Title: CppCon 2019: Matthew Fleming “The Smart Pointers I Wish I Had”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
C++ offers two owning smart pointers, and a proposed non-owning smart pointer in the C++20 Library Fundamentals v2 Technical Specification. This talk will cover the kinds of semantics I think are important in a non-owning pointer, why I think more than one is desirable, and why the existing C++ owning smart pointers are sub-optimal for some use-cases. I will show how correct use of non-owning smart pointers can reduce memory lifetime issues, clarify code, and nearly eliminate incorrect ownership.

For asynchronous programming especially, the lifetime of observing pointers can be a source of significant and difficult to debug issues. I'll cover a mental model to use when writing code that helps focus on where lifetime issues might be likely, and where they will be unlikely.
— 
Matthew Fleming
Software Engineer, Pure Storage
I've been working in systems software for almost 20 years now, mostly on virtual memory and filesystems, in both C and C++. I tend to find myself gravitating lower and lower in the stack, to code primitives, library helpers, and getting very close to the hardware.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:09,559 --> 00:00:14,620
hello the countdown clock has begun

00:00:13,280 --> 00:00:18,160
counting down so

00:00:14,620 --> 00:00:22,480
to begin this is my talk on smart

00:00:18,160 --> 00:00:24,310
pointers the original alternate title

00:00:22,480 --> 00:00:26,020
was a click by T title for an

00:00:24,310 --> 00:00:30,070
interesting problem I came up with an

00:00:26,020 --> 00:00:39,610
alternate title instead if my good

00:00:30,070 --> 00:00:41,260
technical problems moment there we go

00:00:39,610 --> 00:00:44,079
so we're gonna fix lifetime issues with

00:00:41,260 --> 00:00:46,030
this one weird trick and fixes of course

00:00:44,079 --> 00:00:50,109
in air quotes because nothing is a

00:00:46,030 --> 00:00:51,969
perfect fix so um my name is Matthew

00:00:50,109 --> 00:00:54,579
Fleming like the title slide said I work

00:00:51,969 --> 00:00:55,989
at pure storage and I want to spend a

00:00:54,579 --> 00:00:58,179
brief moment explaining the kind of

00:00:55,989 --> 00:01:00,579
stuff I work on my experience is that

00:00:58,179 --> 00:01:02,559
talks make a lot more sense and I can

00:01:00,579 --> 00:01:04,300
really do them better if I know what

00:01:02,559 --> 00:01:06,550
problems the author is trying to solve

00:01:04,300 --> 00:01:08,620
because they may not be my problems so

00:01:06,550 --> 00:01:10,900
what I work on happens to be in C++ 11

00:01:08,620 --> 00:01:13,240
we have finally gone through the

00:01:10,900 --> 00:01:16,300
rototilling 2 we think we can switch to

00:01:13,240 --> 00:01:18,190
C++ 17 early next year we are somewhat

00:01:16,300 --> 00:01:22,510
multi-threaded and that we have like 8

00:01:18,190 --> 00:01:24,430
to 64 threads roughly one thread per

00:01:22,510 --> 00:01:26,080
core we so we're not like massively

00:01:24,430 --> 00:01:28,900
multi-bit it's not like it's super tiny

00:01:26,080 --> 00:01:31,150
either our code is almost entirely lock

00:01:28,900 --> 00:01:34,450
free hopefully wait free most of the

00:01:31,150 --> 00:01:36,550
time it is almost entirely asynchronous

00:01:34,450 --> 00:01:39,340
code using a homegrown asynchronous

00:01:36,550 --> 00:01:41,530
programming framework that happily looks

00:01:39,340 --> 00:01:42,910
almost identical to a manual stockless

00:01:41,530 --> 00:01:45,750
co-routine system so I have high hopes

00:01:42,910 --> 00:01:48,970
that I can relatively easily transition

00:01:45,750 --> 00:01:51,880
in a layered way to using actual C++

00:01:48,970 --> 00:01:54,400
cover teens sometime after a C++ 20

00:01:51,880 --> 00:01:58,030
ships I work with about a hundred other

00:01:54,400 --> 00:02:00,610
developers on a 1.3 million ish line of

00:01:58,030 --> 00:02:02,590
code code base and the developers I work

00:02:00,610 --> 00:02:06,250
with they are not C++ experts by any

00:02:02,590 --> 00:02:08,080
means they in fact some of them many of

00:02:06,250 --> 00:02:11,140
them don't know C++ when they come to

00:02:08,080 --> 00:02:12,700
work for us and they're also in addition

00:02:11,140 --> 00:02:14,530
to being new to C++ the new due to

00:02:12,700 --> 00:02:16,090
asynchronous programming they are new to

00:02:14,530 --> 00:02:17,920
thinking about lock-free programming

00:02:16,090 --> 00:02:18,790
they are new to flash storage which is

00:02:17,920 --> 00:02:19,720
what we work on

00:02:18,790 --> 00:02:21,700
they're new to template metaprogramming

00:02:19,720 --> 00:02:23,680
because they've never seen in C++

00:02:21,700 --> 00:02:25,480
they're new to file systems they've

00:02:23,680 --> 00:02:26,799
never had to think about NFS protocols

00:02:25,480 --> 00:02:27,930
or snapshots or anything like that

00:02:26,799 --> 00:02:31,049
before

00:02:27,930 --> 00:02:32,489
and giving them good tools good software

00:02:31,049 --> 00:02:34,620
tools so they can think about their

00:02:32,489 --> 00:02:37,230
problem whether it's snapshots or

00:02:34,620 --> 00:02:38,879
replication or protocol layer things and

00:02:37,230 --> 00:02:41,310
not have to think about the nuts and

00:02:38,879 --> 00:02:44,069
bolts of C++ that's really critical for

00:02:41,310 --> 00:02:46,170
us and specifically for me because I'm

00:02:44,069 --> 00:02:48,989
one of the people who helps maintain our

00:02:46,170 --> 00:02:51,780
internal libraries and this is low ish

00:02:48,989 --> 00:02:53,790
latency flash storage is not low latency

00:02:51,780 --> 00:02:56,549
like high frequency trading but we're

00:02:53,790 --> 00:02:58,409
still looking for you know in our case

00:02:56,549 --> 00:03:00,689
one to three milliseconds for things

00:02:58,409 --> 00:03:03,659
that involve going to across network

00:03:00,689 --> 00:03:05,970
connections so this is a clickbait title

00:03:03,659 --> 00:03:07,739
because that's how you get people to

00:03:05,970 --> 00:03:10,169
come to your talk but there is no silver

00:03:07,739 --> 00:03:13,230
bullet we're not gonna be able to fix

00:03:10,169 --> 00:03:15,450
everything and nothing that's being done

00:03:13,230 --> 00:03:18,750
here is magic it's really a set of um

00:03:15,450 --> 00:03:21,389
both software tools and mental models I

00:03:18,750 --> 00:03:23,219
think we can make things better than the

00:03:21,389 --> 00:03:25,049
existing state of the art or a state of

00:03:23,219 --> 00:03:26,340
the world and and this is going to be

00:03:25,049 --> 00:03:28,439
done through incremental improvements

00:03:26,340 --> 00:03:29,519
the same way shared Twitter and unique

00:03:28,439 --> 00:03:32,430
Twitter we're an incremental improvement

00:03:29,519 --> 00:03:35,659
I'll be at a big one over previous smart

00:03:32,430 --> 00:03:37,500
pointer systems I will probably say some

00:03:35,659 --> 00:03:38,760
controversial things in which case

00:03:37,500 --> 00:03:40,889
better is in the eye of the beholder

00:03:38,760 --> 00:03:42,299
this happens to be my hour so my

00:03:40,889 --> 00:03:46,229
opinions are mostly correct right now

00:03:42,299 --> 00:03:48,389
but I'm just a guy and I did give a talk

00:03:46,229 --> 00:03:51,030
at C++ now called an alternate smart

00:03:48,389 --> 00:03:53,250
player yarn pointer hierarchy I focused

00:03:51,030 --> 00:03:55,530
in that talk a lot more on some

00:03:53,250 --> 00:03:56,939
interesting alternative boning smart

00:03:55,530 --> 00:03:59,669
pointer semantics and so I'm gonna focus

00:03:56,939 --> 00:04:01,829
in this talk instead on non owning smart

00:03:59,669 --> 00:04:03,419
pointers but there is a link there to

00:04:01,829 --> 00:04:04,819
the YouTube talk if you want to check

00:04:03,419 --> 00:04:08,280
that out at some point

00:04:04,819 --> 00:04:10,169
so my first thesis for this entire talk

00:04:08,280 --> 00:04:12,840
is that none of these coding tools are

00:04:10,169 --> 00:04:16,079
actually needed that is you can write

00:04:12,840 --> 00:04:19,289
100 percent correct C++ code maybe

00:04:16,079 --> 00:04:21,269
modulo exception safety using raw C++

00:04:19,289 --> 00:04:23,599
and so every single one of these tools

00:04:21,269 --> 00:04:25,710
that we add has to add significant value

00:04:23,599 --> 00:04:27,539
like Chandler Carruth was saying in his

00:04:25,710 --> 00:04:29,220
talk there are no zero cost abstractions

00:04:27,539 --> 00:04:32,460
these are abstractions with a mental

00:04:29,220 --> 00:04:34,770
cost hopefully not a actual machine time

00:04:32,460 --> 00:04:38,130
cost and so they should add to our

00:04:34,770 --> 00:04:39,810
understanding of code and not to be more

00:04:38,130 --> 00:04:42,289
costly than what they give it to us in

00:04:39,810 --> 00:04:42,289
benefits

00:04:42,360 --> 00:04:47,310
if you quit definitions when I talk

00:04:44,820 --> 00:04:49,140
about lifetime errors this is in general

00:04:47,310 --> 00:04:50,490
using a pointer or reference when it

00:04:49,140 --> 00:04:51,660
isn't actually pointing to what you

00:04:50,490 --> 00:04:54,240
thought it did

00:04:51,660 --> 00:04:56,610
this can cause a memory corruption it

00:04:54,240 --> 00:04:58,020
could which sometimes people think the

00:04:56,610 --> 00:05:00,270
word corruption is scariest we call it

00:04:58,020 --> 00:05:02,400
scribbling instead because it's a rose

00:05:00,270 --> 00:05:03,900
by any another name and a lot of times

00:05:02,400 --> 00:05:06,780
actually your code just works it just

00:05:03,900 --> 00:05:08,010
depends on what has gone on with with

00:05:06,780 --> 00:05:09,480
the thing you used to point to did it

00:05:08,010 --> 00:05:11,340
get freed to the system and then the

00:05:09,480 --> 00:05:12,660
allocator hasn't bothered returning that

00:05:11,340 --> 00:05:15,120
memory to someone else and so the bits

00:05:12,660 --> 00:05:17,940
are all still the same um you can get a

00:05:15,120 --> 00:05:20,040
double free this can this is when you

00:05:17,940 --> 00:05:21,510
see the same address twice this sort of

00:05:20,040 --> 00:05:23,790
thing can easily cause are their

00:05:21,510 --> 00:05:26,070
lifetime errors because the memory is

00:05:23,790 --> 00:05:28,770
reallocated for somebody else it can

00:05:26,070 --> 00:05:30,000
cause your allocator to get corrupted it

00:05:28,770 --> 00:05:33,270
could cause your holiday hater to crash

00:05:30,000 --> 00:05:34,850
if it has decent debugging or it may

00:05:33,270 --> 00:05:37,620
just sort of silently work for a while

00:05:34,850 --> 00:05:39,540
and use after free is a very similar

00:05:37,620 --> 00:05:40,890
thing where you're using the pointer

00:05:39,540 --> 00:05:43,530
after the underlying memory is freed

00:05:40,890 --> 00:05:44,760
this doesn't always have to be because

00:05:43,530 --> 00:05:46,620
of a double free there are other reasons

00:05:44,760 --> 00:05:49,650
but it's another category of lifetime

00:05:46,620 --> 00:05:51,900
error if you're lucky that's a seg fault

00:05:49,650 --> 00:05:54,540
if you're not lucky something else

00:05:51,900 --> 00:05:56,010
happens so we can use tools to detect a

00:05:54,540 --> 00:05:58,710
lot of these things and I'm not going to

00:05:56,010 --> 00:06:00,900
talk about those tools because tooling

00:05:58,710 --> 00:06:04,290
is really nice and it will help a lot

00:06:00,900 --> 00:06:06,510
but it is not perfect well I love AC on

00:06:04,290 --> 00:06:07,790
it finds a lot of interesting bugs and

00:06:06,510 --> 00:06:10,740
it gives me really useful information

00:06:07,790 --> 00:06:12,390
about what actually went wrong but it

00:06:10,740 --> 00:06:14,550
can't actually catch a timing race until

00:06:12,390 --> 00:06:18,150
that race happens in your code so if you

00:06:14,550 --> 00:06:19,740
have very rare races or very small

00:06:18,150 --> 00:06:21,990
timing windows that never happen to

00:06:19,740 --> 00:06:24,270
occur in your ACN run the tool will not

00:06:21,990 --> 00:06:27,330
find that for you static analysis is

00:06:24,270 --> 00:06:28,890
also really nice but it has some

00:06:27,330 --> 00:06:30,870
knowledge of what it thinks are memory

00:06:28,890 --> 00:06:32,790
lifetimes and other things going on but

00:06:30,870 --> 00:06:35,280
it can't know everything you know and

00:06:32,790 --> 00:06:36,450
and in some sense it either has to give

00:06:35,280 --> 00:06:41,490
you false positives or false negatives

00:06:36,450 --> 00:06:42,960
um testing is nice but again it can only

00:06:41,490 --> 00:06:46,860
find the issues that your tests actually

00:06:42,960 --> 00:06:49,650
cover if you have longer running test

00:06:46,860 --> 00:06:51,300
cases very rare events you're not going

00:06:49,650 --> 00:06:54,000
to hit your actual bugs very often and

00:06:51,300 --> 00:06:55,740
so in the end reading code is the only

00:06:54,000 --> 00:06:57,030
thing I actually trust

00:06:55,740 --> 00:06:59,849
and then convincing myself through

00:06:57,030 --> 00:07:01,620
reading code that that all of my uses of

00:06:59,849 --> 00:07:03,750
memory across asynchronous boundaries is

00:07:01,620 --> 00:07:06,419
actually correct and since I trust

00:07:03,750 --> 00:07:08,250
reading code in the end as the final

00:07:06,419 --> 00:07:09,930
answer to whether something is correct

00:07:08,250 --> 00:07:12,930
I want reading the code to be as simple

00:07:09,930 --> 00:07:14,880
as possible so this is a the first

00:07:12,930 --> 00:07:16,560
guideline I have no owning rob pointers

00:07:14,880 --> 00:07:18,630
we've been talking about this for a

00:07:16,560 --> 00:07:20,130
while you know you've got shared put her

00:07:18,630 --> 00:07:21,479
and unique putter and we've been saying

00:07:20,130 --> 00:07:22,919
you should use this for awhile so this

00:07:21,479 --> 00:07:25,680
should not be a surprise to anybody I

00:07:22,919 --> 00:07:27,090
think you might wonder can you ban the

00:07:25,680 --> 00:07:29,370
delete keyword entirely from your code

00:07:27,090 --> 00:07:33,360
repository and the answer is maybe there

00:07:29,370 --> 00:07:35,520
are reasons why you might need it you

00:07:33,360 --> 00:07:37,289
you may need a Rob pointer that has

00:07:35,520 --> 00:07:38,940
ownership because you're using a precede

00:07:37,289 --> 00:07:41,250
plus plus 14 lambda where you can't move

00:07:38,940 --> 00:07:43,710
things into it you may be using atomic

00:07:41,250 --> 00:07:47,130
updates on some state where you can't

00:07:43,710 --> 00:07:49,199
have a move only type in it because that

00:07:47,130 --> 00:07:50,639
doesn't work with atomic updates unless

00:07:49,199 --> 00:07:54,060
it's the simple case like a single

00:07:50,639 --> 00:07:55,710
shared pointer but these know it using

00:07:54,060 --> 00:07:57,270
smart pointers like share and unique

00:07:55,710 --> 00:07:59,280
order do they do at least fix our memory

00:07:57,270 --> 00:08:01,289
leaks due to miss delete and so it makes

00:07:59,280 --> 00:08:02,570
it harder to have a double free but not

00:08:01,289 --> 00:08:07,979
impossible

00:08:02,570 --> 00:08:10,729
so along that line here's four lines of

00:08:07,979 --> 00:08:17,460
code every single line is incorrect

00:08:10,729 --> 00:08:18,240
every single line compiles so you

00:08:17,460 --> 00:08:20,520
shouldn't do any of these things

00:08:18,240 --> 00:08:21,810
obviously probably the only thing that's

00:08:20,520 --> 00:08:23,340
actually going to crash immediately is

00:08:21,810 --> 00:08:25,409
that fourth line because you're deleting

00:08:23,340 --> 00:08:27,210
the actual thing that's probably

00:08:25,409 --> 00:08:30,719
understaffed not the underlying memory

00:08:27,210 --> 00:08:31,800
so these are you know you might look at

00:08:30,719 --> 00:08:34,079
this and say yeah that's clearly wrong

00:08:31,800 --> 00:08:35,520
but when you get longer pull requests

00:08:34,079 --> 00:08:36,779
when you get buried in a mess of code it

00:08:35,520 --> 00:08:40,500
gets a little bit harder to tell and

00:08:36,779 --> 00:08:41,849
I'll go back to this in a bit so I'm

00:08:40,500 --> 00:08:43,529
gonna slightly modify this guideline

00:08:41,849 --> 00:08:45,510
based on my experience you want to see

00:08:43,529 --> 00:08:48,720
maybe almost no owning rob pointers

00:08:45,510 --> 00:08:50,339
because there are exceptions I think so

00:08:48,720 --> 00:08:52,380
it deletes maybe not a bug but it should

00:08:50,339 --> 00:08:55,050
be really rare in your code and so each

00:08:52,380 --> 00:08:56,820
of the very small number of instances of

00:08:55,050 --> 00:08:59,100
the keyword delete in your code in a

00:08:56,820 --> 00:09:00,450
perfect world should be obviously

00:08:59,100 --> 00:09:03,870
correct and it should be very tightly

00:09:00,450 --> 00:09:05,760
constrained to a small module that you

00:09:03,870 --> 00:09:07,140
know you or some other person who

00:09:05,760 --> 00:09:08,790
understands how to write libraries wrote

00:09:07,140 --> 00:09:09,420
and everyone else just consumes from the

00:09:08,790 --> 00:09:11,760
outside

00:09:09,420 --> 00:09:13,410
and in fact in some sense this is

00:09:11,760 --> 00:09:15,240
exactly what shared a kneading pointer

00:09:13,410 --> 00:09:16,890
are it is a library written by somebody

00:09:15,240 --> 00:09:18,890
smart that you only use from the outside

00:09:16,890 --> 00:09:21,900
but inside it still has to do a delete

00:09:18,890 --> 00:09:24,540
okay so this is an example of code that

00:09:21,900 --> 00:09:25,800
is um this is slide where of course but

00:09:24,540 --> 00:09:28,050
this is very similar to something that

00:09:25,800 --> 00:09:31,080
actually showed up in our source code at

00:09:28,050 --> 00:09:34,100
some point and this code is buggy and

00:09:31,080 --> 00:09:36,570
it's not necessarily obviously buggy and

00:09:34,100 --> 00:09:39,480
the bug that this cause took us two

00:09:36,570 --> 00:09:40,740
months to track down and the reason it

00:09:39,480 --> 00:09:42,900
took two months to track down is this

00:09:40,740 --> 00:09:45,600
particular code path would hit maybe

00:09:42,900 --> 00:09:47,640
once a day on only some of our toughest

00:09:45,600 --> 00:09:52,220
test beds that were doing it running on

00:09:47,640 --> 00:09:55,590
more interesting h8s more fail overs and

00:09:52,220 --> 00:09:57,480
the problem is of course this buggy line

00:09:55,590 --> 00:09:59,610
of code wasn't where we crashed we

00:09:57,480 --> 00:10:01,910
crashed later when we did the thing that

00:09:59,610 --> 00:10:04,230
was actually correct and we had maybe

00:10:01,910 --> 00:10:06,420
two or three hundred instances of this

00:10:04,230 --> 00:10:08,520
kind of notification call back in the

00:10:06,420 --> 00:10:10,230
system and it's hard to go and look

00:10:08,520 --> 00:10:13,830
through all of them to figure out is

00:10:10,230 --> 00:10:15,750
this one right so as you can maybe tell

00:10:13,830 --> 00:10:19,350
the problem here is this error object is

00:10:15,750 --> 00:10:21,000
being passed as a non owning pointer but

00:10:19,350 --> 00:10:23,610
the type system doesn't tell me that it

00:10:21,000 --> 00:10:24,870
was by convention now every single we'd

00:10:23,610 --> 00:10:26,580
never had a single instance of this

00:10:24,870 --> 00:10:28,350
where this was an owning pointer but

00:10:26,580 --> 00:10:29,610
that didn't stop some person at the

00:10:28,350 --> 00:10:31,050
company who didn't know that that was

00:10:29,610 --> 00:10:33,060
the convention from thinking they should

00:10:31,050 --> 00:10:34,410
take ownership and the person who

00:10:33,060 --> 00:10:35,760
reviewed their code also apparently

00:10:34,410 --> 00:10:37,980
didn't know that convention and didn't

00:10:35,760 --> 00:10:40,350
see it in code review and so this

00:10:37,980 --> 00:10:42,780
happened to us once and then we fixed it

00:10:40,350 --> 00:10:46,530
and then maybe a year later it happened

00:10:42,780 --> 00:10:48,420
to us again so this codes buggy and you

00:10:46,530 --> 00:10:50,550
might say great I'll ban that we won't

00:10:48,420 --> 00:10:52,080
have delete in our code base because we

00:10:50,550 --> 00:10:54,480
now have owning smart pointers for

00:10:52,080 --> 00:10:57,000
everything and we'll use rob pointers to

00:10:54,480 --> 00:10:58,920
mean non ownership see AB and that

00:10:57,000 --> 00:11:00,740
keyword delete and your enterprising

00:10:58,920 --> 00:11:03,690
developer and Studds writes this code

00:11:00,740 --> 00:11:05,970
and they very helpfully explain their

00:11:03,690 --> 00:11:11,400
reasoning in a comment that is 100%

00:11:05,970 --> 00:11:12,960
wrong but feels right so this this code

00:11:11,400 --> 00:11:15,000
will also compile it'll do exactly what

00:11:12,960 --> 00:11:20,000
you don't want and again it may not be

00:11:15,000 --> 00:11:23,250
spotted in code review so this code

00:11:20,000 --> 00:11:26,220
using a C++ 20 feature I'll cover it

00:11:23,250 --> 00:11:28,199
this code it won't compile to actually

00:11:26,220 --> 00:11:30,300
take ownership of this resource

00:11:28,199 --> 00:11:32,490
we've been explicit through the type

00:11:30,300 --> 00:11:35,910
system that I am observing this error I

00:11:32,490 --> 00:11:37,490
am not owning it and so I can't without

00:11:35,910 --> 00:11:39,449
typing a lot more characters

00:11:37,490 --> 00:11:43,259
accidentally take ownership and do the

00:11:39,449 --> 00:11:44,910
wrong thing we pushed through a change

00:11:43,259 --> 00:11:47,069
to our code base about like this it took

00:11:44,910 --> 00:11:48,329
me four weeks working on it on and off

00:11:47,069 --> 00:11:49,800
because there were literally hundreds

00:11:48,329 --> 00:11:51,480
and hundreds of sites that it had to fix

00:11:49,800 --> 00:11:53,100
and then verify that I didn't break

00:11:51,480 --> 00:11:54,720
anything and I think the first attempt

00:11:53,100 --> 00:11:56,250
then ran afoul of something weird where

00:11:54,720 --> 00:11:57,089
the optimizer didn't like the code quite

00:11:56,250 --> 00:11:58,800
as much and so we had a small

00:11:57,089 --> 00:12:00,689
performance regression and it back the

00:11:58,800 --> 00:12:02,970
whole thing out and then stare carefully

00:12:00,689 --> 00:12:04,620
at assembly and then fix it again but um

00:12:02,970 --> 00:12:06,269
it was definitely worth doing because we

00:12:04,620 --> 00:12:07,769
will never see this bug again and that's

00:12:06,269 --> 00:12:09,740
nice because I don't want to waste a

00:12:07,769 --> 00:12:12,720
month of my life debugging it ever again

00:12:09,740 --> 00:12:14,430
so my second thesis then is being

00:12:12,720 --> 00:12:16,800
explicit is being is better than being

00:12:14,430 --> 00:12:18,720
implicit the the bug we ran into is

00:12:16,800 --> 00:12:20,730
because we had this implicit idea that

00:12:18,720 --> 00:12:21,810
we were non owning and if I can just be

00:12:20,730 --> 00:12:23,220
explicit about it

00:12:21,810 --> 00:12:24,930
with a little bit of help from the type

00:12:23,220 --> 00:12:26,310
system it makes it harder to actually

00:12:24,930 --> 00:12:30,240
type bugs because they won't even

00:12:26,310 --> 00:12:32,939
compile so guideline number two known on

00:12:30,240 --> 00:12:36,029
owning raw pointers we have observer put

00:12:32,939 --> 00:12:38,189
er in C++ 20 this is definitely an

00:12:36,029 --> 00:12:41,279
improvement over using raw pointers um

00:12:38,189 --> 00:12:43,019
in my experience with the code I've had

00:12:41,279 --> 00:12:45,689
to deal with and the current proposed

00:12:43,019 --> 00:12:47,610
API it gets me about 70% of the way to

00:12:45,689 --> 00:12:51,600
solving the problem I want and I'll

00:12:47,610 --> 00:12:53,100
cover that also um and unlike your

00:12:51,600 --> 00:12:54,870
owning pointers where there may be

00:12:53,100 --> 00:12:56,730
special circumstances where you can't

00:12:54,870 --> 00:12:59,100
convert an owning pointer from a raw

00:12:56,730 --> 00:13:01,379
pointer to a smart pointer because of

00:12:59,100 --> 00:13:02,579
move only semantics you actually can or

00:13:01,379 --> 00:13:04,709
should be able to convert a hundred

00:13:02,579 --> 00:13:06,629
percent of your non owning pointers to

00:13:04,709 --> 00:13:08,910
using this kind of observer pointer and

00:13:06,629 --> 00:13:11,790
so because you can always get the raw

00:13:08,910 --> 00:13:13,920
pointer back for legacy api's and it's

00:13:11,790 --> 00:13:15,449
trivially copyable and assignable so it

00:13:13,920 --> 00:13:20,089
should flow through your code much more

00:13:15,449 --> 00:13:22,800
like a raw pointer does so thesis 3 then

00:13:20,089 --> 00:13:24,329
these types these smart pointer types

00:13:22,800 --> 00:13:27,509
work best when I have less code to

00:13:24,329 --> 00:13:28,949
change so like just the way like a raw

00:13:27,509 --> 00:13:30,660
pointer I just pass it from function to

00:13:28,949 --> 00:13:33,029
function and it happily compiles and it

00:13:30,660 --> 00:13:35,309
just moves along I would like these

00:13:33,029 --> 00:13:36,720
owning and not owning pointers to flow

00:13:35,309 --> 00:13:38,430
trivially through my code I should

00:13:36,720 --> 00:13:41,310
have to do a lot of conversions to go

00:13:38,430 --> 00:13:43,589
from owning to non owning and from non

00:13:41,310 --> 00:13:44,790
owning to raw pointer if I believe well

00:13:43,589 --> 00:13:47,579
I should have to do some to make it go

00:13:44,790 --> 00:13:48,930
to rock point or as a cover um but I'd

00:13:47,579 --> 00:13:52,529
like them to flow more trivially through

00:13:48,930 --> 00:13:53,970
my code so this is um let me give you a

00:13:52,529 --> 00:13:55,769
brief for those who don't know this is

00:13:53,970 --> 00:13:58,560
you know a slide where version of

00:13:55,769 --> 00:14:00,209
observer pointer there's I'm ignoring

00:13:58,560 --> 00:14:03,029
public and private and other things but

00:14:00,209 --> 00:14:05,699
essentially there's just a single member

00:14:03,029 --> 00:14:07,860
which is the raw pointer I have a

00:14:05,699 --> 00:14:09,269
explicit constructor which will take in

00:14:07,860 --> 00:14:11,009
a pointer and assign and put it in I

00:14:09,269 --> 00:14:12,720
have a defaulted copy and move

00:14:11,009 --> 00:14:14,939
constructor defaulted copy and

00:14:12,720 --> 00:14:16,949
assignment I have a conversion from some

00:14:14,939 --> 00:14:18,449
other kind of observer pointer with a

00:14:16,949 --> 00:14:19,490
different template type as long as the

00:14:18,449 --> 00:14:23,670
types are convertible

00:14:19,490 --> 00:14:25,680
it has release reset bool get arrow and

00:14:23,670 --> 00:14:28,680
star and other utility functions to

00:14:25,680 --> 00:14:31,769
match unique pointer and this is one

00:14:28,680 --> 00:14:33,810
place where you might were you as a user

00:14:31,769 --> 00:14:35,310
of this might have disagreements with

00:14:33,810 --> 00:14:37,740
the C++ committee about what's a good

00:14:35,310 --> 00:14:39,779
idea and the thing is for example

00:14:37,740 --> 00:14:41,430
release makes a lot of sense on an

00:14:39,779 --> 00:14:43,110
owning pointer because it owns a

00:14:41,430 --> 00:14:44,850
resource I would like to release it and

00:14:43,110 --> 00:14:46,470
switch to give me back the rock pointer

00:14:44,850 --> 00:14:47,970
to do something funny with and reset

00:14:46,470 --> 00:14:50,220
itself to null because otherwise that is

00:14:47,970 --> 00:14:52,290
a double free for a non owning pointer

00:14:50,220 --> 00:14:53,910
that function the semantics of that

00:14:52,290 --> 00:14:56,819
function isn't as useful

00:14:53,910 --> 00:14:58,980
my assumption having not participated in

00:14:56,819 --> 00:15:00,449
any of the deliberations my assumption

00:14:58,980 --> 00:15:03,059
is that that's here because it will

00:15:00,449 --> 00:15:05,939
match a owning smart pointer and so you

00:15:03,059 --> 00:15:06,930
can do more generic programming they're

00:15:05,939 --> 00:15:09,089
probably good reasons for that

00:15:06,930 --> 00:15:12,300
it also sometimes maybe seems like a bad

00:15:09,089 --> 00:15:13,620
idea to me in that if I'm doing generic

00:15:12,300 --> 00:15:15,300
programming on a thing I think is an

00:15:13,620 --> 00:15:16,829
owning pointer I might actually do

00:15:15,300 --> 00:15:18,509
different things than with a non winning

00:15:16,829 --> 00:15:20,339
pointer and so the existence of a

00:15:18,509 --> 00:15:21,899
function like release may make me think

00:15:20,339 --> 00:15:23,699
I have to do a very specific thing with

00:15:21,899 --> 00:15:24,959
it other than hopefully just shove it

00:15:23,699 --> 00:15:27,870
right back into the type it came from

00:15:24,959 --> 00:15:29,910
eventually so it is it is this sort of

00:15:27,870 --> 00:15:31,500
clear to people what the how observe

00:15:29,910 --> 00:15:33,569
reporter is kind of implemented under

00:15:31,500 --> 00:15:37,500
the covers all right I'm seeing nodding

00:15:33,569 --> 00:15:40,559
um so one problem I personally have with

00:15:37,500 --> 00:15:43,410
this in terms of ergonomics there's no

00:15:40,559 --> 00:15:44,819
implicit conversion from a unique

00:15:43,410 --> 00:15:47,429
pointer or a shared pointer into

00:15:44,819 --> 00:15:49,500
observer pointer I have to do I have to

00:15:47,429 --> 00:15:50,410
stand on my head a little bit to create

00:15:49,500 --> 00:15:52,240
one of these things

00:15:50,410 --> 00:15:55,180
and that makes it harder to craft

00:15:52,240 --> 00:15:57,879
correct api's because in some sense the

00:15:55,180 --> 00:16:01,569
whole point of having a non owning smart

00:15:57,879 --> 00:16:03,819
pointer um is that if I'm explicit about

00:16:01,569 --> 00:16:05,829
ownership and non ownership the type

00:16:03,819 --> 00:16:07,930
system has already protected me from

00:16:05,829 --> 00:16:10,060
accidentally creating double ownership

00:16:07,930 --> 00:16:11,949
when I shouldn't I can easily make it

00:16:10,060 --> 00:16:13,689
not compile when I don't want it to I

00:16:11,949 --> 00:16:15,839
can't get Rob pointers back out easily

00:16:13,689 --> 00:16:17,769
so why should it be hard to take

00:16:15,839 --> 00:16:19,089
something that has ownership and

00:16:17,769 --> 00:16:20,769
trivially create something that it

00:16:19,089 --> 00:16:22,300
doesn't have ownership when I'm actually

00:16:20,769 --> 00:16:24,759
now being explicit that I don't have

00:16:22,300 --> 00:16:27,399
ownership in my mind this makes it just

00:16:24,759 --> 00:16:28,629
harder to use the code but that is a

00:16:27,399 --> 00:16:31,660
good question though should you be able

00:16:28,629 --> 00:16:33,189
to trivially get a non owning pointer

00:16:31,660 --> 00:16:34,779
from an owning one and this is again a

00:16:33,189 --> 00:16:38,769
place of tension perhaps between

00:16:34,779 --> 00:16:42,399
ultimate safety and convenience I have a

00:16:38,769 --> 00:16:45,339
little bit of example code there the

00:16:42,399 --> 00:16:47,290
idea is here I probably don't have this

00:16:45,339 --> 00:16:49,720
kind of overload set I would not have a

00:16:47,290 --> 00:16:51,430
function that both takes a non owning

00:16:49,720 --> 00:16:53,050
pointer and takes a reference to an

00:16:51,430 --> 00:16:54,670
owning pointer and in fact I probably

00:16:53,050 --> 00:16:56,439
wouldn't often write a function that

00:16:54,670 --> 00:16:57,910
takes a reference to an owning pointer

00:16:56,439 --> 00:16:59,170
because the question that is what am i

00:16:57,910 --> 00:17:00,819
doing with it I'm not transferring

00:16:59,170 --> 00:17:02,319
ownership I'm saying here you can have

00:17:00,819 --> 00:17:03,519
it and maybe you can fiddle with it but

00:17:02,319 --> 00:17:05,409
I'm not really giving it to you but you

00:17:03,519 --> 00:17:07,059
might take it anyway that's sort of a

00:17:05,409 --> 00:17:08,289
weird thing to do and if it's something

00:17:07,059 --> 00:17:10,089
that should be filled in like a return

00:17:08,289 --> 00:17:12,339
value that should probably be a return

00:17:10,089 --> 00:17:14,020
value so it's it's a weird thing to have

00:17:12,339 --> 00:17:15,669
and so then I would like this code lines

00:17:14,020 --> 00:17:18,640
four and five I'd like to just compile

00:17:15,669 --> 00:17:20,470
and work because I have something that

00:17:18,640 --> 00:17:22,150
has ownership but I don't I don't need

00:17:20,470 --> 00:17:23,709
to know it has ownership to know that

00:17:22,150 --> 00:17:25,630
calling that functions safe because the

00:17:23,709 --> 00:17:26,770
type system already protects me the same

00:17:25,630 --> 00:17:28,659
way the type system protects you from

00:17:26,770 --> 00:17:30,340
making mistakes with if you have enough

00:17:28,659 --> 00:17:31,630
warnings and other filter bits it

00:17:30,340 --> 00:17:33,909
prevents you from making mistakes with

00:17:31,630 --> 00:17:35,289
Long's vs intz or Long's and doubles etc

00:17:33,909 --> 00:17:39,400
you get some protection from the

00:17:35,289 --> 00:17:41,080
compiler against screw-ups ah which ever

00:17:39,400 --> 00:17:42,970
lived wanted to go I do not well so if I

00:17:41,080 --> 00:17:44,530
had both it will call number one because

00:17:42,970 --> 00:17:46,390
but I don't think number one doesn't

00:17:44,530 --> 00:17:47,679
overload should exist sorry that was a

00:17:46,390 --> 00:17:49,480
the question was which overlit should a

00:17:47,679 --> 00:17:52,750
call if that wasn't clear from context

00:17:49,480 --> 00:17:54,280
okay so here's one of my possibly

00:17:52,750 --> 00:17:56,110
controversial statements harkening back

00:17:54,280 --> 00:17:58,539
to Dijkstra's considered harmful

00:17:56,110 --> 00:18:03,130
so is dot get actually even a good idea

00:17:58,539 --> 00:18:04,750
at all um and in 2011 I would say yes it

00:18:03,130 --> 00:18:06,730
definitely was right I was in a

00:18:04,750 --> 00:18:08,110
world in 2011 were basically everything

00:18:06,730 --> 00:18:10,090
was either raw printer or auto putter

00:18:08,110 --> 00:18:13,330
neither of which I really wanted and so

00:18:10,090 --> 00:18:15,400
I have some now pretty decent owning

00:18:13,330 --> 00:18:16,990
smart pointer types but I have a lot of

00:18:15,400 --> 00:18:18,490
legacy code that wants a rock pointer

00:18:16,990 --> 00:18:20,260
and I probably don't want to have to do

00:18:18,490 --> 00:18:23,050
a lot of typing to work with that code

00:18:20,260 --> 00:18:25,540
so dot get is relatively short and it's

00:18:23,050 --> 00:18:26,020
pretty convenient and and and so it

00:18:25,540 --> 00:18:28,960
works

00:18:26,020 --> 00:18:30,670
um the trouble I think is now it's it's

00:18:28,960 --> 00:18:33,850
another eight or nine years since then

00:18:30,670 --> 00:18:34,900
and hopefully a lot more code bases have

00:18:33,850 --> 00:18:37,300
moved toward this world where this

00:18:34,900 --> 00:18:39,490
ownership is more explicit and if I make

00:18:37,300 --> 00:18:40,960
it easy to get back a rock pointer when

00:18:39,490 --> 00:18:43,000
my whole idea of my system is that I

00:18:40,960 --> 00:18:45,850
shouldn't have rock pointers I feel like

00:18:43,000 --> 00:18:48,850
I'm going backwards so in some sense as

00:18:45,850 --> 00:18:50,350
a design point for the non owning smart

00:18:48,850 --> 00:18:53,080
even a known actually for any smart

00:18:50,350 --> 00:18:54,730
pointer that I want to work with long

00:18:53,080 --> 00:18:57,550
term I actually want to make it really

00:18:54,730 --> 00:18:59,680
hard to subvert ownership and getting a

00:18:57,550 --> 00:19:01,990
rob pointer back from either an owning

00:18:59,680 --> 00:19:06,030
or a non owning pointer makes it much

00:19:01,990 --> 00:19:09,220
easier to trivially create unexpected

00:19:06,030 --> 00:19:12,550
incorrect ownership and I will have some

00:19:09,220 --> 00:19:13,900
examples of that later also so here I've

00:19:12,550 --> 00:19:15,790
got a legacy function that takes a raw

00:19:13,900 --> 00:19:18,070
pointer and I'm calling it four

00:19:15,790 --> 00:19:20,350
different ways every single one of these

00:19:18,070 --> 00:19:23,200
will compile which one of these looks

00:19:20,350 --> 00:19:24,820
like a bug or at least which one of

00:19:23,200 --> 00:19:26,170
these looks like a thing that if you saw

00:19:24,820 --> 00:19:27,730
it in a code review or when you're

00:19:26,170 --> 00:19:28,960
trying to chase down a weird memory

00:19:27,730 --> 00:19:30,370
corruption error which one of these

00:19:28,960 --> 00:19:32,530
lines of code would you actually look at

00:19:30,370 --> 00:19:36,550
and see dang that's that's probably not

00:19:32,530 --> 00:19:37,750
right so my argument is yeah so number

00:19:36,550 --> 00:19:39,460
two would look funny right because

00:19:37,750 --> 00:19:40,780
ampersand star when I start putting

00:19:39,460 --> 00:19:43,360
symbols together I'm probably doing

00:19:40,780 --> 00:19:45,550
something weird my argument is number

00:19:43,360 --> 00:19:48,190
one doesn't look very scary and that's

00:19:45,550 --> 00:19:50,230
what the state of the art is today at

00:19:48,190 --> 00:19:51,760
work because we were we have our own

00:19:50,230 --> 00:19:54,670
smart pointer types at work because we

00:19:51,760 --> 00:19:56,710
started the code pre C++ 11 and it

00:19:54,670 --> 00:19:58,870
existed long enough before we got 11

00:19:56,710 --> 00:20:00,220
compilers we're not going to change and

00:19:58,870 --> 00:20:03,130
we're actually going through the process

00:20:00,220 --> 00:20:05,170
of removing get from our smart pointer

00:20:03,130 --> 00:20:07,060
types entirely and the function name we

00:20:05,170 --> 00:20:09,460
came up with to replace that we called

00:20:07,060 --> 00:20:11,890
Rob pointer ignoring lifetime because

00:20:09,460 --> 00:20:14,679
it's a mouthful it's a lot of letters to

00:20:11,890 --> 00:20:17,590
type it is not convenient it is not a

00:20:14,679 --> 00:20:18,550
ergonomic and it looks scary and it

00:20:17,590 --> 00:20:22,450
tells you exactly

00:20:18,550 --> 00:20:23,050
is doing by the way if you type number

00:20:22,450 --> 00:20:27,840
four

00:20:23,050 --> 00:20:32,440
you should really rethink your decisions

00:20:27,840 --> 00:20:34,510
so I mentioned the implicit conversion

00:20:32,440 --> 00:20:36,340
from an owning pointer to transition to

00:20:34,510 --> 00:20:37,750
non owning because as long as it's hard

00:20:36,340 --> 00:20:39,280
to go from non owning back to owning

00:20:37,750 --> 00:20:41,590
that's a safe transition it should be

00:20:39,280 --> 00:20:44,170
easy in my opinion I would actually also

00:20:41,590 --> 00:20:46,630
like it to be trivial to go from a rob

00:20:44,170 --> 00:20:49,720
pointer to a non owning pointer um

00:20:46,630 --> 00:20:51,310
it's it can't be in the sense and

00:20:49,720 --> 00:20:53,170
sometimes it can't be unsafe because

00:20:51,310 --> 00:20:55,420
I've I've made it if I've made it hard

00:20:53,170 --> 00:20:59,110
to get the rob pointer back from this

00:20:55,420 --> 00:21:01,090
non owning smart pointer it's safe to go

00:20:59,110 --> 00:21:02,830
from a raw pointer to an on owning smart

00:21:01,090 --> 00:21:04,480
pointer I can't accidentally turn it

00:21:02,830 --> 00:21:07,630
back into an owning pointer whether it

00:21:04,480 --> 00:21:09,580
should have been or not so and and if I

00:21:07,630 --> 00:21:12,220
don't have something like this it makes

00:21:09,580 --> 00:21:14,590
it very hard to pick a place in my code

00:21:12,220 --> 00:21:17,050
base where I start converting from non

00:21:14,590 --> 00:21:19,570
owning Rob pointers to non owning smart

00:21:17,050 --> 00:21:21,220
pointers because wherever I pick I have

00:21:19,570 --> 00:21:22,300
people above me or below me and I have

00:21:21,220 --> 00:21:24,520
to type I have to do something

00:21:22,300 --> 00:21:29,650
inconvenient to get back into the legacy

00:21:24,520 --> 00:21:31,450
functions I haven't converted yet um so

00:21:29,650 --> 00:21:35,470
we can't implicitly convert from a rob

00:21:31,450 --> 00:21:37,930
pointer maybe we'd like to but there is

00:21:35,470 --> 00:21:41,530
a reason not to of course so for one

00:21:37,930 --> 00:21:43,090
thing the the explicit constructor from

00:21:41,530 --> 00:21:44,560
a Rob point or matches that of shared

00:21:43,090 --> 00:21:45,670
and unique pointer where it actually

00:21:44,560 --> 00:21:48,130
makes a lot of sense I should be very

00:21:45,670 --> 00:21:49,990
explicit that I'm taking ownership but

00:21:48,130 --> 00:21:52,780
there also could be if your code is like

00:21:49,990 --> 00:21:54,400
mine you have um you have some factory

00:21:52,780 --> 00:21:55,840
functions and you lived in an old world

00:21:54,400 --> 00:21:57,130
where factory functions return to raw

00:21:55,840 --> 00:21:58,120
pointer and they just had a comment

00:21:57,130 --> 00:22:00,730
saying yeah you need to take ownership

00:21:58,120 --> 00:22:02,080
of this and that's you know the comments

00:22:00,730 --> 00:22:05,070
all cute nah but the type system doesn't

00:22:02,080 --> 00:22:09,160
help me I would actually like that

00:22:05,070 --> 00:22:10,750
owning Rob pointer to not implicitly

00:22:09,160 --> 00:22:13,750
become a non winning pointer and that

00:22:10,750 --> 00:22:15,220
actually turns out to be really hard so

00:22:13,750 --> 00:22:19,090
the the prototype that I showed for

00:22:15,220 --> 00:22:20,380
observer putter took a raw T star and it

00:22:19,090 --> 00:22:21,760
would be really great if I could type

00:22:20,380 --> 00:22:25,240
something like those bottom two lines

00:22:21,760 --> 00:22:26,440
where I could take the watch I can type

00:22:25,240 --> 00:22:28,600
those two lines but it doesn't quit do

00:22:26,440 --> 00:22:30,100
what I want so there's a couple ways to

00:22:28,600 --> 00:22:31,840
construct this none of which actually

00:22:30,100 --> 00:22:32,260
works as I discovered last night when I

00:22:31,840 --> 00:22:35,980
was

00:22:32,260 --> 00:22:40,419
putting examples up on God bolt so what

00:22:35,980 --> 00:22:42,309
I want is to implicitly convert a Const

00:22:40,419 --> 00:22:44,740
reference to a Rob pointer because

00:22:42,309 --> 00:22:46,480
that's a value type it's an L value and

00:22:44,740 --> 00:22:47,830
L value means is already inside a raw

00:22:46,480 --> 00:22:50,200
pointer and if it's already a Rob

00:22:47,830 --> 00:22:53,019
pointer that's great and I would like to

00:22:50,200 --> 00:22:54,610
not convert from an R value of a raw

00:22:53,019 --> 00:22:56,830
pointer which is a thing you can type

00:22:54,610 --> 00:22:58,029
and I didn't know this until I started

00:22:56,830 --> 00:23:00,669
working at this job it's a thing you can

00:22:58,029 --> 00:23:02,080
type the type system is happy the

00:23:00,669 --> 00:23:05,500
problem is that that doesn't end up

00:23:02,080 --> 00:23:07,330
working if I make it explicit I will

00:23:05,500 --> 00:23:10,330
never select that overload unless I'm

00:23:07,330 --> 00:23:11,679
actually explicit in a implicit context

00:23:10,330 --> 00:23:12,730
a compiler will say well you didn't say

00:23:11,679 --> 00:23:14,440
you wanted this one because you weren't

00:23:12,730 --> 00:23:16,210
explicit so let me see if I can convert

00:23:14,440 --> 00:23:18,700
to any of the other constructors and it

00:23:16,210 --> 00:23:20,350
can implicitly convert an R value

00:23:18,700 --> 00:23:21,880
reference into a Const value reference

00:23:20,350 --> 00:23:23,860
that's a safe conversion according to

00:23:21,880 --> 00:23:26,649
the type system as best I understand I

00:23:23,860 --> 00:23:27,820
could say equals delete that does do

00:23:26,649 --> 00:23:29,200
what you want because I'm not singing

00:23:27,820 --> 00:23:31,570
explicit I'm just saying you just can't

00:23:29,200 --> 00:23:34,720
make an owning pointer an on owning

00:23:31,570 --> 00:23:36,730
pointer from an R value Rob pointer the

00:23:34,720 --> 00:23:39,039
problem is that doesn't let me say some

00:23:36,730 --> 00:23:41,049
other things I want to because for

00:23:39,039 --> 00:23:43,389
example ampersand foo is actually our

00:23:41,049 --> 00:23:45,519
value of a pointer and then I couldn't

00:23:43,389 --> 00:23:47,590
pass the address of a local variable as

00:23:45,519 --> 00:23:50,380
a non owning pointer which is clearly

00:23:47,590 --> 00:23:51,700
something I'd like to do I think so I

00:23:50,380 --> 00:23:54,789
don't know how to solve this problem

00:23:51,700 --> 00:23:56,380
exactly you could argue that maybe I

00:23:54,789 --> 00:23:58,059
don't need to the fact that this is a

00:23:56,380 --> 00:24:00,010
non owning pointer means the worst that

00:23:58,059 --> 00:24:03,730
happens as a memory leak which is better

00:24:00,010 --> 00:24:04,779
than most alternatives so that's in some

00:24:03,730 --> 00:24:06,700
sense the end of what I'm going to talk

00:24:04,779 --> 00:24:07,990
about about pointers themselves and I'm

00:24:06,700 --> 00:24:10,120
going to move on to references because

00:24:07,990 --> 00:24:11,919
in a lot of ways a reference is just a

00:24:10,120 --> 00:24:14,380
pointer it's just got some syntactic

00:24:11,919 --> 00:24:17,440
goop around it and a small assumption

00:24:14,380 --> 00:24:18,789
that it's probably not null you could

00:24:17,440 --> 00:24:20,289
say it's definitely not null except that

00:24:18,789 --> 00:24:21,940
you can construct a null reference and

00:24:20,289 --> 00:24:24,039
you can't check that it's null because

00:24:21,940 --> 00:24:25,929
the compiler will actually omit your

00:24:24,039 --> 00:24:28,019
code under optimization because it knows

00:24:25,929 --> 00:24:32,230
the address isn't at all its reference

00:24:28,019 --> 00:24:34,740
so which I've got two functions I'm

00:24:32,230 --> 00:24:37,269
calling local variables foo and bar

00:24:34,740 --> 00:24:42,250
which one of these two functions could

00:24:37,269 --> 00:24:43,690
modify its arguments right we're C++

00:24:42,250 --> 00:24:45,490
programmers we actually know that both

00:24:43,690 --> 00:24:49,090
of those could modify their arguments

00:24:45,490 --> 00:24:50,679
great that's a troublesome though

00:24:49,090 --> 00:24:52,179
because one of them kind of looks at

00:24:50,679 --> 00:24:54,040
first glance like it doesn't and it

00:24:52,179 --> 00:24:57,040
looks like denticles to code that

00:24:54,040 --> 00:24:58,690
doesn't mutate its arguments because the

00:24:57,040 --> 00:25:01,510
prototype says I'm taking by value or

00:24:58,690 --> 00:25:02,890
cost reference so I'm Google style guide

00:25:01,510 --> 00:25:05,200
will tell us that we should prefer

00:25:02,890 --> 00:25:07,210
return values of her out pointers or

00:25:05,200 --> 00:25:09,490
output parameters but if we do have an

00:25:07,210 --> 00:25:11,500
output parameter we have to pass it by

00:25:09,490 --> 00:25:13,809
pointer and that's to make that issue

00:25:11,500 --> 00:25:16,240
explicit in your code you you've made

00:25:13,809 --> 00:25:20,080
visible that you were possibly mutating

00:25:16,240 --> 00:25:22,630
the input bloomberg's style guide goes

00:25:20,080 --> 00:25:25,420
even further not only should output

00:25:22,630 --> 00:25:28,420
always be passed by pointer not by

00:25:25,420 --> 00:25:30,490
reference or any other type inputs where

00:25:28,420 --> 00:25:32,200
the address is going to be retained past

00:25:30,490 --> 00:25:35,080
the initial function call must also be

00:25:32,200 --> 00:25:36,760
passed by pointer and that solves again

00:25:35,080 --> 00:25:39,070
the problem that you thought may be a

00:25:36,760 --> 00:25:40,960
pasty value maybe you didn't but the

00:25:39,070 --> 00:25:44,559
code underneath actually is holding on

00:25:40,960 --> 00:25:46,330
to a handle to your memory past the time

00:25:44,559 --> 00:25:48,010
when you think it could be done with it

00:25:46,330 --> 00:25:49,990
so this is again about making explicit

00:25:48,010 --> 00:25:52,090
but instead of making explicit what can

00:25:49,990 --> 00:25:54,460
be mutated this is now making lifetime

00:25:52,090 --> 00:25:58,420
explicit by saying in our style you have

00:25:54,460 --> 00:26:00,400
to pass by pointer not by reference and

00:25:58,420 --> 00:26:01,840
so I find it interesting that that more

00:26:00,400 --> 00:26:04,559
than one company has decided that

00:26:01,840 --> 00:26:09,490
passing by mutating reference is maybe

00:26:04,559 --> 00:26:10,450
it works but it um it's unclear so now

00:26:09,490 --> 00:26:12,670
that we're thinking about maybe

00:26:10,450 --> 00:26:14,410
asynchronous programming lifetime errors

00:26:12,670 --> 00:26:17,160
which one of these two lines of code

00:26:14,410 --> 00:26:17,160
could seg fault

00:26:17,220 --> 00:26:22,890
so both of them could seg fault unless

00:26:20,440 --> 00:26:25,300
foo is actually a value not a reference

00:26:22,890 --> 00:26:27,010
if it's a value then that can't seg

00:26:25,300 --> 00:26:28,330
fault because it's all it's just a

00:26:27,010 --> 00:26:29,920
structure member it's just I've got a

00:26:28,330 --> 00:26:32,140
valid address I'm bumping it up by a

00:26:29,920 --> 00:26:36,100
little bit which one of these can site

00:26:32,140 --> 00:26:38,380
fault again the answer is it depends if

00:26:36,100 --> 00:26:41,640
foo is a reference they both could if

00:26:38,380 --> 00:26:43,660
foo is a value only one of them will

00:26:41,640 --> 00:26:47,110
which one of these two can see garbage

00:26:43,660 --> 00:26:52,660
data it's the same issue again it

00:26:47,110 --> 00:26:55,780
depends on the type of foo the trouble I

00:26:52,660 --> 00:26:57,700
have with this and the thing I get the

00:26:55,780 --> 00:26:58,910
reason I like those style guides is

00:26:57,700 --> 00:27:01,100
because

00:26:58,910 --> 00:27:03,230
this this brings up what I've been

00:27:01,100 --> 00:27:04,910
calling non-local reasoning I haven't

00:27:03,230 --> 00:27:06,350
seen this term used elsewhere if someone

00:27:04,910 --> 00:27:09,440
else has a word for it I'd love to hear

00:27:06,350 --> 00:27:10,880
about it the idea is the further away

00:27:09,440 --> 00:27:12,170
from a line of code I have to go to

00:27:10,880 --> 00:27:14,210
actually find the answer to my question

00:27:12,170 --> 00:27:16,700
the longer it takes me to debug things

00:27:14,210 --> 00:27:18,770
it takes more mental effort I have to

00:27:16,700 --> 00:27:19,880
enslave scrutinising three lines of code

00:27:18,770 --> 00:27:21,950
in a function I have to scrutinize

00:27:19,880 --> 00:27:23,240
almost everyone because I'm calling

00:27:21,950 --> 00:27:25,280
functions and I'm passing things that

00:27:23,240 --> 00:27:26,720
maybe their values maybe their

00:27:25,280 --> 00:27:28,790
conferences maybe their mutable

00:27:26,720 --> 00:27:31,010
references I can't tell from the call

00:27:28,790 --> 00:27:32,300
site and so maybe I've got an IDE that's

00:27:31,010 --> 00:27:33,530
helpful or maybe you're really

00:27:32,300 --> 00:27:35,330
old-school like me and now you're doing

00:27:33,530 --> 00:27:36,590
get grabbed and looking in see scope and

00:27:35,330 --> 00:27:42,110
hoping that you found the right overload

00:27:36,590 --> 00:27:43,220
and stuff and so I think it would be

00:27:42,110 --> 00:27:46,460
really nice if we could start being

00:27:43,220 --> 00:27:47,480
explicit about this sort of thing I have

00:27:46,460 --> 00:27:49,430
one more point on that I think I'm going

00:27:47,480 --> 00:27:53,060
to repeat it later but the other point

00:27:49,430 --> 00:27:56,990
about this is um when I have those

00:27:53,060 --> 00:27:59,270
references you know food bar that could

00:27:56,990 --> 00:28:01,880
be a cache miss pointer dereference or

00:27:59,270 --> 00:28:04,640
something or it may not be foo arrow is

00:28:01,880 --> 00:28:08,270
always one thing and I would really like

00:28:04,640 --> 00:28:09,890
it if one way of saying things couldn't

00:28:08,270 --> 00:28:11,210
mean two things because I think that's

00:28:09,890 --> 00:28:12,380
where a big part of the mental burden

00:28:11,210 --> 00:28:13,730
comes from I have one way of saying

00:28:12,380 --> 00:28:15,380
things but it actually means two

00:28:13,730 --> 00:28:17,450
different things depending on context in

00:28:15,380 --> 00:28:18,950
a sort of a different way than overloads

00:28:17,450 --> 00:28:20,570
that's mean different things because a

00:28:18,950 --> 00:28:22,040
good overloads that actually means I do

00:28:20,570 --> 00:28:23,540
the same thing every time this is the

00:28:22,040 --> 00:28:24,470
inputs may be a double or a float or an

00:28:23,540 --> 00:28:26,270
end but I'm actually doing the same

00:28:24,470 --> 00:28:28,300
underlying function and a well-designed

00:28:26,270 --> 00:28:32,030
overload set that is true

00:28:28,300 --> 00:28:33,260
so um when you get to asynchronous

00:28:32,030 --> 00:28:34,910
programming now it's gonna change our

00:28:33,260 --> 00:28:35,870
understanding about life times when

00:28:34,910 --> 00:28:37,790
you're thinking about synchronous

00:28:35,870 --> 00:28:40,430
programming whether you pass by value

00:28:37,790 --> 00:28:41,920
reference Const reference at least from

00:28:40,430 --> 00:28:44,270
the scope of the function you call

00:28:41,920 --> 00:28:45,740
everything's still good it was good when

00:28:44,270 --> 00:28:47,270
you call the function it'll be good for

00:28:45,740 --> 00:28:48,800
the entire length of the function and

00:28:47,270 --> 00:28:51,830
the moment I get to asynchronous

00:28:48,800 --> 00:28:53,960
programming everything changes so this

00:28:51,830 --> 00:28:55,640
is a slide where because you would never

00:28:53,960 --> 00:28:57,800
write code like this but it I think it's

00:28:55,640 --> 00:29:01,250
illustrative of the example I have this

00:28:57,800 --> 00:29:02,810
function slow acumen is actually an

00:29:01,250 --> 00:29:05,480
input one as an output parameter

00:29:02,810 --> 00:29:07,460
I have hopefully named the parameters

00:29:05,480 --> 00:29:10,060
such but the type system tells me

00:29:07,460 --> 00:29:12,530
nothing and so I'm gonna accumulate the

00:29:10,060 --> 00:29:14,360
the sum of the size of everything

00:29:12,530 --> 00:29:15,890
and meanwhile I got a co a weight in

00:29:14,360 --> 00:29:17,660
between each one I'm gonna very slowly

00:29:15,890 --> 00:29:19,460
accumulate these things maybe maybe it's

00:29:17,660 --> 00:29:21,380
a much more expensive computation and I

00:29:19,460 --> 00:29:22,490
want to be very friendly to the CPU and

00:29:21,380 --> 00:29:23,900
I just want to say look I've done a

00:29:22,490 --> 00:29:27,950
bunch of hard work somebody else can

00:29:23,900 --> 00:29:29,540
have a turn um this is not Co routine

00:29:27,950 --> 00:29:31,850
syntax there's still some debate about

00:29:29,540 --> 00:29:33,290
that there are people who want the async

00:29:31,850 --> 00:29:35,690
keyword or something like it to be a

00:29:33,290 --> 00:29:37,790
part of the prototype and function

00:29:35,690 --> 00:29:39,920
signature because otherwise you can't

00:29:37,790 --> 00:29:41,690
tell a co routine from a non carotene

00:29:39,920 --> 00:29:43,730
without looking at the implementation

00:29:41,690 --> 00:29:45,320
and scrolling down however far it is to

00:29:43,730 --> 00:29:49,990
find your Co await or Co return keyword

00:29:45,320 --> 00:29:52,400
so I'm using a non-existent syntax so

00:29:49,990 --> 00:29:53,330
building on this then especially when

00:29:52,400 --> 00:29:55,280
thinking about asynchronous programming

00:29:53,330 --> 00:29:57,370
and the other issues I don't actually

00:29:55,280 --> 00:29:59,990
think references are all that awesome

00:29:57,370 --> 00:30:01,940
they solve an absolutely fundamentally

00:29:59,990 --> 00:30:03,800
necessary problem the language I cannot

00:30:01,940 --> 00:30:06,080
have an operator square brackets that

00:30:03,800 --> 00:30:07,670
works without references it's the only

00:30:06,080 --> 00:30:10,790
way to make that work in a way that

00:30:07,670 --> 00:30:12,350
syntactically makes sense but they make

00:30:10,790 --> 00:30:15,530
all of my calling code harder to reason

00:30:12,350 --> 00:30:17,030
about and when I have a reference versus

00:30:15,530 --> 00:30:18,320
a pointer I have two ways to do one

00:30:17,030 --> 00:30:20,390
thing and they're not they're

00:30:18,320 --> 00:30:22,580
fundamentally different only in the idea

00:30:20,390 --> 00:30:25,700
of whether something is null but no is

00:30:22,580 --> 00:30:27,500
only one of many kinds of actual memory

00:30:25,700 --> 00:30:29,630
or lifetime error I will eventually be

00:30:27,500 --> 00:30:31,820
concerned about and so I don't in my

00:30:29,630 --> 00:30:34,250
experience that null versus not enough

00:30:31,820 --> 00:30:35,960
has not been in like in my list of if I

00:30:34,250 --> 00:30:39,070
have top three list of bugs I worry

00:30:35,960 --> 00:30:43,430
about null pointers are not in the list

00:30:39,070 --> 00:30:45,140
so continuing on then consistent code is

00:30:43,430 --> 00:30:47,660
great for lowering our cognitive load

00:30:45,140 --> 00:30:49,280
and so if we pass by pointer to indicate

00:30:47,660 --> 00:30:51,980
these um these concepts

00:30:49,280 --> 00:30:54,110
I'm much I'm now more consistent the

00:30:51,980 --> 00:30:56,390
language doesn't require me to do it but

00:30:54,110 --> 00:30:58,160
I could have the the discipline to do it

00:30:56,390 --> 00:31:00,980
for myself as a gift to my future self

00:30:58,160 --> 00:31:03,140
who is woken up at 3:00 a.m. by the

00:31:00,980 --> 00:31:05,810
pager and needs to really find an answer

00:31:03,140 --> 00:31:08,090
fast and especially for asynchronous

00:31:05,810 --> 00:31:10,130
code actually passing by pointer or by

00:31:08,090 --> 00:31:12,980
value will completely clarify my

00:31:10,130 --> 00:31:15,350
lifetime issues if I if I always pass by

00:31:12,980 --> 00:31:18,070
something that's a value type I don't

00:31:15,350 --> 00:31:20,480
have lifetime issues anymore in this

00:31:18,070 --> 00:31:22,429
because I now have assumed to ownership

00:31:20,480 --> 00:31:24,280
of everything that I need it's a part

00:31:22,429 --> 00:31:26,450
it's now a part of my co-routine frame

00:31:24,280 --> 00:31:28,100
so here's my original example

00:31:26,450 --> 00:31:29,810
I'm gonna apply Google's style rules to

00:31:28,100 --> 00:31:31,520
this and I'm gonna say great I mean I'm

00:31:29,810 --> 00:31:33,290
gonna pass that first input by Const

00:31:31,520 --> 00:31:35,690
reference because it's not mutated and

00:31:33,290 --> 00:31:38,840
I'm gonna pass the second one by pointer

00:31:35,690 --> 00:31:41,030
and so now I've actually got some very

00:31:38,840 --> 00:31:43,160
obvious D references in here and it

00:31:41,030 --> 00:31:45,580
might be more obvious that if I had a

00:31:43,160 --> 00:31:47,690
lifetime bug it's somewhere in there and

00:31:45,580 --> 00:31:48,830
then they can apply some smart pointer

00:31:47,690 --> 00:31:50,990
guidelines and to say great it's not a

00:31:48,830 --> 00:31:52,850
rock pointer it's an observer and the

00:31:50,990 --> 00:31:55,100
only thing that changed was the API my

00:31:52,850 --> 00:31:56,420
source code didn't change and I had this

00:31:55,100 --> 00:31:58,280
helpful document here that the output

00:31:56,420 --> 00:32:00,230
can't be null and since I don't have

00:31:58,280 --> 00:32:02,570
contracts yet I'll get to that in a

00:32:00,230 --> 00:32:04,220
moment too so now I can apply

00:32:02,570 --> 00:32:06,620
Bloomberg's guidelines and I say great

00:32:04,220 --> 00:32:08,690
that input actually effectively has its

00:32:06,620 --> 00:32:10,550
address maintained after the initial

00:32:08,690 --> 00:32:13,400
function call this is a cover teen I'm

00:32:10,550 --> 00:32:15,380
going a sink I'm effectively holding on

00:32:13,400 --> 00:32:17,270
to that address passed when the initial

00:32:15,380 --> 00:32:18,620
function returns so I should pass it by

00:32:17,270 --> 00:32:20,660
pointer to make that clear at the call

00:32:18,620 --> 00:32:22,970
site and the only thing that changes in

00:32:20,660 --> 00:32:24,080
the implementation is a single I have to

00:32:22,970 --> 00:32:26,540
use a star in order to get the

00:32:24,080 --> 00:32:28,040
underlying thing and so now we'll apply

00:32:26,540 --> 00:32:28,790
the smart pointer guidelines again and

00:32:28,040 --> 00:32:30,080
we'll say okay great

00:32:28,790 --> 00:32:32,360
that shouldn't be a rock pointer it

00:32:30,080 --> 00:32:33,830
should be an observer put her and the

00:32:32,360 --> 00:32:35,690
code didn't change just a function

00:32:33,830 --> 00:32:39,050
prototype but now I've got this

00:32:35,690 --> 00:32:40,490
different problem almost everything I'm

00:32:39,050 --> 00:32:46,100
inputting is now an observer footer and

00:32:40,490 --> 00:32:47,570
I've lost a bunch of meaning so I've got

00:32:46,100 --> 00:32:49,490
references between things are never null

00:32:47,570 --> 00:32:51,700
and now I'm passing by pointer and it's

00:32:49,490 --> 00:32:53,960
observer Porter but it's still nullable

00:32:51,700 --> 00:32:55,160
and so you might ask the question with

00:32:53,960 --> 00:32:56,690
something like an observer ref would

00:32:55,160 --> 00:32:58,820
that make sense as an additional type

00:32:56,690 --> 00:33:00,380
it's almost like exactly like observer

00:32:58,820 --> 00:33:02,600
Twitter we could imagine such a thing

00:33:00,380 --> 00:33:04,310
you still use operator arrow and

00:33:02,600 --> 00:33:06,110
operator star to access the underlying

00:33:04,310 --> 00:33:07,730
memory so my uses of it look a little

00:33:06,110 --> 00:33:09,980
scary they look like that could be a bug

00:33:07,730 --> 00:33:11,570
but I have some guarantee by an actual

00:33:09,980 --> 00:33:13,610
contract that it's never null and I can

00:33:11,570 --> 00:33:15,350
actually get this checking from real

00:33:13,610 --> 00:33:20,240
contracts or from debugger certs in a

00:33:15,350 --> 00:33:22,490
way I can't quite get with references so

00:33:20,240 --> 00:33:23,810
and then if I suppose I had this thing I

00:33:22,490 --> 00:33:25,580
have another decision point about it

00:33:23,810 --> 00:33:27,050
should I allow constructing one of these

00:33:25,580 --> 00:33:29,120
things from a raw reference or should I

00:33:27,050 --> 00:33:31,000
require a pointer and that leads to

00:33:29,120 --> 00:33:33,980
slightly different code where either I

00:33:31,000 --> 00:33:37,730
look more like a C++ reference and so

00:33:33,980 --> 00:33:39,050
maybe my code changes less but maybe now

00:33:37,730 --> 00:33:39,950
I'm hiding mutated parameters or

00:33:39,050 --> 00:33:43,100
lifetime issues again

00:33:39,950 --> 00:33:44,720
so this is a design point if you wanted

00:33:43,100 --> 00:33:49,010
both an observer pointer and an observer

00:33:44,720 --> 00:33:51,200
ref you would have to think about and in

00:33:49,010 --> 00:33:53,120
fact I have more than just this and some

00:33:51,200 --> 00:33:55,760
sense I have two kinds of by pointer

00:33:53,120 --> 00:33:58,100
inputs I have these inputs that are

00:33:55,760 --> 00:34:00,200
output arguments actually and I might

00:33:58,100 --> 00:34:02,750
want to name like out and out opt for

00:34:00,200 --> 00:34:04,039
optional ones and if I don't have stood

00:34:02,750 --> 00:34:06,110
optional may be stood optional that

00:34:04,039 --> 00:34:07,429
would be good enough and it were in out

00:34:06,110 --> 00:34:09,040
for something that's an in and an out

00:34:07,429 --> 00:34:11,240
argument um

00:34:09,040 --> 00:34:13,010
output arcs are almost never know unless

00:34:11,240 --> 00:34:14,570
they're optional which is relatively

00:34:13,010 --> 00:34:16,490
where it's it's rare to call a function

00:34:14,570 --> 00:34:18,800
and say put the answer here and not not

00:34:16,490 --> 00:34:21,879
give you a here to put it in that would

00:34:18,800 --> 00:34:24,470
typically be an obvious bug

00:34:21,879 --> 00:34:26,419
unfortunately C++ doesn't let me make a

00:34:24,470 --> 00:34:27,770
write only type I would really love it

00:34:26,419 --> 00:34:29,629
if like out with something I could only

00:34:27,770 --> 00:34:31,159
store into but it couldn't read from but

00:34:29,629 --> 00:34:32,659
operator star has to return a reference

00:34:31,159 --> 00:34:35,149
and once I've got a reference I can go

00:34:32,659 --> 00:34:37,220
both ways and then I have what we call

00:34:35,149 --> 00:34:38,119
it our code base borrowed pointer and

00:34:37,220 --> 00:34:40,550
borrowed ref these are inputs

00:34:38,119 --> 00:34:42,290
essentially they are not owning pointers

00:34:40,550 --> 00:34:44,510
they pervert preserve a little of your

00:34:42,290 --> 00:34:48,950
pointer versus reference differences but

00:34:44,510 --> 00:34:52,159
by contract I can't have a no ref and so

00:34:48,950 --> 00:34:54,470
this is sort of a maybe not quite an eye

00:34:52,159 --> 00:34:56,929
chart but I have this taxonomy now of

00:34:54,470 --> 00:34:59,450
things where I might want to think about

00:34:56,929 --> 00:35:01,190
whether they can be know what their

00:34:59,450 --> 00:35:03,079
asynchronous lifetime would be and

00:35:01,190 --> 00:35:06,140
whether I can default construct them and

00:35:03,079 --> 00:35:08,359
so the idea in perhaps this new taxonomy

00:35:06,140 --> 00:35:11,450
would be the borrowed ref looks just

00:35:08,359 --> 00:35:13,460
like a reference it's it's got the same

00:35:11,450 --> 00:35:15,500
lifetime ideas it's got the same ability

00:35:13,460 --> 00:35:18,079
to not be constructed from no and it has

00:35:15,500 --> 00:35:20,000
the same idea that I can't default

00:35:18,079 --> 00:35:20,420
construct it and maybe I can't reassign

00:35:20,000 --> 00:35:22,369
it either

00:35:20,420 --> 00:35:24,829
and similarly borrowed pointer should

00:35:22,369 --> 00:35:26,630
look exactly like a rob pointer and I

00:35:24,829 --> 00:35:28,160
wouldn't in out are sort of in the

00:35:26,630 --> 00:35:29,810
middle ground they there's a there's an

00:35:28,160 --> 00:35:31,910
implicit semantics for an out pointer

00:35:29,810 --> 00:35:33,920
that it better last as long as whatever

00:35:31,910 --> 00:35:35,329
asynchronous crude you're calling or you

00:35:33,920 --> 00:35:36,980
as the caller have already screwed up

00:35:35,329 --> 00:35:39,079
like I shouldn't have to I should have

00:35:36,980 --> 00:35:40,369
to say anything about this is unusual

00:35:39,079 --> 00:35:41,720
about the lifetime if you've told me to

00:35:40,369 --> 00:35:43,220
fill in a value and it's gonna take me a

00:35:41,720 --> 00:35:45,200
while to compute it and I'm going across

00:35:43,220 --> 00:35:46,700
asynchronous boundaries if you didn't

00:35:45,200 --> 00:35:48,500
give me something that'll last until the

00:35:46,700 --> 00:35:50,930
result is actually ready that's your bug

00:35:48,500 --> 00:35:53,180
not mine and so I have this implicit

00:35:50,930 --> 00:35:53,819
difference in understanding of

00:35:53,180 --> 00:35:55,079
asynchronous

00:35:53,819 --> 00:35:58,519
lifetime between what I might call a

00:35:55,079 --> 00:35:59,670
borrowed pointer and an output pointer

00:35:58,519 --> 00:36:01,709
okay

00:35:59,670 --> 00:36:03,630
so I have a little code example going

00:36:01,709 --> 00:36:04,949
through the essentially the

00:36:03,630 --> 00:36:06,479
implementation we have at work I'm not

00:36:04,949 --> 00:36:08,279
going to spend a lot of time on this the

00:36:06,479 --> 00:36:13,109
link is in the slide the slides will be

00:36:08,279 --> 00:36:15,449
up on wherever the slides go in another

00:36:13,109 --> 00:36:17,339
couple days when I email them so the

00:36:15,449 --> 00:36:20,180
basic idea is I've implemented this

00:36:17,339 --> 00:36:22,349
function raw pointer ignoring lifetime I

00:36:20,180 --> 00:36:24,660
forward to clear it so I can make friend

00:36:22,349 --> 00:36:26,579
functions and there's some fiddly bits

00:36:24,660 --> 00:36:29,309
here about tagging new verses reference

00:36:26,579 --> 00:36:31,380
verses pointer this is mostly fun smart

00:36:29,309 --> 00:36:33,239
normal smart pointer syntax I can assert

00:36:31,380 --> 00:36:35,699
that you didn't give me an all things on

00:36:33,239 --> 00:36:38,430
construction that's nice I can say

00:36:35,699 --> 00:36:40,319
things like a I can statically assert

00:36:38,430 --> 00:36:41,910
that you don't construct a referenceable

00:36:40,319 --> 00:36:44,190
type with a null pointer that's kind of

00:36:41,910 --> 00:36:45,900
nice I get that same kind of thing from

00:36:44,190 --> 00:36:48,749
a raw reference

00:36:45,900 --> 00:36:50,489
I added some comments about possible

00:36:48,749 --> 00:36:52,529
semantics here the the point of all this

00:36:50,489 --> 00:36:54,329
is that once you scroll down through a

00:36:52,529 --> 00:36:56,940
bunch of you know it's still kind of

00:36:54,329 --> 00:36:58,559
slide where you get down to a bunch of

00:36:56,940 --> 00:37:01,380
code that actually uses it and I've

00:36:58,559 --> 00:37:03,209
commented out every so I've got this use

00:37:01,380 --> 00:37:05,339
sample use site I take a bar hard ref

00:37:03,209 --> 00:37:07,170
and I just print it it's not no I don't

00:37:05,339 --> 00:37:10,589
have to check and I've got a bunch of

00:37:07,170 --> 00:37:12,180
sample use sites I could construct a

00:37:10,589 --> 00:37:15,359
barred ref from a unique and it just

00:37:12,180 --> 00:37:16,949
looks safe and simple

00:37:15,359 --> 00:37:19,349
I can't reassign it that line won't

00:37:16,949 --> 00:37:21,479
compile I can pass a borrowed ref or a

00:37:19,349 --> 00:37:22,920
unique putter or the address of a

00:37:21,479 --> 00:37:24,509
pointer I can pass all of those things

00:37:22,920 --> 00:37:27,539
and it just compiled so I don't have to

00:37:24,509 --> 00:37:29,039
do any extra typing I did find one

00:37:27,539 --> 00:37:32,430
surprise here I'd love it if someone can

00:37:29,039 --> 00:37:34,440
explain this one to me so borrowed ref I

00:37:32,430 --> 00:37:35,880
don't want to construct it from there's

00:37:34,440 --> 00:37:38,640
a one of the parts was I don't want to

00:37:35,880 --> 00:37:40,319
construct a bar any borrow type from an

00:37:38,640 --> 00:37:42,239
R value of an actual winning pointer

00:37:40,319 --> 00:37:43,979
because you're trying to say here take

00:37:42,239 --> 00:37:46,619
ownership and my type literally says I

00:37:43,979 --> 00:37:48,029
can't own things so there's um I've just

00:37:46,619 --> 00:37:50,039
completely deleted those concept

00:37:48,029 --> 00:37:52,709
constructors and so if I do if I

00:37:50,039 --> 00:37:55,650
explicitly try to create one here that

00:37:52,709 --> 00:37:57,660
fails and if I use the assignment syntax

00:37:55,650 --> 00:38:02,069
instead of construction this compiles

00:37:57,660 --> 00:38:03,660
and I can't figure out why because the

00:38:02,069 --> 00:38:04,890
assignment operator also doesn't work I

00:38:03,660 --> 00:38:06,690
don't think maybe I didn't get rid of

00:38:04,890 --> 00:38:07,589
that one but I can't reassign in to

00:38:06,690 --> 00:38:08,880
borrow drafts anyway so

00:38:07,589 --> 00:38:10,529
not quite sure what overloads this is

00:38:08,880 --> 00:38:12,660
calling and if somebody knows the actual

00:38:10,529 --> 00:38:14,599
concrete difference in which special

00:38:12,660 --> 00:38:17,489
member functions are called when you

00:38:14,599 --> 00:38:18,809
construct by like this style or this

00:38:17,489 --> 00:38:20,759
style I'd be very interested to hear

00:38:18,809 --> 00:38:23,099
that later so have some more examples of

00:38:20,759 --> 00:38:24,869
things I can and can't do depending on

00:38:23,099 --> 00:38:26,940
these are using slightly looser

00:38:24,869 --> 00:38:28,079
semantics about ownership we're yeah you

00:38:26,940 --> 00:38:31,710
wanted to stood move but I'm not taking

00:38:28,079 --> 00:38:33,559
it so yeah maybe that's okay um the

00:38:31,710 --> 00:38:36,329
other point is here is observer footer I

00:38:33,559 --> 00:38:40,680
can make an observe reporter by

00:38:36,329 --> 00:38:41,759
explicitly using get I can be explicit

00:38:40,680 --> 00:38:42,630
about passing in a row pointer and

00:38:41,759 --> 00:38:44,339
getting observer pointer

00:38:42,630 --> 00:38:46,489
I can't just initialize it like this

00:38:44,339 --> 00:38:48,599
that doesn't compile I can't assign it

00:38:46,489 --> 00:38:50,789
using anything other than another

00:38:48,599 --> 00:38:55,109
observer put ER either from a smart

00:38:50,789 --> 00:38:56,400
pointer or not and I can't delete it

00:38:55,109 --> 00:38:57,630
which is good but there's a lot of

00:38:56,400 --> 00:38:59,999
things I can't do it that I kind of want

00:38:57,630 --> 00:39:02,249
um and then here's some things that do

00:38:59,999 --> 00:39:03,630
compile which should compile because you

00:39:02,249 --> 00:39:06,359
were very explicit about doing something

00:39:03,630 --> 00:39:07,890
dumb and more things that don't compile

00:39:06,359 --> 00:39:08,940
I can't delete things so this is out

00:39:07,890 --> 00:39:11,099
there if you want to look at it more and

00:39:08,940 --> 00:39:19,369
play a little bit with explicit versus

00:39:11,099 --> 00:39:22,259
implicit what's deleted what's not so

00:39:19,369 --> 00:39:24,599
using a slightly broader taxonomy of

00:39:22,259 --> 00:39:26,489
smart pointers this is what my original

00:39:24,599 --> 00:39:28,229
example might look like now I have a

00:39:26,489 --> 00:39:30,089
borrowed ref for the input and I have an

00:39:28,229 --> 00:39:32,460
output and the only thing I have to

00:39:30,089 --> 00:39:34,710
document about this API now is that for

00:39:32,460 --> 00:39:36,299
this specific use the input must have a

00:39:34,710 --> 00:39:38,789
lifetime longer than the async function

00:39:36,299 --> 00:39:42,059
that's a requirement of the API I cannot

00:39:38,789 --> 00:39:44,400
put that in the type system my static

00:39:42,059 --> 00:39:46,079
analysis tools could quite possibly tell

00:39:44,400 --> 00:39:47,190
me you know this is an async function

00:39:46,079 --> 00:39:49,380
and then uh lifetimes not long enough

00:39:47,190 --> 00:39:50,789
but that's not a bug necessarily because

00:39:49,380 --> 00:39:53,549
I may know more things about life time

00:39:50,789 --> 00:39:55,499
than the static analysis tool that's I

00:39:53,549 --> 00:39:56,670
think probably provably correct that you

00:39:55,499 --> 00:39:58,469
can always know something this tool

00:39:56,670 --> 00:40:02,430
can't know that's technically correct

00:39:58,469 --> 00:40:04,710
just hard to analyze and so I call this

00:40:02,430 --> 00:40:06,210
function essentially like we would might

00:40:04,710 --> 00:40:08,099
before I pass in an address if account

00:40:06,210 --> 00:40:09,239
and following Bloomberg's style rows at

00:40:08,099 --> 00:40:14,609
least I passed the address of the

00:40:09,239 --> 00:40:18,029
container I'm getting over so so a third

00:40:14,609 --> 00:40:20,309
guideline that is consider at least only

00:40:18,029 --> 00:40:21,450
passing by value to an asynchronous

00:40:20,309 --> 00:40:23,709
function

00:40:21,450 --> 00:40:26,049
Poynter is an on owning smart pointer as

00:40:23,709 --> 00:40:27,069
those are values your function

00:40:26,049 --> 00:40:28,660
definition should be using the

00:40:27,069 --> 00:40:29,609
appropriate kinds of smart pointers to

00:40:28,660 --> 00:40:32,049
encapsulate meaning

00:40:29,609 --> 00:40:33,579
supposing I don't actually have the

00:40:32,049 --> 00:40:34,719
standard Committee give me out and in

00:40:33,579 --> 00:40:36,519
out and all those other names I might

00:40:34,719 --> 00:40:39,130
just be able to make a using alias that

00:40:36,519 --> 00:40:42,910
works well enough or I could make my own

00:40:39,130 --> 00:40:45,489
type this is actually another point of

00:40:42,910 --> 00:40:47,140
interesting tension I is a consumer of

00:40:45,489 --> 00:40:49,089
these things with a relatively limited

00:40:47,140 --> 00:40:52,029
audience and a relatively narrow domain

00:40:49,089 --> 00:40:54,400
I might want slightly different

00:40:52,029 --> 00:40:56,229
guarantees and behaviors than what the

00:40:54,400 --> 00:40:58,059
standards committee could give the broad

00:40:56,229 --> 00:41:00,309
community of hundreds of thousands of

00:40:58,059 --> 00:41:02,529
C++ developers because the things that

00:41:00,309 --> 00:41:03,849
are to me not a bug may be considered

00:41:02,529 --> 00:41:05,170
sketchy enough to the committee that

00:41:03,849 --> 00:41:07,269
they don't want to make them easy to do

00:41:05,170 --> 00:41:09,849
and the things that are considered to me

00:41:07,269 --> 00:41:12,009
a bug like get maybe considered by the

00:41:09,849 --> 00:41:14,319
committee as a we want to be consistent

00:41:12,009 --> 00:41:15,609
with existing types or it's going to be

00:41:14,319 --> 00:41:17,890
twenty years before people finish

00:41:15,609 --> 00:41:19,890
rototilling their code bases or whatever

00:41:17,890 --> 00:41:23,319
reason so I think there's this sort of

00:41:19,890 --> 00:41:26,229
natural tension between what is

00:41:23,319 --> 00:41:27,670
appropriate for Standardization and what

00:41:26,229 --> 00:41:29,979
you may actually want in your code base

00:41:27,670 --> 00:41:32,529
and that's sort of unfortunate right we

00:41:29,979 --> 00:41:34,479
in some sense I can't get by the

00:41:32,529 --> 00:41:36,039
standard exactly what I want it's either

00:41:34,479 --> 00:41:37,180
too specialized or too constrained or

00:41:36,039 --> 00:41:38,709
something like that and you just kind of

00:41:37,180 --> 00:41:40,690
hope that it meets your purpose well

00:41:38,709 --> 00:41:44,079
enough that you'd rather use standard

00:41:40,690 --> 00:41:46,119
tools and roll your own the other part

00:41:44,079 --> 00:41:47,559
of this guideline three is we should be

00:41:46,119 --> 00:41:49,569
explicit about lifetime if the type

00:41:47,559 --> 00:41:50,940
isn't for any asynchronous function I

00:41:49,569 --> 00:41:53,319
have to really think about lifetime

00:41:50,940 --> 00:41:55,809
values are good anything else is

00:41:53,319 --> 00:41:58,329
possibly sketchy and I should have this

00:41:55,809 --> 00:41:59,440
assumption I think that something that

00:41:58,329 --> 00:42:01,869
you would think of as an out parameter

00:41:59,440 --> 00:42:04,449
has a long enough life and any other

00:42:01,869 --> 00:42:05,709
type of borrow parameter is only good up

00:42:04,449 --> 00:42:07,150
through the like the initial invocation

00:42:05,709 --> 00:42:10,059
of the function call and up to the first

00:42:07,150 --> 00:42:11,799
moment you go async because technically

00:42:10,059 --> 00:42:13,690
that's all you get if I if I'm giving

00:42:11,799 --> 00:42:15,160
you some kind of borrow type you don't

00:42:13,690 --> 00:42:16,920
know where it is it may be gone by the

00:42:15,160 --> 00:42:18,729
time you return to your co-routine frame

00:42:16,920 --> 00:42:20,109
and it's important to remember that

00:42:18,729 --> 00:42:21,999
things like span and string view these

00:42:20,109 --> 00:42:23,709
are also borrow types there's no

00:42:21,999 --> 00:42:25,660
ownership inside them I'm passing them

00:42:23,709 --> 00:42:31,589
by value but I still have to think about

00:42:25,660 --> 00:42:33,459
lifetime on these types as well so

00:42:31,589 --> 00:42:34,390
you're in this world you've got a code

00:42:33,459 --> 00:42:35,859
base it's lovely

00:42:34,390 --> 00:42:37,089
basse it solves your problems but you'd

00:42:35,859 --> 00:42:39,210
like it to be a little more strict about

00:42:37,089 --> 00:42:41,500
types how do you get there from here

00:42:39,210 --> 00:42:43,480
my experience has been that you want to

00:42:41,500 --> 00:42:44,829
fix your owning pointers first you take

00:42:43,480 --> 00:42:46,569
if you have a rock pointer that actually

00:42:44,829 --> 00:42:47,950
expresses ownership that's much more

00:42:46,569 --> 00:42:49,779
dangerous than a rob pointer that

00:42:47,950 --> 00:42:51,460
doesn't Express ownership you can have

00:42:49,779 --> 00:42:54,549
bugs like the one I showed at the

00:42:51,460 --> 00:42:56,230
beginning they are relatively rare if

00:42:54,549 --> 00:42:58,000
you're able to run your full production

00:42:56,230 --> 00:43:00,099
code in an ACN environment the address

00:42:58,000 --> 00:43:03,599
sanitizer will tell you who did the bad

00:43:00,099 --> 00:43:06,309
thing and then who tripped across it so

00:43:03,599 --> 00:43:09,160
any any kind of owning pointer is better

00:43:06,309 --> 00:43:11,470
than a rock pointer in my experience and

00:43:09,160 --> 00:43:12,789
at least an hour code base almost every

00:43:11,470 --> 00:43:14,710
instance that was using one of those

00:43:12,789 --> 00:43:16,690
legacy factory functions that return to

00:43:14,710 --> 00:43:18,400
rob pointer it was immediately holding

00:43:16,690 --> 00:43:20,140
the value in an actual correct owning

00:43:18,400 --> 00:43:22,210
smart pointer it's just that the API

00:43:20,140 --> 00:43:23,799
hadn't been changed so most of the

00:43:22,210 --> 00:43:25,779
changes I had to do to fix those up were

00:43:23,799 --> 00:43:27,279
just to change the API I was returning a

00:43:25,779 --> 00:43:28,839
new type I have fixed up the

00:43:27,279 --> 00:43:30,190
implementation I did not have to change

00:43:28,839 --> 00:43:32,230
the calling code because I was already

00:43:30,190 --> 00:43:33,970
taking ownership your code base may not

00:43:32,230 --> 00:43:35,920
be like that but in the process of

00:43:33,970 --> 00:43:37,089
converting Rob pointers to owning

00:43:35,920 --> 00:43:38,769
pointers will probably find some

00:43:37,089 --> 00:43:42,369
interesting places where you might want

00:43:38,769 --> 00:43:45,670
to worry about lifetime I would say you

00:43:42,369 --> 00:43:47,200
also want at least consider not just not

00:43:45,670 --> 00:43:48,309
using dot get the library gives it to

00:43:47,200 --> 00:43:50,289
you maybe you would just say look we're

00:43:48,309 --> 00:43:51,759
not going to use get we're gonna we're

00:43:50,289 --> 00:43:53,559
gonna implement this Rob point you're

00:43:51,759 --> 00:43:55,660
ignoring lifetime function it's pretty

00:43:53,559 --> 00:43:57,279
trivial to implement and the nice thing

00:43:55,660 --> 00:43:59,529
about that is twofold number when it

00:43:57,279 --> 00:44:01,660
gives you a really scary name and number

00:43:59,529 --> 00:44:03,430
two it actually makes it really easy to

00:44:01,660 --> 00:44:04,630
grep for sites in your code where you

00:44:03,430 --> 00:44:07,150
haven't pushed through all the

00:44:04,630 --> 00:44:09,099
properties of explicit ownership and non

00:44:07,150 --> 00:44:11,619
ownership you now have a that gets

00:44:09,099 --> 00:44:13,119
really hard to grab for maybe you've got

00:44:11,619 --> 00:44:14,950
a tool that can show you these things

00:44:13,119 --> 00:44:18,099
but it's really easy to grab for that

00:44:14,950 --> 00:44:19,299
function and in fact I sometimes just

00:44:18,099 --> 00:44:21,009
kind of grab that against my code base

00:44:19,299 --> 00:44:22,359
to see if somebody thought they were

00:44:21,009 --> 00:44:23,140
being clever solving your problem and it

00:44:22,359 --> 00:44:25,000
actually shouldn't have done that

00:44:23,140 --> 00:44:26,559
because they didn't understand how to

00:44:25,000 --> 00:44:29,740
properly use zoning and non-winning

00:44:26,559 --> 00:44:31,630
smart pointers so it's also easy to it's

00:44:29,740 --> 00:44:32,890
also easy to find sketchy code someone

00:44:31,630 --> 00:44:35,319
else wrote that they didn't that I never

00:44:32,890 --> 00:44:37,089
was on the code review for um I like to

00:44:35,319 --> 00:44:42,279
check that out occasionally you do find

00:44:37,089 --> 00:44:43,089
real bugs that way so essentially to

00:44:42,279 --> 00:44:46,119
summarize here

00:44:43,089 --> 00:44:47,349
I had these four theses you can write a

00:44:46,119 --> 00:44:48,160
hundred percent correct code in raw

00:44:47,349 --> 00:44:50,420
c-plus

00:44:48,160 --> 00:44:52,970
so we should add value with any of these

00:44:50,420 --> 00:44:55,730
new types being explicit sputter than

00:44:52,970 --> 00:44:57,110
being implicit all of these types will

00:44:55,730 --> 00:45:00,020
work best if I have left's code to

00:44:57,110 --> 00:45:02,630
change I'd rather do I still rather be

00:45:00,020 --> 00:45:04,400
explicit and type more but ideally like

00:45:02,630 --> 00:45:06,680
it so I can not have to type much and

00:45:04,400 --> 00:45:08,120
let the type system give me belief about

00:45:06,680 --> 00:45:09,590
correctness rather than having to

00:45:08,120 --> 00:45:11,300
explicitly say yes and then we put it in

00:45:09,590 --> 00:45:11,960
the observer pointer now yes let me do

00:45:11,300 --> 00:45:15,530
something else

00:45:11,960 --> 00:45:16,730
and finally references to have some

00:45:15,530 --> 00:45:20,030
issues especially when you start

00:45:16,730 --> 00:45:22,610
thinking about async code they are they

00:45:20,030 --> 00:45:25,850
are no longer the safe thing to do into

00:45:22,610 --> 00:45:28,310
some sense and and by moving away from

00:45:25,850 --> 00:45:30,080
references to appropriate non owning

00:45:28,310 --> 00:45:32,840
smart pointers I actually can clear from

00:45:30,080 --> 00:45:36,320
my code I can now make it easier to tell

00:45:32,840 --> 00:45:37,700
what's mutated what's not um and so

00:45:36,320 --> 00:45:39,050
these choices for your smart pointer

00:45:37,700 --> 00:45:41,660
semantics can make your code easier to

00:45:39,050 --> 00:45:44,870
read also how much do you have to type

00:45:41,660 --> 00:45:46,820
to make it happen so the guidelines were

00:45:44,870 --> 00:45:49,280
relatively simple know owning rob

00:45:46,820 --> 00:45:50,990
pointers unless you have to known on the

00:45:49,280 --> 00:45:52,700
owning rob pointers it's gonna take a

00:45:50,990 --> 00:45:54,880
while to get here I think I've been

00:45:52,700 --> 00:45:58,430
working on this in our code base for

00:45:54,880 --> 00:46:00,500
three years on and off and I'm and maybe

00:45:58,430 --> 00:46:01,730
2/3 of the way done I don't know it

00:46:00,500 --> 00:46:04,700
takes a while there's a lot there's a

00:46:01,730 --> 00:46:06,050
million lines of code and so you fix the

00:46:04,700 --> 00:46:07,520
low-level stuff and you kind of bubble

00:46:06,050 --> 00:46:08,900
out towards the outside you tell all

00:46:07,520 --> 00:46:10,730
your tech leads hey please start typing

00:46:08,900 --> 00:46:11,960
the new hotness and the new hotness if

00:46:10,730 --> 00:46:14,930
you do it right integrates well with the

00:46:11,960 --> 00:46:16,430
old stuff so like I don't have to like

00:46:14,930 --> 00:46:17,690
all the code I'm used to typing for

00:46:16,430 --> 00:46:19,580
callers doesn't get different it's just

00:46:17,690 --> 00:46:21,500
the API and the implementation and

00:46:19,580 --> 00:46:23,450
that's pretty trivial for for people to

00:46:21,500 --> 00:46:25,610
remember to do and then remember to pass

00:46:23,450 --> 00:46:27,170
by value to async code and if you are

00:46:25,610 --> 00:46:31,010
not passing by value be explicit about

00:46:27,170 --> 00:46:32,900
lifetimes that's the end of what I

00:46:31,010 --> 00:46:34,760
thought I might be able to fit in time I

00:46:32,900 --> 00:46:36,740
have a couple small appendices that it

00:46:34,760 --> 00:46:39,560
looks like I have a bit of time for um

00:46:36,740 --> 00:46:40,760
so one thing I wanted to mention if you

00:46:39,560 --> 00:46:42,770
have a winning smart pointers you can

00:46:40,760 --> 00:46:45,050
still end up with a double free and it's

00:46:42,770 --> 00:46:47,600
really not that hard but it does rely on

00:46:45,050 --> 00:46:49,790
multi-threaded code so I've got this

00:46:47,600 --> 00:46:51,920
multi-threaded member function I happily

00:46:49,790 --> 00:46:54,620
have a owning smart pointer as a member

00:46:51,920 --> 00:46:56,090
and I very helpfully reset the buffer

00:46:54,620 --> 00:46:57,500
early because I don't want to hold on to

00:46:56,090 --> 00:46:58,940
resources longer than I have to

00:46:57,500 --> 00:47:00,140
and this is probably code I should write

00:46:58,940 --> 00:47:01,490
sometimes I mean if it's gonna be awhile

00:47:00,140 --> 00:47:02,750
before this

00:47:01,490 --> 00:47:04,580
type is done but I'm done with that

00:47:02,750 --> 00:47:05,960
memory might be nice to free up the

00:47:04,580 --> 00:47:09,740
resources especially if it's something

00:47:05,960 --> 00:47:12,530
scarce but you probably can already

00:47:09,740 --> 00:47:14,330
recognize good at data race here if it's

00:47:12,530 --> 00:47:15,650
actually multi-threaded whereas in a

00:47:14,330 --> 00:47:16,849
destructor I would not have had the data

00:47:15,650 --> 00:47:17,480
race destructors or guaranteed

00:47:16,849 --> 00:47:20,680
single-threaded

00:47:17,480 --> 00:47:24,950
the world is nonsensical otherwise so

00:47:20,680 --> 00:47:27,200
there's a data race there um I think the

00:47:24,950 --> 00:47:29,780
next appendix is a little bit

00:47:27,200 --> 00:47:32,150
inscrutable in the time I have so if you

00:47:29,780 --> 00:47:33,560
want to if you want to see a brief but

00:47:32,150 --> 00:47:35,540
slightly hard to read example of why you

00:47:33,560 --> 00:47:37,339
might need an owning but raw pointer I

00:47:35,540 --> 00:47:38,510
have some code for that that I can go

00:47:37,339 --> 00:47:52,250
over but I think right now is a good

00:47:38,510 --> 00:47:54,920
time to open for questions so thanks for

00:47:52,250 --> 00:47:57,890
the talk um so what my question is

00:47:54,920 --> 00:48:01,760
actually or like this custom start point

00:47:57,890 --> 00:48:03,650
it well my point of view I would kind of

00:48:01,760 --> 00:48:06,730
it feels like I would like to disagree

00:48:03,650 --> 00:48:09,710
on the observer pointer so first of all

00:48:06,730 --> 00:48:11,480
if you remember changes talk every

00:48:09,710 --> 00:48:15,380
abstraction comes with a cost

00:48:11,480 --> 00:48:18,820
absolutely and you gave us the example

00:48:15,380 --> 00:48:21,950
where you had the convention that a

00:48:18,820 --> 00:48:24,140
pointer row pointer is a non owning

00:48:21,950 --> 00:48:25,839
pointer and someone constructed an

00:48:24,140 --> 00:48:31,040
unique pointer formats and then the

00:48:25,839 --> 00:48:33,530
pointer again cause not owning pointer

00:48:31,040 --> 00:48:35,690
to be deleted but actually for me it

00:48:33,530 --> 00:48:37,660
feels like if you have that kind of like

00:48:35,690 --> 00:48:41,480
the reasoning that was in the comment

00:48:37,660 --> 00:48:43,190
that he could also apply to the to the

00:48:41,480 --> 00:48:46,400
observer pointer he could just call get

00:48:43,190 --> 00:48:47,720
or give scary function and then create

00:48:46,400 --> 00:48:50,359
an unique pointer from it and then

00:48:47,720 --> 00:48:52,970
delete it again and you said this kind

00:48:50,359 --> 00:48:55,460
of bug is quite it's not very common in

00:48:52,970 --> 00:48:57,020
the code bases right which which part is

00:48:55,460 --> 00:49:02,210
not common I don't member exactly what I

00:48:57,020 --> 00:49:03,380
said but calling explicitly calling

00:49:02,210 --> 00:49:04,849
delete when you shouldn't or something

00:49:03,380 --> 00:49:06,740
like that I haven't seen much but it

00:49:04,849 --> 00:49:08,210
takes a long time to debug so my

00:49:06,740 --> 00:49:10,490
experience has been it's worth a little

00:49:08,210 --> 00:49:11,960
bit of time to make that bug never

00:49:10,490 --> 00:49:13,760
happen again I mean we literally lost

00:49:11,960 --> 00:49:13,970
months of engineer time trying to debug

00:49:13,760 --> 00:49:15,260
that

00:49:13,970 --> 00:49:17,869
and

00:49:15,260 --> 00:49:20,150
with make unique you could even go ahead

00:49:17,869 --> 00:49:21,349
and say maybe we should remove the

00:49:20,150 --> 00:49:23,540
constructor the you new pointer

00:49:21,349 --> 00:49:25,640
constructor for a row pointer so I mean

00:49:23,540 --> 00:49:27,950
there are a number of different

00:49:25,640 --> 00:49:32,089
approaches that you could take and which

00:49:27,950 --> 00:49:34,250
would be much less would require people

00:49:32,089 --> 00:49:36,800
to type much less if you would could

00:49:34,250 --> 00:49:39,079
then like consistently go for the

00:49:36,800 --> 00:49:42,740
convention that every you are pointer

00:49:39,079 --> 00:49:44,990
that you see is not owning right right

00:49:42,740 --> 00:49:46,070
so that's probably true you and I don't

00:49:44,990 --> 00:49:48,170
want to be prescriptive for anyone

00:49:46,070 --> 00:49:50,390
else's code base like I said one of my

00:49:48,170 --> 00:49:52,540
theses though was I think being explicit

00:49:50,390 --> 00:49:54,740
better than implicit if I only have

00:49:52,540 --> 00:49:57,020
essentially to owning smart pointers and

00:49:54,740 --> 00:49:58,550
one on a non owning smart pointer I've

00:49:57,020 --> 00:50:01,369
added very little extra overhead

00:49:58,550 --> 00:50:03,589
mentally to have that non owning smart

00:50:01,369 --> 00:50:05,390
pointer instead of a raw pointer and I

00:50:03,589 --> 00:50:07,099
can construct cases and we have them in

00:50:05,390 --> 00:50:08,589
our code at least where I have to have a

00:50:07,099 --> 00:50:12,250
rob pointer that actually has ownership

00:50:08,589 --> 00:50:15,290
because I can't use atomic updates on

00:50:12,250 --> 00:50:16,490
move only types they require copying and

00:50:15,290 --> 00:50:18,740
copying can only be done with rot

00:50:16,490 --> 00:50:20,510
pointers but wouldn't it be better to

00:50:18,740 --> 00:50:22,310
fix these cases so that in the end you

00:50:20,510 --> 00:50:24,800
would end up with a code base but you

00:50:22,310 --> 00:50:27,410
actually don't have any valid use case

00:50:24,800 --> 00:50:29,030
for a row pointer except for it being

00:50:27,410 --> 00:50:30,589
unknown and then you could just go for

00:50:29,030 --> 00:50:32,450
the shorter and nicer syntax well I'm

00:50:30,589 --> 00:50:33,680
not sure how I'd fix that I have to use

00:50:32,450 --> 00:50:35,390
a row pointer because I needed time like

00:50:33,680 --> 00:50:37,690
updates I need atomic updates because

00:50:35,390 --> 00:50:39,710
I'm in a lot free programming system I

00:50:37,690 --> 00:50:41,180
happen to be you may not be in which

00:50:39,710 --> 00:50:43,130
case yes you can probably much more

00:50:41,180 --> 00:50:45,140
easily move to that world or you just

00:50:43,130 --> 00:50:46,520
say look it's it's a rob pointer it's

00:50:45,140 --> 00:50:48,430
not owning I can write some tooling that

00:50:46,520 --> 00:50:50,630
says don't type delete or other things

00:50:48,430 --> 00:50:52,490
unfortunately you can't get rid of the

00:50:50,630 --> 00:50:53,720
constructor for unique put er that

00:50:52,490 --> 00:50:55,819
actually takes ownership from a Rob

00:50:53,720 --> 00:50:57,109
pointer that's just in the C++ system

00:50:55,819 --> 00:50:58,369
and the Committee is not going to get

00:50:57,109 --> 00:51:01,430
rid of that either I don't think anytime

00:50:58,369 --> 00:51:02,480
in the next 50 years so but yeah there

00:51:01,430 --> 00:51:03,980
are definitely other options possible

00:51:02,480 --> 00:51:10,540
this is I think this is the way we've

00:51:03,980 --> 00:51:10,540
gone thank you any other questions

00:51:10,569 --> 00:51:13,460
all right well thank you very much for

00:51:12,410 --> 00:51:18,360
your time

00:51:13,460 --> 00:51:18,360

YouTube URL: https://www.youtube.com/watch?v=CKCR5eFVrmc


