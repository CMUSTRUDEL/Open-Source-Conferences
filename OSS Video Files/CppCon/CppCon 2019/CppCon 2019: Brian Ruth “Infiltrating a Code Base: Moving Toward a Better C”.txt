Title: CppCon 2019: Brian Ruth “Infiltrating a Code Base: Moving Toward a Better C”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
“If you’re arguing, you’re losing”, or so said Dan Saks when discussing migrating legacy C codebases to C++. Many of the arguments that you hear against using C++ deal with the level of abstraction provided by objects and the STL (or templates, in general). However, there are many standard practices in C codebases that can benefit from some C++ tactics without having to introduce any of those features of the language. In this talk, we will look at some history of C to understand the viewpoint of C programmers. Then we will see methods to both improve both the reliability and maintainability of the codebase, while not alienating the existing developers. Along with these techniques, we will use compiler output that can be used to prove that we aren’t introducing any new overhead. Armed with these tools, we can move this legacy code and your team forward in preparation for the day where the file is renamed from C to CPP.
— 
Brian Ruth
Garmin, Ltd
Senior Software Engineer
bsruth@gmail.com

Brian has been programming in C++ for 20+ years; working for both small and large companies on a wide variety of projects and technologies. For over a decade he worked with neuroscience researchers and created high speed acquisition, analysis and visualization software. He is currently a senior software engineer at Garmin, developing embedded devices and migrating legacy modules to C++. When he isn’t knee deep in code, he is enjoying a home brewed beer or building some furniture. He has been a volunteer at CppCon since 2015.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,320 --> 00:00:11,950
so first of all thank you for coming my

00:00:10,540 --> 00:00:13,960
name is Brian Routh I'm a senior

00:00:11,950 --> 00:00:15,160
software engineer at Garmin and my talk

00:00:13,960 --> 00:00:17,230
today is going to be about infiltrating

00:00:15,160 --> 00:00:19,900
a code base or moving towards a better

00:00:17,230 --> 00:00:21,910
seat so first some motivation about this

00:00:19,900 --> 00:00:24,460
tuck so why are we having a sea talk at

00:00:21,910 --> 00:00:25,990
a C++ conference so I know if you

00:00:24,460 --> 00:00:28,600
remember but a few years back Dan sacks

00:00:25,990 --> 00:00:32,680
gave a talk I'm talking about how to top

00:00:28,600 --> 00:00:34,239
to C developers about C++ and the theme

00:00:32,680 --> 00:00:36,790
throughout the entire talk is if you

00:00:34,239 --> 00:00:38,620
were arguing you're losing and the talk

00:00:36,790 --> 00:00:40,600
wasn't so much about code or coding

00:00:38,620 --> 00:00:42,519
practices or things like that it was

00:00:40,600 --> 00:00:43,870
more about the psychology trying to

00:00:42,519 --> 00:00:45,309
understand the people that you're trying

00:00:43,870 --> 00:00:47,350
to convince and put yourself in their

00:00:45,309 --> 00:00:50,350
shoes so this got me thinking about my

00:00:47,350 --> 00:00:51,850
own like C++ evangelism like why didn't

00:00:50,350 --> 00:00:54,610
I always exceed when I was doing it and

00:00:51,850 --> 00:00:56,290
maybe I needed to understand better the

00:00:54,610 --> 00:00:57,879
people who was trying to convince you

00:00:56,290 --> 00:00:59,680
know play by the rules of their game

00:00:57,879 --> 00:01:02,920
before I try and influence them with

00:00:59,680 --> 00:01:05,770
mine so first of all like it or not C

00:01:02,920 --> 00:01:08,140
slash C++ is still a thing people still

00:01:05,770 --> 00:01:09,880
think that they're one in the same

00:01:08,140 --> 00:01:11,290
language but as developers of each

00:01:09,880 --> 00:01:13,150
language they are significantly

00:01:11,290 --> 00:01:15,250
different just because the syntax is

00:01:13,150 --> 00:01:16,810
similar doesn't mean that the way that

00:01:15,250 --> 00:01:18,400
they go about doing things the idioms

00:01:16,810 --> 00:01:20,380
the paradigms the way the code is

00:01:18,400 --> 00:01:21,550
flowing all of that is completely

00:01:20,380 --> 00:01:23,290
different between the two and it takes

00:01:21,550 --> 00:01:25,780
two different mentalities to understand

00:01:23,290 --> 00:01:27,580
these things so you need to understand

00:01:25,780 --> 00:01:29,380
the historical constraints of C when

00:01:27,580 --> 00:01:31,840
you're faced with some code that has

00:01:29,380 --> 00:01:33,490
things that look odd to you you need to

00:01:31,840 --> 00:01:35,290
understand where it comes from why they

00:01:33,490 --> 00:01:37,150
went that way what constraints the

00:01:35,290 --> 00:01:39,160
original authors were under when they

00:01:37,150 --> 00:01:41,200
wrote this code you also want to use

00:01:39,160 --> 00:01:42,670
code that's familiar to C developers if

00:01:41,200 --> 00:01:45,220
you start throwing in a bunch of classes

00:01:42,670 --> 00:01:46,540
and lambdas and algorithms and things

00:01:45,220 --> 00:01:48,460
like that that they don't they've never

00:01:46,540 --> 00:01:50,820
seen before it's just gonna alienate

00:01:48,460 --> 00:01:52,540
them and make them push back even harder

00:01:50,820 --> 00:01:56,380
but you also want to make sure you

00:01:52,540 --> 00:01:58,120
address fundamental concerns so take a

00:01:56,380 --> 00:02:00,190
look at this codebase see what the

00:01:58,120 --> 00:02:01,750
problems are see where the bugs are see

00:02:00,190 --> 00:02:03,940
what issues that they've fought with and

00:02:01,750 --> 00:02:05,590
then try and address your message to to

00:02:03,940 --> 00:02:06,790
those particular things because those

00:02:05,590 --> 00:02:09,700
are already pain points that they're

00:02:06,790 --> 00:02:11,349
aware of and you always don't get to

00:02:09,700 --> 00:02:13,450
start from scratch one of the things

00:02:11,349 --> 00:02:14,769
that coders love to do is to come in

00:02:13,450 --> 00:02:16,480
look at some code that they don't

00:02:14,769 --> 00:02:17,349
understand and say you know what I'm

00:02:16,480 --> 00:02:19,950
just going to write it from scratch

00:02:17,349 --> 00:02:22,170
well existing code has failed

00:02:19,950 --> 00:02:23,970
it's battle-tested it's been there for a

00:02:22,170 --> 00:02:25,950
while it's making the company money and

00:02:23,970 --> 00:02:27,630
by throwing it away or throwing away all

00:02:25,950 --> 00:02:29,340
of that a useful information that's been

00:02:27,630 --> 00:02:32,760
built up over years and years and years

00:02:29,340 --> 00:02:35,430
of that code being used so that kind of

00:02:32,760 --> 00:02:37,650
ends up with code that people are like

00:02:35,430 --> 00:02:39,420
don't touch this don't touch this at all

00:02:37,650 --> 00:02:42,900
it works if you need to make changes

00:02:39,420 --> 00:02:45,930
just make a copy of it so you see that a

00:02:42,900 --> 00:02:47,370
lot as well and tests if they exist at

00:02:45,930 --> 00:02:49,140
all they're probably not there on that

00:02:47,370 --> 00:02:51,690
set of code which is why no one touches

00:02:49,140 --> 00:02:53,850
it and you may get lucky and have some

00:02:51,690 --> 00:02:55,769
dot cpp files within your project but

00:02:53,850 --> 00:02:57,120
upon further inspection you'll notice

00:02:55,769 --> 00:02:59,970
that it's literally just see with a

00:02:57,120 --> 00:03:01,500
different extension and another reason

00:02:59,970 --> 00:03:03,330
is old projects still need to be

00:03:01,500 --> 00:03:05,280
supported so maybe there's some bug

00:03:03,330 --> 00:03:07,530
fixes or regulation changes or something

00:03:05,280 --> 00:03:09,810
and you need to use some old project

00:03:07,530 --> 00:03:12,420
with an old compiler and you need to

00:03:09,810 --> 00:03:13,980
understand the C code because you're

00:03:12,420 --> 00:03:16,110
under those constraints to make that

00:03:13,980 --> 00:03:19,860
maintenance release so understanding

00:03:16,110 --> 00:03:21,989
where C came from is another benefit so

00:03:19,860 --> 00:03:23,910
why not C++ so this is kind of an

00:03:21,989 --> 00:03:25,769
informal poll of C programmers that I've

00:03:23,910 --> 00:03:28,560
talked to so you hear things like it's

00:03:25,769 --> 00:03:29,850
object-oriented macros and templates are

00:03:28,560 --> 00:03:32,430
just the same for debugging

00:03:29,850 --> 00:03:35,070
it's bloated C flips post hides what

00:03:32,430 --> 00:03:37,380
it's doing from you my team knows C they

00:03:35,070 --> 00:03:39,269
don't know C++ and these are all

00:03:37,380 --> 00:03:41,730
legitimate concerns coming from C

00:03:39,269 --> 00:03:43,680
developers so if you start arguing back

00:03:41,730 --> 00:03:45,840
against any of these things you've

00:03:43,680 --> 00:03:47,100
already lost so there's you know you're

00:03:45,840 --> 00:03:50,430
not gonna win you're not gonna get them

00:03:47,100 --> 00:03:52,650
to move forward so you need to know your

00:03:50,430 --> 00:03:54,180
users you need to know not only the

00:03:52,650 --> 00:03:56,250
people using your code outside the

00:03:54,180 --> 00:03:58,200
company but also you need to understand

00:03:56,250 --> 00:04:00,630
the code or the people using your code

00:03:58,200 --> 00:04:02,010
within the company so you can't take a C

00:04:00,630 --> 00:04:02,760
codebase and immediately switch it over

00:04:02,010 --> 00:04:06,390
to C++

00:04:02,760 --> 00:04:08,430
especially modern C++ so first of all

00:04:06,390 --> 00:04:10,530
the tools may not support it I had

00:04:08,430 --> 00:04:14,040
something a few weeks back where I spent

00:04:10,530 --> 00:04:16,049
a weekend back porting some code to c99

00:04:14,040 --> 00:04:18,600
because one of the projects that used

00:04:16,049 --> 00:04:21,720
that code had to use a compiler that

00:04:18,600 --> 00:04:23,729
didn't support anything past C 98 so you

00:04:21,720 --> 00:04:25,229
need to before you go down this path of

00:04:23,729 --> 00:04:27,349
making all these wholesale changes you

00:04:25,229 --> 00:04:30,960
need to understand who's using that code

00:04:27,349 --> 00:04:31,820
and traditionally two compilers for C++

00:04:30,960 --> 00:04:34,880
I work on embedded

00:04:31,820 --> 00:04:37,490
vices have been very very poor at C++

00:04:34,880 --> 00:04:40,970
most of the embedded embedded compiler

00:04:37,490 --> 00:04:42,590
makers have focused on C because that's

00:04:40,970 --> 00:04:45,260
what all of their their customers use

00:04:42,590 --> 00:04:47,420
only recently has C++ started getting

00:04:45,260 --> 00:04:49,700
more and more support for for compilers

00:04:47,420 --> 00:04:51,020
but that's you know another historical

00:04:49,700 --> 00:04:54,830
reason that people have been leery of

00:04:51,020 --> 00:04:56,660
using C++ C++ may also introduce

00:04:54,830 --> 00:04:58,550
problems memory performance or other

00:04:56,660 --> 00:05:00,380
things like that so if you take a look

00:04:58,550 --> 00:05:02,720
and you see some code that looks really

00:05:00,380 --> 00:05:04,550
odd well there might be a reason for

00:05:02,720 --> 00:05:06,740
that that might be some workaround for

00:05:04,550 --> 00:05:09,110
some firmware on some chip that we have

00:05:06,740 --> 00:05:10,730
no control over so if you go and change

00:05:09,110 --> 00:05:12,500
it and make it better you may actually

00:05:10,730 --> 00:05:15,920
be breaking everything so understand

00:05:12,500 --> 00:05:17,660
what's going on but a common common

00:05:15,920 --> 00:05:19,610
ground for both for everybody involved

00:05:17,660 --> 00:05:22,250
is we want to make safer and more

00:05:19,610 --> 00:05:25,490
maintainable code the default so what

00:05:22,250 --> 00:05:27,800
steps as C++ developers can we take to

00:05:25,490 --> 00:05:30,140
start moving this cutting C developers

00:05:27,800 --> 00:05:31,760
for making this code better well we want

00:05:30,140 --> 00:05:33,860
to make it easier to read legacy code is

00:05:31,760 --> 00:05:35,900
fraught with a lot of issues of readable

00:05:33,860 --> 00:05:38,600
so we want minimize macros utilize

00:05:35,900 --> 00:05:40,640
constant scoping isolate Global's we

00:05:38,600 --> 00:05:42,110
want to reduce duplication reducing

00:05:40,640 --> 00:05:44,150
function size is one good way to do that

00:05:42,110 --> 00:05:46,670
we don't want to introduce regressions

00:05:44,150 --> 00:05:49,940
one surefire way to stop things is if

00:05:46,670 --> 00:05:51,350
the code that you enter is worse

00:05:49,940 --> 00:05:52,730
performing than the code you're

00:05:51,350 --> 00:05:56,230
replacing so you need to make sure that

00:05:52,730 --> 00:05:58,370
the new code is as good if not more

00:05:56,230 --> 00:06:00,050
efficient than the code you're replacing

00:05:58,370 --> 00:06:01,880
and you want to speak the same language

00:06:00,050 --> 00:06:04,520
you want to use the C compatible or at

00:06:01,880 --> 00:06:06,020
least the C familiar set of C++ so that

00:06:04,520 --> 00:06:07,880
everybody on all the teams can keep

00:06:06,020 --> 00:06:13,480
moving forward as you're improving this

00:06:07,880 --> 00:06:16,100
code all right so minimizing macro use

00:06:13,480 --> 00:06:18,800
this is going to kind of get them used

00:06:16,100 --> 00:06:20,150
to the C++ type system and trying to

00:06:18,800 --> 00:06:23,960
start using the compiler to kind of help

00:06:20,150 --> 00:06:26,990
them out so macros are are necessary

00:06:23,960 --> 00:06:28,280
sometimes in C there is no generics so

00:06:26,990 --> 00:06:30,260
having something like this which just

00:06:28,280 --> 00:06:33,470
gives you a max Val of two numeric

00:06:30,260 --> 00:06:35,060
values is necessary it's not type check

00:06:33,470 --> 00:06:36,530
but it's how you have to do it and

00:06:35,060 --> 00:06:39,470
another one and this is actually

00:06:36,530 --> 00:06:41,270
currently true in in C++ until your

00:06:39,470 --> 00:06:43,980
generators in twenty three or twenty six

00:06:41,270 --> 00:06:45,900
is going to be to stamp out boiler

00:06:43,980 --> 00:06:49,560
this is pretty much the only way to do

00:06:45,900 --> 00:06:51,000
that right now another one is a

00:06:49,560 --> 00:06:52,410
conditional compilation I know there was

00:06:51,000 --> 00:06:54,060
a talk earlier today about getting rid

00:06:52,410 --> 00:06:55,410
of this but it still ubiquitous it's

00:06:54,060 --> 00:06:57,330
everywhere so if you wanted to have

00:06:55,410 --> 00:06:59,610
debug print statements that are removed

00:06:57,330 --> 00:07:02,090
during release this is one way to go

00:06:59,610 --> 00:07:05,130
about doing it and another one is

00:07:02,090 --> 00:07:06,900
inheritance so si has no concept of

00:07:05,130 --> 00:07:09,240
inheritance so if you wanted to have a

00:07:06,900 --> 00:07:11,490
function that takes in those packet

00:07:09,240 --> 00:07:14,030
processing and then either process is

00:07:11,490 --> 00:07:16,230
large or small packets based on the type

00:07:14,030 --> 00:07:17,520
this is how you're gonna have to do it

00:07:16,230 --> 00:07:19,920
if you want cast between the two I'm

00:07:17,520 --> 00:07:22,050
assuming that's the packing is the same

00:07:19,920 --> 00:07:23,790
for both of those but this is also a 3/4

00:07:22,050 --> 00:07:25,740
C++ at least for now if you have some

00:07:23,790 --> 00:07:27,450
type of external generator that creates

00:07:25,740 --> 00:07:29,940
a bunch of getters and setters that are

00:07:27,450 --> 00:07:31,740
then later on put into your class this

00:07:29,940 --> 00:07:36,720
is one of the better ways to go about

00:07:31,740 --> 00:07:38,460
doing it compile time constants so C

00:07:36,720 --> 00:07:40,470
does not allow constant L values to be

00:07:38,460 --> 00:07:42,060
used at compile time so all of these

00:07:40,470 --> 00:07:44,280
instances and C++ of these are

00:07:42,060 --> 00:07:46,680
completely valid code button C it fails

00:07:44,280 --> 00:07:48,720
to compile can't use it as a size and

00:07:46,680 --> 00:07:50,190
array can't use it as a case in a switch

00:07:48,720 --> 00:07:54,720
statement you can't even use it to

00:07:50,190 --> 00:07:56,490
calculate another constant integer so

00:07:54,720 --> 00:07:58,500
you see these types of things in C using

00:07:56,490 --> 00:08:01,560
macros as a constant preprocessor comes

00:07:58,500 --> 00:08:03,960
in just replaces it fine and this as a

00:08:01,560 --> 00:08:06,450
C++ developer going and looking at C

00:08:03,960 --> 00:08:07,890
code it was really weird to see large

00:08:06,450 --> 00:08:09,630
unnamed enums

00:08:07,890 --> 00:08:11,550
with a whole bunch of completely

00:08:09,630 --> 00:08:13,860
unrelated values that just have data

00:08:11,550 --> 00:08:15,480
assigned to them well the reason behind

00:08:13,860 --> 00:08:17,400
it is enums are actually constant

00:08:15,480 --> 00:08:19,170
expressions they can be used at compile

00:08:17,400 --> 00:08:21,210
time and they're also going to be int

00:08:19,170 --> 00:08:23,160
compatible so that means that they're at

00:08:21,210 --> 00:08:25,320
least an INT but depending on the

00:08:23,160 --> 00:08:29,610
compiler they may make it smaller if

00:08:25,320 --> 00:08:32,220
they can but not all constants are

00:08:29,610 --> 00:08:34,470
needed at compile time so sometimes you

00:08:32,220 --> 00:08:36,360
can use run time constants so here on

00:08:34,470 --> 00:08:37,800
the left-hand side I've got a display

00:08:36,360 --> 00:08:40,050
using a macro on the right-hand side

00:08:37,800 --> 00:08:42,330
I've got the display using a constant

00:08:40,050 --> 00:08:43,920
integer and as it turns out the code

00:08:42,330 --> 00:08:45,630
generated between the two is exactly the

00:08:43,920 --> 00:08:47,310
same the compiler is smart enough to

00:08:45,630 --> 00:08:50,610
know that this constants can just be

00:08:47,310 --> 00:08:52,320
replaced another time that macros are

00:08:50,610 --> 00:08:54,540
used a lot is in what I'm calling pseudo

00:08:52,320 --> 00:08:56,649
functions so we're in a section of code

00:08:54,540 --> 00:08:58,569
is instead of just inline

00:08:56,649 --> 00:09:00,910
pasted its broken out into a separate

00:08:58,569 --> 00:09:02,470
callable thing so a nice thing about

00:09:00,910 --> 00:09:04,680
this at least from the metod side is

00:09:02,470 --> 00:09:07,149
that it forces the compiler to inline

00:09:04,680 --> 00:09:09,519
the code everywhere it's quote called

00:09:07,149 --> 00:09:10,600
the downside though is that it can lead

00:09:09,519 --> 00:09:12,009
to kill a bloke because this is just

00:09:10,600 --> 00:09:13,480
copy and pasted all over and you're kind

00:09:12,009 --> 00:09:16,779
of short circuiting with the compiler

00:09:13,480 --> 00:09:19,179
the compilers ability to smartly inline

00:09:16,779 --> 00:09:21,429
things there's also no type checking so

00:09:19,179 --> 00:09:23,889
your errors or warnings might be really

00:09:21,429 --> 00:09:25,749
weird debuggers 10 have a really hard

00:09:23,889 --> 00:09:27,279
time stepping through and it's also

00:09:25,749 --> 00:09:29,829
prone to a lot of maintenance issues you

00:09:27,279 --> 00:09:31,540
know correct braces correct parentheses

00:09:29,829 --> 00:09:33,879
semicolons so sometimes you'll even

00:09:31,540 --> 00:09:36,009
actually see a you know do-while zero

00:09:33,879 --> 00:09:38,439
around there to hopefully make it easier

00:09:36,009 --> 00:09:39,999
to maintain or use another thing is that

00:09:38,439 --> 00:09:41,860
all the multi-line code you need to make

00:09:39,999 --> 00:09:45,670
sure it ends not only in the semicolon

00:09:41,860 --> 00:09:47,230
but also in a backslash and if you

00:09:45,670 --> 00:09:49,839
forget this I've seen this forgotten in

00:09:47,230 --> 00:09:51,399
code and it actually compiles and it was

00:09:49,839 --> 00:09:53,410
really weird and really difficult to try

00:09:51,399 --> 00:09:55,660
to figure out what was going on

00:09:53,410 --> 00:09:57,129
you also can't have preprocessor check

00:09:55,660 --> 00:09:58,869
so if I wanted have debug statements

00:09:57,129 --> 00:10:00,339
those can't go in there and as we'll see

00:09:58,869 --> 00:10:03,879
in the next slide local variables can't

00:10:00,339 --> 00:10:05,889
actually be hidden within that macro so

00:10:03,879 --> 00:10:07,329
make real functions allow the compiler

00:10:05,889 --> 00:10:09,939
decide whether or not it's in lined or

00:10:07,329 --> 00:10:11,829
not Jason Turner did a simple sauce

00:10:09,939 --> 00:10:13,300
Winkley a while back showing how clang

00:10:11,829 --> 00:10:16,360
determines whether or not the in line

00:10:13,300 --> 00:10:17,529
things and how we can mess with that the

00:10:16,360 --> 00:10:18,910
arguments gonna be type checked so

00:10:17,529 --> 00:10:20,949
you'll actually get real you know

00:10:18,910 --> 00:10:21,339
compiler warnings errors and things like

00:10:20,949 --> 00:10:22,929
that

00:10:21,339 --> 00:10:24,189
the codes going to read as normal source

00:10:22,929 --> 00:10:26,589
you don't need to think about the

00:10:24,189 --> 00:10:28,449
context necessarily of where this macro

00:10:26,589 --> 00:10:30,699
is invoked it's a real function with a

00:10:28,449 --> 00:10:32,980
real call real arguments you can put

00:10:30,699 --> 00:10:35,829
preprocessor macros in there and this

00:10:32,980 --> 00:10:37,660
also exposed a hidden dependency so the

00:10:35,829 --> 00:10:39,970
macro assumed that there was a text

00:10:37,660 --> 00:10:41,379
coordinate in a string color of type XY

00:10:39,970 --> 00:10:45,610
type and colors type that were declared

00:10:41,379 --> 00:10:48,040
prior to invoking that macro well now

00:10:45,610 --> 00:10:48,370
it's explicitly part of the the function

00:10:48,040 --> 00:10:49,949
call

00:10:48,370 --> 00:10:52,120
you'll get errors and get warnings and

00:10:49,949 --> 00:10:55,619
you can call them locally whatever you

00:10:52,120 --> 00:10:58,089
want variable names that make sense and

00:10:55,619 --> 00:10:59,769
turns out compilers like to in line on

00:10:58,089 --> 00:11:00,970
the left-hand side is the macro version

00:10:59,769 --> 00:11:03,009
and the right-hand side is the broken

00:11:00,970 --> 00:11:05,110
out function version zooming in on that

00:11:03,009 --> 00:11:07,499
a chart turns out that both of those are

00:11:05,110 --> 00:11:07,499
in lines

00:11:07,500 --> 00:11:13,710
so utilizing constant and scoping so

00:11:12,210 --> 00:11:16,320
this is China cut get that the C++

00:11:13,710 --> 00:11:19,550
concepts of REI Const expert and again

00:11:16,320 --> 00:11:21,390
the type system so C++ developers

00:11:19,550 --> 00:11:23,040
scoping is something that you're kind of

00:11:21,390 --> 00:11:24,510
drilled into first day always declare

00:11:23,040 --> 00:11:26,670
things where they're used well

00:11:24,510 --> 00:11:29,820
historically speaking C didn't support

00:11:26,670 --> 00:11:31,740
that so C 8990 which is the ANSI C

00:11:29,820 --> 00:11:33,860
standard all variables had to be

00:11:31,740 --> 00:11:35,820
declared at the top of the scope so

00:11:33,860 --> 00:11:38,100
declarations and executable statements

00:11:35,820 --> 00:11:41,070
also could it be intermixed so something

00:11:38,100 --> 00:11:43,830
like this int I equals 0 fine J fine

00:11:41,070 --> 00:11:46,530
assign J executable statement hour fails

00:11:43,830 --> 00:11:48,990
to compile inside some condition new

00:11:46,530 --> 00:11:51,960
scope you're okay so one of the reasons

00:11:48,990 --> 00:11:54,060
and in a lot of C code you see in ty JK

00:11:51,960 --> 00:11:56,430
sitting up at the top of the function is

00:11:54,060 --> 00:11:58,860
because 4 does not introduce a new scope

00:11:56,430 --> 00:12:01,350
so you couldn't declare K there it won't

00:11:58,860 --> 00:12:03,090
compile but once you get into the loop

00:12:01,350 --> 00:12:05,940
new scope you're fine

00:12:03,090 --> 00:12:07,590
incidentally C 99 or the ISO C standard

00:12:05,940 --> 00:12:09,840
remove this requirement so if you can

00:12:07,590 --> 00:12:12,510
use a compiler that's 20 years

00:12:09,840 --> 00:12:17,100
out-of-date you you should be okay to

00:12:12,510 --> 00:12:19,290
use this but because of that initial

00:12:17,100 --> 00:12:21,780
syntax we're declaring everything at the

00:12:19,290 --> 00:12:23,640
top this has led to a lot of variable

00:12:21,780 --> 00:12:25,350
reuse so instead of having you know

00:12:23,640 --> 00:12:27,330
multiple declarations of all the

00:12:25,350 --> 00:12:29,190
different names of a temp integer

00:12:27,330 --> 00:12:31,530
throughout the function and declaring a

00:12:29,190 --> 00:12:35,070
bunch of different stack variables you

00:12:31,530 --> 00:12:36,450
see this generic temp paradigm used so

00:12:35,070 --> 00:12:38,310
imagine this is a really long function

00:12:36,450 --> 00:12:41,340
at the top temp into ends up becoming

00:12:38,310 --> 00:12:43,220
the width and used to layout a page and

00:12:41,340 --> 00:12:45,780
then later on in the function it's

00:12:43,220 --> 00:12:48,350
orbital velocity it really makes

00:12:45,780 --> 00:12:51,990
understanding what this code does and

00:12:48,350 --> 00:12:53,700
maintaining the code very difficult it

00:12:51,990 --> 00:12:55,650
turns out compilers are used to this so

00:12:53,700 --> 00:12:57,510
on the left hand side is the temp int on

00:12:55,650 --> 00:13:00,920
the right hand side I've got constant

00:12:57,510 --> 00:13:03,690
named variables for each of those

00:13:00,920 --> 00:13:05,610
temporary integers and it turns out the

00:13:03,690 --> 00:13:07,290
compiler can just see right through it

00:13:05,610 --> 00:13:09,180
notice that the integers and reused

00:13:07,290 --> 00:13:12,540
afterwards and generate the exact same

00:13:09,180 --> 00:13:16,020
code this is even true for structs i've

00:13:12,540 --> 00:13:18,150
seen and have done in the past in a for

00:13:16,020 --> 00:13:19,620
loop if if I have to keep filling a

00:13:18,150 --> 00:13:21,720
struct with some data I would always do

00:13:19,620 --> 00:13:23,610
beforehand and not inside because I

00:13:21,720 --> 00:13:25,830
don't want this for loop to reallocate

00:13:23,610 --> 00:13:27,480
every single time through well this is

00:13:25,830 --> 00:13:30,350
something that compilers use to as well

00:13:27,480 --> 00:13:34,230
put it inside the for-loop same code

00:13:30,350 --> 00:13:36,860
quick aside macro scoping I have noticed

00:13:34,230 --> 00:13:41,010
in code macros defined within functions

00:13:36,860 --> 00:13:43,230
macros do not have scope so something

00:13:41,010 --> 00:13:45,990
like this reach from the top down on the

00:13:43,230 --> 00:13:48,660
file first is defined my Val seven okay

00:13:45,990 --> 00:13:51,180
further down my Val's used okay its

00:13:48,660 --> 00:13:53,400
redefined down there this may generates

00:13:51,180 --> 00:13:55,800
generate a warning if you have warnings

00:13:53,400 --> 00:13:57,360
turned on or if it does generate a

00:13:55,800 --> 00:13:58,589
warning if you can notice it with all

00:13:57,360 --> 00:14:01,200
the thousands of other warnings that

00:13:58,589 --> 00:14:02,910
you're seeing so this particular one

00:14:01,200 --> 00:14:04,620
when you get into main it's going to

00:14:02,910 --> 00:14:06,150
print out seven because that's where it

00:14:04,620 --> 00:14:08,850
is at that point it's gonna call up two

00:14:06,150 --> 00:14:10,470
blorp which is gonna have seven again go

00:14:08,850 --> 00:14:12,330
down to the other function print out

00:14:10,470 --> 00:14:14,760
nine and then go back to main where the

00:14:12,330 --> 00:14:15,990
value has been replaced with seven under

00:14:14,760 --> 00:14:18,420
maintenance let's say this cow gets

00:14:15,990 --> 00:14:20,700
rearranged it completely changes what

00:14:18,420 --> 00:14:26,339
this code does because it just reads

00:14:20,700 --> 00:14:29,100
down from the top down so const in c so

00:14:26,339 --> 00:14:32,310
c 89 didn't have const and seen ID edit

00:14:29,100 --> 00:14:34,140
constant volvo constancy does not mean

00:14:32,310 --> 00:14:37,350
cast an expression it means read-only

00:14:34,140 --> 00:14:39,830
and that's only by software c cost of a

00:14:37,350 --> 00:14:42,000
little for hardware main manipulation

00:14:39,830 --> 00:14:44,070
but you see for the same reasons that

00:14:42,000 --> 00:14:46,770
you constancy for the same reasons you

00:14:44,070 --> 00:14:48,450
use in c++ so code contracts if someone

00:14:46,770 --> 00:14:49,589
sees it counts there it tells them

00:14:48,450 --> 00:14:50,630
something about the code that they're

00:14:49,589 --> 00:14:53,130
calling the code that they're using

00:14:50,630 --> 00:14:54,240
readability so when you're going through

00:14:53,130 --> 00:14:56,250
trying to figure out what a function

00:14:54,240 --> 00:14:58,350
does if you see something assigned to a

00:14:56,250 --> 00:15:01,320
const well you have to worry about that

00:14:58,350 --> 00:15:03,089
ever changing again compiler hints so

00:15:01,320 --> 00:15:04,709
but making something Const you're

00:15:03,089 --> 00:15:06,540
telling the compiler hey this isn't

00:15:04,709 --> 00:15:08,730
gonna change go ahead and optimize it

00:15:06,540 --> 00:15:10,529
and two insurance options when you're

00:15:08,730 --> 00:15:12,450
maintaining legacy code or trying to

00:15:10,529 --> 00:15:13,589
refactor or legacy code if you assume

00:15:12,450 --> 00:15:15,510
something's not going to change

00:15:13,589 --> 00:15:17,040
make it count if the can fail is to

00:15:15,510 --> 00:15:20,310
compile your assumptions need to be

00:15:17,040 --> 00:15:23,490
re-evaluated so const all the things

00:15:20,310 --> 00:15:24,750
make all function arguments const so

00:15:23,490 --> 00:15:26,790
many times especially in longer

00:15:24,750 --> 00:15:28,110
functions the argument variables are

00:15:26,790 --> 00:15:30,150
actually reassigned and reused

00:15:28,110 --> 00:15:31,350
throughout the courses function and that

00:15:30,150 --> 00:15:32,209
makes it really difficult to determine

00:15:31,350 --> 00:15:33,589
where

00:15:32,209 --> 00:15:37,160
our what things are going on if the

00:15:33,589 --> 00:15:39,199
value keeps changing cling tightly wound

00:15:37,160 --> 00:15:42,139
zon this especially if you have it in

00:15:39,199 --> 00:15:43,519
the declaration but I actually believe

00:15:42,139 --> 00:15:46,100
it conveys a lot of useful information

00:15:43,519 --> 00:15:47,720
that you know even though the compiler

00:15:46,100 --> 00:15:48,980
isn't care that you called it Const the

00:15:47,720 --> 00:15:52,490
person calling the function might want

00:15:48,980 --> 00:15:55,639
to know another time that this is kind

00:15:52,490 --> 00:15:57,649
of useful is for complicated expressions

00:15:55,639 --> 00:15:58,550
especially conditionals so when you

00:15:57,649 --> 00:16:00,350
first start out with some code you've

00:15:58,550 --> 00:16:02,449
got it if and then a simple case simple

00:16:00,350 --> 00:16:04,459
you know condition in there but over

00:16:02,449 --> 00:16:07,279
time you start getting edge cases bugs

00:16:04,459 --> 00:16:09,199
things like that and it becomes a really

00:16:07,279 --> 00:16:11,240
complicated expression well if you can

00:16:09,199 --> 00:16:12,800
break those out into named constant

00:16:11,240 --> 00:16:13,369
boolean's and then put those into the if

00:16:12,800 --> 00:16:15,709
statement

00:16:13,369 --> 00:16:17,660
it gives the reader and the maintainer a

00:16:15,709 --> 00:16:19,399
better idea of what's going on and they

00:16:17,660 --> 00:16:21,860
can more readily reason about how your

00:16:19,399 --> 00:16:23,269
code works and most of the time the

00:16:21,860 --> 00:16:24,829
compiler just going to put all those in

00:16:23,269 --> 00:16:27,949
line anyways it's not gonna really cost

00:16:24,829 --> 00:16:29,449
you anything the other thing is making

00:16:27,949 --> 00:16:31,879
something Const enable some very

00:16:29,449 --> 00:16:34,579
powerful optimizations Jason had a

00:16:31,879 --> 00:16:36,619
keynote a few years back where he was

00:16:34,579 --> 00:16:39,350
messing with a Commodore 64 and by

00:16:36,619 --> 00:16:40,999
making one of the variables Const like

00:16:39,350 --> 00:16:50,059
it literally made almost all the program

00:16:40,999 --> 00:16:52,579
go away but isn't his side casting away

00:16:50,059 --> 00:16:54,949
Const don't ever cast away Const so just

00:16:52,579 --> 00:16:58,100
like in C++ the compilers free to ignore

00:16:54,949 --> 00:16:59,959
you for not one of the things you see in

00:16:58,100 --> 00:17:02,059
legacy code is because it's not

00:16:59,959 --> 00:17:03,499
necessarily keeping constant mind

00:17:02,059 --> 00:17:04,880
it's just functions to take things by

00:17:03,499 --> 00:17:06,470
pointers whether it's for efficiency or

00:17:04,880 --> 00:17:07,880
something else and they whether they

00:17:06,470 --> 00:17:09,589
change it or not they don't put the cons

00:17:07,880 --> 00:17:10,880
done there so when you're writing new

00:17:09,589 --> 00:17:13,039
code and you're making things constant

00:17:10,880 --> 00:17:14,720
correct to make the compiler shut up you

00:17:13,039 --> 00:17:16,159
simply just cast away cons to pass it

00:17:14,720 --> 00:17:19,370
into the function and everything works

00:17:16,159 --> 00:17:21,230
maybe so here I've got a new function

00:17:19,370 --> 00:17:24,020
that wraps an old one the value that I

00:17:21,230 --> 00:17:25,699
pass in I cast away that Const pass it

00:17:24,020 --> 00:17:28,069
in there it actually modifies the value

00:17:25,699 --> 00:17:29,690
but then I've got a local constant that

00:17:28,069 --> 00:17:32,450
I cast away the cons to pass it in and

00:17:29,690 --> 00:17:36,590
it's ignored so just don't cast away

00:17:32,450 --> 00:17:38,179
constant reducing function sighs so this

00:17:36,590 --> 00:17:41,710
is kind of getting into algorithms and

00:17:38,179 --> 00:17:41,710
classes and those types of things

00:17:41,890 --> 00:17:48,519
a thousand line function why do those

00:17:44,590 --> 00:17:50,409
exist how do they come to be so state

00:17:48,519 --> 00:17:52,539
machine message driven systems this

00:17:50,409 --> 00:17:54,580
happens a lot as you had new states new

00:17:52,539 --> 00:17:56,080
messages you want to handle those are

00:17:54,580 --> 00:17:58,360
literally just pasted into a switch

00:17:56,080 --> 00:17:59,919
statement and because they don't want to

00:17:58,360 --> 00:18:01,360
refactor the old code or don't want to

00:17:59,919 --> 00:18:02,909
pull out functions you just get more and

00:18:01,360 --> 00:18:04,840
more of those things put in their

00:18:02,909 --> 00:18:06,669
convenience you know sometimes you have

00:18:04,840 --> 00:18:08,440
to make a change and there's this one

00:18:06,669 --> 00:18:11,590
location where all the variables and

00:18:08,440 --> 00:18:12,880
functions and everything align and this

00:18:11,590 --> 00:18:14,289
is where I'm gonna put it even if the

00:18:12,880 --> 00:18:14,860
name of the function or whatever doesn't

00:18:14,289 --> 00:18:17,500
make sense

00:18:14,860 --> 00:18:19,779
hooks if I'm trying to put some new code

00:18:17,500 --> 00:18:21,519
into you know just place it into some

00:18:19,779 --> 00:18:24,010
older code you know maybe there's a

00:18:21,519 --> 00:18:25,990
convenient location again convenience to

00:18:24,010 --> 00:18:27,730
go in and and hook these two things up

00:18:25,990 --> 00:18:30,070
even if it again makes a little

00:18:27,730 --> 00:18:32,049
difficult to read and adapters so if

00:18:30,070 --> 00:18:32,559
you're adapting some new code to old

00:18:32,049 --> 00:18:34,720
code

00:18:32,559 --> 00:18:36,279
maybe you just throw that stuff in in

00:18:34,720 --> 00:18:39,820
line and a function to kind of make it

00:18:36,279 --> 00:18:41,860
do the manipulation right in place so

00:18:39,820 --> 00:18:43,450
long functions they generally do a lot

00:18:41,860 --> 00:18:44,889
of things not all of them are gonna be

00:18:43,450 --> 00:18:46,360
related so it makes reading the code

00:18:44,889 --> 00:18:48,519
maintaining the code really difficult

00:18:46,360 --> 00:18:50,710
they tend to have generic names like

00:18:48,519 --> 00:18:52,630
message processor which really gives the

00:18:50,710 --> 00:18:54,549
person who's reading the code or calling

00:18:52,630 --> 00:18:56,169
the code no idea of what the

00:18:54,549 --> 00:18:58,269
preconditions post conditions are even

00:18:56,169 --> 00:19:01,090
what that function will do to their

00:18:58,269 --> 00:19:03,850
program I usually see a lot of

00:19:01,090 --> 00:19:07,120
unnecessary control flow duplicated code

00:19:03,850 --> 00:19:08,740
you get that copy-paste modified so like

00:19:07,120 --> 00:19:10,360
this code works don't touch it

00:19:08,740 --> 00:19:12,460
all right well I'm gonna copy it over

00:19:10,360 --> 00:19:14,320
here make my one change move on and

00:19:12,460 --> 00:19:17,139
again variables changing meaning

00:19:14,320 --> 00:19:19,029
throughout the function so we want to

00:19:17,139 --> 00:19:21,070
find some refactoring seems things that

00:19:19,029 --> 00:19:23,529
are easy candidates to just pull out and

00:19:21,070 --> 00:19:25,510
make functions so switch statements

00:19:23,529 --> 00:19:27,190
nested another side can inside other

00:19:25,510 --> 00:19:29,830
control statements or for that key fact

00:19:27,190 --> 00:19:32,590
any other type of like nested control is

00:19:29,830 --> 00:19:35,049
a pretty good way of going about pulling

00:19:32,590 --> 00:19:37,929
things out for functions long if-else

00:19:35,049 --> 00:19:40,630
if-else chains if you can try and make

00:19:37,929 --> 00:19:42,730
these into a switch statement so at the

00:19:40,630 --> 00:19:44,649
very worst it'll decay into if-else

00:19:42,730 --> 00:19:46,149
if-else chains but if the compiler can

00:19:44,649 --> 00:19:48,279
find some fancy ways to make things more

00:19:46,149 --> 00:19:49,809
efficient it will I've actually had

00:19:48,279 --> 00:19:51,220
issue you know instances where I take

00:19:49,809 --> 00:19:53,200
something that's more of like a runtime

00:19:51,220 --> 00:19:53,760
whose case like trying to figure out

00:19:53,200 --> 00:19:56,370
like

00:19:53,760 --> 00:19:58,650
button was clicked in a UI converted all

00:19:56,370 --> 00:20:00,900
that runtime stuff to figure out which

00:19:58,650 --> 00:20:02,280
button was clicked made that an enum it

00:20:00,900 --> 00:20:03,990
pulled it back out did a switch that

00:20:02,280 --> 00:20:05,940
statement generator there was a whole

00:20:03,990 --> 00:20:07,170
bunch more code but when it compiled it

00:20:05,940 --> 00:20:08,640
actually ended up being more efficient

00:20:07,170 --> 00:20:11,310
because the compiler was able to make

00:20:08,640 --> 00:20:14,760
some assumptions this is my favorite one

00:20:11,310 --> 00:20:17,700
comments indicating what they do not why

00:20:14,760 --> 00:20:19,230
they do it so if you have a section of

00:20:17,700 --> 00:20:21,780
code that has a comment that says

00:20:19,230 --> 00:20:23,640
displays string and pop page and then

00:20:21,780 --> 00:20:25,260
followed by eight lines of code take

00:20:23,640 --> 00:20:26,880
those eight lines of code and put them

00:20:25,260 --> 00:20:30,840
into a function this says display string

00:20:26,880 --> 00:20:33,180
and pop page turns out to work very well

00:20:30,840 --> 00:20:34,410
another thing that line or IDs newer

00:20:33,180 --> 00:20:35,700
editors allow you to do is actually just

00:20:34,410 --> 00:20:37,800
take a look at the shape of the code

00:20:35,700 --> 00:20:39,390
this is Visual Studio and it's got like

00:20:37,800 --> 00:20:40,590
the classic arrow code you see it kind

00:20:39,390 --> 00:20:42,270
of going towards the edge and then

00:20:40,590 --> 00:20:45,330
coming back in and that's gonna indicate

00:20:42,270 --> 00:20:47,870
a lot of nested statements so or just

00:20:45,330 --> 00:20:51,270
sections of code that have similar looks

00:20:47,870 --> 00:20:52,710
so some more subtle seems okay so on the

00:20:51,270 --> 00:20:54,630
left hand side is a get employees from

00:20:52,710 --> 00:20:56,550
department where are you passing a list

00:20:54,630 --> 00:20:58,230
give it an employee Department and it

00:20:56,550 --> 00:20:59,970
gives you a filtered list on the right

00:20:58,230 --> 00:21:02,280
hand side is employees with greater than

00:20:59,970 --> 00:21:04,230
some number of years the only difference

00:21:02,280 --> 00:21:07,080
between these two functions are those

00:21:04,230 --> 00:21:10,800
two comparisons how do we add things to

00:21:07,080 --> 00:21:14,280
the function function pointers in C have

00:21:10,800 --> 00:21:16,530
existed for ever and one of the things

00:21:14,280 --> 00:21:18,510
though is that I don't see them used in

00:21:16,530 --> 00:21:21,540
the way that C++ programmers use

00:21:18,510 --> 00:21:22,920
algorithms so something like this you

00:21:21,540 --> 00:21:24,960
can actually have like a filter list

00:21:22,920 --> 00:21:27,540
function that's going to take a

00:21:24,960 --> 00:21:30,030
predicate and it's gonna be whether it's

00:21:27,540 --> 00:21:32,490
an engineer or whether it's a four week

00:21:30,030 --> 00:21:33,750
vacation and as you have more things you

00:21:32,490 --> 00:21:35,520
can just keep passing that to this

00:21:33,750 --> 00:21:37,710
function and if you needed to pass more

00:21:35,520 --> 00:21:39,990
parameters you can just you know extend

00:21:37,710 --> 00:21:44,190
put some void stars or whatever at the

00:21:39,990 --> 00:21:47,970
end of your filter list but if you can't

00:21:44,190 --> 00:21:49,260
refactor it right now rename so if you

00:21:47,970 --> 00:21:50,580
spend all this time looking at this

00:21:49,260 --> 00:21:52,770
function and it takes you forever

00:21:50,580 --> 00:21:54,480
understand okay it does some setup but

00:21:52,770 --> 00:21:56,820
check to see if it exists it updates a

00:21:54,480 --> 00:21:57,720
record it adds a new record if you don't

00:21:56,820 --> 00:21:59,610
have the time to go through and

00:21:57,720 --> 00:22:01,560
rearrange all this capture your

00:21:59,610 --> 00:22:03,180
knowledge by renaming it whether it's a

00:22:01,560 --> 00:22:04,590
variable whether it's the function name

00:22:03,180 --> 00:22:05,800
if your cake if you can do it if not too

00:22:04,590 --> 00:22:08,740
many things depend on it

00:22:05,800 --> 00:22:10,870
so if this was called update or add

00:22:08,740 --> 00:22:12,520
request to database it's got at least

00:22:10,870 --> 00:22:15,780
tell somebody who's calling it what the

00:22:12,520 --> 00:22:18,160
function is gonna do when you call it so

00:22:15,780 --> 00:22:19,750
hopefully you know next time you come by

00:22:18,160 --> 00:22:21,460
you'll understand it save yourself a

00:22:19,750 --> 00:22:22,660
bunch of time and if somebody gets

00:22:21,460 --> 00:22:26,170
really annoyed by the name maybe they'll

00:22:22,660 --> 00:22:30,580
go and refactor it for you and the last

00:22:26,170 --> 00:22:33,040
thing is isolating Global's so this is

00:22:30,580 --> 00:22:35,770
getting towards C++ classes so C is a

00:22:33,040 --> 00:22:38,740
global language it is used constantly

00:22:35,770 --> 00:22:41,620
throughout the coding paradigms of C one

00:22:38,740 --> 00:22:43,030
of the more insidious ones are external

00:22:41,620 --> 00:22:44,170
and variables and implicit functions

00:22:43,030 --> 00:22:45,870
where you basically just rely on the

00:22:44,170 --> 00:22:48,010
linker to fix everything for you but

00:22:45,870 --> 00:22:51,310
macros and global variables exist as

00:22:48,010 --> 00:22:53,590
well so quick exercise so this code

00:22:51,310 --> 00:22:56,950
snippet here relies on a global current

00:22:53,590 --> 00:22:58,870
canvas so it's X turned out and there's

00:22:56,950 --> 00:23:01,080
a column count and it makes it sets a

00:22:58,870 --> 00:23:03,430
dirty flag and when you draw it's dirty

00:23:01,080 --> 00:23:05,590
recalculates the width and then clears

00:23:03,430 --> 00:23:07,270
the dirty flag so what the first things

00:23:05,590 --> 00:23:09,070
we can do is pull that funk that

00:23:07,270 --> 00:23:11,050
variable out into a function that

00:23:09,070 --> 00:23:12,310
returns a constant pointer and what

00:23:11,050 --> 00:23:14,380
that's gonna do is it to identify the

00:23:12,310 --> 00:23:18,190
locations we're modifying that variable

00:23:14,380 --> 00:23:20,380
or that global so it's not going to

00:23:18,190 --> 00:23:21,850
compile next thing you can do is make a

00:23:20,380 --> 00:23:23,590
mutable version of that function and

00:23:21,850 --> 00:23:25,510
then put that in all the locations where

00:23:23,590 --> 00:23:26,980
it's modified and then take a look at

00:23:25,510 --> 00:23:28,780
all the places where it's modified and

00:23:26,980 --> 00:23:30,550
see if there's any similarities can this

00:23:28,780 --> 00:23:31,870
be made into a separate function for

00:23:30,550 --> 00:23:34,000
this particular example it's just

00:23:31,870 --> 00:23:35,110
setting and clearing the dirty flag so

00:23:34,000 --> 00:23:39,670
let's make a separate function for that

00:23:35,110 --> 00:23:42,490
and as it turns out I charred again left

00:23:39,670 --> 00:23:44,290
hand side is going to be the global

00:23:42,490 --> 00:23:45,970
version right hand side it's going to be

00:23:44,290 --> 00:23:48,160
the all the functions broken out into

00:23:45,970 --> 00:23:51,600
the same final version it ends up

00:23:48,160 --> 00:23:54,460
generating the exact same code so

00:23:51,600 --> 00:23:57,190
ideally we would like to get here we

00:23:54,460 --> 00:23:59,670
would like to get to having things

00:23:57,190 --> 00:24:02,230
separated out into separate classes and

00:23:59,670 --> 00:24:04,090
separate files one of the problems with

00:24:02,230 --> 00:24:05,890
that though is at least for this

00:24:04,090 --> 00:24:07,990
particular thing it really depends on

00:24:05,890 --> 00:24:09,610
how it's implemented because the way

00:24:07,990 --> 00:24:12,100
it's implemented here does actually

00:24:09,610 --> 00:24:13,630
generate a few extra function call

00:24:12,100 --> 00:24:16,530
overhead or a little extra function call

00:24:13,630 --> 00:24:18,360
overhead so

00:24:16,530 --> 00:24:20,130
you don't want to put that in because

00:24:18,360 --> 00:24:24,240
one of the rules is you don't want to

00:24:20,130 --> 00:24:25,650
introduce any extra overhead so this

00:24:24,240 --> 00:24:27,110
take away from this and wow this

00:24:25,650 --> 00:24:29,640
finished a lot quicker than I thought

00:24:27,110 --> 00:24:32,640
the takeaway from this is if you're

00:24:29,640 --> 00:24:34,440
arguing you're losing so just make sure

00:24:32,640 --> 00:24:35,460
that you're putting yourself in the

00:24:34,440 --> 00:24:38,789
shoes of the people that you're talking

00:24:35,460 --> 00:24:40,860
to some resources here trusting your

00:24:38,789 --> 00:24:42,809
compiler Matt God bolts what I want you

00:24:40,860 --> 00:24:45,390
to know about how amazing compilers are

00:24:42,809 --> 00:24:46,650
some really cool things about just how

00:24:45,390 --> 00:24:48,960
the compiler can see through your code

00:24:46,650 --> 00:24:49,950
and make really weird math that does

00:24:48,960 --> 00:24:53,460
magic

00:24:49,950 --> 00:24:56,419
Jason's talk on the commodore 64 where

00:24:53,460 --> 00:24:59,250
he built pong on stage and play with her

00:24:56,419 --> 00:25:02,700
the the reason I started doing this talk

00:24:59,250 --> 00:25:05,010
is dance axes extern see talking to C

00:25:02,700 --> 00:25:07,830
programmers about C++

00:25:05,010 --> 00:25:09,659
Jason C++ weekly on inlining and then

00:25:07,830 --> 00:25:11,429
the whole section on naming I had first

00:25:09,659 --> 00:25:14,070
heard that on the legacy code Rox

00:25:11,429 --> 00:25:17,159
podcast but it turns out the guests are

00:25:14,070 --> 00:25:19,260
labelled she actually has an entire blog

00:25:17,159 --> 00:25:22,100
series on how to go about rename and

00:25:19,260 --> 00:25:24,480
refactoring names and legacy code and

00:25:22,100 --> 00:25:26,640
you know if we want to understand the

00:25:24,480 --> 00:25:29,720
history of C we should probably

00:25:26,640 --> 00:25:32,250
understand the history of C++ and how C

00:25:29,720 --> 00:25:34,440
influenced C++ and what changes were

00:25:32,250 --> 00:25:37,110
made and the reasons why so that we can

00:25:34,440 --> 00:25:40,309
again discuss with C developers what's

00:25:37,110 --> 00:25:44,039
going on and then two great books for

00:25:40,309 --> 00:25:46,409
working with legacy code by feathers and

00:25:44,039 --> 00:25:48,150
one is refactoring the second edition

00:25:46,409 --> 00:25:50,850
it's a little bit more updated for

00:25:48,150 --> 00:25:52,980
modern modern programming so well I

00:25:50,850 --> 00:25:56,780
actually have four minutes left for

00:25:52,980 --> 00:25:56,780
questions if anybody wants to ask

00:26:03,740 --> 00:26:09,680
you mentioned I think the very harmful

00:26:05,990 --> 00:26:12,800
feature in C but I think you did not pay

00:26:09,680 --> 00:26:15,140
attention for it it's implicit function

00:26:12,800 --> 00:26:18,500
declaration I think I should tell I must

00:26:15,140 --> 00:26:20,840
tell to everyone that this is only

00:26:18,500 --> 00:26:23,930
warning in C it's not an error and this

00:26:20,840 --> 00:26:28,070
warning must be switched into an error

00:26:23,930 --> 00:26:29,930
by compiler Fox right yeah it's not

00:26:28,070 --> 00:26:31,820
necessarily an error it's a warning and

00:26:29,930 --> 00:26:41,720
clean tidy actually like flags at all

00:26:31,820 --> 00:26:44,750
the time but my pain it shouldn't will

00:26:41,720 --> 00:26:47,720
you recommend to create in see something

00:26:44,750 --> 00:26:50,390
similar to C++ memory functions like

00:26:47,720 --> 00:26:54,170
special set of function work in this

00:26:50,390 --> 00:26:55,610
specific structure yeah yeah so I had a

00:26:54,170 --> 00:26:56,960
whole nother section this was originally

00:26:55,610 --> 00:26:58,490
proposed as a one-hour talk I don't

00:26:56,960 --> 00:27:00,380
another section about dealing with like

00:26:58,490 --> 00:27:02,000
pseudo classes and polymorphism and

00:27:00,380 --> 00:27:04,760
stuff like that trying to use the

00:27:02,000 --> 00:27:07,630
structures and and function pointers to

00:27:04,760 --> 00:27:07,630
do that type of thing

00:27:10,150 --> 00:27:16,910
all right cool thank you

00:27:13,710 --> 00:27:16,910

YouTube URL: https://www.youtube.com/watch?v=muvUKqsmGWU


