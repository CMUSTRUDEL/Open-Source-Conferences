Title: CppCon 2019: Dan Saks “Back to Basics: Const as a Promise”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
The const qualifier has various uses in C++. One of the most valuable uses is in declaring function headings that constrain the effects of function calls. Using const appropriately can reduce bugs and development time by turning potential run-time errors into compile-time errors that are much easier to find and correct. Using const can even reduce your program’s code size and execution time. 

Despite these benefits, too many C++ programmers still use const reactively rather than proactively. That is, they tend to add const as needed to quell compiler error messages, rather than design const in as they code. To get the most out of const, programmers really need to understand (1) when and where to place const in declarations, (2) when to leave it out entirely, and (3) how type conversions involving const behave. 

The key insight about const is to understand const as a promise—a promise not to modify something. This session explains the real meaning of that promise and how that insight can guide you in declaring function parameters and return types. It also explains why you shouldn’t declare by-value parameters and return types as const, why overloading on const is such a useful and ubiquitous idiom, and why it is meaningful to declare constexpr member functions as const.
— 
Dan Saks
Saks & Associates
President

Dan Saks is the president of Saks & Associates, which offers training and consulting in C and C++ and their use in developing embedded systems. Dan used to write the “Programming Pointers” column for embedded.com online. He has also written columns for numerous print publications including The C/C++ Users Journal, The C++ Report, Software Development, and Embedded Systems Design. With Thomas Plum, he wrote C++ Programming Guidelines, which won a 1992 Computer Language Magazine Productivity Award. Dan has taught C and C++ to thousands of programmers around the world. He has presented at conferences such as Software Development, Embedded Systems, and C++ World. He has served on the advisory boards of the Embedded Systems and Software Development conferences. Dan served as secretary of the ANSI and ISO C++ Standards committees and as a member of the ANSI C Standards committee. More recently, he contributed to the CERT Secure C Coding Standard and the CERT Secure C++ Coding Standard.)
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:10,440 --> 00:00:19,020
okay

00:00:13,110 --> 00:00:23,040
welcome there's my topic tlit and let's

00:00:19,020 --> 00:00:25,320
just do it the the dilemma with these

00:00:23,040 --> 00:00:28,500
back to basics talks is how basic to get

00:00:25,320 --> 00:00:30,539
and I'm going to try to start at the

00:00:28,500 --> 00:00:32,250
very beginning but I think is the very

00:00:30,539 --> 00:00:35,010
beginning of this topic but go really

00:00:32,250 --> 00:00:37,019
fast just stop me if there's anything

00:00:35,010 --> 00:00:38,489
that you need me to dwell on but

00:00:37,019 --> 00:00:41,629
otherwise I'm going to sail along for

00:00:38,489 --> 00:00:45,629
like 30 slides to get to the real meat

00:00:41,629 --> 00:00:47,489
so what are the uses for Const well one

00:00:45,629 --> 00:00:50,820
of them is to define symbolic constants

00:00:47,489 --> 00:00:52,799
but it turns out now in modern C++ Const

00:00:50,820 --> 00:00:56,100
exper is often a better choice for doing

00:00:52,799 --> 00:00:57,629
that also to define immutable data

00:00:56,100 --> 00:00:59,119
something where you say I want this

00:00:57,629 --> 00:01:02,790
piece of data to never change

00:00:59,119 --> 00:01:06,150
well it turns out context burs also kind

00:01:02,790 --> 00:01:11,400
of bumping Consta side here as well so

00:01:06,150 --> 00:01:14,400
what's left what's left is being able to

00:01:11,400 --> 00:01:17,940
prevent the modification of data that's

00:01:14,400 --> 00:01:21,270
already modifiable and turns out that

00:01:17,940 --> 00:01:24,720
this in my opinion is what construe lis

00:01:21,270 --> 00:01:26,430
is useful for in modern C++ that's what

00:01:24,720 --> 00:01:35,670
we're going to be focusing on it's

00:01:26,430 --> 00:01:37,110
mostly oh stand in the light okay it's

00:01:35,670 --> 00:01:38,870
mostly when you're doing argument

00:01:37,110 --> 00:01:42,060
passing especially when it involves

00:01:38,870 --> 00:01:45,030
pointers and references and that's where

00:01:42,060 --> 00:01:48,000
we're headed with this so just the

00:01:45,030 --> 00:01:50,010
high-level idea is using Const is good

00:01:48,000 --> 00:01:52,230
hygiene what it does is it turns

00:01:50,010 --> 00:01:54,150
potential runtime errors into compile

00:01:52,230 --> 00:01:57,270
time errors and the nice thing about

00:01:54,150 --> 00:02:01,590
that is it's really hard to ignore them

00:01:57,270 --> 00:02:04,110
when they're compile time errors and so

00:02:01,590 --> 00:02:07,740
the consequence is that what you wind up

00:02:04,110 --> 00:02:09,989
is that Const helps you write better

00:02:07,740 --> 00:02:14,129
interfaces things that state more

00:02:09,989 --> 00:02:18,360
clearly what they intend and and protect

00:02:14,129 --> 00:02:20,610
themselves against misuse now in

00:02:18,360 --> 00:02:23,190
contrast context but really doesn't play

00:02:20,610 --> 00:02:25,110
a role in this context burr has to do

00:02:23,190 --> 00:02:26,319
with turning runtime comp mutations into

00:02:25,110 --> 00:02:28,749
compile time

00:02:26,319 --> 00:02:35,170
so we won't be talking all that much

00:02:28,749 --> 00:02:38,379
about context birds mostly constant now

00:02:35,170 --> 00:02:41,799
one of the things I hope to accomplish

00:02:38,379 --> 00:02:46,599
here is to make it that more programmers

00:02:41,799 --> 00:02:49,329
will be using constant proactively I I

00:02:46,599 --> 00:02:51,909
teach a lot of people a lot of

00:02:49,329 --> 00:02:55,629
experienced programmers and the feedback

00:02:51,909 --> 00:02:57,159
that I often get is yeah we know we

00:02:55,629 --> 00:02:58,900
should be using constant but we're a

00:02:57,159 --> 00:03:01,450
little bit skittish about doing it

00:02:58,900 --> 00:03:03,340
because we're not sure that we're doing

00:03:01,450 --> 00:03:05,949
it properly and that we have

00:03:03,340 --> 00:03:11,319
occasionally thrown constant to existing

00:03:05,949 --> 00:03:14,260
code and regretted it and so in fact the

00:03:11,319 --> 00:03:17,169
reality is that retrofitting code that

00:03:14,260 --> 00:03:19,719
doesn't used Const so that it does use

00:03:17,169 --> 00:03:21,340
cons properly is kind of rough and so

00:03:19,719 --> 00:03:23,769
what we want to do is get in habit of

00:03:21,340 --> 00:03:26,919
using it proactively which means do it

00:03:23,769 --> 00:03:29,680
as you're designing and coding and plan

00:03:26,919 --> 00:03:31,780
ahead and and I hope to encourage you

00:03:29,680 --> 00:03:34,599
more of you to do that or to give you

00:03:31,780 --> 00:03:37,479
the tools if you're already doing it to

00:03:34,599 --> 00:03:42,250
help persuade your colleagues to do that

00:03:37,479 --> 00:03:43,870
with you okay so what's the basic part

00:03:42,250 --> 00:03:47,109
is what most of you already know which

00:03:43,870 --> 00:03:49,870
is that when you use Const to define

00:03:47,109 --> 00:03:52,569
objects which are what you're doing

00:03:49,870 --> 00:03:55,030
basically is saying I want these objects

00:03:52,569 --> 00:03:57,819
to be non-modifiable now notice I throw

00:03:55,030 --> 00:03:59,799
in the colloquial sorta because I don't

00:03:57,819 --> 00:04:02,319
want you to get too wedded to this yet

00:03:59,799 --> 00:04:05,799
it's going to take most of the hour to

00:04:02,319 --> 00:04:08,290
get the truth out about what constantly

00:04:05,799 --> 00:04:10,540
means but a good first order

00:04:08,290 --> 00:04:12,579
approximation it is to say that a

00:04:10,540 --> 00:04:15,459
constant is something that you can read

00:04:12,579 --> 00:04:17,919
from but not write too so there you can

00:04:15,459 --> 00:04:19,479
read for number is a constant integer

00:04:17,919 --> 00:04:22,570
you can read from it but you can't write

00:04:19,479 --> 00:04:24,849
to it message is an array of constant

00:04:22,570 --> 00:04:26,560
characters you can read from the

00:04:24,849 --> 00:04:28,120
individual elements but you can't write

00:04:26,560 --> 00:04:31,180
to most of you know that so let's just

00:04:28,120 --> 00:04:34,330
go on here's an interesting property is

00:04:31,180 --> 00:04:37,029
that because constants can't be written

00:04:34,330 --> 00:04:39,700
to your only chance to give it a value

00:04:37,029 --> 00:04:44,350
is at the moment of birth

00:04:39,700 --> 00:04:47,320
when it's created and so C++ imposes a

00:04:44,350 --> 00:04:50,470
semantic requirement which is that you

00:04:47,320 --> 00:04:52,810
must initialize every constant mandated

00:04:50,470 --> 00:04:55,170
initialization so for example here we

00:04:52,810 --> 00:04:57,640
have the Declaration of a Const integer

00:04:55,170 --> 00:05:00,430
called upper bound that's an error

00:04:57,640 --> 00:05:02,380
because it lacks an initializer now in

00:05:00,430 --> 00:05:04,930
contrast you can put extern on a

00:05:02,380 --> 00:05:06,850
declaration like that and that means

00:05:04,930 --> 00:05:09,910
it's not a definition it's just a

00:05:06,850 --> 00:05:12,610
declaration the actual definition of

00:05:09,910 --> 00:05:15,580
limit is somewhere else that's okay to

00:05:12,610 --> 00:05:16,930
leave the initializer off and then

00:05:15,580 --> 00:05:18,850
here's the way you're used to seeing it

00:05:16,930 --> 00:05:22,450
most the time is declaration with an

00:05:18,850 --> 00:05:26,230
initializer now there's this important

00:05:22,450 --> 00:05:29,100
idea that's both in C and in C++ called

00:05:26,230 --> 00:05:32,260
the constant expression

00:05:29,100 --> 00:05:34,360
there are numerous situations where we

00:05:32,260 --> 00:05:37,930
need to be able to provide things like

00:05:34,360 --> 00:05:40,930
array dimensions and notice there that

00:05:37,930 --> 00:05:43,750
that declaration for the integer X the

00:05:40,930 --> 00:05:47,890
first local variable inside foo that's

00:05:43,750 --> 00:05:50,580
an unacceptable declaration because it's

00:05:47,890 --> 00:05:53,350
has a dimension which is non constant

00:05:50,580 --> 00:05:55,270
the 17 for the dimension of Y that's

00:05:53,350 --> 00:05:58,390
perfectly okay and they're at several

00:05:55,270 --> 00:06:01,510
other half a dozen or so contexts in C++

00:05:58,390 --> 00:06:03,880
where the you're allowed to use an

00:06:01,510 --> 00:06:05,650
expression but it has to be a constant

00:06:03,880 --> 00:06:11,970
expression like for example a bit filled

00:06:05,650 --> 00:06:14,680
with constant expressions can involve

00:06:11,970 --> 00:06:17,260
operands and operators it's not just a

00:06:14,680 --> 00:06:19,420
single integer literal or a single

00:06:17,260 --> 00:06:21,160
identifier there can be operations in

00:06:19,420 --> 00:06:27,880
there as long as the whole thing can be

00:06:21,160 --> 00:06:31,090
crunched at compile time so a constant

00:06:27,880 --> 00:06:33,640
object initialized with a constant

00:06:31,090 --> 00:06:37,150
expression is itself a constant

00:06:33,640 --> 00:06:39,490
expression so you can that definition

00:06:37,150 --> 00:06:42,250
for a level it's perfectly legit it says

00:06:39,490 --> 00:06:44,650
level is a constant integer initialized

00:06:42,250 --> 00:06:48,070
with a constant value you can then use

00:06:44,650 --> 00:06:50,350
it to form more complicated constant

00:06:48,070 --> 00:06:52,440
expressions like two times level plus

00:06:50,350 --> 00:06:54,180
one and that's still annex

00:06:52,440 --> 00:06:56,520
that can be evaluated at compile time

00:06:54,180 --> 00:07:00,140
that's a perfectly legitimate array

00:06:56,520 --> 00:07:03,090
dimension but surprisingly Const objects

00:07:00,140 --> 00:07:05,040
don't always result in constant

00:07:03,090 --> 00:07:07,520
expressions and the reason is because

00:07:05,040 --> 00:07:12,930
you can initialize a constant object

00:07:07,520 --> 00:07:15,870
with a non constant initializer and when

00:07:12,930 --> 00:07:20,190
that happens the compiler might defer

00:07:15,870 --> 00:07:22,770
the initialization until runtime so it's

00:07:20,190 --> 00:07:25,710
a value that's not computable at compile

00:07:22,770 --> 00:07:27,750
time and so here's a situation where you

00:07:25,710 --> 00:07:30,030
can use a constant object in an

00:07:27,750 --> 00:07:33,540
expression and find that the compiler

00:07:30,030 --> 00:07:36,360
will complain because level in this

00:07:33,540 --> 00:07:38,790
context is not a constant it's a

00:07:36,360 --> 00:07:41,160
constant object but it's not initialized

00:07:38,790 --> 00:07:52,910
with a constant expression and so it

00:07:41,160 --> 00:07:55,590
itself is not a constant expression okay

00:07:52,910 --> 00:08:00,740
so this is where Const expert comes in

00:07:55,590 --> 00:08:03,030
in that a Const exper object definition

00:08:00,740 --> 00:08:05,850
gives you a guarantee that the

00:08:03,030 --> 00:08:07,860
initializer is itself a constant

00:08:05,850 --> 00:08:09,600
expression there's a mandate that if you

00:08:07,860 --> 00:08:12,630
declare something as a context per

00:08:09,600 --> 00:08:16,740
object the initializing expression is an

00:08:12,630 --> 00:08:20,400
error if it is a non constant

00:08:16,740 --> 00:08:23,790
initializer so the resulting type in

00:08:20,400 --> 00:08:27,000
this case the for example on the last

00:08:23,790 --> 00:08:30,840
line there min is a context per object

00:08:27,000 --> 00:08:32,849
it's cost but the presence of Const

00:08:30,840 --> 00:08:35,219
exper there instead of constant says and

00:08:32,849 --> 00:08:38,789
now give me an error if the initializer

00:08:35,219 --> 00:08:42,000
isn't a constant expression so my

00:08:38,789 --> 00:08:44,339
colleague Steve Dewar's is around here

00:08:42,000 --> 00:08:46,710
somewhere and he introduced me to this

00:08:44,339 --> 00:08:51,330
nice concept which is context for his

00:08:46,710 --> 00:08:54,839
constant and constant and so as a

00:08:51,330 --> 00:08:57,030
general Scott style guide you should

00:08:54,839 --> 00:08:58,890
prefer Const expert a Const for defining

00:08:57,030 --> 00:09:00,870
symbolic constants but having said that

00:08:58,890 --> 00:09:03,720
we're going to largely set context burr

00:09:00,870 --> 00:09:05,550
aside because its role is not in

00:09:03,720 --> 00:09:06,650
parameter passing the way and we're

00:09:05,550 --> 00:09:10,880
going to be talking about it

00:09:06,650 --> 00:09:13,520
shortly now before I go on I want to

00:09:10,880 --> 00:09:17,240
talk a little bit about some of the

00:09:13,520 --> 00:09:19,250
syntactic issues first one is not going

00:09:17,240 --> 00:09:21,460
to say much about volatile here but I do

00:09:19,250 --> 00:09:24,170
want to note that constant volatile are

00:09:21,460 --> 00:09:27,140
close cousins together they're known as

00:09:24,170 --> 00:09:28,850
CV qualifiers because anywhere in the

00:09:27,140 --> 00:09:32,600
syntax that you can throw Const you can

00:09:28,850 --> 00:09:34,670
throw volatile or you can throw both and

00:09:32,600 --> 00:09:37,820
so collectively they're called cv

00:09:34,670 --> 00:09:39,680
qualifiers and although again we're not

00:09:37,820 --> 00:09:41,270
going to talk much about volatile one of

00:09:39,680 --> 00:09:43,730
the interesting side effects of this

00:09:41,270 --> 00:09:45,860
discussion is that once you learn the

00:09:43,730 --> 00:09:48,310
type conversion rules involving Const

00:09:45,860 --> 00:09:52,240
you know them for volatile as well

00:09:48,310 --> 00:09:52,240
they're very close parallel

00:09:52,570 --> 00:10:00,200
interestingly Const exper is not a cv

00:09:55,700 --> 00:10:02,150
qualifier you can't use their context

00:10:00,200 --> 00:10:04,870
per everywhere that you can use Const

00:10:02,150 --> 00:10:09,560
and vice versa

00:10:04,870 --> 00:10:11,000
so for example yeah okay well I'll give

00:10:09,560 --> 00:10:14,990
you some examples in just a moment

00:10:11,000 --> 00:10:18,140
that's where I'm headed now as we just

00:10:14,990 --> 00:10:20,000
saw earlier declaring contexts Const

00:10:18,140 --> 00:10:20,780
objects of an arithmetic type is pretty

00:10:20,000 --> 00:10:23,450
straightforward

00:10:20,780 --> 00:10:25,310
the real interesting and complicated

00:10:23,450 --> 00:10:31,130
stuff happens when you start mixing in

00:10:25,310 --> 00:10:34,190
pointers and references and so I think

00:10:31,130 --> 00:10:36,890
that my experience in teaching this is

00:10:34,190 --> 00:10:39,050
that a lot of people don't quite

00:10:36,890 --> 00:10:41,540
understand the syntax of declarations

00:10:39,050 --> 00:10:44,630
let alone how Const plays a role in

00:10:41,540 --> 00:10:47,060
there and it's interesting most books

00:10:44,630 --> 00:10:48,440
and articles try very hard to avoid

00:10:47,060 --> 00:10:51,500
telling you what the underlying

00:10:48,440 --> 00:10:53,570
syntactic truth is and it turns out it's

00:10:51,500 --> 00:10:54,680
only going to take us a few minutes so

00:10:53,570 --> 00:10:58,340
let's just do it

00:10:54,680 --> 00:11:01,070
and and you'll see it's it's remarkably

00:10:58,340 --> 00:11:05,000
straightforward I don't quite know why

00:11:01,070 --> 00:11:07,670
so many of my colleagues try to avoid

00:11:05,000 --> 00:11:11,270
covering this because it's really pretty

00:11:07,670 --> 00:11:12,650
straightforward so here it is yeah what

00:11:11,270 --> 00:11:15,470
I'm going to do is give you a bunch of

00:11:12,650 --> 00:11:19,370
sort of basic insights into the

00:11:15,470 --> 00:11:20,120
structure of declarations in C++ and you

00:11:19,370 --> 00:11:22,279
know we're going to not going

00:11:20,120 --> 00:11:23,450
I'm not pulling out grammar rules and

00:11:22,279 --> 00:11:25,910
we're not getting to that level of

00:11:23,450 --> 00:11:27,950
detail but this is a pretty accurate

00:11:25,910 --> 00:11:30,320
model of what's the way the compiler

00:11:27,950 --> 00:11:32,420
views things the first thing is that

00:11:30,320 --> 00:11:34,790
every declaration for an object or a

00:11:32,420 --> 00:11:37,070
function has two main parts and I'm

00:11:34,790 --> 00:11:39,020
using color highlighting to make it a

00:11:37,070 --> 00:11:40,670
little easier for you to recognize it

00:11:39,020 --> 00:11:43,339
the first part is called the declaration

00:11:40,670 --> 00:11:46,400
specifiers and the second part is called

00:11:43,339 --> 00:11:48,680
the declarative the clarity is a

00:11:46,400 --> 00:11:51,560
completely made-up word it comes from

00:11:48,680 --> 00:11:54,529
the grammar in the C language and the

00:11:51,560 --> 00:11:57,520
name being declared the thing that's in

00:11:54,529 --> 00:12:01,120
the center of that declaratory Durai D

00:11:57,520 --> 00:12:04,160
that's a little bit of syntactic

00:12:01,120 --> 00:12:06,050
notation I'm going to introduce here now

00:12:04,160 --> 00:12:08,510
the declaration specifies you know what

00:12:06,050 --> 00:12:10,580
these things are there but the important

00:12:08,510 --> 00:12:13,460
thing is they break down into two broad

00:12:10,580 --> 00:12:16,160
categories type specifiers and non type

00:12:13,460 --> 00:12:18,400
specifiers type specifiers and things

00:12:16,160 --> 00:12:21,410
like int unsigned long double or

00:12:18,400 --> 00:12:23,930
user-defined types in this case like

00:12:21,410 --> 00:12:26,560
string or even the instantiation of a

00:12:23,930 --> 00:12:29,270
template like vector int those are all

00:12:26,560 --> 00:12:32,209
things that could be typed specifiers

00:12:29,270 --> 00:12:34,310
the non type specifiers are the other

00:12:32,209 --> 00:12:36,830
keywords that handle things like storage

00:12:34,310 --> 00:12:39,589
classes or function properties like

00:12:36,830 --> 00:12:45,110
virtual keywords like inline typed if

00:12:39,589 --> 00:12:48,800
those are the non type specifiers now so

00:12:45,110 --> 00:12:51,740
the declaratory ID the thing being

00:12:48,800 --> 00:12:53,300
declared possibly surrounded by

00:12:51,740 --> 00:12:55,339
operators and again you know what those

00:12:53,300 --> 00:12:57,950
operators are there stars square

00:12:55,339 --> 00:12:59,900
brackets the ampersand for reference the

00:12:57,950 --> 00:13:02,810
double ampersand for L value reference

00:12:59,900 --> 00:13:06,230
likes me our value reference and so on

00:13:02,810 --> 00:13:09,890
notice that there's a precedence here

00:13:06,230 --> 00:13:13,459
and this is this is one of life's

00:13:09,890 --> 00:13:16,580
mysteries the hell it's surprising how

00:13:13,459 --> 00:13:18,980
few C and C++ programmers know this

00:13:16,580 --> 00:13:20,810
underlying truth about declarations and

00:13:18,980 --> 00:13:26,360
here's what it is it's that when

00:13:20,810 --> 00:13:28,640
presented with a declaratory to an array

00:13:26,360 --> 00:13:31,940
or an array of pointers the answer is

00:13:28,640 --> 00:13:33,779
very simple it's start the square

00:13:31,940 --> 00:13:37,680
bracket has a higher precedence

00:13:33,779 --> 00:13:40,290
star then the unary star and so it

00:13:37,680 --> 00:13:42,540
follows then the winner is it's an array

00:13:40,290 --> 00:13:44,519
of pointers now these are the exact same

00:13:42,540 --> 00:13:46,920
precedence rules that exist in

00:13:44,519 --> 00:13:48,779
expressions and all of you know about

00:13:46,920 --> 00:13:51,420
those right if I were to write an

00:13:48,779 --> 00:13:55,079
arithmetic expression like a plus B

00:13:51,420 --> 00:13:56,910
times C and I would ask which is done

00:13:55,079 --> 00:13:59,910
which has a higher precedence the

00:13:56,910 --> 00:14:03,499
multiplier the ad you'd all say multiply

00:13:59,910 --> 00:14:07,019
right but then when you show people a

00:14:03,499 --> 00:14:10,529
declaratory of pointers or a pointer to

00:14:07,019 --> 00:14:14,970
an array if they answer correctly and

00:14:10,529 --> 00:14:18,029
you say I ask then how did you know that

00:14:14,970 --> 00:14:20,040
I'm just let's do a little how many of

00:14:18,029 --> 00:14:21,899
you already knew that the precedence

00:14:20,040 --> 00:14:25,430
rule is applied here can I just see a

00:14:21,899 --> 00:14:27,899
show of hands yeah I'm seeing about 10

00:14:25,430 --> 00:14:30,509
yeah there's probably 80 people in this

00:14:27,899 --> 00:14:34,559
room and that's very typical it's like

00:14:30,509 --> 00:14:36,990
like duh right the precedence rules are

00:14:34,559 --> 00:14:38,970
a fundamental part of expressions and

00:14:36,990 --> 00:14:40,740
declaratives our expression like things

00:14:38,970 --> 00:14:43,529
that behave according to precedence

00:14:40,740 --> 00:14:49,040
rules so now you are members of a very

00:14:43,529 --> 00:14:49,040
select community in within C and C++

00:14:49,160 --> 00:14:54,540
now parentheses of course give us a

00:14:52,980 --> 00:14:57,559
little bit of a problem because they

00:14:54,540 --> 00:15:00,720
play two roles both in expressions and

00:14:57,559 --> 00:15:02,189
in the class actually three roles and

00:15:00,720 --> 00:15:03,839
expressions because you had the function

00:15:02,189 --> 00:15:06,509
call operator you have grouping and you

00:15:03,839 --> 00:15:10,860
also have casting a form of casting that

00:15:06,509 --> 00:15:13,529
we never use anymore right as a function

00:15:10,860 --> 00:15:17,009
call operator the parentheses will

00:15:13,529 --> 00:15:18,629
follow the declaratory D and they have

00:15:17,009 --> 00:15:21,600
the same precedence as a square bracket

00:15:18,629 --> 00:15:24,569
but as grouping the grouping will

00:15:21,600 --> 00:15:26,040
enclose the declare être and that has

00:15:24,569 --> 00:15:28,350
the highest precedence of all for

00:15:26,040 --> 00:15:30,209
example this is a declarative that says

00:15:28,350 --> 00:15:33,120
f is a function that takes an int and

00:15:30,209 --> 00:15:35,879
returns a pointer if you want it to be a

00:15:33,120 --> 00:15:40,230
pointer to a function you put parens

00:15:35,879 --> 00:15:42,689
around the F and the star so again I'm

00:15:40,230 --> 00:15:46,620
using color to show you the part in gold

00:15:42,689 --> 00:15:47,649
there is that's the grouping parens and

00:15:46,620 --> 00:15:49,089
you can tell the

00:15:47,649 --> 00:15:51,939
our grouping parens because the

00:15:49,089 --> 00:15:56,170
declaratory is on the inside you can

00:15:51,939 --> 00:15:58,619
tell that the red parens there are the

00:15:56,170 --> 00:16:03,329
function parens because they're after

00:15:58,619 --> 00:16:05,790
the declarative writing it's very simple

00:16:03,329 --> 00:16:09,999
okay

00:16:05,790 --> 00:16:19,959
bear with me I'm almost a Const okay it

00:16:09,999 --> 00:16:23,709
is related okay so the type specifiers

00:16:19,959 --> 00:16:26,800
in the declaration specifiers and modify

00:16:23,709 --> 00:16:29,079
other type specifiers but the non tete

00:16:26,800 --> 00:16:31,269
type specifiers it turns out go directly

00:16:29,079 --> 00:16:34,029
to the declaratory D so again the big

00:16:31,269 --> 00:16:36,009
thing for you to understand is what's

00:16:34,029 --> 00:16:38,980
the difference between a type specifier

00:16:36,009 --> 00:16:40,869
and a non type specifier because for

00:16:38,980 --> 00:16:45,369
example there the unsigned and the long

00:16:40,869 --> 00:16:49,300
are modifying it but static is directly

00:16:45,369 --> 00:16:51,069
modifying X the entity and that

00:16:49,300 --> 00:16:55,749
declaration has the property of being

00:16:51,069 --> 00:16:59,559
static is X so you read this as X is a

00:16:55,749 --> 00:17:03,339
static array of pointers to unsigned

00:16:59,559 --> 00:17:06,279
long integers it's a very inside-out

00:17:03,339 --> 00:17:09,850
kind of process but it's what it is it's

00:17:06,279 --> 00:17:12,059
not that bad and this is as bad as it

00:17:09,850 --> 00:17:12,059
gets

00:17:12,839 --> 00:17:18,100
now this this is one you might want not

00:17:16,059 --> 00:17:19,809
you might not want to know but it is

00:17:18,100 --> 00:17:21,520
what it is the order of the declaration

00:17:19,809 --> 00:17:25,500
specifiers doesn't matter to the

00:17:21,520 --> 00:17:30,340
compiler so those are the same thing

00:17:25,500 --> 00:17:31,809
so are those okay you can think of it as

00:17:30,340 --> 00:17:33,460
the compiler comes in there it just

00:17:31,809 --> 00:17:35,350
scoops up all the declarations

00:17:33,460 --> 00:17:38,860
specifiers and dump some on the table

00:17:35,350 --> 00:17:41,320
and sorts them out like Lego bricks it's

00:17:38,860 --> 00:17:44,590
that it doesn't care what order you

00:17:41,320 --> 00:17:47,919
write them in and of course this opens

00:17:44,590 --> 00:17:53,470
the four very heated discussions right

00:17:47,919 --> 00:17:58,870
okay this one is interesting Const turns

00:17:53,470 --> 00:18:00,160
out is a type specifier like long or

00:17:58,870 --> 00:18:02,919
unsigned

00:18:00,160 --> 00:18:05,950
it's not it's not like static or extern

00:18:02,919 --> 00:18:08,350
it's it's like long or unsigned and this

00:18:05,950 --> 00:18:11,350
one never occurred to me until many

00:18:08,350 --> 00:18:14,410
years ago I wrote an article for a now

00:18:11,350 --> 00:18:17,350
out of print publication explaining this

00:18:14,410 --> 00:18:20,470
stuff to the readers of that publication

00:18:17,350 --> 00:18:22,299
and I got back a letter from somebody

00:18:20,470 --> 00:18:25,900
who had written the stuff in the right

00:18:22,299 --> 00:18:29,230
hand column expecting Const to behave

00:18:25,900 --> 00:18:31,840
like static and so I thought it was

00:18:29,230 --> 00:18:32,980
worth a moment to point this out it

00:18:31,840 --> 00:18:35,860
never occurred to me that it was

00:18:32,980 --> 00:18:40,090
anything but that Const modifier the int

00:18:35,860 --> 00:18:44,679
but it's worth mentioning it's a type

00:18:40,090 --> 00:18:46,270
specifier and here's the other twist as

00:18:44,679 --> 00:18:48,700
the constant volatile are the only

00:18:46,270 --> 00:18:51,880
symbols in C++ that it can appear either

00:18:48,700 --> 00:18:54,299
as declaration specifiers or in the

00:18:51,880 --> 00:18:58,419
declarative

00:18:54,299 --> 00:19:00,580
so here whether you say in cons constant

00:18:58,419 --> 00:19:03,460
the important thing as marked by the

00:19:00,580 --> 00:19:05,620
bold vertical line is to know where the

00:19:03,460 --> 00:19:08,470
declaration specifiers and and the

00:19:05,620 --> 00:19:11,110
declaratory Ginn's when you're on the

00:19:08,470 --> 00:19:12,400
left hand side of that line the order

00:19:11,110 --> 00:19:15,250
doesn't matter when you're on the right

00:19:12,400 --> 00:19:17,620
hand side the compiler is pretty

00:19:15,250 --> 00:19:19,690
inflexible about what it will accept

00:19:17,620 --> 00:19:24,880
there's a little bit of wiggle room but

00:19:19,690 --> 00:19:30,520
not much here now the Const is in the

00:19:24,880 --> 00:19:37,210
declarative fiying the int it's actually

00:19:30,520 --> 00:19:40,360
modifying the star the pointer so when

00:19:37,210 --> 00:19:42,280
the constipated the immediate right of a

00:19:40,360 --> 00:19:45,100
pointer operator it's actually modifying

00:19:42,280 --> 00:19:48,429
that pointer it makes the what was a

00:19:45,100 --> 00:19:51,490
point R into a Const pointer and so here

00:19:48,429 --> 00:19:55,330
just a few examples this is a pointer to

00:19:51,490 --> 00:19:57,700
a constant pointer or a constant pointer

00:19:55,330 --> 00:19:59,679
to pointer it's actually a constant

00:19:57,700 --> 00:20:04,840
pointer to a let's be explicit non

00:19:59,679 --> 00:20:07,600
constant pointer now the star in the

00:20:04,840 --> 00:20:12,159
concept oaken's how you space things

00:20:07,600 --> 00:20:13,490
that style all of those four different

00:20:12,159 --> 00:20:16,429
variations are except

00:20:13,490 --> 00:20:18,080
the holder the compiler I happen to have

00:20:16,429 --> 00:20:22,130
a preference and it's motivated by this

00:20:18,080 --> 00:20:24,800
is that because the Const is modifying

00:20:22,130 --> 00:20:28,340
the star to its immediate left and in

00:20:24,800 --> 00:20:30,800
fact grammatically there is it's known

00:20:28,340 --> 00:20:33,290
as the Const point or operator and and

00:20:30,800 --> 00:20:38,870
the star Const has the same precedence

00:20:33,290 --> 00:20:40,700
as the star by itself so you remove the

00:20:38,870 --> 00:20:50,200
space between the Const and the star

00:20:40,700 --> 00:20:53,090
just to reinforce that notion so here is

00:20:50,200 --> 00:20:55,900
my simple advice on being able to see I

00:20:53,090 --> 00:20:58,400
haven't yet really told you what

00:20:55,900 --> 00:21:01,250
consummate you have a rough idea of what

00:20:58,400 --> 00:21:03,200
constantine's if you want to be able to

00:21:01,250 --> 00:21:05,059
write a declaration where constants in

00:21:03,200 --> 00:21:07,520
the right place here's a little bit of

00:21:05,059 --> 00:21:09,730
advice first write the declaration as it

00:21:07,520 --> 00:21:12,920
would be without Khan store volatile and

00:21:09,730 --> 00:21:14,120
then simply place Const or volatile to

00:21:12,920 --> 00:21:16,400
the immediate right of the type

00:21:14,120 --> 00:21:20,480
specifier or operator that you want to

00:21:16,400 --> 00:21:23,809
modify here's an example suppose what I

00:21:20,480 --> 00:21:27,890
want is an array of n Const painters two

00:21:23,809 --> 00:21:30,320
volatile UN 32 s when you start out by

00:21:27,890 --> 00:21:34,460
doing is get rid of the constant the

00:21:30,320 --> 00:21:39,320
volatile just write an array of pointers

00:21:34,460 --> 00:21:43,610
to you int 32 s that's it start there

00:21:39,320 --> 00:21:45,440
okay now make a little space so that

00:21:43,610 --> 00:21:47,570
there's room for the constant volatile

00:21:45,440 --> 00:21:50,420
and what if since I want the pointer to

00:21:47,570 --> 00:21:50,960
be Const I put the cons to the immediate

00:21:50,420 --> 00:21:53,600
right

00:21:50,960 --> 00:21:55,340
I want the UN 32 to be volatile I put

00:21:53,600 --> 00:21:57,470
the volatile to the immediate right and

00:21:55,340 --> 00:22:02,710
as the Brits like the st. Bob's your

00:21:57,470 --> 00:22:02,710
uncle you got it right

00:22:04,600 --> 00:22:11,559
okay what about context / let's just

00:22:07,970 --> 00:22:15,309
spend a moment on this because this is

00:22:11,559 --> 00:22:15,309
it is what it is

00:22:18,039 --> 00:22:24,620
now you know that to the left of that

00:22:21,110 --> 00:22:28,399
separator the order doesn't matter const

00:22:24,620 --> 00:22:30,320
char char kant's the same thing it's

00:22:28,399 --> 00:22:32,510
true with context burg because const

00:22:30,320 --> 00:22:35,090
exper is a declaration specifier so

00:22:32,510 --> 00:22:41,890
context for char char context for the

00:22:35,090 --> 00:22:41,890
same thing but these are not equivalent

00:22:42,039 --> 00:22:48,070
and the reason there here's what the

00:22:45,470 --> 00:22:54,320
equivalence is drum roll please

00:22:48,070 --> 00:22:54,770
that's it okay now Wyatt what's going on

00:22:54,320 --> 00:22:57,919
here

00:22:54,770 --> 00:23:00,140
well const expert is not a type

00:22:57,919 --> 00:23:01,850
specifier it's a declaration specifier

00:23:00,140 --> 00:23:04,730
but it's not it but it's an on type

00:23:01,850 --> 00:23:10,190
specifier some semantically which means

00:23:04,730 --> 00:23:13,659
that it behaves more like static the cot

00:23:10,190 --> 00:23:16,039
the thing that is context per here is X

00:23:13,659 --> 00:23:17,720
so that means that from a type

00:23:16,039 --> 00:23:19,279
standpoint not regarding the

00:23:17,720 --> 00:23:22,309
initialization but just from the

00:23:19,279 --> 00:23:24,940
standpoint of the types that context per

00:23:22,309 --> 00:23:29,059
death declaration is equivalent to this

00:23:24,940 --> 00:23:31,789
it's making X a constant pointer to an

00:23:29,059 --> 00:23:35,500
unsigned long int it X is an array of

00:23:31,789 --> 00:23:43,789
constant pointers to unsigned long it

00:23:35,500 --> 00:23:46,520
okay now just another basic but

00:23:43,789 --> 00:23:49,490
noteworthy point the address of operator

00:23:46,520 --> 00:23:52,880
preserves constant Asst if you have that

00:23:49,490 --> 00:23:55,580
I is a non constant integer its address

00:23:52,880 --> 00:23:58,730
yields a pointer to non constant int if

00:23:55,580 --> 00:24:00,520
you have CI as a constant int taking its

00:23:58,730 --> 00:24:03,409
address yields a pointer to constant

00:24:00,520 --> 00:24:06,830
this also happens with the implicit

00:24:03,409 --> 00:24:09,860
conversions regarding arrays there is

00:24:06,830 --> 00:24:12,710
this conversion known as the array two

00:24:09,860 --> 00:24:14,960
pointer conversion in many contexts not

00:24:12,710 --> 00:24:18,350
every context but in many contexts where

00:24:14,960 --> 00:24:20,360
you use an array the compiler will

00:24:18,350 --> 00:24:24,440
implicitly convert it into a pointer to

00:24:20,360 --> 00:24:28,370
its zeroth element and use that for the

00:24:24,440 --> 00:24:30,320
rest of the expression evaluation same

00:24:28,370 --> 00:24:31,789
thing happens with string literals that

00:24:30,320 --> 00:24:34,580
double quoted X

00:24:31,789 --> 00:24:37,220
why zzy really has type array of

00:24:34,580 --> 00:24:40,789
constant character if you use it in an

00:24:37,220 --> 00:24:45,979
expression it is quietly converted it's

00:24:40,789 --> 00:24:48,519
a pointer to Const character so the

00:24:45,979 --> 00:24:51,649
these conversions preserve constants

00:24:48,519 --> 00:24:55,070
okay with that background now let's look

00:24:51,649 --> 00:24:57,799
at some various uses for Const in

00:24:55,070 --> 00:24:59,899
pointer declarations and talk a little

00:24:57,799 --> 00:25:03,440
bit more about what they mean so now you

00:24:59,899 --> 00:25:06,289
know those two are equivalent that P is

00:25:03,440 --> 00:25:08,539
a pointer to a constant tea or a tea

00:25:06,289 --> 00:25:12,080
that's Const however you want to say it

00:25:08,539 --> 00:25:16,309
in English and what does that mean

00:25:12,080 --> 00:25:20,029
operationally what it means is that you

00:25:16,309 --> 00:25:22,429
can modify P you can store new values

00:25:20,029 --> 00:25:27,320
into P but when you use the expression

00:25:22,429 --> 00:25:30,739
star P you can't write to it you can

00:25:27,320 --> 00:25:33,200
read from it you can't write to you

00:25:30,739 --> 00:25:38,539
contrast that with this one P is a

00:25:33,200 --> 00:25:41,239
constant pointer to a tea so that means

00:25:38,539 --> 00:25:44,450
that P itself is a constant pointer to a

00:25:41,239 --> 00:25:48,019
non constant T but star P is non

00:25:44,450 --> 00:25:51,440
constant so you try to assign to P

00:25:48,019 --> 00:25:56,269
itself that's an error but you can

00:25:51,440 --> 00:25:59,570
assign to star P and then finally we

00:25:56,269 --> 00:26:03,679
have this one you can have that P is a

00:25:59,570 --> 00:26:06,529
constant pointer to a constant T and it

00:26:03,679 --> 00:26:10,909
means that by itself P is a constant

00:26:06,529 --> 00:26:13,909
pointer and star P is a constant T which

00:26:10,909 --> 00:26:18,470
means attempting to assign to either P

00:26:13,909 --> 00:26:25,639
or star P will be rejected by the

00:26:18,470 --> 00:26:27,739
compiler so now let's look at some

00:26:25,639 --> 00:26:29,479
conversion rules and this is really the

00:26:27,739 --> 00:26:32,899
heart of our discussion all of that

00:26:29,479 --> 00:26:36,799
syntactic stuff was leading up to this

00:26:32,899 --> 00:26:41,299
which is the real substance so here what

00:26:36,799 --> 00:26:44,960
we have is a pointer P it's a pointer to

00:26:41,299 --> 00:26:45,570
non constand a pointer P C which is a

00:26:44,960 --> 00:26:49,560
pointer to

00:26:45,570 --> 00:26:53,220
constand we have two functions WP which

00:26:49,560 --> 00:26:57,500
is short for once pointer and WP c which

00:26:53,220 --> 00:26:59,970
wants a pointer to Const now clearly

00:26:57,500 --> 00:27:01,530
these are going to be okay

00:26:59,970 --> 00:27:02,700
because if you have a function that

00:27:01,530 --> 00:27:05,160
wants a pointer and you give it a

00:27:02,700 --> 00:27:07,290
pointer with no constants in the

00:27:05,160 --> 00:27:09,090
equation that's going to work and if you

00:27:07,290 --> 00:27:10,530
have a function that wants a pointer to

00:27:09,090 --> 00:27:14,600
constant you give it a pointer to

00:27:10,530 --> 00:27:14,600
constant everybody's happy

00:27:15,350 --> 00:27:22,170
here those declarations are again this

00:27:18,750 --> 00:27:25,590
is the challenging question if can I

00:27:22,170 --> 00:27:29,730
call once pointer and pass it a pointer

00:27:25,590 --> 00:27:31,770
to cost that involves a conversion of

00:27:29,730 --> 00:27:36,630
converting a pointer to constant to a

00:27:31,770 --> 00:27:38,340
pointer to implicitly non constant how

00:27:36,630 --> 00:27:41,760
about this one I have something that

00:27:38,340 --> 00:27:45,270
once appointed a Const and I give it a

00:27:41,760 --> 00:27:46,920
pointer can I do that and the answer is

00:27:45,270 --> 00:27:49,800
one of them will compile and the other

00:27:46,920 --> 00:27:52,080
one will not but this is just a special

00:27:49,800 --> 00:27:54,060
case of a broad category of problems

00:27:52,080 --> 00:27:56,360
which brings us to the putt you know

00:27:54,060 --> 00:27:59,640
that the title of our talk which is

00:27:56,360 --> 00:28:02,880
don't memorize this B I want you to be

00:27:59,640 --> 00:28:04,710
able to reason it out because it rears

00:28:02,880 --> 00:28:07,350
itself and a whole bunch of different

00:28:04,710 --> 00:28:09,720
scenarios not just involving pointers

00:28:07,350 --> 00:28:11,670
but involving references and member

00:28:09,720 --> 00:28:15,930
function calls and things like that and

00:28:11,670 --> 00:28:17,340
so it's think of const as a promise in

00:28:15,930 --> 00:28:20,730
other words you can apply ethical

00:28:17,340 --> 00:28:23,280
reasoning to the semantics of cost which

00:28:20,730 --> 00:28:27,050
i'm sorry if you're a sociopath you're

00:28:23,280 --> 00:28:31,320
out of luck but assuming that you're not

00:28:27,050 --> 00:28:33,440
this should work and so let's apply the

00:28:31,320 --> 00:28:38,700
ethical reasoning to an imaginary

00:28:33,440 --> 00:28:42,390
conversation between hey the keeper of

00:28:38,700 --> 00:28:45,180
some thing called X and B who is about

00:28:42,390 --> 00:28:47,460
to borrow or is aspiring to borrow that

00:28:45,180 --> 00:28:50,220
X and here's the conversation it's

00:28:47,460 --> 00:28:52,200
basically K says if I give you access to

00:28:50,220 --> 00:28:56,400
X can I trust that you won't change it

00:28:52,200 --> 00:28:59,640
and B says yeah I promise I won't change

00:28:56,400 --> 00:29:01,950
it and K says you understand

00:28:59,640 --> 00:29:04,530
and that I might still be able to change

00:29:01,950 --> 00:29:09,000
X and give others permission in other

00:29:04,530 --> 00:29:12,809
words X isn't necessarily immutable I'm

00:29:09,000 --> 00:29:17,520
just saying I want B to promise you are

00:29:12,809 --> 00:29:19,440
not going to be the agent of change B

00:29:17,520 --> 00:29:21,480
says yet my promise not the change X

00:29:19,440 --> 00:29:24,059
doesn't necessarily mean no one else can

00:29:21,480 --> 00:29:26,190
change X I understand that and then

00:29:24,059 --> 00:29:28,830
finally and this is also very important

00:29:26,190 --> 00:29:30,900
you also understand you can't weasel out

00:29:28,830 --> 00:29:35,460
by asking others to break the promise

00:29:30,900 --> 00:29:39,540
for you yes I promise I won't other ask

00:29:35,460 --> 00:29:42,240
others to break my promise right because

00:29:39,540 --> 00:29:44,220
that's the ethics part is you say hey

00:29:42,240 --> 00:29:46,140
would you like I promised I wouldn't do

00:29:44,220 --> 00:29:49,740
this damage would you do the damage for

00:29:46,140 --> 00:29:54,270
me and then I can stand with a straight

00:29:49,740 --> 00:29:57,120
face and deny that I did it most of us

00:29:54,270 --> 00:30:00,120
would think that that's unethical and

00:29:57,120 --> 00:30:03,840
that's basically the way const is

00:30:00,120 --> 00:30:06,330
handled in a c++ compiler so let's apply

00:30:03,840 --> 00:30:08,970
it to this specific declaration we have

00:30:06,330 --> 00:30:11,790
QC as a pointer to a constant e what is

00:30:08,970 --> 00:30:16,320
the real nature of the promise here the

00:30:11,790 --> 00:30:21,380
real nature is that the program says I

00:30:16,320 --> 00:30:25,020
won't use any value obtained from QC

00:30:21,380 --> 00:30:28,049
directly or indirectly to alter any t

00:30:25,020 --> 00:30:31,260
objects in other words once use the

00:30:28,049 --> 00:30:33,299
promises made the last part of the

00:30:31,260 --> 00:30:36,240
conversation says and you can't hand it

00:30:33,299 --> 00:30:43,730
off to anybody else unless they make the

00:30:36,240 --> 00:30:47,010
same promise so we can think of this oh

00:30:43,730 --> 00:30:48,960
and by the way this promise doesn't

00:30:47,010 --> 00:30:51,179
apply to other pointers which if they

00:30:48,960 --> 00:30:54,390
coincidentally have the same value in

00:30:51,179 --> 00:30:56,370
amis QC they're not not subject to the

00:30:54,390 --> 00:31:00,570
promise unless they made it explicitly

00:30:56,370 --> 00:31:02,490
themselves so that's the sense in which

00:31:00,570 --> 00:31:05,429
you can have an expression that

00:31:02,490 --> 00:31:07,230
designates a constant object actually

00:31:05,429 --> 00:31:12,320
referring to something which is really

00:31:07,230 --> 00:31:12,320
not constant really not immutable

00:31:13,220 --> 00:31:17,790
so let's apply this reasoning to the

00:31:15,390 --> 00:31:20,550
function calls so once again we have

00:31:17,790 --> 00:31:24,240
this pointer PC which is a pointer to a

00:31:20,550 --> 00:31:30,960
constant T and that in a sense PC is the

00:31:24,240 --> 00:31:34,620
current keeper of the access and now WP

00:31:30,960 --> 00:31:37,770
wants to borrow access through its

00:31:34,620 --> 00:31:41,130
parameter Q but notice that Q makes no

00:31:37,770 --> 00:31:44,460
promise that's a declaration that says

00:31:41,130 --> 00:31:48,150
don't trust me and so the compiler says

00:31:44,460 --> 00:31:52,770
ok I won't and it rejects that call as

00:31:48,150 --> 00:31:55,230
an invalid pointer conversion that's

00:31:52,770 --> 00:31:58,650
what you'll get and the problem is that

00:31:55,230 --> 00:32:00,960
it's losing consciousness so the

00:31:58,650 --> 00:32:03,600
compiler rejects it you know and the

00:32:00,960 --> 00:32:05,220
problem is that if it were to compile it

00:32:03,600 --> 00:32:08,430
would open up the door to violate the

00:32:05,220 --> 00:32:12,150
promise C it doesn't necessarily mean

00:32:08,430 --> 00:32:14,420
that WP will inside its body alter the

00:32:12,150 --> 00:32:18,330
thing it's pointing to but it is saying

00:32:14,420 --> 00:32:23,010
I'm not willing to swear to make that

00:32:18,330 --> 00:32:24,720
promise and therefore don't trust me now

00:32:23,010 --> 00:32:27,810
in contrast when you call the function

00:32:24,720 --> 00:32:29,730
that once a pointer to Const and you

00:32:27,810 --> 00:32:33,060
pass it something that isn't constant

00:32:29,730 --> 00:32:37,290
that's ok because what that's actually

00:32:33,060 --> 00:32:38,520
doing is adding a promise it's not

00:32:37,290 --> 00:32:41,040
taking one away and there's nothing

00:32:38,520 --> 00:32:43,290
wrong with somebody who says I've got

00:32:41,040 --> 00:32:45,570
this thing that's modifiable can I give

00:32:43,290 --> 00:32:49,170
it to you with the understanding that

00:32:45,570 --> 00:32:50,670
it'll come back intact I'm not giving up

00:32:49,170 --> 00:32:52,410
the right to change it or to give it to

00:32:50,670 --> 00:32:53,520
other people who want to change it but

00:32:52,410 --> 00:32:57,240
I'm asking you

00:32:53,520 --> 00:33:01,700
well I'll lend it to you to not change

00:32:57,240 --> 00:33:01,700
it that promise is perfectly legit

00:33:02,120 --> 00:33:06,210
there's a name for this kind of pointer

00:33:04,740 --> 00:33:10,200
conversion it's called a qualification

00:33:06,210 --> 00:33:13,380
conversion and basically it adds CV

00:33:10,200 --> 00:33:17,780
qualifiers to they converted the type of

00:33:13,380 --> 00:33:21,780
the that the pointer is pointing to and

00:33:17,780 --> 00:33:23,910
so a more precise statement of what a

00:33:21,780 --> 00:33:27,059
qualification conversion involves is

00:33:23,910 --> 00:33:30,809
you've got a pointer to see the CV

00:33:27,059 --> 00:33:34,950
represents some combination of constand

00:33:30,809 --> 00:33:38,129
or volatile and cb2 also represents some

00:33:34,950 --> 00:33:42,029
combination of const or volatile or both

00:33:38,129 --> 00:33:45,240
or nothing and we have this concept of a

00:33:42,029 --> 00:33:50,700
pointer being more cv qualified than

00:33:45,240 --> 00:33:53,190
another pointer if more cv qualified

00:33:50,700 --> 00:33:56,100
means that it has everything that was in

00:33:53,190 --> 00:33:58,649
the first one plus it might have suborn

00:33:56,100 --> 00:34:03,149
so you can always add another qualifier

00:33:58,649 --> 00:34:05,549
you just can't take one away and so this

00:34:03,149 --> 00:34:07,289
same set of pointer conversions can be

00:34:05,549 --> 00:34:10,589
illustrated with assignments as well as

00:34:07,289 --> 00:34:13,500
parameter passing so here we have P as a

00:34:10,589 --> 00:34:16,200
pointer to a non-constant T and PC as a

00:34:13,500 --> 00:34:19,649
pointer to cons you can take a pointer

00:34:16,200 --> 00:34:20,940
to non Const and convert it into pointer

00:34:19,649 --> 00:34:24,179
to cons because that's adding a

00:34:20,940 --> 00:34:26,069
qualifier on the pointed to object but

00:34:24,179 --> 00:34:28,859
you can't go the other way that's losing

00:34:26,069 --> 00:34:31,260
a qualifier and by the way the exact

00:34:28,859 --> 00:34:34,349
same rule applies for pointer to

00:34:31,260 --> 00:34:36,030
volatile you can increase the volatility

00:34:34,349 --> 00:34:39,300
of the pointed to object but you can't

00:34:36,030 --> 00:34:41,760
strip it away and now here what we have

00:34:39,300 --> 00:34:43,589
is converting pointer to constant

00:34:41,760 --> 00:34:47,000
appointed a volatile well that adds a

00:34:43,589 --> 00:34:49,500
volatile but it loses a constant no good

00:34:47,000 --> 00:34:52,470
same thing pointed a volatile into

00:34:49,500 --> 00:34:55,909
pointer to constant you're picking up of

00:34:52,470 --> 00:34:55,909
Const but you're losing a volatile

00:34:57,140 --> 00:35:01,770
not surprisingly these things work with

00:35:00,660 --> 00:35:04,020
references as well although

00:35:01,770 --> 00:35:06,930
interestingly the standard does not

00:35:04,020 --> 00:35:09,390
refer to reference initialization as

00:35:06,930 --> 00:35:11,730
having qualification conversions they

00:35:09,390 --> 00:35:13,980
just describe a set of reference binding

00:35:11,730 --> 00:35:16,560
rules which by some coincidence happen

00:35:13,980 --> 00:35:21,900
to be parallel to the pointer conversion

00:35:16,560 --> 00:35:24,810
rules so here we have a function wi that

00:35:21,900 --> 00:35:29,339
wants an int and another one WC i that

00:35:24,810 --> 00:35:32,339
wants a constant int once again clearly

00:35:29,339 --> 00:35:35,849
you can bind a reference to an into an

00:35:32,339 --> 00:35:39,650
int and a reference to a constant int to

00:35:35,849 --> 00:35:43,880
a constant it that's no change in type

00:35:39,650 --> 00:35:46,190
but the reference initialization can

00:35:43,880 --> 00:35:48,680
increase the constants of the referenced

00:35:46,190 --> 00:35:51,230
object so for example this one is

00:35:48,680 --> 00:35:55,309
perfectly okay I have a function that

00:35:51,230 --> 00:35:57,549
once a reference to a constant int and I

00:35:55,309 --> 00:36:01,220
say will you take a reference to an int

00:35:57,549 --> 00:36:04,130
yeah fine I'll take it and I'll treat it

00:36:01,220 --> 00:36:08,599
as if it's constant no promise broken

00:36:04,130 --> 00:36:11,660
there but if I try to take the constant

00:36:08,599 --> 00:36:14,059
integer and bind a reference that's not

00:36:11,660 --> 00:36:18,470
a reference to a non constant integer

00:36:14,059 --> 00:36:28,430
that's trying to strip it away the

00:36:18,470 --> 00:36:30,619
compiler will not be happy with that the

00:36:28,430 --> 00:36:32,390
standard yes if you have a question

00:36:30,619 --> 00:36:34,460
please go over to the Maya hate to make

00:36:32,390 --> 00:36:37,700
you step over other people but it's big

00:36:34,460 --> 00:36:38,059
room and we want to hear the question go

00:36:37,700 --> 00:36:39,470
ahead

00:36:38,059 --> 00:36:43,819
can you go back to the previous slide

00:36:39,470 --> 00:36:45,559
please yes where you say W CI CI you

00:36:43,819 --> 00:36:47,960
can't find a reference to into oh that

00:36:45,559 --> 00:36:50,900
is a typo yeah that was yes okay thank

00:36:47,960 --> 00:36:54,859
you very much yes that should have been

00:36:50,900 --> 00:36:57,349
I and and the miracle of PowerPoint is

00:36:54,859 --> 00:37:00,220
it can fix it right now so you can see

00:36:57,349 --> 00:37:00,220
the correct one

00:37:07,010 --> 00:37:16,490
thank you very much iterators the

00:37:13,400 --> 00:37:19,369
standard library has a bunch of these

00:37:16,490 --> 00:37:23,570
container class templates and they have

00:37:19,369 --> 00:37:25,520
members in them called iterator now in

00:37:23,570 --> 00:37:28,190
the broad scope of things you know

00:37:25,520 --> 00:37:32,090
iterator in the standard library is a

00:37:28,190 --> 00:37:33,890
generalization of a pointer when you

00:37:32,090 --> 00:37:36,050
write algorithms we try to write

00:37:33,890 --> 00:37:38,780
algorithms which will accept iterators

00:37:36,050 --> 00:37:41,420
that work equally well whether or not

00:37:38,780 --> 00:37:44,480
that iterator happens to be a genuine

00:37:41,420 --> 00:37:46,970
pointer or it's an object of a class

00:37:44,480 --> 00:37:50,230
type which is made to look like a

00:37:46,970 --> 00:37:53,840
pointer through operator overloading

00:37:50,230 --> 00:37:57,109
either way that's an iterator well but

00:37:53,840 --> 00:38:00,040
the standard container classes the class

00:37:57,109 --> 00:38:02,540
templates like vector deck lists so on

00:38:00,040 --> 00:38:06,580
they all have member types called

00:38:02,540 --> 00:38:15,200
iterator and Const iterator and that

00:38:06,580 --> 00:38:17,900
those type members reprimand to

00:38:15,200 --> 00:38:19,660
essentially point to individual elements

00:38:17,900 --> 00:38:23,170
in that list

00:38:19,660 --> 00:38:26,060
what's a Const iterator well it's a

00:38:23,170 --> 00:38:28,100
thing you think of it as a pointer to an

00:38:26,060 --> 00:38:30,710
element and what's the constituent there

00:38:28,100 --> 00:38:33,530
it's actually a pointer to a constant

00:38:30,710 --> 00:38:36,200
element it's not that the iterator

00:38:33,530 --> 00:38:40,090
itself is immutable that you can't

00:38:36,200 --> 00:38:44,150
change it it's that it's pointing to so

00:38:40,090 --> 00:38:46,280
it's really I would have preferred that

00:38:44,150 --> 00:38:48,560
the actual name would have been iterator

00:38:46,280 --> 00:38:49,730
to Const but that's not the name you

00:38:48,560 --> 00:38:52,369
just have to live with the fact that

00:38:49,730 --> 00:38:57,050
Const iterator mean is conceptually

00:38:52,369 --> 00:39:00,109
equivalent a pointer to Const well not

00:38:57,050 --> 00:39:03,560
surprisingly there are since these

00:39:00,109 --> 00:39:07,720
things are mimicking pointers you can do

00:39:03,560 --> 00:39:11,210
conversions between iterators and

00:39:07,720 --> 00:39:14,119
concentrators that mimic the pointer

00:39:11,210 --> 00:39:16,400
conversions that we just talked about so

00:39:14,119 --> 00:39:19,460
here we have an example of a deck and

00:39:16,400 --> 00:39:20,490
I've declared a deck of int iterator I

00:39:19,460 --> 00:39:25,560
and

00:39:20,490 --> 00:39:29,550
and concentrator CI can you convert CI

00:39:25,560 --> 00:39:32,490
and I know because that drops a Const

00:39:29,550 --> 00:39:40,200
from the pointed to type but you can

00:39:32,490 --> 00:39:43,770
convert I into CI that is the iterator

00:39:40,200 --> 00:39:50,880
types analog of a qualification

00:39:43,770 --> 00:39:55,470
conversion now let's use these things in

00:39:50,880 --> 00:39:57,500
parameter declarations because one of

00:39:55,470 --> 00:39:59,550
the big questions that I think

00:39:57,500 --> 00:40:01,260
programmers are constantly asking is

00:39:59,550 --> 00:40:05,040
well where's the right place to put the

00:40:01,260 --> 00:40:07,670
constant and I'll tell you up front some

00:40:05,040 --> 00:40:11,010
ways are more useful than others

00:40:07,670 --> 00:40:13,230
so here's the scenario suppose that you

00:40:11,010 --> 00:40:16,200
have a function foo which has a

00:40:13,230 --> 00:40:20,610
parameter of type pointer to T return

00:40:16,200 --> 00:40:22,619
some value R and a typical call on foo

00:40:20,610 --> 00:40:24,660
you pass it an array it's going to

00:40:22,619 --> 00:40:28,230
process the elements of that array and

00:40:24,660 --> 00:40:30,330
when you use the array name X as an

00:40:28,230 --> 00:40:34,800
argument to a call on foo you get that

00:40:30,330 --> 00:40:37,440
implicit conversion array two pointer

00:40:34,800 --> 00:40:40,440
conversion so let's now consider the

00:40:37,440 --> 00:40:43,770
consequence of putting const somewhere

00:40:40,440 --> 00:40:47,130
in the parameter list of food one way to

00:40:43,770 --> 00:40:52,530
do it is like that again I could have

00:40:47,130 --> 00:40:55,790
said T Const cons T but you know most of

00:40:52,530 --> 00:41:01,200
you know by I'm an East Coast guy so

00:40:55,790 --> 00:41:04,710
this is what I'm just showing you one of

00:41:01,200 --> 00:41:06,990
the two possibilities so what's the

00:41:04,710 --> 00:41:12,270
consequence of doing that in terms of

00:41:06,990 --> 00:41:16,500
the behavior of foo well foo is still

00:41:12,270 --> 00:41:19,530
allowed to alter P it can use P to point

00:41:16,500 --> 00:41:21,750
to individual can use P as a local

00:41:19,530 --> 00:41:26,430
variable essentially pointing in turn to

00:41:21,750 --> 00:41:28,940
the different elements within X you can

00:41:26,430 --> 00:41:33,240
dereference p for the purpose of

00:41:28,940 --> 00:41:34,920
comparing it you can increment P itself

00:41:33,240 --> 00:41:37,950
do they be able to step to the next

00:41:34,920 --> 00:41:39,720
element you can compare four equal not

00:41:37,950 --> 00:41:41,490
equal if it supports less than greater

00:41:39,720 --> 00:41:46,860
than compares these are all read

00:41:41,490 --> 00:41:49,790
operations through star P but if you try

00:41:46,860 --> 00:41:53,400
to do that you try to store into star P

00:41:49,790 --> 00:41:56,430
try to alter any elements of the array X

00:41:53,400 --> 00:42:00,060
in this case that's an error and what I

00:41:56,430 --> 00:42:03,180
say is this is a meaningful constraint

00:42:00,060 --> 00:42:04,710
on the behavior of function foo this is

00:42:03,180 --> 00:42:06,300
an announcement that food says you give

00:42:04,710 --> 00:42:08,220
me your data whether I don't care

00:42:06,300 --> 00:42:12,420
whether your data is modifiable or not

00:42:08,220 --> 00:42:13,740
I'm not going to modify it and when you

00:42:12,420 --> 00:42:18,750
look through the standard library you

00:42:13,740 --> 00:42:20,520
see lots of functions that do this they

00:42:18,750 --> 00:42:22,740
work equally well with constant and non

00:42:20,520 --> 00:42:24,450
constant data being passed in because

00:42:22,740 --> 00:42:28,980
they say I'm going to treat it like it's

00:42:24,450 --> 00:42:35,190
caused if this is the behavior one this

00:42:28,980 --> 00:42:39,810
is the way to get it how about this

00:42:35,190 --> 00:42:44,100
button Const on the pointer itself what

00:42:39,810 --> 00:42:47,010
does that say what this says is you

00:42:44,100 --> 00:42:51,720
inside the body of foo you can't alter P

00:42:47,010 --> 00:42:54,240
but you can still use P two in this case

00:42:51,720 --> 00:42:58,920
alter the value of the zeroth element of

00:42:54,240 --> 00:43:01,680
the array right because P itself is

00:42:58,920 --> 00:43:03,480
constant it can only point to the thing

00:43:01,680 --> 00:43:07,830
that it's an initialized to point to

00:43:03,480 --> 00:43:11,880
which in this case is X sub zero now my

00:43:07,830 --> 00:43:15,300
reaction to this is in I'm nearing

00:43:11,880 --> 00:43:17,280
retirement in 40 actually it's not quite

00:43:15,300 --> 00:43:20,550
four it's it's you have almost 40 years

00:43:17,280 --> 00:43:22,890
of C and C++ programming I can't recall

00:43:20,550 --> 00:43:29,610
ever wanting a function where that was

00:43:22,890 --> 00:43:31,320
the behavior that I wanted I would claim

00:43:29,610 --> 00:43:36,240
that this is pretty useless if not

00:43:31,320 --> 00:43:38,280
deceptive because I think when you're

00:43:36,240 --> 00:43:40,740
looking at the Declaration of a function

00:43:38,280 --> 00:43:43,290
and you see a constant there most

00:43:40,740 --> 00:43:44,700
programmers are going to say I want to

00:43:43,290 --> 00:43:45,840
know what you're going to do with my

00:43:44,700 --> 00:43:47,280
data

00:43:45,840 --> 00:43:49,560
I'm handing you some data what are you

00:43:47,280 --> 00:43:55,680
gonna do with it and what is this

00:43:49,560 --> 00:43:57,720
constants a this consec --that i am

00:43:55,680 --> 00:43:59,610
going to take you the copy of the

00:43:57,720 --> 00:44:05,460
address of your data and i promise i

00:43:59,610 --> 00:44:09,180
won't change it I won't change my own

00:44:05,460 --> 00:44:13,850
copy of your address and I say gee

00:44:09,180 --> 00:44:16,980
thanks you know thanks for sharing that

00:44:13,850 --> 00:44:18,150
but it doesn't affect what foo can do

00:44:16,980 --> 00:44:20,970
with my data

00:44:18,150 --> 00:44:26,550
foo can go ahead and scribble all over

00:44:20,970 --> 00:44:30,510
my data do it like this so you can take

00:44:26,550 --> 00:44:33,660
the value in P and copy it to Q notice

00:44:30,510 --> 00:44:36,120
that Q is not a no constant there in the

00:44:33,660 --> 00:44:39,570
in Q's declarations hold it isn't that

00:44:36,120 --> 00:44:42,360
going to violate something no because P

00:44:39,570 --> 00:44:45,030
is a constant pointer to non constant

00:44:42,360 --> 00:44:47,490
data and I'm taking that constant

00:44:45,030 --> 00:44:51,930
pointer and copying it the value being

00:44:47,490 --> 00:44:55,920
copied is a pointer to T a pointer to

00:44:51,930 --> 00:44:59,430
non constant T the only thing I promised

00:44:55,920 --> 00:45:02,850
here was I wouldn't change P itself that

00:44:59,430 --> 00:45:06,780
doesn't change P and then I can go ahead

00:45:02,850 --> 00:45:11,460
and use Q to scribble all over the data

00:45:06,780 --> 00:45:13,800
that was passed in you can also do it

00:45:11,460 --> 00:45:15,690
with array notation you can declare a

00:45:13,800 --> 00:45:17,160
local variable for an index and

00:45:15,690 --> 00:45:21,270
subscript off of the point and that

00:45:17,160 --> 00:45:24,780
doesn't change the point or either so I

00:45:21,270 --> 00:45:28,050
would say I'm not too partial to using

00:45:24,780 --> 00:45:32,400
constant this way I think it's actually

00:45:28,050 --> 00:45:34,770
it's arguably deceptive you know it's it

00:45:32,400 --> 00:45:37,770
tricks the the less than completely

00:45:34,770 --> 00:45:40,590
alert reader into thinking that there is

00:45:37,770 --> 00:45:42,020
a behavioral statement there when there

00:45:40,590 --> 00:45:45,480
really isn't there's an implementation

00:45:42,020 --> 00:45:46,830
statement not a behavioral statement how

00:45:45,480 --> 00:45:52,220
about this one well that's overkill

00:45:46,830 --> 00:45:55,350
because the the constant modifies the t

00:45:52,220 --> 00:45:57,830
has an effect on the outward behavior of

00:45:55,350 --> 00:45:57,830
the function

00:45:58,060 --> 00:46:04,000
the constant modifies the pointer well

00:46:00,700 --> 00:46:05,290
we just dismissed that one so my advice

00:46:04,000 --> 00:46:07,180
to you is you declare a pointer

00:46:05,290 --> 00:46:09,220
parameter as pointer to Const if the

00:46:07,180 --> 00:46:12,430
function shouldn't alter the pointed to

00:46:09,220 --> 00:46:14,200
object and that imposes a meaningful

00:46:12,430 --> 00:46:17,080
constraint on the functions outward

00:46:14,200 --> 00:46:18,490
behavior the guideline for references is

00:46:17,080 --> 00:46:20,800
similar it's declare a reference

00:46:18,490 --> 00:46:22,390
parameter as reference to Const if the

00:46:20,800 --> 00:46:25,330
function shouldn't alter the referenced

00:46:22,390 --> 00:46:27,610
object and we see abundant examples of

00:46:25,330 --> 00:46:29,500
this in common class member functions

00:46:27,610 --> 00:46:34,330
like copy constructors and copy

00:46:29,500 --> 00:46:36,310
assignment operators we you know it's

00:46:34,330 --> 00:46:38,950
exceedingly rare I hate to make

00:46:36,310 --> 00:46:40,480
absolutist statement but you don't

00:46:38,950 --> 00:46:42,790
really want these to be destructive

00:46:40,480 --> 00:46:44,260
copies which is what you would get if

00:46:42,790 --> 00:46:47,140
you took the Const off there the

00:46:44,260 --> 00:46:54,280
potential that the source operand would

00:46:47,140 --> 00:46:56,230
be modified by copying it now just a

00:46:54,280 --> 00:46:59,080
tiny don't introduce a little bit of

00:46:56,230 --> 00:47:02,440
terminology to be able to talk about the

00:46:59,080 --> 00:47:04,780
next concept it's that in C++ as you

00:47:02,440 --> 00:47:06,940
well know data types can exist on

00:47:04,780 --> 00:47:08,560
multiple levels so for example when you

00:47:06,940 --> 00:47:12,250
declare a pointer to character it's a

00:47:08,560 --> 00:47:13,990
two-level type pointer to character when

00:47:12,250 --> 00:47:17,950
you have an array of pointer to int it's

00:47:13,990 --> 00:47:20,140
array of pointer to in three levels and

00:47:17,950 --> 00:47:23,530
when you just say a type is string

00:47:20,140 --> 00:47:26,290
that's one level and there's this term

00:47:23,530 --> 00:47:29,610
for ACB qualifier applied to the first

00:47:26,290 --> 00:47:32,470
level we call it a top-level qualifier

00:47:29,610 --> 00:47:35,590
for example here this is P is a constant

00:47:32,470 --> 00:47:36,790
pointer to a tee Const is the top-level

00:47:35,590 --> 00:47:39,640
qualifier

00:47:36,790 --> 00:47:42,720
q is a volatile pointer to a constant e

00:47:39,640 --> 00:47:44,800
volatile as the top-level qualifier

00:47:42,720 --> 00:47:45,610
these don't have any top-level

00:47:44,800 --> 00:47:48,670
qualifiers

00:47:45,610 --> 00:47:51,010
even though P is a pointer to a console

00:47:48,670 --> 00:47:52,660
little T there's no qualifier on the

00:47:51,010 --> 00:47:59,710
pointer itself which would be the

00:47:52,660 --> 00:48:02,020
top-level so what about top-level types

00:47:59,710 --> 00:48:05,830
in parameters like this here's a

00:48:02,020 --> 00:48:08,560
function G that takes an int my position

00:48:05,830 --> 00:48:11,500
is my advice is this is regardless as

00:48:08,560 --> 00:48:15,580
useless and the reason is it's already

00:48:11,500 --> 00:48:18,660
passing by value when you have an

00:48:15,580 --> 00:48:21,010
integer argument 2n and you pass it to

00:48:18,660 --> 00:48:23,950
gee-gees making a copy that's what

00:48:21,010 --> 00:48:27,160
passed by value means and so G can't

00:48:23,950 --> 00:48:30,220
alter N and the presence of the Const

00:48:27,160 --> 00:48:33,970
heir doesn't make that inability any

00:48:30,220 --> 00:48:36,930
stronger or weaker all it does again is

00:48:33,970 --> 00:48:44,370
it affects what G can do with its copy

00:48:36,930 --> 00:48:48,940
inside the body of the function and so I

00:48:44,370 --> 00:48:50,650
tend to discourage this yes so the

00:48:48,940 --> 00:48:51,880
argument that I've heard in terms of

00:48:50,650 --> 00:48:53,650
this is there's a difference between

00:48:51,880 --> 00:48:55,450
whether it's on the interface or there

00:48:53,650 --> 00:48:57,700
it's on the implement yeah hold still on

00:48:55,450 --> 00:49:05,290
that yes I don't mean to cut you off but

00:48:57,700 --> 00:49:07,300
I'm getting there yes so here is the

00:49:05,290 --> 00:49:13,110
thing that I caution about is you know

00:49:07,300 --> 00:49:13,110
hear a familiar function mem copy and

00:49:13,560 --> 00:49:19,960
notice that there is a Const in the

00:49:16,870 --> 00:49:22,180
parameter list on the source operand it

00:49:19,960 --> 00:49:23,620
says S is a pointer to a constant voy

00:49:22,180 --> 00:49:26,950
notice there's no constant on the

00:49:23,620 --> 00:49:29,830
destination and there's no Const on the

00:49:26,950 --> 00:49:32,020
size T parameter n which represents the

00:49:29,830 --> 00:49:33,910
number of bytes to be copied and it's a

00:49:32,020 --> 00:49:38,230
common idiom to implement this by

00:49:33,910 --> 00:49:39,910
decrementing and inside the function so

00:49:38,230 --> 00:49:42,880
what's the consequence for example of

00:49:39,910 --> 00:49:44,770
putting cons there what it does is it

00:49:42,880 --> 00:49:47,590
renders this particular programming

00:49:44,770 --> 00:49:50,980
style invalid you're now obligated to

00:49:47,590 --> 00:49:57,610
copy and to another local variable in

00:49:50,980 --> 00:50:02,770
order to be able to decrement it I'm not

00:49:57,610 --> 00:50:04,660
sure you gain much by doing that and to

00:50:02,770 --> 00:50:06,550
make matters worse is well if you're

00:50:04,660 --> 00:50:08,950
going to put the Const on the size T

00:50:06,550 --> 00:50:13,360
then let's look at the other top-level

00:50:08,950 --> 00:50:16,030
types where you could put it you can put

00:50:13,360 --> 00:50:18,670
a Const on the return type on the

00:50:16,030 --> 00:50:20,470
parameter D you can add another one to

00:50:18,670 --> 00:50:24,280
the Declaration of s and you can put one

00:50:20,470 --> 00:50:27,040
on N and I've

00:50:24,280 --> 00:50:28,780
put them all in red because they don't

00:50:27,040 --> 00:50:34,150
affect the outward behavior of the

00:50:28,780 --> 00:50:36,730
function there's only one of those one

00:50:34,150 --> 00:50:40,120
two three four five constants that

00:50:36,730 --> 00:50:42,610
actually has a substantive impact and

00:50:40,120 --> 00:50:44,730
the problem is once you start going down

00:50:42,610 --> 00:50:47,560
this path

00:50:44,730 --> 00:50:49,900
most people regret it because what it

00:50:47,560 --> 00:50:51,670
does is it drowns the meaningful costs

00:50:49,900 --> 00:50:58,930
in a sea of relatively meaningless

00:50:51,670 --> 00:51:00,610
constants so I still you should use it

00:50:58,930 --> 00:51:02,650
proactively but I believe you should

00:51:00,610 --> 00:51:06,670
avoid using constant the top level of

00:51:02,650 --> 00:51:10,770
parameter declarations okay and I

00:51:06,670 --> 00:51:12,850
haven't forgotten about your point okay

00:51:10,770 --> 00:51:16,840
okay let's just talk for a moment about

00:51:12,850 --> 00:51:18,760
constant class design and I'm going to

00:51:16,840 --> 00:51:20,590
use as my illustration a rudimentary

00:51:18,760 --> 00:51:24,370
string class that looks a lot like the

00:51:20,590 --> 00:51:26,890
standard string here's a sketch of an

00:51:24,370 --> 00:51:30,190
implementation the private data consists

00:51:26,890 --> 00:51:32,170
of a pointer to a character that points

00:51:30,190 --> 00:51:34,810
to a dynamically allocated array that

00:51:32,170 --> 00:51:38,290
holds the text of the strength plus an

00:51:34,810 --> 00:51:40,540
integer which is the current number of

00:51:38,290 --> 00:51:42,580
characters in the string and you have

00:51:40,540 --> 00:51:44,650
some member functions like size which is

00:51:42,580 --> 00:51:45,940
how you ask how many characters are

00:51:44,650 --> 00:51:48,340
currently there and there's a member

00:51:45,940 --> 00:51:52,480
function clear which will erase the

00:51:48,340 --> 00:51:55,540
contents of a string now it's it's very

00:51:52,480 --> 00:51:57,970
typical that you pass string objects by

00:51:55,540 --> 00:52:00,610
reference to con Strether than by value

00:51:57,970 --> 00:52:02,440
because passing a string by value

00:52:00,610 --> 00:52:05,890
invokes the copy constructor makes a

00:52:02,440 --> 00:52:07,150
copy of the entire string generally

00:52:05,890 --> 00:52:10,150
expensive thing to do

00:52:07,150 --> 00:52:11,860
so we the prevailing wisdom is unless

00:52:10,150 --> 00:52:14,290
you really need a copy you pass by

00:52:11,860 --> 00:52:17,350
reference to Const because it has a very

00:52:14,290 --> 00:52:19,420
similar effect outwardly namely I'm

00:52:17,350 --> 00:52:21,370
giving you access to my string without

00:52:19,420 --> 00:52:24,100
having to make a copy and you can't

00:52:21,370 --> 00:52:28,180
modify it which is what would happen if

00:52:24,100 --> 00:52:32,260
you passed it by value something that

00:52:28,180 --> 00:52:33,790
looks like that now the problem is that

00:52:32,260 --> 00:52:35,410
that code right there based on

00:52:33,790 --> 00:52:37,030
everything I've shown you won't compile

00:52:35,410 --> 00:52:37,990
and the reason it won't compile is

00:52:37,030 --> 00:52:40,060
because

00:52:37,990 --> 00:52:44,110
compiler will complain about the call on

00:52:40,060 --> 00:52:47,920
the member function sighs and that's

00:52:44,110 --> 00:52:51,160
because the Declaration of X in the

00:52:47,920 --> 00:52:54,430
parameter list of Fuu says I promise I

00:52:51,160 --> 00:52:57,400
will not alter s and now here you are

00:52:54,430 --> 00:52:59,619
passing it through at this pointer to a

00:52:57,400 --> 00:53:01,270
member function and it's perfectly

00:52:59,619 --> 00:53:04,540
legitimate to ask but where's the

00:53:01,270 --> 00:53:06,460
promise that size made that it won't

00:53:04,540 --> 00:53:11,340
alter the string that is computing the

00:53:06,460 --> 00:53:14,700
size of I didn't see anything about that

00:53:11,340 --> 00:53:18,820
well now if the this parameter were

00:53:14,700 --> 00:53:20,050
explicitly declared in C++ solving this

00:53:18,820 --> 00:53:22,720
problem would be easy you would just

00:53:20,050 --> 00:53:26,950
throw a Const into the explicit

00:53:22,720 --> 00:53:31,380
declaration of this and that's how size

00:53:26,950 --> 00:53:34,030
would make the promise but those

00:53:31,380 --> 00:53:36,040
declarations for this are not something

00:53:34,030 --> 00:53:38,230
that we write the compiler writes at

00:53:36,040 --> 00:53:41,440
forests so where do you squeeze the

00:53:38,230 --> 00:53:46,450
Const and the answer is you put it after

00:53:41,440 --> 00:53:48,910
the parameter list that's the way that a

00:53:46,450 --> 00:53:52,630
function says I promise I won't alter

00:53:48,910 --> 00:53:56,350
the object that my this parameter is

00:53:52,630 --> 00:53:59,440
pointing to it has the effect of putting

00:53:56,350 --> 00:54:05,020
of modifying the Declaration of this to

00:53:59,440 --> 00:54:07,690
be a pointer to Const and one of the

00:54:05,020 --> 00:54:11,350
consequences is then that inside a Const

00:54:07,690 --> 00:54:15,010
member function any attempt to modify a

00:54:11,350 --> 00:54:18,760
data member of the object is now

00:54:15,010 --> 00:54:21,310
rejected as an error because this is

00:54:18,760 --> 00:54:30,100
pointing to a constant object it keeps

00:54:21,310 --> 00:54:31,900
the promise and so if you try to put the

00:54:30,100 --> 00:54:34,030
Const on the clear function though

00:54:31,900 --> 00:54:36,490
you'll find that's you're getting

00:54:34,030 --> 00:54:38,590
carried away here because it's really

00:54:36,490 --> 00:54:42,940
hard to clear a string and say but I

00:54:38,590 --> 00:54:45,190
promise I won't alter its contents and

00:54:42,940 --> 00:54:47,740
and you'll be called out by the compiler

00:54:45,190 --> 00:54:50,470
for doing that because it will reject

00:54:47,740 --> 00:54:51,559
attempts to modify data members of the

00:54:50,470 --> 00:54:57,799
object

00:54:51,559 --> 00:55:01,640
inside the body of the function so the

00:54:57,799 --> 00:55:04,309
rules for passing constant non-constant

00:55:01,640 --> 00:55:07,519
to member functions are direct parallel

00:55:04,309 --> 00:55:10,359
to the qualification conversion rules so

00:55:07,519 --> 00:55:17,479
you can apply a constant member function

00:55:10,359 --> 00:55:19,609
to either a Const or a non constant but

00:55:17,479 --> 00:55:25,599
you can apply a non-constant member

00:55:19,609 --> 00:55:25,599
function only to a non constant object

00:55:26,109 --> 00:55:31,039
so think about it this way is that if

00:55:28,969 --> 00:55:34,819
you're writing classes and your attitude

00:55:31,039 --> 00:55:37,729
is I can't be bothered putting const in

00:55:34,819 --> 00:55:40,009
the interface to that class i just don't

00:55:37,729 --> 00:55:42,109
want to fuss with constant functions the

00:55:40,009 --> 00:55:45,859
consequence is that anybody who wants to

00:55:42,109 --> 00:55:47,449
use your class can't declare constant

00:55:45,859 --> 00:55:49,369
object they couldn't declare Const

00:55:47,449 --> 00:55:51,469
objects of that type but as soon as they

00:55:49,369 --> 00:55:54,769
try to apply any operations to it

00:55:51,469 --> 00:55:57,259
they'll be rejected by the compiler on

00:55:54,769 --> 00:55:58,789
the other hand if you opt to use Const

00:55:57,259 --> 00:55:59,539
as you're designing the class and

00:55:58,789 --> 00:56:03,199
implementing it

00:55:59,539 --> 00:56:05,929
you don't force anybody to use Const you

00:56:03,199 --> 00:56:07,489
say the freedom is yours make objects

00:56:05,929 --> 00:56:10,279
constant on constants and I'm going to

00:56:07,489 --> 00:56:13,160
give you full functionality for those

00:56:10,279 --> 00:56:14,749
objects and so the advice is declare a

00:56:13,160 --> 00:56:19,609
member function ax sconce whenever it's

00:56:14,749 --> 00:56:21,769
meaningful to do so now I have three

00:56:19,609 --> 00:56:24,249
minutes left and I wasn't sure exactly

00:56:21,769 --> 00:56:26,479
where I would end so this isn't quite I

00:56:24,249 --> 00:56:29,199
bear with me just another few minutes

00:56:26,479 --> 00:56:32,719
I'm going to do a few more slides

00:56:29,199 --> 00:56:37,219
there's a curious flaw in constant

00:56:32,719 --> 00:56:39,410
functions and that is right here is that

00:56:37,219 --> 00:56:43,640
if we implement a square bracket

00:56:39,410 --> 00:56:45,469
operator to illustrate this point let's

00:56:43,640 --> 00:56:47,650
go ahead and add it and I think square

00:56:45,469 --> 00:56:50,239
brackets should be a constant function

00:56:47,650 --> 00:56:52,969
because if it's not a constant function

00:56:50,239 --> 00:56:56,449
you can't select an element out of a

00:56:52,969 --> 00:57:00,949
constant array like out of a constant

00:56:56,449 --> 00:57:04,760
string you want to be able to do things

00:57:00,949 --> 00:57:06,860
like that and when the compiler sees s

00:57:04,760 --> 00:57:09,170
by will interpret it as s dot operator

00:57:06,860 --> 00:57:11,350
square bracket of I and the

00:57:09,170 --> 00:57:15,470
implementation looks something like that

00:57:11,350 --> 00:57:17,360
very simple function notice it's a Const

00:57:15,470 --> 00:57:19,670
member function it says I won't alter it

00:57:17,360 --> 00:57:22,270
anything but look at the return type

00:57:19,670 --> 00:57:24,800
it's a reference to Const

00:57:22,270 --> 00:57:29,600
not a I'm sorry it's a reference to a

00:57:24,800 --> 00:57:33,740
non cons - what does that mean it means

00:57:29,600 --> 00:57:35,750
that you could write code like this you

00:57:33,740 --> 00:57:38,120
could say I've got a constant string and

00:57:35,750 --> 00:57:40,100
I'm going to assign to it one of the

00:57:38,120 --> 00:57:42,050
characters in that string that code

00:57:40,100 --> 00:57:51,740
would compile and I think most of us

00:57:42,050 --> 00:57:53,990
would say that's a logic error and yeah

00:57:51,740 --> 00:57:56,300
and the reason it does work is because

00:57:53,990 --> 00:57:58,820
it's returning a reference to non Const

00:57:56,300 --> 00:57:59,530
a modifiable character and this is it

00:57:58,820 --> 00:58:01,910
logical

00:57:59,530 --> 00:58:03,530
the reason it's illogical is because

00:58:01,910 --> 00:58:05,360
most of us expect that an element

00:58:03,530 --> 00:58:08,330
selected from a constant string should

00:58:05,360 --> 00:58:09,980
be constant oh and by the way an element

00:58:08,330 --> 00:58:12,530
selected from a non constant string

00:58:09,980 --> 00:58:17,890
should be non constant right that's the

00:58:12,530 --> 00:58:23,630
logic so why does that even compile and

00:58:17,890 --> 00:58:27,320
the answer is that this in a constant

00:58:23,630 --> 00:58:29,510
function is pointer to Const

00:58:27,320 --> 00:58:33,250
actually it's a Const pointer to concen

00:58:29,510 --> 00:58:35,270
let's not go there what matters is that

00:58:33,250 --> 00:58:38,270
when you're in a constant member

00:58:35,270 --> 00:58:40,550
function it makes the top type of all

00:58:38,270 --> 00:58:45,560
the non static data members Const

00:58:40,550 --> 00:58:49,220
it's like this the Const is applied not

00:58:45,560 --> 00:58:53,140
to the contents of the string itself but

00:58:49,220 --> 00:58:53,140
to the pointer that points to the string

00:58:54,100 --> 00:58:58,910
okay and that's why the code goes ahead

00:58:56,570 --> 00:59:01,400
and compiles because even in a constant

00:58:58,910 --> 00:59:04,940
string the contents of the string or non

00:59:01,400 --> 00:59:06,830
Const what we really wanted was this but

00:59:04,940 --> 00:59:14,920
that's not what a constant member

00:59:06,830 --> 00:59:14,920
function gives us and so the

00:59:15,329 --> 00:59:19,589
the thing to do is to repair the return

00:59:19,019 --> 00:59:22,109
type

00:59:19,589 --> 00:59:27,209
you just have to fix the flaw manually

00:59:22,109 --> 00:59:28,769
like this now for reasons of time I'm

00:59:27,209 --> 00:59:30,899
going to just skip ahead and show you

00:59:28,769 --> 00:59:32,669
the problem is that it prevents you from

00:59:30,899 --> 00:59:35,640
modifying a string that you want to be

00:59:32,669 --> 00:59:39,029
able to modify you could cast it away

00:59:35,640 --> 00:59:42,649
but that's not where we want to go here

00:59:39,029 --> 00:59:46,289
is the proper solution which is to

00:59:42,649 --> 00:59:48,869
overload them as constant non Const so

00:59:46,289 --> 00:59:51,659
that you get logically consistent return

00:59:48,869 --> 00:59:53,699
type behavior that is an element

00:59:51,659 --> 00:59:56,699
selected from an on constraint should be

00:59:53,699 --> 01:00:01,709
non Const and an element selected from a

00:59:56,699 --> 01:00:03,959
constant string should be Const and so

01:00:01,709 --> 01:00:08,309
it's a really a special case of doing

01:00:03,959 --> 01:00:11,089
this you have point you can overload

01:00:08,309 --> 01:00:14,519
functions on pointer to constant and and

01:00:11,089 --> 01:00:16,859
reference to Const and this is the

01:00:14,519 --> 01:00:21,659
answer to the question that I cut off

01:00:16,859 --> 01:00:24,389
which is that when you have a Const in

01:00:21,659 --> 01:00:25,859
the R in the parameter type like this

01:00:24,389 --> 01:00:29,819
most of the time it's part of the

01:00:25,859 --> 01:00:32,130
signature and you can overload however

01:00:29,819 --> 01:00:34,949
the top-level qualifiers don't

01:00:32,130 --> 01:00:39,419
participate in the signature so it means

01:00:34,949 --> 01:00:41,579
that this is not overloading this is two

01:00:39,419 --> 01:00:44,609
declarations for the same function and

01:00:41,579 --> 01:00:47,489
the Const is ignored for overloading

01:00:44,609 --> 01:00:49,859
purposes and some people like to take

01:00:47,489 --> 01:00:52,079
advantage of this and say well I will

01:00:49,859 --> 01:00:55,769
declare the function without the Const

01:00:52,079 --> 01:00:58,859
and define it with the constant because

01:00:55,769 --> 01:01:01,169
that's part of the implementation I'm

01:00:58,859 --> 01:01:03,359
not too partial to that style but I'm

01:01:01,169 --> 01:01:06,569
not going to argue vehemently against it

01:01:03,359 --> 01:01:08,459
as being wrong I do think though it

01:01:06,569 --> 01:01:10,829
creates a lot of canoe you have to

01:01:08,459 --> 01:01:15,359
educate people a lot to get them to use

01:01:10,829 --> 01:01:17,969
that style okay so that that's not an

01:01:15,359 --> 01:01:22,619
error that's just a redecoration this is

01:01:17,969 --> 01:01:24,329
overloading but this is not so the

01:01:22,619 --> 01:01:27,599
placement of Const in or out of the

01:01:24,329 --> 01:01:30,109
declarative the difference and now I'm

01:01:27,599 --> 01:01:30,109
really done

01:01:30,650 --> 01:01:34,849

YouTube URL: https://www.youtube.com/watch?v=NZtr93iL3R0


