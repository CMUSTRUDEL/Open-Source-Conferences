Title: CppCon 2019: Miro Knejp “Non-conforming C++: the Secrets the Committee Is Hiding From You”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
These days everyone talks about conforming and portable C++. Compiler vendors celebrate increasing conformance. Committee agents blind us with new shiny toys coming to the language. But there is a darker side to C++. A C++ you are not supposed to know about.

What if I told you there was more to C++ than what the agents of The Committee want us to believe? Over decades programmers all around the world have added features to the language in form of compiler extensions that let us do even greater things. Some are completely new, and some are lifted from C to C++ to allow some interesting, and sometimes more efficient, application.

We will see how statements can become expressions, how "goto" with extra superpowers can make your programs faster, and why there exists an operator named after a famous rock star. These are just a few examples of what to expect as listing any more would draw unwanted attention from The Committee. Unfortunately, because these extensions are not part of ISO C++, using any of them comes at the expense of portability. Or does it?
— 
Miro Knejp
Miro Knejp
Miro Knejp
Munich, Germany
Miro wrote his first line of C++ code in 1997 at the age of 12, and it has been his programming language of choice ever since. He’s especially passionate about low-level programming, assembly, 3D graphics, and games engineering. Miro holds a Master’s degrees in Computer Science from the Technical University of Munich. He has worked on projects ranging from designing 3D rendering libraries to building airport self-boarding control systems. He currently works as freelancer and trainer, with the goal of creating his own video game one day.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:09,110 --> 00:00:13,799
alright then good afternoon everyone my

00:00:11,599 --> 00:00:15,080
name is Mira and I'm going to talk to

00:00:13,799 --> 00:00:19,200
you about

00:00:15,080 --> 00:00:20,940
right non-conforming C++ or as I would

00:00:19,200 --> 00:00:24,330
also like to call it the committee

00:00:20,940 --> 00:00:25,890
exposed because today you will see and

00:00:24,330 --> 00:00:28,590
hear things that will fundamentally

00:00:25,890 --> 00:00:31,260
challenge your understanding of the C++

00:00:28,590 --> 00:00:32,850
committee and hour from now you will

00:00:31,260 --> 00:00:35,370
have a very different view important who

00:00:32,850 --> 00:00:37,650
they are you also all believe that you

00:00:35,370 --> 00:00:38,280
came out of your own free will but no

00:00:37,650 --> 00:00:40,170
you have not

00:00:38,280 --> 00:00:41,879
I have made you come here with a little

00:00:40,170 --> 00:00:44,190
bit of mind control because I know that

00:00:41,879 --> 00:00:46,410
you are programmers open-minded enough

00:00:44,190 --> 00:00:48,900
to be receptacle for the truths I'm

00:00:46,410 --> 00:00:51,420
going to reveal to you today if you want

00:00:48,900 --> 00:00:58,830
to know how I did it was that impressive

00:00:51,420 --> 00:01:00,239
camera rates if yeah but you know now

00:00:58,830 --> 00:01:02,790
that I told you how easy to manipulate

00:01:00,239 --> 00:01:04,650
people I have to protect myself because

00:01:02,790 --> 00:01:06,450
there are lots and lots of patrons of

00:01:04,650 --> 00:01:11,869
the committee in this building today the

00:01:06,450 --> 00:01:14,880
whole week and so I have to make sure

00:01:11,869 --> 00:01:16,080
the data cannot stop this you cannot

00:01:14,880 --> 00:01:20,220
stop this anymore this will happen

00:01:16,080 --> 00:01:21,510
whether you want or not because oh you

00:01:20,220 --> 00:01:22,770
don't think this is a joke right you

00:01:21,510 --> 00:01:24,720
laughing because this is funny to you

00:01:22,770 --> 00:01:26,250
well let me tell you after I announced

00:01:24,720 --> 00:01:28,650
this talk on Twitter about two months

00:01:26,250 --> 00:01:31,230
ago I have received thinly veiled death

00:01:28,650 --> 00:01:33,990
threats on Twitter in public by agents

00:01:31,230 --> 00:01:35,850
of the committee they did audacity they

00:01:33,990 --> 00:01:38,490
think they are untouchable one of them

00:01:35,850 --> 00:01:41,040
said and I quote good thing we're a

00:01:38,490 --> 00:01:42,360
committee and other mafia you'd be

00:01:41,040 --> 00:01:45,180
swimming with the fishes for the street

00:01:42,360 --> 00:01:46,650
I have been living in fear ever since

00:01:45,180 --> 00:01:49,500
because I'm afraid that I couldn't just

00:01:46,650 --> 00:01:52,170
something worse and another quote from

00:01:49,500 --> 00:01:55,530
another agent C++ is what the Committee

00:01:52,170 --> 00:01:57,480
says it is c plus plus plus plus is not

00:01:55,530 --> 00:01:59,580
C++ I'm honestly not sure this means I

00:01:57,480 --> 00:02:01,409
think it's code for something and there

00:01:59,580 --> 00:02:03,210
unfortunately no fish in Denver I'm

00:02:01,409 --> 00:02:06,860
pretty sure that's wrong but I'm glad

00:02:03,210 --> 00:02:09,690
they believe it and it didn't stop there

00:02:06,860 --> 00:02:12,930
about a week ago was invited on CPP cast

00:02:09,690 --> 00:02:17,250
and only days after the episode went

00:02:12,930 --> 00:02:20,280
live I have received a message saying

00:02:17,250 --> 00:02:22,319
also we will have to get rid of CPP cast

00:02:20,280 --> 00:02:25,709
and its host because of you can't have

00:02:22,319 --> 00:02:27,989
people spread lies so Rob and Jason I am

00:02:25,709 --> 00:02:28,440
really really sorry I have to apologize

00:02:27,989 --> 00:02:30,780
to you

00:02:28,440 --> 00:02:32,430
at one point in the episode I have

00:02:30,780 --> 00:02:38,340
accused you of being compromised by the

00:02:32,430 --> 00:02:40,050
committee and now I know the truth and I

00:02:38,340 --> 00:02:44,220
am really sorry that I put you in danger

00:02:40,050 --> 00:02:45,660
okay yeah you better you know leave the

00:02:44,220 --> 00:02:48,930
country though it's it's international I

00:02:45,660 --> 00:02:53,940
don't know but maybe after this is over

00:02:48,930 --> 00:02:55,320
you'll be safe again you'll see okay so

00:02:53,940 --> 00:02:56,880
now with this out of the way you now

00:02:55,320 --> 00:02:58,710
understand the gravity of the situation

00:02:56,880 --> 00:03:01,530
although anti-gravity is in a different

00:02:58,710 --> 00:03:03,360
talk I'm sorry we start like one of the

00:03:01,530 --> 00:03:06,630
first treasures of the secret committee

00:03:03,360 --> 00:03:08,310
box and that is case ranges so I'm

00:03:06,630 --> 00:03:10,560
pretty sure many of you have seen

00:03:08,310 --> 00:03:13,350
switches like this where you have many

00:03:10,560 --> 00:03:15,600
cases that are exiting to the same code

00:03:13,350 --> 00:03:17,370
and it's tedious and it's error-prone

00:03:15,600 --> 00:03:19,070
and so a normal person is going to say

00:03:17,370 --> 00:03:21,390
I'm going to use anything else

00:03:19,070 --> 00:03:22,470
unfortunately now I've lost the

00:03:21,390 --> 00:03:24,990
declarative nature of the switch

00:03:22,470 --> 00:03:27,000
statement is what the GCC developers

00:03:24,990 --> 00:03:29,670
thought and so it said let's add switch

00:03:27,000 --> 00:03:32,220
ranges case ranges so you can just use

00:03:29,670 --> 00:03:34,050
dot or dot between two values and it's

00:03:32,220 --> 00:03:37,560
going to generate all the cases with

00:03:34,050 --> 00:03:40,830
those two values inclusive so what it's

00:03:37,560 --> 00:03:43,260
like you've received forbidden knowledge

00:03:40,830 --> 00:03:44,400
from the committee today for the first

00:03:43,260 --> 00:03:45,930
time how does it feel it's exciting

00:03:44,400 --> 00:03:48,690
isn't it so let's keep going

00:03:45,930 --> 00:03:51,600
the next one unnamed structured Union

00:03:48,690 --> 00:03:52,709
foods this one has leaked so much people

00:03:51,600 --> 00:03:55,290
think it's actually part of the language

00:03:52,709 --> 00:03:57,810
but it is not what we see here is a

00:03:55,290 --> 00:03:59,580
union without a type and a struct

00:03:57,810 --> 00:04:01,680
without the type and both declare

00:03:59,580 --> 00:04:04,650
members inside the outer structure now

00:04:01,680 --> 00:04:07,200
the union is fine this truck is not who

00:04:04,650 --> 00:04:08,760
knows why we can simplify this a little

00:04:07,200 --> 00:04:11,160
bit and just remove the outer structure

00:04:08,760 --> 00:04:13,080
because in 2011 the committee finally

00:04:11,160 --> 00:04:15,030
decided to declassify unrestricted

00:04:13,080 --> 00:04:17,850
unions and so we can have special member

00:04:15,030 --> 00:04:19,890
functions what can we do with this I

00:04:17,850 --> 00:04:21,359
mean if you've Anathem graphics engine

00:04:19,890 --> 00:04:23,220
development or game development or if

00:04:21,359 --> 00:04:25,050
you look at any of the tutorial on the

00:04:23,220 --> 00:04:27,870
internet you will have seen something

00:04:25,050 --> 00:04:30,380
like this that you can use the floats in

00:04:27,870 --> 00:04:33,419
this structure either by name or by

00:04:30,380 --> 00:04:35,790
indexing the array which is kind of

00:04:33,419 --> 00:04:37,710
useful because you can use dynamic

00:04:35,790 --> 00:04:41,280
indices to refer to your structure

00:04:37,710 --> 00:04:42,480
members and many api is required to pass

00:04:41,280 --> 00:04:45,750
in floats

00:04:42,480 --> 00:04:49,320
as a pointer to a ray so you don't have

00:04:45,750 --> 00:04:52,170
to reinterpret cast around and the thing

00:04:49,320 --> 00:04:54,090
is though if you are respectable C++

00:04:52,170 --> 00:04:56,120
company then at some point in your life

00:04:54,090 --> 00:04:59,490
you're going to hire you know these

00:04:56,120 --> 00:05:02,610
experts to tell you how to code write in

00:04:59,490 --> 00:05:04,380
C++ they're going to come to you look at

00:05:02,610 --> 00:05:09,210
your code and say you can do that that's

00:05:04,380 --> 00:05:10,800
a different behavior oh no oh no oh no a

00:05:09,210 --> 00:05:12,450
sudden surge of panic comes over you

00:05:10,800 --> 00:05:14,040
because they set the humor than the B

00:05:12,450 --> 00:05:15,150
word in the same sentence and that means

00:05:14,040 --> 00:05:18,210
you have to write everything from

00:05:15,150 --> 00:05:20,790
scratch but you have to keep calm and

00:05:18,210 --> 00:05:23,730
you have to stare at them stare at them

00:05:20,790 --> 00:05:26,250
real hard and some more and then we

00:05:23,730 --> 00:05:28,140
follow your confidence you say so what

00:05:26,250 --> 00:05:30,570
we got millions of Webster awning it

00:05:28,140 --> 00:05:34,230
works on all machines and then they just

00:05:30,570 --> 00:05:37,230
walk away now you have saved yourself a

00:05:34,230 --> 00:05:41,040
lot of money and even for the C++

00:05:37,230 --> 00:05:44,030
rebellion but your thinking has a C++

00:05:41,040 --> 00:05:46,710
all I've seen so far C can I just

00:05:44,030 --> 00:05:48,600
overload the subscript operator but you

00:05:46,710 --> 00:05:50,580
can well it turns out the compiler

00:05:48,600 --> 00:05:52,410
doesn't like it so much I've tried and

00:05:50,580 --> 00:05:54,840
the generated code isn't as nice and

00:05:52,410 --> 00:05:56,910
also I'm pretty sure that this here

00:05:54,840 --> 00:05:59,190
becomes undefined behavior because you

00:05:56,910 --> 00:06:05,010
cannot just turn a field float into an

00:05:59,190 --> 00:06:06,840
array all right coming next conditionals

00:06:05,010 --> 00:06:09,210
with omitted operands quite a mouthful

00:06:06,840 --> 00:06:10,500
of the name imagine the scenario you're

00:06:09,210 --> 00:06:11,640
writing some kind of configuration

00:06:10,500 --> 00:06:14,600
system and you're reading it

00:06:11,640 --> 00:06:16,860
configuration file values form a file

00:06:14,600 --> 00:06:18,270
you represent these using the read

00:06:16,860 --> 00:06:19,890
function and the default value function

00:06:18,270 --> 00:06:21,420
they return have unique point of

00:06:19,890 --> 00:06:23,670
something you don't really care right

00:06:21,420 --> 00:06:25,110
now and you have this little convenience

00:06:23,670 --> 00:06:26,430
function that if the value does not

00:06:25,110 --> 00:06:30,300
exist in the file you're just going to

00:06:26,430 --> 00:06:32,160
return the default now this this cries

00:06:30,300 --> 00:06:34,050
like I should use I should be able to

00:06:32,160 --> 00:06:37,710
use the conditional operator right it's

00:06:34,050 --> 00:06:40,620
an if return else return it's like the

00:06:37,710 --> 00:06:41,970
perfect use case unfortunately when you

00:06:40,620 --> 00:06:45,180
try you realize that you're running into

00:06:41,970 --> 00:06:47,730
a problem because the left expression if

00:06:45,180 --> 00:06:49,980
it evaluates to a normal pointer it's

00:06:47,730 --> 00:06:51,810
gonna call the read again and if read

00:06:49,980 --> 00:06:54,630
has side effects you probably just

00:06:51,810 --> 00:06:56,220
trashed your configuration system if for

00:06:54,630 --> 00:07:01,920
example you develop it one

00:06:56,220 --> 00:07:03,600
sorry it advances so you have to host

00:07:01,920 --> 00:07:06,960
this read out of the conditioner which

00:07:03,600 --> 00:07:10,100
looks ugly but you know it still does

00:07:06,960 --> 00:07:13,230
the job but let's look again at this

00:07:10,100 --> 00:07:15,210
expression this operator the way it

00:07:13,230 --> 00:07:17,220
works you have an expression on the left

00:07:15,210 --> 00:07:19,380
followed by question mark an expression

00:07:17,220 --> 00:07:21,750
in the middle colon an expression on the

00:07:19,380 --> 00:07:23,100
right the problem it has the property

00:07:21,750 --> 00:07:25,400
that both the expressions on the right

00:07:23,100 --> 00:07:28,740
have to have in compare not in their

00:07:25,400 --> 00:07:30,690
compatible types because the expression

00:07:28,740 --> 00:07:32,520
as a whole must have a type

00:07:30,690 --> 00:07:33,960
so both the result of course of these

00:07:32,520 --> 00:07:38,280
expressions has to be implicitly

00:07:33,960 --> 00:07:41,460
convertible to one type so there's

00:07:38,280 --> 00:07:44,070
people that CP g CC thought we can do

00:07:41,460 --> 00:07:45,300
better and they decided to create a

00:07:44,070 --> 00:07:47,970
version that you can just remove the

00:07:45,300 --> 00:07:49,500
middle part and it's the equivalent as

00:07:47,970 --> 00:07:51,450
if you just repeated the left expression

00:07:49,500 --> 00:07:54,180
put it in the middle except it is only

00:07:51,450 --> 00:07:56,280
evaluated once now you might be thinking

00:07:54,180 --> 00:07:57,630
that kind of breaks the type system

00:07:56,280 --> 00:08:00,000
right because we now have an expression

00:07:57,630 --> 00:08:03,360
of a bull with something else and it

00:08:00,000 --> 00:08:05,820
doesn't work but it does because the way

00:08:03,360 --> 00:08:09,240
this works is the expression on the left

00:08:05,820 --> 00:08:11,220
is evaluated in its entirety and that's

00:08:09,240 --> 00:08:13,020
the type of the expression and only

00:08:11,220 --> 00:08:16,680
after that the conversion to pool

00:08:13,020 --> 00:08:18,390
happens so this expression here works it

00:08:16,680 --> 00:08:19,680
doesn't cause any type problems and it

00:08:18,390 --> 00:08:23,460
does what we wanted to do and it's very

00:08:19,680 --> 00:08:25,020
concise easy to read then you're gonna

00:08:23,460 --> 00:08:27,270
leave here and look this up on the

00:08:25,020 --> 00:08:29,630
Internet you are going to realize that

00:08:27,270 --> 00:08:33,270
people call this the Elvis operator in

00:08:29,630 --> 00:08:35,849
fact other languages openly admit that

00:08:33,270 --> 00:08:38,789
they have the Aldous operator but not in

00:08:35,849 --> 00:08:41,760
C++ and not in C they don't they're

00:08:38,789 --> 00:08:45,690
hiding this from us I don't know why and

00:08:41,760 --> 00:08:48,750
also by even Elvis operate I mean I mean

00:08:45,690 --> 00:08:50,400
let's look at it okay for me it's

00:08:48,750 --> 00:08:53,250
obvious when I look at this I clearly

00:08:50,400 --> 00:08:56,339
see Alice yeah when you maybe tilt your

00:08:53,250 --> 00:08:58,590
head a bit okay at some point you're

00:08:56,339 --> 00:09:01,710
just gonna see the face of all this

00:08:58,590 --> 00:09:03,720
and I I don't know if you can see it I

00:09:01,710 --> 00:09:08,520
definitely see it and it just can't get

00:09:03,720 --> 00:09:10,040
it out of my Dan anyway have you thought

00:09:08,520 --> 00:09:12,720
about what this means

00:09:10,040 --> 00:09:15,060
why does the C++ and C committees why do

00:09:12,720 --> 00:09:17,100
they so desperately try to keep this

00:09:15,060 --> 00:09:22,440
away from us because they know that the

00:09:17,100 --> 00:09:26,100
king is alive the conspiracy is so deep

00:09:22,440 --> 00:09:29,010
you you wouldn't understand okay another

00:09:26,100 --> 00:09:31,140
very quick and short one so let's go

00:09:29,010 --> 00:09:33,990
further and have a look at designated

00:09:31,140 --> 00:09:35,940
initializers so here in the disassemble

00:09:33,990 --> 00:09:37,200
be a page structure and ordinarily you

00:09:35,940 --> 00:09:38,970
would be able to use aggregate

00:09:37,200 --> 00:09:41,010
initialization to construct in such a

00:09:38,970 --> 00:09:42,390
structure but just have big curly braces

00:09:41,010 --> 00:09:43,160
and putting the values in the right

00:09:42,390 --> 00:09:46,110
order

00:09:43,160 --> 00:09:48,779
this extension lets you use the names of

00:09:46,110 --> 00:09:49,500
the fields in the constructor so that

00:09:48,779 --> 00:09:52,279
you know what you're actually

00:09:49,500 --> 00:09:55,020
initializing inside the structure and

00:09:52,279 --> 00:09:56,760
this is very useful because now you

00:09:55,020 --> 00:10:00,510
don't don't have the confusion between

00:09:56,760 --> 00:10:03,030
the two bullets you see which one gets

00:10:00,510 --> 00:10:04,530
which value and we can use that to

00:10:03,030 --> 00:10:08,070
imitate something other languages have

00:10:04,530 --> 00:10:09,990
called named parameters for example if

00:10:08,070 --> 00:10:11,940
we for the function like this that takes

00:10:09,990 --> 00:10:14,480
one such as structures its parameter and

00:10:11,940 --> 00:10:16,770
then we can construct it in place and

00:10:14,480 --> 00:10:17,880
this looks a lot like if we actually

00:10:16,770 --> 00:10:19,830
have two named parameters in the

00:10:17,880 --> 00:10:22,500
language doesn't it and it's much easier

00:10:19,830 --> 00:10:25,140
to read than this because if you don't

00:10:22,500 --> 00:10:29,839
have the declaration you don't know what

00:10:25,140 --> 00:10:32,400
true what false what it's not obvious

00:10:29,839 --> 00:10:34,560
fortunately this has been declassified

00:10:32,400 --> 00:10:38,700
after decades we finally getting into

00:10:34,560 --> 00:10:40,770
C++ 20 so I won't go into more detail

00:10:38,700 --> 00:10:45,330
here because the public information is

00:10:40,770 --> 00:10:47,550
now a variable about this however the

00:10:45,330 --> 00:10:50,180
committee in its infinite malice decided

00:10:47,550 --> 00:10:55,110
no you're not getting the full thing

00:10:50,180 --> 00:10:57,240
because there's more so this is an area

00:10:55,110 --> 00:11:00,150
that I see a lot you have some kind of

00:10:57,240 --> 00:11:01,890
enumeration in this case it's just names

00:11:00,150 --> 00:11:05,310
for colors and then you have some

00:11:01,890 --> 00:11:07,740
associated arrays right and the idea is

00:11:05,310 --> 00:11:10,560
that you use the enumeration as the key

00:11:07,740 --> 00:11:12,010
to get some value that is associated

00:11:10,560 --> 00:11:14,740
with this

00:11:12,010 --> 00:11:20,200
enumeration like the string or the color

00:11:14,740 --> 00:11:21,580
value on the screen though if you if you

00:11:20,200 --> 00:11:25,390
let someone like me into your code

00:11:21,580 --> 00:11:28,420
I'm just gonna say I can handle this no

00:11:25,390 --> 00:11:31,410
I can't have an unsorted list of names I

00:11:28,420 --> 00:11:34,690
just can't this is too much

00:11:31,410 --> 00:11:36,160
but now I've broken everything and I may

00:11:34,690 --> 00:11:37,720
not even notice because these arrays may

00:11:36,160 --> 00:11:42,010
be in completely different files or

00:11:37,720 --> 00:11:43,360
systems of my project so yeah green yeah

00:11:42,010 --> 00:11:46,600
no no you're not getting green are you

00:11:43,360 --> 00:11:48,190
getting but black here the code for

00:11:46,600 --> 00:11:51,730
white no it's it's the code for yellow

00:11:48,190 --> 00:11:53,080
sorry if you don't have good tests it's

00:11:51,730 --> 00:11:57,190
gonna take a while till you notice I

00:11:53,080 --> 00:11:59,680
guess so of course the obvious thing to

00:11:57,190 --> 00:12:00,880
do is well let's put those damn values

00:11:59,680 --> 00:12:02,230
in there I don't actually care about

00:12:00,880 --> 00:12:03,910
them I don't care that red is you I

00:12:02,230 --> 00:12:06,640
don't care that black is three but I

00:12:03,910 --> 00:12:09,870
need them because now if someone like me

00:12:06,640 --> 00:12:12,550
comes along it works

00:12:09,870 --> 00:12:14,350
however it's tedious because neither

00:12:12,550 --> 00:12:15,520
want to add a new value I have to

00:12:14,350 --> 00:12:20,770
actually find the biggest one in the

00:12:15,520 --> 00:12:22,510
list and incremental I hate it and the

00:12:20,770 --> 00:12:24,280
people at GCC agree with me so they

00:12:22,510 --> 00:12:27,070
decided yeah you're just gonna let you

00:12:24,280 --> 00:12:30,220
specify the index of the value in square

00:12:27,070 --> 00:12:32,140
brackets and what happens now is no

00:12:30,220 --> 00:12:34,780
matter the order of the values of

00:12:32,140 --> 00:12:38,590
enumeration the compiler will put the

00:12:34,780 --> 00:12:40,300
array values in the correct order that

00:12:38,590 --> 00:12:41,710
solves all the problems I had I had no

00:12:40,300 --> 00:12:44,880
long I have to care about the values of

00:12:41,710 --> 00:12:46,900
my enums and I can sort them I'm happy

00:12:44,880 --> 00:12:49,660
the syntax for this is very simple

00:12:46,900 --> 00:12:51,610
really you just use these square

00:12:49,660 --> 00:12:53,890
brackets with the index and assign it a

00:12:51,610 --> 00:12:57,670
value the values you do not mention are

00:12:53,890 --> 00:13:00,460
set to zero if you have a value that

00:12:57,670 --> 00:13:02,320
follows one of these with an index it

00:13:00,460 --> 00:13:05,200
just gets the next index so 24 is so

00:13:02,320 --> 00:13:06,550
sign to index 3 and we can even omit the

00:13:05,200 --> 00:13:07,900
size of the array because it can be

00:13:06,550 --> 00:13:11,050
deduced from the biggest index that we

00:13:07,900 --> 00:13:15,370
specified and so naturally this array

00:13:11,050 --> 00:13:18,550
here has size 7 because 11 here gets the

00:13:15,370 --> 00:13:19,750
index 6 and the order of those indices

00:13:18,550 --> 00:13:23,260
of course does met otherwise our

00:13:19,750 --> 00:13:25,940
previous example would broke but wait

00:13:23,260 --> 00:13:28,570
there's more I think we all know

00:13:25,940 --> 00:13:32,030
how to create an array of zeros right

00:13:28,570 --> 00:13:35,480
that's trivial but what if I need an

00:13:32,030 --> 00:13:36,890
array of ones from baby for a Cindy mask

00:13:35,480 --> 00:13:40,850
or something like that

00:13:36,890 --> 00:13:44,090
I just have to spell it out and I hope I

00:13:40,850 --> 00:13:46,280
don't scrub because one is missing my

00:13:44,090 --> 00:13:49,280
last value zero have you noticed how

00:13:46,280 --> 00:13:50,780
long took it till you did so of course

00:13:49,280 --> 00:13:52,460
we can combine this with something

00:13:50,780 --> 00:13:54,290
better but that we've seen before and

00:13:52,460 --> 00:13:57,740
could use similar syntax as in case

00:13:54,290 --> 00:13:59,630
ranges now for indices so again left and

00:13:57,740 --> 00:14:00,910
try to inclusive and we assigned the

00:13:59,630 --> 00:14:03,800
same value to all of these values

00:14:00,910 --> 00:14:05,510
indices and we can also meet the size

00:14:03,800 --> 00:14:09,200
again because we have we can deduce it

00:14:05,510 --> 00:14:10,660
from the biggest index and we can mix

00:14:09,200 --> 00:14:13,400
and match those as much as we want

00:14:10,660 --> 00:14:14,930
there's only one restriction both the

00:14:13,400 --> 00:14:18,080
index and the value have to be constant

00:14:14,930 --> 00:14:21,350
expressions and that's it so here

00:14:18,080 --> 00:14:24,380
naturally the F has to be constant and

00:14:21,350 --> 00:14:26,720
it gets assigned to index 3 and the

00:14:24,380 --> 00:14:32,120
hundred here gets the index 8 and the

00:14:26,720 --> 00:14:35,420
array in total is 21 elements so

00:14:32,120 --> 00:14:37,970
speaking of a race to explain the next

00:14:35,420 --> 00:14:39,140
one I would have I have to dig a bit

00:14:37,970 --> 00:14:41,780
through the language and try to

00:14:39,140 --> 00:14:46,210
implement something that will be down a

00:14:41,780 --> 00:14:50,600
pain path of pain imagine the following

00:14:46,210 --> 00:14:52,580
many virtual machines or scripting

00:14:50,600 --> 00:14:55,010
languages or systems like that have

00:14:52,580 --> 00:14:56,720
immutable strings so those are strings

00:14:55,010 --> 00:14:58,160
once they create it they cannot be

00:14:56,720 --> 00:15:00,860
changed in size they cannot change in

00:14:58,160 --> 00:15:03,410
content and so because strings are used

00:15:00,860 --> 00:15:04,970
a lot which these implementers of these

00:15:03,410 --> 00:15:07,580
virtual machines try to make them as

00:15:04,970 --> 00:15:09,410
quick and as accessible as possible and

00:15:07,580 --> 00:15:10,640
many times also put in a hash table so

00:15:09,410 --> 00:15:11,750
you don't have to placate strings in

00:15:10,640 --> 00:15:13,460
your system because then a string

00:15:11,750 --> 00:15:14,900
comparison is just a pointer comparison

00:15:13,460 --> 00:15:17,270
which is a lot quicker than comparing

00:15:14,900 --> 00:15:19,100
strings then they probably garbage

00:15:17,270 --> 00:15:21,650
collected or reference counted or

00:15:19,100 --> 00:15:24,320
something like that and so I want

00:15:21,650 --> 00:15:25,670
something like a share point of a vector

00:15:24,320 --> 00:15:29,300
of something okay I'm gonna generalize

00:15:25,670 --> 00:15:31,840
this to not just strings if you create

00:15:29,300 --> 00:15:34,400
something like this in C++ we get a

00:15:31,840 --> 00:15:36,020
memory layer to do something like this

00:15:34,400 --> 00:15:38,720
they each block represents its own

00:15:36,020 --> 00:15:39,710
allocation we have the control block

00:15:38,720 --> 00:15:41,120
here which contain

00:15:39,710 --> 00:15:42,410
of the reference counting in the

00:15:41,120 --> 00:15:44,510
internal bookkeeping of the share

00:15:42,410 --> 00:15:48,050
pointer that is something internal that

00:15:44,510 --> 00:15:50,180
we don't have access to and I think it

00:15:48,050 --> 00:15:51,320
should be common knowledge now that with

00:15:50,180 --> 00:15:54,110
make sure we can fuse those two

00:15:51,320 --> 00:15:56,210
locations into one but I want to go even

00:15:54,110 --> 00:15:58,790
further I want everything in one

00:15:56,210 --> 00:16:01,760
allocation because the size of the data

00:15:58,790 --> 00:16:03,650
doesn't change but I do not want this

00:16:01,760 --> 00:16:05,510
indirection I do not want access to this

00:16:03,650 --> 00:16:07,250
something that then has a pointer that

00:16:05,510 --> 00:16:10,130
points to the data I want to go a

00:16:07,250 --> 00:16:14,510
pointer to the Container just a constant

00:16:10,130 --> 00:16:16,930
offset and find the data what could be

00:16:14,510 --> 00:16:18,770
used for this what's the question mark

00:16:16,930 --> 00:16:23,180
but there's nothing in the standard

00:16:18,770 --> 00:16:24,410
library can you tell that but there's

00:16:23,180 --> 00:16:26,270
something in boost it could help us you

00:16:24,410 --> 00:16:30,500
boost as a container called static

00:16:26,270 --> 00:16:33,650
vector you give it a template constant

00:16:30,500 --> 00:16:36,410
integer and it call it's going to create

00:16:33,650 --> 00:16:38,870
a buffer for this number of T's inside

00:16:36,410 --> 00:16:40,640
itself so it's kind of useful because

00:16:38,870 --> 00:16:42,470
once we have a pointer to the static

00:16:40,640 --> 00:16:44,120
vector we know exactly what to do to

00:16:42,470 --> 00:16:46,820
just get to the data because it's right

00:16:44,120 --> 00:16:49,240
next to it so we do not have an

00:16:46,820 --> 00:16:51,530
indirection that's great

00:16:49,240 --> 00:16:54,290
but the fixed capacity is a problem

00:16:51,530 --> 00:16:56,390
because if we create less than n

00:16:54,290 --> 00:16:59,180
elements we gonna waste memory if you

00:16:56,390 --> 00:17:02,780
create more well we can't because it's a

00:16:59,180 --> 00:17:04,520
fixed capacity it cannot grow well

00:17:02,780 --> 00:17:06,320
there's another container that works in

00:17:04,520 --> 00:17:09,470
a similar fashion it has the same

00:17:06,320 --> 00:17:11,089
starting position so again no

00:17:09,470 --> 00:17:15,170
indirection if our size of the container

00:17:11,089 --> 00:17:16,790
is not more than n but as soon as we

00:17:15,170 --> 00:17:20,690
grow beyond n it's gonna just turn into

00:17:16,790 --> 00:17:23,060
a normal vector and again have an extra

00:17:20,690 --> 00:17:25,100
direction and we are also wasting all

00:17:23,060 --> 00:17:26,510
this memory here because the vector is

00:17:25,100 --> 00:17:27,709
to store all it's a tiny contiguous

00:17:26,510 --> 00:17:32,210
block you cannot just split it in half

00:17:27,709 --> 00:17:35,180
so what do you do when Oh buddy ass off

00:17:32,210 --> 00:17:39,140
the problem yet you do it yourself and

00:17:35,180 --> 00:17:40,820
let's try to do just that imagine here a

00:17:39,140 --> 00:17:43,430
visualization well you don't have to

00:17:40,820 --> 00:17:45,980
imagine it you can just see it I guess a

00:17:43,430 --> 00:17:47,420
visualization of our memory allocation

00:17:45,980 --> 00:17:49,250
right on the far left is the lowest

00:17:47,420 --> 00:17:51,500
address of our block of memory and just

00:17:49,250 --> 00:17:53,720
keeps growing as much as we need well it

00:17:51,500 --> 00:17:57,110
doesn't prove dynamically

00:17:53,720 --> 00:17:58,820
rated ones we also have this thing that

00:17:57,110 --> 00:18:00,080
represents the question marks the thing

00:17:58,820 --> 00:18:02,299
that we interact with that has a known

00:18:00,080 --> 00:18:04,460
type unknown size we know where it is we

00:18:02,299 --> 00:18:05,210
have a pointer to it it is the T in our

00:18:04,460 --> 00:18:06,710
set pointer

00:18:05,210 --> 00:18:10,010
I'm just going to call it a header here

00:18:06,710 --> 00:18:11,630
and it knows how many how many elements

00:18:10,010 --> 00:18:15,020
there are I can ask you to give me a

00:18:11,630 --> 00:18:16,309
integrator to the data and so on the

00:18:15,020 --> 00:18:18,470
layout in memory would look something

00:18:16,309 --> 00:18:20,210
like this I have my header structure at

00:18:18,470 --> 00:18:22,669
the very beginning and then just an

00:18:20,210 --> 00:18:26,090
array of data in this case I'm going to

00:18:22,669 --> 00:18:27,260
demonstrate it using doubles to create

00:18:26,090 --> 00:18:28,730
this we need to know how many pints

00:18:27,260 --> 00:18:30,409
bytes to allocate and that is kind of

00:18:28,730 --> 00:18:33,350
straightforward we have the size of the

00:18:30,409 --> 00:18:35,419
header and then enough space for n

00:18:33,350 --> 00:18:37,010
elements and then here is a runtime

00:18:35,419 --> 00:18:38,860
value you do not know it at compile time

00:18:37,010 --> 00:18:43,030
that's the assumption you're making here

00:18:38,860 --> 00:18:46,340
then of course I just allocate bytes I

00:18:43,030 --> 00:18:49,309
construct the head object I construct

00:18:46,340 --> 00:18:53,080
your right and then later down the line

00:18:49,309 --> 00:18:56,919
I'm gonna just use the data right and

00:18:53,080 --> 00:19:01,190
then you do this two things may one

00:18:56,919 --> 00:19:02,990
works fine cool and the other is you're

00:19:01,190 --> 00:19:04,490
gonna crash with righteous fury because

00:19:02,990 --> 00:19:09,320
you dare to it unaligned loads and

00:19:04,490 --> 00:19:12,110
stores because many architectures where

00:19:09,320 --> 00:19:13,460
I guess most of them require that your

00:19:12,110 --> 00:19:16,220
doubles are aligned on an eight by

00:19:13,460 --> 00:19:19,730
boundary if you run an arm that is your

00:19:16,220 --> 00:19:22,700
world that is the reality on an x86 it's

00:19:19,730 --> 00:19:23,960
kind of optional so it depends on what

00:19:22,700 --> 00:19:26,510
instructions your compiler is going to

00:19:23,960 --> 00:19:28,909
generate if it generates unaligned lots

00:19:26,510 --> 00:19:30,230
and story is fine however if you also

00:19:28,909 --> 00:19:31,880
want to support order our CPU

00:19:30,230 --> 00:19:33,740
architectures it can be up to two to ten

00:19:31,880 --> 00:19:36,919
times slower to iterate through this

00:19:33,740 --> 00:19:38,320
array if it's not aligned and if your

00:19:36,919 --> 00:19:44,870
compiler decide to use aligned

00:19:38,320 --> 00:19:46,460
instructions well just go home so to fix

00:19:44,870 --> 00:19:48,020
this we need to sound add some kind of

00:19:46,460 --> 00:19:49,490
padding behind the header to make sure

00:19:48,020 --> 00:19:52,610
that our double is aligned on an eight

00:19:49,490 --> 00:19:55,580
byte boundary which looks like we just

00:19:52,610 --> 00:19:58,220
need some kind of offset like the size

00:19:55,580 --> 00:20:00,080
of the double but okay double is the

00:19:58,220 --> 00:20:01,850
example here but it may not be a double

00:20:00,080 --> 00:20:06,110
so really we want the alignment of the

00:20:01,850 --> 00:20:07,100
type but if you now add something to our

00:20:06,110 --> 00:20:09,860
header it's

00:20:07,100 --> 00:20:11,780
may grow beyond that of a double so

00:20:09,860 --> 00:20:15,080
began I had overlapping data structures

00:20:11,780 --> 00:20:17,210
and they just yeah don't go there so

00:20:15,080 --> 00:20:18,880
let's try again we know that we need at

00:20:17,210 --> 00:20:20,990
least in our files to store one header

00:20:18,880 --> 00:20:23,960
we need at least enough bytes to store

00:20:20,990 --> 00:20:28,789
on alignment then we need at least one

00:20:23,960 --> 00:20:35,929
less bite we divide by the alignment of

00:20:28,789 --> 00:20:38,600
the table okay and then we what okay so

00:20:35,929 --> 00:20:40,429
if you do not know this pattern this is

00:20:38,600 --> 00:20:42,409
how you round up a positive integer to

00:20:40,429 --> 00:20:44,659
the nearest multiple of another this

00:20:42,409 --> 00:20:46,669
here is a integer division that rounds

00:20:44,659 --> 00:20:48,770
up instead of down which is the default

00:20:46,669 --> 00:20:50,210
for positive numbers and then with the

00:20:48,770 --> 00:20:52,760
multiplication we can then turn this

00:20:50,210 --> 00:20:55,039
into a rounding up towards the multiple

00:20:52,760 --> 00:20:57,559
of another integer of course we could

00:20:55,039 --> 00:20:59,419
use some bit twiddling tricks because we

00:20:57,559 --> 00:21:02,539
know the alignment is a power of two but

00:20:59,419 --> 00:21:05,240
it happens at compile time who cares so

00:21:02,539 --> 00:21:07,580
we have this X now you're gonna plug it

00:21:05,240 --> 00:21:13,940
into the code we had before and

00:21:07,580 --> 00:21:16,520
everything's fine except it's not this

00:21:13,940 --> 00:21:20,330
one line okay this one line this one

00:21:16,520 --> 00:21:23,030
innocuous line is a massive massive

00:21:20,330 --> 00:21:27,320
troll by the community it's in who's

00:21:23,030 --> 00:21:28,820
gonna drive you crazy it's like you know

00:21:27,320 --> 00:21:30,710
sometimes this line just works sometimes

00:21:28,820 --> 00:21:32,720
it doesn't sometimes gonna crash your

00:21:30,710 --> 00:21:34,900
program sometimes about seven it's gonna

00:21:32,720 --> 00:21:37,850
corrupt your memory sometimes it won't

00:21:34,900 --> 00:21:39,409
you just connect angry right angry at

00:21:37,850 --> 00:21:41,390
yourself because you think you don't

00:21:39,409 --> 00:21:42,650
understand this one damn line of code

00:21:41,390 --> 00:21:45,409
that's so obvious it couldn't be more

00:21:42,650 --> 00:21:46,730
obvious what it does and then you get

00:21:45,409 --> 00:21:48,380
just angry at the compiler because I

00:21:46,730 --> 00:21:51,500
think it's breaking your code but no

00:21:48,380 --> 00:21:52,760
it's just doing its job you just got C++

00:21:51,500 --> 00:21:53,270
why are doing this to me I thought we

00:21:52,760 --> 00:21:57,440
were friends

00:21:53,270 --> 00:21:59,919
no no we are not friends no no I think

00:21:57,440 --> 00:22:02,480
you just get sad

00:21:59,919 --> 00:22:04,370
you realize this there is no code at the

00:22:02,480 --> 00:22:05,510
end of the rainbow the pot is full of

00:22:04,370 --> 00:22:09,010
crap and you just have to carry it

00:22:05,510 --> 00:22:11,919
around with you because let me tell you

00:22:09,010 --> 00:22:15,799
this is why the committee hates you

00:22:11,919 --> 00:22:17,750
let's have a look surely at working

00:22:15,799 --> 00:22:20,490
draft comma standard for programming

00:22:17,750 --> 00:22:23,130
language C++ section x4

00:22:20,490 --> 00:22:25,020
don't new paragraph 19 and there's also

00:22:23,130 --> 00:22:28,410
a link as evidence if you want to verify

00:22:25,020 --> 00:22:31,740
yourself you look at this section and

00:22:28,410 --> 00:22:34,280
come across this it explains how the

00:22:31,740 --> 00:22:36,270
array expression with arguments is

00:22:34,280 --> 00:22:38,820
converted into a call to an allocation

00:22:36,270 --> 00:22:42,210
function which is also called operate on

00:22:38,820 --> 00:22:44,010
you because sure I know so it shows that

00:22:42,210 --> 00:22:46,290
here you have these two parameters that

00:22:44,010 --> 00:22:47,940
get passed into this operator and they

00:22:46,290 --> 00:22:50,040
just get appended at the end of this

00:22:47,940 --> 00:22:51,450
education function and then overall

00:22:50,040 --> 00:22:54,030
resolution is going to pick the best

00:22:51,450 --> 00:22:56,550
match this is what we do every time we

00:22:54,030 --> 00:22:57,660
use placement new where we have this

00:22:56,550 --> 00:23:00,090
pointer where we want to place our

00:22:57,660 --> 00:23:02,160
object and then it resolves to the built

00:23:00,090 --> 00:23:07,220
in allocation function that does nothing

00:23:02,160 --> 00:23:11,460
essentially except do you see what I see

00:23:07,220 --> 00:23:14,100
what is this who is this X where's it

00:23:11,460 --> 00:23:19,080
come from do you see it in your

00:23:14,100 --> 00:23:21,330
rendering expression on my plant well so

00:23:19,080 --> 00:23:23,910
you'll keep reading on and you come

00:23:21,330 --> 00:23:29,640
across this lovely paragraph so let me

00:23:23,910 --> 00:23:33,980
read to you a horror story here each

00:23:29,640 --> 00:23:36,750
instance of X non-negative and specified

00:23:33,980 --> 00:23:39,570
value representing array allocation

00:23:36,750 --> 00:23:41,700
overhead the result of the new

00:23:39,570 --> 00:23:44,210
expression will be offset by this amount

00:23:41,700 --> 00:23:47,600
from the value returned by operator new

00:23:44,210 --> 00:23:50,060
this overhead may be applied in all

00:23:47,600 --> 00:23:52,530
Iranian subjects new expressions

00:23:50,060 --> 00:23:54,900
including those referencing the library

00:23:52,530 --> 00:23:57,150
function operator new with the signature

00:23:54,900 --> 00:23:59,390
that we are usually calling in this case

00:23:57,150 --> 00:24:02,280
and other placement allocation functions

00:23:59,390 --> 00:24:05,570
the amount of overhead may vary from one

00:24:02,280 --> 00:24:05,570
invocation of new to another

00:24:07,760 --> 00:24:15,030
what the hell is this let if you don't

00:24:13,320 --> 00:24:16,590
understand the code that the language is

00:24:15,030 --> 00:24:17,580
written in or specified in let me

00:24:16,590 --> 00:24:20,370
summarize okay

00:24:17,580 --> 00:24:22,020
they say non-negative value that is

00:24:20,370 --> 00:24:23,580
added by the compiler every time you

00:24:22,020 --> 00:24:26,700
call an array new expression in the

00:24:23,580 --> 00:24:28,950
array form and this value made may vary

00:24:26,700 --> 00:24:31,110
from one new call to the other and you

00:24:28,950 --> 00:24:33,240
don't know the value there is no way to

00:24:31,110 --> 00:24:36,660
carry this value in advance you don't

00:24:33,240 --> 00:24:38,670
know it and so if this one one single

00:24:36,660 --> 00:24:42,330
message from this talk that you keep

00:24:38,670 --> 00:24:44,010
this is the serious part never ever for

00:24:42,330 --> 00:24:46,140
whatever reason use the array new

00:24:44,010 --> 00:24:49,740
placement version of the built-in

00:24:46,140 --> 00:24:52,620
operator just don't it will corrupt you

00:24:49,740 --> 00:24:54,660
memory it will corrupt your stack it's a

00:24:52,620 --> 00:24:56,850
door for attackers because there is no

00:24:54,660 --> 00:24:58,740
guarantee that you can actually create a

00:24:56,850 --> 00:25:00,450
buffer that is guaranteed hundred

00:24:58,740 --> 00:25:04,860
percent big enough to hold the result of

00:25:00,450 --> 00:25:07,370
this expression there is not so if you

00:25:04,860 --> 00:25:11,970
like me you're thinking this right now

00:25:07,370 --> 00:25:13,860
and really it's those moments where we

00:25:11,970 --> 00:25:18,360
realize the committee is just out to see

00:25:13,860 --> 00:25:21,120
you suffer because they strive on

00:25:18,360 --> 00:25:24,060
ultimate despair so let's see if we can

00:25:21,120 --> 00:25:27,720
salvage this we know the problematic

00:25:24,060 --> 00:25:30,060
line and we do have a solution kind of

00:25:27,720 --> 00:25:33,210
which is in C++ 17 we have the

00:25:30,060 --> 00:25:34,890
uninitialized algorithms so in this case

00:25:33,210 --> 00:25:37,470
you can use initialize default construct

00:25:34,890 --> 00:25:39,960
n it takes a forward iterator and a

00:25:37,470 --> 00:25:41,280
number and it's going to construct an

00:25:39,960 --> 00:25:43,920
object at every position that the

00:25:41,280 --> 00:25:45,660
iterator points to and this is another

00:25:43,920 --> 00:25:48,120
thing I'm like what the hell is this

00:25:45,660 --> 00:25:49,890
because think about it this algorithm

00:25:48,120 --> 00:25:52,920
gives an uninitialized wrong

00:25:49,890 --> 00:25:55,040
storage and yet we have to give it an

00:25:52,920 --> 00:25:59,790
iterator to objects that don't exist yet

00:25:55,040 --> 00:26:02,300
what the hell who designed this evil

00:25:59,790 --> 00:26:04,650
people did that's the answer

00:26:02,300 --> 00:26:06,330
well it is what it is

00:26:04,650 --> 00:26:07,590
but there's one thing I still don't like

00:26:06,330 --> 00:26:11,070
about this right you have this buffer

00:26:07,590 --> 00:26:13,260
here so if we imagine that this is like

00:26:11,070 --> 00:26:13,950
capsulated in a factory function or

00:26:13,260 --> 00:26:15,990
something like that

00:26:13,950 --> 00:26:17,760
then we only really want to return the P

00:26:15,990 --> 00:26:19,920
the pointer to the header the thing that

00:26:17,760 --> 00:26:21,380
we're actually interacting with so we

00:26:19,920 --> 00:26:24,290
need to base everything

00:26:21,380 --> 00:26:24,710
off of this pointer P which is easy

00:26:24,290 --> 00:26:26,450
right

00:26:24,710 --> 00:26:28,700
just turn it into a point of the bytes

00:26:26,450 --> 00:26:31,510
at the offset turn it back into a point

00:26:28,700 --> 00:26:34,940
of doubles and we're good

00:26:31,510 --> 00:26:36,950
fortunately you're not because again you

00:26:34,940 --> 00:26:38,530
think you know what you're doing you

00:26:36,950 --> 00:26:40,880
think your programming against the cpu

00:26:38,530 --> 00:26:42,890
but you're not you're programming

00:26:40,880 --> 00:26:44,210
against the abstract machine in the

00:26:42,890 --> 00:26:45,830
abstract machine you can just take any

00:26:44,210 --> 00:26:48,650
arbitrary pointer add some number to it

00:26:45,830 --> 00:26:52,910
and say professor Pablo because the

00:26:48,650 --> 00:26:56,330
compiler knows that this pointer has

00:26:52,910 --> 00:26:58,400
been created from one single allocation

00:26:56,330 --> 00:27:00,800
it knows that it doesn't point to more

00:26:58,400 --> 00:27:05,420
than one thing and that's why you cannot

00:27:00,800 --> 00:27:08,120
do this and that's that's that's a trap

00:27:05,420 --> 00:27:09,320
that well I mean this reinterpret cast

00:27:08,120 --> 00:27:12,200
all over the place you know that

00:27:09,320 --> 00:27:13,910
something's wrong but this is one of the

00:27:12,200 --> 00:27:15,500
things that many people remain - it's a

00:27:13,910 --> 00:27:18,230
big source of a different behavior traps

00:27:15,500 --> 00:27:19,640
and it's just you know this conception

00:27:18,230 --> 00:27:21,740
that you're not writing

00:27:19,640 --> 00:27:25,970
you're not programming the CPU you're

00:27:21,740 --> 00:27:28,850
programming the compiler so we have to

00:27:25,970 --> 00:27:30,500
do let's just store the buffer pointer

00:27:28,850 --> 00:27:32,060
because that is actually something that

00:27:30,500 --> 00:27:36,950
has allocated storage for other things

00:27:32,060 --> 00:27:38,510
and so we can use that as our starting

00:27:36,950 --> 00:27:42,220
position for the reinterpret cast and

00:27:38,510 --> 00:27:46,310
this short work big emphasis on should

00:27:42,220 --> 00:27:47,860
because P is something or buffer is

00:27:46,310 --> 00:27:49,730
something that is actually part of the

00:27:47,860 --> 00:27:54,290
allocation and constructing chain of

00:27:49,730 --> 00:27:57,800
those doubles so are we good now who

00:27:54,290 --> 00:28:00,770
think that this is all it is wrong it's

00:27:57,800 --> 00:28:02,270
more in fact this entire thing it's just

00:28:00,770 --> 00:28:02,950
it's just on different behavior cut just

00:28:02,270 --> 00:28:06,860
throw it away

00:28:02,950 --> 00:28:09,080
because see you're trying to treat this

00:28:06,860 --> 00:28:12,500
pointer as if it was an array but it's

00:28:09,080 --> 00:28:13,970
not you have never created an array the

00:28:12,500 --> 00:28:16,220
way initialize default construct is

00:28:13,970 --> 00:28:18,830
specified it is just places objects

00:28:16,220 --> 00:28:20,180
individually somewhere in this case they

00:28:18,830 --> 00:28:21,770
just happen to be next to each other in

00:28:20,180 --> 00:28:24,220
memory but that does not make them an

00:28:21,770 --> 00:28:26,510
array that's not how the language works

00:28:24,220 --> 00:28:28,750
it's how the rest of the world works but

00:28:26,510 --> 00:28:32,360
not the language

00:28:28,750 --> 00:28:33,800
so yeah index zero sure that reference

00:28:32,360 --> 00:28:36,800
is the double that was created there

00:28:33,800 --> 00:28:41,090
this dereference is the past the end

00:28:36,800 --> 00:28:47,030
iterator and this is just just garbage

00:28:41,090 --> 00:28:49,670
it's nothing so really really yeah

00:28:47,030 --> 00:28:53,090
unfortunately I believe that there is no

00:28:49,670 --> 00:28:57,190
way to implement this in standard C++ in

00:28:53,090 --> 00:28:59,570
in the efficient way that I wanted I

00:28:57,190 --> 00:29:01,910
challenge you to find a way that doesn't

00:28:59,570 --> 00:29:03,590
have any undefined behavior I would like

00:29:01,910 --> 00:29:06,440
to see it but I don't think there is one

00:29:03,590 --> 00:29:08,120
and so if the standard doesn't help us

00:29:06,440 --> 00:29:09,830
they just throw it out the window and

00:29:08,120 --> 00:29:13,310
create our own rules which is what the

00:29:09,830 --> 00:29:16,280
people at GCC did so we start again with

00:29:13,310 --> 00:29:18,140
our header structure and this time we

00:29:16,280 --> 00:29:19,340
are going to add an unsigned array and

00:29:18,140 --> 00:29:21,830
this is the thing that is called a

00:29:19,340 --> 00:29:24,680
flexible array member it is an array

00:29:21,830 --> 00:29:27,650
with outer size and this instructs the

00:29:24,680 --> 00:29:29,630
compiler to alter the alignment and the

00:29:27,650 --> 00:29:31,010
size of the structure in a way that we

00:29:29,630 --> 00:29:33,620
can use it exactly for the purpose that

00:29:31,010 --> 00:29:34,700
we wanted to use it's almost as if it

00:29:33,620 --> 00:29:37,760
was created just for that

00:29:34,700 --> 00:29:39,650
and now our intuition holds now we can

00:29:37,760 --> 00:29:42,170
count the number of bytes the way we

00:29:39,650 --> 00:29:44,720
wanted to now it works to just allocate

00:29:42,170 --> 00:29:48,100
this array now it works to just place

00:29:44,720 --> 00:29:52,610
menu this header now it works to just

00:29:48,100 --> 00:29:53,990
construct these doubles because when we

00:29:52,610 --> 00:29:56,870
access the thing now we're actually

00:29:53,990 --> 00:29:58,640
accessing it through an array object the

00:29:56,870 --> 00:30:00,980
compiler knows what we want to do the

00:29:58,640 --> 00:30:03,800
compiler knows that there is an array

00:30:00,980 --> 00:30:05,360
following the structure and don't be

00:30:03,800 --> 00:30:07,340
alarmed by this thing in this truck

00:30:05,360 --> 00:30:08,900
right this this is just symbolic data

00:30:07,340 --> 00:30:10,760
does not occupy any space in the

00:30:08,900 --> 00:30:12,920
structure it only instructs the compiler

00:30:10,760 --> 00:30:15,320
to do some point arithmetic to access

00:30:12,920 --> 00:30:17,300
the first element distracts the size of

00:30:15,320 --> 00:30:20,900
this head is still 8 there is no pointer

00:30:17,300 --> 00:30:22,580
in there or anything so we have the

00:30:20,900 --> 00:30:25,970
solution we of course should clean up

00:30:22,580 --> 00:30:28,070
after ourselves just use smart pointers

00:30:25,970 --> 00:30:29,900
which I it shows not to to demonstrate

00:30:28,070 --> 00:30:31,730
what's going on here you can move that

00:30:29,900 --> 00:30:33,860
in destructors and constructors and so

00:30:31,730 --> 00:30:36,470
on I'm sure you can figure out how to do

00:30:33,860 --> 00:30:39,110
that what we haven't solved yet is the

00:30:36,470 --> 00:30:41,480
sharepoint apart and unfortunately we

00:30:39,110 --> 00:30:42,410
can't go further there because we don't

00:30:41,480 --> 00:30:44,150
have access to

00:30:42,410 --> 00:30:46,790
the type that share pointer uses for its

00:30:44,150 --> 00:30:48,350
internal bookkeeping I would really like

00:30:46,790 --> 00:30:50,660
to just you know slap the thing at the

00:30:48,350 --> 00:30:52,070
front of the buffer here and construct

00:30:50,660 --> 00:30:54,380
the share pointer with a pointer to this

00:30:52,070 --> 00:30:56,000
control block and tell it hey here it is

00:30:54,380 --> 00:30:58,670
take ownership it's not used you manage

00:30:56,000 --> 00:31:00,320
it with Reb common everything but we

00:30:58,670 --> 00:31:03,560
can't we have to implement it ourselves

00:31:00,320 --> 00:31:05,600
I won't go into that here but a useful

00:31:03,560 --> 00:31:07,850
tool to look for here is boost intrusive

00:31:05,600 --> 00:31:10,780
pointer it's very useful and it gonna

00:31:07,850 --> 00:31:10,780
make your life a lot easier

00:31:10,810 --> 00:31:19,670
well that's so far it for a race let's

00:31:15,890 --> 00:31:20,960
go to something new and this is the part

00:31:19,670 --> 00:31:22,250
where either gonna hate me or love me

00:31:20,960 --> 00:31:23,900
because it's going to use a language

00:31:22,250 --> 00:31:28,400
feature that people either hate or laugh

00:31:23,900 --> 00:31:30,730
or love to hate and for this example I

00:31:28,400 --> 00:31:33,260
have created a like a very trivial

00:31:30,730 --> 00:31:35,870
bytecode language that should consist of

00:31:33,260 --> 00:31:38,030
these op codes and it is very simple

00:31:35,870 --> 00:31:40,910
each instruction just takes the current

00:31:38,030 --> 00:31:42,500
value and does an arithmetic operation

00:31:40,910 --> 00:31:45,710
with the constant right that's all there

00:31:42,500 --> 00:31:48,770
is to it and an interpreter foil is also

00:31:45,710 --> 00:31:51,890
very trivial tube right and it's just a

00:31:48,770 --> 00:31:53,450
switch inside a for loop it always it

00:31:51,890 --> 00:31:54,950
reads the instruction and advances the

00:31:53,450 --> 00:31:56,390
point and execute the action that is

00:31:54,950 --> 00:31:59,300
associated with this instruction right

00:31:56,390 --> 00:32:02,690
so the add one here is literally just

00:31:59,300 --> 00:32:04,550
creating this action and when we reach

00:32:02,690 --> 00:32:08,120
the hot code we just return the value

00:32:04,550 --> 00:32:10,850
that we've computed okay I've been

00:32:08,120 --> 00:32:12,950
chucked this and this is mostly just for

00:32:10,850 --> 00:32:14,600
reference so what I did is just create a

00:32:12,950 --> 00:32:16,340
uniform distribution of all these op

00:32:14,600 --> 00:32:18,410
courts except for the halt code because

00:32:16,340 --> 00:32:20,510
I want my benchmark that she run to all

00:32:18,410 --> 00:32:23,810
the way to the end and then I slap a

00:32:20,510 --> 00:32:26,330
halt at the end to make it terminate so

00:32:23,810 --> 00:32:29,060
you run this you get some numbers out of

00:32:26,330 --> 00:32:32,930
it they don't really matter for now but

00:32:29,060 --> 00:32:36,110
what does matter is this do you believe

00:32:32,930 --> 00:32:37,460
that you can make this faster do you

00:32:36,110 --> 00:32:39,500
think that you can refactor a switch

00:32:37,460 --> 00:32:41,990
inside a loop that is so trivial and

00:32:39,500 --> 00:32:43,850
still make it faster because that's what

00:32:41,990 --> 00:32:49,010
I did and we have the numbers for it

00:32:43,850 --> 00:32:50,480
here and here is the speed-up so let's

00:32:49,010 --> 00:32:52,400
throw away the first one because it's an

00:32:50,480 --> 00:32:55,790
outlier but for the rest of the cases

00:32:52,400 --> 00:33:00,050
you have on average 15% fast execution

00:32:55,790 --> 00:33:01,790
doing the same thing and the way we do

00:33:00,050 --> 00:33:04,880
it you can see it in the name of the

00:33:01,790 --> 00:33:05,870
benchmark it involves go to which is

00:33:04,880 --> 00:33:06,980
also where this feature is called

00:33:05,870 --> 00:33:09,320
computer code

00:33:06,980 --> 00:33:12,680
I think we all know for how go-to works

00:33:09,320 --> 00:33:15,650
right that the body of this function is

00:33:12,680 --> 00:33:18,590
just a for loop but what we can do now

00:33:15,650 --> 00:33:22,730
what's new is that we can take the

00:33:18,590 --> 00:33:25,190
address of a label using these double

00:33:22,730 --> 00:33:28,220
ampersands we can store the address of a

00:33:25,190 --> 00:33:34,010
label in a variable and later you can

00:33:28,220 --> 00:33:41,330
jump to that address those are good

00:33:34,010 --> 00:33:43,430
reactions in so notice that technically

00:33:41,330 --> 00:33:45,530
yeah it looks like we'd be referencing a

00:33:43,430 --> 00:33:48,440
void pointer which we cannot do which

00:33:45,530 --> 00:33:49,940
why I say that this asterisk is part of

00:33:48,440 --> 00:33:52,520
the go-to it belongs together it should

00:33:49,940 --> 00:33:54,560
be treated as one keyword and you also

00:33:52,520 --> 00:33:57,220
cannot refactor this object or function

00:33:54,560 --> 00:33:59,690
the asterisk has to be with the goal and

00:33:57,220 --> 00:34:03,290
this enables something that we've never

00:33:59,690 --> 00:34:05,330
had we can now write indirect jumps that

00:34:03,290 --> 00:34:07,970
is a privilege that up until now has

00:34:05,330 --> 00:34:09,440
been reserved solely for the compiler we

00:34:07,970 --> 00:34:11,919
have always able to do indirect calls

00:34:09,440 --> 00:34:14,419
with function pointers but this is new

00:34:11,919 --> 00:34:16,129
because now we can create jump tables

00:34:14,419 --> 00:34:19,610
that are just as efficient as the ones

00:34:16,129 --> 00:34:22,159
by the compiler we can use a dynamic

00:34:19,610 --> 00:34:24,280
index to access an array of labels and

00:34:22,159 --> 00:34:27,919
then jump to one determined at run time

00:34:24,280 --> 00:34:29,300
and I mean yeah so far this is only been

00:34:27,919 --> 00:34:33,590
C so he can make the array constructs

00:34:29,300 --> 00:34:34,970
bridges because you know but the thing

00:34:33,590 --> 00:34:36,620
is you know notice that we are just

00:34:34,970 --> 00:34:41,889
jumping to a void pointer there is no

00:34:36,620 --> 00:34:44,179
specific type for label addresses so an

00:34:41,889 --> 00:34:45,649
evil person or a very clever person

00:34:44,179 --> 00:34:48,020
depends how you see it

00:34:45,649 --> 00:34:49,669
could just pass a void pointer that is

00:34:48,020 --> 00:34:51,260
the address of a label in one function

00:34:49,669 --> 00:34:53,000
to another function and then have that

00:34:51,260 --> 00:34:54,470
function jump to that label so you would

00:34:53,000 --> 00:34:55,610
have control program from the middle of

00:34:54,470 --> 00:34:58,130
one function to the middle of the

00:34:55,610 --> 00:35:01,280
another function and that is where food

00:34:58,130 --> 00:35:03,140
cans look like toys but maybe it's

00:35:01,280 --> 00:35:07,310
useful to someone if they manage to not

00:35:03,140 --> 00:35:09,020
break everything so let's see how we

00:35:07,310 --> 00:35:10,940
have way now this is

00:35:09,020 --> 00:35:13,580
this is the tool I use but now how did I

00:35:10,940 --> 00:35:15,470
actually apply it so I did very volatile

00:35:13,580 --> 00:35:18,410
things to my route

00:35:15,470 --> 00:35:21,650
in fact the loop is gone so I create

00:35:18,410 --> 00:35:23,420
this table of this jump table full of

00:35:21,650 --> 00:35:25,460
the addresses of labels every

00:35:23,420 --> 00:35:27,200
instruction has and label associated

00:35:25,460 --> 00:35:29,300
with it and the rest of the function

00:35:27,200 --> 00:35:31,940
just has lots of labels each label

00:35:29,300 --> 00:35:33,830
execute the instruction and then does

00:35:31,940 --> 00:35:36,320
the same as the top of the switch did it

00:35:33,830 --> 00:35:38,840
decodes the next instruction and jumps

00:35:36,320 --> 00:35:42,350
to that entry in the ROM table so we

00:35:38,840 --> 00:35:44,630
have a lot more labels like this you

00:35:42,350 --> 00:35:46,930
also f1 go to at the top so we know what

00:35:44,630 --> 00:35:49,880
the first instruction is to jump to and

00:35:46,930 --> 00:35:53,090
because I hate repeating myself I just

00:35:49,880 --> 00:35:55,700
put it in a lambda and this is again the

00:35:53,090 --> 00:35:58,480
point where you cannot put the asterisk

00:35:55,700 --> 00:36:01,580
away from the go-to it has to be there

00:35:58,480 --> 00:36:05,330
so this is the how but it doesn't

00:36:01,580 --> 00:36:07,310
explain the why why is this faster there

00:36:05,330 --> 00:36:10,130
is no loop there is no switch and this

00:36:07,310 --> 00:36:12,860
is also sometimes called threaded jumps

00:36:10,130 --> 00:36:14,270
because it essentially you're jumping

00:36:12,860 --> 00:36:15,859
from case to case to case the case

00:36:14,270 --> 00:36:18,140
you're not going through the top at the

00:36:15,859 --> 00:36:19,990
switch so to understand why this is

00:36:18,140 --> 00:36:22,430
faster let's have a look at the assembly

00:36:19,990 --> 00:36:24,470
this is the simplified version of the

00:36:22,430 --> 00:36:26,900
switch if you see the top two

00:36:24,470 --> 00:36:28,130
instructions here they just read the

00:36:26,900 --> 00:36:31,550
next instruction increment the pointer

00:36:28,130 --> 00:36:33,830
right and then we have the jump and we

00:36:31,550 --> 00:36:36,020
see that it has this operand a register

00:36:33,830 --> 00:36:38,630
so the destination of this jump depends

00:36:36,020 --> 00:36:40,130
on a runtime value and it can go any one

00:36:38,630 --> 00:36:44,810
of these labels which are representative

00:36:40,130 --> 00:36:46,340
of the cases then if others jumps they

00:36:44,810 --> 00:36:49,490
just go back to the top those are the

00:36:46,340 --> 00:36:53,090
breaks in the case let's compare this to

00:36:49,490 --> 00:36:55,160
the go-to and for first we see there's a

00:36:53,090 --> 00:36:58,250
lot more code and in fact this function

00:36:55,160 --> 00:36:59,810
is about 20% bigger than the other but

00:36:58,250 --> 00:37:01,490
there's a lot of repetition here right

00:36:59,810 --> 00:37:03,320
those blocks already really different

00:37:01,490 --> 00:37:04,880
the top line which is the arithmetic

00:37:03,320 --> 00:37:07,430
operation that we encoded in our

00:37:04,880 --> 00:37:09,650
instruction set and the rest is

00:37:07,430 --> 00:37:12,980
character for character identical for

00:37:09,650 --> 00:37:14,630
every block in fact it is almost a

00:37:12,980 --> 00:37:17,180
drink'll to what the compiler created

00:37:14,630 --> 00:37:19,190
with the switch with the only difference

00:37:17,180 --> 00:37:22,080
the compiler he generated its own jump

00:37:19,190 --> 00:37:23,640
table whereas we brought one ourselves

00:37:22,080 --> 00:37:26,100
so the compiler already had the right

00:37:23,640 --> 00:37:29,850
idea if you get out the case goes from 0

00:37:26,100 --> 00:37:33,660
to n contiguity contiguous and it can

00:37:29,850 --> 00:37:38,000
implement this with the jump table but

00:37:33,660 --> 00:37:40,080
it's not fast enough so the jumps here

00:37:38,000 --> 00:37:43,290
pretty much the same as in the other

00:37:40,080 --> 00:37:45,660
example and they cannot jump to

00:37:43,290 --> 00:37:46,890
everywhere and these are indirect jumps

00:37:45,660 --> 00:37:49,050
right that's why the arrows I read

00:37:46,890 --> 00:37:51,960
because indirect jumps are generally bad

00:37:49,050 --> 00:37:53,550
for the CPU because complicated

00:37:51,960 --> 00:37:56,240
architecture reason asked Network board

00:37:53,550 --> 00:37:58,800
he tell you everything about it

00:37:56,240 --> 00:37:59,910
but so the first intuition would have is

00:37:58,800 --> 00:38:01,080
you know I have a lot more indirect

00:37:59,910 --> 00:38:02,310
jumps it looks like it should be slower

00:38:01,080 --> 00:38:05,670
to see if you should have a harder time

00:38:02,310 --> 00:38:08,850
predicting these jumps so to explain why

00:38:05,670 --> 00:38:10,380
this works let me first summarize what

00:38:08,850 --> 00:38:11,970
actually happens before I go into the

00:38:10,380 --> 00:38:13,920
why so if none of this assembly

00:38:11,970 --> 00:38:16,080
mumbo-jumbo actually means anything to

00:38:13,920 --> 00:38:19,980
you this is the explanation of what's

00:38:16,080 --> 00:38:23,580
going on the CPU has recognized patterns

00:38:19,980 --> 00:38:25,890
in my randomly generated input let that

00:38:23,580 --> 00:38:28,440
sink in the CPU can analyze my data

00:38:25,890 --> 00:38:31,830
that's randomly generated and find

00:38:28,440 --> 00:38:32,310
patterns in it to understand how that

00:38:31,830 --> 00:38:34,170
works

00:38:32,310 --> 00:38:36,720
let's have a look at a much simplified

00:38:34,170 --> 00:38:39,600
example so now we reduce our

00:38:36,720 --> 00:38:41,880
instructions at only two values a and B

00:38:39,600 --> 00:38:44,420
and we produce an input that is

00:38:41,880 --> 00:38:46,950
alternating between a and B forever

00:38:44,420 --> 00:38:48,060
we also have the reduced implementation

00:38:46,950 --> 00:38:50,700
that only deals with these two bar

00:38:48,060 --> 00:38:54,180
labels and if you look at what's going

00:38:50,700 --> 00:38:56,400
on here now we have we see that this one

00:38:54,180 --> 00:39:00,180
jump here has a 50-50 chance to go

00:38:56,400 --> 00:39:03,090
either to an A or B so what happens from

00:39:00,180 --> 00:39:05,130
this abuse perspective here is it starts

00:39:03,090 --> 00:39:08,940
its season a said ok we're gonna jump to

00:39:05,130 --> 00:39:11,400
da then the next sits it thinks well I

00:39:08,940 --> 00:39:16,590
just went away so clearly gonna go to a

00:39:11,400 --> 00:39:19,050
again but no B alright next well I just

00:39:16,590 --> 00:39:21,770
want to be so clearly B is the most

00:39:19,050 --> 00:39:24,690
likely next candidate not wrong it's a

00:39:21,770 --> 00:39:27,840
next one come on now I've jumped to a

00:39:24,690 --> 00:39:30,140
twice ok B only once clearly a is the

00:39:27,840 --> 00:39:32,940
winner here not you're wrong it's V now

00:39:30,140 --> 00:39:36,960
so we have a 0% branch prediction right

00:39:32,940 --> 00:39:38,490
here now it is not 100% true because

00:39:36,960 --> 00:39:40,650
some CPUs can actually detect this

00:39:38,490 --> 00:39:42,390
specific pattern but it depends on your

00:39:40,650 --> 00:39:44,730
architecture it depends on the model and

00:39:42,390 --> 00:39:46,140
everything so in the general case if you

00:39:44,730 --> 00:39:48,030
chip you is not able to predict this

00:39:46,140 --> 00:39:50,130
kind of alternating pattern this is

00:39:48,030 --> 00:39:53,130
what's gonna happen well it's in the

00:39:50,130 --> 00:39:55,440
other case it's a lot easier we know

00:39:53,130 --> 00:39:58,860
100% that every a is followed by and B

00:39:55,440 --> 00:40:00,870
and we know that every a every B is

00:39:58,860 --> 00:40:03,260
always followed by an A so here the

00:40:00,870 --> 00:40:08,730
prediction rate is 100% every time and

00:40:03,260 --> 00:40:10,110
it's a huge speed-up of course the

00:40:08,730 --> 00:40:13,110
numbers that I showed you where just for

00:40:10,110 --> 00:40:14,910
this you know toy language so let me

00:40:13,110 --> 00:40:18,480
show you a real application of this

00:40:14,910 --> 00:40:20,520
I chose Lua for this which is a very

00:40:18,480 --> 00:40:22,170
widespread scripting language and it is

00:40:20,520 --> 00:40:24,330
also an interpreted language it is not

00:40:22,170 --> 00:40:28,530
computer compiled to bytecode to machine

00:40:24,330 --> 00:40:32,760
code it is implemented in C and it also

00:40:28,530 --> 00:40:35,040
has this switch inside a loop and the

00:40:32,760 --> 00:40:38,070
creators of were actually smart enough

00:40:35,040 --> 00:40:40,230
to create macros that let you modify the

00:40:38,070 --> 00:40:42,780
beginning of the loop the switch the

00:40:40,230 --> 00:40:45,210
case and the break so we can change how

00:40:42,780 --> 00:40:47,250
the main core interpreter loop actually

00:40:45,210 --> 00:40:50,160
works which is exactly what I did

00:40:47,250 --> 00:40:52,920
so I compile two versions of Lua one

00:40:50,160 --> 00:40:55,320
with a switch one with a go to and I ran

00:40:52,920 --> 00:40:56,910
a benchmark on it seemed our course I'm

00:40:55,320 --> 00:40:59,070
mark I'm not sure but it's a popular

00:40:56,910 --> 00:41:00,690
benchmark that is used to make Lua

00:40:59,070 --> 00:41:03,630
implementation compete against each

00:41:00,690 --> 00:41:05,280
other the real the numbers we only need

00:41:03,630 --> 00:41:08,220
to care about other ones on the left

00:41:05,280 --> 00:41:10,860
which show the average mega flops per

00:41:08,220 --> 00:41:12,960
second then we also have numbers for the

00:41:10,860 --> 00:41:18,450
go to and then we put them next to each

00:41:12,960 --> 00:41:20,520
other and this is this incredible speed

00:41:18,450 --> 00:41:23,940
of up to 41 percent depending on what

00:41:20,520 --> 00:41:26,010
you do the fast Fourier transform is

00:41:23,940 --> 00:41:27,300
very compute heavy so making an

00:41:26,010 --> 00:41:30,240
interpreter run faster won't really

00:41:27,300 --> 00:41:32,640
matter much and it doesn't because you

00:41:30,240 --> 00:41:33,990
compute bound but the Monte Carlo

00:41:32,640 --> 00:41:36,240
integration does a lot more of other

00:41:33,990 --> 00:41:38,520
things and speeding those up works and

00:41:36,240 --> 00:41:41,040
on average all the benchmarks together

00:41:38,520 --> 00:41:45,530
manage about 20% more mega flops per

00:41:41,040 --> 00:41:47,990
second and that is a huge win I mean and

00:41:45,530 --> 00:41:49,730
Rewa is not the own example so

00:41:47,990 --> 00:41:52,430
the people at C patent did this too and

00:41:49,730 --> 00:41:53,930
they noticed an up to fifteen fifteen to

00:41:52,430 --> 00:41:57,380
twenty percent speed-up of the virtual

00:41:53,930 --> 00:42:00,260
machine right this is performance lying

00:41:57,380 --> 00:42:02,420
on the floor you pretty much do this

00:42:00,260 --> 00:42:04,460
very mechanical transformation of you

00:42:02,420 --> 00:42:06,980
know code that can speed up all your

00:42:04,460 --> 00:42:10,520
Python programs by twenty percent that's

00:42:06,980 --> 00:42:16,490
insane and the committee does not want

00:42:10,520 --> 00:42:19,610
us to use it and rupee also uses this

00:42:16,490 --> 00:42:20,150
go-to and dharak the JVM on Android does

00:42:19,610 --> 00:42:23,630
this too

00:42:20,150 --> 00:42:29,470
so in the in the free world it is not a

00:42:23,630 --> 00:42:31,970
secret but in C++ it's it's it's guarded

00:42:29,470 --> 00:42:34,520
so I've just showed you lots of things

00:42:31,970 --> 00:42:37,490
that you you know you technically cannot

00:42:34,520 --> 00:42:39,530
use and I've been told by committee

00:42:37,490 --> 00:42:45,860
agents in this building that they don't

00:42:39,530 --> 00:42:47,960
exist but if you leave the bubble of the

00:42:45,860 --> 00:42:49,820
committee you realize that a lot of

00:42:47,960 --> 00:42:51,680
compilers actually do support them these

00:42:49,820 --> 00:42:55,220
are the oldest compiler versions that I

00:42:51,680 --> 00:42:56,960
contest on compiler Explorer and in fact

00:42:55,220 --> 00:43:00,770
the youngest compiler on this list is

00:42:56,960 --> 00:43:05,060
from 2012 though if you are on Windows

00:43:00,770 --> 00:43:07,220
it's kind of you know Microsoft with a

00:43:05,060 --> 00:43:09,200
big conformance Porsche that just did

00:43:07,220 --> 00:43:11,000
they just don't want to oppose the

00:43:09,200 --> 00:43:12,560
committee anymore it's just you know yes

00:43:11,000 --> 00:43:17,180
yes we do as you say

00:43:12,560 --> 00:43:19,480
but and you're not a corporate drone

00:43:17,180 --> 00:43:26,030
you're just gonna use prank on Windows

00:43:19,480 --> 00:43:28,570
problem solve right okay so now let's

00:43:26,030 --> 00:43:32,390
let's let's go back to serious mode

00:43:28,570 --> 00:43:33,700
because it's all the fun and the left

00:43:32,390 --> 00:43:37,400
and everything in the jokes

00:43:33,700 --> 00:43:40,280
this matter is real because you know

00:43:37,400 --> 00:43:41,510
there's the C++ slack you know if you

00:43:40,280 --> 00:43:43,910
know it and I'm one of the

00:43:41,510 --> 00:43:46,400
administration administrators of this

00:43:43,910 --> 00:43:48,950
slack and one of the agents of the

00:43:46,400 --> 00:43:52,160
company approached me there they came to

00:43:48,950 --> 00:43:53,770
my turf and threatened me here's what

00:43:52,160 --> 00:43:56,490
happened

00:43:53,770 --> 00:43:59,950
they asked me do you see me as the enemy

00:43:56,490 --> 00:44:06,550
duh one your French and your nature of

00:43:59,950 --> 00:44:07,750
the community so I said that they're

00:44:06,550 --> 00:44:08,290
French because actually you know who

00:44:07,750 --> 00:44:10,630
this is

00:44:08,290 --> 00:44:12,490
so I did a bit of a mind trick career so

00:44:10,630 --> 00:44:15,400
I let them know that I know so that they

00:44:12,490 --> 00:44:17,740
know I know you know and then they say

00:44:15,400 --> 00:44:21,490
well you know if I were an agent of the

00:44:17,740 --> 00:44:23,470
community I might declare up in you B of

00:44:21,490 --> 00:44:24,369
course that's what committee members do

00:44:23,470 --> 00:44:25,900
you know if they don't like something

00:44:24,369 --> 00:44:28,950
they call it undefined behavior just

00:44:25,900 --> 00:44:32,470
stops existing problem solved

00:44:28,950 --> 00:44:34,720
so I already assumed as much but the

00:44:32,470 --> 00:44:37,180
next thing they said that actually that

00:44:34,720 --> 00:44:39,790
blew my mind and it should Rose used to

00:44:37,180 --> 00:44:41,170
because they said allowing me to

00:44:39,790 --> 00:44:45,210
optimize your existence are very

00:44:41,170 --> 00:44:47,710
attractive think about what this means

00:44:45,210 --> 00:44:49,059
this agent of the committee has just

00:44:47,710 --> 00:44:53,319
openly admitted that the committee is

00:44:49,059 --> 00:44:54,400
access to time travel technology you

00:44:53,319 --> 00:44:55,990
know the next time you see a

00:44:54,400 --> 00:44:57,970
conversation between a committee member

00:44:55,990 --> 00:44:59,619
and a normal person and the normal

00:44:57,970 --> 00:45:01,299
person says something like well you know

00:44:59,619 --> 00:45:03,280
I don't like this part of the language

00:45:01,299 --> 00:45:05,079
and this is so this is dangerous can we

00:45:03,280 --> 00:45:07,569
change this and remove that what is the

00:45:05,079 --> 00:45:11,400
canned response well it'll only be at

00:45:07,569 --> 00:45:11,400
the time machine code may contain things

00:45:15,990 --> 00:45:21,970
so I hope that you are now as

00:45:18,970 --> 00:45:24,609
enlightened as me that you understand

00:45:21,970 --> 00:45:26,500
the danger you're facing here because if

00:45:24,609 --> 00:45:27,430
you thought that you Minotti a bet just

00:45:26,500 --> 00:45:29,380
think about this you have this

00:45:27,430 --> 00:45:31,329
multinational organization backed by

00:45:29,380 --> 00:45:33,010
governments backed by our text money

00:45:31,329 --> 00:45:34,540
that has access to time travel

00:45:33,010 --> 00:45:38,230
technology that is controlling all of

00:45:34,540 --> 00:45:39,609
C++ everything even this laptop here so

00:45:38,230 --> 00:45:41,349
you think this is Windows just gonna

00:45:39,609 --> 00:45:43,420
lose Linux and open mrs. her but it's

00:45:41,349 --> 00:45:46,329
see it's the same thing they all working

00:45:43,420 --> 00:45:48,280
together you can't escape it so you have

00:45:46,329 --> 00:45:50,530
to fight it and so I hope that you will

00:45:48,280 --> 00:45:52,930
join me on the rebellion of the free

00:45:50,530 --> 00:45:57,910
thinking C++ programmers and crush the

00:45:52,930 --> 00:46:00,400
tyranny of the committee and you know

00:45:57,910 --> 00:46:02,980
I'm really glad that all of you in fact

00:46:00,400 --> 00:46:04,599
stayed all the way to the end I know

00:46:02,980 --> 00:46:06,430
that I may have come across a bit crazy

00:46:04,599 --> 00:46:12,270
at times I'm not crazy

00:46:06,430 --> 00:46:15,849
I'm not crazy don't call me crazy but

00:46:12,270 --> 00:46:21,280
now that the truth is out I can finally

00:46:15,849 --> 00:46:25,960
stop living in fear and that's it

00:46:21,280 --> 00:46:29,170
[Applause]

00:46:25,960 --> 00:46:29,170
[Music]

00:46:32,250 --> 00:46:37,869
so if you have any questions please

00:46:34,570 --> 00:46:40,570
gather at the microphone oh yeah look at

00:46:37,869 --> 00:46:43,800
them this is what I'm Reba this is what

00:46:40,570 --> 00:46:48,369
an evil person looks like yeah

00:46:43,800 --> 00:46:52,119
maybe I haven't evil suggestion or

00:46:48,369 --> 00:46:54,520
hiding your name place the question is

00:46:52,119 --> 00:46:56,770
wouldn't that be a big chance for better

00:46:54,520 --> 00:46:59,200
optimizes through to translate form

00:46:56,770 --> 00:47:01,690
these switches to the mechanics that you

00:46:59,200 --> 00:47:03,190
explained with the computer I asked

00:47:01,690 --> 00:47:05,920
myself the to and in fact when I gave

00:47:03,190 --> 00:47:08,830
this in meetup in the munich meter one

00:47:05,920 --> 00:47:11,110
attendee said that some compilers do it

00:47:08,830 --> 00:47:13,000
on arm but i don't understand why i

00:47:11,110 --> 00:47:14,260
clang OGC don't do it on their own maybe

00:47:13,000 --> 00:47:15,850
there are trade-offs that I'm not aware

00:47:14,260 --> 00:47:18,400
of because it also does increase

00:47:15,850 --> 00:47:20,950
actually your size of the function so I

00:47:18,400 --> 00:47:23,350
don't know why they don't do it but they

00:47:20,950 --> 00:47:25,390
should if they can have you figured out

00:47:23,350 --> 00:47:28,810
all the options of the optimizer that

00:47:25,390 --> 00:47:32,700
you might be able to set how many other

00:47:28,810 --> 00:47:34,990
again I don't know I never try those but

00:47:32,700 --> 00:47:37,300
maybe it's already implemented

00:47:34,990 --> 00:47:38,770
nobody knows yeah yeah good question to

00:47:37,300 --> 00:47:40,950
ask someone else at this conference I

00:47:38,770 --> 00:47:40,950
guess

00:47:46,040 --> 00:47:56,020
I'm a bit conflicted because I look

00:47:50,119 --> 00:47:58,880
after GCC so the side of my t-shirt the

00:47:56,020 --> 00:48:00,440
the reasoned compiled it doesn't do that

00:47:58,880 --> 00:48:03,170
switch expansions you might have

00:48:00,440 --> 00:48:04,970
expected I think is probably because the

00:48:03,170 --> 00:48:10,400
actual switch code generation happens

00:48:04,970 --> 00:48:11,420
much later in the compiler than it could

00:48:10,400 --> 00:48:13,700
make that decision

00:48:11,420 --> 00:48:15,109
okay that's unfortunately white and we

00:48:13,700 --> 00:48:16,400
also have and we have the labels

00:48:15,109 --> 00:48:20,200
extension and everybody writes their

00:48:16,400 --> 00:48:20,200
code exactly how you described it so

00:48:22,660 --> 00:48:28,970
it's got that extension to now it's not

00:48:27,740 --> 00:48:33,740
undefined behavior

00:48:28,970 --> 00:48:36,470
it's ill-formed which of the many slides

00:48:33,740 --> 00:48:39,380
ahead I think all of the all of the

00:48:36,470 --> 00:48:42,440
slides were ill formed and what you're

00:48:39,380 --> 00:48:47,059
relying on a vendor extensions except

00:48:42,440 --> 00:48:49,309
that once where they didn't most of the

00:48:47,059 --> 00:48:50,809
flexible array code on the slide was not

00:48:49,309 --> 00:48:54,740
a relying on extensions that was full of

00:48:50,809 --> 00:48:57,079
undefined behavior instead the the way

00:48:54,740 --> 00:48:59,390
you showed it yeah with with the

00:48:57,079 --> 00:49:01,220
flexible array as a vendor extent sure

00:48:59,390 --> 00:49:04,940
with the flexible array but everything

00:49:01,220 --> 00:49:07,010
before that okay all right oh yes I had

00:49:04,940 --> 00:49:08,020
to thought about that one okay if you

00:49:07,010 --> 00:49:11,599
could go back to that slide

00:49:08,020 --> 00:49:13,040
you mean this the slide where you

00:49:11,599 --> 00:49:16,520
actually had the flexible of RAM you had

00:49:13,040 --> 00:49:19,400
the destructor in the header okay that's

00:49:16,520 --> 00:49:20,660
this that one you could put the

00:49:19,400 --> 00:49:22,460
constructor in the header and put the

00:49:20,660 --> 00:49:24,109
uninitialized default construct in that

00:49:22,460 --> 00:49:27,200
constructor I did mention that you could

00:49:24,109 --> 00:49:32,990
put things in and make it look a bit

00:49:27,200 --> 00:49:37,220
neater yeah yeah I agree I have a

00:49:32,990 --> 00:49:40,190
question about slide nine which was the

00:49:37,220 --> 00:49:42,829
anonymous struct you mentioned that a

00:49:40,190 --> 00:49:44,480
committee member would say that there's

00:49:42,829 --> 00:49:47,809
undefined behavior and I was wondering

00:49:44,480 --> 00:49:49,970
where this one yeah yeah so the

00:49:47,809 --> 00:49:51,230
undefined behavior comes but one okay

00:49:49,970 --> 00:49:52,849
it's actually in form because if the

00:49:51,230 --> 00:49:54,799
structure but even if it had destructed

00:49:52,849 --> 00:49:57,079
a name and the field name will be

00:49:54,799 --> 00:49:58,430
undefined behavior because an array in a

00:49:57,079 --> 00:50:02,660
struct don't have a comment

00:49:58,430 --> 00:50:07,369
common initial sequence why not because

00:50:02,660 --> 00:50:10,099
it doesn't i-i've looked at the standard

00:50:07,369 --> 00:50:13,130
and I confirmed with another agent here

00:50:10,099 --> 00:50:14,750
that in fact whenever the standard talks

00:50:13,130 --> 00:50:16,609
about common initial sequence it is

00:50:14,750 --> 00:50:21,680
between arrays or between classes but

00:50:16,609 --> 00:50:23,710
never across okay okay I think that's

00:50:21,680 --> 00:50:25,010
the best answer I have I don't know why

00:50:23,710 --> 00:50:28,099
hi

00:50:25,010 --> 00:50:37,460
I just wonder how did you discover all

00:50:28,099 --> 00:50:39,650
those Easter eggs in the language well

00:50:37,460 --> 00:50:40,970
some of them I just by accident just I

00:50:39,650 --> 00:50:42,920
happen to read about them and then I

00:50:40,970 --> 00:50:45,770
thought I maybe there are more I should

00:50:42,920 --> 00:50:48,980
make a talk about it so I did and they I

00:50:45,770 --> 00:50:50,510
in fact many more but the majority of

00:50:48,980 --> 00:50:52,700
them only really applied to see and are

00:50:50,510 --> 00:50:54,470
obsolete in C++ so yeah what I didn't

00:50:52,700 --> 00:50:57,200
mention a lot of these extensions are

00:50:54,470 --> 00:51:02,089
actually for made for C 99 but you can

00:50:57,200 --> 00:51:04,670
use them in C++ mode thank you now

00:51:02,089 --> 00:51:06,109
there's another one remember his face so

00:51:04,670 --> 00:51:07,549
apart from the fact that all the stuff

00:51:06,109 --> 00:51:10,640
either is on different behavior or

00:51:07,549 --> 00:51:12,500
doesn't exist some of it sounds like

00:51:10,640 --> 00:51:15,400
it's a very good idea and obviously if

00:51:12,500 --> 00:51:17,839
you also have existing practice and

00:51:15,400 --> 00:51:21,380
implementation experience so one know

00:51:17,839 --> 00:51:23,000
why a lot of these things either have

00:51:21,380 --> 00:51:24,319
not been proposed for the standard or

00:51:23,000 --> 00:51:26,299
have been rejected by the committee

00:51:24,319 --> 00:51:28,880
somewhere in the distant past do you

00:51:26,299 --> 00:51:31,010
know anything about kind of so I about

00:51:28,880 --> 00:51:33,230
two things what I didn't show a

00:51:31,010 --> 00:51:35,930
variable-length erase those there was a

00:51:33,230 --> 00:51:37,520
petition to declassify those but the

00:51:35,930 --> 00:51:41,299
committee decided that we are not

00:51:37,520 --> 00:51:43,700
prepared for that kind of power and they

00:51:41,299 --> 00:51:46,549
were I think in Cologne there was a

00:51:43,700 --> 00:51:48,529
paper discussed about flexible remembers

00:51:46,549 --> 00:51:50,089
by Nicole massacre but I think the

00:51:48,529 --> 00:51:52,059
conclusion there was because they did

00:51:50,089 --> 00:51:55,940
also change some things they added more

00:51:52,059 --> 00:51:57,829
C++ lifetime semantics to it and so they

00:51:55,940 --> 00:52:01,039
asked for implementation proof of

00:51:57,829 --> 00:52:02,270
concert implementation that's the one

00:52:01,039 --> 00:52:04,099
only the two I know I don't know if

00:52:02,270 --> 00:52:05,420
others were proposed before that yeah

00:52:04,099 --> 00:52:07,700
maybe we should dig a little bit in

00:52:05,420 --> 00:52:09,529
history and you know maybe some of them

00:52:07,700 --> 00:52:12,049
can be either resurrected or just never

00:52:09,529 --> 00:52:17,809
have been proposed maybe

00:52:12,049 --> 00:52:19,460
yeah okay that's it then thank you all

00:52:17,809 --> 00:52:23,920
for coming and this

00:52:19,460 --> 00:52:23,920

YouTube URL: https://www.youtube.com/watch?v=IAdLwUXRUvg


