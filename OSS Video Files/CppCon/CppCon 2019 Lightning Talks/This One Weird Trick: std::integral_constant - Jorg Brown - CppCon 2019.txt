Title: This One Weird Trick: std::integral_constant - Jorg Brown - CppCon 2019
Publication date: 2019-10-23
Playlist: CppCon 2019 Lightning Talks
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,290 --> 00:00:11,200
right hello and welcome no lightning

00:00:10,300 --> 00:00:13,210
talks

00:00:11,200 --> 00:00:14,980
my talk is called this one weird trick

00:00:13,210 --> 00:00:16,330
stood in a real constant now if you're

00:00:14,980 --> 00:00:18,430
like me when you first saw this in

00:00:16,330 --> 00:00:20,200
standard library you thought what is the

00:00:18,430 --> 00:00:21,939
point all this is a template class that

00:00:20,200 --> 00:00:24,160
has next to nothing in it what can I do

00:00:21,939 --> 00:00:25,930
with it I'm here to tell you the proper

00:00:24,160 --> 00:00:29,590
question to ask is what can't you do

00:00:25,930 --> 00:00:31,990
with it let's take a simple example this

00:00:29,590 --> 00:00:33,790
is without interval constant this is

00:00:31,990 --> 00:00:36,010
Fibonacci routine is declared contacts

00:00:33,790 --> 00:00:38,890
per however this if you actually run it

00:00:36,010 --> 00:00:40,390
will take quite a long time this is one

00:00:38,890 --> 00:00:42,070
a few functions like computing Fibonacci

00:00:40,390 --> 00:00:45,040
this white will take order of Fibonacci

00:00:42,070 --> 00:00:46,449
time the reason is that concept or

00:00:45,040 --> 00:00:48,699
function isn't actually going to be in

00:00:46,449 --> 00:00:53,170
line well let's say I wanted to force it

00:00:48,699 --> 00:00:57,280
to be in line absolutely for sure I'm

00:00:53,170 --> 00:00:58,989
stuck closer this is good sorry all

00:00:57,280 --> 00:01:00,909
right so now let's do the same thing

00:00:58,989 --> 00:01:02,470
same exact algorithm except this time

00:01:00,909 --> 00:01:04,900
around we're going to use contacts burn

00:01:02,470 --> 00:01:07,030
and we're going to use an auto return

00:01:04,900 --> 00:01:09,130
type which allows us to take the return

00:01:07,030 --> 00:01:11,380
type of the function and put the value

00:01:09,130 --> 00:01:17,380
that we trying to compute in the return

00:01:11,380 --> 00:01:19,600
type by doing this we make sure that it

00:01:17,380 --> 00:01:21,399
sits partly because it's templated but

00:01:19,600 --> 00:01:23,680
bolts because values in the type we can

00:01:21,399 --> 00:01:26,320
actually force this to be memorized this

00:01:23,680 --> 00:01:29,140
is compiles fast and runs immediately

00:01:26,320 --> 00:01:31,570
however if you're compiling for debug or

00:01:29,140 --> 00:01:33,189
with inline functions turned off this

00:01:31,570 --> 00:01:36,070
still actually makes one function call

00:01:33,189 --> 00:01:37,539
let's fix that instead of calling the

00:01:36,070 --> 00:01:39,039
function we'll just called echo type in

00:01:37,539 --> 00:01:41,770
it say well what type would you return

00:01:39,039 --> 00:01:43,570
if I did call you that's gonna be the

00:01:41,770 --> 00:01:45,579
real content we can pick kong-kong value

00:01:43,570 --> 00:01:48,429
out of it this is no function calls

00:01:45,579 --> 00:01:52,060
whatsoever even when all debugging or

00:01:48,429 --> 00:01:55,270
all optimizations are off let's go to

00:01:52,060 --> 00:01:58,270
something else we firstly stood in real

00:01:55,270 --> 00:02:00,999
cons to do overload resolution so let's

00:01:58,270 --> 00:02:03,189
say one map the integers 0 1 & 2 2 the

00:02:00,999 --> 00:02:04,929
types in long and double we have these

00:02:03,189 --> 00:02:06,609
three overloads this type map into

00:02:04,929 --> 00:02:08,530
function and then we just use this using

00:02:06,609 --> 00:02:10,539
declaration to say well what would the

00:02:08,530 --> 00:02:13,090
deckle type be if I pass to this

00:02:10,539 --> 00:02:15,730
particular select integer to this

00:02:13,090 --> 00:02:17,110
routine and that will be either in long

00:02:15,730 --> 00:02:18,670
or double depending on what I put

00:02:17,110 --> 00:02:21,940
whether I pass 0 1 or 2 we can actually

00:02:18,670 --> 00:02:23,650
make this general let's make a little

00:02:21,940 --> 00:02:24,730
class that all it does is have that

00:02:23,650 --> 00:02:28,180
function for one

00:02:24,730 --> 00:02:30,250
Hiller integer and type then let's make

00:02:28,180 --> 00:02:33,670
a collection of these takes a number of

00:02:30,250 --> 00:02:36,250
indices and a number of types and it

00:02:33,670 --> 00:02:38,920
just goes through and using using

00:02:36,250 --> 00:02:43,239
declarations picks the appropriate

00:02:38,920 --> 00:02:44,620
overload will actually make a little

00:02:43,239 --> 00:02:46,660
using declaration just like we did

00:02:44,620 --> 00:02:50,739
before will automatically instantiate

00:02:46,660 --> 00:02:54,700
the type map will then call it function

00:02:50,739 --> 00:02:56,079
get the deckle type of it and finally

00:02:54,700 --> 00:02:59,190
this is actually what it looks like you

00:02:56,079 --> 00:03:05,519
do map into type two in long double

00:02:59,190 --> 00:03:08,319
returns double go for another example

00:03:05,519 --> 00:03:11,500
you can even overload on collections of

00:03:08,319 --> 00:03:13,569
integral constant so this interesting

00:03:11,500 --> 00:03:17,140
function here fine same type when you

00:03:13,569 --> 00:03:18,760
pass an initializer list if all of the

00:03:17,140 --> 00:03:21,819
types that you're passing are exactly

00:03:18,760 --> 00:03:23,410
the same then the compiler will think of

00:03:21,819 --> 00:03:25,599
what you're passing as an initial idlers

00:03:23,410 --> 00:03:27,569
initializer list of that type and fine

00:03:25,599 --> 00:03:29,739
same type will return that type

00:03:27,569 --> 00:03:31,630
otherwise in this case we'll just say

00:03:29,739 --> 00:03:34,120
we'll overlook for initializer list of

00:03:31,630 --> 00:03:36,760
size T and so as long as the things in

00:03:34,120 --> 00:03:38,410
the initial list can be cast to size T

00:03:36,760 --> 00:03:42,760
then that's the overloads gonna return

00:03:38,410 --> 00:03:45,790
see how it uses this so we'll make this

00:03:42,760 --> 00:03:47,500
function get common size and what's

00:03:45,790 --> 00:03:50,230
gonna do is call fine same type

00:03:47,500 --> 00:03:52,989
withstood at a little constant of all of

00:03:50,230 --> 00:03:57,519
the template size T's in this case that

00:03:52,989 --> 00:03:59,680
get common size was instantiated with so

00:03:57,519 --> 00:04:01,450
we take that collection pass define same

00:03:59,680 --> 00:04:04,180
type and then look at the deco type of

00:04:01,450 --> 00:04:06,819
the type that comes back put that into

00:04:04,180 --> 00:04:09,280
same lease if constructs were to test if

00:04:06,819 --> 00:04:11,889
the return type was actually void if it

00:04:09,280 --> 00:04:14,290
was will return emptiness so this did

00:04:11,889 --> 00:04:16,810
optional will return empty otherwise

00:04:14,290 --> 00:04:21,699
will actually pick out the value from

00:04:16,810 --> 00:04:24,880
the stood interval constant type so for

00:04:21,699 --> 00:04:27,010
example an example main function in this

00:04:24,880 --> 00:04:30,789
case get common size instantiated 2

00:04:27,010 --> 00:04:33,669
comma 2 comma 2 will return an optional

00:04:30,789 --> 00:04:35,560
that's filled in with the value 2 if I

00:04:33,669 --> 00:04:38,700
pass to comma 2 comma 3 then the

00:04:35,560 --> 00:04:38,700
optional return would just be empty

00:04:38,800 --> 00:04:45,980
thank you

00:04:40,890 --> 00:04:45,980

YouTube URL: https://www.youtube.com/watch?v=MKes-sG3zAU


