Title: Generalised Double Dispatch - Barath Kannan - CppCon 2019
Publication date: 2019-10-23
Playlist: CppCon 2019 Lightning Talks
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,360 --> 00:00:10,390
Oh

00:00:14,260 --> 00:00:19,869
is generalize old dispatch de

00:00:16,270 --> 00:00:22,660
virtualization okay so how do you access

00:00:19,869 --> 00:00:24,520
the concrete type of a dynamic class one

00:00:22,660 --> 00:00:26,920
we can do it is with dynamic cast with a

00:00:24,520 --> 00:00:28,480
bunch of details checks but dynamic cast

00:00:26,920 --> 00:00:29,800
is pretty expensive usually in order of

00:00:28,480 --> 00:00:31,240
magnitude slower than a v-- table lookup

00:00:29,800 --> 00:00:34,900
there's a whole bunch of benchmarks

00:00:31,240 --> 00:00:36,520
about it go with them up so what is

00:00:34,900 --> 00:00:38,980
double dispatch double dispatch is a way

00:00:36,520 --> 00:00:40,300
to apply dynamic class of operations to

00:00:38,980 --> 00:00:42,550
a concrete set of types by their common

00:00:40,300 --> 00:00:43,840
interface so you have an intermediate

00:00:42,550 --> 00:00:45,340
class that can visit each of the

00:00:43,840 --> 00:00:47,379
concrete types of a given virtual base

00:00:45,340 --> 00:00:48,610
class and then each concrete type

00:00:47,379 --> 00:00:51,010
provides an equivalent implementation

00:00:48,610 --> 00:00:53,949
the positive is at all so here's an

00:00:51,010 --> 00:00:55,239
example you have a cat dog and mouse and

00:00:53,949 --> 00:00:56,860
you have an animal visitor that can

00:00:55,239 --> 00:01:00,580
visit each of these types you have a

00:00:56,860 --> 00:01:02,110
constable visitor and you have an animal

00:01:00,580 --> 00:01:04,720
that has some apply methods that can

00:01:02,110 --> 00:01:06,130
apply these visitor classes and then

00:01:04,720 --> 00:01:08,140
your actual concrete classes will have

00:01:06,130 --> 00:01:09,700
the implementations of these which then

00:01:08,140 --> 00:01:11,890
pass themselves into the visit function

00:01:09,700 --> 00:01:14,049
and because they're the concrete types

00:01:11,890 --> 00:01:16,150
they'll call particular methods and get

00:01:14,049 --> 00:01:19,990
this kind of two-way virtual table

00:01:16,150 --> 00:01:22,030
lookup so here's a example of a visit

00:01:19,990 --> 00:01:24,400
our signs a value for each different

00:01:22,030 --> 00:01:28,120
animal cats one dogs are two masses of

00:01:24,400 --> 00:01:29,950
three calls the visitor you call they

00:01:28,120 --> 00:01:33,550
you create a unique pointer to each of

00:01:29,950 --> 00:01:36,250
these you to a dog and you applied the

00:01:33,550 --> 00:01:37,300
visitor to it and you turn the value so

00:01:36,250 --> 00:01:40,990
this is the output you get about

00:01:37,300 --> 00:01:42,700
thousand lines of assembly turn on o3

00:01:40,990 --> 00:01:45,820
and it's like magic you return to

00:01:42,700 --> 00:01:47,710
because there's dog so the unique

00:01:45,820 --> 00:01:48,940
pointers it knows that you don't need

00:01:47,710 --> 00:01:51,730
the actual veter like like the

00:01:48,940 --> 00:01:53,740
allocation so I can get rid of the heap

00:01:51,730 --> 00:01:55,270
allocation it knows exactly what types

00:01:53,740 --> 00:01:57,490
they are so you get rid of the 2v table

00:01:55,270 --> 00:01:59,530
lookups and it knows that because all

00:01:57,490 --> 00:02:01,270
the V tables all the views couple cups

00:01:59,530 --> 00:02:06,510
already done it doesn't admit the V

00:02:01,270 --> 00:02:10,000
table pointers so you get returned to so

00:02:06,510 --> 00:02:11,110
wait so it can't take it so this can

00:02:10,000 --> 00:02:12,970
take advantage of the croisé ability to

00:02:11,110 --> 00:02:14,769
do virtualize the function call if all

00:02:12,970 --> 00:02:16,120
the types are known and it's easy or not

00:02:14,769 --> 00:02:17,470
miss cases when you're adding new type

00:02:16,120 --> 00:02:18,610
so you just add them to visitor if

00:02:17,470 --> 00:02:22,090
they're missing then you get compile

00:02:18,610 --> 00:02:24,069
error so let's generalize who we want to

00:02:22,090 --> 00:02:26,049
be able to declare new concrete classes

00:02:24,069 --> 00:02:27,580
with minimal overhead and you want to

00:02:26,049 --> 00:02:28,980
have minimal boilerplate code in the

00:02:27,580 --> 00:02:32,890
and visible classes and adding new types

00:02:28,980 --> 00:02:34,450
so we can do it on the CRT P so we got a

00:02:32,890 --> 00:02:36,970
visitor base for a particular vehicle

00:02:34,450 --> 00:02:38,470
type and then we've got a visit that we

00:02:36,970 --> 00:02:40,330
could which can visit some parameter

00:02:38,470 --> 00:02:43,330
pack of visible so in this case they'll

00:02:40,330 --> 00:02:44,860
be cat dog and mouse and the same for

00:02:43,330 --> 00:02:46,150
cons and then you have a visitor set

00:02:44,860 --> 00:02:48,370
that just kind of has its convenience

00:02:46,150 --> 00:02:49,690
method your our visible class is gonna

00:02:48,370 --> 00:02:51,730
use those visitor types defined the

00:02:49,690 --> 00:02:53,800
visitors and then define the apply

00:02:51,730 --> 00:02:55,360
method and then your actual

00:02:53,800 --> 00:02:57,340
implementation is going to be the CRT P

00:02:55,360 --> 00:02:59,290
thing that takes itself and then the

00:02:57,340 --> 00:03:01,870
virtual visit visitor base class and

00:02:59,290 --> 00:03:04,240
then cause the static cast to call the

00:03:01,870 --> 00:03:05,740
actual PI method so your actual

00:03:04,240 --> 00:03:07,750
application code now fits on one slide

00:03:05,740 --> 00:03:09,790
you've got this little thing where

00:03:07,750 --> 00:03:12,130
you've got my visitor set your animal is

00:03:09,790 --> 00:03:13,420
an ID visible of those and then your cat

00:03:12,130 --> 00:03:17,530
dog and mouse our visit was of

00:03:13,420 --> 00:03:19,030
themselves and the base class and then

00:03:17,530 --> 00:03:23,050
you get this really nice thing and the

00:03:19,030 --> 00:03:25,030
output is exactly the same turn - so

00:03:23,050 --> 00:03:26,380
this is nice but you still want some

00:03:25,030 --> 00:03:26,830
kind of analog to state visit and

00:03:26,380 --> 00:03:30,130
overload

00:03:26,830 --> 00:03:31,570
it's like eating that as so it's kind of

00:03:30,130 --> 00:03:32,860
community ride out you want to be able

00:03:31,570 --> 00:03:36,850
to use it with like I said of lambdas

00:03:32,860 --> 00:03:40,630
for your visit so we can do that with a

00:03:36,850 --> 00:03:41,739
bit of template recursive inheritance so

00:03:40,630 --> 00:03:45,550
we're gonna take a parameter pack of

00:03:41,739 --> 00:03:47,440
Cola bulls and they're going to pull out

00:03:45,550 --> 00:03:50,470
the function the argument that that call

00:03:47,440 --> 00:03:52,209
war takes using boost Coble traits do

00:03:50,470 --> 00:03:53,709
fine first argument and then reviews

00:03:52,209 --> 00:03:55,950
that to find out which particular visit

00:03:53,709 --> 00:03:58,120
we want to overload and then we take

00:03:55,950 --> 00:04:00,850
this thing is like a parameter pack we

00:03:58,120 --> 00:04:02,860
have a deduction guide because we need

00:04:00,850 --> 00:04:04,480
the virtual base class we need to know

00:04:02,860 --> 00:04:06,459
what visit type is so we take that using

00:04:04,480 --> 00:04:09,250
the identity visit type and we need to

00:04:06,459 --> 00:04:10,630
remove it from the touch base into the

00:04:09,250 --> 00:04:12,250
value space because we don't have

00:04:10,630 --> 00:04:14,769
partial deduction guards in C++ you know

00:04:12,250 --> 00:04:16,000
and then our base case of the

00:04:14,769 --> 00:04:18,280
inheritance looks kind of like this like

00:04:16,000 --> 00:04:22,630
you're just implementing the the actual

00:04:18,280 --> 00:04:23,680
virtual base class and then just because

00:04:22,630 --> 00:04:24,910
you don't wanna type out the identity

00:04:23,680 --> 00:04:28,000
type every time we get these little like

00:04:24,910 --> 00:04:29,610
convenience things and then we get code

00:04:28,000 --> 00:04:32,050
that looks like this

00:04:29,610 --> 00:04:34,330
so all this one slide you got something

00:04:32,050 --> 00:04:37,660
that looks really similar to visit with

00:04:34,330 --> 00:04:39,640
overloaded and without optimizations you

00:04:37,660 --> 00:04:42,629
get sixteen hundreds of assembly with

00:04:39,640 --> 00:04:44,790
optimizations you get two

00:04:42,629 --> 00:04:48,489
and that's it

00:04:44,790 --> 00:04:48,489

YouTube URL: https://www.youtube.com/watch?v=nNqiBasCab4


