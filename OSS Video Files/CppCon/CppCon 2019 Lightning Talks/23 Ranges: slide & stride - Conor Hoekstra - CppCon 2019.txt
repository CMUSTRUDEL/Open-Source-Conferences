Title: 23 Ranges: slide & stride - Conor Hoekstra - CppCon 2019
Publication date: 2019-10-23
Playlist: CppCon 2019 Lightning Talks
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:10,500 --> 00:00:14,820
how's everyone enjoying CPP Khan

00:00:16,660 --> 00:00:22,730
all right my name is Connor Hoekstra and

00:00:19,370 --> 00:00:25,850
welcome to my CPP con 2019 lightening

00:00:22,730 --> 00:00:29,360
talk entitled C++ 23 range is flat in

00:00:25,850 --> 00:00:30,860
stride so we are going to start by

00:00:29,360 --> 00:00:33,080
looking at three algorithms that are

00:00:30,860 --> 00:00:36,140
going to be coming in the c++ 23

00:00:33,080 --> 00:00:40,400
hopefully ranges library those are

00:00:36,140 --> 00:00:42,110
sliding chunk and stride so the function

00:00:40,400 --> 00:00:44,000
declaration of each of these looks very

00:00:42,110 --> 00:00:45,950
similar they take two parameters and

00:00:44,000 --> 00:00:47,600
integer K and arrange so sliding might

00:00:45,950 --> 00:00:49,790
look like this chunk might look like

00:00:47,600 --> 00:00:50,989
this and drive might look like this if

00:00:49,790 --> 00:00:52,309
you are a functional programming

00:00:50,989 --> 00:00:53,900
enthusiast like myself and you love

00:00:52,309 --> 00:00:55,699
haskell the type signature of the

00:00:53,900 --> 00:00:58,010
equivalent function in haskell would be

00:00:55,699 --> 00:01:00,140
the following so an integer a list of a

00:00:58,010 --> 00:01:01,879
a as a generic type and then returning a

00:01:00,140 --> 00:01:02,720
list of list of a so for our C++

00:01:01,879 --> 00:01:05,780
functions those are going to be

00:01:02,720 --> 00:01:07,700
returning a range of ranges if we take a

00:01:05,780 --> 00:01:09,530
look at what these algorithms do sliding

00:01:07,700 --> 00:01:11,780
with k equal to 4 and our list of

00:01:09,530 --> 00:01:13,430
integers 0 to 9 it starts by looking at

00:01:11,780 --> 00:01:15,110
the first four integers and then it

00:01:13,430 --> 00:01:16,820
takes a step looks at the next four it

00:01:15,110 --> 00:01:18,740
takes another step and it continues to

00:01:16,820 --> 00:01:19,940
do this until we end up with our final

00:01:18,740 --> 00:01:21,530
range of ranges that's going to look

00:01:19,940 --> 00:01:24,229
like this the different ranges are

00:01:21,530 --> 00:01:25,969
separated by colors chunk with k equal

00:01:24,229 --> 00:01:28,009
to 4 is a very similar algorithm but

00:01:25,969 --> 00:01:30,020
instead of stepping by one it steps by

00:01:28,009 --> 00:01:32,329
the size of the chunk so we look at 0 2

00:01:30,020 --> 00:01:34,490
3 then 4 to 7 and then we have a partial

00:01:32,329 --> 00:01:35,689
chunk at the end 8 and 9 so this is

00:01:34,490 --> 00:01:38,170
going to give us the following range of

00:01:35,689 --> 00:01:40,460
ranges finally stride with k equal to 4

00:01:38,170 --> 00:01:42,710
looks at one element at a time and it

00:01:40,460 --> 00:01:45,109
strides by 4 so we first look at 0 then

00:01:42,710 --> 00:01:46,850
we skip to 4 then we skip to 8 this is

00:01:45,109 --> 00:01:48,710
going to give us a range of ranges 0 4

00:01:46,850 --> 00:01:50,000
and 8 note that we might just want this

00:01:48,710 --> 00:01:52,250
to be a single range so we could use a

00:01:50,000 --> 00:01:56,210
Haskell can cat or a pythonic John join

00:01:52,250 --> 00:01:58,549
or a range v3 join so Kotlin a little

00:01:56,210 --> 00:02:01,189
shout-out to Phil and JetBrains here has

00:01:58,549 --> 00:02:03,049
an algorithm called windowed the

00:02:01,189 --> 00:02:04,609
function declaration of windowed is as

00:02:03,049 --> 00:02:06,109
follows we can ignore the third

00:02:04,609 --> 00:02:08,210
parameter but most importantly have two

00:02:06,109 --> 00:02:11,840
integers size and step where step is

00:02:08,210 --> 00:02:14,060
defaulted to 1 this is what it might

00:02:11,840 --> 00:02:16,340
look like in C++ to integers and K at a

00:02:14,060 --> 00:02:17,720
range and once again in Haskell we just

00:02:16,340 --> 00:02:20,570
have an extra int and our type signature

00:02:17,720 --> 00:02:22,130
so why is this important each of the

00:02:20,570 --> 00:02:23,810
three algorithms we just looked at can

00:02:22,130 --> 00:02:26,000
be implemented in terms of the Kotlin

00:02:23,810 --> 00:02:28,670
windowed when step is equal to size we

00:02:26,000 --> 00:02:29,840
get chunk when step is equal to 1 we get

00:02:28,670 --> 00:02:32,440
sliding and when

00:02:29,840 --> 00:02:35,239
size is equal to 1 we get stride in

00:02:32,440 --> 00:02:36,800
Scala this is called sliding note that

00:02:35,239 --> 00:02:39,290
the default here is not equal to 1 we

00:02:36,800 --> 00:02:40,849
have an overloaded version of sliding or

00:02:39,290 --> 00:02:43,849
it just takes a single integer and the

00:02:40,849 --> 00:02:45,830
step is hard-coded to one in D Lang or D

00:02:43,849 --> 00:02:47,180
this algorithm is called slide

00:02:45,830 --> 00:02:49,640
note that the parameters here are called

00:02:47,180 --> 00:02:51,620
window size and step size so Kotlin

00:02:49,640 --> 00:02:55,310
calls is windowed Scala calls is sliding

00:02:51,620 --> 00:02:55,730
D calls this slide haskell calls this

00:02:55,310 --> 00:02:58,700
Divi

00:02:55,730 --> 00:03:02,690
I don't know why and very unfortunately

00:02:58,700 --> 00:03:04,519
closure calls this partition so if we

00:03:02,690 --> 00:03:06,680
take a look at five more languages and

00:03:04,519 --> 00:03:08,920
we look at each of these four algorithms

00:03:06,680 --> 00:03:12,200
the Kotlin windowed and the chunk

00:03:08,920 --> 00:03:14,420
sliding and stride from the range v3

00:03:12,200 --> 00:03:15,799
library we end up with the following

00:03:14,420 --> 00:03:17,569
diagram so first we're gonna look at the

00:03:15,799 --> 00:03:19,220
most consistently named algorithm mets

00:03:17,569 --> 00:03:21,079
chunk so that's where the step is equal

00:03:19,220 --> 00:03:22,549
to size so you can see here see here a

00:03:21,079 --> 00:03:23,599
number of the different languages call

00:03:22,549 --> 00:03:25,730
this slightly something slightly

00:03:23,599 --> 00:03:28,790
different Haskell is chunks of elixir is

00:03:25,730 --> 00:03:30,379
chunk every D in rust or chunks F sharp

00:03:28,790 --> 00:03:31,940
is checked by size and Kotlin is chunked

00:03:30,379 --> 00:03:33,739
but I like the algorithm named chunk

00:03:31,940 --> 00:03:35,150
here I might prefer an S at the end to

00:03:33,739 --> 00:03:36,410
be consistent with the in rust seeing as

00:03:35,150 --> 00:03:38,690
those are our sibling languages but

00:03:36,410 --> 00:03:40,340
chunk it is the next most consistently

00:03:38,690 --> 00:03:42,380
named algorithm is stride that's where

00:03:40,340 --> 00:03:44,870
size is equal to one you can see here

00:03:42,380 --> 00:03:46,250
we're being consistent with the two

00:03:44,870 --> 00:03:48,739
other names for this algorithm or take

00:03:46,250 --> 00:03:51,019
aunt from closure and take every from

00:03:48,739 --> 00:03:53,870
elixir but for the next two we have some

00:03:51,019 --> 00:03:55,489
ambiguity for in step is equal to one

00:03:53,870 --> 00:03:57,709
and we just are stepping by one or when

00:03:55,489 --> 00:03:59,660
we have a specification of step and size

00:03:57,709 --> 00:04:02,209
we have two choices either sliding or

00:03:59,660 --> 00:04:04,880
windows so if we're consistent with

00:04:02,209 --> 00:04:05,900
Scala and D and range B 3 we get sliding

00:04:04,880 --> 00:04:07,880
or slide but if we're gonna be

00:04:05,900 --> 00:04:09,410
consistent with Kotlin or F sharp or

00:04:07,880 --> 00:04:12,200
rust we're gonna call it window or

00:04:09,410 --> 00:04:14,180
windows note here that Rustin F sharp

00:04:12,200 --> 00:04:15,410
don't have the two integer parameter

00:04:14,180 --> 00:04:17,209
version they just have these sliding

00:04:15,410 --> 00:04:19,310
where a hard-coded step is equal to one

00:04:17,209 --> 00:04:21,620
so the question is should we be

00:04:19,310 --> 00:04:23,780
consistent with D or should we be

00:04:21,620 --> 00:04:26,030
consistent with Kotlin I'm not sure if

00:04:23,780 --> 00:04:29,810
Andres here I invited them

00:04:26,030 --> 00:04:32,539
I vote for D you can see how happy

00:04:29,810 --> 00:04:33,860
andrea is because of this there's a

00:04:32,539 --> 00:04:35,419
number of motivations for this though

00:04:33,860 --> 00:04:36,889
one I think the semantic meaning of

00:04:35,419 --> 00:04:38,750
slide is closer to what this algorithm

00:04:36,889 --> 00:04:40,849
is doing we were sliding across the

00:04:38,750 --> 00:04:42,950
screen the second reason is that it has

00:04:40,849 --> 00:04:43,610
the same tenses stride I think it's a

00:04:42,950 --> 00:04:45,169
bit weird

00:04:43,610 --> 00:04:46,759
when window 2 is in past tense and

00:04:45,169 --> 00:04:48,409
stride isn't so sliding stride is a

00:04:46,759 --> 00:04:50,840
little bit more consistent and so I

00:04:48,409 --> 00:04:52,639
prefer the slide over sliding also

00:04:50,840 --> 00:04:54,020
Windows is an operating system and that

00:04:52,639 --> 00:04:56,629
makes it a little bit hard to search for

00:04:54,020 --> 00:04:58,219
if you're on Google but most importantly

00:04:56,629 --> 00:04:59,870
whether we call this slide or windowed

00:04:58,219 --> 00:05:00,979
what I want is a version of this

00:04:59,870 --> 00:05:03,680
algorithm so that we can implement

00:05:00,979 --> 00:05:05,300
chunks and the hard coded where the step

00:05:03,680 --> 00:05:07,849
is equal to one and stride in terms of

00:05:05,300 --> 00:05:09,319
this algorithm so that gives us the

00:05:07,849 --> 00:05:11,360
following and if you like this kind of

00:05:09,319 --> 00:05:16,139
stuff hit me up on Twitter thank you

00:05:11,360 --> 00:05:16,139

YouTube URL: https://www.youtube.com/watch?v=-_lqZJK2vjI


