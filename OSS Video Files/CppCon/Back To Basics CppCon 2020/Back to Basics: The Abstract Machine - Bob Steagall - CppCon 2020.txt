Title: Back to Basics: The Abstract Machine - Bob Steagall - CppCon 2020
Publication date: 2020-09-22
Playlist: Back To Basics CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_the_abstract_machine/back_to_basics_the_abstract_machine__bob_steagall__cppcon_2020.pdf
---
The compilation of every C++ program is controlled by a little-known device that remains mysterious, or even unknown, to many programmers: the C++ abstract machine. When a program is compiled, the abstract machine constructs and expresses the compiler's "mental model" of that program. It is responsible for enforcing all of the rules governing C++ programs, and ensuring that programs execute properly when those rules are observed. What's more, the abstract machine is often quite different from the physical machine, and the difference between the two can be confusing at first.

The goal of this talk is to provide an introduction to the C++ abstract machine and describe its relationship to the C++ language, how it influences the way we think about coding in C++, and its relationship to the underlying hardware upon which C++ programs execute. If you were previously unaware of the abstract machine, or have only a vague notion of what it is, then this talk is for you. Attendees will leave this session with a basic understanding of what the abstract machine is, its conception of memory, its relationship to hardware, undefined/unspecified/implementation-defined/observable behavior, and the "as-if" rule.

---
Bob Steagall
Chief Cook and Bottle Washer, KEWB Computing

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,400 --> 00:00:11,599
hello everyone

00:00:09,360 --> 00:00:12,719
and thank you for coming my name is bob

00:00:11,599 --> 00:00:14,240
stegall

00:00:12,719 --> 00:00:15,839
and i have the present the privilege of

00:00:14,240 --> 00:00:16,960
presenting the first talk at this year's

00:00:15,839 --> 00:00:20,400
back to basics track

00:00:16,960 --> 00:00:22,160
cppcon 2020. each session in this track

00:00:20,400 --> 00:00:24,240
is about a single concrete topic

00:00:22,160 --> 00:00:25,840
like this one which is about the c plus

00:00:24,240 --> 00:00:28,240
abstract machine

00:00:25,840 --> 00:00:29,359
our goal with the track is to produce

00:00:28,240 --> 00:00:30,800
content that covers

00:00:29,359 --> 00:00:32,800
important things that you need to know

00:00:30,800 --> 00:00:34,559
to be a working programmer in today's c

00:00:32,800 --> 00:00:36,880
plus plus community

00:00:34,559 --> 00:00:38,079
that being said many thanks to our back

00:00:36,880 --> 00:00:40,719
to basics chair

00:00:38,079 --> 00:00:41,840
arthur o'greier for putting together the

00:00:40,719 --> 00:00:43,680
track program

00:00:41,840 --> 00:00:45,520
and to our conference chair john call

00:00:43,680 --> 00:00:48,000
for making cppcon such a great

00:00:45,520 --> 00:00:48,000
conference

00:00:48,559 --> 00:00:53,520
i'd like to begin by providing a basic

00:00:51,440 --> 00:00:55,440
idea of what an abstract machine is

00:00:53,520 --> 00:00:56,559
in general and then move on to

00:00:55,440 --> 00:01:00,559
describing the c

00:00:56,559 --> 00:01:00,559
plus abstract machine in particular

00:01:00,719 --> 00:01:03,760
i'll briefly cover some of the language

00:01:02,399 --> 00:01:05,119
goals that drive the design of the

00:01:03,760 --> 00:01:07,119
abstract machine

00:01:05,119 --> 00:01:09,200
and its role in our program development

00:01:07,119 --> 00:01:11,200
and execution

00:01:09,200 --> 00:01:12,960
i'll provide some important definitions

00:01:11,200 --> 00:01:14,400
and hopefully we can tease out some

00:01:12,960 --> 00:01:16,640
interesting characteristics

00:01:14,400 --> 00:01:19,360
of the abstract machine and i'd like to

00:01:16,640 --> 00:01:21,520
do this in somewhat of an axiomatic way

00:01:19,360 --> 00:01:23,360
axiomatic in that i'll try to try to

00:01:21,520 --> 00:01:25,759
build a picture from the ground up

00:01:23,360 --> 00:01:29,040
it's not truly axiomatic of course this

00:01:25,759 --> 00:01:29,040
is not hardcore math

00:01:29,280 --> 00:01:32,479
we'll talk about important components of

00:01:30,880 --> 00:01:35,360
the abstract machine and their

00:01:32,479 --> 00:01:35,360
relationships

00:01:35,600 --> 00:01:42,000
my goal really is to provide you

00:01:39,280 --> 00:01:42,560
the viewer with an useful overview of

00:01:42,000 --> 00:01:44,240
the c

00:01:42,560 --> 00:01:46,240
plus abstract machine in the hopes that

00:01:44,240 --> 00:01:48,720
will help you a little bit at least

00:01:46,240 --> 00:01:50,479
in your day-to-day work there's actually

00:01:48,720 --> 00:01:51,200
very little code in this talk there are

00:01:50,479 --> 00:01:53,040
however

00:01:51,200 --> 00:01:54,479
a number of definitions and diagrams

00:01:53,040 --> 00:01:57,040
that i hope will explain the c

00:01:54,479 --> 00:02:00,240
plus abstract machine a little better so

00:01:57,040 --> 00:02:03,439
let's begin with some definitions

00:02:00,240 --> 00:02:05,840
so what is an abstract machine

00:02:03,439 --> 00:02:08,319
opinions vary of course and i provided

00:02:05,840 --> 00:02:11,440
three general purpose definitions here

00:02:08,319 --> 00:02:13,040
i will read some of the highlights

00:02:11,440 --> 00:02:15,840
for this definition which comes from a

00:02:13,040 --> 00:02:17,440
paper published in 2000

00:02:15,840 --> 00:02:19,040
the silent characteristic is that

00:02:17,440 --> 00:02:20,480
abstract machines provide an

00:02:19,040 --> 00:02:21,599
intermediate language stage for

00:02:20,480 --> 00:02:23,599
compilation

00:02:21,599 --> 00:02:24,640
they bridge the gap between a high-level

00:02:23,599 --> 00:02:28,080
programming language

00:02:24,640 --> 00:02:28,080
and the low level of a hardware

00:02:29,040 --> 00:02:34,560
a great post on quora by sergey zubkov

00:02:32,319 --> 00:02:36,640
defined an abstract machine in this way

00:02:34,560 --> 00:02:38,480
again reading only the highlights

00:02:36,640 --> 00:02:39,920
programming language specifications

00:02:38,480 --> 00:02:42,400
define the languages

00:02:39,920 --> 00:02:43,440
in terms of an abstract machine which in

00:02:42,400 --> 00:02:45,760
this usage

00:02:43,440 --> 00:02:46,480
is the simplest imaginary computer

00:02:45,760 --> 00:02:48,840
capable of

00:02:46,480 --> 00:02:50,080
executing a program in the source

00:02:48,840 --> 00:02:51,680
language

00:02:50,080 --> 00:02:54,000
that's uh that's actually a very good

00:02:51,680 --> 00:02:55,519
definition

00:02:54,000 --> 00:02:57,519
and finally from the free online

00:02:55,519 --> 00:02:59,360
dictionary of computing

00:02:57,519 --> 00:03:00,640
it defines an abstract machine as a

00:02:59,360 --> 00:03:02,239
processor design

00:03:00,640 --> 00:03:04,239
not intended to be implemented as

00:03:02,239 --> 00:03:07,120
hardware but which is

00:03:04,239 --> 00:03:08,879
the notional executor of a particular

00:03:07,120 --> 00:03:10,959
intermediate language

00:03:08,879 --> 00:03:14,560
an abstract machine language that's used

00:03:10,959 --> 00:03:14,560
in a compiler or an interpreter

00:03:15,519 --> 00:03:20,720
what is the c plus abstract machine well

00:03:19,040 --> 00:03:22,239
i like this definition that was given by

00:03:20,720 --> 00:03:25,280
bryce adelstein lelbach

00:03:22,239 --> 00:03:27,680
at coors c plus plus 29 last year

00:03:25,280 --> 00:03:29,120
bryce says that the c plus plus abstract

00:03:27,680 --> 00:03:30,720
machine is a portalglass

00:03:29,120 --> 00:03:32,640
portable abstraction of your operating

00:03:30,720 --> 00:03:34,480
system systems kernel and hardware

00:03:32,640 --> 00:03:36,319
the abstract machine is the intermediary

00:03:34,480 --> 00:03:37,519
between your program and the system that

00:03:36,319 --> 00:03:40,560
it is run on

00:03:37,519 --> 00:03:43,360
and that's a nice concise terse and spot

00:03:40,560 --> 00:03:43,360
on definition

00:03:43,760 --> 00:03:47,120
so why do we use abstract machines well

00:03:46,560 --> 00:03:49,120
we have

00:03:47,120 --> 00:03:50,400
complex information tasks that we need

00:03:49,120 --> 00:03:52,799
to get done

00:03:50,400 --> 00:03:54,720
we want to write programs in some human

00:03:52,799 --> 00:03:55,519
readable language to help us get these

00:03:54,720 --> 00:03:57,519
tasks done

00:03:55,519 --> 00:03:58,959
in a reasonable amount of time and of

00:03:57,519 --> 00:04:01,200
course human readable

00:03:58,959 --> 00:04:03,280
for productivity nobody wants to look at

00:04:01,200 --> 00:04:05,280
machine code anymore

00:04:03,280 --> 00:04:07,200
we want tools that will robustly and

00:04:05,280 --> 00:04:09,760
reliably take our programs

00:04:07,200 --> 00:04:12,319
and transform them into a form that can

00:04:09,760 --> 00:04:14,720
execute on one or more computing systems

00:04:12,319 --> 00:04:18,239
and in c plus these tools are primarily

00:04:14,720 --> 00:04:19,919
the compiler and the linker

00:04:18,239 --> 00:04:21,759
in today's world we have an enormous

00:04:19,919 --> 00:04:24,560
variety of computing platforms

00:04:21,759 --> 00:04:26,240
from general purpose cpus which i think

00:04:24,560 --> 00:04:28,000
is probably what most of us think of

00:04:26,240 --> 00:04:31,280
when we think of programming

00:04:28,000 --> 00:04:32,880
to gpus and specialized co-processors

00:04:31,280 --> 00:04:34,800
which are sort of these days achieving

00:04:32,880 --> 00:04:36,880
their own prominence

00:04:34,800 --> 00:04:37,919
and then finally embedded processors

00:04:36,880 --> 00:04:40,240
which are found

00:04:37,919 --> 00:04:40,960
in everything i think it's interesting

00:04:40,240 --> 00:04:42,960
to note

00:04:40,960 --> 00:04:44,479
the percentage of systems that use

00:04:42,960 --> 00:04:46,880
general purpose cpus

00:04:44,479 --> 00:04:48,880
relative to all systems in the world

00:04:46,880 --> 00:04:53,919
i've seen estimates of 95

00:04:48,880 --> 00:04:53,919
or higher being embedded devices

00:04:54,080 --> 00:04:58,320
so given all this it is impractical or

00:04:56,400 --> 00:05:00,240
perhaps impossible to create

00:04:58,320 --> 00:05:01,919
a separate language instead of tools for

00:05:00,240 --> 00:05:03,520
every computing platform

00:05:01,919 --> 00:05:04,960
this was done a few times in the early

00:05:03,520 --> 00:05:06,639
days of computing and t

00:05:04,960 --> 00:05:10,479
until people realized it just couldn't

00:05:06,639 --> 00:05:12,080
be done for every new platform

00:05:10,479 --> 00:05:14,160
so we want tools to help us manage

00:05:12,080 --> 00:05:15,440
complexity when we write our programs we

00:05:14,160 --> 00:05:17,039
don't want to be concerned with the

00:05:15,440 --> 00:05:19,919
details of the underlying

00:05:17,039 --> 00:05:21,919
physical hardware we want our languages

00:05:19,919 --> 00:05:23,759
capable of representing abstractions

00:05:21,919 --> 00:05:26,000
relevant to the problem domain

00:05:23,759 --> 00:05:27,919
at hand and we want programming

00:05:26,000 --> 00:05:29,919
languages to transform our programs to

00:05:27,919 --> 00:05:32,240
executable form on one or more computing

00:05:29,919 --> 00:05:34,400
platforms

00:05:32,240 --> 00:05:35,280
to solve problems like this we humans

00:05:34,400 --> 00:05:38,000
like to use

00:05:35,280 --> 00:05:39,280
abstraction and so we define our

00:05:38,000 --> 00:05:42,400
programming languages

00:05:39,280 --> 00:05:45,440
in terms of abstract machines

00:05:42,400 --> 00:05:48,320
virtually every modern language and

00:05:45,440 --> 00:05:51,199
even some old ones like algol defined

00:05:48,320 --> 00:05:54,320
abstract machines

00:05:51,199 --> 00:05:55,840
so you could legitimately ask what

00:05:54,320 --> 00:05:58,880
drives the design

00:05:55,840 --> 00:06:00,240
of the c plus abstract machine well

00:05:58,880 --> 00:06:03,600
there was a great paper

00:06:00,240 --> 00:06:05,360
uh p 2137 published at the committee

00:06:03,600 --> 00:06:07,680
which set out a set of goals for the

00:06:05,360 --> 00:06:09,520
language i was not a signatory to the

00:06:07,680 --> 00:06:11,440
paper but i agree wholeheartedly with

00:06:09,520 --> 00:06:14,080
the points that they made in it

00:06:11,440 --> 00:06:14,720
and they contend that c plus should

00:06:14,080 --> 00:06:17,440
support

00:06:14,720 --> 00:06:18,960
performance critical software uh

00:06:17,440 --> 00:06:21,840
evolution of software

00:06:18,960 --> 00:06:22,560
and the language itself code that's easy

00:06:21,840 --> 00:06:25,680
to read

00:06:22,560 --> 00:06:26,960
and write and understand practical

00:06:25,680 --> 00:06:30,080
guarantees regarding

00:06:26,960 --> 00:06:31,919
safety and testing fast and scalable

00:06:30,080 --> 00:06:33,520
development

00:06:31,919 --> 00:06:35,520
and the ability to support current

00:06:33,520 --> 00:06:36,960
hardware textures architectures

00:06:35,520 --> 00:06:40,080
platforms and environments

00:06:36,960 --> 00:06:41,759
as they evolve i want to dig a little

00:06:40,080 --> 00:06:43,600
bit into some of these that i think are

00:06:41,759 --> 00:06:46,720
most directly related to the c

00:06:43,600 --> 00:06:49,280
plus abstract machine

00:06:46,720 --> 00:06:50,479
for performance critical software really

00:06:49,280 --> 00:06:52,560
what we want to do is give the

00:06:50,479 --> 00:06:53,599
programmer control over every aspect of

00:06:52,560 --> 00:06:55,520
performance

00:06:53,599 --> 00:06:57,599
c plus should always have tools

00:06:55,520 --> 00:07:00,240
available to to address performance

00:06:57,599 --> 00:07:02,960
problems when they arise

00:07:00,240 --> 00:07:03,440
code should perform predictably the

00:07:02,960 --> 00:07:05,039
reader

00:07:03,440 --> 00:07:07,280
and also the writer of code should be

00:07:05,039 --> 00:07:08,160
able to understand that code's expected

00:07:07,280 --> 00:07:09,520
performance

00:07:08,160 --> 00:07:13,120
giving an understanding of the

00:07:09,520 --> 00:07:13,120
underlying execution environment

00:07:13,280 --> 00:07:18,960
in performance so we want to leave no

00:07:17,039 --> 00:07:20,720
room for a lower level language

00:07:18,960 --> 00:07:22,479
in other words a programmer should never

00:07:20,720 --> 00:07:24,400
need to look under the hood

00:07:22,479 --> 00:07:28,479
and have to switch to another language

00:07:24,400 --> 00:07:31,840
to improve the performance of a program

00:07:28,479 --> 00:07:34,160
finally as hardware

00:07:31,840 --> 00:07:35,360
and operating systems and environments

00:07:34,160 --> 00:07:37,840
evolve

00:07:35,360 --> 00:07:38,639
we wanted the way we generate executable

00:07:37,840 --> 00:07:40,720
code for them

00:07:38,639 --> 00:07:42,000
also has to evolve and we need a

00:07:40,720 --> 00:07:44,479
framework to do this

00:07:42,000 --> 00:07:45,360
a generalization mechanism that allows

00:07:44,479 --> 00:07:49,440
us to evolve

00:07:45,360 --> 00:07:49,440
as these external things evolve

00:07:49,680 --> 00:07:54,240
so how does c plus meet these goals well

00:07:52,240 --> 00:07:55,680
c plus plus has no layers of abstraction

00:07:54,240 --> 00:07:57,440
between it and the hardware

00:07:55,680 --> 00:08:00,160
there are no interpreters or virtual

00:07:57,440 --> 00:08:01,919
machines like the jbm

00:08:00,160 --> 00:08:04,080
and because of this c plus plus can

00:08:01,919 --> 00:08:07,280
perform high quality code generation

00:08:04,080 --> 00:08:08,960
in the compiler backend literally there

00:08:07,280 --> 00:08:09,440
is no room for another language between

00:08:08,960 --> 00:08:11,360
c

00:08:09,440 --> 00:08:14,000
plus and the hardware unless you want to

00:08:11,360 --> 00:08:17,199
drop down into assembler

00:08:14,000 --> 00:08:19,840
c plus plus maps types and operations

00:08:17,199 --> 00:08:20,960
very directly onto hardware most of the

00:08:19,840 --> 00:08:23,199
fundamental types

00:08:20,960 --> 00:08:26,000
if not all of the fundamental types map

00:08:23,199 --> 00:08:27,919
directly into memory entities

00:08:26,000 --> 00:08:30,240
things like pointers and references and

00:08:27,919 --> 00:08:32,839
arrays map directly into the hardware

00:08:30,240 --> 00:08:36,080
addressing capabilities of most modern

00:08:32,839 --> 00:08:37,360
microprocessors and modern hardware

00:08:36,080 --> 00:08:39,760
supports

00:08:37,360 --> 00:08:41,279
a wide variety of very useful arithmetic

00:08:39,760 --> 00:08:44,880
and logical operations

00:08:41,279 --> 00:08:47,519
on those entities in general

00:08:44,880 --> 00:08:49,600
and to sum it all up c plus defines how

00:08:47,519 --> 00:08:50,399
programs work in terms of an abstract

00:08:49,600 --> 00:08:52,160
machine

00:08:50,399 --> 00:08:55,440
a machine that's deliberately defined to

00:08:52,160 --> 00:08:57,760
be very close to the hardware

00:08:55,440 --> 00:08:59,279
so let's look at that a little bit when

00:08:57,760 --> 00:09:01,680
we write programs

00:08:59,279 --> 00:09:02,399
our programs describe operations that we

00:09:01,680 --> 00:09:05,920
would like

00:09:02,399 --> 00:09:07,920
to have performed and in a sense those

00:09:05,920 --> 00:09:11,519
operations are performed on the abstract

00:09:07,920 --> 00:09:14,880
machine so we start with our source code

00:09:11,519 --> 00:09:17,279
we feed that source code into a compiler

00:09:14,880 --> 00:09:18,720
and from our perspective the compiler

00:09:17,279 --> 00:09:20,800
emulates in a sense

00:09:18,720 --> 00:09:21,760
that program running on the abstract

00:09:20,800 --> 00:09:24,800
machine

00:09:21,760 --> 00:09:26,160
it checks it checks the syntax and the

00:09:24,800 --> 00:09:28,480
constructs in our program

00:09:26,160 --> 00:09:29,440
against those that are legal to ensure

00:09:28,480 --> 00:09:31,920
that

00:09:29,440 --> 00:09:33,360
the the code if if there actually were

00:09:31,920 --> 00:09:35,279
hardware that implemented

00:09:33,360 --> 00:09:37,839
the abstract machine would actually

00:09:35,279 --> 00:09:37,839
execute

00:09:38,080 --> 00:09:42,160
now the implementation the underlying

00:09:40,560 --> 00:09:44,320
compiler and tool chain

00:09:42,160 --> 00:09:45,920
it translates the abstract machine

00:09:44,320 --> 00:09:47,120
operations into physical machine

00:09:45,920 --> 00:09:50,240
operations

00:09:47,120 --> 00:09:52,959
so at the same time it's emulating our

00:09:50,240 --> 00:09:55,360
uh program on the abstract machine it's

00:09:52,959 --> 00:09:57,519
mapping operations occurring on this

00:09:55,360 --> 00:09:58,640
this on the abstract machine into

00:09:57,519 --> 00:10:00,480
machine code

00:09:58,640 --> 00:10:01,680
and it's the machine code that actually

00:10:00,480 --> 00:10:05,040
runs on an x

00:10:01,680 --> 00:10:05,920
on a physical machine when we write

00:10:05,040 --> 00:10:08,720
programs

00:10:05,920 --> 00:10:09,360
this is our area of concern we want to

00:10:08,720 --> 00:10:11,440
make sure

00:10:09,360 --> 00:10:13,200
that our source code meets the

00:10:11,440 --> 00:10:15,760
requirements specified

00:10:13,200 --> 00:10:16,959
in the standard and by the compiler so

00:10:15,760 --> 00:10:19,200
that it can run

00:10:16,959 --> 00:10:20,079
on the abstract machine even if it's

00:10:19,200 --> 00:10:23,200
only running in an

00:10:20,079 --> 00:10:25,600
emulated or virtual way

00:10:23,200 --> 00:10:26,880
the compiler's concern is to take that

00:10:25,600 --> 00:10:29,519
same source code

00:10:26,880 --> 00:10:30,880
and turn it into optimal machine code

00:10:29,519 --> 00:10:33,839
that runs on hardware

00:10:30,880 --> 00:10:33,839
out there in the world

00:10:35,120 --> 00:10:39,600
so one central thesis here and the if

00:10:37,920 --> 00:10:41,440
you take away one thing from today's

00:10:39,600 --> 00:10:44,560
talk you should take this away

00:10:41,440 --> 00:10:46,880
when we write c plus code we are writing

00:10:44,560 --> 00:10:48,800
we are targeting the c plus abstract

00:10:46,880 --> 00:10:50,720
machine

00:10:48,800 --> 00:10:51,920
now i don't normally like to read a lot

00:10:50,720 --> 00:10:53,839
but what i'm going to do

00:10:51,920 --> 00:10:55,680
is start with some very important

00:10:53,839 --> 00:10:57,279
definitions that are in the standard and

00:10:55,680 --> 00:10:59,200
i'm going to read some of the highlight

00:10:57,279 --> 00:11:01,040
highlighted sections as i mentioned

00:10:59,200 --> 00:11:02,399
before i'm trying to build an axiomatic

00:11:01,040 --> 00:11:04,480
view of what the

00:11:02,399 --> 00:11:05,680
c plus abstract machine is and so i have

00:11:04,480 --> 00:11:08,880
to start with these

00:11:05,680 --> 00:11:10,880
crucial definitions so the abstract

00:11:08,880 --> 00:11:13,279
machine is defined right up front in the

00:11:10,880 --> 00:11:15,279
standard in section 4.1

00:11:13,279 --> 00:11:17,360
and at the very beginning of that it

00:11:15,279 --> 00:11:19,640
says the semantic description of this

00:11:17,360 --> 00:11:22,720
document define a parameterized

00:11:19,640 --> 00:11:25,279
non-deterministic abstract machine

00:11:22,720 --> 00:11:26,839
the document places no requirement on

00:11:25,279 --> 00:11:29,200
the structure of a conforming

00:11:26,839 --> 00:11:31,360
implementation

00:11:29,200 --> 00:11:32,640
rather conforming implementations are

00:11:31,360 --> 00:11:34,640
required to emulate

00:11:32,640 --> 00:11:35,839
only the observable behavior of the

00:11:34,640 --> 00:11:38,399
abstract machine

00:11:35,839 --> 00:11:40,640
as explained below so there's some

00:11:38,399 --> 00:11:42,160
interesting tidbits here in this first

00:11:40,640 --> 00:11:44,800
portion of the definition there's some

00:11:42,160 --> 00:11:48,720
things we need to understand

00:11:44,800 --> 00:11:51,760
so there was a mention of implementation

00:11:48,720 --> 00:11:54,959
there was the mention of parametrized

00:11:51,760 --> 00:11:56,399
and non-deterministic and there was this

00:11:54,959 --> 00:11:56,800
interesting statement that contained the

00:11:56,399 --> 00:11:59,200
term

00:11:56,800 --> 00:12:01,040
observable behavior implementations must

00:11:59,200 --> 00:12:03,200
emulate the observable behavior of the

00:12:01,040 --> 00:12:05,120
abstract machine

00:12:03,200 --> 00:12:06,639
well implementation turns out to be one

00:12:05,120 --> 00:12:07,760
of those terms that the standard doesn't

00:12:06,639 --> 00:12:09,839
define directly

00:12:07,760 --> 00:12:11,760
at least not that i could find and so

00:12:09,839 --> 00:12:12,560
i'm going to substitute my definition in

00:12:11,760 --> 00:12:14,560
here

00:12:12,560 --> 00:12:16,720
so when i say implementation and

00:12:14,560 --> 00:12:19,760
hopefully i'm using the word correctly

00:12:16,720 --> 00:12:22,320
i mean tools that verify the program

00:12:19,760 --> 00:12:23,120
on the abstract machine and generate a

00:12:22,320 --> 00:12:25,440
corresponding

00:12:23,120 --> 00:12:27,279
executable image and these are generally

00:12:25,440 --> 00:12:30,800
the things that we call the compiler

00:12:27,279 --> 00:12:32,880
and the linker at the bottom of that

00:12:30,800 --> 00:12:33,279
same page is a very interesting footnote

00:12:32,880 --> 00:12:36,560
that

00:12:33,279 --> 00:12:37,440
provides some some very useful uh very

00:12:36,560 --> 00:12:39,760
useful

00:12:37,440 --> 00:12:41,760
definition says this provision is

00:12:39,760 --> 00:12:43,760
sometimes called the as if rule

00:12:41,760 --> 00:12:45,040
because it's an implementation is free

00:12:43,760 --> 00:12:47,360
to disregard

00:12:45,040 --> 00:12:48,639
any requirement of this document as long

00:12:47,360 --> 00:12:51,839
as the result is

00:12:48,639 --> 00:12:52,480
as if the requirement had been obeyed

00:12:51,839 --> 00:12:54,320
for instance

00:12:52,480 --> 00:12:56,320
an actual implementation need not

00:12:54,320 --> 00:12:58,240
evaluate part of an expression

00:12:56,320 --> 00:12:59,600
if it can deduce that its value is not

00:12:58,240 --> 00:13:01,600
used and that no

00:12:59,600 --> 00:13:03,040
side effects affecting the observable

00:13:01,600 --> 00:13:05,519
behavior of the program

00:13:03,040 --> 00:13:08,959
are produced okay so there's some more

00:13:05,519 --> 00:13:12,639
adjectives and nouns of interest in this

00:13:08,959 --> 00:13:13,360
so the the definition of the abstract

00:13:12,639 --> 00:13:17,279
machine

00:13:13,360 --> 00:13:18,480
mentions expressions and non-observable

00:13:17,279 --> 00:13:21,200
side effects

00:13:18,480 --> 00:13:21,519
and so i take that to mean the opposite

00:13:21,200 --> 00:13:26,160
of

00:13:21,519 --> 00:13:29,760
observable behavior continuing

00:13:26,160 --> 00:13:30,720
in 4-1-2 certain aspects and operations

00:13:29,760 --> 00:13:33,760
of the machine

00:13:30,720 --> 00:13:36,079
are described as implementation defined

00:13:33,760 --> 00:13:38,000
these constitute the parameters of the

00:13:36,079 --> 00:13:40,160
abstract machine

00:13:38,000 --> 00:13:41,920
each implementation must include

00:13:40,160 --> 00:13:44,000
documentation that describe

00:13:41,920 --> 00:13:46,720
its characteristics and behavior in

00:13:44,000 --> 00:13:50,639
these respects

00:13:46,720 --> 00:13:52,160
so implementation defined behavior

00:13:50,639 --> 00:13:55,120
is what characterizes the

00:13:52,160 --> 00:13:58,160
parameterization of our parametrized

00:13:55,120 --> 00:14:00,639
non-deterministic abstract machine

00:13:58,160 --> 00:14:01,440
now we can deduce from this that

00:14:00,639 --> 00:14:03,199
implementation

00:14:01,440 --> 00:14:06,240
implementation defined behavior is

00:14:03,199 --> 00:14:08,320
allowable and it has to be documented

00:14:06,240 --> 00:14:10,720
we should be able to look up somewhere

00:14:08,320 --> 00:14:13,600
in a document online or on paper

00:14:10,720 --> 00:14:17,760
where some implementation defined aspect

00:14:13,600 --> 00:14:20,240
of an implementation is provided

00:14:17,760 --> 00:14:22,240
moving back to the definition where

00:14:20,240 --> 00:14:24,160
possible this document also defines a

00:14:22,240 --> 00:14:26,639
set of allowable behaviors

00:14:24,160 --> 00:14:28,560
notice they don't say must be documented

00:14:26,639 --> 00:14:30,880
these define the non-deterministic

00:14:28,560 --> 00:14:32,959
aspects of the abstract machine

00:14:30,880 --> 00:14:35,040
an instance of the abstract machine can

00:14:32,959 --> 00:14:36,000
therefore have more than one possible

00:14:35,040 --> 00:14:40,399
execution

00:14:36,000 --> 00:14:40,399
for a given program and a given input

00:14:40,480 --> 00:14:44,079
alright so unspecified behavior is

00:14:43,440 --> 00:14:46,399
allowable

00:14:44,079 --> 00:14:47,360
behaviors that the abstract machine can

00:14:46,399 --> 00:14:49,440
engage in

00:14:47,360 --> 00:14:51,040
the difference between unspecified and

00:14:49,440 --> 00:14:54,959
implementation defined

00:14:51,040 --> 00:14:59,279
is that unspecified is undocumented

00:14:54,959 --> 00:15:02,560
but nevertheless it's allowable

00:14:59,279 --> 00:15:04,160
moving on certain other operations in

00:15:02,560 --> 00:15:07,040
this document

00:15:04,160 --> 00:15:08,480
are described as being undefined and

00:15:07,040 --> 00:15:10,480
then it gives the example of trying to

00:15:08,480 --> 00:15:11,839
modify a const object

00:15:10,480 --> 00:15:14,079
now there's a very important note that

00:15:11,839 --> 00:15:16,240
follows this document imposes no

00:15:14,079 --> 00:15:16,880
requirements on the behavior of programs

00:15:16,240 --> 00:15:19,839
that contained

00:15:16,880 --> 00:15:21,040
undefined behavior so here's another

00:15:19,839 --> 00:15:23,040
characteristic

00:15:21,040 --> 00:15:24,320
the fact that an operation can be

00:15:23,040 --> 00:15:26,399
undefined

00:15:24,320 --> 00:15:28,000
and when that occurs there are no

00:15:26,399 --> 00:15:30,399
requirements on the behavior

00:15:28,000 --> 00:15:33,279
of those undefined operations literally

00:15:30,399 --> 00:15:33,279
anything can happen

00:15:34,320 --> 00:15:38,399
a conforming implementation must produce

00:15:36,800 --> 00:15:40,560
the same observable behavior

00:15:38,399 --> 00:15:42,480
as one of the possible executions of the

00:15:40,560 --> 00:15:43,279
corresponding instance of the abstract

00:15:42,480 --> 00:15:45,279
machine

00:15:43,279 --> 00:15:47,360
given the same program and the same

00:15:45,279 --> 00:15:48,880
input

00:15:47,360 --> 00:15:51,680
all right so now we're beginning to get

00:15:48,880 --> 00:15:52,959
a picture of what observable behavior is

00:15:51,680 --> 00:15:56,160
what this is telling us that there are

00:15:52,959 --> 00:15:58,480
many possible valid execution paths

00:15:56,160 --> 00:15:59,279
observable behaviors that occur that

00:15:58,480 --> 00:16:02,079
could occur

00:15:59,279 --> 00:16:03,279
in the abstract machine and the

00:16:02,079 --> 00:16:05,199
implementation

00:16:03,279 --> 00:16:09,440
the physical code that's running must

00:16:05,199 --> 00:16:10,959
match one of them when it runs

00:16:09,440 --> 00:16:13,120
the next part i'm not going to read all

00:16:10,959 --> 00:16:13,759
of this to you but basically what it

00:16:13,120 --> 00:16:15,759
says

00:16:13,759 --> 00:16:17,199
is that it defines what observable

00:16:15,759 --> 00:16:20,240
behavior is

00:16:17,199 --> 00:16:24,240
if accesses to data are made through

00:16:20,240 --> 00:16:26,079
volatile volatile variables

00:16:24,240 --> 00:16:28,560
data that's written to a file at the end

00:16:26,079 --> 00:16:30,880
of a program and interaction with i o

00:16:28,560 --> 00:16:32,880
functions that are part of the library

00:16:30,880 --> 00:16:34,399
when those things occur that is

00:16:32,880 --> 00:16:36,800
observable behavior

00:16:34,399 --> 00:16:37,600
those are points in the execution of a

00:16:36,800 --> 00:16:39,680
program

00:16:37,600 --> 00:16:42,240
where the state of the program can be

00:16:39,680 --> 00:16:42,240
observed

00:16:42,720 --> 00:16:47,120
so observable behavior i think of it as

00:16:45,199 --> 00:16:49,040
being execution state information

00:16:47,120 --> 00:16:51,839
that's exchanged over time with some

00:16:49,040 --> 00:16:51,839
outside entity

00:16:52,000 --> 00:16:58,079
and finally what are side effects

00:16:55,440 --> 00:16:59,519
and what is an expression so further in

00:16:58,079 --> 00:17:02,079
the standard it describes

00:16:59,519 --> 00:17:04,079
side effects as being changes in the

00:17:02,079 --> 00:17:06,240
state of the execution environment

00:17:04,079 --> 00:17:07,839
and it lists four four instances in

00:17:06,240 --> 00:17:09,280
which that can occur

00:17:07,839 --> 00:17:11,839
reading an object that's marked as

00:17:09,280 --> 00:17:13,679
volatile modifying any object

00:17:11,839 --> 00:17:15,360
including volatile objects calling a

00:17:13,679 --> 00:17:17,039
library function that does i o

00:17:15,360 --> 00:17:18,400
and calling a function that does any of

00:17:17,039 --> 00:17:22,959
the above

00:17:18,400 --> 00:17:25,280
so that is what defines side effects

00:17:22,959 --> 00:17:27,199
an expression a little bit simpler an

00:17:25,280 --> 00:17:28,480
expression is a sequence of operands and

00:17:27,199 --> 00:17:30,880
operators

00:17:28,480 --> 00:17:32,320
that specifies a computation the

00:17:30,880 --> 00:17:34,240
important thing here is that an

00:17:32,320 --> 00:17:37,200
expression can result in a value

00:17:34,240 --> 00:17:38,480
and it can cause side effects so now we

00:17:37,200 --> 00:17:40,320
have our final

00:17:38,480 --> 00:17:42,160
piece in the puzzle here of our

00:17:40,320 --> 00:17:45,600
characterization

00:17:42,160 --> 00:17:47,600
so i think that with these

00:17:45,600 --> 00:17:49,919
sentences and these descriptions we can

00:17:47,600 --> 00:17:52,480
begin to form

00:17:49,919 --> 00:17:54,400
a concrete understanding of the abstract

00:17:52,480 --> 00:17:57,760
machine

00:17:54,400 --> 00:17:59,840
so let's move on remember

00:17:57,760 --> 00:18:01,760
our programs describe operations

00:17:59,840 --> 00:18:04,400
performed on the abstract machine

00:18:01,760 --> 00:18:06,720
when our source code is compiled it is

00:18:04,400 --> 00:18:07,440
as if the compiler is emulating our

00:18:06,720 --> 00:18:11,440
program

00:18:07,440 --> 00:18:11,440
that's running on an abstract machine

00:18:11,760 --> 00:18:16,160
the implementation translates these

00:18:14,480 --> 00:18:17,840
abstract machine operations

00:18:16,160 --> 00:18:19,200
into physical machine operations it

00:18:17,840 --> 00:18:20,960
emits source code

00:18:19,200 --> 00:18:23,120
it links it and that's what actually

00:18:20,960 --> 00:18:25,679
runs on the physical machine

00:18:23,120 --> 00:18:26,640
at the end of the day with a conforming

00:18:25,679 --> 00:18:29,360
implementation

00:18:26,640 --> 00:18:31,520
and correct code there will be

00:18:29,360 --> 00:18:33,280
equivalent observable behavior

00:18:31,520 --> 00:18:36,799
between the the two machines the

00:18:33,280 --> 00:18:36,799
physical and the abstract

00:18:37,200 --> 00:18:43,039
so let's pretend we're watching a

00:18:39,520 --> 00:18:43,919
program in action we have our abstract

00:18:43,039 --> 00:18:47,200
machine

00:18:43,919 --> 00:18:48,559
and we have our physical machine we feed

00:18:47,200 --> 00:18:51,120
them some input

00:18:48,559 --> 00:18:53,679
and we start them on the path of

00:18:51,120 --> 00:18:53,679
executing

00:18:53,840 --> 00:18:57,600
as they execute through time there will

00:18:56,240 --> 00:19:00,720
be points

00:18:57,600 --> 00:19:02,080
at which observable behavior occurs and

00:19:00,720 --> 00:19:03,440
i've labeled these points as

00:19:02,080 --> 00:19:07,600
interactions

00:19:03,440 --> 00:19:10,400
in this presentation as a shorthand for

00:19:07,600 --> 00:19:12,640
as a shorthand for the statement

00:19:10,400 --> 00:19:13,280
observable behavior is occurring at this

00:19:12,640 --> 00:19:16,080
point

00:19:13,280 --> 00:19:19,679
in the execution state of this machine

00:19:16,080 --> 00:19:19,679
be it physical or abstract

00:19:19,760 --> 00:19:25,280
and so interactions will continue

00:19:24,120 --> 00:19:28,240
[Music]

00:19:25,280 --> 00:19:29,840
throughout the lifetime of the program

00:19:28,240 --> 00:19:34,240
and perhaps when the program

00:19:29,840 --> 00:19:34,240
ends there will be some output

00:19:36,400 --> 00:19:42,080
with correct data a correct program

00:19:39,520 --> 00:19:43,840
and a conforming implementation at these

00:19:42,080 --> 00:19:45,919
points of interaction

00:19:43,840 --> 00:19:47,840
the observable behavior must be

00:19:45,919 --> 00:19:49,840
equivalent

00:19:47,840 --> 00:19:52,240
now this diagram is actually slightly

00:19:49,840 --> 00:19:53,120
simpler than the real case because

00:19:52,240 --> 00:19:56,080
remember

00:19:53,120 --> 00:19:58,559
there's a non-deterministic aspect to

00:19:56,080 --> 00:19:58,559
all of this

00:20:01,200 --> 00:20:07,120
so here what i've tried to do is

00:20:04,400 --> 00:20:07,919
indicate with the fuzziness of the lines

00:20:07,120 --> 00:20:11,360
that

00:20:07,919 --> 00:20:14,799
there is some non-determinism

00:20:11,360 --> 00:20:17,600
so for example here

00:20:14,799 --> 00:20:19,360
when a physical machine is executing

00:20:17,600 --> 00:20:20,640
between two points of observable

00:20:19,360 --> 00:20:22,799
behavior

00:20:20,640 --> 00:20:25,360
there are some paths of execution that

00:20:22,799 --> 00:20:27,840
occur that we can't know what they are

00:20:25,360 --> 00:20:28,960
kind of like quantum mechanics and at

00:20:27,840 --> 00:20:31,120
the same time

00:20:28,960 --> 00:20:32,880
in the abstract machine there are

00:20:31,120 --> 00:20:34,960
corresponding

00:20:32,880 --> 00:20:36,880
paths of execution that are occurring

00:20:34,960 --> 00:20:40,400
but we just don't know what they are

00:20:36,880 --> 00:20:42,640
it's non-deterministic but

00:20:40,400 --> 00:20:43,919
at these points of interaction

00:20:42,640 --> 00:20:46,400
throughout the lifetime

00:20:43,919 --> 00:20:48,159
of the program and at the end when we

00:20:46,400 --> 00:20:50,000
write our output

00:20:48,159 --> 00:20:52,240
you can see that in a sense the

00:20:50,000 --> 00:20:55,679
probability waves collapse

00:20:52,240 --> 00:20:58,320
and the observable behavior

00:20:55,679 --> 00:20:58,880
of the physical machine must correspond

00:20:58,320 --> 00:21:00,960
to

00:20:58,880 --> 00:21:02,240
what would have been observed if the

00:21:00,960 --> 00:21:05,520
program was running

00:21:02,240 --> 00:21:05,520
on the abstract machine

00:21:06,080 --> 00:21:10,320
and as before at these points in the

00:21:08,320 --> 00:21:14,559
execution of the program

00:21:10,320 --> 00:21:14,559
the observable behavior must be

00:21:14,840 --> 00:21:18,880
equivalent

00:21:16,799 --> 00:21:21,200
so for example just to take another

00:21:18,880 --> 00:21:24,720
example suppose we have

00:21:21,200 --> 00:21:27,760
two threads t1 and t2

00:21:24,720 --> 00:21:29,760
and they execute in the time frame

00:21:27,760 --> 00:21:33,760
between this first interaction

00:21:29,760 --> 00:21:36,080
and this second interaction

00:21:33,760 --> 00:21:39,120
let's say that thread t1 does 20 units

00:21:36,080 --> 00:21:40,240
of work and thread t2 does 25 units of

00:21:39,120 --> 00:21:43,280
work

00:21:40,240 --> 00:21:46,320
and when they complete their work they

00:21:43,280 --> 00:21:49,039
write data to a file or

00:21:46,320 --> 00:21:53,120
send data to an output terminal or do

00:21:49,039 --> 00:21:53,120
something that causes a side effect

00:21:53,280 --> 00:22:00,559
well this is an allowable interaction

00:21:56,960 --> 00:22:02,400
this is correct observable behavior and

00:22:00,559 --> 00:22:03,679
there must have been a path in the

00:22:02,400 --> 00:22:08,080
abstract machine

00:22:03,679 --> 00:22:08,080
that ended in those two results

00:22:08,240 --> 00:22:15,600
likewise on a subsequent invocation

00:22:11,360 --> 00:22:20,159
of the program if t1 does 137 units of

00:22:15,600 --> 00:22:24,080
work and t2 does 1729

00:22:20,159 --> 00:22:27,120
then in a correct program

00:22:24,080 --> 00:22:28,480
with a conforming implementation the

00:22:27,120 --> 00:22:31,679
observable behavior

00:22:28,480 --> 00:22:32,640
those units of work must have must there

00:22:31,679 --> 00:22:35,440
must be a path

00:22:32,640 --> 00:22:38,960
in the execution of the abstract machine

00:22:35,440 --> 00:22:41,840
where that behavior would have occurred

00:22:38,960 --> 00:22:41,840
okay

00:22:42,559 --> 00:22:46,799
i'd like to also provide a couple more

00:22:45,200 --> 00:22:49,760
important definitions

00:22:46,799 --> 00:22:50,960
that uh go a long way to helping

00:22:49,760 --> 00:22:54,080
describe

00:22:50,960 --> 00:22:57,280
the abstract machine the first is

00:22:54,080 --> 00:22:57,280
well-formed program

00:22:57,520 --> 00:23:01,200
a well-formed program is one that's

00:22:59,360 --> 00:23:02,000
constructed according to the syntax

00:23:01,200 --> 00:23:04,400
rules

00:23:02,000 --> 00:23:06,960
the diagnosable semantic rules and the

00:23:04,400 --> 00:23:09,039
one definition rule

00:23:06,960 --> 00:23:10,159
and what this really means is this

00:23:09,039 --> 00:23:13,120
refers to

00:23:10,159 --> 00:23:16,880
a valid program valid at least as far as

00:23:13,120 --> 00:23:16,880
the implementation is concerned

00:23:18,000 --> 00:23:21,679
implementation defined behavior we've

00:23:19,760 --> 00:23:23,600
mentioned this before

00:23:21,679 --> 00:23:25,840
the standard says that this is behavior

00:23:23,600 --> 00:23:27,919
for a well-formed program

00:23:25,840 --> 00:23:30,799
a well-formed program and correct input

00:23:27,919 --> 00:23:34,960
data that depends on the implementation

00:23:30,799 --> 00:23:36,559
and that each implementation documents

00:23:34,960 --> 00:23:38,720
so what this is doing is this is

00:23:36,559 --> 00:23:40,720
referring to behaviors of a program that

00:23:38,720 --> 00:23:43,279
vary between implementations

00:23:40,720 --> 00:23:46,159
for example compiler x running on

00:23:43,279 --> 00:23:49,039
windows versus compiler x

00:23:46,159 --> 00:23:51,760
running on linux and this refers to

00:23:49,039 --> 00:23:55,200
again the parametrization aspect

00:23:51,760 --> 00:23:58,000
of the abstract machine

00:23:55,200 --> 00:23:58,799
so what are some examples well size of

00:23:58,000 --> 00:24:00,559
void

00:23:58,799 --> 00:24:02,559
i could have a compiler that runs on

00:24:00,559 --> 00:24:05,600
64-bit hardware

00:24:02,559 --> 00:24:06,480
and the same compiler run on 32-bit

00:24:05,600 --> 00:24:09,120
hardware

00:24:06,480 --> 00:24:09,600
and so the size of of a pointer will be

00:24:09,120 --> 00:24:12,240
different

00:24:09,600 --> 00:24:13,120
on each of those platforms and this is

00:24:12,240 --> 00:24:15,120
implementation

00:24:13,120 --> 00:24:16,799
defined behavior in that a compiler will

00:24:15,120 --> 00:24:19,679
document the fact that

00:24:16,799 --> 00:24:21,919
pointers have uh eight bytes a size of

00:24:19,679 --> 00:24:24,640
eight bytes on a 64-bit platform

00:24:21,919 --> 00:24:27,120
and a size of four bytes say on a 32-bit

00:24:24,640 --> 00:24:27,120
platform

00:24:28,080 --> 00:24:32,240
the value of char bit which indicates

00:24:30,080 --> 00:24:36,000
the number of bits in a byte

00:24:32,240 --> 00:24:38,480
which has to be at least eight

00:24:36,000 --> 00:24:40,400
the text that's returned by stood bad

00:24:38,480 --> 00:24:42,159
alec what

00:24:40,400 --> 00:24:43,840
implementations are free to substitute

00:24:42,159 --> 00:24:44,880
whatever message they want as long as

00:24:43,840 --> 00:24:46,080
they define

00:24:44,880 --> 00:24:48,640
what that message is in their

00:24:46,080 --> 00:24:49,840
documentation and finally locale

00:24:48,640 --> 00:24:51,679
specific behavior

00:24:49,840 --> 00:24:54,799
which depends on the implementation

00:24:51,679 --> 00:24:54,799
supplied locales

00:24:56,080 --> 00:25:01,760
next up is unspecified behavior and the

00:24:58,960 --> 00:25:05,440
standard says that unspecified behavior

00:25:01,760 --> 00:25:08,159
for welfare is for a well-formed program

00:25:05,440 --> 00:25:10,000
and correct data is behavior that

00:25:08,159 --> 00:25:12,000
depends on the implementation

00:25:10,000 --> 00:25:14,000
and as i mentioned before notice that

00:25:12,000 --> 00:25:15,760
there's no

00:25:14,000 --> 00:25:17,520
there's no mention of documentation in

00:25:15,760 --> 00:25:19,760
this case

00:25:17,520 --> 00:25:19,760
so

00:25:21,200 --> 00:25:25,840
the corollary that goes with this is

00:25:23,120 --> 00:25:27,760
that each unspecified behavior

00:25:25,840 --> 00:25:29,360
has to yield at least has to yield

00:25:27,760 --> 00:25:32,480
exactly one result from the set of

00:25:29,360 --> 00:25:36,159
all possible valid results remember

00:25:32,480 --> 00:25:38,000
that fuzzy diagram at those points of

00:25:36,159 --> 00:25:41,279
observable behavior

00:25:38,000 --> 00:25:42,000
when i observe some execution state

00:25:41,279 --> 00:25:44,240
information

00:25:42,000 --> 00:25:46,080
on physical machine there must have been

00:25:44,240 --> 00:25:48,240
some path of execution

00:25:46,080 --> 00:25:50,880
on the abstract machine that would have

00:25:48,240 --> 00:25:53,360
provided exactly the same results

00:25:50,880 --> 00:25:54,159
in this case i don't know what paths

00:25:53,360 --> 00:25:58,080
were taken

00:25:54,159 --> 00:26:00,760
and so that's unspecified behavior and

00:25:58,080 --> 00:26:02,480
this again this describes the

00:26:00,760 --> 00:26:05,679
non-deterministic aspect

00:26:02,480 --> 00:26:08,799
of the abstract machine so

00:26:05,679 --> 00:26:11,039
for example the order of evaluation of

00:26:08,799 --> 00:26:14,400
arguments in a function call

00:26:11,039 --> 00:26:18,480
if f takes two arguments and

00:26:14,400 --> 00:26:21,760
the first argument to f is a call to g

00:26:18,480 --> 00:26:23,679
and second call to f is a call to h

00:26:21,760 --> 00:26:24,880
the standard doesn't say whether g is

00:26:23,679 --> 00:26:27,279
going to be called first

00:26:24,880 --> 00:26:29,120
or h is going to be called first it

00:26:27,279 --> 00:26:30,480
leaves it up to the implementation

00:26:29,120 --> 00:26:32,720
and the implementation doesn't need to

00:26:30,480 --> 00:26:33,760
document it and in fact the order of

00:26:32,720 --> 00:26:36,400
evaluation

00:26:33,760 --> 00:26:37,440
of invoking g and h can vary within the

00:26:36,400 --> 00:26:39,200
same program

00:26:37,440 --> 00:26:42,640
there are no rules that say what order

00:26:39,200 --> 00:26:42,640
that in which that has to occur

00:26:42,880 --> 00:26:47,679
another unspecified behavior to pull

00:26:45,840 --> 00:26:51,039
another wild example out is whether

00:26:47,679 --> 00:26:52,240
identical string literals which occur

00:26:51,039 --> 00:26:54,799
which are sprinkled throughout your

00:26:52,240 --> 00:26:58,240
program are stored distinctly

00:26:54,799 --> 00:27:02,240
as separate copies of that string or

00:26:58,240 --> 00:27:02,240
as one copy of the string

00:27:04,559 --> 00:27:08,559
another uh important bit of unspecified

00:27:08,000 --> 00:27:11,760
behavior

00:27:08,559 --> 00:27:14,240
is the order the contiguity

00:27:11,760 --> 00:27:16,320
and the initial values value of storage

00:27:14,240 --> 00:27:18,880
that's returned by successive allocation

00:27:16,320 --> 00:27:18,880
requests

00:27:19,520 --> 00:27:22,799
when you allocate memory the compiler

00:27:21,760 --> 00:27:25,919
the implementation

00:27:22,799 --> 00:27:29,919
is under no obligation in a sense

00:27:25,919 --> 00:27:32,399
to conform to any sort of

00:27:29,919 --> 00:27:33,200
uh order of where the return memory

00:27:32,399 --> 00:27:35,120
exists

00:27:33,200 --> 00:27:36,320
or where the return buffer exists in

00:27:35,120 --> 00:27:38,399
memory

00:27:36,320 --> 00:27:40,799
it's under no obligation to say that if

00:27:38,399 --> 00:27:42,559
you do two allocations in a row that the

00:27:40,799 --> 00:27:44,000
second buffer is actually physically

00:27:42,559 --> 00:27:47,120
right after the first buffer

00:27:44,000 --> 00:27:49,120
or vice versa and it makes no promises

00:27:47,120 --> 00:27:51,360
regarding the initial value

00:27:49,120 --> 00:27:52,880
that lives in the bytes that are

00:27:51,360 --> 00:27:56,640
returned

00:27:52,880 --> 00:27:56,640
by that allocation request

00:27:58,080 --> 00:28:01,200
here's another very important concept

00:28:00,480 --> 00:28:04,399
that of

00:28:01,200 --> 00:28:04,399
undefined behavior

00:28:05,039 --> 00:28:09,760
undefined behavior well simply is

00:28:07,120 --> 00:28:11,760
behavior that is not defined or

00:28:09,760 --> 00:28:12,960
for which the document imposes no

00:28:11,760 --> 00:28:14,720
requirements

00:28:12,960 --> 00:28:16,480
by imposing no requirements it's not

00:28:14,720 --> 00:28:19,279
defining any behavior so it's

00:28:16,480 --> 00:28:20,960
undefined behavior in this case when

00:28:19,279 --> 00:28:22,399
undefined behavior occurs there's no

00:28:20,960 --> 00:28:23,520
restrictions on the behavior of the

00:28:22,399 --> 00:28:26,159
program

00:28:23,520 --> 00:28:29,200
compilers are not required to diagnose

00:28:26,159 --> 00:28:31,679
undefined behavior

00:28:29,200 --> 00:28:33,279
a program with undefined behavior is not

00:28:31,679 --> 00:28:35,600
actually required to do anything

00:28:33,279 --> 00:28:37,760
meaningful

00:28:35,600 --> 00:28:39,279
for example if you dereference a null

00:28:37,760 --> 00:28:42,159
pointer

00:28:39,279 --> 00:28:44,159
or access memory outside the bounds of

00:28:42,159 --> 00:28:46,399
an array

00:28:44,159 --> 00:28:47,600
you commit the sin of signed integer

00:28:46,399 --> 00:28:49,840
overflow

00:28:47,600 --> 00:28:52,159
or you access an object through a

00:28:49,840 --> 00:28:54,399
pointer of a different type

00:28:52,159 --> 00:28:55,360
all of these behaviors these are things

00:28:54,399 --> 00:28:57,120
that you can do

00:28:55,360 --> 00:28:58,799
but the standard says they're undefined

00:28:57,120 --> 00:29:00,399
behavior the standard makes no

00:28:58,799 --> 00:29:03,039
guarantees

00:29:00,399 --> 00:29:04,880
about what the implementation will do

00:29:03,039 --> 00:29:08,399
what the abstract machine will do

00:29:04,880 --> 00:29:08,399
if any of these behaviors occur

00:29:10,799 --> 00:29:15,200
let's talk about what ill-formed means

00:29:13,360 --> 00:29:18,320
an ill-formed program

00:29:15,200 --> 00:29:20,399
is a program that's not well-formed

00:29:18,320 --> 00:29:22,080
this is a program that has syntax errors

00:29:20,399 --> 00:29:24,840
or it has semantic errors that the

00:29:22,080 --> 00:29:26,159
compiler is smart enough to diagnose for

00:29:24,840 --> 00:29:30,480
you

00:29:26,159 --> 00:29:32,159
when ill form behavior occurs

00:29:30,480 --> 00:29:34,720
an implementation has to issue a

00:29:32,159 --> 00:29:36,640
diagnostic even if that implementation

00:29:34,720 --> 00:29:39,200
defines some language extension

00:29:36,640 --> 00:29:40,720
that assigns a meaning to such code so

00:29:39,200 --> 00:29:43,600
for example

00:29:40,720 --> 00:29:45,360
variable length arrays some compilers as

00:29:43,600 --> 00:29:47,919
an extension to the language define a

00:29:45,360 --> 00:29:50,159
facility called variable length arrays

00:29:47,919 --> 00:29:52,080
now this is a non-standard feature and

00:29:50,159 --> 00:29:54,320
by default your compiler

00:29:52,080 --> 00:29:55,840
is required to issue a diagnostic

00:29:54,320 --> 00:29:57,520
warning you that you're using this

00:29:55,840 --> 00:29:59,360
non-standard feature

00:29:57,520 --> 00:30:01,279
because it's non-standard now of course

00:29:59,360 --> 00:30:02,960
you can always uh

00:30:01,279 --> 00:30:04,799
tell the compiler not to provide you the

00:30:02,960 --> 00:30:06,159
warning but absent that explicit

00:30:04,799 --> 00:30:10,080
instruction to the compiler

00:30:06,159 --> 00:30:10,080
it has to tell you that

00:30:10,480 --> 00:30:16,240
that you're using an extension so

00:30:13,919 --> 00:30:16,960
the standard uses the words shall and

00:30:16,240 --> 00:30:18,720
shall not

00:30:16,960 --> 00:30:20,240
and ill-formed to indicate that

00:30:18,720 --> 00:30:21,120
requirement the requirements that have

00:30:20,240 --> 00:30:24,399
to be met

00:30:21,120 --> 00:30:27,919
for program to not be ill-formed for a

00:30:24,399 --> 00:30:27,919
program to be well-formed

00:30:29,039 --> 00:30:32,640
there's another characteristi

00:30:31,440 --> 00:30:35,200
characterization here

00:30:32,640 --> 00:30:36,399
which is called ill-formed no diagnostic

00:30:35,200 --> 00:30:38,640
required

00:30:36,399 --> 00:30:40,080
in this case this means that the program

00:30:38,640 --> 00:30:42,480
has semantic areas

00:30:40,080 --> 00:30:43,360
errors but those errors cannot be

00:30:42,480 --> 00:30:47,600
diagnosed

00:30:43,360 --> 00:30:50,000
at compile time so

00:30:47,600 --> 00:30:52,880
if you run a program that contains an

00:30:50,000 --> 00:30:55,520
ill-form no diagnostic required error

00:30:52,880 --> 00:30:56,320
the behavior of the program is undefined

00:30:55,520 --> 00:30:59,039
if you

00:30:56,320 --> 00:31:00,559
execute the program so what are some

00:30:59,039 --> 00:31:03,600
examples

00:31:00,559 --> 00:31:05,760
violations of the one definition rule

00:31:03,600 --> 00:31:08,720
when a constructor delegates to itself

00:31:05,760 --> 00:31:10,880
whether directly or indirectly

00:31:08,720 --> 00:31:12,399
declaring a function no return in one

00:31:10,880 --> 00:31:15,120
translation unit

00:31:12,399 --> 00:31:19,840
and declaring it without no return in

00:31:15,120 --> 00:31:19,840
another translation unit

00:31:20,159 --> 00:31:25,279
so let's dig in a little bit to the

00:31:22,720 --> 00:31:27,360
structure of the abstract machine

00:31:25,279 --> 00:31:29,200
there are i think of it as being three

00:31:27,360 --> 00:31:32,399
important pieces

00:31:29,200 --> 00:31:35,600
that the machine is made of

00:31:32,399 --> 00:31:38,880
first important piece is memory

00:31:35,600 --> 00:31:40,480
memory provides storage it provides

00:31:38,880 --> 00:31:46,559
storage for objects

00:31:40,480 --> 00:31:48,799
which for the most part reside in memory

00:31:46,559 --> 00:31:50,640
and the third leg of the stool is that

00:31:48,799 --> 00:31:53,600
we have threads

00:31:50,640 --> 00:31:54,080
threads are flows of control that carry

00:31:53,600 --> 00:31:57,120
out the

00:31:54,080 --> 00:31:58,000
operations that we have requested or

00:31:57,120 --> 00:32:01,200
specified

00:31:58,000 --> 00:32:04,159
in our program so let's dig into each of

00:32:01,200 --> 00:32:06,880
these things in a little more depth

00:32:04,159 --> 00:32:08,880
let's talk about memory first the

00:32:06,880 --> 00:32:09,440
abstract machine views memory as a

00:32:08,880 --> 00:32:13,200
single

00:32:09,440 --> 00:32:15,039
flat space all parts of memory

00:32:13,200 --> 00:32:18,240
in the abstract machine are equally

00:32:15,039 --> 00:32:20,080
reachable by the abstract machine

00:32:18,240 --> 00:32:22,640
there is no conception of memory

00:32:20,080 --> 00:32:25,360
hierarchy the abstract machine does not

00:32:22,640 --> 00:32:28,480
recognize the concept of stack

00:32:25,360 --> 00:32:30,159
registers or cache although

00:32:28,480 --> 00:32:32,480
incidentally stack unwinding is

00:32:30,159 --> 00:32:35,919
mentioned several times in regard to

00:32:32,480 --> 00:32:35,919
exceptions throughout the standard

00:32:36,399 --> 00:32:40,399
the abstract machine has no concept of

00:32:38,559 --> 00:32:43,039
heterogeneous memory for example

00:32:40,399 --> 00:32:44,559
memory that might exist on a gpu or a

00:32:43,039 --> 00:32:48,799
coprocessor

00:32:44,559 --> 00:32:50,559
or some other thing that is external to

00:32:48,799 --> 00:32:53,360
the processor on which your physical

00:32:50,559 --> 00:32:53,360
machine is running

00:32:54,880 --> 00:32:59,360
now taken together all of these imply

00:32:57,440 --> 00:33:00,960
that access to memory has uniform

00:32:59,360 --> 00:33:02,640
latency the standard doesn't

00:33:00,960 --> 00:33:05,039
say this explicitly but i think it's a

00:33:02,640 --> 00:33:07,840
fair conclusion to make

00:33:05,039 --> 00:33:09,440
given that it's a flat address space all

00:33:07,840 --> 00:33:11,120
parts are equally reachable and that

00:33:09,440 --> 00:33:13,679
there's no hierarchy

00:33:11,120 --> 00:33:15,360
otherwise if latency varied from one

00:33:13,679 --> 00:33:19,039
part of the abstract machine to the

00:33:15,360 --> 00:33:19,039
other there actually would be hierarchy

00:33:20,480 --> 00:33:24,240
memory is composed of bytes and the

00:33:22,480 --> 00:33:26,320
standard specifies the minimum

00:33:24,240 --> 00:33:28,240
requirements for what a byte is

00:33:26,320 --> 00:33:30,799
in terms of what it has to be able to

00:33:28,240 --> 00:33:30,799
represent

00:33:31,519 --> 00:33:36,159
the memory that's available to a program

00:33:34,480 --> 00:33:37,200
made available to the program by the

00:33:36,159 --> 00:33:39,200
abstract machine

00:33:37,200 --> 00:33:41,760
consists of one or more sequences of

00:33:39,200 --> 00:33:44,399
contiguous bytes

00:33:41,760 --> 00:33:45,360
and any operation that occurs in a

00:33:44,399 --> 00:33:47,600
program

00:33:45,360 --> 00:33:48,720
can potentially access any memory

00:33:47,600 --> 00:33:50,559
location

00:33:48,720 --> 00:33:52,240
in those sequences of bytes that the

00:33:50,559 --> 00:33:54,000
abstract machine has supplied to the

00:33:52,240 --> 00:33:56,240
program

00:33:54,000 --> 00:33:58,480
every byte has a unique location in

00:33:56,240 --> 00:34:00,559
memory its address

00:33:58,480 --> 00:34:04,000
and addresses are represented in our

00:34:00,559 --> 00:34:07,200
program by pointers

00:34:04,000 --> 00:34:10,960
let's move on to objects objects

00:34:07,200 --> 00:34:13,359
in a program create destroy refer access

00:34:10,960 --> 00:34:14,320
or i'm sorry operations create destroy

00:34:13,359 --> 00:34:17,520
refer access

00:34:14,320 --> 00:34:19,440
or manipulate objects objects have

00:34:17,520 --> 00:34:21,200
size which can be determined with size

00:34:19,440 --> 00:34:23,040
of they have alignment

00:34:21,200 --> 00:34:25,679
which can be determined with a line a

00:34:23,040 --> 00:34:28,000
line of they have storage duration

00:34:25,679 --> 00:34:29,200
which can be automatic static dynamic

00:34:28,000 --> 00:34:31,839
thread local

00:34:29,200 --> 00:34:32,399
they have a lifetime their temporaries

00:34:31,839 --> 00:34:34,720
or

00:34:32,399 --> 00:34:36,480
their lifetime is bounded by the storage

00:34:34,720 --> 00:34:37,679
duration of the storage in which they

00:34:36,480 --> 00:34:39,679
exist

00:34:37,679 --> 00:34:42,240
they have type which i think of as being

00:34:39,679 --> 00:34:43,760
a tag that specifies a representation

00:34:42,240 --> 00:34:45,280
and the valid set of values that

00:34:43,760 --> 00:34:47,679
representation can have

00:34:45,280 --> 00:34:50,720
along with behaviors that are allowed to

00:34:47,679 --> 00:34:52,560
occur with that representation

00:34:50,720 --> 00:34:54,560
it can have a value which can be

00:34:52,560 --> 00:34:57,839
indeterminate

00:34:54,560 --> 00:35:00,880
and optionally an object can have a name

00:34:57,839 --> 00:35:02,720
some objects in c plus have no name like

00:35:00,880 --> 00:35:04,880
the value that's returned

00:35:02,720 --> 00:35:07,280
when an object is returned from a from a

00:35:04,880 --> 00:35:09,119
function

00:35:07,280 --> 00:35:10,800
it's important to note that an object

00:35:09,119 --> 00:35:12,960
can have at most

00:35:10,800 --> 00:35:15,359
one memory location actually it can have

00:35:12,960 --> 00:35:17,920
zero or one memory locations

00:35:15,359 --> 00:35:19,040
because an implementation is allowed to

00:35:17,920 --> 00:35:21,359
store two objects

00:35:19,040 --> 00:35:22,720
at the same address or not store an

00:35:21,359 --> 00:35:26,560
object at all

00:35:22,720 --> 00:35:27,200
as long as the program can't observe the

00:35:26,560 --> 00:35:30,560
difference

00:35:27,200 --> 00:35:32,320
and this is the as if rule at work if

00:35:30,560 --> 00:35:34,960
storing two objects at the same memory

00:35:32,320 --> 00:35:37,599
location or not storing an object at all

00:35:34,960 --> 00:35:38,240
has no effect on observable behavior

00:35:37,599 --> 00:35:40,640
then

00:35:38,240 --> 00:35:44,560
the implementation is free to not

00:35:40,640 --> 00:35:47,040
actually store the object

00:35:44,560 --> 00:35:48,880
an object having a memory location is

00:35:47,040 --> 00:35:49,760
stored in a contiguous sequence of one

00:35:48,880 --> 00:35:51,359
or more bytes

00:35:49,760 --> 00:35:53,520
and here is just a little drawing

00:35:51,359 --> 00:35:57,040
showing an n32 existing

00:35:53,520 --> 00:35:58,320
in a sequence of bytes the address of an

00:35:57,040 --> 00:36:00,400
object stored in memory

00:35:58,320 --> 00:36:02,480
is always given by the address of its

00:36:00,400 --> 00:36:04,720
first byte and as i mentioned before the

00:36:02,480 --> 00:36:06,960
address is represented by a pointer

00:36:04,720 --> 00:36:09,440
and pointers are themselves kinds of

00:36:06,960 --> 00:36:09,440
objects

00:36:09,760 --> 00:36:13,359
arrays of objects and data members of

00:36:12,240 --> 00:36:15,920
classes

00:36:13,359 --> 00:36:17,119
may or may not occupy contiguous

00:36:15,920 --> 00:36:18,720
sequences of bytes

00:36:17,119 --> 00:36:20,160
in other words structure padding is

00:36:18,720 --> 00:36:23,359
permitted

00:36:20,160 --> 00:36:25,760
however as we all know we index

00:36:23,359 --> 00:36:26,640
arrays contiguously even though the

00:36:25,760 --> 00:36:29,359
elements in our

00:36:26,640 --> 00:36:31,040
in array may have padding in them so the

00:36:29,359 --> 00:36:33,680
little picture on the top

00:36:31,040 --> 00:36:34,880
shows two different variables x and y

00:36:33,680 --> 00:36:36,960
laid out in memory

00:36:34,880 --> 00:36:40,079
and it just so happens that y comes

00:36:36,960 --> 00:36:43,280
immediately after x

00:36:40,079 --> 00:36:44,640
now these are 32-bit integers consisting

00:36:43,280 --> 00:36:46,320
of four bytes each

00:36:44,640 --> 00:36:48,800
and i'm assuming that i have four byte

00:36:46,320 --> 00:36:51,040
alignment of my data in this picture

00:36:48,800 --> 00:36:52,400
in the picture at the bottom i have a

00:36:51,040 --> 00:36:54,960
type a struct called

00:36:52,400 --> 00:36:56,480
s and s consists of a short and i'm

00:36:54,960 --> 00:36:57,200
assuming that it has two bytes in this

00:36:56,480 --> 00:37:00,320
picture

00:36:57,200 --> 00:37:03,119
and it has a char which is one byte now

00:37:00,320 --> 00:37:05,680
also assuming four byte alignment

00:37:03,119 --> 00:37:06,160
an array of three elements of type

00:37:05,680 --> 00:37:08,720
struct

00:37:06,160 --> 00:37:10,720
s will be laid out as you see and there

00:37:08,720 --> 00:37:13,040
will be

00:37:10,720 --> 00:37:15,040
there will be a little gap an unused

00:37:13,040 --> 00:37:18,560
bite

00:37:15,040 --> 00:37:23,599
between successive elements

00:37:18,560 --> 00:37:26,560
this is perfectly allowable

00:37:23,599 --> 00:37:27,040
now pointers can point to the one past

00:37:26,560 --> 00:37:29,680
the end

00:37:27,040 --> 00:37:31,440
element of an array and one past the end

00:37:29,680 --> 00:37:33,839
element of an object

00:37:31,440 --> 00:37:35,280
so if i have a pointer if i have an

00:37:33,839 --> 00:37:37,359
object x

00:37:35,280 --> 00:37:38,560
and i have a pointer px that points to

00:37:37,359 --> 00:37:41,280
it

00:37:38,560 --> 00:37:42,640
i'm allowed to form a pointer i'll call

00:37:41,280 --> 00:37:47,359
it pe

00:37:42,640 --> 00:37:50,480
that points to byte immediately after

00:37:47,359 --> 00:37:53,680
x this is a perfectly allowable

00:37:50,480 --> 00:37:55,920
and supported operation likewise

00:37:53,680 --> 00:37:57,680
if i have an array my my original array

00:37:55,920 --> 00:38:01,200
of three elements of type struct

00:37:57,680 --> 00:38:04,079
s i'm allowed to form a pointer

00:38:01,200 --> 00:38:05,520
to what would to the end the end point

00:38:04,079 --> 00:38:08,400
or the one past

00:38:05,520 --> 00:38:09,599
uh the one past end pointer which occurs

00:38:08,400 --> 00:38:12,400
at the place

00:38:09,599 --> 00:38:14,320
where a fourth element would have been

00:38:12,400 --> 00:38:19,839
had there been fourth elements and

00:38:14,320 --> 00:38:19,839
clearly i've got a little typo there

00:38:19,920 --> 00:38:23,839
pointers to objects can be compared in

00:38:22,000 --> 00:38:26,320
certain circumstances

00:38:23,839 --> 00:38:28,000
for equality and inequality when they

00:38:26,320 --> 00:38:30,079
point to the same type

00:38:28,000 --> 00:38:31,040
for ordering when they point to elements

00:38:30,079 --> 00:38:32,800
of the same array

00:38:31,040 --> 00:38:34,560
and for ordering when pointing to data

00:38:32,800 --> 00:38:36,720
members of the same class

00:38:34,560 --> 00:38:37,839
so here's another little example with my

00:38:36,720 --> 00:38:41,119
mislabeled three

00:38:37,839 --> 00:38:42,880
three element array and another element

00:38:41,119 --> 00:38:46,640
of type s that happens to be

00:38:42,880 --> 00:38:49,119
instantiated afterward so

00:38:46,640 --> 00:38:50,720
here's my code i've got my struct s i'm

00:38:49,119 --> 00:38:52,560
creating a three element array

00:38:50,720 --> 00:38:54,000
and i'm creating an individual object of

00:38:52,560 --> 00:38:55,760
that type

00:38:54,000 --> 00:38:57,280
and it just so happens in this case the

00:38:55,760 --> 00:39:00,640
compiler laid it out

00:38:57,280 --> 00:39:03,440
in this in this fashion so

00:39:00,640 --> 00:39:04,160
which comparisons are allowed well i can

00:39:03,440 --> 00:39:07,359
compare

00:39:04,160 --> 00:39:09,760
pb this address with pe because they're

00:39:07,359 --> 00:39:13,680
elements of the same array

00:39:09,760 --> 00:39:16,000
i can compare for equality pb with px

00:39:13,680 --> 00:39:18,560
which is the pointer to x because

00:39:16,000 --> 00:39:21,119
they're pointers to the same type

00:39:18,560 --> 00:39:23,119
i can also compare p d p b to p x for

00:39:21,119 --> 00:39:26,480
inequality

00:39:23,119 --> 00:39:27,200
i can order i can compare p b to p e for

00:39:26,480 --> 00:39:30,480
ordering

00:39:27,200 --> 00:39:33,119
because pb and pe are both elements

00:39:30,480 --> 00:39:33,680
both point to elements in the same array

00:39:33,119 --> 00:39:37,599
however

00:39:33,680 --> 00:39:40,240
i cannot compare pb to px

00:39:37,599 --> 00:39:41,520
even if x is in the spot where a fourth

00:39:40,240 --> 00:39:42,560
element of that array might have

00:39:41,520 --> 00:39:47,520
occurred

00:39:42,560 --> 00:39:51,040
because x is not an element of the array

00:39:47,520 --> 00:39:53,359
s and it's not the one past n pointer

00:39:51,040 --> 00:39:53,359
either

00:39:54,800 --> 00:39:58,320
another property of objects is that they

00:39:56,960 --> 00:40:00,640
have a property called

00:39:58,320 --> 00:40:02,079
storage duration as i mentioned there

00:40:00,640 --> 00:40:04,480
are four kinds of storage duration

00:40:02,079 --> 00:40:07,119
there's automatic storage duration

00:40:04,480 --> 00:40:09,119
where object storage is allocated at the

00:40:07,119 --> 00:40:11,119
beginning of summon closing block

00:40:09,119 --> 00:40:12,800
and deallocated at the end of the block

00:40:11,119 --> 00:40:14,480
and this is the kind of storage duration

00:40:12,800 --> 00:40:16,000
that we're probably most familiar with

00:40:14,480 --> 00:40:18,240
when we're writing code inside a

00:40:16,000 --> 00:40:20,800
function we declare a variable

00:40:18,240 --> 00:40:21,280
to do something inside that function

00:40:20,800 --> 00:40:25,760
that's

00:40:21,280 --> 00:40:28,079
automatic storage automatic duration

00:40:25,760 --> 00:40:29,280
this applies to all local objects in our

00:40:28,079 --> 00:40:30,640
code

00:40:29,280 --> 00:40:32,960
objects that are defined inside of

00:40:30,640 --> 00:40:33,760
blocks except those that are declared

00:40:32,960 --> 00:40:37,920
thread local

00:40:33,760 --> 00:40:39,280
static or external we also have dynamic

00:40:37,920 --> 00:40:41,040
storage duration

00:40:39,280 --> 00:40:43,359
this is storage duration that we as

00:40:41,040 --> 00:40:47,119
programmers have explicit control over

00:40:43,359 --> 00:40:48,960
and in this case our object storage

00:40:47,119 --> 00:40:51,280
is allocated and deallocated by the

00:40:48,960 --> 00:40:52,960
program using functions to perform

00:40:51,280 --> 00:40:55,359
dynamic memory allocation

00:40:52,960 --> 00:40:57,440
right objects with this duration are

00:40:55,359 --> 00:40:59,599
created using new expressions

00:40:57,440 --> 00:41:02,640
i.e the new operator and they're

00:40:59,599 --> 00:41:07,599
destroyed using delete expressions

00:41:02,640 --> 00:41:09,920
like using the delete operator

00:41:07,599 --> 00:41:12,079
we have static storage duration where

00:41:09,920 --> 00:41:13,920
object storage is allocated for

00:41:12,079 --> 00:41:16,400
at the beginning of a program and it's

00:41:13,920 --> 00:41:18,400
deallocated at the end of the program

00:41:16,400 --> 00:41:20,079
in other words it's storage is allocated

00:41:18,400 --> 00:41:22,240
before main is entered

00:41:20,079 --> 00:41:24,400
and it is deallocated after main is

00:41:22,240 --> 00:41:27,599
exited

00:41:24,400 --> 00:41:29,440
static storage duration storage applies

00:41:27,599 --> 00:41:30,640
to all objects that are declared at

00:41:29,440 --> 00:41:33,200
namespace scope

00:41:30,640 --> 00:41:34,079
including the global namespace this is

00:41:33,200 --> 00:41:37,119
where global

00:41:34,079 --> 00:41:37,920
variables live or file file global

00:41:37,119 --> 00:41:40,560
variables

00:41:37,920 --> 00:41:41,839
live this also applies to any object

00:41:40,560 --> 00:41:44,960
that's declared static

00:41:41,839 --> 00:41:49,040
or extern those objects are all stored

00:41:44,960 --> 00:41:50,720
in storage which has static duration

00:41:49,040 --> 00:41:52,640
the consequence of this is that there's

00:41:50,720 --> 00:41:53,599
only one instance of an object with a

00:41:52,640 --> 00:41:55,520
given name

00:41:53,599 --> 00:41:57,520
with static duration in the entire

00:41:55,520 --> 00:41:59,440
program

00:41:57,520 --> 00:42:00,560
we also have thread storage duration

00:41:59,440 --> 00:42:02,880
something that came with c

00:42:00,560 --> 00:42:04,400
plus 11 and this is object storage

00:42:02,880 --> 00:42:06,079
that's allocated when the thread

00:42:04,400 --> 00:42:07,920
creating the object begins

00:42:06,079 --> 00:42:09,280
and it's deallocating when that threat

00:42:07,920 --> 00:42:11,920
deallocated when that thread

00:42:09,280 --> 00:42:13,599
ends this applies only to objects

00:42:11,920 --> 00:42:16,640
declared thread local

00:42:13,599 --> 00:42:19,119
this is automatic storage that's

00:42:16,640 --> 00:42:21,119
tightly bound to a thread and the

00:42:19,119 --> 00:42:22,560
storage exists when the thread starts

00:42:21,119 --> 00:42:25,280
and the storage is released when the

00:42:22,560 --> 00:42:27,440
thread ends

00:42:25,280 --> 00:42:29,599
in this particular case every thread has

00:42:27,440 --> 00:42:33,599
its own instance of an object

00:42:29,599 --> 00:42:33,599
if that object has thread duration

00:42:34,000 --> 00:42:37,040
an object has lifetime and the lifetime

00:42:36,640 --> 00:42:40,480
of an

00:42:37,040 --> 00:42:42,000
object of type t begins when storage of

00:42:40,480 --> 00:42:44,160
the proper size and alignment

00:42:42,000 --> 00:42:45,920
is obtained or whatever that storage

00:42:44,160 --> 00:42:48,560
duration might be

00:42:45,920 --> 00:42:50,240
and its initialization is complete in

00:42:48,560 --> 00:42:52,079
other words

00:42:50,240 --> 00:42:53,760
after the after the constructor is

00:42:52,079 --> 00:42:56,720
executed

00:42:53,760 --> 00:42:57,599
the lifetime of some object obj of that

00:42:56,720 --> 00:43:00,640
type t

00:42:57,599 --> 00:43:04,319
ends when the object is destroyed if t

00:43:00,640 --> 00:43:07,520
is a non-class type like say an int

00:43:04,319 --> 00:43:10,640
or the destructor call starts

00:43:07,520 --> 00:43:12,079
if t is a class type like string

00:43:10,640 --> 00:43:14,400
and finally there's another condition

00:43:12,079 --> 00:43:16,640
having to do with reusing storage

00:43:14,400 --> 00:43:18,800
uh when storage of the object occupies

00:43:16,640 --> 00:43:22,079
is released or reused by an object

00:43:18,800 --> 00:43:24,240
that's not nested within obj

00:43:22,079 --> 00:43:25,599
so basically this conforms to our common

00:43:24,240 --> 00:43:27,839
sense

00:43:25,599 --> 00:43:29,520
the lifetime of an object is strictly

00:43:27,839 --> 00:43:30,240
contained within the lifetime of the

00:43:29,520 --> 00:43:32,319
storage

00:43:30,240 --> 00:43:33,920
that contains the object and the

00:43:32,319 --> 00:43:36,960
object's lifetime

00:43:33,920 --> 00:43:39,520
begins from our perspective after the

00:43:36,960 --> 00:43:41,839
object is constructed or initialized

00:43:39,520 --> 00:43:45,040
and it ends immediately before the

00:43:41,839 --> 00:43:45,040
object is destroyed

00:43:46,079 --> 00:43:49,200
let's talk about threads a thread of

00:43:48,000 --> 00:43:50,880
execution

00:43:49,200 --> 00:43:52,880
is a single flow of control within the

00:43:50,880 --> 00:43:55,119
program and importantly

00:43:52,880 --> 00:43:57,520
this includes the initial invocation of

00:43:55,119 --> 00:44:00,319
a specific top-level function

00:43:57,520 --> 00:44:00,800
and it recursively includes all of the

00:44:00,319 --> 00:44:02,800
function

00:44:00,800 --> 00:44:04,960
invocations that are subsequently

00:44:02,800 --> 00:44:07,119
executed by the thread

00:44:04,960 --> 00:44:08,000
so when a thread starts there's a top

00:44:07,119 --> 00:44:10,000
level function the

00:44:08,000 --> 00:44:12,800
thread function and that thread is

00:44:10,000 --> 00:44:15,040
responsible for executing

00:44:12,800 --> 00:44:16,160
all of the functions that are

00:44:15,040 --> 00:44:19,760
subsequently called

00:44:16,160 --> 00:44:22,160
inside of that top level function and

00:44:19,760 --> 00:44:23,359
of course as we all know a c program can

00:44:22,160 --> 00:44:26,240
have more than one thread

00:44:23,359 --> 00:44:26,240
running concurrently

00:44:27,040 --> 00:44:30,240
every thread in a program can

00:44:28,880 --> 00:44:32,240
potentially access

00:44:30,240 --> 00:44:33,599
every object and function in the program

00:44:32,240 --> 00:44:35,280
and this is a consequence

00:44:33,599 --> 00:44:38,480
of the rules the guidelines that we

00:44:35,280 --> 00:44:41,599
mentioned regarding memory

00:44:38,480 --> 00:44:43,280
so when a thread creates another thread

00:44:41,599 --> 00:44:45,280
the initial call to the top level

00:44:43,280 --> 00:44:48,000
function of that new thread

00:44:45,280 --> 00:44:48,960
the thread function is executed by the

00:44:48,000 --> 00:44:52,400
new thread

00:44:48,960 --> 00:44:52,400
not by the creating thread

00:44:53,440 --> 00:44:57,040
well of course there's one very special

00:44:55,200 --> 00:44:58,720
top-level function that we all use and

00:44:57,040 --> 00:45:00,560
that's main

00:44:58,720 --> 00:45:02,240
and there are several rules that go

00:45:00,560 --> 00:45:04,319
along with main

00:45:02,240 --> 00:45:05,280
restrictions on how it can be used it

00:45:04,319 --> 00:45:07,760
has to have c

00:45:05,280 --> 00:45:09,119
plus liquid linkage an implementation

00:45:07,760 --> 00:45:11,200
has to provide

00:45:09,119 --> 00:45:13,280
at least these two forms of the main

00:45:11,200 --> 00:45:14,400
function although an implementation can

00:45:13,280 --> 00:45:16,000
provide more

00:45:14,400 --> 00:45:18,880
it can't be overloaded it can't be a

00:45:16,000 --> 00:45:21,280
co-routine main cannot be called

00:45:18,880 --> 00:45:22,000
from within a program it can't be

00:45:21,280 --> 00:45:23,839
deleted

00:45:22,000 --> 00:45:27,599
it can't be static inline or const

00:45:23,839 --> 00:45:27,599
expert and so on

00:45:28,400 --> 00:45:32,800
importantly maine is the entry point for

00:45:30,560 --> 00:45:35,760
the program

00:45:32,800 --> 00:45:37,839
so when you execute a program what

00:45:35,760 --> 00:45:40,880
happens is the outside environment

00:45:37,839 --> 00:45:42,720
starts the main thread of execution

00:45:40,880 --> 00:45:44,720
does some initialization and then it

00:45:42,720 --> 00:45:47,280
calls main

00:45:44,720 --> 00:45:47,839
that initialization is initializing

00:45:47,280 --> 00:45:50,240
objects

00:45:47,839 --> 00:45:52,160
of static storage duration the

00:45:50,240 --> 00:45:53,280
initialization occurs before main is

00:45:52,160 --> 00:45:55,920
called

00:45:53,280 --> 00:45:57,280
and that storage is destroyed after main

00:45:55,920 --> 00:45:59,200
exits

00:45:57,280 --> 00:46:00,319
every program therefore must have at

00:45:59,200 --> 00:46:03,359
least one thread

00:46:00,319 --> 00:46:06,480
the main thread and

00:46:03,359 --> 00:46:10,560
the top level function for every program

00:46:06,480 --> 00:46:12,560
is main so what does it mean to invoke

00:46:10,560 --> 00:46:14,319
and execute main

00:46:12,560 --> 00:46:16,160
well that takes us to the question what

00:46:14,319 --> 00:46:17,440
does it mean to invoke and execute a

00:46:16,160 --> 00:46:19,040
function in general

00:46:17,440 --> 00:46:21,040
well we know functions consist of

00:46:19,040 --> 00:46:22,240
statements statements consist of

00:46:21,040 --> 00:46:23,839
expressions

00:46:22,240 --> 00:46:26,079
we also know that an expression is a

00:46:23,839 --> 00:46:28,319
sequence of operators and operands that

00:46:26,079 --> 00:46:30,480
specify a computation

00:46:28,319 --> 00:46:31,359
and that the expression must be

00:46:30,480 --> 00:46:34,640
evaluated

00:46:31,359 --> 00:46:36,000
to actually do the computation when we

00:46:34,640 --> 00:46:38,640
evaluate an expression

00:46:36,000 --> 00:46:40,560
we get we can get a result and the

00:46:38,640 --> 00:46:43,920
process of getting that result can cause

00:46:40,560 --> 00:46:46,319
side effects so in summary

00:46:43,920 --> 00:46:47,280
evaluating expressions that cause side

00:46:46,319 --> 00:46:49,200
effects

00:46:47,280 --> 00:46:50,560
can result in changes to the program's

00:46:49,200 --> 00:46:53,200
execution state

00:46:50,560 --> 00:46:55,119
and possibly to the observable behavior

00:46:53,200 --> 00:46:56,960
and here i provided this bullet

00:46:55,119 --> 00:46:58,400
sort of tie into that list of

00:46:56,960 --> 00:46:59,760
characteristics that we

00:46:58,400 --> 00:47:02,400
put together at the beginning of the

00:46:59,760 --> 00:47:02,400
presentation

00:47:04,160 --> 00:47:08,480
every c plus plus expression has an

00:47:06,400 --> 00:47:11,119
associated type

00:47:08,480 --> 00:47:13,119
and every c plus plus expression is a

00:47:11,119 --> 00:47:14,800
member of a value category

00:47:13,119 --> 00:47:17,440
you've probably all seen this little

00:47:14,800 --> 00:47:17,440
diagram

00:47:17,599 --> 00:47:21,200
which is used really to help explain

00:47:19,599 --> 00:47:25,839
what our value objects are

00:47:21,200 --> 00:47:25,839
and what l value objects are

00:47:26,559 --> 00:47:30,960
so i'll give a quick overview a gl

00:47:28,960 --> 00:47:33,599
values an expression

00:47:30,960 --> 00:47:34,480
that basically uses the name of an

00:47:33,599 --> 00:47:36,960
object

00:47:34,480 --> 00:47:38,800
if you take the name of an object if you

00:47:36,960 --> 00:47:41,200
use its name if you take its

00:47:38,800 --> 00:47:42,800
address if you return a reference to an

00:47:41,200 --> 00:47:44,240
object from a function if you pass a

00:47:42,800 --> 00:47:49,760
reference

00:47:44,240 --> 00:47:49,760
that is a gl value a generalized l value

00:47:50,079 --> 00:47:53,680
on the other side of the coin is a pr

00:47:51,920 --> 00:47:55,440
value and the p stands

00:47:53,680 --> 00:47:57,040
i think for pure at least it's been said

00:47:55,440 --> 00:47:59,440
that p stands for pure

00:47:57,040 --> 00:48:00,880
and a pr value is an expression that

00:47:59,440 --> 00:48:04,319
initializes an object

00:48:00,880 --> 00:48:06,079
or bit field and computes the value of

00:48:04,319 --> 00:48:08,160
the operand of an operator

00:48:06,079 --> 00:48:10,400
as specified in the context in which it

00:48:08,160 --> 00:48:13,040
occurs so what are some examples

00:48:10,400 --> 00:48:14,400
literals are examples of pr value they

00:48:13,040 --> 00:48:16,720
don't have names and you can't take

00:48:14,400 --> 00:48:18,160
their address

00:48:16,720 --> 00:48:20,400
function calls that return a

00:48:18,160 --> 00:48:21,280
non-reference type like returning by

00:48:20,400 --> 00:48:23,440
value

00:48:21,280 --> 00:48:25,280
if you return a string from some

00:48:23,440 --> 00:48:28,160
function that string

00:48:25,280 --> 00:48:28,160
is an r value

00:48:28,400 --> 00:48:36,240
an x value is a gl value

00:48:33,040 --> 00:48:38,400
whose resources can be reused so

00:48:36,240 --> 00:48:40,079
an x-value expression has an address

00:48:38,400 --> 00:48:40,800
that's no longer accessible by your

00:48:40,079 --> 00:48:42,400
program

00:48:40,800 --> 00:48:44,800
but you can use it to initialize an

00:48:42,400 --> 00:48:46,240
r-value reference which provides access

00:48:44,800 --> 00:48:48,559
to the expression

00:48:46,240 --> 00:48:51,359
so an example here function calls that

00:48:48,559 --> 00:48:54,240
return an r-value reference

00:48:51,359 --> 00:48:55,040
like stood move or casting to an r-value

00:48:54,240 --> 00:48:57,200
reference

00:48:55,040 --> 00:48:59,680
or any expression that designates a

00:48:57,200 --> 00:49:02,640
temporary object

00:48:59,680 --> 00:49:04,079
and then finally an l value is very

00:49:02,640 --> 00:49:07,359
helpfully defined as being

00:49:04,079 --> 00:49:08,880
a gl value that's not an x value and an

00:49:07,359 --> 00:49:13,760
r value

00:49:08,880 --> 00:49:16,800
is either a pr value or an x value

00:49:13,760 --> 00:49:18,480
so as we learned a program in c plus we

00:49:16,800 --> 00:49:21,680
develop some intuition

00:49:18,480 --> 00:49:25,040
about objects and after

00:49:21,680 --> 00:49:26,559
some experience we begin to understand

00:49:25,040 --> 00:49:28,559
when we can take the address of

00:49:26,559 --> 00:49:30,240
something and

00:49:28,559 --> 00:49:31,680
it's sort of a rough guideline but it's

00:49:30,240 --> 00:49:35,040
a useful guideline

00:49:31,680 --> 00:49:37,200
if you have the name of something and

00:49:35,040 --> 00:49:38,880
you can use that name or you can take

00:49:37,200 --> 00:49:40,400
the address of that thing

00:49:38,880 --> 00:49:42,319
then in general you can think of it as

00:49:40,400 --> 00:49:45,440
being an l value

00:49:42,319 --> 00:49:47,119
if that thing doesn't have a name or

00:49:45,440 --> 00:49:49,599
it's a temporary

00:49:47,119 --> 00:49:51,440
or you can't take its address then think

00:49:49,599 --> 00:49:53,040
of it as being an r value

00:49:51,440 --> 00:49:55,440
now that's not a perfectly correct

00:49:53,040 --> 00:49:57,040
characterization but in my experience

00:49:55,440 --> 00:50:00,400
for a typical day-to-day work

00:49:57,040 --> 00:50:00,400
it's good enough and it works

00:50:01,200 --> 00:50:05,359
so functions consist of statements

00:50:03,119 --> 00:50:07,359
statements consist of expressions

00:50:05,359 --> 00:50:10,400
and expressions a sequence of operators

00:50:07,359 --> 00:50:11,920
and operands that specify a computation

00:50:10,400 --> 00:50:13,760
when we evaluate an expression that

00:50:11,920 --> 00:50:16,240
causes side effects we can

00:50:13,760 --> 00:50:18,079
have changes that we can change the

00:50:16,240 --> 00:50:21,520
program's execution state and

00:50:18,079 --> 00:50:23,760
and possibly affect observable behavior

00:50:21,520 --> 00:50:26,000
the rules that govern the evaluation of

00:50:23,760 --> 00:50:27,920
expressions are formulated in terms

00:50:26,000 --> 00:50:30,319
of an expressions type and value

00:50:27,920 --> 00:50:32,559
category that's why i covered them

00:50:30,319 --> 00:50:35,040
the idea of an expression having a type

00:50:32,559 --> 00:50:37,599
and a value category is the basis

00:50:35,040 --> 00:50:39,359
for all the rules or i guess probably

00:50:37,599 --> 00:50:41,839
most of the rules in the standard

00:50:39,359 --> 00:50:42,960
that describe how an expression is to be

00:50:41,839 --> 00:50:46,319
evaluated

00:50:42,960 --> 00:50:48,720
and type and category are two

00:50:46,319 --> 00:50:50,160
two important parameters into that

00:50:48,720 --> 00:50:51,760
equation if you will

00:50:50,160 --> 00:50:55,599
that determines the outcome of

00:50:51,760 --> 00:50:58,800
evaluating an expression

00:50:55,599 --> 00:50:58,800
so in summary

00:50:58,880 --> 00:51:04,400
our programs describe operations that

00:51:01,119 --> 00:51:07,280
are performed on the abstract machine

00:51:04,400 --> 00:51:08,720
as i've tried to denote in this diagram

00:51:07,280 --> 00:51:11,680
we create source code

00:51:08,720 --> 00:51:12,720
we feed it to a compiler the compiler

00:51:11,680 --> 00:51:16,319
effectively

00:51:12,720 --> 00:51:19,599
emulates that program running on the c

00:51:16,319 --> 00:51:19,599
plus abstract machine

00:51:20,160 --> 00:51:24,640
implementations translate abstract

00:51:22,559 --> 00:51:25,839
machine operations into physical machine

00:51:24,640 --> 00:51:29,280
operations

00:51:25,839 --> 00:51:31,839
and so here we have the compiler

00:51:29,280 --> 00:51:33,119
taking uh mapping the operations from

00:51:31,839 --> 00:51:36,000
the abstract machine

00:51:33,119 --> 00:51:36,559
into machine code and stitching it

00:51:36,000 --> 00:51:38,240
together

00:51:36,559 --> 00:51:40,960
to create an executable that runs on a

00:51:38,240 --> 00:51:40,960
physical machine

00:51:41,200 --> 00:51:45,200
implementations must emulate the

00:51:43,359 --> 00:51:47,520
observable behavior of the abstract

00:51:45,200 --> 00:51:50,559
machine

00:51:47,520 --> 00:51:52,160
so here we have some indeterminate

00:51:50,559 --> 00:51:54,960
non-deterministic behavior that's

00:51:52,160 --> 00:51:57,520
occurring in the physical machine

00:51:54,960 --> 00:51:58,960
and we get some observable behavior at a

00:51:57,520 --> 00:52:02,640
point of interaction

00:51:58,960 --> 00:52:04,800
there must be in a correct implement

00:52:02,640 --> 00:52:06,800
in a conforming implementation and a

00:52:04,800 --> 00:52:08,880
correct program with correct data

00:52:06,800 --> 00:52:11,200
there must be an equivalent path of

00:52:08,880 --> 00:52:13,040
execution through the abstract machine

00:52:11,200 --> 00:52:14,720
that leads to the same observable

00:52:13,040 --> 00:52:18,640
behavior at that point

00:52:14,720 --> 00:52:20,880
of execution

00:52:18,640 --> 00:52:21,680
finally the abstract machine has memory

00:52:20,880 --> 00:52:24,880
that provides

00:52:21,680 --> 00:52:25,920
storage storage for objects which for

00:52:24,880 --> 00:52:29,200
the most part

00:52:25,920 --> 00:52:31,119
reside in that storage and threads which

00:52:29,200 --> 00:52:35,280
are flows of control that carry out the

00:52:31,119 --> 00:52:37,200
operations specified by the program

00:52:35,280 --> 00:52:40,240
and here's again a very simple picture

00:52:37,200 --> 00:52:43,119
of the abstract machine

00:52:40,240 --> 00:52:44,480
so in summary again the one point you

00:52:43,119 --> 00:52:46,079
should take away from this if you take

00:52:44,480 --> 00:52:48,880
nothing else away

00:52:46,079 --> 00:52:50,240
when you write c plus code you're not

00:52:48,880 --> 00:52:52,640
targeting a particular

00:52:50,240 --> 00:52:54,480
physical machine unless you know you're

00:52:52,640 --> 00:52:57,200
writing device drivers something

00:52:54,480 --> 00:52:58,720
you're not targeting specific hardware

00:52:57,200 --> 00:53:01,839
you're targeting the c

00:52:58,720 --> 00:53:01,839
plus abstract machine

00:53:02,160 --> 00:53:09,200
okay thanks for attending uh

00:53:06,640 --> 00:53:10,720
later today this talk and my second talk

00:53:09,200 --> 00:53:13,520
will be up on my github site

00:53:10,720 --> 00:53:14,559
and there's the url for my blog and so

00:53:13,520 --> 00:53:18,000
now i'm going to

00:53:14,559 --> 00:53:18,640
move over to remo and answer some

00:53:18,000 --> 00:53:20,960
questions

00:53:18,640 --> 00:53:29,839
perhaps for the next three minutes so

00:53:20,960 --> 00:53:29,839
let me go there

00:53:38,160 --> 00:53:41,520
okay so there's a question here the

00:53:40,640 --> 00:53:43,040
question is

00:53:41,520 --> 00:53:44,559
you said that there is no room for

00:53:43,040 --> 00:53:47,680
another language between c

00:53:44,559 --> 00:53:49,920
plus plus and the hardware how does llvm

00:53:47,680 --> 00:53:53,920
fit into this

00:53:49,920 --> 00:53:56,960
well i'm not an llvm developer

00:53:53,920 --> 00:53:59,839
so my understanding of llvm

00:53:56,960 --> 00:54:01,520
is that it is a set of tools for

00:53:59,839 --> 00:54:05,040
developing compilers

00:54:01,520 --> 00:54:08,000
and part of that set of tools is clang

00:54:05,040 --> 00:54:09,359
the c plus plus compiler and in clang it

00:54:08,000 --> 00:54:12,800
implements the code

00:54:09,359 --> 00:54:16,000
that that describes the c

00:54:12,800 --> 00:54:18,160
plus abstract machine now i as

00:54:16,000 --> 00:54:20,000
i think that historically llvm was

00:54:18,160 --> 00:54:21,599
intended originally meant low level

00:54:20,000 --> 00:54:22,480
virtual machine and perhaps it still

00:54:21,599 --> 00:54:24,319
does

00:54:22,480 --> 00:54:26,240
but it doesn't indicate any sort of

00:54:24,319 --> 00:54:29,119
layer between

00:54:26,240 --> 00:54:31,119
uh between the compiler or between an

00:54:29,119 --> 00:54:33,839
executing program

00:54:31,119 --> 00:54:35,839
and the hardware it's simply a set of

00:54:33,839 --> 00:54:36,640
tools well not simply it is a great set

00:54:35,839 --> 00:54:39,440
of tools

00:54:36,640 --> 00:54:41,119
that allow you to build a compiler clang

00:54:39,440 --> 00:54:44,480
and a linker

00:54:41,119 --> 00:54:48,720
ldd or lld to compile

00:54:44,480 --> 00:54:50,480
and link c plus programs

00:54:48,720 --> 00:54:51,760
there's another question here why is the

00:54:50,480 --> 00:54:53,359
abstract machine considered

00:54:51,760 --> 00:54:55,680
non-deterministic

00:54:53,359 --> 00:54:57,359
when aspects that vary from one platform

00:54:55,680 --> 00:54:59,200
to the other could simply be considered

00:54:57,359 --> 00:55:02,319
as being additional parameters to a

00:54:59,200 --> 00:55:02,319
deterministic machine

00:55:02,640 --> 00:55:10,079
well i think uh to answer that

00:55:07,359 --> 00:55:10,559
the non-determinism comes from the fact

00:55:10,079 --> 00:55:13,359
that

00:55:10,559 --> 00:55:15,920
there are flows of execution that can't

00:55:13,359 --> 00:55:19,920
be specified or documented

00:55:15,920 --> 00:55:21,680
um for example generate a random number

00:55:19,920 --> 00:55:22,960
a pseudo-random number generator

00:55:21,680 --> 00:55:25,119
suppose you have a high quality

00:55:22,960 --> 00:55:26,960
pseudo-random number generator

00:55:25,119 --> 00:55:28,640
you know between two points of

00:55:26,960 --> 00:55:30,480
observable behavior that you're going to

00:55:28,640 --> 00:55:33,200
invoke that random number generator and

00:55:30,480 --> 00:55:35,440
that you're going to generate a result

00:55:33,200 --> 00:55:36,400
now the non-determinism comes from the

00:55:35,440 --> 00:55:38,960
fact that

00:55:36,400 --> 00:55:40,880
as the pseudo-random number generator is

00:55:38,960 --> 00:55:42,720
doing its job it's computing the random

00:55:40,880 --> 00:55:45,599
value

00:55:42,720 --> 00:55:46,400
it is difficult if not impossible to

00:55:45,599 --> 00:55:48,480
understand

00:55:46,400 --> 00:55:50,880
what is actually happening under under

00:55:48,480 --> 00:55:50,880
the hood

00:55:50,960 --> 00:55:54,400
when the observable behavior occurs

00:55:53,359 --> 00:55:56,799
there must have been

00:55:54,400 --> 00:55:58,480
a flow of control through the abstract

00:55:56,799 --> 00:56:00,319
machine that is equivalent

00:55:58,480 --> 00:56:01,599
to the flow of control that occurred in

00:56:00,319 --> 00:56:04,160
the physical machine

00:56:01,599 --> 00:56:06,160
that will lead the same lead to the same

00:56:04,160 --> 00:56:08,240
observable

00:56:06,160 --> 00:56:09,839
behavior the same result from the random

00:56:08,240 --> 00:56:11,680
number generator

00:56:09,839 --> 00:56:13,680
we can't specify we can't know in

00:56:11,680 --> 00:56:14,720
advance what that behavior is going to

00:56:13,680 --> 00:56:17,119
be

00:56:14,720 --> 00:56:18,799
all we need to know is that when the

00:56:17,119 --> 00:56:21,040
observable behavior occurs

00:56:18,799 --> 00:56:22,160
when you interact with the outside world

00:56:21,040 --> 00:56:24,000
and we

00:56:22,160 --> 00:56:26,720
read that random number we write it to a

00:56:24,000 --> 00:56:29,599
file or we print it to a terminal

00:56:26,720 --> 00:56:30,240
that there must be equivalent flows of

00:56:29,599 --> 00:56:31,680
control

00:56:30,240 --> 00:56:33,280
through the physical and abstract

00:56:31,680 --> 00:56:36,799
machine

00:56:33,280 --> 00:56:39,200
i hope that answers your question

00:56:36,799 --> 00:56:40,640
okay well thank you everyone for coming

00:56:39,200 --> 00:56:42,400
it's been a pleasure and privilege to

00:56:40,640 --> 00:56:44,960
present this first talk

00:56:42,400 --> 00:56:59,839
and everybody have a great conference

00:56:44,960 --> 00:56:59,839
and we'll see you in the hallway soon

00:57:06,640 --> 00:57:08,720

YouTube URL: https://www.youtube.com/watch?v=ZAji7PkXaKY


