Title: Back to Basics: Templates (part 2 of 2) - Andreas Fertig - CppCon 2020
Publication date: 2020-11-06
Playlist: Back To Basics CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_templates_part_2/back_to_basics_templates_part_2__andreas_fertig__cppcon_2020.pdf
---
Advanced Templates
This is the second part of Templates where go more into depth. Attendees expected to know the syntax an properties of function and class templates, type_traits and constexpr if.

In this session, we look at variadic templates together with fold expressions by using a Printf like function as an example. This knowledge is then used to talk about template specializations.

At this point we will briefly talk about SFINAE. We compare it to the tag-dispatching pattern and see how C++20s Concepts make SFINAE way less scary. Next on the plate are variable templates as well as template template parameters.

This session is for developers with C++ experience who have avoided templates so far. After attending this talk, attendees have learned techniques like SFINAE and template specializations.

---
Andreas Fertig
Unique Code

Andreas Fertig is the CEO of Unique Code GmbH, which offers training and consulting for C++ specialized in embedded systems. He worked for Philips Medizin Systeme GmbH for ten years as a C++ software developer and architect focusing on embedded systems.

Andreas is involved in the C ++ standardization committee. He is a regular speaker at conferences internationally. Textbooks and articles by Andreas are available in German and English.

Andreas has a passion for teaching people how C++ works, which is why he created C++ Insights (cppinsights.io).

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,240 --> 00:00:12,000
so

00:00:08,800 --> 00:00:13,120
welcome to the second part of the back

00:00:12,000 --> 00:00:16,320
to the basics

00:00:13,120 --> 00:00:17,440
track c plus plus templates my name is

00:00:16,320 --> 00:00:20,320
andreas fertig

00:00:17,440 --> 00:00:22,960
i work as a trainer and consultant for c

00:00:20,320 --> 00:00:22,960
plus plus

00:00:23,119 --> 00:00:26,720
i told you in the first part for all of

00:00:25,359 --> 00:00:29,439
those who went there

00:00:26,720 --> 00:00:30,400
there and i think it's quite nice and

00:00:29,439 --> 00:00:32,719
very great

00:00:30,400 --> 00:00:34,880
that we can't have this event here

00:00:32,719 --> 00:00:36,079
despite all what's going on the world

00:00:34,880 --> 00:00:38,879
currently and

00:00:36,079 --> 00:00:41,040
the situation we are facing and the

00:00:38,879 --> 00:00:43,360
sadness about

00:00:41,040 --> 00:00:44,719
having it that way is that you see even

00:00:43,360 --> 00:00:46,399
less the people

00:00:44,719 --> 00:00:48,000
who are running this show who are

00:00:46,399 --> 00:00:50,399
contributing to it not by

00:00:48,000 --> 00:00:53,120
standing in front of camera or

00:00:50,399 --> 00:00:56,320
microphone but behind the scenes um

00:00:53,120 --> 00:00:58,559
like the two volunteers creating this

00:00:56,320 --> 00:01:00,719
live stream for you today and managing

00:00:58,559 --> 00:01:01,760
the templates and all that stuff behind

00:01:00,719 --> 00:01:04,640
for me

00:01:01,760 --> 00:01:06,080
atul and jojo and there are all the

00:01:04,640 --> 00:01:09,119
others around john

00:01:06,080 --> 00:01:12,320
who made all that possible to be

00:01:09,119 --> 00:01:16,400
here even if he or maybe your own home

00:01:12,320 --> 00:01:19,360
so as i said in the first part

00:01:16,400 --> 00:01:21,680
one good idea is create in the question

00:01:19,360 --> 00:01:25,360
and answers

00:01:21,680 --> 00:01:27,520
section create a question saying

00:01:25,360 --> 00:01:30,159
give a round of applause to all this

00:01:27,520 --> 00:01:32,960
stuff for all the things you are doing

00:01:30,159 --> 00:01:35,040
making this thing happen and simply

00:01:32,960 --> 00:01:37,840
everybody who likes to jump in

00:01:35,040 --> 00:01:39,280
upvolt the art that gives them a little

00:01:37,840 --> 00:01:41,360
bit of appreciation

00:01:39,280 --> 00:01:42,560
because if you're simply applauding at

00:01:41,360 --> 00:01:44,560
home

00:01:42,560 --> 00:01:46,399
well you have either to live stream it

00:01:44,560 --> 00:01:49,040
or send them the recording

00:01:46,399 --> 00:01:49,439
um that would be a nice idea maybe as

00:01:49,040 --> 00:01:51,840
well

00:01:49,439 --> 00:01:52,880
but they cannot hear it initially so

00:01:51,840 --> 00:01:54,640
let's um

00:01:52,880 --> 00:01:57,280
let's give them a hand of applause

00:01:54,640 --> 00:02:00,399
showing them our appreciation

00:01:57,280 --> 00:02:02,880
in the first talk part we talked about

00:02:00,399 --> 00:02:05,200
function templates and class templates

00:02:02,880 --> 00:02:08,399
we looked a little bit about

00:02:05,200 --> 00:02:12,560
what instantiation means and how we can

00:02:08,399 --> 00:02:15,599
control the resulting code from it so

00:02:12,560 --> 00:02:18,160
guidelines for efficiently using

00:02:15,599 --> 00:02:18,720
templates here the key is that we have

00:02:18,160 --> 00:02:21,599
to

00:02:18,720 --> 00:02:23,599
watch out for different instantiations

00:02:21,599 --> 00:02:26,400
and for which parts we

00:02:23,599 --> 00:02:27,360
can move out of the template because

00:02:26,400 --> 00:02:30,000
they are

00:02:27,360 --> 00:02:30,800
shared commonality which can be used all

00:02:30,000 --> 00:02:33,840
over the place

00:02:30,800 --> 00:02:37,120
things like that we also looked at

00:02:33,840 --> 00:02:40,080
another construct like constexprf which

00:02:37,120 --> 00:02:41,200
yields to only one branch in your binary

00:02:40,080 --> 00:02:43,599
in the end

00:02:41,200 --> 00:02:44,640
because it's evaluated at compile time

00:02:43,599 --> 00:02:47,680
and it works with

00:02:44,640 --> 00:02:48,319
types so despite there was only a small

00:02:47,680 --> 00:02:50,720
section

00:02:48,319 --> 00:02:52,000
where i specifically addressed syncing

00:02:50,720 --> 00:02:55,040
types

00:02:52,000 --> 00:02:55,599
a lot of my slides in the first part

00:02:55,040 --> 00:02:58,239
referred

00:02:55,599 --> 00:03:00,560
to types because we talked about how to

00:02:58,239 --> 00:03:01,840
instantiate a template and often that's

00:03:00,560 --> 00:03:04,159
done by a type

00:03:01,840 --> 00:03:05,200
sometimes it's by a so-called non-type

00:03:04,159 --> 00:03:08,400
template parameter

00:03:05,200 --> 00:03:10,319
and its number most likely

00:03:08,400 --> 00:03:11,519
we have also seen or heard about the

00:03:10,319 --> 00:03:13,200
different types of

00:03:11,519 --> 00:03:15,120
template parameters so we have type

00:03:13,200 --> 00:03:17,360
template parameters per bleeding

00:03:15,120 --> 00:03:19,280
most common ones one type template

00:03:17,360 --> 00:03:20,319
parameters whenever you're passing in a

00:03:19,280 --> 00:03:23,440
constant

00:03:20,319 --> 00:03:24,400
or um template template parameters which

00:03:23,440 --> 00:03:27,200
we'll see in

00:03:24,400 --> 00:03:32,640
this second part now what we can do with

00:03:27,200 --> 00:03:35,200
them or when we need them

00:03:32,640 --> 00:03:37,440
we learned that we have function

00:03:35,200 --> 00:03:38,959
templates class templates and variable

00:03:37,440 --> 00:03:42,239
templates i

00:03:38,959 --> 00:03:44,159
um slightly skipped alias templates at

00:03:42,239 --> 00:03:45,680
the beginning but we also looked in

00:03:44,159 --> 00:03:49,040
alias templates

00:03:45,680 --> 00:03:52,159
now there is a another thing

00:03:49,040 --> 00:03:53,040
since c plus plus 11 we can do with

00:03:52,159 --> 00:03:55,599
templates or

00:03:53,040 --> 00:03:57,920
ability templates give us and these are

00:03:55,599 --> 00:04:02,159
variatic templates

00:03:57,920 --> 00:04:04,480
and here we have such a variety template

00:04:02,159 --> 00:04:05,760
as an example and all its different

00:04:04,480 --> 00:04:08,799
components

00:04:05,760 --> 00:04:10,879
so verific template starts

00:04:08,799 --> 00:04:12,319
as every other template of course with

00:04:10,879 --> 00:04:13,200
the template keyword and then called

00:04:12,319 --> 00:04:15,760
brackets i'm

00:04:13,200 --> 00:04:17,359
sure you learned that in the first part

00:04:15,760 --> 00:04:21,519
and

00:04:17,359 --> 00:04:24,639
vertical template is

00:04:21,519 --> 00:04:27,680
created by having three dots

00:04:24,639 --> 00:04:29,199
after type name or class it's the

00:04:27,680 --> 00:04:31,600
ellipsis operator

00:04:29,199 --> 00:04:33,840
we know that from maybe functions like

00:04:31,600 --> 00:04:35,199
printf so variatic functions or veridic

00:04:33,840 --> 00:04:38,400
macros

00:04:35,199 --> 00:04:41,120
and whenever we

00:04:38,400 --> 00:04:42,000
say type name we can also exchange that

00:04:41,120 --> 00:04:44,320
and say class

00:04:42,000 --> 00:04:46,479
there are a few minor exceptions where

00:04:44,320 --> 00:04:47,280
we only can either use type name or

00:04:46,479 --> 00:04:48,960
class

00:04:47,280 --> 00:04:50,880
but in the case here of this template

00:04:48,960 --> 00:04:51,440
head we can use either type name or

00:04:50,880 --> 00:04:54,880
class

00:04:51,440 --> 00:04:57,040
i usually use type name so

00:04:54,880 --> 00:04:58,160
what i'm doing here is i'm creating a

00:04:57,040 --> 00:04:59,520
variety template

00:04:58,160 --> 00:05:01,919
because i'm starting here in the

00:04:59,520 --> 00:05:05,280
template head with type name t

00:05:01,919 --> 00:05:08,160
comma and then typename.ts

00:05:05,280 --> 00:05:09,440
and that refers to a veridic template

00:05:08,160 --> 00:05:11,440
more precisely

00:05:09,440 --> 00:05:12,720
we are creating here a template

00:05:11,440 --> 00:05:15,919
parameter pack

00:05:12,720 --> 00:05:18,000
because it's a type name so it's a type

00:05:15,919 --> 00:05:19,120
parameter we have here we can also

00:05:18,000 --> 00:05:20,960
create non-type

00:05:19,120 --> 00:05:22,639
template parameter packs but here we are

00:05:20,960 --> 00:05:26,000
looking at a type

00:05:22,639 --> 00:05:27,919
template parameter pack we can give it a

00:05:26,000 --> 00:05:29,840
name we can omit that name if you don't

00:05:27,919 --> 00:05:32,880
like to refer to it later

00:05:29,840 --> 00:05:36,560
like this every other type name or

00:05:32,880 --> 00:05:39,280
template parameter and here

00:05:36,560 --> 00:05:42,320
then i have a min function it returns

00:05:39,280 --> 00:05:45,520
auto it's constant expert because i can

00:05:42,320 --> 00:05:47,199
and if you remember or whether in the

00:05:45,520 --> 00:05:49,440
first round of the talk

00:05:47,199 --> 00:05:50,320
then i already had the min function

00:05:49,440 --> 00:05:53,280
there it took

00:05:50,320 --> 00:05:53,919
two parameters a and b by const t ref

00:05:53,280 --> 00:05:56,560
the same

00:05:53,919 --> 00:05:57,520
as here but this time we have third

00:05:56,560 --> 00:06:00,639
parameter

00:05:57,520 --> 00:06:04,000
that function takes and it's

00:06:00,639 --> 00:06:04,960
of type const tsref followed by the

00:06:04,000 --> 00:06:08,160
three dots

00:06:04,960 --> 00:06:10,880
so this is a third parameter which is

00:06:08,160 --> 00:06:11,680
somewhat optional and this is the

00:06:10,880 --> 00:06:13,759
variety

00:06:11,680 --> 00:06:14,960
pack so here i'm looking at the

00:06:13,759 --> 00:06:18,080
parameter pack

00:06:14,960 --> 00:06:19,919
and now that i have this type ts i can

00:06:18,080 --> 00:06:20,720
create this pack out of it and can give

00:06:19,919 --> 00:06:24,080
it a name

00:06:20,720 --> 00:06:26,560
which in this case is the small written

00:06:24,080 --> 00:06:26,560
tias

00:06:27,360 --> 00:06:34,880
now i can combine a couple of features

00:06:30,400 --> 00:06:37,360
we saw in the first

00:06:34,880 --> 00:06:39,360
part we look there temp function

00:06:37,360 --> 00:06:40,000
templates and that constitutes very very

00:06:39,360 --> 00:06:41,680
end

00:06:40,000 --> 00:06:43,360
and here i'm using that constitutes

00:06:41,680 --> 00:06:45,759
brief because that min

00:06:43,360 --> 00:06:47,120
function is supposed to work with an

00:06:45,759 --> 00:06:50,720
arbitrary number

00:06:47,120 --> 00:06:53,919
of arguments but at least two

00:06:50,720 --> 00:06:54,960
because a pack can be empty it's like a

00:06:53,919 --> 00:06:57,199
printf you

00:06:54,960 --> 00:06:58,639
don't need to pass any other parameter

00:06:57,199 --> 00:07:01,599
in a format string to it

00:06:58,639 --> 00:07:02,000
and that can contain the entire string

00:07:01,599 --> 00:07:04,080
and here

00:07:02,000 --> 00:07:06,479
it's the same if you're looking down

00:07:04,080 --> 00:07:09,520
before peeking into the template itself

00:07:06,479 --> 00:07:11,919
in line number 19 and 20 there

00:07:09,520 --> 00:07:13,520
i'm using it i have this min function

00:07:11,919 --> 00:07:15,440
called in the static assert because it's

00:07:13,520 --> 00:07:17,520
context where i can do that

00:07:15,440 --> 00:07:19,599
and the first time i'm passing three

00:07:17,520 --> 00:07:20,400
comma two comma three comma four comma

00:07:19,599 --> 00:07:23,680
five to it

00:07:20,400 --> 00:07:26,639
and i expect the result is two because

00:07:23,680 --> 00:07:29,120
two is the smallest value in that set

00:07:26,639 --> 00:07:30,000
and then i can also use it with only two

00:07:29,120 --> 00:07:32,800
parameters

00:07:30,000 --> 00:07:34,240
as before so this helps you if you have

00:07:32,800 --> 00:07:37,759
the case where you

00:07:34,240 --> 00:07:39,280
need to pass more than two values into a

00:07:37,759 --> 00:07:42,319
function and figure out which one

00:07:39,280 --> 00:07:44,400
is the smallest value and get that back

00:07:42,319 --> 00:07:46,479
and our function template does it a way

00:07:44,400 --> 00:07:49,039
that it first in line number nine

00:07:46,479 --> 00:07:49,919
figures out which is the smallest value

00:07:49,039 --> 00:07:52,400
of a and b

00:07:49,919 --> 00:07:55,120
which is a smaller one a or b and it

00:07:52,400 --> 00:07:57,120
saves that result in a variable m

00:07:55,120 --> 00:08:00,160
so that's more or less like before but

00:07:57,120 --> 00:08:03,280
before we immediately return that result

00:08:00,160 --> 00:08:03,680
now we only store this result for a

00:08:03,280 --> 00:08:06,240
moment

00:08:03,680 --> 00:08:08,000
and then we have a constexpr if there

00:08:06,240 --> 00:08:11,120
and that constexpr if

00:08:08,000 --> 00:08:13,919
inside does use

00:08:11,120 --> 00:08:16,080
my parameter pack because there is a

00:08:13,919 --> 00:08:18,319
special kind of size of it's the size of

00:08:16,080 --> 00:08:19,120
followed by three dots and i'm passing

00:08:18,319 --> 00:08:22,400
ts

00:08:19,120 --> 00:08:24,879
to it and that means that i'm clearing

00:08:22,400 --> 00:08:27,360
at compile time for the size of this

00:08:24,879 --> 00:08:28,000
pack and size of this pack in this

00:08:27,360 --> 00:08:31,759
context

00:08:28,000 --> 00:08:34,240
means number of arguments in that pack

00:08:31,759 --> 00:08:35,360
so the number of arguments you passed to

00:08:34,240 --> 00:08:39,279
that function

00:08:35,360 --> 00:08:41,599
to min the one followed by the first two

00:08:39,279 --> 00:08:43,200
so in my example is it would be three

00:08:41,599 --> 00:08:45,440
comma four comma five

00:08:43,200 --> 00:08:47,760
these are the elements in this pack and

00:08:45,440 --> 00:08:50,720
the size of operator returns me

00:08:47,760 --> 00:08:52,160
as a result three it's not the number of

00:08:50,720 --> 00:08:55,200
bytes

00:08:52,160 --> 00:08:57,279
these types or these values would occupy

00:08:55,200 --> 00:08:59,200
it's solely the number of arguments in

00:08:57,279 --> 00:09:00,959
this pack i can query that

00:08:59,200 --> 00:09:02,880
and then the size of i'm checking

00:09:00,959 --> 00:09:06,240
whether there are elements left

00:09:02,880 --> 00:09:09,440
in the pack and if so i go

00:09:06,240 --> 00:09:12,560
and call min recursively

00:09:09,440 --> 00:09:13,839
passing in the result i calculated

00:09:12,560 --> 00:09:17,040
before in line number nine

00:09:13,839 --> 00:09:20,240
m and my parameter pack

00:09:17,040 --> 00:09:22,320
ts but with the three dots that means

00:09:20,240 --> 00:09:25,360
that pack gets expanded

00:09:22,320 --> 00:09:26,640
in that context in d i'm expanding the

00:09:25,360 --> 00:09:28,480
pack

00:09:26,640 --> 00:09:30,160
and if you're looking at the signature

00:09:28,480 --> 00:09:32,880
closely of that function

00:09:30,160 --> 00:09:35,279
you can see that i'm essentially

00:09:32,880 --> 00:09:35,760
splitting up the first argument from the

00:09:35,279 --> 00:09:39,040
pack

00:09:35,760 --> 00:09:43,360
because that now gets passed to min as

00:09:39,040 --> 00:09:46,399
argument b and i use that technique

00:09:43,360 --> 00:09:50,160
to with each recursive call split up

00:09:46,399 --> 00:09:53,920
one parameter and reduce the pack until

00:09:50,160 --> 00:09:55,120
its size is zero and i have the final

00:09:53,920 --> 00:09:57,680
result

00:09:55,120 --> 00:09:59,120
this is a technique that often happens

00:09:57,680 --> 00:10:01,600
in beretic templates

00:09:59,120 --> 00:10:03,839
especially before or if you are using c

00:10:01,600 --> 00:10:06,480
plus plus 17 and 14

00:10:03,839 --> 00:10:08,640
then you have to do this recursion

00:10:06,480 --> 00:10:11,120
because there's no way to

00:10:08,640 --> 00:10:13,040
index into a pack so it's it's not like

00:10:11,120 --> 00:10:14,880
an array where you can say please give

00:10:13,040 --> 00:10:16,800
me the

00:10:14,880 --> 00:10:18,079
element number three or something like

00:10:16,800 --> 00:10:21,040
this you you have

00:10:18,079 --> 00:10:22,399
to slightly or slowly split up the

00:10:21,040 --> 00:10:25,440
elements and this is the

00:10:22,399 --> 00:10:27,600
the typical technique to do this

00:10:25,440 --> 00:10:29,920
guarded by the constexpr if it's

00:10:27,600 --> 00:10:32,800
slightly better because the

00:10:29,920 --> 00:10:35,200
solely c plus 11 version constitutive

00:10:32,800 --> 00:10:37,680
technically is c plus plus 17.

00:10:35,200 --> 00:10:39,519
in a soul c plus plus 11 version you

00:10:37,680 --> 00:10:42,480
would have to provide

00:10:39,519 --> 00:10:43,120
a min function or an overload for a min

00:10:42,480 --> 00:10:45,519
with

00:10:43,120 --> 00:10:47,279
zero or the two arguments to catch the

00:10:45,519 --> 00:10:49,920
case when the pack gets empty

00:10:47,279 --> 00:10:52,320
but the context brief helps me here to

00:10:49,920 --> 00:10:55,519
avoid that

00:10:52,320 --> 00:10:57,519
so that's the essential parts of

00:10:55,519 --> 00:11:00,079
a variatic template and variatic

00:10:57,519 --> 00:11:03,279
templates are really powerful

00:11:00,079 --> 00:11:07,120
what can i do with them

00:11:03,279 --> 00:11:10,800
so here is another example slightly more

00:11:07,120 --> 00:11:11,440
code and you start hopefully to get the

00:11:10,800 --> 00:11:14,959
feeling

00:11:11,440 --> 00:11:15,200
on how templates look like you see a lot

00:11:14,959 --> 00:11:17,120
of

00:11:15,200 --> 00:11:18,800
template keywords in there and a lot of

00:11:17,120 --> 00:11:22,240
ankle brackets

00:11:18,800 --> 00:11:24,160
but that's not really an issue you

00:11:22,240 --> 00:11:25,279
you just know that your template and

00:11:24,160 --> 00:11:26,880
that you have to

00:11:25,279 --> 00:11:31,200
parse it in your mind a little bit

00:11:26,880 --> 00:11:34,240
differently so what i'm having here

00:11:31,200 --> 00:11:34,880
are from the top at a three different

00:11:34,240 --> 00:11:43,839
functions

00:11:34,880 --> 00:11:43,839
called normalize

00:11:44,800 --> 00:11:49,279
and their purpose is solely to take

00:11:46,959 --> 00:11:53,519
either stood string a q string from the

00:11:49,279 --> 00:11:55,920
cute library or a plain jar string

00:11:53,519 --> 00:11:57,519
as a pointer and convert it back in the

00:11:55,920 --> 00:11:59,519
stood string so in the case of stood

00:11:57,519 --> 00:12:02,160
string there's nothing much to do

00:11:59,519 --> 00:12:04,240
in case of cute string i have to call

00:12:02,160 --> 00:12:05,839
two stood string on that string because

00:12:04,240 --> 00:12:07,440
that's the way how you convert the q

00:12:05,839 --> 00:12:10,720
string into a struct string

00:12:07,440 --> 00:12:12,399
and for a char array i just call the

00:12:10,720 --> 00:12:14,639
constructor of a stood string

00:12:12,399 --> 00:12:18,560
and return it because the normalized

00:12:14,639 --> 00:12:21,600
functions return currently outer

00:12:18,560 --> 00:12:24,079
as in the first part it's not optimized

00:12:21,600 --> 00:12:26,079
for efficiency here so you could squeeze

00:12:24,079 --> 00:12:27,440
in a couple of hour your references and

00:12:26,079 --> 00:12:30,720
stood moves and so on

00:12:27,440 --> 00:12:33,200
to make it more efficient but i did

00:12:30,720 --> 00:12:34,480
go for an implementation that still fits

00:12:33,200 --> 00:12:37,120
on a slide so

00:12:34,480 --> 00:12:39,600
in real code you would probably write it

00:12:37,120 --> 00:12:42,240
a little bit differently

00:12:39,600 --> 00:12:44,639
to make it more efficient but it does

00:12:42,240 --> 00:12:47,680
the job it does a pretty good job

00:12:44,639 --> 00:12:50,800
so then i have in b

00:12:47,680 --> 00:12:52,880
this say catch all

00:12:50,800 --> 00:12:54,560
template it's a function template it

00:12:52,880 --> 00:12:58,240
takes a single class name

00:12:54,560 --> 00:13:00,800
type name t this time i use class t

00:12:58,240 --> 00:13:02,959
just to switch it a little and it once

00:13:00,800 --> 00:13:06,399
again takes only a single parameter

00:13:02,959 --> 00:13:08,639
constitute ref and it converts their st

00:13:06,399 --> 00:13:09,519
thing to a stood string by calling to

00:13:08,639 --> 00:13:12,079
stood string

00:13:09,519 --> 00:13:13,040
because the idea is that the first three

00:13:12,079 --> 00:13:15,200
function

00:13:13,040 --> 00:13:16,320
essentially covered every string

00:13:15,200 --> 00:13:18,160
combination

00:13:16,320 --> 00:13:20,079
and now it's no longer a string it may

00:13:18,160 --> 00:13:23,440
be a number or something arbitrary

00:13:20,079 --> 00:13:25,600
else and hopefully tostring has

00:13:23,440 --> 00:13:28,160
knowledge how to convert it to a stool

00:13:25,600 --> 00:13:30,959
string that's the key idea here

00:13:28,160 --> 00:13:32,000
with all that normalized functions

00:13:30,959 --> 00:13:35,519
equipped

00:13:32,000 --> 00:13:36,720
we can now start using it and the usage

00:13:35,519 --> 00:13:38,880
here is

00:13:36,720 --> 00:13:39,839
at the bottom we have a function

00:13:38,880 --> 00:13:42,320
template called

00:13:39,839 --> 00:13:43,279
stutter cut its purpose is to

00:13:42,320 --> 00:13:45,279
concatenate

00:13:43,279 --> 00:13:47,199
multiple strings if you're really

00:13:45,279 --> 00:13:48,160
looking for such a version i highly

00:13:47,199 --> 00:13:51,440
recommend the

00:13:48,160 --> 00:13:53,920
version of stood abseil they do

00:13:51,440 --> 00:13:55,760
way more and a lot better job than this

00:13:53,920 --> 00:13:57,839
short snippet here but this short

00:13:55,760 --> 00:14:00,480
snippet does the job

00:13:57,839 --> 00:14:03,120
what i'm doing is so the string card

00:14:00,480 --> 00:14:03,920
takes a const t ref as its first

00:14:03,120 --> 00:14:06,639
argument

00:14:03,920 --> 00:14:07,040
and after that it's a valid template so

00:14:06,639 --> 00:14:10,720
it

00:14:07,040 --> 00:14:13,199
takes my const t s ref dot dot dot

00:14:10,720 --> 00:14:14,720
arcs so it takes an arbitrary number of

00:14:13,199 --> 00:14:17,680
arguments

00:14:14,720 --> 00:14:18,800
and what it does is internally in line

00:14:17,680 --> 00:14:21,199
number 19

00:14:18,800 --> 00:14:21,839
it starts with creating a variable

00:14:21,199 --> 00:14:24,320
called red

00:14:21,839 --> 00:14:25,120
of type stood string this is the one

00:14:24,320 --> 00:14:28,399
which will be

00:14:25,120 --> 00:14:30,880
returned later in line 23 and it calls

00:14:28,399 --> 00:14:33,839
normalized in the first argument on t

00:14:30,880 --> 00:14:34,399
arc and initializes my return value

00:14:33,839 --> 00:14:36,800
string

00:14:34,399 --> 00:14:38,639
was that result so essentially that's

00:14:36,800 --> 00:14:40,160
the first step of converting everything

00:14:38,639 --> 00:14:42,480
that was passed in this

00:14:40,160 --> 00:14:44,079
first argument into a stood string and

00:14:42,480 --> 00:14:47,360
after that i'm calling this

00:14:44,079 --> 00:14:50,079
dash store cut function which

00:14:47,360 --> 00:14:51,760
would usually go into a namespace or

00:14:50,079 --> 00:14:53,760
something like this but

00:14:51,760 --> 00:14:55,120
as you can see there were no more lines

00:14:53,760 --> 00:14:58,000
left on this slide so i

00:14:55,120 --> 00:15:00,000
haven't had a chance so i named it a

00:14:58,000 --> 00:15:01,760
number line store card

00:15:00,000 --> 00:15:03,600
and you can see this function in line

00:15:01,760 --> 00:15:06,959
number nine what it's passed

00:15:03,600 --> 00:15:08,480
to and 21 is the return value we created

00:15:06,959 --> 00:15:11,680
so that's two string

00:15:08,480 --> 00:15:13,519
and then the expanded pack that the

00:15:11,680 --> 00:15:19,680
initial cut function

00:15:13,519 --> 00:15:23,519
took as you can see that by the arcs.ind

00:15:19,680 --> 00:15:24,720
now my more or less internal template

00:15:23,519 --> 00:15:27,680
strip card

00:15:24,720 --> 00:15:29,120
it takes as a first argument a stood

00:15:27,680 --> 00:15:32,320
string by reference so

00:15:29,120 --> 00:15:33,199
it expects that the outer version didn't

00:15:32,320 --> 00:15:35,440
so

00:15:33,199 --> 00:15:37,680
you could pass everything as a first

00:15:35,440 --> 00:15:40,480
argument to that outer version even

00:15:37,680 --> 00:15:41,680
an end but to the internal version that

00:15:40,480 --> 00:15:43,839
one expects

00:15:41,680 --> 00:15:46,079
to get a stood string as his first

00:15:43,839 --> 00:15:46,959
argument because essentially as we can

00:15:46,079 --> 00:15:49,040
see in the body

00:15:46,959 --> 00:15:50,399
it depends all the following arguments

00:15:49,040 --> 00:15:52,000
to it and

00:15:50,399 --> 00:15:53,680
simply it doesn't has to return it

00:15:52,000 --> 00:15:54,079
because it got it by reference so it

00:15:53,680 --> 00:15:56,800
simply

00:15:54,079 --> 00:15:57,360
adds to it and the outer function later

00:15:56,800 --> 00:16:00,560
can

00:15:57,360 --> 00:16:01,759
return the concluded string the second

00:16:00,560 --> 00:16:03,839
argument my

00:16:01,759 --> 00:16:06,399
internal string cut function takes is

00:16:03,839 --> 00:16:08,880
once again a const t ref tr

00:16:06,399 --> 00:16:09,680
and after that my parameter pack so that

00:16:08,880 --> 00:16:12,240
pattern

00:16:09,680 --> 00:16:15,279
follows along the lines it's the same as

00:16:12,240 --> 00:16:19,279
the storycard function before

00:16:15,279 --> 00:16:21,440
with the purpose to have the ability to

00:16:19,279 --> 00:16:23,519
split up one argument from the pack

00:16:21,440 --> 00:16:25,440
as we see it on the previous slide as we

00:16:23,519 --> 00:16:27,120
saw in the previous slide

00:16:25,440 --> 00:16:29,440
so and what it does then in line number

00:16:27,120 --> 00:16:32,320
l11 is

00:16:29,440 --> 00:16:34,000
call normalize and append this value to

00:16:32,320 --> 00:16:36,000
our return value so whatever was

00:16:34,000 --> 00:16:38,639
returned by normalize as a stood string

00:16:36,000 --> 00:16:40,079
by now and we can return it we can add

00:16:38,639 --> 00:16:41,839
it to red

00:16:40,079 --> 00:16:43,440
and then we see the constexpref as

00:16:41,839 --> 00:16:45,680
before it checks

00:16:43,440 --> 00:16:46,959
other elements in this pack left so it's

00:16:45,680 --> 00:16:49,279
the size of this peg

00:16:46,959 --> 00:16:50,079
larger than one or larger than zero

00:16:49,279 --> 00:16:53,040
sorry

00:16:50,079 --> 00:16:53,839
if so then in c we can see that stutter

00:16:53,040 --> 00:16:57,519
cut now

00:16:53,839 --> 00:16:57,519
calls itself repeatedly

00:17:01,759 --> 00:17:05,600
splitting up one element from the pack

00:17:04,720 --> 00:17:08,880
each time

00:17:05,600 --> 00:17:10,640
as before so this is a pattern we're

00:17:08,880 --> 00:17:12,240
using all over the place when it comes

00:17:10,640 --> 00:17:15,760
to writing templates

00:17:12,240 --> 00:17:17,760
as long as we have c plus plus 14 or

00:17:15,760 --> 00:17:20,000
less

00:17:17,760 --> 00:17:22,240
and we have a question can inheritance

00:17:20,000 --> 00:17:25,520
and templates be combined to

00:17:22,240 --> 00:17:26,480
call say member function foo from base

00:17:25,520 --> 00:17:30,080
to derived

00:17:26,480 --> 00:17:32,559
by explicitly calling derived foo

00:17:30,080 --> 00:17:34,559
using class template type rather than

00:17:32,559 --> 00:17:47,840
dynamic pointer

00:17:34,559 --> 00:17:47,840
let me process that once again

00:17:52,880 --> 00:17:57,280
okay i think the answer is yes but reach

00:17:56,160 --> 00:18:01,600
out to me later

00:17:57,280 --> 00:18:05,280
um i have to process it in more depth

00:18:01,600 --> 00:18:08,320
so that's veridic templates

00:18:05,280 --> 00:18:10,400
and that's the 11 to 14 version

00:18:08,320 --> 00:18:12,000
i squeezed in context per if there so

00:18:10,400 --> 00:18:15,280
technically we are already

00:18:12,000 --> 00:18:18,640
used c plus plus 17 but

00:18:15,280 --> 00:18:21,919
there is one additional thing with c

00:18:18,640 --> 00:18:22,880
plus plus 17 and that's fault

00:18:21,919 --> 00:18:26,080
expressions

00:18:22,880 --> 00:18:27,440
and fault expressions make that

00:18:26,080 --> 00:18:31,520
recursion

00:18:27,440 --> 00:18:31,520
go away we don't need it any longer

00:18:32,080 --> 00:18:38,320
we have two different

00:18:35,200 --> 00:18:40,080
types of fault expressions we have unary

00:18:38,320 --> 00:18:43,200
and binary

00:18:40,080 --> 00:18:44,799
fault expressions and they're once more

00:18:43,200 --> 00:18:46,480
divided into a right

00:18:44,799 --> 00:18:48,480
and into a left fault so we have a

00:18:46,480 --> 00:18:49,840
junior right and a unary left and a

00:18:48,480 --> 00:18:53,039
binary right and a

00:18:49,840 --> 00:18:56,000
binary left fold

00:18:53,039 --> 00:18:57,440
and as you can see on the slide here the

00:18:56,000 --> 00:18:59,919
unary form

00:18:57,440 --> 00:19:00,640
always has to form pack then an

00:18:59,919 --> 00:19:04,400
operation

00:19:00,640 --> 00:19:06,720
operation is like plus minus as we will

00:19:04,400 --> 00:19:08,400
see here the comma operator as well and

00:19:06,720 --> 00:19:10,000
then followed by the three dots

00:19:08,400 --> 00:19:11,760
and all that in parentheses the

00:19:10,000 --> 00:19:13,440
parentheses are crucial here otherwise

00:19:11,760 --> 00:19:15,840
it's not a fault expression

00:19:13,440 --> 00:19:18,000
and what that means is that you have a

00:19:15,840 --> 00:19:18,320
pack then you apply an operation here

00:19:18,000 --> 00:19:20,640
then

00:19:18,320 --> 00:19:21,840
these three dots imply that this thing

00:19:20,640 --> 00:19:24,880
gets

00:19:21,840 --> 00:19:27,039
expanded so you can work on

00:19:24,880 --> 00:19:27,919
on a fold and this fold is the parameter

00:19:27,039 --> 00:19:31,280
pack

00:19:27,919 --> 00:19:33,919
and the right or left indicates

00:19:31,280 --> 00:19:35,840
where are the three dots in relation to

00:19:33,919 --> 00:19:36,720
the operation so we are talking about a

00:19:35,840 --> 00:19:40,000
right fold

00:19:36,720 --> 00:19:42,080
the three dots are at the right from up

00:19:40,000 --> 00:19:43,120
and we are talking about the left fold

00:19:42,080 --> 00:19:46,000
if the

00:19:43,120 --> 00:19:48,000
three dots the ellipses is left from my

00:19:46,000 --> 00:19:51,360
operation

00:19:48,000 --> 00:19:53,760
and for the case of a binary fold

00:19:51,360 --> 00:19:54,559
it's slightly different because we now

00:19:53,760 --> 00:19:58,000
have

00:19:54,559 --> 00:20:01,120
an additional init so the form is

00:19:58,000 --> 00:20:04,880
pack op dot dot up init or

00:20:01,120 --> 00:20:07,440
init up dot dot op pack

00:20:04,880 --> 00:20:09,120
and this helps because we can face an

00:20:07,440 --> 00:20:10,960
empty pack

00:20:09,120 --> 00:20:12,640
and for this situation where we have an

00:20:10,960 --> 00:20:15,840
empty pack we can provide

00:20:12,640 --> 00:20:19,200
this in it this initial value or however

00:20:15,840 --> 00:20:20,159
the catch-all value um however you like

00:20:19,200 --> 00:20:23,600
to call it

00:20:20,159 --> 00:20:25,919
which will um added or used in this fold

00:20:23,600 --> 00:20:28,720
expression

00:20:25,919 --> 00:20:30,960
it's essential here that all ops

00:20:28,720 --> 00:20:32,080
especially in the binary case where we

00:20:30,960 --> 00:20:33,840
see two of them

00:20:32,080 --> 00:20:35,520
they have to be of the same type so

00:20:33,840 --> 00:20:38,799
because you cannot say pack

00:20:35,520 --> 00:20:40,159
plus dot dot minus init it has for

00:20:38,799 --> 00:20:43,840
example then to be

00:20:40,159 --> 00:20:46,960
pack plus dot dot plus in it

00:20:43,840 --> 00:20:49,679
so there's no mixture allowed and

00:20:46,960 --> 00:20:50,880
what can i do with that so at the right

00:20:49,679 --> 00:20:54,640
i have this

00:20:50,880 --> 00:20:56,159
function template print it's a variety

00:20:54,640 --> 00:20:57,280
function template because it takes a

00:20:56,159 --> 00:21:00,840
type name t

00:20:57,280 --> 00:21:03,360
and the typename.ts that's the verdict

00:21:00,840 --> 00:21:06,240
part and it once again

00:21:03,360 --> 00:21:06,880
as we saw it before it takes a constant

00:21:06,240 --> 00:21:09,520
ref

00:21:06,880 --> 00:21:10,320
as a first argument then the cons tiers

00:21:09,520 --> 00:21:12,240
ref dot

00:21:10,320 --> 00:21:13,600
dot so the parameter pack is the second

00:21:12,240 --> 00:21:16,720
argument

00:21:13,600 --> 00:21:19,360
technically second arguments

00:21:16,720 --> 00:21:21,679
and at first in line number four simply

00:21:19,360 --> 00:21:24,240
see how it's the first argument t arc

00:21:21,679 --> 00:21:26,640
and then i'm using a lambda here so c

00:21:24,240 --> 00:21:27,760
plus plus 14 lambda it's generic lambda

00:21:26,640 --> 00:21:30,480
because it takes

00:21:27,760 --> 00:21:32,080
a const auto ref is its argument it

00:21:30,480 --> 00:21:34,240
doesn't capture anything

00:21:32,080 --> 00:21:35,600
and they store it in the wearable c out

00:21:34,240 --> 00:21:38,640
space and arc

00:21:35,600 --> 00:21:42,159
because what it internally does it calls

00:21:38,640 --> 00:21:45,760
stutzy out passes space first in

00:21:42,159 --> 00:21:48,640
and then the argument

00:21:45,760 --> 00:21:51,280
and now i can use this lambda and apply

00:21:48,640 --> 00:21:54,480
it to my pack

00:21:51,280 --> 00:21:58,000
i do this in line number nine at a

00:21:54,480 --> 00:22:01,280
here so i say dot dot comma c out space

00:21:58,000 --> 00:22:03,919
and arc and pass arcs to it

00:22:01,280 --> 00:22:04,320
this time we do not have to say arcs dot

00:22:03,919 --> 00:22:06,240
dot

00:22:04,320 --> 00:22:08,240
because we put the dots in front so we

00:22:06,240 --> 00:22:09,440
are talking about the unary left fold

00:22:08,240 --> 00:22:12,559
here

00:22:09,440 --> 00:22:15,919
and this helps me to apply this your

00:22:12,559 --> 00:22:19,120
arcs operation to each element in

00:22:15,919 --> 00:22:22,720
the pack and

00:22:19,120 --> 00:22:26,400
by that it saves me the recursion

00:22:22,720 --> 00:22:29,440
we had before because this is now one

00:22:26,400 --> 00:22:31,120
long call separated by the comma

00:22:29,440 --> 00:22:33,360
operator and for those of you who know

00:22:31,120 --> 00:22:37,039
the comma operator it works that way

00:22:33,360 --> 00:22:40,000
that only the last return value if there

00:22:37,039 --> 00:22:43,520
would be any is preserved all the audios

00:22:40,000 --> 00:22:45,840
are discarded so it returns void my

00:22:43,520 --> 00:22:49,679
lambda so that doesn't matter here

00:22:45,840 --> 00:22:52,840
and if i now look

00:22:49,679 --> 00:22:55,600
at this print function in c plus plus

00:22:52,840 --> 00:22:58,799
insides

00:22:55,600 --> 00:23:02,039
and let it do the transformation

00:22:58,799 --> 00:23:03,280
then we can see that i here have the

00:23:02,039 --> 00:23:06,720
instantiation

00:23:03,280 --> 00:23:08,960
for my varidic template we can't see the

00:23:06,720 --> 00:23:11,200
arguments it's instantiated with

00:23:08,960 --> 00:23:14,320
it's with a jar array of size 6 jar

00:23:11,200 --> 00:23:17,120
array of size 4 and then an end

00:23:14,320 --> 00:23:19,200
here hello is my jar array of size 6 c

00:23:17,120 --> 00:23:21,600
plus plus my chara of size 4

00:23:19,200 --> 00:23:22,720
and my end is the 20. so hell is c plus

00:23:21,600 --> 00:23:26,480
plus 20.

00:23:22,720 --> 00:23:27,919
hello so then we can see another thing

00:23:26,480 --> 00:23:30,080
i'm not like to talk

00:23:27,919 --> 00:23:31,120
very much about this today it's how

00:23:30,080 --> 00:23:33,600
lenders

00:23:31,120 --> 00:23:35,120
are modeled internally in the compilers

00:23:33,600 --> 00:23:37,280
or direct class that's

00:23:35,120 --> 00:23:38,240
what c plus plus inside shows me here so

00:23:37,280 --> 00:23:40,320
i have

00:23:38,240 --> 00:23:42,400
my lambda here we are currently looking

00:23:40,320 --> 00:23:45,520
at because it's a

00:23:42,400 --> 00:23:48,559
generic lambda generic lambdas are

00:23:45,520 --> 00:23:51,760
essentially come with a method

00:23:48,559 --> 00:23:54,799
template as call operator so i have the

00:23:51,760 --> 00:23:57,600
different instantiations for this

00:23:54,799 --> 00:23:59,360
variety for these various arguments i'm

00:23:57,600 --> 00:24:03,200
calling this lambda with so

00:23:59,360 --> 00:24:06,240
first within constant char ref of size 4

00:24:03,200 --> 00:24:08,640
then only with an end graph

00:24:06,240 --> 00:24:09,279
and now if we are looking down here we

00:24:08,640 --> 00:24:11,520
can see

00:24:09,279 --> 00:24:13,679
these are the two arguments in my pack

00:24:11,520 --> 00:24:14,880
which are applied as a fold expression

00:24:13,679 --> 00:24:16,799
to my lambda

00:24:14,880 --> 00:24:18,799
so see how the arc is called with the

00:24:16,799 --> 00:24:19,679
first argument and then with the second

00:24:18,799 --> 00:24:22,799
argument

00:24:19,679 --> 00:24:26,400
first argument as it's in the pack is c

00:24:22,799 --> 00:24:29,919
plus second argument is 20.

00:24:26,400 --> 00:24:33,440
so here the comma operator helps us to

00:24:29,919 --> 00:24:35,520
sequence a couple of calls and apply it

00:24:33,440 --> 00:24:39,120
together with the

00:24:35,520 --> 00:24:42,240
the fault expression to a function

00:24:39,120 --> 00:24:44,880
such that we can do the operation there

00:24:42,240 --> 00:24:46,559
saving us the recursion you can see

00:24:44,880 --> 00:24:50,720
there is no longer the need for a

00:24:46,559 --> 00:24:53,679
context prayer for things like that in

00:24:50,720 --> 00:24:55,679
question always is how many arguments

00:24:53,679 --> 00:24:57,679
can you pass there that it makes

00:24:55,679 --> 00:24:59,919
sense or that it's still sensible and

00:24:57,679 --> 00:25:01,919
that of course depends on on your

00:24:59,919 --> 00:25:05,600
compiler and your optimizer

00:25:01,919 --> 00:25:07,360
and there's probably a certain threshold

00:25:05,600 --> 00:25:08,960
where it may be better to do that in the

00:25:07,360 --> 00:25:12,000
loop at runtime

00:25:08,960 --> 00:25:15,600
um than having such a long call but

00:25:12,000 --> 00:25:18,000
optimizers and compilers are great so

00:25:15,600 --> 00:25:19,200
look at the number and maybe for your

00:25:18,000 --> 00:25:22,559
compiler

00:25:19,200 --> 00:25:22,559
it's sufficient enough for you

00:25:23,679 --> 00:25:29,840
so let's look at questions what i have

00:25:26,840 --> 00:25:29,840
here

00:25:30,240 --> 00:25:34,159
i have a very specific one saying that

00:25:33,200 --> 00:25:36,799
on slides

00:25:34,159 --> 00:25:39,200
three why do i use template

00:25:36,799 --> 00:25:42,400
specialization for the overloads on line

00:25:39,200 --> 00:25:43,919
two to four what are the pros and cons

00:25:42,400 --> 00:25:46,000
of overloads versus template

00:25:43,919 --> 00:25:49,120
specializations

00:25:46,000 --> 00:25:51,360
so roughly because i would have to

00:25:49,120 --> 00:25:53,120
type more to create a template

00:25:51,360 --> 00:25:56,000
specializations here

00:25:53,120 --> 00:25:57,600
and secondly three functions trump

00:25:56,000 --> 00:26:01,120
template functions

00:25:57,600 --> 00:26:02,960
so i have to make sure and i could add

00:26:01,120 --> 00:26:06,720
with a specialization

00:26:02,960 --> 00:26:08,840
that if normalize in line six seven if b

00:26:06,720 --> 00:26:10,400
is called with a stood string that the

00:26:08,840 --> 00:26:13,279
specialization

00:26:10,400 --> 00:26:14,559
is really the the function that the

00:26:13,279 --> 00:26:16,480
compiler calls

00:26:14,559 --> 00:26:18,000
specialization would do their job but i

00:26:16,480 --> 00:26:20,720
would have to write more

00:26:18,000 --> 00:26:22,480
and if there is a specialization for

00:26:20,720 --> 00:26:26,159
example of stood string

00:26:22,480 --> 00:26:26,960
and the function as provided in line

00:26:26,159 --> 00:26:30,080
number two

00:26:26,960 --> 00:26:30,960
then line number two wins so i'm on the

00:26:30,080 --> 00:26:33,279
safe side

00:26:30,960 --> 00:26:35,039
doing it that way and i have to write

00:26:33,279 --> 00:26:37,840
and type a little more and read

00:26:35,039 --> 00:26:40,559
so that's why i prefer that solution i

00:26:37,840 --> 00:26:40,559
hope that helps

00:26:43,039 --> 00:26:46,799
how to decide whether it is appropriate

00:26:45,440 --> 00:26:50,320
to use templates

00:26:46,799 --> 00:26:52,320
versus some other mechanisms performance

00:26:50,320 --> 00:26:54,880
code reusability

00:26:52,320 --> 00:26:56,240
yeah well that's probably a question of

00:26:54,880 --> 00:26:59,279
its own

00:26:56,240 --> 00:27:00,720
simple short answer is it's hard you

00:26:59,279 --> 00:27:03,039
have to know your target you have to

00:27:00,720 --> 00:27:04,880
know your use case and you have to know

00:27:03,039 --> 00:27:09,600
your benefits and the downsides

00:27:04,880 --> 00:27:11,840
so tablets can increase your binary but

00:27:09,600 --> 00:27:12,960
they probably only do it for a good

00:27:11,840 --> 00:27:14,720
reason because

00:27:12,960 --> 00:27:16,400
they are type safe so they're creating

00:27:14,720 --> 00:27:17,600
the different versions for the different

00:27:16,400 --> 00:27:20,559
types you're calling

00:27:17,600 --> 00:27:23,200
without them you may have implicit

00:27:20,559 --> 00:27:24,960
conversions and come out with only two

00:27:23,200 --> 00:27:26,480
functions instead of say four the

00:27:24,960 --> 00:27:28,960
template graded for you

00:27:26,480 --> 00:27:30,799
so that could be a thing but then you're

00:27:28,960 --> 00:27:32,080
more safe and you can wait whether you

00:27:30,799 --> 00:27:35,840
want that or not

00:27:32,080 --> 00:27:38,080
reusability is a great thing so

00:27:35,840 --> 00:27:40,399
templates make it easy to re reuse your

00:27:38,080 --> 00:27:43,840
code but in general you you have to look

00:27:40,399 --> 00:27:45,440
into it more specifically feel free to

00:27:43,840 --> 00:27:47,760
approach me at a conference we

00:27:45,440 --> 00:27:49,520
can have a chat about this this is a

00:27:47,760 --> 00:27:52,640
longer discussion usually when it makes

00:27:49,520 --> 00:27:52,640
sense and when it stops

00:27:54,559 --> 00:27:58,559
so here's another example for fall

00:27:57,039 --> 00:28:00,799
expressions

00:27:58,559 --> 00:28:02,000
um what can you do with them so before

00:28:00,799 --> 00:28:04,799
we we have this

00:28:02,000 --> 00:28:06,320
print function that's nice here we have

00:28:04,799 --> 00:28:08,480
something different

00:28:06,320 --> 00:28:09,360
i reused the normalize function we've

00:28:08,480 --> 00:28:12,559
seen before in

00:28:09,360 --> 00:28:15,919
a in the first

00:28:12,559 --> 00:28:17,840
first slide and now i have a new veridic

00:28:15,919 --> 00:28:20,880
function template in b

00:28:17,840 --> 00:28:22,880
build cvs line and its purpose is to

00:28:20,880 --> 00:28:26,320
create a comma separated line

00:28:22,880 --> 00:28:28,559
out of all the parameters i'm passing in

00:28:26,320 --> 00:28:30,799
and that means that it has to convert

00:28:28,559 --> 00:28:33,760
every parameter into a stud string

00:28:30,799 --> 00:28:34,799
and separate each of these strings by

00:28:33,760 --> 00:28:36,960
comma

00:28:34,799 --> 00:28:38,000
before with the print we separated it

00:28:36,960 --> 00:28:40,559
with a space

00:28:38,000 --> 00:28:41,279
so we combine these two techniques now

00:28:40,559 --> 00:28:44,399
we have my

00:28:41,279 --> 00:28:46,799
the normalized functions which convert

00:28:44,399 --> 00:28:48,720
probably everything into a stud string

00:28:46,799 --> 00:28:49,120
if you figure out that you have a type

00:28:48,720 --> 00:28:50,880
that

00:28:49,120 --> 00:28:52,799
isn't convertible to a stool string you

00:28:50,880 --> 00:28:53,919
have to write your own conversion

00:28:52,799 --> 00:28:57,360
function

00:28:53,919 --> 00:28:59,039
normalize but suppose we have that then

00:28:57,360 --> 00:28:59,760
the pattern here is the same i'm

00:28:59,039 --> 00:29:03,600
creating

00:28:59,760 --> 00:29:05,600
inline number 10 the return variable

00:29:03,600 --> 00:29:07,440
red they call normalize here in the

00:29:05,600 --> 00:29:10,080
first argument i expect

00:29:07,440 --> 00:29:12,080
that normalize returns a stood string so

00:29:10,080 --> 00:29:14,000
i use order here to deduce the

00:29:12,080 --> 00:29:17,039
return tie or the type of the variable

00:29:14,000 --> 00:29:19,360
red and then i once again have this

00:29:17,039 --> 00:29:20,480
lambda in place this time it's called

00:29:19,360 --> 00:29:23,120
add colon and

00:29:20,480 --> 00:29:23,840
normalize it's once again a generic

00:29:23,120 --> 00:29:26,799
lambda

00:29:23,840 --> 00:29:29,039
taking a const or the ref for arc and

00:29:26,799 --> 00:29:32,159
instead of

00:29:29,039 --> 00:29:35,039
writing it to c out it now captures

00:29:32,159 --> 00:29:35,760
by reference the red variable and the

00:29:35,039 --> 00:29:38,960
parents

00:29:35,760 --> 00:29:42,240
the comma to it and it's

00:29:38,960 --> 00:29:44,480
the normalized version

00:29:42,240 --> 00:29:46,559
of arc and the arc is the thing i'm

00:29:44,480 --> 00:29:50,080
passing into this lambda

00:29:46,559 --> 00:29:50,960
and then in line number 16 i do the same

00:29:50,080 --> 00:29:53,840
thing as before

00:29:50,960 --> 00:29:54,799
in my print function i use my parameter

00:29:53,840 --> 00:29:57,520
pack

00:29:54,799 --> 00:29:59,760
i expanded with the urinary left fold

00:29:57,520 --> 00:30:00,720
and this time i call add colon and

00:29:59,760 --> 00:30:03,279
normalize

00:30:00,720 --> 00:30:04,240
on my parameter pack on arcs as before

00:30:03,279 --> 00:30:06,399
remember

00:30:04,240 --> 00:30:07,360
these three dots are already in front so

00:30:06,399 --> 00:30:10,159
i do not have

00:30:07,360 --> 00:30:12,159
and i'm not allowed to repeat them here

00:30:10,159 --> 00:30:15,440
in the abnormal at colon

00:30:12,159 --> 00:30:18,159
and normalize call

00:30:15,440 --> 00:30:19,039
and with that i have a small little

00:30:18,159 --> 00:30:22,240
function

00:30:19,039 --> 00:30:25,279
which helps me to create a

00:30:22,240 --> 00:30:27,200
cvs line out of arbitrary types

00:30:25,279 --> 00:30:28,559
as long as i have the functions to

00:30:27,200 --> 00:30:30,720
convert them to

00:30:28,559 --> 00:30:32,320
a stool string so that's really great

00:30:30,720 --> 00:30:34,960
tool because developers

00:30:32,320 --> 00:30:35,679
users now only have to remember this one

00:30:34,960 --> 00:30:38,960
function

00:30:35,679 --> 00:30:40,799
and if you hit a situation

00:30:38,960 --> 00:30:42,960
where you have a type that isn't

00:30:40,799 --> 00:30:44,559
convertible now to a stool string

00:30:42,960 --> 00:30:46,880
you can come up and write your own

00:30:44,559 --> 00:30:50,159
normalized function which does the job

00:30:46,880 --> 00:30:53,440
and nobody has to know everybody still

00:30:50,159 --> 00:30:56,640
simply calls build cvs log

00:30:53,440 --> 00:30:59,120
that's one application area

00:30:56,640 --> 00:31:01,120
for all what we've seen so far for fault

00:30:59,120 --> 00:31:04,399
expressions for vari templates

00:31:01,120 --> 00:31:08,000
function templates itself

00:31:04,399 --> 00:31:11,360
we then can call it as shown here below

00:31:08,000 --> 00:31:13,840
with a q string as i had that before

00:31:11,360 --> 00:31:16,720
we can now say build cvs line hello

00:31:13,840 --> 00:31:20,159
comma stood string c plus plus comma 20

00:31:16,720 --> 00:31:23,360
and the q string says at cppcon

00:31:20,159 --> 00:31:26,399
and then i chose printf to print it out

00:31:23,360 --> 00:31:29,360
so that's how that thing

00:31:26,399 --> 00:31:30,799
is used or it's called and as i said in

00:31:29,360 --> 00:31:32,720
the first part

00:31:30,799 --> 00:31:34,000
if you call this or if you see only the

00:31:32,720 --> 00:31:35,679
call side

00:31:34,000 --> 00:31:37,679
you do not notice that we are talking

00:31:35,679 --> 00:31:41,440
about the template that's

00:31:37,679 --> 00:31:43,039
cool what other things can we do with

00:31:41,440 --> 00:31:46,080
spreading templates

00:31:43,039 --> 00:31:49,039
well we can

00:31:46,080 --> 00:31:50,720
use it to compare data structures the

00:31:49,039 --> 00:31:54,559
case i'm having here is

00:31:50,720 --> 00:31:55,679
i have a mac address the mac address is

00:31:54,559 --> 00:31:58,799
a struct here

00:31:55,679 --> 00:31:59,840
which has an array in it of type

00:31:58,799 --> 00:32:01,760
unsigned char

00:31:59,840 --> 00:32:03,440
and it has six values because the mac

00:32:01,760 --> 00:32:07,039
address if you know that

00:32:03,440 --> 00:32:10,080
comes with six digits they are often

00:32:07,039 --> 00:32:12,880
displayed as hexadecimal representation

00:32:10,080 --> 00:32:16,080
if we are printing them or viewing them

00:32:12,880 --> 00:32:16,640
and the idea here is that that i'm

00:32:16,080 --> 00:32:19,760
creating

00:32:16,640 --> 00:32:22,960
three different um variables of my mac

00:32:19,760 --> 00:32:24,880
address mca mcb mcc

00:32:22,960 --> 00:32:26,399
i fill them with the values and as you

00:32:24,880 --> 00:32:29,760
can see mca and c

00:32:26,399 --> 00:32:31,519
are the same just

00:32:29,760 --> 00:32:32,880
they have different names but the

00:32:31,519 --> 00:32:35,440
contents are the same

00:32:32,880 --> 00:32:40,159
and only b differs in the last digit

00:32:35,440 --> 00:32:40,159
because there it has four instead of two

00:32:40,240 --> 00:32:47,200
and the goal is that i'm

00:32:43,440 --> 00:32:47,919
able to either or in both versions to be

00:32:47,200 --> 00:32:50,880
precise

00:32:47,919 --> 00:32:51,760
to call a function or something called

00:32:50,880 --> 00:32:54,080
compare

00:32:51,760 --> 00:32:55,679
which is able to compare my mac address

00:32:54,080 --> 00:32:58,960
or the array in it

00:32:55,679 --> 00:33:01,200
to a value against the value as shown

00:32:58,960 --> 00:33:04,080
here on line number 13 and 14

00:33:01,200 --> 00:33:05,039
that should tell me whether each element

00:33:04,080 --> 00:33:07,279
in that array

00:33:05,039 --> 00:33:08,880
correspond or equal that number i'm

00:33:07,279 --> 00:33:11,279
passing in here or not

00:33:08,880 --> 00:33:13,200
so for a mac a that should yield to true

00:33:11,279 --> 00:33:14,080
as the static assert indicates and from

00:33:13,200 --> 00:33:17,360
a macb

00:33:14,080 --> 00:33:19,760
in line 14 that should return

00:33:17,360 --> 00:33:21,519
false my compare so i have to negate the

00:33:19,760 --> 00:33:22,799
result here to make that static a

00:33:21,519 --> 00:33:24,880
certain pairs

00:33:22,799 --> 00:33:26,240
that's a one application the other one

00:33:24,880 --> 00:33:29,600
is that i would

00:33:26,240 --> 00:33:32,640
also like to be able to compare

00:33:29,600 --> 00:33:38,000
two mac addresses with each other

00:33:32,640 --> 00:33:41,039
as shown in line number 17 and 18.

00:33:38,000 --> 00:33:43,279
the key idea is i do not like to have to

00:33:41,039 --> 00:33:44,640
remember different function names so i

00:33:43,279 --> 00:33:46,640
don't want to have

00:33:44,640 --> 00:33:47,840
something like compare array and compare

00:33:46,640 --> 00:33:50,240
value

00:33:47,840 --> 00:33:51,200
i i like to call it compare because

00:33:50,240 --> 00:33:53,679
there's

00:33:51,200 --> 00:33:54,640
they're doing the same thing just once

00:33:53,679 --> 00:33:57,919
against the value

00:33:54,640 --> 00:34:00,240
once against another version of a mac

00:33:57,919 --> 00:34:00,240
address

00:34:01,600 --> 00:34:04,840
solutions i have seen in the wild so far

00:34:04,080 --> 00:34:08,320
is

00:34:04,840 --> 00:34:11,679
using a macro function

00:34:08,320 --> 00:34:13,119
which then has the six cases already

00:34:11,679 --> 00:34:14,639
expanded because we

00:34:13,119 --> 00:34:16,720
know that we are dealing with a mac

00:34:14,639 --> 00:34:19,839
address so we can unfold that and

00:34:16,720 --> 00:34:22,159
use that function macro to make it

00:34:19,839 --> 00:34:23,919
easier to read in the code

00:34:22,159 --> 00:34:26,240
another version is that that function

00:34:23,919 --> 00:34:29,679
macro or even a function

00:34:26,240 --> 00:34:31,599
we have which takes the array and then

00:34:29,679 --> 00:34:33,440
loops in a for loop over it it knows

00:34:31,599 --> 00:34:35,359
that it's of size 6

00:34:33,440 --> 00:34:37,599
and if you lie about this or you're

00:34:35,359 --> 00:34:38,320
unintentionally passing in a shorter or

00:34:37,599 --> 00:34:41,839
larger

00:34:38,320 --> 00:34:44,879
buffer then you were screwed so

00:34:41,839 --> 00:34:46,720
we also like to be that thing type save

00:34:44,879 --> 00:34:48,240
and we can do that we have seen enough

00:34:46,720 --> 00:34:50,560
about templates so far

00:34:48,240 --> 00:34:52,720
that we can do that and we in fact can

00:34:50,560 --> 00:34:54,720
do that in 27 lines of code

00:34:52,720 --> 00:34:56,399
okay if you not like to refer to

00:34:54,720 --> 00:34:58,480
something like a stud algorithm

00:34:56,399 --> 00:35:00,400
if you like to unfold it and do it if

00:34:58,480 --> 00:35:03,520
possible at compile time

00:35:00,400 --> 00:35:05,599
this here is a solution

00:35:03,520 --> 00:35:07,040
we are starting this time from the

00:35:05,599 --> 00:35:10,800
bottom to the top

00:35:07,040 --> 00:35:13,760
because then um it's more readable so

00:35:10,800 --> 00:35:15,200
at the bottom most at b i have a

00:35:13,760 --> 00:35:16,640
function called compare

00:35:15,200 --> 00:35:19,040
it's a function template it takes the

00:35:16,640 --> 00:35:21,680
type name t and my size t

00:35:19,040 --> 00:35:23,680
parameter as before i'm using here the

00:35:21,680 --> 00:35:26,000
technique to let the compiler that use

00:35:23,680 --> 00:35:29,280
the type and the size of this array

00:35:26,000 --> 00:35:32,320
so compare in line 24

00:35:29,280 --> 00:35:35,440
essentially takes two ref

00:35:32,320 --> 00:35:36,240
array references of size n so the two

00:35:35,440 --> 00:35:38,880
parameters a

00:35:36,240 --> 00:35:40,720
and b both take a reference to an array

00:35:38,880 --> 00:35:44,160
of size n

00:35:40,720 --> 00:35:45,119
key here is that a and b have to be of

00:35:44,160 --> 00:35:47,760
the same type

00:35:45,119 --> 00:35:49,200
both have to be of type t and they have

00:35:47,760 --> 00:35:52,240
to be of the same size

00:35:49,200 --> 00:35:53,040
both have to be of size n okay if you

00:35:52,240 --> 00:35:55,119
pairs in

00:35:53,040 --> 00:35:56,960
differently sized arrays this will

00:35:55,119 --> 00:35:59,520
result in a compile error

00:35:56,960 --> 00:36:00,079
at compile time of course you can allow

00:35:59,520 --> 00:36:03,200
this

00:36:00,079 --> 00:36:05,200
um but what will that mean

00:36:03,200 --> 00:36:07,040
it's always false because there are

00:36:05,200 --> 00:36:07,839
elements you cannot compare or something

00:36:07,040 --> 00:36:10,560
like this so

00:36:07,839 --> 00:36:12,079
let it fail fast let it fail early let

00:36:10,560 --> 00:36:14,320
it fail at compile time

00:36:12,079 --> 00:36:15,599
this is what this does and then

00:36:14,320 --> 00:36:18,400
internally compare

00:36:15,599 --> 00:36:20,400
refers to another function in the

00:36:18,400 --> 00:36:23,119
namespace details array compare

00:36:20,400 --> 00:36:23,920
which is also called compare it passes

00:36:23,119 --> 00:36:26,640
in a and b

00:36:23,920 --> 00:36:28,640
so with two arrays and then as the third

00:36:26,640 --> 00:36:31,359
argument that function takes

00:36:28,640 --> 00:36:32,560
it calls the function from standard

00:36:31,359 --> 00:36:35,599
library called stood

00:36:32,560 --> 00:36:37,359
make index sequence and you can see by

00:36:35,599 --> 00:36:39,920
the angle brackets there

00:36:37,359 --> 00:36:40,960
it's once again on the template and it

00:36:39,920 --> 00:36:44,400
takes the number

00:36:40,960 --> 00:36:46,960
n so it takes the size of this array

00:36:44,400 --> 00:36:47,920
and what stood made us to make index

00:36:46,960 --> 00:36:50,800
sequence does

00:36:47,920 --> 00:36:51,760
is it creates a sequence from 0 to n

00:36:50,800 --> 00:36:55,280
minus 1

00:36:51,760 --> 00:36:58,079
of numbers for us and if we are looking

00:36:55,280 --> 00:36:58,400
at the details array compare namespace

00:36:58,079 --> 00:37:01,280
in

00:36:58,400 --> 00:37:03,280
line number 14 and 16 we see we are

00:37:01,280 --> 00:37:05,359
dealing with another function template

00:37:03,280 --> 00:37:06,400
called compare it takes the type name t

00:37:05,359 --> 00:37:08,400
as the outer one

00:37:06,400 --> 00:37:09,920
and the size n as the outer one as

00:37:08,400 --> 00:37:13,119
argument and then

00:37:09,920 --> 00:37:15,359
we're first looking at a non-type

00:37:13,119 --> 00:37:17,200
template parameter which is a variety

00:37:15,359 --> 00:37:20,720
pack my size t dot

00:37:17,200 --> 00:37:23,680
dot i okay

00:37:20,720 --> 00:37:24,560
and now compare itself takes once again

00:37:23,680 --> 00:37:27,200
two

00:37:24,560 --> 00:37:27,760
arrays which the compiler that uses the

00:37:27,200 --> 00:37:31,200
size and

00:37:27,760 --> 00:37:34,560
type for us and there's a third argument

00:37:31,200 --> 00:37:37,359
what something of stood index sequence

00:37:34,560 --> 00:37:38,160
of i dot dot dot so that thing gets

00:37:37,359 --> 00:37:40,400
expanded

00:37:38,160 --> 00:37:41,200
because we are looking once more about a

00:37:40,400 --> 00:37:43,040
template

00:37:41,200 --> 00:37:44,960
and the cool thing here is now i can

00:37:43,040 --> 00:37:48,160
refer to my

00:37:44,960 --> 00:37:48,160
parameter packs

00:37:48,880 --> 00:37:56,079
elements i in line number 19

00:37:52,560 --> 00:37:59,200
i can now say i like to compare

00:37:56,079 --> 00:38:02,560
a at position i with

00:37:59,200 --> 00:38:06,000
b at position i for equality and i

00:38:02,560 --> 00:38:08,240
apply the boolean and to this operation

00:38:06,000 --> 00:38:11,200
and then i expand it so here we are

00:38:08,240 --> 00:38:14,880
looking at a right fold

00:38:11,200 --> 00:38:17,520
by that essentially my array gets

00:38:14,880 --> 00:38:18,000
unfolded and each element of a and b get

00:38:17,520 --> 00:38:19,520
compared

00:38:18,000 --> 00:38:22,079
with each other we'll look at this and

00:38:19,520 --> 00:38:24,720
see plus plus and sides in a moment

00:38:22,079 --> 00:38:27,440
and the same thing is done for the

00:38:24,720 --> 00:38:29,200
single array comparison we have it in a

00:38:27,440 --> 00:38:30,640
the only difference is that now i'm

00:38:29,200 --> 00:38:33,280
passing in only

00:38:30,640 --> 00:38:35,680
one array and the value but other than

00:38:33,280 --> 00:38:37,520
that it stays the same

00:38:35,680 --> 00:38:39,760
and if you look at this in c plus plus

00:38:37,520 --> 00:38:47,839
and size

00:38:39,760 --> 00:38:47,839
we have that here then we can see

00:38:51,599 --> 00:38:55,040
then in fact the compiler creates what

00:38:53,599 --> 00:38:56,800
i've told you for us

00:38:55,040 --> 00:38:58,079
so if you're looking at this function

00:38:56,800 --> 00:39:01,599
which is the

00:38:58,079 --> 00:39:04,880
function comparing my

00:39:01,599 --> 00:39:07,200
array to a value

00:39:04,880 --> 00:39:08,240
then you can see it's instantiated with

00:39:07,200 --> 00:39:10,800
type jar

00:39:08,240 --> 00:39:11,839
size 6 my arrays of type unsigned jar

00:39:10,800 --> 00:39:13,440
and size 6

00:39:11,839 --> 00:39:15,200
and then with an end and that's

00:39:13,440 --> 00:39:18,320
interesting because when i

00:39:15,200 --> 00:39:19,599
wrote this code initially i used instead

00:39:18,320 --> 00:39:23,680
of u here

00:39:19,599 --> 00:39:24,320
i used t to have my value i'm comparing

00:39:23,680 --> 00:39:27,359
it to

00:39:24,320 --> 00:39:28,000
the same type as my arrays type but it

00:39:27,359 --> 00:39:30,960
turned out

00:39:28,000 --> 00:39:33,280
that due to the implicit conversions

00:39:30,960 --> 00:39:36,800
which are not happening

00:39:33,280 --> 00:39:38,880
in templates

00:39:36,800 --> 00:39:41,040
it didn't compile in a lot of cases and

00:39:38,880 --> 00:39:43,040
there was a lot of typing that we are

00:39:41,040 --> 00:39:45,119
now talking about an unsigned jar

00:39:43,040 --> 00:39:47,280
and unsigned short something like this

00:39:45,119 --> 00:39:50,960
so in this case it felt easier

00:39:47,280 --> 00:39:53,599
to have a different value a type

00:39:50,960 --> 00:39:55,359
available or possible to be passed in

00:39:53,599 --> 00:39:58,480
which in this case isn't

00:39:55,359 --> 00:40:01,920
and then we are seeing the

00:39:58,480 --> 00:40:04,000
magic of the stood make index sequence

00:40:01,920 --> 00:40:05,200
this is the index sequence from zero to

00:40:04,000 --> 00:40:08,319
five so from

00:40:05,200 --> 00:40:09,359
zero to n minus one and then here we can

00:40:08,319 --> 00:40:12,560
see

00:40:09,359 --> 00:40:16,079
a at index zero equals b and

00:40:12,560 --> 00:40:19,200
and a at index one

00:40:16,079 --> 00:40:22,720
equals b b and so forth there equals b

00:40:19,200 --> 00:40:24,640
sorry and all the time we can see that

00:40:22,720 --> 00:40:26,720
a is promoted to an integer with a

00:40:24,640 --> 00:40:27,599
static cost it's another thing c plus

00:40:26,720 --> 00:40:30,079
plus insides

00:40:27,599 --> 00:40:31,119
shows you and the same thing happens of

00:40:30,079 --> 00:40:34,240
course for

00:40:31,119 --> 00:40:35,680
my the other compare version where we

00:40:34,240 --> 00:40:38,319
are comparing

00:40:35,680 --> 00:40:40,079
the two arrays with each other so it's

00:40:38,319 --> 00:40:40,960
the same thing that you can write by

00:40:40,079 --> 00:40:43,040
hand

00:40:40,960 --> 00:40:44,079
but this time the compiler does it for

00:40:43,040 --> 00:40:46,079
us which

00:40:44,079 --> 00:40:47,920
is always great if you don't have to

00:40:46,079 --> 00:40:51,119
type it ourselves

00:40:47,920 --> 00:40:52,000
this is the code the 27 lines it takes

00:40:51,119 --> 00:40:55,280
in c

00:40:52,000 --> 00:40:58,319
plus plus 17 to come up with that

00:40:55,280 --> 00:41:00,960
in c plus 20 we can reduce this to

00:40:58,319 --> 00:41:01,680
13 lines of code it more or less does

00:41:00,960 --> 00:41:04,800
the same

00:41:01,680 --> 00:41:07,440
but in c plus plus 20 we have the

00:41:04,800 --> 00:41:10,000
ability to have lambdas with a template

00:41:07,440 --> 00:41:10,880
head as you can see for example in line

00:41:10,000 --> 00:41:14,079
4 and

00:41:10,880 --> 00:41:14,880
11 it starts with return and then the

00:41:14,079 --> 00:41:18,000
brackets

00:41:14,880 --> 00:41:19,839
for the captures of our lambda followed

00:41:18,000 --> 00:41:20,800
by the ankle brackets which we know from

00:41:19,839 --> 00:41:23,280
templates

00:41:20,800 --> 00:41:24,240
and in that we can specify the template

00:41:23,280 --> 00:41:25,760
parameters

00:41:24,240 --> 00:41:27,839
so this is the only case where you're

00:41:25,760 --> 00:41:30,720
technically looking at a template

00:41:27,839 --> 00:41:33,119
or writing template parameters but you

00:41:30,720 --> 00:41:36,960
don't write template in front of it

00:41:33,119 --> 00:41:40,160
and now my lambda takes a parameter pack

00:41:36,960 --> 00:41:43,520
non-type term parameter pack as before

00:41:40,160 --> 00:41:46,000
my my verdict function in the namespace

00:41:43,520 --> 00:41:48,000
and it does essentially the same job but

00:41:46,000 --> 00:41:50,720
i don't have to have all

00:41:48,000 --> 00:41:51,920
these additional functions in namespaces

00:41:50,720 --> 00:41:54,720
lingering around

00:41:51,920 --> 00:41:55,359
so this is a more compact version to

00:41:54,720 --> 00:42:02,400
write it

00:41:55,359 --> 00:42:05,680
it's the power of c plus plus 20.

00:42:02,400 --> 00:42:09,280
then we are having one more thing um

00:42:05,680 --> 00:42:09,280
these are variable templates

00:42:09,359 --> 00:42:13,839
variables can become templates since c

00:42:11,680 --> 00:42:17,760
plus plus 14 as well

00:42:13,839 --> 00:42:20,880
this helps us to define constants like

00:42:17,760 --> 00:42:24,000
pi and have it converted into

00:42:20,880 --> 00:42:28,240
different types so if you define it for

00:42:24,000 --> 00:42:31,359
double then you have the 3.14

00:42:28,240 --> 00:42:32,960
and the force whatever your position is

00:42:31,359 --> 00:42:36,000
there and if you convert it to an end

00:42:32,960 --> 00:42:38,480
you only have the three

00:42:36,000 --> 00:42:40,160
but you can also make template meter

00:42:38,480 --> 00:42:42,800
programming tmp

00:42:40,160 --> 00:42:44,800
code more readable if you like think

00:42:42,800 --> 00:42:47,040
it's readable at all

00:42:44,800 --> 00:42:48,240
if not with that hopefully it gets

00:42:47,040 --> 00:42:50,480
readable for you

00:42:48,240 --> 00:42:51,440
so the example on the right is something

00:42:50,480 --> 00:42:54,240
we had

00:42:51,440 --> 00:42:55,599
only even seen in the first part already

00:42:54,240 --> 00:42:57,760
seen in the first part

00:42:55,599 --> 00:42:58,720
it's where i'm creating my stud integral

00:42:57,760 --> 00:43:01,760
constant i

00:42:58,720 --> 00:43:03,359
have the false and true type and i have

00:43:01,760 --> 00:43:06,160
the

00:43:03,359 --> 00:43:08,400
primary template this pointer which all

00:43:06,160 --> 00:43:11,040
this yields to false and then c

00:43:08,400 --> 00:43:14,480
and then i have the specialization in d

00:43:11,040 --> 00:43:17,920
which yields to

00:43:14,480 --> 00:43:20,400
true if we are passing in a pointer and

00:43:17,920 --> 00:43:21,440
the thing here is if you look at line 25

00:43:20,400 --> 00:43:24,880
and 26

00:43:21,440 --> 00:43:26,880
this is why tmp code often gets so ugly

00:43:24,880 --> 00:43:29,040
to read or to write because i have to

00:43:26,880 --> 00:43:31,040
write is pointer in ankle brackets my

00:43:29,040 --> 00:43:33,200
type colon column value

00:43:31,040 --> 00:43:34,160
this colon colon value is all over the

00:43:33,200 --> 00:43:37,359
place

00:43:34,160 --> 00:43:40,640
it's it hinders readability so

00:43:37,359 --> 00:43:44,160
variable templates can help us in a way

00:43:40,640 --> 00:43:45,599
that now in line 21 i'm defining such a

00:43:44,160 --> 00:43:48,880
variable template

00:43:45,599 --> 00:43:51,280
it starts once again was template

00:43:48,880 --> 00:43:52,000
and then in ankle brackets type nt so

00:43:51,280 --> 00:43:55,119
takes a

00:43:52,000 --> 00:43:57,599
type parameter this thing is of

00:43:55,119 --> 00:43:58,720
uh is const express the variable is of

00:43:57,599 --> 00:44:01,200
type order

00:43:58,720 --> 00:44:02,960
and i named it as pointer v this is the

00:44:01,200 --> 00:44:05,200
convention to end it with v

00:44:02,960 --> 00:44:06,720
if it points to a value and then i say

00:44:05,200 --> 00:44:12,000
equals is pointer

00:44:06,720 --> 00:44:15,359
and angle brackets t colon colon value

00:44:12,000 --> 00:44:17,839
by that essentially this pointer gets

00:44:15,359 --> 00:44:19,920
to be a boolean which points to the

00:44:17,839 --> 00:44:21,839
value or stores the value

00:44:19,920 --> 00:44:23,359
of this instantiation because all this

00:44:21,839 --> 00:44:25,680
happens at compile time

00:44:23,359 --> 00:44:27,359
this yields to is point of v either

00:44:25,680 --> 00:44:30,000
being true or false

00:44:27,359 --> 00:44:31,200
for your specific type so technically

00:44:30,000 --> 00:44:33,520
you can have

00:44:31,200 --> 00:44:35,920
multiple is point of v variables in your

00:44:33,520 --> 00:44:36,319
code because they're all instantiated

00:44:35,920 --> 00:44:39,760
for

00:44:36,319 --> 00:44:43,119
different types and all that helps me

00:44:39,760 --> 00:44:43,839
to write line 26 and 27 shorter than

00:44:43,119 --> 00:44:47,040
before

00:44:43,839 --> 00:44:50,400
because now i can say is point of v of

00:44:47,040 --> 00:44:53,520
end star or not is point a v

00:44:50,400 --> 00:44:56,640
of type it so this is the

00:44:53,520 --> 00:44:58,319
case where a variable template a

00:44:56,640 --> 00:45:01,839
variable template helps you

00:44:58,319 --> 00:45:04,319
to make your code your template code

00:45:01,839 --> 00:45:05,119
look a little bit nicer and it also

00:45:04,319 --> 00:45:08,079
helps you

00:45:05,119 --> 00:45:11,680
later on if you like to refactor and

00:45:08,079 --> 00:45:11,680
rename value for example

00:45:12,240 --> 00:45:16,240
there's another technique we haven't

00:45:14,400 --> 00:45:19,440
talked about yet that's

00:45:16,240 --> 00:45:20,400
fine which is short for substitution

00:45:19,440 --> 00:45:23,839
failure is

00:45:20,400 --> 00:45:27,040
not an error and

00:45:23,839 --> 00:45:29,599
this is needed and it's helpful

00:45:27,040 --> 00:45:32,000
because whenever the compiler looks into

00:45:29,599 --> 00:45:35,119
instantiating a template

00:45:32,000 --> 00:45:36,240
and it turns out that this instantiation

00:45:35,119 --> 00:45:39,520
would fail

00:45:36,240 --> 00:45:42,560
the compiler silently discards that

00:45:39,520 --> 00:45:44,960
and it tries another version or another

00:45:42,560 --> 00:45:44,960
function

00:45:45,520 --> 00:45:51,839
if that all ends for the compiler

00:45:49,520 --> 00:45:53,839
in having found no function to

00:45:51,839 --> 00:45:56,800
instantiate

00:45:53,839 --> 00:45:57,760
a function template to instantiate with

00:45:56,800 --> 00:46:01,599
that given

00:45:57,760 --> 00:46:04,480
set of variables or types values

00:46:01,599 --> 00:46:05,599
and there is no free function a global

00:46:04,480 --> 00:46:08,079
function available

00:46:05,599 --> 00:46:10,079
the same name that takes these arguments

00:46:08,079 --> 00:46:13,359
then it results in a compile error

00:46:10,079 --> 00:46:14,240
but if the compiler files another

00:46:13,359 --> 00:46:16,079
template

00:46:14,240 --> 00:46:18,400
same name but different argument

00:46:16,079 --> 00:46:21,200
combination that matches

00:46:18,400 --> 00:46:22,160
then all the previous versions which

00:46:21,200 --> 00:46:24,319
failed

00:46:22,160 --> 00:46:26,319
you never know about them but the

00:46:24,319 --> 00:46:26,960
compiler instantiates the version that

00:46:26,319 --> 00:46:29,920
works

00:46:26,960 --> 00:46:30,720
and we are all happy if it not if it's

00:46:29,920 --> 00:46:32,480
not working

00:46:30,720 --> 00:46:35,040
then you're probably getting out this

00:46:32,480 --> 00:46:40,319
pagewise error output we

00:46:35,040 --> 00:46:40,319
briefly talked about

00:46:41,040 --> 00:46:44,480
and where does this help and why do we

00:46:43,920 --> 00:46:47,839
need

00:46:44,480 --> 00:46:50,240
these look at the example i've shared

00:46:47,839 --> 00:46:52,319
with you in the first part i have this

00:46:50,240 --> 00:46:54,720
equal function that compares with a

00:46:52,319 --> 00:46:56,560
and b is equal in line four and then i

00:46:54,720 --> 00:46:59,440
have a specialization

00:46:56,560 --> 00:47:01,119
for type double because as i explained

00:46:59,440 --> 00:47:02,720
there floating point numbers have to be

00:47:01,119 --> 00:47:06,400
treated a little bit different

00:47:02,720 --> 00:47:09,440
than non-floating point since

00:47:06,400 --> 00:47:11,200
yet that thing works but

00:47:09,440 --> 00:47:12,960
we have more than one floating point

00:47:11,200 --> 00:47:14,880
type and c plus plus i mean c

00:47:12,960 --> 00:47:16,079
plus of course we have different ways to

00:47:14,880 --> 00:47:19,280
do things so

00:47:16,079 --> 00:47:22,480
we have not only double we have also

00:47:19,280 --> 00:47:26,079
float but this isn't caught here

00:47:22,480 --> 00:47:27,119
so what be the solution duplicating my

00:47:26,079 --> 00:47:30,880
template code

00:47:27,119 --> 00:47:32,880
from line 7 to line 11 and change double

00:47:30,880 --> 00:47:36,400
to float

00:47:32,880 --> 00:47:39,119
ah no doesn't seem

00:47:36,400 --> 00:47:41,200
or sound like the right thing so what

00:47:39,119 --> 00:47:43,760
you can do is we can use

00:47:41,200 --> 00:47:46,160
fini and now we are looking deeper into

00:47:43,760 --> 00:47:47,839
that stuff that usually scares people a

00:47:46,160 --> 00:47:51,280
little bit away because it

00:47:47,839 --> 00:47:51,280
starts getting unreadable

00:47:51,359 --> 00:47:58,800
swiney is active here and i'm using it

00:47:55,520 --> 00:48:00,400
or yeah make use of it with stood enable

00:47:58,800 --> 00:48:03,440
if t

00:48:00,400 --> 00:48:06,960
as you can see in line two and line nine

00:48:03,440 --> 00:48:08,800
and so to enable if takes two arguments

00:48:06,960 --> 00:48:10,079
it takes a condition which is either

00:48:08,800 --> 00:48:13,359
true or false

00:48:10,079 --> 00:48:14,400
and the return type or type that stood

00:48:13,359 --> 00:48:17,040
enable if t

00:48:14,400 --> 00:48:17,440
yields to and in the first case i say

00:48:17,040 --> 00:48:21,280
okay

00:48:17,440 --> 00:48:24,880
enable that that thing if

00:48:21,280 --> 00:48:26,960
t is not of type floating point and then

00:48:24,880 --> 00:48:28,319
the result of my n i believe should be

00:48:26,960 --> 00:48:30,960
of type

00:48:28,319 --> 00:48:32,480
bool so that's like before and then i

00:48:30,960 --> 00:48:33,200
have the second version in line number

00:48:32,480 --> 00:48:37,599
nine

00:48:33,200 --> 00:48:39,839
which says enable this one if

00:48:37,599 --> 00:48:40,640
t is substitute floating point and of

00:48:39,839 --> 00:48:43,760
course

00:48:40,640 --> 00:48:46,720
keep the same type keep it cool

00:48:43,760 --> 00:48:49,119
i put if you look closely at this i put

00:48:46,720 --> 00:48:51,119
this enable if on the return type

00:48:49,119 --> 00:48:53,920
because there is no other return type

00:48:51,119 --> 00:48:55,839
essentially that enable ifs makes up

00:48:53,920 --> 00:48:56,400
whether this function has a return type

00:48:55,839 --> 00:48:57,760
or not

00:48:56,400 --> 00:48:59,359
and if there is no return type the

00:48:57,760 --> 00:49:01,040
compiler cannot do anything with that

00:48:59,359 --> 00:49:02,800
function so it throws it away that's

00:49:01,040 --> 00:49:06,000
that's this finney here

00:49:02,800 --> 00:49:08,559
so that means that i now can call this

00:49:06,000 --> 00:49:11,040
with a double with a float within it

00:49:08,559 --> 00:49:11,599
if i call it this floater with a double

00:49:11,040 --> 00:49:14,559
the

00:49:11,599 --> 00:49:15,440
function in line 12 will be chosen and

00:49:14,559 --> 00:49:18,559
otherwise

00:49:15,440 --> 00:49:20,880
the one in line

00:49:18,559 --> 00:49:20,880
five

00:49:24,720 --> 00:49:28,880
so as here another question here any

00:49:26,559 --> 00:49:32,079
reason you're using template class t

00:49:28,880 --> 00:49:35,280
instead of template type name t

00:49:32,079 --> 00:49:38,640
here it seems to be the first time yes i

00:49:35,280 --> 00:49:40,960
switched because simply it works so

00:49:38,640 --> 00:49:41,839
you can use either type name or class

00:49:40,960 --> 00:49:44,559
here

00:49:41,839 --> 00:49:46,160
and this is just another way to confuse

00:49:44,559 --> 00:49:48,800
people new to templates

00:49:46,160 --> 00:49:50,559
there are a few places i'm not have the

00:49:48,800 --> 00:49:53,119
time to talk about this today

00:49:50,559 --> 00:49:54,079
where you can only use type name or only

00:49:53,119 --> 00:49:56,800
use class

00:49:54,079 --> 00:49:57,359
but in a template hat you for the most

00:49:56,800 --> 00:49:59,839
cases

00:49:57,359 --> 00:50:01,920
can use either type name or class they

00:49:59,839 --> 00:50:04,240
are changeable

00:50:01,920 --> 00:50:05,119
for me personally i usually use type

00:50:04,240 --> 00:50:07,680
name because

00:50:05,119 --> 00:50:08,319
class refers for me to an object but i

00:50:07,680 --> 00:50:11,040
can also

00:50:08,319 --> 00:50:12,000
pass built-in types like in like char to

00:50:11,040 --> 00:50:14,240
that thing

00:50:12,000 --> 00:50:16,559
so i grew up a little bit using type

00:50:14,240 --> 00:50:19,520
name for that instead of class because

00:50:16,559 --> 00:50:20,559
this class i'm declaring new types but

00:50:19,520 --> 00:50:27,839
that's just

00:50:20,559 --> 00:50:27,839
my my rule of thumb

00:50:28,079 --> 00:50:32,000
on a question here i will answer you

00:50:30,240 --> 00:50:35,119
later do you have a slide

00:50:32,000 --> 00:50:38,240
like this i'm showing here with concepts

00:50:35,119 --> 00:50:38,240
i guess yes

00:50:39,119 --> 00:50:44,000
so let's pause here we have this swinney

00:50:44,960 --> 00:50:49,839
oh okay wait the only reasons finney

00:50:48,079 --> 00:50:53,040
works is because the

00:50:49,839 --> 00:50:55,280
equal returns swinney is here put on the

00:50:53,040 --> 00:50:56,880
return type you can also put it either

00:50:55,280 --> 00:50:58,720
as an optional

00:50:56,880 --> 00:51:00,240
template argument into the template

00:50:58,720 --> 00:51:03,760
header as an

00:51:00,240 --> 00:51:04,319
additional optional parameter into your

00:51:03,760 --> 00:51:07,599
equal

00:51:04,319 --> 00:51:10,079
function signature both versions

00:51:07,599 --> 00:51:11,680
are visible to users so they are often

00:51:10,079 --> 00:51:14,160
confused

00:51:11,680 --> 00:51:16,319
asking what they have to pass as the

00:51:14,160 --> 00:51:19,760
second or third argument here

00:51:16,319 --> 00:51:21,440
so my rule is put these 20 condition if

00:51:19,760 --> 00:51:23,520
possible at the return time

00:51:21,440 --> 00:51:25,119
and only if that doesn't work put it

00:51:23,520 --> 00:51:26,319
somewhere else so this is why i'm

00:51:25,119 --> 00:51:29,040
showing you here

00:51:26,319 --> 00:51:30,240
and yes this is why this this whole

00:51:29,040 --> 00:51:32,160
thing works because

00:51:30,240 --> 00:51:33,760
a function without the return type is

00:51:32,160 --> 00:51:35,520
not a function

00:51:33,760 --> 00:51:37,280
so this is where the compiler decides

00:51:35,520 --> 00:51:39,680
okay i have to throw this thing away and

00:51:37,280 --> 00:51:41,839
try another version and this is either

00:51:39,680 --> 00:51:43,839
the version where it's the float or it's

00:51:41,839 --> 00:51:46,319
not flawed

00:51:43,839 --> 00:51:47,280
so aside from swinney we can use

00:51:46,319 --> 00:51:49,280
something else

00:51:47,280 --> 00:51:51,280
we can use a technique called tact

00:51:49,280 --> 00:51:54,240
dispatch

00:51:51,280 --> 00:51:55,839
here i have that still we are talking

00:51:54,240 --> 00:51:58,400
about this equal function

00:51:55,839 --> 00:51:59,599
a little bit different now i have from

00:51:58,400 --> 00:52:02,079
the bottom to the top

00:51:59,599 --> 00:52:03,119
in line 19 i have my function template

00:52:02,079 --> 00:52:06,160
equal

00:52:03,119 --> 00:52:08,480
it takes two parameters a and b

00:52:06,160 --> 00:52:10,880
a constraint and then inside i'm using a

00:52:08,480 --> 00:52:11,839
constexpr if and once again querying the

00:52:10,880 --> 00:52:13,839
type of t

00:52:11,839 --> 00:52:15,520
at compile time checking whether it's

00:52:13,839 --> 00:52:18,720
floating point or not

00:52:15,520 --> 00:52:22,240
if so i call another equal function

00:52:18,720 --> 00:52:25,520
in my internal namespace

00:52:22,240 --> 00:52:27,599
and i'm passing tag type

00:52:25,520 --> 00:52:28,640
floating point to it you can see that

00:52:27,599 --> 00:52:32,000
i'm creating here

00:52:28,640 --> 00:52:34,400
inline an instance of floating point

00:52:32,000 --> 00:52:36,480
with the curly braces and at the very

00:52:34,400 --> 00:52:38,559
top there you can see i have these two

00:52:36,480 --> 00:52:40,800
structs not floating point and floating

00:52:38,559 --> 00:52:40,800
point

00:52:41,760 --> 00:52:44,960
and in the internal name space i also

00:52:44,160 --> 00:52:47,920
have

00:52:44,960 --> 00:52:49,520
two equal implementations one for the

00:52:47,920 --> 00:52:51,760
general case where i use the equal

00:52:49,520 --> 00:52:55,119
operator and one for the case

00:52:51,760 --> 00:52:57,599
for floating point types

00:52:55,119 --> 00:52:59,280
and the floating point type takes a

00:52:57,599 --> 00:53:01,280
third argument

00:52:59,280 --> 00:53:03,839
of type floating point the first one

00:53:01,280 --> 00:53:07,280
takes one called not floating point

00:53:03,839 --> 00:53:09,280
so by passing in in line 24 and 27

00:53:07,280 --> 00:53:10,559
or forwarding my arguments a and b and

00:53:09,280 --> 00:53:13,440
passing then either

00:53:10,559 --> 00:53:14,480
floating point or not floating point as

00:53:13,440 --> 00:53:16,480
an object

00:53:14,480 --> 00:53:18,559
the compiler can select the two

00:53:16,480 --> 00:53:22,319
templates above

00:53:18,559 --> 00:53:22,960
and the good thing is the compiler is so

00:53:22,319 --> 00:53:24,559
smart

00:53:22,960 --> 00:53:26,000
that it figures out that this is an

00:53:24,559 --> 00:53:28,480
unused parameter

00:53:26,000 --> 00:53:29,280
which doesn't do anything it's only used

00:53:28,480 --> 00:53:31,200
to select

00:53:29,280 --> 00:53:32,720
the appropriate overload and to

00:53:31,200 --> 00:53:35,119
instantiate the template

00:53:32,720 --> 00:53:36,319
so you will not even pay for it it's

00:53:35,119 --> 00:53:38,800
just

00:53:36,319 --> 00:53:39,680
like um having a switch to switch

00:53:38,800 --> 00:53:42,720
between the two

00:53:39,680 --> 00:53:43,440
functions this is a version with tech

00:53:42,720 --> 00:53:46,480
dispatch

00:53:43,440 --> 00:53:49,839
and if we recall what we seen

00:53:46,480 --> 00:53:51,920
earlier there was this build cbs line

00:53:49,839 --> 00:53:55,280
function

00:53:51,920 --> 00:53:58,240
the function template and this was

00:53:55,280 --> 00:53:58,960
good this was nice but there there's one

00:53:58,240 --> 00:54:01,839
thing to it

00:53:58,960 --> 00:54:02,559
some of you may have had an issue with

00:54:01,839 --> 00:54:05,599
so far

00:54:02,559 --> 00:54:06,400
and that's it words only was um normal

00:54:05,599 --> 00:54:10,000
strings

00:54:06,400 --> 00:54:12,319
so not with a white string or more

00:54:10,000 --> 00:54:14,960
precise and utf string things like that

00:54:12,319 --> 00:54:16,720
so let's add that functionality you

00:54:14,960 --> 00:54:18,640
where the next slide will be full of

00:54:16,720 --> 00:54:20,400
code but you're here for that right

00:54:18,640 --> 00:54:21,760
you know most of it because you've

00:54:20,400 --> 00:54:25,200
already seen it

00:54:21,760 --> 00:54:28,400
so here it is we are starting

00:54:25,200 --> 00:54:30,000
adding tech this patch to that thing so

00:54:28,400 --> 00:54:32,319
in line number one line number two i'm

00:54:30,000 --> 00:54:35,520
creating two tags local v

00:54:32,319 --> 00:54:39,119
uh locally s and little was they

00:54:35,520 --> 00:54:41,599
stand for i have either my local with a

00:54:39,119 --> 00:54:43,520
normal string or with a white string

00:54:41,599 --> 00:54:46,000
and then i have a replication of the

00:54:43,520 --> 00:54:48,720
normalized functions we've seen before

00:54:46,000 --> 00:54:49,520
they're more now because i have one for

00:54:48,720 --> 00:54:52,960
all the

00:54:49,520 --> 00:54:55,760
regular strings and one for utf 8 or

00:54:52,960 --> 00:54:57,440
white strings and they're doing their

00:54:55,760 --> 00:55:00,960
normalized thing there so

00:54:57,440 --> 00:55:03,920
returning the correct string so either

00:55:00,960 --> 00:55:06,160
stood w string or stood string we once

00:55:03,920 --> 00:55:08,160
again have all the combinations

00:55:06,160 --> 00:55:10,160
and the specialty compared to the former

00:55:08,160 --> 00:55:12,480
version is that my normalized functions

00:55:10,160 --> 00:55:13,440
now also take a second parameter and

00:55:12,480 --> 00:55:16,799
that's my local

00:55:13,440 --> 00:55:19,200
it's either local s or local ws

00:55:16,799 --> 00:55:20,400
this is s in the example with the tech

00:55:19,200 --> 00:55:23,200
dispatch before

00:55:20,400 --> 00:55:24,559
to help the old compiler to select the

00:55:23,200 --> 00:55:27,440
correct overload

00:55:24,559 --> 00:55:29,599
and then of course i have my catch all

00:55:27,440 --> 00:55:31,280
normalized

00:55:29,599 --> 00:55:33,040
function templates here in line number

00:55:31,280 --> 00:55:35,839
nine and online 16

00:55:33,040 --> 00:55:37,119
doing the appropriate things either if

00:55:35,839 --> 00:55:41,760
it's a

00:55:37,119 --> 00:55:43,920
irregular low class or if it's local ws

00:55:41,760 --> 00:55:48,640
one's calling to stood string and the

00:55:43,920 --> 00:55:51,599
other time calling two w's to string

00:55:48,640 --> 00:55:53,119
my build line cvs function as shown at d

00:55:51,599 --> 00:55:55,520
in line number 18

00:55:53,119 --> 00:55:56,960
hasn't changed that much from a user's

00:55:55,520 --> 00:55:59,280
perspective

00:55:56,960 --> 00:56:01,760
to the version i shared with you before

00:55:59,280 --> 00:56:04,559
for regular string we can just call

00:56:01,760 --> 00:56:06,319
build cvs line the signature of the

00:56:04,559 --> 00:56:07,839
template however changed a little bit

00:56:06,319 --> 00:56:10,880
because now it has the first

00:56:07,839 --> 00:56:13,920
parameter of type class lt

00:56:10,880 --> 00:56:14,559
is the name and its initialized was low

00:56:13,920 --> 00:56:17,040
class

00:56:14,559 --> 00:56:18,720
so template parameters can also have

00:56:17,040 --> 00:56:22,079
default values

00:56:18,720 --> 00:56:25,200
and if a user only calls build tvs line

00:56:22,079 --> 00:56:27,359
they invoke the functions with

00:56:25,200 --> 00:56:28,799
a regular stored string so not a wide

00:56:27,359 --> 00:56:31,440
string version

00:56:28,799 --> 00:56:32,480
internally in that function also little

00:56:31,440 --> 00:56:35,839
has changed

00:56:32,480 --> 00:56:37,839
i'm now using this lt that the type the

00:56:35,839 --> 00:56:40,079
first type that is passed into the

00:56:37,839 --> 00:56:41,839
template and pass it to the normalized

00:56:40,079 --> 00:56:44,079
functions

00:56:41,839 --> 00:56:45,599
that's all i have to do that's all that

00:56:44,079 --> 00:56:48,240
changed to the version

00:56:45,599 --> 00:56:48,799
just reading a regular string and then i

00:56:48,240 --> 00:56:52,160
have

00:56:48,799 --> 00:56:53,920
down there in f in line 31 we have a

00:56:52,160 --> 00:56:56,160
built w series line

00:56:53,920 --> 00:56:57,280
which does the same job as before for

00:56:56,160 --> 00:57:01,040
regular string

00:56:57,280 --> 00:57:02,960
was now a utf-8 string and it does so by

00:57:01,040 --> 00:57:05,200
referring to build cvs line

00:57:02,960 --> 00:57:07,119
as you can see it calls that but it

00:57:05,200 --> 00:57:11,440
passes as a first argument

00:57:07,119 --> 00:57:14,400
local ws so it provides to our template

00:57:11,440 --> 00:57:16,160
first argument and all the others are

00:57:14,400 --> 00:57:19,359
still deduced by the compiler

00:57:16,160 --> 00:57:22,799
this is how i can say please choose the

00:57:19,359 --> 00:57:26,799
local ws instead of the

00:57:22,799 --> 00:57:29,760
regular local

00:57:26,799 --> 00:57:30,480
and now someone asked and this was a

00:57:29,760 --> 00:57:33,680
question

00:57:30,480 --> 00:57:36,079
not made up before someone from your

00:57:33,680 --> 00:57:36,799
from the audience asked how does this

00:57:36,079 --> 00:57:40,160
equal

00:57:36,799 --> 00:57:42,799
thing look with concepts and this is the

00:57:40,160 --> 00:57:46,880
version in c plus plus 20 you can write

00:57:42,799 --> 00:57:50,079
so putting tech dispatching aside

00:57:46,880 --> 00:57:51,040
we can now say we have this requires

00:57:50,079 --> 00:57:53,520
clause here and

00:57:51,040 --> 00:57:55,520
line number 2 and line number 10 sorry

00:57:53,520 --> 00:57:57,359
for the formatting clang format wasn't

00:57:55,520 --> 00:58:01,359
so savvy with

00:57:57,359 --> 00:58:03,760
this concept so far that's because um

00:58:01,359 --> 00:58:04,880
although that's why it says spool equal

00:58:03,760 --> 00:58:07,119
at the end

00:58:04,880 --> 00:58:09,040
but here in line number two and line

00:58:07,119 --> 00:58:11,359
number 10 i say requires

00:58:09,040 --> 00:58:12,240
in parentheses and then i can state my

00:58:11,359 --> 00:58:14,799
requirement

00:58:12,240 --> 00:58:16,240
and this is in this case not stood as

00:58:14,799 --> 00:58:19,440
floating point we

00:58:16,240 --> 00:58:20,480
for t so the first version comparing

00:58:19,440 --> 00:58:22,640
things to equal

00:58:20,480 --> 00:58:23,680
checks where the t isn't of type

00:58:22,640 --> 00:58:25,599
floating point

00:58:23,680 --> 00:58:27,839
if so that thing passes it's like

00:58:25,599 --> 00:58:31,920
spinning but much more powerful

00:58:27,839 --> 00:58:35,119
and we are doing the comparison here

00:58:31,920 --> 00:58:36,960
and down then in line number 10 we are

00:58:35,119 --> 00:58:39,520
checking if it's a floating point

00:58:36,960 --> 00:58:40,640
this is the requirement if so then this

00:58:39,520 --> 00:58:42,880
version kicks in

00:58:40,640 --> 00:58:46,079
and we're doing the specialty for every

00:58:42,880 --> 00:58:49,280
floating point type

00:58:46,079 --> 00:58:50,960
the difference to this finial version or

00:58:49,280 --> 00:58:53,119
detect dispatch version is

00:58:50,960 --> 00:58:54,880
that with the requires clause you're

00:58:53,119 --> 00:58:58,400
telling the compiler

00:58:54,880 --> 00:59:00,079
the specific requirement and the type

00:58:58,400 --> 00:59:01,760
that has to fulfill it

00:59:00,079 --> 00:59:03,359
and if that requirement fails the

00:59:01,760 --> 00:59:06,720
compiler can give you a

00:59:03,359 --> 00:59:09,920
quite good error message at this point

00:59:06,720 --> 00:59:09,920
this is really helpful

00:59:13,520 --> 00:59:18,079
and then we have finally template

00:59:16,240 --> 00:59:21,119
template parameters

00:59:18,079 --> 00:59:24,559
and you can see them as nested templates

00:59:21,119 --> 00:59:27,760
we need them when we need to pass

00:59:24,559 --> 00:59:29,599
a template to another template and my

00:59:27,760 --> 00:59:32,640
case here is they have this function

00:59:29,599 --> 00:59:35,760
fun that should take a container

00:59:32,640 --> 00:59:37,839
it should take any container

00:59:35,760 --> 00:59:38,960
um but it should be a container so it

00:59:37,839 --> 00:59:41,200
should not be a

00:59:38,960 --> 00:59:41,200
um

00:59:41,560 --> 00:59:44,480
[Music]

00:59:42,720 --> 00:59:46,559
char array something like this it should

00:59:44,480 --> 00:59:51,280
be something like a stood vector

00:59:46,559 --> 00:59:53,040
or stood list and the syntax is

00:59:51,280 --> 00:59:55,359
the same as before i start at line

00:59:53,040 --> 00:59:56,160
number one saying template and the angle

00:59:55,359 --> 00:59:58,640
brackets

00:59:56,160 --> 01:00:00,079
and then the specialty for my template

00:59:58,640 --> 01:00:02,559
printer stops

01:00:00,079 --> 01:00:03,760
a here i have to tell the compiler that

01:00:02,559 --> 01:00:06,480
i'm not talking

01:00:03,760 --> 01:00:07,359
about the template in a template and i

01:00:06,480 --> 01:00:09,280
do that by

01:00:07,359 --> 01:00:10,880
once again repeating the keyword

01:00:09,280 --> 01:00:14,160
template in ankle brackets

01:00:10,880 --> 01:00:17,200
now i have to tell the compiler the

01:00:14,160 --> 01:00:20,640
types this template i'm like

01:00:17,200 --> 01:00:23,520
to take in this template takes so for

01:00:20,640 --> 01:00:24,079
stood container they are typically

01:00:23,520 --> 01:00:27,200
taking

01:00:24,079 --> 01:00:29,760
two types to type parameters the first

01:00:27,200 --> 01:00:31,760
one we are often specifying like in

01:00:29,760 --> 01:00:33,839
line number 18 here we say stood vector

01:00:31,760 --> 01:00:35,040
of int the second one often goes

01:00:33,839 --> 01:00:38,240
unnoticed

01:00:35,040 --> 01:00:41,119
and this is stood allocator

01:00:38,240 --> 01:00:42,720
so i don't have to name them i just have

01:00:41,119 --> 01:00:45,040
to tell the compiler

01:00:42,720 --> 01:00:46,079
the types so this is why i'm saying in

01:00:45,040 --> 01:00:48,720
line number three

01:00:46,079 --> 01:00:49,839
class comma class and then i have to

01:00:48,720 --> 01:00:51,839
give that a name

01:00:49,839 --> 01:00:53,839
in line number four i have to say class

01:00:51,839 --> 01:00:54,720
container and this is one place where

01:00:53,839 --> 01:00:58,880
you have to say

01:00:54,720 --> 01:00:58,880
class you cannot say template there

01:01:00,000 --> 01:01:04,880
and then in b i start

01:01:03,200 --> 01:01:06,480
telling the compiler that this template

01:01:04,880 --> 01:01:08,559
now takes a couple of

01:01:06,480 --> 01:01:10,720
parameters in my case a template

01:01:08,559 --> 01:01:13,280
parameter in line 6t

01:01:10,720 --> 01:01:15,040
and then in line 8 another template

01:01:13,280 --> 01:01:17,680
another type parameter

01:01:15,040 --> 01:01:18,799
allocator and this is defaulted to stood

01:01:17,680 --> 01:01:21,680
on the locator of

01:01:18,799 --> 01:01:22,880
t and now my function fun takes a

01:01:21,680 --> 01:01:25,760
container of t

01:01:22,880 --> 01:01:27,760
comma allocator by reference and i can

01:01:25,760 --> 01:01:31,040
iterate over this as shown here in

01:01:27,760 --> 01:01:32,880
the range base for loop and now i can

01:01:31,040 --> 01:01:33,680
pair the understood vector understood

01:01:32,880 --> 01:01:37,119
jar is

01:01:33,680 --> 01:01:38,799
stood list of jar and they are still

01:01:37,119 --> 01:01:41,760
their containers

01:01:38,799 --> 01:01:43,040
so this makes sure that this function

01:01:41,760 --> 01:01:45,760
takes a container

01:01:43,040 --> 01:01:48,000
it's still a template so it takes a

01:01:45,760 --> 01:01:50,960
vector of n the stood vector of double

01:01:48,000 --> 01:01:52,000
and all that stuff but it has to be of

01:01:50,960 --> 01:01:54,720
the signature of

01:01:52,000 --> 01:01:55,680
such a stood container so it has to take

01:01:54,720 --> 01:01:58,240
a type t

01:01:55,680 --> 01:01:59,039
as first argument and understood

01:01:58,240 --> 01:02:02,480
allocator

01:01:59,039 --> 01:02:02,480
as its second argument

01:02:04,240 --> 01:02:07,760
that's it so far so we have covered a

01:02:06,640 --> 01:02:10,720
lot today

01:02:07,760 --> 01:02:12,559
um ran a little over time there would be

01:02:10,720 --> 01:02:16,319
so much more to say about templates

01:02:12,559 --> 01:02:19,280
maybe you have another chance next year

01:02:16,319 --> 01:02:19,839
all that's up to me to say is i'm

01:02:19,280 --> 01:02:21,359
verdict

01:02:19,839 --> 01:02:23,359
for all of you who were in the first

01:02:21,359 --> 01:02:26,640
part they hopefully get the joke

01:02:23,359 --> 01:02:28,480
i wrote a book um tips and tricks with

01:02:26,640 --> 01:02:31,440
templates

01:02:28,480 --> 01:02:33,599
it's writing down my notes um how to

01:02:31,440 --> 01:02:35,839
handle a couple of things with templates

01:02:33,599 --> 01:02:38,160
you can get a discounted version it's on

01:02:35,839 --> 01:02:39,920
lean pop if you like and hopefully it's

01:02:38,160 --> 01:02:44,480
out there as a printed version

01:02:39,920 --> 01:02:47,039
soonish i hope you enjoyed it

01:02:44,480 --> 01:02:48,400
thanks for tuning in today see you later

01:02:47,039 --> 01:03:03,839
at remo

01:02:48,400 --> 01:03:03,839
thank you and bye bye

01:03:09,839 --> 01:03:11,920

YouTube URL: https://www.youtube.com/watch?v=0dtjDTEE0hQ


