Title: Back to Basics: Concurrency - Arthur O'Dwyer - CppCon 2020
Publication date: 2020-10-04
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_concurrency/back_to_basics_concurrency__arthur_odwyer__cppcon_2020.pdf
---
One of C++11's flagship features was the introduction of std::thread, along with a complete suite of synchronization primitives and useful patterns such as thread-safe static initialization. In this session, we'll motivate C++11's threading model and explain how to use std::thread effectively. We'll compare and contrast the C++11 synchronization primitives (mutex, condition variable, reader-writer lock, and once-flag) as well as the primitives that are new in C++20 (semaphore, latch, and barrier). In particular, we'll show how to make a mutex and a condition variable work together.
When using threads, it's important to avoid shared mutable state. We'll show how to tame that state via the "blue/green deployment" pattern, and briefly discuss how to use std::future and std::async to safely handle threads that produce answers.
Attendees will leave this session with a strong grasp on "multithreading tactics" in C++11 and beyond.

---
Arthur O'Dwyer is the author of "Mastering the C++17 STL" (Packt 2017) and of professional training courses such as "Intro to C++," "Classic STL: Algorithms, Containers, Iterators," and "The STL From Scratch." (Ask me about training your new hires!) Arthur is occasionally active on the C++ Standards Committee and has a blog mostly about C++. He is also the author of "Colossal Cave: The Board Game," an avid club juggler, and the recipient of four

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,679 --> 00:00:14,400
all right hello everyone and welcome to

00:00:12,160 --> 00:00:15,599
back to basics concurrency my name is

00:00:14,400 --> 00:00:17,520
arthur dwyer

00:00:15,599 --> 00:00:19,520
i also do c plus plus training if you

00:00:17,520 --> 00:00:22,960
have new hires who need training or

00:00:19,520 --> 00:00:23,600
want to brush up on cpl's plus 11 or 17

00:00:22,960 --> 00:00:26,560
or

00:00:23,600 --> 00:00:28,080
20 or anything like that give me a give

00:00:26,560 --> 00:00:31,119
me an email it's right there on the

00:00:28,080 --> 00:00:32,320
slide and i'm also the chair of the back

00:00:31,119 --> 00:00:35,520
to basics track

00:00:32,320 --> 00:00:36,960
at cppcon so let me know

00:00:35,520 --> 00:00:39,680
how you like the back to basics track

00:00:36,960 --> 00:00:41,920
this year um

00:00:39,680 --> 00:00:44,960
and without further ado let's get

00:00:41,920 --> 00:00:46,079
started with concurrency

00:00:44,960 --> 00:00:47,200
so here's all the stuff we're going to

00:00:46,079 --> 00:00:48,320
be talking about today we're going to

00:00:47,200 --> 00:00:50,239
talk about data races we're going to

00:00:48,320 --> 00:00:50,879
talk about mutex and uniqlo condition

00:00:50,239 --> 00:00:53,600
variable

00:00:50,879 --> 00:00:55,840
once flag new primitives that have been

00:00:53,600 --> 00:00:57,600
introduced in 17 and 20.

00:00:55,840 --> 00:00:59,680
a couple of idioms that might be useful

00:00:57,600 --> 00:01:01,680
to you in writing one-off

00:00:59,680 --> 00:01:03,440
uh concurrency code such as the blue

00:01:01,680 --> 00:01:05,199
green pattern and maybe if we have time

00:01:03,440 --> 00:01:07,760
we have some bonus slides

00:01:05,199 --> 00:01:09,200
um this presentation is geared toward

00:01:07,760 --> 00:01:10,720
people who are just getting into

00:01:09,200 --> 00:01:13,119
concurrency they're like what

00:01:10,720 --> 00:01:14,479
is it how do i like what is a mutex how

00:01:13,119 --> 00:01:17,520
do i use that

00:01:14,479 --> 00:01:19,200
uh if you are working in a domain where

00:01:17,520 --> 00:01:20,320
uh you have a lot of threads you're

00:01:19,200 --> 00:01:21,680
talking about green threads you're

00:01:20,320 --> 00:01:22,400
talking about fibers you're talking

00:01:21,680 --> 00:01:25,680
about

00:01:22,400 --> 00:01:28,799
uh you know send receive and that

00:01:25,680 --> 00:01:29,920
kind of stuff uh asio this is not the

00:01:28,799 --> 00:01:33,200
talk for you

00:01:29,920 --> 00:01:35,680
uh you're gonna need a different talk

00:01:33,200 --> 00:01:36,960
uh you're gonna need a bigger boat um

00:01:35,680 --> 00:01:40,159
but this is the little boat

00:01:36,960 --> 00:01:43,360
for the back to basics tracks so

00:01:40,159 --> 00:01:44,640
what is concurrency uh there are two

00:01:43,360 --> 00:01:45,280
words you're going to hear thrown around

00:01:44,640 --> 00:01:47,840
a lot

00:01:45,280 --> 00:01:48,799
uh in this domain concurrency and

00:01:47,840 --> 00:01:50,159
parallelism

00:01:48,799 --> 00:01:51,680
and a lot of people will use them as

00:01:50,159 --> 00:01:53,520
synonyms and then there will be people

00:01:51,680 --> 00:01:55,119
who say no no no these are not synonyms

00:01:53,520 --> 00:01:57,119
they have very distinct meanings

00:01:55,119 --> 00:01:58,640
uh and i'm kind of in the middle uh you

00:01:57,119 --> 00:02:00,799
know you can go either way

00:01:58,640 --> 00:02:02,079
but roughly i would say that to me

00:02:00,799 --> 00:02:05,200
concurrency

00:02:02,079 --> 00:02:05,680
uh is the meanings in the name from the

00:02:05,200 --> 00:02:09,039
latin

00:02:05,680 --> 00:02:10,560
con current running together um

00:02:09,039 --> 00:02:12,160
so these are things that are happening

00:02:10,560 --> 00:02:13,520
sort of at the same time

00:02:12,160 --> 00:02:15,120
but maybe you're just switching back and

00:02:13,520 --> 00:02:16,319
forth between them i might say if i'm

00:02:15,120 --> 00:02:18,640
multitasking

00:02:16,319 --> 00:02:20,239
as a person if i'm writing my slides and

00:02:18,640 --> 00:02:21,920
i write a couple slides and i go answer

00:02:20,239 --> 00:02:23,680
some email and i write some slides i

00:02:21,920 --> 00:02:25,599
answer an email

00:02:23,680 --> 00:02:27,120
that's concurrency on the other hand

00:02:25,599 --> 00:02:29,040
parallelism means

00:02:27,120 --> 00:02:30,800
literally doing two things in parallel

00:02:29,040 --> 00:02:33,040
simultaneously literally

00:02:30,800 --> 00:02:34,959
in the same instant for example i might

00:02:33,040 --> 00:02:36,080
be writing my slides and also listening

00:02:34,959 --> 00:02:37,519
to music or

00:02:36,080 --> 00:02:40,080
listening to a radio show in the

00:02:37,519 --> 00:02:40,480
background um those are two things i can

00:02:40,080 --> 00:02:43,200
do

00:02:40,480 --> 00:02:45,360
simultaneously um in extremely broad

00:02:43,200 --> 00:02:46,720
strokes i could say that parallelism is

00:02:45,360 --> 00:02:48,879
a problem for hardware

00:02:46,720 --> 00:02:51,120
if you have multiple cpus you have the

00:02:48,879 --> 00:02:53,519
capability for parallelism

00:02:51,120 --> 00:02:54,400
uh concurrency tends to be done more in

00:02:53,519 --> 00:02:56,000
software

00:02:54,400 --> 00:02:58,080
uh time sharing operating systems

00:02:56,000 --> 00:02:59,519
multi-threading um

00:02:58,080 --> 00:03:02,000
there is some overlap intel's

00:02:59,519 --> 00:03:03,599
hyper-threading is basically

00:03:02,000 --> 00:03:05,040
switching back and forth concurrently

00:03:03,599 --> 00:03:07,920
between things on uh

00:03:05,040 --> 00:03:09,040
on hardware um but fundamentally these

00:03:07,920 --> 00:03:10,400
are the kind of things you should have

00:03:09,040 --> 00:03:11,840
in your head for an intuition about

00:03:10,400 --> 00:03:13,840
these terms

00:03:11,840 --> 00:03:15,519
so why does c plus plus care at all

00:03:13,840 --> 00:03:18,879
about concurrency

00:03:15,519 --> 00:03:21,040
well back in 98 in c plus 03 uh

00:03:18,879 --> 00:03:22,400
standard c plus plus did not have any

00:03:21,040 --> 00:03:24,799
concept of

00:03:22,400 --> 00:03:27,440
concurrency or of threads or threads of

00:03:24,799 --> 00:03:27,440
execution

00:03:30,400 --> 00:03:34,560
added and you would just use a platform

00:03:31,760 --> 00:03:36,560
specific library such as p threads

00:03:34,560 --> 00:03:38,640
um like libp thread and you you add it

00:03:36,560 --> 00:03:40,879
to your link line and it provides

00:03:38,640 --> 00:03:42,480
uh some some somewhat standardized

00:03:40,879 --> 00:03:45,440
functionality that you call the

00:03:42,480 --> 00:03:46,000
to make threads on your operating system

00:03:45,440 --> 00:03:47,920
the problem

00:03:46,000 --> 00:03:50,159
with that is that then the standard

00:03:47,920 --> 00:03:52,000
language couldn't really say anything

00:03:50,159 --> 00:03:53,200
meaningful about multi-threaded programs

00:03:52,000 --> 00:03:54,959
and if everyone's going to start writing

00:03:53,200 --> 00:03:57,280
multi-threaded programs we really don't

00:03:54,959 --> 00:03:59,680
want them all to have undefined behavior

00:03:57,280 --> 00:04:00,560
right if we have two threads thread a

00:03:59,680 --> 00:04:03,120
and thread b

00:04:00,560 --> 00:04:04,560
in a p threads program and one of them

00:04:03,120 --> 00:04:05,599
writes to an end and the other one tries

00:04:04,560 --> 00:04:08,640
to read from the end

00:04:05,599 --> 00:04:09,360
will that uh second thread ever actually

00:04:08,640 --> 00:04:13,840
see

00:04:09,360 --> 00:04:14,720
that right um standard c plus plus 98

00:04:13,840 --> 00:04:16,799
and o3

00:04:14,720 --> 00:04:18,320
didn't say um because they had no

00:04:16,799 --> 00:04:20,239
concept of what it meant to have thread

00:04:18,320 --> 00:04:24,320
a and thread b in the first place

00:04:20,239 --> 00:04:27,120
um so uh cpus plus 11

00:04:24,320 --> 00:04:28,960
is going to fix that as we'll see um

00:04:27,120 --> 00:04:31,440
also this uh

00:04:28,960 --> 00:04:33,440
uh impacts what kind of optimizations

00:04:31,440 --> 00:04:35,600
the compiler is allowed to perform if

00:04:33,440 --> 00:04:37,759
my original code has an end and i

00:04:35,600 --> 00:04:40,240
originally initialize it to zero

00:04:37,759 --> 00:04:42,080
and then uh set it to one and then sleep

00:04:40,240 --> 00:04:45,120
for a while set it for two uh

00:04:42,080 --> 00:04:46,479
sleep for a while set it to three um is

00:04:45,120 --> 00:04:49,360
the compiler allowed

00:04:46,479 --> 00:04:50,960
to rewrite that to say well i see what

00:04:49,360 --> 00:04:52,400
you're doing here you're setting x to

00:04:50,960 --> 00:04:54,960
three and you're sleeping for a total of

00:04:52,400 --> 00:04:57,280
200 milliseconds can i just do that

00:04:54,960 --> 00:04:58,560
is is that an a legal optimization that

00:04:57,280 --> 00:05:00,320
will make your code

00:04:58,560 --> 00:05:01,759
smaller i mean it won't make it faster

00:05:00,320 --> 00:05:02,880
it'll still take 200 milliseconds but

00:05:01,759 --> 00:05:05,520
it'll make it smaller and

00:05:02,880 --> 00:05:07,440
and you know better in some sense but is

00:05:05,520 --> 00:05:09,759
that legal to do or do i need to have

00:05:07,440 --> 00:05:10,639
x be at 2 somehow for some sense of the

00:05:09,759 --> 00:05:12,560
word

00:05:10,639 --> 00:05:14,560
so the c plus plus 11 answer is

00:05:12,560 --> 00:05:16,000
unambiguously yes you are allowed to do

00:05:14,560 --> 00:05:19,840
this optimization

00:05:16,000 --> 00:05:22,880
um because no other thread

00:05:19,840 --> 00:05:26,400
can possibly be looking at x

00:05:22,880 --> 00:05:27,919
uh during the execution of this code

00:05:26,400 --> 00:05:29,759
as far as any other code is concerned

00:05:27,919 --> 00:05:31,280
this is a black box um

00:05:29,759 --> 00:05:33,039
no other thread is allowed to be looking

00:05:31,280 --> 00:05:34,320
at x while i'm modifying it

00:05:33,039 --> 00:05:36,320
and they don't know exactly when i'm

00:05:34,320 --> 00:05:36,560
modifying it and we're going to see how

00:05:36,320 --> 00:05:40,560
c

00:05:36,560 --> 00:05:43,919
plus plus 11 turns that idea into formal

00:05:40,560 --> 00:05:44,880
codified wording um in about one slide

00:05:43,919 --> 00:05:46,720
from now

00:05:44,880 --> 00:05:49,360
the other thing that's going on with

00:05:46,720 --> 00:05:51,440
concurrency on in computer programming

00:05:49,360 --> 00:05:52,639
is that not only is the compiler allowed

00:05:51,440 --> 00:05:56,080
to rewrite your code

00:05:52,639 --> 00:05:58,479
but the hardware itself can effectively

00:05:56,080 --> 00:06:00,800
rewrite your code and reorder accesses

00:05:58,479 --> 00:06:01,840
because of things like cache lines right

00:06:00,800 --> 00:06:05,919
your l1 cache

00:06:01,840 --> 00:06:06,560
has let's say 64 bytes in each cache

00:06:05,919 --> 00:06:09,600
line

00:06:06,560 --> 00:06:12,639
and if you write to a sub 0 and then

00:06:09,600 --> 00:06:12,960
a sub 100 and then a sub 1 the compiler

00:06:12,639 --> 00:06:14,639
or

00:06:12,960 --> 00:06:16,160
sorry the hardware is quite likely to

00:06:14,639 --> 00:06:17,120
reorder that even if the compiler

00:06:16,160 --> 00:06:18,800
doesn't

00:06:17,120 --> 00:06:20,400
and effectively what you're doing there

00:06:18,800 --> 00:06:21,680
is two writes to one cache line and one

00:06:20,400 --> 00:06:23,440
right to another cache line and those

00:06:21,680 --> 00:06:26,319
will be published to other

00:06:23,440 --> 00:06:28,639
cpus in some order that is not

00:06:26,319 --> 00:06:30,800
necessarily the order you wrote it in

00:06:28,639 --> 00:06:32,479
so when we're designing uh

00:06:30,800 --> 00:06:34,000
multi-threaded programs

00:06:32,479 --> 00:06:35,840
these are all the things that might

00:06:34,000 --> 00:06:38,000
happen under the hood

00:06:35,840 --> 00:06:39,360
and we need to use the guarantees given

00:06:38,000 --> 00:06:41,759
to us by standard c

00:06:39,360 --> 00:06:44,319
plus uh to make sure we don't have to

00:06:41,759 --> 00:06:46,400
worry about these kinds of things

00:06:44,319 --> 00:06:49,120
so in c plus plus 11 we get a memory

00:06:46,400 --> 00:06:52,240
model is what they call it

00:06:49,120 --> 00:06:55,280
it is uh a formal model

00:06:52,240 --> 00:06:57,120
of what it means to be a multi-threaded

00:06:55,280 --> 00:06:59,280
c-plus plus 11 program

00:06:57,120 --> 00:07:02,880
a c-plus pulse program consists of one

00:06:59,280 --> 00:07:04,880
or more threads of execution and

00:07:02,880 --> 00:07:06,800
each of those threads of execution

00:07:04,880 --> 00:07:07,919
executes basically independently of the

00:07:06,800 --> 00:07:10,960
others

00:07:07,919 --> 00:07:15,520
uh and they communicate via memory

00:07:10,960 --> 00:07:18,639
but every right to a memory location

00:07:15,520 --> 00:07:20,960
in memory anywhere uh must what we say

00:07:18,639 --> 00:07:22,720
synchronize with all other reads or

00:07:20,960 --> 00:07:24,800
rights of that memory location

00:07:22,720 --> 00:07:27,120
so if i'm writing to a particular

00:07:24,800 --> 00:07:28,880
variable or particular you know star p

00:07:27,120 --> 00:07:30,800
and someone else is at the same time

00:07:28,880 --> 00:07:33,120
reading or writing to that thing

00:07:30,800 --> 00:07:34,319
um then the program will have undefined

00:07:33,120 --> 00:07:36,960
behavior

00:07:34,319 --> 00:07:38,160
we can establish these synchronizes with

00:07:36,960 --> 00:07:39,599
relationships

00:07:38,160 --> 00:07:41,680
using various standard library

00:07:39,599 --> 00:07:45,919
facilities such as mutex

00:07:41,680 --> 00:07:49,440
and atomic um so how do we create

00:07:45,919 --> 00:07:51,280
a thread of execution um in pthreads

00:07:49,440 --> 00:07:53,039
you'd create a new thread by calling a

00:07:51,280 --> 00:07:56,160
third party library function

00:07:53,039 --> 00:07:58,240
uh you know out of libp thread in c plus

00:07:56,160 --> 00:07:59,840
plus 11 and later uh

00:07:58,240 --> 00:08:01,759
threads have been standardized and

00:07:59,840 --> 00:08:03,759
therefore there is a standard way to

00:08:01,759 --> 00:08:05,360
create a new thread the standard library

00:08:03,759 --> 00:08:07,440
owns this idea now

00:08:05,360 --> 00:08:09,199
that this is how you create a thread in

00:08:07,440 --> 00:08:11,599
c plus plus and the way you do it

00:08:09,199 --> 00:08:12,720
is to create a stid thread object that's

00:08:11,599 --> 00:08:15,759
a library class

00:08:12,720 --> 00:08:19,520
from the thread header

00:08:15,759 --> 00:08:22,240
the constructor argument to stid thread

00:08:19,520 --> 00:08:23,039
is a callable usually these days it'll

00:08:22,240 --> 00:08:24,879
be a lambda

00:08:23,039 --> 00:08:26,080
it could be a function but usually these

00:08:24,879 --> 00:08:27,759
days it's just a lambda

00:08:26,080 --> 00:08:29,360
that says what you want the thread to do

00:08:27,759 --> 00:08:32,080
this is your job thread

00:08:29,360 --> 00:08:32,719
your job is to execute this lambda which

00:08:32,080 --> 00:08:36,159
will

00:08:32,719 --> 00:08:36,159
print hello from thread b

00:08:36,880 --> 00:08:40,640
the new thread starts executing

00:08:38,640 --> 00:08:42,399
immediately when its job is done the

00:08:40,640 --> 00:08:44,959
threat has nothing else to do and so

00:08:42,399 --> 00:08:46,000
we say it becomes joinable this is kind

00:08:44,959 --> 00:08:49,360
of a confusing

00:08:46,000 --> 00:08:52,560
term join to mean like finish up um

00:08:49,360 --> 00:08:54,560
but think of it as a single thread of

00:08:52,560 --> 00:08:56,000
execution branches at some point and now

00:08:54,560 --> 00:08:58,160
we have two threads

00:08:56,000 --> 00:08:59,760
and then at some point their their

00:08:58,160 --> 00:09:01,279
threads sort of join back together one

00:08:59,760 --> 00:09:02,399
thread joins the other and now we have a

00:09:01,279 --> 00:09:05,440
single thread again

00:09:02,399 --> 00:09:07,600
so um before you destroy

00:09:05,440 --> 00:09:09,360
any stid thread object you must call dot

00:09:07,600 --> 00:09:12,320
join on it

00:09:09,360 --> 00:09:14,000
and this call will block if necessary

00:09:12,320 --> 00:09:16,959
until the other thread's job is finished

00:09:14,000 --> 00:09:17,839
block here is a synonym for weight so

00:09:16,959 --> 00:09:19,760
here

00:09:17,839 --> 00:09:20,880
i make a stid thread variable called

00:09:19,760 --> 00:09:24,240
thread b and i

00:09:20,880 --> 00:09:25,680
initialize it um with this lambda

00:09:24,240 --> 00:09:27,200
by the way i'm taking this lambda and

00:09:25,680 --> 00:09:28,800
saying given this lambda make me a stid

00:09:27,200 --> 00:09:30,959
thread object which i'm going to call

00:09:28,800 --> 00:09:32,480
thread b uh so it has a job and that job

00:09:30,959 --> 00:09:34,640
is to print hello from thread b

00:09:32,480 --> 00:09:37,360
this immediately starts executing there

00:09:34,640 --> 00:09:39,600
is uh there's not a way to say

00:09:37,360 --> 00:09:41,200
uh put it off until later there's no

00:09:39,600 --> 00:09:43,839
thread dot start the way there is in

00:09:41,200 --> 00:09:46,160
some languages it just starts right away

00:09:43,839 --> 00:09:47,360
um we will see soon how to deal with

00:09:46,160 --> 00:09:49,440
that um

00:09:47,360 --> 00:09:51,519
so in some order this is going to print

00:09:49,440 --> 00:09:54,959
uh hello from fred a hello from thread b

00:09:51,519 --> 00:09:58,240
or maybe the reverse um and then

00:09:54,959 --> 00:10:01,440
thread a is going to call dot join

00:09:58,240 --> 00:10:04,560
on the stood thread object thread b

00:10:01,440 --> 00:10:07,279
this says uh i thread a

00:10:04,560 --> 00:10:09,120
i'm going to block and wait here my my

00:10:07,279 --> 00:10:10,800
running is blocked now by this obstacle

00:10:09,120 --> 00:10:14,399
which is i am waiting for thread b

00:10:10,800 --> 00:10:17,440
to be done with its job and then i will

00:10:14,399 --> 00:10:20,160
clean it up i will join with it um

00:10:17,440 --> 00:10:21,920
and then at some point after that i may

00:10:20,160 --> 00:10:25,519
call the destructor of stid thread that

00:10:21,920 --> 00:10:25,519
will then at that point be safe to call

00:10:25,680 --> 00:10:28,560
we have a question is there advantage of

00:10:27,120 --> 00:10:30,079
having a lambda versus a function for

00:10:28,560 --> 00:10:33,519
thread start it depends

00:10:30,079 --> 00:10:35,440
on how much stuff you have to do

00:10:33,519 --> 00:10:36,640
there i mean if it's something like a

00:10:35,440 --> 00:10:37,440
worker thread where you have some

00:10:36,640 --> 00:10:39,519
complicated

00:10:37,440 --> 00:10:40,800
job for the worker to do yeah like a

00:10:39,519 --> 00:10:42,240
while loop and something and maybe you

00:10:40,800 --> 00:10:44,480
push that off into a function

00:10:42,240 --> 00:10:45,440
and you just say start a thread with my

00:10:44,480 --> 00:10:47,120
job

00:10:45,440 --> 00:10:48,640
cool uh if it's something simple like

00:10:47,120 --> 00:10:50,880
this you know on a slide

00:10:48,640 --> 00:10:52,320
even in real life i would totally use a

00:10:50,880 --> 00:10:53,600
lambda for this it's a one-liner

00:10:52,320 --> 00:10:56,240
why would i make a separate named

00:10:53,600 --> 00:10:59,519
function for some one-off thing

00:10:56,240 --> 00:11:01,120
so that's what i'd say

00:10:59,519 --> 00:11:02,560
so we don't so that was how we create a

00:11:01,120 --> 00:11:04,079
thread so how do we

00:11:02,560 --> 00:11:05,680
get the result of that thread that we've

00:11:04,079 --> 00:11:07,680
joined um

00:11:05,680 --> 00:11:09,120
threads don't have explicit results

00:11:07,680 --> 00:11:12,160
there's no way to ask a thread

00:11:09,120 --> 00:11:15,200
hey what was your status

00:11:12,160 --> 00:11:16,560
um because joining with the child thread

00:11:15,200 --> 00:11:19,680
is a synchronization

00:11:16,560 --> 00:11:23,040
of the uh operation so

00:11:19,680 --> 00:11:24,959
here i create thread b

00:11:23,040 --> 00:11:26,959
and its job now is to print hello from

00:11:24,959 --> 00:11:30,480
thread b and then the store 42

00:11:26,959 --> 00:11:33,360
into result then uh

00:11:30,480 --> 00:11:33,839
in thread a meanwhile and that instantly

00:11:33,360 --> 00:11:35,839
starts

00:11:33,839 --> 00:11:37,839
executing now in fred a i say hello from

00:11:35,839 --> 00:11:40,880
thread a and then i block and wait

00:11:37,839 --> 00:11:43,120
for thread b and only once thread b is

00:11:40,880 --> 00:11:45,760
done with its job and has written to

00:11:43,120 --> 00:11:47,200
42 into variable result and i have

00:11:45,760 --> 00:11:50,639
joined with fred b

00:11:47,200 --> 00:11:53,120
then i read out of result

00:11:50,639 --> 00:11:53,839
right the the right to result happens

00:11:53,120 --> 00:11:55,200
first

00:11:53,839 --> 00:11:57,839
well first the initialization of result

00:11:55,200 --> 00:12:00,880
happens and then i create this thread

00:11:57,839 --> 00:12:05,440
and then this thread writes

00:12:00,880 --> 00:12:06,959
42 to result and then this join returns

00:12:05,440 --> 00:12:08,079
right this join might start before the

00:12:06,959 --> 00:12:10,480
result happens but it's going to block

00:12:08,079 --> 00:12:13,680
until this thread is done with its job

00:12:10,480 --> 00:12:15,920
and then finally

00:12:13,680 --> 00:12:17,040
i read the result and so this is thread

00:12:15,920 --> 00:12:19,920
safe code

00:12:17,040 --> 00:12:20,880
because we do not have a data race here

00:12:19,920 --> 00:12:22,959
between

00:12:20,880 --> 00:12:24,399
the write to result and the read from

00:12:22,959 --> 00:12:26,399
result they are separated by the

00:12:24,399 --> 00:12:28,880
synchronizing optimization

00:12:26,399 --> 00:12:30,079
and we say that the um the read

00:12:28,880 --> 00:12:33,600
synchronizes with

00:12:30,079 --> 00:12:35,040
the write and vice versa

00:12:33,600 --> 00:12:36,880
but here's an example of a piece of code

00:12:35,040 --> 00:12:41,120
that does have a data race

00:12:36,880 --> 00:12:43,120
um so here this is a terrible slide code

00:12:41,120 --> 00:12:44,160
um but i'm going to create thread b and

00:12:43,120 --> 00:12:47,680
i'm going to say that your

00:12:44,160 --> 00:12:50,399
your job thread b is to run this loop

00:12:47,680 --> 00:12:52,000
that just repeatedly uh prints out and

00:12:50,399 --> 00:12:54,480
increments this counter

00:12:52,000 --> 00:12:56,320
uh until reaching some deadline in the

00:12:54,480 --> 00:12:57,600
future 10 seconds from now

00:12:56,320 --> 00:12:59,360
and meanwhile on thread a i'm going to

00:12:57,600 --> 00:13:00,800
be doing the same thing um

00:12:59,360 --> 00:13:02,720
incrementing the counter and printing it

00:13:00,800 --> 00:13:05,600
out uh this

00:13:02,720 --> 00:13:06,480
is a data race because it could happen

00:13:05,600 --> 00:13:10,000
that

00:13:06,480 --> 00:13:12,160
uh thread a and thread b simultaneously

00:13:10,000 --> 00:13:13,920
try to increment counter they both try

00:13:12,160 --> 00:13:15,279
to write to it or one tries to write

00:13:13,920 --> 00:13:17,760
while the other is reading

00:13:15,279 --> 00:13:19,200
those are both data races and a data

00:13:17,760 --> 00:13:21,839
race on a regular

00:13:19,200 --> 00:13:23,519
any kind of variable including int uh is

00:13:21,839 --> 00:13:25,360
undefined behavior

00:13:23,519 --> 00:13:26,560
right no synchronization exists between

00:13:25,360 --> 00:13:30,560
these two acts

00:13:26,560 --> 00:13:33,680
yes simultaneously

00:13:30,560 --> 00:13:36,160
and that's a that's undefined behavior

00:13:33,680 --> 00:13:37,360
we can fix this using the standard

00:13:36,160 --> 00:13:39,199
library type stid

00:13:37,360 --> 00:13:41,120
atomic which is a template it's a stead

00:13:39,199 --> 00:13:42,880
atomic of int makes me an atomic n you

00:13:41,120 --> 00:13:43,519
can make a state atomic of any trivial

00:13:42,880 --> 00:13:46,720
data type

00:13:43,519 --> 00:13:48,560
so you know ants pointers uh even floats

00:13:46,720 --> 00:13:51,839
i think you can make an atomic float

00:13:48,560 --> 00:13:53,680
um and this minor change completely

00:13:51,839 --> 00:13:54,160
fixes that physical data race that we

00:13:53,680 --> 00:13:56,880
had

00:13:54,160 --> 00:13:57,839
because by definition according to the

00:13:56,880 --> 00:14:00,639
standard

00:13:57,839 --> 00:14:02,560
every access to an atomic variable

00:14:00,639 --> 00:14:03,680
implicitly synchronizes with every other

00:14:02,560 --> 00:14:06,959
access

00:14:03,680 --> 00:14:08,160
so here i have uh thread a and thread b

00:14:06,959 --> 00:14:09,680
and they're both trying to increment

00:14:08,160 --> 00:14:13,440
counter simultaneously

00:14:09,680 --> 00:14:15,279
right at the same time um but

00:14:13,440 --> 00:14:17,040
by definition because it's of type stit

00:14:15,279 --> 00:14:18,639
atomic event

00:14:17,040 --> 00:14:20,560
each of those accesses each of those

00:14:18,639 --> 00:14:22,240
reads and writes synchronizes with

00:14:20,560 --> 00:14:22,720
everything else that's going on in the

00:14:22,240 --> 00:14:25,360
program

00:14:22,720 --> 00:14:27,279
or every every other access to that

00:14:25,360 --> 00:14:29,120
variable that's going on in the program

00:14:27,279 --> 00:14:31,199
um so there's still what we might call a

00:14:29,120 --> 00:14:32,800
logical race or a semantic data race

00:14:31,199 --> 00:14:34,880
where

00:14:32,800 --> 00:14:36,160
the behavior of this program is kind of

00:14:34,880 --> 00:14:37,920
unpredictable

00:14:36,160 --> 00:14:40,240
it depends on how the threads are

00:14:37,920 --> 00:14:41,920
scheduled what you see as output

00:14:40,240 --> 00:14:43,279
you might consider that a bug in real

00:14:41,920 --> 00:14:45,440
life but

00:14:43,279 --> 00:14:46,560
it is not undefined behavior according

00:14:45,440 --> 00:14:48,399
to the standard this has perfectly

00:14:46,560 --> 00:14:51,600
well-defined behavior

00:14:48,399 --> 00:14:51,600
it never has you be

00:14:52,240 --> 00:14:59,360
um so let's talk about

00:14:55,519 --> 00:15:02,480
the uh the way that threads start

00:14:59,360 --> 00:15:04,880
um so i said that threads

00:15:02,480 --> 00:15:05,680
always uh start up uh running

00:15:04,880 --> 00:15:07,199
immediately

00:15:05,680 --> 00:15:08,399
there's no thread.start method you just

00:15:07,199 --> 00:15:10,079
create a thread and boom you've got a

00:15:08,399 --> 00:15:12,320
second thread and it's running

00:15:10,079 --> 00:15:13,680
as far as you're concerned right it may

00:15:12,320 --> 00:15:15,279
actually be blocked somewhere in the

00:15:13,680 --> 00:15:16,560
operating system waiting for a cpu to

00:15:15,279 --> 00:15:18,000
become available waiting for some

00:15:16,560 --> 00:15:18,959
resources to become available but as far

00:15:18,000 --> 00:15:21,600
as you know

00:15:18,959 --> 00:15:23,120
it's running right away um so what if we

00:15:21,600 --> 00:15:24,240
didn't want that what if i wanted to

00:15:23,120 --> 00:15:25,920
create a thread

00:15:24,240 --> 00:15:27,839
and set it up and say this will be your

00:15:25,920 --> 00:15:29,759
job but not yet hang on i have a little

00:15:27,839 --> 00:15:31,040
more setup to do on the main thread

00:15:29,759 --> 00:15:32,880
in thread a i'm going to print hello

00:15:31,040 --> 00:15:35,120
from a and then i want to do something

00:15:32,880 --> 00:15:36,800
to unblock thread b

00:15:35,120 --> 00:15:38,480
uh and then let thread b do its thing

00:15:36,800 --> 00:15:40,000
and and then maybe i also do something

00:15:38,480 --> 00:15:44,639
in thread and then i join

00:15:40,000 --> 00:15:47,519
um so can we tell thread b to wait

00:15:44,639 --> 00:15:48,480
until thread a unblocks it uh the answer

00:15:47,519 --> 00:15:51,279
is yes

00:15:48,480 --> 00:15:52,959
naturally uh using what the standard

00:15:51,279 --> 00:15:54,240
calls synchronization primitives and

00:15:52,959 --> 00:15:55,680
we're going to look at the

00:15:54,240 --> 00:15:56,720
the rest of this talk mostly is talking

00:15:55,680 --> 00:15:57,920
about different synchronization

00:15:56,720 --> 00:16:01,040
primitives

00:15:57,920 --> 00:16:02,720
so first a non-solution um

00:16:01,040 --> 00:16:04,240
this is the busy weight solution this is

00:16:02,720 --> 00:16:05,759
what you might actually do

00:16:04,240 --> 00:16:08,000
if you hadn't attended this talk you

00:16:05,759 --> 00:16:11,519
might think here's what i'll do

00:16:08,000 --> 00:16:12,959
uh i know that i can make an atomic bool

00:16:11,519 --> 00:16:14,399
where accesses to it

00:16:12,959 --> 00:16:16,000
don't cause undefined behavior they all

00:16:14,399 --> 00:16:20,079
synchronize with each other

00:16:16,000 --> 00:16:22,480
um and then b will just wait until

00:16:20,079 --> 00:16:24,480
uh the ready flag becomes true and it'll

00:16:22,480 --> 00:16:26,000
just do a while loop it'll just

00:16:24,480 --> 00:16:27,600
zip around in the loop over and over and

00:16:26,000 --> 00:16:29,120
over and meanwhile we'll

00:16:27,600 --> 00:16:31,600
will carry on in a and eventually a will

00:16:29,120 --> 00:16:32,160
set ready to true um this is not a data

00:16:31,600 --> 00:16:34,959
race

00:16:32,160 --> 00:16:35,199
because ready as an atomic however this

00:16:34,959 --> 00:16:37,680
is

00:16:35,199 --> 00:16:38,720
also not what you want to do for several

00:16:37,680 --> 00:16:41,920
reasons

00:16:38,720 --> 00:16:43,519
um so the main thing that is wrong with

00:16:41,920 --> 00:16:45,519
this that you should see every time you

00:16:43,519 --> 00:16:49,199
you look at a piece of concurrent code

00:16:45,519 --> 00:16:50,880
look for this kind of busy weight

00:16:49,199 --> 00:16:52,720
this is all a while loop that's saying

00:16:50,880 --> 00:16:54,160
like i'm just going to keep doing

00:16:52,720 --> 00:16:56,800
something

00:16:54,160 --> 00:16:58,399
until this condition is true and my

00:16:56,800 --> 00:16:59,600
something is not helping us progress

00:16:58,399 --> 00:17:02,079
toward that condition

00:16:59,600 --> 00:17:04,160
right thread b here never stops working

00:17:02,079 --> 00:17:06,160
it it never goes to sleep it just keeps

00:17:04,160 --> 00:17:07,839
checking over and over and over

00:17:06,160 --> 00:17:09,280
um this is like someone's in the

00:17:07,839 --> 00:17:10,799
bathroom and you're standing outside

00:17:09,280 --> 00:17:14,079
rattling the door handle

00:17:10,799 --> 00:17:15,679
uh it does not help and it may even hurt

00:17:14,079 --> 00:17:17,360
right you're using resources that the

00:17:15,679 --> 00:17:18,000
other person might actually be using you

00:17:17,360 --> 00:17:20,880
know

00:17:18,000 --> 00:17:22,160
um so on a single core system this is a

00:17:20,880 --> 00:17:24,799
huge waste of time

00:17:22,160 --> 00:17:25,439
um so you really don't want to do that

00:17:24,799 --> 00:17:27,280
uh

00:17:25,439 --> 00:17:28,880
also this code has undefined behavior

00:17:27,280 --> 00:17:31,360
for other reasons which is

00:17:28,880 --> 00:17:32,000
that uh the the read and write do not

00:17:31,360 --> 00:17:35,600
cause a data

00:17:32,000 --> 00:17:38,480
race but the compiler can see that

00:17:35,600 --> 00:17:40,640
this condition cannot possibly change as

00:17:38,480 --> 00:17:42,799
a result of anything thread b is doing

00:17:40,640 --> 00:17:44,320
and it might hoist it out of the loop

00:17:42,799 --> 00:17:45,120
right just test once at the beginning of

00:17:44,320 --> 00:17:47,679
the loop

00:17:45,120 --> 00:17:48,880
store that in a register and just test

00:17:47,679 --> 00:17:50,240
that register and it turns out oh well

00:17:48,880 --> 00:17:51,440
in that case this is either

00:17:50,240 --> 00:17:52,720
either it drops through immediately or

00:17:51,440 --> 00:17:54,480
it's an infinite loop and the compiler

00:17:52,720 --> 00:17:57,760
is allowed to generate that code

00:17:54,480 --> 00:17:58,640
so again even with atomics uh you want

00:17:57,760 --> 00:18:00,640
to watch out

00:17:58,640 --> 00:18:03,120
for doing things that the compiler might

00:18:00,640 --> 00:18:04,960
optimize in ways you didn't expect

00:18:03,120 --> 00:18:06,320
so there are many reasons not to do this

00:18:04,960 --> 00:18:09,440
kind of busy weight

00:18:06,320 --> 00:18:10,960
loop what could we do instead

00:18:09,440 --> 00:18:12,640
here's one real solution this is the

00:18:10,960 --> 00:18:14,640
simplest solution not necessarily the

00:18:12,640 --> 00:18:17,280
most appropriate for production code

00:18:14,640 --> 00:18:17,919
um but i think i think it's decently

00:18:17,280 --> 00:18:20,720
appropriate

00:18:17,919 --> 00:18:21,919
um but uh i've had people tell me what

00:18:20,720 --> 00:18:23,440
this is crazy

00:18:21,919 --> 00:18:24,960
um here's how we're gonna do this with

00:18:23,440 --> 00:18:27,520
stid mutex

00:18:24,960 --> 00:18:28,400
uh what is a stid mutex it's a mutual

00:18:27,520 --> 00:18:31,679
exclusion

00:18:28,400 --> 00:18:33,200
mechanism so mutex mutual exclusion

00:18:31,679 --> 00:18:35,360
um that doesn't still doesn't really

00:18:33,200 --> 00:18:36,960
tell you what it is um but at least that

00:18:35,360 --> 00:18:40,000
tells you what it does

00:18:36,960 --> 00:18:41,520
kind of i compare this to the uh the key

00:18:40,000 --> 00:18:43,280
to the bathroom in the coffee shop

00:18:41,520 --> 00:18:44,799
um you know you go to coffee shop

00:18:43,280 --> 00:18:46,000
remember coffee shops we used to go

00:18:44,799 --> 00:18:46,480
there and there would be other people

00:18:46,000 --> 00:18:48,880
there

00:18:46,480 --> 00:18:49,600
and you know it was it was very good

00:18:48,880 --> 00:18:52,640
times

00:18:49,600 --> 00:18:53,840
um so you would go and then eventually

00:18:52,640 --> 00:18:55,760
you'd be like well i need to use the

00:18:53,840 --> 00:18:57,919
restroom and you would uh go up the

00:18:55,760 --> 00:18:59,679
counter and you'd ask for the key

00:18:57,919 --> 00:19:01,120
and you'd get the key and you'd take it

00:18:59,679 --> 00:19:03,120
in it'd be on some sort of spoon or

00:19:01,120 --> 00:19:06,080
something you know and then you'd go in

00:19:03,120 --> 00:19:06,960
um and as long as alice is holding that

00:19:06,080 --> 00:19:08,960
key

00:19:06,960 --> 00:19:10,559
bob can't enter the restroom and vice

00:19:08,960 --> 00:19:12,559
versa right

00:19:10,559 --> 00:19:14,240
and then when you're done you you return

00:19:12,559 --> 00:19:16,000
the kit you you release it

00:19:14,240 --> 00:19:18,080
and then someone else can acquire it

00:19:16,000 --> 00:19:19,919
that's what a mutex is

00:19:18,080 --> 00:19:21,919
all right it has two methods called lock

00:19:19,919 --> 00:19:25,919
and unlock the lock method

00:19:21,919 --> 00:19:27,280
acquires this unique resource whatever

00:19:25,919 --> 00:19:28,080
it is that the key attached to the big

00:19:27,280 --> 00:19:31,120
wooden spoon

00:19:28,080 --> 00:19:33,120
the unlock method releases and returns

00:19:31,120 --> 00:19:35,600
that key so that someone else can use it

00:19:33,120 --> 00:19:40,480
so here's what we do we make one key

00:19:35,600 --> 00:19:43,360
mutex mtx and uh thread a locks it

00:19:40,480 --> 00:19:44,160
now thread a holds the mutex thread b

00:19:43,360 --> 00:19:46,160
then

00:19:44,160 --> 00:19:47,360
we start it running but the very first

00:19:46,160 --> 00:19:50,160
thing it wants to do

00:19:47,360 --> 00:19:50,799
is lock that mutex so it will now have

00:19:50,160 --> 00:19:52,400
to wait

00:19:50,799 --> 00:19:54,559
it's now in line outside the bathroom

00:19:52,400 --> 00:19:57,520
and it is waiting uh to

00:19:54,559 --> 00:19:58,320
get that key uh so it's blocked there

00:19:57,520 --> 00:19:59,520
meanwhile

00:19:58,320 --> 00:20:01,600
meanwhile so that's what that other

00:19:59,520 --> 00:20:03,840
thread b is doing meanwhile in thread a

00:20:01,600 --> 00:20:06,320
we go on we print our hello from a and

00:20:03,840 --> 00:20:08,400
then we release the k we unlock the

00:20:06,320 --> 00:20:11,679
mutex

00:20:08,400 --> 00:20:12,880
that allows thread b to wake up at some

00:20:11,679 --> 00:20:14,400
point it will say

00:20:12,880 --> 00:20:16,480
oh yes the key is available i will now

00:20:14,400 --> 00:20:19,600
get that i will immediately give it back

00:20:16,480 --> 00:20:21,200
but now i can go on and do my thing

00:20:19,600 --> 00:20:23,120
so then uh we do some other stuff and

00:20:21,200 --> 00:20:25,440
eventually we join thread b

00:20:23,120 --> 00:20:27,039
i'm sorry this little uh black bar keeps

00:20:25,440 --> 00:20:30,159
popping up at the bottom here

00:20:27,039 --> 00:20:33,440
um and then we say hello again from a

00:20:30,159 --> 00:20:35,200
um we have a couple questions about the

00:20:33,440 --> 00:20:37,120
busy weight uh whether you should put a

00:20:35,200 --> 00:20:40,320
yield or a pause inside the loop

00:20:37,120 --> 00:20:42,400
um whether or maybe if you're on a

00:20:40,320 --> 00:20:43,520
multi-core system uh that could help

00:20:42,400 --> 00:20:45,840
with latency

00:20:43,520 --> 00:20:46,640
um those questions are out of scope for

00:20:45,840 --> 00:20:49,919
this talk

00:20:46,640 --> 00:20:51,760
um but i think the short answer is yes

00:20:49,919 --> 00:20:52,880
maybe but if you're asking the question

00:20:51,760 --> 00:20:56,400
you probably shouldn't be doing it

00:20:52,880 --> 00:20:56,400
yourself um

00:20:58,480 --> 00:21:02,000
so uh let's talk some more about stid

00:21:00,320 --> 00:21:03,760
mutex so that was an atypical

00:21:02,000 --> 00:21:06,000
use of stid mutex where we were using it

00:21:03,760 --> 00:21:08,400
just as a gating mechanism on thread b

00:21:06,000 --> 00:21:09,440
a more typical use for a mutex would be

00:21:08,400 --> 00:21:11,440
to protect

00:21:09,440 --> 00:21:13,039
some data just again like in the coffee

00:21:11,440 --> 00:21:14,880
shop analogy the coffee shop bathroom

00:21:13,039 --> 00:21:18,480
key protects the facilities of

00:21:14,880 --> 00:21:19,520
the physical bathroom um here i have a

00:21:18,480 --> 00:21:22,640
tokenpool

00:21:19,520 --> 00:21:24,640
class and it has two members

00:21:22,640 --> 00:21:26,320
one of which is a mutex the other of

00:21:24,640 --> 00:21:29,600
which is a

00:21:26,320 --> 00:21:30,559
vector and the mutex protects the vector

00:21:29,600 --> 00:21:32,960
of tokens

00:21:30,559 --> 00:21:34,480
every access every read every write that

00:21:32,960 --> 00:21:36,880
we do to that vector

00:21:34,480 --> 00:21:38,480
must be done according to my class and

00:21:36,880 --> 00:21:40,240
variant that i answer programmer design

00:21:38,480 --> 00:21:41,039
i've decided that every access will be

00:21:40,240 --> 00:21:43,679
done

00:21:41,039 --> 00:21:45,280
under a lock on the mutex this is an

00:21:43,679 --> 00:21:47,280
invariant that will be preserved

00:21:45,280 --> 00:21:48,640
and this makes my class token pool

00:21:47,280 --> 00:21:50,960
thread safe

00:21:48,640 --> 00:21:53,120
two different threads can now call get

00:21:50,960 --> 00:21:57,520
token at the same time

00:21:53,120 --> 00:21:59,120
they will both attempt to lock the mutex

00:21:57,520 --> 00:22:00,799
one of them will succeed and then

00:21:59,120 --> 00:22:02,880
proceed and the other one will fail

00:22:00,799 --> 00:22:04,960
and and have to wait until the other one

00:22:02,880 --> 00:22:05,840
releases it unlocks it at the end of the

00:22:04,960 --> 00:22:08,320
code

00:22:05,840 --> 00:22:09,600
uh and then while we have the mutex we

00:22:08,320 --> 00:22:11,039
are allowed to do whatever we want with

00:22:09,600 --> 00:22:11,679
tokens as long as we get it back into

00:22:11,039 --> 00:22:13,520
some

00:22:11,679 --> 00:22:16,000
stable state you know at the end and

00:22:13,520 --> 00:22:19,120
then we unlock

00:22:16,000 --> 00:22:21,039
um protection must be complete if you

00:22:19,120 --> 00:22:22,799
are using a mutex to protect some

00:22:21,039 --> 00:22:24,880
resource some resource

00:22:22,799 --> 00:22:26,559
you must use it consistently this is

00:22:24,880 --> 00:22:28,400
necessary for correctness

00:22:26,559 --> 00:22:29,840
here i have two functions get token and

00:22:28,400 --> 00:22:32,480
num tokens available

00:22:29,840 --> 00:22:34,240
and i say inside get token if you're

00:22:32,480 --> 00:22:36,960
modifying the tokens array

00:22:34,240 --> 00:22:38,400
you need to lock the mutex first um by

00:22:36,960 --> 00:22:39,840
the way if you're wondering is this bad

00:22:38,400 --> 00:22:40,799
code because it's not using unique lock

00:22:39,840 --> 00:22:44,640
yes

00:22:40,799 --> 00:22:48,080
wait a slide um so

00:22:44,640 --> 00:22:51,360
uh in this function

00:22:48,080 --> 00:22:54,080
we are modifying the tokens vector

00:22:51,360 --> 00:22:55,280
um and so we lock the mutex in num

00:22:54,080 --> 00:22:58,240
tokens available

00:22:55,280 --> 00:23:00,000
that is a simple access or simple getter

00:22:58,240 --> 00:23:01,679
just give me the size of the vector

00:23:00,000 --> 00:23:04,000
and so the programmer thinks you know

00:23:01,679 --> 00:23:06,000
what that's just like just read the

00:23:04,000 --> 00:23:07,840
the size i don't actually need to lock

00:23:06,000 --> 00:23:08,720
the uh the mutex for that right it's a

00:23:07,840 --> 00:23:11,440
read

00:23:08,720 --> 00:23:13,039
but no that is not correct thinking

00:23:11,440 --> 00:23:15,120
right um

00:23:13,039 --> 00:23:16,640
if someone is calling get token at the

00:23:15,120 --> 00:23:18,320
same time that someone else is calling

00:23:16,640 --> 00:23:20,400
num tokens available

00:23:18,320 --> 00:23:22,559
the one calling get token will hold the

00:23:20,400 --> 00:23:25,440
mutex and they will be doing rights

00:23:22,559 --> 00:23:26,000
to the vector and if the other thread

00:23:25,440 --> 00:23:29,039
thread b

00:23:26,000 --> 00:23:31,840
is reading from

00:23:29,039 --> 00:23:32,720
tokens same time just read the size that

00:23:31,840 --> 00:23:34,480
is a data race

00:23:32,720 --> 00:23:36,720
a write plus a read gives you a data

00:23:34,480 --> 00:23:37,360
race two reads don't but a read and a

00:23:36,720 --> 00:23:38,799
write

00:23:37,360 --> 00:23:40,559
those are bad so if you protect only

00:23:38,799 --> 00:23:42,400
your rights and then someone else is

00:23:40,559 --> 00:23:44,400
doing unprotected reads

00:23:42,400 --> 00:23:46,400
you have a data race so protecting a

00:23:44,400 --> 00:23:48,559
variable with a mutex must be 100

00:23:46,400 --> 00:23:50,000
protect every excess or else it's no

00:23:48,559 --> 00:23:51,919
good the only exception

00:23:50,000 --> 00:23:53,760
for that is in uh things like the

00:23:51,919 --> 00:23:56,000
constructor and the destructor

00:23:53,760 --> 00:23:57,520
um because if you're destroying the

00:23:56,000 --> 00:23:59,200
object obviously

00:23:57,520 --> 00:24:00,960
nobody else has a handle to the object

00:23:59,200 --> 00:24:02,240
anymore because you're now destroying it

00:24:00,960 --> 00:24:05,120
right that would be

00:24:02,240 --> 00:24:06,159
a bug of a different class if they uh

00:24:05,120 --> 00:24:07,600
tried to use it while you were

00:24:06,159 --> 00:24:08,960
destroying it so there you wouldn't need

00:24:07,600 --> 00:24:11,440
to take the mutex

00:24:08,960 --> 00:24:12,960
but this code would be bad so let's see

00:24:11,440 --> 00:24:14,640
how to fix this code

00:24:12,960 --> 00:24:16,880
we also have a problem here with

00:24:14,640 --> 00:24:19,840
exception safety right because

00:24:16,880 --> 00:24:22,240
uh there is a potential bug here if uh

00:24:19,840 --> 00:24:25,520
tokencreate or pushback

00:24:22,240 --> 00:24:26,960
throws an exception we have a bug

00:24:25,520 --> 00:24:29,440
they throw in the exception we have

00:24:26,960 --> 00:24:32,240
locked the mutex but

00:24:29,440 --> 00:24:33,120
we never call unlock because exceptions

00:24:32,240 --> 00:24:36,159
when they're thrown

00:24:33,120 --> 00:24:37,520
abort the execution of the function we

00:24:36,159 --> 00:24:39,120
never call unlock

00:24:37,520 --> 00:24:40,880
um so we should look for a way here

00:24:39,120 --> 00:24:43,039
anytime we have a resource

00:24:40,880 --> 00:24:44,720
we should look for a way to follow uh

00:24:43,039 --> 00:24:47,679
rai principles

00:24:44,720 --> 00:24:48,880
every cleanup action uh freeing uh

00:24:47,679 --> 00:24:50,720
resources freeing

00:24:48,880 --> 00:24:52,559
heap allocated pointers or unlocking

00:24:50,720 --> 00:24:55,919
mutexes should always be done

00:24:52,559 --> 00:24:55,919
inside a destructor

00:24:56,799 --> 00:24:59,840
so here's how we're gonna fix that we're

00:24:59,120 --> 00:25:02,799
going to make an

00:24:59,840 --> 00:25:04,240
rai class in fact we're going to use one

00:25:02,799 --> 00:25:05,919
out of the standard library in the

00:25:04,240 --> 00:25:07,559
standard library in the mutex header

00:25:05,919 --> 00:25:09,120
right next to sid mutex you will find

00:25:07,559 --> 00:25:12,400
stidlockguard

00:25:09,120 --> 00:25:14,080
that is a class template

00:25:12,400 --> 00:25:15,279
it takes as its parameter the type of

00:25:14,080 --> 00:25:16,960
the thing you're locking which in this

00:25:15,279 --> 00:25:19,919
case is stid mutex

00:25:16,960 --> 00:25:20,880
and in its constructor when i construct

00:25:19,919 --> 00:25:23,840
this variable

00:25:20,880 --> 00:25:26,159
lk of type lockguard of mutex uh i give

00:25:23,840 --> 00:25:28,400
it a mutex a reference to a mutex

00:25:26,159 --> 00:25:29,200
and it locks that mutex in its

00:25:28,400 --> 00:25:31,600
destructor

00:25:29,200 --> 00:25:32,400
it will unlock it automatically now if

00:25:31,600 --> 00:25:35,200
pushback

00:25:32,400 --> 00:25:36,880
throws uh the destructor for lock guard

00:25:35,200 --> 00:25:38,799
will run and it will unlock the mutex

00:25:36,880 --> 00:25:40,400
and i no longer have that exception

00:25:38,799 --> 00:25:43,279
safety bug

00:25:40,400 --> 00:25:44,400
uh also that's a one-line fix for num

00:25:43,279 --> 00:25:46,559
tokens available

00:25:44,400 --> 00:25:48,320
i don't have to worry about where do i

00:25:46,559 --> 00:25:50,799
put the lock and the unlock i just

00:25:48,320 --> 00:25:52,400
define at the top of my function uh i

00:25:50,799 --> 00:25:53,760
have a local variable named lk i've

00:25:52,400 --> 00:25:56,240
typed lock guard here i'm using the

00:25:53,760 --> 00:25:57,840
sequels plus 17

00:25:56,240 --> 00:25:59,200
class template argument deduction so i

00:25:57,840 --> 00:26:00,159
don't have to write mutex if i don't

00:25:59,200 --> 00:26:02,880
want to

00:26:00,159 --> 00:26:04,720
um this is one place where even though i

00:26:02,880 --> 00:26:08,080
normally hate ctad i might say

00:26:04,720 --> 00:26:11,200
maybe it's okay here um and

00:26:08,080 --> 00:26:12,640
uh right so we lock the mutex we return

00:26:11,200 --> 00:26:14,080
token size and at the end of this

00:26:12,640 --> 00:26:15,520
function at that closing curly brace

00:26:14,080 --> 00:26:18,880
we destroy the lock guard and that

00:26:15,520 --> 00:26:18,880
unlocks our mutex

00:26:19,760 --> 00:26:23,600
so a mutex locks is a resource just like

00:26:22,000 --> 00:26:25,840
a heap allocated uh t

00:26:23,600 --> 00:26:26,640
star uh where when you're done with that

00:26:25,840 --> 00:26:28,159
you call delete

00:26:26,640 --> 00:26:30,240
locks did mutex when you're done with it

00:26:28,159 --> 00:26:32,240
you call dot unlock we have

00:26:30,240 --> 00:26:33,919
a unique putter to help us manage unique

00:26:32,240 --> 00:26:36,159
ownership of heap allocations

00:26:33,919 --> 00:26:38,240
and likewise we just saw a lock guard

00:26:36,159 --> 00:26:39,279
but just like unique putter we have

00:26:38,240 --> 00:26:41,279
unique lock

00:26:39,279 --> 00:26:42,960
also to help us manage unique ownership

00:26:41,279 --> 00:26:45,440
of mutex locks

00:26:42,960 --> 00:26:46,960
and just as functions can pass or return

00:26:45,440 --> 00:26:48,640
ownership of a pointer

00:26:46,960 --> 00:26:50,000
functions can also pass a return

00:26:48,640 --> 00:26:53,039
ownership of a mutex

00:26:50,000 --> 00:26:55,279
lock i can write a function here uh here

00:26:53,039 --> 00:26:57,120
i've got two functions named foo

00:26:55,279 --> 00:26:58,880
one of them takes in a unique putter

00:26:57,120 --> 00:27:02,080
that is a heap allocated

00:26:58,880 --> 00:27:04,400
int um a handle to a heap allocated int

00:27:02,080 --> 00:27:05,520
and uh you know if some random number

00:27:04,400 --> 00:27:08,880
some random condition

00:27:05,520 --> 00:27:12,000
uh clean it up uh and then return

00:27:08,880 --> 00:27:12,559
either null or uh the pointer that we

00:27:12,000 --> 00:27:15,120
got in

00:27:12,559 --> 00:27:17,039
that all works fine right since uh c

00:27:15,120 --> 00:27:18,840
plus plus well people plus 14 because

00:27:17,039 --> 00:27:22,080
we're using implicit move here

00:27:18,840 --> 00:27:24,960
um but uh right that

00:27:22,080 --> 00:27:26,960
this is a keep allocated resource that i

00:27:24,960 --> 00:27:28,799
can prematurely clean up if i want i can

00:27:26,960 --> 00:27:29,520
pass it around to a function from a

00:27:28,799 --> 00:27:32,240
function

00:27:29,520 --> 00:27:33,120
whatever i want similarly with unique

00:27:32,240 --> 00:27:37,279
lock

00:27:33,120 --> 00:27:39,919
this is lk here is a unique lock

00:27:37,279 --> 00:27:40,480
uh on some mutex and it knows what mutex

00:27:39,919 --> 00:27:41,679
that is

00:27:40,480 --> 00:27:45,279
it has captured a reference to that

00:27:41,679 --> 00:27:46,320
mutex and uh i can prematurely clean it

00:27:45,279 --> 00:27:48,240
up if i want

00:27:46,320 --> 00:27:49,440
or i can just pass it back to my caller

00:27:48,240 --> 00:27:50,240
i can pass it around from function to

00:27:49,440 --> 00:27:53,039
function

00:27:50,240 --> 00:27:54,640
this all works fine stid lock guard is a

00:27:53,039 --> 00:27:57,039
special case the lock guard

00:27:54,640 --> 00:27:58,559
is not movable at all um it can be a

00:27:57,039 --> 00:28:00,000
little bit more efficient that way it

00:27:58,559 --> 00:28:01,360
doesn't have an empty state it's just

00:28:00,000 --> 00:28:02,880
either you construct it you destroy it

00:28:01,360 --> 00:28:05,840
that's it that's all it is

00:28:02,880 --> 00:28:07,919
so it's a little bit more efficient um

00:28:05,840 --> 00:28:09,279
if you're compiling with optimizations

00:28:07,919 --> 00:28:11,279
it doesn't really matter i don't think

00:28:09,279 --> 00:28:12,320
whether you use unique lock or lock

00:28:11,279 --> 00:28:14,000
guard

00:28:12,320 --> 00:28:17,520
but i would tend to say if you're not

00:28:14,000 --> 00:28:19,520
going to pass it around use lock guard

00:28:17,520 --> 00:28:21,039
if you are going to pass it around you

00:28:19,520 --> 00:28:23,120
have to use unique lock in order to make

00:28:21,039 --> 00:28:24,720
it movable like unique putter

00:28:23,120 --> 00:28:26,159
and unique lock just like unique putter

00:28:24,720 --> 00:28:29,039
is of course movable

00:28:26,159 --> 00:28:29,039
not copyable

00:28:29,600 --> 00:28:32,799
by the way there is also a stid scoped

00:28:32,320 --> 00:28:36,080
lock

00:28:32,799 --> 00:28:37,200
in cpus plus 17 it is a new and improved

00:28:36,080 --> 00:28:40,000
lock guard

00:28:37,200 --> 00:28:40,480
um it can take multiple mutexes at once

00:28:40,000 --> 00:28:43,039
and

00:28:40,480 --> 00:28:44,000
it internally has an algorithm usually

00:28:43,039 --> 00:28:45,760
based on sorting their

00:28:44,000 --> 00:28:47,440
addresses to figure out what order it

00:28:45,760 --> 00:28:48,880
should lock them in uh

00:28:47,440 --> 00:28:51,200
so that if you do have something like

00:28:48,880 --> 00:28:54,960
you arrive a merge tokens from

00:28:51,200 --> 00:28:57,760
a function that takes this

00:28:54,960 --> 00:29:00,720
pointer and another token pool and wants

00:28:57,760 --> 00:29:03,360
to lock both of their mutexes

00:29:00,720 --> 00:29:03,840
so here i use a scoped lock and i pass

00:29:03,360 --> 00:29:06,559
it

00:29:03,840 --> 00:29:08,720
both mutexes and even if i'm merging

00:29:06,559 --> 00:29:11,039
tokens from a into b and from b

00:29:08,720 --> 00:29:12,320
into a simultaneously this will not

00:29:11,039 --> 00:29:14,880
cause a deadlock

00:29:12,320 --> 00:29:16,559
um because it will internally lock the

00:29:14,880 --> 00:29:20,240
locks in the correct order

00:29:16,559 --> 00:29:22,320
um so this is a very rare

00:29:20,240 --> 00:29:25,279
thing that that you would have to use a

00:29:22,320 --> 00:29:26,399
scope lock to lock multiple locks but

00:29:25,279 --> 00:29:29,840
i was kind of pleased to come up with

00:29:26,399 --> 00:29:29,840
this motivating example for it

00:29:30,880 --> 00:29:34,080
at this point we have a question break

00:29:32,720 --> 00:29:36,320
um i'm looking at the

00:29:34,080 --> 00:29:37,919
questions that the volunteers pasted to

00:29:36,320 --> 00:29:39,919
me here i think we've actually done

00:29:37,919 --> 00:29:41,679
most of them there was a question about

00:29:39,919 --> 00:29:45,039
how is did thread implemented

00:29:41,679 --> 00:29:47,440
uh does it have uh are there primitives

00:29:45,039 --> 00:29:49,919
backing it up that are

00:29:47,440 --> 00:29:51,600
talk aboutable and i think the answer is

00:29:49,919 --> 00:29:53,279
stid thread does tend to be fairly

00:29:51,600 --> 00:29:55,760
complicated and does tend to end up

00:29:53,279 --> 00:29:58,559
being based essentially on pthreads

00:29:55,760 --> 00:30:00,399
uh at least on posix systems on windows

00:29:58,559 --> 00:30:03,840
of course it's based on windows stuff

00:30:00,399 --> 00:30:05,520
um so uh using stid thread instead of

00:30:03,840 --> 00:30:08,000
one of these third-party libraries

00:30:05,520 --> 00:30:08,799
not only makes your code correct c 11

00:30:08,000 --> 00:30:11,760
and later

00:30:08,799 --> 00:30:12,960
uh it also helps with portability um is

00:30:11,760 --> 00:30:15,360
it safe to mix

00:30:12,960 --> 00:30:17,520
standard library threading with the

00:30:15,360 --> 00:30:20,559
underlying p threads or windows threads

00:30:17,520 --> 00:30:22,159
um in general i think the answer in

00:30:20,559 --> 00:30:23,760
practice is yes

00:30:22,159 --> 00:30:26,080
as far as the standard is concerned the

00:30:23,760 --> 00:30:27,200
answer is no uh that's the sort of thing

00:30:26,080 --> 00:30:28,480
where if it breaks

00:30:27,200 --> 00:30:29,919
you don't come to the standards

00:30:28,480 --> 00:30:31,760
committee and complain you have to go to

00:30:29,919 --> 00:30:35,279
stack overflow and they will tell you

00:30:31,760 --> 00:30:37,120
it doesn't work workarounds and so on

00:30:35,279 --> 00:30:38,399
uh what would i prefer between unique

00:30:37,120 --> 00:30:41,919
lock and lock guard and

00:30:38,399 --> 00:30:44,000
why um i would prefer lock guard

00:30:41,919 --> 00:30:46,080
in the case that it is just limited to a

00:30:44,000 --> 00:30:47,120
single scope if i needed to pass it to

00:30:46,080 --> 00:30:49,760
another function

00:30:47,120 --> 00:30:51,360
i would have to use unique lock because

00:30:49,760 --> 00:30:55,679
that is the only one that is movable

00:30:51,360 --> 00:30:57,200
lock guard is immobile um

00:30:55,679 --> 00:30:59,200
if a resource is going to be written by

00:30:57,200 --> 00:31:00,720
one thread and read by another thread

00:30:59,200 --> 00:31:02,000
are there read write locks yes and we

00:31:00,720 --> 00:31:03,279
will see them see if those plus calls

00:31:02,000 --> 00:31:05,440
them shared mutexes

00:31:03,279 --> 00:31:07,360
uh we will see those in a couple slides

00:31:05,440 --> 00:31:09,919
um i think that is

00:31:07,360 --> 00:31:11,440
it for now uh oh uh one more was scope

00:31:09,919 --> 00:31:12,880
block introduced to solve the deadlock

00:31:11,440 --> 00:31:15,919
issue um

00:31:12,880 --> 00:31:18,159
that is uh one of its purposes

00:31:15,919 --> 00:31:19,279
um another one was just that locked the

00:31:18,159 --> 00:31:21,519
existing

00:31:19,279 --> 00:31:22,720
lock guard i don't think played well

00:31:21,519 --> 00:31:24,559
with uh

00:31:22,720 --> 00:31:26,240
ctad or something like that there was

00:31:24,559 --> 00:31:29,679
some reason they needed a whole new

00:31:26,240 --> 00:31:33,039
um uh class for for this instead of just

00:31:29,679 --> 00:31:34,240
uh expanding lock guard um but even in

00:31:33,039 --> 00:31:37,679
sequels plus 11

00:31:34,240 --> 00:31:41,039
there is a library function stidlock

00:31:37,679 --> 00:31:42,559
that handles the deadlock for you

00:31:41,039 --> 00:31:44,399
all right what do i dislike about cpad

00:31:42,559 --> 00:31:45,519
we'll save that for the hallway track

00:31:44,399 --> 00:31:48,480
all right

00:31:45,519 --> 00:31:49,600
metaphor time all right let's move on to

00:31:48,480 --> 00:31:51,440
more complicated

00:31:49,600 --> 00:31:52,880
uh synchronization primitives and see

00:31:51,440 --> 00:31:54,159
our second one so

00:31:52,880 --> 00:31:56,320
i'm going to use this metaphor a lot i

00:31:54,159 --> 00:31:58,640
like this um we have two

00:31:56,320 --> 00:32:00,480
people in this metaphor we have pat pat

00:31:58,640 --> 00:32:01,120
the postman pat is going to deliver a

00:32:00,480 --> 00:32:03,360
letter

00:32:01,120 --> 00:32:04,720
and we have frosty the snowman i don't

00:32:03,360 --> 00:32:08,080
know i found this clip art

00:32:04,720 --> 00:32:09,679
and frosty is waiting for to receive

00:32:08,080 --> 00:32:10,960
that letter right pat delivering the

00:32:09,679 --> 00:32:13,600
letter to frosty

00:32:10,960 --> 00:32:15,279
think about what those those two

00:32:13,600 --> 00:32:17,600
initials could stand for

00:32:15,279 --> 00:32:18,559
um here's our algorithm our procedure

00:32:17,600 --> 00:32:21,600
for

00:32:18,559 --> 00:32:24,399
pat delivering a message to frosty um

00:32:21,600 --> 00:32:26,159
mailboxes flags and symbols frosty goes

00:32:24,399 --> 00:32:28,480
to sleep next to the mailbox

00:32:26,159 --> 00:32:29,519
pat puts a letter into the mailbox

00:32:28,480 --> 00:32:32,240
raises the flag

00:32:29,519 --> 00:32:33,919
clashes her symbols her symbols wake up

00:32:32,240 --> 00:32:34,559
frosty frosty is asleep next to the

00:32:33,919 --> 00:32:36,559
mailbox

00:32:34,559 --> 00:32:38,320
he's been asleep this whole time but

00:32:36,559 --> 00:32:39,519
when he wakes up he heard a loud noise

00:32:38,320 --> 00:32:41,120
he wakes up

00:32:39,519 --> 00:32:42,559
pat is nowhere to be found they don't

00:32:41,120 --> 00:32:44,399
communicate directly

00:32:42,559 --> 00:32:45,840
but he sees that someone has raised the

00:32:44,399 --> 00:32:48,000
flag on the mailbox

00:32:45,840 --> 00:32:49,760
so now he can look in the mailbox and in

00:32:48,000 --> 00:32:51,919
fact sees the letter

00:32:49,760 --> 00:32:53,200
um there are some subtleties here by the

00:32:51,919 --> 00:32:55,600
way um

00:32:53,200 --> 00:32:57,519
frosty is a light sleeper a truck goes

00:32:55,600 --> 00:32:59,679
by and backfires he might wake up

00:32:57,519 --> 00:33:01,039
he might look but the flag is still down

00:32:59,679 --> 00:33:02,080
on the mailbox so he knows he can just

00:33:01,039 --> 00:33:03,919
go back to sleep

00:33:02,080 --> 00:33:07,919
right there are some things like that

00:33:03,919 --> 00:33:07,919
but this is our fundamental metaphor

00:33:08,840 --> 00:33:12,799
um and this brings us to our next

00:33:11,279 --> 00:33:14,720
synchronization primitive which is

00:33:12,799 --> 00:33:15,679
called another another name that doesn't

00:33:14,720 --> 00:33:18,960
really mean anything

00:33:15,679 --> 00:33:20,480
condition variable so let's say that in

00:33:18,960 --> 00:33:21,760
our token pool class that we're building

00:33:20,480 --> 00:33:24,960
if we have

00:33:21,760 --> 00:33:25,760
uh no uh token create we we just

00:33:24,960 --> 00:33:29,679
populate

00:33:25,760 --> 00:33:31,760
our uh vector of tokens

00:33:29,679 --> 00:33:33,760
again a certain number of tokens and we

00:33:31,760 --> 00:33:35,120
hand them out and if someone asks us for

00:33:33,760 --> 00:33:37,039
a token and we have none

00:33:35,120 --> 00:33:39,519
then we're going to have to block and

00:33:37,039 --> 00:33:41,440
wait until someone else returns a token

00:33:39,519 --> 00:33:44,559
and then we can hand that one out

00:33:41,440 --> 00:33:46,320
so here's my new token pool i have a

00:33:44,559 --> 00:33:48,960
vector of tokens i have a mutex

00:33:46,320 --> 00:33:50,240
still protecting tokens and i have a

00:33:48,960 --> 00:33:51,600
condition variable

00:33:50,240 --> 00:33:53,679
and we're going to add one new member

00:33:51,600 --> 00:33:54,559
function here return token and what it's

00:33:53,679 --> 00:33:56,960
going to do

00:33:54,559 --> 00:33:58,559
is someone gives us a token and i'm

00:33:56,960 --> 00:33:59,440
going to put that token back into the

00:33:58,559 --> 00:34:02,880
token vector

00:33:59,440 --> 00:34:05,120
so step one i take the lock because

00:34:02,880 --> 00:34:06,399
every access to tokens must be protected

00:34:05,120 --> 00:34:09,200
by the mutex

00:34:06,399 --> 00:34:11,359
um i modify tokens i'm putting my

00:34:09,200 --> 00:34:14,079
message into the mailbox here

00:34:11,359 --> 00:34:15,280
uh i'm raising the flag on the mailbox

00:34:14,079 --> 00:34:17,679
at the same time because the flag on the

00:34:15,280 --> 00:34:21,040
mailboxes is tokens empty basically

00:34:17,679 --> 00:34:23,919
um and then i clash my symbols uh

00:34:21,040 --> 00:34:25,200
condition variable has a method called

00:34:23,919 --> 00:34:27,679
notify one

00:34:25,200 --> 00:34:29,679
it also has a method called notify all

00:34:27,679 --> 00:34:32,879
um notify one will wake up

00:34:29,679 --> 00:34:34,079
one uh individual who is waiting on that

00:34:32,879 --> 00:34:36,560
condition variable notify

00:34:34,079 --> 00:34:38,000
all will wake them all up again they

00:34:36,560 --> 00:34:39,359
could wake up spuriously when a truck

00:34:38,000 --> 00:34:43,280
backfires but we're

00:34:39,359 --> 00:34:45,679
not worrying about that at the moment um

00:34:43,280 --> 00:34:48,159
on the other side here's frosty's side

00:34:45,679 --> 00:34:50,720
um we have a get token function

00:34:48,159 --> 00:34:52,159
and what it's going to do is take the

00:34:50,720 --> 00:34:54,879
walk on the mutex

00:34:52,159 --> 00:34:55,839
and look at the tokens vector is it

00:34:54,879 --> 00:34:58,880
empty

00:34:55,839 --> 00:34:59,839
this is our mailbox flag if the mailbox

00:34:58,880 --> 00:35:02,320
is empty

00:34:59,839 --> 00:35:03,760
then we're going to go to sleep next to

00:35:02,320 --> 00:35:07,040
the mailbox

00:35:03,760 --> 00:35:08,720
when we go to sleep uh we are no longer

00:35:07,040 --> 00:35:11,839
looking at the mailbox and we drop

00:35:08,720 --> 00:35:15,280
our hold on the mutex the

00:35:11,839 --> 00:35:15,280
mutex here controls

00:35:15,760 --> 00:35:19,200
the what am i saying here the view text

00:35:17,440 --> 00:35:23,119
here controls access to tokens

00:35:19,200 --> 00:35:25,200
so as long as our behavior depends on

00:35:23,119 --> 00:35:26,560
the mailbox being empty we need to hold

00:35:25,200 --> 00:35:29,680
that mutex

00:35:26,560 --> 00:35:33,359
um so what cp.weight of

00:35:29,680 --> 00:35:33,760
lock does is uh it takes the law or

00:35:33,359 --> 00:35:36,240
sorry

00:35:33,760 --> 00:35:37,760
it already has the lock it will

00:35:36,240 --> 00:35:38,480
relinquish the lock and go to sleep and

00:35:37,760 --> 00:35:41,680
it will do that

00:35:38,480 --> 00:35:43,920
atomically there will be no little gap

00:35:41,680 --> 00:35:45,440
where someone else could steal in grab

00:35:43,920 --> 00:35:47,760
the lock modify tokens

00:35:45,440 --> 00:35:48,720
before we went to sleep it will

00:35:47,760 --> 00:35:51,280
atomically

00:35:48,720 --> 00:35:51,920
drop the lock and go to sleep once it

00:35:51,280 --> 00:35:53,440
wakes up

00:35:51,920 --> 00:35:54,640
it will try to reacquire the lock it

00:35:53,440 --> 00:35:55,839
will wait until it has done so and then

00:35:54,640 --> 00:35:58,320
it will return to us

00:35:55,839 --> 00:35:58,880
so when it returns we still have the

00:35:58,320 --> 00:36:00,240
lock

00:35:58,880 --> 00:36:02,240
we dropped it while we were asleep but

00:36:00,240 --> 00:36:03,760
now we have the lock again and again we

00:36:02,240 --> 00:36:05,280
can look and see if anyone has got an

00:36:03,760 --> 00:36:07,920
email for us

00:36:05,280 --> 00:36:09,920
um we drop out of the loop assuming

00:36:07,920 --> 00:36:11,920
there is some mail for us

00:36:09,920 --> 00:36:15,040
we pop something off the back of tokens

00:36:11,920 --> 00:36:19,200
and we return that token to our caller

00:36:15,040 --> 00:36:22,880
so this is our condition variable

00:36:19,200 --> 00:36:26,079
in slide 26 why isn't it a lock guard

00:36:22,880 --> 00:36:26,800
it actually could be a lock guard uh the

00:36:26,079 --> 00:36:29,520
reason that

00:36:26,800 --> 00:36:31,760
uh i made it a unique lock is so that i

00:36:29,520 --> 00:36:34,880
could manually unlock it here

00:36:31,760 --> 00:36:36,400
uh before doing the notify um in

00:36:34,880 --> 00:36:36,960
previous versions of this presentation i

00:36:36,400 --> 00:36:38,480
would also

00:36:36,960 --> 00:36:40,800
sometimes reverse those lines and do the

00:36:38,480 --> 00:36:41,599
notify before the unlock uh semantically

00:36:40,800 --> 00:36:43,920
it doesn't matter

00:36:41,599 --> 00:36:44,880
for performance people keep telling me

00:36:43,920 --> 00:36:47,119
it's a good idea

00:36:44,880 --> 00:36:48,480
to do the unlock before the notify and

00:36:47,119 --> 00:36:50,160
so that's what i've done here in order

00:36:48,480 --> 00:36:52,320
to manually unlock it it needs to be a

00:36:50,160 --> 00:36:54,160
unique lock because that is the only

00:36:52,320 --> 00:36:56,240
type with a with an empty state right at

00:36:54,160 --> 00:36:57,680
lock guard holds the lock all the way

00:36:56,240 --> 00:37:01,040
until it's destructor and i wouldn't be

00:36:57,680 --> 00:37:02,480
able to manually unlock it here

00:37:01,040 --> 00:37:05,839
i could add an extra scope of curly

00:37:02,480 --> 00:37:07,359
braces but that would take more lines

00:37:05,839 --> 00:37:08,800
so whenever you have this pattern of a

00:37:07,359 --> 00:37:11,280
producer and a consumer where the

00:37:08,800 --> 00:37:13,200
consumer must wait for the producer

00:37:11,280 --> 00:37:14,320
and this production consumption cycle

00:37:13,200 --> 00:37:16,079
happens over and over

00:37:14,320 --> 00:37:18,079
such as in our token pool such as a task

00:37:16,079 --> 00:37:18,800
queue a work queue a channel in the go

00:37:18,079 --> 00:37:20,560
sense

00:37:18,800 --> 00:37:23,119
then you almost certainly want to have a

00:37:20,560 --> 00:37:24,960
mutex plus a condition variable

00:37:23,119 --> 00:37:26,240
we will see later i'll have one slide on

00:37:24,960 --> 00:37:27,839
promise and future we're not going to

00:37:26,240 --> 00:37:29,280
talk about them a lot in this talk they

00:37:27,839 --> 00:37:31,359
are implemented internally

00:37:29,280 --> 00:37:32,880
in terms of mutex and cv promise and

00:37:31,359 --> 00:37:34,880
future would be appropriate

00:37:32,880 --> 00:37:36,000
if you just had a producer talking to

00:37:34,880 --> 00:37:38,160
one consumer

00:37:36,000 --> 00:37:39,760
and it was a one-shot deal for something

00:37:38,160 --> 00:37:42,320
like this where it's a loop a task

00:37:39,760 --> 00:37:44,160
queue channel you want to use a mutex

00:37:42,320 --> 00:37:47,040
and a condition variable

00:37:44,160 --> 00:37:47,440
um of course if you can use something

00:37:47,040 --> 00:37:49,520
like

00:37:47,440 --> 00:37:51,359
threading building blocks intel tbb if

00:37:49,520 --> 00:37:53,760
you can use you know for some

00:37:51,359 --> 00:37:54,640
applications maybe you want to use azio

00:37:53,760 --> 00:37:56,720
type things all

00:37:54,640 --> 00:37:58,400
there's all sorts of libraries out there

00:37:56,720 --> 00:38:00,320
um especially if your program is

00:37:58,400 --> 00:38:02,079
fundamentally concerned with concurrency

00:38:00,320 --> 00:38:03,280
again this presentation is geared to

00:38:02,079 --> 00:38:04,320
people who are just getting into

00:38:03,280 --> 00:38:06,320
concurrency

00:38:04,320 --> 00:38:08,400
uh who maybe have a one-off task that

00:38:06,320 --> 00:38:09,520
requires you know using a mutex

00:38:08,400 --> 00:38:12,480
correctly

00:38:09,520 --> 00:38:13,920
um if your program is fundamentally

00:38:12,480 --> 00:38:18,079
concerned with multi-threading

00:38:13,920 --> 00:38:21,200
you're going to need a bigger boat

00:38:18,079 --> 00:38:22,800
all right so c plus plus 11 made the

00:38:21,200 --> 00:38:24,320
core language know about threads in

00:38:22,800 --> 00:38:25,760
order to explain how concurrent rights

00:38:24,320 --> 00:38:27,520
to end cause you be but concurrent

00:38:25,760 --> 00:38:29,760
rights to atomic don't

00:38:27,520 --> 00:38:30,800
but simple 11 did another cool thing as

00:38:29,760 --> 00:38:33,520
well with this

00:38:30,800 --> 00:38:34,000
idea of threads in the core language uh

00:38:33,520 --> 00:38:37,839
in

00:38:34,000 --> 00:38:40,000
main here i make two threads t1 and t2

00:38:37,839 --> 00:38:42,560
and i am saying that their job in both

00:38:40,000 --> 00:38:46,240
cases is foof it was a function here

00:38:42,560 --> 00:38:48,960
um takes no parameters and it has a

00:38:46,240 --> 00:38:50,400
static local variable of type

00:38:48,960 --> 00:38:52,480
complicated object

00:38:50,400 --> 00:38:53,440
so t1 and t2 will arrive at this line

00:38:52,480 --> 00:38:54,880
concurrently

00:38:53,440 --> 00:38:57,359
right there will be no synchronization

00:38:54,880 --> 00:38:59,520
between t1 and t2 when they get here

00:38:57,359 --> 00:39:02,160
which one of them is going to perform

00:38:59,520 --> 00:39:04,640
the constructor of complicated object

00:39:02,160 --> 00:39:07,440
and what is the other one doing while

00:39:04,640 --> 00:39:07,440
that's going on

00:39:07,680 --> 00:39:12,160
in c 03 when you had a static variable

00:39:10,960 --> 00:39:14,079
like this like a singleton

00:39:12,160 --> 00:39:16,079
uh you had to do things like there's a

00:39:14,079 --> 00:39:17,280
double-check locking pattern and anyway

00:39:16,079 --> 00:39:18,160
it's all ub because there were no

00:39:17,280 --> 00:39:21,520
threads

00:39:18,160 --> 00:39:25,760
in c plus plus 11 it is as easy as

00:39:21,520 --> 00:39:28,800
make a static local and this is a valid

00:39:25,760 --> 00:39:30,640
uh inline function that returns a

00:39:28,800 --> 00:39:31,200
reference to a correctly initialized

00:39:30,640 --> 00:39:32,800
singleton

00:39:31,200 --> 00:39:34,560
only one thread will initialize this

00:39:32,800 --> 00:39:36,400
singleton when it gets there the first

00:39:34,560 --> 00:39:37,359
thread to arrive starts initializing the

00:39:36,400 --> 00:39:39,920
static instance

00:39:37,359 --> 00:39:41,280
the static variable here any more

00:39:39,920 --> 00:39:43,520
threads that arrive

00:39:41,280 --> 00:39:45,680
will according to the standard block and

00:39:43,520 --> 00:39:46,800
wait until the first thread succeeds

00:39:45,680 --> 00:39:49,920
unlocking them all

00:39:46,800 --> 00:39:52,079
or frozen exception uh which means

00:39:49,920 --> 00:39:53,280
it's exiting out it's done the object

00:39:52,079 --> 00:39:55,200
didn't get constructed

00:39:53,280 --> 00:39:57,839
and then one of the waiters will unlock

00:39:55,200 --> 00:39:59,440
and it will try its turn

00:39:57,839 --> 00:40:01,280
this is known as thread safe static

00:39:59,440 --> 00:40:04,079
initialization and this is standard

00:40:01,280 --> 00:40:06,319
since c plus plus 11. you don't need any

00:40:04,079 --> 00:40:11,839
special additional synchronization

00:40:06,319 --> 00:40:11,839
in order to make this work it just works

00:40:12,400 --> 00:40:16,319
so suppose you want a singleton per

00:40:14,400 --> 00:40:18,240
instance of some other object so you

00:40:16,319 --> 00:40:22,400
can't use a static but i have this

00:40:18,240 --> 00:40:24,480
um this data member of a logger so each

00:40:22,400 --> 00:40:25,280
logger has its own optional network

00:40:24,480 --> 00:40:27,599
connection

00:40:25,280 --> 00:40:29,520
and i have this get connection function

00:40:27,599 --> 00:40:31,440
that the first time you call it

00:40:29,520 --> 00:40:33,040
i want it to create a new network

00:40:31,440 --> 00:40:36,240
connection

00:40:33,040 --> 00:40:38,160
and populate the optional

00:40:36,240 --> 00:40:40,400
but this code is clearly unsafe it's not

00:40:38,160 --> 00:40:41,520
thread safe if two threads call getcon

00:40:40,400 --> 00:40:44,640
concurrently

00:40:41,520 --> 00:40:45,040
um as the first call because they will

00:40:44,640 --> 00:40:46,319
both

00:40:45,040 --> 00:40:48,000
look at con they'll see it doesn't have

00:40:46,319 --> 00:40:49,359
a value lit they will both construct

00:40:48,000 --> 00:40:51,200
network connection they will both try to

00:40:49,359 --> 00:40:54,319
write the con this is a data race

00:40:51,200 --> 00:40:56,000
how do we fix that um

00:40:54,319 --> 00:40:58,079
well one way to do it is protect it with

00:40:56,000 --> 00:40:59,760
a mutex this is totally fine

00:40:58,079 --> 00:41:02,240
um and we have seen this already

00:40:59,760 --> 00:41:02,240
protective

00:41:04,240 --> 00:41:07,440
mutex now this code is safe but it is

00:41:06,480 --> 00:41:09,920
perhaps

00:41:07,440 --> 00:41:12,640
that was weird little glitch there but

00:41:09,920 --> 00:41:15,040
it's perhaps slower than it uh could be

00:41:12,640 --> 00:41:17,839
right because now every time we call get

00:41:15,040 --> 00:41:19,599
con we have to try to lock that mutex

00:41:17,839 --> 00:41:21,760
and if there's a lot of contention this

00:41:19,599 --> 00:41:24,240
is going to be very slow

00:41:21,760 --> 00:41:25,200
what we can do is we can use a new

00:41:24,240 --> 00:41:28,400
primitive in c

00:41:25,200 --> 00:41:32,720
plus 11 called once flag or

00:41:28,400 --> 00:41:35,440
call once so a once flag object

00:41:32,720 --> 00:41:36,560
is a concurrency primitive like mutex or

00:41:35,440 --> 00:41:38,720
condition variable

00:41:36,560 --> 00:41:40,480
but it only has one method and that

00:41:38,720 --> 00:41:41,280
method for some reason is implemented as

00:41:40,480 --> 00:41:44,319
a free function

00:41:41,280 --> 00:41:45,839
not as a method on one's flag um

00:41:44,319 --> 00:41:47,680
it takes the once flag as its first

00:41:45,839 --> 00:41:48,400
parameter but this is basically think of

00:41:47,680 --> 00:41:49,839
it as

00:41:48,400 --> 00:41:52,960
the only thing you can do with a once

00:41:49,839 --> 00:41:55,119
flag is you can call call once on it

00:41:52,960 --> 00:41:56,720
when you do that you give it some sort

00:41:55,119 --> 00:42:00,000
of job to do

00:41:56,720 --> 00:42:03,280
and every time this line is reached um

00:42:00,000 --> 00:42:06,560
if the once flag has not yet been

00:42:03,280 --> 00:42:07,760
done um if no one has succeeded at this

00:42:06,560 --> 00:42:11,839
task yet

00:42:07,760 --> 00:42:11,839
we will try this task cue

00:42:12,000 --> 00:42:15,040
the waiters behind us to attempt this

00:42:14,160 --> 00:42:17,520
task

00:42:15,040 --> 00:42:18,560
uh if we fail the first one to succeed

00:42:17,520 --> 00:42:21,839
at this task

00:42:18,560 --> 00:42:23,760
sets the once flag to done um

00:42:21,839 --> 00:42:25,119
and from then on anyone who calls call

00:42:23,760 --> 00:42:26,079
once on it just says oh the task's

00:42:25,119 --> 00:42:27,680
already been done

00:42:26,079 --> 00:42:30,640
i don't need to do anything else this is

00:42:27,680 --> 00:42:33,520
more efficient

00:42:30,640 --> 00:42:35,040
mutex every single time so this mimic so

00:42:33,520 --> 00:42:37,440
c plus plus 11 does

00:42:35,040 --> 00:42:39,119
uh thread save static initialization but

00:42:37,440 --> 00:42:40,960
it does it for a non-static variable

00:42:39,119 --> 00:42:44,640
such as a member variable

00:42:40,960 --> 00:42:45,760
um so uh this is where you would use

00:42:44,640 --> 00:42:47,359
once flag

00:42:45,760 --> 00:42:49,040
i see a lot of people using one's flag

00:42:47,359 --> 00:42:50,480
for global variables using one flag for

00:42:49,040 --> 00:42:50,800
static variables you don't have to do

00:42:50,480 --> 00:42:52,400
that

00:42:50,800 --> 00:42:54,480
right this is the intended use case for

00:42:52,400 --> 00:42:56,880
one swag

00:42:54,480 --> 00:42:57,520
so here's a comparison of the primitives

00:42:56,880 --> 00:42:59,839
um

00:42:57,520 --> 00:43:01,280
which i believe we are running far

00:42:59,839 --> 00:43:04,800
behind and i am going to

00:43:01,280 --> 00:43:07,440
move on quickly sorry um

00:43:04,800 --> 00:43:08,400
c plus plus 17 is a reader writer lock

00:43:07,440 --> 00:43:09,920
that someone asked about in the

00:43:08,400 --> 00:43:11,040
questions that reader writer lock is

00:43:09,920 --> 00:43:13,760
known in c plus plus

00:43:11,040 --> 00:43:15,920
as a shared mutex because there are two

00:43:13,760 --> 00:43:17,599
kinds of ways that you can lock it

00:43:15,920 --> 00:43:19,680
you can call just regular dot lock and

00:43:17,599 --> 00:43:20,400
doc unlock which are called by unique

00:43:19,680 --> 00:43:23,040
lock

00:43:20,400 --> 00:43:24,560
this gives you an exclusive lock a what

00:43:23,040 --> 00:43:26,960
we would call a writer lock

00:43:24,560 --> 00:43:30,319
on the reader writer lock however it

00:43:26,960 --> 00:43:30,319
also has functions called

00:43:32,079 --> 00:43:35,599
and unlock shared and these are your

00:43:34,240 --> 00:43:37,680
read lock functions

00:43:35,599 --> 00:43:39,040
as many threads as you want can all be

00:43:37,680 --> 00:43:40,400
sharing the same

00:43:39,040 --> 00:43:41,680
lock shared like you can have many

00:43:40,400 --> 00:43:43,040
threads concurrently called lock share

00:43:41,680 --> 00:43:46,240
they're all readers

00:43:43,040 --> 00:43:47,839
um and uh they all do their reading

00:43:46,240 --> 00:43:49,680
stuff they all unlock and then

00:43:47,839 --> 00:43:51,200
finally a writer can get in a single

00:43:49,680 --> 00:43:52,240
writer can get the exclusive lock and do

00:43:51,200 --> 00:43:53,920
what's writing thing

00:43:52,240 --> 00:43:55,760
so this is a reader writer lock that we

00:43:53,920 --> 00:43:58,319
in c plus plus call for some reason

00:43:55,760 --> 00:43:59,760
shared mutex the terminology is

00:43:58,319 --> 00:44:03,920
different but if you're familiar with

00:43:59,760 --> 00:44:03,920
pthreads rw lock it works the same way

00:44:04,240 --> 00:44:08,400
in c plus plus 20 uh we also add

00:44:06,880 --> 00:44:11,040
semaphores a semaphore

00:44:08,400 --> 00:44:12,480
is a bag of poker chips very similar to

00:44:11,040 --> 00:44:13,280
our thread pool this is now sort of

00:44:12,480 --> 00:44:17,280
built into the

00:44:13,280 --> 00:44:18,960
the library um it has two methods

00:44:17,280 --> 00:44:21,920
acquire and release

00:44:18,960 --> 00:44:22,560
um a choir uh removes the chip from the

00:44:21,920 --> 00:44:24,000
bag

00:44:22,560 --> 00:44:25,920
uh and if there are no chips available

00:44:24,000 --> 00:44:27,040
it will block until there are chips

00:44:25,920 --> 00:44:30,079
available

00:44:27,040 --> 00:44:32,000
uh release returns a chip to the bag

00:44:30,079 --> 00:44:33,440
um we assume that you acquired a chip

00:44:32,000 --> 00:44:35,040
earlier if you didn't then you just keep

00:44:33,440 --> 00:44:36,319
releasing chips and adding things until

00:44:35,040 --> 00:44:40,160
the bag overflows

00:44:36,319 --> 00:44:42,000
um that's undefined behavior um

00:44:40,160 --> 00:44:43,280
but yeah it's basically a counter that

00:44:42,000 --> 00:44:44,319
can go up and down and up and down and

00:44:43,280 --> 00:44:47,680
if it gets to zero

00:44:44,319 --> 00:44:48,960
it blocks until someone else bumps it up

00:44:47,680 --> 00:44:50,720
uh chips are indistinguishable

00:44:48,960 --> 00:44:52,319
interchangeable and not tied to any

00:44:50,720 --> 00:44:53,520
particular thread this is different from

00:44:52,319 --> 00:44:55,520
a mutex lock

00:44:53,520 --> 00:44:57,599
you can't pass a mutex lock between two

00:44:55,520 --> 00:44:59,200
stid threads the thread that has it

00:44:57,599 --> 00:44:59,520
locked is the thread that has to unlock

00:44:59,200 --> 00:45:00,960
it

00:44:59,520 --> 00:45:03,119
that's just part of what it means to be

00:45:00,960 --> 00:45:05,280
a standard mutex

00:45:03,119 --> 00:45:06,319
but you could use a counting semaphore

00:45:05,280 --> 00:45:09,839
as a kind

00:45:06,319 --> 00:45:11,200
as a kind of mutex um whose locks could

00:45:09,839 --> 00:45:14,400
be passed between threads

00:45:11,200 --> 00:45:16,400
you would just give it a maximum of one

00:45:14,400 --> 00:45:17,680
right someone has the one token they can

00:45:16,400 --> 00:45:20,640
pass it across my other thread that'll

00:45:17,680 --> 00:45:23,680
defend calls release that's totally fine

00:45:20,640 --> 00:45:27,040
um this makes our uh token pool

00:45:23,680 --> 00:45:30,319
uh slightly safer to use um if you saw

00:45:27,040 --> 00:45:33,119
my cppcon 2019 talk back to basics smart

00:45:30,319 --> 00:45:35,040
pointers uh you saw me using unique

00:45:33,119 --> 00:45:38,079
footers for interesting things

00:45:35,040 --> 00:45:39,760
like open ssl certificates and things

00:45:38,079 --> 00:45:41,839
here's another example where i'm using a

00:45:39,760 --> 00:45:45,040
unique putter

00:45:41,839 --> 00:45:46,480
to say uh you have a handle to a

00:45:45,040 --> 00:45:48,640
semaphore and

00:45:46,480 --> 00:45:50,160
when you're done with this token i want

00:45:48,640 --> 00:45:54,800
you to call release

00:45:50,160 --> 00:45:56,800
on that semaphore um

00:45:54,800 --> 00:45:58,000
someone asks do we ever need to use

00:45:56,800 --> 00:46:00,880
volatile

00:45:58,000 --> 00:46:03,599
no that was easy please don't use

00:46:00,880 --> 00:46:07,280
volatile for anything ever

00:46:03,599 --> 00:46:09,520
um also in c plus plus 20 there

00:46:07,280 --> 00:46:11,200
is a another thing besides semaphore we

00:46:09,520 --> 00:46:13,119
also now have latch

00:46:11,200 --> 00:46:14,800
std latch is an integer counter that

00:46:13,119 --> 00:46:15,760
starts positive and counts down towards

00:46:14,800 --> 00:46:18,480
zero

00:46:15,760 --> 00:46:19,280
and when someone reaches the latch they

00:46:18,480 --> 00:46:22,240
will then

00:46:19,280 --> 00:46:23,760
wait at the latch until every other

00:46:22,240 --> 00:46:25,760
thread has reached the latch that is

00:46:23,760 --> 00:46:27,440
until the counter has gone down to zero

00:46:25,760 --> 00:46:29,520
and then they were all unblocked this is

00:46:27,440 --> 00:46:31,200
a one-shot starting gate mechanism

00:46:29,520 --> 00:46:32,400
wait for everyone to arrive here we have

00:46:31,200 --> 00:46:33,520
a counter that says how many people

00:46:32,400 --> 00:46:35,680
haven't arrived yet

00:46:33,520 --> 00:46:38,400
once everyone has arrived i'll let you

00:46:35,680 --> 00:46:41,119
all go that's a starting gate

00:46:38,400 --> 00:46:42,960
latch is similar to once flag or promise

00:46:41,119 --> 00:46:44,480
or future that there's no way to reset

00:46:42,960 --> 00:46:46,640
it it is a one-time thing

00:46:44,480 --> 00:46:47,839
if you want another latch destroy this

00:46:46,640 --> 00:46:51,200
one and create a new one

00:46:47,839 --> 00:46:52,720
it's a one-time thing um if you want a

00:46:51,200 --> 00:46:55,280
reusable

00:46:52,720 --> 00:46:57,040
starting gate what i might call a pace

00:46:55,280 --> 00:46:58,079
car mechanism if you're familiar with

00:46:57,040 --> 00:47:01,440
auto racing

00:46:58,079 --> 00:47:03,200
um you have a barrier

00:47:01,440 --> 00:47:04,880
stead barrier is essentially a

00:47:03,200 --> 00:47:08,000
resettable latch

00:47:04,880 --> 00:47:10,480
um so again it has a counter we uh

00:47:08,000 --> 00:47:11,920
as people show up at the barrier uh they

00:47:10,480 --> 00:47:14,480
block and they wait

00:47:11,920 --> 00:47:15,520
uh once the appropriate number of people

00:47:14,480 --> 00:47:18,240
have arrived

00:47:15,520 --> 00:47:19,280
uh the barrier lets comes down and lets

00:47:18,240 --> 00:47:21,280
everyone go

00:47:19,280 --> 00:47:23,200
and begins a new phase immediately

00:47:21,280 --> 00:47:24,480
atomically such that if someone comes

00:47:23,200 --> 00:47:25,599
around and starts waiting again

00:47:24,480 --> 00:47:27,280
immediately they will block and

00:47:25,599 --> 00:47:29,040
they will wait again until everyone has

00:47:27,280 --> 00:47:30,240
come around and done one lap

00:47:29,040 --> 00:47:31,599
and then they will all get to go and

00:47:30,240 --> 00:47:33,280
come around and do another lap and

00:47:31,599 --> 00:47:34,880
they'll unblock and let them all go

00:47:33,280 --> 00:47:36,559
so this is a pace car once everyone's

00:47:34,880 --> 00:47:39,520
caught up on block everyone atomically

00:47:36,559 --> 00:47:43,040
refresh the barrier

00:47:39,520 --> 00:47:44,319
um rob says uh talking about uh passing

00:47:43,040 --> 00:47:47,359
semaphore tokens between

00:47:44,319 --> 00:47:50,480
threads uh wouldn't you need some

00:47:47,359 --> 00:47:53,599
method to pass the token safely um

00:47:50,480 --> 00:47:56,160
no uh sort of yes sort of no let's take

00:47:53,599 --> 00:47:58,720
that one to the hallway track as well

00:47:56,160 --> 00:48:00,319
um what's the difference between uh

00:47:58,720 --> 00:48:01,040
blocking these threads and then letting

00:48:00,319 --> 00:48:04,319
them go

00:48:01,040 --> 00:48:07,200
versus joining them um

00:48:04,319 --> 00:48:08,880
two things number one join blocks the

00:48:07,200 --> 00:48:11,920
thread that calls join

00:48:08,880 --> 00:48:16,160
until another thread finishes

00:48:11,920 --> 00:48:18,400
a latch you call latch.weight from

00:48:16,160 --> 00:48:19,760
the thread that's running right not the

00:48:18,400 --> 00:48:21,920
main thread but the act the thread

00:48:19,760 --> 00:48:24,559
that's like going around

00:48:21,920 --> 00:48:25,599
and it blocks that thread until some

00:48:24,559 --> 00:48:27,920
other thread gets

00:48:25,599 --> 00:48:29,440
also to that point or also to latch

00:48:27,920 --> 00:48:32,800
weight

00:48:29,440 --> 00:48:33,920
uh or sorry latch arrive and wait um

00:48:32,800 --> 00:48:35,440
and then lets them all go i actually

00:48:33,920 --> 00:48:36,640
have a couple of examples in a slide so

00:48:35,440 --> 00:48:38,559
that might help

00:48:36,640 --> 00:48:40,800
um there are some subtleties of slid

00:48:38,559 --> 00:48:42,400
barrier and glossing over it's really a

00:48:40,800 --> 00:48:44,640
class template at the final completion

00:48:42,400 --> 00:48:47,280
function we'll see an example of that

00:48:44,640 --> 00:48:48,880
um it has possibilities for undefined

00:48:47,280 --> 00:48:50,400
behavior if you use it wrong

00:48:48,880 --> 00:48:52,240
so it's important to read the

00:48:50,400 --> 00:48:55,040
documentation

00:48:52,240 --> 00:48:56,800
um here is how i might use latch to

00:48:55,040 --> 00:48:58,400
solve our thread starting problem

00:48:56,800 --> 00:49:00,640
remember threads start immediately

00:48:58,400 --> 00:49:01,520
running but what i can do is i can make

00:49:00,640 --> 00:49:03,119
a latch

00:49:01,520 --> 00:49:05,440
uh with the counter initially set to two

00:49:03,119 --> 00:49:06,800
i expect two threads to call arrive and

00:49:05,440 --> 00:49:09,200
wait on the latch

00:49:06,800 --> 00:49:11,440
uh here's my thread b its job is step

00:49:09,200 --> 00:49:14,240
one arrive and wait at the latch

00:49:11,440 --> 00:49:15,520
wait for the other thread to arrive so

00:49:14,240 --> 00:49:16,079
that's what it's doing it's blocked

00:49:15,520 --> 00:49:18,640
there

00:49:16,079 --> 00:49:19,119
now meanwhile in thread a i print hello

00:49:18,640 --> 00:49:21,440
from a

00:49:19,119 --> 00:49:22,480
and then i also arrive and wait at the

00:49:21,440 --> 00:49:24,240
same latch

00:49:22,480 --> 00:49:26,000
notice i'm capturing a reference this

00:49:24,240 --> 00:49:27,359
latch so my latch here and my latch here

00:49:26,000 --> 00:49:30,319
refer to the same

00:49:27,359 --> 00:49:32,319
local variable latch now both of my

00:49:30,319 --> 00:49:33,040
threads have arrived and waited at the

00:49:32,319 --> 00:49:36,240
latch

00:49:33,040 --> 00:49:38,800
and so the latch lets them both go now

00:49:36,240 --> 00:49:40,640
thread b is unblocked and thread a is

00:49:38,800 --> 00:49:42,800
unblocked thread a immediately goes and

00:49:40,640 --> 00:49:45,520
joins thread b so now it's blocked again

00:49:42,800 --> 00:49:47,520
meanwhile thread b prints hello from b

00:49:45,520 --> 00:49:50,400
and x sets that unblocks a here

00:49:47,520 --> 00:49:51,680
so hopefully this example uh and it may

00:49:50,400 --> 00:49:52,960
not even be on the screen long enough

00:49:51,680 --> 00:49:54,800
but if you go and study the

00:49:52,960 --> 00:49:56,480
the slide hopefully this clarifies the

00:49:54,800 --> 00:49:59,040
difference between

00:49:56,480 --> 00:50:01,359
waiting on a latch and joining another

00:49:59,040 --> 00:50:01,359
thread

00:50:03,520 --> 00:50:07,200
in fact the main thread is going to call

00:50:05,359 --> 00:50:09,040
join anyway so we can just do this we

00:50:07,200 --> 00:50:11,760
can say

00:50:09,040 --> 00:50:13,760
we're just waiting on one thread and you

00:50:11,760 --> 00:50:15,839
don't bother decrementing it just wait

00:50:13,760 --> 00:50:17,040
one thread is is still too boring if you

00:50:15,839 --> 00:50:20,000
wait until they come

00:50:17,040 --> 00:50:21,760
then here you say you arrive you

00:50:20,000 --> 00:50:23,119
decorate the counter but you don't wait

00:50:21,760 --> 00:50:24,480
right you don't need to wait just just

00:50:23,119 --> 00:50:27,280
decrement counters prove you've been

00:50:24,480 --> 00:50:28,960
here go on so no matter what order these

00:50:27,280 --> 00:50:30,559
two functions end up getting called in

00:50:28,960 --> 00:50:32,000
right there's no synchronization that

00:50:30,559 --> 00:50:32,800
says what order they're gonna get called

00:50:32,000 --> 00:50:36,000
in

00:50:32,800 --> 00:50:36,880
but thread a here is sort of leaving a

00:50:36,000 --> 00:50:39,440
note

00:50:36,880 --> 00:50:40,160
for thread b that says yes i got here if

00:50:39,440 --> 00:50:41,680
you're waiting

00:50:40,160 --> 00:50:44,240
unblock yourself if you haven't started

00:50:41,680 --> 00:50:47,680
waiting yet you don't even need to wait

00:50:44,240 --> 00:50:49,440
so you could do this um

00:50:47,680 --> 00:50:51,200
are latches copyable no no

00:50:49,440 --> 00:50:53,119
synchronization primitives could ever be

00:50:51,200 --> 00:50:55,040
copyable mutexes are not copyable

00:50:53,119 --> 00:50:56,960
condition variables are not copyable

00:50:55,040 --> 00:50:58,720
right all the actual things they just

00:50:56,960 --> 00:51:00,720
sit in one place in memory

00:50:58,720 --> 00:51:02,160
uh and you you poke at them they're

00:51:00,720 --> 00:51:03,040
they're very object-oriented they have

00:51:02,160 --> 00:51:07,200
state

00:51:03,040 --> 00:51:08,480
um you could not make a copy of a mutex

00:51:07,200 --> 00:51:10,160
similarly you can't make a copy of a

00:51:08,480 --> 00:51:11,119
latch so how does this thread know where

00:51:10,160 --> 00:51:12,960
the latch is

00:51:11,119 --> 00:51:15,200
uh because it captured a reference to it

00:51:12,960 --> 00:51:17,280
the lambda captured a reference to it

00:51:15,200 --> 00:51:18,400
and uh you know could this reference

00:51:17,280 --> 00:51:20,000
dangle yes

00:51:18,400 --> 00:51:21,839
theoretically if thread a finished and

00:51:20,000 --> 00:51:23,359
destroyed the latch

00:51:21,839 --> 00:51:24,800
but we're using synchronization to make

00:51:23,359 --> 00:51:26,319
sure that doesn't happen we're making

00:51:24,800 --> 00:51:27,200
sure that we join thread b and it's

00:51:26,319 --> 00:51:30,480
completely done

00:51:27,200 --> 00:51:30,480
before we destroy the latch

00:51:31,599 --> 00:51:34,720
synchronization with stick barrier looks

00:51:33,440 --> 00:51:36,640
kind of similar

00:51:34,720 --> 00:51:38,559
barrier as i said is a template which

00:51:36,640 --> 00:51:39,040
allows you to put a completion function

00:51:38,559 --> 00:51:41,440
here

00:51:39,040 --> 00:51:43,040
uh that says this is the thing that i

00:51:41,440 --> 00:51:44,880
also want to by the way like

00:51:43,040 --> 00:51:47,440
notify someone else when the barrier

00:51:44,880 --> 00:51:49,280
comes down latches can't do this barrier

00:51:47,440 --> 00:51:51,119
can so barrier is more general

00:51:49,280 --> 00:51:52,400
so here's my barrier the counter is

00:51:51,119 --> 00:51:55,440
initially two

00:51:52,400 --> 00:51:57,280
um b is setting up a is setting up then

00:51:55,440 --> 00:51:58,880
they both arrive and wait at the barrier

00:51:57,280 --> 00:51:59,599
once they are both waiting the barrier

00:51:58,880 --> 00:52:02,720
comes down

00:51:59,599 --> 00:52:04,400
and it prints green flag go and then

00:52:02,720 --> 00:52:06,960
we get b is running and a is running in

00:52:04,400 --> 00:52:06,960
some order

00:52:10,480 --> 00:52:14,319
so here's another comparison of the new

00:52:12,160 --> 00:52:16,400
primitives in c plus plus 20

00:52:14,319 --> 00:52:18,800
and notice that all of them have this

00:52:16,400 --> 00:52:20,640
counter involved so i put little graphs

00:52:18,800 --> 00:52:22,960
of how does the counter go

00:52:20,640 --> 00:52:24,720
um for counting semaphore uh different

00:52:22,960 --> 00:52:26,480
threads are acquiring and releasing and

00:52:24,720 --> 00:52:27,920
it's going up and down by one over

00:52:26,480 --> 00:52:29,520
over and over actually can go up and

00:52:27,920 --> 00:52:30,720
down by arbitrary jumps because you can

00:52:29,520 --> 00:52:34,000
pass an argument

00:52:30,720 --> 00:52:35,599
to say i want three tokens right now um

00:52:34,000 --> 00:52:37,599
but accounting time before the counter

00:52:35,599 --> 00:52:38,400
goes up and down with latch the counter

00:52:37,599 --> 00:52:40,400
starts high

00:52:38,400 --> 00:52:42,240
goes down to zero and then boom you're

00:52:40,400 --> 00:52:44,640
done one shot that's it

00:52:42,240 --> 00:52:46,000
uh the barrier counter goes down to zero

00:52:44,640 --> 00:52:47,359
and then boom right back up to where it

00:52:46,000 --> 00:52:48,640
started and goes down to zero and right

00:52:47,359 --> 00:52:50,640
back up to where it started and it keeps

00:52:48,640 --> 00:52:52,240
doing this over and over

00:52:50,640 --> 00:52:53,760
and support some extra complexity which

00:52:52,240 --> 00:52:57,920
we most mostly lost

00:52:53,760 --> 00:53:00,800
over now we finally get

00:52:57,920 --> 00:53:02,720
to a question break um on the new

00:53:00,800 --> 00:53:05,920
features here and other things

00:53:02,720 --> 00:53:07,760
um uh

00:53:05,920 --> 00:53:10,400
someone asks is a if i use a shared

00:53:07,760 --> 00:53:12,880
mutex is that slower than a simple mutex

00:53:10,400 --> 00:53:14,400
uh i would assume that yes it probably

00:53:12,880 --> 00:53:16,240
is

00:53:14,400 --> 00:53:18,319
it's more complicated if what you need

00:53:16,240 --> 00:53:20,720
is a simple mutex use a simple mutex

00:53:18,319 --> 00:53:22,559
if what you need is a reader writer lock

00:53:20,720 --> 00:53:24,720
use a shared mutex

00:53:22,559 --> 00:53:26,079
right it's based on what you need don't

00:53:24,720 --> 00:53:29,440
pay for what you don't need

00:53:26,079 --> 00:53:30,559
but also don't think oh i don't want to

00:53:29,440 --> 00:53:33,520
pay

00:53:30,559 --> 00:53:35,119
so why should the simplest possible you

00:53:33,520 --> 00:53:36,640
know i really need to read a writer lock

00:53:35,119 --> 00:53:38,160
how can i possibly simulate that with a

00:53:36,640 --> 00:53:39,440
mutex because it's cheap well you can't

00:53:38,160 --> 00:53:40,800
if there were a simple way to simulate

00:53:39,440 --> 00:53:41,599
to simulate it they would just do that

00:53:40,800 --> 00:53:44,079
in the library

00:53:41,599 --> 00:53:45,920
right so use the library type that maps

00:53:44,079 --> 00:53:48,800
well onto the actual task you're

00:53:45,920 --> 00:53:48,800
attempting to perform

00:53:49,280 --> 00:53:52,400
here's one slide on promise and future

00:53:51,200 --> 00:53:54,079
if you want more on this i do have a

00:53:52,400 --> 00:53:56,720
talk from several years ago called

00:53:54,079 --> 00:53:57,839
a future from scratch uh which might be

00:53:56,720 --> 00:53:59,520
worth watching

00:53:57,839 --> 00:54:00,880
um it's probably a little bit dated at

00:53:59,520 --> 00:54:02,400
this point it

00:54:00,880 --> 00:54:05,200
um foreshadows a lot of things that

00:54:02,400 --> 00:54:09,119
didn't actually happen in 17 and 20.

00:54:05,200 --> 00:54:10,400
um so uh one slide intro how do we do

00:54:09,119 --> 00:54:11,920
this um

00:54:10,400 --> 00:54:13,520
there's a library function called stid

00:54:11,920 --> 00:54:17,040
async and what async does

00:54:13,520 --> 00:54:20,160
is spin up a new thread do this

00:54:17,040 --> 00:54:21,680
in the thread and then it has a return

00:54:20,160 --> 00:54:22,960
threads don't return things where does

00:54:21,680 --> 00:54:25,920
this return go

00:54:22,960 --> 00:54:26,640
uh well it goes into something called a

00:54:25,920 --> 00:54:28,400
promise

00:54:26,640 --> 00:54:30,160
which is not shown on this slide because

00:54:28,400 --> 00:54:31,839
that's all wrapped up inside this did

00:54:30,160 --> 00:54:33,520
async helper function

00:54:31,839 --> 00:54:35,359
and the promise communicates with a

00:54:33,520 --> 00:54:38,079
future which is returned

00:54:35,359 --> 00:54:40,240
immediately from state async um this is

00:54:38,079 --> 00:54:42,160
the sort of thing that in c plus plus 20

00:54:40,240 --> 00:54:43,680
uh we're moving toward maybe's

00:54:42,160 --> 00:54:46,799
co-routines for this kind of thing

00:54:43,680 --> 00:54:50,880
maybe i'm not sure um so

00:54:46,799 --> 00:54:52,480
state async instantly returns a future

00:54:50,880 --> 00:54:54,160
and you can go on and you can async and

00:54:52,480 --> 00:54:55,760
other things spawn off another thread

00:54:54,160 --> 00:54:57,599
and it's doing its own job and you get a

00:54:55,760 --> 00:54:59,520
second future

00:54:57,599 --> 00:55:00,720
and then finally here where we call dot

00:54:59,520 --> 00:55:03,119
get on the future

00:55:00,720 --> 00:55:04,720
that is what blocks if it needs to and

00:55:03,119 --> 00:55:06,000
blocks and waits and goes to sleep by

00:55:04,720 --> 00:55:09,359
the mailbox

00:55:06,000 --> 00:55:10,240
f for future f for frosty the other side

00:55:09,359 --> 00:55:13,280
being promise

00:55:10,240 --> 00:55:16,640
p for pat for postman for promise

00:55:13,280 --> 00:55:19,520
so f goes to sleep and waits until

00:55:16,640 --> 00:55:21,280
he sends it the data that it needs and

00:55:19,520 --> 00:55:22,720
so this get will return one this get

00:55:21,280 --> 00:55:23,440
will return two and i'll add them

00:55:22,720 --> 00:55:27,119
together

00:55:23,440 --> 00:55:30,160
once they're both available um so

00:55:27,119 --> 00:55:32,400
uh however this is one slide uh

00:55:30,160 --> 00:55:33,680
if this sounds like something you could

00:55:32,400 --> 00:55:35,680
use in production

00:55:33,680 --> 00:55:37,040
please do not actually base your design

00:55:35,680 --> 00:55:39,119
decision on this

00:55:37,040 --> 00:55:41,599
slide please go learn about this and

00:55:39,119 --> 00:55:44,319
decide whether it's appropriate for you

00:55:41,599 --> 00:55:45,760
um the sdl async also has serious

00:55:44,319 --> 00:55:47,839
caveats about performance

00:55:45,760 --> 00:55:48,960
because it creates all these threads and

00:55:47,839 --> 00:55:49,839
that can quickly run you out of

00:55:48,960 --> 00:55:51,119
resources

00:55:49,839 --> 00:55:52,720
you really want something like a thread

00:55:51,119 --> 00:55:54,480
pool which does not exist in the

00:55:52,720 --> 00:55:56,799
standard library

00:55:54,480 --> 00:55:56,799
um

00:55:57,599 --> 00:56:02,640
someone was at pub quiz last night thank

00:55:59,440 --> 00:56:05,440
you um uh

00:56:02,640 --> 00:56:07,040
someone asks uh if i have more threads

00:56:05,440 --> 00:56:09,680
that arrive at a barrier

00:56:07,040 --> 00:56:10,640
than the counter initially was what

00:56:09,680 --> 00:56:13,040
happens

00:56:10,640 --> 00:56:14,079
um well once you get n of those threads

00:56:13,040 --> 00:56:15,440
at the barrier

00:56:14,079 --> 00:56:16,799
uh the barrier will drop and it'll go

00:56:15,440 --> 00:56:18,720
around again and then this other thread

00:56:16,799 --> 00:56:21,839
will come in late and it will join the

00:56:18,720 --> 00:56:23,359
next group to go and then

00:56:21,839 --> 00:56:24,880
you know some more will come in and once

00:56:23,359 --> 00:56:26,480
n minus one others will come in the

00:56:24,880 --> 00:56:27,359
barrier goes down and they'll go around

00:56:26,480 --> 00:56:29,359
again

00:56:27,359 --> 00:56:30,720
and at some point here you might end up

00:56:29,359 --> 00:56:33,839
with with all n

00:56:30,720 --> 00:56:35,440
minus one arriving simultaneously this

00:56:33,839 --> 00:56:36,240
sounds like it's going to give you ub at

00:56:35,440 --> 00:56:39,599
some point

00:56:36,240 --> 00:56:42,079
um but the the goal of using something

00:56:39,599 --> 00:56:44,319
like barrier is to make sure you

00:56:42,079 --> 00:56:45,760
understand all the possible things that

00:56:44,319 --> 00:56:46,319
could happen and if one of them leads to

00:56:45,760 --> 00:56:48,400
ub

00:56:46,319 --> 00:56:49,920
maybe you're you've got the design wrong

00:56:48,400 --> 00:56:51,760
right

00:56:49,920 --> 00:56:55,119
um is there a good way to use thread

00:56:51,760 --> 00:56:57,440
detach i don't talk about it here

00:56:55,119 --> 00:56:58,880
you could spin off some background job

00:56:57,440 --> 00:57:00,400
that you don't really care about what

00:56:58,880 --> 00:57:02,480
happens or it doesn't clean up

00:57:00,400 --> 00:57:03,760
very much that's quite common in real

00:57:02,480 --> 00:57:05,359
life but i'm not going to talk about it

00:57:03,760 --> 00:57:06,079
here because there's not too much to say

00:57:05,359 --> 00:57:09,200
about

00:57:06,079 --> 00:57:12,559
how to make it uh standard

00:57:09,200 --> 00:57:14,319
nice um

00:57:12,559 --> 00:57:16,000
so protect shared data with a mutex

00:57:14,319 --> 00:57:17,920
protect every access

00:57:16,000 --> 00:57:19,920
um if you have a producer consumer use

00:57:17,920 --> 00:57:22,319
mutex and condition variable

00:57:19,920 --> 00:57:24,240
um make the data in uh best of all

00:57:22,319 --> 00:57:25,599
though is avoid sharing viewable data

00:57:24,240 --> 00:57:27,920
between threads

00:57:25,599 --> 00:57:29,280
i'm already going super over time but

00:57:27,920 --> 00:57:31,040
let me very quickly get to the blue

00:57:29,280 --> 00:57:33,119
green pattern that i did want to promote

00:57:31,040 --> 00:57:34,240
here this comes from devops

00:57:33,119 --> 00:57:36,319
the idea is that you have a blue

00:57:34,240 --> 00:57:37,599
environment and a green environment you

00:57:36,319 --> 00:57:39,680
are running with the blue environment in

00:57:37,599 --> 00:57:41,599
production you

00:57:39,680 --> 00:57:42,799
spin up the green environment you move

00:57:41,599 --> 00:57:44,079
all the traffic over

00:57:42,799 --> 00:57:46,000
finally you can shut down the blue

00:57:44,079 --> 00:57:48,319
environment um

00:57:46,000 --> 00:57:49,119
so what this actually looks like in c

00:57:48,319 --> 00:57:51,599
plus plus

00:57:49,119 --> 00:57:54,000
as opposed to devops is maybe we have

00:57:51,599 --> 00:57:55,200
some global config map here that's a map

00:57:54,000 --> 00:57:57,440
of let's say i don't know strings to

00:57:55,200 --> 00:57:59,760
string some expensive data structure

00:57:57,440 --> 00:58:01,440
and everyone in the program wants to

00:57:59,760 --> 00:58:03,920
know what is the current config

00:58:01,440 --> 00:58:05,200
so those are our clients who are trying

00:58:03,920 --> 00:58:06,880
to connect to our

00:58:05,200 --> 00:58:08,640
website where the config is published

00:58:06,880 --> 00:58:11,920
right the config here is the

00:58:08,640 --> 00:58:13,520
map um so everyone's trying to get at

00:58:11,920 --> 00:58:16,000
this thing and what we're going to do

00:58:13,520 --> 00:58:17,200
is when we want to change something

00:58:16,000 --> 00:58:20,160
about the config

00:58:17,200 --> 00:58:22,000
we're going to say okay well the old

00:58:20,160 --> 00:58:25,440
config

00:58:22,000 --> 00:58:28,240
was the blue version and i'm going to

00:58:25,440 --> 00:58:30,240
uh get a pointer that i am then going to

00:58:28,240 --> 00:58:32,400
make a copy of that whole config

00:58:30,240 --> 00:58:34,240
this is the expensive part but we're

00:58:32,400 --> 00:58:36,160
doing this while the old config is still

00:58:34,240 --> 00:58:38,559
available and people are still

00:58:36,160 --> 00:58:40,160
um interacting with the old config so

00:58:38,559 --> 00:58:41,359
while that's going on in this thread

00:58:40,160 --> 00:58:42,880
that's trying to set the default host

00:58:41,359 --> 00:58:45,760
name they're going to do all the work of

00:58:42,880 --> 00:58:47,839
copying the config

00:58:45,760 --> 00:58:49,839
then they're going to modify this new

00:58:47,839 --> 00:58:51,680
config it's okay to modify it without

00:58:49,839 --> 00:58:53,520
taking a mutex lock because we are the

00:58:51,680 --> 00:58:56,640
only person yet who knows

00:58:53,520 --> 00:58:58,960
that this new config exists um

00:58:56,640 --> 00:59:00,480
so we can modify it without a mutex

00:58:58,960 --> 00:59:01,920
finally

00:59:00,480 --> 00:59:03,520
uh we're going to use an atomic

00:59:01,920 --> 00:59:07,359
operation c plus plus

00:59:03,520 --> 00:59:08,559
uh 20 adds atomic operations on a shared

00:59:07,359 --> 00:59:11,920
putter

00:59:08,559 --> 00:59:15,520
and so we can atomically say

00:59:11,920 --> 00:59:17,359
if the current blue version is still

00:59:15,520 --> 00:59:18,400
what it was no one else has swapped in a

00:59:17,359 --> 00:59:21,359
new version there

00:59:18,400 --> 00:59:23,200
then i am going to swap in my version we

00:59:21,359 --> 00:59:25,680
didn't talk about this verb compare

00:59:23,200 --> 00:59:26,319
exchange or compare and swap in this

00:59:25,680 --> 00:59:27,760
talk

00:59:26,319 --> 00:59:29,359
if that is interesting to you you're

00:59:27,760 --> 00:59:31,200
going to need a bigger boat

00:59:29,359 --> 00:59:33,040
um but that's something you can do with

00:59:31,200 --> 00:59:36,160
an atomic you can say i want to swap

00:59:33,040 --> 00:59:37,839
atomically that value for for my value

00:59:36,160 --> 00:59:39,200
um so that's how we then publish our

00:59:37,839 --> 00:59:40,720
version as soon as we publish it we have

00:59:39,200 --> 00:59:42,559
to stop writing to it the published

00:59:40,720 --> 00:59:44,559
version is read only

00:59:42,559 --> 00:59:46,319
and on the read side all we need to do

00:59:44,559 --> 00:59:48,400
is load from the atomic

00:59:46,319 --> 00:59:49,839
now we have a shared putter and now

00:59:48,400 --> 00:59:50,480
we're participating in reference

00:59:49,839 --> 00:59:54,160
counting

00:59:50,480 --> 00:59:56,559
on that actual heap allocated config map

00:59:54,160 --> 00:59:58,880
uh and so we can go you know look up

00:59:56,559 --> 01:00:01,280
things in it whatever we want to do

00:59:58,880 --> 01:00:02,799
and we will keep holding that reference

01:00:01,280 --> 01:00:04,240
count and that thing we're referring to

01:00:02,799 --> 01:00:05,920
will continue to be good

01:00:04,240 --> 01:00:07,440
and at least until we are done with it

01:00:05,920 --> 01:00:09,040
and drop our reference count

01:00:07,440 --> 01:00:10,960
so we have this read-only reference

01:00:09,040 --> 01:00:12,160
counted source of truth and anyone who

01:00:10,960 --> 01:00:14,880
wants to change it

01:00:12,160 --> 01:00:15,920
uh reads it in order to copy it and then

01:00:14,880 --> 01:00:17,920
atomically

01:00:15,920 --> 01:00:18,960
swaps out their new version for our

01:00:17,920 --> 01:00:21,440
version

01:00:18,960 --> 01:00:22,480
um so this is a pattern that is useful

01:00:21,440 --> 01:00:24,799
uh for

01:00:22,480 --> 01:00:25,680
one-off cases like i have a program that

01:00:24,799 --> 01:00:27,280
you know

01:00:25,680 --> 01:00:28,559
uses a bunch of threads for something

01:00:27,280 --> 01:00:29,440
and they all want to communicate with

01:00:28,559 --> 01:00:31,040
this config map

01:00:29,440 --> 01:00:32,640
and i didn't want to put a mutex around

01:00:31,040 --> 01:00:33,280
it what do i do how do i make a thread

01:00:32,640 --> 01:00:34,640
safe

01:00:33,280 --> 01:00:37,119
uh this might be a pattern that could be

01:00:34,640 --> 01:00:38,319
useful for you in conclusion we won't

01:00:37,119 --> 01:00:41,280
get to the bonus slides

01:00:38,319 --> 01:00:42,240
but remember data races are undefined

01:00:41,280 --> 01:00:43,920
behavior

01:00:42,240 --> 01:00:45,920
one way to get around data races is to

01:00:43,920 --> 01:00:47,520
use a mutex to protect all the accesses

01:00:45,920 --> 01:00:48,160
it must be all it must be unconditional

01:00:47,520 --> 01:00:50,160
01:00:48,160 --> 01:00:51,680
both the reads and the rights thread

01:00:50,160 --> 01:00:52,079
safe static initialization is your

01:00:51,680 --> 01:00:55,280
friend

01:00:52,079 --> 01:00:57,040
use static variables uh fearlessly

01:00:55,280 --> 01:00:58,720
right i mean they're still glorified

01:00:57,040 --> 01:01:01,520
globals they're not good

01:00:58,720 --> 01:01:03,119
uh in terms of program architecture but

01:01:01,520 --> 01:01:04,240
in terms of thread safety you don't have

01:01:03,119 --> 01:01:05,280
to do anything else you don't have to

01:01:04,240 --> 01:01:07,359
use one's flag

01:01:05,280 --> 01:01:09,839
it's thread safe to use a static

01:01:07,359 --> 01:01:11,839
variable in c plus plus

01:01:09,839 --> 01:01:13,440
if you have a non-static variable that

01:01:11,839 --> 01:01:14,319
you want to initialize only once that's

01:01:13,440 --> 01:01:16,640
when you pull out

01:01:14,319 --> 01:01:17,839
once flag mutex and condition variable

01:01:16,640 --> 01:01:18,720
two great tastes that taste great

01:01:17,839 --> 01:01:21,920
together

01:01:18,720 --> 01:01:23,520
um c plus plus 20 introduces these three

01:01:21,920 --> 01:01:24,720
new counting primitives semaphore latch

01:01:23,520 --> 01:01:26,559
and barrier

01:01:24,720 --> 01:01:27,760
and finally for the third time this talk

01:01:26,559 --> 01:01:29,599
let me repeat

01:01:27,760 --> 01:01:31,119
uh if your program is fundamentally

01:01:29,599 --> 01:01:32,319
multi-threaded if you're gonna write

01:01:31,119 --> 01:01:34,400
something that is

01:01:32,319 --> 01:01:36,960
you know complicated and real-world and

01:01:34,400 --> 01:01:39,680
multi-threaded in a fundamental way

01:01:36,960 --> 01:01:41,280
please don't base design decisions on

01:01:39,680 --> 01:01:43,920
the intro stuff in this talk

01:01:41,280 --> 01:01:44,640
please use uh you know look into promise

01:01:43,920 --> 01:01:46,400
future

01:01:44,640 --> 01:01:49,359
look into super host 20 co routines

01:01:46,400 --> 01:01:50,880
perhaps look into seo look into tbb

01:01:49,359 --> 01:01:54,160
and again don't base your choice on what

01:01:50,880 --> 01:01:56,799
you saw on these slides

01:01:54,160 --> 01:01:58,160
um with that let me take some more

01:01:56,799 --> 01:02:01,359
questions if we have time

01:01:58,160 --> 01:02:02,799
and bonus slides you can see

01:02:01,359 --> 01:02:05,039
when the slides are published there will

01:02:02,799 --> 01:02:08,480
be a github repo with all of the slides

01:02:05,039 --> 01:02:09,039
um and i will hang out uh let's say in

01:02:08,480 --> 01:02:12,640
the uh

01:02:09,039 --> 01:02:16,400
hallway track um hallway track

01:02:12,640 --> 01:02:18,839
floor 10 come table one floor 10

01:02:16,400 --> 01:02:20,559
uh for for questions we don't get to

01:02:18,839 --> 01:02:23,920
here

01:02:20,559 --> 01:02:23,920
do we have any other questions

01:02:30,079 --> 01:02:34,000
um there's a question about the

01:02:32,319 --> 01:02:37,760
co-routines uh how will that change

01:02:34,000 --> 01:02:41,039
the way we use threads um i think

01:02:37,760 --> 01:02:43,440
that is probably out of scope

01:02:41,039 --> 01:02:44,880
um the short answer is i don't know i

01:02:43,440 --> 01:02:46,400
don't know that much about co routines

01:02:44,880 --> 01:02:48,559
and especially like i know some about

01:02:46,400 --> 01:02:50,559
generators the co-yield stuff

01:02:48,559 --> 01:02:52,240
about how co-await is going to end up

01:02:50,559 --> 01:02:53,680
working with red pools and other

01:02:52,240 --> 01:02:56,960
executors and other things that we don't

01:02:53,680 --> 01:03:01,039
have uh that is even further out of my

01:02:56,960 --> 01:03:03,119
area of expertise um

01:03:01,039 --> 01:03:04,720
someone asks would semaphores be the

01:03:03,119 --> 01:03:06,720
preferred synchronization mechanism

01:03:04,720 --> 01:03:08,480
going forward for producer consumer

01:03:06,720 --> 01:03:10,799
uh rather than a mutex condition

01:03:08,480 --> 01:03:14,160
variable could i use a semaphore

01:03:10,799 --> 01:03:16,720
um i yes i think i

01:03:14,160 --> 01:03:18,000
see how that would work would it be

01:03:16,720 --> 01:03:20,640
preferred

01:03:18,000 --> 01:03:22,160
it might be lighter weight um i might

01:03:20,640 --> 01:03:23,920
suspect that it would be lighter weight

01:03:22,160 --> 01:03:25,200
i certainly don't know

01:03:23,920 --> 01:03:27,119
in practice i have no you know

01:03:25,200 --> 01:03:29,680
benchmarks or anything

01:03:27,119 --> 01:03:31,359
but it's plausible to say that that if

01:03:29,680 --> 01:03:34,319
you had producer consume

01:03:31,359 --> 01:03:35,039
or you might marry some before there is

01:03:34,319 --> 01:03:36,400
a typedef

01:03:35,039 --> 01:03:38,960
in the semaphore header for binary

01:03:36,400 --> 01:03:40,000
semaphore um that just has a max of one

01:03:38,960 --> 01:03:41,680
and just goes up and down

01:03:40,000 --> 01:03:43,119
up and down is there data for me yes

01:03:41,680 --> 01:03:44,960
there is is there data for me yes there

01:03:43,119 --> 01:03:47,039
is um

01:03:44,960 --> 01:03:48,799
so yes that that might be appropriate if

01:03:47,039 --> 01:03:50,960
you're in 20.

01:03:48,799 --> 01:03:52,480
um will the bonus slides be available

01:03:50,960 --> 01:03:55,920
yes they will

01:03:52,480 --> 01:03:59,119
um all right

01:03:55,920 --> 01:04:00,559
um i think that is it thank you all for

01:03:59,119 --> 01:04:01,599
coming enjoy the back the basics track

01:04:00,559 --> 01:04:04,799
give me feedback

01:04:01,599 --> 01:04:06,400
um i also do training

01:04:04,799 --> 01:04:13,839
it's in the email thank you very much

01:04:06,400 --> 01:04:13,839
i've been art director

01:04:27,440 --> 01:04:29,520

YouTube URL: https://www.youtube.com/watch?v=F6Ipn7gCOsY


