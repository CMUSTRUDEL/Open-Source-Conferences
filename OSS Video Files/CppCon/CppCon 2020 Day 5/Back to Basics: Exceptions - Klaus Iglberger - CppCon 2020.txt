Title: Back to Basics: Exceptions - Klaus Iglberger - CppCon 2020
Publication date: 2020-10-04
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_exceptions/back_to_basics_exceptions__klaus_iglberger__cppcon_2020.pdf
---
Exceptions are the native error propagation mechanism in C++. If used properly, exceptions enable us to write simpler, more readable and more robust code. However, the path there can be tricky and unfortunately the exception mechanism isn't without flaws. This talk sheds somelight on the current issues with exceptions and why a large part of the C++ community isn't using them. It also gives guidelines and best practices on how to deal with exceptions and how touse them properly. It will go into detail about the exception safety guarantees, explains the tradeoffs between them, and demonstrates by example the individual steps necessary to reach them.

---
Klaus Iglberger is a freelancing C++ trainer and consultant. He has finished his PhD in computer science in 2010 and since then is focused on large-scale C++ software design. He shares his experience in popular advanced C++ courses around the world (mainly in Germany, but also the EU and US). Additionally, he is the initiator and lead designer of the Blaze C++ math library (https://bitbucket.org/blaze-lib/blaze/src/master/) and one of the organizers of the Munich C++ user group (https://www.meetup.com/MUCplusplus/).

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,480 --> 00:00:11,280
so

00:00:09,200 --> 00:00:12,960
a wonderful good morning good afternoon

00:00:11,280 --> 00:00:15,599
or good evening depending

00:00:12,960 --> 00:00:17,760
on wherever you are and welcome to yet

00:00:15,599 --> 00:00:19,359
another talk in the back to basics track

00:00:17,760 --> 00:00:20,960
so the back to basic strike is supposed

00:00:19,359 --> 00:00:23,920
to bring comprehensible

00:00:20,960 --> 00:00:25,359
easy to understand talks um and this one

00:00:23,920 --> 00:00:29,199
is no exception

00:00:25,359 --> 00:00:32,320
as it is about exceptions so allow me to

00:00:29,199 --> 00:00:33,840
first of all introduce myself my name is

00:00:32,320 --> 00:00:35,680
claus

00:00:33,840 --> 00:00:38,800
i'm doing sea glasses trainings for

00:00:35,680 --> 00:00:40,480
living since approximately 2016

00:00:38,800 --> 00:00:43,120
and apparently this is not even enough c

00:00:40,480 --> 00:00:45,280
plus plus for me i'm also the author of

00:00:43,120 --> 00:00:47,120
z plus a smart library called blaze and

00:00:45,280 --> 00:00:48,879
i'm one of the organizers of the munich

00:00:47,120 --> 00:00:50,800
c plus was user group

00:00:48,879 --> 00:00:52,399
which by the way since now everything

00:00:50,800 --> 00:00:55,440
has turned into virtual

00:00:52,399 --> 00:00:58,559
um maybe a pretty interesting point

00:00:55,440 --> 00:01:01,039
anyway munich seems to be one of the

00:00:58,559 --> 00:01:02,000
um most attractive most active user

00:01:01,039 --> 00:01:04,720
groups worldwide

00:01:02,000 --> 00:01:05,760
and since it's kind of in the middle of

00:01:04,720 --> 00:01:08,240
a lot of

00:01:05,760 --> 00:01:09,200
potential countries a lot of people can

00:01:08,240 --> 00:01:10,960
join so

00:01:09,200 --> 00:01:12,320
please check out the music c plus user

00:01:10,960 --> 00:01:14,799
group there might be a lot of content

00:01:12,320 --> 00:01:17,200
interesting for you

00:01:14,799 --> 00:01:19,200
however back to topic today we are

00:01:17,200 --> 00:01:21,200
talking about exceptions

00:01:19,200 --> 00:01:23,119
i want to start with the exception

00:01:21,200 --> 00:01:25,040
situation because i believe this is

00:01:23,119 --> 00:01:28,880
actually one of the most important most

00:01:25,040 --> 00:01:31,439
interesting um things to talk to about

00:01:28,880 --> 00:01:32,720
when you talk about exceptions then we

00:01:31,439 --> 00:01:35,759
do a short recap

00:01:32,720 --> 00:01:37,920
we talk about how do exceptions work

00:01:35,759 --> 00:01:39,600
and then we focus in depth on how to

00:01:37,920 --> 00:01:41,520
work with exceptions

00:01:39,600 --> 00:01:43,200
so best practices of the exceptions

00:01:41,520 --> 00:01:46,399
handling and

00:01:43,200 --> 00:01:48,159
we'll go into a lot of details here well

00:01:46,399 --> 00:01:50,079
let's get started with the exception

00:01:48,159 --> 00:01:53,040
situation

00:01:50,079 --> 00:01:56,479
and you indeed might wonder there is

00:01:53,040 --> 00:01:58,880
recently a lot of talks about exceptions

00:01:56,479 --> 00:02:00,399
for instance right in the uh time slot

00:01:58,880 --> 00:02:01,520
after this talk there isn't talk about

00:02:00,399 --> 00:02:03,600
exceptions

00:02:01,520 --> 00:02:05,600
and you might also remember that last

00:02:03,600 --> 00:02:09,520
year at cp con 2019

00:02:05,600 --> 00:02:11,520
there was a talk about exceptions also

00:02:09,520 --> 00:02:13,200
there is probably a reason that

00:02:11,520 --> 00:02:15,680
exceptions are pretty

00:02:13,200 --> 00:02:16,959
invoke nowadays and it probably all

00:02:15,680 --> 00:02:20,480
started with a

00:02:16,959 --> 00:02:22,239
paper from 2018 zero overhead

00:02:20,480 --> 00:02:25,680
deterministic exceptions

00:02:22,239 --> 00:02:27,040
throwing values herb sata proposed this

00:02:25,680 --> 00:02:29,360
in 2018

00:02:27,040 --> 00:02:30,720
this is the fourth revision therefore

00:02:29,360 --> 00:02:32,000
00:02:30,720 --> 00:02:33,920
and there's a couple of pretty

00:02:32,000 --> 00:02:36,000
interesting points that he makes so

00:02:33,920 --> 00:02:37,280
scroll down a little bit and go to a

00:02:36,000 --> 00:02:41,280
couple of

00:02:37,280 --> 00:02:44,000
bullet points major coding guidelines

00:02:41,280 --> 00:02:46,000
ban exceptions including common modern

00:02:44,000 --> 00:02:48,239
guidelines endorsed by the world's top

00:02:46,000 --> 00:02:50,720
advocates of c plus with exceptions

00:02:48,239 --> 00:02:52,640
for example the google c plus plus style

00:02:50,720 --> 00:02:54,879
guide spans exceptions

00:02:52,640 --> 00:02:56,080
the joint strike fighter air vehicle c

00:02:54,879 --> 00:02:58,800
plus coding standards

00:02:56,080 --> 00:02:59,519
short jsf plus plus was produced by

00:02:58,800 --> 00:03:01,840
group

00:02:59,519 --> 00:03:03,680
that included biannual street strip and

00:03:01,840 --> 00:03:04,640
is published on producers personal

00:03:03,680 --> 00:03:07,760
webpage

00:03:04,640 --> 00:03:10,800
and bans exceptions

00:03:07,760 --> 00:03:14,720
many project spam exceptions

00:03:10,800 --> 00:03:16,640
in some survey in 2018 52 percent of c

00:03:14,720 --> 00:03:19,360
plus developers reported that

00:03:16,640 --> 00:03:20,959
exceptions were banned in part or all of

00:03:19,360 --> 00:03:23,519
their project code

00:03:20,959 --> 00:03:25,360
i.e most are not allowed to freely use c

00:03:23,519 --> 00:03:26,159
plus versus primary recommended error

00:03:25,360 --> 00:03:27,760
handling model

00:03:26,159 --> 00:03:30,480
that is required to use the c plus with

00:03:27,760 --> 00:03:33,040
standard language and library

00:03:30,480 --> 00:03:33,599
so it's kind of in between summary this

00:03:33,040 --> 00:03:36,480
is an

00:03:33,599 --> 00:03:37,120
intolerable rift large numbers of c plus

00:03:36,480 --> 00:03:39,599
projects

00:03:37,120 --> 00:03:41,680
are not actually using standard c plus

00:03:39,599 --> 00:03:44,560
plus

00:03:41,680 --> 00:03:45,120
and that is indeed the situation a lot

00:03:44,560 --> 00:03:47,519
of people

00:03:45,120 --> 00:03:49,519
cannot use them do not want to use them

00:03:47,519 --> 00:03:52,000
for various reasons

00:03:49,519 --> 00:03:52,879
and that despite the fact that

00:03:52,000 --> 00:03:56,560
exceptions are

00:03:52,879 --> 00:03:58,720
actually rated pretty a pretty decent

00:03:56,560 --> 00:04:02,319
way to report errors

00:03:58,720 --> 00:04:05,280
proper gate errors for instance in 2018

00:04:02,319 --> 00:04:06,640
phil nash and simon brandt um compared

00:04:05,280 --> 00:04:08,560
different ways to

00:04:06,640 --> 00:04:10,720
deal with errors and it pretty much

00:04:08,560 --> 00:04:13,680
compared everything that is available

00:04:10,720 --> 00:04:14,239
return codes but also there are flagging

00:04:13,680 --> 00:04:16,239
also

00:04:14,239 --> 00:04:17,919
a couple of things but also of course

00:04:16,239 --> 00:04:20,239
exceptions

00:04:17,919 --> 00:04:21,199
and i rated them based on these eight

00:04:20,239 --> 00:04:23,919
categories

00:04:21,199 --> 00:04:24,560
and found that after all exceptions are

00:04:23,919 --> 00:04:26,720
not

00:04:24,560 --> 00:04:29,600
totally bad there is a couple of things

00:04:26,720 --> 00:04:32,400
where they're really shine

00:04:29,600 --> 00:04:34,960
however there is of course also a couple

00:04:32,400 --> 00:04:36,960
of things where exceptions do not shine

00:04:34,960 --> 00:04:38,160
one of the most obvious things here is

00:04:36,960 --> 00:04:40,560
the rating of one

00:04:38,160 --> 00:04:42,400
uh for overhead in the era path that

00:04:40,560 --> 00:04:45,680
definitely is one of the things that

00:04:42,400 --> 00:04:48,160
people do not like about exceptions

00:04:45,680 --> 00:04:50,720
exceptions incur an extreme performance

00:04:48,160 --> 00:04:53,280
overhead in the failure case

00:04:50,720 --> 00:04:54,880
to give you an idea how big this um this

00:04:53,280 --> 00:04:57,520
performance penalty is

00:04:54,880 --> 00:04:58,320
i'm boring a slide from um neil

00:04:57,520 --> 00:05:00,960
douglas's

00:04:58,320 --> 00:05:03,919
uh introduction to proposed expected

00:05:00,960 --> 00:05:06,960
from meeting c plus plus 2017.

00:05:03,919 --> 00:05:08,639
in his talk he presents this light

00:05:06,960 --> 00:05:10,720
which i don't want to go into detail

00:05:08,639 --> 00:05:11,840
it's not so interesting what exactly is

00:05:10,720 --> 00:05:14,160
compared here

00:05:11,840 --> 00:05:16,560
but there's a couple of things that

00:05:14,160 --> 00:05:18,639
apparently have low bars

00:05:16,560 --> 00:05:21,120
and there is exceptions these yellow

00:05:18,639 --> 00:05:22,160
bars the most important detail about

00:05:21,120 --> 00:05:26,160
this slide i believe

00:05:22,160 --> 00:05:26,160
is the left-hand side

00:05:27,600 --> 00:05:34,479
axis it is a logarithmic scale

00:05:31,759 --> 00:05:36,080
logarithmic means that exceptions if

00:05:34,479 --> 00:05:38,720
they are truly thrown

00:05:36,080 --> 00:05:39,919
are orders of magnitude more expensive

00:05:38,720 --> 00:05:41,919
than anything else

00:05:39,919 --> 00:05:43,280
now return codes returning expected

00:05:41,919 --> 00:05:45,759
things

00:05:43,280 --> 00:05:47,440
orders of magnitude more expensive and

00:05:45,759 --> 00:05:48,320
of course this can be a significant

00:05:47,440 --> 00:05:52,560
problem

00:05:48,320 --> 00:05:53,039
in many project situations this is not

00:05:52,560 --> 00:05:56,240
it

00:05:53,039 --> 00:05:56,960
there's more unfortunately there's one

00:05:56,240 --> 00:05:58,800
point that

00:05:56,960 --> 00:06:00,720
is always brought up that is it that

00:05:58,800 --> 00:06:02,319
exceptions make it hard to reason about

00:06:00,720 --> 00:06:04,240
functions

00:06:02,319 --> 00:06:05,759
does a function throw or does it not

00:06:04,240 --> 00:06:07,360
throw and if it does throw

00:06:05,759 --> 00:06:09,120
what does it throw so which kind of

00:06:07,360 --> 00:06:10,720
exception of throne

00:06:09,120 --> 00:06:13,440
that is indeed something that is a

00:06:10,720 --> 00:06:15,039
little harder to um to deal with

00:06:13,440 --> 00:06:16,639
there's only one exception that we'll

00:06:15,039 --> 00:06:18,880
also take a look

00:06:16,639 --> 00:06:20,800
at a little later of course you can

00:06:18,880 --> 00:06:22,880
declare a function no except

00:06:20,800 --> 00:06:24,000
but that's the one exception i know it

00:06:22,880 --> 00:06:25,600
will not throw

00:06:24,000 --> 00:06:27,520
but about all the other things i still

00:06:25,600 --> 00:06:30,400
have to wonder

00:06:27,520 --> 00:06:32,000
something that also deals is a deal

00:06:30,400 --> 00:06:33,759
breaker for many people

00:06:32,000 --> 00:06:35,759
is except that exceptions rely on

00:06:33,759 --> 00:06:38,479
dynamic memory

00:06:35,759 --> 00:06:40,160
that indeed can be a deal breaker

00:06:38,479 --> 00:06:43,440
especially in the situations we are not

00:06:40,160 --> 00:06:44,160
allowed to use dynamic memory exceptions

00:06:43,440 --> 00:06:47,360
need that

00:06:44,160 --> 00:06:49,520
because as a matter of fact sometimes

00:06:47,360 --> 00:06:51,520
several exceptions might be required

00:06:49,520 --> 00:06:53,919
and all of these exceptions might

00:06:51,520 --> 00:06:56,160
actually have to allocate something of a

00:06:53,919 --> 00:06:57,840
dynamic size something that is not known

00:06:56,160 --> 00:07:00,720
beforehand

00:06:57,840 --> 00:07:02,000
that is of course something that

00:07:00,720 --> 00:07:05,280
potentially makes a big

00:07:02,000 --> 00:07:08,639
problem and then last but not least

00:07:05,280 --> 00:07:10,800
exceptions make the binary size grow

00:07:08,639 --> 00:07:12,479
both common approaches so called frame

00:07:10,800 --> 00:07:13,759
based and the so-called table based

00:07:12,479 --> 00:07:17,520
approach

00:07:13,759 --> 00:07:19,680
result in increased binary size

00:07:17,520 --> 00:07:22,880
the compiler stores some information

00:07:19,680 --> 00:07:25,280
somewhere that helps with dispatching

00:07:22,880 --> 00:07:26,479
the right kind of handling so it's some

00:07:25,280 --> 00:07:29,520
kind of

00:07:26,479 --> 00:07:31,280
dispatch tables where is the right catch

00:07:29,520 --> 00:07:33,680
handler for instance

00:07:31,280 --> 00:07:35,520
they're not for free and so they have to

00:07:33,680 --> 00:07:36,800
be stored somewhere the binary size

00:07:35,520 --> 00:07:38,800
grows

00:07:36,800 --> 00:07:40,000
so in other words this is not zero

00:07:38,800 --> 00:07:42,319
overhead

00:07:40,000 --> 00:07:45,440
there is something that you pay um when

00:07:42,319 --> 00:07:48,479
you use exceptions

00:07:45,440 --> 00:07:48,879
however all of these problems hopefully

00:07:48,479 --> 00:07:51,360
will

00:07:48,879 --> 00:07:52,080
go away if indeed there is this major

00:07:51,360 --> 00:07:56,479
overhaul

00:07:52,080 --> 00:07:57,759
that is proposed in this paper i have to

00:07:56,479 --> 00:08:00,000
tell you that this is not the only

00:07:57,759 --> 00:08:00,560
approach but now there is a couple of

00:08:00,000 --> 00:08:02,960
papers

00:08:00,560 --> 00:08:04,800
um out there that basically try to

00:08:02,960 --> 00:08:06,560
figure out what is the right approach

00:08:04,800 --> 00:08:07,840
but in other words there is happening

00:08:06,560 --> 00:08:10,400
something

00:08:07,840 --> 00:08:11,120
something is on the horizon and if all

00:08:10,400 --> 00:08:14,639
of the things

00:08:11,120 --> 00:08:16,720
work out as anticipated then potentially

00:08:14,639 --> 00:08:17,919
and this is one of the last messages

00:08:16,720 --> 00:08:21,039
that was given in the

00:08:17,919 --> 00:08:24,000
already mentioned talk exceptions

00:08:21,039 --> 00:08:24,879
could actually become something that is

00:08:24,000 --> 00:08:27,440
very very

00:08:24,879 --> 00:08:29,599
good now almost flawless in terms of

00:08:27,440 --> 00:08:32,159
these numbers here

00:08:29,599 --> 00:08:32,959
so of course this is a pretty hot topic

00:08:32,159 --> 00:08:35,519
nowadays

00:08:32,959 --> 00:08:36,080
and something that steers a lot of

00:08:35,519 --> 00:08:38,719
interest

00:08:36,080 --> 00:08:40,240
because suddenly on the horizon

00:08:38,719 --> 00:08:42,000
exceptions might actually be something

00:08:40,240 --> 00:08:43,200
that in all those projects that today

00:08:42,000 --> 00:08:46,320
cannot use them

00:08:43,200 --> 00:08:47,279
um might be able to use so our ultimate

00:08:46,320 --> 00:08:52,320
goal is

00:08:47,279 --> 00:08:52,320
to make exceptions usable for everyone

00:08:52,959 --> 00:08:56,320
this is one part of the story the

00:08:55,200 --> 00:08:57,920
technical thing

00:08:56,320 --> 00:08:59,839
making exceptions used for ephraim

00:08:57,920 --> 00:09:01,120
technically this is something that you

00:08:59,839 --> 00:09:03,440
will hear about a little more

00:09:01,120 --> 00:09:05,200
in the talk directly after this slot so

00:09:03,440 --> 00:09:06,839
um in the next time slot involved we

00:09:05,200 --> 00:09:08,560
will talk about exceptions under the

00:09:06,839 --> 00:09:11,680
spotlight

00:09:08,560 --> 00:09:13,760
this talk is more about teaching how to

00:09:11,680 --> 00:09:17,200
work with exceptions properly

00:09:13,760 --> 00:09:20,160
and implicitly how to just write good

00:09:17,200 --> 00:09:21,440
code because ultimately this is what

00:09:20,160 --> 00:09:23,040
exceptions teaches

00:09:21,440 --> 00:09:24,560
good code works pretty well with

00:09:23,040 --> 00:09:27,040
exceptions

00:09:24,560 --> 00:09:27,600
other code does not and so perhaps for

00:09:27,040 --> 00:09:30,880
this

00:09:27,600 --> 00:09:32,480
talk i want to actually try something

00:09:30,880 --> 00:09:34,240
perhaps like it works out perhaps it

00:09:32,480 --> 00:09:36,320
does not because

00:09:34,240 --> 00:09:37,839
it appears that this is a talk for two

00:09:36,320 --> 00:09:40,240
different kinds of communities

00:09:37,839 --> 00:09:42,399
the community that can use exceptions

00:09:40,240 --> 00:09:44,880
and the other part of the community

00:09:42,399 --> 00:09:47,279
almost half half that cannot use

00:09:44,880 --> 00:09:48,959
exceptions

00:09:47,279 --> 00:09:51,360
for this talk i will try to perhaps

00:09:48,959 --> 00:09:53,839
bring these two communities together

00:09:51,360 --> 00:09:55,200
and primarily i want to focus on how to

00:09:53,839 --> 00:09:57,680
write good code

00:09:55,200 --> 00:09:59,040
that can also deal with exceptions well

00:09:57,680 --> 00:10:01,440
but

00:09:59,040 --> 00:10:04,560
of course is also good from a lot of

00:10:01,440 --> 00:10:07,360
other points of view

00:10:04,560 --> 00:10:07,760
all right so let's do a quick recap on

00:10:07,360 --> 00:10:09,920
how

00:10:07,760 --> 00:10:10,880
exceptions actually work there's a

00:10:09,920 --> 00:10:14,240
couple of uh

00:10:10,880 --> 00:10:16,480
important um things that you should

00:10:14,240 --> 00:10:18,079
always keep in mind

00:10:16,480 --> 00:10:20,000
the first thing is that exceptions

00:10:18,079 --> 00:10:23,040
usually have to do with three keywords

00:10:20,000 --> 00:10:23,920
and that is throw which is here for

00:10:23,040 --> 00:10:26,480
instance

00:10:23,920 --> 00:10:28,160
try and catch so in this little example

00:10:26,480 --> 00:10:29,839
i have a function f

00:10:28,160 --> 00:10:31,360
that may have some local variables and

00:10:29,839 --> 00:10:32,720
that under some condition throws an

00:10:31,360 --> 00:10:34,720
exception

00:10:32,720 --> 00:10:36,000
this function f is called from sound

00:10:34,720 --> 00:10:39,760
function g

00:10:36,000 --> 00:10:41,680
that also might have some local state

00:10:39,760 --> 00:10:43,680
and which is ultimately called by main

00:10:41,680 --> 00:10:45,120
function which embeds this colon strike

00:10:43,680 --> 00:10:46,720
catch block

00:10:45,120 --> 00:10:49,040
so one thing that is pretty obvious is

00:10:46,720 --> 00:10:50,079
the throne catch are pretty far away

00:10:49,040 --> 00:10:52,640
from each other

00:10:50,079 --> 00:10:53,839
at some point you actually find

00:10:52,640 --> 00:10:56,320
something wrong

00:10:53,839 --> 00:10:57,839
report this era and at some completely

00:10:56,320 --> 00:11:00,000
different point

00:10:57,839 --> 00:11:02,399
potentially pretty far away you actually

00:11:00,000 --> 00:11:04,560
deal with this particular problem

00:11:02,399 --> 00:11:06,480
which may be actually a beauty about

00:11:04,560 --> 00:11:07,839
exceptions you do not see something in

00:11:06,480 --> 00:11:10,160
between

00:11:07,839 --> 00:11:11,040
in between it is just as if everything

00:11:10,160 --> 00:11:14,079
would work out

00:11:11,040 --> 00:11:17,279
now so here in g i just call a function

00:11:14,079 --> 00:11:21,040
and i just rely on the fact that things

00:11:17,279 --> 00:11:22,800
are handled because if if in fact an

00:11:21,040 --> 00:11:25,600
exception is thrown

00:11:22,800 --> 00:11:28,399
then something pretty good happens

00:11:25,600 --> 00:11:30,640
something called stack unwinding

00:11:28,399 --> 00:11:32,160
function f has some local state the

00:11:30,640 --> 00:11:34,480
string s

00:11:32,160 --> 00:11:35,200
and the first thing that happens is that

00:11:34,480 --> 00:11:37,519
this s

00:11:35,200 --> 00:11:38,240
is properly destroyed by its own

00:11:37,519 --> 00:11:42,720
destructor

00:11:38,240 --> 00:11:45,279
before i go back to the actual call site

00:11:42,720 --> 00:11:46,160
function g also has some local state the

00:11:45,279 --> 00:11:49,120
vector v

00:11:46,160 --> 00:11:49,839
which is then destroyed next before i

00:11:49,120 --> 00:11:53,360
again go

00:11:49,839 --> 00:11:54,959
to the actual call site so note objects

00:11:53,360 --> 00:11:57,120
are destroyed in reverse

00:11:54,959 --> 00:11:58,320
order of the construction financially

00:11:57,120 --> 00:12:01,040
because this is

00:11:58,320 --> 00:12:02,160
um exactly what what needs to happen if

00:12:01,040 --> 00:12:06,480
i basically

00:12:02,160 --> 00:12:08,240
jump up or go up the call stack

00:12:06,480 --> 00:12:09,600
and finally in the dry catch block the

00:12:08,240 --> 00:12:13,519
exceptions card

00:12:09,600 --> 00:12:16,000
and handled however the stack unwinding

00:12:13,519 --> 00:12:17,279
is not something that you can take for

00:12:16,000 --> 00:12:22,480
granted

00:12:17,279 --> 00:12:22,480
if you would omit the try catch block

00:12:22,639 --> 00:12:26,240
then nothing keeps the exception nothing

00:12:24,800 --> 00:12:27,920
catches the exception the exception

00:12:26,240 --> 00:12:31,519
would leave the main function

00:12:27,920 --> 00:12:32,880
in case that happens the exception is

00:12:31,519 --> 00:12:35,519
not handled and no

00:12:32,880 --> 00:12:37,839
stack unwinding occurs on the contrary a

00:12:35,519 --> 00:12:39,760
function calls to terminate is called

00:12:37,839 --> 00:12:41,360
and so terminate is a function that is

00:12:39,760 --> 00:12:42,959
not particularly pleasant

00:12:41,360 --> 00:12:45,440
it basically just terminates your

00:12:42,959 --> 00:12:47,040
process and as i said a lot of things do

00:12:45,440 --> 00:12:48,959
not happen no stack unwinding

00:12:47,040 --> 00:12:51,680
no destructors are called and so

00:12:48,959 --> 00:12:53,920
resources upon potentially leaked

00:12:51,680 --> 00:12:56,160
so it is definitely reasonable to at

00:12:53,920 --> 00:12:58,240
least catch exceptions somehow

00:12:56,160 --> 00:12:59,200
and if you don't want to react to them

00:12:58,240 --> 00:13:01,040
in any way

00:12:59,200 --> 00:13:03,519
a so-called catch-all handler might do

00:13:01,040 --> 00:13:06,399
the trick a catch-all handler is

00:13:03,519 --> 00:13:08,000
just about catching anything you cannot

00:13:06,399 --> 00:13:08,720
deal with this very specifically at this

00:13:08,000 --> 00:13:11,760
point

00:13:08,720 --> 00:13:15,040
but at least you guarantee that the

00:13:11,760 --> 00:13:15,040
stick is probably unwound

00:13:16,160 --> 00:13:19,279
so at this time you might already have a

00:13:17,680 --> 00:13:21,519
couple of questions

00:13:19,279 --> 00:13:23,680
since there is directly after this talk

00:13:21,519 --> 00:13:26,320
a subsequent ama session

00:13:23,680 --> 00:13:27,920
i will take all the questions at the end

00:13:26,320 --> 00:13:30,320
so if you have a couple of questions

00:13:27,920 --> 00:13:31,920
please write them down and do not forget

00:13:30,320 --> 00:13:35,360
to use the slide numbers this definitely

00:13:31,920 --> 00:13:38,480
helps in finding the right slide again

00:13:35,360 --> 00:13:39,360
which brings us to the biggest part in

00:13:38,480 --> 00:13:42,000
this talk

00:13:39,360 --> 00:13:43,600
best practices of exception handling and

00:13:42,000 --> 00:13:44,160
the first question that people usually

00:13:43,600 --> 00:13:47,279
deal with

00:13:44,160 --> 00:13:49,360
is when should i use exceptions and are

00:13:47,279 --> 00:13:50,880
not of course assuming that you're

00:13:49,360 --> 00:13:53,199
allowed to use exceptions in the first

00:13:50,880 --> 00:13:53,199
place

00:13:53,519 --> 00:13:58,639
so to summarize use exceptions

00:13:56,800 --> 00:14:00,959
for errors that are expected to occur

00:13:58,639 --> 00:14:03,199
rarely you've just seen that

00:14:00,959 --> 00:14:04,079
in the error case the performance

00:14:03,199 --> 00:14:06,880
penalty is

00:14:04,079 --> 00:14:07,600
pretty high so i would not use

00:14:06,880 --> 00:14:09,920
exceptions

00:14:07,600 --> 00:14:11,839
for something that occurs pretty often

00:14:09,920 --> 00:14:14,839
use exceptions for the cases that are

00:14:11,839 --> 00:14:18,000
truly exceptional that are careerly

00:14:14,839 --> 00:14:19,360
um and probably also in which cases you

00:14:18,000 --> 00:14:22,160
do not really care about

00:14:19,360 --> 00:14:24,800
performance anymore not the really the

00:14:22,160 --> 00:14:26,959
real problems

00:14:24,800 --> 00:14:29,120
then use them for the exceptional cases

00:14:26,959 --> 00:14:31,519
that they cannot deal with locally

00:14:29,120 --> 00:14:32,560
so for instance uh cases like file not

00:14:31,519 --> 00:14:34,000
found

00:14:32,560 --> 00:14:35,920
you have no idea what to do if a

00:14:34,000 --> 00:14:38,079
specific file is not found probably you

00:14:35,920 --> 00:14:40,959
have to communicate this upwards

00:14:38,079 --> 00:14:41,839
to point where you can go to some backup

00:14:40,959 --> 00:14:44,240
strategy

00:14:41,839 --> 00:14:45,279
or you cannot find a killer map although

00:14:44,240 --> 00:14:47,199
this would some

00:14:45,279 --> 00:14:49,760
was something that you were absolutely

00:14:47,199 --> 00:14:49,760
expecting

00:14:49,920 --> 00:14:53,600
the news exceptions for operators and

00:14:52,320 --> 00:14:55,360
constructors

00:14:53,600 --> 00:14:57,040
operators for instance like operator

00:14:55,360 --> 00:14:59,120
plus operator minus

00:14:57,040 --> 00:15:00,320
so the things that have a natural return

00:14:59,120 --> 00:15:02,079
value

00:15:00,320 --> 00:15:03,839
and it does not really allow you to

00:15:02,079 --> 00:15:05,839
return anything else

00:15:03,839 --> 00:15:07,040
constructors on the other side cannot

00:15:05,839 --> 00:15:08,959
return anything

00:15:07,040 --> 00:15:11,040
so this is two examples where it's quite

00:15:08,959 --> 00:15:13,920
natural to use exceptions

00:15:11,040 --> 00:15:14,959
they provide a different exit point from

00:15:13,920 --> 00:15:17,120
these functions

00:15:14,959 --> 00:15:19,600
and so you do not have don't need any

00:15:17,120 --> 00:15:21,839
kind of return value

00:15:19,600 --> 00:15:23,040
now of course if you cannot use

00:15:21,839 --> 00:15:25,440
exceptions

00:15:23,040 --> 00:15:28,320
this is usually a problem operators

00:15:25,440 --> 00:15:30,880
constructors they usually pose a problem

00:15:28,320 --> 00:15:32,720
there may be solutions to that also for

00:15:30,880 --> 00:15:34,560
that case in case you're interested to

00:15:32,720 --> 00:15:37,680
deal with constructors

00:15:34,560 --> 00:15:38,160
in a convenient way i would refer you to

00:15:37,680 --> 00:15:40,240
this

00:15:38,160 --> 00:15:41,680
short lightning talk fixing two-phase

00:15:40,240 --> 00:15:44,000
initialization

00:15:41,680 --> 00:15:45,519
dupage initialization is what is usually

00:15:44,000 --> 00:15:47,279
done in that case

00:15:45,519 --> 00:15:49,519
but if you do it right you actually can

00:15:47,279 --> 00:15:52,480
cope with the problem pretty nicely

00:15:49,519 --> 00:15:52,480
pretty naturally

00:15:53,040 --> 00:15:58,560
however you should not use exceptions

00:15:56,480 --> 00:16:00,000
for errors that are expected to occur

00:15:58,560 --> 00:16:03,600
frequently

00:16:00,000 --> 00:16:06,079
so if indeed something um

00:16:03,600 --> 00:16:08,240
yeah it happens very very often perhaps

00:16:06,079 --> 00:16:10,880
there's a better way to report

00:16:08,240 --> 00:16:12,320
that something happened that may for

00:16:10,880 --> 00:16:13,920
instance be for functions that are

00:16:12,320 --> 00:16:16,639
expected to fail

00:16:13,920 --> 00:16:18,560
so for instance a function that is

00:16:16,639 --> 00:16:21,199
supposed to convert a string

00:16:18,560 --> 00:16:25,519
into an int let's call this function to

00:16:21,199 --> 00:16:25,519
int it gets a string as a parameter

00:16:26,000 --> 00:16:30,079
it is kind of expected that the string

00:16:27,839 --> 00:16:32,000
here cannot be converted

00:16:30,079 --> 00:16:33,759
so perhaps this is an example where i

00:16:32,000 --> 00:16:35,839
simply do not throw an exception

00:16:33,759 --> 00:16:38,800
to notify the user that something went

00:16:35,839 --> 00:16:41,040
wrong but to perhaps return an optional

00:16:38,800 --> 00:16:43,199
in the case that something didn't work

00:16:41,040 --> 00:16:46,480
the optional is returned as a nod

00:16:43,199 --> 00:16:47,199
else you just return the according

00:16:46,480 --> 00:16:49,519
number

00:16:47,199 --> 00:16:50,720
that's quite natural although of course

00:16:49,519 --> 00:16:54,079
an optional does not really

00:16:50,720 --> 00:16:54,560
express some bad thing happened for this

00:16:54,079 --> 00:16:57,440
reason

00:16:54,560 --> 00:16:57,759
stood expected was proposed which is a

00:16:57,440 --> 00:17:00,079
little

00:16:57,759 --> 00:17:00,880
closer to the actual thing either you

00:17:00,079 --> 00:17:03,519
get an int

00:17:00,880 --> 00:17:04,240
or something that represents an era so

00:17:03,519 --> 00:17:06,959
it's a little

00:17:04,240 --> 00:17:09,120
closer a little more specific but

00:17:06,959 --> 00:17:12,319
unfortunately to expect it was not

00:17:09,120 --> 00:17:13,919
um standardized yet so it's not part of

00:17:12,319 --> 00:17:17,039
c plus 20.

00:17:13,919 --> 00:17:19,439
um perhaps an alternative is

00:17:17,039 --> 00:17:20,079
to rely on the original the boost

00:17:19,439 --> 00:17:22,160
outcome

00:17:20,079 --> 00:17:24,799
which is kind of the predecessor of

00:17:22,160 --> 00:17:27,439
standard expected

00:17:24,799 --> 00:17:29,200
so if you write this function like that

00:17:27,439 --> 00:17:32,960
it's i believe a little easier to

00:17:29,200 --> 00:17:34,480
ex to comprehend because it does not

00:17:32,960 --> 00:17:36,480
if the function does not pretend that

00:17:34,480 --> 00:17:40,320
all strings can be converted into an it

00:17:36,480 --> 00:17:40,320
it's a little easier to deal with this

00:17:40,960 --> 00:17:45,600
then don't use exceptions if you indeed

00:17:43,360 --> 00:17:48,559
have to guarantee certain response times

00:17:45,600 --> 00:17:50,320
even in the error case in that case

00:17:48,559 --> 00:17:50,960
exceptions are truly a bad thing to work

00:17:50,320 --> 00:17:53,520
with

00:17:50,960 --> 00:17:55,840
because unfortunately this this response

00:17:53,520 --> 00:17:58,320
time it feels a little bit unbounded

00:17:55,840 --> 00:18:00,160
of course you might measure explicitly

00:17:58,320 --> 00:18:01,840
find that it still works

00:18:00,160 --> 00:18:03,760
but i would argue there is a certain

00:18:01,840 --> 00:18:05,360
risk this is exactly one of the things

00:18:03,760 --> 00:18:08,400
that needs to be repaired

00:18:05,360 --> 00:18:09,919
um it's mostly about the implementation

00:18:08,400 --> 00:18:12,080
of the compilers and so

00:18:09,919 --> 00:18:14,480
there can be something done it just

00:18:12,080 --> 00:18:15,039
might take a little time and last but

00:18:14,480 --> 00:18:17,679
not least

00:18:15,039 --> 00:18:18,240
do not use exceptions for things that

00:18:17,679 --> 00:18:20,160
should

00:18:18,240 --> 00:18:22,160
never happen like dereferencing null

00:18:20,160 --> 00:18:25,600
pointers out of range access

00:18:22,160 --> 00:18:28,320
use after free this is not exceptions

00:18:25,600 --> 00:18:29,039
areas this is bugs bugs that you should

00:18:28,320 --> 00:18:31,120
fix

00:18:29,039 --> 00:18:32,240
um this is something that you might uh

00:18:31,120 --> 00:18:34,640
simply report when

00:18:32,240 --> 00:18:37,039
a search crash right away and it should

00:18:34,640 --> 00:18:40,480
be fixed before it goes to the customer

00:18:37,039 --> 00:18:42,720
um or of course um you you find other

00:18:40,480 --> 00:18:44,880
ways to deal with this

00:18:42,720 --> 00:18:47,760
this is not exceptional cases this is

00:18:44,880 --> 00:18:50,400
just plain bugs

00:18:47,760 --> 00:18:52,400
all right again note only questions i

00:18:50,400 --> 00:18:56,160
will take all of them in the end

00:18:52,400 --> 00:19:00,320
so please keep them coming

00:18:56,160 --> 00:19:03,200
deal with how to use exceptions properly

00:19:00,320 --> 00:19:05,039
and there's a couple of reasonable um

00:19:03,200 --> 00:19:07,120
common advice that you get when you deal

00:19:05,039 --> 00:19:09,919
with exceptions

00:19:07,120 --> 00:19:11,919
the first thing is that you should build

00:19:09,919 --> 00:19:14,640
on the already existing hierarchy in the

00:19:11,919 --> 00:19:17,440
standard library the exception hierarchy

00:19:14,640 --> 00:19:18,160
standard exception is designed as a base

00:19:17,440 --> 00:19:19,679
class

00:19:18,160 --> 00:19:21,520
and this light is something that you

00:19:19,679 --> 00:19:22,480
don't have to read just should give you

00:19:21,520 --> 00:19:24,559
a feeling of

00:19:22,480 --> 00:19:26,480
there is already quite a lot of

00:19:24,559 --> 00:19:29,200
possibilities that you have

00:19:26,480 --> 00:19:30,559
so stood exception is in the center and

00:19:29,200 --> 00:19:32,799
this is a base class for

00:19:30,559 --> 00:19:34,799
for instance logic error and runtime era

00:19:32,799 --> 00:19:37,120
which on their own are again

00:19:34,799 --> 00:19:39,440
base classes to a lot of much more

00:19:37,120 --> 00:19:41,679
specific errors

00:19:39,440 --> 00:19:43,520
i believe you will find a spot where

00:19:41,679 --> 00:19:45,600
your particular your special kind of

00:19:43,520 --> 00:19:47,840
exception fits in quite well

00:19:45,600 --> 00:19:50,000
and so you can build on this exception

00:19:47,840 --> 00:19:51,679
hierarchy

00:19:50,000 --> 00:19:53,120
standard exception is also the one base

00:19:51,679 --> 00:19:53,919
class in the standard library that you

00:19:53,120 --> 00:19:55,520
need to know

00:19:53,919 --> 00:19:57,840
everything else is probably something

00:19:55,520 --> 00:19:59,760
that will only in rare cases visit

00:19:57,840 --> 00:20:01,919
but this is the one based class that is

00:19:59,760 --> 00:20:02,240
indeed interesting that you are supposed

00:20:01,919 --> 00:20:05,520
to

00:20:02,240 --> 00:20:08,720
inherit from then

00:20:05,520 --> 00:20:11,120
throw by r value

00:20:08,720 --> 00:20:13,120
which means you can throw arbitrary

00:20:11,120 --> 00:20:15,120
things you can even throw pointers

00:20:13,120 --> 00:20:16,720
um you can even throw reference

00:20:15,120 --> 00:20:19,039
references but this is not a

00:20:16,720 --> 00:20:22,000
particularly good idea

00:20:19,039 --> 00:20:22,559
the good recent convention is that you

00:20:22,000 --> 00:20:26,000
throw

00:20:22,559 --> 00:20:26,880
something directly by value in this case

00:20:26,000 --> 00:20:29,200
i'm doing that

00:20:26,880 --> 00:20:30,240
i'm creating runtime error which can

00:20:29,200 --> 00:20:32,960
even be const

00:20:30,240 --> 00:20:35,039
i give it some message and i throw it

00:20:32,960 --> 00:20:37,120
but why give it a name

00:20:35,039 --> 00:20:38,320
there is not a lot of point perhaps

00:20:37,120 --> 00:20:40,799
there are special cases

00:20:38,320 --> 00:20:42,240
but in this particular case the common

00:20:40,799 --> 00:20:43,200
advice is just to throw the thing

00:20:42,240 --> 00:20:46,559
directly

00:20:43,200 --> 00:20:48,159
throws the runtime error so i do not

00:20:46,559 --> 00:20:49,679
throw something that has a name i do

00:20:48,159 --> 00:20:50,400
throw something that does not have a

00:20:49,679 --> 00:20:52,960
name

00:20:50,400 --> 00:20:54,480
that would be an r value that of course

00:20:52,960 --> 00:20:56,240
enables the compiler to

00:20:54,480 --> 00:20:58,320
um to deal with this a little more

00:20:56,240 --> 00:20:59,039
efficiently although as we've seen

00:20:58,320 --> 00:21:01,280
before

00:20:59,039 --> 00:21:03,520
the performance of throw might be so bad

00:21:01,280 --> 00:21:05,760
that you do not really benefit from this

00:21:03,520 --> 00:21:08,480
particular

00:21:05,760 --> 00:21:10,799
optimization but still it's reasonable

00:21:08,480 --> 00:21:12,960
advice

00:21:10,799 --> 00:21:15,360
and last but not least catch by

00:21:12,960 --> 00:21:18,320
reference

00:21:15,360 --> 00:21:20,799
you can catch by a lot of things you can

00:21:18,320 --> 00:21:22,640
for instance also catch by value

00:21:20,799 --> 00:21:25,039
to some extent the catch class works

00:21:22,640 --> 00:21:28,159
indeed like functions argument do

00:21:25,039 --> 00:21:30,880
in this case i now catch by value

00:21:28,159 --> 00:21:31,679
get something by value but as if we've

00:21:30,880 --> 00:21:34,880
seen is

00:21:31,679 --> 00:21:36,720
that standard exception is a base class

00:21:34,880 --> 00:21:39,360
and of course there is a couple of

00:21:36,720 --> 00:21:42,840
disadvantages if you catch a base class

00:21:39,360 --> 00:21:44,000
by value first creates an unnecessary

00:21:42,840 --> 00:21:45,840
copy

00:21:44,000 --> 00:21:47,840
which since it's the base class might

00:21:45,840 --> 00:21:49,760
not be too bad but definitely bad

00:21:47,840 --> 00:21:51,360
is that it now slices the type of

00:21:49,760 --> 00:21:53,760
exception

00:21:51,360 --> 00:21:56,159
the real thing whether it's a runtime

00:21:53,760 --> 00:21:59,280
era or a logic error with something else

00:21:56,159 --> 00:21:59,760
it's lost and so therefore the common

00:21:59,280 --> 00:22:02,799
device

00:21:59,760 --> 00:22:04,799
is to catch by reference usually

00:22:02,799 --> 00:22:05,600
reference to const if you do not want to

00:22:04,799 --> 00:22:08,640
modify except

00:22:05,600 --> 00:22:10,080
the exception but if you want to well of

00:22:08,640 --> 00:22:13,679
course you can also catch

00:22:10,080 --> 00:22:14,799
by none khan's reference mutate the

00:22:13,679 --> 00:22:18,559
exception

00:22:14,799 --> 00:22:18,559
and then potentially re-throw it again

00:22:20,159 --> 00:22:23,919
all right which brings us to to some

00:22:23,360 --> 00:22:28,480
extent

00:22:23,919 --> 00:22:31,039
the core of the talk writing good code

00:22:28,480 --> 00:22:32,720
and first we should talk about something

00:22:31,039 --> 00:22:34,240
that is called the exception safety

00:22:32,720 --> 00:22:36,240
guarantees

00:22:34,240 --> 00:22:37,440
this already sounds a little bit like

00:22:36,240 --> 00:22:40,480
good things

00:22:37,440 --> 00:22:41,679
the name guarantee suggests that there

00:22:40,480 --> 00:22:45,039
is some promises

00:22:41,679 --> 00:22:48,000
that we are making there is in fact

00:22:45,039 --> 00:22:49,840
three different levels of exception

00:22:48,000 --> 00:22:51,760
safety guarantees

00:22:49,840 --> 00:22:53,280
the first level of exception safety

00:22:51,760 --> 00:22:56,559
guarantee is called

00:22:53,280 --> 00:22:59,600
basic exception safety guarantee

00:22:56,559 --> 00:23:01,760
that already is pretty valuable

00:22:59,600 --> 00:23:02,799
because first of all it promises us that

00:23:01,760 --> 00:23:06,400
invariants are

00:23:02,799 --> 00:23:08,320
preserved as invariants are the one and

00:23:06,400 --> 00:23:10,400
only thing that you can trust

00:23:08,320 --> 00:23:12,080
now that the one thing that definitely

00:23:10,400 --> 00:23:14,159
needs to be

00:23:12,080 --> 00:23:16,080
something that you can count on this is

00:23:14,159 --> 00:23:18,240
already pretty valuable

00:23:16,080 --> 00:23:19,760
and second the basic exception safety

00:23:18,240 --> 00:23:22,640
guarantee promises

00:23:19,760 --> 00:23:26,720
that no resources are leaked also

00:23:22,640 --> 00:23:30,480
something that is particularly valuable

00:23:26,720 --> 00:23:33,360
what this does not promise however is

00:23:30,480 --> 00:23:34,840
that state does not change so if you

00:23:33,360 --> 00:23:36,559
call a function that gives this

00:23:34,840 --> 00:23:39,360
guarantee

00:23:36,559 --> 00:23:41,440
let's assume it's a member function then

00:23:39,360 --> 00:23:42,320
the state of the object that you call

00:23:41,440 --> 00:23:45,840
this function on

00:23:42,320 --> 00:23:47,520
might actually change since it promises

00:23:45,840 --> 00:23:50,240
that invariants are preserved

00:23:47,520 --> 00:23:53,679
it is a valid state but it is not

00:23:50,240 --> 00:23:55,520
necessarily the original state

00:23:53,679 --> 00:23:57,360
if you also want to promise that the

00:23:55,520 --> 00:23:59,360
original state is preserved

00:23:57,360 --> 00:24:01,279
then we need something called the strong

00:23:59,360 --> 00:24:04,159
exception safety guarantee

00:24:01,279 --> 00:24:05,679
that additionally so it again promises

00:24:04,159 --> 00:24:06,960
invariants are preserved and no

00:24:05,679 --> 00:24:09,360
resources are leaked

00:24:06,960 --> 00:24:10,080
but it additionally promises that no

00:24:09,360 --> 00:24:13,200
state

00:24:10,080 --> 00:24:15,440
is changing in a database we would call

00:24:13,200 --> 00:24:18,159
this a transaction

00:24:15,440 --> 00:24:19,840
we also refer to this as commit rollback

00:24:18,159 --> 00:24:23,039
semantics

00:24:19,840 --> 00:24:26,080
that of course is absolutely great

00:24:23,039 --> 00:24:28,480
because this is something that

00:24:26,080 --> 00:24:29,600
really feels easy to use so i call this

00:24:28,480 --> 00:24:32,480
function

00:24:29,600 --> 00:24:34,080
e that works or nothing has changed

00:24:32,480 --> 00:24:35,919
really beautiful

00:24:34,080 --> 00:24:37,840
but unfortunately it's not always

00:24:35,919 --> 00:24:39,919
possible so for instance

00:24:37,840 --> 00:24:41,919
uh imagine that i'm reading something

00:24:39,919 --> 00:24:43,760
from socket this fails

00:24:41,919 --> 00:24:45,679
i might not be able to read it again

00:24:43,760 --> 00:24:48,080
same is true for streams

00:24:45,679 --> 00:24:49,600
and it might not always be reasonable

00:24:48,080 --> 00:24:51,039
performance wise

00:24:49,600 --> 00:24:53,120
this is something that we'll see again a

00:24:51,039 --> 00:24:55,360
little later sometimes it

00:24:53,120 --> 00:24:57,760
could be done but we just don't want to

00:24:55,360 --> 00:24:59,840
pay the cost for it

00:24:57,760 --> 00:25:01,919
and there is even one more more

00:24:59,840 --> 00:25:03,840
guarantee an even stronger

00:25:01,919 --> 00:25:05,200
section safety guarantee and that one is

00:25:03,840 --> 00:25:08,240
called the no throw

00:25:05,200 --> 00:25:10,799
or sometimes also in a fail guarantee

00:25:08,240 --> 00:25:13,039
that guarantee simply says the operation

00:25:10,799 --> 00:25:14,640
cannot fail it will not throw an

00:25:13,039 --> 00:25:16,880
exception

00:25:14,640 --> 00:25:18,400
and this is nowadays explicitly

00:25:16,880 --> 00:25:21,520
expressed in code with

00:25:18,400 --> 00:25:23,679
no except which i'll talk about a little

00:25:21,520 --> 00:25:25,840
later

00:25:23,679 --> 00:25:27,679
so this is the three exception safety

00:25:25,840 --> 00:25:29,760
guarantees

00:25:27,679 --> 00:25:30,720
and this is now what we want to apply in

00:25:29,760 --> 00:25:33,520
code directly

00:25:30,720 --> 00:25:34,240
we want to see how code works with these

00:25:33,520 --> 00:25:37,360
particular

00:25:34,240 --> 00:25:40,000
exception safety guarantees so let's

00:25:37,360 --> 00:25:40,880
consider an example and as i said this

00:25:40,000 --> 00:25:43,919
is not just about

00:25:40,880 --> 00:25:45,760
exceptions now i want to really make the

00:25:43,919 --> 00:25:49,360
point that this is about writing

00:25:45,760 --> 00:25:52,480
good code code that it can reason about

00:25:49,360 --> 00:25:54,240
code that works reliably

00:25:52,480 --> 00:25:56,159
and that you just have a good feeling

00:25:54,240 --> 00:25:58,320
about so whether or not you're using

00:25:56,159 --> 00:26:01,039
exceptions is indeed irrelevant

00:25:58,320 --> 00:26:02,080
you want to write this kind of code and

00:26:01,039 --> 00:26:04,960
interestingly

00:26:02,080 --> 00:26:07,760
exception safety is just an outcome of

00:26:04,960 --> 00:26:10,880
writing this kind of code

00:26:07,760 --> 00:26:14,200
so to some extent i'm now building on

00:26:10,880 --> 00:26:15,360
um a talk from john kopp from cppcon

00:26:14,200 --> 00:26:17,919
00:26:15,360 --> 00:26:21,200
i believe it was the talk was also

00:26:17,919 --> 00:26:23,279
called exception safe code

00:26:21,200 --> 00:26:24,480
and in his talk he starts by making a

00:26:23,279 --> 00:26:26,159
promise

00:26:24,480 --> 00:26:28,720
actually it's three parts and this

00:26:26,159 --> 00:26:31,120
promise holds for all three parts

00:26:28,720 --> 00:26:32,640
the promise is that if you follow the

00:26:31,120 --> 00:26:35,360
advice the code is

00:26:32,640 --> 00:26:38,159
easier to read which implies it is

00:26:35,360 --> 00:26:38,559
easier to understand and maintain and i

00:26:38,159 --> 00:26:41,600
know

00:26:38,559 --> 00:26:45,919
add that it is even more correct

00:26:41,600 --> 00:26:48,559
with a much much higher probability than

00:26:45,919 --> 00:26:49,600
if it would not be the code becomes easy

00:26:48,559 --> 00:26:52,000
to write as well

00:26:49,600 --> 00:26:54,400
which is of course also great there is

00:26:52,000 --> 00:26:57,440
no additional time penalty

00:26:54,400 --> 00:26:59,440
and it should be 100 robust you should

00:26:57,440 --> 00:27:02,080
be able to just trust the code

00:26:59,440 --> 00:27:04,320
look at the code and know it is working

00:27:02,080 --> 00:27:07,120
correctly

00:27:04,320 --> 00:27:07,679
all right the example i have that i have

00:27:07,120 --> 00:27:10,799
is

00:27:07,679 --> 00:27:12,480
widget class and this class first of all

00:27:10,799 --> 00:27:14,880
comes with three data members

00:27:12,480 --> 00:27:15,679
it comes with an integer which i by

00:27:14,880 --> 00:27:18,559
default

00:27:15,679 --> 00:27:19,200
uh initialized to zero it comes with a

00:27:18,559 --> 00:27:21,120
string s

00:27:19,200 --> 00:27:22,320
that by default initialized to an empty

00:27:21,120 --> 00:27:24,320
string

00:27:22,320 --> 00:27:25,360
and it comes with a pointer to sum

00:27:24,320 --> 00:27:29,039
resource

00:27:25,360 --> 00:27:31,679
a raw pointer initialized to null porter

00:27:29,039 --> 00:27:32,320
i should already at this point point out

00:27:31,679 --> 00:27:34,799
that

00:27:32,320 --> 00:27:36,559
pr maybe null this is part of the

00:27:34,799 --> 00:27:39,600
semantics of this widget

00:27:36,559 --> 00:27:41,039
so um if this is null the invariant

00:27:39,600 --> 00:27:44,640
might still be preserved

00:27:41,039 --> 00:27:46,240
that's okay one of the things i

00:27:44,640 --> 00:27:48,880
definitely want to do with a widget

00:27:46,240 --> 00:27:51,760
is that i want to copy it so first of

00:27:48,880 --> 00:27:54,480
all i write a copy constructor

00:27:51,760 --> 00:27:55,679
which is pretty straightforward so given

00:27:54,480 --> 00:27:58,240
i have some

00:27:55,679 --> 00:27:59,039
other widget i first of all copy the

00:27:58,240 --> 00:28:02,480
integer

00:27:59,039 --> 00:28:07,120
i copy the string and then well

00:28:02,480 --> 00:28:10,159
i copy um the resource

00:28:07,120 --> 00:28:12,559
and i do not copy just the pointer

00:28:10,159 --> 00:28:14,320
which would be bad because copying a row

00:28:12,559 --> 00:28:16,320
pointer here would probably

00:28:14,320 --> 00:28:17,440
um cause some trouble later in the

00:28:16,320 --> 00:28:20,159
destructor

00:28:17,440 --> 00:28:20,720
now i'm really copying the resource as

00:28:20,159 --> 00:28:23,760
such

00:28:20,720 --> 00:28:26,880
so i'm creating a new resource literally

00:28:23,760 --> 00:28:29,200
and assign this to the point appear

00:28:26,880 --> 00:28:30,080
of course i'm only doing that if the

00:28:29,200 --> 00:28:32,399
given pointer

00:28:30,080 --> 00:28:34,720
so the pointer inside this w here is not

00:28:32,399 --> 00:28:37,120
a null pointer

00:28:34,720 --> 00:28:39,679
else i just um stick to the null point

00:28:37,120 --> 00:28:41,760
that i also have

00:28:39,679 --> 00:28:42,960
so that's a copy constructor we can take

00:28:41,760 --> 00:28:45,200
a look at this

00:28:42,960 --> 00:28:46,799
and we feel pretty confident that

00:28:45,200 --> 00:28:47,840
everything we're doing this function is

00:28:46,799 --> 00:28:49,520
just okay

00:28:47,840 --> 00:28:51,360
very straightforward deal with the end

00:28:49,520 --> 00:28:53,840
deal with the string deal with the

00:28:51,360 --> 00:28:53,840
pointer

00:28:55,600 --> 00:29:02,159
then however i also for symmetry reasons

00:28:58,320 --> 00:29:05,279
alone won the copy assignment operator

00:29:02,159 --> 00:29:07,760
that as you see here in in

00:29:05,279 --> 00:29:09,600
with these braces is apparently a

00:29:07,760 --> 00:29:11,840
slightly longer story

00:29:09,600 --> 00:29:13,679
so i start with something that i used to

00:29:11,840 --> 00:29:15,919
forget pretty often and so um

00:29:13,679 --> 00:29:17,840
it's now it is the first thing i write

00:29:15,919 --> 00:29:18,399
the return statement now the canonical

00:29:17,840 --> 00:29:20,480
return

00:29:18,399 --> 00:29:22,080
asterisk list um that's the first thing

00:29:20,480 --> 00:29:24,799
we do

00:29:22,080 --> 00:29:26,960
however from a logic point of view the

00:29:24,799 --> 00:29:30,559
first thing is that we do is of course

00:29:26,960 --> 00:29:32,640
we copy the integer well okay

00:29:30,559 --> 00:29:33,600
then we copy the string also pretty

00:29:32,640 --> 00:29:36,320
straight forward

00:29:33,600 --> 00:29:38,559
and we copy the pointer in the sense

00:29:36,320 --> 00:29:42,720
that we create a new resource

00:29:38,559 --> 00:29:46,480
um that deals with this copy operation

00:29:42,720 --> 00:29:48,640
so copy constructor of resource okay

00:29:46,480 --> 00:29:50,720
you already see that something's missing

00:29:48,640 --> 00:29:54,159
i'm missing the check of course

00:29:50,720 --> 00:29:55,919
i also again have to deal with null

00:29:54,159 --> 00:29:58,799
pointers

00:29:55,919 --> 00:30:00,480
w dot pr could be null i should check

00:29:58,799 --> 00:30:03,760
for this first

00:30:00,480 --> 00:30:05,679
and then it actually works well

00:30:03,760 --> 00:30:07,520
however something still does not feel

00:30:05,679 --> 00:30:10,960
quite right

00:30:07,520 --> 00:30:11,840
oh yes of course what if the given

00:30:10,960 --> 00:30:14,880
pointer

00:30:11,840 --> 00:30:14,880
is null

00:30:15,760 --> 00:30:22,240
and what about the fact that

00:30:19,360 --> 00:30:22,720
actually i'm assigning to a pointer that

00:30:22,240 --> 00:30:26,080
might

00:30:22,720 --> 00:30:27,520
already have been holding a resource

00:30:26,080 --> 00:30:29,840
oh there's multiple things that we

00:30:27,520 --> 00:30:30,720
should take care of so first of all i

00:30:29,840 --> 00:30:33,760
definitely should

00:30:30,720 --> 00:30:35,919
take care of my old resource first

00:30:33,760 --> 00:30:37,360
i do not want to leak any kind of memory

00:30:35,919 --> 00:30:40,799
so i delete

00:30:37,360 --> 00:30:43,279
the pointer and then of course i said

00:30:40,799 --> 00:30:44,480
potentially the pointer is null so i

00:30:43,279 --> 00:30:47,520
need an else branch

00:30:44,480 --> 00:30:50,399
too an else branch that

00:30:47,520 --> 00:30:52,799
probably sets pr to now in case um the

00:30:50,399 --> 00:30:54,880
other point does not well so i want the

00:30:52,799 --> 00:30:57,440
this widget to be a real copy of the

00:30:54,880 --> 00:30:57,440
other widget

00:30:57,840 --> 00:31:00,960
okay this was already a lot of work a

00:31:00,480 --> 00:31:04,480
lot of

00:31:00,960 --> 00:31:07,200
details but something's still missing

00:31:04,480 --> 00:31:09,039
and yes you might already see that a

00:31:07,200 --> 00:31:13,120
special case is missing

00:31:09,039 --> 00:31:16,480
an edge case self-assignment

00:31:13,120 --> 00:31:18,240
if indeed accidentally or because it's

00:31:16,480 --> 00:31:21,120
just a mathematical thing

00:31:18,240 --> 00:31:22,640
um this w here is the same as this

00:31:21,120 --> 00:31:24,559
widget

00:31:22,640 --> 00:31:26,640
then actually this is not really working

00:31:24,559 --> 00:31:28,559
well now this might work well

00:31:26,640 --> 00:31:29,760
perhaps this does but i'm definitely

00:31:28,559 --> 00:31:32,399
destroying my old

00:31:29,760 --> 00:31:33,840
resource and then it's gone and this

00:31:32,399 --> 00:31:34,480
definitely is not what a user would

00:31:33,840 --> 00:31:37,679
expect

00:31:34,480 --> 00:31:40,320
if um if it assigns a widget to itself

00:31:37,679 --> 00:31:42,399
so i should protect myself against this

00:31:40,320 --> 00:31:45,600
by means of a canonical

00:31:42,399 --> 00:31:48,000
self-assignment protection statement

00:31:45,600 --> 00:31:49,200
okay now it feels a little bit like we

00:31:48,000 --> 00:31:51,279
can lean back

00:31:49,200 --> 00:31:55,039
and be very proud about ourselves that

00:31:51,279 --> 00:31:55,039
this is actually not working well

00:31:55,120 --> 00:31:59,279
you may anticipate however that this is

00:31:57,039 --> 00:32:02,720
not the end of the story

00:31:59,279 --> 00:32:04,799
because this line here gives us a lot of

00:32:02,720 --> 00:32:08,320
trouble potentially

00:32:04,799 --> 00:32:11,279
new could fail new could actually

00:32:08,320 --> 00:32:12,000
throw an exception because it does not

00:32:11,279 --> 00:32:15,440
uh

00:32:12,000 --> 00:32:17,440
he's not able to give you enough memory

00:32:15,440 --> 00:32:18,960
if indeed you don't have enough memory

00:32:17,440 --> 00:32:21,039
you probably have totally different

00:32:18,960 --> 00:32:23,840
problems this may be the one thing that

00:32:21,039 --> 00:32:25,679
um you cannot really cope with but also

00:32:23,840 --> 00:32:28,799
the constructive resource

00:32:25,679 --> 00:32:31,279
might throw an exception

00:32:28,799 --> 00:32:35,039
and if that happens we are unfortunately

00:32:31,279 --> 00:32:38,720
in a pretty bad state because

00:32:35,039 --> 00:32:40,960
we have already deleted our old resource

00:32:38,720 --> 00:32:42,880
and the delete operation freeze the

00:32:40,960 --> 00:32:46,880
memory this is great

00:32:42,880 --> 00:32:48,880
um but it does not reset the pointer

00:32:46,880 --> 00:32:50,720
so if indeed the constructor of resource

00:32:48,880 --> 00:32:54,080
throws an exception

00:32:50,720 --> 00:32:56,559
i have a dangling pointer

00:32:54,080 --> 00:32:59,360
and so the invariant of my class is

00:32:56,559 --> 00:33:01,039
completely destroyed

00:32:59,360 --> 00:33:03,600
you would expect that in the destructor

00:33:01,039 --> 00:33:06,080
i simply delete this pointer too

00:33:03,600 --> 00:33:07,360
now imagine that in the destructor and

00:33:06,080 --> 00:33:09,760
i'll find the dangling point

00:33:07,360 --> 00:33:11,200
i would try to delete the resources

00:33:09,760 --> 00:33:13,919
second time

00:33:11,200 --> 00:33:15,440
of course this doesn't work perhaps this

00:33:13,919 --> 00:33:16,640
is more like a silent error

00:33:15,440 --> 00:33:18,480
if your standard library is not

00:33:16,640 --> 00:33:20,640
configured accordingly but

00:33:18,480 --> 00:33:21,519
perhaps it also crashes and if you see

00:33:20,640 --> 00:33:24,000
the crash

00:33:21,519 --> 00:33:26,399
it is miles away from the line where

00:33:24,000 --> 00:33:29,679
actually the problem occurred

00:33:26,399 --> 00:33:30,240
and so this is really really bad broken

00:33:29,679 --> 00:33:31,519
invariant

00:33:30,240 --> 00:33:33,360
is probably the worst thing that can

00:33:31,519 --> 00:33:35,279
happen to you

00:33:33,360 --> 00:33:36,640
perhaps i can visualize this even more

00:33:35,279 --> 00:33:38,480
by um

00:33:36,640 --> 00:33:40,880
telling you that this is perhaps a toy

00:33:38,480 --> 00:33:44,080
example consider some real example some

00:33:40,880 --> 00:33:45,840
atm machine consider that

00:33:44,080 --> 00:33:48,159
somebody has written a class bank

00:33:45,840 --> 00:33:49,919
account and this bank account comes with

00:33:48,159 --> 00:33:52,000
a withdraw money function

00:33:49,919 --> 00:33:54,240
well you pass some amount and the first

00:33:52,000 --> 00:33:57,519
thing you do is to reduce the balance

00:33:54,240 --> 00:33:59,039
by this given amount okay

00:33:57,519 --> 00:34:00,880
now the next thing is that we have to do

00:33:59,039 --> 00:34:04,159
is we have to prepare the cache

00:34:00,880 --> 00:34:09,119
that the user of the atm machine

00:34:04,159 --> 00:34:13,200
then finally gets what if per cash

00:34:09,119 --> 00:34:15,200
does not really work throws an exception

00:34:13,200 --> 00:34:16,639
well then of course i have a significant

00:34:15,200 --> 00:34:18,839
problem either

00:34:16,639 --> 00:34:20,639
because the balance has already been

00:34:18,839 --> 00:34:22,159
reduced

00:34:20,639 --> 00:34:24,000
what is the obvious solution in this

00:34:22,159 --> 00:34:26,960
case

00:34:24,000 --> 00:34:27,760
well of course it is a try catch block

00:34:26,960 --> 00:34:29,520
try

00:34:27,760 --> 00:34:30,960
prepare cash and in case there's

00:34:29,520 --> 00:34:33,359
something happening

00:34:30,960 --> 00:34:36,480
any exceptions thrown then of course we

00:34:33,359 --> 00:34:38,159
increase the balance again

00:34:36,480 --> 00:34:39,679
is this really the kind of code that you

00:34:38,159 --> 00:34:41,440
want to

00:34:39,679 --> 00:34:43,679
happen behind the covers in an atm

00:34:41,440 --> 00:34:46,639
machine is this the way you want your

00:34:43,679 --> 00:34:49,679
money to be treated

00:34:46,639 --> 00:34:52,720
let's admit it this is just bad code

00:34:49,679 --> 00:34:54,720
code that is not really reliable yeah

00:34:52,720 --> 00:34:55,919
what if increased balance throws another

00:34:54,720 --> 00:34:58,480
exception

00:34:55,919 --> 00:35:00,000
the money is gone it might be entirely

00:34:58,480 --> 00:35:02,320
gone

00:35:00,000 --> 00:35:03,680
and a lot of people believe that the

00:35:02,320 --> 00:35:07,119
financial crisis

00:35:03,680 --> 00:35:09,599
was um was responsible for

00:35:07,119 --> 00:35:10,480
um the bankruptcy of the lehman brothers

00:35:09,599 --> 00:35:16,160
i believe

00:35:10,480 --> 00:35:19,680
it was because of in invalid

00:35:16,160 --> 00:35:22,960
um objects also

00:35:19,680 --> 00:35:26,240
invalidated invariants and if

00:35:22,960 --> 00:35:28,079
i am to predict the future a little bit

00:35:26,240 --> 00:35:29,359
i might not be good at that but if i

00:35:28,079 --> 00:35:31,200
would be predict

00:35:29,359 --> 00:35:32,800
um the future then probably broken

00:35:31,200 --> 00:35:36,079
invariants are also

00:35:32,800 --> 00:35:36,560
a reason for the fall of mankind and if

00:35:36,079 --> 00:35:39,119
they go

00:35:36,560 --> 00:35:40,240
to a far few further future or far

00:35:39,119 --> 00:35:42,240
farther away future

00:35:40,240 --> 00:35:44,560
then probably broken invariants are also

00:35:42,240 --> 00:35:47,760
the reason for the rise of the empire

00:35:44,560 --> 00:35:51,599
i'm almost certain about that because

00:35:47,760 --> 00:35:54,240
in 2014 we already got the right message

00:35:51,599 --> 00:35:55,280
so both john kopp and his friend yoda

00:35:54,240 --> 00:35:58,480
tried us to tell

00:35:55,280 --> 00:36:01,200
that there is now a try good code

00:35:58,480 --> 00:36:04,160
is easy to understand and it's not about

00:36:01,200 --> 00:36:05,839
filling with all the details

00:36:04,160 --> 00:36:07,839
this is exactly what is happening in

00:36:05,839 --> 00:36:10,480
this function

00:36:07,839 --> 00:36:11,599
despite the fact that this assignment

00:36:10,480 --> 00:36:14,800
operator

00:36:11,599 --> 00:36:17,280
it's only about 10 functions long

00:36:14,800 --> 00:36:18,720
it is just too difficult to really

00:36:17,280 --> 00:36:21,599
comprehend

00:36:18,720 --> 00:36:23,280
we're dealing with virtually everything

00:36:21,599 --> 00:36:25,520
we are dealing with

00:36:23,280 --> 00:36:26,480
memory management there is a new there's

00:36:25,520 --> 00:36:28,720
a delete

00:36:26,480 --> 00:36:30,320
we're dealing with pointers yeah so

00:36:28,720 --> 00:36:32,079
there is dangling pointers involved

00:36:30,320 --> 00:36:35,280
there's null pointers involved

00:36:32,079 --> 00:36:38,240
um we are dealing with all different

00:36:35,280 --> 00:36:38,960
uh kinds of data members uh all of them

00:36:38,240 --> 00:36:41,599
um

00:36:38,960 --> 00:36:42,800
in in in a row we're dealing with

00:36:41,599 --> 00:36:45,839
self-assignment

00:36:42,800 --> 00:36:45,839
it's just too much

00:36:46,240 --> 00:36:51,280
there is however very very good advice

00:36:48,800 --> 00:36:54,400
on how to deal with this kind of thing

00:36:51,280 --> 00:36:56,079
delegate so first of all

00:36:54,400 --> 00:36:57,920
this function is what we say is

00:36:56,079 --> 00:36:59,920
exception unsafe

00:36:57,920 --> 00:37:01,839
so right now this code gives us no

00:36:59,920 --> 00:37:04,480
guarantees whatsoever with respect to

00:37:01,839 --> 00:37:07,119
invariance and resources

00:37:04,480 --> 00:37:07,760
there is a simple fix now a simple fix

00:37:07,119 --> 00:37:11,119
would be

00:37:07,760 --> 00:37:12,400
to move the else branch so this this

00:37:11,119 --> 00:37:16,960
line of code here

00:37:12,400 --> 00:37:20,839
to line 25. in case we do that

00:37:16,960 --> 00:37:23,200
actually we have saved the day because

00:37:20,839 --> 00:37:26,480
if either new or the

00:37:23,200 --> 00:37:28,560
constructive resource fail um

00:37:26,480 --> 00:37:29,760
we're still in a good shape i said that

00:37:28,560 --> 00:37:33,680
it is perfectly okay

00:37:29,760 --> 00:37:37,040
if the resource point is a null pointer

00:37:33,680 --> 00:37:39,760
so this is potentially okay but

00:37:37,040 --> 00:37:41,040
it might not be the old state because

00:37:39,760 --> 00:37:44,079
i've already changed

00:37:41,040 --> 00:37:45,839
in line 22 the integer and in line 23

00:37:44,079 --> 00:37:48,160
the string

00:37:45,839 --> 00:37:51,520
still this is what we refer to as the

00:37:48,160 --> 00:37:54,000
basic exception safety guarantee

00:37:51,520 --> 00:37:55,520
essentially means we are in good shape

00:37:54,000 --> 00:37:56,160
yes there was a problem there was an

00:37:55,520 --> 00:37:59,839
exception

00:37:56,160 --> 00:38:02,240
but still we can deal with a problem um

00:37:59,839 --> 00:38:04,400
we we are still in good shape we have

00:38:02,240 --> 00:38:05,920
somehow dealt with the problem locally

00:38:04,400 --> 00:38:08,400
no resources leaked invariants are

00:38:05,920 --> 00:38:08,400
preserved

00:38:08,640 --> 00:38:11,839
but i would still rate this as bad code

00:38:10,960 --> 00:38:13,680
because still

00:38:11,839 --> 00:38:16,079
it is just too many details that i'm

00:38:13,680 --> 00:38:18,160
trying to deal with manually

00:38:16,079 --> 00:38:19,839
so as i said before the right solution

00:38:18,160 --> 00:38:21,920
is to delegate

00:38:19,839 --> 00:38:23,599
instead of dealing with all of this

00:38:21,920 --> 00:38:27,520
memory management manually

00:38:23,599 --> 00:38:30,160
what i should do really is to use

00:38:27,520 --> 00:38:31,520
a unique pointer in this example so i

00:38:30,160 --> 00:38:32,640
have a unique pointer here is a data

00:38:31,520 --> 00:38:35,359
member now

00:38:32,640 --> 00:38:36,480
i use make unique in the in the

00:38:35,359 --> 00:38:38,640
constructor

00:38:36,480 --> 00:38:40,160
and i'm also using make unique here in

00:38:38,640 --> 00:38:42,960
this line

00:38:40,160 --> 00:38:44,320
and suddenly a lot of the complexity

00:38:42,960 --> 00:38:47,680
that we've seen before

00:38:44,320 --> 00:38:48,640
is simply gone we do no longer have to

00:38:47,680 --> 00:38:51,599
delete

00:38:48,640 --> 00:38:53,359
you no longer have to call new manually

00:38:51,599 --> 00:38:56,560
it's all handled

00:38:53,359 --> 00:38:59,280
automatically reliably

00:38:56,560 --> 00:39:00,400
true we did not go beyond the basic they

00:38:59,280 --> 00:39:03,520
have to guarantee it

00:39:00,400 --> 00:39:04,960
but still it feels and it looks better

00:39:03,520 --> 00:39:06,560
we take a look at this code now and we

00:39:04,960 --> 00:39:08,960
have a much better understanding what is

00:39:06,560 --> 00:39:08,960
happening

00:39:09,520 --> 00:39:13,200
what i'm using here is just the basic

00:39:11,680 --> 00:39:15,760
philosophy of the c plus

00:39:13,200 --> 00:39:16,400
program language what i'm using here is

00:39:15,760 --> 00:39:19,760
rye

00:39:16,400 --> 00:39:21,760
resource acquisition is initialization

00:39:19,760 --> 00:39:22,800
and i will not talk a lot about rai at

00:39:21,760 --> 00:39:24,880
this point because

00:39:22,800 --> 00:39:26,480
also here there has been a very good

00:39:24,880 --> 00:39:29,599
back to basics talk

00:39:26,480 --> 00:39:31,920
last year at cppcon 2019. so arthur

00:39:29,599 --> 00:39:33,599
dwight talked about ry and the rule of

00:39:31,920 --> 00:39:35,119
zero

00:39:33,599 --> 00:39:36,880
and this is a talk that definitely every

00:39:35,119 --> 00:39:39,280
c plus bus programmer should

00:39:36,880 --> 00:39:39,920
have seen or every c plus burst program

00:39:39,280 --> 00:39:41,520
at least

00:39:39,920 --> 00:39:43,599
should have understood the full

00:39:41,520 --> 00:39:47,040
extension the full extent

00:39:43,599 --> 00:39:49,440
of what right truly means there is no

00:39:47,040 --> 00:39:50,720
resource leaks in c plus if you truly

00:39:49,440 --> 00:39:54,079
follow

00:39:50,720 --> 00:39:55,520
this this guideline or to put it into

00:39:54,079 --> 00:39:57,520
john culp's words

00:39:55,520 --> 00:39:59,440
keep your resources on a short leash to

00:39:57,520 --> 00:40:02,960
not go leaking wherever they want

00:39:59,440 --> 00:40:06,160
now indeed right is helping you

00:40:02,960 --> 00:40:08,480
a lot with resources without making your

00:40:06,160 --> 00:40:10,319
code much easier

00:40:08,480 --> 00:40:11,839
to some extent automatically exception

00:40:10,319 --> 00:40:14,560
saved

00:40:11,839 --> 00:40:17,760
so it will not always work still um this

00:40:14,560 --> 00:40:19,599
is a very first step to go there

00:40:17,760 --> 00:40:21,119
still we can now although we are pretty

00:40:19,599 --> 00:40:23,520
happy already

00:40:21,119 --> 00:40:24,720
perhaps we can still try to reason about

00:40:23,520 --> 00:40:27,280
this one more time

00:40:24,720 --> 00:40:28,560
because still whatever happens in make

00:40:27,280 --> 00:40:30,480
unique might fail

00:40:28,560 --> 00:40:32,880
we still call new inside this function

00:40:30,480 --> 00:40:36,079
we still call the construct of resource

00:40:32,880 --> 00:40:36,079
it might throw an exception

00:40:36,480 --> 00:40:40,640
however perhaps we can take a closer

00:40:39,359 --> 00:40:42,400
look at what we're doing in this

00:40:40,640 --> 00:40:44,720
function

00:40:42,400 --> 00:40:46,079
we're copying the into a carbonyl string

00:40:44,720 --> 00:40:48,880
we are copying

00:40:46,079 --> 00:40:48,880
a resource

00:40:49,280 --> 00:40:53,200
isn't this something that i'm also

00:40:51,599 --> 00:40:55,800
dealing with

00:40:53,200 --> 00:40:57,599
in the copy constructor isn't this

00:40:55,800 --> 00:41:01,040
exactly the same

00:40:57,599 --> 00:41:04,240
piece of code actually

00:41:01,040 --> 00:41:05,440
it is and for that reason we can

00:41:04,240 --> 00:41:10,319
actually go one step

00:41:05,440 --> 00:41:10,319
further and apply something that

00:41:10,400 --> 00:41:13,440
most strongly follows the advice that

00:41:12,319 --> 00:41:16,960
i've given you before

00:41:13,440 --> 00:41:19,280
delegate instead of coding this again

00:41:16,960 --> 00:41:20,880
to some extent violate the dry principle

00:41:19,280 --> 00:41:24,319
we could simply

00:41:20,880 --> 00:41:26,400
call the copy constructor

00:41:24,319 --> 00:41:28,240
so now in this function we have dealt

00:41:26,400 --> 00:41:33,119
with all of these operations

00:41:28,240 --> 00:41:35,599
if indeed this line here line 14 fails

00:41:33,119 --> 00:41:37,920
i think that happened actually it just

00:41:35,599 --> 00:41:41,520
failed to create a copy

00:41:37,920 --> 00:41:44,319
which is nice so this line is

00:41:41,520 --> 00:41:44,880
the one line that might actually fail if

00:41:44,319 --> 00:41:48,720
i now

00:41:44,880 --> 00:41:51,280
can make the content of temp

00:41:48,720 --> 00:41:51,280
my own

00:41:51,839 --> 00:41:55,760
without any possibility of this

00:41:54,720 --> 00:41:58,560
operation to fail

00:41:55,760 --> 00:42:00,720
then i actually would be done there's a

00:41:58,560 --> 00:42:03,200
very elegant way to do that

00:42:00,720 --> 00:42:03,920
the most common one used today is to

00:42:03,200 --> 00:42:07,040
simply

00:42:03,920 --> 00:42:09,040
move this temporary into this

00:42:07,040 --> 00:42:11,040
in other words to use the move

00:42:09,040 --> 00:42:13,760
assignment operator

00:42:11,040 --> 00:42:14,960
that is called the temporary move medium

00:42:13,760 --> 00:42:17,440
and it works

00:42:14,960 --> 00:42:18,160
hopefully because your move assignment

00:42:17,440 --> 00:42:20,640
operator

00:42:18,160 --> 00:42:22,000
if everything is implemented as expected

00:42:20,640 --> 00:42:25,280
should actually be a no

00:42:22,000 --> 00:42:29,440
except operation an operation

00:42:25,280 --> 00:42:32,160
that promises that it will not fail

00:42:29,440 --> 00:42:34,880
so if i experience an exception in this

00:42:32,160 --> 00:42:36,640
line of code

00:42:34,880 --> 00:42:38,880
then actually nothing bad happened to

00:42:36,640 --> 00:42:42,400
this subject i did not yet

00:42:38,880 --> 00:42:44,960
touch this state this is great

00:42:42,400 --> 00:42:47,839
this is what we refer to as the strong

00:42:44,960 --> 00:42:52,160
exception safety guarantee

00:42:47,839 --> 00:42:54,720
either everything everything works out

00:42:52,160 --> 00:42:57,520
or nothing is changed invariants are

00:42:54,720 --> 00:43:00,560
preserved no resources leaked

00:42:57,520 --> 00:43:03,839
perfect but if this works

00:43:00,560 --> 00:43:07,040
if i indeed get a full copy of w

00:43:03,839 --> 00:43:08,079
now if i get this temporary then i can

00:43:07,040 --> 00:43:11,359
move it

00:43:08,079 --> 00:43:12,319
without any possibility for any kind of

00:43:11,359 --> 00:43:15,359
exception

00:43:12,319 --> 00:43:15,359
into myself

00:43:16,480 --> 00:43:20,880
the temporary move idiom and suddenly a

00:43:18,800 --> 00:43:22,640
lot of the complexity is indeed gone

00:43:20,880 --> 00:43:24,160
if you take a look at this function we

00:43:22,640 --> 00:43:26,560
now simply argue

00:43:24,160 --> 00:43:27,839
this works and of course the move

00:43:26,560 --> 00:43:30,160
assignment operator

00:43:27,839 --> 00:43:31,520
implements something that we call is

00:43:30,160 --> 00:43:33,119
that this no throw

00:43:31,520 --> 00:43:35,040
exception safety guarantee this

00:43:33,119 --> 00:43:38,240
operation will not fail

00:43:35,040 --> 00:43:41,920
we heavily rely on that for implementing

00:43:38,240 --> 00:43:43,920
the strong exception safety guarantee

00:43:41,920 --> 00:43:45,920
there is in fact a couple more functions

00:43:43,920 --> 00:43:48,160
that are not supposed to fail

00:43:45,920 --> 00:43:49,440
so move just being one of them the most

00:43:48,160 --> 00:43:53,040
prominent function that

00:43:49,440 --> 00:43:56,640
must not fail should not fail

00:43:53,040 --> 00:43:59,040
to weaken a little bit is the structures

00:43:56,640 --> 00:44:00,240
the structures are an integral part of

00:43:59,040 --> 00:44:02,560
this entire game

00:44:00,240 --> 00:44:04,319
because they are called during stag

00:44:02,560 --> 00:44:07,280
unwinding

00:44:04,319 --> 00:44:08,800
if a destructor could fail if it could

00:44:07,280 --> 00:44:10,880
throw an exception

00:44:08,800 --> 00:44:14,079
during stack unwinding when another

00:44:10,880 --> 00:44:17,520
exception is obviously already flying

00:44:14,079 --> 00:44:20,400
then we would again fail completely

00:44:17,520 --> 00:44:20,720
if you throw a second exception meaning

00:44:20,400 --> 00:44:23,520
if

00:44:20,720 --> 00:44:25,520
indeed two or more exceptions are flying

00:44:23,520 --> 00:44:26,400
then the standard terminate function is

00:44:25,520 --> 00:44:28,720
called again

00:44:26,400 --> 00:44:31,119
and i said before this is a not but not

00:44:28,720 --> 00:44:34,000
particularly pleasant thing to happen

00:44:31,119 --> 00:44:35,119
um this is something you want to avoid

00:44:34,000 --> 00:44:37,760
because they're so

00:44:35,119 --> 00:44:39,440
important in terms of program

00:44:37,760 --> 00:44:40,640
correctness and exception safety in

00:44:39,440 --> 00:44:42,800
particular

00:44:40,640 --> 00:44:44,400
they are the structures are implicitly

00:44:42,800 --> 00:44:45,359
marked as no except sincere plus verse

00:44:44,400 --> 00:44:47,839
11.

00:44:45,359 --> 00:44:49,599
so you can of course mark them yourself

00:44:47,839 --> 00:44:52,240
but the compiler assumes that there

00:44:49,599 --> 00:44:53,040
are no except if indeed you want the

00:44:52,240 --> 00:44:55,520
destructor

00:44:53,040 --> 00:44:57,440
to throw to throw then what he would

00:44:55,520 --> 00:45:01,040
have to do is to explicitly

00:44:57,440 --> 00:45:04,400
mark this as no except false

00:45:01,040 --> 00:45:06,640
so cleanup must be safe

00:45:04,400 --> 00:45:08,480
the second function i already mentioned

00:45:06,640 --> 00:45:10,800
um the move assignment operator but of

00:45:08,480 --> 00:45:12,880
course there's also the move constructor

00:45:10,800 --> 00:45:14,079
move operations in general should be

00:45:12,880 --> 00:45:16,960
implemented such that

00:45:14,079 --> 00:45:18,160
they can promise not to fail by means of

00:45:16,960 --> 00:45:20,880
no except

00:45:18,160 --> 00:45:23,040
so there is even a core guideline core

00:45:20,880 --> 00:45:26,240
guideline c66 that says

00:45:23,040 --> 00:45:27,760
make move operations no except there's

00:45:26,240 --> 00:45:29,920
very very good reasons

00:45:27,760 --> 00:45:31,200
um because usually the move operation

00:45:29,920 --> 00:45:33,760
should really

00:45:31,200 --> 00:45:35,040
be broken down into the most simple

00:45:33,760 --> 00:45:37,599
operations

00:45:35,040 --> 00:45:39,599
copying pointers copying integers it

00:45:37,599 --> 00:45:41,520
should be simple

00:45:39,599 --> 00:45:43,680
and even though it may be a little more

00:45:41,520 --> 00:45:44,240
expensive every move operation can be

00:45:43,680 --> 00:45:47,040
made

00:45:44,240 --> 00:45:47,440
no except that of course it is your

00:45:47,040 --> 00:45:50,560
choice

00:45:47,440 --> 00:45:52,079
um in in special cases and the third

00:45:50,560 --> 00:45:54,240
function that should always be

00:45:52,079 --> 00:45:55,680
no except because it usually can be

00:45:54,240 --> 00:45:59,200
implemented in that way is

00:45:55,680 --> 00:46:02,079
the swap function also swap

00:45:59,200 --> 00:46:02,880
usually should be able to be implemented

00:46:02,079 --> 00:46:05,359
in terms

00:46:02,880 --> 00:46:07,440
of non-failing basic operations like

00:46:05,359 --> 00:46:09,040
copying pointers like copying integers

00:46:07,440 --> 00:46:12,640
etc

00:46:09,040 --> 00:46:15,040
standard swap relies on move operations

00:46:12,640 --> 00:46:16,720
and if the move operations do not do

00:46:15,040 --> 00:46:18,079
what you expect what you want

00:46:16,720 --> 00:46:20,400
of course you can implement your own

00:46:18,079 --> 00:46:25,359
swap in that case please remember

00:46:20,400 --> 00:46:25,359
that swap indeed should be no except

00:46:25,760 --> 00:46:30,160
no accept has indeed a couple of

00:46:27,440 --> 00:46:32,319
benefits so it is something that perhaps

00:46:30,160 --> 00:46:34,800
you want to look out

00:46:32,319 --> 00:46:35,680
no except first of all makes the promise

00:46:34,800 --> 00:46:39,440
to never

00:46:35,680 --> 00:46:42,480
throw visible and throw

00:46:39,440 --> 00:46:45,760
did not throw visible in the code

00:46:42,480 --> 00:46:47,359
so you will definitely see in the code

00:46:45,760 --> 00:46:49,599
that something will not fail

00:46:47,359 --> 00:46:52,800
and this is a good thing you know this

00:46:49,599 --> 00:46:54,839
definitely raises your um

00:46:52,800 --> 00:46:56,319
your confidence in this particular

00:46:54,839 --> 00:46:58,640
function

00:46:56,319 --> 00:47:00,560
but it also can lead to well at least

00:46:58,640 --> 00:47:04,000
slightly faster code

00:47:00,560 --> 00:47:05,359
it's not massively faster but

00:47:04,000 --> 00:47:07,280
it has been shown that indeed the

00:47:05,359 --> 00:47:09,920
compiler has to produce

00:47:07,280 --> 00:47:11,520
a couple of less assembly statements and

00:47:09,920 --> 00:47:12,400
of course this may make a difference

00:47:11,520 --> 00:47:16,240
between

00:47:12,400 --> 00:47:16,240
a little faster and a little slower

00:47:16,400 --> 00:47:21,520
note that if you indeed mark a function

00:47:19,680 --> 00:47:23,920
with no except

00:47:21,520 --> 00:47:24,960
and you still throw from this function

00:47:23,920 --> 00:47:27,200
so an exception

00:47:24,960 --> 00:47:29,040
leaves this function then again

00:47:27,200 --> 00:47:30,880
terminator is called

00:47:29,040 --> 00:47:32,800
and unfortunately the compiler does not

00:47:30,880 --> 00:47:35,520
really check this

00:47:32,800 --> 00:47:37,200
this promise that you do not accept this

00:47:35,520 --> 00:47:38,160
is something that company has never done

00:47:37,200 --> 00:47:40,079
before

00:47:38,160 --> 00:47:42,720
before you see blessed 11 the compiler

00:47:40,079 --> 00:47:45,680
did not check any kind of exceptions

00:47:42,720 --> 00:47:47,839
you're on your own here so if you give

00:47:45,680 --> 00:47:51,280
the no accept

00:47:47,839 --> 00:47:54,800
promise then make sure that it is true

00:47:51,280 --> 00:47:56,800
and make sure that you can also

00:47:54,800 --> 00:47:58,400
give this promise the compiler will not

00:47:56,800 --> 00:48:01,040
help you

00:47:58,400 --> 00:48:01,680
which however also means that you should

00:48:01,040 --> 00:48:04,720
not

00:48:01,680 --> 00:48:07,040
give the no accept promise lightly

00:48:04,720 --> 00:48:09,359
so only give it if you're absolutely

00:48:07,040 --> 00:48:12,720
certain that this is actually true

00:48:09,359 --> 00:48:15,359
and also um do not give it if you later

00:48:12,720 --> 00:48:16,960
potentially might take it back because

00:48:15,359 --> 00:48:17,680
once the function is smart there's no

00:48:16,960 --> 00:48:20,880
accept

00:48:17,680 --> 00:48:22,400
people will rely on this promise later

00:48:20,880 --> 00:48:24,640
telling them oh by the way

00:48:22,400 --> 00:48:26,480
it's not working that way anymore is

00:48:24,640 --> 00:48:28,400
probably not a good idea

00:48:26,480 --> 00:48:29,920
so there is few functions that should be

00:48:28,400 --> 00:48:33,359
marked with no except

00:48:29,920 --> 00:48:35,440
the obvious small functions um

00:48:33,359 --> 00:48:36,559
please don't overuse it despite the fact

00:48:35,440 --> 00:48:39,760
that perhaps code

00:48:36,559 --> 00:48:39,760
is a little faster

00:48:40,079 --> 00:48:43,920
so and of course i mentioned before

00:48:42,079 --> 00:48:46,319
destructors are implicitly marked as no

00:48:43,920 --> 00:48:49,359
except

00:48:46,319 --> 00:48:50,800
so back to this example by means of this

00:48:49,359 --> 00:48:52,079
construct we have now turned the

00:48:50,800 --> 00:48:53,280
function into something that we

00:48:52,079 --> 00:48:54,960
understand

00:48:53,280 --> 00:48:56,319
immediately we can take a look at the

00:48:54,960 --> 00:48:59,760
function we see

00:48:56,319 --> 00:49:03,680
it works and i would argue this is just

00:48:59,760 --> 00:49:06,319
good code code that is comprehensible

00:49:03,680 --> 00:49:08,319
code that the reader can pick up easily

00:49:06,319 --> 00:49:09,119
and so even if exceptions are not your

00:49:08,319 --> 00:49:11,839
thing

00:49:09,119 --> 00:49:13,760
this is still something that is

00:49:11,839 --> 00:49:14,319
interesting from a structural point of

00:49:13,760 --> 00:49:18,319
view

00:49:14,319 --> 00:49:21,359
this code is just properly structured

00:49:18,319 --> 00:49:23,040
and so if you implement your code in

00:49:21,359 --> 00:49:25,359
this particular fashion

00:49:23,040 --> 00:49:27,040
then you might in the future when you

00:49:25,359 --> 00:49:31,839
can turn on exceptions

00:49:27,040 --> 00:49:31,839
um you might actually have a big benefit

00:49:32,000 --> 00:49:35,359
note that when this is working we can

00:49:34,480 --> 00:49:37,520
actually also

00:49:35,359 --> 00:49:39,119
um completely get rid of this statement

00:49:37,520 --> 00:49:41,119
here um

00:49:39,119 --> 00:49:42,839
self-assignment will still work it might

00:49:41,119 --> 00:49:44,400
be a little more expensive but still it

00:49:42,839 --> 00:49:46,240
works

00:49:44,400 --> 00:49:47,680
and so this is exactly what john kopp

00:49:46,240 --> 00:49:50,480
meant with his promise

00:49:47,680 --> 00:49:51,839
the code it becomes easier to read easy

00:49:50,480 --> 00:49:53,359
to write

00:49:51,839 --> 00:49:55,440
there's not nothing special that we're

00:49:53,359 --> 00:49:59,520
doing we've done this same thing before

00:49:55,440 --> 00:50:02,319
and it is 100 robust

00:49:59,520 --> 00:50:03,839
so a couple of guidelines rai is the

00:50:02,319 --> 00:50:05,119
single most important idiom of the c

00:50:03,839 --> 00:50:08,319
plus programming language

00:50:05,119 --> 00:50:09,839
use it all functions should at least

00:50:08,319 --> 00:50:10,800
provide the basic exception safety

00:50:09,839 --> 00:50:13,440
guarantee

00:50:10,800 --> 00:50:15,280
if possible and reasonable the strong

00:50:13,440 --> 00:50:18,160
guarantee

00:50:15,280 --> 00:50:20,480
and consider the authorial guarantee but

00:50:18,160 --> 00:50:26,160
only provided if you can guarantee it

00:50:20,480 --> 00:50:29,359
even for possible future changes

00:50:26,160 --> 00:50:31,280
all right um

00:50:29,359 --> 00:50:33,200
there is a perhaps interesting side

00:50:31,280 --> 00:50:34,720
question how to deal with failing

00:50:33,200 --> 00:50:37,760
cleanup functions

00:50:34,720 --> 00:50:40,880
what if for instance

00:50:37,760 --> 00:50:44,640
a destructor calls something that could

00:50:40,880 --> 00:50:46,640
potentially fail so for instance

00:50:44,640 --> 00:50:48,000
let's assume that we have a file that

00:50:46,640 --> 00:50:49,920
has been opened somewhere

00:50:48,000 --> 00:50:53,359
in the constructor probably but now that

00:50:49,920 --> 00:50:56,720
has been to be closed in the destructor

00:50:53,359 --> 00:50:58,720
well f close actually can fail

00:50:56,720 --> 00:51:01,520
it's not that obvious but it will return

00:50:58,720 --> 00:51:01,520
an error code

00:51:02,160 --> 00:51:05,760
what if i want to deal with this problem

00:51:04,640 --> 00:51:08,079
somehow

00:51:05,760 --> 00:51:09,440
well then the best advice i can give you

00:51:08,079 --> 00:51:12,559
is that you do not rely

00:51:09,440 --> 00:51:15,760
on stud fstream or

00:51:12,559 --> 00:51:18,720
um so if stream or off stream

00:51:15,760 --> 00:51:20,079
because in this case they simply ignore

00:51:18,720 --> 00:51:22,079
the problem

00:51:20,079 --> 00:51:23,680
if you want to react on this particular

00:51:22,079 --> 00:51:25,280
problem then you would have to write

00:51:23,680 --> 00:51:27,920
your own right class

00:51:25,280 --> 00:51:29,520
in the destructor you would now accept

00:51:27,920 --> 00:51:32,000
this error code

00:51:29,520 --> 00:51:32,800
check it and deal with it somehow but

00:51:32,000 --> 00:51:35,760
you still

00:51:32,800 --> 00:51:37,200
cannot throw you should not throw you

00:51:35,760 --> 00:51:39,040
not know what you could do

00:51:37,200 --> 00:51:41,119
but still it's not a particularly good

00:51:39,040 --> 00:51:42,400
idea and it will trigger too many other

00:51:41,119 --> 00:51:45,520
problems

00:51:42,400 --> 00:51:47,359
so um for handling errors in the

00:51:45,520 --> 00:51:50,640
destructor differently write your own

00:51:47,359 --> 00:51:53,760
right classes that manage this in the

00:51:50,640 --> 00:51:53,760
way you want to deal with it

00:51:54,800 --> 00:51:57,599
now there is perhaps one more

00:51:56,160 --> 00:51:58,400
information that i want to give you

00:51:57,599 --> 00:52:00,720
something that

00:51:58,400 --> 00:52:02,800
is always something that i also deal

00:52:00,720 --> 00:52:05,280
with in my uh my training classes

00:52:02,800 --> 00:52:06,319
how to refactor code that just isn't

00:52:05,280 --> 00:52:09,200
there yet

00:52:06,319 --> 00:52:11,839
how can i get to code that is exception

00:52:09,200 --> 00:52:15,359
safe that is beautiful to use

00:52:11,839 --> 00:52:18,640
um what you do what do you have to do

00:52:15,359 --> 00:52:20,640
well basically we are not talking about

00:52:18,640 --> 00:52:25,280
the transition from pre-exception

00:52:20,640 --> 00:52:28,000
save to exception say of code um so

00:52:25,280 --> 00:52:29,520
this is um we're dealing with code that

00:52:28,000 --> 00:52:30,800
cannot really deal with exceptions at

00:52:29,520 --> 00:52:33,839
this point

00:52:30,800 --> 00:52:36,319
and there is one law

00:52:33,839 --> 00:52:38,079
one rule i would say um not just a

00:52:36,319 --> 00:52:40,400
strong from a wording point of view

00:52:38,079 --> 00:52:41,760
um the strong parent's iron law of lagos

00:52:40,400 --> 00:52:46,079
refactoring

00:52:41,760 --> 00:52:47,599
existing contracts cannot be broken so

00:52:46,079 --> 00:52:49,839
what does this mean

00:52:47,599 --> 00:52:50,880
of course you should refactor but you

00:52:49,839 --> 00:52:52,319
should not make

00:52:50,880 --> 00:52:54,079
the old function suddenly throw

00:52:52,319 --> 00:52:56,720
exceptions

00:52:54,079 --> 00:52:58,079
all new code that you write can be

00:52:56,720 --> 00:53:00,960
exception safe

00:52:58,079 --> 00:53:02,480
can be written in the way um that i

00:53:00,960 --> 00:53:06,079
basically now just um

00:53:02,480 --> 00:53:06,720
talked about all new interfaces of

00:53:06,079 --> 00:53:10,960
course

00:53:06,720 --> 00:53:14,160
free to throw um as well yeah

00:53:10,960 --> 00:53:17,280
however if you have some old function

00:53:14,160 --> 00:53:18,640
you cannot just leave exception let

00:53:17,280 --> 00:53:20,880
this this whole function throw

00:53:18,640 --> 00:53:22,880
exceptions now nobody would expect it

00:53:20,880 --> 00:53:25,680
and it would of course very ungracefully

00:53:22,880 --> 00:53:28,960
disrupt a lot of things

00:53:25,680 --> 00:53:29,839
so you have to basically write new

00:53:28,960 --> 00:53:31,839
functions

00:53:29,839 --> 00:53:34,160
and re-implement the old function terms

00:53:31,839 --> 00:53:36,000
of the of the new one

00:53:34,160 --> 00:53:37,599
so in order to give you an idea how this

00:53:36,000 --> 00:53:40,400
works

00:53:37,599 --> 00:53:42,559
let's take a look at an example it's not

00:53:40,400 --> 00:53:44,079
a particularly difficult example it's a

00:53:42,559 --> 00:53:46,559
rather short example

00:53:44,079 --> 00:53:48,000
something that gives you an idea what i

00:53:46,559 --> 00:53:51,599
have in mind here

00:53:48,000 --> 00:53:55,040
it's a function that loads a file

00:53:51,599 --> 00:53:55,440
so i'm loading a file i have in this

00:53:55,040 --> 00:53:57,599
class

00:53:55,440 --> 00:53:59,440
some member that tells me from which

00:53:57,599 --> 00:54:02,319
file and everything that i load is

00:53:59,440 --> 00:54:05,200
written into this byte stream

00:54:02,319 --> 00:54:07,200
this implementation now uses error codes

00:54:05,200 --> 00:54:09,200
and i should say this is actually a nice

00:54:07,200 --> 00:54:11,119
way to use error codes

00:54:09,200 --> 00:54:14,480
it's still easy to understand it deals

00:54:11,119 --> 00:54:18,160
with everything properly this is okay

00:54:14,480 --> 00:54:19,760
so um i first of all open the file with

00:54:18,160 --> 00:54:21,680
some

00:54:19,760 --> 00:54:23,520
things so the details are not so

00:54:21,680 --> 00:54:26,319
important i open it

00:54:23,520 --> 00:54:28,079
and if this fails well no problem i

00:54:26,319 --> 00:54:30,559
returned that there was an error

00:54:28,079 --> 00:54:32,000
if this was okay though i first query

00:54:30,559 --> 00:54:34,960
the size

00:54:32,000 --> 00:54:37,599
which might fail if this however failed

00:54:34,960 --> 00:54:40,640
i simply closed the filemanton

00:54:37,599 --> 00:54:41,839
and if this works i really do the the

00:54:40,640 --> 00:54:43,920
reading

00:54:41,839 --> 00:54:46,960
as i said it's more about the structure

00:54:43,920 --> 00:54:48,960
now it's not about the details

00:54:46,960 --> 00:54:50,400
now you can refactor this very very

00:54:48,960 --> 00:54:52,880
elegantly

00:54:50,400 --> 00:54:53,520
you just have to also first of all

00:54:52,880 --> 00:54:56,240
rework

00:54:53,520 --> 00:54:57,200
file because file as long as it works

00:54:56,240 --> 00:55:00,240
with error codes

00:54:57,200 --> 00:55:02,319
will not really work so let's assume

00:55:00,240 --> 00:55:04,000
that file has been restructured

00:55:02,319 --> 00:55:07,040
following these right principles

00:55:04,000 --> 00:55:08,640
now the constructor opens the file or

00:55:07,040 --> 00:55:10,799
throws an exception

00:55:08,640 --> 00:55:12,400
of course the destructor calls close

00:55:10,799 --> 00:55:14,880
when necessary

00:55:12,400 --> 00:55:15,760
get size and read these two functions

00:55:14,880 --> 00:55:21,839
also throw

00:55:15,760 --> 00:55:24,880
on error and return whatever is expected

00:55:21,839 --> 00:55:28,240
if you do that then the function

00:55:24,880 --> 00:55:29,520
suddenly might look like this you open

00:55:28,240 --> 00:55:31,680
the file

00:55:29,520 --> 00:55:32,960
if this doesn't work nothing bad happens

00:55:31,680 --> 00:55:34,559
but if it works

00:55:32,960 --> 00:55:36,960
i can continue to deal with a byte

00:55:34,559 --> 00:55:39,280
stream the byte stream might

00:55:36,960 --> 00:55:41,280
a constructor might fail but then file

00:55:39,280 --> 00:55:44,799
is cleaned up everything's okay again

00:55:41,280 --> 00:55:46,319
and if this works i can read and so on

00:55:44,799 --> 00:55:48,079
i do not have to explicitly deal with

00:55:46,319 --> 00:55:50,640
errors anymore

00:55:48,079 --> 00:55:51,599
note that this function is now called

00:55:50,640 --> 00:55:54,240
differently

00:55:51,599 --> 00:55:56,160
it has also different semantics it gets

00:55:54,240 --> 00:55:58,559
the file name as a parameter it returns

00:55:56,160 --> 00:56:01,520
a byte stream

00:55:58,559 --> 00:56:02,640
i changed a lot but this might be the

00:56:01,520 --> 00:56:05,520
function that i need

00:56:02,640 --> 00:56:07,040
and that here is the old function the

00:56:05,520 --> 00:56:10,400
old function that

00:56:07,040 --> 00:56:12,960
i called before um this function is now

00:56:10,400 --> 00:56:15,359
implemented in terms of the new one

00:56:12,960 --> 00:56:16,480
i embed the new function in a try catch

00:56:15,359 --> 00:56:19,200
block

00:56:16,480 --> 00:56:19,599
and simply return what i returned before

00:56:19,200 --> 00:56:22,720
true

00:56:19,599 --> 00:56:25,920
in the case of success

00:56:22,720 --> 00:56:28,240
false in the case of an error it

00:56:25,920 --> 00:56:29,599
is the same code but sounds like it's so

00:56:28,240 --> 00:56:33,280
much nicer to read

00:56:29,599 --> 00:56:36,880
so much nicer to to deal with

00:56:33,280 --> 00:56:39,359
all right and so yes you can indeed

00:56:36,880 --> 00:56:40,640
deal with this with these steps even in

00:56:39,359 --> 00:56:42,480
a large code base

00:56:40,640 --> 00:56:43,760
because usually you deal with this in

00:56:42,480 --> 00:56:46,240
small bytes

00:56:43,760 --> 00:56:48,559
it should be part of regular maintenance

00:56:46,240 --> 00:56:51,440
and the big code base is never at risk

00:56:48,559 --> 00:56:51,760
you can actually deal with this locally

00:56:51,440 --> 00:56:55,040
so

00:56:51,760 --> 00:56:57,359
again i point out this is exactly what

00:56:55,040 --> 00:56:58,319
john kopp meant with his promise code

00:56:57,359 --> 00:57:02,720
just becomes

00:56:58,319 --> 00:57:06,400
more beautiful more readable

00:57:02,720 --> 00:57:08,240
so i hope that this was a reasonable

00:57:06,400 --> 00:57:10,880
give you a reasonable idea of how to

00:57:08,240 --> 00:57:12,640
work with exceptions but also

00:57:10,880 --> 00:57:14,240
that a lot of the problems that we have

00:57:12,640 --> 00:57:15,040
with exceptions are not really about

00:57:14,240 --> 00:57:16,640
exceptions

00:57:15,040 --> 00:57:18,160
but about the code that is surrounding

00:57:16,640 --> 00:57:20,400
the exceptions

00:57:18,160 --> 00:57:22,720
writing better code dealing with

00:57:20,400 --> 00:57:23,760
exceptions actually becomes easier

00:57:22,720 --> 00:57:25,520
so thank you very much for your

00:57:23,760 --> 00:57:27,200
attention and of course i'm happy to

00:57:25,520 --> 00:57:30,000
take a couple of questions

00:57:27,200 --> 00:57:30,000
if there's time left

00:57:32,720 --> 00:57:37,760
all right so there is a question um can

00:57:35,359 --> 00:57:38,480
you re-explain potentially slices the

00:57:37,760 --> 00:57:40,240
exception

00:57:38,480 --> 00:57:42,400
under the topic of catching exceptions

00:57:40,240 --> 00:57:45,839
by reciprocates

00:57:42,400 --> 00:57:46,480
so potentially slices let me see if i

00:57:45,839 --> 00:57:50,000
can really

00:57:46,480 --> 00:57:50,000
quickly go back to this slide

00:57:50,160 --> 00:57:57,920
that might make it a little easier

00:57:54,720 --> 00:57:57,920
um so

00:57:59,359 --> 00:58:05,440
here we are so potentially slices

00:58:02,799 --> 00:58:06,880
if you throw an exception object itself

00:58:05,440 --> 00:58:10,079
it's not sliced

00:58:06,880 --> 00:58:12,000
but as soon as you have anything that is

00:58:10,079 --> 00:58:15,280
deriving from exception

00:58:12,000 --> 00:58:17,599
it will definitely be sliced um so

00:58:15,280 --> 00:58:19,680
it entirely depends on what you actually

00:58:17,599 --> 00:58:21,760
throw and what you expect

00:58:19,680 --> 00:58:23,599
in case you catch them net exception i

00:58:21,760 --> 00:58:25,680
would guess that this d

00:58:23,599 --> 00:58:26,640
really deals that this really causes

00:58:25,680 --> 00:58:29,359
slicing

00:58:26,640 --> 00:58:29,920
but if you throw something different and

00:58:29,359 --> 00:58:32,319
you

00:58:29,920 --> 00:58:34,640
expect it in exactly that form it is

00:58:32,319 --> 00:58:37,440
just copied unnecessarily it is not

00:58:34,640 --> 00:58:39,920
necessarily sliced it entirely depends

00:58:37,440 --> 00:58:42,480
on this combination

00:58:39,920 --> 00:58:44,079
okay second question in an embedded

00:58:42,480 --> 00:58:45,760
system that is multi-process

00:58:44,079 --> 00:58:47,599
and multi-threaded is it workable to

00:58:45,760 --> 00:58:49,119
allow exceptions in any process without

00:58:47,599 --> 00:58:52,000
real-time deadlines

00:58:49,119 --> 00:58:52,880
and restrict in process with real time

00:58:52,000 --> 00:58:56,480
and restrict

00:58:52,880 --> 00:58:59,839
in process with real-time deadlines

00:58:56,480 --> 00:59:02,000
okay this is definitely a great question

00:58:59,839 --> 00:59:04,000
a longer answer however this is perfect

00:59:02,000 --> 00:59:06,079
for the subsequent ama section

00:59:04,000 --> 00:59:07,440
now so i could invite you to just post a

00:59:06,079 --> 00:59:08,880
question again

00:59:07,440 --> 00:59:11,599
probably i don't have enough time to

00:59:08,880 --> 00:59:14,400
answer this in detail now

00:59:11,599 --> 00:59:17,119
which means i'm going to slide 78 let me

00:59:14,400 --> 00:59:19,760
quickly go there

00:59:17,119 --> 00:59:21,599
for the third question how does the use

00:59:19,760 --> 00:59:22,559
of make unique handle disallocating the

00:59:21,599 --> 00:59:24,880
memory

00:59:22,559 --> 00:59:28,799
and then allocating again in the copy

00:59:24,880 --> 00:59:28,799
constructor and copy assignment operator

00:59:29,440 --> 00:59:35,440
so make unique is essentially just

00:59:32,960 --> 00:59:38,319
calling new it is a wrapper around

00:59:35,440 --> 00:59:39,520
new which is fairly convenient because

00:59:38,319 --> 00:59:41,680
indeed in this course

00:59:39,520 --> 00:59:44,559
code you never have to deal with new or

00:59:41,680 --> 00:59:44,559
delete yourself

00:59:44,960 --> 00:59:50,000
in case however um anything happens

00:59:48,559 --> 00:59:53,599
during this new

00:59:50,000 --> 00:59:56,960
and the subsequent um constructor

00:59:53,599 --> 01:00:00,240
there's never an object that is created

00:59:56,960 --> 01:00:01,920
make unique fails completely

01:00:00,240 --> 01:00:04,160
and there's never any result it never

01:00:01,920 --> 01:00:06,480
returns me something uh that has been

01:00:04,160 --> 01:00:08,799
created because nothing has been created

01:00:06,480 --> 01:00:10,960
and so it's not really a problem for me

01:00:08,799 --> 01:00:11,680
there is no responsibility that i need

01:00:10,960 --> 01:00:15,119
to take

01:00:11,680 --> 01:00:17,280
care of um

01:00:15,119 --> 01:00:19,040
and so there is not no problem with

01:00:17,280 --> 01:00:21,040
disallocating anything

01:00:19,040 --> 01:00:23,200
perhaps there is one more detail to the

01:00:21,040 --> 01:00:26,400
story um

01:00:23,200 --> 01:00:29,760
if new indeed allocates and then the the

01:00:26,400 --> 01:00:33,760
constructive resource fails then the new

01:00:29,760 --> 01:00:36,640
promises us to also de-allocate again

01:00:33,760 --> 01:00:37,760
so i never get a pointer i would not be

01:00:36,640 --> 01:00:41,440
in a position to

01:00:37,760 --> 01:00:43,520
uh free the the this resource um

01:00:41,440 --> 01:00:45,760
because i did not really get the pointer

01:00:43,520 --> 01:00:48,400
nothing was assigned to pr

01:00:45,760 --> 01:00:49,760
also i wouldn't have a chance anyway new

01:00:48,400 --> 01:00:52,720
takes care of this

01:00:49,760 --> 01:00:54,319
it rolls back uh the memory allocation

01:00:52,720 --> 01:00:56,240
on its own

01:00:54,319 --> 01:00:57,760
so there is a difference between the new

01:00:56,240 --> 01:01:00,319
expression and

01:00:57,760 --> 01:01:02,559
operator new this is something that is

01:01:00,319 --> 01:01:04,960
important here

01:01:02,559 --> 01:01:05,680
all right i think that's the end of the

01:01:04,960 --> 01:01:08,480
question

01:01:05,680 --> 01:01:09,599
please of this session please if you

01:01:08,480 --> 01:01:10,880
have a couple of questions that you

01:01:09,599 --> 01:01:13,119
really want to be answered

01:01:10,880 --> 01:01:14,799
please just stay in this room um there

01:01:13,119 --> 01:01:17,440
is a subsequent amaze session

01:01:14,799 --> 01:01:18,720
you're quite invited to proceed to put

01:01:17,440 --> 01:01:21,760
participate there

01:01:18,720 --> 01:01:23,440
um else thanks a lot for attending i

01:01:21,760 --> 01:01:39,839
hope this was useful

01:01:23,440 --> 01:01:39,839
for you thank you very much

01:01:44,240 --> 01:01:46,319

YouTube URL: https://www.youtube.com/watch?v=0ojB8c0xUd8


