Title: How C++20 Changes the Way We Write Code - Timur Doumler - CppCon 2020
Publication date: 2020-10-09
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/how_cpp20_changes_the_way_we_write_code/how_cpp20_changes_the_way_we_write_code__timur_doumler__cppcon_2020.pdf
---
The upcoming C++20 standard is the biggest update in a decade. Its feature set and their impact on how we write C++ will be as large, and possibly larger than that of C++11.

In this talk we will look at how new features like concepts, coroutines, and modules will fundamentally change the way we design libraries, the way we think about functions, and even the way we compile our code. We will also mention some long-standing warts in C++ which are finally cured.

---
Timur Doumler is a C++ developer specialising in audio and music technology, an active member of the ISO C++ committee, and Conference Chair of the Audio Developer Conference (ADC). He is passionate about building communities, clean code, good tools, and the evolution of C++.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,639 --> 00:00:11,440
hello everyone

00:00:09,679 --> 00:00:14,080
my name is timur thank you very much for

00:00:11,440 --> 00:00:15,679
listening to my talk about cpr20

00:00:14,080 --> 00:00:17,520
so i've given quite a few talks at

00:00:15,679 --> 00:00:19,119
cppcon but

00:00:17,520 --> 00:00:20,720
um actually obviously this year it's

00:00:19,119 --> 00:00:21,840
different as you can see i'm giving my

00:00:20,720 --> 00:00:24,480
talk from home

00:00:21,840 --> 00:00:26,160
uh because of the pandemic so actually i

00:00:24,480 --> 00:00:27,439
have not done this before this is a new

00:00:26,160 --> 00:00:30,560
experience for me

00:00:27,439 --> 00:00:33,280
so i hope it's gonna work out um

00:00:30,560 --> 00:00:34,559
but actually i think with zebra says 20

00:00:33,280 --> 00:00:36,320
and the whole situation that's going on

00:00:34,559 --> 00:00:38,559
right now we actually got really lucky

00:00:36,320 --> 00:00:40,960
because um we had a committee meeting

00:00:38,559 --> 00:00:43,600
earlier this year in february 2020

00:00:40,960 --> 00:00:45,039
in prague and by the way thanks again

00:00:43,600 --> 00:00:46,399
hannah and avast for organizing this

00:00:45,039 --> 00:00:48,320
wonderful event

00:00:46,399 --> 00:00:50,079
um that was a picture of everyone who

00:00:48,320 --> 00:00:51,840
was there um

00:00:50,079 --> 00:00:53,680
i am somewhere in there as well so if

00:00:51,840 --> 00:00:55,120
you want to play west wally then you can

00:00:53,680 --> 00:00:58,879
try to find me there

00:00:55,120 --> 00:01:00,559
um and at that meeting we actually um

00:00:58,879 --> 00:01:01,199
finalized the technical work for c plus

00:01:00,559 --> 00:01:03,359
plus 20

00:01:01,199 --> 00:01:04,640
right and that was just just a few weeks

00:01:03,359 --> 00:01:06,479
before who

00:01:04,640 --> 00:01:08,159
um announced the global pandemic and

00:01:06,479 --> 00:01:09,439
everyone started to shut down and get

00:01:08,159 --> 00:01:12,320
cancelled

00:01:09,439 --> 00:01:14,000
so i'd say that was pretty good timing

00:01:12,320 --> 00:01:17,680
um and actually just two weeks

00:01:14,000 --> 00:01:18,320
from today um just two weeks ago cps 20

00:01:17,680 --> 00:01:21,119
uh the

00:01:18,320 --> 00:01:21,920
sus 20 draft international standard has

00:01:21,119 --> 00:01:23,680
passed

00:01:21,920 --> 00:01:25,360
the international ballot which means

00:01:23,680 --> 00:01:26,799
that now it's all approved

00:01:25,360 --> 00:01:28,720
it will now just take a couple weeks

00:01:26,799 --> 00:01:29,600
before um iso is going to publish the

00:01:28,720 --> 00:01:32,000
new civil assessment

00:01:29,600 --> 00:01:33,520
standard on their website as the new

00:01:32,000 --> 00:01:35,119
official standard so that's just a

00:01:33,520 --> 00:01:38,720
formality at this point

00:01:35,119 --> 00:01:40,640
so uh superstars20 is done yay

00:01:38,720 --> 00:01:41,920
and um yeah as you can see on the

00:01:40,640 --> 00:01:43,840
previous picture uh

00:01:41,920 --> 00:01:45,360
the superstars committee actually has

00:01:43,840 --> 00:01:47,920
grown in size

00:01:45,360 --> 00:01:48,960
quite significantly from what it was in

00:01:47,920 --> 00:01:50,640
the 90s

00:01:48,960 --> 00:01:52,880
and not only did the committee grow in

00:01:50,640 --> 00:01:55,040
size not in not only uh

00:01:52,880 --> 00:01:56,560
the number of proposals go grow in size

00:01:55,040 --> 00:01:58,079
but also the number of pages in the

00:01:56,560 --> 00:02:01,280
sequester standard document

00:01:58,079 --> 00:02:02,640
um grew as well so here's a graph of the

00:02:01,280 --> 00:02:03,200
number of pages of all the different

00:02:02,640 --> 00:02:06,320
published

00:02:03,200 --> 00:02:08,080
cpu standards as you can see while um

00:02:06,320 --> 00:02:09,440
philosophy 98 had seven hundred

00:02:08,080 --> 00:02:13,599
something pages

00:02:09,440 --> 00:02:15,200
uh cbs 20 now has um 1800 pages

00:02:13,599 --> 00:02:17,440
and from the number of pages it's not

00:02:15,200 --> 00:02:18,640
immediately obvious um which of these

00:02:17,440 --> 00:02:20,640
standard versions were the most

00:02:18,640 --> 00:02:22,560
significant in terms of impact on the

00:02:20,640 --> 00:02:24,560
cpus ecosystem

00:02:22,560 --> 00:02:26,160
and and what i mean by significant is

00:02:24,560 --> 00:02:27,680
not just adding you know a bunch of cool

00:02:26,160 --> 00:02:28,720
features that you might want to use or

00:02:27,680 --> 00:02:30,879
choose to use

00:02:28,720 --> 00:02:33,040
but really fundamentally changing the

00:02:30,879 --> 00:02:33,840
way we think about tps code the way you

00:02:33,040 --> 00:02:36,959
write cpus

00:02:33,840 --> 00:02:39,920
code and the last touch release

00:02:36,959 --> 00:02:40,879
um was the super splash 11. um so let's

00:02:39,920 --> 00:02:43,200
remember why

00:02:40,879 --> 00:02:43,200
um

00:02:44,959 --> 00:02:52,239
hang on my remote okay now it works

00:02:49,040 --> 00:02:55,120
um so let's remember how we had to write

00:02:52,239 --> 00:02:57,200
um code before c plus 11. so let's

00:02:55,120 --> 00:03:00,000
suppose you have some kind of vector

00:02:57,200 --> 00:03:01,599
and um if you want to iterate over that

00:03:00,000 --> 00:03:03,440
vector before c source 11

00:03:01,599 --> 00:03:04,879
you actually have to write out the

00:03:03,440 --> 00:03:06,480
iterator type because we didn't have

00:03:04,879 --> 00:03:07,840
auto and those iterated types could be

00:03:06,480 --> 00:03:09,840
arbitrarily long

00:03:07,840 --> 00:03:11,120
if you wanted to sort that vector you

00:03:09,840 --> 00:03:13,120
had to actually create

00:03:11,120 --> 00:03:14,800
a sorted type class you have to

00:03:13,120 --> 00:03:16,080
instantiate it you have to pass it into

00:03:14,800 --> 00:03:18,480
the sort algorithm because we didn't

00:03:16,080 --> 00:03:20,080
have lambdas yet

00:03:18,480 --> 00:03:21,519
and then actually whenever you had

00:03:20,080 --> 00:03:22,959
nested templates you had to put this

00:03:21,519 --> 00:03:25,040
like weird white space

00:03:22,959 --> 00:03:26,400
um in between the closing angle brackets

00:03:25,040 --> 00:03:28,480
because um

00:03:26,400 --> 00:03:29,920
the lexer would always treat two angle

00:03:28,480 --> 00:03:32,159
brackets in a row as

00:03:29,920 --> 00:03:33,440
a right shift operator and then finally

00:03:32,159 --> 00:03:34,560
we couldn't even initialize a vector

00:03:33,440 --> 00:03:35,920
like that right because we didn't have

00:03:34,560 --> 00:03:37,519
list initialization so

00:03:35,920 --> 00:03:38,959
in order to initialize a vector or any

00:03:37,519 --> 00:03:40,799
other kind of container

00:03:38,959 --> 00:03:42,720
um here you would have to just manually

00:03:40,799 --> 00:03:44,480
do pushback so do pushbacks in the loop

00:03:42,720 --> 00:03:45,519
or we had some horrible boost markers

00:03:44,480 --> 00:03:47,599
for that

00:03:45,519 --> 00:03:49,200
so so that was that was how we used to

00:03:47,599 --> 00:03:50,640
write c plus plus code and see since it

00:03:49,200 --> 00:03:52,400
was 11

00:03:50,640 --> 00:03:53,680
you know this looks a lot more familiar

00:03:52,400 --> 00:03:55,120
and a lot more clean this is how you

00:03:53,680 --> 00:03:56,560
write tv stuff today

00:03:55,120 --> 00:03:58,560
because we have all two we have rage

00:03:56,560 --> 00:04:00,720
paints before we have lambdas

00:03:58,560 --> 00:04:02,879
and the addition of all these features

00:04:00,720 --> 00:04:04,080
has really significantly changed the way

00:04:02,879 --> 00:04:06,000
you write

00:04:04,080 --> 00:04:08,319
cpus plus code and today the way

00:04:06,000 --> 00:04:11,760
everyone writes sequence does code

00:04:08,319 --> 00:04:13,599
so looking at this graph again cps20

00:04:11,760 --> 00:04:15,120
didn't add quite as many pages that

00:04:13,599 --> 00:04:18,320
superstars 11 did

00:04:15,120 --> 00:04:20,239
and in fact cbs 17 added a little bit

00:04:18,320 --> 00:04:23,600
more pages to the standard than cbs

00:04:20,239 --> 00:04:25,199
20 did so it seems that cbs 20 wouldn't

00:04:23,600 --> 00:04:27,680
be more significant than cbs

00:04:25,199 --> 00:04:29,520
17 if you judge by the number of pages

00:04:27,680 --> 00:04:32,160
but it turns out that counting the pages

00:04:29,520 --> 00:04:34,240
is not a very good metric because um

00:04:32,160 --> 00:04:36,320
first of all one thing that we had to do

00:04:34,240 --> 00:04:38,080
from superstar 17 to super soft 20 is

00:04:36,320 --> 00:04:41,040
that we had to change

00:04:38,080 --> 00:04:41,600
the paper size of the standard document

00:04:41,040 --> 00:04:45,040
from

00:04:41,600 --> 00:04:45,520
us letter to a4 right so that shaved off

00:04:45,040 --> 00:04:49,120
several

00:04:45,520 --> 00:04:51,280
100 pages and then more importantly

00:04:49,120 --> 00:04:53,600
um a lot of the pages that got out of

00:04:51,280 --> 00:04:54,960
the cpu 17 were

00:04:53,600 --> 00:04:56,639
like library features that were

00:04:54,960 --> 00:04:57,120
previously already available in boost

00:04:56,639 --> 00:05:00,400
such as

00:04:57,120 --> 00:05:02,400
file system annie optional variant stuff

00:05:00,400 --> 00:05:04,800
like that cbs 17 added

00:05:02,400 --> 00:05:06,400
a few core language features things like

00:05:04,800 --> 00:05:08,320
structure bindings and

00:05:06,400 --> 00:05:09,520
plus temporary production but i would

00:05:08,320 --> 00:05:11,280
argue that those

00:05:09,520 --> 00:05:13,919
those are kind of more or less syntactic

00:05:11,280 --> 00:05:15,120
sugar those are things that let you add

00:05:13,919 --> 00:05:16,639
let you write things a little bit

00:05:15,120 --> 00:05:17,759
shorter that you could already write

00:05:16,639 --> 00:05:20,400
before

00:05:17,759 --> 00:05:21,039
but cbs 20 is different because the

00:05:20,400 --> 00:05:23,600
stuff that's

00:05:21,039 --> 00:05:25,520
just 20 added um really changes the

00:05:23,600 --> 00:05:27,759
language much more fundamentally

00:05:25,520 --> 00:05:28,560
it changes the way you think about code

00:05:27,759 --> 00:05:30,880
it changes

00:05:28,560 --> 00:05:32,880
our mental model of what a function is

00:05:30,880 --> 00:05:35,919
how to write a template

00:05:32,880 --> 00:05:38,080
how to um how to um design a library

00:05:35,919 --> 00:05:39,600
how to organize package and compile a c

00:05:38,080 --> 00:05:41,919
plus plus program

00:05:39,600 --> 00:05:43,919
so that's why i think cyberstars20 is

00:05:41,919 --> 00:05:46,639
actually the most significant update of

00:05:43,919 --> 00:05:48,800
c plus plus in its entire history

00:05:46,639 --> 00:05:50,240
and in this talk i want to explain why i

00:05:48,800 --> 00:05:52,960
think that is

00:05:50,240 --> 00:05:54,639
so last year at tppcon i gave this talk

00:05:52,960 --> 00:05:55,440
about a bunch of small features in cpr

00:05:54,639 --> 00:05:56,960
source 20.

00:05:55,440 --> 00:05:59,120
but i think really the reason why the

00:05:56,960 --> 00:06:00,960
sus 20 is such a significant update is

00:05:59,120 --> 00:06:03,280
because of the big features

00:06:00,960 --> 00:06:04,400
and mostly because of the big four as

00:06:03,280 --> 00:06:07,600
some people call them

00:06:04,400 --> 00:06:10,720
coroutines concepts ranges and modules

00:06:07,600 --> 00:06:11,919
so let's talk about those let's um start

00:06:10,720 --> 00:06:13,199
with quarantines

00:06:11,919 --> 00:06:15,840
um but before we can talk about

00:06:13,199 --> 00:06:18,800
quarantines let's talk about functions

00:06:15,840 --> 00:06:20,240
what's a function so what's our mental

00:06:18,800 --> 00:06:22,800
model of a function

00:06:20,240 --> 00:06:24,639
basically a function is is a block of

00:06:22,800 --> 00:06:26,160
code that has a name you can call it you

00:06:24,639 --> 00:06:27,600
can pass it some parameters which i

00:06:26,160 --> 00:06:29,120
omitted here it's not particularly

00:06:27,600 --> 00:06:30,479
important for the purposes of our talk

00:06:29,120 --> 00:06:32,319
here

00:06:30,479 --> 00:06:33,919
it has some local stack variables that

00:06:32,319 --> 00:06:34,639
execute some code and then it returns a

00:06:33,919 --> 00:06:37,680
value

00:06:34,639 --> 00:06:38,400
okay so that is kind of our mental model

00:06:37,680 --> 00:06:40,720
of a function

00:06:38,400 --> 00:06:42,400
it didn't really change since the 50s uh

00:06:40,720 --> 00:06:44,000
they used to call them subroutines they

00:06:42,400 --> 00:06:44,880
still call them like latin fortran i

00:06:44,000 --> 00:06:46,080
believe

00:06:44,880 --> 00:06:48,479
it's pretty much the same thing it's

00:06:46,080 --> 00:06:49,599
been around forever you know we all know

00:06:48,479 --> 00:06:51,520
this stuff

00:06:49,599 --> 00:06:53,120
so let's uh let's look at functions

00:06:51,520 --> 00:06:55,919
let's have you have a function uh

00:06:53,120 --> 00:06:56,720
called f um and then we're gonna call it

00:06:55,919 --> 00:06:58,000
we're gonna

00:06:56,720 --> 00:06:59,919
get its value and then we're gonna print

00:06:58,000 --> 00:07:02,720
that line okay

00:06:59,919 --> 00:07:04,479
so let's say the function returns zero

00:07:02,720 --> 00:07:06,400
okay so now we are

00:07:04,479 --> 00:07:08,240
um it returns zero so now we're going to

00:07:06,400 --> 00:07:10,880
get zero and

00:07:08,240 --> 00:07:12,400
zero right so there's this concept of a

00:07:10,880 --> 00:07:13,520
pure function which is a function

00:07:12,400 --> 00:07:14,880
essentially that gives you the same

00:07:13,520 --> 00:07:17,759
output every time

00:07:14,880 --> 00:07:18,319
f obviously is a pure function so if you

00:07:17,759 --> 00:07:19,759
call f

00:07:18,319 --> 00:07:21,840
three times and print the result three

00:07:19,759 --> 00:07:24,720
times you're gonna get zero three times

00:07:21,840 --> 00:07:26,639
okay so that's probably not really

00:07:24,720 --> 00:07:28,240
interesting

00:07:26,639 --> 00:07:30,319
but what if you want the function to

00:07:28,240 --> 00:07:31,599
return different values every time and

00:07:30,319 --> 00:07:32,639
let's come up with a really simple

00:07:31,599 --> 00:07:34,800
example let's say

00:07:32,639 --> 00:07:37,680
instead of zero zero zero you wanna have

00:07:34,800 --> 00:07:41,039
a sequence like zero one two three

00:07:37,680 --> 00:07:44,479
so how do we implement that um

00:07:41,039 --> 00:07:45,599
and obviously the kind of simplest way

00:07:44,479 --> 00:07:47,599
you could possibly do this

00:07:45,599 --> 00:07:49,120
is you just go in main just write a loop

00:07:47,599 --> 00:07:51,120
right and you just increment the loop

00:07:49,120 --> 00:07:53,120
counter and just print that loop counter

00:07:51,120 --> 00:07:55,039
so we can write that that's very simple

00:07:53,120 --> 00:07:56,160
um but then practice you don't really

00:07:55,039 --> 00:07:57,680
want to write code like that right

00:07:56,160 --> 00:07:58,000
that's not very modular so what you want

00:07:57,680 --> 00:08:00,000
to do

00:07:58,000 --> 00:08:02,240
is you want to kind of separate

00:08:00,000 --> 00:08:04,319
generating the sequence from printing it

00:08:02,240 --> 00:08:05,680
because that's good design so how do we

00:08:04,319 --> 00:08:07,680
do that

00:08:05,680 --> 00:08:09,039
um one thing we could do is we could uh

00:08:07,680 --> 00:08:11,199
generate the sequence and put it in a

00:08:09,039 --> 00:08:13,120
container like a vector

00:08:11,199 --> 00:08:14,639
right and then the vector we could

00:08:13,120 --> 00:08:16,240
initialize using list initialization

00:08:14,639 --> 00:08:17,199
like here we could fill the vector using

00:08:16,240 --> 00:08:19,599
the loop

00:08:17,199 --> 00:08:20,960
uh probably better uh we could fill the

00:08:19,599 --> 00:08:22,879
vector using an algorithm there's

00:08:20,960 --> 00:08:25,280
actually in the stl an algorithm called

00:08:22,879 --> 00:08:26,639
studiota which generates the sequence

00:08:25,280 --> 00:08:28,319
so we could use that and we're going to

00:08:26,639 --> 00:08:31,520
talk about algorithms later

00:08:28,319 --> 00:08:32,719
but um however we do this um

00:08:31,520 --> 00:08:34,959
we are kind of storing the whole

00:08:32,719 --> 00:08:35,919
sequence the downside of this procedural

00:08:34,959 --> 00:08:37,839
approach that you

00:08:35,919 --> 00:08:40,240
you have to store this whole sequence in

00:08:37,839 --> 00:08:41,519
memory before you print it right

00:08:40,240 --> 00:08:43,360
and if you want to print all the numbers

00:08:41,519 --> 00:08:44,800
from zero to one billion

00:08:43,360 --> 00:08:46,560
that's probably not going to be a great

00:08:44,800 --> 00:08:48,399
approach so

00:08:46,560 --> 00:08:50,160
what we want really to make this more

00:08:48,399 --> 00:08:52,240
optimal is you want to um generate the

00:08:50,160 --> 00:08:53,360
sequence lazily right like we did in the

00:08:52,240 --> 00:08:54,399
previous slide where you just had the

00:08:53,360 --> 00:08:56,640
loop you want to

00:08:54,399 --> 00:08:58,480
generate each number as you print it as

00:08:56,640 --> 00:09:01,040
we need it right

00:08:58,480 --> 00:09:01,680
um but still you want to general

00:09:01,040 --> 00:09:03,440
separate

00:09:01,680 --> 00:09:05,440
generation of the sequence from printing

00:09:03,440 --> 00:09:08,000
the sequence

00:09:05,440 --> 00:09:09,519
so let's think about how we do that um

00:09:08,000 --> 00:09:11,279
let's forget about the container thing

00:09:09,519 --> 00:09:14,720
and let's go back to the function

00:09:11,279 --> 00:09:17,920
so how do we implement the function f

00:09:14,720 --> 00:09:20,160
such that it prints 0 1 2 and just think

00:09:17,920 --> 00:09:21,680
about that for a second

00:09:20,160 --> 00:09:23,279
one thing we could do which we could

00:09:21,680 --> 00:09:26,880
always do since before c plus

00:09:23,279 --> 00:09:28,640
98 is um well we could make a counter

00:09:26,880 --> 00:09:30,240
which is a static variable right

00:09:28,640 --> 00:09:32,399
and then we can just increment that and

00:09:30,240 --> 00:09:34,399
that static variable is going to persist

00:09:32,399 --> 00:09:36,000
uh next time around we call f it's going

00:09:34,399 --> 00:09:37,519
to still have the value it had the last

00:09:36,000 --> 00:09:39,600
time so it's going to remember its value

00:09:37,519 --> 00:09:41,279
so we're going to get the sequence

00:09:39,600 --> 00:09:43,200
but that's not really great because what

00:09:41,279 --> 00:09:43,680
we did here is we just introduced global

00:09:43,200 --> 00:09:47,440
state

00:09:43,680 --> 00:09:50,320
right so that really isn't a good idea

00:09:47,440 --> 00:09:52,000
so how do we solve this problem without

00:09:50,320 --> 00:09:54,800
introducing global state

00:09:52,000 --> 00:09:56,399
and then what you know you kind of end

00:09:54,800 --> 00:09:57,200
up doing is what you all know what

00:09:56,399 --> 00:09:59,920
you're all used to

00:09:57,200 --> 00:10:01,279
is you implement a class you generate a

00:09:59,920 --> 00:10:03,120
class that's going to generate you that

00:10:01,279 --> 00:10:05,920
sequence right so

00:10:03,120 --> 00:10:08,240
here i have a class my generator i keep

00:10:05,920 --> 00:10:09,760
the counter as a member variable i

00:10:08,240 --> 00:10:11,519
um then i have this we have this call

00:10:09,760 --> 00:10:12,800
operator here which is going to return

00:10:11,519 --> 00:10:14,079
the current value and increment the

00:10:12,800 --> 00:10:16,079
counter

00:10:14,079 --> 00:10:18,240
um and then we call that to generate

00:10:16,079 --> 00:10:19,920
more numbers right um

00:10:18,240 --> 00:10:21,120
and this is object-oriented programming

00:10:19,920 --> 00:10:23,279
this is what we've all been doing for

00:10:21,120 --> 00:10:25,360
decades and it works

00:10:23,279 --> 00:10:26,720
but i would argue that for a task like

00:10:25,360 --> 00:10:28,800
generating the sequence

00:10:26,720 --> 00:10:29,839
um it's kind of the wrong approach it's

00:10:28,800 --> 00:10:32,399
kind of overkill

00:10:29,839 --> 00:10:32,880
right so imagine what we have to do we

00:10:32,399 --> 00:10:35,519
have to

00:10:32,880 --> 00:10:36,959
generate a new type uh we have to decide

00:10:35,519 --> 00:10:38,160
what member variables we're gonna have

00:10:36,959 --> 00:10:39,680
we're gonna have to decide whether

00:10:38,160 --> 00:10:41,040
they're private or public

00:10:39,680 --> 00:10:42,959
you know we're gonna think about what

00:10:41,040 --> 00:10:43,839
api does this class have we're gonna

00:10:42,959 --> 00:10:45,440
think about

00:10:43,839 --> 00:10:47,440
what class and variance does this cloud

00:10:45,440 --> 00:10:48,640
have right so there's a lot of stuff to

00:10:47,440 --> 00:10:52,079
think about and we think

00:10:48,640 --> 00:10:52,800
in objects right and for a task like

00:10:52,079 --> 00:10:55,279
generating a

00:10:52,800 --> 00:10:57,120
sequence of numbers this is too

00:10:55,279 --> 00:10:57,760
complicated this just doesn't feel right

00:10:57,120 --> 00:11:00,160
so this is

00:10:57,760 --> 00:11:02,160
the wrong way to think about this code

00:11:00,160 --> 00:11:03,440
and um since it says 11 there was

00:11:02,160 --> 00:11:05,760
actually a slightly different way of

00:11:03,440 --> 00:11:09,120
writing this code so we can use lambdas

00:11:05,760 --> 00:11:10,480
and since he does 14 actually um we have

00:11:09,120 --> 00:11:13,519
this init capture feature

00:11:10,480 --> 00:11:14,480
um but that is still the same code right

00:11:13,519 --> 00:11:15,839
that's just like a little bit of

00:11:14,480 --> 00:11:17,920
syntactic sugar

00:11:15,839 --> 00:11:19,120
on top of the previous slide essentially

00:11:17,920 --> 00:11:21,040
right so

00:11:19,120 --> 00:11:22,160
uh we still have to explicitly create

00:11:21,040 --> 00:11:24,640
this object state

00:11:22,160 --> 00:11:27,839
and and in the form of a member variable

00:11:24,640 --> 00:11:29,920
which is now in the inner capture

00:11:27,839 --> 00:11:31,040
ah it's still the same stuff right but

00:11:29,920 --> 00:11:32,399
it turns out

00:11:31,040 --> 00:11:35,360
we don't actually have to think in

00:11:32,399 --> 00:11:38,640
objects at all so let's go back

00:11:35,360 --> 00:11:39,600
to functions turns out we don't actually

00:11:38,640 --> 00:11:42,880
need to store

00:11:39,600 --> 00:11:43,760
explicitly um state in member variables

00:11:42,880 --> 00:11:46,640
because

00:11:43,760 --> 00:11:48,399
the function already has stage right so

00:11:46,640 --> 00:11:50,399
this function already has state in form

00:11:48,399 --> 00:11:50,639
of just its local member variables right

00:11:50,399 --> 00:11:52,959
in

00:11:50,639 --> 00:11:54,560
x equals zero that's that's a state

00:11:52,959 --> 00:11:56,079
right

00:11:54,560 --> 00:11:57,920
so in order to make this all work we

00:11:56,079 --> 00:11:59,120
just need to expand our mental model of

00:11:57,920 --> 00:12:02,720
what a function is

00:11:59,120 --> 00:12:03,120
just a little bit and have to imagine

00:12:02,720 --> 00:12:05,600
that

00:12:03,120 --> 00:12:07,040
um let's just add a little bit to that

00:12:05,600 --> 00:12:10,160
function and let's

00:12:07,040 --> 00:12:11,680
say that the function now can start

00:12:10,160 --> 00:12:13,279
running

00:12:11,680 --> 00:12:14,800
you have this local variable and then

00:12:13,279 --> 00:12:17,519
you can yield

00:12:14,800 --> 00:12:19,279
an in intermediate value and then that's

00:12:17,519 --> 00:12:21,360
going to return control back to the

00:12:19,279 --> 00:12:22,839
the calling code but the function is

00:12:21,360 --> 00:12:24,320
going to still remember its local

00:12:22,839 --> 00:12:26,000
variables

00:12:24,320 --> 00:12:27,279
and then the next time next time around

00:12:26,000 --> 00:12:29,120
you call the function it's going to jump

00:12:27,279 --> 00:12:30,399
back into where it was at the yield it's

00:12:29,120 --> 00:12:32,560
still going to remember all these local

00:12:30,399 --> 00:12:35,760
variables and now it just keeps going

00:12:32,560 --> 00:12:38,639
okay until the next yield or until i

00:12:35,760 --> 00:12:41,200
return at the end

00:12:38,639 --> 00:12:43,040
and that's essentially what a coating is

00:12:41,200 --> 00:12:44,000
and this concept is also not new it's

00:12:43,040 --> 00:12:47,279
been around

00:12:44,000 --> 00:12:48,959
since the 60s so um finally after six

00:12:47,279 --> 00:12:50,240
decades we see bus people

00:12:48,959 --> 00:12:52,639
caught up with the rest of the world

00:12:50,240 --> 00:12:54,959
which i think is good um

00:12:52,639 --> 00:12:56,800
here's a paper by uh melvin conway uh

00:12:54,959 --> 00:12:59,519
describing what the court he knows in

00:12:56,800 --> 00:13:01,680
1963. um by the way that's the same

00:12:59,519 --> 00:13:03,120
conway who coined conway's law but it's

00:13:01,680 --> 00:13:05,040
not the same convey who invented

00:13:03,120 --> 00:13:07,680
conway's game of life

00:13:05,040 --> 00:13:09,519
but anyway so now that we have this

00:13:07,680 --> 00:13:11,920
expanded mental model

00:13:09,519 --> 00:13:13,040
let's see if we can um solve this

00:13:11,920 --> 00:13:13,680
problem of the sequence for the

00:13:13,040 --> 00:13:16,720
choroidine

00:13:13,680 --> 00:13:19,360
and if you just kind of keep that mental

00:13:16,720 --> 00:13:20,880
model in mind maybe intuitively

00:13:19,360 --> 00:13:22,560
how you would want to write this code

00:13:20,880 --> 00:13:25,680
not now that you have this yield thing

00:13:22,560 --> 00:13:27,279
um is something like this right so

00:13:25,680 --> 00:13:28,399
this is not real superstar's code but

00:13:27,279 --> 00:13:30,399
this is kind of what you would

00:13:28,399 --> 00:13:32,000
intuitively like to write when you

00:13:30,399 --> 00:13:34,880
first come across this concept of

00:13:32,000 --> 00:13:36,000
recording right so the counter now is

00:13:34,880 --> 00:13:37,839
just a local variable

00:13:36,000 --> 00:13:39,360
and then we just enter a loop and in

00:13:37,839 --> 00:13:41,120
that loop we're just going to yield

00:13:39,360 --> 00:13:42,720
um the current value and increment the

00:13:41,120 --> 00:13:43,680
counter right and next time around we

00:13:42,720 --> 00:13:45,440
call this function

00:13:43,680 --> 00:13:47,040
you got to just go back into the loop do

00:13:45,440 --> 00:13:48,240
one more iteration increment the counter

00:13:47,040 --> 00:13:49,839
return the value next time

00:13:48,240 --> 00:13:51,519
we call the function again increment the

00:13:49,839 --> 00:13:53,600
contrary to underground

00:13:51,519 --> 00:13:54,720
so every time you call f you're just

00:13:53,600 --> 00:13:55,920
going to keep incrementing this thing

00:13:54,720 --> 00:13:57,199
and yielding

00:13:55,920 --> 00:14:00,839
and you're going to get the result that

00:13:57,199 --> 00:14:03,839
you want and that's super simple right

00:14:00,839 --> 00:14:04,720
unfortunately this is c so it's not

00:14:03,839 --> 00:14:07,839
quite as simple

00:14:04,720 --> 00:14:10,560
so this code actually won't compile

00:14:07,839 --> 00:14:11,360
first of all um instead of the keyword

00:14:10,560 --> 00:14:13,920
yield which

00:14:11,360 --> 00:14:15,519
most other programming languages use uh

00:14:13,920 --> 00:14:18,720
we have a keyword called

00:14:15,519 --> 00:14:20,160
cool yield uh because of reasons i'm not

00:14:18,720 --> 00:14:23,360
going to go into this now you can

00:14:20,160 --> 00:14:24,720
ask me afterwards um and the second

00:14:23,360 --> 00:14:26,800
thing which is more important

00:14:24,720 --> 00:14:28,480
is that the quartering is not going to

00:14:26,800 --> 00:14:30,160
return an end it's going to actually

00:14:28,480 --> 00:14:32,800
return a generator

00:14:30,160 --> 00:14:33,360
and then you have to call that generator

00:14:32,800 --> 00:14:36,000
um

00:14:33,360 --> 00:14:37,760
to actually get the values and so you

00:14:36,000 --> 00:14:39,600
have this like extra step

00:14:37,760 --> 00:14:41,040
and that is because cpus plus is not

00:14:39,600 --> 00:14:42,399
lying to you

00:14:41,040 --> 00:14:44,160
so what actually happens is that

00:14:42,399 --> 00:14:44,880
quotient does not return an end right it

00:14:44,160 --> 00:14:47,600
returns an

00:14:44,880 --> 00:14:49,600
object which through the quotient api

00:14:47,600 --> 00:14:50,959
will eventually give you an end

00:14:49,600 --> 00:14:52,160
and the way to think about this is that

00:14:50,959 --> 00:14:54,240
the quality is essentially like a

00:14:52,160 --> 00:14:55,360
generator factory so you call it to get

00:14:54,240 --> 00:14:56,560
a generator

00:14:55,360 --> 00:14:58,720
and then generator will give you the

00:14:56,560 --> 00:15:00,240
values and this extra step is there

00:14:58,720 --> 00:15:01,680
because there is a bunch of choices and

00:15:00,240 --> 00:15:03,120
how you might want to implement this

00:15:01,680 --> 00:15:05,920
generator

00:15:03,120 --> 00:15:07,440
and so superstars makes them explicit so

00:15:05,920 --> 00:15:08,480
it lets you implement the generators you

00:15:07,440 --> 00:15:11,440
can

00:15:08,480 --> 00:15:12,880
make those choices yourself um so it

00:15:11,440 --> 00:15:14,079
kind of gives you the option

00:15:12,880 --> 00:15:16,639
uh so you have to implement this

00:15:14,079 --> 00:15:18,320
generator and then uh it kind of exposes

00:15:16,639 --> 00:15:19,760
this whole underlying machinery to you

00:15:18,320 --> 00:15:21,040
which is the coordinating api and that's

00:15:19,760 --> 00:15:22,399
what you need to use in order to make

00:15:21,040 --> 00:15:25,440
this work

00:15:22,399 --> 00:15:28,720
so this might be a bit confusing so um

00:15:25,440 --> 00:15:30,320
it's actually not that unintuitive

00:15:28,720 --> 00:15:32,959
um if you just kind of take it apart so

00:15:30,320 --> 00:15:34,560
let's take it apart a little bit

00:15:32,959 --> 00:15:36,720
so here's the user code this is our main

00:15:34,560 --> 00:15:38,079
right it's going to call the coroutine

00:15:36,720 --> 00:15:39,040
you you're going to get generated and

00:15:38,079 --> 00:15:40,480
then we're going to call that to get

00:15:39,040 --> 00:15:43,759
more values

00:15:40,480 --> 00:15:45,120
so g is our generator now that's

00:15:43,759 --> 00:15:47,519
that's a stack variable in main right

00:15:45,120 --> 00:15:50,079
it's going to get allocated on the stack

00:15:47,519 --> 00:15:51,279
and what is g turns out g contains a

00:15:50,079 --> 00:15:52,560
bunch of stuff

00:15:51,279 --> 00:15:54,000
so the most important thing that you

00:15:52,560 --> 00:15:54,959
want you want our int back right so

00:15:54,000 --> 00:15:56,320
that's what you want to print you want

00:15:54,959 --> 00:15:58,880
to print zero one two three

00:15:56,320 --> 00:16:00,240
so anytime i need to get our in so it

00:15:58,880 --> 00:16:00,959
turns out that there is this thing

00:16:00,240 --> 00:16:02,880
called

00:16:00,959 --> 00:16:04,160
a promise type and that's the first

00:16:02,880 --> 00:16:06,720
thing that's going to be instantiated

00:16:04,160 --> 00:16:08,160
when you when you create this generator

00:16:06,720 --> 00:16:10,240
and that's essentially the box where the

00:16:08,160 --> 00:16:11,120
quarantine puts the end and where the

00:16:10,240 --> 00:16:13,440
user code

00:16:11,120 --> 00:16:15,279
can can get the end out again right so

00:16:13,440 --> 00:16:17,279
think of it as like a stood optional of

00:16:15,279 --> 00:16:19,360
int it's essentially a reusable box that

00:16:17,279 --> 00:16:21,120
can hold a single inch

00:16:19,360 --> 00:16:22,560
and that's essentially our communication

00:16:21,120 --> 00:16:25,120
channel right and everyone needs to have

00:16:22,560 --> 00:16:27,360
a reference to this promise type

00:16:25,120 --> 00:16:28,720
so that's one really important um uh

00:16:27,360 --> 00:16:30,240
object and then the other really

00:16:28,720 --> 00:16:32,160
important thing is this thing called the

00:16:30,240 --> 00:16:33,600
quotient handle

00:16:32,160 --> 00:16:36,079
and that thing is also going to get

00:16:33,600 --> 00:16:37,920
instantiated here and that's standard

00:16:36,079 --> 00:16:39,839
that's kind of a magic standard library

00:16:37,920 --> 00:16:42,160
type um and what it really is

00:16:39,839 --> 00:16:42,959
is pointer to something that's called

00:16:42,160 --> 00:16:46,160
the quarantine

00:16:42,959 --> 00:16:48,639
frame and what's the chord in frame

00:16:46,160 --> 00:16:50,000
um so think about a normal function the

00:16:48,639 --> 00:16:51,040
normal function has a thing that's

00:16:50,000 --> 00:16:52,959
called a stack frame

00:16:51,040 --> 00:16:54,639
okay in stack frame that's basically

00:16:52,959 --> 00:16:55,920
just the internal data structure that

00:16:54,639 --> 00:16:57,440
your machine needs

00:16:55,920 --> 00:16:59,040
in order to know how to call this

00:16:57,440 --> 00:17:01,120
function right

00:16:59,040 --> 00:17:02,800
so for a normal function the stack frame

00:17:01,120 --> 00:17:04,799
will contain um

00:17:02,800 --> 00:17:05,839
basically the parameters you pass in

00:17:04,799 --> 00:17:08,559
it's going to contain

00:17:05,839 --> 00:17:09,199
uh all the um local member variables

00:17:08,559 --> 00:17:10,640
that the

00:17:09,199 --> 00:17:13,439
function is going to create then it's

00:17:10,640 --> 00:17:15,280
going to contain um

00:17:13,439 --> 00:17:17,600
an address where to jump back to when

00:17:15,280 --> 00:17:19,600
the function returns right

00:17:17,600 --> 00:17:21,280
and for a function that stack frame is

00:17:19,600 --> 00:17:23,120
tied to the like the lifetime of that

00:17:21,280 --> 00:17:23,760
stack frame is tied to the stack right

00:17:23,120 --> 00:17:26,160
because

00:17:23,760 --> 00:17:27,520
when a function returns then all of its

00:17:26,160 --> 00:17:29,280
local

00:17:27,520 --> 00:17:31,039
all of its local variables they're going

00:17:29,280 --> 00:17:32,400
to get destroyed so

00:17:31,039 --> 00:17:34,799
it's gonna they're gonna get popped off

00:17:32,400 --> 00:17:36,240
the stack and and that's kind of how a

00:17:34,799 --> 00:17:37,840
normal function works

00:17:36,240 --> 00:17:39,280
so now the difference with the

00:17:37,840 --> 00:17:42,640
quarantine is that uh

00:17:39,280 --> 00:17:44,320
that state can persist so

00:17:42,640 --> 00:17:45,600
um according has a lifetime which is

00:17:44,320 --> 00:17:47,520
independent from that spec and that's

00:17:45,600 --> 00:17:49,039
why i need this pointed to it right so

00:17:47,520 --> 00:17:51,760
you can manage the lifetime of that

00:17:49,039 --> 00:17:54,960
quotient frame which is now not anymore

00:17:51,760 --> 00:17:56,960
tied to the lifetime of the step so

00:17:54,960 --> 00:17:58,640
um another way to think about this is if

00:17:56,960 --> 00:17:59,520
you think about this lambda again which

00:17:58,640 --> 00:18:01,840
we wrote here

00:17:59,520 --> 00:18:02,559
so we have this um this inner capture

00:18:01,840 --> 00:18:04,400
here right

00:18:02,559 --> 00:18:06,320
and the inner capture is kind of like

00:18:04,400 --> 00:18:08,799
the quality frame

00:18:06,320 --> 00:18:10,400
for this lambda because that's the thing

00:18:08,799 --> 00:18:10,880
that has all the local variables which

00:18:10,400 --> 00:18:13,440
is just

00:18:10,880 --> 00:18:14,000
the i in this case and so later you can

00:18:13,440 --> 00:18:15,919
enter that

00:18:14,000 --> 00:18:17,280
stage uh wherever you want just by

00:18:15,919 --> 00:18:18,320
calling that lambda so that's going to

00:18:17,280 --> 00:18:19,600
be the thing that's going to remember

00:18:18,320 --> 00:18:22,880
the state of your lambda which is just

00:18:19,600 --> 00:18:22,880
the value of i in this case

00:18:22,960 --> 00:18:27,600
and um so next time you call that lambda

00:18:26,080 --> 00:18:30,160
it's going to still know what the value

00:18:27,600 --> 00:18:31,600
of i is and the quarten is really just

00:18:30,160 --> 00:18:32,559
an extension of that like the only

00:18:31,600 --> 00:18:34,240
difference is that

00:18:32,559 --> 00:18:36,080
the protein has multiple entry points

00:18:34,240 --> 00:18:37,520
and multiple suspension points right but

00:18:36,080 --> 00:18:39,840
it still only has

00:18:37,520 --> 00:18:40,559
uh one uh quotient frame that persists

00:18:39,840 --> 00:18:42,000
all this time

00:18:40,559 --> 00:18:43,520
just like it does with this lambda where

00:18:42,000 --> 00:18:45,039
it has this like member variable i that

00:18:43,520 --> 00:18:48,000
persists all the time as long as

00:18:45,039 --> 00:18:48,960
lambda exists um so we can think of this

00:18:48,000 --> 00:18:50,559
lambda really as

00:18:48,960 --> 00:18:52,400
as kind of a very simple core routine

00:18:50,559 --> 00:18:54,080
right so with the restriction that it

00:18:52,400 --> 00:18:55,760
has to be entered from the top

00:18:54,080 --> 00:18:57,360
and it cannot be resumed it can only

00:18:55,760 --> 00:18:59,120
return but you can call it multiple

00:18:57,360 --> 00:19:00,640
times and quarteen

00:18:59,120 --> 00:19:01,760
according is kind of an extension of

00:19:00,640 --> 00:19:02,880
that in the sense that you can enter it

00:19:01,760 --> 00:19:04,400
from the middle and you can leave it

00:19:02,880 --> 00:19:07,120
from the middle

00:19:04,400 --> 00:19:08,000
and the other difference is that um the

00:19:07,120 --> 00:19:09,760
quarten frame

00:19:08,000 --> 00:19:11,840
this coaching frame for the lambda this

00:19:09,760 --> 00:19:13,919
i equals zero we know how big it is

00:19:11,840 --> 00:19:16,799
right so it's an integer so we know

00:19:13,919 --> 00:19:18,240
it's going to be uh four bytes um

00:19:16,799 --> 00:19:19,039
because that's the only member that this

00:19:18,240 --> 00:19:21,600
lambda has

00:19:19,039 --> 00:19:22,960
but the quality in general the compiler

00:19:21,600 --> 00:19:26,080
doesn't know how big the coordinating

00:19:22,960 --> 00:19:30,080
frame has to be at compile time

00:19:26,080 --> 00:19:32,000
so that coating frame

00:19:30,080 --> 00:19:33,360
will then need to go on this on the heap

00:19:32,000 --> 00:19:35,360
it's going to have to be dynamically

00:19:33,360 --> 00:19:38,000
allocated

00:19:35,360 --> 00:19:40,240
so then this is like this dynamically

00:19:38,000 --> 00:19:42,480
allocated object and the coaching handle

00:19:40,240 --> 00:19:43,440
is kind of this opaque type erased

00:19:42,480 --> 00:19:46,559
pointer

00:19:43,440 --> 00:19:48,320
uh to this object uh on the heap

00:19:46,559 --> 00:19:49,760
so that's the coding handle and that's

00:19:48,320 --> 00:19:51,440
the protein frame

00:19:49,760 --> 00:19:53,280
and the generator is really just the

00:19:51,440 --> 00:19:54,960
user facing object that kind of groups

00:19:53,280 --> 00:19:57,200
these two parts together

00:19:54,960 --> 00:19:59,919
and enforce this kind of coding api to

00:19:57,200 --> 00:20:02,799
the user code so you can use it

00:19:59,919 --> 00:20:03,360
so the important thing is so the coding

00:20:02,799 --> 00:20:06,159
frame

00:20:03,360 --> 00:20:07,679
is on the heap but the generator is on

00:20:06,159 --> 00:20:09,440
the stack right and if the generator

00:20:07,679 --> 00:20:11,360
manages the lifetime of the quotient

00:20:09,440 --> 00:20:14,159
frame for this quartering handle

00:20:11,360 --> 00:20:14,880
then when g the generator goes out of

00:20:14,159 --> 00:20:16,320
scope

00:20:14,880 --> 00:20:17,919
that's going to destroy the quarantine

00:20:16,320 --> 00:20:20,480
frame and that heat memory at that point

00:20:17,919 --> 00:20:22,559
will be deallocated

00:20:20,480 --> 00:20:24,799
okay and now the last piece of the

00:20:22,559 --> 00:20:25,760
puzzle is the actual code routine

00:20:24,799 --> 00:20:27,280
and that's the thing that's going to

00:20:25,760 --> 00:20:28,960
actually construct the coding frame and

00:20:27,280 --> 00:20:32,080
that's going to actually run the code

00:20:28,960 --> 00:20:34,000
that you wrote inside the quarantine and

00:20:32,080 --> 00:20:35,679
the interesting here is the interesting

00:20:34,000 --> 00:20:36,720
thing here is that the quotient object

00:20:35,679 --> 00:20:38,559
actually itself is

00:20:36,720 --> 00:20:40,400
generated by the compiler so that's why

00:20:38,559 --> 00:20:43,760
i drew this um dashed

00:20:40,400 --> 00:20:46,080
line in between um and that

00:20:43,760 --> 00:20:47,200
is because um basically that's subject

00:20:46,080 --> 00:20:48,799
to optimizations

00:20:47,200 --> 00:20:50,240
right so the compiler can optimize this

00:20:48,799 --> 00:20:51,760
quite quite a bit

00:20:50,240 --> 00:20:53,520
so that's in particular two important

00:20:51,760 --> 00:20:53,919
optimizations that the compiler is gonna

00:20:53,520 --> 00:20:56,480
do

00:20:53,919 --> 00:20:57,600
um one is that if you wrote this code in

00:20:56,480 --> 00:21:00,640
the core team

00:20:57,600 --> 00:21:01,840
um what it's gonna do it's gonna take

00:21:00,640 --> 00:21:03,360
that code and turn it into a state

00:21:01,840 --> 00:21:04,240
machine so it can actually manage all

00:21:03,360 --> 00:21:07,120
this like

00:21:04,240 --> 00:21:08,400
uh re-entrance behavior more efficiently

00:21:07,120 --> 00:21:10,000
so it's gonna turn this into something

00:21:08,400 --> 00:21:11,600
more complicated but you don't have to

00:21:10,000 --> 00:21:13,600
worry about that because you still

00:21:11,600 --> 00:21:15,039
wrote this code um in the query that

00:21:13,600 --> 00:21:16,880
looks really nice

00:21:15,039 --> 00:21:18,720
and and the other important optimization

00:21:16,880 --> 00:21:20,400
is that in general we said the quality

00:21:18,720 --> 00:21:21,679
frame is going to be on the heap because

00:21:20,400 --> 00:21:22,960
the compiler doesn't know how big it's

00:21:21,679 --> 00:21:25,360
going to be

00:21:22,960 --> 00:21:27,120
but sometimes the compiler can optimize

00:21:25,360 --> 00:21:28,720
away that heap allocation

00:21:27,120 --> 00:21:30,320
and that happens whenever the compiler

00:21:28,720 --> 00:21:32,400
can see through the lifetime of the

00:21:30,320 --> 00:21:34,320
coding frame you can prove

00:21:32,400 --> 00:21:36,080
that stops existing by the end of the

00:21:34,320 --> 00:21:37,200
function so that's exactly the case here

00:21:36,080 --> 00:21:39,840
right so

00:21:37,200 --> 00:21:41,280
um and on the left of the left hand side

00:21:39,840 --> 00:21:42,559
we have our main and then when all that

00:21:41,280 --> 00:21:44,480
goes out of scope

00:21:42,559 --> 00:21:46,960
our g is going to stop existing and if

00:21:44,480 --> 00:21:50,080
the compiler can prove that no one else

00:21:46,960 --> 00:21:51,440
uh has has the appointed this protein

00:21:50,080 --> 00:21:53,440
handle so the protein handle is never

00:21:51,440 --> 00:21:56,000
going to escape that scope

00:21:53,440 --> 00:21:57,360
that means that um basically that that's

00:21:56,000 --> 00:21:59,280
going to be the lifetime of the courage

00:21:57,360 --> 00:22:00,799
in so then

00:21:59,280 --> 00:22:02,159
the compiler can just like put the

00:22:00,799 --> 00:22:03,919
quartet on the stack instead and

00:22:02,159 --> 00:22:05,600
everything just collapses and there's no

00:22:03,919 --> 00:22:07,679
dynamic memory allocation anymore and

00:22:05,600 --> 00:22:09,600
everything is very nice

00:22:07,679 --> 00:22:10,720
but because of these optimizations

00:22:09,600 --> 00:22:12,240
that's why if

00:22:10,720 --> 00:22:13,600
efficient quarantines need to be a

00:22:12,240 --> 00:22:15,039
language feature right that's what they

00:22:13,600 --> 00:22:17,200
can't just be a library feature that's

00:22:15,039 --> 00:22:18,480
why we need core language support

00:22:17,200 --> 00:22:20,640
and that's actually really nice because

00:22:18,480 --> 00:22:22,400
the the code you write on both sides is

00:22:20,640 --> 00:22:25,440
like really nice and clean

00:22:22,400 --> 00:22:26,799
and the code that you get compiled is

00:22:25,440 --> 00:22:27,840
actually really really lightweight it's

00:22:26,799 --> 00:22:29,600
very very efficient

00:22:27,840 --> 00:22:31,679
and if you have a compiler that supports

00:22:29,600 --> 00:22:33,120
that you can even run it on a bare metal

00:22:31,679 --> 00:22:34,799
machine that has no threads and

00:22:33,120 --> 00:22:36,240
operating systems or nothing

00:22:34,799 --> 00:22:37,840
um and it's going to be really fast it's

00:22:36,240 --> 00:22:41,280
going to be really really efficient

00:22:37,840 --> 00:22:43,120
so so that's very nice um and these are

00:22:41,280 --> 00:22:46,799
really all the bits that you need

00:22:43,120 --> 00:22:50,799
there's one slightly annoying thing

00:22:46,799 --> 00:22:53,679
um that this generator type turns out

00:22:50,799 --> 00:22:54,960
that is not provided in c plus 20 you

00:22:53,679 --> 00:22:57,280
don't get that as it

00:22:54,960 --> 00:22:59,200
implemented type in a standard language

00:22:57,280 --> 00:23:00,880
and the promise type is a part of the

00:22:59,200 --> 00:23:04,240
generator type really so

00:23:00,880 --> 00:23:04,240
you don't get that either so

00:23:04,559 --> 00:23:08,480
you're going to fix that in css23 so

00:23:06,480 --> 00:23:08,960
there's this uh proposal by lewis baker

00:23:08,480 --> 00:23:11,120
and khan

00:23:08,960 --> 00:23:12,400
jambo um proposing a still generator

00:23:11,120 --> 00:23:13,840
which unfortunately we didn't get in

00:23:12,400 --> 00:23:14,480
super suspension but we're going to get

00:23:13,840 --> 00:23:17,280
into

00:23:14,480 --> 00:23:18,880
23 and that's going to be really awesome

00:23:17,280 --> 00:23:20,320
but until then

00:23:18,880 --> 00:23:22,000
unfortunately you have to implement this

00:23:20,320 --> 00:23:25,039
yourself or

00:23:22,000 --> 00:23:27,520
the much much better idea is um to

00:23:25,039 --> 00:23:28,960
actually just use a library there is um

00:23:27,520 --> 00:23:30,640
cpp coral which is a great library

00:23:28,960 --> 00:23:32,320
written by louis baker

00:23:30,640 --> 00:23:34,320
so that's what i recommend just use that

00:23:32,320 --> 00:23:36,080
and then you you get you get a generator

00:23:34,320 --> 00:23:38,960
that you can use

00:23:36,080 --> 00:23:40,240
but um when i was looking at core teams

00:23:38,960 --> 00:23:41,600
and kind of the specification the

00:23:40,240 --> 00:23:42,799
standard i was kind of trying to figure

00:23:41,600 --> 00:23:44,320
out how it works

00:23:42,799 --> 00:23:46,720
i got curious and i really wanted to

00:23:44,320 --> 00:23:49,120
understand how this works so

00:23:46,720 --> 00:23:51,279
i actually went ahead and actually

00:23:49,120 --> 00:23:52,880
implemented generate on a promise type

00:23:51,279 --> 00:23:54,480
just for this example that i showed you

00:23:52,880 --> 00:23:56,000
earlier with the sequence of zero one

00:23:54,480 --> 00:23:57,600
two three and i just wanted to see what

00:23:56,000 --> 00:23:59,360
it takes to make this all work just with

00:23:57,600 --> 00:24:01,279
standard tips that's 20.

00:23:59,360 --> 00:24:04,480
and i have to admit um it was

00:24:01,279 --> 00:24:07,200
surprisingly painful it took me all day

00:24:04,480 --> 00:24:07,600
but i kind of figured it out so i'm just

00:24:07,200 --> 00:24:08,880
going to

00:24:07,600 --> 00:24:11,039
quickly show you what this looks like if

00:24:08,880 --> 00:24:11,840
you do this yourself so this is the

00:24:11,039 --> 00:24:14,480
promise

00:24:11,840 --> 00:24:15,600
type and at the top there you have the

00:24:14,480 --> 00:24:17,200
current value

00:24:15,600 --> 00:24:18,320
that's kind of the box where the ink

00:24:17,200 --> 00:24:19,919
lives right that's where we're going to

00:24:18,320 --> 00:24:21,919
be storing the in

00:24:19,919 --> 00:24:24,000
um and the coating is going to be

00:24:21,919 --> 00:24:25,840
talking to that object right so

00:24:24,000 --> 00:24:28,240
and all the other functions down there

00:24:25,840 --> 00:24:29,279
are really answers to questions that the

00:24:28,240 --> 00:24:31,520
quarantine is going to

00:24:29,279 --> 00:24:33,279
ask about how its reentrant behavior is

00:24:31,520 --> 00:24:34,799
supposed to work exactly whenever it

00:24:33,279 --> 00:24:35,440
yields and suspends and all of this

00:24:34,799 --> 00:24:37,600
stuff

00:24:35,440 --> 00:24:38,799
and you have a bunch of choices there

00:24:37,600 --> 00:24:40,159
and that will basically govern how

00:24:38,799 --> 00:24:41,600
you're going to implement the body of

00:24:40,159 --> 00:24:41,919
those those functions so this is really

00:24:41,600 --> 00:24:45,360
down

00:24:41,919 --> 00:24:47,840
deep into the guts of the coating api

00:24:45,360 --> 00:24:49,679
um but like the really interesting thing

00:24:47,840 --> 00:24:51,440
here is this uh yield value function

00:24:49,679 --> 00:24:52,720
because that's the chord inside of the

00:24:51,440 --> 00:24:54,400
communication channel

00:24:52,720 --> 00:24:56,799
so this is where the core team is going

00:24:54,400 --> 00:24:59,120
to put the end into the box you see it's

00:24:56,799 --> 00:25:00,000
taking um so you get value and then it's

00:24:59,120 --> 00:25:02,480
going to be assigned

00:25:00,000 --> 00:25:04,559
to current value so that's where you're

00:25:02,480 --> 00:25:06,960
going to the questions can store

00:25:04,559 --> 00:25:09,039
um the in that it produced into that

00:25:06,960 --> 00:25:12,159
into that box

00:25:09,039 --> 00:25:14,480
and then that's generator

00:25:12,159 --> 00:25:15,200
so it has a promise type at the top and

00:25:14,480 --> 00:25:16,400
then it has

00:25:15,200 --> 00:25:18,080
this thing which you already talked

00:25:16,400 --> 00:25:20,240
about that's the stood coding handle so

00:25:18,080 --> 00:25:22,240
that's the um

00:25:20,240 --> 00:25:24,000
that's the pointer to the actual uh

00:25:22,240 --> 00:25:26,320
coordinating frame

00:25:24,000 --> 00:25:28,000
that the compiler generates um and the

00:25:26,320 --> 00:25:29,919
rest of this uh class essentially it's

00:25:28,000 --> 00:25:31,919
just a bunch of constructors

00:25:29,919 --> 00:25:33,279
and basically managing the lifetime of

00:25:31,919 --> 00:25:34,880
that coverage and handle so that's

00:25:33,279 --> 00:25:36,400
that's really what this is

00:25:34,880 --> 00:25:38,480
and this is the promise that we saw

00:25:36,400 --> 00:25:40,400
before and then the other really

00:25:38,480 --> 00:25:43,039
interesting place that's the operator

00:25:40,400 --> 00:25:44,640
um paramparan that's the call operator

00:25:43,039 --> 00:25:46,080
and that's the user side of the

00:25:44,640 --> 00:25:47,440
communication channel so that's the

00:25:46,080 --> 00:25:49,520
operator that takes the int

00:25:47,440 --> 00:25:51,039
out of the box and yields it to your

00:25:49,520 --> 00:25:51,679
user code so that's what you call them

00:25:51,039 --> 00:25:54,320
you write g

00:25:51,679 --> 00:25:54,320
paramparan

00:25:55,120 --> 00:26:01,200
and basically the main message here is

00:25:59,039 --> 00:26:02,159
please don't try this at home like i can

00:26:01,200 --> 00:26:03,520
really stress

00:26:02,159 --> 00:26:05,600
don't can't stress this enough like

00:26:03,520 --> 00:26:06,960
please just just don't do this yourself

00:26:05,600 --> 00:26:08,080
unless you really really know what

00:26:06,960 --> 00:26:09,520
you're doing

00:26:08,080 --> 00:26:11,840
there's a lot of subtlety a lot of

00:26:09,520 --> 00:26:14,640
choices here um

00:26:11,840 --> 00:26:16,080
and i managed to write this like very

00:26:14,640 --> 00:26:17,440
simple one which i just showed you for

00:26:16,080 --> 00:26:18,559
this like very simple example

00:26:17,440 --> 00:26:20,480
but for something like a more

00:26:18,559 --> 00:26:22,880
complicated more realistic uh

00:26:20,480 --> 00:26:25,679
use case i probably wouldn't be able to

00:26:22,880 --> 00:26:28,720
figure out how to write this correctly

00:26:25,679 --> 00:26:30,880
so please just use a library

00:26:28,720 --> 00:26:32,400
and if you do that you get this code and

00:26:30,880 --> 00:26:34,000
that's great this is really nice it's

00:26:32,400 --> 00:26:35,279
really clean it's really efficient

00:26:34,000 --> 00:26:37,279
it becomes even more interesting when

00:26:35,279 --> 00:26:39,600
you have multiple core teams

00:26:37,279 --> 00:26:41,039
so let's say you implement the front-end

00:26:39,600 --> 00:26:43,279
for some programming language right so

00:26:41,039 --> 00:26:45,279
you need to read characters from a file

00:26:43,279 --> 00:26:47,200
uh then you need to lex uh those

00:26:45,279 --> 00:26:48,880
characters to your tokens and then you

00:26:47,200 --> 00:26:50,000
have a parser which is going to consume

00:26:48,880 --> 00:26:53,440
those tokens and build

00:26:50,000 --> 00:26:55,039
an abstract syntax tree so

00:26:53,440 --> 00:26:57,919
so you can either obviously read the

00:26:55,039 --> 00:26:58,960
whole file then next and then pause it

00:26:57,919 --> 00:27:01,360
and then you're going to have a bunch of

00:26:58,960 --> 00:27:02,799
classes with members and apis that do

00:27:01,360 --> 00:27:03,600
all of the stuff all you do with core

00:27:02,799 --> 00:27:05,200
teams

00:27:03,600 --> 00:27:06,799
and that that's going to be doing it

00:27:05,200 --> 00:27:08,080
lazily and cooperatively and that's

00:27:06,799 --> 00:27:11,440
really nice

00:27:08,080 --> 00:27:13,279
so so imagine how this works right so

00:27:11,440 --> 00:27:15,039
the positive is going to pass some

00:27:13,279 --> 00:27:16,799
tokens and whenever um

00:27:15,039 --> 00:27:18,320
whenever it needs a new token it's going

00:27:16,799 --> 00:27:21,039
to call the lexer

00:27:18,320 --> 00:27:22,559
and the lexer um is going to be

00:27:21,039 --> 00:27:25,840
somewhere in the middle of of

00:27:22,559 --> 00:27:27,120
uh lexing uh lexington the characters

00:27:25,840 --> 00:27:29,120
and it's going to remember that state

00:27:27,120 --> 00:27:30,799
is going to just like yield the next

00:27:29,120 --> 00:27:32,640
token and then the parser can consume

00:27:30,799 --> 00:27:34,240
that unless alexa

00:27:32,640 --> 00:27:35,760
needs another character or two then it's

00:27:34,240 --> 00:27:36,240
gonna ask the reader and the reader is

00:27:35,760 --> 00:27:39,600
gonna

00:27:36,240 --> 00:27:41,440
use the next next character and

00:27:39,600 --> 00:27:43,039
and that's all like lazily and

00:27:41,440 --> 00:27:44,320
cooperatively and that all really works

00:27:43,039 --> 00:27:45,840
nicely together that's really

00:27:44,320 --> 00:27:48,880
interesting because of the completely

00:27:45,840 --> 00:27:51,039
different way of designing this

00:27:48,880 --> 00:27:52,640
and it gets even more interesting if

00:27:51,039 --> 00:27:54,240
that happens on multiple threads because

00:27:52,640 --> 00:27:55,760
then you basically have cooperative

00:27:54,240 --> 00:27:57,919
multitasking instead of preemptive

00:27:55,760 --> 00:28:00,640
multitasking

00:27:57,919 --> 00:28:02,000
doing this way actually um avoids

00:28:00,640 --> 00:28:03,200
another um

00:28:02,000 --> 00:28:05,039
very very common problem with

00:28:03,200 --> 00:28:05,440
multi-threaded code which you might know

00:28:05,039 --> 00:28:08,559
is

00:28:05,440 --> 00:28:11,120
call back hell and i'm sure

00:28:08,559 --> 00:28:12,640
i've definitely um you know have to deal

00:28:11,120 --> 00:28:13,039
with this quite a lot i'm sure many of

00:28:12,640 --> 00:28:15,279
you

00:28:13,039 --> 00:28:16,640
need to um if you use objects and you

00:28:15,279 --> 00:28:18,000
you're on this multi-failed environment

00:28:16,640 --> 00:28:19,039
where different objects you know do

00:28:18,000 --> 00:28:20,960
different tasks

00:28:19,039 --> 00:28:22,960
then typically they're going to register

00:28:20,960 --> 00:28:24,799
objects uh register callbacks

00:28:22,960 --> 00:28:26,159
to other objects and then later when the

00:28:24,799 --> 00:28:27,360
other objects do something on different

00:28:26,159 --> 00:28:28,880
thread they're going to call back these

00:28:27,360 --> 00:28:30,240
callbacks and the callback actually

00:28:28,880 --> 00:28:31,360
itself is going to be somewhere else in

00:28:30,240 --> 00:28:32,960
that class

00:28:31,360 --> 00:28:34,960
so your logic is kind of scattered

00:28:32,960 --> 00:28:37,039
across all these different places

00:28:34,960 --> 00:28:39,440
it's generally like really hard to debug

00:28:37,039 --> 00:28:42,080
it's really painful to work with this

00:28:39,440 --> 00:28:43,120
and core teams make this a lot simpler

00:28:42,080 --> 00:28:44,480
so

00:28:43,120 --> 00:28:46,640
we've already seen that quarantines can

00:28:44,480 --> 00:28:48,720
yield and return uh

00:28:46,640 --> 00:28:50,159
but in order to make this work um

00:28:48,720 --> 00:28:52,559
there's just like one more thing that

00:28:50,159 --> 00:28:54,320
they can do which is a weight

00:28:52,559 --> 00:28:56,240
and so we have this like third key word

00:28:54,320 --> 00:28:58,559
in there which is cool way

00:28:56,240 --> 00:29:00,240
and how this works essentially is that

00:28:58,559 --> 00:29:02,080
now we have a quote in f1 and another

00:29:00,240 --> 00:29:04,720
coding f2

00:29:02,080 --> 00:29:06,399
and um by the way as soon as you write

00:29:04,720 --> 00:29:08,159
any of these three keywords cohere

00:29:06,399 --> 00:29:09,520
kuwait co-return that's how the compiler

00:29:08,159 --> 00:29:11,120
knows that your functions choreogene

00:29:09,520 --> 00:29:12,720
right so there's no other like syntactic

00:29:11,120 --> 00:29:15,440
marker for a co-routine

00:29:12,720 --> 00:29:16,720
so um it's kind of like whether a

00:29:15,440 --> 00:29:18,080
function is according is kind of an

00:29:16,720 --> 00:29:19,600
implementation detail whenever you use

00:29:18,080 --> 00:29:21,679
any of these keywords that's going to be

00:29:19,600 --> 00:29:23,360
a core routine so that's quite important

00:29:21,679 --> 00:29:24,720
so that also from that follows that you

00:29:23,360 --> 00:29:26,559
can only co-weight

00:29:24,720 --> 00:29:27,840
on a quarantine from another core

00:29:26,559 --> 00:29:29,360
routine but

00:29:27,840 --> 00:29:30,399
now we're in this kind of world where we

00:29:29,360 --> 00:29:32,720
have these different quarantines

00:29:30,399 --> 00:29:35,440
cooperating

00:29:32,720 --> 00:29:36,960
and so what happens if caution f1 co

00:29:35,440 --> 00:29:39,760
waits in coordinate two

00:29:36,960 --> 00:29:40,960
so what happens is if you call weight so

00:29:39,760 --> 00:29:42,720
first you're gonna suspend so you're

00:29:40,960 --> 00:29:44,799
gonna return the control back to

00:29:42,720 --> 00:29:45,760
um the calling code so that's just like

00:29:44,799 --> 00:29:48,640
with the yield

00:29:45,760 --> 00:29:50,080
but the extra track is then if later f2

00:29:48,640 --> 00:29:52,000
yields a value

00:29:50,080 --> 00:29:54,320
that's gonna actually resume f1 and

00:29:52,000 --> 00:29:55,840
that's gonna jump back into this line of

00:29:54,320 --> 00:29:57,600
code with the ko weight and you're going

00:29:55,840 --> 00:29:59,440
to get the value for you and then you're

00:29:57,600 --> 00:30:03,440
going to resume that protein

00:29:59,440 --> 00:30:06,720
right so that is really interesting this

00:30:03,440 --> 00:30:09,440
is how you can get this cooperative

00:30:06,720 --> 00:30:10,159
thing work and this is really really

00:30:09,440 --> 00:30:12,480
interesting

00:30:10,159 --> 00:30:13,200
if f1 and f2 are running on different

00:30:12,480 --> 00:30:16,080
threads

00:30:13,200 --> 00:30:17,520
right so imagine what that means and

00:30:16,080 --> 00:30:20,880
that's actually um

00:30:17,520 --> 00:30:22,399
basically a better um mental model of

00:30:20,880 --> 00:30:25,120
what a coordinate is that that

00:30:22,399 --> 00:30:26,640
correlates so the way to think about

00:30:25,120 --> 00:30:27,120
this what effectively happens here is

00:30:26,640 --> 00:30:30,399
that

00:30:27,120 --> 00:30:30,799
if if one co waits on f2 what it's doing

00:30:30,399 --> 00:30:34,000
it's

00:30:30,799 --> 00:30:35,520
registering a callback to f2 and then

00:30:34,000 --> 00:30:38,240
it's suspending and returning control

00:30:35,520 --> 00:30:40,720
back to the corner and then later

00:30:38,240 --> 00:30:41,440
if f2 is yielding a value it's going to

00:30:40,720 --> 00:30:43,600
effectively

00:30:41,440 --> 00:30:45,279
call back that callback and the callback

00:30:43,600 --> 00:30:46,320
is just the rest of the function value

00:30:45,279 --> 00:30:48,720
of f1

00:30:46,320 --> 00:30:50,000
right so f1 you have the core weight and

00:30:48,720 --> 00:30:52,799
the rest of that body that is your

00:30:50,000 --> 00:30:52,799
callback right

00:30:52,960 --> 00:30:56,640
and and that can happen from another

00:30:54,880 --> 00:30:58,480
thread um

00:30:56,640 --> 00:31:00,159
and that's actually really nice because

00:30:58,480 --> 00:31:02,000
um you get the logic but

00:31:00,159 --> 00:31:03,279
you don't have to um write it you don't

00:31:02,000 --> 00:31:04,080
have to write all these all these

00:31:03,279 --> 00:31:05,760
callbacks

00:31:04,080 --> 00:31:07,039
so your code ends up being much cleaner

00:31:05,760 --> 00:31:07,760
and much more compact and much more

00:31:07,039 --> 00:31:09,360
coherent

00:31:07,760 --> 00:31:10,720
because this whole communication channel

00:31:09,360 --> 00:31:12,559
with the callbacks is essentially just

00:31:10,720 --> 00:31:14,320
abstracted away right the coaching staff

00:31:12,559 --> 00:31:16,240
just just handles it

00:31:14,320 --> 00:31:17,760
there's only one caveat here which is

00:31:16,240 --> 00:31:18,480
quite important you might have noticed

00:31:17,760 --> 00:31:21,919
that i wrote

00:31:18,480 --> 00:31:23,600
an async generator here because if you

00:31:21,919 --> 00:31:24,720
have multiple threads going on

00:31:23,600 --> 00:31:26,000
you need a fundamentally different

00:31:24,720 --> 00:31:27,600
promise type right so you need to

00:31:26,000 --> 00:31:30,720
synchronize access to this

00:31:27,600 --> 00:31:32,159
value u um so you're gonna have a

00:31:30,720 --> 00:31:34,559
promise type where you're gonna put

00:31:32,159 --> 00:31:36,159
locks in um you're gonna like have to

00:31:34,559 --> 00:31:37,360
deal with race conditions

00:31:36,159 --> 00:31:39,200
so that's gonna be a bit more

00:31:37,360 --> 00:31:40,799
complicated and that's actually quite

00:31:39,200 --> 00:31:42,799
important so you have to do that in the

00:31:40,799 --> 00:31:44,880
the generator in the promised time

00:31:42,799 --> 00:31:46,399
uh because core genes they don't handle

00:31:44,880 --> 00:31:47,840
that quaritiens themselves they don't

00:31:46,399 --> 00:31:49,840
care about threats at all they don't

00:31:47,840 --> 00:31:51,120
they don't care what they're running on

00:31:49,840 --> 00:31:53,120
and actually let me repeat that

00:31:51,120 --> 00:31:55,919
questions have nothing to do

00:31:53,120 --> 00:31:57,600
with threads right so if your generator

00:31:55,919 --> 00:31:59,600
type is asynchronous and thread save

00:31:57,600 --> 00:32:01,360
then it all just works

00:31:59,600 --> 00:32:03,519
um but you kind of kind of have to do

00:32:01,360 --> 00:32:06,640
that

00:32:03,519 --> 00:32:09,600
so yeah that's i think pretty much um

00:32:06,640 --> 00:32:10,480
all the basics that uh we need to know

00:32:09,600 --> 00:32:12,399
about proteins

00:32:10,480 --> 00:32:13,679
and this is kind of the mental model

00:32:12,399 --> 00:32:14,320
behind them like how do you think about

00:32:13,679 --> 00:32:16,000
them

00:32:14,320 --> 00:32:17,840
how to how to use them to design your

00:32:16,000 --> 00:32:21,279
code um

00:32:17,840 --> 00:32:22,960
okay let's move on uh we have concept

00:32:21,279 --> 00:32:24,640
so let's talk about concepts but before

00:32:22,960 --> 00:32:27,519
we can talk about concepts

00:32:24,640 --> 00:32:28,640
we need to talk about functions here's a

00:32:27,519 --> 00:32:30,960
function

00:32:28,640 --> 00:32:32,799
so that's uh a function that takes an

00:32:30,960 --> 00:32:33,519
integer and figures out whether it's a

00:32:32,799 --> 00:32:35,679
power of two

00:32:33,519 --> 00:32:37,760
right so that's i'm doing audio software

00:32:35,679 --> 00:32:39,519
so we need that function quite a lot

00:32:37,760 --> 00:32:41,279
it's a very clever interpretation of it

00:32:39,519 --> 00:32:42,960
where you basically do a bunch of like

00:32:41,279 --> 00:32:45,200
bit operations to figure out if exactly

00:32:42,960 --> 00:32:46,720
one bit is set

00:32:45,200 --> 00:32:48,320
so that's really clever but that only

00:32:46,720 --> 00:32:50,960
works for integers

00:32:48,320 --> 00:32:53,519
obviously we want it to be generic so we

00:32:50,960 --> 00:32:55,039
want it to work for any integer type

00:32:53,519 --> 00:32:57,200
so how do you make that work for any

00:32:55,039 --> 00:32:58,880
individual type well one way of doing

00:32:57,200 --> 00:33:01,279
this would be to

00:32:58,880 --> 00:33:02,880
write out all the 12 overloads so some

00:33:01,279 --> 00:33:05,840
people actually do that

00:33:02,880 --> 00:33:07,600
um that's not a great approach we have

00:33:05,840 --> 00:33:08,960
templates so let's use templates so we

00:33:07,600 --> 00:33:10,880
can template it that's great we can

00:33:08,960 --> 00:33:13,279
template it on the type

00:33:10,880 --> 00:33:15,120
so we all know this stuff but what

00:33:13,279 --> 00:33:18,000
happens if we call this function now

00:33:15,120 --> 00:33:19,679
with an odd integer type like let's say

00:33:18,000 --> 00:33:20,240
we call it with a double like a floating

00:33:19,679 --> 00:33:22,799
point number

00:33:20,240 --> 00:33:24,240
just because someone decides to do that

00:33:22,799 --> 00:33:25,279
and then you get this really weird error

00:33:24,240 --> 00:33:27,120
message saying

00:33:25,279 --> 00:33:29,600
error invalid operands to binary

00:33:27,120 --> 00:33:29,600
expression

00:33:30,799 --> 00:33:35,760
so imagine you're the user of this right

00:33:34,000 --> 00:33:37,279
and you're like what does this mean what

00:33:35,760 --> 00:33:39,440
did i do wrong it turns out

00:33:37,279 --> 00:33:40,960
the compiler tried to instantiate this

00:33:39,440 --> 00:33:43,039
template with a double

00:33:40,960 --> 00:33:44,399
and then it started uh instantiating and

00:33:43,039 --> 00:33:45,279
then it hit this expression with the

00:33:44,399 --> 00:33:47,200
binary and

00:33:45,279 --> 00:33:48,559
and it turns out binary and doesn't work

00:33:47,200 --> 00:33:49,919
for floating point numbers

00:33:48,559 --> 00:33:52,159
so it's going to issue basically an

00:33:49,919 --> 00:33:54,399
error saying well you can't have a

00:33:52,159 --> 00:33:55,600
binary and in between two floating point

00:33:54,399 --> 00:33:57,519
numbers

00:33:55,600 --> 00:33:59,279
but that's really um basically in order

00:33:57,519 --> 00:34:02,080
to figure this out the user needs to go

00:33:59,279 --> 00:34:04,000
into the body of that function you need

00:34:02,080 --> 00:34:05,679
to find the line of code where

00:34:04,000 --> 00:34:08,480
the invalid expression was they need to

00:34:05,679 --> 00:34:10,560
figure out why this failed

00:34:08,480 --> 00:34:12,159
and and and that's you shouldn't really

00:34:10,560 --> 00:34:13,679
be doing that right and

00:34:12,159 --> 00:34:15,520
that's a very simple case but if you

00:34:13,679 --> 00:34:17,040
work with like real world cases or if

00:34:15,520 --> 00:34:18,399
you work with something like boost

00:34:17,040 --> 00:34:20,240
then uh you probably know that these

00:34:18,399 --> 00:34:21,599
error messages can get a lot longer and

00:34:20,240 --> 00:34:23,040
a lot more horrible

00:34:21,599 --> 00:34:24,399
and how on earth are you supposed to

00:34:23,040 --> 00:34:25,760
figure out what you did wrong and what's

00:34:24,399 --> 00:34:28,159
going on there

00:34:25,760 --> 00:34:29,679
so well there is a solution to this

00:34:28,159 --> 00:34:30,720
right so we can put a static assertion

00:34:29,679 --> 00:34:33,440
there saying well

00:34:30,720 --> 00:34:34,000
please assert that t is an integral time

00:34:33,440 --> 00:34:35,839
that's much

00:34:34,000 --> 00:34:37,280
better now you get an error message

00:34:35,839 --> 00:34:39,359
saying okay well

00:34:37,280 --> 00:34:42,079
double is not an integral type so that's

00:34:39,359 --> 00:34:42,079
great um

00:34:42,159 --> 00:34:46,240
but what do we do if we actually want to

00:34:44,720 --> 00:34:48,399
make this work for protein point times

00:34:46,240 --> 00:34:48,960
right this is actually useful like 0.25

00:34:48,399 --> 00:34:51,040
actually

00:34:48,960 --> 00:34:52,079
is a power of two right so that's useful

00:34:51,040 --> 00:34:53,520
to know

00:34:52,079 --> 00:34:55,919
so and actually we can implement this

00:34:53,520 --> 00:34:57,119
function for um for pulling point types

00:34:55,919 --> 00:34:59,200
it's actually just going to be a

00:34:57,119 --> 00:35:00,640
different implementation but

00:34:59,200 --> 00:35:03,760
um there was actually a very clever way

00:35:00,640 --> 00:35:05,119
of doing this so you want to do this for

00:35:03,760 --> 00:35:06,800
floating point numbers and you want this

00:35:05,119 --> 00:35:08,079
to work for negative as well as positive

00:35:06,800 --> 00:35:09,920
powers of two

00:35:08,079 --> 00:35:11,359
uh so the way you do this is you have to

00:35:09,920 --> 00:35:13,839
kind of decompose the floating point

00:35:11,359 --> 00:35:15,359
number into a mantissa and exponent

00:35:13,839 --> 00:35:17,119
and if you've never heard about stood

00:35:15,359 --> 00:35:18,960
for expert before then congratulations

00:35:17,119 --> 00:35:20,400
now you have because that's exactly what

00:35:18,960 --> 00:35:24,240
it does

00:35:20,400 --> 00:35:26,160
um so but if you do that

00:35:24,240 --> 00:35:27,839
we get an error message saying

00:35:26,160 --> 00:35:29,040
redefinition of function template is

00:35:27,839 --> 00:35:32,079
power of 2

00:35:29,040 --> 00:35:34,480
so now we define the same template twice

00:35:32,079 --> 00:35:36,160
and that sucks because that's what we

00:35:34,480 --> 00:35:37,280
want right the first one is for integers

00:35:36,160 --> 00:35:38,400
the second one is the floating point

00:35:37,280 --> 00:35:40,480
numbers but you still get this error

00:35:38,400 --> 00:35:42,560
message

00:35:40,480 --> 00:35:44,000
so how do we make this work and before c

00:35:42,560 --> 00:35:47,520
plus 20 really the

00:35:44,000 --> 00:35:50,160
only way of doing this is

00:35:47,520 --> 00:35:52,160
and the tool we have for that is stood

00:35:50,160 --> 00:35:56,560
enable it

00:35:52,160 --> 00:35:58,240
and um well um let's remember if we

00:35:56,560 --> 00:35:59,920
let's see if i can remember how to um

00:35:58,240 --> 00:36:02,320
how to use to enable it okay

00:35:59,920 --> 00:36:05,280
so you can write the student label if

00:36:02,320 --> 00:36:06,560
integral type and floating point type

00:36:05,280 --> 00:36:09,040
where do we put this this is something

00:36:06,560 --> 00:36:12,240
that can i can never remember right so

00:36:09,040 --> 00:36:13,680
you can put this onto the return type of

00:36:12,240 --> 00:36:15,280
the function but then

00:36:13,680 --> 00:36:17,680
you don't really see the actual return

00:36:15,280 --> 00:36:20,000
type anymore so that's not great

00:36:17,680 --> 00:36:21,760
you can put this into the parameter list

00:36:20,000 --> 00:36:25,119
but then you don't really see

00:36:21,760 --> 00:36:26,079
the parameter list anymore so i don't

00:36:25,119 --> 00:36:27,920
like either of these

00:36:26,079 --> 00:36:29,839
um so my favorite method is actually to

00:36:27,920 --> 00:36:31,440
put this into the template argument list

00:36:29,839 --> 00:36:33,200
because then you can still cleanly see

00:36:31,440 --> 00:36:36,400
the function signature

00:36:33,200 --> 00:36:39,280
um so that's i think the most readable

00:36:36,400 --> 00:36:42,079
way of doing this except it doesn't work

00:36:39,280 --> 00:36:43,440
because it turns out that in cbs

00:36:42,079 --> 00:36:45,359
defaulted

00:36:43,440 --> 00:36:46,720
template arguments are not part of the

00:36:45,359 --> 00:36:48,160
function signature

00:36:46,720 --> 00:36:49,839
and then you again have the same

00:36:48,160 --> 00:36:51,200
function signature twice and then you

00:36:49,839 --> 00:36:53,119
again get this error redefinition of

00:36:51,200 --> 00:36:54,640
function template

00:36:53,119 --> 00:36:56,160
turns out you can work around that

00:36:54,640 --> 00:36:57,760
because that rule doesn't apply to

00:36:56,160 --> 00:36:58,400
non-type template parameters so you can

00:36:57,760 --> 00:37:01,280
make this an

00:36:58,400 --> 00:37:03,599
int template parameter so you can uh and

00:37:01,280 --> 00:37:06,720
that's gonna work that's gonna compile

00:37:03,599 --> 00:37:08,320
so that's what i've been doing um but

00:37:06,720 --> 00:37:10,240
just last weekend actually i heard from

00:37:08,320 --> 00:37:12,079
my friend gash parasman that this is

00:37:10,240 --> 00:37:14,640
actually not good either because

00:37:12,079 --> 00:37:16,400
in uh you know people use in is like a

00:37:14,640 --> 00:37:18,480
legit non-tech template parameter

00:37:16,400 --> 00:37:20,480
somewhat could just like put a value in

00:37:18,480 --> 00:37:21,200
there and that's going to break this

00:37:20,480 --> 00:37:22,720
whole thing

00:37:21,200 --> 00:37:24,480
so what you should be doing instead is

00:37:22,720 --> 00:37:25,760
you should uh like make it a void point

00:37:24,480 --> 00:37:28,240
a non-temp temperature parameter and you

00:37:25,760 --> 00:37:30,880
should default it to malpractor

00:37:28,240 --> 00:37:32,400
so this is just ridiculous right like

00:37:30,880 --> 00:37:33,280
who's gonna who's supposed to like

00:37:32,400 --> 00:37:34,720
remember how to

00:37:33,280 --> 00:37:37,119
figure out how to use this correctly

00:37:34,720 --> 00:37:39,599
this is this is not great

00:37:37,119 --> 00:37:41,200
well the good news is in sql server 20

00:37:39,599 --> 00:37:43,119
we don't have to do this ever again

00:37:41,200 --> 00:37:44,400
because in sql strategy we have requires

00:37:43,119 --> 00:37:45,599
and concepts and you can just write it

00:37:44,400 --> 00:37:47,920
like that

00:37:45,599 --> 00:37:49,839
so that's really nice so we have uh

00:37:47,920 --> 00:37:51,680
standard library concept and header uh

00:37:49,839 --> 00:37:53,359
concepts like student integral and still

00:37:51,680 --> 00:37:56,160
floating point then you're gonna write

00:37:53,359 --> 00:37:57,839
requires that integral and requires the

00:37:56,160 --> 00:37:58,960
floating point

00:37:57,839 --> 00:38:00,720
and that's just gonna work and it's

00:37:58,960 --> 00:38:02,800
gonna exactly do what we want without

00:38:00,720 --> 00:38:04,640
any of the ugly stuff

00:38:02,800 --> 00:38:06,079
of course this is super spa so there's

00:38:04,640 --> 00:38:08,480
actually three different ways of writing

00:38:06,079 --> 00:38:10,240
this this is kind of the long form

00:38:08,480 --> 00:38:12,400
then instead of writing a template blah

00:38:10,240 --> 00:38:14,480
blah requires you can actually um

00:38:12,400 --> 00:38:15,760
put the concept name into the template

00:38:14,480 --> 00:38:17,680
argument list instead of the

00:38:15,760 --> 00:38:19,359
the titanium keyword so you can write

00:38:17,680 --> 00:38:21,920
template integral t

00:38:19,359 --> 00:38:23,280
and template floating point t and then

00:38:21,920 --> 00:38:24,640
there's an even shorter syntax where you

00:38:23,280 --> 00:38:26,480
get rid of the template argument list

00:38:24,640 --> 00:38:28,720
entirely and you just write

00:38:26,480 --> 00:38:30,560
um you just write it directly into the

00:38:28,720 --> 00:38:32,320
parameter list saying concept name

00:38:30,560 --> 00:38:34,400
autumn and now

00:38:32,320 --> 00:38:35,839
really the only um thing that's still

00:38:34,400 --> 00:38:37,359
kind of reminding you that this is not a

00:38:35,839 --> 00:38:40,240
function but a constraint function

00:38:37,359 --> 00:38:43,520
template is this little order after the

00:38:40,240 --> 00:38:44,880
concept name um

00:38:43,520 --> 00:38:46,320
and that's actually really nice i think

00:38:44,880 --> 00:38:47,839
that's that's a really nice syntax and

00:38:46,320 --> 00:38:49,359
we also kind of see why we need

00:38:47,839 --> 00:38:50,960
different syntaxes for these things

00:38:49,359 --> 00:38:52,320
because in the first case the really

00:38:50,960 --> 00:38:53,680
short syntax works

00:38:52,320 --> 00:38:55,920
in the second case for the floating

00:38:53,680 --> 00:38:57,200
point for the expert stuff we actually

00:38:55,920 --> 00:39:00,240
need to be able to name

00:38:57,200 --> 00:39:01,920
that type the actual type t so that's

00:39:00,240 --> 00:39:03,680
why we use the slightly longer form we

00:39:01,920 --> 00:39:05,599
have template floating point t so we can

00:39:03,680 --> 00:39:07,440
name that t

00:39:05,599 --> 00:39:09,119
um but that's really just kind of

00:39:07,440 --> 00:39:10,720
scratching the surface of what contents

00:39:09,119 --> 00:39:13,760
are they're like much more than just a

00:39:10,720 --> 00:39:15,280
more convenient syntax for enable if

00:39:13,760 --> 00:39:17,839
you can do much more stuff with concepts

00:39:15,280 --> 00:39:21,119
so first of all you can combine them

00:39:17,839 --> 00:39:22,800
right so if you have uh this integral

00:39:21,119 --> 00:39:24,880
concept and body point concept from the

00:39:22,800 --> 00:39:27,200
concepts header and the standard library

00:39:24,880 --> 00:39:28,079
you can make your own concept of an

00:39:27,200 --> 00:39:30,800
arithmetic type

00:39:28,079 --> 00:39:31,680
which is maybe all the integrals and all

00:39:30,800 --> 00:39:32,800
the floating point

00:39:31,680 --> 00:39:34,800
types so you're just going to say

00:39:32,800 --> 00:39:36,960
constant arithmetic is integral or

00:39:34,800 --> 00:39:38,400
floating point so you can combine them

00:39:36,960 --> 00:39:39,119
like that you can also combine them with

00:39:38,400 --> 00:39:41,520
and

00:39:39,119 --> 00:39:42,960
so you can say well so for whatever

00:39:41,520 --> 00:39:44,720
reason my library

00:39:42,960 --> 00:39:46,880
is going to accept arithmetic types but

00:39:44,720 --> 00:39:48,960
only those with the size not larger than

00:39:46,880 --> 00:39:51,280
eight bytes for whatever reason

00:39:48,960 --> 00:39:53,680
so you can combine that with and and

00:39:51,280 --> 00:39:56,560
actually you can even combine um

00:39:53,680 --> 00:39:58,640
as you can see here concept names with

00:39:56,560 --> 00:39:59,119
um some concepts with just arbitrary

00:39:58,640 --> 00:40:01,839
compiled

00:39:59,119 --> 00:40:04,000
expressions that yield a bool i like

00:40:01,839 --> 00:40:05,359
this kind of size of thing here

00:40:04,000 --> 00:40:06,880
and you can just combine them like that

00:40:05,359 --> 00:40:07,920
and that's really nice and now you have

00:40:06,880 --> 00:40:10,319
this concept that you need

00:40:07,920 --> 00:40:11,599
and you can just write a function sorry

00:40:10,319 --> 00:40:14,720
a function template

00:40:11,599 --> 00:40:17,839
that takes exactly the

00:40:14,720 --> 00:40:20,480
types of types that you can accept so

00:40:17,839 --> 00:40:23,119
it's constrained exactly on

00:40:20,480 --> 00:40:23,520
kind of the types that you want here and

00:40:23,119 --> 00:40:26,560
um

00:40:23,520 --> 00:40:28,160
if the user uses that code if you um for

00:40:26,560 --> 00:40:29,119
example pass a double to that function

00:40:28,160 --> 00:40:31,200
that's fine

00:40:29,119 --> 00:40:32,720
if you pass a long double that's not

00:40:31,200 --> 00:40:34,240
going to satisfy this uh

00:40:32,720 --> 00:40:35,839
constraint that we defined up there it's

00:40:34,240 --> 00:40:36,400
not going to satisfy this concept my

00:40:35,839 --> 00:40:38,720
number

00:40:36,400 --> 00:40:40,240
but you get a really like meaningful

00:40:38,720 --> 00:40:41,599
error message so that's what client for

00:40:40,240 --> 00:40:44,240
example gives you you'd say

00:40:41,599 --> 00:40:46,560
well my matching function because long

00:40:44,240 --> 00:40:50,079
double doesn't satisfy contact my number

00:40:46,560 --> 00:40:52,640
because sizeof is bigger than eight so

00:40:50,079 --> 00:40:54,160
i think um that's really great but

00:40:52,640 --> 00:40:55,760
that's not everything you can do even

00:40:54,160 --> 00:40:56,720
more with contents we have this thing

00:40:55,760 --> 00:40:59,839
called

00:40:56,720 --> 00:41:01,520
requires clauses where not only can you

00:40:59,839 --> 00:41:04,240
use combined concepts and combine

00:41:01,520 --> 00:41:07,520
concepts with uh boolean expressions

00:41:04,240 --> 00:41:10,240
but this actually lets you encode um

00:41:07,520 --> 00:41:11,599
the uh exact interface that the type

00:41:10,240 --> 00:41:13,040
needs to have

00:41:11,599 --> 00:41:15,119
into a concept and make that a

00:41:13,040 --> 00:41:17,040
requirement like for example

00:41:15,119 --> 00:41:18,319
if you want to implement a hashmap and

00:41:17,040 --> 00:41:20,720
you want to template it on

00:41:18,319 --> 00:41:22,079
any type that's hashable so what does it

00:41:20,720 --> 00:41:25,119
mean hashable

00:41:22,079 --> 00:41:27,839
and then typically it means well

00:41:25,119 --> 00:41:29,520
you can instantiate stud hash for it and

00:41:27,839 --> 00:41:32,000
if you call that it's going to give you

00:41:29,520 --> 00:41:33,119
um a hash value which is you know an

00:41:32,000 --> 00:41:34,640
integer

00:41:33,119 --> 00:41:36,640
and you can actually just type that out

00:41:34,640 --> 00:41:37,599
as a requirement and say my concept of

00:41:36,640 --> 00:41:41,200
hashable is

00:41:37,599 --> 00:41:42,880
any type that supports that interface

00:41:41,200 --> 00:41:44,240
and that's actually really really really

00:41:42,880 --> 00:41:45,839
nice because

00:41:44,240 --> 00:41:47,359
previously if you have if you wanted to

00:41:45,839 --> 00:41:49,280
kind of constrain

00:41:47,359 --> 00:41:50,400
your library interface like a class or a

00:41:49,280 --> 00:41:51,920
function like that

00:41:50,400 --> 00:41:53,760
you really have two choices right so

00:41:51,920 --> 00:41:54,960
either you would go the polymorphism

00:41:53,760 --> 00:41:56,880
approach you would say

00:41:54,960 --> 00:41:58,160
the hashable is like a base class and it

00:41:56,880 --> 00:42:00,400
has a bunch of

00:41:58,160 --> 00:42:01,280
like pure virtual functions and then in

00:42:00,400 --> 00:42:03,599
order to like

00:42:01,280 --> 00:42:05,280
have a type user type that you can use

00:42:03,599 --> 00:42:07,520
you need to inherit from that base class

00:42:05,280 --> 00:42:10,400
and implement all these functions

00:42:07,520 --> 00:42:12,560
um that's basically what languages like

00:42:10,400 --> 00:42:15,119
java do like object-oriented languages

00:42:12,560 --> 00:42:16,880
or if you want to use templates the only

00:42:15,119 --> 00:42:18,560
way to really do this is to just

00:42:16,880 --> 00:42:20,480
write out in your documentation what the

00:42:18,560 --> 00:42:22,319
constraints are you know like like

00:42:20,480 --> 00:42:24,160
what we have been doing for the last 20

00:42:22,319 --> 00:42:27,920
30 40 years like saying

00:42:24,160 --> 00:42:30,640
okay well um

00:42:27,920 --> 00:42:31,280
if you have a template temperature on t

00:42:30,640 --> 00:42:33,040
then that t

00:42:31,280 --> 00:42:34,640
needs to have you know this in this

00:42:33,040 --> 00:42:36,160
requirement and you just write that into

00:42:34,640 --> 00:42:38,640
the documentation

00:42:36,160 --> 00:42:39,760
but now you can write these requirements

00:42:38,640 --> 00:42:42,880
in code

00:42:39,760 --> 00:42:44,400
like in this requires clause and that

00:42:42,880 --> 00:42:46,560
that is so much nicer right this

00:42:44,400 --> 00:42:48,319
fundamentally changes the way

00:42:46,560 --> 00:42:49,680
we design our libraries because we can't

00:42:48,319 --> 00:42:52,160
we can exactly say

00:42:49,680 --> 00:42:53,280
what the interface of that type is in

00:42:52,160 --> 00:42:55,280
code

00:42:53,280 --> 00:42:56,319
so earlier when you were designing a

00:42:55,280 --> 00:42:57,760
library like

00:42:56,319 --> 00:42:59,359
let's imagine you you want to write in

00:42:57,760 --> 00:43:00,240
your library you would you would ask

00:42:59,359 --> 00:43:02,000
yourself okay like

00:43:00,240 --> 00:43:03,440
how do i go about this like what classes

00:43:02,000 --> 00:43:05,119
do i need am i going to use like an

00:43:03,440 --> 00:43:07,920
inheritance like hierarchy and base

00:43:05,119 --> 00:43:10,319
classes am i going to use templates like

00:43:07,920 --> 00:43:11,680
um now the first question you're going

00:43:10,319 --> 00:43:14,480
to ask yourself is

00:43:11,680 --> 00:43:16,079
what concept do i need to define and

00:43:14,480 --> 00:43:17,280
then

00:43:16,079 --> 00:43:19,200
everything is basically just kind of

00:43:17,280 --> 00:43:21,839
gonna fall off from that

00:43:19,200 --> 00:43:22,319
and that is really nice that changes

00:43:21,839 --> 00:43:24,079
everything

00:43:22,319 --> 00:43:25,760
once you embrace this idea of like

00:43:24,079 --> 00:43:27,520
designing libraries using concepts you

00:43:25,760 --> 00:43:30,079
never go back

00:43:27,520 --> 00:43:31,599
and this lets you write like more

00:43:30,079 --> 00:43:32,960
flexible libraries more powerful

00:43:31,599 --> 00:43:35,119
libraries

00:43:32,960 --> 00:43:37,599
and uh some libraries are just outright

00:43:35,119 --> 00:43:41,040
impossible to write blood concepts and

00:43:37,599 --> 00:43:43,760
the best example of that is ranges

00:43:41,040 --> 00:43:44,400
um so um let's talk about ranges a

00:43:43,760 --> 00:43:47,359
little bit

00:43:44,400 --> 00:43:47,760
um so that's like the most basic thing

00:43:47,359 --> 00:43:51,680
um

00:43:47,760 --> 00:43:53,280
let's say we have a user so users

00:43:51,680 --> 00:43:55,200
have a name and have an age and then you

00:43:53,280 --> 00:43:56,720
have a vector of these users

00:43:55,200 --> 00:43:58,720
and what you want to do is you just want

00:43:56,720 --> 00:43:59,440
to sort them by their age okay very

00:43:58,720 --> 00:44:01,200
simple so

00:43:59,440 --> 00:44:02,560
previously you would just use the sword

00:44:01,200 --> 00:44:03,359
you would pass it a begin and an end

00:44:02,560 --> 00:44:06,079
iterator

00:44:03,359 --> 00:44:07,760
this is kind of annoying um so a bunch

00:44:06,079 --> 00:44:10,079
of code bases that i have seen they

00:44:07,760 --> 00:44:12,800
actually replace this like begin and end

00:44:10,079 --> 00:44:14,079
uh stuff with different overloads of all

00:44:12,800 --> 00:44:15,680
these like standard algorithms which

00:44:14,079 --> 00:44:17,520
just take one argument which is just

00:44:15,680 --> 00:44:19,280
your container

00:44:17,520 --> 00:44:20,960
so a bunch of libraries have that

00:44:19,280 --> 00:44:24,160
epsilon has that we have it in the code

00:44:20,960 --> 00:44:26,400
base where i work with at the moment

00:44:24,160 --> 00:44:28,160
uh and um so that we don't have to write

00:44:26,400 --> 00:44:29,839
begin and end all the time and the good

00:44:28,160 --> 00:44:30,800
news is that ranges are going to give us

00:44:29,839 --> 00:44:32,160
those overloads

00:44:30,800 --> 00:44:33,920
in the standard language so now we just

00:44:32,160 --> 00:44:36,079
need to pass

00:44:33,920 --> 00:44:37,359
just the vector right so that's that's

00:44:36,079 --> 00:44:39,359
great

00:44:37,359 --> 00:44:41,280
but it's not just an overload right so

00:44:39,359 --> 00:44:43,839
because it's also constrained

00:44:41,280 --> 00:44:45,520
with content so if you pass in something

00:44:43,839 --> 00:44:46,560
that is not arranged that can be sorted

00:44:45,520 --> 00:44:48,240
you're going to get one of these like

00:44:46,560 --> 00:44:49,839
really nice error messages

00:44:48,240 --> 00:44:52,079
whereas previously it will probably

00:44:49,839 --> 00:44:55,119
explode

00:44:52,079 --> 00:44:56,480
and um another feature that rangers have

00:44:55,119 --> 00:44:58,480
which is really nice is uh this thing

00:44:56,480 --> 00:45:01,200
called projections

00:44:58,480 --> 00:45:03,040
uh that's like um a third argument that

00:45:01,200 --> 00:45:04,079
algorithms like sword now have which is

00:45:03,040 --> 00:45:07,680
really nice

00:45:04,079 --> 00:45:10,000
and then this stuff looks like this so

00:45:07,680 --> 00:45:10,720
you just pass in a projection onto the

00:45:10,000 --> 00:45:14,640
member

00:45:10,720 --> 00:45:16,720
age of this user and now

00:45:14,640 --> 00:45:18,000
the h is just an end so now you don't

00:45:16,720 --> 00:45:20,160
even need the lamina anymore

00:45:18,000 --> 00:45:22,160
because the sword already knows how the

00:45:20,160 --> 00:45:22,560
sword ends um if you just pass it's the

00:45:22,160 --> 00:45:24,240
less

00:45:22,560 --> 00:45:26,160
right that's the default way of doing

00:45:24,240 --> 00:45:28,160
this so now you get rid of this lambda

00:45:26,160 --> 00:45:31,280
entirely

00:45:28,160 --> 00:45:32,240
and that's really cool so um let's look

00:45:31,280 --> 00:45:34,319
at the uh

00:45:32,240 --> 00:45:35,440
declaration of state range of sort it

00:45:34,319 --> 00:45:38,640
looks something like that

00:45:35,440 --> 00:45:40,319
and you see okay so it takes a range a

00:45:38,640 --> 00:45:42,000
comparator and now it takes a projection

00:45:40,319 --> 00:45:43,520
as well and it's a template

00:45:42,000 --> 00:45:45,440
but it's also a constraint template

00:45:43,520 --> 00:45:47,760
right so

00:45:45,440 --> 00:45:49,520
um it says that the first template

00:45:47,760 --> 00:45:50,960
argument has to be a random access range

00:45:49,520 --> 00:45:53,680
because we need that for sorting and

00:45:50,960 --> 00:45:57,040
then this also requires saying

00:45:53,680 --> 00:45:58,160
uh this requires the um this thing to be

00:45:57,040 --> 00:46:00,319
sortable

00:45:58,160 --> 00:46:02,079
and what does sortable mean the concept

00:46:00,319 --> 00:46:03,839
is sortable so if you look up the

00:46:02,079 --> 00:46:05,200
declaration definition of sortable it

00:46:03,839 --> 00:46:06,720
turns out well

00:46:05,200 --> 00:46:08,720
um something is sortable if it's

00:46:06,720 --> 00:46:09,680
permutable and if there's a strict big

00:46:08,720 --> 00:46:12,160
order

00:46:09,680 --> 00:46:13,520
which kind of makes sense right but it

00:46:12,160 --> 00:46:15,280
kind of goes all the way down like that

00:46:13,520 --> 00:46:17,440
if you look up permutable turns out well

00:46:15,280 --> 00:46:19,200
immutable is something that

00:46:17,440 --> 00:46:20,800
has you know at least a forward iterator

00:46:19,200 --> 00:46:23,119
and is indirectly movable storable and

00:46:20,800 --> 00:46:25,200
swappable

00:46:23,119 --> 00:46:26,480
and it's just kind of the whole library

00:46:25,200 --> 00:46:28,079
the whole range library swedish is

00:46:26,480 --> 00:46:30,720
designed all the way like that it's

00:46:28,079 --> 00:46:33,920
really completely built upon concepts

00:46:30,720 --> 00:46:35,680
and um just imagine for a second um

00:46:33,920 --> 00:46:37,440
how you would implement that if you had

00:46:35,680 --> 00:46:40,400
to emulate this

00:46:37,440 --> 00:46:42,160
would still enable it right so this

00:46:40,400 --> 00:46:44,880
would be ridiculous

00:46:42,160 --> 00:46:46,640
uh nobody maybe except if you're eric

00:46:44,880 --> 00:46:47,839
niebler would be able to write them that

00:46:46,640 --> 00:46:50,880
you wouldn't even like

00:46:47,839 --> 00:46:53,200
try to do that right but with concepts

00:46:50,880 --> 00:46:55,599
that's just code right you can just read

00:46:53,200 --> 00:46:58,560
it it makes sense

00:46:55,599 --> 00:46:59,839
um so let's go back to um our vector of

00:46:58,560 --> 00:47:01,680
units

00:46:59,839 --> 00:47:04,480
what else can we do with ranges so let's

00:47:01,680 --> 00:47:06,079
make this um a const vector actually

00:47:04,480 --> 00:47:08,640
and the reason i'm putting a cons there

00:47:06,079 --> 00:47:10,160
is i want to make this range

00:47:08,640 --> 00:47:11,760
basically not modifiable so you cannot

00:47:10,160 --> 00:47:12,960
modify it in place and that's really to

00:47:11,760 --> 00:47:15,200
emulate

00:47:12,960 --> 00:47:16,960
uh arrange for example if you would read

00:47:15,200 --> 00:47:18,400
the users of the disk or you would use

00:47:16,960 --> 00:47:20,880
the readers uh sorry

00:47:18,400 --> 00:47:23,280
read the users um from a network like

00:47:20,880 --> 00:47:26,480
one by one something like that right

00:47:23,280 --> 00:47:29,200
so race if you cannot modify in place

00:47:26,480 --> 00:47:31,359
um and then um okay let's do something a

00:47:29,200 --> 00:47:34,160
little bit more interesting let's um

00:47:31,359 --> 00:47:35,200
remove all the users that are under the

00:47:34,160 --> 00:47:37,839
age of 18

00:47:35,200 --> 00:47:39,520
and let's print the age of all the

00:47:37,839 --> 00:47:41,520
remaining users

00:47:39,520 --> 00:47:42,559
and how would you implement this without

00:47:41,520 --> 00:47:44,400
ranges

00:47:42,559 --> 00:47:45,839
all right so you have a vector of users

00:47:44,400 --> 00:47:49,440
so you would then

00:47:45,839 --> 00:47:53,680
um use copy if um

00:47:49,440 --> 00:47:55,680
with a function or lambda

00:47:53,680 --> 00:47:57,680
basically to filter out the underage

00:47:55,680 --> 00:47:59,200
users and then you would use a transform

00:47:57,680 --> 00:48:01,440
for example that's one way of writing

00:47:59,200 --> 00:48:04,480
this uh to print their age

00:48:01,440 --> 00:48:06,960
um and

00:48:04,480 --> 00:48:08,160
this is kind of like um not great this

00:48:06,960 --> 00:48:10,240
is a lot of code

00:48:08,160 --> 00:48:11,920
so a lot of people ask um so okay why

00:48:10,240 --> 00:48:13,359
don't we have a transformative in the

00:48:11,920 --> 00:48:14,720
standard library right to make this

00:48:13,359 --> 00:48:15,839
shorter to make this like one step

00:48:14,720 --> 00:48:17,920
instead of two

00:48:15,839 --> 00:48:19,599
and the answer is well if we had

00:48:17,920 --> 00:48:21,440
transformer then we also would have to

00:48:19,599 --> 00:48:22,480
have generative and fill it and all the

00:48:21,440 --> 00:48:25,280
other combinations and

00:48:22,480 --> 00:48:27,760
you'll get like this uh permutation like

00:48:25,280 --> 00:48:30,400
a combinational explosion

00:48:27,760 --> 00:48:31,440
um so that's kind of not the way to go

00:48:30,400 --> 00:48:34,400
and but how do we

00:48:31,440 --> 00:48:35,520
combine algorithms and it turns out

00:48:34,400 --> 00:48:37,440
without ranges

00:48:35,520 --> 00:48:39,359
like really the only way to do this like

00:48:37,440 --> 00:48:40,960
that is to combine them eagerly in this

00:48:39,359 --> 00:48:43,359
like procedural stem where you do one

00:48:40,960 --> 00:48:45,040
and then the other and then the other

00:48:43,359 --> 00:48:47,119
and that also unfortunately means that

00:48:45,040 --> 00:48:47,599
we need to uh do the loop over the data

00:48:47,119 --> 00:48:50,640
twice

00:48:47,599 --> 00:48:52,400
right what ranges allows us to do

00:48:50,640 --> 00:48:54,480
is we can combine them lazily like in a

00:48:52,400 --> 00:48:56,160
functional style

00:48:54,480 --> 00:48:58,000
and and that's going to look like that

00:48:56,160 --> 00:48:59,760
right so we have these ranges called

00:48:58,000 --> 00:49:01,040
views which are just wrapping other

00:48:59,760 --> 00:49:02,480
ranges

00:49:01,040 --> 00:49:04,319
and then you can easily combine them

00:49:02,480 --> 00:49:05,920
with the pipe operator and then they're

00:49:04,319 --> 00:49:07,599
lazy so the code in the green box is

00:49:05,920 --> 00:49:08,880
actually not going to evaluate anything

00:49:07,599 --> 00:49:10,079
it's not going to loop over the data

00:49:08,880 --> 00:49:10,480
it's not going to do anything it's going

00:49:10,079 --> 00:49:12,559
to

00:49:10,480 --> 00:49:13,839
create this like nested structure of

00:49:12,559 --> 00:49:15,920
ranges

00:49:13,839 --> 00:49:17,839
and then down there when you actually um

00:49:15,920 --> 00:49:19,040
copy them out into an osu iterator which

00:49:17,839 --> 00:49:21,040
is essentially just another way of

00:49:19,040 --> 00:49:22,720
saying print this

00:49:21,040 --> 00:49:24,559
that's when you're actually going to

00:49:22,720 --> 00:49:26,000
loop over the data and do all of the

00:49:24,559 --> 00:49:26,480
stuff but that's going to be just one

00:49:26,000 --> 00:49:29,680
loop

00:49:26,480 --> 00:49:31,040
right and

00:49:29,680 --> 00:49:32,480
the other interesting thing about this

00:49:31,040 --> 00:49:33,599
is that if you end up like chaining

00:49:32,480 --> 00:49:36,160
ranges like that to

00:49:33,599 --> 00:49:38,240
to achieve your result you actually end

00:49:36,160 --> 00:49:39,680
up not writing any loops at all anymore

00:49:38,240 --> 00:49:42,400
and that's really nice so remember when

00:49:39,680 --> 00:49:44,559
sean parent said in his talk in 2013

00:49:42,400 --> 00:49:46,160
no real loops don't play loops so now

00:49:44,559 --> 00:49:47,200
with ranges we really don't have to

00:49:46,160 --> 00:49:48,400
write loops anymore

00:49:47,200 --> 00:49:50,720
right so because you can just do

00:49:48,400 --> 00:49:55,200
everything with these like chained um

00:49:50,720 --> 00:49:58,400
chained ranges and but of course because

00:49:55,200 --> 00:50:00,640
result is a range and ranges

00:49:58,400 --> 00:50:02,800
still have begin and end you can still

00:50:00,640 --> 00:50:05,280
use them with loops if you want

00:50:02,800 --> 00:50:06,640
so you could stick this whole expression

00:50:05,280 --> 00:50:08,559
which evaluates to range

00:50:06,640 --> 00:50:10,079
in a for loop in a range-based folder

00:50:08,559 --> 00:50:11,280
you can loop over that and that has a

00:50:10,079 --> 00:50:14,880
beginning and an end

00:50:11,280 --> 00:50:16,640
so that will also just work and filter

00:50:14,880 --> 00:50:17,520
transfer and transform are really just

00:50:16,640 --> 00:50:19,359
two examples

00:50:17,520 --> 00:50:21,599
um there are many many more views in c

00:50:19,359 --> 00:50:25,040
business 20. here's another example

00:50:21,599 --> 00:50:26,000
so we have studiota and then in ranges

00:50:25,040 --> 00:50:27,920
now we also have

00:50:26,000 --> 00:50:30,000
uh range's version of yota which is the

00:50:27,920 --> 00:50:33,119
views yota

00:50:30,000 --> 00:50:35,680
and um that

00:50:33,119 --> 00:50:36,240
range just prints the sequence zero one

00:50:35,680 --> 00:50:39,280
two three

00:50:36,240 --> 00:50:40,000
right and um the cool thing about yota

00:50:39,280 --> 00:50:41,599
is you can print

00:50:40,000 --> 00:50:43,440
out as many numbers as you want so it's

00:50:41,599 --> 00:50:44,800
like it's lazy right you don't have to

00:50:43,440 --> 00:50:46,240
store them anywhere you don't have to

00:50:44,800 --> 00:50:47,119
like put them in a vector you can just

00:50:46,240 --> 00:50:50,240
like

00:50:47,119 --> 00:50:51,839
lazily fetch them one by one on demand

00:50:50,240 --> 00:50:53,200
and you don't need any extra memory for

00:50:51,839 --> 00:50:55,520
that because they never have to store

00:50:53,200 --> 00:50:57,119
the whole sequence in memory

00:50:55,520 --> 00:50:58,480
and that's actually another way of

00:50:57,119 --> 00:51:00,240
achieving the same thing that we did

00:50:58,480 --> 00:51:01,680
earlier in coroutines with coroutines

00:51:00,240 --> 00:51:04,160
right so in fact

00:51:01,680 --> 00:51:05,760
that's actually pretty cool because um

00:51:04,160 --> 00:51:06,880
remember when we when i showed you this

00:51:05,760 --> 00:51:09,040
paper that we're going to get into the

00:51:06,880 --> 00:51:10,079
suspension 3 with a stitch generator for

00:51:09,040 --> 00:51:11,920
quarantines

00:51:10,079 --> 00:51:13,599
the generator itself is actually also

00:51:11,920 --> 00:51:16,400
going to be a range

00:51:13,599 --> 00:51:18,160
so in a weird way they're just like kind

00:51:16,400 --> 00:51:21,040
of two sides of the same coin and i

00:51:18,160 --> 00:51:24,160
think that's that's really pretty cool

00:51:21,040 --> 00:51:25,520
so um yeah ranges are a big um step of

00:51:24,160 --> 00:51:27,280
evolution for standard

00:51:25,520 --> 00:51:28,559
algorithms and i really encourage you to

00:51:27,280 --> 00:51:30,160
check them out but

00:51:28,559 --> 00:51:32,480
uh we have one more big features on our

00:51:30,160 --> 00:51:34,640
list which is modules

00:51:32,480 --> 00:51:36,079
so let's talk about modules but before

00:51:34,640 --> 00:51:39,200
we can talk about modules

00:51:36,079 --> 00:51:40,720
we have to talk about headers

00:51:39,200 --> 00:51:42,319
so headers we all write headers you all

00:51:40,720 --> 00:51:43,119
love headers that's the world we live in

00:51:42,319 --> 00:51:45,119
today

00:51:43,119 --> 00:51:46,640
here's the header so we implemented this

00:51:45,119 --> 00:51:48,240
generator earlier

00:51:46,640 --> 00:51:50,160
uh let's put it into a header right

00:51:48,240 --> 00:51:51,200
that's great and uh we had this math

00:51:50,160 --> 00:51:52,800
function earlier

00:51:51,200 --> 00:51:54,880
this power of two things let's put that

00:51:52,800 --> 00:51:56,720
into a math.header as well

00:51:54,880 --> 00:51:59,440
so now we have these two headers they're

00:51:56,720 --> 00:52:01,040
great and maybe let's use them now maybe

00:51:59,440 --> 00:52:02,559
we're doing some stuff with chorogenes

00:52:01,040 --> 00:52:04,480
and some stuff with math

00:52:02,559 --> 00:52:05,599
so we need both of those headers so we

00:52:04,480 --> 00:52:07,040
hash include math

00:52:05,599 --> 00:52:09,040
uh mathematician rehashing from

00:52:07,040 --> 00:52:11,200
generated video and maybe we have

00:52:09,040 --> 00:52:13,200
another cvp file where we also need math

00:52:11,200 --> 00:52:16,800
donation we also need generated image

00:52:13,200 --> 00:52:18,400
right so what um i mean this is this

00:52:16,800 --> 00:52:19,520
this is what we're all doing but there's

00:52:18,400 --> 00:52:22,000
so many problems with this

00:52:19,520 --> 00:52:24,240
right so what hash include essentially

00:52:22,000 --> 00:52:25,920
does is it just copy paste the code in

00:52:24,240 --> 00:52:27,440
in there right it just takes the header

00:52:25,920 --> 00:52:28,800
and just copy paste the code into the

00:52:27,440 --> 00:52:29,839
cpp form

00:52:28,800 --> 00:52:32,559
so and that's going to be your

00:52:29,839 --> 00:52:33,200
translation unit so whenever you include

00:52:32,559 --> 00:52:34,960
the same

00:52:33,200 --> 00:52:37,119
uh headers into multiple translation

00:52:34,960 --> 00:52:37,839
units like here the compiler has to just

00:52:37,119 --> 00:52:39,040
repeat that

00:52:37,839 --> 00:52:41,040
over and over again so it's going to

00:52:39,040 --> 00:52:42,319
copy paste the code here pause it

00:52:41,040 --> 00:52:44,000
compile it it's going to copy paste the

00:52:42,319 --> 00:52:45,359
code there and this other cpp file pause

00:52:44,000 --> 00:52:47,119
it and compile it it's going to just

00:52:45,359 --> 00:52:48,480
keep doing this over and over again and

00:52:47,119 --> 00:52:49,359
if you keep if you include these two

00:52:48,480 --> 00:52:52,000
headers um

00:52:49,359 --> 00:52:53,200
in 20 different cp files which are 20

00:52:52,000 --> 00:52:55,119
different translation units so the

00:52:53,200 --> 00:52:56,000
compiler is going to have to parse and

00:52:55,119 --> 00:52:59,280
compile

00:52:56,000 --> 00:53:01,200
those headers 20 times and

00:52:59,280 --> 00:53:02,720
on the one hand that's great because

00:53:01,200 --> 00:53:03,920
that means translation units are

00:53:02,720 --> 00:53:06,079
independent from each other so it's

00:53:03,920 --> 00:53:08,000
really easy to parallelize this

00:53:06,079 --> 00:53:09,440
but on the other hand it's really bad

00:53:08,000 --> 00:53:11,599
because it's just slow and you're

00:53:09,440 --> 00:53:13,920
wasting a lot of resources

00:53:11,599 --> 00:53:15,760
it's actually really bad because it

00:53:13,920 --> 00:53:17,280
actually scales non-linearly with the

00:53:15,760 --> 00:53:18,240
amount of transformation units that you

00:53:17,280 --> 00:53:21,680
have so that's

00:53:18,240 --> 00:53:22,880
really bad and it's like literally the

00:53:21,680 --> 00:53:24,400
same headers that you include in the

00:53:22,880 --> 00:53:26,160
same order and then you can do some

00:53:24,400 --> 00:53:29,359
clever stuff like cache it like c

00:53:26,160 --> 00:53:31,680
cache and tools like that but let's just

00:53:29,359 --> 00:53:33,040
flip around two of these includes and

00:53:31,680 --> 00:53:34,319
all of a sudden it's a different code

00:53:33,040 --> 00:53:36,319
right because

00:53:34,319 --> 00:53:37,839
um the pre-processor is going to copy

00:53:36,319 --> 00:53:40,000
paste it in it's it's different right

00:53:37,839 --> 00:53:41,440
the order is different so

00:53:40,000 --> 00:53:43,520
again the compiler is going to have to

00:53:41,440 --> 00:53:45,839
pause and and compile this all over

00:53:43,520 --> 00:53:48,079
again because it's different code now

00:53:45,839 --> 00:53:49,839
so that's one problem another great

00:53:48,079 --> 00:53:51,119
thing is you can have cycles between

00:53:49,839 --> 00:53:52,800
headers right so

00:53:51,119 --> 00:53:54,000
because the preprocessors just copy

00:53:52,800 --> 00:53:55,599
pasting stuff it's not going to prevent

00:53:54,000 --> 00:53:58,640
you from doing that

00:53:55,599 --> 00:53:59,920
so we have to go in and do things like

00:53:58,640 --> 00:54:03,040
pragma ones or

00:53:59,920 --> 00:54:04,640
header you know include guards um but

00:54:03,040 --> 00:54:06,559
sometimes you forget to do that and then

00:54:04,640 --> 00:54:08,160
you spend two hours trying to figure out

00:54:06,559 --> 00:54:11,839
these weird errors where

00:54:08,160 --> 00:54:13,280
um you know um you know something header

00:54:11,839 --> 00:54:14,559
is included from somewhere else and you

00:54:13,280 --> 00:54:16,319
look at this like a

00:54:14,559 --> 00:54:19,280
long stack of compiler errors and you're

00:54:16,319 --> 00:54:21,680
trying to figure out what's going on

00:54:19,280 --> 00:54:24,079
and if that were not bad enough you also

00:54:21,680 --> 00:54:26,480
have macros

00:54:24,079 --> 00:54:28,800
and turns out that macros can basically

00:54:26,480 --> 00:54:30,800
uh leak into and out of everything right

00:54:28,800 --> 00:54:32,480
so if you have a macro maybe in other

00:54:30,800 --> 00:54:34,240
stuff with cpp

00:54:32,480 --> 00:54:35,760
uh just above your header includes so

00:54:34,240 --> 00:54:37,599
that macro is going to leak into those

00:54:35,760 --> 00:54:38,000
headers right and it can change anything

00:54:37,599 --> 00:54:39,760
in there

00:54:38,000 --> 00:54:42,319
right if you define any bar before you

00:54:39,760 --> 00:54:43,839
include generator that age that might

00:54:42,319 --> 00:54:45,920
change the layout of the class in that

00:54:43,839 --> 00:54:48,079
hand right so

00:54:45,920 --> 00:54:49,040
um that's going to be really bad because

00:54:48,079 --> 00:54:50,400
then you're going to have two different

00:54:49,040 --> 00:54:51,040
definitions of the class you're going to

00:54:50,400 --> 00:54:54,720
have

00:54:51,040 --> 00:54:55,280
audio violations so uh that's basically

00:54:54,720 --> 00:54:56,960
like uh

00:54:55,280 --> 00:54:58,319
undefined behavior but it's worse

00:54:56,960 --> 00:54:59,920
actually because it's undefined behavior

00:54:58,319 --> 00:55:03,680
on the level of a linker

00:54:59,920 --> 00:55:05,200
so you're gonna have got some program

00:55:03,680 --> 00:55:06,559
which is just gonna crash or do

00:55:05,200 --> 00:55:07,520
something weird it's definitely not

00:55:06,559 --> 00:55:08,799
going to do what you want

00:55:07,520 --> 00:55:11,599
you're not going to get a compiler area

00:55:08,799 --> 00:55:12,799
you're not going to get a warning

00:55:11,599 --> 00:55:15,440
you don't know what's going on it's

00:55:12,799 --> 00:55:17,599
really fun to debug this

00:55:15,440 --> 00:55:18,960
and macros can not only leak into

00:55:17,599 --> 00:55:20,000
headers they can also leak out of

00:55:18,960 --> 00:55:23,280
headers so for example

00:55:20,000 --> 00:55:24,799
if you define uh a macro in the

00:55:23,280 --> 00:55:26,400
generated blade shutter

00:55:24,799 --> 00:55:28,400
that's gonna leak out of the header and

00:55:26,400 --> 00:55:30,079
it's gonna maybe infect other headers or

00:55:28,400 --> 00:55:31,200
infect your cpp file and change stuff in

00:55:30,079 --> 00:55:33,680
there

00:55:31,200 --> 00:55:34,960
and that's really bad and the other

00:55:33,680 --> 00:55:35,680
really bad thing about headers is that

00:55:34,960 --> 00:55:38,079
there's really no

00:55:35,680 --> 00:55:40,240
um good encapsulation mechanism right so

00:55:38,079 --> 00:55:43,440
let's say you have the generator

00:55:40,240 --> 00:55:44,720
um and then maybe you have like

00:55:43,440 --> 00:55:46,960
some kind of other helper struct which

00:55:44,720 --> 00:55:50,720
is an implementation detail right

00:55:46,960 --> 00:55:52,000
um and then um you don't want users to

00:55:50,720 --> 00:55:52,559
see this you don't want users to use

00:55:52,000 --> 00:55:54,079
this

00:55:52,559 --> 00:55:55,680
but you can't really prevent them from

00:55:54,079 --> 00:55:58,079
doing that so

00:55:55,680 --> 00:55:59,359
if um you know if it's a if it's a

00:55:58,079 --> 00:56:00,880
standard library header if your standard

00:55:59,359 --> 00:56:02,319
library implementer you can prefix this

00:56:00,880 --> 00:56:04,319
with double underscore

00:56:02,319 --> 00:56:06,000
if you just write a normal library then

00:56:04,319 --> 00:56:07,280
people do the namespace detail thing

00:56:06,000 --> 00:56:09,119
which is kind of a convention it doesn't

00:56:07,280 --> 00:56:11,280
actually prevent anyone from

00:56:09,119 --> 00:56:12,640
going in and reaching it and doing stuff

00:56:11,280 --> 00:56:13,839
so there's really no encapsulation

00:56:12,640 --> 00:56:17,200
method at all

00:56:13,839 --> 00:56:18,160
modules sold all of this right so in the

00:56:17,200 --> 00:56:20,000
modules world

00:56:18,160 --> 00:56:21,920
you would write your generator like this

00:56:20,000 --> 00:56:23,599
so that's a module

00:56:21,920 --> 00:56:25,359
and now the only things that are visible

00:56:23,599 --> 00:56:27,200
outside are the things that you export

00:56:25,359 --> 00:56:28,640
right so you export generate you don't

00:56:27,200 --> 00:56:31,200
export the helper so the helper is

00:56:28,640 --> 00:56:32,880
essentially going to be a private thing

00:56:31,200 --> 00:56:34,319
and also this module is completely

00:56:32,880 --> 00:56:36,799
self-contained now you can't have cycles

00:56:34,319 --> 00:56:38,079
between modules you can't um

00:56:36,799 --> 00:56:39,359
macros are not going to leak into the

00:56:38,079 --> 00:56:40,400
module they're going to leak out of the

00:56:39,359 --> 00:56:42,000
module

00:56:40,400 --> 00:56:43,680
so it's completely self-contained it's

00:56:42,000 --> 00:56:45,119
going to have the compiler is only going

00:56:43,680 --> 00:56:47,359
to have to compile and parse it

00:56:45,119 --> 00:56:48,319
only once actually what it's going to do

00:56:47,359 --> 00:56:49,599
is going

00:56:48,319 --> 00:56:51,680
as the first step is going to create

00:56:49,599 --> 00:56:53,599
this thing called the bmi or binary

00:56:51,680 --> 00:56:55,440
module interface which

00:56:53,599 --> 00:56:57,119
uh seems a bit confusing because you

00:56:55,440 --> 00:56:58,640
might think binary mode interface maybe

00:56:57,119 --> 00:57:00,799
it's some kind of like object file like

00:56:58,640 --> 00:57:01,839
dot o like a compiled like binary code

00:57:00,799 --> 00:57:05,200
that's not what it is

00:57:01,839 --> 00:57:06,480
binary here just means not text this is

00:57:05,200 --> 00:57:07,920
actually just like um

00:57:06,480 --> 00:57:10,160
an alternative representation of the

00:57:07,920 --> 00:57:12,240
code so that the compiler can

00:57:10,160 --> 00:57:13,440
more quickly find all the declarations

00:57:12,240 --> 00:57:15,359
and definitions in this it's going to be

00:57:13,440 --> 00:57:16,880
some kind of tree structure

00:57:15,359 --> 00:57:18,319
um and that tree structure is actually

00:57:16,880 --> 00:57:19,839
going to be specific to the compiler

00:57:18,319 --> 00:57:21,119
you're using and it's also going to have

00:57:19,839 --> 00:57:22,240
things like your current compiler

00:57:21,119 --> 00:57:25,440
settings

00:57:22,240 --> 00:57:26,960
uh like even flags that you defined um

00:57:25,440 --> 00:57:27,920
like what warnings are on and stuff like

00:57:26,960 --> 00:57:29,040
that it's going to have your compiler

00:57:27,920 --> 00:57:30,799
version so it's really just like an

00:57:29,040 --> 00:57:32,559
implementation detail

00:57:30,799 --> 00:57:35,359
of your build system right so you should

00:57:32,559 --> 00:57:38,400
really not distribute this file ever

00:57:35,359 --> 00:57:40,480
so that's actually really important if

00:57:38,400 --> 00:57:41,839
you give a bmi file to someone else that

00:57:40,480 --> 00:57:43,040
other person is going to have a really

00:57:41,839 --> 00:57:46,880
bad time so don't

00:57:43,040 --> 00:57:49,520
don't do that um but

00:57:46,880 --> 00:57:51,520
if you have a module you can now just in

00:57:49,520 --> 00:57:53,040
your query in staff.cpp you can just

00:57:51,520 --> 00:57:54,319
import that module you can import

00:57:53,040 --> 00:57:57,280
generate you can import math

00:57:54,319 --> 00:57:59,280
the order doesn't matter anymore and

00:57:57,280 --> 00:58:01,920
basically that problem is just sold

00:57:59,280 --> 00:58:02,400
so modules are a massive feature there

00:58:01,920 --> 00:58:03,920
are many

00:58:02,400 --> 00:58:05,760
other details and additional levels to

00:58:03,920 --> 00:58:07,359
this that i didn't cover

00:58:05,760 --> 00:58:09,599
there's many other ways to like organize

00:58:07,359 --> 00:58:11,119
your code and split up your modules into

00:58:09,599 --> 00:58:11,839
like different subunits and stuff like

00:58:11,119 --> 00:58:13,359
that

00:58:11,839 --> 00:58:15,920
so i don't have time to talk about that

00:58:13,359 --> 00:58:16,559
now but um the important thing here is

00:58:15,920 --> 00:58:18,559
that

00:58:16,559 --> 00:58:20,319
it really fundamentally changes the

00:58:18,559 --> 00:58:22,160
architecture of your program right so it

00:58:20,319 --> 00:58:23,040
changes how you package up libraries it

00:58:22,160 --> 00:58:25,920
changes how we

00:58:23,040 --> 00:58:28,000
um um yeah how we compile our code

00:58:25,920 --> 00:58:29,119
really like it's it's a huge ecosystem

00:58:28,000 --> 00:58:31,599
change

00:58:29,119 --> 00:58:33,520
so so this is just by far the most

00:58:31,599 --> 00:58:36,240
impactful and significant uh feature in

00:58:33,520 --> 00:58:39,440
sequences 20.

00:58:36,240 --> 00:58:40,079
so um yes this is these are the big four

00:58:39,440 --> 00:58:41,680
features

00:58:40,079 --> 00:58:43,119
this is kind of what i wanted to say

00:58:41,680 --> 00:58:45,760
about those in this talk

00:58:43,119 --> 00:58:48,480
i see that i have one minute left so i

00:58:45,760 --> 00:58:50,640
have actually a couple more bonus slides

00:58:48,480 --> 00:58:52,160
so we not only have these big features

00:58:50,640 --> 00:58:54,000
in cbs20 but you also have some

00:58:52,160 --> 00:58:56,640
long-awaited fixes

00:58:54,000 --> 00:58:58,559
so one particular thing that every heap

00:58:56,640 --> 00:59:00,000
of stars developer stumbles upon at some

00:58:58,559 --> 00:59:02,000
point in their career and i'm definitely

00:59:00,000 --> 00:59:04,640
not an exception

00:59:02,000 --> 00:59:06,160
is this thing with removing stuff from

00:59:04,640 --> 00:59:08,720
vectors

00:59:06,160 --> 00:59:09,920
um let's say you have a vector with a

00:59:08,720 --> 00:59:11,839
bunch of integers and

00:59:09,920 --> 00:59:13,280
now the task is to remove all the odd

00:59:11,839 --> 00:59:15,520
numbers and i'm sure you've all seen

00:59:13,280 --> 00:59:18,720
this right

00:59:15,520 --> 00:59:20,319
how do we do this

00:59:18,720 --> 00:59:21,599
you have the erase remove idiom and

00:59:20,319 --> 00:59:23,200
that's probably the only thing in the

00:59:21,599 --> 00:59:24,720
standard diary that i hate even more

00:59:23,200 --> 00:59:26,720
than enable if

00:59:24,720 --> 00:59:28,720
because it's horrible like everyone just

00:59:26,720 --> 00:59:30,720
like stumbles upon this like

00:59:28,720 --> 00:59:31,839
everyone like the first time i wanted to

00:59:30,720 --> 00:59:33,200
do this like i did

00:59:31,839 --> 00:59:35,040
what probably everyone else tries the

00:59:33,200 --> 00:59:37,040
first time around well you just remove

00:59:35,040 --> 00:59:38,640
uh element by element in the loop and

00:59:37,040 --> 00:59:40,160
then someone tells you well no that's

00:59:38,640 --> 00:59:41,040
really slow that's really inefficient

00:59:40,160 --> 00:59:44,480
you have to like

00:59:41,040 --> 00:59:45,680
do this remove algorithm except

00:59:44,480 --> 00:59:47,119
remover is actually not removing

00:59:45,680 --> 00:59:48,640
anything it's just moving the stuff you

00:59:47,119 --> 00:59:50,960
want to remove to the end

00:59:48,640 --> 00:59:52,400
except um actually just this year i

00:59:50,960 --> 00:59:53,680
learned that's not even true it's not

00:59:52,400 --> 00:59:54,960
removing anything to the end it's

00:59:53,680 --> 00:59:56,799
actually moving the stuff that you want

00:59:54,960 --> 00:59:58,720
to keep to the front

00:59:56,799 --> 01:00:00,160
right so that's what it's actually doing

00:59:58,720 --> 01:00:01,200
and when it's done doing that you need

01:00:00,160 --> 01:00:02,799
to do this erase

01:00:01,200 --> 01:00:04,640
which is going to just basically crop

01:00:02,799 --> 01:00:05,920
the range to the stuff that the sub rays

01:00:04,640 --> 01:00:08,960
that you want

01:00:05,920 --> 01:00:11,280
and and this is just horrible right so

01:00:08,960 --> 01:00:12,640
the good news

01:00:11,280 --> 01:00:15,200
we never have to do this again because

01:00:12,640 --> 01:00:16,880
in c plus 20 we can just write this

01:00:15,200 --> 01:00:18,720
so we have stood a race which just takes

01:00:16,880 --> 01:00:20,240
the lecture does the job

01:00:18,720 --> 01:00:22,960
and that's amazing so we can forget

01:00:20,240 --> 01:00:24,079
about um erase remove idiom and never

01:00:22,960 --> 01:00:25,680
speak about this again

01:00:24,079 --> 01:00:27,520
and i just mentioned this particular one

01:00:25,680 --> 01:00:28,079
as an example because it's such a common

01:00:27,520 --> 01:00:30,480
thing

01:00:28,079 --> 01:00:32,160
but cpr 20 has a lot of stuff like this

01:00:30,480 --> 01:00:34,799
it just removes a lot of these

01:00:32,160 --> 01:00:35,760
obstacles and that makes cpa stars

01:00:34,799 --> 01:00:37,760
easier to teach

01:00:35,760 --> 01:00:40,240
easier to learn it's going to make

01:00:37,760 --> 01:00:43,839
everyday cpa's passcode like this

01:00:40,240 --> 01:00:46,559
easier to read and that in itself

01:00:43,839 --> 01:00:48,799
also significantly changes the way you

01:00:46,559 --> 01:00:50,559
write code

01:00:48,799 --> 01:00:51,839
thank you very much that's all i have

01:00:50,559 --> 01:00:53,280
for today

01:00:51,839 --> 01:00:54,960
i believe we don't have time for

01:00:53,280 --> 01:00:57,040
questions but

01:00:54,960 --> 01:00:58,000
just after this talk i have an ama

01:00:57,040 --> 01:01:00,880
session so

01:00:58,000 --> 01:01:02,160
um make sure you catch me there and i

01:01:00,880 --> 01:01:03,200
will be answering all the questions that

01:01:02,160 --> 01:01:05,440
you have

01:01:03,200 --> 01:01:06,960
and yeah um my name is timo doomna

01:01:05,440 --> 01:01:08,839
thanks for listening you can

01:01:06,960 --> 01:01:10,079
find me on twitter at tumor underscore

01:01:08,839 --> 01:01:14,160
audio

01:01:10,079 --> 01:01:25,839
and yeah enjoy the rest of cppcon

01:01:14,160 --> 01:01:25,839
thank you very much

01:01:34,720 --> 01:01:36,799

YouTube URL: https://www.youtube.com/watch?v=ImLFlLjSveM


