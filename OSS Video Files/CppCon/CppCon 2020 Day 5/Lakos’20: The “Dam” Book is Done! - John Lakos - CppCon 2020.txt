Title: Lakos’20: The “Dam” Book is Done! - John Lakos - CppCon 2020
Publication date: 2020-10-05
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Writing reliable and maintainable C++ software is hard. Designing such software at scale adds a new set of challenges. Large-scale systems require more than just a thorough understanding of the logical design concepts addressed in most popular texts. To be successful on an enterprise scale, developers must also address physical design, a dimension of software engineering that may be unfamiliar even to expert developers.

After more than two decades in the making, Large-Scale C++, Volume I: Process and Architecture, is finally here. Drawing on his over 30 years of hands-on experience building massive, mission-critical enterprise systems, John Lakos, using select excerpts from this glisteningly new volume, elucidates the essential value of (and several techniques needed for) creating and growing hierarchical reusable software a.k.a. Software Capital as the foundation for developing C++ software at virtually unbounded scale.

---
John Lakos, author of Large-Scale C++ Software Design, serves at Bloomberg LP in New York City as a senior architect and mentor for C++ Software Development world-wide.  He is also an active voting member of the C++ Standards Committee’s Evolution Working Group. Previously, Dr. Lakos directed the design and development of infrastructure libraries for proprietary analytic financial applications at Bear Stearns. For 12 years prior, Dr. Lakos developed large frameworks and advanced ICCAD applications at Mentor Graphics, for which he holds multiple software patents. His academic credentials include a Ph.D. in Computer Science ('97) and an Sc.D. in Electrical Engineering ('89) from Columbia University. Dr. Lakos received his undergraduate degrees from MIT in Mathematics ('82) and Computer Science ('81). His next book, entitled Large-Scale C++—Volume I: Process and Architecture, is anticipated in 2019.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,360 --> 00:00:14,880
hello and welcome to my talk

00:00:11,519 --> 00:00:17,119
at cppcon my name is john lakos

00:00:14,880 --> 00:00:19,039
and i'm here with my video buddy kevin

00:00:17,119 --> 00:00:20,640
kline he's the greatest he's helped me

00:00:19,039 --> 00:00:23,519
to get everything going and

00:00:20,640 --> 00:00:24,880
uh i'm looking forward to trying to

00:00:23,519 --> 00:00:27,119
describe to you something that i've been

00:00:24,880 --> 00:00:29,359
working on for a very very long time

00:00:27,119 --> 00:00:30,320
and hopefully it will be of some value

00:00:29,359 --> 00:00:34,480
and

00:00:30,320 --> 00:00:37,600
so i will move ahead this is me

00:00:34,480 --> 00:00:40,000
this is my new book this is me with my

00:00:37,600 --> 00:00:40,000
new book

00:00:40,160 --> 00:00:44,800
what we're going to do today is talk

00:00:41,600 --> 00:00:46,960
about the first chapter chapter zero

00:00:44,800 --> 00:00:49,280
which is an overview of what's really

00:00:46,960 --> 00:00:50,879
important the motivation for the entire

00:00:49,280 --> 00:00:53,520
three book series

00:00:50,879 --> 00:00:55,920
is hierarchical reuse and everything

00:00:53,520 --> 00:00:57,520
else is kind of a detail

00:00:55,920 --> 00:00:59,120
there are three more chapters in this

00:00:57,520 --> 00:01:01,440
book

00:00:59,120 --> 00:01:03,120
process and architecture and there are

00:01:01,440 --> 00:01:05,199
two more volumes planned

00:01:03,120 --> 00:01:06,560
and in fact those volumes were written

00:01:05,199 --> 00:01:08,320
uh already

00:01:06,560 --> 00:01:10,880
and the third volume was written first

00:01:08,320 --> 00:01:12,400
it's kind of like a star wars trilogy

00:01:10,880 --> 00:01:14,080
and they include design and

00:01:12,400 --> 00:01:15,920
implementation in volume 2

00:01:14,080 --> 00:01:18,960
and verification and testing in volume

00:01:15,920 --> 00:01:21,520
3. so let's get started

00:01:18,960 --> 00:01:23,840
this may look familiar uh from a book

00:01:21,520 --> 00:01:27,200
many years ago

00:01:23,840 --> 00:01:27,920
and it's describing the trade-off that

00:01:27,200 --> 00:01:30,960
you make

00:01:27,920 --> 00:01:33,439
between product schedule and budget

00:01:30,960 --> 00:01:35,040
and you can think of them as jc van

00:01:33,439 --> 00:01:38,000
winkle pointed out in the book

00:01:35,040 --> 00:01:39,200
as slider switches you can adjust two of

00:01:38,000 --> 00:01:40,880
them

00:01:39,200 --> 00:01:43,119
and then the third one is pretty much

00:01:40,880 --> 00:01:44,000
dictated so for example if you want to

00:01:43,119 --> 00:01:46,479
build something

00:01:44,000 --> 00:01:47,200
at a given date and you have a certain

00:01:46,479 --> 00:01:48,799
budget

00:01:47,200 --> 00:01:50,880
then the quality of the product is kind

00:01:48,799 --> 00:01:51,680
of determined if you have a certain

00:01:50,880 --> 00:01:54,159
budget

00:01:51,680 --> 00:01:55,600
and you can take as long as you want

00:01:54,159 --> 00:01:57,360
then you can

00:01:55,600 --> 00:01:58,880
do things more efficiently perhaps by

00:01:57,360 --> 00:02:01,439
linearizing them

00:01:58,880 --> 00:02:03,280
to get a better quality product bottom

00:02:01,439 --> 00:02:05,439
line is if you pick any two of these the

00:02:03,280 --> 00:02:08,000
third one is kind of determined

00:02:05,439 --> 00:02:10,160
so the idea here is what can we do to

00:02:08,000 --> 00:02:13,040
break out of this triangle

00:02:10,160 --> 00:02:15,040
and literally 20 years ago i was

00:02:13,040 --> 00:02:18,640
struggling with this problem

00:02:15,040 --> 00:02:21,760
and the solution was

00:02:18,640 --> 00:02:23,280
what we're about to talk about today so

00:02:21,760 --> 00:02:25,680
what we want to do is we want to start

00:02:23,280 --> 00:02:27,680
in 2020 and this original diagram from

00:02:25,680 --> 00:02:30,239
the book was started in 2000

00:02:27,680 --> 00:02:30,959
and the 240 rectangle triangle was

00:02:30,239 --> 00:02:33,440
really

00:02:30,959 --> 00:02:34,400
uh 2020 but we actually went through

00:02:33,440 --> 00:02:36,400
this process

00:02:34,400 --> 00:02:38,560
so now i'm taking 20 years of experience

00:02:36,400 --> 00:02:39,200
doing this projecting out another 20

00:02:38,560 --> 00:02:42,160
years

00:02:39,200 --> 00:02:44,160
to show that the more we do it the wider

00:02:42,160 --> 00:02:46,000
our design space becomes

00:02:44,160 --> 00:02:47,519
our design space in the sense of faster

00:02:46,000 --> 00:02:50,560
better cheaper we can

00:02:47,519 --> 00:02:53,360
we can get more and more efficiencies

00:02:50,560 --> 00:02:54,480
over time provided that we do things

00:02:53,360 --> 00:02:57,120
mindfully

00:02:54,480 --> 00:02:58,959
so how do we do that so if you think

00:02:57,120 --> 00:03:00,000
about what top down design is if you

00:02:58,959 --> 00:03:02,720
were going to go design

00:03:00,000 --> 00:03:04,480
something at school or a small project

00:03:02,720 --> 00:03:05,920
you basically come up with a problem

00:03:04,480 --> 00:03:07,680
that you need to solve

00:03:05,920 --> 00:03:10,319
absolutely nothing wrong with top-down

00:03:07,680 --> 00:03:12,480
design you break it down into sub-pieces

00:03:10,319 --> 00:03:14,560
and sub-pieces and so on and so forth

00:03:12,480 --> 00:03:16,000
and whatever

00:03:14,560 --> 00:03:18,080
and then you get to something that you

00:03:16,000 --> 00:03:20,879
can actually write code for

00:03:18,080 --> 00:03:21,760
and then you write the code and you test

00:03:20,879 --> 00:03:24,080
and

00:03:21,760 --> 00:03:26,159
and and integrate it bottom up you build

00:03:24,080 --> 00:03:28,480
design and test and or you you build it

00:03:26,159 --> 00:03:30,480
test it and integrate it bottom up the

00:03:28,480 --> 00:03:33,599
problem is is that in the large

00:03:30,480 --> 00:03:36,959
this creates an exponentially large

00:03:33,599 --> 00:03:39,360
number of leaf nodes and that is a

00:03:36,959 --> 00:03:42,640
problem for any large organization

00:03:39,360 --> 00:03:44,640
and it obviously you know if you

00:03:42,640 --> 00:03:46,879
didn't have to have an excellently

00:03:44,640 --> 00:03:48,799
exponentially large number of leaf nodes

00:03:46,879 --> 00:03:50,080
that would be a huge benefit just from a

00:03:48,799 --> 00:03:52,400
maintenance point of view

00:03:50,080 --> 00:03:54,159
never mind a development point of view

00:03:52,400 --> 00:03:56,319
so

00:03:54,159 --> 00:03:59,519
application software is typically

00:03:56,319 --> 00:04:01,599
top-down collaborative and malleable

00:03:59,519 --> 00:04:03,760
library software is typically bottom-up

00:04:01,599 --> 00:04:06,159
reusable and stable

00:04:03,760 --> 00:04:07,519
they're two very different branches of

00:04:06,159 --> 00:04:09,599
of development

00:04:07,519 --> 00:04:11,360
and in fact the kind of people that do

00:04:09,599 --> 00:04:12,640
top-down design and the kind of people

00:04:11,360 --> 00:04:15,760
that do bottom-up

00:04:12,640 --> 00:04:17,359
design are two relatively different

00:04:15,760 --> 00:04:19,519
kinds of programmers

00:04:17,359 --> 00:04:20,639
and what they do what they're attempting

00:04:19,519 --> 00:04:23,600
to do

00:04:20,639 --> 00:04:24,960
is really a a different set of goals the

00:04:23,600 --> 00:04:27,040
application developers solving a

00:04:24,960 --> 00:04:30,880
business problem the library developer

00:04:27,040 --> 00:04:32,479
is solving a variety of problems

00:04:30,880 --> 00:04:33,919
none of which is specific to any

00:04:32,479 --> 00:04:37,919
particular business need

00:04:33,919 --> 00:04:39,360
all of them are add business value

00:04:37,919 --> 00:04:42,240
so again these are very different

00:04:39,360 --> 00:04:44,479
disciplines take a complex application

00:04:42,240 --> 00:04:45,280
it's typical that it'll have a complex

00:04:44,479 --> 00:04:47,520
boundary

00:04:45,280 --> 00:04:49,600
that's moving all the time so to try to

00:04:47,520 --> 00:04:51,919
specify a complex application is not

00:04:49,600 --> 00:04:53,840
only difficult it's a moving target

00:04:51,919 --> 00:04:55,040
the wonderful thing is that within the

00:04:53,840 --> 00:04:57,600
application

00:04:55,040 --> 00:04:59,199
there are many regular pieces that recur

00:04:57,600 --> 00:05:01,680
and will recur in the future

00:04:59,199 --> 00:05:03,520
if you can identify those regular pieces

00:05:01,680 --> 00:05:05,840
such as a standard component

00:05:03,520 --> 00:05:07,199
then you can take advantage of it now

00:05:05,840 --> 00:05:08,720
and in the future

00:05:07,199 --> 00:05:10,720
there are many standard components in

00:05:08,720 --> 00:05:12,720
typical applications there are also

00:05:10,720 --> 00:05:15,520
bigger components

00:05:12,720 --> 00:05:17,919
that that that might recur and you can

00:05:15,520 --> 00:05:19,680
see here as they get larger and larger

00:05:17,919 --> 00:05:21,600
something like this might be a very

00:05:19,680 --> 00:05:23,199
large reusable component perhaps it's an

00:05:21,600 --> 00:05:26,080
entire database system

00:05:23,199 --> 00:05:27,120
or perhaps it's an entire uh ticker

00:05:26,080 --> 00:05:29,360
plant or

00:05:27,120 --> 00:05:30,479
or some large piece that's used widely

00:05:29,360 --> 00:05:32,960
throughout the enterprise

00:05:30,479 --> 00:05:34,400
it's a reusable piece it's all it's not

00:05:32,960 --> 00:05:35,120
what you would typically think of as

00:05:34,400 --> 00:05:37,280
reuse

00:05:35,120 --> 00:05:39,360
you might even think of it as use but

00:05:37,280 --> 00:05:41,600
the point is it appears

00:05:39,360 --> 00:05:44,160
referenced from many different

00:05:41,600 --> 00:05:47,280
applications and so in that sense

00:05:44,160 --> 00:05:48,880
it is reused used or reused it appears

00:05:47,280 --> 00:05:50,960
in many applications

00:05:48,880 --> 00:05:52,000
so if you're repeating code in many

00:05:50,960 --> 00:05:53,440
applications

00:05:52,000 --> 00:05:56,560
you get a picture that looks kind of

00:05:53,440 --> 00:05:58,880
like that if you're capturing that

00:05:56,560 --> 00:06:00,160
bulk of the code in library software

00:05:58,880 --> 00:06:02,240
then each application

00:06:00,160 --> 00:06:03,919
has less code to write and that means

00:06:02,240 --> 00:06:07,520
that we're better off for it

00:06:03,919 --> 00:06:08,080
this is a good idea so if you think of

00:06:07,520 --> 00:06:10,479
something

00:06:08,080 --> 00:06:12,319
simple like a circle circle might be

00:06:10,479 --> 00:06:13,919
representative of some piece of software

00:06:12,319 --> 00:06:15,680
that we want to build

00:06:13,919 --> 00:06:17,840
if we divide that software in sort of

00:06:15,680 --> 00:06:18,960
arbitrary ways we get something that i

00:06:17,840 --> 00:06:21,039
like to think of

00:06:18,960 --> 00:06:23,520
the cracked plate metaphor where the

00:06:21,039 --> 00:06:24,880
individual pieces aren't useful in any

00:06:23,520 --> 00:06:26,880
way other than where they were

00:06:24,880 --> 00:06:28,479
originally created

00:06:26,880 --> 00:06:30,240
another way to think about this is

00:06:28,479 --> 00:06:31,280
imagine if your mother says go

00:06:30,240 --> 00:06:32,800
downstairs

00:06:31,280 --> 00:06:34,720
brush your teeth and make toast and you

00:06:32,800 --> 00:06:37,600
say aha i'm going to build

00:06:34,720 --> 00:06:38,720
a toaster toothbrush for that purpose

00:06:37,600 --> 00:06:41,919
this is not a factor

00:06:38,720 --> 00:06:41,919
uh piece of software

00:06:42,000 --> 00:06:45,280
not a factory piece of software this is

00:06:43,600 --> 00:06:48,880
actually just a big uh

00:06:45,280 --> 00:06:50,080
pile of stuff that that that somebody

00:06:48,880 --> 00:06:52,080
glued together

00:06:50,080 --> 00:06:53,440
and and serves one function so these are

00:06:52,080 --> 00:06:56,479
two different metaphors

00:06:53,440 --> 00:06:57,759
for what we're talking about now imagine

00:06:56,479 --> 00:06:58,319
we have something that's a little bit

00:06:57,759 --> 00:06:59,919
better

00:06:58,319 --> 00:07:02,160
we'll call this collaborative software

00:06:59,919 --> 00:07:05,199
the dependencies across

00:07:02,160 --> 00:07:06,720
collaborative pieces in a system are not

00:07:05,199 --> 00:07:09,680
as tightly coupled as they are

00:07:06,720 --> 00:07:10,000
in a brittle in the brittle broken plate

00:07:09,680 --> 00:07:12,400
uh

00:07:10,000 --> 00:07:13,120
metaphor but they are clearly aware of

00:07:12,400 --> 00:07:15,759
each other

00:07:13,120 --> 00:07:17,039
and so those pieces are not invented

00:07:15,759 --> 00:07:19,440
independently

00:07:17,039 --> 00:07:21,440
another analogy would be a toaster with

00:07:19,440 --> 00:07:23,599
a hook and a toothbrush with a hole

00:07:21,440 --> 00:07:25,599
and you can imagine yeah that makes

00:07:23,599 --> 00:07:27,360
sense in some context but who would buy

00:07:25,599 --> 00:07:29,120
a toothbrush a toaster with a

00:07:27,360 --> 00:07:30,639
hook or a toothbrush with a hole

00:07:29,120 --> 00:07:31,280
separately that doesn't really make

00:07:30,639 --> 00:07:33,840
sense

00:07:31,280 --> 00:07:35,360
so these are not really reusable pieces

00:07:33,840 --> 00:07:38,560
these are collaborative

00:07:35,360 --> 00:07:40,880
pieces so brittle pieces are usable

00:07:38,560 --> 00:07:42,720
within one version of one application

00:07:40,880 --> 00:07:44,800
collaborative pieces are usable across

00:07:42,720 --> 00:07:46,639
many versions of the same application

00:07:44,800 --> 00:07:48,800
because from one version to the next

00:07:46,639 --> 00:07:49,680
the basic design doesn't change that

00:07:48,800 --> 00:07:51,440
much

00:07:49,680 --> 00:07:54,240
but what we're really looking for is to

00:07:51,440 --> 00:07:56,000
have many versions of many applications

00:07:54,240 --> 00:07:58,000
share the same software

00:07:56,000 --> 00:07:59,520
that's the kind of reusable software

00:07:58,000 --> 00:08:02,400
we'd like to have

00:07:59,520 --> 00:08:04,560
so consider that a piece of reusable

00:08:02,400 --> 00:08:06,240
software is easy to explain

00:08:04,560 --> 00:08:07,919
and it can be built up in terms of other

00:08:06,240 --> 00:08:09,919
reusable pieces of software that are

00:08:07,919 --> 00:08:13,280
themselves easy to explain

00:08:09,919 --> 00:08:14,400
so for example a gray square a black

00:08:13,280 --> 00:08:17,520
track

00:08:14,400 --> 00:08:20,639
a triangle a a light gray rectangle

00:08:17,520 --> 00:08:22,479
or a clear semi-circle

00:08:20,639 --> 00:08:23,759
are things that are fairly easy to

00:08:22,479 --> 00:08:26,560
explain to somebody

00:08:23,759 --> 00:08:28,160
in words and what we'd like to say is

00:08:26,560 --> 00:08:30,879
that they have a

00:08:28,160 --> 00:08:32,080
small surface to volume ratio which

00:08:30,879 --> 00:08:34,320
means that the

00:08:32,080 --> 00:08:35,360
the interface is small and easy to

00:08:34,320 --> 00:08:37,519
understand

00:08:35,360 --> 00:08:38,719
whereas what is done for you is

00:08:37,519 --> 00:08:41,599
proportionally large

00:08:38,719 --> 00:08:42,959
and useful the most reused things have

00:08:41,599 --> 00:08:45,600
that property

00:08:42,959 --> 00:08:47,120
so if we had a toaster and a toothbrush

00:08:45,600 --> 00:08:47,920
that were themselves independently

00:08:47,120 --> 00:08:49,360
useful

00:08:47,920 --> 00:08:51,760
and then we had something that could

00:08:49,360 --> 00:08:53,920
connect them such as an adapter

00:08:51,760 --> 00:08:55,839
then we'd get something like the glue

00:08:53,920 --> 00:08:57,839
that can take all the software

00:08:55,839 --> 00:09:00,000
uh the the reusable pieces put them

00:08:57,839 --> 00:09:03,279
together into another reusable piece

00:09:00,000 --> 00:09:05,680
we also get the uh

00:09:03,279 --> 00:09:07,600
toaster and the toothbrush and the

00:09:05,680 --> 00:09:11,200
adapter and the glue

00:09:07,600 --> 00:09:11,200
independently so this is a good thing

00:09:12,560 --> 00:09:16,560
let's imagine we have a big monolithic

00:09:14,640 --> 00:09:17,600
block of software this is typical of

00:09:16,560 --> 00:09:20,959
some large

00:09:17,600 --> 00:09:22,640
uh behemoths that one might have if we

00:09:20,959 --> 00:09:23,920
didn't have any sort of strategy for

00:09:22,640 --> 00:09:26,959
developing large

00:09:23,920 --> 00:09:29,279
uh legacy software now

00:09:26,959 --> 00:09:31,440
if you think about what we could do

00:09:29,279 --> 00:09:34,320
there's a there's a fellow named dykstra

00:09:31,440 --> 00:09:36,240
and he invented this notion of physical

00:09:34,320 --> 00:09:39,519
hierarchy within systems

00:09:36,240 --> 00:09:41,440
small pieces that are built and tested

00:09:39,519 --> 00:09:43,519
in place and stacked like bricks

00:09:41,440 --> 00:09:45,200
and even though their their interfaces

00:09:43,519 --> 00:09:47,519
might not be all that pretty

00:09:45,200 --> 00:09:50,320
um when they're stacked and tested this

00:09:47,519 --> 00:09:52,720
way they can be very reliable he claimed

00:09:50,320 --> 00:09:54,160
uh along the lines of even mathematical

00:09:52,720 --> 00:09:54,959
proofs many mathematicians would

00:09:54,160 --> 00:09:56,959
disagree

00:09:54,959 --> 00:09:58,720
but as we all know mathematicians prove

00:09:56,959 --> 00:10:00,959
things and they're human

00:09:58,720 --> 00:10:02,640
and humans make mistakes and having a

00:10:00,959 --> 00:10:03,440
program go through and mechanically

00:10:02,640 --> 00:10:06,240
verify

00:10:03,440 --> 00:10:08,079
what you wanted to prove is a very very

00:10:06,240 --> 00:10:09,440
valuable tool this can be done either at

00:10:08,079 --> 00:10:12,160
runtime through unit tests

00:10:09,440 --> 00:10:14,320
or through static analysis or both

00:10:12,160 --> 00:10:16,240
there's all kinds of ways to help human

00:10:14,320 --> 00:10:17,120
humans do a better job than humans do

00:10:16,240 --> 00:10:19,040
naturally

00:10:17,120 --> 00:10:20,800
there's another fellow named parnus and

00:10:19,040 --> 00:10:22,480
he said that modular code was what was

00:10:20,800 --> 00:10:23,200
important regardless of its physical

00:10:22,480 --> 00:10:24,560
structure

00:10:23,200 --> 00:10:26,720
and so if you make a change to the

00:10:24,560 --> 00:10:28,880
internals of a module the

00:10:26,720 --> 00:10:30,959
surrounding modules are not affected

00:10:28,880 --> 00:10:32,000
both of these ideas are very important

00:10:30,959 --> 00:10:33,600
to what we do

00:10:32,000 --> 00:10:35,519
and if you add to that thorough

00:10:33,600 --> 00:10:36,880
interface documentation within the

00:10:35,519 --> 00:10:39,440
boundaries of a system

00:10:36,880 --> 00:10:40,160
you pretty much get what we call a

00:10:39,440 --> 00:10:43,440
component

00:10:40,160 --> 00:10:45,519
in our methodology so if we take a big

00:10:43,440 --> 00:10:46,640
monolithic blob of software and break it

00:10:45,519 --> 00:10:49,360
down into course

00:10:46,640 --> 00:10:50,240
levels well that's better but that's not

00:10:49,360 --> 00:10:52,880
good enough

00:10:50,240 --> 00:10:54,160
if we make them finer levels still if

00:10:52,880 --> 00:10:56,959
they span each other

00:10:54,160 --> 00:10:58,880
we still don't have the kind of

00:10:56,959 --> 00:11:00,079
independent reusability that we want to

00:10:58,880 --> 00:11:03,760
have from any particular

00:11:00,079 --> 00:11:05,600
node in the physical hierarchy

00:11:03,760 --> 00:11:07,040
if we were to do what we call silos

00:11:05,600 --> 00:11:08,320
there's a lot of advantage to that

00:11:07,040 --> 00:11:09,200
because the people in the different

00:11:08,320 --> 00:11:11,200
silos

00:11:09,200 --> 00:11:13,120
can work independently and they're not

00:11:11,200 --> 00:11:14,880
encumbered by what other people do

00:11:13,120 --> 00:11:17,600
the problem with this is that the bottom

00:11:14,880 --> 00:11:20,320
of each silo repeats a lot of the code

00:11:17,600 --> 00:11:21,040
that we would naturally want to use so

00:11:20,320 --> 00:11:23,760
the

00:11:21,040 --> 00:11:24,800
solution here is something that looks

00:11:23,760 --> 00:11:28,640
like this

00:11:24,800 --> 00:11:30,480
finely graduated granular software

00:11:28,640 --> 00:11:32,320
and at each level in the physical

00:11:30,480 --> 00:11:33,279
hierarchy we drop down a level of

00:11:32,320 --> 00:11:35,600
abstraction

00:11:33,279 --> 00:11:37,760
but any single piece in that physical

00:11:35,600 --> 00:11:40,399
hierarchy is stable and therefore

00:11:37,760 --> 00:11:42,079
available for independent reuse either

00:11:40,399 --> 00:11:45,440
by other software components

00:11:42,079 --> 00:11:46,160
or by application components i cannot

00:11:45,440 --> 00:11:49,200
emphasize

00:11:46,160 --> 00:11:52,399
enough how important this is

00:11:49,200 --> 00:11:54,320
this slide number 19 is what we are

00:11:52,399 --> 00:11:56,480
aiming for

00:11:54,320 --> 00:11:58,160
all right so in other words we're taking

00:11:56,480 --> 00:11:59,760
a piece of software and breaking it down

00:11:58,160 --> 00:12:02,880
into sub components and sub sub

00:11:59,760 --> 00:12:05,040
components and so on and so forth

00:12:02,880 --> 00:12:08,000
if you imagine the toaster toothbrush

00:12:05,040 --> 00:12:10,959
toaster toothbrush has a toast

00:12:08,000 --> 00:12:12,720
as a toaster a toothbrush and an adapter

00:12:10,959 --> 00:12:14,000
and each one of those is broken down

00:12:12,720 --> 00:12:15,839
into its subparts

00:12:14,000 --> 00:12:17,760
you can see a case in a chassis a handle

00:12:15,839 --> 00:12:19,680
and bristles an arm and a joint

00:12:17,760 --> 00:12:21,120
and so on and so forth until you get

00:12:19,680 --> 00:12:21,760
down to something that can be

00:12:21,120 --> 00:12:24,480
implemented

00:12:21,760 --> 00:12:25,920
independently some sort of atomic piece

00:12:24,480 --> 00:12:27,120
that doesn't make sense to further

00:12:25,920 --> 00:12:29,040
decompose

00:12:27,120 --> 00:12:31,360
and you'd be surprised how far that goes

00:12:29,040 --> 00:12:34,880
down and by the way those things

00:12:31,360 --> 00:12:36,399
do reconverge at the very bottom

00:12:34,880 --> 00:12:38,959
you'll find there aren't that many

00:12:36,399 --> 00:12:40,880
pieces that you need at the very bottom

00:12:38,959 --> 00:12:41,279
there are a few very fundamental pieces

00:12:40,880 --> 00:12:43,760
that are

00:12:41,279 --> 00:12:45,440
used very very many times throughout

00:12:43,760 --> 00:12:47,760
your software system

00:12:45,440 --> 00:12:48,800
so now let's take a look of exploiting

00:12:47,760 --> 00:12:52,000
what we'll call

00:12:48,800 --> 00:12:55,760
finely factored library software so

00:12:52,000 --> 00:12:57,680
classical reuse we would create a

00:12:55,760 --> 00:12:58,959
a flashlight and we create a for a

00:12:57,680 --> 00:13:00,639
toaster flashlight and

00:12:58,959 --> 00:13:02,880
yeah the flashlight would would have to

00:13:00,639 --> 00:13:03,600
have sub implementations of lens and

00:13:02,880 --> 00:13:05,600
stock

00:13:03,600 --> 00:13:07,600
but what we're doing is we're reusing

00:13:05,600 --> 00:13:08,560
the toaster and the adapter in their

00:13:07,600 --> 00:13:10,079
entirety

00:13:08,560 --> 00:13:12,000
and then we're creating another piece to

00:13:10,079 --> 00:13:14,560
create the toaster flashlight

00:13:12,000 --> 00:13:16,160
that is what reuses now let's look at

00:13:14,560 --> 00:13:18,560
the difference between that

00:13:16,160 --> 00:13:20,079
which is just reusing two other pieces

00:13:18,560 --> 00:13:23,360
and adding a third

00:13:20,079 --> 00:13:24,959
and hierarchical reuse well what we're

00:13:23,360 --> 00:13:25,920
going to do now is we're going to add a

00:13:24,959 --> 00:13:29,120
scrub brush

00:13:25,920 --> 00:13:30,880
but now the scrub brush itself is using

00:13:29,120 --> 00:13:32,880
the sub pieces that were already

00:13:30,880 --> 00:13:34,480
available within the system

00:13:32,880 --> 00:13:36,160
so this is the fundamental difference

00:13:34,480 --> 00:13:37,519
between just plain old reuse and

00:13:36,160 --> 00:13:39,760
hierarchical reuse

00:13:37,519 --> 00:13:40,560
the scrub brush itself is using a

00:13:39,760 --> 00:13:44,079
subpart

00:13:40,560 --> 00:13:46,000
of something that was already there

00:13:44,079 --> 00:13:48,480
imagine we have a function if you have a

00:13:46,000 --> 00:13:50,160
function of six elements

00:13:48,480 --> 00:13:52,240
most likely there'll be seven or eight

00:13:50,160 --> 00:13:53,440
someday if that function happened to be

00:13:52,240 --> 00:13:55,120
implemented in terms of

00:13:53,440 --> 00:13:57,279
other things that were individual

00:13:55,120 --> 00:13:59,680
functions then when the time comes to

00:13:57,279 --> 00:14:01,760
extend this function without changing it

00:13:59,680 --> 00:14:03,279
we can add those other sub functions and

00:14:01,760 --> 00:14:04,320
then we can reuse those pieces

00:14:03,279 --> 00:14:06,320
independently

00:14:04,320 --> 00:14:07,920
again we have an example of hierarchical

00:14:06,320 --> 00:14:10,399
reuse

00:14:07,920 --> 00:14:11,760
imagine we have a proxy and a server and

00:14:10,399 --> 00:14:14,959
a client

00:14:11,760 --> 00:14:18,079
what if we want to upgrade our transport

00:14:14,959 --> 00:14:19,839
how are we going to do that um

00:14:18,079 --> 00:14:22,720
suppose we want to go from one version

00:14:19,839 --> 00:14:24,320
of http to another what would we do

00:14:22,720 --> 00:14:26,800
we'll see an answer to this at the very

00:14:24,320 --> 00:14:28,480
end of the talk

00:14:26,800 --> 00:14:30,079
let's look at some sort of software

00:14:28,480 --> 00:14:33,040
that's stable and we want to extend

00:14:30,079 --> 00:14:34,000
it one way to do that is to add a pr a

00:14:33,040 --> 00:14:36,160
member function

00:14:34,000 --> 00:14:37,760
to the container or whatever but as we

00:14:36,160 --> 00:14:39,279
know that violates a very important

00:14:37,760 --> 00:14:39,920
property of stability we don't want to

00:14:39,279 --> 00:14:41,839
go in

00:14:39,920 --> 00:14:43,120
and muck with things that are stable so

00:14:41,839 --> 00:14:45,279
what we do is we create

00:14:43,120 --> 00:14:47,519
a free function typically this would be

00:14:45,279 --> 00:14:48,800
in a as a static method of a struct but

00:14:47,519 --> 00:14:51,120
that's another story

00:14:48,800 --> 00:14:52,160
and then we would use iterators to

00:14:51,120 --> 00:14:54,800
iterate over

00:14:52,160 --> 00:14:56,399
the pieces of the container and by doing

00:14:54,800 --> 00:14:59,040
that we don't have to add

00:14:56,399 --> 00:15:00,639
a private method to the to the container

00:14:59,040 --> 00:15:02,560
we can simply extend it

00:15:00,639 --> 00:15:04,399
without having to change it this is a

00:15:02,560 --> 00:15:05,199
principle called known as the open close

00:15:04,399 --> 00:15:06,720
principle

00:15:05,199 --> 00:15:09,040
another example is we want to do some

00:15:06,720 --> 00:15:11,120
sort of fancy print instead of writing a

00:15:09,040 --> 00:15:13,920
new print method for the container

00:15:11,120 --> 00:15:15,440
we create some independent function that

00:15:13,920 --> 00:15:16,240
the client could do in their own code

00:15:15,440 --> 00:15:19,360
for example

00:15:16,240 --> 00:15:20,000
then again we use iterators to extend

00:15:19,360 --> 00:15:22,639
without

00:15:20,000 --> 00:15:24,320
modifying the library software this is a

00:15:22,639 --> 00:15:26,160
very important principle of what we need

00:15:24,320 --> 00:15:28,480
to do and how we design

00:15:26,160 --> 00:15:30,079
our software we want it to be extended

00:15:28,480 --> 00:15:32,079
without being modified

00:15:30,079 --> 00:15:35,120
open closed open to extension close to

00:15:32,079 --> 00:15:36,880
source code modification

00:15:35,120 --> 00:15:38,320
now imagine we have a system like this

00:15:36,880 --> 00:15:40,240
where we have a postscript printer and

00:15:38,320 --> 00:15:42,160
we have a postscript output device

00:15:40,240 --> 00:15:44,800
driver and then we have some out

00:15:42,160 --> 00:15:45,279
account report writer so this is typical

00:15:44,800 --> 00:15:47,759
these

00:15:45,279 --> 00:15:49,600
physical arrows are not inheritance

00:15:47,759 --> 00:15:51,600
their physical dependency

00:15:49,600 --> 00:15:52,959
and i emphasize the physicalness by the

00:15:51,600 --> 00:15:55,680
three-dimensional thing that is an

00:15:52,959 --> 00:15:56,399
actual physical device physical design

00:15:55,680 --> 00:15:58,160
is an important

00:15:56,399 --> 00:15:59,440
part of what we do it's complement to

00:15:58,160 --> 00:16:01,600
logical design

00:15:59,440 --> 00:16:02,880
and we didn't talk about it a lot in

00:16:01,600 --> 00:16:04,720
this talk but

00:16:02,880 --> 00:16:06,560
uh please suffice it to say that it's

00:16:04,720 --> 00:16:08,320
critically important

00:16:06,560 --> 00:16:10,000
this is the depends on relationship it's

00:16:08,320 --> 00:16:13,759
a physical dependency

00:16:10,000 --> 00:16:13,759
this is also a physical dependency

00:16:13,920 --> 00:16:19,199
here we have a diagram that shows how

00:16:16,079 --> 00:16:21,360
each of these pieces are built out of

00:16:19,199 --> 00:16:23,360
fine-grained modular library software in

00:16:21,360 --> 00:16:25,920
other words we're hierarchically reusing

00:16:23,360 --> 00:16:27,680
this other software this is a well

00:16:25,920 --> 00:16:29,920
factored system

00:16:27,680 --> 00:16:31,920
now imagine we want to extend to

00:16:29,920 --> 00:16:34,160
different kinds of printers

00:16:31,920 --> 00:16:36,000
one way that's typically done and is of

00:16:34,160 --> 00:16:38,399
course not a good idea

00:16:36,000 --> 00:16:40,560
is cut and paste reuse we do not want to

00:16:38,399 --> 00:16:42,720
cut and paste

00:16:40,560 --> 00:16:43,600
we would much prefer to reuse things in

00:16:42,720 --> 00:16:46,320
place

00:16:43,600 --> 00:16:48,720
so instead of doing that we might think

00:16:46,320 --> 00:16:50,560
to create a single module that unites

00:16:48,720 --> 00:16:53,040
all of the three different devices

00:16:50,560 --> 00:16:54,399
and call it a device manager now look at

00:16:53,040 --> 00:16:59,680
this for a second

00:16:54,399 --> 00:17:01,600
there's definitely something that is uh

00:16:59,680 --> 00:17:02,800
wrong with this and that is we're taking

00:17:01,600 --> 00:17:05,760
something that might not

00:17:02,800 --> 00:17:07,439
ever be part of a single executable and

00:17:05,760 --> 00:17:08,720
requiring a dependency on three

00:17:07,439 --> 00:17:11,600
different things

00:17:08,720 --> 00:17:12,559
uh this is not something that i'm

00:17:11,600 --> 00:17:15,679
excited about

00:17:12,559 --> 00:17:16,079
uh uh even considering because it's

00:17:15,679 --> 00:17:17,600
putting

00:17:16,079 --> 00:17:19,439
it's putting gratuitous dependencies

00:17:17,600 --> 00:17:21,199
where none are needed

00:17:19,439 --> 00:17:23,199
one of the things we strive for is to

00:17:21,199 --> 00:17:25,679
make sure that we don't

00:17:23,199 --> 00:17:26,959
create dependencies on things that we

00:17:25,679 --> 00:17:28,640
won't need

00:17:26,959 --> 00:17:30,960
so this is another design principle

00:17:28,640 --> 00:17:33,760
that's just so natural to me

00:17:30,960 --> 00:17:35,440
that even to even mention it of course i

00:17:33,760 --> 00:17:37,679
i have trouble even thinking

00:17:35,440 --> 00:17:39,760
but in any event we're not going to do

00:17:37,679 --> 00:17:41,679
this what we're going to do instead is

00:17:39,760 --> 00:17:44,320
something that was first talked about

00:17:41,679 --> 00:17:47,360
dependency inversion by uncle bob martin

00:17:44,320 --> 00:17:48,799
in a book that predates my 1996 book

00:17:47,360 --> 00:17:50,720
only one that talks about this

00:17:48,799 --> 00:17:52,880
dependency inversion that i'm aware of

00:17:50,720 --> 00:17:54,240
or physical design in general uh in

00:17:52,880 --> 00:17:55,919
terms of c plus

00:17:54,240 --> 00:17:57,679
and so we now have an output device

00:17:55,919 --> 00:17:59,679
which is an abstract interface

00:17:57,679 --> 00:18:00,960
and then we have implementations and the

00:17:59,679 --> 00:18:04,400
implementations are is

00:18:00,960 --> 00:18:04,960
a and no object oriented programming is

00:18:04,400 --> 00:18:07,679
not the

00:18:04,960 --> 00:18:09,200
evil that might be claimed to be once

00:18:07,679 --> 00:18:10,000
upon a time it was the greatest thing in

00:18:09,200 --> 00:18:11,520
the world

00:18:10,000 --> 00:18:12,880
then it was decided it was the worst

00:18:11,520 --> 00:18:14,320
thing in the world well it's neither the

00:18:12,880 --> 00:18:15,200
greatest nor the worst it's part of our

00:18:14,320 --> 00:18:17,440
toolbox

00:18:15,200 --> 00:18:19,440
for large-scale design it's essential

00:18:17,440 --> 00:18:21,840
and then we have clients that make use

00:18:19,440 --> 00:18:23,039
of the output device in their interface

00:18:21,840 --> 00:18:24,240
that little white bubble we'll talk

00:18:23,039 --> 00:18:26,720
about that in a moment

00:18:24,240 --> 00:18:28,320
is users in the interface so isa and

00:18:26,720 --> 00:18:29,360
users in the interface are logical

00:18:28,320 --> 00:18:31,679
relationships that

00:18:29,360 --> 00:18:33,120
imply physical dependencies this is

00:18:31,679 --> 00:18:33,679
something that was discussed in my first

00:18:33,120 --> 00:18:35,520
book

00:18:33,679 --> 00:18:37,520
and is certainly discussed in the one

00:18:35,520 --> 00:18:39,120
we're talking about now

00:18:37,520 --> 00:18:40,799
these are depends on relationships and

00:18:39,120 --> 00:18:43,120
they are independent of the logical

00:18:40,799 --> 00:18:46,880
nature in which the dependency occurs

00:18:43,120 --> 00:18:49,120
this is a well factored software system

00:18:46,880 --> 00:18:50,320
one thing we want to say is if you have

00:18:49,120 --> 00:18:52,400
one client

00:18:50,320 --> 00:18:54,240
that's dictating what software does then

00:18:52,400 --> 00:18:55,600
that software can change because no one

00:18:54,240 --> 00:18:57,600
else is affected

00:18:55,600 --> 00:18:59,200
it's not unlike the notion of uh

00:18:57,600 --> 00:19:01,679
something that's movable if you can

00:18:59,200 --> 00:19:04,000
change it if only one person cares

00:19:01,679 --> 00:19:06,240
then that's fine but if multiple people

00:19:04,000 --> 00:19:08,320
are referencing the same software

00:19:06,240 --> 00:19:10,160
and you try to change it other people

00:19:08,320 --> 00:19:12,799
could be adversely affected

00:19:10,160 --> 00:19:13,679
so by definition software that is

00:19:12,799 --> 00:19:16,480
reusable

00:19:13,679 --> 00:19:17,520
is dependent on by many clients is

00:19:16,480 --> 00:19:19,200
stable

00:19:17,520 --> 00:19:22,080
and in fact one of the measures of

00:19:19,200 --> 00:19:23,760
stability is how many clients use it

00:19:22,080 --> 00:19:25,360
too many clients use it and you change

00:19:23,760 --> 00:19:26,400
it people will come after you with

00:19:25,360 --> 00:19:28,960
pitchforks

00:19:26,400 --> 00:19:30,720
so don't change it this scenario where

00:19:28,960 --> 00:19:32,720
you have multiple clients

00:19:30,720 --> 00:19:34,000
telling you what to do can lead to

00:19:32,720 --> 00:19:36,640
something that's usable

00:19:34,000 --> 00:19:38,320
effectively by no one and we call it the

00:19:36,640 --> 00:19:40,320
flattened green toaster toothbrush with

00:19:38,320 --> 00:19:41,600
flag

00:19:40,320 --> 00:19:43,520
by the way i was mentioned i'm going to

00:19:41,600 --> 00:19:44,960
stop for questions and uh at an

00:19:43,520 --> 00:19:47,200
appropriate point so

00:19:44,960 --> 00:19:48,000
unless there's something that's very

00:19:47,200 --> 00:19:49,440
important

00:19:48,000 --> 00:19:50,640
uh i'm just going to keep going then

00:19:49,440 --> 00:19:53,760
i'll go back and see if i can answer

00:19:50,640 --> 00:19:55,760
some questions

00:19:53,760 --> 00:19:57,440
so what is physical design these are

00:19:55,760 --> 00:19:58,880
some definitions

00:19:57,440 --> 00:20:01,039
the arrangement of source code within

00:19:58,880 --> 00:20:03,919
files and files within libraries

00:20:01,039 --> 00:20:05,760
there's another one two deliberately

00:20:03,919 --> 00:20:07,440
partition source code among files and

00:20:05,760 --> 00:20:08,159
files among libraries in a way that

00:20:07,440 --> 00:20:11,120
makes good

00:20:08,159 --> 00:20:12,480
sense good engineering sense so one of

00:20:11,120 --> 00:20:14,240
the things that we

00:20:12,480 --> 00:20:16,559
take as a given is that a component

00:20:14,240 --> 00:20:20,880
consists of a header file

00:20:16,559 --> 00:20:23,280
and almost always one like name.cpp file

00:20:20,880 --> 00:20:25,360
i say almost always because in very rare

00:20:23,280 --> 00:20:27,600
situations in embedded code you might

00:20:25,360 --> 00:20:29,200
have physical properties but we won't go

00:20:27,600 --> 00:20:29,760
into that so for the purposes of this

00:20:29,200 --> 00:20:31,919
talk

00:20:29,760 --> 00:20:33,520
a component is a dot h and a dot cpp

00:20:31,919 --> 00:20:35,840
file this is the header

00:20:33,520 --> 00:20:36,880
this is the implementation the header is

00:20:35,840 --> 00:20:37,919
the physical interface the

00:20:36,880 --> 00:20:40,720
implementation is the

00:20:37,919 --> 00:20:41,440
is the physical implementation but as we

00:20:40,720 --> 00:20:43,039
all know

00:20:41,440 --> 00:20:44,480
a lot of the logical implementation

00:20:43,039 --> 00:20:45,919
these days with templates and inline

00:20:44,480 --> 00:20:48,240
functions and blah blah blah

00:20:45,919 --> 00:20:49,520
reside in the header we also have

00:20:48,240 --> 00:20:51,280
something that is not part of the

00:20:49,520 --> 00:20:52,559
component proper but is part of every

00:20:51,280 --> 00:20:54,400
component we write

00:20:52,559 --> 00:20:55,760
and that is a component level test

00:20:54,400 --> 00:20:57,679
driver this is something that's

00:20:55,760 --> 00:20:59,200
discussed in volume three of this three

00:20:57,679 --> 00:21:01,919
volume set

00:20:59,200 --> 00:21:04,240
and it's not part of this talk now we'll

00:21:01,919 --> 00:21:06,400
take a look at how we lay out

00:21:04,240 --> 00:21:07,679
a component in source code and i'm

00:21:06,400 --> 00:21:09,200
putting this here i don't want you

00:21:07,679 --> 00:21:10,799
necessarily to read it i'm just going

00:21:09,200 --> 00:21:12,799
over the big categories

00:21:10,799 --> 00:21:14,799
please don't feel like it's essential to

00:21:12,799 --> 00:21:17,280
see this it's more of a picture

00:21:14,799 --> 00:21:18,880
we start out with the name of the file

00:21:17,280 --> 00:21:19,600
at the top so we know what we're looking

00:21:18,880 --> 00:21:21,039
at

00:21:19,600 --> 00:21:23,120
we're not going to talk about packages

00:21:21,039 --> 00:21:25,840
for now that's a higher level grouping

00:21:23,120 --> 00:21:27,679
and our definition of package and the

00:21:25,840 --> 00:21:28,960
standards definition of package are not

00:21:27,679 --> 00:21:30,720
the same

00:21:28,960 --> 00:21:32,000
they're different ideas they are

00:21:30,720 --> 00:21:33,679
definitely related

00:21:32,000 --> 00:21:35,200
but a package in the standard is

00:21:33,679 --> 00:21:38,159
probably more closely aligned with what

00:21:35,200 --> 00:21:41,200
we call a component

00:21:38,159 --> 00:21:43,120
so we have helper stuff like a

00:21:41,200 --> 00:21:45,039
stack in this case we have a stack const

00:21:43,120 --> 00:21:46,880
iterator we have free operators that

00:21:45,039 --> 00:21:50,400
operate on the stack const iterator

00:21:46,880 --> 00:21:51,840
we have the flagship uh class which is

00:21:50,400 --> 00:21:54,320
the stack itself

00:21:51,840 --> 00:21:56,159
the data members the public interface

00:21:54,320 --> 00:21:57,840
that starts out with public types

00:21:56,159 --> 00:22:00,240
then creators which are the constructors

00:21:57,840 --> 00:22:02,000
and destructors the manipulators which

00:22:00,240 --> 00:22:03,280
are the functions that mutate the state

00:22:02,000 --> 00:22:05,360
of the object and they simply are

00:22:03,280 --> 00:22:07,200
defined by not having a const

00:22:05,360 --> 00:22:09,679
and the accessors are defined by having

00:22:07,200 --> 00:22:12,240
a const if this looks like a weird way

00:22:09,679 --> 00:22:15,840
to represent things to you

00:22:12,240 --> 00:22:18,400
i cannot tell you how valuable it is

00:22:15,840 --> 00:22:20,240
to have this kind of partition because

00:22:18,400 --> 00:22:22,000
every single

00:22:20,240 --> 00:22:23,280
object that's constructable has

00:22:22,000 --> 00:22:26,720
constructors

00:22:23,280 --> 00:22:28,640
manipulators and accessors and you know

00:22:26,720 --> 00:22:31,120
exactly what they are because they're

00:22:28,640 --> 00:22:33,200
not opinions they're facts

00:22:31,120 --> 00:22:35,039
so just by virtue of the fact that it's

00:22:33,200 --> 00:22:36,720
a const you know where to find it

00:22:35,039 --> 00:22:38,640
anyway that's our organization and then

00:22:36,720 --> 00:22:41,679
of course we have the free operators

00:22:38,640 --> 00:22:43,919
and for reasons that that are not

00:22:41,679 --> 00:22:45,600
capricious operator double equals and

00:22:43,919 --> 00:22:47,360
not equals and all of those kinds of

00:22:45,600 --> 00:22:49,280
operators aren't not methods of a class

00:22:47,360 --> 00:22:52,480
to provide symmetry with respect

00:22:49,280 --> 00:22:55,039
to the left and right side um

00:22:52,480 --> 00:22:56,640
user-defined conversions all right among

00:22:55,039 --> 00:22:59,039
other reasons

00:22:56,640 --> 00:23:00,400
and here's the end of that file so if we

00:22:59,039 --> 00:23:02,080
were to look at this as a diagram we

00:23:00,400 --> 00:23:04,960
have three kinds of things

00:23:02,080 --> 00:23:05,919
uh in a logical diagram we have users in

00:23:04,960 --> 00:23:09,600
the interface

00:23:05,919 --> 00:23:10,480
which means uh a function uses a type in

00:23:09,600 --> 00:23:12,559
its interface

00:23:10,480 --> 00:23:14,799
if the function names the type in its

00:23:12,559 --> 00:23:17,039
signature as part of its return type

00:23:14,799 --> 00:23:18,880
and a type where you use as a type in

00:23:17,039 --> 00:23:21,440
its interface a class for example

00:23:18,880 --> 00:23:23,039
if any of its member functions use that

00:23:21,440 --> 00:23:24,000
type in the interface so this is used as

00:23:23,039 --> 00:23:26,480
in the interface

00:23:24,000 --> 00:23:27,520
means it's programmatically known to be

00:23:26,480 --> 00:23:29,280
part of

00:23:27,520 --> 00:23:30,720
the usage model uses in the

00:23:29,280 --> 00:23:31,679
implementation means it's used

00:23:30,720 --> 00:23:33,440
substantively

00:23:31,679 --> 00:23:34,880
but there's no programmatic way to get

00:23:33,440 --> 00:23:35,600
your hands on the thing that's being

00:23:34,880 --> 00:23:38,080
used

00:23:35,600 --> 00:23:38,799
so uses in the implementation in our

00:23:38,080 --> 00:23:41,039
notation

00:23:38,799 --> 00:23:42,240
implies that it's not used in the

00:23:41,039 --> 00:23:42,960
interface if something's used in the

00:23:42,240 --> 00:23:44,720
interface

00:23:42,960 --> 00:23:46,159
it's used in the implementation

00:23:44,720 --> 00:23:48,840
something is used in the implementation

00:23:46,159 --> 00:23:50,080
it implies that it's not used in the

00:23:48,840 --> 00:23:53,039
interface

00:23:50,080 --> 00:23:55,760
this other thing every dot h uh is

00:23:53,039 --> 00:23:57,120
included by its corresponding.cpp as the

00:23:55,760 --> 00:23:58,640
first substantive line of code they're

00:23:57,120 --> 00:24:00,080
four properties of a component we're not

00:23:58,640 --> 00:24:01,360
going to talk about them here

00:24:00,080 --> 00:24:03,200
but they're definitely important

00:24:01,360 --> 00:24:05,039
properties that make a dot h dot cpp

00:24:03,200 --> 00:24:06,559
pair more than just that

00:24:05,039 --> 00:24:08,240
the physical interface again is the

00:24:06,559 --> 00:24:10,000
header file the physical implementation

00:24:08,240 --> 00:24:12,559
is the cpp file

00:24:10,000 --> 00:24:14,320
now not every component is considered

00:24:12,559 --> 00:24:17,600
created equal some are very simple

00:24:14,320 --> 00:24:21,520
for example they have just one class uh

00:24:17,600 --> 00:24:26,080
and and uh more complex ones

00:24:21,520 --> 00:24:29,520
uh have uh uh maybe more than one class

00:24:26,080 --> 00:24:31,360
uh yet another uh component might have

00:24:29,520 --> 00:24:33,039
several different classes in it but all

00:24:31,360 --> 00:24:34,880
of them are tightly related

00:24:33,039 --> 00:24:36,640
and typically the reason for having more

00:24:34,880 --> 00:24:38,400
than one class and a component is

00:24:36,640 --> 00:24:39,200
friendship not cyclic dependency not

00:24:38,400 --> 00:24:40,960
anything else

00:24:39,200 --> 00:24:42,559
friendship is really the reason why we

00:24:40,960 --> 00:24:45,200
would do such a thing

00:24:42,559 --> 00:24:46,799
and then finally um we might have

00:24:45,200 --> 00:24:48,960
something that's extremely complex we'll

00:24:46,799 --> 00:24:52,480
call this more like a facade

00:24:48,960 --> 00:24:53,600
and a facade is uh not something that

00:24:52,480 --> 00:24:55,520
can clearly be

00:24:53,600 --> 00:24:57,360
completely implemented within one class

00:24:55,520 --> 00:24:59,600
it's going to delegate to other

00:24:57,360 --> 00:25:00,799
uh components uh excuse me can be

00:24:59,600 --> 00:25:02,400
implemented in one components can be

00:25:00,799 --> 00:25:03,840
delegated other components

00:25:02,400 --> 00:25:06,080
so if we take a look at some sort of

00:25:03,840 --> 00:25:08,080
physical structure uh

00:25:06,080 --> 00:25:09,279
uh the structure might consist of very

00:25:08,080 --> 00:25:11,760
simple things it might

00:25:09,279 --> 00:25:13,200
consist of more complex things or very

00:25:11,760 --> 00:25:15,840
complex things

00:25:13,200 --> 00:25:17,919
i'm showing this more as a pedagogical

00:25:15,840 --> 00:25:20,000
example

00:25:17,919 --> 00:25:21,840
whether you'd have a particular body of

00:25:20,000 --> 00:25:23,360
code that has a point and a matching

00:25:21,840 --> 00:25:24,799
engine which is something that's used to

00:25:23,360 --> 00:25:26,320
pair

00:25:24,799 --> 00:25:28,240
people who want to buy stocks and sell

00:25:26,320 --> 00:25:29,760
stocks in the same program

00:25:28,240 --> 00:25:31,600
who knows the point might be part of a

00:25:29,760 --> 00:25:33,840
graphical interface the item

00:25:31,600 --> 00:25:36,000
iterator might be something that's used

00:25:33,840 --> 00:25:37,360
to to do some low-level thing that has

00:25:36,000 --> 00:25:38,000
nothing to do with the application

00:25:37,360 --> 00:25:39,760
itself

00:25:38,000 --> 00:25:41,120
but in the full dependency that might

00:25:39,760 --> 00:25:42,480
happen so here's a point

00:25:41,120 --> 00:25:44,799
very simple at the bottom of the

00:25:42,480 --> 00:25:46,159
physical hierarchy here's a container

00:25:44,799 --> 00:25:47,520
class it might be a little bit higher

00:25:46,159 --> 00:25:50,240
than the most simple thing

00:25:47,520 --> 00:25:52,400
and here we are way up the chain in some

00:25:50,240 --> 00:25:54,000
sort of application level library

00:25:52,400 --> 00:25:56,000
that's creating what's called a matching

00:25:54,000 --> 00:25:58,559
engine a very complex piece of machinery

00:25:56,000 --> 00:25:59,760
that's reused as such uh throughout a

00:25:58,559 --> 00:26:01,600
large company like

00:25:59,760 --> 00:26:02,960
i don't know a trading company or who

00:26:01,600 --> 00:26:05,200
knows maybe bloomberg

00:26:02,960 --> 00:26:06,880
um i'm going to take a quick pause for

00:26:05,200 --> 00:26:07,840
questions now and just see if there's

00:26:06,880 --> 00:26:11,840
anything

00:26:07,840 --> 00:26:15,360
that i i need to to answer real quick

00:26:11,840 --> 00:26:16,880
so let me just look um

00:26:15,360 --> 00:26:18,640
and see if there's anything if it's not

00:26:16,880 --> 00:26:21,919
something so gosh

00:26:18,640 --> 00:26:22,960
okay i was asked uh if the business has

00:26:21,919 --> 00:26:24,960
a large culture of

00:26:22,960 --> 00:26:27,039
developing monolith from scratch

00:26:24,960 --> 00:26:29,279
applications how can you convince them

00:26:27,039 --> 00:26:30,559
that a reusable library framework has

00:26:29,279 --> 00:26:33,360
business value

00:26:30,559 --> 00:26:35,520
so this is an excellent question show

00:26:33,360 --> 00:26:37,440
them this talk have them read this book

00:26:35,520 --> 00:26:40,320
and have them relive my life for the

00:26:37,440 --> 00:26:43,200
past 20 years i had to do exactly that

00:26:40,320 --> 00:26:44,159
it turns out that this is a long-term

00:26:43,200 --> 00:26:46,720
investment

00:26:44,159 --> 00:26:48,400
what you need is somebody who's either

00:26:46,720 --> 00:26:49,679
high enough in the company and plans to

00:26:48,400 --> 00:26:51,200
be there for a while

00:26:49,679 --> 00:26:53,039
that what happens three years from now

00:26:51,200 --> 00:26:56,159
actually matters

00:26:53,039 --> 00:26:59,200
or you have to develop a

00:26:56,159 --> 00:27:00,320
a sort of a ground swell of leaf level

00:26:59,200 --> 00:27:03,600
people

00:27:00,320 --> 00:27:05,679
who together decide to do this

00:27:03,600 --> 00:27:08,559
i'm not going to say it's easy but it's

00:27:05,679 --> 00:27:10,640
sort of a question of having to um

00:27:08,559 --> 00:27:11,919
to have the mindset and the will to make

00:27:10,640 --> 00:27:14,080
it happen

00:27:11,919 --> 00:27:15,600
i don't have a good recipe for it but

00:27:14,080 --> 00:27:17,679
persistence is a good one

00:27:15,600 --> 00:27:18,720
if you go to a new company the best

00:27:17,679 --> 00:27:20,320
thing you can do

00:27:18,720 --> 00:27:22,399
is put your head down and make yourself

00:27:20,320 --> 00:27:23,440
useful then over time people will see

00:27:22,399 --> 00:27:25,200
that you're useful

00:27:23,440 --> 00:27:27,360
then you go to the next step which is

00:27:25,200 --> 00:27:28,640
you say here i think this and if people

00:27:27,360 --> 00:27:30,559
don't agree say okay

00:27:28,640 --> 00:27:32,320
then they find out you were right and

00:27:30,559 --> 00:27:34,000
over time if you play your cards right

00:27:32,320 --> 00:27:35,279
people will actually listen to you and

00:27:34,000 --> 00:27:37,200
when they finally listen to you

00:27:35,279 --> 00:27:38,480
hopefully it doesn't take 20 years

00:27:37,200 --> 00:27:40,399
then you can tell them this is a good

00:27:38,480 --> 00:27:41,679
idea in any event if you're a team lead

00:27:40,399 --> 00:27:44,159
you don't need permission

00:27:41,679 --> 00:27:45,120
uh on how to organize your team's code

00:27:44,159 --> 00:27:47,279
just do it

00:27:45,120 --> 00:27:49,200
and finally the way to separate that out

00:27:47,279 --> 00:27:51,279
i think is to make sure that you

00:27:49,200 --> 00:27:52,399
if you have a clean code base try not to

00:27:51,279 --> 00:27:54,399
depend directly

00:27:52,399 --> 00:27:56,000
on something that's quicksand try to

00:27:54,399 --> 00:27:57,919
build your code separately and

00:27:56,000 --> 00:27:59,039
have them depend on you that's what i

00:27:57,919 --> 00:28:00,480
did uh

00:27:59,039 --> 00:28:02,559
i'm going to take some of these other

00:28:00,480 --> 00:28:04,880
questions later because i'm low on time

00:28:02,559 --> 00:28:07,520
but i think that question deserves uh

00:28:04,880 --> 00:28:09,760
deserve definitely deserves some uh

00:28:07,520 --> 00:28:11,279
attention now so now i'm going to go on

00:28:09,760 --> 00:28:15,520
to the next step

00:28:11,279 --> 00:28:18,559
which is to talk about um

00:28:15,520 --> 00:28:20,399
an analogy so uh top-down

00:28:18,559 --> 00:28:21,760
software design is a recursive

00:28:20,399 --> 00:28:25,120
partitioning problem

00:28:21,760 --> 00:28:26,559
and it's a hard problem and attempting

00:28:25,120 --> 00:28:30,000
to optimize it

00:28:26,559 --> 00:28:32,799
is is a complex um is

00:28:30,000 --> 00:28:34,320
satisfying a complex uh cost function so

00:28:32,799 --> 00:28:37,440
we're going to create an analogy

00:28:34,320 --> 00:28:39,840
between hierarchical software design

00:28:37,440 --> 00:28:40,880
which is hard and something that's not

00:28:39,840 --> 00:28:43,919
as hard

00:28:40,880 --> 00:28:44,880
and quantifiable so take a look at this

00:28:43,919 --> 00:28:46,559
we have

00:28:44,880 --> 00:28:48,559
this this text here suppose that we want

00:28:46,559 --> 00:28:50,240
to write a program to format function

00:28:48,559 --> 00:28:50,799
documentation that avoids leaving lots

00:28:50,240 --> 00:28:53,039
of space

00:28:50,799 --> 00:28:54,640
at the end of a line due to very long

00:28:53,039 --> 00:28:58,320
words like my

00:28:54,640 --> 00:28:59,760
very long type maybe you've done this

00:28:58,320 --> 00:29:01,440
and you say gee i wish that the

00:28:59,760 --> 00:29:03,279
ragged documentation on the function

00:29:01,440 --> 00:29:05,440
looked a little better what

00:29:03,279 --> 00:29:06,960
we don't like this we don't even like

00:29:05,440 --> 00:29:08,399
this what might we do

00:29:06,960 --> 00:29:10,480
well we'd like it to look a little bit

00:29:08,399 --> 00:29:11,919
more like this but somebody might say

00:29:10,480 --> 00:29:14,000
well how can you optimize

00:29:11,919 --> 00:29:15,360
how can you automate that so that it

00:29:14,000 --> 00:29:17,440
looks like that by just

00:29:15,360 --> 00:29:20,080
applying some sort of editor function to

00:29:17,440 --> 00:29:20,720
do it and so that you get this nice more

00:29:20,080 --> 00:29:23,120
even

00:29:20,720 --> 00:29:24,960
spacing at the end so now what i'm going

00:29:23,120 --> 00:29:25,760
to ask you to do is look at these two

00:29:24,960 --> 00:29:29,279
things

00:29:25,760 --> 00:29:33,039
how would you write a program that

00:29:29,279 --> 00:29:36,320
optimizes the layout

00:29:33,039 --> 00:29:37,360
of each line so that the spacing is more

00:29:36,320 --> 00:29:39,440
even

00:29:37,360 --> 00:29:41,840
think about this for a second what would

00:29:39,440 --> 00:29:41,840
you do

00:29:42,640 --> 00:29:46,640
so what you want to do is you want to

00:29:44,159 --> 00:29:48,799
create for a series of words

00:29:46,640 --> 00:29:50,000
you've got these words you want to

00:29:48,799 --> 00:29:54,399
partition

00:29:50,000 --> 00:29:56,799
the words somehow such that

00:29:54,399 --> 00:29:59,520
some function of the spacing at the end

00:29:56,799 --> 00:29:59,520
of the lines

00:29:59,919 --> 00:30:06,240
is minimized and that function is

00:30:03,279 --> 00:30:07,039
any non-linear function any super linear

00:30:06,240 --> 00:30:09,919
function like

00:30:07,039 --> 00:30:11,440
x squared x cubed x to the fourth

00:30:09,919 --> 00:30:14,799
because

00:30:11,440 --> 00:30:15,840
a long gap will be treated much more

00:30:14,799 --> 00:30:18,880
harshly

00:30:15,840 --> 00:30:20,640
than two medium gaps

00:30:18,880 --> 00:30:22,480
and you'll see that used done right here

00:30:20,640 --> 00:30:23,600
this is a cost function

00:30:22,480 --> 00:30:25,279
here we're going to see the cost

00:30:23,600 --> 00:30:26,399
function in action so here on the left

00:30:25,279 --> 00:30:28,320
side you see

00:30:26,399 --> 00:30:29,600
i have used a greedy algorithm to fill

00:30:28,320 --> 00:30:31,760
in three words

00:30:29,600 --> 00:30:34,320
over here you've seen that i've wisely

00:30:31,760 --> 00:30:36,960
chosen using a global algorithm

00:30:34,320 --> 00:30:38,480
not to fill in three words as a result

00:30:36,960 --> 00:30:41,760
the first two lines

00:30:38,480 --> 00:30:44,960
contribute a lower cost

00:30:41,760 --> 00:30:47,760
to the overall cost function you see one

00:30:44,960 --> 00:30:49,360
one cubed plus nine cubed is less than

00:30:47,760 --> 00:30:52,240
five cubed plus five cubed

00:30:49,360 --> 00:30:53,440
you see that 1 cubed and 9 cubed you see

00:30:52,240 --> 00:30:57,840
the 5 cubed and 5

00:30:53,440 --> 00:30:59,840
cubed when you add them up you get this

00:30:57,840 --> 00:31:01,039
this is the cost function and the cost

00:30:59,840 --> 00:31:04,080
function

00:31:01,039 --> 00:31:06,240
is lower on the right because the

00:31:04,080 --> 00:31:07,760
sum of the cubes of the number of

00:31:06,240 --> 00:31:13,120
trailing spaces

00:31:07,760 --> 00:31:15,200
on the right is lower better partition

00:31:13,120 --> 00:31:17,840
okay so what we're doing is we have a

00:31:15,200 --> 00:31:19,279
global cost function instead of a local

00:31:17,840 --> 00:31:20,960
approach a local algorithm called a

00:31:19,279 --> 00:31:23,519
greedy algorithm

00:31:20,960 --> 00:31:25,760
so it looks better and the same would be

00:31:23,519 --> 00:31:28,799
true if we had a global cost function

00:31:25,760 --> 00:31:33,600
that optimized hierarchical

00:31:28,799 --> 00:31:37,519
design that would be wonderful but

00:31:33,600 --> 00:31:40,159
how do we do that so anyway

00:31:37,519 --> 00:31:41,919
we're going to describe a programmatic

00:31:40,159 --> 00:31:43,120
solution to the problem that we do

00:31:41,919 --> 00:31:46,240
understand

00:31:43,120 --> 00:31:48,720
which is how do we optimize the

00:31:46,240 --> 00:31:49,440
rendering of text so as to make it less

00:31:48,720 --> 00:31:51,200
ragged

00:31:49,440 --> 00:31:52,640
and what you see here is a library

00:31:51,200 --> 00:31:55,679
component and

00:31:52,640 --> 00:31:56,240
the function the struct format util is

00:31:55,679 --> 00:31:59,279
the one

00:31:56,240 --> 00:32:02,399
that holds the name space for the actual

00:31:59,279 --> 00:32:04,399
um function that we're going to create

00:32:02,399 --> 00:32:06,880
so this is the name of the header file

00:32:04,399 --> 00:32:09,440
of the component

00:32:06,880 --> 00:32:10,640
this is the struct that holds the

00:32:09,440 --> 00:32:14,399
namespace

00:32:10,640 --> 00:32:16,960
for the static function that is

00:32:14,399 --> 00:32:19,200
the utility function is the utility the

00:32:16,960 --> 00:32:20,960
utility function

00:32:19,200 --> 00:32:22,720
utility function and now we're going to

00:32:20,960 --> 00:32:23,679
look at the utility function and its

00:32:22,720 --> 00:32:26,799
contract

00:32:23,679 --> 00:32:28,399
here it is now you can read this i'm not

00:32:26,799 --> 00:32:29,519
going to read it to you but what you

00:32:28,399 --> 00:32:32,399
need to understand

00:32:29,519 --> 00:32:34,720
is that you have a you have a prototype

00:32:32,399 --> 00:32:37,919
the prototype consists of return type

00:32:34,720 --> 00:32:41,120
and a bunch of formal

00:32:37,919 --> 00:32:42,799
parameters with types but that's not

00:32:41,120 --> 00:32:44,000
enough you need a contract contracts are

00:32:42,799 --> 00:32:45,600
very important something we've been

00:32:44,000 --> 00:32:47,360
working on very very aggressively at

00:32:45,600 --> 00:32:49,039
bloomberg since 2004

00:32:47,360 --> 00:32:50,960
almost made it into the c plus plus

00:32:49,039 --> 00:32:52,000
standard and by contracts i don't mean

00:32:50,960 --> 00:32:54,159
just the

00:32:52,000 --> 00:32:56,399
description here but the actual ability

00:32:54,159 --> 00:32:58,720
of the compiler to help you check them

00:32:56,399 --> 00:33:00,799
so that's what contract checking is in c

00:32:58,720 --> 00:33:02,720
plus hopefully 23

00:33:00,799 --> 00:33:04,159
but for right now this is the english

00:33:02,720 --> 00:33:06,880
version of the contract

00:33:04,159 --> 00:33:07,840
which you could then apply precondition

00:33:06,880 --> 00:33:09,760
checks to

00:33:07,840 --> 00:33:10,960
somehow using some homegrown system but

00:33:09,760 --> 00:33:14,559
only soon in c

00:33:10,960 --> 00:33:16,480
plus itself all right so

00:33:14,559 --> 00:33:18,240
this is the top level application

00:33:16,480 --> 00:33:21,600
program this is something

00:33:18,240 --> 00:33:24,799
that will be used to uh

00:33:21,600 --> 00:33:26,240
leverage the the library functions so

00:33:24,799 --> 00:33:28,159
what we're saying here is the library

00:33:26,240 --> 00:33:30,080
function alone doesn't get the job done

00:33:28,159 --> 00:33:31,600
this is the actual application program

00:33:30,080 --> 00:33:33,600
that makes use of it that uh

00:33:31,600 --> 00:33:35,360
that an end user would call and the

00:33:33,600 --> 00:33:36,960
whole point is that this application

00:33:35,360 --> 00:33:37,519
program is going to call that library

00:33:36,960 --> 00:33:39,679
function

00:33:37,519 --> 00:33:42,000
so here's the application program we're

00:33:39,679 --> 00:33:44,080
specifying the non-linear function as we

00:33:42,000 --> 00:33:45,279
we said and it's just going to be the

00:33:44,080 --> 00:33:48,159
number cubed

00:33:45,279 --> 00:33:50,000
and then we're going to invoke uh no

00:33:48,159 --> 00:33:51,200
excuse me this is a local function this

00:33:50,000 --> 00:33:52,880
is one of those malleable functions

00:33:51,200 --> 00:33:55,120
that's part of the application

00:33:52,880 --> 00:33:56,080
and then finally we've got the main

00:33:55,120 --> 00:33:59,120
program

00:33:56,080 --> 00:34:01,279
and the main program is going to call

00:33:59,120 --> 00:34:02,880
the library function so this is where we

00:34:01,279 --> 00:34:03,760
call the library function and all we do

00:34:02,880 --> 00:34:05,440
is we set up

00:34:03,760 --> 00:34:07,120
the call to the library function the

00:34:05,440 --> 00:34:09,040
library function does its work

00:34:07,120 --> 00:34:11,359
returning the partition that we need is

00:34:09,040 --> 00:34:13,599
the first argument

00:34:11,359 --> 00:34:16,000
at which we're passing in by address and

00:34:13,599 --> 00:34:16,000
we're done

00:34:18,560 --> 00:34:21,679
this is where we print the results now

00:34:20,639 --> 00:34:25,119
we're really done

00:34:21,679 --> 00:34:26,399
okay so what's the pseudo code for the

00:34:25,119 --> 00:34:27,839
library function that we're trying to

00:34:26,399 --> 00:34:28,720
create the pseudo code looks something

00:34:27,839 --> 00:34:32,879
like this

00:34:28,720 --> 00:34:36,639
uh we're gonna say if a particular

00:34:32,879 --> 00:34:38,560
sequence of words fits on a line great

00:34:36,639 --> 00:34:40,079
if it doesn't fit on the line which is a

00:34:38,560 --> 00:34:41,919
parameter to the function

00:34:40,079 --> 00:34:44,000
then we're going to partition it every

00:34:41,919 --> 00:34:46,079
way we can by dividing it in every

00:34:44,000 --> 00:34:49,119
possible partition pair

00:34:46,079 --> 00:34:50,000
solve the problem recursively and then

00:34:49,119 --> 00:34:52,720
take the one

00:34:50,000 --> 00:34:54,399
the pair that has the least some cost

00:34:52,720 --> 00:34:56,000
and return that is the answer to the

00:34:54,399 --> 00:34:58,640
question

00:34:56,000 --> 00:34:59,920
so this is again this is the if it's

00:34:58,640 --> 00:35:02,800
good

00:34:59,920 --> 00:35:04,160
leave it if it's not recursively

00:35:02,800 --> 00:35:07,200
partition it

00:35:04,160 --> 00:35:11,040
and then load the result

00:35:07,200 --> 00:35:13,280
so this is the library component

00:35:11,040 --> 00:35:13,680
implementation file now i'm showing you

00:35:13,280 --> 00:35:15,119
this

00:35:13,680 --> 00:35:16,800
not because i want you to understand

00:35:15,119 --> 00:35:18,400
every part of it but just simply so that

00:35:16,800 --> 00:35:19,440
you have it on the camera you can go

00:35:18,400 --> 00:35:21,280
back and look at it

00:35:19,440 --> 00:35:23,680
this is the name of the file we always

00:35:21,280 --> 00:35:25,280
do that

00:35:23,680 --> 00:35:27,680
this is the local context that we're

00:35:25,280 --> 00:35:28,640
passing in this is the recursive

00:35:27,680 --> 00:35:30,240
subroutine

00:35:28,640 --> 00:35:31,920
that we're going to call from the main

00:35:30,240 --> 00:35:34,560
subroutine which is the entry point to

00:35:31,920 --> 00:35:34,560
the utility

00:35:35,839 --> 00:35:40,240
and i'm going on with that and this is

00:35:38,160 --> 00:35:42,000
the main entry point to the utility

00:35:40,240 --> 00:35:43,359
now again i'm not asking you to read

00:35:42,000 --> 00:35:45,359
this i just want you to know that this

00:35:43,359 --> 00:35:46,240
is how much code it is it fits on a few

00:35:45,359 --> 00:35:48,960
slides

00:35:46,240 --> 00:35:50,400
you can go back and look at the slides

00:35:48,960 --> 00:35:52,240
it's also in the book

00:35:50,400 --> 00:35:54,480
in fact every picture here is a figure

00:35:52,240 --> 00:35:55,760
from the book so you don't have any

00:35:54,480 --> 00:35:58,079
question if you want to go back and read

00:35:55,760 --> 00:36:01,040
about this chapter zero is exactly

00:35:58,079 --> 00:36:04,240
your friend it's explained all

00:36:01,040 --> 00:36:07,920
thoroughly totally utterly in the book

00:36:04,240 --> 00:36:09,839
so where we have a recursive

00:36:07,920 --> 00:36:11,440
descent approach you know we're going

00:36:09,839 --> 00:36:13,920
down and looking at each thing

00:36:11,440 --> 00:36:15,920
but they're an exponential number of

00:36:13,920 --> 00:36:19,520
things we have to look at

00:36:15,920 --> 00:36:21,599
and while this program works in theory

00:36:19,520 --> 00:36:23,119
it doesn't work in practice it doesn't

00:36:21,599 --> 00:36:25,440
scale

00:36:23,119 --> 00:36:27,839
but there aren't an exponential number

00:36:25,440 --> 00:36:28,960
of subproblems to solve which is

00:36:27,839 --> 00:36:31,040
an important point of this whole

00:36:28,960 --> 00:36:34,160
discussion they're only

00:36:31,040 --> 00:36:36,400
a polynomial number why is that

00:36:34,160 --> 00:36:38,240
because every partition that you might

00:36:36,400 --> 00:36:41,040
want to describe

00:36:38,240 --> 00:36:43,359
for n words can be described as its

00:36:41,040 --> 00:36:47,359
starting index i which is between 1

00:36:43,359 --> 00:36:48,720
0 and n and it's and its final index

00:36:47,359 --> 00:36:50,560
which is between 0 and n so if you

00:36:48,720 --> 00:36:53,359
choose them independently

00:36:50,560 --> 00:36:54,320
you would get n by n which is n squared

00:36:53,359 --> 00:36:56,960
there are only

00:36:54,320 --> 00:36:58,880
n squared subproblems therefore an

00:36:56,960 --> 00:37:00,400
exponential number of calculations is a

00:36:58,880 --> 00:37:02,720
bad idea

00:37:00,400 --> 00:37:03,920
notice the analogy with software if

00:37:02,720 --> 00:37:06,000
they're only a

00:37:03,920 --> 00:37:07,599
polynomial number of things to write and

00:37:06,000 --> 00:37:08,560
you find yourself writing an exponential

00:37:07,599 --> 00:37:10,880
number of things

00:37:08,560 --> 00:37:12,160
something's wrong we'll get to that so

00:37:10,880 --> 00:37:13,440
given that they're only n squared

00:37:12,160 --> 00:37:16,800
problems what can we

00:37:13,440 --> 00:37:19,839
do and you'll see the analogy is

00:37:16,800 --> 00:37:21,119
we don't solve them over and over again

00:37:19,839 --> 00:37:23,359
so what we're going to do is we're going

00:37:21,119 --> 00:37:26,880
to add what we'll call

00:37:23,359 --> 00:37:28,960
a solution cache and if the problem is

00:37:26,880 --> 00:37:31,760
already in the solution cache

00:37:28,960 --> 00:37:34,800
we use it like a library and if it's not

00:37:31,760 --> 00:37:36,880
we write it and put it in the library

00:37:34,800 --> 00:37:38,880
so what does that look like i'm showing

00:37:36,880 --> 00:37:39,680
you the same code as before except i've

00:37:38,880 --> 00:37:43,040
added

00:37:39,680 --> 00:37:44,720
i've taken away anything i've added code

00:37:43,040 --> 00:37:47,119
to what we had before which is very

00:37:44,720 --> 00:37:49,520
important it's an additive process

00:37:47,119 --> 00:37:50,960
so i've added the solution cache i've

00:37:49,520 --> 00:37:52,880
added a data member

00:37:50,960 --> 00:37:55,280
i've added the part where we look to

00:37:52,880 --> 00:37:58,400
check to see if there's something there

00:37:55,280 --> 00:37:59,839
and then i've added the part

00:37:58,400 --> 00:38:02,000
where we say if it wasn't there i

00:37:59,839 --> 00:38:04,560
calculated and i put it back

00:38:02,000 --> 00:38:07,280
that's all this is that's called

00:38:04,560 --> 00:38:09,920
memoization or dynamic programming

00:38:07,280 --> 00:38:11,280
the point is you don't do a calculation

00:38:09,920 --> 00:38:14,000
twice once it's done

00:38:11,280 --> 00:38:14,880
you save the results now you eliminate

00:38:14,000 --> 00:38:17,440
the vast

00:38:14,880 --> 00:38:18,480
majority of the work so when you go to

00:38:17,440 --> 00:38:21,359
run this

00:38:18,480 --> 00:38:23,760
if you look at the number of potential

00:38:21,359 --> 00:38:26,800
sub-problems versus the actual

00:38:23,760 --> 00:38:27,760
number of unique sub-problems it becomes

00:38:26,800 --> 00:38:29,839
clear that

00:38:27,760 --> 00:38:31,760
one of them is scalable and one of them

00:38:29,839 --> 00:38:33,599
is not

00:38:31,760 --> 00:38:35,359
so let's take a look at the

00:38:33,599 --> 00:38:37,839
implementation

00:38:35,359 --> 00:38:39,359
the way we did this problem was we

00:38:37,839 --> 00:38:42,160
created a

00:38:39,359 --> 00:38:43,520
map of sub-ranges and every partition

00:38:42,160 --> 00:38:47,119
was copied into

00:38:43,520 --> 00:38:49,440
a new vector as a sequence of indices

00:38:47,119 --> 00:38:50,960
and you'll notice that those indices

00:38:49,440 --> 00:38:52,800
were copied

00:38:50,960 --> 00:38:54,880
not referenced when we went to larger

00:38:52,800 --> 00:38:57,599
and larger petition partitions

00:38:54,880 --> 00:38:58,960
that copying is akin to cut and paste we

00:38:57,599 --> 00:39:01,280
don't want to copy paste

00:38:58,960 --> 00:39:02,880
it would be much better if each

00:39:01,280 --> 00:39:05,200
individual partition

00:39:02,880 --> 00:39:07,440
referenced the top level solution which

00:39:05,200 --> 00:39:07,920
is decomposed into sub solutions and so

00:39:07,440 --> 00:39:10,400
on and

00:39:07,920 --> 00:39:12,640
so forth hierarchically where each sub

00:39:10,400 --> 00:39:14,560
solution had finite size

00:39:12,640 --> 00:39:15,680
a node much like a component has a

00:39:14,560 --> 00:39:17,359
finite size

00:39:15,680 --> 00:39:20,160
which is typically that can be tested by

00:39:17,359 --> 00:39:22,800
a single test driver file

00:39:20,160 --> 00:39:23,359
this is by reference not by value so in

00:39:22,800 --> 00:39:26,800
other words

00:39:23,359 --> 00:39:30,000
instead of copy paste we reference the

00:39:26,800 --> 00:39:31,359
library component fixed size nodes

00:39:30,000 --> 00:39:34,400
much like a component it's not

00:39:31,359 --> 00:39:37,920
arbitrarily large what about this map

00:39:34,400 --> 00:39:38,960
well a map in c plus plus is a balanced

00:39:37,920 --> 00:39:40,640
binary tree

00:39:38,960 --> 00:39:42,079
it's required to be that way because of

00:39:40,640 --> 00:39:44,480
the properties being

00:39:42,079 --> 00:39:46,480
able to for it to be ordered and certain

00:39:44,480 --> 00:39:48,960
other properties of guaranteed

00:39:46,480 --> 00:39:50,880
logarithmic worst case time but if we

00:39:48,960 --> 00:39:52,720
don't care about that

00:39:50,880 --> 00:39:54,320
balance tree we might decide to go with

00:39:52,720 --> 00:39:56,720
let's say an unordered

00:39:54,320 --> 00:39:58,079
map which is a hash table based thing

00:39:56,720 --> 00:39:59,200
and that is different properties and

00:39:58,079 --> 00:40:01,520
those properties are

00:39:59,200 --> 00:40:03,040
typically faster than what we would

00:40:01,520 --> 00:40:04,640
achieve with the tree

00:40:03,040 --> 00:40:07,920
but guess what we know that there are

00:40:04,640 --> 00:40:10,640
exactly a triangular matrix of solutions

00:40:07,920 --> 00:40:12,640
so we can create that triangular matrix

00:40:10,640 --> 00:40:15,359
in terms of a triangular array

00:40:12,640 --> 00:40:17,359
and we can pre-allocate that space as

00:40:15,359 --> 00:40:19,119
compactly as possible

00:40:17,359 --> 00:40:20,800
moreover we can know exactly where to go

00:40:19,119 --> 00:40:23,119
without having to do any sort of

00:40:20,800 --> 00:40:23,920
expensive or possibly non-constant

00:40:23,119 --> 00:40:27,359
lookup

00:40:23,920 --> 00:40:31,200
so the packed array is the winner

00:40:27,359 --> 00:40:33,119
by far now beating the analogy to death

00:40:31,200 --> 00:40:34,640
the original solution was intractable

00:40:33,119 --> 00:40:36,160
because we had to do an exponential

00:40:34,640 --> 00:40:37,520
number of calculations

00:40:36,160 --> 00:40:39,200
we then said we're going to create a

00:40:37,520 --> 00:40:40,319
library but we're going to copy paste

00:40:39,200 --> 00:40:42,480
the solutions

00:40:40,319 --> 00:40:44,000
that's the by value solution then we

00:40:42,480 --> 00:40:45,920
said we're going to not do that we're

00:40:44,000 --> 00:40:47,680
going to do those solutions by reference

00:40:45,920 --> 00:40:49,440
that's the hierarchically reusable

00:40:47,680 --> 00:40:51,440
library

00:40:49,440 --> 00:40:53,119
and then finally the carefully curated

00:40:51,440 --> 00:40:55,760
library is the one that has many

00:40:53,119 --> 00:40:57,440
easy ways to find what you need now i

00:40:55,760 --> 00:40:59,119
know i'm stretching the analogy but i

00:40:57,440 --> 00:41:01,119
wanted to show you that

00:40:59,119 --> 00:41:03,440
the more time you put into thinking

00:41:01,119 --> 00:41:06,560
about this the better your software

00:41:03,440 --> 00:41:07,760
uh development can be and so this is my

00:41:06,560 --> 00:41:10,480
analogy let's just

00:41:07,760 --> 00:41:10,880
beat it one more little bit and say what

00:41:10,480 --> 00:41:12,079
are the

00:41:10,880 --> 00:41:13,680
what is the analogy so you have a

00:41:12,079 --> 00:41:15,040
subjective cost function in software

00:41:13,680 --> 00:41:17,680
development what does it mean

00:41:15,040 --> 00:41:18,480
is it easy to read is it easy to use is

00:41:17,680 --> 00:41:21,599
it efficient

00:41:18,480 --> 00:41:23,040
is it whatever is it interoperable in

00:41:21,599 --> 00:41:24,319
text partitioning we have an objective

00:41:23,040 --> 00:41:26,720
cost function

00:41:24,319 --> 00:41:27,760
application programs and suites of

00:41:26,720 --> 00:41:29,839
programs

00:41:27,760 --> 00:41:31,920
those those are are related to the

00:41:29,839 --> 00:41:33,599
entire text and the entire text again

00:41:31,920 --> 00:41:35,599
those are the clients if you will that's

00:41:33,599 --> 00:41:38,240
the end product um

00:41:35,599 --> 00:41:38,960
factor design partitioning logical

00:41:38,240 --> 00:41:41,520
content

00:41:38,960 --> 00:41:42,319
words leaf component is a line you're

00:41:41,520 --> 00:41:44,800
trying to put

00:41:42,319 --> 00:41:46,720
logical content in a physical entity

00:41:44,800 --> 00:41:47,520
what is a component a component is a

00:41:46,720 --> 00:41:49,760
solution

00:41:47,520 --> 00:41:51,280
it might be a sub solution it might be a

00:41:49,760 --> 00:41:52,880
sub sub solution

00:41:51,280 --> 00:41:54,960
hierarchically reusable library is a

00:41:52,880 --> 00:41:57,280
solution cache an enterprise is

00:41:54,960 --> 00:41:59,680
enterprise-wide globally accessible

00:41:57,280 --> 00:42:01,359
to optimize an enterprise-wide library

00:41:59,680 --> 00:42:04,560
is to do a global

00:42:01,359 --> 00:42:06,800
optimization source code copy and paste

00:42:04,560 --> 00:42:09,119
independent solution copies that means

00:42:06,800 --> 00:42:11,760
that i'm giving you the indices for

00:42:09,119 --> 00:42:13,760
for a partition in this problem i'm

00:42:11,760 --> 00:42:16,800
giving it to you as a complete vector

00:42:13,760 --> 00:42:18,880
not as pointers to two sub-vectors

00:42:16,800 --> 00:42:20,400
software packaging strategy curated

00:42:18,880 --> 00:42:22,560
components again

00:42:20,400 --> 00:42:24,400
this is a well-organized solution cache

00:42:22,560 --> 00:42:26,640
possibly having a triangular matrix

00:42:24,400 --> 00:42:28,640
where you can find things instantly

00:42:26,640 --> 00:42:30,160
finding things in a library is a big

00:42:28,640 --> 00:42:30,880
issue as well of course so you have to

00:42:30,160 --> 00:42:33,280
keep that in mind

00:42:30,880 --> 00:42:34,400
uniform component size this is the

00:42:33,280 --> 00:42:36,880
uniform node

00:42:34,400 --> 00:42:38,240
in that solution where where you're not

00:42:36,880 --> 00:42:39,359
where you're not copying things that

00:42:38,240 --> 00:42:40,880
means that you're

00:42:39,359 --> 00:42:42,560
you're referring to other things and so

00:42:40,880 --> 00:42:45,359
the space utilization

00:42:42,560 --> 00:42:47,359
in your program goes down reusable

00:42:45,359 --> 00:42:49,680
software is stable by the way once you

00:42:47,359 --> 00:42:51,920
calculate an answer it never changes so

00:42:49,680 --> 00:42:54,640
everybody that depends on that answer

00:42:51,920 --> 00:42:57,359
never has to worry about being broken

00:42:54,640 --> 00:42:58,160
again it's an important point component

00:42:57,359 --> 00:43:00,079
dependency

00:42:58,160 --> 00:43:01,520
reference to subroutine so if you have a

00:43:00,079 --> 00:43:03,119
component that depends on two sub

00:43:01,520 --> 00:43:04,880
solutions that are components

00:43:03,119 --> 00:43:06,400
a reference to a solution depends on

00:43:04,880 --> 00:43:09,200
other solutions

00:43:06,400 --> 00:43:10,640
same idea finding a relevant component

00:43:09,200 --> 00:43:11,280
is the same as finding a solution

00:43:10,640 --> 00:43:14,160
quickly

00:43:11,280 --> 00:43:15,920
in the in the solution cache so that's

00:43:14,160 --> 00:43:18,720
the end of the analogy

00:43:15,920 --> 00:43:20,079
and let me just see if i can take um

00:43:18,720 --> 00:43:22,480
i'll try to look for another question i

00:43:20,079 --> 00:43:24,319
apologize that i'm going so quickly here

00:43:22,480 --> 00:43:27,839
but i did want to get this all in so let

00:43:24,319 --> 00:43:27,839
me see if i can answer another question

00:43:28,880 --> 00:43:32,640
it says you mentioned vocabulary types a

00:43:30,800 --> 00:43:33,280
lot in the book but explain them in

00:43:32,640 --> 00:43:35,119
detail

00:43:33,280 --> 00:43:36,800
in later volumes can you briefly explain

00:43:35,119 --> 00:43:38,000
what they are especially in the context

00:43:36,800 --> 00:43:39,760
of software capital

00:43:38,000 --> 00:43:41,200
i will that's an important question i

00:43:39,760 --> 00:43:42,400
wish i could answer more now but i'll

00:43:41,200 --> 00:43:45,440
answer that one

00:43:42,400 --> 00:43:47,119
um a vocabulary type very simply

00:43:45,440 --> 00:43:48,720
is a type that's used widely in the

00:43:47,119 --> 00:43:50,560
interface of functions

00:43:48,720 --> 00:43:51,760
if you have something that's that's

00:43:50,560 --> 00:43:53,359
that's a function

00:43:51,760 --> 00:43:54,880
just a function a free function or

00:43:53,359 --> 00:43:57,040
function as a member of a struct

00:43:54,880 --> 00:43:58,640
you could have 17 different functions

00:43:57,040 --> 00:44:00,480
they're not part of your vocabulary

00:43:58,640 --> 00:44:02,720
their implementation details

00:44:00,480 --> 00:44:04,560
you don't have to pass them around but

00:44:02,720 --> 00:44:06,560
now imagine you have something like a

00:44:04,560 --> 00:44:07,760
date class and that date class is used

00:44:06,560 --> 00:44:09,040
widely throughout your entire

00:44:07,760 --> 00:44:11,280
organization

00:44:09,040 --> 00:44:13,200
if you make a change to that date class

00:44:11,280 --> 00:44:14,960
and try to move it to some other

00:44:13,200 --> 00:44:17,839
package or try to call it another

00:44:14,960 --> 00:44:20,000
namespace or call it something else

00:44:17,839 --> 00:44:22,160
it will become inter non-interoperable

00:44:20,000 --> 00:44:26,079
with everything else that was using it

00:44:22,160 --> 00:44:28,640
so changing a vocabulary type

00:44:26,079 --> 00:44:30,960
is a major problem but if it's not a

00:44:28,640 --> 00:44:32,800
vocabulary type then it's easy to change

00:44:30,960 --> 00:44:34,319
because you change it you can have the

00:44:32,800 --> 00:44:36,880
non-vocabulary types

00:44:34,319 --> 00:44:38,240
such as a such as a utility struct or

00:44:36,880 --> 00:44:40,000
something that's not used in the

00:44:38,240 --> 00:44:42,160
interface like for example

00:44:40,000 --> 00:44:44,160
a scoped guard scoped guards are not

00:44:42,160 --> 00:44:45,280
used in the interface you could have 17

00:44:44,160 --> 00:44:47,359
scoped guards

00:44:45,280 --> 00:44:48,400
and no one would care but if you have

00:44:47,359 --> 00:44:51,440
for example an

00:44:48,400 --> 00:44:54,079
abstract allocator interface if that is

00:44:51,440 --> 00:44:55,280
ever more than exactly one you lose

00:44:54,079 --> 00:44:57,200
interoperability

00:44:55,280 --> 00:44:58,800
and that's why it's so important that an

00:44:57,200 --> 00:45:02,079
abstract type

00:44:58,800 --> 00:45:03,920
in the interface must be standard

00:45:02,079 --> 00:45:05,839
at least throughout your organization if

00:45:03,920 --> 00:45:08,720
not in the standard itself

00:45:05,839 --> 00:45:10,400
um i hope that answers that question and

00:45:08,720 --> 00:45:12,000
i'll try to get back to more questions

00:45:10,400 --> 00:45:15,680
if i have time after this

00:45:12,000 --> 00:45:15,680
um so let me continue

00:45:16,160 --> 00:45:20,160
bear with me while i get to the point

00:45:18,000 --> 00:45:23,200
here okay

00:45:20,160 --> 00:45:26,960
uh all right

00:45:23,200 --> 00:45:26,960
so when we're um

00:45:27,200 --> 00:45:30,079
when we're trying to design something in

00:45:28,880 --> 00:45:31,520
industry particularly if in the

00:45:30,079 --> 00:45:33,359
financial sector

00:45:31,520 --> 00:45:35,440
the faster you get something to market

00:45:33,359 --> 00:45:37,040
the more valuable it is if you wait

00:45:35,440 --> 00:45:39,119
and you make it perfect somebody else

00:45:37,040 --> 00:45:40,800
will get it there and they will get a

00:45:39,119 --> 00:45:43,440
larger profit margin

00:45:40,800 --> 00:45:44,079
uh because they got it there first over

00:45:43,440 --> 00:45:46,960
time

00:45:44,079 --> 00:45:47,520
these products will decay to steady

00:45:46,960 --> 00:45:49,920
state

00:45:47,520 --> 00:45:51,839
and you'll get just the free sort of the

00:45:49,920 --> 00:45:54,400
uh free market value

00:45:51,839 --> 00:45:56,079
and so it's often said that there's

00:45:54,400 --> 00:45:57,839
never enough time to do it right there's

00:45:56,079 --> 00:46:00,480
always enough time to do it over

00:45:57,839 --> 00:46:01,839
and as crazy as that sounds it's

00:46:00,480 --> 00:46:03,680
absolutely true

00:46:01,839 --> 00:46:05,359
you could imagine two teams the fast

00:46:03,680 --> 00:46:07,119
team and the right team

00:46:05,359 --> 00:46:09,520
the fast team gets it there quickly and

00:46:07,119 --> 00:46:12,960
the right team gets it there permanently

00:46:09,520 --> 00:46:14,000
and that's not wrong so you might think

00:46:12,960 --> 00:46:17,280
one way to have the

00:46:14,000 --> 00:46:18,560
fast team uh uh or the the right team

00:46:17,280 --> 00:46:21,520
get it there faster

00:46:18,560 --> 00:46:21,920
is to just pile on more effort all at

00:46:21,520 --> 00:46:23,599
once

00:46:21,920 --> 00:46:25,119
and we know that that's not true from

00:46:23,599 --> 00:46:27,599
the mythical man month right

00:46:25,119 --> 00:46:29,440
fred brooks would not agree the actual

00:46:27,599 --> 00:46:31,599
staffing profile and one that we use

00:46:29,440 --> 00:46:33,599
in my group and and hopefully everybody

00:46:31,599 --> 00:46:35,280
would consider as being a reasonable one

00:46:33,599 --> 00:46:38,000
is you start out with the germ of an

00:46:35,280 --> 00:46:39,760
idea and you you move it to a real idea

00:46:38,000 --> 00:46:41,040
and you get feedback and at some point

00:46:39,760 --> 00:46:43,440
you widen your audience

00:46:41,040 --> 00:46:45,520
to more and more feedback until it gets

00:46:43,440 --> 00:46:46,800
to a point where it's ready to put into

00:46:45,520 --> 00:46:49,200
real development

00:46:46,800 --> 00:46:51,200
we call that a hump project and that's

00:46:49,200 --> 00:46:53,200
an example of this curve

00:46:51,200 --> 00:46:54,240
where we've reached the part of the play

00:46:53,200 --> 00:46:55,839
of the project

00:46:54,240 --> 00:46:57,920
where we know what we're doing and now

00:46:55,839 --> 00:46:59,440
it's a question of execution

00:46:57,920 --> 00:47:00,880
there comes a point where we've done

00:46:59,440 --> 00:47:02,319
most of that the testing is not

00:47:00,880 --> 00:47:05,920
delivering too many

00:47:02,319 --> 00:47:06,640
uh uh uh defects and we say we're about

00:47:05,920 --> 00:47:08,319
ready to

00:47:06,640 --> 00:47:09,839
release that doesn't mean that we're

00:47:08,319 --> 00:47:11,200
done because once we release of course

00:47:09,839 --> 00:47:12,480
there's going to be more defects found

00:47:11,200 --> 00:47:14,960
in the field sadly

00:47:12,480 --> 00:47:16,560
and so uh if there are no defects found

00:47:14,960 --> 00:47:17,040
in the in the field we we release too

00:47:16,560 --> 00:47:18,800
late

00:47:17,040 --> 00:47:20,079
and if there are too many defects in the

00:47:18,800 --> 00:47:22,160
field we released too early

00:47:20,079 --> 00:47:24,000
so again this is a non-uh you know

00:47:22,160 --> 00:47:26,160
precise definition of

00:47:24,000 --> 00:47:27,280
what we mean by delivery date but you

00:47:26,160 --> 00:47:30,000
get the idea

00:47:27,280 --> 00:47:30,960
so we can't do that so what is software

00:47:30,000 --> 00:47:33,280
capital well

00:47:30,960 --> 00:47:34,880
its charter is resi to reduce time to

00:47:33,280 --> 00:47:37,680
market for future applications

00:47:34,880 --> 00:47:38,880
and products that's it's charter it's

00:47:37,680 --> 00:47:41,440
secondary benefit

00:47:38,880 --> 00:47:43,359
is just not to have to keep maintaining

00:47:41,440 --> 00:47:45,520
everything and reinventing the wheel

00:47:43,359 --> 00:47:47,520
but anyway what is software capital it's

00:47:45,520 --> 00:47:52,079
easy to understand

00:47:47,520 --> 00:47:53,040
it's easy to use that's easy to say it's

00:47:52,079 --> 00:47:54,880
high performing

00:47:53,040 --> 00:47:56,240
and in particular if we ever design

00:47:54,880 --> 00:47:57,359
something that isn't high performing you

00:47:56,240 --> 00:47:57,839
know there'll be somewhere out there

00:47:57,359 --> 00:48:00,079
that

00:47:57,839 --> 00:48:01,760
that'll want to rewrite it so it has to

00:48:00,079 --> 00:48:02,480
be so high performing that no one in

00:48:01,760 --> 00:48:04,240
their

00:48:02,480 --> 00:48:05,359
right mind would waste their time trying

00:48:04,240 --> 00:48:06,079
to write something that's more high

00:48:05,359 --> 00:48:08,480
performing

00:48:06,079 --> 00:48:09,520
this has been part of our methodology

00:48:08,480 --> 00:48:12,079
from the start

00:48:09,520 --> 00:48:13,200
that we cannot put something out there

00:48:12,079 --> 00:48:16,079
that's

00:48:13,200 --> 00:48:17,280
okay in performance it has to be the

00:48:16,079 --> 00:48:20,160
best

00:48:17,280 --> 00:48:22,000
portable we want to write things that if

00:48:20,160 --> 00:48:23,280
a new architecture comes along that's

00:48:22,000 --> 00:48:25,520
conforming to

00:48:23,280 --> 00:48:26,480
to what the standard defines that we

00:48:25,520 --> 00:48:29,119
will be able to port

00:48:26,480 --> 00:48:30,880
our software to it instantly and so we

00:48:29,119 --> 00:48:32,079
do lots of things to make sure that we

00:48:30,880 --> 00:48:33,599
don't go outside

00:48:32,079 --> 00:48:35,440
the standard and create platform

00:48:33,599 --> 00:48:36,640
adapters and such of course without

00:48:35,440 --> 00:48:39,599
losing efficiency

00:48:36,640 --> 00:48:41,440
and finally reliable and we really do

00:48:39,599 --> 00:48:44,000
strive to make our components

00:48:41,440 --> 00:48:45,680
as reliable as the compilers themselves

00:48:44,000 --> 00:48:46,960
and if that sounds like it's not

00:48:45,680 --> 00:48:50,240
reasonable

00:48:46,960 --> 00:48:51,920
believe me it is reasonable the reason

00:48:50,240 --> 00:48:54,079
compilers are pretty good is because

00:48:51,920 --> 00:48:57,119
they're field tested by a lot of people

00:48:54,079 --> 00:48:58,079
but it is not only because they're unit

00:48:57,119 --> 00:49:01,119
tested

00:48:58,079 --> 00:49:03,520
it is quite surprising how many little

00:49:01,119 --> 00:49:04,640
corner defects in the various compilers

00:49:03,520 --> 00:49:06,480
exist out there

00:49:04,640 --> 00:49:07,760
and they do get refined over time and

00:49:06,480 --> 00:49:10,480
there are defect reports

00:49:07,760 --> 00:49:11,920
so compilers are usually right and if

00:49:10,480 --> 00:49:13,520
it's a question between your code that

00:49:11,920 --> 00:49:15,920
you just wrote in a compiler

00:49:13,520 --> 00:49:17,920
chances are real good at your code we

00:49:15,920 --> 00:49:19,119
want our code to be at that level by the

00:49:17,920 --> 00:49:20,640
time we release it

00:49:19,119 --> 00:49:22,480
we have test methodologies that are

00:49:20,640 --> 00:49:24,640
described in part three of

00:49:22,480 --> 00:49:25,839
my book that come close to doing that

00:49:24,640 --> 00:49:28,640
when it's finally released

00:49:25,839 --> 00:49:29,760
um it'll be quite something i hope

00:49:28,640 --> 00:49:31,920
anyway

00:49:29,760 --> 00:49:33,119
continuing imagine you're in one of

00:49:31,920 --> 00:49:34,640
those home uh

00:49:33,119 --> 00:49:37,119
home improvement centers like a home

00:49:34,640 --> 00:49:38,960
depot or a lowe's and in this home

00:49:37,119 --> 00:49:41,040
improvement center all of the things in

00:49:38,960 --> 00:49:42,559
the first row the simple things like the

00:49:41,040 --> 00:49:45,119
nails and the screws

00:49:42,559 --> 00:49:46,079
are are the piece parts that the things

00:49:45,119 --> 00:49:48,400
in row two

00:49:46,079 --> 00:49:50,000
are built out of such as the i don't

00:49:48,400 --> 00:49:52,480
know the uh

00:49:50,000 --> 00:49:53,680
let's say we had a toaster toothbrush

00:49:52,480 --> 00:49:56,240
who knows

00:49:53,680 --> 00:49:58,079
a small box a jewelry box in row three

00:49:56,240 --> 00:49:59,599
maybe have a pre-assembled furniture

00:49:58,079 --> 00:50:01,359
maybe in four we have pre-assembled

00:49:59,599 --> 00:50:03,920
homes i don't know uh

00:50:01,359 --> 00:50:05,119
a car the point being that in this

00:50:03,920 --> 00:50:08,240
particular

00:50:05,119 --> 00:50:09,839
uh theoretical home improvement store

00:50:08,240 --> 00:50:11,440
all of the parts in the higher level

00:50:09,839 --> 00:50:12,960
rows are implemented in terms of the

00:50:11,440 --> 00:50:14,880
parts in the lower level rows

00:50:12,960 --> 00:50:16,880
think of these parts as types of parts

00:50:14,880 --> 00:50:19,440
rather than actual objects

00:50:16,880 --> 00:50:21,760
and it'll make more sense now if we ever

00:50:19,440 --> 00:50:24,160
talk about any one particular one

00:50:21,760 --> 00:50:25,920
we can see that that one depends on some

00:50:24,160 --> 00:50:29,440
subset of the other parts

00:50:25,920 --> 00:50:32,480
in the in the um repository

00:50:29,440 --> 00:50:33,839
and if we want to visualize that

00:50:32,480 --> 00:50:35,920
it would look like this and that's why

00:50:33,839 --> 00:50:37,680
visualization tools that that are

00:50:35,920 --> 00:50:39,359
reflective of both physical and logical

00:50:37,680 --> 00:50:41,440
design are so important

00:50:39,359 --> 00:50:44,079
we are actually actively researching

00:50:41,440 --> 00:50:45,680
such tools that will be consistent

00:50:44,079 --> 00:50:48,000
with what we're talking about in the

00:50:45,680 --> 00:50:51,040
book hopefully that will be available

00:50:48,000 --> 00:50:54,319
in the coming

00:50:51,040 --> 00:50:56,960
years year i don't know but at some

00:50:54,319 --> 00:50:58,559
point hopefully not too long from now

00:50:56,960 --> 00:51:00,160
we can make this more widely available

00:50:58,559 --> 00:51:01,680
but we're researching it now

00:51:00,160 --> 00:51:03,599
and it's incredibly important for

00:51:01,680 --> 00:51:06,160
understanding large systems

00:51:03,599 --> 00:51:07,520
so the idea is we started out with this

00:51:06,160 --> 00:51:10,800
faster better cheaper

00:51:07,520 --> 00:51:12,480
design space and not only did we move it

00:51:10,800 --> 00:51:15,119
out so that you could make things more

00:51:12,480 --> 00:51:17,040
faster more better and more cheaper

00:51:15,119 --> 00:51:19,520
uh we actually moved it off the axis

00:51:17,040 --> 00:51:23,599
because built into the reuse

00:51:19,520 --> 00:51:25,280
is the speed the quality and the

00:51:23,599 --> 00:51:27,359
cost savings because you don't have to

00:51:25,280 --> 00:51:29,920
reinvent the software each time

00:51:27,359 --> 00:51:31,680
test it each time and inventing and

00:51:29,920 --> 00:51:34,160
creating it does take time

00:51:31,680 --> 00:51:35,040
takes energy and it adds the risk of

00:51:34,160 --> 00:51:37,040
adding bugs

00:51:35,040 --> 00:51:39,599
and of course it adds maintenance cost

00:51:37,040 --> 00:51:40,960
so if we did this over time we'd see

00:51:39,599 --> 00:51:43,040
that we would

00:51:40,960 --> 00:51:44,160
without without software capital we

00:51:43,040 --> 00:51:46,319
would see that we would

00:51:44,160 --> 00:51:47,680
gain experience but we would lose

00:51:46,319 --> 00:51:49,599
productivity

00:51:47,680 --> 00:51:51,520
uh due to the cost of ownership because

00:51:49,599 --> 00:51:52,800
we didn't organize things just so

00:51:51,520 --> 00:51:54,079
and this curve is flattering to the

00:51:52,800 --> 00:51:54,960
people who chose not to use our

00:51:54,079 --> 00:51:57,119
methodology

00:51:54,960 --> 00:51:58,480
it's actually much worse than that if on

00:51:57,119 --> 00:52:00,160
the other hand we took a small group of

00:51:58,480 --> 00:52:00,960
people as we did 20 years ago at

00:52:00,160 --> 00:52:03,440
bloomberg

00:52:00,960 --> 00:52:04,000
and moved them to a group known as bde

00:52:03,440 --> 00:52:08,000
which i

00:52:04,000 --> 00:52:10,640
was the first person to be part of since

00:52:08,000 --> 00:52:12,880
i was the one that created it um after

00:52:10,640 --> 00:52:15,440
some period of time t1

00:52:12,880 --> 00:52:17,440
some productivity was seen and after

00:52:15,440 --> 00:52:20,960
some period of time t2

00:52:17,440 --> 00:52:23,119
the productivity cumulative productivity

00:52:20,960 --> 00:52:25,920
past the point where if we hadn't done

00:52:23,119 --> 00:52:26,640
that that was many many many many years

00:52:25,920 --> 00:52:29,359
ago

00:52:26,640 --> 00:52:29,760
and we haven't looked back so here we

00:52:29,359 --> 00:52:32,079
are

00:52:29,760 --> 00:52:32,960
almost 20 years hence and we're saying

00:52:32,079 --> 00:52:34,800
that

00:52:32,960 --> 00:52:36,240
t1 might have been on the order of a

00:52:34,800 --> 00:52:38,559
year or two uh

00:52:36,240 --> 00:52:39,599
i can't exactly say where t2 was but it

00:52:38,559 --> 00:52:42,000
wasn't that far

00:52:39,599 --> 00:52:43,359
after t1 i can assure you of that and

00:52:42,000 --> 00:52:46,400
then after that

00:52:43,359 --> 00:52:47,760
um here we are

00:52:46,400 --> 00:52:49,520
this is the critical point this is the

00:52:47,760 --> 00:52:51,680
break-even point for doing this

00:52:49,520 --> 00:52:53,119
if you ask me what that time is i'm sure

00:52:51,680 --> 00:52:55,359
if i had it to do over

00:52:53,119 --> 00:52:57,200
i could have done it faster but whatever

00:52:55,359 --> 00:52:58,960
time it is it's kind of like well

00:52:57,200 --> 00:53:00,640
how much time do you want to have before

00:52:58,960 --> 00:53:01,839
you've saved enough for your retirement

00:53:00,640 --> 00:53:03,520
you want to make that as soon as

00:53:01,839 --> 00:53:04,559
possible and if you're smart about it

00:53:03,520 --> 00:53:08,160
you'll do it sooner

00:53:04,559 --> 00:53:09,599
you'll start sooner what can i say

00:53:08,160 --> 00:53:11,839
once you've passed that point there's no

00:53:09,599 --> 00:53:13,760
looking back all right so you start with

00:53:11,839 --> 00:53:14,640
an application there is no software

00:53:13,760 --> 00:53:17,280
capital

00:53:14,640 --> 00:53:18,960
so you create some that application can

00:53:17,280 --> 00:53:20,800
then either choose to use that new

00:53:18,960 --> 00:53:21,440
software capital in the next version or

00:53:20,800 --> 00:53:22,960
not

00:53:21,440 --> 00:53:24,720
but the next application that comes

00:53:22,960 --> 00:53:27,359
along can start using that

00:53:24,720 --> 00:53:28,000
if it does less work was done you can

00:53:27,359 --> 00:53:30,400
then extract

00:53:28,000 --> 00:53:32,319
software capital from that that doesn't

00:53:30,400 --> 00:53:33,040
mean copy and paste it that means rework

00:53:32,319 --> 00:53:35,280
it and

00:53:33,040 --> 00:53:36,800
assimilate it by a different group into

00:53:35,280 --> 00:53:39,280
your software capital

00:53:36,800 --> 00:53:41,040
uh repository which of course is

00:53:39,280 --> 00:53:44,079
hierarchically usable

00:53:41,040 --> 00:53:47,119
and then that that could retool but then

00:53:44,079 --> 00:53:49,200
now an application three comes along

00:53:47,119 --> 00:53:50,319
you have a substantial body of software

00:53:49,200 --> 00:53:51,839
to draw from and you've made a

00:53:50,319 --> 00:53:53,520
substantial saving

00:53:51,839 --> 00:53:55,280
so the point is the first application

00:53:53,520 --> 00:53:56,240
does not benefit the second application

00:53:55,280 --> 00:53:58,240
benefits slightly

00:53:56,240 --> 00:53:59,359
but the fifth application benefits

00:53:58,240 --> 00:54:00,640
tremendously

00:53:59,359 --> 00:54:03,520
and i don't need to tell you what the

00:54:00,640 --> 00:54:05,280
175th application does

00:54:03,520 --> 00:54:07,119
now imagine you come along and we talked

00:54:05,280 --> 00:54:08,720
about this early on with say we had an

00:54:07,119 --> 00:54:11,359
http

00:54:08,720 --> 00:54:12,800
uh protocol we wanted to upgrade it well

00:54:11,359 --> 00:54:14,400
we're not going to go in let's say

00:54:12,800 --> 00:54:16,880
that's you we're not going to go in

00:54:14,400 --> 00:54:19,280
and change it and break everybody else

00:54:16,880 --> 00:54:21,119
in our system

00:54:19,280 --> 00:54:22,480
what we're going to do is we're not

00:54:21,119 --> 00:54:23,920
going to copy the system either

00:54:22,480 --> 00:54:25,839
we're going to take those pieces that

00:54:23,920 --> 00:54:27,680
are dependent on that and we're going to

00:54:25,839 --> 00:54:29,599
fork them but we're going to fork them

00:54:27,680 --> 00:54:31,760
in the way where they can co-exist

00:54:29,599 --> 00:54:33,839
so you have those solutions and those

00:54:31,760 --> 00:54:35,760
solutions prime and it was asked earlier

00:54:33,839 --> 00:54:38,559
can you do that with vocabulary types no

00:54:35,760 --> 00:54:40,400
you can't which is why this becomes

00:54:38,559 --> 00:54:41,680
a real engineering problem and why

00:54:40,400 --> 00:54:43,359
vocabulary types are so

00:54:41,680 --> 00:54:45,280
important but assuming it's not a

00:54:43,359 --> 00:54:47,680
vocabulary type then yes you can and

00:54:45,280 --> 00:54:49,920
this is the way to do it

00:54:47,680 --> 00:54:51,359
drawing this picture in ascii was hard

00:54:49,920 --> 00:54:53,119
but it's possible

00:54:51,359 --> 00:54:54,559
i did draw an ascii in my book when i

00:54:53,119 --> 00:54:56,640
did the original draft

00:54:54,559 --> 00:54:59,200
this is how we would do the http upgrade

00:54:56,640 --> 00:55:00,559
by the way we would have http 1 and http

00:54:59,200 --> 00:55:03,599
2 coexist

00:55:00,559 --> 00:55:06,000
so here's a here's a system

00:55:03,599 --> 00:55:07,839
that you might reuse it's embedded in a

00:55:06,000 --> 00:55:09,599
much larger body of code that is

00:55:07,839 --> 00:55:11,200
interoperable

00:55:09,599 --> 00:55:14,720
that follows the same design rules that

00:55:11,200 --> 00:55:14,720
we have that are described in the book

00:55:14,960 --> 00:55:19,599
the long-term vision in this picture was

00:55:16,799 --> 00:55:21,359
literally drawn 20 years ago

00:55:19,599 --> 00:55:24,079
with with what we have now as being the

00:55:21,359 --> 00:55:26,720
vision this is what we aspire to

00:55:24,079 --> 00:55:28,640
where most of our code is library code

00:55:26,720 --> 00:55:30,319
and the rest is appcode

00:55:28,640 --> 00:55:32,880
without it we get something that looks

00:55:30,319 --> 00:55:32,880
like this

00:55:33,040 --> 00:55:36,960
so the end goal is to have software

00:55:36,079 --> 00:55:39,440
capital

00:55:36,960 --> 00:55:41,760
that per component is enormously

00:55:39,440 --> 00:55:44,079
expensive

00:55:41,760 --> 00:55:45,200
and it doesn't matter because without it

00:55:44,079 --> 00:55:48,400
what would have

00:55:45,200 --> 00:55:49,200
come is code that is very very

00:55:48,400 --> 00:55:50,720
duplicative

00:55:49,200 --> 00:55:53,119
and the maintenance cost would be

00:55:50,720 --> 00:55:54,400
prohibitive and so the value of the

00:55:53,119 --> 00:55:57,280
software capital

00:55:54,400 --> 00:55:58,319
far far out seeds exceeds its cost

00:55:57,280 --> 00:56:01,440
because

00:55:58,319 --> 00:56:03,599
it can be reused across an unbounded

00:56:01,440 --> 00:56:04,160
number of versions of an unbounded

00:56:03,599 --> 00:56:07,760
number

00:56:04,160 --> 00:56:10,000
of applications in your

00:56:07,760 --> 00:56:11,200
domain i have to emphasize this the

00:56:10,000 --> 00:56:13,760
standard is not

00:56:11,200 --> 00:56:14,720
software capital it is not domain

00:56:13,760 --> 00:56:18,400
specific

00:56:14,720 --> 00:56:19,839
the software capital is is what you have

00:56:18,400 --> 00:56:23,280
invented because

00:56:19,839 --> 00:56:27,359
you invented it for your own purposes

00:56:23,280 --> 00:56:30,240
if you follow this methodology it's

00:56:27,359 --> 00:56:31,760
really useful somebody else's software

00:56:30,240 --> 00:56:33,280
capital is not your software capital

00:56:31,760 --> 00:56:34,240
especially if they don't follow the same

00:56:33,280 --> 00:56:36,160
methodology

00:56:34,240 --> 00:56:38,240
so one of the reasons it's okay for us

00:56:36,160 --> 00:56:39,599
to open source our software capital

00:56:38,240 --> 00:56:42,640
and that it's not a competitive

00:56:39,599 --> 00:56:44,799
advantage that we want to keep secret

00:56:42,640 --> 00:56:46,480
is that we actually feel that this

00:56:44,799 --> 00:56:47,119
software capital being stable in

00:56:46,480 --> 00:56:49,040
whatever

00:56:47,119 --> 00:56:51,520
will entice people to want to come work

00:56:49,040 --> 00:56:54,319
at bloomberg because our methodology

00:56:51,520 --> 00:56:55,440
is this is our methodology which started

00:56:54,319 --> 00:56:57,520
20 years ago

00:56:55,440 --> 00:56:59,839
and with hindsight we did the right

00:56:57,520 --> 00:57:02,960
thing and we're going to keep doing it

00:56:59,839 --> 00:57:04,960
and my advice to anybody who's has any

00:57:02,960 --> 00:57:07,280
say in anything that they're doing

00:57:04,960 --> 00:57:09,359
please consider using this methodology

00:57:07,280 --> 00:57:11,440
because you won't be disappointed

00:57:09,359 --> 00:57:12,799
kind of like a good stock tip which i

00:57:11,440 --> 00:57:16,000
won't give you here

00:57:12,799 --> 00:57:18,240
and that is the end of the talk and i

00:57:16,000 --> 00:57:19,599
have a couple of questions accumulated

00:57:18,240 --> 00:57:22,720
so what i'm going to try to do

00:57:19,599 --> 00:57:24,400
is answer a couple of them on this on

00:57:22,720 --> 00:57:27,200
this talk if i can

00:57:24,400 --> 00:57:28,480
and then i will uh and what i'm trying

00:57:27,200 --> 00:57:29,920
to do now is figure out how to get my

00:57:28,480 --> 00:57:30,960
mouse to the point where i can scroll to

00:57:29,920 --> 00:57:35,200
look at the questions

00:57:30,960 --> 00:57:35,200
so bear with me a second uh

00:57:36,640 --> 00:57:42,720
okay so

00:57:40,079 --> 00:57:44,000
suggesting great resources and books i

00:57:42,720 --> 00:57:47,920
want to tell you that uh

00:57:44,000 --> 00:57:51,359
a fellow friend uh a colleague of mine

00:57:47,920 --> 00:57:54,799
vittorio romero and i are working on

00:57:51,359 --> 00:57:57,119
a book to explain in in practice

00:57:54,799 --> 00:57:58,400
it's it's called um embracing modern c

00:57:57,119 --> 00:58:00,640
plus plus safely

00:57:58,400 --> 00:58:03,280
and this would be a great book to learn

00:58:00,640 --> 00:58:05,839
about how to use

00:58:03,280 --> 00:58:06,720
11 and 14 features with seven years of

00:58:05,839 --> 00:58:08,160
hindsight

00:58:06,720 --> 00:58:10,079
how to use them in a way that's

00:58:08,160 --> 00:58:11,920
consistent with the methodologies

00:58:10,079 --> 00:58:15,440
described in this book

00:58:11,920 --> 00:58:17,119
um another one would be as far as

00:58:15,440 --> 00:58:19,359
architecture there's no book that i

00:58:17,119 --> 00:58:21,440
can possibly recommend other than my own

00:58:19,359 --> 00:58:23,280
there are other ones out there

00:58:21,440 --> 00:58:25,200
unfortunately i and i'm not saying

00:58:23,280 --> 00:58:26,319
they're not good unfortunately over the

00:58:25,200 --> 00:58:28,000
last

00:58:26,319 --> 00:58:30,079
year and a half i haven't had a chance

00:58:28,000 --> 00:58:32,079
to read some of them that might be

00:58:30,079 --> 00:58:34,079
totally awesome so i'm not going to

00:58:32,079 --> 00:58:35,839
recommend an architecture book

00:58:34,079 --> 00:58:37,280
other than the one i'm suggesting here

00:58:35,839 --> 00:58:38,240
but please don't take that to mean that

00:58:37,280 --> 00:58:41,200
they don't exist

00:58:38,240 --> 00:58:42,720
and i tend to feel that there's a lot of

00:58:41,200 --> 00:58:45,760
kindred spiritship

00:58:42,720 --> 00:58:47,839
between me and uncle bob so if you see

00:58:45,760 --> 00:58:51,119
anything by robert martin i would

00:58:47,839 --> 00:58:52,240
gravitate to that is your experience

00:58:51,119 --> 00:58:54,640
with what's best

00:58:52,240 --> 00:58:56,079
a way to build reusable components

00:58:54,640 --> 00:58:57,680
design them up front as part of a

00:58:56,079 --> 00:58:59,920
process to build applications

00:58:57,680 --> 00:59:01,680
or fracture the amount of applications

00:58:59,920 --> 00:59:03,119
as reused seems valuable awesome

00:59:01,680 --> 00:59:05,280
question

00:59:03,119 --> 00:59:07,200
it's a matter of both it's kind of like

00:59:05,280 --> 00:59:09,599
do you do test driven development

00:59:07,200 --> 00:59:11,119
i mean the idea is once you know like

00:59:09,599 --> 00:59:13,200
when i started at bloomberg

00:59:11,119 --> 00:59:14,559
i knew from my experience what i would

00:59:13,200 --> 00:59:15,359
need before i could even look at an

00:59:14,559 --> 00:59:17,920
application

00:59:15,359 --> 00:59:19,760
i couldn't design a piece part of an

00:59:17,920 --> 00:59:21,119
application until i had the piece parts

00:59:19,760 --> 00:59:21,680
that i could use to build those piece

00:59:21,119 --> 00:59:23,280
parts

00:59:21,680 --> 00:59:24,880
and even those piece parts needed piece

00:59:23,280 --> 00:59:25,920
parts and so on and so forth below and

00:59:24,880 --> 00:59:29,440
below and below

00:59:25,920 --> 00:59:30,960
so i had to do that and

00:59:29,440 --> 00:59:33,119
the answer is you got to start from

00:59:30,960 --> 00:59:35,200
first principles and if you don't

00:59:33,119 --> 00:59:37,599
you need somebody who at least knows

00:59:35,200 --> 00:59:38,960
what vanilla software looks like

00:59:37,599 --> 00:59:40,880
and you need to write the reusable

00:59:38,960 --> 00:59:42,319
software to build the vanilla software

00:59:40,880 --> 00:59:44,240
before you build the application

00:59:42,319 --> 00:59:45,520
software once you see application

00:59:44,240 --> 00:59:46,960
software in the wild

00:59:45,520 --> 00:59:48,480
obviously you want to see two or three

00:59:46,960 --> 00:59:49,119
uses of what appears to be the same

00:59:48,480 --> 00:59:50,880
thing

00:59:49,119 --> 00:59:52,319
and then you want to say yes i want to

00:59:50,880 --> 00:59:54,559
pare that down to the

00:59:52,319 --> 00:59:56,160
intersection not the union the

00:59:54,559 --> 00:59:58,240
intersection of those things

00:59:56,160 --> 00:59:59,839
be eighty percent of every use don't be

00:59:58,240 --> 01:00:01,280
a hundred percent of all three uses

00:59:59,839 --> 01:00:02,720
because you'll wind up with what we call

01:00:01,280 --> 01:00:04,480
a winnebago class

01:00:02,720 --> 01:00:05,839
or a component that's not usable by

01:00:04,480 --> 01:00:06,720
anyone the flattened green toaster

01:00:05,839 --> 01:00:09,599
toothbrush

01:00:06,720 --> 01:00:11,280
with flag thing don't do that so listen

01:00:09,599 --> 01:00:12,720
i'm out of time i'm going to answer one

01:00:11,280 --> 01:00:13,359
more question i guess and then i'm going

01:00:12,720 --> 01:00:14,640
to

01:00:13,359 --> 01:00:16,880
maybe somehow figure out how to be

01:00:14,640 --> 01:00:18,720
available do you think popular soa

01:00:16,880 --> 01:00:19,520
service oriented architectures fit in

01:00:18,720 --> 01:00:21,760
finally graduate

01:00:19,520 --> 01:00:24,799
granular software architecture so my

01:00:21,760 --> 01:00:26,880
parting answer here is going to be

01:00:24,799 --> 01:00:28,000
that is a different level just like you

01:00:26,880 --> 01:00:30,079
can have a binding like

01:00:28,000 --> 01:00:32,240
javascript to a language like c plus

01:00:30,079 --> 01:00:34,640
plus the javascript level

01:00:32,240 --> 01:00:37,119
depends on the c plus plus level and the

01:00:34,640 --> 01:00:40,160
software oriented architecture level

01:00:37,119 --> 01:00:42,240
is a bunch of services that are built

01:00:40,160 --> 01:00:45,359
out of reusable pieces

01:00:42,240 --> 01:00:46,720
so if you think of an soa as an app and

01:00:45,359 --> 01:00:50,400
you have 10 so

01:00:46,720 --> 01:00:51,119
uh not an s an soa entity so you have a

01:00:50,400 --> 01:00:52,799
service

01:00:51,119 --> 01:00:55,040
think of each service as being an

01:00:52,799 --> 01:00:57,839
application that provides a service

01:00:55,040 --> 01:00:59,920
all of those services could use the same

01:00:57,839 --> 01:01:01,920
um

01:00:59,920 --> 01:01:03,440
software capital code base the nice

01:01:01,920 --> 01:01:05,280
thing about soas is

01:01:03,440 --> 01:01:06,640
the the software capital doesn't have to

01:01:05,280 --> 01:01:08,480
all be in the same language

01:01:06,640 --> 01:01:10,079
you could have a code base in java can

01:01:08,480 --> 01:01:11,520
have a code base in javascript

01:01:10,079 --> 01:01:13,200
you could have a code base in c plus

01:01:11,520 --> 01:01:14,240
plus and the services interact

01:01:13,200 --> 01:01:16,799
regardless

01:01:14,240 --> 01:01:18,480
so that's my answer to that and with

01:01:16,799 --> 01:01:19,760
that i'm going to thank everybody for

01:01:18,480 --> 01:01:21,599
coming to my talk

01:01:19,760 --> 01:01:24,079
and i'm going to find out from my my

01:01:21,599 --> 01:01:27,200
buddy kevin how i can go answer more

01:01:24,079 --> 01:01:29,440
questions and if you want to find me and

01:01:27,200 --> 01:01:31,680
send me email you can find me in

01:01:29,440 --> 01:01:33,680
my email in the standards committee

01:01:31,680 --> 01:01:35,680
because every paper that i've submitted

01:01:33,680 --> 01:01:37,599
has my email on it you can send it to my

01:01:35,680 --> 01:01:38,960
work email so if that's what you want to

01:01:37,599 --> 01:01:39,760
do and you have a question i'll try to

01:01:38,960 --> 01:01:41,920
answer it

01:01:39,760 --> 01:01:44,400
and hopefully i'll get my book out and

01:01:41,920 --> 01:01:46,880
still answer all your questions

01:01:44,400 --> 01:01:53,839
so thanks again for coming and uh i

01:01:46,880 --> 01:01:53,839
guess i'm done

01:02:07,440 --> 01:02:09,520

YouTube URL: https://www.youtube.com/watch?v=d3zMfMC8l5U


