Title: Introducing Microsoft’s New Open Source Fuzzing Platform - Michael Walker & Justin Campbell - CppCon
Publication date: 2020-10-07
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
This native code security talk is a joint presentation by Principals from Windows Security (COSINE) and Microsoft Research. The work by Google and other contributors to the llvm ecosystem on libfuzzer, ASan, and sancov have “shifted left” the field of fuzz testing from the hands of hackers and security auditors directly to CI/CD developers. Rather than waiting for an auditing gate, developers should be able to receive fuzz testing results directly from their build system: quickly, cheaply, and reliably without false positives. To this end, Microsoft is adopting this testing paradigm via continuous cloud-based fuzzing of dedicated test binaries.

Microsoft is currently fuzzing Windows continuously in Azure using libfuzzer and a fuzzing platform developed at Microsoft Research that we are releasing as Open Source at CppCon. Developers continuously building libfuzzer-based test binaries utilizing sanitizers and coverage instrumentation can now launch fuzzing jobs in the cloud with a single command line. This talk will introduce the framework and its capabilities including a live demo. Features include:

• Composable fuzzing workflows: Open Source allows users to onboard their own fuzzers, swap instrumentation, introduce corpora,
• Built-in ensemble fuzzing: By default, fuzzers work as a team that shares strengths, swapping inputs of interest between fuzzing technologies
• Programmatic triage & result deduplication: Get unique flaw cases that always reproduce
• On-demand live-debugging of found crashes: Summon a live debugging session on-demand or from your build system
• Observable & Debug-able: Transparent design allows introspection into every stage
• Detailed telemetry: Easily monitor all your fuzzing from ‘fuzztop’
• Fuzz on Windows & Linux OSes: Multi-platform by design
• Crash reporting notification callbacks: Currently supporting Microsoft Teams
• Code Coverage KPIs: Monitor your progress and motivate testing using code coverage as key metric

---
Justin Campbell is a Principal at Microsoft COSINE whose group is focused on Windows OS security: vulnerability testing at scale, sandboxing and mitigations. Justin was previously VP of Cyber Operations at Novetta and served as CTO at Ocean’s Edge.

Mike Walker is a Senior Director at MSR Special Projects. Prior to joining Microsoft, Mike led DARPA’s Cyber Grand Challenge, a two-year $58M contest to construct & compete the first prototypes of reasoning cyberdefense systems. Mike has worked in a policy advisory role, testifying to the President’s Commission on Cybersecurity, and has played in “the world series of hacking”: DEF CON CTF finals. Mike has coached CTF teams and built CTFs throughout his career.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,240 --> 00:00:11,920
welcome to

00:00:09,120 --> 00:00:14,160
introducing onefuzz i'm justin campbell

00:00:11,920 --> 00:00:17,199
i'm with the microsoft windows

00:00:14,160 --> 00:00:18,240
security team here with mike walker uh

00:00:17,199 --> 00:00:20,240
the leaders

00:00:18,240 --> 00:00:23,920
lead responsible for the leader of the

00:00:20,240 --> 00:00:23,920
group responsible for building one fuzz

00:00:25,119 --> 00:00:29,279
uh today we're gonna introduce uh one

00:00:28,240 --> 00:00:31,439
fuzz itself

00:00:29,279 --> 00:00:32,559
talk about how windows is leveraging it

00:00:31,439 --> 00:00:34,960
to handle the

00:00:32,559 --> 00:00:36,800
security of the scale of windows and

00:00:34,960 --> 00:00:39,120
also concurrently be releasing it open

00:00:36,800 --> 00:00:39,120
source

00:00:40,079 --> 00:00:43,120
so uh spoilers we're going to kind of

00:00:41,680 --> 00:00:44,320
jump to the end of the presentation at

00:00:43,120 --> 00:00:46,239
the beginning

00:00:44,320 --> 00:00:47,360
and describe the vision that we had at

00:00:46,239 --> 00:00:50,079
the beginning of the

00:00:47,360 --> 00:00:51,280
project which is that developers could

00:00:50,079 --> 00:00:52,960
introduce a change

00:00:51,280 --> 00:00:54,640
to their code base be that windows or

00:00:52,960 --> 00:00:57,199
anything else at microsoft

00:00:54,640 --> 00:00:58,480
wait for the build nightly validation

00:00:57,199 --> 00:01:00,239
come in the next morning to an

00:00:58,480 --> 00:01:03,359
automatically delivered message

00:01:00,239 --> 00:01:06,159
with all the information uh necessary

00:01:03,359 --> 00:01:07,840
to reproduce and fix a bug that had been

00:01:06,159 --> 00:01:12,080
automatically detected

00:01:07,840 --> 00:01:13,360
reproduced deduplicated and with uh

00:01:12,080 --> 00:01:15,840
all the technical details that we could

00:01:13,360 --> 00:01:17,759
possibly gather automatically

00:01:15,840 --> 00:01:19,680
and the goal was to get a developer up

00:01:17,759 --> 00:01:22,320
and running in one day

00:01:19,680 --> 00:01:24,799
onboarded into the windows cr system uh

00:01:22,320 --> 00:01:24,799
to keep this

00:01:24,880 --> 00:01:28,560
to make it as simple as possible for

00:01:26,640 --> 00:01:30,000
developers to take advantage of the

00:01:28,560 --> 00:01:31,520
technology that we had built

00:01:30,000 --> 00:01:34,479
and broaden adoption as widely as

00:01:31,520 --> 00:01:36,479
possible so

00:01:34,479 --> 00:01:38,000
dealing with security at the scale of

00:01:36,479 --> 00:01:41,040
windows

00:01:38,000 --> 00:01:41,600
is a tough job uh there are roughly six

00:01:41,040 --> 00:01:45,280
million

00:01:41,600 --> 00:01:49,680
source files uh mostly cc plus but

00:01:45,280 --> 00:01:52,799
a variety of languages 100 prs a day

00:01:49,680 --> 00:01:54,960
that comes out to roughly 19 a minute

00:01:52,799 --> 00:01:56,399
thousands of developers all across the

00:01:54,960 --> 00:02:00,719
globe committing to windows

00:01:56,399 --> 00:02:02,719
every day and 440 official branches

00:02:00,719 --> 00:02:04,240
and an official branch is one that

00:02:02,719 --> 00:02:05,520
receives a nightly build and nightly

00:02:04,240 --> 00:02:07,280
test validation

00:02:05,520 --> 00:02:10,319
and acts as an excellent choke point for

00:02:07,280 --> 00:02:12,720
security teams like mine

00:02:10,319 --> 00:02:14,480
to perform validation steps including

00:02:12,720 --> 00:02:15,440
static analysis dynamic analysis like

00:02:14,480 --> 00:02:17,840
fuzzing

00:02:15,440 --> 00:02:20,160
and so on and so the way we tend to

00:02:17,840 --> 00:02:23,280
think about finding vulnerabilities

00:02:20,160 --> 00:02:24,080
and software flaws in native code is

00:02:23,280 --> 00:02:26,239
part of this

00:02:24,080 --> 00:02:27,760
vulnerability discovery funnel and at

00:02:26,239 --> 00:02:28,480
the top of the funnel the most broadly

00:02:27,760 --> 00:02:31,200
applicable

00:02:28,480 --> 00:02:32,720
uh and cheapest to employ techniques

00:02:31,200 --> 00:02:35,120
like static analysis

00:02:32,720 --> 00:02:36,640
and at the bottom are things like red

00:02:35,120 --> 00:02:39,120
team and so when we think of static

00:02:36,640 --> 00:02:40,720
analysis that's automated code analysis

00:02:39,120 --> 00:02:42,480
uh microsoft has world class static

00:02:40,720 --> 00:02:43,840
analysis built into the compiler and in

00:02:42,480 --> 00:02:46,000
additional tool chains

00:02:43,840 --> 00:02:47,599
and we try to do those things at pr time

00:02:46,000 --> 00:02:48,239
and as early in the developer loop as

00:02:47,599 --> 00:02:50,560
possible

00:02:48,239 --> 00:02:51,599
and we're now experimenting with uh an

00:02:50,560 --> 00:02:54,000
ide

00:02:51,599 --> 00:02:55,040
uh inner loop experience there as well

00:02:54,000 --> 00:02:56,720
we then also like to think about

00:02:55,040 --> 00:02:58,879
scalable fuzzing how do we

00:02:56,720 --> 00:03:00,239
have developers perform automatic

00:02:58,879 --> 00:03:02,239
dynamic testing

00:03:00,239 --> 00:03:03,599
of their code roughly the same time they

00:03:02,239 --> 00:03:05,680
would run their unit tests when things

00:03:03,599 --> 00:03:07,280
are expected to work

00:03:05,680 --> 00:03:09,360
we perform automated attack surface

00:03:07,280 --> 00:03:11,200
analysis so this is churn

00:03:09,360 --> 00:03:13,040
where you have changed code on something

00:03:11,200 --> 00:03:14,879
that's already on the attack surface

00:03:13,040 --> 00:03:16,000
as well as when you're adding new attack

00:03:14,879 --> 00:03:16,879
servers and the best time for us to do

00:03:16,000 --> 00:03:18,879
that is run

00:03:16,879 --> 00:03:21,519
build and integration time there are

00:03:18,879 --> 00:03:22,720
also other techniques dynamic sanitizers

00:03:21,519 --> 00:03:24,239
that we'll be talking a little bit about

00:03:22,720 --> 00:03:25,360
today when we do flight testing and

00:03:24,239 --> 00:03:27,920
flight testing is

00:03:25,360 --> 00:03:30,239
a microsoft term for when we deliver

00:03:27,920 --> 00:03:32,720
early copies to

00:03:30,239 --> 00:03:34,799
early adopters and enthusiasts as part

00:03:32,720 --> 00:03:36,239
of the windows insider program

00:03:34,799 --> 00:03:37,680
and then there's pen testing which is

00:03:36,239 --> 00:03:39,120
predominantly the activity that teams

00:03:37,680 --> 00:03:42,159
like mine do which is

00:03:39,120 --> 00:03:42,879
validating the implementation matches

00:03:42,159 --> 00:03:45,680
the design

00:03:42,879 --> 00:03:47,120
and also looking for possible

00:03:45,680 --> 00:03:50,959
implementation flaws

00:03:47,120 --> 00:03:52,159
be they architectural or code flaws

00:03:50,959 --> 00:03:54,480
and then finally all the way to the

00:03:52,159 --> 00:03:57,760
right are red team and so that's a true

00:03:54,480 --> 00:04:00,239
black box start from binaries reverse

00:03:57,760 --> 00:04:01,760
engineer find a flaw write an exploit

00:04:00,239 --> 00:04:03,599
and use that to help teams and

00:04:01,760 --> 00:04:04,799
stakeholders understand any actualized

00:04:03,599 --> 00:04:05,760
risk

00:04:04,799 --> 00:04:07,200
and so the things we're going to be

00:04:05,760 --> 00:04:08,480
focusing on today are going to be

00:04:07,200 --> 00:04:10,640
scalable fuzzing

00:04:08,480 --> 00:04:12,640
and dynamic sanitizer technology that

00:04:10,640 --> 00:04:16,079
enables scalable fuzzing

00:04:12,640 --> 00:04:17,040
for developers so let's also think about

00:04:16,079 --> 00:04:20,000
the scale

00:04:17,040 --> 00:04:20,639
of issues that come into windows so a

00:04:20,000 --> 00:04:22,160
cve

00:04:20,639 --> 00:04:24,880
if you're not familiar with it is

00:04:22,160 --> 00:04:27,680
essentially just a unique identifier for

00:04:24,880 --> 00:04:28,320
vulnerabilities in published software so

00:04:27,680 --> 00:04:30,080
flaws

00:04:28,320 --> 00:04:32,320
in any piece of software that were never

00:04:30,080 --> 00:04:35,040
shipped to customers won't receive a cd

00:04:32,320 --> 00:04:35,440
and so this chart is showing the number

00:04:35,040 --> 00:04:38,479
of

00:04:35,440 --> 00:04:40,400
issues reported either internally or

00:04:38,479 --> 00:04:43,520
externally

00:04:40,400 --> 00:04:44,240
in one of a shipped windows product and

00:04:43,520 --> 00:04:45,759
you can see

00:04:44,240 --> 00:04:47,199
over the years there's been an

00:04:45,759 --> 00:04:48,880
increasing amount of attention both

00:04:47,199 --> 00:04:51,040
internally with investment

00:04:48,880 --> 00:04:53,759
and externally from external researchers

00:04:51,040 --> 00:04:55,759
with strong incentives to find issues

00:04:53,759 --> 00:04:58,160
and so 2020 is looking pretty good if we

00:04:55,759 --> 00:05:00,320
naively annualize that

00:04:58,160 --> 00:05:03,680
we're looking to be flat or a slight

00:05:00,320 --> 00:05:05,840
uptick from 2019

00:05:03,680 --> 00:05:07,039
roughly 80 percent of these issues are

00:05:05,840 --> 00:05:08,880
common fuzzing

00:05:07,039 --> 00:05:10,080
of course there is some bias in this

00:05:08,880 --> 00:05:11,840
data

00:05:10,080 --> 00:05:13,520
as i mentioned microsoft already

00:05:11,840 --> 00:05:14,320
leverages world class static analysis to

00:05:13,520 --> 00:05:17,440
find issues

00:05:14,320 --> 00:05:19,280
early in the development cycle and so uh

00:05:17,440 --> 00:05:20,639
that tends to filter things out earlier

00:05:19,280 --> 00:05:22,160
in the pipeline and so then they never

00:05:20,639 --> 00:05:24,160
make it to a deliberate product and thus

00:05:22,160 --> 00:05:26,720
never receive a cve

00:05:24,160 --> 00:05:27,759
there's also external finders of course

00:05:26,720 --> 00:05:29,120
don't have source

00:05:27,759 --> 00:05:30,320
don't have private symbols and so

00:05:29,120 --> 00:05:31,919
they're limited in the tools and

00:05:30,320 --> 00:05:33,199
technologies that they can use

00:05:31,919 --> 00:05:35,120
to find vulnerabilities before they

00:05:33,199 --> 00:05:35,919
report them back to us so windows has a

00:05:35,120 --> 00:05:38,000
pretty generous

00:05:35,919 --> 00:05:39,600
bounty program which pays external

00:05:38,000 --> 00:05:41,600
finders and there are a variety of

00:05:39,600 --> 00:05:44,479
incentives in the security industry

00:05:41,600 --> 00:05:46,320
to be the ones to find issues and report

00:05:44,479 --> 00:05:47,919
back to microsoft and that leads to some

00:05:46,320 --> 00:05:50,240
recognition and pr as well

00:05:47,919 --> 00:05:52,000
so all those incentives really lead to a

00:05:50,240 --> 00:05:53,440
massive concentration of effort on

00:05:52,000 --> 00:05:54,800
finding vulnerabilities in these shift

00:05:53,440 --> 00:05:56,319
products

00:05:54,800 --> 00:05:57,840
so if we think about the history of

00:05:56,319 --> 00:05:58,800
fuzzing we can go all the way back to

00:05:57,840 --> 00:06:00,479
the 50s

00:05:58,800 --> 00:06:03,759
and i'll give you just a moment to

00:06:00,479 --> 00:06:06,319
digest this anecdote here

00:06:03,759 --> 00:06:08,080
but what it basically says is that even

00:06:06,319 --> 00:06:10,240
in the days of punch cards the earliest

00:06:08,080 --> 00:06:12,880
developers had figured out that there's

00:06:10,240 --> 00:06:14,880
a real benefit to taking inputs for your

00:06:12,880 --> 00:06:17,039
program that were syntactically valid

00:06:14,880 --> 00:06:18,960
they were well-formed punch cards but

00:06:17,039 --> 00:06:20,240
semantically invalid they were utterly

00:06:18,960 --> 00:06:21,759
they were literally garbage there were

00:06:20,240 --> 00:06:22,960
inputs that were never intended to be

00:06:21,759 --> 00:06:24,319
processed by the program that you're

00:06:22,960 --> 00:06:25,680
feeding them to us inputs

00:06:24,319 --> 00:06:27,520
and so maybe they were the ones who used

00:06:25,680 --> 00:06:30,319
the program code maybe they were

00:06:27,520 --> 00:06:32,319
mistakes from earlier formats etc

00:06:30,319 --> 00:06:34,319
but ultimately when introducing those

00:06:32,319 --> 00:06:36,720
inputs into their programs

00:06:34,319 --> 00:06:38,160
they shook out undesirable behavior and

00:06:36,720 --> 00:06:41,199
it was the earliest form

00:06:38,160 --> 00:06:42,639
of dynamic testing they didn't

00:06:41,199 --> 00:06:44,319
call it fuzzing then but they had

00:06:42,639 --> 00:06:46,479
effectively stumbled upon it

00:06:44,319 --> 00:06:48,400
and then fast forward to 2016. so this

00:06:46,479 --> 00:06:50,720
is a picture from the smithsonian

00:06:48,400 --> 00:06:51,599
where out of a machine that won a darker

00:06:50,720 --> 00:06:55,840
contest

00:06:51,599 --> 00:06:58,960
to automatically find flaws in software

00:06:55,840 --> 00:06:59,360
uh reproduce them and patch them so 70

00:06:58,960 --> 00:07:00,639
years

00:06:59,360 --> 00:07:02,720
has led to a lot of advancements and

00:07:00,639 --> 00:07:04,560
it's still a rapidly shifting field

00:07:02,720 --> 00:07:06,400
and so you know we want to take you or

00:07:04,560 --> 00:07:08,479
we want to invite you to reconsider any

00:07:06,400 --> 00:07:10,000
assumptions you may already have about

00:07:08,479 --> 00:07:12,560
how expensive it is for developers to

00:07:10,000 --> 00:07:16,160
begin fuzzing the costs of those

00:07:12,560 --> 00:07:19,280
and capabilities of fuzzers

00:07:16,160 --> 00:07:21,599
and one of the major advancements

00:07:19,280 --> 00:07:23,440
in modern fuzzing and perhaps in the

00:07:21,599 --> 00:07:26,400
last 10 or 15 years even

00:07:23,440 --> 00:07:26,880
is in coverage guided housing and so

00:07:26,400 --> 00:07:28,880
let's

00:07:26,880 --> 00:07:30,080
start by considering this toy program

00:07:28,880 --> 00:07:32,240
that i have on the left here

00:07:30,080 --> 00:07:33,120
and we have parse function with an array

00:07:32,240 --> 00:07:35,440
of bytes

00:07:33,120 --> 00:07:36,720
and a corresponding size and we can

00:07:35,440 --> 00:07:39,280
assume that size

00:07:36,720 --> 00:07:40,240
is a trustworthy value for the valid

00:07:39,280 --> 00:07:42,960
length

00:07:40,240 --> 00:07:43,280
of buff and then we have a couple simple

00:07:42,960 --> 00:07:45,680
check

00:07:43,280 --> 00:07:47,280
functions there we verify that there are

00:07:45,680 --> 00:07:48,560
at least enough bytes for us to do some

00:07:47,280 --> 00:07:51,599
basic parsing

00:07:48,560 --> 00:07:53,520
and then some early guard checks the

00:07:51,599 --> 00:07:54,000
first night must be x the second must be

00:07:53,520 --> 00:07:56,160
y

00:07:54,000 --> 00:07:57,440
and so on and then we can imagine after

00:07:56,160 --> 00:08:00,080
those initial checks

00:07:57,440 --> 00:08:01,840
we do our actual work and so perhaps we

00:08:00,080 --> 00:08:02,879
allocate some memory we do some further

00:08:01,840 --> 00:08:06,160
parsing

00:08:02,879 --> 00:08:08,080
and then in a refactor or simple typo

00:08:06,160 --> 00:08:10,479
we've introduced a double free and a

00:08:08,080 --> 00:08:12,960
double free is an exceptionally powerful

00:08:10,479 --> 00:08:13,919
vulnerability when it does occur it's

00:08:12,960 --> 00:08:16,160
very likely that

00:08:13,919 --> 00:08:17,680
when it does occur an attacker will be

00:08:16,160 --> 00:08:18,479
able to leverage that for arbitrary code

00:08:17,680 --> 00:08:20,319
execution

00:08:18,479 --> 00:08:22,879
were they able to influence the state of

00:08:20,319 --> 00:08:25,199
the program and that input

00:08:22,879 --> 00:08:26,960
so let's then think about how we fuzz

00:08:25,199 --> 00:08:29,440
this target

00:08:26,960 --> 00:08:31,520
fuzzing is fundamentally executing the

00:08:29,440 --> 00:08:34,560
program and monitoring for crashes or

00:08:31,520 --> 00:08:36,719
other spurious behavior

00:08:34,560 --> 00:08:38,399
and the way we start fuzzing is by with

00:08:36,719 --> 00:08:40,640
coverage guided fuzzing at least

00:08:38,399 --> 00:08:41,919
is by selecting an input from a corpus

00:08:40,640 --> 00:08:44,240
and mutating it

00:08:41,919 --> 00:08:45,760
and corpus is just a term of art for a

00:08:44,240 --> 00:08:47,440
collection of input seeds

00:08:45,760 --> 00:08:49,360
as i mentioned before it's those cement

00:08:47,440 --> 00:08:50,160
uh syntactically valid semantically

00:08:49,360 --> 00:08:51,680
invalid

00:08:50,160 --> 00:08:53,279
or perhaps even semantically valid at

00:08:51,680 --> 00:08:54,480
the point of uh

00:08:53,279 --> 00:08:57,040
at the point where we're starting

00:08:54,480 --> 00:08:58,880
fuzzing and so if this is

00:08:57,040 --> 00:09:01,440
uh you know an image parser perhaps it's

00:08:58,880 --> 00:09:04,480
a well-formed image or perhaps not

00:09:01,440 --> 00:09:06,640
and then mutate it is uh just a

00:09:04,480 --> 00:09:08,000
another again another term of art for

00:09:06,640 --> 00:09:10,240
performing perturbations

00:09:08,000 --> 00:09:11,440
on the input prior to introducing it to

00:09:10,240 --> 00:09:14,240
the program

00:09:11,440 --> 00:09:16,560
um and by that we can mean randomizing

00:09:14,240 --> 00:09:18,000
certain values we can smash in magic by

00:09:16,560 --> 00:09:18,880
values that we know are likely to cause

00:09:18,000 --> 00:09:21,760
problems

00:09:18,880 --> 00:09:23,839
we can invert the values of bits we can

00:09:21,760 --> 00:09:26,800
transpose sections of the input

00:09:23,839 --> 00:09:28,560
really the sky's the limit to the in

00:09:26,800 --> 00:09:30,959
terms of the creativity of the

00:09:28,560 --> 00:09:32,000
fuzzer author as far as what can be done

00:09:30,959 --> 00:09:34,880
as part of mutations

00:09:32,000 --> 00:09:37,440
and there's a huge body of work here in

00:09:34,880 --> 00:09:40,000
academia and in the security industry

00:09:37,440 --> 00:09:41,360
on what makes a more valuable mutation

00:09:40,000 --> 00:09:44,320
and what types of mutations

00:09:41,360 --> 00:09:46,720
are more effective on different types of

00:09:44,320 --> 00:09:48,959
parsers and programs

00:09:46,720 --> 00:09:50,720
so then we need to introduce that input

00:09:48,959 --> 00:09:53,760
so we trigger parsing

00:09:50,720 --> 00:09:55,279
by uh invoking the program

00:09:53,760 --> 00:09:57,040
in such a way that the input that we

00:09:55,279 --> 00:09:59,279
have mutated will reach our

00:09:57,040 --> 00:10:00,320
target function on the left and so the

00:09:59,279 --> 00:10:03,839
buff will then be

00:10:00,320 --> 00:10:05,120
will then contain the value that we have

00:10:03,839 --> 00:10:07,040
here's where the magic starts to happen

00:10:05,120 --> 00:10:09,600
is we measure code covered

00:10:07,040 --> 00:10:10,320
and with uh modern tools and techniques

00:10:09,600 --> 00:10:11,920
uh

00:10:10,320 --> 00:10:13,760
we there's a variety of ways we can do

00:10:11,920 --> 00:10:15,200
this but we can for the moment assume

00:10:13,760 --> 00:10:16,399
that we have compiler introduced

00:10:15,200 --> 00:10:19,360
instrumentation

00:10:16,399 --> 00:10:22,240
to determine which code was hit when a

00:10:19,360 --> 00:10:24,640
new input was generated

00:10:22,240 --> 00:10:26,959
and uh that can then lead to a variety

00:10:24,640 --> 00:10:30,240
of valuable behaviors where

00:10:26,959 --> 00:10:33,279
if we consider passing in uh the word

00:10:30,240 --> 00:10:36,320
test as the value that buff points to

00:10:33,279 --> 00:10:39,440
when it uh does that initial comparison

00:10:36,320 --> 00:10:42,880
against x uh we can hint

00:10:39,440 --> 00:10:44,880
to the runtime that is measuring and

00:10:42,880 --> 00:10:47,920
executing and guiding this buzzing

00:10:44,880 --> 00:10:51,440
that perhaps x is valuable

00:10:47,920 --> 00:10:52,640
to the like as is worthwhile to consider

00:10:51,440 --> 00:10:55,360
and introducing

00:10:52,640 --> 00:10:55,920
somewhere in the input and then such

00:10:55,360 --> 00:11:00,959
later

00:10:55,920 --> 00:11:04,320
might actually be um might able

00:11:00,959 --> 00:11:05,920
function on new coverage

00:11:04,320 --> 00:11:08,560
once we know we have a value that gets

00:11:05,920 --> 00:11:09,600
us past a check we save that input back

00:11:08,560 --> 00:11:11,360
into the corpus

00:11:09,600 --> 00:11:12,959
and it's now a candidate for further

00:11:11,360 --> 00:11:14,240
mutation

00:11:12,959 --> 00:11:16,320
and then we do this hundreds of

00:11:14,240 --> 00:11:17,760
thousands of times per second because so

00:11:16,320 --> 00:11:18,640
much of the work that we're doing is

00:11:17,760 --> 00:11:21,360
fuzzing

00:11:18,640 --> 00:11:23,040
uh is probabilistic we really need those

00:11:21,360 --> 00:11:25,440
large sample counts

00:11:23,040 --> 00:11:27,120
to uh get us the outcomes that we're

00:11:25,440 --> 00:11:30,079
looking for

00:11:27,120 --> 00:11:31,360
and so uh the first piece of feedback

00:11:30,079 --> 00:11:32,800
that we always get when introducing this

00:11:31,360 --> 00:11:35,040
concept to developers is

00:11:32,800 --> 00:11:36,079
well that's great this is a toy function

00:11:35,040 --> 00:11:38,880
um

00:11:36,079 --> 00:11:39,519
my my program is infinitely complex it

00:11:38,880 --> 00:11:40,800
has

00:11:39,519 --> 00:11:42,880
all these edge cases that your thing

00:11:40,800 --> 00:11:45,200
won't handle and

00:11:42,880 --> 00:11:46,640
here are a set of sample inputs from a

00:11:45,200 --> 00:11:48,640
blog

00:11:46,640 --> 00:11:51,200
written by michael celeski who is the

00:11:48,640 --> 00:11:55,120
primary author of afl a broadly adopted

00:11:51,200 --> 00:11:56,480
fuzzer these are automatically generated

00:11:55,120 --> 00:11:59,040
jpegs and so as

00:11:56,480 --> 00:12:00,560
as the contents of this blog outline he

00:11:59,040 --> 00:12:03,440
started with a single

00:12:00,560 --> 00:12:04,560
null byte in his single input in his

00:12:03,440 --> 00:12:05,680
test purpose

00:12:04,560 --> 00:12:07,920
and coverage credit fuzzing in

00:12:05,680 --> 00:12:10,320
combination with afl eventually

00:12:07,920 --> 00:12:12,399
led to automatically generating fully

00:12:10,320 --> 00:12:14,480
parsable and displayable jpegs

00:12:12,399 --> 00:12:15,680
so something as complex and convoluted

00:12:14,480 --> 00:12:18,079
as jpeg

00:12:15,680 --> 00:12:18,959
um can be solved to this type of type of

00:12:18,079 --> 00:12:20,800
process

00:12:18,959 --> 00:12:22,720
it's very likely that the vast majority

00:12:20,800 --> 00:12:24,639
of parsers are targetable by this

00:12:22,720 --> 00:12:26,959
technique as well

00:12:24,639 --> 00:12:28,240
and so coverage guided fuzzing will help

00:12:26,959 --> 00:12:31,360
as i mentioned it will

00:12:28,240 --> 00:12:32,160
help discover magic numbers and guard

00:12:31,360 --> 00:12:34,880
checks

00:12:32,160 --> 00:12:35,600
looking for immediate values but it

00:12:34,880 --> 00:12:38,320
won't

00:12:35,600 --> 00:12:40,000
calculate hashes it won't break crypto

00:12:38,320 --> 00:12:41,680
and it doesn't understand it isn't

00:12:40,000 --> 00:12:42,800
reasoning about the relationship between

00:12:41,680 --> 00:12:46,079
an immediate

00:12:42,800 --> 00:12:47,839
or uh where that goes in the input um

00:12:46,079 --> 00:12:49,600
naive or relatively straightforward

00:12:47,839 --> 00:12:51,200
coverage fuzzing instead relies on that

00:12:49,600 --> 00:12:51,760
probabilistic approach of saying perhaps

00:12:51,200 --> 00:12:54,480
this

00:12:51,760 --> 00:12:55,839
immediate is valuable and perhaps we can

00:12:54,480 --> 00:12:56,800
wait for it to land in the correct

00:12:55,839 --> 00:12:59,040
position

00:12:56,800 --> 00:13:00,399
um and in reality this actually gets us

00:12:59,040 --> 00:13:02,560
very solid results that we'll talk a

00:13:00,399 --> 00:13:04,839
little bit about later

00:13:02,560 --> 00:13:06,399
so what is it like to actually harness a

00:13:04,839 --> 00:13:10,000
target for

00:13:06,399 --> 00:13:11,680
fuzzing with lip fuzzer uh so lip fuzzer

00:13:10,000 --> 00:13:14,240
isn't it is a coverage guided

00:13:11,680 --> 00:13:15,279
fuzzer written by google and introduced

00:13:14,240 --> 00:13:17,600
as part of the lvm

00:13:15,279 --> 00:13:19,279
project and is an incredibly valuable

00:13:17,600 --> 00:13:21,279
shift in paradigm

00:13:19,279 --> 00:13:22,880
where you can think of lube fuzzer as a

00:13:21,279 --> 00:13:24,000
unit test framework with a fixed

00:13:22,880 --> 00:13:25,600
contract

00:13:24,000 --> 00:13:27,360
and its contract looks exactly like that

00:13:25,600 --> 00:13:29,120
parse function that i showed earlier

00:13:27,360 --> 00:13:30,560
there's an array of bytes with a

00:13:29,120 --> 00:13:32,480
corresponding size and the corresponding

00:13:30,560 --> 00:13:35,600
size can be assumed to be trustworthy

00:13:32,480 --> 00:13:38,160
and your job as a test author

00:13:35,600 --> 00:13:39,600
is to introduce that uh generated or

00:13:38,160 --> 00:13:41,279
mutated input

00:13:39,600 --> 00:13:42,959
into your program and so here's a real

00:13:41,279 --> 00:13:45,760
world example where we're

00:13:42,959 --> 00:13:46,800
fuzzing the x509 parser that's used in

00:13:45,760 --> 00:13:49,120
windows

00:13:46,800 --> 00:13:50,720
and we're taking the data and we're

00:13:49,120 --> 00:13:51,519
specifying a number of configuration

00:13:50,720 --> 00:13:53,199
parameters

00:13:51,519 --> 00:13:56,000
which in this case is saying please

00:13:53,199 --> 00:13:57,600
interpret my data as an x599 certificate

00:13:56,000 --> 00:13:59,920
and then we're introducing it to the

00:13:57,600 --> 00:14:01,040
target and then on line 17 through 19

00:13:59,920 --> 00:14:02,720
there you can see we're doing some

00:14:01,040 --> 00:14:04,320
cleanup so if this was successful enough

00:14:02,720 --> 00:14:05,760
to allocate resources

00:14:04,320 --> 00:14:08,160
uh be sure to clean those up so that we

00:14:05,760 --> 00:14:10,320
can then uh continue and not

00:14:08,160 --> 00:14:11,839
exhaust memory or exhaust other

00:14:10,320 --> 00:14:15,040
undependent resources

00:14:11,839 --> 00:14:16,240
and so this is it this is a 20 line test

00:14:15,040 --> 00:14:18,959
target that's actually

00:14:16,240 --> 00:14:19,839
in use in production today and in terms

00:14:18,959 --> 00:14:22,000
of

00:14:19,839 --> 00:14:23,360
building and what it looks like to

00:14:22,000 --> 00:14:25,040
modify your build system

00:14:23,360 --> 00:14:27,199
you can see what we've done here with an

00:14:25,040 --> 00:14:29,600
edited sources

00:14:27,199 --> 00:14:31,120
used with build.exe we've enabled

00:14:29,600 --> 00:14:33,920
address sanitizer

00:14:31,120 --> 00:14:35,199
and we've included the live fuzzer lid

00:14:33,920 --> 00:14:36,560
that is responsible for kind of

00:14:35,199 --> 00:14:37,600
implementing the driver and performing

00:14:36,560 --> 00:14:40,560
the callback

00:14:37,600 --> 00:14:42,480
that we've implemented here and so uh

00:14:40,560 --> 00:14:43,120
this gets us a long way towards that one

00:14:42,480 --> 00:14:45,360
day

00:14:43,120 --> 00:14:47,199
of developer time goal to get started

00:14:45,360 --> 00:14:49,839
fuzzing

00:14:47,199 --> 00:14:50,560
if we look at another case study we

00:14:49,839 --> 00:14:52,639
actually

00:14:50,560 --> 00:14:53,760
also perform this technique on a variety

00:14:52,639 --> 00:14:56,320
of parsers

00:14:53,760 --> 00:14:57,600
in dhcp and so dhcp obviously has a

00:14:56,320 --> 00:15:00,079
network protocol

00:14:57,600 --> 00:15:01,440
and the windows implementation is native

00:15:00,079 --> 00:15:03,199
code and it's actually a

00:15:01,440 --> 00:15:05,199
variety of self-contained parsers and so

00:15:03,199 --> 00:15:06,720
it's almost an ideal target

00:15:05,199 --> 00:15:08,320
and with coverage credited fuzzing with

00:15:06,720 --> 00:15:11,440
no seed corpus

00:15:08,320 --> 00:15:13,360
like no human provided inputs uh with

00:15:11,440 --> 00:15:16,560
200 000 iterations per second

00:15:13,360 --> 00:15:18,240
in roughly 30 seconds we exhausted

00:15:16,560 --> 00:15:19,680
uh or we reached 72 percent code

00:15:18,240 --> 00:15:22,639
coverage and

00:15:19,680 --> 00:15:24,639
uh roughly stabilized there that uh this

00:15:22,639 --> 00:15:27,120
work actually then resulted in four

00:15:24,639 --> 00:15:29,920
publicly documented vulnerabilities and

00:15:27,120 --> 00:15:33,120
two of those were remote code execution

00:15:29,920 --> 00:15:35,279
um and so uh the

00:15:33,120 --> 00:15:36,800
uh the proof is in the footing as we say

00:15:35,279 --> 00:15:38,480
like actually then

00:15:36,800 --> 00:15:40,480
uh spending the less than a day

00:15:38,480 --> 00:15:42,320
necessary to harness this target

00:15:40,480 --> 00:15:44,399
start it running get this performance

00:15:42,320 --> 00:15:46,399
and now there is a durable artifact that

00:15:44,399 --> 00:15:48,480
can be run every time unit tests are run

00:15:46,399 --> 00:15:50,240
and performs automatic regression

00:15:48,480 --> 00:15:51,040
testing and also prevents future

00:15:50,240 --> 00:15:54,240
vulnerabilities from

00:15:51,040 --> 00:15:58,000
reaching customers

00:15:54,240 --> 00:16:00,639
so let's take a slightly broader lens

00:15:58,000 --> 00:16:01,040
and think about how we got to where we

00:16:00,639 --> 00:16:03,600
are

00:16:01,040 --> 00:16:04,639
with compiler inserted instrumentation

00:16:03,600 --> 00:16:06,480
and fuzzing

00:16:04,639 --> 00:16:09,120
the the way things the way most security

00:16:06,480 --> 00:16:09,839
teams work today is we employ security

00:16:09,120 --> 00:16:12,079
analysts

00:16:09,839 --> 00:16:14,000
to target the production binaries so the

00:16:12,079 --> 00:16:16,560
same binaries that ship to customers

00:16:14,000 --> 00:16:18,160
and run on customer systems every day

00:16:16,560 --> 00:16:21,440
and our goal

00:16:18,160 --> 00:16:22,000
is to reach this target where developers

00:16:21,440 --> 00:16:25,199
can write

00:16:22,000 --> 00:16:26,800
their own unit test like binaries

00:16:25,199 --> 00:16:28,800
that are born to fuss they have a single

00:16:26,800 --> 00:16:30,079
purpose of performing fuzzing

00:16:28,800 --> 00:16:31,839
and perhaps they share code in common

00:16:30,079 --> 00:16:33,120
but not necessarily the final artifact

00:16:31,839 --> 00:16:35,600
binaries

00:16:33,120 --> 00:16:37,279
the problem comes in when we then act

00:16:35,600 --> 00:16:39,440
when we then consider all the problems

00:16:37,279 --> 00:16:40,639
that a security analyst has to solve

00:16:39,440 --> 00:16:42,320
they have to think about how they're

00:16:40,639 --> 00:16:43,920
going to gather coverage if we don't

00:16:42,320 --> 00:16:45,120
have the source we're not able to modify

00:16:43,920 --> 00:16:45,920
the source we're not able to recompile

00:16:45,120 --> 00:16:47,680
the source

00:16:45,920 --> 00:16:48,959
perhaps we're doing things like dynamic

00:16:47,680 --> 00:16:51,600
binary instrumentation

00:16:48,959 --> 00:16:53,519
using pin tool or dynamo rio maybe we're

00:16:51,600 --> 00:16:56,160
using a platform specific debugger

00:16:53,519 --> 00:16:57,600
or the platform's debugging apis to

00:16:56,160 --> 00:16:59,279
perform that instrumentation

00:16:57,600 --> 00:17:01,279
maybe we're using ph heap or electric

00:16:59,279 --> 00:17:02,480
fence to catch uh out of bounds

00:17:01,279 --> 00:17:05,839
overwrites and reads

00:17:02,480 --> 00:17:07,919
etc and so there are all these uh 80

00:17:05,839 --> 00:17:09,280
solutions that the security analyst is

00:17:07,919 --> 00:17:12,160
expected to

00:17:09,280 --> 00:17:14,079
be aware of piece together select the

00:17:12,160 --> 00:17:17,199
appropriate combination thereof

00:17:14,079 --> 00:17:19,760
write glue or write new tools

00:17:17,199 --> 00:17:21,600
when existing tools don't exist and this

00:17:19,760 --> 00:17:23,280
is unrealistic to expect developers to

00:17:21,600 --> 00:17:24,480
also become subject matter experts in

00:17:23,280 --> 00:17:27,439
the whole domain of

00:17:24,480 --> 00:17:28,960
security and security testing in

00:17:27,439 --> 00:17:30,480
addition to whatever they are already a

00:17:28,960 --> 00:17:33,120
subject matter experience

00:17:30,480 --> 00:17:33,679
and so instead we look to compile in

00:17:33,120 --> 00:17:35,440
tools

00:17:33,679 --> 00:17:37,760
and so a variety of these are again

00:17:35,440 --> 00:17:41,200
tools built by pioneered by google

00:17:37,760 --> 00:17:43,280
and now uh some of them available uh

00:17:41,200 --> 00:17:44,960
as experimental features in the

00:17:43,280 --> 00:17:46,320
microsoft sql software toolchain

00:17:44,960 --> 00:17:48,320
and so for coverage we look at things

00:17:46,320 --> 00:17:49,440
like sanitizer coverage for boundary

00:17:48,320 --> 00:17:52,720
detection we look at

00:17:49,440 --> 00:17:55,760
we look at things like address sanitizer

00:17:52,720 --> 00:17:58,559
and other things we completely avoid

00:17:55,760 --> 00:17:59,200
like having to introduce io by making

00:17:58,559 --> 00:18:02,480
that a

00:17:59,200 --> 00:18:05,200
a part of the contract

00:18:02,480 --> 00:18:07,200
and really the goal here is to pivot

00:18:05,200 --> 00:18:09,280
from the hacker bolt-on paradigm

00:18:07,200 --> 00:18:10,640
to introducing developer tools we need

00:18:09,280 --> 00:18:12,080
to reach developers where they're

00:18:10,640 --> 00:18:14,160
already working

00:18:12,080 --> 00:18:15,520
in tools they're already familiar with

00:18:14,160 --> 00:18:17,760
and in paradigms in which they're

00:18:15,520 --> 00:18:20,160
already familiar and operating

00:18:17,760 --> 00:18:22,080
and through all of this then we can rely

00:18:20,160 --> 00:18:23,360
on the security analysts to provide

00:18:22,080 --> 00:18:25,200
fuzzing expertise

00:18:23,360 --> 00:18:27,120
they can write new fuzzers they can

00:18:25,200 --> 00:18:29,600
ensure that they reproduce correctly

00:18:27,120 --> 00:18:31,200
they can assist with regressions and

00:18:29,600 --> 00:18:33,360
automatic regression testing

00:18:31,200 --> 00:18:35,120
and introduce and manage the corporate

00:18:33,360 --> 00:18:38,640
responsible for

00:18:35,120 --> 00:18:41,880
making widely available parsers fuzzable

00:18:38,640 --> 00:18:43,120
and so once we've got self-contained uh

00:18:41,880 --> 00:18:45,440
developer-created

00:18:43,120 --> 00:18:46,320
fuzzing binaries like this we then need

00:18:45,440 --> 00:18:48,559
to think about

00:18:46,320 --> 00:18:49,440
how we fuzz them at scale and for that

00:18:48,559 --> 00:18:51,679
i'm gonna hand it off

00:18:49,440 --> 00:18:52,559
to mike walker who's gonna talk you walk

00:18:51,679 --> 00:18:55,120
you through

00:18:52,559 --> 00:18:57,840
more of one fuzz and how we perform

00:18:55,120 --> 00:18:57,840
fuzzing at scale

00:19:02,640 --> 00:19:06,080
excuse me thank you justin my name is

00:19:05,039 --> 00:19:08,160
mike walker

00:19:06,080 --> 00:19:09,120
i'm a senior director at microsoft

00:19:08,160 --> 00:19:11,840
research

00:19:09,120 --> 00:19:13,120
um thanks to cppcon for uh inviting us

00:19:11,840 --> 00:19:15,039
to be here today

00:19:13,120 --> 00:19:16,480
today's talk is about the open source

00:19:15,039 --> 00:19:17,120
onefuzz framework that we're releasing

00:19:16,480 --> 00:19:18,480
today

00:19:17,120 --> 00:19:20,160
and that is a framework that was

00:19:18,480 --> 00:19:21,840
developed through listening

00:19:20,160 --> 00:19:23,600
uh listening to teams that develop

00:19:21,840 --> 00:19:24,000
products around microsoft like justin's

00:19:23,600 --> 00:19:26,640
team

00:19:24,000 --> 00:19:28,240
and others uh to developers and fuzzing

00:19:26,640 --> 00:19:29,440
authors at fuzz con the fuzzing

00:19:28,240 --> 00:19:30,960
conference this year

00:19:29,440 --> 00:19:32,320
to the customers of the microsoft risk

00:19:30,960 --> 00:19:33,360
detection service that we've operated

00:19:32,320 --> 00:19:35,360
for years

00:19:33,360 --> 00:19:37,520
uh and both listening to security

00:19:35,360 --> 00:19:39,679
engineering and developers

00:19:37,520 --> 00:19:42,160
and the consensus story that we came up

00:19:39,679 --> 00:19:44,240
with uh through all these conversations

00:19:42,160 --> 00:19:46,080
was that everybody wants fuzzing and

00:19:44,240 --> 00:19:47,600
everybody understands the reliability

00:19:46,080 --> 00:19:49,600
and security upside

00:19:47,600 --> 00:19:51,440
but everyone also agrees that fuzzing as

00:19:49,600 --> 00:19:52,320
it stands and as it's been traditionally

00:19:51,440 --> 00:19:54,480
done

00:19:52,320 --> 00:19:56,559
is hard expensive to use and it's

00:19:54,480 --> 00:19:58,160
expensive in terms of engineering

00:19:56,559 --> 00:20:00,880
engineering work that could be better

00:19:58,160 --> 00:20:02,880
spent developing new product features

00:20:00,880 --> 00:20:05,039
so i want to dive deeper into the

00:20:02,880 --> 00:20:08,320
revolution that justin was describing

00:20:05,039 --> 00:20:10,640
through an example this is our

00:20:08,320 --> 00:20:11,840
simple image resizing application that

00:20:10,640 --> 00:20:13,760
we're going to use to talk about

00:20:11,840 --> 00:20:14,960
fuzz testing and the compiler testing

00:20:13,760 --> 00:20:16,799
revolution

00:20:14,960 --> 00:20:18,320
um and the job of this service is to

00:20:16,799 --> 00:20:20,080
resize images

00:20:18,320 --> 00:20:22,320
its control flow is very simple it takes

00:20:20,080 --> 00:20:25,440
untrusted inputs from the network

00:20:22,320 --> 00:20:28,400
and it recognizes them as jpegs or pngs

00:20:25,440 --> 00:20:28,640
and then it has to de-marshal those into

00:20:28,400 --> 00:20:31,600
an

00:20:28,640 --> 00:20:33,200
rpc state machine so jpegs and their

00:20:31,600 --> 00:20:35,760
associated metadata go one way

00:20:33,200 --> 00:20:37,280
pngs go the other inside that state

00:20:35,760 --> 00:20:39,600
machine

00:20:37,280 --> 00:20:42,000
is the work of converting jpegs or pngs

00:20:39,600 --> 00:20:44,400
into an intermediary image format

00:20:42,000 --> 00:20:45,440
and then resizing and then

00:20:44,400 --> 00:20:47,360
re-serializing

00:20:45,440 --> 00:20:48,799
in the user's requested format and

00:20:47,360 --> 00:20:50,480
sending it back

00:20:48,799 --> 00:20:52,720
now if i'm a security engineering team

00:20:50,480 --> 00:20:54,320
like justin's

00:20:52,720 --> 00:20:55,760
then there's a significant amount of

00:20:54,320 --> 00:20:57,360
work to do to be able to test this

00:20:55,760 --> 00:20:59,039
network service because it is a network

00:20:57,360 --> 00:21:01,039
service it is stateful

00:20:59,039 --> 00:21:02,559
that means that it has to be fast and

00:21:01,039 --> 00:21:03,840
performant for the authorized users

00:21:02,559 --> 00:21:05,200
they're going to use it in high volume

00:21:03,840 --> 00:21:06,799
every day

00:21:05,200 --> 00:21:08,480
and it also needs to be resistant to

00:21:06,799 --> 00:21:09,200
black hackers who have vulnerability

00:21:08,480 --> 00:21:11,200
research

00:21:09,200 --> 00:21:12,720
capabilities so that means that we have

00:21:11,200 --> 00:21:14,240
to be able to test it better than they

00:21:12,720 --> 00:21:16,159
can

00:21:14,240 --> 00:21:18,159
and my first problem is that i have to

00:21:16,159 --> 00:21:18,559
develop a networked pseudo client that

00:21:18,159 --> 00:21:21,280
tracks

00:21:18,559 --> 00:21:21,760
every feature in this service to get

00:21:21,280 --> 00:21:22,960
inputs

00:21:21,760 --> 00:21:24,640
into a network service that is a

00:21:22,960 --> 00:21:25,200
production binary i need to be able to

00:21:24,640 --> 00:21:26,720
generate

00:21:25,200 --> 00:21:28,400
high volume high speed inputs into the

00:21:26,720 --> 00:21:30,559
service and then orchestrate

00:21:28,400 --> 00:21:32,640
the correlation of the effect with the

00:21:30,559 --> 00:21:33,840
input that's a significant amount of

00:21:32,640 --> 00:21:35,280
work

00:21:33,840 --> 00:21:37,440
the next thing that i have to be able to

00:21:35,280 --> 00:21:37,440
do

00:21:38,000 --> 00:21:45,840
is advance my slides

00:21:48,240 --> 00:21:52,559
well um technical difficulties here we

00:21:51,919 --> 00:21:54,559
are

00:21:52,559 --> 00:21:55,919
um the second thing that i have to be

00:21:54,559 --> 00:21:58,000
able to do is

00:21:55,919 --> 00:21:59,440
instrument production binaries so

00:21:58,000 --> 00:22:00,159
production binaries are designed for

00:21:59,440 --> 00:22:03,120
speed

00:22:00,159 --> 00:22:04,720
not instrumentation um and that means

00:22:03,120 --> 00:22:06,480
that i have to bolt on coverage often

00:22:04,720 --> 00:22:08,320
through a dynamic binary instrumentation

00:22:06,480 --> 00:22:11,679
framework like dynamo rio

00:22:08,320 --> 00:22:13,520
or intel's pin and i have to bolt on uh

00:22:11,679 --> 00:22:15,200
crash detection either through parsing

00:22:13,520 --> 00:22:16,080
cores or using a debugger

00:22:15,200 --> 00:22:18,159
and then i have to be able to

00:22:16,080 --> 00:22:19,520
differentiate real crashes and

00:22:18,159 --> 00:22:20,799
investigate real crashes and

00:22:19,520 --> 00:22:27,840
differentiate them from

00:22:20,799 --> 00:22:27,840
instrumentation induced crashes

00:22:29,039 --> 00:22:32,400
uh so the net result here is in our

00:22:31,600 --> 00:22:34,799
example

00:22:32,400 --> 00:22:36,080
uh security engineering has full-time

00:22:34,799 --> 00:22:38,960
care and feeding of this

00:22:36,080 --> 00:22:40,880
testing framework um they have to write

00:22:38,960 --> 00:22:42,080
probably two clients one for the rpc

00:22:40,880 --> 00:22:45,039
state machine

00:22:42,080 --> 00:22:46,640
um one for the network service uh

00:22:45,039 --> 00:22:49,760
they're going to be doing a lot of

00:22:46,640 --> 00:22:50,240
uh investigation of each crash uh

00:22:49,760 --> 00:22:51,679
there's

00:22:50,240 --> 00:22:53,679
probably going to be per app

00:22:51,679 --> 00:22:56,799
enlightenment using the dynamic binary

00:22:53,679 --> 00:22:56,799
instrumentation framework

00:22:56,960 --> 00:23:01,039
and reachability issues are going to

00:22:59,280 --> 00:23:05,200
over test the recognizer

00:23:01,039 --> 00:23:05,200
and under test the serialize and send

00:23:06,840 --> 00:23:09,840
step

00:23:11,840 --> 00:23:15,760
so what we're looking at here is a set

00:23:14,159 --> 00:23:17,120
of homework not just homework for the

00:23:15,760 --> 00:23:20,880
software under test

00:23:17,120 --> 00:23:22,480
but homework for the testing apparatus

00:23:20,880 --> 00:23:24,159
security engineering teams are tasked

00:23:22,480 --> 00:23:25,840
with building high performance compute

00:23:24,159 --> 00:23:27,679
root causing crashes

00:23:25,840 --> 00:23:29,840
uh testing every single input for

00:23:27,679 --> 00:23:32,640
reproducibility

00:23:29,840 --> 00:23:33,120
um uniqueing crashes and figuring out

00:23:32,640 --> 00:23:34,799
whether

00:23:33,120 --> 00:23:36,480
all these crashes fall under one bug or

00:23:34,799 --> 00:23:38,559
different bugs and then there's the

00:23:36,480 --> 00:23:39,200
whole job of fuzzer selection corpora

00:23:38,559 --> 00:23:43,200
updates

00:23:39,200 --> 00:23:45,760
the rest so

00:23:43,200 --> 00:23:47,440
let's take this legacy application and

00:23:45,760 --> 00:23:49,279
rebuild it again with the compiler

00:23:47,440 --> 00:23:51,279
fuzzing regimen that

00:23:49,279 --> 00:23:53,279
justin was describing we're going to

00:23:51,279 --> 00:23:54,720
take each component

00:23:53,279 --> 00:23:57,440
and we're going to harness it with the

00:23:54,720 --> 00:24:00,400
llvm test one input

00:23:57,440 --> 00:24:00,400
function prototype

00:24:02,840 --> 00:24:08,559
and for each component

00:24:05,919 --> 00:24:08,960
we're going to have a unit test that is

00:24:08,559 --> 00:24:11,919
cooked

00:24:08,960 --> 00:24:13,360
into the build system and this unit test

00:24:11,919 --> 00:24:16,159
is going to contain

00:24:13,360 --> 00:24:17,679
the trifecta coverage sanitizers and

00:24:16,159 --> 00:24:20,640
fuzzing technology

00:24:17,679 --> 00:24:22,080
all built in and the goal here is

00:24:20,640 --> 00:24:24,400
automated targets that you can build

00:24:22,080 --> 00:24:25,279
once and compile forever and vanish into

00:24:24,400 --> 00:24:30,000
the build system

00:24:25,279 --> 00:24:30,000
kind of reducing that homework lift so

00:24:30,320 --> 00:24:34,720
the compiler support that we've already

00:24:32,240 --> 00:24:37,200
covered uh is half of the story

00:24:34,720 --> 00:24:38,960
and the other half is cloud fuzzing the

00:24:37,200 --> 00:24:40,400
job management to be able to do testing

00:24:38,960 --> 00:24:42,480
in bulk with a

00:24:40,400 --> 00:24:44,000
massive number of test cases that uh

00:24:42,480 --> 00:24:46,559
justin mentioned

00:24:44,000 --> 00:24:47,200
crash deduplication being able to check

00:24:46,559 --> 00:24:49,600
uh and

00:24:47,200 --> 00:24:50,640
and manage the uh massive number of

00:24:49,600 --> 00:24:52,080
crashes you may get

00:24:50,640 --> 00:24:54,240
making sure they reproduce making sure

00:24:52,080 --> 00:24:55,440
they're unique handling the onboarding

00:24:54,240 --> 00:24:57,279
of fuzzers

00:24:55,440 --> 00:24:58,960
and and using telemetry to get

00:24:57,279 --> 00:25:01,919
notifications

00:24:58,960 --> 00:25:02,640
so let's let's try this out on the

00:25:01,919 --> 00:25:05,279
command line

00:25:02,640 --> 00:25:06,960
take a look at what it looks like we're

00:25:05,279 --> 00:25:08,799
going to start again with that simple

00:25:06,960 --> 00:25:12,559
test program

00:25:08,799 --> 00:25:13,360
that is uh checking the input for x y

00:25:12,559 --> 00:25:14,799
and z

00:25:13,360 --> 00:25:16,559
but afterwards we're going to use the

00:25:14,799 --> 00:25:20,559
next byte to select

00:25:16,559 --> 00:25:22,080
a different critically important memory

00:25:20,559 --> 00:25:23,679
corruption flaw and this particular

00:25:22,080 --> 00:25:26,000
sample program

00:25:23,679 --> 00:25:26,720
on its fourth byte will select from one

00:25:26,000 --> 00:25:29,200
of eight

00:25:26,720 --> 00:25:30,400
different harmful memory corruption uh

00:25:29,200 --> 00:25:32,559
capabilities so

00:25:30,400 --> 00:25:35,360
if we fuzz this thoroughly we should get

00:25:32,559 --> 00:25:38,480
at least eight unique bugs

00:25:35,360 --> 00:25:40,559
and uh fuzzing

00:25:38,480 --> 00:25:42,000
um with modern coverage guided buzzers

00:25:40,559 --> 00:25:43,200
is useful just on the command line

00:25:42,000 --> 00:25:45,279
that's what it takes to build one of

00:25:43,200 --> 00:25:46,960
these unit test binaries cooks into the

00:25:45,279 --> 00:25:48,559
build system very easily

00:25:46,960 --> 00:25:50,000
and that's how long it takes for a

00:25:48,559 --> 00:25:51,760
modern coverage guided buzzer to

00:25:50,000 --> 00:25:54,799
determine that xyz

00:25:51,760 --> 00:25:56,000
is the correct uh the correct input for

00:25:54,799 --> 00:25:59,360
this program

00:25:56,000 --> 00:26:01,679
and it starts generating crashes and

00:25:59,360 --> 00:26:03,200
it's completely feasible for a developer

00:26:01,679 --> 00:26:04,799
to test this type of binary on their

00:26:03,200 --> 00:26:06,640
local workstation

00:26:04,799 --> 00:26:10,240
to harness one of these binaries into a

00:26:06,640 --> 00:26:12,159
while loop start generating crashes and

00:26:10,240 --> 00:26:14,159
start generating a series of faulting

00:26:12,159 --> 00:26:15,120
inputs you can see the crash and then

00:26:14,159 --> 00:26:17,279
it's hash

00:26:15,120 --> 00:26:19,360
generated on the command line the first

00:26:17,279 --> 00:26:23,520
one generated was

00:26:19,360 --> 00:26:26,480
x y z 0. now as useful as this is

00:26:23,520 --> 00:26:28,240
with real software this needs to scale

00:26:26,480 --> 00:26:29,760
this needs to be a large process with

00:26:28,240 --> 00:26:31,600
lots of compute behind it

00:26:29,760 --> 00:26:33,520
and there's a lot of data orchestration

00:26:31,600 --> 00:26:36,559
behind the scenes

00:26:33,520 --> 00:26:39,760
so to solve the problem of how to take

00:26:36,559 --> 00:26:41,440
these unit test binaries uh attach them

00:26:39,760 --> 00:26:42,320
to multiple fuzzing technologies get

00:26:41,440 --> 00:26:44,640
them into the cloud

00:26:42,320 --> 00:26:46,159
and and handle all the data flows and

00:26:44,640 --> 00:26:48,400
crash management

00:26:46,159 --> 00:26:50,480
we developed one fuzz that's how far the

00:26:48,400 --> 00:26:52,000
buzzer gets on a local workstation

00:26:50,480 --> 00:26:53,600
we can use one fuzz to send it to the

00:26:52,000 --> 00:26:57,279
cloud

00:26:53,600 --> 00:26:58,559
so um i want to talk today about the one

00:26:57,279 --> 00:27:02,000
fuzz framework

00:26:58,559 --> 00:27:05,039
it is open source and it is self-hosted

00:27:02,000 --> 00:27:06,159
so uh mit license this is here for you

00:27:05,039 --> 00:27:08,559
to run uh

00:27:06,159 --> 00:27:09,679
in your enterprise and to build and

00:27:08,559 --> 00:27:13,039
remix

00:27:09,679 --> 00:27:15,760
um and change and

00:27:13,039 --> 00:27:17,039
it's also self-hosted that means it runs

00:27:15,760 --> 00:27:20,480
in your subscription

00:27:17,039 --> 00:27:21,840
so your jobs uh your there is no hosted

00:27:20,480 --> 00:27:23,520
buzzing service here

00:27:21,840 --> 00:27:25,039
all your jobs and your data live in your

00:27:23,520 --> 00:27:27,360
subscription

00:27:25,039 --> 00:27:28,640
and deployment of this framework does

00:27:27,360 --> 00:27:32,159
not take

00:27:28,640 --> 00:27:33,919
uh an azure expert uh the readme that's

00:27:32,159 --> 00:27:37,120
linked on this slide

00:27:33,919 --> 00:27:41,120
will allow you to if if you have access

00:27:37,120 --> 00:27:41,120
to the azcli and access to azure

00:27:44,640 --> 00:27:48,480
start this up in an afternoon and have a

00:27:46,799 --> 00:27:52,240
fuzzing instance that can scale to a

00:27:48,480 --> 00:27:52,240
company as large as microsoft

00:27:54,640 --> 00:27:58,880
so i want to talk again about that

00:27:56,960 --> 00:28:00,240
listening phase of listening to security

00:27:58,880 --> 00:28:01,200
engineering teams listening to

00:28:00,240 --> 00:28:03,360
developers

00:28:01,200 --> 00:28:05,039
and talk about how the one fuzz

00:28:03,360 --> 00:28:06,480
framework attempts to solve

00:28:05,039 --> 00:28:08,559
the very different requirements of these

00:28:06,480 --> 00:28:10,080
two different teams so as we talked to

00:28:08,559 --> 00:28:11,600
security engineering teams around the

00:28:10,080 --> 00:28:13,679
company and around the world

00:28:11,600 --> 00:28:14,880
what we found was that we would hear

00:28:13,679 --> 00:28:16,559
feature requests

00:28:14,880 --> 00:28:17,919
but they weren't feature requests they

00:28:16,559 --> 00:28:19,520
were complete blockers

00:28:17,919 --> 00:28:21,360
security engineering teams often had

00:28:19,520 --> 00:28:22,799
unique requirements where if they

00:28:21,360 --> 00:28:24,240
couldn't meet that requirement they

00:28:22,799 --> 00:28:25,679
would abandon the entire fuzzing

00:28:24,240 --> 00:28:26,559
technology if they couldn't make the

00:28:25,679 --> 00:28:29,440
change

00:28:26,559 --> 00:28:30,960
those requirements went from windows and

00:28:29,440 --> 00:28:32,559
other operating system dependent

00:28:30,960 --> 00:28:34,240
products that needed to be able to take

00:28:32,559 --> 00:28:35,919
daily builds of their operating system

00:28:34,240 --> 00:28:36,559
and fuzz on that daily build so they

00:28:35,919 --> 00:28:38,480
needed

00:28:36,559 --> 00:28:40,159
complete custom operating system support

00:28:38,480 --> 00:28:41,679
that was cross-platform we have this

00:28:40,159 --> 00:28:42,799
problem on linux we have this problem on

00:28:41,679 --> 00:28:45,679
windows

00:28:42,799 --> 00:28:48,080
there were many teams that needed their

00:28:45,679 --> 00:28:49,440
own custom crash analysis tasks

00:28:48,080 --> 00:28:50,960
and they needed to be able to plug in

00:28:49,440 --> 00:28:51,520
their own crash analyzer because there

00:28:50,960 --> 00:28:53,279
was

00:28:51,520 --> 00:28:56,880
rich metadata associated with their

00:28:53,279 --> 00:28:59,120
program uh that needed custom analysis

00:28:56,880 --> 00:29:00,399
we had many security engineering teams

00:28:59,120 --> 00:29:02,159
that said we need to be able to onboard

00:29:00,399 --> 00:29:03,679
our own fuzzers we have private fuzzers

00:29:02,159 --> 00:29:04,640
that live in our subscription or our

00:29:03,679 --> 00:29:05,760
enterprise

00:29:04,640 --> 00:29:07,279
we need to be able to onboard them

00:29:05,760 --> 00:29:09,440
easily if we can't do that we have to

00:29:07,279 --> 00:29:11,760
use our own fuzzing rig

00:29:09,440 --> 00:29:13,279
so what we developed was a python

00:29:11,760 --> 00:29:15,279
software development kit

00:29:13,279 --> 00:29:16,960
where it's not just that you can change

00:29:15,279 --> 00:29:18,080
things because it's open source you can

00:29:16,960 --> 00:29:21,679
change things because

00:29:18,080 --> 00:29:24,000
everything in one fuzz is used and

00:29:21,679 --> 00:29:26,720
composed through this sdk

00:29:24,000 --> 00:29:28,720
so all of our fuzzers are onboarded

00:29:26,720 --> 00:29:30,720
through the onefuzz sdk

00:29:28,720 --> 00:29:32,159
and it's made up of a collection of

00:29:30,720 --> 00:29:34,960
simple primitives

00:29:32,159 --> 00:29:35,520
so jobs are collections of tasks tasks

00:29:34,960 --> 00:29:39,039
perform

00:29:35,520 --> 00:29:40,880
a primitive um within a fuzzing workflow

00:29:39,039 --> 00:29:42,799
and every single task and every single

00:29:40,880 --> 00:29:44,480
job is remixable and plugable so you can

00:29:42,799 --> 00:29:47,679
add your own input generators

00:29:44,480 --> 00:29:51,120
you can add your own coverage and you

00:29:47,679 --> 00:29:52,399
can add your own analysis tasks

00:29:51,120 --> 00:29:54,559
on the other side of the fence what we

00:29:52,399 --> 00:29:57,440
heard from developers was we need

00:29:54,559 --> 00:29:59,520
simple reliable recipes that just work

00:29:57,440 --> 00:30:02,640
and plug into continuous integration

00:29:59,520 --> 00:30:05,679
so onefuzz has a python cli or a cli

00:30:02,640 --> 00:30:07,679
that's accessible as a downloadable pe

00:30:05,679 --> 00:30:08,880
where you can send in very simple

00:30:07,679 --> 00:30:11,600
recipes get

00:30:08,880 --> 00:30:13,600
powerful defaults and fuzzing should

00:30:11,600 --> 00:30:16,640
just work

00:30:13,600 --> 00:30:19,760
so let's talk about how that line is

00:30:16,640 --> 00:30:23,440
uh set up and navigated

00:30:19,760 --> 00:30:24,000
component by component one fuzz had to

00:30:23,440 --> 00:30:25,679
be a

00:30:24,000 --> 00:30:27,760
scalable architecture we needed to be

00:30:25,679 --> 00:30:30,000
able to handle software projects with

00:30:27,760 --> 00:30:31,200
thousands of concurrent buzzer targets

00:30:30,000 --> 00:30:32,880
thousands of cores

00:30:31,200 --> 00:30:35,200
but it also had to work the same way if

00:30:32,880 --> 00:30:37,039
you were fuzzing on one or two vms

00:30:35,200 --> 00:30:38,559
so to do that we used scalable

00:30:37,039 --> 00:30:41,279
primitives in azure

00:30:38,559 --> 00:30:41,679
and uh the the end of the road here is

00:30:41,279 --> 00:30:44,960
that

00:30:41,679 --> 00:30:47,679
everything is structured data in a file

00:30:44,960 --> 00:30:49,679
in an azure storage blob container so

00:30:47,679 --> 00:30:51,760
seeds or files crashing inputs or files

00:30:49,679 --> 00:30:52,720
executables or files crash reports or

00:30:51,760 --> 00:30:54,799
files

00:30:52,720 --> 00:30:56,080
and all of them live in the same by

00:30:54,799 --> 00:30:57,760
default seven

00:30:56,080 --> 00:31:00,080
storage containers that are set up on

00:30:57,760 --> 00:31:02,159
every job your setup storage container

00:31:00,080 --> 00:31:04,720
creates uh contains prereqs

00:31:02,159 --> 00:31:06,559
inputs create contains both the inputs

00:31:04,720 --> 00:31:08,320
you provide if you start out with a

00:31:06,559 --> 00:31:09,679
corpus of valid inputs or inputs you

00:31:08,320 --> 00:31:11,120
want to test and those you generate

00:31:09,679 --> 00:31:12,399
through fuzzing

00:31:11,120 --> 00:31:14,559
all your crashing inputs live in a

00:31:12,399 --> 00:31:15,840
container your crash reports which are

00:31:14,559 --> 00:31:17,600
kicked off automatically live in a

00:31:15,840 --> 00:31:18,320
container and then the container that

00:31:17,600 --> 00:31:20,240
you will

00:31:18,320 --> 00:31:22,559
care about the most is the unique

00:31:20,240 --> 00:31:24,240
reports container

00:31:22,559 --> 00:31:25,840
where new entries in that unique report

00:31:24,240 --> 00:31:26,799
container by default can kick off

00:31:25,840 --> 00:31:28,960
messaging

00:31:26,799 --> 00:31:30,000
uh to your continuous integration system

00:31:28,960 --> 00:31:32,240
we also have

00:31:30,000 --> 00:31:35,279
those bugs that failed to reproduce and

00:31:32,240 --> 00:31:35,279
code coverage data

00:31:40,799 --> 00:31:44,159
continuous integration on compile

00:31:42,799 --> 00:31:47,039
fuzzing so

00:31:44,159 --> 00:31:48,799
we talked a bit about how developers uh

00:31:47,039 --> 00:31:51,279
want reliable recipes

00:31:48,799 --> 00:31:52,720
uh that just work this is the commit the

00:31:51,279 --> 00:31:54,880
default command line for getting

00:31:52,720 --> 00:31:55,760
a fuzzy job launched in the cloud and

00:31:54,880 --> 00:31:57,840
we're gonna uh

00:31:55,760 --> 00:32:00,159
fuzz a component out of our sample image

00:31:57,840 --> 00:32:03,360
processing application

00:32:00,159 --> 00:32:04,799
start with a template take the re image

00:32:03,360 --> 00:32:08,000
resizer project

00:32:04,799 --> 00:32:12,399
jpeg functionality build number one

00:32:08,000 --> 00:32:15,760
and the linux available pool

00:32:12,399 --> 00:32:18,000
so virtual machines live in pools

00:32:15,760 --> 00:32:20,240
they are hot spares so the pool is a

00:32:18,000 --> 00:32:22,799
size that you specify and set up

00:32:20,240 --> 00:32:24,799
and uh every task will pull from the

00:32:22,799 --> 00:32:27,120
available pool that means that

00:32:24,799 --> 00:32:28,480
in that phase in between local fuzzing

00:32:27,120 --> 00:32:29,679
and continuous fuzzing where you're kind

00:32:28,480 --> 00:32:30,559
of setting things up and working with

00:32:29,679 --> 00:32:32,960
the framework

00:32:30,559 --> 00:32:34,960
you get this very low latency observable

00:32:32,960 --> 00:32:37,679
debuggable interaction with the

00:32:34,960 --> 00:32:38,960
one fuzz framework build aware artifact

00:32:37,679 --> 00:32:42,080
preservation means we keep

00:32:38,960 --> 00:32:43,440
inputs over the life of a feature as

00:32:42,080 --> 00:32:45,200
you're doing continuous integration

00:32:43,440 --> 00:32:46,880
testing of the jpeg feature all the

00:32:45,200 --> 00:32:47,840
inputs that were created by last fuzzing

00:32:46,880 --> 00:32:49,440
run are

00:32:47,840 --> 00:32:51,679
automatically ported to the next fuzzing

00:32:49,440 --> 00:32:55,039
run and combined with your new

00:32:51,679 --> 00:32:55,039
newly compiled fuzz target

00:32:55,360 --> 00:32:59,120
and beyond these defaults there are

00:32:57,919 --> 00:33:01,039
powerful options

00:32:59,120 --> 00:33:02,880
so i mentioned the need to be able to do

00:33:01,039 --> 00:33:04,960
custom operating systems

00:33:02,880 --> 00:33:05,919
um that comes from a pool that you can

00:33:04,960 --> 00:33:08,159
set up

00:33:05,919 --> 00:33:09,039
and you can do everything from pulling

00:33:08,159 --> 00:33:11,679
public images

00:33:09,039 --> 00:33:12,640
out of azure vm image list off the azure

00:33:11,679 --> 00:33:15,519
cli

00:33:12,640 --> 00:33:17,360
anything in the url format works to

00:33:15,519 --> 00:33:19,279
using

00:33:17,360 --> 00:33:21,600
automation to take your daily build of

00:33:19,279 --> 00:33:23,679
an operating system and create a custom

00:33:21,600 --> 00:33:25,039
bootable image of that operating system

00:33:23,679 --> 00:33:26,799
or if you're an operating system

00:33:25,039 --> 00:33:29,200
dependent product

00:33:26,799 --> 00:33:30,720
or you're doing something exotic like uh

00:33:29,200 --> 00:33:31,760
fuzzing a hypervisor using nested

00:33:30,720 --> 00:33:33,600
virtualization

00:33:31,760 --> 00:33:35,039
you can create and test your own custom

00:33:33,600 --> 00:33:36,840
operating system image and then do all

00:33:35,039 --> 00:33:39,840
of your fuzzing on it

00:33:36,840 --> 00:33:39,840
um

00:33:42,240 --> 00:33:46,640
for scaling we wanted to make sure that

00:33:44,559 --> 00:33:48,480
the same command line that you used to

00:33:46,640 --> 00:33:49,200
do continuous fuzzing at very small

00:33:48,480 --> 00:33:51,200
scale

00:33:49,200 --> 00:33:53,120
could be turned into large-scale uh

00:33:51,200 --> 00:33:56,080
fuzzing

00:33:53,120 --> 00:33:57,840
with just one flag so scale is just a

00:33:56,080 --> 00:34:01,120
number in one fuzz

00:33:57,840 --> 00:34:01,840
if you want to fuzz with tens uh a few

00:34:01,120 --> 00:34:03,919
cores

00:34:01,840 --> 00:34:07,840
tens of course hundreds of course all

00:34:03,919 --> 00:34:07,840
you have to do is change vm count

00:34:09,200 --> 00:34:15,119
talking to security engineering teams

00:34:12,320 --> 00:34:17,280
fuzzer choice was a really important

00:34:15,119 --> 00:34:18,800
topic and the ability to onboard fuzzers

00:34:17,280 --> 00:34:21,040
was a really important topic

00:34:18,800 --> 00:34:22,159
so this is a screenshot from last week's

00:34:21,040 --> 00:34:25,040
fuzz bench

00:34:22,159 --> 00:34:28,159
um and you can clearly see that on when

00:34:25,040 --> 00:34:29,839
testing sqlite 3

00:34:28,159 --> 00:34:31,760
that you get breakout performance from

00:34:29,839 --> 00:34:34,399
afl plus plus

00:34:31,760 --> 00:34:35,440
more edges discovered more quickly so

00:34:34,399 --> 00:34:38,560
it's clear to me

00:34:35,440 --> 00:34:39,919
as a security engineer perhaps that

00:34:38,560 --> 00:34:41,839
if i'm going to test my software i

00:34:39,919 --> 00:34:44,480
should use afl plus plus

00:34:41,839 --> 00:34:45,599
here's a screenshot from the same uh

00:34:44,480 --> 00:34:48,960
fuzz bench

00:34:45,599 --> 00:34:51,119
test from last week of libpng where

00:34:48,960 --> 00:34:52,560
hong fuzz achieves breakout performance

00:34:51,119 --> 00:34:54,720
and more edge coverage

00:34:52,560 --> 00:34:55,599
security engineering teams love results

00:34:54,720 --> 00:34:57,280
like this

00:34:55,599 --> 00:34:58,800
uh they love learning about which

00:34:57,280 --> 00:35:01,280
fuzzing technology should be adapted to

00:34:58,800 --> 00:35:04,160
which software and tuning the fuzzy mix

00:35:01,280 --> 00:35:07,200
um we also uh when we speak to

00:35:04,160 --> 00:35:09,280
developers realize that developers

00:35:07,200 --> 00:35:11,280
just want high quality reproducible

00:35:09,280 --> 00:35:13,359
results they want the best testing

00:35:11,280 --> 00:35:14,720
uh and analysis and they're not as

00:35:13,359 --> 00:35:15,680
concerned about what's happening under

00:35:14,720 --> 00:35:17,440
the hood

00:35:15,680 --> 00:35:19,359
and we felt that the solution to this

00:35:17,440 --> 00:35:21,920
was uh very recent

00:35:19,359 --> 00:35:23,599
in in in terms of academic investigation

00:35:21,920 --> 00:35:26,480
the um

00:35:23,599 --> 00:35:28,240
ianfuzz paper ensemble fuzzing presented

00:35:26,480 --> 00:35:30,480
at usenix last year

00:35:28,240 --> 00:35:32,000
uh came up with the remarkable result

00:35:30,480 --> 00:35:32,400
that when you allow these buzzers to

00:35:32,000 --> 00:35:34,880
share

00:35:32,400 --> 00:35:35,920
inputs throughout the entire job to work

00:35:34,880 --> 00:35:39,280
as a team

00:35:35,920 --> 00:35:41,040
uh lib buzzer afl fuzzers like radomsa

00:35:39,280 --> 00:35:42,560
maybe a private fuzzer that you use or

00:35:41,040 --> 00:35:44,800
fuzzers that are

00:35:42,560 --> 00:35:45,920
domain specific to your target when

00:35:44,800 --> 00:35:48,640
they're able to swap

00:35:45,920 --> 00:35:50,480
inputs they can reach coverage and bugs

00:35:48,640 --> 00:35:52,160
that no individual fuzzer in the team

00:35:50,480 --> 00:35:54,880
can find on their own

00:35:52,160 --> 00:35:56,240
so we decided that one fuzz would be

00:35:54,880 --> 00:35:58,240
ensemble by default

00:35:56,240 --> 00:35:59,680
and so when you onboard a fuzzer or use

00:35:58,240 --> 00:36:01,359
the default fuzzers in the one files

00:35:59,680 --> 00:36:02,400
framework they all swap inputs and work

00:36:01,359 --> 00:36:05,040
as a team

00:36:02,400 --> 00:36:06,160
and you don't need to worry about it as

00:36:05,040 --> 00:36:07,760
a developer when you're using these

00:36:06,160 --> 00:36:09,440
templates that just happens as a

00:36:07,760 --> 00:36:12,480
property of the framework

00:36:09,440 --> 00:36:14,160
and uh we wanted uh security engineering

00:36:12,480 --> 00:36:15,280
teams to always be able to bring their

00:36:14,160 --> 00:36:16,960
own fuzzers

00:36:15,280 --> 00:36:18,880
so we have first class support for the

00:36:16,960 --> 00:36:20,720
buzzer afl radonsa

00:36:18,880 --> 00:36:22,320
but we also have an examples directory

00:36:20,720 --> 00:36:24,480
linked on the slide

00:36:22,320 --> 00:36:25,520
that shows how to onboard other fuzzers

00:36:24,480 --> 00:36:27,680
d'amato which is

00:36:25,520 --> 00:36:29,359
very specific to the browser domain hong

00:36:27,680 --> 00:36:33,200
fuzz oss fuzz

00:36:29,359 --> 00:36:37,680
these examples um

00:36:33,200 --> 00:36:39,119
are are there in the directory

00:36:37,680 --> 00:36:41,040
not just to be able to allow you to

00:36:39,119 --> 00:36:42,720
onboard those fuzzers but to you

00:36:41,040 --> 00:36:44,480
to work as a template for onboarding

00:36:42,720 --> 00:36:46,160
buzzers that are unique to your project

00:36:44,480 --> 00:36:48,079
even closed source buzzers that you may

00:36:46,160 --> 00:36:50,400
keep only in your subscription or belong

00:36:48,079 --> 00:36:50,400
to you

00:36:51,440 --> 00:36:54,960
so i want to do some security

00:36:54,240 --> 00:36:56,400
engineering

00:36:54,960 --> 00:36:58,640
use the framework on the command line

00:36:56,400 --> 00:37:01,040
briefly uh while also noting

00:36:58,640 --> 00:37:03,040
that you don't need to do this in order

00:37:01,040 --> 00:37:04,320
to use one files

00:37:03,040 --> 00:37:05,760
but what i want to point out here is

00:37:04,320 --> 00:37:07,200
that everything is programmatically

00:37:05,760 --> 00:37:09,920
accessible in the framework

00:37:07,200 --> 00:37:11,440
and all data is structured uh data is

00:37:09,920 --> 00:37:13,680
json the jms

00:37:11,440 --> 00:37:16,240
path query language and step one is how

00:37:13,680 --> 00:37:18,560
all querying of the framework happens

00:37:16,240 --> 00:37:20,720
and the idea here is that it should be

00:37:18,560 --> 00:37:22,240
interactive it should be scriptable

00:37:20,720 --> 00:37:24,800
and it should be able to interact with

00:37:22,240 --> 00:37:26,640
your automation so in step one

00:37:24,800 --> 00:37:28,560
i will search for a job with containing

00:37:26,640 --> 00:37:31,280
the substring 8763

00:37:28,560 --> 00:37:33,680
just enough of the uuid to be unique i

00:37:31,280 --> 00:37:36,240
will pull the unique reports container

00:37:33,680 --> 00:37:39,520
and i will pull one json structured

00:37:36,240 --> 00:37:40,800
crash report out of that container

00:37:39,520 --> 00:37:42,880
here's what it looks like on the command

00:37:40,800 --> 00:37:45,440
line and we're going to start this

00:37:42,880 --> 00:37:47,440
command line session where we left off

00:37:45,440 --> 00:37:48,880
with a fuzz target we had just built on

00:37:47,440 --> 00:37:50,160
the developer workstation

00:37:48,880 --> 00:37:52,720
and we're going to launch a cloud

00:37:50,160 --> 00:37:56,640
fuzzing job so there is that one line

00:37:52,720 --> 00:37:56,640
template again from the one five cli

00:37:56,880 --> 00:38:03,119
and this is what it takes to launch a

00:38:00,000 --> 00:38:06,240
a cloud fuzzing job of any size

00:38:03,119 --> 00:38:06,880
uh there are the seven uh containers i

00:38:06,240 --> 00:38:09,040
mentioned

00:38:06,880 --> 00:38:10,240
and it's off now the minute you launch a

00:38:09,040 --> 00:38:12,560
fuzzing job you want to know how is it

00:38:10,240 --> 00:38:13,440
doing so i just launched one fuzz status

00:38:12,560 --> 00:38:16,240
top

00:38:13,440 --> 00:38:18,240
this is fuzz top uh the development team

00:38:16,240 --> 00:38:19,920
behind one fuzz loves this view

00:38:18,240 --> 00:38:22,079
you can see everything in your entire

00:38:19,920 --> 00:38:23,920
fuzzing instance in real time

00:38:22,079 --> 00:38:26,000
at the top is the status of your pool

00:38:23,920 --> 00:38:28,160
it's busy in free node counts

00:38:26,000 --> 00:38:30,079
next are jobs so the job we just

00:38:28,160 --> 00:38:33,440
launched uh that is

00:38:30,079 --> 00:38:34,960
following the tiff functionality uh with

00:38:33,440 --> 00:38:37,119
two crashes and nine inputs is

00:38:34,960 --> 00:38:40,079
accompanied by longer running jobs

00:38:37,119 --> 00:38:41,359
testing png and jpeg with more crashes

00:38:40,079 --> 00:38:43,200
uh

00:38:41,359 --> 00:38:44,560
based on when they were started and then

00:38:43,200 --> 00:38:46,960
all the individual tasks that are being

00:38:44,560 --> 00:38:48,400
kicked off by the jobs is at the bottom

00:38:46,960 --> 00:38:50,560
now i'm going to dig straight into the

00:38:48,400 --> 00:38:54,000
job i just launched on the command line

00:38:50,560 --> 00:38:54,720
i'm going to say using just enough of

00:38:54,000 --> 00:38:57,839
the handle

00:38:54,720 --> 00:39:00,720
from that job 3fc just the substring

00:38:57,839 --> 00:39:03,680
give me that container and list

00:39:00,720 --> 00:39:03,680
everything inside it

00:39:04,800 --> 00:39:10,560
and i want the unique reports

00:39:08,720 --> 00:39:12,320
so those are my unique crash reports i

00:39:10,560 --> 00:39:14,480
have two unique crashes so far

00:39:12,320 --> 00:39:15,359
and if i pull that json file you'll see

00:39:14,480 --> 00:39:18,880
again

00:39:15,359 --> 00:39:22,000
uh that all data is structured um

00:39:18,880 --> 00:39:24,560
everything is a file in a container and

00:39:22,000 --> 00:39:26,160
the the ability to pull this uh and then

00:39:24,560 --> 00:39:27,760
we'll run it through jq so we can

00:39:26,160 --> 00:39:29,599
we can take a look at it uh in its

00:39:27,760 --> 00:39:32,000
structured form uh

00:39:29,599 --> 00:39:34,480
has sensible name fields that would you

00:39:32,000 --> 00:39:36,800
can plug into your follow-on automation

00:39:34,480 --> 00:39:38,000
uh maybe route different types of

00:39:36,800 --> 00:39:41,119
sanitizer bugs

00:39:38,000 --> 00:39:43,440
to different parts or

00:39:41,119 --> 00:39:45,839
different notification pipelines the

00:39:43,440 --> 00:39:48,240
entire call stack is there

00:39:45,839 --> 00:39:49,839
uh the asan log anything that your

00:39:48,240 --> 00:39:50,640
security engineering team wants to be

00:39:49,839 --> 00:39:54,960
able to fire

00:39:50,640 --> 00:39:57,359
as a introspection driven event

00:39:54,960 --> 00:39:58,640
is programmatically accessible uh from

00:39:57,359 --> 00:40:01,599
this cli

00:39:58,640 --> 00:40:03,280
but we also understand that this is what

00:40:01,599 --> 00:40:05,200
security engineering teams need but it

00:40:03,280 --> 00:40:07,040
is not what developers want

00:40:05,200 --> 00:40:09,280
uh when we talk to developers they

00:40:07,040 --> 00:40:11,520
wanted to the fuzz testing process to

00:40:09,280 --> 00:40:15,040
vanish into their build system

00:40:11,520 --> 00:40:17,200
and to kick off automatically so

00:40:15,040 --> 00:40:19,200
in the one fuzz samples directory linked

00:40:17,200 --> 00:40:20,160
from this slide you'll see example yaml

00:40:19,200 --> 00:40:22,079
files

00:40:20,160 --> 00:40:25,839
uh that show how to launch fuzzing jobs

00:40:22,079 --> 00:40:28,000
from an ado pipeline

00:40:25,839 --> 00:40:29,839
and how to launch fuzzing jobs from

00:40:28,000 --> 00:40:33,760
github actions

00:40:29,839 --> 00:40:34,160
and uh we also have examples on how to

00:40:33,760 --> 00:40:37,599
do

00:40:34,160 --> 00:40:40,319
new unique crashes um and cr uh

00:40:37,599 --> 00:40:42,000
have those create notifications in

00:40:40,319 --> 00:40:45,200
microsoft teams or as

00:40:42,000 --> 00:40:46,960
ado work items so

00:40:45,200 --> 00:40:48,319
uh i'm gonna show an example from

00:40:46,960 --> 00:40:50,079
microsoft teams

00:40:48,319 --> 00:40:53,040
and like justin said when you work at

00:40:50,079 --> 00:40:53,839
microsoft now you can get messaged over

00:40:53,040 --> 00:40:57,119
your

00:40:53,839 --> 00:41:00,400
chat application with a new unique

00:40:57,119 --> 00:41:03,040
reproducible fuzzing induced crash in

00:41:00,400 --> 00:41:04,480
pre-production code and along with that

00:41:03,040 --> 00:41:06,240
notification

00:41:04,480 --> 00:41:08,880
comes a direct link to the crashing

00:41:06,240 --> 00:41:10,720
target the direct link to the input file

00:41:08,880 --> 00:41:13,119
and a direct link to the crash report

00:41:10,720 --> 00:41:16,560
with a complete call stack included

00:41:13,119 --> 00:41:19,440
and uh it it really changes the

00:41:16,560 --> 00:41:20,000
the uh the way that fuzzing is viewed

00:41:19,440 --> 00:41:23,760
when

00:41:20,000 --> 00:41:23,760
every single bug is reproducible

00:41:25,280 --> 00:41:28,319
the screenshots here are from our dev

00:41:26,880 --> 00:41:31,359
branch this is

00:41:28,319 --> 00:41:33,200
a github issue automatically generated

00:41:31,359 --> 00:41:36,880
by the one fuzz framework

00:41:33,200 --> 00:41:40,400
uh talks about again the same fields

00:41:36,880 --> 00:41:41,839
um uh crashing input in the in our

00:41:40,400 --> 00:41:44,560
example program

00:41:41,839 --> 00:41:45,200
um down in the github comments uh are

00:41:44,560 --> 00:41:48,319
all the

00:41:45,200 --> 00:41:50,319
reproducing cases so uh multiple

00:41:48,319 --> 00:41:53,680
invocations of the same bug unique

00:41:50,319 --> 00:41:56,480
as additional reports and then finally

00:41:53,680 --> 00:41:57,359
uh the this part of the git hub issue

00:41:56,480 --> 00:41:59,680
has

00:41:57,359 --> 00:42:00,800
the same metadata as teams and i want to

00:41:59,680 --> 00:42:04,880
call out one line

00:42:00,800 --> 00:42:08,160
in particular which is the repro line

00:42:04,880 --> 00:42:10,480
so this is a pasteable command

00:42:08,160 --> 00:42:12,160
that allows for live programmatic

00:42:10,480 --> 00:42:15,839
cross-platform debugging

00:42:12,160 --> 00:42:16,560
of any bug found by the framework and uh

00:42:15,839 --> 00:42:18,079
when we

00:42:16,560 --> 00:42:19,680
launch this on the command line so i'll

00:42:18,079 --> 00:42:21,599
copy it out of my

00:42:19,680 --> 00:42:23,359
build system and paste it into a one

00:42:21,599 --> 00:42:24,960
fuzz enable command line

00:42:23,359 --> 00:42:26,800
a series of things happens whether it's

00:42:24,960 --> 00:42:30,000
windows or linux we're gonna pull

00:42:26,800 --> 00:42:32,240
a hot spare vm from the specified pool

00:42:30,000 --> 00:42:34,800
we'll do the key exchange automatically

00:42:32,240 --> 00:42:36,880
we'll set up an ssh session for you

00:42:34,800 --> 00:42:37,839
and then on the target the known

00:42:36,880 --> 00:42:40,400
faulting input

00:42:37,839 --> 00:42:41,520
the target is deployed a debugger is

00:42:40,400 --> 00:42:43,920
attached

00:42:41,520 --> 00:42:45,359
and we'll halt on entry and because you

00:42:43,920 --> 00:42:46,079
have the call stack this is a time when

00:42:45,359 --> 00:42:49,359
you can set up

00:42:46,079 --> 00:42:50,960
breakpoints and you can continue

00:42:49,359 --> 00:42:53,119
and the program is going to parse with

00:42:50,960 --> 00:42:56,640
sanitizers enabled

00:42:53,119 --> 00:42:59,200
straight to the the crash condition

00:42:56,640 --> 00:43:00,480
and we're using the same sample program

00:42:59,200 --> 00:43:02,319
that we started off at the beginning of

00:43:00,480 --> 00:43:05,599
the presentation with

00:43:02,319 --> 00:43:07,359
um and

00:43:05,599 --> 00:43:10,000
in this particular case you can see that

00:43:07,359 --> 00:43:11,680
this is lip buzzer discovering xyz one

00:43:10,000 --> 00:43:12,960
and it's even available at line

00:43:11,680 --> 00:43:14,800
seven of the call stack that's the

00:43:12,960 --> 00:43:18,480
faulting input

00:43:14,800 --> 00:43:20,880
so continuous fuzzing should not be

00:43:18,480 --> 00:43:21,680
about doing continuous homework it

00:43:20,880 --> 00:43:24,720
should be

00:43:21,680 --> 00:43:26,640
about spending a day setting up maybe a

00:43:24,720 --> 00:43:27,760
fuzzing instance and some targets for

00:43:26,640 --> 00:43:29,599
your program

00:43:27,760 --> 00:43:32,079
and then after that the fuzzing program

00:43:29,599 --> 00:43:34,720
should vanish into the build system

00:43:32,079 --> 00:43:35,200
and it should be about notifications

00:43:34,720 --> 00:43:37,520
that are

00:43:35,200 --> 00:43:38,960
immediate and actionable uh that are

00:43:37,520 --> 00:43:40,000
easy to understand and make your code

00:43:38,960 --> 00:43:43,280
more reliable

00:43:40,000 --> 00:43:43,280
help make you a better programmer

00:43:43,920 --> 00:43:47,839
i want to take this slide um right

00:43:46,319 --> 00:43:50,079
before we move to questions which

00:43:47,839 --> 00:43:52,240
i've been i've been reading but uh

00:43:50,079 --> 00:43:55,440
hoping that future slides would answer

00:43:52,240 --> 00:43:55,839
but we'll get to them um to spend some

00:43:55,440 --> 00:43:58,000
time

00:43:55,839 --> 00:43:59,359
thanking uh the one fuzz team who spent

00:43:58,000 --> 00:44:00,880
the last year building this framework

00:43:59,359 --> 00:44:03,599
and getting it ready for global open

00:44:00,880 --> 00:44:03,599
source release

00:44:04,960 --> 00:44:08,000
our partners uh on product teams who

00:44:07,280 --> 00:44:10,079
who've worked with

00:44:08,000 --> 00:44:11,119
us uh used the framework driven its

00:44:10,079 --> 00:44:13,920
development

00:44:11,119 --> 00:44:14,720
uh justin windows jonathan normand at

00:44:13,920 --> 00:44:19,200
edge

00:44:14,720 --> 00:44:23,040
uh sphere sdl teams around windows

00:44:19,200 --> 00:44:24,720
uh the visual studio team jim radigan

00:44:23,040 --> 00:44:26,560
and the customers are our microsoft risk

00:44:24,720 --> 00:44:28,000
detection service all of whose voices

00:44:26,560 --> 00:44:30,240
are represented in the

00:44:28,000 --> 00:44:31,280
the result we're releasing today we also

00:44:30,240 --> 00:44:33,760
need to thank

00:44:31,280 --> 00:44:35,280
google costia the llvm community for

00:44:33,760 --> 00:44:36,560
pioneering this compiler fuzzing

00:44:35,280 --> 00:44:38,240
revolution you'll see

00:44:36,560 --> 00:44:40,480
their ideas and tools represented

00:44:38,240 --> 00:44:41,599
throughout the open source fuzzing

00:44:40,480 --> 00:44:44,960
community

00:44:41,599 --> 00:44:47,520
and the attendees of cppcon and cppcon

00:44:44,960 --> 00:44:47,520
for having us

00:44:48,319 --> 00:44:53,359
so uh again we are open source

00:44:51,680 --> 00:44:55,359
and self-hosted and we're going to be

00:44:53,359 --> 00:44:58,720
using this continuously at microsoft

00:44:55,359 --> 00:45:01,200
and pushing updates uh to github

00:44:58,720 --> 00:45:02,960
um and we're releasing it globally

00:45:01,200 --> 00:45:04,560
because we hope that uh

00:45:02,960 --> 00:45:06,800
this is going to democratize and make

00:45:04,560 --> 00:45:08,800
fuzzing easier for enterprises

00:45:06,800 --> 00:45:10,480
who um for whom that security

00:45:08,800 --> 00:45:11,920
engineering task has traditionally been

00:45:10,480 --> 00:45:13,599
too expensive

00:45:11,920 --> 00:45:15,680
so we hope that you fuzz with us on

00:45:13,599 --> 00:45:18,079
windows and linux operating systems

00:45:15,680 --> 00:45:20,480
using composable fuzzy workload

00:45:18,079 --> 00:45:22,400
workflows that you can edit yourself

00:45:20,480 --> 00:45:24,000
using built-in ensemble fuzzing by

00:45:22,400 --> 00:45:26,640
default

00:45:24,000 --> 00:45:28,480
programmatic triage that's that's

00:45:26,640 --> 00:45:28,960
hookable and customizable and can use

00:45:28,480 --> 00:45:31,119
your own

00:45:28,960 --> 00:45:32,480
crash analysis automated result

00:45:31,119 --> 00:45:34,160
deduplication

00:45:32,480 --> 00:45:36,319
on-demand live debugging straight out of

00:45:34,160 --> 00:45:38,960
your messaging system

00:45:36,319 --> 00:45:41,119
um observable and debuggable with

00:45:38,960 --> 00:45:42,960
detailed telemetry through app insights

00:45:41,119 --> 00:45:46,079
which we don't have a slide on but it

00:45:42,960 --> 00:45:47,520
but it's there and that uh app that app

00:45:46,079 --> 00:45:49,680
insights telemetry

00:45:47,520 --> 00:45:50,960
uh is something you can use to you to

00:45:49,680 --> 00:45:53,200
create coverage

00:45:50,960 --> 00:45:55,119
guided fuzzing programs and crash

00:45:53,200 --> 00:45:58,839
reporting through microsoft teams

00:45:55,119 --> 00:46:02,319
so at this point um i believe

00:45:58,839 --> 00:46:04,640
justin can rejoin me

00:46:02,319 --> 00:46:05,920
and we can take some questions from the

00:46:04,640 --> 00:46:09,599
audience

00:46:05,920 --> 00:46:11,920
so i'm gonna uh please bear with me uh

00:46:09,599 --> 00:46:13,280
as i uh attempt to to repeat some

00:46:11,920 --> 00:46:17,119
questions

00:46:13,280 --> 00:46:18,960
um yes one fuzzy is open source on

00:46:17,119 --> 00:46:20,480
github and we are happy to work with

00:46:18,960 --> 00:46:23,040
developers

00:46:20,480 --> 00:46:25,280
um and and we'll by the way be at the

00:46:23,040 --> 00:46:28,319
microsoft booth for the rest of the con

00:46:25,280 --> 00:46:29,680
uh to talk about people to

00:46:28,319 --> 00:46:31,200
talk with people who are interested in

00:46:29,680 --> 00:46:33,680
collaborating or contributing to the

00:46:31,200 --> 00:46:33,680
framework

00:46:37,280 --> 00:46:41,280
fuzzing can be used for testing non-i o

00:46:39,440 --> 00:46:43,200
functions and there is a huge body of

00:46:41,280 --> 00:46:45,200
work using fuzzers to discuss

00:46:43,200 --> 00:46:47,040
uh to to discuss state machines

00:46:45,200 --> 00:46:48,160
differential analysis of implementations

00:46:47,040 --> 00:46:50,400
etc

00:46:48,160 --> 00:46:52,240
um uh maybe falling onto that i know

00:46:50,400 --> 00:46:54,560
that there is um

00:46:52,240 --> 00:46:57,119
i believe the the project is crypt fuzz

00:46:54,560 --> 00:46:58,960
but there is a a project that uses

00:46:57,119 --> 00:47:01,680
fuzzing to discover

00:46:58,960 --> 00:47:03,359
divergent implementation behaviors

00:47:01,680 --> 00:47:04,880
between cryptographic primitives that

00:47:03,359 --> 00:47:06,800
should always have the same outputs for

00:47:04,880 --> 00:47:09,280
the same inputs that's maybe one

00:47:06,800 --> 00:47:10,880
example of that to answer other

00:47:09,280 --> 00:47:12,400
questions i'm going to need to move over

00:47:10,880 --> 00:47:14,000
to the screen and scroll back

00:47:12,400 --> 00:47:16,319
so maybe justin who's had more time to

00:47:14,000 --> 00:47:18,240
prepare can pull one out of the stack

00:47:16,319 --> 00:47:19,599
yeah let me let me go ahead and read one

00:47:18,240 --> 00:47:21,599
question for you here

00:47:19,599 --> 00:47:23,839
uh does throwing exceptions count as a

00:47:21,599 --> 00:47:27,119
crash for purposes of

00:47:23,839 --> 00:47:28,000
crash monitoring do you want to take

00:47:27,119 --> 00:47:31,119
that one

00:47:28,000 --> 00:47:33,200
uh yeah sure so so today in

00:47:31,119 --> 00:47:35,040
uh technologies like lib fuzzer

00:47:33,200 --> 00:47:38,400
structured exception handling is

00:47:35,040 --> 00:47:40,160
uh we'll handle that correctly i believe

00:47:38,400 --> 00:47:41,680
the public implementation of the buzzer

00:47:40,160 --> 00:47:44,400
does have a gap

00:47:41,680 --> 00:47:46,079
uh where c plus exceptions are concerned

00:47:44,400 --> 00:47:48,480
that's something that

00:47:46,079 --> 00:47:51,599
my team and the compiler team at

00:47:48,480 --> 00:47:53,200
microsoft are working to close

00:47:51,599 --> 00:47:56,160
one fuzz on the other hand that's

00:47:53,200 --> 00:47:59,200
entirely uh configurable based on

00:47:56,160 --> 00:48:00,240
how you've implemented your fuzzing

00:47:59,200 --> 00:48:02,160
adapter and so

00:48:00,240 --> 00:48:04,160
mike mentioned that it's composable and

00:48:02,160 --> 00:48:06,480
you can bring your own fuzzer

00:48:04,160 --> 00:48:07,680
and it's incredibly flexible in how what

00:48:06,480 --> 00:48:10,079
behaviors you treat

00:48:07,680 --> 00:48:12,000
as something worth reporting and whether

00:48:10,079 --> 00:48:15,280
you treat that as a crash for purposes

00:48:12,000 --> 00:48:15,280
of alerts and reports

00:48:16,720 --> 00:48:20,160
uh second question here does the

00:48:18,640 --> 00:48:22,319
framework work with any

00:48:20,160 --> 00:48:23,520
programming language is it a black box

00:48:22,319 --> 00:48:27,040
testing tool

00:48:23,520 --> 00:48:27,040
mike you want to fill that one

00:48:27,280 --> 00:48:31,839
it it can we say that fuzzing is good

00:48:31,520 --> 00:48:35,359
for

00:48:31,839 --> 00:48:38,720
any target that contains native code

00:48:35,359 --> 00:48:41,280
so it sees c plus plus

00:48:38,720 --> 00:48:42,079
but those are just the the primary

00:48:41,280 --> 00:48:44,319
languages

00:48:42,079 --> 00:48:45,920
uh that where where fuzzing is

00:48:44,319 --> 00:48:48,800
traditionally used however

00:48:45,920 --> 00:48:50,319
it's worth noting that even with

00:48:48,800 --> 00:48:52,480
binaries that have

00:48:50,319 --> 00:48:54,319
stronger guarantees of memory safety

00:48:52,480 --> 00:48:55,040
anywhere there are potentially unsafe

00:48:54,319 --> 00:48:57,280
components

00:48:55,040 --> 00:48:59,040
at the end of a reachability path

00:48:57,280 --> 00:49:02,160
fuzzing is an appropriate solution

00:48:59,040 --> 00:49:04,480
so you see fuzzing in the rust community

00:49:02,160 --> 00:49:04,480
as well

00:49:05,520 --> 00:49:08,480
now i can read another one for you here

00:49:06,720 --> 00:49:09,200
can we integrate with other ci

00:49:08,480 --> 00:49:12,480
environments

00:49:09,200 --> 00:49:15,200
uh for example team city

00:49:12,480 --> 00:49:16,079
uh we haven't tested it but the spirit

00:49:15,200 --> 00:49:18,720
of one fuzz

00:49:16,079 --> 00:49:21,040
is that everything should be pluggable

00:49:18,720 --> 00:49:24,720
and integration should be easy so

00:49:21,040 --> 00:49:27,040
that uh onefuzz samples um directory

00:49:24,720 --> 00:49:29,760
uh and those yaml files there are

00:49:27,040 --> 00:49:33,359
recipes for how we've done it with ado

00:49:29,760 --> 00:49:35,680
and github um but this is open source

00:49:33,359 --> 00:49:39,040
and contributions are accepted so

00:49:35,680 --> 00:49:40,400
uh our answer is try it let us know and

00:49:39,040 --> 00:49:42,480
we're really interested to know whether

00:49:40,400 --> 00:49:43,040
the sdk is adaptable enough to make that

00:49:42,480 --> 00:49:46,240
happen

00:49:43,040 --> 00:49:49,119
or what sdk changes we need to make

00:49:46,240 --> 00:49:49,119
so that can happen

00:49:49,920 --> 00:49:58,319
okay and next question can we extend

00:49:51,599 --> 00:50:01,119
your framework with c-sharp

00:49:58,319 --> 00:50:02,880
well it's open source um so i don't

00:50:01,119 --> 00:50:06,400
think there's a reason you couldn't

00:50:02,880 --> 00:50:07,599
um i will say that uh one fuzz

00:50:06,400 --> 00:50:09,480
when we talk about the language choice

00:50:07,599 --> 00:50:12,400
of the framework itself it is primarily

00:50:09,480 --> 00:50:15,920
python um and

00:50:12,400 --> 00:50:18,400
and there is also a rust component

00:50:15,920 --> 00:50:20,559
and we've used rust uh exclusively for

00:50:18,400 --> 00:50:23,520
the execution agent that happens

00:50:20,559 --> 00:50:24,160
on the target virtual machine because of

00:50:23,520 --> 00:50:26,480
rust's

00:50:24,160 --> 00:50:29,119
well first uh amazing runtime properties

00:50:26,480 --> 00:50:32,559
but also its ability to be able to emit

00:50:29,119 --> 00:50:34,240
dependency free cross-platform binder

00:50:32,559 --> 00:50:35,839
binaries without a lot of

00:50:34,240 --> 00:50:37,680
platform-specific code

00:50:35,839 --> 00:50:39,599
so it is already a multi-language

00:50:37,680 --> 00:50:41,280
framework um

00:50:39,599 --> 00:50:43,200
and i'm sure you could extend it in c

00:50:41,280 --> 00:50:45,520
sharp

00:50:43,200 --> 00:50:47,280
yeah and i'll add to that that um if you

00:50:45,520 --> 00:50:48,079
wanted to write a fuzzer in c sharp

00:50:47,280 --> 00:50:50,160
that's obviously

00:50:48,079 --> 00:50:52,720
supported today with no additional work

00:50:50,160 --> 00:50:56,319
and microsoft is actually working with

00:50:52,720 --> 00:50:59,200
the.net and c-sharp teams on

00:50:56,319 --> 00:51:02,640
using fuzzing to fuzz csr and the

00:50:59,200 --> 00:51:02,640
dot-net runtime itself as well

00:51:05,920 --> 00:51:10,400
okay i think that's our our total

00:51:07,920 --> 00:51:10,400
backlog

00:51:14,559 --> 00:51:17,680
i i believe we've covered the questions

00:51:16,800 --> 00:51:20,160
queue

00:51:17,680 --> 00:51:21,200
but um if you'd like to have um a

00:51:20,160 --> 00:51:24,079
smaller discussion

00:51:21,200 --> 00:51:37,839
after the talk um please come join us at

00:51:24,079 --> 00:51:37,839
the microsoft booth

00:51:44,960 --> 00:51:47,040

YouTube URL: https://www.youtube.com/watch?v=NsmRPRxhLn0


