Title: Exceptions Under the Spotlight - Inbal Levi - CppCon 2020
Publication date: 2020-10-04
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/exceptions_under_the_spotlight/exceptions_under_the_spotlight__inbal_levi__cppcon_2020.pdf
---
The exceptions mechanism is a complex topic and has been enthusiastically discussed in the last WG21 committee meeting.

In this talk we will dive into the world of exceptions.

We will start by understanding the error handling mechanism.

We will explore the evolution of exceptions, and the design decisions that led to the current version.

Next, we will see its usage as part of the program, and analyze the overhead by breaking the exceptions mechanism to bits.

Last, we will describe and analyze the alternatives, and potential directions for the exceptions mechanism in a future C++ versions.

---
Inbal Levi is an embedded software engineer with a passion for high performance.
She is one of the organizers of CoreCpp conference and CoreCpp user group.
She's also a member of ISO/IEC JTC1/SC22/WG21 (the C++ Standards Committee), and among the founders of the Israeli NB Mirror committee.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,280 --> 00:00:14,000
hello everyone

00:00:11,120 --> 00:00:15,040
my name is inval levy and today i'm

00:00:14,000 --> 00:00:20,160
going to talk about

00:00:15,040 --> 00:00:22,240
exceptions so let's start

00:00:20,160 --> 00:00:23,600
but first of all i want to introduce

00:00:22,240 --> 00:00:27,199
myself so

00:00:23,600 --> 00:00:29,199
i'm a c plus plus enthusiast i'm also a

00:00:27,199 --> 00:00:30,800
an embedded software engineer at solar

00:00:29,199 --> 00:00:32,320
edge and i'm working on smart home

00:00:30,800 --> 00:00:34,800
devices

00:00:32,320 --> 00:00:35,520
i'm one of the organizers of core cpp

00:00:34,800 --> 00:00:39,120
conference

00:00:35,520 --> 00:00:40,000
and user group and a member of workgroup

00:00:39,120 --> 00:00:42,079
21.

00:00:40,000 --> 00:00:43,840
in addition i'm one of the founders of

00:00:42,079 --> 00:00:46,800
the israeli national body

00:00:43,840 --> 00:00:47,840
the izo israeli national body and i've

00:00:46,800 --> 00:00:50,480
studied physics

00:00:47,840 --> 00:00:52,079
i also love math so if anyone wants to

00:00:50,480 --> 00:00:53,600
talk about math later you're almost

00:00:52,079 --> 00:00:56,640
welcome

00:00:53,600 --> 00:00:57,520
so let's start i want to start with

00:00:56,640 --> 00:01:00,719
motivation

00:00:57,520 --> 00:01:01,760
to this talk so here you can see two

00:01:00,719 --> 00:01:04,080
surveys

00:01:01,760 --> 00:01:05,760
the last one was made by izo the right

00:01:04,080 --> 00:01:09,760
one was made by me

00:01:05,760 --> 00:01:11,760
in twitter it was a twitter survey

00:01:09,760 --> 00:01:13,760
throughout our user group of course it

00:01:11,760 --> 00:01:16,960
be you might have seen it

00:01:13,760 --> 00:01:19,600
and the questions were asking

00:01:16,960 --> 00:01:21,840
the easier one is actually more precise

00:01:19,600 --> 00:01:25,520
it was asking how many developers

00:01:21,840 --> 00:01:27,920
can use error exceptions

00:01:25,520 --> 00:01:28,720
freely in their project and you can see

00:01:27,920 --> 00:01:32,320
that

00:01:28,720 --> 00:01:33,759
over 54 percent uh said that they can't

00:01:32,320 --> 00:01:36,000
use exceptions freely

00:01:33,759 --> 00:01:36,960
in their project and the right one is

00:01:36,000 --> 00:01:39,680
talking about

00:01:36,960 --> 00:01:41,680
uh developers uh working on embedded

00:01:39,680 --> 00:01:42,720
systems and again you can see similar

00:01:41,680 --> 00:01:46,880
numbers

00:01:42,720 --> 00:01:50,079
so the problem of exceptions handling

00:01:46,880 --> 00:01:52,320
uh being um

00:01:50,079 --> 00:01:55,040
of projects avoiding exception handling

00:01:52,320 --> 00:01:58,000
is a is a very large issue

00:01:55,040 --> 00:01:58,719
and i would i know we're on a virtual uh

00:01:58,000 --> 00:02:01,680
setup but

00:01:58,719 --> 00:02:03,840
i wonder how many of you would say that

00:02:01,680 --> 00:02:05,439
you're not using exceptions in your in

00:02:03,840 --> 00:02:08,240
your project i would love to hear your

00:02:05,439 --> 00:02:08,240
answers later

00:02:08,879 --> 00:02:16,720
okay so many industries as i said

00:02:14,000 --> 00:02:19,120
don't use exceptions for performance

00:02:16,720 --> 00:02:19,120
reasons

00:02:19,520 --> 00:02:24,080
the error handling mechanism was

00:02:21,280 --> 00:02:26,400
addressed by a direction group

00:02:24,080 --> 00:02:28,160
and this is a special group of people

00:02:26,400 --> 00:02:29,440
that have been working on c plus plus

00:02:28,160 --> 00:02:32,239
for a very long time

00:02:29,440 --> 00:02:32,959
it includes piana and david and michael

00:02:32,239 --> 00:02:36,720
wong and

00:02:32,959 --> 00:02:40,560
others and they've addressed

00:02:36,720 --> 00:02:43,680
er handling mechanism uh by contracts

00:02:40,560 --> 00:02:47,440
uh in 2016 in in a way that

00:02:43,680 --> 00:02:49,280
uh they uh addressed that

00:02:47,440 --> 00:02:50,640
uh by addressing the predefined

00:02:49,280 --> 00:02:52,400
conditions

00:02:50,640 --> 00:02:56,160
but contracts clearly are not part of

00:02:52,400 --> 00:02:56,160
our office 20 yet

00:02:56,239 --> 00:03:02,640
and they addressed it again in 2018.

00:03:00,959 --> 00:03:04,400
the exception mechanism was also

00:03:02,640 --> 00:03:07,680
addressed by herb sutter

00:03:04,400 --> 00:03:09,760
in 2019 by the paper

00:03:07,680 --> 00:03:12,800
zero zero overhead deterministic

00:03:09,760 --> 00:03:16,000
exceptions throwing values

00:03:12,800 --> 00:03:19,519
and again in the recent meeting

00:03:16,000 --> 00:03:22,800
the last real-life meeting in prague

00:03:19,519 --> 00:03:24,720
uh a paper by james ranwick and others

00:03:22,800 --> 00:03:26,799
were present was presented

00:03:24,720 --> 00:03:28,799
it's called a low-cost deterministic

00:03:26,799 --> 00:03:30,080
sipless plus exceptions for embedded

00:03:28,799 --> 00:03:33,200
systems

00:03:30,080 --> 00:03:36,239
and uh the last two papers i'm gonna

00:03:33,200 --> 00:03:39,599
uh talk about uh late uh

00:03:36,239 --> 00:03:41,920
uh around the end of my talk uh the

00:03:39,599 --> 00:03:45,200
technical part

00:03:41,920 --> 00:03:46,480
uh i also wanna say that uh i gave this

00:03:45,200 --> 00:03:49,519
talk in munich

00:03:46,480 --> 00:03:52,159
uh user group so um

00:03:49,519 --> 00:03:53,040
i think it's it's very interesting uh to

00:03:52,159 --> 00:03:56,799
see it

00:03:53,040 --> 00:04:00,000
uh this topic comes out a lot lately

00:03:56,799 --> 00:04:03,840
and i'm sure you're most welcome to

00:04:00,000 --> 00:04:04,480
see um klaus's talk uh where he talks

00:04:03,840 --> 00:04:07,439
about

00:04:04,480 --> 00:04:10,400
the usage of exceptions here i'm gonna

00:04:07,439 --> 00:04:14,159
focus on the technical part

00:04:10,400 --> 00:04:15,120
so as i said i expect a major changes in

00:04:14,159 --> 00:04:18,160
the mechanism

00:04:15,120 --> 00:04:18,160
in the near future

00:04:19,040 --> 00:04:23,520
so the talk will go as follows we're

00:04:22,000 --> 00:04:26,479
going to start with

00:04:23,520 --> 00:04:28,080
water exceptions a very basic syntax

00:04:26,479 --> 00:04:30,960
then we're going to go over history

00:04:28,080 --> 00:04:32,720
and domain we're going to look at

00:04:30,960 --> 00:04:36,000
exceptions overhead

00:04:32,720 --> 00:04:37,040
um in the technical part again and then

00:04:36,000 --> 00:04:39,759
we're going to

00:04:37,040 --> 00:04:41,040
do a design overview and look at some

00:04:39,759 --> 00:04:42,960
alternatives

00:04:41,040 --> 00:04:45,919
and at the end we're going to talk about

00:04:42,960 --> 00:04:49,919
what's what's next in the exceptions

00:04:45,919 --> 00:04:52,240
mechanism so as i said this is not a

00:04:49,919 --> 00:04:56,479
talk about best practices

00:04:52,240 --> 00:04:58,639
of using exceptions though it does refer

00:04:56,479 --> 00:05:00,320
very very briefly to some guidelines

00:04:58,639 --> 00:05:01,759
this is not a talk presenting uh

00:05:00,320 --> 00:05:04,639
production level code

00:05:01,759 --> 00:05:06,639
uh this is uh the the code appears in

00:05:04,639 --> 00:05:09,600
the talk is just a poc

00:05:06,639 --> 00:05:12,560
and it was ran only on linux and

00:05:09,600 --> 00:05:13,840
concurrency is also out of the scope for

00:05:12,560 --> 00:05:16,400
this talk

00:05:13,840 --> 00:05:17,280
and it aims to include a historical

00:05:16,400 --> 00:05:20,960
perspective

00:05:17,280 --> 00:05:22,080
but i wasn't there so everything all the

00:05:20,960 --> 00:05:25,120
decision making

00:05:22,080 --> 00:05:29,600
described is alleged and

00:05:25,120 --> 00:05:31,600
hope you enjoy it so what are exceptions

00:05:29,600 --> 00:05:33,039
uh exceptions are a fail handling

00:05:31,600 --> 00:05:35,600
mechanism

00:05:33,039 --> 00:05:38,800
so here we have a function that's called

00:05:35,600 --> 00:05:41,759
foo and foo can do stuff and if ca

00:05:38,800 --> 00:05:42,320
in case fails it can throw it can either

00:05:41,759 --> 00:05:45,360
throw

00:05:42,320 --> 00:05:49,280
from of course from uh stood uh

00:05:45,360 --> 00:05:52,400
standard library uh functionality or

00:05:49,280 --> 00:05:55,680
other things and the error is propagated

00:05:52,400 --> 00:05:57,440
up the stack so uh just

00:05:55,680 --> 00:05:59,600
as i mentioned we're going to go very

00:05:57,440 --> 00:06:01,840
briefly of the of the main

00:05:59,600 --> 00:06:02,639
guidelines you can define your exception

00:06:01,840 --> 00:06:06,080
type

00:06:02,639 --> 00:06:07,199
it's recommended to derive from us the

00:06:06,080 --> 00:06:09,280
exceptions

00:06:07,199 --> 00:06:10,319
and it is recommended to throw by value

00:06:09,280 --> 00:06:12,800
catch by ref

00:06:10,319 --> 00:06:13,680
uh and rethrow just by using throw and

00:06:12,800 --> 00:06:17,280
not

00:06:13,680 --> 00:06:20,080
the value and this is just a

00:06:17,280 --> 00:06:21,280
general guidelines for optimizing

00:06:20,080 --> 00:06:24,639
performance in the

00:06:21,280 --> 00:06:26,720
in the current exception mechanism

00:06:24,639 --> 00:06:28,000
so as i said this is a fail handling

00:06:26,720 --> 00:06:31,360
mechanism

00:06:28,000 --> 00:06:33,440
and as i've shown before uh

00:06:31,360 --> 00:06:35,120
this is the same food that you saw in

00:06:33,440 --> 00:06:38,400
the previous slide so we could

00:06:35,120 --> 00:06:40,560
try put the try block on the foo and

00:06:38,400 --> 00:06:42,080
and the throws and then we can have a

00:06:40,560 --> 00:06:45,120
catch that goes

00:06:42,080 --> 00:06:46,160
um it tries to catch a specific arrow

00:06:45,120 --> 00:06:50,080
type

00:06:46,160 --> 00:06:50,400
or we can just uh uh have a catch that

00:06:50,080 --> 00:06:53,440
uh

00:06:50,400 --> 00:06:55,520
catch in a general uh general type

00:06:53,440 --> 00:06:56,720
and here we can also redelegate the

00:06:55,520 --> 00:07:00,840
responsibility for

00:06:56,720 --> 00:07:03,840
error for the error uh by using throw

00:07:00,840 --> 00:07:06,240
um okay uh

00:07:03,840 --> 00:07:07,919
so this is our main function and it have

00:07:06,240 --> 00:07:09,440
uh the bar function that we saw in the

00:07:07,919 --> 00:07:12,800
previous slide and the bar

00:07:09,440 --> 00:07:16,400
contains the foo and again we can uh

00:07:12,800 --> 00:07:18,960
catch the error here but we could also

00:07:16,400 --> 00:07:19,599
uh redelegate the responsibility and

00:07:18,960 --> 00:07:22,800
that i'm

00:07:19,599 --> 00:07:25,280
i mean in court remarks of course uh but

00:07:22,800 --> 00:07:26,639
in a way uh when we decide not to catch

00:07:25,280 --> 00:07:29,120
the error we're sort of

00:07:26,639 --> 00:07:30,720
uh passing the responsibility to our

00:07:29,120 --> 00:07:34,240
operation system

00:07:30,720 --> 00:07:37,599
so that's a way of of looking at

00:07:34,240 --> 00:07:41,520
the exception mechanism being propagated

00:07:37,599 --> 00:07:46,000
outside of our program scope

00:07:41,520 --> 00:07:49,039
so let's go back a few years

00:07:46,000 --> 00:07:49,520
so in the beginning there were c then

00:07:49,039 --> 00:07:52,720
came

00:07:49,520 --> 00:07:55,759
c with classes actually

00:07:52,720 --> 00:07:58,319
uh then came c pass but actually

00:07:55,759 --> 00:07:59,199
then came c plus plus with exceptions

00:07:58,319 --> 00:08:00,879
because

00:07:59,199 --> 00:08:02,560
i'm not i'm not sure if you're aware

00:08:00,879 --> 00:08:04,560
exception mechanism was something that

00:08:02,560 --> 00:08:05,120
was considered very early at the

00:08:04,560 --> 00:08:08,639
beginning

00:08:05,120 --> 00:08:11,039
of siplus class and

00:08:08,639 --> 00:08:12,160
um and and we're gonna see in the

00:08:11,039 --> 00:08:15,120
following slides

00:08:12,160 --> 00:08:17,280
uh but clearly error handling was uh a

00:08:15,120 --> 00:08:19,360
major thing

00:08:17,280 --> 00:08:21,199
so let's go back a few years as i said

00:08:19,360 --> 00:08:22,400
and see the alternatives that were

00:08:21,199 --> 00:08:25,440
existed

00:08:22,400 --> 00:08:28,400
they existed so we have error codes

00:08:25,440 --> 00:08:29,199
that basically return value and this is

00:08:28,400 --> 00:08:31,280
like the c

00:08:29,199 --> 00:08:33,599
style error handling so we have a

00:08:31,280 --> 00:08:36,800
function it does something if it fails

00:08:33,599 --> 00:08:41,839
it can return a value that is not zero

00:08:36,800 --> 00:08:41,839
and usually that's a um

00:08:44,159 --> 00:08:50,720
that's the common uh way to do it

00:08:47,200 --> 00:08:52,240
and we have a function bar and it checks

00:08:50,720 --> 00:08:54,480
the return value from foo

00:08:52,240 --> 00:08:55,600
and it can return an error and here we

00:08:54,480 --> 00:08:57,839
can do something

00:08:55,600 --> 00:08:59,360
uh this is the way to propagate up to

00:08:57,839 --> 00:09:00,240
the main and here we can do something

00:08:59,360 --> 00:09:04,240
that regards

00:09:00,240 --> 00:09:06,560
uh the failure of r and another way to

00:09:04,240 --> 00:09:08,959
approach errors uh that was existed

00:09:06,560 --> 00:09:09,920
before c plus pass was using a global it

00:09:08,959 --> 00:09:12,959
could be aeronaut

00:09:09,920 --> 00:09:13,760
for system reason i use it it could be

00:09:12,959 --> 00:09:16,240
air def

00:09:13,760 --> 00:09:17,120
user defined global but the principle is

00:09:16,240 --> 00:09:20,240
the same

00:09:17,120 --> 00:09:23,680
uh you do something failure in its

00:09:20,240 --> 00:09:27,760
the global and uh the

00:09:23,680 --> 00:09:29,200
uh the advantage of this method is that

00:09:27,760 --> 00:09:31,839
you don't really have to

00:09:29,200 --> 00:09:32,800
manually propagate the error you could

00:09:31,839 --> 00:09:36,240
just check

00:09:32,800 --> 00:09:36,720
uh the error wherever in whatever scope

00:09:36,240 --> 00:09:40,720
that

00:09:36,720 --> 00:09:43,200
interests you so this is somewhat um

00:09:40,720 --> 00:09:44,959
i would say in some ways it could have

00:09:43,200 --> 00:09:47,120
been considered better in some ways

00:09:44,959 --> 00:09:48,160
it's not uh clearly globals have their

00:09:47,120 --> 00:09:51,040
own issues

00:09:48,160 --> 00:09:51,680
but uh just notice this uh this is an

00:09:51,040 --> 00:09:56,640
interesting

00:09:51,680 --> 00:09:59,279
um difference and um

00:09:56,640 --> 00:09:59,839
okay and and i just wanted uh also to

00:09:59,279 --> 00:10:03,120
mention

00:09:59,839 --> 00:10:03,120
that um

00:10:03,519 --> 00:10:08,880
okay sorry all right so i just wanted to

00:10:07,279 --> 00:10:11,279
mention that uh

00:10:08,880 --> 00:10:12,560
this is the common practice uh also

00:10:11,279 --> 00:10:16,640
nowadays

00:10:12,560 --> 00:10:19,839
not for c so let's continue

00:10:16,640 --> 00:10:22,240
so why exceptions uh exceptions

00:10:19,839 --> 00:10:23,440
make it easier to adhere to the best

00:10:22,240 --> 00:10:25,600
practices

00:10:23,440 --> 00:10:27,040
begin error handling a more regular

00:10:25,600 --> 00:10:30,640
style

00:10:27,040 --> 00:10:32,800
makes air handling code more readable

00:10:30,640 --> 00:10:34,560
and it makes error handling code more

00:10:32,800 --> 00:10:37,360
amenable to tools

00:10:34,560 --> 00:10:38,079
so this is actually a quote from the

00:10:37,360 --> 00:10:40,800
first uh

00:10:38,079 --> 00:10:42,959
paper that suggested exam exceptions to

00:10:40,800 --> 00:10:46,160
c plus plus standard

00:10:42,959 --> 00:10:47,680
and the design of the of this uh of the

00:10:46,160 --> 00:10:49,440
mechanism of exceptions

00:10:47,680 --> 00:10:51,160
took approximately five years it

00:10:49,440 --> 00:10:55,680
finished in

00:10:51,160 --> 00:10:55,680
1988 as i said very early

00:10:56,800 --> 00:11:02,880
um okay so

00:11:00,000 --> 00:11:03,839
let's uh this is a quote from design and

00:11:02,880 --> 00:11:07,279
evolution

00:11:03,839 --> 00:11:09,360
so in the original design of c plus plus

00:11:07,279 --> 00:11:10,800
exceptions were considered by but

00:11:09,360 --> 00:11:12,480
postponed because

00:11:10,800 --> 00:11:14,880
there wasn't enough time to do a

00:11:12,480 --> 00:11:16,560
thorough job for of exploring the design

00:11:14,880 --> 00:11:18,640
and implementation issues

00:11:16,560 --> 00:11:19,920
and because of fears of the complex

00:11:18,640 --> 00:11:23,040
complexity

00:11:19,920 --> 00:11:24,000
they might add to an implementation in

00:11:23,040 --> 00:11:26,240
particular

00:11:24,000 --> 00:11:28,240
it was understood that poor design could

00:11:26,240 --> 00:11:28,720
cause runtime overhead and significant

00:11:28,240 --> 00:11:32,560
increase

00:11:28,720 --> 00:11:35,279
in porting times so as i said exceptions

00:11:32,560 --> 00:11:38,560
were considered very early

00:11:35,279 --> 00:11:40,720
and you can see here some responses

00:11:38,560 --> 00:11:42,880
to the original exception mechanism to

00:11:40,720 --> 00:11:45,279
the paper that we saw before

00:11:42,880 --> 00:11:47,760
and you can see the responses were from

00:11:45,279 --> 00:11:50,160
a right spectrum of companies you can

00:11:47,760 --> 00:11:54,000
see here microsoft and ericsson

00:11:50,160 --> 00:11:57,200
and apple ibm others as well that

00:11:54,000 --> 00:11:58,639
beyond approach to and

00:11:57,200 --> 00:12:00,720
again this was something that was

00:11:58,639 --> 00:12:02,639
debated very broadly

00:12:00,720 --> 00:12:03,839
and i'll just mention here that some

00:12:02,639 --> 00:12:05,600
voices have claimed that

00:12:03,839 --> 00:12:08,839
exception may lead to bad quality

00:12:05,600 --> 00:12:11,440
program in a very early stage of this

00:12:08,839 --> 00:12:13,040
design and we might we'll go back to

00:12:11,440 --> 00:12:16,560
that later and think

00:12:13,040 --> 00:12:18,320
where did it came from but nevertheless

00:12:16,560 --> 00:12:20,320
exception mechanism was accepted to the

00:12:18,320 --> 00:12:22,880
first standard of c plus plus

00:12:20,320 --> 00:12:25,839
and here you can see uh the section

00:12:22,880 --> 00:12:25,839
regards that

00:12:25,920 --> 00:12:29,279
so the following assumptions were made

00:12:28,560 --> 00:12:33,279
regarding

00:12:29,279 --> 00:12:36,000
exception usage in in this early design

00:12:33,279 --> 00:12:36,800
and this is again from the paper uh of

00:12:36,000 --> 00:12:38,639
defining

00:12:36,800 --> 00:12:40,399
the design of exceptions so exceptions

00:12:38,639 --> 00:12:43,360
are used primarily for

00:12:40,399 --> 00:12:46,079
error handling exception handlers are

00:12:43,360 --> 00:12:48,959
rare compared to function definitions

00:12:46,079 --> 00:12:50,399
exceptions occur infrequently compared

00:12:48,959 --> 00:12:52,320
to function calls

00:12:50,399 --> 00:12:53,519
and exceptions are language level

00:12:52,320 --> 00:12:55,040
concept

00:12:53,519 --> 00:12:56,720
so we're going to go over those

00:12:55,040 --> 00:12:59,120
assumptions and see

00:12:56,720 --> 00:13:00,800
how do they suit how do they fit the

00:12:59,120 --> 00:13:03,440
current version of exceptions that we

00:13:00,800 --> 00:13:06,240
have today

00:13:03,440 --> 00:13:08,639
so original design exceptions are used

00:13:06,240 --> 00:13:10,639
primarily for error handling

00:13:08,639 --> 00:13:13,839
so it's true that a control flow

00:13:10,639 --> 00:13:17,680
management is discouraged by the formal

00:13:13,839 --> 00:13:18,320
standard publications and the existing

00:13:17,680 --> 00:13:21,600
practice

00:13:18,320 --> 00:13:23,600
really rarely use con exceptions for

00:13:21,600 --> 00:13:24,399
control for all management but do notice

00:13:23,600 --> 00:13:27,519
that

00:13:24,399 --> 00:13:30,320
um simplest does not return to the

00:13:27,519 --> 00:13:31,680
to the throwing code so it's a design

00:13:30,320 --> 00:13:35,120
decision that were made

00:13:31,680 --> 00:13:37,680
again very early it goes back uh to the

00:13:35,120 --> 00:13:37,680
catch block

00:13:37,920 --> 00:13:41,360
exception handlers are rare compared to

00:13:39,760 --> 00:13:43,040
function definition so

00:13:41,360 --> 00:13:44,480
it's true that the formal usage

00:13:43,040 --> 00:13:48,320
recommendation say

00:13:44,480 --> 00:13:50,959
that exceptions are costly and uh

00:13:48,320 --> 00:13:51,519
clearly you don't want to use them in a

00:13:50,959 --> 00:13:55,440
in a

00:13:51,519 --> 00:13:57,920
time sensitive in real time code

00:13:55,440 --> 00:13:59,920
if thrown we've reached to a point where

00:13:57,920 --> 00:14:01,360
uh cost is the list of our problems so

00:13:59,920 --> 00:14:03,920
they are used in

00:14:01,360 --> 00:14:05,519
in code bases that are not sensitive to

00:14:03,920 --> 00:14:07,440
that

00:14:05,519 --> 00:14:09,839
perceptions occur infrequently compared

00:14:07,440 --> 00:14:13,360
to function calls that's also true

00:14:09,839 --> 00:14:16,880
standard library though standard library

00:14:13,360 --> 00:14:18,560
does use exceptions extensively so

00:14:16,880 --> 00:14:21,040
and this is one of the main issues that

00:14:18,560 --> 00:14:23,040
we have today and it is common

00:14:21,040 --> 00:14:24,160
though it's common to use alternative

00:14:23,040 --> 00:14:26,720
error handling

00:14:24,160 --> 00:14:28,240
uh because of this uh because of this

00:14:26,720 --> 00:14:31,519
and also to avoid using

00:14:28,240 --> 00:14:33,920
standard library and exceptions are

00:14:31,519 --> 00:14:35,920
language level concept that's true uh

00:14:33,920 --> 00:14:39,920
they're platform independent and

00:14:35,920 --> 00:14:43,360
uh the api is defined uh

00:14:39,920 --> 00:14:46,399
uh two to c plus plus

00:14:43,360 --> 00:14:49,519
but a general concept is

00:14:46,399 --> 00:14:51,120
is really something across different uh

00:14:49,519 --> 00:14:54,480
compilation

00:14:51,120 --> 00:14:56,320
sorry uh development languages

00:14:54,480 --> 00:14:58,079
uh i also want to mention that other

00:14:56,320 --> 00:15:00,800
languages do have back parts

00:14:58,079 --> 00:15:01,440
best practices of uh managing control

00:15:00,800 --> 00:15:03,760
flow

00:15:01,440 --> 00:15:04,639
for the exception mechanism i had a talk

00:15:03,760 --> 00:15:07,920
about it yes

00:15:04,639 --> 00:15:11,199
yesterday um

00:15:07,920 --> 00:15:15,360
with some very

00:15:11,199 --> 00:15:17,440
nice people so um exception overhead

00:15:15,360 --> 00:15:19,519
so the main difference between c and c

00:15:17,440 --> 00:15:21,279
plus plus is the cleanup process is now

00:15:19,519 --> 00:15:22,720
part of the language in constructors and

00:15:21,279 --> 00:15:25,120
these structures clearly

00:15:22,720 --> 00:15:26,880
so but by using such jump and long jump

00:15:25,120 --> 00:15:27,839
we break the contract between the user

00:15:26,880 --> 00:15:29,920
and the language so

00:15:27,839 --> 00:15:32,399
clearly we can't use uh set job and long

00:15:29,920 --> 00:15:34,880
jump just like in c plus plus

00:15:32,399 --> 00:15:35,759
i will also just mention two more terms

00:15:34,880 --> 00:15:37,360
a happy path

00:15:35,759 --> 00:15:40,240
is the default scenario with no

00:15:37,360 --> 00:15:41,279
exceptions wrong and a set path is the

00:15:40,240 --> 00:15:45,040
path which uh

00:15:41,279 --> 00:15:46,959
indicate includes error and i just

00:15:45,040 --> 00:15:49,519
want to mention here as well that msbc

00:15:46,959 --> 00:15:53,279
supports a different behavior for the

00:15:49,519 --> 00:15:55,040
jump uh functions uh but we're not gonna

00:15:53,279 --> 00:15:57,199
focus uh here in the stock we're gonna

00:15:55,040 --> 00:15:59,360
focus on uh gcc

00:15:57,199 --> 00:16:02,720
uh particularly but there are other

00:15:59,360 --> 00:16:05,440
things uh exists as well

00:16:02,720 --> 00:16:06,160
so uh just a few words about happy path

00:16:05,440 --> 00:16:08,639
in this slide

00:16:06,160 --> 00:16:09,759
i've added after uh giving this talk

00:16:08,639 --> 00:16:12,959
again as i said in a

00:16:09,759 --> 00:16:13,440
make user group because i had a question

00:16:12,959 --> 00:16:16,880
about it

00:16:13,440 --> 00:16:18,639
so um i don't want to focus on

00:16:16,880 --> 00:16:20,959
uh in this talk i don't want to focus on

00:16:18,639 --> 00:16:24,160
comparing happy paths to setback

00:16:20,959 --> 00:16:26,639
it's clear we will see a short bet

00:16:24,160 --> 00:16:27,680
benchmark later but it's clear that it's

00:16:26,639 --> 00:16:30,240
costly

00:16:27,680 --> 00:16:30,880
uh but i just wanna uh i just wanna

00:16:30,240 --> 00:16:33,680
point out

00:16:30,880 --> 00:16:34,399
the the overhead that we do get on the

00:16:33,680 --> 00:16:37,519
happy path

00:16:34,399 --> 00:16:41,279
so for return values of course we have

00:16:37,519 --> 00:16:43,440
um uh the the fact that uh return

00:16:41,279 --> 00:16:45,600
uh the error is occupying the return

00:16:43,440 --> 00:16:47,839
value so now we can't use it freely

00:16:45,600 --> 00:16:50,079
and it adds the need to manually

00:16:47,839 --> 00:16:52,560
propagate the error as we saw before

00:16:50,079 --> 00:16:53,839
and it adds an if statement which

00:16:52,560 --> 00:16:58,639
eventually translates

00:16:53,839 --> 00:17:01,440
into instructions by using globals

00:16:58,639 --> 00:17:03,279
clearly as i said the multithreading is

00:17:01,440 --> 00:17:05,520
out of outside of the scope for this

00:17:03,279 --> 00:17:10,640
talk but clearly it

00:17:05,520 --> 00:17:13,280
adds um it's a problem in a multi-uh

00:17:10,640 --> 00:17:15,600
multi-threaded environment and it's

00:17:13,280 --> 00:17:18,240
limited

00:17:15,600 --> 00:17:19,760
you have to manage the global in a way

00:17:18,240 --> 00:17:22,959
and exceptions

00:17:19,760 --> 00:17:24,720
have other overhead that is

00:17:22,959 --> 00:17:26,959
for the happy path so first of all when

00:17:24,720 --> 00:17:30,080
you do compile with exceptions you need

00:17:26,959 --> 00:17:33,520
rtti information and there's also

00:17:30,080 --> 00:17:35,600
catch tables created and uh

00:17:33,520 --> 00:17:37,200
additional assembly that is called the

00:17:35,600 --> 00:17:40,320
landing pad and

00:17:37,200 --> 00:17:42,480
is actually created

00:17:40,320 --> 00:17:43,919
in a different location than the regular

00:17:42,480 --> 00:17:47,039
control flow

00:17:43,919 --> 00:17:50,240
to have in order to avoid

00:17:47,039 --> 00:17:53,520
uh to avoid uh getting cold uh

00:17:50,240 --> 00:17:56,480
code into into our realm so basically

00:17:53,520 --> 00:17:57,520
uh there's the hat path and uh and the

00:17:56,480 --> 00:17:59,440
hat code that is

00:17:57,520 --> 00:18:01,600
on the cache and if there's exception

00:17:59,440 --> 00:18:04,720
then we'll jump to a code

00:18:01,600 --> 00:18:05,919
a code code and of course there's the

00:18:04,720 --> 00:18:09,760
runtime overhead

00:18:05,919 --> 00:18:10,799
that just loading cold code from memory

00:18:09,760 --> 00:18:13,760
in case they are

00:18:10,799 --> 00:18:16,559
turned but again this is just to

00:18:13,760 --> 00:18:19,039
understand what happens there

00:18:16,559 --> 00:18:20,960
so let's go deeper into the setback so

00:18:19,039 --> 00:18:21,840
now we're focusing on the step path of

00:18:20,960 --> 00:18:25,039
the case of

00:18:21,840 --> 00:18:26,000
throwing errors um for interceptions of

00:18:25,039 --> 00:18:29,039
course sorry

00:18:26,000 --> 00:18:31,919
and i've compared the throwing uh

00:18:29,039 --> 00:18:33,760
throwing mechanism to return value code

00:18:31,919 --> 00:18:35,919
return code value

00:18:33,760 --> 00:18:36,799
and just to make sure that we are on the

00:18:35,919 --> 00:18:39,919
same page

00:18:36,799 --> 00:18:42,160
um we i'm using here throw by value

00:18:39,919 --> 00:18:44,240
catch by reference of course

00:18:42,160 --> 00:18:45,600
so this is the mini benchmark and you

00:18:44,240 --> 00:18:49,600
can see here that

00:18:45,600 --> 00:18:53,760
exceptions are uh 435 times

00:18:49,600 --> 00:18:57,280
slower than the return value

00:18:53,760 --> 00:19:00,799
and the size i've tested this on

00:18:57,280 --> 00:19:04,640
x x 86 and an arm and the size

00:19:00,799 --> 00:19:07,760
is uh more noticeably larger here on

00:19:04,640 --> 00:19:10,000
arm but yeah you can see that

00:19:07,760 --> 00:19:11,120
there is overhead again this is the

00:19:10,000 --> 00:19:13,440
setback

00:19:11,120 --> 00:19:14,559
and there's a clue clear of the

00:19:13,440 --> 00:19:18,080
observation of the

00:19:14,559 --> 00:19:19,039
overhead sorry and as i said they

00:19:18,080 --> 00:19:21,760
perform worse

00:19:19,039 --> 00:19:21,760
on arm

00:19:22,960 --> 00:19:27,200
so two main implementations for

00:19:26,160 --> 00:19:29,200
exceptions exist

00:19:27,200 --> 00:19:30,559
the first one is tablevest which is what

00:19:29,200 --> 00:19:32,720
gcc and clang

00:19:30,559 --> 00:19:34,400
are using and it's better for happy path

00:19:32,720 --> 00:19:37,280
results and the second one

00:19:34,400 --> 00:19:38,960
is firm based which is also called a

00:19:37,280 --> 00:19:42,640
code approach

00:19:38,960 --> 00:19:44,480
sorry and msvc uh uses that but this is

00:19:42,640 --> 00:19:47,840
better for set path results

00:19:44,480 --> 00:19:49,679
i have focused on gcc both because this

00:19:47,840 --> 00:19:50,000
is a platform i'm mainly working with

00:19:49,679 --> 00:19:53,919
but

00:19:50,000 --> 00:19:56,400
also i mean linux and gcc but also

00:19:53,919 --> 00:19:57,120
because i think it makes more sense the

00:19:56,400 --> 00:20:00,720
assumption

00:19:57,120 --> 00:20:04,240
for optimizing better happy path

00:20:00,720 --> 00:20:06,960
makes more sense to me so

00:20:04,240 --> 00:20:07,520
uh table best implementation as i said

00:20:06,960 --> 00:20:10,240
have

00:20:07,520 --> 00:20:10,960
uh some overhead in the program i've

00:20:10,240 --> 00:20:14,240
mentioned it

00:20:10,960 --> 00:20:14,880
before uh but this is i'm now referring

00:20:14,240 --> 00:20:17,600
to the

00:20:14,880 --> 00:20:18,720
to the to the case that we're using uh

00:20:17,600 --> 00:20:21,600
the setback

00:20:18,720 --> 00:20:23,679
so again our tti will be generated and

00:20:21,600 --> 00:20:26,400
this is for both cases of course

00:20:23,679 --> 00:20:28,000
exception handlers will be defined and

00:20:26,400 --> 00:20:29,600
each catching function will contain

00:20:28,000 --> 00:20:32,240
additional information

00:20:29,600 --> 00:20:33,919
of the catchable objects and and this

00:20:32,240 --> 00:20:34,400
time we're actually going to use this

00:20:33,919 --> 00:20:37,440
code

00:20:34,400 --> 00:20:40,240
uh when foreign

00:20:37,440 --> 00:20:42,480
so the functionality is uh basically

00:20:40,240 --> 00:20:46,000
implemented in two main libraries

00:20:42,480 --> 00:20:48,159
uh again on gcc so we have lib gcc

00:20:46,000 --> 00:20:50,559
which is containing which contains the

00:20:48,159 --> 00:20:52,880
functionality of stack unwinding

00:20:50,559 --> 00:20:54,320
and frame management and we have uh loop

00:20:52,880 --> 00:20:56,320
stud c plus plus

00:20:54,320 --> 00:20:57,760
contains the functionality of exception

00:20:56,320 --> 00:21:01,200
handling uh

00:20:57,760 --> 00:21:01,200
this one's uh is

00:21:01,280 --> 00:21:07,679
aligned to eternium c

00:21:04,640 --> 00:21:09,440
x x and there's also a tenure document

00:21:07,679 --> 00:21:11,039
regarding this functionality but it is

00:21:09,440 --> 00:21:14,720
language independent

00:21:11,039 --> 00:21:16,400
and here i've added uh just the list of

00:21:14,720 --> 00:21:19,280
the functions that are

00:21:16,400 --> 00:21:20,240
part of the of handling uh the exception

00:21:19,280 --> 00:21:23,120
mechanism

00:21:20,240 --> 00:21:25,120
so that you can you don't have to read

00:21:23,120 --> 00:21:28,840
all the names but you can

00:21:25,120 --> 00:21:30,000
definitely see that there's a lot of

00:21:28,840 --> 00:21:31,919
them

00:21:30,000 --> 00:21:33,919
uh by the way i haven't mentioned that

00:21:31,919 --> 00:21:37,039
i'll take uh questions at the end

00:21:33,919 --> 00:21:38,080
because this is a quite a long talk i'll

00:21:37,039 --> 00:21:39,840
uh be happy to

00:21:38,080 --> 00:21:41,200
be at the table and get your questions

00:21:39,840 --> 00:21:44,400
later so

00:21:41,200 --> 00:21:47,520
the stages of exception rising progress

00:21:44,400 --> 00:21:50,159
so uh sorry process so first of all we

00:21:47,520 --> 00:21:53,520
allocate the exception

00:21:50,159 --> 00:21:57,200
and this is a call for uh uh sc

00:21:53,520 --> 00:22:00,240
uh allocate exception uh function

00:21:57,200 --> 00:22:03,600
then uh we throw that means that

00:22:00,240 --> 00:22:06,799
uh there's a call to throw and

00:22:03,600 --> 00:22:10,080
the look of phase starts and then uh

00:22:06,799 --> 00:22:13,120
in case uh there's

00:22:10,080 --> 00:22:14,480
some uh catch statement that deals with

00:22:13,120 --> 00:22:17,280
this type of nro

00:22:14,480 --> 00:22:17,760
then we can also get to the cleanup

00:22:17,280 --> 00:22:20,799
phase

00:22:17,760 --> 00:22:22,960
and i'll explain again a bit later

00:22:20,799 --> 00:22:25,440
just notice that in case of a failure

00:22:22,960 --> 00:22:29,520
there's a emergency

00:22:25,440 --> 00:22:32,159
emergency space located and you could

00:22:29,520 --> 00:22:34,960
uh and the exception will be allocated

00:22:32,159 --> 00:22:38,640
only in certain conditions

00:22:34,960 --> 00:22:42,320
so for example uh it could be only

00:22:38,640 --> 00:22:45,440
under one kilobyte it can only have

00:22:42,320 --> 00:22:47,200
up to four um exceptions in a single

00:22:45,440 --> 00:22:49,679
thread

00:22:47,200 --> 00:22:51,039
and other conditions that relates to

00:22:49,679 --> 00:22:52,559
multi-threaded

00:22:51,039 --> 00:22:54,080
environment as i said i'm not going to

00:22:52,559 --> 00:22:56,400
go deeper into that

00:22:54,080 --> 00:22:58,320
so this is just in case that we failed

00:22:56,400 --> 00:22:59,600
in allocating the exception exception in

00:22:58,320 --> 00:23:02,320
general

00:22:59,600 --> 00:23:04,240
can be allocated in whatever size that

00:23:02,320 --> 00:23:07,039
we want

00:23:04,240 --> 00:23:08,000
so let's go deeper into those phases

00:23:07,039 --> 00:23:10,240
that i've mentioned

00:23:08,000 --> 00:23:12,640
so the lookup phase triggers start

00:23:10,240 --> 00:23:15,840
unwinding a call

00:23:12,640 --> 00:23:19,200
for this function called raise exception

00:23:15,840 --> 00:23:21,919
and it passes the flag search phase so

00:23:19,200 --> 00:23:23,600
in k we're going over the stack and

00:23:21,919 --> 00:23:26,159
we're basically looking for

00:23:23,600 --> 00:23:27,600
a function that catch the uh type of an

00:23:26,159 --> 00:23:29,760
error that we've thrown

00:23:27,600 --> 00:23:30,640
and in case of a failure uh there's

00:23:29,760 --> 00:23:32,960
instant call for

00:23:30,640 --> 00:23:35,760
terminators to terminate clearly there's

00:23:32,960 --> 00:23:38,720
no uh cleaning

00:23:35,760 --> 00:23:39,360
uh resources and in case of success we

00:23:38,720 --> 00:23:42,960
return

00:23:39,360 --> 00:23:45,760
uh a handler found and in that

00:23:42,960 --> 00:23:47,440
point we're going back down uh the stack

00:23:45,760 --> 00:23:50,400
and then we start the cleanup phase

00:23:47,440 --> 00:23:51,200
we triggers uh the same function with a

00:23:50,400 --> 00:23:54,640
different flag

00:23:51,200 --> 00:23:58,000
called cleanup phase so

00:23:54,640 --> 00:24:00,799
um okay so the cleaning progress

00:23:58,000 --> 00:24:02,080
process is as follows the person

00:24:00,799 --> 00:24:04,559
personality routine

00:24:02,080 --> 00:24:05,279
uh cleaning the stack frame takes over

00:24:04,559 --> 00:24:07,600
so

00:24:05,279 --> 00:24:08,400
basically we have reached to our certain

00:24:07,600 --> 00:24:11,440
stock frame

00:24:08,400 --> 00:24:11,840
and we're cleaning it then we continue

00:24:11,440 --> 00:24:15,279
you

00:24:11,840 --> 00:24:17,600
wait by calling unwind you resume

00:24:15,279 --> 00:24:18,880
uh when we reach to a stock frame that

00:24:17,600 --> 00:24:22,320
actually contains the

00:24:18,880 --> 00:24:26,159
catch statement uh it suits the

00:24:22,320 --> 00:24:28,880
the certain type then uh we begin

00:24:26,159 --> 00:24:29,360
we call begin catch and and catch begin

00:24:28,880 --> 00:24:31,360
catch

00:24:29,360 --> 00:24:32,400
basically treats the exception modify

00:24:31,360 --> 00:24:35,279
relevant data

00:24:32,400 --> 00:24:36,880
is sort of global data that counts the

00:24:35,279 --> 00:24:37,600
number of exceptions that are currently

00:24:36,880 --> 00:24:40,240
active

00:24:37,600 --> 00:24:41,200
and it decreases the number of

00:24:40,240 --> 00:24:44,240
exceptions

00:24:41,200 --> 00:24:47,600
and then

00:24:44,240 --> 00:24:48,320
it can uh sorry and catch can call to

00:24:47,600 --> 00:24:50,559
terminate

00:24:48,320 --> 00:24:52,320
or rethrow according to success or

00:24:50,559 --> 00:24:54,480
failure of the process

00:24:52,320 --> 00:24:56,159
uh if for example we needed to do

00:24:54,480 --> 00:24:59,600
something in the catch and we

00:24:56,159 --> 00:25:00,159
failed then we'll terminate and if free

00:24:59,600 --> 00:25:03,120
throw

00:25:00,159 --> 00:25:05,440
is uh is called then we just continue

00:25:03,120 --> 00:25:08,480
continue unwinding the stack

00:25:05,440 --> 00:25:10,400
so to go over this process with uh

00:25:08,480 --> 00:25:11,600
with drawings and to make everything a

00:25:10,400 --> 00:25:15,200
bit more clear

00:25:11,600 --> 00:25:17,760
let's do that uh that overview

00:25:15,200 --> 00:25:19,039
so the complete progress is this follow

00:25:17,760 --> 00:25:21,440
we have a subroutine

00:25:19,039 --> 00:25:23,440
and uh this is the nested subroutine

00:25:21,440 --> 00:25:25,279
subroutine on top and the one on top

00:25:23,440 --> 00:25:26,480
that we just saw before for in this

00:25:25,279 --> 00:25:30,240
example it could be

00:25:26,480 --> 00:25:31,440
the barfu in maine so first we allocate

00:25:30,240 --> 00:25:33,919
the exception

00:25:31,440 --> 00:25:35,039
then in case of a failure in case we

00:25:33,919 --> 00:25:37,600
couldn't allocate

00:25:35,039 --> 00:25:39,360
then we just call stood terminate in

00:25:37,600 --> 00:25:42,000
case of success

00:25:39,360 --> 00:25:43,679
we throw which means uh we start the

00:25:42,000 --> 00:25:44,080
look of phase and the look of phase is

00:25:43,679 --> 00:25:46,799
go

00:25:44,080 --> 00:25:47,440
goes by the uh up the stack and looking

00:25:46,799 --> 00:25:51,440
for

00:25:47,440 --> 00:25:53,520
our appropriate function

00:25:51,440 --> 00:25:54,640
and in case of a failure again we

00:25:53,520 --> 00:25:57,120
terminate

00:25:54,640 --> 00:25:58,559
in case of success we start the cleanup

00:25:57,120 --> 00:26:01,279
phase so we go back down

00:25:58,559 --> 00:26:02,799
and we start the cleanup phase and we do

00:26:01,279 --> 00:26:05,760
the stuck unwinding

00:26:02,799 --> 00:26:06,640
we look for the proper catch and we call

00:26:05,760 --> 00:26:10,240
the

00:26:06,640 --> 00:26:12,640
cleanup methods for each stock frame

00:26:10,240 --> 00:26:16,640
that we're closing

00:26:12,640 --> 00:26:19,120
and in case we found a catch then uh the

00:26:16,640 --> 00:26:19,840
we transform here and then we zoom

00:26:19,120 --> 00:26:22,159
execution

00:26:19,840 --> 00:26:24,240
on the catch frame and if a final block

00:26:22,159 --> 00:26:29,279
exists we also execute it

00:26:24,240 --> 00:26:29,279
and then we resume in the catch block

00:26:29,360 --> 00:26:34,720
so let's have another design overview

00:26:32,640 --> 00:26:38,559
but this time let's look at the details

00:26:34,720 --> 00:26:42,080
of what are the things that we've

00:26:38,559 --> 00:26:45,279
uh we've defined uh want in the

00:26:42,080 --> 00:26:47,120
in the exception mechanism so these are

00:26:45,279 --> 00:26:50,400
the assumptions from their digital

00:26:47,120 --> 00:26:52,159
uh design of uh

00:26:50,400 --> 00:26:55,120
from embedded perspective of the

00:26:52,159 --> 00:26:55,120
exception mechanism

00:26:55,360 --> 00:27:00,080
so we want a typesafe transmission and

00:26:58,400 --> 00:27:03,279
that's clear

00:27:00,080 --> 00:27:04,559
we want no added cost uh unless with

00:27:03,279 --> 00:27:07,120
foreign exception that's

00:27:04,559 --> 00:27:09,840
uh close to what we have today uh if you

00:27:07,120 --> 00:27:13,600
put aside the size and rtti

00:27:09,840 --> 00:27:16,720
uh generation uh handlers can be written

00:27:13,600 --> 00:27:18,559
to catch a group of exceptions so um

00:27:16,720 --> 00:27:20,559
again i'm coming from the embedded world

00:27:18,559 --> 00:27:22,960
and i'm looking for

00:27:20,559 --> 00:27:24,000
assumptions that could be costly so i

00:27:22,960 --> 00:27:28,000
think this one

00:27:24,000 --> 00:27:29,919
might uh we want to allow cooperation

00:27:28,000 --> 00:27:30,399
with other languages especially with c

00:27:29,919 --> 00:27:33,279
that

00:27:30,399 --> 00:27:34,320
actually makes sense and i wouldn't

00:27:33,279 --> 00:27:37,679
think that we should

00:27:34,320 --> 00:27:40,720
uh avoid that but that's something that

00:27:37,679 --> 00:27:42,640
is part of our mechanism uh

00:27:40,720 --> 00:27:44,559
exception occur infrequently compared to

00:27:42,640 --> 00:27:47,919
function calls so that's also

00:27:44,559 --> 00:27:48,799
uh great and i actually i'll show later

00:27:47,919 --> 00:27:51,520
that

00:27:48,799 --> 00:27:52,320
the majority of the communities going

00:27:51,520 --> 00:27:56,080
forward

00:27:52,320 --> 00:27:58,559
having even less exceptions

00:27:56,080 --> 00:28:00,240
types of transmission of arbitrary and

00:27:58,559 --> 00:28:02,320
art of information so

00:28:00,240 --> 00:28:03,279
when i look at this demand i figure i

00:28:02,320 --> 00:28:06,559
thought uh

00:28:03,279 --> 00:28:09,679
that this might be a bit a lot to ask

00:28:06,559 --> 00:28:10,880
so we could also uh consider a design

00:28:09,679 --> 00:28:13,600
that doesn't have

00:28:10,880 --> 00:28:14,159
this requirement and exceptions are

00:28:13,600 --> 00:28:16,960
primarily

00:28:14,159 --> 00:28:17,760
uh for error handling uh and not uh code

00:28:16,960 --> 00:28:20,799
management

00:28:17,760 --> 00:28:21,840
so again uh this is these are uh the

00:28:20,799 --> 00:28:24,640
assumptions

00:28:21,840 --> 00:28:25,600
um i would i would think that this is a

00:28:24,640 --> 00:28:27,520
good assumption but

00:28:25,600 --> 00:28:29,679
actually i had some talks during this

00:28:27,520 --> 00:28:31,440
conference with people and

00:28:29,679 --> 00:28:32,799
they convinced me that this this could

00:28:31,440 --> 00:28:35,279
be um

00:28:32,799 --> 00:28:36,080
considered so again uh i'm not uh

00:28:35,279 --> 00:28:38,159
suggesting

00:28:36,080 --> 00:28:39,760
speaking here i'm just saying that we

00:28:38,159 --> 00:28:42,000
should really look

00:28:39,760 --> 00:28:43,440
look into those assumptions and and

00:28:42,000 --> 00:28:46,559
consider reconsider them

00:28:43,440 --> 00:28:50,159
maybe so

00:28:46,559 --> 00:28:53,279
um okay so let's take

00:28:50,159 --> 00:28:56,320
let's take a step back and see uh how

00:28:53,279 --> 00:28:59,520
the exception mechanism is

00:28:56,320 --> 00:29:02,799
relating to our general um

00:28:59,520 --> 00:29:05,039
to our general system

00:29:02,799 --> 00:29:06,720
so there's a subroutine and again as i

00:29:05,039 --> 00:29:07,279
said there's a subroutine on top of it

00:29:06,720 --> 00:29:10,880
and the

00:29:07,279 --> 00:29:12,880
program and again if we're an embedded

00:29:10,880 --> 00:29:15,200
system occasionally we have an os

00:29:12,880 --> 00:29:16,480
operation system and of course there's

00:29:15,200 --> 00:29:18,399
the platform

00:29:16,480 --> 00:29:19,919
but i think some things have changed

00:29:18,399 --> 00:29:21,679
since we first

00:29:19,919 --> 00:29:23,840
described the error handling mechanism

00:29:21,679 --> 00:29:26,159
so even if i do address

00:29:23,840 --> 00:29:27,120
embedded systems a lot of embedded

00:29:26,159 --> 00:29:29,200
systems today

00:29:27,120 --> 00:29:30,240
do have some connection to the cloud to

00:29:29,200 --> 00:29:33,679
the web

00:29:30,240 --> 00:29:35,760
and in addition uh they usually

00:29:33,679 --> 00:29:37,440
again this is very dependent and

00:29:35,760 --> 00:29:40,640
embedded is a very broad

00:29:37,440 --> 00:29:41,679
spectrum but occasionally they do have

00:29:40,640 --> 00:29:44,799
the ability to run

00:29:41,679 --> 00:29:47,360
more than one program on the platform

00:29:44,799 --> 00:29:48,000
and of course it could have been that on

00:29:47,360 --> 00:29:51,120
the site

00:29:48,000 --> 00:29:53,600
there's additional platforms uh that are

00:29:51,120 --> 00:29:54,720
coupled in a way with the platform

00:29:53,600 --> 00:29:59,120
either by

00:29:54,720 --> 00:30:02,159
for uh reasons of

00:29:59,120 --> 00:30:04,240
to avoid crashing or other things but

00:30:02,159 --> 00:30:06,159
there could be that the more than one in

00:30:04,240 --> 00:30:09,279
the site

00:30:06,159 --> 00:30:11,039
so i want to uh i want to

00:30:09,279 --> 00:30:12,399
have another quote from design and

00:30:11,039 --> 00:30:14,720
evolution i think it's

00:30:12,399 --> 00:30:15,760
a very interesting one because it really

00:30:14,720 --> 00:30:17,919
uh summarized

00:30:15,760 --> 00:30:20,720
what i feel about exception handling

00:30:17,919 --> 00:30:22,960
mechanism and error handling in general

00:30:20,720 --> 00:30:24,799
so no single unit of a system can

00:30:22,960 --> 00:30:28,000
recover from every error that

00:30:24,799 --> 00:30:29,760
might have happened to it and every

00:30:28,000 --> 00:30:31,120
sorry and every bit of violence that

00:30:29,760 --> 00:30:34,399
might have done to it from

00:30:31,120 --> 00:30:36,640
the outside in extreme cases

00:30:34,399 --> 00:30:37,679
power will fail or memory location will

00:30:36,640 --> 00:30:40,720
change its value

00:30:37,679 --> 00:30:43,840
uh for no apparent reason so

00:30:40,720 --> 00:30:47,279
we really i think this this quote really

00:30:43,840 --> 00:30:49,840
uh really puts the

00:30:47,279 --> 00:30:50,720
spot on the fact that we're addressing

00:30:49,840 --> 00:30:54,240
error handling

00:30:50,720 --> 00:30:56,399
as part of a bigger system

00:30:54,240 --> 00:30:58,320
so there are three and a half types of

00:30:56,399 --> 00:31:00,480
errors

00:30:58,320 --> 00:31:03,760
and i mentioned before that the whole

00:31:00,480 --> 00:31:06,799
community is moving forward

00:31:03,760 --> 00:31:10,080
having less errors sorry

00:31:06,799 --> 00:31:13,039
less exceptions in the code so

00:31:10,080 --> 00:31:13,679
the first type of an error is a program

00:31:13,039 --> 00:31:16,640
back

00:31:13,679 --> 00:31:19,279
which might resemble uh for today's

00:31:16,640 --> 00:31:21,600
exception as a logic error

00:31:19,279 --> 00:31:22,480
uh the second one is the recoverable

00:31:21,600 --> 00:31:25,919
error

00:31:22,480 --> 00:31:29,279
and the third one is a terminal error so

00:31:25,919 --> 00:31:32,480
things like overflow etc

00:31:29,279 --> 00:31:33,760
these contain errors which invalidate

00:31:32,480 --> 00:31:36,880
the program for example

00:31:33,760 --> 00:31:40,159
stock corruption and errors which

00:31:36,880 --> 00:31:44,240
exhaust resources both of them are

00:31:40,159 --> 00:31:47,279
types of errors that we can't come up

00:31:44,240 --> 00:31:50,240
come back from so uh as i said

00:31:47,279 --> 00:31:50,559
it's uh uh in recent years it's have

00:31:50,240 --> 00:31:54,399
been

00:31:50,559 --> 00:31:56,240
uh suggested to decrease the number of

00:31:54,399 --> 00:31:57,600
uh exceptions that we throw in our

00:31:56,240 --> 00:32:00,640
program and

00:31:57,600 --> 00:32:02,159
basically to just focus of throwing the

00:32:00,640 --> 00:32:04,159
third type of error because

00:32:02,159 --> 00:32:05,519
the program bags are things that we

00:32:04,159 --> 00:32:07,279
would like to

00:32:05,519 --> 00:32:09,039
identify in the early stage of

00:32:07,279 --> 00:32:11,519
development and before

00:32:09,039 --> 00:32:12,840
the code moves to production and the

00:32:11,519 --> 00:32:15,679
second ones

00:32:12,840 --> 00:32:18,399
are things that i mean

00:32:15,679 --> 00:32:20,240
we don't want to do too much of a logic

00:32:18,399 --> 00:32:22,720
to handle with those

00:32:20,240 --> 00:32:24,640
uh with errors or at least uh that's

00:32:22,720 --> 00:32:27,679
that's the design that i see

00:32:24,640 --> 00:32:28,240
in front of me and the the third one is

00:32:27,679 --> 00:32:31,519
the

00:32:28,240 --> 00:32:34,000
the one that really uh suggests foreign

00:32:31,519 --> 00:32:38,000
uh exceptions

00:32:34,000 --> 00:32:39,120
so uh this was the design section now

00:32:38,000 --> 00:32:42,880
we're gonna move to

00:32:39,120 --> 00:32:46,000
alternatives some techniques

00:32:42,880 --> 00:32:49,519
uh for exception mechanism uh

00:32:46,000 --> 00:32:52,320
can certain techniques can be used to

00:32:49,519 --> 00:32:54,000
improve your exception uh mechanism uh

00:32:52,320 --> 00:32:55,360
in case you're working on embedded

00:32:54,000 --> 00:32:58,159
software and

00:32:55,360 --> 00:33:00,640
i think uh first of all i wanna

00:32:58,159 --> 00:33:04,399
disclaimer uh i wanna i wanna

00:33:00,640 --> 00:33:05,279
say that uh not all of those techniques

00:33:04,399 --> 00:33:10,640
are suitable

00:33:05,279 --> 00:33:10,640
for every uh project for every company

00:33:10,720 --> 00:33:13,760
it depends on on the trade-offs that

00:33:12,480 --> 00:33:15,919
you're willing to do but

00:33:13,760 --> 00:33:17,919
these are things that you could maybe

00:33:15,919 --> 00:33:19,840
consider so first of all you could use

00:33:17,919 --> 00:33:23,760
the current mechanism

00:33:19,840 --> 00:33:24,000
and library facilities to optimize so as

00:33:23,760 --> 00:33:26,399
we

00:33:24,000 --> 00:33:27,360
saw before the rtti information is

00:33:26,399 --> 00:33:30,480
generated and

00:33:27,360 --> 00:33:32,080
it could be that if we move to just a

00:33:30,480 --> 00:33:36,080
single type of exception we

00:33:32,080 --> 00:33:37,760
might reduce the amount of rtti

00:33:36,080 --> 00:33:39,360
the second thing we can do is overhead

00:33:37,760 --> 00:33:42,480
function calls to leave

00:33:39,360 --> 00:33:43,440
cpu class again this is a poc this is

00:33:42,480 --> 00:33:47,519
not how we'll do it

00:33:43,440 --> 00:33:50,880
uh in a production code but this is just

00:33:47,519 --> 00:33:51,360
the general notion of doing uh of doing

00:33:50,880 --> 00:33:54,320
the

00:33:51,360 --> 00:33:56,159
the work ourselves uh the third thing we

00:33:54,320 --> 00:33:56,640
could basically re-implement parts of

00:33:56,159 --> 00:33:59,360
the

00:33:56,640 --> 00:33:59,919
leap stud c plus plus and compile add it

00:33:59,360 --> 00:34:02,559
to our

00:33:59,919 --> 00:34:04,480
project and four we could use some

00:34:02,559 --> 00:34:06,960
alternative mechanism for example

00:34:04,480 --> 00:34:07,919
msbc have the structured exception

00:34:06,960 --> 00:34:11,359
handling

00:34:07,919 --> 00:34:12,079
mechanism that is not by uh siphospas

00:34:11,359 --> 00:34:13,839
standard

00:34:12,079 --> 00:34:15,359
exception handling mechanism though it

00:34:13,839 --> 00:34:19,200
is used

00:34:15,359 --> 00:34:21,359
to implement the sec the second but

00:34:19,200 --> 00:34:22,320
but again we could have considered if we

00:34:21,359 --> 00:34:26,399
were on

00:34:22,320 --> 00:34:29,919
a windows platform for using msvc

00:34:26,399 --> 00:34:30,879
uh uh in general we could uh decide that

00:34:29,919 --> 00:34:34,240
we

00:34:30,879 --> 00:34:37,440
wanna uh change uh from

00:34:34,240 --> 00:34:40,399
simplest by standard to different

00:34:37,440 --> 00:34:42,960
implementations so i've tried one and

00:34:40,399 --> 00:34:45,119
two uh just to see

00:34:42,960 --> 00:34:47,520
the effect and measure because i always

00:34:45,119 --> 00:34:51,280
love to see

00:34:47,520 --> 00:34:55,280
how uh how uh things that are

00:34:51,280 --> 00:34:58,640
um how things are in in real life

00:34:55,280 --> 00:35:00,880
and not just in theory so let's look at

00:34:58,640 --> 00:35:02,000
the previous case so i moved from

00:35:00,880 --> 00:35:05,200
throwing a few

00:35:02,000 --> 00:35:06,400
types of exception to a single type as i

00:35:05,200 --> 00:35:11,440
said before

00:35:06,400 --> 00:35:15,520
aiming to minimize the rcti information

00:35:11,440 --> 00:35:18,880
and so so here we can see

00:35:15,520 --> 00:35:22,000
our single type uh

00:35:18,880 --> 00:35:24,640
foreign exception versus return code so

00:35:22,000 --> 00:35:25,680
first of all you can see that the ratio

00:35:24,640 --> 00:35:28,880
is much bigger

00:35:25,680 --> 00:35:31,920
because um this this emphasized

00:35:28,880 --> 00:35:32,800
that just by adding exceptions to our

00:35:31,920 --> 00:35:35,760
code

00:35:32,800 --> 00:35:36,320
we have the overhead as uh suggested

00:35:35,760 --> 00:35:38,880
before

00:35:36,320 --> 00:35:39,760
rii and the fact that this ratio is uh

00:35:38,880 --> 00:35:43,760
is bigger

00:35:39,760 --> 00:35:46,320
says uh that it just emphasized that

00:35:43,760 --> 00:35:48,480
the addition alone it doesn't matter how

00:35:46,320 --> 00:35:51,680
many types of errors do we add

00:35:48,480 --> 00:35:54,720
uh creates overhead sorry

00:35:51,680 --> 00:35:58,560
and you can see an arm

00:35:54,720 --> 00:36:01,839
similar ratio though smaller

00:35:58,560 --> 00:36:03,760
and just to compare

00:36:01,839 --> 00:36:05,440
uh between uh three and three types and

00:36:03,760 --> 00:36:08,800
four and one type

00:36:05,440 --> 00:36:12,320
so here i uh i compared them

00:36:08,800 --> 00:36:14,960
and i got some gain on runtime mostly on

00:36:12,320 --> 00:36:16,160
arm but not something that is very

00:36:14,960 --> 00:36:19,040
significant

00:36:16,160 --> 00:36:20,320
at least in my opinion again this is a

00:36:19,040 --> 00:36:23,760
benchmarking on

00:36:20,320 --> 00:36:26,560
not in real life code but on my

00:36:23,760 --> 00:36:28,560
tests and experiments and you are most

00:36:26,560 --> 00:36:32,160
welcome to go and try and

00:36:28,560 --> 00:36:35,520
see how these things act in your code

00:36:32,160 --> 00:36:37,680
i will say that there are again i wasn't

00:36:35,520 --> 00:36:38,400
aiming for a full benchmark but there

00:36:37,680 --> 00:36:41,440
are

00:36:38,400 --> 00:36:44,079
two very interesting papers by ben craig

00:36:41,440 --> 00:36:45,839
uh he's also in the community uh

00:36:44,079 --> 00:36:49,359
committee of uh simplest class

00:36:45,839 --> 00:36:50,800
he benchmarked both the size and

00:36:49,359 --> 00:36:54,000
the size overhead and the random

00:36:50,800 --> 00:36:56,160
overhead for different platforms and i

00:36:54,000 --> 00:36:57,200
linked to them at the end so you're also

00:36:56,160 --> 00:37:00,880
very welcome to go

00:36:57,200 --> 00:37:01,680
and check those so then i've moved to

00:37:00,880 --> 00:37:04,640
the second

00:37:01,680 --> 00:37:05,839
uh to the second option and i've tried

00:37:04,640 --> 00:37:09,359
to re-implement

00:37:05,839 --> 00:37:12,160
the behavior of the exception so

00:37:09,359 --> 00:37:12,720
let's go over this code so this is

00:37:12,160 --> 00:37:16,000
really

00:37:12,720 --> 00:37:16,560
again this is just a poc and here we can

00:37:16,000 --> 00:37:18,560
see

00:37:16,560 --> 00:37:22,240
our main function and this function

00:37:18,560 --> 00:37:24,320
calls some function that throws

00:37:22,240 --> 00:37:26,640
now the foreign function is defined here

00:37:24,320 --> 00:37:29,839
and it throws an exception

00:37:26,640 --> 00:37:31,040
and it includes this is the definition

00:37:29,839 --> 00:37:34,320
of the exemption

00:37:31,040 --> 00:37:34,960
and it includes uh the library and the

00:37:34,320 --> 00:37:37,200
library

00:37:34,960 --> 00:37:39,359
uh what it does is basically

00:37:37,200 --> 00:37:45,280
re-implements the allocate exception

00:37:39,359 --> 00:37:45,280
and death row so what i did here

00:37:45,440 --> 00:37:49,040
is uh it re-implemented allocate

00:37:48,160 --> 00:37:51,520
exception

00:37:49,040 --> 00:37:52,560
by returning some kind of a global

00:37:51,520 --> 00:37:55,520
buffer

00:37:52,560 --> 00:37:57,200
which is addresses the dynamic

00:37:55,520 --> 00:37:59,359
allocation overhead

00:37:57,200 --> 00:38:01,839
and the second thing i did was and again

00:37:59,359 --> 00:38:02,880
this is not a real solution it's just a

00:38:01,839 --> 00:38:05,920
poc to see

00:38:02,880 --> 00:38:07,599
our abilities so i just terminated or

00:38:05,920 --> 00:38:10,720
basically i exited

00:38:07,599 --> 00:38:13,599
properly when instead of

00:38:10,720 --> 00:38:14,560
propagating up the stack so this is

00:38:13,599 --> 00:38:16,160
really

00:38:14,560 --> 00:38:17,599
this really this code really does

00:38:16,160 --> 00:38:20,880
nothing but

00:38:17,599 --> 00:38:21,839
you can see that um here you can see the

00:38:20,880 --> 00:38:25,040
size of the

00:38:21,839 --> 00:38:27,839
of the buffer that i returned and

00:38:25,040 --> 00:38:29,520
the call for uh the call for

00:38:27,839 --> 00:38:32,800
constructing the exception

00:38:29,520 --> 00:38:35,520
and we just exit so

00:38:32,800 --> 00:38:37,280
the this thin implementation that i've

00:38:35,520 --> 00:38:40,320
just showed

00:38:37,280 --> 00:38:42,079
you can see here that it have a ratio

00:38:40,320 --> 00:38:45,119
that is very similar

00:38:42,079 --> 00:38:48,400
to the ratio of um

00:38:45,119 --> 00:38:50,880
of return code uh versus uh throw

00:38:48,400 --> 00:38:52,880
so this is the thinnest uh thread you

00:38:50,880 --> 00:38:53,760
just saw this is for in one type of

00:38:52,880 --> 00:38:56,160
exception

00:38:53,760 --> 00:38:56,800
and you can see just for comparison this

00:38:56,160 --> 00:39:00,720
is how

00:38:56,800 --> 00:39:03,839
uh comparing uh throwing or three values

00:39:00,720 --> 00:39:04,160
to a return value so you can see these

00:39:03,839 --> 00:39:06,480
are

00:39:04,160 --> 00:39:07,599
very similar numbers so that means that

00:39:06,480 --> 00:39:10,720
if we move

00:39:07,599 --> 00:39:13,680
from uh throw to a

00:39:10,720 --> 00:39:14,400
thin air throw or re-implementing these

00:39:13,680 --> 00:39:16,000
parts

00:39:14,400 --> 00:39:18,079
we could actually achieve something that

00:39:16,000 --> 00:39:20,720
is very similar in behavior to

00:39:18,079 --> 00:39:21,359
a random of course the size is still big

00:39:20,720 --> 00:39:24,640
because

00:39:21,359 --> 00:39:28,000
we still need to save uh the tables

00:39:24,640 --> 00:39:31,200
uh the stock and winding tables etc

00:39:28,000 --> 00:39:33,280
and the handlers of the exceptions but i

00:39:31,200 --> 00:39:35,760
still think it's very interesting

00:39:33,280 --> 00:39:35,760
findings

00:39:37,200 --> 00:39:44,960
okay so um

00:39:42,079 --> 00:39:46,320
i i want to show here what i think that

00:39:44,960 --> 00:39:49,680
could have been

00:39:46,320 --> 00:39:50,560
uh some kind of uh uh ideal throw

00:39:49,680 --> 00:39:52,640
mechanism

00:39:50,560 --> 00:39:54,160
that we're gonna that i would have liked

00:39:52,640 --> 00:39:56,400
to have in the following

00:39:54,160 --> 00:39:57,280
years in our in the language in c plus

00:39:56,400 --> 00:40:00,480
plus

00:39:57,280 --> 00:40:02,960
so you can have here

00:40:00,480 --> 00:40:04,480
you can see here a function and in case

00:40:02,960 --> 00:40:07,119
the function fails

00:40:04,480 --> 00:40:08,880
it can throw but i would love to have

00:40:07,119 --> 00:40:12,079
some way to

00:40:08,880 --> 00:40:12,800
customize this fro and decides whether i

00:40:12,079 --> 00:40:16,480
want to

00:40:12,800 --> 00:40:19,520
unwind or whether i want to allocate

00:40:16,480 --> 00:40:21,280
i think other people have also mentioned

00:40:19,520 --> 00:40:22,800
similar ideas

00:40:21,280 --> 00:40:25,040
but i think it's really it's really

00:40:22,800 --> 00:40:29,200
important to identify

00:40:25,040 --> 00:40:30,960
um uh that that we are doing

00:40:29,200 --> 00:40:33,680
we're making decisions here that aren't

00:40:30,960 --> 00:40:38,160
necessarily suitable for all platforms

00:40:33,680 --> 00:40:40,720
and here what i'm doing is basically

00:40:38,160 --> 00:40:41,760
the subroutine is telling the program

00:40:40,720 --> 00:40:44,480
how it wants to

00:40:41,760 --> 00:40:45,200
act in case of a throw there's another

00:40:44,480 --> 00:40:48,800
way

00:40:45,200 --> 00:40:52,560
to do it and this is by just

00:40:48,800 --> 00:40:55,599
another design

00:40:52,560 --> 00:40:56,800
concept to do it it's not it's not a

00:40:55,599 --> 00:40:59,920
technical way

00:40:56,800 --> 00:41:02,160
is just uh so we could define in the

00:40:59,920 --> 00:41:05,119
beginning of the program or in the

00:41:02,160 --> 00:41:06,240
uh executable uh the way that we want to

00:41:05,119 --> 00:41:08,720
address throw

00:41:06,240 --> 00:41:09,280
in this way the program can actually

00:41:08,720 --> 00:41:13,520
sort of

00:41:09,280 --> 00:41:16,800
uh impose its um

00:41:13,520 --> 00:41:21,599
impose the the way that it acts on

00:41:16,800 --> 00:41:23,920
all the subroutines of the program

00:41:21,599 --> 00:41:25,280
so let's look at the alternatives that i

00:41:23,920 --> 00:41:29,359
mentioned in the beginning

00:41:25,280 --> 00:41:32,720
uh the papers by herb and low cost

00:41:29,359 --> 00:41:36,319
and i i want to show you the technical

00:41:32,720 --> 00:41:36,880
details of those papers so herbs as i

00:41:36,319 --> 00:41:39,200
said

00:41:36,880 --> 00:41:40,960
zero overhead deterministic exception uh

00:41:39,200 --> 00:41:44,319
throwing values paper

00:41:40,960 --> 00:41:46,240
is uh doing those um

00:41:44,319 --> 00:41:47,440
having those desired decisions the first

00:41:46,240 --> 00:41:49,440
one is

00:41:47,440 --> 00:41:52,240
[Music]

00:41:49,440 --> 00:41:53,119
first of all it it mentions it's it

00:41:52,240 --> 00:41:56,400
identifies

00:41:53,119 --> 00:41:59,839
that the dynamic exception mechanism

00:41:56,400 --> 00:42:03,280
is have a large overhead

00:41:59,839 --> 00:42:05,599
and program bugs shouldn't be

00:42:03,280 --> 00:42:06,880
addressed by exceptions so as i

00:42:05,599 --> 00:42:09,520
mentioned before

00:42:06,880 --> 00:42:12,240
the general direction of this paper is

00:42:09,520 --> 00:42:15,359
to first of all

00:42:12,240 --> 00:42:16,000
educate the community to use exception

00:42:15,359 --> 00:42:18,720
mechanism

00:42:16,000 --> 00:42:20,800
only for the purpose that we've seen

00:42:18,720 --> 00:42:23,680
actually in the original design

00:42:20,800 --> 00:42:24,880
for identifying exceptions and and as i

00:42:23,680 --> 00:42:27,119
mentioned before

00:42:24,880 --> 00:42:27,920
decrease the number of exceptions in our

00:42:27,119 --> 00:42:31,599
code and

00:42:27,920 --> 00:42:35,760
avoid using them for things that aren't

00:42:31,599 --> 00:42:38,400
necessarily suitable for exceptions

00:42:35,760 --> 00:42:39,680
and also he addresses the fact that

00:42:38,400 --> 00:42:41,680
allocation failure

00:42:39,680 --> 00:42:43,359
is not a regular exception because

00:42:41,680 --> 00:42:44,640
allocation failure as i mentioned before

00:42:43,359 --> 00:42:48,400
is something that

00:42:44,640 --> 00:42:51,599
the program could not uh come back from

00:42:48,400 --> 00:42:54,640
in a way so

00:42:51,599 --> 00:42:56,000
again he says that he should we should

00:42:54,640 --> 00:42:59,280
define errors

00:42:56,000 --> 00:43:02,880
uh only as recoverable errors uh

00:42:59,280 --> 00:43:06,000
that we can we can address uh later

00:43:02,880 --> 00:43:06,560
and replace those error with uh things

00:43:06,000 --> 00:43:09,680
like

00:43:06,560 --> 00:43:12,800
status codes uh stood expected

00:43:09,680 --> 00:43:16,079
and i will mention it a bit uh in

00:43:12,800 --> 00:43:18,640
uh soon and uh deprecate

00:43:16,079 --> 00:43:19,920
basically suggest deprecate logic error

00:43:18,640 --> 00:43:21,440
from the reason that i've mentioned

00:43:19,920 --> 00:43:23,040
before

00:43:21,440 --> 00:43:25,040
logic error is something that we need to

00:43:23,040 --> 00:43:28,319
address in in the development

00:43:25,040 --> 00:43:31,599
of the progress and not later

00:43:28,319 --> 00:43:34,000
so a technical part of what he does

00:43:31,599 --> 00:43:34,880
is basically he's using a statically

00:43:34,000 --> 00:43:38,800
typed

00:43:34,880 --> 00:43:41,839
error so that we'll avoid the rtti

00:43:38,800 --> 00:43:45,280
overhead he also addresses the

00:43:41,839 --> 00:43:48,079
um the size of

00:43:45,280 --> 00:43:48,800
of the code and sorry size of the error

00:43:48,079 --> 00:43:50,800
and he

00:43:48,800 --> 00:43:52,400
returns it on the stack so it's not

00:43:50,800 --> 00:43:54,560
dynamic allocation anymore

00:43:52,400 --> 00:43:55,920
and the third thing he does is basically

00:43:54,560 --> 00:43:59,680
uh suggests returning

00:43:55,920 --> 00:44:02,960
something that is a union style um

00:43:59,680 --> 00:44:03,440
from the program the union thing can

00:44:02,960 --> 00:44:06,560
hold

00:44:03,440 --> 00:44:09,359
both success or

00:44:06,560 --> 00:44:09,920
an error and a boolean that basically

00:44:09,359 --> 00:44:12,960
tells us

00:44:09,920 --> 00:44:13,680
which which one is it and the this

00:44:12,960 --> 00:44:17,280
mechanism

00:44:13,680 --> 00:44:19,280
is not uh it's not the return

00:44:17,280 --> 00:44:21,119
the classic return value mechanism that

00:44:19,280 --> 00:44:22,400
we're familiar with because it contains

00:44:21,119 --> 00:44:25,760
more as you can see

00:44:22,400 --> 00:44:26,480
but it's uh somewhat uses the the same

00:44:25,760 --> 00:44:28,720
principles

00:44:26,480 --> 00:44:29,520
uh in the fact that the stock is the

00:44:28,720 --> 00:44:33,119
thing that

00:44:29,520 --> 00:44:35,520
we post the uh error back

00:44:33,119 --> 00:44:37,119
but i just want to emphasize here that

00:44:35,520 --> 00:44:39,200
it doesn't mean that the

00:44:37,119 --> 00:44:40,640
developer will implement this union by

00:44:39,200 --> 00:44:43,200
himself this is something the compiler

00:44:40,640 --> 00:44:46,720
would do behind the stage

00:44:43,200 --> 00:44:50,480
and as i said um

00:44:46,720 --> 00:44:53,760
stood allocator it can

00:44:50,480 --> 00:44:56,880
um uh sorry

00:44:53,760 --> 00:45:00,160
um can be predefined uh

00:44:56,880 --> 00:45:02,800
to define sort of the whole program

00:45:00,160 --> 00:45:04,079
uh the behavior for all the program so

00:45:02,800 --> 00:45:06,400
this is something that

00:45:04,079 --> 00:45:08,480
what i addressed in the previous slide

00:45:06,400 --> 00:45:11,680
but

00:45:08,480 --> 00:45:14,400
but just in in one direction

00:45:11,680 --> 00:45:15,920
so the program defines the mechanism for

00:45:14,400 --> 00:45:19,599
the subroutines

00:45:15,920 --> 00:45:22,560
and and and and in general

00:45:19,599 --> 00:45:23,119
he allows the programmer to decide uh

00:45:22,560 --> 00:45:26,480
which

00:45:23,119 --> 00:45:28,880
error mechanism he wants

00:45:26,480 --> 00:45:31,040
so the second paper that i've mentioned

00:45:28,880 --> 00:45:32,240
is low-cost deterministic simple plus

00:45:31,040 --> 00:45:34,480
exceptions

00:45:32,240 --> 00:45:36,160
and the proposal focuses on means

00:45:34,480 --> 00:45:38,960
minimizing the cost

00:45:36,160 --> 00:45:39,920
uh again in technical perspective so

00:45:38,960 --> 00:45:43,119
first of all

00:45:39,920 --> 00:45:44,800
uh it reduces the data needed for stock

00:45:43,119 --> 00:45:48,160
unwinding it replace

00:45:44,800 --> 00:45:48,160
allocated exception with

00:45:48,960 --> 00:45:54,160
values returned on the stack again

00:45:52,079 --> 00:45:55,760
they're defined differently of course

00:45:54,160 --> 00:45:59,200
than what we have today

00:45:55,760 --> 00:46:01,200
and uh the using global to rethrow

00:45:59,200 --> 00:46:03,280
because uh the wreath for mechanism is

00:46:01,200 --> 00:46:06,319
also quite complex i haven't uh

00:46:03,280 --> 00:46:09,440
got into that uh here but uh

00:46:06,319 --> 00:46:11,920
when referring we have to sort of um

00:46:09,440 --> 00:46:13,359
change our contact switch uh do some

00:46:11,920 --> 00:46:17,680
progress and then go back

00:46:13,359 --> 00:46:20,800
and refer so these both proposals

00:46:17,680 --> 00:46:21,680
are i think are very interesting um i

00:46:20,800 --> 00:46:24,720
think the

00:46:21,680 --> 00:46:26,000
as i said the they're addressing the

00:46:24,720 --> 00:46:27,920
problems that we have today

00:46:26,000 --> 00:46:29,680
for the exception mechanism and i

00:46:27,920 --> 00:46:31,680
believe that they're gonna

00:46:29,680 --> 00:46:33,440
i believe that they're gonna have a

00:46:31,680 --> 00:46:34,560
major influence on the way that

00:46:33,440 --> 00:46:37,680
exception mechanism

00:46:34,560 --> 00:46:40,640
is uh exists today so

00:46:37,680 --> 00:46:41,200
to conclude i wanna say that uh you can

00:46:40,640 --> 00:46:43,520
create

00:46:41,200 --> 00:46:45,359
your own alternative so if in case

00:46:43,520 --> 00:46:47,920
you're on an embedded

00:46:45,359 --> 00:46:47,920
performance

00:46:48,480 --> 00:46:52,319
an embedded system that needs a high

00:46:51,280 --> 00:46:55,359
performance

00:46:52,319 --> 00:46:56,000
you could do all sort of design

00:46:55,359 --> 00:46:58,560
decisions

00:46:56,000 --> 00:46:59,440
uh similar to the poc that i've just

00:46:58,560 --> 00:47:01,920
shown

00:46:59,440 --> 00:47:03,359
uh of course with the with the

00:47:01,920 --> 00:47:06,560
trade-offs needed

00:47:03,359 --> 00:47:10,400
uh the fact that like developing this

00:47:06,560 --> 00:47:12,400
mechanism will cost developers time etc

00:47:10,400 --> 00:47:14,000
but you could you could decide that this

00:47:12,400 --> 00:47:16,240
is something that is important to you

00:47:14,000 --> 00:47:17,760
and in this case you can decide uh avoid

00:47:16,240 --> 00:47:19,280
stack unwinding

00:47:17,760 --> 00:47:21,119
and replace with all sorts of

00:47:19,280 --> 00:47:23,520
alternatives for example you can

00:47:21,119 --> 00:47:24,240
signal to a different progress process

00:47:23,520 --> 00:47:26,079
sorry

00:47:24,240 --> 00:47:27,280
you could report to the cloud and send

00:47:26,079 --> 00:47:30,720
something and then

00:47:27,280 --> 00:47:35,440
crash for example i'm familiar with

00:47:30,720 --> 00:47:38,160
uh with watchdog it could be

00:47:35,440 --> 00:47:39,760
a design that includes watchdog that

00:47:38,160 --> 00:47:41,599
restarts your program

00:47:39,760 --> 00:47:43,280
so you could decide that you just want

00:47:41,599 --> 00:47:44,720
to crash and then the white job will

00:47:43,280 --> 00:47:47,280
restart your program

00:47:44,720 --> 00:47:48,720
you could uh use some kind of a

00:47:47,280 --> 00:47:52,880
pre-allocated space

00:47:48,720 --> 00:47:55,520
as i've shown and you could uh

00:47:52,880 --> 00:47:56,960
try to do other things like uh just

00:47:55,520 --> 00:47:59,200
minimizing the amount of

00:47:56,960 --> 00:48:01,119
of the different types of exceptions in

00:47:59,200 --> 00:48:04,160
your code i believe it will

00:48:01,119 --> 00:48:07,760
it it could uh it could cause

00:48:04,160 --> 00:48:10,960
reduction in overhead

00:48:07,760 --> 00:48:11,599
so other suggestions for error handling

00:48:10,960 --> 00:48:14,800
in general

00:48:11,599 --> 00:48:17,599
are exists so as i mentioned

00:48:14,800 --> 00:48:18,720
at the beginning contracts are something

00:48:17,599 --> 00:48:20,640
that addresses

00:48:18,720 --> 00:48:23,599
predefined conditions that uses

00:48:20,640 --> 00:48:26,319
predefined conditions to solve

00:48:23,599 --> 00:48:26,880
to avoid errors and in the early stage

00:48:26,319 --> 00:48:29,520
before

00:48:26,880 --> 00:48:30,720
before they happen and another

00:48:29,520 --> 00:48:33,839
interesting proposal

00:48:30,720 --> 00:48:34,559
is a stood expected which basically

00:48:33,839 --> 00:48:37,680
passes

00:48:34,559 --> 00:48:38,079
uh the value that is expected in case

00:48:37,680 --> 00:48:41,040
this

00:48:38,079 --> 00:48:41,920
uh this is not what we get from our

00:48:41,040 --> 00:48:45,359
function

00:48:41,920 --> 00:48:46,640
then there's a callback or we can do

00:48:45,359 --> 00:48:50,000
additional things

00:48:46,640 --> 00:48:52,720
to address that and uh

00:48:50,000 --> 00:48:53,040
just another interesting thing that i

00:48:52,720 --> 00:48:55,520
think

00:48:53,040 --> 00:48:56,319
it's worth mentioning is that bank craig

00:48:55,520 --> 00:49:00,480
is collecting

00:48:56,319 --> 00:49:02,559
data for um for

00:49:00,480 --> 00:49:04,319
generally data regarding the exception

00:49:02,559 --> 00:49:04,960
mechanism things that i've just shown

00:49:04,319 --> 00:49:08,480
and

00:49:04,960 --> 00:49:11,680
uh the the general uh um known

00:49:08,480 --> 00:49:12,240
common knowledge so this paper doesn't

00:49:11,680 --> 00:49:15,760
exist

00:49:12,240 --> 00:49:16,400
yet but it will in the future i'm sure

00:49:15,760 --> 00:49:18,960
and

00:49:16,400 --> 00:49:19,680
uh there are also other holistic

00:49:18,960 --> 00:49:23,040
approaches

00:49:19,680 --> 00:49:26,480
in the committee uh for example um

00:49:23,040 --> 00:49:30,480
there is a paper by uh bloomberg um

00:49:26,480 --> 00:49:33,680
by john lockas and uh

00:49:30,480 --> 00:49:35,520
west love uh defensive tracking versus

00:49:33,680 --> 00:49:37,119
input validations and i think this is a

00:49:35,520 --> 00:49:40,400
very interesting paper

00:49:37,119 --> 00:49:42,240
i've had a chance to view it in

00:49:40,400 --> 00:49:43,599
somewhat late stage but i think it's a

00:49:42,240 --> 00:49:46,480
very interesting paper

00:49:43,599 --> 00:49:47,440
it tries to identify the difference

00:49:46,480 --> 00:49:50,559
between

00:49:47,440 --> 00:49:52,079
uh errors that we get on production and

00:49:50,559 --> 00:49:55,280
errors that we get

00:49:52,079 --> 00:49:58,800
on development and there's another

00:49:55,280 --> 00:50:02,079
interesting notion by stefan and derek

00:49:58,800 --> 00:50:04,640
um suggests that um

00:50:02,079 --> 00:50:06,240
they're considering uh sort of adding

00:50:04,640 --> 00:50:09,440
flexibility to

00:50:06,240 --> 00:50:11,359
uh to how do we define what is an error

00:50:09,440 --> 00:50:14,000
and they're they're suggesting to

00:50:11,359 --> 00:50:17,200
propagate their app and let the caller

00:50:14,000 --> 00:50:20,400
have some decisions uh regarding that

00:50:17,200 --> 00:50:21,119
and i've also talked with lisa and she

00:50:20,400 --> 00:50:23,760
also have

00:50:21,119 --> 00:50:24,480
her own perspective on that so there are

00:50:23,760 --> 00:50:26,800
really

00:50:24,480 --> 00:50:27,760
different people in the community that

00:50:26,800 --> 00:50:29,599
addresses that

00:50:27,760 --> 00:50:32,240
and i'm sure we're going to see some

00:50:29,599 --> 00:50:35,520
progress in the near future

00:50:32,240 --> 00:50:38,240
so as as i said we need separate

00:50:35,520 --> 00:50:39,200
to separate the semantics from the

00:50:38,240 --> 00:50:43,040
implementation

00:50:39,200 --> 00:50:46,319
so exceptions are

00:50:43,040 --> 00:50:50,079
a semantical uh definition or

00:50:46,319 --> 00:50:52,880
they're uh this their their

00:50:50,079 --> 00:50:53,760
programming paradigm but development

00:50:52,880 --> 00:50:56,720
paradigm but

00:50:53,760 --> 00:50:58,400
they're not necessarily uh coupled with

00:50:56,720 --> 00:50:59,359
the current implementation that we have

00:50:58,400 --> 00:51:01,440
today

00:50:59,359 --> 00:51:03,200
and we also need to allow behavior

00:51:01,440 --> 00:51:04,559
suitable for performance sensitive

00:51:03,200 --> 00:51:07,760
applications

00:51:04,559 --> 00:51:08,640
and i would think that adding some

00:51:07,760 --> 00:51:10,319
customization

00:51:08,640 --> 00:51:12,319
to our current mechanism would be the

00:51:10,319 --> 00:51:14,800
right direction and

00:51:12,319 --> 00:51:16,559
as i said the overhead already exists so

00:51:14,800 --> 00:51:19,359
just adding the customization

00:51:16,559 --> 00:51:21,200
is is something that we can only gain

00:51:19,359 --> 00:51:24,559
from

00:51:21,200 --> 00:51:25,200
so uh in the last year uh the keynote

00:51:24,559 --> 00:51:28,480
was by

00:51:25,200 --> 00:51:30,480
uh the previous uh year for cppcon

00:51:28,480 --> 00:51:32,160
uh the the keynote was by biannual

00:51:30,480 --> 00:51:35,200
stuart sir uh about

00:51:32,160 --> 00:51:37,200
uh simplest plus journey 30. so

00:51:35,200 --> 00:51:38,319
a lot of happened in computing in the

00:51:37,200 --> 00:51:41,599
last 30 years

00:51:38,319 --> 00:51:41,920
and as i mentioned over 50 of embedded

00:51:41,599 --> 00:51:45,520
or

00:51:41,920 --> 00:51:48,720
real-time performance sensitive systems

00:51:45,520 --> 00:51:51,040
can't use exceptions so i'm

00:51:48,720 --> 00:51:52,240
suggesting let's reconsider our

00:51:51,040 --> 00:51:54,319
environment we could

00:51:52,240 --> 00:51:56,800
reconsider the decisions that were made

00:51:54,319 --> 00:51:59,280
because today's embedded systems

00:51:56,800 --> 00:51:59,920
are not the same thing that was uh 30

00:51:59,280 --> 00:52:02,559
years ago

00:51:59,920 --> 00:52:03,200
and we really want to consider the big

00:52:02,559 --> 00:52:05,839
picture

00:52:03,200 --> 00:52:07,359
and i've added here as you can see um a

00:52:05,839 --> 00:52:10,640
developer

00:52:07,359 --> 00:52:13,760
that is crushed because uh i was uh

00:52:10,640 --> 00:52:16,319
i wanted to add here that uh today

00:52:13,760 --> 00:52:17,760
our error collection is also done

00:52:16,319 --> 00:52:21,119
differently and

00:52:17,760 --> 00:52:24,400
it is rare that on production code on

00:52:21,119 --> 00:52:27,440
on the systems a developer would go

00:52:24,400 --> 00:52:30,720
and uh check the the errors

00:52:27,440 --> 00:52:33,359
by himself usually be collected

00:52:30,720 --> 00:52:35,040
to a log or to the cloud so i think

00:52:33,359 --> 00:52:37,040
that's also something that we

00:52:35,040 --> 00:52:38,559
we want to consider the change of

00:52:37,040 --> 00:52:41,040
paradigm

00:52:38,559 --> 00:52:42,640
and i think today uh the lack of

00:52:41,040 --> 00:52:45,359
observer

00:52:42,640 --> 00:52:47,760
for those system is something that is

00:52:45,359 --> 00:52:50,400
new

00:52:47,760 --> 00:52:51,599
and i invite you all to share your ideal

00:52:50,400 --> 00:52:54,640
exception usage

00:52:51,599 --> 00:52:57,119
by emailing me i invite you to

00:52:54,640 --> 00:52:58,960
experiment with the exception mechanism

00:52:57,119 --> 00:53:02,000
and suggest alternatives

00:52:58,960 --> 00:53:02,800
uh as i mentioned i think major chances

00:53:02,000 --> 00:53:05,760
will be made

00:53:02,800 --> 00:53:07,280
and i would really love to see what you

00:53:05,760 --> 00:53:09,920
what do people

00:53:07,280 --> 00:53:10,319
that are part of the embedded community

00:53:09,920 --> 00:53:12,960
or

00:53:10,319 --> 00:53:14,480
or others feel that is necessarily in

00:53:12,960 --> 00:53:17,040
the embedded

00:53:14,480 --> 00:53:17,680
in the exceptions mechanism that they

00:53:17,040 --> 00:53:21,680
want to

00:53:17,680 --> 00:53:25,119
be able to use and to conclude

00:53:21,680 --> 00:53:28,640
um exceptions as i said were designed

00:53:25,119 --> 00:53:30,960
around 30 years ago and i really think

00:53:28,640 --> 00:53:32,240
that we should reconsider the design

00:53:30,960 --> 00:53:38,160
decisions

00:53:32,240 --> 00:53:38,160
and and let's rebase this mechanism

00:53:39,359 --> 00:53:42,559
so those are the links that i've

00:53:40,880 --> 00:53:43,599
mentioned before as you can see there's

00:53:42,559 --> 00:53:46,559
a lot of them

00:53:43,599 --> 00:53:48,559
i've collected here some historical

00:53:46,559 --> 00:53:50,559
references the technical references that

00:53:48,559 --> 00:53:53,520
i've mentioned are very interesting

00:53:50,559 --> 00:53:54,480
feel free to go and and research every

00:53:53,520 --> 00:53:58,319
one of them

00:53:54,480 --> 00:54:00,480
there's two talks uh that defined that

00:53:58,319 --> 00:54:01,599
address the unwinding mechanism that i

00:54:00,480 --> 00:54:04,480
haven't uh got

00:54:01,599 --> 00:54:05,680
deeper into here today because it's also

00:54:04,480 --> 00:54:08,480
a very

00:54:05,680 --> 00:54:09,040
it's a complex mechanism and uh i

00:54:08,480 --> 00:54:11,760
couldn't

00:54:09,040 --> 00:54:12,240
have put that in an hour but they're

00:54:11,760 --> 00:54:14,240
also

00:54:12,240 --> 00:54:15,520
the the fact that people have done it

00:54:14,240 --> 00:54:18,800
before and i would

00:54:15,520 --> 00:54:19,119
prefer not to repeat them uh so this is

00:54:18,800 --> 00:54:22,240
a

00:54:19,119 --> 00:54:23,440
talk uh talking about unwinding uh in

00:54:22,240 --> 00:54:26,720
windows and this

00:54:23,440 --> 00:54:31,760
is unwinding uh by uh uh lib

00:54:26,720 --> 00:54:34,480
um um the the similar way that clang

00:54:31,760 --> 00:54:35,119
clang is doing and there's a lot of

00:54:34,480 --> 00:54:37,760
other

00:54:35,119 --> 00:54:39,680
interesting references references here

00:54:37,760 --> 00:54:41,839
you're most welcome also to look at the

00:54:39,680 --> 00:54:45,839
benchmarking that i've mentioned

00:54:41,839 --> 00:54:48,559
and i would love to get your your inputs

00:54:45,839 --> 00:54:51,119
so i hope you're not inspired to go and

00:54:48,559 --> 00:54:55,200
explore your systems error handling

00:54:51,119 --> 00:54:57,119
and reconsider them and feel really

00:54:55,200 --> 00:54:59,040
feel free to email me i would love to

00:54:57,119 --> 00:55:07,839
hear your opinions about it

00:54:59,040 --> 00:55:07,839
thank you

00:55:19,440 --> 00:55:21,520

YouTube URL: https://www.youtube.com/watch?v=N_-bUNMLGvE


