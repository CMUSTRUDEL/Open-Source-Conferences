Title: Adventures in SIMD-Thinking (part 1 of 2) - Bob Steagall - CppCon 2020
Publication date: 2020-10-07
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/adventures_in_simd_thinking_part_1/adventures_in_simd_thinking_part_1__bob_steagall__cppcon_2020.pdf
---
SIMD capabilities are virtually ubiquitous in modern computing hardware, and yet much of that computing capacity often goes unused. This talk will provide a high-level overview of the SSE, AVX, and AVX-512 instruction set architecture provided by Intel microprocessors, and provide some specific examples of real-world problems where additional performance can be gained by thinking "vertically".

We'll begin with a quick, high-level description of the features provided by the SSE, AVX, and AVX-512 instruction sets. We'll then use C++ to compose a simple API employing various compiler intrinsics implementing those instruction sets. At the lowest level, the API will wrap some primitive operations, and then build some very useful basic operations (like multi-register shift) upon those primitives. We'll then build some facilities for comparison and arithmetic, and finally round out the API with functions for load and store. During all of this, we'll use C++ to provide type safety, reduce complexity, and maximize performance.

Next, we'll take a look at how this simple API can be used to improve performance for a handful of interesting problems, like sorting the values stored in a register to create a very fast 1-D median filter, or high-speed convolution and correlation with kernels that fit within a single register. Finally, we'll revisit the UTF-8 to UTF-32 conversion techniques presented at CppCon two years ago to see whether using AVX can make an already fast conversion algorithm even faster.

---
Bob Steagall
KEWB Computing
Chief Cook and Bottle Washer
Maryland

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,720 --> 00:00:11,840
hello everyone

00:00:09,679 --> 00:00:13,280
thank you for coming my name is bob

00:00:11,840 --> 00:00:16,080
stegall

00:00:13,280 --> 00:00:18,560
and i'm here to give a talk to discuss

00:00:16,080 --> 00:00:21,680
some work that i've been doing

00:00:18,560 --> 00:00:25,199
with uh sorry about that

00:00:21,680 --> 00:00:26,000
i happen to have my uh some work that

00:00:25,199 --> 00:00:28,960
i've been doing

00:00:26,000 --> 00:00:30,240
with vectorized computing using avx 512

00:00:28,960 --> 00:00:33,280
and avx-2

00:00:30,240 --> 00:00:34,960
on newer intel architectures this is a

00:00:33,280 --> 00:00:36,880
two-part talk this is the first part of

00:00:34,960 --> 00:00:39,280
that and i call it adventures in cimd

00:00:36,880 --> 00:00:39,280
thinking

00:00:39,600 --> 00:00:46,079
so let's get started

00:00:43,040 --> 00:00:46,879
so uh first of all i'd like to do a

00:00:46,079 --> 00:00:49,039
little bit

00:00:46,879 --> 00:00:51,760
uh help us learn a little bit about

00:00:49,039 --> 00:00:53,280
intel's cmd facilities and a disclaimer

00:00:51,760 --> 00:00:55,120
here i don't work for intel

00:00:53,280 --> 00:00:58,079
i'm not compensated for this this is all

00:00:55,120 --> 00:01:00,239
just work that i've done on my own

00:00:58,079 --> 00:01:02,559
we'll create some handful of useful

00:01:00,239 --> 00:01:04,080
functions in terms of the avx-512

00:01:02,559 --> 00:01:05,360
intrinsics which are particularly

00:01:04,080 --> 00:01:10,640
interesting because they

00:01:05,360 --> 00:01:13,760
are uh 64 they are 512

00:01:10,640 --> 00:01:17,200
bit integers which holds 64 bytes and

00:01:13,760 --> 00:01:20,479
16 floats or 16 32 bit ins which is

00:01:17,200 --> 00:01:23,200
an interesting quantity and then we'll

00:01:20,479 --> 00:01:23,920
try some cmd style thinking to tackle

00:01:23,200 --> 00:01:26,240
some

00:01:23,920 --> 00:01:27,759
problems that i think are interesting uh

00:01:26,240 --> 00:01:28,960
and we'll try to get through four of

00:01:27,759 --> 00:01:32,079
them here

00:01:28,960 --> 00:01:32,720
the first is intro register sorting so

00:01:32,079 --> 00:01:36,079
if you've got

00:01:32,720 --> 00:01:38,479
16 values floats or ins in a register

00:01:36,079 --> 00:01:40,240
can you actually sort them it turns out

00:01:38,479 --> 00:01:43,439
you can

00:01:40,240 --> 00:01:48,159
we will use that to implement a fast

00:01:43,439 --> 00:01:51,439
linear uh median of 7 filter

00:01:48,159 --> 00:01:53,600
and then that will be the first

00:01:51,439 --> 00:01:54,479
talk and then i think in the second half

00:01:53,600 --> 00:01:57,119
of the talks

00:01:54,479 --> 00:01:58,159
we'll look into some fast small kernel

00:01:57,119 --> 00:02:00,079
convolution

00:01:58,159 --> 00:02:02,000
so if you're convolving a linear signal

00:02:00,079 --> 00:02:05,520
and you have a kernel size that's

00:02:02,000 --> 00:02:06,960
less than 16 we'll see how to do that

00:02:05,520 --> 00:02:08,800
and do it very quickly

00:02:06,960 --> 00:02:10,560
and then finally i'll do a reprise of

00:02:08,800 --> 00:02:12,000
some work that i did and presented a

00:02:10,560 --> 00:02:14,480
couple years ago

00:02:12,000 --> 00:02:15,760
on where i was using sse intrinsics an

00:02:14,480 --> 00:02:18,959
older version of the intrinsics to

00:02:15,760 --> 00:02:21,599
convert utf-8 to utf-32

00:02:18,959 --> 00:02:23,280
and i will show a slight improvement

00:02:21,599 --> 00:02:25,040
today it's not a huge improvement not

00:02:23,280 --> 00:02:27,840
nearly as much as i'd hoped for

00:02:25,040 --> 00:02:29,920
using avx2 and on two out of three

00:02:27,840 --> 00:02:31,360
compilers we see a decent improvement

00:02:29,920 --> 00:02:32,560
and on the third there's really no

00:02:31,360 --> 00:02:36,720
change

00:02:32,560 --> 00:02:38,480
so there's not really any heavy code

00:02:36,720 --> 00:02:39,360
there is a lot of code there's lots of

00:02:38,480 --> 00:02:41,360
pictures

00:02:39,360 --> 00:02:43,040
the code that's here today is all c plus

00:02:41,360 --> 00:02:44,160
plus but it's all very simple code it

00:02:43,040 --> 00:02:48,879
could easily be done

00:02:44,160 --> 00:02:51,360
in c plus 14 or higher

00:02:48,879 --> 00:02:53,280
so let's get started these are just some

00:02:51,360 --> 00:02:54,400
fundamental definitions that are part of

00:02:53,280 --> 00:02:56,160
what we're going to

00:02:54,400 --> 00:02:57,680
use here we really don't need much we

00:02:56,160 --> 00:03:00,560
need facilities from

00:02:57,680 --> 00:03:01,599
c stood i o which i use for debugging uh

00:03:00,560 --> 00:03:04,319
we need the standard

00:03:01,599 --> 00:03:05,840
definitions and we need some some things

00:03:04,319 --> 00:03:07,920
out of type traits

00:03:05,840 --> 00:03:09,920
otherwise we're going to include the imm

00:03:07,920 --> 00:03:11,760
intran dot h header file

00:03:09,920 --> 00:03:13,040
and when we're building an optimize mode

00:03:11,760 --> 00:03:14,159
we're going to tell the compiler to

00:03:13,040 --> 00:03:15,760
force it to inline

00:03:14,159 --> 00:03:18,560
otherwise if we're building in debug

00:03:15,760 --> 00:03:21,120
mode we'll just use ordinary inlining

00:03:18,560 --> 00:03:22,319
of particular interest for this talk are

00:03:21,120 --> 00:03:26,200
these three types

00:03:22,319 --> 00:03:29,360
i call them rf 512 ri512 and

00:03:26,200 --> 00:03:32,239
msk512 and these correspond to

00:03:29,360 --> 00:03:33,760
the 512 bit floating point integer type

00:03:32,239 --> 00:03:37,360
that intel defines

00:03:33,760 --> 00:03:40,799
the 512-bit uh integer type

00:03:37,360 --> 00:03:43,120
uh and then uh the mask type that i use

00:03:40,799 --> 00:03:45,280
which is an unsigned 32-bit end

00:03:43,120 --> 00:03:46,480
and these types will these three types

00:03:45,280 --> 00:03:48,159
really form the basis

00:03:46,480 --> 00:03:50,319
are used by all the functions to do the

00:03:48,159 --> 00:03:53,200
work that we're going to look at

00:03:50,319 --> 00:03:55,280
so there are 10 to 15 different

00:03:53,200 --> 00:03:57,040
functions each of them are important for

00:03:55,280 --> 00:03:59,040
understanding the algorithms that are

00:03:57,040 --> 00:04:01,280
discussed later on so i'm going to

00:03:59,040 --> 00:04:02,959
try and get through those and then see

00:04:01,280 --> 00:04:05,200
how they can be applied in some of the

00:04:02,959 --> 00:04:07,120
interesting problems that i mentioned

00:04:05,200 --> 00:04:09,120
so we'll start from the ground up with

00:04:07,120 --> 00:04:11,200
the most basic of the algorithms

00:04:09,120 --> 00:04:12,159
the basic the most basic of the basic

00:04:11,200 --> 00:04:15,680
algorithms

00:04:12,159 --> 00:04:17,759
to more complex basic algorithms

00:04:15,680 --> 00:04:19,680
so the first one is very easy the first

00:04:17,759 --> 00:04:24,000
two we want to

00:04:19,680 --> 00:04:25,360
fill a register a 512-bit register with

00:04:24,000 --> 00:04:28,080
some value

00:04:25,360 --> 00:04:29,759
so the function is very simple i pass in

00:04:28,080 --> 00:04:30,880
the floating point value i call the

00:04:29,759 --> 00:04:33,360
intrinsic

00:04:30,880 --> 00:04:35,280
and i take the floating point value and

00:04:33,360 --> 00:04:37,440
it broadcasts

00:04:35,280 --> 00:04:38,400
uh the intrinsic broadcasts the value of

00:04:37,440 --> 00:04:41,440
the argument

00:04:38,400 --> 00:04:42,800
to all of 16 elements that are part of

00:04:41,440 --> 00:04:46,160
that

00:04:42,800 --> 00:04:49,680
of that 512-bit register

00:04:46,160 --> 00:04:52,800
and there is an analogous function

00:04:49,680 --> 00:04:55,520
for ends for n32 and

00:04:52,800 --> 00:04:56,000
n32 and float are types that are

00:04:55,520 --> 00:04:59,680
natively

00:04:56,000 --> 00:05:04,000
supported by the 512-bit integers uh

00:04:59,680 --> 00:05:08,080
the intel's intrinsics

00:05:04,000 --> 00:05:09,360
uh are often mostly written in terms of

00:05:08,080 --> 00:05:12,160
or a large percentage of them were

00:05:09,360 --> 00:05:15,759
written in terms of 32-bit integers

00:05:12,160 --> 00:05:19,039
32-bit floats doubles 64-bit plots

00:05:15,759 --> 00:05:23,360
floats and then some other types for

00:05:19,039 --> 00:05:24,000
uh for smaller type manipulation both at

00:05:23,360 --> 00:05:25,919
sse

00:05:24,000 --> 00:05:27,360
and the more expensive skylake

00:05:25,919 --> 00:05:28,000
processors where you pay a lot more

00:05:27,360 --> 00:05:31,120
money for

00:05:28,000 --> 00:05:33,600
advanced avx 512 capabilities

00:05:31,120 --> 00:05:34,400
but we're really only going to deal with

00:05:33,600 --> 00:05:36,800
uh

00:05:34,400 --> 00:05:37,759
512 bit registers that are holding 16

00:05:36,800 --> 00:05:40,160
bit

00:05:37,759 --> 00:05:40,880
16 values and those values are either

00:05:40,160 --> 00:05:45,199
going to be

00:05:40,880 --> 00:05:45,199
32-bit floats or 32-bit integers

00:05:45,759 --> 00:05:49,840
so the next interesting function i call

00:05:47,680 --> 00:05:51,440
load from and this is a function for

00:05:49,840 --> 00:05:53,520
loading data from memory float

00:05:51,440 --> 00:05:54,720
floating point memory from data so if

00:05:53,520 --> 00:05:57,440
i've got a pointer

00:05:54,720 --> 00:05:58,560
to some memory and i call the function

00:05:57,440 --> 00:06:01,520
it will load that

00:05:58,560 --> 00:06:03,280
into my register and if you're familiar

00:06:01,520 --> 00:06:05,440
with the intrinsics you'll notice that i

00:06:03,280 --> 00:06:06,479
am using unaligned loads and unaligned

00:06:05,440 --> 00:06:08,560
storage or

00:06:06,479 --> 00:06:10,080
unaligned stores when i when i do stores

00:06:08,560 --> 00:06:12,080
which is indicated by the u

00:06:10,080 --> 00:06:14,000
and the name and the reason for that is

00:06:12,080 --> 00:06:16,319
because the way the algorithms work

00:06:14,000 --> 00:06:17,680
i really need to be able to load from

00:06:16,319 --> 00:06:21,039
any arbitrary

00:06:17,680 --> 00:06:23,440
m32 address or any arbitrary float

00:06:21,039 --> 00:06:23,440
address

00:06:26,560 --> 00:06:31,120
the next the next function is i call

00:06:29,280 --> 00:06:32,800
masked load from

00:06:31,120 --> 00:06:34,880
and this is a function that takes a

00:06:32,800 --> 00:06:37,919
pointer to some floating point data

00:06:34,880 --> 00:06:39,280
it takes a fill value and it takes a

00:06:37,919 --> 00:06:42,319
mask

00:06:39,280 --> 00:06:42,639
now intel actually uses 16-bit masks i

00:06:42,319 --> 00:06:45,280
use

00:06:42,639 --> 00:06:46,800
32 and i cast them to 16 and there's a

00:06:45,280 --> 00:06:48,639
reason for that that's unrelated to this

00:06:46,800 --> 00:06:51,680
presentation but i kept it

00:06:48,639 --> 00:06:53,280
in the presentation so the idea is you

00:06:51,680 --> 00:06:55,360
have a pointer to data

00:06:53,280 --> 00:06:56,880
and you have some fill value and you

00:06:55,360 --> 00:06:58,800
have a mask

00:06:56,880 --> 00:07:00,319
and then when you execute the intrinsic

00:06:58,800 --> 00:07:04,080
what happens

00:07:00,319 --> 00:07:06,800
is for every place the mask is a zero

00:07:04,080 --> 00:07:09,039
you get a value of the fill and every

00:07:06,800 --> 00:07:10,960
place the mask is a one

00:07:09,039 --> 00:07:12,400
you get the value from the corresponding

00:07:10,960 --> 00:07:14,240
location in memory

00:07:12,400 --> 00:07:15,599
so you can see here i'm alternating in

00:07:14,240 --> 00:07:17,599
pairs of two

00:07:15,599 --> 00:07:19,759
because i'm alternating in pairs of two

00:07:17,599 --> 00:07:20,880
in the bits and in the top half of the

00:07:19,759 --> 00:07:23,919
register

00:07:20,880 --> 00:07:25,680
i alternate in units of four but

00:07:23,919 --> 00:07:27,919
everywhere you see a zero

00:07:25,680 --> 00:07:29,520
i'm getting a value from the fill and

00:07:27,919 --> 00:07:30,639
everywhere you see a one i'm getting a

00:07:29,520 --> 00:07:32,000
value from memory

00:07:30,639 --> 00:07:34,240
this actually turns out to be pretty

00:07:32,000 --> 00:07:37,440
useful

00:07:34,240 --> 00:07:39,680
likewise there's another variant of this

00:07:37,440 --> 00:07:41,039
which which is just an overload that

00:07:39,680 --> 00:07:44,319
i've done here

00:07:41,039 --> 00:07:46,720
and that is taking uh

00:07:44,319 --> 00:07:48,800
that actually specifies a different fill

00:07:46,720 --> 00:07:51,360
value for every location

00:07:48,800 --> 00:07:53,360
in the in the fill register so rather

00:07:51,360 --> 00:07:54,000
than having a single floating point fill

00:07:53,360 --> 00:07:56,879
value

00:07:54,000 --> 00:07:59,039
that gets broadcast instead i i supply

00:07:56,879 --> 00:08:00,960
my own fill values and again

00:07:59,039 --> 00:08:02,080
where there's a zero in the mask i get

00:08:00,960 --> 00:08:04,479
the fill value

00:08:02,080 --> 00:08:06,080
and when there are ones in the mask i

00:08:04,479 --> 00:08:13,440
get the values

00:08:06,080 --> 00:08:15,919
read from memory

00:08:13,440 --> 00:08:17,599
and corresponding to load from there are

00:08:15,919 --> 00:08:20,319
functions to store two

00:08:17,599 --> 00:08:21,280
so there's a simple function uh store

00:08:20,319 --> 00:08:23,919
two where i take a

00:08:21,280 --> 00:08:24,400
a float and a register that's got data

00:08:23,919 --> 00:08:26,080
in it

00:08:24,400 --> 00:08:28,080
and i started that here's my memory

00:08:26,080 --> 00:08:29,919
here's my register with values

00:08:28,080 --> 00:08:32,000
and at the end i've i've pushed all

00:08:29,919 --> 00:08:34,640
those register values from the register

00:08:32,000 --> 00:08:34,640
into memory

00:08:35,440 --> 00:08:40,479
and just as this are just as there was a

00:08:37,760 --> 00:08:43,839
masked load from there's also a masked

00:08:40,479 --> 00:08:47,680
store to and so

00:08:43,839 --> 00:08:47,680
the idea is that

00:08:50,000 --> 00:08:54,720
wherever there's a one

00:08:53,200 --> 00:08:56,720
i think i've got it backwards on my

00:08:54,720 --> 00:08:58,880
diagram here

00:08:56,720 --> 00:09:00,240
uh wherever there's a zero you should be

00:08:58,880 --> 00:09:03,440
getting the uh

00:09:00,240 --> 00:09:05,040
i'm sorry wherever there's a zero you

00:09:03,440 --> 00:09:05,440
should be getting the value of the fill

00:09:05,040 --> 00:09:08,640
rate

00:09:05,440 --> 00:09:10,720
of of the register and wherever there's

00:09:08,640 --> 00:09:13,760
a one you're getting value from memory

00:09:10,720 --> 00:09:15,040
yes so anyways same sort of thing you

00:09:13,760 --> 00:09:17,120
see alternating

00:09:15,040 --> 00:09:19,040
with zeros i'm getting values from

00:09:17,120 --> 00:09:22,640
memory and with ones i'm getting values

00:09:19,040 --> 00:09:24,800
from the register

00:09:22,640 --> 00:09:26,480
the next function is a a constexpr

00:09:24,800 --> 00:09:28,399
function which is pretty useful

00:09:26,480 --> 00:09:30,240
it's it's very straightforward it's all

00:09:28,399 --> 00:09:33,360
evaluated at compile time

00:09:30,240 --> 00:09:33,839
and i call this make bitmask and this

00:09:33,360 --> 00:09:36,480
makes

00:09:33,839 --> 00:09:39,040
16 bit bit bit masks for me and returns

00:09:36,480 --> 00:09:41,839
them in an unsigned 32-bit integer

00:09:39,040 --> 00:09:43,200
and the idea here is that the bit values

00:09:41,839 --> 00:09:45,680
0 or 1

00:09:43,200 --> 00:09:46,320
are pres are provided as template

00:09:45,680 --> 00:09:49,360
arguments

00:09:46,320 --> 00:09:52,560
so it's all done at compile time and so

00:09:49,360 --> 00:09:55,279
i have 16 uh template arguments a

00:09:52,560 --> 00:09:55,600
capital a through capital p and what i

00:09:55,279 --> 00:09:58,080
do

00:09:55,600 --> 00:09:59,680
is i statically assert to make sure

00:09:58,080 --> 00:10:01,120
because they're unsigned integers i

00:09:59,680 --> 00:10:03,519
statically assert to make sure

00:10:01,120 --> 00:10:04,959
that their value of all of them is is

00:10:03,519 --> 00:10:07,839
less than two

00:10:04,959 --> 00:10:10,079
so every value here for a through p has

00:10:07,839 --> 00:10:13,600
to be either zero or one

00:10:10,079 --> 00:10:16,640
and then once the static assert clears

00:10:13,600 --> 00:10:19,760
then i just do some bit shifting and

00:10:16,640 --> 00:10:21,920
a bit wise oring to build the bit mask

00:10:19,760 --> 00:10:23,519
and so the bit mask would have from low

00:10:21,920 --> 00:10:26,880
order to high order

00:10:23,519 --> 00:10:29,120
a through o and i should also mention

00:10:26,880 --> 00:10:32,160
for this presentation the convention

00:10:29,120 --> 00:10:33,279
for both registers and memory and also

00:10:32,160 --> 00:10:35,360
bit masks

00:10:33,279 --> 00:10:37,519
is the low order byte and the low order

00:10:35,360 --> 00:10:39,440
bit is on the left

00:10:37,519 --> 00:10:42,079
and the high order byte or the high

00:10:39,440 --> 00:10:44,839
order bit is on the right

00:10:42,079 --> 00:10:46,560
and if you took this representation this

00:10:44,839 --> 00:10:48,640
register uh based

00:10:46,560 --> 00:10:50,000
representation of a bit mask and you

00:10:48,640 --> 00:10:52,640
wrote it out

00:10:50,000 --> 00:10:54,000
uh in the big indian form that we do

00:10:52,640 --> 00:10:55,040
traditionally it would look something

00:10:54,000 --> 00:10:58,839
like this

00:10:55,040 --> 00:11:01,839
uh if you represent it as as a as a bit

00:10:58,839 --> 00:11:01,839
sequence

00:11:02,240 --> 00:11:05,760
the next function is blend this is a

00:11:03,920 --> 00:11:08,480
very important function again it's based

00:11:05,760 --> 00:11:11,360
on masks and allows me to take

00:11:08,480 --> 00:11:11,760
two registers a and b and where the mask

00:11:11,360 --> 00:11:14,480
is

00:11:11,760 --> 00:11:15,040
and where the mask is 0 i get values

00:11:14,480 --> 00:11:17,040
from a

00:11:15,040 --> 00:11:18,959
and where the mask is 1 i get values

00:11:17,040 --> 00:11:20,800
from b this is a very interesting

00:11:18,959 --> 00:11:23,040
very powerful function it gets used a

00:11:20,800 --> 00:11:25,920
lot in in the other functions

00:11:23,040 --> 00:11:25,920
very straightforward

00:11:26,720 --> 00:11:31,360
the next function is also very powerful

00:11:29,279 --> 00:11:34,560
and very useful and i call it permute

00:11:31,360 --> 00:11:37,360
and it's based on this intrinsic this

00:11:34,560 --> 00:11:38,240
avx-5 probe intrinsic so basically what

00:11:37,360 --> 00:11:42,160
happens

00:11:38,240 --> 00:11:44,959
is you have a register full of values

00:11:42,160 --> 00:11:48,399
and you have a permutation sequence in

00:11:44,959 --> 00:11:51,680
another register in an integer register

00:11:48,399 --> 00:11:55,519
and the values at each location

00:11:51,680 --> 00:11:57,839
in the permutation sequence indicate

00:11:55,519 --> 00:11:59,279
which value you would like moved into

00:11:57,839 --> 00:12:02,240
the into the

00:11:59,279 --> 00:12:02,959
result so for example at the zeroth

00:12:02,240 --> 00:12:05,839
index

00:12:02,959 --> 00:12:06,880
i'm indicating that i want the value

00:12:05,839 --> 00:12:10,639
from the 15th

00:12:06,880 --> 00:12:11,920
index to be returned in the zeroth index

00:12:10,639 --> 00:12:14,079
in the result

00:12:11,920 --> 00:12:15,760
and so you can see that by having a

00:12:14,079 --> 00:12:18,720
permutation sequence which

00:12:15,760 --> 00:12:20,160
decreases from 15 to zero and applying

00:12:18,720 --> 00:12:23,920
that permutation

00:12:20,160 --> 00:12:24,399
as an example i have reversed the order

00:12:23,920 --> 00:12:27,839
of

00:12:24,399 --> 00:12:27,839
elements in the register

00:12:30,079 --> 00:12:33,839
and likewise you can do the same sort of

00:12:32,079 --> 00:12:36,800
thing with masking

00:12:33,839 --> 00:12:38,079
you can have the permutation mask i'm

00:12:36,800 --> 00:12:40,800
sorry you can have the permutation

00:12:38,079 --> 00:12:43,200
register and you can have the mask and

00:12:40,800 --> 00:12:44,720
then everywhere the mask is zero

00:12:43,200 --> 00:12:47,200
you get the values from the original

00:12:44,720 --> 00:12:49,519
register everywhere the mask is one

00:12:47,200 --> 00:12:51,440
you get the permutations so for example

00:12:49,519 --> 00:12:52,480
the masks are the mask bits are zero

00:12:51,440 --> 00:12:56,320
here so i get

00:12:52,480 --> 00:12:59,440
r0 and r1 here the mask bits are

00:12:56,320 --> 00:13:03,680
one so i'm going to get r13 and r12

00:12:59,440 --> 00:13:03,680
which i do and so on and so forth

00:13:04,399 --> 00:13:09,680
so a useful thing to be able to do is to

00:13:07,519 --> 00:13:11,200
actually have a function a function

00:13:09,680 --> 00:13:14,320
template in this case

00:13:11,200 --> 00:13:15,519
that makes uh that makes a permutation

00:13:14,320 --> 00:13:17,760
map for you

00:13:15,519 --> 00:13:19,120
so just like the make bitmask function i

00:13:17,760 --> 00:13:21,519
have a a

00:13:19,120 --> 00:13:23,200
function template called make perm map

00:13:21,519 --> 00:13:25,200
for make permutation map

00:13:23,200 --> 00:13:28,160
and it also takes unsigned template

00:13:25,200 --> 00:13:29,600
arguments 16 of them

00:13:28,160 --> 00:13:31,279
and so what happens is you enter the

00:13:29,600 --> 00:13:32,800
function and again there's a static

00:13:31,279 --> 00:13:34,639
assert which validates that

00:13:32,800 --> 00:13:37,040
the value of each of these unsigned

00:13:34,639 --> 00:13:39,760
template parameters is less than 16

00:13:37,040 --> 00:13:41,440
meaning it's from 0 to 15 and therefore

00:13:39,760 --> 00:13:43,920
is a legitimate index for

00:13:41,440 --> 00:13:45,279
for permutation and then it applies the

00:13:43,920 --> 00:13:48,320
appropriate intrinsic

00:13:45,279 --> 00:13:50,480
to actually execute that permutation and

00:13:48,320 --> 00:13:52,320
so

00:13:50,480 --> 00:13:55,760
they'll be in the order that they are

00:13:52,320 --> 00:13:58,320
specified in template arguments

00:13:55,760 --> 00:14:04,000
so these will be the the values of the

00:13:58,320 --> 00:14:07,360
permutation mask so

00:14:04,000 --> 00:14:11,120
we can use the permutation mask

00:14:07,360 --> 00:14:13,440
and we can use uh permutation in general

00:14:11,120 --> 00:14:14,560
to actually rotate values and registers

00:14:13,440 --> 00:14:16,399
and this is also

00:14:14,560 --> 00:14:18,720
very powerful and necessary for the

00:14:16,399 --> 00:14:21,040
algorithms we're going to discuss

00:14:18,720 --> 00:14:23,199
so the next function i've got i call

00:14:21,040 --> 00:14:25,920
rotate and it takes a template parameter

00:14:23,199 --> 00:14:28,079
assigned integer template parameter and

00:14:25,920 --> 00:14:30,399
it will actually rotate the contents of

00:14:28,079 --> 00:14:31,760
a register left or right first thing it

00:14:30,399 --> 00:14:35,839
does is it looks to see

00:14:31,760 --> 00:14:38,639
if the the rotation value capital r

00:14:35,839 --> 00:14:40,320
mod 16 is zero if that's the case then

00:14:38,639 --> 00:14:43,680
the result is the same

00:14:40,320 --> 00:14:46,880
uh as the as the original register

00:14:43,680 --> 00:14:47,519
if not then the function computes a bias

00:14:46,880 --> 00:14:50,720
value

00:14:47,519 --> 00:14:53,920
which depends on whether r is positive

00:14:50,720 --> 00:14:54,720
or r is negative it then takes the bias

00:14:53,920 --> 00:14:58,480
value

00:14:54,720 --> 00:15:02,079
and uses it to generate

00:14:58,480 --> 00:15:05,360
the parameters that get passed to um

00:15:02,079 --> 00:15:07,680
to the permutation to the permea

00:15:05,360 --> 00:15:09,839
the intrinsic that makes the permutation

00:15:07,680 --> 00:15:11,279
register which then gets passed to the

00:15:09,839 --> 00:15:14,480
intrinsic that actually does the

00:15:11,279 --> 00:15:18,240
permutation so for example

00:15:14,480 --> 00:15:20,959
if i had this register with these values

00:15:18,240 --> 00:15:22,639
and my applied rotate with a template

00:15:20,959 --> 00:15:25,120
argument of plus 3

00:15:22,639 --> 00:15:26,320
this is the result i would get all of

00:15:25,120 --> 00:15:29,279
the values are

00:15:26,320 --> 00:15:31,040
shifted upward by three and the last

00:15:29,279 --> 00:15:33,120
three values on the end

00:15:31,040 --> 00:15:34,399
are brought around to the front so you

00:15:33,120 --> 00:15:37,519
can see i've got

00:15:34,399 --> 00:15:37,920
13 14 and 15 now occupying the places

00:15:37,519 --> 00:15:41,440
where

00:15:37,920 --> 00:15:43,759
0 1 and 2 were so this is a very useful

00:15:41,440 --> 00:15:43,759
function

00:15:44,399 --> 00:15:48,160
and we can use that we can actually

00:15:46,240 --> 00:15:49,920
write a couple of handy wrappers on that

00:15:48,160 --> 00:15:52,480
we can have rotate down

00:15:49,920 --> 00:15:54,399
and so what rotate down does is it it

00:15:52,480 --> 00:15:56,160
takes a template argument an integer it

00:15:54,399 --> 00:15:58,560
ensures it's greater than zero

00:15:56,160 --> 00:15:59,279
and for rotating down we take the

00:15:58,560 --> 00:16:01,199
rotation

00:15:59,279 --> 00:16:03,199
value we make it negative and that's

00:16:01,199 --> 00:16:05,759
what we apply rotate to

00:16:03,199 --> 00:16:06,320
so in this case if i'm rotating down to

00:16:05,759 --> 00:16:08,079
the left

00:16:06,320 --> 00:16:09,440
towards the least significant byte by

00:16:08,079 --> 00:16:12,560
four values

00:16:09,440 --> 00:16:15,279
then the the values

00:16:12,560 --> 00:16:16,160
r4 through r15 are shifted to the left

00:16:15,279 --> 00:16:19,440
by four

00:16:16,160 --> 00:16:23,440
and the values r0 through r3 end up

00:16:19,440 --> 00:16:25,279
at the high end likewise we can do an

00:16:23,440 --> 00:16:28,160
analogous definition

00:16:25,279 --> 00:16:29,199
for rotate up and here if i rotate up by

00:16:28,160 --> 00:16:31,120
three

00:16:29,199 --> 00:16:32,800
you get the same result as if i call

00:16:31,120 --> 00:16:36,480
rotate directly directly with an

00:16:32,800 --> 00:16:38,959
argument of three

00:16:36,480 --> 00:16:39,759
other useful functions are shift down

00:16:38,959 --> 00:16:42,880
shift down

00:16:39,759 --> 00:16:45,680
is actually a combination of rotating

00:16:42,880 --> 00:16:48,160
so i'm rotating down by three i'm

00:16:45,680 --> 00:16:50,320
rotating down by four in this example

00:16:48,160 --> 00:16:51,680
i have another register that i've loaded

00:16:50,320 --> 00:16:53,279
with zeros

00:16:51,680 --> 00:16:54,880
and i have a special function called

00:16:53,279 --> 00:16:56,720
shift down blend mask

00:16:54,880 --> 00:16:58,240
which takes the amount of rotation and

00:16:56,720 --> 00:16:59,839
it computes the bit mask

00:16:58,240 --> 00:17:01,440
that's not important here so i didn't

00:16:59,839 --> 00:17:03,519
include it's very straightforward bit

00:17:01,440 --> 00:17:06,480
manipulation so i left it out

00:17:03,519 --> 00:17:08,319
but the point is that my my fill

00:17:06,480 --> 00:17:10,959
register is loaded with zeros

00:17:08,319 --> 00:17:12,240
so i rotate everything down by by four

00:17:10,959 --> 00:17:15,520
in this case

00:17:12,240 --> 00:17:16,400
and then i mask four zeros into the

00:17:15,520 --> 00:17:18,000
upper four

00:17:16,400 --> 00:17:21,760
so it's similar to what you get when

00:17:18,000 --> 00:17:25,439
you're bit shifting on cpu register

00:17:21,760 --> 00:17:25,439
bit shifting downward

00:17:26,160 --> 00:17:29,840
now another important function built on

00:17:28,079 --> 00:17:30,240
that and built on permutations is one

00:17:29,840 --> 00:17:33,679
that's

00:17:30,240 --> 00:17:35,760
very useful in the median filter and the

00:17:33,679 --> 00:17:37,919
convolution which i call shift down

00:17:35,760 --> 00:17:39,760
shift down and shift up with carry

00:17:37,919 --> 00:17:41,520
and this operates on a combination of

00:17:39,760 --> 00:17:44,640
registers a and b

00:17:41,520 --> 00:17:48,000
i think of them as being low and high

00:17:44,640 --> 00:17:51,280
and so what happens is i'm rotating

00:17:48,000 --> 00:17:54,400
i rotate down a i rotate down b

00:17:51,280 --> 00:17:56,559
and then i blend them together so

00:17:54,400 --> 00:17:59,520
i've got b which i think of as high i've

00:17:56,559 --> 00:18:02,400
got a which i think of as low

00:17:59,520 --> 00:18:04,559
i shift a down or i rotate eight a down

00:18:02,400 --> 00:18:06,720
by four in this case

00:18:04,559 --> 00:18:08,960
and then i take the lower four elements

00:18:06,720 --> 00:18:10,640
of b and i put it in the upper four

00:18:08,960 --> 00:18:14,000
locations of a

00:18:10,640 --> 00:18:16,320
so it's as if a and b were contiguous

00:18:14,000 --> 00:18:18,960
and i've shifted all the elements four

00:18:16,320 --> 00:18:18,960
to the left

00:18:20,799 --> 00:18:24,480
so you can have a shift up which is the

00:18:23,760 --> 00:18:28,000
opposite

00:18:24,480 --> 00:18:30,160
of shift down and you can have

00:18:28,000 --> 00:18:31,280
a shift up with carry and here again

00:18:30,160 --> 00:18:34,720
with b

00:18:31,280 --> 00:18:37,280
as i'm thinking of as high and a

00:18:34,720 --> 00:18:38,640
i'm thinking of as low everything gets

00:18:37,280 --> 00:18:41,440
shifted to the right

00:18:38,640 --> 00:18:42,559
and the result is the result of taking

00:18:41,440 --> 00:18:44,240
high

00:18:42,559 --> 00:18:46,000
shifting it to the right by three in

00:18:44,240 --> 00:18:46,720
this case and taking the upper three

00:18:46,000 --> 00:18:48,559
elements

00:18:46,720 --> 00:18:50,559
from low and putting it in the bottom

00:18:48,559 --> 00:18:53,200
three elements of high

00:18:50,559 --> 00:18:55,440
so again it's a way of thinking of these

00:18:53,200 --> 00:18:57,919
two registers as if they're contiguous

00:18:55,440 --> 00:18:58,559
and so when i shift up i shifting stuff

00:18:57,919 --> 00:19:01,039
to the right

00:18:58,559 --> 00:19:02,640
towards the upper register and then

00:19:01,039 --> 00:19:03,520
whatever would be the value in that

00:19:02,640 --> 00:19:06,080
upper register

00:19:03,520 --> 00:19:07,600
that's the result after the shift and

00:19:06,080 --> 00:19:10,720
the converse for

00:19:07,600 --> 00:19:12,320
shift down with carry

00:19:10,720 --> 00:19:14,480
and finally there's a variation of this

00:19:12,320 --> 00:19:16,160
i call in place shift down with carry

00:19:14,480 --> 00:19:18,160
and the only difference between that and

00:19:16,160 --> 00:19:19,919
shift down with carry is that

00:19:18,160 --> 00:19:22,559
i actually want the values in both

00:19:19,919 --> 00:19:25,120
registers to be adjusted in place

00:19:22,559 --> 00:19:27,360
so i passed them in by reference so what

00:19:25,120 --> 00:19:29,200
happens again thinking of this as low

00:19:27,360 --> 00:19:30,480
or thinking of this is high and thinking

00:19:29,200 --> 00:19:34,000
of this is low

00:19:30,480 --> 00:19:35,760
i'm going to shift down b in this case

00:19:34,000 --> 00:19:37,520
by four and because it's a shift

00:19:35,760 --> 00:19:39,600
i'm going to fill the upper four with

00:19:37,520 --> 00:19:42,160
zeros and

00:19:39,600 --> 00:19:44,000
the lower four original values of b are

00:19:42,160 --> 00:19:44,799
going to end up in the upper four values

00:19:44,000 --> 00:19:47,360
of a

00:19:44,799 --> 00:19:49,679
and the bottom four values of a are lost

00:19:47,360 --> 00:19:52,240
so again it's as if i have a and b

00:19:49,679 --> 00:19:53,840
a low and b high i'm shifting everything

00:19:52,240 --> 00:19:55,840
to the left by four elements

00:19:53,840 --> 00:19:57,039
i'm filling the the top four elements

00:19:55,840 --> 00:19:59,360
with zeros

00:19:57,039 --> 00:20:02,640
and i'm actually doing it in place in

00:19:59,360 --> 00:20:02,640
the registers themselves

00:20:04,320 --> 00:20:08,400
now get to the math functions there's

00:20:06,480 --> 00:20:11,120
surprisingly few math functions

00:20:08,400 --> 00:20:12,480
um there's only three there's fused

00:20:11,120 --> 00:20:16,000
multiply and add

00:20:12,480 --> 00:20:18,799
which has uh basically

00:20:16,000 --> 00:20:20,720
uh a b and c registers and it returns a

00:20:18,799 --> 00:20:22,640
value in the d register

00:20:20,720 --> 00:20:24,799
and the value of each element in d is

00:20:22,640 --> 00:20:28,240
equal to the corresponding elements

00:20:24,799 --> 00:20:30,880
of a multiplied by b and added to c

00:20:28,240 --> 00:20:32,000
so it's one operation that does a fused

00:20:30,880 --> 00:20:35,840
multiply

00:20:32,000 --> 00:20:35,840
and add to give you your result

00:20:36,480 --> 00:20:40,559
and then there's comparison functions uh

00:20:38,960 --> 00:20:42,159
minimum and maximum

00:20:40,559 --> 00:20:44,159
and so minimum does what you might

00:20:42,159 --> 00:20:45,120
expect given two registers that have

00:20:44,159 --> 00:20:47,280
values in it

00:20:45,120 --> 00:20:48,720
it returns a result where each element

00:20:47,280 --> 00:20:51,200
in the return register

00:20:48,720 --> 00:20:51,840
is the minimum of the corresponding

00:20:51,200 --> 00:20:53,919
elements

00:20:51,840 --> 00:20:56,400
in the two arguments very

00:20:53,919 --> 00:20:58,400
straightforward

00:20:56,400 --> 00:21:00,320
same thing with for maximum except it's

00:20:58,400 --> 00:21:03,840
the converse of minimum you end up with

00:21:00,320 --> 00:21:03,840
the maximum values of the elements

00:21:04,240 --> 00:21:06,960
now here's a function that's a little

00:21:05,440 --> 00:21:09,120
more complicated and it's very

00:21:06,960 --> 00:21:11,520
interesting

00:21:09,120 --> 00:21:12,960
and it's a way to compare it's the basis

00:21:11,520 --> 00:21:15,200
of sorting in the elements

00:21:12,960 --> 00:21:16,159
or within registers and i call it for

00:21:15,200 --> 00:21:18,159
lack of better

00:21:16,159 --> 00:21:20,480
term and lack of imagination i call it

00:21:18,159 --> 00:21:23,280
compare with exchange

00:21:20,480 --> 00:21:24,080
so it's a it's a primitive for sorting

00:21:23,280 --> 00:21:27,760
so this

00:21:24,080 --> 00:21:30,080
function is called with with values

00:21:27,760 --> 00:21:32,400
that with a register called valves which

00:21:30,080 --> 00:21:36,240
has elements in it

00:21:32,400 --> 00:21:39,520
a permutation mask which specifies

00:21:36,240 --> 00:21:42,640
which elements are to be compared

00:21:39,520 --> 00:21:45,919
and a bit mask which specifies

00:21:42,640 --> 00:21:51,280
when i compare two elements which one

00:21:45,919 --> 00:21:53,600
is the maximum so let's see how it works

00:21:51,280 --> 00:21:55,360
so here i've ended up we're gonna just

00:21:53,600 --> 00:21:56,880
for simplicity we're going to

00:21:55,360 --> 00:21:59,440
compare and exchange the first two

00:21:56,880 --> 00:22:01,919
elements so here are my original values

00:21:59,440 --> 00:22:03,679
i've got it full from the register full

00:22:01,919 --> 00:22:08,159
from 15 to zero

00:22:03,679 --> 00:22:10,960
in uh sorted in descending order

00:22:08,159 --> 00:22:12,240
i've specified a permutation matrix or

00:22:10,960 --> 00:22:15,760
permutation

00:22:12,240 --> 00:22:19,039
register and so i've said for the value

00:22:15,760 --> 00:22:21,440
in location zero i want to

00:22:19,039 --> 00:22:23,520
compare with the value in location one

00:22:21,440 --> 00:22:25,919
and for the value in location one

00:22:23,520 --> 00:22:27,520
i want to compare with the va value in

00:22:25,919 --> 00:22:29,840
location zero

00:22:27,520 --> 00:22:31,600
and i've supplied a mask register and

00:22:29,840 --> 00:22:33,520
the mask register tells me when i do

00:22:31,600 --> 00:22:35,520
this comparison

00:22:33,520 --> 00:22:37,280
the one that has the zero is going to be

00:22:35,520 --> 00:22:38,159
the location that gets the smaller of

00:22:37,280 --> 00:22:41,360
the two numbers

00:22:38,159 --> 00:22:41,919
and the the the location that has the

00:22:41,360 --> 00:22:43,440
one

00:22:41,919 --> 00:22:45,840
is going to get the greater of the two

00:22:43,440 --> 00:22:45,840
numbers

00:22:46,640 --> 00:22:53,200
so first thing we do is we compute the

00:22:50,320 --> 00:22:54,080
the exchange so we use our permutation

00:22:53,200 --> 00:22:56,640
and we exchange

00:22:54,080 --> 00:22:59,039
the values from the vowels register that

00:22:56,640 --> 00:23:01,280
are specified in the permutation matrix

00:22:59,039 --> 00:23:03,280
notice here that each value in the

00:23:01,280 --> 00:23:04,159
register here just corresponds to its

00:23:03,280 --> 00:23:05,679
location

00:23:04,159 --> 00:23:07,679
and that's a that's just a direct

00:23:05,679 --> 00:23:08,080
permutation there's nothing to be

00:23:07,679 --> 00:23:11,440
changed

00:23:08,080 --> 00:23:14,559
there but i in the exchange register

00:23:11,440 --> 00:23:16,000
i've swapped the first two values

00:23:14,559 --> 00:23:17,919
okay now i'm going to compute the

00:23:16,000 --> 00:23:20,159
minimum

00:23:17,919 --> 00:23:22,400
so i look at vowels and i look at

00:23:20,159 --> 00:23:26,559
exchange and i compute the minimum

00:23:22,400 --> 00:23:27,360
well in both cases uh the number 14 is

00:23:26,559 --> 00:23:29,200
the minimum

00:23:27,360 --> 00:23:30,799
it's the minimum in this lane and it's

00:23:29,200 --> 00:23:33,600
the minimum in this line

00:23:30,799 --> 00:23:34,720
and it has to be the same in both lanes

00:23:33,600 --> 00:23:37,840
if you think about it

00:23:34,720 --> 00:23:37,840
so now i've got the minimum

00:23:38,240 --> 00:23:42,400
likewise i'm going to compute the

00:23:40,080 --> 00:23:44,080
maximum i do the same thing except i

00:23:42,400 --> 00:23:45,440
look for the maximum value and here

00:23:44,080 --> 00:23:47,919
again

00:23:45,440 --> 00:23:50,159
between valves and exchange the maximum

00:23:47,919 --> 00:23:52,480
is 15 in both locations

00:23:50,159 --> 00:23:53,520
so now for these two these two elements

00:23:52,480 --> 00:23:55,279
in the register

00:23:53,520 --> 00:23:57,600
i have values for the minimum and values

00:23:55,279 --> 00:23:59,360
for the maximum

00:23:57,600 --> 00:24:01,360
now i'm going to blend them using the

00:23:59,360 --> 00:24:04,159
bit mask

00:24:01,360 --> 00:24:05,279
so i've got my bit mask and my bit mask

00:24:04,159 --> 00:24:07,760
is telling me

00:24:05,279 --> 00:24:08,480
i'm blending v min and i'm blending bit

00:24:07,760 --> 00:24:11,200
v max

00:24:08,480 --> 00:24:12,320
and my bit mask is saying for the zeros

00:24:11,200 --> 00:24:16,240
get the value from v

00:24:12,320 --> 00:24:18,400
min for ones get the value from v max

00:24:16,240 --> 00:24:19,840
and lo and behold i've just sorted the

00:24:18,400 --> 00:24:21,279
two values

00:24:19,840 --> 00:24:25,360
of the first two elements in this

00:24:21,279 --> 00:24:25,360
register i think that's pretty cool

00:24:25,760 --> 00:24:30,880
so why is this useful this primitive is

00:24:29,120 --> 00:24:32,480
very useful if you want to actually sort

00:24:30,880 --> 00:24:34,240
the values in the register

00:24:32,480 --> 00:24:35,760
i look at this i first looked at this

00:24:34,240 --> 00:24:37,440
and realized this could be done

00:24:35,760 --> 00:24:39,520
and i found it in a paper i was reading

00:24:37,440 --> 00:24:41,279
on on avx intrinsics

00:24:39,520 --> 00:24:43,039
and i thought that's really cool you can

00:24:41,279 --> 00:24:44,960
use it for sorting and it only took a

00:24:43,039 --> 00:24:46,320
few seconds later before i realized lots

00:24:44,960 --> 00:24:48,400
of people had already thought of that i

00:24:46,320 --> 00:24:51,600
wasn't creating anything new

00:24:48,400 --> 00:24:52,799
but it's still pretty cool so how do you

00:24:51,600 --> 00:24:54,480
do the sorting well the

00:24:52,799 --> 00:24:56,080
these things i've learned about recently

00:24:54,480 --> 00:24:57,679
called sorting networks and you can look

00:24:56,080 --> 00:24:59,520
them up on wikipedia

00:24:57,679 --> 00:25:01,440
and there are sites that will gener

00:24:59,520 --> 00:25:02,000
generate optimal sorting networks for

00:25:01,440 --> 00:25:04,159
you

00:25:02,000 --> 00:25:06,960
but what it boils down to is each one of

00:25:04,159 --> 00:25:09,600
these lines these horizontal black lines

00:25:06,960 --> 00:25:10,799
represents in effect a wire and these

00:25:09,600 --> 00:25:12,720
were actually used physically in

00:25:10,799 --> 00:25:15,760
electronics in the late 60s

00:25:12,720 --> 00:25:16,880
to do sorting in electronics it's

00:25:15,760 --> 00:25:20,320
amazing

00:25:16,880 --> 00:25:22,559
but each one of these represents a lane

00:25:20,320 --> 00:25:26,240
and each time you see a crossbar

00:25:22,559 --> 00:25:28,960
this represents a comparison and

00:25:26,240 --> 00:25:31,200
you know you can actually do across the

00:25:28,960 --> 00:25:32,240
lanes you can do multiple comparisons in

00:25:31,200 --> 00:25:34,640
parallel

00:25:32,240 --> 00:25:35,520
so each set in this diagram where you

00:25:34,640 --> 00:25:38,320
have

00:25:35,520 --> 00:25:39,039
groups where all of the elements are

00:25:38,320 --> 00:25:41,440
engaged

00:25:39,039 --> 00:25:43,360
because it's a power of 2 in this case

00:25:41,440 --> 00:25:45,200
is one phase in the sort

00:25:43,360 --> 00:25:47,120
so i'm going to sort every adjacent

00:25:45,200 --> 00:25:47,760
element then i'm going to do this style

00:25:47,120 --> 00:25:49,840
sorting

00:25:47,760 --> 00:25:51,279
sort every adjacent element then i'm

00:25:49,840 --> 00:25:52,000
going to do sorting according this

00:25:51,279 --> 00:25:53,760
pattern

00:25:52,000 --> 00:25:56,159
according to this pattern and then

00:25:53,760 --> 00:25:58,559
finally flip every adjacent element

00:25:56,159 --> 00:26:01,039
and this is called a batonic merge sort

00:25:58,559 --> 00:26:04,240
if i'm using the terminology correctly

00:26:01,039 --> 00:26:07,039
and in this particular case

00:26:04,240 --> 00:26:08,000
if it has 16 inputs and it will sort

00:26:07,039 --> 00:26:10,640
them into two

00:26:08,000 --> 00:26:12,559
sorted lanes of eight and it's the same

00:26:10,640 --> 00:26:14,720
number of operations no matter

00:26:12,559 --> 00:26:15,840
how the data is sorted if the data is

00:26:14,720 --> 00:26:18,320
pre-sorted

00:26:15,840 --> 00:26:19,440
still works if the data is inverse order

00:26:18,320 --> 00:26:22,400
same number of steps

00:26:19,440 --> 00:26:23,600
random order same steps very powerful

00:26:22,400 --> 00:26:25,760
and cool idea

00:26:23,600 --> 00:26:26,880
and directly applicable because if you

00:26:25,760 --> 00:26:29,279
think about it

00:26:26,880 --> 00:26:30,080
each one of those lanes corresponds to

00:26:29,279 --> 00:26:32,480
one of the

00:26:30,080 --> 00:26:34,240
one of the elements in our 16 element

00:26:32,480 --> 00:26:37,679
register

00:26:34,240 --> 00:26:41,279
so as it turns out

00:26:37,679 --> 00:26:43,840
for those six steps you can pre-compute

00:26:41,279 --> 00:26:46,000
the permutations and the bit masks

00:26:43,840 --> 00:26:48,400
necessary to carry out the operations

00:26:46,000 --> 00:26:50,480
that you saw in that diagram

00:26:48,400 --> 00:26:51,600
and i'm just going to turn it sideways

00:26:50,480 --> 00:26:54,400
and and

00:26:51,600 --> 00:26:55,360
sort of blur the rest but you can see

00:26:54,400 --> 00:26:57,440
that

00:26:55,360 --> 00:26:59,120
in this first step i'm doing a

00:26:57,440 --> 00:27:02,559
permutation for each

00:26:59,120 --> 00:27:04,640
adjacent pair of elements and my bit

00:27:02,559 --> 00:27:05,120
mask has a zero on the left and a one on

00:27:04,640 --> 00:27:06,799
the right

00:27:05,120 --> 00:27:08,799
meaning that i'm keeping the lower

00:27:06,799 --> 00:27:09,760
number on the left and the higher number

00:27:08,799 --> 00:27:12,080
on the right

00:27:09,760 --> 00:27:13,760
and this will do the first phase of this

00:27:12,080 --> 00:27:16,320
sorting

00:27:13,760 --> 00:27:17,520
and it does it in one pass through

00:27:16,320 --> 00:27:19,279
compare exchange

00:27:17,520 --> 00:27:21,760
so there are six passes through compare

00:27:19,279 --> 00:27:24,480
exchange and each compare exchange

00:27:21,760 --> 00:27:25,679
takes if i counted correctly four

00:27:24,480 --> 00:27:28,720
intrinsics

00:27:25,679 --> 00:27:31,919
so 24 intrinsics calls

00:27:28,720 --> 00:27:34,559
is enough to support 16 elements in two

00:27:31,919 --> 00:27:36,960
lanes of eight

00:27:34,559 --> 00:27:38,080
so here's the rest of the function after

00:27:36,960 --> 00:27:41,039
i've pre-computed

00:27:38,080 --> 00:27:43,679
the permutations and the bitmasks so i

00:27:41,039 --> 00:27:44,960
start with my vowels

00:27:43,679 --> 00:27:47,679
i'm going to do my first compare

00:27:44,960 --> 00:27:50,320
exchange and you'll see

00:27:47,679 --> 00:27:51,120
that it's worked i've got adjacent pairs

00:27:50,320 --> 00:27:56,880
of elements

00:27:51,120 --> 00:28:00,240
have been reversed my second permutation

00:27:56,880 --> 00:28:01,360
and well i can't remember which ones are

00:28:00,240 --> 00:28:04,559
which but

00:28:01,360 --> 00:28:06,720
as you step through and i've left the

00:28:04,559 --> 00:28:07,919
last two in each case unfuzzed

00:28:06,720 --> 00:28:10,080
so that you can look and see the

00:28:07,919 --> 00:28:13,919
difference

00:28:10,080 --> 00:28:13,919
as you step through the sort progresses

00:28:15,679 --> 00:28:19,760
and then by the time you get to the end

00:28:18,240 --> 00:28:23,120
you have a sorted sequence

00:28:19,760 --> 00:28:24,640
i started with 16 through one and i

00:28:23,120 --> 00:28:27,039
sorted two lanes of eight

00:28:24,640 --> 00:28:28,399
so my lower lane i have nine through 16

00:28:27,039 --> 00:28:31,840
and my upper lane

00:28:28,399 --> 00:28:31,840
i have one through eight

00:28:32,880 --> 00:28:41,120
so uh i think that is uh i think that is

00:28:36,720 --> 00:28:41,120
incredibly cool and very powerful

00:28:41,840 --> 00:28:45,360
so now that we have this ability to do

00:28:44,559 --> 00:28:47,200
sorting

00:28:45,360 --> 00:28:49,120
inside a register how can we actually

00:28:47,200 --> 00:28:52,480
apply this in the real world

00:28:49,120 --> 00:28:52,480
and get something useful out of it

00:28:54,320 --> 00:29:00,880
well i was several months ago

00:28:58,240 --> 00:29:02,559
about a year ago tinker around with some

00:29:00,880 --> 00:29:04,559
audio signal processing

00:29:02,559 --> 00:29:06,559
i had a noisy signal and you know audio

00:29:04,559 --> 00:29:08,960
signals are just linear signals

00:29:06,559 --> 00:29:10,559
and i wanted to just fool around try

00:29:08,960 --> 00:29:12,480
some de-noising

00:29:10,559 --> 00:29:14,880
and so one of the things that i saw

00:29:12,480 --> 00:29:17,279
suggested was the idea of a median

00:29:14,880 --> 00:29:17,279
filter

00:29:17,360 --> 00:29:23,919
so stepping back for just a moment

00:29:22,240 --> 00:29:26,880
let's think about how you compute the

00:29:23,919 --> 00:29:30,080
median the median is the central of

00:29:26,880 --> 00:29:31,600
some set of sorted values such that half

00:29:30,080 --> 00:29:32,720
the values are on the left and half the

00:29:31,600 --> 00:29:35,120
values on the right

00:29:32,720 --> 00:29:36,880
or equal number of values below an equal

00:29:35,120 --> 00:29:39,440
number of values above

00:29:36,880 --> 00:29:41,360
so one of the things i wanted to do was

00:29:39,440 --> 00:29:44,399
try a median filter that had seven

00:29:41,360 --> 00:29:45,120
elements in it so for each element or

00:29:44,399 --> 00:29:47,919
each

00:29:45,120 --> 00:29:49,600
each point in the signal i would take

00:29:47,919 --> 00:29:51,919
the point in the signal

00:29:49,600 --> 00:29:52,880
compute the median of that and three

00:29:51,919 --> 00:29:55,360
points previous

00:29:52,880 --> 00:29:56,000
and three points after and see if i

00:29:55,360 --> 00:29:59,919
could remove

00:29:56,000 --> 00:30:02,240
noise well with a fast sort

00:29:59,919 --> 00:30:03,840
we could implement a median of seven

00:30:02,240 --> 00:30:07,840
linear filter

00:30:03,840 --> 00:30:11,360
pretty easily so as i said

00:30:07,840 --> 00:30:12,399
a median is a value in a set of sorted

00:30:11,360 --> 00:30:15,520
data

00:30:12,399 --> 00:30:16,559
where half the data half the values are

00:30:15,520 --> 00:30:19,520
less than the median

00:30:16,559 --> 00:30:20,320
and half the values are above the median

00:30:19,520 --> 00:30:22,320
and if you have an

00:30:20,320 --> 00:30:23,440
odd number then which is usually

00:30:22,320 --> 00:30:26,960
preferable

00:30:23,440 --> 00:30:29,039
then uh you have uh

00:30:26,960 --> 00:30:30,240
equal numbers below and equal numbers

00:30:29,039 --> 00:30:32,799
above

00:30:30,240 --> 00:30:33,600
and uh keep in mind if you have an array

00:30:32,799 --> 00:30:35,120
a of seven

00:30:33,600 --> 00:30:37,360
integers and these are the sorted

00:30:35,120 --> 00:30:38,640
integers that you want to compute your

00:30:37,360 --> 00:30:40,159
median from

00:30:38,640 --> 00:30:42,000
assuming that you're indexing from zero

00:30:40,159 --> 00:30:44,960
to six the median is going to be

00:30:42,000 --> 00:30:47,200
in index three keep that in mind as we

00:30:44,960 --> 00:30:47,200
go

00:30:47,919 --> 00:30:53,760
so median filters are useful

00:30:51,440 --> 00:30:56,880
because they're good at preserving edge

00:30:53,760 --> 00:30:56,880
features in a signal

00:30:57,120 --> 00:31:02,559
and if you have a large discontinuity

00:31:00,960 --> 00:31:04,480
it's good at preserving large

00:31:02,559 --> 00:31:06,399
discontinuities because typically

00:31:04,480 --> 00:31:08,640
if you have areas in your signal where

00:31:06,399 --> 00:31:10,799
you have a shelf

00:31:08,640 --> 00:31:13,519
typically the median will actually

00:31:10,799 --> 00:31:15,360
preserve the shelf in the signal

00:31:13,519 --> 00:31:17,200
if you have a lot of outliers though a

00:31:15,360 --> 00:31:18,880
lot of noise it's good at getting rid of

00:31:17,200 --> 00:31:19,519
them without actually blurring the

00:31:18,880 --> 00:31:20,720
signal

00:31:19,519 --> 00:31:23,679
and as i mentioned it's good for

00:31:20,720 --> 00:31:25,519
denoising on the right here

00:31:23,679 --> 00:31:26,799
is just a diagram i crit from the

00:31:25,519 --> 00:31:29,039
internet

00:31:26,799 --> 00:31:30,080
showing an example of an original signal

00:31:29,039 --> 00:31:32,240
that is

00:31:30,080 --> 00:31:33,519
a little bit noisy and then having

00:31:32,240 --> 00:31:36,320
applied a median of

00:31:33,519 --> 00:31:37,600
seven uh filter to it you can see that a

00:31:36,320 --> 00:31:39,279
lot of the characteristics of the

00:31:37,600 --> 00:31:41,200
original signal are preserved but it's a

00:31:39,279 --> 00:31:42,640
little less noisy

00:31:41,200 --> 00:31:44,399
and that was the effect that i was

00:31:42,640 --> 00:31:47,200
trying to achieve unfortunately i didn't

00:31:44,399 --> 00:31:48,960
have any success doing that

00:31:47,200 --> 00:31:50,720
on the left you can actually you can

00:31:48,960 --> 00:31:52,880
also do uh

00:31:50,720 --> 00:31:54,720
medium filtering in two dimension and so

00:31:52,880 --> 00:31:56,480
this is a this is an example of the

00:31:54,720 --> 00:31:58,240
famous photograph of lena

00:31:56,480 --> 00:32:00,080
and here you've got some added speckle

00:31:58,240 --> 00:32:03,039
noise to the photograph

00:32:00,080 --> 00:32:04,880
and a a two dimensional median filter

00:32:03,039 --> 00:32:06,720
has been applied to the photograph

00:32:04,880 --> 00:32:08,399
and you can see that it removed a lot of

00:32:06,720 --> 00:32:10,399
the noise without

00:32:08,399 --> 00:32:12,559
really damaging too much of the edge

00:32:10,399 --> 00:32:14,559
detail in the original picture

00:32:12,559 --> 00:32:16,240
and i'm not sure whether the median was

00:32:14,559 --> 00:32:18,320
the median filter here was a three by

00:32:16,240 --> 00:32:19,200
three or a five by five or seven by

00:32:18,320 --> 00:32:21,120
seven

00:32:19,200 --> 00:32:22,960
i'm guessing it's probably only probably

00:32:21,120 --> 00:32:24,960
a five by five

00:32:22,960 --> 00:32:26,159
but in any event that's what medium

00:32:24,960 --> 00:32:28,240
filters are good for

00:32:26,159 --> 00:32:29,760
preserving strong characteristics while

00:32:28,240 --> 00:32:32,799
getting rid of noise

00:32:29,760 --> 00:32:32,799
so how can we do this

00:32:33,440 --> 00:32:37,360
well i'm going to walk through some code

00:32:35,279 --> 00:32:40,880
for a function that i call

00:32:37,360 --> 00:32:42,399
avx median of 7 and

00:32:40,880 --> 00:32:44,480
this is a little bit tricky there's a

00:32:42,399 --> 00:32:46,640
lot of code here i've included i've

00:32:44,480 --> 00:32:48,880
interspersed the code with some diagrams

00:32:46,640 --> 00:32:52,399
in the hopes that the diagrams will help

00:32:48,880 --> 00:32:52,399
illustrate what the code is doing

00:32:53,039 --> 00:32:59,919
the function starts out by pre-declaring

00:32:56,159 --> 00:33:03,200
several float registers of 16 element

00:32:59,919 --> 00:33:06,320
avx 512 registers and

00:33:03,200 --> 00:33:08,559
there's previous current and next

00:33:06,320 --> 00:33:10,480
and these are registers which represent

00:33:08,559 --> 00:33:13,120
the data input window

00:33:10,480 --> 00:33:14,480
these registers will actually hold the

00:33:13,120 --> 00:33:16,799
data which i'm

00:33:14,480 --> 00:33:18,720
i'm reading from memory and as their

00:33:16,799 --> 00:33:21,039
names might suggest

00:33:18,720 --> 00:33:21,919
the current register is the one that

00:33:21,039 --> 00:33:23,440
contains the

00:33:21,919 --> 00:33:25,679
most of the data that i'm currently

00:33:23,440 --> 00:33:26,720
processing the previous register

00:33:25,679 --> 00:33:28,720
contains the data

00:33:26,720 --> 00:33:30,720
came before and the next register

00:33:28,720 --> 00:33:32,399
contains the data it came after

00:33:30,720 --> 00:33:34,640
now you may be wondering why do i need

00:33:32,399 --> 00:33:36,399
to keep the registers on each side

00:33:34,640 --> 00:33:37,679
well you'll see you'll see when we get

00:33:36,399 --> 00:33:39,840
to the pictures that

00:33:37,679 --> 00:33:41,360
when you're starting the processing you

00:33:39,840 --> 00:33:42,320
have boundary conditions that you have

00:33:41,360 --> 00:33:44,080
to worry about

00:33:42,320 --> 00:33:46,000
so you need to decide what to do when

00:33:44,080 --> 00:33:47,600
you're when you're computing the median

00:33:46,000 --> 00:33:48,000
applying the median filter to the very

00:33:47,600 --> 00:33:51,200
first

00:33:48,000 --> 00:33:52,000
element in your array there are no

00:33:51,200 --> 00:33:53,519
elements before

00:33:52,000 --> 00:33:55,360
it so you have to pretend there are

00:33:53,519 --> 00:33:56,559
elements and that's in a sense what the

00:33:55,360 --> 00:33:59,760
role of the previous

00:33:56,559 --> 00:34:02,480
uh register is it fills in for memory

00:33:59,760 --> 00:34:04,960
that's not actually there

00:34:02,480 --> 00:34:06,640
then we have work registers low and high

00:34:04,960 --> 00:34:09,919
and you'll see what their role is

00:34:06,640 --> 00:34:11,200
it's easier to see pictorially you have

00:34:09,919 --> 00:34:13,679
a data register which

00:34:11,200 --> 00:34:15,679
holds the result of computations and you

00:34:13,679 --> 00:34:18,240
have an accumulator register

00:34:15,679 --> 00:34:18,879
which holds the results of computing the

00:34:18,240 --> 00:34:22,159
median

00:34:18,879 --> 00:34:25,359
as we go so

00:34:22,159 --> 00:34:27,520
we talked about loading data into lanes

00:34:25,359 --> 00:34:28,879
and so here's the permutation that i use

00:34:27,520 --> 00:34:30,480
here and look carefully at the

00:34:28,879 --> 00:34:34,000
permutation

00:34:30,480 --> 00:34:37,280
so the first eight elements are ordered

00:34:34,000 --> 00:34:39,760
zero through seven as you might expect

00:34:37,280 --> 00:34:41,520
the second eight elements are ordered

00:34:39,760 --> 00:34:44,320
one through eight

00:34:41,520 --> 00:34:46,000
so effectively my lower lane is going to

00:34:44,320 --> 00:34:49,119
sort elements

00:34:46,000 --> 00:34:50,560
zero through six and my upper lane is

00:34:49,119 --> 00:34:53,119
going to sort elements

00:34:50,560 --> 00:34:54,560
one through seven inclusive and so we

00:34:53,119 --> 00:34:57,599
make a permutation

00:34:54,560 --> 00:35:00,160
register which we'll apply later to

00:34:57,599 --> 00:35:03,920
extract data from another register in

00:35:00,160 --> 00:35:03,920
that order so we can do the sorts

00:35:04,320 --> 00:35:08,079
there's another permutation map that i

00:35:06,240 --> 00:35:09,440
call the save permutation

00:35:08,079 --> 00:35:11,599
and you'll see that it's full of these

00:35:09,440 --> 00:35:13,359
weird numbers 3 and 11.

00:35:11,599 --> 00:35:15,040
and the significance of those numbers

00:35:13,359 --> 00:35:16,079
will become clear when we actually see

00:35:15,040 --> 00:35:19,040
an example

00:35:16,079 --> 00:35:20,000
in the diagrams but keep in mind there

00:35:19,040 --> 00:35:22,800
are pairs

00:35:20,000 --> 00:35:22,800
3 and 11.

00:35:23,119 --> 00:35:26,880
so i begin execution first thing i'm

00:35:25,839 --> 00:35:29,200
going to do

00:35:26,880 --> 00:35:30,640
is i have a work register called first

00:35:29,200 --> 00:35:31,839
and i'm just going to load it with the

00:35:30,640 --> 00:35:34,560
value that's in the

00:35:31,839 --> 00:35:36,800
zeroth element in my array and first is

00:35:34,560 --> 00:35:39,520
going to temporarily

00:35:36,800 --> 00:35:42,320
hold this data for purposes of the the

00:35:39,520 --> 00:35:45,520
lower end boundary condition

00:35:42,320 --> 00:35:47,680
i'm going to compute my permutation and

00:35:45,520 --> 00:35:49,599
i'm going to compute my save permutation

00:35:47,680 --> 00:35:51,280
now keep in mind actually these things

00:35:49,599 --> 00:35:52,720
are declared cons and there's no work

00:35:51,280 --> 00:35:54,480
here that's done at run time

00:35:52,720 --> 00:35:56,480
the compiler actually pre-computes these

00:35:54,480 --> 00:35:59,839
things ahead of time and puts them

00:35:56,480 --> 00:35:59,839
puts them in static memory

00:36:01,040 --> 00:36:04,720
the next thing i do and i'm jumping down

00:36:03,200 --> 00:36:05,680
a little bit here is just scrolling down

00:36:04,720 --> 00:36:07,760
in the code

00:36:05,680 --> 00:36:09,119
i create a bit mask using my make

00:36:07,760 --> 00:36:11,200
bitmask function

00:36:09,119 --> 00:36:13,520
and that bitmask has the lower two bits

00:36:11,200 --> 00:36:16,720
set to one and one

00:36:13,520 --> 00:36:18,079
and all the other bits are zero and so

00:36:16,720 --> 00:36:20,240
now what i'm going to do

00:36:18,079 --> 00:36:21,839
is i'm going to make an array of such

00:36:20,240 --> 00:36:25,280
masks

00:36:21,839 --> 00:36:26,800
and i'm going to for each element

00:36:25,280 --> 00:36:29,119
in that array i'm going to take my

00:36:26,800 --> 00:36:30,320
original mask and i'm going to shift it

00:36:29,119 --> 00:36:31,680
by some value

00:36:30,320 --> 00:36:34,079
the zeroth element is going to be

00:36:31,680 --> 00:36:35,599
shifted by zero bits

00:36:34,079 --> 00:36:37,920
the first element is going to be shifted

00:36:35,599 --> 00:36:39,040
by two and so on and so forth until the

00:36:37,920 --> 00:36:41,599
eighth element

00:36:39,040 --> 00:36:44,880
in the array is shifted left uh shifted

00:36:41,599 --> 00:36:44,880
up by 14 bits

00:36:46,560 --> 00:36:52,000
okay now i'm going to preload some data

00:36:50,400 --> 00:36:54,079
into my registers so i've got my

00:36:52,000 --> 00:36:55,839
preloaded data first

00:36:54,079 --> 00:36:58,160
i'm going to load that into my current

00:36:55,839 --> 00:36:59,200
register and i'm going to read the first

00:36:58,160 --> 00:37:00,960
set of data from

00:36:59,200 --> 00:37:03,680
source and i'm going to load it into

00:37:00,960 --> 00:37:05,440
next so

00:37:03,680 --> 00:37:07,520
this is what it looks like and hopefully

00:37:05,440 --> 00:37:10,880
these pictures will make sense

00:37:07,520 --> 00:37:14,079
i've got ker and kerr has

00:37:10,880 --> 00:37:15,440
has my i i've broadcast the values of

00:37:14,079 --> 00:37:18,320
everything that's right here

00:37:15,440 --> 00:37:22,480
into it and next at the beginning of

00:37:18,320 --> 00:37:24,000
next contains the beginning of my data

00:37:22,480 --> 00:37:25,839
now i'm going to go into the loop that

00:37:24,000 --> 00:37:27,359
actually does the work

00:37:25,839 --> 00:37:29,599
and the first thing that i'm going to do

00:37:27,359 --> 00:37:31,680
in the loop is i'm going to read

00:37:29,599 --> 00:37:33,119
another register's worth of data and i'm

00:37:31,680 --> 00:37:36,880
going to shift everything down

00:37:33,119 --> 00:37:37,680
by one register worth so curve becomes

00:37:36,880 --> 00:37:40,400
previous

00:37:37,680 --> 00:37:42,000
next becomes cur and i load more data

00:37:40,400 --> 00:37:44,720
into next

00:37:42,000 --> 00:37:46,640
so now i get this i've shifted what was

00:37:44,720 --> 00:37:48,880
incurred down to previous

00:37:46,640 --> 00:37:50,000
what was in next occur and i've read new

00:37:48,880 --> 00:37:52,400
data

00:37:50,000 --> 00:37:54,240
so this is original fill data this is my

00:37:52,400 --> 00:37:58,960
first element that i've read

00:37:54,240 --> 00:37:58,960
and my data goes off to the right

00:38:00,560 --> 00:38:04,160
now this is where i'm going to use this

00:38:02,560 --> 00:38:06,000
weird function i mentioned before

00:38:04,160 --> 00:38:07,440
shift up with carry this is where it

00:38:06,000 --> 00:38:09,680
gets useful

00:38:07,440 --> 00:38:11,760
so my low work register i'm going to

00:38:09,680 --> 00:38:15,359
shift up by three elements

00:38:11,760 --> 00:38:17,280
because my kernel uh my medium filter

00:38:15,359 --> 00:38:18,640
has seven elements in it i want to do a

00:38:17,280 --> 00:38:21,200
median of seven

00:38:18,640 --> 00:38:22,160
so seven divided by two integer addition

00:38:21,200 --> 00:38:24,480
is three

00:38:22,160 --> 00:38:26,000
so i have to shift i'm going to shift

00:38:24,480 --> 00:38:29,440
previous and current up

00:38:26,000 --> 00:38:31,760
by three uh by three locations

00:38:29,440 --> 00:38:34,960
and i'm gonna store the result in low so

00:38:31,760 --> 00:38:34,960
let's see what that looks like

00:38:35,839 --> 00:38:42,079
so in effect what i've done is

00:38:39,040 --> 00:38:44,320
i've taken previous and cur and i've

00:38:42,079 --> 00:38:46,000
moved it to the right by three

00:38:44,320 --> 00:38:48,480
and this is how i've loaded the initial

00:38:46,000 --> 00:38:51,680
values of low

00:38:48,480 --> 00:38:54,320
so low and high and and high does the

00:38:51,680 --> 00:38:57,920
same thing except for kerr and next

00:38:54,320 --> 00:39:00,480
low and high are shifted to the left

00:38:57,920 --> 00:39:01,280
by three elements relative to ker and

00:39:00,480 --> 00:39:04,720
next

00:39:01,280 --> 00:39:06,240
and that's because uh when i want to

00:39:04,720 --> 00:39:08,800
compute the median

00:39:06,240 --> 00:39:10,000
for this element i need to be able to

00:39:08,800 --> 00:39:14,240
access these

00:39:10,000 --> 00:39:16,880
these uh these elements here

00:39:14,240 --> 00:39:18,560
so all right so now i've shifted i'm

00:39:16,880 --> 00:39:20,640
ready to do some work

00:39:18,560 --> 00:39:22,480
so in my work register i'm going to use

00:39:20,640 --> 00:39:23,359
my load permutation that i mentioned

00:39:22,480 --> 00:39:25,119
before

00:39:23,359 --> 00:39:26,720
and i'm going to take the data in low

00:39:25,119 --> 00:39:29,040
i'm going to permute it

00:39:26,720 --> 00:39:30,640
and i'm going to put that in work so

00:39:29,040 --> 00:39:33,760
here's what that looks like

00:39:30,640 --> 00:39:35,040
i've got low i'm taking the first seven

00:39:33,760 --> 00:39:37,040
elements of low

00:39:35,040 --> 00:39:38,400
and loading them in the first cell seven

00:39:37,040 --> 00:39:40,960
elements of work

00:39:38,400 --> 00:39:43,119
i'm leaving the eighth element blank i'm

00:39:40,960 --> 00:39:44,800
taking the next seven elements of low

00:39:43,119 --> 00:39:46,720
elements one through eight and i'm

00:39:44,800 --> 00:39:50,160
loading them into elements

00:39:46,720 --> 00:39:52,000
eight through fourteen in work so i've

00:39:50,160 --> 00:39:54,079
loaded my two lanes

00:39:52,000 --> 00:39:55,040
with the first seven and the second

00:39:54,079 --> 00:39:59,040
seven

00:39:55,040 --> 00:40:01,040
elements uh from my data

00:39:59,040 --> 00:40:02,960
now i'm going to sort my lanes of data

00:40:01,040 --> 00:40:03,839
and i didn't show you sort two lanes of

00:40:02,960 --> 00:40:06,000
seven

00:40:03,839 --> 00:40:06,960
uh i thought two lanes of eight was

00:40:06,000 --> 00:40:08,880
enough and the the

00:40:06,960 --> 00:40:11,280
diagram of eight is actually easier to

00:40:08,880 --> 00:40:13,119
understand than the 107

00:40:11,280 --> 00:40:14,480
but it executes in the same time it

00:40:13,119 --> 00:40:16,079
takes six steps

00:40:14,480 --> 00:40:17,520
so i'll just hope that you'll trust me

00:40:16,079 --> 00:40:21,040
that it works

00:40:17,520 --> 00:40:22,400
so i sort the data and i've sorted the

00:40:21,040 --> 00:40:24,400
data now that's what the blue is

00:40:22,400 --> 00:40:26,880
intended to represent and

00:40:24,400 --> 00:40:27,520
because i have seven locations here's my

00:40:26,880 --> 00:40:30,319
medium

00:40:27,520 --> 00:40:31,520
for my first lane uh my first lane and

00:40:30,319 --> 00:40:33,359
here's the median

00:40:31,520 --> 00:40:35,280
for my second lane and guess what

00:40:33,359 --> 00:40:39,040
indexes these are this is index

00:40:35,280 --> 00:40:41,599
three and this is index 11.

00:40:39,040 --> 00:40:42,400
so now i'm going to use my save

00:40:41,599 --> 00:40:44,400
permutation

00:40:42,400 --> 00:40:46,640
and i'm going to use the save mask those

00:40:44,400 --> 00:40:48,560
weird things that i computed before

00:40:46,640 --> 00:40:50,560
and i'm going to use them to place my

00:40:48,560 --> 00:40:52,480
results the two medians

00:40:50,560 --> 00:40:54,720
into the register called data which is

00:40:52,480 --> 00:40:58,319
an accumulator

00:40:54,720 --> 00:41:01,440
so here you go i've taken three and 11

00:40:58,319 --> 00:41:04,160
and i've put it

00:41:01,440 --> 00:41:06,000
into the first two locations in the data

00:41:04,160 --> 00:41:08,079
register in the accumulator

00:41:06,000 --> 00:41:09,119
so i've taken i've essentially taken a

00:41:08,079 --> 00:41:12,079
lane of seven

00:41:09,119 --> 00:41:13,680
and a lane of seven or the first seven

00:41:12,079 --> 00:41:15,520
elements the second seven elements i've

00:41:13,680 --> 00:41:17,520
sorted them in two lanes i found the

00:41:15,520 --> 00:41:18,720
median for those two sets of seven

00:41:17,520 --> 00:41:21,760
and i've put them in the first two

00:41:18,720 --> 00:41:24,000
locations of my accumulator

00:41:21,760 --> 00:41:26,240
i go back and this is where the shift

00:41:24,000 --> 00:41:28,160
down with carry is in place because

00:41:26,240 --> 00:41:29,839
i want to keep i want to preserve the

00:41:28,160 --> 00:41:30,960
values in low and high but i need to

00:41:29,839 --> 00:41:32,560
shift them

00:41:30,960 --> 00:41:34,240
and i didn't want to have to return a

00:41:32,560 --> 00:41:36,640
tuple so i used references

00:41:34,240 --> 00:41:38,720
instead of returning my value so what

00:41:36,640 --> 00:41:41,520
happens when i do that shift

00:41:38,720 --> 00:41:43,280
is i effectively am shifting i'm

00:41:41,520 --> 00:41:46,160
shifting the values down

00:41:43,280 --> 00:41:47,760
or relative to current next i'm shifting

00:41:46,160 --> 00:41:49,839
low and high upward

00:41:47,760 --> 00:41:50,800
so you'll notice that the values in low

00:41:49,839 --> 00:41:53,680
have all gone

00:41:50,800 --> 00:41:55,280
to the left by two the values in high

00:41:53,680 --> 00:41:56,960
have gone to the left by two

00:41:55,280 --> 00:41:59,520
and at the upper end of high because

00:41:56,960 --> 00:42:03,200
it's a shift i filled it with zeros

00:41:59,520 --> 00:42:06,079
now i repeat the process again i take

00:42:03,200 --> 00:42:07,760
what was the third lane of seven and the

00:42:06,079 --> 00:42:11,440
fourth lane of seven

00:42:07,760 --> 00:42:11,440
i load them into my work register

00:42:11,760 --> 00:42:19,599
i sort them and i use my save mask

00:42:16,480 --> 00:42:20,960
i use my second save mask bit mask and

00:42:19,599 --> 00:42:24,960
now i've saved

00:42:20,960 --> 00:42:26,480
the third and fourth median values into

00:42:24,960 --> 00:42:28,880
my accumulator

00:42:26,480 --> 00:42:30,560
and i'll do that four more times in

00:42:28,880 --> 00:42:32,400
order to fill the rest of the data

00:42:30,560 --> 00:42:35,520
register

00:42:32,400 --> 00:42:37,680
when the data register is full

00:42:35,520 --> 00:42:38,640
then i will write that out to memory

00:42:37,680 --> 00:42:42,079
somewhere

00:42:38,640 --> 00:42:43,520
and i'm done so

00:42:42,079 --> 00:42:44,880
all right so i've made this claim that

00:42:43,520 --> 00:42:45,920
it works and i've made the claim that

00:42:44,880 --> 00:42:49,040
it's fast so

00:42:45,920 --> 00:42:49,920
how fast is it well let's take a look i

00:42:49,040 --> 00:42:53,200
wrote some code i

00:42:49,920 --> 00:42:55,760
wrote this code so because i'm using avx

00:42:53,200 --> 00:42:55,760
00:42:56,000 --> 00:42:59,920
registers uh i had to use something

00:42:58,640 --> 00:43:01,599
higher than knight's landing and not

00:42:59,920 --> 00:43:04,880
having that i had access to

00:43:01,599 --> 00:43:07,040
some sky lake and cascade lake machines

00:43:04,880 --> 00:43:07,920
so i used a cascade lake machine to

00:43:07,040 --> 00:43:11,119
build this

00:43:07,920 --> 00:43:12,000
so it's done on ubuntu 1804 on a xeon

00:43:11,119 --> 00:43:13,599
processor that's

00:43:12,000 --> 00:43:15,359
cascade lake and i'm not sure what

00:43:13,599 --> 00:43:19,040
series it is it's two giga

00:43:15,359 --> 00:43:20,960
two gigahertz processor 6200 something i

00:43:19,040 --> 00:43:24,000
don't know what exactly

00:43:20,960 --> 00:43:26,400
and i built the code with gcc 10.2

00:43:24,000 --> 00:43:27,359
and clang 10.01 for purposes of

00:43:26,400 --> 00:43:28,800
comparison

00:43:27,359 --> 00:43:31,760
and here are the flags that i used when

00:43:28,800 --> 00:43:31,760
i was doing the building

00:43:31,920 --> 00:43:38,079
to test the how fast the sort was i

00:43:35,280 --> 00:43:38,880
uh used element counts of 100 through 10

00:43:38,079 --> 00:43:41,119
million

00:43:38,880 --> 00:43:42,560
increasing by a factor of 10 each time

00:43:41,119 --> 00:43:46,240
so there's six

00:43:42,560 --> 00:43:47,119
basically six of six tests and i tested

00:43:46,240 --> 00:43:49,040
the data with

00:43:47,119 --> 00:43:50,720
pre-sorted integers where the integers

00:43:49,040 --> 00:43:52,839
increase monotonically

00:43:50,720 --> 00:43:54,640
and i also tested with randomly

00:43:52,839 --> 00:43:56,880
generated

00:43:54,640 --> 00:43:59,040
signed integers whose values ranged from

00:43:56,880 --> 00:44:00,640
zero minus 50 to plus 50.

00:43:59,040 --> 00:44:02,079
and this range doesn't mean anything

00:44:00,640 --> 00:44:02,960
except when i was printing out for

00:44:02,079 --> 00:44:05,359
debugging

00:44:02,960 --> 00:44:06,800
i wanted the amount of space for each

00:44:05,359 --> 00:44:07,760
integer to take no more than three

00:44:06,800 --> 00:44:11,440
characters

00:44:07,760 --> 00:44:13,200
and be easy to recognize so i use minus

00:44:11,440 --> 00:44:14,720
50 to plus 50.

00:44:13,200 --> 00:44:16,800
as part of the test if you look closely

00:44:14,720 --> 00:44:18,720
at the test program i'm always using the

00:44:16,800 --> 00:44:20,640
same seed to generate the data

00:44:18,720 --> 00:44:22,480
now i'm using a mercen twister with a

00:44:20,640 --> 00:44:23,680
with a number that i found and used to

00:44:22,480 --> 00:44:25,680
generate the twister

00:44:23,680 --> 00:44:27,920
i don't care about the random quality of

00:44:25,680 --> 00:44:28,400
the data i just want it to be random

00:44:27,920 --> 00:44:30,240
enough

00:44:28,400 --> 00:44:32,000
to to determine if there's a difference

00:44:30,240 --> 00:44:33,920
between pre-sorted and randomly

00:44:32,000 --> 00:44:35,839
generated input data

00:44:33,920 --> 00:44:37,280
and always generating from the same seed

00:44:35,839 --> 00:44:41,680
allows me to have

00:44:37,280 --> 00:44:41,680
compare apples and apples run after run

00:44:41,920 --> 00:44:46,000
so i used two approaches the first was i

00:44:44,400 --> 00:44:48,160
took the same idea

00:44:46,000 --> 00:44:50,560
and i wrote i wrote a program that uses

00:44:48,160 --> 00:44:54,319
stl stood sort

00:44:50,560 --> 00:44:55,119
and that program scans along the input

00:44:54,319 --> 00:44:58,800
array

00:44:55,119 --> 00:44:59,599
and creates a short work array of seven

00:44:58,800 --> 00:45:02,720
elements

00:44:59,599 --> 00:45:04,079
uses stood sort to find the median and

00:45:02,720 --> 00:45:05,839
takes the median and puts it in the

00:45:04,079 --> 00:45:10,160
destination array

00:45:05,839 --> 00:45:12,720
i also used this small kernel avx-512

00:45:10,160 --> 00:45:14,720
sort that i just showed you and i went

00:45:12,720 --> 00:45:16,640
to great pains to make sure that

00:45:14,720 --> 00:45:19,119
both for the monotonically increasing

00:45:16,640 --> 00:45:19,680
data and also the randomly generated

00:45:19,119 --> 00:45:21,520
data

00:45:19,680 --> 00:45:23,440
that i always got exactly the same

00:45:21,520 --> 00:45:26,319
result in every location

00:45:23,440 --> 00:45:26,319
from both sorts

00:45:28,000 --> 00:45:35,839
so let's look at sorted input

00:45:32,400 --> 00:45:38,079
so here i'm using i'm using a log graph

00:45:35,839 --> 00:45:40,240
right so these are factors of 10 and

00:45:38,079 --> 00:45:42,720
factors of 10 in the size

00:45:40,240 --> 00:45:44,839
so this is the execution time in

00:45:42,720 --> 00:45:47,760
nanoseconds

00:45:44,839 --> 00:45:49,839
because sorting 100 really only takes

00:45:47,760 --> 00:45:53,520
not very many nanoseconds

00:45:49,839 --> 00:45:56,319
uh in nanoseconds for the stl sort

00:45:53,520 --> 00:45:58,400
and for the avx sort and i'm actually

00:45:56,319 --> 00:46:00,240
pleased at how linear this relationship

00:45:58,400 --> 00:46:01,760
is on this log log graph

00:46:00,240 --> 00:46:04,000
what it's saying is if i increase the

00:46:01,760 --> 00:46:07,520
number of elements by 10 times

00:46:04,000 --> 00:46:07,839
then my uh the time that i take is going

00:46:07,520 --> 00:46:10,240
to

00:46:07,839 --> 00:46:12,319
it is going to increase by some constant

00:46:10,240 --> 00:46:15,280
factor

00:46:12,319 --> 00:46:16,560
and the lines uh are have almost

00:46:15,280 --> 00:46:19,040
identical slopes

00:46:16,560 --> 00:46:19,920
and they are a fixed distance apart and

00:46:19,040 --> 00:46:22,480
so you can see

00:46:19,920 --> 00:46:24,880
i also computed the relative speed up

00:46:22,480 --> 00:46:27,359
how many times faster was avx

00:46:24,880 --> 00:46:28,480
than sdl in this case and it was

00:46:27,359 --> 00:46:30,160
basically

00:46:28,480 --> 00:46:33,040
in the case where the data is sorted

00:46:30,160 --> 00:46:35,599
with gcc and using gcc's lib stood c

00:46:33,040 --> 00:46:37,359
plus plus the avx based approach for

00:46:35,599 --> 00:46:38,400
pre-sorted data was always about a

00:46:37,359 --> 00:46:40,000
factor of four

00:46:38,400 --> 00:46:41,760
so you get a nice constant number there

00:46:40,000 --> 00:46:45,200
and that explains the parallel lines

00:46:41,760 --> 00:46:45,200
that are equidistant on the graph

00:46:45,280 --> 00:46:48,800
when i went to random input

00:46:49,200 --> 00:46:52,319
the performance and the time that the

00:46:51,040 --> 00:46:54,480
avx sort took

00:46:52,319 --> 00:46:56,480
was no different almost no different

00:46:54,480 --> 00:46:58,880
within the noise for

00:46:56,480 --> 00:47:00,319
the random input or for the pre-sorted

00:46:58,880 --> 00:47:02,079
input and as i mentioned

00:47:00,319 --> 00:47:03,839
for every sequence in the step exactly

00:47:02,079 --> 00:47:04,480
the same number of sort operations need

00:47:03,839 --> 00:47:08,400
to be

00:47:04,480 --> 00:47:09,839
done by uh compare compare with exchange

00:47:08,400 --> 00:47:11,599
whereas you can see there is a little

00:47:09,839 --> 00:47:13,119
bit of change in the slope here for the

00:47:11,599 --> 00:47:16,319
stl

00:47:13,119 --> 00:47:16,720
the stl algorithm stood sort and you'll

00:47:16,319 --> 00:47:18,720
all

00:47:16,720 --> 00:47:20,559
also notice that the performance

00:47:18,720 --> 00:47:23,280
difference bumped up and

00:47:20,559 --> 00:47:23,680
became asymptotically around 18 or 19

00:47:23,280 --> 00:47:27,680
times

00:47:23,680 --> 00:47:28,880
faster so in this case because the data

00:47:27,680 --> 00:47:30,880
was random

00:47:28,880 --> 00:47:32,400
stood sort actually had to do work it

00:47:30,880 --> 00:47:34,160
had to do comparisons

00:47:32,400 --> 00:47:35,760
it had to swap elements in the

00:47:34,160 --> 00:47:37,599
pre-sorted case the amount of work it

00:47:35,760 --> 00:47:38,800
has to do is much less which is why it's

00:47:37,599 --> 00:47:40,640
much faster

00:47:38,800 --> 00:47:42,319
so you get a nice relative speed up

00:47:40,640 --> 00:47:45,119
there uh

00:47:42,319 --> 00:47:46,000
relative to random input data which i

00:47:45,119 --> 00:47:47,520
you know i would think

00:47:46,000 --> 00:47:50,559
more or less corresponds to the real

00:47:47,520 --> 00:47:54,800
world but you know who knows

00:47:50,559 --> 00:47:57,680
so with clang clang was interesting

00:47:54,800 --> 00:47:58,640
with clang the performance difference uh

00:47:57,680 --> 00:48:02,319
between

00:47:58,640 --> 00:48:04,559
um between avx and stl

00:48:02,319 --> 00:48:07,359
was much tighter and interestingly

00:48:04,559 --> 00:48:11,119
enough on the same platform

00:48:07,359 --> 00:48:14,079
clang was actually creating faster code

00:48:11,119 --> 00:48:16,800
with lib stood c plus than gcc was in

00:48:14,079 --> 00:48:18,480
terms of absolute execution times

00:48:16,800 --> 00:48:20,960
so the factor difference here it sort of

00:48:18,480 --> 00:48:22,800
asymptotically was around two

00:48:20,960 --> 00:48:24,559
still nothing to sneeze at and i think

00:48:22,800 --> 00:48:28,480
that's pretty good speed up

00:48:24,559 --> 00:48:30,079
in this case for random input the

00:48:28,480 --> 00:48:31,359
difference in performance spreads out a

00:48:30,079 --> 00:48:33,599
little bit again

00:48:31,359 --> 00:48:34,720
it's closer for small numbers and then

00:48:33,599 --> 00:48:37,040
it gets not as

00:48:34,720 --> 00:48:39,119
not quite as far apart as it was for gcc

00:48:37,040 --> 00:48:40,480
but you can see asymptotically for 10

00:48:39,119 --> 00:48:42,880
000 elements or more

00:48:40,480 --> 00:48:45,040
the avx based sort with random data is

00:48:42,880 --> 00:48:48,000
around 16 times faster

00:48:45,040 --> 00:48:49,119
than using stood sort in libs stood c

00:48:48,000 --> 00:48:50,960
plus

00:48:49,119 --> 00:48:52,640
now i'm cognizant of the fact that you

00:48:50,960 --> 00:48:54,160
know stood sword is probably not the way

00:48:52,640 --> 00:48:55,760
that really smart people that know what

00:48:54,160 --> 00:48:58,640
they're doing would do this

00:48:55,760 --> 00:49:00,160
and i expect that it's probably you know

00:48:58,640 --> 00:49:01,839
it's a very good sort but it's also

00:49:00,160 --> 00:49:03,200
worst case performance probably for

00:49:01,839 --> 00:49:04,800
somebody who's doing this kind of

00:49:03,200 --> 00:49:06,480
processing for real

00:49:04,800 --> 00:49:08,480
i don't really do that for real and i

00:49:06,480 --> 00:49:09,280
needed something to compare against as a

00:49:08,480 --> 00:49:14,079
baseline

00:49:09,280 --> 00:49:14,079
and so i used i chose to use stood sort

00:49:14,839 --> 00:49:18,800
so that's it for this

00:49:17,200 --> 00:49:20,160
this half of the talk thanks for coming

00:49:18,800 --> 00:49:21,440
and i hope you'll come back to the

00:49:20,160 --> 00:49:24,240
second half

00:49:21,440 --> 00:49:25,680
uh i've got uh a few minutes left so i'm

00:49:24,240 --> 00:49:31,839
gonna move over to remo

00:49:25,680 --> 00:49:31,839
and answer some questions in the q a

00:49:33,200 --> 00:49:37,440
okay so the first question is uh now

00:49:35,599 --> 00:49:39,119
that apple is moving away from intel

00:49:37,440 --> 00:49:40,960
chips what will the future of cmd

00:49:39,119 --> 00:49:44,160
development look like in

00:49:40,960 --> 00:49:45,839
cross-platform products well

00:49:44,160 --> 00:49:47,520
if i had a crystal ball i would keep the

00:49:45,839 --> 00:49:48,160
answer to myself and make a lot of money

00:49:47,520 --> 00:49:52,559
from that

00:49:48,160 --> 00:49:55,119
so i don't know uh

00:49:52,559 --> 00:49:56,240
i will say that i don't really have a

00:49:55,119 --> 00:49:58,800
good feeling for how

00:49:56,240 --> 00:50:00,079
intelsimd compares to other cindy chips

00:49:58,800 --> 00:50:04,079
i would like to

00:50:00,079 --> 00:50:05,839
compare absolute and relative speedups

00:50:04,079 --> 00:50:09,440
on other chips like arm

00:50:05,839 --> 00:50:11,200
or mips or other things

00:50:09,440 --> 00:50:13,200
and i would have done that but i don't

00:50:11,200 --> 00:50:15,200
have access to that kind of hardware

00:50:13,200 --> 00:50:17,119
you know my world in my world i am

00:50:15,200 --> 00:50:19,359
surrounded by intel and there's really

00:50:17,119 --> 00:50:20,720
intel and nvidia and there's really

00:50:19,359 --> 00:50:22,319
nothing else

00:50:20,720 --> 00:50:24,319
uh if somebody wants to send me some

00:50:22,319 --> 00:50:27,839
free hardware i'll happily take it and

00:50:24,319 --> 00:50:27,839
do some benchmarking on that as well

00:50:30,240 --> 00:50:33,359
the next question is wouldn't stood m

00:50:32,800 --> 00:50:35,359
element

00:50:33,359 --> 00:50:36,559
be enough to find the median as a

00:50:35,359 --> 00:50:41,839
baseline

00:50:36,559 --> 00:50:41,839
rather than the full stood sort

00:50:42,800 --> 00:50:47,119
it maybe i don't know i didn't think of

00:50:45,440 --> 00:50:48,640
that

00:50:47,119 --> 00:50:50,480
now that someone has brought it to my

00:50:48,640 --> 00:50:52,640
attention i think i have a third

00:50:50,480 --> 00:50:54,559
if it works i have a third baseline case

00:50:52,640 --> 00:50:57,680
that i can add to the processing

00:50:54,559 --> 00:50:59,359
and see how it compares

00:50:57,680 --> 00:51:01,599
i think it would but i'm not absolutely

00:50:59,359 --> 00:51:01,599
sure

00:51:02,160 --> 00:51:07,440
and the last question that i see is is

00:51:05,280 --> 00:51:10,400
it possible to use const expert to

00:51:07,440 --> 00:51:13,520
perform complex register initialization

00:51:10,400 --> 00:51:17,040
and the answer is not yet uh

00:51:13,520 --> 00:51:17,040
const expert the compiler

00:51:17,200 --> 00:51:21,119
it would have to be a compiler specific

00:51:18,880 --> 00:51:23,200
extension the abstract machine

00:51:21,119 --> 00:51:25,440
doesn't recognize registers it doesn't

00:51:23,200 --> 00:51:29,359
recognize these special constructs in c

00:51:25,440 --> 00:51:32,240
plus plenty of c plus 20 or earlier

00:51:29,359 --> 00:51:33,680
so uh there is no way to make it const

00:51:32,240 --> 00:51:36,640
expert

00:51:33,680 --> 00:51:37,520
now i found from a practical perspective

00:51:36,640 --> 00:51:40,640
even in

00:51:37,520 --> 00:51:43,119
even in debug mode

00:51:40,640 --> 00:51:44,640
when i declare those register structs to

00:51:43,119 --> 00:51:47,760
be const

00:51:44,640 --> 00:51:49,680
the compiler still puts them in static

00:51:47,760 --> 00:51:50,880
data storage and actually doesn't do any

00:51:49,680 --> 00:51:54,079
work at runtime

00:51:50,880 --> 00:51:55,440
it preforms them my understanding is

00:51:54,079 --> 00:51:58,720
in the committee that there are people

00:51:55,440 --> 00:52:00,720
looking at how we can actually

00:51:58,720 --> 00:52:03,280
take intrinsics whether it their intel

00:52:00,720 --> 00:52:05,200
intrinsics or from other companies

00:52:03,280 --> 00:52:06,960
and extend the abstract machine and the

00:52:05,200 --> 00:52:09,280
language in such a way that

00:52:06,960 --> 00:52:12,079
those things can be accommodated by

00:52:09,280 --> 00:52:12,079
constexpr

00:52:13,760 --> 00:52:18,640
okay so the next question is is there a

00:52:16,720 --> 00:52:21,119
relevant performance difference between

00:52:18,640 --> 00:52:23,040
aligned and unaligned loads on recent

00:52:21,119 --> 00:52:25,280
hardware

00:52:23,040 --> 00:52:25,280
well

00:52:26,400 --> 00:52:31,520
i think there are uh

00:52:29,520 --> 00:52:32,960
well so here's measurements that i've

00:52:31,520 --> 00:52:35,280
done informally

00:52:32,960 --> 00:52:37,760
and this is purely anecdata so you know

00:52:35,280 --> 00:52:39,440
don't take it seriously

00:52:37,760 --> 00:52:41,520
uh in some of the algorithm work that

00:52:39,440 --> 00:52:43,599
i've done at work i built

00:52:41,520 --> 00:52:46,160
an aligned allocator where allocations

00:52:43,599 --> 00:52:49,040
were always aligned on a 64

00:52:46,160 --> 00:52:50,400
a 64 byte boundary so that i could start

00:52:49,040 --> 00:52:52,000
at the beginning of the array and i

00:52:50,400 --> 00:52:55,040
could read data into registers

00:52:52,000 --> 00:52:58,400
in a 64 in a 60

00:52:55,040 --> 00:53:01,359
64 byte chunk and

00:52:58,400 --> 00:53:02,319
in the tests that i was doing after

00:53:01,359 --> 00:53:03,839
reading data

00:53:02,319 --> 00:53:05,760
loading the data from memory into

00:53:03,839 --> 00:53:08,800
registers and doing work on the

00:53:05,760 --> 00:53:11,440
doing work on them and timing that

00:53:08,800 --> 00:53:12,640
and there was quite a bit of work so i

00:53:11,440 --> 00:53:15,040
tried it with both

00:53:12,640 --> 00:53:15,920
load aligned aligned loads and unaligned

00:53:15,040 --> 00:53:17,440
loads

00:53:15,920 --> 00:53:19,680
and i couldn't see any difference in

00:53:17,440 --> 00:53:21,200
that case when the data was aligned

00:53:19,680 --> 00:53:22,800
there didn't appear to be a whole lot of

00:53:21,200 --> 00:53:26,400
difference between load u

00:53:22,800 --> 00:53:28,240
and regular load i did find to my

00:53:26,400 --> 00:53:30,319
chagrin when i had unaligned data

00:53:28,240 --> 00:53:31,680
like having to start the address load a

00:53:30,319 --> 00:53:34,960
register from

00:53:31,680 --> 00:53:36,640
some arbitrary float uh

00:53:34,960 --> 00:53:38,800
register or some arbitrary float

00:53:36,640 --> 00:53:40,240
location in memory that you can't use uh

00:53:38,800 --> 00:53:43,200
you'll get a seg v if you use

00:53:40,240 --> 00:53:45,200
load aligned found that very quickly so

00:53:43,200 --> 00:53:46,960
now i just default to using unaligned

00:53:45,200 --> 00:53:49,119
loads and stores for everything and

00:53:46,960 --> 00:53:50,960
for load for the cases where the loads

00:53:49,119 --> 00:53:52,480
and stores are actually aligned

00:53:50,960 --> 00:53:54,079
there doesn't seem to be any performance

00:53:52,480 --> 00:53:56,079
difference in the case where they're

00:53:54,079 --> 00:54:00,079
unaligned i can't compare it to the

00:53:56,079 --> 00:54:00,079
aligned loads because i get seg fees

00:54:02,720 --> 00:54:06,839
there's another question are the avx-270

00:54:05,119 --> 00:54:08,079
instructions rather similar to the

00:54:06,839 --> 00:54:09,599
avx-512

00:54:08,079 --> 00:54:11,200
are are there bigger differences than

00:54:09,599 --> 00:54:14,160
the width of the registers

00:54:11,200 --> 00:54:15,280
well certainly avx 512 is twice as large

00:54:14,160 --> 00:54:18,960
as avx-2

00:54:15,280 --> 00:54:20,480
avx and avx-2 and avx and avx-2 are

00:54:18,960 --> 00:54:22,720
twice as large as the ss

00:54:20,480 --> 00:54:24,000
the original ssc intrinsics which are

00:54:22,720 --> 00:54:26,720
twice as large as the mx

00:54:24,000 --> 00:54:28,319
mmx intrinsic so who knows if it keeps

00:54:26,720 --> 00:54:31,520
going

00:54:28,319 --> 00:54:34,000
so uh there's quite a bit of new

00:54:31,520 --> 00:54:34,720
functionality that's in avx 512 that

00:54:34,000 --> 00:54:39,119
doesn't

00:54:34,720 --> 00:54:40,960
exist in avx avx2

00:54:39,119 --> 00:54:43,359
i think that everything that i've shown

00:54:40,960 --> 00:54:43,920
so far could also be implemented at half

00:54:43,359 --> 00:54:47,040
the width

00:54:43,920 --> 00:54:49,839
in avx-2 i've just not done that yet but

00:54:47,040 --> 00:54:53,440
there are some very cool things

00:54:49,839 --> 00:54:55,920
in avx-512

00:54:53,440 --> 00:54:58,480
there's gather scatter primitives now

00:54:55,920 --> 00:55:00,960
avx-2 has a gather primitive but

00:54:58,480 --> 00:55:02,799
it's basically just a full register i

00:55:00,960 --> 00:55:04,000
don't remember if it has a masked gather

00:55:02,799 --> 00:55:07,760
or not

00:55:04,000 --> 00:55:10,079
but avx-512 has gather scatter

00:55:07,760 --> 00:55:11,119
and it has masked gather and masked

00:55:10,079 --> 00:55:14,400
scatter

00:55:11,119 --> 00:55:16,880
it also has compressed load it also has

00:55:14,400 --> 00:55:18,400
compressed load and compressed store so

00:55:16,880 --> 00:55:21,119
if you have

00:55:18,400 --> 00:55:22,400
if you have 16 floats in a fl in a

00:55:21,119 --> 00:55:24,400
register and

00:55:22,400 --> 00:55:25,680
you have a mask and you need to specify

00:55:24,400 --> 00:55:28,799
i only want to write

00:55:25,680 --> 00:55:29,920
11 of those to memory with a masked

00:55:28,799 --> 00:55:32,160
store

00:55:29,920 --> 00:55:35,839
uh it will only write 11 and leave the

00:55:32,160 --> 00:55:35,839
other five alone

00:55:36,079 --> 00:55:39,119
so and there are some other capability

00:55:38,640 --> 00:55:41,680
difference

00:55:39,119 --> 00:55:43,920
uh if you want to pay lots of money for

00:55:41,680 --> 00:55:46,240
the super high-end avx processors they

00:55:43,920 --> 00:55:48,079
include primitives at those levels of

00:55:46,240 --> 00:55:51,119
processor to allow you to work with

00:55:48,079 --> 00:55:52,799
individual bytes and two byte uh two

00:55:51,119 --> 00:55:54,480
byte segments of the register

00:55:52,799 --> 00:55:56,880
but those processors are are quite

00:55:54,480 --> 00:56:00,319
expensive and not where i work and

00:55:56,880 --> 00:56:02,079
certainly out of reach of my budget

00:56:00,319 --> 00:56:03,359
all right well i think that's it for

00:56:02,079 --> 00:56:05,760
this segment uh

00:56:03,359 --> 00:56:06,960
thank you everyone for coming uh if

00:56:05,760 --> 00:56:08,640
you're interested please come back in

00:56:06,960 --> 00:56:10,319
half an hour for the second half and

00:56:08,640 --> 00:56:17,839
hopefully i'll see you there

00:56:10,319 --> 00:56:17,839
thank you take care

00:56:31,280 --> 00:56:33,359

YouTube URL: https://www.youtube.com/watch?v=qejTqnxQRcw


