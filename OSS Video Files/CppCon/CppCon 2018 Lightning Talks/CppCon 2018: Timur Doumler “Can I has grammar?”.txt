Title: CppCon 2018: Timur Doumler “Can I has grammar?”
Publication date: 2018-11-11
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,134 --> 00:00:00,967
- Hi!

00:00:00,967 --> 00:00:02,450
My name is Timur.

00:00:02,450 --> 00:00:05,145
So you've already I think all been there.

00:00:05,145 --> 00:00:07,485
Someone shows you this really weird snippet

00:00:07,485 --> 00:00:09,881
of really weird C++ code, and tells you

00:00:09,881 --> 00:00:12,033
did you know this is valid C++?

00:00:12,033 --> 00:00:14,103
And you're like what?

00:00:14,103 --> 00:00:16,331
And you're like oh okay.

00:00:16,331 --> 00:00:19,355
But no one is going to write code like that anyway.

00:00:19,355 --> 00:00:21,159
Then you go off and have a nice day.

00:00:21,159 --> 00:00:22,322
But you can't do that if you maintain

00:00:22,322 --> 00:00:24,111
a C++ parser.

00:00:24,111 --> 00:00:25,818
If you do that then you have to like

00:00:25,818 --> 00:00:28,200
oh okay, sit down with the standard and figure

00:00:28,200 --> 00:00:30,060
out where if it's actually valid code.

00:00:30,060 --> 00:00:32,721
And if it is, and it doesn't work, fix the bug.

00:00:32,721 --> 00:00:33,822
So what you end up doing a lot

00:00:33,822 --> 00:00:35,438
is staring at the C++ grammar.

00:00:35,438 --> 00:00:36,671
C++ has a grammar.

00:00:36,671 --> 00:00:39,791
It's what, 20 pages in the standard that looks like this.

00:00:39,791 --> 00:00:41,341
There's beautiful things in there like

00:00:41,341 --> 00:00:44,629
pseudo-destructor-name, elaborated-type-specifier,

00:00:44,629 --> 00:00:47,241
or the nodeclspec-function-declaration.

00:00:47,241 --> 00:00:48,731
Which of course a function declaration with

00:00:48,731 --> 00:00:50,731
no decl-specifier set.

00:00:52,960 --> 00:00:55,684
But actually, you know this grammar

00:00:55,684 --> 00:00:56,917
is a just an aid to comprehension.

00:00:56,917 --> 00:00:59,605
It's not an exact statement of the language.

00:00:59,605 --> 00:01:02,768
And in particular, all these really complicated rules

00:01:02,768 --> 00:01:04,336
must be used to weed out syntactically valid

00:01:04,336 --> 00:01:05,966
but meaningless constructs.

00:01:05,966 --> 00:01:07,944
But it turns out even if you do all that,

00:01:07,944 --> 00:01:10,731
then there's still a lot of weed growing.

00:01:10,731 --> 00:01:13,398
For example, linkage-specifiers.

00:01:14,257 --> 00:01:16,737
This kind of extern C kind of thing.

00:01:16,737 --> 00:01:20,568
Grammar for that is well, linkage-specification

00:01:20,568 --> 00:01:22,024
is the declaration and it can also contain

00:01:22,024 --> 00:01:24,015
the declaration with braces, without braces

00:01:24,015 --> 00:01:25,897
so it actually nests right?

00:01:25,897 --> 00:01:27,146
So it can nest with braces,

00:01:27,146 --> 00:01:27,979
it can also nest without braces.

00:01:27,979 --> 00:01:30,678
(audience laughs)

00:01:30,678 --> 00:01:32,237
And actually extern has a second meaning.

00:01:32,237 --> 00:01:35,821
Extern can actually be a star specifier right?

00:01:35,821 --> 00:01:37,159
Which is also part of the declaration.

00:01:37,159 --> 00:01:38,371
So you can put it...

00:01:38,371 --> 00:01:40,015
well, where do you put it?

00:01:40,015 --> 00:01:40,848
(audience laughs)

00:01:40,848 --> 00:01:41,681
In the beginning or in the end?

00:01:41,681 --> 00:01:43,107
Well, which one is correct?

00:01:43,107 --> 00:01:45,086
(audience member interjects)

00:01:45,086 --> 00:01:47,286
(audience laughs)

00:01:47,286 --> 00:01:48,365
Godbolt's not going to help you

00:01:48,365 --> 00:01:50,637
because Microsoft rejects the first,

00:01:50,637 --> 00:01:51,940
GCC rejects the second,

00:01:51,940 --> 00:01:54,419
and Clang thinks both are okay.

00:01:54,419 --> 00:01:55,252
(audience laughs)

00:01:55,252 --> 00:01:58,842
Great C++ 17 feature, if with initializer.

00:01:58,842 --> 00:02:00,982
The initializer is the thing before the semi-colon

00:02:00,982 --> 00:02:02,534
it's great to initialize a variable.

00:02:02,534 --> 00:02:04,373
Here's the grammar for it.

00:02:04,373 --> 00:02:05,461
It turns out in the statement,

00:02:05,461 --> 00:02:07,342
that's the thing we're talking about here.

00:02:07,342 --> 00:02:10,260
Can be either a declaration or an expression

00:02:10,260 --> 00:02:12,002
basically it means it can be pretty much anything.

00:02:12,002 --> 00:02:13,178
So you can forward declare

00:02:13,178 --> 00:02:14,586
a class in there, that's valid.

00:02:14,586 --> 00:02:15,624
(audience laughs)

00:02:15,624 --> 00:02:18,891
You can put an expression in there like false,

00:02:18,891 --> 00:02:20,159
that's valid C++.

00:02:20,159 --> 00:02:20,992
(audience laughs)

00:02:20,992 --> 00:02:22,186
You can put an empty expression in there as well,

00:02:22,186 --> 00:02:24,555
that's also perfectly valid C++ grammar.

00:02:24,555 --> 00:02:26,540
I find a lot of compiler bugs when

00:02:26,540 --> 00:02:29,744
I was looking at these things.

00:02:29,744 --> 00:02:32,761
Great topic, initialization.

00:02:32,761 --> 00:02:33,861
You already saw a talk

00:02:33,861 --> 00:02:35,031
on initialization this week.

00:02:35,031 --> 00:02:37,811
There's about 50 ways you can initialize an int,

00:02:37,811 --> 00:02:38,952
these are just four of them.

00:02:38,952 --> 00:02:41,468
The best one of course is the one with parenthesis

00:02:41,468 --> 00:02:43,962
because it's so great that parenthesis,

00:02:43,962 --> 00:02:46,902
you know they appear everywhere and they conflict

00:02:46,902 --> 00:02:50,768
with everything so that's definitely my favorite one.

00:02:50,768 --> 00:02:53,366
Let's take for example, take function pointer

00:02:53,366 --> 00:02:56,452
which also has a lot of parenthesis.

00:02:56,452 --> 00:02:57,588
This is of course not modern C++,

00:02:57,588 --> 00:02:58,939
we have to write a trailing return type

00:02:58,939 --> 00:02:59,983
that's much better.

00:02:59,983 --> 00:03:01,877
And because a function pointer is variable,

00:03:01,877 --> 00:03:02,853
you can initialize it.

00:03:02,853 --> 00:03:04,615
You can put the initializer in parenths.

00:03:04,615 --> 00:03:05,466
That's great.

00:03:05,466 --> 00:03:06,299
(audience laughs)

00:03:06,299 --> 00:03:08,413
Most parsers will just say no.

00:03:08,413 --> 00:03:11,359
But, you know, it's valid.

00:03:11,359 --> 00:03:13,344
You can also put parens around decelerators,

00:03:13,344 --> 00:03:15,567
like variable names, right?

00:03:15,567 --> 00:03:17,734
Which is great because ...

00:03:18,660 --> 00:03:21,173
for example you have a function that takes

00:03:21,173 --> 00:03:22,848
a foo which is a struct.

00:03:22,848 --> 00:03:25,585
Let's give this parameter a name,

00:03:25,585 --> 00:03:26,826
let's also call it foo just because we can.

00:03:26,826 --> 00:03:28,912
(audience laughs)

00:03:28,912 --> 00:03:31,529
Let's put parens around the declarator.

00:03:31,529 --> 00:03:33,341
Now we all know this is the vexing parse.

00:03:33,341 --> 00:03:34,776
Now it's different thing right?

00:03:34,776 --> 00:03:36,663
It's actually a function, taking a function,

00:03:36,663 --> 00:03:39,686
taking a foo, turning a foo, turning void.

00:03:39,686 --> 00:03:41,526
Great, that's the vexing parse.

00:03:41,526 --> 00:03:43,734
But, actually this is not the most vexing parse.

00:03:43,734 --> 00:03:46,256
There's some more vexing parse.

00:03:46,256 --> 00:03:48,011
Which happens if you put another pair of parenthesis

00:03:48,011 --> 00:03:49,428
around the thing.

00:03:50,958 --> 00:03:53,312
So what type is this?

00:03:53,312 --> 00:03:55,003
(audience laughs)

00:03:55,003 --> 00:03:55,836
Anyone knows?

00:03:55,836 --> 00:03:56,669
(audience member interjects)

00:03:56,669 --> 00:04:00,034
So different compilers again use very different answers.

00:04:00,034 --> 00:04:01,288
(audience laughs)

00:04:01,288 --> 00:04:04,367
Right, next thing elaborated-type-specifier.

00:04:04,367 --> 00:04:05,200
That's really great.

00:04:05,200 --> 00:04:06,622
So it's used here if you have like bar,

00:04:06,622 --> 00:04:08,651
and it's an int, and it's also a class.

00:04:08,651 --> 00:04:10,149
And you know you can't declare a bar like that,

00:04:10,149 --> 00:04:11,617
you have to kind of disambiguate it.

00:04:11,617 --> 00:04:13,576
But it turns out that actually you can just

00:04:13,576 --> 00:04:15,791
use it like, you know, it's optional.

00:04:15,791 --> 00:04:18,215
But you can just use it.

00:04:18,215 --> 00:04:19,511
It actually turns out the grammar says you can

00:04:19,511 --> 00:04:21,517
use it everywhere, you can use a normal-type-specifier

00:04:21,517 --> 00:04:23,067
so if you have something like this.

00:04:23,067 --> 00:04:24,074
You can sprinkle the whole thing

00:04:24,074 --> 00:04:25,888
with elaborated-type-specifiers.

00:04:25,888 --> 00:04:26,738
(audience laughs)

00:04:26,738 --> 00:04:27,571
It's great.

00:04:27,571 --> 00:04:28,404
You can actually automate this,

00:04:28,404 --> 00:04:29,309
you can write a script that adds in there

00:04:29,309 --> 00:04:30,152
whichever type specifier everywhere where

00:04:30,152 --> 00:04:32,221
grammatically it's valid.

00:04:32,221 --> 00:04:35,836
It's great because every parser will just blow up.

00:04:35,836 --> 00:04:36,796
It's fun.

00:04:36,796 --> 00:04:38,351
They're also great because they're also...

00:04:38,351 --> 00:04:41,054
Elaborated-type-specifier also can simultaneously

00:04:41,054 --> 00:04:42,552
act as a forward declaration.

00:04:42,552 --> 00:04:43,385
Right?

00:04:43,385 --> 00:04:46,655
So this takes a pointer to S and also

00:04:46,655 --> 00:04:48,891
automatically forward declares S.

00:04:48,891 --> 00:04:50,172
So that is actually gonna compile even if S

00:04:50,172 --> 00:04:51,231
is not declared anywhere.

00:04:51,231 --> 00:04:52,975
(audience laughs)

00:04:52,975 --> 00:04:54,563
And actually it's great because it has

00:04:54,563 --> 00:04:56,338
really weird scoping rules.

00:04:56,338 --> 00:04:57,335
Like if you put that in a class it

00:04:57,335 --> 00:04:59,864
is still gonna be visible outside.

00:04:59,864 --> 00:05:00,697
(audience laughs)

00:05:00,697 --> 00:05:01,530
Yeah.

00:05:01,530 --> 00:05:02,857
Great feature I love C++.

00:05:02,857 --> 00:05:05,052
Pseudo-destructor-name that's another one

00:05:05,052 --> 00:05:07,086
which is really great.

00:05:07,086 --> 00:05:09,510
So pseudo-destructor-name is tilde

00:05:09,510 --> 00:05:11,175
with a type-name so it looks like a destructor.

00:05:11,175 --> 00:05:13,669
But actually, the actual destructor

00:05:13,669 --> 00:05:14,790
would be still the class-name.

00:05:14,790 --> 00:05:16,867
Class-name and type-name are different things.

00:05:16,867 --> 00:05:18,636
So a type-name would be a type

00:05:18,636 --> 00:05:20,593
which is not a class, in this case.

00:05:20,593 --> 00:05:22,412
So you can do something like this

00:05:22,412 --> 00:05:24,075
except actually you can't because int

00:05:24,075 --> 00:05:25,456
is actually not a type-name,

00:05:25,456 --> 00:05:27,016
it is a type specifier.

00:05:27,016 --> 00:05:28,911
So you have to use a using,

00:05:28,911 --> 00:05:30,255
and then it's okay.

00:05:30,255 --> 00:05:32,066
(audience laughs loudly)

00:05:32,066 --> 00:05:32,899
(audience claps)

00:05:32,899 --> 00:05:33,869
But fear not, fear not.

00:05:33,869 --> 00:05:36,497
So the destructor for int doesn't work.

00:05:36,497 --> 00:05:38,287
Let's declare one.

00:05:38,287 --> 00:05:39,120
That compiles!

00:05:39,120 --> 00:05:40,767
(audience laughs)

00:05:40,767 --> 00:05:42,258
Unfortunately, this is of course not

00:05:42,258 --> 00:05:44,103
a destructor this is a default

00:05:44,103 --> 00:05:45,490
constructor is int which is zero and then

00:05:45,490 --> 00:05:47,099
bit not right?

00:05:47,099 --> 00:05:48,088
(audience laughs)

00:05:48,088 --> 00:05:50,728
So this tilde thing is really ambiguous right?

00:05:50,728 --> 00:05:52,072
It's like it could be one or the other,

00:05:52,072 --> 00:05:55,130
so I have a suggestion how to make it better.

00:05:55,130 --> 00:05:56,940
So that never confuse destructors with

00:05:56,940 --> 00:05:58,474
these kind of things.

00:05:58,474 --> 00:06:00,293
So if you have a class and you declare

00:06:00,293 --> 00:06:01,512
a constructor and destructor

00:06:01,512 --> 00:06:02,556
and this tilde thing.

00:06:02,556 --> 00:06:04,524
And really want to make sure that's not the

00:06:04,524 --> 00:06:06,391
bit not tilde.

00:06:06,391 --> 00:06:08,146
You can actually write it like that.

00:06:08,146 --> 00:06:08,979
(audience laughs)

00:06:08,979 --> 00:06:10,431
Because we have alternative tokens!

00:06:10,431 --> 00:06:11,264
Right?

00:06:11,264 --> 00:06:12,276
So the alternative token for tilde,

00:06:12,276 --> 00:06:13,886
is compl, which is great.

00:06:13,886 --> 00:06:17,272
So now this doesn't look like an expression anymore.

00:06:17,272 --> 00:06:18,498
So, it's nice and clean.

00:06:18,498 --> 00:06:20,824
And actually this doesn't work only for destructors,

00:06:20,824 --> 00:06:24,649
it also works for copy constructors and move constructors,

00:06:24,649 --> 00:06:26,724
you can also use alternative tokens for those.

00:06:26,724 --> 00:06:27,557
(audience laughs)

00:06:27,557 --> 00:06:29,266
This is also valid C++.

00:06:29,266 --> 00:06:31,893
So, I recommend we declare our special

00:06:31,893 --> 00:06:32,980
mema functions like this,

00:06:32,980 --> 00:06:33,948
because it looks much cleaner,

00:06:33,948 --> 00:06:36,512
You know it's much simpler to English.

00:06:36,512 --> 00:06:37,345
(audience laughs)

00:06:37,345 --> 00:06:38,532
Much more like English you know?

00:06:38,532 --> 00:06:40,845
We want our code to look like English.

00:06:40,845 --> 00:06:42,412
Not like gibberish right?

00:06:42,412 --> 00:06:46,800
So yeah, great that's all I have thank you.

00:06:46,800 --> 00:06:49,800

YouTube URL: https://www.youtube.com/watch?v=tsG95Y-C14k


