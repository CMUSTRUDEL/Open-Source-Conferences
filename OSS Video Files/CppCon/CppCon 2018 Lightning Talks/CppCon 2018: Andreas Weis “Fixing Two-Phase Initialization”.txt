Title: CppCon 2018: Andreas Weis “Fixing Two-Phase Initialization”
Publication date: 2018-11-10
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,920
I work from B&W which means I have to

00:00:02,730 --> 00:00:07,490
deal with a lot of embedded code which

00:00:04,920 --> 00:00:10,110
means I have to deal a lot which code

00:00:07,490 --> 00:00:12,900
has to be compiled without support for

00:00:10,110 --> 00:00:16,190
exception handling and the one point

00:00:12,900 --> 00:00:18,660
where that really hurts is constructors

00:00:16,190 --> 00:00:21,930
so um this is going to be our little

00:00:18,660 --> 00:00:25,039
example class for tonight and the

00:00:21,930 --> 00:00:27,330
problematic part is shown in red here

00:00:25,039 --> 00:00:28,920
don't get too hung up on on the make

00:00:27,330 --> 00:00:31,969
unique this is just supposed to be like

00:00:28,920 --> 00:00:34,110
a placeholder for any non-trivial

00:00:31,969 --> 00:00:36,930
initialization of the class state that

00:00:34,110 --> 00:00:39,239
could fail and if that fails we actually

00:00:36,930 --> 00:00:42,090
want to have a channel for reporting

00:00:39,239 --> 00:00:43,649
that error back to the outside so what

00:00:42,090 --> 00:00:46,530
people typically do is they use

00:00:43,649 --> 00:00:48,840
two-phase initialization that means we

00:00:46,530 --> 00:00:51,390
basically make the constructor empty

00:00:48,840 --> 00:00:53,760
like do nothing so that we can make it

00:00:51,390 --> 00:00:57,210
know accept and then we add a member

00:00:53,760 --> 00:00:59,160
function in it or whichever name you

00:00:57,210 --> 00:01:02,100
prefer and that member function will now

00:00:59,160 --> 00:01:04,019
perform all of the actual work and since

00:01:02,100 --> 00:01:07,080
this is now an ordinary function we can

00:01:04,019 --> 00:01:09,240
just use the return value to report back

00:01:07,080 --> 00:01:11,909
any error to the outside that might be

00:01:09,240 --> 00:01:13,229
generated by the initialization so I'm

00:01:11,909 --> 00:01:16,350
sure most of you have seen this pattern

00:01:13,229 --> 00:01:18,960
before and those of you have tried to

00:01:16,350 --> 00:01:21,060
use it we're probably hated because it

00:01:18,960 --> 00:01:22,890
leads to a lot of objects and partial

00:01:21,060 --> 00:01:24,960
constructed State once the constructor

00:01:22,890 --> 00:01:26,310
is run the object is still not usable I

00:01:24,960 --> 00:01:29,340
will have to call the init function

00:01:26,310 --> 00:01:32,570
first and if I forget that and all hell

00:01:29,340 --> 00:01:36,270
breaks loose um so this is not very nice

00:01:32,570 --> 00:01:39,060
so a first attempt to fix this has

00:01:36,270 --> 00:01:42,479
actually been if you look up for example

00:01:39,060 --> 00:01:44,490
a boost outcome they have a whole

00:01:42,479 --> 00:01:48,000
chapter on this and the way that they

00:01:44,490 --> 00:01:51,119
try to fix this is as following they

00:01:48,000 --> 00:01:53,759
make the constructor private and then

00:01:51,119 --> 00:01:55,799
instead of the init member function they

00:01:53,759 --> 00:01:59,630
actually add a static member function

00:01:55,799 --> 00:02:02,850
create member function and that one then

00:01:59,630 --> 00:02:06,590
performs both the constructor call as

00:02:02,850 --> 00:02:10,590
well as the actual construction of the

00:02:06,590 --> 00:02:13,050
of the state and now the advantages of

00:02:10,590 --> 00:02:13,650
course since the constructor is private

00:02:13,050 --> 00:02:15,480
I

00:02:13,650 --> 00:02:18,560
can only construct new objects through

00:02:15,480 --> 00:02:21,060
this create function and since that

00:02:18,560 --> 00:02:23,040
performs both steps of the two phase

00:02:21,060 --> 00:02:26,120
initialization I cannot get these

00:02:23,040 --> 00:02:28,650
partially constructed objects anymore

00:02:26,120 --> 00:02:32,340
this is great this solves our problem

00:02:28,650 --> 00:02:34,200
but it creates a new problem this is no

00:02:32,340 --> 00:02:36,420
longer idiomatic construction because in

00:02:34,200 --> 00:02:38,939
C++ if you want to construct objects we

00:02:36,420 --> 00:02:42,900
call the constructor we do not call some

00:02:38,939 --> 00:02:45,000
weird create function so this leads to

00:02:42,900 --> 00:02:47,480
problems if for example we want to use

00:02:45,000 --> 00:02:50,099
stuff like and place back or make shared

00:02:47,480 --> 00:02:52,700
which always assume that there is a

00:02:50,099 --> 00:02:56,819
constructor to be called

00:02:52,700 --> 00:02:59,430
so we came up with a way around this and

00:02:56,819 --> 00:03:01,430
we refer to this idiom as inverse to

00:02:59,430 --> 00:03:04,379
face initialization because it sort of

00:03:01,430 --> 00:03:07,409
switches the phases around of the

00:03:04,379 --> 00:03:11,639
two-phase initialization so instead of

00:03:07,409 --> 00:03:14,220
the create static function we actually

00:03:11,639 --> 00:03:16,889
have a pre construct member function

00:03:14,220 --> 00:03:19,859
which returns not the final class but it

00:03:16,889 --> 00:03:23,040
returns all the construction token and

00:03:19,859 --> 00:03:25,889
this construction token is able to hold

00:03:23,040 --> 00:03:28,139
the same state as the final class but

00:03:25,889 --> 00:03:30,650
otherwise it's like the world's dumbest

00:03:28,139 --> 00:03:33,930
type you cannot do anything with it

00:03:30,650 --> 00:03:36,569
except pass it to the actual constructor

00:03:33,930 --> 00:03:41,220
of the final class which will consume it

00:03:36,569 --> 00:03:46,319
and then move this state over into into

00:03:41,220 --> 00:03:48,239
the final object and now since all of

00:03:46,319 --> 00:03:50,729
the meaty stuff has already happened in

00:03:48,239 --> 00:03:55,769
the pre construct phase now we can do

00:03:50,729 --> 00:03:57,419
this the second step also no example so

00:03:55,769 --> 00:04:00,479
this is how it looks like on the user

00:03:57,419 --> 00:04:02,760
side the user will just call pre

00:04:00,479 --> 00:04:04,409
construct get back such and expect a

00:04:02,760 --> 00:04:06,900
construction token then you can check

00:04:04,409 --> 00:04:09,150
for errors if there were no errors then

00:04:06,900 --> 00:04:10,919
we just consume it by the constructor

00:04:09,150 --> 00:04:13,979
and then we get our final object and

00:04:10,919 --> 00:04:16,019
this also works with make sure now and

00:04:13,979 --> 00:04:18,329
then place back and whatever else your

00:04:16,019 --> 00:04:21,570
library might be doing so this solves

00:04:18,329 --> 00:04:24,360
both of our problems so this is again

00:04:21,570 --> 00:04:26,789
the idiom on one slide

00:04:24,360 --> 00:04:30,449
and like if you look at it closely you

00:04:26,789 --> 00:04:31,860
will actually notice that we still have

00:04:30,449 --> 00:04:34,050
this this problem of the weird

00:04:31,860 --> 00:04:36,000
construction in there but we actually

00:04:34,050 --> 00:04:38,819
moved all of that to the construction

00:04:36,000 --> 00:04:40,530
token and since the construction token

00:04:38,819 --> 00:04:42,300
is not really an object that we want to

00:04:40,530 --> 00:04:43,949
keep around right we only construct the

00:04:42,300 --> 00:04:46,139
temporarily and then consume it

00:04:43,949 --> 00:04:48,629
immediately to construct the final food

00:04:46,139 --> 00:04:50,639
um it actually doesn't hurt us that much

00:04:48,629 --> 00:04:52,949
but the object that we care about of

00:04:50,639 --> 00:04:56,180
type foo I'm the one is actually now

00:04:52,949 --> 00:04:56,180
really nice and behaved

00:04:57,490 --> 00:05:02,999

YouTube URL: https://www.youtube.com/watch?v=S7I66lZX_zM


