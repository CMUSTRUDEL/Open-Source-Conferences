Title: CppCon 2018: Tony Wasserka “Curly Function Call Syntax”
Publication date: 2018-11-11
Playlist: CppCon 2018 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:06,299
hi I'm Tony I'm a freelance of working

00:00:03,210 --> 00:00:07,740
on embedded systems at a day and for

00:00:06,299 --> 00:00:09,750
breakfast I called game console

00:00:07,740 --> 00:00:11,550
emulators so this talk is actually an

00:00:09,750 --> 00:00:13,170
extension of my talk on Monday about

00:00:11,550 --> 00:00:14,370
emulating the Nintendo 3ds with

00:00:13,170 --> 00:00:17,100
generative and declarative programming

00:00:14,370 --> 00:00:22,740
and this talk wasn't quite long enough

00:00:17,100 --> 00:00:23,789
so I kind of had to some stuff I don't

00:00:22,740 --> 00:00:26,369
actually want to show you this one

00:00:23,789 --> 00:00:28,619
so the question I've been asking myself

00:00:26,369 --> 00:00:31,529
is what is the best feature in C++ 11

00:00:28,619 --> 00:00:32,880
well obviously it's curly brace

00:00:31,529 --> 00:00:35,489
initialization curly brace and

00:00:32,880 --> 00:00:39,239
naturalisation avoids the most vexing

00:00:35,489 --> 00:00:42,149
path it allows type narrowing and all of

00:00:39,239 --> 00:00:43,680
these kind of very evil things so let's

00:00:42,149 --> 00:00:50,370
just take a look at very quick look at

00:00:43,680 --> 00:00:51,989
this so a very simple example previously

00:00:50,370 --> 00:00:54,539
this wasn't possible you know

00:00:51,989 --> 00:00:58,800
initializing a vector with paranthesis

00:00:54,539 --> 00:01:12,049
but thanks to C++ 11 we can just use

00:00:58,800 --> 00:01:12,049
curly braces and it just works yeah

00:01:26,150 --> 00:01:33,360
getting there getting there there we go

00:01:32,130 --> 00:01:36,780
so it doesn't all put anything but it

00:01:33,360 --> 00:01:38,880
compiles you know that's all we care

00:01:36,780 --> 00:01:40,200
about it also works for custom

00:01:38,880 --> 00:01:41,790
structures I don't need to show you that

00:01:40,200 --> 00:01:44,100
one so this is just the constructor

00:01:41,790 --> 00:01:45,720
doing stuff we can also go use the curly

00:01:44,100 --> 00:01:47,880
brace syntax so the question I've been

00:01:45,720 --> 00:01:49,950
asking myself though since curly braces

00:01:47,880 --> 00:01:52,200
obviously brings so many benefits to the

00:01:49,950 --> 00:01:55,200
language can we use them in more places

00:01:52,200 --> 00:01:57,899
can we replace more parantesis with

00:01:55,200 --> 00:02:00,390
curly braces and if you think that's

00:01:57,899 --> 00:02:01,979
utter nonsense then I beg you please

00:02:00,390 --> 00:02:06,929
stop in series this is the lightening

00:02:01,979 --> 00:02:10,200
talk session so I've been thinking about

00:02:06,929 --> 00:02:11,790
a number of possible attempts this is

00:02:10,200 --> 00:02:15,030
just like some become because we have a

00:02:11,790 --> 00:02:16,560
function do stuff just stuff we call it

00:02:15,030 --> 00:02:17,519
with parent pieces and obviously this is

00:02:16,560 --> 00:02:22,280
just horrible

00:02:17,519 --> 00:02:24,510
come on so my attempt of fixing this is

00:02:22,280 --> 00:02:25,590
using various initialization because

00:02:24,510 --> 00:02:27,780
we've been thinking about brace

00:02:25,590 --> 00:02:29,310
initialization completely wrong it's not

00:02:27,780 --> 00:02:31,920
actually initializing things it's

00:02:29,310 --> 00:02:33,750
calling a function because it's calling

00:02:31,920 --> 00:02:36,900
the constructor and that's just you know

00:02:33,750 --> 00:02:39,840
yet about the function so what we want

00:02:36,900 --> 00:02:42,150
to do is we want to write a class which

00:02:39,840 --> 00:02:44,850
has a constructor which calls the actual

00:02:42,150 --> 00:02:48,840
function that we have and that allows us

00:02:44,850 --> 00:02:51,060
to conveniently call my type with the

00:02:48,840 --> 00:02:58,320
arguments that are then given to dooster

00:02:51,060 --> 00:03:00,480
we compile this I close my function with

00:02:58,320 --> 00:03:06,060
the given arguments it's beautiful isn't

00:03:00,480 --> 00:03:07,470
it now remind me again where did I

00:03:06,060 --> 00:03:11,310
actually want to go with this let's

00:03:07,470 --> 00:03:14,459
let's see in the next method right the

00:03:11,310 --> 00:03:16,290
actual serious part of this talk so it

00:03:14,459 --> 00:03:18,390
turns out the function call with

00:03:16,290 --> 00:03:21,840
parantesis has an actual issue and that

00:03:18,390 --> 00:03:23,549
is when you this is somewhat more

00:03:21,840 --> 00:03:25,859
complicated expression so here we call

00:03:23,549 --> 00:03:27,690
do stuff let me make this a little bit

00:03:25,859 --> 00:03:32,070
bigger even this stuff

00:03:27,690 --> 00:03:38,690
we're on we transient fermented number

00:03:32,070 --> 00:03:40,800
argument and if you compile this five

00:03:38,690 --> 00:03:44,220
but sivanna greek and all that because

00:03:40,800 --> 00:03:46,260
you know nobody rich warnings it works

00:03:44,220 --> 00:03:52,540
fine okay hmm let's try a different

00:03:46,260 --> 00:03:54,170
compiler well that's interesting

00:03:52,540 --> 00:03:57,090
[Music]

00:03:54,170 --> 00:03:58,110
okay so as I was saying curly braces

00:03:57,090 --> 00:04:01,770
make everything better

00:03:58,110 --> 00:04:04,700
let's try the curly brace index and see

00:04:01,770 --> 00:04:08,220
the same class as before but now we are

00:04:04,700 --> 00:04:14,820
so now it's called curly call I think I

00:04:08,220 --> 00:04:17,760
believe and use a place of its index it

00:04:14,820 --> 00:04:19,320
just works so question might be now why

00:04:17,760 --> 00:04:25,430
does it work well this is where my

00:04:19,320 --> 00:04:25,430
fourth window comes in C++ standard

00:04:26,270 --> 00:04:32,580
section I'd have to scroll up too much

00:04:29,310 --> 00:04:33,900
just for texture search for the thing we

00:04:32,580 --> 00:04:36,210
could with us yourself a basically what

00:04:33,900 --> 00:04:39,200
it says is that within an initialize all

00:04:36,210 --> 00:04:41,940
this all the arguments that follow are

00:04:39,200 --> 00:04:44,210
evaluate it's quickly in sequence and

00:04:41,940 --> 00:04:46,650
that is precisely what we want for our

00:04:44,210 --> 00:04:49,250
code snippet here so we want to have

00:04:46,650 --> 00:04:52,800
this expression evaluated first

00:04:49,250 --> 00:04:55,410
basically in order so that's nice

00:04:52,800 --> 00:04:57,180
you might just you know write these two

00:04:55,410 --> 00:04:58,830
things out manually yourself and assign

00:04:57,180 --> 00:04:59,460
and two variables and stuff but yeah no

00:04:58,830 --> 00:05:01,080
that's boring

00:04:59,460 --> 00:05:03,210
plus there's an actually use case for

00:05:01,080 --> 00:05:04,670
this which is in my talk you can look at

00:05:03,210 --> 00:05:06,280
[Applause]

00:05:04,670 --> 00:05:10,550
[Music]

00:05:06,280 --> 00:05:10,550

YouTube URL: https://www.youtube.com/watch?v=L8eeDzTWEtU


