Title: Exploration of C++20 Meta Programming - Inbal Levi - CppCon 2020
Publication date: 2020-09-29
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/exploration_of_cpp20_metaprogramming/exploration_of_cpp20_metaprogramming__inbal_levi__cppcon_2020.pdf
---
In this talk, we will take the journey to compile-time.

We will start with adding templates to existing program, and overview overload resolution and conditioning at compile time.

We will continue with exploring the latest version of template metaprogramming updated by the release of C++20.

Finally, we will present techniques to control the compiled-time logic when instantiating templates, on C++20 and beyond.

---
Inbal Levi is an embedded software engineer with a passion for high performance.
She is one of the organizers of CoreCpp conference and CoreCpp user group.
She's also a member of ISO/IEC JTC1/SC22/WG21 (the C++ Standards Committee), and among the founders of the Israeli NB Mirror committee.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,040 --> 00:00:14,400
hello everyone

00:00:11,200 --> 00:00:15,679
welcome to exploration of c plus plus

00:00:14,400 --> 00:00:18,480
meta programming

00:00:15,679 --> 00:00:19,199
20 of course and i'm really i'm really

00:00:18,480 --> 00:00:22,720
glad you

00:00:19,199 --> 00:00:25,840
joined me today so today

00:00:22,720 --> 00:00:27,680
we're going to talk about simple plus 20

00:00:25,840 --> 00:00:29,039
meter programming but first of all i'm

00:00:27,680 --> 00:00:32,320
going to introduce myself

00:00:29,039 --> 00:00:35,760
so my name is inba levy

00:00:32,320 --> 00:00:37,440
i'm a c plus plus enthusiast and i work

00:00:35,760 --> 00:00:39,360
i'm an embedded software engineer and i

00:00:37,440 --> 00:00:42,239
work at solaredge

00:00:39,360 --> 00:00:43,360
on smart home devices i'm also one of

00:00:42,239 --> 00:00:46,879
the organizers

00:00:43,360 --> 00:00:48,800
of course cpp conference and this is a

00:00:46,879 --> 00:00:50,640
end user group and this is the largest

00:00:48,800 --> 00:00:53,920
user group for cpp

00:00:50,640 --> 00:00:57,440
in israel along with adishavit

00:00:53,920 --> 00:01:01,600
and michael goldstein and

00:00:57,440 --> 00:01:03,600
i'm also uh a member of world group 21

00:01:01,600 --> 00:01:04,720
and one of the founders of the israeli

00:01:03,600 --> 00:01:08,799
national body

00:01:04,720 --> 00:01:12,159
of of the simplest plus iso

00:01:08,799 --> 00:01:13,200
conference i've studied physics and i

00:01:12,159 --> 00:01:15,040
also love math

00:01:13,200 --> 00:01:16,880
so if anyone wants to talk about math

00:01:15,040 --> 00:01:18,960
slider i would love to

00:01:16,880 --> 00:01:20,240
so let's have uh let's start with

00:01:18,960 --> 00:01:23,119
motivation to

00:01:20,240 --> 00:01:25,200
this talk so templates are a powerful

00:01:23,119 --> 00:01:26,880
tool for simpleplus programmers and i'm

00:01:25,200 --> 00:01:30,560
sure that everyone here

00:01:26,880 --> 00:01:31,119
is not aware of that each simplest

00:01:30,560 --> 00:01:34,560
version

00:01:31,119 --> 00:01:37,600
have evolved and evolved this topic and

00:01:34,560 --> 00:01:40,799
uh by each plus version we can see a

00:01:37,600 --> 00:01:43,280
better usage in this mechanism

00:01:40,799 --> 00:01:44,960
we'll see the value of adding templates

00:01:43,280 --> 00:01:47,520
in your code

00:01:44,960 --> 00:01:48,960
and i just want to add here that we're

00:01:47,520 --> 00:01:52,159
going to start

00:01:48,960 --> 00:01:55,360
as if no templates are part of our

00:01:52,159 --> 00:01:58,479
code base and and this talk is uh

00:01:55,360 --> 00:01:58,880
for intermediate and beginners but i

00:01:58,479 --> 00:02:01,759
also

00:01:58,880 --> 00:02:02,799
think it has some very interesting uh uh

00:02:01,759 --> 00:02:05,280
guideline general

00:02:02,799 --> 00:02:06,079
simples plus 20 guidelines for advanced

00:02:05,280 --> 00:02:10,720
programmers

00:02:06,079 --> 00:02:13,280
so uh some environments uh discourage uh

00:02:10,720 --> 00:02:16,239
extensive use of templates and

00:02:13,280 --> 00:02:17,200
i'm not sure if you guys familiar with

00:02:16,239 --> 00:02:20,879
this

00:02:17,200 --> 00:02:24,000
um style guide uh in uh

00:02:20,879 --> 00:02:24,800
if you were in a real world i would have

00:02:24,000 --> 00:02:28,000
asked you now

00:02:24,800 --> 00:02:30,560
uh to suggest where is this

00:02:28,000 --> 00:02:31,760
style guide which company this tag it

00:02:30,560 --> 00:02:33,920
belongs to

00:02:31,760 --> 00:02:36,000
but this this is the style guide of

00:02:33,920 --> 00:02:39,200
google which is a very advanced

00:02:36,000 --> 00:02:42,160
company i would i would presume and

00:02:39,200 --> 00:02:44,000
um and they're suggesting to avoid

00:02:42,160 --> 00:02:44,879
complicated meta programming in the code

00:02:44,000 --> 00:02:47,040
base

00:02:44,879 --> 00:02:48,720
and i actually don't blame them they

00:02:47,040 --> 00:02:51,840
have a really good reason because

00:02:48,720 --> 00:02:55,360
templates considered as an advanced

00:02:51,840 --> 00:02:58,319
topic and for for experienced

00:02:55,360 --> 00:02:58,319
engineers and

00:02:58,800 --> 00:03:02,400
you want to be able you want to have

00:03:00,560 --> 00:03:05,599
your code base available

00:03:02,400 --> 00:03:08,080
to different levels of developers

00:03:05,599 --> 00:03:09,680
especially if you recruit new ones et

00:03:08,080 --> 00:03:12,720
cetera

00:03:09,680 --> 00:03:13,599
so i would hope that on c plus 20 will

00:03:12,720 --> 00:03:16,720
have

00:03:13,599 --> 00:03:20,000
uh will have syntax that

00:03:16,720 --> 00:03:23,760
allows more program more developers to

00:03:20,000 --> 00:03:26,239
to use template meta programming

00:03:23,760 --> 00:03:27,599
and in the following slides we see how

00:03:26,239 --> 00:03:30,879
how simple pass

00:03:27,599 --> 00:03:33,280
actually was 20 actually uh uh

00:03:30,879 --> 00:03:34,239
to my opinion creates a paradigm shift

00:03:33,280 --> 00:03:37,200
in the way we

00:03:34,239 --> 00:03:37,200
use meta programming

00:03:37,840 --> 00:03:43,599
so this is the outline of our talk so uh

00:03:41,360 --> 00:03:45,599
first we're gonna start by introducing

00:03:43,599 --> 00:03:48,080
what are templates

00:03:45,599 --> 00:03:50,000
then i'm going to continue as i said

00:03:48,080 --> 00:03:51,120
before by adding templates to existing

00:03:50,000 --> 00:03:53,599
code

00:03:51,120 --> 00:03:56,000
i'm going to go over overworld

00:03:53,599 --> 00:03:58,239
resolution and adl which are

00:03:56,000 --> 00:03:59,840
important topics in order to understand

00:03:58,239 --> 00:04:01,680
template meta programming but they're

00:03:59,840 --> 00:04:03,599
also important in general

00:04:01,680 --> 00:04:05,599
uh and then we're going to move to

00:04:03,599 --> 00:04:07,360
conditions at compile time before

00:04:05,599 --> 00:04:09,680
sequence 20

00:04:07,360 --> 00:04:10,799
and conditions at compile time using c

00:04:09,680 --> 00:04:12,959
plus plus 20

00:04:10,799 --> 00:04:15,280
and beyond some of the things i'm going

00:04:12,959 --> 00:04:18,000
to show until at the end are

00:04:15,280 --> 00:04:19,680
not part of the version yet i would hope

00:04:18,000 --> 00:04:22,079
in the future there will be

00:04:19,680 --> 00:04:23,840
and at last we're going to look at

00:04:22,079 --> 00:04:26,000
advanced methods for controlling

00:04:23,840 --> 00:04:30,880
compile-time logic

00:04:26,000 --> 00:04:34,320
so let's start what are templates

00:04:30,880 --> 00:04:34,800
so as i said before we're going to go

00:04:34,320 --> 00:04:38,000
over

00:04:34,800 --> 00:04:40,880
this very very briefly

00:04:38,000 --> 00:04:43,520
so templates can create it can be used

00:04:40,880 --> 00:04:46,360
to create a class or a function

00:04:43,520 --> 00:04:47,759
and here we can see uh the the

00:04:46,360 --> 00:04:50,880
[Music]

00:04:47,759 --> 00:04:54,320
the template for

00:04:50,880 --> 00:04:55,360
having a class type and you can see that

00:04:54,320 --> 00:04:58,560
your expect

00:04:55,360 --> 00:05:00,880
accepting a type here and

00:04:58,560 --> 00:05:02,479
you can use the type in your class you

00:05:00,880 --> 00:05:05,600
can also not use it

00:05:02,479 --> 00:05:07,840
if you prefer to but this this type is

00:05:05,600 --> 00:05:10,880
available to you

00:05:07,840 --> 00:05:14,080
in the definition and

00:05:10,880 --> 00:05:16,320
uh this this is how you will define

00:05:14,080 --> 00:05:17,520
a template function so you accept again

00:05:16,320 --> 00:05:20,240
the type here

00:05:17,520 --> 00:05:20,960
and you use it and just additional way

00:05:20,240 --> 00:05:24,320
to do it

00:05:20,960 --> 00:05:26,080
and by by taking the type uh

00:05:24,320 --> 00:05:27,759
that you've passed you can actually take

00:05:26,080 --> 00:05:30,000
it as a

00:05:27,759 --> 00:05:31,759
as a parameter for the function but you

00:05:30,000 --> 00:05:34,800
don't have to and i'll show later

00:05:31,759 --> 00:05:37,280
uh the two different versions

00:05:34,800 --> 00:05:38,240
and again i would say that this this

00:05:37,280 --> 00:05:40,639
talk is not

00:05:38,240 --> 00:05:41,280
uh introductory to template meta

00:05:40,639 --> 00:05:44,000
programming

00:05:41,280 --> 00:05:44,639
um but it assumes that you do familiar

00:05:44,000 --> 00:05:48,639
with it

00:05:44,639 --> 00:05:51,039
but again you're not a library author

00:05:48,639 --> 00:05:52,000
basically but there are two very

00:05:51,039 --> 00:05:54,240
interesting talks

00:05:52,000 --> 00:05:55,600
in this conference and i mean actually

00:05:54,240 --> 00:05:58,960
four two uh

00:05:55,600 --> 00:06:02,560
uh talks that are uh double double talks

00:05:58,960 --> 00:06:04,160
and one is uh bake two basics for

00:06:02,560 --> 00:06:07,120
template meta programming and the other

00:06:04,160 --> 00:06:10,479
one is for type trades i will

00:06:07,120 --> 00:06:13,680
mention them later so

00:06:10,479 --> 00:06:16,800
function template is usable only if you

00:06:13,680 --> 00:06:18,840
can see the definition so clearly um

00:06:16,800 --> 00:06:21,120
declaration is not enough just like in

00:06:18,840 --> 00:06:24,240
regular template function

00:06:21,120 --> 00:06:25,919
and there's two ways to have uh so so

00:06:24,240 --> 00:06:27,120
this is the collection this is the

00:06:25,919 --> 00:06:30,400
definition

00:06:27,120 --> 00:06:33,600
and there's two ways to have explicit uh

00:06:30,400 --> 00:06:36,160
instantiation for template

00:06:33,600 --> 00:06:38,080
function and there's a few ways to have

00:06:36,160 --> 00:06:41,280
an implicit instantiation now

00:06:38,080 --> 00:06:44,960
this is useful uh if you uh

00:06:41,280 --> 00:06:47,680
want to implement a library

00:06:44,960 --> 00:06:48,479
a template library then there's two ways

00:06:47,680 --> 00:06:51,199
you can do that

00:06:48,479 --> 00:06:52,080
the first one would be to expose your

00:06:51,199 --> 00:06:54,080
definition

00:06:52,080 --> 00:06:55,520
in the header file uh of course the

00:06:54,080 --> 00:06:57,360
declaration as well

00:06:55,520 --> 00:06:59,599
and in that case the user would be able

00:06:57,360 --> 00:07:02,080
to instantiate your templates

00:06:59,599 --> 00:07:02,960
your library for every type that he

00:07:02,080 --> 00:07:05,919
desires

00:07:02,960 --> 00:07:08,000
and the second way would be just to have

00:07:05,919 --> 00:07:10,160
the declaration in the header file

00:07:08,000 --> 00:07:12,560
and the definition hidden and then in

00:07:10,160 --> 00:07:15,680
the header file you could use

00:07:12,560 --> 00:07:18,240
this method basically this syntax

00:07:15,680 --> 00:07:19,680
to explicitly instantiate your uh

00:07:18,240 --> 00:07:22,800
templates and therefore

00:07:19,680 --> 00:07:25,120
limit the types that the user can use

00:07:22,800 --> 00:07:26,560
and and this would be like a closed

00:07:25,120 --> 00:07:30,000
interface

00:07:26,560 --> 00:07:34,160
and another thing i would like to to

00:07:30,000 --> 00:07:35,360
point out is um simplest 20 adds a

00:07:34,160 --> 00:07:37,520
synthetic sugar

00:07:35,360 --> 00:07:38,639
for for this function template

00:07:37,520 --> 00:07:41,280
decoration

00:07:38,639 --> 00:07:42,319
i actually chose not to use that uh for

00:07:41,280 --> 00:07:44,639
the talk because

00:07:42,319 --> 00:07:45,599
i still want this to be some somewhat

00:07:44,639 --> 00:07:48,240
introductional

00:07:45,599 --> 00:07:48,720
introductory level and he uses auto and

00:07:48,240 --> 00:07:51,840
i

00:07:48,720 --> 00:07:55,199
i would think that it might be a bit uh

00:07:51,840 --> 00:07:57,360
less explicit but you can search later

00:07:55,199 --> 00:07:58,479
and there's a way to do that it's called

00:07:57,360 --> 00:08:02,960
arbitrary

00:07:58,479 --> 00:08:02,960
turret function template declaration

00:08:03,280 --> 00:08:08,400
so uh as i said templates are evaluated

00:08:06,879 --> 00:08:10,319
compile time and they're also to

00:08:08,400 --> 00:08:12,160
incomplete that means that you can

00:08:10,319 --> 00:08:14,080
achieve any functionality of tuning

00:08:12,160 --> 00:08:16,479
machine with templates

00:08:14,080 --> 00:08:17,759
and they have fewer layers of usage so

00:08:16,479 --> 00:08:20,639
i've mentioned that before

00:08:17,759 --> 00:08:21,520
i'm just summarizing here that first of

00:08:20,639 --> 00:08:24,800
all you can

00:08:21,520 --> 00:08:25,280
use them to avoid rewriting repeated

00:08:24,800 --> 00:08:29,039
logic

00:08:25,280 --> 00:08:31,919
so clearly when you write something

00:08:29,039 --> 00:08:32,640
once it's less error prone and that's a

00:08:31,919 --> 00:08:35,360
good practice

00:08:32,640 --> 00:08:37,760
in general and they can also be used to

00:08:35,360 --> 00:08:39,599
write generic code as i mentioned before

00:08:37,760 --> 00:08:40,800
you can use them in order to provide a

00:08:39,599 --> 00:08:43,279
library in

00:08:40,800 --> 00:08:45,519
two ways that i mentioned and they

00:08:43,279 --> 00:08:47,680
provide a mechanism for moving logic to

00:08:45,519 --> 00:08:49,519
compile time which is actually i think

00:08:47,680 --> 00:08:51,440
it's the most interesting thing about

00:08:49,519 --> 00:08:55,440
templates

00:08:51,440 --> 00:08:58,560
so uh in the

00:08:55,440 --> 00:09:02,640
simplest ways to use uh generic

00:08:58,560 --> 00:09:06,000
extra code is uh

00:09:02,640 --> 00:09:09,040
they have i mean okay sorry um

00:09:06,000 --> 00:09:12,080
you would expect that uh by having

00:09:09,040 --> 00:09:15,519
the template as a generic uh

00:09:12,080 --> 00:09:19,279
extra code uh way to perform extra code

00:09:15,519 --> 00:09:21,600
it will uh create some overhead

00:09:19,279 --> 00:09:22,399
in instantiation but in fact they

00:09:21,600 --> 00:09:25,040
actually have

00:09:22,399 --> 00:09:26,720
similar size and their uh and the

00:09:25,040 --> 00:09:29,120
compilation time is also

00:09:26,720 --> 00:09:29,760
similar to regular code so this is very

00:09:29,120 --> 00:09:32,560
useful

00:09:29,760 --> 00:09:33,519
uh if you are not sure which types

00:09:32,560 --> 00:09:36,720
you're going to have

00:09:33,519 --> 00:09:39,360
in your in your program

00:09:36,720 --> 00:09:40,399
okay adding templates to existing code

00:09:39,360 --> 00:09:43,279
so first of all

00:09:40,399 --> 00:09:44,480
uh consider this following template free

00:09:43,279 --> 00:09:47,200
code so

00:09:44,480 --> 00:09:48,000
i would just go briefly on the overload

00:09:47,200 --> 00:09:50,080
resolution

00:09:48,000 --> 00:09:52,080
so overall resolution is of course by

00:09:50,080 --> 00:09:52,320
parameter and you can see here there's

00:09:52,080 --> 00:09:55,519
an

00:09:52,320 --> 00:09:58,720
int and a float and some class sum class

00:09:55,519 --> 00:10:01,920
c and you could

00:09:58,720 --> 00:10:04,560
uh call the functions called

00:10:01,920 --> 00:10:05,680
overloads uh by by calling the the

00:10:04,560 --> 00:10:08,640
functions

00:10:05,680 --> 00:10:09,760
and you have all all the different types

00:10:08,640 --> 00:10:14,000
that you

00:10:09,760 --> 00:10:16,720
have instantiated before by declaration

00:10:14,000 --> 00:10:20,240
of course if you uh add another

00:10:16,720 --> 00:10:23,920
declaration that would be ambiguous

00:10:20,240 --> 00:10:27,360
and the the issue here is that if you

00:10:23,920 --> 00:10:28,160
don't use uh this the this version for

00:10:27,360 --> 00:10:32,000
some class

00:10:28,160 --> 00:10:32,800
in your code but you you're not sure you

00:10:32,000 --> 00:10:35,519
want to

00:10:32,800 --> 00:10:36,800
be able to add it later to the code and

00:10:35,519 --> 00:10:38,480
say this is the library

00:10:36,800 --> 00:10:41,120
then you have to instantiate the

00:10:38,480 --> 00:10:43,760
declaration of course

00:10:41,120 --> 00:10:45,360
so we could replace the overloads by a

00:10:43,760 --> 00:10:46,959
single template function

00:10:45,360 --> 00:10:48,640
and in this way we have two main

00:10:46,959 --> 00:10:50,880
advantages as i said uh

00:10:48,640 --> 00:10:52,320
we're saving coding time and code

00:10:50,880 --> 00:10:55,440
duplications

00:10:52,320 --> 00:10:57,120
and error less our prones and in binary

00:10:55,440 --> 00:10:59,519
size as i said before

00:10:57,120 --> 00:11:00,720
we don't have to uh instance exclusively

00:10:59,519 --> 00:11:03,279
associate all the

00:11:00,720 --> 00:11:04,160
uh different types the function is

00:11:03,279 --> 00:11:07,519
getting

00:11:04,160 --> 00:11:08,240
uh we could in case we're providing a

00:11:07,519 --> 00:11:10,800
generic

00:11:08,240 --> 00:11:13,440
library we could just have this

00:11:10,800 --> 00:11:16,320
instantiated by the users

00:11:13,440 --> 00:11:16,320
that users will

00:11:17,120 --> 00:11:23,519
so partial specialization

00:11:20,880 --> 00:11:25,839
is also available so first one is

00:11:23,519 --> 00:11:29,200
partial specialization of a class

00:11:25,839 --> 00:11:32,640
and in this case we can have a full

00:11:29,200 --> 00:11:34,399
full type class that calls fuller type

00:11:32,640 --> 00:11:38,320
that takes two

00:11:34,399 --> 00:11:41,440
types for two template parameters types

00:11:38,320 --> 00:11:43,279
and the second one that can

00:11:41,440 --> 00:11:45,040
actually take the same type and of

00:11:43,279 --> 00:11:48,320
course if we'll call

00:11:45,040 --> 00:11:51,040
uh this the full type with

00:11:48,320 --> 00:11:51,600
same type we'll get the call uh to to

00:11:51,040 --> 00:11:54,959
the

00:11:51,600 --> 00:11:57,360
uh specialized version that we requested

00:11:54,959 --> 00:11:58,800
by the way all the snippets of codes

00:11:57,360 --> 00:12:01,839
will be available later

00:11:58,800 --> 00:12:04,800
and i'll post them in my github as

00:12:01,839 --> 00:12:08,320
called that god belt links so you're

00:12:04,800 --> 00:12:08,320
most welcome to play with the code

00:12:08,720 --> 00:12:12,800
so in partial specialization of a

00:12:11,600 --> 00:12:16,079
function

00:12:12,800 --> 00:12:18,160
is uh is a bit different and

00:12:16,079 --> 00:12:19,839
by the way it's not always called uh not

00:12:18,160 --> 00:12:23,519
explicitly called like that

00:12:19,839 --> 00:12:25,120
but uh you could see here in the example

00:12:23,519 --> 00:12:28,560
there's a wrapper

00:12:25,120 --> 00:12:30,480
and this is a function that takes a type

00:12:28,560 --> 00:12:32,480
four that takes a type and the other

00:12:30,480 --> 00:12:35,760
function takes a rubber

00:12:32,480 --> 00:12:38,959
and when you call the the foo

00:12:35,760 --> 00:12:43,440
you get uh the appropriate call

00:12:38,959 --> 00:12:45,519
actually that should be a large case

00:12:43,440 --> 00:12:46,480
according to the to what we were

00:12:45,519 --> 00:12:49,360
expecting

00:12:46,480 --> 00:12:51,040
but i'm not getting uh into this in

00:12:49,360 --> 00:12:53,600
details here but

00:12:51,040 --> 00:12:54,720
take a uh pay attention that there might

00:12:53,600 --> 00:12:57,920
be namespaces

00:12:54,720 --> 00:13:00,959
issues here and uh you will need uh

00:12:57,920 --> 00:13:03,920
you need to consider if your uh

00:13:00,959 --> 00:13:07,200
type is uh exposed if the template is

00:13:03,920 --> 00:13:10,480
available in the scope

00:13:07,200 --> 00:13:11,279
all right overload resolution this is

00:13:10,480 --> 00:13:13,120
our next topic

00:13:11,279 --> 00:13:15,200
and this is relates to what i just said

00:13:13,120 --> 00:13:17,040
but i'm not going to

00:13:15,200 --> 00:13:18,480
elaborate on that too much but i will

00:13:17,040 --> 00:13:21,120
mention the main

00:13:18,480 --> 00:13:22,560
few guidelines that we need to remember

00:13:21,120 --> 00:13:26,079
when we are in stasi

00:13:22,560 --> 00:13:28,880
templates so first of all

00:13:26,079 --> 00:13:30,000
the compiler creates a set of candidates

00:13:28,880 --> 00:13:33,040
candidates sorry

00:13:30,000 --> 00:13:36,320
and all fun all functions that can have

00:13:33,040 --> 00:13:40,160
uh that can be uh suitable for our

00:13:36,320 --> 00:13:42,639
uh for our ins for a call

00:13:40,160 --> 00:13:43,839
and then the compiler creates a subset

00:13:42,639 --> 00:13:47,199
of viable functions

00:13:43,839 --> 00:13:50,560
uh that's actually suitable uh

00:13:47,199 --> 00:13:54,079
by name and parameters

00:13:50,560 --> 00:13:57,199
also uh uh by partial ordering of

00:13:54,079 --> 00:13:59,120
function template that means that uh the

00:13:57,199 --> 00:14:00,880
most uh specialized template is

00:13:59,120 --> 00:14:02,399
instantiated and template agreement

00:14:00,880 --> 00:14:04,160
deduction i will

00:14:02,399 --> 00:14:05,839
elaborate a bit more on those on the

00:14:04,160 --> 00:14:07,440
next slide but in general the best

00:14:05,839 --> 00:14:11,360
viable function

00:14:07,440 --> 00:14:14,000
is the one that whole parameters have

00:14:11,360 --> 00:14:15,199
uh either better equilibrium implicit

00:14:14,000 --> 00:14:18,399
versions so

00:14:15,199 --> 00:14:18,399
if we have uh

00:14:19,519 --> 00:14:22,560
if we have two of those then we'll be

00:14:21,519 --> 00:14:25,680
ambiguous

00:14:22,560 --> 00:14:26,160
and member functions gets their uh their

00:14:25,680 --> 00:14:28,880
class

00:14:26,160 --> 00:14:30,399
uh parameter as a first parameter of

00:14:28,880 --> 00:14:33,199
course

00:14:30,399 --> 00:14:34,320
so as i said uh name lookup all the

00:14:33,199 --> 00:14:36,000
functions

00:14:34,320 --> 00:14:37,839
with suitable suitable names are

00:14:36,000 --> 00:14:40,639
associated with the function code

00:14:37,839 --> 00:14:41,680
and partial ordering says that we choose

00:14:40,639 --> 00:14:44,320
the function template

00:14:41,680 --> 00:14:46,639
that is according to the specialized

00:14:44,320 --> 00:14:50,000
version as we saw before

00:14:46,639 --> 00:14:52,720
and adl actually means that uh

00:14:50,000 --> 00:14:53,360
in in addition to the namespace that the

00:14:52,720 --> 00:14:56,560
function

00:14:53,360 --> 00:14:57,360
is uh located at uh the compiler will

00:14:56,560 --> 00:15:00,079
look for

00:14:57,360 --> 00:15:00,639
suitable functions in the according to

00:15:00,079 --> 00:15:02,800
the

00:15:00,639 --> 00:15:05,199
parameters being and transport to the

00:15:02,800 --> 00:15:05,199
function

00:15:06,000 --> 00:15:12,720
so again as i said ambiguity

00:15:10,240 --> 00:15:14,800
can be created if we have more than one

00:15:12,720 --> 00:15:18,160
viable function

00:15:14,800 --> 00:15:21,279
and we will get an error

00:15:18,160 --> 00:15:21,680
if no content function is found in case

00:15:21,279 --> 00:15:25,199
we

00:15:21,680 --> 00:15:28,399
called it but if we haven't called it

00:15:25,199 --> 00:15:28,880
then notice uh sphina is something that

00:15:28,399 --> 00:15:31,680
is

00:15:28,880 --> 00:15:32,240
widely mentioned and again i'm not gonna

00:15:31,680 --> 00:15:34,399
go

00:15:32,240 --> 00:15:36,240
too deep to that direction in this talk

00:15:34,399 --> 00:15:39,519
but uh

00:15:36,240 --> 00:15:41,759
if we're not the the error would be

00:15:39,519 --> 00:15:43,440
as part of of the calling for the

00:15:41,759 --> 00:15:46,720
function and not

00:15:43,440 --> 00:15:50,230
and not part of the unfound

00:15:46,720 --> 00:15:52,480
match so

00:15:50,230 --> 00:15:55,199
[Music]

00:15:52,480 --> 00:15:58,240
let's go over conditions at compile time

00:15:55,199 --> 00:16:00,959
before simple plus 20.

00:15:58,240 --> 00:16:01,360
so first of all conditions and compile

00:16:00,959 --> 00:16:06,000
time

00:16:01,360 --> 00:16:08,399
were have a very powerful

00:16:06,000 --> 00:16:09,680
tool that they're using and that's

00:16:08,399 --> 00:16:12,720
called type trade

00:16:09,680 --> 00:16:15,600
type are a library and

00:16:12,720 --> 00:16:16,000
they're clearly verified at compile time

00:16:15,600 --> 00:16:19,759
and

00:16:16,000 --> 00:16:22,160
a typed rate it contains a member

00:16:19,759 --> 00:16:23,199
which is a boolean it can be either true

00:16:22,160 --> 00:16:26,720
or false

00:16:23,199 --> 00:16:29,120
you can access that member either by a

00:16:26,720 --> 00:16:30,480
value by addressing directly to the

00:16:29,120 --> 00:16:32,800
value

00:16:30,480 --> 00:16:34,720
since c plus plus 17 you can also access

00:16:32,800 --> 00:16:37,279
it by

00:16:34,720 --> 00:16:39,759
by uh using the type the trait name and

00:16:37,279 --> 00:16:42,880
then underscore v

00:16:39,759 --> 00:16:44,800
um some new type traits have been added

00:16:42,880 --> 00:16:47,680
to c plus 20 and we're going to

00:16:44,800 --> 00:16:48,639
go over them a bit later but in general

00:16:47,680 --> 00:16:51,040
a

00:16:48,639 --> 00:16:53,199
function type type trait uh is also

00:16:51,040 --> 00:16:56,880
something that is uh new for c

00:16:53,199 --> 00:16:58,880
20 and uh function templates would be

00:16:56,880 --> 00:17:00,240
type traits sorry would be a context

00:16:58,880 --> 00:17:02,639
pair function and

00:17:00,240 --> 00:17:05,280
uh they identify generally they identify

00:17:02,639 --> 00:17:08,319
a situation

00:17:05,280 --> 00:17:10,799
so a general overview on

00:17:08,319 --> 00:17:12,720
which type rights do we have uh just

00:17:10,799 --> 00:17:14,480
briefly again i'm not going to go

00:17:12,720 --> 00:17:16,319
too deep into that if if you're

00:17:14,480 --> 00:17:18,959
interested the talk by

00:17:16,319 --> 00:17:19,919
judy hanks in this conference is going

00:17:18,959 --> 00:17:21,199
deeper into

00:17:19,919 --> 00:17:22,959
the different type traits and

00:17:21,199 --> 00:17:26,559
implementation

00:17:22,959 --> 00:17:30,960
and demonstrate implementation

00:17:26,559 --> 00:17:34,480
but basically we have things like

00:17:30,960 --> 00:17:37,679
helper classes we have a

00:17:34,480 --> 00:17:41,360
way to identify the type of of the

00:17:37,679 --> 00:17:45,280
the type the reference versus the

00:17:41,360 --> 00:17:48,640
pointer type properties

00:17:45,280 --> 00:17:51,840
relationships and in addition

00:17:48,640 --> 00:17:55,280
you could also have uh

00:17:51,840 --> 00:17:59,039
remove references and pointers and

00:17:55,280 --> 00:18:01,679
signs of course change the signs and

00:17:59,039 --> 00:18:02,160
an additional uh very interesting thing

00:18:01,679 --> 00:18:04,400
i think

00:18:02,160 --> 00:18:06,160
is the operations on trades uh

00:18:04,400 --> 00:18:08,880
conjunction disjunction and negation

00:18:06,160 --> 00:18:11,280
they were all added in six plus 17

00:18:08,880 --> 00:18:12,799
and we will address them very briefly

00:18:11,280 --> 00:18:16,320
because they're also very

00:18:12,799 --> 00:18:20,799
relevant to six cosmetic i believe

00:18:16,320 --> 00:18:20,799
so in addition um

00:18:21,200 --> 00:18:27,120
as i said uh we have the functions

00:18:24,240 --> 00:18:29,120
uh type rate that were edited c plus 20

00:18:27,120 --> 00:18:31,919
which is is corresponding member

00:18:29,120 --> 00:18:33,600
is pointer invertible with class and is

00:18:31,919 --> 00:18:38,320
constant evaluated that

00:18:33,600 --> 00:18:41,360
i believe is the most interesting one so

00:18:38,320 --> 00:18:44,559
two main types of conditions exist

00:18:41,360 --> 00:18:45,280
so the first one would be and and this

00:18:44,559 --> 00:18:48,240
is just

00:18:45,280 --> 00:18:48,720
my sort of uh identification it's not

00:18:48,240 --> 00:18:52,000
nothing

00:18:48,720 --> 00:18:54,240
official i mean i haven't found some

00:18:52,000 --> 00:18:55,200
official declaration for that but uh in

00:18:54,240 --> 00:18:58,320
a way you could

00:18:55,200 --> 00:19:01,440
uh define your type as uh

00:18:58,320 --> 00:19:04,640
uh define boolean defines your your

00:19:01,440 --> 00:19:07,600
condition and then evaluate it and

00:19:04,640 --> 00:19:08,240
a different way would be to to create a

00:19:07,600 --> 00:19:11,520
function

00:19:08,240 --> 00:19:14,000
that can evaluate the type and

00:19:11,520 --> 00:19:14,799
do something accordingly so these are

00:19:14,000 --> 00:19:19,200
like two

00:19:14,799 --> 00:19:19,200
main um i would say uh

00:19:19,440 --> 00:19:26,400
main ways to to address the um

00:19:22,960 --> 00:19:29,760
the condition and notice that you can

00:19:26,400 --> 00:19:31,760
here i haven't even used the uh types in

00:19:29,760 --> 00:19:34,880
the in the function so basically this is

00:19:31,760 --> 00:19:39,039
like this is created in order to to

00:19:34,880 --> 00:19:42,080
identify a situation that

00:19:39,039 --> 00:19:45,039
so um

00:19:42,080 --> 00:19:46,559
there's two ways the pre simples plus 20

00:19:45,039 --> 00:19:50,320
there were two ways to

00:19:46,559 --> 00:19:53,360
to to define functions uh conditions

00:19:50,320 --> 00:19:56,480
the first one would be with enable if

00:19:53,360 --> 00:20:00,320
so you can see here a function

00:19:56,480 --> 00:20:03,120
print trivially true reality and

00:20:00,320 --> 00:20:03,520
for trivial types the overload will be

00:20:03,120 --> 00:20:06,799
the

00:20:03,520 --> 00:20:07,919
one on the top four nonchalant trivial

00:20:06,799 --> 00:20:11,679
types we'll get

00:20:07,919 --> 00:20:15,039
here now we have this uh

00:20:11,679 --> 00:20:18,159
as i said enable if uh functionality

00:20:15,039 --> 00:20:21,520
that uh by default it

00:20:18,159 --> 00:20:24,320
it returns void and the idea

00:20:21,520 --> 00:20:25,520
is that if the condition is not met this

00:20:24,320 --> 00:20:28,480
function will not be

00:20:25,520 --> 00:20:30,960
defined because this actually defines

00:20:28,480 --> 00:20:34,320
the return value of the function

00:20:30,960 --> 00:20:37,760
and here we have as i said similar

00:20:34,320 --> 00:20:40,960
overload by non-trival types

00:20:37,760 --> 00:20:44,240
so we basically covered the cases here

00:20:40,960 --> 00:20:48,240
and a different way to to define this

00:20:44,240 --> 00:20:51,520
condition is available by a firm simple

00:20:48,240 --> 00:20:54,799
17 conspirif which is

00:20:51,520 --> 00:20:58,080
uh stated here and

00:20:54,799 --> 00:20:59,919
you you could uh basically check the

00:20:58,080 --> 00:21:01,840
condition as i said typed rates are

00:20:59,919 --> 00:21:03,360
compile time so you could check the

00:21:01,840 --> 00:21:06,880
condition and then

00:21:03,360 --> 00:21:09,440
evaluate your path for the function

00:21:06,880 --> 00:21:10,720
notice here that the this print

00:21:09,440 --> 00:21:13,919
triviality function

00:21:10,720 --> 00:21:16,720
is always created unlike here

00:21:13,919 --> 00:21:17,440
but it effectively does the same thing

00:21:16,720 --> 00:21:22,799
eventually

00:21:17,440 --> 00:21:22,799
the code as well sorry this was

00:21:23,039 --> 00:21:28,240
unused all right so as i said before

00:21:26,720 --> 00:21:30,000
we're going to focus on conjunction

00:21:28,240 --> 00:21:32,799
disjunction negation and gation

00:21:30,000 --> 00:21:33,280
because they're going to be badly used

00:21:32,799 --> 00:21:36,320
uh

00:21:33,280 --> 00:21:36,880
once you move to c plus 20 at least i

00:21:36,320 --> 00:21:40,000
would

00:21:36,880 --> 00:21:43,600
expect and uh conjunction is

00:21:40,000 --> 00:21:47,280
uh clearly an or operator and sorry

00:21:43,600 --> 00:21:50,000
and operator and you could uh have

00:21:47,280 --> 00:21:51,520
the as i mentioned before you could have

00:21:50,000 --> 00:21:54,720
the form of

00:21:51,520 --> 00:21:56,880
is all same that doesn't take parameters

00:21:54,720 --> 00:21:58,080
and the form of uh is all same that does

00:21:56,880 --> 00:22:00,559
take parameters here

00:21:58,080 --> 00:22:01,280
specifically it's taking a parameter

00:22:00,559 --> 00:22:04,720
pack

00:22:01,280 --> 00:22:07,039
and again um there's two

00:22:04,720 --> 00:22:09,200
main talks in this conference and you

00:22:07,039 --> 00:22:11,440
could look it back to basic track

00:22:09,200 --> 00:22:12,880
for templates to to understand better

00:22:11,440 --> 00:22:15,919
parameter bits

00:22:12,880 --> 00:22:18,320
and again as i said

00:22:15,919 --> 00:22:19,120
this is uh this is the forms and you can

00:22:18,320 --> 00:22:22,720
use

00:22:19,120 --> 00:22:25,120
this as as a as a boolean as to evaluate

00:22:22,720 --> 00:22:28,720
the state

00:22:25,120 --> 00:22:32,320
so this junction is very similar

00:22:28,720 --> 00:22:35,600
and here you can see this function that

00:22:32,320 --> 00:22:38,320
evaluates the condition and again it can

00:22:35,600 --> 00:22:39,520
do something with it either or or just

00:22:38,320 --> 00:22:43,039
return it or

00:22:39,520 --> 00:22:46,640
and that would make it closer to concept

00:22:43,039 --> 00:22:49,200
uh in the formation and negation

00:22:46,640 --> 00:22:49,200
is again

00:22:50,080 --> 00:22:53,360
part of the stood the negation part of

00:22:52,720 --> 00:22:56,240
the

00:22:53,360 --> 00:22:58,559
traits now the reason i'm using those uh

00:22:56,240 --> 00:23:01,600
versions and i think that you should too

00:22:58,559 --> 00:23:05,200
is that uh those versions over

00:23:01,600 --> 00:23:08,159
uh and or and negation that are

00:23:05,200 --> 00:23:09,679
marked in science this forms will

00:23:08,159 --> 00:23:12,720
optimize

00:23:09,679 --> 00:23:14,320
and in case when they open the parameter

00:23:12,720 --> 00:23:17,039
pack and will not

00:23:14,320 --> 00:23:18,480
uh instantiate if the condition is met

00:23:17,039 --> 00:23:22,960
so this is actually

00:23:18,480 --> 00:23:26,720
sort of a lazy evaluation more effective

00:23:22,960 --> 00:23:28,799
so uh okay so this was the

00:23:26,720 --> 00:23:30,400
sort of the boilerplate of the talk and

00:23:28,799 --> 00:23:33,280
now we're reaching to

00:23:30,400 --> 00:23:35,280
uh conditions at compile time uh using

00:23:33,280 --> 00:23:38,400
simple plus 20.

00:23:35,280 --> 00:23:41,039
so as i mentioned c plus

00:23:38,400 --> 00:23:42,400
20 created a paradigm shift and concepts

00:23:41,039 --> 00:23:45,039
and constraints

00:23:42,400 --> 00:23:46,559
are i think a very powerful tool and i

00:23:45,039 --> 00:23:49,039
think they're also

00:23:46,559 --> 00:23:51,440
changing the way we look at the language

00:23:49,039 --> 00:23:55,039
so again as i mentioned i

00:23:51,440 --> 00:23:58,240
i come from i mean i'm very fond of math

00:23:55,039 --> 00:24:02,080
and i think that in a way they

00:23:58,240 --> 00:24:04,159
give us a broader definition in which we

00:24:02,080 --> 00:24:07,440
can use for type category versus

00:24:04,159 --> 00:24:09,279
type as we did before and it is true

00:24:07,440 --> 00:24:12,480
that most things that you've

00:24:09,279 --> 00:24:16,480
uh you're doing with simplest 20 were

00:24:12,480 --> 00:24:20,000
acceptable accessible before

00:24:16,480 --> 00:24:23,679
concepts or at least i would think most

00:24:20,000 --> 00:24:27,840
usable uh most um

00:24:23,679 --> 00:24:30,960
common use cases but but still uh

00:24:27,840 --> 00:24:32,159
it's a much powerful tool and i i think

00:24:30,960 --> 00:24:35,360
it's worth uh

00:24:32,159 --> 00:24:39,440
exploring so uh as i said before

00:24:35,360 --> 00:24:39,919
uh basically before c plus 20 i would i

00:24:39,440 --> 00:24:43,279
would

00:24:39,919 --> 00:24:46,480
think of that as having a condition and

00:24:43,279 --> 00:24:47,039
defining the type and you can look at

00:24:46,480 --> 00:24:50,080
the type

00:24:47,039 --> 00:24:52,799
and understand if if the type is uh

00:24:50,080 --> 00:24:54,240
evaluated if the condition is evaluated

00:24:52,799 --> 00:24:56,640
to true

00:24:54,240 --> 00:24:58,720
and i think in a way concepts allow you

00:24:56,640 --> 00:25:03,760
to define something that is broader

00:24:58,720 --> 00:25:06,080
and as if as a type category

00:25:03,760 --> 00:25:06,799
so in the following slides we will

00:25:06,080 --> 00:25:10,159
review

00:25:06,799 --> 00:25:13,200
uh as i mentioned earlier simple plus 20

00:25:10,159 --> 00:25:16,320
new type trades some new syntax for

00:25:13,200 --> 00:25:16,799
controlling the overload sets and new

00:25:16,320 --> 00:25:20,320
tools

00:25:16,799 --> 00:25:21,039
to use uh when you're using simple plus

00:25:20,320 --> 00:25:23,919
00:25:21,039 --> 00:25:26,559
and a bit beyond some of the tools are

00:25:23,919 --> 00:25:29,200
actually not part of the language yet

00:25:26,559 --> 00:25:29,919
so as i mentioned before uh typed rates

00:25:29,200 --> 00:25:33,760
were added

00:25:29,919 --> 00:25:36,640
for uh in c plus 20 and i think they're

00:25:33,760 --> 00:25:37,520
they're very interesting um there are

00:25:36,640 --> 00:25:40,159
very interesting

00:25:37,520 --> 00:25:40,880
uh typeders here and i've mentioned

00:25:40,159 --> 00:25:43,760
before

00:25:40,880 --> 00:25:45,600
the functions the sum that defines

00:25:43,760 --> 00:25:48,159
member relationships

00:25:45,600 --> 00:25:49,760
is pointer invokable with class and is

00:25:48,159 --> 00:25:52,240
corresponding member

00:25:49,760 --> 00:25:52,799
and is constantly evaluated of course

00:25:52,240 --> 00:25:54,799
and

00:25:52,799 --> 00:25:56,159
if you look at those type rates that i

00:25:54,799 --> 00:25:58,400
would i wouldn't go too deep

00:25:56,159 --> 00:26:00,159
into each of them but if you look at

00:25:58,400 --> 00:26:02,320
them you can see

00:26:00,159 --> 00:26:03,440
that they're they have something in

00:26:02,320 --> 00:26:05,440
common and

00:26:03,440 --> 00:26:08,840
the thing in common is that they provide

00:26:05,440 --> 00:26:12,159
better uh reflection abilities

00:26:08,840 --> 00:26:15,679
so basically i think that they

00:26:12,159 --> 00:26:16,320
expand broadly our ability to use the

00:26:15,679 --> 00:26:19,600
language

00:26:16,320 --> 00:26:23,120
and i think uh along with concepts

00:26:19,600 --> 00:26:24,240
and constraints the the new type traits

00:26:23,120 --> 00:26:28,080
are also very

00:26:24,240 --> 00:26:31,120
valuable tools so

00:26:28,080 --> 00:26:33,679
um okay concepts

00:26:31,120 --> 00:26:34,720
so concepts are a way to define

00:26:33,679 --> 00:26:37,600
restrictions

00:26:34,720 --> 00:26:40,080
as i said i would refer to them as

00:26:37,600 --> 00:26:43,440
defining type category

00:26:40,080 --> 00:26:46,400
the expressions in the concept are only

00:26:43,440 --> 00:26:47,679
validated they're not evaluated so a

00:26:46,400 --> 00:26:50,880
condition can be

00:26:47,679 --> 00:26:53,200
either a simple condition true or false

00:26:50,880 --> 00:26:54,720
it could be a requires expression which

00:26:53,200 --> 00:26:57,840
will turn true

00:26:54,720 --> 00:26:59,600
if valid or false otherwise and

00:26:57,840 --> 00:27:02,080
it could be requires expression that

00:26:59,600 --> 00:27:05,279
describe requirement under return value

00:27:02,080 --> 00:27:06,320
as well so you can define with this

00:27:05,279 --> 00:27:09,279
syntax

00:27:06,320 --> 00:27:10,400
some condition under return value here

00:27:09,279 --> 00:27:12,720
you can just uh

00:27:10,400 --> 00:27:13,840
here you're just defining conditions on

00:27:12,720 --> 00:27:16,080
the accepted

00:27:13,840 --> 00:27:16,080
type

00:27:17,279 --> 00:27:21,279
again again as i said there are concepts

00:27:20,000 --> 00:27:23,360
are used to identify

00:27:21,279 --> 00:27:24,720
if a type belongs to a certain type

00:27:23,360 --> 00:27:28,399
category

00:27:24,720 --> 00:27:31,919
so i would say that uh cons

00:27:28,399 --> 00:27:35,120
concepts in a way i think they're

00:27:31,919 --> 00:27:35,679
easier to read you you can judge by

00:27:35,120 --> 00:27:38,159
yourself

00:27:35,679 --> 00:27:38,960
for yourself but i think that concepts

00:27:38,159 --> 00:27:42,399
are

00:27:38,960 --> 00:27:43,760
easier more expressive way to define

00:27:42,399 --> 00:27:47,360
what we want

00:27:43,760 --> 00:27:51,520
in our program so um

00:27:47,360 --> 00:27:54,960
here i defined this trivial concept type

00:27:51,520 --> 00:27:57,760
and just a few short limitations concept

00:27:54,960 --> 00:28:00,159
cannot contain cannot be constrained

00:27:57,760 --> 00:28:01,840
that means that you can't accept

00:28:00,159 --> 00:28:03,600
you can constrain a concept with a

00:28:01,840 --> 00:28:05,919
different concept and they cannot

00:28:03,600 --> 00:28:09,440
recursively refer to themselves

00:28:05,919 --> 00:28:12,080
and these are things that needs to be um

00:28:09,440 --> 00:28:12,559
considered when you define concepts and

00:28:12,080 --> 00:28:14,880
we

00:28:12,559 --> 00:28:16,000
broadly when you heavily use concepts in

00:28:14,880 --> 00:28:19,120
your code base

00:28:16,000 --> 00:28:22,799
which i would uh hope you will

00:28:19,120 --> 00:28:24,960
uh just uh uh another short boilerplate

00:28:22,799 --> 00:28:28,559
a popular way to declare a concept

00:28:24,960 --> 00:28:31,840
could be i mean again in this talk i'm

00:28:28,559 --> 00:28:34,480
mentioning the the return types etc and

00:28:31,840 --> 00:28:35,200
of course and avoiding things like uh

00:28:34,480 --> 00:28:38,000
reference

00:28:35,200 --> 00:28:39,679
uh semantics and so on but i'm defining

00:28:38,000 --> 00:28:42,720
the return types and

00:28:39,679 --> 00:28:44,159
uh you could basically uh avoid that by

00:28:42,720 --> 00:28:47,360
using conspiracy auto

00:28:44,159 --> 00:28:48,080
and of course it's less um i think it's

00:28:47,360 --> 00:28:51,360
less

00:28:48,080 --> 00:28:54,720
understood in a presentation

00:28:51,360 --> 00:28:56,399
so uh concept okay so

00:28:54,720 --> 00:28:58,159
again these are the concepts that were

00:28:56,399 --> 00:29:01,840
added and all of course

00:28:58,159 --> 00:29:04,399
added in c plus plus 20. and

00:29:01,840 --> 00:29:05,279
i'm not gonna go over each of them but

00:29:04,399 --> 00:29:07,600
you can

00:29:05,279 --> 00:29:08,880
i think you can recognize that they are

00:29:07,600 --> 00:29:11,360
uh very

00:29:08,880 --> 00:29:12,240
strongly coupled with the with the

00:29:11,360 --> 00:29:15,520
titrates

00:29:12,240 --> 00:29:18,559
and and it's in a way

00:29:15,520 --> 00:29:20,080
they're they're basically a clearer way

00:29:18,559 --> 00:29:23,120
to define this

00:29:20,080 --> 00:29:25,440
very similar conditions as in the typed

00:29:23,120 --> 00:29:28,000
rates

00:29:25,440 --> 00:29:29,200
and you you can see here that there are

00:29:28,000 --> 00:29:32,000
um

00:29:29,200 --> 00:29:32,559
comprehension concepts object concepts

00:29:32,000 --> 00:29:34,720
some

00:29:32,559 --> 00:29:35,760
concepts are uh part of the core

00:29:34,720 --> 00:29:38,840
language

00:29:35,760 --> 00:29:43,440
and uh callable concepts can

00:29:38,840 --> 00:29:43,440
evaluate um the

00:29:44,000 --> 00:29:47,840
i would say the um

00:29:48,799 --> 00:29:56,240
evaluate the callability of the type

00:29:52,840 --> 00:29:59,440
so um

00:29:56,240 --> 00:30:02,159
constraints are uh what you

00:29:59,440 --> 00:30:04,159
you're doing when you're using a concept

00:30:02,159 --> 00:30:05,440
in order to restrict your overload

00:30:04,159 --> 00:30:09,520
resolution

00:30:05,440 --> 00:30:11,440
so uh in this example we have the

00:30:09,520 --> 00:30:12,559
uh requires concept that we defined

00:30:11,440 --> 00:30:15,919
before

00:30:12,559 --> 00:30:18,480
and sorry the integral concept that we

00:30:15,919 --> 00:30:19,200
defined before and we required this

00:30:18,480 --> 00:30:23,120
integral

00:30:19,200 --> 00:30:27,039
uh uh to be uh to to restrict the

00:30:23,120 --> 00:30:29,840
full function and concerns can also be

00:30:27,039 --> 00:30:32,399
defined in the form of uh

00:30:29,840 --> 00:30:34,640
that to me at least resembles enable

00:30:32,399 --> 00:30:36,960
leaf so this is very similar to what we

00:30:34,640 --> 00:30:41,120
saw before before we saw

00:30:36,960 --> 00:30:42,880
a enable if here that defines whether

00:30:41,120 --> 00:30:45,679
the function

00:30:42,880 --> 00:30:46,720
is going to exist or not and i would

00:30:45,679 --> 00:30:50,159
think that this is

00:30:46,720 --> 00:30:52,799
very similar syntax and

00:30:50,159 --> 00:30:55,679
eventually i just want to mention that

00:30:52,799 --> 00:30:59,760
as i said before

00:30:55,679 --> 00:31:02,320
the svena issue that will be here

00:30:59,760 --> 00:31:04,480
would suggest that i mean if i wouldn't

00:31:02,320 --> 00:31:08,559
have called this function

00:31:04,480 --> 00:31:12,080
um explicitly i would

00:31:08,559 --> 00:31:13,679
i mean i the error comes from the fact

00:31:12,080 --> 00:31:17,360
that i'm trying to use the function

00:31:13,679 --> 00:31:18,159
and not by uh just the fact that i

00:31:17,360 --> 00:31:21,360
couldn't find

00:31:18,159 --> 00:31:21,360
the overlord resolution

00:31:22,240 --> 00:31:29,440
okay so concerns as i mentioned before

00:31:26,399 --> 00:31:30,640
uh are expressed uh expressing

00:31:29,440 --> 00:31:33,519
additional

00:31:30,640 --> 00:31:35,679
data on the type some restriction and

00:31:33,519 --> 00:31:40,159
contrast can be used to restrict

00:31:35,679 --> 00:31:43,440
uh either time place parameters or

00:31:40,159 --> 00:31:46,880
variables um

00:31:43,440 --> 00:31:47,679
their normal normalizing process of

00:31:46,880 --> 00:31:50,480
constraints

00:31:47,679 --> 00:31:51,600
is as follows basically unpacking the

00:31:50,480 --> 00:31:54,240
constraint

00:31:51,600 --> 00:31:54,960
and having a conjunction between between

00:31:54,240 --> 00:31:57,919
the different

00:31:54,960 --> 00:31:59,440
uh constraints and they can be added to

00:31:57,919 --> 00:32:02,080
the code

00:31:59,440 --> 00:32:02,799
in the four in the following four ways

00:32:02,080 --> 00:32:05,919
and

00:32:02,799 --> 00:32:07,840
in in by the order so it could be

00:32:05,919 --> 00:32:10,080
uh in the declaration of the template

00:32:07,840 --> 00:32:12,880
parameter using requires clause

00:32:10,080 --> 00:32:14,080
after the template parameter list um

00:32:12,880 --> 00:32:16,960
using uh

00:32:14,080 --> 00:32:17,679
as a placeholder type to arbitrary

00:32:16,960 --> 00:32:20,000
function

00:32:17,679 --> 00:32:20,799
templates declaration as we mentioned

00:32:20,000 --> 00:32:22,640
before

00:32:20,799 --> 00:32:24,480
and trailing requires clause as we

00:32:22,640 --> 00:32:28,159
mentioned so

00:32:24,480 --> 00:32:29,919
i'll just introduce those four ways um

00:32:28,159 --> 00:32:32,159
again as i said in the following order

00:32:29,919 --> 00:32:33,519
and this is interesting because i refer

00:32:32,159 --> 00:32:35,279
to that later

00:32:33,519 --> 00:32:36,960
so in the declaration of a template

00:32:35,279 --> 00:32:40,159
parameter you can see here the

00:32:36,960 --> 00:32:44,080
integral concept uh

00:32:40,159 --> 00:32:46,559
using required clause uh uh after the

00:32:44,080 --> 00:32:49,039
template parameter list so this is the

00:32:46,559 --> 00:32:51,840
enable if form

00:32:49,039 --> 00:32:52,480
using concept as a placeholder type uh

00:32:51,840 --> 00:32:56,080
this is

00:32:52,480 --> 00:32:59,679
uh actually relevant when you use the

00:32:56,080 --> 00:33:02,320
advanced form as i mentioned before

00:32:59,679 --> 00:33:03,840
for defining uh template function and

00:33:02,320 --> 00:33:07,039
this is the way to do it for

00:33:03,840 --> 00:33:09,120
parameter pack and

00:33:07,039 --> 00:33:10,799
using qr codes after the template

00:33:09,120 --> 00:33:13,919
parameter list

00:33:10,799 --> 00:33:14,559
so this is again this is the uh this is

00:33:13,919 --> 00:33:16,399
the order

00:33:14,559 --> 00:33:18,080
which the conditions are evaluated and

00:33:16,399 --> 00:33:21,360
this is i think this is important

00:33:18,080 --> 00:33:24,480
um for and we'll see later

00:33:21,360 --> 00:33:27,360
why so

00:33:24,480 --> 00:33:28,399
let's go to real world use case a

00:33:27,360 --> 00:33:31,519
wrapper type

00:33:28,399 --> 00:33:35,200
so the type category again uh

00:33:31,519 --> 00:33:36,240
can be used uh to my opinion in a

00:33:35,200 --> 00:33:39,760
broader way than

00:33:36,240 --> 00:33:42,720
the classic template meta programming

00:33:39,760 --> 00:33:43,760
style so we start with defining a

00:33:42,720 --> 00:33:46,399
concept

00:33:43,760 --> 00:33:47,519
that's called contain data contains data

00:33:46,399 --> 00:33:51,200
sorry

00:33:47,519 --> 00:33:54,240
and this concept contains data

00:33:51,200 --> 00:33:57,360
requires that the type that we get here

00:33:54,240 --> 00:33:58,000
will have here sorry we passed here

00:33:57,360 --> 00:34:01,120
we'll have

00:33:58,000 --> 00:34:05,200
a data member so

00:34:01,120 --> 00:34:07,360
that's type that satisfies the concept

00:34:05,200 --> 00:34:10,639
that i described above

00:34:07,360 --> 00:34:14,560
would be something as follows

00:34:10,639 --> 00:34:18,720
and you can see here the data type

00:34:14,560 --> 00:34:21,919
now we can define this wrapper

00:34:18,720 --> 00:34:24,800
class that can only accept types that

00:34:21,919 --> 00:34:25,200
have the data member and here you can

00:34:24,800 --> 00:34:28,399
see

00:34:25,200 --> 00:34:32,159
we're using our our

00:34:28,399 --> 00:34:32,159
concept defined before

00:34:32,839 --> 00:34:39,760
and this is uh

00:34:36,399 --> 00:34:42,800
again this it's not necessarily uh to

00:34:39,760 --> 00:34:45,119
to use the the the whatever

00:34:42,800 --> 00:34:46,000
constraint that you've added to the to

00:34:45,119 --> 00:34:47,760
the function

00:34:46,000 --> 00:34:50,000
but in this specific example we're

00:34:47,760 --> 00:34:54,079
actually using the the data that we

00:34:50,000 --> 00:34:57,280
defined uh is required here

00:34:54,079 --> 00:35:01,280
and um

00:34:57,280 --> 00:35:04,720
and and as i mentioned before we can

00:35:01,280 --> 00:35:07,680
either uh succeed when we

00:35:04,720 --> 00:35:09,200
instantiate when we actually try to call

00:35:07,680 --> 00:35:12,400
the function type

00:35:09,200 --> 00:35:15,119
or we can fail and in this case

00:35:12,400 --> 00:35:17,839
we'll get an error because the function

00:35:15,119 --> 00:35:17,839
was not found

00:35:20,560 --> 00:35:26,160
um sorry again

00:35:23,839 --> 00:35:27,359
uh again i i haven't mentioned that

00:35:26,160 --> 00:35:29,280
before but i'll

00:35:27,359 --> 00:35:30,960
probably take questions in the end

00:35:29,280 --> 00:35:34,320
because uh because

00:35:30,960 --> 00:35:37,599
we have a lot to cover so uh

00:35:34,320 --> 00:35:38,400
the example i've showed you is is very

00:35:37,599 --> 00:35:42,480
interesting

00:35:38,400 --> 00:35:46,960
i think because um it can it can

00:35:42,480 --> 00:35:49,440
suggest some um potential problems

00:35:46,960 --> 00:35:50,400
so you can see here the class wrapper

00:35:49,440 --> 00:35:53,760
and you can see

00:35:50,400 --> 00:35:55,920
that it takes some kind of type

00:35:53,760 --> 00:35:57,200
now it might have been the case that the

00:35:55,920 --> 00:36:00,960
type that it accepts

00:35:57,200 --> 00:36:02,960
is also uh is also

00:36:00,960 --> 00:36:04,160
somehow affecting the evaluation of the

00:36:02,960 --> 00:36:07,680
function

00:36:04,160 --> 00:36:10,480
so i wanna i wanna um

00:36:07,680 --> 00:36:12,240
show you here uh a solution that is not

00:36:10,480 --> 00:36:15,920
part of the language yet

00:36:12,240 --> 00:36:19,359
and this is a proposal by isabel morta

00:36:15,920 --> 00:36:23,200
and uh it's offering

00:36:19,359 --> 00:36:26,240
basically to add those con those types

00:36:23,200 --> 00:36:29,359
sorry those concepts to the language

00:36:26,240 --> 00:36:32,480
and the way to use those is

00:36:29,359 --> 00:36:35,520
to break uh the recursiveness of

00:36:32,480 --> 00:36:37,200
of calling of trying to evaluate a

00:36:35,520 --> 00:36:40,240
concept on a type that's

00:36:37,200 --> 00:36:43,839
uh that is expect accepted from

00:36:40,240 --> 00:36:44,880
uh outside on a class that's uh again

00:36:43,839 --> 00:36:48,000
being evaluated

00:36:44,880 --> 00:36:49,920
with the concept so

00:36:48,000 --> 00:36:51,839
this is something i actually stumbled

00:36:49,920 --> 00:36:55,119
across while um

00:36:51,839 --> 00:36:58,880
while working on uh you know

00:36:55,119 --> 00:37:02,079
in a war group related to executors

00:36:58,880 --> 00:37:04,800
but i'm sure there's a lot of examples

00:37:02,079 --> 00:37:06,079
online but this is probably not

00:37:04,800 --> 00:37:09,599
something that

00:37:06,079 --> 00:37:12,640
you will stumble across every day

00:37:09,599 --> 00:37:14,000
but in case you're uh you are defining a

00:37:12,640 --> 00:37:16,640
complex library

00:37:14,000 --> 00:37:18,320
you might want to keep in mind these in

00:37:16,640 --> 00:37:21,440
order to

00:37:18,320 --> 00:37:23,040
identify that you're accepting a type

00:37:21,440 --> 00:37:26,640
that already

00:37:23,040 --> 00:37:28,400
been evaluated with with the concept

00:37:26,640 --> 00:37:31,599
that you're evaluating

00:37:28,400 --> 00:37:33,520
inside the function so this is very

00:37:31,599 --> 00:37:35,040
important in case you get a compiler

00:37:33,520 --> 00:37:38,960
error

00:37:35,040 --> 00:37:40,320
and uh okay so this is the last part of

00:37:38,960 --> 00:37:42,480
my talk

00:37:40,320 --> 00:37:44,720
and now we're gonna see advanced method

00:37:42,480 --> 00:37:48,800
for compile time logic so

00:37:44,720 --> 00:37:52,320
uh as i said uh simplest 20 gives us

00:37:48,800 --> 00:37:54,880
a lot of different tools um

00:37:52,320 --> 00:37:57,040
and i'm gonna i want to start with

00:37:54,880 --> 00:38:00,560
things relates to lazy evaluation

00:37:57,040 --> 00:38:04,240
so and

00:38:00,560 --> 00:38:09,520
be trying when when you write a template

00:38:04,240 --> 00:38:12,720
code meta programming code you you could

00:38:09,520 --> 00:38:15,839
you could just address that as moving

00:38:12,720 --> 00:38:16,960
a code to compile time which is of

00:38:15,839 --> 00:38:20,079
course something that

00:38:16,960 --> 00:38:22,960
is done that you're doing by

00:38:20,079 --> 00:38:23,839
moving to templates but you could also

00:38:22,960 --> 00:38:27,920
address it

00:38:23,839 --> 00:38:30,560
as as moving your logic

00:38:27,920 --> 00:38:32,400
to compile time that means you could

00:38:30,560 --> 00:38:36,400
perform more tasks

00:38:32,400 --> 00:38:39,760
in compile time considering conditions

00:38:36,400 --> 00:38:39,760
so as i said

00:38:40,000 --> 00:38:43,359
lazy evaluation is an interesting thing

00:38:42,160 --> 00:38:46,240
that you can do

00:38:43,359 --> 00:38:47,200
for the most more advanced template meta

00:38:46,240 --> 00:38:50,800
programming

00:38:47,200 --> 00:38:53,839
uh scenarios so the benefits of

00:38:50,800 --> 00:38:54,480
lazy evaluations would be uh to avoid

00:38:53,839 --> 00:38:57,440
creating

00:38:54,480 --> 00:38:58,960
uh temporaries that are unnecessarily

00:38:57,440 --> 00:39:02,240
and costly

00:38:58,960 --> 00:39:05,119
and we could also improve

00:39:02,240 --> 00:39:06,400
our compile time of the program i'll

00:39:05,119 --> 00:39:09,520
show you later

00:39:06,400 --> 00:39:11,920
uh in a way but uh with with a bit of a

00:39:09,520 --> 00:39:14,400
different method

00:39:11,920 --> 00:39:15,839
so expression templates are an old

00:39:14,400 --> 00:39:20,160
method to do that

00:39:15,839 --> 00:39:22,880
and um it exists for quite a while

00:39:20,160 --> 00:39:23,520
and i'm going to go over this and show

00:39:22,880 --> 00:39:27,680
you

00:39:23,520 --> 00:39:29,680
that we could actually implement that

00:39:27,680 --> 00:39:33,119
and

00:39:29,680 --> 00:39:34,320
and and and and try to address that as a

00:39:33,119 --> 00:39:38,560
more general

00:39:34,320 --> 00:39:40,800
uh try to avoid addressing the specific

00:39:38,560 --> 00:39:44,079
example that is very popular one

00:39:40,800 --> 00:39:48,560
and and and see uh the general

00:39:44,079 --> 00:39:51,920
uh design uh guidelines that are here

00:39:48,560 --> 00:39:55,440
for creating a proxy object to hold

00:39:51,920 --> 00:39:58,240
uh to hold your logic

00:39:55,440 --> 00:39:59,440
in order to avoid the insensation of of

00:39:58,240 --> 00:40:03,200
temps

00:39:59,440 --> 00:40:07,119
so um okay so

00:40:03,200 --> 00:40:09,680
let's start so here we have a

00:40:07,119 --> 00:40:10,400
wrapper for a vector which is again the

00:40:09,680 --> 00:40:13,520
most common

00:40:10,400 --> 00:40:15,280
uh example for expression templates

00:40:13,520 --> 00:40:18,720
since creating a vector is

00:40:15,280 --> 00:40:22,240
is uh costly and we can have

00:40:18,720 --> 00:40:25,920
a constructor take size

00:40:22,240 --> 00:40:28,960
and again a constructor that's um

00:40:25,920 --> 00:40:31,520
a copy constructor that takes another

00:40:28,960 --> 00:40:32,480
preparer and we have the implementation

00:40:31,520 --> 00:40:37,359
of the

00:40:32,480 --> 00:40:39,599
equal operator and the plus and

00:40:37,359 --> 00:40:41,359
and i haven't added this in this slide

00:40:39,599 --> 00:40:44,079
but of course we have the

00:40:41,359 --> 00:40:44,720
two implementations for operator and

00:40:44,079 --> 00:40:47,760
reference

00:40:44,720 --> 00:40:51,119
and uh sorry um

00:40:47,760 --> 00:40:53,680
clause and um

00:40:51,119 --> 00:40:56,400
and and here you you can actually see

00:40:53,680 --> 00:40:59,680
the usage of this wrapper function

00:40:56,400 --> 00:41:03,839
so we could uh

00:40:59,680 --> 00:41:07,680
eliminate this uh plus operator from our

00:41:03,839 --> 00:41:10,560
original class and add a free function

00:41:07,680 --> 00:41:12,000
that overwrites uh doesn't overwork

00:41:10,560 --> 00:41:15,359
because we eliminated but

00:41:12,000 --> 00:41:18,800
it implements the operator plus

00:41:15,359 --> 00:41:21,119
and here if you can as you can see

00:41:18,800 --> 00:41:22,480
we're not expecting we're not accepting

00:41:21,119 --> 00:41:25,200
uh our

00:41:22,480 --> 00:41:26,160
uh we're not producing our vac uh

00:41:25,200 --> 00:41:27,839
wrapper

00:41:26,160 --> 00:41:29,440
instead we're producing a new type

00:41:27,839 --> 00:41:32,400
that's called sum

00:41:29,440 --> 00:41:33,040
and this new type this new uh struct as

00:41:32,400 --> 00:41:35,440
you're gonna

00:41:33,040 --> 00:41:37,280
see in the following slide is gonna hold

00:41:35,440 --> 00:41:40,560
our uh

00:41:37,280 --> 00:41:45,760
our uh vectors that we

00:41:40,560 --> 00:41:45,760
were trying to uh perform operator plus

00:41:46,839 --> 00:41:51,920
on

00:41:48,560 --> 00:41:55,119
so here is our sum class

00:41:51,920 --> 00:41:58,079
so you can see here the class it gets a

00:41:55,119 --> 00:41:58,720
type of this is the type that is part of

00:41:58,079 --> 00:42:00,800
the

00:41:58,720 --> 00:42:02,000
this is the type that the vector holds

00:42:00,800 --> 00:42:04,400
it's not necessarily to

00:42:02,000 --> 00:42:05,280
get it that's why it's uh great but you

00:42:04,400 --> 00:42:07,359
might want to do

00:42:05,280 --> 00:42:09,280
something with it so it's an optional

00:42:07,359 --> 00:42:11,280
and here you see

00:42:09,280 --> 00:42:13,040
two different types that represents the

00:42:11,280 --> 00:42:16,560
two vectors that you receive

00:42:13,040 --> 00:42:20,240
in order to evaluate and

00:42:16,560 --> 00:42:23,440
this class constructor is basically

00:42:20,240 --> 00:42:27,119
uh saving the types that you got for

00:42:23,440 --> 00:42:30,480
the vectors in a reference to them

00:42:27,119 --> 00:42:33,119
inside the destruct

00:42:30,480 --> 00:42:33,839
so this is very simply simple as you can

00:42:33,119 --> 00:42:37,440
see this is

00:42:33,839 --> 00:42:39,440
uh this is a very simple form to do

00:42:37,440 --> 00:42:41,760
i think it's very readable to do

00:42:39,440 --> 00:42:45,920
something that is very complex

00:42:41,760 --> 00:42:48,640
so uh here you can see uh

00:42:45,920 --> 00:42:49,200
the implementation of the operator

00:42:48,640 --> 00:42:52,560
clause

00:42:49,200 --> 00:42:55,920
and and this

00:42:52,560 --> 00:42:58,480
this implementation is what creates our

00:42:55,920 --> 00:42:59,839
lazy evaluation so as you can see here

00:42:58,480 --> 00:43:05,040
we're returning

00:42:59,839 --> 00:43:05,040
the sum of the of the objects

00:43:06,480 --> 00:43:14,000
so as i mentioned before

00:43:10,880 --> 00:43:17,040
expression templates are very common and

00:43:14,000 --> 00:43:20,079
uh again you can watch a talk by klaus

00:43:17,040 --> 00:43:23,359
engenberg from cppnow for uh

00:43:20,079 --> 00:43:26,960
14. he was talking about blaise library

00:43:23,359 --> 00:43:30,160
and he implemented and he gave me giving

00:43:26,960 --> 00:43:33,150
very good examples there so i really

00:43:30,160 --> 00:43:34,720
welcome you all to go and watch that um

00:43:33,150 --> 00:43:37,200
[Music]

00:43:34,720 --> 00:43:38,160
but again we've created sort of a lazy

00:43:37,200 --> 00:43:41,440
evaluation

00:43:38,160 --> 00:43:44,960
and this is what we're aiming for

00:43:41,440 --> 00:43:48,400
and here you can see that uh

00:43:44,960 --> 00:43:52,160
the temp is not being created um

00:43:48,400 --> 00:43:54,960
between every every time we're

00:43:52,160 --> 00:43:55,599
calling the operator plus we're saving

00:43:54,960 --> 00:43:59,040
the

00:43:55,599 --> 00:44:02,079
uh different vectors in our sum

00:43:59,040 --> 00:44:05,839
um class

00:44:02,079 --> 00:44:09,040
and then we basically only evaluate

00:44:05,839 --> 00:44:12,720
this final in the final uh

00:44:09,040 --> 00:44:16,079
um um the following evaluation

00:44:12,720 --> 00:44:17,200
and injection um that actually

00:44:16,079 --> 00:44:22,480
instantiates the

00:44:17,200 --> 00:44:26,560
the zed so it's not um this one

00:44:22,480 --> 00:44:26,560
actually all right

00:44:27,280 --> 00:44:34,800
so um ranges

00:44:30,880 --> 00:44:38,000
are uh optional way

00:44:34,800 --> 00:44:40,079
there's there could have been a way to

00:44:38,000 --> 00:44:43,359
solve this lazy evaluation

00:44:40,079 --> 00:44:45,440
uh thing and implement something that is

00:44:43,359 --> 00:44:48,000
very similar to what we just saw

00:44:45,440 --> 00:44:48,880
in a much simpler way but they're not

00:44:48,000 --> 00:44:51,839
just yet

00:44:48,880 --> 00:44:52,800
because uh ranges are were clearly they

00:44:51,839 --> 00:44:56,000
were added to c

00:44:52,800 --> 00:44:59,119
plus 20. uh but left out was the

00:44:56,000 --> 00:45:02,319
zip and zip with uh view

00:44:59,119 --> 00:45:05,680
ranges options

00:45:02,319 --> 00:45:06,480
and you can experiment ranges are

00:45:05,680 --> 00:45:09,680
basically

00:45:06,480 --> 00:45:12,720
imported from eric nable's

00:45:09,680 --> 00:45:15,040
nibbler sorry um ranger's

00:45:12,720 --> 00:45:17,119
version 3 library that is part of boost

00:45:15,040 --> 00:45:20,319
and you can experiment with them

00:45:17,119 --> 00:45:23,200
but basically uh this uh

00:45:20,319 --> 00:45:24,400
this is how it could have looked like in

00:45:23,200 --> 00:45:28,480
case we would have got

00:45:24,400 --> 00:45:31,359
a zip and zip with in the standard so um

00:45:28,480 --> 00:45:32,400
this is the plus operator and you can

00:45:31,359 --> 00:45:34,800
see

00:45:32,400 --> 00:45:36,960
the classic definition that you would

00:45:34,800 --> 00:45:39,440
have expect

00:45:36,960 --> 00:45:40,319
it implements the operator parentheses

00:45:39,440 --> 00:45:44,079
premises

00:45:40,319 --> 00:45:45,200
and it returns the plus of the two types

00:45:44,079 --> 00:45:49,040
they've got

00:45:45,200 --> 00:45:52,400
and here we can see uh the

00:45:49,040 --> 00:45:55,599
the usage of the zip with

00:45:52,400 --> 00:45:57,599
uh view operator and by the way

00:45:55,599 --> 00:45:58,880
uh in the standard would have been

00:45:57,599 --> 00:46:01,359
suggested as

00:45:58,880 --> 00:46:02,720
zip with view uh here it's under the

00:46:01,359 --> 00:46:06,240
namespace view

00:46:02,720 --> 00:46:09,040
and the fact that this is in red is to

00:46:06,240 --> 00:46:10,640
um emphasize that this is not a part of

00:46:09,040 --> 00:46:12,720
the standard but this is

00:46:10,640 --> 00:46:14,319
uh because in the start it calls uh

00:46:12,720 --> 00:46:17,920
they're called views

00:46:14,319 --> 00:46:20,560
so uh again you can experiment with that

00:46:17,920 --> 00:46:22,400
in the snippets that i'll post later and

00:46:20,560 --> 00:46:24,800
my github

00:46:22,400 --> 00:46:27,280
if you if you're interested and i think

00:46:24,800 --> 00:46:28,640
this is very elegant and very simple way

00:46:27,280 --> 00:46:31,440
to

00:46:28,640 --> 00:46:33,599
create lazy evaluation um i would hope

00:46:31,440 --> 00:46:37,200
that in the future we'll also get those

00:46:33,599 --> 00:46:40,079
um so the problem with them was uh

00:46:37,200 --> 00:46:41,599
reference uh the return types uh

00:46:40,079 --> 00:46:43,839
reference

00:46:41,599 --> 00:46:46,640
issues so we're probably going to see

00:46:43,839 --> 00:46:48,240
them in the future

00:46:46,640 --> 00:46:49,760
sorry one more thing that i forgot to

00:46:48,240 --> 00:46:52,400
mention if you're interested

00:46:49,760 --> 00:46:54,640
more in understanding ranges there's

00:46:52,400 --> 00:46:56,720
also a talk from last year's cppcon by

00:46:54,640 --> 00:46:59,280
dre

00:46:56,720 --> 00:47:01,760
which is also a member of my national

00:46:59,280 --> 00:47:03,680
body and you're most welcome to watch it

00:47:01,760 --> 00:47:05,040
i think it's a very it's a very funny

00:47:03,680 --> 00:47:08,079
one a good one

00:47:05,040 --> 00:47:08,079
to explain ranges

00:47:08,240 --> 00:47:15,359
so as i said uh before

00:47:12,400 --> 00:47:15,680
and i think i mean to to my opinion it's

00:47:15,359 --> 00:47:17,760
a

00:47:15,680 --> 00:47:20,480
very interesting finding um the

00:47:17,760 --> 00:47:24,240
constraints evaluation have four stages

00:47:20,480 --> 00:47:27,440
so uh you you i've

00:47:24,240 --> 00:47:29,359
mentioned them before uh the the by

00:47:27,440 --> 00:47:32,400
order

00:47:29,359 --> 00:47:35,520
and i took here sorry i took here uh

00:47:32,400 --> 00:47:38,960
four uh uh evaluation four which is

00:47:35,520 --> 00:47:42,319
the last evaluation uh

00:47:38,960 --> 00:47:45,119
syntax and evaluation one which is the

00:47:42,319 --> 00:47:46,400
first evaluation syntax meaning putting

00:47:45,119 --> 00:47:50,000
the concept

00:47:46,400 --> 00:47:53,119
here at the restricting the type

00:47:50,000 --> 00:47:56,160
the template accepts

00:47:53,119 --> 00:47:59,440
sorry and putting the concepts as uh

00:47:56,160 --> 00:48:02,400
requires at the end of the function

00:47:59,440 --> 00:48:05,040
and i would have expected the

00:48:02,400 --> 00:48:08,400
performance would be

00:48:05,040 --> 00:48:12,640
equal but in fact what i found was

00:48:08,400 --> 00:48:16,319
that uh evaluate putting the um

00:48:12,640 --> 00:48:19,520
using the eva evaluation first

00:48:16,319 --> 00:48:20,240
form would actually create better

00:48:19,520 --> 00:48:23,599
performance

00:48:20,240 --> 00:48:25,760
so this is uh the stack that i've been

00:48:23,599 --> 00:48:29,040
using i've been using gcc tranq

00:48:25,760 --> 00:48:32,480
and uh flag clearly of six plus two

00:48:29,040 --> 00:48:36,160
a uh student libs

00:48:32,480 --> 00:48:39,119
spas and this is on x 86

00:48:36,160 --> 00:48:39,760
and with optimization level 3. now i

00:48:39,119 --> 00:48:42,880
would

00:48:39,760 --> 00:48:43,280
uh i would encourage you to try and test

00:48:42,880 --> 00:48:46,640
that

00:48:43,280 --> 00:48:49,680
on your machines and to see

00:48:46,640 --> 00:48:53,359
whether moving the condition

00:48:49,680 --> 00:48:55,760
to um to to the

00:48:53,359 --> 00:48:57,119
uh to this place which is evaluated

00:48:55,760 --> 00:49:00,559
first will

00:48:57,119 --> 00:49:03,359
create some performance

00:49:00,559 --> 00:49:04,240
optimization uh here and sorry i haven't

00:49:03,359 --> 00:49:06,079
mentioned it

00:49:04,240 --> 00:49:08,240
i'm referring to specifically to the

00:49:06,079 --> 00:49:08,960
time that the comp it takes the compiler

00:49:08,240 --> 00:49:11,040
to

00:49:08,960 --> 00:49:13,599
create the program not the runtime of

00:49:11,040 --> 00:49:13,599
the program

00:49:13,760 --> 00:49:18,079
and of course it could have been

00:49:15,839 --> 00:49:21,440
implementation detail but one thing i do

00:49:18,079 --> 00:49:25,119
think that is worth uh understanding

00:49:21,440 --> 00:49:29,520
from this example and in general for

00:49:25,119 --> 00:49:32,240
designing a code with concepts is that

00:49:29,520 --> 00:49:34,000
i would uh suggest you to put your

00:49:32,240 --> 00:49:37,920
breaking conditions

00:49:34,000 --> 00:49:39,119
here in the in the evaluate one form

00:49:37,920 --> 00:49:41,119
and of course you could put the

00:49:39,119 --> 00:49:44,160
otherwise odd ones uh

00:49:41,119 --> 00:49:48,000
here as well by uh by adding

00:49:44,160 --> 00:49:50,319
um conjunction disjunction etc

00:49:48,000 --> 00:49:51,920
but i would suggest to do something like

00:49:50,319 --> 00:49:54,559
putting the breaking conditions

00:49:51,920 --> 00:49:55,920
in here and then have the additional

00:49:54,559 --> 00:49:59,280
conditions here and

00:49:55,920 --> 00:50:02,319
while in order to improve performance uh

00:49:59,280 --> 00:50:05,280
the compile time of your program

00:50:02,319 --> 00:50:06,160
so what we will do is that if the

00:50:05,280 --> 00:50:09,359
condition

00:50:06,160 --> 00:50:11,680
especially if you're if your

00:50:09,359 --> 00:50:12,640
spectrum of suitable types is very

00:50:11,680 --> 00:50:16,160
limited

00:50:12,640 --> 00:50:18,880
limited sorry it will break the

00:50:16,160 --> 00:50:22,079
condition very early in the compilation

00:50:18,880 --> 00:50:26,400
process therefore i would expect it will

00:50:22,079 --> 00:50:29,040
optimize your your compilation time

00:50:26,400 --> 00:50:29,920
so i think that's uh very cool to to

00:50:29,040 --> 00:50:34,240
discover

00:50:29,920 --> 00:50:37,359
uh additional capabilities that we have

00:50:34,240 --> 00:50:40,720
by uh by using this

00:50:37,359 --> 00:50:44,160
additional syntax that's uh expect

00:50:40,720 --> 00:50:44,160
accepted in six plus 20.

00:50:44,480 --> 00:50:51,280
so takeaways from my talk

00:50:47,599 --> 00:50:53,200
so first of all i would say that

00:50:51,280 --> 00:50:56,079
i think we all agree now that template

00:50:53,200 --> 00:50:59,200
meta programming is a very powerful tool

00:50:56,079 --> 00:51:02,720
simple 20 extends the vocabulary uh

00:50:59,200 --> 00:51:05,920
for this for this for using this tool

00:51:02,720 --> 00:51:09,599
and i would even suggest that it

00:51:05,920 --> 00:51:13,040
create a simpler and clearer

00:51:09,599 --> 00:51:13,920
way to for the developer to express what

00:51:13,040 --> 00:51:16,960
he wants

00:51:13,920 --> 00:51:20,400
to be limited and

00:51:16,960 --> 00:51:24,480
a stronger way to to use compile time

00:51:20,400 --> 00:51:28,240
for logics in addition

00:51:24,480 --> 00:51:32,640
as i said the readability of the code is

00:51:28,240 --> 00:51:35,119
is increased and i would also expect

00:51:32,640 --> 00:51:36,800
that a few of the improvements that i

00:51:35,119 --> 00:51:38,800
mentioned before would be

00:51:36,800 --> 00:51:40,240
part of the standard in the following

00:51:38,800 --> 00:51:43,200
years so i

00:51:40,240 --> 00:51:44,160
think you should stay tuned and and be

00:51:43,200 --> 00:51:48,559
able to add them

00:51:44,160 --> 00:51:48,559
to your code bases whenever possible

00:51:49,280 --> 00:51:56,800
and in addition uh i think that's uh

00:51:53,280 --> 00:52:00,400
i mean i would hope that we everyone's

00:51:56,800 --> 00:52:01,520
uh gonna move to six plus uh 20 as soon

00:52:00,400 --> 00:52:04,160
as possible

00:52:01,520 --> 00:52:05,280
uh because i really think that those

00:52:04,160 --> 00:52:09,280
tools are giving us

00:52:05,280 --> 00:52:10,960
additional um additional flexibility

00:52:09,280 --> 00:52:14,240
regarding our code

00:52:10,960 --> 00:52:15,599
and even if you're not a library

00:52:14,240 --> 00:52:19,839
developer

00:52:15,599 --> 00:52:19,839
knowing those uh

00:52:21,280 --> 00:52:26,720
evaluation knowing the the order of

00:52:24,640 --> 00:52:29,280
evaluation that i've mentioned before

00:52:26,720 --> 00:52:30,319
and understanding uh overlord resolution

00:52:29,280 --> 00:52:33,440
and adl

00:52:30,319 --> 00:52:35,920
are powerful tool uh tools even

00:52:33,440 --> 00:52:36,880
uh for for code that doesn't need

00:52:35,920 --> 00:52:39,280
extensive use

00:52:36,880 --> 00:52:40,000
of template meta programming and i would

00:52:39,280 --> 00:52:43,119
hope that

00:52:40,000 --> 00:52:44,800
uh uh by this talk you you're more

00:52:43,119 --> 00:52:45,680
familiar with them and you'll go and

00:52:44,800 --> 00:52:49,920
search

00:52:45,680 --> 00:52:52,400
more about those later on

00:52:49,920 --> 00:52:53,760
and let's strive for more extensive use

00:52:52,400 --> 00:52:57,280
of templates

00:52:53,760 --> 00:52:58,079
so books that you can go over and those

00:52:57,280 --> 00:53:01,520
are

00:52:58,079 --> 00:53:02,559
clearly classics uh you could uh uh you

00:53:01,520 --> 00:53:05,920
could read those

00:53:02,559 --> 00:53:09,119
uh the simple plus one template the

00:53:05,920 --> 00:53:11,760
complete guide is aligned to 17.

00:53:09,119 --> 00:53:12,800
uh the one in the middle is actually uh

00:53:11,760 --> 00:53:16,000
was published not

00:53:12,800 --> 00:53:17,440
not very long ago and is more advanced

00:53:16,000 --> 00:53:20,880
but i think this one's

00:53:17,440 --> 00:53:23,839
clearly uh more

00:53:20,880 --> 00:53:25,119
covers uh broader material and of course

00:53:23,839 --> 00:53:29,920
you could uh

00:53:25,119 --> 00:53:33,359
go to the classic uh book

00:53:29,920 --> 00:53:33,760
publication and of course there's much

00:53:33,359 --> 00:53:35,599
more

00:53:33,760 --> 00:53:37,599
books on the internet i would love to

00:53:35,599 --> 00:53:40,160
get your recommendations as well i think

00:53:37,599 --> 00:53:42,480
this topic is fascinating

00:53:40,160 --> 00:53:43,440
so a few links that i've mentioned

00:53:42,480 --> 00:53:44,960
during uh

00:53:43,440 --> 00:53:46,480
the things that i mentioned during the

00:53:44,960 --> 00:53:50,720
talk so uh

00:53:46,480 --> 00:53:53,839
cpp con talks uh those are all happening

00:53:50,720 --> 00:53:55,839
now or in this in this session cpas 20.

00:53:53,839 --> 00:53:57,280
so as i said there's a template meta

00:53:55,839 --> 00:54:00,640
programming uh

00:53:57,280 --> 00:54:02,319
time type with emphasis on type traits

00:54:00,640 --> 00:54:05,440
by judy hanks

00:54:02,319 --> 00:54:07,680
and uh back to basic templates by andres

00:54:05,440 --> 00:54:09,599
ferti and i apologize if i don't

00:54:07,680 --> 00:54:12,240
pronounce correctly all the names

00:54:09,599 --> 00:54:13,839
i'm i think it's also a very good talk

00:54:12,240 --> 00:54:18,559
to get you started and

00:54:13,839 --> 00:54:23,200
he also explains about much more about

00:54:18,559 --> 00:54:26,559
various templates and um

00:54:23,200 --> 00:54:29,839
uh uh and not another thing that i

00:54:26,559 --> 00:54:32,480
i think that is uh tomorrow i think or

00:54:29,839 --> 00:54:34,480
i think perhaps later or tomorrow

00:54:32,480 --> 00:54:38,000
there's a a very interesting talk

00:54:34,480 --> 00:54:40,240
uh by teamwork that will the ex um

00:54:38,000 --> 00:54:41,200
talk about all new features for six plus

00:54:40,240 --> 00:54:44,640
twenty

00:54:41,200 --> 00:54:45,119
and also uh i'm sure it will be a great

00:54:44,640 --> 00:54:47,119
talk

00:54:45,119 --> 00:54:48,160
i haven't had a chance to see it yet but

00:54:47,119 --> 00:54:51,119
ben dean

00:54:48,160 --> 00:54:51,599
also talks about generic algorithms so

00:54:51,119 --> 00:54:54,559
uh

00:54:51,599 --> 00:54:54,880
the uh previous year's talks uh first

00:54:54,559 --> 00:54:57,280
one

00:54:54,880 --> 00:54:58,640
is uh by john club for more the template

00:54:57,280 --> 00:55:02,000
technic techniques

00:54:58,640 --> 00:55:04,400
and um everything is i mean uh

00:55:02,000 --> 00:55:05,119
things that you saw uh regarding enable

00:55:04,400 --> 00:55:08,240
if

00:55:05,119 --> 00:55:08,960
he explains much in much broader and i

00:55:08,240 --> 00:55:11,359
haven't got

00:55:08,960 --> 00:55:12,400
uh deeper into that because i was uh

00:55:11,359 --> 00:55:15,440
focusing on simplest

00:55:12,400 --> 00:55:18,079
20 but if you want the background if you

00:55:15,440 --> 00:55:20,559
or if you're unable to use cpl plus 20

00:55:18,079 --> 00:55:22,640
which is uh which is also common

00:55:20,559 --> 00:55:23,680
you're most welcome to go and look

00:55:22,640 --> 00:55:26,720
deeper into

00:55:23,680 --> 00:55:28,799
uh his uh uh talk and and

00:55:26,720 --> 00:55:30,160
understand the implementation for uh

00:55:28,799 --> 00:55:33,440
previous versions

00:55:30,160 --> 00:55:36,240
of simple stuff and and

00:55:33,440 --> 00:55:37,359
i also mentioned rear taki's talk for

00:55:36,240 --> 00:55:40,480
rangers which is

00:55:37,359 --> 00:55:44,559
fascinating to my opinion and uh

00:55:40,480 --> 00:55:47,280
klaus's talk from 2014

00:55:44,559 --> 00:55:50,160
is explaining very broadly about how he

00:55:47,280 --> 00:55:52,559
used expression templates for blaze

00:55:50,160 --> 00:55:54,799
uh technical data that i mentioned i'm

00:55:52,559 --> 00:55:58,079
not going to go over all of those but

00:55:54,799 --> 00:56:01,200
the papers that i've mentioned are

00:55:58,079 --> 00:56:04,480
also here and there's

00:56:01,200 --> 00:56:08,559
uh of course link to cpp insight by

00:56:04,480 --> 00:56:11,920
um andres fertig that actually um

00:56:08,559 --> 00:56:15,040
un uh unpack your templates um

00:56:11,920 --> 00:56:16,640
and present them uh i think in a very

00:56:15,040 --> 00:56:19,520
readable way so i would

00:56:16,640 --> 00:56:21,040
really recommend going that and again

00:56:19,520 --> 00:56:24,319
the papers that i mentioned

00:56:21,040 --> 00:56:27,119
appear here so thank you very much i

00:56:24,319 --> 00:56:28,000
uh will stay at the tables and take

00:56:27,119 --> 00:56:30,240
questions there

00:56:28,000 --> 00:56:32,000
because as you can see i got very close

00:56:30,240 --> 00:56:34,720
to the end of my

00:56:32,000 --> 00:56:36,720
of my slot of my time slot but i hope

00:56:34,720 --> 00:56:40,079
you are now inspired to go and explore

00:56:36,720 --> 00:56:41,440
more of c plus 20 templates and again if

00:56:40,079 --> 00:56:43,599
you want to play with the code with the

00:56:41,440 --> 00:56:46,880
snippets i will post all of those

00:56:43,599 --> 00:56:48,240
in all the lists in my github so you're

00:56:46,880 --> 00:56:51,440
most welcome to

00:56:48,240 --> 00:56:52,720
go there and experiment with them and

00:56:51,440 --> 00:56:55,920
you can always uh

00:56:52,720 --> 00:56:59,680
feel free to email me and i think uh

00:56:55,920 --> 00:57:01,760
that's i would love to hear from you if

00:56:59,680 --> 00:57:04,400
this talk have affected you and

00:57:01,760 --> 00:57:05,440
made you uh insert more templates to

00:57:04,400 --> 00:57:08,640
your code base

00:57:05,440 --> 00:57:13,839
in whatever version that you're using

00:57:08,640 --> 00:57:13,839
so thank you very much

00:57:30,160 --> 00:57:32,240

YouTube URL: https://www.youtube.com/watch?v=XgrjybKaIV8


