Title: Back to Basics: Unit Tests - Ben Saks - CppCon 2020
Publication date: 2020-09-28
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Automated unit tests can accelerate software development by quickly identifying regressions, clarifying interface requirements, and encouraging more modular designs. However, actually incorporating unit tests into your development process can be intimidating. Choosing a unit testing framework can be a daunting task because there are so many frameworks with such wide-ranging capabilities. Moreover, even when using a really good framework, crafting effective tests is a skill that takes time to master.

This session takes you through the process of writing automated unit tests for realistic code, working from very simple tests up to more complex ones. It starts with a brief introduction to automated testing and test-driven development. It shows you the first steps toward using automated unit tests in your development process.

In this session, you’ll learn the practical benefits of a unit testing framework through examples using Google Test. You’ll see how you can simplify difficult tests using dependency injection and Google Mock in addition to Google Test. Along the way, you’ll learn about different testing strategies, as well as concepts such as test coverage and ordering dependencies. Whether you’re new to automated testing or looking for a way to test challenging components, this session will help you take the next step toward more reliable, test-driven software.

---
Ben Saks
Chief Engineer, Saks & Associates

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,120 --> 00:00:12,559
all right

00:00:09,679 --> 00:00:13,679
hello everyone i'm ben sax for those of

00:00:12,559 --> 00:00:15,920
you who don't know me

00:00:13,679 --> 00:00:18,160
my company saks associates offers

00:00:15,920 --> 00:00:21,039
training in cnc plus plus

00:00:18,160 --> 00:00:22,160
for companies all over the world and i'm

00:00:21,039 --> 00:00:25,439
here to talk a little bit

00:00:22,160 --> 00:00:28,560
about the basics of unit testing

00:00:25,439 --> 00:00:31,119
so there's a lot to cover uh so i'd like

00:00:28,560 --> 00:00:34,480
to just dive in but one thing to mention

00:00:31,119 --> 00:00:34,480
is that um

00:00:34,800 --> 00:00:41,360
feel free to ask questions as we go

00:00:38,160 --> 00:00:42,000
um i will try and take them as best i

00:00:41,360 --> 00:00:44,480
can

00:00:42,000 --> 00:00:47,039
uh but please understand we're on

00:00:44,480 --> 00:00:49,440
something like a 10 to 15 second delay

00:00:47,039 --> 00:00:50,640
so it may take me a moment to see your

00:00:49,440 --> 00:00:54,800
question and respond

00:00:50,640 --> 00:00:58,320
to it all right let's get started

00:00:54,800 --> 00:00:59,039
so automated unit testing is something

00:00:58,320 --> 00:01:01,680
that's

00:00:59,039 --> 00:01:03,039
become very popular in certain circles

00:01:01,680 --> 00:01:05,040
of development

00:01:03,039 --> 00:01:06,960
there's a lot of books written on it a

00:01:05,040 --> 00:01:09,040
lot of people swear by it

00:01:06,960 --> 00:01:10,479
but at the same time there are also a

00:01:09,040 --> 00:01:11,600
lot of developers who've never had the

00:01:10,479 --> 00:01:14,960
chance to do it

00:01:11,600 --> 00:01:15,920
who are haven't written any automated

00:01:14,960 --> 00:01:19,759
unit tests

00:01:15,920 --> 00:01:21,280
and given that the amount of information

00:01:19,759 --> 00:01:24,720
that's out there

00:01:21,280 --> 00:01:26,880
can seem kind of overwhelming to

00:01:24,720 --> 00:01:28,560
from someone approaching it from that

00:01:26,880 --> 00:01:31,759
initial position

00:01:28,560 --> 00:01:33,840
so for example uh

00:01:31,759 --> 00:01:35,200
if you look back at one of the previous

00:01:33,840 --> 00:01:38,159
cpp contacts

00:01:35,200 --> 00:01:41,119
on unit testing they listed out five

00:01:38,159 --> 00:01:44,320
different properties of good unit tests

00:01:41,119 --> 00:01:45,920
correctness that the test succeeds when

00:01:44,320 --> 00:01:46,240
it should succeed and fail when it

00:01:45,920 --> 00:01:48,240
should

00:01:46,240 --> 00:01:50,000
when it's supposed to fail that is

00:01:48,240 --> 00:01:51,840
readable so that you can actually

00:01:50,000 --> 00:01:54,560
understand what the test is doing

00:01:51,840 --> 00:01:56,960
without extra documentation

00:01:54,560 --> 00:01:59,040
completeness the idea that your tests

00:01:56,960 --> 00:02:02,240
cover enough of your program

00:01:59,040 --> 00:02:04,880
to provide you with a good sign that

00:02:02,240 --> 00:02:08,319
things are working correctly

00:02:04,880 --> 00:02:09,679
demonstrative the tests serve as a model

00:02:08,319 --> 00:02:12,640
for how you would actually

00:02:09,679 --> 00:02:13,680
use the components being tested and

00:02:12,640 --> 00:02:15,680
resilient

00:02:13,680 --> 00:02:16,959
they'd be maintainable and useful over

00:02:15,680 --> 00:02:18,640
time

00:02:16,959 --> 00:02:20,480
there's a fair bit to think about just

00:02:18,640 --> 00:02:22,800
there and this is just one question

00:02:20,480 --> 00:02:24,000
we also you also may find yourself

00:02:22,800 --> 00:02:26,239
thinking about

00:02:24,000 --> 00:02:28,000
what unit testing framework should i use

00:02:26,239 --> 00:02:29,200
and there's a whole bunch of them that

00:02:28,000 --> 00:02:32,800
you could potentially

00:02:29,200 --> 00:02:35,760
choose from there are other questions

00:02:32,800 --> 00:02:36,000
like how do i avoid dependencies between

00:02:35,760 --> 00:02:39,360
the

00:02:36,000 --> 00:02:40,319
tests how will i integrate this testing

00:02:39,360 --> 00:02:42,720
with my build

00:02:40,319 --> 00:02:43,440
process in some say a continuous

00:02:42,720 --> 00:02:45,680
integration

00:02:43,440 --> 00:02:47,519
server or something like that how i

00:02:45,680 --> 00:02:48,959
measure how much of my code is actually

00:02:47,519 --> 00:02:51,760
being tested

00:02:48,959 --> 00:02:52,160
do i have a code coverage tool that i

00:02:51,760 --> 00:02:56,319
need to

00:02:52,160 --> 00:02:59,840
select so all of that taken together

00:02:56,319 --> 00:03:01,200
can be kind of intimidating and it means

00:02:59,840 --> 00:03:02,959
that

00:03:01,200 --> 00:03:04,319
it can put you in a very paralyzed

00:03:02,959 --> 00:03:06,400
position because

00:03:04,319 --> 00:03:07,920
if you're just starting to look at unit

00:03:06,400 --> 00:03:10,319
testing

00:03:07,920 --> 00:03:11,519
you may think i'd really like to test

00:03:10,319 --> 00:03:14,080
this thing

00:03:11,519 --> 00:03:15,840
but i'm not being paid to write tests

00:03:14,080 --> 00:03:19,599
i'm being paid to get this thing

00:03:15,840 --> 00:03:22,239
shipped on friday so

00:03:19,599 --> 00:03:22,879
i need to be i need to make sure that

00:03:22,239 --> 00:03:26,480
i'm not

00:03:22,879 --> 00:03:28,080
spending too much time doing this and

00:03:26,480 --> 00:03:30,000
the point i'm trying to make in this

00:03:28,080 --> 00:03:32,239
talk is that you can grow

00:03:30,000 --> 00:03:34,480
into unit testing it's something that

00:03:32,239 --> 00:03:38,400
you don't have to

00:03:34,480 --> 00:03:39,840
take as one big giant leap you can do it

00:03:38,400 --> 00:03:42,319
as a series of

00:03:39,840 --> 00:03:43,200
steps so eventually all of these

00:03:42,319 --> 00:03:45,760
questions about

00:03:43,200 --> 00:03:47,440
which framework should i use how will i

00:03:45,760 --> 00:03:49,040
keep my tests independent

00:03:47,440 --> 00:03:50,799
those are things that you will want to

00:03:49,040 --> 00:03:54,560
address in order to

00:03:50,799 --> 00:03:56,640
get a really solid unit testing system

00:03:54,560 --> 00:03:59,680
for your project

00:03:56,640 --> 00:04:00,319
but you can start without answering all

00:03:59,680 --> 00:04:02,319
of those

00:04:00,319 --> 00:04:05,120
questions there are unit tests you can

00:04:02,319 --> 00:04:08,480
write before that

00:04:05,120 --> 00:04:09,920
so just uh

00:04:08,480 --> 00:04:12,319
as i was writing this up i thought of

00:04:09,920 --> 00:04:13,200
the saying from lao tzu the chinese

00:04:12,319 --> 00:04:15,280
philosopher

00:04:13,200 --> 00:04:17,759
journey of a journey of a thousand miles

00:04:15,280 --> 00:04:19,919
begins with a single step

00:04:17,759 --> 00:04:21,440
you've got to start somewhere uh if

00:04:19,919 --> 00:04:22,160
you're going to write automated unit

00:04:21,440 --> 00:04:24,800
tests

00:04:22,160 --> 00:04:26,000
one of them is going to be your first

00:04:24,800 --> 00:04:27,680
and in this case

00:04:26,000 --> 00:04:30,000
what i'll be doing is starting with an

00:04:27,680 --> 00:04:31,360
existing program that doesn't have any

00:04:30,000 --> 00:04:34,240
automated tests at

00:04:31,360 --> 00:04:35,120
all and what we'll do what i will show

00:04:34,240 --> 00:04:38,880
is

00:04:35,120 --> 00:04:42,000
uh we'll put a minimum amount of

00:04:38,880 --> 00:04:46,400
code in place to get an automated test

00:04:42,000 --> 00:04:46,400
running and then we'll build on that

00:04:46,720 --> 00:04:50,240
so uh and the other thing i want to

00:04:49,759 --> 00:04:53,840
mention

00:04:50,240 --> 00:04:55,520
is this saying from chuck jones

00:04:53,840 --> 00:04:57,040
every artist has thousands of bad

00:04:55,520 --> 00:04:59,280
drawings in them and the only way to get

00:04:57,040 --> 00:05:02,320
them out is to draw them out

00:04:59,280 --> 00:05:04,800
that is to say you will

00:05:02,320 --> 00:05:07,759
there will probably be flaws in the

00:05:04,800 --> 00:05:10,000
first automated tests that you write

00:05:07,759 --> 00:05:11,039
that's okay it's part of the learning

00:05:10,000 --> 00:05:13,360
process

00:05:11,039 --> 00:05:15,280
we expect to get better at this over

00:05:13,360 --> 00:05:18,160
time

00:05:15,280 --> 00:05:19,360
so in some of these cases that i'm

00:05:18,160 --> 00:05:22,240
showing you here we will

00:05:19,360 --> 00:05:24,160
start with a test that might have some

00:05:22,240 --> 00:05:26,639
weaknesses or flaws in it

00:05:24,160 --> 00:05:29,520
and will gradually improve it over the

00:05:26,639 --> 00:05:29,520
course of this hour

00:05:29,840 --> 00:05:33,360
now i mentioned that i'm starting with

00:05:32,400 --> 00:05:36,479
an existing

00:05:33,360 --> 00:05:37,759
program here i'm doing that because i

00:05:36,479 --> 00:05:39,759
think that that's the situation that a

00:05:37,759 --> 00:05:42,800
lot of developers are in

00:05:39,759 --> 00:05:44,400
we often if you are looking at adopting

00:05:42,800 --> 00:05:48,080
unit testing early

00:05:44,400 --> 00:05:49,840
uh you're you're working on some piece

00:05:48,080 --> 00:05:50,240
of an existing project most of us are

00:05:49,840 --> 00:05:52,160
not

00:05:50,240 --> 00:05:54,320
right at the point of starting up our

00:05:52,160 --> 00:05:56,960
next project right now

00:05:54,320 --> 00:05:59,199
and so test driven development the

00:05:56,960 --> 00:06:01,840
standard model would be

00:05:59,199 --> 00:06:02,639
before you write any new code for the

00:06:01,840 --> 00:06:06,000
project

00:06:02,639 --> 00:06:07,280
write the test code do just enough to

00:06:06,000 --> 00:06:10,720
get the code to com

00:06:07,280 --> 00:06:13,199
the code to compile and watch it fail

00:06:10,720 --> 00:06:14,160
uh run the test and then once you've

00:06:13,199 --> 00:06:17,120
seen that the test

00:06:14,160 --> 00:06:19,199
fails correctly then go and actually

00:06:17,120 --> 00:06:22,400
write the code

00:06:19,199 --> 00:06:24,800
that is needed to make the test pass

00:06:22,400 --> 00:06:26,720
and once you've done that once you've

00:06:24,800 --> 00:06:29,199
gotten together the basic

00:06:26,720 --> 00:06:30,639
code that needs to be there for the test

00:06:29,199 --> 00:06:34,560
to pass then you can

00:06:30,639 --> 00:06:36,319
refine it and refactor it to

00:06:34,560 --> 00:06:38,400
improve the state of it so that the

00:06:36,319 --> 00:06:40,880
system is

00:06:38,400 --> 00:06:42,400
more flexible and ready for well the

00:06:40,880 --> 00:06:44,960
next test that you're going to write

00:06:42,400 --> 00:06:44,960
basically

00:06:46,400 --> 00:06:50,880
but in this case we're not uh we're not

00:06:49,199 --> 00:06:53,440
doing that because the program

00:06:50,880 --> 00:06:55,120
already exists now that's not to say

00:06:53,440 --> 00:06:57,520
that test driven development

00:06:55,120 --> 00:06:58,880
isn't a good thing to use i like to use

00:06:57,520 --> 00:07:00,800
it when i can

00:06:58,880 --> 00:07:03,440
i think writing the tests first has a

00:07:00,800 --> 00:07:05,440
lot of benefits it helps you

00:07:03,440 --> 00:07:06,880
get a clear sense of the interface that

00:07:05,440 --> 00:07:09,440
you're trying to

00:07:06,880 --> 00:07:12,960
implement it forces you to think about

00:07:09,440 --> 00:07:12,960
testability early on

00:07:13,280 --> 00:07:19,280
and you you don't have to do

00:07:16,400 --> 00:07:19,840
artificial work to make sure that the

00:07:19,280 --> 00:07:21,599
test

00:07:19,840 --> 00:07:23,039
fails later on we'll see that a little

00:07:21,599 --> 00:07:26,240
bit later

00:07:23,039 --> 00:07:30,000
but i also wanted to make sure that you

00:07:26,240 --> 00:07:33,360
that it was clear that tdd isn't the

00:07:30,000 --> 00:07:35,199
only way to write automated unit tests

00:07:33,360 --> 00:07:37,440
i don't want i don't want you to think

00:07:35,199 --> 00:07:39,759
that oh just because i didn't

00:07:37,440 --> 00:07:41,840
start out writing unit tests from the

00:07:39,759 --> 00:07:45,039
very beginning

00:07:41,840 --> 00:07:46,000
then well now there's no need to there's

00:07:45,039 --> 00:07:49,039
no point in

00:07:46,000 --> 00:07:50,479
doing them now there are you should

00:07:49,039 --> 00:07:52,560
still write the tests even if you

00:07:50,479 --> 00:07:56,080
weren't able to necessarily write them

00:07:52,560 --> 00:07:58,080
first if you want stable software

00:07:56,080 --> 00:07:59,120
all right so the program i'm going to

00:07:58,080 --> 00:08:02,400
use for

00:07:59,120 --> 00:08:05,840
this example here is uh

00:08:02,400 --> 00:08:09,440
it's called decal and what it does is it

00:08:05,840 --> 00:08:12,479
translates basic c plus declarations

00:08:09,440 --> 00:08:13,280
into english text it's taken from an

00:08:12,479 --> 00:08:16,639
exercise

00:08:13,280 --> 00:08:18,639
in kernan richie's original book and

00:08:16,639 --> 00:08:21,120
they did not publish solutions in their

00:08:18,639 --> 00:08:23,599
book but there's a separate book the c

00:08:21,120 --> 00:08:24,240
answer book by tondo and gimple that

00:08:23,599 --> 00:08:27,120
does

00:08:24,240 --> 00:08:28,720
show solutions to those exercises i'm

00:08:27,120 --> 00:08:30,400
not using their solution

00:08:28,720 --> 00:08:32,000
i'm using a secret their solution was

00:08:30,400 --> 00:08:36,000
written in c

00:08:32,000 --> 00:08:40,560
but i've used some i'm using something

00:08:36,000 --> 00:08:45,040
based on that example the idea is that

00:08:40,560 --> 00:08:48,160
you will type in a c plus declaration

00:08:45,040 --> 00:08:51,519
like this into standard input

00:08:48,160 --> 00:08:54,800
and deco will output a description

00:08:51,519 --> 00:08:55,519
of what that object that's being

00:08:54,800 --> 00:08:58,800
declared

00:08:55,519 --> 00:09:01,600
is in basic english

00:08:58,800 --> 00:09:02,800
it will decipher this it'll translate

00:09:01,600 --> 00:09:05,920
stars into

00:09:02,800 --> 00:09:06,839
pointer to it will translate angle

00:09:05,920 --> 00:09:10,000
brackets

00:09:06,839 --> 00:09:13,839
into array of n elements

00:09:10,000 --> 00:09:17,440
things like that this will help this

00:09:13,839 --> 00:09:20,080
uh is sometimes helpful for

00:09:17,440 --> 00:09:21,600
seeing the difference between say a

00:09:20,080 --> 00:09:25,360
constant pointer

00:09:21,600 --> 00:09:27,600
and a pointer to a constant object

00:09:25,360 --> 00:09:28,800
and also just it's a nice exercise for

00:09:27,600 --> 00:09:31,440
reinforcing

00:09:28,800 --> 00:09:33,200
what you already know about c plus

00:09:31,440 --> 00:09:35,440
declarations

00:09:33,200 --> 00:09:37,279
now i didn't create this exercise

00:09:35,440 --> 00:09:38,240
specifically for this talk it's actually

00:09:37,279 --> 00:09:40,959
taken from

00:09:38,240 --> 00:09:42,240
a series of articles written about 25

00:09:40,959 --> 00:09:44,240
years ago

00:09:42,240 --> 00:09:46,240
um so you'll see that in the

00:09:44,240 --> 00:09:48,160
bibliography at the end

00:09:46,240 --> 00:09:50,320
it's not exactly what appeared in those

00:09:48,160 --> 00:09:52,160
articles either i've updated it to use

00:09:50,320 --> 00:09:55,360
some modern z-plus plus

00:09:52,160 --> 00:09:57,680
but it's still

00:09:55,360 --> 00:09:59,200
very you know if you if you happen to

00:09:57,680 --> 00:10:01,920
have read those articles you will see

00:09:59,200 --> 00:10:05,279
some similarities

00:10:01,920 --> 00:10:07,760
all right so uh deco reads in input

00:10:05,279 --> 00:10:08,959
a character at a time gets rid of any

00:10:07,760 --> 00:10:10,880
white space

00:10:08,959 --> 00:10:13,040
and it groups the remaining characters

00:10:10,880 --> 00:10:15,600
into tokens

00:10:13,040 --> 00:10:16,800
so each token is a series of characters

00:10:15,600 --> 00:10:20,800
that forms

00:10:16,800 --> 00:10:23,920
a single symbol for parsing purposes

00:10:20,800 --> 00:10:26,800
so here inch

00:10:23,920 --> 00:10:28,160
is one symbol the star is a symbol by

00:10:26,800 --> 00:10:30,640
itself

00:10:28,160 --> 00:10:31,360
the let the word p that's a symbol by

00:10:30,640 --> 00:10:35,680
itself

00:10:31,360 --> 00:10:39,440
and the semicolon is also a symbol so

00:10:35,680 --> 00:10:40,959
uh so i'll show you that breakdown in a

00:10:39,440 --> 00:10:44,079
little bit more detail

00:10:40,959 --> 00:10:46,320
as we go on there are three

00:10:44,079 --> 00:10:47,519
main classes that are involved in the

00:10:46,320 --> 00:10:50,959
decal program

00:10:47,519 --> 00:10:53,200
there's a token class where each token

00:10:50,959 --> 00:10:54,079
represents a single one of these input

00:10:53,200 --> 00:10:57,120
tokens like

00:10:54,079 --> 00:10:58,560
the word int the the star that

00:10:57,120 --> 00:11:02,240
represents a pointer

00:10:58,560 --> 00:11:06,160
things like that the scanner class

00:11:02,240 --> 00:11:08,720
a scanner object takes in

00:11:06,160 --> 00:11:09,839
input as a stream of characters from a

00:11:08,720 --> 00:11:13,120
basic input stream

00:11:09,839 --> 00:11:15,839
and translates it into a series of

00:11:13,120 --> 00:11:15,839
tokens

00:11:17,920 --> 00:11:21,200
and that those tokens are fed into a

00:11:20,240 --> 00:11:24,240
parser

00:11:21,200 --> 00:11:26,720
which analyzes the sequence of tokens

00:11:24,240 --> 00:11:28,160
figures out if they form a valid c plus

00:11:26,720 --> 00:11:30,320
plus declaration

00:11:28,160 --> 00:11:33,519
and if they do it translates that

00:11:30,320 --> 00:11:35,920
declaration into english

00:11:33,519 --> 00:11:37,959
so there are two source files involved

00:11:35,920 --> 00:11:41,279
here scanner.cpp and

00:11:37,959 --> 00:11:42,279
decal.cpp uh the token and the scanner

00:11:41,279 --> 00:11:45,200
classes are in

00:11:42,279 --> 00:11:45,839
scanner.cpp the parser class and main

00:11:45,200 --> 00:11:49,600
function

00:11:45,839 --> 00:11:49,600
are in decal.cpp

00:11:49,680 --> 00:11:53,279
so each token consists of two data

00:11:52,560 --> 00:11:55,360
members

00:11:53,279 --> 00:11:57,279
there's the actual text of the token

00:11:55,360 --> 00:12:00,560
itself and there's also a

00:11:57,279 --> 00:12:04,399
category that identifies what

00:12:00,560 --> 00:12:06,560
general kind of token this thing is

00:12:04,399 --> 00:12:07,440
and so there's uh there's a special

00:12:06,560 --> 00:12:10,800
category

00:12:07,440 --> 00:12:12,240
no more that identifies the end of input

00:12:10,800 --> 00:12:14,800
this isn't really a token

00:12:12,240 --> 00:12:16,880
it's the indication that no more tokens

00:12:14,800 --> 00:12:20,079
exist

00:12:16,880 --> 00:12:23,680
so when the scanner receives this input

00:12:20,079 --> 00:12:26,079
here in star p semicolon

00:12:23,680 --> 00:12:27,839
it will wind up generating these tokens

00:12:26,079 --> 00:12:31,519
in order

00:12:27,839 --> 00:12:33,760
one for int one for the star p

00:12:31,519 --> 00:12:35,839
semicolon and then the very last one

00:12:33,760 --> 00:12:38,240
will be the empty string

00:12:35,839 --> 00:12:40,560
with the no more category indicating

00:12:38,240 --> 00:12:44,720
that we've reached the end of the input

00:12:40,560 --> 00:12:44,720
there are no more tokens left to read

00:12:45,360 --> 00:12:49,600
the token class has a fairly simple

00:12:48,000 --> 00:12:51,920
public interface it just has

00:12:49,600 --> 00:12:53,760
it consists of just the category

00:12:51,920 --> 00:12:56,800
enumeration type

00:12:53,760 --> 00:12:59,839
uh some default copy operations

00:12:56,800 --> 00:13:00,880
and then accessor functions for the text

00:12:59,839 --> 00:13:03,920
and

00:13:00,880 --> 00:13:03,920
category pieces

00:13:04,320 --> 00:13:11,040
it only the only uh it's only public

00:13:07,760 --> 00:13:13,519
constructor is the copy constructor so

00:13:11,040 --> 00:13:14,160
in general tokens originate with the

00:13:13,519 --> 00:13:16,800
scanner

00:13:14,160 --> 00:13:18,480
the scanner is the piece that creates

00:13:16,800 --> 00:13:20,320
tokens in the first place

00:13:18,480 --> 00:13:23,360
once you've received one you can copy it

00:13:20,320 --> 00:13:26,399
around but you can't really create them

00:13:23,360 --> 00:13:28,880
yourself outside of the scanner

00:13:26,399 --> 00:13:30,399
so there are these two other

00:13:28,880 --> 00:13:32,959
constructors

00:13:30,399 --> 00:13:33,519
for the scanner to use to actually

00:13:32,959 --> 00:13:36,399
create

00:13:33,519 --> 00:13:38,560
tokens and it has access to them because

00:13:36,399 --> 00:13:40,800
scanner is declared as a friend class

00:13:38,560 --> 00:13:42,079
of the token the scanner and the token

00:13:40,800 --> 00:13:46,000
are really designed to

00:13:42,079 --> 00:13:48,000
to work together closely like this

00:13:46,000 --> 00:13:49,360
scanner's public interface is just a

00:13:48,000 --> 00:13:52,480
constructor and

00:13:49,360 --> 00:13:55,120
two functions the constructor

00:13:52,480 --> 00:13:57,040
uh sets up the scanner to use a

00:13:55,120 --> 00:13:59,199
particular input stream

00:13:57,040 --> 00:14:01,920
get reads the next token in the input

00:13:59,199 --> 00:14:03,920
stream current is just a way of fetching

00:14:01,920 --> 00:14:07,120
the last value that get

00:14:03,920 --> 00:14:09,839
recently returned so uh you can

00:14:07,120 --> 00:14:11,600
it once you call get ones if you keep

00:14:09,839 --> 00:14:13,199
calling current after that it'll return

00:14:11,600 --> 00:14:14,160
the same thing that get returned

00:14:13,199 --> 00:14:16,240
initially

00:14:14,160 --> 00:14:18,000
once you call get again it will move on

00:14:16,240 --> 00:14:20,240
to the next token

00:14:18,000 --> 00:14:21,120
and current will then start returning

00:14:20,240 --> 00:14:25,440
that token

00:14:21,120 --> 00:14:27,920
instead the parser class here

00:14:25,440 --> 00:14:29,839
has a public interface that's just a

00:14:27,920 --> 00:14:31,360
constructor that sets up the input and

00:14:29,839 --> 00:14:34,320
output streams

00:14:31,360 --> 00:14:35,519
for the parsing operation and a single

00:14:34,320 --> 00:14:38,880
function here that just

00:14:35,519 --> 00:14:38,880
triggers the parse to go

00:14:39,519 --> 00:14:42,959
now what the parse function actually

00:14:41,120 --> 00:14:46,800
does is it

00:14:42,959 --> 00:14:49,360
it can read multiple declarations it's

00:14:46,800 --> 00:14:51,120
and it just reads them one token one

00:14:49,360 --> 00:14:53,279
declaration at a time essentially until

00:14:51,120 --> 00:14:56,000
the scanner runs out of tokens

00:14:53,279 --> 00:14:57,519
so the first time that control reaches

00:14:56,000 --> 00:15:00,560
this line

00:14:57,519 --> 00:15:01,839
uh when we're parsing this input the

00:15:00,560 --> 00:15:05,279
token will be that

00:15:01,839 --> 00:15:05,279
int keyword at the beginning

00:15:07,120 --> 00:15:11,199
which means that the token isn't the no

00:15:10,000 --> 00:15:14,320
more token

00:15:11,199 --> 00:15:16,720
will move on and parse a declaration

00:15:14,320 --> 00:15:18,639
most of that is done inside this simple

00:15:16,720 --> 00:15:21,680
declaration helper function it's a

00:15:18,639 --> 00:15:23,760
private function on the parser and it

00:15:21,680 --> 00:15:26,240
will read until it finds a token

00:15:23,760 --> 00:15:28,160
that can't be part of a declaration and

00:15:26,240 --> 00:15:29,279
if if we're talking about a well-formed

00:15:28,160 --> 00:15:31,440
declaration in c

00:15:29,279 --> 00:15:34,800
plus that's going to be a semicolon that

00:15:31,440 --> 00:15:34,800
marks the end of the statement

00:15:35,199 --> 00:15:39,839
this program doesn't is dealing with

00:15:38,240 --> 00:15:42,639
just declarations

00:15:39,839 --> 00:15:43,959
not definitions so it doesn't include a

00:15:42,639 --> 00:15:47,199
support for

00:15:43,959 --> 00:15:50,560
initializers x

00:15:47,199 --> 00:15:54,720
equals three it just it just allows int

00:15:50,560 --> 00:15:56,639
x semicolon at this point

00:15:54,720 --> 00:15:58,399
so main function all it needs to do is

00:15:56,639 --> 00:16:01,519
create a parser and then

00:15:58,399 --> 00:16:01,519
call the parse function

00:16:01,920 --> 00:16:08,079
all right so that's enough setup

00:16:05,519 --> 00:16:10,079
what do we do about tests at the moment

00:16:08,079 --> 00:16:11,040
decal doesn't have any automated tests

00:16:10,079 --> 00:16:14,079
at all

00:16:11,040 --> 00:16:14,480
and there's a maxim that i've often

00:16:14,079 --> 00:16:16,800
heard

00:16:14,480 --> 00:16:17,839
programmers use that i'd like to come

00:16:16,800 --> 00:16:19,759
back to

00:16:17,839 --> 00:16:21,199
is what's the simplest thing that could

00:16:19,759 --> 00:16:24,399
possibly work

00:16:21,199 --> 00:16:27,680
we if we're starting from zero

00:16:24,399 --> 00:16:31,920
rather than spend a lot of time thinking

00:16:27,680 --> 00:16:34,160
about um

00:16:31,920 --> 00:16:36,160
about you know different ways of doing

00:16:34,160 --> 00:16:39,759
things just try to boil it down to the

00:16:36,160 --> 00:16:41,040
simplest elements and start at that

00:16:39,759 --> 00:16:43,040
point

00:16:41,040 --> 00:16:44,240
question do you believe it isn't

00:16:43,040 --> 00:16:47,040
possible to employ

00:16:44,240 --> 00:16:48,320
tdd in existing projects with legacy

00:16:47,040 --> 00:16:51,279
code

00:16:48,320 --> 00:16:52,160
legacy being untested in this case no

00:16:51,279 --> 00:16:56,480
it's

00:16:52,160 --> 00:17:00,160
so different people would be

00:16:56,480 --> 00:17:02,480
more or less pedantic about what tdd

00:17:00,160 --> 00:17:04,480
actually is some people would look at

00:17:02,480 --> 00:17:06,559
some one person might look at something

00:17:04,480 --> 00:17:08,160
and say oh yeah that's tdd

00:17:06,559 --> 00:17:10,079
and another person might look at it and

00:17:08,160 --> 00:17:12,720
say well you're not really

00:17:10,079 --> 00:17:13,520
doing test driven development because

00:17:12,720 --> 00:17:15,679
you didn't

00:17:13,520 --> 00:17:16,559
write all of your tests first one at a

00:17:15,679 --> 00:17:19,679
time

00:17:16,559 --> 00:17:22,160
for example depending on how strict you

00:17:19,679 --> 00:17:22,160
want to be

00:17:22,720 --> 00:17:25,520
some people might

00:17:26,079 --> 00:17:30,720
say different things there i do think

00:17:28,400 --> 00:17:33,120
that it's possible to employ tdd in an

00:17:30,720 --> 00:17:36,400
existing project something that didn't

00:17:33,120 --> 00:17:39,600
start from the ground up using tdd

00:17:36,400 --> 00:17:41,840
you get if you're writing new components

00:17:39,600 --> 00:17:44,320
you really can write the tests first

00:17:41,840 --> 00:17:47,600
quite easily

00:17:44,320 --> 00:17:49,760
and again and if you don't write the

00:17:47,600 --> 00:17:52,400
tests first that's not necessarily what

00:17:49,760 --> 00:17:55,200
everyone calls test driven development

00:17:52,400 --> 00:17:56,799
but it's still but if you're writing the

00:17:55,200 --> 00:17:58,960
automated tests

00:17:56,799 --> 00:18:01,360
eventually you can wind up in a fairly

00:17:58,960 --> 00:18:04,240
similar spot

00:18:01,360 --> 00:18:04,640
uh because the end goal is the same we

00:18:04,240 --> 00:18:06,240
want

00:18:04,640 --> 00:18:08,400
working code that has a bunch of

00:18:06,240 --> 00:18:11,919
automated tests that will ensure

00:18:08,400 --> 00:18:15,039
it keeps working tomorrow so

00:18:11,919 --> 00:18:16,080
uh i think that you i think that you can

00:18:15,039 --> 00:18:18,480
use tdd

00:18:16,080 --> 00:18:21,039
in an existing project with legacy code

00:18:18,480 --> 00:18:23,679
but it is something that has to be

00:18:21,039 --> 00:18:24,320
introduced over time you wouldn't have

00:18:23,679 --> 00:18:29,840
the whole

00:18:24,320 --> 00:18:29,840
project suddenly become tdd-based

00:18:30,000 --> 00:18:35,440
okay so how can we add an automated unit

00:18:33,679 --> 00:18:38,640
test to decl

00:18:35,440 --> 00:18:41,679
as simply as possible

00:18:38,640 --> 00:18:44,320
so in general the classes with fewer

00:18:41,679 --> 00:18:46,799
dependencies are easier to test

00:18:44,320 --> 00:18:47,440
so the parser here depends on both

00:18:46,799 --> 00:18:51,120
scanner

00:18:47,440 --> 00:18:52,160
and token scanner and token depend on

00:18:51,120 --> 00:18:54,000
each other

00:18:52,160 --> 00:18:55,200
but neither one of them knows about the

00:18:54,000 --> 00:18:57,280
parser

00:18:55,200 --> 00:18:59,120
scanners public public functions are

00:18:57,280 --> 00:19:02,320
designed to return tokens

00:18:59,120 --> 00:19:06,080
and tokens can really only be created

00:19:02,320 --> 00:19:07,440
by the scanner so they're designed to

00:19:06,080 --> 00:19:10,320
work together

00:19:07,440 --> 00:19:10,799
it makes sense to focus our first test

00:19:10,320 --> 00:19:13,200
on

00:19:10,799 --> 00:19:14,880
the scanner and the tokens rather than

00:19:13,200 --> 00:19:19,280
on the parser

00:19:14,880 --> 00:19:19,280
because they have fewer dependencies

00:19:19,440 --> 00:19:23,360
so decal knows that it's reached the end

00:19:22,960 --> 00:19:25,520
of the

00:19:23,360 --> 00:19:28,240
input when the scanner says there are no

00:19:25,520 --> 00:19:28,240
more tokens

00:19:28,960 --> 00:19:33,200
that means if the simplest possible test

00:19:31,840 --> 00:19:36,240
is if there's no input

00:19:33,200 --> 00:19:40,000
at all the very first token

00:19:36,240 --> 00:19:43,440
should say there's no more input

00:19:40,000 --> 00:19:43,440
that's our simplest test

00:19:44,400 --> 00:19:47,840
the base the body of the test is going

00:19:45,840 --> 00:19:50,480
to look something like this

00:19:47,840 --> 00:19:50,960
set up an input stream that represents

00:19:50,480 --> 00:19:53,840
empty

00:19:50,960 --> 00:19:55,600
input create a scanner that uses that

00:19:53,840 --> 00:19:57,679
input stream

00:19:55,600 --> 00:19:59,280
in the first token and what we should

00:19:57,679 --> 00:20:02,720
see at the other end is

00:19:59,280 --> 00:20:03,679
that token says no more there's no more

00:20:02,720 --> 00:20:05,280
input

00:20:03,679 --> 00:20:07,440
in a sense there never was any input to

00:20:05,280 --> 00:20:10,320
begin with

00:20:07,440 --> 00:20:10,960
so when we translate that into code it's

00:20:10,320 --> 00:20:13,039
going to look

00:20:10,960 --> 00:20:14,960
something like this that is we know

00:20:13,039 --> 00:20:16,640
we're going to build the scanner around

00:20:14,960 --> 00:20:18,400
some kind of input

00:20:16,640 --> 00:20:20,320
we're going to read a token from the

00:20:18,400 --> 00:20:20,880
scanner and we're going to check to see

00:20:20,320 --> 00:20:25,120
whether

00:20:20,880 --> 00:20:27,360
the category of that token is no more

00:20:25,120 --> 00:20:29,120
what we need to do now is figure out

00:20:27,360 --> 00:20:32,159
okay how are we going to represent

00:20:29,120 --> 00:20:36,559
empty input how are we going to report

00:20:32,159 --> 00:20:38,799
success and failure from this test

00:20:36,559 --> 00:20:38,799
so

00:20:40,640 --> 00:20:44,799
with regard to the empty input

00:20:42,400 --> 00:20:45,840
ordinarily deco is written to take its

00:20:44,799 --> 00:20:49,039
input from

00:20:45,840 --> 00:20:49,520
cn standard m now since this is going to

00:20:49,039 --> 00:20:52,640
be an

00:20:49,520 --> 00:20:54,960
automated test it's not very automated

00:20:52,640 --> 00:20:57,280
if a user has to sit there and type

00:20:54,960 --> 00:20:58,080
in the input that we're intending to

00:20:57,280 --> 00:21:00,880
test

00:20:58,080 --> 00:21:03,039
so that's not going to work very well

00:21:00,880 --> 00:21:05,200
for us fortunately we've written

00:21:03,039 --> 00:21:06,080
scanners constructor to work with any

00:21:05,200 --> 00:21:09,360
istream

00:21:06,080 --> 00:21:11,760
not just with standard in

00:21:09,360 --> 00:21:13,679
so we can pass in another kind of

00:21:11,760 --> 00:21:16,240
istream and use that

00:21:13,679 --> 00:21:17,440
as the input to the scanner this is

00:21:16,240 --> 00:21:18,799
something that

00:21:17,440 --> 00:21:21,840
in the testing language is called

00:21:18,799 --> 00:21:25,360
dependency injection sometimes it's

00:21:21,840 --> 00:21:26,480
uh rather than building the scanner to

00:21:25,360 --> 00:21:30,000
assume

00:21:26,480 --> 00:21:31,600
that it uses a particular input stream

00:21:30,000 --> 00:21:33,039
we've built the scanner so that it can

00:21:31,600 --> 00:21:35,679
work in terms of

00:21:33,039 --> 00:21:38,880
any input stream that we that is

00:21:35,679 --> 00:21:42,640
provided by the creator of the scanner

00:21:38,880 --> 00:21:44,400
and then uh and this is something that

00:21:42,640 --> 00:21:45,440
generally makes things a lot easier to

00:21:44,400 --> 00:21:47,760
test because

00:21:45,440 --> 00:21:49,039
the scanner isn't making unnecessary

00:21:47,760 --> 00:21:51,600
assumptions about

00:21:49,039 --> 00:21:52,480
what other pieces of the code have to be

00:21:51,600 --> 00:21:56,000
there

00:21:52,480 --> 00:22:00,080
to make everything work

00:21:56,000 --> 00:22:02,080
so if to create our empty input stream

00:22:00,080 --> 00:22:04,559
uh we're going to use the i string

00:22:02,080 --> 00:22:08,159
stream uh

00:22:04,559 --> 00:22:11,120
type from the s from the stream header

00:22:08,159 --> 00:22:12,000
and so we can what this lets us do is

00:22:11,120 --> 00:22:15,039
just treat

00:22:12,000 --> 00:22:16,240
any string as if it were an input stream

00:22:15,039 --> 00:22:19,120
so if i create an

00:22:16,240 --> 00:22:19,919
an i string stream that looks like this

00:22:19,120 --> 00:22:23,280
with the string

00:22:19,919 --> 00:22:25,440
one two three and then i i can then

00:22:23,280 --> 00:22:26,640
read from that input stream into an

00:22:25,440 --> 00:22:30,559
integer

00:22:26,640 --> 00:22:33,200
and it gets out the value 123.

00:22:30,559 --> 00:22:35,120
so in this case all we need is a string

00:22:33,200 --> 00:22:38,080
stream that takes an empty string

00:22:35,120 --> 00:22:41,280
we'll use that as our empty input for

00:22:38,080 --> 00:22:46,159
the scanner

00:22:41,280 --> 00:22:46,159
um and by the way uh

00:22:46,480 --> 00:22:49,360
one of the interesting things about this

00:22:48,080 --> 00:22:50,159
is that even if you're working on a

00:22:49,360 --> 00:22:53,039
project

00:22:50,159 --> 00:22:54,400
that is that has tight performance

00:22:53,039 --> 00:22:56,240
requirements where you might not

00:22:54,400 --> 00:22:58,559
necessarily want to be using

00:22:56,240 --> 00:22:59,679
streams all over the place or doing a

00:22:58,559 --> 00:23:03,440
lot of work with

00:22:59,679 --> 00:23:06,559
dynamic memory allocation these tests

00:23:03,440 --> 00:23:08,880
are running uh are actually going to run

00:23:06,559 --> 00:23:10,400
in such a way that that performance is

00:23:08,880 --> 00:23:12,880
somewhat less of an issue because

00:23:10,400 --> 00:23:14,159
they're usually not going to be running

00:23:12,880 --> 00:23:16,720
on

00:23:14,159 --> 00:23:17,679
uh on a single computer they're going to

00:23:16,720 --> 00:23:22,000
be running

00:23:17,679 --> 00:23:25,039
uh regularly in the background

00:23:22,000 --> 00:23:27,120
so uh in order to do the reporting of

00:23:25,039 --> 00:23:28,400
the test to report the results

00:23:27,120 --> 00:23:30,960
uh we need to figure out how we're

00:23:28,400 --> 00:23:33,200
actually going to run the test

00:23:30,960 --> 00:23:34,000
and this test is for the scanner not

00:23:33,200 --> 00:23:37,039
really the whole

00:23:34,000 --> 00:23:37,360
decal program so we don't actually have

00:23:37,039 --> 00:23:39,840
to

00:23:37,360 --> 00:23:40,799
use the main function of the decal

00:23:39,840 --> 00:23:44,240
program

00:23:40,799 --> 00:23:44,640
to run the test we can build a different

00:23:44,240 --> 00:23:47,919
main

00:23:44,640 --> 00:23:48,559
function that's specifically designed to

00:23:47,919 --> 00:23:51,679
run this

00:23:48,559 --> 00:23:53,840
test and then from there

00:23:51,679 --> 00:23:55,520
regular old c out is fine as for a

00:23:53,840 --> 00:23:56,640
reporting input before reporting the

00:23:55,520 --> 00:23:58,320
output we can just say

00:23:56,640 --> 00:24:01,360
here is the name of the test that we

00:23:58,320 --> 00:24:04,080
want to run scan empty input

00:24:01,360 --> 00:24:05,679
set that our result will be when we get

00:24:04,080 --> 00:24:08,799
to the end we write out either

00:24:05,679 --> 00:24:09,120
success or failure depending on whether

00:24:08,799 --> 00:24:10,960
we

00:24:09,120 --> 00:24:13,200
saw the token that we were expecting to

00:24:10,960 --> 00:24:13,200
see

00:24:13,520 --> 00:24:18,080
so uh normally i wouldn't actually put

00:24:17,600 --> 00:24:21,200
the test

00:24:18,080 --> 00:24:22,960
directly in main uh and

00:24:21,200 --> 00:24:24,480
as you will see in a little while i'm

00:24:22,960 --> 00:24:27,200
going to extract it

00:24:24,480 --> 00:24:29,440
and you start using helper functions but

00:24:27,200 --> 00:24:32,400
for right now i'm just keeping things

00:24:29,440 --> 00:24:34,240
as simple as possible just to show you

00:24:32,400 --> 00:24:36,720
what you can do with the minimal amount

00:24:34,240 --> 00:24:36,720
of code

00:24:37,200 --> 00:24:41,039
all right so this version of main is in

00:24:39,600 --> 00:24:44,640
its own source file i call

00:24:41,039 --> 00:24:47,919
decal test.cpp so we compile that with

00:24:44,640 --> 00:24:51,440
just scanner.cpp we don't actually need

00:24:47,919 --> 00:24:53,360
the original decal.cpp at all because

00:24:51,440 --> 00:24:55,600
it just contained the parser which we're

00:24:53,360 --> 00:24:57,919
not using and the main program

00:24:55,600 --> 00:24:59,600
which we're not using and when we

00:24:57,919 --> 00:25:02,640
execute this program

00:24:59,600 --> 00:25:03,919
indeed decl test prints out i tried

00:25:02,640 --> 00:25:07,440
running this test

00:25:03,919 --> 00:25:10,799
and it succeeded because

00:25:07,440 --> 00:25:12,159
this is an existing program there's a

00:25:10,799 --> 00:25:16,799
there's a good chance that it may

00:25:12,159 --> 00:25:16,799
actually pass on the first run

00:25:16,880 --> 00:25:20,640
that being the case we're not quite done

00:25:19,600 --> 00:25:24,000
making sure that this

00:25:20,640 --> 00:25:25,760
test works yet because

00:25:24,000 --> 00:25:27,520
test correctness is more that is about

00:25:25,760 --> 00:25:31,360
more than just seeing the test

00:25:27,520 --> 00:25:32,960
pass when we expect it to pass

00:25:31,360 --> 00:25:34,400
we also want to make sure that the test

00:25:32,960 --> 00:25:37,360
will fail

00:25:34,400 --> 00:25:38,960
when we expect it to fail what that

00:25:37,360 --> 00:25:41,919
means is we need to

00:25:38,960 --> 00:25:42,720
now create a scenario in which the test

00:25:41,919 --> 00:25:44,720
fails

00:25:42,720 --> 00:25:47,840
so that we can watch it fail because so

00:25:44,720 --> 00:25:50,080
far we've only seen it succeed

00:25:47,840 --> 00:25:52,400
so there are lots of different ways that

00:25:50,080 --> 00:25:56,640
we could change scanner.cpp

00:25:52,400 --> 00:26:00,240
to make the test fail

00:25:56,640 --> 00:26:02,240
as is often the case uh there can be

00:26:00,240 --> 00:26:05,279
there's often one way to do things right

00:26:02,240 --> 00:26:08,880
and lots of ways that something could go

00:26:05,279 --> 00:26:12,400
wrong uh if you think about

00:26:08,880 --> 00:26:14,960
the human body as a system that if you

00:26:12,400 --> 00:26:16,320
if your heart stops lots of parts of

00:26:14,960 --> 00:26:19,279
your body are going to stop

00:26:16,320 --> 00:26:21,279
working at all about the same time so

00:26:19,279 --> 00:26:23,039
that will represent a

00:26:21,279 --> 00:26:24,559
a failure that could show up in lots of

00:26:23,039 --> 00:26:26,080
places

00:26:24,559 --> 00:26:28,000
ideally we would we just want to make a

00:26:26,080 --> 00:26:30,559
single obvious change

00:26:28,000 --> 00:26:33,520
that will make the test fail because if

00:26:30,559 --> 00:26:36,480
we'd been writing the tests first

00:26:33,520 --> 00:26:38,720
then the test would fail due to a pretty

00:26:36,480 --> 00:26:41,679
obvious gap in the code we haven't

00:26:38,720 --> 00:26:43,120
written anything to make make it succeed

00:26:41,679 --> 00:26:45,840
so

00:26:43,120 --> 00:26:46,880
that's a pretty obvious failure case

00:26:45,840 --> 00:26:48,080
right there

00:26:46,880 --> 00:26:50,559
there's nothing wrong with doing

00:26:48,080 --> 00:26:51,279
something similar to go when we're going

00:26:50,559 --> 00:26:53,840
back and

00:26:51,279 --> 00:26:54,799
falsifying the test later on i've heard

00:26:53,840 --> 00:26:58,559
this referred to as

00:26:54,799 --> 00:27:01,840
falsifying the test um

00:26:58,559 --> 00:27:02,960
that's i don't know how widespread that

00:27:01,840 --> 00:27:04,960
term is

00:27:02,960 --> 00:27:06,080
that's just what i've seen used and it

00:27:04,960 --> 00:27:09,120
seemed like a

00:27:06,080 --> 00:27:09,120
handy term here

00:27:11,679 --> 00:27:17,760
okay so the get function for the scanner

00:27:14,559 --> 00:27:21,120
reads each token a character at a time

00:27:17,760 --> 00:27:21,760
if the first character is eof that's how

00:27:21,120 --> 00:27:26,000
we

00:27:21,760 --> 00:27:28,080
know that we have a no more token so

00:27:26,000 --> 00:27:30,080
inside the get function if it sees that

00:27:28,080 --> 00:27:32,960
that character is eof

00:27:30,080 --> 00:27:35,520
it assigns no more as the right category

00:27:32,960 --> 00:27:37,760
for this token

00:27:35,520 --> 00:27:38,799
so if we want to make this test fail we

00:27:37,760 --> 00:27:41,120
need to

00:27:38,799 --> 00:27:43,039
replace that in some way so that we can

00:27:41,120 --> 00:27:46,480
we'll change that code

00:27:43,039 --> 00:27:47,520
replace the value no more with some

00:27:46,480 --> 00:27:49,440
other value value-like

00:27:47,520 --> 00:27:51,360
identifier that represents a different

00:27:49,440 --> 00:27:54,000
kind of token

00:27:51,360 --> 00:27:55,279
and we can go ahead and run our test and

00:27:54,000 --> 00:27:59,200
what we expect to see

00:27:55,279 --> 00:28:01,440
is now the test reports failure

00:27:59,200 --> 00:28:02,320
because it's not indeed it's not

00:28:01,440 --> 00:28:06,240
returning

00:28:02,320 --> 00:28:09,120
the right kind of token on empty input

00:28:06,240 --> 00:28:09,840
now that we've done that this is a

00:28:09,120 --> 00:28:12,080
fairly

00:28:09,840 --> 00:28:14,240
this is a pedantic little change i

00:28:12,080 --> 00:28:18,080
realize that this i've made it kind of

00:28:14,240 --> 00:28:20,240
trivial by using a fairly simple test

00:28:18,080 --> 00:28:21,679
in reality it's not always going to be

00:28:20,240 --> 00:28:23,840
that simple

00:28:21,679 --> 00:28:25,120
but this just illustrates the basic idea

00:28:23,840 --> 00:28:26,880
that you want to be

00:28:25,120 --> 00:28:28,960
that you want to know both that your

00:28:26,880 --> 00:28:31,200
test will fit will succeed

00:28:28,960 --> 00:28:32,320
when it's supposed to succeed and that

00:28:31,200 --> 00:28:35,440
it will fail

00:28:32,320 --> 00:28:37,760
when it's supposed to fail

00:28:35,440 --> 00:28:39,279
now that we've done this verification we

00:28:37,760 --> 00:28:44,080
can go go back

00:28:39,279 --> 00:28:45,039
undo this change here and then and

00:28:44,080 --> 00:28:47,760
restore the test

00:28:45,039 --> 00:28:49,039
to passing condition we don't need to

00:28:47,760 --> 00:28:51,440
keep that change

00:28:49,039 --> 00:28:53,440
around and in general we won't need to

00:28:51,440 --> 00:28:55,679
falsify the test again

00:28:53,440 --> 00:28:56,880
unless the code actually changes that is

00:28:55,679 --> 00:28:59,840
the code that runs

00:28:56,880 --> 00:28:59,840
the test itself

00:29:00,240 --> 00:29:05,360
so what do we have well we have a test

00:29:04,320 --> 00:29:08,399
that uses

00:29:05,360 --> 00:29:09,039
no frameworks no libraries the full test

00:29:08,399 --> 00:29:12,080
code

00:29:09,039 --> 00:29:14,880
fits right on this next slide here

00:29:12,080 --> 00:29:14,880
it's just that

00:29:15,200 --> 00:29:20,720
now uh and that code

00:29:18,240 --> 00:29:22,559
does one test but it's actually fairly

00:29:20,720 --> 00:29:23,679
easy to take that and turn it into

00:29:22,559 --> 00:29:26,799
multiple tests

00:29:23,679 --> 00:29:30,720
we can generalize this code

00:29:26,799 --> 00:29:32,720
into something that looks like this

00:29:30,720 --> 00:29:35,760
i've changed it from the main function

00:29:32,720 --> 00:29:38,960
to a helper function called token test

00:29:35,760 --> 00:29:42,159
that takes in the name of a test

00:29:38,960 --> 00:29:44,559
the text of a token and the kind of

00:29:42,159 --> 00:29:47,679
token that we expect to see

00:29:44,559 --> 00:29:48,080
and now instead of printing out a fixed

00:29:47,679 --> 00:29:50,000
name

00:29:48,080 --> 00:29:51,600
scan empty input it always prints out

00:29:50,000 --> 00:29:52,880
the test name it prints out the test

00:29:51,600 --> 00:29:55,440
name

00:29:52,880 --> 00:29:57,760
it creates as the input whatever text

00:29:55,440 --> 00:30:00,240
string it was given rather than

00:29:57,760 --> 00:30:01,760
just the empty string and it compares

00:30:00,240 --> 00:30:04,559
the category to

00:30:01,760 --> 00:30:07,360
whatever kind of category was specified

00:30:04,559 --> 00:30:09,279
and now we have a nice simple function

00:30:07,360 --> 00:30:10,799
for testing how the scanner can deal

00:30:09,279 --> 00:30:14,080
with pretty much

00:30:10,799 --> 00:30:17,120
any single token input

00:30:14,080 --> 00:30:20,159
and i find this is not uncommon where

00:30:17,120 --> 00:30:22,799
having written one test that test turns

00:30:20,159 --> 00:30:23,120
out to serve as a model for a number of

00:30:22,799 --> 00:30:25,840
other

00:30:23,120 --> 00:30:27,200
tests that's something that can happen

00:30:25,840 --> 00:30:30,399
fairly frequently

00:30:27,200 --> 00:30:32,159
so it can feel sometimes like you're

00:30:30,399 --> 00:30:35,039
investing a lot of work in

00:30:32,159 --> 00:30:37,440
in creating just one test but then when

00:30:35,039 --> 00:30:39,600
you get to the end

00:30:37,440 --> 00:30:40,480
you see okay now this one test can

00:30:39,600 --> 00:30:43,279
easily become

00:30:40,480 --> 00:30:45,440
five tests without too much additional

00:30:43,279 --> 00:30:49,279
work

00:30:45,440 --> 00:30:50,320
now if i was going to have a full set

00:30:49,279 --> 00:30:52,640
suite of tests

00:30:50,320 --> 00:30:53,840
for the scanner i'd also want to include

00:30:52,640 --> 00:30:56,000
some tests of

00:30:53,840 --> 00:30:56,960
multi-token input i'm not showing that

00:30:56,000 --> 00:31:00,559
here

00:30:56,960 --> 00:31:02,480
but a real full test of the scanner

00:31:00,559 --> 00:31:05,120
should also be looking at whether the

00:31:02,480 --> 00:31:07,760
scanner works correctly

00:31:05,120 --> 00:31:09,279
when dealing with input consisting of

00:31:07,760 --> 00:31:12,080
multiple tokens

00:31:09,279 --> 00:31:13,840
but what we've got so far is a pretty

00:31:12,080 --> 00:31:14,799
good start for how much work we've had

00:31:13,840 --> 00:31:19,120
to put in

00:31:14,799 --> 00:31:21,440
to make it if these tests pass

00:31:19,120 --> 00:31:22,880
it's a fairly good indication that the

00:31:21,440 --> 00:31:26,000
scanner is handling

00:31:22,880 --> 00:31:28,080
individual tokens correctly it's not an

00:31:26,000 --> 00:31:30,399
absolute certainty

00:31:28,080 --> 00:31:32,000
but in some sense that we're not looking

00:31:30,399 --> 00:31:34,559
for absolute certainties

00:31:32,000 --> 00:31:38,080
out of our automated tests one of the

00:31:34,559 --> 00:31:40,320
ways i like to think about it is

00:31:38,080 --> 00:31:42,240
you're writing the tests not because

00:31:40,320 --> 00:31:44,960
you'll the tests will catch

00:31:42,240 --> 00:31:46,880
all of the bugs that you might get but

00:31:44,960 --> 00:31:49,840
rather it changes the way you

00:31:46,880 --> 00:31:50,880
think about debugging now the question

00:31:49,840 --> 00:31:52,799
become

00:31:50,880 --> 00:31:55,279
when i see that a bunch of tests are

00:31:52,799 --> 00:31:58,840
passing if i notice a failure

00:31:55,279 --> 00:32:01,760
in the code then i can ask myself

00:31:58,840 --> 00:32:03,600
okay given that i know that all of this

00:32:01,760 --> 00:32:07,120
stuff works

00:32:03,600 --> 00:32:09,279
where could the pros problem possibly be

00:32:07,120 --> 00:32:10,880
how is it that all of these tests could

00:32:09,279 --> 00:32:13,919
say everything is fine

00:32:10,880 --> 00:32:16,159
and i still see this problem over here

00:32:13,919 --> 00:32:17,360
changes the mentality that you use to

00:32:16,159 --> 00:32:20,720
look for

00:32:17,360 --> 00:32:22,480
the sources of defects so in this case

00:32:20,720 --> 00:32:23,519
we'll be able to focus our debugging

00:32:22,480 --> 00:32:25,919
efforts on

00:32:23,519 --> 00:32:27,679
the parser we haven't tested that yet so

00:32:25,919 --> 00:32:29,679
the problem could be there

00:32:27,679 --> 00:32:31,519
or it's possible that the scanner has

00:32:29,679 --> 00:32:34,559
some leftover state

00:32:31,519 --> 00:32:37,760
information in it after reading a token

00:32:34,559 --> 00:32:40,640
and that that in for multi-token input

00:32:37,760 --> 00:32:43,519
because we haven't tested that yet

00:32:40,640 --> 00:32:45,120
that's that might be a thing that throws

00:32:43,519 --> 00:32:48,960
off

00:32:45,120 --> 00:32:52,480
uh the deco program but

00:32:48,960 --> 00:32:55,360
for what we've got that's not a bad

00:32:52,480 --> 00:32:56,320
a bad start we've got you know we've

00:32:55,360 --> 00:32:59,919
eliminated

00:32:56,320 --> 00:33:04,080
a fairly sizable chunk of the code

00:32:59,919 --> 00:33:06,559
as a as a likely culprit for

00:33:04,080 --> 00:33:08,720
a lot of failures and we didn't have to

00:33:06,559 --> 00:33:10,880
spend that much time

00:33:08,720 --> 00:33:12,880
writing these tests we didn't have to

00:33:10,880 --> 00:33:15,919
investigate using a framework

00:33:12,880 --> 00:33:18,399
or uh

00:33:15,919 --> 00:33:20,159
come up with how we were going to do a

00:33:18,399 --> 00:33:21,039
lot of work to integrate with a build

00:33:20,159 --> 00:33:24,720
system

00:33:21,039 --> 00:33:25,760
it's just uh and so these tests don't

00:33:24,720 --> 00:33:27,519
need to take

00:33:25,760 --> 00:33:30,159
that much they don't need to save us

00:33:27,519 --> 00:33:33,200
that much debugging time before they

00:33:30,159 --> 00:33:36,080
pay for themselves a good question

00:33:33,200 --> 00:33:36,559
how about testing private functions

00:33:36,080 --> 00:33:39,440
these

00:33:36,559 --> 00:33:39,919
private tests seem convenient since you

00:33:39,440 --> 00:33:43,120
can't

00:33:39,919 --> 00:33:43,440
typically test for corner case inputs to

00:33:43,120 --> 00:33:46,480
the

00:33:43,440 --> 00:33:48,640
internal function by using the public

00:33:46,480 --> 00:33:52,480
interface

00:33:48,640 --> 00:33:56,399
yes um

00:33:52,480 --> 00:33:56,399
in general uh

00:33:56,799 --> 00:34:01,120
you the private functions uh

00:33:59,919 --> 00:34:03,279
are meant to be part of your

00:34:01,120 --> 00:34:06,640
implementation you want to

00:34:03,279 --> 00:34:07,919
focus your testing efforts on the public

00:34:06,640 --> 00:34:11,760
interface

00:34:07,919 --> 00:34:13,599
of a class because

00:34:11,760 --> 00:34:16,560
it's the public interface that's going

00:34:13,599 --> 00:34:18,720
to be used in lots of different places

00:34:16,560 --> 00:34:20,000
the private interface should be used in

00:34:18,720 --> 00:34:23,119
a relatively small

00:34:20,000 --> 00:34:25,839
number of different places and you want

00:34:23,119 --> 00:34:27,919
to have a little more freedom to change

00:34:25,839 --> 00:34:28,879
the private interface to change the

00:34:27,919 --> 00:34:31,919
implementation

00:34:28,879 --> 00:34:35,520
behind the scenes in order to

00:34:31,919 --> 00:34:38,159
deal with new situations that arise

00:34:35,520 --> 00:34:40,480
once i've written these tests i may go

00:34:38,159 --> 00:34:43,760
back and modify the scanner

00:34:40,480 --> 00:34:45,599
to do to be able to recognize additional

00:34:43,760 --> 00:34:48,720
kinds of tokens or

00:34:45,599 --> 00:34:50,560
to be able to look ahead by a certain

00:34:48,720 --> 00:34:52,960
number of tokens

00:34:50,560 --> 00:34:57,040
and that could involve a lot of changes

00:34:52,960 --> 00:34:57,040
to the private details of the scanner

00:34:57,440 --> 00:35:01,359
i want my tests to focus on the public

00:34:59,760 --> 00:35:03,280
interface because

00:35:01,359 --> 00:35:05,599
what that tells me is that if all of

00:35:03,280 --> 00:35:08,880
those tests are passing

00:35:05,599 --> 00:35:10,480
i know that i've managed to update what

00:35:08,880 --> 00:35:13,040
the scanner is doing

00:35:10,480 --> 00:35:14,480
without breaking any of those existing

00:35:13,040 --> 00:35:17,440
tests

00:35:14,480 --> 00:35:18,720
now i don't want to be too absolutist

00:35:17,440 --> 00:35:21,359
about this as

00:35:18,720 --> 00:35:21,359
sometimes

00:35:21,920 --> 00:35:25,280
particularly if you're trying to

00:35:23,200 --> 00:35:28,800
introduce

00:35:25,280 --> 00:35:31,599
testing into code that has legacy

00:35:28,800 --> 00:35:33,520
behavior in it uh that has legacy

00:35:31,599 --> 00:35:36,400
untested code in it yes

00:35:33,520 --> 00:35:37,040
you may find that there are some private

00:35:36,400 --> 00:35:39,040
functions

00:35:37,040 --> 00:35:42,320
that are used in enough places that it

00:35:39,040 --> 00:35:42,320
makes sense to test them

00:35:42,400 --> 00:35:48,560
but in general we want to

00:35:45,440 --> 00:35:51,920
focus on the public interfaces as

00:35:48,560 --> 00:35:55,599
the main testing that we do

00:35:51,920 --> 00:35:57,440
um and we want to write enough tests of

00:35:55,599 --> 00:36:00,000
the public interface

00:35:57,440 --> 00:36:01,280
that it also exists exercises our

00:36:00,000 --> 00:36:05,599
private interface

00:36:01,280 --> 00:36:05,599
in whatever ways we need to

00:36:06,400 --> 00:36:11,119
okay so up to this point we haven't used

00:36:10,320 --> 00:36:13,680
any kind of

00:36:11,119 --> 00:36:15,280
unit testing framework just this is just

00:36:13,680 --> 00:36:15,839
done to keep the work as simple as

00:36:15,280 --> 00:36:18,400
possible

00:36:15,839 --> 00:36:19,839
see what kind of benefits we can get

00:36:18,400 --> 00:36:22,800
without

00:36:19,839 --> 00:36:24,400
with a minimal amount of effort so now

00:36:22,800 --> 00:36:27,599
let's look at

00:36:24,400 --> 00:36:30,240
if we add on the work of do

00:36:27,599 --> 00:36:31,920
of adding in a framework what will that

00:36:30,240 --> 00:36:34,079
get us

00:36:31,920 --> 00:36:35,760
just the basic stuff with a framework

00:36:34,079 --> 00:36:37,760
i'm trying to use

00:36:35,760 --> 00:36:40,560
a relatively small amount of the

00:36:37,760 --> 00:36:42,480
framework here and just show

00:36:40,560 --> 00:36:44,320
just what just taking the first step

00:36:42,480 --> 00:36:47,760
into using a framework

00:36:44,320 --> 00:36:50,240
what sort of benefits do we see and

00:36:47,760 --> 00:36:51,040
what does what other steps does that set

00:36:50,240 --> 00:36:53,760
us up for

00:36:51,040 --> 00:36:55,359
in the future again we don't want to try

00:36:53,760 --> 00:36:58,480
and go all thousand miles

00:36:55,359 --> 00:37:00,960
at once so in this case i've chosen to

00:36:58,480 --> 00:37:03,119
use google test as the framework

00:37:00,960 --> 00:37:04,400
uh now different frameworks are going to

00:37:03,119 --> 00:37:07,520
offer different

00:37:04,400 --> 00:37:08,960
features so

00:37:07,520 --> 00:37:11,440
the features that i'm presenting here

00:37:08,960 --> 00:37:13,359
aren't necessarily universal

00:37:11,440 --> 00:37:14,640
you may not find them in every testing

00:37:13,359 --> 00:37:16,480
framework but

00:37:14,640 --> 00:37:18,079
they're not they're certainly not unique

00:37:16,480 --> 00:37:19,760
to google test

00:37:18,079 --> 00:37:22,240
you can find them in lots of just

00:37:19,760 --> 00:37:24,320
different testing frameworks but

00:37:22,240 --> 00:37:25,920
in general just think of the stuff that

00:37:24,320 --> 00:37:27,680
i'm showing you here as

00:37:25,920 --> 00:37:29,359
a little bit more of a taste of what a

00:37:27,680 --> 00:37:32,320
framework can offer

00:37:29,359 --> 00:37:33,520
rather than it will specifically be able

00:37:32,320 --> 00:37:37,280
to do this and this

00:37:33,520 --> 00:37:40,880
and this

00:37:37,280 --> 00:37:43,280
so earlier without using a framework we

00:37:40,880 --> 00:37:44,480
created a separate main program to run

00:37:43,280 --> 00:37:48,000
our tests

00:37:44,480 --> 00:37:50,800
and google test does something similar

00:37:48,000 --> 00:37:51,520
in fact it actually includes a main

00:37:50,800 --> 00:37:54,960
function that's

00:37:51,520 --> 00:37:56,240
pre-written and you can link it in as a

00:37:54,960 --> 00:37:58,160
library

00:37:56,240 --> 00:37:59,599
to build your test code you probably

00:37:58,160 --> 00:38:00,079
don't even need to write the main

00:37:59,599 --> 00:38:02,640
function

00:38:00,079 --> 00:38:02,640
yourself

00:38:03,280 --> 00:38:09,520
so uh google test is distributed through

00:38:06,480 --> 00:38:11,839
github at this address uh

00:38:09,520 --> 00:38:13,440
officially the build system that it uses

00:38:11,839 --> 00:38:16,400
is bazel

00:38:13,440 --> 00:38:18,400
there's also cmake support provided on a

00:38:16,400 --> 00:38:20,079
community basis

00:38:18,400 --> 00:38:21,839
it's unofficial they don't promise that

00:38:20,079 --> 00:38:26,480
they won't break it

00:38:21,839 --> 00:38:26,480
but it's generally pretty good

00:38:27,760 --> 00:38:32,000
now exactly how you integrate your

00:38:31,200 --> 00:38:34,800
framework like

00:38:32,000 --> 00:38:35,440
google test into your build is going to

00:38:34,800 --> 00:38:38,800
depend

00:38:35,440 --> 00:38:40,960
somewhat on the details of your project

00:38:38,800 --> 00:38:42,160
but it doesn't have to be particularly

00:38:40,960 --> 00:38:44,880
complicated

00:38:42,160 --> 00:38:46,160
google test does build as just simple

00:38:44,880 --> 00:38:49,040
libraries

00:38:46,160 --> 00:38:51,040
like the uh these two specifically the

00:38:49,040 --> 00:38:52,960
all of the main testing facilities go in

00:38:51,040 --> 00:38:55,520
with g-test.a

00:38:52,960 --> 00:38:56,720
and then the separate main program for

00:38:55,520 --> 00:38:58,880
executing the tests

00:38:56,720 --> 00:39:00,160
if you want to link that in has its own

00:38:58,880 --> 00:39:01,520
library

00:39:00,160 --> 00:39:03,760
and then you can just link them into

00:39:01,520 --> 00:39:08,560
your project the same way that you would

00:39:03,760 --> 00:39:11,599
any other libraries and

00:39:08,560 --> 00:39:14,720
you can go ahead and use google test

00:39:11,599 --> 00:39:16,960
you may want to integrate it more deeply

00:39:14,720 --> 00:39:20,079
with your build system but may

00:39:16,960 --> 00:39:23,359
call out to its cmake files from your

00:39:20,079 --> 00:39:25,599
own cmake system for example

00:39:23,359 --> 00:39:26,640
but you don't necessarily have to there

00:39:25,599 --> 00:39:28,960
are

00:39:26,640 --> 00:39:30,880
ways of doing things fairly simply other

00:39:28,960 --> 00:39:33,680
frameworks in some cases are just

00:39:30,880 --> 00:39:34,800
are header only um there are ones that

00:39:33,680 --> 00:39:37,599
just

00:39:34,800 --> 00:39:38,160
basically just include the headers and

00:39:37,599 --> 00:39:42,160
you

00:39:38,160 --> 00:39:45,119
go from there so

00:39:42,160 --> 00:39:46,960
earlier the first test that we wrote was

00:39:45,119 --> 00:39:49,359
start with empty input

00:39:46,960 --> 00:39:50,000
check to see that the scanner gives us a

00:39:49,359 --> 00:39:54,400
token

00:39:50,000 --> 00:39:57,520
that says category no more

00:39:54,400 --> 00:39:59,839
so if we take that test and move it into

00:39:57,520 --> 00:40:01,200
the google test framework it's going to

00:39:59,839 --> 00:40:03,760
look something like

00:40:01,200 --> 00:40:05,200
this and here's what the different

00:40:03,760 --> 00:40:08,880
pieces of this

00:40:05,200 --> 00:40:10,960
are doing so each test

00:40:08,880 --> 00:40:13,839
has a name that consists of two parts

00:40:10,960 --> 00:40:16,640
the test here capital t-e-s-t

00:40:13,839 --> 00:40:19,119
is just a macro that assembles a

00:40:16,640 --> 00:40:21,040
function for running your test

00:40:19,119 --> 00:40:23,040
and it asse it names that function

00:40:21,040 --> 00:40:24,480
essentially based on these two pieces

00:40:23,040 --> 00:40:27,200
here

00:40:24,480 --> 00:40:27,920
the first part scanner here is the name

00:40:27,200 --> 00:40:30,560
of a

00:40:27,920 --> 00:40:32,160
test suite as we call it a group of

00:40:30,560 --> 00:40:34,000
related tests

00:40:32,160 --> 00:40:36,000
in this case they're the tests for the

00:40:34,000 --> 00:40:38,880
scanner class

00:40:36,000 --> 00:40:40,319
by the way traditionally i i've seen

00:40:38,880 --> 00:40:43,680
these two

00:40:40,319 --> 00:40:47,520
uh these names using

00:40:43,680 --> 00:40:48,560
capital camel case uh that seems to be a

00:40:47,520 --> 00:40:53,280
convention

00:40:48,560 --> 00:40:57,359
it's not it's not a requirement um

00:40:53,280 --> 00:40:57,760
well it is it is doing google test is

00:40:57,359 --> 00:40:59,440
doing

00:40:57,760 --> 00:41:01,280
some work behind the scenes so there is

00:40:59,440 --> 00:41:03,839
some there are some restrictions

00:41:01,280 --> 00:41:06,319
on how creative you can get with these

00:41:03,839 --> 00:41:10,640
names though

00:41:06,319 --> 00:41:14,160
uh so empty empty input token is no more

00:41:10,640 --> 00:41:14,960
is that is empty input the token is no

00:41:14,160 --> 00:41:16,800
more

00:41:14,960 --> 00:41:18,839
is the name of a specific test within

00:41:16,800 --> 00:41:20,640
that test suite that we're about to

00:41:18,839 --> 00:41:23,119
write

00:41:20,640 --> 00:41:25,599
the code for running the test goes

00:41:23,119 --> 00:41:27,040
inside the curly braces and

00:41:25,599 --> 00:41:29,119
the first part of it looks pretty

00:41:27,040 --> 00:41:31,119
similar to the way the code looked in

00:41:29,119 --> 00:41:34,480
the original version

00:41:31,119 --> 00:41:37,440
excuse me um the only difference is

00:41:34,480 --> 00:41:38,319
we don't have to write out this the name

00:41:37,440 --> 00:41:40,240
of the test

00:41:38,319 --> 00:41:41,680
itself because google test will take

00:41:40,240 --> 00:41:43,920
care of that for us

00:41:41,680 --> 00:41:45,680
but otherwise we're still setting up an

00:41:43,920 --> 00:41:46,560
i string stream that represents our

00:41:45,680 --> 00:41:48,880
empty input

00:41:46,560 --> 00:41:51,839
passing that to a scanner using that

00:41:48,880 --> 00:41:54,800
scanner to read a token

00:41:51,839 --> 00:41:55,920
the part for reporting output looks

00:41:54,800 --> 00:41:58,000
fairly different

00:41:55,920 --> 00:41:59,119
before we had this where we wrote an if

00:41:58,000 --> 00:42:01,040
statement and then

00:41:59,119 --> 00:42:02,640
manually printed out something to see

00:42:01,040 --> 00:42:06,240
out

00:42:02,640 --> 00:42:09,520
in google test it looks just like this

00:42:06,240 --> 00:42:11,599
there's another macro expect eq

00:42:09,520 --> 00:42:13,359
that takes two values and what this is

00:42:11,599 --> 00:42:15,680
saying is

00:42:13,359 --> 00:42:17,040
we're informing google test that we

00:42:15,680 --> 00:42:20,880
expect these two

00:42:17,040 --> 00:42:23,440
values to compare equal to each other

00:42:20,880 --> 00:42:24,640
in this case you know it's doing it's

00:42:23,440 --> 00:42:28,240
testing that

00:42:24,640 --> 00:42:32,720
t dot kind is equal equal token dot

00:42:28,240 --> 00:42:35,760
or colon no more and what this means is

00:42:32,720 --> 00:42:37,599
if that condition isn't true

00:42:35,760 --> 00:42:39,520
google test knows that the test has

00:42:37,599 --> 00:42:42,079
failed and it should report

00:42:39,520 --> 00:42:44,400
failure when it prints out the output of

00:42:42,079 --> 00:42:47,200
the test

00:42:44,400 --> 00:42:48,400
so when you run the test if it passes

00:42:47,200 --> 00:42:51,760
the output is going to look

00:42:48,400 --> 00:42:53,680
something like this it'll say

00:42:51,760 --> 00:42:55,280
right now we only have one test suite

00:42:53,680 --> 00:42:57,760
with one test in it

00:42:55,280 --> 00:42:59,839
so it will talk about it's running a

00:42:57,760 --> 00:43:02,160
single test from the scanner suite

00:42:59,839 --> 00:43:03,359
that tested scanner empty token is no

00:43:02,160 --> 00:43:07,760
more

00:43:03,359 --> 00:43:10,880
uh and it ran and it passed

00:43:07,760 --> 00:43:11,680
if it had failed the output would

00:43:10,880 --> 00:43:14,480
include

00:43:11,680 --> 00:43:15,680
the the real results of the comparison

00:43:14,480 --> 00:43:18,240
that is

00:43:15,680 --> 00:43:19,440
it tells us what the two values that

00:43:18,240 --> 00:43:23,599
were being compared

00:43:19,440 --> 00:43:27,280
actually were which gives us a sense of

00:43:23,599 --> 00:43:29,680
a little bit more insight into okay uh

00:43:27,280 --> 00:43:30,960
what might actually be going wrong i may

00:43:29,680 --> 00:43:32,880
not need to

00:43:30,960 --> 00:43:34,480
go into the code modify it to have some

00:43:32,880 --> 00:43:35,280
output statements and things like that i

00:43:34,480 --> 00:43:37,280
might

00:43:35,280 --> 00:43:39,599
be able to figure it out just from this

00:43:37,280 --> 00:43:42,160
message

00:43:39,599 --> 00:43:44,240
the failure would look something like

00:43:42,160 --> 00:43:47,520
this

00:43:44,240 --> 00:43:50,079
and again this one test can be

00:43:47,520 --> 00:43:51,280
we can expand that using it as a model

00:43:50,079 --> 00:43:54,640
for others

00:43:51,280 --> 00:43:57,200
turn that into a whole bunch of tests so

00:43:54,640 --> 00:43:58,240
that we would call the test macro

00:43:57,200 --> 00:44:00,400
separately for

00:43:58,240 --> 00:44:02,640
each individual test because that's what

00:44:00,400 --> 00:44:06,480
assigns the

00:44:02,640 --> 00:44:06,480
that's what assigns a name to the test

00:44:07,119 --> 00:44:10,800
and that but the expectation macros

00:44:09,359 --> 00:44:12,960
things like expect eq

00:44:10,800 --> 00:44:14,319
and then there are others like expect

00:44:12,960 --> 00:44:18,000
any e for

00:44:14,319 --> 00:44:20,319
not equals expect uh lt for less than

00:44:18,000 --> 00:44:22,000
so forth and so on those work from

00:44:20,319 --> 00:44:24,800
inside other function calls

00:44:22,000 --> 00:44:26,000
they don't have to be directly within

00:44:24,800 --> 00:44:29,440
the curly braces

00:44:26,000 --> 00:44:31,520
after a test macro so

00:44:29,440 --> 00:44:32,880
we can put that code into a helper

00:44:31,520 --> 00:44:34,400
function

00:44:32,880 --> 00:44:36,160
and do something very similar to the

00:44:34,400 --> 00:44:38,480
token test function that we wrote

00:44:36,160 --> 00:44:41,359
earlier

00:44:38,480 --> 00:44:42,560
uh that lets us generalize this test

00:44:41,359 --> 00:44:44,640
into just

00:44:42,560 --> 00:44:46,800
take in a certain amount a certain text

00:44:44,640 --> 00:44:50,319
as input build the scanner

00:44:46,800 --> 00:44:53,359
read the token we expect it to be

00:44:50,319 --> 00:44:57,119
some particular category of token

00:44:53,359 --> 00:45:01,200
and now it's and now we have

00:44:57,119 --> 00:45:01,200
that one test has become three tests

00:45:01,680 --> 00:45:05,839
and the output looks something like this

00:45:03,839 --> 00:45:09,040
it's now indicating that all three tests

00:45:05,839 --> 00:45:10,560
are in the scanner test suite

00:45:09,040 --> 00:45:14,079
so they're automatically grouped

00:45:10,560 --> 00:45:15,920
together in the output

00:45:14,079 --> 00:45:18,319
and it just tells us the results from

00:45:15,920 --> 00:45:20,880
that whole test suite

00:45:18,319 --> 00:45:20,880
at once

00:45:21,359 --> 00:45:25,440
now we can also filter depth this down

00:45:23,920 --> 00:45:28,720
so if we only wanted to

00:45:25,440 --> 00:45:30,800
run a specific test like the empty input

00:45:28,720 --> 00:45:34,160
token is no more test

00:45:30,800 --> 00:45:36,720
we could use apply a filter to the

00:45:34,160 --> 00:45:36,720
program

00:45:40,720 --> 00:45:42,880
the

00:45:45,520 --> 00:45:52,160
and that will that tells it only

00:45:49,119 --> 00:45:53,520
tests that match this pattern

00:45:52,160 --> 00:45:56,240
which in this case is just a literal

00:45:53,520 --> 00:45:58,319
string should be run

00:45:56,240 --> 00:46:00,160
this time that we run the decal test

00:45:58,319 --> 00:46:03,280
program which is the name of our

00:46:00,160 --> 00:46:05,280
test program the question would

00:46:03,280 --> 00:46:07,119
would you recommend using google test

00:46:05,280 --> 00:46:09,920
over other frameworks

00:46:07,119 --> 00:46:11,839
for simple projects very complex ones

00:46:09,920 --> 00:46:14,720
what do i think

00:46:11,839 --> 00:46:16,720
google test is a framework that i have a

00:46:14,720 --> 00:46:20,000
fair bit of experience with

00:46:16,720 --> 00:46:20,720
it's also a fairly widely used framework

00:46:20,000 --> 00:46:23,200
so that's

00:46:20,720 --> 00:46:25,440
that's why i picked it for this

00:46:23,200 --> 00:46:29,040
particular

00:46:25,440 --> 00:46:31,520
uh talk was because it

00:46:29,040 --> 00:46:33,440
it's fairly widely used you can use a

00:46:31,520 --> 00:46:35,440
fairly small amount of it

00:46:33,440 --> 00:46:37,440
and still get some significant benefits

00:46:35,440 --> 00:46:40,480
out of it

00:46:37,440 --> 00:46:43,599
uh and there are

00:46:40,480 --> 00:46:47,520
it builds nicely into some next steps

00:46:43,599 --> 00:46:48,400
that are uh that go beyond this one

00:46:47,520 --> 00:46:51,440
section where we

00:46:48,400 --> 00:46:55,200
you'd start building into google moc

00:46:51,440 --> 00:46:55,599
and using that as the as the foundation

00:46:55,200 --> 00:46:59,119
for

00:46:55,599 --> 00:47:02,240
more advanced testing facilities

00:46:59,119 --> 00:47:04,880
um so i think it works well i've

00:47:02,240 --> 00:47:07,359
had good experiences with it it's not

00:47:04,880 --> 00:47:11,440
the only test framework i've used

00:47:07,359 --> 00:47:14,560
um i mentioned at the start i do

00:47:11,440 --> 00:47:17,920
uh i also do training in

00:47:14,560 --> 00:47:21,920
plane c google test is specifically a c

00:47:17,920 --> 00:47:25,520
plus framework uh when i

00:47:21,920 --> 00:47:26,160
so when i wrote my c programs i went and

00:47:25,520 --> 00:47:29,119
i found a

00:47:26,160 --> 00:47:31,119
a very simple little test framework

00:47:29,119 --> 00:47:36,160
called

00:47:31,119 --> 00:47:39,920
c test s-e-a-t-e-s-t

00:47:36,160 --> 00:47:42,720
um i'll put it in the uh

00:47:39,920 --> 00:47:44,960
i'll put it in here and it can be copied

00:47:42,720 --> 00:47:49,200
over to the chat

00:47:44,960 --> 00:47:52,400
um the

00:47:49,200 --> 00:47:54,319
uh and that's a very simple framework uh

00:47:52,400 --> 00:47:56,800
very minimal but it was something i

00:47:54,319 --> 00:47:59,359
could get up up and running quickly

00:47:56,800 --> 00:48:01,200
uh which is what i wanted in when i

00:47:59,359 --> 00:48:03,119
wanted it

00:48:01,200 --> 00:48:04,480
i think that different frameworks have

00:48:03,119 --> 00:48:07,200
different advantages

00:48:04,480 --> 00:48:08,079
um so which one is right for you is

00:48:07,200 --> 00:48:11,359
going to depend

00:48:08,079 --> 00:48:14,400
on the nature of your project

00:48:11,359 --> 00:48:14,800
how many people you expect to use it uh

00:48:14,400 --> 00:48:16,240
how

00:48:14,800 --> 00:48:18,480
quickly you think that you're that the

00:48:16,240 --> 00:48:20,640
number of tests might grow

00:48:18,480 --> 00:48:21,920
uh if you think that you're that if

00:48:20,640 --> 00:48:24,000
you're not really sure and you're just

00:48:21,920 --> 00:48:25,599
tiptoeing into automated testing

00:48:24,000 --> 00:48:27,200
probably get away with a fairly simple

00:48:25,599 --> 00:48:28,960
framework if you're

00:48:27,200 --> 00:48:32,240
if at this point you're fairly convinced

00:48:28,960 --> 00:48:34,880
that yeah this is something i want to do

00:48:32,240 --> 00:48:35,359
i'd like a framework that gives me some

00:48:34,880 --> 00:48:37,359
uh

00:48:35,359 --> 00:48:41,200
some good potential for growth maybe you

00:48:37,359 --> 00:48:44,400
want to use a more advanced one

00:48:41,200 --> 00:48:46,960
um so i've had good results with google

00:48:44,400 --> 00:48:48,720
test but it's certainly not the only one

00:48:46,960 --> 00:48:50,079
that you can use and in fact i'll

00:48:48,720 --> 00:48:53,280
mention a feature

00:48:50,079 --> 00:48:55,040
later on that uh

00:48:53,280 --> 00:48:56,640
that some other test frameworks have

00:48:55,040 --> 00:49:03,839
that google test

00:48:56,640 --> 00:49:03,839
uh from my understanding does not

00:49:05,359 --> 00:49:09,680
okay you can also filter using wild

00:49:09,040 --> 00:49:12,559
cards

00:49:09,680 --> 00:49:13,359
so here i can run all the tests in the

00:49:12,559 --> 00:49:16,119
scanner

00:49:13,359 --> 00:49:18,240
test suite but by just saying

00:49:16,119 --> 00:49:20,559
scanner.star

00:49:18,240 --> 00:49:21,440
and now that runs all the tests in that

00:49:20,559 --> 00:49:24,079
test suite

00:49:21,440 --> 00:49:24,720
doesn't run any tests in any other test

00:49:24,079 --> 00:49:26,559
suites

00:49:24,720 --> 00:49:29,680
if we have them in this case i just have

00:49:26,559 --> 00:49:31,280
the one but

00:49:29,680 --> 00:49:33,920
you can use this filtering for that

00:49:31,280 --> 00:49:35,839
purpose so

00:49:33,920 --> 00:49:37,520
up till now we've only been testing the

00:49:35,839 --> 00:49:38,480
category of the token we've been

00:49:37,520 --> 00:49:41,119
ignoring

00:49:38,480 --> 00:49:42,960
the text part of the token we've just

00:49:41,119 --> 00:49:45,680
been assuming that if the category is

00:49:42,960 --> 00:49:47,359
right the text that the token contains

00:49:45,680 --> 00:49:49,839
is also correct

00:49:47,359 --> 00:49:51,839
ideally we'd test both and we would

00:49:49,839 --> 00:49:55,839
report if either one of them had

00:49:51,839 --> 00:49:58,400
an unexpected value as a result

00:49:55,839 --> 00:50:00,240
now back in our original test when we

00:49:58,400 --> 00:50:02,480
weren't using a framework

00:50:00,240 --> 00:50:06,000
we need to do a fair bit of work to

00:50:02,480 --> 00:50:08,240
expand the output code here we need to

00:50:06,000 --> 00:50:10,559
have separate tests for each of the two

00:50:08,240 --> 00:50:12,319
different ways that the test could fail

00:50:10,559 --> 00:50:15,119
we need to write out different error

00:50:12,319 --> 00:50:18,079
messages for

00:50:15,119 --> 00:50:20,559
each of those different possible

00:50:18,079 --> 00:50:20,559
failures

00:50:24,319 --> 00:50:29,040
using google test or most other

00:50:27,599 --> 00:50:33,280
frameworks as well

00:50:29,040 --> 00:50:37,520
uh it's fairly easy to add an extra

00:50:33,280 --> 00:50:38,960
uh an extra expectation like this into

00:50:37,520 --> 00:50:42,079
the same test

00:50:38,960 --> 00:50:45,119
so now this test makes sure that both

00:50:42,079 --> 00:50:47,839
the category and the text

00:50:45,119 --> 00:50:48,800
are matching what we expect them to

00:50:47,839 --> 00:50:50,559
match

00:50:48,800 --> 00:50:52,319
i'll get to your question in just a

00:50:50,559 --> 00:50:55,920
moment um

00:50:52,319 --> 00:51:00,079
i want to finish out this thought

00:50:55,920 --> 00:51:03,200
so now uh

00:51:00,079 --> 00:51:03,200
this uh

00:51:03,599 --> 00:51:08,640
because we now have two separate

00:51:05,599 --> 00:51:10,640
expectations in the test google tests

00:51:08,640 --> 00:51:11,280
output will now give us an indication of

00:51:10,640 --> 00:51:14,960
whether

00:51:11,280 --> 00:51:16,400
it failed because the two kind values

00:51:14,960 --> 00:51:19,520
the categories

00:51:16,400 --> 00:51:22,559
didn't match or whether the test failed

00:51:19,520 --> 00:51:23,040
because the token text didn't match here

00:51:22,559 --> 00:51:25,359
i

00:51:23,040 --> 00:51:26,480
inserted an extraneous space to make the

00:51:25,359 --> 00:51:27,839
test fail

00:51:26,480 --> 00:51:30,240
which i knew that the scanner would

00:51:27,839 --> 00:51:30,240
ignore

00:51:31,839 --> 00:51:37,040
uh so uh would you

00:51:34,960 --> 00:51:38,000
question would you put all the test

00:51:37,040 --> 00:51:42,960
suites

00:51:38,000 --> 00:51:42,960
in the same file um

00:51:43,040 --> 00:51:48,160
almost for for a large pr well for a

00:51:45,760 --> 00:51:50,480
project of any significant size

00:51:48,160 --> 00:51:52,720
i can't imagine i'd put all the test

00:51:50,480 --> 00:51:56,960
suites in the same file

00:51:52,720 --> 00:51:58,800
you know if i uh

00:51:56,960 --> 00:52:00,480
in a real version of this program where

00:51:58,800 --> 00:52:01,040
i wanted to have a full set of unit

00:52:00,480 --> 00:52:04,079
tests

00:52:01,040 --> 00:52:06,559
or i wanted to have good unit test code

00:52:04,079 --> 00:52:09,920
coverage over my whole project i would

00:52:06,559 --> 00:52:09,920
probably have a parser

00:52:10,800 --> 00:52:15,119
test suite as well as a scanner test

00:52:13,599 --> 00:52:17,040
suite

00:52:15,119 --> 00:52:19,040
i would expect that at the very least

00:52:17,040 --> 00:52:20,960
the parsers test suite would be in a

00:52:19,040 --> 00:52:23,599
different source file from the scanners

00:52:20,960 --> 00:52:23,599
test suite

00:52:24,640 --> 00:52:29,920
the depending on

00:52:30,079 --> 00:52:37,040
i would tend to place all of the tests

00:52:33,119 --> 00:52:41,119
for a particular test suite in one file

00:52:37,040 --> 00:52:44,000
uh usually i try to keep my types

00:52:41,119 --> 00:52:45,599
fairly small so i don't need to write

00:52:44,000 --> 00:52:49,040
that many tests

00:52:45,599 --> 00:52:50,480
so we're not talking about adding a huge

00:52:49,040 --> 00:52:53,520
amount of code

00:52:50,480 --> 00:52:56,800
into a single source file for the tests

00:52:53,520 --> 00:52:58,720
uh i can imagine

00:52:56,800 --> 00:53:00,400
well i don't need to imagine i can say

00:52:58,720 --> 00:53:03,200
that there are certainly

00:53:00,400 --> 00:53:04,640
uh i haven't stuck to that rigidly and

00:53:03,200 --> 00:53:08,319
there are types that i have

00:53:04,640 --> 00:53:10,160
written from time to time where

00:53:08,319 --> 00:53:12,839
it might have made sense to split the

00:53:10,160 --> 00:53:17,520
tests out into multiple files

00:53:12,839 --> 00:53:20,319
but generally speaking i think of

00:53:17,520 --> 00:53:20,880
putting all of the tests in a test suite

00:53:20,319 --> 00:53:24,160
in

00:53:20,880 --> 00:53:26,000
one test suite in a source file and

00:53:24,160 --> 00:53:29,839
putting each test suite in its own

00:53:26,000 --> 00:53:29,839
source file

00:53:29,920 --> 00:53:37,760
okay so what parts of google test

00:53:33,119 --> 00:53:41,599
have we used well the test macro

00:53:37,760 --> 00:53:43,599
the expect eq uh macro and the filter

00:53:41,599 --> 00:53:46,400
option

00:53:43,599 --> 00:53:47,119
what have we got out of it well we've

00:53:46,400 --> 00:53:49,359
got

00:53:47,119 --> 00:53:50,400
clearer more detailed output from our

00:53:49,359 --> 00:53:52,319
tests

00:53:50,400 --> 00:53:53,920
our tests are now grouped into a test

00:53:52,319 --> 00:53:57,599
suite which we

00:53:53,920 --> 00:53:58,160
and we can filter on what tests we want

00:53:57,599 --> 00:54:00,720
to run

00:53:58,160 --> 00:54:01,680
such as down to a specific test suite

00:54:00,720 --> 00:54:04,720
down to a type

00:54:01,680 --> 00:54:09,040
down to a particular

00:54:04,720 --> 00:54:11,119
individual test things like that

00:54:09,040 --> 00:54:12,640
and this is just scratching the surface

00:54:11,119 --> 00:54:15,839
of what you can do

00:54:12,640 --> 00:54:17,599
with a testing framework so uh

00:54:15,839 --> 00:54:20,000
this gets you to a point where the

00:54:17,599 --> 00:54:21,040
framework is you've started using the

00:54:20,000 --> 00:54:24,400
framework

00:54:21,040 --> 00:54:25,680
and you can start gradually exploring

00:54:24,400 --> 00:54:27,599
the new feature

00:54:25,680 --> 00:54:29,680
the features of the framework as you

00:54:27,599 --> 00:54:33,280
write additional tests

00:54:29,680 --> 00:54:36,000
some of the ones that you that uh

00:54:33,280 --> 00:54:36,559
are a big deal are the notion of

00:54:36,000 --> 00:54:39,760
creating

00:54:36,559 --> 00:54:42,319
test fixtures uh where

00:54:39,760 --> 00:54:43,280
you have several tests that use a common

00:54:42,319 --> 00:54:46,000
setup and

00:54:43,280 --> 00:54:49,680
common setup and teardown uh you want to

00:54:46,000 --> 00:54:54,400
run several tests based on the same

00:54:49,680 --> 00:54:56,400
setup the a test fixture is a way of

00:54:54,400 --> 00:54:58,559
doing that without duplicating the setup

00:54:56,400 --> 00:55:01,839
code

00:54:58,559 --> 00:55:03,920
uh randomizing the order of the tests uh

00:55:01,839 --> 00:55:07,280
this is something that you

00:55:03,920 --> 00:55:09,520
we see people do so that if you're if

00:55:07,280 --> 00:55:12,559
the tests always run in the same order

00:55:09,520 --> 00:55:15,280
it's possible that that would mask

00:55:12,559 --> 00:55:16,640
certain kinds of failures that one that

00:55:15,280 --> 00:55:19,440
the second test only

00:55:16,640 --> 00:55:20,319
passes because it came after the first

00:55:19,440 --> 00:55:22,640
one

00:55:20,319 --> 00:55:24,960
if you randomize the order of the order

00:55:22,640 --> 00:55:27,520
of the tests

00:55:24,960 --> 00:55:28,799
that can help you identify those sorts

00:55:27,520 --> 00:55:30,640
of problems and

00:55:28,799 --> 00:55:32,240
notice when a test isn't cleaning up

00:55:30,640 --> 00:55:34,000
after itself

00:55:32,240 --> 00:55:35,680
then there are some frameworks that that

00:55:34,000 --> 00:55:37,440
can actually generate the tests

00:55:35,680 --> 00:55:41,440
automatically this seems to be a

00:55:37,440 --> 00:55:44,880
feature in particular of uh commercial

00:55:41,440 --> 00:55:46,079
tests uh test frameworks that they will

00:55:44,880 --> 00:55:49,839
be able to

00:55:46,079 --> 00:55:53,200
automatically generate several tests

00:55:49,839 --> 00:55:55,680
uh along similar lines

00:55:53,200 --> 00:55:56,559
based on some information that you give

00:55:55,680 --> 00:56:00,319
them

00:55:56,559 --> 00:56:01,440
and figure out ways of testing your

00:56:00,319 --> 00:56:04,880
interface

00:56:01,440 --> 00:56:08,400
in an automated fashion

00:56:04,880 --> 00:56:10,960
now this is also a good point to to

00:56:08,400 --> 00:56:11,440
take a step back review the properties

00:56:10,960 --> 00:56:15,200
of

00:56:11,440 --> 00:56:16,640
what makes a good test they're correct

00:56:15,200 --> 00:56:19,760
pass when they when we expect them to

00:56:16,640 --> 00:56:22,079
pass fail when we expect them to fail

00:56:19,760 --> 00:56:23,119
they're readable that is you don't have

00:56:22,079 --> 00:56:25,520
to look at

00:56:23,119 --> 00:56:27,440
uh you don't have to document them in

00:56:25,520 --> 00:56:29,359
much detail other than

00:56:27,440 --> 00:56:31,200
the code itself it should be fairly

00:56:29,359 --> 00:56:33,760
self-documenting

00:56:31,200 --> 00:56:35,599
uh we have enough co we have enough

00:56:33,760 --> 00:56:37,119
tests to

00:56:35,599 --> 00:56:38,720
give us a reasonable degree of

00:56:37,119 --> 00:56:40,559
confidence that our code is working

00:56:38,720 --> 00:56:43,119
correctly

00:56:40,559 --> 00:56:44,160
they're demonstrative they represent how

00:56:43,119 --> 00:56:47,760
someone would really

00:56:44,160 --> 00:56:50,880
use this component in the main program

00:56:47,760 --> 00:56:51,680
and resilient we don't have to

00:56:50,880 --> 00:56:53,680
constantly

00:56:51,680 --> 00:56:54,799
fiddle with the tests and change them

00:56:53,680 --> 00:56:58,480
all the time

00:56:54,799 --> 00:57:01,839
to make sure that they stay up to date

00:56:58,480 --> 00:57:04,160
we only want uh you will have to do some

00:57:01,839 --> 00:57:06,319
test maintenance that's

00:57:04,160 --> 00:57:08,240
that's to be expected because we don't

00:57:06,319 --> 00:57:10,839
always get our interfaces right the

00:57:08,240 --> 00:57:13,440
first time

00:57:10,839 --> 00:57:16,640
but that should be the exception

00:57:13,440 --> 00:57:18,559
rather than the rule if you have to

00:57:16,640 --> 00:57:20,000
spend a lot of time maintaining your

00:57:18,559 --> 00:57:21,760
tests

00:57:20,000 --> 00:57:23,280
it starts to become more questionable

00:57:21,760 --> 00:57:26,319
whether they're really

00:57:23,280 --> 00:57:30,079
saving you time

00:57:26,319 --> 00:57:31,599
so uh once you

00:57:30,079 --> 00:57:33,119
getting comfortable with those

00:57:31,599 --> 00:57:35,599
properties

00:57:33,119 --> 00:57:36,480
is an important part of really of the

00:57:35,599 --> 00:57:39,920
next big

00:57:36,480 --> 00:57:40,799
step in testing i think is moving into

00:57:39,920 --> 00:57:43,839
the use of

00:57:40,799 --> 00:57:45,520
mocks mocks or other test doubles as

00:57:43,839 --> 00:57:48,240
they're sometimes called which are

00:57:45,520 --> 00:57:49,599
tools for minimizing dependencies

00:57:48,240 --> 00:57:52,319
between the tests

00:57:49,599 --> 00:57:54,000
so i mentioned the idea that we could

00:57:52,319 --> 00:57:57,599
have a separate test suite for

00:57:54,000 --> 00:58:01,760
the parser as well as the scanner

00:57:57,599 --> 00:58:08,319
right now the parser

00:58:01,760 --> 00:58:12,400
um uh the parser

00:58:08,319 --> 00:58:13,920
depend uses the normal scanner

00:58:12,400 --> 00:58:17,280
the same scanner that we've been testing

00:58:13,920 --> 00:58:19,040
up to this point to do its work

00:58:17,280 --> 00:58:22,400
what that means is if we write our

00:58:19,040 --> 00:58:24,480
parser tests to use that scanner

00:58:22,400 --> 00:58:26,160
and the scanner has some kind of failure

00:58:24,480 --> 00:58:28,160
in it

00:58:26,160 --> 00:58:30,000
it might look like the parser isn't

00:58:28,160 --> 00:58:31,280
working even though it's really a

00:58:30,000 --> 00:58:33,440
problem in the scanner

00:58:31,280 --> 00:58:36,720
it's not narrowing things down as much

00:58:33,440 --> 00:58:39,200
as it could for us so

00:58:36,720 --> 00:58:40,880
by using a mock scanner instead of the

00:58:39,200 --> 00:58:42,720
normal scanner

00:58:40,880 --> 00:58:44,319
we would be able to test the parser

00:58:42,720 --> 00:58:48,839
independently

00:58:44,319 --> 00:58:53,599
and make sure that a failure in the test

00:58:48,839 --> 00:58:55,920
uh would um

00:58:53,599 --> 00:58:56,720
uh would represent a real failure in

00:58:55,920 --> 00:59:00,400
just the

00:58:56,720 --> 00:59:03,440
parser not the scanner

00:59:00,400 --> 00:59:06,720
okay uh that brings me to

00:59:03,440 --> 00:59:09,680
the end a couple of questions here

00:59:06,720 --> 00:59:10,480
uh does google test have the ability to

00:59:09,680 --> 00:59:14,559
show

00:59:10,480 --> 00:59:17,760
test coverage when i've used google test

00:59:14,559 --> 00:59:20,960
it's i've measured my the test coverage

00:59:17,760 --> 00:59:24,480
through an external tool but i'm

00:59:20,960 --> 00:59:27,520
not certain it doesn't have one

00:59:24,480 --> 00:59:29,359
there may be one and that system was

00:59:27,520 --> 00:59:32,160
just using another

00:59:29,359 --> 00:59:34,400
test framework or another code coverage

00:59:32,160 --> 00:59:36,000
measurement tool that we already had in

00:59:34,400 --> 00:59:38,319
place

00:59:36,000 --> 00:59:38,319
um

00:59:39,119 --> 00:59:42,400
for some functions that have

00:59:40,559 --> 00:59:44,640
dependencies on others

00:59:42,400 --> 00:59:45,440
what framework do you recommend to be

00:59:44,640 --> 00:59:50,000
easily

00:59:45,440 --> 00:59:53,040
to easily mock these internal functions

00:59:50,000 --> 00:59:56,640
uh so i typically think of mocking

00:59:53,040 --> 00:59:58,640
classes rather than individual functions

00:59:56,640 --> 01:00:01,359
although you can do that

00:59:58,640 --> 01:00:04,319
um but some locking frameworks will let

01:00:01,359 --> 01:00:04,319
you do that i should say

01:00:04,400 --> 01:00:08,079
the uh

01:00:09,520 --> 01:00:13,520
i've had good good results with google

01:00:11,599 --> 01:00:15,440
mock one of the reasons i picked google

01:00:13,520 --> 01:00:17,760
test as this was because

01:00:15,440 --> 01:00:19,200
google mock is a nice extension on to

01:00:17,760 --> 01:00:21,760
that so

01:00:19,200 --> 01:00:23,359
it easily sets you up for this next step

01:00:21,760 --> 01:00:26,079
that i'm i'm leaving you with a little

01:00:23,359 --> 01:00:26,079
teaser for

01:00:26,160 --> 01:00:29,520
but there certainly are other frameworks

01:00:28,240 --> 01:00:32,559
that have

01:00:29,520 --> 01:00:35,200
mocking capabilities not all of them uh

01:00:32,559 --> 01:00:37,200
there are c tests the the sieve testing

01:00:35,200 --> 01:00:38,400
framework that i mentioned earlier

01:00:37,200 --> 01:00:41,200
as far as i know doesn't have any

01:00:38,400 --> 01:00:44,400
mocking capability but

01:00:41,200 --> 01:00:44,799
uh so i've had good success with google

01:00:44,400 --> 01:00:48,880
mock

01:00:44,799 --> 01:00:51,119
but i haven't i can't say that i've used

01:00:48,880 --> 01:00:52,000
uh enough different testing frameworks

01:00:51,119 --> 01:00:54,400
on enough different

01:00:52,000 --> 01:00:56,319
projects to be able to give you a really

01:00:54,400 --> 01:01:00,160
good comparison of

01:00:56,319 --> 01:01:00,160
yeah i think this one is the best

01:01:00,559 --> 01:01:06,240
um okay i'm going to stop and

01:01:04,400 --> 01:01:08,000
see if there's another question i'm

01:01:06,240 --> 01:01:09,520
gonna stop here because we're a little

01:01:08,000 --> 01:01:12,240
bit over time

01:01:09,520 --> 01:01:14,079
uh but i will be available in remo for

01:01:12,240 --> 01:01:16,480
answering questions i'll

01:01:14,079 --> 01:01:17,200
i will try and find a table yesterday i

01:01:16,480 --> 01:01:21,200
was looking

01:01:17,200 --> 01:01:24,319
i was on floor three of the hallway

01:01:21,200 --> 01:01:26,400
uh track when i was doing this so you

01:01:24,319 --> 01:01:29,359
can find me there if you want to ask

01:01:26,400 --> 01:01:30,400
additional follow-up questions otherwise

01:01:29,359 --> 01:01:32,559
thank you for listening

01:01:30,400 --> 01:01:33,599
i hope you enjoyed it i hope you find

01:01:32,559 --> 01:01:39,839
this useful

01:01:33,599 --> 01:01:39,839
and enjoy the rest of cbpcon

01:01:55,440 --> 01:01:57,520

YouTube URL: https://www.youtube.com/watch?v=_OHE33s7EKw


