Title: Dynamic Polymorphism with Metaclasses and Code Injection - Sy Brand - CppCon 2020
Publication date: 2020-09-28
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Dynamic polymorphism in C++ has historically meant virtual functions and inheritance. However, these form only one possible design for solving this problem, and they bring several implications on performance, ergonomics and flexibility. Type erasure is another way to implement dynamic polymorphism, as demonstrated in several talks by Sean Parent and adopted in other languages, such as Rust’s trait objects. But implementing type erasing objects which provide ergonomic interfaces in C++ is cumbersome and error-prone, leading to a large family of types and libraries with subtly different semantics and lower adoption rates compared to inheritance.

This talk will present a possible future design for interface-based type erasure in C++ that marries the convenience of inheritance to the benefits which it otherwise lacks. It will introduce the code injection and metaclasses facilities which are proposed for inclusion in C++ along with a prototype implementation of the design based on the experimental metaclasses Clang fork.

---
Sy Brand is Microsoft’s C++ Developer Advocate. Their background is in compilers and debuggers for embedded accelerators, but they’re also interested in generic library design, metaprogramming, functional-style C++, undefined behaviour, and making our communities more welcoming and inclusive.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,320 --> 00:00:12,639
welcome to dynamic polymorphism with

00:00:10,559 --> 00:00:14,639
code injection and metaclasses

00:00:12,639 --> 00:00:16,720
my name is sai brand i am microsoft's

00:00:14,639 --> 00:00:19,039
siblings plus developer advocate

00:00:16,720 --> 00:00:21,279
uh before i get started on the talk a

00:00:19,039 --> 00:00:22,480
bit about what we're doing as microsoft

00:00:21,279 --> 00:00:25,599
at cppcon

00:00:22,480 --> 00:00:26,160
we have our own expo booth um and our

00:00:25,599 --> 00:00:27,840
room

00:00:26,160 --> 00:00:29,279
and our table at the expo hall so please

00:00:27,840 --> 00:00:31,039
come talk to us about any of the

00:00:29,279 --> 00:00:32,640
announcements we've been making

00:00:31,039 --> 00:00:34,399
and please also take our survey you know

00:00:32,640 --> 00:00:35,120
this helps us to tune our own tools to

00:00:34,399 --> 00:00:36,800
help you

00:00:35,120 --> 00:00:39,120
and you could also win microsoft flight

00:00:36,800 --> 00:00:41,520
simulator which is always fun

00:00:39,120 --> 00:00:44,480
all right dynamic polymorphism what do i

00:00:41,520 --> 00:00:46,800
mean by this

00:00:44,480 --> 00:00:47,920
so polymorphism is the provision of a

00:00:46,800 --> 00:00:51,360
single interface

00:00:47,920 --> 00:00:53,440
to entities of different types

00:00:51,360 --> 00:00:55,039
and there's a split we're interested in

00:00:53,440 --> 00:00:57,280
in this definition

00:00:55,039 --> 00:00:59,199
dynamic polymorphism versus static

00:00:57,280 --> 00:01:01,760
polymorphism

00:00:59,199 --> 00:01:04,239
dynamic is at runtime static is at

00:01:01,760 --> 00:01:06,720
compile time

00:01:04,239 --> 00:01:09,040
dynamic gives you different behavior

00:01:06,720 --> 00:01:11,119
based on your dynamic type of an object

00:01:09,040 --> 00:01:13,760
whereas static is the static type

00:01:11,119 --> 00:01:15,119
i have a cat trying to climb my chair hi

00:01:13,760 --> 00:01:18,400
this is milkshake

00:01:15,119 --> 00:01:18,400
i'm gonna say hi milkshake

00:01:20,320 --> 00:01:23,840
dynamic polymorphism is typically

00:01:22,240 --> 00:01:26,000
implemented with inheritance

00:01:23,840 --> 00:01:27,600
but there's um there's other ways you

00:01:26,000 --> 00:01:30,640
can do it inheritance is the main

00:01:27,600 --> 00:01:31,520
method static polymorphism is usually

00:01:30,640 --> 00:01:35,680
implemented with

00:01:31,520 --> 00:01:35,680
overloading or templates

00:01:36,400 --> 00:01:40,000
now louis dion gave a really fantastic

00:01:39,040 --> 00:01:42,079
talk a few years

00:01:40,000 --> 00:01:43,600
back on runtime polymorphism it's

00:01:42,079 --> 00:01:44,240
hebrews plus now which i'd highly

00:01:43,600 --> 00:01:46,640
recommend

00:01:44,240 --> 00:01:48,000
going to see there's a lot of overlap

00:01:46,640 --> 00:01:48,479
with the kind of things we're talking

00:01:48,000 --> 00:01:50,560
about

00:01:48,479 --> 00:01:53,520
and this goes into some more details

00:01:50,560 --> 00:01:55,360
about part of this session

00:01:53,520 --> 00:01:56,640
however louis says that we should listen

00:01:55,360 --> 00:01:58,479
to sean perrin not him

00:01:56,640 --> 00:02:00,320
so let's go see what sean perrin has to

00:01:58,479 --> 00:02:02,399
say

00:02:00,320 --> 00:02:04,240
john parent says inheritance is the base

00:02:02,399 --> 00:02:07,040
class of evil

00:02:04,240 --> 00:02:08,319
this is a talk from 2012 like eight

00:02:07,040 --> 00:02:11,920
years ago now

00:02:08,319 --> 00:02:14,239
but it's still very much relevant today

00:02:11,920 --> 00:02:16,640
and sean's talk and louise talks and

00:02:14,239 --> 00:02:18,000
other talks which sean has given

00:02:16,640 --> 00:02:20,000
they go into a lot of detail about

00:02:18,000 --> 00:02:21,599
problems with inheritance

00:02:20,000 --> 00:02:23,360
i'm not going to go into so much detail

00:02:21,599 --> 00:02:25,599
but you do need to understand some of

00:02:23,360 --> 00:02:27,760
these concepts in order to really

00:02:25,599 --> 00:02:29,760
um get what i'm trying to get at in this

00:02:27,760 --> 00:02:32,000
talk

00:02:29,760 --> 00:02:34,560
so some problems with inheritance one is

00:02:32,000 --> 00:02:37,680
it often requires dynamic allocation

00:02:34,560 --> 00:02:40,640
where you might not need it

00:02:37,680 --> 00:02:42,160
an example is say we have a base object

00:02:40,640 --> 00:02:43,680
and then we have an a and b which

00:02:42,160 --> 00:02:45,280
derived from it

00:02:43,680 --> 00:02:47,519
if we have some function which returns

00:02:45,280 --> 00:02:48,560
base by value or we have some vector of

00:02:47,519 --> 00:02:50,000
bases

00:02:48,560 --> 00:02:51,760
then this is going to do what's called

00:02:50,000 --> 00:02:54,000
slicing where we take

00:02:51,760 --> 00:02:55,440
just the base object part of the object

00:02:54,000 --> 00:02:58,000
and we slice off

00:02:55,440 --> 00:02:59,280
the and the dynamic part the part of the

00:02:58,000 --> 00:03:02,239
the derived object

00:02:59,280 --> 00:03:04,000
usually this is not what we want in

00:03:02,239 --> 00:03:06,640
order to make this work we have to

00:03:04,000 --> 00:03:08,080
do something like a unique pointer we

00:03:06,640 --> 00:03:10,400
dynamically allocate we

00:03:08,080 --> 00:03:11,920
return a pointer or we store a pointer

00:03:10,400 --> 00:03:13,680
in the vector

00:03:11,920 --> 00:03:15,599
and there are ways you could get around

00:03:13,680 --> 00:03:17,680
this by like building something on top

00:03:15,599 --> 00:03:20,560
of inheritance which does like

00:03:17,680 --> 00:03:22,560
a small buffer optimization or always

00:03:20,560 --> 00:03:23,360
uses in place storage things like that

00:03:22,560 --> 00:03:25,599
but

00:03:23,360 --> 00:03:26,560
by default inheritance and virtual

00:03:25,599 --> 00:03:28,319
functions

00:03:26,560 --> 00:03:30,000
you need to dynamically allocate if you

00:03:28,319 --> 00:03:32,480
want to use them in a polymorphic way

00:03:30,000 --> 00:03:34,959
like this

00:03:32,480 --> 00:03:36,720
another is ownership and nullability

00:03:34,959 --> 00:03:38,400
since we have pointers we have to care

00:03:36,720 --> 00:03:40,720
about ownership we have to care

00:03:38,400 --> 00:03:41,760
if this thing could be null if we use

00:03:40,720 --> 00:03:44,480
unique pointer

00:03:41,760 --> 00:03:46,159
then the ownership is clear but less

00:03:44,480 --> 00:03:47,680
clear is like

00:03:46,159 --> 00:03:49,760
if this thing is returning a unique

00:03:47,680 --> 00:03:50,640
pointer can it return null do i have to

00:03:49,760 --> 00:03:52,959
check

00:03:50,640 --> 00:03:54,560
if this thing is taking a unique pointer

00:03:52,959 --> 00:03:55,920
what happens if i pass null is that

00:03:54,560 --> 00:03:57,599
valid what's the behavior

00:03:55,920 --> 00:04:01,360
something we have to care about which

00:03:57,599 --> 00:04:05,760
maybe we don't want to

00:04:01,360 --> 00:04:07,680
another is intrusiveness and that

00:04:05,760 --> 00:04:08,799
supporting inheritance requires

00:04:07,680 --> 00:04:12,159
modifying child

00:04:08,799 --> 00:04:15,040
classes an example of this

00:04:12,159 --> 00:04:17,040
if we have a base class in my lib and

00:04:15,040 --> 00:04:17,840
then we have some other library which

00:04:17,040 --> 00:04:20,479
has an

00:04:17,840 --> 00:04:21,040
x class now they both have a do thing

00:04:20,479 --> 00:04:24,240
method

00:04:21,040 --> 00:04:27,440
which returns void and they're virtual

00:04:24,240 --> 00:04:28,320
you cannot allocate an instance of other

00:04:27,440 --> 00:04:31,120
lib x

00:04:28,320 --> 00:04:32,080
and take a pointer to it through a mylib

00:04:31,120 --> 00:04:34,479
base

00:04:32,080 --> 00:04:36,320
this will not work because other lid x

00:04:34,479 --> 00:04:38,080
does not say it inherits from my lid

00:04:36,320 --> 00:04:40,880
base

00:04:38,080 --> 00:04:41,440
this can be a problem maybe we can't

00:04:40,880 --> 00:04:43,680
change

00:04:41,440 --> 00:04:45,360
other limp x like if we could just

00:04:43,680 --> 00:04:45,759
decorate it and say oh we inherit from

00:04:45,360 --> 00:04:47,440
bass

00:04:45,759 --> 00:04:49,040
maybe our problem solved but maybe we

00:04:47,440 --> 00:04:50,400
can't maybe we don't own the code or

00:04:49,040 --> 00:04:52,880
there's some other constraints which

00:04:50,400 --> 00:04:56,240
stop us from doing this

00:04:52,880 --> 00:04:58,880
so polymorphism with inheritance is

00:04:56,240 --> 00:04:58,880
intrusive

00:04:59,520 --> 00:05:03,440
another is no more value semantics we

00:05:01,600 --> 00:05:06,240
have pointers

00:05:03,440 --> 00:05:07,440
again if we want value semantics then we

00:05:06,240 --> 00:05:10,160
have to build something on top

00:05:07,440 --> 00:05:10,880
you know if we have like a virtual clone

00:05:10,160 --> 00:05:14,000
function

00:05:10,880 --> 00:05:15,759
which will dynamically allocate um a

00:05:14,000 --> 00:05:17,680
pointer and pass it back

00:05:15,759 --> 00:05:18,960
which uses the correct dynamic type and

00:05:17,680 --> 00:05:21,199
that's a way of doing

00:05:18,960 --> 00:05:22,000
of getting copy behavior but you still

00:05:21,199 --> 00:05:24,639
don't have

00:05:22,000 --> 00:05:26,960
the usual c plus value semantics which a

00:05:24,639 --> 00:05:29,360
lot of cocaine depends on

00:05:26,960 --> 00:05:31,199
and similarly it changes semantics for

00:05:29,360 --> 00:05:33,120
algorithms and containers like if you

00:05:31,199 --> 00:05:34,960
have if you're doing a sort

00:05:33,120 --> 00:05:37,120
suddenly maybe we're sorting on pointers

00:05:34,960 --> 00:05:37,840
and we have to supply our own custom

00:05:37,120 --> 00:05:39,520
comparator

00:05:37,840 --> 00:05:41,440
object or if we're storing these things

00:05:39,520 --> 00:05:41,919
in a set we might need to do the same

00:05:41,440 --> 00:05:43,199
thing

00:05:41,919 --> 00:05:45,199
so it's another thing we're thinking

00:05:43,199 --> 00:05:48,000
about where we're not in the

00:05:45,199 --> 00:05:49,600
usual world of c plus values which is

00:05:48,000 --> 00:05:53,360
where we like to be for most of our

00:05:49,600 --> 00:05:56,000
siebels plus development

00:05:53,360 --> 00:05:58,479
what we're going to do is implement

00:05:56,000 --> 00:06:00,720
virtual functions by hand

00:05:58,479 --> 00:06:02,560
first we're going to do it in normalc

00:06:00,720 --> 00:06:05,600
plus which you can write today

00:06:02,560 --> 00:06:07,520
and then we're going to improve it using

00:06:05,600 --> 00:06:09,680
techniques which might be coming in

00:06:07,520 --> 00:06:12,800
future versions

00:06:09,680 --> 00:06:14,400
a lot of the code which i'm showing is

00:06:12,800 --> 00:06:16,160
kind of complex and there's a bunch of

00:06:14,400 --> 00:06:18,000
new stuff and new

00:06:16,160 --> 00:06:20,319
features new syntax you might not be

00:06:18,000 --> 00:06:20,960
familiar with so i will be glancing over

00:06:20,319 --> 00:06:23,520
at the q

00:06:20,960 --> 00:06:25,520
a in remo so if you have anything you'd

00:06:23,520 --> 00:06:27,680
like clarified or any questions

00:06:25,520 --> 00:06:28,800
as i go forward please just drop them in

00:06:27,680 --> 00:06:31,039
there and

00:06:28,800 --> 00:06:32,400
i will as long as remo cooperates i'll

00:06:31,039 --> 00:06:34,880
be able to see them and you can pick

00:06:32,400 --> 00:06:36,800
them up as i go

00:06:34,880 --> 00:06:38,000
so this is the class hierarchy i'm going

00:06:36,800 --> 00:06:39,680
to try and emulate

00:06:38,000 --> 00:06:42,319
i'll try and implement by hand we have

00:06:39,680 --> 00:06:45,600
an animal class which has a speak

00:06:42,319 --> 00:06:47,919
function which is pure virtual

00:06:45,600 --> 00:06:50,240
and we have a virtual destructor then we

00:06:47,919 --> 00:06:51,759
have a cat class and a dog class which

00:06:50,240 --> 00:06:54,880
override the speak function

00:06:51,759 --> 00:06:57,520
and they inherit from animal fairly

00:06:54,880 --> 00:06:57,520
straightforward

00:06:57,919 --> 00:07:02,319
now how this is implemented under the

00:06:59,680 --> 00:07:04,319
covers is that if i have a felix object

00:07:02,319 --> 00:07:06,240
which is a cat

00:07:04,319 --> 00:07:08,960
then this is going to have a pointer to

00:07:06,240 --> 00:07:12,160
a v table a virtual table

00:07:08,960 --> 00:07:15,039
this virtual table essentially tells us

00:07:12,160 --> 00:07:18,160
how to call functions of what virtual

00:07:15,039 --> 00:07:20,720
functions in a polymorphic object

00:07:18,160 --> 00:07:21,919
so this v table will in turn have a

00:07:20,720 --> 00:07:24,080
pointer to the speak

00:07:21,919 --> 00:07:25,680
function for cat so there's a couple of

00:07:24,080 --> 00:07:26,720
indirections we're going through here

00:07:25,680 --> 00:07:29,039
when we call speak

00:07:26,720 --> 00:07:30,000
we first have to grab the v table then

00:07:29,039 --> 00:07:32,319
we have to read through

00:07:30,000 --> 00:07:36,000
the b table to get the speak function

00:07:32,319 --> 00:07:36,000
that can be a performance bottleneck

00:07:36,720 --> 00:07:40,960
this is what i want oh my god i have

00:07:39,759 --> 00:07:43,120
another cat who is now

00:07:40,960 --> 00:07:44,639
standing on top of my printer hi come

00:07:43,120 --> 00:07:46,639
say hi

00:07:44,639 --> 00:07:48,000
i didn't have any cats in my other talks

00:07:46,639 --> 00:07:50,639
so you're getting you're getting the

00:07:48,000 --> 00:07:55,840
best this is marshmallow he's very cute

00:07:50,639 --> 00:07:57,599
um so the cat can speak this one is not

00:07:55,840 --> 00:07:59,759
so this is the interface i want i want

00:07:57,599 --> 00:08:01,680
to have an animal class which has

00:07:59,759 --> 00:08:03,520
a bunch of magic which i'm gonna gonna

00:08:01,680 --> 00:08:05,680
implement throughout the talk

00:08:03,520 --> 00:08:06,560
and then i have a cat class and a dog

00:08:05,680 --> 00:08:08,800
class which

00:08:06,560 --> 00:08:10,319
both just have speak functions note that

00:08:08,800 --> 00:08:13,120
these are not inheriting

00:08:10,319 --> 00:08:16,160
from the animal class i'm just doing all

00:08:13,120 --> 00:08:18,000
of this with bear sleepless blood

00:08:16,160 --> 00:08:19,280
but i want to support this use case i

00:08:18,000 --> 00:08:21,759
want to be able to create an

00:08:19,280 --> 00:08:23,120
animal from a cat and call speak and i

00:08:21,759 --> 00:08:23,759
want to be able to create an animal from

00:08:23,120 --> 00:08:26,479
a dog

00:08:23,759 --> 00:08:27,599
and have it speak and not do any slicing

00:08:26,479 --> 00:08:29,039
okay

00:08:27,599 --> 00:08:31,120
so now we'll implement the magic in

00:08:29,039 --> 00:08:33,360
animal

00:08:31,120 --> 00:08:35,039
this is the the steps we're going to go

00:08:33,360 --> 00:08:36,399
through to implement our virtual

00:08:35,039 --> 00:08:38,320
functions by hand

00:08:36,399 --> 00:08:40,000
first we're going to declare what the v

00:08:38,320 --> 00:08:43,039
table layout looks like

00:08:40,000 --> 00:08:45,440
for our animal class then we're going to

00:08:43,039 --> 00:08:46,720
fill in the v table for our cat and dog

00:08:45,440 --> 00:08:49,519
class

00:08:46,720 --> 00:08:50,160
then we will on construction of an

00:08:49,519 --> 00:08:52,000
animal

00:08:50,160 --> 00:08:54,399
we're going to capture the v table

00:08:52,000 --> 00:08:57,279
pointers for the correct concrete type

00:08:54,399 --> 00:08:58,560
and then finally when we call speak for

00:08:57,279 --> 00:09:02,000
the destructor we're going to

00:08:58,560 --> 00:09:04,000
forward our calls through the v table

00:09:02,000 --> 00:09:05,680
i don't worry if this all seems like a

00:09:04,000 --> 00:09:08,720
lot we're going to step through all of

00:09:05,680 --> 00:09:11,200
these in some detail

00:09:08,720 --> 00:09:12,080
again this is our hierarchy animal can

00:09:11,200 --> 00:09:15,200
speak

00:09:12,080 --> 00:09:15,200
cat and dog override

00:09:15,279 --> 00:09:19,360
let's move on to declaring our v table

00:09:17,680 --> 00:09:21,760
we're going to start off very simple

00:09:19,360 --> 00:09:23,120
our v table is going to have two

00:09:21,760 --> 00:09:26,640
function pointers

00:09:23,120 --> 00:09:28,399
one for speak and one for destroy

00:09:26,640 --> 00:09:30,000
which is going to call the destructor of

00:09:28,399 --> 00:09:32,080
the concrete object and also

00:09:30,000 --> 00:09:33,279
because we're going to be allocating

00:09:32,080 --> 00:09:36,000
inside our object

00:09:33,279 --> 00:09:37,920
it's going to reclaim that memory these

00:09:36,000 --> 00:09:40,880
things are taking void pointers

00:09:37,920 --> 00:09:41,519
because that's how we're going to store

00:09:40,880 --> 00:09:43,680
um

00:09:41,519 --> 00:09:46,000
our concrete object internally we're

00:09:43,680 --> 00:09:49,440
going to pass void pointers around

00:09:46,000 --> 00:09:51,920
and then the concrete objects

00:09:49,440 --> 00:09:53,360
are going to cast those pointers

00:09:51,920 --> 00:09:56,080
internally

00:09:53,360 --> 00:09:58,480
okay you'll see how this works in a

00:09:56,080 --> 00:09:58,480
second

00:09:58,959 --> 00:10:03,120
now we're going to define v table for

00:10:00,640 --> 00:10:04,800
concrete type

00:10:03,120 --> 00:10:06,720
so we're going to have an instance this

00:10:04,800 --> 00:10:08,800
is a variable template

00:10:06,720 --> 00:10:10,480
we're going to have an instance of a v

00:10:08,800 --> 00:10:13,600
table and it's going to be

00:10:10,480 --> 00:10:14,800
templated on the concrete type i.e cat

00:10:13,600 --> 00:10:16,480
or dog

00:10:14,800 --> 00:10:18,480
so we need a function which is going to

00:10:16,480 --> 00:10:19,440
call the correct version of speak and a

00:10:18,480 --> 00:10:21,040
function which

00:10:19,440 --> 00:10:23,200
deletes the object and calls the

00:10:21,040 --> 00:10:25,279
destructor and we can use lambdas for

00:10:23,200 --> 00:10:27,440
this

00:10:25,279 --> 00:10:29,279
so for a given concrete object the first

00:10:27,440 --> 00:10:30,079
function pointer is just going to static

00:10:29,279 --> 00:10:32,880
cast

00:10:30,079 --> 00:10:34,079
to the concrete type and then call speak

00:10:32,880 --> 00:10:35,920
and then the destroy

00:10:34,079 --> 00:10:37,920
function is going to static cast and

00:10:35,920 --> 00:10:41,120
then called delete

00:10:37,920 --> 00:10:43,360
okay this all works because

00:10:41,120 --> 00:10:45,200
lambdas which don't capture can decay to

00:10:43,360 --> 00:10:48,399
function pointers

00:10:45,200 --> 00:10:49,120
which is kind of nice okay hopefully

00:10:48,399 --> 00:10:51,839
that's all clear

00:10:49,120 --> 00:10:53,920
as i said drop q a questions if you have

00:10:51,839 --> 00:10:55,519
anything you clarified

00:10:53,920 --> 00:10:57,680
next we need to capture the b table

00:10:55,519 --> 00:10:58,399
pointers so when we construct an animal

00:10:57,680 --> 00:11:01,440
class

00:10:58,399 --> 00:11:03,760
what we need to do is fill in um

00:11:01,440 --> 00:11:04,800
our pointer for our concrete object and

00:11:03,760 --> 00:11:07,680
pointer to our v

00:11:04,800 --> 00:11:09,040
table so our constructor is going to be

00:11:07,680 --> 00:11:10,640
a template

00:11:09,040 --> 00:11:12,399
it's going to take anything of course in

00:11:10,640 --> 00:11:12,800
the real world we would like constrain

00:11:12,399 --> 00:11:16,320
this

00:11:12,800 --> 00:11:18,880
but slidewear and we're gonna

00:11:16,320 --> 00:11:19,760
dynamically allocate a copy of what

00:11:18,880 --> 00:11:21,680
we're given

00:11:19,760 --> 00:11:24,320
and store in concrete and then we're

00:11:21,680 --> 00:11:27,680
gonna take a pointer to our v table

00:11:24,320 --> 00:11:31,040
and store that inside our animal

00:11:27,680 --> 00:11:31,920
now note that because we're um we have

00:11:31,040 --> 00:11:34,399
access to what

00:11:31,920 --> 00:11:36,399
tea is at this point whether it's a cat

00:11:34,399 --> 00:11:39,519
or a dog so this is where we're kind of

00:11:36,399 --> 00:11:41,600
saving this information for later by

00:11:39,519 --> 00:11:44,399
grabbing the right v table pointer

00:11:41,600 --> 00:11:45,200
and by dynamically allocating a copy of

00:11:44,399 --> 00:11:49,440
our t

00:11:45,200 --> 00:11:49,440
this technique is called type erasure

00:11:50,720 --> 00:11:54,079
finally we need to forward our calls

00:11:52,639 --> 00:11:56,240
through the v table

00:11:54,079 --> 00:11:57,920
which looks like this inside our animal

00:11:56,240 --> 00:12:00,000
class if we call speak

00:11:57,920 --> 00:12:01,519
then we indirect through the b table and

00:12:00,000 --> 00:12:03,519
pass it our void pointer

00:12:01,519 --> 00:12:05,279
and remember that is then going to cast

00:12:03,519 --> 00:12:06,639
inside the function and call the right

00:12:05,279 --> 00:12:08,480
version

00:12:06,639 --> 00:12:11,600
and then similarly for the structure we

00:12:08,480 --> 00:12:13,440
call destroy

00:12:11,600 --> 00:12:14,959
so now we have something which works for

00:12:13,440 --> 00:12:17,360
that use case

00:12:14,959 --> 00:12:18,800
we can have a duck cat and a dog and

00:12:17,360 --> 00:12:20,990
speak functions

00:12:18,800 --> 00:12:22,320
we can construct cat we can

00:12:20,990 --> 00:12:24,240
[Music]

00:12:22,320 --> 00:12:26,240
construct an animal from a cat and a dog

00:12:24,240 --> 00:12:28,959
and make them speak and it all works

00:12:26,240 --> 00:12:29,839
this is cool so let's look at what this

00:12:28,959 --> 00:12:31,519
has gained us

00:12:29,839 --> 00:12:33,760
these are the problems we had with

00:12:31,519 --> 00:12:35,519
inheritance at the start

00:12:33,760 --> 00:12:37,200
and we've solved some of these we've

00:12:35,519 --> 00:12:38,320
solved the ownership and nullability

00:12:37,200 --> 00:12:40,720
because now

00:12:38,320 --> 00:12:42,320
all our memory allocations are handled

00:12:40,720 --> 00:12:44,480
inside the animal class

00:12:42,320 --> 00:12:46,000
we don't have pointers externally we're

00:12:44,480 --> 00:12:49,680
just dealing with

00:12:46,000 --> 00:12:51,360
with the values we've got rid of the

00:12:49,680 --> 00:12:53,279
intrusivity because remember

00:12:51,360 --> 00:12:56,079
cat and dog did not derive from anything

00:12:53,279 --> 00:12:56,079
it just worked

00:12:57,200 --> 00:13:00,800
however we we still have the problem

00:12:58,880 --> 00:13:02,480
with um no more value semantics because

00:13:00,800 --> 00:13:03,040
we can't copy these objects but we can

00:13:02,480 --> 00:13:05,920
solve that

00:13:03,040 --> 00:13:06,560
we can extend our v table with a clone

00:13:05,920 --> 00:13:08,639
function

00:13:06,560 --> 00:13:09,920
and a move clone function and these do

00:13:08,639 --> 00:13:13,120
roughly what you'd expect

00:13:09,920 --> 00:13:13,519
clone will allocate a copy move clone

00:13:13,120 --> 00:13:16,959
will

00:13:13,519 --> 00:13:20,560
allocate by moving from the object

00:13:16,959 --> 00:13:22,160
i'm going to flash out the the code for

00:13:20,560 --> 00:13:23,680
this it's not that important it's kind

00:13:22,160 --> 00:13:24,800
of gnarly but

00:13:23,680 --> 00:13:26,800
you can see the third and fourth

00:13:24,800 --> 00:13:28,399
functions allocate new and then allocate

00:13:26,800 --> 00:13:31,839
you and move i've got a couple

00:13:28,399 --> 00:13:34,160
of um questions what happens if i pass

00:13:31,839 --> 00:13:36,160
an object which doesn't contain speak

00:13:34,160 --> 00:13:38,079
we're not handling that right now we

00:13:36,160 --> 00:13:41,920
would in this slide

00:13:38,079 --> 00:13:43,920
um where we take a um a type t

00:13:41,920 --> 00:13:45,279
we should have some check in there which

00:13:43,920 --> 00:13:47,680
checks that we have a speak

00:13:45,279 --> 00:13:49,120
and otherwise gives us a compiler error

00:13:47,680 --> 00:13:52,320
so that's how you would do

00:13:49,120 --> 00:13:53,519
that if you were doing it properly then

00:13:52,320 --> 00:13:56,000
the other question is shouldn't the

00:13:53,519 --> 00:13:56,480
destructor also call delete the other

00:13:56,000 --> 00:13:59,600
can

00:13:56,480 --> 00:14:01,680
so the destructor of animal is not going

00:13:59,600 --> 00:14:04,000
to call delete the call to delete is

00:14:01,680 --> 00:14:05,040
inside the implementation of destroy in

00:14:04,000 --> 00:14:07,040
the v table

00:14:05,040 --> 00:14:08,480
so this is the destructor for animal

00:14:07,040 --> 00:14:12,800
which calls destroy

00:14:08,480 --> 00:14:17,600
and a second function pointer here

00:14:12,800 --> 00:14:20,079
that has the call to delete all right

00:14:17,600 --> 00:14:21,760
and did i show the definition of the v

00:14:20,079 --> 00:14:26,079
table the v table layout

00:14:21,760 --> 00:14:26,079
is this one has two function pointers

00:14:26,399 --> 00:14:29,680
and then this is where we fill in the

00:14:28,880 --> 00:14:32,480
definition

00:14:29,680 --> 00:14:32,480
of the v table

00:14:33,600 --> 00:14:40,560
all right but yeah

00:14:37,120 --> 00:14:42,839
back to where we were um clone

00:14:40,560 --> 00:14:45,519
allocates copy move allocates from

00:14:42,839 --> 00:14:47,600
moving

00:14:45,519 --> 00:14:49,120
then in our copy constructor and move

00:14:47,600 --> 00:14:51,839
constructor for animal

00:14:49,120 --> 00:14:53,760
we just call through our v table to

00:14:51,839 --> 00:14:54,560
clone and move clone and we make sure to

00:14:53,760 --> 00:14:56,880
copy over

00:14:54,560 --> 00:14:58,079
the v table pointer from the object

00:14:56,880 --> 00:14:59,760
we're created from

00:14:58,079 --> 00:15:01,600
and then you would do the same thing for

00:14:59,760 --> 00:15:04,880
the assignment the copy assignment and

00:15:01,600 --> 00:15:04,880
move assignment operators

00:15:06,000 --> 00:15:09,519
now we have actually kind of a nice

00:15:08,480 --> 00:15:11,600
interface

00:15:09,519 --> 00:15:13,040
we can create an animal from a cat we

00:15:11,600 --> 00:15:14,959
can make it speak

00:15:13,040 --> 00:15:16,320
we can reassign it to a dog and make

00:15:14,959 --> 00:15:18,880
that speak we can

00:15:16,320 --> 00:15:20,320
create a new animal from an old one and

00:15:18,880 --> 00:15:21,360
make that speak and all works we have

00:15:20,320 --> 00:15:22,880
value semantics

00:15:21,360 --> 00:15:25,199
even though we're doing dynamic

00:15:22,880 --> 00:15:28,720
polymorphism it's just all handled under

00:15:25,199 --> 00:15:28,720
the covers which is really cool

00:15:29,199 --> 00:15:32,720
you can even make a vector of these

00:15:30,639 --> 00:15:34,880
things like because we defined copying

00:15:32,720 --> 00:15:37,759
and moving and things like that we can

00:15:34,880 --> 00:15:38,480
uh put a cat and a dog in a vector of

00:15:37,759 --> 00:15:42,720
animals

00:15:38,480 --> 00:15:43,759
and this will do what you expect great

00:15:42,720 --> 00:15:45,680
so we've solved some more of our

00:15:43,759 --> 00:15:46,800
problems we've got back our value

00:15:45,680 --> 00:15:49,120
semantics

00:15:46,800 --> 00:15:50,800
and we've got back our normal algorithm

00:15:49,120 --> 00:15:51,519
and container semantics you know as long

00:15:50,800 --> 00:15:53,440
as we

00:15:51,519 --> 00:15:55,199
define any of the relevant like

00:15:53,440 --> 00:15:57,920
comparison operators and things like

00:15:55,199 --> 00:16:00,320
that for our animal class

00:15:57,920 --> 00:16:01,839
the dynamic allocation one we're not

00:16:00,320 --> 00:16:02,959
going to solve for a while

00:16:01,839 --> 00:16:06,320
that's going to be towards the end of

00:16:02,959 --> 00:16:06,320
the talk but we will get to that

00:16:06,480 --> 00:16:10,320
a problem is this this is all the code

00:16:09,040 --> 00:16:13,519
which i had to write

00:16:10,320 --> 00:16:15,759
to implement this uh

00:16:13,519 --> 00:16:17,360
it's intentionally small the point is

00:16:15,759 --> 00:16:19,440
it's a lot

00:16:17,360 --> 00:16:21,519
now of course there you can do a bunch

00:16:19,440 --> 00:16:23,199
of stuff with macros or clever template

00:16:21,519 --> 00:16:24,560
magic to make this a lot smaller and

00:16:23,199 --> 00:16:27,600
there are libraries which

00:16:24,560 --> 00:16:29,920
will help you do that like uh dyno or

00:16:27,600 --> 00:16:31,600
folly poly there's a whole host of these

00:16:29,920 --> 00:16:32,560
things so you can make this easier but

00:16:31,600 --> 00:16:33,839
the point is

00:16:32,560 --> 00:16:36,880
i don't want to have to do this for

00:16:33,839 --> 00:16:39,440
every class which um i want to have a

00:16:36,880 --> 00:16:40,959
dynamic i want to treat dynamically okay

00:16:39,440 --> 00:16:43,120
it's a lot of work

00:16:40,959 --> 00:16:44,720
there's a lot of things to get wrong and

00:16:43,120 --> 00:16:47,600
because it's kind of weird code

00:16:44,720 --> 00:16:47,600
it's easy to get wrong

00:16:48,000 --> 00:16:51,199
so for the rest of the talk we're going

00:16:49,360 --> 00:16:53,519
to be improving this

00:16:51,199 --> 00:16:54,720
um with a bunch of features which might

00:16:53,519 --> 00:16:57,440
be upcoming in c

00:16:54,720 --> 00:17:00,880
plus the first thing we need in order to

00:16:57,440 --> 00:17:02,880
do this is static reflection

00:17:00,880 --> 00:17:04,959
so if reflection is the ability of a

00:17:02,880 --> 00:17:07,600
program to introspect

00:17:04,959 --> 00:17:08,720
its own structure and then expose parts

00:17:07,600 --> 00:17:11,839
of that structure

00:17:08,720 --> 00:17:11,839
to the rest of the program

00:17:12,000 --> 00:17:18,240
static reflection is therefore the

00:17:13,679 --> 00:17:20,559
ability to do that at compile time

00:17:18,240 --> 00:17:22,079
we do have some reflection capabilities

00:17:20,559 --> 00:17:24,720
in c plus plus right now

00:17:22,079 --> 00:17:26,559
most of them under type traits header so

00:17:24,720 --> 00:17:29,039
for example you can check something

00:17:26,559 --> 00:17:30,559
as an array this is kind of like

00:17:29,039 --> 00:17:31,919
reflection right you're querying

00:17:30,559 --> 00:17:33,600
something about the state of your

00:17:31,919 --> 00:17:36,480
program statically

00:17:33,600 --> 00:17:38,640
you're asking questions about your types

00:17:36,480 --> 00:17:42,400
it's kind of rudimentary but it's still

00:17:38,640 --> 00:17:42,960
a form of reflection or something like

00:17:42,400 --> 00:17:44,799
is same

00:17:42,960 --> 00:17:48,400
check if two types are the same or

00:17:44,799 --> 00:17:50,720
querying state about our program

00:17:48,400 --> 00:17:52,480
but what about converting a new

00:17:50,720 --> 00:17:54,400
enumerator to a string

00:17:52,480 --> 00:17:55,679
that's something people have to do all

00:17:54,400 --> 00:17:57,760
the time and

00:17:55,679 --> 00:17:59,919
we have to invent the wheel every single

00:17:57,760 --> 00:18:01,039
time we do it how about iterating over

00:17:59,919 --> 00:18:03,039
member functions for

00:18:01,039 --> 00:18:05,919
type we can't do that with type traits

00:18:03,039 --> 00:18:07,600
we need something more

00:18:05,919 --> 00:18:09,600
fortunately there is a paper called

00:18:07,600 --> 00:18:11,600
scalable reflection in cbs plus which

00:18:09,600 --> 00:18:13,760
solves exactly this problem

00:18:11,600 --> 00:18:15,039
and this is as far as i'm aware

00:18:13,760 --> 00:18:17,600
targeting sql

00:18:15,039 --> 00:18:17,600
23.

00:18:18,400 --> 00:18:23,919
so for an example of um converting a

00:18:21,760 --> 00:18:26,000
numerator to a string

00:18:23,919 --> 00:18:27,679
what we're gonna do is we have a two

00:18:26,000 --> 00:18:31,280
string function which takes

00:18:27,679 --> 00:18:31,280
some enumerator value

00:18:32,160 --> 00:18:37,760
next we have some magic so

00:18:35,440 --> 00:18:39,039
i'll step through this inside this

00:18:37,760 --> 00:18:42,320
members off call we have

00:18:39,039 --> 00:18:46,000
reflex per t what that does is

00:18:42,320 --> 00:18:46,240
it reflects on the type t and it returns

00:18:46,000 --> 00:18:48,960
an

00:18:46,240 --> 00:18:51,520
object which represents information

00:18:48,960 --> 00:18:54,160
about it

00:18:51,520 --> 00:18:54,799
then we have a call to members of which

00:18:54,160 --> 00:18:57,679
gives us

00:18:54,799 --> 00:18:58,320
a range representing the members of that

00:18:57,679 --> 00:19:01,200
type

00:18:58,320 --> 00:19:02,400
which since t is going to be an enum

00:19:01,200 --> 00:19:03,760
this is going to give us all the

00:19:02,400 --> 00:19:06,080
enumerator values

00:19:03,760 --> 00:19:08,080
like if our enum was color and our

00:19:06,080 --> 00:19:10,000
enumerators were red green yellow

00:19:08,080 --> 00:19:11,840
then we'd be looping through the

00:19:10,000 --> 00:19:14,559
reflection information for red green

00:19:11,840 --> 00:19:14,559
green and yellow

00:19:15,200 --> 00:19:19,520
then we're going to check if the value

00:19:17,760 --> 00:19:22,320
we got for the function

00:19:19,520 --> 00:19:23,200
is that a new original value is it green

00:19:22,320 --> 00:19:26,240
is it yellow

00:19:23,200 --> 00:19:29,120
is it red whatever if it is

00:19:26,240 --> 00:19:30,320
i'm sorry this expert id changes the

00:19:29,120 --> 00:19:33,039
reflection information

00:19:30,320 --> 00:19:35,440
into an actual expression in the c plus

00:19:33,039 --> 00:19:37,039
plus world

00:19:35,440 --> 00:19:40,080
and if it is the same then we're going

00:19:37,039 --> 00:19:42,720
to return the name of that enumerator

00:19:40,080 --> 00:19:42,720
as a string

00:19:43,200 --> 00:19:47,280
otherwise we're going to return unnamed

00:19:45,039 --> 00:19:49,360
because you know you can have

00:19:47,280 --> 00:19:50,840
values of an enum which are outside the

00:19:49,360 --> 00:19:52,320
range of things which actually have a

00:19:50,840 --> 00:19:54,000
name

00:19:52,320 --> 00:19:55,840
so this is an implementation of

00:19:54,000 --> 00:19:59,679
enumerators to strings

00:19:55,840 --> 00:20:01,280
it's much nicer than pretty much any

00:19:59,679 --> 00:20:03,600
uh solution we have in siebel's plus

00:20:01,280 --> 00:20:03,600
today

00:20:04,960 --> 00:20:09,679
code injection um i have a bunch of

00:20:08,240 --> 00:20:10,640
things in slack i'm just gonna make sure

00:20:09,679 --> 00:20:13,919
my

00:20:10,640 --> 00:20:15,840
um no we're good okay code injection so

00:20:13,919 --> 00:20:16,880
code injection is the next thing that we

00:20:15,840 --> 00:20:21,840
need

00:20:16,880 --> 00:20:21,840
for um improving this

00:20:23,280 --> 00:20:29,280
here we have a class point

00:20:26,320 --> 00:20:31,200
oh i have a question reflection requires

00:20:29,280 --> 00:20:33,520
being able to modify or program

00:20:31,200 --> 00:20:35,440
introspection as part of reflection more

00:20:33,520 --> 00:20:39,039
comment what's the question

00:20:35,440 --> 00:20:42,400
um okay so i have a class point

00:20:39,039 --> 00:20:45,520
which has two members x and y

00:20:42,400 --> 00:20:48,480
now say that i have i

00:20:45,520 --> 00:20:49,760
i want to have these um getter functions

00:20:48,480 --> 00:20:50,400
i'm not saying you should use getter

00:20:49,760 --> 00:20:52,240
functions

00:20:50,400 --> 00:20:55,039
this is just an example because people

00:20:52,240 --> 00:20:57,200
understand what getter functions are

00:20:55,039 --> 00:20:59,280
this is kind of a mechanical translation

00:20:57,200 --> 00:21:01,200
right like i have

00:20:59,280 --> 00:21:02,960
two members and i want to produce

00:21:01,200 --> 00:21:05,679
getters for those members

00:21:02,960 --> 00:21:06,960
which have the same name prefix by get

00:21:05,679 --> 00:21:10,640
and just return

00:21:06,960 --> 00:21:11,120
the object so ideally i could write some

00:21:10,640 --> 00:21:15,360
code

00:21:11,120 --> 00:21:15,360
to generate these functions for me

00:21:15,440 --> 00:21:19,039
um quickly i do have a question i

00:21:17,360 --> 00:21:19,840
believe we can you have enough to string

00:21:19,039 --> 00:21:22,480
with macros

00:21:19,840 --> 00:21:24,080
sure you could do that but this is just

00:21:22,480 --> 00:21:25,039
a function which you can call and you

00:21:24,080 --> 00:21:26,159
don't have to do anything in the

00:21:25,039 --> 00:21:29,760
declaration of your mac

00:21:26,159 --> 00:21:31,120
of your enum it's much nicer um

00:21:29,760 --> 00:21:33,679
so the code would look something like

00:21:31,120 --> 00:21:36,240
this we have a const eval block

00:21:33,679 --> 00:21:37,360
what constituteval means is execute this

00:21:36,240 --> 00:21:40,400
part of the program

00:21:37,360 --> 00:21:41,679
at compile time we then have a call to

00:21:40,400 --> 00:21:44,240
generate getters

00:21:41,679 --> 00:21:46,080
and that's going to inject some code

00:21:44,240 --> 00:21:48,480
into this context

00:21:46,080 --> 00:21:50,320
and we give it the reflection for our

00:21:48,480 --> 00:21:52,880
type

00:21:50,320 --> 00:21:55,679
okay now i can show you the definition

00:21:52,880 --> 00:21:58,320
of generate getters

00:21:55,679 --> 00:21:58,960
looks something like this take some meta

00:21:58,320 --> 00:22:01,520
info

00:21:58,960 --> 00:22:02,880
meta info is the type which reflexper

00:22:01,520 --> 00:22:05,440
returns it's the

00:22:02,880 --> 00:22:07,919
um the representation of our reflection

00:22:05,440 --> 00:22:10,799
information

00:22:07,919 --> 00:22:11,120
and then we loop over all of the members

00:22:10,799 --> 00:22:13,679
if

00:22:11,120 --> 00:22:15,520
the member is a non-static data member

00:22:13,679 --> 00:22:18,320
then we're going to generate a getter

00:22:15,520 --> 00:22:19,120
for it all right looping over the

00:22:18,320 --> 00:22:21,120
members

00:22:19,120 --> 00:22:23,120
generating getters for every non-static

00:22:21,120 --> 00:22:25,760
data member

00:22:23,120 --> 00:22:27,760
okay inside generate getter is where the

00:22:25,760 --> 00:22:31,520
magic is

00:22:27,760 --> 00:22:34,080
so there's some interesting syntax here

00:22:31,520 --> 00:22:35,280
uh this underscore underscore fragment

00:22:34,080 --> 00:22:38,320
thing is not going to be

00:22:35,280 --> 00:22:40,960
where we end up it's just a

00:22:38,320 --> 00:22:42,480
stop but essentially this is an

00:22:40,960 --> 00:22:46,480
injection statement

00:22:42,480 --> 00:22:48,880
it's going to inject some um code

00:22:46,480 --> 00:22:49,840
into the context which we're currently

00:22:48,880 --> 00:22:53,039
executing in

00:22:49,840 --> 00:22:54,559
at compile time this is a class fragment

00:22:53,039 --> 00:22:56,880
because it has struct after you can have

00:22:54,559 --> 00:22:58,960
class after there as well it's just it

00:22:56,880 --> 00:23:00,960
changes the the default um

00:22:58,960 --> 00:23:02,320
visibility so you can have class

00:23:00,960 --> 00:23:04,159
fragments you can have

00:23:02,320 --> 00:23:06,240
namespace fragments which are injected

00:23:04,159 --> 00:23:08,720
into a namespace and you can have

00:23:06,240 --> 00:23:09,919
block fragments which are injected into

00:23:08,720 --> 00:23:12,320
like a function or

00:23:09,919 --> 00:23:14,159
anywhere you can have um just a block of

00:23:12,320 --> 00:23:16,320
code

00:23:14,159 --> 00:23:18,559
so this is the context in which we're

00:23:16,320 --> 00:23:19,679
injecting so any code which we inject

00:23:18,559 --> 00:23:22,799
will turn up

00:23:19,679 --> 00:23:24,640
here the question is slide 72 meta is

00:23:22,799 --> 00:23:28,000
stood meta yes that would be

00:23:24,640 --> 00:23:28,000
stood meta members of

00:23:28,640 --> 00:23:32,159
so what we want is something like this

00:23:30,400 --> 00:23:36,159
we want to inject

00:23:32,159 --> 00:23:38,000
um a function which will look like this

00:23:36,159 --> 00:23:39,440
of course we want to vary this

00:23:38,000 --> 00:23:41,279
information based

00:23:39,440 --> 00:23:43,440
on the reflection information we're

00:23:41,279 --> 00:23:44,640
given so i'm going to slowly transform

00:23:43,440 --> 00:23:47,679
this definition

00:23:44,640 --> 00:23:49,919
into a general version

00:23:47,679 --> 00:23:52,320
so first we have the return type which

00:23:49,919 --> 00:23:54,880
is int

00:23:52,320 --> 00:23:55,840
we're going to change that into type

00:23:54,880 --> 00:23:57,919
name

00:23:55,840 --> 00:23:59,760
type of member what this does is type

00:23:57,919 --> 00:24:02,320
all the member gets used its type

00:23:59,760 --> 00:24:03,120
and then type name turns that into a c

00:24:02,320 --> 00:24:06,159
plus world

00:24:03,120 --> 00:24:07,679
type okay these things are like type

00:24:06,159 --> 00:24:09,679
name and expert id they're called

00:24:07,679 --> 00:24:11,679
ray of fires they turn some reflection

00:24:09,679 --> 00:24:15,520
information into sql plus

00:24:11,679 --> 00:24:17,279
constructs then this get x

00:24:15,520 --> 00:24:18,880
of course i want this to vary depending

00:24:17,279 --> 00:24:22,720
on the name of the member

00:24:18,880 --> 00:24:24,880
for that i can use uncall id which turns

00:24:22,720 --> 00:24:27,120
some reflection information into an

00:24:24,880 --> 00:24:30,799
identifier i can use and i can prefix it

00:24:27,120 --> 00:24:33,520
and suffix it which is what i do here

00:24:30,799 --> 00:24:35,200
then i return the member as an

00:24:33,520 --> 00:24:36,799
expression

00:24:35,200 --> 00:24:38,960
shafiq has a question so when is the

00:24:36,799 --> 00:24:40,720
type considered complete can we reflect

00:24:38,960 --> 00:24:41,760
over the injected members that's a very

00:24:40,720 --> 00:24:45,440
good question

00:24:41,760 --> 00:24:48,559
so the type is considered complete after

00:24:45,440 --> 00:24:50,480
all of this is um is implement is has

00:24:48,559 --> 00:24:51,679
been executed at compile time so if

00:24:50,480 --> 00:24:54,240
we're

00:24:51,679 --> 00:24:56,480
um for example here we're we're

00:24:54,240 --> 00:24:56,880
iterating all over all the members right

00:24:56,480 --> 00:25:02,080
so

00:24:56,880 --> 00:25:02,080
you can imagine if the the type um

00:25:02,480 --> 00:25:07,200
if we injected something into the type

00:25:05,039 --> 00:25:09,360
and we kept on looping all over

00:25:07,200 --> 00:25:10,720
these members then we could end up in an

00:25:09,360 --> 00:25:12,640
infinite loop because we're just

00:25:10,720 --> 00:25:15,919
injecting things and then reading them

00:25:12,640 --> 00:25:16,880
so essentially everything in this con's

00:25:15,919 --> 00:25:19,200
eval block

00:25:16,880 --> 00:25:20,960
will be executed and all those changes

00:25:19,200 --> 00:25:23,600
will be made to the class

00:25:20,960 --> 00:25:26,320
before you can then use it and it's

00:25:23,600 --> 00:25:28,960
considered complete

00:25:26,320 --> 00:25:31,200
all right so that is our definition of

00:25:28,960 --> 00:25:34,559
generate getter

00:25:31,200 --> 00:25:36,960
so this will change um when we run this

00:25:34,559 --> 00:25:40,480
program at compile time it will generate

00:25:36,960 --> 00:25:43,279
these member functions so we have

00:25:40,480 --> 00:25:44,320
written code which has taken reflection

00:25:43,279 --> 00:25:47,039
information about

00:25:44,320 --> 00:25:48,080
our program and then generated code for

00:25:47,039 --> 00:25:49,679
us

00:25:48,080 --> 00:25:51,520
question what determines the access

00:25:49,679 --> 00:25:53,440
specifiers of the getters

00:25:51,520 --> 00:25:55,440
would these be private since generate

00:25:53,440 --> 00:25:59,919
getters appears in the private portion

00:25:55,440 --> 00:26:01,760
that it depends on the um

00:25:59,919 --> 00:26:03,200
fragment so here i have said fragment

00:26:01,760 --> 00:26:04,240
struct which means it's going to be

00:26:03,200 --> 00:26:07,440
public

00:26:04,240 --> 00:26:07,760
if i said fragment class then it would

00:26:07,440 --> 00:26:09,520
be

00:26:07,760 --> 00:26:11,760
private you could also put access

00:26:09,520 --> 00:26:14,240
specifiers in here so i could say

00:26:11,760 --> 00:26:15,919
um underscore underscore fragment struct

00:26:14,240 --> 00:26:17,679
and then i could put private

00:26:15,919 --> 00:26:20,400
inside the braces and that would change

00:26:17,679 --> 00:26:22,400
the visibility of those getters

00:26:20,400 --> 00:26:23,520
um question is how is injected code

00:26:22,400 --> 00:26:26,400
stepped in

00:26:23,520 --> 00:26:28,240
during debug session so this is a an

00:26:26,400 --> 00:26:31,360
open tooling question

00:26:28,240 --> 00:26:33,360
so there are um in the

00:26:31,360 --> 00:26:34,880
the version of the compiler which lock

00:26:33,360 --> 00:26:38,559
three is working on

00:26:34,880 --> 00:26:40,640
um there are facilities for

00:26:38,559 --> 00:26:42,400
saying what code does this generate can

00:26:40,640 --> 00:26:43,360
you print it out for me which helps you

00:26:42,400 --> 00:26:46,720
debug

00:26:43,360 --> 00:26:47,520
as far as like what um this would look

00:26:46,720 --> 00:26:50,080
like in

00:26:47,520 --> 00:26:50,960
during debugging um that's a different

00:26:50,080 --> 00:26:53,440
question and

00:26:50,960 --> 00:26:55,039
i don't know the answer to that and it's

00:26:53,440 --> 00:26:57,840
uh it's certainly

00:26:55,039 --> 00:26:58,799
an interesting area to to look into like

00:26:57,840 --> 00:27:01,760
you could imagine

00:26:58,799 --> 00:27:03,360
that um in the debug information

00:27:01,760 --> 00:27:05,200
generated source will be

00:27:03,360 --> 00:27:07,440
put into there so that when the debugger

00:27:05,200 --> 00:27:09,679
runs it will

00:27:07,440 --> 00:27:11,520
see the generated code and then can

00:27:09,679 --> 00:27:14,240
display that to you

00:27:11,520 --> 00:27:16,320
it would be one way of implementing it

00:27:14,240 --> 00:27:19,919
what order do the generators

00:27:16,320 --> 00:27:20,559
run in um yes this will be declaration

00:27:19,919 --> 00:27:22,880
order

00:27:20,559 --> 00:27:24,000
um the order of the declarations in my

00:27:22,880 --> 00:27:26,399
class

00:27:24,000 --> 00:27:27,279
will be the order in which i iterate

00:27:26,399 --> 00:27:30,399
over them

00:27:27,279 --> 00:27:30,399
from the members of call

00:27:30,799 --> 00:27:37,360
right that's um

00:27:34,799 --> 00:27:39,679
an intro to code injection feel free to

00:27:37,360 --> 00:27:42,720
keep dropping in questions

00:27:39,679 --> 00:27:45,840
now we want to put code injection into

00:27:42,720 --> 00:27:46,480
dynamic polymorphism to generate all of

00:27:45,840 --> 00:27:48,000
that

00:27:46,480 --> 00:27:49,440
that massive block of code which i

00:27:48,000 --> 00:27:51,440
showed which i don't want to have to

00:27:49,440 --> 00:27:54,159
write every time i want to generate that

00:27:51,440 --> 00:27:54,159
automatically

00:27:54,640 --> 00:27:59,039
right so here is our original animal

00:27:57,440 --> 00:28:00,480
type which had the concrete pointer and

00:27:59,039 --> 00:28:02,399
the v table pointer and then all the

00:28:00,480 --> 00:28:03,679
constructors forwarding functions things

00:28:02,399 --> 00:28:05,440
like that

00:28:03,679 --> 00:28:06,720
now i want to make this general so i'm

00:28:05,440 --> 00:28:09,600
going to change this

00:28:06,720 --> 00:28:11,600
into a template i'm going to call it

00:28:09,600 --> 00:28:13,520
type class 4 because it's kind of like

00:28:11,600 --> 00:28:16,480
haskell type classes or

00:28:13,520 --> 00:28:17,440
or rust traits so the changes i made

00:28:16,480 --> 00:28:20,559
here were

00:28:17,440 --> 00:28:22,159
this was my animal now it's a template

00:28:20,559 --> 00:28:25,440
it takes some

00:28:22,159 --> 00:28:27,039
template parameter which i call facade

00:28:25,440 --> 00:28:29,120
and the only other change is that

00:28:27,039 --> 00:28:31,120
instead of a v table

00:28:29,120 --> 00:28:32,720
v table is now a template and i give it

00:28:31,120 --> 00:28:35,279
my facade

00:28:32,720 --> 00:28:37,200
now a facade is going to be a

00:28:35,279 --> 00:28:39,279
description of the interface

00:28:37,200 --> 00:28:41,039
for your type and it's going to look

00:28:39,279 --> 00:28:44,080
something like this

00:28:41,039 --> 00:28:45,120
a facade for an animal is just a

00:28:44,080 --> 00:28:47,520
declaration for

00:28:45,120 --> 00:28:48,799
the speak function this speak function

00:28:47,520 --> 00:28:51,520
will never be defined

00:28:48,799 --> 00:28:52,480
i will never write code for animal

00:28:51,520 --> 00:28:55,120
facade

00:28:52,480 --> 00:28:55,760
speak it's just a declaration it's like

00:28:55,120 --> 00:28:57,919
a blank

00:28:55,760 --> 00:29:00,000
interface which says here's what an

00:28:57,919 --> 00:29:02,320
animal should look like

00:29:00,000 --> 00:29:03,520
you can think of it as a concept but

00:29:02,320 --> 00:29:05,600
instead of defined

00:29:03,520 --> 00:29:08,159
on usage patterns is defined on

00:29:05,600 --> 00:29:08,159
signatures

00:29:09,039 --> 00:29:12,399
and then if i wanted to have my animal

00:29:10,799 --> 00:29:16,320
class i would say an animal

00:29:12,399 --> 00:29:18,640
is a type class for an animal facade

00:29:16,320 --> 00:29:22,640
and this should give me all the behavior

00:29:18,640 --> 00:29:22,640
which i had for my handwritten version

00:29:23,600 --> 00:29:27,360
right code injected virtual functions

00:29:25,360 --> 00:29:29,520
i'm going to follow exactly the same

00:29:27,360 --> 00:29:31,679
order of operations which i did for when

00:29:29,520 --> 00:29:33,520
we wrote all of this by hand

00:29:31,679 --> 00:29:35,760
but instead we're going to inject this

00:29:33,520 --> 00:29:35,760
code

00:29:36,000 --> 00:29:40,000
first declaring the v table this was our

00:29:39,200 --> 00:29:43,520
v table which we

00:29:40,000 --> 00:29:45,840
had now these last three are going to be

00:29:43,520 --> 00:29:47,440
the same but we're not going to be

00:29:45,840 --> 00:29:50,000
changing these depending on

00:29:47,440 --> 00:29:50,880
um on what our type is but that speak

00:29:50,000 --> 00:29:52,240
function will

00:29:50,880 --> 00:29:54,080
because you know we might have any

00:29:52,240 --> 00:29:55,360
number of functions in here

00:29:54,080 --> 00:29:57,120
they might have different return types

00:29:55,360 --> 00:29:58,000
different parameter types things like

00:29:57,120 --> 00:30:00,399
that

00:29:58,000 --> 00:30:01,039
what does click type class 4 do type

00:30:00,399 --> 00:30:04,080
class 4

00:30:01,039 --> 00:30:05,760
is the representation it's like the the

00:30:04,080 --> 00:30:06,320
general version of animal which will

00:30:05,760 --> 00:30:09,840
work for

00:30:06,320 --> 00:30:11,279
any facade with this ad overhead for

00:30:09,840 --> 00:30:14,240
compiler debug i'm going to

00:30:11,279 --> 00:30:14,240
talk about that at the end

00:30:14,640 --> 00:30:19,360
um so we want to generate this speak

00:30:17,600 --> 00:30:22,960
function pointer

00:30:19,360 --> 00:30:23,679
um in code so our v table we have our

00:30:22,960 --> 00:30:25,600
facade

00:30:23,679 --> 00:30:27,039
and we want to generate for every

00:30:25,600 --> 00:30:28,960
function in the facade we want to

00:30:27,039 --> 00:30:32,080
generate a function pointer

00:30:28,960 --> 00:30:33,440
in our v table so of course we're going

00:30:32,080 --> 00:30:36,240
to have a constant eval block we want to

00:30:33,440 --> 00:30:38,480
do this at compile time

00:30:36,240 --> 00:30:40,399
and here's where the magic is so this

00:30:38,480 --> 00:30:42,159
for each declared function thing

00:30:40,399 --> 00:30:43,679
is not a standard thing it's just a

00:30:42,159 --> 00:30:46,159
little helper i wrote because

00:30:43,679 --> 00:30:47,440
i end up having to do this a lot um i

00:30:46,159 --> 00:30:48,799
don't show the implementation

00:30:47,440 --> 00:30:50,799
it's not that interesting but it just

00:30:48,799 --> 00:30:52,720
reflects over the facade and for every

00:30:50,799 --> 00:30:54,799
declared function in it

00:30:52,720 --> 00:30:56,720
it will call this lambda with the

00:30:54,799 --> 00:30:58,240
function reflection the return type and

00:30:56,720 --> 00:31:01,440
the parameters it just

00:30:58,240 --> 00:31:01,440
cleans up the code a lot

00:31:01,519 --> 00:31:08,240
so i want to inject

00:31:04,640 --> 00:31:10,480
a class fragment with that um

00:31:08,240 --> 00:31:12,480
that function pointer type and now

00:31:10,480 --> 00:31:13,600
similarly to earlier i'm going to slowly

00:31:12,480 --> 00:31:15,600
transform

00:31:13,600 --> 00:31:17,679
this function pointer type into the

00:31:15,600 --> 00:31:19,760
generic version

00:31:17,679 --> 00:31:21,600
so first we want to change our return

00:31:19,760 --> 00:31:25,039
type into

00:31:21,600 --> 00:31:28,159
the type name of the return type for the

00:31:25,039 --> 00:31:30,480
um function which we're reading

00:31:28,159 --> 00:31:32,640
we want to change the name to the name

00:31:30,480 --> 00:31:34,320
of that function

00:31:32,640 --> 00:31:35,679
and we also want to inject any

00:31:34,320 --> 00:31:38,799
additional parameters

00:31:35,679 --> 00:31:39,679
so if uh if speak took some other

00:31:38,799 --> 00:31:43,600
parameters

00:31:39,679 --> 00:31:45,679
then they would end up injected in here

00:31:43,600 --> 00:31:48,000
the question does order of compilation

00:31:45,679 --> 00:31:51,210
matter between where getters are invoked

00:31:48,000 --> 00:31:52,960
to where they're created um

00:31:51,210 --> 00:31:55,600
[Music]

00:31:52,960 --> 00:31:56,480
i'm going to come back to that once i

00:31:55,600 --> 00:31:59,279
finish this

00:31:56,480 --> 00:32:00,159
train of thought so this is our generic

00:31:59,279 --> 00:32:03,120
version of

00:32:00,159 --> 00:32:04,480
our rv table for every function which is

00:32:03,120 --> 00:32:06,480
declared in the facade we're going to

00:32:04,480 --> 00:32:09,519
generate

00:32:06,480 --> 00:32:10,240
a function pointer now we're going to

00:32:09,519 --> 00:32:13,600
define our v

00:32:10,240 --> 00:32:16,799
table we want to

00:32:13,600 --> 00:32:17,360
fill in every pointer in the virtual

00:32:16,799 --> 00:32:19,200
table

00:32:17,360 --> 00:32:20,799
with something which does a static cast

00:32:19,200 --> 00:32:24,240
the right type and then

00:32:20,799 --> 00:32:24,240
calls the correct function

00:32:25,360 --> 00:32:29,440
so it looks something like this we're

00:32:26,559 --> 00:32:31,039
going to inject a block fragment

00:32:29,440 --> 00:32:32,480
and we're going to do transformations

00:32:31,039 --> 00:32:35,519
again we're going to

00:32:32,480 --> 00:32:37,919
do on call id which when the quest says

00:32:35,519 --> 00:32:39,440
unqualid just takes a reflection and

00:32:37,919 --> 00:32:41,519
gives you its identifier

00:32:39,440 --> 00:32:42,799
so if the function was called speak then

00:32:41,519 --> 00:32:46,320
this would give you table

00:32:42,799 --> 00:32:48,640
dot speak like this

00:32:46,320 --> 00:32:52,720
speak we change it to on quality gives

00:32:48,640 --> 00:32:52,720
you the name of it as an identifier

00:32:53,039 --> 00:32:56,799
then we are going to use our if we have

00:32:55,120 --> 00:33:00,000
any additional parameters

00:32:56,799 --> 00:33:00,960
we inject the types into that lambda

00:33:00,000 --> 00:33:02,080
declaration

00:33:00,960 --> 00:33:04,640
the into the signature and the

00:33:02,080 --> 00:33:07,440
parameters and we also want to

00:33:04,640 --> 00:33:08,880
pass those parameters inside the body of

00:33:07,440 --> 00:33:10,880
the function

00:33:08,880 --> 00:33:12,640
finally in case the function returns

00:33:10,880 --> 00:33:12,960
anything you know speak returned void

00:33:12,640 --> 00:33:14,640
but

00:33:12,960 --> 00:33:17,279
if something returns an in or whatever

00:33:14,640 --> 00:33:19,519
then we need to return

00:33:17,279 --> 00:33:19,519
all right

00:33:20,399 --> 00:33:23,679
gonna leave this up for just a second

00:33:21,840 --> 00:33:24,320
because there's a lot of new concepts

00:33:23,679 --> 00:33:28,960
here

00:33:24,320 --> 00:33:30,640
and the code looks really weird

00:33:28,960 --> 00:33:32,159
but hopefully you can see that the point

00:33:30,640 --> 00:33:34,320
is you take

00:33:32,159 --> 00:33:35,600
what you want to generate and you slowly

00:33:34,320 --> 00:33:38,559
generalize it

00:33:35,600 --> 00:33:41,679
by taking information from the

00:33:38,559 --> 00:33:41,679
reflection of your types

00:33:42,399 --> 00:33:46,000
all right capturing the v table pointers

00:33:44,399 --> 00:33:49,200
this is essentially the same

00:33:46,000 --> 00:33:51,360
as before we have to

00:33:49,200 --> 00:33:52,960
dynamically allocate copy and we capture

00:33:51,360 --> 00:33:54,399
the v table the only difference is that

00:33:52,960 --> 00:33:57,919
we pass our facade

00:33:54,399 --> 00:33:59,440
as um as a template parameter

00:33:57,919 --> 00:34:01,440
to our v table so we know what we're

00:33:59,440 --> 00:34:04,399
generating for

00:34:01,440 --> 00:34:06,080
question is what exactly was arrow

00:34:04,399 --> 00:34:08,639
params that injects

00:34:06,080 --> 00:34:09,760
all of the parameter types into here so

00:34:08,639 --> 00:34:13,440
if we had

00:34:09,760 --> 00:34:15,919
a function which took three integers

00:34:13,440 --> 00:34:16,879
then this is gonna add three integers

00:34:15,919 --> 00:34:19,359
into the

00:34:16,879 --> 00:34:21,839
um into the parameter list for this

00:34:19,359 --> 00:34:21,839
function

00:34:21,919 --> 00:34:26,000
would you need to add stood forward or

00:34:24,320 --> 00:34:29,919
something to the params pack

00:34:26,000 --> 00:34:33,359
uh yes you would you'd want to use

00:34:29,919 --> 00:34:34,960
like um decal type and forward on

00:34:33,359 --> 00:34:38,240
the deckle type if you're doing it

00:34:34,960 --> 00:34:38,240
generically yeah

00:34:38,960 --> 00:34:42,560
can we generate classes with a virtual

00:34:41,679 --> 00:34:46,079
function

00:34:42,560 --> 00:34:48,720
oh that one disappeared well

00:34:46,079 --> 00:34:50,399
suddenly lots of questions okay right

00:34:48,720 --> 00:34:53,520
i'm gonna work through these the top

00:34:50,399 --> 00:34:54,879
all right how does the params work i've

00:34:53,520 --> 00:34:56,639
already answered that one

00:34:54,879 --> 00:34:58,480
is params a very addict pack or

00:34:56,639 --> 00:35:01,520
something different

00:34:58,480 --> 00:35:04,960
it's um

00:35:01,520 --> 00:35:06,480
so come back to

00:35:04,960 --> 00:35:08,400
get params back on the screen since

00:35:06,480 --> 00:35:11,839
there's lots of questions about that

00:35:08,400 --> 00:35:14,839
so this dot dot params um

00:35:11,839 --> 00:35:16,960
it's not quite a variatic pack this is

00:35:14,839 --> 00:35:19,119
expanding um

00:35:16,960 --> 00:35:20,800
it's kind of like variatic reflection

00:35:19,119 --> 00:35:22,560
information this is

00:35:20,800 --> 00:35:24,400
kind of weird syntax you know if this

00:35:22,560 --> 00:35:26,720
was a variatic pack then the

00:35:24,400 --> 00:35:27,760
dot would be after this is a little bit

00:35:26,720 --> 00:35:30,240
different

00:35:27,760 --> 00:35:30,880
the fragments require full statements or

00:35:30,240 --> 00:35:34,480
can they be

00:35:30,880 --> 00:35:37,839
partial um i think if fragments

00:35:34,480 --> 00:35:38,880
have to be full statements you can't

00:35:37,839 --> 00:35:42,800
have

00:35:38,880 --> 00:35:46,400
just like random bits of code

00:35:42,800 --> 00:35:47,920
um because what they mean might differ

00:35:46,400 --> 00:35:50,320
very very differently depending on the

00:35:47,920 --> 00:35:51,599
context

00:35:50,320 --> 00:35:53,440
are there any compilers out there that

00:35:51,599 --> 00:35:55,280
currently support this uh

00:35:53,440 --> 00:35:57,280
yes there is a experimental

00:35:55,280 --> 00:35:58,160
implementation from lock 3 based on

00:35:57,280 --> 00:36:01,520
clang

00:35:58,160 --> 00:36:02,960
and edg are also working on a version

00:36:01,520 --> 00:36:04,480
there's some way to view the resulting

00:36:02,960 --> 00:36:05,680
generated code yes i mentioned that

00:36:04,480 --> 00:36:08,079
earlier the

00:36:05,680 --> 00:36:09,760
log 3 version lets you print out what

00:36:08,079 --> 00:36:12,800
code is generated

00:36:09,760 --> 00:36:14,400
um do i have to forward the prams

00:36:12,800 --> 00:36:15,839
already answer that one can we generate

00:36:14,400 --> 00:36:17,760
classes with a virtual function where

00:36:15,839 --> 00:36:20,960
the classes

00:36:17,760 --> 00:36:24,240
are all the combination of all

00:36:20,960 --> 00:36:27,280
base classes um

00:36:24,240 --> 00:36:29,680
i'm currently on

00:36:27,280 --> 00:36:31,440
talk adrenaline and can't parse this

00:36:29,680 --> 00:36:33,599
question so i might come back to that at

00:36:31,440 --> 00:36:36,320
the end

00:36:33,599 --> 00:36:37,599
so finally we have to forward our calls

00:36:36,320 --> 00:36:39,599
through the b table

00:36:37,599 --> 00:36:40,640
and i'm not going to dwell on the code

00:36:39,599 --> 00:36:42,640
here because it's

00:36:40,640 --> 00:36:44,640
quite complicated and it's mostly

00:36:42,640 --> 00:36:47,599
following the same patterns we've seen

00:36:44,640 --> 00:36:48,320
before um we're generating construct

00:36:47,599 --> 00:36:51,839
fragment

00:36:48,320 --> 00:36:53,680
we're generating a function declaration

00:36:51,839 --> 00:36:55,520
based on a reflection information and

00:36:53,680 --> 00:36:57,359
then generating an implementation which

00:36:55,520 --> 00:36:58,880
forwards a call

00:36:57,359 --> 00:37:00,640
you can go look at that i have a link to

00:36:58,880 --> 00:37:02,400
the code later which you can go look at

00:37:00,640 --> 00:37:05,599
i don't want to

00:37:02,400 --> 00:37:08,079
spend too much time on this so now

00:37:05,599 --> 00:37:09,760
we've taken all of that code which we

00:37:08,079 --> 00:37:11,680
wrote before when we were doing this by

00:37:09,760 --> 00:37:14,720
hand

00:37:11,680 --> 00:37:16,640
and we've changed it into this we now

00:37:14,720 --> 00:37:18,320
just say here's what our facade looks

00:37:16,640 --> 00:37:21,359
like and then

00:37:18,320 --> 00:37:23,359
we give our facade to type class 4 which

00:37:21,359 --> 00:37:26,480
is going to generate all of that code

00:37:23,359 --> 00:37:30,320
for us through code injection and

00:37:26,480 --> 00:37:32,480
we don't have to do anything else

00:37:30,320 --> 00:37:35,280
question is is this stuff being proposed

00:37:32,480 --> 00:37:39,200
for 23 26 29

00:37:35,280 --> 00:37:42,000
this the static reflection

00:37:39,200 --> 00:37:43,280
is targeting 23 i believe code injection

00:37:42,000 --> 00:37:45,680
i'm not sure

00:37:43,280 --> 00:37:49,599
uh i don't have an answer for that one

00:37:45,680 --> 00:37:49,599
um if someone knows please drop in chat

00:37:49,680 --> 00:37:56,640
all right um so one thing we could do

00:37:53,119 --> 00:37:57,920
is um you know i had this this hanging

00:37:56,640 --> 00:38:00,000
thing left of

00:37:57,920 --> 00:38:01,119
what about the dynamic allocation i

00:38:00,000 --> 00:38:04,240
promised that we were trying

00:38:01,119 --> 00:38:06,320
and deal with this

00:38:04,240 --> 00:38:08,560
we can now that we have a more general

00:38:06,320 --> 00:38:10,320
facility for generating this information

00:38:08,560 --> 00:38:13,280
what we could do

00:38:10,320 --> 00:38:15,599
is template our type class on some

00:38:13,280 --> 00:38:17,520
storage policy

00:38:15,599 --> 00:38:19,599
and this storage policy will tell us if

00:38:17,520 --> 00:38:20,480
we want to always dynamically allocate

00:38:19,599 --> 00:38:21,599
or

00:38:20,480 --> 00:38:24,320
you know have a small buffer

00:38:21,599 --> 00:38:26,400
optimization or always allocate in place

00:38:24,320 --> 00:38:28,400
things like that and then we could also

00:38:26,400 --> 00:38:28,960
take a policy for how to store the v

00:38:28,400 --> 00:38:30,800
table

00:38:28,960 --> 00:38:32,240
like do we want to store it remote or

00:38:30,800 --> 00:38:33,839
inside the class

00:38:32,240 --> 00:38:35,520
so that we only have to do one pointer

00:38:33,839 --> 00:38:36,960
in direction instead of two these are

00:38:35,520 --> 00:38:40,400
all options

00:38:36,960 --> 00:38:43,440
so some examples of how this could work

00:38:40,400 --> 00:38:45,040
is i could say okay type class for an

00:38:43,440 --> 00:38:47,920
animal facade this will give me some

00:38:45,040 --> 00:38:50,800
reasonable defaults it might give me

00:38:47,920 --> 00:38:53,520
a type class for an animal facade where

00:38:50,800 --> 00:38:55,839
i have remote storage i.e i always

00:38:53,520 --> 00:38:56,720
dynamically allocate the object i'm

00:38:55,839 --> 00:38:59,599
storing

00:38:56,720 --> 00:39:01,280
and i have a remote table i.e i have to

00:38:59,599 --> 00:39:04,400
do two pointer leaps

00:39:01,280 --> 00:39:07,200
for every function call

00:39:04,400 --> 00:39:08,800
i could then say okay actually i want a

00:39:07,200 --> 00:39:11,920
type class for animal facade

00:39:08,800 --> 00:39:13,520
where i have 32 bytes of small buffer

00:39:11,920 --> 00:39:15,760
optimization storage

00:39:13,520 --> 00:39:17,200
and i want to store my v table in place

00:39:15,760 --> 00:39:19,599
maybe i just have a couple

00:39:17,200 --> 00:39:22,720
of functions in my v table and i don't

00:39:19,599 --> 00:39:26,320
want to pay for that extra point or leap

00:39:22,720 --> 00:39:28,880
i could even say all right i want

00:39:26,320 --> 00:39:30,800
a type class or an animal facade where

00:39:28,880 --> 00:39:32,720
you store the object in place

00:39:30,800 --> 00:39:34,320
so i never dynamically allocate and if

00:39:32,720 --> 00:39:35,280
it's too big then through a compiler

00:39:34,320 --> 00:39:37,119
error

00:39:35,280 --> 00:39:38,880
and you know i have parts of my v table

00:39:37,119 --> 00:39:41,520
which are called a lot and parts which

00:39:38,880 --> 00:39:43,040
aren't so for the parts which are called

00:39:41,520 --> 00:39:44,800
a lot i want to store them in place so i

00:39:43,040 --> 00:39:46,480
don't have to do two pointer leaps

00:39:44,800 --> 00:39:48,000
and for everything else i want to store

00:39:46,480 --> 00:39:49,920
that off

00:39:48,000 --> 00:39:51,440
um elsewhere so i'm not paying for too

00:39:49,920 --> 00:39:54,560
much extra space

00:39:51,440 --> 00:39:55,680
in my animal object so like this is so

00:39:54,560 --> 00:39:59,359
flexible you could do

00:39:55,680 --> 00:40:01,680
anything here it's uh it's kind of cool

00:39:59,359 --> 00:40:02,560
uh one question is how settled is this

00:40:01,680 --> 00:40:06,079
syntax

00:40:02,560 --> 00:40:08,240
um it's not the

00:40:06,079 --> 00:40:10,030
um the injection code especially is not

00:40:08,240 --> 00:40:11,359
settled the um

00:40:10,030 --> 00:40:13,599
[Music]

00:40:11,359 --> 00:40:14,400
most of the reflection stuff is as far

00:40:13,599 --> 00:40:16,240
as i'm aware

00:40:14,400 --> 00:40:18,079
which herb's metaclasses help make the

00:40:16,240 --> 00:40:19,920
reflective code more readable i'm so

00:40:18,079 --> 00:40:22,800
glad you asked because we're just about

00:40:19,920 --> 00:40:22,800
to talk about that

00:40:22,839 --> 00:40:28,640
um yeah

00:40:24,560 --> 00:40:29,280
move on so this was our pro these were

00:40:28,640 --> 00:40:30,720
our problems

00:40:29,280 --> 00:40:32,400
and we were still left off with the

00:40:30,720 --> 00:40:34,480
dynamic allocation problem

00:40:32,400 --> 00:40:35,599
and i think that we've solved that

00:40:34,480 --> 00:40:37,680
pretty much as best

00:40:35,599 --> 00:40:39,359
we can like you're always going to have

00:40:37,680 --> 00:40:41,760
the problem where if you have an open

00:40:39,359 --> 00:40:44,720
set of types which you want to support

00:40:41,760 --> 00:40:46,079
then you need to have some way of

00:40:44,720 --> 00:40:48,560
dealing with that either

00:40:46,079 --> 00:40:50,880
always allocating or allocating with a

00:40:48,560 --> 00:40:53,040
small buffer optimization or

00:40:50,880 --> 00:40:55,359
and storing everything in place and

00:40:53,040 --> 00:40:57,040
compiler error if something's too big

00:40:55,359 --> 00:40:58,720
uh these are kind of fundamental issues

00:40:57,040 --> 00:41:01,200
and i think we're doing about as good as

00:40:58,720 --> 00:41:01,200
we can do

00:41:01,440 --> 00:41:04,720
but we can do better someone just asked

00:41:03,440 --> 00:41:08,079
about meta classes

00:41:04,720 --> 00:41:10,880
what if we could take this code

00:41:08,079 --> 00:41:10,880
and do this

00:41:11,680 --> 00:41:19,359
so this again is some new syntax this

00:41:16,160 --> 00:41:21,920
uses type class as a metaclass so

00:41:19,359 --> 00:41:22,480
this is saying that animal is some type

00:41:21,920 --> 00:41:24,800
class

00:41:22,480 --> 00:41:26,319
and this will generate an animal class

00:41:24,800 --> 00:41:30,079
which is equivalent

00:41:26,319 --> 00:41:33,520
to had we done this all right

00:41:30,079 --> 00:41:34,640
it's it's a small change but it's kind

00:41:33,520 --> 00:41:36,480
of powerful

00:41:34,640 --> 00:41:37,680
like we're now not just saying that you

00:41:36,480 --> 00:41:39,440
know we have a facade and then we're

00:41:37,680 --> 00:41:41,280
generating some

00:41:39,440 --> 00:41:43,040
um some type class for this thing we're

00:41:41,280 --> 00:41:44,960
saying like okay right animal is a type

00:41:43,040 --> 00:41:48,480
class

00:41:44,960 --> 00:41:51,839
it's like it's self-documenting in

00:41:48,480 --> 00:41:57,680
what it means not like this this facade

00:41:51,839 --> 00:42:02,560
and then um using a type class for it

00:41:57,680 --> 00:42:04,880
so let's talk about math classes

00:42:02,560 --> 00:42:06,880
this is a definition from the paper um

00:42:04,880 --> 00:42:07,760
it's proposed by herb sutter currently

00:42:06,880 --> 00:42:10,000
does not have

00:42:07,760 --> 00:42:11,280
a standard version as targeting as far

00:42:10,000 --> 00:42:13,200
as i'm aware

00:42:11,280 --> 00:42:14,640
says metaclass functions let programmers

00:42:13,200 --> 00:42:15,440
write a new kind of efficient

00:42:14,640 --> 00:42:18,240
abstraction

00:42:15,440 --> 00:42:19,599
a user-defined named subset of classes

00:42:18,240 --> 00:42:22,000
that share common

00:42:19,599 --> 00:42:22,640
characteristics such as user-defined

00:42:22,000 --> 00:42:25,440
rules

00:42:22,640 --> 00:42:26,480
defaults and generated functions in the

00:42:25,440 --> 00:42:28,319
case here

00:42:26,480 --> 00:42:31,680
i use generated functions that's the

00:42:28,319 --> 00:42:33,680
main part i'm using

00:42:31,680 --> 00:42:34,800
for example coming back to our point

00:42:33,680 --> 00:42:36,720
object

00:42:34,800 --> 00:42:38,319
now currently the point is just an x and

00:42:36,720 --> 00:42:40,560
a y we don't have

00:42:38,319 --> 00:42:42,560
like comparison object we don't have

00:42:40,560 --> 00:42:45,440
comparison operators for it

00:42:42,560 --> 00:42:46,800
we haven't defined any constructors or

00:42:45,440 --> 00:42:50,240
anything like that

00:42:46,800 --> 00:42:52,160
uh you know some people would use a

00:42:50,240 --> 00:42:53,440
stood pair instead because stud pair

00:42:52,160 --> 00:42:55,280
does all of that but then

00:42:53,440 --> 00:42:57,440
you know you have to use first and that

00:42:55,280 --> 00:42:58,079
second it's a pain what we really want

00:42:57,440 --> 00:43:00,800
is to say

00:42:58,079 --> 00:43:02,160
like point is essentially a stood pair

00:43:00,800 --> 00:43:04,400
with names

00:43:02,160 --> 00:43:05,599
or more generally point i want you to

00:43:04,400 --> 00:43:08,960
just treat it like

00:43:05,599 --> 00:43:10,720
a value i want it to have everything

00:43:08,960 --> 00:43:13,599
which you might expect from a

00:43:10,720 --> 00:43:16,800
well-written value type

00:43:13,599 --> 00:43:18,880
so maybe we could do this and by

00:43:16,800 --> 00:43:20,560
saying okay i'm a value that will define

00:43:18,880 --> 00:43:22,880
all of your comparison operators we'll

00:43:20,560 --> 00:43:25,359
define constructors for you

00:43:22,880 --> 00:43:28,400
and generate all that code without you

00:43:25,359 --> 00:43:28,400
having to do anything

00:43:28,960 --> 00:43:34,880
so value here we're seeing

00:43:32,079 --> 00:43:35,680
class and value in brackets what value

00:43:34,880 --> 00:43:39,680
is

00:43:35,680 --> 00:43:41,680
is our cons eval function which takes

00:43:39,680 --> 00:43:43,520
some reflection information this meta

00:43:41,680 --> 00:43:46,400
info is the same thing we saw

00:43:43,520 --> 00:43:48,079
earlier and then inside this function

00:43:46,400 --> 00:43:50,640
we're going to have a bunch of injection

00:43:48,079 --> 00:43:50,640
statements

00:43:51,200 --> 00:43:55,359
now a cool thing is you could go and

00:43:53,119 --> 00:43:57,040
read the meta classes paper

00:43:55,359 --> 00:43:58,319
and i think you should it's a really

00:43:57,040 --> 00:43:59,359
interesting paper and has a lot of

00:43:58,319 --> 00:44:02,240
motivation

00:43:59,359 --> 00:44:02,720
and great examples but also i can pretty

00:44:02,240 --> 00:44:05,920
much

00:44:02,720 --> 00:44:09,200
describe it on this slide if we have

00:44:05,920 --> 00:44:12,319
a point class which um

00:44:09,200 --> 00:44:15,920
we use values that's metaclass then this

00:44:12,319 --> 00:44:18,400
is the same as if we copied

00:44:15,920 --> 00:44:20,400
the definition of point into some hidden

00:44:18,400 --> 00:44:22,560
namespace and some prototype

00:44:20,400 --> 00:44:24,319
you know we've just taken the whole body

00:44:22,560 --> 00:44:26,400
of the class and

00:44:24,319 --> 00:44:28,720
copied the text essentially somewhere

00:44:26,400 --> 00:44:28,720
else

00:44:29,200 --> 00:44:36,240
then we define a point class

00:44:32,319 --> 00:44:38,800
which calls value in a const eval

00:44:36,240 --> 00:44:38,800
context

00:44:39,280 --> 00:44:42,480
all right i'll go through that again we

00:44:40,640 --> 00:44:44,480
have our point class which uses value as

00:44:42,480 --> 00:44:47,119
a metaclass we just copy the thing

00:44:44,480 --> 00:44:48,079
somewhere and then we call value on that

00:44:47,119 --> 00:44:50,720
type

00:44:48,079 --> 00:44:52,800
which we generated and this is

00:44:50,720 --> 00:44:54,640
metaclasses in a slide

00:44:52,800 --> 00:44:55,920
based on all that we learned about

00:44:54,640 --> 00:44:59,599
static reflection

00:44:55,920 --> 00:45:00,720
and code injection this builds upon it

00:44:59,599 --> 00:45:04,160
and

00:45:00,720 --> 00:45:06,800
has a kind of simple looking

00:45:04,160 --> 00:45:08,000
implementation but gives you a lot of

00:45:06,800 --> 00:45:11,119
power and expressive

00:45:08,000 --> 00:45:11,119
and expressiveness

00:45:12,640 --> 00:45:15,920
so similarly you would have a type class

00:45:15,359 --> 00:45:18,160
function

00:45:15,920 --> 00:45:22,079
which does the equivalent to everything

00:45:18,160 --> 00:45:22,079
we wrote in our type class for

00:45:22,240 --> 00:45:26,000
and then you would say okay i have an

00:45:24,240 --> 00:45:28,160
animal which uses type class as

00:45:26,000 --> 00:45:29,040
metaclass and now i can have a vector of

00:45:28,160 --> 00:45:30,960
animals i can

00:45:29,040 --> 00:45:33,520
copy them i can move them i can pass

00:45:30,960 --> 00:45:37,280
them around i can call speak on anything

00:45:33,520 --> 00:45:37,280
which conforms to this interface

00:45:38,079 --> 00:45:41,520
i like this a lot personally

00:45:41,599 --> 00:45:46,640
there are some concerns um

00:45:45,040 --> 00:45:48,800
one is runtime performance you know i'm

00:45:46,640 --> 00:45:52,880
generating all of this by hand

00:45:48,800 --> 00:45:53,520
uh based on the experimental compiler

00:45:52,880 --> 00:45:55,760
that i

00:45:53,520 --> 00:45:57,119
wrote all this in sometimes the compiler

00:45:55,760 --> 00:45:58,079
sees through everything and all just

00:45:57,119 --> 00:46:01,680
goes away and it's

00:45:58,079 --> 00:46:03,119
phenomenal um other times it does not

00:46:01,680 --> 00:46:04,800
especially because some compilers have

00:46:03,119 --> 00:46:07,040
been doing a lot of work in d

00:46:04,800 --> 00:46:10,160
virtualization like gcc

00:46:07,040 --> 00:46:13,200
um there will be times the the

00:46:10,160 --> 00:46:14,000
virtual functions will give you better

00:46:13,200 --> 00:46:17,119
performance for

00:46:14,000 --> 00:46:19,040
some um for some use cases

00:46:17,119 --> 00:46:21,119
i expect that if techniques like this

00:46:19,040 --> 00:46:21,839
become more commonplace then compilers

00:46:21,119 --> 00:46:25,280
would

00:46:21,839 --> 00:46:26,880
do their best to optimize those cases

00:46:25,280 --> 00:46:28,880
so i don't have too much too many

00:46:26,880 --> 00:46:30,480
concerns on runtime performance like

00:46:28,880 --> 00:46:32,079
there's so much scope for improving

00:46:30,480 --> 00:46:34,240
runtime performance with things like

00:46:32,079 --> 00:46:36,800
controlling the dynamic allocation

00:46:34,240 --> 00:46:38,560
that the the compiler optimizations can

00:46:36,800 --> 00:46:41,520
catch up

00:46:38,560 --> 00:46:42,800
another is compile time performance the

00:46:41,520 --> 00:46:45,920
clang implementation

00:46:42,800 --> 00:46:47,599
which i used uh is not optimized for

00:46:45,920 --> 00:46:51,440
compile time performance yet

00:46:47,599 --> 00:46:53,359
and i don't want to make any um

00:46:51,440 --> 00:46:54,560
measurements there because it wouldn't

00:46:53,359 --> 00:46:57,680
be fair

00:46:54,560 --> 00:46:58,960
however the edg folks um have reported

00:46:57,680 --> 00:47:01,280
that their

00:46:58,960 --> 00:47:02,720
version gives very good performance

00:47:01,280 --> 00:47:04,880
actually better than

00:47:02,720 --> 00:47:05,920
um than some stuff based on meta

00:47:04,880 --> 00:47:06,720
programming because you know meta

00:47:05,920 --> 00:47:08,400
programming

00:47:06,720 --> 00:47:10,079
you end up creating a bunch of types

00:47:08,400 --> 00:47:12,079
which have to be cached and then that

00:47:10,079 --> 00:47:13,359
explodes symbol tables and things like

00:47:12,079 --> 00:47:15,040
that whereas this

00:47:13,359 --> 00:47:16,880
is a little bit different and they can

00:47:15,040 --> 00:47:18,800
optimize in a different way so

00:47:16,880 --> 00:47:20,480
according to the edg folks who were

00:47:18,800 --> 00:47:21,440
probably the people i would maybe trust

00:47:20,480 --> 00:47:24,400
the most

00:47:21,440 --> 00:47:25,760
on this kind of thing then the compile

00:47:24,400 --> 00:47:26,880
time performance might actually be

00:47:25,760 --> 00:47:29,040
better than

00:47:26,880 --> 00:47:31,359
um than equivalence which we're using

00:47:29,040 --> 00:47:31,359
today

00:47:31,440 --> 00:47:35,440
my kind of more fundamental like

00:47:33,680 --> 00:47:37,599
philosophical concern with this

00:47:35,440 --> 00:47:40,240
is it's kind of a new and incompatible

00:47:37,599 --> 00:47:42,720
way of specifying concepts

00:47:40,240 --> 00:47:44,160
uh like i said earlier the concepts are

00:47:42,720 --> 00:47:47,119
based on usage patterns

00:47:44,160 --> 00:47:47,760
you say oh i can call dot speak on this

00:47:47,119 --> 00:47:50,640
thing

00:47:47,760 --> 00:47:51,520
whereas um this version is oh well i

00:47:50,640 --> 00:47:54,559
have a

00:47:51,520 --> 00:47:55,119
class which has a speak function which

00:47:54,559 --> 00:47:57,839
is

00:47:55,119 --> 00:47:58,319
subtly different and it means that you

00:47:57,839 --> 00:48:00,240
know

00:47:58,319 --> 00:48:02,160
if this became commonplace then maybe

00:48:00,240 --> 00:48:04,400
you would want to have some concept

00:48:02,160 --> 00:48:06,960
which you use at both compile time and

00:48:04,400 --> 00:48:09,280
runtime you know you want to constrain

00:48:06,960 --> 00:48:10,079
a template by saying okay you can pass

00:48:09,280 --> 00:48:13,359
me anything

00:48:10,079 --> 00:48:15,760
which conforms to this interface

00:48:13,359 --> 00:48:17,440
and do it all compile time but you might

00:48:15,760 --> 00:48:19,040
also want to say oh i also want to store

00:48:17,440 --> 00:48:20,480
a vector of these things

00:48:19,040 --> 00:48:22,960
well with this approach you would have

00:48:20,480 --> 00:48:25,119
to um

00:48:22,960 --> 00:48:27,040
implement those concepts twice once

00:48:25,119 --> 00:48:29,200
using this like facade

00:48:27,040 --> 00:48:31,040
style and once using the sequels 20

00:48:29,200 --> 00:48:32,800
concept style

00:48:31,040 --> 00:48:34,800
i don't have a good answer there one

00:48:32,800 --> 00:48:36,400
option would be to

00:48:34,800 --> 00:48:38,160
actually do something like virtual

00:48:36,400 --> 00:48:42,400
concepts which have been

00:48:38,160 --> 00:48:45,280
um proposed before and just build this

00:48:42,400 --> 00:48:46,079
implementation or this style programming

00:48:45,280 --> 00:48:50,000
into

00:48:46,079 --> 00:48:52,880
the the compiler um another one would be

00:48:50,000 --> 00:48:54,160
trying to define some way of reflecting

00:48:52,880 --> 00:48:55,599
over concepts

00:48:54,160 --> 00:48:57,680
such that you could generate an

00:48:55,599 --> 00:48:59,040
interface but i'm pretty sure that's

00:48:57,680 --> 00:49:00,880
undecidable

00:48:59,040 --> 00:49:02,640
so you might be able to do it for a

00:49:00,880 --> 00:49:05,440
bunch of cases but

00:49:02,640 --> 00:49:08,880
um i might be wrong but it doesn't seem

00:49:05,440 --> 00:49:12,319
like it would be possible in all cases

00:49:08,880 --> 00:49:14,960
so those are some some concerns there is

00:49:12,319 --> 00:49:16,480
a lot of future work there's a paper

00:49:14,960 --> 00:49:18,319
called pfa which

00:49:16,480 --> 00:49:19,920
um kind of encodes a bunch of what i've

00:49:18,319 --> 00:49:22,400
been saying in a

00:49:19,920 --> 00:49:23,119
um in an actual like sequel plus

00:49:22,400 --> 00:49:26,160
interface

00:49:23,119 --> 00:49:28,079
and um should be implementable using the

00:49:26,160 --> 00:49:29,920
experimental compiler so you can go read

00:49:28,079 --> 00:49:32,559
that

00:49:29,920 --> 00:49:33,520
some links um the code i wrote for this

00:49:32,559 --> 00:49:36,240
talk is on

00:49:33,520 --> 00:49:38,720
compiler explorer um i have a slightly

00:49:36,240 --> 00:49:40,319
different prototype implementation which

00:49:38,720 --> 00:49:43,760
um you know implements things a bit

00:49:40,319 --> 00:49:45,920
different but it's better commented

00:49:43,760 --> 00:49:48,000
and that's on github you can check out

00:49:45,920 --> 00:49:51,280
the experimental compiler from lock

00:49:48,000 --> 00:49:52,720
3 on git lab and also on compiler

00:49:51,280 --> 00:49:54,079
explorer to play around with it which is

00:49:52,720 --> 00:49:56,559
really nice

00:49:54,079 --> 00:49:57,440
the scalable reflection sequence paper

00:49:56,559 --> 00:49:59,520
is linked to

00:49:57,440 --> 00:50:01,280
there as well as the metic classes one

00:49:59,520 --> 00:50:03,599
so i highly recommend going and checking

00:50:01,280 --> 00:50:05,280
those out

00:50:03,599 --> 00:50:06,880
finally like i mentioned start please

00:50:05,280 --> 00:50:10,000
come talk to us at our

00:50:06,880 --> 00:50:13,599
expo hall um at the microsoft table

00:50:10,000 --> 00:50:15,520
or our booth or our exhibitor room

00:50:13,599 --> 00:50:17,440
please do take our survey you can win

00:50:15,520 --> 00:50:21,280
flight simulator right here it's good

00:50:17,440 --> 00:50:22,960
i'm terrible at it we have a bunch of

00:50:21,280 --> 00:50:25,920
other sessions which you can either

00:50:22,960 --> 00:50:26,559
check out um when the videos come out or

00:50:25,920 --> 00:50:29,119
um

00:50:26,559 --> 00:50:30,240
or later in the conference this is my

00:50:29,119 --> 00:50:32,319
third talk so far

00:50:30,240 --> 00:50:34,160
the conference i had one on monday and

00:50:32,319 --> 00:50:36,319
one yesterday

00:50:34,160 --> 00:50:38,480
um and then these are the ones which are

00:50:36,319 --> 00:50:39,520
later on some about cross-platform

00:50:38,480 --> 00:50:41,599
development

00:50:39,520 --> 00:50:43,040
and code spaces for remote development

00:50:41,599 --> 00:50:46,880
and then a new open source

00:50:43,040 --> 00:50:49,280
buzzer with that i will thank you very

00:50:46,880 --> 00:50:50,640
much and i'll take the remainder of the

00:50:49,280 --> 00:50:52,079
questions

00:50:50,640 --> 00:50:54,079
the top question is there a compiler

00:50:52,079 --> 00:50:55,599
inside the library allows me to try this

00:50:54,079 --> 00:50:58,319
yes the lock three one go to give it a

00:50:55,599 --> 00:51:01,119
shot does the order of compilation

00:50:58,319 --> 00:51:01,760
matter between where the getters are

00:51:01,119 --> 00:51:04,720
invoked

00:51:01,760 --> 00:51:05,599
to where they are created as i just

00:51:04,720 --> 00:51:08,400
can't

00:51:05,599 --> 00:51:09,200
understand what this one is getting at

00:51:08,400 --> 00:51:13,520
the

00:51:09,200 --> 00:51:15,839
where the you have the const

00:51:13,520 --> 00:51:16,880
eval block which calls the generate

00:51:15,839 --> 00:51:19,680
getters function

00:51:16,880 --> 00:51:21,119
and when that exits when that conste val

00:51:19,680 --> 00:51:23,599
block completes

00:51:21,119 --> 00:51:25,520
then the code for the getters is going

00:51:23,599 --> 00:51:29,240
to be generated

00:51:25,520 --> 00:51:31,520
uh i hope that answers it feel free to

00:51:29,240 --> 00:51:34,319
re-phrase the question

00:51:31,520 --> 00:51:34,880
uh if if you'd like another question

00:51:34,319 --> 00:51:37,200
will

00:51:34,880 --> 00:51:39,440
compilers provide some switches that

00:51:37,200 --> 00:51:41,280
allow you to emit pre-processed code

00:51:39,440 --> 00:51:43,280
yeah like i said this is a an open

00:51:41,280 --> 00:51:44,400
tooling consideration like you could

00:51:43,280 --> 00:51:45,920
imagine

00:51:44,400 --> 00:51:48,319
multiple different ways of doing this

00:51:45,920 --> 00:51:50,559
you could have a

00:51:48,319 --> 00:51:52,160
c function which you could call to get

00:51:50,559 --> 00:51:53,760
the um

00:51:52,160 --> 00:51:55,119
the code which is generated and then do

00:51:53,760 --> 00:51:56,800
whatever you want with that you could

00:51:55,119 --> 00:51:58,400
have a compiler switch which emits the

00:51:56,800 --> 00:52:01,040
generated code

00:51:58,400 --> 00:52:02,720
uh you could have um something

00:52:01,040 --> 00:52:03,839
integrated in your ide

00:52:02,720 --> 00:52:06,480
there's a bunch of different ways you

00:52:03,839 --> 00:52:09,520
could implement it um and it's

00:52:06,480 --> 00:52:12,240
there's no there haven't been any

00:52:09,520 --> 00:52:12,960
like ways committed to yet uh as far as

00:52:12,240 --> 00:52:14,000
i know so

00:52:12,960 --> 00:52:15,839
yeah there's a bunch of different

00:52:14,000 --> 00:52:18,000
options there how does this compare to

00:52:15,839 --> 00:52:20,559
ross traits it's very similar

00:52:18,000 --> 00:52:21,359
one key difference is the the the

00:52:20,559 --> 00:52:24,640
implementation

00:52:21,359 --> 00:52:27,839
i just showed is um not

00:52:24,640 --> 00:52:28,880
opt in ie anything which satisfies the

00:52:27,839 --> 00:52:32,480
facade

00:52:28,880 --> 00:52:34,800
will be accepted um you could

00:52:32,480 --> 00:52:35,680
implement it in a different way and make

00:52:34,800 --> 00:52:37,359
it opt-in

00:52:35,680 --> 00:52:38,960
either by you know having a trait which

00:52:37,359 --> 00:52:42,640
you need to specify

00:52:38,960 --> 00:52:45,599
or having some way of mapping from a

00:52:42,640 --> 00:52:46,400
sad function to the functions in your

00:52:45,599 --> 00:52:48,000
type

00:52:46,400 --> 00:52:49,680
um there's a bunch of different options

00:52:48,000 --> 00:52:52,480
there that would be a lot closer to

00:52:49,680 --> 00:52:52,480
rust's traits

00:52:52,559 --> 00:52:55,760
i believe i've seen herb address

00:52:54,079 --> 00:52:56,960
concepts versus match classes and talk

00:52:55,760 --> 00:52:58,880
before and he claimed they're

00:52:56,960 --> 00:53:01,440
complementary but not overlapping

00:52:58,880 --> 00:53:02,160
yes the concepts and manta classes are

00:53:01,440 --> 00:53:03,920
but

00:53:02,160 --> 00:53:05,359
you know the the thing i'm presenting is

00:53:03,920 --> 00:53:06,480
something which is building on top of

00:53:05,359 --> 00:53:10,800
mata classes

00:53:06,480 --> 00:53:12,800
um and that does overlap with concepts

00:53:10,800 --> 00:53:14,559
about the list of three concerns you

00:53:12,800 --> 00:53:15,200
shared those concerns about the type

00:53:14,559 --> 00:53:16,559
four

00:53:15,200 --> 00:53:18,640
experiment you showed us and not

00:53:16,559 --> 00:53:22,079
concerns about reflection meta classes

00:53:18,640 --> 00:53:24,880
uh the three concerns i shared

00:53:22,079 --> 00:53:27,920
are these um yes so the runtime

00:53:24,880 --> 00:53:28,240
performance i'm talking about comparing

00:53:27,920 --> 00:53:30,640
my

00:53:28,240 --> 00:53:31,599
implementation versus virtual function

00:53:30,640 --> 00:53:34,240
calls

00:53:31,599 --> 00:53:35,440
so that's not um about reflection many

00:53:34,240 --> 00:53:37,280
classes that's about

00:53:35,440 --> 00:53:39,520
specifically this compile time

00:53:37,280 --> 00:53:42,640
performance is a bit more general like

00:53:39,520 --> 00:53:43,760
that would be um the compile-time

00:53:42,640 --> 00:53:47,200
performance of

00:53:43,760 --> 00:53:49,839
code injection and reflection versus

00:53:47,200 --> 00:53:50,880
um you know methods based on meta

00:53:49,839 --> 00:53:53,040
program we have

00:53:50,880 --> 00:53:54,880
that we have today and then the new and

00:53:53,040 --> 00:53:56,160
incompatible way of specifying concepts

00:53:54,880 --> 00:53:59,520
that again is specific

00:53:56,160 --> 00:54:01,680
to to what i'm presenting here

00:53:59,520 --> 00:54:02,559
is this user class code injection

00:54:01,680 --> 00:54:05,599
expected to

00:54:02,559 --> 00:54:08,400
be part of some c plus plus library

00:54:05,599 --> 00:54:09,680
um just like x bind or sb which use xml

00:54:08,400 --> 00:54:12,480
to generate code

00:54:09,680 --> 00:54:13,359
or remain at the programmer level so

00:54:12,480 --> 00:54:16,000
there's a few

00:54:13,359 --> 00:54:17,200
options like you could imagine that this

00:54:16,000 --> 00:54:20,559
could be part of

00:54:17,200 --> 00:54:20,559
the standard library

00:54:21,119 --> 00:54:28,240
where you'd have a stood type class

00:54:24,800 --> 00:54:29,599
meta class which you can use um

00:54:28,240 --> 00:54:31,359
so that would all live in the standard

00:54:29,599 --> 00:54:32,960
library you could also imagine that

00:54:31,359 --> 00:54:34,880
there's an external library

00:54:32,960 --> 00:54:36,559
like you know you get it off of github

00:54:34,880 --> 00:54:39,760
and you use someone's

00:54:36,559 --> 00:54:44,240
type class implementation

00:54:39,760 --> 00:54:46,319
so we'd live in in a in some library

00:54:44,240 --> 00:54:48,160
what's a reasonable path for gradually

00:54:46,319 --> 00:54:49,200
introducing these techniques into a code

00:54:48,160 --> 00:54:51,839
base as different

00:54:49,200 --> 00:54:53,920
pieces of as different pieces of needed

00:54:51,839 --> 00:54:56,799
machinery enter the standard

00:54:53,920 --> 00:54:58,160
um so i think for what i'm specifying

00:54:56,799 --> 00:55:01,359
here

00:54:58,160 --> 00:55:05,040
um you could do it with just

00:55:01,359 --> 00:55:07,440
um static reflection and code injection

00:55:05,040 --> 00:55:09,040
which means the static reflection is

00:55:07,440 --> 00:55:09,680
going to come before code injection most

00:55:09,040 --> 00:55:12,319
likely

00:55:09,680 --> 00:55:14,319
so when static reflection lands you'll

00:55:12,319 --> 00:55:16,160
still not be able to to implement this

00:55:14,319 --> 00:55:19,359
without doing a bunch of other

00:55:16,160 --> 00:55:20,480
um you know like macro based stuff or

00:55:19,359 --> 00:55:23,119
other template

00:55:20,480 --> 00:55:24,799
things um so if you were wanting to like

00:55:23,119 --> 00:55:25,520
do this piecemeal i'd recommend waiting

00:55:24,799 --> 00:55:27,839
for

00:55:25,520 --> 00:55:29,040
static reflection and code injection to

00:55:27,839 --> 00:55:31,440
land and then

00:55:29,040 --> 00:55:34,559
later on you could introduce magic

00:55:31,440 --> 00:55:37,280
classes afterwards can we generate

00:55:34,559 --> 00:55:39,760
classes with a virtual function

00:55:37,280 --> 00:55:41,599
where the classes are all the

00:55:39,760 --> 00:55:44,720
combination of all

00:55:41,599 --> 00:55:46,160
base classes uh i'm struggling to work

00:55:44,720 --> 00:55:48,960
out what this means is like

00:55:46,160 --> 00:55:50,559
you you multiply inherit from different

00:55:48,960 --> 00:55:51,680
facades or something like that because

00:55:50,559 --> 00:55:53,119
you could

00:55:51,680 --> 00:55:55,520
do you you could have some way of

00:55:53,119 --> 00:55:58,079
combining facades which says you know

00:55:55,520 --> 00:55:59,520
i i want a vector of things which are

00:55:58,079 --> 00:56:03,280
both animals

00:55:59,520 --> 00:56:04,559
and something else like you could

00:56:03,280 --> 00:56:06,880
uh you could come up with a way of

00:56:04,559 --> 00:56:09,520
composing facades and

00:56:06,880 --> 00:56:10,480
uh and that would work fine uh if that's

00:56:09,520 --> 00:56:12,559
not what you meant

00:56:10,480 --> 00:56:14,480
feel free to ask another question can

00:56:12,559 --> 00:56:16,079
this support a class that implements

00:56:14,480 --> 00:56:18,880
multiple virtual interfaces

00:56:16,079 --> 00:56:19,920
i think that's fairly similar to what i

00:56:18,880 --> 00:56:21,839
just answered

00:56:19,920 --> 00:56:23,599
when will the drawing for flight

00:56:21,839 --> 00:56:26,000
simulator be done every day

00:56:23,599 --> 00:56:28,480
um at the end of every day one per day

00:56:26,000 --> 00:56:31,040
will we get cat pictures on slack yes i

00:56:28,480 --> 00:56:33,359
can supply cat pictures on slack

00:56:31,040 --> 00:56:34,480
uh can i use these techniques to create

00:56:33,359 --> 00:56:36,400
also test

00:56:34,480 --> 00:56:38,720
doubles for my classes using this for

00:56:36,400 --> 00:56:41,760
like mocking or something

00:56:38,720 --> 00:56:45,200
uh yeah um i think the

00:56:41,760 --> 00:56:47,839
the mocking is definitely uh

00:56:45,200 --> 00:56:49,839
not necessarily of like the uh the

00:56:47,839 --> 00:56:52,160
dynamic polymorphism

00:56:49,839 --> 00:56:53,760
thing but the code injection and

00:56:52,160 --> 00:56:57,200
reflection are definitely

00:56:53,760 --> 00:57:01,280
mocking is definitely a good um

00:56:57,200 --> 00:57:03,920
thing that those could be used for yeah

00:57:01,280 --> 00:57:05,040
okay uh we've got about two minutes left

00:57:03,920 --> 00:57:07,359
so

00:57:05,040 --> 00:57:09,119
right after the session i do have an ask

00:57:07,359 --> 00:57:11,440
me anything so we can

00:57:09,119 --> 00:57:12,240
pretty much pivot to that right now so

00:57:11,440 --> 00:57:14,559
the

00:57:12,240 --> 00:57:16,160
um feel free to keep asking me questions

00:57:14,559 --> 00:57:19,359
about this talk

00:57:16,160 --> 00:57:21,839
i'll keep my slides

00:57:19,359 --> 00:57:24,000
up in case anyone has questions on that

00:57:21,839 --> 00:57:27,119
but also feel free to ask me about

00:57:24,000 --> 00:57:29,760
any of the other talks i gave or

00:57:27,119 --> 00:57:30,480
um anything about meta classes in

00:57:29,760 --> 00:57:33,200
general

00:57:30,480 --> 00:57:34,480
or functional style programming in c

00:57:33,200 --> 00:57:37,839
plus plus

00:57:34,480 --> 00:57:41,040
diversity and inclusion um

00:57:37,839 --> 00:57:43,040
movies anything it's asking me anything

00:57:41,040 --> 00:57:45,760
one question is does this get us closer

00:57:43,040 --> 00:57:49,040
to python-esque decorators

00:57:45,760 --> 00:57:51,119
uh my memory of python is i i can't

00:57:49,040 --> 00:57:53,839
remember what decorators in python do

00:57:51,119 --> 00:57:55,280
so if you if you tell me what decorators

00:57:53,839 --> 00:57:58,480
and python do that i can tell you if

00:57:55,280 --> 00:57:58,480
this gets us closer

00:58:05,040 --> 00:58:08,319
what is the name of the experimental

00:58:06,559 --> 00:58:11,920
compiler you mentioned um

00:58:08,319 --> 00:58:13,280
it's under a fork uh a clang fork says

00:58:11,920 --> 00:58:14,960
git lab

00:58:13,280 --> 00:58:16,400
and actually got my slides open

00:58:14,960 --> 00:58:19,680
gitlab.com

00:58:16,400 --> 00:58:21,359
slash rock3 clang so

00:58:19,680 --> 00:58:23,119
as far as i know it doesn't i don't know

00:58:21,359 --> 00:58:26,000
if it has like a product

00:58:23,119 --> 00:58:26,799
name it's just it's a clang fork for

00:58:26,000 --> 00:58:28,559
medic classes

00:58:26,799 --> 00:58:30,880
can we ask about your cats please do ask

00:58:28,559 --> 00:58:32,960
about my cats

00:58:30,880 --> 00:58:35,040
i have three cats the the ones you saw

00:58:32,960 --> 00:58:38,160
earlier milkshake was the

00:58:35,040 --> 00:58:39,200
uh the tortoise shell and marshmallow

00:58:38,160 --> 00:58:41,920
was the

00:58:39,200 --> 00:58:43,680
super fluffy golden one uh marshmallow

00:58:41,920 --> 00:58:44,160
is more like a dog than a cat he has no

00:58:43,680 --> 00:58:47,040
idea

00:58:44,160 --> 00:58:48,880
how to cat he's just he's useless and

00:58:47,040 --> 00:58:49,680
then the third one is called lexa she's

00:58:48,880 --> 00:58:52,160
a

00:58:49,680 --> 00:58:53,680
she's grumpy she she probably won't come

00:58:52,160 --> 00:58:56,720
through she doesn't like

00:58:53,680 --> 00:58:56,720
people mostly

00:59:00,640 --> 00:59:04,720
is it possible to implement these new

00:59:02,640 --> 00:59:07,040
language features as a separate source

00:59:04,720 --> 00:59:08,000
to source translation sure i mean you

00:59:07,040 --> 00:59:11,280
could do that

00:59:08,000 --> 00:59:13,440
today right like there's there's no

00:59:11,280 --> 00:59:16,640
reason that you'd have to

00:59:13,440 --> 00:59:19,839
implement this as a c plus

00:59:16,640 --> 00:59:23,839
um library and language feature like

00:59:19,839 --> 00:59:25,680
you could write a um a python script

00:59:23,839 --> 00:59:29,359
which does the necessary

00:59:25,680 --> 00:59:31,599
transformations if you really wanted the

00:59:29,359 --> 00:59:32,480
reason this is better is because it

00:59:31,599 --> 00:59:34,799
would be

00:59:32,480 --> 00:59:35,520
shipped directly in the compiler and you

00:59:34,799 --> 00:59:39,680
could just

00:59:35,520 --> 00:59:43,280
like include a library um

00:59:39,680 --> 00:59:45,920
and then have access to this

00:59:43,280 --> 00:59:46,400
this way of doing dynamic polymorphism

00:59:45,920 --> 00:59:48,319
so that's

00:59:46,400 --> 00:59:49,680
that's the benefit here like you can you

00:59:48,319 --> 00:59:51,680
can do source to source translation of

00:59:49,680 --> 00:59:54,640
anything like you could write a compiler

00:59:51,680 --> 00:59:56,000
uh from this to whatever you wanted it's

00:59:54,640 --> 00:59:59,119
just a case of

00:59:56,000 --> 01:00:00,880
making it easier to consume and

00:59:59,119 --> 01:00:03,839
integrating it into tools and making it

01:00:00,880 --> 01:00:15,839
more standard across the

01:00:03,839 --> 01:00:15,839
across the community

01:00:25,040 --> 01:00:27,119

YouTube URL: https://www.youtube.com/watch?v=8c6BAQcYF_E


