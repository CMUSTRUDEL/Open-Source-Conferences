Title: Cross-Platform Pitfalls and How to Avoid Them - Erika Sweet - CppCon 2020
Publication date: 2020-09-27
Playlist: CppCon 2020 Day 3
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/cross_platform_pitfalls_and_how_to_avoid_them/cross_platform_pitfalls_and_how_to_avoid_them__erika_sweet__cppcon_2020.pdf
---
C++ cross-platform development is difficult. These difficulties are compounded by the fractured solution field, where every project seems to use a different combination of build systems, package managers, and diagnostic tools to address shared challenges. Join us for a discussion and demo of C++ cross-platform development centered on common pitfalls and widely adopted tooling.

Learn how to leverage CMake to seamlessly build across operating systems and platforms. Untangle your dependencies with tools like vcpkg and Conan to avoid inconsistencies between system package managers. Debug your projects across multiple platforms with Visual Studio and Visual Studio Code. Weâ€™ll also take a brief look into how to use CI and testing to get in front of issues before they even happen.

---
Erika Sweet
Program Manager, Microsoft
Erika is a Program Manager on the Visual C++ Team at Microsoft. She likes math and mystery novels. She is currently working on developer tools to support C++ cross-platform development.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,360 --> 00:00:13,120
hi everyone

00:00:10,240 --> 00:00:13,920
my name is erica sweet i use she her

00:00:13,120 --> 00:00:17,039
pronouns

00:00:13,920 --> 00:00:19,199
i work on microsoft's c plus plus team

00:00:17,039 --> 00:00:22,240
and this is cross-platform pitfalls and

00:00:19,199 --> 00:00:24,240
how to avoid them

00:00:22,240 --> 00:00:26,480
if you have any questions about this

00:00:24,240 --> 00:00:27,599
talk or any other talks that folks on my

00:00:26,480 --> 00:00:29,760
team are giving

00:00:27,599 --> 00:00:30,800
or have comments feedback or just want

00:00:29,760 --> 00:00:33,040
to say hi

00:00:30,800 --> 00:00:36,239
then please stop by our table at the

00:00:33,040 --> 00:00:36,239
virtual expo hall

00:00:37,520 --> 00:00:41,040
tooling 4 c plus plus cross platform

00:00:40,160 --> 00:00:43,600
developers

00:00:41,040 --> 00:00:45,039
is a fractured solution space and to

00:00:43,600 --> 00:00:46,879
help illustrate this point

00:00:45,039 --> 00:00:48,879
i'm going to start with an example

00:00:46,879 --> 00:00:50,879
rooted in combinatorics

00:00:48,879 --> 00:00:51,920
so let's say that i'm a c plus plus

00:00:50,879 --> 00:00:53,840
developer

00:00:51,920 --> 00:00:56,239
working on an application that needs to

00:00:53,840 --> 00:00:59,039
run on both windows and linux

00:00:56,239 --> 00:01:02,640
so i want to choose one cross-platform

00:00:59,039 --> 00:01:04,879
build system generator out of 10.

00:01:02,640 --> 00:01:06,720
i want to choose two package management

00:01:04,879 --> 00:01:08,880
solutions out of six

00:01:06,720 --> 00:01:10,000
because i think i want to use the system

00:01:08,880 --> 00:01:12,320
package manager

00:01:10,000 --> 00:01:15,439
on linux which means i'll need to figure

00:01:12,320 --> 00:01:18,479
something else out on windows

00:01:15,439 --> 00:01:19,520
i want to choose two ides or editors out

00:01:18,479 --> 00:01:21,360
of eight

00:01:19,520 --> 00:01:23,680
maybe folks on my team have different

00:01:21,360 --> 00:01:27,280
preferences or maybe i'm opting for

00:01:23,680 --> 00:01:30,079
platform-specific solutions

00:01:27,280 --> 00:01:31,280
i want to choose one cross-platform unit

00:01:30,079 --> 00:01:34,400
testing framework

00:01:31,280 --> 00:01:36,720
out of 10 and i want to choose

00:01:34,400 --> 00:01:38,000
one continuous integration system out of

00:01:36,720 --> 00:01:40,320
four

00:01:38,000 --> 00:01:42,159
and obviously this is just an example

00:01:40,320 --> 00:01:42,880
with arbitrary coefficients and

00:01:42,159 --> 00:01:45,520
restraints

00:01:42,880 --> 00:01:47,200
that i've imposed but already we're up

00:01:45,520 --> 00:01:50,240
to 168

00:01:47,200 --> 00:01:53,040
000 unique combinations of tools that i

00:01:50,240 --> 00:01:53,040
can choose from

00:01:53,360 --> 00:01:56,799
as a cross-platform developer who uses

00:01:55,680 --> 00:01:59,119
these tools

00:01:56,799 --> 00:02:01,520
this gives you a lot of flexibility but

00:01:59,119 --> 00:02:03,439
it can also make your life harder

00:02:01,520 --> 00:02:05,280
it can be difficult to get started

00:02:03,439 --> 00:02:07,119
because there's simultaneously

00:02:05,280 --> 00:02:09,679
too much documentation that you need to

00:02:07,119 --> 00:02:11,520
sift through and no authoritative source

00:02:09,679 --> 00:02:13,760
of truth on the workflow that you're

00:02:11,520 --> 00:02:15,920
actually trying to accomplish

00:02:13,760 --> 00:02:18,400
it can make it harder to find and

00:02:15,920 --> 00:02:20,480
leverage the work of others

00:02:18,400 --> 00:02:21,920
and generally it makes it difficult to

00:02:20,480 --> 00:02:25,360
push the field towards

00:02:21,920 --> 00:02:25,680
a consensus of good practice as someone

00:02:25,360 --> 00:02:28,560
who

00:02:25,680 --> 00:02:30,160
creates or contributes to these tools it

00:02:28,560 --> 00:02:31,920
can also be frustrating

00:02:30,160 --> 00:02:34,720
because the overwhelming amount of

00:02:31,920 --> 00:02:35,280
options makes it difficult for any one

00:02:34,720 --> 00:02:38,239
tool

00:02:35,280 --> 00:02:38,959
to acquire the critical mass necessary

00:02:38,239 --> 00:02:42,000
to achieve

00:02:38,959 --> 00:02:44,080
a positive feedback loop and

00:02:42,000 --> 00:02:45,599
i don't have all the answers and i

00:02:44,080 --> 00:02:48,400
understand that your team's

00:02:45,599 --> 00:02:50,400
needs and matrix of solutions might be

00:02:48,400 --> 00:02:52,560
entirely unique

00:02:50,400 --> 00:02:54,239
but as a part of my job i do talk to

00:02:52,560 --> 00:02:56,400
cross-platform developers

00:02:54,239 --> 00:02:57,760
to better understand their workflows

00:02:56,400 --> 00:03:00,080
their pain points

00:02:57,760 --> 00:03:00,879
and the tools that they're using or want

00:03:00,080 --> 00:03:03,840
to use

00:03:00,879 --> 00:03:05,920
to help address those pain points in

00:03:03,840 --> 00:03:08,400
this talk i'm going to synthesize some

00:03:05,920 --> 00:03:11,360
of the common problems and pitfalls

00:03:08,400 --> 00:03:13,599
that i hear real teams facing and offer

00:03:11,360 --> 00:03:18,000
commentary on the solution space

00:03:13,599 --> 00:03:20,239
rooted in widely adopted tooling

00:03:18,000 --> 00:03:22,319
so i've split this talk into four

00:03:20,239 --> 00:03:23,360
sections or stages in a development

00:03:22,319 --> 00:03:25,440
workflow

00:03:23,360 --> 00:03:27,360
starting with build systems and build

00:03:25,440 --> 00:03:30,840
system generators

00:03:27,360 --> 00:03:34,000
dependency management debugging and

00:03:30,840 --> 00:03:36,480
testing i'll also be showing two

00:03:34,000 --> 00:03:38,319
demos that showcase some of the tooling

00:03:36,480 --> 00:03:39,200
my team has been working on in the past

00:03:38,319 --> 00:03:42,239
year

00:03:39,200 --> 00:03:43,599
like vc package and visual studios cmake

00:03:42,239 --> 00:03:46,080
support

00:03:43,599 --> 00:03:47,280
but if you're not using pc package or

00:03:46,080 --> 00:03:49,760
visual studio

00:03:47,280 --> 00:03:51,920
or visual studio code or anything at all

00:03:49,760 --> 00:03:53,760
in the microsoft ecosystem

00:03:51,920 --> 00:03:56,080
then i hope you will still find value in

00:03:53,760 --> 00:03:57,680
this talk because the problems and tools

00:03:56,080 --> 00:03:59,920
that i'll be discussing

00:03:57,680 --> 00:04:02,000
whether it's a unit testing framework or

00:03:59,920 --> 00:04:04,480
a build system generator

00:04:02,000 --> 00:04:07,280
are transferable and not tied to just

00:04:04,480 --> 00:04:07,280
one ide

00:04:07,439 --> 00:04:11,760
so with that i'll dive into the first

00:04:09,519 --> 00:04:13,599
section on build systems and build

00:04:11,760 --> 00:04:15,439
system generators

00:04:13,599 --> 00:04:17,440
for every other section i'm going to

00:04:15,439 --> 00:04:18,320
start by synthesizing some common

00:04:17,440 --> 00:04:20,079
problems

00:04:18,320 --> 00:04:21,680
and then offer commentary on the

00:04:20,079 --> 00:04:23,759
solution space

00:04:21,680 --> 00:04:25,759
but for this section i flipped it so i'm

00:04:23,759 --> 00:04:27,199
going to start by giving an overview of

00:04:25,759 --> 00:04:29,120
the solutions

00:04:27,199 --> 00:04:32,800
and then talk about the problems that

00:04:29,120 --> 00:04:32,800
are specific to one solution

00:04:33,600 --> 00:04:37,680
let's start by differentiating between

00:04:35,919 --> 00:04:39,040
build systems and build system

00:04:37,680 --> 00:04:41,840
generators

00:04:39,040 --> 00:04:43,440
so a build system we can define as a

00:04:41,840 --> 00:04:46,080
tool or set of tools

00:04:43,440 --> 00:04:48,320
used to compile and link source code and

00:04:46,080 --> 00:04:48,720
oftentimes these build systems will only

00:04:48,320 --> 00:04:52,160
run

00:04:48,720 --> 00:04:53,360
on a subset of operating systems popular

00:04:52,160 --> 00:04:55,440
examples include

00:04:53,360 --> 00:04:57,680
all the different flavors of make as

00:04:55,440 --> 00:05:02,320
well as build systems that are tied to

00:04:57,680 --> 00:05:02,320
an ide like xcode or ms build

00:05:02,800 --> 00:05:06,720
to help address the problem of

00:05:04,639 --> 00:05:09,440
platform-specific build systems

00:05:06,720 --> 00:05:12,000
we have build system generators which

00:05:09,440 --> 00:05:14,720
are used to generate project files for

00:05:12,000 --> 00:05:15,440
specified build systems and can be used

00:05:14,720 --> 00:05:18,400
to maintain

00:05:15,440 --> 00:05:21,360
one build script or one source of truth

00:05:18,400 --> 00:05:24,000
when targeting multiple platforms

00:05:21,360 --> 00:05:26,160
and whether you love it or hate it cmake

00:05:24,000 --> 00:05:27,919
leads the market as a cross-platform

00:05:26,160 --> 00:05:29,440
build system generator

00:05:27,919 --> 00:05:31,039
which leads to something called the

00:05:29,440 --> 00:05:33,680
cmake network effect

00:05:31,039 --> 00:05:34,320
which is basically the idea that other

00:05:33,680 --> 00:05:37,120
projects

00:05:34,320 --> 00:05:38,479
libraries and tools are more likely to

00:05:37,120 --> 00:05:40,320
be using cmake

00:05:38,479 --> 00:05:42,000
and integrate nicely with your own scene

00:05:40,320 --> 00:05:44,000
make projects

00:05:42,000 --> 00:05:46,960
we've also seen more and more editors

00:05:44,000 --> 00:05:50,400
and ides adding their own cmake support

00:05:46,960 --> 00:05:52,720
in our response to this effect but even

00:05:50,400 --> 00:05:54,479
if you're using cmake or you know that

00:05:52,720 --> 00:05:56,000
you want to use cmake

00:05:54,479 --> 00:05:57,919
there's still a lot of ways that your

00:05:56,000 --> 00:05:59,919
life can be difficult and that's what

00:05:57,919 --> 00:06:03,520
we're going to talk about next

00:05:59,919 --> 00:06:03,520
cmake and the problems

00:06:04,479 --> 00:06:08,000
one thing that i hear repeatedly from

00:06:06,319 --> 00:06:09,759
cross-platform developers

00:06:08,000 --> 00:06:11,840
is that it can be difficult to learn the

00:06:09,759 --> 00:06:13,919
language of the build system

00:06:11,840 --> 00:06:15,360
this might be especially true if you're

00:06:13,919 --> 00:06:17,199
used to an ide

00:06:15,360 --> 00:06:18,720
that helps to manage the underlying

00:06:17,199 --> 00:06:22,000
build system for you

00:06:18,720 --> 00:06:24,400
like visual studio and ms build

00:06:22,000 --> 00:06:26,479
relatively common actions like adding a

00:06:24,400 --> 00:06:29,199
new source file to a project

00:06:26,479 --> 00:06:30,080
need to be accessible to everyone devs

00:06:29,199 --> 00:06:31,840
testers

00:06:30,080 --> 00:06:34,319
and not just your build architects who

00:06:31,840 --> 00:06:35,759
are your in-house cmake experts

00:06:34,319 --> 00:06:38,400
but with really complicated build

00:06:35,759 --> 00:06:39,120
scripts even adding a new source file to

00:06:38,400 --> 00:06:42,240
a project

00:06:39,120 --> 00:06:44,880
can become a non-trivial task

00:06:42,240 --> 00:06:46,160
lastly just like c plus plus c make is

00:06:44,880 --> 00:06:48,000
its own language

00:06:46,160 --> 00:06:49,680
so it's yet another set of best

00:06:48,000 --> 00:06:53,440
practices in syntax

00:06:49,680 --> 00:06:53,440
that you'll need to become familiar with

00:06:53,759 --> 00:06:58,319
another pitfall is not abdicating as

00:06:56,319 --> 00:07:00,800
much responsibility to cmake

00:06:58,319 --> 00:07:01,759
as you can see make itself is

00:07:00,800 --> 00:07:04,080
cross-platform

00:07:01,759 --> 00:07:05,520
and it has a lot of primitives built in

00:07:04,080 --> 00:07:08,400
to help abstract away

00:07:05,520 --> 00:07:10,240
platform and compiler specifics but you

00:07:08,400 --> 00:07:11,280
can make your life harder by trying to

00:07:10,240 --> 00:07:13,520
fight with cmake

00:07:11,280 --> 00:07:14,560
and re-implement that functionality on

00:07:13,520 --> 00:07:17,120
your own

00:07:14,560 --> 00:07:18,319
so i've identified a few examples and

00:07:17,120 --> 00:07:20,240
recommendations

00:07:18,319 --> 00:07:22,560
to better illustrate what i mean by this

00:07:20,240 --> 00:07:22,560
point

00:07:22,880 --> 00:07:26,560
first is to use built-in cmit command

00:07:25,520 --> 00:07:28,319
line tools

00:07:26,560 --> 00:07:30,960
instead of calling system commands

00:07:28,319 --> 00:07:33,680
directly so cmic has a lot of

00:07:30,960 --> 00:07:37,120
abstractions for common system commands

00:07:33,680 --> 00:07:38,960
like make directory remove copy echo

00:07:37,120 --> 00:07:40,720
and you can call them instead of

00:07:38,960 --> 00:07:44,000
wrapping your system commands

00:07:40,720 --> 00:07:45,599
and platform specific logic this create

00:07:44,000 --> 00:07:49,840
simulink command that i'm using in the

00:07:45,599 --> 00:07:52,720
example was added to cmake and cmake 313

00:07:49,840 --> 00:07:54,240
and all of these commands uh can also be

00:07:52,720 --> 00:07:55,039
used when you're invoking cmake from the

00:07:54,240 --> 00:07:56,800
command line

00:07:55,039 --> 00:07:58,639
this is just an example of what it might

00:07:56,800 --> 00:08:00,960
look like in the context of the cmx

00:07:58,639 --> 00:08:00,960
script

00:08:02,479 --> 00:08:07,759
a second example is to use built-in

00:08:05,360 --> 00:08:10,080
project commands whenever possible

00:08:07,759 --> 00:08:11,680
instead of re-implementing functionality

00:08:10,080 --> 00:08:14,720
with custom functions

00:08:11,680 --> 00:08:17,520
and compiler specific logic so

00:08:14,720 --> 00:08:19,840
this command target pre-compile headers

00:08:17,520 --> 00:08:21,520
was recently added to cmeq and cmake

00:08:19,840 --> 00:08:23,680
316.

00:08:21,520 --> 00:08:24,879
before that you have might have had to

00:08:23,680 --> 00:08:28,000
hand roll your own

00:08:24,879 --> 00:08:30,080
function with compiler specific logic

00:08:28,000 --> 00:08:32,320
or you might have used kotire which

00:08:30,080 --> 00:08:34,640
stands for compile-time reducer

00:08:32,320 --> 00:08:37,919
and was an open source cmake module

00:08:34,640 --> 00:08:40,399
that's now fully integrated into cmake

00:08:37,919 --> 00:08:41,120
but kotar was over a thousand lines of

00:08:40,399 --> 00:08:43,279
cmake

00:08:41,120 --> 00:08:44,880
that's now abstracted for you in a

00:08:43,279 --> 00:08:47,200
single command

00:08:44,880 --> 00:08:48,000
all that you need to do is pass a list

00:08:47,200 --> 00:08:50,320
of public

00:08:48,000 --> 00:08:52,399
private and interface headers to cmake

00:08:50,320 --> 00:08:54,800
on a per target basis

00:08:52,399 --> 00:08:55,600
you can also reuse pre-compiled header

00:08:54,800 --> 00:08:57,600
artifacts

00:08:55,600 --> 00:08:59,040
from other targets instead of always

00:08:57,600 --> 00:09:02,480
generating your own

00:08:59,040 --> 00:09:04,959
by using the reuse from option

00:09:02,480 --> 00:09:06,399
lastly you don't need to modify your cnc

00:09:04,959 --> 00:09:08,720
plus plus source code at

00:09:06,399 --> 00:09:11,200
all to use this command because

00:09:08,720 --> 00:09:14,800
pre-compiled headers are force included

00:09:11,200 --> 00:09:14,800
in all compilation units

00:09:16,399 --> 00:09:19,600
a third example is to set compile

00:09:18,640 --> 00:09:21,600
features so

00:09:19,600 --> 00:09:23,360
in this first example we're setting one

00:09:21,600 --> 00:09:25,920
compile feature that's required to

00:09:23,360 --> 00:09:27,920
compile this specific target

00:09:25,920 --> 00:09:29,440
or meta features so in the second

00:09:27,920 --> 00:09:31,839
example we're setting a c

00:09:29,440 --> 00:09:34,080
plus language standard that's required

00:09:31,839 --> 00:09:36,959
to compile this target

00:09:34,080 --> 00:09:38,399
instead of manually setting flags you

00:09:36,959 --> 00:09:41,120
don't need to be in the business

00:09:38,399 --> 00:09:42,240
of maintaining flags and error messages

00:09:41,120 --> 00:09:44,320
for every version

00:09:42,240 --> 00:09:47,040
of every compiler because that's

00:09:44,320 --> 00:09:48,880
something that cma can help you with

00:09:47,040 --> 00:09:50,240
you can also set optional compile

00:09:48,880 --> 00:09:52,399
features that say

00:09:50,240 --> 00:09:54,800
hey use this feature if it's available

00:09:52,399 --> 00:09:57,360
but don't set a hard requirement

00:09:54,800 --> 00:09:58,160
or conditional compile features so for

00:09:57,360 --> 00:10:00,560
example

00:09:58,160 --> 00:10:03,040
you can use a generator expression to

00:10:00,560 --> 00:10:05,839
say require this one specific compile

00:10:03,040 --> 00:10:08,959
feature only when the compile id

00:10:05,839 --> 00:10:08,959
matches gnu

00:10:10,480 --> 00:10:14,480
a fourth example is to keep your paths

00:10:13,040 --> 00:10:17,120
platform independent

00:10:14,480 --> 00:10:18,880
and not platform specific so in this

00:10:17,120 --> 00:10:19,600
example there's a few things going on

00:10:18,880 --> 00:10:22,720
here

00:10:19,600 --> 00:10:24,320
the relative path include my target for

00:10:22,720 --> 00:10:26,399
the install interface

00:10:24,320 --> 00:10:28,560
is being interpreted relative to the

00:10:26,399 --> 00:10:31,279
installation prefix

00:10:28,560 --> 00:10:32,000
the variable c make current source dir

00:10:31,279 --> 00:10:34,000
is going to

00:10:32,000 --> 00:10:36,079
evaluate to the source directory that's

00:10:34,000 --> 00:10:39,040
currently being processed

00:10:36,079 --> 00:10:40,079
so in general use relative paths and in

00:10:39,040 --> 00:10:41,680
that same

00:10:40,079 --> 00:10:44,160
in that same vein if you're searching

00:10:41,680 --> 00:10:46,560
for tools you can assume that the tool

00:10:44,160 --> 00:10:49,120
binaries are on path and fail

00:10:46,560 --> 00:10:51,680
otherwise to avoid searching in platform

00:10:49,120 --> 00:10:53,839
specific directories

00:10:51,680 --> 00:10:54,880
another recommendation is to avoid

00:10:53,839 --> 00:10:57,519
backslashes

00:10:54,880 --> 00:10:58,880
so you can use the file command with the

00:10:57,519 --> 00:11:01,519
two cmake path

00:10:58,880 --> 00:11:04,320
or two native path options to convert

00:11:01,519 --> 00:11:06,800
native paths and system search paths

00:11:04,320 --> 00:11:09,680
to and from semi-style paths with

00:11:06,800 --> 00:11:09,680
forward slashes

00:11:10,720 --> 00:11:15,519
and lastly cross-compilation with cma

00:11:13,440 --> 00:11:17,120
can be pretty straightforward

00:11:15,519 --> 00:11:19,279
but a lot of folks tend to over

00:11:17,120 --> 00:11:21,920
configure their tool chain files

00:11:19,279 --> 00:11:24,240
so the recommendation is to use one tool

00:11:21,920 --> 00:11:26,320
chain file per target platform

00:11:24,240 --> 00:11:28,000
and avoid adding logic to your tool

00:11:26,320 --> 00:11:30,320
chain file

00:11:28,000 --> 00:11:32,000
this example that i have here is one of

00:11:30,320 --> 00:11:33,040
the most simple tool chain files that

00:11:32,000 --> 00:11:35,040
you can author

00:11:33,040 --> 00:11:36,959
but it still gets the job done all i'm

00:11:35,040 --> 00:11:40,839
doing is setting my target system

00:11:36,959 --> 00:11:42,640
and architecture and then picking my

00:11:40,839 --> 00:11:45,040
compilers

00:11:42,640 --> 00:11:47,360
this was just a few examples of some

00:11:45,040 --> 00:11:48,880
cross-platform specific gotchas

00:11:47,360 --> 00:11:50,959
that you can run into when you're

00:11:48,880 --> 00:11:52,880
authoring your cmake scripts

00:11:50,959 --> 00:11:54,560
but there's a lot of other ways that

00:11:52,880 --> 00:11:55,360
modern seamlate can make your life

00:11:54,560 --> 00:11:57,360
easier

00:11:55,360 --> 00:11:59,440
and so for more information i would

00:11:57,360 --> 00:12:01,680
recommend these two resources

00:11:59,440 --> 00:12:02,480
the first is a recording of a conference

00:12:01,680 --> 00:12:04,639
talk

00:12:02,480 --> 00:12:07,839
and the second is some documentation

00:12:04,639 --> 00:12:07,839
published by getbook

00:12:09,279 --> 00:12:13,839
all right on to the second section which

00:12:11,920 --> 00:12:15,600
is dependency management

00:12:13,839 --> 00:12:18,320
and this time i'm going to start with

00:12:15,600 --> 00:12:18,320
the problems

00:12:19,200 --> 00:12:23,360
dependency management is a pain point

00:12:21,279 --> 00:12:26,000
for all c plus developers

00:12:23,360 --> 00:12:26,720
unless you're part of the lucky 14.9

00:12:26,000 --> 00:12:28,480
percent

00:12:26,720 --> 00:12:30,160
who say that it's not a significant

00:12:28,480 --> 00:12:31,760
issue for me

00:12:30,160 --> 00:12:33,279
but there's a couple of problems that

00:12:31,760 --> 00:12:36,720
might be exasperated

00:12:33,279 --> 00:12:38,959
for cross-platform developers

00:12:36,720 --> 00:12:41,120
if you are building a library from

00:12:38,959 --> 00:12:43,040
source by following the instructions and

00:12:41,120 --> 00:12:44,720
the repositories read me

00:12:43,040 --> 00:12:46,079
then you're going to need to follow

00:12:44,720 --> 00:12:48,800
those instructions

00:12:46,079 --> 00:12:50,639
as well as manually fetch and resolve

00:12:48,800 --> 00:12:52,399
all transitive dependencies

00:12:50,639 --> 00:12:54,160
including building and installing the

00:12:52,399 --> 00:12:56,800
right version of the dependency

00:12:54,160 --> 00:12:58,000
to not break your dependency tree on all

00:12:56,800 --> 00:12:59,519
the different platforms that you're

00:12:58,000 --> 00:13:01,279
working on

00:12:59,519 --> 00:13:02,560
you're also going to need to maintain

00:13:01,279 --> 00:13:05,040
multiple sources

00:13:02,560 --> 00:13:06,720
of your dependency tree across all the

00:13:05,040 --> 00:13:08,880
different platforms

00:13:06,720 --> 00:13:10,240
i was talking to some developers who

00:13:08,880 --> 00:13:12,800
were working on windows

00:13:10,240 --> 00:13:14,399
and trying out wsl or the windows

00:13:12,800 --> 00:13:16,079
subsystem for linux

00:13:14,399 --> 00:13:18,240
and they were lamenting on how nice it

00:13:16,079 --> 00:13:19,839
would be if they were able to leverage

00:13:18,240 --> 00:13:22,240
all the work that they had already put

00:13:19,839 --> 00:13:23,040
in to configure their dependency tree on

00:13:22,240 --> 00:13:26,320
windows

00:13:23,040 --> 00:13:29,279
when they're working on wsl

00:13:26,320 --> 00:13:29,760
and lastly whatever tool or solution you

00:13:29,279 --> 00:13:32,160
use

00:13:29,760 --> 00:13:33,839
to manage your dependencies it would be

00:13:32,160 --> 00:13:34,800
nice if that solution itself was

00:13:33,839 --> 00:13:36,880
cross-platform

00:13:34,800 --> 00:13:40,320
so that you can use the same workflow

00:13:36,880 --> 00:13:40,320
across multiple platforms

00:13:40,959 --> 00:13:46,560
and again there are a lot of solutions

00:13:43,360 --> 00:13:46,560
in this space already

00:13:46,639 --> 00:13:50,720
system package managers can be really

00:13:49,040 --> 00:13:52,240
nice for installing tooling

00:13:50,720 --> 00:13:55,040
but they can make your life difficult

00:13:52,240 --> 00:13:57,040
when you're trying to install packages

00:13:55,040 --> 00:13:59,440
they oftentimes don't have the most

00:13:57,040 --> 00:14:01,680
up-to-date version of a package

00:13:59,440 --> 00:14:03,040
and they can also silently update things

00:14:01,680 --> 00:14:05,760
from underneath you

00:14:03,040 --> 00:14:06,320
with no warning so for example you might

00:14:05,760 --> 00:14:08,720
pull in

00:14:06,320 --> 00:14:10,240
a new dependency that updates the

00:14:08,720 --> 00:14:11,040
version of several dependencies

00:14:10,240 --> 00:14:14,320
downstream

00:14:11,040 --> 00:14:16,959
and its own dependency tree they're also

00:14:14,320 --> 00:14:18,959
system wide and not project specific

00:14:16,959 --> 00:14:19,920
which can make it nearly impossible to

00:14:18,959 --> 00:14:23,600
work on two

00:14:19,920 --> 00:14:26,079
incompatible projects on the same system

00:14:23,600 --> 00:14:28,399
and lastly they are platform specific

00:14:26,079 --> 00:14:30,959
and oftentimes even distro specific

00:14:28,399 --> 00:14:35,199
so apt is really popular but it only

00:14:30,959 --> 00:14:35,199
works on debian based linux systems

00:14:35,920 --> 00:14:39,440
a second class of dependency management

00:14:38,639 --> 00:14:41,519
solutions

00:14:39,440 --> 00:14:42,560
is build system specific package

00:14:41,519 --> 00:14:44,160
managers

00:14:42,560 --> 00:14:46,480
and the primary example that i'm

00:14:44,160 --> 00:14:48,399
thinking of here is nuget

00:14:46,480 --> 00:14:50,079
nuget is not our recommendation for

00:14:48,399 --> 00:14:53,839
cross-platform development

00:14:50,079 --> 00:14:56,240
or for any c-plus plus development

00:14:53,839 --> 00:14:57,680
nuget does do some nice things like it

00:14:56,240 --> 00:15:00,560
has some build system

00:14:57,680 --> 00:15:02,079
integration and ide integration and it

00:15:00,560 --> 00:15:04,639
provides a way to share

00:15:02,079 --> 00:15:05,600
pre-built binaries and sources but at

00:15:04,639 --> 00:15:07,519
the end of the day

00:15:05,600 --> 00:15:10,320
it's tied to the build system and not

00:15:07,519 --> 00:15:10,959
the language so for example nuget also

00:15:10,320 --> 00:15:12,959
serves

00:15:10,959 --> 00:15:15,120
net developers who have an entirely

00:15:12,959 --> 00:15:17,680
different set of needs than c plus bus

00:15:15,120 --> 00:15:17,680
developers

00:15:18,880 --> 00:15:22,480
finally there are language specific

00:15:20,800 --> 00:15:23,760
package managers which is our

00:15:22,480 --> 00:15:27,839
recommendation for

00:15:23,760 --> 00:15:27,839
c plus plus cross-platform development

00:15:28,399 --> 00:15:32,800
two c plus plus package managers that

00:15:30,880 --> 00:15:35,680
are being actively invested in

00:15:32,800 --> 00:15:37,680
are conan and vc package and this list

00:15:35,680 --> 00:15:39,040
of qualities applies to both of those

00:15:37,680 --> 00:15:41,199
tools

00:15:39,040 --> 00:15:43,199
so both conan and vc package are

00:15:41,199 --> 00:15:45,199
themselves cross-platform

00:15:43,199 --> 00:15:46,560
and allow you to bring down and build

00:15:45,199 --> 00:15:50,000
libraries from source

00:15:46,560 --> 00:15:51,600
on windows linux and mac

00:15:50,000 --> 00:15:53,519
they both automatically fetch and

00:15:51,600 --> 00:15:57,759
resolve transitive dependencies

00:15:53,519 --> 00:15:59,120
for you with conan you can acquire

00:15:57,759 --> 00:16:01,600
pre-built binaries

00:15:59,120 --> 00:16:03,120
and with both conan and bc package you

00:16:01,600 --> 00:16:04,959
can cache binaries

00:16:03,120 --> 00:16:06,399
to speed up the amount of time it takes

00:16:04,959 --> 00:16:09,360
to download and install

00:16:06,399 --> 00:16:10,959
libraries across multiple systems and to

00:16:09,360 --> 00:16:13,440
ensure that every developer

00:16:10,959 --> 00:16:15,040
and your continuous integration system

00:16:13,440 --> 00:16:18,720
are using the same version of the

00:16:15,040 --> 00:16:18,720
library built the same way

00:16:19,360 --> 00:16:23,519
both conan and vc package support some

00:16:21,759 --> 00:16:25,440
declarative manifest file

00:16:23,519 --> 00:16:27,120
or you can declaratively specify your

00:16:25,440 --> 00:16:28,639
dependencies one time

00:16:27,120 --> 00:16:31,120
and then check that file into source

00:16:28,639 --> 00:16:31,120
control

00:16:31,440 --> 00:16:36,720
conan and soon vc package will

00:16:34,720 --> 00:16:38,000
enable you to install libraries from

00:16:36,720 --> 00:16:40,079
multiple sources

00:16:38,000 --> 00:16:42,800
so that means you can use the same tool

00:16:40,079 --> 00:16:45,040
to install your proprietary libraries

00:16:42,800 --> 00:16:46,160
your own custom fork of an open source

00:16:45,040 --> 00:16:49,600
library

00:16:46,160 --> 00:16:52,160
or an open source library

00:16:49,600 --> 00:16:52,720
and finally conan and soon vc package

00:16:52,160 --> 00:16:54,720
support

00:16:52,720 --> 00:16:56,720
versioning which is the ability to

00:16:54,720 --> 00:16:59,199
specify which specific version

00:16:56,720 --> 00:17:01,600
of one specific library that you want to

00:16:59,199 --> 00:17:01,600
install

00:17:01,839 --> 00:17:05,039
vc package is the tool that my team

00:17:04,079 --> 00:17:07,600
works on

00:17:05,039 --> 00:17:09,199
and binary caching and support for a

00:17:07,600 --> 00:17:12,079
declarative manifest file

00:17:09,199 --> 00:17:14,079
are both new and now available and

00:17:12,079 --> 00:17:15,600
registry support which is what bc

00:17:14,079 --> 00:17:17,280
package calls the ability

00:17:15,600 --> 00:17:18,959
to install libraries from multiple

00:17:17,280 --> 00:17:23,199
sources and verge

00:17:18,959 --> 00:17:23,199
versioning support are both coming soon

00:17:24,160 --> 00:17:27,679
it can be difficult to change your

00:17:25,760 --> 00:17:29,679
package management solution

00:17:27,679 --> 00:17:32,000
especially if you're working with legacy

00:17:29,679 --> 00:17:34,400
code but we do see that c

00:17:32,000 --> 00:17:35,280
plus package managers like vc package

00:17:34,400 --> 00:17:38,000
and conan

00:17:35,280 --> 00:17:38,000
are on the rise

00:17:39,360 --> 00:17:44,080
and with that i'll jump on into my first

00:17:41,679 --> 00:17:46,640
demo

00:17:44,080 --> 00:17:47,919
so here i have a cmake project open in

00:17:46,640 --> 00:17:49,840
visual studio

00:17:47,919 --> 00:17:51,600
and the first thing i'm going to do is

00:17:49,840 --> 00:17:53,840
generate the cache

00:17:51,600 --> 00:17:55,760
this is the same as calling cmit

00:17:53,840 --> 00:17:58,240
configure from the command line

00:17:55,760 --> 00:18:01,440
so it generates the cache and writes the

00:17:58,240 --> 00:18:02,320
build files i'm working with a fork of

00:18:01,440 --> 00:18:04,480
box 2d

00:18:02,320 --> 00:18:05,919
lite which is a more streamlined version

00:18:04,480 --> 00:18:09,039
of box 2d

00:18:05,919 --> 00:18:10,640
the open source physics library and i

00:18:09,039 --> 00:18:12,880
also have this folder open

00:18:10,640 --> 00:18:15,120
using visual studio's native support for

00:18:12,880 --> 00:18:16,240
cmake which means that i'm opening this

00:18:15,120 --> 00:18:18,480
folder directly

00:18:16,240 --> 00:18:20,880
without ever generating visual studio

00:18:18,480 --> 00:18:23,039
project and solution files

00:18:20,880 --> 00:18:24,400
so it looks like generation generation

00:18:23,039 --> 00:18:28,080
has finished but with

00:18:24,400 --> 00:18:31,360
an error i'm missing a dependency

00:18:28,080 --> 00:18:34,000
because cma cannot find glad

00:18:31,360 --> 00:18:36,080
so this repository is configured to use

00:18:34,000 --> 00:18:38,960
a vc package manifest file

00:18:36,080 --> 00:18:39,360
to acquire its dependencies i'll open

00:18:38,960 --> 00:18:42,799
that

00:18:39,360 --> 00:18:45,760
up now

00:18:42,799 --> 00:18:47,039
and because one i'm using the vc package

00:18:45,760 --> 00:18:50,799
tool chain file

00:18:47,039 --> 00:18:52,960
and two i have this vc package.json file

00:18:50,799 --> 00:18:54,400
adjacent to my root c make list in my

00:18:52,960 --> 00:18:56,480
project tree

00:18:54,400 --> 00:18:57,520
then when cmake is called to configure

00:18:56,480 --> 00:18:59,840
the project

00:18:57,520 --> 00:19:00,640
vc package will automatically bring down

00:18:59,840 --> 00:19:02,080
and build

00:19:00,640 --> 00:19:04,320
all of the dependencies that i've

00:19:02,080 --> 00:19:06,720
specified here from source

00:19:04,320 --> 00:19:08,640
or download them from a binary cache if

00:19:06,720 --> 00:19:11,039
i'm using binary caching

00:19:08,640 --> 00:19:13,520
and install them into a subdirectory of

00:19:11,039 --> 00:19:15,520
this project's output directory

00:19:13,520 --> 00:19:16,640
so all i need to do to add the missing

00:19:15,520 --> 00:19:20,080
dependency

00:19:16,640 --> 00:19:20,640
is add glad to this list and this file

00:19:20,080 --> 00:19:22,480
can be

00:19:20,640 --> 00:19:24,480
checked into source control with the

00:19:22,480 --> 00:19:27,919
rest of my source code

00:19:24,480 --> 00:19:31,840
so now i'll save this file and try

00:19:27,919 --> 00:19:33,520
regenerating the cache again

00:19:31,840 --> 00:19:35,200
and there's three things that i want to

00:19:33,520 --> 00:19:37,039
point out one

00:19:35,200 --> 00:19:39,120
you'll notice that i didn't specify

00:19:37,039 --> 00:19:40,640
which triplet of these dependencies i

00:19:39,120 --> 00:19:42,240
want to install

00:19:40,640 --> 00:19:44,720
and that's because the vc package

00:19:42,240 --> 00:19:45,520
manifest file is integrated with visual

00:19:44,720 --> 00:19:47,280
studio

00:19:45,520 --> 00:19:49,280
such that the triplet that's built by

00:19:47,280 --> 00:19:50,720
default matches the active cma

00:19:49,280 --> 00:19:54,000
configuration

00:19:50,720 --> 00:19:57,360
so because an x86 windows configuration

00:19:54,000 --> 00:19:59,440
is active right now the x86 windows

00:19:57,360 --> 00:20:01,679
triplet of all these dependencies will

00:19:59,440 --> 00:20:03,039
be built by default

00:20:01,679 --> 00:20:05,039
another thing is that all the

00:20:03,039 --> 00:20:07,760
dependencies that i've specified

00:20:05,039 --> 00:20:08,400
are just strings but i could also

00:20:07,760 --> 00:20:10,159
specify

00:20:08,400 --> 00:20:12,799
objects if i want to include any

00:20:10,159 --> 00:20:15,039
optional keys like a platform expression

00:20:12,799 --> 00:20:18,080
that says which platforms are or are not

00:20:15,039 --> 00:20:20,799
supported by a specific dependency

00:20:18,080 --> 00:20:22,799
and lastly i want to underscore that i

00:20:20,799 --> 00:20:25,039
didn't need to make any changes to my

00:20:22,799 --> 00:20:26,880
build scripts to use this functionality

00:20:25,039 --> 00:20:28,080
so you can bring your projects exactly

00:20:26,880 --> 00:20:30,200
as they are

00:20:28,080 --> 00:20:32,960
all i needed to do was add this

00:20:30,200 --> 00:20:36,400
bcpackage.json file to the root

00:20:32,960 --> 00:20:38,240
and use the vc package tool chain file

00:20:36,400 --> 00:20:39,840
so it looks like cement generation has

00:20:38,240 --> 00:20:41,360
been done and

00:20:39,840 --> 00:20:43,520
there's a few things that i want to

00:20:41,360 --> 00:20:46,799
point out

00:20:43,520 --> 00:20:48,480
so one you'll see that vc package is

00:20:46,799 --> 00:20:50,640
trying to build and install

00:20:48,480 --> 00:20:53,440
six packages but i've only specified

00:20:50,640 --> 00:20:55,520
four and two have an asterisk by them

00:20:53,440 --> 00:20:57,760
and that's because vc package is

00:20:55,520 --> 00:21:02,720
automatically fetching and resolving

00:20:57,760 --> 00:21:04,960
all of my transitive dependencies for me

00:21:02,720 --> 00:21:06,159
you can also see that this operation

00:21:04,960 --> 00:21:08,000
took a suspiciously

00:21:06,159 --> 00:21:09,919
short amount of time and that i'm

00:21:08,000 --> 00:21:10,640
attempting to fetch six packages from

00:21:09,919 --> 00:21:13,600
nuget

00:21:10,640 --> 00:21:15,840
and restoring six packages and that's

00:21:13,600 --> 00:21:16,880
because i'm using vc package binary

00:21:15,840 --> 00:21:18,559
caching

00:21:16,880 --> 00:21:20,559
there's two different backends that you

00:21:18,559 --> 00:21:23,280
can use with binary caching

00:21:20,559 --> 00:21:24,000
you can use a file share or you can use

00:21:23,280 --> 00:21:26,240
nuget

00:21:24,000 --> 00:21:27,679
which essentially uploads binaries as

00:21:26,240 --> 00:21:29,840
raw nougat packages

00:21:27,679 --> 00:21:30,880
which allows you to use any binary

00:21:29,840 --> 00:21:32,880
hosting service

00:21:30,880 --> 00:21:35,280
that already supports nuget so for

00:21:32,880 --> 00:21:38,559
example i'm using github packages

00:21:35,280 --> 00:21:40,320
to host these binaries and

00:21:38,559 --> 00:21:41,919
because of that all of these

00:21:40,320 --> 00:21:46,400
installations are taking

00:21:41,919 --> 00:21:49,679
104 milliseconds all under a second here

00:21:46,400 --> 00:21:51,520
and the entire operation took about 10

00:21:49,679 --> 00:21:54,159
seconds

00:21:51,520 --> 00:21:54,640
so now that cache generation is complete

00:21:54,159 --> 00:21:56,880
i

00:21:54,640 --> 00:21:58,159
can build and run these samples

00:21:56,880 --> 00:22:01,200
executable

00:21:58,159 --> 00:22:01,200
on windows

00:22:01,280 --> 00:22:04,640
so this is just a demo application that

00:22:03,520 --> 00:22:08,080
was included

00:22:04,640 --> 00:22:08,080
with the static library

00:22:09,200 --> 00:22:13,840
and here is samples

00:22:18,640 --> 00:22:22,720
now i'm going to switch gear a little

00:22:20,559 --> 00:22:25,120
bit and start making some edits to

00:22:22,720 --> 00:22:27,840
my cmic scripts so i'll switch into

00:22:25,120 --> 00:22:30,240
cmake targets view

00:22:27,840 --> 00:22:31,360
which is a more cmake-centric way of

00:22:30,240 --> 00:22:33,760
viewing my code

00:22:31,360 --> 00:22:36,000
organized by target and i'm going to

00:22:33,760 --> 00:22:39,200
open the cmake list that defines the

00:22:36,000 --> 00:22:39,200
samples executable

00:22:39,280 --> 00:22:43,200
one of the problems that i addressed

00:22:41,280 --> 00:22:44,320
earlier was learning the language of the

00:22:43,200 --> 00:22:46,080
build system

00:22:44,320 --> 00:22:48,400
so one feature that we've added in the

00:22:46,080 --> 00:22:51,200
past year to help address this

00:22:48,400 --> 00:22:52,480
is language services for c make just

00:22:51,200 --> 00:22:54,559
like when you're using

00:22:52,480 --> 00:22:56,080
or working with cnc plus plus source

00:22:54,559 --> 00:23:00,080
code you can now

00:22:56,080 --> 00:23:02,880
right click on a c make variable and

00:23:00,080 --> 00:23:04,640
peak definition or go to definition so

00:23:02,880 --> 00:23:09,840
here i'm seeing that sample

00:23:04,640 --> 00:23:09,840
source files variable defined for me

00:23:10,400 --> 00:23:16,880
i can also right click on a target

00:23:14,240 --> 00:23:18,480
and find all references so this will

00:23:16,880 --> 00:23:19,440
list all the different times that this

00:23:18,480 --> 00:23:23,840
sample's target

00:23:19,440 --> 00:23:23,840
is referenced in my entire project tree

00:23:25,840 --> 00:23:29,520
and with really complicated uh source

00:23:28,480 --> 00:23:32,480
trees and build scripts

00:23:29,520 --> 00:23:34,159
this functionality can be really helpful

00:23:32,480 --> 00:23:34,559
another feature that we've added in the

00:23:34,159 --> 00:23:37,039
past

00:23:34,559 --> 00:23:38,880
year to try and address this problem is

00:23:37,039 --> 00:23:41,039
project manipulation support

00:23:38,880 --> 00:23:41,919
so now i'll pretend that i want to add a

00:23:41,039 --> 00:23:43,760
new test

00:23:41,919 --> 00:23:46,880
so i'll open up the cmake list that

00:23:43,760 --> 00:23:50,799
defines my test executable

00:23:46,880 --> 00:23:54,960
right click on the executable add

00:23:50,799 --> 00:23:56,640
new item i'll add a new cpp file and

00:23:54,960 --> 00:24:00,480
i'll just call it

00:23:56,640 --> 00:24:02,320
new test dot cpp

00:24:00,480 --> 00:24:03,600
and now instead of just dropping that

00:24:02,320 --> 00:24:05,919
file on disk

00:24:03,600 --> 00:24:08,000
visual studio is trying to understand

00:24:05,919 --> 00:24:09,760
where it might add a reference to this

00:24:08,000 --> 00:24:11,840
newly added source file

00:24:09,760 --> 00:24:13,520
and if there's any ambiguity then visual

00:24:11,840 --> 00:24:14,240
studio will prompt you with multiple

00:24:13,520 --> 00:24:16,960
options

00:24:14,240 --> 00:24:18,960
so in this case it's offering to add the

00:24:16,960 --> 00:24:19,840
reference straight to the add executable

00:24:18,960 --> 00:24:22,640
command

00:24:19,840 --> 00:24:23,520
or it's also offering to add it to a set

00:24:22,640 --> 00:24:25,840
command

00:24:23,520 --> 00:24:27,440
and because i'm using this test source

00:24:25,840 --> 00:24:29,840
files variable to define

00:24:27,440 --> 00:24:32,080
all of my source files that is the only

00:24:29,840 --> 00:24:33,440
option that i would want

00:24:32,080 --> 00:24:37,360
but i'm not actually going to make these

00:24:33,440 --> 00:24:37,360
changes so i'll go ahead and cancel that

00:24:38,320 --> 00:24:42,000
and now i'll hop back on over to the

00:24:40,640 --> 00:24:44,080
slides

00:24:42,000 --> 00:24:47,279
alright so we can quickly recap what we

00:24:44,080 --> 00:24:50,080
just covered in that demo

00:24:47,279 --> 00:24:52,400
we showcased two new vc package features

00:24:50,080 --> 00:24:54,480
a vc package manifest file

00:24:52,400 --> 00:24:55,679
where i declaratively specified my

00:24:54,480 --> 00:24:57,600
dependencies

00:24:55,679 --> 00:25:00,480
and that file can be checked into source

00:24:57,600 --> 00:25:03,520
control and shared between my team

00:25:00,480 --> 00:25:04,559
and vc package binary caching i was

00:25:03,520 --> 00:25:06,640
using eugene

00:25:04,559 --> 00:25:09,039
binary cache that was hosted in github

00:25:06,640 --> 00:25:11,840
packages and downloading and installing

00:25:09,039 --> 00:25:14,240
those cached packages locally

00:25:11,840 --> 00:25:16,559
we also showed two new cmake features

00:25:14,240 --> 00:25:18,559
the first was to make language features

00:25:16,559 --> 00:25:20,720
where i can go to definition peak

00:25:18,559 --> 00:25:22,960
definition and find all references

00:25:20,720 --> 00:25:23,840
on scenic variables targets and

00:25:22,960 --> 00:25:25,760
functions

00:25:23,840 --> 00:25:27,520
and we showed this on c make variables

00:25:25,760 --> 00:25:29,039
and targets

00:25:27,520 --> 00:25:31,360
we then showed cmake project

00:25:29,039 --> 00:25:31,760
manipulation support which allows you to

00:25:31,360 --> 00:25:34,559
add

00:25:31,760 --> 00:25:36,480
remove and rename files and targets

00:25:34,559 --> 00:25:37,760
without ever modifying your build

00:25:36,480 --> 00:25:40,000
scripts by hand

00:25:37,760 --> 00:25:43,840
and we show the example of adding a new

00:25:40,000 --> 00:25:43,840
source file to a target

00:25:44,080 --> 00:25:47,120
and with that we can jump on into the

00:25:46,159 --> 00:25:49,520
third section

00:25:47,120 --> 00:25:52,720
on debugging and again i'm going to

00:25:49,520 --> 00:25:52,720
start with the problems

00:25:53,120 --> 00:25:57,520
one thing that i hear repeatedly from

00:25:55,120 --> 00:25:57,840
customers is that they're unfamiliar

00:25:57,520 --> 00:26:00,640
with

00:25:57,840 --> 00:26:02,000
platform-specific tools and this might

00:26:00,640 --> 00:26:03,840
be especially true

00:26:02,000 --> 00:26:05,840
if you added support for a second

00:26:03,840 --> 00:26:06,880
platform after your project already

00:26:05,840 --> 00:26:09,039
existed

00:26:06,880 --> 00:26:11,520
so for example you might work primarily

00:26:09,039 --> 00:26:12,799
on windows and have relied on the visual

00:26:11,520 --> 00:26:14,640
studio debugger

00:26:12,799 --> 00:26:16,559
but then you also added support for

00:26:14,640 --> 00:26:18,559
linux

00:26:16,559 --> 00:26:20,080
and a common theme that i hear in a

00:26:18,559 --> 00:26:22,320
response to this problem

00:26:20,080 --> 00:26:23,360
is that teams will have a few specified

00:26:22,320 --> 00:26:25,679
linux devs

00:26:23,360 --> 00:26:26,799
who are comfortable using gdb from the

00:26:25,679 --> 00:26:28,960
command line

00:26:26,799 --> 00:26:30,559
and are responsible for debugging all

00:26:28,960 --> 00:26:32,559
linux failures

00:26:30,559 --> 00:26:34,159
and this can definitely help but it

00:26:32,559 --> 00:26:36,640
doesn't really address the root of the

00:26:34,159 --> 00:26:36,640
problem

00:26:37,120 --> 00:26:40,159
a second source of tension is if and

00:26:39,520 --> 00:26:42,640
when

00:26:40,159 --> 00:26:44,240
to use a graphical interface versus a

00:26:42,640 --> 00:26:46,880
command driven interface

00:26:44,240 --> 00:26:48,480
when debugging and command line tools

00:26:46,880 --> 00:26:50,799
are perfectly fine

00:26:48,480 --> 00:26:52,000
but there might be some times when you

00:26:50,799 --> 00:26:54,799
or other folks on your

00:26:52,000 --> 00:26:56,400
team would prefer a graphical interface

00:26:54,799 --> 00:26:57,279
maybe it's to see breakpoints

00:26:56,400 --> 00:26:59,279
highlighted

00:26:57,279 --> 00:27:02,000
or maybe it's to have both the watches

00:26:59,279 --> 00:27:04,240
and locals windows open simultaneously

00:27:02,000 --> 00:27:06,159
and staying in the same visual location

00:27:04,240 --> 00:27:07,679
as you step through your code

00:27:06,159 --> 00:27:09,679
instead of having to request that

00:27:07,679 --> 00:27:13,360
information on each step

00:27:09,679 --> 00:27:15,279
or scroll up and down in your terminal

00:27:13,360 --> 00:27:16,400
command line tools can also have a

00:27:15,279 --> 00:27:18,960
greater learning curve

00:27:16,400 --> 00:27:20,640
which again is perfectly fine but if

00:27:18,960 --> 00:27:23,039
that learning curve only exists

00:27:20,640 --> 00:27:25,039
on one of your target platforms then it

00:27:23,039 --> 00:27:25,360
might lead to some unbalanced solutions

00:27:25,039 --> 00:27:27,600
like

00:27:25,360 --> 00:27:28,559
only a subset of your developers being

00:27:27,600 --> 00:27:31,679
able to debug

00:27:28,559 --> 00:27:31,679
all linux failures

00:27:32,399 --> 00:27:37,279
and lastly we know that some developers

00:27:34,960 --> 00:27:40,080
will actually switch between platforms

00:27:37,279 --> 00:27:41,279
daily or weekly to work natively on that

00:27:40,080 --> 00:27:43,520
platform when debugging

00:27:41,279 --> 00:27:45,520
platform-specific issues

00:27:43,520 --> 00:27:46,799
and this works but it can also be really

00:27:45,520 --> 00:27:48,559
unproductive

00:27:46,799 --> 00:27:50,559
especially if you're using a different

00:27:48,559 --> 00:27:51,600
editor or debugging tools on those

00:27:50,559 --> 00:27:52,799
platforms

00:27:51,600 --> 00:27:55,200
because then you might need to

00:27:52,799 --> 00:27:58,159
reconfigure your project in all those

00:27:55,200 --> 00:27:58,159
different contexts

00:27:58,559 --> 00:28:02,240
fortunately there exist a lot of tools

00:28:00,799 --> 00:28:05,039
that are out there to help make your

00:28:02,240 --> 00:28:07,360
life easier

00:28:05,039 --> 00:28:09,200
one classic tools are cross-platform

00:28:07,360 --> 00:28:11,840
ides and editors

00:28:09,200 --> 00:28:12,960
and these run natively on windows linux

00:28:11,840 --> 00:28:15,279
and mac

00:28:12,960 --> 00:28:16,000
and a few popular examples include

00:28:15,279 --> 00:28:19,760
c-line

00:28:16,000 --> 00:28:20,240
vs code and q-creator these tools all

00:28:19,760 --> 00:28:22,159
provide

00:28:20,240 --> 00:28:23,760
a graphical interface for command-line

00:28:22,159 --> 00:28:26,799
debuggers like gdb

00:28:23,760 --> 00:28:28,640
and lldb and they can also provide a

00:28:26,799 --> 00:28:30,240
consistent user experience

00:28:28,640 --> 00:28:31,840
when you're working across multiple

00:28:30,240 --> 00:28:33,919
platforms

00:28:31,840 --> 00:28:35,679
but they don't necessarily address the

00:28:33,919 --> 00:28:39,360
issue of having to switch between

00:28:35,679 --> 00:28:39,360
platforms to debug natively

00:28:40,000 --> 00:28:44,159
another class of solutions is remote

00:28:42,159 --> 00:28:46,320
debugging which we can define

00:28:44,159 --> 00:28:47,679
as debugging a program running on a

00:28:46,320 --> 00:28:50,080
different system

00:28:47,679 --> 00:28:52,799
and likely a different operating system

00:28:50,080 --> 00:28:54,960
than the one you are working on

00:28:52,799 --> 00:28:57,279
one example of this kind of solution are

00:28:54,960 --> 00:28:59,039
the vs code remote extensions

00:28:57,279 --> 00:29:01,279
and there's actually three extensions

00:28:59,039 --> 00:29:02,240
here there's the ssh extension for

00:29:01,279 --> 00:29:05,840
debugging on

00:29:02,240 --> 00:29:08,080
ssh connections the wsl extension

00:29:05,840 --> 00:29:08,880
for debugging on the windows subsystem

00:29:08,080 --> 00:29:11,200
for linux

00:29:08,880 --> 00:29:12,159
from windows and there's the docker

00:29:11,200 --> 00:29:13,840
extension

00:29:12,159 --> 00:29:15,679
and for more information on these

00:29:13,840 --> 00:29:17,840
extensions and a demo

00:29:15,679 --> 00:29:19,600
i would recommend checking out julia's

00:29:17,840 --> 00:29:21,840
talk which was on monday

00:29:19,600 --> 00:29:24,000
so if you missed that then you can check

00:29:21,840 --> 00:29:26,720
the recording

00:29:24,000 --> 00:29:27,600
and how these extensions work is

00:29:26,720 --> 00:29:30,159
essentially

00:29:27,600 --> 00:29:31,600
you're required to run install the back

00:29:30,159 --> 00:29:34,320
end of visual studio code

00:29:31,600 --> 00:29:34,720
on your target system that also hosts

00:29:34,320 --> 00:29:36,799
your

00:29:34,720 --> 00:29:38,799
source code build tools and debugging

00:29:36,799 --> 00:29:39,760
tools and then you can debug from

00:29:38,799 --> 00:29:43,600
whatever host

00:29:39,760 --> 00:29:46,240
is also running visual studio code

00:29:43,600 --> 00:29:48,080
another option for remote debugging is

00:29:46,240 --> 00:29:49,919
visual studios remote support

00:29:48,080 --> 00:29:53,520
which provides first class support for

00:29:49,919 --> 00:29:55,679
gdb and gdp server

00:29:53,520 --> 00:29:57,279
how that works is your source code

00:29:55,679 --> 00:29:58,960
originates on windows

00:29:57,279 --> 00:30:00,799
and visual studio will automatically

00:29:58,960 --> 00:30:02,080
copy your source files over to your

00:30:00,799 --> 00:30:04,399
linux system

00:30:02,080 --> 00:30:05,520
and maintain two synchronous copies of

00:30:04,399 --> 00:30:07,679
your source tree

00:30:05,520 --> 00:30:09,520
so your linux system only needs to host

00:30:07,679 --> 00:30:11,279
your build tools and your debugging

00:30:09,520 --> 00:30:14,320
tools

00:30:11,279 --> 00:30:15,760
visual studio has native support for wsl

00:30:14,320 --> 00:30:18,320
which means that all commands are

00:30:15,760 --> 00:30:20,880
executed locally and there's no need to

00:30:18,320 --> 00:30:23,440
establish an ssh connection

00:30:20,880 --> 00:30:25,120
and also allows you this to separate the

00:30:23,440 --> 00:30:27,120
system that you're building on

00:30:25,120 --> 00:30:28,559
from the system that you are deploying

00:30:27,120 --> 00:30:31,200
to and debugging on

00:30:28,559 --> 00:30:32,960
so for example you might cross compile

00:30:31,200 --> 00:30:35,919
natively on wsl for

00:30:32,960 --> 00:30:37,760
arm and then deploy that executable to a

00:30:35,919 --> 00:30:39,840
second remote linux system

00:30:37,760 --> 00:30:41,120
an arm linux system that's connected

00:30:39,840 --> 00:30:43,440
over ssh

00:30:41,120 --> 00:30:45,760
and debug the executable eugene gdb

00:30:43,440 --> 00:30:48,640
server

00:30:45,760 --> 00:30:50,960
finally both sea lion and cute creator

00:30:48,640 --> 00:30:53,279
also have remote debugging solutions for

00:30:50,960 --> 00:30:56,320
debugging against remote linux systems

00:30:53,279 --> 00:30:56,320
and wsl

00:30:57,360 --> 00:31:00,960
and the last section that i'm going to

00:30:58,799 --> 00:31:03,279
talk about today is testing

00:31:00,960 --> 00:31:05,360
and this is a huge problem area i'm

00:31:03,279 --> 00:31:06,240
going to be focusing primarily on unit

00:31:05,360 --> 00:31:08,559
testing

00:31:06,240 --> 00:31:10,559
but i do want to give a nod to static

00:31:08,559 --> 00:31:12,880
and dynamic analysis tools

00:31:10,559 --> 00:31:15,120
and for more information on those spaces

00:31:12,880 --> 00:31:18,000
i would recommend these two talks

00:31:15,120 --> 00:31:18,320
they both occurred yesterday on tuesday

00:31:18,000 --> 00:31:20,240
so

00:31:18,320 --> 00:31:23,360
again if you miss them then you can

00:31:20,240 --> 00:31:23,360
catch the recordings

00:31:25,200 --> 00:31:29,039
alright so we know that writing unit

00:31:27,840 --> 00:31:31,600
tests can be difficult

00:31:29,039 --> 00:31:32,080
especially if you're working with legacy

00:31:31,600 --> 00:31:33,519
code

00:31:32,080 --> 00:31:35,600
and we also know that they always

00:31:33,519 --> 00:31:38,000
provide some value but they can be

00:31:35,600 --> 00:31:38,960
especially valuable for cross-platform

00:31:38,000 --> 00:31:40,960
developers

00:31:38,960 --> 00:31:43,039
because when used in conjunction with a

00:31:40,960 --> 00:31:45,200
continuous integration system

00:31:43,039 --> 00:31:46,880
they can catch runtime errors across

00:31:45,200 --> 00:31:48,720
multiple platforms

00:31:46,880 --> 00:31:52,240
and this partnership is going to be the

00:31:48,720 --> 00:31:52,240
focus of this section

00:31:52,480 --> 00:31:57,440
so what kind of tools are available to

00:31:54,559 --> 00:32:00,320
help you achieve this

00:31:57,440 --> 00:32:02,399
c test is c makes test driver program

00:32:00,320 --> 00:32:04,559
and is used to manage and execute

00:32:02,399 --> 00:32:08,159
a complete suite of tests with or

00:32:04,559 --> 00:32:10,080
without a unit testing framework

00:32:08,159 --> 00:32:11,440
unit testing frameworks are used to

00:32:10,080 --> 00:32:14,080
author individual c

00:32:11,440 --> 00:32:15,600
plus plus unit tests and some popular

00:32:14,080 --> 00:32:18,880
cross-platform examples

00:32:15,600 --> 00:32:20,559
include google test boost test and cache

00:32:18,880 --> 00:32:23,279
2.

00:32:20,559 --> 00:32:25,840
our recommendation is to use c-test and

00:32:23,279 --> 00:32:29,200
a cross-platform unit testing framework

00:32:25,840 --> 00:32:31,519
together unit testing frameworks provide

00:32:29,200 --> 00:32:32,159
all the primitives for a designing unit

00:32:31,519 --> 00:32:34,960
test

00:32:32,159 --> 00:32:37,440
like exception handling and assertions

00:32:34,960 --> 00:32:39,200
and when used in conjunction with c-test

00:32:37,440 --> 00:32:40,480
can make your life easier than you

00:32:39,200 --> 00:32:43,600
trying to hand roll

00:32:40,480 --> 00:32:45,679
all that same functionality on your own

00:32:43,600 --> 00:32:46,960
it's pretty easy to enable a cmic

00:32:45,679 --> 00:32:49,519
project to use c

00:32:46,960 --> 00:32:51,279
test and a unit testing framework it's

00:32:49,519 --> 00:32:52,399
just a few lines of c make

00:32:51,279 --> 00:32:56,080
and that's something that i'm going to

00:32:52,399 --> 00:32:58,799
be showing more in my second demo

00:32:56,080 --> 00:32:59,360
finally for some unit testing frameworks

00:32:58,799 --> 00:33:02,159
cma

00:32:59,360 --> 00:33:04,399
can automatically extract unit tests at

00:33:02,159 --> 00:33:07,200
the individual test method level

00:33:04,399 --> 00:33:08,799
by clearing the compiled test executable

00:33:07,200 --> 00:33:10,880
for available tests

00:33:08,799 --> 00:33:12,559
and this translates really nicely if

00:33:10,880 --> 00:33:15,120
you're using an ide

00:33:12,559 --> 00:33:16,960
or a continuous integration system

00:33:15,120 --> 00:33:19,279
because it'll allow you to to view

00:33:16,960 --> 00:33:20,240
individual test results at the test

00:33:19,279 --> 00:33:22,559
method level

00:33:20,240 --> 00:33:23,679
instead of at the c-test level which can

00:33:22,559 --> 00:33:25,679
make it easier to

00:33:23,679 --> 00:33:28,559
diagnose and find out exactly where

00:33:25,679 --> 00:33:28,559
things are going wrong

00:33:29,200 --> 00:33:34,159
so with that i can jump on into my

00:33:31,440 --> 00:33:34,159
second demo

00:33:35,519 --> 00:33:40,000
all right now i'm backing visual studio

00:33:38,000 --> 00:33:42,159
and the first thing i want to do is

00:33:40,000 --> 00:33:44,640
show you how i've enabled this project

00:33:42,159 --> 00:33:47,919
to use c test and google test

00:33:44,640 --> 00:33:51,200
so open up my root cmic list

00:33:47,919 --> 00:33:53,279
and here i included c test

00:33:51,200 --> 00:33:54,240
and i've used this built-in build

00:33:53,279 --> 00:33:58,000
testing option

00:33:54,240 --> 00:34:01,279
which defaults to on to enable testing

00:33:58,000 --> 00:34:03,919
and add the test subdirectory then i'll

00:34:01,279 --> 00:34:07,120
jump back to the cmic list that defines

00:34:03,919 --> 00:34:08,720
my test executable i only have one test

00:34:07,120 --> 00:34:11,119
executable in this project

00:34:08,720 --> 00:34:12,079
but you can have as many as you'd like

00:34:11,119 --> 00:34:14,879
and i

00:34:12,079 --> 00:34:16,720
find and include google test and again

00:34:14,879 --> 00:34:21,839
i'm using this vc package

00:34:16,720 --> 00:34:21,839
manifest file to actually acquire g-test

00:34:22,639 --> 00:34:26,720
link against g-test and then i can use

00:34:25,679 --> 00:34:30,159
this built-in

00:34:26,720 --> 00:34:32,879
g-test discover test command and pass it

00:34:30,159 --> 00:34:34,639
my box 2d test executable

00:34:32,879 --> 00:34:36,240
and then cmake will automatically

00:34:34,639 --> 00:34:38,720
extract unit tests

00:34:36,240 --> 00:34:41,040
at the individual test method level by

00:34:38,720 --> 00:34:44,480
acquiring that compiled box 2d

00:34:41,040 --> 00:34:49,839
test executable for available tests

00:34:44,480 --> 00:34:52,000
such that when i open the test explorer

00:34:49,839 --> 00:34:52,960
i can see individual unit tests

00:34:52,000 --> 00:34:55,359
enumerated

00:34:52,960 --> 00:34:56,079
at the test method level so that means i

00:34:55,359 --> 00:35:00,839
can run

00:34:56,079 --> 00:35:02,000
one individual unit test and view the

00:35:00,839 --> 00:35:05,119
results

00:35:02,000 --> 00:35:09,040
or i can run a group of tests and view

00:35:05,119 --> 00:35:09,040
the results at the test method level

00:35:10,240 --> 00:35:18,079
so in this case all of the tests passed

00:35:16,079 --> 00:35:19,359
we'll also see the same level of

00:35:18,079 --> 00:35:22,000
granularity in

00:35:19,359 --> 00:35:22,400
our continuous integration system so

00:35:22,000 --> 00:35:24,079
this

00:35:22,400 --> 00:35:25,440
project has been configured to use

00:35:24,079 --> 00:35:27,680
github actions

00:35:25,440 --> 00:35:28,720
and i've authored a workflow file that

00:35:27,680 --> 00:35:31,040
will automatically

00:35:28,720 --> 00:35:31,839
build this project on both windows and

00:35:31,040 --> 00:35:35,040
linux

00:35:31,839 --> 00:35:37,040
and run the full suite of tests on push

00:35:35,040 --> 00:35:38,800
so to get that workflow started all

00:35:37,040 --> 00:35:41,920
we'll need to do is commit

00:35:38,800 --> 00:35:45,520
our changes so git

00:35:41,920 --> 00:35:48,000
commit the only change that we've made

00:35:45,520 --> 00:35:51,920
is to add that missing dependency

00:35:48,000 --> 00:35:55,040
so add we see json um

00:35:51,920 --> 00:35:59,119
we added glad

00:35:55,040 --> 00:36:03,119
commit those changes and then

00:35:59,119 --> 00:36:04,960
push to the remote and i did all this

00:36:03,119 --> 00:36:07,040
using visual studio's new get

00:36:04,960 --> 00:36:08,160
integration but obviously you can also

00:36:07,040 --> 00:36:10,400
use a command driven

00:36:08,160 --> 00:36:12,240
workflow as well so if you prefer

00:36:10,400 --> 00:36:13,119
command line tools or command driven

00:36:12,240 --> 00:36:15,520
workflows

00:36:13,119 --> 00:36:18,160
then visual studio also now has an

00:36:15,520 --> 00:36:20,000
integrated terminal

00:36:18,160 --> 00:36:22,640
so that you can use your command line

00:36:20,000 --> 00:36:25,760
tools or your command driven workflows

00:36:22,640 --> 00:36:29,040
right in the context of visual studio

00:36:25,760 --> 00:36:30,720
so i'll close this

00:36:29,040 --> 00:36:32,960
and there's a couple more things i want

00:36:30,720 --> 00:36:34,160
to show you locally before i switch on

00:36:32,960 --> 00:36:35,839
over to github

00:36:34,160 --> 00:36:37,359
and walk through that github actions

00:36:35,839 --> 00:36:40,240
workflow

00:36:37,359 --> 00:36:41,119
so this talk is all about cross-platform

00:36:40,240 --> 00:36:43,520
development

00:36:41,119 --> 00:36:45,440
but so far i've only been building and

00:36:43,520 --> 00:36:47,680
running locally on windows

00:36:45,440 --> 00:36:50,560
so now i'm going to show you how easy it

00:36:47,680 --> 00:36:53,839
is to retarget the same cmake project

00:36:50,560 --> 00:36:55,119
for linux so i'll go ahead and make my

00:36:53,839 --> 00:36:58,160
linux configuration

00:36:55,119 --> 00:36:58,480
my active configuration and i can show

00:36:58,160 --> 00:37:01,280
you

00:36:58,480 --> 00:37:02,880
where i've defined that so here in the

00:37:01,280 --> 00:37:06,839
cmx settings editor

00:37:02,880 --> 00:37:10,560
all i've had to do is specify

00:37:06,839 --> 00:37:13,599
um oops it's down here

00:37:10,560 --> 00:37:16,400
oh make my lens configuration active

00:37:13,599 --> 00:37:16,800
and then specify my remote machine name

00:37:16,400 --> 00:37:18,880
or

00:37:16,800 --> 00:37:20,400
the build machine that visual studio

00:37:18,880 --> 00:37:22,880
will be targeting

00:37:20,400 --> 00:37:24,720
and if i needed to add a new connection

00:37:22,880 --> 00:37:26,720
then i could do that in the connection

00:37:24,720 --> 00:37:29,839
manager where i can add and remove

00:37:26,720 --> 00:37:33,119
my ssh connections and i'm targeting a

00:37:29,839 --> 00:37:33,119
local hyper-v vm

00:37:34,640 --> 00:37:37,920
here i can also do things like set

00:37:36,640 --> 00:37:41,119
environment variables

00:37:37,920 --> 00:37:44,560
past c make variables um

00:37:41,119 --> 00:37:47,520
pick my compilers and things like that

00:37:44,560 --> 00:37:48,400
so now that this configuration is active

00:37:47,520 --> 00:37:51,760
when i go

00:37:48,400 --> 00:37:53,280
and generate the cache then i will start

00:37:51,760 --> 00:37:55,920
configuring the cmake project

00:37:53,280 --> 00:37:57,839
on my remote linux system and just to

00:37:55,920 --> 00:38:00,079
walk through what's happening here

00:37:57,839 --> 00:38:01,200
visual studio is using all of the build

00:38:00,079 --> 00:38:04,079
tools that exist

00:38:01,200 --> 00:38:05,920
on my linux system so we're invoking

00:38:04,079 --> 00:38:07,359
cmake using the cmake that exists on

00:38:05,920 --> 00:38:09,040
that linux system

00:38:07,359 --> 00:38:10,400
we're going to build with the build

00:38:09,040 --> 00:38:13,280
tools in this case

00:38:10,400 --> 00:38:14,320
gcc and ninja that exist on that linux

00:38:13,280 --> 00:38:16,240
system

00:38:14,320 --> 00:38:18,560
and visual studio is automatically

00:38:16,240 --> 00:38:21,520
maintaining two synchronous copies of my

00:38:18,560 --> 00:38:23,839
source tree on windows and linux

00:38:21,520 --> 00:38:24,640
so it looks like cmake generation has

00:38:23,839 --> 00:38:27,599
finished

00:38:24,640 --> 00:38:28,000
and now just like before i can build and

00:38:27,599 --> 00:38:30,880
run

00:38:28,000 --> 00:38:33,839
the samples executable but this time on

00:38:30,880 --> 00:38:33,839
linux

00:38:34,560 --> 00:38:37,599
so i'll go ahead and switch over to my

00:38:37,040 --> 00:38:40,720
vm

00:38:37,599 --> 00:38:47,200
now so you can see when that

00:38:40,720 --> 00:38:51,119
application launches

00:38:47,200 --> 00:39:00,160
and here i have samples

00:38:51,119 --> 00:39:02,640
but running on linux

00:39:00,160 --> 00:39:04,240
i can also debug against an application

00:39:02,640 --> 00:39:08,079
that's running on linux

00:39:04,240 --> 00:39:12,400
so i'll go into a source file

00:39:08,079 --> 00:39:15,920
that is part of this samples executable

00:39:12,400 --> 00:39:19,040
control g to go to line 134

00:39:15,920 --> 00:39:21,520
i'll set a breakpoint and this time when

00:39:19,040 --> 00:39:22,320
i run the samples executable under the

00:39:21,520 --> 00:39:29,839
debugger

00:39:22,320 --> 00:39:29,839
i'm going to hit my breakpoint

00:39:30,800 --> 00:39:37,920
and here i've hit my break point and i

00:39:34,720 --> 00:39:41,760
can step through

00:39:37,920 --> 00:39:45,119
just like if i was debugging locally on

00:39:41,760 --> 00:39:48,560
windows and this is using

00:39:45,119 --> 00:39:49,920
visual studio with gdb so it's gdb with

00:39:48,560 --> 00:39:52,400
the front end of the visual studio

00:39:49,920 --> 00:39:52,400
debugger

00:39:53,920 --> 00:39:57,599
the last thing that i want to do is show

00:39:55,680 --> 00:39:58,240
you how i configured this debugging

00:39:57,599 --> 00:40:01,520
session

00:39:58,240 --> 00:40:03,200
so i will go to debug debug and launch

00:40:01,520 --> 00:40:06,480
settings for samples

00:40:03,200 --> 00:40:08,640
this option just matches whatever target

00:40:06,480 --> 00:40:11,040
is active in this drop down right here

00:40:08,640 --> 00:40:13,920
so because i have the samples executable

00:40:11,040 --> 00:40:17,359
active then this will bring me to debug

00:40:13,920 --> 00:40:20,720
and launch settings for samples

00:40:17,359 --> 00:40:22,079
and here i have launch.bs.json

00:40:20,720 --> 00:40:24,640
which is where you configure all

00:40:22,079 --> 00:40:26,720
debugging sessions for cmake projects

00:40:24,640 --> 00:40:28,000
so i can do things like pick whether i

00:40:26,720 --> 00:40:31,760
want to use gdb

00:40:28,000 --> 00:40:33,920
or gdb server i can pass arguments

00:40:31,760 --> 00:40:36,319
i can set environment variables so the

00:40:33,920 --> 00:40:38,960
only change that i need to make to this

00:40:36,319 --> 00:40:40,000
default configuration was to export my

00:40:38,960 --> 00:40:42,319
display variable

00:40:40,000 --> 00:40:44,400
to match the default or the value of the

00:40:42,319 --> 00:40:45,760
display environment variable on my linux

00:40:44,400 --> 00:40:47,359
system

00:40:45,760 --> 00:40:48,960
if you've used remote debugging with

00:40:47,359 --> 00:40:51,119
visual studio before

00:40:48,960 --> 00:40:54,240
you might realize that this is a new and

00:40:51,119 --> 00:40:56,160
streamlined template of type cpp gdb

00:40:54,240 --> 00:40:58,000
and we added that recently to make it

00:40:56,160 --> 00:40:58,800
easier for you to configure debugging

00:40:58,000 --> 00:41:02,000
sessions

00:40:58,800 --> 00:41:06,000
on linux systems or wsl that use gdb

00:41:02,000 --> 00:41:07,760
or gdb server and with that i'm going to

00:41:06,000 --> 00:41:09,040
jump on over to github now

00:41:07,760 --> 00:41:12,960
to walk through that continuous

00:41:09,040 --> 00:41:12,960
integration workflow that i kicked off

00:41:13,119 --> 00:41:20,000
so here we are in github

00:41:16,880 --> 00:41:20,880
and here is the run that i started five

00:41:20,000 --> 00:41:24,880
minutes ago

00:41:20,880 --> 00:41:24,880
it took two minutes to complete

00:41:26,480 --> 00:41:32,400
you can see there were two jobs i ran on

00:41:28,560 --> 00:41:35,359
both windows and linux ubuntu 2004

00:41:32,400 --> 00:41:38,400
and i'll jump into the windows 1 to show

00:41:35,359 --> 00:41:40,720
you what was happening

00:41:38,400 --> 00:41:42,480
so basically what we did here is we

00:41:40,720 --> 00:41:45,839
acquire cmake

00:41:42,480 --> 00:41:47,920
we acquire vc package we set up our

00:41:45,839 --> 00:41:50,000
nougat credentials because again i'm

00:41:47,920 --> 00:41:52,319
using nuget as the back end for vc

00:41:50,000 --> 00:41:55,040
package binary caching

00:41:52,319 --> 00:41:57,119
we skipped the app to get update apps

00:41:55,040 --> 00:41:59,280
and app dependencies steps on windows

00:41:57,119 --> 00:42:01,200
because they only apply on linux

00:41:59,280 --> 00:42:03,440
there's a few system libraries for

00:42:01,200 --> 00:42:06,319
opengl that i acquired using the system

00:42:03,440 --> 00:42:06,319
package manager

00:42:06,560 --> 00:42:11,119
we built with simic and ninja which is

00:42:09,200 --> 00:42:12,240
the same build tools that i was using

00:42:11,119 --> 00:42:15,520
locally

00:42:12,240 --> 00:42:16,079
and we ran our full suite of tests so if

00:42:15,520 --> 00:42:18,160
i jump

00:42:16,079 --> 00:42:19,200
into this build with cmake and ninja

00:42:18,160 --> 00:42:22,319
step this

00:42:19,200 --> 00:42:24,960
actually captures both uh generation and

00:42:22,319 --> 00:42:25,520
build so i can scroll down to the

00:42:24,960 --> 00:42:28,079
generate

00:42:25,520 --> 00:42:29,440
project files with cmakestep and expand

00:42:28,079 --> 00:42:31,440
it

00:42:29,440 --> 00:42:33,359
and here you can see the exact same

00:42:31,440 --> 00:42:35,839
output that we were seeing locally when

00:42:33,359 --> 00:42:37,839
i was building on windows earlier

00:42:35,839 --> 00:42:39,599
so here again you can see the list of

00:42:37,839 --> 00:42:40,400
six dependencies that are being

00:42:39,599 --> 00:42:42,480
installed

00:42:40,400 --> 00:42:44,560
the four that i've specified and the two

00:42:42,480 --> 00:42:46,720
transitive ones that bc package is

00:42:44,560 --> 00:42:48,640
fetching and resolving for me

00:42:46,720 --> 00:42:49,760
you can see that again i'm fetching and

00:42:48,640 --> 00:42:52,000
restoring six

00:42:49,760 --> 00:42:53,440
packages from nuget so i'm using the

00:42:52,000 --> 00:42:56,079
same binary cache

00:42:53,440 --> 00:42:56,960
hosted in github packages to download

00:42:56,079 --> 00:42:59,839
and install

00:42:56,960 --> 00:43:02,160
these libraries on both my local dev box

00:42:59,839 --> 00:43:03,920
and in my continuous integration system

00:43:02,160 --> 00:43:05,920
so i can be confident that i'm using the

00:43:03,920 --> 00:43:08,000
exact same version of the library

00:43:05,920 --> 00:43:10,000
built the same way in both of those

00:43:08,000 --> 00:43:11,839
contexts

00:43:10,000 --> 00:43:15,200
again you can also see that this speeds

00:43:11,839 --> 00:43:18,640
up installation so this entire operation

00:43:15,200 --> 00:43:21,680
took four seconds

00:43:18,640 --> 00:43:23,920
i can also expand this run c test step

00:43:21,680 --> 00:43:25,119
and just like in the test explorer i can

00:43:23,920 --> 00:43:27,680
see the results of

00:43:25,119 --> 00:43:29,520
every single unit test enumerated for me

00:43:27,680 --> 00:43:31,440
and that'll make it easy to pick up on

00:43:29,520 --> 00:43:34,319
what's failing or where i might be

00:43:31,440 --> 00:43:34,319
having issues

00:43:35,280 --> 00:43:41,839
i can then move over to the code

00:43:38,839 --> 00:43:44,079
tab and jump down to

00:43:41,839 --> 00:43:45,920
packages so these are the github

00:43:44,079 --> 00:43:47,040
packages that are associated with this

00:43:45,920 --> 00:43:48,800
repository

00:43:47,040 --> 00:43:51,119
and again this is where i'm actually

00:43:48,800 --> 00:43:53,200
storing my binaries that i'm using for

00:43:51,119 --> 00:43:55,760
vc package binary caching

00:43:53,200 --> 00:43:56,319
so you can see i had the x86 windows

00:43:55,760 --> 00:43:59,440
triplet

00:43:56,319 --> 00:44:02,319
of all of the required packages

00:43:59,440 --> 00:44:05,440
and i also have the x64 linux triplets

00:44:02,319 --> 00:44:07,440
so everything is hosted here

00:44:05,440 --> 00:44:08,720
and i'll quickly jump back to visual

00:44:07,440 --> 00:44:10,560
studio

00:44:08,720 --> 00:44:12,640
the last thing i want to show you in

00:44:10,560 --> 00:44:15,839
this demo is the actual

00:44:12,640 --> 00:44:17,599
yaml file that i configured to

00:44:15,839 --> 00:44:19,040
configure that github actions workflow

00:44:17,599 --> 00:44:20,720
that we just stepped through and this

00:44:19,040 --> 00:44:22,480
will all be available on github so you

00:44:20,720 --> 00:44:25,680
can look at it in more detail

00:44:22,480 --> 00:44:27,680
but basically it runs on every push

00:44:25,680 --> 00:44:28,960
and then every step that we saw

00:44:27,680 --> 00:44:31,680
corresponds to

00:44:28,960 --> 00:44:33,920
a few lines of code here so which

00:44:31,680 --> 00:44:36,480
operating systems do i want to run on

00:44:33,920 --> 00:44:38,240
acquiring vc package and cmake i'm using

00:44:36,480 --> 00:44:40,640
some actions that make that stuff a bit

00:44:38,240 --> 00:44:43,119
easier for me

00:44:40,640 --> 00:44:44,319
setting up new bit credentials acquiring

00:44:43,119 --> 00:44:46,480
dependencies

00:44:44,319 --> 00:44:47,359
building and then running the suite of

00:44:46,480 --> 00:44:49,520
tests

00:44:47,359 --> 00:44:51,200
so that was a quick run through and you

00:44:49,520 --> 00:44:52,560
can look at that in more detail if you

00:44:51,200 --> 00:44:55,599
want

00:44:52,560 --> 00:44:57,359
and with that i will hop back on over to

00:44:55,599 --> 00:44:59,200
my slides

00:44:57,359 --> 00:45:01,280
all right just to quickly recap what we

00:44:59,200 --> 00:45:03,839
showed in this second demo

00:45:01,280 --> 00:45:06,319
we showed how easy it can be to enable a

00:45:03,839 --> 00:45:08,800
cmake project to use both c-test

00:45:06,319 --> 00:45:10,160
and google test it's just a few lines of

00:45:08,800 --> 00:45:12,480
cmake

00:45:10,160 --> 00:45:13,839
we showcased remote debugging on linux

00:45:12,480 --> 00:45:16,880
with visual studio

00:45:13,839 --> 00:45:18,640
and that was using gdb and the front end

00:45:16,880 --> 00:45:20,800
of the visual studio debugger

00:45:18,640 --> 00:45:21,839
and i could set breakpoints and step

00:45:20,800 --> 00:45:25,280
through my code

00:45:21,839 --> 00:45:27,599
just like i was debugging on windows

00:45:25,280 --> 00:45:29,680
we also showcased a github actions

00:45:27,599 --> 00:45:32,880
pipeline with github packages

00:45:29,680 --> 00:45:34,880
so there we acquired cmic and vc package

00:45:32,880 --> 00:45:36,319
we've downloaded cache binaries from

00:45:34,880 --> 00:45:38,400
github packages

00:45:36,319 --> 00:45:41,359
we configured and built our cmake

00:45:38,400 --> 00:45:46,319
project on both windows and linux agents

00:45:41,359 --> 00:45:49,040
and ran our full suite of tests

00:45:46,319 --> 00:45:50,240
in my demo all of my tests were passing

00:45:49,040 --> 00:45:52,640
but if they weren't

00:45:50,240 --> 00:45:55,040
we recently added the ability to debug

00:45:52,640 --> 00:45:57,680
linux core dumps in visual studio

00:45:55,040 --> 00:45:58,960
and the latest release of visual studio

00:45:57,680 --> 00:46:02,240
which was released on

00:45:58,960 --> 00:46:05,040
monday and those core doms can be hosted

00:46:02,240 --> 00:46:06,640
on either a remote linux system or wsl

00:46:05,040 --> 00:46:08,160
and leverage our remote debugging

00:46:06,640 --> 00:46:10,160
capabilities

00:46:08,160 --> 00:46:12,240
and this might be especially helpful for

00:46:10,160 --> 00:46:14,640
you if you run a windows shop

00:46:12,240 --> 00:46:15,920
so you primarily build and debug locally

00:46:14,640 --> 00:46:18,640
on windows

00:46:15,920 --> 00:46:20,800
but you also deploy to linux servers and

00:46:18,640 --> 00:46:22,240
you want to diagnose crashes whether

00:46:20,800 --> 00:46:23,680
they occurred in your continuous

00:46:22,240 --> 00:46:26,000
integration system

00:46:23,680 --> 00:46:27,520
or on those servers in a familiar

00:46:26,000 --> 00:46:29,920
environment

00:46:27,520 --> 00:46:31,680
there was a demo of this functionality

00:46:29,920 --> 00:46:34,560
in marion and ty's saw

00:46:31,680 --> 00:46:35,359
marion and size talk which was on monday

00:46:34,560 --> 00:46:36,960
so again

00:46:35,359 --> 00:46:38,480
if you missed that then be sure to catch

00:46:36,960 --> 00:46:41,200
the recording

00:46:38,480 --> 00:46:43,040
i also just published a new blog post

00:46:41,200 --> 00:46:45,040
that walks through this feature

00:46:43,040 --> 00:46:47,440
and describes it in a bit more detail to

00:46:45,040 --> 00:46:49,440
the seed plus plus team blog

00:46:47,440 --> 00:46:51,680
and in general our team blog is a great

00:46:49,440 --> 00:46:52,880
place to go to stay up to date with new

00:46:51,680 --> 00:46:55,040
functionality

00:46:52,880 --> 00:46:57,839
or also just to see descriptions of new

00:46:55,040 --> 00:46:57,839
workflows

00:46:59,280 --> 00:47:02,960
with that i hope that you enjoyed this

00:47:01,119 --> 00:47:04,800
talk and that you maybe gain some

00:47:02,960 --> 00:47:06,160
awareness of all the tools that are

00:47:04,800 --> 00:47:08,839
available to help make your

00:47:06,160 --> 00:47:11,920
cross-platform development workflows

00:47:08,839 --> 00:47:13,440
easier i hope you realize that while you

00:47:11,920 --> 00:47:15,839
might have some problems that are

00:47:13,440 --> 00:47:17,760
completely unique to you and your team

00:47:15,839 --> 00:47:18,960
you also might have some problems that

00:47:17,760 --> 00:47:21,359
are shared between

00:47:18,960 --> 00:47:22,960
other cross-platform developers and for

00:47:21,359 --> 00:47:26,000
those problems we can use

00:47:22,960 --> 00:47:26,000
shared solutions

00:47:26,160 --> 00:47:30,400
and finally i hope you will talk to me

00:47:28,800 --> 00:47:32,960
talk to others on my team

00:47:30,400 --> 00:47:34,720
talk to other people who work on tooling

00:47:32,960 --> 00:47:36,480
because we work on tooling because we

00:47:34,720 --> 00:47:39,280
hope it will make your lives easier

00:47:36,480 --> 00:47:41,119
so if you have unmet needs or you have

00:47:39,280 --> 00:47:42,000
particularly painful parts of your

00:47:41,119 --> 00:47:43,920
workflow

00:47:42,000 --> 00:47:45,680
then please talk to us because those

00:47:43,920 --> 00:47:46,559
problems are probably not specific to

00:47:45,680 --> 00:47:48,800
just you

00:47:46,559 --> 00:47:50,640
they might be shared with others and

00:47:48,800 --> 00:47:51,359
we're constantly iterating over our

00:47:50,640 --> 00:47:53,680
tools

00:47:51,359 --> 00:47:57,440
or designing new tools that we think

00:47:53,680 --> 00:47:57,440
will help make your lives even easier

00:47:57,920 --> 00:48:02,319
as promised so i was working with a

00:48:00,240 --> 00:48:04,240
private fork of this repo today because

00:48:02,319 --> 00:48:06,559
the github packages are private

00:48:04,240 --> 00:48:07,920
but i also have everything checked into

00:48:06,559 --> 00:48:09,839
a public repo

00:48:07,920 --> 00:48:11,599
so if you want to take a look at that

00:48:09,839 --> 00:48:13,680
and take a closer look at anything

00:48:11,599 --> 00:48:14,800
including the yaml file that we used to

00:48:13,680 --> 00:48:17,359
actually configure

00:48:14,800 --> 00:48:18,960
that github actions workflow then you

00:48:17,359 --> 00:48:21,839
can take a look at that and this is the

00:48:18,960 --> 00:48:21,839
url

00:48:22,880 --> 00:48:26,800
please enjoy the rest of the conference

00:48:24,720 --> 00:48:27,520
and again if you have any follow-up

00:48:26,800 --> 00:48:29,839
questions

00:48:27,520 --> 00:48:31,440
comments or just want to say hi then you

00:48:29,839 --> 00:48:35,599
can stop by our table

00:48:31,440 --> 00:48:37,920
at the virtual expo hall

00:48:35,599 --> 00:48:39,599
these sessions already passed uh there's

00:48:37,920 --> 00:48:42,480
a couple that i called out in the

00:48:39,599 --> 00:48:43,520
in my talk today and there's a few more

00:48:42,480 --> 00:48:45,760
that are still coming

00:48:43,520 --> 00:48:46,880
and these are talks given by other folks

00:48:45,760 --> 00:48:48,960
on microsoft c

00:48:46,880 --> 00:48:50,400
plus plus team so it looks like there's

00:48:48,960 --> 00:48:53,359
one more today

00:48:50,400 --> 00:48:54,720
and one on friday so thank you again for

00:48:53,359 --> 00:48:57,119
coming

00:48:54,720 --> 00:48:59,119
hi everyone hopefully you can hear me

00:48:57,119 --> 00:49:02,079
all right uh just post in the chat

00:48:59,119 --> 00:49:03,280
if you can't and i'm now going to go

00:49:02,079 --> 00:49:04,800
through some of the questions that were

00:49:03,280 --> 00:49:09,200
posted throughout the talk

00:49:04,800 --> 00:49:11,599
so starting with this first one

00:49:09,200 --> 00:49:12,880
um sorry just looking at the chat so

00:49:11,599 --> 00:49:13,760
starting with the one with the most

00:49:12,880 --> 00:49:16,240
upvotes here

00:49:13,760 --> 00:49:17,680
do package managers pull and build

00:49:16,240 --> 00:49:19,920
dependencies locally

00:49:17,680 --> 00:49:21,280
or grab pre-built binaries from some

00:49:19,920 --> 00:49:23,520
well-known location

00:49:21,280 --> 00:49:26,160
that's a great question so i first want

00:49:23,520 --> 00:49:28,240
to say that different package managers

00:49:26,160 --> 00:49:30,319
support different functionality i will

00:49:28,240 --> 00:49:32,720
speak to vc package which is the tool

00:49:30,319 --> 00:49:35,040
that i demoed in the first demo

00:49:32,720 --> 00:49:36,000
so with bc package it's not pre-built

00:49:35,040 --> 00:49:39,119
binaries

00:49:36,000 --> 00:49:41,440
it is by uh libraries that you have

00:49:39,119 --> 00:49:43,280
built and compiled at some point locally

00:49:41,440 --> 00:49:45,839
with your own build tools that you know

00:49:43,280 --> 00:49:46,640
integrates well with your own projects

00:49:45,839 --> 00:49:50,160
you can then

00:49:46,640 --> 00:49:52,160
um modify your vc package installation

00:49:50,160 --> 00:49:52,559
to use binary caching and you can do

00:49:52,160 --> 00:49:54,480
that

00:49:52,559 --> 00:49:56,400
by setting a few environment variables

00:49:54,480 --> 00:49:58,720
but in that way you can cache those

00:49:56,400 --> 00:50:01,040
binaries that you have built locally

00:49:58,720 --> 00:50:03,040
in some shared locations so that can be

00:50:01,040 --> 00:50:06,079
github packages like i was using

00:50:03,040 --> 00:50:08,000
or a file share and then other

00:50:06,079 --> 00:50:08,960
developers working on other systems will

00:50:08,000 --> 00:50:11,440
be able to pull

00:50:08,960 --> 00:50:12,000
down those cache binaries that you have

00:50:11,440 --> 00:50:14,720
personally

00:50:12,000 --> 00:50:16,160
built to use on their own systems so

00:50:14,720 --> 00:50:18,319
it's not pre-built it's something that

00:50:16,160 --> 00:50:20,720
some developer on your team has built

00:50:18,319 --> 00:50:22,960
intentionally and by default if you

00:50:20,720 --> 00:50:24,079
don't enable binary caching to point to

00:50:22,960 --> 00:50:27,440
some

00:50:24,079 --> 00:50:28,000
remote shared um cache or a file share

00:50:27,440 --> 00:50:30,079
or something

00:50:28,000 --> 00:50:31,760
then binary caching is done locally so

00:50:30,079 --> 00:50:33,200
that you on your own system

00:50:31,760 --> 00:50:35,040
will always use this you'll never have

00:50:33,200 --> 00:50:36,800
to build the same label library twice

00:50:35,040 --> 00:50:38,240
the same way

00:50:36,800 --> 00:50:40,319
and if you have more questions about

00:50:38,240 --> 00:50:42,240
that you can come to our booth talk to

00:50:40,319 --> 00:50:45,520
me or talk to some of the folks who

00:50:42,240 --> 00:50:45,520
uh work on bc package

00:50:45,680 --> 00:50:50,480
second question will there be catch to

00:50:48,319 --> 00:50:52,000
support for visual studio

00:50:50,480 --> 00:50:54,319
um that's not something that we have a

00:50:52,000 --> 00:50:56,720
firm timeline to share right now

00:50:54,319 --> 00:50:58,240
in the chat i did post a link to a

00:50:56,720 --> 00:51:00,400
developer community

00:50:58,240 --> 00:51:01,520
suggestion asking for that so please go

00:51:00,400 --> 00:51:03,599
ahead and upload that

00:51:01,520 --> 00:51:05,040
we use your upvotes to help prioritize

00:51:03,599 --> 00:51:08,319
new features

00:51:05,040 --> 00:51:10,720
um and i believe there's also a

00:51:08,319 --> 00:51:11,839
open source third part or not a third

00:51:10,720 --> 00:51:14,319
party extension

00:51:11,839 --> 00:51:16,160
that provides some catch to support so i

00:51:14,319 --> 00:51:16,880
can't speak to exactly what that

00:51:16,160 --> 00:51:18,640
provides

00:51:16,880 --> 00:51:19,920
and how it integrates with visual studio

00:51:18,640 --> 00:51:22,720
but it might be something that's worth

00:51:19,920 --> 00:51:26,240
checking out

00:51:22,720 --> 00:51:28,160
all right next question let's say your

00:51:26,240 --> 00:51:30,559
app depends on package a

00:51:28,160 --> 00:51:31,359
but package a depends on package b i

00:51:30,559 --> 00:51:33,760
have a bug

00:51:31,359 --> 00:51:35,599
in my app that's traced to package b

00:51:33,760 --> 00:51:37,599
what are effective ways to prototype and

00:51:35,599 --> 00:51:40,640
test the fix for package b

00:51:37,599 --> 00:51:42,319
that's another great question um when

00:51:40,640 --> 00:51:43,839
you're working with vc package some

00:51:42,319 --> 00:51:46,160
ideas that come to mind is that you

00:51:43,839 --> 00:51:49,280
could fork vc package and point b

00:51:46,160 --> 00:51:51,200
to your own fork of b or somehow modify

00:51:49,280 --> 00:51:52,400
cmake to use your own local copy of b

00:51:51,200 --> 00:51:53,920
that you know works

00:51:52,400 --> 00:51:55,920
but i think this would still be a bit of

00:51:53,920 --> 00:51:58,559
a pain and so robert

00:51:55,920 --> 00:52:00,480
who works on vc package is going to be

00:51:58,559 --> 00:52:03,200
at the microsoft booth today

00:52:00,480 --> 00:52:04,000
at 1 30 pm mountain time so i would

00:52:03,200 --> 00:52:07,520
probably defer to

00:52:04,000 --> 00:52:08,880
him for some so more information on

00:52:07,520 --> 00:52:12,000
strategies to

00:52:08,880 --> 00:52:12,000
test that dependency

00:52:12,880 --> 00:52:18,720
all right up next is vc package

00:52:16,400 --> 00:52:21,599
appropriate for programs using multiple

00:52:18,720 --> 00:52:24,800
languages so for example cnc plus plus

00:52:21,599 --> 00:52:27,280
rust fortran so vc package

00:52:24,800 --> 00:52:27,839
only supports c and c plus plus right

00:52:27,280 --> 00:52:30,400
now

00:52:27,839 --> 00:52:31,599
um but it is open source and so you

00:52:30,400 --> 00:52:32,079
could potentially hack something

00:52:31,599 --> 00:52:33,920
together

00:52:32,079 --> 00:52:37,839
that works for your own needs but

00:52:33,920 --> 00:52:37,839
officially it supports cnc plus plus

00:52:38,640 --> 00:52:42,160
does vc package support ios and android

00:52:41,599 --> 00:52:44,720
triplets

00:52:42,160 --> 00:52:46,000
at this point in time my answer to that

00:52:44,720 --> 00:52:48,400
is i don't think

00:52:46,000 --> 00:52:49,839
so but i can follow up and share the

00:52:48,400 --> 00:52:50,319
look through the documentation i think

00:52:49,839 --> 00:52:52,800
it's just

00:52:50,319 --> 00:52:53,599
different variants of windows linux and

00:52:52,800 --> 00:52:57,200
mac

00:52:53,599 --> 00:52:58,640
um but again i will defer to the booth

00:52:57,200 --> 00:53:00,480
and i can also follow up and look that

00:52:58,640 --> 00:53:03,680
one up pretty easily i just

00:53:00,480 --> 00:53:07,040
don't know off top of my head

00:53:03,680 --> 00:53:10,800
um can we call c make from

00:53:07,040 --> 00:53:13,599
c plus plus source code so

00:53:10,800 --> 00:53:14,079
generally no you can generate c plus

00:53:13,599 --> 00:53:16,559
plus

00:53:14,079 --> 00:53:18,800
code from c make and i guess that your

00:53:16,559 --> 00:53:20,240
tests or binaries could call c make

00:53:18,800 --> 00:53:22,640
but i don't think you would want to do

00:53:20,240 --> 00:53:24,160
that so generally no c make is

00:53:22,640 --> 00:53:26,240
the build script and so it's how you

00:53:24,160 --> 00:53:27,359
define your build um

00:53:26,240 --> 00:53:29,119
and it's not something that you really

00:53:27,359 --> 00:53:30,240
invoke from your c plus plus source code

00:53:29,119 --> 00:53:32,000
as far as i'm aware

00:53:30,240 --> 00:53:33,440
and if someone has more information to

00:53:32,000 --> 00:53:36,559
share on that um

00:53:33,440 --> 00:53:36,559
please go ahead and share it

00:53:37,760 --> 00:53:43,119
why must a non-system non-bill tool

00:53:40,480 --> 00:53:44,240
dependency tool be language specific is

00:53:43,119 --> 00:53:47,760
cross-platform

00:53:44,240 --> 00:53:48,640
nyx guix not possible so i don't have a

00:53:47,760 --> 00:53:50,960
ton of familiar

00:53:48,640 --> 00:53:52,640
familiar familiarity i'm not very

00:53:50,960 --> 00:53:56,400
familiar with those tools

00:53:52,640 --> 00:53:57,040
um i can say that c plus plus has a lot

00:53:56,400 --> 00:54:00,880
of

00:53:57,040 --> 00:54:03,680
requirements um to maintain abi

00:54:00,880 --> 00:54:05,280
it has it's yeah it has its own set of

00:54:03,680 --> 00:54:05,760
requirements as opposed to something

00:54:05,280 --> 00:54:08,960
like c

00:54:05,760 --> 00:54:10,640
sharp or other languages um and so as

00:54:08,960 --> 00:54:12,800
for the specifics

00:54:10,640 --> 00:54:14,160
that you run up against to when building

00:54:12,800 --> 00:54:16,480
a package management solution

00:54:14,160 --> 00:54:18,480
solution for c plus plus that is not

00:54:16,480 --> 00:54:21,599
satisfied by existing tools

00:54:18,480 --> 00:54:23,760
um i guess i would again defer

00:54:21,599 --> 00:54:25,200
to people who work on vc package for a

00:54:23,760 --> 00:54:27,520
more specific answer

00:54:25,200 --> 00:54:29,359
but i know that c plus plus has its own

00:54:27,520 --> 00:54:32,559
whole host of problems

00:54:29,359 --> 00:54:32,559
that are language specific

00:54:33,040 --> 00:54:39,040
okay i want to teach students c on unix

00:54:36,640 --> 00:54:41,280
with visual studio is that possible to

00:54:39,040 --> 00:54:44,640
build and debug a cross-platform

00:54:41,280 --> 00:54:45,040
c file without a cmake project so yes it

00:54:44,640 --> 00:54:47,839
is

00:54:45,040 --> 00:54:48,480
possible we do have ms build based

00:54:47,839 --> 00:54:51,680
support

00:54:48,480 --> 00:54:54,559
for linux applications that build

00:54:51,680 --> 00:54:55,760
and are debugged natively on la are on

00:54:54,559 --> 00:54:59,119
linux

00:54:55,760 --> 00:55:00,400
um so if you check out our documentation

00:54:59,119 --> 00:55:03,040
i can post a link to that

00:55:00,400 --> 00:55:04,480
after this talk you can get more

00:55:03,040 --> 00:55:06,000
information but it's basically just like

00:55:04,480 --> 00:55:07,760
a console application or just like you

00:55:06,000 --> 00:55:09,280
were working with ms built on windows

00:55:07,760 --> 00:55:13,520
except for everything is invoked on the

00:55:09,280 --> 00:55:13,520
remote system so very similar to cmake

00:55:15,520 --> 00:55:20,400
is the goal to make cmake project have

00:55:18,079 --> 00:55:22,079
parity with solution and cx proj if i

00:55:20,400 --> 00:55:22,720
recall last time i checked cmake didn't

00:55:22,079 --> 00:55:25,839
have support for

00:55:22,720 --> 00:55:26,480
profiling so yes that is our long-term

00:55:25,839 --> 00:55:29,359
vision

00:55:26,480 --> 00:55:30,160
so with things like the language

00:55:29,359 --> 00:55:32,400
services

00:55:30,160 --> 00:55:34,079
or things like that our project

00:55:32,400 --> 00:55:36,160
manipulation support we are trying to

00:55:34,079 --> 00:55:37,440
get closer to what you're able to do via

00:55:36,160 --> 00:55:40,480
property pages

00:55:37,440 --> 00:55:42,400
um in a ms field-based project where

00:55:40,480 --> 00:55:44,720
visual studio helps you to manage that

00:55:42,400 --> 00:55:46,559
underlying build system for you

00:55:44,720 --> 00:55:47,839
and so yes we know that there are still

00:55:46,559 --> 00:55:49,359
some parity guests we think we're

00:55:47,839 --> 00:55:52,000
getting pretty close

00:55:49,359 --> 00:55:53,680
uh i know that there exists a developer

00:55:52,000 --> 00:55:55,200
community suggestion for profiling

00:55:53,680 --> 00:55:55,839
specifically so i would give the same

00:55:55,200 --> 00:55:57,520
advice

00:55:55,839 --> 00:55:59,040
that please go ahead and upload that

00:55:57,520 --> 00:56:00,559
because we do use

00:55:59,040 --> 00:56:02,480
your upvotes and your suggestions to

00:56:00,559 --> 00:56:04,240
help prioritize what we work on when it

00:56:02,480 --> 00:56:04,960
comes to new functionality that we're

00:56:04,240 --> 00:56:07,520
adding

00:56:04,960 --> 00:56:08,400
to the product but we do want you to be

00:56:07,520 --> 00:56:10,559
able to use

00:56:08,400 --> 00:56:12,240
cmake in the same way with the same

00:56:10,559 --> 00:56:14,480
requirements as if you were using ms

00:56:12,240 --> 00:56:14,480
build

00:56:15,280 --> 00:56:19,200
can you recommend something for

00:56:17,040 --> 00:56:20,640
migrating from a make to see make build

00:56:19,200 --> 00:56:21,599
flow that's a great question and

00:56:20,640 --> 00:56:24,559
something that i

00:56:21,599 --> 00:56:26,480
have been hearing um i we don't provide

00:56:24,559 --> 00:56:30,160
any documentation or any kind of

00:56:26,480 --> 00:56:31,760
automatic help there um so i guess i i

00:56:30,160 --> 00:56:33,200
don't really have anything off the top

00:56:31,760 --> 00:56:34,480
of my head but i would love to open it

00:56:33,200 --> 00:56:36,400
up to others in this talk

00:56:34,480 --> 00:56:38,160
who are doing cross-platform development

00:56:36,400 --> 00:56:40,720
to see if they have tools

00:56:38,160 --> 00:56:42,400
that they're using um that i can learn

00:56:40,720 --> 00:56:43,520
from and also help share with the rest

00:56:42,400 --> 00:56:45,040
of the community because

00:56:43,520 --> 00:56:49,119
that's a great question and is a big

00:56:45,040 --> 00:56:49,119
pain point of migrating to cmake

00:56:50,400 --> 00:56:54,799
are there other build system generators

00:56:52,559 --> 00:56:57,440
integrated by visual studio

00:56:54,799 --> 00:56:59,440
so not natively other than ms build

00:56:57,440 --> 00:57:01,760
cmake is the only build system generator

00:56:59,440 --> 00:57:03,599
that we have first class support for but

00:57:01,760 --> 00:57:05,040
there is something called open folder

00:57:03,599 --> 00:57:06,960
mode in visual studio

00:57:05,040 --> 00:57:08,559
which is quite similar to how vs code

00:57:06,960 --> 00:57:10,480
works if you're familiar

00:57:08,559 --> 00:57:12,319
um with that product at all where you

00:57:10,480 --> 00:57:13,920
have your own json file where you

00:57:12,319 --> 00:57:15,839
configure the build step

00:57:13,920 --> 00:57:17,680
and so you can kind of work with that to

00:57:15,839 --> 00:57:20,400
hook up your own custom

00:57:17,680 --> 00:57:22,079
build commands but we don't have first

00:57:20,400 --> 00:57:23,359
class support for anything other than

00:57:22,079 --> 00:57:25,280
the cmake support that i

00:57:23,359 --> 00:57:26,880
showed and then obviously ms field as

00:57:25,280 --> 00:57:28,799
well

00:57:26,880 --> 00:57:30,240
will there be a debugger for c make

00:57:28,799 --> 00:57:31,920
files

00:57:30,240 --> 00:57:33,280
i don't have anything firm to share but

00:57:31,920 --> 00:57:36,160
that is something that we have been

00:57:33,280 --> 00:57:36,160
playing around with

00:57:36,640 --> 00:57:40,000
is vc package planning any public binary

00:57:39,440 --> 00:57:43,520
caching

00:57:40,000 --> 00:57:45,359
a la conan center as far as i know

00:57:43,520 --> 00:57:47,680
that's not an immediate road map but

00:57:45,359 --> 00:57:50,319
we're investing a lot in vc package

00:57:47,680 --> 00:57:51,680
um so again i would defer to augustine

00:57:50,319 --> 00:57:53,200
and robert who kind of are driving the

00:57:51,680 --> 00:57:55,280
vc package experience

00:57:53,200 --> 00:57:57,599
who can speak more to our timeline i can

00:57:55,280 --> 00:58:01,200
also post in the chat

00:57:57,599 --> 00:58:05,040
um the we have a public

00:58:01,200 --> 00:58:06,319
a public backlog um or future roadmap i

00:58:05,040 --> 00:58:08,000
guess is the better term of what we're

00:58:06,319 --> 00:58:09,920
working on in vc package so it's not

00:58:08,000 --> 00:58:12,160
currently part of that but you can see

00:58:09,920 --> 00:58:13,200
what else is coming soon i know some of

00:58:12,160 --> 00:58:14,079
the things that we have publicly

00:58:13,200 --> 00:58:16,000
committed to

00:58:14,079 --> 00:58:18,240
are better integration and visual studio

00:58:16,000 --> 00:58:18,880
and vs code so kind of a ui to help you

00:58:18,240 --> 00:58:21,520
manage

00:58:18,880 --> 00:58:22,880
your libraries install new libraries and

00:58:21,520 --> 00:58:24,880
things like that

00:58:22,880 --> 00:58:25,920
um and then the things i talked about in

00:58:24,880 --> 00:58:28,079
the demo as well

00:58:25,920 --> 00:58:29,040
like versioning support and registry

00:58:28,079 --> 00:58:33,040
support

00:58:29,040 --> 00:58:34,480
um all right

00:58:33,040 --> 00:58:36,880
it looks like we're almost out of time

00:58:34,480 --> 00:58:38,240
and i answered most of the questions so

00:58:36,880 --> 00:58:38,799
sorry if i didn't have any specific

00:58:38,240 --> 00:58:40,640
answers

00:58:38,799 --> 00:58:42,640
i would again point you to the microsoft

00:58:40,640 --> 00:58:43,920
booth or you can reach out to me on

00:58:42,640 --> 00:58:45,520
twitter also

00:58:43,920 --> 00:58:47,200
and i can help get you in touch with

00:58:45,520 --> 00:58:49,040
someone who can fully answer your

00:58:47,200 --> 00:58:52,720
question

00:58:49,040 --> 00:58:52,720
i'll jump back over to the chat

00:58:54,000 --> 00:58:58,079
thanks oh oh i see augustine's been

00:58:56,640 --> 00:58:59,040
augustine works on vc package so

00:58:58,079 --> 00:59:01,280
anything from him

00:58:59,040 --> 00:59:05,839
should be helpful and to address some of

00:59:01,280 --> 00:59:05,839
these questions as well

00:59:07,200 --> 00:59:10,960
yeah i think that is all the questions

00:59:09,359 --> 00:59:14,000
so feel free to reach out

00:59:10,960 --> 00:59:19,839
on twitter or come to our booth

00:59:14,000 --> 00:59:19,839
thanks everyone for tuning in today

00:59:36,720 --> 00:59:38,799

YouTube URL: https://www.youtube.com/watch?v=oYCin0B037Y


