Title: CppCon 2017: Nimrod Sapir “When every Microseconds counts: Lessons learned about performance”
Publication date: 2017-10-27
Playlist: CppCon 2017 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:02,790 --> 00:00:09,180
I am NOT from Chiefs Park today I want

00:00:07,350 --> 00:00:10,950
to talk about some of the lessons I

00:00:09,180 --> 00:00:12,690
learned in the past three years working

00:00:10,950 --> 00:00:17,490
in environment in which every

00:00:12,690 --> 00:00:20,099
microsecond actually counts so what

00:00:17,490 --> 00:00:23,070
makes high-frequency trading environment

00:00:20,099 --> 00:00:25,320
you need so in those low latency

00:00:23,070 --> 00:00:28,020
environments performance is truly a key

00:00:25,320 --> 00:00:31,020
feature since every transaction is erase

00:00:28,020 --> 00:00:32,460
and in many times the second place

00:00:31,020 --> 00:00:34,830
simply gets nothing

00:00:32,460 --> 00:00:37,080
this forces the real-time flow to be

00:00:34,830 --> 00:00:39,690
extremely optimized in every way

00:00:37,080 --> 00:00:42,330
possible there's no notion of fast

00:00:39,690 --> 00:00:46,050
enough if I can improve the real-time

00:00:42,330 --> 00:00:48,120
flow in even a fraction of a microsecond

00:00:46,050 --> 00:00:51,270
it avoids the effort

00:00:48,120 --> 00:00:53,670
I'm going to show a few ground rules I

00:00:51,270 --> 00:00:57,960
learned during my walk in this

00:00:53,670 --> 00:01:00,899
environment so the first basic and

00:00:57,960 --> 00:01:03,540
simple rule is it is not faster if it

00:01:00,899 --> 00:01:05,040
was measured this sounds obvious it was

00:01:03,540 --> 00:01:07,650
told many times during those

00:01:05,040 --> 00:01:10,370
presentations but we tend to make a lot

00:01:07,650 --> 00:01:12,600
of assumptions and rule of thumb that

00:01:10,370 --> 00:01:15,600
underclothing inspection may proven to

00:01:12,600 --> 00:01:18,180
be some somewhat false from example from

00:01:15,600 --> 00:01:20,549
our environments we're using a very

00:01:18,180 --> 00:01:23,820
efficient object a locator over pre

00:01:20,549 --> 00:01:25,950
allocated memory space and we always

00:01:23,820 --> 00:01:28,380
assumed it would be much more efficient

00:01:25,950 --> 00:01:30,450
than malloc but some measurements show

00:01:28,380 --> 00:01:32,940
that malloc is sometimes more efficient

00:01:30,450 --> 00:01:35,850
that was because our implementation was

00:01:32,940 --> 00:01:38,700
not optimized to reuse hot memory

00:01:35,850 --> 00:01:40,890
segments from the pool when we change

00:01:38,700 --> 00:01:44,100
that the issue was resolved and the

00:01:40,890 --> 00:01:46,409
performance was very noticeable to get

00:01:44,100 --> 00:01:48,380
those kind of measurements we create the

00:01:46,409 --> 00:01:53,310
performance graph that looks like this

00:01:48,380 --> 00:01:54,840
let's take a closer look so you can see

00:01:53,310 --> 00:01:56,970
and I hope you can see that the graph

00:01:54,840 --> 00:01:58,890
gives the real-time cost of every action

00:01:56,970 --> 00:02:00,869
in the system would give us a

00:01:58,890 --> 00:02:02,670
performance baseline that we can use to

00:02:00,869 --> 00:02:04,470
compare different environment different

00:02:02,670 --> 00:02:06,990
configuration different version of

00:02:04,470 --> 00:02:10,530
course creating such a graph has an

00:02:06,990 --> 00:02:12,360
overhead by itself so so we can always

00:02:10,530 --> 00:02:15,600
use this kind of measurement

00:02:12,360 --> 00:02:18,870
actual production environments the

00:02:15,600 --> 00:02:21,120
second rule I want to give is branching

00:02:18,870 --> 00:02:22,280
is sometimes more expensive than you

00:02:21,120 --> 00:02:25,410
think

00:02:22,280 --> 00:02:27,420
we of course tend to rely a lot about on

00:02:25,410 --> 00:02:29,520
print prediction but branch

00:02:27,420 --> 00:02:32,370
misprediction still a real performance

00:02:29,520 --> 00:02:34,440
issue for us so we are always trying to

00:02:32,370 --> 00:02:37,350
minimize the branching in our code

00:02:34,440 --> 00:02:39,360
the most obvious way and common way of

00:02:37,350 --> 00:02:41,000
doing that is to move as many decision

00:02:39,360 --> 00:02:44,550
as possible to the compilation

00:02:41,000 --> 00:02:47,459
initialization time modern c++ provides

00:02:44,550 --> 00:02:49,110
tons of techniques of doing that and i'm

00:02:47,459 --> 00:02:52,770
sure you heard about them during this

00:02:49,110 --> 00:02:55,080
convention i want to look at another

00:02:52,770 --> 00:02:57,239
method design in which we sacrifice some

00:02:55,080 --> 00:02:59,550
of the safety checks in sake of

00:02:57,239 --> 00:03:00,540
performance allowing us to receive a

00:02:59,550 --> 00:03:04,320
more deterministic

00:03:00,540 --> 00:03:07,800
although risky flow so this is your

00:03:04,320 --> 00:03:10,590
standard error of handling flow in in

00:03:07,800 --> 00:03:12,360
that flow the code contains a lot of

00:03:10,590 --> 00:03:15,150
safety check we translate it into a lot

00:03:12,360 --> 00:03:18,150
of branching if sometimes some branching

00:03:15,150 --> 00:03:20,010
misprediction the logic here is simple

00:03:18,150 --> 00:03:22,380
you understand the benefit if we have an

00:03:20,010 --> 00:03:24,510
issue we try and discover it as soon as

00:03:22,380 --> 00:03:27,269
possible and handle it as soon as

00:03:24,510 --> 00:03:29,730
possible in a safe and graceful way but

00:03:27,269 --> 00:03:33,690
sometimes we strive to a different

00:03:29,730 --> 00:03:36,690
design in which we assume that our input

00:03:33,690 --> 00:03:38,940
is just okay and everything good and

00:03:36,690 --> 00:03:41,190
safe until we actually have to use it

00:03:38,940 --> 00:03:43,290
when we do we either succeed and

00:03:41,190 --> 00:03:46,160
everything is great or we pay the price

00:03:43,290 --> 00:03:49,380
the price can range from anything

00:03:46,160 --> 00:03:52,950
expensive exception to data corruption

00:03:49,380 --> 00:03:55,130
or even segmentation fault all are very

00:03:52,950 --> 00:03:57,750
expensive to handle and to debug and

00:03:55,130 --> 00:04:00,989
stabilizing this kind of environments

00:03:57,750 --> 00:04:03,660
tends to be much harder and very

00:04:00,989 --> 00:04:05,549
expensive what we need when it does

00:04:03,660 --> 00:04:09,209
become stable we get a more predictable

00:04:05,549 --> 00:04:11,070
pipeline of events that allows to

00:04:09,209 --> 00:04:14,430
eliminate a lot of the redundant

00:04:11,070 --> 00:04:16,979
branching this is of course very

00:04:14,430 --> 00:04:19,169
dangerous design but sometimes the

00:04:16,979 --> 00:04:22,759
insurance fee is too high and you have

00:04:19,169 --> 00:04:25,949
to wait waiver if it

00:04:22,759 --> 00:04:27,949
the last rule I want to give you is to

00:04:25,949 --> 00:04:31,500
watch for the rare yet critical flow

00:04:27,949 --> 00:04:34,590
let's look at this code it checks

00:04:31,500 --> 00:04:36,600
repeatedly stay exhale is frozen if

00:04:34,590 --> 00:04:39,330
he'll hasn't frozen yet it updates on

00:04:36,600 --> 00:04:41,699
counters otherwise it by oil stops of

00:04:39,330 --> 00:04:43,620
course the more critical action here is

00:04:41,699 --> 00:04:46,440
to buy all stocks when hell freezes over

00:04:43,620 --> 00:04:49,400
but says he'll rarely freezes over once

00:04:46,440 --> 00:04:52,590
maybe twice a day all the runtime

00:04:49,400 --> 00:04:55,080
optimization branch prediction CPU cache

00:04:52,590 --> 00:04:57,810
will all work to work optimizing the

00:04:55,080 --> 00:05:01,289
more likely case in which we only update

00:04:57,810 --> 00:05:04,289
counters fooling those mechanism without

00:05:01,289 --> 00:05:06,900
triggering unwanted flows is quite

00:05:04,289 --> 00:05:08,639
complicated and I can get into it in

00:05:06,900 --> 00:05:10,949
this small presentation but please try

00:05:08,639 --> 00:05:13,770
and map those laws and their impact on

00:05:10,949 --> 00:05:16,820
related see thanks

00:05:13,770 --> 00:05:16,820

YouTube URL: https://www.youtube.com/watch?v=mDs9hFlsliE


