Title: Speeding up Preprocessor - Ivan Sorokin [ CppCon 2017 ]
Publication date: 2017-10-27
Playlist: CppCon 2017 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:06,278 --> 00:00:08,890
In IDEs, we need to reparse files really fast.

00:00:08,890 --> 00:00:09,797
Why?

00:00:09,797 --> 00:00:12,761
One example of this is code completion.

00:00:12,761 --> 00:00:16,524
It's when a user types a object name dot

00:00:16,524 --> 00:00:19,562
and we want to show him a completion list.

00:00:19,562 --> 00:00:23,009
And to do this we need to have an AST.

00:00:23,009 --> 00:00:27,176
The problem is that any editing invalidates the AST.

00:00:30,271 --> 00:00:33,367
So if we want to show the completion instantly,

00:00:33,367 --> 00:00:35,646
we need to reparse files instantly.

00:00:35,646 --> 00:00:38,093
That's why we employ different tricks

00:00:38,093 --> 00:00:39,824
to speed up this process.

00:00:39,824 --> 00:00:42,968
For example, we cache as many things as possible

00:00:42,968 --> 00:00:46,913
in order to not recompute them at each reparse.

00:00:46,913 --> 00:00:48,468
Also, for some edits,

00:00:48,468 --> 00:00:51,175
we update existing AST incrementally

00:00:51,175 --> 00:00:52,970
without discarding the old one

00:00:52,970 --> 00:00:54,370
and building a new one.

00:00:54,370 --> 00:00:58,026
And also we defer some computations

00:00:58,026 --> 00:01:01,879
in hope that we won't need them at all.

00:01:01,879 --> 00:01:05,460
Unfortunately, sometimes these tricks don't work

00:01:05,460 --> 00:01:08,578
and we need to fall back to a full reparse.

00:01:08,578 --> 00:01:10,899
That's the process where preprocessor

00:01:10,899 --> 00:01:13,649
took a significant share of time.

00:01:14,978 --> 00:01:17,145
So let's consider a simple...

00:01:18,829 --> 00:01:22,009
We thought about how can we speed up the preprocesor.

00:01:22,009 --> 00:01:25,018
Let's consider two macros, A and B, as shown on the left.

00:01:25,018 --> 00:01:28,116
And every time A is expanded,

00:01:28,116 --> 00:01:31,008
preprocessor notices that B is inside

00:01:31,008 --> 00:01:33,004
and it expands B too.

00:01:33,004 --> 00:01:33,966
The question is

00:01:33,966 --> 00:01:36,837
can we compute the final replacement

00:01:36,837 --> 00:01:38,634
for the macro A

00:01:38,634 --> 00:01:43,005
and then apply it at each expansion of macro A.

00:01:43,005 --> 00:01:45,088
Surely B can be redefined

00:01:45,994 --> 00:01:47,344
and that's why

00:01:47,344 --> 00:01:51,261
the final replacement of A needs to be updated.

00:01:52,754 --> 00:01:54,668
Using these ideas,

00:01:54,668 --> 00:01:57,585
we made a prototype based on clang.

00:01:58,743 --> 00:02:00,995
And at first expansion of each macro

00:02:00,995 --> 00:02:04,696
we complete the final replacement for it

00:02:04,696 --> 00:02:07,096
and we track dependencies

00:02:07,096 --> 00:02:09,504
which macros depend on which

00:02:09,504 --> 00:02:13,250
so we can invalidate them correctly.

00:02:13,250 --> 00:02:17,417
This gave us a nice 20% speed up on boost libraries.

00:02:19,468 --> 00:02:20,627
A few months later

00:02:20,627 --> 00:02:23,199
we were redesigning our own preprocessor

00:02:23,199 --> 00:02:27,282
and we noticed that only a small number of macros

00:02:28,329 --> 00:02:31,368
are expanded thousands of times.

00:02:31,368 --> 00:02:34,196
Can we just implement them as built-ins?

00:02:34,196 --> 00:02:35,720
Surely we can.

00:02:35,720 --> 00:02:37,572
We did this and

00:02:37,572 --> 00:02:41,572
turned out that it was surprisingly easy task.

00:02:42,612 --> 00:02:45,538
We implemented six of the most common

00:02:45,538 --> 00:02:47,955
macros in Boost.Preprocessor.

00:02:48,823 --> 00:02:51,874
And we got the same 20% speed up

00:02:51,874 --> 00:02:53,874
on our own preprocessor.

00:02:55,631 --> 00:02:58,714
This is the number of macro expansion

00:02:59,713 --> 00:03:02,630
with and without this optimization.

00:03:03,722 --> 00:03:05,394
The strength of this approach

00:03:05,394 --> 00:03:08,295
is that it's much easier to implement

00:03:08,295 --> 00:03:10,838
because implementation of each macro

00:03:10,838 --> 00:03:12,891
is localized in one function.

00:03:12,891 --> 00:03:15,682
We don't need any fancy data structures

00:03:15,682 --> 00:03:18,599
to keep this graph of dependencies.

00:03:19,595 --> 00:03:20,821
And as side effect,

00:03:20,821 --> 00:03:23,242
we got better error messages.

00:03:23,242 --> 00:03:24,521
For example, we can check that

00:03:24,521 --> 00:03:28,354
the first argument of boost_pp_if is a number.

00:03:32,426 --> 00:03:34,073
The weakness of this approach is that

00:03:34,073 --> 00:03:36,518
it only speeds up boost

00:03:36,518 --> 00:03:38,949
and the programs that use it.

00:03:38,949 --> 00:03:42,699
How can we make this more widely applicable?

00:03:43,821 --> 00:03:45,238
So my question is

00:03:46,235 --> 00:03:47,533
what do you think is it feasible

00:03:47,533 --> 00:03:51,162
to implement these built-ins in major compilers?

00:03:51,162 --> 00:03:54,963
If it is so, we can contribute patches.

00:03:54,963 --> 00:03:56,142
It's open question.

00:03:56,142 --> 00:04:00,724
Should we implement them 100% compatible

00:04:00,724 --> 00:04:02,361
with existing boost macros

00:04:02,361 --> 00:04:04,278
or can we improve them?

00:04:06,060 --> 00:04:10,689
So if you have any idea, suggestions, comments

00:04:10,689 --> 00:04:11,520
you can mail me

00:04:11,520 --> 00:04:14,300
or you can find me at JetBrains booth here.

00:04:14,300 --> 00:04:15,333
Thank you.

00:04:15,333 --> 00:04:17,583

YouTube URL: https://www.youtube.com/watch?v=XLITpcf7so8


