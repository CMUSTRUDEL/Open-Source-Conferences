Title: CppCon 2017: Jorg Brown “The design of absl::StrCat...”
Publication date: 2017-10-22
Playlist: CppCon 2017 Lightning Talks
Description: 
	"The design of absl::StrCat A tour of C++ inefficiency and variadic templates"

http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,370
right as she said my name is Wirt Brown

00:00:02,610 --> 00:00:06,660
I did most of the design work for

00:00:05,370 --> 00:00:09,300
something called struck out which is

00:00:06,660 --> 00:00:11,940
part of absol it's kind of interesting

00:00:09,300 --> 00:00:15,299
because it hits provides a little tour

00:00:11,940 --> 00:00:16,529
of see focus and efficiencies and some

00:00:15,299 --> 00:00:20,279
interesting techniques with variable

00:00:16,529 --> 00:00:23,250
templates so what started all this about

00:00:20,279 --> 00:00:25,769
more than 10 years ago was there's a lot

00:00:23,250 --> 00:00:28,500
of this at Google where people construct

00:00:25,769 --> 00:00:30,359
a string using the plus operator and the

00:00:28,500 --> 00:00:32,460
problem with that is that there are a

00:00:30,359 --> 00:00:36,059
crazy amount of temporaries that are

00:00:32,460 --> 00:00:38,149
constructed there 10 years ago it would

00:00:36,059 --> 00:00:40,950
constructed the string for username

00:00:38,149 --> 00:00:42,570
append missus to the front it'll create

00:00:40,950 --> 00:00:44,309
a new temporary then it would take the

00:00:42,570 --> 00:00:46,230
temporary add lives in make another

00:00:44,309 --> 00:00:49,110
temporary then would take that temporary

00:00:46,230 --> 00:00:50,730
concatenated with city create a final

00:00:49,110 --> 00:00:53,340
temporary then that final temporary

00:00:50,730 --> 00:00:55,530
would be a sign operator into the string

00:00:53,340 --> 00:00:56,309
and then all the temporaries would be

00:00:55,530 --> 00:00:58,260
destructed

00:00:56,309 --> 00:01:01,469
I took not only a lot of time but it

00:00:58,260 --> 00:01:03,059
generated a ton of code so my first

00:01:01,469 --> 00:01:04,710
reaction was well why don't just make a

00:01:03,059 --> 00:01:07,110
simple routine that just accepts a bunch

00:01:04,710 --> 00:01:08,970
of student strings and we do with that

00:01:07,110 --> 00:01:10,530
the problem with that is you still need

00:01:08,970 --> 00:01:12,619
to create temporary strings for the

00:01:10,530 --> 00:01:14,880
string misses and the string lives in

00:01:12,619 --> 00:01:17,880
but it's still much faster it still

00:01:14,880 --> 00:01:20,100
generates much less code you can do

00:01:17,880 --> 00:01:21,509
better another way of spring view or you

00:01:20,100 --> 00:01:23,880
know 10 years ghost we have this thing

00:01:21,509 --> 00:01:27,180
called spring peace internally because

00:01:23,880 --> 00:01:29,790
now the the literal strings don't need

00:01:27,180 --> 00:01:32,340
to create temporary string objects they

00:01:29,790 --> 00:01:36,509
can just create pointer length pairs so

00:01:32,340 --> 00:01:37,920
that's already quite a lot faster having

00:01:36,509 --> 00:01:39,180
done that and then I thought well wait a

00:01:37,920 --> 00:01:40,350
minute if string view is doing this

00:01:39,180 --> 00:01:42,960
thing where it automatically is

00:01:40,350 --> 00:01:45,509
converting string literals into you know

00:01:42,960 --> 00:01:48,810
pointer length pairs what if I could

00:01:45,509 --> 00:01:51,360
also do that for integers and floating

00:01:48,810 --> 00:01:54,149
point numbers so created yet another

00:01:51,360 --> 00:01:56,909
class called alpha doom and it's a

00:01:54,149 --> 00:01:59,490
simple basically just a string view but

00:01:56,909 --> 00:02:03,119
also a small pad where it can store the

00:01:59,490 --> 00:02:04,619
digits of a number and you can see that

00:02:03,119 --> 00:02:06,750
there's two constructors all they do is

00:02:04,619 --> 00:02:08,240
call some you know shared library code

00:02:06,750 --> 00:02:10,220
to take the integer

00:02:08,240 --> 00:02:13,700
or floating-point number stuff it into

00:02:10,220 --> 00:02:16,070
digit there's one little extra trick I

00:02:13,700 --> 00:02:17,570
couldn't just create a string view

00:02:16,070 --> 00:02:20,000
constructor because then if you try to

00:02:17,570 --> 00:02:22,760
pass a literal string C++ would have to

00:02:20,000 --> 00:02:24,380
do two implicit conversions first a

00:02:22,760 --> 00:02:25,610
string view and then to alpha them so I

00:02:24,380 --> 00:02:28,730
have to actually spell out the

00:02:25,610 --> 00:02:32,870
individual things that are spring-like

00:02:28,730 --> 00:02:34,730
things so having that then we just

00:02:32,870 --> 00:02:36,950
defined stroke act you know multiple

00:02:34,730 --> 00:02:41,300
varieties taking various number of

00:02:36,950 --> 00:02:43,790
arguments there you know implementation

00:02:41,300 --> 00:02:46,160
is dirt simple you just do one initial

00:02:43,790 --> 00:02:50,000
allocation that's exactly the final size

00:02:46,160 --> 00:02:50,990
and then copy the results in and the

00:02:50,000 --> 00:02:55,460
great things that turned out to be

00:02:50,990 --> 00:02:57,830
really really fast not only does it not

00:02:55,460 --> 00:03:00,050
I have to allocate the wrong size string

00:02:57,830 --> 00:03:01,460
but unlike something like SN printf it

00:03:00,050 --> 00:03:03,890
we wouldn't have to go through every

00:03:01,460 --> 00:03:05,840
single character and figure out what the

00:03:03,890 --> 00:03:09,050
format specifier is and then traverse

00:03:05,840 --> 00:03:11,420
see time bar arts anymore so this is

00:03:09,050 --> 00:03:12,770
already three times faster and that's

00:03:11,420 --> 00:03:18,320
including the overhead of actually

00:03:12,770 --> 00:03:21,890
allocating a string a little extra thing

00:03:18,320 --> 00:03:23,570
though I don't people quickly ran into

00:03:21,890 --> 00:03:25,430
the argument once the initial one there

00:03:23,570 --> 00:03:27,530
was a limit of mine arguments then there

00:03:25,430 --> 00:03:31,250
was expanded to 26 and people still

00:03:27,530 --> 00:03:32,450
complained so thankfully with C++ 11 we

00:03:31,250 --> 00:03:35,990
have this thing called initializer list

00:03:32,450 --> 00:03:37,700
and we can use them here so now we can

00:03:35,990 --> 00:03:40,670
define the strip that will take the the

00:03:37,700 --> 00:03:41,990
first two as alpha note and a third one

00:03:40,670 --> 00:03:44,120
will just be an unlimited number of

00:03:41,990 --> 00:03:46,550
arguments each one of which will convert

00:03:44,120 --> 00:03:48,170
into an alpha Nam which then will grab

00:03:46,550 --> 00:03:52,160
the to the string view from and pass

00:03:48,170 --> 00:03:53,570
that to cat pieces one subtle thing here

00:03:52,160 --> 00:03:55,460
you'll notice that rather than just

00:03:53,570 --> 00:03:57,860
construct an alpha Nam I do a static

00:03:55,460 --> 00:04:01,040
cast to a constant alpha new reference

00:03:57,860 --> 00:04:03,800
the reason for that is if somebody else

00:04:01,040 --> 00:04:07,040
wants to have a interface like this they

00:04:03,800 --> 00:04:09,200
might take across 204 known as one of

00:04:07,040 --> 00:04:11,450
their parameters and I want to pass that

00:04:09,200 --> 00:04:15,740
reference to me and if I construct an

00:04:11,450 --> 00:04:18,489
alpha Neumann and data whereas if I do a

00:04:15,740 --> 00:04:20,310
static cast constant alpha new reference

00:04:18,489 --> 00:04:24,510
then there's no overhead

00:04:20,310 --> 00:04:26,700
for that note no copy and then final

00:04:24,510 --> 00:04:29,510
slide just by the way this al cat pieces

00:04:26,700 --> 00:04:31,710
works again we just loop over the

00:04:29,510 --> 00:04:34,050
initializer list first grab the initial

00:04:31,710 --> 00:04:38,070
size allocate the string then mem copy

00:04:34,050 --> 00:04:40,650
the data and the result and that's why

00:04:38,070 --> 00:04:43,440
it's fast this of course to be in a

00:04:40,650 --> 00:04:45,389
lightning talk it's a much abbreviated

00:04:43,440 --> 00:04:48,670
portion of the code but the actual real

00:04:45,389 --> 00:04:54,439
code is right there thank you very much

00:04:48,670 --> 00:04:54,439

YouTube URL: https://www.youtube.com/watch?v=tuWnw3sWZ4w


