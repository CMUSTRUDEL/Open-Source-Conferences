Title: CppCon 2017: Victor Komarov “Universal Memoization Decorator”
Publication date: 2017-10-27
Playlist: CppCon 2017 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:05,750 --> 00:00:11,309
so today I want to talk to you about

00:00:08,250 --> 00:00:14,550
minimization what's minimization

00:00:11,309 --> 00:00:16,770
it's basically caching function calls in

00:00:14,550 --> 00:00:18,750
order to avoid the same computations

00:00:16,770 --> 00:00:21,300
happening over and over again with the

00:00:18,750 --> 00:00:23,430
same parameters after implementing it

00:00:21,300 --> 00:00:25,680
several times in my code I wondered if

00:00:23,430 --> 00:00:26,009
it's possible to implement it once and

00:00:25,680 --> 00:00:29,700
for all

00:00:26,009 --> 00:00:31,770
like universally in Python once you have

00:00:29,700 --> 00:00:35,340
the decorator ready it takes just one

00:00:31,770 --> 00:00:37,829
line to decorate the function it looks

00:00:35,340 --> 00:00:40,170
like this but as we now know Python may

00:00:37,829 --> 00:00:43,829
take you up to several months to get

00:00:40,170 --> 00:00:46,500
your data and besides that it's the C++

00:00:43,829 --> 00:00:48,239
conference so let's do something

00:00:46,500 --> 00:00:52,469
comparable meet in our favorite language

00:00:48,239 --> 00:00:56,269
I want to have a function like the same

00:00:52,469 --> 00:00:58,739
that we have in Python and take its name

00:00:56,269 --> 00:01:02,129
specify the container I want to use and

00:00:58,739 --> 00:01:04,650
just call these decorated versions with

00:01:02,129 --> 00:01:06,780
the same arguments how are we going to

00:01:04,650 --> 00:01:08,909
do this and at first let's talk about

00:01:06,780 --> 00:01:11,400
the container suppose that we have a

00:01:08,909 --> 00:01:15,210
function that takes arguments returns a

00:01:11,400 --> 00:01:18,330
value we create a key from the decade--

00:01:15,210 --> 00:01:20,640
arguments of that function and then use

00:01:18,330 --> 00:01:23,040
it to the key the value is a value and

00:01:20,640 --> 00:01:25,200
the suitable implementation of a

00:01:23,040 --> 00:01:27,210
container will look like this so it's

00:01:25,200 --> 00:01:30,360
some kind of a hash map that supports

00:01:27,210 --> 00:01:32,340
two operations set and get sets set

00:01:30,360 --> 00:01:34,050
updates the cache get returns the

00:01:32,340 --> 00:01:37,560
pointer to the element if it's present

00:01:34,050 --> 00:01:39,450
or a null pointer if it's not and after

00:01:37,560 --> 00:01:42,270
a cait gregory's talked this morning I'm

00:01:39,450 --> 00:01:45,630
considering using is the optional stood

00:01:42,270 --> 00:01:48,390
optional so now once we have the

00:01:45,630 --> 00:01:52,080
container ready let's think where it

00:01:48,390 --> 00:01:54,600
should be placed luckily as we know each

00:01:52,080 --> 00:01:57,000
instance iation of class or function the

00:01:54,600 --> 00:01:58,860
plate has its own static variables so if

00:01:57,000 --> 00:02:01,650
we parameterize our decorated with a

00:01:58,860 --> 00:02:03,750
function we can store the cache in a

00:02:01,650 --> 00:02:05,750
static variable however there is a

00:02:03,750 --> 00:02:08,310
problem with this approach if we

00:02:05,750 --> 00:02:09,810
parameterize the template with the type

00:02:08,310 --> 00:02:12,540
of a function which is basically its

00:02:09,810 --> 00:02:13,500
signature we can run into collision if

00:02:12,540 --> 00:02:15,290
we want to decorate

00:02:13,500 --> 00:02:19,020
two functions having the same signature

00:02:15,290 --> 00:02:22,290
however there's a remedy to this problem

00:02:19,020 --> 00:02:25,320
this thing looks weird if you see it for

00:02:22,290 --> 00:02:28,190
the first time but it does very useful

00:02:25,320 --> 00:02:31,380
thing it allows us to parametrize

00:02:28,190 --> 00:02:34,740
templates with values roses rather than

00:02:31,380 --> 00:02:38,280
just types consider this example we have

00:02:34,740 --> 00:02:40,170
a template of this form with a static

00:02:38,280 --> 00:02:41,400
function and the static variable inside

00:02:40,170 --> 00:02:44,370
that function and what this function

00:02:41,400 --> 00:02:46,680
does it just prints the addresses of the

00:02:44,370 --> 00:02:48,840
address of the static variable and we

00:02:46,680 --> 00:02:51,930
have three distinct instantiations with

00:02:48,840 --> 00:02:54,120
three distinct integers and on my

00:02:51,930 --> 00:02:55,830
machine this program outputs the

00:02:54,120 --> 00:02:59,550
following numbers so the static

00:02:55,830 --> 00:03:01,890
variables inside are distinct okay let's

00:02:59,550 --> 00:03:04,380
build the decorator we start with the

00:03:01,890 --> 00:03:06,480
template declaration the first line of

00:03:04,380 --> 00:03:08,430
the parameters correspond to the trick I

00:03:06,480 --> 00:03:12,300
mentioned the second line is about the

00:03:08,430 --> 00:03:14,190
container then we specialize our

00:03:12,300 --> 00:03:16,860
decorator for functions because we don't

00:03:14,190 --> 00:03:19,860
want to call the decorator on integers

00:03:16,860 --> 00:03:22,110
of strings or whatever so first comes

00:03:19,860 --> 00:03:24,330
the function signature then comes the

00:03:22,110 --> 00:03:27,780
function itself and then the container

00:03:24,330 --> 00:03:29,120
we want to store our results in here

00:03:27,780 --> 00:03:32,250
where all the work is done

00:03:29,120 --> 00:03:35,040
so the function call is supposed to be

00:03:32,250 --> 00:03:38,640
called instead of the function we are

00:03:35,040 --> 00:03:41,040
decorating we have a cache stored in a

00:03:38,640 --> 00:03:43,950
static variable we create key we search

00:03:41,040 --> 00:03:46,890
our cash flow and element with that key

00:03:43,950 --> 00:03:49,350
if the result is present we return it if

00:03:46,890 --> 00:03:53,490
it's not we call the function populate

00:03:49,350 --> 00:03:55,380
the cache and return okay so how does

00:03:53,490 --> 00:04:00,660
the usages look like they look like this

00:03:55,380 --> 00:04:03,180
our initial example looks just as neat

00:04:00,660 --> 00:04:06,060
as I want it to and with the echo type I

00:04:03,180 --> 00:04:08,130
don't have to write by hand the function

00:04:06,060 --> 00:04:12,680
signature like back in the good old

00:04:08,130 --> 00:04:14,520
times okay we can even decorate the

00:04:12,680 --> 00:04:17,190
recursive functions so here's a

00:04:14,520 --> 00:04:19,799
Fibonacci example and we just declare

00:04:17,190 --> 00:04:22,590
the function first and define it after

00:04:19,799 --> 00:04:27,030
we define the function that does all the

00:04:22,590 --> 00:04:28,950
work obviously it's a simplification and

00:04:27,030 --> 00:04:31,580
there is a lot of details left behind

00:04:28,950 --> 00:04:34,120
like how does this thing interoperate

00:04:31,580 --> 00:04:37,100
with lambdas state functions to bind

00:04:34,120 --> 00:04:39,170
what containers can we use to store the

00:04:37,100 --> 00:04:43,730
cash the bunch of fancy hash maps to

00:04:39,170 --> 00:04:47,270
choose from we can use you whatever how

00:04:43,730 --> 00:04:50,810
do we support concurrency so how do we

00:04:47,270 --> 00:04:53,870
protect the access to the cache if it's

00:04:50,810 --> 00:04:57,230
if the decorator is used in several

00:04:53,870 --> 00:05:00,110
threads we can put simple mutex we can

00:04:57,230 --> 00:05:02,240
use a robot we can even declare the cash

00:05:00,110 --> 00:05:04,940
thread local so each thread has its own

00:05:02,240 --> 00:05:07,190
copy so it's a work in progress and I

00:05:04,940 --> 00:05:09,730
hope you hear more about it in the

00:05:07,190 --> 00:05:09,730

YouTube URL: https://www.youtube.com/watch?v=n3MWHzQX26g


