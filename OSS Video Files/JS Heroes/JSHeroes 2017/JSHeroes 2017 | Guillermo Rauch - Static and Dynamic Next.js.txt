Title: JSHeroes 2017 | Guillermo Rauch - Static and Dynamic Next.js
Publication date: 2017-06-23
Playlist: JSHeroes 2017
Description: 
	With Next.js, you can create React applications that automatically server-render, code-split and hot-reload, with no setup. 
This talk will explore the two most powerful new features of Next.js: static exports and dynamic imports. These allow for the creation of high-performance advanced applications, examples of which we'll demonstrate live, on stage.
Captions: 
	00:00:11,720 --> 00:00:17,040
hello everyone

00:00:13,380 --> 00:00:19,770
thanks for being here today thanks also

00:00:17,040 --> 00:00:21,840
to those that were up late tonight

00:00:19,770 --> 00:00:24,300
discussing on the open source panel with

00:00:21,840 --> 00:00:26,970
us so today I'm going to talk about next

00:00:24,300 --> 00:00:30,060
yes my name is guillermo rauch am the

00:00:26,970 --> 00:00:33,270
founder of site we make a deployment

00:00:30,060 --> 00:00:35,400
tool called now and I'm going to talk a

00:00:33,270 --> 00:00:38,059
little bit about it because we have a

00:00:35,400 --> 00:00:40,080
philosophy for the tools we write

00:00:38,059 --> 00:00:42,300
especially for those of you that haven't

00:00:40,080 --> 00:00:44,790
heard about NEX Jas I'll give you a

00:00:42,300 --> 00:00:49,170
little bit of context about where it

00:00:44,790 --> 00:00:52,290
comes from and what it does so we have

00:00:49,170 --> 00:00:55,260
this Tolkien inspired idea of having one

00:00:52,290 --> 00:00:58,590
commands to perform the most important

00:00:55,260 --> 00:01:00,300
tasks in your life we think that there's

00:00:58,590 --> 00:01:04,289
just too much water played for things

00:01:00,300 --> 00:01:06,149
that we do far too frequently so when it

00:01:04,289 --> 00:01:09,060
comes to deploying a website or an API

00:01:06,149 --> 00:01:11,490
we invented this tool called now you go

00:01:09,060 --> 00:01:17,009
to any directory whether it's a static

00:01:11,490 --> 00:01:19,830
project or a node.js server or a docker

00:01:17,009 --> 00:01:21,119
file based Linux container server we

00:01:19,830 --> 00:01:23,729
give you this one command that takes

00:01:21,119 --> 00:01:29,160
that project to the cloud you get a URL

00:01:23,729 --> 00:01:31,380
back by just writing now and taking this

00:01:29,160 --> 00:01:33,690
experience from the CLI to team

00:01:31,380 --> 00:01:37,080
collaboration in the web we wanted to

00:01:33,690 --> 00:01:38,700
enable something where people could

00:01:37,080 --> 00:01:41,640
collaborate so we want to build this

00:01:38,700 --> 00:01:43,979
really rich web UI where you can see the

00:01:41,640 --> 00:01:45,750
logs REO deployment the source code the

00:01:43,979 --> 00:01:48,830
overview the state the newsfeed and all

00:01:45,750 --> 00:01:52,560
of these things and we had some pretty

00:01:48,830 --> 00:01:56,039
big ambitions so we wanted it to feel

00:01:52,560 --> 00:01:58,110
almost like github where every team or a

00:01:56,039 --> 00:02:00,899
person has a dedicated URL within the

00:01:58,110 --> 00:02:04,950
website we want to enable server

00:02:00,899 --> 00:02:07,170
rendering for great performance and we

00:02:04,950 --> 00:02:09,840
want to also once we render something

00:02:07,170 --> 00:02:11,400
updated in real time because when you

00:02:09,840 --> 00:02:13,200
deploy something when where people are

00:02:11,400 --> 00:02:15,540
visiting it or when it's being scaled

00:02:13,200 --> 00:02:17,069
there's a lot of data that changes on

00:02:15,540 --> 00:02:19,890
the backends and we need to communicate

00:02:17,069 --> 00:02:22,050
it to the clients as fast as possible so

00:02:19,890 --> 00:02:24,180
it was a pretty tall order we wanted

00:02:22,050 --> 00:02:25,770
all these things and we also had this

00:02:24,180 --> 00:02:28,710
expectation of how things should work

00:02:25,770 --> 00:02:30,630
that they shouldn't take you know so

00:02:28,710 --> 00:02:32,040
much configuration and so so many

00:02:30,630 --> 00:02:35,100
different steps and commands and

00:02:32,040 --> 00:02:37,890
incantations and that's where next comes

00:02:35,100 --> 00:02:40,880
in so I'm going to describe what next

00:02:37,890 --> 00:02:43,920
does for you in three very simple steps

00:02:40,880 --> 00:02:46,340
so you go to any brand new directory in

00:02:43,920 --> 00:02:49,800
your computer and installed next and

00:02:46,340 --> 00:02:51,950
it's pure dependencies so something

00:02:49,800 --> 00:02:55,320
really cool about this framework is that

00:02:51,950 --> 00:02:56,640
it gets out of the way a lot so for

00:02:55,320 --> 00:03:00,570
example it doesn't really ship with its

00:02:56,640 --> 00:03:04,020
own version of react react Dom or even

00:03:00,570 --> 00:03:05,790
associated utilities like yes lanes and

00:03:04,020 --> 00:03:09,000
so on it's basically just a framework

00:03:05,790 --> 00:03:11,130
that renders it pages so you install it

00:03:09,000 --> 00:03:13,740
and you choose the version of react in

00:03:11,130 --> 00:03:16,830
the react on that you want to use the

00:03:13,740 --> 00:03:19,380
second step is you create at this pages

00:03:16,830 --> 00:03:23,010
directory which is where your entry

00:03:19,380 --> 00:03:24,930
points or top-level components go and

00:03:23,010 --> 00:03:27,239
I'm going to get more into this later

00:03:24,930 --> 00:03:28,620
when I talk about code splitting but the

00:03:27,239 --> 00:03:32,430
fundamental idea is that you start with

00:03:28,620 --> 00:03:34,200
one code splitting entry point which in

00:03:32,430 --> 00:03:37,320
this case is the index of your

00:03:34,200 --> 00:03:40,290
application and I provide it with a

00:03:37,320 --> 00:03:42,810
stateless functional component here you

00:03:40,290 --> 00:03:45,480
could actually also export and react

00:03:42,810 --> 00:03:47,520
class so what next is doing really is

00:03:45,480 --> 00:03:50,130
just providing the minimal amount of

00:03:47,520 --> 00:03:53,130
glue between your react components and

00:03:50,130 --> 00:03:56,640
rendering them from a web server or as a

00:03:53,130 --> 00:03:59,489
static file last step is to run next and

00:03:56,640 --> 00:04:02,160
that's it you go to localhost and you

00:03:59,489 --> 00:04:05,700
get your beautiful page since I created

00:04:02,160 --> 00:04:08,040
index it's mapped to the root of my web

00:04:05,700 --> 00:04:10,110
server in this case there are three

00:04:08,040 --> 00:04:12,930
really interesting sinks you get for

00:04:10,110 --> 00:04:15,570
free by just running next one of them is

00:04:12,930 --> 00:04:18,390
hot code reloading so any change you

00:04:15,570 --> 00:04:20,970
make to the files gets automatically

00:04:18,390 --> 00:04:24,360
reflected on the web UI without even

00:04:20,970 --> 00:04:25,710
pressing refresh the second thing and

00:04:24,360 --> 00:04:28,350
what drives a lot of people to this

00:04:25,710 --> 00:04:32,070
framework is server rendering so you can

00:04:28,350 --> 00:04:34,200
get any dynamic data and when you load

00:04:32,070 --> 00:04:35,770
the page the page already comes with all

00:04:34,200 --> 00:04:38,440
the HTML size

00:04:35,770 --> 00:04:41,440
Sheetz and as i'll go more into it later

00:04:38,440 --> 00:04:44,440
all the necessary script files for your

00:04:41,440 --> 00:04:46,090
system to load and what's really cool

00:04:44,440 --> 00:04:48,310
about this is we recently introduced a

00:04:46,090 --> 00:04:50,080
command called next export so if you

00:04:48,310 --> 00:04:51,909
don't want to use a server you can

00:04:50,080 --> 00:04:55,300
actually export all those individual

00:04:51,909 --> 00:04:57,940
entry points as a static HTML files so

00:04:55,300 --> 00:05:00,460
it's very cool the technology that

00:04:57,940 --> 00:05:01,960
enables this is as I showed earlier you

00:05:00,460 --> 00:05:04,810
have a stateless component or a class

00:05:01,960 --> 00:05:07,840
you have to add an additional hook which

00:05:04,810 --> 00:05:11,470
is get initial props for those of you

00:05:07,840 --> 00:05:14,319
who remember the initial react API it is

00:05:11,470 --> 00:05:15,789
to call the method get initial States so

00:05:14,319 --> 00:05:17,409
you can think of this as a counterpart

00:05:15,789 --> 00:05:19,030
to getting the initial state of our

00:05:17,409 --> 00:05:21,819
component getting the initial properties

00:05:19,030 --> 00:05:24,940
with which that component has to be

00:05:21,819 --> 00:05:26,849
rendered and perhaps the most

00:05:24,940 --> 00:05:29,919
interesting feature of them all

00:05:26,849 --> 00:05:32,530
especially when it comes to scaling your

00:05:29,919 --> 00:05:36,370
applications is code splitting and

00:05:32,530 --> 00:05:39,699
routing so earlier I called my page in

00:05:36,370 --> 00:05:42,940
the XRS but you can actually call it

00:05:39,699 --> 00:05:45,310
anything inside pages like ajs and bjs

00:05:42,940 --> 00:05:48,009
and those will be mapped automatically

00:05:45,310 --> 00:05:50,590
to routes which you can later override

00:05:48,009 --> 00:05:53,229
if you so desire but you get up and

00:05:50,590 --> 00:05:56,469
running very quickly this way and within

00:05:53,229 --> 00:05:59,500
those files is the same story just

00:05:56,469 --> 00:06:03,880
export functions or classes that render

00:05:59,500 --> 00:06:06,360
your application the idea here was to

00:06:03,880 --> 00:06:10,270
provide something that also goes beyond

00:06:06,360 --> 00:06:13,870
technical accomplishments which is team

00:06:10,270 --> 00:06:17,080
scalability and what I refer to by a

00:06:13,870 --> 00:06:19,360
team scalability is this idea that you

00:06:17,080 --> 00:06:21,819
can divide the team of people that are

00:06:19,360 --> 00:06:25,380
work in the front-end into specific

00:06:21,819 --> 00:06:27,789
sections and the their work can

00:06:25,380 --> 00:06:31,389
complement each other much better and

00:06:27,789 --> 00:06:32,469
the performance of one file doesn't

00:06:31,389 --> 00:06:34,870
bring down the performance of another

00:06:32,469 --> 00:06:37,960
for example so it's a prettier section

00:06:34,870 --> 00:06:40,120
on your applications rolling a lot when

00:06:37,960 --> 00:06:41,949
those bundles are generated it's not

00:06:40,120 --> 00:06:45,039
going to impact the work of others and

00:06:41,949 --> 00:06:47,380
also it configures an emergent

00:06:45,039 --> 00:06:49,000
convention that I call it so typically

00:06:47,380 --> 00:06:49,569
what you end up with is you have a pages

00:06:49,000 --> 00:06:52,300
directory

00:06:49,569 --> 00:06:54,339
in a components directory inside that

00:06:52,300 --> 00:06:58,689
component directory you keep all the

00:06:54,339 --> 00:07:02,649
reusable stuff that those higher entry

00:06:58,689 --> 00:07:04,779
points will use so as you get started

00:07:02,649 --> 00:07:07,990
using next with the team it's it's very

00:07:04,779 --> 00:07:12,879
easy to make progress and to not become

00:07:07,990 --> 00:07:16,179
slow over time so automatic Road mapping

00:07:12,879 --> 00:07:18,399
can actually take you very far so one

00:07:16,179 --> 00:07:20,860
example that you can check out is next

00:07:18,399 --> 00:07:23,110
news so every time I create an example

00:07:20,860 --> 00:07:26,740
for next I live a perfectly with next

00:07:23,110 --> 00:07:28,779
and this is the basically clone of

00:07:26,740 --> 00:07:30,099
hacker news and what I did with this is

00:07:28,779 --> 00:07:32,649
I actually set out to create an

00:07:30,099 --> 00:07:35,439
identical clone because I wanted to show

00:07:32,649 --> 00:07:37,899
off that we had the capability to at the

00:07:35,439 --> 00:07:41,080
very least have the same amount of power

00:07:37,899 --> 00:07:43,599
as a traditional server rendering stack

00:07:41,080 --> 00:07:47,349
so hacker news was written I think 20

00:07:43,599 --> 00:07:49,539
years ago and you know they just booted

00:07:47,349 --> 00:07:52,179
up a server had some data in memory and

00:07:49,539 --> 00:07:54,939
printed out some HTML and so far is them

00:07:52,179 --> 00:07:56,919
very well because it hasn't changed much

00:07:54,939 --> 00:07:59,259
and I'm pretty sure that a lot of people

00:07:56,919 --> 00:08:02,919
in this room go to it quite a lot quite

00:07:59,259 --> 00:08:05,889
a possibly even right now at this very

00:08:02,919 --> 00:08:08,229
moment but what I also wanted to show

00:08:05,889 --> 00:08:11,050
was ok once we have the server rendering

00:08:08,229 --> 00:08:13,569
part you can actually use a react

00:08:11,050 --> 00:08:15,279
lifecycle so such as component did mount

00:08:13,569 --> 00:08:18,279
component will receive props and so on

00:08:15,279 --> 00:08:20,409
to augment that initial rendering of the

00:08:18,279 --> 00:08:22,809
components and for example you can load

00:08:20,409 --> 00:08:24,399
more data you can update it data so a

00:08:22,809 --> 00:08:26,079
particular detail that this version

00:08:24,399 --> 00:08:28,509
hacker news has that the original

00:08:26,079 --> 00:08:31,599
doesn't is it updates the number of

00:08:28,509 --> 00:08:33,849
votes in real time it can load comments

00:08:31,599 --> 00:08:36,819
dynamically and so on so it kind of

00:08:33,849 --> 00:08:40,959
shows you what you can do and as I was

00:08:36,819 --> 00:08:43,389
saying automatic page to route mapping

00:08:40,959 --> 00:08:45,910
goes very far because I was able able to

00:08:43,389 --> 00:08:50,380
clone the entire side without using any

00:08:45,910 --> 00:08:52,209
custom server code so so far this is

00:08:50,380 --> 00:08:55,449
basically what you've been able to do

00:08:52,209 --> 00:08:58,750
until the very most recent release of

00:08:55,449 --> 00:09:01,600
the framework which is you can set up a

00:08:58,750 --> 00:09:03,250
bunch of top-level components and get

00:09:01,600 --> 00:09:06,340
some initial data

00:09:03,250 --> 00:09:09,610
take advantage of code splitting so the

00:09:06,340 --> 00:09:11,320
workflow up until now and I think for a

00:09:09,610 --> 00:09:13,450
great majority of applications that are

00:09:11,320 --> 00:09:15,610
out there today is you look you load

00:09:13,450 --> 00:09:19,930
some code either on the client or on the

00:09:15,610 --> 00:09:22,990
server it gets some data and then the

00:09:19,930 --> 00:09:24,550
typical you know the UI is a pure

00:09:22,990 --> 00:09:28,660
function of data saying you take the

00:09:24,550 --> 00:09:30,430
data and you render the page but in many

00:09:28,660 --> 00:09:33,790
cases I'll show today through some

00:09:30,430 --> 00:09:36,310
really compelling examples I hope the

00:09:33,790 --> 00:09:40,570
data can actually determine additional

00:09:36,310 --> 00:09:43,480
code that can be loaded so this is why I

00:09:40,570 --> 00:09:45,730
call this presentation code as a

00:09:43,480 --> 00:09:48,580
function of data in many cases the API

00:09:45,730 --> 00:09:50,920
calls you make the result of a graph QL

00:09:48,580 --> 00:09:53,440
query for example can determine actually

00:09:50,920 --> 00:09:56,890
what additional code has to be loaded in

00:09:53,440 --> 00:09:59,620
order to very efficiently and load up

00:09:56,890 --> 00:10:02,770
your application so I'm developing a new

00:09:59,620 --> 00:10:04,030
case study following my convention it's

00:10:02,770 --> 00:10:07,060
called next sender

00:10:04,030 --> 00:10:10,570
it's very funny thank you and it's a

00:10:07,060 --> 00:10:12,520
clone of messenger so it's actually it's

00:10:10,570 --> 00:10:14,440
actually trying to become be very simple

00:10:12,520 --> 00:10:15,960
so what it does is obviously allow

00:10:14,440 --> 00:10:19,360
people to communicate with each other

00:10:15,960 --> 00:10:23,589
and switch between conversations using

00:10:19,360 --> 00:10:26,380
the next AAS page system so this is the

00:10:23,589 --> 00:10:28,540
very basic implementation of a

00:10:26,380 --> 00:10:30,760
conversation you get to it there's no

00:10:28,540 --> 00:10:33,190
data you populate it with some data in

00:10:30,760 --> 00:10:36,190
this case I'm using States so that I can

00:10:33,190 --> 00:10:39,970
have it offline and then reconciliate it

00:10:36,190 --> 00:10:42,010
later etc so the first highlight that I

00:10:39,970 --> 00:10:43,780
want to point out that next enables kind

00:10:42,010 --> 00:10:45,640
of out of the box is that server

00:10:43,780 --> 00:10:50,830
rendering makes for a really nice

00:10:45,640 --> 00:10:57,540
experience so let's see if this gives

00:10:50,830 --> 00:10:57,540
triggers yeah sorry for the slowness

00:11:01,279 --> 00:11:03,279
Oh

00:11:14,740 --> 00:11:18,279
I'm going to play it here because my

00:11:16,330 --> 00:11:20,380
computer is sort of struggling with the

00:11:18,279 --> 00:11:24,130
full screen hopefully oh hopefully you

00:11:20,380 --> 00:11:25,630
can see it okay there you see it so

00:11:24,130 --> 00:11:27,160
messenger comm actually doesn't serve

00:11:25,630 --> 00:11:29,680
render so what you get first of all it's

00:11:27,160 --> 00:11:32,860
a white page that you get a slim gray

00:11:29,680 --> 00:11:34,720
bar at the top and you see that the even

00:11:32,860 --> 00:11:37,029
the layout is missing from that initial

00:11:34,720 --> 00:11:38,350
load of the page then the right sort of

00:11:37,029 --> 00:11:39,959
change and then there is a spinner and

00:11:38,350 --> 00:11:41,920
then there is a final conversation of

00:11:39,959 --> 00:11:46,810
Alex telling me to show up for the

00:11:41,920 --> 00:11:48,399
conference so obviously this is a much

00:11:46,810 --> 00:11:50,170
more simplistic implementation but I

00:11:48,399 --> 00:11:52,089
added some I simulated some back-end

00:11:50,170 --> 00:11:53,320
latency to show you that the main

00:11:52,089 --> 00:11:55,690
difference is when you serve a render

00:11:53,320 --> 00:11:58,209
you are it's up to you to decide how

00:11:55,690 --> 00:12:00,940
much data is load with that initial

00:11:58,209 --> 00:12:03,520
paint of the page as that HTML servers

00:12:00,940 --> 00:12:06,100
flowing down the pipe from your server

00:12:03,520 --> 00:12:08,140
so what's cool about this is as the

00:12:06,100 --> 00:12:09,790
developer you decide how much you want

00:12:08,140 --> 00:12:12,610
to pre rendered and you decide what that

00:12:09,790 --> 00:12:14,290
initial first experience looks like for

00:12:12,610 --> 00:12:16,510
example you can optimistically render a

00:12:14,290 --> 00:12:18,700
layout or you can render the

00:12:16,510 --> 00:12:22,270
conversation and lazily load the sidebar

00:12:18,700 --> 00:12:25,390
etc so the spectrum here of server

00:12:22,270 --> 00:12:27,670
rendering is you can render the most

00:12:25,390 --> 00:12:29,500
basic thing with which would be maybe a

00:12:27,670 --> 00:12:32,200
spinner or a shell of what the

00:12:29,500 --> 00:12:33,520
eventually it would look like or in many

00:12:32,200 --> 00:12:36,250
cases you want to render what's above

00:12:33,520 --> 00:12:37,990
the fold or you can actually go ahead

00:12:36,250 --> 00:12:40,029
and depending on the performance of your

00:12:37,990 --> 00:12:43,540
back and decide to render at the entire

00:12:40,029 --> 00:12:46,500
page so the next highlight that I want

00:12:43,540 --> 00:12:50,399
to discuss today is what can we do to

00:12:46,500 --> 00:12:54,100
lazily load code as a function of data

00:12:50,399 --> 00:12:57,010
so the basic implementation of my thread

00:12:54,100 --> 00:12:58,779
it contains a text component and that's

00:12:57,010 --> 00:13:01,450
a component that will make up the great

00:12:58,779 --> 00:13:03,850
majority of conversations that you have

00:13:01,450 --> 00:13:06,940
because of the chat application so I

00:13:03,850 --> 00:13:10,209
decided that the text component is part

00:13:06,940 --> 00:13:12,910
of the initial bundle for the code

00:13:10,209 --> 00:13:16,390
splitting entry point of my thread of my

00:13:12,910 --> 00:13:18,700
this basic page so if you look at the

00:13:16,390 --> 00:13:22,360
URL in this case I think it says reg G

00:13:18,700 --> 00:13:25,600
which is me which Maps through a custom

00:13:22,360 --> 00:13:28,300
server it maps to our index entry points

00:13:25,600 --> 00:13:28,630
so this example also aims to show you

00:13:28,300 --> 00:13:31,840
the

00:13:28,630 --> 00:13:35,290
to set up fancy sodas so to speak

00:13:31,840 --> 00:13:39,010
routing but the text component always

00:13:35,290 --> 00:13:42,250
comes with that main.js violet matches

00:13:39,010 --> 00:13:45,520
that in the garages entry point so if

00:13:42,250 --> 00:13:48,120
you were to inspect the output of the

00:13:45,520 --> 00:13:51,640
JavaScript files that next year's

00:13:48,120 --> 00:13:54,220
compiles for you you would see that you

00:13:51,640 --> 00:13:57,310
will find that text component inside the

00:13:54,220 --> 00:14:00,550
main bundle because it's commonly used

00:13:57,310 --> 00:14:03,040
across all entry points which in this

00:14:00,550 --> 00:14:05,820
case is one entry point but for next

00:14:03,040 --> 00:14:12,190
injure to actually be a realistic

00:14:05,820 --> 00:14:14,200
reincarnation of its counterpart we have

00:14:12,190 --> 00:14:17,770
to imagine that we have a potentially

00:14:14,200 --> 00:14:20,530
really big list of message types so

00:14:17,770 --> 00:14:22,870
imagine that I'm configuring my entry

00:14:20,530 --> 00:14:25,960
point or my top-level components and if

00:14:22,870 --> 00:14:29,740
I started to import everything that the

00:14:25,960 --> 00:14:31,960
user can possibly ever see I would first

00:14:29,740 --> 00:14:33,150
of all have a huge list of imports which

00:14:31,960 --> 00:14:36,310
doesn't look very good

00:14:33,150 --> 00:14:38,350
second of all add the bundle size would

00:14:36,310 --> 00:14:40,330
increase and third of all this kind of

00:14:38,350 --> 00:14:43,060
takes away of that idea of scalability

00:14:40,330 --> 00:14:44,830
from the performance standpoint and from

00:14:43,060 --> 00:14:46,570
the standpoint of you know you have a

00:14:44,830 --> 00:14:49,150
bunch of people working perhaps on

00:14:46,570 --> 00:14:52,180
different message types some perhaps so

00:14:49,150 --> 00:14:55,450
obscure that they target maybe a certain

00:14:52,180 --> 00:14:57,910
only a certain segment of your user base

00:14:55,450 --> 00:15:02,830
for example so you wouldn't want to over

00:14:57,910 --> 00:15:06,940
time have three pages of imports in your

00:15:02,830 --> 00:15:09,520
in your entry point so the question that

00:15:06,940 --> 00:15:13,600
really is how can we lazily load code

00:15:09,520 --> 00:15:16,810
yet retain those initial benefits of a

00:15:13,600 --> 00:15:20,770
slick initial load not showing spinners

00:15:16,810 --> 00:15:22,420
that are unnecessary and so on so what

00:15:20,770 --> 00:15:26,950
we want to do essentially is get rid of

00:15:22,420 --> 00:15:29,440
that basically deterrent from that

00:15:26,950 --> 00:15:32,760
initial panes we want to render whatever

00:15:29,440 --> 00:15:36,310
messages are on that last page with that

00:15:32,760 --> 00:15:39,280
conversation and we want to make sure

00:15:36,310 --> 00:15:40,839
that they come with the page yet we also

00:15:39,280 --> 00:15:42,620
want to make sure they don't belong to

00:15:40,839 --> 00:15:44,480
the main code splitting entry point

00:15:42,620 --> 00:15:47,600
because what we're dealing with here is

00:15:44,480 --> 00:15:49,850
the code that we have to load depends on

00:15:47,600 --> 00:15:54,019
data and the data is dynamic and it

00:15:49,850 --> 00:15:56,810
depends on each user and so on so the

00:15:54,019 --> 00:15:59,930
answer to this conundrum is to make imp

00:15:56,810 --> 00:16:03,560
the dynamic import which is supported by

00:15:59,930 --> 00:16:05,600
web pack and we were able to get up and

00:16:03,560 --> 00:16:08,079
running with very quickly we added

00:16:05,600 --> 00:16:11,389
basically server rendering support to it

00:16:08,079 --> 00:16:13,579
so the way that it looks like and this

00:16:11,389 --> 00:16:15,379
API is evolving and so we're currently

00:16:13,579 --> 00:16:17,810
working on this in the beta branch so

00:16:15,379 --> 00:16:20,660
expect this to change a lot but the

00:16:17,810 --> 00:16:23,660
basic idea is when we get that initial

00:16:20,660 --> 00:16:27,740
data in this case in my conversation

00:16:23,660 --> 00:16:31,040
entry point we invoke a component that

00:16:27,740 --> 00:16:34,009
we tell next is async and I'm going to

00:16:31,040 --> 00:16:38,209
get into basically the subtlety of is

00:16:34,009 --> 00:16:40,329
not really async so when you look at the

00:16:38,209 --> 00:16:44,600
implementation of the thread component

00:16:40,329 --> 00:16:49,430
you you look at how we await the import

00:16:44,600 --> 00:16:51,170
of this different message types so what

00:16:49,430 --> 00:16:53,660
we're doing on the next year side of

00:16:51,170 --> 00:16:55,370
things when we we already do this

00:16:53,660 --> 00:16:58,130
actually for our style sheets so when

00:16:55,370 --> 00:17:00,380
when you're incorporating styles in your

00:16:58,130 --> 00:17:02,389
different components we compile the

00:17:00,380 --> 00:17:05,600
styles and we include them at the top of

00:17:02,389 --> 00:17:07,130
the page so that first of all we do

00:17:05,600 --> 00:17:09,319
duplicate we don't want to include all

00:17:07,130 --> 00:17:11,900
the styles for every time a component

00:17:09,319 --> 00:17:13,909
shows up and second of all we want to

00:17:11,900 --> 00:17:16,549
include critical styles at the top so

00:17:13,909 --> 00:17:19,520
the page renders in a very nice way so

00:17:16,549 --> 00:17:22,419
what we did is we took this idea and we

00:17:19,520 --> 00:17:24,380
applied it to import so the only

00:17:22,419 --> 00:17:28,039
requirement is that we call this render

00:17:24,380 --> 00:17:31,220
async method so what's happening

00:17:28,039 --> 00:17:35,840
underneath the hood is import on the

00:17:31,220 --> 00:17:37,789
server side runs synchronously so as you

00:17:35,840 --> 00:17:40,039
as you know render in react is

00:17:37,789 --> 00:17:43,460
synchronous so we can't really await

00:17:40,039 --> 00:17:46,490
something but there is a possibility

00:17:43,460 --> 00:17:49,370
that is import we can manage to run

00:17:46,490 --> 00:17:52,070
synchronously on the nodejs side of

00:17:49,370 --> 00:17:54,620
things we used to require and then we

00:17:52,070 --> 00:17:56,650
just give it handed out to react and and

00:17:54,620 --> 00:17:59,630
the initial render of the page

00:17:56,650 --> 00:18:02,090
then additional script tags are included

00:17:59,630 --> 00:18:05,990
for subsequent components that get added

00:18:02,090 --> 00:18:08,060
on top of that entry point so an example

00:18:05,990 --> 00:18:12,260
that I have here is a conversation with

00:18:08,060 --> 00:18:13,910
my co-founder Naoki about my dog day the

00:18:12,260 --> 00:18:16,130
most beautiful doll in the universe if

00:18:13,910 --> 00:18:18,350
you ask me so as you can see that

00:18:16,130 --> 00:18:21,290
initial render didn't really show a

00:18:18,350 --> 00:18:23,480
loading spinner not even at the

00:18:21,290 --> 00:18:25,010
component level we had already has

00:18:23,480 --> 00:18:27,380
everything that I need to render that

00:18:25,010 --> 00:18:30,260
entire thread even though that photo

00:18:27,380 --> 00:18:35,660
component does not belong to the entry

00:18:30,260 --> 00:18:37,520
point and if we inspect the initial HTML

00:18:35,660 --> 00:18:40,220
it comes to the page you're going to see

00:18:37,520 --> 00:18:44,480
that we're referring to a web pack chunk

00:18:40,220 --> 00:18:46,430
that belongs to that lazy import photo

00:18:44,480 --> 00:18:47,600
component so this is all happening

00:18:46,430 --> 00:18:49,640
automatically for you from your

00:18:47,600 --> 00:18:52,340
perspective you just use the dynamic

00:18:49,640 --> 00:18:55,670
version of import but next yes

00:18:52,340 --> 00:18:58,160
automatically divides main entry points

00:18:55,670 --> 00:18:59,660
and code splitting entry points and the

00:18:58,160 --> 00:19:02,180
components that actually have to be

00:18:59,660 --> 00:19:04,010
loaded as a function of data so if you

00:19:02,180 --> 00:19:06,230
take two distinct conversations or two

00:19:04,010 --> 00:19:07,760
distinct users you would see that the

00:19:06,230 --> 00:19:12,080
script tags that get rendered for each

00:19:07,760 --> 00:19:13,820
change so this happens because we can

00:19:12,080 --> 00:19:17,780
make import work synchronous in a server

00:19:13,820 --> 00:19:21,740
and on the client side before we tell

00:19:17,780 --> 00:19:23,960
react to reconciliate the code with the

00:19:21,740 --> 00:19:26,810
HTML that came with the page we already

00:19:23,960 --> 00:19:28,970
loaded that a script tag and as a bonus

00:19:26,810 --> 00:19:31,010
thing that is really nice is another

00:19:28,970 --> 00:19:36,110
thing you get to refer with next if you

00:19:31,010 --> 00:19:38,510
get linked preload tags so when we send

00:19:36,110 --> 00:19:41,180
out the HTML of the page let's say that

00:19:38,510 --> 00:19:43,610
user is in a slow connection and they

00:19:41,180 --> 00:19:46,340
get maybe the first portion of the HTML

00:19:43,610 --> 00:19:48,710
the first packet or because of the

00:19:46,340 --> 00:19:51,920
sliding TCP window they're only able to

00:19:48,710 --> 00:19:54,140
consume so much notice that we have a

00:19:51,920 --> 00:19:57,940
symmetry between preload components on

00:19:54,140 --> 00:20:01,940
the top and script tags that get loaded

00:19:57,940 --> 00:20:03,530
at the bottom of the page in parallel so

00:20:01,940 --> 00:20:08,600
the really neat thing about this is as

00:20:03,530 --> 00:20:11,179
the rest of the page renders off thread

00:20:08,600 --> 00:20:13,970
things with Lincoln rail preload were

00:20:11,179 --> 00:20:16,490
downloading and parsing the script exit

00:20:13,970 --> 00:20:18,769
then we're going to need for reactor

00:20:16,490 --> 00:20:19,880
reconciliation and for those of you not

00:20:18,769 --> 00:20:23,029
familiar with the implementation details

00:20:19,880 --> 00:20:25,730
of react reconciliation is that react

00:20:23,029 --> 00:20:29,139
received some HTML and you need to

00:20:25,730 --> 00:20:32,539
basically hydrate the components that

00:20:29,139 --> 00:20:35,090
resulted in that HTML so that when you

00:20:32,539 --> 00:20:37,100
have for example lifecycle hooks you can

00:20:35,090 --> 00:20:40,490
access the properties of that component

00:20:37,100 --> 00:20:43,309
for example so the really neat thing

00:20:40,490 --> 00:20:47,419
about this is this API also gives us the

00:20:43,309 --> 00:20:50,230
power to tell the user how much or

00:20:47,419 --> 00:20:52,519
basically decide on behalf of the user

00:20:50,230 --> 00:20:56,240
what components need to be rendered

00:20:52,519 --> 00:20:57,590
before we perform a certain paint an

00:20:56,240 --> 00:20:59,480
example of this is that naive

00:20:57,590 --> 00:21:02,059
implementation of this with some

00:20:59,480 --> 00:21:04,570
higher-order components would result in

00:21:02,059 --> 00:21:06,759
for example as you switch between

00:21:04,570 --> 00:21:11,269
conversations you could end up with

00:21:06,759 --> 00:21:14,360
missing messages or missing message

00:21:11,269 --> 00:21:16,850
types so you would have for example if a

00:21:14,360 --> 00:21:18,679
certain initial render didn't have the

00:21:16,850 --> 00:21:20,450
photo components and then you switch to

00:21:18,679 --> 00:21:22,340
a conversation that net that needs said

00:21:20,450 --> 00:21:25,669
you actually would want to make the

00:21:22,340 --> 00:21:27,620
conversation wait on getting that photo

00:21:25,669 --> 00:21:30,409
component so I have an example here

00:21:27,620 --> 00:21:33,470
because I'm taking advantage of the

00:21:30,409 --> 00:21:36,470
transition system and the initial render

00:21:33,470 --> 00:21:39,529
didn't have the code to load the photo

00:21:36,470 --> 00:21:41,720
but when I transitions I waited on

00:21:39,529 --> 00:21:44,419
everything to be fetched so that's why

00:21:41,720 --> 00:21:48,850
you see the bar at the top so that's a

00:21:44,419 --> 00:21:48,850
very interesting implementation detail

00:21:50,769 --> 00:21:58,490
and yeah again this is this happens when

00:21:55,970 --> 00:22:00,710
if the user beforehand didn't have that

00:21:58,490 --> 00:22:02,629
code then again when they were in there

00:22:00,710 --> 00:22:04,519
some other data sets they're going to

00:22:02,629 --> 00:22:08,629
need it and you want to decide how long

00:22:04,519 --> 00:22:10,519
you wait so perhaps an even more

00:22:08,629 --> 00:22:14,960
interesting example is okay I already

00:22:10,519 --> 00:22:16,460
loaded the page and I want to I received

00:22:14,960 --> 00:22:18,320
through a WebSocket connection for

00:22:16,460 --> 00:22:21,139
example a new message type that I

00:22:18,320 --> 00:22:22,179
haven't ever heard of so in that case

00:22:21,139 --> 00:22:24,340
you do want to show that

00:22:22,179 --> 00:22:29,499
loading message so I have an example

00:22:24,340 --> 00:22:34,629
here where I'm receiving through the

00:22:29,499 --> 00:22:37,710
push channel the message type map so

00:22:34,629 --> 00:22:40,450
notice that first we see a loading tag

00:22:37,710 --> 00:22:42,730
that corresponds with the code being

00:22:40,450 --> 00:22:45,100
fetched but I'm talking about the code

00:22:42,730 --> 00:22:47,379
being searched for that specific entry

00:22:45,100 --> 00:22:50,230
point that sorry components which is a

00:22:47,379 --> 00:22:54,249
map and then we that actually comes with

00:22:50,230 --> 00:22:56,259
a huge tree of components from reactive

00:22:54,249 --> 00:22:58,690
google map and that in itself loads

00:22:56,259 --> 00:23:02,249
google maps so imagine if you included

00:22:58,690 --> 00:23:06,100
that with a page would be quite the

00:23:02,249 --> 00:23:09,960
expensive inclusion for a very small

00:23:06,100 --> 00:23:12,789
percentage of messages that require it

00:23:09,960 --> 00:23:16,090
so as we were working on this we

00:23:12,789 --> 00:23:17,860
realized and there is a library that

00:23:16,090 --> 00:23:20,619
already implements this that perhaps

00:23:17,860 --> 00:23:22,499
just like we can treat import especially

00:23:20,619 --> 00:23:24,879
we could in the future treat fetch

00:23:22,499 --> 00:23:27,549
especially so it would allow you to

00:23:24,879 --> 00:23:31,240
write even more success code where in

00:23:27,549 --> 00:23:33,340
the component that returns the rendered

00:23:31,240 --> 00:23:36,970
elements you could also await on stuff

00:23:33,340 --> 00:23:38,529
because potentially we could rehydrate

00:23:36,970 --> 00:23:42,369
the pet the pit when we rehydrate the

00:23:38,529 --> 00:23:44,200
page we can say fetch actually we

00:23:42,369 --> 00:23:46,869
already have that because we loaded it

00:23:44,200 --> 00:23:48,610
on the server here is the the data that

00:23:46,869 --> 00:23:50,440
is resulted with and then you can

00:23:48,610 --> 00:23:53,619
reconciliate very quickly without making

00:23:50,440 --> 00:23:58,659
another HTTP request so I want to thank

00:23:53,619 --> 00:24:00,610
for this interesting set of improvements

00:23:58,659 --> 00:24:02,470
IRA no doubt one of our core

00:24:00,610 --> 00:24:07,179
contributors who actually worked on this

00:24:02,470 --> 00:24:08,080
implementation then solo I hope I

00:24:07,179 --> 00:24:11,409
pronounced it correctly

00:24:08,080 --> 00:24:13,179
who wrote async reactor which gives you

00:24:11,409 --> 00:24:15,580
that API that I just showed but only on

00:24:13,179 --> 00:24:17,139
the client side and Sascha

00:24:15,580 --> 00:24:19,440
I can who I've been discussing some

00:24:17,139 --> 00:24:22,330
ideas to run fetch and react server

00:24:19,440 --> 00:24:24,879
recently with if you want to learn more

00:24:22,330 --> 00:24:26,889
about an XJS

00:24:24,879 --> 00:24:28,600
you I recommend that you go through our

00:24:26,889 --> 00:24:31,619
history of blog post so that you get

00:24:28,600 --> 00:24:34,779
context for how the projects evolved and

00:24:31,619 --> 00:24:36,220
the reasoning for features that we added

00:24:34,779 --> 00:24:38,980
and so on

00:24:36,220 --> 00:24:40,570
the main github project ofcourse which

00:24:38,980 --> 00:24:42,370
contains the entire documentation for

00:24:40,570 --> 00:24:44,650
the framework that's i saying guy nice

00:24:42,370 --> 00:24:47,770
feature is that the readme of neck j s

00:24:44,650 --> 00:24:49,150
has everything you need to know and then

00:24:47,770 --> 00:24:51,690
you can go to next news and hopefully

00:24:49,150 --> 00:24:53,890
soon you're going to have next sender

00:24:51,690 --> 00:24:56,080
available also and they're now examples

00:24:53,890 --> 00:24:58,960
very soon and if you want to discuss it

00:24:56,080 --> 00:25:01,330
you can also tweet at me and ask any

00:24:58,960 --> 00:25:03,310
questions but i have already seen some

00:25:01,330 --> 00:25:06,430
questions come in which i'm going to

00:25:03,310 --> 00:25:07,960
talk about now so what is the best

00:25:06,430 --> 00:25:09,130
approach to start with next actually the

00:25:07,960 --> 00:25:10,890
best approach to start with next is

00:25:09,130 --> 00:25:13,860
hopefully have an internet connection is

00:25:10,890 --> 00:25:18,870
i learn next year calm

00:25:13,860 --> 00:25:18,870
so let me put that on full screen i

00:25:20,700 --> 00:25:25,620
think i have to use another screen oh

00:25:30,090 --> 00:25:35,110
there it is

00:25:31,390 --> 00:25:36,880
so this is a really amazing guide to get

00:25:35,110 --> 00:25:42,040
started with next because it walks you

00:25:36,880 --> 00:25:44,620
through really small lessons that take

00:25:42,040 --> 00:25:46,960
maybe like 10 seconds each it's

00:25:44,620 --> 00:25:50,110
fantastic i was built by ira note as

00:25:46,960 --> 00:25:51,640
well who's very prolific how hard is it

00:25:50,110 --> 00:25:53,890
to migrate increasing code is is a

00:25:51,640 --> 00:25:56,280
reactant webpack so the neat thing about

00:25:53,890 --> 00:25:59,230
next phase is that you use this web pack

00:25:56,280 --> 00:26:01,690
unlike create react app we decided not

00:25:59,230 --> 00:26:03,100
to go with the right of ejection what we

00:26:01,690 --> 00:26:06,640
allow you to do is we allow you to

00:26:03,100 --> 00:26:09,390
decorate the web pack config through a

00:26:06,640 --> 00:26:12,400
function that you can supply so we

00:26:09,390 --> 00:26:14,920
basically create a web config on your

00:26:12,400 --> 00:26:16,480
behalf and then you get it as you get it

00:26:14,920 --> 00:26:18,880
through a function and then you can

00:26:16,480 --> 00:26:21,910
augment it if you want to customize web

00:26:18,880 --> 00:26:25,120
pack and similarly we also build in top

00:26:21,910 --> 00:26:27,630
of Babel so you can define a Babel

00:26:25,120 --> 00:26:30,670
config and in package.json or a bubble

00:26:27,630 --> 00:26:34,120
RC and you can define your own a

00:26:30,670 --> 00:26:39,040
syntactic extensions like like private

00:26:34,120 --> 00:26:43,240
members in classes what are you more

00:26:39,040 --> 00:26:44,920
proud of now or next most of all I'm

00:26:43,240 --> 00:26:45,310
proud of the naming I think it's really

00:26:44,920 --> 00:26:46,750
good

00:26:45,310 --> 00:26:50,590
now next

00:26:46,750 --> 00:26:51,730
what's what's next I know next we render

00:26:50,590 --> 00:26:55,419
versus PWA

00:26:51,730 --> 00:26:57,820
I think pre-rendering and PWA are

00:26:55,419 --> 00:27:02,140
perfectly complementary I think it

00:26:57,820 --> 00:27:03,549
follows the pattern that Google calls PR

00:27:02,140 --> 00:27:05,890
PL I think it's called

00:27:03,549 --> 00:27:08,950
I think server rendering is always a

00:27:05,890 --> 00:27:10,600
plus because of talked that I wrote an

00:27:08,950 --> 00:27:13,960
essay about this but the fundamental

00:27:10,600 --> 00:27:15,820
idea is if you go to a certain URL that

00:27:13,960 --> 00:27:19,000
contains some information about the data

00:27:15,820 --> 00:27:21,909
that you want such as github.com slash

00:27:19,000 --> 00:27:23,740
zyt the server already knows what data

00:27:21,909 --> 00:27:25,780
you're interested in and it can perform

00:27:23,740 --> 00:27:30,190
a huge number of optimizations on your

00:27:25,780 --> 00:27:31,870
behalf like streaming HTML like pushing

00:27:30,190 --> 00:27:34,900
data that it's going to be required

00:27:31,870 --> 00:27:38,289
later on so pre rendering is always a

00:27:34,900 --> 00:27:40,000
desirable trait now PWA I think it's

00:27:38,289 --> 00:27:44,140
always a desirable trader as well

00:27:40,000 --> 00:27:47,679
because if you can take any website and

00:27:44,140 --> 00:27:50,470
augmented to become a more sticky

00:27:47,679 --> 00:27:54,280
experience with more capabilities that's

00:27:50,470 --> 00:27:57,190
also great so in order to make a PWA

00:27:54,280 --> 00:27:58,539
with next today you have to configure

00:27:57,190 --> 00:28:00,940
your own serviceworker

00:27:58,539 --> 00:28:04,000
so we don't do it automatically for you

00:28:00,940 --> 00:28:06,940
but that might change in the future we

00:28:04,000 --> 00:28:09,820
haven't yet actually built a PWA for

00:28:06,940 --> 00:28:12,039
ourselves so something that kind of

00:28:09,820 --> 00:28:14,620
determines the future of all of our

00:28:12,039 --> 00:28:17,200
decisions is our needs

00:28:14,620 --> 00:28:19,240
for our main application that's why I

00:28:17,200 --> 00:28:21,580
started giving you context of what

00:28:19,240 --> 00:28:23,740
features we needed out of this so we

00:28:21,580 --> 00:28:25,900
haven't yet built that PWA and this is

00:28:23,740 --> 00:28:28,110
why for now it's reserved for a user

00:28:25,900 --> 00:28:31,179
line code which i think is fairly

00:28:28,110 --> 00:28:32,799
acceptable trade-off how do you handle

00:28:31,179 --> 00:28:35,950
coding while also caring about

00:28:32,799 --> 00:28:38,640
authentication and permissions so this

00:28:35,950 --> 00:28:41,770
is a really good question in order to

00:28:38,640 --> 00:28:45,159
for example have a designated part of

00:28:41,770 --> 00:28:48,220
your application that can even whose

00:28:45,159 --> 00:28:50,470
code can only be accessed by a certain

00:28:48,220 --> 00:28:53,350
kind of user so the typical example

00:28:50,470 --> 00:28:56,470
here's you want to have an admin section

00:28:53,350 --> 00:28:59,640
for example for your application so what

00:28:56,470 --> 00:29:02,760
you do there is you can set up a

00:28:59,640 --> 00:29:05,010
Express server or even a vanilla node

00:29:02,760 --> 00:29:08,250
HTTP server and you can add

00:29:05,010 --> 00:29:11,730
authorization to the to those URLs that

00:29:08,250 --> 00:29:15,600
I showed earlier that serve the code so

00:29:11,730 --> 00:29:17,790
if you really can't share for example

00:29:15,600 --> 00:29:20,010
the code itself or like an admin panel

00:29:17,790 --> 00:29:22,380
because it's revealing of certain

00:29:20,010 --> 00:29:25,410
features or you don't want to give away

00:29:22,380 --> 00:29:28,770
your upcoming releases and so on you can

00:29:25,410 --> 00:29:32,900
actually add nth ocation also to that

00:29:28,770 --> 00:29:35,630
part of the code that serves the code

00:29:32,900 --> 00:29:38,940
yeah so we actually do that as well and

00:29:35,630 --> 00:29:42,060
it's fairly easy to do when you involve

00:29:38,940 --> 00:29:45,360
a CDN you want to keep in mind that CD

00:29:42,060 --> 00:29:48,120
ends have to revalidate based on for

00:29:45,360 --> 00:29:50,490
example the cookie header varying or

00:29:48,120 --> 00:29:53,040
whatever so it's it's finicky it's not

00:29:50,490 --> 00:29:55,680
super trivial to do but the main reason

00:29:53,040 --> 00:29:59,430
is authentication authorization is not

00:29:55,680 --> 00:30:02,820
ever easy to do dynamic routes static

00:29:59,430 --> 00:30:05,760
explore what's next for next I wrote

00:30:02,820 --> 00:30:08,250
this on a github issue

00:30:05,760 --> 00:30:11,910
our main goal right now is we recently

00:30:08,250 --> 00:30:16,440
surpassed a thousands react components

00:30:11,910 --> 00:30:18,240
and what we've been facing is some code

00:30:16,440 --> 00:30:22,080
scalability or code base size

00:30:18,240 --> 00:30:23,790
scalability issues so for example if you

00:30:22,080 --> 00:30:25,740
want to maintain hot code reloading and

00:30:23,790 --> 00:30:27,150
you want to watch the entire file system

00:30:25,740 --> 00:30:29,600
and you want to rebuild up and change

00:30:27,150 --> 00:30:31,980
and certain things like that

00:30:29,600 --> 00:30:36,480
things become pretty slow you have a

00:30:31,980 --> 00:30:38,250
ginormous codebase so a lot of the work

00:30:36,480 --> 00:30:40,950
that we're doing right now is we're

00:30:38,250 --> 00:30:42,870
polishing what's already there so that

00:30:40,950 --> 00:30:45,570
it scales really well so that goes for

00:30:42,870 --> 00:30:48,780
hot code reloading error handling and so

00:30:45,570 --> 00:30:52,110
on so we want to take a step back after

00:30:48,780 --> 00:30:54,660
this major features lands and really

00:30:52,110 --> 00:30:58,650
ensure that the developer performance

00:30:54,660 --> 00:31:00,390
and user performance is optimal and some

00:30:58,650 --> 00:31:02,280
features that I would guess might become

00:31:00,390 --> 00:31:04,440
more relevant in the future are for

00:31:02,280 --> 00:31:06,900
example something that makes it easier

00:31:04,440 --> 00:31:09,690
and less error-prone to configure those

00:31:06,900 --> 00:31:13,440
service workers but other than that I

00:31:09,690 --> 00:31:15,990
think maintaining that API maintained

00:31:13,440 --> 00:31:18,299
simplicity of that API comes it's more

00:31:15,990 --> 00:31:21,809
important I think than adding a lot of

00:31:18,299 --> 00:31:23,159
features how do you handle a piece of

00:31:21,809 --> 00:31:27,299
state is common for multiple pages

00:31:23,159 --> 00:31:30,059
that's a great question so when you

00:31:27,299 --> 00:31:36,570
invoke get initial or when get initial

00:31:30,059 --> 00:31:39,149
props gets invoked yeah

00:31:36,570 --> 00:31:43,350
when getting so props gets invoked you

00:31:39,149 --> 00:31:45,809
get the request object if you are on the

00:31:43,350 --> 00:31:47,909
server or you don't get the request

00:31:45,809 --> 00:31:51,120
object if you're on the client so what

00:31:47,909 --> 00:31:52,620
we do for a site is when we detect that

00:31:51,120 --> 00:31:54,840
we're on the client actually this is not

00:31:52,620 --> 00:31:56,940
a good example because we load code we

00:31:54,840 --> 00:31:59,279
load data from github so you saw that

00:31:56,940 --> 00:32:00,870
progress bar but in this we load the

00:31:59,279 --> 00:32:03,210
code mirror or dynamically so you saw

00:32:00,870 --> 00:32:06,149
that progress bar but see how this pages

00:32:03,210 --> 00:32:09,179
transition immediately yet here we have

00:32:06,149 --> 00:32:13,710
user state so that user state is

00:32:09,179 --> 00:32:16,889
actually shared across pages so we have

00:32:13,710 --> 00:32:19,350
an authentication little utility that

00:32:16,889 --> 00:32:21,210
knows it's running on the client side or

00:32:19,350 --> 00:32:23,070
on the server side and when it's running

00:32:21,210 --> 00:32:25,320
on the client side it maintains the

00:32:23,070 --> 00:32:27,720
state and then we use a higher-order

00:32:25,320 --> 00:32:32,190
component to synchronize the states

00:32:27,720 --> 00:32:38,309
across tabs so for example if I go to

00:32:32,190 --> 00:32:40,470
site again and I log out so notice it

00:32:38,309 --> 00:32:43,070
logged me out here as well so not only

00:32:40,470 --> 00:32:47,490
can you share States but because we

00:32:43,070 --> 00:32:50,279
basically maintain that state inside the

00:32:47,490 --> 00:32:53,039
top level component that wraps all our

00:32:50,279 --> 00:32:55,500
pages that need authentication we use

00:32:53,039 --> 00:32:57,539
the react lifecycle hooks to subscribe

00:32:55,500 --> 00:32:59,669
to changes that could come from other

00:32:57,539 --> 00:33:02,700
tabs so in this case we use local

00:32:59,669 --> 00:33:04,110
storage events to talk between tabs so

00:33:02,700 --> 00:33:07,379
what's happening is that top-level

00:33:04,110 --> 00:33:10,830
components has a user object in-state

00:33:07,379 --> 00:33:13,559
across all pages and then when we get a

00:33:10,830 --> 00:33:16,230
message from another tab we call this

00:33:13,559 --> 00:33:18,720
upset state user null and then it

00:33:16,230 --> 00:33:21,480
propagates down the pages so different

00:33:18,720 --> 00:33:23,940
pages react differently to the news that

00:33:21,480 --> 00:33:26,850
you no longer have a user so that's

00:33:23,940 --> 00:33:29,700
where component will will receive props

00:33:26,850 --> 00:33:32,940
then because here we don't really mind

00:33:29,700 --> 00:33:35,460
that we no longer have a user so the

00:33:32,940 --> 00:33:38,759
only impact is that my face went away

00:33:35,460 --> 00:33:41,009
and got replaced with a log in a text

00:33:38,759 --> 00:33:43,200
but in other pages for example if we had

00:33:41,009 --> 00:33:45,090
been on the dashboard there is no

00:33:43,200 --> 00:33:47,190
dashboard that actually works when

00:33:45,090 --> 00:33:51,120
you're not logged in so on component

00:33:47,190 --> 00:33:53,580
will receive props we perform the side

00:33:51,120 --> 00:33:56,190
effect of redirecting to the home page

00:33:53,580 --> 00:34:03,779
so that gets a little too technical but

00:33:56,190 --> 00:34:05,909
the TL DL is too long the listen is we

00:34:03,779 --> 00:34:08,730
have states at the top level components

00:34:05,909 --> 00:34:10,679
and we can synchronize it across pages

00:34:08,730 --> 00:34:12,480
and its global which makes for a

00:34:10,679 --> 00:34:17,669
beautiful optimization that you don't

00:34:12,480 --> 00:34:19,379
load common data across pages offline

00:34:17,669 --> 00:34:20,609
support for next actually we're working

00:34:19,379 --> 00:34:22,589
on this and this is why I was mentioning

00:34:20,609 --> 00:34:27,659
that you can set up your service workers

00:34:22,589 --> 00:34:30,300
yourselves we're working on making a the

00:34:27,659 --> 00:34:31,200
next question so design we make we're

00:34:30,300 --> 00:34:32,909
going to make our documentation

00:34:31,200 --> 00:34:36,419
completely offline and we're actually

00:34:32,909 --> 00:34:38,159
kind of there because I didn't go into

00:34:36,419 --> 00:34:42,139
this yet but you can watch my react

00:34:38,159 --> 00:34:45,780
comms talk if you wanna listen to this

00:34:42,139 --> 00:34:48,389
but we have prefetching of other code

00:34:45,780 --> 00:34:52,679
splitting entry points so if you come to

00:34:48,389 --> 00:34:55,530
this page all the code splitting entry

00:34:52,679 --> 00:34:59,210
points for all the other pages that use

00:34:55,530 --> 00:35:01,589
the link higher-order components

00:34:59,210 --> 00:35:04,200
it's basically prefetching those entry

00:35:01,589 --> 00:35:05,940
points on the backgrounds so if I want

00:35:04,200 --> 00:35:08,099
to go if I were to go offline right now

00:35:05,940 --> 00:35:10,230
especially now it's fetching all the

00:35:08,099 --> 00:35:12,060
blog posts if I were to go offline right

00:35:10,230 --> 00:35:15,420
now I would have access to everything

00:35:12,060 --> 00:35:17,250
like this is already there so what we

00:35:15,420 --> 00:35:19,020
have to do to make this work offline is

00:35:17,250 --> 00:35:21,720
very minimal we just have to say that

00:35:19,020 --> 00:35:24,540
whenever you come to the page for the

00:35:21,720 --> 00:35:27,900
next time like just load whatever

00:35:24,540 --> 00:35:30,270
version you last had and then because of

00:35:27,900 --> 00:35:31,800
all our code splitting entry points and

00:35:30,270 --> 00:35:37,109
all our script tags as you saw earlier

00:35:31,800 --> 00:35:40,260
are identified by immutable hashes so

00:35:37,109 --> 00:35:42,810
there's actually no risk of

00:35:40,260 --> 00:35:45,600
the code getting stale or when you

00:35:42,810 --> 00:35:48,990
reconnect there is no risk that you

00:35:45,600 --> 00:35:50,370
don't know to reconciliate new code this

00:35:48,990 --> 00:35:52,140
also gets a little bit too technical but

00:35:50,370 --> 00:35:53,790
imagine that you've gone offline for a

00:35:52,140 --> 00:35:56,100
very long time then you regain

00:35:53,790 --> 00:35:58,680
connection or you load some pages you

00:35:56,100 --> 00:36:01,890
hadn't loaded before if you've made a

00:35:58,680 --> 00:36:05,760
new deployment that changed your scripts

00:36:01,890 --> 00:36:07,860
next is able to distinguish that the

00:36:05,760 --> 00:36:11,400
code running on the server now is

00:36:07,860 --> 00:36:14,340
outdated and it performs a hard refresh

00:36:11,400 --> 00:36:17,070
or it gives you a hook to take over and

00:36:14,340 --> 00:36:19,110
decide what to do when there's a code

00:36:17,070 --> 00:36:21,690
mismatch so this is a very interesting

00:36:19,110 --> 00:36:24,180
new problem that has emerged from all

00:36:21,690 --> 00:36:27,660
this dynamic code bases which is you

00:36:24,180 --> 00:36:29,940
load the page and an engineer at the

00:36:27,660 --> 00:36:32,400
company just deployed a code change and

00:36:29,940 --> 00:36:34,800
meanwhile you're lazy loading that page

00:36:32,400 --> 00:36:36,180
what happens for example if the server

00:36:34,800 --> 00:36:38,280
no longer knows about it

00:36:36,180 --> 00:36:40,740
so negative actually deals with that

00:36:38,280 --> 00:36:43,620
pretty elegantly so this is something

00:36:40,740 --> 00:36:45,120
that I think most of the people in the

00:36:43,620 --> 00:36:48,180
world should not have to worry about so

00:36:45,120 --> 00:36:50,270
is one of my favorite features are any

00:36:48,180 --> 00:36:52,560
plans to support vue.js along with react

00:36:50,270 --> 00:36:56,280
thankfully and this is actually quite a

00:36:52,560 --> 00:36:58,800
fascinating story and a testament to the

00:36:56,280 --> 00:37:02,490
pace of open-source nowadays when we

00:36:58,800 --> 00:37:06,150
announced next j/s someone in the view

00:37:02,490 --> 00:37:08,940
j/s community announced knucks j/s which

00:37:06,150 --> 00:37:13,290
is the name that i really like so i

00:37:08,940 --> 00:37:16,350
highly recommend it because it's a very

00:37:13,290 --> 00:37:19,550
funny name it satisfies a good name can

00:37:16,350 --> 00:37:22,260
the precondition and it does very much

00:37:19,550 --> 00:37:24,540
like the similar similar similar thing

00:37:22,260 --> 00:37:26,940
as next but they've actually taken it

00:37:24,540 --> 00:37:28,020
further and they they were kind of

00:37:26,940 --> 00:37:30,780
adding a lot of features that we don't

00:37:28,020 --> 00:37:32,580
have like they did static exports before

00:37:30,780 --> 00:37:33,990
so they're very productive there's

00:37:32,580 --> 00:37:37,860
something about the view community that

00:37:33,990 --> 00:37:40,350
makes Google really productive so the

00:37:37,860 --> 00:37:43,190
gist is we don't have to do anything

00:37:40,350 --> 00:37:45,660
because next did it that's great

00:37:43,190 --> 00:37:50,690
it's next enjoy a breach of reassurance

00:37:45,660 --> 00:37:54,180
of views I don't know I don't think so

00:37:50,690 --> 00:37:56,460
but if it is we'll Rene

00:37:54,180 --> 00:37:58,800
me into next chat or something like that

00:37:56,460 --> 00:38:00,270
so many more boring how does next deal

00:37:58,800 --> 00:38:02,430
with dynamic dependencies for the client

00:38:00,270 --> 00:38:04,920
code and also what does it use under the

00:38:02,430 --> 00:38:06,960
hood for code splitting up basically we

00:38:04,920 --> 00:38:11,130
most of the heavy lifting is done by web

00:38:06,960 --> 00:38:13,650
pack web pack does all the maintains the

00:38:11,130 --> 00:38:19,020
graphs and decides what code goes into

00:38:13,650 --> 00:38:21,860
what chunk or entry points etc something

00:38:19,020 --> 00:38:24,840
else it's worth mentioning is when you

00:38:21,860 --> 00:38:27,600
when you lazy load a component on the

00:38:24,840 --> 00:38:29,010
client side sometimes you might take a

00:38:27,600 --> 00:38:33,990
while to load obviously it's not

00:38:29,010 --> 00:38:37,290
immediate or it might fail so our async

00:38:33,990 --> 00:38:40,590
rendering decorator also gives you the

00:38:37,290 --> 00:38:44,280
ability to set up a component for error

00:38:40,590 --> 00:38:47,700
case and for the success case which is

00:38:44,280 --> 00:38:49,980
very similar to how react loadable or

00:38:47,700 --> 00:38:52,560
async reactor do it so it's actually

00:38:49,980 --> 00:38:54,090
very easy to do it's very easy to deal

00:38:52,560 --> 00:38:55,320
with dynamic dependences in the client

00:38:54,090 --> 00:38:57,930
code and at the same time it's very

00:38:55,320 --> 00:39:00,030
difficult because notice that we have to

00:38:57,930 --> 00:39:03,030
think so much more about all these

00:39:00,030 --> 00:39:05,970
finicky user interactions if we're not

00:39:03,030 --> 00:39:09,090
it we might load a page that has like a

00:39:05,970 --> 00:39:11,880
bunch of like loading little texts all

00:39:09,090 --> 00:39:14,820
over the place so all the problems that

00:39:11,880 --> 00:39:17,280
come with asynchronous programming our

00:39:14,820 --> 00:39:18,750
accessory beta is obviously here because

00:39:17,280 --> 00:39:20,760
we're loading a lot of stuff that can

00:39:18,750 --> 00:39:22,860
fail and what do you do when it fails

00:39:20,760 --> 00:39:25,800
you tell the user to refresh the page

00:39:22,860 --> 00:39:27,690
and if it's a little component you tell

00:39:25,800 --> 00:39:29,730
them right there to refresh the page or

00:39:27,690 --> 00:39:31,650
do you like have some like global

00:39:29,730 --> 00:39:33,390
notification system for telling his or

00:39:31,650 --> 00:39:35,190
to refresh the page and that's the user

00:39:33,390 --> 00:39:37,440
even care about refreshing the page

00:39:35,190 --> 00:39:39,540
should you do it automatically but what

00:39:37,440 --> 00:39:41,400
if when you refresh automatically you go

00:39:39,540 --> 00:39:46,290
into a loop of refreshing automatically

00:39:41,400 --> 00:39:48,330
and yeah so it's easy but it's not I

00:39:46,290 --> 00:39:52,950
would say it's simple but it's not so

00:39:48,330 --> 00:39:55,599
easy or some combination of that yes so

00:39:52,950 --> 00:39:57,660
that's last question thank you very much

00:39:55,599 --> 00:39:57,660

YouTube URL: https://www.youtube.com/watch?v=lLNJsuXB4CI


