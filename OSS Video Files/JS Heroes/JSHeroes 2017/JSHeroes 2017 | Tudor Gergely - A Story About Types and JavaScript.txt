Title: JSHeroes 2017 | Tudor Gergely - A Story About Types and JavaScript
Publication date: 2017-06-22
Playlist: JSHeroes 2017
Description: 
	Why do we exactly need those types? Are we not choosing Javascript for its dynamic nature? Let's see how a bit of rigour can help us on the long run.
Captions: 
	00:00:11,469 --> 00:00:16,939
we are all here today to discuss about

00:00:14,629 --> 00:00:18,860
javascript and near made a really really

00:00:16,939 --> 00:00:19,460
great introduction because your real

00:00:18,860 --> 00:00:27,529
typescript

00:00:19,460 --> 00:00:29,119
so yeah thank you near and actually I'm

00:00:27,529 --> 00:00:32,019
here to tell you that you should all

00:00:29,119 --> 00:00:36,220
write typescript after this talk so

00:00:32,019 --> 00:00:36,220
another round of applause for typescript

00:00:38,050 --> 00:00:43,070
we'll discuss a bit about JavaScript and

00:00:40,910 --> 00:00:46,010
we'll discuss a bit about types about

00:00:43,070 --> 00:00:48,440
static types we'll see how javascript

00:00:46,010 --> 00:00:51,110
actually made us love programming its

00:00:48,440 --> 00:00:53,119
how it's easy to get going with projects

00:00:51,110 --> 00:00:56,059
it's easy to build prototypes small

00:00:53,119 --> 00:00:58,010
projects but how it also gets somehow in

00:00:56,059 --> 00:01:00,260
your way when you're building big apps

00:00:58,010 --> 00:01:03,680
with big domain models with hundreds of

00:01:00,260 --> 00:01:06,100
thousands of lines of code so first we

00:01:03,680 --> 00:01:08,720
will discuss a bit about JavaScript

00:01:06,100 --> 00:01:12,049
let's start with a simple question who

00:01:08,720 --> 00:01:15,320
here has ever used JavaScript before yes

00:01:12,049 --> 00:01:16,039
come on there are a few great great

00:01:15,320 --> 00:01:17,810
that's great

00:01:16,039 --> 00:01:20,299
that it means that you know what I'll be

00:01:17,810 --> 00:01:21,469
talking about so JavaScript just if

00:01:20,299 --> 00:01:23,060
there are some of you who don't know

00:01:21,469 --> 00:01:26,719
about it javascript is this dynamic

00:01:23,060 --> 00:01:28,759
language which was built in the 90s to I

00:01:26,719 --> 00:01:32,960
mean it was built to be used by the

00:01:28,759 --> 00:01:35,859
browser to script a bit of HTML pages

00:01:32,960 --> 00:01:39,259
but it has come so so far that nowadays

00:01:35,859 --> 00:01:42,109
we are using it for everything and I

00:01:39,259 --> 00:01:44,810
mean everything here we are still using

00:01:42,109 --> 00:01:46,490
it for the web because yeah the web is

00:01:44,810 --> 00:01:49,130
still there and it will be for a long

00:01:46,490 --> 00:01:52,340
time but we don't look we no longer have

00:01:49,130 --> 00:01:54,439
just simple HTML pages we have those big

00:01:52,340 --> 00:01:56,869
app single page apps hundreds of

00:01:54,439 --> 00:01:58,609
thousands of code of lines of code with

00:01:56,869 --> 00:02:01,729
thousands maybe hundreds of developers

00:01:58,609 --> 00:02:03,259
working on them so they have to be to

00:02:01,729 --> 00:02:04,909
really perform well that they have to be

00:02:03,259 --> 00:02:07,969
maintained over the course of several

00:02:04,909 --> 00:02:10,340
years and this and this is where

00:02:07,969 --> 00:02:13,790
javascript gets a bit in the way then we

00:02:10,340 --> 00:02:16,190
have the server we have no GS which is a

00:02:13,790 --> 00:02:17,709
really great technology and is really

00:02:16,190 --> 00:02:20,450
really popular nowadays

00:02:17,709 --> 00:02:22,730
you have no Jess and with its package

00:02:20,450 --> 00:02:25,190
manager mostly then we have mobile we

00:02:22,730 --> 00:02:27,380
have desktop with having better devices

00:02:25,190 --> 00:02:30,230
all those areas are areas where

00:02:27,380 --> 00:02:32,390
JavaScript was a stranger a few years

00:02:30,230 --> 00:02:34,370
ago but now it's really popular and it's

00:02:32,390 --> 00:02:38,030
starting to grow and then there's

00:02:34,370 --> 00:02:40,580
teaching now teaching is not actually a

00:02:38,030 --> 00:02:43,880
programming area but it's one of the

00:02:40,580 --> 00:02:46,760
most important ones you see if something

00:02:43,880 --> 00:02:49,250
is trending now in universities or

00:02:46,760 --> 00:02:51,800
between beginner programmers it will be

00:02:49,250 --> 00:02:54,080
even more important in a few years

00:02:51,800 --> 00:02:55,760
because it basically says the trend for

00:02:54,080 --> 00:02:57,920
future programmers and this is important

00:02:55,760 --> 00:03:00,230
just a quick mention Stanford

00:02:57,920 --> 00:03:01,730
I think it's Stanford just replace their

00:03:00,230 --> 00:03:03,710
course they're computer science

00:03:01,730 --> 00:03:06,230
introductory course from Java to

00:03:03,710 --> 00:03:11,000
JavaScript so this is a big step in this

00:03:06,230 --> 00:03:13,090
direction okay but you cannot have you

00:03:11,000 --> 00:03:16,310
cannot have programs without a few

00:03:13,090 --> 00:03:17,990
popular projects this is github I'm sure

00:03:16,310 --> 00:03:21,320
you all know about github and those are

00:03:17,990 --> 00:03:23,690
the top side project of if you rank them

00:03:21,320 --> 00:03:25,250
by the number of stars can you count how

00:03:23,690 --> 00:03:28,730
many of them are built using javascript

00:03:25,250 --> 00:03:31,040
I will do it for you it's five here it's

00:03:28,730 --> 00:03:33,110
the top five with five projects will

00:03:31,040 --> 00:03:35,060
using javascript and they are not all

00:03:33,110 --> 00:03:36,590
programming projects that's important I

00:03:35,060 --> 00:03:39,350
mean you have react you have to trap you

00:03:36,590 --> 00:03:41,780
have d3.js all great libraries but you

00:03:39,350 --> 00:03:44,239
also have you don't know yes a great

00:03:41,780 --> 00:03:46,670
book you should all read it and the

00:03:44,239 --> 00:03:49,910
first position is free code camp which

00:03:46,670 --> 00:03:51,950
has almost 300,000 stars a lot more I

00:03:49,910 --> 00:03:54,019
mean really really a lot more than the

00:03:51,950 --> 00:03:55,730
others and free code camp is not even a

00:03:54,019 --> 00:03:59,959
programming project it's about teaching

00:03:55,730 --> 00:04:01,820
it's about helping beginners learn their

00:03:59,959 --> 00:04:03,940
way into programming not only into

00:04:01,820 --> 00:04:06,980
geography but into programming itself

00:04:03,940 --> 00:04:09,200
but not only beginners use JavaScript

00:04:06,980 --> 00:04:11,570
this is the survey from Stack Overflow I

00:04:09,200 --> 00:04:14,810
know it may be biased but this is the

00:04:11,570 --> 00:04:16,160
survey from 2017 you can look at it

00:04:14,810 --> 00:04:18,620
online you can look at the service for

00:04:16,160 --> 00:04:21,290
2016 2015 and so on and you will see

00:04:18,620 --> 00:04:24,650
that in each of those JavaScript is not

00:04:21,290 --> 00:04:26,360
only the first one but by each if that

00:04:24,650 --> 00:04:30,590
passes you will see that the percentage

00:04:26,360 --> 00:04:32,990
of popularity it actually rises but

00:04:30,590 --> 00:04:34,970
let's talk a bit let's get a bit more

00:04:32,990 --> 00:04:37,820
technical here here's a bit a little

00:04:34,970 --> 00:04:38,990
example of code which basically is

00:04:37,820 --> 00:04:42,350
really simple I'm sure your

00:04:38,990 --> 00:04:45,260
understand it but it's it enhances an

00:04:42,350 --> 00:04:48,320
idea which will make you think about why

00:04:45,260 --> 00:04:49,970
we should use pipes so this is a simple

00:04:48,320 --> 00:04:52,100
variable declaration JavaScript you can

00:04:49,970 --> 00:04:53,780
assign a number with a string and then

00:04:52,100 --> 00:04:56,030
an object to the same variable you don't

00:04:53,780 --> 00:04:57,800
have to specify its type and you don't

00:04:56,030 --> 00:04:59,990
even have to know it actually

00:04:57,800 --> 00:05:02,480
the runtime will handle that for you I

00:04:59,990 --> 00:05:05,180
mean this is great for beginners it you

00:05:02,480 --> 00:05:08,200
don't scare them you you get easily

00:05:05,180 --> 00:05:11,180
going into code and then you have this I

00:05:08,200 --> 00:05:12,950
mean yeah that that makes sense right I

00:05:11,180 --> 00:05:15,230
mean who doesn't know that the string

00:05:12,950 --> 00:05:17,420
multiplied by a number will be a number

00:05:15,230 --> 00:05:22,340
in the end but this is true in

00:05:17,420 --> 00:05:24,020
JavaScript moving on this is the most

00:05:22,340 --> 00:05:27,200
important part actually in the project

00:05:24,020 --> 00:05:30,110
this is a little function I could call

00:05:27,200 --> 00:05:32,450
this like an interface and let's let's

00:05:30,110 --> 00:05:34,430
make a bit a bit of scenario here you

00:05:32,450 --> 00:05:36,170
are working on an old project like 3

00:05:34,430 --> 00:05:38,780
years old it doesn't have to be much

00:05:36,170 --> 00:05:41,630
older than that and you have like a big

00:05:38,780 --> 00:05:43,400
domain model you have hundreds of

00:05:41,630 --> 00:05:45,740
thousands of lines of code written there

00:05:43,400 --> 00:05:47,420
and you are assigned to maybe change or

00:05:45,740 --> 00:05:49,790
use this function and all you get is

00:05:47,420 --> 00:05:51,860
this so you get essentially as a person

00:05:49,790 --> 00:05:53,780
and the contact is this descriptive

00:05:51,860 --> 00:05:57,230
enough have you ever asked yourself like

00:05:53,780 --> 00:05:59,360
ok but what happens if you have seven

00:05:57,230 --> 00:06:01,700
types of persons because in big projects

00:05:59,360 --> 00:06:04,010
you might have a domain model with a lot

00:06:01,700 --> 00:06:05,510
of persons with similar similar types

00:06:04,010 --> 00:06:07,580
what happens if you have different types

00:06:05,510 --> 00:06:10,280
of contexts what will happen if you give

00:06:07,580 --> 00:06:11,870
null if you give another value what will

00:06:10,280 --> 00:06:14,390
happen then in this function you cannot

00:06:11,870 --> 00:06:16,610
tell just for looking at it at this

00:06:14,390 --> 00:06:21,170
documentation at its signature because

00:06:16,610 --> 00:06:24,440
JavaScript doesn't tell you this how can

00:06:21,170 --> 00:06:27,350
we improve it yeah I'd say we we should

00:06:24,440 --> 00:06:29,930
all agree that we as humans are really

00:06:27,350 --> 00:06:31,760
or prone to errors so we should let the

00:06:29,930 --> 00:06:34,250
computer do a much better job at this

00:06:31,760 --> 00:06:36,890
than we do so as I let the computer do

00:06:34,250 --> 00:06:40,210
the hard work and just guide JavaScript

00:06:36,890 --> 00:06:44,150
to do something better know type types

00:06:40,210 --> 00:06:46,130
I'm are we talking I mean John's it has

00:06:44,150 --> 00:06:47,900
types types are there even if you don't

00:06:46,130 --> 00:06:51,970
specify them they they don't just go

00:06:47,900 --> 00:06:54,460
away and they're really really important

00:06:51,970 --> 00:06:56,500
let's say this is a simple academic

00:06:54,460 --> 00:06:58,330
definitions of a particular kind of data

00:06:56,500 --> 00:07:00,490
item as defined by the values it can

00:06:58,330 --> 00:07:01,719
take the programming language used or

00:07:00,490 --> 00:07:03,969
the operations that can be performed

00:07:01,719 --> 00:07:05,439
with blah blah blah really boring I

00:07:03,969 --> 00:07:08,530
don't know it by heart you shouldn't

00:07:05,439 --> 00:07:10,150
what's important is that as I said types

00:07:08,530 --> 00:07:12,430
are there even if you don't think about

00:07:10,150 --> 00:07:13,990
them so those are the seven now types

00:07:12,430 --> 00:07:16,539
you have in JavaScript boolean number

00:07:13,990 --> 00:07:19,240
strings undefined null object and now

00:07:16,539 --> 00:07:21,520
symbol those are all the types that the

00:07:19,240 --> 00:07:23,979
runtime has but you don't have to tell

00:07:21,520 --> 00:07:27,300
it what to use it will figure it out on

00:07:23,979 --> 00:07:30,000
its own but will it do so good

00:07:27,300 --> 00:07:31,780
documentation as I showed you before

00:07:30,000 --> 00:07:35,080
documentation is something that's

00:07:31,780 --> 00:07:37,150
probably missing nowadays from code

00:07:35,080 --> 00:07:39,460
written in JavaScript so we have to

00:07:37,150 --> 00:07:41,889
improve there how can we prove there we

00:07:39,460 --> 00:07:43,240
can improve there by using types I mean

00:07:41,889 --> 00:07:44,860
of course to that function

00:07:43,240 --> 00:07:47,110
someone could have written a bigger

00:07:44,860 --> 00:07:49,629
comment there we said okay person should

00:07:47,110 --> 00:07:51,159
be exactly this type the context to

00:07:49,629 --> 00:07:53,770
decide this of the function it does that

00:07:51,159 --> 00:07:55,360
but the comment is not really cold so

00:07:53,770 --> 00:07:58,449
comment has to be maintained separately

00:07:55,360 --> 00:08:01,840
and it increases the complexity it adds

00:07:58,449 --> 00:08:04,000
a lot of a lot of I mean it someone has

00:08:01,840 --> 00:08:04,449
maintained that and at some point trust

00:08:04,000 --> 00:08:06,370
me

00:08:04,449 --> 00:08:08,440
someone will not maintain that and it

00:08:06,370 --> 00:08:10,210
will end up with a different comment

00:08:08,440 --> 00:08:12,669
that a different function view and it

00:08:10,210 --> 00:08:15,279
will all get very very messy then we

00:08:12,669 --> 00:08:17,740
have enforcing as I said humans are

00:08:15,279 --> 00:08:20,229
really really prone to error so we need

00:08:17,740 --> 00:08:23,319
someone to make to add a bit of vigour

00:08:20,229 --> 00:08:26,770
to us especially as developers we cannot

00:08:23,319 --> 00:08:29,379
just be be led by our ourselves we have

00:08:26,770 --> 00:08:32,769
to we have to enforce a couple of rules

00:08:29,379 --> 00:08:34,449
and this can easily be avoided in

00:08:32,769 --> 00:08:37,120
JavaScript because you don't specify

00:08:34,449 --> 00:08:39,430
types you and everything is really

00:08:37,120 --> 00:08:42,880
really dynamic code that maybe shouldn't

00:08:39,430 --> 00:08:46,240
be valid is but this can be improved and

00:08:42,880 --> 00:08:49,329
then we have guidance JavaScript runtime

00:08:46,240 --> 00:08:52,300
is actually pretty pretty fast it's it's

00:08:49,329 --> 00:08:54,880
a great great virtual machine but the

00:08:52,300 --> 00:08:56,380
compiler itself can actually be smart

00:08:54,880 --> 00:08:58,149
cause I mean compilers nowadays are

00:08:56,380 --> 00:09:00,430
really really smart they can detect

00:08:58,149 --> 00:09:01,630
errors which should not have thought

00:09:00,430 --> 00:09:05,010
about before

00:09:01,630 --> 00:09:05,010
you just have to guide them a bit

00:09:05,170 --> 00:09:09,399
see how we can do that of course some

00:09:07,269 --> 00:09:10,959
people before have thought about this so

00:09:09,399 --> 00:09:12,699
they've tried to improve JavaScript

00:09:10,959 --> 00:09:14,980
they've tried to use some other

00:09:12,699 --> 00:09:17,649
languages which compiled out which

00:09:14,980 --> 00:09:19,839
compile down to JavaScript but let's see

00:09:17,649 --> 00:09:22,569
if they succeeded in a way or other we

00:09:19,839 --> 00:09:25,809
have CoffeeScript how many of you have

00:09:22,569 --> 00:09:28,299
ever used CoffeeScript before okay there

00:09:25,809 --> 00:09:32,379
are a few it's it was actually a pretty

00:09:28,299 --> 00:09:33,970
popular option because it added features

00:09:32,379 --> 00:09:37,029
that were not available in JavaScript

00:09:33,970 --> 00:09:39,459
before but it had a funky syntax for

00:09:37,029 --> 00:09:41,709
people not used to Python and yeah well

00:09:39,459 --> 00:09:43,569
it tend to remain that way it also

00:09:41,709 --> 00:09:46,119
didn't add any rigor because it's are

00:09:43,569 --> 00:09:49,480
still dynamic and some code was even

00:09:46,119 --> 00:09:53,699
even less readable then we have with

00:09:49,480 --> 00:09:56,829
anyone here programming in Java

00:09:53,699 --> 00:09:59,079
okay so Google web toolkit so this one

00:09:56,829 --> 00:10:01,329
may be basically those at Google thought

00:09:59,079 --> 00:10:04,019
yeah we don't like Java Script let's use

00:10:01,329 --> 00:10:06,999
Java I mean it should be similar right

00:10:04,019 --> 00:10:09,009
yeah well it's not really the of course

00:10:06,999 --> 00:10:11,470
Java is really strict that if we tighten

00:10:09,009 --> 00:10:14,079
all it adds a lot of rigor but on the

00:10:11,470 --> 00:10:16,749
web we have all this a synchronicity and

00:10:14,079 --> 00:10:18,669
a lot of stuff happens in the background

00:10:16,749 --> 00:10:20,139
a lot of things you cannot you don't

00:10:18,669 --> 00:10:22,779
know exactly and you need a bit more

00:10:20,139 --> 00:10:25,029
flexibility than Java has to offer so

00:10:22,779 --> 00:10:27,040
there are two these two options which I

00:10:25,029 --> 00:10:30,009
will talk next about those are

00:10:27,040 --> 00:10:32,079
typescript and flow flow is not actually

00:10:30,009 --> 00:10:34,660
a language but we'll see that later on

00:10:32,079 --> 00:10:36,279
so types of them flow are actually let's

00:10:34,660 --> 00:10:38,110
talk about types we first that's what is

00:10:36,279 --> 00:10:40,239
a superset of JavaScript this means that

00:10:38,110 --> 00:10:42,639
any single code you write in JavaScript

00:10:40,239 --> 00:10:44,679
is valid by fulfilled this is really

00:10:42,639 --> 00:10:46,600
important because first you have a lot

00:10:44,679 --> 00:10:48,549
of beginners you have a lot of people

00:10:46,600 --> 00:10:50,470
who are used to Java field and they love

00:10:48,549 --> 00:10:54,129
the syntax they love certain parts of it

00:10:50,470 --> 00:10:55,739
and you should definitely make it easier

00:10:54,129 --> 00:10:59,649
for them to get going with typescript

00:10:55,739 --> 00:11:01,809
then you have flow flow is very similar

00:10:59,649 --> 00:11:03,699
it's not a language it's just a static

00:11:01,809 --> 00:11:07,419
type checker will see we see later on

00:11:03,699 --> 00:11:09,970
why and we have L yeah I put it in the

00:11:07,419 --> 00:11:12,279
corner there not to punish it but

00:11:09,970 --> 00:11:13,989
because I'm not sure how many of you

00:11:12,279 --> 00:11:17,860
have ever have has anyone here ever

00:11:13,989 --> 00:11:19,110
heard or used Elm before great I'm I

00:11:17,860 --> 00:11:25,650
knew you were great

00:11:19,110 --> 00:11:26,310
so don't applaud for you okay I'm just

00:11:25,650 --> 00:11:28,440
as Oh

00:11:26,310 --> 00:11:31,650
who heard about understands before I'm

00:11:28,440 --> 00:11:33,600
sure if you watch if you follow any okay

00:11:31,650 --> 00:11:35,400
so he said this in one of his articles

00:11:33,600 --> 00:11:37,140
on mediums that I believe all JavaScript

00:11:35,400 --> 00:11:39,420
libraries which are intended to be used

00:11:37,140 --> 00:11:41,940
by thousands of developers should be

00:11:39,420 --> 00:11:43,920
written in Thai script can you know can

00:11:41,940 --> 00:11:46,260
you maybe think about why he said that I

00:11:43,920 --> 00:11:49,410
mean and I'm sure we can scratch

00:11:46,260 --> 00:11:51,480
libraries week we could say maybe any

00:11:49,410 --> 00:11:53,700
app that is intended to be used by

00:11:51,480 --> 00:11:56,310
thousands of developers or developed by

00:11:53,700 --> 00:11:58,460
hundreds of developers and we don't need

00:11:56,310 --> 00:12:02,280
a script we could use flour some other

00:11:58,460 --> 00:12:04,020
statically typed language this is really

00:12:02,280 --> 00:12:06,030
important because of the three of the

00:12:04,020 --> 00:12:08,280
three things I mentioned earlier which

00:12:06,030 --> 00:12:09,510
is document enforce and guide and this

00:12:08,280 --> 00:12:12,510
can really help us become better

00:12:09,510 --> 00:12:14,940
developers on the long run first let's

00:12:12,510 --> 00:12:16,620
talk about flow as I said flow is a

00:12:14,940 --> 00:12:18,360
static type checker is not even a

00:12:16,620 --> 00:12:20,760
language of its own it doesn't have a

00:12:18,360 --> 00:12:23,550
compiler it's just a checker which needs

00:12:20,760 --> 00:12:27,090
a little guidance it was developed by

00:12:23,550 --> 00:12:29,040
Facebook so its goal is no runtime

00:12:27,090 --> 00:12:31,800
errors this is a pretty big goal in all

00:12:29,040 --> 00:12:36,450
days because who here has ever gotten a

00:12:31,800 --> 00:12:38,730
undefined is not a function okay

00:12:36,450 --> 00:12:41,040
yes that one that's that's the thing we

00:12:38,730 --> 00:12:42,750
need to avoid in the future then we have

00:12:41,040 --> 00:12:45,000
typescript which is a language of its

00:12:42,750 --> 00:12:48,390
own it comes with complete - link its

00:12:45,000 --> 00:12:50,250
own compiler it's only inter and it has

00:12:48,390 --> 00:12:52,260
it's a superset so being a language has

00:12:50,250 --> 00:12:54,510
a few advantages over being just a

00:12:52,260 --> 00:12:56,010
checker you can add features to the

00:12:54,510 --> 00:12:58,230
language you can add abstract classes

00:12:56,010 --> 00:13:00,090
you can that decorators feet really

00:12:58,230 --> 00:13:02,400
really good features opt for

00:13:00,090 --> 00:13:06,240
object-oriented programming let's see a

00:13:02,400 --> 00:13:08,730
few few examples here this is a code

00:13:06,240 --> 00:13:11,820
written using flow so I mean if you've

00:13:08,730 --> 00:13:13,740
paid attention to new stock earlier you

00:13:11,820 --> 00:13:15,540
will see that you have type annotations

00:13:13,740 --> 00:13:17,580
the right name should be a string you

00:13:15,540 --> 00:13:19,320
just tell the compiler or the checkers

00:13:17,580 --> 00:13:22,290
yeah well name should be a string that

00:13:19,320 --> 00:13:24,120
you have talked of method here in the

00:13:22,290 --> 00:13:26,190
person class which takes another person

00:13:24,120 --> 00:13:28,170
and returns a string and we have there

00:13:26,190 --> 00:13:30,300
an error because I wanted to show you

00:13:28,170 --> 00:13:31,890
how an error looks like in flow and what

00:13:30,300 --> 00:13:32,970
happens there so basically you just

00:13:31,890 --> 00:13:34,950
write this code then

00:13:32,970 --> 00:13:38,100
so yeah well this should run just fine

00:13:34,950 --> 00:13:40,290
and when you hit save and run the the

00:13:38,100 --> 00:13:42,180
flow checker you will see that okay but

00:13:40,290 --> 00:13:44,880
yeah you've returned there a number I

00:13:42,180 --> 00:13:47,970
was expecting a string yeah this is one

00:13:44,880 --> 00:13:49,530
one thing it really helps then we have

00:13:47,970 --> 00:13:51,180
the same code in Thai script and I mean

00:13:49,530 --> 00:13:53,790
the same code because it's literally the

00:13:51,180 --> 00:13:56,340
same code it's the only difference here

00:13:53,790 --> 00:13:59,670
is the error and the fact that this code

00:13:56,340 --> 00:14:02,940
will be then compiled by the types of

00:13:59,670 --> 00:14:04,770
compiler the error is similar it's just

00:14:02,940 --> 00:14:08,130
a different different syntax

00:14:04,770 --> 00:14:10,710
now I'm getting a bit a bit more more

00:14:08,130 --> 00:14:14,130
technical here let's say you we wanted

00:14:10,710 --> 00:14:16,290
to marry to talk to let's go back a bit

00:14:14,130 --> 00:14:18,180
if you if you take a look at this

00:14:16,290 --> 00:14:20,820
function talk takes a person out a

00:14:18,180 --> 00:14:23,340
person both in flow and in typescript

00:14:20,820 --> 00:14:24,840
you can enforce the compiler to say yeah

00:14:23,340 --> 00:14:26,430
well if I say it's a person it's a

00:14:24,840 --> 00:14:29,160
person I mean it cannot be null for

00:14:26,430 --> 00:14:31,410
example so it cannot be null you needed

00:14:29,160 --> 00:14:33,960
to take a person so if you let's say I

00:14:31,410 --> 00:14:37,050
passed Tom which is now if you take a

00:14:33,960 --> 00:14:38,910
look here what will slow do it will tell

00:14:37,050 --> 00:14:42,810
me yeah well null is incompatible with

00:14:38,910 --> 00:14:45,120
person because null is not a person we

00:14:42,810 --> 00:14:48,840
have the same thing in typescript again

00:14:45,120 --> 00:14:51,480
and here are a few companies and

00:14:48,840 --> 00:14:54,510
projects which use typescript or flow I

00:14:51,480 --> 00:14:56,010
mean those actually I think are all all

00:14:54,510 --> 00:14:59,160
of those are using typescript

00:14:56,010 --> 00:15:01,830
I think you've read dirty there is a

00:14:59,160 --> 00:15:04,080
great article on medium I think Alex you

00:15:01,830 --> 00:15:06,630
posted about slack

00:15:04,080 --> 00:15:08,580
switching to typescript yep so slightly

00:15:06,630 --> 00:15:11,280
switching to type suite which with its

00:15:08,580 --> 00:15:13,740
code base because it I mean they have a

00:15:11,280 --> 00:15:15,750
really really big app and they need to

00:15:13,740 --> 00:15:17,790
enforce some rules there then we have

00:15:15,750 --> 00:15:19,650
asana we have ionic offers angular

00:15:17,790 --> 00:15:25,020
angular may type suit really popular and

00:15:19,650 --> 00:15:27,870
thanks for that and a few more but let's

00:15:25,020 --> 00:15:30,450
see its limitations so we of course we

00:15:27,870 --> 00:15:32,040
have static type checking we have I'm

00:15:30,450 --> 00:15:34,580
not sure I mean how many things can you

00:15:32,040 --> 00:15:37,230
check out compiles I'm sure you have

00:15:34,580 --> 00:15:40,830
synchronous stuff you have method calls

00:15:37,230 --> 00:15:42,990
you have assignments but as I said in

00:15:40,830 --> 00:15:45,059
the front-end especially a lot of things

00:15:42,990 --> 00:15:47,669
happen a synchronously

00:15:45,059 --> 00:15:50,279
so you may not know everything you have

00:15:47,669 --> 00:15:52,589
a synchronous requests you have requests

00:15:50,279 --> 00:15:54,359
to the server you have you have a lot of

00:15:52,589 --> 00:15:57,499
stuff you have form validation for

00:15:54,359 --> 00:16:01,619
example and you cannot know for sure

00:15:57,499 --> 00:16:04,679
anything at anything at run time will be

00:16:01,619 --> 00:16:08,639
checked by your static type checker so

00:16:04,679 --> 00:16:10,589
we need something more that's why we

00:16:08,639 --> 00:16:14,039
have slower run time of course this is

00:16:10,589 --> 00:16:15,689
this isn't in pretty early stage it used

00:16:14,039 --> 00:16:18,449
to be called differently now it's called

00:16:15,689 --> 00:16:20,339
flow run time and yeah well when compile

00:16:18,449 --> 00:16:21,179
time checking is not enough this is

00:16:20,339 --> 00:16:23,099
really important

00:16:21,179 --> 00:16:26,129
let's see what happens here this is

00:16:23,099 --> 00:16:28,649
valid typescript and it is valid flow

00:16:26,129 --> 00:16:30,419
code actually but flow runtime doesn't

00:16:28,649 --> 00:16:32,939
only work with flow it also works with

00:16:30,419 --> 00:16:36,389
typescript what happens here I have the

00:16:32,939 --> 00:16:39,119
same code and I will run it to the to

00:16:36,389 --> 00:16:42,629
the flow runtime compiler and I will get

00:16:39,119 --> 00:16:44,999
this what happens is that the type that

00:16:42,629 --> 00:16:47,489
was earlier called think is now a tag

00:16:44,999 --> 00:16:49,169
filled with flow runtime it adds a

00:16:47,489 --> 00:16:52,139
little because a little constraint to

00:16:49,169 --> 00:16:54,569
the code so at runtime when I run being

00:16:52,139 --> 00:16:56,249
about assert there this is all compiled

00:16:54,569 --> 00:16:58,799
by the compiler you don't have to write

00:16:56,249 --> 00:17:01,169
any of this what I write assert there it

00:16:58,799 --> 00:17:04,559
will throw an error if that object does

00:17:01,169 --> 00:17:07,139
not respect the structure we just gave

00:17:04,559 --> 00:17:09,389
it so this is really really important it

00:17:07,139 --> 00:17:11,519
has a complete type system compatible

00:17:09,389 --> 00:17:14,249
with flow syntax and it's there are

00:17:11,519 --> 00:17:16,259
already tools available and some I think

00:17:14,249 --> 00:17:20,399
there's an integration with mod X if any

00:17:16,259 --> 00:17:22,470
one fence is that moving on the last

00:17:20,399 --> 00:17:25,169
thing we'll discuss here is Elm

00:17:22,470 --> 00:17:26,999
I'm pretty happy that a lot of you guys

00:17:25,169 --> 00:17:30,389
are you have used it or have at least

00:17:26,999 --> 00:17:32,909
tried but let's just begin by a little

00:17:30,389 --> 00:17:35,820
code example here for those of you who

00:17:32,909 --> 00:17:39,659
have never used any functional language

00:17:35,820 --> 00:17:42,570
before this will be pretty how could I

00:17:39,659 --> 00:17:44,369
say this pretty strange so enemy is a

00:17:42,570 --> 00:17:46,980
purely functional language you just have

00:17:44,369 --> 00:17:49,139
functions which all of them are pure you

00:17:46,980 --> 00:17:52,649
you have types of course and it's really

00:17:49,139 --> 00:17:56,429
really strict so let's see how an error

00:17:52,649 --> 00:17:58,320
of looks in l an arrow L'Occitane looks

00:17:56,429 --> 00:17:58,680
like this really descriptive it will

00:17:58,320 --> 00:18:00,600
tell you

00:17:58,680 --> 00:18:03,240
it will tell you what it expected in a

00:18:00,600 --> 00:18:06,330
beautiful way it can even suggest types

00:18:03,240 --> 00:18:08,130
you didn't know about I mean if you put

00:18:06,330 --> 00:18:09,960
a wrong with don't I'm somewhere it will

00:18:08,130 --> 00:18:11,610
suggest that well your function returns

00:18:09,960 --> 00:18:14,790
the number but you said it should return

00:18:11,610 --> 00:18:17,220
a string so choose one of those this is

00:18:14,790 --> 00:18:19,920
great this is really great and they they

00:18:17,220 --> 00:18:23,310
actually have no runtime errors which is

00:18:19,920 --> 00:18:25,740
even better they they also have runtime

00:18:23,310 --> 00:18:28,200
checking for types I mean all those

00:18:25,740 --> 00:18:31,350
types which are already there in the in

00:18:28,200 --> 00:18:33,930
the runtime are 100% safe and all those

00:18:31,350 --> 00:18:36,930
things which come from JavaScript are

00:18:33,930 --> 00:18:39,180
also 100% safe because they have to pass

00:18:36,930 --> 00:18:42,180
through a converter before they get into

00:18:39,180 --> 00:18:43,980
elm so this is really important having

00:18:42,180 --> 00:18:46,020
no runtime errors is really important of

00:18:43,980 --> 00:18:48,450
course the learning curve is pretty

00:18:46,020 --> 00:18:50,610
steep here so if you are not familiar

00:18:48,450 --> 00:18:57,180
with it I say you should get familiar

00:18:50,610 --> 00:18:59,430
with it overall I I think it's it's

00:18:57,180 --> 00:19:01,440
really important to remember that for

00:18:59,430 --> 00:19:04,200
small projects for just learning how to

00:19:01,440 --> 00:19:05,940
code we should use Java so we should we

00:19:04,200 --> 00:19:08,340
should stick to the basics we should

00:19:05,940 --> 00:19:10,080
first learn how to code before I mean we

00:19:08,340 --> 00:19:12,060
should we should first learn how to walk

00:19:10,080 --> 00:19:14,940
before we learn how to run for example

00:19:12,060 --> 00:19:17,520
so first load JavaScript 3012 but when

00:19:14,940 --> 00:19:20,250
you are developing a bigger application

00:19:17,520 --> 00:19:22,410
please use typescript it will help you

00:19:20,250 --> 00:19:25,590
and which will help any other developer

00:19:22,410 --> 00:19:27,740
which will use it in the future thank

00:19:25,590 --> 00:19:27,740
you

00:19:34,570 --> 00:19:39,710
okay let's let's see the questions would

00:19:38,330 --> 00:19:41,720
you recommend adding types to an

00:19:39,710 --> 00:19:45,770
existing code base which is rather large

00:19:41,720 --> 00:19:48,080
yes actually I I'd say you should add

00:19:45,770 --> 00:19:50,900
types and it's it really helps that both

00:19:48,080 --> 00:19:53,480
flow and dye script are are really easy

00:19:50,900 --> 00:19:55,460
to get on with so maybe with flow you

00:19:53,480 --> 00:19:57,830
just you can just tell it to check file

00:19:55,460 --> 00:19:59,870
even if it has no type annotations and

00:19:57,830 --> 00:20:01,730
it will still catch some errors there

00:19:59,870 --> 00:20:03,890
this happens also with dye script you

00:20:01,730 --> 00:20:05,810
can do the same you can enforce a few

00:20:03,890 --> 00:20:08,180
things I mean you just have to add a

00:20:05,810 --> 00:20:11,720
config file there and it's all pretty

00:20:08,180 --> 00:20:16,220
pretty straightforward okay next Tensei

00:20:11,720 --> 00:20:17,600
script get you a date yeah well of

00:20:16,220 --> 00:20:22,130
course I mean who doesn't like writing

00:20:17,600 --> 00:20:23,690
functions right did you have culture

00:20:22,130 --> 00:20:26,990
clash or resistance in your DMS I

00:20:23,690 --> 00:20:29,030
adopted typescript well actually no no

00:20:26,990 --> 00:20:31,280
but that's that's because of my

00:20:29,030 --> 00:20:33,920
background at it might not apply to you

00:20:31,280 --> 00:20:37,100
and because in my team a lot of guys

00:20:33,920 --> 00:20:39,290
used Java before they were used already

00:20:37,100 --> 00:20:42,080
to the strictness and the static

00:20:39,290 --> 00:20:44,360
statically typed which we have there but

00:20:42,080 --> 00:20:47,150
if you let's say like let's say I this

00:20:44,360 --> 00:20:49,540
if your team only worked with dynamic

00:20:47,150 --> 00:20:52,340
languages they might feel a little

00:20:49,540 --> 00:20:54,740
resistant towards towards typescript and

00:20:52,340 --> 00:20:58,090
towards static types but they will they

00:20:54,740 --> 00:21:01,280
will get the coton with it easily

00:20:58,090 --> 00:21:03,200
okay how about junior deaths would it be

00:21:01,280 --> 00:21:07,310
wise for them to start with strongly

00:21:03,200 --> 00:21:09,140
typed from the beginning II afraid are

00:21:07,310 --> 00:21:11,870
they of programming actually that's does

00:21:09,140 --> 00:21:14,780
the greater question are they do they

00:21:11,870 --> 00:21:17,300
like it they enjoy writing functions in

00:21:14,780 --> 00:21:20,030
JavaScript that's great they they should

00:21:17,300 --> 00:21:22,400
I mean as I said tags are already there

00:21:20,030 --> 00:21:24,470
they are already they cannot be you

00:21:22,400 --> 00:21:26,840
cannot program without types so why not

00:21:24,470 --> 00:21:29,270
learn them why not learn them from the

00:21:26,840 --> 00:21:31,100
beginning I mean if you if you had a few

00:21:29,270 --> 00:21:33,350
of your experiences with coding you can

00:21:31,100 --> 00:21:39,710
gently introduce into the stipes into

00:21:33,350 --> 00:21:41,630
the integration yeah and I'm sure it

00:21:39,710 --> 00:21:43,850
would have been at least maintainable

00:21:41,630 --> 00:21:46,470
maybe we'll have it today

00:21:43,850 --> 00:21:48,990
whilst white I suit and all flow type I

00:21:46,470 --> 00:21:51,420
mean no there's there's no reason why I

00:21:48,990 --> 00:21:53,970
would suspect it actually is because it

00:21:51,420 --> 00:21:56,310
it has a bit better to link there are

00:21:53,970 --> 00:21:59,910
more more types available for existing

00:21:56,310 --> 00:22:01,740
libraries and a lot a lot of companies a

00:21:59,910 --> 00:22:04,620
lot more companies are using it already

00:22:01,740 --> 00:22:06,480
so you have great examples and one one

00:22:04,620 --> 00:22:08,550
more reason actually is that theis creat

00:22:06,480 --> 00:22:11,490
the type C compiler is built using

00:22:08,550 --> 00:22:13,680
typescript so the guys are using type c2

00:22:11,490 --> 00:22:15,210
builder the typescript language which is

00:22:13,680 --> 00:22:18,290
pretty great because they're using their

00:22:15,210 --> 00:22:22,560
own language to their own advantage

00:22:18,290 --> 00:22:23,760
what about Elm yeah well enemy is a

00:22:22,560 --> 00:22:27,540
totally different world

00:22:23,760 --> 00:22:29,850
el is pretty really functional is one of

00:22:27,540 --> 00:22:33,510
a few language which can which can brag

00:22:29,850 --> 00:22:36,060
about this so it's really great in in

00:22:33,510 --> 00:22:39,150
big projects it has an extraordinary

00:22:36,060 --> 00:22:41,580
advantage because it can it can actually

00:22:39,150 --> 00:22:43,380
be integrated into existing projects so

00:22:41,580 --> 00:22:45,570
you can just have I'm not sure let's say

00:22:43,380 --> 00:22:47,730
you have a form which you need a lot of

00:22:45,570 --> 00:22:49,440
things to do there and you want to add

00:22:47,730 --> 00:22:51,270
elder you can just do that you can just

00:22:49,440 --> 00:22:53,880
integrate them into a part of your app

00:22:51,270 --> 00:22:56,460
and everything that will be inside will

00:22:53,880 --> 00:22:59,190
be safe so you will not get any errors

00:22:56,460 --> 00:23:03,090
from el you may only get errors from

00:22:59,190 --> 00:23:04,830
your JavaScript part I say if you if you

00:23:03,090 --> 00:23:07,140
want to learn functional languages yes

00:23:04,830 --> 00:23:08,370
you should you should definitely start

00:23:07,140 --> 00:23:11,070
by learning Elm

00:23:08,370 --> 00:23:12,810
at least look at the syntax see see why

00:23:11,070 --> 00:23:15,060
why some decisions have been taken

00:23:12,810 --> 00:23:16,890
instead of others and I'm sure you will

00:23:15,060 --> 00:23:23,460
reach to a conclusion which which will

00:23:16,890 --> 00:23:30,210
suit your project great yeah but you

00:23:23,460 --> 00:23:32,430
don't use tweak so okay so what's your

00:23:30,210 --> 00:23:34,220
take us that we type types of charities

00:23:32,430 --> 00:23:37,230
yeah well I've already talked about

00:23:34,220 --> 00:23:40,500
about elm about trees with reason ml

00:23:37,230 --> 00:23:44,010
honestly I don't have an experience so I

00:23:40,500 --> 00:23:46,400
I cannot say anything about it or they

00:23:44,010 --> 00:23:48,750
convert a number it was doing it by 50

00:23:46,400 --> 00:23:51,150
well it has it if you define something

00:23:48,750 --> 00:23:53,970
that it's a number you cannot convert it

00:23:51,150 --> 00:23:56,070
to a string you can if you assign it to

00:23:53,970 --> 00:23:57,630
a string you have a few functions there

00:23:56,070 --> 00:23:59,220
you can just go to string

00:23:57,630 --> 00:24:01,830
and there are a few ways to do this

00:23:59,220 --> 00:24:03,810
actually but you don't convert the the

00:24:01,830 --> 00:24:07,620
exactly the same number you just create

00:24:03,810 --> 00:24:10,290
a new variable which is now a string is

00:24:07,620 --> 00:24:14,640
there an L corner outside no but we'll

00:24:10,290 --> 00:24:16,740
make one there will be

00:24:14,640 --> 00:24:18,930
how can you easily debug that yeah this

00:24:16,740 --> 00:24:23,550
is a great question actually Chrome and

00:24:18,930 --> 00:24:26,010
I'm sure other browsers as well have had

00:24:23,550 --> 00:24:28,260
support for typescript in the browser so

00:24:26,010 --> 00:24:31,290
because that's depend it comprised it

00:24:28,260 --> 00:24:33,960
can generate those mapping files so you

00:24:31,290 --> 00:24:35,850
just map your JavaScript code to the

00:24:33,960 --> 00:24:37,470
declaration files which I see so

00:24:35,850 --> 00:24:39,810
basically you will have your typescript

00:24:37,470 --> 00:24:41,370
code in your browser more or less so you

00:24:39,810 --> 00:24:43,140
will see you will not see the compiled

00:24:41,370 --> 00:24:46,170
JavaScript which is by the way is

00:24:43,140 --> 00:24:49,470
totally human readable this was one of

00:24:46,170 --> 00:24:51,420
their their main points there so you can

00:24:49,470 --> 00:24:53,850
debug it pretty easily you will get your

00:24:51,420 --> 00:24:55,920
code which is type it in your in your

00:24:53,850 --> 00:25:01,350
browser as well as your compiled code so

00:24:55,920 --> 00:25:04,410
we can do you can do with any of them is

00:25:01,350 --> 00:25:06,660
flow used with react.js x you can use

00:25:04,410 --> 00:25:09,270
both flow and type good with three

00:25:06,660 --> 00:25:11,310
address X basically I mean once you have

00:25:09,270 --> 00:25:13,530
typed definitions for something you can

00:25:11,310 --> 00:25:16,710
basically throw in type type script or

00:25:13,530 --> 00:25:19,140
or flow and there are thousands of type

00:25:16,710 --> 00:25:21,720
definitions for most of the libraries

00:25:19,140 --> 00:25:23,580
you will ever need and if there are if

00:25:21,720 --> 00:25:25,890
there aren't for one of the libraries

00:25:23,580 --> 00:25:28,710
use please add them I mean it's an open

00:25:25,890 --> 00:25:30,570
source project doesn't estimate

00:25:28,710 --> 00:25:32,460
developers become lazy and or less

00:25:30,570 --> 00:25:35,910
careful with their codebase because they

00:25:32,460 --> 00:25:38,450
rely on this language I wouldn't say it

00:25:35,910 --> 00:25:43,470
developers become lazy because I think

00:25:38,450 --> 00:25:45,600
developers are lazy by nature so we

00:25:43,470 --> 00:25:51,210
cannot become something you already are

00:25:45,600 --> 00:25:52,830
and if what what happens is that if you

00:25:51,210 --> 00:25:55,200
work on a small code base you know every

00:25:52,830 --> 00:25:57,090
single corner of it it's fine but if you

00:25:55,200 --> 00:25:59,550
work on a larger project you have access

00:25:57,090 --> 00:26:02,730
just one module maybe then it's no

00:25:59,550 --> 00:26:04,350
longer fine because you won maybe some

00:26:02,730 --> 00:26:06,390
sometimes we will get to chance to look

00:26:04,350 --> 00:26:08,760
at some of the code and you will not

00:26:06,390 --> 00:26:11,610
understand a thing because because of

00:26:08,760 --> 00:26:14,220
this how would you memorize a function

00:26:11,610 --> 00:26:16,460
I script the way you do it with

00:26:14,220 --> 00:26:19,950
JavaScript

00:26:16,460 --> 00:26:21,059
so I how do you tell what type it is

00:26:19,950 --> 00:26:23,429
worth the hassle

00:26:21,059 --> 00:26:26,730
I'd say if it's if you think the project

00:26:23,429 --> 00:26:29,400
will be larger than yes if not if it's

00:26:26,730 --> 00:26:31,920
just a prototype then sure but you

00:26:29,400 --> 00:26:32,809
cannot exceed the prototype as well why

00:26:31,920 --> 00:26:37,309
not

00:26:32,809 --> 00:26:37,309
okay thank you thank you for this

00:26:40,880 --> 00:26:42,940

YouTube URL: https://www.youtube.com/watch?v=YnukrLi8zew


