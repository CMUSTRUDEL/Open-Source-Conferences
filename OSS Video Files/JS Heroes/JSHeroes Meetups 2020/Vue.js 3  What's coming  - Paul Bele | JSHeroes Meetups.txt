Title: Vue.js 3  What's coming  - Paul Bele | JSHeroes Meetups
Publication date: 2020-03-28
Playlist: JSHeroes Meetups 2020
Description: 
	Hello JavaScripters,

With a Vue.js 3 release in sight, it’s a good time to get familiar with the upcoming features. In this presentation, we’re going to take a trip around the main features, changes and improvements and see what makes Vue.js 3 different from Vue.js 2.

We'll cover:
- Performance improvements
- Composition API
- API changes
- New component types
- Better TypeScript support
- Other exciting features (fragments, suspense, multiple v-models, portals, etc)

Required knowledge:
A basic Vue.js or SPA framework knowledge is recommended

About Paul:
For the past five years, Paul is a remote web developer at Jadu, a UK based company where he helps dozens of local councils and organizations digitalize their processes and services.
Paul's Twitter: https://twitter.com/skmetaly

https://www.meetup.com/jsheroes/events/269602763/
Captions: 
	00:00:03,190 --> 00:00:10,150
okay so hi everybody and welcome to our

00:00:05,680 --> 00:00:12,009
first remote meetup please have patience

00:00:10,150 --> 00:00:15,370
because because this is a the first time

00:00:12,009 --> 00:00:19,720
we're doing this and as Alex said we

00:00:15,370 --> 00:00:22,480
should have done this earlier okay so

00:00:19,720 --> 00:00:25,119
our speaker for today is Paul Bella he

00:00:22,480 --> 00:00:28,769
will talk to us about what's coming up

00:00:25,119 --> 00:00:32,439
in the new version of you

00:00:28,769 --> 00:00:34,240
so yeah let's begin Daniel if you want

00:00:32,439 --> 00:00:41,320
to say something before we begin or

00:00:34,240 --> 00:00:44,770
about the survey yes sure I don't know

00:00:41,320 --> 00:00:47,879
maybe a part of you guys have noticed we

00:00:44,770 --> 00:00:53,949
posted guys and girls sorry don't wander

00:00:47,879 --> 00:00:56,109
make any mistakes where we posted we

00:00:53,949 --> 00:01:00,910
want to do a survey on the closure area

00:00:56,109 --> 00:01:05,260
JavaScript so if you have time please

00:01:00,910 --> 00:01:06,970
please share so alright guys I had the

00:01:05,260 --> 00:01:08,740
Alex do you want to do it I had there

00:01:06,970 --> 00:01:12,850
like you really really hard day and

00:01:08,740 --> 00:01:15,520
spoke hold ankles want to take it yeah

00:01:12,850 --> 00:01:19,150
so we have we have the link in the it

00:01:15,520 --> 00:01:20,890
was posted in the chat here and we also

00:01:19,150 --> 00:01:23,260
posted it on Facebook Twitter Linkedin

00:01:20,890 --> 00:01:26,710
it's like should take you like ten

00:01:23,260 --> 00:01:28,720
minutes to fill it up and we will make

00:01:26,710 --> 00:01:31,090
the all the information public once we

00:01:28,720 --> 00:01:33,640
compile the result it should be

00:01:31,090 --> 00:01:36,970
interesting to see like the local law

00:01:33,640 --> 00:01:38,590
suit community like how people where we

00:01:36,970 --> 00:01:39,850
are like compared maybe to the rest of

00:01:38,590 --> 00:01:42,120
the world because there are there a lot

00:01:39,850 --> 00:01:44,790
of surveys I global surveys about

00:01:42,120 --> 00:01:47,200
developers but there was nothing done

00:01:44,790 --> 00:01:50,710
specifically for the local community so

00:01:47,200 --> 00:01:52,510
be interesting to see that and also of

00:01:50,710 --> 00:01:54,460
course if you can share it with your

00:01:52,510 --> 00:01:57,760
colleagues friends like whoever you know

00:01:54,460 --> 00:02:01,540
is in in touch with the JavaScript

00:01:57,760 --> 00:02:04,320
restaurant and world that say it will be

00:02:01,540 --> 00:02:04,320
nice to gather input

00:02:07,000 --> 00:02:13,780
from Cluj yeah we are gathering results

00:02:12,340 --> 00:02:18,610
from from everywhere

00:02:13,780 --> 00:02:20,890
and we will do like filter we have the

00:02:18,610 --> 00:02:22,540
results for everyone who responded like

00:02:20,890 --> 00:02:24,400
doing let's say the JavaScript community

00:02:22,540 --> 00:02:39,930
the global community and we will also

00:02:24,400 --> 00:02:39,930
have a filtered results for the yeah

00:02:55,670 --> 00:02:58,880
[Music]

00:03:02,520 --> 00:03:08,670
thankfully you team mostly introduced

00:03:05,500 --> 00:03:11,350
additions and improvements over the

00:03:08,670 --> 00:03:13,930
rather than some major new changes so

00:03:11,350 --> 00:03:16,390
that people had already no view to or

00:03:13,930 --> 00:03:18,220
already started looking into view should

00:03:16,390 --> 00:03:21,549
already quickly feel comfortable with

00:03:18,220 --> 00:03:24,160
with a new C so my name is Paul Bonnie

00:03:21,549 --> 00:03:26,200
I'm a remote well mostly I guess

00:03:24,160 --> 00:03:28,660
everyone is a wonderful days web

00:03:26,200 --> 00:03:31,510
developer at Giotto I am a mostly

00:03:28,660 --> 00:03:33,580
back-end developer and agile we help

00:03:31,510 --> 00:03:36,190
local councils and universities across

00:03:33,580 --> 00:03:39,070
UK and USA digitalize their

00:03:36,190 --> 00:03:41,049
infrastructure and their processes so

00:03:39,070 --> 00:03:43,750
for the past year and a half

00:03:41,049 --> 00:03:45,489
give or take I started working on single

00:03:43,750 --> 00:03:48,190
page application projects across the

00:03:45,489 --> 00:03:53,470
company and its many with vue.js and

00:03:48,190 --> 00:03:57,250
everything is going great and so by now

00:03:53,470 --> 00:04:00,130
you're probably aware we're getting a

00:03:57,250 --> 00:04:02,290
shiny new version of you and if you

00:04:00,130 --> 00:04:05,010
don't know about this quickly view gist

00:04:02,290 --> 00:04:07,780
is that the stable version of 2.6 and

00:04:05,010 --> 00:04:11,410
the version 3 was announced by ever-new

00:04:07,780 --> 00:04:14,739
I think in the fall of 2018 and you just

00:04:11,410 --> 00:04:16,539
London and his announcement summary was

00:04:14,739 --> 00:04:19,090
also published on the future of you just

00:04:16,539 --> 00:04:21,850
blog also on multiple

00:04:19,090 --> 00:04:24,090
because written since then and it's been

00:04:21,850 --> 00:04:27,970
written like main features manor of

00:04:24,090 --> 00:04:29,949
talked about later and yeah so until the

00:04:27,970 --> 00:04:31,810
release of you tree we want to talk

00:04:29,949 --> 00:04:33,940
about all the valuable information that

00:04:31,810 --> 00:04:36,160
we can find all the resources and

00:04:33,940 --> 00:04:38,260
hopefully by the end of these

00:04:36,160 --> 00:04:40,650
presentations by the end of this

00:04:38,260 --> 00:04:43,630
presentation we'll be up to date with

00:04:40,650 --> 00:04:45,520
with what the current status of your

00:04:43,630 --> 00:04:50,020
treaties and what we can expect from

00:04:45,520 --> 00:04:52,570
from it but before we look into what we

00:04:50,020 --> 00:04:54,520
love about Blue Jays tree I really want

00:04:52,570 --> 00:04:58,600
to talk a bit about the current state of

00:04:54,520 --> 00:05:01,750
uija's and how what is it and why why do

00:04:58,600 --> 00:05:03,700
we use it so much so let's take a short

00:05:01,750 --> 00:05:05,919
journey through the history of you and

00:05:03,700 --> 00:05:09,040
kind of see how exactly did you end up

00:05:05,919 --> 00:05:11,860
here so first view was created by

00:05:09,040 --> 00:05:14,320
revenue who worked at Google and was

00:05:11,860 --> 00:05:17,229
using angular on on a number of projects

00:05:14,320 --> 00:05:20,289
and he later summed up his thoughts

00:05:17,229 --> 00:05:21,970
process and figure out that he wants to

00:05:20,289 --> 00:05:24,400
extract what he really likes about

00:05:21,970 --> 00:05:27,070
angular and the good features about it

00:05:24,400 --> 00:05:30,880
but packaged everything up in a very

00:05:27,070 --> 00:05:35,380
lightweight library so the first source

00:05:30,880 --> 00:05:38,200
code commit was dated in July 2013 and B

00:05:35,380 --> 00:05:42,220
was released in February of 2014 as a

00:05:38,200 --> 00:05:43,620
public first release so a year later in

00:05:42,220 --> 00:05:46,960
October 2015

00:05:43,620 --> 00:05:49,570
he gave the first version and he

00:05:46,960 --> 00:05:52,090
improved the template in C tags he added

00:05:49,570 --> 00:05:54,849
initial read faster initial rendering we

00:05:52,090 --> 00:05:59,260
have hot component reloading scope CSS

00:05:54,849 --> 00:06:02,289
and in version two in 2016 in September

00:05:59,260 --> 00:06:04,990
get another set of good performance

00:06:02,289 --> 00:06:07,690
improvements a new iteration of virtual

00:06:04,990 --> 00:06:09,760
Dom also I'm not sure if it's a new

00:06:07,690 --> 00:06:11,849
iteration of your column or only in

00:06:09,760 --> 00:06:14,470
version 2 was actually into distribution

00:06:11,849 --> 00:06:18,099
as well as render functions and

00:06:14,470 --> 00:06:21,430
server-side rendering so nowadays in

00:06:18,099 --> 00:06:23,860
February 2000 19 its version 2.6

00:06:21,430 --> 00:06:26,680
released which again another set of

00:06:23,860 --> 00:06:29,169
performance improvements we have unified

00:06:26,680 --> 00:06:32,080
slot syntax and dynamic directive

00:06:29,169 --> 00:06:32,650
arguments I don't think we're two point

00:06:32,080 --> 00:06:34,570
six

00:06:32,650 --> 00:06:38,430
for in 13 or something like that I'm not

00:06:34,570 --> 00:06:40,720
entirely sure but we are still on 2.6 so

00:06:38,430 --> 00:06:42,669
taking like the history and thinking

00:06:40,720 --> 00:06:44,229
about in the context of all of the

00:06:42,669 --> 00:06:46,330
modern single page application

00:06:44,229 --> 00:06:48,970
frameworks view is actually a very

00:06:46,330 --> 00:06:50,770
relatively young framework but in a

00:06:48,970 --> 00:06:52,060
short time it's actually a very famous

00:06:50,770 --> 00:06:54,370
so it's been used by thousands of

00:06:52,060 --> 00:06:57,460
companies worldwide including Google

00:06:54,370 --> 00:07:00,850
Apple Adobe Nintendo and many many more

00:06:57,460 --> 00:07:02,800
and I think the reason that all of these

00:07:00,850 --> 00:07:06,639
companies decided to use vue.js

00:07:02,800 --> 00:07:08,410
is because it's very easy to pick up and

00:07:06,639 --> 00:07:12,669
it's very easy to learn and get started

00:07:08,410 --> 00:07:15,130
with so here we have a graph from a case

00:07:12,669 --> 00:07:17,410
study of the state of JavaScript which

00:07:15,130 --> 00:07:19,510
backs this claim up where future

00:07:17,410 --> 00:07:21,400
developers were simply asked what is

00:07:19,510 --> 00:07:23,800
their favorite aspects of you just buy

00:07:21,400 --> 00:07:25,240
new why do they keep using it and as you

00:07:23,800 --> 00:07:29,590
can see they place that easy learning

00:07:25,240 --> 00:07:32,020
curve as the most important aspect for

00:07:29,590 --> 00:07:34,180
reference I have the same question here

00:07:32,020 --> 00:07:36,639
from the react developers and they place

00:07:34,180 --> 00:07:40,599
the easy learning curve as third from

00:07:36,639 --> 00:07:42,940
the bottom and of course all of these

00:07:40,599 --> 00:07:45,190
companies don't just use view because it

00:07:42,940 --> 00:07:47,169
is simple and it's easy to pick up we

00:07:45,190 --> 00:07:50,020
actually actually use it because it's

00:07:47,169 --> 00:07:51,940
very lightweight it's very easy to drop

00:07:50,020 --> 00:07:53,680
in you know you know maybe legacy

00:07:51,940 --> 00:07:57,120
application and at the same time is

00:07:53,680 --> 00:08:01,780
performant and it's very very scalable

00:07:57,120 --> 00:08:03,940
so if you're familiar with vue.js you

00:08:01,780 --> 00:08:06,699
already know that it's option based and

00:08:03,940 --> 00:08:09,250
it actually looks like this so when we

00:08:06,699 --> 00:08:10,900
want to create an application which is

00:08:09,250 --> 00:08:13,270
simply passing on an object of

00:08:10,900 --> 00:08:15,430
properties that defines how the

00:08:13,270 --> 00:08:18,370
application behaves he finds how the

00:08:15,430 --> 00:08:20,229
application looks and this is just a

00:08:18,370 --> 00:08:22,930
typical view component or view instance

00:08:20,229 --> 00:08:25,750
that we have here and this doesn't go

00:08:22,930 --> 00:08:27,699
anywhere so if in view trail in view

00:08:25,750 --> 00:08:29,530
tree we'll continue to create our

00:08:27,699 --> 00:08:31,720
components like this with the options

00:08:29,530 --> 00:08:34,390
API that we know and Groo cost of it

00:08:31,720 --> 00:08:36,130
also we're gonna see we're gonna have to

00:08:34,390 --> 00:08:38,650
use compositor we're gonna learn about

00:08:36,130 --> 00:08:43,089
composite api which is like an

00:08:38,650 --> 00:08:46,560
alternative way of of doing this now

00:08:43,089 --> 00:08:46,560
let's talk a bit about view tree

00:08:46,770 --> 00:08:54,040
but now that we know a bit about the

00:08:50,200 --> 00:08:56,560
view and its history I think it's very

00:08:54,040 --> 00:08:58,600
important to talk about how new features

00:08:56,560 --> 00:09:00,760
are added to the framework simply

00:08:58,600 --> 00:09:03,640
because it is so much more different

00:09:00,760 --> 00:09:06,160
than how other frameworks add their

00:09:03,640 --> 00:09:08,260
features and and specifically talking

00:09:06,160 --> 00:09:12,070
here and thinking about react and

00:09:08,260 --> 00:09:14,680
angular so for example let's take an

00:09:12,070 --> 00:09:16,630
example react where it's essentially

00:09:14,680 --> 00:09:19,230
driven by the means and goals of

00:09:16,630 --> 00:09:21,790
Facebook because it's backed by Facebook

00:09:19,230 --> 00:09:25,150
angular is driven by the needs and goals

00:09:21,790 --> 00:09:28,240
of Google whereas view is driven really

00:09:25,150 --> 00:09:30,820
by the community and by by everyone that

00:09:28,240 --> 00:09:32,640
wants to that wants to contribute to

00:09:30,820 --> 00:09:35,290
this even say let's say for example

00:09:32,640 --> 00:09:37,810
google courting can propose a new

00:09:35,290 --> 00:09:40,300
feature to view but then the community

00:09:37,810 --> 00:09:42,430
really weighs in on this and drives that

00:09:40,300 --> 00:09:44,710
future and the direction of how you will

00:09:42,430 --> 00:09:48,220
will actually be in the upcoming

00:09:44,710 --> 00:09:50,350
releases a very interesting thing that

00:09:48,220 --> 00:09:52,390
that saw is in one of every news talk

00:09:50,350 --> 00:09:54,760
about design principle of view tree

00:09:52,390 --> 00:09:56,320
where you can find out go on on YouTube

00:09:54,760 --> 00:09:59,260
I think it was a couple of months posted

00:09:56,320 --> 00:10:02,650
back he explained the challenges of

00:09:59,260 --> 00:10:04,540
designing view so the core team tries to

00:10:02,650 --> 00:10:07,180
look at a multitude of use cases and

00:10:04,540 --> 00:10:09,930
provide a solution that is going to make

00:10:07,180 --> 00:10:12,490
men you can make everyone happy

00:10:09,930 --> 00:10:15,010
something that makes most of the people

00:10:12,490 --> 00:10:18,160
happy because really because really view

00:10:15,010 --> 00:10:19,930
has a very diverse audience so we might

00:10:18,160 --> 00:10:22,000
have for example beginners who are just

00:10:19,930 --> 00:10:24,190
progressing from HTML and CSS and

00:10:22,000 --> 00:10:27,160
JavaScript for looking at the first

00:10:24,190 --> 00:10:29,050
framework to jump into at the same time

00:10:27,160 --> 00:10:31,780
we might have professionals that are

00:10:29,050 --> 00:10:33,670
moving on from jQuery so they they

00:10:31,780 --> 00:10:35,710
worked on the same legacy project for

00:10:33,670 --> 00:10:38,470
many years but now they chose okay let's

00:10:35,710 --> 00:10:40,180
start using of modern framework so they

00:10:38,470 --> 00:10:43,030
might have some front-end application

00:10:40,180 --> 00:10:45,280
that had some interactivity in demand or

00:10:43,030 --> 00:10:47,260
some legacy jQuery plugins that did

00:10:45,280 --> 00:10:49,360
something that and this is now time to

00:10:47,260 --> 00:10:51,220
move on from those plugins that may be

00:10:49,360 --> 00:10:55,130
great their own interactivity in their

00:10:51,220 --> 00:10:57,170
own application at the same time we

00:10:55,130 --> 00:10:59,300
have veterans that developers that

00:10:57,170 --> 00:11:01,070
migrated got one who migrated from other

00:10:59,300 --> 00:11:03,590
frameworks we have maybe they are using

00:11:01,070 --> 00:11:05,060
react or something like amber or

00:11:03,590 --> 00:11:07,160
backbone and they want to start

00:11:05,060 --> 00:11:10,070
migrating their applications or create

00:11:07,160 --> 00:11:11,750
new applications using using view at the

00:11:10,070 --> 00:11:13,220
same time we have back at the engineers

00:11:11,750 --> 00:11:15,980
looking for a lightweight front end

00:11:13,220 --> 00:11:18,290
solution and I can speak to this heavily

00:11:15,980 --> 00:11:20,510
since I was a back there was a back-end

00:11:18,290 --> 00:11:22,310
developer most of my time and I was

00:11:20,510 --> 00:11:24,620
looking for a solution that I could

00:11:22,310 --> 00:11:26,330
easily pick up and you really struck a

00:11:24,620 --> 00:11:28,520
nerve to me out here because it has a

00:11:26,330 --> 00:11:31,790
great documentation I could easily just

00:11:28,520 --> 00:11:34,310
plug it in into my existing application

00:11:31,790 --> 00:11:36,350
we place jQuery where needed I wasn't

00:11:34,310 --> 00:11:38,930
necessarily needed to I didn't have to

00:11:36,350 --> 00:11:41,060
use the single page application I could

00:11:38,930 --> 00:11:43,130
just drop in view and start start

00:11:41,060 --> 00:11:46,280
working there it's easy to get started

00:11:43,130 --> 00:11:48,830
and I could easily add it to a page so

00:11:46,280 --> 00:11:50,870
as you can see this isn't just one room

00:11:48,830 --> 00:11:53,150
or one person that there we are

00:11:50,870 --> 00:11:57,170
they're creating futures of it's a very

00:11:53,150 --> 00:11:59,900
very diverse group so to truly

00:11:57,170 --> 00:12:02,780
understand the needs of the users and

00:11:59,900 --> 00:12:05,480
actually help them the users need to

00:12:02,780 --> 00:12:08,360
have a voice in the design process as a

00:12:05,480 --> 00:12:10,700
community driven project it is very very

00:12:08,360 --> 00:12:13,510
important for the community as well to

00:12:10,700 --> 00:12:16,430
take part in shaping the future of you

00:12:13,510 --> 00:12:19,040
so that's why the view core team adopted

00:12:16,430 --> 00:12:22,520
an open NRC so which stands for request

00:12:19,040 --> 00:12:24,470
for comments process and in this github

00:12:22,520 --> 00:12:27,980
link there is the list of all of the

00:12:24,470 --> 00:12:31,070
active practices if you look this is

00:12:27,980 --> 00:12:33,320
basically a list of activities which we

00:12:31,070 --> 00:12:36,140
are looking here and if you go to if you

00:12:33,320 --> 00:12:38,660
go to github future slash services there

00:12:36,140 --> 00:12:40,640
are all the proposals there and inside

00:12:38,660 --> 00:12:42,860
there is a folder with active viruses

00:12:40,640 --> 00:12:44,780
and this is the group of features that

00:12:42,860 --> 00:12:47,630
are going into the next version of you

00:12:44,780 --> 00:12:49,460
so currently this is 3.0 but when the

00:12:47,630 --> 00:12:51,970
next version will be actor 3.0

00:12:49,460 --> 00:12:54,080
there's going to be there as well so

00:12:51,970 --> 00:12:55,880
absolutely everyone that does this kind

00:12:54,080 --> 00:12:58,010
of presentation that talks about the

00:12:55,880 --> 00:12:59,240
next version of view or what we can

00:12:58,010 --> 00:13:00,980
expect in the future

00:12:59,240 --> 00:13:03,410
will heavily rely on this information

00:13:00,980 --> 00:13:05,120
from this error sees as well as

00:13:03,410 --> 00:13:07,920
talks from Avenue or from someone from

00:13:05,120 --> 00:13:09,660
the core team and one

00:13:07,920 --> 00:13:11,940
every good thing about these services is

00:13:09,660 --> 00:13:14,550
that they give out an amazing level of

00:13:11,940 --> 00:13:17,459
details and explain how this new feature

00:13:14,550 --> 00:13:21,149
would look so here for example we have

00:13:17,459 --> 00:13:25,470
the composition API and it starts with a

00:13:21,149 --> 00:13:27,000
summary and basic example and what a lot

00:13:25,470 --> 00:13:29,070
of these rusticated arrises that is

00:13:27,000 --> 00:13:31,529
based on a template so if you want to

00:13:29,070 --> 00:13:34,880
create your own ever see you can simply

00:13:31,529 --> 00:13:38,250
just start from a template and start

00:13:34,880 --> 00:13:40,769
describing it you need to explain what

00:13:38,250 --> 00:13:44,639
this is going to do you need to explain

00:13:40,769 --> 00:13:47,820
you need to give a basic example and for

00:13:44,639 --> 00:13:50,040
me the motivation of a new error see is

00:13:47,820 --> 00:13:52,170
what really helps me understand why this

00:13:50,040 --> 00:13:53,850
feature is getting added to it so even

00:13:52,170 --> 00:13:56,850
though for example I didn't understand

00:13:53,850 --> 00:13:59,250
initially from the summary the

00:13:56,850 --> 00:14:02,010
motivation really drives a new feature

00:13:59,250 --> 00:14:04,889
more in my opinion so there needs to be

00:14:02,010 --> 00:14:07,320
some motivation behind these features as

00:14:04,889 --> 00:14:10,290
well as maybe detailed design specs

00:14:07,320 --> 00:14:12,420
widely chose a specific rod what are the

00:14:10,290 --> 00:14:15,390
drawbacks the alternatives and the

00:14:12,420 --> 00:14:17,070
adoption strategy so again if you are

00:14:15,390 --> 00:14:19,140
very interested in to looking what's

00:14:17,070 --> 00:14:21,180
going on in any feature version of you

00:14:19,140 --> 00:14:27,269
just this is definitely the best place

00:14:21,180 --> 00:14:30,360
to start so let's talk about the

00:14:27,269 --> 00:14:33,209
performance improvements there are

00:14:30,360 --> 00:14:36,120
actually two big categories here we're

00:14:33,209 --> 00:14:39,829
going to talk about so performance needs

00:14:36,120 --> 00:14:42,149
to be about making the libraries smaller

00:14:39,829 --> 00:14:44,399
so that it dollars faster the entire

00:14:42,149 --> 00:14:45,089
source could actually be as small as

00:14:44,399 --> 00:14:48,480
possible

00:14:45,089 --> 00:14:50,160
and at the same time we as fast as

00:14:48,480 --> 00:14:52,769
possible with the interactions with the

00:14:50,160 --> 00:14:55,380
fifth or Tom and whatever so let's talk

00:14:52,769 --> 00:14:58,290
about the smaller part so one of the

00:14:55,380 --> 00:15:01,110
distinguished features of using it was

00:14:58,290 --> 00:15:02,579
also it was created this is actually the

00:15:01,110 --> 00:15:05,279
framework it's actually the frame upside

00:15:02,579 --> 00:15:06,540
so currently last time I checked a

00:15:05,279 --> 00:15:09,089
couple of days ago the last version

00:15:06,540 --> 00:15:13,800
needs around 33 kilobytes with meaning

00:15:09,089 --> 00:15:16,290
between us jace it and in view 3 the

00:15:13,800 --> 00:15:18,839
codebase is developed from scribble from

00:15:16,290 --> 00:15:20,880
scratch and promises to be tree shaking

00:15:18,839 --> 00:15:24,509
friendly so we are going to talk

00:15:20,880 --> 00:15:27,300
this next as well so we expect view tree

00:15:24,509 --> 00:15:30,060
to be under 10 kilobytes and which is

00:15:27,300 --> 00:15:32,910
absolutely incredible to think about but

00:15:30,060 --> 00:15:34,500
this is to be achieved by elimination of

00:15:32,910 --> 00:15:36,990
those libraries that we are not using

00:15:34,500 --> 00:15:38,550
libraries of necessary features that you

00:15:36,990 --> 00:15:41,069
are not using so let's say for example

00:15:38,550 --> 00:15:43,050
if we have an application where simply

00:15:41,069 --> 00:15:45,779
we are not using people live component

00:15:43,050 --> 00:15:48,930
or translation component then by the

00:15:45,779 --> 00:15:50,880
compiler and with everything the because

00:15:48,930 --> 00:15:53,040
of tree shaking we are not that those

00:15:50,880 --> 00:15:54,569
features would not be added so let's

00:15:53,040 --> 00:15:59,519
talk about the three shakable source

00:15:54,569 --> 00:16:02,910
code the idea here is the idea here is

00:15:59,519 --> 00:16:06,209
to make views runtime tree shakable by

00:16:02,910 --> 00:16:09,480
exposing as much as the core API to

00:16:06,209 --> 00:16:10,319
named experts as possible so you is much

00:16:09,480 --> 00:16:13,920
much smaller

00:16:10,319 --> 00:16:16,410
thanks to this approach so the

00:16:13,920 --> 00:16:18,990
motivation between the motivation and

00:16:16,410 --> 00:16:22,680
actually dilemma of view - and what

00:16:18,990 --> 00:16:25,350
drove this feature it was as we looked

00:16:22,680 --> 00:16:26,310
at the history of you earlier and how it

00:16:25,350 --> 00:16:29,189
continued to grow

00:16:26,310 --> 00:16:31,319
years over the years we have to think a

00:16:29,189 --> 00:16:34,380
bit about some the other aspect of

00:16:31,319 --> 00:16:35,910
things as as the view API grows the view

00:16:34,380 --> 00:16:38,100
core team are constantly trying to

00:16:35,910 --> 00:16:40,139
balance the trade-offs between ok we're

00:16:38,100 --> 00:16:42,209
adding more features because there is

00:16:40,139 --> 00:16:44,610
demand for them but at the same time the

00:16:42,209 --> 00:16:47,250
bundle size starts to grow up so they

00:16:44,610 --> 00:16:49,769
want to keep view size overhead to a

00:16:47,250 --> 00:16:51,959
minimum but at the same time they will

00:16:49,769 --> 00:16:54,000
also want to limit its capacity they

00:16:51,959 --> 00:16:55,949
also don't want to limit its capacity

00:16:54,000 --> 00:16:58,350
because of the size constraints so this

00:16:55,949 --> 00:17:01,589
always this balancing act ok are we

00:16:58,350 --> 00:17:04,169
adding how are you adding this so it es

00:17:01,589 --> 00:17:07,199
modules modern bundles and combined with

00:17:04,169 --> 00:17:09,449
minifiers we can now eliminate es

00:17:07,199 --> 00:17:11,699
modules exports that are not being used

00:17:09,449 --> 00:17:13,530
anywhere in the bundle so this means

00:17:11,699 --> 00:17:16,350
that during the rewrite they were able

00:17:13,530 --> 00:17:18,780
to restructure the views global as well

00:17:16,350 --> 00:17:21,809
as internally we have to take advantage

00:17:18,780 --> 00:17:23,579
of this so that users only pay or only

00:17:21,809 --> 00:17:25,780
use the features that they actually

00:17:23,579 --> 00:17:28,520
actually using in the code

00:17:25,780 --> 00:17:30,260
so in addition knowing that option

00:17:28,520 --> 00:17:32,480
features aren't going to increase the

00:17:30,260 --> 00:17:34,460
bundle size so adding new features it

00:17:32,480 --> 00:17:37,100
doesn't necessarily increase the bundle

00:17:34,460 --> 00:17:39,320
size the core team has a much more much

00:17:37,100 --> 00:17:43,070
more room to include features going

00:17:39,320 --> 00:17:45,320
forward so finally we are reaching what

00:17:43,070 --> 00:17:47,990
does this actually mean to us as

00:17:45,320 --> 00:17:51,200
developers as how we are using view

00:17:47,990 --> 00:17:54,800
going forward so it means that in view

00:17:51,200 --> 00:17:57,350
tree we have to use many imports only if

00:17:54,800 --> 00:17:59,960
we look here for example if we look at

00:17:57,350 --> 00:18:02,120
view two we import view from view and

00:17:59,960 --> 00:18:04,490
then we can do whatever we want because

00:18:02,120 --> 00:18:06,350
we have the global API level we can use

00:18:04,490 --> 00:18:09,260
view next stick we can use be observable

00:18:06,350 --> 00:18:11,570
nothing stops us from using the absolute

00:18:09,260 --> 00:18:14,630
all the API that we have available in

00:18:11,570 --> 00:18:16,730
view but with view three we have to be

00:18:14,630 --> 00:18:18,890
very specific about what we are

00:18:16,730 --> 00:18:21,290
importing into the into our application

00:18:18,890 --> 00:18:23,870
so for example if we try to import just

00:18:21,290 --> 00:18:26,210
view and called next stick on it it will

00:18:23,870 --> 00:18:28,850
simply not work we have to import next

00:18:26,210 --> 00:18:32,330
it and observable in this in this case

00:18:28,850 --> 00:18:35,150
from view and then go ahead and use them

00:18:32,330 --> 00:18:38,060
so this is another this is one big

00:18:35,150 --> 00:18:40,220
change that will need to be aware from a

00:18:38,060 --> 00:18:41,930
migration stamp from a migration point

00:18:40,220 --> 00:18:44,150
of view we're gonna have to import

00:18:41,930 --> 00:18:51,230
everything and be very careful about

00:18:44,150 --> 00:18:53,540
what we are importing and in the CDN

00:18:51,230 --> 00:18:56,450
build this feature will also be bundled

00:18:53,540 --> 00:18:59,120
so there is no way around that with es

00:18:56,450 --> 00:19:00,890
modules and with modern bundles we can

00:18:59,120 --> 00:19:02,840
now eliminate all of these modules like

00:19:00,890 --> 00:19:06,350
for example keepalive transition v-model

00:19:02,840 --> 00:19:08,600
or suspects what is also interesting in

00:19:06,350 --> 00:19:10,790
these situations that even the compiler

00:19:08,600 --> 00:19:13,460
will generate three shakable source code

00:19:10,790 --> 00:19:18,260
in the tab in the tempest that that we

00:19:13,460 --> 00:19:20,330
write so in this situation we have the

00:19:18,260 --> 00:19:24,480
rather front so let's say for example in

00:19:20,330 --> 00:19:25,600
our template we have an input type text

00:19:24,480 --> 00:19:29,390
[Music]

00:19:25,600 --> 00:19:32,300
we will compile the generated code into

00:19:29,390 --> 00:19:34,280
a render function and we can see that we

00:19:32,300 --> 00:19:36,950
can see that in this situation it will

00:19:34,280 --> 00:19:38,850
only import the model text because we

00:19:36,950 --> 00:19:41,919
are only using the

00:19:38,850 --> 00:19:44,169
but if for example would use the chat

00:19:41,919 --> 00:19:48,220
box it will just import the v-model chat

00:19:44,169 --> 00:19:50,890
box that again will help a lot with

00:19:48,220 --> 00:19:56,350
getting the size down off of the entire

00:19:50,890 --> 00:20:00,130
bundle source code so a huge part of u3

00:19:56,350 --> 00:20:02,740
was making it faster and more efficient

00:20:00,130 --> 00:20:06,429
and in fact according to every news talk

00:20:02,740 --> 00:20:07,990
at you constantly internal tests have

00:20:06,429 --> 00:20:10,690
shown that the template styling view

00:20:07,990 --> 00:20:13,600
tree is now approximately 120 percent

00:20:10,690 --> 00:20:15,549
faster than view 2 and there were

00:20:13,600 --> 00:20:18,240
actually two key optimizations that

00:20:15,549 --> 00:20:20,590
helps improve view tree rendering speed

00:20:18,240 --> 00:20:22,510
so we have the block to optimizations

00:20:20,590 --> 00:20:26,980
and we have distracted

00:20:22,510 --> 00:20:28,960
static tree hosting and yeah let's talk

00:20:26,980 --> 00:20:33,100
about beautto dome and render function

00:20:28,960 --> 00:20:38,080
so many JavaScript frameworks like view

00:20:33,100 --> 00:20:40,299
or amber or we have rank implement what

00:20:38,080 --> 00:20:46,299
is called a virtual Dom so what exactly

00:20:40,299 --> 00:20:47,980
is we I won't get into much a lot

00:20:46,299 --> 00:20:49,540
engineering talk about virtual Dom you

00:20:47,980 --> 00:20:51,760
can search that a lot and on the

00:20:49,540 --> 00:20:55,059
internet but its main purpose is to

00:20:51,760 --> 00:20:58,270
increase the speed and efficiency of the

00:20:55,059 --> 00:21:00,220
Dom updates that will have to do so when

00:20:58,270 --> 00:21:03,100
we use JavaScript to make a change to

00:21:00,220 --> 00:21:05,410
our page the browser has to be to the

00:21:03,100 --> 00:21:07,059
rest has to dive deep into the DOM and

00:21:05,410 --> 00:21:09,580
get the necessary elements that we want

00:21:07,059 --> 00:21:12,790
for example for using don't get element

00:21:09,580 --> 00:21:16,000
by ID the browser has to get getting the

00:21:12,790 --> 00:21:17,679
Dom get it up so in modern apps there

00:21:16,000 --> 00:21:20,320
can be thousands of nodes in the dome

00:21:17,679 --> 00:21:21,510
and updated can be computationally very

00:21:20,320 --> 00:21:24,580
very expensive

00:21:21,510 --> 00:21:27,160
it's absolutely inevitable that small

00:21:24,580 --> 00:21:30,100
and frequent updates directly to the Dom

00:21:27,160 --> 00:21:32,830
will slow the pace down so if you

00:21:30,100 --> 00:21:35,020
accomplish this by by updates by

00:21:32,830 --> 00:21:37,270
building a little Dom to keep track of

00:21:35,020 --> 00:21:44,260
all of the changes it needs to make the

00:21:37,270 --> 00:21:47,169
real so now that we know a little bit

00:21:44,260 --> 00:21:50,050
about how virtual Dom works let's talk

00:21:47,169 --> 00:21:52,150
about what's changing in v1

00:21:50,050 --> 00:21:54,310
you stake on it so there's a bunch of

00:21:52,150 --> 00:21:56,670
performance improvements here but I'm

00:21:54,310 --> 00:21:59,170
not basically going to talk just the

00:21:56,670 --> 00:22:01,840
biggest one that I think see because I

00:21:59,170 --> 00:22:03,820
understand it the best so everyone has a

00:22:01,840 --> 00:22:06,460
bunch of talks online about this and if

00:22:03,820 --> 00:22:09,070
you really want to get more accustomed

00:22:06,460 --> 00:22:10,960
to it there's and what exactly what

00:22:09,070 --> 00:22:12,940
changes exactly in the virtual Dom I

00:22:10,960 --> 00:22:14,680
will check those out because he

00:22:12,940 --> 00:22:16,090
definitely knows way more than I tried

00:22:14,680 --> 00:22:19,860
there are some really really interesting

00:22:16,090 --> 00:22:22,630
talks about chain about these changes so

00:22:19,860 --> 00:22:25,300
knowing the virtual Dom knowing how it

00:22:22,630 --> 00:22:28,440
works no it's because it's improving the

00:22:25,300 --> 00:22:30,850
speed of how we are working with the Dom

00:22:28,440 --> 00:22:33,490
what are the bottlenecks of a

00:22:30,850 --> 00:22:35,890
traditional virtual Dom because you

00:22:33,490 --> 00:22:37,930
already addresses this and dresses the

00:22:35,890 --> 00:22:40,050
bottlenecks at a very high level problem

00:22:37,930 --> 00:22:42,670
by making sure that each component

00:22:40,050 --> 00:22:45,580
reactively tracks their own dependencies

00:22:42,670 --> 00:22:47,730
and only updates when needed so for

00:22:45,580 --> 00:22:50,950
example across the application if

00:22:47,730 --> 00:22:53,380
component a changes it doesn't need to

00:22:50,950 --> 00:22:55,420
change or diff absolutely every other

00:22:53,380 --> 00:22:57,330
component in the application it only

00:22:55,420 --> 00:23:00,580
needs to do that at the component level

00:22:57,330 --> 00:23:03,490
but the problem here is that inside each

00:23:00,580 --> 00:23:05,890
component it is still a full virtual

00:23:03,490 --> 00:23:08,080
don't--if using the traditional condom

00:23:05,890 --> 00:23:09,700
algorithm inside the component we still

00:23:08,080 --> 00:23:12,610
have to do absolutely everything and

00:23:09,700 --> 00:23:15,100
absolutely check everything that changes

00:23:12,610 --> 00:23:17,200
so observing is dependencies is very

00:23:15,100 --> 00:23:19,150
slow because it recursively checks the

00:23:17,200 --> 00:23:23,620
whole element tree to detect those

00:23:19,150 --> 00:23:26,560
changes so as we can see here in view to

00:23:23,620 --> 00:23:28,840
if if there is some little don't changes

00:23:26,560 --> 00:23:31,270
that we need to do you would start doing

00:23:28,840 --> 00:23:32,350
the beef on the beef it will check the

00:23:31,270 --> 00:23:34,000
props of the beef

00:23:32,350 --> 00:23:36,640
it will check the children of the Dave

00:23:34,000 --> 00:23:38,740
and then each element the paragraph the

00:23:36,640 --> 00:23:40,960
props of paragraph and everything there

00:23:38,740 --> 00:23:43,960
and it repeats and times depending how

00:23:40,960 --> 00:23:45,760
how big the source code is and if we're

00:23:43,960 --> 00:23:47,860
thinking about it the smart way to

00:23:45,760 --> 00:23:49,900
update the reactive variables would be

00:23:47,860 --> 00:23:53,710
to just simply look at the template so

00:23:49,900 --> 00:23:57,400
for example one thing that view team

00:23:53,710 --> 00:24:00,310
noticed was that in components much of a

00:23:57,400 --> 00:24:03,860
node structure was actually static so if

00:24:00,310 --> 00:24:06,140
we look if for example was in for if

00:24:03,860 --> 00:24:09,529
but a particular node was in fact

00:24:06,140 --> 00:24:11,510
dynamic because of a V if or before

00:24:09,529 --> 00:24:14,330
directive and a lot of the content

00:24:11,510 --> 00:24:17,299
inside that that partition was actually

00:24:14,330 --> 00:24:19,000
static so you think this idea of you

00:24:17,299 --> 00:24:22,370
treat partitions the template into

00:24:19,000 --> 00:24:24,380
static versus dynamic sections so that

00:24:22,370 --> 00:24:27,289
now the renderer knows when those are

00:24:24,380 --> 00:24:29,809
dynamic and what knows will never change

00:24:27,289 --> 00:24:32,210
it doesn't waste time checking static

00:24:29,809 --> 00:24:34,070
nodes for changes but this greatly

00:24:32,210 --> 00:24:37,580
reduces the number of elements that need

00:24:34,070 --> 00:24:39,559
to be rapidly washed so combining all of

00:24:37,580 --> 00:24:41,210
these nodes creates actually what is

00:24:39,559 --> 00:24:43,669
called a block tree that's why we are

00:24:41,210 --> 00:24:45,860
calling it block to optimization or a

00:24:43,669 --> 00:24:48,230
template divided need not blocks based

00:24:45,860 --> 00:24:51,409
on the record so for example vdf and key

00:24:48,230 --> 00:24:53,480
for so if you're looking back at the

00:24:51,409 --> 00:24:55,870
template at the section that we checked

00:24:53,480 --> 00:24:59,570
before now it's very easy because

00:24:55,870 --> 00:25:01,940
because we will just simply check i just

00:24:59,570 --> 00:25:03,710
know that the paragraph has the we give

00:25:01,940 --> 00:25:06,110
directive so we need to check that and

00:25:03,710 --> 00:25:08,659
then inside the v if you just have one

00:25:06,110 --> 00:25:12,190
span that has a message and I'll need to

00:25:08,659 --> 00:25:15,919
check I need to give that one up and

00:25:12,190 --> 00:25:17,990
like a previously told in one of my News

00:25:15,919 --> 00:25:20,779
presentation they did a test of about a

00:25:17,990 --> 00:25:23,179
thousand V for iterations and each

00:25:20,779 --> 00:25:25,429
iteration had run twelve Dom elements

00:25:23,179 --> 00:25:27,799
class bindings text interpolations and

00:25:25,429 --> 00:25:30,380
they compared performance of view to

00:25:27,799 --> 00:25:31,669
with view tree and they stopped between

00:25:30,380 --> 00:25:33,860
a hundred and twenty and a hundred

00:25:31,669 --> 00:25:38,120
thirty performance of percent

00:25:33,860 --> 00:25:40,250
performance improvements overview - the

00:25:38,120 --> 00:25:43,039
best part about this is that we don't

00:25:40,250 --> 00:25:45,500
have to do absolutely anything except

00:25:43,039 --> 00:25:48,620
upgrading our code to use v3 but that's

00:25:45,500 --> 00:25:50,570
really easy for us to just okay if we

00:25:48,620 --> 00:25:51,679
are already to v3 we're gonna definitely

00:25:50,570 --> 00:25:54,679
have some performance improvements

00:25:51,679 --> 00:25:57,350
without actually missing out or anything

00:25:54,679 --> 00:26:01,570
or putting the hours of adapting forty

00:25:57,350 --> 00:26:01,570
specific for this specific needs

00:26:03,130 --> 00:26:09,740
let's talk about the reactivity system

00:26:05,600 --> 00:26:12,350
which is the core of UGS is necessary

00:26:09,740 --> 00:26:14,810
that data is able to have dependencies

00:26:12,350 --> 00:26:17,060
we need to observe those dependencies

00:26:14,810 --> 00:26:19,010
and as well as update to reflect any

00:26:17,060 --> 00:26:21,080
changes that happen in in the

00:26:19,010 --> 00:26:23,060
application so let's take a look at the

00:26:21,080 --> 00:26:26,990
reactivity change detection systems and

00:26:23,060 --> 00:26:30,220
a few caveats in view to that we'll go

00:26:26,990 --> 00:26:32,990
that would finally go away in impute 3

00:26:30,220 --> 00:26:35,000
so here we have a template with an h1

00:26:32,990 --> 00:26:36,860
element and inside there we are

00:26:35,000 --> 00:26:39,610
displaying the title so here we have a

00:26:36,860 --> 00:26:41,600
data function that returns an object and

00:26:39,610 --> 00:26:44,540
inside of it we have a property called

00:26:41,600 --> 00:26:47,210
title that title property is reactive

00:26:44,540 --> 00:26:50,390
cause it is where we declared it inside

00:26:47,210 --> 00:26:52,430
the data so this is a reactive data

00:26:50,390 --> 00:26:54,680
property which means that if we're going

00:26:52,430 --> 00:26:59,630
to run this we'll actually get what we

00:26:54,680 --> 00:27:01,690
actually get what we expect and at the

00:26:59,630 --> 00:27:04,430
same time if you modify this property

00:27:01,690 --> 00:27:06,800
using console abusing of your dev tools

00:27:04,430 --> 00:27:09,440
the output will refract the new value

00:27:06,800 --> 00:27:13,280
that for example we change we change it

00:27:09,440 --> 00:27:15,170
to a hello everyone it will automatic so

00:27:13,280 --> 00:27:17,450
this is actually the heart of view it's

00:27:15,170 --> 00:27:20,660
the reactive system and this works very

00:27:17,450 --> 00:27:22,610
very well in most of the cases until it

00:27:20,660 --> 00:27:26,750
actually doesn't so there are a few

00:27:22,610 --> 00:27:28,220
cases where you are gonna waste a couple

00:27:26,750 --> 00:27:29,960
of hours you're gonna scratch your head

00:27:28,220 --> 00:27:31,850
I'm gonna think about why this

00:27:29,960 --> 00:27:35,540
particular case doesn't work when

00:27:31,850 --> 00:27:37,310
everything else synching works and these

00:27:35,540 --> 00:27:40,280
particular cases these particular carry

00:27:37,310 --> 00:27:42,500
ons are so important that there is a

00:27:40,280 --> 00:27:44,510
specific page in the view documentation

00:27:42,500 --> 00:27:46,550
about them I think it's a reactive

00:27:44,510 --> 00:27:49,070
reactivity in depth or something like

00:27:46,550 --> 00:27:51,230
that but within the documentation they

00:27:49,070 --> 00:27:54,850
specifically specifically talk about

00:27:51,230 --> 00:27:59,450
them and run how we can work around them

00:27:54,850 --> 00:28:03,470
so how exactly you to track track

00:27:59,450 --> 00:28:05,690
changes in in the data objects view goes

00:28:03,470 --> 00:28:07,700
in and gets the data object that is

00:28:05,690 --> 00:28:09,290
returned from a component and walks

00:28:07,700 --> 00:28:11,170
through all of the data object

00:28:09,290 --> 00:28:14,680
properties and as

00:28:11,170 --> 00:28:17,980
and satyrs using object defined property

00:28:14,680 --> 00:28:20,740
and objectified property is is an es5

00:28:17,980 --> 00:28:22,780
only and it's on shippable feature so

00:28:20,740 --> 00:28:25,240
which is why view doesn't support even

00:28:22,780 --> 00:28:28,720
version 2.0 it doesn't support ea8 and

00:28:25,240 --> 00:28:30,940
below so let's talk about the reactive

00:28:28,720 --> 00:28:33,490
data so we declare some properties here

00:28:30,940 --> 00:28:35,260
in our return object and from our data

00:28:33,490 --> 00:28:37,270
function so we declare first name and

00:28:35,260 --> 00:28:40,360
last name this is works exactly the same

00:28:37,270 --> 00:28:41,980
as as we expected because we declare the

00:28:40,360 --> 00:28:44,110
properties in the return object and

00:28:41,980 --> 00:28:47,680
everything is it's reactive we don't

00:28:44,110 --> 00:28:51,310
have any issues here but now let's say

00:28:47,680 --> 00:28:53,410
for example we move the we we don't

00:28:51,310 --> 00:28:55,300
initialize the first name we move it to

00:28:53,410 --> 00:28:57,370
the created function so let's say we

00:28:55,300 --> 00:28:59,230
don't initialize the first name in the

00:28:57,370 --> 00:29:00,940
data object but later on in the

00:28:59,230 --> 00:29:04,990
application we actually want to use it

00:29:00,940 --> 00:29:07,240
so this kind of works in that if you're

00:29:04,990 --> 00:29:09,220
gonna do if you're going to run this now

00:29:07,240 --> 00:29:10,810
in the browser it will actually show the

00:29:09,220 --> 00:29:13,780
first name and last name and you'll see

00:29:10,810 --> 00:29:18,190
ok this works but the problem here is

00:29:13,780 --> 00:29:21,130
that the first name isn't reactive so it

00:29:18,190 --> 00:29:23,140
works but when you are modifying it if

00:29:21,130 --> 00:29:25,270
you are trying to change the first name

00:29:23,140 --> 00:29:27,490
that wouldn't get updated is not done

00:29:25,270 --> 00:29:30,520
because it's not declared in the data

00:29:27,490 --> 00:29:32,320
and view simply has no idea that it

00:29:30,520 --> 00:29:35,980
actually needs to look after it so it's

00:29:32,320 --> 00:29:38,770
it's not reacted one very easy way to

00:29:35,980 --> 00:29:40,840
fix this is to declare or initialize the

00:29:38,770 --> 00:29:43,570
first name variable in the return object

00:29:40,840 --> 00:29:45,880
into an into an empty string then you

00:29:43,570 --> 00:29:48,400
will know to track that variable and

00:29:45,880 --> 00:29:50,230
every time we updated for example in

00:29:48,400 --> 00:29:52,180
this life cycle book we can update it

00:29:50,230 --> 00:29:56,890
and the new information will actually be

00:29:52,180 --> 00:29:58,900
reflected in so knowing that let's talk

00:29:56,890 --> 00:30:03,400
about the object properties caveat seen

00:29:58,900 --> 00:30:06,490
in two point in two points or six one

00:30:03,400 --> 00:30:08,650
that is very very similar to the

00:30:06,490 --> 00:30:10,720
variables is to the various example that

00:30:08,650 --> 00:30:14,380
I added was adding or removing

00:30:10,720 --> 00:30:17,440
properties to an object so view does not

00:30:14,380 --> 00:30:19,840
allow to dynamically add new dynamic

00:30:17,440 --> 00:30:23,380
properties for already created instance

00:30:19,840 --> 00:30:24,400
however it is possible to add reactive

00:30:23,380 --> 00:30:26,860
properties if we

00:30:24,400 --> 00:30:28,570
you want to into a nested object by

00:30:26,860 --> 00:30:30,880
using a specialized method that we're

00:30:28,570 --> 00:30:34,330
going to talk about so as we can see

00:30:30,880 --> 00:30:35,890
here we have a return object and inside

00:30:34,330 --> 00:30:38,980
that object we have a book object with

00:30:35,890 --> 00:30:40,780
name on to the price so and we are

00:30:38,980 --> 00:30:43,660
displaying all of these in our template

00:30:40,780 --> 00:30:46,930
the convoy will also have a we also have

00:30:43,660 --> 00:30:50,260
a computed property which calculates the

00:30:46,930 --> 00:30:54,640
total price which is which is quantity x

00:30:50,260 --> 00:30:56,620
times price so what if we - the price

00:30:54,640 --> 00:30:58,600
out of the book object and move it down

00:30:56,620 --> 00:31:00,640
until created or in the created life

00:30:58,600 --> 00:31:02,740
cycle cool this is the exact same

00:31:00,640 --> 00:31:04,750
example that we saw with the first time

00:31:02,740 --> 00:31:07,120
and last name and this is going to work

00:31:04,750 --> 00:31:09,040
the first time because it's a new of

00:31:07,120 --> 00:31:11,260
it's a new property it's gonna be

00:31:09,040 --> 00:31:13,180
displayed there but every time you're

00:31:11,260 --> 00:31:15,280
updating the price every time we are

00:31:13,180 --> 00:31:19,600
updating the property it will not be

00:31:15,280 --> 00:31:22,180
reflected this issue also this also

00:31:19,600 --> 00:31:24,130
creates a side effect in that the total

00:31:22,180 --> 00:31:26,320
price will not be calculated because

00:31:24,130 --> 00:31:28,750
would not be updated with the new value

00:31:26,320 --> 00:31:31,540
because again view has no idea where to

00:31:28,750 --> 00:31:34,410
look that it needs to follow it needs to

00:31:31,540 --> 00:31:37,690
look into it needs to follow the new

00:31:34,410 --> 00:31:39,520
price so we can of course initialize the

00:31:37,690 --> 00:31:43,120
price in the book object and then update

00:31:39,520 --> 00:31:45,340
it once we have the new value or we can

00:31:43,120 --> 00:31:47,080
simply use view set or view delete if

00:31:45,340 --> 00:31:48,880
you want to delete something so instead

00:31:47,080 --> 00:31:51,370
of initializing it and set it in the

00:31:48,880 --> 00:31:53,710
created function we can call view set

00:31:51,370 --> 00:31:56,320
and you're saying the property we say

00:31:53,710 --> 00:31:58,840
okay view please follow the price

00:31:56,320 --> 00:32:01,870
property of the book and initialize it

00:31:58,840 --> 00:32:03,520
with with this price and this one is

00:32:01,870 --> 00:32:06,970
just fine it's been done for many years

00:32:03,520 --> 00:32:09,700
now same thing applies to erase if you

00:32:06,970 --> 00:32:11,770
want to modify it erase directly but

00:32:09,700 --> 00:32:14,650
their indexes instead of using modifier

00:32:11,770 --> 00:32:17,620
functions like push it will not trigger

00:32:14,650 --> 00:32:19,600
any reaction any reactivity action same

00:32:17,620 --> 00:32:21,610
with modifying array length direct

00:32:19,600 --> 00:32:23,860
reason it's interesting especially with

00:32:21,610 --> 00:32:25,480
arrays in that if you're using if you

00:32:23,860 --> 00:32:27,870
are having instead of book you have you

00:32:25,480 --> 00:32:31,260
have an array and if you are saying

00:32:27,870 --> 00:32:34,720
array push a new value it actually works

00:32:31,260 --> 00:32:37,300
but it works because we will inject some

00:32:34,720 --> 00:32:37,570
observable actions into specific into

00:32:37,300 --> 00:32:39,850
all

00:32:37,570 --> 00:32:41,950
these rate functions so it knows that

00:32:39,850 --> 00:32:44,380
when you are using is function zeros

00:32:41,950 --> 00:32:46,030
okay I actually add a new value to this

00:32:44,380 --> 00:32:48,670
array I need to follow this I need to

00:32:46,030 --> 00:32:50,950
update everything that I need but if you

00:32:48,670 --> 00:32:52,750
are calling it directly by the key you

00:32:50,950 --> 00:32:56,410
has no idea about it and it will simply

00:32:52,750 --> 00:32:58,990
not not update anything so with view

00:32:56,410 --> 00:33:00,910
tree is going to adapt to a new proxy

00:32:58,990 --> 00:33:03,730
based observation mechanism for

00:33:00,910 --> 00:33:07,000
detecting and observer observing the

00:33:03,730 --> 00:33:09,520
changes that are happening in view so

00:33:07,000 --> 00:33:11,620
since the proxy based observations there

00:33:09,520 --> 00:33:13,720
is only a big that there's a big issue

00:33:11,620 --> 00:33:15,730
here in that since the proxy latest

00:33:13,720 --> 00:33:19,600
observations aren't compatible and can

00:33:15,730 --> 00:33:21,310
be transferred for e 11 there is

00:33:19,600 --> 00:33:24,850
actually a second bill that will be

00:33:21,310 --> 00:33:27,820
available for developers that need to

00:33:24,850 --> 00:33:30,040
target EA 11 and this particular build

00:33:27,820 --> 00:33:33,460
will continue to use view object define

00:33:30,040 --> 00:33:35,500
API but again it will result in having

00:33:33,460 --> 00:33:38,410
the same happy access to as we discussed

00:33:35,500 --> 00:33:40,000
before so again with with the core team

00:33:38,410 --> 00:33:42,780
they have to think about everything so

00:33:40,000 --> 00:33:45,760
what if what if someone needs to track

00:33:42,780 --> 00:33:47,560
e11 ok we're going to create a separate

00:33:45,760 --> 00:33:49,510
separate build for them they can simply

00:33:47,560 --> 00:33:52,450
use a drop-in replacement there and

00:33:49,510 --> 00:33:56,260
that's that but if you're not targeting

00:33:52,450 --> 00:33:58,690
the EI 11 you will be moving to a proxy

00:33:56,260 --> 00:34:00,190
based change detection system and again

00:33:58,690 --> 00:34:02,740
you don't have to do absolutely anything

00:34:00,190 --> 00:34:05,650
you get a hundred percent faster and

00:34:02,740 --> 00:34:07,660
half the memory you memory usage in the

00:34:05,650 --> 00:34:10,360
application which is actually amazing to

00:34:07,660 --> 00:34:11,590
think about it and at the same time we

00:34:10,360 --> 00:34:13,780
can say goodbye to the reactivity

00:34:11,590 --> 00:34:14,500
calculus like for example like we'll

00:34:13,780 --> 00:34:16,690
like we talked about

00:34:14,500 --> 00:34:18,790
you can set an array item by it it's

00:34:16,690 --> 00:34:20,620
indexed you can set an array object by

00:34:18,790 --> 00:34:23,050
its key everything would work for now

00:34:20,620 --> 00:34:25,240
and so again just the way the

00:34:23,050 --> 00:34:28,180
directivity system changes in view tree

00:34:25,240 --> 00:34:29,560
it helps us to get rid of the caveats

00:34:28,180 --> 00:34:32,230
and we don't have to do absolutely

00:34:29,560 --> 00:34:36,300
anything I'll say that we are increasing

00:34:32,230 --> 00:34:36,300
the performance of our application

00:34:38,640 --> 00:34:43,440
introduced

00:34:39,690 --> 00:34:45,359
the composition API so this is by far

00:34:43,440 --> 00:34:48,389
the well-known change coming in view

00:34:45,359 --> 00:34:51,690
tree and it is by far the most talked

00:34:48,389 --> 00:34:53,609
about the most expected the one that

00:34:51,690 --> 00:34:57,480
created a lot of controversies the

00:34:53,609 --> 00:34:59,660
controversies and in theory it should

00:34:57,480 --> 00:35:03,510
help with code organizations and

00:34:59,660 --> 00:35:07,050
usability so correctly if you've done

00:35:03,510 --> 00:35:09,510
any work in view like you've been using

00:35:07,050 --> 00:35:12,000
what is called an option api's the

00:35:09,510 --> 00:35:14,130
options api organizes the code by

00:35:12,000 --> 00:35:15,960
property so you have data you have

00:35:14,130 --> 00:35:19,109
computer properties you have methods and

00:35:15,960 --> 00:35:22,170
so on and so forth I think one of the

00:35:19,109 --> 00:35:24,089
biggest questions that developers were

00:35:22,170 --> 00:35:26,250
asking about the composition API was

00:35:24,089 --> 00:35:29,190
when it was presented and we it was

00:35:26,250 --> 00:35:31,500
introduced by Sachi why why do we

00:35:29,190 --> 00:35:33,869
actually need another way another work

00:35:31,500 --> 00:35:35,490
why we are actually introducing another

00:35:33,869 --> 00:35:38,160
way of doing things that actually

00:35:35,490 --> 00:35:40,020
there's a lot of talks about you being

00:35:38,160 --> 00:35:43,770
bad and you being over complicated

00:35:40,020 --> 00:35:46,980
because of it well this option API is

00:35:43,770 --> 00:35:49,859
super intuitive system and it's actually

00:35:46,980 --> 00:35:52,829
what I bet many people got hooked into

00:35:49,859 --> 00:35:55,230
into view jest the problem with it is

00:35:52,829 --> 00:35:57,450
that it becomes very very hard to

00:35:55,230 --> 00:35:59,099
maintain huge components with it so for

00:35:57,450 --> 00:36:01,829
example if I don't know how many of you

00:35:59,099 --> 00:36:05,280
work with for example 1,000 lines

00:36:01,829 --> 00:36:06,750
components code for single features code

00:36:05,280 --> 00:36:08,160
for a single future was actually thrown

00:36:06,750 --> 00:36:09,960
in it's actually thrown in separate

00:36:08,160 --> 00:36:12,210
places like you have a bit of properties

00:36:09,960 --> 00:36:14,220
in data you have a computer property you

00:36:12,210 --> 00:36:17,369
have a listen order and it's actually

00:36:14,220 --> 00:36:20,579
very hard to fault the idea behind the

00:36:17,369 --> 00:36:23,730
composition API is that we with the

00:36:20,579 --> 00:36:26,069
option say it's like an alternative for

00:36:23,730 --> 00:36:28,470
the issues that about mental bility and

00:36:26,069 --> 00:36:31,560
with ability with the options with the

00:36:28,470 --> 00:36:32,880
options API the first thing that you

00:36:31,560 --> 00:36:36,000
need to know is that the composition

00:36:32,880 --> 00:36:39,060
idea is purely additive and can be used

00:36:36,000 --> 00:36:39,720
alongside the options API so this is an

00:36:39,060 --> 00:36:41,640
alternative

00:36:39,720 --> 00:36:43,800
advanced api that solves some of the

00:36:41,640 --> 00:36:46,619
limitations of the existing options api

00:36:43,800 --> 00:36:48,390
so again please don't start rewriting

00:36:46,619 --> 00:36:50,549
your entire application using

00:36:48,390 --> 00:36:52,380
composite API after seeing like a

00:36:50,549 --> 00:36:54,960
conference talk after seeing a couple of

00:36:52,380 --> 00:36:57,420
tutorials or understanding that okay

00:36:54,960 --> 00:36:59,760
starting with view tree we need anyone

00:36:57,420 --> 00:37:01,859
needs to use composition API there is no

00:36:59,760 --> 00:37:04,349
need to do that you can centrally for

00:37:01,859 --> 00:37:06,660
example we factor a component and think

00:37:04,349 --> 00:37:08,010
about how you can write it but starting

00:37:06,660 --> 00:37:13,680
you don't need to rewrite your entire

00:37:08,010 --> 00:37:17,160
application so this is again helps a lot

00:37:13,680 --> 00:37:19,140
with with an example here where we have

00:37:17,160 --> 00:37:21,359
a component that does a couple of things

00:37:19,140 --> 00:37:23,760
like searches for a list of items it

00:37:21,359 --> 00:37:26,819
reaches down to an external API to get

00:37:23,760 --> 00:37:29,069
some data and then sort them out so

00:37:26,819 --> 00:37:30,450
everything that is in purple is usually

00:37:29,069 --> 00:37:33,299
searching and everything that is

00:37:30,450 --> 00:37:36,839
highlighted in green with Twitter with

00:37:33,299 --> 00:37:38,849
sodium so as you can see as the

00:37:36,839 --> 00:37:40,740
component grows in complexity that code

00:37:38,849 --> 00:37:42,869
is not not shown here but it's a it's a

00:37:40,740 --> 00:37:44,789
good example all of the features are

00:37:42,869 --> 00:37:46,980
kind of messed up in all of the options

00:37:44,789 --> 00:37:49,230
that we have available so we have a bit

00:37:46,980 --> 00:37:51,390
of component products we have data we

00:37:49,230 --> 00:37:54,509
have and at the same time with options

00:37:51,390 --> 00:37:56,789
API it's it's very hard to it's very

00:37:54,509 --> 00:37:59,940
hard to extract logic common logic

00:37:56,789 --> 00:38:01,799
between between big big components with

00:37:59,940 --> 00:38:04,170
a composition API each of the color

00:38:01,799 --> 00:38:06,779
codes are our features if you want to

00:38:04,170 --> 00:38:08,549
work on one specific feature we can just

00:38:06,779 --> 00:38:10,950
simply go into that section of a code

00:38:08,549 --> 00:38:13,920
and it is way easier to understand how

00:38:10,950 --> 00:38:15,359
how that feature works so like I said

00:38:13,920 --> 00:38:17,910
another common limitation with the

00:38:15,359 --> 00:38:20,579
options API is that when your

00:38:17,910 --> 00:38:23,519
application grows sharing logic between

00:38:20,579 --> 00:38:25,829
components starts to be very hard so of

00:38:23,519 --> 00:38:28,559
course even now we have the ability to

00:38:25,829 --> 00:38:30,150
reuse logic between components in you do

00:38:28,559 --> 00:38:32,519
we are using make sense using

00:38:30,150 --> 00:38:34,740
higher-order components but rather less

00:38:32,519 --> 00:38:37,410
components but each of them comes with

00:38:34,740 --> 00:38:40,890
drawbacks and compares to compared to to

00:38:37,410 --> 00:38:43,500
the composition API so let's dive in and

00:38:40,890 --> 00:38:45,329
take a look at how actually how it

00:38:43,500 --> 00:38:48,450
actually works and how it actually looks

00:38:45,329 --> 00:38:50,880
so there is a link here on the facility

00:38:48,450 --> 00:38:53,400
in the chat if if anyone wants to about

00:38:50,880 --> 00:38:56,789
the about the API reference and you can

00:38:53,400 --> 00:38:59,220
find both RFC as well as the API

00:38:56,789 --> 00:39:01,410
reference the API reference is actually

00:38:59,220 --> 00:39:03,180
very great because it's how you can

00:39:01,410 --> 00:39:05,970
start learn on how you can use the

00:39:03,180 --> 00:39:07,560
composition yeah so if you see that if

00:39:05,970 --> 00:39:09,750
you see the menu on the left there is a

00:39:07,560 --> 00:39:11,910
setup method there's a reactive ref and

00:39:09,750 --> 00:39:14,040
each of these are building blocks or

00:39:11,910 --> 00:39:15,599
building or you are building you're

00:39:14,040 --> 00:39:20,580
going to build the composition if you

00:39:15,599 --> 00:39:23,340
are using using this so let's take an

00:39:20,580 --> 00:39:25,980
example that I found which is a money

00:39:23,340 --> 00:39:28,650
counter component that even though we

00:39:25,980 --> 00:39:30,990
can't see if here it basically shows a

00:39:28,650 --> 00:39:34,470
money amount and allows you to add or

00:39:30,990 --> 00:39:36,720
subtract confronted these to it this

00:39:34,470 --> 00:39:39,720
component has a money state which holds

00:39:36,720 --> 00:39:42,000
the quantity you have a delta which is

00:39:39,720 --> 00:39:44,099
bound using V model so like I said we

00:39:42,000 --> 00:39:45,960
are not actually feeling the template

00:39:44,099 --> 00:39:48,570
part but the data is actually using a V

00:39:45,960 --> 00:39:52,050
model to input and later using the add

00:39:48,570 --> 00:39:53,609
method to add the quantity one so the

00:39:52,050 --> 00:39:55,680
computed property for method money

00:39:53,609 --> 00:39:58,290
simply correctly displace the decimal

00:39:55,680 --> 00:40:00,630
value of the money as soon as finally I

00:39:58,290 --> 00:40:04,050
was included like there's also a dummy

00:40:00,630 --> 00:40:06,089
watch unmounted just so that we can see

00:40:04,050 --> 00:40:10,140
how we can actually accomplish this in

00:40:06,089 --> 00:40:11,880
in the composition area so we didn't

00:40:10,140 --> 00:40:13,800
include at the template part here since

00:40:11,880 --> 00:40:16,650
it is exactly the same in the two

00:40:13,800 --> 00:40:19,080
components between the options API and

00:40:16,650 --> 00:40:22,080
the composition API so all the changes

00:40:19,080 --> 00:40:24,210
are simply in the script part so the

00:40:22,080 --> 00:40:26,490
entry point in our application is and

00:40:24,210 --> 00:40:28,589
the single-biggest function is is the

00:40:26,490 --> 00:40:30,510
setup function so instead of having I

00:40:28,589 --> 00:40:33,180
read all of the all of the options we

00:40:30,510 --> 00:40:35,369
simply have a setup function so this

00:40:33,180 --> 00:40:37,770
serves our first and entry point in our

00:40:35,369 --> 00:40:39,900
composition API and it is how we're

00:40:37,770 --> 00:40:41,839
going to use it in our component so what

00:40:39,900 --> 00:40:44,970
we are doing here remember anything

00:40:41,839 --> 00:40:46,950
again anything that we are using in view

00:40:44,970 --> 00:40:48,990
three alpha we actually need to import

00:40:46,950 --> 00:40:50,880
so we have we need to import graph

00:40:48,990 --> 00:40:54,300
between poor computed whatever be

00:40:50,880 --> 00:40:56,040
whatever we need so as we start using

00:40:54,300 --> 00:40:58,830
all of them we start with we also need

00:40:56,040 --> 00:41:02,310
to import them and the setup function as

00:40:58,830 --> 00:41:05,130
far as timing those is prior to before

00:41:02,310 --> 00:41:09,089
create hook a life cycle hook and is

00:41:05,130 --> 00:41:11,540
actually used in place of the Creator so

00:41:09,089 --> 00:41:13,029
in our previous example the state is

00:41:11,540 --> 00:41:15,729
implemented using

00:41:13,029 --> 00:41:18,039
raph function and as you can see you can

00:41:15,729 --> 00:41:20,079
have as many as you want it's exactly

00:41:18,039 --> 00:41:22,150
the same to access them you don't need

00:41:20,079 --> 00:41:23,979
to access it Tony to access them using

00:41:22,150 --> 00:41:26,289
this that we previously did since the

00:41:23,979 --> 00:41:28,150
variable is not a magic instance from

00:41:26,289 --> 00:41:30,939
somewhere it's actually a variable

00:41:28,150 --> 00:41:33,189
inside the setup functions also to

00:41:30,939 --> 00:41:34,479
change its value the problem here is

00:41:33,189 --> 00:41:36,009
that in order to change its value

00:41:34,479 --> 00:41:39,729
actually need to access the value

00:41:36,009 --> 00:41:42,279
property and this is like a pro tips a

00:41:39,729 --> 00:41:45,489
bit weird because it's actually a proxy

00:41:42,279 --> 00:41:48,009
object and this is also function called

00:41:45,489 --> 00:41:52,269
reactive which roughly does the same

00:41:48,009 --> 00:41:54,309
thing and the idea that you use ref for

00:41:52,269 --> 00:42:04,479
creating reactive for creating

00:41:54,309 --> 00:42:07,179
reactivity on the committee and use

00:42:04,479 --> 00:42:09,489
reactive on an object so you could still

00:42:07,179 --> 00:42:12,309
use ref on an object and under the hood

00:42:09,489 --> 00:42:14,949
it will actually called reactive and I

00:42:12,309 --> 00:42:17,349
found so many counter arguments about

00:42:14,949 --> 00:42:19,150
people just use refs because it's

00:42:17,349 --> 00:42:21,939
actually using reactive for the objects

00:42:19,150 --> 00:42:24,249
or just use wrap for primitive data

00:42:21,939 --> 00:42:26,169
types and reactive for objects is it's

00:42:24,249 --> 00:42:28,809
something that we need to see going

00:42:26,169 --> 00:42:32,409
forward so let's get back to our

00:42:28,809 --> 00:42:34,119
original example here for computer

00:42:32,409 --> 00:42:35,829
properties you don't need to use

00:42:34,119 --> 00:42:39,749
computed from you you just need to use a

00:42:35,829 --> 00:42:44,279
computer function for you it's basic and

00:42:39,749 --> 00:42:44,279
it's basic and it takes the shape of

00:42:46,130 --> 00:42:50,690
hooks every hook has its own utility so

00:42:48,950 --> 00:42:53,000
in the case of mounted who keeps on

00:42:50,690 --> 00:42:55,670
mounted and we also need to import it

00:42:53,000 --> 00:42:57,230
and same shape as computer so they take

00:42:55,670 --> 00:43:00,109
a function as their first time program

00:42:57,230 --> 00:43:01,819
so methods we can have as many methods

00:43:00,109 --> 00:43:03,349
as we want with their simple functions

00:43:01,819 --> 00:43:06,740
like any other if there is nothing

00:43:03,349 --> 00:43:09,259
special yet for watch for we are when

00:43:06,740 --> 00:43:12,200
you are wanting to watch some changes

00:43:09,259 --> 00:43:14,170
there are different signatures here so

00:43:12,200 --> 00:43:16,849
that's the one equivalent to watch money

00:43:14,170 --> 00:43:18,829
but you can also but you can also check

00:43:16,849 --> 00:43:21,349
all the different signatures in the FC

00:43:18,829 --> 00:43:23,269
so for example you can what you can in

00:43:21,349 --> 00:43:25,490
this situation we are using money you

00:43:23,269 --> 00:43:28,789
are using the new value or and all value

00:43:25,490 --> 00:43:31,339
we can you can only watch the money and

00:43:28,789 --> 00:43:35,329
then we then receive only the new value

00:43:31,339 --> 00:43:37,279
and finally the setup function must

00:43:35,329 --> 00:43:40,220
return an object containing everything

00:43:37,279 --> 00:43:41,869
you want using the template it says it's

00:43:40,220 --> 00:43:43,819
essentially the data object that you

00:43:41,869 --> 00:43:46,519
want to use and anything that is not

00:43:43,819 --> 00:43:50,359
there in the return object it won't be

00:43:46,519 --> 00:43:52,910
accessible from the template so again

00:43:50,359 --> 00:43:55,400
this feels a bit complicated than this

00:43:52,910 --> 00:43:59,269
feels a bit why are we actually doing

00:43:55,400 --> 00:44:02,000
this but thinking about how you can

00:43:59,269 --> 00:44:04,519
organize large components by features

00:44:02,000 --> 00:44:07,250
this can actually make a verb this can

00:44:04,519 --> 00:44:09,109
actually make sense as well as if we

00:44:07,250 --> 00:44:11,539
have very large applications we can

00:44:09,109 --> 00:44:13,910
reuse the code across other components

00:44:11,539 --> 00:44:15,559
because we can simply import functions

00:44:13,910 --> 00:44:18,950
because the functions the methods inside

00:44:15,559 --> 00:44:20,779
they don't rely on some on some object

00:44:18,950 --> 00:44:22,549
outside are simply variables inside

00:44:20,779 --> 00:44:25,700
their attic and asleep it can easily be

00:44:22,549 --> 00:44:29,769
reused may be large things will prefer

00:44:25,700 --> 00:44:29,769
this API rather than you options API

00:44:31,260 --> 00:44:36,040
let's talk about typescript support

00:44:33,510 --> 00:44:38,110
another change that is coming is that

00:44:36,040 --> 00:44:41,670
view codebase will be rewritten

00:44:38,110 --> 00:44:44,260
completely using typescript once again

00:44:41,670 --> 00:44:46,720
with everything in the community a major

00:44:44,260 --> 00:44:48,790
concern was that people are kind of

00:44:46,720 --> 00:44:50,800
forced to learn typescript and these

00:44:48,790 --> 00:44:54,520
people increase view barriers of entry

00:44:50,800 --> 00:44:56,860
and so the view team actually made it

00:44:54,520 --> 00:44:58,840
very easy for us because a person if you

00:44:56,860 --> 00:45:00,610
want to use typescript use it that's

00:44:58,840 --> 00:45:03,340
perfect if you don't want to use it

00:45:00,610 --> 00:45:05,050
stick with plain JavaScript both of them

00:45:03,340 --> 00:45:05,920
would work exactly the same both of them

00:45:05,050 --> 00:45:08,710
would work just fine

00:45:05,920 --> 00:45:10,510
so among other things like we type

00:45:08,710 --> 00:45:11,800
script it allows you to enter type

00:45:10,510 --> 00:45:14,050
informations through JavaScript

00:45:11,800 --> 00:45:15,880
variables so this alone will greatly

00:45:14,050 --> 00:45:18,550
help you maintain a project in the long

00:45:15,880 --> 00:45:20,530
run so if you are working within an ID

00:45:18,550 --> 00:45:21,940
that supports tax free there's also be

00:45:20,530 --> 00:45:25,930
autocomplete and type of information

00:45:21,940 --> 00:45:28,030
available and according to them to Evan

00:45:25,930 --> 00:45:30,730
the fact that you will do we and in time

00:45:28,030 --> 00:45:32,740
scream but benefit absolutely everyone

00:45:30,730 --> 00:45:34,990
even if you are continuing to use plain

00:45:32,740 --> 00:45:38,350
JavaScript or you are using or you're

00:45:34,990 --> 00:45:41,590
switching to type script component

00:45:38,350 --> 00:45:43,990
fragments so starting a bit now there

00:45:41,590 --> 00:45:46,420
are a couple of features that are very

00:45:43,990 --> 00:45:48,610
familiar for react developers and they

00:45:46,420 --> 00:45:51,790
were greatly they were imported from

00:45:48,610 --> 00:45:55,060
there and fragments are essentially

00:45:51,790 --> 00:45:57,460
rootless components so in view to every

00:45:55,060 --> 00:46:00,190
component must have one and only one

00:45:57,460 --> 00:46:02,440
root component I'm sure that every view

00:46:00,190 --> 00:46:04,990
developer at one point started creating

00:46:02,440 --> 00:46:09,310
a component start developing it view it

00:46:04,990 --> 00:46:13,960
in the browser and get that yeah each

00:46:09,310 --> 00:46:17,680
component needs to have these can be a

00:46:13,960 --> 00:46:19,570
headache in some cases for example there

00:46:17,680 --> 00:46:21,430
are several use cases were having a

00:46:19,570 --> 00:46:24,490
component we turned several child

00:46:21,430 --> 00:46:26,260
elements would simplify things a lot so

00:46:24,490 --> 00:46:28,630
for example let's take an example from

00:46:26,260 --> 00:46:30,670
from Greg and say you have a table

00:46:28,630 --> 00:46:33,880
structure with a custom component called

00:46:30,670 --> 00:46:37,150
columns and in order for the compiled

00:46:33,880 --> 00:46:39,790
HTML to be valid the columns component

00:46:37,150 --> 00:46:42,490
needs to return several DB's elements

00:46:39,790 --> 00:46:46,600
but currently in view you can do that

00:46:42,490 --> 00:46:54,880
components need to have a the columns

00:46:46,600 --> 00:46:56,340
template - is that one speaking or I can

00:46:54,880 --> 00:46:58,720
mute

00:46:56,340 --> 00:47:00,910
so this is where fragments will come

00:46:58,720 --> 00:47:03,130
fragments will come in handy so they

00:47:00,910 --> 00:47:05,920
allow you to return multiple elements

00:47:03,130 --> 00:47:09,430
which makes sense - like this super

00:47:05,920 --> 00:47:11,590
simple examples in view tree we can

00:47:09,430 --> 00:47:13,810
simply ignore the fragment part and have

00:47:11,590 --> 00:47:20,590
components simply use multiple root

00:47:13,810 --> 00:47:23,380
nodes without without any issues borders

00:47:20,590 --> 00:47:25,810
are another feature that is natively

00:47:23,380 --> 00:47:29,410
used in react and this is now planted

00:47:25,810 --> 00:47:33,490
being fermented in in beauty as well so

00:47:29,410 --> 00:47:35,680
let's let's start off by doing an encode

00:47:33,490 --> 00:47:38,500
example where we have a user card

00:47:35,680 --> 00:47:40,869
component that lets us remove a certain

00:47:38,500 --> 00:47:42,910
user from the data this is playing very

00:47:40,869 --> 00:47:45,760
simple to very simple idea to follow

00:47:42,910 --> 00:47:47,560
them after clicking the button we will

00:47:45,760 --> 00:47:49,869
see a confirmation pop-up where we can

00:47:47,560 --> 00:47:56,290
confirm the action and remove the user

00:47:49,869 --> 00:47:58,450
if on one part keeping the related

00:47:56,290 --> 00:48:00,670
components like the confirmation pop-up

00:47:58,450 --> 00:48:02,590
in the same place and see the other

00:48:00,670 --> 00:48:05,290
logic is actually good for code

00:48:02,590 --> 00:48:07,480
maintenance but when it comes to UI

00:48:05,290 --> 00:48:09,490
elements that should appear on top of

00:48:07,480 --> 00:48:12,490
the others it can lead to some problems

00:48:09,490 --> 00:48:15,310
so mainly around how we display the

00:48:12,490 --> 00:48:16,990
pop-up from the grid layout may be the

00:48:15,310 --> 00:48:19,780
pop-up needs to be like in a completely

00:48:16,990 --> 00:48:22,090
separate part of the Dom as well as for

00:48:19,780 --> 00:48:24,280
example having other classes higher the

00:48:22,090 --> 00:48:28,780
Dom hierarchy that can prevent the

00:48:24,280 --> 00:48:31,240
pop-up from show so in this situation we

00:48:28,780 --> 00:48:36,780
can use portal we can use portal

00:48:31,240 --> 00:48:40,990
component we the portal component simply

00:48:36,780 --> 00:48:42,970
is simply it's taking one actually one

00:48:40,990 --> 00:48:45,190
attribute which is the target saying the

00:48:42,970 --> 00:48:47,560
ID of the deep or very exact if you want

00:48:45,190 --> 00:48:50,410
to put component and everything inside

00:48:47,560 --> 00:48:53,619
the portal will be like a slot and will

00:48:50,410 --> 00:48:55,810
be added inside the deep the good news

00:48:53,619 --> 00:48:57,580
is that portal components is actually

00:48:55,810 --> 00:49:00,010
super simple you only have that one

00:48:57,580 --> 00:49:03,070
property the target and a default stop

00:49:00,010 --> 00:49:04,960
so the slot content will be rather in

00:49:03,070 --> 00:49:09,520
the Dom element that is selecting a

00:49:04,960 --> 00:49:12,670
query and you're done with it another

00:49:09,520 --> 00:49:16,810
feature in view ds3 is a special

00:49:12,670 --> 00:49:18,940
suspense component the suspense is again

00:49:16,810 --> 00:49:22,180
another feature of react that is now

00:49:18,940 --> 00:49:24,310
coming to v3 and it allows you your

00:49:22,180 --> 00:49:27,070
component to display fallback content

00:49:24,310 --> 00:49:29,980
until your page is ready and all of your

00:49:27,070 --> 00:49:32,170
content is loaded this is very useful if

00:49:29,980 --> 00:49:32,650
you want to a synchronously load content

00:49:32,170 --> 00:49:34,119
in

00:49:32,650 --> 00:49:37,420
setup method if you're using composition

00:49:34,119 --> 00:49:39,640
API so if we're looking at the view next

00:49:37,420 --> 00:49:42,010
we'll positive which is view tree the

00:49:39,640 --> 00:49:44,289
setup method the second method is a is

00:49:42,010 --> 00:49:44,890
actually an acing method which returns a

00:49:44,289 --> 00:49:46,960
promise

00:49:44,890 --> 00:49:49,059
so this promise is simply caught up with

00:49:46,960 --> 00:49:51,609
us as mass component which will then

00:49:49,059 --> 00:49:55,180
render follow that content until until

00:49:51,609 --> 00:49:57,339
it's resolved so we can use the spans

00:49:55,180 --> 00:49:58,720
for creating loading pages when we are

00:49:57,339 --> 00:50:01,450
waiting for need we are called to

00:49:58,720 --> 00:50:05,859
resolve or essentially any other sorts

00:50:01,450 --> 00:50:07,390
of data fetching or acing setup so the

00:50:05,859 --> 00:50:08,829
fallback content will be shown until

00:50:07,390 --> 00:50:11,559
suspense component will be fully

00:50:08,829 --> 00:50:13,569
rendered we have two sections we have a

00:50:11,559 --> 00:50:16,240
default section and we have a fallback

00:50:13,569 --> 00:50:18,069
section so suspense can either way to

00:50:16,240 --> 00:50:20,289
the component will be downloaded if

00:50:18,069 --> 00:50:22,660
that's an async component or preference

00:50:20,289 --> 00:50:25,289
of pacing action in the setup in the

00:50:22,660 --> 00:50:25,289
setup function

00:50:25,400 --> 00:50:33,650
and again we can find another major

00:50:30,770 --> 00:50:36,560
change in the way we are instantiating

00:50:33,650 --> 00:50:39,200
and we are configuring our applications

00:50:36,560 --> 00:50:42,230
so let's see for example how we are

00:50:39,200 --> 00:50:45,230
currently working now so correctly in

00:50:42,230 --> 00:50:47,780
view - we are using a global view object

00:50:45,230 --> 00:50:50,600
to provide any configuration and create

00:50:47,780 --> 00:50:52,970
any view instances any changes that we

00:50:50,600 --> 00:50:55,130
make to the view object will essentially

00:50:52,970 --> 00:50:57,530
affect every view instance and every

00:50:55,130 --> 00:51:00,980
component and let's see now how it will

00:50:57,530 --> 00:51:03,800
actually work in version 3 so it's again

00:51:00,980 --> 00:51:06,770
we are we are importing as you probably

00:51:03,800 --> 00:51:09,800
notice now every configuration is scoped

00:51:06,770 --> 00:51:12,680
to assert a new application defined in a

00:51:09,800 --> 00:51:15,050
in a great app function it will easily

00:51:12,680 --> 00:51:18,680
make your code easier to understand and

00:51:15,050 --> 00:51:20,420
it's less prone to unexpected issues for

00:51:18,680 --> 00:51:22,460
example if you have a third-party add-on

00:51:20,420 --> 00:51:24,830
that does some modification see it can

00:51:22,460 --> 00:51:27,680
have very very weird consequences that

00:51:24,830 --> 00:51:29,480
will be very hard to fault so creative

00:51:27,680 --> 00:51:31,670
some third-party solution is modifying

00:51:29,480 --> 00:51:33,410
for example P of your object you can

00:51:31,670 --> 00:51:35,470
affect your application in unexpected

00:51:33,410 --> 00:51:39,710
ways for example in global mix sense

00:51:35,470 --> 00:51:43,640
which now it won't be possible with a

00:51:39,710 --> 00:51:46,760
bit view tree this is also useful for

00:51:43,640 --> 00:51:49,040
tests where global configuration makes

00:51:46,760 --> 00:51:52,910
it easy to accidentally pollute other

00:51:49,040 --> 00:51:55,370
test cases during during testing so I

00:51:52,910 --> 00:51:57,680
don't know how many of you guys of you

00:51:55,370 --> 00:52:00,890
are actually using filters in production

00:51:57,680 --> 00:52:03,020
but but they are done so filters

00:52:00,890 --> 00:52:05,960
functionality can be easily replaced

00:52:03,020 --> 00:52:08,240
with method calls or computed properties

00:52:05,960 --> 00:52:12,290
so it provides primary syntactical

00:52:08,240 --> 00:52:14,830
rather than practical pet the main issue

00:52:12,290 --> 00:52:18,440
here is that the behind-the-scenes

00:52:14,830 --> 00:52:20,060
filters require custom micro syntax that

00:52:18,440 --> 00:52:22,010
actually breaks the assumption of

00:52:20,060 --> 00:52:24,980
expression being it's just JavaScript

00:52:22,010 --> 00:52:27,630
because it's not which adds both to the

00:52:24,980 --> 00:52:30,240
learning and implementation costs

00:52:27,630 --> 00:52:32,790
and going further it actually conflicts

00:52:30,240 --> 00:52:35,430
with JavaScript only twice or operator

00:52:32,790 --> 00:52:40,530
and mixed expression parsing way more

00:52:35,430 --> 00:52:43,140
complicated so apart from the

00:52:40,530 --> 00:52:47,130
composition API that is like the biggest

00:52:43,140 --> 00:52:49,350
major new API and view 3 we can find a

00:52:47,130 --> 00:52:52,140
lot of smaller improvements as well so

00:52:49,350 --> 00:52:55,500
we can see that view is moving towards

00:52:52,140 --> 00:52:58,400
better developer experience and at the

00:52:55,500 --> 00:53:01,110
same time simpler and more intuitive API

00:52:58,400 --> 00:53:02,910
it's also at the same time it's also

00:53:01,110 --> 00:53:05,250
great to see that view team decided to

00:53:02,910 --> 00:53:08,280
adopt many ideas from that are currently

00:53:05,250 --> 00:53:10,230
available like in react or things that

00:53:08,280 --> 00:53:12,270
are only available through third-party

00:53:10,230 --> 00:53:15,870
libraries and they added in the core

00:53:12,270 --> 00:53:18,060
framework but the list above contains

00:53:15,870 --> 00:53:20,910
only solved smaller features and small

00:53:18,060 --> 00:53:23,370
like not all of them are here and again

00:53:20,910 --> 00:53:25,800
if you are curious about other other

00:53:23,370 --> 00:53:29,210
features or other modifications just be

00:53:25,800 --> 00:53:31,290
sure to check out the view view errors

00:53:29,210 --> 00:53:33,270
thank you very much if you have any

00:53:31,290 --> 00:53:38,370
questions just unmute and I'll be more

00:53:33,270 --> 00:53:40,880
than happy or the happy to answer thank

00:53:38,370 --> 00:53:43,020
you Paul for this nice presentation

00:53:40,880 --> 00:53:47,910
maybe we can give him a round of

00:53:43,020 --> 00:53:50,240
applause for him yeah applause next to

00:53:47,910 --> 00:53:50,240
the mic

00:54:10,460 --> 00:54:17,940
yeah pool I have a question so the the

00:54:14,670 --> 00:54:23,570
suspense APR looks pretty cool and was

00:54:17,940 --> 00:54:23,570
that particularly difficult to do in v2

00:54:27,140 --> 00:54:34,710
for variable otherwise you would say if

00:54:32,369 --> 00:54:36,990
if I don't have any data just put some

00:54:34,710 --> 00:54:40,200
loading gif or something like that and

00:54:36,990 --> 00:54:43,290
then again the nice thing about suspense

00:54:40,200 --> 00:54:45,839
is it actually offers you a general way

00:54:43,290 --> 00:54:47,520
of doing it rather than everybody doing

00:54:45,839 --> 00:54:48,720
the bit different and on each component

00:54:47,520 --> 00:54:51,420
you have a bit of different

00:54:48,720 --> 00:54:53,099
implementation and you have no idea am I

00:54:51,420 --> 00:54:55,500
actually doing this or am I not doing

00:54:53,099 --> 00:54:57,480
this in this particular component now

00:54:55,500 --> 00:54:59,220
with suspense is actually super easy I'm

00:54:57,480 --> 00:55:01,230
just checking for the suspense component

00:54:59,220 --> 00:55:03,359
okay I know this section is going to be

00:55:01,230 --> 00:55:05,700
for the loading part this section is

00:55:03,359 --> 00:55:15,589
actually going to be for for the actual

00:55:05,700 --> 00:55:17,910
content of of I have a question

00:55:15,589 --> 00:55:21,780
also thanks Paul for the presentation

00:55:17,910 --> 00:55:36,599
real nice any reason why they get rid of

00:55:21,780 --> 00:55:40,140
the filters you can accomplish the same

00:55:36,599 --> 00:55:41,190
thing with computed properties and with

00:55:40,140 --> 00:55:43,770
normal methods

00:55:41,190 --> 00:55:47,579
it doesn't actually bring a new value

00:55:43,770 --> 00:55:50,400
and I think mainly I think it's a issue

00:55:47,579 --> 00:55:53,280
on how hard it is to parse the template

00:55:50,400 --> 00:55:55,740
and it's not actually very JavaScript

00:55:53,280 --> 00:55:58,770
light like it's not it's not this is

00:55:55,740 --> 00:56:01,040
like a custom syntax for it that it's

00:55:58,770 --> 00:56:03,270
not needed necessarily and it's also

00:56:01,040 --> 00:56:05,700
simplified the code a lot so I think

00:56:03,270 --> 00:56:08,310
it's just because the passing of the

00:56:05,700 --> 00:56:10,349
parsing of filters that it's it's

00:56:08,310 --> 00:56:13,680
between the complexity of having to

00:56:10,349 --> 00:56:16,750
support filters rather than how much how

00:56:13,680 --> 00:56:19,810
much how many improvements does

00:56:16,750 --> 00:56:22,710
bring and you can easily refer to

00:56:19,810 --> 00:56:22,710
complete the property

00:56:33,320 --> 00:56:37,530
that's all if if there are no any other

00:56:35,910 --> 00:56:39,270
questions thanks a lot again and

00:56:37,530 --> 00:56:47,760
hopefully we will see each other pretty

00:56:39,270 --> 00:56:50,730
soon thanks we also have a repository

00:56:47,760 --> 00:57:01,710
where after each Meetup we post

00:56:50,730 --> 00:57:03,020
resources and we kind of lost you there

00:57:01,710 --> 00:57:15,390
[Music]

00:57:03,020 --> 00:57:18,120
and yes okay Andre can you please repeat

00:57:15,390 --> 00:57:28,650
because we lost the connection with you

00:57:18,120 --> 00:57:32,970
and we couldn't hear no yeah I can I can

00:57:28,650 --> 00:57:35,940
say what and really wanted to say after

00:57:32,970 --> 00:57:38,520
each meet after each meetup who we take

00:57:35,940 --> 00:57:41,790
the resources that you mentioned and we

00:57:38,520 --> 00:57:46,140
add them on our github repo it's under

00:57:41,790 --> 00:57:49,980
Jesse Aerosmith pops and if you would be

00:57:46,140 --> 00:57:53,300
nice if you can share the slides with us

00:57:49,980 --> 00:57:57,270
and any links that you think are useful

00:57:53,300 --> 00:58:00,660
so when if somebody wants to go back and

00:57:57,270 --> 00:58:02,400
check hey Paul mentioned something in

00:58:00,660 --> 00:58:12,690
the meetup he can maybe find the link

00:58:02,400 --> 00:58:14,460
there and start learning reading or so

00:58:12,690 --> 00:58:17,210
if there are not any other questions

00:58:14,460 --> 00:58:23,930
thanks a lot for joining and hopefully

00:58:17,210 --> 00:58:23,930

YouTube URL: https://www.youtube.com/watch?v=BwHEqOnQiRg


