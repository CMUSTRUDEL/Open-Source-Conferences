Title: Memoization in React - Andrei Pfeiffer | JSHeroes Meetups 2020
Publication date: 2020-04-20
Playlist: JSHeroes Meetups 2020
Description: 
	It is said that React is "fast enough". This is very true for most applications. However, rendering performance problems might occur in 2 different situations:

1) when we render many components or native elements, or
2) when we perform very frequent updates, during animations or gestures.

During this talk, we'll focus on the first use-case mentioned above. We'll identify performance problems, measure them using the React Profiler and fix them using various optimisation techniques such as React.memo(), useMemo() and useCallback().

About Andrei

He is a Developer / Designer hybrid. He equally loves to code designs and to design code. He is specialised in UI Development, both on web and mobile. He's an organizer of "revo.js" conference and "tim.js" meetup in Timisoara.
Twitter: https://twitter.com/pfeiffer_andrei

FAQ:
Q: How long will the talk be?
A: About 1 hour.

Q: Will it be theoretical or practical?
A: It will be a mix, about 25% slides and 75% live coding demo.

Q: Do I need to know React to attend?
A: This is an advanced presentation, so prior experience with React is needed as it won't touch on aspects like React syntax, JSX, component types, state, or lifecycle.

Q: Will the demo use class or function components?
A: The demo will only use function components, although all the optimisations presented in the talk can be implemented for class components as well.
Captions: 
	00:00:03,090 --> 00:00:10,740
oh hello to our later guests

00:00:06,450 --> 00:00:14,150
oh they're happy to see a lot of people

00:00:10,740 --> 00:00:22,619
joining for this is a third at the third

00:00:14,150 --> 00:00:24,900
Meetup Ramon meetup we we had a had a

00:00:22,619 --> 00:00:28,109
meet-up on you we had one on angular so

00:00:24,900 --> 00:00:32,340
the natural order dictates this the

00:00:28,109 --> 00:00:36,690
third one is on react hopefully the next

00:00:32,340 --> 00:00:39,720
one will not necessarily be in the same

00:00:36,690 --> 00:00:41,990
angle and just proms and frameworks

00:00:39,720 --> 00:00:44,850
we'll try to diversify the topics also

00:00:41,990 --> 00:00:47,960
it is well not necessarily arranged if

00:00:44,850 --> 00:00:47,960
it's just a coincidence

00:00:48,830 --> 00:00:55,260
yeah we're going to allow the meetup for

00:00:52,170 --> 00:00:58,680
next week just after this one I think

00:00:55,260 --> 00:01:01,440
that the recurrence like I've won it up

00:00:58,680 --> 00:01:06,240
four weeks work because people are

00:01:01,440 --> 00:01:09,049
interested we have a lot of topics that

00:01:06,240 --> 00:01:11,789
we can bring here and we have this

00:01:09,049 --> 00:01:16,289
benefit of being able to invite people

00:01:11,789 --> 00:01:19,200
from all over the world to present in

00:01:16,289 --> 00:01:26,189
front of the community this way we're

00:01:19,200 --> 00:01:28,619
going to try to bring speakers that were

00:01:26,189 --> 00:01:30,390
supposed to be in April include from JC

00:01:28,619 --> 00:01:33,509
Rose we're going to try to bring them

00:01:30,390 --> 00:01:38,189
into some of the meetup also in the

00:01:33,509 --> 00:01:40,649
coming weeks months depending on how

00:01:38,189 --> 00:01:43,249
long the situation is going to remain

00:01:40,649 --> 00:01:46,829
like this and of course if this is

00:01:43,249 --> 00:01:49,280
successful on the long run even if we go

00:01:46,829 --> 00:01:52,380
back to organizing you know regular

00:01:49,280 --> 00:01:55,979
on-site meetups who will consider doing

00:01:52,380 --> 00:01:58,200
once in a while remote one also it's

00:01:55,979 --> 00:02:00,119
also much easier from logistics

00:01:58,200 --> 00:02:05,509
perspective but of course you're missing

00:02:00,119 --> 00:02:05,509
from some part of the fun and networking

00:02:07,039 --> 00:02:12,599
we could try also the networking after

00:02:10,140 --> 00:02:16,800
work see how it works if people want to

00:02:12,599 --> 00:02:22,080
stick around after the presentation so

00:02:16,800 --> 00:02:24,210
we have another Andre last week we had

00:02:22,080 --> 00:02:28,100
hungry untold if we could have Andre

00:02:24,210 --> 00:02:31,650
Pfeiffer joining us from Timisoara

00:02:28,100 --> 00:02:33,270
and raised already he's an old friend of

00:02:31,650 --> 00:02:36,890
mine because I don't know like we met

00:02:33,270 --> 00:02:39,980
three or four years ago already

00:02:36,890 --> 00:02:42,210
something like that like that

00:02:39,980 --> 00:02:46,640
he's been too close I've been to two

00:02:42,210 --> 00:02:51,210
mushara we supported each other with

00:02:46,640 --> 00:02:52,800
with the communities not sure if you

00:02:51,210 --> 00:02:54,810
talk about this but they're their

00:02:52,800 --> 00:02:57,810
community sure is actually the longest

00:02:54,810 --> 00:02:59,060
living community dollar community in the

00:02:57,810 --> 00:03:02,190
country

00:02:59,060 --> 00:03:06,180
and we had a lot of interesting ideas

00:03:02,190 --> 00:03:12,360
exchanges a lot of good points taken

00:03:06,180 --> 00:03:15,060
from one from each other and yeah I

00:03:12,360 --> 00:03:17,610
guess he will stick a bit talk football

00:03:15,060 --> 00:03:20,989
maybe rebel Jarius their conference

00:03:17,610 --> 00:03:27,110
conference that they're organizing

00:03:20,989 --> 00:03:32,220
hopefully in October a stinger trust and

00:03:27,110 --> 00:03:34,560
yeah I guess that but all from my side

00:03:32,220 --> 00:03:39,510
and there you can start whenever you're

00:03:34,560 --> 00:03:42,510
ready yeah thanks thanks Alex and thank

00:03:39,510 --> 00:03:45,870
you Jess Jess heroes community for

00:03:42,510 --> 00:03:59,220
putting this event together and thank

00:03:45,870 --> 00:04:04,220
you all for attending this event okay so

00:03:59,220 --> 00:04:06,600
as probably many of you know next week

00:04:04,220 --> 00:04:10,820
at the end of next week

00:04:06,600 --> 00:04:14,700
jazz heroes was supposed to take place a

00:04:10,820 --> 00:04:17,269
conference that I I wanted to attend and

00:04:14,700 --> 00:04:19,919
probably many of you as well

00:04:17,269 --> 00:04:20,640
unfortunately that's not happening

00:04:19,919 --> 00:04:23,340
anymore

00:04:20,640 --> 00:04:27,960
and one day before the conference on the

00:04:23,340 --> 00:04:29,520
22nd of April there was a I I was

00:04:27,960 --> 00:04:30,120
supposed to have a workshop along with

00:04:29,520 --> 00:04:32,040
the

00:04:30,120 --> 00:04:33,980
the other with other friends a workshop

00:04:32,040 --> 00:04:37,169
about react rendering performance

00:04:33,980 --> 00:04:39,169
optimizations so just to give you a bit

00:04:37,169 --> 00:04:43,620
of a context about today's presentation

00:04:39,169 --> 00:04:47,430
this presentation is basically a subset

00:04:43,620 --> 00:04:52,680
of the of the workshop that I did I had

00:04:47,430 --> 00:04:53,310
planned for 4j zeroes so I'm Andre

00:04:52,680 --> 00:04:56,370
Pfeifer

00:04:53,310 --> 00:04:58,380
I work as a designer for this company

00:04:56,370 --> 00:05:01,110
called espresso in Timisoara

00:04:58,380 --> 00:05:04,160
I'm also an event organizer organized a

00:05:01,110 --> 00:05:07,889
team dress which is the local meetup in

00:05:04,160 --> 00:05:10,470
Timisoara a similar to Jess heroes in

00:05:07,889 --> 00:05:13,320
Bruges and I also organize refugees

00:05:10,470 --> 00:05:16,139
which is a two-day conference in in

00:05:13,320 --> 00:05:18,960
Timisoara and just like J's heroes in

00:05:16,139 --> 00:05:20,970
inclusion are gonna talk about refugees

00:05:18,960 --> 00:05:22,770
a bit bit more in a moment

00:05:20,970 --> 00:05:25,440
and from time to time I also write

00:05:22,770 --> 00:05:28,830
technical articles on media mostly

00:05:25,440 --> 00:05:34,919
focused on react native or an or

00:05:28,830 --> 00:05:36,889
JavaScript so speaking of refugees as I

00:05:34,919 --> 00:05:39,479
said it's a two-day conference that's

00:05:36,889 --> 00:05:43,979
hopefully is gonna take place in October

00:05:39,479 --> 00:05:46,590
this year and we already have a pretty

00:05:43,979 --> 00:05:50,820
amazing line of speakers that are

00:05:46,590 --> 00:05:52,830
confirmed but we want some more that's

00:05:50,820 --> 00:05:55,530
why we have we have a call for paper

00:05:52,830 --> 00:05:59,010
that's currently open and we I would

00:05:55,530 --> 00:06:02,010
like to invite everyone to to submit

00:05:59,010 --> 00:06:06,900
your proposals it's on on the website

00:06:02,010 --> 00:06:12,780
you can trap all refugees at ro / 2020 /

00:06:06,900 --> 00:06:16,680
CFP the cover papers is open until the I

00:06:12,780 --> 00:06:20,190
think the 1st of June or something

00:06:16,680 --> 00:06:22,500
so it's plenty of time also tickets are

00:06:20,190 --> 00:06:26,250
not available yet but they will start on

00:06:22,500 --> 00:06:29,330
the 1st of May so in case you want to

00:06:26,250 --> 00:06:32,780
stay updated just follow us on on your

00:06:29,330 --> 00:06:35,580
favorite social network platform or

00:06:32,780 --> 00:06:39,450
check check out the website that

00:06:35,580 --> 00:06:42,210
refugees are oh and if you have any any

00:06:39,450 --> 00:06:42,969
questions just feel free to to ask me or

00:06:42,210 --> 00:06:47,019
drop

00:06:42,969 --> 00:06:50,110
so tweet or or an email I hope that you

00:06:47,019 --> 00:06:52,539
don't have a tik-tok account for it oh

00:06:50,110 --> 00:06:53,589
yeah yeah I don't have a dick stuff yeah

00:06:52,539 --> 00:07:01,229
we don't have yeah

00:06:53,589 --> 00:07:07,719
do you have for Jess yours no okay so

00:07:01,229 --> 00:07:10,419
before we start the presentation so just

00:07:07,719 --> 00:07:12,459
to give you a very very few very few a

00:07:10,419 --> 00:07:16,749
bit of a context so today's talk is

00:07:12,459 --> 00:07:21,519
gonna be about 15 minutes theory some

00:07:16,749 --> 00:07:25,659
slides and about 45 minutes of coding so

00:07:21,519 --> 00:07:27,759
Before we jump into that what is a

00:07:25,659 --> 00:07:30,669
memoization probably many of you know

00:07:27,759 --> 00:07:34,769
but just let me give you a Bic of a bit

00:07:30,669 --> 00:07:37,689
of a recap so citing wikipedia

00:07:34,769 --> 00:07:40,569
memorization in computing is an

00:07:37,689 --> 00:07:42,909
optimization technique used primarily to

00:07:40,569 --> 00:07:45,189
speed up computer programs by storing

00:07:42,909 --> 00:07:47,769
the results of expensive function calls

00:07:45,189 --> 00:07:52,869
and returning the cached result when the

00:07:47,769 --> 00:07:55,659
same input occur again so let's take an

00:07:52,869 --> 00:08:00,009
example of a factorial function a

00:07:55,659 --> 00:08:03,639
factorial is a factorial function

00:08:00,009 --> 00:08:08,050
usually it receives an input an integer

00:08:03,639 --> 00:08:11,919
as an input and returns that input

00:08:08,050 --> 00:08:16,629
multiplied by all the numbers less or

00:08:11,919 --> 00:08:19,149
less or equal than than the input it's a

00:08:16,629 --> 00:08:20,589
abused for VAR no calculating of

00:08:19,149 --> 00:08:22,119
permutations or combinations in

00:08:20,589 --> 00:08:25,509
mathematics it doesn't matter exactly

00:08:22,119 --> 00:08:29,769
just a function that receive some input

00:08:25,509 --> 00:08:31,719
and returns some some result one one

00:08:29,769 --> 00:08:34,479
thing to mention is that memorization is

00:08:31,719 --> 00:08:37,750
only applicable to pure functions your

00:08:34,479 --> 00:08:40,659
functions are functions that only depend

00:08:37,750 --> 00:08:42,479
on the inputs they receive and always

00:08:40,659 --> 00:08:45,430
return the same or the same result for

00:08:42,479 --> 00:08:47,730
for the same input and they don't treat

00:08:45,430 --> 00:08:51,459
any side-effects

00:08:47,730 --> 00:08:53,190
so let's consider that we call the

00:08:51,459 --> 00:08:57,300
factorial function

00:08:53,190 --> 00:08:59,220
first we search if we have if we have

00:08:57,300 --> 00:09:00,899
already stored the result in the cache

00:08:59,220 --> 00:09:04,529
if we don't then we have to calculate

00:09:00,899 --> 00:09:07,980
and to store the results in somewhere in

00:09:04,529 --> 00:09:10,680
the cache we call it again with a

00:09:07,980 --> 00:09:12,899
different input we have to say we do the

00:09:10,680 --> 00:09:15,839
same same thing again we search we don't

00:09:12,899 --> 00:09:17,790
have the result stored we calculate and

00:09:15,839 --> 00:09:19,980
we store the result then at a later time

00:09:17,790 --> 00:09:23,069
when it calls that function again with

00:09:19,980 --> 00:09:24,720
the same input 6 we can return it

00:09:23,069 --> 00:09:27,449
directly from the cache because we have

00:09:24,720 --> 00:09:30,329
already calculated that that results we

00:09:27,449 --> 00:09:37,680
don't have to recalculate we got elected

00:09:30,329 --> 00:09:40,680
again so in in memoization a cache is

00:09:37,680 --> 00:09:43,319
not like a persistent cache so you don't

00:09:40,680 --> 00:09:45,060
store the results on a in a database or

00:09:43,319 --> 00:09:45,660
on the disk usually store it in in

00:09:45,060 --> 00:09:48,870
memory

00:09:45,660 --> 00:09:50,579
it's an in-memory cache and a very

00:09:48,870 --> 00:09:53,399
simple example for our function would be

00:09:50,579 --> 00:09:56,970
like an object and where the key is the

00:09:53,399 --> 00:09:59,880
input and the value is is the the

00:09:56,970 --> 00:10:02,910
calculated result so as you probably

00:09:59,880 --> 00:10:05,819
imagine if you run the program long

00:10:02,910 --> 00:10:07,649
enough this this object will start to

00:10:05,819 --> 00:10:09,720
get really really big right because if

00:10:07,649 --> 00:10:14,490
you store a lot of a lot of results so

00:10:09,720 --> 00:10:17,189
this could be a problem in certain

00:10:14,490 --> 00:10:18,839
situations so let's consider that if we

00:10:17,189 --> 00:10:20,639
don't have any memorization the time to

00:10:18,839 --> 00:10:23,880
calculate a certain a certain input

00:10:20,639 --> 00:10:26,519
takes a certain amount of time if you

00:10:23,880 --> 00:10:29,220
have a mutation with very few stored

00:10:26,519 --> 00:10:32,730
results then probably takes very little

00:10:29,220 --> 00:10:35,430
time to to search for that result to see

00:10:32,730 --> 00:10:36,809
if we have a result stored and of course

00:10:35,430 --> 00:10:39,300
if we have it then we return it

00:10:36,809 --> 00:10:42,029
immediately but if we don't have it then

00:10:39,300 --> 00:10:45,029
we have to calculate that that result so

00:10:42,029 --> 00:10:47,189
you can see that memorization adds a bit

00:10:45,029 --> 00:10:50,730
of an overhead right because now it

00:10:47,189 --> 00:10:52,680
takes a bit longer to to return the

00:10:50,730 --> 00:10:55,949
result because you also have to perform

00:10:52,680 --> 00:10:58,019
some search before if we have many

00:10:55,949 --> 00:11:01,230
stored results then probably will take

00:10:58,019 --> 00:11:03,240
even more to to search for that result

00:11:01,230 --> 00:11:04,920
in in the case where we don't find a

00:11:03,240 --> 00:11:06,780
result and we have to calculate it so it

00:11:04,920 --> 00:11:10,050
could it could base

00:11:06,780 --> 00:11:12,180
affect us even more than not having the

00:11:10,050 --> 00:11:14,010
any memorization at all so I have to be

00:11:12,180 --> 00:11:18,630
very careful about when to use

00:11:14,010 --> 00:11:21,420
memorization in in computing that's why

00:11:18,630 --> 00:11:23,640
usually all the memorization techniques

00:11:21,420 --> 00:11:27,860
have a maximum cache size so you specify

00:11:23,640 --> 00:11:30,870
like only store a maximum amount of

00:11:27,860 --> 00:11:33,960
results don't store all of them just to

00:11:30,870 --> 00:11:39,270
to avoid any of the of the problems that

00:11:33,960 --> 00:11:42,960
I just presented okay so what does this

00:11:39,270 --> 00:11:47,400
have to do with the react well in a

00:11:42,960 --> 00:11:49,800
react 16.6 reactor that memo was was

00:11:47,400 --> 00:11:52,320
that it is an API that uses memorization

00:11:49,800 --> 00:11:57,060
to optimize the performance of function

00:11:52,320 --> 00:11:59,850
components and in sixty 16.8 along with

00:11:57,060 --> 00:12:03,320
the hooks there there were two who said

00:11:59,850 --> 00:12:05,460
it's use callback a News memo that also

00:12:03,320 --> 00:12:08,910
they also use memoization

00:12:05,460 --> 00:12:13,650
and basically these methods were added

00:12:08,910 --> 00:12:16,680
to to react API in order to to help

00:12:13,650 --> 00:12:17,880
developers optimize optimize the

00:12:16,680 --> 00:12:19,410
rendering performance of their

00:12:17,880 --> 00:12:26,760
applications and we're going to talk

00:12:19,410 --> 00:12:29,520
about all of these methods today one one

00:12:26,760 --> 00:12:31,890
bit of a note here all these api's are

00:12:29,520 --> 00:12:34,080
only applicable to functional components

00:12:31,890 --> 00:12:36,180
for class components there are other

00:12:34,080 --> 00:12:38,580
api's and other methods that you can use

00:12:36,180 --> 00:12:43,320
to to achieve the same the same results

00:12:38,580 --> 00:12:46,410
so just just a quick example let's say

00:12:43,320 --> 00:12:50,670
you have a a function a function

00:12:46,410 --> 00:12:56,450
component account that displays some

00:12:50,670 --> 00:12:59,280
some some stuff in if you want to to use

00:12:56,450 --> 00:13:01,890
to this memorization technique you

00:12:59,280 --> 00:13:04,430
basically won't export the component as

00:13:01,890 --> 00:13:07,080
you would normally export it as default

00:13:04,430 --> 00:13:09,620
you wrapper that component into this

00:13:07,080 --> 00:13:15,030
react memo that we're gonna take a

00:13:09,620 --> 00:13:17,490
deeper look you know in a moment so this

00:13:15,030 --> 00:13:20,340
works similarly as pure component works

00:13:17,490 --> 00:13:24,300
for class components just

00:13:20,340 --> 00:13:26,340
the exact the exact effect it's only but

00:13:24,300 --> 00:13:31,740
this but react memo is used for function

00:13:26,340 --> 00:13:35,730
components one one thing to mention the

00:13:31,740 --> 00:13:38,310
cache size of all these api is is one so

00:13:35,730 --> 00:13:41,280
you cannot react doesn't store multiple

00:13:38,310 --> 00:13:44,970
multiple results for this for this memo

00:13:41,280 --> 00:13:48,570
is the methods the only the only catch

00:13:44,970 --> 00:13:51,540
the last result and that's why you're

00:13:48,570 --> 00:13:53,910
gonna see that you will you you will

00:13:51,540 --> 00:13:57,600
need to specify when to recalculate I

00:13:53,910 --> 00:14:00,300
mean the first time you use it react

00:13:57,600 --> 00:14:03,570
will will memorize will basically cache

00:14:00,300 --> 00:14:06,300
the result and you will need to tell it

00:14:03,570 --> 00:14:09,810
when to invalidate those results but

00:14:06,300 --> 00:14:12,240
we're gonna see in more detail in a

00:14:09,810 --> 00:14:14,910
second okay

00:14:12,240 --> 00:14:19,980
moving forward let's say that you have

00:14:14,910 --> 00:14:21,990
another another component that you and

00:14:19,980 --> 00:14:24,630
inside of it you need to calculate some

00:14:21,990 --> 00:14:27,180
factorial or some some function that

00:14:24,630 --> 00:14:31,260
take that could take a long time to to

00:14:27,180 --> 00:14:35,280
run so if you want to memorize this the

00:14:31,260 --> 00:14:38,880
result of this dysfunction you you could

00:14:35,280 --> 00:14:42,480
use react use memo which takes two

00:14:38,880 --> 00:14:45,630
parameters the first one is a is a

00:14:42,480 --> 00:14:48,180
callback is a function which result

00:14:45,630 --> 00:14:52,440
should be should be cached and the

00:14:48,180 --> 00:14:55,430
second is an array of of dependencies so

00:14:52,440 --> 00:14:59,940
you basically are telling reactives memo

00:14:55,430 --> 00:15:03,240
when to recalculate the result of this

00:14:59,940 --> 00:15:06,570
function it will basically say that in

00:15:03,240 --> 00:15:10,170
this case I pass I pass in the this

00:15:06,570 --> 00:15:14,280
variable on earth and whenever this

00:15:10,170 --> 00:15:17,630
thing changes this dysfunction should be

00:15:14,280 --> 00:15:19,740
recalculated and the results put into

00:15:17,630 --> 00:15:26,300
into this constant the type that I

00:15:19,740 --> 00:15:28,890
created I also mentioned I use call back

00:15:26,300 --> 00:15:32,310
at the beginning so the difference

00:15:28,890 --> 00:15:34,040
between use memo and use callback is use

00:15:32,310 --> 00:15:37,440
memo basically

00:15:34,040 --> 00:15:40,410
execute this dysfunction the first

00:15:37,440 --> 00:15:43,970
parameter that we pass use call Becker

00:15:40,410 --> 00:15:49,080
returns a memorized callback function

00:15:43,970 --> 00:15:51,660
this is a the only difference and also

00:15:49,080 --> 00:15:55,950
you score Becker is basically a more

00:15:51,660 --> 00:16:00,300
specialized version of use memo we can

00:15:55,950 --> 00:16:06,110
rewrite this this kind of code here

00:16:00,300 --> 00:16:08,190
using use memo hook basically you return

00:16:06,110 --> 00:16:12,120
you pass in a function that returns

00:16:08,190 --> 00:16:15,630
another function basically the defect is

00:16:12,120 --> 00:16:17,520
the same but enough with with the theory

00:16:15,630 --> 00:16:19,920
let's jump into the code because I think

00:16:17,520 --> 00:16:24,930
it's gonna be much easier to understand

00:16:19,920 --> 00:16:28,580
how everything everything works so I

00:16:24,930 --> 00:16:32,339
have here a very very small application

00:16:28,580 --> 00:16:35,430
we have some toggle here at the top and

00:16:32,339 --> 00:16:38,880
we have a list of items and each item

00:16:35,430 --> 00:16:41,130
has some text it's a very simple data

00:16:38,880 --> 00:16:49,470
structure and a button that increments

00:16:41,130 --> 00:16:51,900
something something here let's open this

00:16:49,470 --> 00:16:55,950
I mean I don't think we need this at the

00:16:51,900 --> 00:16:58,820
moment okay so having this application

00:16:55,950 --> 00:17:01,800
everything is really snappy probably you

00:16:58,820 --> 00:17:03,570
it's it's a bit more difficult to see

00:17:01,800 --> 00:17:06,230
but everything it works really really

00:17:03,570 --> 00:17:08,250
really fast right and because we have

00:17:06,230 --> 00:17:10,829
this application doesn't do a lot

00:17:08,250 --> 00:17:12,980
doesn't have a lot of elements it it

00:17:10,829 --> 00:17:16,470
doesn't do a lot of heavy complications

00:17:12,980 --> 00:17:21,569
so let's instead of rendering five items

00:17:16,470 --> 00:17:24,900
let's render hundred items so now I have

00:17:21,569 --> 00:17:26,339
a more items on the page and if I press

00:17:24,900 --> 00:17:28,620
these buttons here

00:17:26,339 --> 00:17:31,200
everything works again really really

00:17:28,620 --> 00:17:32,790
really well I mean really fast again we

00:17:31,200 --> 00:17:39,150
don't have we don't have any performance

00:17:32,790 --> 00:17:43,170
problems so if we look a bit at the Dom

00:17:39,150 --> 00:17:45,150
structure so it's true that we have a

00:17:43,170 --> 00:17:47,550
lot of elements but the elements are

00:17:45,150 --> 00:17:50,460
really are very simple right

00:17:47,550 --> 00:17:52,560
we have only some leaves and a small

00:17:50,460 --> 00:17:53,010
element and that's it right on the

00:17:52,560 --> 00:17:55,950
button

00:17:53,010 --> 00:18:00,750
so there are intend many many elements

00:17:55,950 --> 00:18:03,060
in in the dom so but this is not a very

00:18:00,750 --> 00:18:05,430
I don't know a very a real case scenario

00:18:03,060 --> 00:18:08,310
because in a real application you would

00:18:05,430 --> 00:18:12,150
have much more elements used either for

00:18:08,310 --> 00:18:14,430
for styling or for layout right so your

00:18:12,150 --> 00:18:20,810
your regular applications are not that

00:18:14,430 --> 00:18:20,810
not that simple so I have created here

00:18:21,860 --> 00:18:27,540
well first of all let's go through the

00:18:24,870 --> 00:18:36,290
application just to so we are on the

00:18:27,540 --> 00:18:36,290
same page okay so let's open the

00:18:36,920 --> 00:18:42,840
components you can go through the

00:18:41,730 --> 00:18:45,900
structure of the application very

00:18:42,840 --> 00:18:48,630
quickly so we are on the same page so

00:18:45,900 --> 00:18:51,930
I'm rendering on an application that

00:18:48,630 --> 00:18:54,180
receives an array of items this array of

00:18:51,930 --> 00:18:56,250
items is a very simple data structure a

00:18:54,180 --> 00:18:58,590
name or description which are two

00:18:56,250 --> 00:19:00,080
strings and a quantity property which is

00:18:58,590 --> 00:19:03,120
which is a number

00:19:00,080 --> 00:19:06,450
these are passed to to the app as you

00:19:03,120 --> 00:19:11,640
can see here now if I go to the app

00:19:06,450 --> 00:19:14,630
component I have I have a label and an

00:19:11,640 --> 00:19:16,710
input which are these two at at the top

00:19:14,630 --> 00:19:19,920
and I have a list component that

00:19:16,710 --> 00:19:22,680
receives the list of items I go to the

00:19:19,920 --> 00:19:26,310
list component I see it it's only a

00:19:22,680 --> 00:19:29,270
table that renders in the body it

00:19:26,310 --> 00:19:34,410
renders the list of list of items and

00:19:29,270 --> 00:19:38,700
each item is a is a table row with some

00:19:34,410 --> 00:19:43,770
table table cells and I have the button

00:19:38,700 --> 00:19:46,500
that increments this discount here so

00:19:43,770 --> 00:19:51,270
here I have a very special name

00:19:46,500 --> 00:19:55,110
component that receives this drop and if

00:19:51,270 --> 00:20:00,809
I change this depth to one and if we

00:19:55,110 --> 00:20:04,899
look at the Dom at the Dom tree

00:20:00,809 --> 00:20:09,519
you see that each each letter of this

00:20:04,899 --> 00:20:15,999
title is wrapped in a span element so if

00:20:09,519 --> 00:20:19,899
I pass to here each letter is wrapped in

00:20:15,999 --> 00:20:22,809
two spends so i basically simulate more

00:20:19,899 --> 00:20:25,690
more elements being being in the

00:20:22,809 --> 00:20:29,590
application so let's put here for

00:20:25,690 --> 00:20:32,470
instance let's say ten depth of ten so

00:20:29,590 --> 00:20:38,429
each letter of of this string here is

00:20:32,470 --> 00:20:41,830
wrapped in ten spans so I have much more

00:20:38,429 --> 00:20:45,970
much more HTML elements inside my

00:20:41,830 --> 00:20:48,879
application now I don't know if it if

00:20:45,970 --> 00:20:51,159
you notice it on the stream but now when

00:20:48,879 --> 00:20:54,609
I press when I push those buttons it

00:20:51,159 --> 00:20:57,639
takes some time to see the D updated the

00:20:54,609 --> 00:21:01,869
result in the page the same with this

00:20:57,639 --> 00:21:06,279
toggle toggle checkbox here so in order

00:21:01,869 --> 00:21:09,489
to show you what this because it takes a

00:21:06,279 --> 00:21:14,169
take some time to get it done let's go

00:21:09,489 --> 00:21:18,070
to the to the profiler so reactor dev

00:21:14,169 --> 00:21:21,190
tools have also has this profiler that

00:21:18,070 --> 00:21:23,710
we can use to profile our application so

00:21:21,190 --> 00:21:26,470
if you open a profiler and you start

00:21:23,710 --> 00:21:33,639
profiling and you start clicking your

00:21:26,470 --> 00:21:38,019
application and you stop it then we can

00:21:33,639 --> 00:21:40,139
see here I clicked three times and you

00:21:38,019 --> 00:21:44,320
can see each each state update

00:21:40,139 --> 00:21:46,419
represented represented here so you can

00:21:44,320 --> 00:21:49,659
see that the render duration of all the

00:21:46,419 --> 00:21:53,320
application took 120 milliseconds which

00:21:49,659 --> 00:21:57,039
is like a lot for just to update like

00:21:53,320 --> 00:22:01,029
one one very small string on the on the

00:21:57,039 --> 00:22:04,659
screen so what's the what's the problem

00:22:01,029 --> 00:22:11,259
here because if we look at the Dom tree

00:22:04,659 --> 00:22:13,269
and we look at this element here we can

00:22:11,259 --> 00:22:14,500
see that when I push this button only

00:22:13,269 --> 00:22:16,630
this

00:22:14,500 --> 00:22:19,660
particular cell updates you can see that

00:22:16,630 --> 00:22:20,980
it's highlighted here in the in the dev

00:22:19,660 --> 00:22:23,130
tools when I when I push the button

00:22:20,980 --> 00:22:25,900
because the dev tools

00:22:23,130 --> 00:22:29,440
highlights when when an element changes

00:22:25,900 --> 00:22:31,990
so even if only this element changes in

00:22:29,440 --> 00:22:35,950
in the Dom it takes also a long time or

00:22:31,990 --> 00:22:38,710
two to get the result there and the

00:22:35,950 --> 00:22:42,550
problem is that I have so it's basically

00:22:38,710 --> 00:22:46,590
how reactor treats a state states

00:22:42,550 --> 00:22:51,070
changes react is really dumb in in

00:22:46,590 --> 00:22:53,620
updating the Dom and when I say this I I

00:22:51,070 --> 00:22:56,800
mean that it doesn't know what actually

00:22:53,620 --> 00:22:58,060
happened what actually changed so it

00:22:56,800 --> 00:23:00,340
doesn't know that when I push this

00:22:58,060 --> 00:23:04,480
button it should update only this small

00:23:00,340 --> 00:23:06,400
part of the application this is a for

00:23:04,480 --> 00:23:08,680
instance in view or in angular they are

00:23:06,400 --> 00:23:11,530
much smarter in this regard they know

00:23:08,680 --> 00:23:13,810
what needs to be to be updated but to

00:23:11,530 --> 00:23:17,590
react needs to compute needs to

00:23:13,810 --> 00:23:19,540
calculate what's don't update signet it

00:23:17,590 --> 00:23:21,550
needs to do and it does this through the

00:23:19,540 --> 00:23:24,190
reconciliation process that you probably

00:23:21,550 --> 00:23:26,530
heard of so basically you have one

00:23:24,190 --> 00:23:28,630
virtual Dom that is created when you

00:23:26,530 --> 00:23:30,730
initialize the application the virtual

00:23:28,630 --> 00:23:32,980
DOM is a data structure that contains

00:23:30,730 --> 00:23:37,240
all the structure of your of your

00:23:32,980 --> 00:23:40,870
application when you do some state

00:23:37,240 --> 00:23:43,330
change or using set state or using the

00:23:40,870 --> 00:23:46,030
you state hook or whatever change you do

00:23:43,330 --> 00:23:47,830
to the to the application react

00:23:46,030 --> 00:23:51,100
creates another virtual Dom a new

00:23:47,830 --> 00:23:53,050
virtual Dom basically it has to compare

00:23:51,100 --> 00:23:55,570
the two in order to figure out what are

00:23:53,050 --> 00:23:58,120
the minimal updates that it needs to

00:23:55,570 --> 00:24:03,130
perform and when it creates this virtual

00:23:58,120 --> 00:24:05,980
Dom this is performed by basically

00:24:03,130 --> 00:24:08,830
executing all of your functions in your

00:24:05,980 --> 00:24:11,460
application so every component so this

00:24:08,830 --> 00:24:15,150
this named component this is a function

00:24:11,460 --> 00:24:19,240
this item component this is a function

00:24:15,150 --> 00:24:22,780
every every element you have in your JSX

00:24:19,240 --> 00:24:24,310
syntax this is a function the small tag

00:24:22,780 --> 00:24:26,980
is a function everything is a function

00:24:24,310 --> 00:24:28,370
so basically when it creates the the Dom

00:24:26,980 --> 00:24:31,520
tree it needs to execute

00:24:28,370 --> 00:24:34,040
dysfunctions so probably seeing all

00:24:31,520 --> 00:24:36,470
these all these spans here that that I

00:24:34,040 --> 00:24:38,600
have in my dumb tree all of these are

00:24:36,470 --> 00:24:41,120
faster that these two to get executed so

00:24:38,600 --> 00:24:47,150
the more you have the the more time it

00:24:41,120 --> 00:24:52,160
takes right even though nothing so

00:24:47,150 --> 00:24:54,590
consider this toggle for instance react

00:24:52,160 --> 00:24:56,360
needs to calculate everything in the

00:24:54,590 --> 00:24:59,480
entire application even though I only

00:24:56,360 --> 00:25:00,980
change this small thing here so this is

00:24:59,480 --> 00:25:04,850
basically what we need to accomplish

00:25:00,980 --> 00:25:08,179
today to tell react that it doesn't need

00:25:04,850 --> 00:25:11,650
to rerender some parts of the

00:25:08,179 --> 00:25:19,250
application when it doesn't need to ok

00:25:11,650 --> 00:25:21,220
so going back to the to the profiler so

00:25:19,250 --> 00:25:26,720
let's do another profiling where I

00:25:21,220 --> 00:25:31,090
toggle wants this this checkbox here and

00:25:26,720 --> 00:25:31,090
once when I push this button here

00:25:32,050 --> 00:25:39,440
probably you can see a small difference

00:25:35,420 --> 00:25:42,230
between the two updates so the first one

00:25:39,440 --> 00:25:44,809
is the one that I that I push that I

00:25:42,230 --> 00:25:46,580
click the toggle and the second one is

00:25:44,809 --> 00:25:47,780
when I click the button here and when I

00:25:46,580 --> 00:25:51,320
click the button here you can see that

00:25:47,780 --> 00:25:53,540
the app here is is in grey and it tweets

00:25:51,320 --> 00:25:57,890
did not render during this profiling

00:25:53,540 --> 00:26:00,980
session but when I click the toggle it

00:25:57,890 --> 00:26:03,230
rerender the the app component as well

00:26:00,980 --> 00:26:07,520
so let's go to the app component and

00:26:03,230 --> 00:26:10,850
take a look at our application structure

00:26:07,520 --> 00:26:15,800
here so as you can see when I when I

00:26:10,850 --> 00:26:18,740
toggle this this checkbox the state that

00:26:15,800 --> 00:26:21,500
is toggled is defined on on the app

00:26:18,740 --> 00:26:25,429
component but when I push this buttons

00:26:21,500 --> 00:26:28,670
here those buttons are inside the list

00:26:25,429 --> 00:26:31,040
the list component which is a separate

00:26:28,670 --> 00:26:35,510
component so react is smart enough to

00:26:31,040 --> 00:26:38,150
some extent to know that it only needs

00:26:35,510 --> 00:26:39,679
to to rerender a part of the entire

00:26:38,150 --> 00:26:42,080
application so a subtree of the

00:26:39,679 --> 00:26:46,190
application whenever the states

00:26:42,080 --> 00:26:49,700
the state update took place so in this

00:26:46,190 --> 00:26:51,980
situation because the the input the

00:26:49,700 --> 00:26:54,950
checkbox is on the app component it

00:26:51,980 --> 00:26:58,399
needs to render the entire the entire

00:26:54,950 --> 00:27:00,140
application and when you update when we

00:26:58,399 --> 00:27:02,360
update something inside the the list

00:27:00,140 --> 00:27:04,460
component then only only the list

00:27:02,360 --> 00:27:08,750
component and all its children needs to

00:27:04,460 --> 00:27:10,640
need needs to be render so the first

00:27:08,750 --> 00:27:13,010
thing that that you could do and

00:27:10,640 --> 00:27:14,919
probably is something that you you can

00:27:13,010 --> 00:27:17,630
apply without any knowledge of rendering

00:27:14,919 --> 00:27:21,559
optimizations you could create a new

00:27:17,630 --> 00:27:24,039
component a separate component only only

00:27:21,559 --> 00:27:26,600
for this for this toggle and to put the

00:27:24,039 --> 00:27:29,450
state inside that component so basically

00:27:26,600 --> 00:27:31,580
if I would if I would take this code and

00:27:29,450 --> 00:27:36,049
this code and create a new component

00:27:31,580 --> 00:27:38,389
then when I would toggle when I would

00:27:36,049 --> 00:27:41,240
would change the state of this toggle it

00:27:38,389 --> 00:27:43,940
won't rerender all the entire all the

00:27:41,240 --> 00:27:46,909
other components because it it will only

00:27:43,940 --> 00:27:49,639
update the subtree of this small

00:27:46,909 --> 00:27:53,210
component but in case I would need to

00:27:49,639 --> 00:27:56,419
access the state from from the

00:27:53,210 --> 00:27:59,809
application component then I would

00:27:56,419 --> 00:28:01,760
basically need to put the state back in

00:27:59,809 --> 00:28:04,429
the in the function component so

00:28:01,760 --> 00:28:08,590
basically I'm back to square one so it

00:28:04,429 --> 00:28:12,470
doesn't it doesn't fix my problem so

00:28:08,590 --> 00:28:15,649
let's take another approach so as I said

00:28:12,470 --> 00:28:17,659
when I click this this toggle here I

00:28:15,649 --> 00:28:20,990
don't need to render the entire list

00:28:17,659 --> 00:28:24,590
because it doesn't change so if the list

00:28:20,990 --> 00:28:28,700
doesn't change I could instead instead

00:28:24,590 --> 00:28:31,610
of exporting delete the list I could

00:28:28,700 --> 00:28:38,419
export a memorized list using the

00:28:31,610 --> 00:28:47,410
reactor memo API so if I go and do

00:28:38,419 --> 00:28:50,809
another profiling now you can see

00:28:47,410 --> 00:28:53,210
here I see the list component and it's

00:28:50,809 --> 00:28:55,760
also mentioned that it's um it's

00:28:53,210 --> 00:28:57,740
memorized you can see the memo here and

00:28:55,760 --> 00:29:00,380
it reads that you thought did not render

00:28:57,740 --> 00:29:04,580
during this profiling session right so

00:29:00,380 --> 00:29:09,050
basically only what was rendered maybe I

00:29:04,580 --> 00:29:10,730
could let's look at the rank chart so

00:29:09,050 --> 00:29:12,770
only the app component the input

00:29:10,730 --> 00:29:17,620
component and the label were rear-ended

00:29:12,770 --> 00:29:17,620
during this during the state's change

00:29:17,679 --> 00:29:22,760
the list the table and everything below

00:29:20,030 --> 00:29:25,280
wasn't rendered so this is this was very

00:29:22,760 --> 00:29:28,460
fast it took only one millisecond to

00:29:25,280 --> 00:29:30,260
tree render so basically a part of a

00:29:28,460 --> 00:29:35,390
photo problem a part of our problem was

00:29:30,260 --> 00:29:44,800
fixed only using this this this API to

00:29:35,390 --> 00:29:46,610
memorize our our list cool but when I

00:29:44,800 --> 00:29:50,870
press this buttons

00:29:46,610 --> 00:29:55,460
let's profile this again when I push

00:29:50,870 --> 00:29:58,850
these buttons I can see that even if I

00:29:55,460 --> 00:30:02,300
I only change the state of one item here

00:29:58,850 --> 00:30:05,450
I can see that all the other all the

00:30:02,300 --> 00:30:07,850
other table rows are updated so when you

00:30:05,450 --> 00:30:09,980
look at this profiling tool whenever you

00:30:07,850 --> 00:30:12,890
see gray that means that it wasn't

00:30:09,980 --> 00:30:16,460
rendered when you see some color being

00:30:12,890 --> 00:30:21,350
this one ASEAN or green or whatever it

00:30:16,460 --> 00:30:23,690
is or if it's a this orange it means

00:30:21,350 --> 00:30:26,900
that's the the component re-rendered so

00:30:23,690 --> 00:30:30,350
this is not this is not good so let's

00:30:26,900 --> 00:30:35,090
fix this problem in the next step so

00:30:30,350 --> 00:30:39,080
let's let's tell react not to render I

00:30:35,090 --> 00:30:42,679
mean to to only to render the item that

00:30:39,080 --> 00:30:44,030
that was basically updated so let's

00:30:42,679 --> 00:30:46,570
apply the same principle that we did

00:30:44,030 --> 00:30:49,460
here let's applied to to the item

00:30:46,570 --> 00:30:55,360
because in our list component I render a

00:30:49,460 --> 00:31:00,669
bunch of items so let's also apply react

00:30:55,360 --> 00:31:00,669
dot memo and the item component

00:31:01,630 --> 00:31:11,420
now let's do another profiling session

00:31:07,480 --> 00:31:13,340
and you can see that nothing has changed

00:31:11,420 --> 00:31:15,490
right so I didn't fix our problems all

00:31:13,340 --> 00:31:19,100
the components are still are still

00:31:15,490 --> 00:31:20,600
re-rendered if you if you would like to

00:31:19,100 --> 00:31:23,090
see which components are you render you

00:31:20,600 --> 00:31:26,390
can go here in the settings and I think

00:31:23,090 --> 00:31:28,160
it's in the general general tab there is

00:31:26,390 --> 00:31:33,680
this check box that says highlight

00:31:28,160 --> 00:31:37,520
updates when components render so now

00:31:33,680 --> 00:31:43,870
when I when I click this this button you

00:31:37,520 --> 00:31:48,040
can see these things updating here ok so

00:31:43,870 --> 00:31:51,230
we don't know why exactly our components

00:31:48,040 --> 00:31:53,600
all these all these table rows are

00:31:51,230 --> 00:31:58,940
rendered because we put react memo here

00:31:53,600 --> 00:32:01,700
and well react memo what what does it do

00:31:58,940 --> 00:32:04,160
exactly as I said it works similar to

00:32:01,700 --> 00:32:06,920
pure component for class components so

00:32:04,160 --> 00:32:11,390
it looks at all the props it receives

00:32:06,920 --> 00:32:14,480
and if if any of the props changes then

00:32:11,390 --> 00:32:16,730
it it will do a rerender but if any of

00:32:14,480 --> 00:32:19,460
the props or if all of the props didn't

00:32:16,730 --> 00:32:21,920
didn't change then it it won't render

00:32:19,460 --> 00:32:24,650
the component so we have here an item

00:32:21,920 --> 00:32:28,070
which is an object and an increment

00:32:24,650 --> 00:32:34,820
there is a is the function so let's see

00:32:28,070 --> 00:32:37,850
how our this past well the item is a the

00:32:34,820 --> 00:32:41,600
item is an object this is a best from

00:32:37,850 --> 00:32:45,380
this mapping here of the array this is

00:32:41,600 --> 00:32:49,010
not a problem because this is the

00:32:45,380 --> 00:32:51,710
updates the increment the the increment

00:32:49,010 --> 00:32:54,980
works similarly to how you would use the

00:32:51,710 --> 00:32:57,230
Redux I used here I use reducer I won't

00:32:54,980 --> 00:32:59,270
get into the details because it is out

00:32:57,230 --> 00:33:02,060
of scope but it works it works similar

00:32:59,270 --> 00:33:05,690
like like Redux so this is not not a

00:33:02,060 --> 00:33:07,580
problem also there is this increment

00:33:05,690 --> 00:33:11,030
function that is best let us create it

00:33:07,580 --> 00:33:11,960
here and we only pass the reference to

00:33:11,030 --> 00:33:15,950
this in

00:33:11,960 --> 00:33:19,640
and function so let's if you go to the

00:33:15,950 --> 00:33:22,250
to the settings here in the profiler you

00:33:19,640 --> 00:33:24,920
have another chat box that the treats

00:33:22,250 --> 00:33:27,650
record why each component rendered while

00:33:24,920 --> 00:33:31,880
profiling so let's check let's check

00:33:27,650 --> 00:33:40,490
this this one and do another profiling

00:33:31,880 --> 00:33:42,830
session so if I go to the list the list

00:33:40,490 --> 00:33:46,370
component you can read here why did this

00:33:42,830 --> 00:33:48,740
render so it says hooks changed okay

00:33:46,370 --> 00:33:51,650
this makes sense because I some hooks

00:33:48,740 --> 00:33:55,910
change so okay might make sense but

00:33:51,650 --> 00:33:58,760
let's go to an item component so it says

00:33:55,910 --> 00:34:03,980
here why this dis rendered props changed

00:33:58,760 --> 00:34:05,780
Inc so basically this prop here or the

00:34:03,980 --> 00:34:09,530
function that was passed to Inc this

00:34:05,780 --> 00:34:13,220
changed between two two renders and this

00:34:09,530 --> 00:34:16,100
happened because list is a function and

00:34:13,220 --> 00:34:18,650
every time we call this function it will

00:34:16,100 --> 00:34:20,420
execute it so it will create a new

00:34:18,650 --> 00:34:23,930
function so this increment function is

00:34:20,420 --> 00:34:27,350
created again everytime we render the

00:34:23,930 --> 00:34:30,650
list component and we basically pass in

00:34:27,350 --> 00:34:32,990
a different different reference of the

00:34:30,650 --> 00:34:34,910
function so of course this changes

00:34:32,990 --> 00:34:39,560
between two renders so this is why all

00:34:34,910 --> 00:34:41,900
the item components are re-rendered so

00:34:39,560 --> 00:34:45,860
what we want here is basically to always

00:34:41,900 --> 00:34:47,510
pass the same reference to to the item

00:34:45,860 --> 00:34:51,080
components because this doesn't actually

00:34:47,510 --> 00:34:53,330
change between two or two renders it

00:34:51,080 --> 00:34:55,730
would make sense to move the function

00:34:53,330 --> 00:34:59,720
outside of this component so let's say

00:34:55,730 --> 00:35:00,290
somewhere here this would fix our

00:34:59,720 --> 00:35:01,970
problem

00:35:00,290 --> 00:35:04,460
because we now we would have only one

00:35:01,970 --> 00:35:08,240
reference or that won't change between

00:35:04,460 --> 00:35:11,660
two two renders but we don't have access

00:35:08,240 --> 00:35:16,130
to this dispatch which comes from from

00:35:11,660 --> 00:35:20,590
my user use reducer hook so it is not

00:35:16,130 --> 00:35:20,590
good so let's try a different approach

00:35:23,730 --> 00:35:29,920
instead of passing the increment

00:35:26,260 --> 00:35:37,510
function to to our components let's

00:35:29,920 --> 00:35:43,210
create a new optimized increment which

00:35:37,510 --> 00:35:45,160
is a react dot use callback then I said

00:35:43,210 --> 00:35:47,619
use callback receives two arguments

00:35:45,160 --> 00:35:50,109
first is a function that should be

00:35:47,619 --> 00:35:53,230
memorized so our function is increment

00:35:50,109 --> 00:35:58,109
and the second is a an array of

00:35:53,230 --> 00:36:02,500
dependencies so when do we need this

00:35:58,109 --> 00:36:04,720
this function to return the new a new

00:36:02,500 --> 00:36:08,920
reference so basically we don't want to

00:36:04,720 --> 00:36:12,039
return a new reference only once right

00:36:08,920 --> 00:36:15,309
we don't need to dysfunction to truly

00:36:12,039 --> 00:36:19,869
return a new reference so if you pass

00:36:15,309 --> 00:36:23,559
this optimized increment to our item

00:36:19,869 --> 00:36:30,039
component and that let's do a new

00:36:23,559 --> 00:36:32,440
profiling session you would see that all

00:36:30,039 --> 00:36:35,019
the items didn't rerender during this

00:36:32,440 --> 00:36:37,809
profiling session and if we go to the to

00:36:35,019 --> 00:36:39,430
the second to a secondary render we can

00:36:37,809 --> 00:36:42,369
see that the second item component

00:36:39,430 --> 00:36:44,740
rerender and in the first in the first

00:36:42,369 --> 00:36:46,869
update only the first one rendered right

00:36:44,740 --> 00:36:51,220
you can also see here in the UI that

00:36:46,869 --> 00:36:58,740
this highlighted what what elements are

00:36:51,220 --> 00:36:58,740
rendered during this state update okay

00:36:58,829 --> 00:37:10,589
so two two out of three let's for the

00:37:05,559 --> 00:37:14,559
last part let me make a quick change to

00:37:10,589 --> 00:37:18,250
the second item here so in this

00:37:14,559 --> 00:37:21,480
description I have the description here

00:37:18,250 --> 00:37:27,180
and I will modify it I will add more

00:37:21,480 --> 00:37:27,180
letters here we'll see in a minute why

00:37:28,140 --> 00:37:35,690
okay

00:37:30,500 --> 00:37:39,830
so probably so I have here some some

00:37:35,690 --> 00:37:41,270
emojis that are displayed there display

00:37:39,830 --> 00:37:43,910
based on some regular expression that

00:37:41,270 --> 00:37:44,800
I'm gonna I'm gonna present in that in a

00:37:43,910 --> 00:37:50,210
second

00:37:44,800 --> 00:37:57,680
but if we do let's do a profiling on the

00:37:50,210 --> 00:38:17,480
rerender one second let me add a bit

00:37:57,680 --> 00:38:20,570
more C's here so when i when i when i

00:38:17,480 --> 00:38:24,109
incremented the the first item it took

00:38:20,570 --> 00:38:26,240
seven milliseconds when i updated the

00:38:24,109 --> 00:38:28,340
second item it took like one second and

00:38:26,240 --> 00:38:33,859
something so it's really really huge

00:38:28,340 --> 00:38:35,660
difference between the two now I don't

00:38:33,859 --> 00:38:37,670
know exactly why this happened I mean I

00:38:35,660 --> 00:38:39,500
know because I wrote the code but let's

00:38:37,670 --> 00:38:42,349
let's say that you don't know why

00:38:39,500 --> 00:38:48,050
something renders a what white takes a

00:38:42,349 --> 00:38:51,290
long time to to render so it's not

00:38:48,050 --> 00:38:54,440
something that is coming from our from

00:38:51,290 --> 00:38:56,240
our react code that is is executed it's

00:38:54,440 --> 00:39:02,570
not something that comes from react

00:38:56,240 --> 00:39:07,369
rendering or something let's go to to

00:39:02,570 --> 00:39:10,490
the performance tab for a second you can

00:39:07,369 --> 00:39:15,380
do also profiling using the performance

00:39:10,490 --> 00:39:18,260
tab or from our reactor dev tools just

00:39:15,380 --> 00:39:22,070
click some buttons to make some updates

00:39:18,260 --> 00:39:25,609
in your applications and then let me

00:39:22,070 --> 00:39:30,130
expand this a bit so here on the

00:39:25,609 --> 00:39:34,099
timeline whenever you see these yellow

00:39:30,130 --> 00:39:36,380
yellow spikes this is a scripting

00:39:34,099 --> 00:39:38,980
scripting means that basically it's time

00:39:36,380 --> 00:39:45,290
spent executing the JavaScript code you

00:39:38,980 --> 00:39:48,410
can see this huge blob of yellow

00:39:45,290 --> 00:39:50,510
which occurred when when I click the the

00:39:48,410 --> 00:39:53,690
second button and you can also see this

00:39:50,510 --> 00:39:56,600
red here telling you that also this is a

00:39:53,690 --> 00:40:02,060
long task it took more than a half or

00:39:56,600 --> 00:40:04,970
more than when more than a second so

00:40:02,060 --> 00:40:07,100
here if you if you have this it's very

00:40:04,970 --> 00:40:09,800
important to not have this check box

00:40:07,100 --> 00:40:11,960
enabled so not to disable JavaScript

00:40:09,800 --> 00:40:14,180
samples and if you don't have this

00:40:11,960 --> 00:40:18,109
checked and you and you go here in the I

00:40:14,180 --> 00:40:21,470
think in the bottom up having selected

00:40:18,109 --> 00:40:23,060
the the part of the code that you can

00:40:21,470 --> 00:40:24,830
see that okay this is not good when you

00:40:23,060 --> 00:40:26,630
see something this a lot of a lot of

00:40:24,830 --> 00:40:29,930
yellow it means that a lot of JavaScript

00:40:26,630 --> 00:40:32,510
code was executed during the during this

00:40:29,930 --> 00:40:36,500
period of time you can see here that

00:40:32,510 --> 00:40:38,930
there is an reg X that is executed that

00:40:36,500 --> 00:40:42,140
took a long time like almost one and a

00:40:38,930 --> 00:40:46,510
half seconds and this comes from a

00:40:42,140 --> 00:40:50,720
problematic red X which comes from item

00:40:46,510 --> 00:40:55,820
component right so basically it knows

00:40:50,720 --> 00:41:00,260
what was executed during during your

00:40:55,820 --> 00:41:02,570
application updates and can pinpoint the

00:41:00,260 --> 00:41:07,580
exact line of code where this took place

00:41:02,570 --> 00:41:11,570
so in my my situation it comes it came

00:41:07,580 --> 00:41:14,750
from this item component where I execute

00:41:11,570 --> 00:41:19,010
this programmatic reg X right so this is

00:41:14,750 --> 00:41:21,410
the the code with with the problem so

00:41:19,010 --> 00:41:25,730
let me go to my item component to

00:41:21,410 --> 00:41:30,470
explain you in a second what is going on

00:41:25,730 --> 00:41:35,390
here so this is a my I have a I have a

00:41:30,470 --> 00:41:38,359
it's a very simple but to be the regular

00:41:35,390 --> 00:41:41,020
expression that if you pass a certain

00:41:38,359 --> 00:41:43,850
string to it it goes into a really

00:41:41,020 --> 00:41:46,580
aggressive backtrack backtracking

00:41:43,850 --> 00:41:51,020
recursion and it takes a long time to

00:41:46,580 --> 00:41:54,710
execute so whenever you have a some

00:41:51,020 --> 00:41:56,330
function that could take it's it's

00:41:54,710 --> 00:41:58,359
potential to take a long time to execute

00:41:56,330 --> 00:42:01,690
like I don't know

00:41:58,359 --> 00:42:05,869
transforming some large strings or

00:42:01,690 --> 00:42:09,230
parsing a huge markdown on or large

00:42:05,869 --> 00:42:11,480
images or processing large images or any

00:42:09,230 --> 00:42:15,440
anything that any function that would

00:42:11,480 --> 00:42:17,960
take a long time to to run this is a

00:42:15,440 --> 00:42:19,730
good place to to add memoization to

00:42:17,960 --> 00:42:23,539
memorize the result of that function

00:42:19,730 --> 00:42:26,450
especially when the result doesn't

00:42:23,539 --> 00:42:30,410
change that frequently so in my

00:42:26,450 --> 00:42:35,270
situation in my in my use case this reg

00:42:30,410 --> 00:42:36,799
X there is this displays one emoji or

00:42:35,270 --> 00:42:39,039
the other it doesn't matter exactly what

00:42:36,799 --> 00:42:42,260
it does so that's that's not a problem

00:42:39,039 --> 00:42:44,680
it receives this the description of the

00:42:42,260 --> 00:42:49,849
item description of the item is this

00:42:44,680 --> 00:42:52,039
this string over here which doesn't we

00:42:49,849 --> 00:42:54,680
doesn't change when when I press this

00:42:52,039 --> 00:42:56,690
this button here pressing this button

00:42:54,680 --> 00:43:00,650
only up is the quantity it doesn't

00:42:56,690 --> 00:43:02,960
affect the description of the of the

00:43:00,650 --> 00:43:06,220
item so this basically doesn't need to

00:43:02,960 --> 00:43:11,150
read to get reacts acutely every time I

00:43:06,220 --> 00:43:14,839
render the items so it's a good it's a

00:43:11,150 --> 00:43:25,210
good place to to use memoization so we

00:43:14,839 --> 00:43:27,859
can you can use the other react use memo

00:43:25,210 --> 00:43:30,650
so this is a hook it's different from

00:43:27,859 --> 00:43:33,380
reactant memo react to use memo is a

00:43:30,650 --> 00:43:38,119
hook that is is used inside the

00:43:33,380 --> 00:43:40,400
components and use memo works just like

00:43:38,119 --> 00:43:43,900
you scroll back it receives two

00:43:40,400 --> 00:43:49,490
arguments the first is a function that

00:43:43,900 --> 00:43:52,609
returns your result and the other is an

00:43:49,490 --> 00:43:58,670
array of dependencies so I would like

00:43:52,609 --> 00:44:00,980
this this function to to or to trick to

00:43:58,670 --> 00:44:05,630
be recomputed whenever this item

00:44:00,980 --> 00:44:07,069
description changes because it the

00:44:05,630 --> 00:44:10,520
description is the dependence basically

00:44:07,069 --> 00:44:11,599
off of this of this function that I'm

00:44:10,520 --> 00:44:14,119
trying to call

00:44:11,599 --> 00:44:18,859
in my use case this will never happen

00:44:14,119 --> 00:44:25,660
but it's always good practice to put the

00:44:18,859 --> 00:44:25,660
dependencies in your in your memorized

00:44:26,019 --> 00:44:31,369
methods in order to avoid any problems

00:44:28,729 --> 00:44:34,249
on the long run otherwise if I don't if

00:44:31,369 --> 00:44:36,739
I don't specify this here whenever item

00:44:34,249 --> 00:44:38,839
description will change I will always

00:44:36,739 --> 00:44:41,329
get the the previous or the first

00:44:38,839 --> 00:44:48,589
calculated result it won't be recomputed

00:44:41,329 --> 00:44:51,619
which I don't want that okay so I have

00:44:48,589 --> 00:44:56,660
replaced the Easter eggs with with this

00:44:51,619 --> 00:44:58,759
memorized version of it and let's go I

00:44:56,660 --> 00:45:07,430
mean let's let's do another profiling

00:44:58,759 --> 00:45:10,279
here go to the performance clear it

00:45:07,430 --> 00:45:13,190
stopped and right now you can see some

00:45:10,279 --> 00:45:15,819
yellow spikes but they are basically the

00:45:13,190 --> 00:45:21,170
same the same height it takes really a

00:45:15,819 --> 00:45:25,160
short amount of time 19 milliseconds 19

00:45:21,170 --> 00:45:30,729
milliseconds to to update or to run to

00:45:25,160 --> 00:45:30,729
run JavaScript if I go to react profiler

00:45:31,779 --> 00:45:46,329
the same thing I see that all updates

00:45:37,119 --> 00:45:46,329
are rendered in a few milliseconds so

00:45:47,289 --> 00:45:59,299
let me go back to the presentation I can

00:45:52,640 --> 00:46:02,469
find it okay so one thing to to notice

00:45:59,299 --> 00:46:05,749
is that or to keep in mind is that any

00:46:02,469 --> 00:46:08,569
any performance optimizations should be

00:46:05,749 --> 00:46:11,479
treated like antibiotics when you take

00:46:08,569 --> 00:46:13,039
antibiotics I mean you should take

00:46:11,479 --> 00:46:14,539
antibiotics when you have a problem when

00:46:13,039 --> 00:46:16,099
you have an bacterial infection you

00:46:14,539 --> 00:46:18,890
won't take antibiotics when you have a

00:46:16,099 --> 00:46:20,150
viral infection or a fungus infection

00:46:18,890 --> 00:46:24,170
you only take them when you have

00:46:20,150 --> 00:46:25,160
bacterial infection and you have to to

00:46:24,170 --> 00:46:27,770
take into consideration that

00:46:25,160 --> 00:46:30,470
antibiotics are bad for your are bad for

00:46:27,770 --> 00:46:34,280
you right they they destroy your stomach

00:46:30,470 --> 00:46:36,799
that destroy and many many good things

00:46:34,280 --> 00:46:39,170
about the human body but you take them

00:46:36,799 --> 00:46:43,640
because well the situation is I've

00:46:39,170 --> 00:46:46,220
really really bad right so it's a you

00:46:43,640 --> 00:46:48,589
need to kill that bacteria because the

00:46:46,220 --> 00:46:52,400
bacterial infection is much more

00:46:48,589 --> 00:46:55,220
dangerous than the harm that the

00:46:52,400 --> 00:46:57,740
antibiotics does to you so this is the

00:46:55,220 --> 00:47:00,920
same as the memorization is basically

00:46:57,740 --> 00:47:03,770
the same thing it will add overhead to

00:47:00,920 --> 00:47:06,980
to your application so you shouldn't use

00:47:03,770 --> 00:47:09,230
it if you don't need it so basically you

00:47:06,980 --> 00:47:11,329
would only use all these methods that

00:47:09,230 --> 00:47:14,270
are that I that I presented here when

00:47:11,329 --> 00:47:15,770
you notice a problem a performance

00:47:14,270 --> 00:47:18,049
problem and you can measure it and you

00:47:15,770 --> 00:47:23,750
can prove that it's really it really

00:47:18,049 --> 00:47:25,390
takes place and before making any any

00:47:23,750 --> 00:47:27,920
optimization you should measure before

00:47:25,390 --> 00:47:31,430
make the optimizations measure

00:47:27,920 --> 00:47:34,460
afterwards to prove that well what -

00:47:31,430 --> 00:47:40,190
what you think you optimize actually has

00:47:34,460 --> 00:47:42,890
has a positive result with this I thank

00:47:40,190 --> 00:47:47,020
you this was my presentation for today

00:47:42,890 --> 00:47:52,240
you can follow me on Twitter on medium

00:47:47,020 --> 00:47:55,490
refugees that are oh and if you have any

00:47:52,240 --> 00:47:57,859
questions about react about

00:47:55,490 --> 00:48:04,220
optimizations about refugees I'm here to

00:47:57,859 --> 00:48:08,020
answer you happily I think we can let

00:48:04,220 --> 00:48:08,020
persons unmute themselves now

00:48:10,360 --> 00:48:13,559
[Music]

00:48:13,720 --> 00:48:22,270
I think there's a question in the chat

00:48:16,330 --> 00:48:26,530
room somebody asked if react memo uses

00:48:22,270 --> 00:48:37,420
shallow compare or props yes it does

00:48:26,530 --> 00:48:39,100
exactly like a pure component this is

00:48:37,420 --> 00:48:41,320
the short answer yeah it does

00:48:39,100 --> 00:48:48,280
it's it does a shallow shallow

00:48:41,320 --> 00:49:01,250
comparison people can unmute themselves

00:48:48,280 --> 00:49:04,220
now sorry for the delay hey thing

00:49:01,250 --> 00:49:08,480
presentation I would like to ask about

00:49:04,220 --> 00:49:11,810
channel compare what is from your point

00:49:08,480 --> 00:49:17,270
of view the best practice for compare

00:49:11,810 --> 00:49:21,400
maybe some other than primitives I mean

00:49:17,270 --> 00:49:21,400
compare part of object

00:49:22,270 --> 00:49:31,430
well objects are references right it

00:49:26,150 --> 00:49:40,760
just like just like functions so let me

00:49:31,430 --> 00:49:47,150
go quickly into code here so have you

00:49:40,760 --> 00:49:52,010
used the redux or set state yeah

00:49:47,150 --> 00:49:55,600
to explain my question I'm sorry I have

00:49:52,010 --> 00:50:00,470
a problem in the real example I have

00:49:55,600 --> 00:50:04,370
context and each second came a new

00:50:00,470 --> 00:50:09,050
result in context from let's say server

00:50:04,370 --> 00:50:14,420
right and this state in context is like

00:50:09,050 --> 00:50:18,340
an hash map an object hash map and some

00:50:14,420 --> 00:50:22,310
of keys some sum of values of some keys

00:50:18,340 --> 00:50:26,030
are really changed on every second but

00:50:22,310 --> 00:50:33,970
some not and I have a list like your

00:50:26,030 --> 00:50:33,970
table and each key represent the one of

00:50:34,240 --> 00:50:41,420
tables

00:50:35,810 --> 00:50:47,990
row and every second I have a like a

00:50:41,420 --> 00:50:52,700
tick for a to to rerender the table

00:50:47,990 --> 00:50:58,250
right and I cannot find the best

00:50:52,700 --> 00:51:06,919
solution to compare if I need the two

00:50:58,250 --> 00:51:12,229
rerender every every row you know well

00:51:06,919 --> 00:51:18,269
so - to make a bit more clear I

00:51:12,229 --> 00:51:23,339
subscribed so every roll subscribed to -

00:51:18,269 --> 00:51:29,779
context and every time every second the

00:51:23,339 --> 00:51:35,519
new object came from context whatever

00:51:29,779 --> 00:51:39,989
okay it's a bit difficult for me to to

00:51:35,519 --> 00:51:43,799
visualize your your exact use case the

00:51:39,989 --> 00:51:46,739
thing is that let's let's just assume

00:51:43,799 --> 00:51:48,449
that you have some some object in visit

00:51:46,739 --> 00:51:50,429
your context right I didn't have some

00:51:48,449 --> 00:51:57,509
some object there and let's say you have

00:51:50,429 --> 00:52:02,039
some some spider some of these that is

00:51:57,509 --> 00:52:05,130
in array of let's say other objects this

00:52:02,039 --> 00:52:07,859
is some very deeply nested data

00:52:05,130 --> 00:52:09,989
structure right because this is a

00:52:07,859 --> 00:52:14,849
reference this is another reference this

00:52:09,989 --> 00:52:20,150
is another reference right yep let's say

00:52:14,849 --> 00:52:24,390
okay so let's say that you only want

00:52:20,150 --> 00:52:30,299
these two these to update you are making

00:52:24,390 --> 00:52:34,259
an update to this element here so so

00:52:30,299 --> 00:52:41,390
let's say this is okay so you won't do

00:52:34,259 --> 00:52:41,390
something like this context of list of

00:52:42,709 --> 00:52:50,519
0.9 or some rot or equals something this

00:52:47,459 --> 00:52:54,209
would mean that you basically make make

00:52:50,519 --> 00:52:59,729
a mutation in this of this of this

00:52:54,209 --> 00:53:04,829
reference here so react won't know - to

00:52:59,729 --> 00:53:07,619
update that talk to to make a rerender

00:53:04,829 --> 00:53:09,719
this is some like a fundamental like

00:53:07,619 --> 00:53:12,689
fundamental thing about about react and

00:53:09,719 --> 00:53:15,929
if you use state or user or if you use

00:53:12,689 --> 00:53:18,900
redux or this is basically like a

00:53:15,929 --> 00:53:20,610
fundamental thing that you don't you you

00:53:18,900 --> 00:53:23,190
shouldn't do something like this

00:53:20,610 --> 00:53:25,980
so you basically would need to return a

00:53:23,190 --> 00:53:28,970
new reference of the of the context in

00:53:25,980 --> 00:53:33,090
the situation so you have to return a

00:53:28,970 --> 00:53:36,270
new a new reference of this object and

00:53:33,090 --> 00:53:40,320
you have to return to make lists like

00:53:36,270 --> 00:53:43,650
being a new array this array should be a

00:53:40,320 --> 00:53:45,330
new reference and you should return a

00:53:43,650 --> 00:53:47,100
new reference of this object and you

00:53:45,330 --> 00:53:48,840
basically would need to leave this

00:53:47,100 --> 00:53:53,300
reference untouched because you don't

00:53:48,840 --> 00:53:53,300
you don't want them to be rendered I

00:53:54,080 --> 00:54:00,840
don't know if it makes any sense I mean

00:53:58,680 --> 00:54:04,500
probably it would be much easier on your

00:54:00,840 --> 00:54:08,130
use case but it would take me a lot

00:54:04,500 --> 00:54:10,460
longer time to understand the context I

00:54:08,130 --> 00:54:16,380
mean I understand your use case and -

00:54:10,460 --> 00:54:19,290
but you can you can drop me on either a

00:54:16,380 --> 00:54:21,360
message on on meetup or on Twitter and

00:54:19,290 --> 00:54:25,350
we can discuss in details if you need to

00:54:21,360 --> 00:54:29,970
help with yeah I think it will be much

00:54:25,350 --> 00:54:33,210
better yeah I I will prepare my question

00:54:29,970 --> 00:54:42,440
and what somewhere thank you for playing

00:54:33,210 --> 00:54:42,440
anyway any other questions

00:54:51,180 --> 00:54:57,700
yeah I have a question about the

00:54:53,620 --> 00:55:04,810
profiler in your scenario your

00:54:57,700 --> 00:55:07,930
application is kind kind of simple right

00:55:04,810 --> 00:55:09,940
well what if you want to do profiling in

00:55:07,930 --> 00:55:12,430
a very big application I'm guessing

00:55:09,940 --> 00:55:17,680
you'll have a lot of graphs and calls

00:55:12,430 --> 00:55:22,330
and codes running is it easy to spot in

00:55:17,680 --> 00:55:27,280
that scenario what function is hogging

00:55:22,330 --> 00:55:30,040
the CPU or I don't know you are

00:55:27,280 --> 00:55:33,030
referring to this profiling using the

00:55:30,040 --> 00:55:36,700
performance the performance tab exactly

00:55:33,030 --> 00:55:40,390
how will it work in a bigger application

00:55:36,700 --> 00:55:43,960
with lots of calls well this is the

00:55:40,390 --> 00:55:47,530
thing because this thing here so let's

00:55:43,960 --> 00:55:49,990
let's go back to to the previous the

00:55:47,530 --> 00:55:52,720
previous example this is the the beauty

00:55:49,990 --> 00:55:56,790
of I mean they are really smart the the

00:55:52,720 --> 00:56:04,030
people from the chrome dev tools

00:55:56,790 --> 00:56:06,760
so let's profile this once again so as

00:56:04,030 --> 00:56:11,350
you can see here this is a so-called

00:56:06,760 --> 00:56:15,640
bottom-up display so it's it shows you

00:56:11,350 --> 00:56:20,470
like the more the most inner inner

00:56:15,640 --> 00:56:23,580
function that got called that so not not

00:56:20,470 --> 00:56:27,070
all the ancestors so it tells you the

00:56:23,580 --> 00:56:30,520
the most deepest function and then you

00:56:27,070 --> 00:56:34,180
can go outwards so item are called the

00:56:30,520 --> 00:56:36,190
item use the this problematic reg X and

00:56:34,180 --> 00:56:40,270
and so on so forth so it will pinpoint

00:56:36,190 --> 00:56:44,320
to the exact to the exact problem so you

00:56:40,270 --> 00:56:46,600
can go from very the very deep the very

00:56:44,320 --> 00:56:51,790
guts of your application can go you can

00:56:46,600 --> 00:56:53,280
go step by step out more to that more to

00:56:51,790 --> 00:56:58,030
the surface I don't know how to describe

00:56:53,280 --> 00:57:01,560
so I it's it's not a problem I mean if

00:56:58,030 --> 00:57:04,510
this was a big application and this

00:57:01,560 --> 00:57:07,840
dysfunction was called from

00:57:04,510 --> 00:57:13,180
know how many levels deeper of

00:57:07,840 --> 00:57:16,750
components understand the the the bottom

00:57:13,180 --> 00:57:18,220
of think make sense yeah so this is

00:57:16,750 --> 00:57:23,310
really really useful

00:57:18,220 --> 00:57:23,310
nice yeah no problem

00:57:33,860 --> 00:57:41,000
I mean this is this was a bit of a was a

00:57:37,700 --> 00:57:42,560
bit out of context it wasn't you

00:57:41,000 --> 00:57:47,120
probably don't need this in the context

00:57:42,560 --> 00:57:49,760
of react this was only to show you like

00:57:47,120 --> 00:57:52,640
how you can pinpoint some some problems

00:57:49,760 --> 00:57:56,330
with your with your code it it's not

00:57:52,640 --> 00:57:59,750
it's not something that is a is related

00:57:56,330 --> 00:58:01,520
to react we can use it in any other kind

00:57:59,750 --> 00:58:03,110
of application when you don't know the

00:58:01,520 --> 00:58:05,540
application and you don't know what's

00:58:03,110 --> 00:58:10,210
actually happening it's this could help

00:58:05,540 --> 00:58:10,210
to to identify some more some problems

00:58:17,020 --> 00:58:32,270
do know some articles maybe videos to

00:58:20,300 --> 00:58:35,960
deep dive into a profiler obvious money

00:58:32,270 --> 00:58:39,290
I think released an article like a few

00:58:35,960 --> 00:58:41,300
days ago I think the Google developer

00:58:39,290 --> 00:58:44,180
portal is a good resource for that

00:58:41,300 --> 00:58:45,980
because they explain there or at least

00:58:44,180 --> 00:58:52,300
how the profiler works in chrome and

00:58:45,980 --> 00:58:52,300
what you can look at that old one course

00:58:52,720 --> 00:59:07,970
from I I've seen the old one course

00:58:59,530 --> 00:59:19,130
video course from Google yeah to go to

00:59:07,970 --> 00:59:26,690
developers.google.com google it it's old

00:59:19,130 --> 00:59:29,150
one but it's a really good one so I saw

00:59:26,690 --> 00:59:33,200
I think this week or last week I don't

00:59:29,150 --> 00:59:35,750
know exactly this blog post from August

00:59:33,200 --> 00:59:43,070
money exact profiling reactor react apps

00:59:35,750 --> 00:59:46,330
it shows some some more in-depth stuff

00:59:43,070 --> 00:59:46,330
that you could do

00:59:48,010 --> 00:59:54,430
but this is only for react er you are

00:59:50,650 --> 01:00:04,569
looking into the chrome vectors right

00:59:54,430 --> 01:00:04,569
nope this one also good okay Chet

01:00:04,720 --> 01:00:10,369
what does Alex mentioned the Google

01:00:08,059 --> 01:00:13,339
developers I don't know exactly one day

01:00:10,369 --> 01:00:18,260
where they put their resources but they

01:00:13,339 --> 01:00:21,290
have a lot of and and I also saw

01:00:18,260 --> 01:00:25,849
something but I am pasting the link in

01:00:21,290 --> 01:00:29,990
the chat this one if you look at and on

01:00:25,849 --> 01:00:33,290
the sidebar they have they have really

01:00:29,990 --> 01:00:45,020
good documentation on all parts of

01:00:33,290 --> 01:00:53,569
performance rendering loading Jeremy

01:00:45,020 --> 01:00:55,940
Wagner nice so you can open on the on

01:00:53,569 --> 01:00:57,410
the left side you can open like there in

01:00:55,940 --> 01:01:01,520
the loading perform good every

01:00:57,410 --> 01:01:04,220
performance all sorts of no article I

01:01:01,520 --> 01:01:07,400
wrote you out like information and

01:01:04,220 --> 01:01:10,069
documentation about what to look and

01:01:07,400 --> 01:01:16,210
it's a lot of reading if you want to

01:01:10,069 --> 01:01:16,210
really get yeah I can see

01:01:21,650 --> 01:01:33,830
nice from me to Alex move on privately

01:01:42,410 --> 01:01:52,350
okay thanks Andre for the presentation -

01:01:46,380 --> 01:01:56,280
really really nice yeah glad to thank

01:01:52,350 --> 01:01:59,610
you for inviting me and hope it was

01:01:56,280 --> 01:02:05,730
useful for at least for some some of you

01:01:59,610 --> 01:02:08,100
it was glad thank you thank you thank

01:02:05,730 --> 01:02:14,520
you thank you very much thank you thank

01:02:08,100 --> 01:02:20,490
you you can ask more questions if you if

01:02:14,520 --> 01:02:24,080
you have and I would have one would you

01:02:20,490 --> 01:02:27,360
use this profiling also for react native

01:02:24,080 --> 01:02:30,030
yes I I've used it a bit but I don't

01:02:27,360 --> 01:02:32,730
know it's a form it was a bit hard to

01:02:30,030 --> 01:02:34,790
find the functions that I was looking

01:02:32,730 --> 01:02:34,790
for

01:02:35,870 --> 01:02:42,570
what are you this is what you would use

01:02:39,030 --> 01:02:45,510
as well for react native I actually all

01:02:42,570 --> 01:02:49,470
these matters that I that I presented

01:02:45,510 --> 01:02:52,110
here I use them for react native because

01:02:49,470 --> 01:02:54,570
I'm working with react native so yeah I

01:02:52,110 --> 01:02:56,700
definitely definitely recommend by means

01:02:54,570 --> 01:02:58,530
it's the same the react works the same

01:02:56,700 --> 01:03:02,940
the reconciliation process is the same

01:02:58,530 --> 01:03:06,180
in react native so yeah I'm I'm using

01:03:02,940 --> 01:03:08,490
the real native debugger but this is

01:03:06,180 --> 01:03:13,650
basically this is like an electron app

01:03:08,490 --> 01:03:15,210
of you have the same profiler as you

01:03:13,650 --> 01:03:19,130
have in the browser it's basically the

01:03:15,210 --> 01:03:23,090
same that it's put in a non electron or

01:03:19,130 --> 01:03:27,170
native application but it's yes the same

01:03:23,090 --> 01:03:27,170
the same it works okay

01:03:56,890 --> 01:04:02,420
anybody I'm curious what what else did

01:04:00,500 --> 01:04:08,120
you have planned for the workshop like

01:04:02,420 --> 01:04:12,260
what were you adding well the workshop

01:04:08,120 --> 01:04:20,750
would have been a much slower pace I

01:04:12,260 --> 01:04:22,340
also have here a slide so I would have

01:04:20,750 --> 01:04:25,190
gone into much more detail about the

01:04:22,340 --> 01:04:29,480
reconciliation process about keys and

01:04:25,190 --> 01:04:32,000
how to use and how to not use keys how

01:04:29,480 --> 01:04:33,770
to use keys or how to abuse keys two for

01:04:32,000 --> 01:04:40,550
three renders in some situations where

01:04:33,770 --> 01:04:44,270
you cannot render something how to use

01:04:40,550 --> 01:04:47,750
the use ref hook in order to skip to not

01:04:44,270 --> 01:04:49,700
rerender when we don't need to also this

01:04:47,750 --> 01:04:51,980
is like a performance performance

01:04:49,700 --> 01:04:55,970
optimization that that I used in some

01:04:51,980 --> 01:05:00,860
situations and react memo also has a

01:04:55,970 --> 01:05:03,110
custom update function so the second

01:05:00,860 --> 01:05:04,730
parameter react memo receives to two

01:05:03,110 --> 01:05:07,220
parameters the first is the component

01:05:04,730 --> 01:05:10,250
and second is is a function it's an

01:05:07,220 --> 01:05:13,610
optional function that we can pass that

01:05:10,250 --> 01:05:15,070
is similar to the shoot component update

01:05:13,610 --> 01:05:18,800
[Music]

01:05:15,070 --> 01:05:22,220
lifecycle method in class components so

01:05:18,800 --> 01:05:25,760
basically this is the second parameter

01:05:22,220 --> 01:05:29,720
is the inverse of root component update

01:05:25,760 --> 01:05:33,500
it tells react memo when these

01:05:29,720 --> 01:05:36,890
components are equal so it's like in the

01:05:33,500 --> 01:05:42,560
negative component update so when you

01:05:36,890 --> 01:05:43,760
return true these these are it won't it

01:05:42,560 --> 01:05:48,410
won't rerender

01:05:43,760 --> 01:05:50,510
and when you return false it should be

01:05:48,410 --> 01:05:53,750
rendered sure component update is

01:05:50,510 --> 01:05:55,580
basically the exact opposite when you

01:05:53,750 --> 01:05:58,070
return true it should update when you

01:05:55,580 --> 01:06:01,250
return false it will not update I also

01:05:58,070 --> 01:06:07,070
have a use case for in in my worship I

01:06:01,250 --> 01:06:11,080
had a use case for this so yeah you get

01:06:07,070 --> 01:06:17,980
as their arguments props and state or

01:06:11,080 --> 01:06:28,130
you don't get the you get the props you

01:06:17,980 --> 01:06:31,790
get only the props I think because you

01:06:28,130 --> 01:06:35,540
can handle state differently in in

01:06:31,790 --> 01:06:46,670
function components react

01:06:35,540 --> 01:06:52,340
memo only the props I think you get are

01:06:46,670 --> 01:06:54,290
equal ref props next props okay

01:06:52,340 --> 01:06:58,690
actually it makes sense cuz you have

01:06:54,290 --> 01:06:58,690
folks for stated exactly

01:07:08,910 --> 01:07:28,540
and of course exercises and more

01:07:14,890 --> 01:07:30,160
practice what are keys keys the ones

01:07:28,540 --> 01:07:33,160
that you use when you render collections

01:07:30,160 --> 01:07:56,710
you pass in a key to to the items

01:07:33,160 --> 01:08:00,910
oh those keys not this one sorry well

01:07:56,710 --> 01:08:06,070
keys are basically so if if you specify

01:08:00,910 --> 01:08:10,050
a key you a unique key you you already

01:08:06,070 --> 01:08:13,690
optimized I mean I during the workshop I

01:08:10,050 --> 01:08:18,279
only tried I the thing it was that to

01:08:13,690 --> 01:08:20,920
get it to the details of why react asks

01:08:18,279 --> 01:08:22,450
you to pass a unique key and what

01:08:20,920 --> 01:08:24,489
happens if you don't pass the unique key

01:08:22,450 --> 01:08:26,830
and what happens when you don't pass key

01:08:24,489 --> 01:08:31,180
is at all and how does it treat key so

01:08:26,830 --> 01:08:35,680
it's basically like a deep dive into how

01:08:31,180 --> 01:08:38,140
keys work and also there is one

01:08:35,680 --> 01:08:41,130
situation where I encounter me counted

01:08:38,140 --> 01:08:44,680
in a in a react native of application

01:08:41,130 --> 01:08:46,299
but I also have an example here let me

01:08:44,680 --> 01:08:52,259
check if I can

01:08:46,299 --> 01:08:52,259
oh no I I don't think I I can demo it so

01:08:52,350 --> 01:09:06,130
if you consider that you have that you

01:09:00,250 --> 01:09:13,690
have one iframe somewhere in in your

01:09:06,130 --> 01:09:18,299
application right you pass in some some

01:09:13,690 --> 01:09:18,299
URL let's say HTTP

01:09:18,339 --> 01:09:27,109
google.com okay and so the user would be

01:09:23,599 --> 01:09:29,900
able to navigate in this in this iframe

01:09:27,109 --> 01:09:31,250
right so it will navigate it would go to

01:09:29,900 --> 01:09:34,609
another place to another place to

01:09:31,250 --> 01:09:40,339
another page now let's say that you want

01:09:34,609 --> 01:09:46,480
to reset the side frame to the original

01:09:40,339 --> 01:09:50,329
to the original URL that you passed here

01:09:46,480 --> 01:09:54,380
it it could be and it is very tricky to

01:09:50,329 --> 01:09:56,739
do this because you I frame is basically

01:09:54,380 --> 01:10:01,489
a component that you cannot control

01:09:56,739 --> 01:10:03,679
right so if you could you would you

01:10:01,489 --> 01:10:06,710
would I mean you you can have a ref to

01:10:03,679 --> 01:10:11,030
the iframe and you can use the the

01:10:06,710 --> 01:10:13,099
browser API to to a node call the

01:10:11,030 --> 01:10:14,989
history state to go back to go back to

01:10:13,099 --> 01:10:17,659
go back but you don't you don't know how

01:10:14,989 --> 01:10:21,860
many how many pages has the user

01:10:17,659 --> 01:10:24,440
navigated for instance so what you could

01:10:21,860 --> 01:10:30,800
do is you can you could pass a key here

01:10:24,440 --> 01:10:34,699
to this to this element let's say count

01:10:30,800 --> 01:10:37,159
or index or something and you could

01:10:34,699 --> 01:10:40,610
force a rerender or disk of this

01:10:37,159 --> 01:10:43,699
component whenever you you change you

01:10:40,610 --> 01:10:46,070
change this key because reacts when you

01:10:43,699 --> 01:10:48,409
change the key of an element it will

01:10:46,070 --> 01:10:51,349
basically rerender it it will take it

01:10:48,409 --> 01:10:55,940
outside the dawn and will remount it

01:10:51,349 --> 01:10:58,219
again so this is like I used to call it

01:10:55,940 --> 01:11:00,920
a hack but it's not actually a high

01:10:58,219 --> 01:11:04,219
because it's also documented in some

01:11:00,920 --> 01:11:06,170
some reactor or Maidan abramova or by

01:11:04,219 --> 01:11:09,590
somebody from the react team it's also

01:11:06,170 --> 01:11:15,380
documented a workaround to for three

01:11:09,590 --> 01:11:20,329
renders on on your components so this is

01:11:15,380 --> 01:11:22,429
I've seen this approach on a project

01:11:20,329 --> 01:11:26,119
I've worked and I thought at first that

01:11:22,429 --> 01:11:29,090
it was a hack but actually the person

01:11:26,119 --> 01:11:31,040
who did that use the components which

01:11:29,090 --> 01:11:34,100
was controlled and you

01:11:31,040 --> 01:11:35,930
an unchanged and a value to it but the

01:11:34,100 --> 01:11:38,270
problem is that component had a bug and

01:11:35,930 --> 01:11:41,600
it did not update itself when the bell

01:11:38,270 --> 01:11:44,810
changed so as a quick fix it gave it a

01:11:41,600 --> 01:11:48,080
new key each time the value changed from

01:11:44,810 --> 01:11:52,240
the outside and will reread there and I

01:11:48,080 --> 01:11:57,590
was like whoa that's actually genius

01:11:52,240 --> 01:12:01,220
yeah so yeah I mean yeah if you if you

01:11:57,590 --> 01:12:04,280
understand how keys work and how react

01:12:01,220 --> 01:12:07,310
treats treats keys then basically we

01:12:04,280 --> 01:12:11,600
have more knowledge in your briefcase

01:12:07,310 --> 01:12:13,610
and you can you can use them in a non

01:12:11,600 --> 01:12:15,340
specific situations that you might you

01:12:13,610 --> 01:12:21,290
might encounter you might encounter I

01:12:15,340 --> 01:12:24,470
use this for instance in in react native

01:12:21,290 --> 01:12:28,370
application having a webview webview is

01:12:24,470 --> 01:12:31,430
just like sort of an iframe that you you

01:12:28,370 --> 01:12:33,890
display like a web page you know mobile

01:12:31,430 --> 01:12:36,190
in a mobile application and the same

01:12:33,890 --> 01:12:39,200
thing like the user could navigate I

01:12:36,190 --> 01:12:42,860
don't know - what are the page and you

01:12:39,200 --> 01:12:44,660
want to take him back to resets the the

01:12:42,860 --> 01:12:46,730
webview or the iframe to D to the

01:12:44,660 --> 01:12:50,800
original URL so this is something that I

01:12:46,730 --> 01:12:54,190
that I used can see dogs also has a

01:12:50,800 --> 01:12:54,190
another use case

01:13:00,600 --> 01:13:07,510
[Music]

01:13:08,500 --> 01:13:14,780
yeah this is like another good article

01:13:12,890 --> 01:13:19,700
he presents another another use case

01:13:14,780 --> 01:13:22,700
that were updating the keys to trigger

01:13:19,700 --> 01:13:25,510
to force re-render worked for him our

01:13:22,700 --> 01:13:25,510
base this year

01:13:39,820 --> 01:13:42,120
Thanks

01:13:40,900 --> 01:14:05,800
because I don't know if you're around

01:13:42,120 --> 01:14:08,080
still want me to leave but yeah thanks

01:14:05,800 --> 01:14:11,230
again see you around

01:14:08,080 --> 01:14:14,460
yes sir next next meet up and hopefully

01:14:11,230 --> 01:14:17,050
in in flash you knocked over

01:14:14,460 --> 01:14:22,570
fingers crossed fingers crossed

01:14:17,050 --> 01:14:25,630
okay so I think we can call it before

01:14:22,570 --> 01:14:30,820
there are no more questions will the

01:14:25,630 --> 01:14:36,239
presentation be posted on the group it

01:14:30,820 --> 01:14:40,270
will be added in on our YouTube channel

01:14:36,239 --> 01:14:43,330
okay Andre allowed us to record it and

01:14:40,270 --> 01:14:51,340
we're gonna post it there yeah thank you

01:14:43,330 --> 01:14:53,140
sure cool Thank You Andre okay thank you

01:14:51,340 --> 01:14:59,260
thank you thank you everybody for

01:14:53,140 --> 01:15:01,860
attending and yeah see you next time bye

01:14:59,260 --> 01:15:05,219
thank you

01:15:01,860 --> 01:15:05,219

YouTube URL: https://www.youtube.com/watch?v=KUreNUqtE50


