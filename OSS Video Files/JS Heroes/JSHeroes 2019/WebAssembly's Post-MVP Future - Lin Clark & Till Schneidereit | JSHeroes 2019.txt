Title: WebAssembly's Post-MVP Future - Lin Clark & Till Schneidereit | JSHeroes 2019
Publication date: 2019-04-27
Playlist: JSHeroes 2019
Description: 
	If the web were a video game franchise, then WebAssembly would be its latest hero...

During the first part of our journey, our hero completed the first quest—making it possible to play PC games and build applications like AutoCAD on the web. But this journey is far from over! Many a quest awaits; whole worlds are left to explore! The browser, and our hero’s current skill set, is just the beginning.

In this talk, we’ll explore both charted and uncharted areas—from the JavaScript-rich lands of the browser, to the darkest reaches of the blockchain, to the airy heights of the cloud with CDNs, and more! And we’ll map out all of the features we need to unlock to take us to these new heights:

Threading
Garbage collection
ES module integration and more!
Captions: 
	00:00:00,160 --> 00:00:13,310
[Music]

00:00:14,250 --> 00:00:20,590
thank you for that fantastic

00:00:15,850 --> 00:00:23,590
introduction and hi I'm Lynne Clark and

00:00:20,590 --> 00:00:25,360
I make coke cartoons and I also work in

00:00:23,590 --> 00:00:26,560
Missoula on things like webassembly

00:00:25,360 --> 00:00:29,110
which is what we'll be talking about

00:00:26,560 --> 00:00:30,640
today and I'm joined by Tony right who

00:00:29,110 --> 00:00:32,680
leads our webassembly tooling efforts

00:00:30,640 --> 00:00:35,290
and will be filling this us in on some

00:00:32,680 --> 00:00:38,890
of the work that they're all doing so

00:00:35,290 --> 00:00:40,780
first off what is web assembly web

00:00:38,890 --> 00:00:42,910
assembly is a way of running programming

00:00:40,780 --> 00:00:45,820
languages other than JavaScript on the

00:00:42,910 --> 00:00:48,699
web up until now it's run code on the

00:00:45,820 --> 00:00:51,699
web page the only language that you

00:00:48,699 --> 00:00:52,989
could use was JavaScript but now that

00:00:51,699 --> 00:00:58,150
there's web assembly you can use other

00:00:52,989 --> 00:00:59,739
languages like rust and C and C++ now

00:00:58,150 --> 00:01:01,989
I've noticed that some people have a

00:00:59,739 --> 00:01:04,540
misconception about web assembly they

00:01:01,989 --> 00:01:08,170
think that the MVP that was turned on by

00:01:04,540 --> 00:01:09,880
default in browsers in 2017 is the final

00:01:08,170 --> 00:01:11,350
version of web assembly and I can

00:01:09,880 --> 00:01:13,659
understand where that misconception

00:01:11,350 --> 00:01:15,700
comes from the web assembly community

00:01:13,659 --> 00:01:17,380
group is really committed to backwards

00:01:15,700 --> 00:01:18,729
compatibility so that means if the web

00:01:17,380 --> 00:01:21,030
assembly that you write today is going

00:01:18,729 --> 00:01:23,259
to continue to work long into the future

00:01:21,030 --> 00:01:24,729
but that doesn't mean that this web

00:01:23,259 --> 00:01:27,609
assembly is to feature complete and in

00:01:24,729 --> 00:01:29,590
fact that's far from the case features

00:01:27,609 --> 00:01:31,689
are coming to web assembly which will

00:01:29,590 --> 00:01:35,200
fundamentally alter what you can do with

00:01:31,689 --> 00:01:37,119
web assembly I think of these future

00:01:35,200 --> 00:01:40,149
features kind of like the skill tree in

00:01:37,119 --> 00:01:41,799
a video game we've fully filled in the

00:01:40,149 --> 00:01:43,210
top few of these skills but there's

00:01:41,799 --> 00:01:45,399
still this whole skill tree underneath

00:01:43,210 --> 00:01:48,880
that we need to fill in to unlock all of

00:01:45,399 --> 00:01:50,770
the applications so let's look at what's

00:01:48,880 --> 00:01:53,579
been filled in already and then we can

00:01:50,770 --> 00:01:53,579
see what's yet to come

00:01:53,789 --> 00:01:58,179
web assembly story starts with

00:01:56,289 --> 00:02:01,749
inscripted which made it possible to

00:01:58,179 --> 00:02:02,859
bring large existing C++ code bases for

00:02:01,749 --> 00:02:05,619
things like games and desktop

00:02:02,859 --> 00:02:08,830
applications to the web Anna did this by

00:02:05,619 --> 00:02:11,290
transpiling that code to JavaScript now

00:02:08,830 --> 00:02:12,730
at first this JavaScript was slow but

00:02:11,290 --> 00:02:14,620
then there was a Firefox engineer who

00:02:12,730 --> 00:02:16,720
saw that you could add an optimization

00:02:14,620 --> 00:02:21,160
to the engine to make it run fast and

00:02:16,720 --> 00:02:22,480
this gave us as enjoy ass once the

00:02:21,160 --> 00:02:24,970
browser vendors all of the browser

00:02:22,480 --> 00:02:27,390
vendors saw how fast as in JS was they

00:02:24,970 --> 00:02:30,060
started adding the same optimizations to

00:02:27,390 --> 00:02:31,620
engines but this wasn't the end of the

00:02:30,060 --> 00:02:33,930
story it was just the beginning of the

00:02:31,620 --> 00:02:35,880
story engines could still make this

00:02:33,930 --> 00:02:37,680
faster but they couldn't do it in

00:02:35,880 --> 00:02:39,600
JavaScript itself and said they needed a

00:02:37,680 --> 00:02:42,780
new language one that was designed

00:02:39,600 --> 00:02:46,530
specifically to be compiled - and that

00:02:42,780 --> 00:02:49,740
was web assembly so what skills were

00:02:46,530 --> 00:02:53,100
needed for the MVP running C and C++ on

00:02:49,740 --> 00:02:54,810
the web well web assemblies designers

00:02:53,100 --> 00:02:57,569
knew they wanted to support languages

00:02:54,810 --> 00:03:00,050
besides just C and C++ so if he needed a

00:02:57,569 --> 00:03:02,220
language agnostic compile target

00:03:00,050 --> 00:03:04,050
something like the assembly language

00:03:02,220 --> 00:03:07,019
that things like desktop applications

00:03:04,050 --> 00:03:08,700
are compiled - like x86 but this

00:03:07,019 --> 00:03:10,739
assembly language wouldn't be for an axe

00:03:08,700 --> 00:03:12,980
actual physical machine it would be for

00:03:10,739 --> 00:03:15,840
a conceptual machine

00:03:12,980 --> 00:03:18,959
now this compiled target also had to run

00:03:15,840 --> 00:03:21,840
very fast to meet users expectations for

00:03:18,959 --> 00:03:23,730
smooth interactions and gameplay and it

00:03:21,840 --> 00:03:26,660
also needed to load fast because the

00:03:23,730 --> 00:03:28,950
web's users are used so fast load times

00:03:26,660 --> 00:03:31,380
but these kinds of applications are

00:03:28,950 --> 00:03:32,880
pretty large code bases which means that

00:03:31,380 --> 00:03:36,239
there's a lot to download and compile

00:03:32,880 --> 00:03:37,920
when the user first goes to the URL so

00:03:36,239 --> 00:03:39,630
we needed our compiled target to be

00:03:37,920 --> 00:03:43,470
compact and that way I could go for the

00:03:39,630 --> 00:03:45,329
internet quickly these languages also

00:03:43,470 --> 00:03:46,650
needed to use memory differently from

00:03:45,329 --> 00:03:50,160
JavaScript they need to be able to

00:03:46,650 --> 00:03:52,140
directly manage their memory this is

00:03:50,160 --> 00:03:54,470
because languages like C and C++ have a

00:03:52,140 --> 00:03:56,790
low-level feature called pointers and

00:03:54,470 --> 00:03:59,269
pointers need to be able to write to and

00:03:56,790 --> 00:04:01,530
read from particular memory addresses

00:03:59,269 --> 00:04:03,989
but you can't have a program that you

00:04:01,530 --> 00:04:07,010
downloaded from the web just accessing

00:04:03,989 --> 00:04:09,690
bytes on your computer willy-nilly in

00:04:07,010 --> 00:04:12,000
order to provide a way to access memory

00:04:09,690 --> 00:04:13,590
directly like a native program is used

00:04:12,000 --> 00:04:15,840
to but keep the browser's secure at the

00:04:13,590 --> 00:04:17,160
same time we had to create something

00:04:15,840 --> 00:04:19,940
that could give access to a very

00:04:17,160 --> 00:04:22,350
specific part of memory and nothing else

00:04:19,940 --> 00:04:25,680
to do this web assembly uses a linear

00:04:22,350 --> 00:04:27,030
memory model and this is implemented

00:04:25,680 --> 00:04:28,169
using something called typed arrays so

00:04:27,030 --> 00:04:30,660
this is basically just a JavaScript

00:04:28,169 --> 00:04:33,150
array but the only thing that it can

00:04:30,660 --> 00:04:34,380
have inside of it is bytes and this

00:04:33,150 --> 00:04:37,169
means that when you're accessing it

00:04:34,380 --> 00:04:39,060
you're just using array indexes which

00:04:37,169 --> 00:04:40,770
you can treat as though they were memory

00:04:39,060 --> 00:04:42,900
addresses and this means that

00:04:40,770 --> 00:04:47,009
can pretend that this memory this array

00:04:42,900 --> 00:04:48,660
is C++ memory so with all of these

00:04:47,009 --> 00:04:51,750
things in place you could run desktop

00:04:48,660 --> 00:04:52,979
applications for things like games in

00:04:51,750 --> 00:04:56,400
your browser as if they were running

00:04:52,979 --> 00:04:58,020
natively on your computer and that was

00:04:56,400 --> 00:05:00,120
pretty much it for the skill set that

00:04:58,020 --> 00:05:03,090
webassembly had when was first released

00:05:00,120 --> 00:05:05,970
as an MVP it truly was an MVP a Minimum

00:05:03,090 --> 00:05:07,470
Viable Product it allowed certain kinds

00:05:05,970 --> 00:05:11,150
of applications to work but there's

00:05:07,470 --> 00:05:13,590
still a whole host of others to unlock

00:05:11,150 --> 00:05:17,400
so the next achievement to unlock is

00:05:13,590 --> 00:05:19,050
have your wait desktop applications can

00:05:17,400 --> 00:05:21,389
you imagine if something like Photoshop

00:05:19,050 --> 00:05:24,090
we're running on the web you know if you

00:05:21,389 --> 00:05:25,860
could use it like use it Gmail where you

00:05:24,090 --> 00:05:27,569
just go to the web site on any device

00:05:25,860 --> 00:05:31,650
and you can immediately start

00:05:27,569 --> 00:05:33,479
interacting with things for and we've

00:05:31,650 --> 00:05:35,909
already started seeing things like this

00:05:33,479 --> 00:05:37,530
so for example the AutoCAD team has made

00:05:35,909 --> 00:05:39,810
their CAD software available through the

00:05:37,530 --> 00:05:41,729
browser and adobe has made lightroom

00:05:39,810 --> 00:05:44,789
available through the browser using web

00:05:41,729 --> 00:05:46,500
assembly as well but there are still a

00:05:44,789 --> 00:05:48,180
few features that we need to make sure

00:05:46,500 --> 00:05:50,310
that all these applications even the

00:05:48,180 --> 00:05:53,099
heaviest of heavyweight applications run

00:05:50,310 --> 00:05:56,159
well in the browser so first to support

00:05:53,099 --> 00:05:57,569
for multi-threading modern-day computers

00:05:56,159 --> 00:05:59,729
have multiple cores that can process

00:05:57,569 --> 00:06:00,960
things in parallel but to make use of

00:05:59,729 --> 00:06:04,229
these cores you need support for

00:06:00,960 --> 00:06:05,849
threading there's another bit of modern

00:06:04,229 --> 00:06:08,610
hardware that processes things in

00:06:05,849 --> 00:06:11,880
parallel this is sim D single

00:06:08,610 --> 00:06:13,469
instruction multiple data with sim T as

00:06:11,880 --> 00:06:15,300
possible to take a chunk of memory and

00:06:13,469 --> 00:06:16,680
split it up across different execution

00:06:15,300 --> 00:06:18,900
units or which are basically like

00:06:16,680 --> 00:06:19,830
different cores and then you can have

00:06:18,900 --> 00:06:22,050
the same bit of code the same

00:06:19,830 --> 00:06:23,729
instruction running across all of these

00:06:22,050 --> 00:06:27,330
different execution units but each on

00:06:23,729 --> 00:06:29,550
its own bit of the data there's another

00:06:27,330 --> 00:06:32,430
hardware capability called 64-bit

00:06:29,550 --> 00:06:34,590
addressing memory addresses are just

00:06:32,430 --> 00:06:36,930
numbers so if your memory address only

00:06:34,590 --> 00:06:39,120
has 32 bits if it's only 32 bits long

00:06:36,930 --> 00:06:42,300
you can only have so many memory

00:06:39,120 --> 00:06:44,400
addresses about 4 gigabytes but most

00:06:42,300 --> 00:06:46,979
modern hardware supports 64-bit

00:06:44,400 --> 00:06:48,960
addressing which offers 16 exabytes of

00:06:46,979 --> 00:06:49,880
memory addresses so that's a big

00:06:48,960 --> 00:06:53,880
difference

00:06:49,880 --> 00:06:54,300
adding 64-bit support will take the

00:06:53,880 --> 00:06:59,039
artifice

00:06:54,300 --> 00:07:01,190
limitation out of webassembly but these

00:06:59,039 --> 00:07:04,370
applications don't just need to run fast

00:07:01,190 --> 00:07:06,990
load times need to be fast too

00:07:04,370 --> 00:07:09,150
one big step here is to do streaming

00:07:06,990 --> 00:07:11,190
compilation so this is where you compile

00:07:09,150 --> 00:07:15,050
the code while it's being downloaded and

00:07:11,190 --> 00:07:17,639
what assembly was designed for this a

00:07:15,050 --> 00:07:19,800
tiered compiler also helps now in

00:07:17,639 --> 00:07:21,659
Firefox we have two compilers the first

00:07:19,800 --> 00:07:24,629
one the baseline compiler starts when

00:07:21,659 --> 00:07:26,490
the download of the file starts then

00:07:24,629 --> 00:07:28,139
another compiler the optimizing compiler

00:07:26,490 --> 00:07:30,180
runs on several threads in the

00:07:28,139 --> 00:07:32,729
background this one takes longer to

00:07:30,180 --> 00:07:36,270
compile but it generates extremely fast

00:07:32,729 --> 00:07:38,300
code we're also working on a new

00:07:36,270 --> 00:07:40,979
optimizing compiler called crane lift

00:07:38,300 --> 00:07:43,259
green lift is designed to compile code

00:07:40,979 --> 00:07:46,259
quickly it can compile code in parallel

00:07:43,259 --> 00:07:48,509
at a function by function level but the

00:07:46,259 --> 00:07:50,969
code it generates is still fast and

00:07:48,509 --> 00:07:52,590
we're currently working to make it see

00:07:50,969 --> 00:07:54,479
if we can make it generate even faster

00:07:52,590 --> 00:07:56,099
code than our current optimizing

00:07:54,479 --> 00:08:00,509
compiler which is already incredibly

00:07:56,099 --> 00:08:02,580
fast there's an even better trick that

00:08:00,509 --> 00:08:06,870
we can use to skip compiling most of the

00:08:02,580 --> 00:08:10,469
time though so unlike JavaScript if you

00:08:06,870 --> 00:08:13,319
load the same web assembly file once

00:08:10,469 --> 00:08:15,210
twice two three four more times it

00:08:13,319 --> 00:08:18,240
compiles to the same machine code each

00:08:15,210 --> 00:08:21,779
time so we can store the compiled code

00:08:18,240 --> 00:08:23,759
in the HTTP cache that means that when

00:08:21,779 --> 00:08:26,250
the page is loading and it goes to fetch

00:08:23,759 --> 00:08:28,139
the wasm file the cache will instead

00:08:26,250 --> 00:08:29,789
give it this precompiled machine code

00:08:28,139 --> 00:08:32,969
and so that will skip compiling

00:08:29,789 --> 00:08:34,589
completely and there are ways to skip

00:08:32,969 --> 00:08:38,399
even more work so stay tuned to see what

00:08:34,589 --> 00:08:40,289
else happens to improve load times where

00:08:38,399 --> 00:08:44,010
are we with supporting these heavyweight

00:08:40,289 --> 00:08:45,570
applications right now for the threading

00:08:44,010 --> 00:08:47,520
we have a proposal that's pretty much

00:08:45,570 --> 00:08:49,410
done but a key piece of that shared

00:08:47,520 --> 00:08:51,810
array buffers had to be turned off in

00:08:49,410 --> 00:08:56,579
browsers early last year they will be

00:08:51,810 --> 00:08:58,579
turned on again soon though sym D is

00:08:56,579 --> 00:09:01,380
under active development at the moment

00:08:58,579 --> 00:09:02,940
for Wasden 64 we have a good picture of

00:09:01,380 --> 00:09:05,430
how this will work and that is pretty

00:09:02,940 --> 00:09:08,190
similar to how x86 or arm got their

00:09:05,430 --> 00:09:10,139
support for 64-bit addressing

00:09:08,190 --> 00:09:12,720
for streaming compilation we added our

00:09:10,139 --> 00:09:15,509
streaming compilation to Firefox last

00:09:12,720 --> 00:09:17,310
year and in Firefox we compile the code

00:09:15,509 --> 00:09:19,410
so fast that it's basically done

00:09:17,310 --> 00:09:22,019
compiling by the time the the file is

00:09:19,410 --> 00:09:25,889
downloaded and other browsers are adding

00:09:22,019 --> 00:09:27,990
streaming to and Firefox also added a

00:09:25,889 --> 00:09:29,519
base line compiler last year and other

00:09:27,990 --> 00:09:33,199
browsers have been adding the same kind

00:09:29,519 --> 00:09:36,560
of architecture over the past year in

00:09:33,199 --> 00:09:38,579
Firefox HTTP caching is very close and

00:09:36,560 --> 00:09:42,240
other improvements are still in

00:09:38,579 --> 00:09:44,730
discussion even though this is still all

00:09:42,240 --> 00:09:46,740
in progress heavyweight applications are

00:09:44,730 --> 00:09:48,480
already coming out today because

00:09:46,740 --> 00:09:50,910
webassembly already gives these apps the

00:09:48,480 --> 00:09:52,800
performance that they need but once

00:09:50,910 --> 00:09:54,209
these features are all in place that's

00:09:52,800 --> 00:09:56,009
going to be another achievement unlocked

00:09:54,209 --> 00:09:58,160
and more of these heavyweight

00:09:56,009 --> 00:10:01,379
applications will come to the browser

00:09:58,160 --> 00:10:03,540
but webassembly isn't just for desktop

00:10:01,379 --> 00:10:05,310
applications it's also for regular web

00:10:03,540 --> 00:10:06,660
development you know this small modules

00:10:05,310 --> 00:10:10,199
kind of web development that we're all

00:10:06,660 --> 00:10:12,449
used to so if you have a module that

00:10:10,199 --> 00:10:14,430
does a lot of heavy processing that's a

00:10:12,449 --> 00:10:17,160
good use case for web assembly and again

00:10:14,430 --> 00:10:18,899
we're already seeing some of this for

00:10:17,160 --> 00:10:20,670
example the parser in the source Maps

00:10:18,899 --> 00:10:23,339
library that's used in Firefox is dev

00:10:20,670 --> 00:10:25,410
tools and web pack is now 11 times

00:10:23,339 --> 00:10:28,380
faster after having been rewritten and

00:10:25,410 --> 00:10:30,300
rust compiled to web assembly and the

00:10:28,380 --> 00:10:34,139
Gutenberg parser on what WordPress is

00:10:30,300 --> 00:10:35,910
now an average of 86 times faster but

00:10:34,139 --> 00:10:40,589
for this to go mainstream we need to

00:10:35,910 --> 00:10:42,660
have a few more things in place so first

00:10:40,589 --> 00:10:45,569
calls between web assembly and

00:10:42,660 --> 00:10:47,009
JavaScript they need to be fast when web

00:10:45,569 --> 00:10:47,959
assembly first came out these calls

00:10:47,009 --> 00:10:50,069
weren't fast

00:10:47,959 --> 00:10:53,850
that's because engines needed to

00:10:50,069 --> 00:10:56,160
optimize them we finished our work on

00:10:53,850 --> 00:10:57,630
Firefox doing this optimization last

00:10:56,160 --> 00:10:59,339
summer and now some of these calls are

00:10:57,630 --> 00:11:02,610
actually faster than non inline

00:10:59,339 --> 00:11:04,019
JavaScript at JavaScript calls that

00:11:02,610 --> 00:11:06,600
brings us to another thing though you

00:11:04,019 --> 00:11:09,360
often have to pass data between your web

00:11:06,600 --> 00:11:10,829
assembly and JavaScript so for example

00:11:09,360 --> 00:11:12,480
you have to pass arguments into your web

00:11:10,829 --> 00:11:15,120
simply function and return values from

00:11:12,480 --> 00:11:17,939
it this can be slow and it can be

00:11:15,120 --> 00:11:19,920
difficult to at the moment web assembly

00:11:17,939 --> 00:11:21,960
only understands numbers so that means

00:11:19,920 --> 00:11:23,730
that you can't pass more complex

00:11:21,960 --> 00:11:25,980
like objects into your web some play

00:11:23,730 --> 00:11:27,510
function as parameters you need to

00:11:25,980 --> 00:11:29,070
convert that object into numbers that

00:11:27,510 --> 00:11:31,500
you can stuff into linear memory and

00:11:29,070 --> 00:11:33,990
then pass a pointer over to the function

00:11:31,500 --> 00:11:35,220
so that's kind of complicated and it

00:11:33,990 --> 00:11:37,410
takes some time to actually do that

00:11:35,220 --> 00:11:40,260
conversion into numbers for linear

00:11:37,410 --> 00:11:43,710
memory so we need this to be easier and

00:11:40,260 --> 00:11:45,840
faster we also need to integrate with es

00:11:43,710 --> 00:11:47,760
modules because right now you can't use

00:11:45,840 --> 00:11:49,530
import and export with wha some modules

00:11:47,760 --> 00:11:51,030
but that means that the web assembly

00:11:49,530 --> 00:11:54,600
module isn't really part of the

00:11:51,030 --> 00:11:56,250
JavaScript module graph just being able

00:11:54,600 --> 00:11:58,290
to import and export doesn't get us all

00:11:56,250 --> 00:11:59,820
the way there though we also need ways

00:11:58,290 --> 00:12:02,490
to distribute and bundle web assembly

00:11:59,820 --> 00:12:04,050
modules and since these molecules

00:12:02,490 --> 00:12:05,370
shouldn't look any different to the

00:12:04,050 --> 00:12:07,280
people who are using them there's no

00:12:05,370 --> 00:12:11,310
reason to create a separate ecosystem

00:12:07,280 --> 00:12:13,500
and there's one more thing support for

00:12:11,310 --> 00:12:14,880
older versions of browsers even those

00:12:13,500 --> 00:12:18,510
that don't know what web assembly is

00:12:14,880 --> 00:12:20,150
like ie 11 so where are we on all of

00:12:18,510 --> 00:12:22,380
this

00:12:20,150 --> 00:12:24,000
well calls between JavaScript and web

00:12:22,380 --> 00:12:26,060
assembly are fast and Firefox now and

00:12:24,000 --> 00:12:28,500
other browsers are also working on this

00:12:26,060 --> 00:12:29,880
for easy and fast data exchange there

00:12:28,500 --> 00:12:32,610
are a few proposals that will help with

00:12:29,880 --> 00:12:34,920
this such as any Raph host bindings and

00:12:32,610 --> 00:12:37,080
we graphs and I unfortunately don't have

00:12:34,920 --> 00:12:38,670
too much time to go into the details on

00:12:37,080 --> 00:12:40,470
this but in the meantime the rust

00:12:38,670 --> 00:12:45,030
ecosystem has created tools that handle

00:12:40,470 --> 00:12:46,920
all this automatically for rust code for

00:12:45,030 --> 00:12:49,980
es module integration the proposal is

00:12:46,920 --> 00:12:51,780
pretty far along for tool chain support

00:12:49,980 --> 00:12:53,370
tools in the rust ecosystem can package

00:12:51,780 --> 00:12:55,940
your code for M p.m. and the bundlers

00:12:53,370 --> 00:12:58,440
are also actively working on support and

00:12:55,940 --> 00:13:00,690
finally for backwards compatibility

00:12:58,440 --> 00:13:03,270
there's the Oise m2j s tool and that

00:13:00,690 --> 00:13:05,310
takes out your wasm file and spits out a

00:13:03,270 --> 00:13:07,290
javascript equivalent of it now this

00:13:05,310 --> 00:13:09,210
javascript is not going to be fast but

00:13:07,290 --> 00:13:10,350
at least we'll work in older versions of

00:13:09,210 --> 00:13:14,160
browsers that don't know what what

00:13:10,350 --> 00:13:16,200
assembly is once we unlock this

00:13:14,160 --> 00:13:19,380
achievement we open the path to another

00:13:16,200 --> 00:13:21,990
to rewriting large parts of JavaScript

00:13:19,380 --> 00:13:23,940
frameworks and web assembly and making

00:13:21,990 --> 00:13:25,740
it possible for statically typed compile

00:13:23,940 --> 00:13:27,990
to JavaScript languages to compile to

00:13:25,740 --> 00:13:31,920
web simply instead so this is languages

00:13:27,990 --> 00:13:33,600
like Scala jeaious or reason or L for

00:13:31,920 --> 00:13:36,329
both of these use cases what assembly

00:13:33,600 --> 00:13:38,339
needs to support higher-level language

00:13:36,329 --> 00:13:41,459
so first let's look at rewriting parts

00:13:38,339 --> 00:13:43,709
of JavaScript frameworks for framework

00:13:41,459 --> 00:13:45,870
like react you could paralyze a virtual

00:13:43,709 --> 00:13:47,759
Dom to thing with Russ and you can also

00:13:45,870 --> 00:13:49,500
speed things up and reduce memory usage

00:13:47,759 --> 00:13:52,259
by using a different memory allocation

00:13:49,500 --> 00:13:53,970
scheme but you'd still need to interact

00:13:52,259 --> 00:13:55,649
with JavaScript objects you know things

00:13:53,970 --> 00:13:57,509
like the components that users are

00:13:55,649 --> 00:13:59,670
writing from that code

00:13:57,509 --> 00:14:01,019
you can't just rewrite everything and

00:13:59,670 --> 00:14:03,420
put it in linear memory because that

00:14:01,019 --> 00:14:04,410
would be difficult and inefficient so

00:14:03,420 --> 00:14:06,720
you need to be able to integrate with

00:14:04,410 --> 00:14:09,810
the browsers built in garbage collector

00:14:06,720 --> 00:14:11,880
at the same time now this will also help

00:14:09,810 --> 00:14:13,529
with languages that compile to

00:14:11,880 --> 00:14:15,750
JavaScript lakes college as to reason or

00:14:13,529 --> 00:14:16,980
elm because those languages use Java

00:14:15,750 --> 00:14:19,019
scripts garbage collector when they

00:14:16,980 --> 00:14:20,670
compile to je s and that's the same

00:14:19,019 --> 00:14:22,769
garbage collector that webassembly will

00:14:20,670 --> 00:14:26,370
use when it's running in the browser so

00:14:22,769 --> 00:14:27,750
they won't need to change their GC we

00:14:26,370 --> 00:14:30,480
also need better support for handling

00:14:27,750 --> 00:14:31,860
exceptions and we need good to buggin

00:14:30,480 --> 00:14:33,509
support you know dev tools make it

00:14:31,860 --> 00:14:35,220
really easy to step through your je s

00:14:33,509 --> 00:14:38,009
code in the browser we need the same

00:14:35,220 --> 00:14:39,600
thing for web assembly and finally for

00:14:38,009 --> 00:14:40,949
many functional languages you need to

00:14:39,600 --> 00:14:45,600
have support for something called tail

00:14:40,949 --> 00:14:47,790
calls so where are we on this well for

00:14:45,600 --> 00:14:50,069
garbage collection our team already has

00:14:47,790 --> 00:14:53,040
a prototype of this working but it will

00:14:50,069 --> 00:14:54,630
still be some time before that all goes

00:14:53,040 --> 00:14:57,319
through standardization so we're

00:14:54,630 --> 00:14:59,189
probably looking at sometime next year

00:14:57,319 --> 00:15:01,470
exception handling is still in the

00:14:59,189 --> 00:15:03,060
research and development phase for

00:15:01,470 --> 00:15:04,500
debugging there's currently some support

00:15:03,060 --> 00:15:06,420
and browser to dev tools but it's still

00:15:04,500 --> 00:15:07,709
not ideal so we're actively working on

00:15:06,420 --> 00:15:09,689
this and there's a subgroup of the web

00:15:07,709 --> 00:15:12,449
assembly shichi working on specifying it

00:15:09,689 --> 00:15:14,450
and the tail calls proposal is also

00:15:12,449 --> 00:15:17,580
underway

00:15:14,450 --> 00:15:19,320
once those are all in place we'll have a

00:15:17,580 --> 00:15:22,440
lil lock to jeaious frameworks and many

00:15:19,320 --> 00:15:24,269
compiled to J's languages so those are

00:15:22,440 --> 00:15:26,610
all achievements that we can unlock

00:15:24,269 --> 00:15:29,399
inside of the browser but what about

00:15:26,610 --> 00:15:30,990
outside of the browser now you may be

00:15:29,399 --> 00:15:33,060
confused when I talk about outside of

00:15:30,990 --> 00:15:35,100
the browser because isn't the browser

00:15:33,060 --> 00:15:39,060
what you use to view the web and isn't

00:15:35,100 --> 00:15:41,640
that right in the name web assembly but

00:15:39,060 --> 00:15:43,980
the truth is technologies like HTML CSS

00:15:41,640 --> 00:15:46,170
and JavaScript they're only part of what

00:15:43,980 --> 00:15:47,370
makes the web they're the visible part

00:15:46,170 --> 00:15:48,779
they're what you used to create your

00:15:47,370 --> 00:15:50,820
user interface so they're the most

00:15:48,779 --> 00:15:52,380
obvious part of the web but there's

00:15:50,820 --> 00:15:54,600
another really important part of the web

00:15:52,380 --> 00:15:59,339
that has properties which aren't as

00:15:54,600 --> 00:16:01,529
visible that is the link the links

00:15:59,339 --> 00:16:03,149
innovation is that I can link to your

00:16:01,529 --> 00:16:05,310
page without having to put in any

00:16:03,149 --> 00:16:08,670
central registry or ask you or even know

00:16:05,310 --> 00:16:10,769
who you are it's this ease of linking

00:16:08,670 --> 00:16:12,120
that enabled us to form global

00:16:10,769 --> 00:16:15,600
communities with people that we don't

00:16:12,120 --> 00:16:18,779
know but there are two problems that we

00:16:15,600 --> 00:16:21,300
haven't addressed with just the link the

00:16:18,779 --> 00:16:23,940
first one is you go visit the site and

00:16:21,300 --> 00:16:25,709
it delivers some coach you how does it

00:16:23,940 --> 00:16:27,060
know what kind of code it should deliver

00:16:25,709 --> 00:16:29,579
to you because if you're running on a

00:16:27,060 --> 00:16:32,279
Mac then you need different machine code

00:16:29,579 --> 00:16:34,050
than somebody running on Windows does

00:16:32,279 --> 00:16:37,910
the website need a different version of

00:16:34,050 --> 00:16:40,200
the code for every possible device no

00:16:37,910 --> 00:16:42,420
instead the site has one version of the

00:16:40,200 --> 00:16:45,000
code the source code and that's what's

00:16:42,420 --> 00:16:48,020
silver to the user and this translated

00:16:45,000 --> 00:16:51,230
some machine code on the user's device

00:16:48,020 --> 00:16:53,760
the name for this concept is portability

00:16:51,230 --> 00:16:56,370
with it websites don't need to know what

00:16:53,760 --> 00:16:57,980
kind of device you're running but that

00:16:56,370 --> 00:17:01,140
present brings us to the second problem

00:16:57,980 --> 00:17:03,720
if you don't know these people whose

00:17:01,140 --> 00:17:05,669
websites you're going to how do you know

00:17:03,720 --> 00:17:07,770
what kind of code they're giving you

00:17:05,669 --> 00:17:10,890
it could be trying to take over your

00:17:07,770 --> 00:17:13,199
system doesn't this vision of the web

00:17:10,890 --> 00:17:13,890
running code from anybody who's linked

00:17:13,199 --> 00:17:15,360
you follow

00:17:13,890 --> 00:17:18,750
mean that you have to blindly trust

00:17:15,360 --> 00:17:20,610
anyone who's on the web this is where

00:17:18,750 --> 00:17:23,569
the other key concept from the web comes

00:17:20,610 --> 00:17:25,489
in and that's the security model

00:17:23,569 --> 00:17:27,229
basically the browser takes that code

00:17:25,489 --> 00:17:29,059
and puts it into a sandbox and it puts a

00:17:27,229 --> 00:17:31,399
couple of toys into the sandbox things

00:17:29,059 --> 00:17:33,169
that aren't dangerous so that the code

00:17:31,399 --> 00:17:35,169
can do some stuff but it leaves the

00:17:33,169 --> 00:17:38,239
dangerous things outside of the sandbox

00:17:35,169 --> 00:17:40,460
so the utility of the link is based on

00:17:38,239 --> 00:17:42,289
these two things portability being able

00:17:40,460 --> 00:17:44,960
to deliver the same code to any device

00:17:42,289 --> 00:17:46,580
and run it and the sandbox the security

00:17:44,960 --> 00:17:49,879
model that lets you run that code

00:17:46,580 --> 00:17:51,950
without putting your machine at risk so

00:17:49,879 --> 00:17:54,679
what difference does it make if we think

00:17:51,950 --> 00:17:55,700
about the web this way well it changes

00:17:54,679 --> 00:17:58,460
the way that you think about web

00:17:55,700 --> 00:18:00,080
assembly you can think about web

00:17:58,460 --> 00:18:03,320
assembly as just another tool in the

00:18:00,080 --> 00:18:04,070
browser's toolbox which it is but it's

00:18:03,320 --> 00:18:06,950
not just that

00:18:04,070 --> 00:18:09,049
what assembly also gives us a way to

00:18:06,950 --> 00:18:11,450
take these other two capabilities of the

00:18:09,049 --> 00:18:13,639
web the portability and the security

00:18:11,450 --> 00:18:16,999
model and bring them to other use cases

00:18:13,639 --> 00:18:20,479
than need them to we can expand the web

00:18:16,999 --> 00:18:22,039
past the boundaries of the browser now

00:18:20,479 --> 00:18:25,129
you may be thinking that already

00:18:22,039 --> 00:18:27,440
happened with nodejs but as it is today

00:18:25,129 --> 00:18:29,059
node doesn't quite get us there it

00:18:27,440 --> 00:18:31,009
doesn't give us a full portability and

00:18:29,059 --> 00:18:32,479
it doesn't give us the same security you

00:18:31,009 --> 00:18:37,220
know the same confidence to run this

00:18:32,479 --> 00:18:39,019
untrusted code either with node is

00:18:37,220 --> 00:18:40,729
possible to run javascript on servers

00:18:39,019 --> 00:18:42,320
and other devices without a browser so

00:18:40,729 --> 00:18:44,450
that does give us a little bit of

00:18:42,320 --> 00:18:46,999
portability but you still need native

00:18:44,450 --> 00:18:48,559
modules in a lot of cases either because

00:18:46,999 --> 00:18:49,999
the native code performs better or

00:18:48,559 --> 00:18:51,979
because you already have code written in

00:18:49,999 --> 00:18:54,950
a language like C or rust and you want

00:18:51,979 --> 00:18:57,259
to reuse that but native modules aren't

00:18:54,950 --> 00:18:59,210
portable when the user is installing

00:18:57,259 --> 00:19:02,499
your app the native module needs to be

00:18:59,210 --> 00:19:06,080
compiled specifically for that device

00:19:02,499 --> 00:19:07,519
we're also still missing security note

00:19:06,080 --> 00:19:09,049
could have taken the sandbox from the

00:19:07,519 --> 00:19:11,570
browser but known made the design

00:19:09,049 --> 00:19:15,259
decision early on that j/s modules would

00:19:11,570 --> 00:19:17,539
have full access to system api's so

00:19:15,259 --> 00:19:20,840
these capabilities things like direct

00:19:17,539 --> 00:19:23,619
file access are the dangerous toys that

00:19:20,840 --> 00:19:26,359
aren't available in the browser sandbox

00:19:23,619 --> 00:19:28,970
even though they're dangerous they do

00:19:26,359 --> 00:19:31,730
make a certain kind of sense for the use

00:19:28,970 --> 00:19:33,320
cases that node was addressing the thing

00:19:31,730 --> 00:19:35,210
I want to make clear here though is that

00:19:33,320 --> 00:19:37,450
node made a choice and really is that

00:19:35,210 --> 00:19:39,769
node had a choice to make

00:19:37,450 --> 00:19:42,859
for JavaScript modules it could have

00:19:39,769 --> 00:19:45,200
gone with a sandbox style approach so

00:19:42,859 --> 00:19:47,119
that was the choice it could make but

00:19:45,200 --> 00:19:49,129
for native modules node had less of a

00:19:47,119 --> 00:19:53,119
choice because it's really really hard

00:19:49,129 --> 00:19:54,619
to sandbox native code so node has

00:19:53,119 --> 00:19:56,330
already made this choice you know if

00:19:54,619 --> 00:19:58,269
you're running a node app you basically

00:19:56,330 --> 00:20:01,340
said I trust this code

00:19:58,269 --> 00:20:04,609
despite this choice webassembly can

00:20:01,340 --> 00:20:06,379
still help node it could eliminate most

00:20:04,609 --> 00:20:09,109
of the need for native modules ones that

00:20:06,379 --> 00:20:10,759
are compiled on the user's device when

00:20:09,109 --> 00:20:13,759
the user is installing the app for that

00:20:10,759 --> 00:20:15,049
specific kind of device these modules

00:20:13,759 --> 00:20:16,999
could be written in webassembly instead

00:20:15,049 --> 00:20:18,409
and just compiled once by the developer

00:20:16,999 --> 00:20:20,179
and then these modules could run across

00:20:18,409 --> 00:20:23,570
all the different devices just like

00:20:20,179 --> 00:20:25,460
JavaScript modules do the only problem

00:20:23,570 --> 00:20:28,179
here is that webassembly doesn't have

00:20:25,460 --> 00:20:31,249
direct access to the system's resources

00:20:28,179 --> 00:20:32,570
we need to pass in functions so that

00:20:31,249 --> 00:20:35,869
these modules could work with the

00:20:32,570 --> 00:20:36,979
operating system for node this will

00:20:35,869 --> 00:20:38,869
probably include a lot of the

00:20:36,979 --> 00:20:40,070
functionality that's and things like Lib

00:20:38,869 --> 00:20:42,229
C and POSIX

00:20:40,070 --> 00:20:43,759
so POSIX says the portable operating

00:20:42,229 --> 00:20:45,529
system interface which is an older

00:20:43,759 --> 00:20:49,129
standard and that helps with

00:20:45,529 --> 00:20:50,929
compatibility so it provides one API for

00:20:49,129 --> 00:20:52,340
interacting with the system across a

00:20:50,929 --> 00:20:56,029
bunch of different unix-like operating

00:20:52,340 --> 00:20:57,409
systems so to make this work the node

00:20:56,029 --> 00:20:59,899
folks would need to figure out what API

00:20:57,409 --> 00:21:02,809
they want to use for the the system

00:20:59,899 --> 00:21:04,070
interface but wouldn't it be nice if

00:21:02,809 --> 00:21:06,200
that were actually something that was

00:21:04,070 --> 00:21:08,179
standard not something that was

00:21:06,200 --> 00:21:10,070
constrained just to node but could

00:21:08,179 --> 00:21:13,129
actually be used across other runtimes

00:21:10,070 --> 00:21:16,340
and use cases too now what I used to say

00:21:13,129 --> 00:21:19,159
here was a POSIX for web assembly if you

00:21:16,340 --> 00:21:21,109
will a POSIX a portable web assembly

00:21:19,159 --> 00:21:23,090
system interface and I would talk about

00:21:21,109 --> 00:21:25,009
how if this system interface were

00:21:23,090 --> 00:21:26,989
designed in the right way you could even

00:21:25,009 --> 00:21:29,479
implement the same API in a different

00:21:26,989 --> 00:21:31,489
way for the web so that's what I used to

00:21:29,479 --> 00:21:33,679
say here I don't have to talk about this

00:21:31,489 --> 00:21:35,869
in what if terms anymore because we

00:21:33,679 --> 00:21:37,519
recently started a subgroup of the w3c

00:21:35,869 --> 00:21:40,129
web assembly community group to

00:21:37,519 --> 00:21:41,899
standardize this and we seeded it with a

00:21:40,129 --> 00:21:45,349
proposal for how the system interface

00:21:41,899 --> 00:21:47,299
should work this new system interface is

00:21:45,349 --> 00:21:48,600
called huazi the web assembly system

00:21:47,299 --> 00:21:50,549
interface

00:21:48,600 --> 00:21:52,980
y'see won't be part of the webassembly

00:21:50,549 --> 00:21:55,230
spec itself and there will be wasm hosts

00:21:52,980 --> 00:21:56,880
or plasm run times that don't make this

00:21:55,230 --> 00:21:59,759
system interface available and that's

00:21:56,880 --> 00:22:01,740
fine but for those platforms that can

00:21:59,759 --> 00:22:04,049
make use of the system interface there

00:22:01,740 --> 00:22:05,610
will be a unified API for calling these

00:22:04,049 --> 00:22:07,919
functions no matter which platform your

00:22:05,610 --> 00:22:10,649
code is running on and this will make

00:22:07,919 --> 00:22:13,110
making Universal modules ones that run

00:22:10,649 --> 00:22:18,179
across both the web and node so much

00:22:13,110 --> 00:22:21,330
easier so y'see this it opens up all

00:22:18,179 --> 00:22:22,889
sorts of use cases for web assembly so

00:22:21,330 --> 00:22:31,950
that's why I brought till here to

00:22:22,889 --> 00:22:34,559
explain more about that so at this point

00:22:31,950 --> 00:22:37,679
I used to say that we and others are

00:22:34,559 --> 00:22:40,590
working on standardizing system

00:22:37,679 --> 00:22:44,129
interface for web sembly and that I

00:22:40,590 --> 00:22:46,139
think we have a good chance but after

00:22:44,129 --> 00:22:49,590
seeing the overwhelmingly positive

00:22:46,139 --> 00:22:52,320
response to the announcement we did a

00:22:49,590 --> 00:22:54,779
couple weeks ago I'll go stronger than

00:22:52,320 --> 00:22:58,649
that I think this will succeed and it'll

00:22:54,779 --> 00:23:02,850
really change how parts of software

00:22:58,649 --> 00:23:05,309
development work solomon hikes one of

00:23:02,850 --> 00:23:08,340
the cofounders of docker tweeted in

00:23:05,309 --> 00:23:10,049
response to our announcement that if web

00:23:08,340 --> 00:23:12,000
assembly and huazi had been around ten

00:23:10,049 --> 00:23:14,850
years ago they wouldn't have needed to

00:23:12,000 --> 00:23:18,629
create docker and that's obviously if it

00:23:14,850 --> 00:23:21,779
was strong statement and he backed it up

00:23:18,629 --> 00:23:23,639
with some more explanation of what he

00:23:21,779 --> 00:23:28,710
meant by that I encourage you to look at

00:23:23,639 --> 00:23:31,230
those tweets but he ends that the tweet

00:23:28,710 --> 00:23:34,350
with saying he hopes that whereas he is

00:23:31,230 --> 00:23:38,450
up to the task and I think it is and I

00:23:34,350 --> 00:23:42,029
think it's not only up for the task for

00:23:38,450 --> 00:23:46,019
the domain docker is mainly used in for

00:23:42,029 --> 00:23:48,809
containers for server-side computation

00:23:46,019 --> 00:23:51,179
but also in lots of other domains and

00:23:48,809 --> 00:23:53,789
I'll talk a bit about some of these

00:23:51,179 --> 00:23:55,980
different domains one of them of course

00:23:53,789 --> 00:23:59,940
is the server-side compute the domain of

00:23:55,980 --> 00:24:01,860
CDN service and at computing the fastly

00:23:59,940 --> 00:24:04,019
CDN for example serves

00:24:01,860 --> 00:24:07,380
a significant fraction of the Internet's

00:24:04,019 --> 00:24:10,830
graphic they are moving from serving

00:24:07,380 --> 00:24:14,100
static files to running their customers

00:24:10,830 --> 00:24:17,640
code on every single request and they're

00:24:14,100 --> 00:24:20,399
doing this without adding say 10 times

00:24:17,640 --> 00:24:22,409
as many machines to their network which

00:24:20,399 --> 00:24:25,860
is really what they would need to do for

00:24:22,409 --> 00:24:27,929
traditional server architectures and I'm

00:24:25,860 --> 00:24:29,669
saying traditional here for something

00:24:27,929 --> 00:24:32,909
like several is where we heard earlier

00:24:29,669 --> 00:24:39,510
that it really is still not not fully

00:24:32,909 --> 00:24:42,769
mature but the much lighter weight

00:24:39,510 --> 00:24:44,909
containers that webassembly will enable

00:24:42,769 --> 00:24:47,730
really changed the game here we are

00:24:44,909 --> 00:24:49,860
talking about dozens of microseconds of

00:24:47,730 --> 00:24:53,159
code startup times instead of hundreds

00:24:49,860 --> 00:24:55,529
of milliseconds and running tens of

00:24:53,159 --> 00:24:58,679
thousands of instances on in a single

00:24:55,529 --> 00:25:01,139
process so you can really Twitter start

00:24:58,679 --> 00:25:03,299
one of these instances for a request

00:25:01,139 --> 00:25:10,649
letter one for a few microseconds

00:25:03,299 --> 00:25:13,350
and teardown again so web assembly gives

00:25:10,649 --> 00:25:16,110
them the sandboxing they need for their

00:25:13,350 --> 00:25:19,980
use case at the speed and at the scale

00:25:16,110 --> 00:25:22,320
that they need people also will working

00:25:19,980 --> 00:25:25,169
on building blockchain platforms with

00:25:22,320 --> 00:25:27,889
web assembly I think at last count we we

00:25:25,169 --> 00:25:30,690
were aware of ten or so different

00:25:27,889 --> 00:25:33,659
blockchain platforms being built around

00:25:30,690 --> 00:25:37,919
web assembly virtual machines and

00:25:33,659 --> 00:25:40,169
there's inquest in the IOT space ended

00:25:37,919 --> 00:25:44,850
writing portable CLI tools with web

00:25:40,169 --> 00:25:47,340
assembly we've also seen interest from

00:25:44,850 --> 00:25:49,260
companies building game engines where

00:25:47,340 --> 00:25:52,350
web assembly can be used as a sandbox

00:25:49,260 --> 00:25:55,049
for game logic to run in and with

00:25:52,350 --> 00:25:57,299
projects like welcome to the nebula some

00:25:55,049 --> 00:26:01,049
people are working on making it run

00:25:57,299 --> 00:26:04,279
inside operating system kernels all of

00:26:01,049 --> 00:26:06,870
these use cases have in common that

00:26:04,279 --> 00:26:10,070
sandboxing and portability as Lyn

00:26:06,870 --> 00:26:13,139
explained are really important for them

00:26:10,070 --> 00:26:15,090
but I want to highlight some additional

00:26:13,139 --> 00:26:19,350
less obvious commonality

00:26:15,090 --> 00:26:21,630
is here for example how do things like

00:26:19,350 --> 00:26:25,350
file access work or talking to the

00:26:21,630 --> 00:26:28,110
network the way to do these things

00:26:25,350 --> 00:26:31,440
should ideally stay the same across all

00:26:28,110 --> 00:26:32,160
of these use cases if you use

00:26:31,440 --> 00:26:34,860
webassembly

00:26:32,160 --> 00:26:37,830
with javascript in the browser or a node

00:26:34,860 --> 00:26:40,970
then javascript is used to let

00:26:37,830 --> 00:26:44,460
webassembly talk to the outside world

00:26:40,970 --> 00:26:48,060
you use fetch in a browser to load a

00:26:44,460 --> 00:26:50,490
file from the server in the browser all

00:26:48,060 --> 00:26:55,050
of this is standardized so you can rely

00:26:50,490 --> 00:26:57,870
on it you use nodes FS thought we'd file

00:26:55,050 --> 00:27:00,180
to read a file from the disk and you can

00:26:57,870 --> 00:27:03,860
also rely on that but for different

00:27:00,180 --> 00:27:09,060
different reason there's really only one

00:27:03,860 --> 00:27:12,650
runtime you'd use node because notice a

00:27:09,060 --> 00:27:15,450
defect of standard so you use the api's

00:27:12,650 --> 00:27:18,230
osuzu you you know the api as you can

00:27:15,450 --> 00:27:20,730
use because it's well notes api's

00:27:18,230 --> 00:27:23,490
ideally ideally we'll have a similar

00:27:20,730 --> 00:27:27,390
situation for web assembly where you

00:27:23,490 --> 00:27:29,070
know what api is you can use but not

00:27:27,390 --> 00:27:32,370
through one branch i'm being completely

00:27:29,070 --> 00:27:35,040
dominant instead we are working towards

00:27:32,370 --> 00:27:38,130
standardized one time at one time

00:27:35,040 --> 00:27:40,260
environment wozy which means there'll be

00:27:38,130 --> 00:27:42,270
a set of functions you can rely on for

00:27:40,260 --> 00:27:45,600
things like file access or network

00:27:42,270 --> 00:27:48,180
access that means you can use you can

00:27:45,600 --> 00:27:50,190
compile your code once and run it in all

00:27:48,180 --> 00:27:52,410
these different environments and in

00:27:50,190 --> 00:27:55,920
difficult one times that provide these

00:27:52,410 --> 00:27:58,560
functions that implement huazi or also

00:27:55,920 --> 00:28:01,050
in the browser where where they can be

00:27:58,560 --> 00:28:03,750
implemented in terms of JavaScript using

00:28:01,050 --> 00:28:05,880
existing Dom API like fetch and in fact

00:28:03,750 --> 00:28:08,010
we do have an implementation of the

00:28:05,880 --> 00:28:13,020
eliminate we version of the y-z

00:28:08,010 --> 00:28:15,210
standards that we put forward so you can

00:28:13,020 --> 00:28:19,320
have one time so they're really tailored

00:28:15,210 --> 00:28:21,390
towards different use cases instead of

00:28:19,320 --> 00:28:25,080
needing to rely on a one-size-fits-all

00:28:21,390 --> 00:28:26,180
solution and for worthy we could have

00:28:25,080 --> 00:28:30,250
said

00:28:26,180 --> 00:28:32,750
let's just use POSIX and be done with it

00:28:30,250 --> 00:28:35,060
unfortunately that eliminates one of

00:28:32,750 --> 00:28:37,340
Webb Assembly's big advantages the

00:28:35,060 --> 00:28:41,900
security model and in particular the

00:28:37,340 --> 00:28:44,180
sandboxing Lin talked about how node had

00:28:41,900 --> 00:28:46,760
a choice to make at least four J's

00:28:44,180 --> 00:28:48,950
modules a choice between keeping the

00:28:46,760 --> 00:28:53,150
sandbox that JavaScript wants in in the

00:28:48,950 --> 00:28:56,810
browser or giving it an easy way to talk

00:28:53,150 --> 00:28:59,360
to the outside world and we now have the

00:28:56,810 --> 00:29:02,480
same choice to make essentially do we go

00:28:59,360 --> 00:29:04,370
with this easiest route but give up on

00:29:02,480 --> 00:29:08,600
sandboxing or do we do something

00:29:04,370 --> 00:29:12,100
different something that enables better

00:29:08,600 --> 00:29:15,350
control and leads to better security and

00:29:12,100 --> 00:29:19,040
auditability that last part is really

00:29:15,350 --> 00:29:21,020
important you should be able to see what

00:29:19,040 --> 00:29:23,960
you're about an application you're about

00:29:21,020 --> 00:29:26,930
to run can do to your system and I'm not

00:29:23,960 --> 00:29:28,820
talking about code review where you're

00:29:26,930 --> 00:29:30,830
really looking school okay what is this

00:29:28,820 --> 00:29:32,860
code trying to do and maybe it's

00:29:30,830 --> 00:29:35,690
malicious code and really hides well

00:29:32,860 --> 00:29:37,280
what it's wise to do instead you should

00:29:35,690 --> 00:29:40,340
be able to essentially look at the tin

00:29:37,280 --> 00:29:44,990
and be able to tell what is the upper

00:29:40,340 --> 00:29:49,700
limit to how this code could access your

00:29:44,990 --> 00:29:53,090
computer with POSIX that is incredibly

00:29:49,700 --> 00:29:55,910
hard and also with other existing system

00:29:53,090 --> 00:29:58,280
api's system interfaces and it requires

00:29:55,910 --> 00:30:01,130
support from the operating system and

00:29:58,280 --> 00:30:04,190
naturally it works differently between

00:30:01,130 --> 00:30:08,870
different operating systems so there

00:30:04,190 --> 00:30:11,200
goes your probability solid portable

00:30:08,870 --> 00:30:13,940
sandboxing is just incredibly hard

00:30:11,200 --> 00:30:17,060
bakwin node was created nobody had

00:30:13,940 --> 00:30:18,070
really figured out how to apply it to

00:30:17,060 --> 00:30:20,870
the real world

00:30:18,070 --> 00:30:24,530
but with things like Google's future

00:30:20,870 --> 00:30:28,610
operating system this has changed better

00:30:24,530 --> 00:30:30,820
designs exist and for wowsie and our

00:30:28,610 --> 00:30:34,310
implementation of where the welcome time

00:30:30,820 --> 00:30:36,950
we are working on a standard lab we

00:30:34,310 --> 00:30:39,389
design that'll make it easy to build

00:30:36,950 --> 00:30:42,149
secure auditable and portable

00:30:39,389 --> 00:30:47,459
modules and applications that'll work

00:30:42,149 --> 00:30:51,479
for all of these different use cases so

00:30:47,459 --> 00:30:53,309
with the standardized API with huazi you

00:30:51,479 --> 00:30:56,279
can get the same flexibility that you

00:30:53,309 --> 00:30:58,349
have with node but still have security

00:30:56,279 --> 00:31:02,339
audit ability and the ability to run

00:30:58,349 --> 00:31:04,379
code in very different one times and we

00:31:02,339 --> 00:31:07,769
are also making sure that you can use

00:31:04,379 --> 00:31:11,820
the tools you're already used to the

00:31:07,769 --> 00:31:14,599
debuggers such as LL DB and gdb and IDE

00:31:11,820 --> 00:31:17,609
such as Xcode and visual studio code and

00:31:14,599 --> 00:31:20,309
just without any modifications without

00:31:17,609 --> 00:31:23,909
special bespoke tooling the compilers

00:31:20,309 --> 00:31:26,909
for languages such as C C++ and other

00:31:23,909 --> 00:31:29,579
languages go edit support

00:31:26,909 --> 00:31:31,669
experimental support for where the two

00:31:29,579 --> 00:31:35,339
days after we announced the

00:31:31,669 --> 00:31:37,589
standardization effort so as you can see

00:31:35,339 --> 00:31:40,259
there's a lot of active development in

00:31:37,589 --> 00:31:43,440
this space we are all working hard to

00:31:40,259 --> 00:31:48,119
make sure it is easy to target these use

00:31:43,440 --> 00:31:51,809
cases and without requiring you all to

00:31:48,119 --> 00:31:55,979
jump through hoops to compile your code

00:31:51,809 --> 00:31:58,079
and to debug it and with this we bring

00:31:55,979 --> 00:31:59,669
these capabilities of the web that Lynn

00:31:58,079 --> 00:32:02,099
mentioned the portability and the

00:31:59,669 --> 00:32:07,339
security and the audit ability that I

00:32:02,099 --> 00:32:07,339
mentioned to all of these use cases

00:32:07,549 --> 00:32:17,219
thank you tow so now let's zoom back out

00:32:13,229 --> 00:32:18,299
and look at this skill tree I said in

00:32:17,219 --> 00:32:19,919
the beginning that people have a

00:32:18,299 --> 00:32:22,229
misconception about web assembly this

00:32:19,919 --> 00:32:24,570
idea that the web assembly that landed

00:32:22,229 --> 00:32:27,269
in the MVP was the final version of web

00:32:24,570 --> 00:32:30,119
assembly I think you can see now why

00:32:27,269 --> 00:32:32,429
this is a misconception yes the MVP

00:32:30,119 --> 00:32:33,989
opened up a lot of opportunities it made

00:32:32,429 --> 00:32:37,049
it possible to bring a lot of desktop

00:32:33,989 --> 00:32:39,599
applications to the web but we still

00:32:37,049 --> 00:32:41,249
have many use cases to unlock from

00:32:39,599 --> 00:32:43,320
heavyweight desktop applications to

00:32:41,249 --> 00:32:45,809
small modules to j/s frameworks and all

00:32:43,320 --> 00:32:48,379
those things outside of the browser node

00:32:45,809 --> 00:32:50,579
and server lists and the blockchain

00:32:48,379 --> 00:32:51,319
portable CLI tools in the Internet of

00:32:50,579 --> 00:32:52,700
Things

00:32:51,319 --> 00:32:55,340
so the

00:32:52,700 --> 00:32:57,109
webassembly that we have today that's

00:32:55,340 --> 00:32:59,059
not the end of the story because

00:32:57,109 --> 00:33:02,499
webassembly still has promised to keep

00:32:59,059 --> 00:33:04,609
and many places to go before it sleeps i

00:33:02,499 --> 00:33:06,409
want to thank my collaborators on

00:33:04,609 --> 00:33:08,299
developing this talk luke Wagner until

00:33:06,409 --> 00:33:09,550
Schneider rate and thank you all for

00:33:08,299 --> 00:33:11,390
listening

00:33:09,550 --> 00:33:17,979
[Applause]

00:33:11,390 --> 00:33:17,979

YouTube URL: https://www.youtube.com/watch?v=ZZ3uj-2H6-w


