Title: Electron: The Event Loop Tightrope - Shelley Vohr | JSHeroes 2019
Publication date: 2019-05-02
Playlist: JSHeroes 2019
Description: 
	On principle, Electron is designed to lower the barrier to entry for development and maintenance of cross-platform desktop development. However, beneath the surface of this seeming magic is a carefully engineered web of JavaScript concepts that need to connect in just the right way to make that magic possible. A JavaScript runtime uses a message queue, or event loop, in order to process messages. Each kind of message has an associated function which handles it, and both Node.js and Chromium, which Electron embeds, have different event loops which must be reconciled. This talk will discuss the principles of the event loop as well as the challenges and solutions that Electron faced and arrived at in order to make the synthesis of Node.js and Chromium in Electron possible. You'll get a glimpse into the inner workings of three powerful open source projects, as well as how they leverage and utilize JavaScript for the benefit of users from beginner to expert.
Captions: 
	00:00:00,070 --> 00:00:03,219
[Music]

00:00:14,539 --> 00:00:20,550
hey everyone I'm excited to be here

00:00:17,789 --> 00:00:23,099
today and to be able to take you on a

00:00:20,550 --> 00:00:26,489
tour of some of the more low-level

00:00:23,099 --> 00:00:30,710
tricks that electron had to employ to

00:00:26,489 --> 00:00:33,510
surpass some of our earliest challenges

00:00:30,710 --> 00:00:36,480
before I do that though let me take a

00:00:33,510 --> 00:00:38,940
brief moment to introduce myself I'm

00:00:36,480 --> 00:00:41,550
Shelly and I work full time on the

00:00:38,940 --> 00:00:44,100
electron project on behalf of github

00:00:41,550 --> 00:00:47,519
where I've been for the past year and a

00:00:44,100 --> 00:00:50,909
half this work has also allowed me to

00:00:47,519 --> 00:00:53,429
explore and participate in a wider range

00:00:50,909 --> 00:00:57,449
of open-source projects and committees

00:00:53,429 --> 00:01:01,829
like node and tc39 I'm based in San

00:00:57,449 --> 00:01:05,670
Francisco some of you may be familiar

00:01:01,829 --> 00:01:09,060
with electron but before we start to dig

00:01:05,670 --> 00:01:11,870
deeper I'll do a brief recap so that we

00:01:09,060 --> 00:01:15,330
can all make sure we're on the same page

00:01:11,870 --> 00:01:17,790
electron is the JavaScript framework for

00:01:15,330 --> 00:01:20,940
creating desktop applications with web

00:01:17,790 --> 00:01:24,810
technologies like JavaScript HTML and

00:01:20,940 --> 00:01:27,990
CSS it can be used on Windows Mac and

00:01:24,810 --> 00:01:32,700
Linux as well as a variety of other

00:01:27,990 --> 00:01:35,430
platforms like raspberry pi it works by

00:01:32,700 --> 00:01:39,210
integrating and depending on chromium

00:01:35,430 --> 00:01:42,690
and node which it uses to allow it both

00:01:39,210 --> 00:01:45,680
the ability to create fully formed GUIs

00:01:42,690 --> 00:01:49,880
as well as to take advantage of

00:01:45,680 --> 00:01:53,730
filesystem and network access with node

00:01:49,880 --> 00:01:56,760
typically desktop applications for each

00:01:53,730 --> 00:01:59,880
operating system are written in each of

00:01:56,760 --> 00:02:03,510
those platforms native language that

00:01:59,880 --> 00:02:07,080
means oftentimes having three teams to

00:02:03,510 --> 00:02:09,209
write three versions of one app electron

00:02:07,080 --> 00:02:13,050
enables you to write your app once and

00:02:09,209 --> 00:02:15,030
have it work on all platforms combining

00:02:13,050 --> 00:02:18,480
these district projects to create the

00:02:15,030 --> 00:02:22,020
electron that developers know today was

00:02:18,480 --> 00:02:24,060
no easy task and so in this talk we're

00:02:22,020 --> 00:02:25,590
going to be walking through some of

00:02:24,060 --> 00:02:27,170
these hairier challenges that we

00:02:25,590 --> 00:02:29,480
encountered the

00:02:27,170 --> 00:02:32,239
engineering concepts that underpin them

00:02:29,480 --> 00:02:35,709
and the solutions that we ultimately

00:02:32,239 --> 00:02:39,099
chose in order to move through them

00:02:35,709 --> 00:02:41,450
chief amongst these challenges was the

00:02:39,099 --> 00:02:44,900
reconciliation of the event loops

00:02:41,450 --> 00:02:46,790
between node and chromium so that's

00:02:44,900 --> 00:02:49,700
where we'll be spending the bulk of our

00:02:46,790 --> 00:02:53,569
time today we'll discuss the event loop

00:02:49,700 --> 00:02:56,599
as it relates to libuv v8 node and

00:02:53,569 --> 00:02:59,120
chromium and the pathways that need to

00:02:56,599 --> 00:03:02,110
be traveled in order to understand how

00:02:59,120 --> 00:03:05,390
they relate to one another

00:03:02,110 --> 00:03:08,510
key to understanding any of these more

00:03:05,390 --> 00:03:11,049
specific details is understanding what

00:03:08,510 --> 00:03:14,480
an event loop even is at a high level

00:03:11,049 --> 00:03:16,940
the event loop forms the basis of the

00:03:14,480 --> 00:03:20,030
concurrency model implemented by

00:03:16,940 --> 00:03:22,640
JavaScript engines it can best be

00:03:20,030 --> 00:03:25,459
conceptualized as an endlessly running

00:03:22,640 --> 00:03:28,280
singly threaded loop where each

00:03:25,459 --> 00:03:31,400
iteration runs a small chunk of the code

00:03:28,280 --> 00:03:34,670
in the program currently being executed

00:03:31,400 --> 00:03:35,769
if you wanted to run a chunk of code at

00:03:34,670 --> 00:03:39,170
a later time

00:03:35,769 --> 00:03:42,049
that chunk would simply be added to a

00:03:39,170 --> 00:03:44,720
queue for the event loop and when the

00:03:42,049 --> 00:03:48,980
time came that you desired it to execute

00:03:44,720 --> 00:03:51,200
it would be DQ'd and executed so that

00:03:48,980 --> 00:03:53,269
was a pretty crappy diagram so let's

00:03:51,200 --> 00:03:56,120
look at an actual diagram that shows us

00:03:53,269 --> 00:03:59,120
what's really going on the process I

00:03:56,120 --> 00:04:02,120
just described whereby actions are added

00:03:59,120 --> 00:04:05,359
to a queue is shown in this diagram with

00:04:02,120 --> 00:04:07,329
tasks one through three so how do a

00:04:05,359 --> 00:04:10,430
synchronous actions factor into this

00:04:07,329 --> 00:04:12,019
well the short answer is that it kind of

00:04:10,430 --> 00:04:14,870
depends on what kind of asynchronous

00:04:12,019 --> 00:04:16,789
action we're talking about if you're

00:04:14,870 --> 00:04:19,609
writing a program that only contains

00:04:16,789 --> 00:04:23,270
callbacks these will be added as a whole

00:04:19,609 --> 00:04:25,280
new events on the event loop queue here

00:04:23,270 --> 00:04:27,650
on the snapshot that would be the

00:04:25,280 --> 00:04:32,240
equivalent of putting a new task for

00:04:27,650 --> 00:04:35,539
immediately following task 3 of some

00:04:32,240 --> 00:04:38,590
note here however is that this paradigm

00:04:35,539 --> 00:04:42,410
is slightly different for promises

00:04:38,590 --> 00:04:44,960
when promises were introduced they

00:04:42,410 --> 00:04:47,510
seemed like a notably improved way to

00:04:44,960 --> 00:04:51,070
handle asynchronous mechanisms and they

00:04:47,510 --> 00:04:53,600
are however they also brought with them

00:04:51,070 --> 00:04:57,590
significant changes to the underlying

00:04:53,600 --> 00:04:59,920
event loop structure promises utilize

00:04:57,590 --> 00:05:03,320
what's known as the micro task queue

00:04:59,920 --> 00:05:06,260
which allows us to say here's this thing

00:05:03,320 --> 00:05:07,790
that I want to do later but I want to

00:05:06,260 --> 00:05:10,970
make sure that it happens right away

00:05:07,790 --> 00:05:13,700
before anything else can happen the

00:05:10,970 --> 00:05:16,940
micro tasks you can best be thought of

00:05:13,700 --> 00:05:21,650
as a little queue attached to each tick

00:05:16,940 --> 00:05:23,840
or task in the event loop promises are

00:05:21,650 --> 00:05:27,050
resolved or rejected and when this

00:05:23,840 --> 00:05:28,730
happens their Associated handlers will

00:05:27,050 --> 00:05:32,570
be called asynchronously

00:05:28,730 --> 00:05:36,680
as micro tasks and so added to the queue

00:05:32,570 --> 00:05:38,720
for the current tick that is to say that

00:05:36,680 --> 00:05:41,180
when you call dot then with arguments

00:05:38,720 --> 00:05:44,740
resolved a reject against a promise

00:05:41,180 --> 00:05:47,570
it immediately queues a micro task any

00:05:44,740 --> 00:05:50,030
additional micro tasks queued during

00:05:47,570 --> 00:05:54,620
this hour outed to the end of the micro

00:05:50,030 --> 00:05:58,160
task queue and also processed in the

00:05:54,620 --> 00:06:01,960
context of node this event loop takes on

00:05:58,160 --> 00:06:06,380
a more specific form with discrete steps

00:06:01,960 --> 00:06:08,720
node is an event based platform what

00:06:06,380 --> 00:06:11,750
this means is that everything that

00:06:08,720 --> 00:06:15,410
happens in node is the reaction to an

00:06:11,750 --> 00:06:18,320
event and that any transaction passing

00:06:15,410 --> 00:06:22,100
through node traverses a series of

00:06:18,320 --> 00:06:23,360
callbacks instead of the developer being

00:06:22,100 --> 00:06:26,870
responsible for this

00:06:23,360 --> 00:06:30,260
it's abstracted away from developers by

00:06:26,870 --> 00:06:32,270
means of a library known as libuv which

00:06:30,260 --> 00:06:35,210
we'll get into in more detail in a few

00:06:32,270 --> 00:06:37,580
minutes but which provides the event

00:06:35,210 --> 00:06:42,890
loop that node uses to handle these

00:06:37,580 --> 00:06:46,160
events the event loop as a process is a

00:06:42,890 --> 00:06:48,740
series of phases with specific tasks

00:06:46,160 --> 00:06:51,590
that are processed in a round robin

00:06:48,740 --> 00:06:52,940
manner nodes fall

00:06:51,590 --> 00:06:55,910
clothes the following order of

00:06:52,940 --> 00:06:59,330
operations which will be important going

00:06:55,910 --> 00:07:02,480
forward as we begin to discuss electrons

00:06:59,330 --> 00:07:05,690
requirements for reconciling it with the

00:07:02,480 --> 00:07:09,140
event loop implemented in chromium we

00:07:05,690 --> 00:07:11,960
start with timers this stage executes

00:07:09,140 --> 00:07:14,420
callbacks scheduled by set timeout and

00:07:11,960 --> 00:07:17,830
set interval which are function specific

00:07:14,420 --> 00:07:21,400
to node next we have pending callbacks

00:07:17,830 --> 00:07:24,230
at this stage we execute IO or

00:07:21,400 --> 00:07:28,790
input-output callbacks deferred to the

00:07:24,230 --> 00:07:30,800
next of loop iteration next we have idle

00:07:28,790 --> 00:07:32,330
in prepare which I really won't get into

00:07:30,800 --> 00:07:37,340
because they're mostly used by node

00:07:32,330 --> 00:07:40,730
internally next poll here we retrieve

00:07:37,340 --> 00:07:45,080
new i/o events and then execute IO

00:07:40,730 --> 00:07:46,610
related callbacks next check which is

00:07:45,080 --> 00:07:49,700
we're set immediate callbacks are

00:07:46,610 --> 00:07:53,480
invoked finally we have close callbacks

00:07:49,700 --> 00:07:56,570
which as the name suggests is where

00:07:53,480 --> 00:07:58,880
close callbacks are processed there's a

00:07:56,570 --> 00:08:01,940
slight discrepancy between the Windows

00:07:58,880 --> 00:08:03,740
and UNIX handling of these phases but

00:08:01,940 --> 00:08:06,200
for the purposes of this talk I'm going

00:08:03,740 --> 00:08:11,510
to alive the specifics in favor of a

00:08:06,200 --> 00:08:14,660
clearer overview of the phases shown in

00:08:11,510 --> 00:08:17,300
the previous diagram there are two that

00:08:14,660 --> 00:08:21,680
were most focused on handling correctly

00:08:17,300 --> 00:08:24,920
in electron these are pending callbacks

00:08:21,680 --> 00:08:28,250
and pulling in the pending callbacks

00:08:24,920 --> 00:08:31,760
phase callbacks are executed for some

00:08:28,250 --> 00:08:34,820
systems operations in the polling phase

00:08:31,760 --> 00:08:37,610
we do two things we perform a

00:08:34,820 --> 00:08:42,320
calculation for how long the event loop

00:08:37,610 --> 00:08:44,900
should block and pull for IO two we

00:08:42,320 --> 00:08:48,800
process events that currently exist in

00:08:44,900 --> 00:08:51,920
the pole Q if the pole Q is not empty

00:08:48,800 --> 00:08:54,230
the event loop will iterate through its

00:08:51,920 --> 00:08:57,380
queue of callbacks and execute them

00:08:54,230 --> 00:09:00,020
synchronously until either the queue has

00:08:57,380 --> 00:09:03,590
been exhausted or the system dependent

00:09:00,020 --> 00:09:04,560
hard limit is reached this is important

00:09:03,590 --> 00:09:07,379
for us

00:09:04,560 --> 00:09:10,499
because we need to notify electrons main

00:09:07,379 --> 00:09:13,589
threat when they happen and in order to

00:09:10,499 --> 00:09:15,569
do this it's crucial that we be informed

00:09:13,589 --> 00:09:19,920
of IO events so that we can

00:09:15,569 --> 00:09:22,170
appropriately react to them Soph talked

00:09:19,920 --> 00:09:24,420
a little bit about libuv and said that

00:09:22,170 --> 00:09:27,749
it powers nodes of vent loop but what

00:09:24,420 --> 00:09:31,470
exactly is that at a very high level

00:09:27,749 --> 00:09:34,319
it's a multi-platform C library that

00:09:31,470 --> 00:09:37,829
provides support for asynchronous IO

00:09:34,319 --> 00:09:40,829
based on event loops it's designed

00:09:37,829 --> 00:09:45,899
around the event-driven asynchronous IO

00:09:40,829 --> 00:09:49,050
model the IO event loop is thus the

00:09:45,899 --> 00:09:52,769
central part of libuv it establishes the

00:09:49,050 --> 00:09:56,249
context for all I o operations and it's

00:09:52,769 --> 00:09:59,240
meant to be tied to a single thread you

00:09:56,249 --> 00:10:02,220
can in fact run multiple event loops

00:09:59,240 --> 00:10:04,319
however each of these must be run in a

00:10:02,220 --> 00:10:09,410
different thread and Libby V is not

00:10:04,319 --> 00:10:11,970
thread safe slightly more specifically

00:10:09,410 --> 00:10:16,290
it's an event loop backed by something

00:10:11,970 --> 00:10:20,490
called KQ for mac OS e poll for linux

00:10:16,290 --> 00:10:23,160
and iocp for Windows these are the

00:10:20,490 --> 00:10:26,600
lower-level mechanisms that let us deal

00:10:23,160 --> 00:10:29,670
with IO events by providing efficient

00:10:26,600 --> 00:10:34,829
input/output event pipelines between the

00:10:29,670 --> 00:10:38,430
system kernel and user land next we'll

00:10:34,829 --> 00:10:41,790
jump into what exactly in libuv we need

00:10:38,430 --> 00:10:43,920
to reconcile however in order to

00:10:41,790 --> 00:10:45,959
understand that you'll need to

00:10:43,920 --> 00:10:49,920
understand what's meant by a file

00:10:45,959 --> 00:10:52,740
descriptor in UNIX and related computer

00:10:49,920 --> 00:10:56,399
operating systems the file descriptor is

00:10:52,740 --> 00:10:59,579
an abstract indicator used to access a

00:10:56,399 --> 00:11:02,879
file or other i/o resource such as a

00:10:59,579 --> 00:11:05,459
pipe or network socket file descriptors

00:11:02,879 --> 00:11:07,230
form a part of the POSIX application

00:11:05,459 --> 00:11:10,829
programming interface and are

00:11:07,230 --> 00:11:12,660
represented by non-negative integers you

00:11:10,829 --> 00:11:14,370
might be a little confused as to why we

00:11:12,660 --> 00:11:17,680
suddenly just jumped from events to

00:11:14,370 --> 00:11:19,540
files in fact UNIX takes

00:11:17,680 --> 00:11:22,000
perspective that everything is a file

00:11:19,540 --> 00:11:24,610
such that reading to and writing from

00:11:22,000 --> 00:11:27,850
files inter-process communication

00:11:24,610 --> 00:11:32,440
network communication and device control

00:11:27,850 --> 00:11:34,810
are all achieved using file IO each UNIX

00:11:32,440 --> 00:11:37,930
process should expect to have three

00:11:34,810 --> 00:11:40,839
standard file descriptors corresponding

00:11:37,930 --> 00:11:44,410
to the three standard streams standard

00:11:40,839 --> 00:11:46,779
in standard out and standard error this

00:11:44,410 --> 00:11:49,690
is important for us because what needs

00:11:46,779 --> 00:11:52,779
to happen essentially is that we need to

00:11:49,690 --> 00:11:56,020
monitor a wide range of file descriptors

00:11:52,779 --> 00:11:58,899
for new input and output so that we can

00:11:56,020 --> 00:12:03,100
take action based on the new events that

00:11:58,899 --> 00:12:05,320
their presence indicates so how does all

00:12:03,100 --> 00:12:07,540
this even relate to electron let's take

00:12:05,320 --> 00:12:08,920
a few steps back and talk about why

00:12:07,540 --> 00:12:12,250
electron cares so much

00:12:08,920 --> 00:12:14,860
if we consider back to electrons purpose

00:12:12,250 --> 00:12:17,410
we remember that it's used to create

00:12:14,860 --> 00:12:20,250
desktop applications which means that

00:12:17,410 --> 00:12:23,529
they need to by necessity be GUI based

00:12:20,250 --> 00:12:26,290
this is both chief difference and what

00:12:23,529 --> 00:12:29,260
presents our main challenge most GUI

00:12:26,290 --> 00:12:32,890
toolkits bring with them their own event

00:12:29,260 --> 00:12:35,830
loops prior to electron there were

00:12:32,890 --> 00:12:38,860
several attempts to use node for GUI

00:12:35,830 --> 00:12:40,990
based applications but they all kept

00:12:38,860 --> 00:12:43,900
running into similar difficulties the

00:12:40,990 --> 00:12:47,800
main thread can only run one loop at the

00:12:43,900 --> 00:12:50,140
same time and the GOI tokens event loop

00:12:47,800 --> 00:12:50,709
would clash with the one provided by

00:12:50,140 --> 00:12:54,339
libuv

00:12:50,709 --> 00:12:57,250
in our case the dua toolkit that we are

00:12:54,339 --> 00:13:02,200
colliding with was the one implemented

00:12:57,250 --> 00:13:05,040
by chromium in chromium and also an

00:13:02,200 --> 00:13:08,410
electron we use something called

00:13:05,040 --> 00:13:11,800
multi-process architecture this is a

00:13:08,410 --> 00:13:14,800
system that seeks to separate aspects of

00:13:11,800 --> 00:13:17,250
electron into separate processes that

00:13:14,800 --> 00:13:20,470
are walled off from one another a

00:13:17,250 --> 00:13:23,050
crashing one of them generally does not

00:13:20,470 --> 00:13:26,680
impair any of the others and each

00:13:23,050 --> 00:13:31,180
process is access to data held and other

00:13:26,680 --> 00:13:33,940
processes is restricted the main process

00:13:31,180 --> 00:13:37,870
controls the lifecycle of your app from

00:13:33,940 --> 00:13:41,110
open to closed when using it you get

00:13:37,870 --> 00:13:44,050
access to the full set of node api's as

00:13:41,110 --> 00:13:47,830
well as all of electrons main process

00:13:44,050 --> 00:13:51,520
modules each module and electron is

00:13:47,830 --> 00:13:55,360
assigned a process and can only be used

00:13:51,520 --> 00:13:57,940
in that process these main process

00:13:55,360 --> 00:14:01,390
modules are responsible for creating

00:13:57,940 --> 00:14:03,430
render processes they also call native

00:14:01,390 --> 00:14:07,090
elements which includes things like

00:14:03,430 --> 00:14:09,460
opening dialogues making menus and other

00:14:07,090 --> 00:14:13,330
resource intensive native operating

00:14:09,460 --> 00:14:17,460
system interactions any given app will

00:14:13,330 --> 00:14:20,860
only ever have exactly one main process

00:14:17,460 --> 00:14:24,070
to illustrate a comparatively simpler

00:14:20,860 --> 00:14:27,100
example here I have a minimum viable

00:14:24,070 --> 00:14:27,850
main process code snippet we're

00:14:27,100 --> 00:14:31,030
requiring

00:14:27,850 --> 00:14:34,330
to of electrons main process modules app

00:14:31,030 --> 00:14:36,370
and browser window you can see that

00:14:34,330 --> 00:14:40,210
we're controlling start and shut down

00:14:36,370 --> 00:14:42,640
with app we also create a basic browser

00:14:40,210 --> 00:14:46,300
window into which we could load either a

00:14:42,640 --> 00:14:49,090
file or a web page when all windows are

00:14:46,300 --> 00:14:54,760
closed and the event is emitted to

00:14:49,090 --> 00:14:57,460
indicate such we quit the app the render

00:14:54,760 --> 00:15:00,820
process is basically a browser window

00:14:57,460 --> 00:15:03,700
within your app unlike the main process

00:15:00,820 --> 00:15:07,060
there can be more than one and each is

00:15:03,700 --> 00:15:10,030
independent meaning as I mentioned that

00:15:07,060 --> 00:15:13,930
a crashing one won't affect any of the

00:15:10,030 --> 00:15:16,990
others it's responsible for running and

00:15:13,930 --> 00:15:20,530
rendering web pages and when you use it

00:15:16,990 --> 00:15:23,500
you get access to dom api's electrons

00:15:20,530 --> 00:15:26,470
set of render process modules and then

00:15:23,500 --> 00:15:31,960
optionally access to all node api's

00:15:26,470 --> 00:15:35,320
should you enable node integration here

00:15:31,960 --> 00:15:38,080
a window and electron is created using

00:15:35,320 --> 00:15:40,510
the browser window class which we saw

00:15:38,080 --> 00:15:43,810
earlier is only available in the main

00:15:40,510 --> 00:15:44,329
process since communication between the

00:15:43,810 --> 00:15:47,959
process

00:15:44,329 --> 00:15:51,399
as possible a render process can call

00:15:47,959 --> 00:15:54,110
upon the main process to perform tasks

00:15:51,399 --> 00:15:58,040
electron comes with a module called

00:15:54,110 --> 00:16:01,819
remote that exposes ap is usually only

00:15:58,040 --> 00:16:04,459
available in the main process in order

00:16:01,819 --> 00:16:06,799
to create a browser window from a render

00:16:04,459 --> 00:16:10,549
process we'd use the remote as a

00:16:06,799 --> 00:16:13,579
middleman like you can see here electron

00:16:10,549 --> 00:16:16,639
also provides two other modules IPC

00:16:13,579 --> 00:16:18,829
renderer and IPC main which allows for

00:16:16,639 --> 00:16:21,470
developers to enable asynchronous

00:16:18,829 --> 00:16:26,209
communication from a renderer process to

00:16:21,470 --> 00:16:28,819
the main process and vice versa so why

00:16:26,209 --> 00:16:32,079
are we talking about processes anyway it

00:16:28,819 --> 00:16:35,869
turns out that event loop integration is

00:16:32,079 --> 00:16:38,899
actually slightly different for each Pro

00:16:35,869 --> 00:16:42,249
Miam on its face is a very multi

00:16:38,899 --> 00:16:45,610
threaded product its architecture is

00:16:42,249 --> 00:16:48,529
designed to try and keep the UI as

00:16:45,610 --> 00:16:51,559
responsive as possible which means not

00:16:48,529 --> 00:16:54,790
blocking the UI thread with any blocking

00:16:51,559 --> 00:16:57,980
i/o or similarly expensive operations

00:16:54,790 --> 00:16:59,899
their approach is to use message passing

00:16:57,980 --> 00:17:02,540
which is similar to what I just

00:16:59,899 --> 00:17:04,699
mentioned with IPC renderer and IPC main

00:17:02,540 --> 00:17:06,589
as the preferred method for

00:17:04,699 --> 00:17:10,850
communicating between threads and

00:17:06,589 --> 00:17:13,730
processes instead objects live only on

00:17:10,850 --> 00:17:16,250
one thread and then uses callback

00:17:13,730 --> 00:17:22,970
interfaces for most cross process

00:17:16,250 --> 00:17:25,480
requests chromium's event loop which

00:17:22,970 --> 00:17:27,949
they call their message loop is

00:17:25,480 --> 00:17:32,000
implemented in both the renderer and

00:17:27,949 --> 00:17:35,450
browser processes it's done with a base

00:17:32,000 --> 00:17:38,299
message loop class and subclasses that

00:17:35,450 --> 00:17:42,159
address thread and process specific

00:17:38,299 --> 00:17:46,070
needs a message loop is used to process

00:17:42,159 --> 00:17:49,010
events for a particular thread and there

00:17:46,070 --> 00:17:52,760
is at most one message loop instance per

00:17:49,010 --> 00:17:55,580
thread when a task is posted to the

00:17:52,760 --> 00:17:57,149
message loop these tasks are invoked in

00:17:55,580 --> 00:18:00,989
FIFO our first

00:17:57,149 --> 00:18:05,820
first out order intermixed with normal

00:18:00,989 --> 00:18:08,789
UI or i/o event processing every chrome

00:18:05,820 --> 00:18:12,029
process has a main thread which the

00:18:08,789 --> 00:18:15,419
browser our main process uses to update

00:18:12,029 --> 00:18:17,639
the UI and in render processes runs most

00:18:15,419 --> 00:18:21,679
of Chrome's rendering engine which is

00:18:17,639 --> 00:18:25,229
called blink it also has an i/o thread

00:18:21,679 --> 00:18:27,629
which the browser process uses to handle

00:18:25,229 --> 00:18:31,499
inter-process communications and network

00:18:27,629 --> 00:18:34,889
and in the renderer process only handles

00:18:31,499 --> 00:18:37,229
inter-process communications beyond that

00:18:34,889 --> 00:18:39,779
the process has a few more

00:18:37,229 --> 00:18:42,839
special-purpose threads as well as a

00:18:39,779 --> 00:18:44,099
pool of general-purpose threads but

00:18:42,839 --> 00:18:48,479
these are less important for our

00:18:44,099 --> 00:18:51,330
purposes today most threads have a loop

00:18:48,479 --> 00:18:53,549
that gets tossed from a queue and runs

00:18:51,330 --> 00:18:55,379
them this should sound someone familiar

00:18:53,549 --> 00:18:59,549
if we think back to what I was talking

00:18:55,379 --> 00:19:02,460
about earlier with nodes event loop this

00:18:59,549 --> 00:19:05,489
takes us to our first reconciliation

00:19:02,460 --> 00:19:07,649
attempt which was essentially to

00:19:05,489 --> 00:19:11,849
re-implement chromium's

00:19:07,649 --> 00:19:14,399
message loop by means of libuv in order

00:19:11,849 --> 00:19:17,549
to do this we needed to extract the

00:19:14,399 --> 00:19:21,210
underlying file descriptors from the

00:19:17,549 --> 00:19:23,339
message loops for each platform this was

00:19:21,210 --> 00:19:25,559
fairly straightforward just when we

00:19:23,339 --> 00:19:27,779
consider the render process because

00:19:25,559 --> 00:19:30,330
there's really only one message loop

00:19:27,779 --> 00:19:34,679
subclass prison called message loop for

00:19:30,330 --> 00:19:37,529
UI this subclass only listened to file

00:19:34,679 --> 00:19:40,429
descriptors on timers and so we could

00:19:37,529 --> 00:19:43,919
re-implement this interface with libuv

00:19:40,429 --> 00:19:48,479
however it was not quite so simple for

00:19:43,919 --> 00:19:52,529
the main process each desktop platform

00:19:48,479 --> 00:19:56,549
has its own kind of GUI message loop and

00:19:52,529 --> 00:20:00,869
thus message loop subclass for example

00:19:56,549 --> 00:20:04,349
on Mac chromium uses NS run loop whereas

00:20:00,869 --> 00:20:05,669
Linux uses something called G lib these

00:20:04,349 --> 00:20:08,960
platform-specific

00:20:05,669 --> 00:20:12,250
items our programming interfaces

00:20:08,960 --> 00:20:15,409
objects that manage input sources

00:20:12,250 --> 00:20:17,419
unfortunately this platform specificity

00:20:15,409 --> 00:20:19,610
meant that we couldn't replicate the

00:20:17,419 --> 00:20:22,640
approach that we took for the render

00:20:19,610 --> 00:20:26,500
process because as you can see the

00:20:22,640 --> 00:20:30,529
renderer process just uses one subclass

00:20:26,500 --> 00:20:32,330
initially we tried a variety of hacks to

00:20:30,529 --> 00:20:35,350
extract these underlying file

00:20:32,330 --> 00:20:39,110
descriptors out of the native GUI loops

00:20:35,350 --> 00:20:41,510
the idea behind this was then that we

00:20:39,110 --> 00:20:44,720
could feed them to libuv for iteration

00:20:41,510 --> 00:20:47,690
so they'd be processed in the same way

00:20:44,720 --> 00:20:51,169
as events already being processed by

00:20:47,690 --> 00:20:53,899
nodes event loop however this approach

00:20:51,169 --> 00:20:55,970
was very error-prone and we found far

00:20:53,899 --> 00:20:58,399
too many edge cases that we need to

00:20:55,970 --> 00:21:01,520
address in order to deliver what we felt

00:20:58,399 --> 00:21:03,440
to be an acceptable user experience we

00:21:01,520 --> 00:21:05,570
knew this was an unacceptable long term

00:21:03,440 --> 00:21:10,340
solution and so we looked ahead to

00:21:05,570 --> 00:21:12,320
something else as a second attempt we

00:21:10,340 --> 00:21:15,950
tried to run both event loops together

00:21:12,320 --> 00:21:18,350
in electrons main thread by pumping the

00:21:15,950 --> 00:21:21,260
event loops in a timer with a really

00:21:18,350 --> 00:21:23,480
really small interval this meant that

00:21:21,260 --> 00:21:25,789
we'd be alternating loops as quickly as

00:21:23,480 --> 00:21:27,289
possible which honestly when you hear me

00:21:25,789 --> 00:21:28,669
say it out loud I feel like you can

00:21:27,289 --> 00:21:31,970
probably already tell that sounds like

00:21:28,669 --> 00:21:34,929
kind of a sketchy solution and as you

00:21:31,970 --> 00:21:38,510
can probably expect this created

00:21:34,929 --> 00:21:41,360
significant problems from the outset it

00:21:38,510 --> 00:21:44,690
notably slowed down interface response

00:21:41,360 --> 00:21:47,870
and occupied a rather notable number of

00:21:44,690 --> 00:21:49,970
system resources since electron is

00:21:47,870 --> 00:21:53,270
designed to make desktop application

00:21:49,970 --> 00:21:54,590
creation easier and not harder we knew

00:21:53,270 --> 00:21:56,679
that we couldn't proceed with this

00:21:54,590 --> 00:21:59,960
either

00:21:56,679 --> 00:22:02,779
finally we tried the first attempt in

00:21:59,960 --> 00:22:05,179
Reverse instead of trying to bring

00:22:02,779 --> 00:22:08,120
chromium's events into nodes event loop

00:22:05,179 --> 00:22:10,789
this time we brought nodes events into

00:22:08,120 --> 00:22:14,299
chromium's event loop under this

00:22:10,789 --> 00:22:17,360
strategy electrons main thread runs

00:22:14,299 --> 00:22:20,929
chromium's event loop a second thread

00:22:17,360 --> 00:22:22,450
handles nodes libuv loop but rather than

00:22:20,929 --> 00:22:25,090
actually running this loop

00:22:22,450 --> 00:22:28,450
what we do is we inspect it with a

00:22:25,090 --> 00:22:32,289
method exposed by libuv called UV vaca

00:22:28,450 --> 00:22:34,869
and FD what this allows us to do is get

00:22:32,289 --> 00:22:38,289
the event loops file descriptor the

00:22:34,869 --> 00:22:41,669
second thread exists to pull if we hark

00:22:38,289 --> 00:22:45,820
back to that stage of nodes event loop

00:22:41,669 --> 00:22:48,249
for events when it finds some events it

00:22:45,820 --> 00:22:52,600
queues up a task in chromium's event

00:22:48,249 --> 00:22:54,629
loop back in the main thread chromium's

00:22:52,600 --> 00:22:58,149
event loop invokes that task

00:22:54,629 --> 00:23:00,340
this makes libuv process all pending

00:22:58,149 --> 00:23:04,210
events without waiting for new ones

00:23:00,340 --> 00:23:06,940
so the pending no to vents are processed

00:23:04,210 --> 00:23:09,609
and then our task ends we're turning

00:23:06,940 --> 00:23:13,779
control flow back to chromium's event

00:23:09,609 --> 00:23:16,799
loop with this approach node events can

00:23:13,779 --> 00:23:18,759
be processed efficiently in sequence

00:23:16,799 --> 00:23:23,230
inside of chromium's

00:23:18,759 --> 00:23:25,359
event loop this finally allowed us to

00:23:23,230 --> 00:23:29,559
achieve our goal and deliver the

00:23:25,359 --> 00:23:31,389
electron you're able to use today I'd

00:23:29,559 --> 00:23:33,970
love to dive more deeply into some of

00:23:31,389 --> 00:23:36,220
these subtopics but sadly there's no

00:23:33,970 --> 00:23:38,139
real way for me to do that to the extent

00:23:36,220 --> 00:23:40,720
that I'd like without running horribly

00:23:38,139 --> 00:23:43,450
over time so I've included some relevant

00:23:40,720 --> 00:23:47,429
links from earlier slide topics that you

00:23:43,450 --> 00:23:50,049
can consult should you want to know more

00:23:47,429 --> 00:23:52,929
Wahl our history is filled with

00:23:50,049 --> 00:23:55,269
interesting engineering efforts today's

00:23:52,929 --> 00:23:57,700
work on electron is also filled with

00:23:55,269 --> 00:24:00,519
challenges requiring unique perspectives

00:23:57,700 --> 00:24:02,590
and we'd love your input please come

00:24:00,519 --> 00:24:04,989
find me if you have follow-up questions

00:24:02,590 --> 00:24:07,359
wanna chat about what contributing to

00:24:04,989 --> 00:24:09,669
electron entails or just want to chat

00:24:07,359 --> 00:24:12,380
generally about open source software and

00:24:09,669 --> 00:24:13,850
its ecosystems thank you very much

00:24:12,380 --> 00:24:16,400
[Applause]

00:24:13,850 --> 00:24:19,449
[Music]

00:24:16,400 --> 00:24:19,449

YouTube URL: https://www.youtube.com/watch?v=OPhb5GoV8Xk


