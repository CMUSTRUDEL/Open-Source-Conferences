Title: The universe in a single arrow: A live dive into the lambda calculus - Anjana Vakil | JSHeroes 2019
Publication date: 2019-05-02
Playlist: JSHeroes 2019
Description: 
	You know that a tiny anonymous function, like a JS arrow function, can be useful when you’re feeling too lazy to think up a good name. But did you know that this humble little arrow can summon one of the most powerful & elegant abstractions in the history of computer science?

The lambda calculus lets us represent our programs - all their logic and data - with nothing but pure, anonymous functions. Booleans, numbers, operators, control flow, data structures… an arrow can do it all! In this session we'll live-code our way to a deeper understanding & admiration of the computational power of the lambda, an abstraction fundamental to functional programming.
Captions: 
	00:00:00,070 --> 00:00:03,219
[Music]

00:00:15,400 --> 00:00:22,040
hi hi everybody

00:00:18,880 --> 00:00:23,360
sorry about the delay show business no

00:00:22,040 --> 00:00:26,270
business like it

00:00:23,360 --> 00:00:28,460
my name is Angie neva Kiel hello I'm

00:00:26,270 --> 00:00:31,640
really excited to be back at Jay s heros

00:00:28,460 --> 00:00:34,340
the second time two years in a row you

00:00:31,640 --> 00:00:36,080
can find me on Twitter at my name

00:00:34,340 --> 00:00:37,970
because I'm not creative with Internet

00:00:36,080 --> 00:00:39,739
handles and if you look at my latest

00:00:37,970 --> 00:00:41,090
tweet you can see the slides that I'm

00:00:39,739 --> 00:00:43,540
actually gonna go through well not the

00:00:41,090 --> 00:00:49,030
slides but the material and then some so

00:00:43,540 --> 00:00:52,160
this is gonna be a experimental live

00:00:49,030 --> 00:00:53,270
exploration of the lambda calculus which

00:00:52,160 --> 00:00:56,030
we're going to talk more about what that

00:00:53,270 --> 00:01:00,050
is in a second but I'm hoping that you

00:00:56,030 --> 00:01:02,480
all can do this with me as we right now

00:01:00,050 --> 00:01:05,059
here live on stage dig into what I think

00:01:02,480 --> 00:01:07,700
is one of the most beautiful and elegant

00:01:05,059 --> 00:01:10,280
and interesting abstractions in the

00:01:07,700 --> 00:01:13,759
history of computer science so Before we

00:01:10,280 --> 00:01:16,670
jump into all that just really quickly

00:01:13,759 --> 00:01:19,820
some some organizations and communities

00:01:16,670 --> 00:01:22,220
that I am so lucky and so proud to be a

00:01:19,820 --> 00:01:24,440
part of so I work at map box in San

00:01:22,220 --> 00:01:27,680
Francisco any map box users in the house

00:01:24,440 --> 00:01:29,299
a few hands cool we make a location data

00:01:27,680 --> 00:01:32,140
platform for developers to build

00:01:29,299 --> 00:01:34,189
beautiful maps and navigation

00:01:32,140 --> 00:01:37,010
experiences in all kinds of location

00:01:34,189 --> 00:01:38,540
powered apps check it out I'm also a

00:01:37,010 --> 00:01:40,600
member of the Mozilla Tech speaker is

00:01:38,540 --> 00:01:44,090
Mozilla Tech speakers in the house oh

00:01:40,600 --> 00:01:46,659
yeah we love to wander the world talking

00:01:44,090 --> 00:01:48,830
about open web technologies check it out

00:01:46,659 --> 00:01:50,390
all of these things are linked in my

00:01:48,830 --> 00:01:53,270
Twitter bio by the way so you can find

00:01:50,390 --> 00:01:55,610
links there I am also an alumna of the

00:01:53,270 --> 00:01:57,350
recurse Center recurse Center is a

00:01:55,610 --> 00:01:59,420
programming retreat in New York City

00:01:57,350 --> 00:02:01,280
it's free it's self-directed it's a

00:01:59,420 --> 00:02:03,350
wonderful place to go and learn more

00:02:01,280 --> 00:02:05,329
about programming get better at coding

00:02:03,350 --> 00:02:07,850
whatever that means to you check it out

00:02:05,329 --> 00:02:10,820
and finally I'm an alumna of outreach e

00:02:07,850 --> 00:02:11,930
any outreach e alums in the house whoa

00:02:10,820 --> 00:02:14,000
yes

00:02:11,930 --> 00:02:16,010
all right so outreach e is an amazing

00:02:14,000 --> 00:02:18,230
initiative to get more women involved in

00:02:16,010 --> 00:02:20,510
open source by offering paid remote

00:02:18,230 --> 00:02:23,359
internships and organizations and

00:02:20,510 --> 00:02:25,220
projects like Mozilla so if you know

00:02:23,359 --> 00:02:26,630
somebody looking for a paid remote inter

00:02:25,220 --> 00:02:28,640
ship who is a woman and wants to get

00:02:26,630 --> 00:02:32,420
into open-source checkout outreach e

00:02:28,640 --> 00:02:34,610
alright so I said I'm here to talk about

00:02:32,420 --> 00:02:37,010
the lambda calculus the water calculus

00:02:34,610 --> 00:02:40,520
the lambda calculus so this is too big

00:02:37,010 --> 00:02:42,860
the lambda calculus is lambda like the

00:02:40,520 --> 00:02:44,270
Greek letter lambda this triangle II

00:02:42,860 --> 00:02:46,490
looking thing with a little sprout on

00:02:44,270 --> 00:02:49,070
the top yeah that you might recognize

00:02:46,490 --> 00:02:50,740
that symbol from the logo of every

00:02:49,070 --> 00:02:53,330
functional programming language ever

00:02:50,740 --> 00:02:55,520
like Haskell and closure and that's

00:02:53,330 --> 00:02:57,380
because the lambda calculus is kind of

00:02:55,520 --> 00:02:59,390
the abstractions and the formalisms of

00:02:57,380 --> 00:03:01,160
the lambda calculus are really

00:02:59,390 --> 00:03:02,810
foundational to though all of the

00:03:01,160 --> 00:03:05,240
practice of functional programming that

00:03:02,810 --> 00:03:07,930
we know and love today but it goes way

00:03:05,240 --> 00:03:10,220
back beyond that so this was a

00:03:07,930 --> 00:03:13,160
mathematical and logical formalism

00:03:10,220 --> 00:03:16,370
created by this dude Alonzo Church one

00:03:13,160 --> 00:03:17,990
of my heroes back in the 30s beginning

00:03:16,370 --> 00:03:21,140
in the 30s and he was trying to

00:03:17,990 --> 00:03:23,540
investigate the nature of logic and

00:03:21,140 --> 00:03:26,540
mathematics and giant philosophical

00:03:23,540 --> 00:03:28,670
concepts like that love it and he

00:03:26,540 --> 00:03:30,200
created this system the lambda calculus

00:03:28,670 --> 00:03:32,360
and basically fell down this huge

00:03:30,200 --> 00:03:35,420
wormhole with all of this stuff like the

00:03:32,360 --> 00:03:37,700
nature of logic and computation and we

00:03:35,420 --> 00:03:40,100
collectively as a discipline in computer

00:03:37,700 --> 00:03:41,780
science and particularly the functional

00:03:40,100 --> 00:03:43,850
traditions and computer science have

00:03:41,780 --> 00:03:45,680
been collectively falling down that

00:03:43,850 --> 00:03:47,570
really interesting rabbit hole for the

00:03:45,680 --> 00:03:50,570
last like what going on a hundred years

00:03:47,570 --> 00:03:52,820
now so this is a really cool interesting

00:03:50,570 --> 00:03:55,280
way of representing computation and

00:03:52,820 --> 00:03:57,410
what's so cool about it I think is that

00:03:55,280 --> 00:04:00,200
the lambda calculus is founded on just

00:03:57,410 --> 00:04:02,860
one tiny little abstraction one tiny

00:04:00,200 --> 00:04:05,480
construct and from that we can model

00:04:02,860 --> 00:04:07,340
anything computable anything a Turing

00:04:05,480 --> 00:04:09,170
machine can do this thing can do this

00:04:07,340 --> 00:04:11,030
one little thing and in our case we're

00:04:09,170 --> 00:04:14,450
gonna do it in JavaScript using an arrow

00:04:11,030 --> 00:04:17,359
function so one arrow can recreate all

00:04:14,450 --> 00:04:20,510
of computation so no big deal you know

00:04:17,359 --> 00:04:22,669
in any case what we're gonna do today

00:04:20,510 --> 00:04:25,310
we're gonna play a little game if we

00:04:22,669 --> 00:04:28,010
treat a JavaScript arrow function like a

00:04:25,310 --> 00:04:29,570
lambda calculus lambda function what can

00:04:28,010 --> 00:04:31,970
we do what can we make with it I've

00:04:29,570 --> 00:04:35,150
already given away the answer everything

00:04:31,970 --> 00:04:37,970
literally everything in computation but

00:04:35,150 --> 00:04:38,960
just because we can do computation this

00:04:37,970 --> 00:04:41,780
way does not mean that

00:04:38,960 --> 00:04:43,819
should do computation this way so this

00:04:41,780 --> 00:04:45,889
is not going to be a practical

00:04:43,819 --> 00:04:48,169
programming talk in fact this is going

00:04:45,889 --> 00:04:51,289
to be the most useless talk you see at

00:04:48,169 --> 00:04:53,690
this entire conference do not go back to

00:04:51,289 --> 00:04:55,099
your boss on Monday and try to suggest

00:04:53,690 --> 00:04:58,130
that you all write code in lambda

00:04:55,099 --> 00:05:00,889
calculus no this is not about practical

00:04:58,130 --> 00:05:03,620
programming this is about expanding our

00:05:00,889 --> 00:05:05,060
idea of how computation can work so what

00:05:03,620 --> 00:05:06,650
we're gonna do here is going to be

00:05:05,060 --> 00:05:08,690
pretty silly it's gonna be pretty

00:05:06,650 --> 00:05:11,360
experimental but hopefully it's gonna

00:05:08,690 --> 00:05:13,910
help us all think about computation in a

00:05:11,360 --> 00:05:15,380
new and interesting way and expand our

00:05:13,910 --> 00:05:17,330
brains a little bit so that's the idea

00:05:15,380 --> 00:05:19,490
if you'd rather be learning practical

00:05:17,330 --> 00:05:21,289
programming stuff I won't be offended if

00:05:19,490 --> 00:05:23,090
you step outside or put in those earbuds

00:05:21,289 --> 00:05:25,070
and start googling all the cool

00:05:23,090 --> 00:05:28,340
frameworks and libraries you've been

00:05:25,070 --> 00:05:29,570
hearing about today and yesterday so no

00:05:28,340 --> 00:05:31,669
worries there but what we're gonna do

00:05:29,570 --> 00:05:34,909
here is gonna get a little silly alright

00:05:31,669 --> 00:05:36,530
so I said let's use an arrow function

00:05:34,909 --> 00:05:38,750
like a lambda function what does that

00:05:36,530 --> 00:05:41,270
even mean what is a lambda function in

00:05:38,750 --> 00:05:43,630
the lambda calculus sense not the aw s

00:05:41,270 --> 00:05:46,880
sense nothing to do with that so

00:05:43,630 --> 00:05:49,759
basically in the lambda calculus we have

00:05:46,880 --> 00:05:51,199
a way of making functions that it's in

00:05:49,759 --> 00:05:53,300
tactically looks a little different from

00:05:51,199 --> 00:05:55,310
what we're used to so can you'll see my

00:05:53,300 --> 00:05:58,310
pointer here so in the lambda calculus

00:05:55,310 --> 00:06:00,320
we use the lambda symbol and then some

00:05:58,310 --> 00:06:02,150
variable in this case like X would

00:06:00,320 --> 00:06:05,330
represent like an input to this function

00:06:02,150 --> 00:06:07,310
then we have a dot and then anything to

00:06:05,330 --> 00:06:09,800
the right of the dot is basically the

00:06:07,310 --> 00:06:12,259
body of the function so right here we're

00:06:09,800 --> 00:06:13,909
making a function that is essentially

00:06:12,259 --> 00:06:17,240
the identity function so it takes in

00:06:13,909 --> 00:06:18,469
some input X and it returns X and that's

00:06:17,240 --> 00:06:20,330
how we would represent it in lambda

00:06:18,469 --> 00:06:22,880
calculus syntax how we would represent

00:06:20,330 --> 00:06:25,039
it in JavaScript arrow function syntax

00:06:22,880 --> 00:06:28,070
probably looks a bit more familiar we

00:06:25,039 --> 00:06:31,639
have the input to the left of this equal

00:06:28,070 --> 00:06:33,830
sign greater than this arrow and then

00:06:31,639 --> 00:06:35,750
whatever we want to return directly

00:06:33,830 --> 00:06:38,060
following that now we could have

00:06:35,750 --> 00:06:39,440
parentheses around that input X but if

00:06:38,060 --> 00:06:41,210
we only have one thing we don't need

00:06:39,440 --> 00:06:43,400
them so for cleanliness sake we're just

00:06:41,210 --> 00:06:44,719
gonna leave them out and this is so that

00:06:43,400 --> 00:06:46,580
what we've done here in the lambda

00:06:44,719 --> 00:06:48,589
calculus this is sort of like declaring

00:06:46,580 --> 00:06:50,539
a function but in lambda calculus that's

00:06:48,589 --> 00:06:52,310
called function abstraction because

00:06:50,539 --> 00:06:55,430
everything in functional programming

00:06:52,310 --> 00:06:56,780
has to have a fancy technical term so if

00:06:55,430 --> 00:06:57,440
you hear function abstraction that's

00:06:56,780 --> 00:06:59,630
what that's about

00:06:57,440 --> 00:07:02,389
and here's the thing about the lambda

00:06:59,630 --> 00:07:03,830
calculus unlike JavaScript function

00:07:02,389 --> 00:07:06,080
script arrow functions which allow us to

00:07:03,830 --> 00:07:08,840
have however many input arguments we

00:07:06,080 --> 00:07:11,389
want if we use parentheses and commas in

00:07:08,840 --> 00:07:14,720
the lambda calculus we only get one

00:07:11,389 --> 00:07:17,450
input to each function one argument so

00:07:14,720 --> 00:07:20,090
if we want to do something that like

00:07:17,450 --> 00:07:21,889
conceptually requires multiple pieces of

00:07:20,090 --> 00:07:24,290
information like let's say adding

00:07:21,889 --> 00:07:26,600
together two numbers we have to kind of

00:07:24,290 --> 00:07:28,910
layer these lambda functions or chained

00:07:26,600 --> 00:07:30,950
them together so what we do is we we

00:07:28,910 --> 00:07:32,930
create a function that takes in one of

00:07:30,950 --> 00:07:34,910
those numbers the first one X and that

00:07:32,930 --> 00:07:37,490
returns so everything to the right here

00:07:34,910 --> 00:07:40,730
that returns another function which

00:07:37,490 --> 00:07:43,750
takes in the second number and that

00:07:40,730 --> 00:07:47,180
returns then the addition of the two

00:07:43,750 --> 00:07:50,090
cool so if we want to take in multiple

00:07:47,180 --> 00:07:51,889
inputs we need to chain these functions

00:07:50,090 --> 00:07:54,380
together this way and we can do that in

00:07:51,889 --> 00:07:56,479
arrow syntax as well by having an arrow

00:07:54,380 --> 00:07:58,820
function that takes in X and returns an

00:07:56,479 --> 00:08:02,150
arrow function that takes in Y and

00:07:58,820 --> 00:08:03,320
returns X plus y everybody on board okay

00:08:02,150 --> 00:08:05,000
so we're just we're going to restrict

00:08:03,320 --> 00:08:07,400
ourselves to this this is like the game

00:08:05,000 --> 00:08:09,169
that we're gonna play and then we also

00:08:07,400 --> 00:08:11,090
we it's not enough to just like create

00:08:09,169 --> 00:08:13,160
functions all over the place we want to

00:08:11,090 --> 00:08:15,460
use them eventually in lambda calculus

00:08:13,160 --> 00:08:18,229
speak that's called function application

00:08:15,460 --> 00:08:19,940
basically calling our function in the

00:08:18,229 --> 00:08:21,470
lambda calculus syntax what we would do

00:08:19,940 --> 00:08:24,260
is we would have the function and then a

00:08:21,470 --> 00:08:26,780
space and then the values that we want

00:08:24,260 --> 00:08:28,220
to apply the function to or the values

00:08:26,780 --> 00:08:32,030
that we want to call the function with

00:08:28,220 --> 00:08:33,680
and regular programmer speak and in in

00:08:32,030 --> 00:08:35,180
in JavaScript that's going to look

00:08:33,680 --> 00:08:37,580
pretty much the same except it had

00:08:35,180 --> 00:08:39,860
instead of having spaces to indicate the

00:08:37,580 --> 00:08:41,750
the values that we're passing in we're

00:08:39,860 --> 00:08:44,690
going to use parentheses to say okay I'm

00:08:41,750 --> 00:08:45,800
calling this function here on five and

00:08:44,690 --> 00:08:47,120
then that's going to return another

00:08:45,800 --> 00:08:48,470
function right because we're taking in

00:08:47,120 --> 00:08:51,890
this Y now and then we're calling that

00:08:48,470 --> 00:08:53,360
on one so this is just syntactically it

00:08:51,890 --> 00:08:55,640
looks a little weird because we're used

00:08:53,360 --> 00:08:57,350
to passing in arguments with like commas

00:08:55,640 --> 00:08:59,089
right but this is just this we're gonna

00:08:57,350 --> 00:09:02,240
we're gonna play this syntax game we're

00:08:59,089 --> 00:09:04,820
gonna do it this way on board cool all

00:09:02,240 --> 00:09:05,900
right awesome so now we know the rules

00:09:04,820 --> 00:09:08,000
of the game

00:09:05,900 --> 00:09:09,910
can we do how about we make some numbers

00:09:08,000 --> 00:09:14,420
because programmers like numbers write

00:09:09,910 --> 00:09:16,400
numbers like oh yeah we're numbers how

00:09:14,420 --> 00:09:18,140
about counting with whole numbers

00:09:16,400 --> 00:09:19,400
counting is fun we can count things

00:09:18,140 --> 00:09:22,100
that's cool

00:09:19,400 --> 00:09:26,360
all right counting is useful what can we

00:09:22,100 --> 00:09:29,420
count in a world where all we have is

00:09:26,360 --> 00:09:31,070
the concept of a function we don't have

00:09:29,420 --> 00:09:33,590
any other data type we're starting from

00:09:31,070 --> 00:09:35,810
scratch here all we've got is this idea

00:09:33,590 --> 00:09:37,820
of functions with single input and

00:09:35,810 --> 00:09:43,460
single output I'm gonna let you think

00:09:37,820 --> 00:09:46,730
about that what can we count we can

00:09:43,460 --> 00:09:48,320
count functions but we actually we want

00:09:46,730 --> 00:09:49,640
to be able to like do things with this

00:09:48,320 --> 00:09:51,170
right so when we're talking about like

00:09:49,640 --> 00:09:52,760
running our programs what we can

00:09:51,170 --> 00:09:53,900
actually do is not not count the number

00:09:52,760 --> 00:09:55,580
of functions that we've created but

00:09:53,900 --> 00:09:57,830
actually take a single function and

00:09:55,580 --> 00:10:00,110
apply it a certain number of times or

00:09:57,830 --> 00:10:01,880
call it a certain number of times and we

00:10:00,110 --> 00:10:05,060
could treat each call to that function

00:10:01,880 --> 00:10:06,860
as like counting one more so I call the

00:10:05,060 --> 00:10:08,420
function once I count one call it again

00:10:06,860 --> 00:10:10,010
I count two call it again

00:10:08,420 --> 00:10:12,110
I count three so we're gonna count

00:10:10,010 --> 00:10:15,140
function applications or call us to the

00:10:12,110 --> 00:10:18,200
function okay so that means numbers are

00:10:15,140 --> 00:10:22,190
gonna be things that apply functions a

00:10:18,200 --> 00:10:24,110
certain number of times to inputs this

00:10:22,190 --> 00:10:26,990
is gonna get weird so buckle up alright

00:10:24,110 --> 00:10:28,820
so if I want to make a number e type

00:10:26,990 --> 00:10:30,440
thing it's gonna be a function because

00:10:28,820 --> 00:10:32,300
everything is a function and it's gonna

00:10:30,440 --> 00:10:35,480
be a function that takes in some other

00:10:32,300 --> 00:10:37,490
function f and then that's gonna return

00:10:35,480 --> 00:10:39,890
a function because everything is

00:10:37,490 --> 00:10:44,930
functions which is going to take in some

00:10:39,890 --> 00:10:48,920
arbitrary input X and then do something

00:10:44,930 --> 00:10:50,330
with it I don't know what what we can do

00:10:48,920 --> 00:10:53,600
so all numbers are going to kind of have

00:10:50,330 --> 00:10:54,770
this this structure this shape of taking

00:10:53,600 --> 00:10:56,630
in a function and then that's gonna

00:10:54,770 --> 00:10:58,430
return a function that takes in some

00:10:56,630 --> 00:11:00,470
input and applies the function a certain

00:10:58,430 --> 00:11:03,770
number of times so like if I wanted to

00:11:00,470 --> 00:11:05,900
count 1 what I would do is apply F once

00:11:03,770 --> 00:11:10,220
so call it once on whatever that input

00:11:05,900 --> 00:11:13,250
is X ok and if I wanted to count 2 I

00:11:10,220 --> 00:11:16,460
would apply F twice call it twice on

00:11:13,250 --> 00:11:17,800
that function any guesses what 3 is

00:11:16,460 --> 00:11:24,879
gonna look like

00:11:17,800 --> 00:11:31,629
help me out F of F of F of x3 F school

00:11:24,879 --> 00:11:35,829
and zero so if I want to apply F zero

00:11:31,629 --> 00:11:39,730
times then I can just return X boom okay

00:11:35,829 --> 00:11:43,269
oops so now these personally I don't

00:11:39,730 --> 00:11:46,059
think look that much like numbers do you

00:11:43,269 --> 00:11:48,309
think they look like numbers yeah I did

00:11:46,059 --> 00:11:49,989
not when I first saw this so I had to

00:11:48,309 --> 00:11:52,480
convince myself and I'm gonna try to

00:11:49,989 --> 00:11:54,220
convince you to so how do we know these

00:11:52,480 --> 00:11:56,499
are numbers well let's cheat a little

00:11:54,220 --> 00:12:00,639
bit let's make a function that converts

00:11:56,499 --> 00:12:03,819
these lambda numbers into JavaScript

00:12:00,639 --> 00:12:06,069
numbers by taking a creating a function

00:12:03,819 --> 00:12:10,360
called two number that takes in some

00:12:06,069 --> 00:12:12,759
number N and then applies n to a

00:12:10,360 --> 00:12:14,499
function f which here is just gonna take

00:12:12,759 --> 00:12:17,350
in some whole number and add one to it

00:12:14,499 --> 00:12:18,970
and that's gonna give us a function that

00:12:17,350 --> 00:12:22,389
then we can apply to some input and if

00:12:18,970 --> 00:12:25,809
we apply it to zero then if we take this

00:12:22,389 --> 00:12:27,879
function f here and apply it once we're

00:12:25,809 --> 00:12:29,499
gonna add one to zero and get one and if

00:12:27,879 --> 00:12:30,850
we play it twice we get two if we buy

00:12:29,499 --> 00:12:34,720
zero times we're just left with zero

00:12:30,850 --> 00:12:36,069
everybody on board okay so if this is

00:12:34,720 --> 00:12:37,749
our little cheetah it's cheating because

00:12:36,069 --> 00:12:39,879
we we shouldn't have access to these

00:12:37,749 --> 00:12:42,069
actual JavaScript numbers but it's just

00:12:39,879 --> 00:12:44,199
cheating for sanity okay so I should be

00:12:42,069 --> 00:12:49,509
able to run this on one of my numbers

00:12:44,199 --> 00:12:51,970
like two let's say and get two and what

00:12:49,509 --> 00:12:54,490
if I try it on three oops well what

00:12:51,970 --> 00:12:59,290
happens if I spell it right I get three

00:12:54,490 --> 00:13:06,610
and if I try it on 0 I get 0 oh my god

00:12:59,290 --> 00:13:08,230
y'all we just made numbers cool okay so

00:13:06,610 --> 00:13:10,480
we have some numbers and actually

00:13:08,230 --> 00:13:12,639
there's a fancy google-able term for

00:13:10,480 --> 00:13:15,399
these called church numerals member my

00:13:12,639 --> 00:13:19,239
bro Alonzo yeah so these are named after

00:13:15,399 --> 00:13:21,429
him representing numbers this way Church

00:13:19,239 --> 00:13:22,929
numerals have fun googling it it will

00:13:21,429 --> 00:13:23,879
lead you down a very deep rabbit hole

00:13:22,929 --> 00:13:26,829
it'll be awesome

00:13:23,879 --> 00:13:29,040
ok so now that we've got some numbers

00:13:26,829 --> 00:13:31,220
what else can we do how about some

00:13:29,040 --> 00:13:33,560
arithmetic

00:13:31,220 --> 00:13:38,410
yes we're entering kindergarten awesome

00:13:33,560 --> 00:13:41,090
okay how can we add two numbers N and M

00:13:38,410 --> 00:13:42,920
when each of those numbers represents

00:13:41,090 --> 00:13:47,680
calling a function a certain number of

00:13:42,920 --> 00:13:50,180
times so let's say n is 2 and M is 3 n

00:13:47,680 --> 00:13:53,540
represents calling F twice and M

00:13:50,180 --> 00:13:56,000
represents calling F 3 times how can I

00:13:53,540 --> 00:14:02,240
add those two together think on it

00:13:56,000 --> 00:14:03,230
I can't hear that that's cool we're

00:14:02,240 --> 00:14:06,050
gonna go we're gonna go through it

00:14:03,230 --> 00:14:08,360
together so what we're gonna do if n is

00:14:06,050 --> 00:14:13,250
2 and M is 3 and I want to get to 5 I'm

00:14:08,360 --> 00:14:17,360
going to call F any times 1 2 and then

00:14:13,250 --> 00:14:22,520
I'm gonna call it m more times 1 2 3

00:14:17,360 --> 00:14:25,700
together should give me 5 so let's make

00:14:22,520 --> 00:14:28,010
an ad function okay what is this

00:14:25,700 --> 00:14:30,020
function gonna take in well it needs two

00:14:28,010 --> 00:14:33,320
numbers to operate on but we only have a

00:14:30,020 --> 00:14:36,410
single input at a time so we're gonna

00:14:33,320 --> 00:14:40,090
take in a number n we're gonna turn a

00:14:36,410 --> 00:14:42,950
function that takes in a number M and

00:14:40,090 --> 00:14:45,520
returns what kind of thing kind of thing

00:14:42,950 --> 00:14:48,140
do I want this add function to return

00:14:45,520 --> 00:14:52,370
well yes a function but okay what kind

00:14:48,140 --> 00:14:54,460
of function like if we add two numbers

00:14:52,370 --> 00:14:57,080
together we expect to get out another

00:14:54,460 --> 00:14:59,570
number okay and what the number

00:14:57,080 --> 00:15:01,730
functions look like they take in a

00:14:59,570 --> 00:15:04,040
function and they take in some kind of

00:15:01,730 --> 00:15:05,600
input and that's the shape of number

00:15:04,040 --> 00:15:07,300
functions right so what we're doing here

00:15:05,600 --> 00:15:10,310
is returning a number of function thing

00:15:07,300 --> 00:15:13,160
okay cool so now we said first we need

00:15:10,310 --> 00:15:18,020
to call the function f n times we do

00:15:13,160 --> 00:15:20,810
that by applying n2f right and applying

00:15:18,020 --> 00:15:24,500
that to our input X so this calls F n

00:15:20,810 --> 00:15:28,820
times yes we're on board okay now I need

00:15:24,500 --> 00:15:31,100
to call F again M more times so what if

00:15:28,820 --> 00:15:36,770
I treat this whole thing as like that X

00:15:31,100 --> 00:15:42,230
input and I call that function f

00:15:36,770 --> 00:15:44,120
and more times huh I know you're all

00:15:42,230 --> 00:15:48,830
like yeah that's exactly what Edition

00:15:44,120 --> 00:15:51,020
looks like in my head yeah me too okay

00:15:48,830 --> 00:15:53,050
now I should now if this works which

00:15:51,020 --> 00:15:57,860
it's live coding I don't know we'll see

00:15:53,050 --> 00:16:00,920
if this works I should be able to create

00:15:57,860 --> 00:16:02,390
a number like four by applying add to

00:16:00,920 --> 00:16:05,230
one and three right

00:16:02,390 --> 00:16:09,399
oops and I should be able to then

00:16:05,230 --> 00:16:10,730
convert four to a number and get out

00:16:09,399 --> 00:16:17,330
four

00:16:10,730 --> 00:16:18,080
oh my god I worked Alonso everybody

00:16:17,330 --> 00:16:20,930
amazing

00:16:18,080 --> 00:16:22,550
alright now I could have rigged that you

00:16:20,930 --> 00:16:24,620
don't know what's happening here inside

00:16:22,550 --> 00:16:26,899
of my computer right so let's try

00:16:24,620 --> 00:16:31,220
something else let's try like adding two

00:16:26,899 --> 00:16:38,089
and three we get five oh my god what if

00:16:31,220 --> 00:16:39,529
I swap them oh hey we did it we added

00:16:38,089 --> 00:16:42,800
numbers together is that the most

00:16:39,529 --> 00:16:44,540
exciting thing ever or what yeah what

00:16:42,800 --> 00:16:47,899
about some more arithmetic how about

00:16:44,540 --> 00:16:52,730
multiplication so what if we want to

00:16:47,899 --> 00:16:57,709
multiply n an M so if n is 2 and M is 3

00:16:52,730 --> 00:17:03,020
I want to call F n times so 1 2 and

00:16:57,709 --> 00:17:05,839
that's kind of like one round of calling

00:17:03,020 --> 00:17:08,179
F n times then I want to call it again

00:17:05,839 --> 00:17:09,890
right 3 4 that's like two rounds of

00:17:08,179 --> 00:17:10,790
calling in then I want to call it again

00:17:09,890 --> 00:17:14,000
5 6

00:17:10,790 --> 00:17:17,689
that's three rounds so that's like 6

00:17:14,000 --> 00:17:21,290
being the composition of n is 2 and M is

00:17:17,689 --> 00:17:25,900
3 I'm calling and calling the function n

00:17:21,290 --> 00:17:25,900
times M times over

00:17:27,140 --> 00:17:30,260
all right we're gonna think about what

00:17:28,429 --> 00:17:31,880
this function should look like if I want

00:17:30,260 --> 00:17:33,620
to make a multiplication function what

00:17:31,880 --> 00:17:36,520
is this gonna look like let you think

00:17:33,620 --> 00:17:36,520
about it for a second

00:17:36,610 --> 00:17:43,280
all right so it's gonna have a pretty

00:17:41,059 --> 00:17:45,260
similar shape to the previous two add

00:17:43,280 --> 00:17:47,179
one right it's gonna take in one number

00:17:45,260 --> 00:17:48,950
and that's gonna turn a function that

00:17:47,179 --> 00:17:51,710
takes in another number and that whole

00:17:48,950 --> 00:17:53,179
thing is going to return a number so

00:17:51,710 --> 00:17:55,160
we're gonna need some more of these a

00:17:53,179 --> 00:17:58,220
little bit of boilerplate in the lambda

00:17:55,160 --> 00:18:00,230
calculus all right now we said we want

00:17:58,220 --> 00:18:03,500
to call first of all we need to call F n

00:18:00,230 --> 00:18:05,390
times which we do like this right now

00:18:03,500 --> 00:18:07,970
because everything is functions here the

00:18:05,390 --> 00:18:10,910
application of n to F that's just

00:18:07,970 --> 00:18:15,080
another function that calls F n times

00:18:10,910 --> 00:18:19,580
right so what if I treat that as my new

00:18:15,080 --> 00:18:22,309
F that I call em on so now I'm taking

00:18:19,580 --> 00:18:30,350
this function that calls F n times loops

00:18:22,309 --> 00:18:34,520
and calling it m times on my input it

00:18:30,350 --> 00:18:35,870
makes total sense right okay all right

00:18:34,520 --> 00:18:37,820
let's see what happens I don't know it

00:18:35,870 --> 00:18:39,350
might be wrong let's find out so if I

00:18:37,820 --> 00:18:41,570
did this right I should be able to

00:18:39,350 --> 00:18:47,720
multiply two numbers like four and three

00:18:41,570 --> 00:18:49,630
together and get oh my god okay wait

00:18:47,720 --> 00:18:53,720
does it work in the other direction I

00:18:49,630 --> 00:18:56,450
don't know no cool okay and and like am

00:18:53,720 --> 00:18:58,070
i rigging this no it even worked with

00:18:56,450 --> 00:19:02,330
different things that I typed in right

00:18:58,070 --> 00:19:05,179
in front of you oh my god y'all we just

00:19:02,330 --> 00:19:07,400
added and multiplied numbers that we

00:19:05,179 --> 00:19:10,790
created from scratch this is like the

00:19:07,400 --> 00:19:12,140
pie that we just baked it's amazing now

00:19:10,790 --> 00:19:14,900
we're not gonna subtract or divide

00:19:12,140 --> 00:19:18,140
because those are like way harder but

00:19:14,900 --> 00:19:19,429
they are doable but even so we should be

00:19:18,140 --> 00:19:21,679
proud of ourselves because even with

00:19:19,429 --> 00:19:23,510
these two little kindergarten functions

00:19:21,679 --> 00:19:26,360
of adding and well multiplying it might

00:19:23,510 --> 00:19:27,700
have been first grade anyway even with

00:19:26,360 --> 00:19:30,350
those we can do some pretty cool

00:19:27,700 --> 00:19:32,600
computation like we can think some real

00:19:30,350 --> 00:19:34,220
deep thoughts here like what's the

00:19:32,600 --> 00:19:38,140
answer to life the universe and

00:19:34,220 --> 00:19:38,140
everything well

00:19:38,790 --> 00:19:42,430
if I add four to one and then multiply

00:19:41,380 --> 00:19:44,380
that by two and then multiply that by

00:19:42,430 --> 00:19:54,970
four and then add two to that then I

00:19:44,380 --> 00:19:57,730
should get yeah okay cool so now we've

00:19:54,970 --> 00:20:00,730
we basically done all of computation no

00:19:57,730 --> 00:20:02,830
not quite but suffice it to say that we

00:20:00,730 --> 00:20:04,780
can do like all of the arithmetic that

00:20:02,830 --> 00:20:05,920
we want here and even solve some real

00:20:04,780 --> 00:20:10,450
deep problems

00:20:05,920 --> 00:20:12,100
all right so simple math is cool but I

00:20:10,450 --> 00:20:16,360
said that we can do all of computation

00:20:12,100 --> 00:20:18,250
with this thing what else do we need to

00:20:16,360 --> 00:20:20,650
write programs like we're programmers

00:20:18,250 --> 00:20:27,220
what else do we need numbers and math is

00:20:20,650 --> 00:20:29,770
not gonna cut it we also need hooks yeah

00:20:27,220 --> 00:20:32,980
eventually we could get two hooks but

00:20:29,770 --> 00:20:34,480
not in the next ten minutes so what else

00:20:32,980 --> 00:20:39,100
do you need to write like a basic

00:20:34,480 --> 00:20:42,360
program it's exactly it's almost like I

00:20:39,100 --> 00:20:44,860
planted them in the audience we need

00:20:42,360 --> 00:20:47,590
conditionals right we need control flow

00:20:44,860 --> 00:20:49,540
and in order for conditionals to work we

00:20:47,590 --> 00:20:52,450
need some kind of boolean values we need

00:20:49,540 --> 00:20:53,800
truth values right and these all kind of

00:20:52,450 --> 00:20:55,600
go hand in hand

00:20:53,800 --> 00:20:57,670
boolean and these conditional this

00:20:55,600 --> 00:21:00,970
control flow of ifs right so like

00:20:57,670 --> 00:21:02,800
thinking about ternary like if syntax

00:21:00,970 --> 00:21:06,550
that were used to we have some boolean

00:21:02,800 --> 00:21:09,220
and we evaluate it and if it's true then

00:21:06,550 --> 00:21:11,200
we want to do some kind of then clause

00:21:09,220 --> 00:21:13,870
that we're gonna look into whatever and

00:21:11,200 --> 00:21:16,090
if it's not true then we're gonna skip

00:21:13,870 --> 00:21:19,300
right to some kind of else else clause

00:21:16,090 --> 00:21:22,240
yeah so what we're gonna do is we're

00:21:19,300 --> 00:21:25,540
gonna define both the syntax of if

00:21:22,240 --> 00:21:28,330
statements and boolean values all

00:21:25,540 --> 00:21:34,530
together in a way that this whole thing

00:21:28,330 --> 00:21:34,530
works out and is possible okay so

00:21:37,200 --> 00:21:42,780
I want to have an if-then-else statement

00:21:39,960 --> 00:21:44,540
or like syntax but everything is

00:21:42,780 --> 00:21:47,310
functions so it's gonna be a function

00:21:44,540 --> 00:21:48,840
it's gonna take in three things right we

00:21:47,310 --> 00:21:50,700
basically have three components here

00:21:48,840 --> 00:21:53,120
we're gonna have some kind of

00:21:50,700 --> 00:21:56,780
conditional some kind of boolean and

00:21:53,120 --> 00:21:59,220
we're gonna have some kind of Venn thing

00:21:56,780 --> 00:22:02,280
and we're gonna have some kind of else

00:21:59,220 --> 00:22:03,870
thing but else is a protected order or a

00:22:02,280 --> 00:22:10,310
special word in JavaScript so I'm just

00:22:03,870 --> 00:22:12,960
gonna rename these to the nulls okay and

00:22:10,310 --> 00:22:14,940
then we're gonna do something I don't

00:22:12,960 --> 00:22:17,550
know what all right let's put a pin in

00:22:14,940 --> 00:22:21,300
that for a minute and think about these

00:22:17,550 --> 00:22:24,150
boolean now what do we want boolean x'

00:22:21,300 --> 00:22:26,550
to do well we want them to choose the

00:22:24,150 --> 00:22:29,580
right branch of our conditional here

00:22:26,550 --> 00:22:31,380
right so if I have a true in my boolean

00:22:29,580 --> 00:22:33,780
spot here I wanted to hit this vend

00:22:31,380 --> 00:22:35,490
thing and if I have a false in my

00:22:33,780 --> 00:22:37,340
boolean spot I want to hit oh gosh I

00:22:35,490 --> 00:22:39,990
want to hit Oh No

00:22:37,340 --> 00:22:43,380
okay I want to hit the else thing if I

00:22:39,990 --> 00:22:45,690
have a false right so what if and this

00:22:43,380 --> 00:22:46,230
is gonna sound weird but what if a

00:22:45,690 --> 00:22:49,350
boolean

00:22:46,230 --> 00:22:54,060
we're just something that takes of N and

00:22:49,350 --> 00:22:56,970
an else and picks one of them so if it's

00:22:54,060 --> 00:23:01,770
true I want it to pick the first one the

00:22:56,970 --> 00:23:05,400
then exactly and if it's false I want it

00:23:01,770 --> 00:23:08,370
to pick the else so we're just we're

00:23:05,400 --> 00:23:09,780
defining boolean as like pickers we'd

00:23:08,370 --> 00:23:12,090
give them two things and they pick one

00:23:09,780 --> 00:23:15,660
of them and which one depends on just

00:23:12,090 --> 00:23:19,440
we're defining truth values that way so

00:23:15,660 --> 00:23:22,080
then in my if then else I've got a

00:23:19,440 --> 00:23:27,090
boolean I've got a venn and an else what

00:23:22,080 --> 00:23:31,170
if I just apply the boolean to the then

00:23:27,090 --> 00:23:36,120
and the else and let it choose which one

00:23:31,170 --> 00:23:38,520
it wants based on its truth value okay

00:23:36,120 --> 00:23:41,340
let's see if this works I'm pretty tired

00:23:38,520 --> 00:23:43,140
so am I not I don't know all right so

00:23:41,340 --> 00:23:44,880
I'm just we're gonna we're gonna see if

00:23:43,140 --> 00:23:47,940
this this could work so as I said I'm

00:23:44,880 --> 00:23:49,980
pretty tired so if I had if I had a

00:23:47,940 --> 00:23:52,440
value tired I would set it to true right

00:23:49,980 --> 00:23:54,720
now and the number of coffees that i'm

00:23:52,440 --> 00:23:59,130
gonna consume today depends on my

00:23:54,720 --> 00:24:00,419
tiredness yes so if I'm tired then I'm

00:23:59,130 --> 00:24:02,970
gonna have three coffees I've already

00:24:00,419 --> 00:24:05,010
had one got two more to go if I'm if I

00:24:02,970 --> 00:24:06,840
somehow through this talk you get so

00:24:05,010 --> 00:24:08,130
excited about the lambda calculus that

00:24:06,840 --> 00:24:11,130
I'm no longer tired then I'm just gonna

00:24:08,130 --> 00:24:12,870
stick with my one coffee okay

00:24:11,130 --> 00:24:14,340
so this is a little program I've written

00:24:12,870 --> 00:24:16,620
to tell me how many coffees I'm supposed

00:24:14,340 --> 00:24:21,690
to drink today and they should tell me

00:24:16,620 --> 00:24:23,970
oh my god oh my god a number came out so

00:24:21,690 --> 00:24:26,280
I thought number was three which is what

00:24:23,970 --> 00:24:27,990
I would expect if I am tired now I am

00:24:26,280 --> 00:24:29,910
getting pretty jazzed about the lambda

00:24:27,990 --> 00:24:31,710
calculus right now so I'm feeling a

00:24:29,910 --> 00:24:36,660
little less tired let's see if this

00:24:31,710 --> 00:24:41,130
program still works y'all

00:24:36,660 --> 00:24:43,410
we just got control flow from arrows I

00:24:41,130 --> 00:24:46,740
don't just mean just me that thinks

00:24:43,410 --> 00:24:53,460
that's cool Wow tough crowd

00:24:46,740 --> 00:24:55,770
tough crowd yay okay how about some

00:24:53,460 --> 00:24:58,309
logic now that we have boolean so we can

00:24:55,770 --> 00:25:03,000
like make operators that mess with them

00:24:58,309 --> 00:25:04,679
so how about we we just took to keep

00:25:03,000 --> 00:25:06,450
ourselves saying we cheat a little bit

00:25:04,679 --> 00:25:09,179
again and we just create another

00:25:06,450 --> 00:25:11,720
converting function to boolean which is

00:25:09,179 --> 00:25:14,640
going to take a limb de a boolean and

00:25:11,720 --> 00:25:16,860
apply it to JavaScript true and then

00:25:14,640 --> 00:25:19,620
JavaScript's false as the then and the

00:25:16,860 --> 00:25:21,030
else and give us one of them so that we

00:25:19,620 --> 00:25:22,410
can just test and we can make sure that

00:25:21,030 --> 00:25:25,230
we're getting the right truth value we

00:25:22,410 --> 00:25:26,940
expect out on board sound okay all right

00:25:25,230 --> 00:25:29,580
so I should be able to convert follows

00:25:26,940 --> 00:25:32,330
to boolean and get JavaScript false and

00:25:29,580 --> 00:25:36,690
true should give me JavaScript true cool

00:25:32,330 --> 00:25:39,350
okay now how about a logical operator

00:25:36,690 --> 00:25:39,350
how about not

00:25:41,460 --> 00:25:46,380
so not is gonna be an operator that

00:25:44,730 --> 00:25:50,700
operates on boolean right so we want it

00:25:46,380 --> 00:25:52,410
to take in a boolean and then we wanted

00:25:50,700 --> 00:25:54,360
to return a boolean so that's gonna need

00:25:52,410 --> 00:25:55,860
to be something that looks like this

00:25:54,360 --> 00:26:01,170
that takes our then and then an else

00:25:55,860 --> 00:26:02,970
yeah and so if I were gonna if I were

00:26:01,170 --> 00:26:06,570
just gonna call the apply this boolean

00:26:02,970 --> 00:26:09,000
to then an else then I would get I would

00:26:06,570 --> 00:26:11,490
get whatever the like the truth value of

00:26:09,000 --> 00:26:13,800
the original boolean was but I don't

00:26:11,490 --> 00:26:17,940
want that I want the opposite of that so

00:26:13,800 --> 00:26:23,310
let's get real Trixie and swap them

00:26:17,940 --> 00:26:25,050
we are hackers yeah we're just gonna

00:26:23,310 --> 00:26:29,100
move these around oops

00:26:25,050 --> 00:26:31,740
and hopefully I now have an operator

00:26:29,100 --> 00:26:34,770
that gives me the opposite of what I

00:26:31,740 --> 00:26:39,450
want of what I originally had so not

00:26:34,770 --> 00:26:44,390
true should give me false and not false

00:26:39,450 --> 00:26:46,620
true we are so tricky oh my gosh alright

00:26:44,390 --> 00:26:48,450
only have a couple more minutes so what

00:26:46,620 --> 00:26:52,500
about some more logic we're just gonna

00:26:48,450 --> 00:26:53,910
fly through these so what about or so or

00:26:52,500 --> 00:26:56,370
is gonna be an operator that operates on

00:26:53,910 --> 00:26:59,910
some boolean a and some other boolean B

00:26:56,370 --> 00:27:02,580
right now just for the sake of speed I'm

00:26:59,910 --> 00:27:04,500
just gonna show you um okay okay so

00:27:02,580 --> 00:27:06,840
let's see so a is a boolean so that

00:27:04,500 --> 00:27:10,070
means we we apply it to two things a

00:27:06,840 --> 00:27:12,570
first thing in a second thing now or is

00:27:10,070 --> 00:27:15,180
like if I have a and I already know that

00:27:12,570 --> 00:27:17,880
a is true I don't even need to look at B

00:27:15,180 --> 00:27:20,190
right because I already know that a is

00:27:17,880 --> 00:27:22,110
true so if a is true it's gonna pick the

00:27:20,190 --> 00:27:24,630
first thing and we want the or operator

00:27:22,110 --> 00:27:28,350
to return true so what if we just have

00:27:24,630 --> 00:27:29,760
it the first thing B a so that if a is

00:27:28,350 --> 00:27:31,290
true it picks the first thing and that's

00:27:29,760 --> 00:27:34,560
itself and it's true because we just

00:27:31,290 --> 00:27:37,380
assume that so it returns true and then

00:27:34,560 --> 00:27:40,350
if a is false then this is gonna pick

00:27:37,380 --> 00:27:42,090
the second thing here and then the value

00:27:40,350 --> 00:27:46,650
of the whole or is going to depend on

00:27:42,090 --> 00:27:49,320
the value of B so what if we just have

00:27:46,650 --> 00:27:52,080
it return whatever the truth value of B

00:27:49,320 --> 00:27:53,580
is because if B is false then this is

00:27:52,080 --> 00:27:54,490
going to evaluate to false and if it's

00:27:53,580 --> 00:27:59,440
true then cool

00:27:54,490 --> 00:28:01,090
get true alright so if that worked then

00:27:59,440 --> 00:28:05,320
I should be able to do an or on false

00:28:01,090 --> 00:28:07,929
and true and get true okay what if I do

00:28:05,320 --> 00:28:10,090
true and true okay

00:28:07,929 --> 00:28:12,600
what if I drew from true and false and

00:28:10,090 --> 00:28:16,690
the only time I should get false is

00:28:12,600 --> 00:28:21,179
truth tables are hard yes we did a truth

00:28:16,690 --> 00:28:21,179
table y'all it's pretty exciting

00:28:24,420 --> 00:28:34,000
now how about and any guesses so Andy's

00:28:31,120 --> 00:28:35,740
gonna work in a similar way so if these

00:28:34,000 --> 00:28:40,450
boolean are things that choose things

00:28:35,740 --> 00:28:42,010
all right if a is false let's say a is

00:28:40,450 --> 00:28:43,630
false we already know we don't even need

00:28:42,010 --> 00:28:45,760
to look at B the whole thing is gonna be

00:28:43,630 --> 00:28:47,230
false because a is false so if a is

00:28:45,760 --> 00:28:49,030
false it's gonna pick the second thing

00:28:47,230 --> 00:28:51,610
so what if we have it return a false

00:28:49,030 --> 00:28:52,809
value and we have a good idea of what a

00:28:51,610 --> 00:28:55,720
false value might be because we just

00:28:52,809 --> 00:28:58,090
assumed that a was a false value okay

00:28:55,720 --> 00:29:00,460
now if a is true then cool we can go on

00:28:58,090 --> 00:29:02,410
and look at B and then the whole thing

00:29:00,460 --> 00:29:06,040
is gonna evaluate to whatever the truth

00:29:02,410 --> 00:29:07,900
value of B is right so if a is true it's

00:29:06,040 --> 00:29:09,910
gonna pick whatever goes here so let's

00:29:07,900 --> 00:29:13,809
have it return whatever the truth value

00:29:09,910 --> 00:29:15,610
of B is yeah so now I should be able to

00:29:13,809 --> 00:29:19,450
do and on false and true and expect

00:29:15,610 --> 00:29:23,500
false cool false and false also false

00:29:19,450 --> 00:29:26,140
true and false also false and I should

00:29:23,500 --> 00:29:29,650
only get true when I have true and true

00:29:26,140 --> 00:29:31,660
we did more truth tables yes okay so now

00:29:29,650 --> 00:29:34,870
we've got logical operators now we can

00:29:31,660 --> 00:29:36,370
do all kinds of stuff right now look at

00:29:34,870 --> 00:29:40,090
all of this stuff that we have been able

00:29:36,370 --> 00:29:42,010
to make with just arrows we've got data

00:29:40,090 --> 00:29:44,200
we've got numbers and boolean values

00:29:42,010 --> 00:29:45,610
we've got our arithmetic okay maybe not

00:29:44,200 --> 00:29:47,650
subtraction and division and the tough

00:29:45,610 --> 00:29:49,870
arithmetic like that but I promise you

00:29:47,650 --> 00:29:53,559
can do it just not in this in 37 seconds

00:29:49,870 --> 00:29:56,380
Wow um we've got logic we've got control

00:29:53,559 --> 00:29:59,590
flow we've got like a lot of computers

00:29:56,380 --> 00:30:02,170
able that we're able to to mimic now and

00:29:59,590 --> 00:30:04,450
so what we've done representing data in

00:30:02,170 --> 00:30:06,590
this way representing it in terms of how

00:30:04,450 --> 00:30:09,140
it behaves when you give it certain in

00:30:06,590 --> 00:30:11,300
it's called church encoding so second

00:30:09,140 --> 00:30:13,310
google-able term you can Google Church

00:30:11,300 --> 00:30:14,630
encoding to fall down an even crazier

00:30:13,310 --> 00:30:19,520
rabbit hole than the one that we've

00:30:14,630 --> 00:30:21,200
already been in so far okay now there's

00:30:19,520 --> 00:30:22,790
a lot more that we could do but I'm like

00:30:21,200 --> 00:30:24,410
out of time so we're not gonna do it we

00:30:22,790 --> 00:30:25,850
could subtract we could divide we could

00:30:24,410 --> 00:30:27,260
have successor functions that give us

00:30:25,850 --> 00:30:29,300
the next higher number of predecessor

00:30:27,260 --> 00:30:31,250
functions we could do lot predicates

00:30:29,300 --> 00:30:33,500
slike is this thing zero is this thing

00:30:31,250 --> 00:30:35,870
even we could do equality operators

00:30:33,500 --> 00:30:38,030
inequalities we could even since we have

00:30:35,870 --> 00:30:40,580
numbers now if we think about characters

00:30:38,030 --> 00:30:43,100
as really just being like the codes

00:30:40,580 --> 00:30:46,160
assigned to those characters we could

00:30:43,100 --> 00:30:48,320
even represent strings as numbers and we

00:30:46,160 --> 00:30:50,120
could have we can actually create data

00:30:48,320 --> 00:30:52,730
structures so we could create pairs of

00:30:50,120 --> 00:30:54,260
things turn those into lists by nesting

00:30:52,730 --> 00:30:56,270
them and then we can even make list

00:30:54,260 --> 00:30:58,520
manipulations like Map Reduce and filter

00:30:56,270 --> 00:31:02,540
and then we're full-blown functional

00:30:58,520 --> 00:31:05,000
programming yo and from there we can get

00:31:02,540 --> 00:31:10,670
all of computation out of this single

00:31:05,000 --> 00:31:12,620
arrow that's so cool I think and even

00:31:10,670 --> 00:31:15,560
more mind-blowing you know what else we

00:31:12,620 --> 00:31:20,210
can do with an arrow we can do

00:31:15,560 --> 00:31:22,610
object-oriented programming what wha no

00:31:20,210 --> 00:31:24,560
seriously so check this out and I'm

00:31:22,610 --> 00:31:25,610
overtime so it was really quickly so

00:31:24,560 --> 00:31:27,380
functional programming an

00:31:25,610 --> 00:31:29,300
object-oriented programming are not like

00:31:27,380 --> 00:31:31,400
epic rivals as hacker news would have

00:31:29,300 --> 00:31:34,790
you believe they're actually kind of

00:31:31,400 --> 00:31:37,070
BFFs best friends forever if you think

00:31:34,790 --> 00:31:38,480
about iconic object-oriented programming

00:31:37,070 --> 00:31:41,750
languages you might think about small

00:31:38,480 --> 00:31:43,760
talk a language created by Alan Kay and

00:31:41,750 --> 00:31:46,790
an Allen case conception of

00:31:43,760 --> 00:31:49,180
object-oriented programming the idea of

00:31:46,790 --> 00:31:51,950
objects is that they are message

00:31:49,180 --> 00:31:53,750
receivers so they take in messages which

00:31:51,950 --> 00:31:55,160
messages consist of like a method name

00:31:53,750 --> 00:31:57,110
and some arguments you want to pass to

00:31:55,160 --> 00:31:58,490
the method and then the object give some

00:31:57,110 --> 00:32:01,190
kind of response which is up to the

00:31:58,490 --> 00:32:03,080
object so if that that's like the alan

00:32:01,190 --> 00:32:06,230
kay idea of object-oriented programming

00:32:03,080 --> 00:32:08,270
in lambda functions functions are just

00:32:06,230 --> 00:32:10,700
things that receive an input and return

00:32:08,270 --> 00:32:12,290
an output so that's not really that

00:32:10,700 --> 00:32:15,200
different because both of these are

00:32:12,290 --> 00:32:17,720
basically representing things in terms

00:32:15,200 --> 00:32:19,890
of their behavior hopefully you can read

00:32:17,720 --> 00:32:22,080
that so we're representing all

00:32:19,890 --> 00:32:25,230
data in terms of how it behaves what it

00:32:22,080 --> 00:32:27,030
does with the input it's given so

00:32:25,230 --> 00:32:29,640
actually what's pretty cool is that if

00:32:27,030 --> 00:32:34,110
you look at that language small talk if

00:32:29,640 --> 00:32:36,620
you look at how boolean are defined in

00:32:34,110 --> 00:32:39,090
small talk they are things that take a

00:32:36,620 --> 00:32:41,400
first thing and if true thing and a

00:32:39,090 --> 00:32:43,560
second thing an if false thing and pick

00:32:41,400 --> 00:32:45,540
one of them true picks the first one and

00:32:43,560 --> 00:32:48,660
false picks the second one does that

00:32:45,540 --> 00:32:50,190
sound familiar that's exactly how they

00:32:48,660 --> 00:32:52,020
look in the lambda calculus now we

00:32:50,190 --> 00:32:53,730
didn't do it with the fancy lambda

00:32:52,020 --> 00:32:55,710
syntax but this is the same thing as

00:32:53,730 --> 00:32:59,640
what we had before just replace X with

00:32:55,710 --> 00:33:02,250
if or X with an and why was else and you

00:32:59,640 --> 00:33:04,680
get the same definitions that we just

00:33:02,250 --> 00:33:08,280
had so this actually means that we can

00:33:04,680 --> 00:33:10,440
even create functional objects from the

00:33:08,280 --> 00:33:13,500
lambda calculus so I think that is

00:33:10,440 --> 00:33:16,320
pretty rad now I'm super out of time so

00:33:13,500 --> 00:33:18,810
this was just a preview a little taster

00:33:16,320 --> 00:33:20,760
of the lambda calculus go check it out

00:33:18,810 --> 00:33:22,290
on your own I think the only way to wrap

00:33:20,760 --> 00:33:24,510
your head around this is to play around

00:33:22,290 --> 00:33:27,420
with it the code from this talk and more

00:33:24,510 --> 00:33:28,920
examples is up on my github gist you can

00:33:27,420 --> 00:33:31,080
find the link in my Twitter I just

00:33:28,920 --> 00:33:32,370
tweeted it out and there's a bunch of

00:33:31,080 --> 00:33:33,630
other things here that you might want to

00:33:32,370 --> 00:33:34,860
read through about functional

00:33:33,630 --> 00:33:36,630
programming about that weird

00:33:34,860 --> 00:33:38,280
object-oriented function thing that I

00:33:36,630 --> 00:33:40,320
just mentioned so check out the

00:33:38,280 --> 00:33:43,710
references so okay that's it for me

00:33:40,320 --> 00:33:45,180
looks a mess thank you so much and I

00:33:43,710 --> 00:33:49,300
want to thank the organizers for having

00:33:45,180 --> 00:33:51,980
me back thank you

00:33:49,300 --> 00:33:55,029
[Music]

00:33:51,980 --> 00:33:55,029

YouTube URL: https://www.youtube.com/watch?v=qTHGmVrOGZo


