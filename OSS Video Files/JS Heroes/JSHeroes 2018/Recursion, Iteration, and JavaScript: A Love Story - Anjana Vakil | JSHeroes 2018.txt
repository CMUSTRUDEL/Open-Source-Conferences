Title: Recursion, Iteration, and JavaScript: A Love Story - Anjana Vakil | JSHeroes 2018
Publication date: 2018-05-05
Playlist: JSHeroes 2018
Description: 
	Recursion and iteration are two alternative paradigms for solving problems by breaking them down into smaller chunks; this talk is a deep dive into how these paradigms work, and how JS supports them both. There’s a fundamental tradeoff between the two: the stateful repetition of iteration is often more performant as it’s closer to the way our machines “think”, whereas many programmers find the self-referential abstraction of recursion easier to read & write. In JS prior to ES6, neither paradigm was especially easy to work with: iterative loops were laborious to read and write (not human-efficient), and recursion was limited by the fact that subsequent recursive calls to a function require additional frames added to the stack, potentially leading to stack overflow (not machine-efficient). Eventually, however, all three - recursion, iteration, and JS - were finally brought closer together. In this talk we’ll dive into the nature of the two paradigms, examine what an Iterable and a tail-recursive function are, and learn how Tail Call Optimization unites the two paradigms, allowing us to write code recursively and run it iteratively.
Captions: 
	00:00:01,840 --> 00:00:04,899
[Music]

00:00:14,330 --> 00:00:20,390
ah machi Alma I'm Donna and I learned

00:00:18,320 --> 00:00:22,460
just those couple of words of Romanian

00:00:20,390 --> 00:00:26,509
unfortunately that's like that's that's

00:00:22,460 --> 00:00:28,790
90% of my Romanian right there so I'm

00:00:26,509 --> 00:00:31,699
from the u.s. I live in San Francisco

00:00:28,790 --> 00:00:33,800
and I work for a company called map box

00:00:31,699 --> 00:00:37,550
I'm engineering learning and development

00:00:33,800 --> 00:00:40,220
lead their map box makes API is an SDKs

00:00:37,550 --> 00:00:43,730
for developers like you all to make

00:00:40,220 --> 00:00:45,590
really awesome location-based apps happy

00:00:43,730 --> 00:00:47,479
to chat about it after the talk but not

00:00:45,590 --> 00:00:50,360
really gonna get into what we do there

00:00:47,479 --> 00:00:52,190
today I also just really quickly want to

00:00:50,360 --> 00:00:54,220
give a shout out to some tech

00:00:52,190 --> 00:00:56,540
communities that I really love and

00:00:54,220 --> 00:00:58,070
without which I wouldn't be standing

00:00:56,540 --> 00:01:00,530
here talking to all of you beautiful

00:00:58,070 --> 00:01:03,710
people one is called the recurse Center

00:01:00,530 --> 00:01:06,290
it's a free self-directed programming

00:01:03,710 --> 00:01:08,210
retreat in New York City it's basically

00:01:06,290 --> 00:01:10,280
a place where you can go for six weeks

00:01:08,210 --> 00:01:12,470
or three months and just get better at

00:01:10,280 --> 00:01:14,270
programming whatever that means for you

00:01:12,470 --> 00:01:17,330
it's awesome

00:01:14,270 --> 00:01:19,310
check it out recurse comm another is a

00:01:17,330 --> 00:01:21,950
fabulous initiative called outreach e

00:01:19,310 --> 00:01:24,410
that aims to get more women and

00:01:21,950 --> 00:01:27,380
underrepresented minorities involved in

00:01:24,410 --> 00:01:29,780
open source by offering paid remote

00:01:27,380 --> 00:01:33,410
internships at open source organizations

00:01:29,780 --> 00:01:34,580
and projects it's really fantastic if

00:01:33,410 --> 00:01:35,960
you know anybody looking for an

00:01:34,580 --> 00:01:37,580
internship or if you're looking for an

00:01:35,960 --> 00:01:39,110
internship yourself and you're a member

00:01:37,580 --> 00:01:42,500
of an underrepresented group in tech

00:01:39,110 --> 00:01:44,330
check out outreach org they work with a

00:01:42,500 --> 00:01:47,030
lot of different organizations and a lot

00:01:44,330 --> 00:01:48,320
of different open-source projects one of

00:01:47,030 --> 00:01:50,480
the organizations they work closely with

00:01:48,320 --> 00:01:52,970
is Mozilla I was lucky enough to intern

00:01:50,480 --> 00:01:54,560
with Mozilla a couple of years ago and I

00:01:52,970 --> 00:01:55,850
still keep in touch with the Mozilla

00:01:54,560 --> 00:01:57,950
community through a group called the

00:01:55,850 --> 00:02:00,979
tech speakers Maz tech speakers shout

00:01:57,950 --> 00:02:03,260
out to tech speakers who are here so you

00:02:00,979 --> 00:02:06,440
can find us often you'll see us in those

00:02:03,260 --> 00:02:08,959
those blue and yellow heart logos around

00:02:06,440 --> 00:02:10,729
at conferences around the world so yeah

00:02:08,959 --> 00:02:12,830
feel free to say hi and I'm happy to

00:02:10,729 --> 00:02:16,610
chat about any of these things if you're

00:02:12,830 --> 00:02:18,110
curious come find me after the talk so

00:02:16,610 --> 00:02:20,989
another important thing to know about me

00:02:18,110 --> 00:02:22,610
is I wasn't always a programmer in

00:02:20,989 --> 00:02:23,810
university I didn't study computers I

00:02:22,610 --> 00:02:25,490
didn't get into it until later in life

00:02:23,810 --> 00:02:27,090
and at university I studied philosophy

00:02:25,490 --> 00:02:29,040
and

00:02:27,090 --> 00:02:30,900
so this maybe is why when I started to

00:02:29,040 --> 00:02:33,959
learn about programming I really loved

00:02:30,900 --> 00:02:36,810
thinking about abstractions and kind of

00:02:33,959 --> 00:02:38,580
the mental models that we use to reason

00:02:36,810 --> 00:02:40,470
about code and think about how our

00:02:38,580 --> 00:02:43,019
programs work so I really love

00:02:40,470 --> 00:02:44,790
programming paradigms and if you want to

00:02:43,019 --> 00:02:46,440
nerd out with me on all the different

00:02:44,790 --> 00:02:48,690
paradigms and kind of what we can learn

00:02:46,440 --> 00:02:50,340
from from all of them check out a talk I

00:02:48,690 --> 00:02:52,709
have called programming across paradigms

00:02:50,340 --> 00:02:54,360
in this talk we're not going to get into

00:02:52,709 --> 00:02:56,340
like all of the different possibilities

00:02:54,360 --> 00:02:59,459
I want to talk about two paradigms in

00:02:56,340 --> 00:03:01,440
particular that are sort of star-crossed

00:02:59,459 --> 00:03:04,380
in the sense so they're almost like

00:03:01,440 --> 00:03:06,660
these these two completely different

00:03:04,380 --> 00:03:07,980
worlds that they represent and you might

00:03:06,660 --> 00:03:10,049
think that they could never come

00:03:07,980 --> 00:03:13,019
together so they're sort of like

00:03:10,049 --> 00:03:14,160
star-crossed lovers in that way and the

00:03:13,019 --> 00:03:17,549
paradigms I'm talking about our

00:03:14,160 --> 00:03:18,900
iteration and recursion now you might

00:03:17,549 --> 00:03:21,480
not think of these as programming

00:03:18,900 --> 00:03:22,890
paradigms they're not usually referred

00:03:21,480 --> 00:03:25,349
to as kind of major programming

00:03:22,890 --> 00:03:27,510
paradigms iteration is associated with

00:03:25,349 --> 00:03:29,190
the iterative programming parent sorry

00:03:27,510 --> 00:03:31,230
the imperative programming paradigm and

00:03:29,190 --> 00:03:33,420
recursion is associated with functional

00:03:31,230 --> 00:03:34,889
programming but they're sort of like sub

00:03:33,420 --> 00:03:38,130
paradigms of each of those because

00:03:34,889 --> 00:03:40,560
they're mental models that help us think

00:03:38,130 --> 00:03:44,970
and reason and understand about how we

00:03:40,560 --> 00:03:47,639
want to solve problems by executing the

00:03:44,970 --> 00:03:49,230
same piece of code multiple times and so

00:03:47,639 --> 00:03:50,930
they offer kind of different approaches

00:03:49,230 --> 00:03:54,000
to how we might do that

00:03:50,930 --> 00:03:56,340
so iteration as we said is sort of part

00:03:54,000 --> 00:03:58,829
of this imperative paradigm where we're

00:03:56,340 --> 00:04:00,870
telling the computer do this and then do

00:03:58,829 --> 00:04:04,400
that and so our programs are made up of

00:04:00,870 --> 00:04:06,450
commands kind of instructions and in

00:04:04,400 --> 00:04:08,760
iterative code we're going to be

00:04:06,450 --> 00:04:10,650
executing the same code the same chunk

00:04:08,760 --> 00:04:14,819
of code multiple times in repetitive

00:04:10,650 --> 00:04:16,709
loops using like for or while and as we

00:04:14,819 --> 00:04:18,720
go through those loops we maintain state

00:04:16,709 --> 00:04:21,030
between different runs through the loop

00:04:18,720 --> 00:04:23,700
we remember how variables are changing

00:04:21,030 --> 00:04:25,349
so maybe we have a counter that we're

00:04:23,700 --> 00:04:27,360
incrementing or maybe we have an array

00:04:25,349 --> 00:04:30,330
that we're pushing things on to and so

00:04:27,360 --> 00:04:32,760
it's a stateful paradigm and I'm a big

00:04:30,330 --> 00:04:34,710
fan of using kind of mental Association

00:04:32,760 --> 00:04:36,060
I like to kind of associate things in my

00:04:34,710 --> 00:04:38,219
head to help me remember them better and

00:04:36,060 --> 00:04:40,409
understand them better and I also love

00:04:38,219 --> 00:04:40,980
movies and so when I think of iteration

00:04:40,409 --> 00:04:42,870
I can

00:04:40,980 --> 00:04:46,560
help but think of a movie called

00:04:42,870 --> 00:04:48,510
Groundhog Day has anybody seen this yeah

00:04:46,560 --> 00:04:50,280
okay a few people so if you haven't seen

00:04:48,510 --> 00:04:52,020
this in Groundhog Day which came out in

00:04:50,280 --> 00:04:54,810
the 90s it's got Bill Murray

00:04:52,020 --> 00:04:56,670
awesome comedian if you ask me he's his

00:04:54,810 --> 00:04:58,770
character he's trapped in the same day

00:04:56,670 --> 00:05:01,020
he's like reliving the same day over and

00:04:58,770 --> 00:05:03,450
over every morning he wakes up and the

00:05:01,020 --> 00:05:04,860
same stuff happens throughout the day

00:05:03,450 --> 00:05:06,330
and he goes to sleep and then it all

00:05:04,860 --> 00:05:07,890
starts over again the next day so he's

00:05:06,330 --> 00:05:10,080
stuck in this kind of like infinite

00:05:07,890 --> 00:05:11,640
while loop but it's also stateful

00:05:10,080 --> 00:05:12,930
because he can also remember that he's

00:05:11,640 --> 00:05:14,400
been there before and he can learn

00:05:12,930 --> 00:05:16,170
things like you can take piano lessons

00:05:14,400 --> 00:05:18,330
and like get really good at piano even

00:05:16,170 --> 00:05:20,010
though he only has one day so I think

00:05:18,330 --> 00:05:23,310
Groundhog Day is a really great example

00:05:20,010 --> 00:05:28,290
of like how iteration works okay so

00:05:23,310 --> 00:05:29,730
that's iteration what about recursion so

00:05:28,290 --> 00:05:31,140
as I said recursion is associated with

00:05:29,730 --> 00:05:33,510
the functional programming paradigm

00:05:31,140 --> 00:05:36,000
where instead of imperative commands we

00:05:33,510 --> 00:05:38,430
are thinking about programs in terms of

00:05:36,000 --> 00:05:42,180
functions that take inputs and return

00:05:38,430 --> 00:05:43,440
outputs and our programs are composed of

00:05:42,180 --> 00:05:45,000
multiple functions that we can put

00:05:43,440 --> 00:05:45,510
together to do increasingly complex

00:05:45,000 --> 00:05:49,050
things

00:05:45,510 --> 00:05:50,400
so in recruitin when we when we take the

00:05:49,050 --> 00:05:52,110
same chunk of code and run it multiple

00:05:50,400 --> 00:05:54,810
times instead of looping like an

00:05:52,110 --> 00:05:56,700
iteration we're making references to

00:05:54,810 --> 00:05:59,190
ourself so maybe we have a function that

00:05:56,700 --> 00:06:01,260
calls itself and then that function can

00:05:59,190 --> 00:06:03,240
call itself again and so on and so forth

00:06:01,260 --> 00:06:05,250
so we're kind of like building this kind

00:06:03,240 --> 00:06:09,060
of Russian doll scenario or nesting

00:06:05,250 --> 00:06:11,520
calls to functions and instead of having

00:06:09,060 --> 00:06:13,260
this stateful sort of memory of values

00:06:11,520 --> 00:06:15,660
changing over time that we have in

00:06:13,260 --> 00:06:18,510
iteration we've got a more stateless

00:06:15,660 --> 00:06:19,980
approach so each function call doesn't

00:06:18,510 --> 00:06:21,690
really need to know anything about like

00:06:19,980 --> 00:06:23,430
how many times that function has been

00:06:21,690 --> 00:06:24,870
called before all it needs to know is

00:06:23,430 --> 00:06:27,300
what are my inputs and what do I need to

00:06:24,870 --> 00:06:29,460
do to return my output now there's also

00:06:27,300 --> 00:06:31,340
a movie that recursion reminds me of can

00:06:29,460 --> 00:06:34,860
anybody guess what it is

00:06:31,340 --> 00:06:36,690
yeah of course it's Inception right this

00:06:34,860 --> 00:06:38,880
is like the perfect example of how

00:06:36,690 --> 00:06:42,270
recursion works so has everybody seen

00:06:38,880 --> 00:06:45,420
Inception like half of people okay if

00:06:42,270 --> 00:06:48,690
you haven't basically Leonardo DiCaprio

00:06:45,420 --> 00:06:51,570
and his friends they they can go into

00:06:48,690 --> 00:06:53,190
dreams and then inside a dream they can

00:06:51,570 --> 00:06:54,449
like fall asleep again and go into

00:06:53,190 --> 00:06:55,919
another dream inside

00:06:54,449 --> 00:06:57,719
dream and then they can go even further

00:06:55,919 --> 00:06:59,879
and fall into a dream within a dream

00:06:57,719 --> 00:07:02,069
within a dream and so on and so forth

00:06:59,879 --> 00:07:03,770
and when they wake up they go up to the

00:07:02,069 --> 00:07:06,509
previous one and so on and so forth and

00:07:03,770 --> 00:07:08,249
yeah they also don't know right they

00:07:06,509 --> 00:07:10,439
don't remember whether they're awake or

00:07:08,249 --> 00:07:11,969
asleep or it's hard to tell so he has to

00:07:10,439 --> 00:07:13,379
carry around a little top that like

00:07:11,969 --> 00:07:15,150
somehow helps him understand whether

00:07:13,379 --> 00:07:16,740
he's dreaming or not anyway go watch the

00:07:15,150 --> 00:07:18,870
movie it's pretty good so his Groundhog

00:07:16,740 --> 00:07:20,039
Day very different but this is the point

00:07:18,870 --> 00:07:22,830
right these are two very different

00:07:20,039 --> 00:07:24,089
paradigms they they have something in

00:07:22,830 --> 00:07:27,389
common in the sense that they're both

00:07:24,089 --> 00:07:28,949
ways that we can execute code repeatedly

00:07:27,389 --> 00:07:30,389
and there are ways that we can solve

00:07:28,949 --> 00:07:33,330
bigger problems by breaking them down

00:07:30,389 --> 00:07:35,249
into smaller chunks but they're they're

00:07:33,330 --> 00:07:36,060
kind of often seen as being sort of in

00:07:35,249 --> 00:07:38,849
opposition

00:07:36,060 --> 00:07:41,219
there's this tension between them now

00:07:38,849 --> 00:07:43,110
they're both equally valid we might say

00:07:41,219 --> 00:07:46,499
that there are two paradigms alike in

00:07:43,110 --> 00:07:49,560
dignity they're they're both totally

00:07:46,499 --> 00:07:52,319
valid approaches for going about writing

00:07:49,560 --> 00:07:54,089
code now some people might prefer one or

00:07:52,319 --> 00:07:56,219
the other and often these arguments

00:07:54,089 --> 00:07:57,809
which if you go online and read forums

00:07:56,219 --> 00:08:00,300
and and hacker news and whatever like

00:07:57,809 --> 00:08:02,879
people argue about it infinitely it

00:08:00,300 --> 00:08:04,499
often comes down to questions of

00:08:02,879 --> 00:08:07,499
efficiency so let's talk about

00:08:04,499 --> 00:08:10,080
efficiency a lot of people like will say

00:08:07,499 --> 00:08:12,209
um well iterative code is better because

00:08:10,080 --> 00:08:14,580
it runs more efficiently it's more

00:08:12,209 --> 00:08:16,139
performant well okay but let's think

00:08:14,580 --> 00:08:18,810
about what we mean when we say

00:08:16,139 --> 00:08:21,360
efficiency um there's a there's a really

00:08:18,810 --> 00:08:23,520
great quote from a programmer named

00:08:21,360 --> 00:08:25,770
Jonathan Blow he's an indie game

00:08:23,520 --> 00:08:27,479
developer he made the game braid I don't

00:08:25,770 --> 00:08:29,759
know if anybody's played it anyway he

00:08:27,479 --> 00:08:31,889
he's got this talk that my current boss

00:08:29,759 --> 00:08:33,630
yuen-han pointed out to me that has this

00:08:31,889 --> 00:08:35,639
really nice he puts a really nice way of

00:08:33,630 --> 00:08:37,919
how we can think about efficiency when

00:08:35,639 --> 00:08:40,260
we talk about humans all of us write in

00:08:37,919 --> 00:08:41,880
code so he says you might optimized for

00:08:40,260 --> 00:08:44,159
speed in your programs you might

00:08:41,880 --> 00:08:45,779
optimize for space but there's a third

00:08:44,159 --> 00:08:48,420
thing you might want to optimize for and

00:08:45,779 --> 00:08:50,850
that's years of your life required per

00:08:48,420 --> 00:08:54,480
program implementation right we are

00:08:50,850 --> 00:08:55,860
humans our lives are not infinite and so

00:08:54,480 --> 00:08:57,810
he says this is more important than

00:08:55,860 --> 00:09:00,389
those other things or at least equally

00:08:57,810 --> 00:09:01,680
important and I think this I totally

00:09:00,389 --> 00:09:03,329
agree I think this is a great way of

00:09:01,680 --> 00:09:05,250
putting it I think when we talk about

00:09:03,329 --> 00:09:07,380
efficiency we need to really distinguish

00:09:05,250 --> 00:09:07,950
between machine efficiency so what's

00:09:07,380 --> 00:09:09,720
efficient for

00:09:07,950 --> 00:09:12,300
a computer when it runs our code in

00:09:09,720 --> 00:09:15,030
terms of its resources time space and

00:09:12,300 --> 00:09:16,560
what's efficient for humans us when we

00:09:15,030 --> 00:09:19,260
write the code or when we read it or

00:09:16,560 --> 00:09:20,820
when we try to maintain it and so when

00:09:19,260 --> 00:09:22,290
we talk about efficiency I think we

00:09:20,820 --> 00:09:25,230
really need to be clear about which one

00:09:22,290 --> 00:09:26,910
we have in mind and these two paradigms

00:09:25,230 --> 00:09:29,430
that I'm using the colors of the fonts

00:09:26,910 --> 00:09:31,290
to kind of echo this these two paradigms

00:09:29,430 --> 00:09:33,330
are often associated with one of these

00:09:31,290 --> 00:09:35,460
types of efficiency so iteration is

00:09:33,330 --> 00:09:37,770
often seen as more machine efficient and

00:09:35,460 --> 00:09:40,680
recursion a lot of people find more kind

00:09:37,770 --> 00:09:41,730
of elegant more intuitive it once you

00:09:40,680 --> 00:09:43,830
kind of wrap your head around how

00:09:41,730 --> 00:09:48,830
recursion works and so some people say

00:09:43,830 --> 00:09:51,120
it's more human efficient now the

00:09:48,830 --> 00:09:52,650
setting for all of this we're talking

00:09:51,120 --> 00:09:54,240
about these two paradigms in is of

00:09:52,650 --> 00:09:56,970
course JavaScript because we're here at

00:09:54,240 --> 00:09:58,410
a JavaScript conference and so it is in

00:09:56,970 --> 00:10:01,350
fair JavaScript where we lay our scene

00:09:58,410 --> 00:10:04,680
today of these two paradigms alike in

00:10:01,350 --> 00:10:06,210
dignity and yes for any English

00:10:04,680 --> 00:10:08,070
literature buffs in the audience these

00:10:06,210 --> 00:10:09,570
are the opening lines of William

00:10:08,070 --> 00:10:11,700
Shakespeare's Romeo and Juliet two

00:10:09,570 --> 00:10:14,250
households both alike in dignity in fair

00:10:11,700 --> 00:10:16,620
Verona where we lay our scene anyway so

00:10:14,250 --> 00:10:18,630
now I've quoted Shakespeare in a Tech

00:10:16,620 --> 00:10:20,370
Talk achievement unlocked and I've also

00:10:18,630 --> 00:10:22,320
made two Leonardo DiCaprio movie

00:10:20,370 --> 00:10:25,920
references in the first 10 minutes of a

00:10:22,320 --> 00:10:27,720
talk another achievement unlocked yes so

00:10:25,920 --> 00:10:29,940
but this is I thought this is sort of

00:10:27,720 --> 00:10:31,470
apt because we a lot of people and again

00:10:29,940 --> 00:10:33,360
on the internet have you see people

00:10:31,470 --> 00:10:35,310
arguing about this they sort of had this

00:10:33,360 --> 00:10:37,410
idea like there can be only one

00:10:35,310 --> 00:10:38,490
everybody's got their guns pointed at

00:10:37,410 --> 00:10:40,140
each other and everybody's got an

00:10:38,490 --> 00:10:42,390
opinion like no I will only write

00:10:40,140 --> 00:10:43,950
recursive code or like a recursive code

00:10:42,390 --> 00:10:46,200
is so inefficient I would never do that

00:10:43,950 --> 00:10:48,450
I don't think it has to be that way I

00:10:46,200 --> 00:10:51,590
think this story has a happy ending and

00:10:48,450 --> 00:10:53,700
I think that these two like sort of

00:10:51,590 --> 00:10:55,380
these paradigms that we think of as

00:10:53,700 --> 00:10:57,210
being opposed to one another they can

00:10:55,380 --> 00:10:59,880
actually really complement each other

00:10:57,210 --> 00:11:02,220
and we can take notions from one to make

00:10:59,880 --> 00:11:05,220
the other stronger and better and easier

00:11:02,220 --> 00:11:07,740
to work in and so that's kind of a happy

00:11:05,220 --> 00:11:09,960
ending where we get two paradigms that

00:11:07,740 --> 00:11:12,000
reinforce and complement each other and

00:11:09,960 --> 00:11:14,610
we as programmers get more options of

00:11:12,000 --> 00:11:16,380
ways that it's easy to write code and of

00:11:14,610 --> 00:11:18,120
course it's JavaScript in this case

00:11:16,380 --> 00:11:20,730
that's bringing these two together it's

00:11:18,120 --> 00:11:21,420
playing matchmaker between them because

00:11:20,730 --> 00:11:23,580
we

00:11:21,420 --> 00:11:25,890
got some really cool new features in the

00:11:23,580 --> 00:11:27,240
last few years and JavaScript that make

00:11:25,890 --> 00:11:29,490
it easier to work in both of these

00:11:27,240 --> 00:11:32,250
paradigms so that's what we're gonna be

00:11:29,490 --> 00:11:34,590
talking about today okay that was all

00:11:32,250 --> 00:11:37,410
prologue really long prologue let's dive

00:11:34,590 --> 00:11:39,570
in so act 1 let's talk about iteration

00:11:37,410 --> 00:11:41,430
we said it's machine efficient let's see

00:11:39,570 --> 00:11:42,620
how we can make it more human efficient

00:11:41,430 --> 00:11:45,450
more intuitive

00:11:42,620 --> 00:11:48,150
alright we're programmers so we love

00:11:45,450 --> 00:11:49,530
trees right all programmers just love

00:11:48,150 --> 00:11:51,480
trees it's our favorite data structure

00:11:49,530 --> 00:11:53,820
here I've just got a really really

00:11:51,480 --> 00:11:55,500
simple tree I'm gonna have little nodes

00:11:53,820 --> 00:11:57,870
that are represented by objects which

00:11:55,500 --> 00:11:59,580
have a value and then have a left child

00:11:57,870 --> 00:12:01,830
and a right child which might be empty

00:11:59,580 --> 00:12:03,960
so it might be a leaf node or it might

00:12:01,830 --> 00:12:05,640
just have one and I've just got a little

00:12:03,960 --> 00:12:07,470
helper function make tree here which is

00:12:05,640 --> 00:12:09,330
gonna take in my simple tree node node

00:12:07,470 --> 00:12:12,060
type and give me a tree that looks like

00:12:09,330 --> 00:12:14,400
this diagram on the right so I just got

00:12:12,060 --> 00:12:15,870
a few few integers in my tree it's not

00:12:14,400 --> 00:12:18,990
the most exciting tree in the world it's

00:12:15,870 --> 00:12:21,000
a simple tree all right now let's say I

00:12:18,990 --> 00:12:23,310
want to traverse this tree and get all

00:12:21,000 --> 00:12:25,850
of the values that are in this tree in

00:12:23,310 --> 00:12:27,750
order in like a in a depth-first

00:12:25,850 --> 00:12:29,100
left-to-right order so that they come

00:12:27,750 --> 00:12:30,990
out in numerical order the way I've

00:12:29,100 --> 00:12:35,010
arranged them here if you were gonna

00:12:30,990 --> 00:12:36,990
explain to me human-to-human how one

00:12:35,010 --> 00:12:38,640
could go about traversing a tree you

00:12:36,990 --> 00:12:40,920
might say something like this okay you

00:12:38,640 --> 00:12:44,820
start at the at the root the top in this

00:12:40,920 --> 00:12:49,830
case tell me the value of that and then

00:12:44,820 --> 00:12:52,170
if it has children on either side treat

00:12:49,830 --> 00:12:54,060
each of those like its own tree and then

00:12:52,170 --> 00:12:56,700
traverse those and so for that you're

00:12:54,060 --> 00:12:58,260
gonna take the value and then look at

00:12:56,700 --> 00:12:59,700
its children and look at those sub trees

00:12:58,260 --> 00:13:00,900
and look at the sub trees of their sub

00:12:59,700 --> 00:13:03,720
trees and the grandchildren the

00:13:00,900 --> 00:13:05,370
great-grandchildren etc so if you were

00:13:03,720 --> 00:13:08,850
to explain it to me that way you kind of

00:13:05,370 --> 00:13:10,650
be talking recursively right so one way

00:13:08,850 --> 00:13:12,540
we might write a function to recurse a

00:13:10,650 --> 00:13:15,210
tree like this is just with a really

00:13:12,540 --> 00:13:16,470
simple recursive function so here I've

00:13:15,210 --> 00:13:19,050
got a function called recursive traverse

00:13:16,470 --> 00:13:21,720
and like any recursive function it's got

00:13:19,050 --> 00:13:23,760
two cases it's got a base case which is

00:13:21,720 --> 00:13:25,590
what stops us from like falling into

00:13:23,760 --> 00:13:27,360
infinite dream States and like being

00:13:25,590 --> 00:13:29,190
Leonardo DiCaprio like stuck in the

00:13:27,360 --> 00:13:30,870
dream forever just falling deeper and

00:13:29,190 --> 00:13:32,910
deeper we don't want that to happen so

00:13:30,870 --> 00:13:34,649
we need a base case so that eventually

00:13:32,910 --> 00:13:37,980
something stops and we

00:13:34,649 --> 00:13:39,509
in this case when we get in a value

00:13:37,980 --> 00:13:41,100
we're gonna make sure that it's not

00:13:39,509 --> 00:13:43,170
undefined that it's not like an empty

00:13:41,100 --> 00:13:45,180
node that we're looking at and if it is

00:13:43,170 --> 00:13:46,980
empty then we're just gonna return so

00:13:45,180 --> 00:13:50,399
that's our bottom to the dream state and

00:13:46,980 --> 00:13:52,410
then it has a recursive case so in this

00:13:50,399 --> 00:13:54,899
case if there is actually a node here

00:13:52,410 --> 00:13:56,999
we're gonna log its value and then we're

00:13:54,899 --> 00:13:58,949
gonna recursively traverse its left

00:13:56,999 --> 00:14:00,569
child and it's right child which once

00:13:58,949 --> 00:14:02,160
again might be empty in which case we'll

00:14:00,569 --> 00:14:04,350
hit the base case on those recursive

00:14:02,160 --> 00:14:06,779
calls and pop back out but if they're

00:14:04,350 --> 00:14:08,819
not empty we'll continue going as deep

00:14:06,779 --> 00:14:11,790
as we need to to get all the values out

00:14:08,819 --> 00:14:13,709
of the tree so if we run this code it

00:14:11,790 --> 00:14:16,290
works we get all our values out yay

00:14:13,709 --> 00:14:17,519
wonderful great and I don't know about

00:14:16,290 --> 00:14:18,779
you but I find this code pretty

00:14:17,519 --> 00:14:20,369
intuitive

00:14:18,779 --> 00:14:22,009
pretty easy to read and write because

00:14:20,369 --> 00:14:24,689
it's kind of how we think about

00:14:22,009 --> 00:14:27,480
descending a tree in terms of its sub

00:14:24,689 --> 00:14:30,029
trees what about an iterative approach

00:14:27,480 --> 00:14:32,269
to iterating over a simple tree like

00:14:30,029 --> 00:14:34,290
this so here's one way we could do it

00:14:32,269 --> 00:14:36,660
I've got an iterative a traverse

00:14:34,290 --> 00:14:38,399
function here we're basically keeping

00:14:36,660 --> 00:14:40,290
track of like the nodes that we need to

00:14:38,399 --> 00:14:43,050
visit in a little to-do list a little

00:14:40,290 --> 00:14:45,149
to-do array and as long as there's stuff

00:14:43,050 --> 00:14:47,160
that we still need to visit I'm going to

00:14:45,149 --> 00:14:50,009
take the thing off of the beginning of

00:14:47,160 --> 00:14:51,600
that array make sure that it's not empty

00:14:50,009 --> 00:14:54,089
that it's not undefined and if it is a

00:14:51,600 --> 00:14:57,120
tree if it's if it's a node then I'm

00:14:54,089 --> 00:14:59,009
going to log its value and then take its

00:14:57,120 --> 00:15:00,600
left child and put it onto the front of

00:14:59,009 --> 00:15:01,769
the right of the array and take its

00:15:00,600 --> 00:15:04,019
right child and put it onto the back of

00:15:01,769 --> 00:15:07,889
the array and then keep going until I

00:15:04,019 --> 00:15:10,170
run out of nodes to visit so this code

00:15:07,889 --> 00:15:12,720
if I run it it runs is exactly the same

00:15:10,170 --> 00:15:16,410
but I don't know about you but I find

00:15:12,720 --> 00:15:17,850
this much less intuitive to to write in

00:15:16,410 --> 00:15:19,829
the first case and also just to read

00:15:17,850 --> 00:15:21,779
it's like all right we need an arrest to

00:15:19,829 --> 00:15:23,429
do's and we're like putting things on

00:15:21,779 --> 00:15:24,990
both ends like which direction do they

00:15:23,429 --> 00:15:26,759
need to go and we're popping things off

00:15:24,990 --> 00:15:28,559
and it just doesn't like it works but

00:15:26,759 --> 00:15:29,850
it's maybe how a computer might think

00:15:28,559 --> 00:15:32,160
about this code but it's not how I think

00:15:29,850 --> 00:15:34,639
about it how I think about the tree and

00:15:32,160 --> 00:15:37,019
how we'd want to go through it so

00:15:34,639 --> 00:15:39,509
wouldn't it be great wouldn't we just

00:15:37,019 --> 00:15:41,339
love to be able to just say like for

00:15:39,509 --> 00:15:44,069
each thing in the tree tell me what the

00:15:41,339 --> 00:15:47,040
thing is and just loop over it really

00:15:44,069 --> 00:15:48,750
simply in as high-level and iterative

00:15:47,040 --> 00:15:53,070
abstraction as

00:15:48,750 --> 00:15:54,450
well thanks to JavaScript and notably

00:15:53,070 --> 00:15:57,420
the some of the features that we got in

00:15:54,450 --> 00:15:59,460
he has six a couple years ago we can yay

00:15:57,420 --> 00:16:01,050
so we got these new iteration protocols

00:15:59,460 --> 00:16:02,370
well they're not so new anymore

00:16:01,050 --> 00:16:05,340
but they're still pretty cool because

00:16:02,370 --> 00:16:07,290
before before we had those this was kind

00:16:05,340 --> 00:16:11,370
of clunky and awkward to work with but

00:16:07,290 --> 00:16:14,190
now thanks to the iterable protocol so

00:16:11,370 --> 00:16:16,320
we can make objects iterable by giving

00:16:14,190 --> 00:16:21,750
them something that is on the symbol

00:16:16,320 --> 00:16:23,460
iterator key and returns an iterator we

00:16:21,750 --> 00:16:25,680
then of course have the notion of

00:16:23,460 --> 00:16:28,710
iterators which are objects that have a

00:16:25,680 --> 00:16:30,210
next method which returns objects that

00:16:28,710 --> 00:16:32,310
tell us whether or not there's something

00:16:30,210 --> 00:16:34,200
else coming there's like whether or not

00:16:32,310 --> 00:16:35,460
the series is done so we've got these

00:16:34,200 --> 00:16:38,670
integrators that return a series of

00:16:35,460 --> 00:16:40,890
objects infinite or finite and we've got

00:16:38,670 --> 00:16:43,950
generators to make it really easy to

00:16:40,890 --> 00:16:45,420
write iterators because generators are

00:16:43,950 --> 00:16:47,280
iterators and they're also adorable

00:16:45,420 --> 00:16:49,260
so bonus so they work really nicely with

00:16:47,280 --> 00:16:51,090
iteration we've got this function star

00:16:49,260 --> 00:16:54,270
keyword to make generator functions

00:16:51,090 --> 00:16:57,390
we've got yield to output values from

00:16:54,270 --> 00:16:59,490
our generator and we can we can do that

00:16:57,390 --> 00:17:01,350
as much as we need to and then we got

00:16:59,490 --> 00:17:05,100
these handy-dandy for of loops to

00:17:01,350 --> 00:17:07,410
iterate over anything that's iterable so

00:17:05,100 --> 00:17:10,140
we can define our own iterable things

00:17:07,410 --> 00:17:13,080
like for example tree nodes we could

00:17:10,140 --> 00:17:15,750
make a tree that's actually in and of

00:17:13,080 --> 00:17:18,060
itself iterable you can loop over it so

00:17:15,750 --> 00:17:19,890
if we were going to make our tree nodes

00:17:18,060 --> 00:17:22,230
iterable I'm gonna make a new type of

00:17:19,890 --> 00:17:25,560
node called iterable tree node because

00:17:22,230 --> 00:17:27,630
I'm that creative and we want to give it

00:17:25,560 --> 00:17:30,750
an iterator that will attach the symbol

00:17:27,630 --> 00:17:32,460
iterator property and I'm gonna make the

00:17:30,750 --> 00:17:34,980
claim that we can actually use our

00:17:32,460 --> 00:17:37,350
recursive way of thinking about tree

00:17:34,980 --> 00:17:38,400
traversal to write this iterator so

00:17:37,350 --> 00:17:40,320
we're gonna build something that I'm

00:17:38,400 --> 00:17:42,290
gonna call a recursive a derp again

00:17:40,320 --> 00:17:45,180
because I'm just so creative with naming

00:17:42,290 --> 00:17:48,390
alright looking back to our recursive

00:17:45,180 --> 00:17:50,340
code from before that's what we see on

00:17:48,390 --> 00:17:51,120
the right here we had this recursive

00:17:50,340 --> 00:17:53,490
traversal

00:17:51,120 --> 00:17:55,230
I we had our base case we had our

00:17:53,490 --> 00:17:59,190
recursive case I'm just gonna shuffle

00:17:55,230 --> 00:18:01,410
them around a little bit so now before

00:17:59,190 --> 00:18:01,639
we were we were descending all the way

00:18:01,410 --> 00:18:03,169
to

00:18:01,639 --> 00:18:05,029
an empty child now we're just gonna

00:18:03,169 --> 00:18:06,829
assume that whatever's coming into this

00:18:05,029 --> 00:18:08,509
function is an actual tree node and

00:18:06,829 --> 00:18:10,759
instead of checking if it's undefined

00:18:08,509 --> 00:18:12,769
we're gonna move the check so that now

00:18:10,759 --> 00:18:15,109
we're gonna log the value of the node

00:18:12,769 --> 00:18:16,459
that we've got and then before we do the

00:18:15,109 --> 00:18:18,679
recursive calls we're just gonna make

00:18:16,459 --> 00:18:20,239
sure that they're not those children

00:18:18,679 --> 00:18:23,239
that we're about to recurse into are not

00:18:20,239 --> 00:18:25,009
undefined so we're just really shuffling

00:18:23,239 --> 00:18:27,679
things around here we've still got the

00:18:25,009 --> 00:18:29,029
same basic approach it's just we just

00:18:27,679 --> 00:18:30,739
move the check to a little bit earlier

00:18:29,029 --> 00:18:33,799
so that we don't have to descend all the

00:18:30,739 --> 00:18:35,179
way to undefined now in this case our

00:18:33,799 --> 00:18:36,829
base case is going to be kind of

00:18:35,179 --> 00:18:38,299
implicit it's like if we fall through

00:18:36,829 --> 00:18:40,159
both of the if statements and there are

00:18:38,299 --> 00:18:41,869
no children then we just return and

00:18:40,159 --> 00:18:45,799
that's kind of our implicit base case

00:18:41,869 --> 00:18:47,779
here so my claim is that we can use this

00:18:45,799 --> 00:18:50,329
recursive code to write an iterator for

00:18:47,779 --> 00:18:51,619
our for our tree what we want to do is

00:18:50,329 --> 00:18:52,969
we want to have some kind of function

00:18:51,619 --> 00:18:54,829
that's like this recur see it a writer

00:18:52,969 --> 00:18:56,719
that does the same thing as the

00:18:54,829 --> 00:18:58,429
recursive traversal function before it's

00:18:56,719 --> 00:18:59,989
going to output the value in the

00:18:58,429 --> 00:19:01,820
recursive case it's going to iterate

00:18:59,989 --> 00:19:03,589
over both of the sub trees and in the

00:19:01,820 --> 00:19:07,759
base case it's just gonna finish just

00:19:03,589 --> 00:19:09,709
gonna stop generators to the rescue so

00:19:07,759 --> 00:19:11,629
if we make this a little function star

00:19:09,709 --> 00:19:13,789
now we've got a generator function we

00:19:11,629 --> 00:19:15,649
can basically take the same exact code

00:19:13,789 --> 00:19:17,989
that we had in our recursive function

00:19:15,649 --> 00:19:19,639
and turn it into a generator using these

00:19:17,989 --> 00:19:21,709
yield statements so instead of console

00:19:19,639 --> 00:19:23,359
logging the value I'm yielding it so I'm

00:19:21,709 --> 00:19:26,119
outputting it and then pausing there and

00:19:23,359 --> 00:19:29,659
then if I have something on the left I'm

00:19:26,119 --> 00:19:33,259
going to recursively yield everything

00:19:29,659 --> 00:19:35,149
from the subtree on the left so this

00:19:33,259 --> 00:19:37,849
yield star basically lets us just loop

00:19:35,149 --> 00:19:39,799
over everything in that subtree so it's

00:19:37,849 --> 00:19:41,869
sort of implicit but it's basically like

00:19:39,799 --> 00:19:44,779
making a call to the recur see iterator

00:19:41,869 --> 00:19:47,269
on the subtrees node itself right and so

00:19:44,779 --> 00:19:49,969
really we're using the same concept here

00:19:47,269 --> 00:19:52,549
to recursively iterate through all of

00:19:49,969 --> 00:19:53,839
the nodes in this tree that we were

00:19:52,549 --> 00:19:55,669
doing with our recursive traversal

00:19:53,839 --> 00:19:58,820
function which is a you know more

00:19:55,669 --> 00:20:02,839
obviously recursive function so what

00:19:58,820 --> 00:20:06,169
we've got now is iterable code that we

00:20:02,839 --> 00:20:08,469
wrote and we can execute in in an

00:20:06,169 --> 00:20:11,359
iterative fashion using a for of loop

00:20:08,469 --> 00:20:13,399
which is super simple and intuitive to

00:20:11,359 --> 00:20:15,270
write just like for each thing and the

00:20:13,399 --> 00:20:17,730
tree tell me the thing and it

00:20:15,270 --> 00:20:19,580
as it does it but under the hood the way

00:20:17,730 --> 00:20:22,950
it's running is sort of more recursively

00:20:19,580 --> 00:20:24,990
so we've got recursive energy as it were

00:20:22,950 --> 00:20:26,460
at the soul of our iterative code I

00:20:24,990 --> 00:20:29,700
think that's pretty cool

00:20:26,460 --> 00:20:32,790
and it gets even better right so now in

00:20:29,700 --> 00:20:35,520
in the 2018-2019

00:20:32,790 --> 00:20:37,620
I think 2018 version of Ekman script

00:20:35,520 --> 00:20:40,440
we're getting like async iterables and

00:20:37,620 --> 00:20:43,260
iterators async generators for a weight

00:20:40,440 --> 00:20:45,780
of makes it even easier to work in the

00:20:43,260 --> 00:20:47,460
iterative paradigm and we can still use

00:20:45,780 --> 00:20:49,830
these kind of like high-level

00:20:47,460 --> 00:20:53,310
abstractions we can even have some that

00:20:49,830 --> 00:20:56,340
are powered by recursion so pretty sweet

00:20:53,310 --> 00:20:58,650
I think because what we've got here is

00:20:56,340 --> 00:21:00,720
we've got the the concept of iteration

00:20:58,650 --> 00:21:02,580
the paradigm of iteration combined with

00:21:00,720 --> 00:21:03,990
a little love from JavaScript and some

00:21:02,580 --> 00:21:05,340
features over the last few years that

00:21:03,990 --> 00:21:07,860
have made it easier to work in that

00:21:05,340 --> 00:21:09,780
paradigm combined with kind of the

00:21:07,860 --> 00:21:12,630
approach or the mental model of

00:21:09,780 --> 00:21:14,610
recursion gives us iterative code that's

00:21:12,630 --> 00:21:17,010
much more intuitive to read and write

00:21:14,610 --> 00:21:18,480
it's much more human efficient so I

00:21:17,010 --> 00:21:20,640
don't know about you but I think that's

00:21:18,480 --> 00:21:23,610
pretty cool and it gives me a warm fuzzy

00:21:20,640 --> 00:21:29,070
feeling in my heart all right

00:21:23,610 --> 00:21:31,650
so act 2 time to talk about recursion as

00:21:29,070 --> 00:21:35,040
we said recursion can often be more

00:21:31,650 --> 00:21:37,380
human efficient but machine efficiency

00:21:35,040 --> 00:21:41,220
or performance is sometimes a problem so

00:21:37,380 --> 00:21:43,260
let's look at why that is ok another

00:21:41,220 --> 00:21:45,270
cool thing about recursion and between

00:21:43,260 --> 00:21:46,560
studying philosophy and becoming a

00:21:45,270 --> 00:21:48,420
programmer I also studied linguistics

00:21:46,560 --> 00:21:50,520
because I think languages are super cool

00:21:48,420 --> 00:21:51,810
and recursion is also a future of

00:21:50,520 --> 00:21:53,760
languages right because we can have

00:21:51,810 --> 00:21:56,280
sentences or in this case a noun phrase

00:21:53,760 --> 00:21:59,280
like a dream within a dream within a

00:21:56,280 --> 00:22:01,170
dream within a dream where the phrase is

00:21:59,280 --> 00:22:03,690
sort of building on itself and it has

00:22:01,170 --> 00:22:05,550
this nested recursive structure so we

00:22:03,690 --> 00:22:07,020
can do that in language and it's true

00:22:05,550 --> 00:22:09,570
recursion like if you were to analyze

00:22:07,020 --> 00:22:11,370
the the sort of meaning structure or the

00:22:09,570 --> 00:22:13,980
way it's organized it really is sort of

00:22:11,370 --> 00:22:18,090
nested so we could write a recursive

00:22:13,980 --> 00:22:21,450
function to output a phrase like this a

00:22:18,090 --> 00:22:24,420
noun phrase like this given a number of

00:22:21,450 --> 00:22:26,190
kind of dream dives that we want to do

00:22:24,420 --> 00:22:27,670
so sort of a depth that we want Leo to

00:22:26,190 --> 00:22:29,950
let go to in his

00:22:27,670 --> 00:22:31,660
dream spelunking so here we've got

00:22:29,950 --> 00:22:33,940
another recursive function of course

00:22:31,660 --> 00:22:37,540
it's got a base case so if we're doing

00:22:33,940 --> 00:22:39,430
zero dream dives then we're just going

00:22:37,540 --> 00:22:41,290
to return a dream it's not inside of

00:22:39,430 --> 00:22:43,960
anything and otherwise we're gonna

00:22:41,290 --> 00:22:45,460
decrement the number that we're the

00:22:43,960 --> 00:22:48,340
number of dives that we're looking for

00:22:45,460 --> 00:22:50,830
and make a recursive call to the same

00:22:48,340 --> 00:22:52,480
function and then whenever that function

00:22:50,830 --> 00:22:55,360
returns we're gonna take the result of

00:22:52,480 --> 00:22:58,360
that and add on within a dream phrase to

00:22:55,360 --> 00:23:00,190
it so I've just put this in a little

00:22:58,360 --> 00:23:02,680
script so I can take in a number at the

00:23:00,190 --> 00:23:04,930
command line if I run it in node if I

00:23:02,680 --> 00:23:06,850
tell it I want to do a depth of three

00:23:04,930 --> 00:23:10,720
it's gonna give me a dream within a

00:23:06,850 --> 00:23:12,340
dream within a dream within a dream so

00:23:10,720 --> 00:23:15,760
we've got like three within if I give it

00:23:12,340 --> 00:23:17,380
30 I get 30 if I give it 3,000 I get

00:23:15,760 --> 00:23:20,320
3,000 it won't even fit on the slides

00:23:17,380 --> 00:23:26,350
but you can take my word for it what

00:23:20,320 --> 00:23:30,160
happens if I give it 30,000 ah yes I

00:23:26,350 --> 00:23:34,000
heard somebody say hello stack yeah we

00:23:30,160 --> 00:23:37,960
get this sad little error here maximum

00:23:34,000 --> 00:23:39,700
call stack size exceeded I think in I

00:23:37,960 --> 00:23:41,410
think in Firefox it even says something

00:23:39,700 --> 00:23:45,780
like too much recursion like too much

00:23:41,410 --> 00:23:48,630
recursion for you to recursion much pain

00:23:45,780 --> 00:23:52,930
so this is so this is a bummer because

00:23:48,630 --> 00:23:54,640
in in our minds lycra crucians should be

00:23:52,930 --> 00:23:57,640
able to go on infinitely there's no

00:23:54,640 --> 00:24:00,400
abstract like philosophical reason that

00:23:57,640 --> 00:24:02,860
recursion can't just continue and yet in

00:24:00,400 --> 00:24:05,110
reality what we get is we've run into

00:24:02,860 --> 00:24:06,670
this error javascript won't do it it

00:24:05,110 --> 00:24:08,590
doesn't like our recursive code it

00:24:06,670 --> 00:24:10,510
doesn't want us to have 30,000 dream

00:24:08,590 --> 00:24:12,010
layers that's like it's like no Leo

00:24:10,510 --> 00:24:13,870
can't handle it we're gonna break his

00:24:12,010 --> 00:24:19,570
poor beautiful little brain we're not

00:24:13,870 --> 00:24:21,670
doing it heartbroken this is because

00:24:19,570 --> 00:24:24,430
call stacks are like a real heartbreaker

00:24:21,670 --> 00:24:26,800
for recursion we need call stacks to

00:24:24,430 --> 00:24:29,260
execute our code but it they don't like

00:24:26,800 --> 00:24:31,450
recursive code very much so why is this

00:24:29,260 --> 00:24:33,130
or how does this work what happens when

00:24:31,450 --> 00:24:36,070
I run this code and I give it the number

00:24:33,130 --> 00:24:37,600
three so I've got my when when my coach

00:24:36,070 --> 00:24:39,940
starts running I've got a stack I've got

00:24:37,600 --> 00:24:41,620
some finite amount of memory that's

00:24:39,940 --> 00:24:44,770
allocated to like run

00:24:41,620 --> 00:24:47,350
and on that stack each time I make a

00:24:44,770 --> 00:24:49,900
call to a function it's gonna add a new

00:24:47,350 --> 00:24:51,429
frame and in that frame it's going to

00:24:49,900 --> 00:24:53,860
remember everything it needs to know

00:24:51,429 --> 00:24:56,140
about the the context of that particular

00:24:53,860 --> 00:24:57,880
call to that function like the scope of

00:24:56,140 --> 00:24:59,830
that call

00:24:57,880 --> 00:25:02,169
now the stack doesn't exactly look like

00:24:59,830 --> 00:25:04,720
whatever in here it doesn't like look so

00:25:02,169 --> 00:25:06,490
close to actual JavaScript code but I

00:25:04,720 --> 00:25:07,929
you know we're humans so I've written it

00:25:06,490 --> 00:25:10,000
in a way that sort of helps me

00:25:07,929 --> 00:25:11,860
understand okay this is what the

00:25:10,000 --> 00:25:14,110
computer is actually thinking about when

00:25:11,860 --> 00:25:16,090
it tries to execute this particular run

00:25:14,110 --> 00:25:19,270
of this function with this particular

00:25:16,090 --> 00:25:21,279
input so when we call this recursive

00:25:19,270 --> 00:25:23,350
inception function with three we get a

00:25:21,279 --> 00:25:25,169
new stack frame on top of some of the

00:25:23,350 --> 00:25:27,640
other global frames and things like that

00:25:25,169 --> 00:25:30,070
we get a new stack frame for this call

00:25:27,640 --> 00:25:31,899
recursive inception with input three now

00:25:30,070 --> 00:25:34,390
it doesn't match the base case so we're

00:25:31,899 --> 00:25:35,860
not going to do line five instead we're

00:25:34,390 --> 00:25:37,600
gonna go on line six and we're gonna say

00:25:35,860 --> 00:25:39,610
okay I need to make a call to recursive

00:25:37,600 --> 00:25:41,169
inception of two so that I can get that

00:25:39,610 --> 00:25:43,539
result back and then add within a dream

00:25:41,169 --> 00:25:45,700
to it so for that call to recursive

00:25:43,539 --> 00:25:46,929
inception two we need a new frame which

00:25:45,700 --> 00:25:49,059
is gonna make a call to recursive

00:25:46,929 --> 00:25:49,600
inception one which is gonna need a new

00:25:49,059 --> 00:25:51,520
frame

00:25:49,600 --> 00:25:53,080
which is gonna make a call to recursive

00:25:51,520 --> 00:25:54,580
inception of zero which is gonna need a

00:25:53,080 --> 00:25:56,649
new frame and now here we've hit the

00:25:54,580 --> 00:25:58,270
base case so here we don't need to make

00:25:56,649 --> 00:26:00,370
another recursive call we don't need to

00:25:58,270 --> 00:26:02,020
keep adding to the stack few because we

00:26:00,370 --> 00:26:03,880
just ran up against the limits of our

00:26:02,020 --> 00:26:05,130
memory with three calls it's a little

00:26:03,880 --> 00:26:07,809
bit larger than that in real life

00:26:05,130 --> 00:26:10,179
and so we're just going to return the

00:26:07,809 --> 00:26:11,740
value back from the call to zero that's

00:26:10,179 --> 00:26:14,529
gonna get returned back to the call to

00:26:11,740 --> 00:26:16,210
one so now it just it gets the actual

00:26:14,529 --> 00:26:17,649
value which is gonna add on within a

00:26:16,210 --> 00:26:19,149
dream or turn it back to the call to two

00:26:17,649 --> 00:26:20,860
which is gonna return it back to the

00:26:19,149 --> 00:26:25,899
call to three which eventually is gonna

00:26:20,860 --> 00:26:26,980
output our sentence cool okay now we can

00:26:25,899 --> 00:26:28,570
probably imagine what's gonna happen

00:26:26,980 --> 00:26:32,289
when we have a number that's a little

00:26:28,570 --> 00:26:35,770
bit bigger than three so if we try this

00:26:32,289 --> 00:26:37,659
with 30,000 is what happens right we

00:26:35,770 --> 00:26:40,929
start out same limited amount of memory

00:26:37,659 --> 00:26:42,850
now we've got a call to the function we

00:26:40,929 --> 00:26:46,510
didn't put 30,000 that's gonna make a

00:26:42,850 --> 00:26:48,250
call to input 29,999 which is going to

00:26:46,510 --> 00:26:52,390
need a new frame which is going to make

00:26:48,250 --> 00:26:53,860
a call to input with 2020 9900

00:26:52,390 --> 00:26:55,690
ninety-eight which is gonna need a new

00:26:53,860 --> 00:26:57,130
frame which is gonna make another call

00:26:55,690 --> 00:26:59,800
which is so on and so forth until

00:26:57,130 --> 00:27:01,300
eventually we're going to run out of

00:26:59,800 --> 00:27:04,120
memory and we're not gonna be able to

00:27:01,300 --> 00:27:07,210
fit the next call the next recursive

00:27:04,120 --> 00:27:09,910
call into the stack anymore and so we

00:27:07,210 --> 00:27:11,650
get you know sad face we get stack

00:27:09,910 --> 00:27:13,890
overflow we get call stack ik call sized

00:27:11,650 --> 00:27:18,970
stack exceeded too much recursion so sad

00:27:13,890 --> 00:27:21,280
in any case it's not fun so the problem

00:27:18,970 --> 00:27:23,050
here is that every time we as we

00:27:21,280 --> 00:27:24,730
increase n as we increase the input to

00:27:23,050 --> 00:27:27,040
the function we have to add basically a

00:27:24,730 --> 00:27:28,480
linear number of stack frames it like

00:27:27,040 --> 00:27:30,970
increases with the input to the function

00:27:28,480 --> 00:27:32,740
linearly wouldn't it be cool if we

00:27:30,970 --> 00:27:35,500
didn't have to do that if we didn't have

00:27:32,740 --> 00:27:37,330
to add a new frame every time we make a

00:27:35,500 --> 00:27:40,600
recursive call wouldn't we love that

00:27:37,330 --> 00:27:44,170
y-yes we would and JavaScript to the

00:27:40,600 --> 00:27:46,170
rescue so with a an implementation

00:27:44,170 --> 00:27:48,610
feature called tail call optimization

00:27:46,170 --> 00:27:50,440
which is a feature in some JavaScript

00:27:48,610 --> 00:27:53,670
engines we'll get back to that Oscar is

00:27:50,440 --> 00:27:56,100
to asterisk in a moment we can basically

00:27:53,670 --> 00:28:00,100
recycle stack frames after a fashion

00:27:56,100 --> 00:28:03,010
because we won't need to remember

00:28:00,100 --> 00:28:04,750
anything about the previous frames on

00:28:03,010 --> 00:28:07,840
the stack the previous recursive calls

00:28:04,750 --> 00:28:10,780
to that function if we write our code in

00:28:07,840 --> 00:28:14,230
a particular way where the call to the

00:28:10,780 --> 00:28:16,390
next function is in tail position and

00:28:14,230 --> 00:28:18,640
this is this gets at this feature called

00:28:16,390 --> 00:28:20,920
proper tail calls in es6 which gives us

00:28:18,640 --> 00:28:24,100
a way to tell if a function is a tail

00:28:20,920 --> 00:28:25,960
position call or not and what's a table

00:28:24,100 --> 00:28:30,220
position call what is what is a tail

00:28:25,960 --> 00:28:31,660
call really so let's take a look so when

00:28:30,220 --> 00:28:33,370
we have a recursive function where the

00:28:31,660 --> 00:28:35,980
recursive call is in tail position we

00:28:33,370 --> 00:28:37,660
have a tail recursive function the

00:28:35,980 --> 00:28:41,200
recursive function that we wrote before

00:28:37,660 --> 00:28:44,650
is not tail recursive so our original

00:28:41,200 --> 00:28:47,020
recursive inception function when we

00:28:44,650 --> 00:28:48,730
make that recursive call as you can see

00:28:47,020 --> 00:28:51,160
it's happening on the second-to-last

00:28:48,730 --> 00:28:52,660
line here now I just wrote it that way

00:28:51,160 --> 00:28:54,520
so it'd be a little bit more clear that

00:28:52,660 --> 00:28:55,390
it's not the last thing that the

00:28:54,520 --> 00:28:57,280
function does

00:28:55,390 --> 00:28:59,050
but even if we put it on the last line

00:28:57,280 --> 00:29:00,880
it's still not the last thing that the

00:28:59,050 --> 00:29:03,400
function does because after it makes

00:29:00,880 --> 00:29:05,190
that call that recursive call it has to

00:29:03,400 --> 00:29:07,200
get the result back and then it has to

00:29:05,190 --> 00:29:09,360
do more work it has to do more

00:29:07,200 --> 00:29:11,730
computation in this case it has to add a

00:29:09,360 --> 00:29:13,350
string concatenate a string onto the

00:29:11,730 --> 00:29:16,830
resulting string from that recursive

00:29:13,350 --> 00:29:19,110
call now what would a tail recursive

00:29:16,830 --> 00:29:24,420
version of this function look like let's

00:29:19,110 --> 00:29:26,220
write one so to make a non tail

00:29:24,420 --> 00:29:29,820
recursive function recursive tail

00:29:26,220 --> 00:29:32,280
recursive what we can do is use a helper

00:29:29,820 --> 00:29:33,420
function the helper function in this

00:29:32,280 --> 00:29:35,640
case I'm going to call it in cept

00:29:33,420 --> 00:29:39,690
because as we've seen by now I am the

00:29:35,640 --> 00:29:40,710
best neighbor of things ever this is the

00:29:39,690 --> 00:29:42,510
function that's actually going to be

00:29:40,710 --> 00:29:44,670
recursive here this is the one that's

00:29:42,510 --> 00:29:46,230
going to be doing the recursive calls

00:29:44,670 --> 00:29:49,800
and it's going we're gonna make it a

00:29:46,230 --> 00:29:51,300
tail recursive function and from our our

00:29:49,800 --> 00:29:52,620
main function we're just going to call

00:29:51,300 --> 00:29:56,940
it and we're gonna pass in whatever

00:29:52,620 --> 00:30:00,810
number the main function got so in our

00:29:56,940 --> 00:30:03,120
knot tail recursive function we had to

00:30:00,810 --> 00:30:05,280
use all of those layered stack frames to

00:30:03,120 --> 00:30:08,130
kind of remember where we had been like

00:30:05,280 --> 00:30:10,110
remember where we're at in the dive like

00:30:08,130 --> 00:30:12,180
how far down we need to go and so that

00:30:10,110 --> 00:30:15,720
we can pop back up when we hit the base

00:30:12,180 --> 00:30:17,130
case in a tail recursive function we

00:30:15,720 --> 00:30:18,150
can't do that or we don't want to do

00:30:17,130 --> 00:30:20,220
that right we don't want to have all

00:30:18,150 --> 00:30:21,930
those stack frames so instead we need

00:30:20,220 --> 00:30:24,150
some other way of remembering our

00:30:21,930 --> 00:30:26,370
history sort of where we've been and to

00:30:24,150 --> 00:30:27,870
do that we're gonna use an accumulator

00:30:26,370 --> 00:30:29,370
so in this case I'm just calling it

00:30:27,870 --> 00:30:32,540
dreams and it's gonna represent all of

00:30:29,370 --> 00:30:35,190
the dreams that we've dreamed so far in

00:30:32,540 --> 00:30:37,140
this case if we hit the base case where

00:30:35,190 --> 00:30:39,120
n is 0 we're just gonna return whatever

00:30:37,140 --> 00:30:40,890
is in the accumulator and otherwise

00:30:39,120 --> 00:30:42,780
we're gonna make the recursive call and

00:30:40,890 --> 00:30:46,050
in the next recursive call we're gonna

00:30:42,780 --> 00:30:47,790
pass in the old accumulator with the

00:30:46,050 --> 00:30:50,010
extra within a dream phrase and that's

00:30:47,790 --> 00:30:52,380
going to become the new value for the

00:30:50,010 --> 00:30:55,050
accumulator so the accumulator variable

00:30:52,380 --> 00:30:57,240
helps us remember that history and when

00:30:55,050 --> 00:30:58,590
we call the function the first time in

00:30:57,240 --> 00:31:01,020
our main function we're just gonna pass

00:30:58,590 --> 00:31:04,680
in our kind of base case as the initial

00:31:01,020 --> 00:31:07,010
value for the accumulator so now our

00:31:04,680 --> 00:31:09,690
recursive call is in tail position

00:31:07,010 --> 00:31:12,330
because it's the absolute last thing

00:31:09,690 --> 00:31:14,580
that the function has to do it doesn't

00:31:12,330 --> 00:31:16,920
have to do any more work once it gets

00:31:14,580 --> 00:31:18,940
the result back it just has to pass it

00:31:16,920 --> 00:31:20,409
straight on out it just returns it

00:31:18,940 --> 00:31:22,809
get to the result from the recursive

00:31:20,409 --> 00:31:25,659
call and just Hugh sends it on down the

00:31:22,809 --> 00:31:28,119
pike so this is the definition of a

00:31:25,659 --> 00:31:30,039
telltale call or a call being in tail

00:31:28,119 --> 00:31:33,489
position it's the absolute last work

00:31:30,039 --> 00:31:35,919
that the function has to do now when I

00:31:33,489 --> 00:31:39,190
run my function and I pass in input

00:31:35,919 --> 00:31:41,649
three what happens is a little bit

00:31:39,190 --> 00:31:45,999
different than before if I have a tail

00:31:41,649 --> 00:31:47,619
optimized JavaScript engine that sorry

00:31:45,999 --> 00:31:49,690
tail call optimized JavaScript engine

00:31:47,619 --> 00:31:51,399
then what happens when I call tail

00:31:49,690 --> 00:31:52,389
recursive inception of three all right

00:31:51,399 --> 00:31:54,779
well this is going to make a call to

00:31:52,389 --> 00:31:57,700
Incept with inputs three and a dream

00:31:54,779 --> 00:32:00,639
that's gonna get a frame and that's

00:31:57,700 --> 00:32:02,349
gonna make a call to Incept with two and

00:32:00,639 --> 00:32:04,090
a dream within a dream as the

00:32:02,349 --> 00:32:07,299
accumulator it's gonna add that on and

00:32:04,090 --> 00:32:09,940
that's gonna need a new frame but the

00:32:07,299 --> 00:32:12,909
thing is that when that inceptive to

00:32:09,940 --> 00:32:14,799
call returns again the inceptive three

00:32:12,909 --> 00:32:19,090
call is just gonna pass it right on back

00:32:14,799 --> 00:32:20,440
to the the original calling context to

00:32:19,090 --> 00:32:21,700
the tail recursive function and tail

00:32:20,440 --> 00:32:24,129
recursive inception function in this

00:32:21,700 --> 00:32:26,289
case and so we don't actually need to

00:32:24,129 --> 00:32:29,139
remember anything about the call to

00:32:26,289 --> 00:32:31,539
Incept of three so we can take that

00:32:29,139 --> 00:32:33,909
stack frame and just throw it out or

00:32:31,539 --> 00:32:36,190
better yet recycle right cuz where you

00:32:33,909 --> 00:32:38,080
go friendly so we could reuse the

00:32:36,190 --> 00:32:39,519
resources or we could just clear the

00:32:38,080 --> 00:32:42,789
freedom so that we have more space for

00:32:39,519 --> 00:32:44,799
something else we basically just take it

00:32:42,789 --> 00:32:47,499
off the stack and now our call to incept

00:32:44,799 --> 00:32:49,599
a two becomes the topmost frame on our

00:32:47,499 --> 00:32:51,639
stack that's gonna make a call to

00:32:49,599 --> 00:32:53,440
inceptive one again we get a new frame

00:32:51,639 --> 00:32:54,729
but we don't need to remember anything

00:32:53,440 --> 00:32:56,470
about the old one cuz it's just gonna

00:32:54,729 --> 00:32:59,289
pass the value right on through so we

00:32:56,470 --> 00:33:00,789
can recycle it and now the in cept if

00:32:59,289 --> 00:33:03,429
one call is on the top of the stack

00:33:00,789 --> 00:33:04,479
again that's gonna concept of zero we

00:33:03,429 --> 00:33:06,940
still don't need to remember anything

00:33:04,479 --> 00:33:08,379
about in cept if one in cept of zero

00:33:06,940 --> 00:33:10,090
becomes on the top of the stack that's

00:33:08,379 --> 00:33:11,950
gonna return and it's the base case so

00:33:10,090 --> 00:33:14,049
it's just done no more recursive calls

00:33:11,950 --> 00:33:15,399
we get our result back and we've got a

00:33:14,049 --> 00:33:18,789
dream within a dream within a dream

00:33:15,399 --> 00:33:21,159
within a dream it's hard to remember so

00:33:18,789 --> 00:33:24,309
this is how tail call optimization works

00:33:21,159 --> 00:33:27,729
in theory we should be able to get rid

00:33:24,309 --> 00:33:30,009
of each of those frames as we make a new

00:33:27,729 --> 00:33:32,380
one so that we really only need a

00:33:30,009 --> 00:33:35,560
constant number of stack frames to

00:33:32,380 --> 00:33:37,080
run our recursive code so what we've got

00:33:35,560 --> 00:33:40,690
now is code that we've written

00:33:37,080 --> 00:33:42,520
recursively that when JavaScript runs it

00:33:40,690 --> 00:33:45,130
when the engine runs it it's really

00:33:42,520 --> 00:33:46,690
running it more iteratively it's running

00:33:45,130 --> 00:33:48,340
it more like okay I just need to

00:33:46,690 --> 00:33:50,140
remember there's an N value and a dreams

00:33:48,340 --> 00:33:54,100
value and they start out being three and

00:33:50,140 --> 00:33:56,140
a dream and as n goes towards zero I'm

00:33:54,100 --> 00:33:58,990
just gonna keep adding within a dream to

00:33:56,140 --> 00:34:01,090
dream value and keep decrementing n and

00:33:58,990 --> 00:34:03,850
eventually and it's gonna reach zero and

00:34:01,090 --> 00:34:06,370
I'm just gonna return dreams so this is

00:34:03,850 --> 00:34:08,010
sort of how I think JavaScript thinks

00:34:06,370 --> 00:34:10,540
about our code is in this iterative way

00:34:08,010 --> 00:34:12,340
but we as humans think about in this

00:34:10,540 --> 00:34:15,940
recursive way and they both get to play

00:34:12,340 --> 00:34:18,280
nicely together now this is the this is

00:34:15,940 --> 00:34:20,350
the dream what about the reality how

00:34:18,280 --> 00:34:22,629
does tail call optimization feel in real

00:34:20,350 --> 00:34:24,550
life so now I've made the claim that

00:34:22,629 --> 00:34:26,200
with tail call optimization in

00:34:24,550 --> 00:34:29,409
JavaScript we should be able to run this

00:34:26,200 --> 00:34:31,450
code I've put our function in a little

00:34:29,409 --> 00:34:35,260
script like before and I should be able

00:34:31,450 --> 00:34:38,260
to pass in 30,000 and get out 30,000

00:34:35,260 --> 00:34:41,409
layered dreams right but if I make this

00:34:38,260 --> 00:34:47,230
call as written to node I still get back

00:34:41,409 --> 00:34:48,909
the same call sex I did I lie to you

00:34:47,230 --> 00:34:51,010
have I broken your heart so I betrayed

00:34:48,909 --> 00:34:53,050
you well not really because I had a

00:34:51,010 --> 00:34:54,820
disclaimer on my slides earlier if you

00:34:53,050 --> 00:34:57,670
remember I said this was a future of

00:34:54,820 --> 00:35:00,190
some JavaScript engines yeah so that's a

00:34:57,670 --> 00:35:02,680
real big asterisk because really most

00:35:00,190 --> 00:35:04,960
implementations of JavaScript don't have

00:35:02,680 --> 00:35:09,760
tail call optimization only a couple

00:35:04,960 --> 00:35:13,600
really do so WebKit is one and v8 chrome

00:35:09,760 --> 00:35:16,150
node had it but got rid of it because of

00:35:13,600 --> 00:35:17,920
some issues and really this is like this

00:35:16,150 --> 00:35:20,260
is actually a whole wormhole if you want

00:35:17,920 --> 00:35:22,900
to do some Leo style like diving into

00:35:20,260 --> 00:35:24,370
the the arguments behind tail call

00:35:22,900 --> 00:35:27,220
optimization whether or not it's a good

00:35:24,370 --> 00:35:29,500
idea like be my guest there's plenty of

00:35:27,220 --> 00:35:31,120
debate going on there's some some of the

00:35:29,500 --> 00:35:32,530
problems with tail call optimization or

00:35:31,120 --> 00:35:34,570
implementing in JavaScript are laid out

00:35:32,530 --> 00:35:37,390
in a cool blog post from the v8 team and

00:35:34,570 --> 00:35:39,370
this discussion is still ongoing so like

00:35:37,390 --> 00:35:42,430
there's a there's a proposal out for

00:35:39,370 --> 00:35:43,960
making like explicit tail call syntax to

00:35:42,430 --> 00:35:45,490
solve some of the issues that came up

00:35:43,960 --> 00:35:45,970
and there's also proposals like in the

00:35:45,490 --> 00:35:47,260
web

00:35:45,970 --> 00:35:49,990
Leigha community to talk about getting

00:35:47,260 --> 00:35:51,280
tail calls in there so you can check out

00:35:49,990 --> 00:35:53,710
the slides later I'll put them up and

00:35:51,280 --> 00:35:55,090
you can read all about this but suffice

00:35:53,710 --> 00:36:00,190
it to say this is a hotly contested

00:35:55,090 --> 00:36:02,950
future but I said that v8 and node kind

00:36:00,190 --> 00:36:05,080
of used to have it so if we use node six

00:36:02,950 --> 00:36:08,020
and in this case I'm using nvm to make

00:36:05,080 --> 00:36:10,480
sure that I'm using node six and if I

00:36:08,020 --> 00:36:14,290
pass in the right flag so harmony tail

00:36:10,480 --> 00:36:17,490
calls flag or just harmony now if I run

00:36:14,290 --> 00:36:20,290
my function with 30,000 as the input and

00:36:17,490 --> 00:36:21,640
it works okay now you can try it

00:36:20,290 --> 00:36:23,560
yourself if you don't believe me and

00:36:21,640 --> 00:36:25,630
this is obviously not 30,000 because

00:36:23,560 --> 00:36:28,210
they definitely don't fit on a slide but

00:36:25,630 --> 00:36:29,920
the point is that with this feature of

00:36:28,210 --> 00:36:31,599
telecom ization which I have to jump

00:36:29,920 --> 00:36:37,240
through some hoops to enable but it is

00:36:31,599 --> 00:36:39,119
eventually there we we get our limitless

00:36:37,240 --> 00:36:42,490
essentially recursion that we weren't it

00:36:39,119 --> 00:36:44,230
so my point has been and I'm sorry them

00:36:42,490 --> 00:36:46,180
over time a little bit but my point has

00:36:44,230 --> 00:36:48,160
been that now we've got code that we

00:36:46,180 --> 00:36:50,890
wrote recursively which thank to some

00:36:48,160 --> 00:36:53,040
features of proper Cale calls and tail

00:36:50,890 --> 00:36:55,599
call optimization and JavaScript engines

00:36:53,040 --> 00:36:57,760
lets us execute that code in a more

00:36:55,599 --> 00:36:59,980
iterative way so we get more machine

00:36:57,760 --> 00:37:02,260
efficient recursion so I can think as a

00:36:59,980 --> 00:37:05,349
human and recursion and execute it as a

00:37:02,260 --> 00:37:06,970
machine iteratively okay so this has

00:37:05,349 --> 00:37:09,670
basically been the point we've got these

00:37:06,970 --> 00:37:12,130
two competing paradigms that are

00:37:09,670 --> 00:37:14,650
ostensibly like in this epic feud

00:37:12,130 --> 00:37:16,810
forever they hate each other but really

00:37:14,650 --> 00:37:18,190
with some love from JavaScript we've

00:37:16,810 --> 00:37:19,839
seen that they can sort of complement

00:37:18,190 --> 00:37:21,940
each other and reinforce each other and

00:37:19,839 --> 00:37:24,369
make both of them easier to work with so

00:37:21,940 --> 00:37:26,530
we as programmers have more choices and

00:37:24,369 --> 00:37:28,240
we can decide what the best tool is for

00:37:26,530 --> 00:37:30,670
the job which paradigm makes more sense

00:37:28,240 --> 00:37:33,070
for us to work in and this is really the

00:37:30,670 --> 00:37:34,690
goal I think is for us to as we advance

00:37:33,070 --> 00:37:36,550
like the state of the artist programmers

00:37:34,690 --> 00:37:38,800
to get more options and have more ways

00:37:36,550 --> 00:37:42,160
of easily writing and efficiently

00:37:38,800 --> 00:37:43,660
running code so if you watch some

00:37:42,160 --> 00:37:45,520
further reading there's plenty of it you

00:37:43,660 --> 00:37:48,990
can check out the slides later that's it

00:37:45,520 --> 00:37:48,990
for me multi misc

00:37:52,610 --> 00:37:57,680
[Music]

00:37:55,620 --> 00:37:57,680

YouTube URL: https://www.youtube.com/watch?v=FmiQr4nfoPQ


