Title: V8 internals for JS developers - Mathias Bynens | JSHeroes 2018
Publication date: 2018-05-05
Playlist: JSHeroes 2018
Description: 
	This presentation demonstrates how learning just a little bit about JavaScript engine internals can help you improve the run-time performance of your JavaScript code â€” not just in V8 specifically, but across all JavaScript engines!
Captions: 
	00:00:01,840 --> 00:00:04,899
[Music]

00:00:09,950 --> 00:00:15,299
hi everyone thanks for being here

00:00:12,929 --> 00:00:18,900
my name is matthias and i indeed work on

00:00:15,299 --> 00:00:20,670
the VA team at google and v8 is ok one

00:00:18,900 --> 00:00:31,019
person of longing that's not awkward at

00:00:20,670 --> 00:00:32,369
all okay so v8 is the javascript engine

00:00:31,019 --> 00:00:34,410
that's used in google chrome but it's

00:00:32,369 --> 00:00:36,210
also used in OTS and in some other

00:00:34,410 --> 00:00:38,160
products as well like electron for

00:00:36,210 --> 00:00:39,629
example and today i'm gonna give you

00:00:38,160 --> 00:00:41,790
some performance advice for your

00:00:39,629 --> 00:00:43,770
javascript code but before we get to the

00:00:41,790 --> 00:00:46,440
actual advice we're gonna look at some

00:00:43,770 --> 00:00:48,329
JavaScript engine internals together so

00:00:46,440 --> 00:00:49,590
I'll be talking about some optimization

00:00:48,329 --> 00:00:51,690
mechanisms that we use in v8

00:00:49,590 --> 00:00:53,340
specifically however the performance

00:00:51,690 --> 00:00:55,649
advice that it will extract from this

00:00:53,340 --> 00:00:57,210
knowledge applies not just in v8 not

00:00:55,649 --> 00:00:58,829
just in Chrome not just in node but

00:00:57,210 --> 00:01:01,140
across the board of all JavaScript

00:00:58,829 --> 00:01:03,239
engines and all web browsers and I think

00:01:01,140 --> 00:01:05,010
that's really important in fact let's

00:01:03,239 --> 00:01:06,479
start off with the most important piece

00:01:05,010 --> 00:01:08,970
of performance advice that anyone can

00:01:06,479 --> 00:01:11,640
give you today you should just write

00:01:08,970 --> 00:01:13,290
modern idiomatic JavaScript and not

00:01:11,640 --> 00:01:15,000
worry about performance too much and

00:01:13,290 --> 00:01:18,180
that way the JavaScript engine can worry

00:01:15,000 --> 00:01:20,100
about making it fast instead modern

00:01:18,180 --> 00:01:22,950
JavaScript features are often much more

00:01:20,100 --> 00:01:24,960
than just syntax or new API methods they

00:01:22,950 --> 00:01:26,880
offer more optimization potential for

00:01:24,960 --> 00:01:28,439
the JavaScript engine than their hand

00:01:26,880 --> 00:01:30,750
written alternatives that you would ride

00:01:28,439 --> 00:01:34,140
in es5 or that you would use in a

00:01:30,750 --> 00:01:35,970
transpiled version and this way you also

00:01:34,140 --> 00:01:37,770
avoid falling into the trap of just

00:01:35,970 --> 00:01:39,390
optimizing for a single engine which

00:01:37,770 --> 00:01:43,040
just doesn't scale and doesn't make a

00:01:39,390 --> 00:01:45,180
lot of sense so let's get right into it

00:01:43,040 --> 00:01:47,490
javascript objects can have arbitrary

00:01:45,180 --> 00:01:49,259
properties associated with them the

00:01:47,490 --> 00:01:51,630
names of object properties can contain

00:01:49,259 --> 00:01:53,280
any alphanumeric character it can even

00:01:51,630 --> 00:01:55,320
contain any Unicode character including

00:01:53,280 --> 00:01:57,540
emoji which will make Monika very happy

00:01:55,320 --> 00:01:59,130
I'm sure but one of the interesting

00:01:57,540 --> 00:02:01,290
cases that a JavaScript engine can

00:01:59,130 --> 00:02:03,420
choose to optimize for our properties

00:02:01,290 --> 00:02:07,200
whose names are purely numeric more

00:02:03,420 --> 00:02:09,660
specifically array indexes in v8 array

00:02:07,200 --> 00:02:11,849
indices are handled specially and in

00:02:09,660 --> 00:02:13,450
many circumstances they these numerical

00:02:11,849 --> 00:02:14,860
index properties behave

00:02:13,450 --> 00:02:17,500
in exactly the same way as other

00:02:14,860 --> 00:02:19,090
properties but v8 still chooses to store

00:02:17,500 --> 00:02:21,849
them separately for optimization

00:02:19,090 --> 00:02:23,680
purposes internally we even give these

00:02:21,849 --> 00:02:26,110
special properties and name they're

00:02:23,680 --> 00:02:28,390
called elements so just think of it this

00:02:26,110 --> 00:02:31,330
way objects in JavaScript have

00:02:28,390 --> 00:02:34,300
properties that map to values and arrays

00:02:31,330 --> 00:02:37,480
have indexes that map to elements these

00:02:34,300 --> 00:02:39,250
are just the names that we use now

00:02:37,480 --> 00:02:41,890
whenever we're running JavaScript code

00:02:39,250 --> 00:02:43,900
v8 keeps track of what kind of elements

00:02:41,890 --> 00:02:45,670
each array contains this information

00:02:43,900 --> 00:02:47,709
allows for you to optimize any

00:02:45,670 --> 00:02:50,049
operations on the array specifically for

00:02:47,709 --> 00:02:52,959
this kind of element for example when

00:02:50,049 --> 00:02:55,540
you call reduce or map or for each on an

00:02:52,959 --> 00:02:56,890
array we can optimize those calls based

00:02:55,540 --> 00:02:59,440
on the information we have available

00:02:56,890 --> 00:03:01,900
about the elements kind so take this

00:02:59,440 --> 00:03:04,480
array for example what kind of elements

00:03:01,900 --> 00:03:06,849
does it contain if you were to use the

00:03:04,480 --> 00:03:08,470
typeof operator in JavaScript on this

00:03:06,849 --> 00:03:09,910
array on each element in the array

00:03:08,470 --> 00:03:11,950
it would just tell you that the array

00:03:09,910 --> 00:03:13,959
contains numbers at the language level

00:03:11,950 --> 00:03:15,370
that's all you'll get for now javascript

00:03:13,959 --> 00:03:16,720
doesn't distinguish between integers

00:03:15,370 --> 00:03:19,030
floats and doubles

00:03:16,720 --> 00:03:21,100
although begins are coming very soon to

00:03:19,030 --> 00:03:24,310
the language we're actually shipping

00:03:21,100 --> 00:03:26,290
them in chrome 67 but still JavaScript

00:03:24,310 --> 00:03:28,269
doesn't have integers floats and

00:03:26,290 --> 00:03:31,269
separate double types they're all just

00:03:28,269 --> 00:03:33,130
numbers for now however behind the

00:03:31,269 --> 00:03:36,549
scenes at the engine level we can make

00:03:33,130 --> 00:03:38,859
these more precise distinctions so the

00:03:36,549 --> 00:03:42,489
elements kind for this array is packed

00:03:38,859 --> 00:03:43,900
my elements now ignore the packed part

00:03:42,489 --> 00:03:46,239
for now we'll get to that in a minute

00:03:43,900 --> 00:03:49,120
for now just look at the smile part in

00:03:46,239 --> 00:03:50,829
v8 the term smile refers to the

00:03:49,120 --> 00:03:53,200
particular format that we used to store

00:03:50,829 --> 00:03:56,049
small integers so it just means that

00:03:53,200 --> 00:04:00,099
this is an integer basically and this

00:03:56,049 --> 00:04:01,989
array only contains integer values now

00:04:00,099 --> 00:04:04,030
if we take this array and then later add

00:04:01,989 --> 00:04:07,180
a floating point number to the very same

00:04:04,030 --> 00:04:09,790
array the the elements can transitions

00:04:07,180 --> 00:04:12,250
to a more generic elements kind in this

00:04:09,790 --> 00:04:15,459
case it would be packed double elements

00:04:12,250 --> 00:04:17,470
if we then add a string literal for

00:04:15,459 --> 00:04:21,370
example to the same array that changes

00:04:17,470 --> 00:04:23,349
its elements kind once again v8 assigns

00:04:21,370 --> 00:04:24,880
and elements kinds to each array the

00:04:23,349 --> 00:04:27,160
elements kind of an array is not set in

00:04:24,880 --> 00:04:29,530
stone it can change at runtime as we've

00:04:27,160 --> 00:04:31,690
in here and in this case we transitioned

00:04:29,530 --> 00:04:35,680
all the way from pacts my elements to

00:04:31,690 --> 00:04:37,720
pact elements so let's recap so far

00:04:35,680 --> 00:04:40,150
we've seen three distinct elements kinds

00:04:37,720 --> 00:04:42,070
there's the spice there's doubles and

00:04:40,150 --> 00:04:43,750
there's regular elements and you can

00:04:42,070 --> 00:04:45,460
think of it kind of has like a pyramid

00:04:43,750 --> 00:04:47,590
the set of numbers that can be

00:04:45,460 --> 00:04:48,700
represented as a smile is a subset of

00:04:47,590 --> 00:04:50,920
the set of numbers that can be

00:04:48,700 --> 00:04:52,810
represented as a double and the same

00:04:50,920 --> 00:04:54,940
thing goes for regular elements below

00:04:52,810 --> 00:04:57,400
that so what's important here is that

00:04:54,940 --> 00:04:59,440
elements kinds transitions can only go

00:04:57,400 --> 00:05:01,270
in one direction you start at the top

00:04:59,440 --> 00:05:03,010
and you can go downwards but you can

00:05:01,270 --> 00:05:05,020
never transition back up so in this

00:05:03,010 --> 00:05:07,360
example we went from pacts my elements

00:05:05,020 --> 00:05:09,610
to pact elements but after that we can

00:05:07,360 --> 00:05:13,210
never go back up to pact double elements

00:05:09,610 --> 00:05:14,950
for example now if we go back to the

00:05:13,210 --> 00:05:18,910
array that we had before how many items

00:05:14,950 --> 00:05:21,610
doesn't contain Wow okay I didn't know

00:05:18,910 --> 00:05:24,280
it was still that early period contains

00:05:21,610 --> 00:05:26,560
five items what happens if we assign a

00:05:24,280 --> 00:05:29,140
value to an index that is far outside of

00:05:26,560 --> 00:05:32,290
the bounds of this array for example if

00:05:29,140 --> 00:05:34,270
we assign a value at position nine well

00:05:32,290 --> 00:05:36,970
in this case it creates holes in the

00:05:34,270 --> 00:05:39,820
array at positions five until eight the

00:05:36,970 --> 00:05:43,780
array is now sparse or holy as we like

00:05:39,820 --> 00:05:45,910
to call it in v8 now creating holes in

00:05:43,780 --> 00:05:48,160
an array downgrades the elements kind to

00:05:45,910 --> 00:05:50,350
its holy variant we went from packed

00:05:48,160 --> 00:05:52,750
elements to holy elements in this case

00:05:50,350 --> 00:05:54,760
and there are of course other ways to

00:05:52,750 --> 00:05:57,040
create holes when you use the delete

00:05:54,760 --> 00:06:00,250
operator on an indexed property that

00:05:57,040 --> 00:06:02,500
also creates a hole there's other

00:06:00,250 --> 00:06:04,120
examples as well but why does Fiat care

00:06:02,500 --> 00:06:06,280
so much whether there are holes in an

00:06:04,120 --> 00:06:07,900
array why do we care so much that we

00:06:06,280 --> 00:06:10,030
actually have separate elements kinds

00:06:07,900 --> 00:06:12,850
for this well let's find out together by

00:06:10,030 --> 00:06:14,110
taking a look at an example now for the

00:06:12,850 --> 00:06:15,790
next five minutes I would like you all

00:06:14,110 --> 00:06:17,919
to pretend that you're a JavaScript

00:06:15,790 --> 00:06:19,419
engine and you're given this piece of

00:06:17,919 --> 00:06:21,070
code for the array that we looked at

00:06:19,419 --> 00:06:23,830
before you're getting the element at

00:06:21,070 --> 00:06:27,880
index eight what is the value for the

00:06:23,830 --> 00:06:29,440
element at index eight you can just

00:06:27,880 --> 00:06:31,120
answer the question you're a javascript

00:06:29,440 --> 00:06:33,040
admin engine dammit you have to follow

00:06:31,120 --> 00:06:36,760
this back so we need to do some work

00:06:33,040 --> 00:06:38,710
first when something that V does

00:06:36,760 --> 00:06:40,750
internally is it starts off by doing a

00:06:38,710 --> 00:06:43,270
bounced check on the array index

00:06:40,750 --> 00:06:44,710
is the index between zero inclusive and

00:06:43,270 --> 00:06:48,010
the number of items in the array

00:06:44,710 --> 00:06:49,960
exclusive well in this case the bounce

00:06:48,010 --> 00:06:51,250
check succeeds but we still cannot

00:06:49,960 --> 00:06:54,970
answer the question of what the result

00:06:51,250 --> 00:06:56,860
is more work is needed Viet now has to

00:06:54,970 --> 00:06:58,630
look up the property named eight on the

00:06:56,860 --> 00:07:00,220
array but in this case that property

00:06:58,630 --> 00:07:02,830
doesn't exist the only thing that's

00:07:00,220 --> 00:07:04,090
there is a hole so we still don't have

00:07:02,830 --> 00:07:06,820
enough information to answer the

00:07:04,090 --> 00:07:08,650
question we have to dig deeper now

00:07:06,820 --> 00:07:10,930
because the property is not present on

00:07:08,650 --> 00:07:13,120
the array itself v8 has to grow up the

00:07:10,930 --> 00:07:16,000
prototype chain until either a value is

00:07:13,120 --> 00:07:17,770
found or the prototype chain ends so

00:07:16,000 --> 00:07:19,780
first we check the prototype of the

00:07:17,770 --> 00:07:22,060
array which is array dot prototype and

00:07:19,780 --> 00:07:25,180
it doesn't have a property named it

00:07:22,060 --> 00:07:27,340
defined on it so at this point we still

00:07:25,180 --> 00:07:29,430
don't know what the answer is we have to

00:07:27,340 --> 00:07:32,140
continue to follow the prototype chain

00:07:29,430 --> 00:07:34,300
so we check the prototype of a radar

00:07:32,140 --> 00:07:36,430
prototype which is objective prototype

00:07:34,300 --> 00:07:39,910
we check if the property eight exists

00:07:36,430 --> 00:07:41,710
there and it doesn't so in this case the

00:07:39,910 --> 00:07:43,930
prototype to a chain ends after reaching

00:07:41,710 --> 00:07:45,760
object dot prototype but it could be

00:07:43,930 --> 00:07:47,169
longer in case someone extended it which

00:07:45,760 --> 00:07:48,940
is a totally valid thing to do in

00:07:47,169 --> 00:07:50,860
JavaScript I wouldn't say it's a best

00:07:48,940 --> 00:07:53,020
practice it's probably a very bad idea

00:07:50,860 --> 00:07:54,700
to extend built-in prototypes but it's

00:07:53,020 --> 00:07:56,800
something that you can totally do in

00:07:54,700 --> 00:07:58,560
JavaScript and because your JavaScript

00:07:56,800 --> 00:08:01,330
engine you have to support these cases

00:07:58,560 --> 00:08:03,160
now because in this case the chain ends

00:08:01,330 --> 00:08:05,229
we cannot continue searching for the

00:08:03,160 --> 00:08:08,229
property which means we can now finally

00:08:05,229 --> 00:08:12,220
answer our question the hole at position

00:08:08,229 --> 00:08:13,510
eight in the array is undefined now from

00:08:12,220 --> 00:08:15,040
the JavaScript engines perspective

00:08:13,510 --> 00:08:18,460
that's a lot of work just to get an

00:08:15,040 --> 00:08:20,710
undefined value isn't it now if we

00:08:18,460 --> 00:08:22,540
compare that to a packed array which is

00:08:20,710 --> 00:08:25,570
an array that is guaranteed to have no

00:08:22,540 --> 00:08:27,910
holes in it turns out that if the array

00:08:25,570 --> 00:08:30,100
index is within bounds the engine can

00:08:27,910 --> 00:08:32,080
instantly return the value no other

00:08:30,100 --> 00:08:34,150
checks or expensive lookups on the

00:08:32,080 --> 00:08:37,900
prototype chain or needed at all in that

00:08:34,150 --> 00:08:40,120
case now if we go back to a holy array

00:08:37,900 --> 00:08:43,570
even if we get a property that does

00:08:40,120 --> 00:08:44,950
exist that is not a hole then the engine

00:08:43,570 --> 00:08:48,250
still needs to check if the property

00:08:44,950 --> 00:08:51,280
exists first so v8 does the bounce check

00:08:48,250 --> 00:08:52,420
and in this case the check succeeds but

00:08:51,280 --> 00:08:54,880
we still don't have enough information

00:08:52,420 --> 00:08:56,590
to return the result

00:08:54,880 --> 00:08:58,480
we must then check if the property

00:08:56,590 --> 00:08:59,770
exists in the array because we know

00:08:58,480 --> 00:09:02,950
there's holes in the array and there

00:08:59,770 --> 00:09:04,780
might be a hole at this position in this

00:09:02,950 --> 00:09:08,020
case the property exists so we can

00:09:04,780 --> 00:09:09,910
return the value at this point but if

00:09:08,020 --> 00:09:11,710
the property didn't exist then it would

00:09:09,910 --> 00:09:13,540
be a hole and we would be back in the

00:09:11,710 --> 00:09:14,920
previous situation and we'd have to do

00:09:13,540 --> 00:09:16,450
the prototype chain work just like

00:09:14,920 --> 00:09:19,630
before which is a very expensive thing

00:09:16,450 --> 00:09:22,060
to do so this is the very best case

00:09:19,630 --> 00:09:24,070
scenario for a holey array and it's

00:09:22,060 --> 00:09:26,770
still one more operation compared to a

00:09:24,070 --> 00:09:27,730
packed array and that's why in general

00:09:26,770 --> 00:09:30,390
Paks

00:09:27,730 --> 00:09:32,590
arrays are preferred over holey arrays

00:09:30,390 --> 00:09:34,690
operations on packed arrays can just be

00:09:32,590 --> 00:09:36,820
optimized much more aggressively than

00:09:34,690 --> 00:09:38,230
operations on holey arrays so for

00:09:36,820 --> 00:09:45,640
optimal performance you should avoid

00:09:38,230 --> 00:09:47,170
creating holes whenever you can now

00:09:45,640 --> 00:09:49,660
going back to that list of elements

00:09:47,170 --> 00:09:52,090
kinds we already knew there were smiles

00:09:49,660 --> 00:09:53,770
for integers doubles and regular

00:09:52,090 --> 00:09:55,810
elements and that you can transition

00:09:53,770 --> 00:09:58,060
from smize to doubles and two regular

00:09:55,810 --> 00:10:00,010
elements but now we've learned that

00:09:58,060 --> 00:10:01,690
there's actually two flavors of each of

00:10:00,010 --> 00:10:03,640
those elements kinds there's the packed

00:10:01,690 --> 00:10:05,620
version and there's a holy version and

00:10:03,640 --> 00:10:08,830
we can also transition from a packed

00:10:05,620 --> 00:10:10,720
kind to its holey counterpart so instead

00:10:08,830 --> 00:10:11,980
of two separate pyramids it's actually a

00:10:10,720 --> 00:10:14,830
little bit easier to think of these

00:10:11,980 --> 00:10:17,050
elements kinds as a lattice and that is

00:10:14,830 --> 00:10:18,730
indeed how v8 implements the system

00:10:17,050 --> 00:10:20,230
around elements kinds and the

00:10:18,730 --> 00:10:22,720
transitions between them behind the

00:10:20,230 --> 00:10:24,150
scenes more concretely it looks a little

00:10:22,720 --> 00:10:26,830
something like this

00:10:24,150 --> 00:10:28,720
so we have our smile double and regular

00:10:26,830 --> 00:10:31,480
elements and each of those comes in two

00:10:28,720 --> 00:10:33,160
flavors packed and holy now these are

00:10:31,480 --> 00:10:35,260
just the most common elements kinds for

00:10:33,160 --> 00:10:36,760
a race specifically but v8 currently

00:10:35,260 --> 00:10:39,100
distinguishes over twenty different

00:10:36,760 --> 00:10:41,290
elements kinds each of which comes with

00:10:39,100 --> 00:10:44,560
its own set of potential optimizations

00:10:41,290 --> 00:10:46,060
for each array of operation and the

00:10:44,560 --> 00:10:48,040
thing about this lattice is that you can

00:10:46,060 --> 00:10:50,260
only transition downwards through the

00:10:48,040 --> 00:10:52,600
lattice it kind of it's kind of similar

00:10:50,260 --> 00:10:54,100
to this puzzle in pokemon blue or

00:10:52,600 --> 00:10:56,080
pokemon red when you enter the tower

00:10:54,100 --> 00:10:57,520
with lots of tiles with arrows on the

00:10:56,080 --> 00:10:59,020
floor as soon as you step on one of

00:10:57,520 --> 00:11:01,000
those styles you can only move in that

00:10:59,020 --> 00:11:02,650
direction this is the same thing you can

00:11:01,000 --> 00:11:04,930
only follow the arrows through this

00:11:02,650 --> 00:11:06,970
lattice this means that you can never go

00:11:04,930 --> 00:11:08,320
back up so once you have an array of

00:11:06,970 --> 00:11:10,120
smize and you

00:11:08,320 --> 00:11:12,910
at a single floating-point number to an

00:11:10,120 --> 00:11:14,700
array it is marked as double even if you

00:11:12,910 --> 00:11:17,230
later remove that double again and

00:11:14,700 --> 00:11:19,780
similarly once you create a hole in an

00:11:17,230 --> 00:11:23,050
array it is marked as holy forever

00:11:19,780 --> 00:11:25,030
now in general more specific elements

00:11:23,050 --> 00:11:26,980
kinds enable more fine-grained

00:11:25,030 --> 00:11:28,900
optimizations the further down the

00:11:26,980 --> 00:11:31,240
elements kinds you are in this lattice

00:11:28,900 --> 00:11:33,310
the slower manipulations of that object

00:11:31,240 --> 00:11:35,260
might become so for optimal performance

00:11:33,310 --> 00:11:37,420
you should try and avoid needlessly

00:11:35,260 --> 00:11:41,230
transitioning from one elements kind to

00:11:37,420 --> 00:11:44,350
another to give you an example of that

00:11:41,230 --> 00:11:46,120
for a rate of prototype for each we can

00:11:44,350 --> 00:11:50,280
use this information about the elements

00:11:46,120 --> 00:11:52,870
kinds to optimize each for each call now

00:11:50,280 --> 00:11:54,430
we have all this information we have

00:11:52,870 --> 00:11:56,740
these six different elements kinds here

00:11:54,430 --> 00:11:58,780
but in chrome 59 this is where we

00:11:56,740 --> 00:12:01,150
launched an entirely new pipeline in v8

00:11:58,780 --> 00:12:03,330
we had ignition or new interpreter and

00:12:01,150 --> 00:12:05,890
turbofan or new optimizing compiler and

00:12:03,330 --> 00:12:07,750
for that reason there was a lot of new

00:12:05,890 --> 00:12:10,450
stuff happening was a lot of work to get

00:12:07,750 --> 00:12:11,740
this to ship and we had this information

00:12:10,450 --> 00:12:13,990
about the elements guidance but we

00:12:11,740 --> 00:12:16,540
didn't have specific optimizations for

00:12:13,990 --> 00:12:18,760
each of them we could still optimize for

00:12:16,540 --> 00:12:21,340
each in some ways but we just didn't use

00:12:18,760 --> 00:12:23,290
this information yet however a couple of

00:12:21,340 --> 00:12:25,630
chrome versions later we already

00:12:23,290 --> 00:12:29,500
optimized for each in turbofan for all

00:12:25,630 --> 00:12:31,240
packet elements kinds and once again a

00:12:29,500 --> 00:12:33,220
couple of chrome versions later we had

00:12:31,240 --> 00:12:35,350
up we had specific optimizations for

00:12:33,220 --> 00:12:37,900
each of these elements kinds including

00:12:35,350 --> 00:12:39,400
the holy versions and this is a pattern

00:12:37,900 --> 00:12:41,590
that you'll see repeated for every

00:12:39,400 --> 00:12:43,210
single operation you can think of we

00:12:41,590 --> 00:12:45,520
have this elements kinds information for

00:12:43,210 --> 00:12:47,080
every array so over time we will add

00:12:45,520 --> 00:12:49,690
more and more specific and very

00:12:47,080 --> 00:12:53,020
fine-grained optimizations so the same

00:12:49,690 --> 00:12:56,200
thing goes for map filter some every

00:12:53,020 --> 00:12:58,090
reduce reduce writes and there's a bunch

00:12:56,200 --> 00:13:00,190
of other array methods but there's two

00:12:58,090 --> 00:13:01,420
that are a little bit special and I'd

00:13:00,190 --> 00:13:03,970
like to call them out they're called

00:13:01,420 --> 00:13:05,620
fine and find index and they are a

00:13:03,970 --> 00:13:07,420
little bit different than any of the

00:13:05,620 --> 00:13:09,790
other array methods in the spec if you

00:13:07,420 --> 00:13:12,670
read the spec you will find that they

00:13:09,790 --> 00:13:14,560
treat holes differently if fine we'll

00:13:12,670 --> 00:13:17,050
find index finds a hole it turns it into

00:13:14,560 --> 00:13:18,730
an explicit undefined value as you're

00:13:17,050 --> 00:13:19,960
using fine or find index which is

00:13:18,730 --> 00:13:21,440
something that none of the other methods

00:13:19,960 --> 00:13:23,840
really do

00:13:21,440 --> 00:13:26,150
and for that reason it's a little tricky

00:13:23,840 --> 00:13:28,190
for us right now to optimize it

00:13:26,150 --> 00:13:30,410
specifically in the holy double elements

00:13:28,190 --> 00:13:32,360
case but there is an open book for it

00:13:30,410 --> 00:13:33,770
we're working on this so in a couple of

00:13:32,360 --> 00:13:38,260
Chrome versions it will probably look

00:13:33,770 --> 00:13:40,670
like this let's look at another example

00:13:38,260 --> 00:13:43,810
now this piece of code creates an array

00:13:40,670 --> 00:13:46,460
of length three what does it contain

00:13:43,810 --> 00:13:49,490
well the array just has three holes in

00:13:46,460 --> 00:13:52,400
it the array is sparse at this point so

00:13:49,490 --> 00:13:53,570
it gets marked as holy my elements

00:13:52,400 --> 00:13:55,400
because that's the most specific

00:13:53,570 --> 00:13:58,850
possibility given the currently

00:13:55,400 --> 00:14:01,100
available information now let's assign a

00:13:58,850 --> 00:14:03,140
value to position zero in the array oh

00:14:01,100 --> 00:14:05,060
wait a minute that's a string instead of

00:14:03,140 --> 00:14:09,080
an integer so the elements kind

00:14:05,060 --> 00:14:11,210
transitions to holy elements now we add

00:14:09,080 --> 00:14:13,100
value to position one in the array and

00:14:11,210 --> 00:14:15,380
the elements kind remains unchanged in

00:14:13,100 --> 00:14:18,140
this case and finally we assign a value

00:14:15,380 --> 00:14:19,970
to the last position in the array now at

00:14:18,140 --> 00:14:22,820
this point you can notice that all three

00:14:19,970 --> 00:14:25,000
positions in the array are filled so the

00:14:22,820 --> 00:14:28,010
array is now packed and no longer sparse

00:14:25,000 --> 00:14:29,780
however as we've seen earlier we cannot

00:14:28,010 --> 00:14:32,960
transition to a more specific elements

00:14:29,780 --> 00:14:33,620
kind such as packet elements so the

00:14:32,960 --> 00:14:36,530
elements kind

00:14:33,620 --> 00:14:38,450
unfortunately remains holy elements once

00:14:36,530 --> 00:14:40,760
an array is marked as Holi its Holi

00:14:38,450 --> 00:14:44,360
forever and I believe that's how st. who

00:14:40,760 --> 00:14:46,190
it works as well but I'm not sure now in

00:14:44,360 --> 00:14:48,050
this scenario of course if you only have

00:14:46,190 --> 00:14:50,360
three values and you know ahead of time

00:14:48,050 --> 00:14:51,710
what the values are then of course you

00:14:50,360 --> 00:14:54,470
were just using array literal and

00:14:51,710 --> 00:14:56,480
hard-coded that makes more sense and in

00:14:54,470 --> 00:14:59,000
that case you also avoid creating a holy

00:14:56,480 --> 00:15:00,560
array the array would be packed but the

00:14:59,000 --> 00:15:02,510
more interesting case is when you don't

00:15:00,560 --> 00:15:03,860
know all the values ahead of time what

00:15:02,510 --> 00:15:05,030
if you have to compute some of these

00:15:03,860 --> 00:15:07,100
values dynamically or

00:15:05,030 --> 00:15:09,620
get them from a third party API or

00:15:07,100 --> 00:15:11,660
something like that well you can still

00:15:09,620 --> 00:15:13,580
avoid going Holi in that case if you

00:15:11,660 --> 00:15:16,490
just create an array it could be an

00:15:13,580 --> 00:15:18,830
empty array and later as you dynamically

00:15:16,490 --> 00:15:20,990
get the values you push the values to

00:15:18,830 --> 00:15:23,030
the array that way you avoid creating

00:15:20,990 --> 00:15:25,940
holes at any point in time and the array

00:15:23,030 --> 00:15:28,010
is never marked as holy this approach

00:15:25,940 --> 00:15:32,450
ensures that v8 optimizes any future

00:15:28,010 --> 00:15:35,750
operations on the array properly life is

00:15:32,450 --> 00:15:37,130
easier without holes JavaScript engines

00:15:35,750 --> 00:15:39,230
deal with packed arrays much more

00:15:37,130 --> 00:15:40,670
efficiently so in general if you need to

00:15:39,230 --> 00:15:44,650
perform lots of operations on an array

00:15:40,670 --> 00:15:47,870
avoid creating holes in it and similarly

00:15:44,650 --> 00:15:49,790
avoid reading beyond the length of an

00:15:47,870 --> 00:15:52,220
array outside of the boundaries because

00:15:49,790 --> 00:15:53,680
there's nothing there anyway so for

00:15:52,220 --> 00:15:56,390
example don't write your loops like this

00:15:53,680 --> 00:15:59,450
this loop reads all the elements in the

00:15:56,390 --> 00:16:01,160
array and then one more and it only ends

00:15:59,450 --> 00:16:03,770
once it finds an undefined or null

00:16:01,160 --> 00:16:05,330
element I didn't actually make up this

00:16:03,770 --> 00:16:08,240
example it's being used in a very

00:16:05,330 --> 00:16:09,860
popular open source library and they

00:16:08,240 --> 00:16:11,780
have kind of a reason for it but in

00:16:09,860 --> 00:16:13,790
general you should avoid patterns like

00:16:11,780 --> 00:16:16,970
this because this is just as bad as

00:16:13,790 --> 00:16:19,280
hitting a hole in an array in this case

00:16:16,970 --> 00:16:21,290
the bounce check would fail the check to

00:16:19,280 --> 00:16:23,000
see if the property is present on the

00:16:21,290 --> 00:16:24,590
array would fail and then we'd have to

00:16:23,000 --> 00:16:26,000
do the very expensive prototype chain

00:16:24,590 --> 00:16:28,910
lookup in case someone added the

00:16:26,000 --> 00:16:32,720
property on that prototype so this is a

00:16:28,910 --> 00:16:34,820
very big performance bottleneck so don't

00:16:32,720 --> 00:16:37,990
do this and instead keep your loop

00:16:34,820 --> 00:16:40,400
simple and just use a regular for loop

00:16:37,990 --> 00:16:43,130
just keep iterating until you hit the

00:16:40,400 --> 00:16:45,200
last element for example or nowadays as

00:16:43,130 --> 00:16:47,270
we just see as we've just seen in the

00:16:45,200 --> 00:16:49,820
last talk there's a more efficient or

00:16:47,270 --> 00:16:52,610
more elegant way of iterating you can

00:16:49,820 --> 00:16:54,740
use for off to just iterate over the

00:16:52,610 --> 00:16:56,600
items this is my favorite way of looping

00:16:54,740 --> 00:16:58,610
over arrays and any other iterable

00:16:56,600 --> 00:17:00,670
values including node lists in the Dom

00:16:58,610 --> 00:17:03,110
for example this works for them as well

00:17:00,670 --> 00:17:04,550
because you don't have to keep track of

00:17:03,110 --> 00:17:06,439
the index yourself you don't have to

00:17:04,550 --> 00:17:09,020
write a lot of boilerplate code just to

00:17:06,439 --> 00:17:10,790
get the loop going but another option

00:17:09,020 --> 00:17:12,860
would be to use if it's an array

00:17:10,790 --> 00:17:15,650
specifically of course you can use for

00:17:12,860 --> 00:17:17,959
each and the good news is that no matter

00:17:15,650 --> 00:17:20,689
which of these three approaches you

00:17:17,959 --> 00:17:23,150
prefer whether it's for each or for off

00:17:20,689 --> 00:17:25,280
or writing your own for loop performance

00:17:23,150 --> 00:17:27,079
is no longer a factor today in making

00:17:25,280 --> 00:17:28,910
the decision of which of these three you

00:17:27,079 --> 00:17:34,850
want to use in v8 they're all equally

00:17:28,910 --> 00:17:38,090
fast so avoid out-of-bounds reads doing

00:17:34,850 --> 00:17:39,500
so is just as bad as hitting a hole now

00:17:38,090 --> 00:17:41,870
before we move on to some more

00:17:39,500 --> 00:17:44,510
performance advice here's a little fun

00:17:41,870 --> 00:17:46,550
fact javascript has two zeros there's

00:17:44,510 --> 00:17:48,440
the regular zero which is positive and

00:17:46,550 --> 00:17:49,940
there's also a negative zero and

00:17:48,440 --> 00:17:51,769
although these value

00:17:49,940 --> 00:17:54,289
are strictly equal to each other they do

00:17:51,769 --> 00:17:56,779
behave differently in some cases and you

00:17:54,289 --> 00:17:59,690
can verify this using object that is for

00:17:56,779 --> 00:18:01,519
example now because they behave

00:17:59,690 --> 00:18:02,929
differently it means that JavaScript

00:18:01,519 --> 00:18:04,429
engines has to have to store these

00:18:02,929 --> 00:18:06,440
values separately as well in different

00:18:04,429 --> 00:18:08,929
ways because they need to differentiate

00:18:06,440 --> 00:18:10,460
between them and the reason I'm telling

00:18:08,929 --> 00:18:13,070
you this is because this has an impact

00:18:10,460 --> 00:18:15,019
on elements kinds as well I hinted

00:18:13,070 --> 00:18:16,610
earlier that it makes sense to avoid

00:18:15,019 --> 00:18:20,120
transitioning to a less specific

00:18:16,610 --> 00:18:21,500
elements kind whenever you can but this

00:18:20,120 --> 00:18:24,980
is actually a little bit harder than it

00:18:21,500 --> 00:18:28,009
seems for example just adding minus 0 to

00:18:24,980 --> 00:18:30,259
an array of small integers is enough to

00:18:28,009 --> 00:18:32,570
transition it to packed double elements

00:18:30,259 --> 00:18:34,370
and now any future operations on this

00:18:32,570 --> 00:18:35,720
array will be optimized in a completely

00:18:34,370 --> 00:18:38,960
different way than they would be for

00:18:35,720 --> 00:18:41,200
smize so this is just one more reason to

00:18:38,960 --> 00:18:43,220
avoid the negative 0 value in your code

00:18:41,200 --> 00:18:46,879
unless of course you have a use case for

00:18:43,220 --> 00:18:49,850
it but I doubt you do and the same thing

00:18:46,879 --> 00:18:52,009
goes for nom and infinity these values

00:18:49,850 --> 00:18:54,110
are represented as doubles as well so

00:18:52,009 --> 00:18:55,940
adding a single nom to an array of smile

00:18:54,110 --> 00:18:58,970
elements is enough to transition the

00:18:55,940 --> 00:19:00,320
whole thing to double elements so if

00:18:58,970 --> 00:19:02,779
you're planning on performing lots of

00:19:00,320 --> 00:19:05,120
operations on an array of integers then

00:19:02,779 --> 00:19:06,919
consider normalizing the values before

00:19:05,120 --> 00:19:09,950
adding them to the array so you could

00:19:06,919 --> 00:19:12,019
normalize minus 0 and you can block man

00:19:09,950 --> 00:19:14,120
and infinity when you're initializing

00:19:12,019 --> 00:19:16,159
the values this way the array would

00:19:14,120 --> 00:19:18,590
stick to the packets my elements kind

00:19:16,159 --> 00:19:21,320
and of course there's a one time

00:19:18,590 --> 00:19:22,940
normalization cost involved here when

00:19:21,320 --> 00:19:24,559
you're doing all the extra checks but

00:19:22,940 --> 00:19:26,120
this cost can be worth the later

00:19:24,559 --> 00:19:28,879
optimizations that you get when you

00:19:26,120 --> 00:19:30,379
start to actually use the array now in

00:19:28,879 --> 00:19:32,570
fact if you're doing mathematical

00:19:30,379 --> 00:19:33,889
operations on an array of numbers you

00:19:32,570 --> 00:19:36,679
should probably look into using typed

00:19:33,889 --> 00:19:38,659
arrays because we have very specialized

00:19:36,679 --> 00:19:40,820
and optimized elements kinds for those

00:19:38,659 --> 00:19:44,360
as well they're kind of made for this

00:19:40,820 --> 00:19:45,710
kind of thing so in general if you need

00:19:44,360 --> 00:19:47,960
to perform lots of operations on an

00:19:45,710 --> 00:19:50,210
array try sticking to an elements kind

00:19:47,960 --> 00:19:53,679
that's as specific as possible so that

00:19:50,210 --> 00:19:56,629
v8 can optimize it as much as possible

00:19:53,679 --> 00:19:59,059
some objects in JavaScript especially in

00:19:56,629 --> 00:20:01,340
the Dom look like arrays although they

00:19:59,059 --> 00:20:02,990
aren't proper arrays it's possible to

00:20:01,340 --> 00:20:03,650
create these array like objects yourself

00:20:02,990 --> 00:20:06,290
and we're do

00:20:03,650 --> 00:20:08,180
that right here this object has a length

00:20:06,290 --> 00:20:10,100
property and it supports indexed

00:20:08,180 --> 00:20:12,170
elements access just like a real array

00:20:10,100 --> 00:20:14,660
but it lacks array methods on its

00:20:12,170 --> 00:20:16,970
prototype so for each for example

00:20:14,660 --> 00:20:19,220
doesn't exist on its prototype but you

00:20:16,970 --> 00:20:22,160
can still call array generics like for

00:20:19,220 --> 00:20:24,080
each on it if you really want to so here

00:20:22,160 --> 00:20:26,420
we're doing just that we're calling the

00:20:24,080 --> 00:20:28,460
array for each built in on the array

00:20:26,420 --> 00:20:30,710
like object and that works as you would

00:20:28,460 --> 00:20:32,540
expect however it's important to know

00:20:30,710 --> 00:20:34,820
that this is going to be slower than

00:20:32,540 --> 00:20:36,860
calling for each on a real array which

00:20:34,820 --> 00:20:39,050
is highly optimized in v8 and in other

00:20:36,860 --> 00:20:41,120
JavaScript engines if you plan on using

00:20:39,050 --> 00:20:43,370
array built-ins on this object more than

00:20:41,120 --> 00:20:46,040
once then consider turning it into an

00:20:43,370 --> 00:20:48,170
actual array beforehand so that v8 can

00:20:46,040 --> 00:20:51,560
optimize these operations specifically

00:20:48,170 --> 00:20:53,540
based on the elements kind and here

00:20:51,560 --> 00:20:56,840
we're using slice to do just that and

00:20:53,540 --> 00:20:58,700
just like in our last example the there

00:20:56,840 --> 00:21:01,370
is of course a one time conversion cost

00:20:58,700 --> 00:21:03,200
of in this case calling slice but this

00:21:01,370 --> 00:21:04,880
small cost can be worth two later

00:21:03,200 --> 00:21:06,500
optimizations that you get when you're

00:21:04,880 --> 00:21:10,430
performing lots of operations on the

00:21:06,500 --> 00:21:12,740
array one specific example of this is

00:21:10,430 --> 00:21:15,380
the arguments object this is an array

00:21:12,740 --> 00:21:17,030
like object when you call array

00:21:15,380 --> 00:21:18,500
built-ins such as for each on it

00:21:17,030 --> 00:21:20,600
everything works the way you would

00:21:18,500 --> 00:21:22,310
expect it to but it won't be fully

00:21:20,600 --> 00:21:24,830
optimized the way it would be for a

00:21:22,310 --> 00:21:26,840
proper array luckily there is a language

00:21:24,830 --> 00:21:29,510
feature called rest parameters that can

00:21:26,840 --> 00:21:31,460
help you with that these rest parameters

00:21:29,510 --> 00:21:33,260
produce proper arrays that can be used

00:21:31,460 --> 00:21:36,110
instead of the array like arguments

00:21:33,260 --> 00:21:37,490
object in a very elegant way nowadays I

00:21:36,110 --> 00:21:39,290
don't think there's a very good reason

00:21:37,490 --> 00:21:41,930
anymore to use the arguments object

00:21:39,290 --> 00:21:44,060
directly use rest parameters instead it

00:21:41,930 --> 00:21:45,380
makes your code more elegant and engines

00:21:44,060 --> 00:21:49,780
can actually optimize it more

00:21:45,380 --> 00:21:49,780
efficiently as well so it's a win win

00:21:49,900 --> 00:21:53,750
this is not a real crocodile and it's

00:21:52,760 --> 00:21:57,380
not going to have the same performance

00:21:53,750 --> 00:21:59,780
as a real crocodile and the same thing

00:21:57,380 --> 00:22:01,430
goes for arrays in general you should

00:21:59,780 --> 00:22:05,380
avoid array like objects whenever

00:22:01,430 --> 00:22:05,380
possible and use proper arrays instead

00:22:10,030 --> 00:22:14,180
now after all this talk about elements

00:22:12,560 --> 00:22:16,850
kinds you may be wondering how you can

00:22:14,180 --> 00:22:19,010
identify the elements kinds of any given

00:22:16,850 --> 00:22:20,180
array in your codebase this might come

00:22:19,010 --> 00:22:22,070
in handy when you're debugging a

00:22:20,180 --> 00:22:23,420
performance issue or just when you're

00:22:22,070 --> 00:22:26,600
trying to get a better understanding of

00:22:23,420 --> 00:22:27,950
what I'm talking about here so to find

00:22:26,600 --> 00:22:31,460
out the elements kind of a given array

00:22:27,950 --> 00:22:33,230
you can run a debug build of d8 which is

00:22:31,460 --> 00:22:36,410
the binary you get when you build v8

00:22:33,230 --> 00:22:38,870
from source you pass in the allow native

00:22:36,410 --> 00:22:41,570
syntax flag and doing so enables access

00:22:38,870 --> 00:22:43,780
to some internal v8 functionality from

00:22:41,570 --> 00:22:45,980
within JavaScript it's really cool

00:22:43,780 --> 00:22:48,590
entering that command opens up the

00:22:45,980 --> 00:22:50,210
wrapper read eval print loop just like

00:22:48,590 --> 00:22:52,940
what you get if you enter node in your

00:22:50,210 --> 00:22:55,040
terminal so now we can start to enter

00:22:52,940 --> 00:22:58,880
some code and it will be run directly in

00:22:55,040 --> 00:23:01,550
v8 so first we create the array that we

00:22:58,880 --> 00:23:04,160
want to test and then we call one of

00:23:01,550 --> 00:23:06,350
those special v8 functions on it in this

00:23:04,160 --> 00:23:08,540
case debug print and you see how the

00:23:06,350 --> 00:23:11,030
name starts with a percentage sign well

00:23:08,540 --> 00:23:12,980
that's not really valid JavaScript we

00:23:11,030 --> 00:23:14,720
use this for all these v8 internal

00:23:12,980 --> 00:23:16,430
functions that are not really part of

00:23:14,720 --> 00:23:17,690
the JavaScript language because we don't

00:23:16,430 --> 00:23:19,850
want people to be using this in

00:23:17,690 --> 00:23:21,170
production code it doesn't make sense to

00:23:19,850 --> 00:23:23,930
use this in production code it's only

00:23:21,170 --> 00:23:26,090
useful for debugging anyway and it only

00:23:23,930 --> 00:23:27,860
works in this particular d8

00:23:26,090 --> 00:23:30,650
configuration it needs to be a debug

00:23:27,860 --> 00:23:32,840
build as well that's why we do this so

00:23:30,650 --> 00:23:35,810
anyway we can now press ENTER and that

00:23:32,840 --> 00:23:37,760
will actually run this piece of code now

00:23:35,810 --> 00:23:39,440
running this code prints a lot of output

00:23:37,760 --> 00:23:41,000
even more than what is shown here on the

00:23:39,440 --> 00:23:42,620
slide but in this case what we're

00:23:41,000 --> 00:23:45,110
looking for is the elements kind which

00:23:42,620 --> 00:23:48,940
is listed on this line in this case the

00:23:45,110 --> 00:23:51,920
elements kind is holy smile elements cow

00:23:48,940 --> 00:23:54,260
and that cow does not refer to the

00:23:51,920 --> 00:23:56,930
animal it stands for copy-on-write which

00:23:54,260 --> 00:23:58,850
is yet another internal optimization but

00:23:56,930 --> 00:24:02,090
don't worry about that for now

00:23:58,850 --> 00:24:04,490
in case you missed it the reason this of

00:24:02,090 --> 00:24:06,320
this array is holy is because we have

00:24:04,490 --> 00:24:08,390
two consecutive commas there without a

00:24:06,320 --> 00:24:10,670
value in between that's another way of

00:24:08,390 --> 00:24:13,040
creating a hole in an array so even a

00:24:10,670 --> 00:24:15,380
simple typo can accidentally create a

00:24:13,040 --> 00:24:17,360
hole in your array and throw a wrench in

00:24:15,380 --> 00:24:19,840
any potential optimizations that you may

00:24:17,360 --> 00:24:22,250
have now I should point out that

00:24:19,840 --> 00:24:23,660
creating a holy array is not the end of

00:24:22,250 --> 00:24:25,610
the world because we can still

00:24:23,660 --> 00:24:27,590
optimize for holy arrays it's just that

00:24:25,610 --> 00:24:31,960
the optimizations are different and not

00:24:27,590 --> 00:24:34,550
as efficient necessarily so let's recap

00:24:31,960 --> 00:24:36,920
we've explored what elements kinds are

00:24:34,550 --> 00:24:38,690
and how they work and as a result we

00:24:36,920 --> 00:24:41,350
were able to identify some practical

00:24:38,690 --> 00:24:45,440
tips that can help us boost performance

00:24:41,350 --> 00:24:48,400
avoid creating holes in arrays don't

00:24:45,440 --> 00:24:50,720
access indexes beyond the arrays length

00:24:48,400 --> 00:24:53,060
try to keep the elements kind of your

00:24:50,720 --> 00:24:54,740
array as specific as possible by

00:24:53,060 --> 00:24:58,370
sticking to a single value type for each

00:24:54,740 --> 00:24:59,960
array avoid using array like objects and

00:24:58,370 --> 00:25:02,210
when you have to use them consider

00:24:59,960 --> 00:25:03,950
converting them to proper arrays before

00:25:02,210 --> 00:25:04,390
performing any expensive operations on

00:25:03,950 --> 00:25:07,100
them

00:25:04,390 --> 00:25:09,260
now although this presentation covered

00:25:07,100 --> 00:25:11,810
3/8 internals these tips don't just

00:25:09,260 --> 00:25:13,280
apply to v8 any other JavaScript engines

00:25:11,810 --> 00:25:15,740
can benefit from them as well and they

00:25:13,280 --> 00:25:17,450
implement similar optimizations so by

00:25:15,740 --> 00:25:19,250
following this advice I promise you that

00:25:17,450 --> 00:25:21,020
your code is not gonna get any slower in

00:25:19,250 --> 00:25:24,890
other engines if anything it will be

00:25:21,020 --> 00:25:26,720
more efficient across the board now

00:25:24,890 --> 00:25:28,640
there's one more thing that we should

00:25:26,720 --> 00:25:30,680
probably talk about we had an example

00:25:28,640 --> 00:25:33,170
like this before where you have an array

00:25:30,680 --> 00:25:35,240
literal with some values in it and if

00:25:33,170 --> 00:25:37,340
you know the values beforehand it makes

00:25:35,240 --> 00:25:40,880
sense to hard-code them into the array

00:25:37,340 --> 00:25:42,620
lateral just like this and things get

00:25:40,880 --> 00:25:43,790
more interesting for larger areas though

00:25:42,620 --> 00:25:46,910
and that's the case that we didn't

00:25:43,790 --> 00:25:48,170
explicitly talk about especially if you

00:25:46,910 --> 00:25:50,200
want to create a large array and you

00:25:48,170 --> 00:25:52,340
don't know all the values beforehand

00:25:50,200 --> 00:25:54,230
maybe you're computing these values

00:25:52,340 --> 00:25:56,450
dynamically or you're fetching them from

00:25:54,230 --> 00:25:59,690
an external API just like before but

00:25:56,450 --> 00:26:02,000
imagine the array is very large now you

00:25:59,690 --> 00:26:03,710
may have seen this trick before if you

00:26:02,000 --> 00:26:05,810
know the length of the array ahead of

00:26:03,710 --> 00:26:08,000
time it makes sense to pass it to the

00:26:05,810 --> 00:26:10,670
array constructor like this so here

00:26:08,000 --> 00:26:13,700
we're creating an array with 9000 9001

00:26:10,670 --> 00:26:16,190
holes in it in the beginning doing so

00:26:13,700 --> 00:26:18,050
ensures that JavaScript can JavaScript

00:26:16,190 --> 00:26:23,420
engines can pre allocate the space for

00:26:18,050 --> 00:26:25,190
all 9001 elements behind the scenes so

00:26:23,420 --> 00:26:26,930
the downside as we discussed is of

00:26:25,190 --> 00:26:28,430
course that the array is marked as holy

00:26:26,930 --> 00:26:31,370
because it contains holes when it's

00:26:28,430 --> 00:26:33,770
created so when using the array

00:26:31,370 --> 00:26:35,600
constructor like this JavaScript engines

00:26:33,770 --> 00:26:37,309
can actually pre allocate the space for

00:26:35,600 --> 00:26:38,960
all the elements in the array

00:26:37,309 --> 00:26:41,509
that the array will need in the future

00:26:38,960 --> 00:26:43,639
and especially for large arrays this

00:26:41,509 --> 00:26:46,279
might actually speed up the creation of

00:26:43,639 --> 00:26:48,649
the array however because the array is

00:26:46,279 --> 00:26:50,899
marked as holy from the beginning you

00:26:48,649 --> 00:26:55,429
get potentially slower array operations

00:26:50,899 --> 00:26:57,110
compared to packet arrays so to avoid

00:26:55,429 --> 00:26:58,999
going holy we discussed this pattern

00:26:57,110 --> 00:27:01,159
where you start off with an array that

00:26:58,999 --> 00:27:02,870
could be empty it could have some values

00:27:01,159 --> 00:27:05,240
that you know ahead of time and then you

00:27:02,870 --> 00:27:07,700
dynamically push more values to them as

00:27:05,240 --> 00:27:09,379
you compute them now when you create an

00:27:07,700 --> 00:27:11,690
array the JavaScript engine creates a

00:27:09,379 --> 00:27:13,850
buffer in the backing store that holds

00:27:11,690 --> 00:27:14,720
the array elements and for an empty

00:27:13,850 --> 00:27:16,940
array in v8

00:27:14,720 --> 00:27:19,369
we already initialize a buffer of

00:27:16,940 --> 00:27:20,210
sixteen elements so that here it has

00:27:19,369 --> 00:27:21,919
some room to grow

00:27:20,210 --> 00:27:25,070
you can push a few elements without us

00:27:21,919 --> 00:27:26,480
having to allocate a new one but once a

00:27:25,070 --> 00:27:28,970
new element is added to the array that

00:27:26,480 --> 00:27:31,580
doesn't fit this buffer anymore we have

00:27:28,970 --> 00:27:33,379
to reallocate which is to create an

00:27:31,580 --> 00:27:35,509
entirely new buffer behind the scenes

00:27:33,379 --> 00:27:38,210
and copy all the elements from the

00:27:35,509 --> 00:27:40,129
previous buffer over and this is kind of

00:27:38,210 --> 00:27:42,619
an expensive operation you want to avoid

00:27:40,129 --> 00:27:44,899
a lot of reallocation whenever you can

00:27:42,619 --> 00:27:47,299
so if you start off with an empty array

00:27:44,899 --> 00:27:49,850
and then you push 9001 items to the

00:27:47,299 --> 00:27:52,580
array then v8 will reallocate the buffer

00:27:49,850 --> 00:27:55,009
in the backing store a total of sixteen

00:27:52,580 --> 00:27:56,869
times which is not too bad but you can

00:27:55,009 --> 00:27:59,269
imagine that if the array is 1 million

00:27:56,869 --> 00:28:02,749
items in size maybe things get a little

00:27:59,269 --> 00:28:04,730
worse so starting from an empty array

00:28:02,749 --> 00:28:06,649
and continuously pushing to it ensures

00:28:04,730 --> 00:28:09,080
that we never create any holes which is

00:28:06,649 --> 00:28:10,580
good the array remains packed at all

00:28:09,080 --> 00:28:12,470
times which means and in future

00:28:10,580 --> 00:28:15,320
operations on the array can be fully

00:28:12,470 --> 00:28:16,940
optimized the downside of continuously

00:28:15,320 --> 00:28:19,190
pushing to an array is that behind the

00:28:16,940 --> 00:28:21,320
scenes engines need to reallocate space

00:28:19,190 --> 00:28:22,940
as the array grows and for large arrays

00:28:21,320 --> 00:28:28,279
this might actually slow down the

00:28:22,940 --> 00:28:30,289
creation of the array so it's really up

00:28:28,279 --> 00:28:32,809
to you and it really depends on your use

00:28:30,289 --> 00:28:34,730
case either you choose to optimize the

00:28:32,809 --> 00:28:37,639
array creation itself and you can do

00:28:34,730 --> 00:28:39,440
that by using new array of n so that

00:28:37,639 --> 00:28:41,899
everything can be pre-allocated behind

00:28:39,440 --> 00:28:44,179
the scenes or you choose to optimize the

00:28:41,899 --> 00:28:46,279
actual operations on the array and in

00:28:44,179 --> 00:28:48,619
this case it makes sense to avoid holy

00:28:46,279 --> 00:28:51,140
elements kinds it's a trade off for sure

00:28:48,619 --> 00:28:55,730
and the choice depends on your exact you

00:28:51,140 --> 00:28:57,860
case now again to zoom out a little bit

00:28:55,730 --> 00:28:59,990
and to go back to that bigger piece of

00:28:57,860 --> 00:29:02,780
performance advice I hope you can all

00:28:59,990 --> 00:29:05,750
just enjoy and use modern JavaScript

00:29:02,780 --> 00:29:07,220
features and write idiomatic code that

00:29:05,750 --> 00:29:08,930
makes sense to you that is readable and

00:29:07,220 --> 00:29:10,370
maintainable and that is really the

00:29:08,930 --> 00:29:12,230
biggest performance improvement you can

00:29:10,370 --> 00:29:15,670
do for yourself and for JavaScript

00:29:12,230 --> 00:29:15,670
engines thank you

00:29:18,370 --> 00:29:23,410
[Music]

00:29:21,350 --> 00:29:23,410

YouTube URL: https://www.youtube.com/watch?v=5UZzT_hgsl0


