Title: OW2con'17 Performance testing and monitoring  a guided tour through CLIF tools and features Bruno Di
Publication date: 2017-06-29
Playlist: OW2con 2017
Description: 
	The CLIF project is 15 years old now - older than OW2 actually! Over the years, this performance testing software integrated new ideas, needs and technologies to keep efficient, powerful, maintainable and extendible: distributed and component-oriented programming, autonomic computing, continuous integration, cloud computing, containers...
While CLIF production version 2.3.5 has just been released, let's have an overview of all available features and tools, and see how the project will carry on towards automation for efficient performance testing and monitoring.
Captions: 
	00:00:01,960 --> 00:00:10,110
[Music]

00:00:05,000 --> 00:00:13,110
and so I'm going to to talk about the

00:00:10,110 --> 00:00:16,139
other value to the software for

00:00:13,110 --> 00:00:20,340
performance testing and monitoring with

00:00:16,139 --> 00:00:21,630
the cliff to cliff platform and so what

00:00:20,340 --> 00:00:23,820
is the performance testing and

00:00:21,630 --> 00:00:27,390
monitoring just to be sure that we share

00:00:23,820 --> 00:00:30,210
the same level of knowledge so with

00:00:27,390 --> 00:00:32,489
performance testing what you want to to

00:00:30,210 --> 00:00:36,660
do is that you have an application or a

00:00:32,489 --> 00:00:38,790
service that is not online yet and you

00:00:36,660 --> 00:00:42,090
want to check its performance before

00:00:38,790 --> 00:00:45,539
putting real users on it so you are

00:00:42,090 --> 00:00:49,129
going to emulate the workload of these

00:00:45,539 --> 00:00:52,140
real users with load injectors here

00:00:49,129 --> 00:00:55,559
there are three machines that to load

00:00:52,140 --> 00:00:57,780
injections with the clip software and

00:00:55,559 --> 00:01:00,899
then we will check the behavior of your

00:00:57,780 --> 00:01:05,539
application is it behaving correctly and

00:01:00,899 --> 00:01:05,539
are the response times correct typically

00:01:06,170 --> 00:01:11,490
then with preference monitoring the goal

00:01:09,390 --> 00:01:14,130
is a little bit different even though

00:01:11,490 --> 00:01:16,080
you still use the load injector to

00:01:14,130 --> 00:01:19,680
generate traffic here you will generate

00:01:16,080 --> 00:01:22,439
a small traffic because you already have

00:01:19,680 --> 00:01:25,170
real users because your system is online

00:01:22,439 --> 00:01:27,930
and what you want to check is the

00:01:25,170 --> 00:01:31,439
quality of experience of your system

00:01:27,930 --> 00:01:37,409
service application so this light

00:01:31,439 --> 00:01:41,210
traffic will perform the same traffic as

00:01:37,409 --> 00:01:45,930
a single real real user for example and

00:01:41,210 --> 00:01:54,030
then you check that your your platform

00:01:45,930 --> 00:01:57,299
services giving correctly briefly is a

00:01:54,030 --> 00:02:00,030
very brief presentation of case this is

00:01:57,299 --> 00:02:01,649
a generic adaptable Java framework for

00:02:00,030 --> 00:02:04,140
distributed performance testing and

00:02:01,649 --> 00:02:07,469
monitoring and so it comes with traffic

00:02:04,140 --> 00:02:10,379
generators that support out of the box a

00:02:07,469 --> 00:02:13,170
number of protocols you have a list here

00:02:10,379 --> 00:02:15,870
and if you don't find you

00:02:13,170 --> 00:02:19,140
protocol you need then you can very

00:02:15,870 --> 00:02:23,280
easily write or wrap your protocol and

00:02:19,140 --> 00:02:25,920
integrated to to live with in the same

00:02:23,280 --> 00:02:31,020
way you can also add some plugins to

00:02:25,920 --> 00:02:33,300
have specific data set like data sets in

00:02:31,020 --> 00:02:35,390
order to parameterize your user

00:02:33,300 --> 00:02:38,790
scenarios

00:02:35,390 --> 00:02:42,569
cliff also comes with the prod that will

00:02:38,790 --> 00:02:46,019
measure the consumption of of your

00:02:42,569 --> 00:02:48,980
resources out of the box here again

00:02:46,019 --> 00:02:52,380
there are a number of probes for typical

00:02:48,980 --> 00:02:55,319
system resources but here again you can

00:02:52,380 --> 00:02:58,850
right wrap your own probes and integrate

00:02:55,319 --> 00:03:01,769
it into cliff it's really done for that

00:02:58,850 --> 00:03:06,750
one of the peculiarities of placeit I

00:03:01,769 --> 00:03:10,319
power we at orange had some test cases

00:03:06,750 --> 00:03:13,799
where we used up to 1000 load injection

00:03:10,319 --> 00:03:15,799
machines in parallel and we also have

00:03:13,799 --> 00:03:17,970
test cases where we need to have

00:03:15,799 --> 00:03:21,780
hundreds of thousands or even millions

00:03:17,970 --> 00:03:25,620
of vehicle users in a single load

00:03:21,780 --> 00:03:28,530
injector and all this is working but of

00:03:25,620 --> 00:03:31,440
course you can also run just a single

00:03:28,530 --> 00:03:33,630
virtual user in a single load injector

00:03:31,440 --> 00:03:39,810
if typically if you are doing some

00:03:33,630 --> 00:03:40,650
performance monitoring and just like

00:03:39,810 --> 00:03:44,359
nginx

00:03:40,650 --> 00:03:48,630
cliff is an amateur project I would say

00:03:44,359 --> 00:03:51,810
it was launched 15 years ago ago and I

00:03:48,630 --> 00:03:55,049
would say that it followed the trends of

00:03:51,810 --> 00:03:56,690
computing science during these years we

00:03:55,049 --> 00:04:00,299
started from a component-based

00:03:56,690 --> 00:04:03,690
architecture with using the fractal

00:04:00,299 --> 00:04:08,040
component model from object web now auto

00:04:03,690 --> 00:04:11,340
we - we started also from Java

00:04:08,040 --> 00:04:16,130
technologies using well cliff is

00:04:11,340 --> 00:04:19,289
entirely developed in Java and the main

00:04:16,130 --> 00:04:21,370
graphical user interface very face of

00:04:19,289 --> 00:04:24,040
cliff is based on Eclipse

00:04:21,370 --> 00:04:26,590
and then we did some work in the field

00:04:24,040 --> 00:04:29,230
of dynamic computing and we developed

00:04:26,590 --> 00:04:32,290
some control loops to make some

00:04:29,230 --> 00:04:35,520
self-driven test campaigns and this was

00:04:32,290 --> 00:04:38,020
contributed as the self bench module and

00:04:35,520 --> 00:04:41,580
in the recent years we are really

00:04:38,020 --> 00:04:46,320
working and automation and automatic

00:04:41,580 --> 00:04:49,090
provisioning of testing infrastructures

00:04:46,320 --> 00:04:55,090
also we did do some work with OpenStack

00:04:49,090 --> 00:04:58,030
or with with the practice middleware to

00:04:55,090 --> 00:05:01,150
get those testing resources and

00:04:58,030 --> 00:05:04,750
frustrated on demand and we also

00:05:01,150 --> 00:05:12,220
automate the deployment of tests using

00:05:04,750 --> 00:05:14,889
Jenkins plugin and another image now so

00:05:12,220 --> 00:05:16,990
this very project is a rather old

00:05:14,889 --> 00:05:19,510
project now and there have been a number

00:05:16,990 --> 00:05:21,340
of developments and so let me show you

00:05:19,510 --> 00:05:23,680
explain you what are the main

00:05:21,340 --> 00:05:26,740
distributions and modules that you need

00:05:23,680 --> 00:05:28,930
to run case the first one is the simpler

00:05:26,740 --> 00:05:31,479
simplest one is the clip server

00:05:28,930 --> 00:05:34,570
distribution which is the basic cliff

00:05:31,479 --> 00:05:36,639
runtime that you need if you you need to

00:05:34,570 --> 00:05:40,990
enter on a machine if you want to deploy

00:05:36,639 --> 00:05:43,479
a load injector or a probe and it comes

00:05:40,990 --> 00:05:47,620
with just a command-line interface but a

00:05:43,479 --> 00:05:48,970
full-fledged command-line interface then

00:05:47,620 --> 00:05:51,910
you have the swing GUI which is

00:05:48,970 --> 00:05:56,650
basically the same distribution but with

00:05:51,910 --> 00:05:58,270
a simple graphical user interface which

00:05:56,650 --> 00:06:01,810
is dedicated to running tests and

00:05:58,270 --> 00:06:07,030
performing some performance analysis on

00:06:01,810 --> 00:06:09,220
reports then the main graphical user

00:06:07,030 --> 00:06:11,380
interface the full-fledged graphical

00:06:09,220 --> 00:06:15,099
user interface is what we call the clips

00:06:11,380 --> 00:06:18,430
control which is based on Eclipse so

00:06:15,099 --> 00:06:21,190
here you can do although you get all the

00:06:18,430 --> 00:06:25,840
features of case and including writing

00:06:21,190 --> 00:06:27,729
complex scenarios and moreover since it

00:06:25,840 --> 00:06:30,810
is based on Eclipse you have an

00:06:27,729 --> 00:06:33,490
integrated development environment that

00:06:30,810 --> 00:06:34,960
provides support for extending cliff and

00:06:33,490 --> 00:06:37,630
especially the

00:06:34,960 --> 00:06:40,150
equipped with odd for writing you wanna

00:06:37,630 --> 00:06:42,699
plug ins for odd injection for extra for

00:06:40,150 --> 00:06:46,720
example to integrate a new protocol or

00:06:42,699 --> 00:06:51,419
integrate a new data set provider and

00:06:46,720 --> 00:06:55,150
finally there is a plugin for Jenkins

00:06:51,419 --> 00:06:58,300
which helps automate automating test

00:06:55,150 --> 00:07:01,620
runs performance reporting and quality

00:06:58,300 --> 00:07:04,780
of experience are lacking either in a

00:07:01,620 --> 00:07:10,900
monitoring approach or in the continuous

00:07:04,780 --> 00:07:13,389
integration approach then entering one

00:07:10,900 --> 00:07:17,080
of these packages is very very easy you

00:07:13,389 --> 00:07:22,060
just have to download it from from cliff

00:07:17,080 --> 00:07:24,759
that o w2 dot org und pen is there is

00:07:22,060 --> 00:07:31,900
just one dependency which is a Java

00:07:24,759 --> 00:07:33,639
Runtime generator or later for the cliff

00:07:31,900 --> 00:07:37,630
performance testing plugin for Jenkins

00:07:33,639 --> 00:07:41,409
it's even easier you get it in your

00:07:37,630 --> 00:07:45,220
Jenkins presence manager because it has

00:07:41,409 --> 00:07:51,220
been contributed to the to the Jenkins

00:07:45,220 --> 00:07:53,349
community community early this year from

00:07:51,220 --> 00:07:55,870
the car it's simple just to command to

00:07:53,349 --> 00:07:58,659
get the image and once you have

00:07:55,870 --> 00:08:00,430
installed the cliff software you can

00:07:58,659 --> 00:08:02,860
easily get support from the cliff

00:08:00,430 --> 00:08:06,759
website where you will find a user guide

00:08:02,860 --> 00:08:10,240
examples tutorials videos presentations

00:08:06,759 --> 00:08:12,099
Javadoc for developers and if you have

00:08:10,240 --> 00:08:13,630
any question don't hesitate or in your

00:08:12,099 --> 00:08:18,490
remark don't hesitate to use like

00:08:13,630 --> 00:08:20,650
explaining it here is another view of

00:08:18,490 --> 00:08:22,990
the command-line interface just to show

00:08:20,650 --> 00:08:25,780
you that is really actually a complete

00:08:22,990 --> 00:08:29,139
set of commands that will allow you to

00:08:25,780 --> 00:08:33,089
deploy test or execute them get some

00:08:29,139 --> 00:08:35,320
statistical reports and doing a lot of

00:08:33,089 --> 00:08:38,440
execution control or configuration

00:08:35,320 --> 00:08:42,760
control during test executions and all

00:08:38,440 --> 00:08:46,630
these commands are just the same if you

00:08:42,760 --> 00:08:47,470
are running this on Windows on Mac OS X

00:08:46,630 --> 00:08:51,460
or

00:08:47,470 --> 00:08:58,270
on Linux or any unix-like environment

00:08:51,460 --> 00:09:01,180
with Java here is just a screenshot of

00:08:58,270 --> 00:09:02,650
the main graphical user interface based

00:09:01,180 --> 00:09:07,330
on Eclipse

00:09:02,650 --> 00:09:10,240
on the left part you see the list of

00:09:07,330 --> 00:09:12,910
test projects with on each project is a

00:09:10,240 --> 00:09:16,300
folder containing all the resources so

00:09:12,910 --> 00:09:19,870
the test plan the scenarios the data

00:09:16,300 --> 00:09:22,390
sets and so on and then on the upper

00:09:19,870 --> 00:09:24,730
part you see the list of load injectors

00:09:22,390 --> 00:09:27,310
or pods here there is just one single

00:09:24,730 --> 00:09:29,230
load injector in this example and in the

00:09:27,310 --> 00:09:32,680
bottom part you see the monitoring part

00:09:29,230 --> 00:09:36,100
which is convenient because when you run

00:09:32,680 --> 00:09:38,610
a test you want to see in real time if

00:09:36,100 --> 00:09:41,350
it's performing correctly otherwise it's

00:09:38,610 --> 00:09:48,040
it's not the case you you can stop the

00:09:41,350 --> 00:09:50,260
test immediately and and fix it and this

00:09:48,040 --> 00:09:53,590
is the performance reporting tool which

00:09:50,260 --> 00:09:55,510
is we did a lot of work on this tool to

00:09:53,590 --> 00:09:58,780
get something that is very efficient

00:09:55,510 --> 00:10:01,960
very easy to use and very powerful to

00:09:58,780 --> 00:10:05,710
get any kind of performance analysis on

00:10:01,960 --> 00:10:08,820
a response time of course and also on

00:10:05,710 --> 00:10:13,180
the versions the measurements of

00:10:08,820 --> 00:10:16,390
resources unit usage for example here

00:10:13,180 --> 00:10:19,030
you have a scatterplot of response times

00:10:16,390 --> 00:10:23,470
so each request for each request there

00:10:19,030 --> 00:10:28,150
is a a dot on the plot we have we see

00:10:23,470 --> 00:10:31,630
the CPU usage we also see the the

00:10:28,150 --> 00:10:34,600
throughput in a request per second very

00:10:31,630 --> 00:10:39,040
well so you can mix every kind of

00:10:34,600 --> 00:10:41,320
measurements from any any test and when

00:10:39,040 --> 00:10:44,880
it's ready you can generate a number of

00:10:41,320 --> 00:10:48,270
pages with one plot there will be

00:10:44,880 --> 00:10:51,190
automatic automatically you will have

00:10:48,270 --> 00:10:54,460
statistic analysis with all the main

00:10:51,190 --> 00:10:57,210
statistical values and then you can

00:10:54,460 --> 00:10:57,210
export it to HTML

00:10:58,250 --> 00:11:03,080
now let's have a look at the reports

00:11:01,250 --> 00:11:05,870
generated by the cliff legging for

00:11:03,080 --> 00:11:08,750
Jenkins this is the detailed performance

00:11:05,870 --> 00:11:12,800
report where you find for each request

00:11:08,750 --> 00:11:16,460
type for example here UDP connectivity

00:11:12,800 --> 00:11:20,740
or UDP sent you will have a global

00:11:16,460 --> 00:11:24,350
statistical array with own values and

00:11:20,740 --> 00:11:27,440
for each action type you get five graphs

00:11:24,350 --> 00:11:31,490
and that we'll see in the next slide

00:11:27,440 --> 00:11:35,030
slide and you will also have the in the

00:11:31,490 --> 00:11:39,740
first the purpose here you have we see

00:11:35,030 --> 00:11:43,760
that we had a GVM jvn probe so you can

00:11:39,740 --> 00:11:47,990
analyze also the consumption of the

00:11:43,760 --> 00:11:50,480
memory of the JVM if you like here are

00:11:47,990 --> 00:11:54,800
all the graphs that are generated the

00:11:50,480 --> 00:11:58,930
first one is a scatter plot then on the

00:11:54,800 --> 00:12:02,660
right you have the moving statistics

00:11:58,930 --> 00:12:04,670
about response Lima on throughput

00:12:02,660 --> 00:12:08,180
then you have the Instagram of response

00:12:04,670 --> 00:12:12,740
time and finally the the quantized of

00:12:08,180 --> 00:12:15,860
response time and all this is generated

00:12:12,740 --> 00:12:18,200
automatically for each test and then

00:12:15,860 --> 00:12:21,650
what something is very useful to is the

00:12:18,200 --> 00:12:26,240
performance trend from through

00:12:21,650 --> 00:12:27,740
successive tests so we see here the the

00:12:26,240 --> 00:12:32,089
evolution of the performance of

00:12:27,740 --> 00:12:37,190
performance with the maximum response

00:12:32,089 --> 00:12:40,700
time minimum average and also the

00:12:37,190 --> 00:12:43,550
standard deviation and also we see if

00:12:40,700 --> 00:12:45,740
there are some error or not because it's

00:12:43,550 --> 00:12:50,480
important to check that answers are

00:12:45,740 --> 00:12:52,490
correct and this is typically useful in

00:12:50,480 --> 00:12:54,980
continuous integration to see there are

00:12:52,490 --> 00:12:59,390
some performance regression and also of

00:12:54,980 --> 00:13:02,690
course in monitoring usage so this is

00:12:59,390 --> 00:13:05,839
the last slide welcoming Ness next with

00:13:02,690 --> 00:13:08,450
the case where as you probably have

00:13:05,839 --> 00:13:10,809
understood we really work a lot about

00:13:08,450 --> 00:13:14,129
automation today

00:13:10,809 --> 00:13:17,499
we are doing something with the act even

00:13:14,129 --> 00:13:21,279
right now in order to integrate metal as

00:13:17,499 --> 00:13:25,660
a service so bare metal resources in our

00:13:21,279 --> 00:13:28,420
in our tests we are working on fuel now

00:13:25,660 --> 00:13:32,410
with Angie Bolen we we probably will

00:13:28,420 --> 00:13:34,600
publish some rows on playbooks and we'll

00:13:32,410 --> 00:13:37,029
do also some more automation in

00:13:34,600 --> 00:13:39,579
OpenStack environments and for

00:13:37,029 --> 00:13:41,799
developers there will be some evolutions

00:13:39,579 --> 00:13:44,350
because we are going to move from

00:13:41,799 --> 00:13:47,350
reservation to the gate level to odo

00:13:44,350 --> 00:13:50,860
bluetooth github instance which will in

00:13:47,350 --> 00:13:53,139
imply a bit codebase reorganization

00:13:50,860 --> 00:13:56,170
because today the subversion code base

00:13:53,139 --> 00:14:02,319
is very monolithic and we have to split

00:13:56,170 --> 00:14:04,509
that number of repositories and as far

00:14:02,319 --> 00:14:06,999
as continue continuous integration is

00:14:04,509 --> 00:14:10,629
concerned while bamboo is is out of

00:14:06,999 --> 00:14:13,629
order right now so we have to to move to

00:14:10,629 --> 00:14:16,360
the CLABSI I okay so we are still

00:14:13,629 --> 00:14:17,709
working and well completing the move

00:14:16,360 --> 00:14:20,919
from the legacy keys could be

00:14:17,709 --> 00:14:22,949
practically so what coming next is your

00:14:20,919 --> 00:14:25,640
question now or later

00:14:22,949 --> 00:14:29,140
thank you

00:14:25,640 --> 00:14:29,140

YouTube URL: https://www.youtube.com/watch?v=torKA2Pxq_c


