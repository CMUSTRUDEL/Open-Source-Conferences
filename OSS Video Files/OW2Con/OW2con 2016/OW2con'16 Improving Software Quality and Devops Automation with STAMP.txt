Title: OW2con'16 Improving Software Quality and Devops Automation with STAMP
Publication date: 2016-09-27
Playlist: OW2con 2016
Description: 
	DevOps has emerged, as a major cultural movement to handle the need for increased agility in software development. While this movement is loosely bound to development methods, a number of practices have emerged to operationalize this extreme agility: loosely coupled software architectures meant to support incremental updates and build (services or micro services with clear APIs); a very high degree of automation at multiple stages of the development lifecycle. Quality assurance is a major challenge in this context. There is very little time for manual testing and the responsibility of bug detection is placed upon the automated test suites. STAMP (Software Testing AMPlification), is a new European R&D project, which aims to bolster automated test suites through the automatic transformation of test assets. The key technical challenge that STAMP aims at overcoming is to reduce the cost due to regression bugs that propagate to production, through advanced research in automatic test generation. The key novelty of our research agenda is to leverage existing assets (such as test cases or execution logs) in order to increase test effectiveness. This innovative research is at the crossroads of program analysis and transformation, software testing, automatic deployment and search-based software engineering.
Captions: 
	00:00:02,020 --> 00:00:10,620
[Music]

00:00:07,040 --> 00:00:13,349
and thanks for inviting me here so I

00:00:10,620 --> 00:00:16,379
will present this project it's a new age

00:00:13,349 --> 00:00:21,119
2020 project actually it's so new that

00:00:16,379 --> 00:00:26,789
is it hasn't started yet so it's

00:00:21,119 --> 00:00:29,189
super-new and it so it's a collaborative

00:00:26,789 --> 00:00:31,439
project as you can see it it gathers a

00:00:29,189 --> 00:00:35,969
number of partners who are present here

00:00:31,439 --> 00:00:38,100
oh w two were partners it's pretty much

00:00:35,969 --> 00:00:41,370
industrial the industry driven it's

00:00:38,100 --> 00:00:43,379
about software testing automation in the

00:00:41,370 --> 00:00:46,950
context of DevOps and so the main idea

00:00:43,379 --> 00:00:48,570
is if we look at DevOps this way so it

00:00:46,950 --> 00:00:51,120
kind of closes the loop between

00:00:48,570 --> 00:00:53,489
developers and operations and the main

00:00:51,120 --> 00:00:55,579
the main intuition of stamp is that in

00:00:53,489 --> 00:00:57,600
this context of continuous improvement

00:00:55,579 --> 00:01:00,149
continuous delivery continuous

00:00:57,600 --> 00:01:02,550
integration there's already a number of

00:01:00,149 --> 00:01:04,710
tests assets that are available test

00:01:02,550 --> 00:01:07,170
suites are available we have seen with

00:01:04,710 --> 00:01:10,350
the the project with cliff and active

00:01:07,170 --> 00:01:12,119
Aeon that they are test configurations

00:01:10,350 --> 00:01:14,939
which are model and which are deployed

00:01:12,119 --> 00:01:16,350
for performance testing to the number of

00:01:14,939 --> 00:01:20,520
things which are available for

00:01:16,350 --> 00:01:22,439
automating test execution yet these

00:01:20,520 --> 00:01:25,110
assets are manually built manually

00:01:22,439 --> 00:01:27,600
designed manually evolved and so somehow

00:01:25,110 --> 00:01:30,720
the scope is limited and can be expanded

00:01:27,600 --> 00:01:32,640
through a automatic generation and so

00:01:30,720 --> 00:01:34,500
the main objective of stamp is to

00:01:32,640 --> 00:01:37,590
automatically transform automatically

00:01:34,500 --> 00:01:40,439
diversify expand those existing test

00:01:37,590 --> 00:01:44,100
assets in order to improve the chances

00:01:40,439 --> 00:01:47,790
of detecting regression bugs before they

00:01:44,100 --> 00:01:51,090
go in production and so more concretely

00:01:47,790 --> 00:01:54,290
we're going to more completely we are

00:01:51,090 --> 00:01:57,090
going to work on three aspects of

00:01:54,290 --> 00:02:00,750
software testing in this DevOps

00:01:57,090 --> 00:02:03,149
continuous cycle so we're going to work

00:02:00,750 --> 00:02:05,130
on unit testing amplification we're

00:02:03,149 --> 00:02:07,079
going to work on configuration testing

00:02:05,130 --> 00:02:10,730
and flip education so it's very much

00:02:07,079 --> 00:02:12,440
related to what we saw earlier with what

00:02:10,730 --> 00:02:15,770
activate on an orange

00:02:12,440 --> 00:02:17,960
presented and we also work on online

00:02:15,770 --> 00:02:21,260
testing so here the idea is that in this

00:02:17,960 --> 00:02:22,730
DevOps context you you have locked races

00:02:21,260 --> 00:02:25,010
which come back from production and

00:02:22,730 --> 00:02:27,770
these traces can be used to generate new

00:02:25,010 --> 00:02:29,780
test cases which were not initially

00:02:27,770 --> 00:02:31,460
designed in the unit test suite but

00:02:29,780 --> 00:02:34,400
which reveals something about the

00:02:31,460 --> 00:02:38,020
production behavior which can be

00:02:34,400 --> 00:02:40,550
integrated for future regression testing

00:02:38,020 --> 00:02:43,070
so a bit more concretely it's going to

00:02:40,550 --> 00:02:44,990
be very much at the unit level it's

00:02:43,070 --> 00:02:46,460
going to be very much java oriented and

00:02:44,990 --> 00:02:48,130
so if you think about the fact that you

00:02:46,460 --> 00:02:51,320
have your jam unit test cases you have

00:02:48,130 --> 00:02:55,250
your java module and you have a commit

00:02:51,320 --> 00:02:57,230
when you when you integrate the commit

00:02:55,250 --> 00:03:00,260
in the in the version we would generate

00:02:57,230 --> 00:03:02,030
muchas cases so here you have variants

00:03:00,260 --> 00:03:04,550
of those existing j unit test cases

00:03:02,030 --> 00:03:06,500
which we run on both versions the

00:03:04,550 --> 00:03:08,150
previous version and the one which with

00:03:06,500 --> 00:03:10,070
the with the commit and we're looking

00:03:08,150 --> 00:03:12,110
for behavioral differences so this is

00:03:10,070 --> 00:03:14,270
that's the intuition of how we're going

00:03:12,110 --> 00:03:16,910
to look for regressions at the

00:03:14,270 --> 00:03:18,500
configuration level you have your your

00:03:16,910 --> 00:03:20,989
configuration so you have your different

00:03:18,500 --> 00:03:23,090
modules you have them descriptive

00:03:20,989 --> 00:03:25,100
description of your IP is and the

00:03:23,090 --> 00:03:27,620
description of how you're going to

00:03:25,100 --> 00:03:29,090
deploy your self your software

00:03:27,620 --> 00:03:31,730
application for testing so you have

00:03:29,090 --> 00:03:35,239
different languages or different

00:03:31,730 --> 00:03:37,900
frameworks to describe configurations so

00:03:35,239 --> 00:03:40,610
here I've mentioned chef for example and

00:03:37,900 --> 00:03:42,200
the same way we expand the number of

00:03:40,610 --> 00:03:45,080
configurations so we use those

00:03:42,200 --> 00:03:48,170
description of test configurations and

00:03:45,080 --> 00:03:51,230
we automatically generate new ones and

00:03:48,170 --> 00:03:53,330
we use technologies such as the one of

00:03:51,230 --> 00:03:55,760
active young to automatically deploy

00:03:53,330 --> 00:03:57,560
these configurations and again we run

00:03:55,760 --> 00:03:59,720
the the test cases on the different

00:03:57,560 --> 00:04:02,060
configurations this this time looking

00:03:59,720 --> 00:04:06,400
for performance differences so looking

00:04:02,060 --> 00:04:10,670
for performance regressions and that the

00:04:06,400 --> 00:04:12,320
the last step is that online in

00:04:10,670 --> 00:04:15,890
production you can have probes which

00:04:12,320 --> 00:04:18,049
will give you choices and these traces

00:04:15,890 --> 00:04:20,180
can be analyzed to generate new test

00:04:18,049 --> 00:04:22,580
cases which we're going to push back in

00:04:20,180 --> 00:04:24,740
the in the unit test suite for future

00:04:22,580 --> 00:04:25,880
regression testing so that's that's the

00:04:24,740 --> 00:04:28,520
main ideas that we

00:04:25,880 --> 00:04:32,710
that we have put in in this proposal so

00:04:28,520 --> 00:04:37,150
as I said it's a new project we haven't

00:04:32,710 --> 00:04:39,650
started yet so there's not much more

00:04:37,150 --> 00:04:42,710
concrete things that I can show you one

00:04:39,650 --> 00:04:44,780
thing I can start discussed talking

00:04:42,710 --> 00:04:46,370
about is what we have started doing at

00:04:44,780 --> 00:04:48,770
Amelia about unit tests and

00:04:46,370 --> 00:04:52,070
amplification so the basic idea is that

00:04:48,770 --> 00:04:54,080
your unit test suite as a selection in

00:04:52,070 --> 00:04:56,240
the input space that you are run on the

00:04:54,080 --> 00:04:57,830
program the program gets in a final

00:04:56,240 --> 00:04:59,990
state and then you have those assertions

00:04:57,830 --> 00:05:01,850
here and you're in ujjain unit test

00:04:59,990 --> 00:05:03,530
suite which expresses something that you

00:05:01,850 --> 00:05:06,050
expect about the final state of your

00:05:03,530 --> 00:05:08,420
program and so unit test amplification

00:05:06,050 --> 00:05:10,520
is basically generate automatically

00:05:08,420 --> 00:05:13,150
taking those inputs generating new

00:05:10,520 --> 00:05:16,280
inputs in the neighborhood and also

00:05:13,150 --> 00:05:18,020
expanding the the observation space on

00:05:16,280 --> 00:05:19,580
the output space we also want to do

00:05:18,020 --> 00:05:22,070
amplification because of course it goes

00:05:19,580 --> 00:05:24,980
hand by hand if you generate new inputs

00:05:22,070 --> 00:05:27,980
the assertion about the state that you

00:05:24,980 --> 00:05:30,170
expect at the end of the execution has

00:05:27,980 --> 00:05:32,600
to change it's not the same assertion if

00:05:30,170 --> 00:05:34,520
you if you pass the test case with a new

00:05:32,600 --> 00:05:38,150
input so we have to work on on both

00:05:34,520 --> 00:05:39,980
sides the idea is that you have your you

00:05:38,150 --> 00:05:42,050
have your test suite here you have your

00:05:39,980 --> 00:05:44,450
program you have your version p prime of

00:05:42,050 --> 00:05:46,300
your of your program so the version in

00:05:44,450 --> 00:05:49,670
which you have introduced a change and

00:05:46,300 --> 00:05:51,740
we want to use this so the tool is

00:05:49,670 --> 00:05:54,050
called this spot for the moment and this

00:05:51,740 --> 00:05:56,180
is going to produce GS plus plus so it's

00:05:54,050 --> 00:06:00,770
this test suite and that we expand with

00:05:56,180 --> 00:06:03,410
new test cases so basically amplifying

00:06:00,770 --> 00:06:05,540
unit test suites or unit test cases is

00:06:03,410 --> 00:06:07,220
to take we take the test case the

00:06:05,540 --> 00:06:10,970
existing test suite and the program P

00:06:07,220 --> 00:06:13,670
and we first amplify the the input space

00:06:10,970 --> 00:06:17,300
so we generate new test cases which are

00:06:13,670 --> 00:06:20,900
going to trigger behavior with new input

00:06:17,300 --> 00:06:23,090
data and then we amplify the out output

00:06:20,900 --> 00:06:24,890
space the observation space so we remove

00:06:23,090 --> 00:06:27,350
the assertions which don't make sense

00:06:24,890 --> 00:06:29,270
anymore with those new inputs and we

00:06:27,350 --> 00:06:31,460
generate new input new assertions

00:06:29,270 --> 00:06:32,630
basically those assertions are based on

00:06:31,460 --> 00:06:35,510
the fact that we're doing regression

00:06:32,630 --> 00:06:37,160
testing so we are going to generate the

00:06:35,510 --> 00:06:38,060
test read the new test cases we

00:06:37,160 --> 00:06:40,190
generally

00:06:38,060 --> 00:06:42,919
acute them on both versions and so the

00:06:40,190 --> 00:06:45,260
assertions are about checking if we find

00:06:42,919 --> 00:06:47,180
differences between the diversion P and

00:06:45,260 --> 00:06:50,180
P prime of the program and then we

00:06:47,180 --> 00:06:53,950
eventually run them with a specific test

00:06:50,180 --> 00:06:56,139
runner to look for differences so

00:06:53,950 --> 00:06:59,120
amplifying the input space is really

00:06:56,139 --> 00:07:02,150
mutating the the parameters for the

00:06:59,120 --> 00:07:04,160
method call calling new methods removing

00:07:02,150 --> 00:07:08,030
method calls so everything that you can

00:07:04,160 --> 00:07:10,940
imagine in terms of changing the the

00:07:08,030 --> 00:07:13,190
code of your J unit test cases we are

00:07:10,940 --> 00:07:15,440
going to do it and we do this through an

00:07:13,190 --> 00:07:18,020
automatic code analysis and code

00:07:15,440 --> 00:07:20,840
generation at search base because at

00:07:18,020 --> 00:07:22,790
some point we need some heuristics to to

00:07:20,840 --> 00:07:24,710
prune the search base there we can

00:07:22,790 --> 00:07:26,810
generate basically millions of variants

00:07:24,710 --> 00:07:29,240
of your J unit test cases which we don't

00:07:26,810 --> 00:07:31,070
want because because we don't have time

00:07:29,240 --> 00:07:34,010
and resources to execute those million

00:07:31,070 --> 00:07:35,960
of test cases and the tricky thing is

00:07:34,010 --> 00:07:37,550
also about the output space I already

00:07:35,960 --> 00:07:40,100
talked about it but the Oracle

00:07:37,550 --> 00:07:41,810
expressing what we what we expect about

00:07:40,100 --> 00:07:43,400
those new test cases is tricky because

00:07:41,810 --> 00:07:45,020
we don't know what we expect we don't

00:07:43,400 --> 00:07:47,840
have the requirements for those new test

00:07:45,020 --> 00:07:50,770
cases and so here we we generate a very

00:07:47,840 --> 00:07:52,820
specific kind of article which is purely

00:07:50,770 --> 00:07:55,640
regression-based so what will the

00:07:52,820 --> 00:07:58,370
article just expresses the fact that we

00:07:55,640 --> 00:08:01,550
are going to raise an alarm if the

00:07:58,370 --> 00:08:03,350
behavior on on the same input if the

00:08:01,550 --> 00:08:05,570
behavior on p and p prime are different

00:08:03,350 --> 00:08:07,220
and so we generate assertions which are

00:08:05,570 --> 00:08:09,560
meant to check this they are not meant

00:08:07,220 --> 00:08:11,630
to check a functional property they're

00:08:09,560 --> 00:08:14,690
meant to check if both programs behave

00:08:11,630 --> 00:08:16,010
the same or differently and so we have a

00:08:14,690 --> 00:08:18,260
number of rules to automatically

00:08:16,010 --> 00:08:20,030
generate these articles so basically

00:08:18,260 --> 00:08:23,840
that's the kind of thing we have so

00:08:20,030 --> 00:08:26,000
that's one J unit just case that we

00:08:23,840 --> 00:08:28,220
would have at the beginning and this is

00:08:26,000 --> 00:08:30,350
an amplified well this is a new test

00:08:28,220 --> 00:08:33,530
case that we could generate so we have

00:08:30,350 --> 00:08:35,779
new calls we have newer search so here

00:08:33,530 --> 00:08:39,409
these assertions were not present at the

00:08:35,779 --> 00:08:41,180
beginning and these these calls here are

00:08:39,409 --> 00:08:42,650
extracted from dear sirs because of

00:08:41,180 --> 00:08:45,050
course it's not only a matter of

00:08:42,650 --> 00:08:46,790
removing the J unit assertions but

00:08:45,050 --> 00:08:48,470
usually in you J unit assertions you

00:08:46,790 --> 00:08:50,060
have method calls which are part of the

00:08:48,470 --> 00:08:50,570
test case so you still need to remove

00:08:50,060 --> 00:08:52,850
them in

00:08:50,570 --> 00:08:54,380
to execute this mess accounts we have a

00:08:52,850 --> 00:08:56,690
number of transformations and code

00:08:54,380 --> 00:08:58,430
analysis that we do on the JUnit test

00:08:56,690 --> 00:09:01,040
read in order to generate those new test

00:08:58,430 --> 00:09:03,590
cases so that's just an example of what

00:09:01,040 --> 00:09:05,750
the kind of prototypes we've been doing

00:09:03,590 --> 00:09:08,870
before the project starts so again it's

00:09:05,750 --> 00:09:10,550
a super news project in stamp what we

00:09:08,870 --> 00:09:12,710
aim at doing is doing this kind of

00:09:10,550 --> 00:09:15,950
amplification on unit test cases on

00:09:12,710 --> 00:09:19,550
configuration test on configuration test

00:09:15,950 --> 00:09:23,320
descriptions and on online testing we

00:09:19,550 --> 00:09:27,290
aim at providing all these amplification

00:09:23,320 --> 00:09:31,010
facilities as micro services and we aim

00:09:27,290 --> 00:09:34,490
at experimenting these test suite

00:09:31,010 --> 00:09:36,320
amplification technologies on several

00:09:34,490 --> 00:09:39,020
case studies which are provided by the

00:09:36,320 --> 00:09:41,360
by the different partners show atos is

00:09:39,020 --> 00:09:44,480
providing a case study in the area smart

00:09:41,360 --> 00:09:45,950
cities active ellen is providing a use

00:09:44,480 --> 00:09:50,180
case in the context of cloud computing

00:09:45,950 --> 00:09:54,410
we have a norwegian SME providing a use

00:09:50,180 --> 00:09:56,840
case in a health Oh w2 is coming with a

00:09:54,410 --> 00:09:58,370
number of projects which will experiment

00:09:56,840 --> 00:10:00,020
these technologies in the area of

00:09:58,370 --> 00:10:02,600
software quality and xvii key is

00:10:00,020 --> 00:10:06,260
providing the XP key or use case in the

00:10:02,600 --> 00:10:08,570
area of information management so as a

00:10:06,260 --> 00:10:10,310
conclusion as a stamp is going to is

00:10:08,570 --> 00:10:12,290
going to be a three-year project it will

00:10:10,310 --> 00:10:15,680
start on December first this year it

00:10:12,290 --> 00:10:18,200
gathers 9u partners it's meant to be a

00:10:15,680 --> 00:10:19,940
fully open source and we have a w2 from

00:10:18,200 --> 00:10:22,010
day one so hopefully we will not wait

00:10:19,940 --> 00:10:25,820
the last week of the project to deliver

00:10:22,010 --> 00:10:27,170
something I'm github and and this is it

00:10:25,820 --> 00:10:31,060
this is what I have to say for the

00:10:27,170 --> 00:10:31,060

YouTube URL: https://www.youtube.com/watch?v=zlT1KIaAOeU


