Title: OW2con'16 Keynote: Kubernetes: the Rising Tide of Systems Administration.
Publication date: 2016-09-28
Playlist: OW2con 2016
Description: 
	Kubernetes, the rising tide of systems administration Containers and cloud have moved from "why" to "how and when?" Learn how Google is helping the world go Cloud Native.
Captions: 
	00:00:05,120 --> 00:00:10,679
okay thank you all very much for coming

00:00:07,740 --> 00:00:13,139
here today just first of all a little

00:00:10,679 --> 00:00:15,120
bit about myself and why I'm here so I

00:00:13,139 --> 00:00:18,449
am Craig box that's my Twitter handle

00:00:15,120 --> 00:00:20,010
I'd love to hear from you all I work on

00:00:18,449 --> 00:00:22,410
the Google cloud platform which is

00:00:20,010 --> 00:00:23,910
Google's Project to externalize the

00:00:22,410 --> 00:00:25,619
infrastructure we have and make it

00:00:23,910 --> 00:00:27,090
available so that everyone can run their

00:00:25,619 --> 00:00:30,720
business on the same infrastructure that

00:00:27,090 --> 00:00:32,880
we do I'm based in London I've come here

00:00:30,720 --> 00:00:34,500
this morning just literally running on

00:00:32,880 --> 00:00:36,480
the trains I'm sorry that hidden

00:00:34,500 --> 00:00:38,280
denounced that so I was here but I'm

00:00:36,480 --> 00:00:39,600
originally from New Zealand and so

00:00:38,280 --> 00:00:45,480
there's a picture of me outside my house

00:00:39,600 --> 00:00:47,730
in New Zealand so in this audience

00:00:45,480 --> 00:00:50,309
especially but to everyone i think it's

00:00:47,730 --> 00:00:52,949
it's neither unpopular nor untrue to say

00:00:50,309 --> 00:00:54,690
that open has one and they say we've

00:00:52,949 --> 00:00:58,020
gone from a world where we see open

00:00:54,690 --> 00:00:59,640
sources of cancer in under 10 years we

00:00:58,020 --> 00:01:03,090
now see this chart was published a few

00:00:59,640 --> 00:01:05,040
days ago and actually if you combine the

00:01:03,090 --> 00:01:06,180
google and the angular organizations you

00:01:05,040 --> 00:01:07,530
will see that they would be number one

00:01:06,180 --> 00:01:09,780
on that chart but for some reason they

00:01:07,530 --> 00:01:11,729
didn't do that and this isn't just

00:01:09,780 --> 00:01:15,330
altruism obviously this is good business

00:01:11,729 --> 00:01:16,950
because money is now made in hosting so

00:01:15,330 --> 00:01:18,570
Joel Spassky who used to work with

00:01:16,950 --> 00:01:20,820
Microsoft has always said that you can

00:01:18,570 --> 00:01:22,770
monetize your compliments economic terms

00:01:20,820 --> 00:01:25,560
a Microsoft are becoming a services

00:01:22,770 --> 00:01:27,900
business and software is the complement

00:01:25,560 --> 00:01:30,000
to hosting so the more software that

00:01:27,900 --> 00:01:31,710
they or other people give away then the

00:01:30,000 --> 00:01:36,000
more hosting services that they or other

00:01:31,710 --> 00:01:37,979
people can sell so let's turn the clock

00:01:36,000 --> 00:01:39,900
back a little bit and see how we got

00:01:37,979 --> 00:01:43,140
here so we're going to consider an

00:01:39,900 --> 00:01:45,299
average startup from 20 years ago here's

00:01:43,140 --> 00:01:48,869
one it's called google I hope they do

00:01:45,299 --> 00:01:50,579
well in the middle there you'll see what

00:01:48,869 --> 00:01:53,040
Google looked like before it was

00:01:50,579 --> 00:01:56,189
incorporated as a company so in the

00:01:53,040 --> 00:01:57,990
early days once it was incorporated we

00:01:56,189 --> 00:02:00,180
moved to a slightly better hardware but

00:01:57,990 --> 00:02:02,520
we didn't even have the money to pay for

00:02:00,180 --> 00:02:04,710
things like cases so we just build

00:02:02,520 --> 00:02:07,290
computers on cork boards and put them on

00:02:04,710 --> 00:02:08,700
the rack in that situation there's no

00:02:07,290 --> 00:02:11,129
way that you can afford to pay for

00:02:08,700 --> 00:02:13,590
proprietary software and still gable the

00:02:11,129 --> 00:02:15,510
bootstrap your company

00:02:13,590 --> 00:02:17,700
so this startup has two simple things

00:02:15,510 --> 00:02:19,680
that it wants to do it wants to download

00:02:17,700 --> 00:02:21,330
everything on the internet and then it

00:02:19,680 --> 00:02:24,660
wants to analyze it over and over again

00:02:21,330 --> 00:02:27,030
that shouldn't be too hard 99 th of it

00:02:24,660 --> 00:02:28,440
well well they weren't based around

00:02:27,030 --> 00:02:29,849
Stanford so they could have called up

00:02:28,440 --> 00:02:31,620
son and said will like the biggest

00:02:29,849 --> 00:02:32,940
computer that you have we want to

00:02:31,620 --> 00:02:35,310
computer big enough to put the internet

00:02:32,940 --> 00:02:37,019
on well the internet wasn't that big

00:02:35,310 --> 00:02:38,849
these days but it still wouldn't have

00:02:37,019 --> 00:02:40,530
been possible if you remember the

00:02:38,849 --> 00:02:43,440
AltaVista search engine that was

00:02:40,530 --> 00:02:45,360
actually a demo to sell DC's computers

00:02:43,440 --> 00:02:47,040
that was what they used is the demo and

00:02:45,360 --> 00:02:48,540
DC don't make computers anymore but

00:02:47,040 --> 00:02:49,560
Yahoo stolen business so think about

00:02:48,540 --> 00:02:52,560
that in terms of the relationship

00:02:49,560 --> 00:02:53,640
between software and hardware another

00:02:52,560 --> 00:02:56,250
way to look at it through the pop

00:02:53,640 --> 00:03:02,370
culture lens of 2002 the internet was

00:02:56,250 --> 00:03:05,040
still pretty big even back then so we

00:03:02,370 --> 00:03:06,780
took ideas from all over the academic

00:03:05,040 --> 00:03:09,299
community to come up with a method for

00:03:06,780 --> 00:03:11,849
doing parallel processing across all of

00:03:09,299 --> 00:03:14,579
these cheap computers we call the

00:03:11,849 --> 00:03:16,170
MapReduce and Google came from the

00:03:14,579 --> 00:03:17,880
background of computer science so we

00:03:16,170 --> 00:03:19,530
published an academic paper that

00:03:17,880 --> 00:03:21,450
suggests this is the method that we've

00:03:19,530 --> 00:03:24,540
come up with to be able to parallel eyes

00:03:21,450 --> 00:03:27,060
build a distributed system to index the

00:03:24,540 --> 00:03:30,150
internet and then in order to store it

00:03:27,060 --> 00:03:31,769
we also needed a file system so we came

00:03:30,150 --> 00:03:35,489
up with the Google file system and again

00:03:31,769 --> 00:03:37,769
published a paper on that what happened

00:03:35,489 --> 00:03:39,540
was somebody took those papers and said

00:03:37,769 --> 00:03:41,099
that's fantastic I'd like one of those

00:03:39,540 --> 00:03:42,690
and then they built their own

00:03:41,099 --> 00:03:45,150
implementation and they made that

00:03:42,690 --> 00:03:46,709
available open source and that was Doug

00:03:45,150 --> 00:03:49,739
cutting who was working at Yahoo at the

00:03:46,709 --> 00:03:52,139
time and we ended up with a divergence

00:03:49,739 --> 00:03:54,209
so we have an internal system at Google

00:03:52,139 --> 00:03:56,700
that's written in C++ and it's very very

00:03:54,209 --> 00:03:58,919
fast and then the rest of the industry

00:03:56,700 --> 00:04:01,290
will they get the Java implementation of

00:03:58,919 --> 00:04:02,489
it so what are you going to do and we'll

00:04:01,290 --> 00:04:06,630
come back to that story a little bit

00:04:02,489 --> 00:04:08,819
later now Google very quickly became

00:04:06,630 --> 00:04:11,760
famous for its 10 blue links that load

00:04:08,819 --> 00:04:14,280
very very quickly what we had to do is

00:04:11,760 --> 00:04:16,859
we have to serve their index very very

00:04:14,280 --> 00:04:18,299
quickly but in the meantime we needed to

00:04:16,859 --> 00:04:20,400
build it we needed to constantly be

00:04:18,299 --> 00:04:21,060
going and downloading and processing

00:04:20,400 --> 00:04:23,790
that

00:04:21,060 --> 00:04:25,919
and what we did was we had two separate

00:04:23,790 --> 00:04:27,540
pools of machines we wanted to be able

00:04:25,919 --> 00:04:29,850
to serve very quickly so we'd have a

00:04:27,540 --> 00:04:31,169
serving pool but then overnight when

00:04:29,850 --> 00:04:32,760
people aren't searching for anything

00:04:31,169 --> 00:04:36,060
those machines are sitting around and

00:04:32,760 --> 00:04:38,190
they're not doing anything but the good

00:04:36,060 --> 00:04:40,350
news is that if someone wants to run a

00:04:38,190 --> 00:04:42,270
MapReduce in some intern for example

00:04:40,350 --> 00:04:44,790
they can't use up all over the servers

00:04:42,270 --> 00:04:46,440
that are hosting google com by mistake

00:04:44,790 --> 00:04:48,300
because everyone gets a lot of it or

00:04:46,440 --> 00:04:53,190
timing inside they could quite easily

00:04:48,300 --> 00:04:56,729
use up all the CPU quote there's the

00:04:53,190 --> 00:04:59,340
second task there we had two different

00:04:56,729 --> 00:05:02,070
systems to manage those two different

00:04:59,340 --> 00:05:04,169
things you could do for the real-time

00:05:02,070 --> 00:05:06,180
work we basically just wanted to say so

00:05:04,169 --> 00:05:07,889
and then if the serving process goes

00:05:06,180 --> 00:05:09,600
down and start it back up again it's all

00:05:07,889 --> 00:05:12,870
it should be doing and that was called

00:05:09,600 --> 00:05:14,610
babysitting and in order to run all the

00:05:12,870 --> 00:05:15,900
MapReduce tasks and all the batch work

00:05:14,610 --> 00:05:17,639
we came up with a system called the

00:05:15,900 --> 00:05:19,500
global work queue which is the allocate

00:05:17,639 --> 00:05:20,940
workout two machines ask it to happen

00:05:19,500 --> 00:05:23,970
and then bring it back in again at the

00:05:20,940 --> 00:05:26,370
end and ultimately we wanted to be able

00:05:23,970 --> 00:05:28,260
to say well we want to run up all of our

00:05:26,370 --> 00:05:29,910
machines is one big pool and then

00:05:28,260 --> 00:05:32,460
allocate work to them as and when it

00:05:29,910 --> 00:05:34,380
makes sense but we've got the use case

00:05:32,460 --> 00:05:36,360
where the intern says I want all the CPU

00:05:34,380 --> 00:05:38,940
resources and runs away with it then you

00:05:36,360 --> 00:05:40,650
can't do your serving so we needed a way

00:05:38,940 --> 00:05:42,330
to guarantee that the more important

00:05:40,650 --> 00:05:44,669
tasks which of course are the ones that

00:05:42,330 --> 00:05:47,789
make money other ones that would get the

00:05:44,669 --> 00:05:50,430
resources so our engineers came up with

00:05:47,789 --> 00:05:53,070
a feature which was developed in the

00:05:50,430 --> 00:05:54,360
upstream Linux kernel was originally

00:05:53,070 --> 00:05:56,190
called process containers but then

00:05:54,360 --> 00:06:00,210
became known as control groups or C

00:05:56,190 --> 00:06:01,770
groups this was released in 2006 and

00:06:00,210 --> 00:06:04,110
it's a facility to basically take a

00:06:01,770 --> 00:06:06,090
process and say this is a guaranteed

00:06:04,110 --> 00:06:08,910
priority it's going to get up to this

00:06:06,090 --> 00:06:10,680
limit but no more and then lets us start

00:06:08,910 --> 00:06:13,470
packing these things together lets us

00:06:10,680 --> 00:06:15,150
say we can give guarantee priority to

00:06:13,470 --> 00:06:18,650
the serving tasks and anything that's

00:06:15,150 --> 00:06:21,300
left over we can give to batch the

00:06:18,650 --> 00:06:23,850
system we came up with is what we still

00:06:21,300 --> 00:06:25,500
use today it's internally known as Borg

00:06:23,850 --> 00:06:27,630
and put that in quotes is for a long

00:06:25,500 --> 00:06:30,479
time it was very top secret was the

00:06:27,630 --> 00:06:31,700
efficiency it was the secret source that

00:06:30,479 --> 00:06:33,560
made the company more

00:06:31,700 --> 00:06:35,120
and competitors and there's no way that

00:06:33,560 --> 00:06:37,670
whatever open source that's the thing

00:06:35,120 --> 00:06:40,400
that it's very special for example we've

00:06:37,670 --> 00:06:42,740
estimated over the time that the system

00:06:40,400 --> 00:06:45,500
of packing batch and serving workloads

00:06:42,740 --> 00:06:47,180
on the same machines if you wanted to

00:06:45,500 --> 00:06:48,800
separate them out today in two different

00:06:47,180 --> 00:06:50,600
clusters you'd need twenty-five percent

00:06:48,800 --> 00:06:52,220
more machines or another way of looking

00:06:50,600 --> 00:06:53,960
at it it saved us the cost of building

00:06:52,220 --> 00:06:56,120
an entire data center which cost

00:06:53,960 --> 00:07:00,970
multiple billions of dollars over the

00:06:56,120 --> 00:07:04,040
course of lifetime so we didn't want to

00:07:00,970 --> 00:07:05,660
to let other people have that same

00:07:04,040 --> 00:07:07,070
advantage who are running similar kind

00:07:05,660 --> 00:07:09,710
of companies but we still wanted to

00:07:07,070 --> 00:07:11,510
contribute in the academic space so the

00:07:09,710 --> 00:07:13,700
first thing we did is we wrote a book we

00:07:11,510 --> 00:07:16,280
wrote a book on warehouse scale machines

00:07:13,700 --> 00:07:20,660
and if you ask me to summarize this book

00:07:16,280 --> 00:07:24,140
in one sentence it would be this a data

00:07:20,660 --> 00:07:25,490
center isn't a collection of computers

00:07:24,140 --> 00:07:27,230
or it can't be thought of as a

00:07:25,490 --> 00:07:29,650
collection of computers you need to

00:07:27,230 --> 00:07:31,940
address it as a single computer and

00:07:29,650 --> 00:07:33,710
again if you think back 20 years ago

00:07:31,940 --> 00:07:35,990
perhaps the system administrator could

00:07:33,710 --> 00:07:38,660
look after the hundred computers perhaps

00:07:35,990 --> 00:07:39,800
and if you wanted to scale to however

00:07:38,660 --> 00:07:41,060
many there might be in that picture

00:07:39,800 --> 00:07:46,340
you're going to need to hire a lot of

00:07:41,060 --> 00:07:48,740
very expensive humans so the warehouse

00:07:46,340 --> 00:07:50,570
scale we've created this big distributed

00:07:48,740 --> 00:07:52,340
system we want to manage it with as few

00:07:50,570 --> 00:07:54,440
people as possible and then we think

00:07:52,340 --> 00:07:58,760
what kind of applications will run on

00:07:54,440 --> 00:07:59,810
this and then we get to what we start

00:07:58,760 --> 00:08:02,750
thinking of now is the application

00:07:59,810 --> 00:08:05,270
container for anyone who's not familiar

00:08:02,750 --> 00:08:07,220
it's very similar concept to apps on the

00:08:05,270 --> 00:08:09,380
model phone so apps are self-contained

00:08:07,220 --> 00:08:11,690
they come as a bundle that you install

00:08:09,380 --> 00:08:13,430
together they start up very quickly if

00:08:11,690 --> 00:08:14,840
they crash they don't take out

00:08:13,430 --> 00:08:17,450
everything else on the system because

00:08:14,840 --> 00:08:19,430
they're sandboxed that's a roughly what

00:08:17,450 --> 00:08:21,350
an application container is it's a way

00:08:19,430 --> 00:08:23,390
of raising the abstraction level so that

00:08:21,350 --> 00:08:25,790
instead of getting an idealized piece of

00:08:23,390 --> 00:08:27,650
hardware which is a virtual machine you

00:08:25,790 --> 00:08:31,419
can idealized operating system and you

00:08:27,650 --> 00:08:33,530
can take your code and run it on that in

00:08:31,419 --> 00:08:34,729
effect there are lightweight Linux

00:08:33,530 --> 00:08:36,140
environment there are containers

00:08:34,729 --> 00:08:37,880
available for other operating systems

00:08:36,140 --> 00:08:43,250
but we generally were talking about

00:08:37,880 --> 00:08:44,180
Linux we say that they're hermetically

00:08:43,250 --> 00:08:46,250
sealed in the

00:08:44,180 --> 00:08:47,870
available so you copy the file on it

00:08:46,250 --> 00:08:51,790
either worked or it didn't and then you

00:08:47,870 --> 00:08:53,690
can run that very easily copying a file

00:08:51,790 --> 00:08:55,220
validating it and then if it doesn't

00:08:53,690 --> 00:08:57,740
work you roll back you just run the

00:08:55,220 --> 00:09:03,350
original file that you had there because

00:08:57,740 --> 00:09:05,480
everything's packed in together and very

00:09:03,350 --> 00:09:08,149
importantly also it's introspect abul

00:09:05,480 --> 00:09:10,100
and the artifact itself is runnable if

00:09:08,149 --> 00:09:12,860
you think of a virtual machine

00:09:10,100 --> 00:09:14,899
environment you can't ask this the

00:09:12,860 --> 00:09:16,339
hypervisor what's my machine doing and

00:09:14,899 --> 00:09:17,690
then make decisions based on that

00:09:16,339 --> 00:09:20,240
because as far as it knows well it's

00:09:17,690 --> 00:09:21,980
just executing instructions in this case

00:09:20,240 --> 00:09:24,500
you can ask the colonel that's running

00:09:21,980 --> 00:09:27,140
these processes information about what's

00:09:24,500 --> 00:09:29,120
running and then that get you the

00:09:27,140 --> 00:09:30,620
opportunity to make decisions about well

00:09:29,120 --> 00:09:32,330
where the things run do we want to move

00:09:30,620 --> 00:09:34,940
them around inside a cluster of machines

00:09:32,330 --> 00:09:38,450
and so on it really raises that level of

00:09:34,940 --> 00:09:40,820
abstraction and what containers allowed

00:09:38,450 --> 00:09:42,620
us to do a number of things we talked

00:09:40,820 --> 00:09:44,420
about the batch versus interactive case

00:09:42,620 --> 00:09:46,279
but we can start doing things like

00:09:44,420 --> 00:09:48,110
over-committing we can pack more work on

00:09:46,279 --> 00:09:50,690
to a machine that it can do knowing that

00:09:48,110 --> 00:09:52,160
people are going to try and they're

00:09:50,690 --> 00:09:53,660
going to say I need this much resource

00:09:52,160 --> 00:09:56,240
but they're only going to use this much

00:09:53,660 --> 00:09:57,950
for example we get predictability we

00:09:56,240 --> 00:09:59,959
know that if we run a certain number of

00:09:57,950 --> 00:10:01,520
processes on a machine that we're going

00:09:59,959 --> 00:10:03,050
to get the same performance out of there

00:10:01,520 --> 00:10:05,839
as if we run the same on a different

00:10:03,050 --> 00:10:07,790
machine you probably have service as

00:10:05,839 --> 00:10:09,410
well like a lot of when people started

00:10:07,790 --> 00:10:10,640
using other cloud providers there was

00:10:09,410 --> 00:10:12,620
what they called the noisy neighbor

00:10:10,640 --> 00:10:14,120
problem where if you had someone else

00:10:12,620 --> 00:10:16,820
who was running on your machine who was

00:10:14,120 --> 00:10:18,380
doing intense use of the CPU you

00:10:16,820 --> 00:10:20,779
wouldn't get as much as you but patch

00:10:18,380 --> 00:10:24,920
wanted so containers are a way of being

00:10:20,779 --> 00:10:27,320
able to prevent that so we went from

00:10:24,920 --> 00:10:29,510
this world where we had server

00:10:27,320 --> 00:10:31,130
administration in the physical and

00:10:29,510 --> 00:10:32,870
virtual machine world which is very much

00:10:31,130 --> 00:10:34,850
about administrating each machine

00:10:32,870 --> 00:10:38,089
individually you talk about the metaphor

00:10:34,850 --> 00:10:42,860
of flying the plane versus moving from

00:10:38,089 --> 00:10:44,630
that imperative model to declarative

00:10:42,860 --> 00:10:46,940
where we say well we declare the state

00:10:44,630 --> 00:10:50,089
that we want we program the autopilot we

00:10:46,940 --> 00:10:52,220
say we want there to be enough processes

00:10:50,089 --> 00:10:54,230
running so we can serve search or we can

00:10:52,220 --> 00:10:56,209
serve gmail or whatever your application

00:10:54,230 --> 00:10:59,569
may be

00:10:56,209 --> 00:11:00,860
and then let the system reconcile that

00:10:59,569 --> 00:11:02,569
we don't have to worry about well if

00:11:00,860 --> 00:11:04,279
individual machines fail for so on we

00:11:02,569 --> 00:11:07,100
don't have to go and we react them at

00:11:04,279 --> 00:11:09,379
the time it's very much about the system

00:11:07,100 --> 00:11:12,949
the controllers sorting this out in what

00:11:09,379 --> 00:11:14,600
we call a reconciliation loop so it

00:11:12,949 --> 00:11:16,759
gives us a few great advantages we get

00:11:14,600 --> 00:11:18,769
the efficiency we can pack more things

00:11:16,759 --> 00:11:22,309
onto a smaller number of machines and we

00:11:18,769 --> 00:11:24,050
can cut those costs we're a bit of

00:11:22,309 --> 00:11:25,579
performance because we can actively tune

00:11:24,050 --> 00:11:27,319
the environment we can look at say

00:11:25,579 --> 00:11:29,119
things well if it turns out that because

00:11:27,319 --> 00:11:30,619
of the way they use the cash on the cpu

00:11:29,119 --> 00:11:32,600
for example certain things don't well

00:11:30,619 --> 00:11:36,470
run well together on same machines they

00:11:32,600 --> 00:11:38,749
can be picked up and moved elsewhere it

00:11:36,470 --> 00:11:40,100
lets you tie into now this is AP I'd

00:11:38,749 --> 00:11:41,839
room and you can tie in things like

00:11:40,100 --> 00:11:43,699
continuous integration you can make sure

00:11:41,839 --> 00:11:45,709
that once you've done builds that they

00:11:43,699 --> 00:11:49,490
are deployed very quickly or you can use

00:11:45,709 --> 00:11:51,199
any time you want to push code very

00:11:49,490 --> 00:11:53,029
quickly build that and deploy inside

00:11:51,199 --> 00:11:55,540
your cluster with that fast roll back as

00:11:53,029 --> 00:11:58,459
we talked about if it doesn't work and

00:11:55,540 --> 00:12:00,740
as part of the the we talked about

00:11:58,459 --> 00:12:02,540
efficiency we now can say all right well

00:12:00,740 --> 00:12:04,549
if it turns out that it's not delivering

00:12:02,540 --> 00:12:06,049
what we want if something crashes if an

00:12:04,549 --> 00:12:07,850
application crashes or if a machine

00:12:06,049 --> 00:12:09,470
running an application we get that

00:12:07,850 --> 00:12:12,079
robustness because the system knows

00:12:09,470 --> 00:12:13,339
you've seen what I want is an end state

00:12:12,079 --> 00:12:17,240
and that knows that can get to that

00:12:13,339 --> 00:12:19,519
point so here's a statistic that we

00:12:17,240 --> 00:12:21,049
always put up in slides it's mostly

00:12:19,519 --> 00:12:22,490
meaningless but it just gives you an

00:12:21,049 --> 00:12:25,699
idea that this is something that we've

00:12:22,490 --> 00:12:28,519
been doing at scale for a long time but

00:12:25,699 --> 00:12:30,290
again it was very secret source and so

00:12:28,519 --> 00:12:32,600
much so that it took until we actually

00:12:30,290 --> 00:12:34,189
built a second system internally before

00:12:32,600 --> 00:12:36,829
we started talking about the were

00:12:34,189 --> 00:12:39,649
doing anything about this at all a few

00:12:36,829 --> 00:12:41,269
years ago we published a paper on the

00:12:39,649 --> 00:12:44,240
system we called Omega which was a

00:12:41,269 --> 00:12:46,639
better scheduling system for container

00:12:44,240 --> 00:12:48,499
work but even at that time we didn't

00:12:46,639 --> 00:12:50,420
even use the B word and public it was

00:12:48,499 --> 00:12:51,499
very very secret an internal we

00:12:50,420 --> 00:12:54,920
definitely didn't publish an

00:12:51,499 --> 00:12:56,629
implementation what i will do though is

00:12:54,920 --> 00:12:58,399
show you here's a picture roughly of

00:12:56,629 --> 00:12:59,990
what it looked like internally see is a

00:12:58,399 --> 00:13:03,259
small architecture diagram its

00:12:59,990 --> 00:13:05,540
high-level basically a google developer

00:13:03,259 --> 00:13:07,699
will configure that they'll build a

00:13:05,540 --> 00:13:09,439
binary and they'll say here's the

00:13:07,699 --> 00:13:10,350
configuration i want of how many of

00:13:09,439 --> 00:13:12,360
these run and so

00:13:10,350 --> 00:13:15,690
and then they send that to a master

00:13:12,360 --> 00:13:18,330
which maintains that state provides a

00:13:15,690 --> 00:13:20,460
nice management measurement monitoring

00:13:18,330 --> 00:13:21,750
you eyes and so on and then a scheduler

00:13:20,460 --> 00:13:24,000
will continually go and look and say

00:13:21,750 --> 00:13:25,440
well I've been asked to have a thousand

00:13:24,000 --> 00:13:27,480
copies of this are all my machines

00:13:25,440 --> 00:13:29,550
running do I have a thousand copies and

00:13:27,480 --> 00:13:30,960
then it will instruct an agent the runs

00:13:29,550 --> 00:13:34,440
in each of the machines and the cluster

00:13:30,960 --> 00:13:37,980
to go and run that again that will come

00:13:34,440 --> 00:13:39,870
back to this later now there were people

00:13:37,980 --> 00:13:41,550
who worked at Google who went and worked

00:13:39,870 --> 00:13:44,520
other companies the people who in turn

00:13:41,550 --> 00:13:46,680
to Google and a lot of people would say

00:13:44,520 --> 00:13:48,660
for example are I really miss what I had

00:13:46,680 --> 00:13:51,210
running on Borg I want to run this

00:13:48,660 --> 00:13:52,590
somewhere else and there was a few

00:13:51,210 --> 00:13:54,480
people in particular who working at

00:13:52,590 --> 00:13:56,430
Twitter they said the same kind of thing

00:13:54,480 --> 00:13:59,100
I said I really missed this and there

00:13:56,430 --> 00:14:01,710
was a talk from a guy who was working on

00:13:59,100 --> 00:14:03,090
a team at UC Berkeley who'd built a very

00:14:01,710 --> 00:14:04,740
similar system and they thought all

00:14:03,090 --> 00:14:06,150
right well we can see a way that we can

00:14:04,740 --> 00:14:07,830
turn what you've built in this academic

00:14:06,150 --> 00:14:10,740
sense into something that's a bit like

00:14:07,830 --> 00:14:13,650
bought it was effectively what Apache

00:14:10,740 --> 00:14:15,990
may sauces it's an ideas implementation

00:14:13,650 --> 00:14:18,000
they built on clustering technology from

00:14:15,990 --> 00:14:19,860
a few years ago bringing it back into

00:14:18,000 --> 00:14:21,600
the space where you can run various is

00:14:19,860 --> 00:14:25,890
positioning more data workloads onto it

00:14:21,600 --> 00:14:28,440
now around about the same time we

00:14:25,890 --> 00:14:31,560
launched our hosted vm product Google

00:14:28,440 --> 00:14:34,140
compute engine this is in 2012 it's VMs

00:14:31,560 --> 00:14:36,330
and they run inside containers on top of

00:14:34,140 --> 00:14:38,940
our board platform people started using

00:14:36,330 --> 00:14:40,320
it it's fantastic and say we're telling

00:14:38,940 --> 00:14:42,450
lots of these things so we'd go to our

00:14:40,320 --> 00:14:44,700
capacity team inside and say we need

00:14:42,450 --> 00:14:47,040
more capacity for the compute engine

00:14:44,700 --> 00:14:49,260
product because people are buying all

00:14:47,040 --> 00:14:50,490
these sea views and then they've come

00:14:49,260 --> 00:14:52,440
back and look at us and say we'll hang

00:14:50,490 --> 00:14:54,390
on you said you've sold all this CPUs

00:14:52,440 --> 00:14:57,420
but they're only really load utilization

00:14:54,390 --> 00:14:59,700
five ten twenty percent or something so

00:14:57,420 --> 00:15:01,170
well why is that well I google workloads

00:14:59,700 --> 00:15:03,210
design said that you asked for exactly

00:15:01,170 --> 00:15:05,430
what you want a new packet it but when

00:15:03,210 --> 00:15:07,470
you sell a vm to someone you just give

00:15:05,430 --> 00:15:09,720
them the CPU and then they only pack a

00:15:07,470 --> 00:15:11,220
small amount of work on to it so we now

00:15:09,720 --> 00:15:13,950
have the same problem in the customer

00:15:11,220 --> 00:15:16,890
space we have the advantages of all the

00:15:13,950 --> 00:15:19,220
scheduling and packing work but our

00:15:16,890 --> 00:15:21,480
customers weren't taking advantage of it

00:15:19,220 --> 00:15:22,769
something else happened again around the

00:15:21,480 --> 00:15:25,559
same time we

00:15:22,769 --> 00:15:27,329
that someone had developed a pretty face

00:15:25,559 --> 00:15:29,819
that says sat on top of the container

00:15:27,329 --> 00:15:31,980
technology which was still in the kernel

00:15:29,819 --> 00:15:34,110
as Alex see for example see groups and

00:15:31,980 --> 00:15:36,269
put real nice face on this kind of stuff

00:15:34,110 --> 00:15:37,769
and this is of course docker which

00:15:36,269 --> 00:15:42,209
actually started the french company

00:15:37,769 --> 00:15:45,089
called doc cloud which brings us back to

00:15:42,209 --> 00:15:47,819
Hadoop from before we'd built this

00:15:45,089 --> 00:15:49,589
wonderful system internally but what the

00:15:47,819 --> 00:15:51,600
community was using was the open-source

00:15:49,589 --> 00:15:54,569
clone or copy that was built somewhere

00:15:51,600 --> 00:15:56,699
else and now we're starting as a company

00:15:54,569 --> 00:15:58,649
to sell services to people and sell

00:15:56,699 --> 00:16:02,639
cloud things we don't really want to

00:15:58,649 --> 00:16:05,189
make the same mistake again after we

00:16:02,639 --> 00:16:06,869
published the MapReduce paper we also

00:16:05,189 --> 00:16:08,399
published a paper on a thing called big

00:16:06,869 --> 00:16:10,709
table which is our internal and no

00:16:08,399 --> 00:16:12,059
sequel database store and again people

00:16:10,709 --> 00:16:13,739
in the Hadoop community built an

00:16:12,059 --> 00:16:17,249
implementation of that that's called

00:16:13,739 --> 00:16:19,139
Apache HBase and what we want to do now

00:16:17,249 --> 00:16:20,910
is a couple years back and say we want

00:16:19,139 --> 00:16:22,139
to sell big table as a service we're

00:16:20,910 --> 00:16:24,839
going to make this a cloud service that

00:16:22,139 --> 00:16:26,699
people can buy but because this is a

00:16:24,839 --> 00:16:28,199
proprietary thing that only Google run

00:16:26,699 --> 00:16:29,730
we don't want people to feel locked into

00:16:28,199 --> 00:16:32,220
it and we came up with an interesting

00:16:29,730 --> 00:16:34,670
solution so what we do is we expose the

00:16:32,220 --> 00:16:38,970
original internal big table service

00:16:34,670 --> 00:16:41,069
using the HBase API so you can use it on

00:16:38,970 --> 00:16:43,110
our cloud and if you know if you want to

00:16:41,069 --> 00:16:45,540
move somewhere else you can run the

00:16:43,110 --> 00:16:46,889
other implementation of it it's an

00:16:45,540 --> 00:16:48,569
interesting lesson there because you can

00:16:46,889 --> 00:16:50,519
differentiate on an implementation of

00:16:48,569 --> 00:16:53,670
something as long as the interface that

00:16:50,519 --> 00:16:54,869
you use is open but given that we

00:16:53,670 --> 00:16:57,059
actually wanted to go a step further

00:16:54,869 --> 00:17:00,329
this time and that's where we got to

00:16:57,059 --> 00:17:03,139
kooban edits we released cubanelle is as

00:17:00,329 --> 00:17:08,100
an open source project in public on jun

00:17:03,139 --> 00:17:10,709
2014 why did we do this well distributed

00:17:08,100 --> 00:17:12,029
systems are still very hard if you've

00:17:10,709 --> 00:17:13,649
ever tried to work with them you know

00:17:12,029 --> 00:17:15,809
you start dealing with non-atomic

00:17:13,649 --> 00:17:17,339
transactions partial availability and

00:17:15,809 --> 00:17:18,809
things there's a whole other things you

00:17:17,339 --> 00:17:20,909
have to worry about in your application

00:17:18,809 --> 00:17:24,139
without re-implementing service

00:17:20,909 --> 00:17:26,189
discoveries re-implementing the wheel

00:17:24,139 --> 00:17:28,260
Tsukuba neighs is a toolkit which

00:17:26,189 --> 00:17:30,899
abstracts all of this away for you it

00:17:28,260 --> 00:17:32,580
builds on the patterns of Borg and Omega

00:17:30,899 --> 00:17:34,380
and it has a lot of the same engineers

00:17:32,580 --> 00:17:34,710
who built those two systems working on

00:17:34,380 --> 00:17:36,360
it

00:17:34,710 --> 00:17:38,669
but it doesn't make all the same

00:17:36,360 --> 00:17:40,350
mistakes it's written in the modern

00:17:38,669 --> 00:17:42,630
language so it's much easier to hack on

00:17:40,350 --> 00:17:44,070
and ultimately we want to make it as

00:17:42,630 --> 00:17:46,020
easy to build a distributed system

00:17:44,070 --> 00:17:47,850
something that can run in a cloud

00:17:46,020 --> 00:17:50,070
provider that has these potential

00:17:47,850 --> 00:17:51,990
failures as it is to write hello world

00:17:50,070 --> 00:17:56,210
and your introductory computer science

00:17:51,990 --> 00:17:59,309
class here's a little bit about cabanas

00:17:56,210 --> 00:18:00,779
it's a Greek word that means helmsman so

00:17:59,309 --> 00:18:04,289
you think of the pilot of a container

00:18:00,779 --> 00:18:06,179
ship which is a good metaphor very early

00:18:04,289 --> 00:18:08,190
on we talked about what are we going to

00:18:06,179 --> 00:18:10,260
run inside this and docker containers

00:18:08,190 --> 00:18:12,120
had the open mind share people were out

00:18:10,260 --> 00:18:14,460
there using this technology and Stein to

00:18:12,120 --> 00:18:16,140
build on it and we didn't we actually

00:18:14,460 --> 00:18:17,760
open sourced our own internal container

00:18:16,140 --> 00:18:20,340
driver but then we saw will dock is

00:18:17,760 --> 00:18:21,929
taking off we we rolled the interesting

00:18:20,340 --> 00:18:24,990
things from that entered their lib

00:18:21,929 --> 00:18:28,529
container project because you need to be

00:18:24,990 --> 00:18:30,600
where people are you need to be to win

00:18:28,529 --> 00:18:31,919
their business you need to adopt the

00:18:30,600 --> 00:18:33,750
things that they're using and then help

00:18:31,919 --> 00:18:36,419
guide them in a direction which is it an

00:18:33,750 --> 00:18:38,610
advantage we also now support other

00:18:36,419 --> 00:18:40,110
container technologies company chorus

00:18:38,610 --> 00:18:41,159
who've built an engine called rocket and

00:18:40,110 --> 00:18:44,610
they've built an open specification

00:18:41,159 --> 00:18:48,720
called app see use them and we start to

00:18:44,610 --> 00:18:49,950
see other implementations as well from

00:18:48,720 --> 00:18:52,049
the beginning we wanted this to be

00:18:49,950 --> 00:18:54,390
something that supported multiple cloud

00:18:52,049 --> 00:18:56,490
and bare metal environments this is we

00:18:54,390 --> 00:18:58,799
want it to be as an API that use on

00:18:56,490 --> 00:19:00,419
whatever environment you run and again

00:18:58,799 --> 00:19:02,450
it gives you that portability to run a

00:19:00,419 --> 00:19:04,890
workload wherever you choose and

00:19:02,450 --> 00:19:07,740
alongside that we know that not everyone

00:19:04,890 --> 00:19:09,659
is going to build a cloud or a container

00:19:07,740 --> 00:19:11,580
application on day one need to be able

00:19:09,659 --> 00:19:13,500
to connect out to your other existing

00:19:11,580 --> 00:19:18,299
services other things cloud providers

00:19:13,500 --> 00:19:20,460
run it's informed by our internal

00:19:18,299 --> 00:19:21,659
experiences but open sourcing board

00:19:20,460 --> 00:19:23,490
wouldn't have done anybody any favors

00:19:21,659 --> 00:19:25,169
it's a 10 year old piece of spaghetti

00:19:23,490 --> 00:19:28,169
that's designed exactly the fitting our

00:19:25,169 --> 00:19:30,179
needs we wanted to build something that

00:19:28,169 --> 00:19:31,679
was written and go for example because

00:19:30,179 --> 00:19:33,210
it's the language that people working on

00:19:31,679 --> 00:19:36,149
things like docker and console and

00:19:33,210 --> 00:19:37,980
various other projects are using and we

00:19:36,149 --> 00:19:40,830
ultimately boiled down to we want to let

00:19:37,980 --> 00:19:43,549
the users manage applications rather

00:19:40,830 --> 00:19:43,549
than machines

00:19:43,860 --> 00:19:46,890
this is a high level architecture

00:19:44,820 --> 00:19:51,900
diagram for KU benetti's is it familiar

00:19:46,890 --> 00:19:54,120
at all these are all the things that you

00:19:51,900 --> 00:19:57,480
don't have to worry about if you're

00:19:54,120 --> 00:19:59,070
using cluster management so worrying

00:19:57,480 --> 00:20:02,490
about where container should run whether

00:19:59,070 --> 00:20:04,200
they're running despite failures taking

00:20:02,490 --> 00:20:05,910
a set of a service that runs with the

00:20:04,200 --> 00:20:07,490
set of containers making a bigger or

00:20:05,910 --> 00:20:10,080
smaller automatically if you want

00:20:07,490 --> 00:20:12,090
figuring out where containers are so one

00:20:10,080 --> 00:20:16,110
of the bigger lessons from the move from

00:20:12,090 --> 00:20:18,330
Borg to communities was that we did we

00:20:16,110 --> 00:20:21,570
would just allocate a port on the host

00:20:18,330 --> 00:20:23,250
machine in Borg so if you were a web

00:20:21,570 --> 00:20:24,419
service and you landed on the machine

00:20:23,250 --> 00:20:25,740
that had someone else running a web

00:20:24,419 --> 00:20:28,410
service you might not get port 80

00:20:25,740 --> 00:20:31,650
because that wasn't available to you so

00:20:28,410 --> 00:20:33,240
by giving each Cuba natives pod group of

00:20:31,650 --> 00:20:35,280
containers its own IP address you can

00:20:33,240 --> 00:20:36,780
guarantee that you're getting the port

00:20:35,280 --> 00:20:38,309
that you want and that for example lets

00:20:36,780 --> 00:20:42,049
you do quality of service inside your

00:20:38,309 --> 00:20:42,049
network because you control that space

00:20:42,350 --> 00:20:46,650
can distribute traffic run a load

00:20:45,000 --> 00:20:49,740
balancer across the sets of containers

00:20:46,650 --> 00:20:51,570
and tie into external load balances you

00:20:49,740 --> 00:20:53,070
need to be able to provide external

00:20:51,570 --> 00:20:55,530
storage outside of your cluster and

00:20:53,070 --> 00:20:59,040
connect that in attract what's happening

00:20:55,530 --> 00:21:02,600
to your containers and services and then

00:20:59,040 --> 00:21:02,600
to enter an attache for introspection

00:21:02,780 --> 00:21:07,740
finally control who can do things these

00:21:05,190 --> 00:21:09,059
are all services that come in the box

00:21:07,740 --> 00:21:10,860
and provide integration with other

00:21:09,059 --> 00:21:16,679
things you would otherwise have to build

00:21:10,860 --> 00:21:18,270
yourself alongside communities we came

00:21:16,679 --> 00:21:20,940
up with this concept we call cloud

00:21:18,270 --> 00:21:23,070
native and cloud native means

00:21:20,940 --> 00:21:25,620
dynamically scheduled applications

00:21:23,070 --> 00:21:27,660
container packaged micro services

00:21:25,620 --> 00:21:29,549
oriented and soku banaras is really one

00:21:27,660 --> 00:21:31,169
leg of that stool in order to be able to

00:21:29,549 --> 00:21:33,570
run these these things that will work

00:21:31,169 --> 00:21:39,799
well on cloud environments either public

00:21:33,570 --> 00:21:42,150
or private it's been GA since 2015 and

00:21:39,799 --> 00:21:46,290
we're about a week away from the next

00:21:42,150 --> 00:21:48,270
major release interestingly on behalf of

00:21:46,290 --> 00:21:50,610
the code in the project is now written

00:21:48,270 --> 00:21:52,020
by Google we've seen a lot of

00:21:50,610 --> 00:21:53,790
collaboration from other commercial open

00:21:52,020 --> 00:21:55,799
source vendors late Red Hat I've seen a

00:21:53,790 --> 00:21:59,320
lot of collaboration from

00:21:55,799 --> 00:22:02,200
community groups from colleges people

00:21:59,320 --> 00:22:04,870
doing the hacking on it internally but

00:22:02,200 --> 00:22:06,880
it is really a good example of something

00:22:04,870 --> 00:22:09,399
where we're still actively involved and

00:22:06,880 --> 00:22:11,289
contributing to it but we've a built a

00:22:09,399 --> 00:22:14,649
big open source ecosystem around the

00:22:11,289 --> 00:22:16,210
project and in order to make people

00:22:14,649 --> 00:22:17,740
understand that it's not just a google

00:22:16,210 --> 00:22:20,200
thing this is something we really want

00:22:17,740 --> 00:22:21,640
everybody to run a benefit we set up a

00:22:20,200 --> 00:22:24,250
foundation working with the Linux

00:22:21,640 --> 00:22:27,279
Foundation for cloud native computing

00:22:24,250 --> 00:22:29,169
and then we gave the copy rights and the

00:22:27,279 --> 00:22:31,360
trademarks and all the code to that

00:22:29,169 --> 00:22:37,809
foundation so it exists as a community

00:22:31,360 --> 00:22:39,549
thing outside of outside of Google it

00:22:37,809 --> 00:22:40,870
takes a lot of these lessons from people

00:22:39,549 --> 00:22:45,460
who are battle-hardened at running

00:22:40,870 --> 00:22:47,500
production systems it moves at the right

00:22:45,460 --> 00:22:50,320
place and there's very important things

00:22:47,500 --> 00:22:52,330
here is that we really wanted to say

00:22:50,320 --> 00:22:53,620
here's the API that we trust and we're

00:22:52,330 --> 00:22:55,029
going to support and we're going to make

00:22:53,620 --> 00:22:56,529
changes in the new version that will

00:22:55,029 --> 00:22:58,659
have alpha and beta tracks and things

00:22:56,529 --> 00:23:02,710
but a lot of products in the space very

00:22:58,659 --> 00:23:04,899
much still sort of pre 1.0 quality even

00:23:02,710 --> 00:23:07,169
though they've got a 1.0 label on them

00:23:04,899 --> 00:23:09,669
this is something that we wanted to say

00:23:07,169 --> 00:23:10,929
we've had the production experience we

00:23:09,669 --> 00:23:13,809
want to make sure we don't make these

00:23:10,929 --> 00:23:16,809
mistakes again we've got the core very

00:23:13,809 --> 00:23:19,690
sensible and we're seeing development

00:23:16,809 --> 00:23:21,250
both in terms of John on the project and

00:23:19,690 --> 00:23:24,039
extensions there now since happening

00:23:21,250 --> 00:23:26,320
outside the core so we're seeing people

00:23:24,039 --> 00:23:28,419
who are now moving on from what can I

00:23:26,320 --> 00:23:30,100
run on my cluster to how can I make the

00:23:28,419 --> 00:23:31,720
cluster support the kind of workloads I

00:23:30,100 --> 00:23:33,549
want to do how can I build custom

00:23:31,720 --> 00:23:38,080
schedulers that are aware of the kind of

00:23:33,549 --> 00:23:39,520
things I might want to run so we're not

00:23:38,080 --> 00:23:41,860
going to go too deep into the technical

00:23:39,520 --> 00:23:44,380
details here but the the core primitives

00:23:41,860 --> 00:23:46,179
say you run effectively you just

00:23:44,380 --> 00:23:48,190
describe the work you want to run in the

00:23:46,179 --> 00:23:51,010
containers that have your programs in

00:23:48,190 --> 00:23:53,529
them and then you deploy them by way of

00:23:51,010 --> 00:23:55,480
pods and services are abstractions that

00:23:53,529 --> 00:23:58,090
let you address a group of pods and

00:23:55,480 --> 00:23:59,799
handler load balancing again another

00:23:58,090 --> 00:24:01,299
thing that we picked up that was

00:23:59,799 --> 00:24:03,700
something we wish to be done on board is

00:24:01,299 --> 00:24:05,260
all label address so key value pairs on

00:24:03,700 --> 00:24:06,970
things and then you just say I want to

00:24:05,260 --> 00:24:07,450
address the things which have this label

00:24:06,970 --> 00:24:10,029
and

00:24:07,450 --> 00:24:12,159
you're able to do a selector across your

00:24:10,029 --> 00:24:13,840
running work to say for example this

00:24:12,159 --> 00:24:16,899
load balancer targets things that are

00:24:13,840 --> 00:24:18,909
type front end and version 2 in the

00:24:16,899 --> 00:24:21,669
board world you only had one ID so you

00:24:18,909 --> 00:24:25,090
have people have a job called gmail dash

00:24:21,669 --> 00:24:28,059
V 2 dash 2014 dash server name or so on

00:24:25,090 --> 00:24:31,330
and a lot of these things are very hard

00:24:28,059 --> 00:24:32,649
for lessons so on top of those basic

00:24:31,330 --> 00:24:34,240
concepts we're starting to say alright

00:24:32,649 --> 00:24:36,700
well how can we extend things and we

00:24:34,240 --> 00:24:38,590
have the ability to run work and

00:24:36,700 --> 00:24:40,029
replicas of things and then we say we

00:24:38,590 --> 00:24:42,580
want to run the batch work so we want to

00:24:40,029 --> 00:24:45,370
run something not forever but run it

00:24:42,580 --> 00:24:47,289
until it completes that's a job and then

00:24:45,370 --> 00:24:49,149
the 1.4 release we're seeing scheduled

00:24:47,289 --> 00:24:50,860
jobs which is basically a common service

00:24:49,149 --> 00:24:53,919
we say do that but do it at a certain

00:24:50,860 --> 00:24:56,350
time so it's continual iteration over

00:24:53,919 --> 00:25:00,070
the set of things that that were built

00:24:56,350 --> 00:25:02,860
on we've seen an absolute great uptake

00:25:00,070 --> 00:25:04,720
from the community both in terms of more

00:25:02,860 --> 00:25:06,730
commercial vendors from the past and a

00:25:04,720 --> 00:25:08,740
lot of people doing commercial open

00:25:06,730 --> 00:25:11,320
source as well as a lot of other open

00:25:08,740 --> 00:25:13,059
source projects so we're working with a

00:25:11,320 --> 00:25:15,010
number of cloud providers we ultimately

00:25:13,059 --> 00:25:18,070
want to see everyone with a hosted

00:25:15,010 --> 00:25:20,580
communities offering companies like red

00:25:18,070 --> 00:25:22,889
hat and core OS doing distributions of

00:25:20,580 --> 00:25:25,450
communities to run behind the firewall a

00:25:22,889 --> 00:25:27,639
lot of people are working on platforms

00:25:25,450 --> 00:25:29,409
or service offerings so dais is a good

00:25:27,639 --> 00:25:31,389
example there it deploys just as

00:25:29,409 --> 00:25:33,549
something that runs inside your cluster

00:25:31,389 --> 00:25:35,590
and then it gives you a Heroku like

00:25:33,549 --> 00:25:36,610
environment where you just push code and

00:25:35,590 --> 00:25:41,350
it does all the building and deploying

00:25:36,610 --> 00:25:43,000
to that same cluster they were along

00:25:41,350 --> 00:25:44,799
with openshift they were so running in a

00:25:43,000 --> 00:25:46,480
different platform in the past and said

00:25:44,799 --> 00:25:48,399
we'll hang on if we re platform on

00:25:46,480 --> 00:25:49,480
Cooper Nettie's then they give us all of

00:25:48,399 --> 00:25:51,639
the things you saw on the previous

00:25:49,480 --> 00:25:52,960
slides for free and we can focus just an

00:25:51,639 --> 00:25:57,429
adding value of the part of the stack

00:25:52,960 --> 00:26:00,159
which makes sense for us have a a number

00:25:57,429 --> 00:26:01,779
of tools around networking so the way

00:26:00,159 --> 00:26:03,159
our networking model works it takes a

00:26:01,779 --> 00:26:05,260
bit more to sit up because you need to

00:26:03,159 --> 00:26:09,250
have a flat network between all the

00:26:05,260 --> 00:26:11,019
machines and again that's something we

00:26:09,250 --> 00:26:13,110
make it it takes a little bit more work

00:26:11,019 --> 00:26:15,610
at the beginning but that makes

00:26:13,110 --> 00:26:17,529
deploying applications easier throughout

00:26:15,610 --> 00:26:19,210
and that's a model now we've seen picked

00:26:17,529 --> 00:26:21,360
up by other people working in the space

00:26:19,210 --> 00:26:23,350
as well

00:26:21,360 --> 00:26:25,750
these are numbers from a couple of weeks

00:26:23,350 --> 00:26:28,810
ago but they're still about right we've

00:26:25,750 --> 00:26:31,380
had say now over 35,000 individual

00:26:28,810 --> 00:26:33,670
commits for almost a thousand people and

00:26:31,380 --> 00:26:35,500
we're seeing it picked up by a lot of

00:26:33,670 --> 00:26:36,910
companies through their internal

00:26:35,500 --> 00:26:41,830
production workloads as well as web

00:26:36,910 --> 00:26:43,570
facing stuff as well Google run a

00:26:41,830 --> 00:26:46,110
managed service they let you run just by

00:26:43,570 --> 00:26:48,130
clicking button and getting a cluster

00:26:46,110 --> 00:26:49,810
there's a nice free trial if you're

00:26:48,130 --> 00:26:52,270
interested in getting started it's also

00:26:49,810 --> 00:26:54,070
very easy to run we have a new talk with

00:26:52,270 --> 00:26:56,620
mini cube which lets you run just on

00:26:54,070 --> 00:27:00,280
your laptop and deploy a pasta there too

00:26:56,620 --> 00:27:01,600
and do the testing an area that we're

00:27:00,280 --> 00:27:03,520
seeing a lot of active work at the

00:27:01,600 --> 00:27:05,170
moment is in that cluster turn up

00:27:03,520 --> 00:27:08,050
because there are a lot of moving parts

00:27:05,170 --> 00:27:09,580
and giving this working so for anyone

00:27:08,050 --> 00:27:11,470
who's interested there's an alpha now

00:27:09,580 --> 00:27:12,970
and what's coming out with 1.4 of the

00:27:11,470 --> 00:27:14,920
new tool which makes it easy to

00:27:12,970 --> 00:27:17,320
basically one command to say that the

00:27:14,920 --> 00:27:19,570
Cuban areas master then generates tokens

00:27:17,320 --> 00:27:21,580
which you then give to the same command

00:27:19,570 --> 00:27:24,250
that you run on the nodes and that will

00:27:21,580 --> 00:27:25,780
connect up it'll do all the TLS

00:27:24,250 --> 00:27:27,820
negotiations if it gets walking and

00:27:25,780 --> 00:27:30,750
things so you end up with a secure

00:27:27,820 --> 00:27:35,890
cluster and it's a lot less ball of

00:27:30,750 --> 00:27:37,030
scripts to set up so there's an

00:27:35,890 --> 00:27:40,300
interesting article that was published

00:27:37,030 --> 00:27:44,410
about a week ago in info world by a open

00:27:40,300 --> 00:27:46,750
source commentator met SI and his theory

00:27:44,410 --> 00:27:48,250
is that why cumin is doing so well at

00:27:46,750 --> 00:27:49,480
the moment is really about the open

00:27:48,250 --> 00:27:52,120
source community that's been built

00:27:49,480 --> 00:27:54,400
around it and there is obviously the

00:27:52,120 --> 00:27:56,590
pedigree of the background that we have

00:27:54,400 --> 00:27:57,910
in this but his point was to say that

00:27:56,590 --> 00:28:00,370
it's about building an open source

00:27:57,910 --> 00:28:02,650
community and in his article ii so that

00:28:00,370 --> 00:28:04,060
suggested it was you build something and

00:28:02,650 --> 00:28:06,910
let it go and then just to the hope that

00:28:04,060 --> 00:28:08,740
it works whereas one of the things we

00:28:06,910 --> 00:28:10,750
think about this is this not as much as

00:28:08,740 --> 00:28:13,000
there but it's the maintaining involve

00:28:10,750 --> 00:28:15,310
involvement from our engineering team so

00:28:13,000 --> 00:28:17,710
we are still working we are working with

00:28:15,310 --> 00:28:19,150
product people from the community that's

00:28:17,710 --> 00:28:21,610
now so the feature development is done

00:28:19,150 --> 00:28:23,920
in the open as well but the choices that

00:28:21,610 --> 00:28:25,420
are being made and the engineering

00:28:23,920 --> 00:28:28,330
contribution is still being brought in

00:28:25,420 --> 00:28:30,310
by google the helping drive the project

00:28:28,330 --> 00:28:32,570
and i think i want to emphasize that if

00:28:30,310 --> 00:28:33,679
you are a commercial company looking

00:28:32,570 --> 00:28:35,240
build something and open-source you

00:28:33,679 --> 00:28:37,009
can't just put it out there and say

00:28:35,240 --> 00:28:40,549
right it's yours to maintain now is

00:28:37,009 --> 00:28:41,870
still needs that drive and the quicker

00:28:40,549 --> 00:28:43,220
you can build your community of

00:28:41,870 --> 00:28:45,380
contributors to include people from

00:28:43,220 --> 00:28:48,500
outside your company the better but you

00:28:45,380 --> 00:28:50,090
still need to as if you're in this kind

00:28:48,500 --> 00:28:55,580
of environment provide eggs daily

00:28:50,090 --> 00:28:58,850
handling cases and that's it so just to

00:28:55,580 --> 00:29:01,220
land up here here are a few things we

00:28:58,850 --> 00:29:03,830
think Canadians ative engages and lets

00:29:01,220 --> 00:29:05,480
people do so you have operations teams a

00:29:03,830 --> 00:29:07,509
happier because they it's very easy for

00:29:05,480 --> 00:29:09,320
them to operate this kind of environment

00:29:07,509 --> 00:29:11,600
application developers are happier

00:29:09,320 --> 00:29:14,299
because they have a nice interface with

00:29:11,600 --> 00:29:15,620
this as a hand things off and enable to

00:29:14,299 --> 00:29:18,169
the reliability of infrastructure

00:29:15,620 --> 00:29:20,090
automation more efficient use of

00:29:18,169 --> 00:29:23,210
resources as a way of saying lower costs

00:29:20,090 --> 00:29:25,250
and lower risk as well these things

00:29:23,210 --> 00:29:29,450
enabled by visit container and cluster

00:29:25,250 --> 00:29:31,009
deployment pattern if you have

00:29:29,450 --> 00:29:32,450
developers who are so scared of their

00:29:31,009 --> 00:29:34,399
legacy code base that they don't ever

00:29:32,450 --> 00:29:36,049
bother going and changing things then

00:29:34,399 --> 00:29:38,269
again that's that's a problem that

00:29:36,049 --> 00:29:40,340
people have so the concept of micro

00:29:38,269 --> 00:29:41,389
services is a way of breaking that apart

00:29:40,340 --> 00:29:43,580
and saying all right well let's make

00:29:41,389 --> 00:29:45,019
everything so simple that everyone can

00:29:43,580 --> 00:29:46,669
understand it and then build the

00:29:45,019 --> 00:29:51,830
boundaries between them well documented

00:29:46,669 --> 00:29:54,370
ap is so thank you very much I think I

00:29:51,830 --> 00:29:57,259
have some time here for questions but

00:29:54,370 --> 00:30:00,429
otherwise do feel free to tweet at me

00:29:57,259 --> 00:30:00,429

YouTube URL: https://www.youtube.com/watch?v=8hWQOuVl6-Q


