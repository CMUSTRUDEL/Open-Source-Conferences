Title: OW2con'18 Automate BPM applications testing in the Cloud with Jenkins, Ansible and Docker
Publication date: 2018-06-13
Playlist: OW2con 2018
Description: 
	Applications build on top of a BPM platform share a key aspect in common with all other applications: they must be tested! But how can tests be automated when an application requires a specific build process and a specific server to run?
In this talk I’ll highlight how we built a solution to automate the build, packaging, deployment and test of Bonita process-based applications using well known developer and DevOps tools such as Jenkins, Docker and Ansible. I’ll explain why we think that using the cloud for testing environments is a nifty idea, and also how to make sure that ultimately, solutions can be easily deployed on the cloud.

(Antoine Mottier, Bonitasoft)
Captions: 
	00:00:01,960 --> 00:00:06,990
[Music]

00:00:05,390 --> 00:00:10,740
hi everyone

00:00:06,990 --> 00:00:12,950
so I'm Antonio che I'm a Technical

00:00:10,740 --> 00:00:15,719
Evangelist that burn its surfed and

00:00:12,950 --> 00:00:18,480
today I'd like to speak about how had

00:00:15,719 --> 00:00:23,279
bonito soft we try to provide solution

00:00:18,480 --> 00:00:27,119
to automate the build deploy and testing

00:00:23,279 --> 00:00:31,410
of our bonito application so processed

00:00:27,119 --> 00:00:34,860
based application so first I'd like to

00:00:31,410 --> 00:00:37,980
say a few words about our solution about

00:00:34,860 --> 00:00:40,590
what is processed based application and

00:00:37,980 --> 00:00:42,809
about the bonito platform we'll try to

00:00:40,590 --> 00:00:46,379
keep it short but just to give a little

00:00:42,809 --> 00:00:49,280
bit of context what is the our platform

00:00:46,379 --> 00:00:52,620
where is bonito platform it's basically

00:00:49,280 --> 00:00:54,329
two different components there is one

00:00:52,620 --> 00:00:57,329
component the major component that is

00:00:54,329 --> 00:01:02,129
the development environment it's what we

00:00:57,329 --> 00:01:05,400
call bonito studio and it's a it's an

00:01:02,129 --> 00:01:07,130
envoy it's a it's a tool to build your

00:01:05,400 --> 00:01:10,950
application to create your application

00:01:07,130 --> 00:01:14,729
by doing by creating some process models

00:01:10,950 --> 00:01:16,920
but as well so by creating the user

00:01:14,729 --> 00:01:20,009
interface to interact with the process

00:01:16,920 --> 00:01:22,530
building other models to define the data

00:01:20,009 --> 00:01:26,549
management so you recreate all the

00:01:22,530 --> 00:01:28,740
application in this studio and the

00:01:26,549 --> 00:01:31,409
studio is based actually on Eclipse

00:01:28,740 --> 00:01:32,850
so it's really a tool for the developers

00:01:31,409 --> 00:01:37,520
it's ready to to create the application

00:01:32,850 --> 00:01:40,500
and once you have this application

00:01:37,520 --> 00:01:42,210
created in the studio to make the

00:01:40,500 --> 00:01:45,119
application available to the end user

00:01:42,210 --> 00:01:48,329
you need to deploy it on what we will

00:01:45,119 --> 00:01:50,610
call a bonito server and so basically

00:01:48,329 --> 00:01:53,220
you go like for any kind of application

00:01:50,610 --> 00:01:56,939
you will Mali's compile the application

00:01:53,220 --> 00:02:00,360
and you will deploy to the server so you

00:01:56,939 --> 00:02:02,070
need to have this server available and I

00:02:00,360 --> 00:02:04,820
don't need a server just to give a

00:02:02,070 --> 00:02:07,920
little bit of technical details it's

00:02:04,820 --> 00:02:09,929
built on Java technology so you need to

00:02:07,920 --> 00:02:12,390
have the java virtual machine you need

00:02:09,929 --> 00:02:13,470
to have a java application server with

00:02:12,390 --> 00:02:15,620
the banette

00:02:13,470 --> 00:02:18,630
and deployed and you need to have

00:02:15,620 --> 00:02:21,330
database available for the persistence

00:02:18,630 --> 00:02:24,420
of the data quality to the process

00:02:21,330 --> 00:02:26,580
execution but also related to the

00:02:24,420 --> 00:02:29,070
business application that are running on

00:02:26,580 --> 00:02:31,020
the platform so that the two big

00:02:29,070 --> 00:02:33,770
component one side is development

00:02:31,020 --> 00:02:38,460
environments and the other side is a

00:02:33,770 --> 00:02:40,830
platform for execution and when we are

00:02:38,460 --> 00:02:42,800
in the in these development environments

00:02:40,830 --> 00:02:46,230
what we are really creating when we

00:02:42,800 --> 00:02:49,890
build the Bonita application is a set of

00:02:46,230 --> 00:02:53,610
like I said process diagram we use the

00:02:49,890 --> 00:02:56,910
bpmn standard to model business process

00:02:53,610 --> 00:02:59,640
so it's a it's a standard by OMG so

00:02:56,910 --> 00:03:04,680
several vendors provide tooling to

00:02:59,640 --> 00:03:07,590
create such diagrams but also we not

00:03:04,680 --> 00:03:10,140
only focus on creating and automating

00:03:07,590 --> 00:03:12,770
the execution of the process diagram but

00:03:10,140 --> 00:03:16,080
we provide extra services like the

00:03:12,770 --> 00:03:18,959
persistence of business data some

00:03:16,080 --> 00:03:21,989
capability to create user interface to

00:03:18,959 --> 00:03:26,970
drive the process execution and we have

00:03:21,989 --> 00:03:29,100
various extension points - - to connect

00:03:26,970 --> 00:03:31,230
the process with the external system

00:03:29,100 --> 00:03:34,739
information like for example if you want

00:03:31,230 --> 00:03:37,050
to call a web service send an email blow

00:03:34,739 --> 00:03:41,700
the documents to a content management

00:03:37,050 --> 00:03:44,910
system so that's the different part of

00:03:41,700 --> 00:03:48,239
an application so as I said we find some

00:03:44,910 --> 00:03:51,750
models we find also source code we have

00:03:48,239 --> 00:03:53,910
classic Java code that the developer can

00:03:51,750 --> 00:03:56,640
create in our studio for the user

00:03:53,910 --> 00:03:59,519
interface we'll find of course HTML and

00:03:56,640 --> 00:04:03,420
JavaScript and so when you want to build

00:03:59,519 --> 00:04:06,330
this application you need to compile the

00:04:03,420 --> 00:04:08,940
source code usually for the models you

00:04:06,330 --> 00:04:11,130
create like the diagrams model you will

00:04:08,940 --> 00:04:14,070
have some kind of transformation to get

00:04:11,130 --> 00:04:16,500
from the visual diagram to a runnable

00:04:14,070 --> 00:04:21,239
diagram that the workflow engine can

00:04:16,500 --> 00:04:23,430
interpret and all the steps in the

00:04:21,239 --> 00:04:24,690
initial version of our application were

00:04:23,430 --> 00:04:27,450
performed

00:04:24,690 --> 00:04:28,890
Morris manually in the studio like you

00:04:27,450 --> 00:04:32,130
will go to a menu

00:04:28,890 --> 00:04:35,670
and trigger the built of the various

00:04:32,130 --> 00:04:38,700
artifacts and then you get a set of zip

00:04:35,670 --> 00:04:42,210
file basically that you need to deploy

00:04:38,700 --> 00:04:45,420
to the to the platform to the server to

00:04:42,210 --> 00:04:48,780
make them available to the end user so

00:04:45,420 --> 00:04:51,120
it was a little bit complex or modest

00:04:48,780 --> 00:04:53,460
error-prone because you need to will

00:04:51,120 --> 00:04:56,180
several set of artifact make sure the

00:04:53,460 --> 00:05:00,810
you build them in the proper version and

00:04:56,180 --> 00:05:05,430
deploy them usually one by one on the

00:05:00,810 --> 00:05:08,280
server so this complex process like was

00:05:05,430 --> 00:05:10,230
risky and it was not really agile you

00:05:08,280 --> 00:05:12,030
cannot really deploy quickly a new

00:05:10,230 --> 00:05:14,400
version or test a new version of the

00:05:12,030 --> 00:05:17,460
application which is quite a few

00:05:14,400 --> 00:05:20,370
challenge on that and so we will come

00:05:17,460 --> 00:05:25,230
with this with this target of empowering

00:05:20,370 --> 00:05:28,310
our clients and let them easily build

00:05:25,230 --> 00:05:32,130
the application test the application on

00:05:28,310 --> 00:05:35,370
a server so we want to address two

00:05:32,130 --> 00:05:40,620
different thing here one part is making

00:05:35,370 --> 00:05:44,070
sure that this the steps needed to build

00:05:40,620 --> 00:05:47,160
and deploy the application can be run

00:05:44,070 --> 00:05:50,100
faster and run again if you want to to

00:05:47,160 --> 00:05:52,560
rebuild a version like that you are sure

00:05:50,100 --> 00:05:55,050
about the path you take to to build the

00:05:52,560 --> 00:05:57,780
application and also make the

00:05:55,050 --> 00:06:01,020
provisioning of the new server a lot

00:05:57,780 --> 00:06:02,490
easier because if you need to set up the

00:06:01,020 --> 00:06:06,000
operating system the java virtual

00:06:02,490 --> 00:06:08,640
machine database and so on it's not very

00:06:06,000 --> 00:06:11,070
very complex but there is always a

00:06:08,640 --> 00:06:13,080
little risk like you don't set up the

00:06:11,070 --> 00:06:16,230
proper version of the JVM because of an

00:06:13,080 --> 00:06:20,060
operating system update or whatever it's

00:06:16,230 --> 00:06:25,230
always a little bit risky on the stage

00:06:20,060 --> 00:06:28,190
so as I said we have two different part

00:06:25,230 --> 00:06:31,560
of the problem to address one is this

00:06:28,190 --> 00:06:33,419
continuous or integration part or more

00:06:31,560 --> 00:06:35,940
accurately what we call continuous

00:06:33,419 --> 00:06:38,280
delivery and I will get back on that but

00:06:35,940 --> 00:06:40,889
the part of the solution we want for the

00:06:38,280 --> 00:06:43,620
Hopper's and the other part is the

00:06:40,889 --> 00:06:48,630
solution to probably to the provisioning

00:06:43,620 --> 00:06:51,780
of the Bonita server so more for system

00:06:48,630 --> 00:06:54,389
administrator and the combination of two

00:06:51,780 --> 00:06:56,639
is of course what is kind of trendy

00:06:54,389 --> 00:07:00,960
right now is whatever one called DevOps

00:06:56,639 --> 00:07:03,389
is meaning that developers can go from

00:07:00,960 --> 00:07:06,860
their source their development in the

00:07:03,389 --> 00:07:12,360
studio to an integration test easily

00:07:06,860 --> 00:07:14,430
within the platform so we'll go in more

00:07:12,360 --> 00:07:20,030
detail about the continuous delivery

00:07:14,430 --> 00:07:22,800
parts and just maybe first a precision

00:07:20,030 --> 00:07:24,720
about what we call continuous delivery

00:07:22,800 --> 00:07:28,050
and how it's different compared to

00:07:24,720 --> 00:07:31,169
continuous integration so continuous

00:07:28,050 --> 00:07:34,830
integration is basically building your

00:07:31,169 --> 00:07:37,440
source or transforming the the models we

00:07:34,830 --> 00:07:41,760
have in the studio and do some unit

00:07:37,440 --> 00:07:45,120
tests on them and this led the developer

00:07:41,760 --> 00:07:47,490
really quickly test what it produce but

00:07:45,120 --> 00:07:49,470
at a smaller scale like it's not the

00:07:47,490 --> 00:07:51,720
world application you test so you know

00:07:49,470 --> 00:07:54,150
that your component will work like you

00:07:51,720 --> 00:07:56,370
might know that your user interface for

00:07:54,150 --> 00:07:58,650
one task in your process is fully

00:07:56,370 --> 00:08:00,510
functional but you will not be sure that

00:07:58,650 --> 00:08:03,990
the world process the whole application

00:08:00,510 --> 00:08:08,850
will be fully functional and behave as

00:08:03,990 --> 00:08:11,220
expected by the end users and that's

00:08:08,850 --> 00:08:14,010
actually the next that it's this

00:08:11,220 --> 00:08:16,380
continuous delivery parts so it's go on

00:08:14,010 --> 00:08:18,690
top of the continuous integration and it

00:08:16,380 --> 00:08:22,289
will take all the artifacts you build in

00:08:18,690 --> 00:08:24,030
the continuous integration and package

00:08:22,289 --> 00:08:26,880
them and build actually the full

00:08:24,030 --> 00:08:29,100
application deploy this application and

00:08:26,880 --> 00:08:31,950
run some integration tests usually

00:08:29,100 --> 00:08:34,110
automated integration tests on the

00:08:31,950 --> 00:08:36,180
application so here you get an extra

00:08:34,110 --> 00:08:38,580
level of confidence and the quality of

00:08:36,180 --> 00:08:41,880
your application because you test it at

00:08:38,580 --> 00:08:44,640
an upper level you have really the

00:08:41,880 --> 00:08:49,110
something that is really close to what

00:08:44,640 --> 00:08:51,889
the end-user will face so why we we

00:08:49,110 --> 00:08:55,220
consider this continuous delivery

00:08:51,889 --> 00:08:58,819
approach importance it's basically

00:08:55,220 --> 00:09:01,339
because it will save a lot of time from

00:08:58,819 --> 00:09:05,920
the developments to the release of the

00:09:01,339 --> 00:09:08,749
application to the end-users because the

00:09:05,920 --> 00:09:11,209
the developer will immediately get some

00:09:08,749 --> 00:09:13,059
feedback about what it created what is

00:09:11,209 --> 00:09:16,489
the current status of the application

00:09:13,059 --> 00:09:18,350
because usually the developer of a

00:09:16,489 --> 00:09:21,829
feedback about the unit s is no like

00:09:18,350 --> 00:09:24,649
this component that he work on work as

00:09:21,829 --> 00:09:26,600
he expects but it sometime doesn't have

00:09:24,649 --> 00:09:28,999
this feedback about how this component

00:09:26,600 --> 00:09:31,600
would work in the final global solution

00:09:28,999 --> 00:09:36,049
in the final application so here it will

00:09:31,600 --> 00:09:38,029
quickly get the feedback about what is

00:09:36,049 --> 00:09:41,209
the current status of the application is

00:09:38,029 --> 00:09:44,269
it fully functional walnut so we'll be

00:09:41,209 --> 00:09:47,720
able to find it faster all the bugs and

00:09:44,269 --> 00:09:50,769
when a user will perform some maybe user

00:09:47,720 --> 00:09:53,720
exception test you will have a better

00:09:50,769 --> 00:09:55,459
software quality so it will be more

00:09:53,720 --> 00:09:57,290
involved in the test because it will not

00:09:55,459 --> 00:09:59,989
face all this kind of bug that you can

00:09:57,290 --> 00:10:03,019
detect by running some integration tests

00:09:59,989 --> 00:10:05,869
so now I will go more in detail about

00:10:03,019 --> 00:10:08,839
the architecture of the our solution and

00:10:05,869 --> 00:10:11,419
how which kind of component we used to

00:10:08,839 --> 00:10:15,199
build it and what was our philosophy

00:10:11,419 --> 00:10:17,839
behind that so as I say to you you can

00:10:15,199 --> 00:10:20,029
see on this on this schema here we have

00:10:17,839 --> 00:10:22,249
our development environment so that's a

00:10:20,029 --> 00:10:24,259
Bonita studio and a component that is

00:10:22,249 --> 00:10:26,989
embedded in Bonita studio that we call

00:10:24,259 --> 00:10:30,199
the UI designer is it's a tool to build

00:10:26,989 --> 00:10:32,389
the user interface and so it's really

00:10:30,199 --> 00:10:34,819
development environment and we want to

00:10:32,389 --> 00:10:38,720
be friendly with developer even if they

00:10:34,819 --> 00:10:41,449
don't code a lot anymore in our solution

00:10:38,720 --> 00:10:43,939
there is still a lot of option to code

00:10:41,449 --> 00:10:46,129
and there is still producing some source

00:10:43,939 --> 00:10:49,160
even if it's a diagram it's it's some

00:10:46,129 --> 00:10:51,169
source for the application so we want to

00:10:49,160 --> 00:10:54,319
provide them the tool they are used to

00:10:51,169 --> 00:10:56,209
and so we integrate with git or we

00:10:54,319 --> 00:11:00,079
integrate also as well with the legacy

00:10:56,209 --> 00:11:01,310
subversion to store the history of the

00:11:00,079 --> 00:11:04,250
source code

00:11:01,310 --> 00:11:07,010
and then we need to plug in a continuous

00:11:04,250 --> 00:11:09,950
integration software so in our case we

00:11:07,010 --> 00:11:13,450
are using Jenkins and we provide a

00:11:09,950 --> 00:11:16,640
prepackaged docker image of Jenkins

00:11:13,450 --> 00:11:19,010
because we we want to keep it as simple

00:11:16,640 --> 00:11:21,320
as possible to our end user because some

00:11:19,010 --> 00:11:26,150
of them might not be really familiar

00:11:21,320 --> 00:11:28,700
always continuous integration and if we

00:11:26,150 --> 00:11:33,910
if it's required if the learning curve

00:11:28,700 --> 00:11:37,339
is towards I might not add up this this

00:11:33,910 --> 00:11:39,800
this workflow to to create their

00:11:37,339 --> 00:11:42,140
application so we want to make this as

00:11:39,800 --> 00:11:44,750
smooth as possible for them so we have

00:11:42,140 --> 00:11:46,880
this prepackaged docker image with some

00:11:44,750 --> 00:11:50,990
example about the the pipeline to build

00:11:46,880 --> 00:11:52,820
the application and what this pipeline

00:11:50,990 --> 00:11:55,510
will do is we'll actually get the source

00:11:52,820 --> 00:11:58,760
code from gates like any classic

00:11:55,510 --> 00:12:01,460
application it will build it run some

00:11:58,760 --> 00:12:04,220
unit the unit tests and then it will

00:12:01,460 --> 00:12:07,280
create a test environment it will set up

00:12:04,220 --> 00:12:09,770
a test server and deploy the application

00:12:07,280 --> 00:12:12,620
to the test server automatically and

00:12:09,770 --> 00:12:16,430
finally we run the integration test on

00:12:12,620 --> 00:12:19,310
this platform so I will get back in the

00:12:16,430 --> 00:12:23,150
second part on how it create the test

00:12:19,310 --> 00:12:26,810
environment but basically what is

00:12:23,150 --> 00:12:28,430
important here is that really we benefit

00:12:26,810 --> 00:12:31,100
from the continuous integration software

00:12:28,430 --> 00:12:35,360
because there is no more manual

00:12:31,100 --> 00:12:38,120
operation in here everything happened on

00:12:35,360 --> 00:12:40,700
the developer computer where it will

00:12:38,120 --> 00:12:44,150
create application where it will define

00:12:40,700 --> 00:12:46,640
the test and we really tests we provide

00:12:44,150 --> 00:12:50,510
testing framework at the process

00:12:46,640 --> 00:12:53,510
execution level so it's not only the

00:12:50,510 --> 00:12:55,400
single components a single piece of the

00:12:53,510 --> 00:12:57,430
application are tested but really the

00:12:55,400 --> 00:13:00,620
the whole application that is

00:12:57,430 --> 00:13:04,100
automatically tested here feedback about

00:13:00,620 --> 00:13:06,830
what we choose the the tool we we select

00:13:04,100 --> 00:13:09,050
in our in our stack here like why we

00:13:06,830 --> 00:13:12,650
choose to support link it and subversion

00:13:09,050 --> 00:13:13,970
and maybe no other versioning control

00:13:12,650 --> 00:13:17,480
system

00:13:13,970 --> 00:13:20,840
I think on an VCS is kind of easy

00:13:17,480 --> 00:13:25,220
because there is not a lot of other

00:13:20,840 --> 00:13:29,560
tools that are such broadly used by any

00:13:25,220 --> 00:13:34,040
cooperation and we will never have

00:13:29,560 --> 00:13:34,970
customer asking for IBM solution for

00:13:34,040 --> 00:13:37,670
versioning system

00:13:34,970 --> 00:13:39,950
I mean few of them might but the Stila

00:13:37,670 --> 00:13:42,520
of git or subversion somewhere it's

00:13:39,950 --> 00:13:46,520
really the most popular open-source tool

00:13:42,520 --> 00:13:49,130
and when you look at the solution to do

00:13:46,520 --> 00:13:51,110
continuous integration every single of

00:13:49,130 --> 00:13:54,140
them support like kids there is none of

00:13:51,110 --> 00:13:58,070
them that doesn't support it so it's

00:13:54,140 --> 00:13:59,900
really the de facto standard and there

00:13:58,070 --> 00:14:06,260
was no question about which one to pick

00:13:59,900 --> 00:14:09,890
here about Jenkins why Jenkins and this

00:14:06,260 --> 00:14:13,430
is from is can be surprising but I think

00:14:09,890 --> 00:14:16,100
the the most important factors that push

00:14:13,430 --> 00:14:18,350
for a third choice such choice is like

00:14:16,100 --> 00:14:20,110
it's what we know internally in the

00:14:18,350 --> 00:14:23,390
company

00:14:20,110 --> 00:14:25,400
our solution is Java based Jenkins is

00:14:23,390 --> 00:14:28,160
quite popular arm and the java

00:14:25,400 --> 00:14:30,770
application developer and so we have

00:14:28,160 --> 00:14:32,900
people internally in the company that's

00:14:30,770 --> 00:14:35,890
know about that have knowledge about the

00:14:32,900 --> 00:14:39,830
tool and I think it's not something to

00:14:35,890 --> 00:14:42,830
take lightly as when you decide to to

00:14:39,830 --> 00:14:44,480
choose one solution or another if some

00:14:42,830 --> 00:14:49,220
people within the company already know

00:14:44,480 --> 00:14:53,510
the tool it's a good indicator that this

00:14:49,220 --> 00:14:56,180
tool is probably a good option also what

00:14:53,510 --> 00:14:59,630
is really nice about Jenkins is 3 it's

00:14:56,180 --> 00:15:02,860
open so it's open source yes but it's

00:14:59,630 --> 00:15:05,750
also really open to be integrated with

00:15:02,860 --> 00:15:10,030
various system it can build Java but it

00:15:05,750 --> 00:15:15,230
can also be easily adapt to build or

00:15:10,030 --> 00:15:17,570
specific application because when we

00:15:15,230 --> 00:15:21,440
build our process diagram for example

00:15:17,570 --> 00:15:23,720
it's an XML file that we transform it's

00:15:21,440 --> 00:15:26,660
not something that is

00:15:23,720 --> 00:15:28,670
it's not a source code like most

00:15:26,660 --> 00:15:30,680
continuous integration software are used

00:15:28,670 --> 00:15:33,560
to deal with so it's need a little bit

00:15:30,680 --> 00:15:36,050
of customization and Jenkins was really

00:15:33,560 --> 00:15:42,140
nice solution with all the customization

00:15:36,050 --> 00:15:44,180
capabilities finally the last point that

00:15:42,140 --> 00:15:49,550
Ernie wants to highlight here is like

00:15:44,180 --> 00:15:52,190
why we choose to I mean that what we

00:15:49,550 --> 00:15:53,900
choose with why we have to to make this

00:15:52,190 --> 00:15:56,630
kind of evolution on the product because

00:15:53,900 --> 00:15:58,790
our product basically on the first

00:15:56,630 --> 00:16:01,970
version you need to go in the menu and

00:15:58,790 --> 00:16:07,310
manual it did the build step one by one

00:16:01,970 --> 00:16:08,720
and now in the in the tool if you want

00:16:07,310 --> 00:16:11,690
the integration with a continuous

00:16:08,720 --> 00:16:15,080
integration software you need to be able

00:16:11,690 --> 00:16:19,130
to have this on the command line and so

00:16:15,080 --> 00:16:21,980
we to be able to deliver the value we we

00:16:19,130 --> 00:16:25,400
need to create a new tool to automate

00:16:21,980 --> 00:16:27,410
the built without any user interface so

00:16:25,400 --> 00:16:30,260
we come with new component with new

00:16:27,410 --> 00:16:31,820
major evolution on the way we used to

00:16:30,260 --> 00:16:38,570
build the application to make the

00:16:31,820 --> 00:16:40,730
automation possible now we try to go

00:16:38,570 --> 00:16:44,240
quickly because I'm running a little bit

00:16:40,730 --> 00:16:48,200
late but on this provisioning part so

00:16:44,240 --> 00:16:51,260
setting up the server and what is really

00:16:48,200 --> 00:16:54,830
interesting in trying to automate the

00:16:51,260 --> 00:16:58,160
server setup is when you want to run

00:16:54,830 --> 00:17:00,320
some tests you need the test server only

00:16:58,160 --> 00:17:02,690
for a short period of time you don't

00:17:00,320 --> 00:17:04,640
need you don't only need it to run your

00:17:02,690 --> 00:17:08,440
tests then the server is basically

00:17:04,640 --> 00:17:11,030
useless so if you buy some hardware and

00:17:08,440 --> 00:17:14,360
spend some time to set up your server

00:17:11,030 --> 00:17:16,850
and it's use like one hour per day when

00:17:14,360 --> 00:17:22,280
you run your integration test it's not

00:17:16,850 --> 00:17:26,540
really optimal and yeah you only run use

00:17:22,280 --> 00:17:31,160
your server like like 25 percent of its

00:17:26,540 --> 00:17:32,780
capability during a day so if you

00:17:31,160 --> 00:17:35,110
automate the provisioning you can

00:17:32,780 --> 00:17:37,490
integrate that in your country in your

00:17:35,110 --> 00:17:39,770
continuous integration pipeline

00:17:37,490 --> 00:17:43,700
set up the server only for the time

00:17:39,770 --> 00:17:46,640
needed to run the test and hit address

00:17:43,700 --> 00:17:50,570
also a lot of challenge here I try to

00:17:46,640 --> 00:17:53,300
sum up a few of them but here's all the

00:17:50,570 --> 00:17:56,300
step needed to be performed when you

00:17:53,300 --> 00:17:58,040
want to set up a Bonita server so of

00:17:56,300 --> 00:18:00,590
course you need the hardware you need

00:17:58,040 --> 00:18:04,970
the operating system as I said we use

00:18:00,590 --> 00:18:08,690
database we are Java software so we need

00:18:04,970 --> 00:18:11,090
gvm and an application server so we

00:18:08,690 --> 00:18:14,120
already provide pretty big prepackaged

00:18:11,090 --> 00:18:16,040
application server with bonita but if

00:18:14,120 --> 00:18:18,679
you automate all of that it really

00:18:16,040 --> 00:18:20,870
reduces the risk about having

00:18:18,679 --> 00:18:24,170
incompatibilities like between the

00:18:20,870 --> 00:18:26,720
components and also if it's fully

00:18:24,170 --> 00:18:29,030
automated it will always be faster than

00:18:26,720 --> 00:18:31,990
compared to a human performing each step

00:18:29,030 --> 00:18:34,370
manually like right now we managed to

00:18:31,990 --> 00:18:38,420
set up our server and there are five

00:18:34,370 --> 00:18:42,200
minutes on cloud infrastructure so it's

00:18:38,420 --> 00:18:45,110
really helped to push our customer to do

00:18:42,200 --> 00:18:50,420
more testing because set is setting up

00:18:45,110 --> 00:18:52,520
the server is a lot easier also this

00:18:50,420 --> 00:18:55,070
server setup automation is really

00:18:52,520 --> 00:18:57,590
interesting when you want to address the

00:18:55,070 --> 00:19:00,260
scalability of the solution if it's

00:18:57,590 --> 00:19:02,540
automated you can add more nodes to a

00:19:00,260 --> 00:19:05,000
cluster environment really easily so

00:19:02,540 --> 00:19:08,059
this is true of course for our Bonita

00:19:05,000 --> 00:19:11,300
server built also like most cloud

00:19:08,059 --> 00:19:14,600
provider provider database as a service

00:19:11,300 --> 00:19:17,059
and they also provide cluster

00:19:14,600 --> 00:19:21,920
infrastructure so you can leverage that

00:19:17,059 --> 00:19:27,230
to be able to absorb the load and

00:19:21,920 --> 00:19:33,080
finally there is all part about backup

00:19:27,230 --> 00:19:34,700
that is really important like in cloud

00:19:33,080 --> 00:19:37,070
solution really helped you on that

00:19:34,700 --> 00:19:39,620
because they will deal with backup for

00:19:37,070 --> 00:19:44,510
for you as I will provide some service

00:19:39,620 --> 00:19:47,840
around that that can be really useful so

00:19:44,510 --> 00:19:49,539
now here is the solution that we we set

00:19:47,840 --> 00:19:53,450
up

00:19:49,539 --> 00:19:57,559
for the automation of the creation of a

00:19:53,450 --> 00:20:01,100
new new instance we we use as well a

00:19:57,559 --> 00:20:04,879
docker image to to make this isolated

00:20:01,100 --> 00:20:07,340
for the developer and this docker image

00:20:04,879 --> 00:20:13,279
will provide a command-line tool that

00:20:07,340 --> 00:20:16,309
will interact with with so in this

00:20:13,279 --> 00:20:20,529
example with AWS but also we might

00:20:16,309 --> 00:20:24,499
support other cloud vendors to create

00:20:20,529 --> 00:20:27,740
machine instance set up on the machine

00:20:24,499 --> 00:20:30,529
instance docker then deploy the docker

00:20:27,740 --> 00:20:34,100
image and start the server and do all

00:20:30,529 --> 00:20:37,279
the configuration it can use also as I

00:20:34,100 --> 00:20:40,210
said databases service like RDS from

00:20:37,279 --> 00:20:43,279
Amazon and we automate all that and

00:20:40,210 --> 00:20:52,909
within five minutes you have a server up

00:20:43,279 --> 00:20:55,999
and running so our benefit from so here

00:20:52,909 --> 00:20:58,490
is I mentioned AWS but it's also true

00:20:55,999 --> 00:21:01,850
with any other vendor and even true on

00:20:58,490 --> 00:21:05,600
your in a house infrastructure the

00:21:01,850 --> 00:21:08,990
provisioning is faster it will deal with

00:21:05,600 --> 00:21:11,629
the operating system setup so you have a

00:21:08,990 --> 00:21:15,049
set of an operating system that is up to

00:21:11,629 --> 00:21:19,159
date when you start and you can allocate

00:21:15,049 --> 00:21:21,080
the server only when needed it's also

00:21:19,159 --> 00:21:23,450
very nice if you want to do some load

00:21:21,080 --> 00:21:25,460
testing because it can be quite

00:21:23,450 --> 00:21:28,389
expensive to have a very large

00:21:25,460 --> 00:21:30,950
configuration here you will allocate the

00:21:28,389 --> 00:21:37,309
server only for the minimal time

00:21:30,950 --> 00:21:39,080
required RDS I will not go into detail

00:21:37,309 --> 00:21:41,869
but specifically yeah you have the

00:21:39,080 --> 00:21:45,169
database as a service so you don't

00:21:41,869 --> 00:21:48,999
dealing more with backups or a lot of

00:21:45,169 --> 00:21:53,509
administration tasks are handled by the

00:21:48,999 --> 00:21:56,640
service provider and the docker image is

00:21:53,509 --> 00:21:59,880
really what is important to us because

00:21:56,640 --> 00:22:03,330
it's isolate us from the customer

00:21:59,880 --> 00:22:06,120
environment so our support team really

00:22:03,330 --> 00:22:08,490
like docker because now they have this

00:22:06,120 --> 00:22:10,980
border they know if it's within the

00:22:08,490 --> 00:22:13,490
docker image it's our fault if it's

00:22:10,980 --> 00:22:18,990
outside it's more than the customer

00:22:13,490 --> 00:22:21,480
customer side just the last word about

00:22:18,990 --> 00:22:24,419
the tool we use to automate the

00:22:21,480 --> 00:22:26,730
deployment it's open source again it's

00:22:24,419 --> 00:22:29,669
sensible and I think I will use the same

00:22:26,730 --> 00:22:32,669
argument as for Jenkins it's because

00:22:29,669 --> 00:22:34,710
it's open it's able to be integrated

00:22:32,669 --> 00:22:37,080
with a lot of different solution

00:22:34,710 --> 00:22:38,970
different cloud provider and this

00:22:37,080 --> 00:22:41,700
openness is really something important

00:22:38,970 --> 00:22:45,000
to us because our clients use different

00:22:41,700 --> 00:22:47,639
system and we don't want to to log them

00:22:45,000 --> 00:22:49,429
within anything specific it's why we

00:22:47,639 --> 00:22:53,549
follow standard ins it's why we

00:22:49,429 --> 00:22:55,100
integrate on the open continents thank

00:22:53,549 --> 00:22:57,419
you everyone for your attention and

00:22:55,100 --> 00:22:58,300
available after if you have any question

00:22:57,419 --> 00:23:03,380
Thanks

00:22:58,300 --> 00:23:03,380

YouTube URL: https://www.youtube.com/watch?v=wXn6fYaeRE4


