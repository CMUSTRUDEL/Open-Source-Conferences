Title: OW2con'18 - STAMP, or Test Amplification to DevTestOps service - Daniele Gagliardi
Publication date: 2018-06-13
Playlist: OW2con 2018
Description: 
	There is increasing talk of DevTestOps to emphasise that the DevOps promise to release software quickly should not be at the expense of its quality and ultimately of its value. STAMP (Software Testing AMPlification) project can provide you with several powerful test amplification features to be exploited at three different stages in a DevOps process:
    • automatic generation and execution of variants of existing test cases;
    • automatic generation of variants of existing test configurations;
    • automatic generation of test cases from available production logs in order to reproduce and fix any anomaly which may occur.
In this talk I will show you how to use this technology within your production processes in order to increase your software quality.
Captions: 
	00:00:01,960 --> 00:00:08,760
[Music]

00:00:05,000 --> 00:00:11,940
hi everybody and thank you for being

00:00:08,760 --> 00:00:16,100
here to listen about stamp these

00:00:11,940 --> 00:00:18,660
collaborative projects stamp stands for

00:00:16,100 --> 00:00:22,279
software testing amplification and we

00:00:18,660 --> 00:00:27,150
will see what this is the this esoteric

00:00:22,279 --> 00:00:31,730
kind of software testing and we will see

00:00:27,150 --> 00:00:36,380
how stamp can let you to introduce to

00:00:31,730 --> 00:00:40,320
empower the quality of your software

00:00:36,380 --> 00:00:44,070
using it you can use it of course in

00:00:40,320 --> 00:00:47,960
India OPS's the natural usage of stem

00:00:44,070 --> 00:00:47,960
but you can also use in more traditional

00:00:48,230 --> 00:00:55,050
software development processes just

00:00:52,020 --> 00:00:58,590
towards about me high among software

00:00:55,050 --> 00:01:01,680
engineering in a software engineer for

00:00:58,590 --> 00:01:04,500
engineering group and I collaborate with

00:01:01,680 --> 00:01:07,560
the W to community sharing the

00:01:04,500 --> 00:01:11,189
Technology Council and representing my

00:01:07,560 --> 00:01:16,979
company in the board of director my

00:01:11,189 --> 00:01:20,040
software test hand to just I teach

00:01:16,979 --> 00:01:22,860
several courses about it and with my

00:01:20,040 --> 00:01:25,409
team we deliver best practices for our

00:01:22,860 --> 00:01:28,759
colleagues and customers and so on

00:01:25,409 --> 00:01:32,369
I a member of the Spago the audibly to

00:01:28,759 --> 00:01:35,250
Spago for Q projects and in stem project

00:01:32,369 --> 00:01:38,939
currently I'm leading the war package

00:01:35,250 --> 00:01:41,899
for that is related to the the system

00:01:38,939 --> 00:01:46,700
integration the integration of stamp

00:01:41,899 --> 00:01:50,100
artifacts so in the agenda we will see

00:01:46,700 --> 00:01:54,000
what are the needs that stamp want to

00:01:50,100 --> 00:01:59,460
address the ideas behind stamp and how

00:01:54,000 --> 00:02:02,009
can use them just now because several

00:01:59,460 --> 00:02:05,460
components are already available are of

00:02:02,009 --> 00:02:09,580
course are open source components they

00:02:05,460 --> 00:02:14,160
are available in the gita b- repository

00:02:09,580 --> 00:02:18,180
and you will see let's start from the

00:02:14,160 --> 00:02:23,470
values behind the DevOps movement scones

00:02:18,180 --> 00:02:26,800
culture automation lean measurement and

00:02:23,470 --> 00:02:30,120
sharing and let's focus on automation

00:02:26,800 --> 00:02:33,460
because automation it's a key points in

00:02:30,120 --> 00:02:38,530
DevOps in DevOps culture and DevOps

00:02:33,460 --> 00:02:41,890
approach to software development yes to

00:02:38,530 --> 00:02:44,530
how to meet you need of course on

00:02:41,890 --> 00:02:49,240
infrastructure here you can see a

00:02:44,530 --> 00:02:51,490
representation have several tools that

00:02:49,240 --> 00:02:54,850
you can use within your software

00:02:51,490 --> 00:02:58,930
development process and you see that

00:02:54,850 --> 00:03:02,770
there is a pipeline with several tools

00:02:58,930 --> 00:03:06,250
some of them you know very well the geet

00:03:02,770 --> 00:03:10,450
lab Jenkins and a lot of other things

00:03:06,250 --> 00:03:13,450
and it seems that automating everything

00:03:10,450 --> 00:03:19,230
could be the solution to home deliver

00:03:13,450 --> 00:03:22,360
software faster in time and so on but

00:03:19,230 --> 00:03:24,940
and deliver the value behind your

00:03:22,360 --> 00:03:28,239
software because we develop software to

00:03:24,940 --> 00:03:32,200
deliver value to our customers to our

00:03:28,239 --> 00:03:36,519
end users but we can have a problem

00:03:32,200 --> 00:03:40,870
because the real value behind our

00:03:36,519 --> 00:03:45,810
software is that it simply should work

00:03:40,870 --> 00:03:49,170
properly and the risk that it could

00:03:45,810 --> 00:03:52,600
couldn't work properly usually is

00:03:49,170 --> 00:03:56,530
mitigated with software testing software

00:03:52,600 --> 00:03:59,470
testing is a central point is the the

00:03:56,530 --> 00:04:02,910
main important things that you have to

00:03:59,470 --> 00:04:07,299
to do to mitigate the risk that your

00:04:02,910 --> 00:04:12,519
software can work properly a bad

00:04:07,299 --> 00:04:15,910
software simply fail fails faster when

00:04:12,519 --> 00:04:19,959
you automate everything and this means

00:04:15,910 --> 00:04:24,720
that the quality the value of your

00:04:19,959 --> 00:04:28,390
software disappear quickly faster

00:04:24,720 --> 00:04:33,100
yes there is a an old saying in software

00:04:28,390 --> 00:04:37,870
testing that bad test only gives you bad

00:04:33,100 --> 00:04:41,920
results faster this is true okay

00:04:37,870 --> 00:04:47,620
so we have a lot of methodology that we

00:04:41,920 --> 00:04:50,650
can put in place and we can considering

00:04:47,620 --> 00:04:54,820
we can consider to design our test cases

00:04:50,650 --> 00:04:56,890
using several approaches this is one of

00:04:54,820 --> 00:05:02,110
the most famous the test parameters

00:04:56,890 --> 00:05:04,960
where you have the base made of your

00:05:02,110 --> 00:05:09,360
unit testing you usually have a lot of

00:05:04,960 --> 00:05:11,740
unit testing then some few left

00:05:09,360 --> 00:05:13,750
integration testing and then functional

00:05:11,740 --> 00:05:20,440
and manual and so on and you know that's

00:05:13,750 --> 00:05:23,950
the cost typically Rises going to the to

00:05:20,440 --> 00:05:26,800
the top of the pyramid and related to

00:05:23,950 --> 00:05:30,850
the concept of test pyramids you have

00:05:26,800 --> 00:05:36,040
the concept of bug filter usually test

00:05:30,850 --> 00:05:40,330
parameter brings this these effects to

00:05:36,040 --> 00:05:42,940
to your developments so the the greatest

00:05:40,330 --> 00:05:47,770
part of your bangs are filtered by the

00:05:42,940 --> 00:05:50,919
unit testing then integration tests help

00:05:47,770 --> 00:05:56,590
you to remove several other bugs and so

00:05:50,919 --> 00:05:59,250
on but sometimes some bugs some some bug

00:05:56,590 --> 00:06:02,020
can escape from your filter and

00:05:59,250 --> 00:06:05,350
presenting it in production so you have

00:06:02,020 --> 00:06:11,890
several stuck traces in your production

00:06:05,350 --> 00:06:16,810
logs and you know how can we improve

00:06:11,890 --> 00:06:20,680
this filter and if some bug escape how

00:06:16,810 --> 00:06:23,530
difficult is to reproduce it to fix it

00:06:20,680 --> 00:06:25,000
because when you have a bug the first

00:06:23,530 --> 00:06:28,360
thing you have to do the first thing

00:06:25,000 --> 00:06:32,770
that the developer have to do is to

00:06:28,360 --> 00:06:34,630
reproduce it and then to fix it you can

00:06:32,770 --> 00:06:37,300
also put in place several other

00:06:34,630 --> 00:06:39,100
practices as test

00:06:37,300 --> 00:06:41,710
development because test-driven

00:06:39,100 --> 00:06:45,880
development lets you to write just the

00:06:41,710 --> 00:06:48,430
code that you need to implement the

00:06:45,880 --> 00:06:51,630
requirements usually in test-driven

00:06:48,430 --> 00:06:54,190
development test cases are also named as

00:06:51,630 --> 00:06:56,830
executable specification this is very

00:06:54,190 --> 00:07:00,100
important if you think to a test case as

00:06:56,830 --> 00:07:03,040
an executable specification you are more

00:07:00,100 --> 00:07:06,460
focused on developing just the software

00:07:03,040 --> 00:07:08,560
you need to implement that specification

00:07:06,460 --> 00:07:10,840
and usually in test-driven development

00:07:08,560 --> 00:07:13,270
you have two phases so you write the

00:07:10,840 --> 00:07:15,670
test case the executable specification

00:07:13,270 --> 00:07:22,510
then you write the software to implement

00:07:15,670 --> 00:07:27,010
it and when you have a test successful

00:07:22,510 --> 00:07:32,800
test usually you refactor and then you

00:07:27,010 --> 00:07:35,830
have to hydrate in this process but then

00:07:32,800 --> 00:07:38,620
is there a way to know how good are your

00:07:35,830 --> 00:07:44,590
tests how good are your test cases to

00:07:38,620 --> 00:07:46,960
detect bugs and another aspect you have

00:07:44,590 --> 00:07:52,020
to consider we live in on a third genius

00:07:46,960 --> 00:07:56,530
world so your software can use a

00:07:52,020 --> 00:07:58,600
Postgres database and Mario DB you can

00:07:56,530 --> 00:08:03,720
use several application servers you know

00:07:58,600 --> 00:08:08,920
and all these configurations can lead

00:08:03,720 --> 00:08:13,000
different behaviors into your software

00:08:08,920 --> 00:08:16,000
solution how can you manage and how can

00:08:13,000 --> 00:08:21,100
you increase the coverage of your test

00:08:16,000 --> 00:08:24,670
cases in this heterogeneous world the

00:08:21,100 --> 00:08:28,800
idea is this is the idea behind stamp is

00:08:24,670 --> 00:08:36,310
to address all these issues in order to

00:08:28,800 --> 00:08:40,570
enhance the quality so stamp find is the

00:08:36,310 --> 00:08:43,870
best results in several parts in the

00:08:40,570 --> 00:08:46,130
typical DevOps cycle but you will see

00:08:43,870 --> 00:08:49,740
that this concepts are

00:08:46,130 --> 00:08:55,260
are applicable also in other country

00:08:49,740 --> 00:09:00,020
more traditional context okay and so I

00:08:55,260 --> 00:09:02,700
will go quickly to the conclusion you

00:09:00,020 --> 00:09:05,430
can have components that are able to

00:09:02,700 --> 00:09:08,310
produce variants automatically to your

00:09:05,430 --> 00:09:11,070
test cases you can have components that

00:09:08,310 --> 00:09:13,740
are able to test your test you can have

00:09:11,070 --> 00:09:16,050
components that generates variant

00:09:13,740 --> 00:09:20,310
variants of your test configurations we

00:09:16,050 --> 00:09:23,310
will see how these are a list of the

00:09:20,310 --> 00:09:25,470
main components developed at the moment

00:09:23,310 --> 00:09:27,990
in the stem project you have for

00:09:25,470 --> 00:09:33,930
instance the cart it's able to test your

00:09:27,990 --> 00:09:36,720
test injecting variations in your source

00:09:33,930 --> 00:09:39,750
code and detecting how your test cases

00:09:36,720 --> 00:09:42,720
are able to detect that variation that

00:09:39,750 --> 00:09:45,120
mutations you have this pot able to

00:09:42,720 --> 00:09:49,020
generate variants to your test cases and

00:09:45,120 --> 00:09:52,170
the camp and tech or two components able

00:09:49,020 --> 00:09:54,810
to generate variants from your test

00:09:52,170 --> 00:09:57,529
configurations made with the docker

00:09:54,810 --> 00:10:01,800
files and execute your test cases

00:09:57,529 --> 00:10:02,339
against this configuration and also Evo

00:10:01,800 --> 00:10:05,820
crash

00:10:02,339 --> 00:10:08,730
he took it takes production logs and

00:10:05,820 --> 00:10:11,070
generates a test case able to reproduce

00:10:08,730 --> 00:10:15,390
dead bugs okay

00:10:11,070 --> 00:10:18,390
and all these components can be used as

00:10:15,390 --> 00:10:20,700
standalone but you can use also within

00:10:18,390 --> 00:10:23,160
Eclipse there is an integration made by

00:10:20,700 --> 00:10:25,829
hiatus you know to use these spots

00:10:23,160 --> 00:10:29,160
within Eclipse you can use the cart

00:10:25,829 --> 00:10:32,370
within your Jenkins pipeline and it

00:10:29,160 --> 00:10:36,720
shows reports on how good you are your

00:10:32,370 --> 00:10:39,390
tests you can use camp to generate a

00:10:36,720 --> 00:10:41,670
variation of your test configurations

00:10:39,390 --> 00:10:43,740
and tick or to execute them and these

00:10:41,670 --> 00:10:48,600
components can be used as standalone or

00:10:43,740 --> 00:10:51,180
within Jenkins pipeline for instance you

00:10:48,600 --> 00:10:54,029
have ever crashed to reproduce test

00:10:51,180 --> 00:10:56,370
cases usually you feed the ba crash with

00:10:54,029 --> 00:10:59,339
the production logs and Evo crash is

00:10:56,370 --> 00:10:59,790
able to generate new test cases to

00:10:59,339 --> 00:11:03,630
repeat

00:10:59,790 --> 00:11:06,300
to reproduce that bug you can also try

00:11:03,630 --> 00:11:10,110
stamp within a virtual machine and the

00:11:06,300 --> 00:11:13,410
Stamper virtual lab so it's very easy to

00:11:10,110 --> 00:11:15,780
start with stamp and in this way you can

00:11:13,410 --> 00:11:19,050
enhance your pipeline putting stem

00:11:15,780 --> 00:11:24,540
components in several stages of your

00:11:19,050 --> 00:11:28,080
pipeline conclusions if you want to try

00:11:24,540 --> 00:11:30,270
of course you can find several tutorials

00:11:28,080 --> 00:11:33,620
but I think that the most important

00:11:30,270 --> 00:11:37,260
thing is that Stamper simply don't

00:11:33,620 --> 00:11:40,200
generate automatically software no stamp

00:11:37,260 --> 00:11:43,110
needs of course that you design your

00:11:40,200 --> 00:11:45,750
test cases and then it can be it can

00:11:43,110 --> 00:11:50,220
enhance your test cases stamp requires

00:11:45,750 --> 00:11:53,550
that you design your test configuration

00:11:50,220 --> 00:11:57,170
and then it will enhance and amplify and

00:11:53,550 --> 00:12:01,650
execute them for you so at the moment

00:11:57,170 --> 00:12:07,100
computers need humans as well as human

00:12:01,650 --> 00:12:10,410
needs computers and now we have several

00:12:07,100 --> 00:12:13,110
steps that we want to achieve in the in

00:12:10,410 --> 00:12:16,550
the remaining of the project optimizing

00:12:13,110 --> 00:12:18,870
the source code exposing stamp

00:12:16,550 --> 00:12:22,710
functionalities as micro-services

00:12:18,870 --> 00:12:26,850
and adding more integration in github

00:12:22,710 --> 00:12:28,590
gitlab jenkins and so on you will see so

00:12:26,850 --> 00:12:31,710
if you're interested you can go to the

00:12:28,590 --> 00:12:34,800
official websites you'll see the

00:12:31,710 --> 00:12:38,190
references the the same source code is

00:12:34,800 --> 00:12:41,610
on github and several tutorials are over

00:12:38,190 --> 00:12:45,650
there ok thank you if you have any

00:12:41,610 --> 00:12:45,650

YouTube URL: https://www.youtube.com/watch?v=Y_B6prCmS2w


