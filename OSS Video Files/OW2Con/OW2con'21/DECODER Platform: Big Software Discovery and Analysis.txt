Title: DECODER Platform: Big Software Discovery and Analysis
Publication date: 2021-06-30
Playlist: OW2con'21
Description: 
	The DECODER open source platform combines information from different sources to share big software knowledge between developers, testers and maintainers. This centralized knowledge contains very heterogeneous documents (code, comments, documentation, formal specifications, tests and static analysis reports, etc.). A set of NLP-based tools is trained to extract relevant semantic information and find correspondences between the documents, either to provide accurate code summarization or to generate a formal view of a plain-text document, which can then be fed to code analyzers.
Captions: 
	00:00:02,970 --> 00:00:06,829
[Music]

00:00:09,750 --> 00:00:17,760
[Music]

00:00:18,080 --> 00:00:21,760
hello and thank you for attending this

00:00:19,840 --> 00:00:23,680
presentation of the decoder platform for

00:00:21,760 --> 00:00:26,480
software analysis

00:00:23,680 --> 00:00:28,160
i'm virgil provosto from clist in france

00:00:26,480 --> 00:00:29,359
and i'm acting as technical leader of

00:00:28,160 --> 00:00:33,199
the decoder project

00:00:29,359 --> 00:00:33,199
that i'm about to present

00:00:33,840 --> 00:00:38,000
in a few words decoder is an h2020

00:00:37,280 --> 00:00:41,280
project

00:00:38,000 --> 00:00:43,200
started in january 2019

00:00:41,280 --> 00:00:45,039
meaning that we are now nearing the end

00:00:43,200 --> 00:00:47,520
of the project

00:00:45,039 --> 00:00:49,280
its main aim is to provide a unified

00:00:47,520 --> 00:00:50,079
platform the persistent knowledge

00:00:49,280 --> 00:00:53,039
monitor

00:00:50,079 --> 00:00:55,199
or pcm for short for holding and

00:00:53,039 --> 00:00:56,800
managing all types of documents that are

00:00:55,199 --> 00:00:59,120
used throughout the lifecycle of a

00:00:56,800 --> 00:01:01,120
software system

00:00:59,120 --> 00:01:02,960
this includes for instance design and

00:01:01,120 --> 00:01:06,159
requirements documents

00:01:02,960 --> 00:01:08,960
the code itself of course its comments

00:01:06,159 --> 00:01:10,159
user manuals formal specifications if

00:01:08,960 --> 00:01:12,960
any

00:01:10,159 --> 00:01:14,479
test and static analysis reports and so

00:01:12,960 --> 00:01:17,520
on

00:01:14,479 --> 00:01:20,400
as i said the pkm is meant to be used

00:01:17,520 --> 00:01:22,080
all along all the phases of the software

00:01:20,400 --> 00:01:24,720
development cycle

00:01:22,080 --> 00:01:26,880
and for reflecting that three main walls

00:01:24,720 --> 00:01:30,000
have been identified

00:01:26,880 --> 00:01:32,400
developers who need to write the code

00:01:30,000 --> 00:01:34,079
reviewers who assess whether the code is

00:01:32,400 --> 00:01:37,119
fit for relays

00:01:34,079 --> 00:01:39,439
and maintainers who have to come back at

00:01:37,119 --> 00:01:42,000
the code base some time later

00:01:39,439 --> 00:01:42,720
sometimes much much later when little

00:01:42,000 --> 00:01:48,000
information

00:01:42,720 --> 00:01:49,680
is still available for the code

00:01:48,000 --> 00:01:51,280
in order to accommodate the various

00:01:49,680 --> 00:01:53,520
needs

00:01:51,280 --> 00:01:56,799
some work in decoder has been dedicated

00:01:53,520 --> 00:02:00,159
to proposed methodological guidelines

00:01:56,799 --> 00:02:04,399
supported by a convenient user interface

00:02:00,159 --> 00:02:06,240
and deployed over a set of use cases

00:02:04,399 --> 00:02:08,080
finally there are two main categories of

00:02:06,240 --> 00:02:09,119
tools that are meant to interact with

00:02:08,080 --> 00:02:12,080
the pgm

00:02:09,119 --> 00:02:13,120
itself on the one hand software

00:02:12,080 --> 00:02:15,760
engineering tools

00:02:13,120 --> 00:02:16,480
static analyzers test case generators

00:02:15,760 --> 00:02:19,599
modeler

00:02:16,480 --> 00:02:20,800
and so on and natural language

00:02:19,599 --> 00:02:22,640
processing tools

00:02:20,800 --> 00:02:23,840
for finding correspondences between the

00:02:22,640 --> 00:02:28,400
various documents

00:02:23,840 --> 00:02:28,400
but into the pkm

00:02:29,920 --> 00:02:33,280
since it is supposed to handle a very

00:02:32,160 --> 00:02:36,959
heterogeneous

00:02:33,280 --> 00:02:39,680
sets of documents at its earth

00:02:36,959 --> 00:02:40,800
the pkm itself is a document oriented

00:02:39,680 --> 00:02:44,640
database

00:02:40,800 --> 00:02:48,560
namely a mongodb instance

00:02:44,640 --> 00:02:50,400
on top of mongodb's javascript api the

00:02:48,560 --> 00:02:53,040
pkm core

00:02:50,400 --> 00:02:54,480
api provides very low level

00:02:53,040 --> 00:02:55,760
functionalities for managing the

00:02:54,480 --> 00:02:57,680
database

00:02:55,760 --> 00:02:59,280
it can be accessed directly from the

00:02:57,680 --> 00:03:02,319
command line

00:02:59,280 --> 00:03:04,879
or through a javascript sdk for instance

00:03:02,319 --> 00:03:09,760
to integrate a new tool

00:03:04,879 --> 00:03:13,200
to communicate with the pcm but

00:03:09,760 --> 00:03:16,879
for everyday usage there's also

00:03:13,200 --> 00:03:20,319
a higher level api

00:03:16,879 --> 00:03:23,360
in the form of restful https

00:03:20,319 --> 00:03:27,280
server which uses uh

00:03:23,360 --> 00:03:31,840
requests described with the open api

00:03:27,280 --> 00:03:34,239
framework which means that

00:03:31,840 --> 00:03:36,720
bindings readily available for a wide

00:03:34,239 --> 00:03:40,799
variety of programming languages

00:03:36,720 --> 00:03:43,760
facilitating of course interoperability

00:03:40,799 --> 00:03:44,840
similarly the deployment of the pkm and

00:03:43,760 --> 00:03:47,680
its tools

00:03:44,840 --> 00:03:50,799
is facilitated by the use of

00:03:47,680 --> 00:03:51,920
docker containers and docker composer

00:03:50,799 --> 00:03:54,400
scripts

00:03:51,920 --> 00:03:56,000
depending of the set of tools that one

00:03:54,400 --> 00:03:59,120
wants to deploy

00:03:56,000 --> 00:03:59,120
on a given platform

00:03:59,439 --> 00:04:04,319
finally the api is available through

00:04:02,879 --> 00:04:07,760
open source licenses

00:04:04,319 --> 00:04:12,640
namely hpl and apache and

00:04:07,760 --> 00:04:15,840
can be found on ow tools gitlab

00:04:12,640 --> 00:04:15,840
at this url

00:04:19,280 --> 00:04:22,720
as i said several tools have been bound

00:04:21,519 --> 00:04:26,479
to the pcm

00:04:22,720 --> 00:04:28,880
during the decoder project

00:04:26,479 --> 00:04:30,800
first among software analysis tools we

00:04:28,880 --> 00:04:34,800
find a tester a test

00:04:30,800 --> 00:04:37,600
generator for graphical user interfaces

00:04:34,800 --> 00:04:38,160
from sc and opengl for more verification

00:04:37,600 --> 00:04:41,840
tools

00:04:38,160 --> 00:04:44,800
for respectively c and c plus plus and

00:04:41,840 --> 00:04:44,800
java programs

00:04:45,199 --> 00:04:50,800
we also have gml gen which is aimed at

00:04:48,240 --> 00:04:51,600
generating simple gml annotations from

00:04:50,800 --> 00:04:54,720
java code

00:04:51,600 --> 00:04:57,759
for instance to assess that

00:04:54,720 --> 00:05:02,400
an object is never null null when

00:04:57,759 --> 00:05:02,400
given to a specific method

00:05:02,800 --> 00:05:06,080
then we find language processing tools

00:05:05,600 --> 00:05:08,320
that

00:05:06,080 --> 00:05:10,160
extract information either from the

00:05:08,320 --> 00:05:14,479
source code

00:05:10,160 --> 00:05:16,080
are from the accompanying documentation

00:05:14,479 --> 00:05:18,000
and attempt to find correspondences

00:05:16,080 --> 00:05:21,039
between the documents

00:05:18,000 --> 00:05:22,240
and that ability to trace the

00:05:21,039 --> 00:05:25,280
implementation of

00:05:22,240 --> 00:05:29,680
the original requirements of the system

00:05:25,280 --> 00:05:29,680
within the implementing code

00:05:30,080 --> 00:05:33,440
another important aspect of decoder is

00:05:32,320 --> 00:05:37,039
the development of the

00:05:33,440 --> 00:05:38,320
acfm language for abstract semi-formal

00:05:37,039 --> 00:05:40,240
modeling

00:05:38,320 --> 00:05:42,400
which is meant to act as an intermediate

00:05:40,240 --> 00:05:42,720
step between natural language documents

00:05:42,400 --> 00:05:45,600
and

00:05:42,720 --> 00:05:47,600
fully formal specifications i'll come

00:05:45,600 --> 00:05:51,600
back to that in the next slide but

00:05:47,600 --> 00:05:54,560
for now i'd just like to mention that

00:05:51,600 --> 00:05:55,520
there are prototype tools to convert to

00:05:54,560 --> 00:05:58,639
and from

00:05:55,520 --> 00:05:58,639
sfm documents

00:05:59,039 --> 00:06:02,400
finally we have a browser-based

00:06:01,280 --> 00:06:06,560
front-end for

00:06:02,400 --> 00:06:09,280
the pgm and its society tools

00:06:06,560 --> 00:06:11,360
which also has the ability to use

00:06:09,280 --> 00:06:16,800
jupiter notebooks

00:06:11,360 --> 00:06:16,800
to deal with the pkm documents

00:06:19,199 --> 00:06:24,400
focusing now on natural language

00:06:21,440 --> 00:06:24,400
processing tools

00:06:25,759 --> 00:06:30,000
in the context of the extraction of

00:06:27,360 --> 00:06:34,080
information from the source code itself

00:06:30,000 --> 00:06:37,120
it has basically been used

00:06:34,080 --> 00:06:40,639
for two main things first to identify

00:06:37,120 --> 00:06:42,400
potential variable misused within the

00:06:40,639 --> 00:06:46,000
code

00:06:42,400 --> 00:06:49,840
and more generally to suggest

00:06:46,000 --> 00:06:53,520
some code repair for simple cases

00:06:49,840 --> 00:06:55,680
for instance to propose

00:06:53,520 --> 00:06:56,880
what the tool thinks is the appropriate

00:06:55,680 --> 00:07:00,400
symbol when

00:06:56,880 --> 00:07:02,400
a misuse has been detected

00:07:00,400 --> 00:07:03,680
in the other direction from natural

00:07:02,400 --> 00:07:05,680
language to code

00:07:03,680 --> 00:07:06,960
most of the work has been dedicated to

00:07:05,680 --> 00:07:10,080
semantic passing

00:07:06,960 --> 00:07:11,520
and the semantic role labeling in order

00:07:10,080 --> 00:07:14,880
to identify the

00:07:11,520 --> 00:07:17,520
entities described in the documentation

00:07:14,880 --> 00:07:19,039
and to be able to map them to variables

00:07:17,520 --> 00:07:23,360
and functions

00:07:19,039 --> 00:07:25,360
in the code this has also resulted in a

00:07:23,360 --> 00:07:26,479
first version of the traceability matrix

00:07:25,360 --> 00:07:30,479
builder that

00:07:26,479 --> 00:07:34,319
aims as i said that showing the user

00:07:30,479 --> 00:07:35,919
and this context reviewer role

00:07:34,319 --> 00:07:38,880
which parts of the code implement a

00:07:35,919 --> 00:07:38,880
given requirement

00:07:40,639 --> 00:07:45,520
reading asfm first nation of the

00:07:43,039 --> 00:07:49,520
language has been defined for describing

00:07:45,520 --> 00:07:52,720
state machines diagrams in particular

00:07:49,520 --> 00:07:54,160
and various tools have been developed on

00:07:52,720 --> 00:07:56,960
top of it

00:07:54,160 --> 00:07:58,960
first it's possible to generate sfn

00:07:56,960 --> 00:08:03,199
diagrams from standard document

00:07:58,960 --> 00:08:04,960
formats pdf and logix namely

00:08:03,199 --> 00:08:06,960
potentially we're using custom

00:08:04,960 --> 00:08:09,919
definitions if user

00:08:06,960 --> 00:08:13,280
defined parser is given in addition to

00:08:09,919 --> 00:08:15,840
the command tool

00:08:13,280 --> 00:08:17,280
the reverse direction the generation of

00:08:15,840 --> 00:08:20,319
dockex or pdf

00:08:17,280 --> 00:08:23,919
from an sfm diagram is of course

00:08:20,319 --> 00:08:28,879
also possible and we also have tools to

00:08:23,919 --> 00:08:32,320
generate directly sfm templates from

00:08:28,879 --> 00:08:34,479
code or implementation first

00:08:32,320 --> 00:08:37,760
test start and generate diagrams to

00:08:34,479 --> 00:08:41,760
display the information it has gathered

00:08:37,760 --> 00:08:46,480
from the ui under test

00:08:41,760 --> 00:08:49,360
and another tool is excavator

00:08:46,480 --> 00:08:51,120
which is has been developed to abstract

00:08:49,360 --> 00:08:52,399
away the internal state of the linux

00:08:51,120 --> 00:08:54,080
kernel

00:08:52,399 --> 00:08:56,000
in order to provide an appropriate

00:08:54,080 --> 00:08:59,040
context for the analysis of

00:08:56,000 --> 00:09:01,519
a driver which is one of the use cases

00:08:59,040 --> 00:09:03,920
of decoder as we will see in the next

00:09:01,519 --> 00:09:03,920
slides

00:09:04,000 --> 00:09:09,600
finally asf endeavors can be animated by

00:09:06,959 --> 00:09:12,959
a graphical debugger

00:09:09,600 --> 00:09:16,080
that uses information given by

00:09:12,959 --> 00:09:17,200
gdb and displays them according to the

00:09:16,080 --> 00:09:22,399
abstractions

00:09:17,200 --> 00:09:25,120
made in the diagram

00:09:22,399 --> 00:09:26,080
i will briefly speak about the front end

00:09:25,120 --> 00:09:28,720
now

00:09:26,080 --> 00:09:29,360
so as i said it is browser-based and

00:09:28,720 --> 00:09:34,000
uses

00:09:29,360 --> 00:09:36,800
the popular angularjs framework

00:09:34,000 --> 00:09:37,279
it first the basic support for the main

00:09:36,800 --> 00:09:40,160
tools

00:09:37,279 --> 00:09:41,360
feeding the pkm such as gem agent star

00:09:40,160 --> 00:09:45,440
from a c

00:09:41,360 --> 00:09:47,600
and so on it has also a dedicated view

00:09:45,440 --> 00:09:51,360
for the traceability metrics

00:09:47,600 --> 00:09:55,120
between requirements and code

00:09:51,360 --> 00:09:58,240
and as i said uh you can

00:09:55,120 --> 00:10:00,640
directly import gpt notebooks

00:09:58,240 --> 00:10:01,680
within the front end and interact with

00:10:00,640 --> 00:10:04,880
the pcm

00:10:01,680 --> 00:10:09,040
that way it is

00:10:04,880 --> 00:10:09,040
under ev development right now

00:10:09,920 --> 00:10:15,200
especially with feedback from the use

00:10:12,800 --> 00:10:15,200
cases

00:10:15,920 --> 00:10:21,760
namely pkm tools and the pcm itself have

00:10:19,920 --> 00:10:22,880
been experimented on all the projects

00:10:21,760 --> 00:10:24,959
that have been selected

00:10:22,880 --> 00:10:26,560
as use cases in the first phase of

00:10:24,959 --> 00:10:29,920
decoder

00:10:26,560 --> 00:10:33,360
namely 4c 2

00:10:29,920 --> 00:10:37,600
drivers from linux

00:10:33,360 --> 00:10:40,880
a simple watchdog and a more involved

00:10:37,600 --> 00:10:44,560
ethernet driver for c

00:10:40,880 --> 00:10:47,760
plus plus we rely mainly on the opencv

00:10:44,560 --> 00:10:51,760
2d graphics library and

00:10:47,760 --> 00:10:51,760
for java there's

00:10:51,839 --> 00:10:55,760
a sample restaurant reservation system

00:10:53,839 --> 00:10:59,040
called maitai star which is

00:10:55,760 --> 00:11:03,040
meant to showcase best practices and

00:10:59,040 --> 00:11:06,480
uh four ow two projects

00:11:03,040 --> 00:11:10,480
all set forth and joram leutis and

00:11:06,480 --> 00:11:11,680
site4g in addition to experimenting with

00:11:10,480 --> 00:11:14,880
the main platform

00:11:11,680 --> 00:11:17,440
as i said this was also the occasion to

00:11:14,880 --> 00:11:21,040
develop new helper tools

00:11:17,440 --> 00:11:26,079
namely gml gen and excavator

00:11:21,040 --> 00:11:29,279
as well as experimenting with dr sfm

00:11:26,079 --> 00:11:33,120
furthermore we also gathered the data

00:11:29,279 --> 00:11:36,720
to enhance the result of nlp tools since

00:11:33,120 --> 00:11:38,880
as always with ai based techniques

00:11:36,720 --> 00:11:41,279
it is important to have a sufficiently

00:11:38,880 --> 00:11:44,480
large training data set

00:11:41,279 --> 00:11:47,279
to obtain a suitable performance

00:11:44,480 --> 00:11:47,279
for the tools

00:11:48,079 --> 00:11:51,839
so in summary the work done so far

00:11:50,560 --> 00:11:53,279
resulting in

00:11:51,839 --> 00:11:56,079
resulted in a fairly robust

00:11:53,279 --> 00:11:57,600
infrastructure for the pcm itself

00:11:56,079 --> 00:11:59,680
with a good connection with the

00:11:57,600 --> 00:12:01,360
individual tools that are meant to

00:11:59,680 --> 00:12:06,240
interact with it

00:12:01,360 --> 00:12:07,920
and interesting results on the use cases

00:12:06,240 --> 00:12:09,440
regarding what you want to do in the

00:12:07,920 --> 00:12:12,480
last six months

00:12:09,440 --> 00:12:16,160
of the project first

00:12:12,480 --> 00:12:19,519
we have to finalize the ui and

00:12:16,160 --> 00:12:22,959
to adapt the methodology based on the

00:12:19,519 --> 00:12:26,079
work done in the use cases

00:12:22,959 --> 00:12:28,480
similarly uh individual tools

00:12:26,079 --> 00:12:29,360
need also to be enhanced to better match

00:12:28,480 --> 00:12:33,279
the user's

00:12:29,360 --> 00:12:35,360
needs and finally

00:12:33,279 --> 00:12:36,800
interactions between the tools need to

00:12:35,360 --> 00:12:40,639
be refined

00:12:36,800 --> 00:12:42,639
on the one end by extending asfm

00:12:40,639 --> 00:12:45,440
and it's accompanying tools to propose

00:12:42,639 --> 00:12:48,560
the finer descriptions

00:12:45,440 --> 00:12:50,000
of the code and on the other hand by

00:12:48,560 --> 00:12:53,600
reinforcing links

00:12:50,000 --> 00:12:57,360
between nlp tools and asfm

00:12:53,600 --> 00:13:01,360
acting as we say before

00:12:57,360 --> 00:13:04,480
as an intermediate step between

00:13:01,360 --> 00:13:05,600
informal documents in plain natural

00:13:04,480 --> 00:13:09,680
language

00:13:05,600 --> 00:13:09,680
and fully formal specifications

00:13:11,440 --> 00:13:15,839
okay so this concludes what i wanted to

00:13:14,000 --> 00:13:18,880
say about decoder

00:13:15,839 --> 00:13:21,040
thanks again for your attention and feel

00:13:18,880 --> 00:13:24,160
free to ask any question

00:13:21,040 --> 00:13:33,360
now or to contact us

00:13:24,160 --> 00:13:33,360

YouTube URL: https://www.youtube.com/watch?v=TPIabVznGLw


