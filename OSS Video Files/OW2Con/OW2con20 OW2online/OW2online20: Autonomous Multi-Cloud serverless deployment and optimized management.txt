Title: OW2online20: Autonomous Multi-Cloud serverless deployment and optimized management
Publication date: 2020-06-22
Playlist: OW2con20 OW2online
Description: 
	Autonomous Multi-Cloud serverless deployment and optimized management
( Marta Różańska, Geir Horn )
This presentation describes how to implement Multi-Cloud native strategies using advanced an open source framework that allows for Cloud-agnostic Multi-Cloud deployment and optimized management of the serverless applications based on flexible monitoring, context aware maximization of the application owner’s utility of the deployed serverless components, and autonomic reconfiguration based on the application’s current execution context.
Captions: 
	00:00:01,300 --> 00:00:04,399
[Music]

00:00:13,040 --> 00:00:18,859
so welcome to this presentation on

00:00:16,099 --> 00:00:21,500
autonomous with clouds left comment and

00:00:18,859 --> 00:00:23,300
optimization management but the melody

00:00:21,500 --> 00:00:26,539
platform which is an open source

00:00:23,300 --> 00:00:29,179
middleware that allows you to deploy

00:00:26,539 --> 00:00:33,949
your application with the cloud and this

00:00:29,179 --> 00:00:35,690
is done by mckernon by myself so the

00:00:33,949 --> 00:00:39,140
idea behind the logic is that we have

00:00:35,690 --> 00:00:42,500
the need to deploy an application in a

00:00:39,140 --> 00:00:44,780
vista cloud setting and often also cost

00:00:42,500 --> 00:00:47,000
clouds so that we are using many clouds

00:00:44,780 --> 00:00:49,399
at the same time including for instance

00:00:47,000 --> 00:00:51,070
a private cloud and a public cloud from

00:00:49,399 --> 00:00:55,129
from a public cloud Kawada

00:00:51,070 --> 00:00:58,489
now this application is then monitoring

00:00:55,129 --> 00:01:00,800
and during runtime and if it needs to be

00:00:58,489 --> 00:01:03,230
changed and the configuration and the

00:01:00,800 --> 00:01:05,720
resources offered to the application

00:01:03,230 --> 00:01:07,460
needs to be changed then melodic will

00:01:05,720 --> 00:01:09,380
automatically reconfigure the

00:01:07,460 --> 00:01:12,530
application and the good thing about

00:01:09,380 --> 00:01:15,679
melodic is that it supports cross cloud

00:01:12,530 --> 00:01:17,420
so as I said many application any cloud

00:01:15,679 --> 00:01:20,330
providers at the same time of the

00:01:17,420 --> 00:01:23,899
application and it is fully open source

00:01:20,330 --> 00:01:26,810
based on open source frameworks so why

00:01:23,899 --> 00:01:29,239
would we start the melodic project and

00:01:26,810 --> 00:01:33,080
develop this platform well the first is

00:01:29,239 --> 00:01:35,450
that this problem using multiple cloud

00:01:33,080 --> 00:01:36,890
providers and it isn't even a larger

00:01:35,450 --> 00:01:38,869
problem you see multiple cloud providers

00:01:36,890 --> 00:01:41,989
at the same time so we wanted to have

00:01:38,869 --> 00:01:44,360
one single interface to all these cloud

00:01:41,989 --> 00:01:47,660
providers we also wanted to have a

00:01:44,360 --> 00:01:51,649
unified way to develop to deploy

00:01:47,660 --> 00:01:55,039
different application components such as

00:01:51,649 --> 00:01:58,340
virtual machines containers and service

00:01:55,039 --> 00:02:00,950
functions and all this respecting the

00:01:58,340 --> 00:02:03,739
data constraints and and the data that

00:02:00,950 --> 00:02:05,690
the application is operating upon and

00:02:03,739 --> 00:02:08,810
the last part is especially important

00:02:05,690 --> 00:02:11,270
principle in Europe where you have GDP

00:02:08,810 --> 00:02:15,430
Arkansas lowary and store and I'm

00:02:11,270 --> 00:02:19,459
operate on beta we also wanted to have

00:02:15,430 --> 00:02:21,409
autonomic deployment because changes

00:02:19,459 --> 00:02:23,599
might be needed to do resources of your

00:02:21,409 --> 00:02:26,480
application at times when you are not

00:02:23,599 --> 00:02:28,760
available and where you

00:02:26,480 --> 00:02:30,830
like your application to stay responsive

00:02:28,760 --> 00:02:34,640
to the application users even if there

00:02:30,830 --> 00:02:39,379
is no person that is able to deploy the

00:02:34,640 --> 00:02:40,849
application on your behalf 24/7 so that

00:02:39,379 --> 00:02:43,340
means we need to have some kind of an

00:02:40,849 --> 00:02:45,620
automatic optimization of the cloud

00:02:43,340 --> 00:02:48,440
resources that are used our unification

00:02:45,620 --> 00:02:50,959
so with melodic is able to scale out the

00:02:48,440 --> 00:02:54,140
resources I needed and scaling again

00:02:50,959 --> 00:02:57,560
when when it's no longer need so what

00:02:54,140 --> 00:02:59,840
are the key features all melodic well so

00:02:57,560 --> 00:03:02,000
that it's automatically for

00:02:59,840 --> 00:03:04,129
mathematically is sort of the key thing

00:03:02,000 --> 00:03:06,049
here but melodic takes care of your

00:03:04,129 --> 00:03:08,959
application it acts on your behalf so

00:03:06,049 --> 00:03:11,989
the application and it does so in order

00:03:08,959 --> 00:03:14,359
to maximize the utility of the

00:03:11,989 --> 00:03:17,079
application seen from your point as the

00:03:14,359 --> 00:03:19,519
application owner so it's based on the

00:03:17,079 --> 00:03:21,170
application type statistics and the

00:03:19,519 --> 00:03:23,180
measurement the real application and

00:03:21,170 --> 00:03:25,849
then it tries to be configured to the

00:03:23,180 --> 00:03:28,910
best possible way it supports Big Data

00:03:25,849 --> 00:03:31,660
frameworks like Hadoop and spark and it

00:03:28,910 --> 00:03:34,010
does so in respect of the day

00:03:31,660 --> 00:03:36,919
constraints that you have so if data

00:03:34,010 --> 00:03:40,069
cannot be moved this data has to be on a

00:03:36,919 --> 00:03:43,400
local server then a melodic will deploy

00:03:40,069 --> 00:03:44,959
the computational components to where

00:03:43,400 --> 00:03:49,030
the data is and not the other way around

00:03:44,959 --> 00:03:52,040
and finally it is also secure so it

00:03:49,030 --> 00:03:55,069
supports a single secure authentication

00:03:52,040 --> 00:03:57,380
of the application used on the sewers

00:03:55,069 --> 00:04:00,530
are only these authorized users can

00:03:57,380 --> 00:04:04,310
deploy applications your application to

00:04:00,530 --> 00:04:07,370
the cloud and it be to be incapacitated

00:04:04,310 --> 00:04:10,430
by that you mean it should be highly

00:04:07,370 --> 00:04:14,569
available and any Milotic itself is

00:04:10,430 --> 00:04:16,519
scalable so that you can ask it to the

00:04:14,569 --> 00:04:23,760
growing complicated applications or

00:04:16,519 --> 00:04:25,560
simple applications a nice

00:04:23,760 --> 00:04:27,180
application modeling and execution

00:04:25,560 --> 00:04:30,060
language and it is used to model

00:04:27,180 --> 00:04:32,430
application it is a domain-specific and

00:04:30,060 --> 00:04:34,140
cloud provider agnostic language based

00:04:32,430 --> 00:04:37,350
on eclipse modeling framework and

00:04:34,140 --> 00:04:39,990
similar to Tosca it covers all aspects

00:04:37,350 --> 00:04:41,310
of application modeling it's possible to

00:04:39,990 --> 00:04:43,080
model in kernel the application

00:04:41,310 --> 00:04:45,870
component connections between them

00:04:43,080 --> 00:04:48,060
security aspects it supports various

00:04:45,870 --> 00:04:49,920
types of application components scripts

00:04:48,060 --> 00:04:52,550
base part of components docker

00:04:49,920 --> 00:04:54,690
containers and service components

00:04:52,550 --> 00:04:56,730
they'll also surfer complex

00:04:54,690 --> 00:04:58,950
infrastructure requirements modeling and

00:04:56,730 --> 00:05:01,200
what is probably the most important and

00:04:58,950 --> 00:05:03,360
unique it allows for modeling confuse

00:05:01,200 --> 00:05:05,730
your preferences utility function and

00:05:03,360 --> 00:05:08,820
constraints it makes the optimization

00:05:05,730 --> 00:05:10,920
process in melody possible what is more

00:05:08,820 --> 00:05:13,500
it supports models at runtime modeling

00:05:10,920 --> 00:05:16,020
is used to express the application state

00:05:13,500 --> 00:05:18,090
during the runtime in other words it

00:05:16,020 --> 00:05:19,980
supports the description of application

00:05:18,090 --> 00:05:22,320
state before it starts to be deployed

00:05:19,980 --> 00:05:25,380
during optimization and when the

00:05:22,320 --> 00:05:27,810
application is running tamil is built

00:05:25,380 --> 00:05:30,330
from modules it currently contains many

00:05:27,810 --> 00:05:32,150
modules and it will have more because

00:05:30,330 --> 00:05:34,560
they are work in progress on extensions

00:05:32,150 --> 00:05:36,930
what is important to notice is the fact

00:05:34,560 --> 00:05:39,450
that these modules can be reused in more

00:05:36,930 --> 00:05:41,100
than one common application model for

00:05:39,450 --> 00:05:43,740
example in the melodic we have some

00:05:41,100 --> 00:05:48,060
predefined metric models that are reused

00:05:43,740 --> 00:05:51,030
in many application models how does the

00:05:48,060 --> 00:05:52,350
melodic work firstly user needs to

00:05:51,030 --> 00:05:54,420
create a common model for his

00:05:52,350 --> 00:05:56,760
application and set up initial

00:05:54,420 --> 00:06:00,030
parameters for the application after

00:05:56,760 --> 00:06:02,070
that melodic start the work it downloads

00:06:00,030 --> 00:06:04,620
the offers from all cloud providers that

00:06:02,070 --> 00:06:06,840
user has access it calculates the best

00:06:04,620 --> 00:06:10,080
cloud environment for application and

00:06:06,840 --> 00:06:12,030
deploys it automatically the reasoning

00:06:10,080 --> 00:06:14,100
part is done by solving a constraint

00:06:12,030 --> 00:06:16,770
optimization problem maximizing the

00:06:14,100 --> 00:06:19,560
utility function automatically generated

00:06:16,770 --> 00:06:21,630
from the camel model to solve the

00:06:19,560 --> 00:06:24,420
constraint problems melodic uses various

00:06:21,630 --> 00:06:25,950
solvers among others as the hostak

00:06:24,420 --> 00:06:27,930
learning automata solver

00:06:25,950 --> 00:06:32,310
based on ray forcement learning and

00:06:27,930 --> 00:06:34,650
Monte Carlo tree search server currently

00:06:32,310 --> 00:06:37,620
monadic supports deployment on big cloud

00:06:34,650 --> 00:06:41,550
providers like AWS GCP or

00:06:37,620 --> 00:06:44,040
and also OpenStack when the application

00:06:41,550 --> 00:06:46,080
is ready and working melodic starts

00:06:44,040 --> 00:06:48,990
collecting defined by the user metrics

00:06:46,080 --> 00:06:51,240
about currently running configuration if

00:06:48,990 --> 00:06:53,550
the better solution appears or actual

00:06:51,240 --> 00:06:55,380
solution becomes unacceptable because

00:06:53,550 --> 00:06:58,199
one of the constraints to the

00:06:55,380 --> 00:07:00,060
configuration is triggered whether they

00:06:58,199 --> 00:07:02,250
can continue basic looking for better

00:07:00,060 --> 00:07:04,860
solution for deployment and to make the

00:07:02,250 --> 00:07:06,690
configuration if newly found solution is

00:07:04,860 --> 00:07:09,360
significantly better than the current

00:07:06,690 --> 00:07:11,400
one it means that it can move

00:07:09,360 --> 00:07:14,190
application components to another cloud

00:07:11,400 --> 00:07:17,010
provider to another virtual machine at

00:07:14,190 --> 00:07:19,310
marine status or whatever melodic

00:07:17,010 --> 00:07:21,930
establishes the best deployment

00:07:19,310 --> 00:07:24,780
therefore during the application

00:07:21,930 --> 00:07:30,690
execution melodic manages to always have

00:07:24,780 --> 00:07:34,880
the most optimal environment so what is

00:07:30,690 --> 00:07:40,139
the best deployment when it comes to

00:07:34,880 --> 00:07:43,139
melodic well what we do is we are first

00:07:40,139 --> 00:07:44,789
going to collect metrics of the running

00:07:43,139 --> 00:07:47,520
application which means that these

00:07:44,789 --> 00:07:50,070
metric values are representing the

00:07:47,520 --> 00:07:52,889
current configuration of the application

00:07:50,070 --> 00:07:54,479
and the current context or how many uses

00:07:52,889 --> 00:07:58,380
the potential has for instance can be

00:07:54,479 --> 00:08:00,270
one of these metric values or the time

00:07:58,380 --> 00:08:02,789
it takes to produce result can be

00:08:00,270 --> 00:08:04,860
another metric value and this provides

00:08:02,789 --> 00:08:07,289
for a very flexible way to talk place

00:08:04,860 --> 00:08:08,820
the utility for this particular complex

00:08:07,289 --> 00:08:11,120
so for this particular number of user

00:08:08,820 --> 00:08:13,530
senses what will then be the best

00:08:11,120 --> 00:08:16,260
utility for you as the owner of the

00:08:13,530 --> 00:08:18,360
application this means that the focus

00:08:16,260 --> 00:08:21,810
will be on the business value rather

00:08:18,360 --> 00:08:25,860
than on the technicalities of collecting

00:08:21,810 --> 00:08:29,070
the metric values and making the right

00:08:25,860 --> 00:08:32,640
decision and that in this particular

00:08:29,070 --> 00:08:34,260
context and of course in all

00:08:32,640 --> 00:08:36,539
optimization there there might be

00:08:34,260 --> 00:08:38,640
trade-offs between cost performance and

00:08:36,539 --> 00:08:42,060
this kind of availability issues

00:08:38,640 --> 00:08:44,310
whatever you represent in the utility

00:08:42,060 --> 00:08:46,470
and melodic aims to do that

00:08:44,310 --> 00:08:48,860
automatically for you so if you have

00:08:46,470 --> 00:08:50,390
formulated and good utility and

00:08:48,860 --> 00:08:53,840
balancing these

00:08:50,390 --> 00:08:56,480
front concerns then melodic we make sure

00:08:53,840 --> 00:09:00,260
that this is the best possible

00:08:56,480 --> 00:09:01,970
deployment on based on your utility so

00:09:00,260 --> 00:09:03,370
let's look at an example for instance

00:09:01,970 --> 00:09:06,860
say that you have an image recognition

00:09:03,370 --> 00:09:10,280
application where the actual image

00:09:06,860 --> 00:09:13,280
recognizer function or classifier is a

00:09:10,280 --> 00:09:15,800
function that you deploy to a service

00:09:13,280 --> 00:09:17,630
platform so the first monadic we do in

00:09:15,800 --> 00:09:21,590
this case is to deploy the actual

00:09:17,630 --> 00:09:23,930
recognizer function which is the katadyn

00:09:21,590 --> 00:09:26,660
and then once up running it will start

00:09:23,930 --> 00:09:29,840
causing images coming in and produce

00:09:26,660 --> 00:09:32,090
classified images as output and this is

00:09:29,840 --> 00:09:35,390
a function which will be automatically

00:09:32,090 --> 00:09:38,650
scale but platform if the load becomes

00:09:35,390 --> 00:09:41,450
more than what can be handled

00:09:38,650 --> 00:09:45,170
consequently embody the touch of our

00:09:41,450 --> 00:09:47,000
function now if you have an image which

00:09:45,170 --> 00:09:50,870
is not recognized then you will need a

00:09:47,000 --> 00:09:53,600
retraining of the classifier so in this

00:09:50,870 --> 00:09:55,850
case you will be call for instance a big

00:09:53,600 --> 00:10:00,110
data framework like spark and we give

00:09:55,850 --> 00:10:02,650
spark one workers to work on retraining

00:10:00,110 --> 00:10:04,910
the classifier then you will of course

00:10:02,650 --> 00:10:07,700
estimate the time it takes for

00:10:04,910 --> 00:10:10,250
processing some data sets and you will

00:10:07,700 --> 00:10:13,340
see if this we allow you to time length

00:10:10,250 --> 00:10:15,170
train the classifier for for your

00:10:13,340 --> 00:10:18,190
application needs but this is not the

00:10:15,170 --> 00:10:22,700
case well then you will need more

00:10:18,190 --> 00:10:24,560
workers to the spark training and this

00:10:22,700 --> 00:10:26,960
work with food and automatically taken

00:10:24,560 --> 00:10:29,630
into consideration was art and the

00:10:26,960 --> 00:10:31,730
estimated time should go down once you

00:10:29,630 --> 00:10:34,400
are happy with the estimated time then

00:10:31,730 --> 00:10:36,440
you can simply wait for the new

00:10:34,400 --> 00:10:39,590
classifier and eventually deploy this

00:10:36,440 --> 00:10:42,670
classifier as needed so this means that

00:10:39,590 --> 00:10:44,630
the right-hand side here is the economic

00:10:42,670 --> 00:10:47,450
retraining and configuration the

00:10:44,630 --> 00:10:49,460
education management done by the melodic

00:10:47,450 --> 00:10:52,310
platform on your behalf and it makes

00:10:49,460 --> 00:10:55,310
sure that it's all because when needed

00:10:52,310 --> 00:10:57,670
at all and deployed when not no longer

00:10:55,310 --> 00:10:57,670
needed

00:11:00,160 --> 00:11:05,470
the workflow with melodic is very simple

00:11:02,680 --> 00:11:07,840
us user need to model your application

00:11:05,470 --> 00:11:10,150
in comma deploy the melodic platform

00:11:07,840 --> 00:11:12,580
then you just need to submit your cannon

00:11:10,150 --> 00:11:14,320
model to your melodic instance push the

00:11:12,580 --> 00:11:17,680
big green button to start the deployment

00:11:14,320 --> 00:11:19,690
of static ation and observe thanks to

00:11:17,680 --> 00:11:21,730
melody Qi you will be able to see the

00:11:19,690 --> 00:11:23,950
reasoning process of melodic but you are

00:11:21,730 --> 00:11:26,620
not expected to do anything more you can

00:11:23,950 --> 00:11:30,280
connect relax and enjoy your application

00:11:26,620 --> 00:11:32,170
working it is very important to mention

00:11:30,280 --> 00:11:34,690
that melodic is enterprise-ready

00:11:32,170 --> 00:11:36,910
and it is used by some companies you

00:11:34,690 --> 00:11:39,730
also can download and try melodic and we

00:11:36,910 --> 00:11:44,560
encourage you to do that melodic itself

00:11:39,730 --> 00:11:46,450
is 3d Thunder NPL 2.0 license currently

00:11:44,560 --> 00:11:48,730
the third release of melodic is ready

00:11:46,450 --> 00:11:51,190
the project is being further developed

00:11:48,730 --> 00:11:53,800
and it is hosted on all WTO repository

00:11:51,190 --> 00:11:59,350
we also encourage for your contribution

00:11:53,800 --> 00:12:01,540
to the project so thank you for your

00:11:59,350 --> 00:12:04,120
attention and we hope that you will

00:12:01,540 --> 00:12:05,830
learn now try out melodic download it

00:12:04,120 --> 00:12:07,840
and if you have any problems or

00:12:05,830 --> 00:12:09,910
questions please feel free to contact us

00:12:07,840 --> 00:12:12,690
we are here to help you so thank you

00:12:09,910 --> 00:12:12,690

YouTube URL: https://www.youtube.com/watch?v=onrNO_g354w


