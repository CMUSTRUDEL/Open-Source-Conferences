Title: Abstracting just enough â€” James Long
Publication date: 2015-11-16
Playlist: ReactiveConf 2015
Description: 
	The frontend landscape changes at a relentless pace. New ideas seem to appear every month. How can you possibly keep up? I'm on the Firefox Developer Tools team, and we are starting to move towards React and Redux for our frontend. I will explain these choices, the reasons behind them, and how we're migrating old code. Our minds can only keep up with a certain level of abstraction, and it's important to choose abstractions that solve fundamental problems rather than shallow ones. The right abstractions will make an order of magnitude difference in power and simplicity, and the wrong ones can be deadly. It's important to estimate the cost of every abstraction, and be ruthless about keeping it as simple as possible.


Works for Mozilla on the Firefox Developer Tools, mostly trying to make debugging JavaScript better. He's spent the last 8 years studying programming languages like Lisp and Scheme, and trying to bring various ideas to JavaScript. He likes to write in-depth articles about interesting programming ideas. Most of his free time is now happily dedicated to his daughter
Captions: 
	00:00:04,509 --> 00:00:11,500
good morning everyone all right thanks

00:00:09,519 --> 00:00:16,240
for getting up early for my talk I know

00:00:11,500 --> 00:00:18,640
it's hard I am James long not the

00:00:16,240 --> 00:00:20,550
fashion designer in London which is what

00:00:18,640 --> 00:00:23,590
google will try to try to tell you I am

00:00:20,550 --> 00:00:27,369
I work for Mozilla on the Firefox dev

00:00:23,590 --> 00:00:28,930
tools and we've done a lot in the last

00:00:27,369 --> 00:00:31,930
few years we've been moving really

00:00:28,930 --> 00:00:33,489
really fast but the problem is when you

00:00:31,930 --> 00:00:36,640
do that you usually accumulate a lot of

00:00:33,489 --> 00:00:38,559
technical debt especially on our front

00:00:36,640 --> 00:00:41,260
end we pretty much just haven't had a

00:00:38,559 --> 00:00:43,329
whole lot of time to think about more

00:00:41,260 --> 00:00:45,760
innovative in cool ways that we can do

00:00:43,329 --> 00:00:48,309
our UI and not really just cool but

00:00:45,760 --> 00:00:51,399
things that actually solve very big

00:00:48,309 --> 00:00:53,489
problems so right now we're doing a lot

00:00:51,399 --> 00:00:55,780
of things that just make things harder

00:00:53,489 --> 00:01:00,100
so we've been talking a lot about what

00:00:55,780 --> 00:01:01,149
we can do about this and specifically of

00:01:00,100 --> 00:01:03,280
course I've been thinking about how we

00:01:01,149 --> 00:01:06,100
can use react so I've been talking to my

00:01:03,280 --> 00:01:07,900
team about that but it's really really

00:01:06,100 --> 00:01:13,420
hard when you already have this big

00:01:07,900 --> 00:01:15,730
project because we factoring sucks it's

00:01:13,420 --> 00:01:18,700
a lot of work for very little short term

00:01:15,730 --> 00:01:23,050
gain you're having to replace a lot of

00:01:18,700 --> 00:01:25,330
code without adding anything new and for

00:01:23,050 --> 00:01:27,040
if some people don't believe in what

00:01:25,330 --> 00:01:29,320
you're trying to do or don't actually

00:01:27,040 --> 00:01:30,730
see a whole lot of value and the things

00:01:29,320 --> 00:01:33,940
that you're adding it's you're just

00:01:30,730 --> 00:01:36,670
wasting time and you know you you may

00:01:33,940 --> 00:01:38,530
actually just do the wrong thing until

00:01:36,670 --> 00:01:40,810
you are just wasting time I mean just

00:01:38,530 --> 00:01:44,140
imagining updating all your tests it's

00:01:40,810 --> 00:01:45,460
just a very hard problem additionally

00:01:44,140 --> 00:01:47,260
you still need to be shipping features

00:01:45,460 --> 00:01:48,640
while you're refactoring that's probably

00:01:47,260 --> 00:01:50,140
the hardest thing about refactoring is

00:01:48,640 --> 00:01:53,650
that you can't just pause the world and

00:01:50,140 --> 00:01:55,090
stop development for six months so in

00:01:53,650 --> 00:01:58,180
that way it's kind of like changing the

00:01:55,090 --> 00:02:01,180
wheel of a moving car and actually this

00:01:58,180 --> 00:02:03,060
ship makes it look awesome if only

00:02:01,180 --> 00:02:05,229
refactoring were this awesome because

00:02:03,060 --> 00:02:06,930
that is ridiculous there's actually

00:02:05,229 --> 00:02:09,580
replacing two wheels at the same time

00:02:06,930 --> 00:02:12,609
you know it's actually more like this it

00:02:09,580 --> 00:02:14,560
feels good at first you're cleaning

00:02:12,609 --> 00:02:15,700
things up and you're like oh this is

00:02:14,560 --> 00:02:16,620
cool I'm going to solve all these

00:02:15,700 --> 00:02:23,129
requirements

00:02:16,620 --> 00:02:24,750
and then it just goes to yeah and

00:02:23,129 --> 00:02:26,010
it's it's also hard because it's

00:02:24,750 --> 00:02:28,799
tempting to look at something like this

00:02:26,010 --> 00:02:30,900
and think wow this looks really bad we

00:02:28,799 --> 00:02:32,940
need to clean this up but what you

00:02:30,900 --> 00:02:35,280
actually forgot is that this is actually

00:02:32,940 --> 00:02:37,860
an elegant solution given as given the

00:02:35,280 --> 00:02:39,810
actual requirements the requirements

00:02:37,860 --> 00:02:41,970
were naturally complex in this case is

00:02:39,810 --> 00:02:43,650
this highway needed to connect all these

00:02:41,970 --> 00:02:46,349
roads and this is actually very well

00:02:43,650 --> 00:02:49,290
designed if you understand the problem

00:02:46,349 --> 00:02:51,480
and so it's easy to look at code and

00:02:49,290 --> 00:02:53,730
think that looks bad but sometimes

00:02:51,480 --> 00:02:55,680
sometimes it naturally is just complex

00:02:53,730 --> 00:02:57,030
so refactoring is really hard because

00:02:55,680 --> 00:02:59,549
you have to figure out which wheel to

00:02:57,030 --> 00:03:01,109
replace and additionally what to even

00:02:59,549 --> 00:03:02,849
replace it with because you need to come

00:03:01,109 --> 00:03:05,940
out better on the other end after you've

00:03:02,849 --> 00:03:07,650
been refactoring so you'll lose all of

00:03:05,940 --> 00:03:10,109
these nuances and edge cases that you've

00:03:07,650 --> 00:03:11,489
already solved so we we can't we can't

00:03:10,109 --> 00:03:13,409
lose those so we have to figure out a

00:03:11,489 --> 00:03:15,329
way how can we get rid of all these

00:03:13,409 --> 00:03:17,849
problems that we have and use of make

00:03:15,329 --> 00:03:20,040
reacts but still kind of keep the

00:03:17,849 --> 00:03:21,569
essence of what we have so there's this

00:03:20,040 --> 00:03:23,760
idea of inherent versus incidental

00:03:21,569 --> 00:03:26,430
complexity I'm sure all of you all have

00:03:23,760 --> 00:03:30,060
heard this but you you need to kind of

00:03:26,430 --> 00:03:32,090
sort of learn again which which parts of

00:03:30,060 --> 00:03:34,739
your code base is just built up

00:03:32,090 --> 00:03:35,910
incidental complexity either it's things

00:03:34,739 --> 00:03:38,970
that we're solving requirements that

00:03:35,910 --> 00:03:41,310
aren't actually requirements anymore or

00:03:38,970 --> 00:03:43,470
it's just bad code and try to remove

00:03:41,310 --> 00:03:45,209
this as much as possible so think hard

00:03:43,470 --> 00:03:49,769
about what you really need because every

00:03:45,209 --> 00:03:51,419
abstraction has a cost so I think you

00:03:49,769 --> 00:03:53,040
should be very ruthless about only

00:03:51,419 --> 00:03:55,980
adopting abstractions that you actually

00:03:53,040 --> 00:03:57,780
get benefits from because otherwise you

00:03:55,980 --> 00:04:00,000
will so you'll still pay the cost of the

00:03:57,780 --> 00:04:01,760
abstraction but he if you're only

00:04:00,000 --> 00:04:04,680
getting a little benefit from it then

00:04:01,760 --> 00:04:06,209
it's probably a net negative of the

00:04:04,680 --> 00:04:08,940
complexity that that is adding to the

00:04:06,209 --> 00:04:10,949
system and this is you know over time

00:04:08,940 --> 00:04:12,090
your requirements change and so maybe an

00:04:10,949 --> 00:04:13,560
abstraction that you actually were

00:04:12,090 --> 00:04:15,329
getting benefits from you you're not

00:04:13,560 --> 00:04:19,199
getting it anymore you just sort of have

00:04:15,329 --> 00:04:21,380
to put up with it I mean for example you

00:04:19,199 --> 00:04:24,539
know some some people may like promises

00:04:21,380 --> 00:04:27,180
promises for example it's an obstruction

00:04:24,539 --> 00:04:30,030
it's an abstraction of over a sink work

00:04:27,180 --> 00:04:32,040
and it's a good way to do a sink values

00:04:30,030 --> 00:04:34,680
and it has things like error propagation

00:04:32,040 --> 00:04:36,750
which is nice but it also tends to make

00:04:34,680 --> 00:04:38,400
errors silent because they just eat

00:04:36,750 --> 00:04:40,200
errors it just eats all your errors

00:04:38,400 --> 00:04:43,350
because it has to because of the way

00:04:40,200 --> 00:04:44,580
that it's meant to work and so but if

00:04:43,350 --> 00:04:46,080
you forget to attach an error handler or

00:04:44,580 --> 00:04:47,790
your tool chain isn't connected the

00:04:46,080 --> 00:04:49,380
right way your test may be failing and

00:04:47,790 --> 00:04:52,320
you have no idea this actually happens

00:04:49,380 --> 00:04:53,940
to us and additionally the semantics are

00:04:52,320 --> 00:04:55,260
just sort of confusing so if there's a

00:04:53,940 --> 00:04:58,350
height there's a hot there is a high

00:04:55,260 --> 00:05:01,170
cost of promises there's also high value

00:04:58,350 --> 00:05:02,370
if you actually need them but you may

00:05:01,170 --> 00:05:04,860
not actually need them as much as you

00:05:02,370 --> 00:05:07,740
think so when trying to migrate existing

00:05:04,860 --> 00:05:09,720
code especially only add as little new

00:05:07,740 --> 00:05:11,550
abstraction as possible don't just jump

00:05:09,720 --> 00:05:13,950
to this whole entire new stack or this

00:05:11,550 --> 00:05:16,410
new framework I think you should leave

00:05:13,950 --> 00:05:17,700
room to grow in the future and that's

00:05:16,410 --> 00:05:19,470
why I tend to prefer things like

00:05:17,700 --> 00:05:21,990
libraries or frameworks because you can

00:05:19,470 --> 00:05:25,590
sort of incrementally adopt what you

00:05:21,990 --> 00:05:26,910
need and in the end you only after

00:05:25,590 --> 00:05:29,130
you've migrated you know maybe it takes

00:05:26,910 --> 00:05:30,390
six months maybe it takes two years what

00:05:29,130 --> 00:05:32,400
you are left with are just the things

00:05:30,390 --> 00:05:36,780
that you need and I think that's super

00:05:32,400 --> 00:05:38,490
valuable because you again you really

00:05:36,780 --> 00:05:40,350
want to come out better on the other end

00:05:38,490 --> 00:05:42,900
after you have been doing the

00:05:40,350 --> 00:05:44,370
refactoring so you know but badass

00:05:42,900 --> 00:05:45,960
attraction sorta can feel like this I

00:05:44,370 --> 00:05:49,020
mean that maybe some really nice wood

00:05:45,960 --> 00:05:50,700
that those balls are rolling down but

00:05:49,020 --> 00:05:52,710
you just want to try on the light that's

00:05:50,700 --> 00:05:53,790
all you want to do you don't need the

00:05:52,710 --> 00:05:56,100
whole framework you just want to join

00:05:53,790 --> 00:05:59,460
the light so what we want to get to is

00:05:56,100 --> 00:06:01,860
this where it's a very well we'll

00:05:59,460 --> 00:06:03,960
machine every single pieces of purpose

00:06:01,860 --> 00:06:05,820
so how do we do that if you're already

00:06:03,960 --> 00:06:09,240
stuck with the Rube Goldberg machine how

00:06:05,820 --> 00:06:11,670
do you get to this you know and I think

00:06:09,240 --> 00:06:13,740
you just start simple you can start

00:06:11,670 --> 00:06:15,900
migrating pieces of your app pieces of

00:06:13,740 --> 00:06:18,860
your co slowly into a new architecture

00:06:15,900 --> 00:06:22,230
which is ideally sort of simple at first

00:06:18,860 --> 00:06:23,700
and as as you do that you relearn your

00:06:22,230 --> 00:06:25,800
requirements and so as you're migrating

00:06:23,700 --> 00:06:26,970
things over you can see things that are

00:06:25,800 --> 00:06:29,190
like I don't even need that anymore i'm

00:06:26,970 --> 00:06:30,660
just going to which is another reason

00:06:29,190 --> 00:06:33,570
why it's important to start simple

00:06:30,660 --> 00:06:37,410
because if you if you start simple you

00:06:33,570 --> 00:06:39,570
can add things back to it so again you

00:06:37,410 --> 00:06:41,430
can build build it back up slowly as

00:06:39,570 --> 00:06:42,460
you're migrating pieces and pieces over

00:06:41,430 --> 00:06:45,460
so this is a very long

00:06:42,460 --> 00:06:47,560
process right I mean because we can't we

00:06:45,460 --> 00:06:49,150
can't just do it total rewrite we can't

00:06:47,560 --> 00:06:50,800
just ditch a lot of our code because

00:06:49,150 --> 00:06:53,530
we've already built up business logic

00:06:50,800 --> 00:06:57,340
which actually is solving some complex

00:06:53,530 --> 00:06:59,319
cases which is naturally a complex ok so

00:06:57,340 --> 00:07:00,819
when i'm looking for abstractions when i

00:06:59,319 --> 00:07:02,289
am looking at different libraries and

00:07:00,819 --> 00:07:03,690
frameworks i have a couple core

00:07:02,289 --> 00:07:07,270
principles that I'd like to think about

00:07:03,690 --> 00:07:08,949
I think that it must be composable is it

00:07:07,270 --> 00:07:11,560
easy to reuse can I use it wherever I

00:07:08,949 --> 00:07:13,150
want it must be testable kind of load a

00:07:11,560 --> 00:07:16,360
single module and tested independently

00:07:13,150 --> 00:07:17,740
else outside of the system can I replay

00:07:16,360 --> 00:07:20,770
what happened can I send it off to

00:07:17,740 --> 00:07:23,349
somebody else it must be must be

00:07:20,770 --> 00:07:25,720
debuggable like can i actually do the

00:07:23,349 --> 00:07:28,210
replying functionality and it must be

00:07:25,720 --> 00:07:29,590
live reloadable can i change code and it

00:07:28,210 --> 00:07:31,960
just magically appears on the app now

00:07:29,590 --> 00:07:33,430
this seems just like a fun feature but

00:07:31,960 --> 00:07:35,080
this is actually what I think should be

00:07:33,430 --> 00:07:36,699
core to development and I come from a

00:07:35,080 --> 00:07:39,159
deep list but background so this is it

00:07:36,699 --> 00:07:41,370
this is very embedded into me I think

00:07:39,159 --> 00:07:44,500
why reloading is a super important

00:07:41,370 --> 00:07:47,860
feature for development I mean when I

00:07:44,500 --> 00:07:49,389
see developers doing code that is in an

00:07:47,860 --> 00:07:52,449
architecture where library loading works

00:07:49,389 --> 00:07:56,289
really well it's a huge huge boost to

00:07:52,449 --> 00:07:57,699
our productivity now all of these things

00:07:56,289 --> 00:07:59,080
actually have one thing in common it

00:07:57,699 --> 00:08:03,159
really could come down to just this one

00:07:59,080 --> 00:08:05,400
question is it stateful because if it if

00:08:03,159 --> 00:08:07,930
it is internally managing its own state

00:08:05,400 --> 00:08:09,610
then it sort of violates all of those

00:08:07,930 --> 00:08:11,500
principles it's hard to test it we can't

00:08:09,610 --> 00:08:13,419
get to that state if we want to we can't

00:08:11,500 --> 00:08:15,669
live reload it because you want state to

00:08:13,419 --> 00:08:16,840
persist across the library loads you

00:08:15,669 --> 00:08:20,110
can't debug it because you can't look at

00:08:16,840 --> 00:08:21,940
the state so foreign it for example this

00:08:20,110 --> 00:08:23,349
is a typical JavaScript pattern you know

00:08:21,940 --> 00:08:24,849
this is sort of how we use the classes

00:08:23,349 --> 00:08:27,370
and of course there's no es 6 classes

00:08:24,849 --> 00:08:29,560
which isn't a whole lot different we

00:08:27,370 --> 00:08:32,469
construct a user we have a method on the

00:08:29,560 --> 00:08:34,919
user is scary and we construct easier

00:08:32,469 --> 00:08:37,240
I'm not scary because I have two eyes

00:08:34,919 --> 00:08:41,520
what is the first thing that we do here

00:08:37,240 --> 00:08:44,610
we mutate the object we mutate ourselves

00:08:41,520 --> 00:08:47,829
so this pattern encourages mutation

00:08:44,610 --> 00:08:49,839
which is just really really bad because

00:08:47,829 --> 00:08:51,910
it's very hard to track what is going on

00:08:49,839 --> 00:08:53,829
in the entire system when you have a big

00:08:51,910 --> 00:08:55,540
complex app and you have things mutating

00:08:53,829 --> 00:08:57,070
themselves an internal state everywhere

00:08:55,540 --> 00:09:00,250
it's very very hard to grasp what's

00:08:57,070 --> 00:09:01,750
going on it's a lot simple if we just

00:09:00,250 --> 00:09:04,209
use do something like this we just have

00:09:01,750 --> 00:09:06,310
a function that's is scary it takes some

00:09:04,209 --> 00:09:08,560
data and then it does some work on the

00:09:06,310 --> 00:09:10,690
data and then it just constructs an

00:09:08,560 --> 00:09:13,240
object which represents the user now you

00:09:10,690 --> 00:09:15,970
you may want to have something like a

00:09:13,240 --> 00:09:17,259
constructor like make user so that you

00:09:15,970 --> 00:09:19,180
know probably is going to do some more

00:09:17,259 --> 00:09:21,550
complex things but here we don't need

00:09:19,180 --> 00:09:24,069
that right again just keep it simple if

00:09:21,550 --> 00:09:25,930
it should be simple and what's nice

00:09:24,069 --> 00:09:28,779
about this is now now that the data is

00:09:25,930 --> 00:09:31,149
extracted from the from the function

00:09:28,779 --> 00:09:32,529
they're just two separate things you can

00:09:31,149 --> 00:09:34,120
do simple things like hey let's let's

00:09:32,529 --> 00:09:36,490
wrap it into an immutable object let's

00:09:34,120 --> 00:09:39,250
let's use a completely different

00:09:36,490 --> 00:09:43,630
implementation of the data structure and

00:09:39,250 --> 00:09:45,100
there are sort of ways to use sort of

00:09:43,630 --> 00:09:47,620
like a protocol so that it's exposing

00:09:45,100 --> 00:09:49,449
the data in a similar manner using like

00:09:47,620 --> 00:09:50,620
gutters and things like that but you can

00:09:49,449 --> 00:09:54,430
use an entirely different data

00:09:50,620 --> 00:09:57,850
implementation if you have more explicit

00:09:54,430 --> 00:09:59,199
data in your throat your app and you

00:09:57,850 --> 00:10:00,699
know this is just a method right we can

00:09:59,199 --> 00:10:02,790
just lie below this method we can just

00:10:00,699 --> 00:10:04,990
switch it out for a different

00:10:02,790 --> 00:10:06,880
implementation because it's just a

00:10:04,990 --> 00:10:08,110
method we can just redefine it these

00:10:06,880 --> 00:10:09,880
sorts of things get a whole lot more

00:10:08,110 --> 00:10:12,250
complex when you start doing a lot of

00:10:09,880 --> 00:10:14,949
like classes and wrapping things into

00:10:12,250 --> 00:10:16,569
themselves okay so I mean is this

00:10:14,949 --> 00:10:18,339
actually possible is it possible to

00:10:16,569 --> 00:10:21,130
build a real world complex apps with

00:10:18,339 --> 00:10:22,690
just pure functions and data it seems

00:10:21,130 --> 00:10:25,060
like that's going to break down at some

00:10:22,690 --> 00:10:27,970
point but the thing that I love about

00:10:25,060 --> 00:10:29,980
react and their community is that

00:10:27,970 --> 00:10:31,540
they've really proven that this you

00:10:29,980 --> 00:10:33,730
could do this you can do this for a lot

00:10:31,540 --> 00:10:36,339
of your app and I'm not saying that you

00:10:33,730 --> 00:10:38,290
shouldn't ever use classes you can use

00:10:36,339 --> 00:10:40,360
them in certain cases and start pointing

00:10:38,290 --> 00:10:41,829
out but for the general architecture of

00:10:40,360 --> 00:10:45,339
your app you shouldn't require that it

00:10:41,829 --> 00:10:46,600
shouldn't be the API that you need so

00:10:45,339 --> 00:10:48,100
let's just let's just run with this

00:10:46,600 --> 00:10:51,430
let's see how far we can take this let's

00:10:48,100 --> 00:10:53,529
see what we can do with this so let's

00:10:51,430 --> 00:10:56,050
let's talk about from front-end

00:10:53,529 --> 00:10:57,699
development what we need we'll comes to

00:10:56,050 --> 00:10:59,709
my mind when I think of what i need for

00:10:57,699 --> 00:11:03,490
front of development as we need to

00:10:59,709 --> 00:11:06,699
render the UI we need to manage state we

00:11:03,490 --> 00:11:07,580
need to do asynchronous work and we need

00:11:06,699 --> 00:11:10,610
to test

00:11:07,580 --> 00:11:14,480
it's and so where we are with the dev

00:11:10,610 --> 00:11:16,910
tools is we do manual dawn mutations for

00:11:14,480 --> 00:11:18,830
the UI which is really hard to just keep

00:11:16,910 --> 00:11:20,630
track of it's especially hard to create

00:11:18,830 --> 00:11:24,350
new things because we it's hard to

00:11:20,630 --> 00:11:26,450
compose these sort of mutations we have

00:11:24,350 --> 00:11:29,120
state in the Dom we have custom JS

00:11:26,450 --> 00:11:30,700
classes which maintain their state so

00:11:29,120 --> 00:11:33,140
state is sort of spread out everywhere

00:11:30,700 --> 00:11:35,210
and it's especially bad that there is

00:11:33,140 --> 00:11:37,970
state in the Dom because you're now

00:11:35,210 --> 00:11:39,200
dependent on the Dom for stuff so it's

00:11:37,970 --> 00:11:41,810
very hard to rationalize about where

00:11:39,200 --> 00:11:43,750
state is this promises an events

00:11:41,810 --> 00:11:47,570
everywhere like all throughout the UI

00:11:43,750 --> 00:11:49,070
and it it feels like a good idea but I

00:11:47,570 --> 00:11:50,900
think it again just kind of makes some

00:11:49,070 --> 00:11:53,690
things harder and there are very few

00:11:50,900 --> 00:11:56,210
unit tests for our UI and that's a sad

00:11:53,690 --> 00:11:58,100
thing so it sort of feels like this once

00:11:56,210 --> 00:12:00,800
you you have this kind of architecture

00:11:58,100 --> 00:12:02,900
you can lay this out as cleanly and

00:12:00,800 --> 00:12:04,520
nicely as you want and everything is

00:12:02,900 --> 00:12:06,710
nicely exposing you promised interface

00:12:04,520 --> 00:12:08,840
and internally managing its own state so

00:12:06,710 --> 00:12:11,720
that you don't have to care about it but

00:12:08,840 --> 00:12:13,280
you still added overview you have no

00:12:11,720 --> 00:12:15,290
idea was really going on going on in the

00:12:13,280 --> 00:12:17,150
system to do anything here you have to

00:12:15,290 --> 00:12:19,990
be intricately aware of actually every

00:12:17,150 --> 00:12:22,340
single little piece in the system so

00:12:19,990 --> 00:12:27,050
where we want to go as we want to have a

00:12:22,340 --> 00:12:28,820
declarative UI central app state do a

00:12:27,050 --> 00:12:31,430
sink work in an explicit manner whether

00:12:28,820 --> 00:12:36,050
it's atomic UI updates and have a lot

00:12:31,430 --> 00:12:38,030
more unit testing and so if only there

00:12:36,050 --> 00:12:41,060
was a library that would allow us to do

00:12:38,030 --> 00:12:43,580
declarative UI work yeah of course

00:12:41,060 --> 00:12:45,170
that's react so that gives us components

00:12:43,580 --> 00:12:46,580
and declarative UI and there's not even

00:12:45,170 --> 00:12:48,890
any dominated we can do unit testing

00:12:46,580 --> 00:12:50,240
with like react components I don't think

00:12:48,890 --> 00:12:52,370
I need to explain your act at all if

00:12:50,240 --> 00:12:53,900
you're at this conference so there's

00:12:52,370 --> 00:12:55,070
there's a complementary library called

00:12:53,900 --> 00:12:57,980
redux which I'm sure a lot of you are

00:12:55,070 --> 00:12:59,780
aware of and it provides a way to manage

00:12:57,980 --> 00:13:04,640
the state it's things that sort of or

00:12:59,780 --> 00:13:07,970
outside reacts role and read X provides

00:13:04,640 --> 00:13:10,820
a central app state and flux style

00:13:07,970 --> 00:13:12,710
actions and these things about action

00:13:10,820 --> 00:13:15,200
creators so read X is a great way to

00:13:12,710 --> 00:13:19,400
sort of that complements react by

00:13:15,200 --> 00:13:20,430
encouraging the concepts like a central

00:13:19,400 --> 00:13:21,990
app state so

00:13:20,430 --> 00:13:24,510
if you think back to that diagram of

00:13:21,990 --> 00:13:26,100
that board think about now you know

00:13:24,510 --> 00:13:29,100
reactant relaxers sort of the CPU and

00:13:26,100 --> 00:13:33,029
the GPU it's a lot more bigger there's

00:13:29,100 --> 00:13:35,160
much more of a course architecture where

00:13:33,029 --> 00:13:37,890
you have a central app state and a

00:13:35,160 --> 00:13:39,740
declarative UI and there it's easier to

00:13:37,890 --> 00:13:42,630
see how things pump through the system

00:13:39,740 --> 00:13:44,790
okay so let's let's start very simple

00:13:42,630 --> 00:13:47,250
with this we have our declarative UI

00:13:44,790 --> 00:13:50,220
right so think of this you is very

00:13:47,250 --> 00:13:52,589
simple green box as a very complex react

00:13:50,220 --> 00:13:54,600
component tree we don't really care how

00:13:52,589 --> 00:13:56,640
its implemented data comes in and it

00:13:54,600 --> 00:14:00,000
renders the UI and then the UI can fire

00:13:56,640 --> 00:14:02,399
events so for example this would be our

00:14:00,000 --> 00:14:04,290
our declarative UI it's just a function

00:14:02,399 --> 00:14:06,240
it's just it's just a function that

00:14:04,290 --> 00:14:08,940
takes some properties we get the items

00:14:06,240 --> 00:14:11,430
off their properties and we return a

00:14:08,940 --> 00:14:13,920
list of all of the items that's just

00:14:11,430 --> 00:14:18,810
it's just a pure function it's great ok

00:14:13,920 --> 00:14:20,880
so what about data though the so for the

00:14:18,810 --> 00:14:22,680
data what Redux encourages you to do

00:14:20,880 --> 00:14:24,810
which comes from closure script and some

00:14:22,680 --> 00:14:26,940
from elm as well so I have just a single

00:14:24,810 --> 00:14:28,380
JavaScript object so this this state

00:14:26,940 --> 00:14:30,510
object is just a single JavaScript

00:14:28,380 --> 00:14:32,339
object this has some items of some names

00:14:30,510 --> 00:14:34,350
and of course in a real world APIs would

00:14:32,339 --> 00:14:36,180
be far more complex and a deep deeply

00:14:34,350 --> 00:14:41,339
nested data structure but poor thing is

00:14:36,180 --> 00:14:43,500
is just a single object and so ok so

00:14:41,339 --> 00:14:45,810
let's cool so what about events that

00:14:43,500 --> 00:14:48,330
what what is that going to do how do we

00:14:45,810 --> 00:14:49,589
do events so Redux defines these things

00:14:48,330 --> 00:14:52,410
called action creators and this actually

00:14:49,589 --> 00:14:54,959
sort of comes from the flux world I mean

00:14:52,410 --> 00:14:57,690
this this is the core idea of flux which

00:14:54,959 --> 00:14:59,370
was a good idea and action creators are

00:14:57,690 --> 00:15:01,529
just functions so they're just functions

00:14:59,370 --> 00:15:04,620
this is a action creator function add

00:15:01,529 --> 00:15:06,930
item and they create actions and they

00:15:04,620 --> 00:15:09,420
dispatch actions to the state so

00:15:06,930 --> 00:15:11,640
dispatch it this action the action is

00:15:09,420 --> 00:15:14,940
just a dumb JavaScript object with a

00:15:11,640 --> 00:15:16,589
type field so the action creator charges

00:15:14,940 --> 00:15:19,170
methods that create actions that are

00:15:16,589 --> 00:15:21,480
dispatched to the state and then the we

00:15:19,170 --> 00:15:23,220
define update functions which take state

00:15:21,480 --> 00:15:25,380
and take an action and we turn new state

00:15:23,220 --> 00:15:27,120
so that's another core ID here as well

00:15:25,380 --> 00:15:29,880
as you never actually mutate your state

00:15:27,120 --> 00:15:33,850
you always return new state and that

00:15:29,880 --> 00:15:36,459
allows a lot of fan tests

00:15:33,850 --> 00:15:39,250
things ok so that's pretty much it that

00:15:36,459 --> 00:15:41,139
is the core idea of Redux in react and

00:15:39,250 --> 00:15:43,720
the combination of the two so you have

00:15:41,139 --> 00:15:45,819
this very simple flow where you have

00:15:43,720 --> 00:15:48,100
state the state changes whenever the

00:15:45,819 --> 00:15:49,990
state changes that you eyes re-rendered

00:15:48,100 --> 00:15:51,819
and then the UI can call methods which

00:15:49,990 --> 00:15:53,860
are action craters which despacho actors

00:15:51,819 --> 00:15:56,160
do the state so this is very circular

00:15:53,860 --> 00:15:56,160
flow

00:16:01,880 --> 00:16:06,410
and but even just with this simple

00:16:04,760 --> 00:16:07,970
architecture by organizing it in this

00:16:06,410 --> 00:16:11,630
way we're able to do very cool things

00:16:07,970 --> 00:16:13,690
like state snapshotting so this is my

00:16:11,630 --> 00:16:16,130
blog which I wrote in reacting redux I

00:16:13,690 --> 00:16:17,900
have a bunch of state I have some fields

00:16:16,130 --> 00:16:20,660
and I'm going to be changing those those

00:16:17,900 --> 00:16:22,520
fields I'm just going to change some of

00:16:20,660 --> 00:16:24,770
them and then I'm going to press a key

00:16:22,520 --> 00:16:27,380
stroke and get the entire app state

00:16:24,770 --> 00:16:29,660
serialize and just copy it go somewhere

00:16:27,380 --> 00:16:31,190
else to add it totally a URL pull up

00:16:29,660 --> 00:16:33,170
that popped again just paste in that

00:16:31,190 --> 00:16:35,960
Sierra upstate it's just going to load

00:16:33,170 --> 00:16:37,430
up what represented that app state so

00:16:35,960 --> 00:16:38,510
this didn't change the URL or go to a

00:16:37,430 --> 00:16:40,430
different page at all this is literally

00:16:38,510 --> 00:16:43,040
just pulling up wut rip is in at that

00:16:40,430 --> 00:16:44,180
app state so just by organizing it and

00:16:43,040 --> 00:16:45,800
that's in that way where there's a

00:16:44,180 --> 00:16:47,330
central app state we can easily just

00:16:45,800 --> 00:16:49,850
snapshot the app which is great for

00:16:47,330 --> 00:16:51,500
debugging we can additionally do things

00:16:49,850 --> 00:16:53,570
like log and replay actions so we

00:16:51,500 --> 00:16:55,340
remember action creators will fire these

00:16:53,570 --> 00:16:57,320
actions which update the state that is

00:16:55,340 --> 00:17:00,170
the only way to update the state what

00:16:57,320 --> 00:17:01,550
that means is that we can just log the

00:17:00,170 --> 00:17:03,680
actions which is an entire which

00:17:01,550 --> 00:17:06,680
describe everything that has happened in

00:17:03,680 --> 00:17:09,530
the system so this is the debugger using

00:17:06,680 --> 00:17:11,180
redux I'm making some changes in the UI

00:17:09,530 --> 00:17:13,490
and redox actually has this great

00:17:11,180 --> 00:17:14,930
project called the redox devtools so I'm

00:17:13,490 --> 00:17:16,819
going to pull open the dev tools and

00:17:14,930 --> 00:17:18,260
these are all of the actions these are

00:17:16,819 --> 00:17:20,540
all of the state changes that have

00:17:18,260 --> 00:17:22,370
happened in the UI that represent every

00:17:20,540 --> 00:17:24,380
single change I can even inspect the

00:17:22,370 --> 00:17:25,819
action what prop what parameters gonna

00:17:24,380 --> 00:17:28,100
happen I can inspect the state at that

00:17:25,819 --> 00:17:30,200
point in time just very cool as suit

00:17:28,100 --> 00:17:31,880
it's very enlightening and not only that

00:17:30,200 --> 00:17:33,590
but I can replay all the actions so I

00:17:31,880 --> 00:17:35,210
loaded up the initial state and I've

00:17:33,590 --> 00:17:38,060
replaying all of the actions so I can

00:17:35,210 --> 00:17:40,760
actually watch how the UI changed over

00:17:38,060 --> 00:17:44,900
time and I could do this from anywhere I

00:17:40,760 --> 00:17:47,210
could have a user just um send me their

00:17:44,900 --> 00:17:49,220
estate and their actions and just replay

00:17:47,210 --> 00:17:50,900
what happened now these are some one

00:17:49,220 --> 00:17:53,390
gimmicky yes you always see these things

00:17:50,900 --> 00:17:55,940
like conferences and you hardly ever use

00:17:53,390 --> 00:17:57,410
them in real life right it's helpful

00:17:55,940 --> 00:18:00,140
every now and then it's helpful you know

00:17:57,410 --> 00:18:03,370
when you have a really hard bug but that

00:18:00,140 --> 00:18:06,530
the action logging is super critical it

00:18:03,370 --> 00:18:08,420
allows you to have insights into what is

00:18:06,530 --> 00:18:10,730
going on in your app it's just like a

00:18:08,420 --> 00:18:12,620
you always have to go in and add console

00:18:10,730 --> 00:18:13,970
logs whenever you want to actually see

00:18:12,620 --> 00:18:15,530
what's going on right i mean

00:18:13,970 --> 00:18:17,120
hopefully you use the debugger as well

00:18:15,530 --> 00:18:19,250
but console dot log in is actually a

00:18:17,120 --> 00:18:21,170
very powerful way of debugging but this

00:18:19,250 --> 00:18:23,720
now that we have made everything into

00:18:21,170 --> 00:18:26,300
first class actions to represent changes

00:18:23,720 --> 00:18:28,280
in the system we can build that in

00:18:26,300 --> 00:18:29,960
naturally and just always log the

00:18:28,280 --> 00:18:31,910
actions when you're in debug mode and

00:18:29,960 --> 00:18:33,800
that way you can always see what's going

00:18:31,910 --> 00:18:37,610
on and I use that almost every single

00:18:33,800 --> 00:18:39,560
day okay so we have that that simple

00:18:37,610 --> 00:18:40,760
system what about asynchronous work this

00:18:39,560 --> 00:18:42,140
is something very important that I want

00:18:40,760 --> 00:18:43,730
to talk about because this is where

00:18:42,140 --> 00:18:46,640
everything tends to get really complex

00:18:43,730 --> 00:18:50,240
so this is where simple architectures

00:18:46,640 --> 00:18:53,210
tend to just either fall and fail or

00:18:50,240 --> 00:18:55,640
just get super complex so how do we do

00:18:53,210 --> 00:18:57,200
that we have a simple system but where

00:18:55,640 --> 00:18:58,310
does where what if you wanted to fetch

00:18:57,200 --> 00:19:01,010
something from the server what is that

00:18:58,310 --> 00:19:03,410
fit what does that fit into this so you

00:19:01,010 --> 00:19:04,820
if you remember this action creators

00:19:03,410 --> 00:19:07,460
their functions right that create

00:19:04,820 --> 00:19:09,530
actions so it dispatches an action at

00:19:07,460 --> 00:19:11,960
some point of time actually feeders can

00:19:09,530 --> 00:19:13,070
actually dispatch multiple actions so

00:19:11,960 --> 00:19:15,440
you can dispatch an action that

00:19:13,070 --> 00:19:17,210
represents the start of the request then

00:19:15,440 --> 00:19:18,710
you can actually out later and in the

00:19:17,210 --> 00:19:20,510
time when the response is received from

00:19:18,710 --> 00:19:22,390
the server you can just patch another

00:19:20,510 --> 00:19:26,210
actual that represents the finished

00:19:22,390 --> 00:19:28,760
state of the whole requests so this

00:19:26,210 --> 00:19:30,230
start and finish if you always do this

00:19:28,760 --> 00:19:32,990
in an action creator you can do a sink

00:19:30,230 --> 00:19:35,210
work so the finish the finishing action

00:19:32,990 --> 00:19:36,020
will have the actual response will

00:19:35,210 --> 00:19:37,760
actually have the thing that was

00:19:36,020 --> 00:19:38,930
returned from the server but this allows

00:19:37,760 --> 00:19:40,880
you to do things like optimistic

00:19:38,930 --> 00:19:42,890
updating and or if you just wanted to

00:19:40,880 --> 00:19:47,450
show like a loading screen you could

00:19:42,890 --> 00:19:49,880
respond to the start state and so you

00:19:47,450 --> 00:19:53,300
know you can have any number of a sink

00:19:49,880 --> 00:19:55,220
work things going on firing actions into

00:19:53,300 --> 00:19:57,470
the system but it all happens

00:19:55,220 --> 00:19:59,540
sequentially throughout the UI so

00:19:57,470 --> 00:20:01,670
everybody says that you eyes are

00:19:59,540 --> 00:20:03,350
inherently asynchronous and I actually

00:20:01,670 --> 00:20:05,870
sort of disagree with that or at least I

00:20:03,350 --> 00:20:08,390
disagree with the the general how a lot

00:20:05,870 --> 00:20:10,910
of people receive that because you know

00:20:08,390 --> 00:20:12,950
this entire box right here is totally

00:20:10,910 --> 00:20:14,690
synchronous as it should be when you

00:20:12,950 --> 00:20:16,820
update the state or when you fire an

00:20:14,690 --> 00:20:19,280
action the updating the state and

00:20:16,820 --> 00:20:22,010
updating the UI happens exactly in that

00:20:19,280 --> 00:20:26,000
same function stack it happens in that

00:20:22,010 --> 00:20:26,809
same tick so this the UI itself is

00:20:26,000 --> 00:20:29,029
actually

00:20:26,809 --> 00:20:30,529
synchronous but we have is this a sync

00:20:29,029 --> 00:20:33,110
works toward going on outside this box

00:20:30,529 --> 00:20:36,110
how we interact with you is is

00:20:33,110 --> 00:20:39,049
asynchronous so everything outside of

00:20:36,110 --> 00:20:41,389
this box is sort of the land of Mordor

00:20:39,049 --> 00:20:43,639
which is always stateful stuff going on

00:20:41,389 --> 00:20:45,799
within this box it's nice and little

00:20:43,639 --> 00:20:47,779
pretty pure function pure pure functions

00:20:45,799 --> 00:20:49,039
you know Elm you know you know this

00:20:47,779 --> 00:20:51,230
probably is resonating with you very

00:20:49,039 --> 00:20:53,570
much actually and some twisted way like

00:20:51,230 --> 00:20:56,749
to think about this is like this is this

00:20:53,570 --> 00:20:58,190
is the the pure benefits of elm inside

00:20:56,749 --> 00:21:00,830
the box this is where we can say pure

00:20:58,190 --> 00:21:03,350
functions what Elm does is you actually

00:21:00,830 --> 00:21:05,149
will pass sight of past side effects up

00:21:03,350 --> 00:21:06,919
because all functions are pure in Elm

00:21:05,149 --> 00:21:08,749
you pass it up to the runtime the

00:21:06,919 --> 00:21:10,669
runtime will actually do the async work

00:21:08,749 --> 00:21:12,139
for you so I sort of like to think of

00:21:10,669 --> 00:21:15,350
this as a dumb way of getting some of

00:21:12,139 --> 00:21:17,509
those benefits where we force everything

00:21:15,350 --> 00:21:19,639
a sink into action creators and they

00:21:17,509 --> 00:21:23,960
live just at a specific layer that's

00:21:19,639 --> 00:21:24,919
outside red box and so that's how you

00:21:23,960 --> 00:21:27,470
that's how that's how you do

00:21:24,919 --> 00:21:28,940
asynchronous work in relaxes a sink I've

00:21:27,470 --> 00:21:31,519
computers can just fire multiple actions

00:21:28,940 --> 00:21:32,600
and you they could be anything you could

00:21:31,519 --> 00:21:34,220
use promises here you can use

00:21:32,600 --> 00:21:35,990
observables your channels you could use

00:21:34,220 --> 00:21:37,340
any AC abstraction you want in the

00:21:35,990 --> 00:21:40,159
action crater if you want to do some

00:21:37,340 --> 00:21:41,990
complex sort of coordination and that TV

00:21:40,159 --> 00:21:44,259
is really nice because these have

00:21:41,990 --> 00:21:46,909
benefits I'm not against promises

00:21:44,259 --> 00:21:49,490
entirely I'm not against observables

00:21:46,909 --> 00:21:52,909
entirely I think that they do have a lot

00:21:49,490 --> 00:21:55,340
of costs and it's only it's only worth

00:21:52,909 --> 00:21:57,919
using if you're actually needing the

00:21:55,340 --> 00:21:59,779
benefits that they provide but here we

00:21:57,919 --> 00:22:01,340
can use them when we need them but when

00:21:59,779 --> 00:22:04,039
you need to actually interact with the

00:22:01,340 --> 00:22:07,610
UI in the whole system you don't need

00:22:04,039 --> 00:22:09,019
observables throughout your UI and so

00:22:07,610 --> 00:22:11,899
it's nice to have just this simple

00:22:09,019 --> 00:22:13,730
system of your functions and we could

00:22:11,899 --> 00:22:15,409
even think about replacing an entire UI

00:22:13,730 --> 00:22:19,279
layer with real a rock wars you're

00:22:15,409 --> 00:22:22,629
fantastic two fantastic technologies and

00:22:19,279 --> 00:22:25,009
it's so again it feels nice to sort of

00:22:22,629 --> 00:22:26,720
force everything async to be at this

00:22:25,009 --> 00:22:29,600
specific layer and model at the certain

00:22:26,720 --> 00:22:32,269
way because maybe at some point down the

00:22:29,600 --> 00:22:33,769
road if we're able to do this we could

00:22:32,269 --> 00:22:35,389
just look at Falkor something like that

00:22:33,769 --> 00:22:36,710
which is super cool and just get rid of

00:22:35,389 --> 00:22:38,600
this because this is all just plumbing

00:22:36,710 --> 00:22:39,980
right async work is entirely just

00:22:38,600 --> 00:22:40,460
plumbing you're just getting stuff from

00:22:39,980 --> 00:22:41,840
the server

00:22:40,460 --> 00:22:43,610
and you wanting to update that central

00:22:41,840 --> 00:22:44,690
state object but really invoke work

00:22:43,610 --> 00:22:46,040
would just automatically update

00:22:44,690 --> 00:22:47,780
essential state object and then you just

00:22:46,040 --> 00:22:50,390
still work on your UI that automatically

00:22:47,780 --> 00:22:52,760
renders it okay so let's look at a

00:22:50,390 --> 00:22:54,110
little bit of code um so this is how you

00:22:52,760 --> 00:22:56,150
dispatch an action this is what would be

00:22:54,110 --> 00:22:59,060
in an action creator we just called

00:22:56,150 --> 00:23:00,500
dispatch and then we create the the

00:22:59,060 --> 00:23:02,320
action an action is just a JavaScript

00:23:00,500 --> 00:23:06,140
object with a type field and then some

00:23:02,320 --> 00:23:07,640
parameters what's nice about this again

00:23:06,140 --> 00:23:10,670
just to reinforce this is that this is

00:23:07,640 --> 00:23:12,890
entirely synchronous the UI is updated

00:23:10,670 --> 00:23:15,980
once this function is done executing on

00:23:12,890 --> 00:23:17,960
the next line the state has changed and

00:23:15,980 --> 00:23:21,670
the UI has we rendered so it's

00:23:17,960 --> 00:23:25,220
completely it's a completely synchronous

00:23:21,670 --> 00:23:26,840
way of working so this is a more complex

00:23:25,220 --> 00:23:29,930
action creator this would be an async

00:23:26,840 --> 00:23:32,080
action creator we actually return a

00:23:29,930 --> 00:23:34,280
function that takes a dispatch function

00:23:32,080 --> 00:23:37,400
this is actually done through a

00:23:34,280 --> 00:23:39,650
middleware middleware allows you to take

00:23:37,400 --> 00:23:41,450
anything return from action craters and

00:23:39,650 --> 00:23:43,220
transform it into something else so

00:23:41,450 --> 00:23:45,050
there's a funk middleware which allows

00:23:43,220 --> 00:23:47,540
you to return the function and it allows

00:23:45,050 --> 00:23:49,100
you to hook into the dispatch system so

00:23:47,540 --> 00:23:51,710
we're not dependent on some global

00:23:49,100 --> 00:23:54,440
dispatcher or some global dispatch crazy

00:23:51,710 --> 00:23:55,790
thing that we're trying to hook into we

00:23:54,440 --> 00:23:57,080
just return function that accepted

00:23:55,790 --> 00:23:58,700
dispatch function and then within that

00:23:57,080 --> 00:24:00,620
function we can call dispatch now and

00:23:58,700 --> 00:24:03,170
that means that we can call dispatch

00:24:00,620 --> 00:24:05,360
multiple times so we call dispatch let's

00:24:03,170 --> 00:24:07,130
add the item with a status of start

00:24:05,360 --> 00:24:09,980
which is the start of the request and

00:24:07,130 --> 00:24:11,840
then we you know I do a set time out to

00:24:09,980 --> 00:24:13,760
represent an async requests and then

00:24:11,840 --> 00:24:15,650
later on we do a finish and so we

00:24:13,760 --> 00:24:19,250
dispatch finish so there's multiple

00:24:15,650 --> 00:24:21,020
things going throughout the system and

00:24:19,250 --> 00:24:22,010
you know you don't want to do that for

00:24:21,020 --> 00:24:24,320
everything because I didn't even talk

00:24:22,010 --> 00:24:25,520
about errors you know you would want to

00:24:24,320 --> 00:24:27,140
actually have to check the error status

00:24:25,520 --> 00:24:30,530
of the response and make sure to

00:24:27,140 --> 00:24:34,160
dispatch in in a status of error of the

00:24:30,530 --> 00:24:35,930
acing action so again with the middle

00:24:34,160 --> 00:24:37,520
where we can actually wrap this up into

00:24:35,930 --> 00:24:39,100
something nice you can we've written

00:24:37,520 --> 00:24:41,330
something called a promise but aware

00:24:39,100 --> 00:24:45,050
this allows you to returning action

00:24:41,330 --> 00:24:47,150
which has a it defines the type and it

00:24:45,050 --> 00:24:49,400
assigns the parameters but it has a

00:24:47,150 --> 00:24:51,080
special promise field on it and what the

00:24:49,400 --> 00:24:52,509
promise mental where does is it takes us

00:24:51,080 --> 00:24:54,519
and it transformed it in

00:24:52,509 --> 00:24:58,089
multiple actions automatically see a

00:24:54,519 --> 00:24:59,679
start action a finish action and in an

00:24:58,089 --> 00:25:01,570
air action will all fire at the right

00:24:59,679 --> 00:25:03,519
time so now we have this really nice

00:25:01,570 --> 00:25:05,489
system to sort of take those async

00:25:03,519 --> 00:25:08,769
abstractions and splice them on to our

00:25:05,489 --> 00:25:12,459
synchronous a sink or sorry synchronous

00:25:08,769 --> 00:25:13,719
action dispatching system am I feel a

00:25:12,459 --> 00:25:16,209
little weird like why don't we just take

00:25:13,719 --> 00:25:18,489
promises and just use them but it's

00:25:16,209 --> 00:25:19,959
again it's the whole concept of let's

00:25:18,489 --> 00:25:22,449
just use pure functions as much as we

00:25:19,959 --> 00:25:24,609
can and doing this I found is really

00:25:22,449 --> 00:25:26,529
nice because it also allows us to use

00:25:24,609 --> 00:25:29,199
any a single abstraction as we want if

00:25:26,529 --> 00:25:30,879
the only accepted promises or only use

00:25:29,199 --> 00:25:32,919
promises as our interface we could never

00:25:30,879 --> 00:25:34,149
use observables if we only you don't

00:25:32,919 --> 00:25:35,919
want to just depend on a single

00:25:34,149 --> 00:25:37,479
abstraction throughout your entire app

00:25:35,919 --> 00:25:40,449
because otherwise you can't mix and

00:25:37,479 --> 00:25:42,699
match them as you need so you might not

00:25:40,449 --> 00:25:45,789
need promises and observables or other

00:25:42,699 --> 00:25:48,039
async abstractions or channels because

00:25:45,789 --> 00:25:50,109
they all incur a pretty big cost again

00:25:48,039 --> 00:25:52,029
promises they eat your errors I mean

00:25:50,109 --> 00:25:56,979
that to me is the biggest fail of

00:25:52,029 --> 00:25:58,929
promises and they also tend to promises

00:25:56,979 --> 00:26:00,639
will run your code or several tix and so

00:25:58,929 --> 00:26:02,949
promise it's NBD if you're using

00:26:00,639 --> 00:26:06,009
promises throughout your UI it tends to

00:26:02,949 --> 00:26:07,119
introduce race conditions and that's

00:26:06,009 --> 00:26:10,629
something that we've had a problem with

00:26:07,119 --> 00:26:12,579
so you I think at the core of your UI

00:26:10,629 --> 00:26:13,809
that's I think the brilliant thing about

00:26:12,579 --> 00:26:16,569
react is that they have just a

00:26:13,809 --> 00:26:18,759
synchronous render function so you might

00:26:16,569 --> 00:26:19,929
not need some of these things only need

00:26:18,759 --> 00:26:22,059
them if you're actually needed to do

00:26:19,929 --> 00:26:23,919
some special coordination of a single

00:26:22,059 --> 00:26:27,129
work okay so I talked about needing

00:26:23,919 --> 00:26:30,609
rendering the UI mate managing state and

00:26:27,129 --> 00:26:32,049
doing asynchronous work women when we're

00:26:30,609 --> 00:26:33,279
doing front and stuff the last thing

00:26:32,049 --> 00:26:36,940
that I thought about is that we need is

00:26:33,279 --> 00:26:39,190
testing right a lot of things also comes

00:26:36,940 --> 00:26:41,709
out of this architecture of just using

00:26:39,190 --> 00:26:45,069
your functions in data it becomes a lot

00:26:41,709 --> 00:26:47,199
simpler to test state updates the the

00:26:45,069 --> 00:26:49,419
update functions which take state take

00:26:47,199 --> 00:26:50,919
an action return a new state they're

00:26:49,419 --> 00:26:53,289
just functions right so you can just

00:26:50,919 --> 00:26:55,149
call them with any state that you want

00:26:53,289 --> 00:26:57,009
to and actually that you want to and

00:26:55,149 --> 00:26:59,079
just check that the return state is what

00:26:57,009 --> 00:27:00,029
you would expect it's just a function I

00:26:59,079 --> 00:27:02,079
mean you don't need to do anything else

00:27:00,029 --> 00:27:03,669
react components are basically just

00:27:02,079 --> 00:27:05,670
simple functions as well they might have

00:27:03,669 --> 00:27:08,820
some other special lifecycle methods

00:27:05,670 --> 00:27:11,250
but in general you can just pass some

00:27:08,820 --> 00:27:12,750
properties to a react component make

00:27:11,250 --> 00:27:15,120
sure that the JSON structure that has

00:27:12,750 --> 00:27:16,860
read that it rendered to is is correct

00:27:15,120 --> 00:27:19,020
you don't even need the Dom you can just

00:27:16,860 --> 00:27:21,360
unit tests every single component in the

00:27:19,020 --> 00:27:23,750
way that you want to it's super simple

00:27:21,360 --> 00:27:25,920
using pure functions is just awesome

00:27:23,750 --> 00:27:28,080
actually created a little more complex

00:27:25,920 --> 00:27:30,420
there's still generally simple functions

00:27:28,080 --> 00:27:32,820
that are generally pure in the fact that

00:27:30,420 --> 00:27:34,680
they don't depend on some global state

00:27:32,820 --> 00:27:36,540
in your app but they're still stateful

00:27:34,680 --> 00:27:38,550
because they're a sink they tend to be

00:27:36,540 --> 00:27:41,910
acing so they're a little harder but if

00:27:38,550 --> 00:27:43,650
you if you know how to test a sink work

00:27:41,910 --> 00:27:45,450
then you can still do this and yeah

00:27:43,650 --> 00:27:47,310
action creators might need a little bit

00:27:45,450 --> 00:27:49,830
more weird things like needing to mock

00:27:47,310 --> 00:27:52,290
some api's so actually creators are a

00:27:49,830 --> 00:27:55,050
little hard but it's a lot better than

00:27:52,290 --> 00:27:56,670
your whole app being really hard so

00:27:55,050 --> 00:27:58,440
there are some other interesting ideas

00:27:56,670 --> 00:28:00,060
now that we have this architecture now

00:27:58,440 --> 00:28:03,240
that we have this kind of observable

00:28:00,060 --> 00:28:05,760
changes in a system through actions like

00:28:03,240 --> 00:28:07,710
we could record a workflow I could start

00:28:05,760 --> 00:28:10,650
recording I could make some changes in

00:28:07,710 --> 00:28:12,720
the UI and say and make sure that I get

00:28:10,650 --> 00:28:14,640
to a certain point of time and then I

00:28:12,720 --> 00:28:16,890
could save that whole session as a test

00:28:14,640 --> 00:28:19,500
and say run through all of these acting

00:28:16,890 --> 00:28:23,010
or given this initial state run through

00:28:19,500 --> 00:28:25,440
all of these actions and make sure that

00:28:23,010 --> 00:28:27,630
this state is what it should be at that

00:28:25,440 --> 00:28:29,220
point in time or maybe it just shouldn't

00:28:27,630 --> 00:28:30,510
error maybe it should actually just make

00:28:29,220 --> 00:28:32,550
sure that successfully runs through that

00:28:30,510 --> 00:28:34,700
session at the right time so I'm not

00:28:32,550 --> 00:28:36,510
sure it could be a cool idea another

00:28:34,700 --> 00:28:38,310
probably more interesting idea is

00:28:36,510 --> 00:28:40,680
generative and property based testing is

00:28:38,310 --> 00:28:42,420
this super super cool stuff it's

00:28:40,680 --> 00:28:45,540
basically just generates random input

00:28:42,420 --> 00:28:47,190
and we'll just make and it just dumps

00:28:45,540 --> 00:28:48,930
random input into your function and

00:28:47,190 --> 00:28:50,730
priority based testing allows you to

00:28:48,930 --> 00:28:52,470
make sure that the output is correct so

00:28:50,730 --> 00:28:53,970
you can actually for you as you might

00:28:52,470 --> 00:28:57,030
say if the checkbox is checked and this

00:28:53,970 --> 00:28:59,940
other thing is selected so I playground

00:28:57,030 --> 00:29:01,950
at this so I wrote some code using the

00:28:59,940 --> 00:29:04,050
gen test library that generates app

00:29:01,950 --> 00:29:07,350
states so this is this is what it looks

00:29:04,050 --> 00:29:09,750
like to generate apps ace and dump them

00:29:07,350 --> 00:29:11,700
into the UI so this is just literally

00:29:09,750 --> 00:29:14,490
creating as many you eyes as we can

00:29:11,700 --> 00:29:16,110
using any random data what's interesting

00:29:14,490 --> 00:29:17,310
about this is this is sorta more of a

00:29:16,110 --> 00:29:18,580
fuzzer right this isn't doing

00:29:17,310 --> 00:29:20,950
property-based huh seen

00:29:18,580 --> 00:29:22,659
you could easily do this was just kind

00:29:20,950 --> 00:29:24,610
of a fun hack for me I didn't you can

00:29:22,659 --> 00:29:25,750
easily extend this to do either property

00:29:24,610 --> 00:29:29,110
based testing or you could be

00:29:25,750 --> 00:29:31,779
dynamically creating actions ok so the

00:29:29,110 --> 00:29:33,909
core principles are let's be composable

00:29:31,779 --> 00:29:37,750
testable debuggable and library loadable

00:29:33,909 --> 00:29:40,419
as very very solved using just civil

00:29:37,750 --> 00:29:43,960
functions as much as possible and it's

00:29:40,419 --> 00:29:46,090
single single essential upstate so the

00:29:43,960 --> 00:29:49,330
Firefox is actually having a release

00:29:46,090 --> 00:29:51,429
today you should go download it one of

00:29:49,330 --> 00:29:53,289
the things new in nightly that we just

00:29:51,429 --> 00:29:55,149
built is a memory tool so this allows

00:29:53,289 --> 00:29:56,679
you to show all of your memory where its

00:29:55,149 --> 00:29:58,630
allocated what is taken the most space

00:29:56,679 --> 00:30:00,010
this is all written in reactant redux so

00:29:58,630 --> 00:30:01,929
this was our first prototype into

00:30:00,010 --> 00:30:04,210
actually using it completely not just my

00:30:01,929 --> 00:30:05,860
green single code I can't take credit

00:30:04,210 --> 00:30:08,110
for this actually my teammate Jordan and

00:30:05,860 --> 00:30:09,880
Nick Fitzgerald and other people after

00:30:08,110 --> 00:30:11,649
you did some fantastic work with us so

00:30:09,880 --> 00:30:13,120
we're slowly slowly doing doing this we

00:30:11,649 --> 00:30:14,769
have a lot of code we're not going to

00:30:13,120 --> 00:30:16,690
we're not going to be any time soon

00:30:14,769 --> 00:30:18,309
using all like we have to relax but

00:30:16,690 --> 00:30:19,720
we're very close if you're interested in

00:30:18,309 --> 00:30:21,909
contributing we're all open source of

00:30:19,720 --> 00:30:23,289
course so contact me it's a little

00:30:21,909 --> 00:30:25,620
awkward right now because we're we are

00:30:23,289 --> 00:30:27,940
trying to figure out this very hard

00:30:25,620 --> 00:30:29,169
migration phase but there might be

00:30:27,940 --> 00:30:31,120
things that we can find if you're just

00:30:29,169 --> 00:30:32,230
interested in doing react stuff but I

00:30:31,120 --> 00:30:34,750
think in a couple months we'll be in a

00:30:32,230 --> 00:30:39,389
really good place to take calm and relax

00:30:34,750 --> 00:30:39,389

YouTube URL: https://www.youtube.com/watch?v=764wvf8KuTw


