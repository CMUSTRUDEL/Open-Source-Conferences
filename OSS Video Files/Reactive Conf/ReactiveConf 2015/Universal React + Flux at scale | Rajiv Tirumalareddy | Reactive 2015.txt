Title: Universal React + Flux at scale | Rajiv Tirumalareddy | Reactive 2015
Publication date: 2017-06-29
Playlist: ReactiveConf 2015
Description: 
	React is great and Flux is awesome. Running both on the server and client is even better! You've built your app with the latest and greatest tech stack, but will your app scale to millions of users? We created and open sourced Fluxible and other libraries that support Yahoo's high-traffic web applications. I'll share our learnings and go through best practices, performance concerns, and challenges of building robust and scalable web applications.

Rajiv is software engineer at Yahoo working on node.js and Fluxible (Universal Flux and React) frontends that power high-traffic web applications.
Captions: 
	00:00:11,129 --> 00:00:17,680
okay so complementation that we came up

00:00:14,350 --> 00:00:20,980
with pretty early on I want to talk

00:00:17,680 --> 00:00:23,680
about why we made flexible what

00:00:20,980 --> 00:00:24,730
challenges should solve for us and some

00:00:23,680 --> 00:00:29,369
of the challenges that we were facing

00:00:24,730 --> 00:00:34,050
right now as we try to scale it out so

00:00:29,369 --> 00:00:37,690
before react we were in a world with Yui

00:00:34,050 --> 00:00:40,859
Yui was invented at Yahoo it was

00:00:37,690 --> 00:00:42,909
basically the jQuery before jQuery

00:00:40,859 --> 00:00:45,460
provided the cross browser as

00:00:42,909 --> 00:00:49,420
extractions needed to manipulate the Dom

00:00:45,460 --> 00:00:51,850
provided a nice modulator it was really

00:00:49,420 --> 00:00:54,339
nice and then we started to move into

00:00:51,850 --> 00:00:57,190
doing server-side rendering with node

00:00:54,339 --> 00:01:00,179
and that's where we realized why you I

00:00:57,190 --> 00:01:02,530
can't simply be moved on to the server

00:01:00,179 --> 00:01:03,879
but we did realize the importance of

00:01:02,530 --> 00:01:06,159
sharing code between the server and

00:01:03,879 --> 00:01:08,770
client so we used us ge'ez templates to

00:01:06,159 --> 00:01:11,050
achieve server-side rendering so this is

00:01:08,770 --> 00:01:13,120
when a new thing called react was came

00:01:11,050 --> 00:01:14,830
about and we thought we could just swap

00:01:13,120 --> 00:01:19,180
it in and use it as a new template

00:01:14,830 --> 00:01:20,170
language but we soon realized it was

00:01:19,180 --> 00:01:23,530
more than just a template language

00:01:20,170 --> 00:01:26,890
because react comes with built-in events

00:01:23,530 --> 00:01:29,260
and well-defined lifecycle and what that

00:01:26,890 --> 00:01:32,830
means is you can now start to put the

00:01:29,260 --> 00:01:35,320
code you I like your UI logic right

00:01:32,830 --> 00:01:37,690
where your do I markup is and that helps

00:01:35,320 --> 00:01:40,210
a lot in terms of making your code

00:01:37,690 --> 00:01:42,130
easier to reason about also with react

00:01:40,210 --> 00:01:44,080
you no longer have to touch the Dom as

00:01:42,130 --> 00:01:47,530
much because it did efficient Dom

00:01:44,080 --> 00:01:49,600
updates but it's virtual Dom biffing so

00:01:47,530 --> 00:01:51,520
that meant you didn't really need the

00:01:49,600 --> 00:01:55,450
cross browser Dom abstractions that Yui

00:01:51,520 --> 00:01:58,210
or jQuery might provide and all of this

00:01:55,450 --> 00:02:00,430
with declarative templates that you can

00:01:58,210 --> 00:02:03,520
actually write in pure jas without

00:02:00,430 --> 00:02:07,750
actually transpiring them we just made

00:02:03,520 --> 00:02:09,009
react a really awesome win for us so as

00:02:07,750 --> 00:02:12,159
we started to realize the benefits of

00:02:09,009 --> 00:02:14,290
react flux was becoming a thing and if

00:02:12,159 --> 00:02:16,359
you're not familiar with flux flux is

00:02:14,290 --> 00:02:18,189
the inner directional dataflow actions

00:02:16,359 --> 00:02:18,460
dispatch some data in your stores and

00:02:18,189 --> 00:02:22,350
then

00:02:18,460 --> 00:02:25,150
your views react to it and render and

00:02:22,350 --> 00:02:27,880
you can fire off more actions responding

00:02:25,150 --> 00:02:30,010
to user events but we wanted to get this

00:02:27,880 --> 00:02:31,870
working on the client and server so how

00:02:30,010 --> 00:02:35,290
does this look on the server well you

00:02:31,870 --> 00:02:37,990
don't have UI events but it is a

00:02:35,290 --> 00:02:39,580
concurrent environment that means you

00:02:37,990 --> 00:02:41,710
have two different users accessing your

00:02:39,580 --> 00:02:43,480
site at the same time they get through

00:02:41,710 --> 00:02:46,090
the dispatcher they get to the store

00:02:43,480 --> 00:02:47,620
into the view and this is where it gets

00:02:46,090 --> 00:02:50,050
complicated because the view doesn't

00:02:47,620 --> 00:02:52,630
know what to display because now the

00:02:50,050 --> 00:02:54,250
store is a singleton and so the latest

00:02:52,630 --> 00:02:57,040
value always overrides the previous

00:02:54,250 --> 00:02:59,140
value so that doesn't work on the server

00:02:57,040 --> 00:03:00,610
we realized what everybody else who is

00:02:59,140 --> 00:03:02,500
working on flux at the time realized

00:03:00,610 --> 00:03:04,000
which is we have the class the

00:03:02,500 --> 00:03:07,260
dispatcher in stores and instantiate

00:03:04,000 --> 00:03:11,290
them per request and that solves our

00:03:07,260 --> 00:03:14,380
simple problem of each user getting

00:03:11,290 --> 00:03:16,300
their own view and own data so this is

00:03:14,380 --> 00:03:18,400
all well and good you have flux on the

00:03:16,300 --> 00:03:20,650
server and client so how do we make this

00:03:18,400 --> 00:03:23,050
truly Universal how do we make the

00:03:20,650 --> 00:03:25,360
server how to make the client pick up

00:03:23,050 --> 00:03:27,610
where the server leaves off well when

00:03:25,360 --> 00:03:30,760
you're done rendering on the server you

00:03:27,610 --> 00:03:32,890
send your markup down but that's not

00:03:30,760 --> 00:03:34,990
enough for react if you call react

00:03:32,890 --> 00:03:37,330
render it'll throw away the mark-up and

00:03:34,990 --> 00:03:38,830
render its own mark up because react

00:03:37,330 --> 00:03:41,560
needs the state that you use to generate

00:03:38,830 --> 00:03:44,890
the mark-up so you also have to send

00:03:41,560 --> 00:03:47,320
down that state once you do that the

00:03:44,890 --> 00:03:50,890
browser the client-side flux can take

00:03:47,320 --> 00:03:52,870
over and you have that so whereas before

00:03:50,890 --> 00:03:55,900
we thought we were only going to share

00:03:52,870 --> 00:03:58,440
react on the server and client we were

00:03:55,900 --> 00:04:01,960
now sharing flux and flexible

00:03:58,440 --> 00:04:04,960
specifically this allows us to get rid

00:04:01,960 --> 00:04:08,620
of Yui on the client and instead rely on

00:04:04,960 --> 00:04:10,450
polyfills so what this means is we write

00:04:08,620 --> 00:04:12,730
every Oliver code and just pure

00:04:10,450 --> 00:04:14,920
JavaScript whenever we need to and we

00:04:12,730 --> 00:04:16,480
rely on polyfills instead of the cross

00:04:14,920 --> 00:04:20,080
browser abstractions you might get with

00:04:16,480 --> 00:04:21,850
the jQuery or Yui we were also able to

00:04:20,080 --> 00:04:25,230
get rid of our MVC abstractions and

00:04:21,850 --> 00:04:27,580
share flux in both the client and server

00:04:25,230 --> 00:04:30,440
and we were also able to use babbled a

00:04:27,580 --> 00:04:34,040
transpiler jsx because we soon learned

00:04:30,440 --> 00:04:36,800
was a lot more fun to write in I want to

00:04:34,040 --> 00:04:38,810
quickly address CSS as well so atomic

00:04:36,800 --> 00:04:40,970
CSS is something that Yahoo is open

00:04:38,810 --> 00:04:42,830
sourced and I don't want it to go too

00:04:40,970 --> 00:04:44,600
deep into it because it's a talk on its

00:04:42,830 --> 00:04:49,010
own but it's a really new approach to

00:04:44,600 --> 00:04:52,700
CSS you guys should check out so what we

00:04:49,010 --> 00:04:54,740
have is a really cool flux

00:04:52,700 --> 00:04:57,650
implementation that we use internally

00:04:54,740 --> 00:05:00,460
our internal framework wraps this flux

00:04:57,650 --> 00:05:03,380
flexible with our own flexible plugins

00:05:00,460 --> 00:05:05,300
flux was flexible was designed from the

00:05:03,380 --> 00:05:08,000
ground up to be pluggable so that you

00:05:05,300 --> 00:05:09,860
can use it for whatever use cases we

00:05:08,000 --> 00:05:12,050
have our own Express middleware and this

00:05:09,860 --> 00:05:15,670
that's kind of it that creates the stack

00:05:12,050 --> 00:05:19,910
for the entire Yahoo media organization

00:05:15,670 --> 00:05:22,130
so one quick caveat is that before we

00:05:19,910 --> 00:05:24,560
made flexible this framework was a thing

00:05:22,130 --> 00:05:26,960
at Yahoo so we actually realized all the

00:05:24,560 --> 00:05:29,270
parts of it that we could open source

00:05:26,960 --> 00:05:31,370
that we're generic enough to be open

00:05:29,270 --> 00:05:33,770
sores abstracted it and then open

00:05:31,370 --> 00:05:36,169
sourced it so now that we've kind of

00:05:33,770 --> 00:05:37,730
briefly touched on react and flux that

00:05:36,169 --> 00:05:42,020
you guys are probably already familiar

00:05:37,730 --> 00:05:46,130
with what is scale what does it mean to

00:05:42,020 --> 00:05:48,230
be developing applications at scale well

00:05:46,130 --> 00:05:50,240
for me it means two things there is

00:05:48,230 --> 00:05:55,360
scale of development and scale of

00:05:50,240 --> 00:05:57,980
product scale of development is that

00:05:55,360 --> 00:05:59,930
that is basically our web pack

00:05:57,980 --> 00:06:04,010
dependency graph so you see like

00:05:59,930 --> 00:06:06,560
hundreds of modules and that whole tree

00:06:04,010 --> 00:06:10,730
doesn't even fit inside of this slide

00:06:06,560 --> 00:06:12,740
it's huge and this is only one app we

00:06:10,730 --> 00:06:14,810
have a lot of applications at Yahoo and

00:06:12,740 --> 00:06:17,350
we have dozens of teams and hundreds of

00:06:14,810 --> 00:06:21,440
developers working on this so how do we

00:06:17,350 --> 00:06:23,390
say Lee keep developing well once you

00:06:21,440 --> 00:06:25,730
get to a certain size you have to invest

00:06:23,390 --> 00:06:27,650
in the right tools so that your

00:06:25,730 --> 00:06:31,850
developers can work predictive it

00:06:27,650 --> 00:06:34,730
productively so some tools we use or ES

00:06:31,850 --> 00:06:37,700
Lent and JSC s this helps you enforce

00:06:34,730 --> 00:06:39,590
code quality across all of your repos we

00:06:37,700 --> 00:06:43,039
use grunt to run our tasks we share a

00:06:39,590 --> 00:06:44,169
grunt task between projects we use

00:06:43,039 --> 00:06:46,180
yeoman so that

00:06:44,169 --> 00:06:48,879
people don't have to start off with a

00:06:46,180 --> 00:06:50,050
completely blank slate you get a good

00:06:48,879 --> 00:06:52,960
starting point for your apps and new

00:06:50,050 --> 00:06:56,039
features we use web packs dev server and

00:06:52,960 --> 00:06:59,669
hot reloading features for really cool

00:06:56,039 --> 00:07:03,999
so like library loading awesomeness and

00:06:59,669 --> 00:07:06,460
use our Jenkins see I CD for testing and

00:07:03,999 --> 00:07:07,870
developing features without worrying

00:07:06,460 --> 00:07:11,080
about whether you broken something else

00:07:07,870 --> 00:07:12,490
and really I just I know I'm just

00:07:11,080 --> 00:07:14,020
throwing a lot of tools at you but it's

00:07:12,490 --> 00:07:15,520
not important what tools you use as long

00:07:14,020 --> 00:07:17,830
as your whole team is using the same

00:07:15,520 --> 00:07:19,659
tools it's not important grunt versus

00:07:17,830 --> 00:07:22,330
gulp but you pick one and you stick to

00:07:19,659 --> 00:07:25,870
it that really allows the maximum

00:07:22,330 --> 00:07:28,389
shareability so next the scale of

00:07:25,870 --> 00:07:31,120
product it's easy to think that Yahoo is

00:07:28,389 --> 00:07:34,180
just one product but it really is a lot

00:07:31,120 --> 00:07:35,710
of products if you look at her quick if

00:07:34,180 --> 00:07:37,180
you can quickly look at our menu you

00:07:35,710 --> 00:07:38,889
realize there's a lot of diverse

00:07:37,180 --> 00:07:41,589
products here how do we go about

00:07:38,889 --> 00:07:43,529
creating an internal framework that is

00:07:41,589 --> 00:07:46,060
able to support all of these use cases

00:07:43,529 --> 00:07:48,279
we have to let each one of these teams

00:07:46,060 --> 00:07:50,529
and there is a team behind each one of

00:07:48,279 --> 00:07:52,930
these products each one of them needs to

00:07:50,529 --> 00:07:55,210
work independently but also we need to

00:07:52,930 --> 00:07:59,110
allow them to reuse as much as possible

00:07:55,210 --> 00:08:01,569
between the products let's look at one

00:07:59,110 --> 00:08:03,939
of them the home page itself if we were

00:08:01,569 --> 00:08:06,339
able to start from scratch and design

00:08:03,939 --> 00:08:08,620
yahoo com over today if I gave this to a

00:08:06,339 --> 00:08:10,899
web developer you'd be able to slice it

00:08:08,620 --> 00:08:13,060
into a three-column layout identify the

00:08:10,899 --> 00:08:15,460
important parts of the page and come up

00:08:13,060 --> 00:08:17,860
with the layouts come up with the

00:08:15,460 --> 00:08:21,159
components that fit in the layout this

00:08:17,860 --> 00:08:23,439
sounds easy but at its scale like Yahoo

00:08:21,159 --> 00:08:24,639
what happens is every single one of

00:08:23,439 --> 00:08:26,830
these components is designed by a

00:08:24,639 --> 00:08:28,509
different team that actually makes it

00:08:26,830 --> 00:08:30,039
really complicated when you want to put

00:08:28,509 --> 00:08:33,959
it all together into one cohesive

00:08:30,039 --> 00:08:36,789
experience and this problem is only

00:08:33,959 --> 00:08:40,569
complicated more by something we call

00:08:36,789 --> 00:08:43,959
context context is basically how the

00:08:40,569 --> 00:08:46,660
user is accessing the site and this is

00:08:43,959 --> 00:08:49,329
very important it's extremely important

00:08:46,660 --> 00:08:52,420
as your app starts to scale a few

00:08:49,329 --> 00:08:54,279
examples of context device a user could

00:08:52,420 --> 00:08:57,329
be on a smartphone or a desktop on a

00:08:54,279 --> 00:09:00,059
tablet it's important not to serve the

00:08:57,329 --> 00:09:02,579
same exact experience to each of those

00:09:00,059 --> 00:09:04,410
devices a small application of the

00:09:02,579 --> 00:09:05,790
startup might serve the same max same

00:09:04,410 --> 00:09:08,189
exact application across all three

00:09:05,790 --> 00:09:10,739
devices and you might hide the fact with

00:09:08,189 --> 00:09:12,689
some responsive CSS but what's really

00:09:10,739 --> 00:09:15,089
needed is a responsive JavaScript if

00:09:12,689 --> 00:09:18,269
half the code in your component is never

00:09:15,089 --> 00:09:19,980
seen by your desktop app and is only

00:09:18,269 --> 00:09:23,129
ferment for your smartphone app and vice

00:09:19,980 --> 00:09:26,119
versa is there really a point in serving

00:09:23,129 --> 00:09:29,100
the extra upload to either device I

00:09:26,119 --> 00:09:32,759
think we can do better so authentic

00:09:29,100 --> 00:09:33,869
ation and the same line of thought if

00:09:32,759 --> 00:09:35,579
you have it logged in and logged out

00:09:33,869 --> 00:09:38,069
user do you want to penalize the logged

00:09:35,579 --> 00:09:40,079
out user with all of the extra logic

00:09:38,069 --> 00:09:41,189
that comes with the logged in user maybe

00:09:40,079 --> 00:09:43,139
you're logged in user is like a

00:09:41,189 --> 00:09:45,480
completely single page app with like so

00:09:43,139 --> 00:09:47,220
many like routes and features but all

00:09:45,480 --> 00:09:48,959
the logs out user needs is just a way to

00:09:47,220 --> 00:09:52,350
sign up probably and the value

00:09:48,959 --> 00:09:55,290
proposition so let's think about

00:09:52,350 --> 00:09:57,989
browsers for a second it's easy to

00:09:55,290 --> 00:10:01,290
ignore understandably easy to ignore ie

00:09:57,989 --> 00:10:03,569
these days but when you are dealing with

00:10:01,290 --> 00:10:06,119
a scale like Yahoo we have a billion

00:10:03,569 --> 00:10:08,279
monthly active users even if a tiny

00:10:06,119 --> 00:10:11,369
fraction of them use IE cigs it's

00:10:08,279 --> 00:10:12,660
becomes not affordable for us to lose

00:10:11,369 --> 00:10:15,179
those users and give them a broken

00:10:12,660 --> 00:10:18,509
experience even if these low-grade

00:10:15,179 --> 00:10:21,899
browsers don't support the fancy web

00:10:18,509 --> 00:10:23,579
page fancy react applications you can

00:10:21,899 --> 00:10:26,069
still give them a server rendered page

00:10:23,579 --> 00:10:27,989
have it look nice on the first load

00:10:26,069 --> 00:10:29,639
don't you don't have to just serve them

00:10:27,989 --> 00:10:34,259
all of your JavaScript assets and have

00:10:29,639 --> 00:10:35,910
them not even load so context has a lot

00:10:34,259 --> 00:10:38,939
of dimensions to it devices

00:10:35,910 --> 00:10:40,619
authentications that is browsers it

00:10:38,939 --> 00:10:43,619
could even include a be testing and

00:10:40,619 --> 00:10:45,149
locales it could going on and on and it

00:10:43,619 --> 00:10:49,619
only increases the complexity of your

00:10:45,149 --> 00:10:51,839
app at first pass that this might look

00:10:49,619 --> 00:10:53,579
like this you could just be like oh if

00:10:51,839 --> 00:10:56,579
I'm on the smartphone let's render this

00:10:53,579 --> 00:10:59,160
guy and if I'm on the desktop or if I'm

00:10:56,579 --> 00:11:01,350
on this a/b test if I'm an experimental

00:10:59,160 --> 00:11:03,600
group if I'm in the control group you

00:11:01,350 --> 00:11:06,419
could do this all over your application

00:11:03,600 --> 00:11:08,970
and this might make sense to you but if

00:11:06,419 --> 00:11:10,610
a lot of developers are doing this in

00:11:08,970 --> 00:11:13,610
different parts of the code base I'm

00:11:10,610 --> 00:11:15,529
taneously you have this load everywhere

00:11:13,610 --> 00:11:19,459
and people are afraid to delete these

00:11:15,529 --> 00:11:22,430
giant if-else blocks so we actually

00:11:19,459 --> 00:11:25,339
don't want to do this what we really

00:11:22,430 --> 00:11:27,440
need is a way to serve the minimal

00:11:25,339 --> 00:11:30,140
resources needed for the best possible

00:11:27,440 --> 00:11:33,680
user experience at that one for that one

00:11:30,140 --> 00:11:35,120
request and our solution for this is

00:11:33,680 --> 00:11:37,790
something we call dynamic page

00:11:35,120 --> 00:11:39,380
composition it's essentially logic that

00:11:37,790 --> 00:11:41,779
will decide how your page will look and

00:11:39,380 --> 00:11:44,480
what resources your page will need based

00:11:41,779 --> 00:11:46,399
on the current context and there are

00:11:44,480 --> 00:11:49,730
four important resources when it comes

00:11:46,399 --> 00:11:53,959
to pages layouts components data and

00:11:49,730 --> 00:11:58,630
assets I want to go into detail about

00:11:53,959 --> 00:12:01,430
each of these layouts layouts are easy

00:11:58,630 --> 00:12:03,769
they basically take in components as

00:12:01,430 --> 00:12:07,790
input and then they arrange them into

00:12:03,769 --> 00:12:09,769
different arrangements based on what

00:12:07,790 --> 00:12:11,269
context you're in one that could the top

00:12:09,769 --> 00:12:14,380
one could be a desktop and that middle

00:12:11,269 --> 00:12:16,760
one could be a tablet view or something

00:12:14,380 --> 00:12:18,829
so to put simply they take individual

00:12:16,760 --> 00:12:21,800
parts of the page and organize them into

00:12:18,829 --> 00:12:23,630
a page react is extremely well-suited

00:12:21,800 --> 00:12:26,870
for this because you can actually pass

00:12:23,630 --> 00:12:30,260
in components as props and then react

00:12:26,870 --> 00:12:33,170
component can just return markup this is

00:12:30,260 --> 00:12:34,760
great especially in react 14 your layout

00:12:33,170 --> 00:12:40,670
functions can be pure functions they

00:12:34,760 --> 00:12:43,339
just map components to markup context is

00:12:40,670 --> 00:12:48,769
extremely important here so now let's

00:12:43,339 --> 00:12:50,180
consider components it's important not

00:12:48,769 --> 00:12:52,250
to reinvent the wheel every time you

00:12:50,180 --> 00:12:55,670
write a component especially at a large

00:12:52,250 --> 00:12:59,839
scale because as your team starts to

00:12:55,670 --> 00:13:01,430
grow its you can envision that some part

00:12:59,839 --> 00:13:03,680
of some teammates might be working on a

00:13:01,430 --> 00:13:05,480
feature and that exact logic might be

00:13:03,680 --> 00:13:07,519
needed down somewhere down the line but

00:13:05,480 --> 00:13:09,410
people don't know that this somebody's

00:13:07,519 --> 00:13:11,149
already written this so it becomes

00:13:09,410 --> 00:13:12,920
important to maintain some sort of

00:13:11,149 --> 00:13:15,829
internal knowledge base where people can

00:13:12,920 --> 00:13:18,110
go to figure out if you this kind of

00:13:15,829 --> 00:13:20,390
thing has already been written so for

00:13:18,110 --> 00:13:22,010
example if I if I wrote an image

00:13:20,390 --> 00:13:22,680
component and this image component

00:13:22,010 --> 00:13:24,870
contain

00:13:22,680 --> 00:13:27,330
some commonly used logic where it won't

00:13:24,870 --> 00:13:28,620
load the image right away it'll load the

00:13:27,330 --> 00:13:31,529
image when it's scrolls into the

00:13:28,620 --> 00:13:33,890
viewport saving some bandwidth that

00:13:31,529 --> 00:13:37,560
sounds like a useful piece of code I

00:13:33,890 --> 00:13:40,910
wanted to use it in a article page for

00:13:37,560 --> 00:13:42,959
the inline images well this is great but

00:13:40,910 --> 00:13:44,850
what if somebody else wants to write a

00:13:42,959 --> 00:13:46,860
gallery this sounds like a great idea

00:13:44,850 --> 00:13:49,170
for a gallery as well the same logic

00:13:46,860 --> 00:13:50,520
could be applied here but we don't want

00:13:49,170 --> 00:13:52,320
them to rewrite it because then now you

00:13:50,520 --> 00:13:55,500
have two components to image components

00:13:52,320 --> 00:13:58,560
that you're loading so what we do is we

00:13:55,500 --> 00:14:01,890
have good guidelines on how to create

00:13:58,560 --> 00:14:04,050
reusable composable components react

00:14:01,890 --> 00:14:06,779
kind of already and for just by its

00:14:04,050 --> 00:14:09,240
nature and forces composability but if

00:14:06,779 --> 00:14:11,370
you take care in the API that you

00:14:09,240 --> 00:14:14,220
exposed to other users and how to use

00:14:11,370 --> 00:14:17,220
your components you can really make them

00:14:14,220 --> 00:14:22,140
truly reusable across any number of

00:14:17,220 --> 00:14:24,420
context data fetching and flexible is

00:14:22,140 --> 00:14:26,399
actually quite simple actions are the

00:14:24,420 --> 00:14:27,870
only parts of your application that's

00:14:26,399 --> 00:14:30,089
allowed to be asynchronous and fetch

00:14:27,870 --> 00:14:32,580
data they have access to this library

00:14:30,089 --> 00:14:35,370
called fetcher and fetcher has access to

00:14:32,580 --> 00:14:37,339
all of your rest api's once your rest

00:14:35,370 --> 00:14:39,900
api returns fetcher transparently

00:14:37,339 --> 00:14:42,540
returns the data down to your action and

00:14:39,900 --> 00:14:44,910
the cool thing about fetcher is that it

00:14:42,540 --> 00:14:46,529
works isomorphic lee on the server and

00:14:44,910 --> 00:14:48,810
client and so you can write the same

00:14:46,529 --> 00:14:52,700
exact code and have the same exact data

00:14:48,810 --> 00:14:56,190
returned to you on the server and client

00:14:52,700 --> 00:14:59,670
so once you get the data back you you

00:14:56,190 --> 00:15:01,410
can sorry once you get the data back you

00:14:59,670 --> 00:15:04,170
can follow through with your flux flow

00:15:01,410 --> 00:15:06,839
and the rest of your actions can also

00:15:04,170 --> 00:15:09,750
talk to fetcher this is well and good

00:15:06,839 --> 00:15:11,579
but what about the first time you render

00:15:09,750 --> 00:15:16,490
an application how do you get the data

00:15:11,579 --> 00:15:19,770
that you need for the first render well

00:15:16,490 --> 00:15:21,779
if you look at the view the view gets

00:15:19,770 --> 00:15:23,790
its data from the store but the store

00:15:21,779 --> 00:15:26,790
gets its data from the action so somehow

00:15:23,790 --> 00:15:29,370
the action needs to know what hbu it is

00:15:26,790 --> 00:15:31,560
going to render this looks like it's

00:15:29,370 --> 00:15:33,240
easily solvable because when you're on

00:15:31,560 --> 00:15:34,529
the home page the home page needs a

00:15:33,240 --> 00:15:36,000
certain amount of data when you're on

00:15:34,529 --> 00:15:37,590
the next page

00:15:36,000 --> 00:15:40,290
whatever page that you've defined it

00:15:37,590 --> 00:15:42,210
needs to render a certain component and

00:15:40,290 --> 00:15:44,910
it's easy enough to assume that that

00:15:42,210 --> 00:15:47,010
component has a certain data that you

00:15:44,910 --> 00:15:50,190
know about but when you're dealing with

00:15:47,010 --> 00:15:53,400
an application that is huge and that has

00:15:50,190 --> 00:15:55,620
a lot of nested components it's hard to

00:15:53,400 --> 00:15:58,380
reason about what data could be needed

00:15:55,620 --> 00:16:00,510
when you're trying to run this

00:15:58,380 --> 00:16:01,890
application so it becomes a problem to

00:16:00,510 --> 00:16:05,940
determine the data that you need at

00:16:01,890 --> 00:16:09,000
runtime so actually one solution to this

00:16:05,940 --> 00:16:13,040
is real a real a kind of Soulstice in

00:16:09,000 --> 00:16:16,830
the same exact way that we do but relay

00:16:13,040 --> 00:16:18,810
salsas by attaching statically on to

00:16:16,830 --> 00:16:21,300
every component some graph ql query that

00:16:18,810 --> 00:16:24,900
gets extremely complicated and i don't

00:16:21,300 --> 00:16:27,600
want to talk about it but all we do is

00:16:24,900 --> 00:16:30,120
we declare an action statically on the

00:16:27,600 --> 00:16:32,190
view and we've already talked about the

00:16:30,120 --> 00:16:34,560
actions being able to access the fetcher

00:16:32,190 --> 00:16:37,260
and fetch whatever any kind of data they

00:16:34,560 --> 00:16:40,050
need it's your secure function so when

00:16:37,260 --> 00:16:42,210
you declare statically in action on

00:16:40,050 --> 00:16:44,550
every view you're able to access these

00:16:42,210 --> 00:16:47,100
views access these actions without

00:16:44,550 --> 00:16:49,620
actually rendering you can run these

00:16:47,100 --> 00:16:51,870
actions before you ever have the need to

00:16:49,620 --> 00:16:54,990
render populate your stores so when it

00:16:51,870 --> 00:16:57,210
comes time to rendering you can have all

00:16:54,990 --> 00:16:59,700
your data ready we can see an example

00:16:57,210 --> 00:17:01,710
here if your users trying to navigate to

00:16:59,700 --> 00:17:04,439
that article page an article page will

00:17:01,710 --> 00:17:07,290
map to an article view when the article

00:17:04,439 --> 00:17:08,459
view will have its own initial action so

00:17:07,290 --> 00:17:10,560
then I have a good action will go to the

00:17:08,459 --> 00:17:13,199
article action and then we'll fetch the

00:17:10,560 --> 00:17:15,120
data that we need it'll come back to the

00:17:13,199 --> 00:17:16,740
navigate action the navigate action will

00:17:15,120 --> 00:17:24,000
continue through the flux flow and

00:17:16,740 --> 00:17:26,459
render out the component so next it's so

00:17:24,000 --> 00:17:28,199
let's go back one second so here you can

00:17:26,459 --> 00:17:29,720
see that the view and the action are

00:17:28,199 --> 00:17:33,450
actually tightly coupled right there

00:17:29,720 --> 00:17:35,670
it's also easy to imagine how this in

00:17:33,450 --> 00:17:37,950
addition to the view in the action the

00:17:35,670 --> 00:17:42,420
data service and the store could also be

00:17:37,950 --> 00:17:43,950
coupled to the to the article view so we

00:17:42,420 --> 00:17:46,590
came up with a concept called bundles

00:17:43,950 --> 00:17:47,970
which are the actual individual modules

00:17:46,590 --> 00:17:51,179
that are shared

00:17:47,970 --> 00:17:52,950
teams a bundle could be a component but

00:17:51,179 --> 00:17:55,080
it could also be a store an action

00:17:52,950 --> 00:17:57,870
creator service or CSS that this

00:17:55,080 --> 00:18:01,049
component needs to render so you we

00:17:57,870 --> 00:18:03,120
allow users to package these up as they

00:18:01,049 --> 00:18:07,049
would and publish them to an internal

00:18:03,120 --> 00:18:09,510
NPM registry and this really allows re

00:18:07,049 --> 00:18:11,400
maximum reusability because now you have

00:18:09,510 --> 00:18:13,860
other users they can just install it

00:18:11,400 --> 00:18:15,659
require it and see if that component

00:18:13,860 --> 00:18:19,980
solves their problem if not they can

00:18:15,659 --> 00:18:22,679
just get rid of it but yeah facilitate

00:18:19,980 --> 00:18:28,559
maximum reuse bundles so once you have

00:18:22,679 --> 00:18:30,990
these bundles it's time for sending them

00:18:28,559 --> 00:18:33,450
down to the server so in the old world

00:18:30,990 --> 00:18:35,850
in an old single page application you

00:18:33,450 --> 00:18:38,370
have all of your bundles or assets user

00:18:35,850 --> 00:18:41,850
comes to your page he wants the bundles

00:18:38,370 --> 00:18:44,490
he gets all the bundles but we can do

00:18:41,850 --> 00:18:46,409
better than that with smart asset

00:18:44,490 --> 00:18:48,630
loading if a user comes to your home

00:18:46,409 --> 00:18:52,169
page you saw them just the homepage if

00:18:48,630 --> 00:18:54,750
your user then exhibits some action like

00:18:52,169 --> 00:18:56,309
a scroll you can then load say that's

00:18:54,750 --> 00:18:57,659
the comments bundle you can render the

00:18:56,309 --> 00:18:59,730
comments at the bottom of the page and

00:18:57,659 --> 00:19:01,770
then if the user tries to navigate our

00:18:59,730 --> 00:19:03,929
way to a different page you can load the

00:19:01,770 --> 00:19:08,730
assets that you need later rather than

00:19:03,929 --> 00:19:10,860
now so if we go back to the question of

00:19:08,730 --> 00:19:13,770
serving the minimal set of resources for

00:19:10,860 --> 00:19:17,010
the best user experience have you

00:19:13,770 --> 00:19:19,530
achieved that well with flexible layouts

00:19:17,010 --> 00:19:22,710
reusable components statically declared

00:19:19,530 --> 00:19:26,669
data and smart bundle loading we have

00:19:22,710 --> 00:19:27,840
all of the resources we need but I don't

00:19:26,669 --> 00:19:29,309
know if we achieve the best user

00:19:27,840 --> 00:19:31,380
experience but we have definitely

00:19:29,309 --> 00:19:33,690
achieved a better user experience this

00:19:31,380 --> 00:19:36,690
will lead to faster page loads smaller

00:19:33,690 --> 00:19:43,289
okay wait and viewer requests made by

00:19:36,690 --> 00:19:45,210
the app so what's next well we're not

00:19:43,289 --> 00:19:46,350
quite done yet these next few topics

00:19:45,210 --> 00:19:47,640
that I'm going to talk about are the

00:19:46,350 --> 00:19:50,669
challenges that we're facing right now

00:19:47,640 --> 00:19:53,970
and these solutions aren't fully vetted

00:19:50,669 --> 00:19:56,669
and if you guys have seen these problems

00:19:53,970 --> 00:19:58,590
before please come talk to me time to

00:19:56,669 --> 00:20:00,870
first byte flush if you guys aren't

00:19:58,590 --> 00:20:01,420
familiar this is how long it takes from

00:20:00,870 --> 00:20:03,400
the

00:20:01,420 --> 00:20:05,920
you get the request to the time you

00:20:03,400 --> 00:20:09,400
respond with something to the user so

00:20:05,920 --> 00:20:11,680
typically where they react app it's this

00:20:09,400 --> 00:20:12,940
is probably what you do you get the

00:20:11,680 --> 00:20:14,920
requests you route it to the proper

00:20:12,940 --> 00:20:16,480
assets you get the data that you need

00:20:14,920 --> 00:20:18,910
your render II components and you send

00:20:16,480 --> 00:20:21,580
it down but actually you don't have to

00:20:18,910 --> 00:20:24,250
wait this long you can flush as early as

00:20:21,580 --> 00:20:26,320
needed you can flush all of your assets

00:20:24,250 --> 00:20:28,090
down so that the browser's starts to

00:20:26,320 --> 00:20:29,980
parse all the JavaScript files as early

00:20:28,090 --> 00:20:33,190
as possible while you're still rendering

00:20:29,980 --> 00:20:35,830
your react components this definitely

00:20:33,190 --> 00:20:37,840
provides a performance boost what's even

00:20:35,830 --> 00:20:40,510
better than this is actually to flesh

00:20:37,840 --> 00:20:42,430
more often but this is harder to do

00:20:40,510 --> 00:20:44,800
because with our current architecture

00:20:42,430 --> 00:20:47,320
and with most architectures have seen

00:20:44,800 --> 00:20:49,870
there is one single giant react

00:20:47,320 --> 00:20:52,180
component at the top and react rendered

00:20:49,870 --> 00:20:53,680
a string is a synchronous method what

00:20:52,180 --> 00:20:55,300
that means is you have to actually wait

00:20:53,680 --> 00:20:57,730
until this whole thing completes before

00:20:55,300 --> 00:20:59,830
you can flush down anything but what is

00:20:57,730 --> 00:21:02,740
ideal is to flush down markup as its

00:20:59,830 --> 00:21:04,690
becomes ready so one thing we're

00:21:02,740 --> 00:21:09,610
considering doing is to have multiple

00:21:04,690 --> 00:21:11,940
trees that we can render so the next is

00:21:09,610 --> 00:21:15,520
concept called progressive rendering and

00:21:11,940 --> 00:21:17,440
with progressive rendering we're able to

00:21:15,520 --> 00:21:19,720
decide dynamically whether we want to

00:21:17,440 --> 00:21:23,110
render and serve data on the client or

00:21:19,720 --> 00:21:25,330
the server so if you're familiar with

00:21:23,110 --> 00:21:27,190
the concept of above fold and below fold

00:21:25,330 --> 00:21:29,260
everything in their view port when you

00:21:27,190 --> 00:21:30,610
go to a website is above fold and those

00:21:29,260 --> 00:21:33,280
things we definitely want to fetch the

00:21:30,610 --> 00:21:35,050
data and render server-side but again

00:21:33,280 --> 00:21:37,240
going back to a comments module at the

00:21:35,050 --> 00:21:40,750
bottom of the page you don't need to

00:21:37,240 --> 00:21:42,160
render it client-side I don't need to

00:21:40,750 --> 00:21:44,620
render its server side so you can send

00:21:42,160 --> 00:21:49,360
it to the client and differ rendering it

00:21:44,620 --> 00:21:51,310
and save that xhr so some few few

00:21:49,360 --> 00:21:56,470
problems that we're facing right now bad

00:21:51,310 --> 00:21:58,630
parts of reactant flux check some issues

00:21:56,470 --> 00:22:03,060
any small error will throw away all your

00:21:58,630 --> 00:22:05,710
markup and that's kind of just bad so

00:22:03,060 --> 00:22:07,300
our solution that we're trying out right

00:22:05,710 --> 00:22:09,020
now is to have multiple react rendered

00:22:07,300 --> 00:22:11,120
trees so that if one

00:22:09,020 --> 00:22:12,680
part of the markup and one render tree

00:22:11,120 --> 00:22:16,550
fails the rest of your markup gets

00:22:12,680 --> 00:22:18,170
reused others iframes if you're her try

00:22:16,550 --> 00:22:19,430
to rerender an iframe it actually just

00:22:18,170 --> 00:22:22,400
realized the whole thing because you

00:22:19,430 --> 00:22:24,770
can't dip the Dom inside of an iframe so

00:22:22,400 --> 00:22:27,020
that's another issue that we're facing

00:22:24,770 --> 00:22:30,770
right now it's not easy to solve with

00:22:27,020 --> 00:22:33,290
reacts virtual Dom unfortunately but if

00:22:30,770 --> 00:22:35,720
you have any ideas about these kind of

00:22:33,290 --> 00:22:39,230
problems come talk to me I have some

00:22:35,720 --> 00:22:51,620
flexible shirts to give out so feel free

00:22:39,230 --> 00:22:53,000
to come grab them great cool we have to

00:22:51,620 --> 00:22:57,230
steal a couple of minutes so we can go

00:22:53,000 --> 00:23:05,360
three two questions okay so why flexible

00:22:57,230 --> 00:23:07,370
over redux wow so it's it's a we just

00:23:05,360 --> 00:23:10,220
actually release this thing called the

00:23:07,370 --> 00:23:12,800
read it reducer store add-on which lets

00:23:10,220 --> 00:23:16,040
you use flexible as a giant reducer

00:23:12,800 --> 00:23:18,770
store and add reducers to it so they're

00:23:16,040 --> 00:23:21,860
not necessarily mutually exclusive but

00:23:18,770 --> 00:23:25,040
it's Redux leaves a lot up for

00:23:21,860 --> 00:23:28,040
interpretation outside of the reducers

00:23:25,040 --> 00:23:31,220
because how you like I was talking about

00:23:28,040 --> 00:23:33,680
the layout all that logic can be

00:23:31,220 --> 00:23:36,710
extremely complicated to handle outside

00:23:33,680 --> 00:23:39,080
of redux but we're experimenting with it

00:23:36,710 --> 00:23:40,910
the reducers store add-on is something

00:23:39,080 --> 00:23:43,310
we want to try to see how the

00:23:40,910 --> 00:23:47,000
performance plays out right now we have

00:23:43,310 --> 00:23:48,560
a lot of stores that you know yeah that

00:23:47,000 --> 00:23:50,270
a lot of different teams made and so

00:23:48,560 --> 00:23:51,860
it's hard to ask them all to be like hey

00:23:50,270 --> 00:23:58,390
guys this new framework came up can we

00:23:51,860 --> 00:23:58,390
all switch so i hope i answered that one

00:24:00,250 --> 00:24:06,290
private npm what's been our experience

00:24:02,870 --> 00:24:08,240
using private npm it's not npm

00:24:06,290 --> 00:24:10,760
enterprise we actually run our own npm

00:24:08,240 --> 00:24:13,940
it's called YN p.m. we try to put a y in

00:24:10,760 --> 00:24:16,970
front of everything internally but we

00:24:13,940 --> 00:24:19,730
have a guy he maintains why npm it works

00:24:16,970 --> 00:24:21,480
the same we just have y npm command line

00:24:19,730 --> 00:24:24,480
and so i think it's a wrapper around

00:24:21,480 --> 00:24:27,150
the actual npm but it's been extremely

00:24:24,480 --> 00:24:30,240
useful for us because when you're able

00:24:27,150 --> 00:24:32,640
to not have to go to another repo to

00:24:30,240 --> 00:24:35,280
like clone it or anything to share code

00:24:32,640 --> 00:24:37,500
you can just install it that helps

00:24:35,280 --> 00:24:38,490
especially in release pipelines because

00:24:37,500 --> 00:24:40,410
you're able to install the latest

00:24:38,490 --> 00:24:47,910
versions instead of copying other

00:24:40,410 --> 00:24:50,100
people's code internally do I consider

00:24:47,910 --> 00:24:54,809
using reacts to render for initial page

00:24:50,100 --> 00:24:56,429
load yes yeah that's one of the reasons

00:24:54,809 --> 00:24:58,380
we do it is because the initial page

00:24:56,429 --> 00:25:00,600
load will be much faster if rendered on

00:24:58,380 --> 00:25:03,120
the server instead of letting the client

00:25:00,600 --> 00:25:04,710
do that all of that logic especially

00:25:03,120 --> 00:25:06,750
because of the data because on the

00:25:04,710 --> 00:25:09,900
server we're able to do all of the data

00:25:06,750 --> 00:25:11,520
fetching so if our if our page has like

00:25:09,900 --> 00:25:12,990
five different modules till about five

00:25:11,520 --> 00:25:15,030
different teams that's five different

00:25:12,990 --> 00:25:16,740
backends that we need to talk to we can

00:25:15,030 --> 00:25:18,179
do all of that very fast on the server

00:25:16,740 --> 00:25:20,370
because they're collocated in our

00:25:18,179 --> 00:25:21,660
databases but on the client if you had

00:25:20,370 --> 00:25:28,559
to do extra charge to all five of them

00:25:21,660 --> 00:25:31,679
that's very slow how our stores

00:25:28,559 --> 00:25:37,470
initiated when calling statically linked

00:25:31,679 --> 00:25:40,890
action of a view this is interesting we

00:25:37,470 --> 00:25:43,049
actually are able to statically when I

00:25:40,890 --> 00:25:45,000
mentioned bundles when you inst NPM

00:25:43,049 --> 00:25:47,669
install a bundle it comes with stores

00:25:45,000 --> 00:25:51,600
and those stores are all like we

00:25:47,669 --> 00:25:54,270
statically crawl our app and we know how

00:25:51,600 --> 00:25:59,070
many stores there are so when an action

00:25:54,270 --> 00:26:00,660
is needs to dispatch some data so these

00:25:59,070 --> 00:26:01,919
statically linked actions once it gets

00:26:00,660 --> 00:26:05,730
the data they dispatch it to the

00:26:01,919 --> 00:26:10,049
dispatcher and the dispatcher it based

00:26:05,730 --> 00:26:12,179
on what the actual like action string is

00:26:10,049 --> 00:26:14,309
dispatching it's able to recognize what

00:26:12,179 --> 00:26:16,020
stores need to be instantiated because

00:26:14,309 --> 00:26:17,910
we've already parched all of the stores

00:26:16,020 --> 00:26:19,620
and know what all the handlers that this

00:26:17,910 --> 00:26:22,799
doors are listening for what are all the

00:26:19,620 --> 00:26:24,299
actions there that they need so we only

00:26:22,799 --> 00:26:28,010
instantiate the stores that are needed

00:26:24,299 --> 00:26:28,010
we don't instantiate all of the stores

00:26:30,350 --> 00:26:37,800
can you have cycles in a tree

00:26:33,290 --> 00:26:41,820
representing actions I'm not sure what

00:26:37,800 --> 00:26:44,280
that means no worries i think you know

00:26:41,820 --> 00:26:46,590
we're out of the the questions with the

00:26:44,280 --> 00:26:47,970
proper amounts of likes so r a chief

00:26:46,590 --> 00:26:50,690
thank you so much for your time and for

00:26:47,970 --> 00:26:50,690

YouTube URL: https://www.youtube.com/watch?v=M3suoQuDvH4


