Title: Functional Programming in JavaScript. What, Why, and How | Daniel Steigerwald | Reactive 2015
Publication date: 2017-06-29
Playlist: ReactiveConf 2015
Description: 
	As programs get bigger, they also become more complex and harder to understand. We all think ourselves pretty clever, of course, but we are mere human beings, and even a moderate amount of chaos tends to baffle us. And then it all goes downhill. Working on something you do not really understand is a bit like cutting random wires on those time-activated bombs they always have in movies. If you are lucky, you might get the right one ― especially if you are the hero of the movie and strike a suitably dramatic pose ― but there is always the possibility of blowing everything up.

Daniel Steigerwald is the Creator of Este, dev stack and starter kit for React/Flux universal web applications. Angel developer, Google Developer Expert, libertarian.
Captions: 
	00:00:05,639 --> 00:00:14,799
so hi welcome in this beautiful city and

00:00:10,230 --> 00:00:18,160
great conference I'm really glad I was

00:00:14,799 --> 00:00:21,930
invited here I will talk about

00:00:18,160 --> 00:00:25,240
functional programming in JavaScript I

00:00:21,930 --> 00:00:27,750
should introduce myself my name is

00:00:25,240 --> 00:00:30,430
Dennis take you out and I'm a forward

00:00:27,750 --> 00:00:36,780
Google developer expert for three years

00:00:30,430 --> 00:00:40,420
and now I'm I'm the JavaScript teacher I

00:00:36,780 --> 00:00:44,319
maintained a development stick it's

00:00:40,420 --> 00:00:48,370
basically the probably the most

00:00:44,319 --> 00:00:50,620
maintained starter kit for universal

00:00:48,370 --> 00:00:54,639
that application native application

00:00:50,620 --> 00:00:58,389
written in Iraq reg ax in the table Jas

00:00:54,639 --> 00:01:03,930
it's something it's not used only by me

00:00:58,389 --> 00:01:08,380
but we have already 44 contributors and

00:01:03,930 --> 00:01:12,040
that's all even so if you want to know

00:01:08,380 --> 00:01:14,380
more just check it so the topic of our

00:01:12,040 --> 00:01:18,850
talk is the functional programming and

00:01:14,380 --> 00:01:22,780
what's the best behind that because you

00:01:18,850 --> 00:01:24,820
affect so there is on the right side you

00:01:22,780 --> 00:01:28,690
can read some boring description from

00:01:24,820 --> 00:01:31,690
Wikipedia which is not helpful if you

00:01:28,690 --> 00:01:35,110
don't see the code and therefore I will

00:01:31,690 --> 00:01:41,050
show you some real code because one code

00:01:35,110 --> 00:01:43,570
is worth of thousand verse and I let me

00:01:41,050 --> 00:01:46,240
do a small prediction I think the

00:01:43,570 --> 00:01:48,400
functional programming is going to

00:01:46,240 --> 00:01:52,840
mainstream for the next year

00:01:48,400 --> 00:01:56,380
finally it's still a new thing for a lot

00:01:52,840 --> 00:01:59,140
of people I'm quite surprised I had a

00:01:56,380 --> 00:02:01,210
workshop yesterday and I was asking how

00:01:59,140 --> 00:02:04,150
many people know the functional

00:02:01,210 --> 00:02:08,950
programming and only three or four hands

00:02:04,150 --> 00:02:12,400
were raised so that's why I decided the

00:02:08,950 --> 00:02:14,430
stock should be more basic and advanced

00:02:12,400 --> 00:02:17,340
and the next reason

00:02:14,430 --> 00:02:20,010
why it's super advanced is that I am

00:02:17,340 --> 00:02:23,340
talking only about the stuff I'm using

00:02:20,010 --> 00:02:25,530
in production it's something like

00:02:23,340 --> 00:02:28,109
Facebook does with the open source

00:02:25,530 --> 00:02:30,689
Facebook is open sourcing only stuff

00:02:28,109 --> 00:02:34,439
they are using in the production so I

00:02:30,689 --> 00:02:37,829
think it's good pattern so what's

00:02:34,439 --> 00:02:41,120
happening I think if someone is reading

00:02:37,829 --> 00:02:44,280
Twitter and newspapers and cetera cetera

00:02:41,120 --> 00:02:49,470
he must realize that functional

00:02:44,280 --> 00:02:52,370
programming is it's hot stuff even the

00:02:49,470 --> 00:02:57,590
old languages like C++ 11 and Java

00:02:52,370 --> 00:02:59,909
already has a lambda expression with

00:02:57,590 --> 00:03:03,510
JavaScript and the paper script we had a

00:02:59,909 --> 00:03:06,900
lot of fun beautiful syntax pretty

00:03:03,510 --> 00:03:09,030
useful from functional programming also

00:03:06,900 --> 00:03:12,900
I would say the functional programming

00:03:09,030 --> 00:03:14,040
in the front end has been introduced by

00:03:12,900 --> 00:03:17,280
react

00:03:14,040 --> 00:03:20,280
mainly because why rect is different I

00:03:17,280 --> 00:03:21,659
and why the other libraries are copying

00:03:20,280 --> 00:03:26,150
the react

00:03:21,659 --> 00:03:31,079
it's Arrakis has the functional routes

00:03:26,150 --> 00:03:33,510
the same apply for flux and redux and

00:03:31,079 --> 00:03:37,199
immutable I remember so as you can see

00:03:33,510 --> 00:03:40,139
you know now what about I'm going to

00:03:37,199 --> 00:03:44,189
talk what is functional programming it's

00:03:40,139 --> 00:03:46,889
not esoteric stuff but it seems like is

00:03:44,189 --> 00:03:49,439
a trick stuff I was previous here in

00:03:46,889 --> 00:03:51,389
Google developer conference and I tried

00:03:49,439 --> 00:03:52,889
to talk with my colleagues from Google

00:03:51,389 --> 00:03:55,919
about the functional programming and

00:03:52,889 --> 00:03:59,009
they told me it's something academic

00:03:55,919 --> 00:04:04,819
stuff it's not usable in the production

00:03:59,009 --> 00:04:07,799
you know hope is here forever and so

00:04:04,819 --> 00:04:09,930
it's my it was my failed I try to

00:04:07,799 --> 00:04:13,379
explain why functional programming works

00:04:09,930 --> 00:04:16,889
but I didn't succeed it nevermind so

00:04:13,379 --> 00:04:18,539
just a quick list don't stay home

00:04:16,889 --> 00:04:21,180
because I will show you the real

00:04:18,539 --> 00:04:23,930
examples so it's basically pure

00:04:21,180 --> 00:04:27,430
functions everywhere immutable values

00:04:23,930 --> 00:04:29,139
composition over inheritance records or

00:04:27,430 --> 00:04:32,470
and it's all about the timing

00:04:29,139 --> 00:04:35,080
side-effects and as I said it's no

00:04:32,470 --> 00:04:38,139
esoteric stuff

00:04:35,080 --> 00:04:40,449
I think the functional programming is

00:04:38,139 --> 00:04:43,660
something like artificial intelligence

00:04:40,449 --> 00:04:45,880
you know it sounds cool it sounds magic

00:04:43,660 --> 00:04:48,190
it sounds strange artificial

00:04:45,880 --> 00:04:50,190
intelligence but what do you understand

00:04:48,190 --> 00:04:55,930
how it works it's just the boring

00:04:50,190 --> 00:04:59,380
ordinary programming why function

00:04:55,930 --> 00:05:02,229
it's nothing you it's a pretty cool

00:04:59,380 --> 00:05:06,669
thing but for some reason we forget what

00:05:02,229 --> 00:05:09,520
we have learned dozens years ago if you

00:05:06,669 --> 00:05:11,740
know software is eating world is a

00:05:09,520 --> 00:05:15,669
famous quote from Mark under scene and

00:05:11,740 --> 00:05:19,180
because the software is driving

00:05:15,669 --> 00:05:21,250
everything must be as good as possible

00:05:19,180 --> 00:05:24,070
and functional it's proof functional

00:05:21,250 --> 00:05:26,860
programming leads to less box less

00:05:24,070 --> 00:05:33,419
complexity more readable code and more

00:05:26,860 --> 00:05:36,280
performance so it's Autopia really bad

00:05:33,419 --> 00:05:39,340
object-oriented programming no it isn't

00:05:36,280 --> 00:05:40,840
it's just misused you know this is not

00:05:39,340 --> 00:05:41,680
should be supposed to be hate speech

00:05:40,840 --> 00:05:44,860
against

00:05:41,680 --> 00:05:47,830
Oopa you dicks you doing it did it wrong

00:05:44,860 --> 00:05:50,979
no no hope it just was misused because

00:05:47,830 --> 00:05:54,220
nobody we all as developers are soft

00:05:50,979 --> 00:05:56,020
educated guys and for some reason nobody

00:05:54,220 --> 00:06:02,190
told us about the functional programming

00:05:56,020 --> 00:06:06,460
can be so fun and so good but it can be

00:06:02,190 --> 00:06:09,130
misuse like oo P was I like to think

00:06:06,460 --> 00:06:12,580
about object-oriented programming like

00:06:09,130 --> 00:06:15,729
about distributed state and it's

00:06:12,580 --> 00:06:19,930
something inevitable distributed systems

00:06:15,729 --> 00:06:22,240
are ugly they are hard but they are here

00:06:19,930 --> 00:06:29,050
to stay and that's all you can do with

00:06:22,240 --> 00:06:32,740
that nothing almost so in my slides

00:06:29,050 --> 00:06:34,780
there I leave that a lot of links useful

00:06:32,740 --> 00:06:37,479
for you to self educate yourselves I

00:06:34,780 --> 00:06:39,159
highly recommend this beautiful talk

00:06:37,479 --> 00:06:40,290
about functional programming design

00:06:39,159 --> 00:06:44,130
patterns

00:06:40,290 --> 00:06:45,720
from Scott it's funny funny to listen

00:06:44,130 --> 00:06:47,730
him because it's fun to listen him

00:06:45,720 --> 00:06:53,390
because he is a very good speaker not

00:06:47,730 --> 00:06:59,940
like me and he explained all these

00:06:53,390 --> 00:07:03,570
details in a very simple way so how many

00:06:59,940 --> 00:07:07,200
of you are using design patterns in your

00:07:03,570 --> 00:07:11,340
in your code and be be honest

00:07:07,200 --> 00:07:15,030
raise your hands well that's that's a

00:07:11,340 --> 00:07:16,970
good thing and do you like that do you

00:07:15,030 --> 00:07:19,950
think you are doing this a good thing

00:07:16,970 --> 00:07:21,540
probably probably yes because it was

00:07:19,950 --> 00:07:25,440
written in C we should do there are

00:07:21,540 --> 00:07:29,670
supposed to do that but sometimes it's

00:07:25,440 --> 00:07:33,930
not as good as it could be we have more

00:07:29,670 --> 00:07:37,950
options so again what's wrong with OB in

00:07:33,930 --> 00:07:40,620
more detail basically every method to

00:07:37,950 --> 00:07:43,830
call on some instance is effectively

00:07:40,620 --> 00:07:48,240
side effect and side effects are hard to

00:07:43,830 --> 00:07:51,180
track hard to reason about and nobody

00:07:48,240 --> 00:07:53,790
likes surprises in code surprise

00:07:51,180 --> 00:07:56,370
surprise in the world in their life it's

00:07:53,790 --> 00:07:57,360
good but surprise surprise in the code

00:07:56,370 --> 00:08:01,380
is nothing good

00:07:57,360 --> 00:08:04,320
so inheritance we were told that we

00:08:01,380 --> 00:08:07,350
should use inheritance but inheritance

00:08:04,320 --> 00:08:10,170
is trapped because it freezes your

00:08:07,350 --> 00:08:12,990
design mistakes and it's such a code

00:08:10,170 --> 00:08:16,200
it's not flexible enough and it's hard

00:08:12,990 --> 00:08:20,220
to change it later also all these design

00:08:16,200 --> 00:08:21,690
patterns is just the simple principles

00:08:20,220 --> 00:08:24,690
but the hard thing about design patterns

00:08:21,690 --> 00:08:27,090
is how to name these things or correctly

00:08:24,690 --> 00:08:31,740
because we are masquerading as nouns

00:08:27,090 --> 00:08:33,479
strategies factories commands and if you

00:08:31,740 --> 00:08:37,430
think about the patterns is just simple

00:08:33,479 --> 00:08:44,550
functions it makes much more sense

00:08:37,430 --> 00:08:46,590
naming stuff is hard yeah you know so

00:08:44,550 --> 00:08:48,699
and that's how it looks like in the real

00:08:46,590 --> 00:08:53,930
application

00:08:48,699 --> 00:08:55,999
so it was joke and but all good jokes

00:08:53,930 --> 00:09:02,600
are based on the reality and this is the

00:08:55,999 --> 00:09:04,550
reality we have to deal react I think it

00:09:02,600 --> 00:09:06,079
doesn't make sense to talk about to

00:09:04,550 --> 00:09:08,389
react in the details on direct

00:09:06,079 --> 00:09:10,970
conference because the react is the

00:09:08,389 --> 00:09:13,430
reason why you are here so I would just

00:09:10,970 --> 00:09:15,860
highlight some things the people still

00:09:13,430 --> 00:09:18,439
are misunderstanding direct as the

00:09:15,860 --> 00:09:20,509
virtual dome and all the virtual dome is

00:09:18,439 --> 00:09:23,230
just implementation detail the most

00:09:20,509 --> 00:09:27,740
important thing about react is

00:09:23,230 --> 00:09:31,629
functional composition and that's why

00:09:27,740 --> 00:09:36,589
the react components are written in code

00:09:31,629 --> 00:09:40,490
JSX is adjust code looking like XML like

00:09:36,589 --> 00:09:44,269
syntax with which is proof for hair

00:09:40,490 --> 00:09:48,910
clicker structures but still is the code

00:09:44,269 --> 00:09:52,490
and I really have no idea how the other

00:09:48,910 --> 00:09:55,339
libraries like ember or angular is

00:09:52,490 --> 00:10:01,000
trying to express functional composition

00:09:55,339 --> 00:10:02,600
in HTML string tag soup template

00:10:01,000 --> 00:10:06,620
recently I

00:10:02,600 --> 00:10:08,600
I checked the I watching the development

00:10:06,620 --> 00:10:11,209
around the angular a lot I recently I

00:10:08,600 --> 00:10:13,430
check these issues and there was

00:10:11,209 --> 00:10:17,300
something like let's vote about the

00:10:13,430 --> 00:10:20,079
right syntax so they are still trying to

00:10:17,300 --> 00:10:23,420
solve the best syntax for the misuse

00:10:20,079 --> 00:10:25,100
HTML and I highly believe HTML should be

00:10:23,420 --> 00:10:30,949
just the correction of your application

00:10:25,100 --> 00:10:34,879
state not source of the truth but who am

00:10:30,949 --> 00:10:38,300
I to judge them so direct can be used in

00:10:34,879 --> 00:10:39,829
a different way I the most best way I

00:10:38,300 --> 00:10:43,910
think they're actually used is a pure

00:10:39,829 --> 00:10:47,179
react react with in table Jas basically

00:10:43,910 --> 00:10:49,970
is the just regular react component with

00:10:47,179 --> 00:10:53,480
chute component update method which is

00:10:49,970 --> 00:10:55,730
used for all these immutable J's checks

00:10:53,480 --> 00:10:59,950
I will show you example examples later

00:10:55,730 --> 00:11:03,900
and if you know direct

00:10:59,950 --> 00:11:06,850
new suggested stateless component syntax

00:11:03,900 --> 00:11:12,070
it's beautiful it's even more minimal

00:11:06,850 --> 00:11:15,010
but don't use it yet at least in Ashta

00:11:12,070 --> 00:11:17,920
because in Ashta ever components are

00:11:15,010 --> 00:11:20,110
pure every component is pure and the

00:11:17,920 --> 00:11:22,570
stateless components still doesn't have

00:11:20,110 --> 00:11:24,430
a way how to do the chute component

00:11:22,570 --> 00:11:28,660
updates check and I was speaking with

00:11:24,430 --> 00:11:31,690
the Sebastian who is the probably the

00:11:28,660 --> 00:11:34,060
leader of the react future and he told

00:11:31,690 --> 00:11:36,190
me they are consider reconsidering the

00:11:34,060 --> 00:11:39,700
chute component updates check maybe they

00:11:36,190 --> 00:11:43,180
choose different approach and as I

00:11:39,700 --> 00:11:47,370
already said as is going is a something

00:11:43,180 --> 00:11:51,820
I'm using in production so it's a

00:11:47,370 --> 00:11:54,130
despite the fact is the is the is using

00:11:51,820 --> 00:11:57,400
the functional programming patterns etc

00:11:54,130 --> 00:12:00,070
it's something which should suppose to

00:11:57,400 --> 00:12:04,120
be mainstream and stable for production

00:12:00,070 --> 00:12:07,870
so stateless components are nice but not

00:12:04,120 --> 00:12:13,510
ready for each day yet and now these

00:12:07,870 --> 00:12:16,420
examples so if you haven't ever seen

00:12:13,510 --> 00:12:19,540
anything from functional programming the

00:12:16,420 --> 00:12:21,790
simple and the most obvious pattern of

00:12:19,540 --> 00:12:24,700
functional programming is just function

00:12:21,790 --> 00:12:29,140
and pure functions which without side

00:12:24,700 --> 00:12:34,270
effect a little example here I think

00:12:29,140 --> 00:12:36,760
it's obvious function pure function the

00:12:34,270 --> 00:12:39,490
most beautiful thing is the it's really

00:12:36,760 --> 00:12:47,680
easy to reason about function it has

00:12:39,490 --> 00:12:51,460
input output and that's easy and but we

00:12:47,680 --> 00:12:55,120
are using also dirty glasses and I love

00:12:51,460 --> 00:12:57,700
this example from the great functional

00:12:55,120 --> 00:12:59,470
book I highly recommend to check it most

00:12:57,700 --> 00:13:02,710
adequate guide to functional programming

00:12:59,470 --> 00:13:05,680
I love the that style how is written

00:13:02,710 --> 00:13:10,810
this is code from the guy this is a

00:13:05,680 --> 00:13:11,680
super simple class but but somehow it

00:13:10,810 --> 00:13:15,130
doesn't

00:13:11,680 --> 00:13:18,580
work is the great demonstration how hard

00:13:15,130 --> 00:13:22,680
is to thinking about state and its

00:13:18,580 --> 00:13:25,960
notation and you see a lot of code and

00:13:22,680 --> 00:13:30,250
all that code can be written in just

00:13:25,960 --> 00:13:36,940
this simple mathematic expression so I

00:13:30,250 --> 00:13:41,830
think this versus this this is class

00:13:36,940 --> 00:13:44,140
base so P as we taught to do death with

00:13:41,830 --> 00:13:47,020
a lot of abstraction and do we really

00:13:44,140 --> 00:13:49,959
need such an abstraction I don't think

00:13:47,020 --> 00:13:53,399
so I think it is much much more sense

00:13:49,959 --> 00:13:55,480
and it also illustrates how the

00:13:53,399 --> 00:14:00,220
programmed functional programming works

00:13:55,480 --> 00:14:05,050
is its manipulation with data and it's

00:14:00,220 --> 00:14:07,420
so helpful because it's so often for

00:14:05,050 --> 00:14:12,430
programmer to be paralysed by analyzing

00:14:07,420 --> 00:14:14,320
and if we have function is hard to be

00:14:12,430 --> 00:14:16,150
paralyzed because the function is

00:14:14,320 --> 00:14:20,890
basically task you must be done

00:14:16,150 --> 00:14:24,339
it has input/output and that's all next

00:14:20,890 --> 00:14:26,380
slide is about something also pretty

00:14:24,339 --> 00:14:32,580
familiar for you yes you have a lot of

00:14:26,380 --> 00:14:36,850
array helpful methods and the thing is

00:14:32,580 --> 00:14:38,650
we don't need it because with functional

00:14:36,850 --> 00:14:41,640
programming we would like to deal with

00:14:38,650 --> 00:14:45,910
the persistent data structures which is

00:14:41,640 --> 00:14:48,610
collection which are immutable and as

00:14:45,910 --> 00:14:52,660
the name suggests in multiple j/s it's

00:14:48,610 --> 00:14:55,329
the library from liberal from again next

00:14:52,660 --> 00:14:57,940
good thing from Facebook I think

00:14:55,329 --> 00:15:00,579
personally the Facebook saved us somehow

00:14:57,940 --> 00:15:03,910
because I can hardly imagine what we

00:15:00,579 --> 00:15:07,150
would we do without the Facebook and its

00:15:03,910 --> 00:15:09,010
influence to web development we would

00:15:07,150 --> 00:15:15,540
probably hate to angular or something

00:15:09,010 --> 00:15:18,540
like that so a lot of you probably know

00:15:15,540 --> 00:15:22,950
underscore and lodash collection methods

00:15:18,540 --> 00:15:25,920
and we don't we don't need them anymore

00:15:22,950 --> 00:15:28,350
almost all these useful produce for

00:15:25,920 --> 00:15:33,540
metals are part of the rich API of

00:15:28,350 --> 00:15:35,310
immutable j/s I don't want to spend a

00:15:33,540 --> 00:15:38,010
time to explain how we multiple J's

00:15:35,310 --> 00:15:40,740
works internally it's your homework and

00:15:38,010 --> 00:15:45,840
I believe next speakers will describe it

00:15:40,740 --> 00:15:48,930
in more details just quick introduction

00:15:45,840 --> 00:15:54,720
it's pretty simple instead of object we

00:15:48,930 --> 00:16:00,300
have map and every every manipulation

00:15:54,720 --> 00:16:05,070
with the map create a new object and the

00:16:00,300 --> 00:16:09,570
same is for array so instead of array we

00:16:05,070 --> 00:16:12,870
are we have lists and I think this this

00:16:09,570 --> 00:16:15,990
line is pretty important to know we with

00:16:12,870 --> 00:16:19,340
red object is in table we can easily

00:16:15,990 --> 00:16:22,680
compare them and that's the key for

00:16:19,340 --> 00:16:28,350
super fast direct rendering without the

00:16:22,680 --> 00:16:31,190
hex immutable data structures it could

00:16:28,350 --> 00:16:35,420
be hard to start with immutable J s

00:16:31,190 --> 00:16:39,450
without examples and I have to say the

00:16:35,420 --> 00:16:44,250
examples in examples in immutable J's

00:16:39,450 --> 00:16:51,590
the computer rep recommends Docs is not

00:16:44,250 --> 00:16:51,590
as detailed as we where to be so you can

00:16:58,750 --> 00:17:01,980
just a second

00:17:07,180 --> 00:17:16,570
yes here if you know how to how to use

00:17:13,930 --> 00:17:20,400
the immutable Jas in your application

00:17:16,570 --> 00:17:31,840
just check - there and for example

00:17:20,400 --> 00:17:33,790
reducers in the to do so how do how to

00:17:31,840 --> 00:17:36,430
update it in estate nested structures

00:17:33,790 --> 00:17:39,910
how to add things how to find things

00:17:36,430 --> 00:17:43,900
remove things all these create read

00:17:39,910 --> 00:17:49,500
update delete operations I would

00:17:43,900 --> 00:17:52,420
highlight one thing and is the record

00:17:49,500 --> 00:17:52,990
record is basically replacement for

00:17:52,420 --> 00:17:57,700
class

00:17:52,990 --> 00:17:59,980
I said classes are bad for most tasks we

00:17:57,700 --> 00:18:02,140
need we have but it doesn't mean we

00:17:59,980 --> 00:18:05,620
should just deal with some plain

00:18:02,140 --> 00:18:08,550
structures we have to we want to have

00:18:05,620 --> 00:18:11,650
some some structures name it with some

00:18:08,550 --> 00:18:16,750
properties in cetera and they are called

00:18:11,650 --> 00:18:20,650
records the real I think it's important

00:18:16,750 --> 00:18:25,660
for server-side rendering when we need

00:18:20,650 --> 00:18:30,370
to realize state basically these three

00:18:25,660 --> 00:18:33,090
lines convert plane and Jason to record

00:18:30,370 --> 00:18:33,090
structure

00:18:35,860 --> 00:18:43,240
as I said because immutable structures

00:18:39,429 --> 00:18:45,520
can be changed we can compare them just

00:18:43,240 --> 00:18:50,620
with a simple identity check in the

00:18:45,520 --> 00:18:53,620
JavaScript so sono deep differing costly

00:18:50,620 --> 00:18:58,570
algorithms but just simply check and

00:18:53,620 --> 00:19:02,890
this is how pure components work just

00:18:58,570 --> 00:19:07,780
this one method is optimizing well your

00:19:02,890 --> 00:19:10,240
application without any details the

00:19:07,780 --> 00:19:15,429
records have the another super beautiful

00:19:10,240 --> 00:19:17,140
feature and what because to read the

00:19:15,429 --> 00:19:20,559
value from the immutable structure you

00:19:17,140 --> 00:19:23,200
have to use the get method but if your

00:19:20,559 --> 00:19:27,700
immutable structure is record you can

00:19:23,200 --> 00:19:29,910
use simple dot notation which is pretty

00:19:27,700 --> 00:19:29,910
useful

00:19:35,470 --> 00:19:41,610
so back to my presentation so you have

00:19:39,460 --> 00:19:44,620
seen some tubular structures now you

00:19:41,610 --> 00:19:47,289
know why these material structures are

00:19:44,620 --> 00:19:50,080
useful for rendering it makes rendering

00:19:47,289 --> 00:19:54,970
super fast and now you'll see some

00:19:50,080 --> 00:19:56,950
diagram and this is some diagram of for

00:19:54,970 --> 00:20:00,370
implementing something like that dozens

00:19:56,950 --> 00:20:03,460
of times what's wrong with that it's

00:20:00,370 --> 00:20:06,519
wrong what's wrong is that we simply

00:20:03,460 --> 00:20:10,389
doesn't know what happened where why

00:20:06,519 --> 00:20:14,320
without the debugging because there's

00:20:10,389 --> 00:20:19,629
how oob works but we can do it better

00:20:14,320 --> 00:20:22,870
with the redux and actions so instead of

00:20:19,629 --> 00:20:27,240
some magic method call which change some

00:20:22,870 --> 00:20:31,600
data in some strange way we encapsulate

00:20:27,240 --> 00:20:34,360
every change in action is basically

00:20:31,600 --> 00:20:37,809
design pattern command and we have

00:20:34,360 --> 00:20:41,230
previous state and yes we have next

00:20:37,809 --> 00:20:43,629
state and beautiful thing I like

00:20:41,230 --> 00:20:48,059
especially I like these two pictures

00:20:43,629 --> 00:20:51,820
because this is the probably the most

00:20:48,059 --> 00:20:56,259
narrative explanation how up state works

00:20:51,820 --> 00:21:00,370
your application is just movie the movie

00:20:56,259 --> 00:21:03,549
consists of screens and every screen is

00:21:00,370 --> 00:21:06,250
described by one application state so

00:21:03,549 --> 00:21:09,070
here we are here we have a previous

00:21:06,250 --> 00:21:12,070
application state action with some

00:21:09,070 --> 00:21:15,100
payload which changed state and the next

00:21:12,070 --> 00:21:18,610
new one state so finally your

00:21:15,100 --> 00:21:24,549
application makes sense the changes in

00:21:18,610 --> 00:21:28,629
your application so you just have seen

00:21:24,549 --> 00:21:31,120
flux design pattern from Facebook and I

00:21:28,629 --> 00:21:32,950
am using direct implementation I was

00:21:31,120 --> 00:21:34,929
using my own implementation but I'm

00:21:32,950 --> 00:21:37,330
always happy when I don't have to write

00:21:34,929 --> 00:21:39,820
the code and maintain my open code and I

00:21:37,330 --> 00:21:43,330
can use something better and then

00:21:39,820 --> 00:21:46,779
removed it wonderful work there were a

00:21:43,330 --> 00:21:48,070
huge amount of flux implementation and

00:21:46,779 --> 00:21:51,850
basically all

00:21:48,070 --> 00:21:57,190
weighs the same just the AP I was a

00:21:51,850 --> 00:21:59,080
little bit different and the important

00:21:57,190 --> 00:22:02,320
thing from this slide is the winner

00:21:59,080 --> 00:22:05,320
takes it all and if some technology is

00:22:02,320 --> 00:22:07,960
winning it's super hard to compete with

00:22:05,320 --> 00:22:12,490
such technology or library I currently

00:22:07,960 --> 00:22:15,490
believe the rare erect one you have to

00:22:12,490 --> 00:22:19,440
do you would have to make 10 times

00:22:15,490 --> 00:22:22,330
better library to compete with react and

00:22:19,440 --> 00:22:26,260
it's same for a radix and flex

00:22:22,330 --> 00:22:29,200
implementation relax just one big it's a

00:22:26,260 --> 00:22:32,440
pretty it has great documentation great

00:22:29,200 --> 00:22:35,020
implementation so it doesn't make sense

00:22:32,440 --> 00:22:37,810
to use any other attacks implementation

00:22:35,020 --> 00:22:40,120
and if you want to know how it's used in

00:22:37,810 --> 00:22:43,840
HD just check I would like highlight the

00:22:40,120 --> 00:22:46,090
all components are pure and I recommend

00:22:43,840 --> 00:22:50,080
you to strict top button data passing

00:22:46,090 --> 00:22:53,050
through the props some people ask me

00:22:50,080 --> 00:22:54,880
isn't it because if we are using the

00:22:53,050 --> 00:22:59,320
props you have to pass the props through

00:22:54,880 --> 00:23:02,170
all parents isn't it verbals maybe but

00:22:59,320 --> 00:23:05,050
some time is good to be verbose you know

00:23:02,170 --> 00:23:05,680
Harry Potter it's the seven big huge

00:23:05,050 --> 00:23:09,250
books

00:23:05,680 --> 00:23:09,700
it is very books yes but is also good

00:23:09,250 --> 00:23:13,660
read

00:23:09,700 --> 00:23:18,310
so no it's not always that verbose is

00:23:13,660 --> 00:23:20,710
bad so the last line side-effects

00:23:18,310 --> 00:23:23,770
dissolution in actions Redux is

00:23:20,710 --> 00:23:26,890
synchronize synchronized but our

00:23:23,770 --> 00:23:30,310
application are synchronized and the

00:23:26,890 --> 00:23:33,090
state mutations and the side effects and

00:23:30,310 --> 00:23:38,080
all the dirty stuffs belong to the

00:23:33,090 --> 00:23:41,650
actions because they are isolated in one

00:23:38,080 --> 00:23:45,670
place and isolation means your heart you

00:23:41,650 --> 00:23:47,860
have control next beautiful design

00:23:45,670 --> 00:23:51,580
pattern functional patterns higher-order

00:23:47,860 --> 00:23:53,620
functions and in react we are using

00:23:51,580 --> 00:23:57,250
higher-order components is basically

00:23:53,620 --> 00:23:59,380
component taking another component as a

00:23:57,250 --> 00:24:01,270
pattern and this is yet another example

00:23:59,380 --> 00:24:03,670
from each day I am

00:24:01,270 --> 00:24:06,700
using the decorators and hire other

00:24:03,670 --> 00:24:12,760
components to hook life cycle to

00:24:06,700 --> 00:24:16,000
components so it's something like relay

00:24:12,760 --> 00:24:18,310
but for for example for firebase if you

00:24:16,000 --> 00:24:23,230
want to use the firebase you can't use

00:24:18,310 --> 00:24:27,400
ray you maybe you don't need it because

00:24:23,230 --> 00:24:31,320
firebase has a pretty nice API so that's

00:24:27,400 --> 00:24:34,780
I'm using the higher-order functions and

00:24:31,320 --> 00:24:37,540
components indirect the last thing I

00:24:34,780 --> 00:24:42,730
would like to highlight is di containers

00:24:37,540 --> 00:24:45,310
I was using di containers a lot and if

00:24:42,730 --> 00:24:49,660
your application consists of a lot of

00:24:45,310 --> 00:24:52,210
small classes di container is must but

00:24:49,660 --> 00:24:56,910
if your application is functional you

00:24:52,210 --> 00:25:00,100
don't need the I container so badly and

00:24:56,910 --> 00:25:03,370
because I don't have a time again I

00:25:00,100 --> 00:25:06,760
recommend you to read these four links

00:25:03,370 --> 00:25:11,380
this is how we angel dependencies is how

00:25:06,760 --> 00:25:14,830
we do pure di which which means manual

00:25:11,380 --> 00:25:18,610
manual injections in Ashta it's

00:25:14,830 --> 00:25:20,350
something like angular services but

00:25:18,610 --> 00:25:22,960
without the magic and we have this

00:25:20,350 --> 00:25:27,820
string and without the all that stuff

00:25:22,960 --> 00:25:34,420
just plain straightforward injection of

00:25:27,820 --> 00:25:38,400
the state for instance instances this is

00:25:34,420 --> 00:25:41,110
not something I am using in a style but

00:25:38,400 --> 00:25:43,720
but this is a rubberized functional

00:25:41,110 --> 00:25:47,380
composition in Java C on steroids it's a

00:25:43,720 --> 00:25:49,780
very very beautiful library I don't

00:25:47,380 --> 00:25:53,050
recommend to use it right now because it

00:25:49,780 --> 00:25:57,600
doesn't work with in table Jas still

00:25:53,050 --> 00:26:01,480
it's something you should know because

00:25:57,600 --> 00:26:05,110
because this picture really why Ram de

00:26:01,480 --> 00:26:07,960
you will understand conclusion a mark

00:26:05,110 --> 00:26:10,720
seaman is blood the first line he is a

00:26:07,960 --> 00:26:12,610
great writer and he wrote an article

00:26:10,720 --> 00:26:16,000
about why function

00:26:12,610 --> 00:26:19,419
is the next step when you are trying to

00:26:16,000 --> 00:26:24,309
do to do object-oriented programming as

00:26:19,419 --> 00:26:29,110
best as possible then you have to write

00:26:24,309 --> 00:26:31,029
functional programming time is up this

00:26:29,110 --> 00:26:34,029
is a beautiful slide but it's for your

00:26:31,029 --> 00:26:36,970
homework me as a libertarian I see the

00:26:34,029 --> 00:26:41,110
state in the programming and the state

00:26:36,970 --> 00:26:45,250
in the in the society as the same evil

00:26:41,110 --> 00:26:47,710
and it's really beautiful how many how

00:26:45,250 --> 00:26:49,809
much similarities are between the state

00:26:47,710 --> 00:26:54,279
and the programming in the state and the

00:26:49,809 --> 00:26:56,700
government so thank you very much for

00:26:54,279 --> 00:26:56,700
your attention

00:27:00,460 --> 00:27:07,029
whoa we have time for one question so

00:27:03,549 --> 00:27:10,299
you can choose one yes yes yes one

00:27:07,029 --> 00:27:16,080
question and a short answer to the first

00:27:10,299 --> 00:27:16,080
one probably let me read read them

00:27:22,749 --> 00:27:26,919
I like the dust function programming

00:27:25,090 --> 00:27:31,110
scalar from development cost point of

00:27:26,919 --> 00:27:34,269
view definitely and what about come

00:27:31,110 --> 00:27:38,289
definitely yes yes or no question yes or

00:27:34,269 --> 00:27:41,279
no answer and jQuery it was great and

00:27:38,289 --> 00:27:43,710
now is that so what I should tell more

00:27:41,279 --> 00:27:47,470
positive note will answer this question

00:27:43,710 --> 00:27:50,200
I would like to say something about the

00:27:47,470 --> 00:27:54,610
combining two paradigms or OPL

00:27:50,200 --> 00:27:58,269
functional and because as I already said

00:27:54,610 --> 00:28:01,990
it's not like that Hopi is always the

00:27:58,269 --> 00:28:04,769
vet Hopi use Hopi when you have to deal

00:28:01,990 --> 00:28:06,070
with a stageful - sometimes it's

00:28:04,769 --> 00:28:09,820
inevitable

00:28:06,070 --> 00:28:12,789
and you can see in an ashtray I have two

00:28:09,820 --> 00:28:16,029
places and all applications started

00:28:12,789 --> 00:28:20,619
racket where I'm using Opie and it's not

00:28:16,029 --> 00:28:21,159
misusing Hopi I believe we can discuss

00:28:20,619 --> 00:28:23,619
it later

00:28:21,159 --> 00:28:25,480
exactly so I think you're gonna think

00:28:23,619 --> 00:28:27,580
again they're gonna be in the VIP room

00:28:25,480 --> 00:28:30,119
you can talk to him again thank you

00:28:27,580 --> 00:28:30,119

YouTube URL: https://www.youtube.com/watch?v=xeAdUEIb_ys


