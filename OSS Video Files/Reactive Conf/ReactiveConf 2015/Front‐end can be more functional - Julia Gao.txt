Title: Frontâ€end can be more functional - Julia Gao
Publication date: 2015-11-16
Playlist: ReactiveConf 2015
Description: 
	Functional programming gives developers better ideas on how the application will react, more expected outputs, and less time needed for debugging. Immutability is one of the key points for functional programming, I'll show you some of the things we can improve on the front-end to make the code more immutable and functional.

Julia Gao
Front-end developer from Utah, using ReactJS and ImmutableJS . Loves functional programming, currently learning Racket and Haskell .
Captions: 
	00:00:08,769 --> 00:00:16,129
hi I'm really excited to be here and

00:00:13,940 --> 00:00:18,380
talk to you more on functional

00:00:16,129 --> 00:00:27,880
programming and how to make for a more

00:00:18,380 --> 00:00:31,419
functional Who am I I'm a software

00:00:27,880 --> 00:00:34,100
developer and I like astronomy

00:00:31,419 --> 00:00:42,590
functional programming react ge'ez and

00:00:34,100 --> 00:00:44,930
some games yeah so today I'm going to

00:00:42,590 --> 00:00:47,330
talk about some concepts about

00:00:44,930 --> 00:00:52,250
functional programming and then

00:00:47,330 --> 00:00:56,360
hopefully it will make more sense so

00:00:52,250 --> 00:00:58,900
we've all seen this picture and it's

00:00:56,360 --> 00:01:01,670
obviously a joke but also kind of true

00:00:58,900 --> 00:01:04,430
so functional programming emphasizes on

00:01:01,670 --> 00:01:07,399
what simple functions can do and there

00:01:04,430 --> 00:01:10,249
are obviously tons of concepts but I am

00:01:07,399 --> 00:01:17,679
going to talk about two simpler ones

00:01:10,249 --> 00:01:24,170
today so stainless functions and

00:01:17,679 --> 00:01:26,479
immutable data as data structures so

00:01:24,170 --> 00:01:28,219
let's learn more about them so you

00:01:26,479 --> 00:01:33,619
wouldn't understand how they may help

00:01:28,219 --> 00:01:36,469
you stay less functions or pure

00:01:33,619 --> 00:01:43,100
functions or this word that I can't

00:01:36,469 --> 00:01:45,350
pronounce which just means um no matter

00:01:43,100 --> 00:01:47,749
how many times the phone the same

00:01:45,350 --> 00:01:50,719
function is getting called if you pass

00:01:47,749 --> 00:01:54,259
in the same arguments then the output

00:01:50,719 --> 00:02:00,319
should be the same which makes a

00:01:54,259 --> 00:02:04,099
function really predictable so let's

00:02:00,319 --> 00:02:08,530
think about the absolute function in

00:02:04,099 --> 00:02:12,830
math which should calculate a numbers

00:02:08,530 --> 00:02:15,569
distance to 0 so this code makes sense

00:02:12,830 --> 00:02:18,840
right you give it

00:02:15,569 --> 00:02:26,790
um the same number three times and you

00:02:18,840 --> 00:02:29,370
get the same output back now so there

00:02:26,790 --> 00:02:33,450
are no side effects and they produce

00:02:29,370 --> 00:02:35,969
fewer bugs so we all know that one thing

00:02:33,450 --> 00:02:40,349
that I used to work and somebody changed

00:02:35,969 --> 00:02:43,709
something which affected your cold so

00:02:40,349 --> 00:02:49,049
makes your code no longer works which

00:02:43,709 --> 00:02:51,389
sucks right so just think about how

00:02:49,049 --> 00:02:55,400
frustrating you will be if you give it a

00:02:51,389 --> 00:02:55,400
negative one and then it produces five

00:02:56,989 --> 00:03:04,889
so let's look at this do stop function

00:03:00,870 --> 00:03:07,680
you give it to a and B but then you

00:03:04,889 --> 00:03:10,579
return a plus B plus this other stuff

00:03:07,680 --> 00:03:13,819
that you don't know where it's from and

00:03:10,579 --> 00:03:18,180
then you call this to other stuff which

00:03:13,819 --> 00:03:20,009
changes this global variable and then

00:03:18,180 --> 00:03:23,400
when you first call the deuce cell

00:03:20,009 --> 00:03:25,470
function and then you call the deuce

00:03:23,400 --> 00:03:28,949
other cell function but then if you

00:03:25,470 --> 00:03:32,669
recall the do sub function given the

00:03:28,949 --> 00:03:37,500
same parameters then the outputs are

00:03:32,669 --> 00:03:41,629
different but if you write it this way

00:03:37,500 --> 00:03:47,090
which you give it three parameters and

00:03:41,629 --> 00:03:51,359
you don't rely on the outside as stuff

00:03:47,090 --> 00:03:56,729
which makes a function produce the same

00:03:51,359 --> 00:03:59,689
outputs every single time the second

00:03:56,729 --> 00:04:02,400
concept is immutable data structures

00:03:59,689 --> 00:04:07,290
because one does not simply mutate a

00:04:02,400 --> 00:04:11,969
data structure let's think about these

00:04:07,290 --> 00:04:16,979
two plus was five and high plus by now

00:04:11,969 --> 00:04:21,329
when we first look at them + 55 simply

00:04:16,979 --> 00:04:25,590
return to six we wouldn't expect this

00:04:21,329 --> 00:04:29,320
changes all of the fives in your code 26

00:04:25,590 --> 00:04:32,350
right now same thing was high plus x

00:04:29,320 --> 00:04:38,410
we wouldn't want to all of the highs to

00:04:32,350 --> 00:04:41,560
change the high by only only this one so

00:04:38,410 --> 00:04:44,500
if that makes sense why is it different

00:04:41,560 --> 00:04:50,320
when we declare variables in our

00:04:44,500 --> 00:04:55,150
function so think about this one we give

00:04:50,320 --> 00:04:58,960
it a and then we return something based

00:04:55,150 --> 00:05:01,690
on these other function that also takes

00:04:58,960 --> 00:05:06,220
a and then we return this object that

00:05:01,690 --> 00:05:07,990
contains a and B this can create a

00:05:06,220 --> 00:05:11,380
problem because we have no idea what

00:05:07,990 --> 00:05:17,440
this other function is doing so it can

00:05:11,380 --> 00:05:20,500
be changed so we have this function

00:05:17,440 --> 00:05:26,770
which takes a person and then we mutate

00:05:20,500 --> 00:05:30,420
the person's age x + 1 and if that

00:05:26,770 --> 00:05:35,890
function is currently the funk then a is

00:05:30,420 --> 00:05:39,460
getting changed now eric has this great

00:05:35,890 --> 00:05:42,820
code it says that thou of immutability

00:05:39,460 --> 00:05:45,130
the true constant is change mutation

00:05:42,820 --> 00:05:53,170
heights change hidden change creates

00:05:45,130 --> 00:05:57,490
chaos so now you're like whatever but if

00:05:53,170 --> 00:06:01,060
you think about this previous code even

00:05:57,490 --> 00:06:05,440
if we compare the same um the person

00:06:01,060 --> 00:06:09,280
object to the previous person object

00:06:05,440 --> 00:06:11,740
without a change it can't tell what is

00:06:09,280 --> 00:06:15,510
being changed and the change is actually

00:06:11,740 --> 00:06:18,910
very very quiet and now you don't have

00:06:15,510 --> 00:06:23,260
any proof that the person's age is

00:06:18,910 --> 00:06:26,650
getting +1 but of course you can also do

00:06:23,260 --> 00:06:32,410
console.log before and after but nobody

00:06:26,650 --> 00:06:36,130
wants that so if we write it like this

00:06:32,410 --> 00:06:40,540
which returns a new object and we copy

00:06:36,130 --> 00:06:42,500
every single properties inside of the

00:06:40,540 --> 00:06:48,380
person object

00:06:42,500 --> 00:06:51,020
this can prevent mutation but in this

00:06:48,380 --> 00:06:54,110
case this is fine because person only

00:06:51,020 --> 00:06:58,070
has two properties but imagine you have

00:06:54,110 --> 00:07:03,890
to copy and paste 500 properties that

00:06:58,070 --> 00:07:08,840
gets very tedious right so instead we

00:07:03,890 --> 00:07:10,730
can use this object a sign which copies

00:07:08,840 --> 00:07:15,080
every single thing in the person object

00:07:10,730 --> 00:07:19,820
and only changes the age but this also

00:07:15,080 --> 00:07:22,210
returns a new object so the so the

00:07:19,820 --> 00:07:29,990
person parameter is not getting changed

00:07:22,210 --> 00:07:33,970
or you can use es6 resin spread so then

00:07:29,990 --> 00:07:38,720
we can deconstruct the H property and

00:07:33,970 --> 00:07:43,210
copy whatever is a copy the rest of the

00:07:38,720 --> 00:07:46,100
person object so now let's talk about

00:07:43,210 --> 00:07:51,650
functional programming on in your front

00:07:46,100 --> 00:07:55,430
end disclaimer i know this is still

00:07:51,650 --> 00:08:00,500
javascript so things like these will

00:07:55,430 --> 00:08:05,360
happen but that's not so bad or things

00:08:00,500 --> 00:08:07,790
like these can happen but I feel like if

00:08:05,360 --> 00:08:14,120
you think you can make things better we

00:08:07,790 --> 00:08:18,830
should do it so first things first let's

00:08:14,120 --> 00:08:24,610
all not use VARs anymore let's change it

00:08:18,830 --> 00:08:24,610
to let because is awesome

00:08:27,020 --> 00:08:40,020
or even better use costs so let it's

00:08:35,280 --> 00:08:45,560
very similar to bar but let is a lek

00:08:40,020 --> 00:08:51,900
variables are block scoped which means

00:08:45,560 --> 00:08:55,010
so we have a B equals to one and then we

00:08:51,900 --> 00:08:58,650
do something else and then then we

00:08:55,010 --> 00:09:01,410
redesigned BTW too but since b is also

00:08:58,650 --> 00:09:05,670
within the if block the else I'd be is

00:09:01,410 --> 00:09:11,940
not being changed unlike the bar is

00:09:05,670 --> 00:09:16,080
getting changed but const cos variables

00:09:11,940 --> 00:09:20,160
cannot be changed which means you also

00:09:16,080 --> 00:09:27,350
have to initialize them when you declare

00:09:20,160 --> 00:09:30,000
the variable so in the first 1a is being

00:09:27,350 --> 00:09:34,470
declared 21 and then you try to change

00:09:30,000 --> 00:09:37,290
82 now that caused some warnings or

00:09:34,470 --> 00:09:42,750
errors now the second one you didn't

00:09:37,290 --> 00:09:47,970
give any values to a so up to this point

00:09:42,750 --> 00:09:50,580
we simply use JavaScript syntax but if

00:09:47,970 --> 00:09:54,090
you want to take functional programming

00:09:50,580 --> 00:09:56,700
to another level on the firm man you can

00:09:54,090 --> 00:10:02,420
also use immutable J's with react Gia's

00:09:56,700 --> 00:10:05,360
or a closure script or pure script even

00:10:02,420 --> 00:10:10,370
so how many people here are actually

00:10:05,360 --> 00:10:13,950
currently using any of them cool awesome

00:10:10,370 --> 00:10:16,500
so I'm going to talk about the other

00:10:13,950 --> 00:10:22,140
bajias first so this already looks

00:10:16,500 --> 00:10:24,630
pretty promising so it has a data

00:10:22,140 --> 00:10:27,530
structures like maps or sets or lists

00:10:24,630 --> 00:10:33,480
and they follow a pretty similar rule as

00:10:27,530 --> 00:10:36,620
in the es6 api's but the ones in this

00:10:33,480 --> 00:10:36,620
library can never be changed

00:10:37,320 --> 00:10:42,690
which also means you make a new map sets

00:10:40,920 --> 00:10:50,460
or less every time you try to make a

00:10:42,690 --> 00:10:53,910
change so um so before this talk I'm I

00:10:50,460 --> 00:10:59,340
have a lot of ideas of how to make the

00:10:53,910 --> 00:11:01,620
slideshows and I changed a lot of times

00:10:59,340 --> 00:11:03,540
but then I was like okay I'm going to

00:11:01,620 --> 00:11:07,050
talk about functional programming so why

00:11:03,540 --> 00:11:10,140
not use the functional way of thinking

00:11:07,050 --> 00:11:14,910
about it so I make a new copy every time

00:11:10,140 --> 00:11:17,880
I change the flow of my slideshow which

00:11:14,910 --> 00:11:21,680
is really heavy right and slow and this

00:11:17,880 --> 00:11:21,680
is so inefficient and stupid but

00:11:23,330 --> 00:11:31,440
fortunately fortunately Emil bajias uses

00:11:30,060 --> 00:11:37,380
this thing called persistent data

00:11:31,440 --> 00:11:40,610
structures which means they only copy or

00:11:37,380 --> 00:11:44,580
they only change the things and

00:11:40,610 --> 00:11:47,130
corresponding pass to the data to

00:11:44,580 --> 00:11:50,670
another copy and then they actually and

00:11:47,130 --> 00:11:53,190
then so for example you changed four to

00:11:50,670 --> 00:11:57,270
eight so now you have to make a new path

00:11:53,190 --> 00:11:59,610
H and F and C but the rest of the paths

00:11:57,270 --> 00:12:05,240
are actually making the same reference

00:11:59,610 --> 00:12:05,240
and this is normally pretty bad because

00:12:05,600 --> 00:12:13,980
sharing data so share data can be

00:12:09,900 --> 00:12:16,140
changed but since in ela bjs cannot be

00:12:13,980 --> 00:12:19,020
changed then that then this works

00:12:16,140 --> 00:12:24,750
perfectly so I was like okay this is

00:12:19,020 --> 00:12:30,300
cool that's awesome so can y'all see

00:12:24,750 --> 00:12:33,480
this okay so on the so on the Left we

00:12:30,300 --> 00:12:35,750
have a regular map which you can set it

00:12:33,480 --> 00:12:39,600
to one and high and then later you can

00:12:35,750 --> 00:12:43,230
set another 12 and by so now the regular

00:12:39,600 --> 00:12:47,370
map has size up to but if we make a map

00:12:43,230 --> 00:12:48,810
in immutable J's library we set it to

00:12:47,370 --> 00:12:50,870
one and high and then we have to

00:12:48,810 --> 00:12:54,270
reassign

00:12:50,870 --> 00:12:58,920
whenever we make a change so the first

00:12:54,270 --> 00:13:03,290
map is staying the size of 21 sorry and

00:12:58,920 --> 00:13:03,290
the new one will have the size of to

00:13:06,380 --> 00:13:16,140
another example say we have this whole

00:13:11,390 --> 00:13:22,320
big object and then we reset the Z which

00:13:16,140 --> 00:13:26,880
is the route 24 and if we call the the

00:13:22,320 --> 00:13:31,080
map it still has the original data where

00:13:26,880 --> 00:13:38,460
if we assign to NASA to now nessa t only

00:13:31,080 --> 00:13:39,690
has Z and for switching gears so we're

00:13:38,460 --> 00:13:44,760
going to talk about something that you

00:13:39,690 --> 00:13:48,540
may or may not be familiar with closure

00:13:44,760 --> 00:13:52,020
script so closure is a dialect of Lisp

00:13:48,540 --> 00:13:55,610
and closure script is a dialect of

00:13:52,020 --> 00:13:58,220
closure that compiles to JavaScript and

00:13:55,610 --> 00:14:03,840
clojurescript also has immutable data

00:13:58,220 --> 00:14:06,890
structures so only and also has lists

00:14:03,840 --> 00:14:10,110
syntax as well so this is the same

00:14:06,890 --> 00:14:13,340
example as a previous one so we get the

00:14:10,110 --> 00:14:18,000
person and we only change the age

00:14:13,340 --> 00:14:22,980
property and return that and whatever

00:14:18,000 --> 00:14:26,010
else is inside of the person and close

00:14:22,980 --> 00:14:31,200
your script is actually very modular so

00:14:26,010 --> 00:14:34,980
you can create a sub module inside of

00:14:31,200 --> 00:14:39,840
the hello world so then you can reuse it

00:14:34,980 --> 00:14:44,340
later and it also has a mutable list so

00:14:39,840 --> 00:14:48,710
if we have V 1 2 3 and then another we

00:14:44,340 --> 00:14:48,710
add 4 to it V is still 1 2 3

00:14:51,820 --> 00:14:58,420
now region region now you can write

00:14:55,600 --> 00:15:02,530
react components inside of closure

00:14:58,420 --> 00:15:05,860
script and similar to quote a similar to

00:15:02,530 --> 00:15:09,670
regular functions as components in react

00:15:05,860 --> 00:15:12,430
point fourteen i believe so now you can

00:15:09,670 --> 00:15:19,050
recognize a lot of the syntax like the P

00:15:12,430 --> 00:15:19,050
tag and the div and even the style sheet

00:15:21,060 --> 00:15:27,520
so if all of the building data

00:15:24,730 --> 00:15:31,060
structures are immutable enclosure then

00:15:27,520 --> 00:15:34,800
how do you change variables so closure

00:15:31,060 --> 00:15:38,500
has this concept of atoms which is just

00:15:34,800 --> 00:15:44,580
another data structure and and adams

00:15:38,500 --> 00:15:48,310
hold and adams hold immutable data so

00:15:44,580 --> 00:15:52,300
whenever you change it changes by

00:15:48,310 --> 00:15:57,430
applying the swap function so like that

00:15:52,300 --> 00:16:00,160
so so you make so you make an atom in in

00:15:57,430 --> 00:16:03,340
my atom and then you assign it to zero

00:16:00,160 --> 00:16:06,220
and then when you try to change my atom

00:16:03,340 --> 00:16:08,470
it's it's actually pointing to the same

00:16:06,220 --> 00:16:14,760
atom but it's adam that's being changed

00:16:08,470 --> 00:16:19,780
and region uses its own adam concept

00:16:14,760 --> 00:16:22,750
which it just refreshes or rear enders

00:16:19,780 --> 00:16:26,320
whenever you make a change its kind of

00:16:22,750 --> 00:16:29,650
similar how how components works in

00:16:26,320 --> 00:16:35,530
react so if you want to know more about

00:16:29,650 --> 00:16:40,360
Adam there's a link to that now pure

00:16:35,530 --> 00:16:43,540
script so pure scoop is written in

00:16:40,360 --> 00:16:46,480
Haskell and it is a strongly typed

00:16:43,540 --> 00:16:49,240
language that compiles to JavaScript as

00:16:46,480 --> 00:16:50,950
well therefore if you're not writing in

00:16:49,240 --> 00:16:58,480
pure script you're writing an inker

00:16:50,950 --> 00:17:04,020
script so it has the haskell syntax as

00:16:58,480 --> 00:17:04,020
well and back to our previous

00:17:04,159 --> 00:17:09,870
example of the person so so you take a

00:17:07,559 --> 00:17:12,480
person and then you copy everything else

00:17:09,870 --> 00:17:14,189
from the person only changes the age and

00:17:12,480 --> 00:17:20,819
this is how you will write in pure

00:17:14,189 --> 00:17:23,069
script so I don't know if all of you are

00:17:20,819 --> 00:17:26,909
familiar with the concept but if you

00:17:23,069 --> 00:17:32,309
only starting ice I suggest to start

00:17:26,909 --> 00:17:35,010
with milk oj s and then if you are more

00:17:32,309 --> 00:17:39,029
comfortable with it then you can move on

00:17:35,010 --> 00:17:41,580
to pure script or closure script and I

00:17:39,029 --> 00:17:45,149
know starting something new is very very

00:17:41,580 --> 00:17:50,460
hard and it may be outside of your

00:17:45,149 --> 00:17:54,690
comfort zone but I think we should all

00:17:50,460 --> 00:17:58,260
expand our comfort zone and write

00:17:54,690 --> 00:18:02,279
something that's more predictable and

00:17:58,260 --> 00:18:04,019
really easy to think about and that's

00:18:02,279 --> 00:18:07,350
all I have and I really love these

00:18:04,019 --> 00:18:10,710
things so so if you want to talk about

00:18:07,350 --> 00:18:15,830
them you can simply tweet about it and

00:18:10,710 --> 00:18:18,950
all my slides are on my github as well

00:18:15,830 --> 00:18:18,950
thank you

00:18:23,110 --> 00:18:31,600
great thank you so much do we have any

00:18:26,350 --> 00:18:32,650
question oh yeah we have a ha ok yes I

00:18:31,600 --> 00:18:34,960
may have to get back to you on that

00:18:32,650 --> 00:18:37,870
because I do have a lot of functional

00:18:34,960 --> 00:18:41,530
programming books but I can't remember

00:18:37,870 --> 00:18:45,429
them on top of my head but I will get

00:18:41,530 --> 00:18:48,000
back to you on that sorry yeah thank you

00:18:45,429 --> 00:18:48,000

YouTube URL: https://www.youtube.com/watch?v=DfxURtcuZdE


