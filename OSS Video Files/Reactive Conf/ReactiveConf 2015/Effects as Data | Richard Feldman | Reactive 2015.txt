Title: Effects as Data | Richard Feldman | Reactive 2015
Publication date: 2017-06-29
Playlist: ReactiveConf 2015
Description: 
	Imagine a world without side effects, where the only way to make things happen was to call functions whose return values described what you wanted done. What gets easier in that world? What gets harder? What would that mean for debugging? Testing? 

We don't have to wonder about these things, because this world already exists — and it compiles to JavaScript. It's the world of Elm, where there are no side effects, all functions are stateless, and all data is immutable. Elm embraces the concepts that make reactive programming great, and goes one step further to shed the error‐prone mutations and side effects that so often lead to incidental complexity and buggy code. 

NoRedInk has reaped the benefits of this approach since they began using Elm in production earlier in 2015. It's helped them scale and maintain a complex front-end code base that students use to answer millions of questions per day. Come see how refreshing this world can be!

Richard is the creator of seamless-immutable and Dreamwriter, and coauthor of Developing a React Edge. Richard leads the front-end team at NoRedInk, where he introduced React, then Flux, and now Elm to their production stack.
Captions: 
	00:00:05,359 --> 00:00:11,580
okay welcome this is FX's data

00:00:08,550 --> 00:00:13,320
I'm Richard Feldman so I want to start

00:00:11,580 --> 00:00:14,639
by talking about a project I worked on a

00:00:13,320 --> 00:00:17,310
couple years ago and this was

00:00:14,639 --> 00:00:20,730
essentially something that let people

00:00:17,310 --> 00:00:22,560
post resumes to apply for jobs so the

00:00:20,730 --> 00:00:24,749
business requirements of this job

00:00:22,560 --> 00:00:26,339
posting system so the user would read

00:00:24,749 --> 00:00:28,140
the job posting they would upload their

00:00:26,339 --> 00:00:30,240
resume the resume would get stored on

00:00:28,140 --> 00:00:32,160
the static file server then we would

00:00:30,240 --> 00:00:33,840
parse the contact info out of that to

00:00:32,160 --> 00:00:35,489
save time for our end users who would be

00:00:33,840 --> 00:00:37,080
reviewing these resumes so they didn't

00:00:35,489 --> 00:00:39,290
want to have to go in and copy-paste out

00:00:37,080 --> 00:00:41,550
the email address and all that stuff so

00:00:39,290 --> 00:00:43,650
the implementation of this we would

00:00:41,550 --> 00:00:46,350
receive the uploaded resume we would

00:00:43,650 --> 00:00:47,550
store it on Amazon s3 in its raw form so

00:00:46,350 --> 00:00:49,800
that they could download it later

00:00:47,550 --> 00:00:53,430
we would parse the contact info out for

00:00:49,800 --> 00:00:54,720
them so to do this we had to deal with a

00:00:53,430 --> 00:00:56,700
bunch of different file formats because

00:00:54,720 --> 00:00:58,500
people who are applying for jobs don't

00:00:56,700 --> 00:01:00,570
care about our lives they just care

00:00:58,500 --> 00:01:03,030
about formatting their resume however

00:01:00,570 --> 00:01:06,150
they want said use dot dot dot docx PDF

00:01:03,030 --> 00:01:07,890
HTML all sorts of different fun file

00:01:06,150 --> 00:01:09,840
formats so we added a couple of

00:01:07,890 --> 00:01:11,609
different steps here first we had to

00:01:09,840 --> 00:01:14,460
convert them into a string so we'd use

00:01:11,609 --> 00:01:16,799
PDF to HTML which does this process that

00:01:14,460 --> 00:01:20,219
would take PDFs and intuitively convert

00:01:16,799 --> 00:01:22,170
them to HTML use JSON to get from HTML

00:01:20,219 --> 00:01:24,780
to various strings and we'd use a

00:01:22,170 --> 00:01:26,340
headless libreoffice process to convert

00:01:24,780 --> 00:01:28,740
from Doc and docx and all these other

00:01:26,340 --> 00:01:31,079
ancient microsoft formats into strings

00:01:28,740 --> 00:01:33,299
and then finally once we had the strings

00:01:31,079 --> 00:01:34,639
we would parse them using node J s that

00:01:33,299 --> 00:01:37,619
was our back-end

00:01:34,639 --> 00:01:39,539
okay so convert was doing file i/o so

00:01:37,619 --> 00:01:41,490
taking in the uploaded resumes and

00:01:39,539 --> 00:01:43,469
storing them in various places HTTP

00:01:41,490 --> 00:01:46,200
communication to send them off to s3 and

00:01:43,469 --> 00:01:47,869
Process Management to deal with headless

00:01:46,200 --> 00:01:50,219
Libre Office and all these other things

00:01:47,869 --> 00:01:53,009
in the parse phase you're just doing

00:01:50,219 --> 00:01:54,869
tokenizing fuzzy matching regular

00:01:53,009 --> 00:02:00,450
expressions pretty standard strings

00:01:54,869 --> 00:02:03,029
stuff so testing is good I think we can

00:02:00,450 --> 00:02:06,420
probably agree on that raise your hand

00:02:03,029 --> 00:02:08,360
if you think testing is good all right I

00:02:06,420 --> 00:02:11,160
think we have consensus on that point

00:02:08,360 --> 00:02:13,640
here's another question has anyone ever

00:02:11,160 --> 00:02:15,890
had one of these

00:02:13,640 --> 00:02:17,150
and unrealistic deadlines raise your

00:02:15,890 --> 00:02:21,020
hand if you've ever had an unrealistic

00:02:17,150 --> 00:02:22,370
deadlines alright so we have consensus

00:02:21,020 --> 00:02:24,980
on that as well you can probably see

00:02:22,370 --> 00:02:26,180
where I'm going with this you don't need

00:02:24,980 --> 00:02:27,410
to raise your hand but just think in

00:02:26,180 --> 00:02:29,390
your head if you've ever had an

00:02:27,410 --> 00:02:31,160
unrealistic deadlines and you've cut

00:02:29,390 --> 00:02:37,160
some corners and the area where you cut

00:02:31,160 --> 00:02:39,200
corners was in testing guilty so this

00:02:37,160 --> 00:02:41,330
was one of those projects we were under

00:02:39,200 --> 00:02:44,780
the gun and we cut corners on testing

00:02:41,330 --> 00:02:46,730
and specifically we cut corners on

00:02:44,780 --> 00:02:50,090
testing and the convert pipeline

00:02:46,730 --> 00:02:53,480
actually we cut the entire corner we

00:02:50,090 --> 00:02:55,340
didn't test it at all we went to

00:02:53,480 --> 00:02:57,980
production with that being totally

00:02:55,340 --> 00:03:00,050
untested all of that file i/o HTTP stuff

00:02:57,980 --> 00:03:03,170
process management no tests around any

00:03:00,050 --> 00:03:05,000
of it guess where all the problems were

00:03:03,170 --> 00:03:08,150
when it got to production where all the

00:03:05,000 --> 00:03:12,230
production fires were yeah it was in

00:03:08,150 --> 00:03:13,730
that stuff so why did we do that why did

00:03:12,230 --> 00:03:18,590
we walk into that why did we fail to

00:03:13,730 --> 00:03:19,850
test any of that stuff well if we look

00:03:18,590 --> 00:03:22,370
at what those two different things were

00:03:19,850 --> 00:03:24,230
doing so convert was doing file i/o HTTP

00:03:22,370 --> 00:03:26,330
process management whereas the parsing

00:03:24,230 --> 00:03:27,590
stuff which was much easier to test

00:03:26,330 --> 00:03:29,510
obviously because that was what we

00:03:27,590 --> 00:03:31,400
reached for and that was just converting

00:03:29,510 --> 00:03:33,320
strings into other strings so another

00:03:31,400 --> 00:03:35,480
way of thinking of this is that convert

00:03:33,320 --> 00:03:38,780
was running lots of effects and parse

00:03:35,480 --> 00:03:41,870
was just transforming data so effects

00:03:38,780 --> 00:03:44,720
are interactions with external state so

00:03:41,870 --> 00:03:47,810
you have a function that deals with

00:03:44,720 --> 00:03:49,190
external state is a stateful function so

00:03:47,810 --> 00:03:51,290
effectual functions are stateful

00:03:49,190 --> 00:03:53,000
functions the opposite of that is a

00:03:51,290 --> 00:03:54,620
stateless function so stateless

00:03:53,000 --> 00:03:56,660
functions just look at their arguments

00:03:54,620 --> 00:03:59,060
and return a value also known as pure

00:03:56,660 --> 00:04:00,920
functions or referential transparency so

00:03:59,060 --> 00:04:03,080
if you give them the same arguments they

00:04:00,920 --> 00:04:04,700
give you the same results have no side

00:04:03,080 --> 00:04:07,190
effects there's no interaction either

00:04:04,700 --> 00:04:10,209
reading from or writing to external

00:04:07,190 --> 00:04:12,590
state they're completely independent so

00:04:10,209 --> 00:04:15,019
stateless tests are really easy right

00:04:12,590 --> 00:04:16,519
set up the arguments you call the

00:04:15,019 --> 00:04:18,530
function with those arguments and you

00:04:16,519 --> 00:04:20,900
check the result the return value that's

00:04:18,530 --> 00:04:22,700
all there is to it stateful tests you

00:04:20,900 --> 00:04:26,000
have to set up the starting state and

00:04:22,700 --> 00:04:27,200
then call the function and then check

00:04:26,000 --> 00:04:30,590
the final state

00:04:27,200 --> 00:04:32,270
but if you think about it it basically

00:04:30,590 --> 00:04:34,340
just said the same thing twice right in

00:04:32,270 --> 00:04:37,550
general we can generalize this to tests

00:04:34,340 --> 00:04:41,900
are just set up and then run and then

00:04:37,550 --> 00:04:43,430
check the result so why is it easier to

00:04:41,900 --> 00:04:45,080
write stateless tests if we're just

00:04:43,430 --> 00:04:46,910
doing the same conceptual thing three

00:04:45,080 --> 00:04:49,310
times what is the implementation detail

00:04:46,910 --> 00:04:51,440
that makes us cut the entire corner off

00:04:49,310 --> 00:04:52,940
this one class of tests and feel that

00:04:51,440 --> 00:04:55,910
the other class of tests are easy to

00:04:52,940 --> 00:04:58,100
write let's take a look at potential

00:04:55,910 --> 00:05:00,020
implementations of certain parts of this

00:04:58,100 --> 00:05:02,450
pipeline so this is one way we can

00:05:00,020 --> 00:05:04,550
implement parse this is a function parse

00:05:02,450 --> 00:05:06,830
resume takes in a string does a bunch of

00:05:04,550 --> 00:05:09,170
stuff and then returns contact info and

00:05:06,830 --> 00:05:11,240
then let's look at just one portion of

00:05:09,170 --> 00:05:13,100
the effectual side of this specifically

00:05:11,240 --> 00:05:15,590
the portion that takes the resume and

00:05:13,100 --> 00:05:18,770
saves it on Amazon s3 this would be a

00:05:15,590 --> 00:05:20,750
store portion of that so function store

00:05:18,770 --> 00:05:22,070
resume it's gonna take in a file object

00:05:20,750 --> 00:05:23,360
and it's gonna take in a call back

00:05:22,070 --> 00:05:25,670
because this is node node likes

00:05:23,360 --> 00:05:27,500
callbacks we're gonna call post to s3

00:05:25,670 --> 00:05:30,410
which is a function we're assuming

00:05:27,500 --> 00:05:31,940
exists and and it takes the first

00:05:30,410 --> 00:05:34,190
argument is a path which will put it in

00:05:31,940 --> 00:05:36,140
the resumes folder and plus file name

00:05:34,190 --> 00:05:38,060
second argument is gonna it's gonna take

00:05:36,140 --> 00:05:39,710
the data the raw binary data of that

00:05:38,060 --> 00:05:41,200
file and then it's gonna take a call

00:05:39,710 --> 00:05:43,910
back which will give us back a response

00:05:41,200 --> 00:05:45,980
so in the middle logic there is handling

00:05:43,910 --> 00:05:47,600
that response so if response status is

00:05:45,980 --> 00:05:49,550
200 that means

00:05:47,600 --> 00:05:51,410
everything was good s3 said yep we

00:05:49,550 --> 00:05:54,080
stored it successfully gonna call our

00:05:51,410 --> 00:05:55,610
callback and continue otherwise we're

00:05:54,080 --> 00:05:59,270
gonna blog an error that said we failed

00:05:55,610 --> 00:06:01,850
to save that particular file ok so

00:05:59,270 --> 00:06:03,800
testing parse we're gonna just do that

00:06:01,850 --> 00:06:05,720
stuff we said earlier this is a mocha

00:06:03,800 --> 00:06:07,970
style test source a describe parsing

00:06:05,720 --> 00:06:10,340
your resume it can identify an address

00:06:07,970 --> 00:06:12,110
we will set up our arguments let's

00:06:10,340 --> 00:06:14,480
assume that we have example being some

00:06:12,110 --> 00:06:17,300
sort of example resume that we're gonna

00:06:14,480 --> 00:06:18,980
pass in the parse resume that's a string

00:06:17,300 --> 00:06:21,050
and then we get back this contact info

00:06:18,980 --> 00:06:22,880
object and then we just assert the

00:06:21,050 --> 00:06:26,300
address it looks right on that contact

00:06:22,880 --> 00:06:28,400
info object the other tests will say we

00:06:26,300 --> 00:06:30,350
want to do identify a phone number same

00:06:28,400 --> 00:06:31,910
thing just contact info equals parse

00:06:30,350 --> 00:06:33,560
resume passing a different set of

00:06:31,910 --> 00:06:37,400
example data and then make an assertion

00:06:33,560 --> 00:06:39,740
about contact info what about that story

00:06:37,400 --> 00:06:40,540
function so let's say we want to just

00:06:39,740 --> 00:06:42,790
test it it's

00:06:40,540 --> 00:06:44,620
seeds if you get a status 200 back and

00:06:42,790 --> 00:06:47,400
then it logs an error if you get a 500

00:06:44,620 --> 00:06:49,510
back how do we do that

00:06:47,400 --> 00:06:51,850
well if we look at our implementation

00:06:49,510 --> 00:06:53,590
here we've got a problem which is that

00:06:51,850 --> 00:06:55,510
we don't have access to that middle

00:06:53,590 --> 00:06:57,250
function there that callback we've got

00:06:55,510 --> 00:06:58,420
its function that takes a response and

00:06:57,250 --> 00:06:59,680
that's what we want to pass in that's

00:06:58,420 --> 00:07:01,570
what we want to change is we want to

00:06:59,680 --> 00:07:03,490
give it a different response in each of

00:07:01,570 --> 00:07:05,170
those different test cases we don't have

00:07:03,490 --> 00:07:07,630
actually access to that right now that's

00:07:05,170 --> 00:07:09,310
something that we get back from s3 so

00:07:07,630 --> 00:07:11,140
how do we fix that okay that's a pretty

00:07:09,310 --> 00:07:12,940
simple refactor we just split it up we

00:07:11,140 --> 00:07:15,040
make two functions you have a function

00:07:12,940 --> 00:07:17,260
called store resume you have a different

00:07:15,040 --> 00:07:18,970
function called handle response and now

00:07:17,260 --> 00:07:20,470
we can test handle response separately

00:07:18,970 --> 00:07:22,060
so we've just taken the same logic it's

00:07:20,470 --> 00:07:23,650
doing the same stuff it's just we've

00:07:22,060 --> 00:07:25,270
reorganized it into two functions

00:07:23,650 --> 00:07:27,580
instead of one to make it more testable

00:07:25,270 --> 00:07:29,710
okay cool

00:07:27,580 --> 00:07:31,930
so now we can describe storing a resume

00:07:29,710 --> 00:07:33,340
and say it succeeds for status 200 and

00:07:31,930 --> 00:07:35,680
now we're calling handle response

00:07:33,340 --> 00:07:38,800
passing status 200 we get back a result

00:07:35,680 --> 00:07:41,050
when you test that logs an error for 500

00:07:38,800 --> 00:07:45,090
call handle responds look at the result

00:07:41,050 --> 00:07:47,770
the test goes here oh good well or is it

00:07:45,090 --> 00:07:49,840
so what what is the value of results

00:07:47,770 --> 00:07:52,450
here

00:07:49,840 --> 00:07:55,030
well nothing because Hamlet response

00:07:52,450 --> 00:07:56,410
doesn't return anything so we're we've

00:07:55,030 --> 00:07:58,000
split it up we've now isolated this

00:07:56,410 --> 00:07:59,740
thing now the arguments part is fine we

00:07:58,000 --> 00:08:01,960
can now pass stuff into this in our test

00:07:59,740 --> 00:08:03,970
cases but we still don't have a return

00:08:01,960 --> 00:08:06,160
value to work with so we've got the part

00:08:03,970 --> 00:08:08,110
where we set it up but the other part

00:08:06,160 --> 00:08:11,770
the check we still don't have anything

00:08:08,110 --> 00:08:14,920
for that this is annoying it's it's sort

00:08:11,770 --> 00:08:16,360
of a hostile API right we want to just

00:08:14,920 --> 00:08:17,860
do what we did in the first place we

00:08:16,360 --> 00:08:19,890
just call the thing and then look at

00:08:17,860 --> 00:08:24,100
what we got back why can't we do that

00:08:19,890 --> 00:08:26,500
well we can do that using mocks so mocks

00:08:24,100 --> 00:08:28,000
inject a more testable API that's

00:08:26,500 --> 00:08:31,660
something that sort of intrinsically has

00:08:28,000 --> 00:08:34,540
a hostile one and mocks are the best

00:08:31,660 --> 00:08:36,610
everybody loves mocks I mean I think

00:08:34,540 --> 00:08:37,900
about writing a stateless test and just

00:08:36,610 --> 00:08:39,790
passing an argument slinging your at the

00:08:37,900 --> 00:08:41,590
result and then I think about writing

00:08:39,790 --> 00:08:45,479
mocks and I have the same feelings about

00:08:41,590 --> 00:08:45,479
both of those yeah

00:08:45,670 --> 00:08:50,090
starting to become apparent how we could

00:08:47,960 --> 00:08:54,830
have skipped this entire category of

00:08:50,090 --> 00:08:56,900
test somehow so here's a novel idea what

00:08:54,830 --> 00:08:59,510
if we just had a testable API to begin

00:08:56,900 --> 00:09:01,820
with what if we just made it so that all

00:08:59,510 --> 00:09:03,410
of our business logic was in stateless

00:09:01,820 --> 00:09:05,480
functions and we could have just written

00:09:03,410 --> 00:09:07,070
the nice kind of test the entire time

00:09:05,480 --> 00:09:08,510
through maybe we would have had a

00:09:07,070 --> 00:09:10,160
different experience and production

00:09:08,510 --> 00:09:14,480
would have been I'm gonna say less on

00:09:10,160 --> 00:09:15,710
fire when we launched so flux has some

00:09:14,480 --> 00:09:17,750
interesting things about say about this

00:09:15,710 --> 00:09:20,570
the same way as Redux does the same way

00:09:17,750 --> 00:09:22,520
as the Elm architecture does you have

00:09:20,570 --> 00:09:24,830
these actions right so an action is a

00:09:22,520 --> 00:09:26,480
value that describes an effect it's not

00:09:24,830 --> 00:09:29,660
an effect itself obviously this is just

00:09:26,480 --> 00:09:31,100
data but it's still describing the idea

00:09:29,660 --> 00:09:33,440
of what we want done we're saying the

00:09:31,100 --> 00:09:35,480
action type is post to s3 you've got a

00:09:33,440 --> 00:09:37,640
name which is file dot name path which

00:09:35,480 --> 00:09:41,240
is the resumés thing we put together and

00:09:37,640 --> 00:09:42,950
then the data being the files data so we

00:09:41,240 --> 00:09:44,840
can write our store resume function in

00:09:42,950 --> 00:09:46,850
terms of this still taking a file but

00:09:44,840 --> 00:09:48,350
now instead of taking a call back we're

00:09:46,850 --> 00:09:52,130
returning something we're returning this

00:09:48,350 --> 00:09:53,840
description of what we want done okay

00:09:52,130 --> 00:09:56,450
and then handle response

00:09:53,840 --> 00:09:59,090
similarly can take a name in a response

00:09:56,450 --> 00:10:01,310
and then instead of making a call back

00:09:59,090 --> 00:10:03,020
it can just return another action and

00:10:01,310 --> 00:10:05,210
this one's gonna return a different

00:10:03,020 --> 00:10:06,920
action depending on the status code so

00:10:05,210 --> 00:10:09,380
this is our business logic determining

00:10:06,920 --> 00:10:11,540
which effect we want done next so the

00:10:09,380 --> 00:10:14,510
status code is 200 we're gonna return a

00:10:11,540 --> 00:10:16,160
saved success and if it's not 200 we're

00:10:14,510 --> 00:10:18,110
gonna return any log error action with

00:10:16,160 --> 00:10:20,600
the appropriate message wrapped up in it

00:10:18,110 --> 00:10:24,110
either way we're going to return another

00:10:20,600 --> 00:10:25,910
action so essentially this is the idea

00:10:24,110 --> 00:10:27,920
of representing effects as data we're

00:10:25,910 --> 00:10:32,270
just passing action objects instead of

00:10:27,920 --> 00:10:34,040
doing the thing immediately okay but of

00:10:32,270 --> 00:10:35,660
course we can't just stop there we can't

00:10:34,040 --> 00:10:38,600
just have functions that just return

00:10:35,660 --> 00:10:40,160
stuff and then we don't do anything with

00:10:38,600 --> 00:10:41,450
them because if we did that then we

00:10:40,160 --> 00:10:42,710
would not have any kind of production

00:10:41,450 --> 00:10:43,820
environment we would just be passing a

00:10:42,710 --> 00:10:47,120
bunch of data around it'll be very

00:10:43,820 --> 00:10:49,160
testable and would do nothing so we

00:10:47,120 --> 00:10:51,290
actually need to do it so we'll make

00:10:49,160 --> 00:10:53,360
this third function called run action so

00:10:51,290 --> 00:10:54,920
run action will take the action and we

00:10:53,360 --> 00:10:56,870
will do a switch statement on action

00:10:54,920 --> 00:10:57,740
action type and then depending on which

00:10:56,870 --> 00:11:00,320
of those

00:10:57,740 --> 00:11:02,480
action types we've got so post s3 handle

00:11:00,320 --> 00:11:03,980
response log air and safe success we

00:11:02,480 --> 00:11:06,410
will take the appropriate action we will

00:11:03,980 --> 00:11:07,010
actually run the effect so if we're post

00:11:06,410 --> 00:11:08,510
to s3

00:11:07,010 --> 00:11:10,250
when we get one of those is our action

00:11:08,510 --> 00:11:11,750
type we're gonna call that post to s3

00:11:10,250 --> 00:11:12,980
function that we're used to be calling

00:11:11,750 --> 00:11:15,800
directly from our business logic

00:11:12,980 --> 00:11:17,630
function so we call it passing action

00:11:15,800 --> 00:11:18,890
path action data which again were

00:11:17,630 --> 00:11:20,600
constructed on our business logic

00:11:18,890 --> 00:11:22,400
function and then we're gonna do the

00:11:20,600 --> 00:11:25,310
callback which is going to call run

00:11:22,400 --> 00:11:27,620
action again passing that action type so

00:11:25,310 --> 00:11:29,900
again we're just no business logic in

00:11:27,620 --> 00:11:32,060
here whatsoever all we're doing is

00:11:29,900 --> 00:11:34,540
handling these actions and translating

00:11:32,060 --> 00:11:36,350
them into actual effects that get run

00:11:34,540 --> 00:11:38,060
similarly we can do the same thing with

00:11:36,350 --> 00:11:39,650
handle response so this is the one that

00:11:38,060 --> 00:11:42,620
actually Forks and does two different

00:11:39,650 --> 00:11:44,720
actions depending on business logic so

00:11:42,620 --> 00:11:46,580
say next action equals and handle

00:11:44,720 --> 00:11:47,870
response and we take action name

00:11:46,580 --> 00:11:50,120
actually not response and that's gonna

00:11:47,870 --> 00:11:52,040
give us back one of two new actions

00:11:50,120 --> 00:11:54,620
depending on whether we got a 200 or not

00:11:52,040 --> 00:11:56,120
from s3 doesn't matter which one again

00:11:54,620 --> 00:11:57,620
this has no knowledge of the business

00:11:56,120 --> 00:11:59,750
logic it's just gonna take whatever it

00:11:57,620 --> 00:12:03,530
gets back from handle response and call

00:11:59,750 --> 00:12:06,050
run action again to keep going okay so

00:12:03,530 --> 00:12:08,090
to sum up version 1 of this function we

00:12:06,050 --> 00:12:10,010
had store resume it did stood chain

00:12:08,090 --> 00:12:11,360
callbacks right there just so the most

00:12:10,010 --> 00:12:14,330
straightforward implementation we could

00:12:11,360 --> 00:12:16,070
think of very difficult to test version

00:12:14,330 --> 00:12:17,960
two easier to test in the sense of

00:12:16,070 --> 00:12:19,370
handling response handle response being

00:12:17,960 --> 00:12:21,110
something we could actually call

00:12:19,370 --> 00:12:23,120
directly so we could pass arguments into

00:12:21,110 --> 00:12:24,890
it so these isolated callbacks let us do

00:12:23,120 --> 00:12:26,750
that and then version three was the

00:12:24,890 --> 00:12:28,040
third refactor where we split these out

00:12:26,750 --> 00:12:29,720
and made it so that both of those

00:12:28,040 --> 00:12:31,940
business logic functions were stateless

00:12:29,720 --> 00:12:33,980
and just returning an action object and

00:12:31,940 --> 00:12:36,400
then we made this run action function

00:12:33,980 --> 00:12:39,590
that actually turned those into effects

00:12:36,400 --> 00:12:41,270
so we're done right mission accomplished

00:12:39,590 --> 00:12:42,920
we've successfully turned our business

00:12:41,270 --> 00:12:44,780
logic stuff into stateless functions

00:12:42,920 --> 00:12:49,370
they're now easy to test and we can all

00:12:44,780 --> 00:12:51,770
go home not quite so the effect wearing

00:12:49,370 --> 00:12:54,560
still needs testing right we can still

00:12:51,770 --> 00:12:56,180
potentially make errors there but at

00:12:54,560 --> 00:12:58,760
least now we can have one mock to test

00:12:56,180 --> 00:13:01,370
them all so if we go back and we look at

00:12:58,760 --> 00:13:04,700
our run action here's an example of one

00:13:01,370 --> 00:13:07,040
thing that could go wrong here if I were

00:13:04,700 --> 00:13:08,810
to change how this worked and I say I

00:13:07,040 --> 00:13:11,150
have a new business logic requirement

00:13:08,810 --> 00:13:13,010
where I want to actually pass through

00:13:11,150 --> 00:13:15,350
the size of the file that I'm uploading

00:13:13,010 --> 00:13:17,630
so one reason I might want to do this is

00:13:15,350 --> 00:13:19,550
let's say that it goes to Amazon and it

00:13:17,630 --> 00:13:20,870
comes back with an error message and it

00:13:19,550 --> 00:13:23,330
says hey I couldn't store this for you

00:13:20,870 --> 00:13:25,250
but for some reason Amazon's API doesn't

00:13:23,330 --> 00:13:26,660
tell us what the reason was that's kind

00:13:25,250 --> 00:13:28,460
of annoying and we're trying to diagnose

00:13:26,660 --> 00:13:30,020
why this might be so when I pass the

00:13:28,460 --> 00:13:32,030
file size to it because we know one of

00:13:30,020 --> 00:13:33,950
the things that could go wrong is that

00:13:32,030 --> 00:13:36,320
we could get in sort of excessive size

00:13:33,950 --> 00:13:39,020
error so we want to pass that through

00:13:36,320 --> 00:13:41,390
well if we're doing these two business

00:13:39,020 --> 00:13:43,490
logics functions as stateless functions

00:13:41,390 --> 00:13:44,660
when we're testing them we're passing in

00:13:43,490 --> 00:13:46,940
dummy data we're assuming that

00:13:44,660 --> 00:13:49,100
everything went through properly but

00:13:46,940 --> 00:13:51,170
it's entirely possible that in the store

00:13:49,100 --> 00:13:53,960
resume part we could fail to pass

00:13:51,170 --> 00:13:56,150
through the correct size attribute from

00:13:53,960 --> 00:13:58,400
that file object but then on the other

00:13:56,150 --> 00:13:59,660
side we would never know that it didn't

00:13:58,400 --> 00:14:01,490
get there because in our test we

00:13:59,660 --> 00:14:03,380
wouldn't be passing it through assuming

00:14:01,490 --> 00:14:04,760
that the wiring had done it properly so

00:14:03,380 --> 00:14:06,470
we could have an error in this wiring

00:14:04,760 --> 00:14:08,090
that breaks everything even though those

00:14:06,470 --> 00:14:11,930
two other functions are tested properly

00:14:08,090 --> 00:14:14,120
but fortunately now we can do one MOC to

00:14:11,930 --> 00:14:17,960
test them all and just only have to mock

00:14:14,120 --> 00:14:20,120
this one function so in summary testing

00:14:17,960 --> 00:14:21,800
tactics we've gone through so far one

00:14:20,120 --> 00:14:23,540
split out stateless functions into

00:14:21,800 --> 00:14:24,800
multiple functions so we can pass things

00:14:23,540 --> 00:14:27,290
into each of them rather than having

00:14:24,800 --> 00:14:29,270
chained callbacks to isolate all the

00:14:27,290 --> 00:14:31,400
effects in one place so that one run

00:14:29,270 --> 00:14:33,530
action and so we can mock everything in

00:14:31,400 --> 00:14:35,960
there and three what we're mocking now

00:14:33,530 --> 00:14:37,640
is just simple wiring not business logic

00:14:35,960 --> 00:14:40,310
our business logic is now nice and easy

00:14:37,640 --> 00:14:44,240
to test and our mocking is all confined

00:14:40,310 --> 00:14:45,710
to just this wiring okay so we've got

00:14:44,240 --> 00:14:48,710
these nice stateless functions right

00:14:45,710 --> 00:14:50,870
what if state sneaks back in the thing

00:14:48,710 --> 00:14:53,590
that makes these tests nice is that we

00:14:50,870 --> 00:14:56,570
can just pass in data and know that if

00:14:53,590 --> 00:14:58,430
we get a return value then that's not

00:14:56,570 --> 00:15:01,940
going to change right it's just data in

00:14:58,430 --> 00:15:03,950
data out okay so here's a stateless

00:15:01,940 --> 00:15:06,290
function count resumes takes in an array

00:15:03,950 --> 00:15:08,870
of resumes it just returns resumes dot

00:15:06,290 --> 00:15:10,850
length I am pretty confident this is

00:15:08,870 --> 00:15:12,110
stateless because all it's doing is

00:15:10,850 --> 00:15:15,410
reading the length attribute and

00:15:12,110 --> 00:15:17,390
returning it cool okay this is also

00:15:15,410 --> 00:15:19,250
stateless count usable resumes let's say

00:15:17,390 --> 00:15:20,930
we get an array of all resumes and then

00:15:19,250 --> 00:15:22,449
also an array of broken resumes that are

00:15:20,930 --> 00:15:23,499
mal formatted somehow

00:15:22,449 --> 00:15:25,480
parse them we don't know what the file

00:15:23,499 --> 00:15:27,519
format is whatever the reason count

00:15:25,480 --> 00:15:30,609
usable says all that length - broken dot

00:15:27,519 --> 00:15:32,709
length definitely also stateless okay

00:15:30,609 --> 00:15:34,569
and even if we compose those two

00:15:32,709 --> 00:15:36,730
together we implement count usable in

00:15:34,569 --> 00:15:41,619
terms of count resumes just passing in

00:15:36,730 --> 00:15:43,869
all um still very stateless this is not

00:15:41,619 --> 00:15:46,239
stateless we made one modification here

00:15:43,869 --> 00:15:48,759
now account resumes is taking in its

00:15:46,239 --> 00:15:50,169
resumes array and then just totally

00:15:48,759 --> 00:15:51,549
ignoring it and just blowing it away

00:15:50,169 --> 00:15:55,629
with whatever's in local storage dot

00:15:51,549 --> 00:15:56,919
resumes thanks that's annoying and

00:15:55,629 --> 00:15:58,299
that's gonna break our count resumes

00:15:56,919 --> 00:16:00,369
function but it's also going to break

00:15:58,299 --> 00:16:02,019
our count usable function because that

00:16:00,369 --> 00:16:04,209
function is calling out to count resumes

00:16:02,019 --> 00:16:05,829
so now whereas previously we had two

00:16:04,209 --> 00:16:07,239
stateless functions now it turns out

00:16:05,829 --> 00:16:08,679
we've got two stateful functions they're

00:16:07,239 --> 00:16:10,569
both relying on the current state of

00:16:08,679 --> 00:16:13,209
local storage at the time that you call

00:16:10,569 --> 00:16:15,549
them to determine what they return this

00:16:13,209 --> 00:16:17,829
reminds me of the colorful metaphor if

00:16:15,549 --> 00:16:20,799
you take a barrel full of water you just

00:16:17,829 --> 00:16:23,919
had just one drop of urine now you have

00:16:20,799 --> 00:16:26,350
a barrel of urine water that's kind of

00:16:23,919 --> 00:16:29,019
what's going on here all it takes is one

00:16:26,350 --> 00:16:31,899
previously you can draw well I don't you

00:16:29,019 --> 00:16:33,220
could write that if you call each of

00:16:31,899 --> 00:16:35,289
them passing the same arguments you're

00:16:33,220 --> 00:16:36,910
gonna get the same return value but now

00:16:35,289 --> 00:16:38,619
you're not anymore because just one of

00:16:36,910 --> 00:16:40,299
them in the chain polluted all the

00:16:38,619 --> 00:16:44,289
others with this state

00:16:40,299 --> 00:16:45,970
that's annoying okay but there's a

00:16:44,289 --> 00:16:47,379
silver lining here which is that if we

00:16:45,970 --> 00:16:49,029
tested both of these functions right we

00:16:47,379 --> 00:16:51,220
tested count usable when we tested count

00:16:49,029 --> 00:16:52,839
resumes this is gonna break because when

00:16:51,220 --> 00:16:54,910
we were passed testing count resumes we

00:16:52,839 --> 00:16:57,789
were passing in a value for resumes and

00:16:54,910 --> 00:16:58,899
then it used to just return resumes at

00:16:57,789 --> 00:17:00,609
length but now it's looking at local

00:16:58,899 --> 00:17:02,709
storage and since we wouldn't have set

00:17:00,609 --> 00:17:05,350
up local storage for that test the test

00:17:02,709 --> 00:17:07,689
would fail right so test con it we're

00:17:05,350 --> 00:17:08,919
good we're glad we wrote that test now

00:17:07,689 --> 00:17:11,639
we're definitely covered we can

00:17:08,919 --> 00:17:11,639
definitely go home

00:17:12,069 --> 00:17:17,059
okay what about this so this is another

00:17:15,709 --> 00:17:19,640
way you could have state sneak in

00:17:17,059 --> 00:17:21,709
what if count resumes calls resumes pop

00:17:19,640 --> 00:17:23,929
so it actually mutates the thing that it

00:17:21,709 --> 00:17:25,790
takes in like a jerk and then it returns

00:17:23,929 --> 00:17:27,140
resumes dot length plus one to cover up

00:17:25,790 --> 00:17:29,450
for it I know that nobody in this room

00:17:27,140 --> 00:17:31,070
has ever done a hack and then covered it

00:17:29,450 --> 00:17:32,720
up to make it look like it was still

00:17:31,070 --> 00:17:35,480
working the way it used to I certainly

00:17:32,720 --> 00:17:37,670
have never done that in my career okay

00:17:35,480 --> 00:17:39,890
so let's say it's doing this now again

00:17:37,670 --> 00:17:42,140
we've had state sneak back in but this

00:17:39,890 --> 00:17:44,480
is more pernicious because our test

00:17:42,140 --> 00:17:46,820
that's passing in resumes is not going

00:17:44,480 --> 00:17:49,070
to fail unless we specifically happen to

00:17:46,820 --> 00:17:50,600
pass in empty array right empty array

00:17:49,070 --> 00:17:52,520
will break if we had a test covering

00:17:50,600 --> 00:17:53,960
this they pass in the empty array it

00:17:52,520 --> 00:17:55,160
tries to pop nothing off of there

00:17:53,960 --> 00:17:57,230
they're never turns length plus one now

00:17:55,160 --> 00:17:59,030
that's the wrong length but all other

00:17:57,230 --> 00:18:01,190
cases it's gonna pass so hopefully we

00:17:59,030 --> 00:18:02,840
did that test hopefully we had one

00:18:01,190 --> 00:18:07,910
passing empty array so we dodged a

00:18:02,840 --> 00:18:09,770
bullet again okay but I mean like

00:18:07,910 --> 00:18:12,230
realistically maybe if we're using quick

00:18:09,770 --> 00:18:14,179
check okay nevermind let's move all

00:18:12,230 --> 00:18:15,710
right what about this one okay surely

00:18:14,179 --> 00:18:18,020
this must be stateless right I mean we

00:18:15,710 --> 00:18:20,780
just got I guess I spoiled it with the

00:18:18,020 --> 00:18:22,160
caption but so we got it we've got a

00:18:20,780 --> 00:18:23,929
variable outside called extras right

00:18:22,160 --> 00:18:26,030
we're closing over it so account usable

00:18:23,929 --> 00:18:27,890
is now doing all dot length which we

00:18:26,030 --> 00:18:29,090
know is stateless broken dot length

00:18:27,890 --> 00:18:31,580
which we also know is stateless and then

00:18:29,090 --> 00:18:33,020
it's adding an extras dot length but of

00:18:31,580 --> 00:18:35,630
course we all know that extras can be

00:18:33,020 --> 00:18:37,370
mutated right at any point in the course

00:18:35,630 --> 00:18:39,290
of our programs execution somebody could

00:18:37,370 --> 00:18:40,460
be pop AB pushing stuff onto extras

00:18:39,290 --> 00:18:42,080
popping stuff off of it

00:18:40,460 --> 00:18:43,720
count usable could return a completely

00:18:42,080 --> 00:18:46,309
different value every time we call it

00:18:43,720 --> 00:18:48,350
and this is even more pernicious than

00:18:46,309 --> 00:18:50,299
the previous two because all of the

00:18:48,350 --> 00:18:51,890
tests for this will work right unless

00:18:50,299 --> 00:18:54,169
the tests go out of their way to mutate

00:18:51,890 --> 00:18:56,450
extras every single time you can't count

00:18:54,169 --> 00:18:57,590
usable in a test situation passing the

00:18:56,450 --> 00:18:59,350
same two arguments you're gonna get the

00:18:57,590 --> 00:19:01,700
same result it appears to be stateless

00:18:59,350 --> 00:19:02,960
when you're gonna encounter this is when

00:19:01,700 --> 00:19:04,790
you have production error logs that

00:19:02,960 --> 00:19:06,200
don't make any sense and you're having

00:19:04,790 --> 00:19:07,640
conversations with people like this

00:19:06,200 --> 00:19:08,150
isn't possible this couldn't be

00:19:07,640 --> 00:19:09,740
happening

00:19:08,150 --> 00:19:11,419
I have tests that prove this is not

00:19:09,740 --> 00:19:13,490
happening and then someone says it is

00:19:11,419 --> 00:19:15,110
happening it's broken I've got these

00:19:13,490 --> 00:19:18,549
people on the phone or angry with me

00:19:15,110 --> 00:19:18,549
like no it's not Oh

00:19:19,269 --> 00:19:29,389
so okay but as one of my favorite lines

00:19:25,519 --> 00:19:33,169
from yesterday was make consecrate lion

00:19:29,389 --> 00:19:34,909
and Julie a cow but would that have

00:19:33,169 --> 00:19:38,029
saved us here if we use constant said of

00:19:34,909 --> 00:19:39,739
our know that can still get mutated so

00:19:38,029 --> 00:19:41,749
Const is better than bar big proponent

00:19:39,739 --> 00:19:45,710
don't get me wrong but it doesn't fix

00:19:41,749 --> 00:19:47,840
the problem here ok finally we have the

00:19:45,710 --> 00:19:50,419
most pernicious one of all this is we're

00:19:47,840 --> 00:19:52,340
definitely all the tests will pass but

00:19:50,419 --> 00:19:54,499
actually it's just got a side effect

00:19:52,340 --> 00:19:56,629
right so it doesn't actually impact its

00:19:54,499 --> 00:19:58,340
own value at all it's gonna return the

00:19:56,629 --> 00:19:59,899
same thing every single time if you give

00:19:58,340 --> 00:20:01,999
it the same arguments no possible way

00:19:59,899 --> 00:20:03,799
you could write your tests in such a way

00:20:01,999 --> 00:20:06,710
that this is ever going to appear not

00:20:03,799 --> 00:20:09,830
stateless except that it's as a side

00:20:06,710 --> 00:20:11,149
effect mutating external state man this

00:20:09,830 --> 00:20:13,519
is the worst one of all because now

00:20:11,149 --> 00:20:15,200
you're wondering who did that somebody

00:20:13,519 --> 00:20:16,700
modified resumes who did that and you're

00:20:15,200 --> 00:20:18,980
not gonna look at count usable right

00:20:16,700 --> 00:20:20,119
there's no chance that count usable what

00:20:18,980 --> 00:20:24,619
I've done that it's harmless it's just

00:20:20,119 --> 00:20:27,559
counting stuff or so we thought ok how

00:20:24,619 --> 00:20:31,749
can we control this how can we stop the

00:20:27,559 --> 00:20:31,749
madness let me tell you about Elm

00:20:38,759 --> 00:20:43,450
so Elam is all stateless functions and

00:20:41,470 --> 00:20:47,230
it's all immutable values and it's all

00:20:43,450 --> 00:20:49,480
Const all the time so here is count

00:20:47,230 --> 00:20:50,950
usable in elm this is how you write

00:20:49,480 --> 00:20:52,899
functions in elm you put the arguments

00:20:50,950 --> 00:20:54,789
before the equal sign so this is count

00:20:52,899 --> 00:20:56,350
usable taking two arguments all and

00:20:54,789 --> 00:20:57,759
broken we're going to call list dot

00:20:56,350 --> 00:20:59,860
length on all that's how you get the

00:20:57,759 --> 00:21:01,120
length of something in elm and subtract

00:20:59,860 --> 00:21:02,860
list dot length of broken

00:21:01,120 --> 00:21:05,860
so same implementation as before all

00:21:02,860 --> 00:21:08,440
right let's try and break it so extras

00:21:05,860 --> 00:21:10,059
equals empty lists count usable is now

00:21:08,440 --> 00:21:12,879
incorporating list dot length extras

00:21:10,059 --> 00:21:14,440
well this is dumb because extras is

00:21:12,879 --> 00:21:16,330
always a Const so it can never be

00:21:14,440 --> 00:21:19,059
reassigned and it's immutable so it can

00:21:16,330 --> 00:21:20,470
never be pushed to or pops from so let's

00:21:19,059 --> 00:21:22,629
thought length extras will literally

00:21:20,470 --> 00:21:24,639
always be zero every single time you run

00:21:22,629 --> 00:21:26,740
this program we've failed to break our

00:21:24,639 --> 00:21:28,929
thing we've failed to introduce even a

00:21:26,740 --> 00:21:34,210
drop of urine into our lovely bucket of

00:21:28,929 --> 00:21:35,889
program colorful metaphors okay good

00:21:34,210 --> 00:21:39,490
that's good so we can actually rely on

00:21:35,889 --> 00:21:41,409
this thing being stateless excellent but

00:21:39,490 --> 00:21:44,019
now there comes the question we don't

00:21:41,409 --> 00:21:45,730
have side effects right we have every

00:21:44,019 --> 00:21:47,710
function is stateless but without side

00:21:45,730 --> 00:21:50,169
effects how can we do stuff we want to

00:21:47,710 --> 00:21:52,029
do stuff earlier on we had that last

00:21:50,169 --> 00:21:53,710
step of implementing run action right

00:21:52,029 --> 00:21:55,149
we've made almost everything stateless

00:21:53,710 --> 00:21:56,590
we made all of our business logic state

00:21:55,149 --> 00:21:58,179
list but we still needed that last

00:21:56,590 --> 00:22:00,039
little bit of effects that last little

00:21:58,179 --> 00:22:02,350
push to get over the hump so that we

00:22:00,039 --> 00:22:05,950
could actually do something how do we do

00:22:02,350 --> 00:22:07,090
that okay so we're calling back in that

00:22:05,950 --> 00:22:08,679
world in JavaScript where we'd

00:22:07,090 --> 00:22:11,529
refactored things into this nice

00:22:08,679 --> 00:22:13,240
testable paradigm we still had store

00:22:11,529 --> 00:22:15,190
resume taking a file returning an action

00:22:13,240 --> 00:22:16,990
grade handle response taking a string

00:22:15,190 --> 00:22:18,879
and a response returning an action great

00:22:16,990 --> 00:22:20,620
and then run action taking an action

00:22:18,879 --> 00:22:23,440
returning undefined and that was the

00:22:20,620 --> 00:22:25,330
thing that actually did the effects so

00:22:23,440 --> 00:22:26,470
an elm instead of having that return

00:22:25,330 --> 00:22:29,740
undefined you're gonna have a return a

00:22:26,470 --> 00:22:31,659
task so a task is just a value that

00:22:29,740 --> 00:22:33,519
describes an effect you want done kind

00:22:31,659 --> 00:22:35,740
of similarly to actions except this is a

00:22:33,519 --> 00:22:36,850
first-class citizen in Elm that the Elm

00:22:35,740 --> 00:22:39,580
runtime will just translate

00:22:36,850 --> 00:22:41,139
automatically into effects for you so it

00:22:39,580 --> 00:22:43,210
has similar characteristics to promises

00:22:41,139 --> 00:22:44,559
and callbacks so like a callback you can

00:22:43,210 --> 00:22:46,000
instantiate a task and it doesn't do

00:22:44,559 --> 00:22:47,470
anything right when you instantiate it

00:22:46,000 --> 00:22:48,490
you can make a hundred of these right in

00:22:47,470 --> 00:22:50,230
a row nothing

00:22:48,490 --> 00:22:52,210
will happen no network traffic no local

00:22:50,230 --> 00:22:54,130
storage modification nothing it just

00:22:52,210 --> 00:22:56,140
describes what you want done and like

00:22:54,130 --> 00:22:58,300
promises they incorporate the notion of

00:22:56,140 --> 00:23:00,640
success and failure right there in the

00:22:58,300 --> 00:23:04,000
task there composable like promises in

00:23:00,640 --> 00:23:08,350
the same consistent kind of way okay so

00:23:04,000 --> 00:23:10,240
now instead of this last function taking

00:23:08,350 --> 00:23:12,429
an action returning undefined in elm

00:23:10,240 --> 00:23:14,050
everything else is the same except we're

00:23:12,429 --> 00:23:15,460
taking an action and we're returning a

00:23:14,050 --> 00:23:18,610
task that's how a run actually

00:23:15,460 --> 00:23:19,630
implements it in L and now for something

00:23:18,610 --> 00:23:22,870
slightly different

00:23:19,630 --> 00:23:24,850
so actions in elm we don't represent as

00:23:22,870 --> 00:23:26,920
objects we represent using union types

00:23:24,850 --> 00:23:28,450
Union types at their simplest are just

00:23:26,920 --> 00:23:30,040
in the numeration so we could say type

00:23:28,450 --> 00:23:32,290
bool equals true or false

00:23:30,040 --> 00:23:33,970
that's saying that bool is a custom type

00:23:32,290 --> 00:23:36,190
we've just invented out of thin air and

00:23:33,970 --> 00:23:37,929
it's got either true or false those are

00:23:36,190 --> 00:23:39,490
the two sort of abstract values that can

00:23:37,929 --> 00:23:41,710
hold this is also coincidentally

00:23:39,490 --> 00:23:43,059
literally how bool is implemented in Elm

00:23:41,710 --> 00:23:44,290
which is why if you've ever seen LM code

00:23:43,059 --> 00:23:46,150
and wondered why true and false are

00:23:44,290 --> 00:23:47,650
capitalized it's because in union types

00:23:46,150 --> 00:23:49,660
all of the enumerated values are

00:23:47,650 --> 00:23:52,390
capitalized and bool is just an

00:23:49,660 --> 00:23:54,010
unspecial one just like anything else so

00:23:52,390 --> 00:23:56,290
we could use this to make an action with

00:23:54,010 --> 00:23:58,120
four different types post s3 handle

00:23:56,290 --> 00:23:59,980
response log error and saved success

00:23:58,120 --> 00:24:01,600
these would correspond to when we were

00:23:59,980 --> 00:24:04,000
making these out of objects we had an

00:24:01,600 --> 00:24:07,150
action type string and elm we're gonna

00:24:04,000 --> 00:24:09,429
use a union type for this instead Union

00:24:07,150 --> 00:24:11,320
types can be parameterized so we can

00:24:09,429 --> 00:24:13,480
incorporate not only the action type but

00:24:11,320 --> 00:24:15,429
also the value that goes with it so post

00:24:13,480 --> 00:24:17,559
s3 needed to take a string for the name

00:24:15,429 --> 00:24:19,059
and the data handle response took a

00:24:17,559 --> 00:24:20,890
string for the name and a response

00:24:19,059 --> 00:24:22,390
object log error just took a string for

00:24:20,890 --> 00:24:25,960
the message and saved success didn't

00:24:22,390 --> 00:24:27,970
take anything at all okay so now we can

00:24:25,960 --> 00:24:29,500
implement our action using a case

00:24:27,970 --> 00:24:31,240
expression which is analogous to a

00:24:29,500 --> 00:24:34,270
switch statement in JavaScript so we've

00:24:31,240 --> 00:24:36,340
got our action Union type up top post s3

00:24:34,270 --> 00:24:37,870
string data handle response string

00:24:36,340 --> 00:24:40,990
response log error string and save

00:24:37,870 --> 00:24:43,150
success and then inside of our case

00:24:40,990 --> 00:24:44,590
expression we can actually pull those

00:24:43,150 --> 00:24:45,700
things out at the same time as we're

00:24:44,590 --> 00:24:46,929
matching on them so that's one of the

00:24:45,700 --> 00:24:49,480
ways that Union types are kind of nice

00:24:46,929 --> 00:24:51,250
rather than having to do a specific

00:24:49,480 --> 00:24:53,230
match on action type and then separately

00:24:51,250 --> 00:24:56,410
extracting the data one at a time we can

00:24:53,230 --> 00:24:57,880
do both at the same time so post s3 we

00:24:56,410 --> 00:24:59,380
pull out the path string in the content

00:24:57,880 --> 00:25:01,090
and the response cloth the name string

00:24:59,380 --> 00:25:01,890
in the response and then inside each of

00:25:01,090 --> 00:25:04,950
those we

00:25:01,890 --> 00:25:07,140
the logic just like we did before okay

00:25:04,950 --> 00:25:09,210
so Union types are one type of

00:25:07,140 --> 00:25:11,610
parameterised types tasks are also

00:25:09,210 --> 00:25:14,040
parameterised tights so a task has two

00:25:11,610 --> 00:25:15,840
types it has an arrow type and a success

00:25:14,040 --> 00:25:18,090
type so in the example that we gave

00:25:15,840 --> 00:25:20,250
propose to s3 either we're gonna get

00:25:18,090 --> 00:25:21,750
back an HTTP error which indicated

00:25:20,250 --> 00:25:23,100
something like network unavailable is

00:25:21,750 --> 00:25:24,510
something went horribly wrong in the

00:25:23,100 --> 00:25:26,940
course of trying to send this resume to

00:25:24,510 --> 00:25:28,410
s3 or if it was successful we'll get

00:25:26,940 --> 00:25:29,760
back a response and that response will

00:25:28,410 --> 00:25:33,450
have the status code that we're gonna

00:25:29,760 --> 00:25:35,160
check to see if it's 200 or not okay now

00:25:33,450 --> 00:25:36,900
in JavaScript you have effects three

00:25:35,160 --> 00:25:39,060
different ways or three ways to run

00:25:36,900 --> 00:25:41,250
effects in JavaScript one is synchronous

00:25:39,060 --> 00:25:43,050
you call local storage dot foo that is

00:25:41,250 --> 00:25:44,670
an a synchronous effect as soon as you

00:25:43,050 --> 00:25:47,040
run that line of code you will have an

00:25:44,670 --> 00:25:49,230
effect another is a synchronous so send

00:25:47,040 --> 00:25:51,120
s3 also when you run that code you will

00:25:49,230 --> 00:25:52,620
have an effect but the callback won't

00:25:51,120 --> 00:25:54,810
get invoked until that effect is done

00:25:52,620 --> 00:25:56,490
and finally you have a synchronous via a

00:25:54,810 --> 00:25:58,170
promise which is the same thing as a

00:25:56,490 --> 00:26:00,000
callback except that you chain things

00:25:58,170 --> 00:26:01,620
together differently and so forth so all

00:26:00,000 --> 00:26:04,320
three of these are very common ways of

00:26:01,620 --> 00:26:05,490
doing effects in JavaScript you also

00:26:04,320 --> 00:26:07,650
have three ways of handling errors in

00:26:05,490 --> 00:26:09,660
JavaScript one is exceptions so you

00:26:07,650 --> 00:26:11,280
might run a line of code in JavaScript

00:26:09,660 --> 00:26:12,840
and expect that it might throw an

00:26:11,280 --> 00:26:14,730
exception so you do a try-catch around

00:26:12,840 --> 00:26:17,670
it another is that you might run it as a

00:26:14,730 --> 00:26:19,290
callback and as we saw in node.js it's

00:26:17,670 --> 00:26:22,530
very common to have the error argument

00:26:19,290 --> 00:26:23,760
as the first argument to the callback so

00:26:22,530 --> 00:26:25,710
you might get both you might have a

00:26:23,760 --> 00:26:27,420
callback and also an exception you might

00:26:25,710 --> 00:26:28,980
need to check for both of those and then

00:26:27,420 --> 00:26:31,500
of course promises have their own built

00:26:28,980 --> 00:26:33,630
in notion of success and failure which

00:26:31,500 --> 00:26:35,610
interacts in sometimes surprising and

00:26:33,630 --> 00:26:37,770
fun ways with these other two as james

00:26:35,610 --> 00:26:39,060
long mentioned yesterday mozilla was

00:26:37,770 --> 00:26:40,860
having this problem where you were

00:26:39,060 --> 00:26:42,780
getting exceptions swallowed by promises

00:26:40,860 --> 00:26:44,460
they were thinking that they were

00:26:42,780 --> 00:26:47,040
covered by wrapping in things in a

00:26:44,460 --> 00:26:48,690
try-catch but in fact because promises

00:26:47,040 --> 00:26:50,760
do their own try caching and translating

00:26:48,690 --> 00:26:53,700
it into these failure things it turns

00:26:50,760 --> 00:26:55,170
out you weren't covered so this is a

00:26:53,700 --> 00:26:56,510
little bit annoying that you have these

00:26:55,170 --> 00:26:59,880
different ways of potentially

00:26:56,510 --> 00:27:01,320
encountering errors Elam is a little bit

00:26:59,880 --> 00:27:02,520
more consistent so whereas you have

00:27:01,320 --> 00:27:05,160
three different ways to do effects in

00:27:02,520 --> 00:27:07,200
j/s so synchronous a sinkhole back or

00:27:05,160 --> 00:27:10,140
composedly sync via promise and effects

00:27:07,200 --> 00:27:11,790
an elm are just one way composable async

00:27:10,140 --> 00:27:12,780
via tasks that's the only way to do any

00:27:11,790 --> 00:27:14,640
effects in Elm

00:27:12,780 --> 00:27:15,630
there's no synchronous just calling a

00:27:14,640 --> 00:27:17,820
thing and not thinking of

00:27:15,630 --> 00:27:20,340
when it might return there's no callback

00:27:17,820 --> 00:27:22,440
based effects it's all via tasks and

00:27:20,340 --> 00:27:24,900
tasks have that same notion of success

00:27:22,440 --> 00:27:26,250
and error also although there are three

00:27:24,900 --> 00:27:28,049
different ways to do errors in

00:27:26,250 --> 00:27:30,240
JavaScript exceptions callback error

00:27:28,049 --> 00:27:31,679
arguments and promise failures again

00:27:30,240 --> 00:27:33,120
Ellen just has one way to do it task

00:27:31,679 --> 00:27:34,950
failures so there's nothing to swallow

00:27:33,120 --> 00:27:36,299
because there is no trycatch in Hell if

00:27:34,950 --> 00:27:37,830
you're trying to figure out how to

00:27:36,299 --> 00:27:38,429
handle an error in elm there's only one

00:27:37,830 --> 00:27:40,950
way to do it

00:27:38,429 --> 00:27:42,030
it's via handling a task failure we'll

00:27:40,950 --> 00:27:46,169
see how this gets even more awesome

00:27:42,030 --> 00:27:47,549
later on finally in JavaScript all of

00:27:46,169 --> 00:27:48,750
your effects or side effects when you

00:27:47,549 --> 00:27:50,760
run one of those things the effect

00:27:48,750 --> 00:27:52,650
happens right now it's very easy to

00:27:50,760 --> 00:27:53,820
sneak a side-effect back into a function

00:27:52,650 --> 00:27:55,080
that appears on the surface to be

00:27:53,820 --> 00:27:56,909
stateless in which all of your tests

00:27:55,080 --> 00:27:58,350
confirm are stateless but which turns

00:27:56,909 --> 00:28:00,240
out not to be because the side effect

00:27:58,350 --> 00:28:02,340
was introduced whereas an elm all

00:28:00,240 --> 00:28:03,990
effects are managed effects if the only

00:28:02,340 --> 00:28:05,760
way to get an effect is by returning a

00:28:03,990 --> 00:28:07,440
task you can't sneak that in to anything

00:28:05,760 --> 00:28:09,210
it has to actually suddenly return a

00:28:07,440 --> 00:28:10,440
task which means that it's not going to

00:28:09,210 --> 00:28:12,390
be compatible of what it was doing

00:28:10,440 --> 00:28:13,650
before you can't accidentally return

00:28:12,390 --> 00:28:16,700
something completely different

00:28:13,650 --> 00:28:19,559
managed effects instead of side effects

00:28:16,700 --> 00:28:21,510
okay so now when we're implementing our

00:28:19,559 --> 00:28:23,549
run action and we've got this case

00:28:21,510 --> 00:28:25,110
expression we got post to s3 as our

00:28:23,549 --> 00:28:27,480
action type which is now a union type

00:28:25,110 --> 00:28:29,640
we're extracting path and content then

00:28:27,480 --> 00:28:31,620
we're calling post to s3 remember that

00:28:29,640 --> 00:28:33,840
now instead of passing a callback to

00:28:31,620 --> 00:28:37,230
that post s3 is returning it to a task

00:28:33,840 --> 00:28:40,020
it is now stateless post s3 is going to

00:28:37,230 --> 00:28:42,539
return a task that's got two types type

00:28:40,020 --> 00:28:44,130
parameters one is the HTTP error which

00:28:42,539 --> 00:28:45,240
is in case it's got a network failure or

00:28:44,130 --> 00:28:46,830
something like that and then the

00:28:45,240 --> 00:28:48,510
response in case it was successful and

00:28:46,830 --> 00:28:50,309
then we can take that response and look

00:28:48,510 --> 00:28:55,280
at it and figure out if we got a 200 or

00:28:50,309 --> 00:28:55,280
not so now this is all totally stateless

00:28:55,490 --> 00:28:58,080
here's all the wiring it takes to make

00:28:57,539 --> 00:29:00,690
that happen

00:28:58,080 --> 00:29:03,870
port tasks equals app dot tasks that's

00:29:00,690 --> 00:29:06,090
it so in Elm that's how you take all of

00:29:03,870 --> 00:29:07,620
these tasks all these values and turn

00:29:06,090 --> 00:29:09,210
them into effects you just hand them off

00:29:07,620 --> 00:29:11,130
to Elm with this one line of boilerplate

00:29:09,210 --> 00:29:13,590
you just say here you go runtime this is

00:29:11,130 --> 00:29:15,690
a port is a keyword in Elm you say here

00:29:13,590 --> 00:29:18,150
are all my tasks make them turn into

00:29:15,690 --> 00:29:21,059
effects magically it just does it's very

00:29:18,150 --> 00:29:23,850
consistent about that okay

00:29:21,059 --> 00:29:26,010
why is that cool so data types in Elm

00:29:23,850 --> 00:29:26,520
are verified at Build time what does

00:29:26,010 --> 00:29:28,320
that mean

00:29:26,520 --> 00:29:30,450
here's an example of what that means

00:29:28,320 --> 00:29:32,280
if I try to call the negate function

00:29:30,450 --> 00:29:35,160
which is the switches the sine of an

00:29:32,280 --> 00:29:36,840
integer and I pass it hamburger instead

00:29:35,160 --> 00:29:38,520
of an integer I will get this error

00:29:36,840 --> 00:29:39,990
message type mismatch the argument to

00:29:38,520 --> 00:29:41,760
function the gate is causing a mismatch

00:29:39,990 --> 00:29:43,230
so it's got the little red squiggle

00:29:41,760 --> 00:29:44,850
under there indicating the offending

00:29:43,230 --> 00:29:46,800
piece of code it's got the line number

00:29:44,850 --> 00:29:48,030
on the left line 9 so this function the

00:29:46,800 --> 00:29:49,710
gate is expecting the argument to be a

00:29:48,030 --> 00:29:51,300
number but it is a string that's true

00:29:49,710 --> 00:29:52,380
you cannot negate a hamburger I had no

00:29:51,300 --> 00:29:55,410
idea how you wouldn't get a hamburger

00:29:52,380 --> 00:29:57,120
and neither does the compiler this

00:29:55,410 --> 00:29:58,800
happens at Build time right so this is

00:29:57,120 --> 00:30:00,150
not something that gets to run time and

00:29:58,800 --> 00:30:01,620
then you have a crash in your browser

00:30:00,150 --> 00:30:03,210
console this is something that just

00:30:01,620 --> 00:30:04,740
happens at the console it just tells you

00:30:03,210 --> 00:30:06,060
this it goes through your program and

00:30:04,740 --> 00:30:09,090
analyzes everything and it figures out

00:30:06,060 --> 00:30:10,920
mismatches like this ahead of time ok

00:30:09,090 --> 00:30:13,050
what does that imply for effect

00:30:10,920 --> 00:30:15,080
well when effects are data then those

00:30:13,050 --> 00:30:18,720
effects can also be verify to build time

00:30:15,080 --> 00:30:20,040
what does that mean remember that who

00:30:18,720 --> 00:30:22,170
did that question earlier

00:30:20,040 --> 00:30:24,150
looks like somebody some jerk modified

00:30:22,170 --> 00:30:25,230
local storage in the middle of something

00:30:24,150 --> 00:30:26,730
and it turned out to be this count

00:30:25,230 --> 00:30:29,280
function that had no business touching

00:30:26,730 --> 00:30:30,810
local storage now in elm when you're

00:30:29,280 --> 00:30:33,120
wondering who did dad who was

00:30:30,810 --> 00:30:34,470
responsible for this bug when you're

00:30:33,120 --> 00:30:35,820
trying to narrow down the set of

00:30:34,470 --> 00:30:38,390
potential culprits and you're looking

00:30:35,820 --> 00:30:40,590
through it now it gets really easy

00:30:38,390 --> 00:30:41,940
because if you look at parse resume

00:30:40,590 --> 00:30:44,280
you're like yeah that returns a contact

00:30:41,940 --> 00:30:46,590
info not a task so I know that that

00:30:44,280 --> 00:30:49,650
couldn't possibly be the culprit here I

00:30:46,590 --> 00:30:51,270
can't return a task so it can't possibly

00:30:49,650 --> 00:30:54,900
have any effects that is guaranteed to

00:30:51,270 --> 00:30:56,760
be stateless and effect free post s3 on

00:30:54,900 --> 00:30:58,530
the other hand is returning a task and

00:30:56,760 --> 00:31:01,170
also we can see from its parameterize

00:30:58,530 --> 00:31:03,120
type what sort of a task it is it's got

00:31:01,170 --> 00:31:04,110
an HTTP error and a response object so

00:31:03,120 --> 00:31:06,000
but until that's probably a network

00:31:04,110 --> 00:31:08,640
effect probably doesn't actually have to

00:31:06,000 --> 00:31:10,440
do with local storage and the best part

00:31:08,640 --> 00:31:12,480
about this is that the compiler is

00:31:10,440 --> 00:31:13,950
verifying all this at Build time so it's

00:31:12,480 --> 00:31:15,570
not like parse resumes sometimes

00:31:13,950 --> 00:31:17,010
returning contact info sometimes

00:31:15,570 --> 00:31:18,330
returning something else maybe sometimes

00:31:17,010 --> 00:31:20,400
it's nuclear returning a task not

00:31:18,330 --> 00:31:22,200
possible the compiler makes sure that

00:31:20,400 --> 00:31:24,480
these are consistent parsed resume

00:31:22,200 --> 00:31:26,910
returns contact info only contact info

00:31:24,480 --> 00:31:27,660
every single time so that means that

00:31:26,910 --> 00:31:29,070
when you're looking through your

00:31:27,660 --> 00:31:30,360
codebase and you got this weird bug and

00:31:29,070 --> 00:31:32,970
you're trying to figure out who caused

00:31:30,360 --> 00:31:34,740
this effect that broke things you can

00:31:32,970 --> 00:31:36,270
narrow down things just by looking at

00:31:34,740 --> 00:31:37,590
them you don't have to go through line

00:31:36,270 --> 00:31:38,910
by line of every function to be like

00:31:37,590 --> 00:31:40,170
what did you do what did you do what did

00:31:38,910 --> 00:31:42,130
you do you just be like what did you

00:31:40,170 --> 00:31:43,930
return Oh contact info all right

00:31:42,130 --> 00:31:45,550
here you're not responsible I know that

00:31:43,930 --> 00:31:47,740
and you could just really quickly narrow

00:31:45,550 --> 00:31:50,950
down the set of potential culprits cuts

00:31:47,740 --> 00:31:54,370
out a ton of debugging time okay

00:31:50,950 --> 00:31:56,380
what does this mean for testing so

00:31:54,370 --> 00:31:59,110
remember this thing this is our original

00:31:56,380 --> 00:32:01,300
implementation of the post to s3 action

00:31:59,110 --> 00:32:03,460
type written in JavaScript and we were

00:32:01,300 --> 00:32:05,710
calling post to s3 passing in the data

00:32:03,460 --> 00:32:07,570
from our actions the path the data we

00:32:05,710 --> 00:32:09,970
had this callback function no business

00:32:07,570 --> 00:32:11,890
logic in here but we still needed this

00:32:09,970 --> 00:32:13,660
wiring to make sure that things you know

00:32:11,890 --> 00:32:15,790
hooked up properly and we needed to test

00:32:13,660 --> 00:32:17,860
this with a mock because in the example

00:32:15,790 --> 00:32:19,660
of what happens if we introduce file

00:32:17,860 --> 00:32:21,070
size we needed to make sure that this

00:32:19,660 --> 00:32:22,840
thing was passing through file size

00:32:21,070 --> 00:32:25,060
properly because even if our business

00:32:22,840 --> 00:32:26,050
logic functions on both sides were

00:32:25,060 --> 00:32:27,340
working properly

00:32:26,050 --> 00:32:29,850
there was still the possibility that

00:32:27,340 --> 00:32:33,190
this wasn't passing it through right

00:32:29,850 --> 00:32:36,430
except that was in JavaScript

00:32:33,190 --> 00:32:38,320
all right so in elm if you look at store

00:32:36,430 --> 00:32:40,060
resume it takes the file returns in

00:32:38,320 --> 00:32:42,160
action handle response takes a string

00:32:40,060 --> 00:32:44,140
response returns in action okay the

00:32:42,160 --> 00:32:45,970
compiler is verifying that these are all

00:32:44,140 --> 00:32:47,290
correct these are the arguments that are

00:32:45,970 --> 00:32:50,230
being passed they're the correct type

00:32:47,290 --> 00:32:52,990
everything is good if I change those and

00:32:50,230 --> 00:32:55,030
I introduce an int to handle response so

00:32:52,990 --> 00:32:57,520
named sighs and now response if that's

00:32:55,030 --> 00:32:59,080
what that's taking now not only do I

00:32:57,520 --> 00:32:59,950
have to I don't need to rely on tests

00:32:59,080 --> 00:33:02,410
anymore to make sure that that's

00:32:59,950 --> 00:33:04,720
happening if I have something that's no

00:33:02,410 --> 00:33:05,980
longer calling handle response passing

00:33:04,720 --> 00:33:07,870
the correct signature in other words

00:33:05,980 --> 00:33:10,600
it's calling it passing the old way I

00:33:07,870 --> 00:33:12,880
forgot to update that wiring I'm gonna

00:33:10,600 --> 00:33:15,640
get a compiler error so in other words

00:33:12,880 --> 00:33:16,810
the wiring can't mess this up that

00:33:15,640 --> 00:33:18,520
little function that we wrote that we

00:33:16,810 --> 00:33:20,260
needed a mock to test in JavaScript

00:33:18,520 --> 00:33:23,080
can't break this anymore

00:33:20,260 --> 00:33:25,690
because the compiler will just cover it

00:33:23,080 --> 00:33:27,310
if there's a mismatch if the wiring is

00:33:25,690 --> 00:33:28,690
wrong the compiler will tell you about

00:33:27,310 --> 00:33:31,450
it for sure you don't need to write a

00:33:28,690 --> 00:33:35,470
test for that and we also talked earlier

00:33:31,450 --> 00:33:36,880
about how of these three functions the

00:33:35,470 --> 00:33:38,980
first two were stateless and didn't need

00:33:36,880 --> 00:33:41,320
any mocks and the only reason the third

00:33:38,980 --> 00:33:44,410
one needed any mocks was to test that

00:33:41,320 --> 00:33:46,350
the wiring worked which means if the

00:33:44,410 --> 00:33:49,510
compilers got you covered on the wiring

00:33:46,350 --> 00:33:51,460
we don't need any walks anymore we can

00:33:49,510 --> 00:33:53,890
test our whole program as stateless

00:33:51,460 --> 00:33:57,010
functions without any mocking and

00:33:53,890 --> 00:33:59,740
we'll be totally covered awesome so

00:33:57,010 --> 00:34:02,050
finally all tests are created easy we

00:33:59,740 --> 00:34:04,000
can have this program that we're going

00:34:02,050 --> 00:34:05,590
to ship to production and no longer feel

00:34:04,000 --> 00:34:07,390
like we need to cut this corner and just

00:34:05,590 --> 00:34:09,310
skip the entire FX testing process

00:34:07,390 --> 00:34:11,980
because it's easy now it's just as easy

00:34:09,310 --> 00:34:14,429
as taste taste testing Wow

00:34:11,980 --> 00:34:18,730
as testing the stateless functions

00:34:14,429 --> 00:34:20,470
awesome okay so let's take this a step

00:34:18,730 --> 00:34:22,780
further so one of the other things that

00:34:20,470 --> 00:34:24,880
we saw was that sometimes we were taking

00:34:22,780 --> 00:34:26,440
in effect and all we were all we were

00:34:24,880 --> 00:34:28,630
doing with that action was we were

00:34:26,440 --> 00:34:30,310
computing the next action so we had

00:34:28,630 --> 00:34:32,730
handle response that was situationally

00:34:30,310 --> 00:34:34,750
returning one of two next actions to do

00:34:32,730 --> 00:34:36,640
okay but that's something that we kind

00:34:34,750 --> 00:34:38,290
of do a lot as we might also recall post

00:34:36,640 --> 00:34:40,270
s3 was returning another action that

00:34:38,290 --> 00:34:43,000
gets done so Elm effects is this library

00:34:40,270 --> 00:34:44,970
that takes task output and just turns it

00:34:43,000 --> 00:34:46,960
back into another action or takes it and

00:34:44,970 --> 00:34:49,419
once you've translated it into another

00:34:46,960 --> 00:34:50,830
action feeds it back into run action so

00:34:49,419 --> 00:34:52,390
you just get this continuous loop of

00:34:50,830 --> 00:34:54,159
actions you don't need to actually do

00:34:52,390 --> 00:34:55,480
that extra wiring of saying okay let's

00:34:54,159 --> 00:34:56,980
look at what we got back and then call

00:34:55,480 --> 00:34:59,310
ourselves again with that this just

00:34:56,980 --> 00:35:02,650
takes care of all of that stuff for you

00:34:59,310 --> 00:35:03,820
okay so there's a slight difference here

00:35:02,650 --> 00:35:05,020
right this is a little bit different

00:35:03,820 --> 00:35:06,430
than what we had before so we still have

00:35:05,020 --> 00:35:07,930
run action we're still doing a pattern

00:35:06,430 --> 00:35:10,000
match on action using our case

00:35:07,930 --> 00:35:11,980
expression now we're taking the results

00:35:10,000 --> 00:35:15,400
of post to s3 which returns a task and

00:35:11,980 --> 00:35:18,370
passing it to effects at tasks okay cool

00:35:15,400 --> 00:35:21,070
so post s3 is a task return returning an

00:35:18,370 --> 00:35:22,720
HTTP error and a response so in HTTP or

00:35:21,070 --> 00:35:24,790
if there's an error and response if

00:35:22,720 --> 00:35:26,980
there's a success that's a problem

00:35:24,790 --> 00:35:28,720
though because we want to send that back

00:35:26,980 --> 00:35:31,570
into run action but we can't do that

00:35:28,720 --> 00:35:32,980
because we've said that Elm effects is

00:35:31,570 --> 00:35:35,140
going to take the results of that task

00:35:32,980 --> 00:35:36,340
and feed it back into run action but we

00:35:35,140 --> 00:35:38,260
didn't actually make it result in

00:35:36,340 --> 00:35:40,030
another action whether it succeeds or

00:35:38,260 --> 00:35:41,770
fails it's always returning something

00:35:40,030 --> 00:35:43,300
that's not an action so we need to

00:35:41,770 --> 00:35:45,520
translate it back into an action if we

00:35:43,300 --> 00:35:47,230
want it to actually be fed back in this

00:35:45,520 --> 00:35:48,940
will be a build error if we run this

00:35:47,230 --> 00:35:50,590
code it will say no you can't do this

00:35:48,940 --> 00:35:53,410
you have a type mismatch you need to

00:35:50,590 --> 00:35:54,910
translate that all right sure so one of

00:35:53,410 --> 00:35:56,860
the nice things about having effects as

00:35:54,910 --> 00:35:58,840
data is that it's easy to translate from

00:35:56,860 --> 00:36:00,850
one type of data to another see how this

00:35:58,840 --> 00:36:02,320
function task dot map that second line

00:36:00,850 --> 00:36:04,510
of code there that's an anonymous

00:36:02,320 --> 00:36:06,640
function in elm so it's like arrow using

00:36:04,510 --> 00:36:07,490
arrows but instead of es6 arrows where

00:36:06,640 --> 00:36:08,660
you have parenthesis

00:36:07,490 --> 00:36:10,070
around the arguments you just have a

00:36:08,660 --> 00:36:11,210
little backslash indicating this is the

00:36:10,070 --> 00:36:13,100
start of the arguments then the arrow

00:36:11,210 --> 00:36:14,180
indicates the end of the arguments so we

00:36:13,100 --> 00:36:16,130
could have multiple arguments in there

00:36:14,180 --> 00:36:18,980
but in this case it's just the response

00:36:16,130 --> 00:36:21,470
so cast map is responsible for

00:36:18,980 --> 00:36:23,360
translating the success case into a

00:36:21,470 --> 00:36:24,080
different type of success so we're

00:36:23,360 --> 00:36:25,670
staying right we're gonna get this

00:36:24,080 --> 00:36:27,470
response object and we're gonna

00:36:25,670 --> 00:36:29,869
translate that into a handle response

00:36:27,470 --> 00:36:31,790
action passing the path that we've got

00:36:29,869 --> 00:36:33,380
from earlier on in the pattern match and

00:36:31,790 --> 00:36:36,350
then the response that we got from the

00:36:33,380 --> 00:36:37,880
task and then the second argument to TAS

00:36:36,350 --> 00:36:39,650
time AB is the actual task that we're

00:36:37,880 --> 00:36:41,570
doing this translation on so what this

00:36:39,650 --> 00:36:44,690
is going to give us back is a new task

00:36:41,570 --> 00:36:47,869
which if it succeeds actually gives a

00:36:44,690 --> 00:36:50,270
Hamel response action rather than a raw

00:36:47,869 --> 00:36:51,770
HTTP response if it's an error it's

00:36:50,270 --> 00:36:54,560
still going to be an HTTP error but if

00:36:51,770 --> 00:36:56,540
it's a success it's now in action okay

00:36:54,560 --> 00:36:59,210
and then finally we need to handle the

00:36:56,540 --> 00:37:00,920
error case now remember it said in L

00:36:59,210 --> 00:37:03,110
effects that it needs to get an action

00:37:00,920 --> 00:37:05,240
out no matter what which means that this

00:37:03,110 --> 00:37:06,950
can't be a task that fails it needs to

00:37:05,240 --> 00:37:08,990
always succeed with an action of some

00:37:06,950 --> 00:37:11,200
sort so the way that we get a task that

00:37:08,990 --> 00:37:13,580
never fails is we call task dot on error

00:37:11,200 --> 00:37:17,420
again passing an anonymous function and

00:37:13,580 --> 00:37:19,040
this time on error takes the the error

00:37:17,420 --> 00:37:20,869
type and then translates it into a new

00:37:19,040 --> 00:37:22,340
type of task so in this case we're gonna

00:37:20,869 --> 00:37:23,540
say task dot succeed which gives you

00:37:22,340 --> 00:37:26,030
back a task that never fails

00:37:23,540 --> 00:37:28,220
and one of those actions in there so in

00:37:26,030 --> 00:37:30,670
essence we've gone from a task that on

00:37:28,220 --> 00:37:32,960
error gives you an HTTP error and on

00:37:30,670 --> 00:37:35,240
success gives you back a response object

00:37:32,960 --> 00:37:38,690
and now on error it gives you a log

00:37:35,240 --> 00:37:41,480
error success and on success it gives

00:37:38,690 --> 00:37:43,190
you back a handle request action so in

00:37:41,480 --> 00:37:46,490
either case we're now getting back in

00:37:43,190 --> 00:37:48,230
action that's what this means

00:37:46,490 --> 00:37:50,300
so error handling has now become

00:37:48,230 --> 00:37:52,190
impossible to forget if we tried not to

00:37:50,300 --> 00:37:53,869
handle that error and not translated it

00:37:52,190 --> 00:37:55,520
back into an action of some sort we

00:37:53,869 --> 00:37:57,230
would have gotten a build error and all

00:37:55,520 --> 00:37:59,390
effects would have said no you can't do

00:37:57,230 --> 00:38:00,920
this you're giving me an HTTP error

00:37:59,390 --> 00:38:03,140
you forgot to handle that turn that into

00:38:00,920 --> 00:38:04,970
an action so we turned it into an action

00:38:03,140 --> 00:38:06,740
we turned it into a log error action and

00:38:04,970 --> 00:38:09,320
if we'd forgotten to do that we would

00:38:06,740 --> 00:38:11,300
have gotten a compiler error what that

00:38:09,320 --> 00:38:13,609
means is that now error handling is

00:38:11,300 --> 00:38:15,230
deliberate it's impossible to forget the

00:38:13,609 --> 00:38:16,490
compiler will literally yell at you if

00:38:15,230 --> 00:38:19,589
you ever forget to handle one of these

00:38:16,490 --> 00:38:20,999
errors what's cool about that is

00:38:19,589 --> 00:38:23,069
it actually lets you improve user

00:38:20,999 --> 00:38:24,269
experience very cheaply so instead of

00:38:23,069 --> 00:38:26,130
having to be like wait a minute did I

00:38:24,269 --> 00:38:27,809
try catch around that did I okay wait

00:38:26,130 --> 00:38:30,329
was this getting swallowed by that what

00:38:27,809 --> 00:38:31,589
happens here I'm not sure if you want to

00:38:30,329 --> 00:38:33,329
swallow an arrow you can do it on

00:38:31,589 --> 00:38:35,190
purpose you can make like a no op action

00:38:33,329 --> 00:38:36,479
it just does nothing that's fine but

00:38:35,190 --> 00:38:38,640
then it's very clear in your code

00:38:36,479 --> 00:38:39,900
explicitly that's a decision you'd make

00:38:38,640 --> 00:38:42,329
it's not a mistake that you potentially

00:38:39,900 --> 00:38:43,799
didn't step into it's like no okay I

00:38:42,329 --> 00:38:46,469
don't think we actually want to handle

00:38:43,799 --> 00:38:48,869
this error it makes it so much easier to

00:38:46,469 --> 00:38:50,579
make a nice user experience when you're

00:38:48,869 --> 00:38:52,170
reminded of error handling when some

00:38:50,579 --> 00:38:53,789
error handling is no longer something

00:38:52,170 --> 00:38:55,380
that you can forget and so we've

00:38:53,789 --> 00:38:55,890
benefited from this at no red ink where

00:38:55,380 --> 00:38:57,239
I work

00:38:55,890 --> 00:38:59,039
so we've started using element

00:38:57,239 --> 00:39:01,380
production we sort of swapped out react

00:38:59,039 --> 00:39:03,210
for it and ever since there ever since

00:39:01,380 --> 00:39:04,859
then not only has it been that we no

00:39:03,210 --> 00:39:06,719
longer get runtime exceptions from our

00:39:04,859 --> 00:39:08,339
own code but addition our user

00:39:06,719 --> 00:39:10,289
experience is actually notably improved

00:39:08,339 --> 00:39:12,119
because we found these spots where it's

00:39:10,289 --> 00:39:14,160
very clear that there's a potential

00:39:12,119 --> 00:39:15,630
error that could impact a user instead

00:39:14,160 --> 00:39:16,920
of just failing to handle it like we

00:39:15,630 --> 00:39:19,109
used to because there were just so many

00:39:16,920 --> 00:39:22,469
possible error states now it's like oh

00:39:19,109 --> 00:39:23,849
it's there and there and there that

00:39:22,469 --> 00:39:26,219
doesn't sound so bad so now we actually

00:39:23,849 --> 00:39:27,809
blog the errors or even better display

00:39:26,219 --> 00:39:29,910
something to the end-user if something

00:39:27,809 --> 00:39:31,950
is unrecoverable or if something is

00:39:29,910 --> 00:39:33,719
recoverable we can do both we can log an

00:39:31,950 --> 00:39:35,519
error and then restore the user to some

00:39:33,719 --> 00:39:37,079
sort of recovered State and just kind of

00:39:35,519 --> 00:39:38,369
continue on and give them at least some

00:39:37,079 --> 00:39:40,680
semblance of a reasonable user

00:39:38,369 --> 00:39:42,239
experience this is never an experience

00:39:40,680 --> 00:39:44,099
I've had before of having it where your

00:39:42,239 --> 00:39:46,079
compiler actually results in a better

00:39:44,099 --> 00:39:47,430
experience for your end user but just

00:39:46,079 --> 00:39:50,749
the fact that it's made things like this

00:39:47,430 --> 00:39:53,670
easier has definitely had that effect

00:39:50,749 --> 00:39:54,869
okay so in summary just combining the

00:39:53,670 --> 00:39:57,269
two things we looked at previously

00:39:54,869 --> 00:39:59,519
here's our new post to s3 implementation

00:39:57,269 --> 00:40:01,319
so let is a keyword in Elm

00:39:59,519 --> 00:40:03,450
unlike LED and JavaScript LED in Elm

00:40:01,319 --> 00:40:04,859
just means constant so you have let and

00:40:03,450 --> 00:40:06,839
in and basically everything in between

00:40:04,859 --> 00:40:09,269
LED and in is just scoped to right there

00:40:06,839 --> 00:40:10,739
it's very explicit about scope so we

00:40:09,269 --> 00:40:13,200
have our action task which is how we're

00:40:10,739 --> 00:40:15,210
mapping the tasks to turn it the success

00:40:13,200 --> 00:40:16,829
into a handle response action you have

00:40:15,210 --> 00:40:19,739
our never-failing task which is taking

00:40:16,829 --> 00:40:21,539
that action task and then mapping it so

00:40:19,739 --> 00:40:23,460
that we always get a log error in the

00:40:21,539 --> 00:40:27,900
case of failure and then we call FX that

00:40:23,460 --> 00:40:29,700
task passing that okay so we are one

00:40:27,900 --> 00:40:31,049
step removed from the Elm architecture

00:40:29,700 --> 00:40:33,039
which is something that people may have

00:40:31,049 --> 00:40:34,660
heard it's inspired

00:40:33,039 --> 00:40:36,519
Redux it's inspired a lot of different

00:40:34,660 --> 00:40:41,650
things let me tell you it definitely

00:40:36,519 --> 00:40:45,549
works the best in Elm so it's composed

00:40:41,650 --> 00:40:47,890
of three parts model view and update so

00:40:45,549 --> 00:40:50,319
model is just data it just represents

00:40:47,890 --> 00:40:52,749
your application state view takes the

00:40:50,319 --> 00:40:54,819
model as an argument and just returns a

00:40:52,749 --> 00:40:56,499
new representation of what you want the

00:40:54,819 --> 00:40:59,140
UI to look like so react

00:40:56,499 --> 00:40:59,709
ODOT 14 introduced stateless rendering

00:40:59,140 --> 00:41:01,630
components

00:40:59,709 --> 00:41:03,459
that's all Elms ever had and that's all

00:41:01,630 --> 00:41:05,140
l needs they're very simple it's just a

00:41:03,459 --> 00:41:07,239
function there is no component it's just

00:41:05,140 --> 00:41:09,429
literally taking the model and then a

00:41:07,239 --> 00:41:11,259
dispatcher to send actions to and then

00:41:09,429 --> 00:41:13,419
return a representation of what you want

00:41:11,259 --> 00:41:15,699
the UI to look like that's it your

00:41:13,419 --> 00:41:18,669
update function takes the model and then

00:41:15,699 --> 00:41:19,989
a list of or sorry it takes the model

00:41:18,669 --> 00:41:22,209
and then whatever action you want to

00:41:19,989 --> 00:41:24,279
apply to that model and it returns a new

00:41:22,209 --> 00:41:28,869
model as well as whatever effects you

00:41:24,279 --> 00:41:30,789
want done okay so here is run action

00:41:28,869 --> 00:41:32,769
translate it into the Elm architecture

00:41:30,789 --> 00:41:34,419
we've now renamed it to update because

00:41:32,769 --> 00:41:36,910
now it's doing both the effect and the

00:41:34,419 --> 00:41:39,009
model so it takes an action and the old

00:41:36,910 --> 00:41:39,459
model case action of that's the same as

00:41:39,009 --> 00:41:40,809
before

00:41:39,459 --> 00:41:43,269
post s3 that's the same as before

00:41:40,809 --> 00:41:45,039
construct our never-failing task as same

00:41:43,269 --> 00:41:46,959
as before except now we're returning

00:41:45,039 --> 00:41:49,029
something slightly different now we're

00:41:46,959 --> 00:41:50,769
returning a tuple so a tuple in Elm is

00:41:49,029 --> 00:41:52,719
basically like a fixed length array in

00:41:50,769 --> 00:41:54,429
JavaScript each position in the tuple

00:41:52,719 --> 00:41:57,009
can hold different types if you want it

00:41:54,429 --> 00:41:58,839
to but it's just fixed length so we're

00:41:57,009 --> 00:42:00,669
always returning exactly two things and

00:41:58,839 --> 00:42:01,929
that's enforced at compile time first

00:42:00,669 --> 00:42:03,609
thing we're returning is the new model

00:42:01,929 --> 00:42:05,169
that we want in this case we're just

00:42:03,609 --> 00:42:06,759
returning the same model as before but

00:42:05,169 --> 00:42:09,189
if we wanted to change the model and

00:42:06,759 --> 00:42:11,019
have it updated to a new state this is

00:42:09,189 --> 00:42:12,669
exactly where we do it and then of

00:42:11,019 --> 00:42:16,599
course the same thing as before if X dot

00:42:12,669 --> 00:42:18,909
tasks cool so this means that now in the

00:42:16,599 --> 00:42:20,829
Elm architecture state changes are also

00:42:18,909 --> 00:42:22,869
isolated and easy to test before and

00:42:20,829 --> 00:42:24,519
after you just call your update function

00:42:22,869 --> 00:42:26,109
passing your old model and then it's

00:42:24,519 --> 00:42:27,729
gonna return a new model in that tuple

00:42:26,109 --> 00:42:29,229
you just look at it and see what the new

00:42:27,729 --> 00:42:31,449
model was as a result of running that

00:42:29,229 --> 00:42:32,829
action super easy to test it's just as

00:42:31,449 --> 00:42:34,269
easy as any other stateless thing to

00:42:32,829 --> 00:42:35,589
test you don't need to mock out your

00:42:34,269 --> 00:42:37,359
stores and see what happens when this

00:42:35,589 --> 00:42:38,679
gets set or that gets set now just call

00:42:37,359 --> 00:42:42,369
the function look at what came out of it

00:42:38,679 --> 00:42:44,109
that's it okay and finally we have the

00:42:42,369 --> 00:42:46,660
view component this is how abused work

00:42:44,109 --> 00:42:48,220
in the Elm architecture or in Elm HTML

00:42:46,660 --> 00:42:49,570
you take two arguments the dispatcher is

00:42:48,220 --> 00:42:51,850
what determines where the actions get

00:42:49,570 --> 00:42:53,650
sent the model is the current model and

00:42:51,850 --> 00:42:55,120
you just render stuff you just return a

00:42:53,650 --> 00:42:56,920
representation of what you want the Dom

00:42:55,120 --> 00:42:58,780
to look like and then just like react

00:42:56,920 --> 00:42:59,800
does you've got this virtual Dom concept

00:42:58,780 --> 00:43:02,620
where it's going to very efficiently

00:42:59,800 --> 00:43:05,170
diff this between what it's got now and

00:43:02,620 --> 00:43:08,140
what it had previously and take care of

00:43:05,170 --> 00:43:09,940
making the minimal set of manual Dom

00:43:08,140 --> 00:43:11,410
updates necessary to reflect what you've

00:43:09,940 --> 00:43:14,440
requested on the screen for your end

00:43:11,410 --> 00:43:16,690
user so this is a div we've got a class

00:43:14,440 --> 00:43:18,070
called upload button we've got an

00:43:16,690 --> 00:43:19,090
onclick handler we've given the

00:43:18,070 --> 00:43:20,950
dispatcher that we want to send the

00:43:19,090 --> 00:43:23,320
action to those dispatchers are

00:43:20,950 --> 00:43:25,000
automatically wired in by a library that

00:43:23,320 --> 00:43:27,100
makes it so that they end up sending

00:43:25,000 --> 00:43:28,510
actions to your update function and in

00:43:27,100 --> 00:43:29,830
the action we want to send to it is

00:43:28,510 --> 00:43:31,480
upload resume which would be a new

00:43:29,830 --> 00:43:33,610
action we would add to our action Union

00:43:31,480 --> 00:43:36,040
type you've got the text in the button

00:43:33,610 --> 00:43:37,990
that says upload resume so user

00:43:36,040 --> 00:43:40,180
interactions are also actions affects

00:43:37,990 --> 00:43:42,130
your actions so everything we've done

00:43:40,180 --> 00:43:44,140
here is all using effects as data

00:43:42,130 --> 00:43:45,850
exactly the same way as we had before

00:43:44,140 --> 00:43:49,660
everything is perfectly stateless and

00:43:45,850 --> 00:43:52,000
totally easy to test okay so in summary

00:43:49,660 --> 00:43:53,920
Ilham architecture we've got raw data

00:43:52,000 --> 00:43:55,750
which is your model your update is just

00:43:53,920 --> 00:43:57,490
a function that takes an action and a

00:43:55,750 --> 00:43:59,350
model or it turns a tuple of the new

00:43:57,490 --> 00:44:00,760
model you want and any effects that you

00:43:59,350 --> 00:44:02,800
want done in addition to changing that

00:44:00,760 --> 00:44:05,410
model and you got a view which takes a

00:44:02,800 --> 00:44:08,050
dispatcher that points to the update

00:44:05,410 --> 00:44:09,370
function and your old model and just

00:44:08,050 --> 00:44:11,380
returned this HTML that you want the

00:44:09,370 --> 00:44:12,880
users to view you all just learn the Elm

00:44:11,380 --> 00:44:15,120
architecture give yourselves round of

00:44:12,880 --> 00:44:15,120
applause

00:44:19,630 --> 00:44:23,780
that's all there is to it

00:44:21,700 --> 00:44:25,910
okay if you'd like a complete tutorial

00:44:23,780 --> 00:44:27,800
of building something using us there's a

00:44:25,910 --> 00:44:29,240
blog post on our company blog building a

00:44:27,800 --> 00:44:31,340
live validated signup form in elm

00:44:29,240 --> 00:44:33,290
basically starts only assuming that you

00:44:31,340 --> 00:44:34,910
know JavaScript and takes you from start

00:44:33,290 --> 00:44:37,460
to finish building a live validated

00:44:34,910 --> 00:44:39,530
signup form that uses the LMR code

00:44:37,460 --> 00:44:42,260
texture and all this good stuff and does

00:44:39,530 --> 00:44:46,700
Ajax and effects and all that all right

00:44:42,260 --> 00:44:48,710
so to sum up what did this get us mock

00:44:46,700 --> 00:44:50,660
free testing we can actually write our

00:44:48,710 --> 00:44:52,070
tests all of our tests and test our

00:44:50,660 --> 00:44:53,600
whole application without writing any

00:44:52,070 --> 00:44:54,920
mocks at all it's great I haven't

00:44:53,600 --> 00:44:57,190
written any mocks since we started using

00:44:54,920 --> 00:45:00,020
Elm I don't miss them at all

00:44:57,190 --> 00:45:02,180
easier debugging when we're asking who

00:45:00,020 --> 00:45:03,830
caused this breakage who had this effect

00:45:02,180 --> 00:45:05,240
that we didn't expect we can really

00:45:03,830 --> 00:45:06,500
quickly narrow down the set of functions

00:45:05,240 --> 00:45:09,440
that could have possibly done that it's

00:45:06,500 --> 00:45:11,030
only the ones that return tasks and

00:45:09,440 --> 00:45:12,440
finally we have error handling you can

00:45:11,030 --> 00:45:14,390
never forget you can no longer have

00:45:12,440 --> 00:45:16,490
stuff gets swallowed and forget to deal

00:45:14,390 --> 00:45:18,290
with it it's always very explicit if you

00:45:16,490 --> 00:45:20,180
forget quote-unquote to handle an error

00:45:18,290 --> 00:45:21,650
it's because you deliberately made the

00:45:20,180 --> 00:45:23,450
choice of saying I want this to go to a

00:45:21,650 --> 00:45:27,320
no op action you can never do it

00:45:23,450 --> 00:45:31,810
accidentally so all of this is thanks to

00:45:27,320 --> 00:45:31,810
effects as data thanks very much

00:45:41,210 --> 00:45:45,960
boo let's look at some questions oh

00:45:43,620 --> 00:45:49,830
there's a lot of questions all right

00:45:45,960 --> 00:45:52,110
worried okay we still have like 15

00:45:49,830 --> 00:45:53,670
minutes left so sure all right

00:45:52,110 --> 00:45:56,130
what are the frustrations with Elm you

00:45:53,670 --> 00:45:59,610
aren't sharing with us okay so I would

00:45:56,130 --> 00:46:01,650
say that I'm a big fan of Elm obviously

00:45:59,610 --> 00:46:03,980
but it's not without drawbacks the first

00:46:01,650 --> 00:46:05,850
drawback is learning curve so Elm is

00:46:03,980 --> 00:46:08,010
significantly different than JavaScript

00:46:05,850 --> 00:46:09,300
it sort of has to be in order to be

00:46:08,010 --> 00:46:12,840
significantly better which I would say

00:46:09,300 --> 00:46:15,690
it is the learning curve is I would say

00:46:12,840 --> 00:46:17,970
pretty easy to get to overcome to get

00:46:15,690 --> 00:46:19,830
sort of like minimally productive the

00:46:17,970 --> 00:46:22,020
the example I can give of that is that

00:46:19,830 --> 00:46:24,180
we had someone her previous programming

00:46:22,020 --> 00:46:25,890
experience was she did three months at a

00:46:24,180 --> 00:46:28,440
JavaScript boot camp before that was not

00:46:25,890 --> 00:46:29,850
a programmer and this was she came to us

00:46:28,440 --> 00:46:30,990
this was her first programming job and

00:46:29,850 --> 00:46:33,080
in her first week she was writing

00:46:30,990 --> 00:46:35,760
production Elm so it's definitely doable

00:46:33,080 --> 00:46:37,170
but having said that getting over that

00:46:35,760 --> 00:46:38,790
hump from like being able to be

00:46:37,170 --> 00:46:40,290
productive versus being you know

00:46:38,790 --> 00:46:41,700
confident in it and comfortable with it

00:46:40,290 --> 00:46:43,320
it takes a while because you have a lot

00:46:41,700 --> 00:46:44,820
of things to relearn there are things

00:46:43,320 --> 00:46:46,680
where you're used to doing it one way

00:46:44,820 --> 00:46:48,480
with JavaScript with side effects and

00:46:46,680 --> 00:46:49,590
you go to reach for that an element it

00:46:48,480 --> 00:46:51,030
doesn't work because there are no side

00:46:49,590 --> 00:46:53,220
effects and you have this moment where

00:46:51,030 --> 00:46:54,930
you're like this isn't possible I can't

00:46:53,220 --> 00:46:56,130
do what I need to do and it turns out

00:46:54,930 --> 00:46:57,720
you can there's just a different way of

00:46:56,130 --> 00:46:59,760
doing it that you're not used to yet so

00:46:57,720 --> 00:47:01,710
certainly one of my early frustrations

00:46:59,760 --> 00:47:03,150
was I just had to relearn this toolbox

00:47:01,710 --> 00:47:04,260
I had this series of things where I

00:47:03,150 --> 00:47:05,790
would reach for and they wouldn't be

00:47:04,260 --> 00:47:07,320
there and I had to learn how to reach

00:47:05,790 --> 00:47:09,000
for the new thing and I think that's

00:47:07,320 --> 00:47:10,740
more true there in elm than you would

00:47:09,000 --> 00:47:13,560
find in other languages like Clojure

00:47:10,740 --> 00:47:15,180
script and things which have some of

00:47:13,560 --> 00:47:16,770
these functional ideas but which don't

00:47:15,180 --> 00:47:20,070
take them as far and as a consequence

00:47:16,770 --> 00:47:21,240
you don't have as much to relearn that

00:47:20,070 --> 00:47:24,210
would be the biggest thing the other

00:47:21,240 --> 00:47:26,130
frustration is that again because Elm is

00:47:24,210 --> 00:47:27,240
really serious about its guarantees the

00:47:26,130 --> 00:47:29,700
way that it interoperates with

00:47:27,240 --> 00:47:31,560
JavaScript is using this port system so

00:47:29,700 --> 00:47:33,660
ports basically treat JavaScript like a

00:47:31,560 --> 00:47:35,730
client-server relationship so instead of

00:47:33,660 --> 00:47:37,740
sharing code you just call it passing

00:47:35,730 --> 00:47:40,620
data and then get data back from it like

00:47:37,740 --> 00:47:42,210
a pub/sub system what that means is that

00:47:40,620 --> 00:47:43,530
whereas again I'm gonna use closure

00:47:42,210 --> 00:47:45,450
script because it's another functional

00:47:43,530 --> 00:47:46,800
language enclosure script you can just

00:47:45,450 --> 00:47:47,940
share code with JavaScript you can just

00:47:46,800 --> 00:47:49,470
say I want to take this JavaScript

00:47:47,940 --> 00:47:51,120
function I want to just call it you know

00:47:49,470 --> 00:47:51,700
you can't do that and elm what you have

00:47:51,120 --> 00:47:53,109
to do is you

00:47:51,700 --> 00:47:54,880
to set up sort of a client-server

00:47:53,109 --> 00:47:57,400
relationship with your JavaScript code

00:47:54,880 --> 00:47:59,230
and then all of that gets isolated so

00:47:57,400 --> 00:48:01,270
the upside of that is that your elm code

00:47:59,230 --> 00:48:03,040
no longer has to worry about all these

00:48:01,270 --> 00:48:05,500
guarantees stay in place but the

00:48:03,040 --> 00:48:06,609
downside is that now literally any time

00:48:05,500 --> 00:48:08,770
you want to interoperate with a

00:48:06,609 --> 00:48:10,630
JavaScript API it's as much work as

00:48:08,770 --> 00:48:12,160
talking to the server you have to send

00:48:10,630 --> 00:48:13,780
data to it and it gets gives you data

00:48:12,160 --> 00:48:16,510
back sometimes that data might be crazy

00:48:13,780 --> 00:48:18,040
you have to deal with that so that's

00:48:16,510 --> 00:48:20,470
more work and that was sort of like

00:48:18,040 --> 00:48:22,119
initially frustrating to deal with but

00:48:20,470 --> 00:48:23,650
now that I've gotten used to it honestly

00:48:22,119 --> 00:48:25,089
it's it's really not bad because we

00:48:23,650 --> 00:48:26,079
don't really use that many I think we

00:48:25,089 --> 00:48:29,800
use we use a date picker

00:48:26,079 --> 00:48:31,780
like a jQuery date picker we use a lunar

00:48:29,800 --> 00:48:33,880
day s for full-text indexing algo Lea

00:48:31,780 --> 00:48:35,230
and rollbar for error reporting and so

00:48:33,880 --> 00:48:36,609
those are like the only things that we

00:48:35,230 --> 00:48:38,260
actually interoperate with as far as

00:48:36,609 --> 00:48:39,550
JavaScript libraries so for each of

00:48:38,260 --> 00:48:41,770
those we have a port system that where

00:48:39,550 --> 00:48:44,440
we talk to it a little bit frustrating

00:48:41,770 --> 00:48:46,690
but overall I'd say it's worth it

00:48:44,440 --> 00:48:49,000
I think that's those are the two main

00:48:46,690 --> 00:48:50,410
ones maybe there's something else I'm

00:48:49,000 --> 00:48:53,800
not thinking of but hit me up on Twitter

00:48:50,410 --> 00:48:56,950
and I'll elaborate I guess all right

00:48:53,800 --> 00:48:58,780
other questions how often do you find

00:48:56,950 --> 00:49:00,760
yourself writing code just to satisfy

00:48:58,780 --> 00:49:03,420
the compiler writing code just to

00:49:00,760 --> 00:49:06,190
satisfy the compiler um basically never

00:49:03,420 --> 00:49:07,630
so Elm has type inference I'm assuming

00:49:06,190 --> 00:49:09,910
where this question is going is

00:49:07,630 --> 00:49:12,579
basically the frustration I used to have

00:49:09,910 --> 00:49:14,349
as a Java programmer so like I used to

00:49:12,579 --> 00:49:16,869
be a professional Java developer and I

00:49:14,349 --> 00:49:17,980
hated it and I left it and one of the

00:49:16,869 --> 00:49:19,210
things I hated most about it was that

00:49:17,980 --> 00:49:21,040
you had to write out your types for

00:49:19,210 --> 00:49:23,470
every damn thing so you had to be like

00:49:21,040 --> 00:49:25,030
this is a string and this is an INT and

00:49:23,470 --> 00:49:26,790
this is a list of a thing of a thing and

00:49:25,030 --> 00:49:29,560
every single time it was really annoying

00:49:26,790 --> 00:49:31,000
so elm you don't have to do that and so

00:49:29,560 --> 00:49:32,710
actually you may have noticed that none

00:49:31,000 --> 00:49:35,589
of my slides that i annotate anything

00:49:32,710 --> 00:49:37,180
with types in practice I actually like

00:49:35,589 --> 00:49:38,920
to annotate things with types in

00:49:37,180 --> 00:49:40,180
particular places just because of that

00:49:38,920 --> 00:49:42,880
debugging experience that I got

00:49:40,180 --> 00:49:44,589
previously so in a lot of cases if I'm

00:49:42,880 --> 00:49:45,910
debugging it's really nice to be able to

00:49:44,589 --> 00:49:48,099
scan through my code and be like ok wait

00:49:45,910 --> 00:49:49,300
who returns what you don't return a task

00:49:48,099 --> 00:49:51,069
and you don't and just having that one

00:49:49,300 --> 00:49:53,410
little line tells me that and it helps

00:49:51,069 --> 00:49:55,000
you narrow things down faster but it's

00:49:53,410 --> 00:49:56,589
an optional form of documentation the

00:49:55,000 --> 00:50:00,720
compiler will just infer things for you

00:49:56,589 --> 00:50:02,859
if you if you if you don't annotate them

00:50:00,720 --> 00:50:05,349
as far as how often I find myself

00:50:02,859 --> 00:50:06,759
writing code to do that so almost never

00:50:05,349 --> 00:50:08,259
how often do I find myself changing code

00:50:06,759 --> 00:50:10,299
just to satisfy the compiler all the

00:50:08,259 --> 00:50:11,859
time but that's because I screwed up and

00:50:10,299 --> 00:50:13,269
the compiler is saving me and I'm making

00:50:11,859 --> 00:50:14,890
the change because if I didn't make the

00:50:13,269 --> 00:50:16,720
change and it weren't compiled language

00:50:14,890 --> 00:50:20,339
it would have blown up at runtime so I

00:50:16,720 --> 00:50:22,779
definitely don't regret that time spent

00:50:20,339 --> 00:50:24,729
okay what about type systems for

00:50:22,779 --> 00:50:26,890
JavaScript can we add types gradually to

00:50:24,729 --> 00:50:29,549
an existing language without switching

00:50:26,890 --> 00:50:32,019
to a new one and have similar guarantees

00:50:29,549 --> 00:50:34,239
to an extent yeah I mean so you can have

00:50:32,019 --> 00:50:36,160
like typescript and flow certainly you

00:50:34,239 --> 00:50:38,410
can get better type safety out of those

00:50:36,160 --> 00:50:39,970
but I think kind of the point of this

00:50:38,410 --> 00:50:41,799
talk right as effects as data and

00:50:39,970 --> 00:50:43,569
obviously you get a completely different

00:50:41,799 --> 00:50:45,700
set of guarantees when you don't have

00:50:43,569 --> 00:50:48,339
side effects every single one of those

00:50:45,700 --> 00:50:50,170
languages has side effects so you can

00:50:48,339 --> 00:50:51,910
get type checking you can get that part

00:50:50,170 --> 00:50:53,200
where the wiring is now guaranteed to be

00:50:51,910 --> 00:50:54,609
correct where things are passing the

00:50:53,200 --> 00:50:56,559
right thing to other things but unless

00:50:54,609 --> 00:50:58,210
you actually have effects as data as

00:50:56,559 --> 00:51:00,009
this first-class notion of the language

00:50:58,210 --> 00:51:01,420
you still can't get the same debugging

00:51:00,009 --> 00:51:03,339
experience you still can't get the same

00:51:01,420 --> 00:51:05,369
easy testing experience and none of

00:51:03,339 --> 00:51:07,599
those languages are ever gonna have that

00:51:05,369 --> 00:51:09,789
what's the best way to start with Elm

00:51:07,599 --> 00:51:12,579
official site any particular book slash

00:51:09,789 --> 00:51:14,469
blog slash tutorial sure so the official

00:51:12,579 --> 00:51:15,969
site has a number of things I think for

00:51:14,469 --> 00:51:17,529
this crowd if you're all coming from a

00:51:15,969 --> 00:51:19,660
JavaScript background I would recommend

00:51:17,529 --> 00:51:20,979
that blog post building a live validated

00:51:19,660 --> 00:51:22,719
sign up form an elm just because it

00:51:20,979 --> 00:51:24,249
starts with JavaScript and gets you to

00:51:22,719 --> 00:51:25,630
building your first thing I've also

00:51:24,249 --> 00:51:27,969
heard really good things about Mike

00:51:25,630 --> 00:51:29,410
Clarks pragmatic studio tutorials on Elm

00:51:27,969 --> 00:51:30,880
people have said those are really good I

00:51:29,410 --> 00:51:34,960
haven't actually watched them but I've

00:51:30,880 --> 00:51:37,089
heard extremely good things and yeah I

00:51:34,960 --> 00:51:38,650
would say to start with those two also

00:51:37,089 --> 00:51:40,630
again hit me up on Twitter if you have

00:51:38,650 --> 00:51:44,140
questions because I'm reflexive about

00:51:40,630 --> 00:51:45,819
answering questions ok Elm looks

00:51:44,140 --> 00:51:48,130
powerful and promising but it seems to

00:51:45,819 --> 00:51:50,109
be very young sure should this be a

00:51:48,130 --> 00:51:51,400
concern how is the infrastructure around

00:51:50,109 --> 00:51:53,739
it these days

00:51:51,400 --> 00:51:56,829
yeah Elm is definitely young it should

00:51:53,739 --> 00:51:58,599
it be a concern I guess is up to you so

00:51:56,829 --> 00:51:59,979
from my perspective the elm code that

00:51:58,599 --> 00:52:02,469
we've written is basically the most

00:51:59,979 --> 00:52:04,329
reliable code on our site switching back

00:52:02,469 --> 00:52:05,739
from Elm to JavaScript would definitely

00:52:04,329 --> 00:52:07,210
be the risky thing to do like that would

00:52:05,739 --> 00:52:11,589
definitely make our codebase less

00:52:07,210 --> 00:52:12,579
reliable Elm was just very reliable it

00:52:11,589 --> 00:52:13,960
is young I would say the main

00:52:12,579 --> 00:52:15,460
consequence of it being young is just

00:52:13,960 --> 00:52:17,710
that the library ecosystem is less

00:52:15,460 --> 00:52:19,060
mature so fortunately we do have the

00:52:17,710 --> 00:52:20,650
port system we can interoperate

00:52:19,060 --> 00:52:21,970
javascript libraries so pretty much

00:52:20,650 --> 00:52:23,890
everything that we've run into where

00:52:21,970 --> 00:52:25,960
we're like this doesn't exist in LM yet

00:52:23,890 --> 00:52:27,970
we just fall back on using the version

00:52:25,960 --> 00:52:30,400
in JavaScript which has led to this kind

00:52:27,970 --> 00:52:32,020
of weird dynamic where like we had this

00:52:30,400 --> 00:52:33,550
assignment form it's like thousands of

00:52:32,020 --> 00:52:35,560
lines of code it's really complicated it

00:52:33,550 --> 00:52:37,150
does a lot of stuff and everybody on the

00:52:35,560 --> 00:52:39,460
team will tell you the same thing that

00:52:37,150 --> 00:52:41,380
they swear about is this damn jQuery

00:52:39,460 --> 00:52:42,550
datepicker that we interoperate with all

00:52:41,380 --> 00:52:44,050
the elm code with all this massive

00:52:42,550 --> 00:52:45,790
complexity is fine that's like that date

00:52:44,050 --> 00:52:47,440
picker like when does it throw these

00:52:45,790 --> 00:52:49,060
events what is it doing who designed

00:52:47,440 --> 00:52:50,920
this thing it's really annoying we've

00:52:49,060 --> 00:52:51,790
definitely thought about we initially we

00:52:50,920 --> 00:52:53,620
were like we're not gonna rewrite our

00:52:51,790 --> 00:52:55,720
own date picker who does that and then

00:52:53,620 --> 00:52:57,310
we were like we're getting closer and

00:52:55,720 --> 00:52:58,960
closer every day it's like it has like a

00:52:57,310 --> 00:53:00,730
few UX things the most date pickers

00:52:58,960 --> 00:53:02,380
don't have that we want or just like

00:53:00,730 --> 00:53:03,970
this close to just rewriting it in Elm

00:53:02,380 --> 00:53:06,670
because we just can't stand all the

00:53:03,970 --> 00:53:08,500
errors we get from it really annoying

00:53:06,670 --> 00:53:09,940
anyway so elements young library

00:53:08,500 --> 00:53:11,650
ecosystem not nearly as big as

00:53:09,940 --> 00:53:13,660
JavaScript obviously but you can still

00:53:11,650 --> 00:53:15,420
fall back on Java scripts for is so far

00:53:13,660 --> 00:53:17,860
everything that we've needed

00:53:15,420 --> 00:53:19,330
how do you do logging that's clearly a

00:53:17,860 --> 00:53:20,320
side effect yes definitely so that was

00:53:19,330 --> 00:53:23,350
one of the four things that I mentioned

00:53:20,320 --> 00:53:25,390
roll bar so roll bar is basically one of

00:53:23,350 --> 00:53:26,590
those services where you send it logging

00:53:25,390 --> 00:53:28,990
events and then it records them on a

00:53:26,590 --> 00:53:30,910
server so that's our most common port by

00:53:28,990 --> 00:53:32,800
far as talking to roll bar so whenever

00:53:30,910 --> 00:53:34,120
we have one of our actions that's

00:53:32,800 --> 00:53:35,890
basically in every single one of our

00:53:34,120 --> 00:53:37,900
update functions is called record error

00:53:35,890 --> 00:53:39,370
and it just describes what you want sent

00:53:37,900 --> 00:53:41,200
to roll bar and then we have that wired

00:53:39,370 --> 00:53:42,910
up to automatically send to roll bar so

00:53:41,200 --> 00:53:44,020
it's a very common thing for us to do is

00:53:42,910 --> 00:53:46,330
we'll write something like let's say

00:53:44,020 --> 00:53:48,250
we're going to do an ajax thing we will

00:53:46,330 --> 00:53:50,410
either unsuccess have an action that

00:53:48,250 --> 00:53:52,030
processes the success or on error we

00:53:50,410 --> 00:53:53,440
will give it one of those record error

00:53:52,030 --> 00:53:54,940
actions and we'll send it out to roll

00:53:53,440 --> 00:53:56,650
bar so it's actually really nice and

00:53:54,940 --> 00:53:58,270
readable because you basically see like

00:53:56,650 --> 00:53:59,980
literally okay on success here's what

00:53:58,270 --> 00:54:01,420
we're gonna do and on error we're gonna

00:53:59,980 --> 00:54:03,370
record it to roll bar so we're really

00:54:01,420 --> 00:54:04,840
confident that if that breaks in an

00:54:03,370 --> 00:54:08,530
unexpected way it's gonna get sent off

00:54:04,840 --> 00:54:11,590
to roll bar okay

00:54:08,530 --> 00:54:14,050
is it possible to render ALM app on

00:54:11,590 --> 00:54:15,010
server so Elm is I don't know why I

00:54:14,050 --> 00:54:18,070
guess there's something called

00:54:15,010 --> 00:54:19,480
ALM but like Elm is it not all caps I

00:54:18,070 --> 00:54:22,750
mean I guess I could be like loud about

00:54:19,480 --> 00:54:24,580
it um but just just to know it I see

00:54:22,750 --> 00:54:26,710
that a lot is it possible to render it

00:54:24,580 --> 00:54:27,550
on a server so in other words Universal

00:54:26,710 --> 00:54:30,820
I'm not gonna use the other word for

00:54:27,550 --> 00:54:31,600
that but Universal rendering no nobody's

00:54:30,820 --> 00:54:32,109
done that yet

00:54:31,600 --> 00:54:33,670
it

00:54:32,109 --> 00:54:35,920
really easy it's just that basically

00:54:33,670 --> 00:54:36,670
nobody in the community has like gotten

00:54:35,920 --> 00:54:38,109
around to it yet

00:54:36,670 --> 00:54:39,099
if someone wants to contribute that that

00:54:38,109 --> 00:54:41,140
would be awesome it's definitely

00:54:39,099 --> 00:54:42,640
technically feasible and easy to do it's

00:54:41,140 --> 00:54:44,410
just no one's done it yet

00:54:42,640 --> 00:54:45,969
same thing with react native is another

00:54:44,410 --> 00:54:48,189
thing we get asked about a lot does LM

00:54:45,969 --> 00:54:50,079
compile to react native not yet but

00:54:48,189 --> 00:54:51,339
again it's just because nobody actually

00:54:50,079 --> 00:54:52,329
downloads more of a knowledge gap where

00:54:51,339 --> 00:54:53,829
they're I don't think there's anybody in

00:54:52,329 --> 00:54:55,299
the Ellen community who is used react

00:54:53,829 --> 00:54:56,979
native enough to be able to do those

00:54:55,299 --> 00:54:58,479
bindings properly it would be great if

00:54:56,979 --> 00:55:02,319
somebody could because that would be

00:54:58,479 --> 00:55:04,779
really excellent do you run into any

00:55:02,319 --> 00:55:06,670
problems slash milestones when

00:55:04,779 --> 00:55:09,189
developing with elm or limitations

00:55:06,670 --> 00:55:10,329
alright when developing with elm besides

00:55:09,189 --> 00:55:15,729
having to think in a different paradigm

00:55:10,329 --> 00:55:17,049
um problems with limitations uh nothing

00:55:15,729 --> 00:55:18,130
I mean really it is just thinking in a

00:55:17,049 --> 00:55:19,059
different paradigm we certainly haven't

00:55:18,130 --> 00:55:21,670
run into anything that we couldn't

00:55:19,059 --> 00:55:23,979
express an elm or at least you know use

00:55:21,670 --> 00:55:26,289
a port I will say ok so a limitation

00:55:23,979 --> 00:55:28,359
would be that in some cases you run into

00:55:26,289 --> 00:55:30,130
these very weird corner cases where you

00:55:28,359 --> 00:55:31,660
want to do something weird like you want

00:55:30,130 --> 00:55:33,099
to just like do some hack where you want

00:55:31,660 --> 00:55:35,019
to just mutate something and just like

00:55:33,099 --> 00:55:36,549
you know it's a like kind of a horrible

00:55:35,019 --> 00:55:39,099
hack but that's just like the best tool

00:55:36,549 --> 00:55:40,630
for this job and then basically what you

00:55:39,099 --> 00:55:42,459
end up doing is you write a port and

00:55:40,630 --> 00:55:44,049
then the port does rather than calling

00:55:42,459 --> 00:55:46,179
out to some JavaScript library calls out

00:55:44,049 --> 00:55:47,499
to your little hack and and you've just

00:55:46,179 --> 00:55:49,029
got this one little like three line

00:55:47,499 --> 00:55:50,319
JavaScript function that's mutating like

00:55:49,029 --> 00:55:51,489
window dot something and you're just

00:55:50,319 --> 00:55:54,819
kind of like let us never speak of this

00:55:51,489 --> 00:55:55,390
again but it works you know it gets the

00:55:54,819 --> 00:55:58,299
job done

00:55:55,390 --> 00:55:59,619
so generally speaking whenever we've run

00:55:58,299 --> 00:56:01,839
into problems with limitations that's

00:55:59,619 --> 00:56:03,549
what we'll do but that's been extremely

00:56:01,839 --> 00:56:04,689
infrequent like basically overall the

00:56:03,549 --> 00:56:06,249
experience has just been we write a lot

00:56:04,689 --> 00:56:08,319
of elam code it's really nice it's

00:56:06,249 --> 00:56:10,119
really you know reliable and then we

00:56:08,319 --> 00:56:11,679
have a tiny little bit of you know

00:56:10,119 --> 00:56:16,269
calling outs of JavaScript libraries or

00:56:11,679 --> 00:56:18,279
calling out to a little hack okay uh-huh

00:56:16,269 --> 00:56:21,160
most of the actions and flux consists of

00:56:18,279 --> 00:56:23,380
beginning success failure a tuple in elm

00:56:21,160 --> 00:56:26,289
it seems to be good at caps leading that

00:56:23,380 --> 00:56:29,229
with tasks but can we do that in J yes

00:56:26,289 --> 00:56:30,429
yeah certainly I mean using the same

00:56:29,229 --> 00:56:31,929
techniques that I talked about in the

00:56:30,429 --> 00:56:33,579
first half of the presentation you can

00:56:31,929 --> 00:56:36,579
absolutely do the same effects as data

00:56:33,579 --> 00:56:38,199
conceptual stuff in JavaScript it's just

00:56:36,579 --> 00:56:40,569
that you don't get the same guarantees

00:56:38,199 --> 00:56:42,579
really so I would argue that what

00:56:40,569 --> 00:56:44,820
effects says data gets you as a concept

00:56:42,579 --> 00:56:47,310
is improved testable test

00:56:44,820 --> 00:56:49,140
and what it gets you from Elm is once

00:56:47,310 --> 00:56:50,340
you've already adopted that model as the

00:56:49,140 --> 00:56:51,840
first class thing that you're building

00:56:50,340 --> 00:56:53,400
your language around in addition to

00:56:51,840 --> 00:56:55,110
testability you get all these other

00:56:53,400 --> 00:56:56,270
benefits and the cost of course is

00:56:55,110 --> 00:57:01,410
having to learn to think in that way

00:56:56,270 --> 00:57:02,970
let's do one more one more okay does it

00:57:01,410 --> 00:57:04,920
take longer to develop an Elmer tsa's

00:57:02,970 --> 00:57:07,530
jail that's a great question versus j/s

00:57:04,920 --> 00:57:10,080
and react etcetera or is it a myth about

00:57:07,530 --> 00:57:11,430
ok about strong typing yeah so this is

00:57:10,080 --> 00:57:12,960
exactly what it's like we've talked

00:57:11,430 --> 00:57:14,400
about this on our team this is exactly

00:57:12,960 --> 00:57:15,690
what it feels like so let's say you're

00:57:14,400 --> 00:57:18,030
building a feature out over the course

00:57:15,690 --> 00:57:20,520
of like three months and the first like

00:57:18,030 --> 00:57:22,560
two or three weeks building it an elm is

00:57:20,520 --> 00:57:24,390
gonna be slower than building it in

00:57:22,560 --> 00:57:26,400
JavaScript or you know react would have

00:57:24,390 --> 00:57:28,470
been definitely the initial time like

00:57:26,400 --> 00:57:30,150
it's it's making your stuff more

00:57:28,470 --> 00:57:31,890
reliable by making you handle all of

00:57:30,150 --> 00:57:33,390
these error cases and things and like

00:57:31,890 --> 00:57:35,070
preventing you from forgetting that and

00:57:33,390 --> 00:57:36,660
in JavaScript you you're allowed to

00:57:35,070 --> 00:57:38,310
forget those things and you can just

00:57:36,660 --> 00:57:39,600
write the code and not have to write the

00:57:38,310 --> 00:57:41,820
code to handle those errors and things

00:57:39,600 --> 00:57:43,260
like that so the first like two or three

00:57:41,820 --> 00:57:44,820
weeks definitely javascript is the win

00:57:43,260 --> 00:57:46,230
and if you're honestly if I'm building a

00:57:44,820 --> 00:57:47,610
new prototype and I'm just hacking it

00:57:46,230 --> 00:57:49,200
together I'm not gonna like keep it

00:57:47,610 --> 00:57:50,790
around and maintain it I won't write an

00:57:49,200 --> 00:57:52,230
elm I will write it in JavaScript I'll

00:57:50,790 --> 00:57:53,460
use it right in jQuery honestly I'll

00:57:52,230 --> 00:57:54,870
just be like slap it together be like

00:57:53,460 --> 00:57:56,160
whatever the fastest thing to get a

00:57:54,870 --> 00:57:58,770
prototype on the screen so we can do

00:57:56,160 --> 00:57:59,940
user testing that's what I'll do if we

00:57:58,770 --> 00:58:01,590
want it to be maintained

00:57:59,940 --> 00:58:02,820
I'll always reach for Elm because over

00:58:01,590 --> 00:58:05,010
the course of those three months it's

00:58:02,820 --> 00:58:07,260
not even close like we will spend way

00:58:05,010 --> 00:58:08,370
less time on Elm like building out that

00:58:07,260 --> 00:58:09,840
feature over the course of three months

00:58:08,370 --> 00:58:10,860
than we would in JavaScript like I don't

00:58:09,840 --> 00:58:12,540
even have to think about that I know

00:58:10,860 --> 00:58:13,950
what the answer is so if you've got a

00:58:12,540 --> 00:58:15,690
really short time frame you're just

00:58:13,950 --> 00:58:16,650
banging out a prototype use JavaScript

00:58:15,690 --> 00:58:18,060
if you're writing something that's gonna

00:58:16,650 --> 00:58:19,980
be maintained over the long term Elm

00:58:18,060 --> 00:58:23,360
will definitely save you time Thanks

00:58:19,980 --> 00:58:23,360
thank you thank you so much

00:58:25,050 --> 00:58:27,110

YouTube URL: https://www.youtube.com/watch?v=6EdXaWfoslc


