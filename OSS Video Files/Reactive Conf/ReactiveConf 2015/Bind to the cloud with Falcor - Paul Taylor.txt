Title: Bind to the cloud with Falcor - Paul Taylor
Publication date: 2015-11-16
Playlist: ReactiveConf 2015
Description: 
	Imagine how easy building your web application would be if all of your data was available in-memory on the client. Falcor lets you to code that way. 

Falcor is the open-source, JS data access framework that powers Netflix. Falcor lets you represent all of your cloud data sources as one virtual JSON model on the server. On the client, Falcor makes it appear as if the entire JSON model is available locally and allows you to access data the same way you would from an in-memory JSON object. Falcor retrieves the model data you request from the cloud on-demand, transparently handling all the network communication and keeping the server and client in sync. 

Falcor is not a replacement for your MVC framework, your database, or your application server. Falcor fits seamlessly into your existing stack and lets the layers communicate more efficiently. 

Get an inside look at the innovative data platform that powers the Netflix UIs and the new UI design patterns it enables. Learn more how Falcor powers Netflix, and how you can integrate into your existing stack.

Paul is a consultant in San Francisco, CA, and former lead engineer on FalcorJS on Netflixâ€™sUI Platform team.
Captions: 
	00:00:04,259 --> 00:00:07,560
hi everybody

00:00:09,750 --> 00:00:16,410
alright so let's get started first of

00:00:14,549 --> 00:00:18,900
all I'd like to say thanks to all the

00:00:16,410 --> 00:00:20,599
conference organizers for inviting me to

00:00:18,900 --> 00:00:24,570
be here this is actually really special

00:00:20,599 --> 00:00:27,300
Falco is a project that i slaved good

00:00:24,570 --> 00:00:28,560
almost 2 years on so it's really cool to

00:00:27,300 --> 00:00:33,150
come and get that show it off to

00:00:28,560 --> 00:00:35,190
everybody before I get started my

00:00:33,150 --> 00:00:37,379
t-shirt right here I have a bunch of

00:00:35,190 --> 00:00:39,780
these and hoodies too so if anybody

00:00:37,379 --> 00:00:41,969
wants a really cool Falkor t-shirt or

00:00:39,780 --> 00:00:46,860
hoodie let me know because I'm not

00:00:41,969 --> 00:00:49,260
taking the back of the US my name is

00:00:46,860 --> 00:00:53,790
paul taylor on twitter you can find me

00:00:49,260 --> 00:00:56,309
at tier excellent with no vowels people

00:00:53,790 --> 00:00:59,789
think it's related to trick cereal and

00:00:56,309 --> 00:01:03,149
it's not I was a founding member of the

00:00:59,789 --> 00:01:06,570
UI platform team at Netflix and my first

00:01:03,149 --> 00:01:09,960
project was talk work so I guess let's

00:01:06,570 --> 00:01:13,020
get started so we started with the idea

00:01:09,960 --> 00:01:16,049
of Falkor with the observation that

00:01:13,020 --> 00:01:18,540
every user wants to believe that the

00:01:16,049 --> 00:01:21,060
entire cloud like all the data in the

00:01:18,540 --> 00:01:23,250
cloud is on their device users behave

00:01:21,060 --> 00:01:25,290
that way they constantly scratch at the

00:01:23,250 --> 00:01:30,840
screen until the data loads like we're

00:01:25,290 --> 00:01:32,850
really just impatient and that's fine so

00:01:30,840 --> 00:01:34,710
then we let ourselves oh well that's

00:01:32,850 --> 00:01:36,150
obviously not true you know we know

00:01:34,710 --> 00:01:38,939
that's not true but what if we could

00:01:36,150 --> 00:01:42,299
code as if it was true and that's where

00:01:38,939 --> 00:01:43,950
we started with Falkor but before

00:01:42,299 --> 00:01:46,610
actually I don't know what my notes

00:01:43,950 --> 00:01:46,610
aren't showing up

00:01:48,190 --> 00:01:57,730
so alright cool okay so going back in

00:01:55,150 --> 00:02:01,830
time a little bit even before I was in

00:01:57,730 --> 00:02:04,000
netflix we had the concept of rest and

00:02:01,830 --> 00:02:05,860
we asked ourselves like what's the most

00:02:04,000 --> 00:02:08,200
successful distributed system ever

00:02:05,860 --> 00:02:12,340
designed for browsing information and

00:02:08,200 --> 00:02:14,380
obviously it's the world wide web and

00:02:12,340 --> 00:02:21,960
now this isn't going forward so I'll

00:02:14,380 --> 00:02:24,730
just do it on my computer there we go

00:02:21,960 --> 00:02:26,550
and that's great because Netflix

00:02:24,730 --> 00:02:28,810
ultimately really is a browsing problem

00:02:26,550 --> 00:02:31,180
users just scroll through an endless

00:02:28,810 --> 00:02:32,740
library of movies for hours at a time

00:02:31,180 --> 00:02:35,980
trying to figure out what they want to

00:02:32,740 --> 00:02:39,910
watch and for a long time netflix had a

00:02:35,980 --> 00:02:44,500
restful api you pretty standard you you

00:02:39,910 --> 00:02:47,280
you know request movies or lists by ids

00:02:44,500 --> 00:02:51,070
and then the server returns of the data

00:02:47,280 --> 00:02:54,640
but the services weren't granular so as

00:02:51,070 --> 00:02:57,820
a netflix expanded and built more

00:02:54,640 --> 00:03:00,370
complex user interfaces we found we

00:02:57,820 --> 00:03:05,530
couldn't this wasn't flexible enough to

00:03:00,370 --> 00:03:06,459
build user interfaces efficiently so

00:03:05,530 --> 00:03:08,200
because we have sort of monolithic

00:03:06,459 --> 00:03:10,000
services that were doing you lots of

00:03:08,200 --> 00:03:11,830
json well what happens tomorrow if we

00:03:10,000 --> 00:03:13,239
introduce a new a/b test and half the

00:03:11,830 --> 00:03:16,600
users don't need that data well they're

00:03:13,239 --> 00:03:21,209
download again anyway so we we started

00:03:16,600 --> 00:03:24,519
building also that that's house of cards

00:03:21,209 --> 00:03:27,580
so we started breaking up our services

00:03:24,519 --> 00:03:29,410
into more granular services but then we

00:03:27,580 --> 00:03:31,420
got slammed with the idea that

00:03:29,410 --> 00:03:32,739
especially on mobile devices is a lot of

00:03:31,420 --> 00:03:36,280
latency especially on cellular

00:03:32,739 --> 00:03:40,959
connections you know just every every

00:03:36,280 --> 00:03:45,280
single network request you make has just

00:03:40,959 --> 00:03:47,470
some latency in the network and that's

00:03:45,280 --> 00:03:49,989
really an artifact of how HTTP was

00:03:47,470 --> 00:03:52,360
designed when it was designed it was the

00:03:49,989 --> 00:03:56,230
web was a place to to get things like

00:03:52,360 --> 00:04:00,250
documents and text files maybe small

00:03:56,230 --> 00:04:01,680
little executable but nowadays the web

00:04:00,250 --> 00:04:05,260
is a place to do

00:04:01,680 --> 00:04:09,760
we have web applications that will tend

00:04:05,260 --> 00:04:12,190
towards more granular services so web

00:04:09,760 --> 00:04:17,200
pages serve small amounts of large

00:04:12,190 --> 00:04:22,060
resources but web applications sort of

00:04:17,200 --> 00:04:24,490
large amounts of small resources so in

00:04:22,060 --> 00:04:27,790
2010 as we transitioned into being a

00:04:24,490 --> 00:04:30,880
more a service that was on more devices

00:04:27,790 --> 00:04:36,460
and everywhere much more dynamic Netflix

00:04:30,880 --> 00:04:38,440
is restful api became a restless api so

00:04:36,460 --> 00:04:40,150
we took all of our URLs that we had that

00:04:38,440 --> 00:04:41,590
used to be unique that the browser could

00:04:40,150 --> 00:04:45,310
just cash and we started to adding

00:04:41,590 --> 00:04:47,980
dynamic properties to them which the

00:04:45,310 --> 00:04:49,750
this is the the other great design

00:04:47,980 --> 00:04:53,290
pattern for distributed system is RPC

00:04:49,750 --> 00:04:55,450
remote procedure calls each different

00:04:53,290 --> 00:04:57,340
platform could say all right this this

00:04:55,450 --> 00:05:00,160
is my state this is the stuff that I

00:04:57,340 --> 00:05:04,120
care about but then we don't we don't

00:05:00,160 --> 00:05:06,460
end up with our unique URLs anymore then

00:05:04,120 --> 00:05:10,420
all of a sudden our resources aren't

00:05:06,460 --> 00:05:12,070
cached because the RPC you might be

00:05:10,420 --> 00:05:19,660
requesting for the same piece of

00:05:12,070 --> 00:05:23,170
information via a different URL so yeah

00:05:19,660 --> 00:05:25,030
same in same info two different URLs so

00:05:23,170 --> 00:05:26,350
what we wondered was what sort of

00:05:25,030 --> 00:05:28,690
programming model could give us the

00:05:26,350 --> 00:05:30,520
caching benefits of rest with the loose

00:05:28,690 --> 00:05:33,040
coupling that we get through you know

00:05:30,520 --> 00:05:34,600
HTTP redirects but then the small

00:05:33,040 --> 00:05:40,890
message sizes in the low latency is of

00:05:34,600 --> 00:05:46,360
RPC and that is where we got to Falkor

00:05:40,890 --> 00:05:49,410
get some water real quick really should

00:05:46,360 --> 00:05:49,410
have done this before the talk

00:05:54,460 --> 00:06:02,360
so Falkor what is it you know beyond a

00:05:58,880 --> 00:06:03,500
really cool name for a project well I'll

00:06:02,360 --> 00:06:05,150
tell you what it's not it's not a

00:06:03,500 --> 00:06:08,150
replacement for your database your MVC

00:06:05,150 --> 00:06:09,560
framework or your web server the awkward

00:06:08,150 --> 00:06:12,230
just fits into your existing stack

00:06:09,560 --> 00:06:13,520
without messing things up but it allows

00:06:12,230 --> 00:06:18,590
all the layers to communicate more

00:06:13,520 --> 00:06:21,200
efficiently so what we do with Falkor is

00:06:18,590 --> 00:06:24,230
it's a combination of a local client

00:06:21,200 --> 00:06:28,550
library that creates an in-memory cache

00:06:24,230 --> 00:06:34,220
and the idea of a big JSON object in the

00:06:28,550 --> 00:06:35,960
sky and effectively that JSON object

00:06:34,220 --> 00:06:38,660
bridges the gap between your client and

00:06:35,960 --> 00:06:40,490
your distributed systems everywhere if

00:06:38,660 --> 00:06:42,710
you know anything about Netflix it's a

00:06:40,490 --> 00:06:47,120
massively distributed architecture on

00:06:42,710 --> 00:06:49,840
the back end so but we don't want to

00:06:47,120 --> 00:06:55,850
burden the client with that information

00:06:49,840 --> 00:06:58,610
let's see so on the client side it gives

00:06:55,850 --> 00:07:00,830
you an async model an instance which you

00:06:58,610 --> 00:07:03,260
can do up and you can request data for

00:07:00,830 --> 00:07:06,520
just like you would if it was if you use

00:07:03,260 --> 00:07:08,480
rest but we saw with the same paradigms

00:07:06,520 --> 00:07:12,590
but you don't know that it's doing the

00:07:08,480 --> 00:07:14,090
catching for you the async model also

00:07:12,590 --> 00:07:16,130
allows you to execute remote function

00:07:14,090 --> 00:07:17,270
calls but in a way like function calls

00:07:16,130 --> 00:07:18,620
have side effects like if you add

00:07:17,270 --> 00:07:20,450
something to a list to remove something

00:07:18,620 --> 00:07:22,190
from a list you need to be able to

00:07:20,450 --> 00:07:25,750
communicate those side effects back to

00:07:22,190 --> 00:07:30,140
the cash through either invalidations or

00:07:25,750 --> 00:07:34,880
value updates so how does this work in

00:07:30,140 --> 00:07:36,530
practice so ideally the server

00:07:34,880 --> 00:07:38,360
implements at least it netflix the

00:07:36,530 --> 00:07:41,750
server implements what we call the

00:07:38,360 --> 00:07:43,550
Falkor router and the Falkor outer is

00:07:41,750 --> 00:07:45,830
that big virtual JSON object in the sky

00:07:43,550 --> 00:07:47,230
it doesn't exist it would be too big to

00:07:45,830 --> 00:07:49,880
hold in memory on any one machine

00:07:47,230 --> 00:07:51,560
because it's just tons and tons of

00:07:49,880 --> 00:07:55,490
information but we're going to pretend

00:07:51,560 --> 00:07:57,470
like it exists so the client when it

00:07:55,490 --> 00:08:00,070
when it's going to load up and it needs

00:07:57,470 --> 00:08:03,860
to render from it like render the view

00:08:00,070 --> 00:08:04,870
the client locally we'll ask it's a sink

00:08:03,860 --> 00:08:09,010
model for

00:08:04,870 --> 00:08:10,510
some small part of that cash the ASIC

00:08:09,010 --> 00:08:12,100
model knows it doesn't have it because

00:08:10,510 --> 00:08:15,270
it's cash is totally empty and it goes

00:08:12,100 --> 00:08:17,920
to the server and tries to get it back

00:08:15,270 --> 00:08:19,870
server says oh cool yeah here's this

00:08:17,920 --> 00:08:21,910
little piece of data here sends it down

00:08:19,870 --> 00:08:23,050
and the client can start in the cash and

00:08:21,910 --> 00:08:27,400
fulfill the request and render the

00:08:23,050 --> 00:08:28,570
rendered screen so then the user starts

00:08:27,400 --> 00:08:29,800
interacting with the application and

00:08:28,570 --> 00:08:31,690
they do something else that we need data

00:08:29,800 --> 00:08:33,040
for so we just do the same thing the

00:08:31,690 --> 00:08:35,230
cash goes and says all right cool give

00:08:33,040 --> 00:08:37,830
me that little piece of the cash and and

00:08:35,230 --> 00:08:40,420
then we can run to the next screen and

00:08:37,830 --> 00:08:44,050
lastly get this next one go into the

00:08:40,420 --> 00:08:46,420
movie details there and now we've got

00:08:44,050 --> 00:08:49,150
like some small part of our large Jason

00:08:46,420 --> 00:08:52,360
graph in this guy locally but what

00:08:49,150 --> 00:08:55,750
happens when we go back so if we at the

00:08:52,360 --> 00:08:58,540
back button and go to this screen again

00:08:55,750 --> 00:09:01,360
we making the request for the same piece

00:08:58,540 --> 00:09:02,440
of data we already got but the async

00:09:01,360 --> 00:09:03,550
mall smart enough to know that it

00:09:02,440 --> 00:09:08,710
doesn't have to go to the server to get

00:09:03,550 --> 00:09:09,520
it so it can fulfill the on the client

00:09:08,710 --> 00:09:12,340
side it can render the view

00:09:09,520 --> 00:09:19,260
synchronously without the view you

00:09:12,340 --> 00:09:23,070
having a change in code view road so

00:09:19,260 --> 00:09:25,090
what does netflix look like on Falkor

00:09:23,070 --> 00:09:28,780
doesn't look like an omelet I'll tell

00:09:25,090 --> 00:09:31,420
you that the netflix domain model is

00:09:28,780 --> 00:09:37,080
ultimately a list of lists it's just a

00:09:31,420 --> 00:09:39,850
list of lists they call it a lolla mo

00:09:37,080 --> 00:09:44,650
each list contains titles in each title

00:09:39,850 --> 00:09:47,440
has little bits of information about the

00:09:44,650 --> 00:09:48,940
movie that you're looking at but as you

00:09:47,440 --> 00:09:50,740
notice right here we see house of cards

00:09:48,940 --> 00:09:52,330
and it's actually in two different lists

00:09:50,740 --> 00:09:54,580
got house of cards and recently watched

00:09:52,330 --> 00:09:56,650
but also house of cards in new releases

00:09:54,580 --> 00:09:59,350
so we've got it you know some amount of

00:09:56,650 --> 00:10:01,210
duplication there but what really that

00:09:59,350 --> 00:10:05,710
means is Netflix is domain model isn't a

00:10:01,210 --> 00:10:07,330
tree it's a graph so here you see the

00:10:05,710 --> 00:10:11,890
same title friends in two different

00:10:07,330 --> 00:10:13,780
lists and on the server side really it's

00:10:11,890 --> 00:10:16,660
a graph but when we send it down to the

00:10:13,780 --> 00:10:18,390
client how do we like it's just json

00:10:16,660 --> 00:10:21,190
json as a tree

00:10:18,390 --> 00:10:24,960
how do we communicate that to the client

00:10:21,190 --> 00:10:24,960
that it's actually the same resource

00:10:25,230 --> 00:10:28,420
traditionally if you have a graph on the

00:10:27,130 --> 00:10:30,610
server which lots of people have graphs

00:10:28,420 --> 00:10:31,960
on the server and you need to

00:10:30,610 --> 00:10:36,010
communicate the graph down to the client

00:10:31,960 --> 00:10:40,420
you kind of have to serialize it into a

00:10:36,010 --> 00:10:44,110
tree and create duplicates give it AI DS

00:10:40,420 --> 00:10:47,440
of some sort send it down through the

00:10:44,110 --> 00:10:52,360
big cloud and then your UI has to

00:10:47,440 --> 00:10:53,950
somehow reconstruct the graph this gives

00:10:52,360 --> 00:10:55,240
you this is there's like two really big

00:10:53,950 --> 00:10:56,530
problems that this is the first is that

00:10:55,240 --> 00:10:58,870
you incur the network cost of

00:10:56,530 --> 00:11:01,110
duplicating data so for someone like

00:10:58,870 --> 00:11:04,360
Netflix who has a large server bill

00:11:01,110 --> 00:11:06,040
that's obviously problematic but also

00:11:04,360 --> 00:11:09,670
you incur the cost in the client side of

00:11:06,040 --> 00:11:14,440
all this complexity that why should you

00:11:09,670 --> 00:11:22,450
care it's not your problem or shouldn't

00:11:14,440 --> 00:11:25,180
be so oakley there we go so Jason graph

00:11:22,450 --> 00:11:26,560
Jason graph is this just idea that

00:11:25,180 --> 00:11:30,430
really is the secret sauce that powers

00:11:26,560 --> 00:11:32,470
Falkor it allows Falco to do the

00:11:30,430 --> 00:11:36,010
intelligent caching batching and

00:11:32,470 --> 00:11:39,790
duplicating requests so on the server

00:11:36,010 --> 00:11:42,340
side if if we had our entire Jason model

00:11:39,790 --> 00:11:43,990
in memory then we wouldn't have anything

00:11:42,340 --> 00:11:47,110
to worry about but since we can't have

00:11:43,990 --> 00:11:51,690
that we create the idea of a Jason model

00:11:47,110 --> 00:11:57,790
in the server and hide it behind our

00:11:51,690 --> 00:11:59,140
hide it behind our Falkor router so

00:11:57,790 --> 00:12:01,690
having factor on the server gives you

00:11:59,140 --> 00:12:04,080
the caching benefits of rest so that the

00:12:01,690 --> 00:12:07,270
client doesn't have to make duplicates

00:12:04,080 --> 00:12:10,000
the client can make small requests as it

00:12:07,270 --> 00:12:14,740
needs and and have this request batched

00:12:10,000 --> 00:12:16,300
up so it's actually using kinds of one

00:12:14,740 --> 00:12:17,890
of the features of HTTP is that you get

00:12:16,300 --> 00:12:20,290
lots of data all in one like Falco would

00:12:17,890 --> 00:12:22,900
match that up and make multiple requests

00:12:20,290 --> 00:12:25,450
in the same same go and then it also

00:12:22,900 --> 00:12:29,680
supports function calls so in this sort

00:12:25,450 --> 00:12:31,720
of straw man user interface model right

00:12:29,680 --> 00:12:34,100
here if we have some sort of control

00:12:31,720 --> 00:12:36,200
that's going to broker communication for

00:12:34,100 --> 00:12:37,940
the view the view doesn't know or care

00:12:36,200 --> 00:12:40,610
like where it date where its data lives

00:12:37,940 --> 00:12:46,820
it just knows it's going to get some and

00:12:40,610 --> 00:12:48,890
then render its pixels the Falkor model

00:12:46,820 --> 00:12:51,320
sits on the client and the controller

00:12:48,890 --> 00:12:53,570
just asks it for some data whenever it

00:12:51,320 --> 00:12:56,030
give whenever the Falco model eventually

00:12:53,570 --> 00:12:58,220
resolved gives the data back to the

00:12:56,030 --> 00:13:00,350
controller and the view is just saying

00:12:58,220 --> 00:13:02,360
all right it's if you're using

00:13:00,350 --> 00:13:05,510
observables it's really easy this is an

00:13:02,360 --> 00:13:09,580
example using angular 2 you can just

00:13:05,510 --> 00:13:09,580
drop them straight into your template

00:13:11,410 --> 00:13:19,970
let's see so the pads that we create

00:13:15,530 --> 00:13:21,800
conceptually are restful they're they're

00:13:19,970 --> 00:13:24,890
based on unique IDs there are references

00:13:21,800 --> 00:13:28,760
along the way that allow us to do path

00:13:24,890 --> 00:13:29,990
optimization but we we use our PC to

00:13:28,760 --> 00:13:33,620
send over because we use an existing

00:13:29,990 --> 00:13:35,810
network transfer protocol so the browser

00:13:33,620 --> 00:13:38,000
actually can't cash our requests we have

00:13:35,810 --> 00:13:43,640
to do all the caching which is fine it's

00:13:38,000 --> 00:13:45,190
it's really not that bad so the server

00:13:43,640 --> 00:13:47,720
sends us down this little piece of data

00:13:45,190 --> 00:13:51,580
the controller sends it down into the

00:13:47,720 --> 00:13:54,500
view the view gives us some HTML and

00:13:51,580 --> 00:13:57,680
that's the story of how Netflix is able

00:13:54,500 --> 00:13:59,420
to share the same data model across

00:13:57,680 --> 00:14:03,520
radically different user interfaces and

00:13:59,420 --> 00:14:03,520
platforms thanks

00:14:09,090 --> 00:14:20,520
now i know i finished kind of early but

00:14:13,780 --> 00:14:28,140
i'm happy to answer any questions all

00:14:20,520 --> 00:14:32,020
right I'm gonna go with anonymous first

00:14:28,140 --> 00:14:33,310
because I can see Andres Tolson how does

00:14:32,020 --> 00:14:36,370
talk work compared to relay and graphic

00:14:33,310 --> 00:14:38,170
you well it's really interesting when

00:14:36,370 --> 00:14:40,900
when we were building Falkor we had a

00:14:38,170 --> 00:14:42,670
few meetings with the graph ql team just

00:14:40,900 --> 00:14:47,620
to person what we were doing here what

00:14:42,670 --> 00:14:51,610
they're doing Falkor is really the idea

00:14:47,620 --> 00:14:53,500
of how r is what do we need like what

00:14:51,610 --> 00:14:56,080
are the minimum set of like operations

00:14:53,500 --> 00:14:58,420
and things we need to make working with

00:14:56,080 --> 00:14:59,800
adjacent objects on another machine feel

00:14:58,420 --> 00:15:03,340
like we're working with the Jason object

00:14:59,800 --> 00:15:05,860
on our local machine the data is the API

00:15:03,340 --> 00:15:07,540
so Falkor isn't doing things that

00:15:05,860 --> 00:15:10,930
JavaScript wouldn't normally do so in

00:15:07,540 --> 00:15:14,050
JavaScript you don't have comprehension

00:15:10,930 --> 00:15:15,430
zor predicates you know you have to drop

00:15:14,050 --> 00:15:19,300
down actually do programming stuff with

00:15:15,430 --> 00:15:20,950
that you can't just create queries so we

00:15:19,300 --> 00:15:22,600
didn't try to write a query language we

00:15:20,950 --> 00:15:26,800
wrote kind of a DSL that allows you to

00:15:22,600 --> 00:15:30,550
describe how you might retrieve lots of

00:15:26,800 --> 00:15:34,510
data in a single array for example if we

00:15:30,550 --> 00:15:35,950
wanted to retrieve 50 movies but we

00:15:34,510 --> 00:15:39,040
wanted to retrieve them by index we

00:15:35,950 --> 00:15:41,560
didn't know their ID yet we needed to

00:15:39,040 --> 00:15:45,490
render a list that was 50 long rather

00:15:41,560 --> 00:15:47,890
than send an array of integers from 0 to

00:15:45,490 --> 00:15:49,750
50 to the server we just said alright

00:15:47,890 --> 00:15:51,850
well we'll standardized a little object

00:15:49,750 --> 00:15:54,070
that has a from in a tube so we can say

00:15:51,850 --> 00:15:57,910
from 0 to 50 and that kind of just says

00:15:54,070 --> 00:16:01,060
compression right there that's about the

00:15:57,910 --> 00:16:04,320
extent of the sort of DSL or query

00:16:01,060 --> 00:16:11,710
language that we implemented for pat's I

00:16:04,320 --> 00:16:14,260
have no idea how graph ql expects to be

00:16:11,710 --> 00:16:15,820
able to you know predict that they can

00:16:14,260 --> 00:16:18,430
retrieve data from cash whenever they've

00:16:15,820 --> 00:16:20,290
got dynamic predicates but they're also

00:16:18,430 --> 00:16:21,209
a lot smarter than me so they probably

00:16:20,290 --> 00:16:28,970
know the

00:16:21,209 --> 00:16:28,970
sir is that sufficient for everybody

00:16:29,389 --> 00:16:35,550
Andre so Netflix is mostly a read only

00:16:33,720 --> 00:16:36,990
or browsing experience how does it

00:16:35,550 --> 00:16:43,470
perform in cases where reads are as

00:16:36,990 --> 00:16:45,689
often as rights so I think it's a common

00:16:43,470 --> 00:16:49,019
misconception that Netflix is a browsing

00:16:45,689 --> 00:16:50,399
experience you might be surprised to

00:16:49,019 --> 00:16:57,990
learn there's a lot of writing happening

00:16:50,399 --> 00:17:01,499
too maybe it's just not user users you

00:16:57,990 --> 00:17:03,420
know causing the actions to occur so

00:17:01,499 --> 00:17:05,039
when enough in the car when you set

00:17:03,420 --> 00:17:08,309
something you set a value through the

00:17:05,039 --> 00:17:09,929
cash 1st we said it locally then we

00:17:08,309 --> 00:17:11,779
bundle up that set we communicate it

00:17:09,929 --> 00:17:14,429
back to the server but there's a special

00:17:11,779 --> 00:17:15,990
protocol the server can say not you're

00:17:14,429 --> 00:17:18,720
wrong because we might have concurrent

00:17:15,990 --> 00:17:19,980
rights or we might have some some

00:17:18,720 --> 00:17:22,500
information out of change in the server

00:17:19,980 --> 00:17:23,970
and now you know that user their credit

00:17:22,500 --> 00:17:26,579
cards declined or they're not authorized

00:17:23,970 --> 00:17:31,649
anymore so the server can always send us

00:17:26,579 --> 00:17:37,740
back the it's the source of truth in a

00:17:31,649 --> 00:17:40,020
sense so it performs pretty well

00:17:37,740 --> 00:17:43,049
actually in cases where I'd say reading

00:17:40,020 --> 00:17:46,049
and writing are about equal and you can

00:17:43,049 --> 00:17:48,960
use it sort of an immutable store there

00:17:46,049 --> 00:17:51,029
there's some new UI work being done in

00:17:48,960 --> 00:17:53,520
netflix to use Valcourt as an immutable

00:17:51,029 --> 00:17:55,440
store for well it's not technically

00:17:53,520 --> 00:17:59,429
immutable but it reports to you the

00:17:55,440 --> 00:18:00,990
results as if it was immutable as a

00:17:59,429 --> 00:18:05,640
store for your you know react

00:18:00,990 --> 00:18:10,440
application state cache invalidation

00:18:05,640 --> 00:18:13,140
cool this is yeah these questions are

00:18:10,440 --> 00:18:15,059
more in line with with what I did

00:18:13,140 --> 00:18:16,440
because I wrote the internals so cache

00:18:15,059 --> 00:18:21,110
invalidation is really near and dear to

00:18:16,440 --> 00:18:24,240
my heart so with cash with core values

00:18:21,110 --> 00:18:25,830
values can have metadata we respect just

00:18:24,240 --> 00:18:27,929
a few little pieces of metadata that we

00:18:25,830 --> 00:18:29,460
built in features for but you can add

00:18:27,929 --> 00:18:31,409
your own meta data

00:18:29,460 --> 00:18:34,890
and do special stuff of it if you want

00:18:31,409 --> 00:18:38,940
but specifically we have what's known as

00:18:34,890 --> 00:18:40,890
time stamps so you can say all right the

00:18:38,940 --> 00:18:42,390
value on the server is newer than the

00:18:40,890 --> 00:18:43,770
die on the client or vice versa the

00:18:42,390 --> 00:18:47,000
value on the server's older than the

00:18:43,770 --> 00:18:49,380
client we actually have that problem on

00:18:47,000 --> 00:18:51,779
TVs when you're you're you're like

00:18:49,380 --> 00:18:54,690
watching a movie and you've like fast

00:18:51,779 --> 00:18:55,980
forwarded your bookmark on the TV is

00:18:54,690 --> 00:19:00,299
about eight minutes ahead of the

00:18:55,980 --> 00:19:03,390
bookmark on the server so if you were to

00:19:00,299 --> 00:19:05,100
watch a movie store your place leave the

00:19:03,390 --> 00:19:06,870
movie come back within 8 minutes and

00:19:05,100 --> 00:19:09,720
watch it the server would tell us that

00:19:06,870 --> 00:19:11,100
you're where you were you know when it

00:19:09,720 --> 00:19:12,510
lasts me to valuate minutes again not

00:19:11,100 --> 00:19:16,409
where you actually were when you stop

00:19:12,510 --> 00:19:18,330
playing the movie so what we do in cases

00:19:16,409 --> 00:19:21,750
like that as we tell the server now

00:19:18,330 --> 00:19:24,929
we've got a newer timestamp than you but

00:19:21,750 --> 00:19:27,120
conversely we also have value expiry so

00:19:24,929 --> 00:19:29,730
you can set an expiry metadata say

00:19:27,120 --> 00:19:33,899
expires at an absolute time expires

00:19:29,730 --> 00:19:35,220
let's say 5 p.m. today so when the cash

00:19:33,899 --> 00:19:37,590
is going through and reading things if

00:19:35,220 --> 00:19:39,750
something is expired it's older then it

00:19:37,590 --> 00:19:41,039
just it treats it if as if as if as if

00:19:39,750 --> 00:19:44,159
it wasn't there and tries to go and get

00:19:41,039 --> 00:19:47,429
it again you can also say expires with a

00:19:44,159 --> 00:19:50,669
relative time so you can say this thing

00:19:47,429 --> 00:19:54,779
expires 30 seconds from now no matter

00:19:50,669 --> 00:19:56,610
what time of day it is and then lastly

00:19:54,779 --> 00:19:58,470
there's a manual cache invalidation way

00:19:56,610 --> 00:20:00,450
so you can take your model and you can

00:19:58,470 --> 00:20:02,159
say just blow these things away get rid

00:20:00,450 --> 00:20:05,909
of them and it'll just completely clean

00:20:02,159 --> 00:20:10,279
them up and also because Valcour works

00:20:05,909 --> 00:20:13,500
under memory constrained devices

00:20:10,279 --> 00:20:16,919
whenever the router sorry the model

00:20:13,500 --> 00:20:18,899
keeps track somewhat of its size and if

00:20:16,919 --> 00:20:21,779
you give it a max sighs it'll you know

00:20:18,899 --> 00:20:24,510
start kicking things out as best it can

00:20:21,779 --> 00:20:26,279
if it starts going over that size which

00:20:24,510 --> 00:20:28,020
should be all right because if something

00:20:26,279 --> 00:20:29,309
goes out of the cash next time you

00:20:28,020 --> 00:20:32,029
request it we can just go back and get

00:20:29,309 --> 00:20:32,029
it again from the server

00:20:33,710 --> 00:20:41,580
so pagination lazy loading so on we

00:20:39,360 --> 00:20:45,030
don't have sort of a native

00:20:41,580 --> 00:20:50,040
implementation of lists or pagination we

00:20:45,030 --> 00:20:52,820
have kind of a sort of a standard or

00:20:50,040 --> 00:20:56,880
convention that we use for lists

00:20:52,820 --> 00:21:00,420
essentially in Jason you could treat an

00:20:56,880 --> 00:21:03,120
object that has keys 0 1 2 3 4 and a

00:21:00,420 --> 00:21:07,020
length of five as if that map were a

00:21:03,120 --> 00:21:08,910
list so typically when we have a list of

00:21:07,020 --> 00:21:12,120
things like a you know one of our lists

00:21:08,910 --> 00:21:14,850
of lists we can say first all right cool

00:21:12,120 --> 00:21:17,070
give me the length of that thing and so

00:21:14,850 --> 00:21:19,559
I know the total length and then make a

00:21:17,070 --> 00:21:21,240
follow-up requested say well I don't

00:21:19,559 --> 00:21:23,640
need you know all of those things I just

00:21:21,240 --> 00:21:25,350
need the first 15 and as you're

00:21:23,640 --> 00:21:28,740
scrolling can just keep making more

00:21:25,350 --> 00:21:31,110
requests to the server that might change

00:21:28,740 --> 00:21:35,760
sometime in the future but for now

00:21:31,110 --> 00:21:39,690
that's that's the convention optimistic

00:21:35,760 --> 00:21:42,450
updates does this whoever asked this

00:21:39,690 --> 00:21:45,450
question you mean push push data like

00:21:42,450 --> 00:21:48,809
push notifications and and value

00:21:45,450 --> 00:21:50,960
streamed to you or what's the context

00:21:48,809 --> 00:21:50,960
for that

00:21:59,390 --> 00:22:06,990
yes yeah so we optimistic of this we we

00:22:04,679 --> 00:22:09,539
called that optimistic concurrency so if

00:22:06,990 --> 00:22:12,840
if you do a set like on something you

00:22:09,539 --> 00:22:14,490
set some data in the cache we until we

00:22:12,840 --> 00:22:17,880
hear back otherwise we'll pretend like

00:22:14,490 --> 00:22:19,710
it succeeded you also run into some

00:22:17,880 --> 00:22:21,899
interesting problems where let's say I

00:22:19,710 --> 00:22:23,669
do a get for a large list of pads I'm

00:22:21,899 --> 00:22:26,309
going to get the movies for you know the

00:22:23,669 --> 00:22:28,169
first ten lists and the 75 movies in

00:22:26,309 --> 00:22:30,450
there but let's say I'm on a memory

00:22:28,169 --> 00:22:32,669
constrained device I might get some of

00:22:30,450 --> 00:22:35,100
that data merge it into cash kick some

00:22:32,669 --> 00:22:36,750
of it out and then not have it by the

00:22:35,100 --> 00:22:38,490
time like I might be waiting on multiple

00:22:36,750 --> 00:22:43,890
requests I might have had to split that

00:22:38,490 --> 00:22:45,330
request across or split that that yeah

00:22:43,890 --> 00:22:47,340
the requests are paths across different

00:22:45,330 --> 00:22:48,720
network requests so we have this problem

00:22:47,340 --> 00:22:51,570
where we have to figure out constantly

00:22:48,720 --> 00:22:53,010
all right did we kick some data out of

00:22:51,570 --> 00:22:54,350
the cash that we really need now and so

00:22:53,010 --> 00:22:56,990
now we have to go back and get it again

00:22:54,350 --> 00:23:06,240
but eventually all kind of settles and

00:22:56,990 --> 00:23:09,179
we have all the data we need Developer

00:23:06,240 --> 00:23:15,960
Preview we use the word Developer

00:23:09,179 --> 00:23:20,250
Preview because really it was me Jaffer

00:23:15,960 --> 00:23:21,840
and Michael and jophur you know who's

00:23:20,250 --> 00:23:23,700
architecting it and didn't really coat

00:23:21,840 --> 00:23:26,610
it so it was it was kind of just two of

00:23:23,700 --> 00:23:33,390
us and we didn't really want to take the

00:23:26,610 --> 00:23:34,770
heat if anybody got into trouble now i'm

00:23:33,390 --> 00:23:37,770
not at netflix anymore in michael's on

00:23:34,770 --> 00:23:39,600
paternity leave so we've got some some

00:23:37,770 --> 00:23:41,360
actually some other really good people

00:23:39,600 --> 00:23:43,679
working on it but they're ramping up

00:23:41,360 --> 00:23:45,179
Developer Preview will eventually go

00:23:43,679 --> 00:23:49,950
away but I can't say when because I

00:23:45,179 --> 00:23:51,539
don't work there anymore but i can say

00:23:49,950 --> 00:23:53,220
absolutely it's in a production-ready

00:23:51,539 --> 00:23:54,419
state we've been using it the new

00:23:53,220 --> 00:23:57,809
netflix you I that launched last

00:23:54,419 --> 00:23:59,270
Christmas the new TV app that's

00:23:57,809 --> 00:24:01,559
launching the new phone and tablet

00:23:59,270 --> 00:24:03,870
there's a version of Falkor working in

00:24:01,559 --> 00:24:06,149
objective-c that we expect to open

00:24:03,870 --> 00:24:09,419
source last I knew there's a java client

00:24:06,149 --> 00:24:10,500
that I think just got open sourced so as

00:24:09,419 --> 00:24:11,970
far as like

00:24:10,500 --> 00:24:13,830
production ready Netflix is using it and

00:24:11,970 --> 00:24:16,980
that's why we didn't even want to

00:24:13,830 --> 00:24:20,520
release it before it was you're running

00:24:16,980 --> 00:24:23,910
in all of our you eyes so that's kind of

00:24:20,520 --> 00:24:26,010
how we did things some kind of support

00:24:23,910 --> 00:24:30,240
for a minute yes managing permissions

00:24:26,010 --> 00:24:33,630
yes on the Falkor router there's an

00:24:30,240 --> 00:24:35,940
authorization you can off you can only

00:24:33,630 --> 00:24:37,920
be authorized for certain pads there's a

00:24:35,940 --> 00:24:39,450
way that you can configure that and if

00:24:37,920 --> 00:24:41,970
you're not authorized and it'll send

00:24:39,450 --> 00:24:46,350
back errors to the cash on the client

00:24:41,970 --> 00:24:54,390
and you can handle those errors if you

00:24:46,350 --> 00:24:55,920
need to we get live updates maybe I can

00:24:54,390 --> 00:24:57,270
tell you that there's some saw amount of

00:24:55,920 --> 00:24:58,920
it that will have to rip out to do that

00:24:57,270 --> 00:25:03,720
but I thought about doing it last

00:24:58,920 --> 00:25:06,750
weekend so maybe it's open source we can

00:25:03,720 --> 00:25:08,310
all work on it I was awkward different I

00:25:06,750 --> 00:25:13,250
have no idea how far is different from

00:25:08,310 --> 00:25:13,250
meteors DDP I have no idea about that i

00:25:14,210 --> 00:25:19,050
do see advantages using service workers

00:25:17,040 --> 00:25:21,960
in a networking caching layer we

00:25:19,050 --> 00:25:26,880
actually experimented with that on iOS

00:25:21,960 --> 00:25:30,390
and it worked really well i think it

00:25:26,880 --> 00:25:32,670
only worked if we were able to get our

00:25:30,390 --> 00:25:36,800
data as binary data and pass it back

00:25:32,670 --> 00:25:42,900
because it's always doing copies across

00:25:36,800 --> 00:25:44,610
threads but it was very very fast oh so

00:25:42,900 --> 00:25:47,520
why does far away that much because it

00:25:44,610 --> 00:25:49,710
currently has RX in it and it's not

00:25:47,520 --> 00:25:52,680
going to have our X in it in a little

00:25:49,710 --> 00:25:55,770
while and I think we brought the size

00:25:52,680 --> 00:26:00,240
down to something like 68 k and maybe

00:25:55,770 --> 00:26:04,320
less with we mean honestly it was two

00:26:00,240 --> 00:26:06,510
years of like going really really hard

00:26:04,320 --> 00:26:11,460
and also everything changing all the

00:26:06,510 --> 00:26:13,590
time so there's a lot of legacy at least

00:26:11,460 --> 00:26:16,940
that I know about and some of that is

00:26:13,590 --> 00:26:16,940
that we just used our X internally

00:26:19,660 --> 00:26:23,620
so no it does not mean you have to model

00:26:22,310 --> 00:26:26,450
your data as a graph on the server

00:26:23,620 --> 00:26:28,550
there's actually and for I guess I

00:26:26,450 --> 00:26:31,490
should if you go to Netflix that github

00:26:28,550 --> 00:26:33,440
daya visage Falkor you can see all of

00:26:31,490 --> 00:26:36,850
the demos and examples there's there's

00:26:33,440 --> 00:26:39,710
one called the Falkor Express demo that

00:26:36,850 --> 00:26:40,820
specifically uses pouch DB because it

00:26:39,710 --> 00:26:43,070
doesn't really need to be deployed but

00:26:40,820 --> 00:26:46,490
you can just run it locally and and see

00:26:43,070 --> 00:26:51,500
how you could implement a router you

00:26:46,490 --> 00:26:53,420
know and calling in the databases it's

00:26:51,500 --> 00:26:54,950
that that's exactly the idea is that you

00:26:53,420 --> 00:26:56,450
transform it on the fly before sending

00:26:54,950 --> 00:27:00,050
it it's like your server doesn't have to

00:26:56,450 --> 00:27:04,450
know or care you just put it in a format

00:27:00,050 --> 00:27:04,450
that the client can efficiently catch it

00:27:04,750 --> 00:27:11,750
yes it is ready to work over HTTP two so

00:27:09,710 --> 00:27:13,310
Falkor models have a data source it's

00:27:11,750 --> 00:27:15,590
just an interface with a get set in a

00:27:13,310 --> 00:27:17,630
call method right now there's an HTTP

00:27:15,590 --> 00:27:19,010
data source the Falkor router actually

00:27:17,630 --> 00:27:21,110
implements the data source so you can

00:27:19,010 --> 00:27:24,680
actually run the router and the client

00:27:21,110 --> 00:27:26,750
both on the client and so all you really

00:27:24,680 --> 00:27:34,000
need to do is write a data source that

00:27:26,750 --> 00:27:34,000
uses HTTP to instead client only data

00:27:34,330 --> 00:27:39,800
yes well so Falkor is not a replacement

00:27:37,160 --> 00:27:41,030
for flux by any means talk cory's is try

00:27:39,800 --> 00:27:48,460
to be as bare bones as possible it's

00:27:41,030 --> 00:27:48,460
just a library for getting data cool

00:27:49,690 --> 00:27:58,190
right so sorry you know there's a lot of

00:27:55,760 --> 00:28:00,290
questions here that's very good there's

00:27:58,190 --> 00:28:02,600
going to be a discussion we can do is

00:28:00,290 --> 00:28:04,280
during the break we have one room

00:28:02,600 --> 00:28:06,200
specifically prepared for this kind of

00:28:04,280 --> 00:28:08,060
situation so if there's more discussions

00:28:06,200 --> 00:28:10,790
that you want to have and you can go to

00:28:08,060 --> 00:28:12,740
the room on the left at the very end and

00:28:10,790 --> 00:28:14,480
pull your gonna be there you can do

00:28:12,740 --> 00:28:15,770
one-on-one discussions on talks I'll be

00:28:14,480 --> 00:28:17,840
giving out t-shirts using on t-shirts

00:28:15,770 --> 00:28:20,930
exactly so let's do one last question

00:28:17,840 --> 00:28:23,000
from from the from the slider slide and

00:28:20,930 --> 00:28:24,380
then we're gonna move to to coffee

00:28:23,000 --> 00:28:25,640
breaks oh yeah somebody who wants to

00:28:24,380 --> 00:28:26,630
vote does anybody want to vote on the

00:28:25,640 --> 00:28:28,460
question or is that she

00:28:26,630 --> 00:28:30,200
by the thumbs or just a tough one the

00:28:28,460 --> 00:28:34,010
Thomas is devoting actually yeah all

00:28:30,200 --> 00:28:35,510
right Jason API so Jason API is more

00:28:34,010 --> 00:28:39,160
complicated than us we're not trying to

00:28:35,510 --> 00:28:42,590
define a schema the cache has very very

00:28:39,160 --> 00:28:47,840
few conventions and the idea was that

00:28:42,590 --> 00:28:49,670
your your data is the API there's really

00:28:47,840 --> 00:28:52,010
only one or two like special types of

00:28:49,670 --> 00:28:54,830
objects inside the Falkor cash and so

00:28:52,010 --> 00:28:57,620
just so that the cash searching

00:28:54,830 --> 00:28:59,960
algorithm can you know delineate

00:28:57,620 --> 00:29:02,360
references and follow them and optimize

00:28:59,960 --> 00:29:04,280
the paths but awkward doesn't try to

00:29:02,360 --> 00:29:08,840
tell you that you need a schema and you

00:29:04,280 --> 00:29:11,060
have to follow some rules great cool

00:29:08,840 --> 00:29:13,330
awesome so Paul thank you so much for

00:29:11,060 --> 00:29:13,330

YouTube URL: https://www.youtube.com/watch?v=5cA7ZHHkVdo


