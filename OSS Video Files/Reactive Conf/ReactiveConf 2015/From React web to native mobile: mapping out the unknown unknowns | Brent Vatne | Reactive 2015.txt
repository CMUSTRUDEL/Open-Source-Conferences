Title: From React web to native mobile: mapping out the unknown unknowns | Brent Vatne | Reactive 2015
Publication date: 2017-06-29
Playlist: ReactiveConf 2015
Description: 
	Engineers with experience using React for web coming who dive into mobile will feel at home quickly because the basic React API doesn't change. But building for mobile introduces a different way of thinking about the software that you create and React Native empowers you to embrace this rather than attempt to hide it from you: your primary mode of interaction is touch, animations are more common and are expected to be smooth and dynamically track your gestures, you actually have to think about how your app will handle offline / poor connectivity, what happens when the user backgrounds it and comes back, how to send push/local notifications and respond to them, how to stay at 60fps performance on a much less capable device with more demanding users, responding to the keyboard appearing and hiding - specifying different keyboard types, autocorrect/autocomplete, dealing with device orientation changes and status bar changes, app store deployment delays and more. I won't go into great detail about each of these points but will rather help you to build a mental map of the space and touch on solutions that React Native provides to handle these mobile-specific problems, in order for unknown unknowns can become known unknowns. So this talk is kind of to React Native what a maphack is to Starcraft, but totally not lame like that.

Brent Vatne lives in Vancouver and work primarily with Exponent and Iodine on React Native projects. With the rest of my time, I am a core contributor to React Native itself, I send out the React Native Newsletter each week and I try to go for long runs whenever I can.
Captions: 
	00:00:04,500 --> 00:00:09,299
all right hi everybody as you heard my

00:00:07,649 --> 00:00:11,790
name is Brent vadney I'm a core

00:00:09,299 --> 00:00:14,429
contributor to react native I work with

00:00:11,790 --> 00:00:16,619
a company called exponent as if quite

00:00:14,429 --> 00:00:19,410
recently what we're doing is building a

00:00:16,619 --> 00:00:21,090
platform on top of react native so you

00:00:19,410 --> 00:00:23,550
might be able to tell them i really like

00:00:21,090 --> 00:00:25,650
react native like I like it a lot but

00:00:23,550 --> 00:00:28,199
I'm yeah that's that's enough about me

00:00:25,650 --> 00:00:30,240
let's talk a bit about react so this is

00:00:28,199 --> 00:00:32,550
Tom wookie no he's a manager at Facebook

00:00:30,240 --> 00:00:38,940
in this photo he's announcing react

00:00:32,550 --> 00:00:40,860
native that all right there we go okay

00:00:38,940 --> 00:00:44,399
in this photo he's announcing react

00:00:40,860 --> 00:00:46,260
native at react off back in January so

00:00:44,399 --> 00:00:49,590
one of the more popular poke quotes from

00:00:46,260 --> 00:00:51,059
his announcement was the same set of

00:00:49,590 --> 00:00:53,340
Engineers should be able to build

00:00:51,059 --> 00:00:55,350
applications for whatever platform they

00:00:53,340 --> 00:00:57,000
choose without needing to learn a

00:00:55,350 --> 00:00:59,399
fundamentally different set of

00:00:57,000 --> 00:01:02,879
technologies for each we call this

00:00:59,399 --> 00:01:05,070
approach learn once right anywhere so

00:01:02,879 --> 00:01:07,440
really important takeaway from that is

00:01:05,070 --> 00:01:09,659
without needing to learn a fundamentally

00:01:07,440 --> 00:01:11,310
different set of technologies so there

00:01:09,659 --> 00:01:14,820
will still be some technologies that

00:01:11,310 --> 00:01:17,549
you'll need to learn without react

00:01:14,820 --> 00:01:19,830
native Skillshare between web iOS and

00:01:17,549 --> 00:01:21,750
Android looks something like this really

00:01:19,830 --> 00:01:23,850
they're the only common ground I mean

00:01:21,750 --> 00:01:26,159
obviously exaggerating is that you're

00:01:23,850 --> 00:01:29,549
using a keyboard and hopefully not a

00:01:26,159 --> 00:01:31,170
mouse with react native it's something

00:01:29,549 --> 00:01:33,470
more like this so you're able to

00:01:31,170 --> 00:01:37,320
leverage your knowledge of react core

00:01:33,470 --> 00:01:41,270
JavaScript CSS flux and other related

00:01:37,320 --> 00:01:43,470
tools like that on both iOS and Android

00:01:41,270 --> 00:01:45,299
so what we'll be talking about today are

00:01:43,470 --> 00:01:47,220
the concepts that you'll need to learn

00:01:45,299 --> 00:01:48,899
when you're getting into native mobile

00:01:47,220 --> 00:01:51,119
development and I'll specifically focus

00:01:48,899 --> 00:01:52,799
on how they're handled by react native I

00:01:51,119 --> 00:01:55,079
won't really talk about reactor core

00:01:52,799 --> 00:01:56,670
react all mental but there are a lot of

00:01:55,079 --> 00:01:58,320
videos so you know even if you don't

00:01:56,670 --> 00:02:00,509
know that so well hopefully you'll be

00:01:58,320 --> 00:02:03,390
entertained so I think that there are

00:02:00,509 --> 00:02:06,780
three key differences between mobile and

00:02:03,390 --> 00:02:09,989
web so first one users have higher

00:02:06,780 --> 00:02:11,210
expectations so mobile apps just feel a

00:02:09,989 --> 00:02:14,730
lot better than web

00:02:11,210 --> 00:02:17,060
users really expect your mobile app to

00:02:14,730 --> 00:02:19,620
follow with that same sort of standard

00:02:17,060 --> 00:02:22,470
second there are a lot more constraints

00:02:19,620 --> 00:02:24,390
so the devices that you're dealing with

00:02:22,470 --> 00:02:31,230
on mobile are seriously underpowered

00:02:24,390 --> 00:02:33,240
compared to your 2015 macbook pro so for

00:02:31,230 --> 00:02:35,340
to put an actual number to that the

00:02:33,240 --> 00:02:37,320
iphone 6s is the first iphone that has

00:02:35,340 --> 00:02:39,000
more than one gigabyte of RAM I don't

00:02:37,320 --> 00:02:40,860
think you can probably remember your

00:02:39,000 --> 00:02:44,640
last computer that had a gigabyte of RAM

00:02:40,860 --> 00:02:47,540
so and third the developer has a lot

00:02:44,640 --> 00:02:50,130
more api's so you get push notifications

00:02:47,540 --> 00:02:54,120
geofencing a bunch of built-in UI

00:02:50,130 --> 00:02:56,400
components and a lot more like that so

00:02:54,120 --> 00:02:59,700
the first topic is higher expectations

00:02:56,400 --> 00:03:01,290
and we'll start there with animations so

00:02:59,700 --> 00:03:03,390
on the way of the animations are kind of

00:03:01,290 --> 00:03:04,890
mostly seen as unnecessary I guess there

00:03:03,390 --> 00:03:08,160
are three main types of animations on

00:03:04,890 --> 00:03:13,320
the web there's cat animations there's

00:03:08,160 --> 00:03:14,940
dog there we go dog animations and this

00:03:13,320 --> 00:03:21,750
one is quite recent but also great

00:03:14,940 --> 00:03:24,600
animations whereas on mobile animations

00:03:21,750 --> 00:03:26,460
are really everywhere right so cat dog

00:03:24,600 --> 00:03:28,770
and Drake animations are all examples of

00:03:26,460 --> 00:03:30,090
static animations and this is what you

00:03:28,770 --> 00:03:31,980
typically see when you work on the web

00:03:30,090 --> 00:03:34,140
you have some few values that are

00:03:31,980 --> 00:03:36,210
animated from a start to an end value

00:03:34,140 --> 00:03:39,630
over a fixed period of time so in the

00:03:36,210 --> 00:03:42,540
video here we tap on the hamburger icon

00:03:39,630 --> 00:03:44,220
and it animates the menu in and then we

00:03:42,540 --> 00:03:48,330
tap it again it animates the menu out

00:03:44,220 --> 00:03:52,680
and so that's a static animation it's

00:03:48,330 --> 00:03:54,180
also known as fire and forget the other

00:03:52,680 --> 00:03:57,900
type of animations that you'll see a lot

00:03:54,180 --> 00:03:59,130
on vocal our dynamic animations so you

00:03:57,900 --> 00:04:00,900
don't really see this a lot on them on

00:03:59,130 --> 00:04:02,670
the web really so they're not really

00:04:00,900 --> 00:04:04,740
even just animations are there more like

00:04:02,670 --> 00:04:07,050
behaviors so what I mean by that is

00:04:04,740 --> 00:04:10,110
these animations will happen gradually

00:04:07,050 --> 00:04:12,870
in response to some type of input stream

00:04:10,110 --> 00:04:14,130
so for example here we touch on the

00:04:12,870 --> 00:04:16,410
bottom bar and you start moving our

00:04:14,130 --> 00:04:17,850
finger upwards the position of that bar

00:04:16,410 --> 00:04:19,840
is going to track the movement of our

00:04:17,850 --> 00:04:22,280
finger

00:04:19,840 --> 00:04:23,510
yeah so keep this particular animation

00:04:22,280 --> 00:04:28,370
in mind because we're going to look at

00:04:23,510 --> 00:04:30,199
how to implement that shortly and lastly

00:04:28,370 --> 00:04:31,880
there are physics animations so physics

00:04:30,199 --> 00:04:35,389
animations make your interactions feel

00:04:31,880 --> 00:04:37,940
more lifelike by modeling the actual

00:04:35,389 --> 00:04:39,440
behavior after real-world physics most

00:04:37,940 --> 00:04:42,199
of us animations that you'll see are

00:04:39,440 --> 00:04:44,930
based off of Springs so you can adjust

00:04:42,199 --> 00:04:47,900
the tension and friction velocity and

00:04:44,930 --> 00:04:51,110
various other factors depending on how

00:04:47,900 --> 00:04:54,080
you want to configure it to make it

00:04:51,110 --> 00:04:56,780
behave how you need so the library

00:04:54,080 --> 00:04:59,720
called animated was created specifically

00:04:56,780 --> 00:05:01,430
for react native and it's the most

00:04:59,720 --> 00:05:04,699
important API with react native for

00:05:01,430 --> 00:05:05,780
doing these types of animations animated

00:05:04,699 --> 00:05:09,740
is the name it's a bit of a weird name

00:05:05,780 --> 00:05:11,539
but yeah so it uses data binding and it

00:05:09,740 --> 00:05:14,330
directly manipulates the underlying

00:05:11,539 --> 00:05:16,300
abuse in order to avoid rear ndering the

00:05:14,330 --> 00:05:18,169
whole component subtree on each frame

00:05:16,300 --> 00:05:19,699
Christopher she doted a really good talk

00:05:18,169 --> 00:05:21,740
about this at react rally where he talks

00:05:19,699 --> 00:05:24,320
about the design decisions behind it so

00:05:21,740 --> 00:05:25,700
I really check that out but here what

00:05:24,320 --> 00:05:27,680
we're going to talk about is a little

00:05:25,700 --> 00:05:29,030
bit on how to use it so the first thing

00:05:27,680 --> 00:05:31,220
we need to do here is I'm creating an

00:05:29,030 --> 00:05:35,389
animated value and just initializing it

00:05:31,220 --> 00:05:37,520
20 and I'm storing that the state next I

00:05:35,389 --> 00:05:39,740
create an animated view which is a

00:05:37,520 --> 00:05:43,190
special type of view it knows how to

00:05:39,740 --> 00:05:45,680
bind the animated style properties to

00:05:43,190 --> 00:05:48,949
the view so I'm going to animate the

00:05:45,680 --> 00:05:50,720
value that I've created from 0 to 1 so

00:05:48,949 --> 00:05:54,500
knowing that I can just set the opacity

00:05:50,720 --> 00:05:57,099
to the animated value directly because

00:05:54,500 --> 00:06:01,280
that's the valid range for opacity

00:05:57,099 --> 00:06:04,490
whereas for rotation I'm going to have

00:06:01,280 --> 00:06:07,880
to interpolate that so when when the

00:06:04,490 --> 00:06:10,880
animated value is 0 the the rotation

00:06:07,880 --> 00:06:13,220
should be negative 180 degrees and when

00:06:10,880 --> 00:06:15,500
it is one it should be 0 degrees and so

00:06:13,220 --> 00:06:18,050
what this interpolation will do is it

00:06:15,500 --> 00:06:20,389
will determine what the value should be

00:06:18,050 --> 00:06:23,360
in between those values and it will just

00:06:20,389 --> 00:06:24,620
take care of that for us so you might be

00:06:23,360 --> 00:06:27,050
familiar with this a bit if you've used

00:06:24,620 --> 00:06:28,700
III I know there's some talks about t3

00:06:27,050 --> 00:06:31,130
so probably there was a decent amount of

00:06:28,700 --> 00:06:31,910
understanding there so inspired by that

00:06:31,130 --> 00:06:35,690
and very sim

00:06:31,910 --> 00:06:37,790
idea so the last thing we need to do is

00:06:35,690 --> 00:06:40,850
actually perform an animation on the

00:06:37,790 --> 00:06:42,740
value so we start a spring we give it

00:06:40,850 --> 00:06:45,620
the animated value that we want to

00:06:42,740 --> 00:06:47,660
animate and we tell it to go to the

00:06:45,620 --> 00:06:52,100
value of one and then we just start the

00:06:47,660 --> 00:06:55,330
animation so what we end up with is is

00:06:52,100 --> 00:07:02,750
this so it just rotates and the opacity

00:06:55,330 --> 00:07:03,950
goes from 0 to 1 okay now we're gonna

00:07:02,750 --> 00:07:05,420
look at how to create a dynamic

00:07:03,950 --> 00:07:07,220
animation so this is what I was

00:07:05,420 --> 00:07:10,640
referring to when I was saying the keep

00:07:07,220 --> 00:07:11,810
an eye out for the the audio animation

00:07:10,640 --> 00:07:13,540
sliding up the bar from the bottom

00:07:11,810 --> 00:07:16,190
that's we're going to look at doing here

00:07:13,540 --> 00:07:19,190
so in order to be able to track the

00:07:16,190 --> 00:07:21,920
touch position we need to use this thing

00:07:19,190 --> 00:07:23,000
called the pan responder so the first

00:07:21,920 --> 00:07:24,980
thing we're going to do here is we're

00:07:23,000 --> 00:07:26,810
going to create another animated value

00:07:24,980 --> 00:07:28,520
and I've just initialized that to what

00:07:26,810 --> 00:07:31,910
we want the default value to be for the

00:07:28,520 --> 00:07:33,380
position of the the bar doesn't really

00:07:31,910 --> 00:07:36,860
matter i just gave it a constant value

00:07:33,380 --> 00:07:40,730
of bottom next thing we do is we create

00:07:36,860 --> 00:07:42,440
a pan responder so the pan responder is

00:07:40,730 --> 00:07:45,170
initialized with a set of callbacks that

00:07:42,440 --> 00:07:46,610
you later attached to a view in order to

00:07:45,170 --> 00:07:50,150
tell it how it should respond to certain

00:07:46,610 --> 00:07:53,960
catch events the first one that we set

00:07:50,150 --> 00:07:56,419
on move should set and responder what it

00:07:53,960 --> 00:07:57,860
does is if it returns true the view that

00:07:56,419 --> 00:08:00,650
it's attached to will become the

00:07:57,860 --> 00:08:02,690
responder for that touch and so here

00:08:00,650 --> 00:08:05,030
we're not passing in any arguments to it

00:08:02,690 --> 00:08:06,550
it will take the same arguments as the

00:08:05,030 --> 00:08:08,840
other callbacks that you'll see shortly

00:08:06,550 --> 00:08:11,900
but we're just saying if you touch this

00:08:08,840 --> 00:08:14,480
view then this view should become the

00:08:11,900 --> 00:08:16,460
responder for that touch and so let me

00:08:14,480 --> 00:08:19,610
explain for a second what what some of

00:08:16,460 --> 00:08:21,800
these terms means so responder is is

00:08:19,610 --> 00:08:24,350
kind of a fancy name for the view that

00:08:21,800 --> 00:08:26,600
will receive subsequent touch events for

00:08:24,350 --> 00:08:29,900
a touch and there can only be one

00:08:26,600 --> 00:08:31,790
responder at any given time and a touch

00:08:29,900 --> 00:08:34,010
starts when your finger contacts the

00:08:31,790 --> 00:08:37,130
screen and it ends when you lift your

00:08:34,010 --> 00:08:39,169
finger so the next thing that we're

00:08:37,130 --> 00:08:41,510
going to implement is what happens when

00:08:39,169 --> 00:08:43,729
you move your finger so at this point

00:08:41,510 --> 00:08:45,290
we've gone through the on move should

00:08:43,729 --> 00:08:48,139
set pan responder we said

00:08:45,290 --> 00:08:51,380
yes this view is the responder and now

00:08:48,139 --> 00:08:53,029
we're saying is when you are responder

00:08:51,380 --> 00:08:55,370
and you're moving your finger we should

00:08:53,029 --> 00:08:58,250
take your Delta Y value and then update

00:08:55,370 --> 00:09:02,269
the animated value to have that Delta Y

00:08:58,250 --> 00:09:05,120
value and lastly we tell it what to do

00:09:02,269 --> 00:09:06,800
when we release the touch so here we're

00:09:05,120 --> 00:09:08,839
just checking if it is passed some

00:09:06,800 --> 00:09:10,730
certain threshold and if it's passed

00:09:08,839 --> 00:09:12,769
that threshold then we will animate it

00:09:10,730 --> 00:09:16,130
to the top of the screen otherwise we'll

00:09:12,769 --> 00:09:17,779
just put it back at the bottom so just

00:09:16,130 --> 00:09:19,160
to summarize really quickly first we

00:09:17,779 --> 00:09:21,680
tell the view that it should become the

00:09:19,160 --> 00:09:24,769
responder when it's touched we tell it

00:09:21,680 --> 00:09:28,160
to set the drag value to the gestures dy

00:09:24,769 --> 00:09:30,860
on each move and then lastly when we

00:09:28,160 --> 00:09:31,940
release the responder we animate it to

00:09:30,860 --> 00:09:35,380
either the top or the bottom of the

00:09:31,940 --> 00:09:37,610
screen so this is what that looks like

00:09:35,380 --> 00:09:41,360
when it's moving up from the bottom this

00:09:37,610 --> 00:09:43,910
is with my finger on the screen and when

00:09:41,360 --> 00:09:45,800
I'm past one-third of the height of the

00:09:43,910 --> 00:09:48,019
screen it will animate to the top and

00:09:45,800 --> 00:09:52,550
otherwise it'll just go right back down

00:09:48,019 --> 00:09:55,430
at the bottom you'll notice also there's

00:09:52,550 --> 00:09:57,350
a link to our in play which is react

00:09:55,430 --> 00:10:00,230
native playground as Joshua was talking

00:09:57,350 --> 00:10:01,790
about earlier so you can have a look at

00:10:00,230 --> 00:10:05,630
these afterwards and play with them if

00:10:01,790 --> 00:10:07,850
you like okay next up on the list for

00:10:05,630 --> 00:10:11,360
higher expectations that users have of

00:10:07,850 --> 00:10:12,529
mobile is navigation transitions so on

00:10:11,360 --> 00:10:14,149
the desktop web it usually looks

00:10:12,529 --> 00:10:16,850
something like this I you'll click

00:10:14,149 --> 00:10:18,440
somewhere there'll be a flash maybe

00:10:16,850 --> 00:10:20,389
whatever the background color is and

00:10:18,440 --> 00:10:23,000
then the next page will flash in once

00:10:20,389 --> 00:10:24,139
that's done loading so this is great

00:10:23,000 --> 00:10:27,860
because it lets you throw away your

00:10:24,139 --> 00:10:29,449
entire app state on on each change of

00:10:27,860 --> 00:10:31,399
the page you don't have to worry about

00:10:29,449 --> 00:10:34,069
memory leaks nearly as much and things

00:10:31,399 --> 00:10:37,610
like that but you don't really have that

00:10:34,069 --> 00:10:38,959
luxury on mobile so on mobile you're

00:10:37,610 --> 00:10:40,939
expected to have these long running apps

00:10:38,959 --> 00:10:43,730
where you have pleasant transitions

00:10:40,939 --> 00:10:45,410
between each of the scenes you should

00:10:43,730 --> 00:10:49,009
also provide gestures that allow you to

00:10:45,410 --> 00:10:50,540
swipe back or if you slide it in from

00:10:49,009 --> 00:10:53,209
the bottom to swipe from the top to the

00:10:50,540 --> 00:10:56,209
bottom to dismiss the view now this kind

00:10:53,209 --> 00:10:57,230
of thing is just pretty uncommon on on

00:10:56,209 --> 00:11:00,200
the web

00:10:57,230 --> 00:11:01,610
what I've done often if I have something

00:11:00,200 --> 00:11:03,920
like a single page app usually that will

00:11:01,610 --> 00:11:07,250
even be a sub app within a larger app

00:11:03,920 --> 00:11:09,020
and so if you look at a site like

00:11:07,250 --> 00:11:10,550
Facebook they'll have certain sections

00:11:09,020 --> 00:11:12,140
where there'll be like a single page app

00:11:10,550 --> 00:11:13,430
type thing but overall if you switch

00:11:12,140 --> 00:11:14,570
between the main sections on the site

00:11:13,430 --> 00:11:16,940
you get to throw away a lot of the

00:11:14,570 --> 00:11:19,910
context and forget about having pleasant

00:11:16,940 --> 00:11:23,330
transitions but you you never get such a

00:11:19,910 --> 00:11:25,910
luxury on mobile thankfully react native

00:11:23,330 --> 00:11:30,050
gives you some pretty good tools to deal

00:11:25,910 --> 00:11:32,180
with this so the Navigator is probably

00:11:30,050 --> 00:11:34,910
the one that you want to use navigator

00:11:32,180 --> 00:11:37,280
API is oriented around two concepts so

00:11:34,910 --> 00:11:41,060
there's their routes and there are

00:11:37,280 --> 00:11:44,270
scenes so routes can be any javascript

00:11:41,060 --> 00:11:46,850
value of your choice scenes are any

00:11:44,270 --> 00:11:48,980
react component of your choice so your

00:11:46,850 --> 00:11:50,960
job with the Navigator is to provide a

00:11:48,980 --> 00:11:53,690
render scene function that takes a route

00:11:50,960 --> 00:11:57,650
and a navigator object and you have to

00:11:53,690 --> 00:11:59,870
return from that a scene component so

00:11:57,650 --> 00:12:01,700
what i'm doing here is i'm just

00:11:59,870 --> 00:12:03,530
providing a really simple view you would

00:12:01,700 --> 00:12:06,710
probably have something like home screen

00:12:03,530 --> 00:12:08,660
returned if the route ID is home or

00:12:06,710 --> 00:12:11,150
something like that but here I'm just

00:12:08,660 --> 00:12:12,770
returning the same scene and putting

00:12:11,150 --> 00:12:16,150
some text inside of there depending on

00:12:12,770 --> 00:12:18,620
the text property passing of the road

00:12:16,150 --> 00:12:21,890
another thing I'm doing is on press on

00:12:18,620 --> 00:12:24,410
the text I'm passing that off to the on

00:12:21,890 --> 00:12:25,760
press call back and so if we go there we

00:12:24,410 --> 00:12:30,490
see that we're going to increment the

00:12:25,760 --> 00:12:32,810
count and then push a new account to the

00:12:30,490 --> 00:12:34,610
navigator so that's a new route that

00:12:32,810 --> 00:12:37,460
we're pushing in there as I said routes

00:12:34,610 --> 00:12:38,990
can be any arbitrary object what we've

00:12:37,460 --> 00:12:42,920
chosen to use here is just an object

00:12:38,990 --> 00:12:44,000
with a text key and a color key and so

00:12:42,920 --> 00:12:46,070
we're just passing in this new route

00:12:44,000 --> 00:12:50,450
that has these two properties so that we

00:12:46,070 --> 00:12:53,060
can render that with our render scene so

00:12:50,450 --> 00:12:54,560
this is what it looks like and now we

00:12:53,060 --> 00:12:56,510
have a way that we can manage our scenes

00:12:54,560 --> 00:12:58,280
so you can notice there that when you

00:12:56,510 --> 00:13:00,560
swipe back it will dismiss the route and

00:12:58,280 --> 00:13:03,200
bring you to the previous scene and when

00:13:00,560 --> 00:13:05,650
you tap on the text it will push the the

00:13:03,200 --> 00:13:05,650
new scene on

00:13:07,940 --> 00:13:11,700
of course at some point you want to be

00:13:10,350 --> 00:13:14,640
able to customize the transitions that

00:13:11,700 --> 00:13:17,280
you have it's not always ideal to just

00:13:14,640 --> 00:13:19,110
push it in from the right and so the

00:13:17,280 --> 00:13:20,940
Navigator gives you various built-in

00:13:19,110 --> 00:13:23,460
scene configurations so you can use

00:13:20,940 --> 00:13:25,920
float from bottom or float from left for

00:13:23,460 --> 00:13:28,200
example so here I've just made it switch

00:13:25,920 --> 00:13:31,950
between the two you can also provide a

00:13:28,200 --> 00:13:33,180
custom scene configuration and in order

00:13:31,950 --> 00:13:34,650
to figure out how to do that I recommend

00:13:33,180 --> 00:13:36,420
just looking at the source for scene

00:13:34,650 --> 00:13:38,610
config it's pretty much just the plain

00:13:36,420 --> 00:13:41,340
JavaScript object so it's not too

00:13:38,610 --> 00:13:43,770
difficult to work with so then what we

00:13:41,340 --> 00:13:46,440
end up here is a navigator where it's

00:13:43,770 --> 00:13:48,330
alternating between sliding from the

00:13:46,440 --> 00:13:51,480
bottom and in from the left and the

00:13:48,330 --> 00:13:52,920
appropriate gestures that match those

00:13:51,480 --> 00:13:58,530
animations will be provided

00:13:52,920 --> 00:14:03,440
automatically another really important

00:13:58,530 --> 00:14:07,320
piece of the Navigator is the nav bar so

00:14:03,440 --> 00:14:08,940
the nav bar you if you use iOS you might

00:14:07,320 --> 00:14:11,400
be familiar with when you swipe back

00:14:08,940 --> 00:14:14,070
between different scenes the text will

00:14:11,400 --> 00:14:16,080
fade in gradually and fade out depending

00:14:14,070 --> 00:14:18,270
on which view is becoming active or

00:14:16,080 --> 00:14:20,370
inactive so what did it built in

00:14:18,270 --> 00:14:21,870
navigation bar does for you is it

00:14:20,370 --> 00:14:24,960
implements this behavior and pure

00:14:21,870 --> 00:14:26,430
JavaScript so here what we're doing is

00:14:24,960 --> 00:14:31,320
we just provide a navigation bar prop

00:14:26,430 --> 00:14:33,840
which returns a navigation bar and on

00:14:31,320 --> 00:14:36,180
the navigation bar we're setting a rope

00:14:33,840 --> 00:14:37,440
mapper I know this is a lot of

00:14:36,180 --> 00:14:40,860
information don't worry about it the

00:14:37,440 --> 00:14:42,990
slides will be available the Rope mapper

00:14:40,860 --> 00:14:46,020
has three properties so it's just an

00:14:42,990 --> 00:14:49,110
object that has a title a right button

00:14:46,020 --> 00:14:52,050
and a left button i'm pretty sure it's

00:14:49,110 --> 00:14:54,350
clear what those are so for an example

00:14:52,050 --> 00:14:57,060
let's look at the title the title

00:14:54,350 --> 00:14:59,160
function will take a route so that's

00:14:57,060 --> 00:15:01,740
what we defined before be like text in

00:14:59,160 --> 00:15:05,040
color and based off of that we can just

00:15:01,740 --> 00:15:06,900
return any react component that will be

00:15:05,040 --> 00:15:09,650
used as the title so here I'm just

00:15:06,900 --> 00:15:13,410
returning the route text that we

00:15:09,650 --> 00:15:17,250
increment on every tab so then what we

00:15:13,410 --> 00:15:19,320
end up with is something like this it'll

00:15:17,250 --> 00:15:20,080
animate in and then as we swipe back

00:15:19,320 --> 00:15:27,960
it's going

00:15:20,080 --> 00:15:30,700
to fade out how you expect cool so

00:15:27,960 --> 00:15:33,640
that's that's nice but I mean there's

00:15:30,700 --> 00:15:35,260
this big issue with when you have these

00:15:33,640 --> 00:15:38,140
long running apps that you need to

00:15:35,260 --> 00:15:40,480
ensure consistency across your scenes so

00:15:38,140 --> 00:15:42,910
the example you see here I'm navigating

00:15:40,480 --> 00:15:45,550
to somebody's profile from the feed and

00:15:42,910 --> 00:15:47,560
I'm liking one of their posts and then

00:15:45,550 --> 00:15:49,600
I'm swiping back to the feed and you'll

00:15:47,560 --> 00:15:50,860
notice that the post appears is liked

00:15:49,600 --> 00:15:55,930
even though I liked it from their

00:15:50,860 --> 00:15:57,730
profile and not the feed so this is

00:15:55,930 --> 00:16:00,150
something where react native doesn't

00:15:57,730 --> 00:16:02,740
really give you anything to do this

00:16:00,150 --> 00:16:06,040
right there there's nothing specifically

00:16:02,740 --> 00:16:08,320
built in that enables that what it does

00:16:06,040 --> 00:16:10,660
do is that with the navigator all of

00:16:08,320 --> 00:16:12,700
your routes that have been mounted in

00:16:10,660 --> 00:16:16,120
our part of the route sack remain in

00:16:12,700 --> 00:16:19,090
memory so if they're tied to some store

00:16:16,120 --> 00:16:20,970
they will receive any update events and

00:16:19,090 --> 00:16:25,210
they can update themselves appropriately

00:16:20,970 --> 00:16:26,290
so in order to do that without totally

00:16:25,210 --> 00:16:27,420
killing the performance of your app

00:16:26,290 --> 00:16:29,770
you'll probably need a way to

00:16:27,420 --> 00:16:31,330
efficiently determine what you need to

00:16:29,770 --> 00:16:32,650
update but of course you'll need a

00:16:31,330 --> 00:16:34,510
centralized data store of some kind

00:16:32,650 --> 00:16:36,070
because if you just have component local

00:16:34,510 --> 00:16:39,430
state you won't be able to propagate it

00:16:36,070 --> 00:16:41,410
through all the scenes in your app so i

00:16:39,430 --> 00:16:44,050
like to use Redux for state management

00:16:41,410 --> 00:16:45,850
as I imagine a lot of you do as well and

00:16:44,050 --> 00:16:49,540
then immutable j/s as the basis for

00:16:45,850 --> 00:16:51,640
Redux reducers so every time any data

00:16:49,540 --> 00:16:54,160
changes Redux will try to re-render all

00:16:51,640 --> 00:16:57,640
of the views and immutable makes it

00:16:54,160 --> 00:17:02,950
possible to just make that efficient by

00:16:57,640 --> 00:17:05,860
doing the reference equality check okay

00:17:02,950 --> 00:17:08,320
another area where there are higher

00:17:05,860 --> 00:17:10,089
expectations is of course around speed

00:17:08,320 --> 00:17:12,490
and performance so you should give

00:17:10,089 --> 00:17:15,040
everyone instant feedback to any

00:17:12,490 --> 00:17:17,500
interaction they do with the app so it

00:17:15,040 --> 00:17:19,330
should be within 100 milliseconds is

00:17:17,500 --> 00:17:22,630
basically what that means additionally

00:17:19,330 --> 00:17:23,949
the feedback anytime you tap on

00:17:22,630 --> 00:17:26,560
something it should do something like

00:17:23,949 --> 00:17:28,360
fade the view that you're tapping out

00:17:26,560 --> 00:17:29,890
gradually should highlight the

00:17:28,360 --> 00:17:32,620
background on it or do something like

00:17:29,890 --> 00:17:34,720
the material design ripple effect

00:17:32,620 --> 00:17:35,559
that you see on a droid just some sort

00:17:34,720 --> 00:17:37,450
of way to indicate that they've

00:17:35,559 --> 00:17:41,250
interacted with the device otherwise it

00:17:37,450 --> 00:17:44,080
doesn't feel it doesn't quite feel right

00:17:41,250 --> 00:17:45,730
another thing is smooth gestures so if

00:17:44,080 --> 00:17:47,320
you're dragging a photo around it would

00:17:45,730 --> 00:17:51,760
be pretty unpleasant if the app froze

00:17:47,320 --> 00:17:53,020
and the photo for let's say a second

00:17:51,760 --> 00:17:57,220
stop tracking the movement of your

00:17:53,020 --> 00:17:59,140
finger so by smooth I mean it should be

00:17:57,220 --> 00:18:01,120
as close as possible to 60 frames per

00:17:59,140 --> 00:18:02,530
second and if you are going to drop

00:18:01,120 --> 00:18:05,380
frames then you'll probably at least

00:18:02,530 --> 00:18:07,960
want to do it consistently and in the

00:18:05,380 --> 00:18:09,130
smallest possible batches so what I mean

00:18:07,960 --> 00:18:11,440
by that is you don't want to suddenly

00:18:09,130 --> 00:18:13,690
drop ten frames but maybe drop two

00:18:11,440 --> 00:18:18,250
frames and then render a frame and then

00:18:13,690 --> 00:18:19,660
two frames and etc that type of thing so

00:18:18,250 --> 00:18:20,980
I put a lot of information into the

00:18:19,660 --> 00:18:23,559
performance guide in the react native

00:18:20,980 --> 00:18:25,090
docs so you can check that out it's just

00:18:23,559 --> 00:18:27,970
the start there's a lot more to be done

00:18:25,090 --> 00:18:32,770
around that but it'll get you a lot of

00:18:27,970 --> 00:18:36,280
the way they need to go okay another key

00:18:32,770 --> 00:18:37,660
area for performance is lists so user

00:18:36,280 --> 00:18:40,150
interfaces are pretty much made up of

00:18:37,660 --> 00:18:41,500
forms for entering data and you get

00:18:40,150 --> 00:18:43,510
lists of the data that's been entered

00:18:41,500 --> 00:18:47,559
and then you have specific detail views

00:18:43,510 --> 00:18:50,590
for the data but lyssa can see they like

00:18:47,559 --> 00:18:52,570
their key component of that of any UI

00:18:50,590 --> 00:18:54,580
and so on the desktop what happens is

00:18:52,570 --> 00:18:56,200
you can render large list pretty much

00:18:54,580 --> 00:18:57,910
without being concerned about it I mean

00:18:56,200 --> 00:18:59,860
you'll probably want to paginate so that

00:18:57,910 --> 00:19:01,780
you won't have to make huge Network

00:18:59,860 --> 00:19:04,600
requests but you're not really thinking

00:19:01,780 --> 00:19:06,550
about how many views you're going to

00:19:04,600 --> 00:19:08,230
have on the screen in your facebook news

00:19:06,550 --> 00:19:10,090
feed or how many views you're going to

00:19:08,230 --> 00:19:13,890
have in the Dom that's something that

00:19:10,090 --> 00:19:18,120
just isn't really that big of a concern

00:19:13,890 --> 00:19:20,620
so that's not really the case on mobile

00:19:18,120 --> 00:19:23,920
in order for the views through load

00:19:20,620 --> 00:19:25,840
quickly and smooth scroll smoothly on a

00:19:23,920 --> 00:19:29,140
device there are a few optimizations

00:19:25,840 --> 00:19:31,090
that are done natively so usually this

00:19:29,140 --> 00:19:33,910
is through something like on iOS a

00:19:31,090 --> 00:19:38,050
uicollectionview or UI tableview or

00:19:33,910 --> 00:19:39,100
similar constructs on Android so with

00:19:38,050 --> 00:19:41,920
react native you're given something

00:19:39,100 --> 00:19:43,929
called the ListView so this is kind of a

00:19:41,920 --> 00:19:45,730
weak area of react native immediately

00:19:43,929 --> 00:19:46,190
it's a bit of a work in progress at the

00:19:45,730 --> 00:19:48,289
moment

00:19:46,190 --> 00:19:50,000
it's not as robust as the native version

00:19:48,289 --> 00:19:52,100
but it does work quite well in most

00:19:50,000 --> 00:19:55,309
cases it just falls apart of it when

00:19:52,100 --> 00:19:56,690
they are very very long list but you'll

00:19:55,309 --> 00:19:59,690
really be surprised by how often you use

00:19:56,690 --> 00:20:02,029
something like a list view on mobile so

00:19:59,690 --> 00:20:03,230
I'll show you quickly how it works so to

00:20:02,029 --> 00:20:06,320
use the list view we need to store all

00:20:03,230 --> 00:20:08,330
of our data inside of a data source the

00:20:06,320 --> 00:20:11,120
data source requires you provide a row

00:20:08,330 --> 00:20:15,080
has changed function so you can tell the

00:20:11,120 --> 00:20:16,730
ListView how to determine how a row is

00:20:15,080 --> 00:20:22,129
changed and whether it needs to be

00:20:16,730 --> 00:20:25,070
updated next we just render out the list

00:20:22,129 --> 00:20:28,279
view and provide that data source as a

00:20:25,070 --> 00:20:31,580
prop in the ListView an important thing

00:20:28,279 --> 00:20:34,669
here is that we are passing in render

00:20:31,580 --> 00:20:36,820
row as a function so by defining it as a

00:20:34,669 --> 00:20:39,080
function as a function of the row data

00:20:36,820 --> 00:20:41,600
what we were able to do is provide some

00:20:39,080 --> 00:20:44,240
optimizations around rendering that will

00:20:41,600 --> 00:20:47,899
see very shortly so what this example

00:20:44,240 --> 00:20:50,480
that we've done here does is very simple

00:20:47,899 --> 00:20:52,429
it just gives us this list with two

00:20:50,480 --> 00:20:53,690
items that's wrapped in a scrollview so

00:20:52,429 --> 00:20:56,870
you can just move it around and you get

00:20:53,690 --> 00:21:01,039
the bouncy scroll effect on iOS and not

00:20:56,870 --> 00:21:04,039
too fancy so these are the performance

00:21:01,039 --> 00:21:08,029
tuning properties there's initial list

00:21:04,039 --> 00:21:12,320
size page size and scroll render ahead

00:21:08,029 --> 00:21:14,029
distance so initial list size defaults

00:21:12,320 --> 00:21:16,159
to 10 and it tells the ListView how many

00:21:14,029 --> 00:21:19,370
rolls arose the render synchronously

00:21:16,159 --> 00:21:21,110
when its first mounted page size tells

00:21:19,370 --> 00:21:23,179
the ListView how many rows to render in

00:21:21,110 --> 00:21:26,629
each subsequent frame after being

00:21:23,179 --> 00:21:29,690
mounted and scroll render distance tells

00:21:26,629 --> 00:21:34,490
the ListView how far ahead in points to

00:21:29,690 --> 00:21:35,570
render by using the page size so in this

00:21:34,490 --> 00:21:37,820
case what we're doing is when the

00:21:35,570 --> 00:21:39,919
ListView mounts we render 10 rows then

00:21:37,820 --> 00:21:42,860
on each subsequent frame will render one

00:21:39,919 --> 00:21:48,159
row until we've rendered up to 2,000

00:21:42,860 --> 00:21:48,159
points ahead of the scroll position

00:21:49,419 --> 00:21:53,389
these are a few other properties that

00:21:51,470 --> 00:21:55,220
are really important with list views in

00:21:53,389 --> 00:21:56,090
particular I like the render section

00:21:55,220 --> 00:21:58,539
header

00:21:56,090 --> 00:22:00,710
property and so what that gives you is

00:21:58,539 --> 00:22:02,000
something like this you get your sticky

00:22:00,710 --> 00:22:04,580
section headers that you'll see

00:22:02,000 --> 00:22:06,950
everywhere on mobile this just ships

00:22:04,580 --> 00:22:08,630
with react native and it's not a whole

00:22:06,950 --> 00:22:10,039
lot of work to implement and you'll

00:22:08,630 --> 00:22:13,850
definitely be using that with with list

00:22:10,039 --> 00:22:15,140
views so there's another optimization

00:22:13,850 --> 00:22:16,730
with list views that it's pretty

00:22:15,140 --> 00:22:19,250
important it's called remove clip' sub

00:22:16,730 --> 00:22:21,440
views so this is an optional property on

00:22:19,250 --> 00:22:24,529
list views and it can really help with

00:22:21,440 --> 00:22:26,450
the performance on on long lists so what

00:22:24,529 --> 00:22:28,789
it does is it removes the views that are

00:22:26,450 --> 00:22:32,600
not visible on the screen from the

00:22:28,789 --> 00:22:34,100
underlying native view hierarchy so the

00:22:32,600 --> 00:22:35,690
views actually stay in memory and

00:22:34,100 --> 00:22:37,309
they're just remounted when they come

00:22:35,690 --> 00:22:38,240
back on the screen so that might sound

00:22:37,309 --> 00:22:40,669
like there really aren't a lot of

00:22:38,240 --> 00:22:42,529
benefits to it but a result of it being

00:22:40,669 --> 00:22:45,020
unmounted from the native view hierarchy

00:22:42,529 --> 00:22:47,179
is that now the images can be unloaded

00:22:45,020 --> 00:22:48,590
from memory and so that ends up being

00:22:47,179 --> 00:22:52,070
very important if you have a long list

00:22:48,590 --> 00:22:56,809
of let's say photos on Instagram you'll

00:22:52,070 --> 00:22:58,610
want to be able to unmount the views so

00:22:56,809 --> 00:23:03,830
that you can unload the images and not

00:22:58,610 --> 00:23:05,179
run to out of memory errors another very

00:23:03,830 --> 00:23:06,950
important tool for performance

00:23:05,179 --> 00:23:09,649
optimization right now and to maintain

00:23:06,950 --> 00:23:13,580
60 frames per second is the interaction

00:23:09,649 --> 00:23:16,490
manager so what this does is it lets you

00:23:13,580 --> 00:23:18,679
defer any CPU intensive work until some

00:23:16,490 --> 00:23:20,720
sort of gesture interaction or animation

00:23:18,679 --> 00:23:22,309
has completed because when like I was

00:23:20,720 --> 00:23:24,799
saying before with the image gallery if

00:23:22,309 --> 00:23:26,750
you start dragging a photo around you

00:23:24,799 --> 00:23:27,980
don't want to be doing any intensive

00:23:26,750 --> 00:23:30,830
work that will cause you to drop frames

00:23:27,980 --> 00:23:34,039
during that time so you'll want to defer

00:23:30,830 --> 00:23:37,820
that work until the interaction manager

00:23:34,039 --> 00:23:40,820
no longer has any one registered as an

00:23:37,820 --> 00:23:43,220
interaction so let's just set up some

00:23:40,820 --> 00:23:46,279
scaffolding here I have some state

00:23:43,220 --> 00:23:48,529
called is ready when we're ready we'll

00:23:46,279 --> 00:23:49,640
just render this whole scene until it's

00:23:48,529 --> 00:23:54,890
ready we just render a loading screen

00:23:49,640 --> 00:23:56,450
and then in component did mount we call

00:23:54,890 --> 00:23:58,520
on the interaction manager and we tell

00:23:56,450 --> 00:23:59,779
it to run a block after interactions and

00:23:58,520 --> 00:24:04,460
in that block we just sell it to say

00:23:59,779 --> 00:24:06,880
that it's ready to render so this is

00:24:04,460 --> 00:24:08,900
really important because right now

00:24:06,880 --> 00:24:11,360
animations run on the Java Sea

00:24:08,900 --> 00:24:13,490
rip thread so when you render a new

00:24:11,360 --> 00:24:17,150
scene and we're pushing in the scene

00:24:13,490 --> 00:24:19,730
from the right by default if your new

00:24:17,150 --> 00:24:21,260
scene needs to render however many

00:24:19,730 --> 00:24:23,540
hundred subcomponents something like

00:24:21,260 --> 00:24:25,670
that it's pretty likely that that's

00:24:23,540 --> 00:24:30,080
going to take more than 16 milliseconds

00:24:25,670 --> 00:24:31,820
to do the reconciliation for that so you

00:24:30,080 --> 00:24:33,950
can probably render some kind of loading

00:24:31,820 --> 00:24:37,940
seen that you can do easily within that

00:24:33,950 --> 00:24:39,980
frame deadline but you want to defer the

00:24:37,940 --> 00:24:41,360
actual full scene until that animation

00:24:39,980 --> 00:24:45,610
is completed otherwise you'll end up

00:24:41,360 --> 00:24:49,570
with a really Jenky kind of transition

00:24:45,610 --> 00:24:52,040
ok 11 last optimization here is

00:24:49,570 --> 00:24:55,670
rasterization some of you might be

00:24:52,040 --> 00:24:58,310
familiar with this already so what it is

00:24:55,670 --> 00:25:00,920
is it helps you with the problem of over

00:24:58,310 --> 00:25:03,380
drone so overdraw occurs when you're

00:25:00,920 --> 00:25:05,600
making the GPU repaint the same pixel

00:25:03,380 --> 00:25:08,150
multiple times so this can negatively

00:25:05,600 --> 00:25:10,070
affect performances you might might

00:25:08,150 --> 00:25:11,990
guess so this is useful when you're

00:25:10,070 --> 00:25:15,830
animating a view with a lot of layers or

00:25:11,990 --> 00:25:18,710
scrolling through a view that has sub

00:25:15,830 --> 00:25:20,750
views with many layers so what I mean by

00:25:18,710 --> 00:25:22,490
that is you look at this cat this is

00:25:20,750 --> 00:25:25,040
just one image and then we have to paint

00:25:22,490 --> 00:25:26,360
the star on top and then we have to

00:25:25,040 --> 00:25:30,050
paint this one and this one and this one

00:25:26,360 --> 00:25:32,240
and then cute text and then this overlay

00:25:30,050 --> 00:25:34,580
again so there's a lot of repainting

00:25:32,240 --> 00:25:37,220
being done here and what we need to do

00:25:34,580 --> 00:25:38,570
in order for this to likely be

00:25:37,220 --> 00:25:41,390
performant when we're scrolling in a

00:25:38,570 --> 00:25:43,550
list of of these types of views is just

00:25:41,390 --> 00:25:46,520
enable a couple of properties so there

00:25:43,550 --> 00:25:48,950
should rasterize iOS is the iOS version

00:25:46,520 --> 00:25:51,410
of this and then there's render to

00:25:48,950 --> 00:25:53,390
hardware text or Android so what this

00:25:51,410 --> 00:25:54,950
does is it's the equivalent of in

00:25:53,390 --> 00:25:57,670
Photoshop doing something like flattened

00:25:54,950 --> 00:26:00,770
layers it just pushes them all into one

00:25:57,670 --> 00:26:04,520
texture and keeps that in memory and

00:26:00,770 --> 00:26:06,680
then draws from that in the future so

00:26:04,520 --> 00:26:07,910
that said definitely read more about

00:26:06,680 --> 00:26:10,100
this when you're going to use it because

00:26:07,910 --> 00:26:12,200
it's possible to shoot yourself in the

00:26:10,100 --> 00:26:14,690
foot pretty easily because it does use

00:26:12,200 --> 00:26:16,580
more memory and if you're animating some

00:26:14,690 --> 00:26:17,690
of the interviews the inner layers it's

00:26:16,580 --> 00:26:25,039
probably not a good idea to

00:26:17,690 --> 00:26:27,470
but all right so now how do we monitor

00:26:25,039 --> 00:26:29,090
our performance so it's a good idea when

00:26:27,470 --> 00:26:31,370
you're doing development and coming to

00:26:29,090 --> 00:26:33,230
any performance problems is not to just

00:26:31,370 --> 00:26:35,120
assume oh I think this part of the

00:26:33,230 --> 00:26:37,789
application is slow obviously I'm sure

00:26:35,120 --> 00:26:40,009
you all know this so what you should do

00:26:37,789 --> 00:26:41,120
is try to track down what the bottleneck

00:26:40,009 --> 00:26:44,330
is and then try and fix that

00:26:41,120 --> 00:26:46,190
specifically so I find it with react

00:26:44,330 --> 00:26:49,100
native usually the JavaScript thread is

00:26:46,190 --> 00:26:52,399
holding things up what you can do is you

00:26:49,100 --> 00:26:56,149
can turn on the FPS monitor and do this

00:26:52,399 --> 00:26:58,190
on your device and see in the parts of

00:26:56,149 --> 00:27:00,080
the app that feels slow where are you

00:26:58,190 --> 00:27:03,200
dropping frames and then you can do

00:27:00,080 --> 00:27:04,399
further analysis from there so I said on

00:27:03,200 --> 00:27:06,019
your device it's really important that

00:27:04,399 --> 00:27:09,110
you run it on your device not in the

00:27:06,019 --> 00:27:10,730
simulator I you know it's a completely

00:27:09,110 --> 00:27:13,279
different environment and it will not be

00:27:10,730 --> 00:27:16,850
representative of the actual performance

00:27:13,279 --> 00:27:18,470
if you're running in the simulator so if

00:27:16,850 --> 00:27:20,870
if you're having a hard time even with

00:27:18,470 --> 00:27:24,080
FPS monitor and looking through your

00:27:20,870 --> 00:27:26,080
code based off of just intuition after

00:27:24,080 --> 00:27:28,639
that what you might want to do is use

00:27:26,080 --> 00:27:30,769
aside from whatever profiling to tools

00:27:28,639 --> 00:27:33,440
you are already familiar with like react

00:27:30,769 --> 00:27:35,870
perf you might want to use the built-in

00:27:33,440 --> 00:27:38,000
react native profiler so you just enable

00:27:35,870 --> 00:27:39,620
that at some point and then go through

00:27:38,000 --> 00:27:43,250
your interaction and then turn it off

00:27:39,620 --> 00:27:46,190
and then it loads up this trace view

00:27:43,250 --> 00:27:47,929
where you can look at the three most

00:27:46,190 --> 00:27:49,789
important threads in react native so

00:27:47,929 --> 00:27:51,169
there's the main thread the JavaScript

00:27:49,789 --> 00:27:53,269
thread and the shadow thread which does

00:27:51,169 --> 00:27:56,269
layout and you can trace the flow of

00:27:53,269 --> 00:28:02,929
events through each and see where the

00:27:56,269 --> 00:28:06,740
the bottleneck is happening so on the

00:28:02,929 --> 00:28:08,659
web nobody really expects you to cater

00:28:06,740 --> 00:28:10,580
to whether they're using windows or

00:28:08,659 --> 00:28:12,830
using Mac or Linux right you just have

00:28:10,580 --> 00:28:14,440
this kind of like web UI but that's not

00:28:12,830 --> 00:28:17,059
really the case on mobile where their

00:28:14,440 --> 00:28:18,440
platform specific patterns that you need

00:28:17,059 --> 00:28:20,240
to take into account and they're good

00:28:18,440 --> 00:28:23,600
reasons for this as well so if you look

00:28:20,240 --> 00:28:28,369
at the Android version here of facebook

00:28:23,600 --> 00:28:29,899
ads manager you'll see that we have Note

00:28:28,369 --> 00:28:30,530
tab bar on the bottom but instead we

00:28:29,899 --> 00:28:32,540
have the

00:28:30,530 --> 00:28:36,500
Elton Android back button and home

00:28:32,540 --> 00:28:38,390
screen and why not so the results of

00:28:36,500 --> 00:28:40,670
Android using a back button on the

00:28:38,390 --> 00:28:42,140
bottom of the screen is that it's not

00:28:40,670 --> 00:28:44,450
very common to have tab bars because

00:28:42,140 --> 00:28:47,000
then you have two rows of buttons on the

00:28:44,450 --> 00:28:48,680
bottom which I mean you can easily press

00:28:47,000 --> 00:28:51,860
the wrong button and do all sorts of

00:28:48,680 --> 00:28:53,780
things like that so instead on Android

00:28:51,860 --> 00:28:55,100
you'll probably use a what's called the

00:28:53,780 --> 00:28:58,180
drawer layout which is sort of a side

00:28:55,100 --> 00:29:00,740
menu that you swipe out from the side

00:28:58,180 --> 00:29:02,540
there's a floating action button there

00:29:00,740 --> 00:29:04,370
there's there's just a few differences

00:29:02,540 --> 00:29:07,340
you need to take into account on that so

00:29:04,370 --> 00:29:09,950
Martin's going to show more about these

00:29:07,340 --> 00:29:13,940
platform differences in his talk next so

00:29:09,950 --> 00:29:16,730
I won't talk too much about that another

00:29:13,940 --> 00:29:19,580
issue is with pixel densities so on the

00:29:16,730 --> 00:29:24,850
web you can kind of just do whatever you

00:29:19,580 --> 00:29:27,710
probably how many people have 1x 2x 3x

00:29:24,850 --> 00:29:31,310
assets for everything on the web your

00:29:27,710 --> 00:29:33,890
hand up yeah make this that's worth up

00:29:31,310 --> 00:29:36,770
nobody does like if you go to facebook

00:29:33,890 --> 00:29:40,540
com and look at the the tab bar in the

00:29:36,770 --> 00:29:42,890
top they don't even have 2x assets so

00:29:40,540 --> 00:29:45,650
but on mobile you can't really get away

00:29:42,890 --> 00:29:48,140
with that you have to provide various

00:29:45,650 --> 00:29:49,400
sizes for it because otherwise it's just

00:29:48,140 --> 00:29:52,250
not going to look good right there's

00:29:49,400 --> 00:29:53,840
this expectation people have that this

00:29:52,250 --> 00:29:58,700
is a Retina device you're going to have

00:29:53,840 --> 00:30:00,770
retina assets on this device so react

00:29:58,700 --> 00:30:03,080
native gives you a few good tools for

00:30:00,770 --> 00:30:05,300
that so you can access the pixel ratio

00:30:03,080 --> 00:30:07,160
directly if you want to do something

00:30:05,300 --> 00:30:10,070
programmatically with your layout based

00:30:07,160 --> 00:30:11,750
off of the pixel ratio or the image

00:30:10,070 --> 00:30:15,200
component itself will automatically

00:30:11,750 --> 00:30:17,690
determine which image to use so here

00:30:15,200 --> 00:30:20,270
with reactive PNG if we did reactive at

00:30:17,690 --> 00:30:22,430
1x reactive at 2x reactive at 3x it

00:30:20,270 --> 00:30:27,680
would just pick the correct one for us

00:30:22,430 --> 00:30:29,740
depending on the devices pixel ratio ok

00:30:27,680 --> 00:30:34,130
so that was everything about higher

00:30:29,740 --> 00:30:36,800
expectations the next topic is the

00:30:34,130 --> 00:30:39,260
constraints so like I was mentioning

00:30:36,800 --> 00:30:41,549
before with long running apps you can't

00:30:39,260 --> 00:30:44,759
just throw the context away with every

00:30:41,549 --> 00:30:47,399
every request memory is really valuable

00:30:44,759 --> 00:30:49,100
resource on mobile devices so you need

00:30:47,399 --> 00:30:51,059
to make sure you clean up after yourself

00:30:49,100 --> 00:30:54,299
memory leaks will really add up over

00:30:51,059 --> 00:30:56,009
time whereas on the web you get to throw

00:30:54,299 --> 00:30:58,529
away your memory leaks and if you

00:30:56,009 --> 00:31:01,289
navigate to a new page on mobile if

00:30:58,529 --> 00:31:02,850
you're using react native and really

00:31:01,289 --> 00:31:04,440
just mobile in general these memory

00:31:02,850 --> 00:31:07,200
leaks can definitely add up as you're

00:31:04,440 --> 00:31:09,330
going between different scenes on iOS

00:31:07,200 --> 00:31:12,029
your app can be killed during

00:31:09,330 --> 00:31:13,950
multitasking if if it's holding too much

00:31:12,029 --> 00:31:16,799
memory so maybe you've seen that where

00:31:13,950 --> 00:31:18,509
you're in your app you minimize it go to

00:31:16,799 --> 00:31:20,580
another app and then come back and

00:31:18,509 --> 00:31:22,289
notice that this app is looks like it's

00:31:20,580 --> 00:31:26,419
being restarted so that happened because

00:31:22,289 --> 00:31:29,090
it was holding too much memory so

00:31:26,419 --> 00:31:31,440
there's also an important factor that

00:31:29,090 --> 00:31:34,289
mobile apps tend to focus a lot on media

00:31:31,440 --> 00:31:37,049
so there's a lot of image and video and

00:31:34,289 --> 00:31:38,340
so the remove clip' subview prop that i

00:31:37,049 --> 00:31:44,159
mentioned before is really important for

00:31:38,340 --> 00:31:46,909
reducing memory usage another important

00:31:44,159 --> 00:31:50,039
constraint is with connectivity so

00:31:46,909 --> 00:31:52,710
you'll have to deal with users who have

00:31:50,039 --> 00:31:55,830
no connection at all like for example I

00:31:52,710 --> 00:31:59,340
am currently in Slovakia where I have no

00:31:55,830 --> 00:32:01,169
data so when I open up a nap I wouldn't

00:31:59,340 --> 00:32:02,489
expect you to just close or say go away

00:32:01,169 --> 00:32:04,559
until you get data or something like

00:32:02,489 --> 00:32:06,840
that right I should be able to view some

00:32:04,559 --> 00:32:08,639
offline cache data and maybe write a

00:32:06,840 --> 00:32:10,799
message read a message and then have

00:32:08,639 --> 00:32:15,029
that automatically be sent out when I

00:32:10,799 --> 00:32:17,779
come into an area with data similarly

00:32:15,029 --> 00:32:20,669
you might just have a slow connection

00:32:17,779 --> 00:32:22,769
maybe you're on the train in a tunnel

00:32:20,669 --> 00:32:25,649
something like that so you should

00:32:22,769 --> 00:32:27,929
definitely build in timeouts and retries

00:32:25,649 --> 00:32:29,519
into your app and that's something

00:32:27,929 --> 00:32:32,190
probably a lot of you do that already

00:32:29,519 --> 00:32:34,679
for the web but I don't suspect you do

00:32:32,190 --> 00:32:36,179
it everywhere but it's it's definitely

00:32:34,679 --> 00:32:38,369
worth doing in your mobile app because

00:32:36,179 --> 00:32:40,230
request will timeout and if your app

00:32:38,369 --> 00:32:42,179
gets into a weird inconsistent state

00:32:40,230 --> 00:32:45,379
when it times out it's not going to be

00:32:42,179 --> 00:32:45,379
very pleasant experience

00:32:47,070 --> 00:32:51,360
so there's a component called net info

00:32:48,840 --> 00:32:53,909
that lets you pick out the current state

00:32:51,360 --> 00:32:56,789
of the network if you don't have a

00:32:53,909 --> 00:33:00,899
connection it will let you know if this

00:32:56,789 --> 00:33:02,759
is connected boolean that's passed in

00:33:00,899 --> 00:33:04,080
and that's pretty much all there is to

00:33:02,759 --> 00:33:06,509
that you just add a listener to it and

00:33:04,080 --> 00:33:08,940
do whatever you need so maybe just show

00:33:06,509 --> 00:33:11,880
up Anna or something in terms of

00:33:08,940 --> 00:33:13,710
handling timeouts you can use something

00:33:11,880 --> 00:33:16,289
very simple like this where it's just a

00:33:13,710 --> 00:33:18,330
function that wraps a promise and if

00:33:16,289 --> 00:33:19,710
this doesn't complete in certain number

00:33:18,330 --> 00:33:23,789
of milliseconds then the promise is

00:33:19,710 --> 00:33:26,309
rejected and we clear the timeout so if

00:33:23,789 --> 00:33:29,100
we use this in conjunction with async

00:33:26,309 --> 00:33:31,710
await then it's actually quite clear we

00:33:29,100 --> 00:33:34,019
just do try and then we await the

00:33:31,710 --> 00:33:36,570
response of the HTTP request so here

00:33:34,019 --> 00:33:37,799
we'll give it 10 seconds to complete if

00:33:36,570 --> 00:33:40,139
it doesn't complete we can catch that

00:33:37,799 --> 00:33:42,029
and maybe set the state for this seem to

00:33:40,139 --> 00:33:45,179
say hey we couldn't get the data click

00:33:42,029 --> 00:33:51,629
here to retry so it's not that hard to

00:33:45,179 --> 00:33:53,279
do so battery usage is another issue

00:33:51,629 --> 00:33:55,289
that I'm almost certain nobody has

00:33:53,279 --> 00:33:56,399
thought about on the web and that's fair

00:33:55,289 --> 00:33:57,960
you probably don't really need you i

00:33:56,399 --> 00:33:59,039
mean chrome already uses huge amounts of

00:33:57,960 --> 00:34:02,610
battery that I don't think you're asking

00:33:59,039 --> 00:34:04,250
to make it that much worse but on mobile

00:34:02,610 --> 00:34:07,110
it's definitely consideration especially

00:34:04,250 --> 00:34:08,669
with things like geolocation like how

00:34:07,110 --> 00:34:10,290
frequently do you need to be pulling for

00:34:08,669 --> 00:34:12,030
their location you probably want to

00:34:10,290 --> 00:34:13,889
minimize that to the least amount that

00:34:12,030 --> 00:34:16,770
you actually need in order to not kill

00:34:13,889 --> 00:34:17,970
their battery and you know there are all

00:34:16,770 --> 00:34:19,889
sorts of other things like that network

00:34:17,970 --> 00:34:22,399
network requests try to avoid making

00:34:19,889 --> 00:34:24,389
unnecessary Network requests otherwise

00:34:22,399 --> 00:34:27,629
that'll also consume quite a bit of

00:34:24,389 --> 00:34:29,819
battery so don't just pull the server

00:34:27,629 --> 00:34:34,409
for updates constantly maybe set up a

00:34:29,819 --> 00:34:36,899
web socket so that there are there tools

00:34:34,409 --> 00:34:39,569
that are provided on each platform with

00:34:36,899 --> 00:34:41,310
iOS with Xcode you can monitor your

00:34:39,569 --> 00:34:43,740
battery usage just by going to the

00:34:41,310 --> 00:34:45,000
energy impact section and if you just

00:34:43,740 --> 00:34:47,639
keep an eye on that and make sure you're

00:34:45,000 --> 00:34:50,159
not kind of getting out of control that

00:34:47,639 --> 00:34:52,339
will probably be sufficient a lot of the

00:34:50,159 --> 00:34:52,339
time

00:34:53,690 --> 00:34:59,000
so this constraint the new mode of

00:34:56,450 --> 00:35:00,560
interaction is I think fairly obvious

00:34:59,000 --> 00:35:03,530
you you no longer have an external

00:35:00,560 --> 00:35:05,089
keyboard on mobile you have touch

00:35:03,530 --> 00:35:07,280
everything that you do to interact with

00:35:05,089 --> 00:35:09,170
the device with the exception of a

00:35:07,280 --> 00:35:11,300
couple of things like shake and the

00:35:09,170 --> 00:35:13,579
accelerometer everything is touch and

00:35:11,300 --> 00:35:15,500
just some combination of how you touch

00:35:13,579 --> 00:35:19,089
the screen to create a certain gesture

00:35:15,500 --> 00:35:21,740
so get tap DoubleTap long-press 3d touch

00:35:19,089 --> 00:35:24,890
with varying degrees of pressure you get

00:35:21,740 --> 00:35:26,119
swype pinch to zoom etc and then there

00:35:24,890 --> 00:35:28,040
are actually a lot of accessibility

00:35:26,119 --> 00:35:29,450
gestures built on top of that so there's

00:35:28,040 --> 00:35:32,540
something called magic tap where you do

00:35:29,450 --> 00:35:34,520
two taps to double taps in the middle of

00:35:32,540 --> 00:35:37,310
the screen and that will perform like

00:35:34,520 --> 00:35:38,359
the main action and that's that's meant

00:35:37,310 --> 00:35:43,760
for that screen and that's meant for

00:35:38,359 --> 00:35:46,190
visually impaired users so luckily the

00:35:43,760 --> 00:35:47,720
layout system itself is many of you may

00:35:46,190 --> 00:35:49,730
know already is consistent across

00:35:47,720 --> 00:35:52,460
platforms with react native you get

00:35:49,730 --> 00:35:56,359
flexbox but there are still some

00:35:52,460 --> 00:35:58,780
concerns that just don't exist on on the

00:35:56,359 --> 00:36:01,450
web so the keyboard key words a big one

00:35:58,780 --> 00:36:04,099
in fact I think that's the biggest thing

00:36:01,450 --> 00:36:06,770
to consider when you're doing mobile

00:36:04,099 --> 00:36:09,980
development in terms of how the OS can

00:36:06,770 --> 00:36:12,050
interact with your layout so when the

00:36:09,980 --> 00:36:13,750
keyboard opens you might have to scroll

00:36:12,050 --> 00:36:16,069
somewhere on the screen in order to

00:36:13,750 --> 00:36:18,079
accommodate the view so they can

00:36:16,069 --> 00:36:21,530
actually see what they are interacting

00:36:18,079 --> 00:36:23,270
with do they have something like

00:36:21,530 --> 00:36:24,740
predictive typing enabled because then

00:36:23,270 --> 00:36:26,510
the keyboard size will be slightly

00:36:24,740 --> 00:36:28,700
different what is the height of their

00:36:26,510 --> 00:36:32,359
device they're using an iphone 4 versus

00:36:28,700 --> 00:36:34,849
a 6 plus or 6s plus you're going to have

00:36:32,359 --> 00:36:37,490
a very different viewport size with the

00:36:34,849 --> 00:36:39,530
keyboard open so those are definitely

00:36:37,490 --> 00:36:43,220
considerations that are that are pretty

00:36:39,530 --> 00:36:44,990
important there's orientation so if you

00:36:43,220 --> 00:36:47,180
look at some of the top most popular

00:36:44,990 --> 00:36:49,819
apps on the App Store like Facebook or

00:36:47,180 --> 00:36:52,010
Twitter they don't really support

00:36:49,819 --> 00:36:54,890
orientation changes with the exception

00:36:52,010 --> 00:36:56,390
of things like image galleries but

00:36:54,890 --> 00:36:59,150
generally speaking you can kind of just

00:36:56,390 --> 00:37:00,740
lock your orientation to whatever it's

00:36:59,150 --> 00:37:04,490
meant for and then on a case-by-case

00:37:00,740 --> 00:37:05,480
basis enable it and then the last one is

00:37:04,490 --> 00:37:06,860
status bar which is actually

00:37:05,480 --> 00:37:09,710
surprisingly difficult to get

00:37:06,860 --> 00:37:13,190
right you may have even seen on your own

00:37:09,710 --> 00:37:15,380
bugs with built-in apple apps like Apple

00:37:13,190 --> 00:37:17,960
music will sometimes in response to the

00:37:15,380 --> 00:37:19,910
status bar height changing rendered the

00:37:17,960 --> 00:37:22,720
tab bar with a space underneath it

00:37:19,910 --> 00:37:25,910
equivalent to the size of the status bar

00:37:22,720 --> 00:37:27,110
so there are a lot of things to to

00:37:25,910 --> 00:37:31,760
really consider with with the layout

00:37:27,110 --> 00:37:33,020
that don't exist on the web so this is

00:37:31,760 --> 00:37:34,940
what it looks like if you don't take

00:37:33,020 --> 00:37:36,710
these kind of things into account so

00:37:34,940 --> 00:37:39,470
here we're tapping on this email field

00:37:36,710 --> 00:37:41,510
and we're trying to fill out the form to

00:37:39,470 --> 00:37:42,680
sign up which is I mean I imagine you

00:37:41,510 --> 00:37:44,630
want people to sign up you want to

00:37:42,680 --> 00:37:46,510
reduce the friction to signing up but

00:37:44,630 --> 00:37:49,070
what happens is I click on that and

00:37:46,510 --> 00:37:51,050
suddenly I'm seeing this whole area

00:37:49,070 --> 00:37:53,090
above still which is totally useless to

00:37:51,050 --> 00:37:54,710
me at the point of me deciding to sign

00:37:53,090 --> 00:37:56,630
up what it should do is shift up and

00:37:54,710 --> 00:37:59,540
show me the form as much of the form as

00:37:56,630 --> 00:38:01,970
possible but actually what happens is it

00:37:59,540 --> 00:38:04,850
covers up the whole form except for the

00:38:01,970 --> 00:38:06,470
user name and if this was a smaller

00:38:04,850 --> 00:38:07,670
device if this was an iphone 4 I

00:38:06,470 --> 00:38:10,970
wouldn't even be able to see the user

00:38:07,670 --> 00:38:13,760
name and even when I press next here it

00:38:10,970 --> 00:38:15,230
doesn't jump to the next field so this

00:38:13,760 --> 00:38:17,240
is actually constraint with with react

00:38:15,230 --> 00:38:20,960
native at the moment react native does

00:38:17,240 --> 00:38:22,700
not implement a tab index so if you are

00:38:20,960 --> 00:38:25,310
going to jump from one text field to

00:38:22,700 --> 00:38:28,100
another when you submit it then you have

00:38:25,310 --> 00:38:29,330
to manually focus the next field so if

00:38:28,100 --> 00:38:35,840
anyone wants to work on that that would

00:38:29,330 --> 00:38:37,780
be great so here's how you can handle

00:38:35,840 --> 00:38:40,460
these situations with react native

00:38:37,780 --> 00:38:42,970
there's the divisive animator which you

00:38:40,460 --> 00:38:45,230
can add a listener to for various events

00:38:42,970 --> 00:38:47,420
so for the keyboard its keyboard will

00:38:45,230 --> 00:38:49,580
show there's a few others as well like

00:38:47,420 --> 00:38:51,860
keyboard did show which is after that's

00:38:49,580 --> 00:38:53,960
already completed and so the handler

00:38:51,860 --> 00:38:56,000
that you provide for that is given an

00:38:53,960 --> 00:38:57,950
object that has n coordinates duration

00:38:56,000 --> 00:39:00,140
easing a couple of other properties that

00:38:57,950 --> 00:39:01,610
are not so important and then what you

00:39:00,140 --> 00:39:03,980
can do in response to that is set the

00:39:01,610 --> 00:39:07,270
state or somehow update your layout so

00:39:03,980 --> 00:39:10,610
that it fits appropriately to

00:39:07,270 --> 00:39:13,700
accommodate the keyboard additionally

00:39:10,610 --> 00:39:15,590
the status bar frame will change so this

00:39:13,700 --> 00:39:18,140
just gets the height of the status bar

00:39:15,590 --> 00:39:20,000
so if you have a phone call or you're

00:39:18,140 --> 00:39:21,470
watching someone's geolocation you'll

00:39:20,000 --> 00:39:23,360
we be doubling the size of the status

00:39:21,470 --> 00:39:27,050
bar so you can take that into account as

00:39:23,360 --> 00:39:29,330
well and in addition to that with the

00:39:27,050 --> 00:39:32,660
status bar you can style it by sending

00:39:29,330 --> 00:39:34,370
it to light or dark if you have a dark

00:39:32,660 --> 00:39:35,570
status bar on a dark background that's

00:39:34,370 --> 00:39:37,610
not going to look very good so you need

00:39:35,570 --> 00:39:39,290
to consider that and switch it so that

00:39:37,610 --> 00:39:40,880
you can actually see the status bar or

00:39:39,290 --> 00:39:42,440
maybe just decide that you don't need

00:39:40,880 --> 00:39:46,220
the status bar at all in which case you

00:39:42,440 --> 00:39:49,820
can hide it and lastly with orientation

00:39:46,220 --> 00:39:53,300
you similarly just add a listener to an

00:39:49,820 --> 00:39:59,390
orientation event and respond to that is

00:39:53,300 --> 00:40:01,790
necessary all right development workflow

00:39:59,390 --> 00:40:04,070
is probably the the main area where

00:40:01,790 --> 00:40:08,240
people recognize a difference between

00:40:04,070 --> 00:40:10,850
mobile and web because with native

00:40:08,240 --> 00:40:13,730
development you're stuck using IDEs like

00:40:10,850 --> 00:40:15,170
Xcode or Android studio and every time

00:40:13,730 --> 00:40:16,940
you make a change you compile your

00:40:15,170 --> 00:40:19,670
project and then you navigate to the

00:40:16,940 --> 00:40:21,530
screen and make sure that the view is

00:40:19,670 --> 00:40:23,900
moved over one point to the right or

00:40:21,530 --> 00:40:27,380
that it's that new shade of red or or

00:40:23,900 --> 00:40:31,460
whatever it's a little bit different

00:40:27,380 --> 00:40:32,360
with react native so you you get a lot

00:40:31,460 --> 00:40:34,280
of the stuff that you're familiar with

00:40:32,360 --> 00:40:36,680
you can use a chrome debugger and

00:40:34,280 --> 00:40:38,210
actually just throw in a debugger

00:40:36,680 --> 00:40:40,760
statement at any point and inspect the

00:40:38,210 --> 00:40:43,250
state of your application you can even

00:40:40,760 --> 00:40:44,510
use an element inspector to click on

00:40:43,250 --> 00:40:47,030
things and see the various style

00:40:44,510 --> 00:40:50,870
properties and you can change those by

00:40:47,030 --> 00:40:52,520
using react dev tools so react native

00:40:50,870 --> 00:40:56,120
also supports live reload as you saw

00:40:52,520 --> 00:40:57,680
from Joshua's presentation earlier but

00:40:56,120 --> 00:40:59,990
actually Dan abramoff is joining

00:40:57,680 --> 00:41:02,690
Facebook so I'm really hoping that he'll

00:40:59,990 --> 00:41:04,520
work on live reloading for react native

00:41:02,690 --> 00:41:09,110
he's actually joining the react native

00:41:04,520 --> 00:41:10,490
tooling team so I'm optimistic um in

00:41:09,110 --> 00:41:12,400
terms of sharing your app that's another

00:41:10,490 --> 00:41:15,200
area where the development workflow is

00:41:12,400 --> 00:41:16,790
very different so if you're going to

00:41:15,200 --> 00:41:18,530
share your app on the web and you have

00:41:16,790 --> 00:41:20,270
some local server you might just open up

00:41:18,530 --> 00:41:24,050
an end rock server and sends him on the

00:41:20,270 --> 00:41:26,480
URL so if you're going to do is natively

00:41:24,050 --> 00:41:28,790
you probably have to either send in the

00:41:26,480 --> 00:41:30,590
repo and have them build it or deploy

00:41:28,790 --> 00:41:31,160
the app to the app store or put it on

00:41:30,590 --> 00:41:33,980
something like

00:41:31,160 --> 00:41:35,870
test flight and test flight can take

00:41:33,980 --> 00:41:38,360
hours it can actually take three four

00:41:35,870 --> 00:41:40,670
five hours depending on how slow it is

00:41:38,360 --> 00:41:44,240
that day I mean ideally it doesn't take

00:41:40,670 --> 00:41:46,520
that long but it definitely can with

00:41:44,240 --> 00:41:48,500
react native you could definitely do the

00:41:46,520 --> 00:41:49,790
same sort of thing but you could use

00:41:48,500 --> 00:41:52,460
something like react native playground

00:41:49,790 --> 00:41:55,520
alternatively to share some code or if

00:41:52,460 --> 00:41:57,860
you use exponent you can have your

00:41:55,520 --> 00:42:00,020
friend or co-worker just download the

00:41:57,860 --> 00:42:01,790
exponent app from the App Store and you

00:42:00,020 --> 00:42:04,400
can do the same sort of thing as you do

00:42:01,790 --> 00:42:08,030
on the web and just share this n grok

00:42:04,400 --> 00:42:09,590
URL to access your app when you're done

00:42:08,030 --> 00:42:12,050
you can just hit publish and then anyone

00:42:09,590 --> 00:42:16,370
can access that app with the exponent

00:42:12,050 --> 00:42:20,150
app at any given time and when you're

00:42:16,370 --> 00:42:21,410
finally ready to deploy the app so as I

00:42:20,150 --> 00:42:22,790
said with the exponent you just press

00:42:21,410 --> 00:42:23,990
publish and that's great it doesn't

00:42:22,790 --> 00:42:25,730
actually publish to the app store though

00:42:23,990 --> 00:42:27,950
so if you want to deploy the app to the

00:42:25,730 --> 00:42:31,720
app store you have to wait an average of

00:42:27,950 --> 00:42:34,310
seven days for it to be approved and

00:42:31,720 --> 00:42:36,170
that's a pretty long time because on the

00:42:34,310 --> 00:42:37,910
web what you typically get is on every

00:42:36,170 --> 00:42:40,340
request you have a chance to send them a

00:42:37,910 --> 00:42:41,980
new version of the app right zero

00:42:40,340 --> 00:42:44,690
downtime deploys are pretty common and

00:42:41,980 --> 00:42:47,570
it's just not something that you can do

00:42:44,690 --> 00:42:49,550
with native mobile apps but again that's

00:42:47,570 --> 00:42:51,560
an area where I think react native has a

00:42:49,550 --> 00:42:54,590
bit of an advantage because you can use

00:42:51,560 --> 00:42:58,130
tools like a pub which allow you to send

00:42:54,590 --> 00:42:59,330
app updates over the air so I know

00:42:58,130 --> 00:43:01,880
there's been a concern about that

00:42:59,330 --> 00:43:03,440
earlier but really they the Terms of

00:43:01,880 --> 00:43:06,230
Service indicate and they were updated

00:43:03,440 --> 00:43:10,430
recently to say that you can run code

00:43:06,230 --> 00:43:17,930
from JavaScript core inside of inside of

00:43:10,430 --> 00:43:21,040
your app and download it as well and so

00:43:17,930 --> 00:43:23,420
to add a pup all you need to do is

00:43:21,040 --> 00:43:26,050
basically it's all the SDK and then you

00:43:23,420 --> 00:43:28,930
drop this little bit of code into your

00:43:26,050 --> 00:43:31,010
into your app delegate and it will just

00:43:28,930 --> 00:43:33,020
get the most recent version of your app

00:43:31,010 --> 00:43:35,660
every time you start it and update in

00:43:33,020 --> 00:43:37,280
the background as well so when you

00:43:35,660 --> 00:43:42,740
publish a new version of the app you

00:43:37,280 --> 00:43:43,470
upload your IPA to the app hub dashboard

00:43:42,740 --> 00:43:44,940
and then you

00:43:43,470 --> 00:43:48,510
state publish and that will be sent out

00:43:44,940 --> 00:43:51,390
to everyone who has your app from the

00:43:48,510 --> 00:43:52,890
App Store already another alternative to

00:43:51,390 --> 00:43:55,740
a pub though is something called code

00:43:52,890 --> 00:43:57,960
push so code push does the same thing

00:43:55,740 --> 00:44:00,270
but instead of having a dashboard it's

00:43:57,960 --> 00:44:01,590
all controlled through the CLI so this

00:44:00,270 --> 00:44:04,619
was actually recently open source by

00:44:01,590 --> 00:44:06,210
Microsoft they're using it for Cordova

00:44:04,619 --> 00:44:12,030
projects internally but they've also

00:44:06,210 --> 00:44:14,700
built out a react native SDK acceptance

00:44:12,030 --> 00:44:16,770
testing is is a big thing and continuous

00:44:14,700 --> 00:44:18,990
integration with with native app

00:44:16,770 --> 00:44:20,849
development because if you want to test

00:44:18,990 --> 00:44:22,530
your iOS app and you want to test it end

00:44:20,849 --> 00:44:25,440
to end you're going to need to run it on

00:44:22,530 --> 00:44:27,060
a mac circle see I supports that and so

00:44:25,440 --> 00:44:30,480
is Travis but there are some issues with

00:44:27,060 --> 00:44:32,730
it being a bit flaky so what you can do

00:44:30,480 --> 00:44:36,119
alternatively is by rack of mac minis

00:44:32,730 --> 00:44:37,200
and just set them up in your office but

00:44:36,119 --> 00:44:39,300
one of the great things about writing

00:44:37,200 --> 00:44:41,880
your app with react native is that now a

00:44:39,300 --> 00:44:44,849
lot of your app is just JavaScript right

00:44:41,880 --> 00:44:48,900
so you don't need to test it necessarily

00:44:44,849 --> 00:44:52,740
entirely on something like a Mac if

00:44:48,900 --> 00:44:54,630
that's the platform they're using now a

00:44:52,740 --> 00:44:56,130
caveat to that is that there aren't

00:44:54,630 --> 00:44:57,780
really a lot of best practices at the

00:44:56,130 --> 00:45:00,450
moment in the react native community for

00:44:57,780 --> 00:45:03,390
testing components hopefully that's

00:45:00,450 --> 00:45:07,470
something that that emerges soon but

00:45:03,390 --> 00:45:09,330
it's still an early project ok and a

00:45:07,470 --> 00:45:11,910
couple of exceptions to these

00:45:09,330 --> 00:45:16,440
constraints there are actually some

00:45:11,910 --> 00:45:18,540
advantages as well so imagine if with

00:45:16,440 --> 00:45:21,060
your website you could ship a custom

00:45:18,540 --> 00:45:22,800
build of chrome so would give you all

00:45:21,060 --> 00:45:24,690
the power to customize anything that you

00:45:22,800 --> 00:45:26,040
want at a low level and this is

00:45:24,690 --> 00:45:28,410
essentially what you get with mobile

00:45:26,040 --> 00:45:31,589
apps so here's an example from the

00:45:28,410 --> 00:45:32,700
issues react native issues where someone

00:45:31,589 --> 00:45:35,550
was saying they built a yearly calendar

00:45:32,700 --> 00:45:36,750
component and it was made up over 400

00:45:35,550 --> 00:45:39,570
views and it was taking three to five

00:45:36,750 --> 00:45:42,570
seconds to render which is obviously

00:45:39,570 --> 00:45:43,740
unacceptably slow someone suggested that

00:45:42,570 --> 00:45:45,150
you would probably even have that

00:45:43,740 --> 00:45:46,470
problem if you weren't using react

00:45:45,150 --> 00:45:48,510
native if you're just using UI kit

00:45:46,470 --> 00:45:52,109
suggested maybe trying a lower level

00:45:48,510 --> 00:45:53,760
primitive core animation layer so you

00:45:52,109 --> 00:45:55,790
went ahead and implemented that and you

00:45:53,760 --> 00:45:57,890
can see on one side I'll let you

00:45:55,790 --> 00:46:00,710
which one is which is the unoptimized

00:45:57,890 --> 00:46:02,960
one and on the other side is optimized

00:46:00,710 --> 00:46:04,720
and so you get quite a quite a benefit

00:46:02,960 --> 00:46:07,210
in terms of performance there by just

00:46:04,720 --> 00:46:09,440
dropping down to a lower level and

00:46:07,210 --> 00:46:11,090
ultimately the API that he ended up with

00:46:09,440 --> 00:46:14,270
exposed to JavaScript looked like this

00:46:11,090 --> 00:46:16,790
so just ended up with a react component

00:46:14,270 --> 00:46:20,780
and many had to write some objective c

00:46:16,790 --> 00:46:23,780
for it or Swift but it's exposed in the

00:46:20,780 --> 00:46:27,290
end as as a rack component you can use

00:46:23,780 --> 00:46:28,580
it in that way afterwards another

00:46:27,290 --> 00:46:30,620
alternative to doing it this way would

00:46:28,580 --> 00:46:32,930
have just been to use react native arch

00:46:30,620 --> 00:46:34,370
so that lets you access these lower

00:46:32,930 --> 00:46:36,560
level drawing primitives directly as

00:46:34,370 --> 00:46:40,310
well but doesn't require you to write

00:46:36,560 --> 00:46:43,100
any additional native code the other

00:46:40,310 --> 00:46:45,200
advantage is multi-threading so in the

00:46:43,100 --> 00:46:47,600
web browser javascript runs on the main

00:46:45,200 --> 00:46:51,400
thread and it can prevent user input

00:46:47,600 --> 00:46:54,440
from being handled if it blocks so

00:46:51,400 --> 00:46:56,000
another issue there is that images are

00:46:54,440 --> 00:46:58,280
decoded on the main thread so if you're

00:46:56,000 --> 00:46:59,630
scrolling and you're loading an image at

00:46:58,280 --> 00:47:03,760
the same time you might feel a little

00:46:59,630 --> 00:47:06,430
bit of gencon that whereas on mobile and

00:47:03,760 --> 00:47:08,780
specifically with react native

00:47:06,430 --> 00:47:10,850
everything well several things happen on

00:47:08,780 --> 00:47:12,500
various different threads and so what

00:47:10,850 --> 00:47:15,350
you're seeing here actually is I just

00:47:12,500 --> 00:47:17,090
simulate a very slow action in the

00:47:15,350 --> 00:47:18,830
browser that takes a few seconds and I'm

00:47:17,090 --> 00:47:20,600
trying to scroll at the same time it's

00:47:18,830 --> 00:47:22,280
not working if I hover over some text

00:47:20,600 --> 00:47:24,320
it's not working and so this is what

00:47:22,280 --> 00:47:27,200
you'll probably see happen but at a less

00:47:24,320 --> 00:47:30,860
exaggerated scale if you do anything

00:47:27,200 --> 00:47:32,660
complicated in your app and a nice thing

00:47:30,860 --> 00:47:35,330
with I was saying with react native is

00:47:32,660 --> 00:47:38,600
now you have the handling of the user

00:47:35,330 --> 00:47:41,510
input on the main thread and then we run

00:47:38,600 --> 00:47:43,160
the rendering logic and such on the

00:47:41,510 --> 00:47:45,020
react native thread which is the

00:47:43,160 --> 00:47:47,150
JavaScript thread and so here when i

00:47:45,020 --> 00:47:49,820
press this filter button it's performing

00:47:47,150 --> 00:47:51,710
that same coat that same block of code

00:47:49,820 --> 00:47:53,660
that i was running in the browser and so

00:47:51,710 --> 00:47:54,980
it's blocking the UI briefly but i can

00:47:53,660 --> 00:47:57,710
still scroll because that's handled

00:47:54,980 --> 00:48:00,380
natively on the native thread the actual

00:47:57,710 --> 00:48:06,260
alert that shows up doesn't happen until

00:48:00,380 --> 00:48:08,650
we've yielded to the JavaScript rim so a

00:48:06,260 --> 00:48:10,029
bit of an issue with that is that now

00:48:08,650 --> 00:48:12,369
all the communication between these

00:48:10,029 --> 00:48:14,500
threads is asynchronous so with react

00:48:12,369 --> 00:48:17,049
native if we want to measure the width

00:48:14,500 --> 00:48:19,299
height XY position we actually have to

00:48:17,049 --> 00:48:22,690
make a call to the native side and wait

00:48:19,299 --> 00:48:24,609
a frame for it to respond with the Dom

00:48:22,690 --> 00:48:26,470
right it's on the same thread so you can

00:48:24,609 --> 00:48:30,099
just grab the offset with directly from

00:48:26,470 --> 00:48:32,770
there a nicer way to do that is probably

00:48:30,099 --> 00:48:34,630
to use async await with react native so

00:48:32,770 --> 00:48:36,369
this transform is enabled by default and

00:48:34,630 --> 00:48:40,240
you can definitely use this to clean up

00:48:36,369 --> 00:48:43,630
a lot of callbacks all right last thing

00:48:40,240 --> 00:48:45,099
running out of time is a more AP is so

00:48:43,630 --> 00:48:47,619
there are a lot of high quality UI

00:48:45,099 --> 00:48:48,700
widgets right i mean native you get a

00:48:47,619 --> 00:48:49,990
lot of this stuff out there you don't

00:48:48,700 --> 00:48:51,789
there's a reason why there's no

00:48:49,990 --> 00:48:53,859
bootstrap native right because you don't

00:48:51,789 --> 00:48:56,410
need it you get a lot of really nice

00:48:53,859 --> 00:48:58,839
components just out of the box whether

00:48:56,410 --> 00:49:01,599
it's like a map or some sort of picker

00:48:58,839 --> 00:49:04,150
like a date picker or a calendar drawer

00:49:01,599 --> 00:49:06,910
layout toolbar tab bar various types of

00:49:04,150 --> 00:49:09,160
toasts and alerts scrollview view pager

00:49:06,910 --> 00:49:11,109
etc you can actually view all these by

00:49:09,160 --> 00:49:13,510
cloning the react native repo and going

00:49:11,109 --> 00:49:17,230
to the UI Explorer and running that and

00:49:13,510 --> 00:49:20,079
just clicking around another API to deal

00:49:17,230 --> 00:49:22,869
with is execution states so on the web

00:49:20,079 --> 00:49:24,160
your app is either open or it's just not

00:49:22,869 --> 00:49:27,700
open you don't have it open in the

00:49:24,160 --> 00:49:30,010
browser so that's a bit different on

00:49:27,700 --> 00:49:32,980
mobile where you can have not running an

00:49:30,010 --> 00:49:35,170
active active etc you can run tasks in

00:49:32,980 --> 00:49:36,849
the background you can be launched from

00:49:35,170 --> 00:49:38,500
a push notification or from a quick

00:49:36,849 --> 00:49:40,420
action they're different ways to

00:49:38,500 --> 00:49:42,130
transition between these states and so

00:49:40,420 --> 00:49:45,579
this is just a whole other set of API is

00:49:42,130 --> 00:49:48,039
that you would want to be aware of there

00:49:45,579 --> 00:49:49,839
was OS integration so are you going to

00:49:48,039 --> 00:49:54,430
index your app in spotlight if you do

00:49:49,839 --> 00:49:56,890
then how you respond to being told to

00:49:54,430 --> 00:49:59,440
open from spotlight for a certain route

00:49:56,890 --> 00:50:01,299
you have to build the whole navigation

00:49:59,440 --> 00:50:03,730
stack for that specific route and bring

00:50:01,299 --> 00:50:05,849
the user to that section you have to

00:50:03,730 --> 00:50:07,990
actually perform the indexing manually

00:50:05,849 --> 00:50:12,490
and there's like widgets on Android and

00:50:07,990 --> 00:50:14,529
that sort of thing all right and lastly

00:50:12,490 --> 00:50:17,140
there are just a lot of other fun API

00:50:14,529 --> 00:50:19,480
sand and applications that you can do

00:50:17,140 --> 00:50:21,190
with mobile just by having this device

00:50:19,480 --> 00:50:23,800
in your pocket with all these sensors

00:50:21,190 --> 00:50:24,849
and an internet connection it opens up a

00:50:23,800 --> 00:50:27,250
lot of possibilities that you can't

00:50:24,849 --> 00:50:31,329
really do on on the desktop or

00:50:27,250 --> 00:50:32,940
especially on the web so one of these

00:50:31,329 --> 00:50:34,900
examples is friend of mine made a

00:50:32,940 --> 00:50:38,920
geofencing app that opens his garage

00:50:34,900 --> 00:50:41,230
door automatically the Arduino thing

00:50:38,920 --> 00:50:43,900
which you saw in the lightning talk and

00:50:41,230 --> 00:50:45,790
various other things so yeah mobile is

00:50:43,900 --> 00:50:50,140
different for these three key reasons I

00:50:45,790 --> 00:50:51,730
believe with react native at least you

00:50:50,140 --> 00:50:54,630
get to use this consistent set of

00:50:51,730 --> 00:50:56,740
technologies across web iOS and Android

00:50:54,630 --> 00:50:59,079
but there are still some new things to

00:50:56,740 --> 00:51:00,730
learn and I hope I've covered a lot of

00:50:59,079 --> 00:51:02,890
those new things even if it was fairly

00:51:00,730 --> 00:51:05,079
rapid fire but I encourage you to give

00:51:02,890 --> 00:51:08,079
react native a try and go to native

00:51:05,079 --> 00:51:10,780
react Jess com or exponent jazz calm or

00:51:08,079 --> 00:51:12,599
on play org whatever you choose just

00:51:10,780 --> 00:51:20,710
give it a try and I think you'll like it

00:51:12,599 --> 00:51:23,260
thank you whoa

00:51:20,710 --> 00:51:24,760
nice I think we have time for one or two

00:51:23,260 --> 00:51:27,089
questions and then we have to move on

00:51:24,760 --> 00:51:31,859
all right I can answer the first one no

00:51:27,089 --> 00:51:34,480
next one it was easy the conference app

00:51:31,859 --> 00:51:37,720
yes all of the conference on apps are

00:51:34,480 --> 00:51:39,250
available if you go to react native CC

00:51:37,720 --> 00:51:41,589
which is a newsletter that I run for

00:51:39,250 --> 00:51:44,050
react native I believe in the second

00:51:41,589 --> 00:51:46,720
most recent issue I link to all of the

00:51:44,050 --> 00:51:51,070
conference entries yeah so you can get

00:51:46,720 --> 00:51:54,369
it there ok react native compares to

00:51:51,070 --> 00:51:57,010
native script a so essentially native

00:51:54,369 --> 00:51:59,320
script runs synchronously so as i was

00:51:57,010 --> 00:52:00,849
showing before with react native when

00:51:59,320 --> 00:52:03,190
you're communicating between the native

00:52:00,849 --> 00:52:04,510
thread and the JavaScript read this is

00:52:03,190 --> 00:52:08,369
all happening through an asynchronous

00:52:04,510 --> 00:52:11,560
bridge native script you're essentially

00:52:08,369 --> 00:52:13,900
you're writing JavaScript that is the

00:52:11,560 --> 00:52:18,640
same it calls the exact same functions

00:52:13,900 --> 00:52:20,740
as in as in the host platform so it

00:52:18,640 --> 00:52:25,030
happens on the same thread and there are

00:52:20,740 --> 00:52:28,030
other yeah lots it's a big topic yeah

00:52:25,030 --> 00:52:30,670
we're going to the next one SVG and

00:52:28,030 --> 00:52:33,580
react native I have a library for that

00:52:30,670 --> 00:52:36,010
that you can use I haven't really made

00:52:33,580 --> 00:52:38,290
it so robust but if you want to submit a

00:52:36,010 --> 00:52:39,550
pull requests and make that work I mean

00:52:38,290 --> 00:52:42,760
it works if you want to make it better

00:52:39,550 --> 00:52:44,710
go for it similarly you can use react

00:52:42,760 --> 00:52:46,810
native art like I mentioned before which

00:52:44,710 --> 00:52:48,550
allows you to do a lot of SPG style of

00:52:46,810 --> 00:52:51,220
drawing as well as animate those

00:52:48,550 --> 00:52:54,040
components however you like so that's a

00:52:51,220 --> 00:52:57,089
yeah boom that good boom thank you so

00:52:54,040 --> 00:52:57,089

YouTube URL: https://www.youtube.com/watch?v=-XxSCi8TKuk


