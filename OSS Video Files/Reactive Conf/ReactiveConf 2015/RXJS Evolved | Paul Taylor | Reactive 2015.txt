Title: RXJS Evolved | Paul Taylor | Reactive 2015
Publication date: 2017-06-29
Playlist: ReactiveConf 2015
Description: 
	Reactive Extensions for JavaScript is evolving! Building on lessons learned from RxJava and RxMobile, Microsoft Netflix, Google, and the ReactiveX community have begun work on the next version of RxJS. This talk will enumerate the improvements we’ve made to increase speed, reduce memory, expose locations for extension, provide more debuggable call-stacks, and enable more readable flame charts.

Paul is a consultant in San Francisco, CA, and former lead engineer on FalcorJS on Netflix’sUI Platform team.
Captions: 
	00:00:06,179 --> 00:00:14,410
well hello again you guys already know

00:00:10,959 --> 00:00:17,529
me if you were more awake than I was

00:00:14,410 --> 00:00:20,080
this morning I am gonna talk about

00:00:17,529 --> 00:00:23,320
evolving reactive extensions for

00:00:20,080 --> 00:00:26,590
JavaScript so before I get started just

00:00:23,320 --> 00:00:31,349
hands up or not at me or something if

00:00:26,590 --> 00:00:35,020
you you've heard of rx or views da recs

00:00:31,349 --> 00:00:37,059
cool that's more hands than I expected

00:00:35,020 --> 00:00:39,699
how about people who would consider

00:00:37,059 --> 00:00:44,889
themselves even slightly above beginner

00:00:39,699 --> 00:00:46,690
level maybe oh that guy right there

00:00:44,889 --> 00:00:48,460
all right cool well actually that's

00:00:46,690 --> 00:00:50,679
perfect because I tried to make the

00:00:48,460 --> 00:00:53,289
first half of my talk a intense

00:00:50,679 --> 00:00:56,699
introduction whereas the second half of

00:00:53,289 --> 00:01:01,600
my talk is going to be flying into space

00:00:56,699 --> 00:01:03,609
so cool well that's who I am and I'm

00:01:01,600 --> 00:01:06,850
gonna introduce the observable type to

00:01:03,609 --> 00:01:08,170
everybody and if you've read a little

00:01:06,850 --> 00:01:10,000
bit about the observable type or you've

00:01:08,170 --> 00:01:12,730
heard some people talk about it

00:01:10,000 --> 00:01:14,680
it might sound just like another event

00:01:12,730 --> 00:01:16,180
emitter or event dispatcher or thing

00:01:14,680 --> 00:01:17,890
that you've subscribed to you give it a

00:01:16,180 --> 00:01:20,950
callback and then it it gives you some

00:01:17,890 --> 00:01:23,830
data later which is partly true but the

00:01:20,950 --> 00:01:26,500
observable is absolutely not in any way

00:01:23,830 --> 00:01:28,660
like even remotely related to any of

00:01:26,500 --> 00:01:31,920
these concepts right here and that's the

00:01:28,660 --> 00:01:34,270
biggest hurdle LearningRx is we all know

00:01:31,920 --> 00:01:39,090
reactive programming we all use event

00:01:34,270 --> 00:01:44,230
handlers and get callbacks later but

00:01:39,090 --> 00:01:45,790
nothing is nothing is rx all of these

00:01:44,230 --> 00:01:48,190
guys are essentially the same thing

00:01:45,790 --> 00:01:49,390
they're an array of callbacks you can

00:01:48,190 --> 00:01:50,920
call a function

00:01:49,390 --> 00:01:52,630
that'll iterate over the array and then

00:01:50,920 --> 00:01:55,150
call all those callbacks with the same

00:01:52,630 --> 00:02:00,280
piece of data that's all of these guys

00:01:55,150 --> 00:02:06,340
do that an observable in my words is the

00:02:00,280 --> 00:02:06,970
idea of future values maybe but what

00:02:06,340 --> 00:02:09,340
does that mean

00:02:06,970 --> 00:02:14,560
so I'll take a look at some other ideas

00:02:09,340 --> 00:02:17,019
of future values in the first quadrant

00:02:14,560 --> 00:02:17,819
we've got functions and it may seem

00:02:17,019 --> 00:02:20,670
straight

00:02:17,819 --> 00:02:22,920
to call a function an idea of a value

00:02:20,670 --> 00:02:26,249
but ultimately that that's kind of what

00:02:22,920 --> 00:02:30,090
it is it's not the value yet it produces

00:02:26,249 --> 00:02:32,249
a value whenever you you want it to but

00:02:30,090 --> 00:02:35,480
functions are synchronous so a function

00:02:32,249 --> 00:02:37,439
can synchronously give you back a value

00:02:35,480 --> 00:02:38,849
something that can synchronously give

00:02:37,439 --> 00:02:42,090
you back multiple values would be an

00:02:38,849 --> 00:02:43,530
enumerable something that can a

00:02:42,090 --> 00:02:47,159
synchronously give you back a single

00:02:43,530 --> 00:02:49,530
value is promise and then an observable

00:02:47,159 --> 00:02:52,980
is something that can a synchronously

00:02:49,530 --> 00:02:54,959
give you back multiple values I don't

00:02:52,980 --> 00:02:56,010
particularly like talking about it in

00:02:54,959 --> 00:02:57,959
terms of synchronous versus asynchronous

00:02:56,010 --> 00:03:00,419
because they kind of imply that

00:02:57,959 --> 00:03:03,930
asynchronous will always be some point

00:03:00,419 --> 00:03:06,590
in the future instead I like to think

00:03:03,930 --> 00:03:11,549
about it in terms of pole versus push

00:03:06,590 --> 00:03:14,459
and these concepts really apply to they

00:03:11,549 --> 00:03:18,000
relate to who's consuming one of these

00:03:14,459 --> 00:03:20,280
ideas of values so if you're a function

00:03:18,000 --> 00:03:22,379
or an enumerable and you're the consumer

00:03:20,280 --> 00:03:24,720
you're gonna pull the value you get to

00:03:22,379 --> 00:03:27,269
decide when you want the value if you're

00:03:24,720 --> 00:03:31,590
an enumerable you get to you know do a

00:03:27,269 --> 00:03:33,359
for loop over it but if you're these two

00:03:31,590 --> 00:03:36,269
bottom guys it's it's it's actually

00:03:33,359 --> 00:03:38,340
inverted the promise or the observable

00:03:36,269 --> 00:03:40,590
decides when the consumer receives a

00:03:38,340 --> 00:03:43,489
value and the consumer doesn't really

00:03:40,590 --> 00:03:47,280
have any choice when it gets that value

00:03:43,489 --> 00:03:49,919
so let's talk about the just basic

00:03:47,280 --> 00:03:52,139
functions this is kind of what I mean

00:03:49,919 --> 00:03:53,459
when I say it's an idea of a value we

00:03:52,139 --> 00:03:55,019
can instantiate a function in this case

00:03:53,459 --> 00:03:57,900
a function that returns a so random

00:03:55,019 --> 00:04:01,019
number but we haven't really done

00:03:57,900 --> 00:04:03,090
anything except like create that idea of

00:04:01,019 --> 00:04:06,750
a future random number but at the bottom

00:04:03,090 --> 00:04:09,329
here we then go and get that value this

00:04:06,750 --> 00:04:11,969
is also referred to as laziness a lot of

00:04:09,329 --> 00:04:16,469
people see the word lazy and either

00:04:11,969 --> 00:04:18,599
think slacking off or that it's related

00:04:16,469 --> 00:04:20,280
to something else that's really the

00:04:18,599 --> 00:04:23,159
concept that you instantiate some sort

00:04:20,280 --> 00:04:28,500
of wrapper that later when you want you

00:04:23,159 --> 00:04:32,040
can invoke and get the value from it so

00:04:28,500 --> 00:04:37,410
the anatomy of an observable is if an

00:04:32,040 --> 00:04:41,010
observable is the idea of future values

00:04:37,410 --> 00:04:42,860
maybe then just like with functions with

00:04:41,010 --> 00:04:45,240
observables there's the creation step

00:04:42,860 --> 00:04:47,340
then there's the subscription step which

00:04:45,240 --> 00:04:49,110
is analogous to calling the observable I

00:04:47,340 --> 00:04:50,430
like you would call a function but then

00:04:49,110 --> 00:04:54,860
the observable has something that a

00:04:50,430 --> 00:04:54,860
functions don't have which is disposal

00:04:54,950 --> 00:04:58,920
so when you call a function if in a

00:04:57,780 --> 00:05:01,920
single-threaded language there's really

00:04:58,920 --> 00:05:03,510
no way to interrupt the function you you

00:05:01,920 --> 00:05:05,700
invoke it and then it gives you back the

00:05:03,510 --> 00:05:08,580
value but with an observable especially

00:05:05,700 --> 00:05:10,320
whenever it could give you those values

00:05:08,580 --> 00:05:11,280
over time you you might want to cancel

00:05:10,320 --> 00:05:13,650
it you might want to stock with stop

00:05:11,280 --> 00:05:16,380
listening and tell it to shut up and

00:05:13,650 --> 00:05:18,180
that's where disposal comes in so right

00:05:16,380 --> 00:05:19,590
here just to break this down here's kind

00:05:18,180 --> 00:05:21,240
of a creation step if we're just gonna

00:05:19,590 --> 00:05:23,490
create an observable that's gonna give

00:05:21,240 --> 00:05:26,840
us random numbers in the future we can

00:05:23,490 --> 00:05:29,400
just do it with the observable create

00:05:26,840 --> 00:05:33,240
Factory and that just takes a subscriber

00:05:29,400 --> 00:05:34,650
function the subscriber function

00:05:33,240 --> 00:05:36,210
actually gets run whenever you

00:05:34,650 --> 00:05:39,660
subscribes like every single subscriber

00:05:36,210 --> 00:05:41,880
will reinvest so in our case this

00:05:39,660 --> 00:05:45,600
function is going to instantiate or

00:05:41,880 --> 00:05:49,800
gonna allocate a set timeout callback

00:05:45,600 --> 00:05:51,960
for 1000 milliseconds from now and then

00:05:49,800 --> 00:05:54,300
here's the third step disposal that

00:05:51,960 --> 00:05:57,570
functions don't have you can't interrupt

00:05:54,300 --> 00:05:59,490
functions but this theoretically after

00:05:57,570 --> 00:06:01,290
you subscribed but before the set

00:05:59,490 --> 00:06:03,270
timeout who triggered you could decide

00:06:01,290 --> 00:06:04,979
to throw away your subscription and we

00:06:03,270 --> 00:06:07,910
want to clean up that memory we wouldn't

00:06:04,979 --> 00:06:10,830
want this set timeout to keep going and

00:06:07,910 --> 00:06:12,540
so this last step right here I marked

00:06:10,830 --> 00:06:15,479
with a pink star because this is

00:06:12,540 --> 00:06:17,910
actually where we call random numbers

00:06:15,479 --> 00:06:19,680
dot subscribe that's actually like the

00:06:17,910 --> 00:06:23,710
same thing as doing function dot apply

00:06:19,680 --> 00:06:26,680
or function call so

00:06:23,710 --> 00:06:29,169
and this is like one of my favorite

00:06:26,680 --> 00:06:30,639
little tests once I once I tell people

00:06:29,169 --> 00:06:33,370
that they're like oh yeah I totally get

00:06:30,639 --> 00:06:35,530
that all right but then I heard this out

00:06:33,370 --> 00:06:38,560
so if I just have this random numbers

00:06:35,530 --> 00:06:42,370
observable and I subscribe to it twice

00:06:38,560 --> 00:06:45,039
and then I print out the results what do

00:06:42,370 --> 00:06:47,530
you think happens a lot of people say

00:06:45,039 --> 00:06:51,009
the same random number gets printed and

00:06:47,530 --> 00:06:53,830
I don't fault them for that that's the

00:06:51,009 --> 00:06:56,289
that's the event emitter model but this

00:06:53,830 --> 00:06:57,370
is what happens the first guy gets a

00:06:56,289 --> 00:06:59,190
random number it's second guy gets a

00:06:57,370 --> 00:07:05,860
completely different random number and

00:06:59,190 --> 00:07:07,509
here's why so when we create it and then

00:07:05,860 --> 00:07:08,620
we subscribe to it then we run the the

00:07:07,509 --> 00:07:12,130
subscriber function for the first

00:07:08,620 --> 00:07:14,110
subscription which call set timeout then

00:07:12,130 --> 00:07:16,840
we run the subscriber function for the

00:07:14,110 --> 00:07:18,310
second subscription and then eventually

00:07:16,840 --> 00:07:21,759
our set timeout completes for the first

00:07:18,310 --> 00:07:23,949
thing and we call subscriber next

00:07:21,759 --> 00:07:28,150
impassive math dot random and then we

00:07:23,949 --> 00:07:30,550
call subscriber not complete then set

00:07:28,150 --> 00:07:34,240
timeout for the second subscription

00:07:30,550 --> 00:07:36,099
number two also resolves and then we

00:07:34,240 --> 00:07:40,150
pass the second subscriber a different

00:07:36,099 --> 00:07:42,220
random number so just like if this were

00:07:40,150 --> 00:07:43,780
a function and you called this random

00:07:42,220 --> 00:07:45,460
numbers function twice you would get two

00:07:43,780 --> 00:07:47,800
different random numbers yet I mean

00:07:45,460 --> 00:07:52,120
that's all it is an observable is a

00:07:47,800 --> 00:07:53,770
future function so observables aren't

00:07:52,120 --> 00:07:55,630
event emitters event dispatches event

00:07:53,770 --> 00:07:58,900
delegates what are they they are

00:07:55,630 --> 00:08:00,909
functions and here's my real definition

00:07:58,900 --> 00:08:02,740
for observable this is what I tell to

00:08:00,909 --> 00:08:04,630
people when I want to freak them out I

00:08:02,740 --> 00:08:06,729
say observable as a function that when

00:08:04,630 --> 00:08:10,599
invoked returns 0 to infinity values

00:08:06,729 --> 00:08:12,490
between now and the end of time which I

00:08:10,599 --> 00:08:16,210
think it's a pretty accurate you know

00:08:12,490 --> 00:08:19,060
answer observables have operators and

00:08:16,210 --> 00:08:20,560
what are operators operators are methods

00:08:19,060 --> 00:08:23,080
that perform calculations on the values

00:08:20,560 --> 00:08:25,780
things like map filter scan reduce

00:08:23,080 --> 00:08:27,759
familiar with the array extras or lodash

00:08:25,780 --> 00:08:29,199
or underscore then you'll be familiar

00:08:27,759 --> 00:08:30,639
with a lot of these but then observable

00:08:29,199 --> 00:08:32,560
also has a lot of ones that are specific

00:08:30,639 --> 00:08:34,570
to it if you talked about asynchronous

00:08:32,560 --> 00:08:37,450
values and you're talking about temporal

00:08:34,570 --> 00:08:40,450
operators like delay debounce

00:08:37,450 --> 00:08:43,120
time interval throttle some people call

00:08:40,450 --> 00:08:50,080
it low - for events I don't call it that

00:08:43,120 --> 00:08:51,520
but you can so what does an operator

00:08:50,080 --> 00:08:53,890
actually look like like this is just

00:08:51,520 --> 00:08:55,150
kind of a real basic crash course

00:08:53,890 --> 00:08:58,360
introduction there's a lot more to this

00:08:55,150 --> 00:08:59,980
but if we had kind of this basic

00:08:58,360 --> 00:09:01,540
structure of an observable where the

00:08:59,980 --> 00:09:04,810
constructor takes to subscribe function

00:09:01,540 --> 00:09:07,150
it just puts it on itself and then it

00:09:04,810 --> 00:09:10,180
also defines the map operator well the

00:09:07,150 --> 00:09:13,690
map operator takes a function it's going

00:09:10,180 --> 00:09:15,220
to return a new observable what we have

00:09:13,690 --> 00:09:16,750
to do is we have to say that who we

00:09:15,220 --> 00:09:18,580
currently are so that when someone

00:09:16,750 --> 00:09:20,920
subscribes to this new observable they

00:09:18,580 --> 00:09:23,920
can they can we can call back to our

00:09:20,920 --> 00:09:25,510
source and map the events that our

00:09:23,920 --> 00:09:31,090
source is going to give us so in this

00:09:25,510 --> 00:09:33,160
way we kind of create this chain so if

00:09:31,090 --> 00:09:35,200
we just have this observable chain

00:09:33,160 --> 00:09:37,300
observable that of creates an observable

00:09:35,200 --> 00:09:39,520
that will on next the arguments that you

00:09:37,300 --> 00:09:43,150
give it then we have all these cool

00:09:39,520 --> 00:09:44,830
filters that we can apply functions over

00:09:43,150 --> 00:09:52,060
the events and change them as they go

00:09:44,830 --> 00:09:59,980
through all right so this part I usually

00:09:52,060 --> 00:10:03,180
don't talk about because even people who

00:09:59,980 --> 00:10:06,070
like our X don't like schedulers

00:10:03,180 --> 00:10:07,840
schedulers are centralized dispatchers

00:10:06,070 --> 00:10:10,450
to control concurrency and the reason

00:10:07,840 --> 00:10:12,610
I'm talking about this is because the

00:10:10,450 --> 00:10:14,790
rest of my talk has a lot to do with

00:10:12,610 --> 00:10:17,170
this part this is really kind of a deep

00:10:14,790 --> 00:10:19,450
inside part of rx that a lot of people

00:10:17,170 --> 00:10:22,120
don't really have to worry about but

00:10:19,450 --> 00:10:23,200
they're they're absolutely key if you've

00:10:22,120 --> 00:10:24,610
got all if you're thinking about you

00:10:23,200 --> 00:10:26,410
have all these asynchronous observables

00:10:24,610 --> 00:10:28,030
happening you might subscribe to this

00:10:26,410 --> 00:10:29,380
one and that one they might be getting

00:10:28,030 --> 00:10:30,790
events in at different times you really

00:10:29,380 --> 00:10:32,920
want to kind of send them through a

00:10:30,790 --> 00:10:35,050
central dispatcher or be able to

00:10:32,920 --> 00:10:36,550
coordinate it in some way and that's

00:10:35,050 --> 00:10:38,740
really what schedules schedulers give

00:10:36,550 --> 00:10:40,330
you so there's a couple different

00:10:38,740 --> 00:10:42,460
schedulers in rx there's the immediate

00:10:40,330 --> 00:10:43,330
scheduler which does sort of has sort of

00:10:42,460 --> 00:10:46,420
a trampolining

00:10:43,330 --> 00:10:48,070
it pushes actions onto a queue and pops

00:10:46,420 --> 00:10:49,720
them off in a while loop there's the

00:10:48,070 --> 00:10:50,319
time out scheduler which just uses that

00:10:49,720 --> 00:10:52,269
time out

00:10:50,319 --> 00:10:54,069
the requestanimationframe scheduler is

00:10:52,269 --> 00:10:57,939
one of my favorites because it allows

00:10:54,069 --> 00:11:01,119
you to very easily synchronize going

00:10:57,939 --> 00:11:07,839
from bottle updates to Dom rendering

00:11:01,119 --> 00:11:09,699
without threshing uh the Dom so what do

00:11:07,839 --> 00:11:12,669
schedulers look like if I was gonna

00:11:09,699 --> 00:11:14,410
create the range operator range is kind

00:11:12,669 --> 00:11:16,600
of like like lo dashes range you give it

00:11:14,410 --> 00:11:18,249
like a start value and a length and then

00:11:16,600 --> 00:11:20,410
it you know that lo - it would give you

00:11:18,249 --> 00:11:22,209
back an array of all those numbers well

00:11:20,410 --> 00:11:25,899
and observable we want to just iterate

00:11:22,209 --> 00:11:27,999
and create those numbers lazily but you

00:11:25,899 --> 00:11:29,979
can give the range an optional scheduler

00:11:27,999 --> 00:11:32,079
and this is really what happens with the

00:11:29,979 --> 00:11:36,729
scheduler scheduler has a scheduled

00:11:32,079 --> 00:11:38,079
method that takes up takes a closure and

00:11:36,729 --> 00:11:40,749
then optionally some state at the end

00:11:38,079 --> 00:11:43,239
and then what you can do is the action

00:11:40,749 --> 00:11:44,949
can recursively reschedule itself until

00:11:43,239 --> 00:11:47,049
it decides that it's done and it doesn't

00:11:44,949 --> 00:11:49,269
need to anymore this is really just

00:11:47,049 --> 00:11:53,319
there to blow your minds

00:11:49,269 --> 00:11:55,329
you don't really have to read it but

00:11:53,319 --> 00:11:56,649
schedulers are also useful they can be

00:11:55,329 --> 00:11:59,079
passed into certain operators like in

00:11:56,649 --> 00:12:01,329
this case I've got a mouse move event

00:11:59,079 --> 00:12:02,949
that might happen super fast well I want

00:12:01,329 --> 00:12:05,559
to throttle but I want to throttle on

00:12:02,949 --> 00:12:08,879
the requestanimationframe so that way I

00:12:05,559 --> 00:12:12,059
only call my react dot render down here

00:12:08,879 --> 00:12:14,679
whenever the browser is ready to paint

00:12:12,059 --> 00:12:18,419
whoo all right that was the crash course

00:12:14,679 --> 00:12:20,709
into rx I hope you guys understood it

00:12:18,419 --> 00:12:23,319
this is really what this next talk this

00:12:20,709 --> 00:12:28,389
talk is actually about the next version

00:12:23,319 --> 00:12:31,299
of rx it's officially gonna be number

00:12:28,389 --> 00:12:34,299
five that's been sanctioned by the team

00:12:31,299 --> 00:12:35,829
at Microsoft and it's available at

00:12:34,299 --> 00:12:39,970
github khamseh less reactive X slash

00:12:35,829 --> 00:12:42,879
rxjs and we have an amazing contributor

00:12:39,970 --> 00:12:45,220
list in addition to companies like where

00:12:42,879 --> 00:12:47,350
I worked we've got people from the

00:12:45,220 --> 00:12:51,659
Google team obviously the rx team at

00:12:47,350 --> 00:12:54,039
Microsoft mr. Andre stalls over there

00:12:51,659 --> 00:12:56,139
been at Netflix has been instrumental

00:12:54,039 --> 00:12:57,819
he's kind of the project lead he

00:12:56,139 --> 00:13:00,819
coordinates everything he's big into

00:12:57,819 --> 00:13:02,049
open source and this Oh Jake want over

00:13:00,819 --> 00:13:04,030
here I don't know where the hell he came

00:13:02,049 --> 00:13:06,640
from but I'm glad he's here

00:13:04,030 --> 00:13:09,940
these guys are prolific they've written

00:13:06,640 --> 00:13:11,200
way more code than I have an Rx so the

00:13:09,940 --> 00:13:13,000
rest of the contributors are also

00:13:11,200 --> 00:13:16,390
important I just can't talk about them

00:13:13,000 --> 00:13:20,830
all ah so the primary goals for this

00:13:16,390 --> 00:13:22,630
version of our X is modularity improving

00:13:20,830 --> 00:13:26,470
performance improving the debugging

00:13:22,630 --> 00:13:28,570
story improving extensibility like but

00:13:26,470 --> 00:13:31,300
if you want to extend observable and

00:13:28,570 --> 00:13:34,960
then also writing much easier to read

00:13:31,300 --> 00:13:36,730
and write unit tests if anybody's ever

00:13:34,960 --> 00:13:40,600
seen our X's unit tests they aren't

00:13:36,730 --> 00:13:42,130
necessarily the nicest to you in terms

00:13:40,600 --> 00:13:43,540
of modularity that's been a big

00:13:42,130 --> 00:13:45,040
complaint from everybody in the node

00:13:43,540 --> 00:13:47,260
world is that you with rx you've always

00:13:45,040 --> 00:13:49,810
kind of had to bring in everything or

00:13:47,260 --> 00:13:52,480
nothing and these sort of like light

00:13:49,810 --> 00:13:54,940
builds that Matt would compile never

00:13:52,480 --> 00:13:55,810
really did it for them so in this latest

00:13:54,940 --> 00:13:59,020
one if you're using something like

00:13:55,810 --> 00:14:03,000
typescript or es6 you can sort of import

00:13:59,020 --> 00:14:10,560
just the operators you want with modules

00:14:03,000 --> 00:14:19,480
so that the new rx so far is on average

00:14:10,560 --> 00:14:21,130
4.3 times faster than current rx numbers

00:14:19,480 --> 00:14:24,760
I've seen personally on my machine are

00:14:21,130 --> 00:14:27,040
up to 11 times but Ben was telling me of

00:14:24,760 --> 00:14:29,430
some of the macro tests are some times

00:14:27,040 --> 00:14:31,210
26 times faster so that's that's just

00:14:29,430 --> 00:14:34,900
ridiculous I mean I don't know anything

00:14:31,210 --> 00:14:36,850
that gets 26 times faster so we have a

00:14:34,900 --> 00:14:38,110
full performance test suite which is

00:14:36,850 --> 00:14:39,070
something Rx really never shipped with

00:14:38,110 --> 00:14:42,100
like they were kind of added on later

00:14:39,070 --> 00:14:43,870
but we've also got with the Google

00:14:42,100 --> 00:14:46,240
angular team with they got the benchmark

00:14:43,870 --> 00:14:47,770
tests running so they're if you crazy

00:14:46,240 --> 00:14:49,540
enough to run those they'll like spin up

00:14:47,770 --> 00:14:51,160
a hundred instances of chrome and like

00:14:49,540 --> 00:14:53,620
thrash the Dom a whole bunch and see how

00:14:51,160 --> 00:14:56,740
rx performs it's it's really being

00:14:53,620 --> 00:15:00,610
battle tested pretty well on the memory

00:14:56,740 --> 00:15:02,290
front we're at least 50% fewer

00:15:00,610 --> 00:15:04,120
allocations on subscribe' and

00:15:02,290 --> 00:15:06,850
potentially up to 90 depending on what

00:15:04,120 --> 00:15:10,570
schedulers you using which is just

00:15:06,850 --> 00:15:12,430
amazing debugging to also that the call

00:15:10,570 --> 00:15:14,110
stacks are massively improved if

00:15:12,430 --> 00:15:15,950
anybody's ever debug or had to step

00:15:14,110 --> 00:15:18,470
through the internals of our

00:15:15,950 --> 00:15:19,700
you know you you are next and then it

00:15:18,470 --> 00:15:21,530
goes doing internal on next and that

00:15:19,700 --> 00:15:23,000
goes to an abstract observer next and

00:15:21,530 --> 00:15:24,710
that one goes to a try catcher and then

00:15:23,000 --> 00:15:28,490
the other one comes back and then you

00:15:24,710 --> 00:15:29,720
accidentally hit the other key that

00:15:28,490 --> 00:15:34,640
steps over and now you've lost your

00:15:29,720 --> 00:15:37,370
place so that's been a big help with the

00:15:34,640 --> 00:15:39,230
newest version of rx I put together just

00:15:37,370 --> 00:15:45,100
a few little examples just to see the

00:15:39,230 --> 00:15:47,210
difference between the two okay so

00:15:45,100 --> 00:15:50,030
something we really needed at Netflix

00:15:47,210 --> 00:15:53,690
like they were we're very very anti Rx

00:15:50,030 --> 00:15:56,180
on node ironically Netflix you know

00:15:53,690 --> 00:15:57,620
writing rx Java and then using rxjs and

00:15:56,180 --> 00:15:59,870
the client everywhere the node guys

00:15:57,620 --> 00:16:01,880
weren't having it so this is kind of

00:15:59,870 --> 00:16:05,810
what spurred this we really needed to be

00:16:01,880 --> 00:16:07,940
able to get better-looking flame graphs

00:16:05,810 --> 00:16:09,680
so this is just an example where I did a

00:16:07,940 --> 00:16:11,960
flat map followed up by another flat map

00:16:09,680 --> 00:16:12,890
really not that crazy like it actually

00:16:11,960 --> 00:16:18,080
happens all the time

00:16:12,890 --> 00:16:23,890
and that's what rx looks like today RX 5

00:16:18,080 --> 00:16:25,610
looks like that which I don't know that

00:16:23,890 --> 00:16:27,380
makes any difference

00:16:25,610 --> 00:16:28,880
but what you see is like a lot of this

00:16:27,380 --> 00:16:31,010
stuff that's all broken up number one

00:16:28,880 --> 00:16:31,880
there's a lot of the optimized functions

00:16:31,010 --> 00:16:34,100
because they're doing a lot of try

00:16:31,880 --> 00:16:35,870
caches everywhere but also you can't

00:16:34,100 --> 00:16:37,400
really follow an event all the way

00:16:35,870 --> 00:16:40,040
through the next because it constantly

00:16:37,400 --> 00:16:42,590
jumps back to the schedulers so having

00:16:40,040 --> 00:16:44,000
these these wider lines that then you

00:16:42,590 --> 00:16:46,220
can see oh that's where it's taking all

00:16:44,000 --> 00:16:50,420
the time is really great especially on

00:16:46,220 --> 00:16:52,490
the server and here's another one where

00:16:50,420 --> 00:16:54,980
I use switch map it did a switch map

00:16:52,490 --> 00:16:56,210
event a switch map in our x4 and

00:16:54,980 --> 00:16:59,660
actually this one kind of broke my

00:16:56,210 --> 00:17:04,730
computer the graph was so long that I

00:16:59,660 --> 00:17:07,220
had to take screenshots in chunks I mean

00:17:04,730 --> 00:17:11,209
this it was just wild and this is what

00:17:07,220 --> 00:17:16,670
it looks like in our x5 so pretty pretty

00:17:11,209 --> 00:17:19,730
big improvement there so hope that's

00:17:16,670 --> 00:17:23,000
useful for everybody so what what got us

00:17:19,730 --> 00:17:24,890
to this point we decided we needed

00:17:23,000 --> 00:17:27,170
overall the schedulers internally the

00:17:24,890 --> 00:17:28,850
schedulers do a lot for us they're a

00:17:27,170 --> 00:17:31,190
really great concept but

00:17:28,850 --> 00:17:35,660
they there's a lot of legacy from

00:17:31,190 --> 00:17:37,220
c-sharp and other stuff we also

00:17:35,660 --> 00:17:40,250
completely change the architecture of

00:17:37,220 --> 00:17:43,280
how operators are implemented we

00:17:40,250 --> 00:17:45,890
implement them with classes and very

00:17:43,280 --> 00:17:49,429
very few closures because we realized

00:17:45,890 --> 00:17:52,070
talking to the v8 team that they

00:17:49,429 --> 00:17:53,780
optimize prototype lookups and we can

00:17:52,070 --> 00:17:57,410
create anonymous inner classes and do

00:17:53,780 --> 00:18:00,289
some optimizations there we're also able

00:17:57,410 --> 00:18:01,610
to unify the observer and the subscriber

00:18:00,289 --> 00:18:04,370
or the disposable so that's how we

00:18:01,610 --> 00:18:06,169
actually get just off the top 50% fewer

00:18:04,370 --> 00:18:08,600
allocations because those were always

00:18:06,169 --> 00:18:13,190
allocated in pairs and now they're a

00:18:08,600 --> 00:18:15,049
single object we also flatten the

00:18:13,190 --> 00:18:17,150
disposable trees so if you subscribe to

00:18:15,049 --> 00:18:18,320
an observable and it's got flat maps and

00:18:17,150 --> 00:18:20,210
stuff inside of it you don't know what's

00:18:18,320 --> 00:18:21,650
happening there's this you know kind of

00:18:20,210 --> 00:18:23,690
expansive disposable tree that could

00:18:21,650 --> 00:18:26,570
potentially get created we flattened all

00:18:23,690 --> 00:18:28,220
of that into a single list by sharing

00:18:26,570 --> 00:18:30,590
the same composite disposable between

00:18:28,220 --> 00:18:33,620
everybody all the way through so

00:18:30,590 --> 00:18:36,530
removing disposables is faster it less

00:18:33,620 --> 00:18:37,820
memory and then we also removed all

00:18:36,530 --> 00:18:38,900
these try caches from the internals

00:18:37,820 --> 00:18:41,659
because if we're calling framework

00:18:38,900 --> 00:18:43,130
internal code and you know we kind of

00:18:41,659 --> 00:18:44,270
trust our unit tests then we're pretty

00:18:43,130 --> 00:18:47,090
sure we're not going to get runtime

00:18:44,270 --> 00:18:48,200
exceptions and so all the try caches

00:18:47,090 --> 00:18:50,150
we're doing we're just being annoying

00:18:48,200 --> 00:18:55,159
for debugging and D optimizing our

00:18:50,150 --> 00:18:57,020
functions the flat map versus lift

00:18:55,159 --> 00:18:58,250
discussion is kind of interesting we

00:18:57,020 --> 00:19:00,350
went from an architecture where

00:18:58,250 --> 00:19:02,570
everything was kind of architected off

00:19:00,350 --> 00:19:04,039
of flat map basically flat map is this

00:19:02,570 --> 00:19:07,960
God operator that can implement any

00:19:04,039 --> 00:19:11,600
other operator if you are tricky enough

00:19:07,960 --> 00:19:14,360
so flat Maps signature not to get to

00:19:11,600 --> 00:19:17,320
typescript the end of this but it's a

00:19:14,360 --> 00:19:20,690
function that goes from type T to type R

00:19:17,320 --> 00:19:23,059
it takes a higher-order function so it

00:19:20,690 --> 00:19:24,770
takes a function that accepts the value

00:19:23,059 --> 00:19:29,299
of T and then returns an observable of R

00:19:24,770 --> 00:19:31,039
and then merges that together if anybody

00:19:29,299 --> 00:19:33,320
there's a lot of functional people here

00:19:31,039 --> 00:19:36,320
so people are probably familiar this is

00:19:33,320 --> 00:19:39,320
my attic bind so this is exactly the

00:19:36,320 --> 00:19:43,910
signature of bind

00:19:39,320 --> 00:19:46,040
so we move to lift which is that first

00:19:43,910 --> 00:19:48,140
looks kind of similar but then looks a

00:19:46,040 --> 00:19:50,810
little stranger it's also a function

00:19:48,140 --> 00:19:53,570
that goes from T to R but it takes a

00:19:50,810 --> 00:19:56,720
selector that doesn't take a value it

00:19:53,570 --> 00:19:59,480
takes a subscriber of T and returns a

00:19:56,720 --> 00:20:01,190
subscriber of our but then somehow

00:19:59,480 --> 00:20:05,000
returns an observable of R and it's just

00:20:01,190 --> 00:20:06,590
kind of this black magic video this is

00:20:05,000 --> 00:20:09,590
kind of the the flatmap way of doing

00:20:06,590 --> 00:20:12,920
things this is like a map function that

00:20:09,590 --> 00:20:14,450
I showed you before where we get our

00:20:12,920 --> 00:20:19,310
projection function we could sort of say

00:20:14,450 --> 00:20:22,460
about this source then we just allocate

00:20:19,310 --> 00:20:24,250
a new observable in return now this is

00:20:22,460 --> 00:20:28,060
problematic for a couple reasons because

00:20:24,250 --> 00:20:31,700
number 1 closure scope is slower than

00:20:28,060 --> 00:20:34,520
accessing things on a prototype number 2

00:20:31,700 --> 00:20:37,190
is its inflexible so if you subclass

00:20:34,520 --> 00:20:39,470
observable like subject or you know your

00:20:37,190 --> 00:20:42,770
custom type and then you call map well

00:20:39,470 --> 00:20:44,360
now you've lost your subclass type so it

00:20:42,770 --> 00:20:47,210
kind of overrides and now you're just

00:20:44,360 --> 00:20:48,860
back to using an observable and also

00:20:47,210 --> 00:20:51,080
there's there's all these closures down

00:20:48,860 --> 00:20:53,210
here when we subscribe to the source

00:20:51,080 --> 00:20:54,800
that really should exist on a subscriber

00:20:53,210 --> 00:20:58,010
prototype somewhere we don't need to

00:20:54,800 --> 00:21:00,230
allocate them every time so that's where

00:20:58,010 --> 00:21:03,410
lift comes in this is how map would be

00:21:00,230 --> 00:21:05,780
written and lift really map is just a

00:21:03,410 --> 00:21:07,970
function that takes a projector and then

00:21:05,780 --> 00:21:14,330
calls lifts so all of the operators want

00:21:07,970 --> 00:21:15,770
to call lifts lift takes a map operator

00:21:14,330 --> 00:21:19,460
which is just a class instance that has

00:21:15,770 --> 00:21:21,080
a call function it the map operator can

00:21:19,460 --> 00:21:24,050
store anything on its prototype it wants

00:21:21,080 --> 00:21:25,700
but then whenever call is invoked it's

00:21:24,050 --> 00:21:28,340
supposed to take the observer that you

00:21:25,700 --> 00:21:30,890
give it and then pass that to a new

00:21:28,340 --> 00:21:32,990
subscriber so let's say I'm subscribing

00:21:30,890 --> 00:21:34,280
I'm the first subscriber then I

00:21:32,990 --> 00:21:35,570
subscribed to the map thing the map

00:21:34,280 --> 00:21:39,650
thing gets told about me and then that

00:21:35,570 --> 00:21:42,350
thing is subscribes to the source so

00:21:39,650 --> 00:21:43,340
that's how you kind of create the chain

00:21:42,350 --> 00:21:48,760
in a different way without using

00:21:43,340 --> 00:21:51,200
closures this way is super super fast

00:21:48,760 --> 00:21:52,370
also it gives us the benefit that it

00:21:51,200 --> 00:21:54,980
delegates the new

00:21:52,370 --> 00:21:57,590
observable creation - dilution so if

00:21:54,980 --> 00:22:01,220
you're gonna subclass observable all you

00:21:57,590 --> 00:22:03,760
have to do is override lift so this is

00:22:01,220 --> 00:22:03,760
kind of cool because

00:22:04,960 --> 00:22:09,399
you call flatmap you got back at and

00:22:07,149 --> 00:22:12,309
observable and you lost all your custom

00:22:09,399 --> 00:22:13,809
methods what this also allows us to do

00:22:12,309 --> 00:22:15,460
is if you use something like WebSockets

00:22:13,809 --> 00:22:17,950
where you have subjects that are two-way

00:22:15,460 --> 00:22:19,390
communication you can differ flatmap

00:22:17,950 --> 00:22:20,919
those either because you get out

00:22:19,390 --> 00:22:23,309
observables so we can maintain the

00:22:20,919 --> 00:22:25,299
bidirectionality of communication and

00:22:23,309 --> 00:22:27,580
potentially in the future just put in

00:22:25,299 --> 00:22:29,320
back pressure support to the way that rx

00:22:27,580 --> 00:22:31,539
Java did so we're keeping that open as

00:22:29,320 --> 00:22:33,850
an option so this is kind of an example

00:22:31,539 --> 00:22:35,409
of using a mouse observable I have a

00:22:33,850 --> 00:22:37,779
demo of this that I might be able to

00:22:35,409 --> 00:22:40,419
show at the end if I can get through

00:22:37,779 --> 00:22:42,909
this fast enough where I'm sub-classing

00:22:40,419 --> 00:22:44,470
observable I'm overriding lift to return

00:22:42,909 --> 00:22:46,059
a new instance of the mass observable so

00:22:44,470 --> 00:22:47,440
every time you call a function like an

00:22:46,059 --> 00:22:49,840
operator on the mass observable you're

00:22:47,440 --> 00:22:51,399
gonna get a new mass observable I added

00:22:49,840 --> 00:22:53,130
these two little functions down here to

00:22:51,399 --> 00:22:57,520
track the velocity and then also

00:22:53,130 --> 00:22:59,230
concatenate friction events and that's

00:22:57,520 --> 00:23:01,149
kind of a stub and then here's how I'm

00:22:59,230 --> 00:23:03,789
using it so if I do this is sort of a

00:23:01,149 --> 00:23:05,649
canonical rx drag drop example where you

00:23:03,789 --> 00:23:08,169
have an observable from the mousedown

00:23:05,649 --> 00:23:09,970
event that you flatmap and inside of

00:23:08,169 --> 00:23:12,360
that you return all of the mouse moves

00:23:09,970 --> 00:23:15,039
until the mouse up but I've added my own

00:23:12,360 --> 00:23:17,169
tricky little things here with the mouse

00:23:15,039 --> 00:23:19,600
observable tracking the velocity as the

00:23:17,169 --> 00:23:21,610
users moving their Mouse and then at the

00:23:19,600 --> 00:23:24,669
very end can cat friction says all right

00:23:21,610 --> 00:23:26,770
once they've finished let's take the

00:23:24,669 --> 00:23:28,929
most recent event start with that

00:23:26,770 --> 00:23:30,760
velocity and then fake a bunch of events

00:23:28,929 --> 00:23:32,760
so whoever subscribe me of this doesn't

00:23:30,760 --> 00:23:35,620
know that they're getting fake events

00:23:32,760 --> 00:23:40,450
huh and then of course we throttle and

00:23:35,620 --> 00:23:43,179
then we render also so WebSockets this

00:23:40,450 --> 00:23:46,090
is really useful if you've got streaming

00:23:43,179 --> 00:23:49,570
stuff or little Bluetooth devices you

00:23:46,090 --> 00:23:52,539
talk to the talk over WebSockets in this

00:23:49,570 --> 00:23:54,130
case I'm telling Navi to shut up all

00:23:52,539 --> 00:23:55,390
right simply unit tests marble diagrams

00:23:54,130 --> 00:23:57,820
that anybody's never seen this this is

00:23:55,390 --> 00:24:00,429
from the documentation actually Andre

00:23:57,820 --> 00:24:02,110
stalls had the best idea I've ever heard

00:24:00,429 --> 00:24:03,909
which is why can't we just write our

00:24:02,110 --> 00:24:05,620
unit tests as marble diagrams because

00:24:03,909 --> 00:24:09,940
that makes a whole lot more sense than

00:24:05,620 --> 00:24:12,760
like having an 18 line thing checks

00:24:09,940 --> 00:24:14,789
numbers so this is kind of what our unit

00:24:12,760 --> 00:24:17,470
tests look like right now

00:24:14,789 --> 00:24:19,040
so you tell it what your observable is

00:24:17,470 --> 00:24:20,510
you tell it what your eggs

00:24:19,040 --> 00:24:22,940
affecting to get out at the end and then

00:24:20,510 --> 00:24:27,830
you say expect observable you know

00:24:22,940 --> 00:24:32,230
filter to be this string and that's it

00:24:27,830 --> 00:24:32,230
that's the crash course in the new rx

00:24:36,790 --> 00:24:41,480
great if you want I can actually

00:24:39,530 --> 00:24:44,270
actually just real quick show that

00:24:41,480 --> 00:24:49,010
little demo okay so let's let's get back

00:24:44,270 --> 00:24:50,570
to the to the screen yeah yep okay

00:24:49,010 --> 00:24:53,000
alright so this is something I did

00:24:50,570 --> 00:24:54,860
actually like a while ago when I first

00:24:53,000 --> 00:24:57,550
joined Netflix this is a virtualized

00:24:54,860 --> 00:24:57,550
scrolling list

00:25:01,630 --> 00:25:06,050
it's scrolling so it's all it's doing

00:25:03,620 --> 00:25:09,290
all the all the scrolling natively it's

00:25:06,050 --> 00:25:10,730
not doing any sort of it's not using

00:25:09,290 --> 00:25:12,470
native scroll bars it's doing UI

00:25:10,730 --> 00:25:15,650
recycling it's not doing any leaf loads

00:25:12,470 --> 00:25:17,540
using CSS to move and then it's doing

00:25:15,650 --> 00:25:19,340
all the the tracking velocity and and

00:25:17,540 --> 00:25:24,380
slowing down with friction I don't know

00:25:19,340 --> 00:25:26,240
why it's there we go it just and it just

00:25:24,380 --> 00:25:28,190
runs super fast and this is actually an

00:25:26,240 --> 00:25:31,540
older version of rx but this is like

00:25:28,190 --> 00:25:34,700
everybody's always like Oh Rx is so slow

00:25:31,540 --> 00:25:36,560
it's a lot of times it can be but it's

00:25:34,700 --> 00:25:39,320
also in how people use things also

00:25:36,560 --> 00:25:42,980
before I go if anybody I just want to

00:25:39,320 --> 00:25:44,600
point these out these are two files

00:25:42,980 --> 00:25:46,370
which you kind of buried really really

00:25:44,600 --> 00:25:47,810
deep in the documentation but this is

00:25:46,370 --> 00:25:48,980
kind of the most common complaint I see

00:25:47,810 --> 00:25:52,190
about Rx is that there's too many

00:25:48,980 --> 00:25:55,670
operators and I totally agree but

00:25:52,190 --> 00:25:57,860
there's a decision tree for static

00:25:55,670 --> 00:25:59,960
operators if you're like oh I have this

00:25:57,860 --> 00:26:00,590
problem and what do I need what operator

00:25:59,960 --> 00:26:01,880
do I use

00:26:00,590 --> 00:26:03,140
I'm you can say I want to create a new

00:26:01,880 --> 00:26:05,360
sequence that iterates over an

00:26:03,140 --> 00:26:08,150
asynchronous element ok BAM right there

00:26:05,360 --> 00:26:10,670
and the same thing for the instance

00:26:08,150 --> 00:26:12,050
operators if you're ever looking for the

00:26:10,670 --> 00:26:13,520
right operator to do something you're

00:26:12,050 --> 00:26:17,600
like you must be there you can just go

00:26:13,520 --> 00:26:21,440
to this decision tree it's in dock slash

00:26:17,600 --> 00:26:23,660
getting started so alright ok cool let's

00:26:21,440 --> 00:26:28,250
move to the questions yeah yeah tours

00:26:23,660 --> 00:26:30,690
three questions sure observable

00:26:28,250 --> 00:26:34,169
different from es6 generators

00:26:30,690 --> 00:26:37,860
the Essex generators are actually closer

00:26:34,169 --> 00:26:39,900
to enumerables their poll based although

00:26:37,860 --> 00:26:42,660
there is that weird like talking back to

00:26:39,900 --> 00:26:44,400
them saying observables are pushed so

00:26:42,660 --> 00:26:46,500
you you subscribe to the observable you

00:26:44,400 --> 00:26:48,410
give it three callbacks and then it

00:26:46,500 --> 00:26:51,360
decides if it wants to call those

00:26:48,410 --> 00:26:54,960
whenever it's also different because the

00:26:51,360 --> 00:26:56,520
generator is once you've enumerated a

00:26:54,960 --> 00:26:59,760
result from it it's exhausted you can't

00:26:56,520 --> 00:27:04,679
really Maury tit which feels like kind

00:26:59,760 --> 00:27:06,539
of a flaw but whatever bacon bacon is

00:27:04,679 --> 00:27:07,710
multicast by default actually where

00:27:06,539 --> 00:27:10,740
there's a big discussion about that

00:27:07,710 --> 00:27:13,830
right now the the the idea that is

00:27:10,740 --> 00:27:16,110
observable as a function in our X land

00:27:13,830 --> 00:27:18,240
they call that cold I don't know why

00:27:16,110 --> 00:27:21,200
it's really easier to understand if you

00:27:18,240 --> 00:27:24,440
think about it an async function but

00:27:21,200 --> 00:27:27,750
bacon the observables aren't always cold

00:27:24,440 --> 00:27:29,580
but the problem is if you go from cold

00:27:27,750 --> 00:27:32,700
the hot hot being meaning that you have

00:27:29,580 --> 00:27:34,440
a subscription that is a subject that

00:27:32,700 --> 00:27:36,900
has a list of observers just like an

00:27:34,440 --> 00:27:39,150
event emitter you can never really go

00:27:36,900 --> 00:27:42,440
back to being cold or purely functional

00:27:39,150 --> 00:27:44,460
so you have to kind of have the

00:27:42,440 --> 00:27:46,650
functional primitive and then you can

00:27:44,460 --> 00:27:50,490
sort of graduate to sharing the events

00:27:46,650 --> 00:27:52,370
if you need to how do we manage to

00:27:50,490 --> 00:27:58,130
perform improvements improve performance

00:27:52,370 --> 00:28:00,150
all of those techniques moving to lift

00:27:58,130 --> 00:28:02,909
revamping the schedulers we do things

00:28:00,150 --> 00:28:05,970
like object pooling or we recycle the

00:28:02,909 --> 00:28:08,850
same scheduled action we we we basically

00:28:05,970 --> 00:28:10,440
went and said all right let's be

00:28:08,850 --> 00:28:12,000
functionally pure about everything but

00:28:10,440 --> 00:28:14,400
then let's find all of the places that

00:28:12,000 --> 00:28:17,070
using dirty mutable state can like save

00:28:14,400 --> 00:28:19,490
us a bunch of time and money so that's

00:28:17,070 --> 00:28:21,840
what we did

00:28:19,490 --> 00:28:25,830
why is it incorrect to call it low - for

00:28:21,840 --> 00:28:28,020
events it's like the idea is great but

00:28:25,830 --> 00:28:31,470
low - works on arrays and arrays aren't

00:28:28,020 --> 00:28:33,330
functions arrays are mutable things the

00:28:31,470 --> 00:28:35,070
a better thing like a better example

00:28:33,330 --> 00:28:39,409
would be the ienumerable type in c-sharp

00:28:35,070 --> 00:28:44,460
i enumerables or iterators and iterables

00:28:39,409 --> 00:28:46,890
in java essentially our factories

00:28:44,460 --> 00:28:49,500
for an iterator so you can always go

00:28:46,890 --> 00:28:51,420
back and remunerate something and that's

00:28:49,500 --> 00:28:53,730
why it's not necessarily the same thing

00:28:51,420 --> 00:28:57,510
as lo - you're not performing a

00:28:53,730 --> 00:28:59,100
calculation whenever you do you know a

00:28:57,510 --> 00:29:02,220
map and a filter sequence another thing

00:28:59,100 --> 00:29:04,110
that's different is in lo - you you know

00:29:02,220 --> 00:29:05,880
if you're gonna do map and then filter

00:29:04,110 --> 00:29:06,990
while you're creating an intermediate

00:29:05,880 --> 00:29:08,160
array to store all the results of the

00:29:06,990 --> 00:29:09,510
map operation then you're creating

00:29:08,160 --> 00:29:10,770
another intermediate array to store all

00:29:09,510 --> 00:29:12,480
the results of the filter operation so

00:29:10,770 --> 00:29:14,550
you just created two arrays there so you

00:29:12,480 --> 00:29:16,740
exhausted it to create map then you did

00:29:14,550 --> 00:29:18,000
all the filter stuff well in rx it's not

00:29:16,740 --> 00:29:19,920
that way since it's kind of a pipeline

00:29:18,000 --> 00:29:21,060
one event goes through the map thing

00:29:19,920 --> 00:29:22,020
then it immediately goes through the

00:29:21,060 --> 00:29:23,670
filter thing and then you immediately

00:29:22,020 --> 00:29:25,110
get it and then the second event goes

00:29:23,670 --> 00:29:30,540
through kind of like that

00:29:25,110 --> 00:29:33,140
so what Falkor oh that's the one one

00:29:30,540 --> 00:29:36,360
last one yeah yeah Falkor will totally

00:29:33,140 --> 00:29:38,400
be compatible with RX because the result

00:29:36,360 --> 00:29:40,140
of Falkor has a subscribe function and

00:29:38,400 --> 00:29:41,670
RX works with any object that has a

00:29:40,140 --> 00:29:43,740
subscribe function

00:29:41,670 --> 00:29:45,630
it's just internally and we didn't need

00:29:43,740 --> 00:29:47,610
it anymore we were using it to do some

00:29:45,630 --> 00:29:48,950
complex asynchronous state handling that

00:29:47,610 --> 00:29:56,970
we don't have to do anymore

00:29:48,950 --> 00:29:58,350
cool thank you so much thank you and

00:29:56,970 --> 00:30:00,930
this last time probably we're gonna be

00:29:58,350 --> 00:30:04,970
in the in the room back and you can have

00:30:00,930 --> 00:30:04,970

YouTube URL: https://www.youtube.com/watch?v=QhjALubBQPg


