Title: State, UI and the stuff in between | Christian Alfoni | Reactive 2015
Publication date: 2017-06-29
Playlist: ReactiveConf 2015
Description: 
	The one way flow of flux has pushed us in the right direction, but we are still evolving what makes up that flow. Cerebral is a project that separates storing state and producing state with a functional flow defining API called signals.
Captions: 
	00:00:03,649 --> 00:00:09,719
okay welcome to my presentation on state

00:00:06,450 --> 00:00:11,880
UI and stuff in between my name is

00:00:09,719 --> 00:00:15,150
Christian all phony and I am the author

00:00:11,880 --> 00:00:18,779
of a library called cerebral but I also

00:00:15,150 --> 00:00:20,939
do other stuff like address bar which

00:00:18,779 --> 00:00:22,679
basically just converts that risk bar in

00:00:20,939 --> 00:00:24,779
the browser to an input so you can

00:00:22,679 --> 00:00:26,880
listen to changes on it you can change

00:00:24,779 --> 00:00:29,880
the value of it without any side effects

00:00:26,880 --> 00:00:33,750
and I also co-founded a project called

00:00:29,880 --> 00:00:38,340
webpack react cookbook together with a

00:00:33,750 --> 00:00:40,020
guy who calls himself be bro online he

00:00:38,340 --> 00:00:42,960
is the guy maintaining it now but I

00:00:40,020 --> 00:00:45,780
recommend you check that out I also

00:00:42,960 --> 00:00:47,850
brought the yahoo dispatcher to two

00:00:45,780 --> 00:00:50,280
angular with the Flex angular project

00:00:47,850 --> 00:00:52,560
and i also have a project called foreign

00:00:50,280 --> 00:00:55,740
syriac which is a form builder and

00:00:52,560 --> 00:00:58,800
validator for reacted I have a webpage

00:00:55,740 --> 00:01:00,870
at Christian of phony com we are mostly

00:00:58,800 --> 00:01:03,450
right about react and web pack and stuff

00:01:00,870 --> 00:01:05,250
like that and I'm currently working on

00:01:03,450 --> 00:01:08,310
my own project my own little startup

00:01:05,250 --> 00:01:10,439
actually using cerebral to build a

00:01:08,310 --> 00:01:12,450
service to teach kids how to code and

00:01:10,439 --> 00:01:15,749
hopefully inspire them to become

00:01:12,450 --> 00:01:20,100
developers like us one day and I do some

00:01:15,749 --> 00:01:22,889
consultancy on the side so my talk is

00:01:20,100 --> 00:01:26,850
really about complexity how cerebral can

00:01:22,889 --> 00:01:28,920
help us express complexity because we do

00:01:26,850 --> 00:01:31,109
not really want to hide complexity in

00:01:28,920 --> 00:01:33,810
our applications and we certainly do not

00:01:31,109 --> 00:01:35,939
want to reduce it like removing features

00:01:33,810 --> 00:01:38,399
and stuff like that what we need is a

00:01:35,939 --> 00:01:40,979
way to express all this complexity in

00:01:38,399 --> 00:01:44,030
our applications and cerebral is one

00:01:40,979 --> 00:01:47,279
perspective on how we can achieve that

00:01:44,030 --> 00:01:50,069
so this is a piece of you I and this is

00:01:47,279 --> 00:01:52,799
how our users consumes the state of our

00:01:50,069 --> 00:01:54,869
application and actually as a developer

00:01:52,799 --> 00:01:58,229
I also consume the state of my

00:01:54,869 --> 00:01:59,969
application going into the UI so if I

00:01:58,229 --> 00:02:02,459
wanted to know if this checkbox was

00:01:59,969 --> 00:02:05,130
checked i went into the DOM and I

00:02:02,459 --> 00:02:07,920
checked if the check box was checked but

00:02:05,130 --> 00:02:11,280
that's not a good idea it gets you into

00:02:07,920 --> 00:02:15,030
all sorts of problems and then react

00:02:11,280 --> 00:02:16,960
came out and react shifted my mindset it

00:02:15,030 --> 00:02:19,900
made me think about my applicant

00:02:16,960 --> 00:02:23,020
patient separately from my UI so

00:02:19,900 --> 00:02:26,530
specifically my UI is now an output of

00:02:23,020 --> 00:02:29,080
my application and like with backbone I

00:02:26,530 --> 00:02:30,820
had grabbed state from a model shoved it

00:02:29,080 --> 00:02:33,460
through a template and produce some UI

00:02:30,820 --> 00:02:35,110
but I would still go into the dawn to

00:02:33,460 --> 00:02:38,950
figure out if the check box was checked

00:02:35,110 --> 00:02:42,100
or if they input had some value with

00:02:38,950 --> 00:02:44,070
angular it's kind of yeah you have this

00:02:42,100 --> 00:02:46,980
two-way data-binding so it can like

00:02:44,070 --> 00:02:49,420
intertwines your application with the UI

00:02:46,980 --> 00:02:50,740
but we'd react it's the complete

00:02:49,420 --> 00:02:56,290
opposite it's like you have your

00:02:50,740 --> 00:02:58,750
application and the output is the UI so

00:02:56,290 --> 00:03:00,700
this is like the flow a inside our

00:02:58,750 --> 00:03:03,460
applications it doesn't matter what we

00:03:00,700 --> 00:03:05,470
use to build it but what we want to

00:03:03,460 --> 00:03:08,020
achieve is to have some initial state

00:03:05,470 --> 00:03:10,860
and we shoved up through some render

00:03:08,020 --> 00:03:13,720
mechanism which produces some UI and

00:03:10,860 --> 00:03:15,340
then something happens in the UI and we

00:03:13,720 --> 00:03:18,730
want to change the state of our

00:03:15,340 --> 00:03:21,160
application so this stuff in between air

00:03:18,730 --> 00:03:23,350
is really render and changing state I'm

00:03:21,160 --> 00:03:25,660
not going to talk about render but I am

00:03:23,350 --> 00:03:28,180
going to talk about changing the state

00:03:25,660 --> 00:03:31,300
of our applications because it's really

00:03:28,180 --> 00:03:33,250
hard it's really really hard so the

00:03:31,300 --> 00:03:35,850
smallest context with this flow is a

00:03:33,250 --> 00:03:38,350
typical view or a component with react

00:03:35,850 --> 00:03:41,080
where you have some initial state and

00:03:38,350 --> 00:03:42,970
then we shove that state through some

00:03:41,080 --> 00:03:45,880
render mechanism and we produce some UI

00:03:42,970 --> 00:03:48,310
and typically we would like click a

00:03:45,880 --> 00:03:51,370
button and that would run a function and

00:03:48,310 --> 00:03:54,640
that function would change the state of

00:03:51,370 --> 00:03:57,580
the view either implicitly or explicitly

00:03:54,640 --> 00:04:00,130
cause a new render like we'd react it's

00:03:57,580 --> 00:04:03,280
implicit we just call set state and it

00:04:00,130 --> 00:04:05,560
does a new render but wait for example

00:04:03,280 --> 00:04:10,840
backbone we have to explicitly call

00:04:05,560 --> 00:04:13,030
render after any state change but

00:04:10,840 --> 00:04:16,000
building applications is not just one

00:04:13,030 --> 00:04:18,730
view we have many views all handling

00:04:16,000 --> 00:04:21,040
this flow and we also need global state

00:04:18,730 --> 00:04:22,750
we need global state in our applications

00:04:21,040 --> 00:04:24,880
because we want to share state between

00:04:22,750 --> 00:04:26,830
our views and this is handled

00:04:24,880 --> 00:04:28,900
differently with different libraries

00:04:26,830 --> 00:04:30,460
like in backbone you have these

00:04:28,900 --> 00:04:32,710
abstractions different

00:04:30,460 --> 00:04:34,930
abstractions for state called model and

00:04:32,710 --> 00:04:36,910
collection and you have lots of these

00:04:34,930 --> 00:04:39,039
entities lots of models and lots of

00:04:36,910 --> 00:04:40,780
collections and with angular you have

00:04:39,039 --> 00:04:43,389
the same kind of stuff but it's just

00:04:40,780 --> 00:04:46,030
called something else like resource and

00:04:43,389 --> 00:04:49,180
service and factory and provider and and

00:04:46,030 --> 00:04:50,949
all this is about state but it's just

00:04:49,180 --> 00:04:53,139
wrapped in the api's and stuff like that

00:04:50,949 --> 00:04:55,330
and you can actually also think about

00:04:53,139 --> 00:04:57,639
your router as keeping some of your

00:04:55,330 --> 00:04:59,650
state like what views am I supposed to

00:04:57,639 --> 00:05:02,080
render what is the current URL and stuff

00:04:59,650 --> 00:05:04,360
like that and the problem here is that

00:05:02,080 --> 00:05:06,130
it's really hard to reason about all

00:05:04,360 --> 00:05:08,490
this because we're creating so many

00:05:06,130 --> 00:05:11,199
relationships inside our application

00:05:08,490 --> 00:05:14,370
having all these entities representing

00:05:11,199 --> 00:05:18,160
our state and then having these rappers

00:05:14,370 --> 00:05:21,580
with all the AP ice and stuff but then

00:05:18,160 --> 00:05:28,120
we got flex and flex really cleaned up

00:05:21,580 --> 00:05:30,400
this stuff and the really great thing

00:05:28,120 --> 00:05:32,500
about flux is that we moved away from

00:05:30,400 --> 00:05:36,009
having multiple abstractions for state

00:05:32,500 --> 00:05:40,330
and moved into having one abstraction

00:05:36,009 --> 00:05:41,979
called a story and that's really great

00:05:40,330 --> 00:05:43,090
and another thing about these stores is

00:05:41,979 --> 00:05:45,070
that there are a very shallow

00:05:43,090 --> 00:05:46,870
abstraction we don't have lots of api's

00:05:45,070 --> 00:05:49,090
for talking to the server and stuff like

00:05:46,870 --> 00:05:52,479
that it's just basically an object we

00:05:49,090 --> 00:05:54,729
put other objects and stuff in then the

00:05:52,479 --> 00:05:56,320
program with Flex though is that when

00:05:54,729 --> 00:05:59,650
you want to change the state of your

00:05:56,320 --> 00:06:01,990
application you have to often you start

00:05:59,650 --> 00:06:04,539
in the component you have some click

00:06:01,990 --> 00:06:06,280
handler or something that has some logic

00:06:04,539 --> 00:06:08,440
and then you have the action creators

00:06:06,280 --> 00:06:10,750
and they have some more logic related to

00:06:08,440 --> 00:06:12,699
this state change and then you have

00:06:10,750 --> 00:06:15,310
logic inside your stores to actually

00:06:12,699 --> 00:06:17,139
produce the new state so it's kind of

00:06:15,310 --> 00:06:20,320
like split between these three layers

00:06:17,139 --> 00:06:23,229
and personally I think that's hard to

00:06:20,320 --> 00:06:27,310
reason about but then I found this

00:06:23,229 --> 00:06:30,610
project called baobab and baobab is a

00:06:27,310 --> 00:06:32,199
single state tree it's just one object

00:06:30,610 --> 00:06:35,919
representing all the state of your

00:06:32,199 --> 00:06:38,259
application so the components has the

00:06:35,919 --> 00:06:40,900
ability to point into this tree they can

00:06:38,259 --> 00:06:43,719
point point to specific paths and listen

00:06:40,900 --> 00:06:44,289
to changes and what's really great now

00:06:43,719 --> 00:06:47,110
is

00:06:44,289 --> 00:06:49,479
that we do not need the dispatcher we

00:06:47,110 --> 00:06:51,279
just need something to handle our state

00:06:49,479 --> 00:06:53,860
changes and that is typically just

00:06:51,279 --> 00:06:55,599
functions and these functions just as

00:06:53,860 --> 00:07:00,369
access to the tree and they can change

00:06:55,599 --> 00:07:03,159
the state on the tree and once very nice

00:07:00,369 --> 00:07:05,529
is with the latest version of react we

00:07:03,159 --> 00:07:07,869
can have stateless components and this

00:07:05,529 --> 00:07:11,110
image is something I really like it's

00:07:07,869 --> 00:07:13,719
the same flow I started bin but now it's

00:07:11,110 --> 00:07:16,599
more in a global perspective so now the

00:07:13,719 --> 00:07:18,309
components only does rendering and then

00:07:16,599 --> 00:07:20,259
you have a layer for changing the state

00:07:18,309 --> 00:07:22,539
of your application and you have a

00:07:20,259 --> 00:07:26,860
single entity representing the state of

00:07:22,539 --> 00:07:29,589
your application so I built applications

00:07:26,860 --> 00:07:31,689
like this for some time and this is

00:07:29,589 --> 00:07:33,849
typically how I would change the state

00:07:31,689 --> 00:07:35,949
of my application I will write a

00:07:33,849 --> 00:07:38,409
function in this case called get to

00:07:35,949 --> 00:07:40,539
deuce but it does more than getting the

00:07:38,409 --> 00:07:43,629
two deuce it's also changing the loading

00:07:40,539 --> 00:07:46,899
state it's setting the two deuce where

00:07:43,629 --> 00:07:48,729
is setting an error the point is that to

00:07:46,899 --> 00:07:50,740
understand this change you have to read

00:07:48,729 --> 00:07:54,069
all the implementation details and this

00:07:50,740 --> 00:07:56,319
is a really simple function you can

00:07:54,069 --> 00:07:57,759
imagine how complex this can get and you

00:07:56,319 --> 00:08:00,430
have to read all the implementation

00:07:57,759 --> 00:08:04,240
details so I wanted to make this better

00:08:00,430 --> 00:08:06,999
and I looked different places but ended

00:08:04,240 --> 00:08:09,729
up actually looking at like the good old

00:08:06,999 --> 00:08:13,180
days where we have just HTML in the

00:08:09,729 --> 00:08:15,729
browser easy to build applications but

00:08:13,180 --> 00:08:18,939
these applications also needed to change

00:08:15,729 --> 00:08:21,099
their state so what they did to change

00:08:18,939 --> 00:08:23,319
their state was typically with a form

00:08:21,099 --> 00:08:26,199
like we wanted to post on you to do and

00:08:23,319 --> 00:08:29,199
this post request is actually a request

00:08:26,199 --> 00:08:31,539
for state change and what handles this

00:08:29,199 --> 00:08:34,599
request versus a change is the router

00:08:31,539 --> 00:08:36,279
and the router commonly has a concept of

00:08:34,599 --> 00:08:38,680
middleware where you have multiple

00:08:36,279 --> 00:08:41,709
function each of them performing a

00:08:38,680 --> 00:08:44,560
specific task now what I like about

00:08:41,709 --> 00:08:46,779
middle where is that it is expressed as

00:08:44,560 --> 00:08:48,490
a flow as I said you have one function

00:08:46,779 --> 00:08:51,880
doing one thing and the next function

00:08:48,490 --> 00:08:54,699
does something but it also has this

00:08:51,880 --> 00:08:57,070
request object so you're not limited to

00:08:54,699 --> 00:08:59,920
only operating on the output of the

00:08:57,070 --> 00:09:03,040
obvious function you can connect share

00:08:59,920 --> 00:09:08,080
state as you move through this state

00:09:03,040 --> 00:09:10,690
change so taking this into account now

00:09:08,080 --> 00:09:12,760
we're back in the client and we're going

00:09:10,690 --> 00:09:14,770
to talk about cerebral so cerebral kind

00:09:12,760 --> 00:09:18,550
of like fits in between your state and

00:09:14,770 --> 00:09:20,320
the UI and the way it changes the state

00:09:18,550 --> 00:09:23,260
of your application is using something

00:09:20,320 --> 00:09:24,730
called signals so something happens in

00:09:23,260 --> 00:09:27,250
the UI or some other part of your

00:09:24,730 --> 00:09:30,310
application and it fires of a signal and

00:09:27,250 --> 00:09:32,860
this signal has actions and it's just

00:09:30,310 --> 00:09:37,240
functions that has access to changing

00:09:32,860 --> 00:09:39,610
the state of your application so the

00:09:37,240 --> 00:09:42,520
thing here is that typically with flex

00:09:39,610 --> 00:09:45,280
we do a state change and that specific

00:09:42,520 --> 00:09:47,680
state change tells the UI to do a change

00:09:45,280 --> 00:09:50,200
that's not how it works in cerebral with

00:09:47,680 --> 00:09:52,360
cerebral it's the signal that decides

00:09:50,200 --> 00:10:03,760
when it's time for the UI to update

00:09:52,360 --> 00:10:05,410
itself going ok yes and so smack right

00:10:03,760 --> 00:10:10,720
in the middle between your state and you

00:10:05,410 --> 00:10:14,350
I you find cerebral and now we're going

00:10:10,720 --> 00:10:15,790
to dive a step-like deeper and we're

00:10:14,350 --> 00:10:18,010
going to talk about these signals and

00:10:15,790 --> 00:10:21,370
actions so the way you build a signal is

00:10:18,010 --> 00:10:24,310
by composing actions into something we

00:10:21,370 --> 00:10:27,130
call chains you might think of pipes

00:10:24,310 --> 00:10:29,620
maybe but I think of them as chains and

00:10:27,130 --> 00:10:32,650
these chains can be composed into a

00:10:29,620 --> 00:10:35,620
signal so in this case we have just one

00:10:32,650 --> 00:10:38,590
signal with one chain and three actions

00:10:35,620 --> 00:10:41,590
so something happens in the UI and it

00:10:38,590 --> 00:10:43,780
and cerebral runs the first action that

00:10:41,590 --> 00:10:46,270
action changes some state in the state

00:10:43,780 --> 00:10:48,370
tree and then it runs the second action

00:10:46,270 --> 00:10:51,760
which actually grab some state from the

00:10:48,370 --> 00:10:53,980
state tree and I want to access my

00:10:51,760 --> 00:10:57,160
current state when I am changing my

00:10:53,980 --> 00:10:59,650
state for example if I'm changing like

00:10:57,160 --> 00:11:03,160
the state of an issue in my project

00:10:59,650 --> 00:11:06,010
application I need the ID of the project

00:11:03,160 --> 00:11:08,830
and I don't want to necessarily pass

00:11:06,010 --> 00:11:10,520
that through the component I want to

00:11:08,830 --> 00:11:11,840
just be able to access it

00:11:10,520 --> 00:11:14,660
I might need some information from the

00:11:11,840 --> 00:11:17,330
user or whatever to do this state change

00:11:14,660 --> 00:11:19,250
and then it will run the last action

00:11:17,330 --> 00:11:24,740
doing some state change and then it

00:11:19,250 --> 00:11:26,560
notifies the UI about an update but we

00:11:24,740 --> 00:11:29,810
have to do more complex stuff than this

00:11:26,560 --> 00:11:32,600
so we have to do asynchronous stuff so

00:11:29,810 --> 00:11:35,030
imagine that this first action is

00:11:32,600 --> 00:11:37,160
changing some loading state and then

00:11:35,030 --> 00:11:39,560
cerebral see is that the next action in

00:11:37,160 --> 00:11:42,650
line is asynchronous so what it does is

00:11:39,560 --> 00:11:44,240
just poke the UI and tells it that okay

00:11:42,650 --> 00:11:46,400
I have some changes for you now I'm

00:11:44,240 --> 00:11:49,040
going to do something asynchronous so

00:11:46,400 --> 00:11:51,050
you can update yourself and then it runs

00:11:49,040 --> 00:11:52,990
this asynchronous action which is

00:11:51,050 --> 00:11:55,790
typically a request to the server and

00:11:52,990 --> 00:11:58,790
the response from the server can be like

00:11:55,790 --> 00:12:01,460
success error not authorized not found

00:11:58,790 --> 00:12:04,250
whatever the thing is that this

00:12:01,460 --> 00:12:07,130
asynchronous action can output to a

00:12:04,250 --> 00:12:08,870
specific path so in this case you can

00:12:07,130 --> 00:12:12,290
imagine that the asynchronous action

00:12:08,870 --> 00:12:16,100
outputs to a success path and this path

00:12:12,290 --> 00:12:18,110
is just a chain with one action changing

00:12:16,100 --> 00:12:21,860
some state and then notifying the UI

00:12:18,110 --> 00:12:24,590
that it can update itself but we have to

00:12:21,860 --> 00:12:26,930
do even more complex stuff than this we

00:12:24,590 --> 00:12:30,050
also want to run parallel asynchronous

00:12:26,930 --> 00:12:32,480
stuff and so we can imagine here that we

00:12:30,050 --> 00:12:35,300
have two requests to the server one of

00:12:32,480 --> 00:12:38,900
them taking one second to respond long

00:12:35,300 --> 00:12:41,510
time but just for an example and that

00:12:38,900 --> 00:12:43,790
results in a success so after one second

00:12:41,510 --> 00:12:46,180
it will run the success chain running

00:12:43,790 --> 00:12:48,050
just one action but the other

00:12:46,180 --> 00:12:50,990
asynchronous action takes a bit longer

00:12:48,050 --> 00:12:53,900
and when it's done it will bring its

00:12:50,990 --> 00:12:56,150
success or error chain and then finally

00:12:53,900 --> 00:13:01,550
when all this is done it will run the

00:12:56,150 --> 00:13:03,470
last action and then update the UI so

00:13:01,550 --> 00:13:05,540
we're going to take a crash course in

00:13:03,470 --> 00:13:10,730
signals so I'm going to use the example

00:13:05,540 --> 00:13:12,560
I had earlier with with Baba and so the

00:13:10,730 --> 00:13:15,950
way you would express this with a signal

00:13:12,560 --> 00:13:18,170
is first naming it and by convention the

00:13:15,950 --> 00:13:20,300
name should be what happened inside your

00:13:18,170 --> 00:13:22,490
application for this signal to trigger

00:13:20,300 --> 00:13:24,499
it's just easier to reason about stuff

00:13:22,490 --> 00:13:27,289
that way so in this case

00:13:24,499 --> 00:13:29,689
application mounts we have defined a

00:13:27,289 --> 00:13:33,049
chain and the first item of this chain

00:13:29,689 --> 00:13:35,149
is set loading to deuce and set loading

00:13:33,049 --> 00:13:37,429
to deuce is just referencing an action

00:13:35,149 --> 00:13:39,379
just a function I'm not going to talk

00:13:37,429 --> 00:13:41,059
about these actions because I just don't

00:13:39,379 --> 00:13:43,519
have time for it but it's just a

00:13:41,059 --> 00:13:44,599
function receiving some arguments making

00:13:43,519 --> 00:13:47,839
you're able to change your state and

00:13:44,599 --> 00:13:51,019
stuff the second item inside this chain

00:13:47,839 --> 00:13:53,599
is an array so an array inside a chain

00:13:51,019 --> 00:13:56,839
means that the actions inside it will

00:13:53,599 --> 00:14:00,039
run asynchronously so get to deuce in

00:13:56,839 --> 00:14:03,619
this example will run asynchronously and

00:14:00,039 --> 00:14:06,279
then we have an object after that get to

00:14:03,619 --> 00:14:09,439
deuce and this object represents puffs

00:14:06,279 --> 00:14:11,869
so in this case get to do the get to do

00:14:09,439 --> 00:14:15,379
section can output either a success or

00:14:11,869 --> 00:14:17,479
an error if it's a success it will run a

00:14:15,379 --> 00:14:19,759
chain containing one action called set

00:14:17,479 --> 00:14:23,749
to deuce or if it's an error it will run

00:14:19,759 --> 00:14:25,819
one chain containing set to do zaror

00:14:23,749 --> 00:14:28,819
action and when all of this stuff is

00:14:25,819 --> 00:14:33,470
done it will run that last action and

00:14:28,819 --> 00:14:37,939
set loading to deuce so what we're going

00:14:33,470 --> 00:14:45,319
to do now is have a little demo so let

00:14:37,939 --> 00:14:47,599
me do this correctly you ok let's try

00:14:45,319 --> 00:14:50,149
this ok so what you're seeing here is

00:14:47,599 --> 00:14:53,569
the typical to do MVC application only

00:14:50,149 --> 00:14:55,399
running with cerebral and so you have

00:14:53,569 --> 00:14:58,849
the typical you I here on the left side

00:14:55,399 --> 00:15:02,749
but you also have the cerebral debugger

00:14:58,849 --> 00:15:05,329
so cerebral has a chrome extension which

00:15:02,749 --> 00:15:08,929
is its own the bugger so what happens

00:15:05,329 --> 00:15:11,720
here when I change the UI is that you

00:15:08,929 --> 00:15:13,069
can see what signals were triggered when

00:15:11,720 --> 00:15:14,749
doing this state change inside

00:15:13,069 --> 00:15:16,909
application so you see what signal

00:15:14,749 --> 00:15:18,919
triggered what actions were run what

00:15:16,909 --> 00:15:23,839
input did it have what state mutations

00:15:18,919 --> 00:15:26,479
did it do and if i hit enter here we can

00:15:23,839 --> 00:15:29,389
see a more complex example with more

00:15:26,479 --> 00:15:31,459
actions and some asynchronous actions

00:15:29,389 --> 00:15:35,029
inputs outputs and all that good stuff

00:15:31,459 --> 00:15:36,799
and now we can see how like we often

00:15:35,029 --> 00:15:37,810
underestimate the complexities of what

00:15:36,799 --> 00:15:39,820
we do

00:15:37,810 --> 00:15:43,000
and adding her to do seems like a really

00:15:39,820 --> 00:15:44,830
simple thing but it is actually quite

00:15:43,000 --> 00:15:47,830
complex as we can see here there's a lot

00:15:44,830 --> 00:15:51,279
of stuff happening what's also really

00:15:47,830 --> 00:15:53,290
nice is if I click this model up here we

00:15:51,279 --> 00:15:55,960
can see the complete state of the

00:15:53,290 --> 00:15:58,270
application and what I'm talking about

00:15:55,960 --> 00:15:59,950
now are like these three layers you have

00:15:58,270 --> 00:16:03,520
your UI which of course the browser

00:15:59,950 --> 00:16:05,650
handles but you can also see the state

00:16:03,520 --> 00:16:07,900
changes of your application using the

00:16:05,650 --> 00:16:09,880
debugger and you can at any time see

00:16:07,900 --> 00:16:13,750
what is the complete state of my

00:16:09,880 --> 00:16:16,080
application right now and the big hype

00:16:13,750 --> 00:16:19,150
these days is time travel debugging and

00:16:16,080 --> 00:16:21,160
and you can do that because cerebral

00:16:19,150 --> 00:16:23,589
knows about everything that's happening

00:16:21,160 --> 00:16:25,029
inside their application so you can do

00:16:23,589 --> 00:16:27,550
that we actually used to have a slider

00:16:25,029 --> 00:16:30,550
here because I remember the elm example

00:16:27,550 --> 00:16:33,160
but the slider is just really cool it's

00:16:30,550 --> 00:16:37,120
not very practical so we decided to have

00:16:33,160 --> 00:16:39,460
some buttons here instead um okay I

00:16:37,120 --> 00:16:41,529
could talk more about this but I'm

00:16:39,460 --> 00:16:44,470
actually not going to do okay i want to

00:16:41,529 --> 00:16:47,080
mention one more thing it's like and you

00:16:44,470 --> 00:16:49,810
have no insight into the cold of this

00:16:47,080 --> 00:16:52,060
application but if you were able to read

00:16:49,810 --> 00:16:53,770
the signals here you will actually get

00:16:52,060 --> 00:16:55,720
an understanding of what does this

00:16:53,770 --> 00:16:58,089
application do what is it trying to

00:16:55,720 --> 00:16:59,680
achieve and I think that's really

00:16:58,089 --> 00:17:03,070
powerful that it can just grab a

00:16:59,680 --> 00:17:04,630
developer open up the dev tools and just

00:17:03,070 --> 00:17:06,100
start playing around the UI and you

00:17:04,630 --> 00:17:13,150
understand the internals of the

00:17:06,100 --> 00:17:16,150
application all right and so I said I

00:17:13,150 --> 00:17:18,699
was going to talk about complexity so

00:17:16,150 --> 00:17:21,970
this is complexity for you and you're

00:17:18,699 --> 00:17:24,280
probably thinking now like what what

00:17:21,970 --> 00:17:26,500
what is this but I'm going to make a

00:17:24,280 --> 00:17:29,220
stain statement now and that is that

00:17:26,500 --> 00:17:32,470
when you read this you will understand

00:17:29,220 --> 00:17:35,620
what it tries to do so we're going to go

00:17:32,470 --> 00:17:38,470
through some of it now and as we can see

00:17:35,620 --> 00:17:40,780
here it's trying to load an access token

00:17:38,470 --> 00:17:42,820
at the very top layer and two different

00:17:40,780 --> 00:17:45,550
things can happen either a token is

00:17:42,820 --> 00:17:49,030
found or it's not found if it's not

00:17:45,550 --> 00:17:50,590
found it will try to log in and that can

00:17:49,030 --> 00:17:53,500
result in a success or

00:17:50,590 --> 00:17:55,000
error if it's a success it will set the

00:17:53,500 --> 00:17:57,730
access token and then it will try to

00:17:55,000 --> 00:18:00,159
verify that token I'm not going to go

00:17:57,730 --> 00:18:02,860
through all the rest of it but this was

00:18:00,159 --> 00:18:06,070
an example pasted by a guy named Brian

00:18:02,860 --> 00:18:09,549
on the Gator channel hi Brian thanks for

00:18:06,070 --> 00:18:11,200
example and he wanted to ask us some

00:18:09,549 --> 00:18:13,900
questions now we didn't know anything

00:18:11,200 --> 00:18:15,730
about the implementation details of its

00:18:13,900 --> 00:18:18,130
application we didn't even know that

00:18:15,730 --> 00:18:20,980
these folks related to google and their

00:18:18,130 --> 00:18:23,500
access tokens but he wanted feedback on

00:18:20,980 --> 00:18:27,520
this and one of some of that feedback

00:18:23,500 --> 00:18:29,919
was why do you have to verify the token

00:18:27,520 --> 00:18:32,710
after you have a successful login and

00:18:29,919 --> 00:18:34,450
what Brian answered is ok it's just in

00:18:32,710 --> 00:18:37,450
the Google documentation I have to do

00:18:34,450 --> 00:18:40,510
that but I think it's kinda nice that we

00:18:37,450 --> 00:18:43,559
were able to ask that question without

00:18:40,510 --> 00:18:47,409
reading and the implementation details

00:18:43,559 --> 00:18:49,570
and then we have like these scenarios so

00:18:47,409 --> 00:18:52,270
when we handle complexity I think most

00:18:49,570 --> 00:18:55,000
of our bags are scenarios not handled

00:18:52,270 --> 00:18:56,950
you know you create some requests and

00:18:55,000 --> 00:18:59,980
you have the catch and then you really

00:18:56,950 --> 00:19:02,169
are have can do that later but it's very

00:18:59,980 --> 00:19:04,360
explicit here what scenarios should be

00:19:02,169 --> 00:19:07,029
handled so what we could tell brian is

00:19:04,360 --> 00:19:10,240
that ok when you when you verify the

00:19:07,029 --> 00:19:12,760
token over here why are not handling the

00:19:10,240 --> 00:19:15,130
token invalid scenario and we have the

00:19:12,760 --> 00:19:16,870
same thing down here it's verifying the

00:19:15,130 --> 00:19:19,510
token but it's not handling the

00:19:16,870 --> 00:19:21,610
scenarios so you can can like sit

00:19:19,510 --> 00:19:23,500
together and you can build these signals

00:19:21,610 --> 00:19:26,169
not implementing any code at all and

00:19:23,500 --> 00:19:28,059
everybody talks about and understands

00:19:26,169 --> 00:19:32,289
the flow of changing the state of the

00:19:28,059 --> 00:19:34,929
application so its of course possible to

00:19:32,289 --> 00:19:37,270
refactor this and I like to express it

00:19:34,929 --> 00:19:39,760
mostly like you saw on the previous line

00:19:37,270 --> 00:19:42,279
but since these are just functions these

00:19:39,760 --> 00:19:43,870
actions are functions you have the

00:19:42,279 --> 00:19:47,440
possibility to just use normal

00:19:43,870 --> 00:19:49,809
JavaScript for example factories so

00:19:47,440 --> 00:19:52,210
instead of having a get to do section as

00:19:49,809 --> 00:19:54,220
we see here you can have an action

00:19:52,210 --> 00:19:56,289
factory so it's just a function that

00:19:54,220 --> 00:20:00,460
takes an argument and it returns an

00:19:56,289 --> 00:20:02,320
action using in this case the URL but

00:20:00,460 --> 00:20:03,840
you can also use a new spread operator

00:20:02,320 --> 00:20:09,750
from

00:20:03,840 --> 00:20:12,870
es 2015 and you can just put actions and

00:20:09,750 --> 00:20:14,400
paths and whatever you want into race

00:20:12,870 --> 00:20:16,830
and then you can just spread these

00:20:14,400 --> 00:20:20,520
wherever you want you compose it

00:20:16,830 --> 00:20:23,909
together and you can even create chain

00:20:20,520 --> 00:20:25,950
factories so you can pass in some custom

00:20:23,909 --> 00:20:28,110
actions to a chain factory and it will

00:20:25,950 --> 00:20:32,190
return a chain for you having some

00:20:28,110 --> 00:20:35,190
default actions so this is an example of

00:20:32,190 --> 00:20:36,809
how we could refactor Bryan's example if

00:20:35,190 --> 00:20:39,270
we see at the bottom here that is where

00:20:36,809 --> 00:20:41,340
we have the initial chain and we're

00:20:39,270 --> 00:20:43,260
loading the access token again and it

00:20:41,340 --> 00:20:46,200
can be found or it can not be found if

00:20:43,260 --> 00:20:48,720
it's found we run the verify token chain

00:20:46,200 --> 00:20:51,059
but if it's not found we run the login

00:20:48,720 --> 00:20:54,270
chain and as we can see here in the

00:20:51,059 --> 00:20:56,370
verify token chain it's reusing the

00:20:54,270 --> 00:20:59,370
login chain so this is this is like

00:20:56,370 --> 00:21:02,340
composition and its really kind of fun

00:20:59,370 --> 00:21:04,620
building an application because as you

00:21:02,340 --> 00:21:08,270
move on you start reusing your chains

00:21:04,620 --> 00:21:11,520
and we start reusing your actions and

00:21:08,270 --> 00:21:14,190
but before I close of this presentation

00:21:11,520 --> 00:21:18,480
I forgot to set my timer I'm not sure

00:21:14,190 --> 00:21:19,770
how we are oh nice and I just want to

00:21:18,480 --> 00:21:22,860
show you how do you actually use this

00:21:19,770 --> 00:21:25,289
with a component so you would define

00:21:22,860 --> 00:21:28,110
some state in your state store and you

00:21:25,289 --> 00:21:31,020
would create your signals and with

00:21:28,110 --> 00:21:33,419
cerebral you get a decorator so we still

00:21:31,020 --> 00:21:36,090
need stateful components we need to

00:21:33,419 --> 00:21:39,090
listen like grab state from other places

00:21:36,090 --> 00:21:41,309
and do other stuff and so what we would

00:21:39,090 --> 00:21:43,649
do is create a component that uses the

00:21:41,309 --> 00:21:45,809
cerebral decorator and this basically

00:21:43,649 --> 00:21:47,880
just means that ok I want an East

00:21:45,809 --> 00:21:50,460
loading state and a to-do state inside

00:21:47,880 --> 00:21:53,730
my component and I'm going to grab that

00:21:50,460 --> 00:21:57,120
state from its loading path and to do

00:21:53,730 --> 00:22:00,720
stuff and inside your component you have

00:21:57,120 --> 00:22:03,419
access to props so this state will be

00:22:00,720 --> 00:22:05,940
available on the prop subject and you

00:22:03,419 --> 00:22:08,370
also have access to the signals

00:22:05,940 --> 00:22:11,309
themselves so you say like props dot

00:22:08,370 --> 00:22:14,210
signals dot up mountain and you can call

00:22:11,309 --> 00:22:14,210
that signal

00:22:15,430 --> 00:22:20,080
you know this one quite well yeah I'm

00:22:18,070 --> 00:22:25,710
finished thanks so much for listening

00:22:20,080 --> 00:22:25,710
and maybe it can help you out great

00:22:27,180 --> 00:22:31,690
Thank You Christian ah we have a couple

00:22:30,040 --> 00:22:34,000
of questions from slider that we were

00:22:31,690 --> 00:22:38,980
great if you can answer any remaining

00:22:34,000 --> 00:22:42,850
five minutes uh-huh which benefit

00:22:38,980 --> 00:22:45,130
cerebral have over wheel so redox

00:22:42,850 --> 00:22:47,560
doesn't really have a concept for

00:22:45,130 --> 00:22:50,800
handling complex state changes you have

00:22:47,560 --> 00:22:55,900
like this action creator which basically

00:22:50,800 --> 00:22:58,120
is just a function and then you have you

00:22:55,900 --> 00:23:00,160
have to like do all the requests you

00:22:58,120 --> 00:23:04,510
have to implement everything you do not

00:23:00,160 --> 00:23:06,070
really have an abstraction over em like

00:23:04,510 --> 00:23:09,100
like with cerebral it's like an

00:23:06,070 --> 00:23:12,400
obstruction of abstraction above if that

00:23:09,100 --> 00:23:14,440
makes sense I'm not like an expert in

00:23:12,400 --> 00:23:17,980
redox I am actually working on the

00:23:14,440 --> 00:23:21,280
project now using redux but yeah that is

00:23:17,980 --> 00:23:29,860
my statement on that hopefully it makes

00:23:21,280 --> 00:23:32,230
sense call back hell I am not met maybe

00:23:29,860 --> 00:23:34,750
you think about the tree structure that

00:23:32,230 --> 00:23:36,940
it looks can I call back hell the

00:23:34,750 --> 00:23:40,510
example I shall know is like really

00:23:36,940 --> 00:23:41,940
complex and I want to compare it to call

00:23:40,510 --> 00:23:43,840
back hell because that's like

00:23:41,940 --> 00:23:47,380
implementation what we're doing is

00:23:43,840 --> 00:23:49,450
declaratively expressing how our state

00:23:47,380 --> 00:23:52,120
changes should run inside our

00:23:49,450 --> 00:23:54,250
application but maybe that's more a

00:23:52,120 --> 00:23:59,080
matter of opinion I don't think of it

00:23:54,250 --> 00:24:03,130
like that at least um do we get runtime

00:23:59,080 --> 00:24:04,690
error and well actually these actions if

00:24:03,130 --> 00:24:07,150
you're working in the bigger application

00:24:04,690 --> 00:24:10,720
you have the possibility to define what

00:24:07,150 --> 00:24:12,610
outputs should this action have and you

00:24:10,720 --> 00:24:16,570
can type check its input so you can type

00:24:12,610 --> 00:24:19,060
check its output and so in the case with

00:24:16,570 --> 00:24:22,210
the error here you can say that this

00:24:19,060 --> 00:24:25,630
should have an error output and if you

00:24:22,210 --> 00:24:28,420
define that it will and it will

00:24:25,630 --> 00:24:28,990
instantly tell you when you fire up the

00:24:28,420 --> 00:24:30,460
application

00:24:28,990 --> 00:24:32,920
there's something wrong in this signal

00:24:30,460 --> 00:24:34,870
you said that this action warmth some

00:24:32,920 --> 00:24:37,270
output to an error but I can't find it

00:24:34,870 --> 00:24:41,410
if you do not define it it will happen

00:24:37,270 --> 00:24:44,920
at the runtime like when the action

00:24:41,410 --> 00:24:48,010
actually runs was how do we confirm this

00:24:44,920 --> 00:24:50,140
update if you're missing if you're not

00:24:48,010 --> 00:24:54,040
passing props down all the way are using

00:24:50,140 --> 00:24:57,010
them yeah exactly and so the decorator

00:24:54,040 --> 00:24:59,200
just wraps the component and listens to

00:24:57,010 --> 00:25:01,600
a change event on what we call the

00:24:59,200 --> 00:25:03,340
controller cerebral is a controller and

00:25:01,600 --> 00:25:06,700
when the change happens it will do a

00:25:03,340 --> 00:25:08,980
shallow check on the paths so it's

00:25:06,700 --> 00:25:12,220
important here that the state tree is

00:25:08,980 --> 00:25:14,370
immutable so you can use immutable jas

00:25:12,220 --> 00:25:17,260
or you can use baobab for example and

00:25:14,370 --> 00:25:20,530
and yes there's some events happening in

00:25:17,260 --> 00:25:23,620
the background and yeah I just answer

00:25:20,530 --> 00:25:26,110
that immutable J's yes it works is it

00:25:23,620 --> 00:25:29,880
already used in production the project

00:25:26,110 --> 00:25:33,790
I'm working on now is not in production

00:25:29,880 --> 00:25:35,830
but there are multiple projects using it

00:25:33,790 --> 00:25:37,780
now and so I can say no it's not

00:25:35,830 --> 00:25:41,320
production ready right now but it will

00:25:37,780 --> 00:25:43,740
be during this year untasted great thank

00:25:41,320 --> 00:25:43,740

YouTube URL: https://www.youtube.com/watch?v=MnFV6wEqKFE


