Title: Advanced React.js Performance | Daniel Hejl | ReactiveConf 2015
Publication date: 2017-06-29
Playlist: ReactiveConf 2015
Description: 
	I created this video with the YouTube Video Editor (https://www.youtube.com/editor)
Captions: 
	00:00:04,510 --> 00:00:09,960
yes so I want to talk to you today about

00:00:07,090 --> 00:00:13,180
performance by reacting performance its

00:00:09,960 --> 00:00:14,980
react is generally very fast but you

00:00:13,180 --> 00:00:16,990
know depending on what type of app we

00:00:14,980 --> 00:00:19,690
are building you might still hate it's

00:00:16,990 --> 00:00:22,779
performance limits especially if your

00:00:19,690 --> 00:00:26,500
your dome is very complex if you are

00:00:22,779 --> 00:00:28,330
trying to fit into one one frame into 16

00:00:26,500 --> 00:00:31,150
milliseconds or if you are supporting

00:00:28,330 --> 00:00:32,980
mobile browsers and the problem I see is

00:00:31,150 --> 00:00:35,560
that there are not really many advanced

00:00:32,980 --> 00:00:37,780
articles explaining how the internals of

00:00:35,560 --> 00:00:40,960
react really works and how you can

00:00:37,780 --> 00:00:43,510
optimize your apps above you know the

00:00:40,960 --> 00:00:46,390
basic stuff like should component update

00:00:43,510 --> 00:00:51,430
our using immutable what we've heard

00:00:46,390 --> 00:00:53,500
about a lot today now some very smart

00:00:51,430 --> 00:00:55,059
people on the Internet building

00:00:53,500 --> 00:00:59,170
different benchmarks trying to

00:00:55,059 --> 00:01:02,230
understand in which scenarios react is

00:00:59,170 --> 00:01:04,960
very fast in which in which it's not

00:01:02,230 --> 00:01:08,590
that fast one of them is Paul's Lewis

00:01:04,960 --> 00:01:12,490
from Google he built this benchmark

00:01:08,590 --> 00:01:15,160
where he tried to see you know how is

00:01:12,490 --> 00:01:17,740
the app fast based on how many don't

00:01:15,160 --> 00:01:19,450
elements you are rendering but then if

00:01:17,740 --> 00:01:22,390
some you know other very smart people

00:01:19,450 --> 00:01:25,030
from the erect core team saying it okay

00:01:22,390 --> 00:01:27,130
so but this is not the use case we are

00:01:25,030 --> 00:01:29,950
really optimizing for this is not we

00:01:27,130 --> 00:01:31,630
really care so I was like thinking okay

00:01:29,950 --> 00:01:34,150
so what does this all mean

00:01:31,630 --> 00:01:37,420
what is reactively optimized for and how

00:01:34,150 --> 00:01:42,630
do we solve the other use cases one

00:01:37,420 --> 00:01:45,490
really insightful post was by Ben Alpert

00:01:42,630 --> 00:01:48,250
explaining that react right now is

00:01:45,490 --> 00:01:51,400
optimized for initial page rendering and

00:01:48,250 --> 00:01:53,740
for creating abstractions without you

00:01:51,400 --> 00:01:56,620
know too much overhead but it's not

00:01:53,740 --> 00:01:59,350
optimized so far is for rendering long

00:01:56,620 --> 00:02:01,690
lists of items and the reason for this

00:01:59,350 --> 00:02:04,300
is that if you have long lists of items

00:02:01,690 --> 00:02:06,460
you can do something like pagination or

00:02:04,300 --> 00:02:07,619
infinite scroll and it's not your

00:02:06,460 --> 00:02:11,470
problem anymore

00:02:07,619 --> 00:02:13,810
but so how does this look like in real

00:02:11,470 --> 00:02:15,609
life we are burning this ad where you

00:02:13,810 --> 00:02:17,730
know we are we are having this problem

00:02:15,609 --> 00:02:21,300
we have lots of rows

00:02:17,730 --> 00:02:24,510
you know these are like features and you

00:02:21,300 --> 00:02:26,340
can have like to hundreds of them or for

00:02:24,510 --> 00:02:29,340
hundreds of them and you have different

00:02:26,340 --> 00:02:30,989
like visualizations saying okay how much

00:02:29,340 --> 00:02:33,299
this feature impacts different business

00:02:30,989 --> 00:02:35,220
metrics so it's like this big dashboard

00:02:33,299 --> 00:02:38,400
but the problem we have is that we

00:02:35,220 --> 00:02:41,489
cannot really infinite scroll it because

00:02:38,400 --> 00:02:44,879
we are not able to render the lines fast

00:02:41,489 --> 00:02:48,150
enough so you could get smooth scrolling

00:02:44,879 --> 00:02:51,000
so we had to try to optimize this in a

00:02:48,150 --> 00:02:52,769
different way try to look into the react

00:02:51,000 --> 00:02:56,120
source code and try to understand what

00:02:52,769 --> 00:03:00,049
are the other dirty tricks we can do to

00:02:56,120 --> 00:03:02,579
optimize our app we are obviously using

00:03:00,049 --> 00:03:04,980
should component update and immutable

00:03:02,579 --> 00:03:07,049
where it's possible but that was not

00:03:04,980 --> 00:03:09,450
enough for us so today I want to share

00:03:07,049 --> 00:03:11,280
three tricks that helped us to make it

00:03:09,450 --> 00:03:15,780
faster even though we are not using

00:03:11,280 --> 00:03:18,450
infinite scrolling first of them is

00:03:15,780 --> 00:03:20,970
trying to limit reconciliation as much

00:03:18,450 --> 00:03:23,040
as possible there is one example I want

00:03:20,970 --> 00:03:26,370
to pin point here is that this is how

00:03:23,040 --> 00:03:28,980
our component looked at the beginning

00:03:26,370 --> 00:03:31,530
you know this is simple for example like

00:03:28,980 --> 00:03:34,829
table component that that's rendering a

00:03:31,530 --> 00:03:38,090
list of rows but the problem here is

00:03:34,829 --> 00:03:41,370
this part which is like a static HTML

00:03:38,090 --> 00:03:44,700
that gets rear-ended every time some of

00:03:41,370 --> 00:03:47,730
the children gets rendered so it will

00:03:44,700 --> 00:03:51,120
get reconciled and that's cost you

00:03:47,730 --> 00:03:54,060
precious time so you need to avoid this

00:03:51,120 --> 00:03:56,750
as much as possible and one trick is you

00:03:54,060 --> 00:03:59,340
can you can make small more granular

00:03:56,750 --> 00:04:02,790
components and do should component and

00:03:59,340 --> 00:04:07,099
they there so it will get escaped but

00:04:02,790 --> 00:04:12,450
other take what you can do is use babel

00:04:07,099 --> 00:04:17,099
optimization called in constant elements

00:04:12,450 --> 00:04:21,900
which comes with babel 5.18 i think and

00:04:17,099 --> 00:04:25,710
react 14 which in compile phase takes

00:04:21,900 --> 00:04:28,409
your static HTML and you know puts it

00:04:25,710 --> 00:04:30,600
somewhere else so it's not being

00:04:28,409 --> 00:04:33,150
evaluated every time and

00:04:30,600 --> 00:04:36,900
actually skips the reconciliation phase

00:04:33,150 --> 00:04:39,090
for you so this was very helpful another

00:04:36,900 --> 00:04:40,800
trick is that today you've seen probably

00:04:39,090 --> 00:04:45,060
several times that there is a it's a

00:04:40,800 --> 00:04:48,030
good design decision to try to take all

00:04:45,060 --> 00:04:51,480
the data you have in your state and send

00:04:48,030 --> 00:04:54,300
it through the component hierarchy

00:04:51,480 --> 00:04:57,210
through probes and one of the things we

00:04:54,300 --> 00:05:00,000
used is that we skipped days and we are

00:04:57,210 --> 00:05:01,740
doing it instead down in the latest

00:05:00,000 --> 00:05:06,000
component you know in down in the three

00:05:01,740 --> 00:05:07,620
which helped us around like 20% improve

00:05:06,000 --> 00:05:10,500
the performance and there is explanation

00:05:07,620 --> 00:05:12,390
for this and that is even though if you

00:05:10,500 --> 00:05:13,980
have implemented should compile update

00:05:12,390 --> 00:05:16,250
the component 3-stone needs to be

00:05:13,980 --> 00:05:20,700
created and it takes a lot of time and

00:05:16,250 --> 00:05:23,520
memory and as last trick is using just

00:05:20,700 --> 00:05:26,310
pure JavaScript avoid attract completely

00:05:23,520 --> 00:05:29,060
for things like animations that's it

00:05:26,310 --> 00:05:29,060

YouTube URL: https://www.youtube.com/watch?v=GXzbbkiJZsY


