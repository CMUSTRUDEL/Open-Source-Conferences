Title: Reactive Online Meetup|How to Design Complex Async Apps
Publication date: 2020-11-13
Playlist: Reactive Online Meetups
Description: 
	𝗔𝗟𝗘𝗫𝗔𝗡𝗗𝗘𝗥 𝗦𝗠𝗜𝗥𝗡𝗢𝗩
 Mews Developers
#metatalk
𝗧𝗔𝗟𝗞
Running custom neural networks in a browser
𝗧𝗔𝗟𝗞 𝗔𝗕𝗦𝗧𝗥𝗔𝗖𝗧
The talk will be about how to train a classification model, how to convert it to a specific browser-readable format, how to run it in a browser, and why would you actually want to do it.
𝗕𝗜𝗢
Alexander is a Software Developer at Mews and a Computer Science Student started with Competitive Programming and after a journey through Robotics, Information Security and Game Development ended up in Frontend Development.

𝗗𝗔𝗩𝗜𝗗 𝗞𝗛𝗢𝗨𝗥𝗦𝗛𝗜𝗗
Microsoft, XState
#devtalk
𝗧𝗔𝗟𝗞
Everything is an Actor
𝗧𝗔𝗟𝗞 𝗔𝗕𝗦𝗧𝗥𝗔𝗖𝗧
If the word "async" scares you, you're not alone. Time is the one variable that introduces the most complexity in software. Thankfully, the Actor Model can hold the key to simplifying the reactive apps we work on. Learn how this nearly 50-year-old event-driven model can improve the way we architect complex apps.
𝗕𝗜𝗢
David is a software engineer at Microsoft and the creator of XState. He's passionate about state machines, software modeling, animations, and innovative user interfaces. When he's not at his computer keyboard, he's at his piano keyboard.

--------------------------------

𝗚𝗢𝗜𝗡𝗚 𝗢𝗡𝗟𝗜𝗡𝗘:
Stay home. Stay safe. And, stay connected to the community.
We realize our meetups and gatherings were not just about the high-quality content talks but mostly about the post networking and discussions you could lead with like-minded developers. We are planning on keeping the Slack channel for communication about all of our following online meetups, your one on one communication, and hope it will be the meeting point of our online community.

𝗦𝗟𝗔𝗖𝗞 𝗡𝗘𝗧𝗪𝗢𝗥𝗞𝗜𝗡𝗚
http://bit.ly/chat_with_speakers
---------------------------------------
Captions: 
	00:00:03,360 --> 00:00:08,000
welcome

00:00:04,160 --> 00:00:09,920
to our 10th reactive online meetup

00:00:08,000 --> 00:00:12,559
uh i'm really excited that you made a

00:00:09,920 --> 00:00:14,559
decision to join us today for a special

00:00:12,559 --> 00:00:16,240
online meetup in which we are going to

00:00:14,559 --> 00:00:19,680
deep dive into the topic of

00:00:16,240 --> 00:00:22,960
how to design complex async apps

00:00:19,680 --> 00:00:25,359
so just to prepare the e-ground for our

00:00:22,960 --> 00:00:29,760
next speakers

00:00:25,359 --> 00:00:32,960
who are with meta talk alexander smirnov

00:00:29,760 --> 00:00:35,200
and the talk has a title

00:00:32,960 --> 00:00:36,239
of running custom neural networks in the

00:00:35,200 --> 00:00:39,120
browser

00:00:36,239 --> 00:00:41,280
and our dev talk will be presented by

00:00:39,120 --> 00:00:44,640
david kurshit

00:00:41,280 --> 00:00:47,600
and the title is everything is an actor

00:00:44,640 --> 00:00:48,640
uh just before we start i would like uh

00:00:47,600 --> 00:00:51,840
also to thank

00:00:48,640 --> 00:00:54,399
our media partner uh jiva

00:00:51,840 --> 00:00:57,120
eska which is an online magazine which

00:00:54,399 --> 00:00:58,239
observes current news from i.t startups

00:00:57,120 --> 00:01:01,039
and businesses

00:00:58,239 --> 00:01:03,600
so if you are fluent in chegg or slovak

00:01:01,039 --> 00:01:06,400
make sure to check it out

00:01:03,600 --> 00:01:06,799
uh just to introduce myself uh my name

00:01:06,400 --> 00:01:10,240
is

00:01:06,799 --> 00:01:12,640
andy or andre and i'm from vacuum labs

00:01:10,240 --> 00:01:14,320
which is a company that started the

00:01:12,640 --> 00:01:17,520
reactive calm

00:01:14,320 --> 00:01:19,600
in its beginnings in 2015

00:01:17,520 --> 00:01:22,320
vacuum labs focuses on providing

00:01:19,600 --> 00:01:24,400
flexible and reliable software engineers

00:01:22,320 --> 00:01:26,880
to clients all over the world

00:01:24,400 --> 00:01:28,799
and we help them build fintech

00:01:26,880 --> 00:01:30,320
blockchain projects or online

00:01:28,799 --> 00:01:33,040
marketplaces

00:01:30,320 --> 00:01:35,119
uh just before we start i would like to

00:01:33,040 --> 00:01:39,439
inform you about two things

00:01:35,119 --> 00:01:42,880
uh and that is q a uh and the slack

00:01:39,439 --> 00:01:43,360
so regarding the q a there is an option

00:01:42,880 --> 00:01:46,159
to

00:01:43,360 --> 00:01:46,960
ask the questions on the bottom of your

00:01:46,159 --> 00:01:49,920
zoom window

00:01:46,960 --> 00:01:51,920
so just use the chat uh feel free to ask

00:01:49,920 --> 00:01:55,439
questions during the presentation

00:01:51,920 --> 00:01:58,479
i will try to get to all of them after

00:01:55,439 --> 00:02:02,000
the the speakers

00:01:58,479 --> 00:02:02,799
uh ends their talks uh and then there is

00:02:02,000 --> 00:02:05,920
a slack

00:02:02,799 --> 00:02:09,360
so if we will not have enough time to

00:02:05,920 --> 00:02:12,480
get to all of the questions uh you can

00:02:09,360 --> 00:02:14,920
you are free to

00:02:12,480 --> 00:02:16,480
join our slack channel

00:02:14,920 --> 00:02:19,280
reactiveonlinemeetup.com

00:02:16,480 --> 00:02:20,400
link will be also in the in the chat

00:02:19,280 --> 00:02:23,680
here on zoom

00:02:20,400 --> 00:02:27,280
and you can discuss all the topics there

00:02:23,680 --> 00:02:29,840
uh alex and david are also there so

00:02:27,280 --> 00:02:31,920
so you can ask some more questions after

00:02:29,840 --> 00:02:34,840
uh after this meetup is done

00:02:31,920 --> 00:02:36,480
uh so i will not postpone the talks any

00:02:34,840 --> 00:02:40,000
longer uh

00:02:36,480 --> 00:02:42,959
let's start with the first one so alex

00:02:40,000 --> 00:02:44,879
are you here you can unmute yourself i

00:02:42,959 --> 00:02:47,920
hope you are ready

00:02:44,879 --> 00:02:49,440
yes hello everyone yep let me quickly

00:02:47,920 --> 00:02:51,500
share my screen

00:02:49,440 --> 00:02:53,840
great so let's see

00:02:51,500 --> 00:02:57,040
[Music]

00:02:53,840 --> 00:02:58,159
everything works so we are really

00:02:57,040 --> 00:03:01,120
looking forward

00:02:58,159 --> 00:03:02,879
feel free to start okay hello everyone

00:03:01,120 --> 00:03:04,159
my name is alex i'm a front-end

00:03:02,879 --> 00:03:05,440
developer at muse

00:03:04,159 --> 00:03:07,360
and today i'm going to tell you about

00:03:05,440 --> 00:03:07,920
how to create and run a custom neural

00:03:07,360 --> 00:03:10,959
network

00:03:07,920 --> 00:03:11,840
in a browser now before we begin why

00:03:10,959 --> 00:03:14,080
this topic

00:03:11,840 --> 00:03:15,760
well i myself was always inspired by

00:03:14,080 --> 00:03:18,080
neural networks and

00:03:15,760 --> 00:03:18,879
the way they make predictions on data

00:03:18,080 --> 00:03:20,879
just always

00:03:18,879 --> 00:03:22,080
feel like magic even after i found out

00:03:20,879 --> 00:03:23,599
how they work

00:03:22,080 --> 00:03:25,519
and i believe that they have a lot of

00:03:23,599 --> 00:03:28,239
potential and being able to run them in

00:03:25,519 --> 00:03:30,319
a browser well that opens a lot of doors

00:03:28,239 --> 00:03:32,000
before we begin the source code is

00:03:30,319 --> 00:03:34,319
available by the links on the left

00:03:32,000 --> 00:03:35,599
and the qr code on the rights and i will

00:03:34,319 --> 00:03:37,280
show the links at the very end of the

00:03:35,599 --> 00:03:39,760
presentation as well

00:03:37,280 --> 00:03:41,680
okay let's do this so this talk will be

00:03:39,760 --> 00:03:43,200
split into three main parts

00:03:41,680 --> 00:03:44,720
the what where i'll give you a brief

00:03:43,200 --> 00:03:46,640
introduction to what neural networks

00:03:44,720 --> 00:03:48,560
actually are the how

00:03:46,640 --> 00:03:50,480
where i'll actually tell you how to

00:03:48,560 --> 00:03:52,560
create and train a model

00:03:50,480 --> 00:03:54,000
and how to run it in the browser and the

00:03:52,560 --> 00:03:55,280
why we'll tell you about

00:03:54,000 --> 00:03:57,439
why would you want to do this in the

00:03:55,280 --> 00:03:58,720
first place so let's start with the

00:03:57,439 --> 00:04:01,280
first topic

00:03:58,720 --> 00:04:03,200
what is a neural network well a

00:04:01,280 --> 00:04:05,439
artificial neural network is an

00:04:03,200 --> 00:04:07,040
algorithm or a computational system

00:04:05,439 --> 00:04:08,879
that is inspired by our brains

00:04:07,040 --> 00:04:10,400
biological neural networks

00:04:08,879 --> 00:04:13,439
and they're really good at recognizing

00:04:10,400 --> 00:04:16,720
patterns in a large set of complex data

00:04:13,439 --> 00:04:19,840
now a typical neural network is a graph

00:04:16,720 --> 00:04:22,800
that consists of input nodes or neurons

00:04:19,840 --> 00:04:24,080
output nodes hidden nodes in between and

00:04:22,800 --> 00:04:26,800
the connections between them

00:04:24,080 --> 00:04:27,520
or edges or synapses now these edges are

00:04:26,800 --> 00:04:29,280
important

00:04:27,520 --> 00:04:30,880
each one of them has a weight assigned

00:04:29,280 --> 00:04:32,960
to it and you could

00:04:30,880 --> 00:04:34,880
view it as a water pipe the higher the

00:04:32,960 --> 00:04:36,320
weight or the diameter the more water

00:04:34,880 --> 00:04:38,320
goes through

00:04:36,320 --> 00:04:41,120
now the real cool thing happens when you

00:04:38,320 --> 00:04:43,680
provide the network with inputs

00:04:41,120 --> 00:04:45,120
in this case uh pixel values of this

00:04:43,680 --> 00:04:46,880
image of a dog

00:04:45,120 --> 00:04:48,320
so the network will take these inputs

00:04:46,880 --> 00:04:49,680
and it will push them through the layers

00:04:48,320 --> 00:04:50,639
and remember some edges let through more

00:04:49,680 --> 00:04:52,000
than the others

00:04:50,639 --> 00:04:53,680
so it will push it through the layers

00:04:52,000 --> 00:04:55,199
until it reaches the output

00:04:53,680 --> 00:04:56,960
and one of the output nodes will have a

00:04:55,199 --> 00:04:58,479
higher value than the others

00:04:56,960 --> 00:05:00,479
and that would be the guess or the

00:04:58,479 --> 00:05:02,000
prediction of the network

00:05:00,479 --> 00:05:04,240
and obviously different inputs would

00:05:02,000 --> 00:05:07,039
provide different results

00:05:04,240 --> 00:05:08,240
and this is called a classification

00:05:07,039 --> 00:05:09,840
neural network

00:05:08,240 --> 00:05:11,759
because it assigns a class from a fixed

00:05:09,840 --> 00:05:13,759
set to an input and that's exactly what

00:05:11,759 --> 00:05:15,440
we're going to be building today

00:05:13,759 --> 00:05:17,440
but before we get to it let's talk about

00:05:15,440 --> 00:05:18,000
weights for a second so the weights are

00:05:17,440 --> 00:05:19,360
important

00:05:18,000 --> 00:05:22,160
if you know the weights you basically

00:05:19,360 --> 00:05:23,919
have a model that can run predictions

00:05:22,160 --> 00:05:26,160
question is how do you find these

00:05:23,919 --> 00:05:28,080
weights well this process is called

00:05:26,160 --> 00:05:29,840
training the network and we're going to

00:05:28,080 --> 00:05:33,199
cover it in the next step

00:05:29,840 --> 00:05:35,039
how let's remember our initial goal

00:05:33,199 --> 00:05:36,560
is to be able to run a custom neural

00:05:35,039 --> 00:05:38,160
network in a browser

00:05:36,560 --> 00:05:40,400
and to do that we need to do three main

00:05:38,160 --> 00:05:41,440
things first we need to collect a label

00:05:40,400 --> 00:05:43,520
data set

00:05:41,440 --> 00:05:44,800
then we need to create the model and

00:05:43,520 --> 00:05:46,800
train it on the data set

00:05:44,800 --> 00:05:48,080
to find the weights and finally we

00:05:46,800 --> 00:05:50,479
wanted to import to

00:05:48,080 --> 00:05:51,199
it to javascript and run predictions so

00:05:50,479 --> 00:05:53,440
let's go through

00:05:51,199 --> 00:05:54,960
through these one by one first of all

00:05:53,440 --> 00:05:57,199
collecting a data set

00:05:54,960 --> 00:05:58,639
why well because the easiest way to

00:05:57,199 --> 00:06:01,120
train the model to find

00:05:58,639 --> 00:06:02,400
the ways is to give it a large set of

00:06:01,120 --> 00:06:04,000
pre-label data

00:06:02,400 --> 00:06:05,840
basically the network will run

00:06:04,000 --> 00:06:07,440
predictions on it it will compare the

00:06:05,840 --> 00:06:08,080
outputs to the actual labels that you

00:06:07,440 --> 00:06:09,680
provide

00:06:08,080 --> 00:06:11,600
and it will learn its mistakes over and

00:06:09,680 --> 00:06:12,479
over again until over the course of many

00:06:11,600 --> 00:06:13,919
iterations

00:06:12,479 --> 00:06:15,520
it will get closer and closer to the

00:06:13,919 --> 00:06:17,919
ideal weights

00:06:15,520 --> 00:06:19,919
so for this example here i've collected

00:06:17,919 --> 00:06:20,639
over a hundred thousand images of

00:06:19,919 --> 00:06:23,120
handwritten

00:06:20,639 --> 00:06:24,880
letters and digits and we're going to be

00:06:23,120 --> 00:06:27,840
using this for training the

00:06:24,880 --> 00:06:29,600
network now speaking of training how do

00:06:27,840 --> 00:06:31,680
you actually do this

00:06:29,600 --> 00:06:33,600
well well you could train the network

00:06:31,680 --> 00:06:34,720
from scratch and write the code yourself

00:06:33,600 --> 00:06:36,880
it's a lot easier to use some

00:06:34,720 --> 00:06:37,919
third-party tools and today we're going

00:06:36,880 --> 00:06:40,479
to be using python

00:06:37,919 --> 00:06:42,240
and tensorflow where tensorflow is a set

00:06:40,479 --> 00:06:43,759
of utils and helper functions

00:06:42,240 --> 00:06:45,440
that really simplify the whole process

00:06:43,759 --> 00:06:46,880
of machine learning and one of the best

00:06:45,440 --> 00:06:48,960
parts about tensorflow is that it

00:06:46,880 --> 00:06:52,240
actually comes with tensorflow.js

00:06:48,960 --> 00:06:53,919
a javascript package that helps you with

00:06:52,240 --> 00:06:55,440
integrating machine learning tasks into

00:06:53,919 --> 00:06:57,680
your web app

00:06:55,440 --> 00:06:59,280
okay i know that probably not all of you

00:06:57,680 --> 00:07:00,479
here are familiar with python so i won't

00:06:59,280 --> 00:07:02,160
go into much detail

00:07:00,479 --> 00:07:04,160
in the next section but it's super

00:07:02,160 --> 00:07:06,400
simple i promise you

00:07:04,160 --> 00:07:08,160
so how do you make network in python

00:07:06,400 --> 00:07:09,599
well it only takes a few steps

00:07:08,160 --> 00:07:11,599
first you want to load the data set that

00:07:09,599 --> 00:07:13,599
you collected with a helper function

00:07:11,599 --> 00:07:15,120
then you want to create a model and here

00:07:13,599 --> 00:07:16,800
each line is one of those layers i was

00:07:15,120 --> 00:07:19,759
talking about the input output

00:07:16,800 --> 00:07:20,240
hidden and this is not the main topic of

00:07:19,759 --> 00:07:21,759
this

00:07:20,240 --> 00:07:24,000
talk so don't give too much thought to

00:07:21,759 --> 00:07:25,120
it anyway once you create the model you

00:07:24,000 --> 00:07:26,160
want to find the weights you want to

00:07:25,120 --> 00:07:27,840
train it

00:07:26,160 --> 00:07:29,280
and this is done using this one simple

00:07:27,840 --> 00:07:31,199
line however

00:07:29,280 --> 00:07:33,599
this line can take anywhere from minutes

00:07:31,199 --> 00:07:34,880
to hours days or weeks to finish

00:07:33,599 --> 00:07:37,280
depending on the complexity of the

00:07:34,880 --> 00:07:39,120
network and the size of the data set

00:07:37,280 --> 00:07:41,360
but once it's done there's not really

00:07:39,120 --> 00:07:42,560
much left to do you just need to

00:07:41,360 --> 00:07:45,680
export and save the model to the

00:07:42,560 --> 00:07:47,759
tensorflow.js format and that's it

00:07:45,680 --> 00:07:49,039
so with just four steps we've created a

00:07:47,759 --> 00:07:51,199
trained network

00:07:49,039 --> 00:07:53,199
how do we use it now well it's even

00:07:51,199 --> 00:07:53,520
easier in javascript you want to install

00:07:53,199 --> 00:07:56,080
and

00:07:53,520 --> 00:07:58,319
import the tensorflow.js package then

00:07:56,080 --> 00:07:59,599
load the model that you've just created

00:07:58,319 --> 00:08:00,879
after that you want to create an input

00:07:59,599 --> 00:08:02,000
tensor with the values you want to

00:08:00,879 --> 00:08:03,520
classify

00:08:02,000 --> 00:08:05,599
and in our case the values are going to

00:08:03,520 --> 00:08:07,039
be the pixel values of an image

00:08:05,599 --> 00:08:09,039
and the tensor is basically a

00:08:07,039 --> 00:08:11,039
n-dimensional vector so like

00:08:09,039 --> 00:08:12,720
a 0-dimensional would be a constant

00:08:11,039 --> 00:08:15,360
one-dimensional vector to the

00:08:12,720 --> 00:08:16,160
matrix and so on finally after you have

00:08:15,360 --> 00:08:18,240
the input

00:08:16,160 --> 00:08:19,599
you provide it to the model and it gives

00:08:18,240 --> 00:08:21,039
you the prediction back

00:08:19,599 --> 00:08:23,280
and the result of the prediction is

00:08:21,039 --> 00:08:24,560
basically an array of probabilities

00:08:23,280 --> 00:08:26,000
where each element gives you the

00:08:24,560 --> 00:08:29,199
probability of input

00:08:26,000 --> 00:08:30,960
representing this class and that's it

00:08:29,199 --> 00:08:33,039
four lines and we have a model running

00:08:30,960 --> 00:08:33,519
in the browser and what can we do with

00:08:33,039 --> 00:08:36,240
it

00:08:33,519 --> 00:08:36,240
let's take a look

00:08:36,959 --> 00:08:42,479
so this right here is basically a fancy

00:08:40,000 --> 00:08:43,680
wrapper around the four lines i showed

00:08:42,479 --> 00:08:47,120
you earlier

00:08:43,680 --> 00:08:48,959
what it does is it takes an input

00:08:47,120 --> 00:08:50,800
and it provides you with an output on

00:08:48,959 --> 00:08:52,640
the left you can see the prediction with

00:08:50,800 --> 00:08:54,640
the maximum probability

00:08:52,640 --> 00:08:56,480
while on the right is a map of all

00:08:54,640 --> 00:08:58,160
classes that the network knows about and

00:08:56,480 --> 00:08:59,600
the probabilities of them

00:08:58,160 --> 00:09:03,120
and right now you see that it's almost

00:08:59,600 --> 00:09:06,000
certain that well what i drew is a p

00:09:03,120 --> 00:09:07,440
but if i draw a line like this network

00:09:06,000 --> 00:09:08,720
is not really sure it could be an i

00:09:07,440 --> 00:09:09,920
could be an l because both of those

00:09:08,720 --> 00:09:11,680
could be a line

00:09:09,920 --> 00:09:13,360
but it could be any other of these

00:09:11,680 --> 00:09:16,480
things and it's actually true

00:09:13,360 --> 00:09:18,240
if i add this line here the network is

00:09:16,480 --> 00:09:22,399
fairly certain it's a y

00:09:18,240 --> 00:09:24,560
and when i add this it knows it's an x

00:09:22,399 --> 00:09:25,519
and the cool part about neural networks

00:09:24,560 --> 00:09:28,000
is that while

00:09:25,519 --> 00:09:28,560
it can take a while for them to train

00:09:28,000 --> 00:09:30,880
running

00:09:28,560 --> 00:09:32,320
doesn't really take much and this

00:09:30,880 --> 00:09:34,640
network is fairly simple

00:09:32,320 --> 00:09:36,320
so basically the prediction speed here

00:09:34,640 --> 00:09:38,000
is almost real time

00:09:36,320 --> 00:09:39,760
and you can see that as while i draw

00:09:38,000 --> 00:09:41,120
this line the network basically run all

00:09:39,760 --> 00:09:42,880
those predictions

00:09:41,120 --> 00:09:44,320
real time and right now it's not really

00:09:42,880 --> 00:09:45,680
sure what i'm drawing but as soon as i

00:09:44,320 --> 00:09:48,000
start adding this line

00:09:45,680 --> 00:09:48,959
it becomes certain it's a 7 and when i

00:09:48,000 --> 00:09:52,480
add this

00:09:48,959 --> 00:09:55,600
it knows it says that so

00:09:52,480 --> 00:09:58,880
this is a neural network in a browser

00:09:55,600 --> 00:10:00,880
and it basically answers our question on

00:09:58,880 --> 00:10:02,720
how to do this and a quick disclaimer

00:10:00,880 --> 00:10:04,480
this network is really simple

00:10:02,720 --> 00:10:06,320
and i only trade it for a few hours so

00:10:04,480 --> 00:10:09,120
the predictions are not perfect

00:10:06,320 --> 00:10:10,079
but if you increase the complexity of

00:10:09,120 --> 00:10:11,760
the model

00:10:10,079 --> 00:10:13,920
or you train it for longer on a bigger

00:10:11,760 --> 00:10:16,000
data set you get progressively higher

00:10:13,920 --> 00:10:19,360
values of accuracy

00:10:16,000 --> 00:10:21,279
anyway now that we know how to create a

00:10:19,360 --> 00:10:22,000
network in the browser and how to run it

00:10:21,279 --> 00:10:24,399
there

00:10:22,000 --> 00:10:27,519
let's go back to the presentation and

00:10:24,399 --> 00:10:27,519
answer the final question

00:10:28,320 --> 00:10:32,160
why well actually there are two

00:10:31,680 --> 00:10:35,279
questions

00:10:32,160 --> 00:10:36,480
here why would you run it in the browser

00:10:35,279 --> 00:10:38,880
and why would you use it in the first

00:10:36,480 --> 00:10:40,240
place so let's start with the first one

00:10:38,880 --> 00:10:43,279
why in a browser

00:10:40,240 --> 00:10:44,720
well the obvious opposite way of doing

00:10:43,279 --> 00:10:45,760
this would be running it in the server

00:10:44,720 --> 00:10:48,160
and communicating

00:10:45,760 --> 00:10:49,519
by requests and both of these approaches

00:10:48,160 --> 00:10:51,839
have their pros and cons so

00:10:49,519 --> 00:10:53,200
let's take a look at a few first of all

00:10:51,839 --> 00:10:54,800
if you're on a network in the browser

00:10:53,200 --> 00:10:56,640
the prediction speed will depend on the

00:10:54,800 --> 00:10:57,920
device of the user because

00:10:56,640 --> 00:11:00,240
they're all the computations will be

00:10:57,920 --> 00:11:01,120
done on their end while on the server

00:11:00,240 --> 00:11:03,440
it's constant

00:11:01,120 --> 00:11:04,959
for your server on the other hand the

00:11:03,440 --> 00:11:06,800
prediction speed in browser networks

00:11:04,959 --> 00:11:08,240
doesn't depend on the number of users

00:11:06,800 --> 00:11:10,320
while on the server it would be

00:11:08,240 --> 00:11:12,959
bottlenecked if you have a lot of user

00:11:10,320 --> 00:11:15,440
accessing at the same time

00:11:12,959 --> 00:11:17,040
also uh in a browser side network the

00:11:15,440 --> 00:11:18,399
users will have to download the whole

00:11:17,040 --> 00:11:20,959
model all the weights for it

00:11:18,399 --> 00:11:22,240
before they can use it and the files

00:11:20,959 --> 00:11:24,480
could be big it could be hundreds of

00:11:22,240 --> 00:11:25,760
megabytes or gigabytes or even more

00:11:24,480 --> 00:11:27,600
while on the server they only need to

00:11:25,760 --> 00:11:29,680
send requests with their input data and

00:11:27,600 --> 00:11:31,680
get the predictions back

00:11:29,680 --> 00:11:32,720
however not all users want to share

00:11:31,680 --> 00:11:34,399
their input data

00:11:32,720 --> 00:11:36,640
and on the browser side network they

00:11:34,399 --> 00:11:38,079
don't have to while on a server side

00:11:36,640 --> 00:11:38,880
network you don't have to share the

00:11:38,079 --> 00:11:41,279
trained model

00:11:38,880 --> 00:11:42,160
and you can keep it as a business secret

00:11:41,279 --> 00:11:44,640
finally

00:11:42,160 --> 00:11:46,000
browser site networks can run offline

00:11:44,640 --> 00:11:47,839
and they can be used for something like

00:11:46,000 --> 00:11:49,760
progressive web applications

00:11:47,839 --> 00:11:52,160
while for server side networks to work

00:11:49,760 --> 00:11:54,639
you have to have internet access

00:11:52,160 --> 00:11:56,079
now this is not a complete comparison

00:11:54,639 --> 00:11:58,000
but it gives you a basic overview

00:11:56,079 --> 00:11:59,360
of the differences between the two and

00:11:58,000 --> 00:12:01,040
you can see that the approach you should

00:11:59,360 --> 00:12:03,040
use highly depends on the type of the

00:12:01,040 --> 00:12:05,279
application you're developing

00:12:03,040 --> 00:12:06,720
now on the topic of applications why

00:12:05,279 --> 00:12:07,920
would you use a neural network in the

00:12:06,720 --> 00:12:10,079
first place

00:12:07,920 --> 00:12:11,519
well as i mentioned earlier you might

00:12:10,079 --> 00:12:13,279
want to use one when you need to find

00:12:11,519 --> 00:12:14,720
patterns and make predictions on a large

00:12:13,279 --> 00:12:16,480
set of complex data

00:12:14,720 --> 00:12:18,079
and examples that include something like

00:12:16,480 --> 00:12:18,959
image classification like we did right

00:12:18,079 --> 00:12:21,120
now

00:12:18,959 --> 00:12:22,320
or computer vision like those face masks

00:12:21,120 --> 00:12:23,760
in snapchat

00:12:22,320 --> 00:12:25,680
or voice recognition and voice

00:12:23,760 --> 00:12:27,120
generation or optimizing search results

00:12:25,680 --> 00:12:29,120
and many other things

00:12:27,120 --> 00:12:30,880
and a lot of companies already use

00:12:29,120 --> 00:12:32,720
machine learning in their products

00:12:30,880 --> 00:12:34,720
like google use it in their translator

00:12:32,720 --> 00:12:36,320
assistant a lot of other services

00:12:34,720 --> 00:12:38,639
like pinterest use it to optimize

00:12:36,320 --> 00:12:40,240
content discovery and airbnb

00:12:38,639 --> 00:12:42,639
use it to optimize search ranking and

00:12:40,240 --> 00:12:44,480
display the most relevant results

00:12:42,639 --> 00:12:46,079
now this is not a complete list that can

00:12:44,480 --> 00:12:49,040
go on forever

00:12:46,079 --> 00:12:50,320
and it basically answers the why and we

00:12:49,040 --> 00:12:54,000
already know the what

00:12:50,320 --> 00:12:56,240
and the how so let's sum it up

00:12:54,000 --> 00:12:58,000
neural networks can do a lot of things

00:12:56,240 --> 00:13:00,079
and coming up with a suitable design and

00:12:58,000 --> 00:13:02,240
layout for the model can be challenging

00:13:00,079 --> 00:13:03,519
but for a lot of tasks it's still easier

00:13:02,240 --> 00:13:06,240
than creating

00:13:03,519 --> 00:13:07,200
an actual algorithm the possibilities

00:13:06,240 --> 00:13:09,839
are literally

00:13:07,200 --> 00:13:10,480
limitless and if you ask me neural

00:13:09,839 --> 00:13:14,079
networks

00:13:10,480 --> 00:13:16,240
are the future thank you

00:13:14,079 --> 00:13:17,440
now the code once again is available by

00:13:16,240 --> 00:13:20,320
the links on the left

00:13:17,440 --> 00:13:21,760
and the qr code the socials are below

00:13:20,320 --> 00:13:24,399
and most importantly

00:13:21,760 --> 00:13:24,399
any questions

00:13:25,360 --> 00:13:28,639
thank you alex for our presentation

00:13:27,519 --> 00:13:31,680
thank you very much

00:13:28,639 --> 00:13:34,720
it was very insightful as far as i can

00:13:31,680 --> 00:13:35,680
see there are no questions no questions

00:13:34,720 --> 00:13:39,120
yet

00:13:35,680 --> 00:13:42,399
uh but just out of my

00:13:39,120 --> 00:13:44,000
curiosity uh do you have any if you have

00:13:42,399 --> 00:13:48,320
any personal experience

00:13:44,000 --> 00:13:51,440
with shipping those those networks to

00:13:48,320 --> 00:13:55,279
do a real clients uh how big

00:13:51,440 --> 00:13:58,000
are those models in in terms of

00:13:55,279 --> 00:13:59,680
size or or how big of a hit is it for a

00:13:58,000 --> 00:14:03,279
client because client is

00:13:59,680 --> 00:14:05,519
kind of performance uh or or size

00:14:03,279 --> 00:14:06,959
sensitive most of the time some mobile

00:14:05,519 --> 00:14:09,760
devices or something

00:14:06,959 --> 00:14:10,720
is this uh is this uh something which

00:14:09,760 --> 00:14:13,279
you

00:14:10,720 --> 00:14:15,199
would you have to optimize for or it

00:14:13,279 --> 00:14:17,519
doesn't really matter

00:14:15,199 --> 00:14:18,320
yeah well coming up with a suitable

00:14:17,519 --> 00:14:20,480
layout

00:14:18,320 --> 00:14:21,360
is a challenge and the more complex the

00:14:20,480 --> 00:14:23,519
layout is

00:14:21,360 --> 00:14:25,199
the higher will be the file size of the

00:14:23,519 --> 00:14:26,880
model so that's one of the biggest

00:14:25,199 --> 00:14:29,519
challenges of machine learning is

00:14:26,880 --> 00:14:31,839
finding the actual model you want to use

00:14:29,519 --> 00:14:33,120
and

00:14:31,839 --> 00:14:36,000
once again you don't have to ship the

00:14:33,120 --> 00:14:38,880
whole model you can start on the server

00:14:36,000 --> 00:14:39,760
but i think running it in the browser is

00:14:38,880 --> 00:14:42,880
really cool

00:14:39,760 --> 00:14:45,839
and one use that i see for this

00:14:42,880 --> 00:14:47,519
is chrome extensions because you could

00:14:45,839 --> 00:14:48,000
have an extension that monitors your web

00:14:47,519 --> 00:14:49,279
page

00:14:48,000 --> 00:14:52,079
and for example highlights things you

00:14:49,279 --> 00:14:54,639
want to see using neural networks

00:14:52,079 --> 00:14:56,399
but now answering a question i haven't

00:14:54,639 --> 00:14:56,800
used it in any real projects yet so this

00:14:56,399 --> 00:15:00,560
is my

00:14:56,800 --> 00:15:04,720
site research either way

00:15:00,560 --> 00:15:06,560
uh this is a quite interesting path

00:15:04,720 --> 00:15:08,639
which is worth following also in the

00:15:06,560 --> 00:15:12,399
future uh

00:15:08,639 --> 00:15:15,440
so can you maybe uh recommend

00:15:12,399 --> 00:15:18,639
some some sources or or or

00:15:15,440 --> 00:15:21,120
was the inspiration for you or who do

00:15:18,639 --> 00:15:23,760
you follow on twitter or something

00:15:21,120 --> 00:15:26,480
which which maybe we can recommend also

00:15:23,760 --> 00:15:26,959
to be able to the audience yeah well i

00:15:26,480 --> 00:15:28,800
was

00:15:26,959 --> 00:15:31,199
mostly inspired by the actual

00:15:28,800 --> 00:15:34,000
documentation of tensorflow

00:15:31,199 --> 00:15:35,519
and i set it as a challenge for myself

00:15:34,000 --> 00:15:37,120
can i run it in the browser

00:15:35,519 --> 00:15:39,120
and i started with a more complex

00:15:37,120 --> 00:15:40,560
network i used object detection instead

00:15:39,120 --> 00:15:44,639
of classification

00:15:40,560 --> 00:15:47,279
and those are much more complicated um

00:15:44,639 --> 00:15:48,880
but yeah it's basically the

00:15:47,279 --> 00:15:49,839
documentation and a lot of medium

00:15:48,880 --> 00:15:52,880
articles i

00:15:49,839 --> 00:15:52,880
wouldn't remember all of them

00:15:53,199 --> 00:15:58,639
so uh it's a neural network uh

00:15:56,639 --> 00:16:01,120
recommending you uh and other articles

00:15:58,639 --> 00:16:03,839
about the neural networks pretty much

00:16:01,120 --> 00:16:04,560
yeah yeah yeah completely understood uh

00:16:03,839 --> 00:16:07,600
so thank you

00:16:04,560 --> 00:16:10,720
thank you again uh alex uh or

00:16:07,600 --> 00:16:13,360
maybe there was one question

00:16:10,720 --> 00:16:14,560
uh just landed in the chat did you take

00:16:13,360 --> 00:16:18,240
any online courses

00:16:14,560 --> 00:16:20,560
can you suggest one uh i didn't

00:16:18,240 --> 00:16:21,519
well technically it's an online course

00:16:20,560 --> 00:16:23,120
but

00:16:21,519 --> 00:16:25,120
it's what my university provides like we

00:16:23,120 --> 00:16:26,800
have a machine learning course

00:16:25,120 --> 00:16:28,320
but i learned most of the things just by

00:16:26,800 --> 00:16:31,040
browsing stack overflow and

00:16:28,320 --> 00:16:31,040
documentation

00:16:34,240 --> 00:16:37,680
okay and there is a second question is

00:16:36,160 --> 00:16:39,040
there some possibility to split the

00:16:37,680 --> 00:16:42,079
memory workload

00:16:39,040 --> 00:16:43,040
between the server and the client sort

00:16:42,079 --> 00:16:46,720
of

00:16:43,040 --> 00:16:49,120
uh it's not really trivial because

00:16:46,720 --> 00:16:51,279
well you need the whole way all of the

00:16:49,120 --> 00:16:55,040
waits for the model to run predictions

00:16:51,279 --> 00:16:55,440
but if you spend enough time designing

00:16:55,040 --> 00:16:57,839
it

00:16:55,440 --> 00:17:00,240
you can split it to multiple networks

00:16:57,839 --> 00:17:01,759
that can make predictions in a row

00:17:00,240 --> 00:17:03,199
and then you could host some of them on

00:17:01,759 --> 00:17:04,000
the client side some of them on server

00:17:03,199 --> 00:17:06,480
side

00:17:04,000 --> 00:17:10,400
and somehow combine the results but i

00:17:06,480 --> 00:17:10,400
don't think i ever saw that in action

00:17:11,039 --> 00:17:14,480
yeah but theoretically possible

00:17:15,760 --> 00:17:18,799
then another question here in our

00:17:17,760 --> 00:17:21,520
official q a

00:17:18,799 --> 00:17:23,439
is it possible and advisable to use

00:17:21,520 --> 00:17:25,520
node.js for server side

00:17:23,439 --> 00:17:26,720
portion of learning i don't really want

00:17:25,520 --> 00:17:29,039
to dive into

00:17:26,720 --> 00:17:31,760
python it's definitely possible

00:17:29,039 --> 00:17:33,520
tensorflow.js supports learning

00:17:31,760 --> 00:17:35,679
but it's going to be really slow

00:17:33,520 --> 00:17:38,880
probably

00:17:35,679 --> 00:17:41,280
it depends because a lot of training

00:17:38,880 --> 00:17:44,640
processes are optimized by the gpu

00:17:41,280 --> 00:17:47,919
and tender tensorflow and python

00:17:44,640 --> 00:17:50,000
really um uses that a lot while

00:17:47,919 --> 00:17:51,440
node.js i'm not so sure but it's

00:17:50,000 --> 00:17:54,080
definitely possible and you could

00:17:51,440 --> 00:17:54,080
experiment with it

00:17:54,240 --> 00:17:58,400
okay i see another question can i

00:17:56,240 --> 00:18:00,400
compare neural networks to support

00:17:58,400 --> 00:18:04,080
vector machines performance wise

00:18:00,400 --> 00:18:05,679
i am not really experienced with svms

00:18:04,080 --> 00:18:07,840
so i can't give you an answer straight

00:18:05,679 --> 00:18:10,799
away but

00:18:07,840 --> 00:18:14,720
i'm pretty sure it's fairly simple to

00:18:10,799 --> 00:18:18,880
write a benchmark for these two

00:18:14,720 --> 00:18:22,640
yep okay so that's all for the questions

00:18:18,880 --> 00:18:25,760
uh and uh thank you thank you very much

00:18:22,640 --> 00:18:28,720
uh let's continue with david enjoy the

00:18:25,760 --> 00:18:28,720
rest of the evening

00:18:30,559 --> 00:18:34,480
cheers thank you david are you here are

00:18:33,039 --> 00:18:38,400
you ready

00:18:34,480 --> 00:18:43,120
i am uh yeah let me just

00:18:38,400 --> 00:18:46,559
get my desktop ready okay

00:18:43,120 --> 00:18:48,480
yep seems like everything works uh

00:18:46,559 --> 00:18:50,320
we're already looking forward so the

00:18:48,480 --> 00:18:52,640
stage is yours

00:18:50,320 --> 00:18:54,559
all right thank you uh first of all my

00:18:52,640 --> 00:18:56,400
name is david course sheet i'm at the

00:18:54,559 --> 00:18:58,559
avid key piano everywhere

00:18:56,400 --> 00:19:00,720
i'm a software engineer at microsoft and

00:18:58,559 --> 00:19:02,880
i created xstate but

00:19:00,720 --> 00:19:03,760
uh today i actually wants to talk to you

00:19:02,880 --> 00:19:06,000
about

00:19:03,760 --> 00:19:07,039
something called the actor model and

00:19:06,000 --> 00:19:09,440
that's uh

00:19:07,039 --> 00:19:11,520
that's what the talk is all about the

00:19:09,440 --> 00:19:13,120
fact that everything is an actor

00:19:11,520 --> 00:19:15,679
and so just simplifying everything to

00:19:13,120 --> 00:19:17,600
this notion of actors communicating with

00:19:15,679 --> 00:19:19,600
each other can really simplify the way

00:19:17,600 --> 00:19:21,679
we think about our software

00:19:19,600 --> 00:19:24,160
and all of the parts talking to each

00:19:21,679 --> 00:19:27,440
other and having to work with each other

00:19:24,160 --> 00:19:29,840
um so

00:19:27,440 --> 00:19:30,960
so yeah first let's consider a real-life

00:19:29,840 --> 00:19:32,720
example from

00:19:30,960 --> 00:19:34,960
you know better times when there wasn't

00:19:32,720 --> 00:19:36,080
a pandemic that completely interrupted

00:19:34,960 --> 00:19:37,600
our lives

00:19:36,080 --> 00:19:39,120
suppose you wanted to go to your

00:19:37,600 --> 00:19:41,600
favorite cafe

00:19:39,120 --> 00:19:42,799
to sit down get a coffee and maybe get

00:19:41,600 --> 00:19:45,440
some work done

00:19:42,799 --> 00:19:46,160
um we'll we'll use a dotted line to

00:19:45,440 --> 00:19:48,000
represent

00:19:46,160 --> 00:19:50,400
sort of a timeline of events that could

00:19:48,000 --> 00:19:53,039
happen in this interaction

00:19:50,400 --> 00:19:54,640
so you walk up to the cashier and you

00:19:53,039 --> 00:19:57,039
ask for a coffee

00:19:54,640 --> 00:19:58,960
and the cashier has to tell the barista

00:19:57,039 --> 00:20:01,679
what the coffee order is

00:19:58,960 --> 00:20:02,559
so they could start making it and in the

00:20:01,679 --> 00:20:04,400
meantime

00:20:02,559 --> 00:20:06,000
the cashier tells you that it's going to

00:20:04,400 --> 00:20:08,400
be three euro

00:20:06,000 --> 00:20:09,840
so you get your credit card out and you

00:20:08,400 --> 00:20:13,280
pay the three euro

00:20:09,840 --> 00:20:16,080
and so now that payment process itself

00:20:13,280 --> 00:20:17,760
is a series of events so from securely

00:20:16,080 --> 00:20:19,919
sending the credit card information

00:20:17,760 --> 00:20:21,280
to a payment gateway you know getting

00:20:19,919 --> 00:20:21,840
confirmation that the payment went

00:20:21,280 --> 00:20:24,559
through

00:20:21,840 --> 00:20:26,000
adding a tip uh maybe registering reward

00:20:24,559 --> 00:20:27,679
points if they're a frequent customer

00:20:26,000 --> 00:20:28,960
and whatever else the payment platform

00:20:27,679 --> 00:20:30,559
may do

00:20:28,960 --> 00:20:32,880
so when you meet your payment the

00:20:30,559 --> 00:20:35,919
cashier then gives you a receipt

00:20:32,880 --> 00:20:38,400
and then you wait a few minutes and the

00:20:35,919 --> 00:20:39,600
barista prepares the coffee gives it to

00:20:38,400 --> 00:20:41,600
the cashier

00:20:39,600 --> 00:20:42,720
and then the cashier delivers the coffee

00:20:41,600 --> 00:20:44,720
to you

00:20:42,720 --> 00:20:46,960
so getting a cup of coffee in the

00:20:44,720 --> 00:20:48,159
morning actually involves a lot more

00:20:46,960 --> 00:20:51,760
communication

00:20:48,159 --> 00:20:53,840
than you may think now

00:20:51,760 --> 00:20:55,120
there's this idea called eventual

00:20:53,840 --> 00:20:57,280
consistency

00:20:55,120 --> 00:20:59,280
that states that in the distributed

00:20:57,280 --> 00:20:59,679
system everything observing of value

00:20:59,280 --> 00:21:01,679
will

00:20:59,679 --> 00:21:03,440
eventually get the latest value as long

00:21:01,679 --> 00:21:04,720
as that value doesn't have any you know

00:21:03,440 --> 00:21:07,120
new updates

00:21:04,720 --> 00:21:08,240
in software where you typically want to

00:21:07,120 --> 00:21:10,159
know the value

00:21:08,240 --> 00:21:12,080
as soon as possible this can be a bit

00:21:10,159 --> 00:21:14,320
frustrating but in real life this

00:21:12,080 --> 00:21:16,000
actually makes sense if something

00:21:14,320 --> 00:21:17,840
happens somewhere in the world

00:21:16,000 --> 00:21:19,600
you know which has happened far too many

00:21:17,840 --> 00:21:21,840
times in 2020 and even

00:21:19,600 --> 00:21:23,600
as recently as now we're in the united

00:21:21,840 --> 00:21:26,480
states you know we have the election

00:21:23,600 --> 00:21:27,760
um not everyone is going to know about

00:21:26,480 --> 00:21:30,000
it immediately

00:21:27,760 --> 00:21:31,679
so like you may have heard uh the

00:21:30,000 --> 00:21:34,240
election results weren't

00:21:31,679 --> 00:21:35,280
known by everyone exactly the moment

00:21:34,240 --> 00:21:38,400
that they were

00:21:35,280 --> 00:21:40,720
uh posted instead they trickled through

00:21:38,400 --> 00:21:42,799
twitter or facebook or just all of these

00:21:40,720 --> 00:21:44,000
other avenues and then people eventually

00:21:42,799 --> 00:21:46,640
checked their phones

00:21:44,000 --> 00:21:48,000
and they saw oh hey we have a new

00:21:46,640 --> 00:21:51,280
president

00:21:48,000 --> 00:21:54,000
but it's never immediate um

00:21:51,280 --> 00:21:55,679
so that that's just one example of that

00:21:54,000 --> 00:21:56,640
the key point is that it doesn't happen

00:21:55,679 --> 00:22:00,000
immediately

00:21:56,640 --> 00:22:01,520
and it happens due to communication so

00:22:00,000 --> 00:22:03,360
let's take a little bit of a nicer

00:22:01,520 --> 00:22:05,200
example um

00:22:03,360 --> 00:22:06,880
when you enter that cafe you want a

00:22:05,200 --> 00:22:08,320
coffee right

00:22:06,880 --> 00:22:10,799
and so you're probably thinking i would

00:22:08,320 --> 00:22:12,400
like a coffee the barista doesn't know

00:22:10,799 --> 00:22:12,799
that even though they could probably

00:22:12,400 --> 00:22:15,520
guess

00:22:12,799 --> 00:22:16,480
because they can't read your mind but

00:22:15,520 --> 00:22:18,320
they will eventually

00:22:16,480 --> 00:22:20,799
know that you want a coffee if they care

00:22:18,320 --> 00:22:22,799
to ask what would you like

00:22:20,799 --> 00:22:24,000
so the fact that you want coffee is part

00:22:22,799 --> 00:22:26,880
of your internal

00:22:24,000 --> 00:22:27,679
private state again no one can read your

00:22:26,880 --> 00:22:29,840
mind

00:22:27,679 --> 00:22:30,880
so you can choose to share that states

00:22:29,840 --> 00:22:33,760
by replying

00:22:30,880 --> 00:22:35,600
i would like a copy please and when you

00:22:33,760 --> 00:22:36,159
say that statements that statement

00:22:35,600 --> 00:22:39,200
itself

00:22:36,159 --> 00:22:40,000
is immutable you can't go back in time

00:22:39,200 --> 00:22:43,679
and change that

00:22:40,000 --> 00:22:44,720
statement so if you wanted a tea instead

00:22:43,679 --> 00:22:46,400
for instance

00:22:44,720 --> 00:22:48,159
you would have to say afterwards

00:22:46,400 --> 00:22:49,679
actually i want some tea

00:22:48,159 --> 00:22:52,480
but that doesn't change the fact that

00:22:49,679 --> 00:22:55,280
first you wanted coffee

00:22:52,480 --> 00:22:57,520
and of course asking for coffee isn't a

00:22:55,280 --> 00:22:59,440
guarantee that you will get coffee

00:22:57,520 --> 00:23:00,880
just like making an api request isn't

00:22:59,440 --> 00:23:03,039
any guarantee that you'll actually get a

00:23:00,880 --> 00:23:05,440
response you know you might get a

00:23:03,039 --> 00:23:06,240
timeout or a server error or something

00:23:05,440 --> 00:23:08,240
like that

00:23:06,240 --> 00:23:09,600
but if all goes well you'll eventually

00:23:08,240 --> 00:23:12,400
get your coffee

00:23:09,600 --> 00:23:13,360
and all of this is done via message

00:23:12,400 --> 00:23:15,840
passing

00:23:13,360 --> 00:23:17,120
and we could consider each individual in

00:23:15,840 --> 00:23:19,360
this scenario

00:23:17,120 --> 00:23:20,720
to be an actor both the person ordering

00:23:19,360 --> 00:23:21,919
the coffee and the person making the

00:23:20,720 --> 00:23:23,600
coffee

00:23:21,919 --> 00:23:25,919
and both of them are communicating with

00:23:23,600 --> 00:23:28,159
each other to achieve a certain outcome

00:23:25,919 --> 00:23:30,159
so this is how things work in real life

00:23:28,159 --> 00:23:30,880
and this is how things work in the actor

00:23:30,159 --> 00:23:34,000
model

00:23:30,880 --> 00:23:37,520
as well all right so

00:23:34,000 --> 00:23:40,080
what is an actor in um

00:23:37,520 --> 00:23:41,679
in short an actor is an abstraction that

00:23:40,080 --> 00:23:44,080
pretty much describes

00:23:41,679 --> 00:23:45,919
everything an actor can be thought of as

00:23:44,080 --> 00:23:48,720
any entity that could send

00:23:45,919 --> 00:23:49,440
and or receive messages they react

00:23:48,720 --> 00:23:51,600
messages

00:23:49,440 --> 00:23:53,360
meaning that when they get a message and

00:23:51,600 --> 00:23:55,679
only when they get a message

00:23:53,360 --> 00:23:57,200
they can do something and we'll talk

00:23:55,679 --> 00:24:00,080
about what they could do

00:23:57,200 --> 00:24:00,400
uh pretty soon in terms of programming

00:24:00,080 --> 00:24:03,600
an

00:24:00,400 --> 00:24:06,000
actor can send a message from

00:24:03,600 --> 00:24:07,120
one actor to another actor that it has

00:24:06,000 --> 00:24:09,360
reference to

00:24:07,120 --> 00:24:11,360
so sending a message can be thought of

00:24:09,360 --> 00:24:13,440
simply as a function call

00:24:11,360 --> 00:24:15,039
so just like you talk to people that you

00:24:13,440 --> 00:24:17,360
um that you know

00:24:15,039 --> 00:24:20,240
or that you're in contact with actors

00:24:17,360 --> 00:24:22,320
can only talk to other known actors

00:24:20,240 --> 00:24:24,000
but just like with emails or phone calls

00:24:22,320 --> 00:24:26,320
you can include a reference to yourself

00:24:24,000 --> 00:24:26,880
so that the recipient actor can reply to

00:24:26,320 --> 00:24:28,880
you

00:24:26,880 --> 00:24:30,480
obviously you can't email someone you

00:24:28,880 --> 00:24:32,559
know if you don't know their email

00:24:30,480 --> 00:24:35,919
address and they can't reply to you

00:24:32,559 --> 00:24:38,320
if they don't know yours so um

00:24:35,919 --> 00:24:39,120
when an actor receives a message it can

00:24:38,320 --> 00:24:42,240
decide

00:24:39,120 --> 00:24:42,960
what to do with that message for example

00:24:42,240 --> 00:24:46,240
it could just

00:24:42,960 --> 00:24:49,440
send a message right back or it could do

00:24:46,240 --> 00:24:52,400
a number of other things too

00:24:49,440 --> 00:24:53,200
and so this actor model is actually

00:24:52,400 --> 00:24:54,799
nothing new

00:24:53,200 --> 00:24:56,240
in fact the actor model is even older

00:24:54,799 --> 00:24:58,240
than state charts which

00:24:56,240 --> 00:25:00,159
i talked about last time at reactive

00:24:58,240 --> 00:25:01,919
conf and i i've been talking about state

00:25:00,159 --> 00:25:05,039
machines and state charts for a while

00:25:01,919 --> 00:25:08,799
and um yeah the actor model is even

00:25:05,039 --> 00:25:10,960
older it was first formulated in 1973

00:25:08,799 --> 00:25:11,919
by carl hewitt peter bishop and richard

00:25:10,960 --> 00:25:14,000
steiger

00:25:11,919 --> 00:25:16,159
in a paper titled the universe a

00:25:14,000 --> 00:25:17,840
universal modular after formalism for

00:25:16,159 --> 00:25:19,520
artificial intelligence

00:25:17,840 --> 00:25:22,559
so yeah we went from one artificial

00:25:19,520 --> 00:25:24,640
intelligence talk to another technically

00:25:22,559 --> 00:25:26,960
uh it was influenced by the small talk

00:25:24,640 --> 00:25:29,039
uh language created by allen key

00:25:26,960 --> 00:25:30,799
who um some of you may recognize allen

00:25:29,039 --> 00:25:33,039
key as the person who coined the term

00:25:30,799 --> 00:25:36,000
object-oriented programming

00:25:33,039 --> 00:25:38,320
or oop but what's interesting is that

00:25:36,000 --> 00:25:40,480
allen key envisioned oop

00:25:38,320 --> 00:25:42,960
which is commonly viewed as everything

00:25:40,480 --> 00:25:44,159
is an object with more of a message

00:25:42,960 --> 00:25:46,159
passing approach and

00:25:44,159 --> 00:25:48,000
that was something that his uh small

00:25:46,159 --> 00:25:50,320
talk language emphasized

00:25:48,000 --> 00:25:51,840
alky says himself that the original

00:25:50,320 --> 00:25:53,840
vision of oop

00:25:51,840 --> 00:25:55,279
was basically the same thing as the

00:25:53,840 --> 00:25:57,200
actor model

00:25:55,279 --> 00:25:58,400
now there's a few programming languages

00:25:57,200 --> 00:26:01,360
which embrace this

00:25:58,400 --> 00:26:02,880
actor model erling which was created by

00:26:01,360 --> 00:26:05,679
joe armstrong who

00:26:02,880 --> 00:26:07,360
passed away i think about a year ago is

00:26:05,679 --> 00:26:09,600
probably the most well known and it's

00:26:07,360 --> 00:26:11,760
heavily used in telecommunications

00:26:09,600 --> 00:26:13,679
which is where the actor model shines

00:26:11,760 --> 00:26:15,840
which you know in a distributed

00:26:13,679 --> 00:26:17,679
computing environment where you have

00:26:15,840 --> 00:26:19,679
thousands and thousands of computers all

00:26:17,679 --> 00:26:21,600
over the place talking to each other

00:26:19,679 --> 00:26:23,200
elixir is built on the erlang virtual

00:26:21,600 --> 00:26:24,960
machine and it's basically ruby for

00:26:23,200 --> 00:26:27,440
erling i really recommend you

00:26:24,960 --> 00:26:28,799
check out elixir it's a it's a very nice

00:26:27,440 --> 00:26:31,760
language

00:26:28,799 --> 00:26:33,200
akka is probably the most popular actor

00:26:31,760 --> 00:26:36,799
model implementation

00:26:33,200 --> 00:26:39,039
it's built on scala and java

00:26:36,799 --> 00:26:40,159
and there's even an akka.js and then

00:26:39,039 --> 00:26:42,240
akka.net

00:26:40,159 --> 00:26:44,559
and pony is another lesser-known

00:26:42,240 --> 00:26:45,120
object-oriented actor model language but

00:26:44,559 --> 00:26:46,799
it just

00:26:45,120 --> 00:26:49,360
goes to show that you could create

00:26:46,799 --> 00:26:53,039
entire languages that are based on this

00:26:49,360 --> 00:26:55,279
idea of an actor model all right so

00:26:53,039 --> 00:26:57,039
actors have a few basic rules and these

00:26:55,279 --> 00:27:00,960
rules are rules that have remained

00:26:57,039 --> 00:27:04,159
unchanged for the last 50 years or so

00:27:00,960 --> 00:27:04,720
um just like we have you know rules in

00:27:04,159 --> 00:27:07,200
whatever

00:27:04,720 --> 00:27:10,400
framework or programming language we use

00:27:07,200 --> 00:27:12,480
that render purity and immutability and

00:27:10,400 --> 00:27:14,480
all of that sort of stuff these rules

00:27:12,480 --> 00:27:14,880
are what make the actor model work so

00:27:14,480 --> 00:27:17,440
well

00:27:14,880 --> 00:27:19,840
in distributed and concurrent systems so

00:27:17,440 --> 00:27:22,720
the first rule is about locality

00:27:19,840 --> 00:27:23,279
which is all computation is performed

00:27:22,720 --> 00:27:26,159
within an

00:27:23,279 --> 00:27:27,200
actor only as for the title of this

00:27:26,159 --> 00:27:29,600
presentation

00:27:27,200 --> 00:27:32,080
everything is an actor because the actor

00:27:29,600 --> 00:27:33,840
is the fundamental unit of computation

00:27:32,080 --> 00:27:35,760
in fact you can model pretty much

00:27:33,840 --> 00:27:37,440
everything in programming as actors

00:27:35,760 --> 00:27:39,919
even individual values but we're not

00:27:37,440 --> 00:27:42,960
going to get that granular because that

00:27:39,919 --> 00:27:45,360
quickly becomes uh you know unpragmatic

00:27:42,960 --> 00:27:46,320
so since all computation is performed

00:27:45,360 --> 00:27:48,880
within an actor

00:27:46,320 --> 00:27:50,000
it can also contain its own behavior and

00:27:48,880 --> 00:27:52,080
state

00:27:50,000 --> 00:27:53,600
which can sort of be thought about as

00:27:52,080 --> 00:27:54,480
the same thing and we're going to talk

00:27:53,600 --> 00:27:57,600
about that

00:27:54,480 --> 00:28:00,159
a little bit later so

00:27:57,600 --> 00:28:01,360
then how can an actor read another

00:28:00,159 --> 00:28:02,799
actor's state

00:28:01,360 --> 00:28:04,799
and so that's where the second rule

00:28:02,799 --> 00:28:06,880
comes in actors can

00:28:04,799 --> 00:28:08,320
only communicate through messages

00:28:06,880 --> 00:28:11,120
nothing else

00:28:08,320 --> 00:28:11,919
and messages like we talked about are

00:28:11,120 --> 00:28:14,399
immutable

00:28:11,919 --> 00:28:15,279
which provides a guarantee of no shared

00:28:14,399 --> 00:28:18,799
states

00:28:15,279 --> 00:28:21,200
between actors so if one actor wants to

00:28:18,799 --> 00:28:23,120
read another actor states it needs to

00:28:21,200 --> 00:28:25,039
ask it via a message

00:28:23,120 --> 00:28:27,440
the receiving actor can then choose

00:28:25,039 --> 00:28:30,000
whether to send back a message

00:28:27,440 --> 00:28:31,840
which might contain the desired state or

00:28:30,000 --> 00:28:32,640
send something else or just not send

00:28:31,840 --> 00:28:35,360
something

00:28:32,640 --> 00:28:37,039
at all if you think about actors the

00:28:35,360 --> 00:28:39,679
same way as communicating between the

00:28:37,039 --> 00:28:42,159
client and server via http

00:28:39,679 --> 00:28:44,159
that's basically the same idea like you

00:28:42,159 --> 00:28:46,159
can't directly read a database

00:28:44,159 --> 00:28:48,559
you have to ask a server hey i want to

00:28:46,159 --> 00:28:50,880
know this information from the database

00:28:48,559 --> 00:28:54,480
and the server can decide whether it

00:28:50,880 --> 00:28:54,480
should grab that information or not

00:28:54,559 --> 00:28:59,039
now actors are reactive in that they

00:28:57,200 --> 00:29:00,720
react to incoming messages

00:28:59,039 --> 00:29:03,120
and there are three things that an actor

00:29:00,720 --> 00:29:04,559
can do when it receives a message

00:29:03,120 --> 00:29:07,360
so the first thing that it could do is

00:29:04,559 --> 00:29:09,520
it could change state or its behavior

00:29:07,360 --> 00:29:11,360
and so remember that actors have local

00:29:09,520 --> 00:29:13,840
isolated states which includes

00:29:11,360 --> 00:29:15,840
all the data and logic that determines

00:29:13,840 --> 00:29:18,559
what the actor should do

00:29:15,840 --> 00:29:20,320
in response to a message for example if

00:29:18,559 --> 00:29:22,720
you send an increment message to an

00:29:20,320 --> 00:29:24,720
actor it can change its internal states

00:29:22,720 --> 00:29:26,720
to its currents counts plus one

00:29:24,720 --> 00:29:28,159
it can also determine that the counter

00:29:26,720 --> 00:29:30,320
has reached its max

00:29:28,159 --> 00:29:32,240
and changed its behavior so that nothing

00:29:30,320 --> 00:29:32,880
happens if another increment message

00:29:32,240 --> 00:29:36,080
comes

00:29:32,880 --> 00:29:40,559
otherwise it would go above the max

00:29:36,080 --> 00:29:43,440
um so actors can also send messages

00:29:40,559 --> 00:29:45,760
to other actors that it knows about and

00:29:43,440 --> 00:29:47,360
so this makes sense in real life too

00:29:45,760 --> 00:29:49,600
just like we talked about you can only

00:29:47,360 --> 00:29:51,200
talk to people that you have contact

00:29:49,600 --> 00:29:54,080
with either their phone number

00:29:51,200 --> 00:29:55,600
twitter handle or email address you know

00:29:54,080 --> 00:29:58,159
something like that

00:29:55,600 --> 00:29:59,679
um but just like with you know twitter

00:29:58,159 --> 00:30:01,360
handles or email addresses

00:29:59,679 --> 00:30:03,520
you could also send a reference of

00:30:01,360 --> 00:30:05,360
another actor to some actor

00:30:03,520 --> 00:30:07,279
so that the actor you send the message

00:30:05,360 --> 00:30:10,000
to can communicate with that actor

00:30:07,279 --> 00:30:10,720
so again you could basically basically

00:30:10,000 --> 00:30:14,640
think of this

00:30:10,720 --> 00:30:16,240
in real life terms um an actor can also

00:30:14,640 --> 00:30:18,399
create or spawn a

00:30:16,240 --> 00:30:19,760
finite number of child actors and these

00:30:18,399 --> 00:30:21,679
child actors are just like

00:30:19,760 --> 00:30:24,080
every other actor they follow the exact

00:30:21,679 --> 00:30:25,600
same rules they have their own isolated

00:30:24,080 --> 00:30:27,760
states and behavior

00:30:25,600 --> 00:30:29,039
they're their own breathing living

00:30:27,760 --> 00:30:31,360
things

00:30:29,039 --> 00:30:32,799
and remember an actor can only know of

00:30:31,360 --> 00:30:35,200
some external states

00:30:32,799 --> 00:30:36,000
if it receives it via message or if it's

00:30:35,200 --> 00:30:38,399
born with it

00:30:36,000 --> 00:30:39,200
you know that is like if the parents can

00:30:38,399 --> 00:30:41,360
create a child

00:30:39,200 --> 00:30:42,640
actor that already has some relevant

00:30:41,360 --> 00:30:44,080
data from its inception

00:30:42,640 --> 00:30:45,919
you know just sort of like real life you

00:30:44,080 --> 00:30:47,840
could think of dna as

00:30:45,919 --> 00:30:50,720
this you know sort of born with its sort

00:30:47,840 --> 00:30:52,640
of uh state

00:30:50,720 --> 00:30:54,559
so even though actors all follow the

00:30:52,640 --> 00:30:55,279
same rules they can behave a little bit

00:30:54,559 --> 00:30:57,039
differently

00:30:55,279 --> 00:30:58,399
in reaction to a message that they

00:30:57,039 --> 00:31:00,159
receive and

00:30:58,399 --> 00:31:02,399
this is what's called an actor's

00:31:00,159 --> 00:31:02,960
behavior it's what determines what

00:31:02,399 --> 00:31:06,320
happens

00:31:02,960 --> 00:31:07,519
immediately due to a message being

00:31:06,320 --> 00:31:09,679
received

00:31:07,519 --> 00:31:11,440
a a finite state machine is actually a

00:31:09,679 --> 00:31:12,880
great way of describing the internal

00:31:11,440 --> 00:31:14,799
behavior of an actor

00:31:12,880 --> 00:31:16,960
because it's an events driven approach

00:31:14,799 --> 00:31:19,519
to modeling the logic

00:31:16,960 --> 00:31:21,279
and by the way i use message and events

00:31:19,519 --> 00:31:21,919
interchangeably so you could consider

00:31:21,279 --> 00:31:24,960
them

00:31:21,919 --> 00:31:26,960
exactly the same thing for now

00:31:24,960 --> 00:31:29,360
with the state machine the finite state

00:31:26,960 --> 00:31:31,039
represents the qualitative state

00:31:29,360 --> 00:31:32,720
and in different finite states events

00:31:31,039 --> 00:31:34,559
can do different things like transition

00:31:32,720 --> 00:31:36,240
to another finite state

00:31:34,559 --> 00:31:37,760
state machines can also have extended

00:31:36,240 --> 00:31:39,440
state which represents the

00:31:37,760 --> 00:31:41,840
quantitative data associated with the

00:31:39,440 --> 00:31:42,559
machine and both of these combined are

00:31:41,840 --> 00:31:45,200
what makes

00:31:42,559 --> 00:31:46,000
an actor's overall state which is why an

00:31:45,200 --> 00:31:48,799
actor's behavior

00:31:46,000 --> 00:31:50,640
can be expressed in its state if you're

00:31:48,799 --> 00:31:51,200
not using a state machine you might have

00:31:50,640 --> 00:31:54,159
things like

00:31:51,200 --> 00:31:54,960
is loading or is error or is success

00:31:54,159 --> 00:31:57,039
like all of those

00:31:54,960 --> 00:31:58,559
booleans floating around hopefully you

00:31:57,039 --> 00:31:59,440
have some logic that does the right

00:31:58,559 --> 00:32:02,720
thing depending on

00:31:59,440 --> 00:32:05,039
is loading is true or false and that's

00:32:02,720 --> 00:32:06,960
where the same idea around behavior

00:32:05,039 --> 00:32:08,799
behavior determines what should happen

00:32:06,960 --> 00:32:09,679
next given the current state and the

00:32:08,799 --> 00:32:12,240
event

00:32:09,679 --> 00:32:13,360
or or the message that was just received

00:32:12,240 --> 00:32:15,120
so

00:32:13,360 --> 00:32:16,480
if you're not using steam machine

00:32:15,120 --> 00:32:18,320
strictly

00:32:16,480 --> 00:32:20,640
you could still describe all that state

00:32:18,320 --> 00:32:22,640
as a behavior

00:32:20,640 --> 00:32:24,480
so whereas an actor's behavior

00:32:22,640 --> 00:32:26,080
represents its internal logic

00:32:24,480 --> 00:32:28,960
an actor system represents the

00:32:26,080 --> 00:32:32,320
connections between all of the actors

00:32:28,960 --> 00:32:34,240
an actor system always has a root actor

00:32:32,320 --> 00:32:36,960
which is known as the guardian actor in

00:32:34,240 --> 00:32:38,559
some implementations like akka

00:32:36,960 --> 00:32:40,320
every single actor from the brood actor

00:32:38,559 --> 00:32:43,360
has exactly one parent

00:32:40,320 --> 00:32:44,880
so an actor system forms a hierarchy or

00:32:43,360 --> 00:32:46,960
a tree structure

00:32:44,880 --> 00:32:48,000
and remember that any actor can spawn

00:32:46,960 --> 00:32:50,480
child actors

00:32:48,000 --> 00:32:52,480
and those child actors can then uh can

00:32:50,480 --> 00:32:53,360
themselves spawn child actors and on and

00:32:52,480 --> 00:32:56,159
on and so

00:32:53,360 --> 00:32:57,760
that's how it forms a tree each actor

00:32:56,159 --> 00:32:58,720
also has a unique address that

00:32:57,760 --> 00:33:00,799
identifies it

00:32:58,720 --> 00:33:02,880
so for simplicity and some actor model

00:33:00,799 --> 00:33:05,039
implementations this address represents

00:33:02,880 --> 00:33:08,159
the hierarchical path to the actor

00:33:05,039 --> 00:33:09,679
for example cafe miniature one is a

00:33:08,159 --> 00:33:12,880
child of cafe

00:33:09,679 --> 00:33:15,519
and so on and so forth um addresses

00:33:12,880 --> 00:33:16,799
can't be used to access the actor

00:33:15,519 --> 00:33:19,120
instance directly

00:33:16,799 --> 00:33:20,480
so just like if i give you my email

00:33:19,120 --> 00:33:22,960
address you can't

00:33:20,480 --> 00:33:24,399
access my email you can't see any of my

00:33:22,960 --> 00:33:26,640
emails or at least i really hope

00:33:24,399 --> 00:33:28,960
you can't uh you can only send me a

00:33:26,640 --> 00:33:31,279
message using my email address

00:33:28,960 --> 00:33:32,399
um and so that's that's the same idea

00:33:31,279 --> 00:33:35,760
where you have

00:33:32,399 --> 00:33:37,840
this local private state um actors can

00:33:35,760 --> 00:33:40,880
only send messages to other actors

00:33:37,840 --> 00:33:43,039
via their address and just like an email

00:33:40,880 --> 00:33:45,440
inbox those messages arrive in the

00:33:43,039 --> 00:33:46,799
actor's mailbox and so that's how an

00:33:45,440 --> 00:33:50,399
actor processes

00:33:46,799 --> 00:33:53,360
one message at a time

00:33:50,399 --> 00:33:53,919
so an actor needs a mailbox to guarantee

00:33:53,360 --> 00:33:56,960
that only

00:33:53,919 --> 00:33:57,760
one message is sent at a time and here's

00:33:56,960 --> 00:33:59,760
why

00:33:57,760 --> 00:34:01,440
when an actor receives a message it

00:33:59,760 --> 00:34:02,720
needs to process that message to

00:34:01,440 --> 00:34:04,880
determine what should happen

00:34:02,720 --> 00:34:06,159
next how the state will change what the

00:34:04,880 --> 00:34:08,079
next behavior is

00:34:06,159 --> 00:34:10,480
if it needs to spawn new actors or send

00:34:08,079 --> 00:34:12,879
messages to other actors

00:34:10,480 --> 00:34:14,480
and so on and so forth when it's done

00:34:12,879 --> 00:34:16,320
processing that message you can then

00:34:14,480 --> 00:34:18,960
process another message

00:34:16,320 --> 00:34:20,000
and return the next state but what

00:34:18,960 --> 00:34:22,960
happens if an

00:34:20,000 --> 00:34:24,240
actor is processing a message and it

00:34:22,960 --> 00:34:27,280
receives a message while

00:34:24,240 --> 00:34:30,560
processing the previous message

00:34:27,280 --> 00:34:32,000
so what will happen uh you know this

00:34:30,560 --> 00:34:33,520
could lead to race conditions or

00:34:32,000 --> 00:34:36,000
impossible states or worse you could

00:34:33,520 --> 00:34:39,200
actually make the actor crash

00:34:36,000 --> 00:34:40,159
so by using a mailbox we can hold all

00:34:39,200 --> 00:34:42,560
these messages

00:34:40,159 --> 00:34:44,639
in sort of a queue and the actor can

00:34:42,560 --> 00:34:48,000
then dq the messages

00:34:44,639 --> 00:34:50,320
one at a time the actor takes the dq

00:34:48,000 --> 00:34:52,159
message determines the next date

00:34:50,320 --> 00:34:55,679
performs any side effects

00:34:52,159 --> 00:34:58,320
and then only then does it dequeue

00:34:55,679 --> 00:34:59,520
the next message so even if a message

00:34:58,320 --> 00:35:01,280
arrives

00:34:59,520 --> 00:35:02,560
while the actor is processing the

00:35:01,280 --> 00:35:04,800
previous message

00:35:02,560 --> 00:35:07,680
the mailbox will hold on to the message

00:35:04,800 --> 00:35:09,359
until it's ready for processing

00:35:07,680 --> 00:35:10,960
and so this gives the illusion of an

00:35:09,359 --> 00:35:13,520
actor living in its own

00:35:10,960 --> 00:35:15,599
virtual thread by mitigating concurrency

00:35:13,520 --> 00:35:17,520
issues with the message timing

00:35:15,599 --> 00:35:19,200
the mailbox is typically a first and

00:35:17,520 --> 00:35:20,000
first out cue but that's not strict

00:35:19,200 --> 00:35:21,920
requirements

00:35:20,000 --> 00:35:23,440
it can be a priority queue or something

00:35:21,920 --> 00:35:25,119
else for instance

00:35:23,440 --> 00:35:27,280
and it's also interesting to note that

00:35:25,119 --> 00:35:30,320
mailboxes are themselves

00:35:27,280 --> 00:35:30,880
actors all right so remember an actor

00:35:30,320 --> 00:35:33,200
instance

00:35:30,880 --> 00:35:34,800
can't be accessed directly we can only

00:35:33,200 --> 00:35:36,640
communicate with an actor using an

00:35:34,800 --> 00:35:38,160
address or in other words some sort of

00:35:36,640 --> 00:35:40,240
reference to the actor

00:35:38,160 --> 00:35:42,320
and this is what gives actors uh what's

00:35:40,240 --> 00:35:44,400
called location transparency

00:35:42,320 --> 00:35:45,599
and allows the actor to act as sort of a

00:35:44,400 --> 00:35:47,920
black box

00:35:45,599 --> 00:35:48,960
because we don't need to care where the

00:35:47,920 --> 00:35:51,520
actor is

00:35:48,960 --> 00:35:52,960
we just need to access uh something that

00:35:51,520 --> 00:35:54,400
references that actor

00:35:52,960 --> 00:35:56,000
and the actor ref can take care of

00:35:54,400 --> 00:35:57,680
forwarding the message to the actual

00:35:56,000 --> 00:35:59,920
location of the actor

00:35:57,680 --> 00:36:02,160
and so it doesn't matter if the actor is

00:35:59,920 --> 00:36:05,440
in space or the actor is on

00:36:02,160 --> 00:36:07,359
another computer somewhere

00:36:05,440 --> 00:36:10,560
that's what location transparency is all

00:36:07,359 --> 00:36:12,640
about the actor ref remains the same

00:36:10,560 --> 00:36:14,079
this location transparency also enables

00:36:12,640 --> 00:36:16,560
another powerful feature

00:36:14,079 --> 00:36:18,240
which is called false tolerance so if

00:36:16,560 --> 00:36:20,160
this actor

00:36:18,240 --> 00:36:22,640
fails for whatever reason whether it's a

00:36:20,160 --> 00:36:24,400
shaky network or some other fatal error

00:36:22,640 --> 00:36:26,400
some actor model implementations can

00:36:24,400 --> 00:36:27,359
choose a strategy for reviving that

00:36:26,400 --> 00:36:30,240
actor

00:36:27,359 --> 00:36:31,440
or letting it fail gracefully one such

00:36:30,240 --> 00:36:33,760
strategy is to just

00:36:31,440 --> 00:36:35,680
basically restart the actor if it fails

00:36:33,760 --> 00:36:37,119
or replace the behavior with some other

00:36:35,680 --> 00:36:39,040
fallback behavior

00:36:37,119 --> 00:36:40,960
notice how the actor f still stays

00:36:39,040 --> 00:36:43,359
exactly the same so

00:36:40,960 --> 00:36:46,800
whoever we're sending messages to is

00:36:43,359 --> 00:36:49,760
none the wiser if an actor fails

00:36:46,800 --> 00:36:51,440
so like i said from the very first slide

00:36:49,760 --> 00:36:53,599
everything is an actor

00:36:51,440 --> 00:36:55,359
and hopefully now if you squint you'll

00:36:53,599 --> 00:36:57,200
begin to see how various parts of our

00:36:55,359 --> 00:36:57,599
code can really be modeled with this

00:36:57,200 --> 00:37:00,000
message

00:36:57,599 --> 00:37:02,320
passing paradigm i was working with the

00:37:00,000 --> 00:37:03,920
post message api and i realized that the

00:37:02,320 --> 00:37:05,520
way that windows communicate with each

00:37:03,920 --> 00:37:08,960
other whether it's an iframe

00:37:05,520 --> 00:37:10,720
pop-up or a dead tools panel is with

00:37:08,960 --> 00:37:12,240
message passing i mean it's even in the

00:37:10,720 --> 00:37:15,760
name post message

00:37:12,240 --> 00:37:16,400
um so in this example we spawn a window

00:37:15,760 --> 00:37:19,440
actor

00:37:16,400 --> 00:37:21,359
by calling window.open then the parent

00:37:19,440 --> 00:37:22,079
window actor can send a message to the

00:37:21,359 --> 00:37:25,359
spawn

00:37:22,079 --> 00:37:28,560
child window by calling post message

00:37:25,359 --> 00:37:30,320
and then you could see that

00:37:28,560 --> 00:37:32,079
it could receive a message and then

00:37:30,320 --> 00:37:36,560
choose to do something

00:37:32,079 --> 00:37:37,680
with that message and uh i'm just gonna

00:37:36,560 --> 00:37:41,040
skip this slide

00:37:37,680 --> 00:37:44,160
so um in general an actor

00:37:41,040 --> 00:37:46,560
can send and receive any kind of events

00:37:44,160 --> 00:37:47,680
so how can we consider other constructs

00:37:46,560 --> 00:37:50,160
like promises

00:37:47,680 --> 00:37:52,880
and observables and things like that to

00:37:50,160 --> 00:37:52,880
the actors

00:37:52,960 --> 00:37:56,240
well a promise can be considered an

00:37:55,359 --> 00:37:58,560
actor

00:37:56,240 --> 00:38:00,800
that can only ever send back at most one

00:37:58,560 --> 00:38:02,880
message which is a resolved or

00:38:00,800 --> 00:38:04,720
rejected value and at first i didn't

00:38:02,880 --> 00:38:06,480
think that promises can receive anything

00:38:04,720 --> 00:38:07,920
but in the browser you can send in a

00:38:06,480 --> 00:38:10,480
board controller

00:38:07,920 --> 00:38:12,000
a board signal to uh to afford a promise

00:38:10,480 --> 00:38:13,599
and that's about the only thing that the

00:38:12,000 --> 00:38:15,359
promise can receive

00:38:13,599 --> 00:38:17,440
there's really no other type of

00:38:15,359 --> 00:38:20,400
communication with promises

00:38:17,440 --> 00:38:21,119
um observables are a little bit

00:38:20,400 --> 00:38:23,359
different

00:38:21,119 --> 00:38:24,160
they're sort of like promises but they

00:38:23,359 --> 00:38:27,599
could admit

00:38:24,160 --> 00:38:28,320
uh basically multiple values so whereas

00:38:27,599 --> 00:38:30,640
a promise could

00:38:28,320 --> 00:38:31,839
admit at most one value observables

00:38:30,640 --> 00:38:34,960
could

00:38:31,839 --> 00:38:35,599
emit potentially many values and also

00:38:34,960 --> 00:38:38,320
things like

00:38:35,599 --> 00:38:40,160
a completion signal or an error signal

00:38:38,320 --> 00:38:42,000
and so if it sends one of those signals

00:38:40,160 --> 00:38:44,720
the observable is terminated

00:38:42,000 --> 00:38:48,000
and it could send no more values in the

00:38:44,720 --> 00:38:50,480
tc39 observable stack it isn't specified

00:38:48,000 --> 00:38:53,200
that observables can receive any events

00:38:50,480 --> 00:38:55,599
so essentially observables are one-way

00:38:53,200 --> 00:38:57,599
streams of data

00:38:55,599 --> 00:39:00,160
rxjs though has this thing called

00:38:57,599 --> 00:39:03,280
subjects and subjects can also receive

00:39:00,160 --> 00:39:06,000
values and it can emit those values too

00:39:03,280 --> 00:39:07,760
so internally an observable has a source

00:39:06,000 --> 00:39:09,680
where it generates values

00:39:07,760 --> 00:39:11,440
so that that source can also act as

00:39:09,680 --> 00:39:13,920
something that can receive values if you

00:39:11,440 --> 00:39:15,680
look at it that way

00:39:13,920 --> 00:39:17,200
like i mentioned at the beginning i

00:39:15,680 --> 00:39:19,440
created x dates

00:39:17,200 --> 00:39:21,200
and xdate is a steam machine in the

00:39:19,440 --> 00:39:22,400
state charts library but it's also a

00:39:21,200 --> 00:39:25,440
library that embraces

00:39:22,400 --> 00:39:26,000
the actor model and uses that to sort of

00:39:25,440 --> 00:39:29,200
create

00:39:26,000 --> 00:39:31,280
a simple framework for

00:39:29,200 --> 00:39:32,480
creating actors that have behavior

00:39:31,280 --> 00:39:35,760
that's defined

00:39:32,480 --> 00:39:39,119
by each of these machines and so

00:39:35,760 --> 00:39:40,560
when you interpret an xt machine such as

00:39:39,119 --> 00:39:42,000
you know with the service equals

00:39:40,560 --> 00:39:43,839
interpreting machine

00:39:42,000 --> 00:39:45,520
essentially you're creating an actor

00:39:43,839 --> 00:39:46,640
you're creating this entity that you

00:39:45,520 --> 00:39:49,680
could send

00:39:46,640 --> 00:39:52,400
um all sorts of events to and

00:39:49,680 --> 00:39:54,400
this machine or the service can also

00:39:52,400 --> 00:39:56,000
spawn actors as well

00:39:54,400 --> 00:39:57,520
and so we're going to see that pretty

00:39:56,000 --> 00:40:00,480
soon

00:39:57,520 --> 00:40:01,680
um the this general idea of everything

00:40:00,480 --> 00:40:05,599
is an actor is

00:40:01,680 --> 00:40:08,880
basically true for x-state um

00:40:05,599 --> 00:40:10,640
so exe can also invoke and spawn child

00:40:08,880 --> 00:40:12,640
actors

00:40:10,640 --> 00:40:14,240
invoking an actor is done by using the

00:40:12,640 --> 00:40:16,000
invoke property

00:40:14,240 --> 00:40:17,839
where the behavior of the actor is

00:40:16,000 --> 00:40:19,760
specified in the source

00:40:17,839 --> 00:40:21,599
and in this case we're invoking a new

00:40:19,760 --> 00:40:23,040
actor with the behavior defined in

00:40:21,599 --> 00:40:25,359
espresso machine

00:40:23,040 --> 00:40:27,119
and when this actor is done we

00:40:25,359 --> 00:40:28,160
transition to the delivering coffee

00:40:27,119 --> 00:40:30,880
states

00:40:28,160 --> 00:40:31,440
um by the way invoking and spawning are

00:40:30,880 --> 00:40:33,359
pretty much

00:40:31,440 --> 00:40:35,359
the same thing the only difference is

00:40:33,359 --> 00:40:37,119
that an invoked actor lives only for as

00:40:35,359 --> 00:40:38,480
long as the machine is in the states

00:40:37,119 --> 00:40:41,040
where the actor is defined

00:40:38,480 --> 00:40:42,319
and so you manually have to stop spawned

00:40:41,040 --> 00:40:44,640
actors whereas

00:40:42,319 --> 00:40:46,960
you know it's controlled for you in

00:40:44,640 --> 00:40:49,920
invoke

00:40:46,960 --> 00:40:51,359
there's also no special way that x8

00:40:49,920 --> 00:40:53,520
knows whether an actor is

00:40:51,359 --> 00:40:55,200
done or not and so that's why the

00:40:53,520 --> 00:40:56,560
invoked actor sends a special done

00:40:55,200 --> 00:40:59,440
message

00:40:56,560 --> 00:41:01,200
back to the cafe machine so when we

00:40:59,440 --> 00:41:03,040
invoke the espresso machine

00:41:01,200 --> 00:41:04,640
we're creating a new actor with the

00:41:03,040 --> 00:41:07,119
espresso machine behavior

00:41:04,640 --> 00:41:09,160
and that actor should eventually send

00:41:07,119 --> 00:41:11,520
some special

00:41:09,160 --> 00:41:12,480
done.invoked.espresso events back to the

00:41:11,520 --> 00:41:14,079
parent

00:41:12,480 --> 00:41:15,680
and if you're wondering why it looks

00:41:14,079 --> 00:41:18,079
like that done invoked

00:41:15,680 --> 00:41:20,000
espresso that's actually defined in

00:41:18,079 --> 00:41:23,520
scxml which is the w3

00:41:20,000 --> 00:41:27,119
spec that x8 uses in order to define

00:41:23,520 --> 00:41:29,200
the protocol for message passing now

00:41:27,119 --> 00:41:30,720
because the cafe machine has a reference

00:41:29,200 --> 00:41:34,079
to the invoked actor

00:41:30,720 --> 00:41:36,000
via the id it can send events to it

00:41:34,079 --> 00:41:37,119
for example if the cafe machine gets a

00:41:36,000 --> 00:41:40,240
change order

00:41:37,119 --> 00:41:43,280
event then it could send that event

00:41:40,240 --> 00:41:47,119
directly to the invoked espresso actor

00:41:43,280 --> 00:41:49,280
and you know reference it by id

00:41:47,119 --> 00:41:50,720
so if this seems a little bit verbose

00:41:49,280 --> 00:41:53,440
there's a helper function called

00:41:50,720 --> 00:41:55,280
forward two that essentially does this

00:41:53,440 --> 00:41:59,119
you could just call forward to

00:41:55,280 --> 00:42:01,119
espresso and uh it does the same thing

00:41:59,119 --> 00:42:02,240
in the evoked espresso machine the actor

00:42:01,119 --> 00:42:04,319
already has

00:42:02,240 --> 00:42:05,680
a reference to its parents so we can

00:42:04,319 --> 00:42:08,319
send the parent cafe machine

00:42:05,680 --> 00:42:09,839
and then such as a machine broken event

00:42:08,319 --> 00:42:12,160
if the machine breaks

00:42:09,839 --> 00:42:14,000
then the parent can decide uh that event

00:42:12,160 --> 00:42:17,440
and decide what to do

00:42:14,000 --> 00:42:19,440
with it next and sometimes we need to

00:42:17,440 --> 00:42:21,040
spawn actors dynamically such as

00:42:19,440 --> 00:42:23,359
whenever an order comes in

00:42:21,040 --> 00:42:25,200
instead of being constrained to a state

00:42:23,359 --> 00:42:28,079
and so that's what spawn

00:42:25,200 --> 00:42:28,880
is for uh for instance whenever an order

00:42:28,079 --> 00:42:31,599
is placed

00:42:28,880 --> 00:42:33,040
we can spawn order actors which each

00:42:31,599 --> 00:42:34,319
have their own special behavior for

00:42:33,040 --> 00:42:36,640
handling orders

00:42:34,319 --> 00:42:38,400
these actors are fundamental units so

00:42:36,640 --> 00:42:39,839
they can be treated as values in a

00:42:38,400 --> 00:42:41,760
scientific context

00:42:39,839 --> 00:42:44,400
and passed around just like any other

00:42:41,760 --> 00:42:46,880
data note the second argument to spawn

00:42:44,400 --> 00:42:50,560
which is a unique identifier

00:42:46,880 --> 00:42:52,880
for that actor this event.order id

00:42:50,560 --> 00:42:55,040
that's how the parent machine can

00:42:52,880 --> 00:42:55,599
recognize and send messages to spawn

00:42:55,040 --> 00:42:58,079
actors

00:42:55,599 --> 00:42:59,040
later in case you wanted to manually do

00:42:58,079 --> 00:43:00,800
that

00:42:59,040 --> 00:43:02,079
all right so for for example if we need

00:43:00,800 --> 00:43:04,400
to cancel an order

00:43:02,079 --> 00:43:05,839
we can send a cancel event to that

00:43:04,400 --> 00:43:07,680
specific order

00:43:05,839 --> 00:43:09,440
and that will pick up the event and do

00:43:07,680 --> 00:43:12,560
whatever logic it needs to do

00:43:09,440 --> 00:43:13,920
to cancel that order the upcoming x8

00:43:12,560 --> 00:43:16,480
version 5 is taking

00:43:13,920 --> 00:43:18,880
everything as an actor to the next level

00:43:16,480 --> 00:43:21,680
by simplifying how it creates actors

00:43:18,880 --> 00:43:23,839
in version 4 retreated promises

00:43:21,680 --> 00:43:25,760
observables callbacks and

00:43:23,839 --> 00:43:27,599
other machines special by internally

00:43:25,760 --> 00:43:30,240
adapting them to be actors

00:43:27,599 --> 00:43:32,319
and this made general use cases easy but

00:43:30,240 --> 00:43:33,200
made all of their use cases a little bit

00:43:32,319 --> 00:43:35,920
harder

00:43:33,200 --> 00:43:37,599
in version 5 this will be explicit you

00:43:35,920 --> 00:43:38,839
will only be able to create and

00:43:37,599 --> 00:43:41,440
communicate with

00:43:38,839 --> 00:43:43,119
actors um helper functions will make it

00:43:41,440 --> 00:43:46,480
easy to invoke actors

00:43:43,119 --> 00:43:48,640
such as from promises or observables

00:43:46,480 --> 00:43:50,079
and also spawn them so we have this

00:43:48,640 --> 00:43:52,160
bond.from which

00:43:50,079 --> 00:43:55,839
is a lot more type safe than just having

00:43:52,160 --> 00:43:57,920
a you know spawn function

00:43:55,839 --> 00:43:59,520
this will enable xd to be truly

00:43:57,920 --> 00:44:01,119
universal because

00:43:59,520 --> 00:44:02,560
it essentially allows you to create

00:44:01,119 --> 00:44:05,599
actors out of

00:44:02,560 --> 00:44:07,920
virtually everything

00:44:05,599 --> 00:44:09,760
and so there's a lot of vector model

00:44:07,920 --> 00:44:11,680
implementations right now

00:44:09,760 --> 00:44:13,280
and one of them that i'm working on is

00:44:11,680 --> 00:44:15,440
called x actor

00:44:13,280 --> 00:44:17,440
which is a work in progress it's a new

00:44:15,440 --> 00:44:18,400
actor model implementation that works

00:44:17,440 --> 00:44:21,280
seamlessly with

00:44:18,400 --> 00:44:21,520
or without xstate in general i'm working

00:44:21,280 --> 00:44:24,560
on

00:44:21,520 --> 00:44:25,680
x8 version 5 and the core actor model

00:44:24,560 --> 00:44:28,480
part of that

00:44:25,680 --> 00:44:29,839
is known as x actor but in the future

00:44:28,480 --> 00:44:32,880
you're going to be able to use

00:44:29,839 --> 00:44:35,599
x after you know without x states

00:44:32,880 --> 00:44:36,000
and so the way x actor looks is actually

00:44:35,599 --> 00:44:39,760
a

00:44:36,000 --> 00:44:41,359
lot lot simpler than x states

00:44:39,760 --> 00:44:43,119
but of course you know x8 is going to

00:44:41,359 --> 00:44:44,960
use it internally

00:44:43,119 --> 00:44:47,599
so what you do is you have this creep

00:44:44,960 --> 00:44:49,760
behavior and you have a reducer

00:44:47,599 --> 00:44:52,480
so if you're used to redux this is going

00:44:49,760 --> 00:44:55,680
to look exactly the same

00:44:52,480 --> 00:44:58,400
and you also provide in initial states

00:44:55,680 --> 00:44:58,800
then you create a system and that system

00:44:58,400 --> 00:45:00,880
has

00:44:58,800 --> 00:45:02,640
that behavior so that counter behavior

00:45:00,880 --> 00:45:04,079
over here and then you could send

00:45:02,640 --> 00:45:07,280
messages to that system

00:45:04,079 --> 00:45:08,079
so um basically you could sort of think

00:45:07,280 --> 00:45:11,839
of it

00:45:08,079 --> 00:45:15,040
as a distributed redux in a way

00:45:11,839 --> 00:45:15,760
a more advanced example is here so we

00:45:15,040 --> 00:45:18,640
created to

00:45:15,760 --> 00:45:19,440
do um or in create to do we create a

00:45:18,640 --> 00:45:22,960
behavior

00:45:19,440 --> 00:45:26,000
that represents that's to do item

00:45:22,960 --> 00:45:26,880
and again this is just a reducer so our

00:45:26,000 --> 00:45:29,359
to do's

00:45:26,880 --> 00:45:31,680
this will be a reducer that manages all

00:45:29,359 --> 00:45:33,839
of those individual to do actors

00:45:31,680 --> 00:45:34,960
so if we wanted to create a new to do

00:45:33,839 --> 00:45:38,720
for instance

00:45:34,960 --> 00:45:41,520
uh we would call context.spawn

00:45:38,720 --> 00:45:42,240
and we would create that to do give it a

00:45:41,520 --> 00:45:45,119
name

00:45:42,240 --> 00:45:46,800
and then that is a to do actor that we

00:45:45,119 --> 00:45:48,960
could send messages to

00:45:46,800 --> 00:45:50,640
then we append it to state again this

00:45:48,960 --> 00:45:53,760
should look very familiar if

00:45:50,640 --> 00:45:54,720
you're used to redux or you know even x8

00:45:53,760 --> 00:45:57,760
or ng

00:45:54,720 --> 00:45:59,440
rx or any of those reducer based state

00:45:57,760 --> 00:46:01,359
management libraries

00:45:59,440 --> 00:46:03,599
and then we create a to-do system where

00:46:01,359 --> 00:46:04,720
our root actor or our guardian actor is

00:46:03,599 --> 00:46:07,200
the to do uh

00:46:04,720 --> 00:46:08,880
has a to do's behavior and we call it

00:46:07,200 --> 00:46:10,640
something probably not my counter that

00:46:08,880 --> 00:46:11,280
should be my to-do's or something like

00:46:10,640 --> 00:46:14,560
that

00:46:11,280 --> 00:46:17,599
and then we could um send that

00:46:14,560 --> 00:46:20,319
to system uh

00:46:17,599 --> 00:46:22,720
any message like to do create to do dot

00:46:20,319 --> 00:46:26,800
completes to do dot deletes

00:46:22,720 --> 00:46:27,200
etc so thank you reactive comp i hope

00:46:26,800 --> 00:46:29,839
that

00:46:27,200 --> 00:46:30,640
uh learning about the actor mall changed

00:46:29,839 --> 00:46:33,200
the way that you

00:46:30,640 --> 00:46:35,599
think about you know just handling

00:46:33,200 --> 00:46:37,280
asynchronicity and concurrency in your

00:46:35,599 --> 00:46:39,440
applications because

00:46:37,280 --> 00:46:41,119
uh there is a mathematical model that

00:46:39,440 --> 00:46:44,160
actually makes this a lot easier

00:46:41,119 --> 00:46:44,160
so thank you

00:46:46,800 --> 00:46:50,240
thank you david thank you very much i

00:46:49,440 --> 00:46:54,000
really love

00:46:50,240 --> 00:46:57,280
that when someone is taking the

00:46:54,000 --> 00:46:58,800
ideas that were presented i don't know

00:46:57,280 --> 00:47:02,240
40 50 years ago

00:46:58,800 --> 00:47:04,319
and they're creating them in the new new

00:47:02,240 --> 00:47:08,160
settings i think of the applications of

00:47:04,319 --> 00:47:10,560
2020 or 21st century so we're really

00:47:08,160 --> 00:47:11,359
really insightful i'm looking forward

00:47:10,560 --> 00:47:14,640
probably

00:47:11,359 --> 00:47:18,240
to a weekend oh and

00:47:14,640 --> 00:47:22,000
i will hopefully have time to try it out

00:47:18,240 --> 00:47:25,440
as well on some some playground

00:47:22,000 --> 00:47:28,480
myself so thank you very much

00:47:25,440 --> 00:47:30,480
uh let's see whether they are there are

00:47:28,480 --> 00:47:34,880
some questions

00:47:30,480 --> 00:47:34,880
the q a or in the chat

00:47:35,040 --> 00:47:40,319
uh okay so there is a question in chat

00:47:38,400 --> 00:47:42,480
would a program of any sufficient

00:47:40,319 --> 00:47:43,680
complexity usually be composed of

00:47:42,480 --> 00:47:46,720
multiple actors

00:47:43,680 --> 00:47:50,480
systems and would the guardian notes

00:47:46,720 --> 00:47:53,599
then maybe know about each other

00:47:50,480 --> 00:47:57,440
that is now each other's id slash

00:47:53,599 --> 00:48:00,720
name yeah that's a good question um

00:47:57,440 --> 00:48:03,359
so uh sufficient complexity so

00:48:00,720 --> 00:48:03,920
essentially an actor system is itself an

00:48:03,359 --> 00:48:06,160
actor

00:48:03,920 --> 00:48:07,520
just like you know we're an actor but we

00:48:06,160 --> 00:48:09,040
have different organs which

00:48:07,520 --> 00:48:11,200
each have their own you know mind of

00:48:09,040 --> 00:48:11,680
their own they each are responsible for

00:48:11,200 --> 00:48:13,040
doing

00:48:11,680 --> 00:48:15,359
each of their own things but we could

00:48:13,040 --> 00:48:18,160
consider the entire human body like

00:48:15,359 --> 00:48:19,359
its own actor system however we have to

00:48:18,160 --> 00:48:21,280
communicate with other

00:48:19,359 --> 00:48:22,880
uh humans which you know might have

00:48:21,280 --> 00:48:25,920
their own actor system

00:48:22,880 --> 00:48:27,680
and um yeah so basically um

00:48:25,920 --> 00:48:29,520
if you just define everything as this

00:48:27,680 --> 00:48:31,440
hierarchical structure of

00:48:29,520 --> 00:48:33,119
smaller actor systems that are talking

00:48:31,440 --> 00:48:34,079
to each other as part of this bigger

00:48:33,119 --> 00:48:37,040
actor system

00:48:34,079 --> 00:48:38,160
you still have the same uh actor system

00:48:37,040 --> 00:48:40,319
and so some of you might

00:48:38,160 --> 00:48:42,880
be thinking you know this actually

00:48:40,319 --> 00:48:45,599
really has parallels with microservices

00:48:42,880 --> 00:48:47,359
and essentially it's the same thing so

00:48:45,599 --> 00:48:51,119
uh the same architectural

00:48:47,359 --> 00:48:52,880
guidelines that apply to microservices

00:48:51,119 --> 00:48:55,440
and distributed systems are going to

00:48:52,880 --> 00:48:57,200
apply to you know using the actor model

00:48:55,440 --> 00:48:59,359
in the front end or backend or

00:48:57,200 --> 00:49:00,640
you know wherever you want to use it the

00:48:59,359 --> 00:49:02,800
second question was uh

00:49:00,640 --> 00:49:04,240
and would the guardian nodes you know

00:49:02,800 --> 00:49:06,559
maybe know about each other

00:49:04,240 --> 00:49:07,520
so yeah that's that's the thing about an

00:49:06,559 --> 00:49:09,359
actor system

00:49:07,520 --> 00:49:10,960
if you have two after systems that need

00:49:09,359 --> 00:49:12,800
to talk to each other essentially you

00:49:10,960 --> 00:49:15,599
have a bigger actor system

00:49:12,800 --> 00:49:16,000
that knows about those and can sort of

00:49:15,599 --> 00:49:18,160
mediate

00:49:16,000 --> 00:49:20,079
requests between those and you know

00:49:18,160 --> 00:49:23,119
message pass back and forth

00:49:20,079 --> 00:49:24,160
so essentially if you have two disparate

00:49:23,119 --> 00:49:25,440
systems

00:49:24,160 --> 00:49:27,680
they don't know about each other they

00:49:25,440 --> 00:49:29,520
can't talk to each other so

00:49:27,680 --> 00:49:31,839
in other words there's always a system

00:49:29,520 --> 00:49:31,839
somewhere

00:49:33,680 --> 00:49:40,319
thanks a lot for the answer from our q a

00:49:38,720 --> 00:49:42,400
do you see any benefits to the

00:49:40,319 --> 00:49:45,040
application of the actor model

00:49:42,400 --> 00:49:47,359
when building uis in an unrest

00:49:45,040 --> 00:49:50,400
distributed systems

00:49:47,359 --> 00:49:53,200
uh yeah i definitely do in fact

00:49:50,400 --> 00:49:54,400
um the title of this talk everything is

00:49:53,200 --> 00:49:56,960
an actor really

00:49:54,400 --> 00:49:57,520
uh is because when i was working on ui

00:49:56,960 --> 00:49:59,440
first i

00:49:57,520 --> 00:50:01,119
started seeing like individual behaviors

00:49:59,440 --> 00:50:02,400
as oh all of these are state machines or

00:50:01,119 --> 00:50:05,200
all of these are c charts

00:50:02,400 --> 00:50:06,160
and then realizing that uh for example

00:50:05,200 --> 00:50:08,720
if you're working in

00:50:06,160 --> 00:50:10,640
react or angular view each one of your

00:50:08,720 --> 00:50:13,040
components can be thought of

00:50:10,640 --> 00:50:15,680
as an actor and so the way that one

00:50:13,040 --> 00:50:18,640
actor communicates with another actor

00:50:15,680 --> 00:50:20,079
might be something like redux or even uh

00:50:18,640 --> 00:50:23,520
props passing

00:50:20,079 --> 00:50:25,040
so uh for example an on click handler or

00:50:23,520 --> 00:50:27,119
an on change handler

00:50:25,040 --> 00:50:29,280
that is message passing itself you have

00:50:27,119 --> 00:50:31,599
the child communicating to the parents

00:50:29,280 --> 00:50:32,800
something that just happened the child

00:50:31,599 --> 00:50:34,240
isn't going to tell the parent what to

00:50:32,800 --> 00:50:35,839
do instead

00:50:34,240 --> 00:50:38,000
it's going to communicate via those

00:50:35,839 --> 00:50:40,880
events and in general

00:50:38,000 --> 00:50:41,680
when designing and developing uis having

00:50:40,880 --> 00:50:44,720
an event

00:50:41,680 --> 00:50:46,640
passing architecture makes things

00:50:44,720 --> 00:50:48,480
so much simpler because now you think of

00:50:46,640 --> 00:50:51,040
everything in terms of events

00:50:48,480 --> 00:50:52,160
redux discovered this really early on

00:50:51,040 --> 00:50:55,119
you know with uh

00:50:52,160 --> 00:50:57,599
flux and all of that and uh you know

00:50:55,119 --> 00:50:59,040
it's been widely adopted so i would say

00:50:57,599 --> 00:51:01,040
that you know just this

00:50:59,040 --> 00:51:03,040
this idea of having events as a main

00:51:01,040 --> 00:51:05,359
communication mechanism

00:51:03,040 --> 00:51:06,480
really speaks volumes to you know the

00:51:05,359 --> 00:51:10,160
next step which is

00:51:06,480 --> 00:51:10,160
the actor model everywhere

00:51:11,520 --> 00:51:15,680
okay and the next question is about

00:51:13,680 --> 00:51:18,960
these some examples or what are the

00:51:15,680 --> 00:51:22,559
the most uh most common recommended ways

00:51:18,960 --> 00:51:26,480
the x-state is being used uh

00:51:22,559 --> 00:51:28,160
so oh x8 x8 is being used in

00:51:26,480 --> 00:51:30,480
lots of things i would say that the most

00:51:28,160 --> 00:51:32,640
common application is in ui

00:51:30,480 --> 00:51:33,680
just because that's where all the demos

00:51:32,640 --> 00:51:37,200
are in there's

00:51:33,680 --> 00:51:40,240
um plugins for reacts but also for

00:51:37,200 --> 00:51:40,880
vue for spelt uh ways to do it in

00:51:40,240 --> 00:51:42,000
angular

00:51:40,880 --> 00:51:43,920
there's actually a lot of frameworks

00:51:42,000 --> 00:51:46,079
that don't even really need a

00:51:43,920 --> 00:51:48,000
plug-in or an adapter for it you could

00:51:46,079 --> 00:51:50,880
just use it directly

00:51:48,000 --> 00:51:53,119
um but there have been other interesting

00:51:50,880 --> 00:51:55,520
places where x8 have been used as well

00:51:53,119 --> 00:51:56,559
including the back end uh a lot of

00:51:55,520 --> 00:51:58,800
people are using

00:51:56,559 --> 00:51:59,760
uh xdate as a way of managing state on

00:51:58,800 --> 00:52:01,760
the back end

00:51:59,760 --> 00:52:03,599
uh persisting the state to a database

00:52:01,760 --> 00:52:06,400
restoring it and then continuing

00:52:03,599 --> 00:52:07,359
and sort of using it in a workflow sort

00:52:06,400 --> 00:52:09,280
of sense um

00:52:07,359 --> 00:52:11,440
and then there's wilder applications too

00:52:09,280 --> 00:52:14,960
people using x date for

00:52:11,440 --> 00:52:18,079
uh blockchain of all things and

00:52:14,960 --> 00:52:21,119
things like that so but mostly ui

00:52:18,079 --> 00:52:24,400
a lot of back end as well

00:52:21,119 --> 00:52:26,800
uh here we go with the performance uh

00:52:24,400 --> 00:52:28,880
question uh as messing message

00:52:26,800 --> 00:52:31,200
processing happens one by one

00:52:28,880 --> 00:52:33,280
and as every message goes through the

00:52:31,200 --> 00:52:35,520
root actor

00:52:33,280 --> 00:52:37,440
then isn't the route to this actor a

00:52:35,520 --> 00:52:41,440
performance performance bottleneck

00:52:37,440 --> 00:52:41,839
or how can this scale so not necessarily

00:52:41,440 --> 00:52:44,880
uh

00:52:41,839 --> 00:52:47,520
the the root is just um you know

00:52:44,880 --> 00:52:48,800
it's just an actor itself and you have a

00:52:47,520 --> 00:52:50,480
tree of actors

00:52:48,800 --> 00:52:53,280
as well and you could always send

00:52:50,480 --> 00:52:54,800
messages directly to one of those actors

00:52:53,280 --> 00:52:56,480
remember those actors are like you know

00:52:54,800 --> 00:52:58,640
they have a mind of their own so

00:52:56,480 --> 00:53:00,000
if you think about it like a company you

00:52:58,640 --> 00:53:01,760
have the ceo

00:53:00,000 --> 00:53:03,119
at the top and then you have you know

00:53:01,760 --> 00:53:05,119
managers and then you have

00:53:03,119 --> 00:53:06,720
you who you work on your manager manager

00:53:05,119 --> 00:53:09,280
works under the ceo

00:53:06,720 --> 00:53:10,960
and everything that's told to you might

00:53:09,280 --> 00:53:12,079
be told to you directly from some

00:53:10,960 --> 00:53:14,000
external source

00:53:12,079 --> 00:53:16,000
it might be told you directly from a

00:53:14,000 --> 00:53:20,000
manager but it doesn't come from

00:53:16,000 --> 00:53:22,640
you know top down always so

00:53:20,000 --> 00:53:24,160
yeah but i mean he even reacts like the

00:53:22,640 --> 00:53:26,559
way that it handles events

00:53:24,160 --> 00:53:27,680
the components don't receive it directly

00:53:26,559 --> 00:53:29,760
what happens is

00:53:27,680 --> 00:53:31,119
react has its own internal engine in

00:53:29,760 --> 00:53:33,440
which it processes

00:53:31,119 --> 00:53:35,040
events and then delegates to components

00:53:33,440 --> 00:53:36,400
hey you handle this events you should

00:53:35,040 --> 00:53:40,640
handle that event

00:53:36,400 --> 00:53:43,200
uh so there is already that idea of

00:53:40,640 --> 00:53:43,760
you know events don't go directly to the

00:53:43,200 --> 00:53:47,599
actor

00:53:43,760 --> 00:53:50,319
right away um yeah

00:53:47,599 --> 00:53:51,200
yeah but that was a great analogy uh the

00:53:50,319 --> 00:53:54,400
last question from

00:53:51,200 --> 00:53:54,960
our our q a uh what about security did

00:53:54,400 --> 00:53:59,359
the

00:53:54,960 --> 00:53:59,359
vector-based languages provided

00:53:59,599 --> 00:54:03,839
that's an interesting question um i'm

00:54:02,559 --> 00:54:07,040
i'm sure they do

00:54:03,839 --> 00:54:08,079
in fact um actor mala provides a way

00:54:07,040 --> 00:54:09,520
where um

00:54:08,079 --> 00:54:11,520
since you're your only way of

00:54:09,520 --> 00:54:13,280
communicating is via events you're

00:54:11,520 --> 00:54:15,839
essentially only validating

00:54:13,280 --> 00:54:18,000
events you might have some sort of uh

00:54:15,839 --> 00:54:20,640
you know security mechanism that

00:54:18,000 --> 00:54:22,800
uh just authorizes and makes sure that

00:54:20,640 --> 00:54:24,000
uh you only send an event back if you're

00:54:22,800 --> 00:54:27,040
authorized to

00:54:24,000 --> 00:54:28,800
do so i'm actually looking back at

00:54:27,040 --> 00:54:32,319
security as well

00:54:28,800 --> 00:54:35,119
there's an entire section on it um

00:54:32,319 --> 00:54:36,640
actually it's extremely outdated but uh

00:54:35,119 --> 00:54:38,960
but yeah

00:54:36,640 --> 00:54:41,359
and in fact uh if you think about http

00:54:38,960 --> 00:54:44,319
and just uh servers in general

00:54:41,359 --> 00:54:45,280
um you you can't reach directly into a

00:54:44,319 --> 00:54:47,200
database

00:54:45,280 --> 00:54:48,960
i mean that's for you know just the way

00:54:47,200 --> 00:54:49,599
that message passing works but that's

00:54:48,960 --> 00:54:52,480
also

00:54:49,599 --> 00:54:53,839
uh a important security consideration

00:54:52,480 --> 00:54:56,319
and so that's why

00:54:53,839 --> 00:54:58,319
um you know you ask the server which

00:54:56,319 --> 00:55:00,079
again has its own internal localized

00:54:58,319 --> 00:55:01,200
state which is not visible to the

00:55:00,079 --> 00:55:04,720
outside world

00:55:01,200 --> 00:55:06,319
it it uses logic to decide um

00:55:04,720 --> 00:55:08,640
whether it should send back that

00:55:06,319 --> 00:55:10,960
sensitive data or whether it should say

00:55:08,640 --> 00:55:14,240
hey you're unauthorized to see this data

00:55:10,960 --> 00:55:16,319
and so you know that's why you're you're

00:55:14,240 --> 00:55:18,720
really limiting the scope of um

00:55:16,319 --> 00:55:21,599
attack vectors really because it's it's

00:55:18,720 --> 00:55:24,319
all just the same event passing

00:55:21,599 --> 00:55:25,200
yeah and as you as you also said in the

00:55:24,319 --> 00:55:27,680
beginning of this

00:55:25,200 --> 00:55:28,400
of this q a session uh when you imagine

00:55:27,680 --> 00:55:31,440
it as

00:55:28,400 --> 00:55:32,400
uh microservices for example or use that

00:55:31,440 --> 00:55:35,359
analogy

00:55:32,400 --> 00:55:37,200
so that works also pretty well or i can

00:55:35,359 --> 00:55:38,000
imagine some security layers and

00:55:37,200 --> 00:55:39,680
measures

00:55:38,000 --> 00:55:41,440
also yeah yeah like like you would have

00:55:39,680 --> 00:55:42,960
in the space

00:55:41,440 --> 00:55:44,799
yeah you would have an api gateway for

00:55:42,960 --> 00:55:47,839
instance and that api gateway could

00:55:44,799 --> 00:55:50,480
itself be followed as an actor

00:55:47,839 --> 00:55:51,119
absolutely correct uh there are many

00:55:50,480 --> 00:55:54,079
questions

00:55:51,119 --> 00:55:54,559
uh appearing so let's try one or two

00:55:54,079 --> 00:55:56,079
more

00:55:54,559 --> 00:55:58,000
and okay and we can move the discussion

00:55:56,079 --> 00:56:00,000
to slack so from dusan

00:55:58,000 --> 00:56:01,520
are there any exceptions to the

00:56:00,000 --> 00:56:03,280
synchronous nature of

00:56:01,520 --> 00:56:04,960
message processing could an actor

00:56:03,280 --> 00:56:08,319
delegate that asks to child

00:56:04,960 --> 00:56:11,839
actors to simulate multitasking uh

00:56:08,319 --> 00:56:13,920
yeah no it definitely can so um

00:56:11,839 --> 00:56:15,680
by by synchronous i'm guessing they mean

00:56:13,920 --> 00:56:16,000
that um you know when it receives the

00:56:15,680 --> 00:56:17,599
message

00:56:16,000 --> 00:56:19,200
it does something immediately after that

00:56:17,599 --> 00:56:19,920
message which is true that's what

00:56:19,200 --> 00:56:22,480
happens

00:56:19,920 --> 00:56:24,160
uh so to model asynchronicity you're

00:56:22,480 --> 00:56:25,040
basically you could delegate something

00:56:24,160 --> 00:56:27,680
to an actor

00:56:25,040 --> 00:56:28,640
be like hey please take care of this and

00:56:27,680 --> 00:56:31,040
when you're done

00:56:28,640 --> 00:56:31,920
get back to me and so that's via an

00:56:31,040 --> 00:56:35,040
event

00:56:31,920 --> 00:56:37,119
and so that's why um actors can be sort

00:56:35,040 --> 00:56:38,400
of thought of as async by defaults

00:56:37,119 --> 00:56:41,119
because

00:56:38,400 --> 00:56:41,520
it's always just waiting on an event

00:56:41,119 --> 00:56:44,640
which

00:56:41,520 --> 00:56:48,079
you know events take time

00:56:44,640 --> 00:56:51,280
yeah and uh okay

00:56:48,079 --> 00:56:54,000
really the last one how big

00:56:51,280 --> 00:56:55,760
in quotation marks actors should be or

00:56:54,000 --> 00:56:58,960
how many different objects

00:56:55,760 --> 00:57:00,640
objects should be actors i can imagine

00:56:58,960 --> 00:57:04,079
this could lead to a lot of different

00:57:00,640 --> 00:57:07,680
messages and a boilerplate code

00:57:04,079 --> 00:57:08,640
right so um my experimentation with x

00:57:07,680 --> 00:57:12,240
actor

00:57:08,640 --> 00:57:14,079
um actually found that i'm reducing

00:57:12,240 --> 00:57:15,920
so much code because you're essentially

00:57:14,079 --> 00:57:16,640
describing the behavior as a single

00:57:15,920 --> 00:57:18,079
function

00:57:16,640 --> 00:57:19,839
and that function could be whatever you

00:57:18,079 --> 00:57:22,640
want it's just a reducer so

00:57:19,839 --> 00:57:23,520
it's just function initial state uh

00:57:22,640 --> 00:57:26,079
that's it

00:57:23,520 --> 00:57:26,960
um traditionally in languages such as uh

00:57:26,079 --> 00:57:29,119
earthling

00:57:26,960 --> 00:57:30,319
an actor is described as something

00:57:29,119 --> 00:57:32,319
that's extremely

00:57:30,319 --> 00:57:33,760
lightweight and i mean that's

00:57:32,319 --> 00:57:35,359
essentially all it is you could think of

00:57:33,760 --> 00:57:36,480
it as an object where you could send

00:57:35,359 --> 00:57:39,280
events to

00:57:36,480 --> 00:57:40,799
and uh that's pretty much it you know of

00:57:39,280 --> 00:57:41,520
course that object could spawn other

00:57:40,799 --> 00:57:44,720
actors

00:57:41,520 --> 00:57:47,599
and um since then there's like

00:57:44,720 --> 00:57:48,960
the actor model and sort of the opposite

00:57:47,599 --> 00:57:50,319
not the opposite but just something

00:57:48,960 --> 00:57:50,720
different than the actor mall is like

00:57:50,319 --> 00:57:53,280
the

00:57:50,720 --> 00:57:54,000
basic threaded model of concurrency

00:57:53,280 --> 00:57:55,920
threats are not

00:57:54,000 --> 00:57:57,680
lightweight you know if you you know

00:57:55,920 --> 00:57:59,920
make a new thread for something that

00:57:57,680 --> 00:58:02,079
incurs a lot of latency and processing

00:57:59,920 --> 00:58:03,520
but actors can live on their own virtual

00:58:02,079 --> 00:58:05,839
threats so you could have

00:58:03,520 --> 00:58:07,920
you know hundreds of thousands of actors

00:58:05,839 --> 00:58:08,480
which might be on the same thread might

00:58:07,920 --> 00:58:10,559
not be

00:58:08,480 --> 00:58:12,319
it doesn't really matter uh the the

00:58:10,559 --> 00:58:15,440
point is that they are

00:58:12,319 --> 00:58:17,040
um they are lightweight and of course

00:58:15,440 --> 00:58:19,200
nothing is going to be faster than

00:58:17,040 --> 00:58:21,200
directly reaching into memory directly

00:58:19,200 --> 00:58:22,640
reading states or directly calling a

00:58:21,200 --> 00:58:25,760
method on another

00:58:22,640 --> 00:58:27,920
object but if you do that you get a lot

00:58:25,760 --> 00:58:28,640
uh you get rid of a lot of the security

00:58:27,920 --> 00:58:31,200
and benefits

00:58:28,640 --> 00:58:32,880
of uh using something like with the

00:58:31,200 --> 00:58:36,079
message passing paradigm

00:58:32,880 --> 00:58:38,160
like the actor model so uh tiny

00:58:36,079 --> 00:58:39,839
costs and i do mean tiny as far as

00:58:38,160 --> 00:58:42,480
weights it's negligible

00:58:39,839 --> 00:58:43,760
and um as far as event latency also

00:58:42,480 --> 00:58:46,160
negligible

00:58:43,760 --> 00:58:47,040
but what you get in return is you know a

00:58:46,160 --> 00:58:48,839
lot better for

00:58:47,040 --> 00:58:51,359
understanding the clarity of your

00:58:48,839 --> 00:58:54,319
application

00:58:51,359 --> 00:58:54,880
uh thanks a lot david thanks a lot for

00:58:54,319 --> 00:58:57,280
all the

00:58:54,880 --> 00:58:58,640
for all the answers and uh great

00:58:57,280 --> 00:59:02,480
presentation

00:58:58,640 --> 00:59:05,599
so let's wrap this up uh thank you all

00:59:02,480 --> 00:59:08,319
for participating uh i remind

00:59:05,599 --> 00:59:09,040
all of you our slack channel where you

00:59:08,319 --> 00:59:12,079
can

00:59:09,040 --> 00:59:13,359
connect and discuss with others maybe if

00:59:12,079 --> 00:59:17,119
you have another

00:59:13,359 --> 00:59:18,559
some other questions or or you

00:59:17,119 --> 00:59:20,720
there are there are something some

00:59:18,559 --> 00:59:24,720
topics which you would like to discuss

00:59:20,720 --> 00:59:28,000
uh feel free to do it there uh

00:59:24,720 --> 00:59:30,400
after this call ends uh

00:59:28,000 --> 00:59:31,440
there will be a feedback form in the

00:59:30,400 --> 00:59:34,400
slack channel

00:59:31,440 --> 00:59:35,359
so please if you have any suggestions or

00:59:34,400 --> 00:59:39,440
feedback to me

00:59:35,359 --> 00:59:42,480
or the organizers uh just write it there

00:59:39,440 --> 00:59:43,760
we will try to be better next time there

00:59:42,480 --> 00:59:46,640
is something which

00:59:43,760 --> 00:59:47,119
we can do to improve ourselves it will

00:59:46,640 --> 00:59:50,720
be

00:59:47,119 --> 00:59:51,280
highly appreciated uh and that's all

00:59:50,720 --> 00:59:55,040
from us

00:59:51,280 --> 00:59:58,319
uh today thanks all of the speakers

00:59:55,040 --> 01:00:00,319
thanks also you attendees for those

00:59:58,319 --> 01:00:03,680
great questions

01:00:00,319 --> 01:00:06,319
and being part of this community uh

01:00:03,680 --> 01:00:07,119
please join us also the next time uh

01:00:06,319 --> 01:00:10,240
follow our

01:00:07,119 --> 01:00:11,040
social media or our slack to know when

01:00:10,240 --> 01:00:15,200
the

01:00:11,040 --> 01:00:17,359
next meetup is going to happen and

01:00:15,200 --> 01:00:19,119
we are looking forward uh have a great

01:00:17,359 --> 01:00:21,359
rest of the evening here in europe

01:00:19,119 --> 01:00:22,640
or wherever in the world you are have a

01:00:21,359 --> 01:00:29,839
rest nice

01:00:22,640 --> 01:00:29,839
rest of the day and cheers bye

01:00:30,079 --> 01:00:32,160

YouTube URL: https://www.youtube.com/watch?v=dMgowALRqF4


