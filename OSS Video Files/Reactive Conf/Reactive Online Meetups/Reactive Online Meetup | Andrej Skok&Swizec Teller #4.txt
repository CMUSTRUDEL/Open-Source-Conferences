Title: Reactive Online Meetup | Andrej Skok&Swizec Teller #4
Publication date: 2020-05-29
Playlist: Reactive Online Meetups
Description: 
	NEXT REACTIVE ONLINE MEETUP âž¡ï¸JUNE 9TH, 7 PM CEST
TIM BENNIKS&CHEN HUI JING

JÍŸoÍŸiÍŸnÍŸ ÍŸtÍŸhÍŸeÍŸ ÍŸmÍŸeÍŸeÍŸtÍŸuÍŸpÍŸ ÍŸvÍŸiÍŸaÍŸ ÍŸSÍŸlÍŸaÍŸcÍŸkÍŸ ÍŸcÍŸhÍŸaÍŸnÍŸnÍŸeÍŸlÍŸ:ÍŸ
https://bit.ly/Reactive_slack_networking

--------------------

SPEAKERS
#metatalk - ANDREJ SKOK - Mind the perf
#devtalk - SWIZEC TELLER - Push your state to the edge


--------------------


ANDREJ SKOK
#metatalk

ð—§ð—”ð—Ÿð—ž
Mind the perf

ð—§ð—”ð—Ÿð—ž ð—”ð—•ð—¦ð—§ð—¥ð—”ð—–ð—§
Adding more and more new features almost always comes at a cost. Letâ€™s look at some ways how to keep heavy frontend in react performant even when the codebase is growing like crazy.
--------------------

SWIZEC TELLER 
#devtalk

ð—§ð—”ð—Ÿð—ž
Push your state to the edge

ð—§ð—”ð—Ÿð—ž ð—”ð—•ð—¦ð—§ð—¥ð—”ð—–ð—§
React revolutionized the way most of us think about the state. No more binding, no more mess, just a beautiful unidirectional flow of data. It was great.

Until your app grew.

How the heck do you scale a central store of all app state? Where do you drill all the props? Why does every update go through a bazillion nested layers before it shows?

React Hooks enable a new architecture.

An architecture where state lives where you need it, business logic is where you use it, and anyone can understand your code without studying the whole codebase.

ð—•ð—œð—¢
Swizec is a prolific engineer, instructor, blogger, vlogger, conference speaker, and author. He's written many books including ReactForDataViz.com, Data Visualization with D3.js, the work-in-progress SeverlessHandbook.Dev, and ServerlessReact.Dev. He has trained the engineering teams from multiple Fortune 500 companies on React, Redux, GraphQL, Serverless, and other modern web technologies.

links:
ReactiveOnline Meetups are powered by Vacuumlabs
https://www.vacuumlabs.com

Swizec Teller / Twitter: @Swizec / w: https://swizec.com

Andrej Skok / Twitter: @andrejskoki
Captions: 
	00:00:06,960 --> 00:00:19,830
hello everyone welcome to our

00:00:14,490 --> 00:00:22,080
online Meetup first of all let me let me

00:00:19,830 --> 00:00:25,320
tell you that I really hope that you are

00:00:22,080 --> 00:00:28,529
all staying home safe with your families

00:00:25,320 --> 00:00:30,890
and you are not stressed out about the

00:00:28,529 --> 00:00:34,530
coffee situation and you are enjoying

00:00:30,890 --> 00:00:37,800
some great books or games or or online

00:00:34,530 --> 00:00:39,870
presentations I'm really excited that

00:00:37,800 --> 00:00:43,070
you made the decision to stay ahead of

00:00:39,870 --> 00:00:45,780
the curve and spent this evening with us

00:00:43,070 --> 00:00:50,699
it's really great to see so many

00:00:45,780 --> 00:00:54,449
attendees to introduce myself and the

00:00:50,699 --> 00:00:58,559
Scott I will be host today and I will be

00:00:54,449 --> 00:01:01,229
also the meta speaker I work for for

00:00:58,559 --> 00:01:04,979
Viking labs which is the company that

00:01:01,229 --> 00:01:07,970
stays behind and was behind the original

00:01:04,979 --> 00:01:12,740
idea of the reactive come from back in

00:01:07,970 --> 00:01:15,240
2015 we are focused on providing the

00:01:12,740 --> 00:01:17,130
flexible and reliable software engineers

00:01:15,240 --> 00:01:20,340
to clients all over the all over the

00:01:17,130 --> 00:01:24,000
world from Los Angeles to Tokyo

00:01:20,340 --> 00:01:28,380
basically focused mainly on feedback and

00:01:24,000 --> 00:01:31,649
blockchain projects my position in the

00:01:28,380 --> 00:01:36,950
company is that for four years already

00:01:31,649 --> 00:01:41,539
I am from tenth calculate working for

00:01:36,950 --> 00:01:44,880
tv.com the point Achatz in company

00:01:41,539 --> 00:01:48,210
before my presentation begins with me

00:01:44,880 --> 00:01:51,179
just give you a few notes how this will

00:01:48,210 --> 00:01:53,609
be organized so first of all there is a

00:01:51,179 --> 00:01:56,549
QA QA

00:01:53,609 --> 00:01:58,770
there is an option to ask questions on

00:01:56,549 --> 00:02:02,579
the bottom of your select windows feel

00:01:58,770 --> 00:02:05,969
free to ask questions anytime during the

00:02:02,579 --> 00:02:08,700
talk after meta talk and even after the

00:02:05,969 --> 00:02:10,560
main talk there will be two separate QA

00:02:08,700 --> 00:02:13,040
sessions and hopefully all your

00:02:10,560 --> 00:02:15,390
questions will be answered

00:02:13,040 --> 00:02:17,010
secondly there is a select channel

00:02:15,390 --> 00:02:20,850
reactive online Meetup

00:02:17,010 --> 00:02:24,270
that's like calm feel free to join and

00:02:20,850 --> 00:02:28,410
ask questions and discuss topics even

00:02:24,270 --> 00:02:32,010
after the talk so will be really

00:02:28,410 --> 00:02:37,590
but if if you will join visits and also

00:02:32,010 --> 00:02:41,430
me we are both there also there is a

00:02:37,590 --> 00:02:42,660
main speaker available on the call so

00:02:41,430 --> 00:02:50,570
welcomes with it

00:02:42,660 --> 00:02:54,200
how are you doing hurry yeah also great

00:02:50,570 --> 00:02:58,200
I'm really excited for the talks of

00:02:54,200 --> 00:03:00,930
course for your more than for mine but

00:02:58,200 --> 00:03:06,060
it might not be the same for all of the

00:03:00,930 --> 00:03:08,520
attendees hopefully so pretty much what

00:03:06,060 --> 00:03:10,590
is left to say is that stage is mine and

00:03:08,520 --> 00:03:14,520
I will just start with my presentation

00:03:10,590 --> 00:03:20,070
so enjoy enjoy your evening grab your

00:03:14,520 --> 00:03:28,740
beers and let's start hopefully you can

00:03:20,070 --> 00:03:31,470
see my screen perfect so I choose the

00:03:28,740 --> 00:03:36,990
title for my meta tall to be mined the

00:03:31,470 --> 00:03:41,850
Perth and and I hope that you will mind

00:03:36,990 --> 00:03:48,510
the performance a little bit more after

00:03:41,850 --> 00:03:51,660
this after this meta talk first of all

00:03:48,510 --> 00:03:54,390
who is behind the screen so I have

00:03:51,660 --> 00:03:59,489
already introduced myself for four years

00:03:54,390 --> 00:04:01,620
working for only on the web in a travel

00:03:59,489 --> 00:04:04,410
industry I've been part of vacuum labs

00:04:01,620 --> 00:04:10,250
for four five years so that's my coding

00:04:04,410 --> 00:04:14,580
career my handle on the most popular

00:04:10,250 --> 00:04:18,209
ornithologist website is at Andres kaki

00:04:14,580 --> 00:04:27,240
so you can get get in touch with me

00:04:18,209 --> 00:04:29,700
there I read to eat a lot of time so to

00:04:27,240 --> 00:04:32,430
give you a context and some initial

00:04:29,700 --> 00:04:35,040
setting so how we were thinking about

00:04:32,430 --> 00:04:39,200
the performance where we start when we

00:04:35,040 --> 00:04:41,630
started and I will try to just show you

00:04:39,200 --> 00:04:45,270
the steps

00:04:41,630 --> 00:04:45,720
that we have taken just to reach reached

00:04:45,270 --> 00:04:49,250
our goal

00:04:45,720 --> 00:04:51,180
so when we first started the codebase

00:04:49,250 --> 00:04:52,860
when we started thinking about

00:04:51,180 --> 00:04:55,560
performance at the performance is our

00:04:52,860 --> 00:04:59,070
problem the code base was five to six

00:04:55,560 --> 00:05:01,860
years old the problem was that the tech

00:04:59,070 --> 00:05:04,950
changed multiple times and majored in

00:05:01,860 --> 00:05:08,670
times of JavaScript fatigue so there was

00:05:04,950 --> 00:05:11,010
a really great idea every every day what

00:05:08,670 --> 00:05:14,460
we should do differently and we never

00:05:11,010 --> 00:05:17,370
speak to one one proper technology for a

00:05:14,460 --> 00:05:19,350
longer period of time the code base was

00:05:17,370 --> 00:05:23,340
growing pretty much features were more

00:05:19,350 --> 00:05:26,340
important than performance and we were

00:05:23,340 --> 00:05:28,490
adding new features maybe tests we were

00:05:26,340 --> 00:05:31,470
going through a lot of rate redesigns

00:05:28,490 --> 00:05:34,620
after the some UX research first was

00:05:31,470 --> 00:05:36,780
done the up up felt slow

00:05:34,620 --> 00:05:39,030
we made some measurements and find out

00:05:36,780 --> 00:05:41,220
that we are really lagging behind the

00:05:39,030 --> 00:05:43,230
industry standard if in terms of basic

00:05:41,220 --> 00:05:46,230
performance like time to interacting

00:05:43,230 --> 00:05:48,810
visually complete or page load time for

00:05:46,230 --> 00:05:50,730
us the initial load stopped around one

00:05:48,810 --> 00:05:53,010
megabyte of JavaScript and five megabyte

00:05:50,730 --> 00:05:56,160
of total assets after the compression it

00:05:53,010 --> 00:06:00,020
may not sound like like much but

00:05:56,160 --> 00:06:03,240
industry standard was maybe half of that

00:06:00,020 --> 00:06:06,390
today my main goal is to summarize the

00:06:03,240 --> 00:06:08,370
steps which we gradually took and which

00:06:06,390 --> 00:06:11,010
Butcher pushed us to much better

00:06:08,370 --> 00:06:12,780
performance and in the end improved our

00:06:11,010 --> 00:06:17,550
code based quality and also the

00:06:12,780 --> 00:06:20,340
processes the prerequisite of the tech

00:06:17,550 --> 00:06:23,370
you should know is pretty much the web

00:06:20,340 --> 00:06:25,890
pack Babel and the basics of Jessica

00:06:23,370 --> 00:06:28,560
system it will be really high level and

00:06:25,890 --> 00:06:34,260
it will be more about concepts that than

00:06:28,560 --> 00:06:37,080
some really specific configurations my

00:06:34,260 --> 00:06:39,570
my first recommendation is that mind the

00:06:37,080 --> 00:06:40,350
dependencies and might mind them from

00:06:39,570 --> 00:06:43,890
the start

00:06:40,350 --> 00:06:48,450
start it made sound sound really trivial

00:06:43,890 --> 00:06:50,880
but at first our dependencies or

00:06:48,450 --> 00:06:54,919
third-party libraries in our code made

00:06:50,880 --> 00:06:54,919
up more than 60% of the codebase

00:06:55,060 --> 00:06:59,520
there is nothing inherently wrong with

00:06:56,919 --> 00:07:02,370
using the dependencies and using

00:06:59,520 --> 00:07:05,110
third-party code and using it wisely

00:07:02,370 --> 00:07:07,570
because pretty much that's what we all

00:07:05,110 --> 00:07:10,510
do like we reuse someone else else's

00:07:07,570 --> 00:07:13,300
code because we do not want all to build

00:07:10,510 --> 00:07:16,600
everything from ground up on the green

00:07:13,300 --> 00:07:18,610
field but make sure that you are using

00:07:16,600 --> 00:07:21,280
your dependencies wisely and to the

00:07:18,610 --> 00:07:23,980
fullest and you are not including that

00:07:21,280 --> 00:07:26,710
ends of kilobytes of code and using just

00:07:23,980 --> 00:07:28,960
a few functions from it that really

00:07:26,710 --> 00:07:31,479
makes no sense and further analysis

00:07:28,960 --> 00:07:34,720
could have been done what is more

00:07:31,479 --> 00:07:37,389
important that it's it's not just a

00:07:34,720 --> 00:07:44,710
library self about the dependencies that

00:07:37,389 --> 00:07:46,750
come I'll come with that library what

00:07:44,710 --> 00:07:48,550
we're our our steps we're that we

00:07:46,750 --> 00:07:51,010
started to actively search for libraries

00:07:48,550 --> 00:07:54,419
that do exactly the things that we need

00:07:51,010 --> 00:07:58,180
it to do and the library itself has

00:07:54,419 --> 00:08:00,610
minimum dependencies that's pretty much

00:07:58,180 --> 00:08:03,490
like using Rambla overload ash rambha

00:08:00,610 --> 00:08:06,340
has dependencies I think date functions

00:08:03,490 --> 00:08:08,800
our moment or throwing away the

00:08:06,340 --> 00:08:11,919
libraries which you probably do not need

00:08:08,800 --> 00:08:13,479
may be immutable Jas like we know that

00:08:11,919 --> 00:08:16,210
we cannot get rid of it completely

00:08:13,479 --> 00:08:17,979
because it's dependency to all too many

00:08:16,210 --> 00:08:21,280
other libraries but at least we can try

00:08:17,979 --> 00:08:25,510
and do not have it there in our bound on

00:08:21,280 --> 00:08:28,300
multiple times for example this has

00:08:25,510 --> 00:08:30,430
other great consequences like having

00:08:28,300 --> 00:08:36,520
faster pipeline installed time of the

00:08:30,430 --> 00:08:44,440
application faster security old it ran

00:08:36,520 --> 00:08:46,060
on NPM I recommend the using some of the

00:08:44,440 --> 00:08:47,650
pay web pages which will tell you more

00:08:46,060 --> 00:08:50,290
about the libraries that you are using

00:08:47,650 --> 00:08:53,110
or going to install like pantophobia

00:08:50,290 --> 00:08:55,620
comm which is a pretty great overview

00:08:53,110 --> 00:08:58,240
that what the size of the library

00:08:55,620 --> 00:09:01,839
whether it's dependencies how big they

00:08:58,240 --> 00:09:04,150
are how the size of the library is

00:09:01,839 --> 00:09:06,280
changing with the versions so that's

00:09:04,150 --> 00:09:07,810
this is a really nice to do at least the

00:09:06,280 --> 00:09:09,400
basic track of

00:09:07,810 --> 00:09:13,060
some dependency that you are going to

00:09:09,400 --> 00:09:14,860
add to your to your coat also we started

00:09:13,060 --> 00:09:17,680
to periodically check whether the

00:09:14,860 --> 00:09:19,810
pendency still make sense so maybe there

00:09:17,680 --> 00:09:21,790
is some better alternative which may not

00:09:19,810 --> 00:09:26,080
have existed before when we started to

00:09:21,790 --> 00:09:27,580
start the programming or maybe there are

00:09:26,080 --> 00:09:30,310
some dependencies which can be dropped

00:09:27,580 --> 00:09:32,470
altogether which may always happen in a

00:09:30,310 --> 00:09:39,010
pretty big codebase that the clean up is

00:09:32,470 --> 00:09:41,200
not always on 100% my second

00:09:39,010 --> 00:09:44,290
recommendation is that if you have to

00:09:41,200 --> 00:09:45,610
use the dependencies to reshape them so

00:09:44,290 --> 00:09:47,050
if you do not feel like we're moving in

00:09:45,610 --> 00:09:49,510
the library that's still fine

00:09:47,050 --> 00:09:51,730
maybe there is nothing better which can

00:09:49,510 --> 00:09:55,720
be used at the time but you can always

00:09:51,730 --> 00:09:57,760
save a few kilobytes if you if you tree

00:09:55,720 --> 00:09:59,080
shake it properly it may be the case

00:09:57,760 --> 00:10:01,300
that you are just importing the eight

00:09:59,080 --> 00:10:03,850
entities in the front way and you should

00:10:01,300 --> 00:10:06,640
just install some babel plugin or web

00:10:03,850 --> 00:10:09,540
deploy perfect plugin which will just

00:10:06,640 --> 00:10:13,900
during the translation of the code

00:10:09,540 --> 00:10:17,260
adjust the imports so they are used they

00:10:13,900 --> 00:10:22,089
are used properly and in such a way that

00:10:17,260 --> 00:10:25,060
they can be true shaken in my own

00:10:22,089 --> 00:10:27,310
experience some web pack plugins are a

00:10:25,060 --> 00:10:30,130
little bit dangerous for example for

00:10:27,310 --> 00:10:32,410
lavash because they alter the the the

00:10:30,130 --> 00:10:34,720
behavior of the library they tries to

00:10:32,410 --> 00:10:36,670
optimize so much that they will they

00:10:34,720 --> 00:10:40,240
will even remove something that was

00:10:36,670 --> 00:10:46,559
really important so be aware but at

00:10:40,240 --> 00:10:49,529
least give it a try next step

00:10:46,559 --> 00:10:53,789
our next step was to analyze our bundle

00:10:49,529 --> 00:10:56,549
size and our analyze is it regularly so

00:10:53,789 --> 00:10:59,309
we started to use webpack analyzer to do

00:10:56,549 --> 00:11:01,679
at least basic bundle structure overview

00:10:59,309 --> 00:11:03,809
so this is pretty much how it looks like

00:11:01,679 --> 00:11:06,629
today it gives you a pretty great

00:11:03,809 --> 00:11:08,789
overview but without the big chunks in

00:11:06,629 --> 00:11:12,779
your code like all this is the lightest

00:11:08,789 --> 00:11:14,969
JSON can I remove it do we need it where

00:11:12,779 --> 00:11:17,369
is this having 100 kilobytes can I

00:11:14,969 --> 00:11:20,939
remove it can I split maybe some chunks

00:11:17,369 --> 00:11:23,279
even more who knows is it worth it so

00:11:20,939 --> 00:11:28,529
you can start asking a lot of useful

00:11:23,279 --> 00:11:31,979
questions based on what you can see so

00:11:28,529 --> 00:11:35,219
so the tooling was essential and and

00:11:31,979 --> 00:11:37,799
then we start asking questions and at

00:11:35,219 --> 00:11:41,399
first pretty much basically we had one

00:11:37,799 --> 00:11:44,729
bundle and everything was everywhere

00:11:41,399 --> 00:11:47,339
everything was in one chunk it was quite

00:11:44,729 --> 00:11:49,259
easy to spot some low-hanging fruit big

00:11:47,339 --> 00:11:52,379
chunks of code which are loaded at the

00:11:49,259 --> 00:11:55,889
wrong time or do not need to be loaded

00:11:52,379 --> 00:11:57,599
at all it was just that code and there

00:11:55,889 --> 00:12:01,109
was so much of it that it was pretty

00:11:57,599 --> 00:12:04,679
much obvious that it has to go away and

00:12:01,109 --> 00:12:08,639
our main goal was to start using dynamic

00:12:04,679 --> 00:12:12,899
imports where we could and minimizing

00:12:08,639 --> 00:12:15,899
the visibility of loading on the page

00:12:12,899 --> 00:12:18,179
due to code not being ready yet so we

00:12:15,899 --> 00:12:20,399
started off loading the features in

00:12:18,179 --> 00:12:23,369
models the features which are not so

00:12:20,399 --> 00:12:26,069
heavily used based on our analytics or

00:12:23,369 --> 00:12:29,429
for example in which medications for

00:12:26,069 --> 00:12:32,039
date functions or or moment libraries

00:12:29,429 --> 00:12:34,189
that's that there are pretty huge chunks

00:12:32,039 --> 00:12:37,919
of code and they are probably not needed

00:12:34,189 --> 00:12:39,479
because because you need just at one

00:12:37,919 --> 00:12:43,259
language which the users currently

00:12:39,479 --> 00:12:46,499
currently using and and see quite

00:12:43,259 --> 00:12:48,209
naturally we came to a point where we

00:12:46,499 --> 00:12:50,939
started to use dynamic imports per

00:12:48,209 --> 00:12:52,709
screen I will call it the scene and

00:12:50,939 --> 00:12:56,429
created one chunk for common code of

00:12:52,709 --> 00:12:58,490
course but the result was not as we

00:12:56,429 --> 00:13:01,370
expected

00:12:58,490 --> 00:13:03,860
we ended up pretty much which each each

00:13:01,370 --> 00:13:05,810
scene having one two one two five

00:13:03,860 --> 00:13:08,899
percent of the total size of the code

00:13:05,810 --> 00:13:11,270
and when become a chunk having the rest

00:13:08,899 --> 00:13:12,020
seventy-five percent of the size of of

00:13:11,270 --> 00:13:14,209
the codebase

00:13:12,020 --> 00:13:18,110
so that was pretty much not ideal we

00:13:14,209 --> 00:13:22,839
were hoping for something more even so

00:13:18,110 --> 00:13:26,540
this is something which helped a bit in

00:13:22,839 --> 00:13:30,920
terms of performance of loading of our

00:13:26,540 --> 00:13:33,620
page but it was far from optimal so we

00:13:30,920 --> 00:13:37,250
decided to split them on a load and the

00:13:33,620 --> 00:13:39,830
main problem was that which we realized

00:13:37,250 --> 00:13:42,140
pretty quickly that there are some some

00:13:39,830 --> 00:13:44,990
some big notes in our dependency graph

00:13:42,140 --> 00:13:47,750
which were pretty much the files which

00:13:44,990 --> 00:13:50,540
which included a lot of other files and

00:13:47,750 --> 00:13:52,790
we're gluing the codebase together so a

00:13:50,540 --> 00:13:56,600
nice example if you are using relax is

00:13:52,790 --> 00:13:59,770
your your register in which you are

00:13:56,600 --> 00:14:02,959
combining all the all of the other users

00:13:59,770 --> 00:14:05,570
so this is pretty much where you are

00:14:02,959 --> 00:14:07,510
importing all the other reducers those

00:14:05,570 --> 00:14:10,820
are in importing the actions they are

00:14:07,510 --> 00:14:13,190
importing maybe maybe some types some

00:14:10,820 --> 00:14:15,829
utils and whatever so so these were

00:14:13,190 --> 00:14:17,720
really the glue of the code base and the

00:14:15,829 --> 00:14:21,470
second problem was that we were cross

00:14:17,720 --> 00:14:23,300
importing too much like there were the

00:14:21,470 --> 00:14:27,020
the files from common were importing

00:14:23,300 --> 00:14:29,120
from other scenes the scenes were

00:14:27,020 --> 00:14:31,160
importing one from from from another

00:14:29,120 --> 00:14:34,730
instead of putting the the code in

00:14:31,160 --> 00:14:37,190
common so it was quite quite quite mess

00:14:34,730 --> 00:14:42,829
but it was not visible at the first

00:14:37,190 --> 00:14:45,890
sight so so we started to do to clean up

00:14:42,829 --> 00:14:47,930
clean up the mess and we started with

00:14:45,890 --> 00:14:51,110
isolated rules because Iceland for the

00:14:47,930 --> 00:14:53,709
win when you need to enforce something

00:14:51,110 --> 00:14:57,709
which can be done by static analysis

00:14:53,709 --> 00:15:00,890
just try to write a static excellent

00:14:57,709 --> 00:15:03,350
rule for it because there is no chance

00:15:00,890 --> 00:15:06,140
that if you write it in some code review

00:15:03,350 --> 00:15:08,690
guideline that people will not overload

00:15:06,140 --> 00:15:11,930
pigs will stick to it you have to really

00:15:08,690 --> 00:15:12,259
enforce it properly so we started to

00:15:11,930 --> 00:15:14,600
write

00:15:12,259 --> 00:15:18,499
a lot of excellent rules for restricted

00:15:14,600 --> 00:15:22,009
paths world can be imported from where

00:15:18,499 --> 00:15:25,189
and start cleaning cleaning up to code

00:15:22,009 --> 00:15:28,309
and pretty much breaking up all the all

00:15:25,189 --> 00:15:31,069
the notes which are going to the

00:15:28,309 --> 00:15:37,939
codebase together but they didn't have

00:15:31,069 --> 00:15:40,369
to it was just our fault we took also an

00:15:37,939 --> 00:15:42,289
extra step for length in page because

00:15:40,369 --> 00:15:50,359
the one the landing page loading time

00:15:42,289 --> 00:15:53,089
was the most important for us so we

00:15:50,359 --> 00:15:55,669
really what we really wanted to achieve

00:15:53,089 --> 00:15:59,660
was that for running page we would load

00:15:55,669 --> 00:16:01,819
just the code which is needed for to be

00:15:59,660 --> 00:16:03,529
run on the on the landing page so we

00:16:01,819 --> 00:16:06,410
will not waste time parsing and

00:16:03,529 --> 00:16:08,989
executing the common common code which

00:16:06,410 --> 00:16:11,359
ended up in a common chunk and load it

00:16:08,989 --> 00:16:14,989
on the landing page but was not actually

00:16:11,359 --> 00:16:18,470
used there so we ended up with two

00:16:14,989 --> 00:16:22,789
common common chunks the first one was

00:16:18,470 --> 00:16:24,980
the was the one was the common part of

00:16:22,789 --> 00:16:27,799
the code but was landing on the landing

00:16:24,980 --> 00:16:30,259
page and in the includes just the common

00:16:27,799 --> 00:16:32,899
code shared by the landing page and the

00:16:30,259 --> 00:16:37,339
other modules and the second chunk was

00:16:32,899 --> 00:16:39,289
the common code loaded shared just

00:16:37,339 --> 00:16:42,019
between the rest of the of the other

00:16:39,289 --> 00:16:44,509
chunks so on landing page reload the

00:16:42,019 --> 00:16:49,759
just the first one and all of the other

00:16:44,509 --> 00:16:53,119
pages really loved it this they say this

00:16:49,759 --> 00:16:56,230
was a great saving for us it saved us

00:16:53,119 --> 00:17:01,009
like 20 percent of the of the code size

00:16:56,230 --> 00:17:02,629
so this this we were on a really good

00:17:01,009 --> 00:17:04,789
track here

00:17:02,629 --> 00:17:07,370
the second optimization we made here was

00:17:04,789 --> 00:17:09,169
that we separated the so called stable

00:17:07,370 --> 00:17:12,350
libraries and the dependencies which we

00:17:09,169 --> 00:17:16,519
do not update very often like react

00:17:12,350 --> 00:17:21,470
maybe style components which which are

00:17:16,519 --> 00:17:24,860
not like crazy updated or and but only

00:17:21,470 --> 00:17:25,510
on just some regular basis so that we

00:17:24,860 --> 00:17:29,190
can use

00:17:25,510 --> 00:17:31,960
we can cash it for four regular users

00:17:29,190 --> 00:17:35,800
this also helped much wait for

00:17:31,960 --> 00:17:38,320
subsequent wizards even some more

00:17:35,800 --> 00:17:42,190
optimizations with it and summarize it

00:17:38,320 --> 00:17:44,590
on one slide pretty much we prepared two

00:17:42,190 --> 00:17:47,620
different bundles modern one and the

00:17:44,590 --> 00:17:51,310
legacy one and we serve them based on

00:17:47,620 --> 00:17:53,200
the browser so there is a great

00:17:51,310 --> 00:17:55,750
advantage when you do not have to

00:17:53,200 --> 00:17:59,440
transpile the code to some some some

00:17:55,750 --> 00:18:02,650
legacy constructs and use directly what

00:17:59,440 --> 00:18:05,250
browser is allowing you you to use it

00:18:02,650 --> 00:18:08,350
results in a lot less lines of code

00:18:05,250 --> 00:18:09,970
pretty much we could drop majority of

00:18:08,350 --> 00:18:13,060
the polyfills for new web browser

00:18:09,970 --> 00:18:17,970
sectors and we saved around around 10 to

00:18:13,060 --> 00:18:20,980
15% just a trace translation itself I

00:18:17,970 --> 00:18:23,890
also strongly advise to start pre

00:18:20,980 --> 00:18:28,470
connecting to domains which are which

00:18:23,890 --> 00:18:32,830
have and provide blocking resources I

00:18:28,470 --> 00:18:35,380
even suggest to shave off some time by

00:18:32,830 --> 00:18:38,890
declaring in your head head of the

00:18:35,380 --> 00:18:43,360
document the the scripts which need to

00:18:38,890 --> 00:18:46,000
be pre-loaded so it will not block the

00:18:43,360 --> 00:18:49,120
parsing but the browser will start start

00:18:46,000 --> 00:18:52,180
fetching those resources and also

00:18:49,120 --> 00:18:55,240
optionally as I said we want to minimize

00:18:52,180 --> 00:18:57,460
the loading which is which is which is

00:18:55,240 --> 00:19:00,190
shown to user because the code is not

00:18:57,460 --> 00:19:03,670
loaded yet so we started to pretty

00:19:00,190 --> 00:19:06,220
heavily use also prefetching but only in

00:19:03,670 --> 00:19:07,720
times of course when the user will

00:19:06,220 --> 00:19:10,650
choose that now is the right time to

00:19:07,720 --> 00:19:14,200
prefetch the code and not forcing it to

00:19:10,650 --> 00:19:19,930
fetch it at times when it has a lot of

00:19:14,200 --> 00:19:22,690
work to do - - to load - all the page we

00:19:19,930 --> 00:19:25,660
lazy load each other assets assets which

00:19:22,690 --> 00:19:27,760
which which we could of all off screen

00:19:25,660 --> 00:19:33,420
screen contact account content all the

00:19:27,760 --> 00:19:37,720
images all the non-critical CSS so this

00:19:33,420 --> 00:19:41,710
say that saved us another Millis

00:19:37,720 --> 00:19:43,500
constants of milliseconds and and a lot

00:19:41,710 --> 00:19:48,400
of a lot of bandwidth

00:19:43,500 --> 00:19:51,490
during the first lot just to keep the

00:19:48,400 --> 00:19:56,380
bar high do not rely on the code reviews

00:19:51,490 --> 00:19:58,780
only you have to just enforce it by

00:19:56,380 --> 00:20:01,960
rules against back best bad practices

00:19:58,780 --> 00:20:04,840
and then habits pretty much best

00:20:01,960 --> 00:20:06,100
squirreling what winters are for and I

00:20:04,840 --> 00:20:09,940
would suggest to use them whenever

00:20:06,100 --> 00:20:12,160
possible you need to you need to do at

00:20:09,940 --> 00:20:14,440
least some basic sanity check checks in

00:20:12,160 --> 00:20:16,810
CI for example check for your size

00:20:14,440 --> 00:20:19,510
limits set some proper size limits for

00:20:16,810 --> 00:20:23,320
your chunk and keep tracking them and

00:20:19,510 --> 00:20:24,970
let your pipeline warn you or fail and

00:20:23,320 --> 00:20:27,580
then of course production time

00:20:24,970 --> 00:20:30,760
monitoring on server side the response

00:20:27,580 --> 00:20:33,550
time nineteen ninety fifth percentile

00:20:30,760 --> 00:20:36,550
response time request I'd taking more

00:20:33,550 --> 00:20:39,130
than X milliseconds whatever may feel

00:20:36,550 --> 00:20:42,400
slow for a user and on the client-side

00:20:39,130 --> 00:20:44,860
tools like Pingdom speaker and checking

00:20:42,400 --> 00:20:46,930
their for a total total bundle size time

00:20:44,860 --> 00:20:49,420
to interactive time to first byte and

00:20:46,930 --> 00:20:54,160
and some others if you find them

00:20:49,420 --> 00:20:56,770
interesting and to just wrap it up our

00:20:54,160 --> 00:20:58,840
final results where that after one year

00:20:56,770 --> 00:21:02,710
of gradually factors while I thinking

00:20:58,840 --> 00:21:04,720
features so not no situations like we

00:21:02,710 --> 00:21:07,120
have to stop adding features for a week

00:21:04,720 --> 00:21:08,140
because I have to do one properly factor

00:21:07,120 --> 00:21:12,400
nothing like that

00:21:08,140 --> 00:21:15,160
our HTML size dropped from 200 to twenty

00:21:12,400 --> 00:21:18,280
five kilobytes we got rid of 100

00:21:15,160 --> 00:21:21,550
kilobytes of CSS by using styled

00:21:18,280 --> 00:21:24,130
components and having critical CSS in

00:21:21,550 --> 00:21:26,230
the HTML and our JavaScript size

00:21:24,130 --> 00:21:28,480
decreased not increased so that's also

00:21:26,230 --> 00:21:30,940
pretty important and we managed to

00:21:28,480 --> 00:21:35,320
reduce the time to interactive monitored

00:21:30,940 --> 00:21:40,030
and the page load time by 20% time to

00:21:35,320 --> 00:21:44,410
visual complete by 50 40 % was the

00:21:40,030 --> 00:21:48,580
saving of the JavaScript all together

00:21:44,410 --> 00:21:50,410
and we shaved off nearly 60% of the

00:21:48,580 --> 00:21:51,420
total size of the page so currently

00:21:50,410 --> 00:21:54,280
something

00:21:51,420 --> 00:21:55,600
around two megabytes not five like it

00:21:54,280 --> 00:21:58,480
used to be

00:21:55,600 --> 00:22:01,960
of course like with everything there is

00:21:58,480 --> 00:22:04,570
one catch that is that you need a really

00:22:01,960 --> 00:22:07,270
awesome team full of great full of great

00:22:04,570 --> 00:22:11,500
developers to achieve something like

00:22:07,270 --> 00:22:15,220
that and a constant support so so so

00:22:11,500 --> 00:22:20,700
really big thanks to them but it was a

00:22:15,220 --> 00:22:23,260
great experience that one here yeah I'm

00:22:20,700 --> 00:22:27,760
pretty much that's it does everything

00:22:23,260 --> 00:22:41,110
from me I will not just stop sharing and

00:22:27,760 --> 00:22:44,410
we can move to Q&A so let's see no

00:22:41,110 --> 00:22:48,130
questions there I actually have a

00:22:44,410 --> 00:22:50,800
question oh let's go for it so you

00:22:48,130 --> 00:22:52,450
mentioned that limiting dependencies was

00:22:50,800 --> 00:22:54,280
something that really helped you with

00:22:52,450 --> 00:22:56,680
your bundle sizes and how much

00:22:54,280 --> 00:22:59,350
JavaScript you load how do you feel

00:22:56,680 --> 00:23:01,990
about copy paste dependencies where you

00:22:59,350 --> 00:23:03,550
find a project on github that does what

00:23:01,990 --> 00:23:07,360
you need it and you just copy paste its

00:23:03,550 --> 00:23:09,910
code into your posit ory mm-hmm that's a

00:23:07,360 --> 00:23:13,210
really great question like we have I

00:23:09,910 --> 00:23:15,730
don't think that this is something you

00:23:13,210 --> 00:23:17,260
want to do or on a regular basis or with

00:23:15,730 --> 00:23:19,030
the majority of your dependencies

00:23:17,260 --> 00:23:24,220
because then you have to support them

00:23:19,030 --> 00:23:25,410
all pretty much but I did it I did a few

00:23:24,220 --> 00:23:27,700
things

00:23:25,410 --> 00:23:29,940
sometimes when the dependency is really

00:23:27,700 --> 00:23:32,830
old I just copied it over and just

00:23:29,940 --> 00:23:36,310
rewrite it maybe to something more

00:23:32,830 --> 00:23:39,790
modern and maybe just got rid of the

00:23:36,310 --> 00:23:43,750
unnecessary parts so yeah I think that's

00:23:39,790 --> 00:23:46,210
doable and it can be done the second one

00:23:43,750 --> 00:23:48,690
was that I was forking and I'm still

00:23:46,210 --> 00:23:52,720
actively forking the repositories and

00:23:48,690 --> 00:23:54,640
making them more modern so I will get

00:23:52,720 --> 00:23:56,670
rid of for example two dependencies

00:23:54,640 --> 00:24:00,550
which have known critical dependence

00:23:56,670 --> 00:24:03,010
critical security issues with them and

00:24:00,550 --> 00:24:04,300
this may be the case for example when

00:24:03,010 --> 00:24:07,410
the library is not maintained

00:24:04,300 --> 00:24:10,840
for a year it almost certainly appear

00:24:07,410 --> 00:24:16,030
that these kind of issues so I'm doing

00:24:10,840 --> 00:24:18,190
these two approaches and I feel until

00:24:16,030 --> 00:24:20,800
now I feel fine with it but I wouldn't

00:24:18,190 --> 00:24:26,770
want to do it with many libraries to be

00:24:20,800 --> 00:24:30,160
honest yeah I got the idea from a CD

00:24:26,770 --> 00:24:32,710
light on Twitter he said that when he

00:24:30,160 --> 00:24:34,420
finds a small small package it's easier

00:24:32,710 --> 00:24:37,870
to just copy paste the code rather than

00:24:34,420 --> 00:24:40,780
have another NPM dependency yep even

00:24:37,870 --> 00:24:44,080
even more when the the code is using

00:24:40,780 --> 00:24:46,090
really dependencies which are not really

00:24:44,080 --> 00:24:55,020
necessary on or you do not feel

00:24:46,090 --> 00:24:58,240
comfortable with them so so yeah great

00:24:55,020 --> 00:25:01,810
awesome if you if any of you have any

00:24:58,240 --> 00:25:04,840
questions or I was too fast just write

00:25:01,810 --> 00:25:07,300
the questions down or just get in touch

00:25:04,840 --> 00:25:13,750
with me on the rack to online meetups

00:25:07,300 --> 00:25:16,480
like so feel free everyone ok so it's

00:25:13,750 --> 00:25:19,690
pretty much the stage is yours

00:25:16,480 --> 00:25:23,140
so repair your screen and we are really

00:25:19,690 --> 00:25:26,500
are all excited and looking forward so

00:25:23,140 --> 00:25:31,600
let's bring it on for a guy who is using

00:25:26,500 --> 00:25:38,020
redux for the half of his career so like

00:25:31,600 --> 00:25:40,920
let's do this screen okay so hi everyone

00:25:38,020 --> 00:25:42,970
i'm swiss force wizards depending on how

00:25:40,920 --> 00:25:46,050
Americanized you want to pronounce my

00:25:42,970 --> 00:25:49,660
name today I'm gonna talk to you about a

00:25:46,050 --> 00:25:51,490
pattern not a library it's a pattern I'm

00:25:49,660 --> 00:25:54,010
calling the wormhole state management

00:25:51,490 --> 00:25:56,680
pattern that I kind of developed when I

00:25:54,010 --> 00:25:58,600
was working on a library that some

00:25:56,680 --> 00:26:01,270
people are using and I discovered this

00:25:58,600 --> 00:26:04,300
really cool pattern that lets you manage

00:26:01,270 --> 00:26:06,760
state in a more manageable way without

00:26:04,300 --> 00:26:08,500
using any to any dependencies without

00:26:06,760 --> 00:26:12,700
state management libraries just using

00:26:08,500 --> 00:26:14,500
stuff that's already in react so oh by

00:26:12,700 --> 00:26:16,450
the way I don't have an intro slide

00:26:14,500 --> 00:26:17,330
because I don't like those if you want

00:26:16,450 --> 00:26:18,560
to

00:26:17,330 --> 00:26:21,020
more about me or if you want to reach

00:26:18,560 --> 00:26:23,780
out I think if you types wizards into

00:26:21,020 --> 00:26:27,950
Google you're gonna find a lot of stuff

00:26:23,780 --> 00:26:29,990
about me so I don't know how long you've

00:26:27,950 --> 00:26:32,180
all been react developers but you might

00:26:29,990 --> 00:26:35,090
remember back when react first came on

00:26:32,180 --> 00:26:37,490
the scene it made a huge splash with

00:26:35,090 --> 00:26:39,620
this unidirectional state management

00:26:37,490 --> 00:26:42,820
system or unidirectional data flow

00:26:39,620 --> 00:26:46,460
because back then this was what 2014

00:26:42,820 --> 00:26:47,990
2015 I don't have a mouse when I'm

00:26:46,460 --> 00:26:50,950
presenting that's fun cool

00:26:47,990 --> 00:26:54,290
so I can't open the chatroom so back in

00:26:50,950 --> 00:26:56,720
2015 2016 somewhere thereabouts the way

00:26:54,290 --> 00:27:01,640
we used to build these web apps was that

00:26:56,720 --> 00:27:04,100
you had a lot of painful pain with doing

00:27:01,640 --> 00:27:05,870
state management you could either use an

00:27:04,100 --> 00:27:08,000
event based system like backbone which

00:27:05,870 --> 00:27:10,490
very quickly grew to a point where you

00:27:08,000 --> 00:27:11,990
just had no idea what's going on you

00:27:10,490 --> 00:27:15,410
click the button and a bunch of events

00:27:11,990 --> 00:27:17,330
fired and you really couldn't tell what

00:27:15,410 --> 00:27:19,670
was gonna happen when you did anything

00:27:17,330 --> 00:27:23,000
on the page or there was still a lot of

00:27:19,670 --> 00:27:26,300
jQuery stuff things like that where

00:27:23,000 --> 00:27:28,700
every state update caused a bunch of

00:27:26,300 --> 00:27:32,180
rear Enders and a bunch of Dom reflows

00:27:28,700 --> 00:27:35,710
and it was just terrible so then oh and

00:27:32,180 --> 00:27:37,970
the other popular one was angular with

00:27:35,710 --> 00:27:39,440
bi-directional data flows where he had

00:27:37,970 --> 00:27:41,840
bi-directional binding and you could

00:27:39,440 --> 00:27:43,700
change the state of some variable and it

00:27:41,840 --> 00:27:45,530
would magically update everything that

00:27:43,700 --> 00:27:47,210
dependent on that variable which sounds

00:27:45,530 --> 00:27:50,650
really cool when you're building small

00:27:47,210 --> 00:27:54,230
temos but then it very quickly becomes

00:27:50,650 --> 00:27:57,920
very painful and grows gets out of hand

00:27:54,230 --> 00:27:59,900
and you just I'm actually not it

00:27:57,920 --> 00:28:01,940
basically becomes pretty problematic

00:27:59,900 --> 00:28:04,340
very quickly that I don't know if you've

00:28:01,940 --> 00:28:06,920
worked with code bases like that but it

00:28:04,340 --> 00:28:08,270
doesn't feel nice when you change

00:28:06,920 --> 00:28:10,700
something and you don't know exactly

00:28:08,270 --> 00:28:13,250
what's going to happen or you have to

00:28:10,700 --> 00:28:15,740
trace too much of the code to figure out

00:28:13,250 --> 00:28:17,960
how things are actually working so the

00:28:15,740 --> 00:28:20,090
UNIVAC unidirectional data flow was this

00:28:17,960 --> 00:28:23,360
wonderful idea from the Facebook team

00:28:20,090 --> 00:28:25,460
from Facebook's react team where you

00:28:23,360 --> 00:28:27,800
could suddenly understand how your

00:28:25,460 --> 00:28:30,830
entire application work data would

00:28:27,800 --> 00:28:33,260
always go just in one direction from the

00:28:30,830 --> 00:28:34,789
from your top component all the way down

00:28:33,260 --> 00:28:36,649
through your component tree to the

00:28:34,789 --> 00:28:38,450
bottom where something changed so you

00:28:36,649 --> 00:28:43,549
always knew exactly what was happening

00:28:38,450 --> 00:28:45,470
the idea was that your your UI would be

00:28:43,549 --> 00:28:48,529
a direct representation of state you

00:28:45,470 --> 00:28:50,330
would always know okay this is if I

00:28:48,529 --> 00:28:52,730
change state I know that everything

00:28:50,330 --> 00:28:55,279
updates and I don't have weird

00:28:52,730 --> 00:28:58,190
additional things on top of my head

00:28:55,279 --> 00:29:00,049
updates actually D sorry the chatroom

00:28:58,190 --> 00:29:02,690
notification is really bugging me so I

00:29:00,049 --> 00:29:06,950
have to click that maybe I can see the

00:29:02,690 --> 00:29:07,909
chat while I'm doing now it just shows

00:29:06,950 --> 00:29:11,750
there you go

00:29:07,909 --> 00:29:13,250
okay so okay so now I can see the chat I

00:29:11,750 --> 00:29:16,179
don't know if you can see the chat while

00:29:13,250 --> 00:29:19,940
I'm sharing the screen but whatever so

00:29:16,179 --> 00:29:22,750
basically the idea of the unidirectional

00:29:19,940 --> 00:29:24,860
data flow was that it makes your

00:29:22,750 --> 00:29:27,110
application more understandable your

00:29:24,860 --> 00:29:28,639
data is going only in one direction

00:29:27,110 --> 00:29:30,169
you always know what's happening you are

00:29:28,639 --> 00:29:32,450
is a pure representation of state

00:29:30,169 --> 00:29:34,909
because you have all of your states

00:29:32,450 --> 00:29:36,590
stored in a single source of truth it's

00:29:34,909 --> 00:29:38,809
very easy to sync between different

00:29:36,590 --> 00:29:40,639
components so you can know what's going

00:29:38,809 --> 00:29:42,590
on you can say okay I'm rendering

00:29:40,639 --> 00:29:45,169
something all the way here on the left

00:29:42,590 --> 00:29:47,299
and it depends on something a component

00:29:45,169 --> 00:29:49,970
over here on the right path and you

00:29:47,299 --> 00:29:51,590
connect them together over the single

00:29:49,970 --> 00:29:53,720
source of truth and everything is

00:29:51,590 --> 00:29:56,899
updating in super-awesome so that was

00:29:53,720 --> 00:29:58,850
nice but I think we kind of you know

00:29:56,899 --> 00:30:01,940
started taking it way too far

00:29:58,850 --> 00:30:03,799
we everybody who was teaching reacted

00:30:01,940 --> 00:30:05,659
back then and I think it still happens a

00:30:03,799 --> 00:30:09,440
lot was saying you should put everything

00:30:05,659 --> 00:30:10,850
in a in your top component top component

00:30:09,440 --> 00:30:12,590
should hold your state and you should

00:30:10,850 --> 00:30:14,750
hold the state for your entire

00:30:12,590 --> 00:30:17,000
application and then you had to deal

00:30:14,750 --> 00:30:18,380
with prop drilling you had to pass

00:30:17,000 --> 00:30:20,950
everything down then you have to pass

00:30:18,380 --> 00:30:23,659
callbacks back up this up the state tree

00:30:20,950 --> 00:30:25,610
so the property line was a huge problem

00:30:23,659 --> 00:30:27,950
you ended up with extremely tight

00:30:25,610 --> 00:30:29,929
coupling between components so if you

00:30:27,950 --> 00:30:32,929
wanted to move a component from the

00:30:29,929 --> 00:30:35,389
bottom of your Dom tree or of your

00:30:32,929 --> 00:30:37,519
reactor 3 to a different part you

00:30:35,389 --> 00:30:40,700
suddenly have to change every component

00:30:37,519 --> 00:30:42,590
that was on that path so everything that

00:30:40,700 --> 00:30:44,190
was between the component you were

00:30:42,590 --> 00:30:48,029
actually changing and

00:30:44,190 --> 00:30:49,440
component that was so everything that

00:30:48,029 --> 00:30:50,700
was between the component that held

00:30:49,440 --> 00:30:52,620
state and the component you were

00:30:50,700 --> 00:30:53,970
actually changing you had to change all

00:30:52,620 --> 00:30:55,799
of that if you wanted to move your

00:30:53,970 --> 00:30:56,789
component somewhere else so that was a

00:30:55,799 --> 00:30:59,940
huge pain in the ass

00:30:56,789 --> 00:31:01,769
so people very smart people were like

00:30:59,940 --> 00:31:05,240
you know what we can save we can solve

00:31:01,769 --> 00:31:07,379
with state libraries so then we had this

00:31:05,240 --> 00:31:09,960
proliferation of state libraries we had

00:31:07,379 --> 00:31:12,000
Redux we have mo bags I think we had a

00:31:09,960 --> 00:31:14,580
couple of others Redux and mobile

00:31:12,000 --> 00:31:17,840
scanning Redux and mo bags I think are

00:31:14,580 --> 00:31:20,370
still the main ones that people use and

00:31:17,840 --> 00:31:22,500
they're great they're awesome libraries

00:31:20,370 --> 00:31:25,049
amazing to use whenever when you're

00:31:22,500 --> 00:31:26,490
starting out well maybe they're not

00:31:25,049 --> 00:31:29,279
amazing to use when you're first

00:31:26,490 --> 00:31:32,100
starting out because it makes your

00:31:29,279 --> 00:31:35,279
application really complicated makes it

00:31:32,100 --> 00:31:37,139
very hard to know well it makes it

00:31:35,279 --> 00:31:39,659
relatively easy to know what's going on

00:31:37,139 --> 00:31:42,720
but the complexity of your application

00:31:39,659 --> 00:31:44,700
basically just explodes suddenly you

00:31:42,720 --> 00:31:46,409
need to change five files if you want to

00:31:44,700 --> 00:31:48,240
change how something works you need to

00:31:46,409 --> 00:31:50,340
add reducers you need to add actions

00:31:48,240 --> 00:31:52,350
then people are saying you should have

00:31:50,340 --> 00:31:54,090
all of your actions in one file but then

00:31:52,350 --> 00:31:56,700
your files become too big and you start

00:31:54,090 --> 00:31:59,340
changing things into sagas or chunks or

00:31:56,700 --> 00:32:02,429
whatever other things there are but

00:31:59,340 --> 00:32:04,379
basically your codebase becomes really

00:32:02,429 --> 00:32:06,840
difficult to understand whenever you

00:32:04,379 --> 00:32:09,000
change something you suddenly don't know

00:32:06,840 --> 00:32:11,789
everything it's connected to which is

00:32:09,000 --> 00:32:13,860
fine in a way because potentially if the

00:32:11,789 --> 00:32:16,019
abstractions are well done you don't

00:32:13,860 --> 00:32:18,000
want to know everything that's connected

00:32:16,019 --> 00:32:20,940
to your component right or connect it to

00:32:18,000 --> 00:32:23,009
your state you also get this really nice

00:32:20,940 --> 00:32:25,740
separation where you have a state layer

00:32:23,009 --> 00:32:27,840
that handle that lives outside of your

00:32:25,740 --> 00:32:29,460
component tree so that so it becomes

00:32:27,840 --> 00:32:32,009
easy to change to move components around

00:32:29,460 --> 00:32:35,279
you just hook them up to your Redux

00:32:32,009 --> 00:32:37,740
state or to your my back state and it

00:32:35,279 --> 00:32:39,629
kind of just works right it's a pain in

00:32:37,740 --> 00:32:41,639
the ass to set up you have to deal with

00:32:39,629 --> 00:32:43,799
a lot of boilerplate code to get

00:32:41,639 --> 00:32:44,250
everything working and set up and

00:32:43,799 --> 00:32:46,980
running

00:32:44,250 --> 00:32:50,190
when a new junior joins your team they

00:32:46,980 --> 00:32:52,409
probably really struggle with how to

00:32:50,190 --> 00:32:55,200
make anything work here but there's just

00:32:52,409 --> 00:32:57,850
a lot to understand you have a lot of

00:32:55,200 --> 00:32:59,620
complexity and what I think is

00:32:57,850 --> 00:33:01,600
the biggest problem of these libraries

00:32:59,620 --> 00:33:04,930
is that they break the colocation

00:33:01,600 --> 00:33:07,300
principle so suddenly what you're doing

00:33:04,930 --> 00:33:09,190
and what you're displaying or your UI

00:33:07,300 --> 00:33:11,290
and your business logic user

00:33:09,190 --> 00:33:13,750
interactions and all of that are just

00:33:11,290 --> 00:33:17,260
not close together anymore you have to

00:33:13,750 --> 00:33:21,520
keep a lot of context in mind to be able

00:33:17,260 --> 00:33:24,820
to make any change you have to I don't

00:33:21,520 --> 00:33:26,560
know how often you've approached a redux

00:33:24,820 --> 00:33:28,240
or mobile code base that somebody else

00:33:26,560 --> 00:33:30,040
built you weren't the one building it

00:33:28,240 --> 00:33:32,470
but if you don't understand

00:33:30,040 --> 00:33:34,600
the entire system it becomes almost

00:33:32,470 --> 00:33:37,750
impossible to understand how anything

00:33:34,600 --> 00:33:41,410
works I remember walking into a saga

00:33:37,750 --> 00:33:44,890
based into a saga based project once and

00:33:41,410 --> 00:33:48,070
it took me three or four days just to

00:33:44,890 --> 00:33:50,290
barely understand how it works because

00:33:48,070 --> 00:33:52,420
you could click something and a bunch of

00:33:50,290 --> 00:33:54,520
things happened and then a bunch of

00:33:52,420 --> 00:33:57,010
other things changed and I had a bun I

00:33:54,520 --> 00:33:58,960
had a lot of unknown side effects where

00:33:57,010 --> 00:34:00,460
things were really rendering and

00:33:58,960 --> 00:34:04,270
changing that I didn't even know existed

00:34:00,460 --> 00:34:07,210
or I wanted to just change how a button

00:34:04,270 --> 00:34:08,800
works and I changed that I made the made

00:34:07,210 --> 00:34:10,690
that small change in the button and

00:34:08,800 --> 00:34:12,550
suddenly my header started changing and

00:34:10,690 --> 00:34:14,500
I was like what no i didn't i don't want

00:34:12,550 --> 00:34:15,970
my header to change in all in all cases

00:34:14,500 --> 00:34:19,330
maybe i just want to change it in in

00:34:15,970 --> 00:34:20,950
some cases so all of that becomes really

00:34:19,330 --> 00:34:23,860
difficult and means that you have to be

00:34:20,950 --> 00:34:26,379
able to basically hold your your entire

00:34:23,860 --> 00:34:28,960
code base in your mind which is great as

00:34:26,379 --> 00:34:31,030
long as it's a small codebase if you use

00:34:28,960 --> 00:34:32,770
end this principle of splitting up your

00:34:31,030 --> 00:34:35,230
monolith it's great because you can have

00:34:32,770 --> 00:34:36,970
small simple apps each deployed in a

00:34:35,230 --> 00:34:39,460
separate gem stack or wherever you

00:34:36,970 --> 00:34:41,590
deploy them so that kind of helps with

00:34:39,460 --> 00:34:44,560
that complexity but eventually your

00:34:41,590 --> 00:34:47,169
complexity is going to grow I know we

00:34:44,560 --> 00:34:48,820
try to work with micro front-ends and

00:34:47,169 --> 00:34:51,399
that never really went anywhere and was

00:34:48,820 --> 00:34:54,669
a huge failure so what I'm gonna propose

00:34:51,399 --> 00:34:57,640
today is a new way of managing your

00:34:54,669 --> 00:35:00,730
state that mostly solves all of these

00:34:57,640 --> 00:35:02,770
problems and makes your life a lot

00:35:00,730 --> 00:35:05,470
better and I'm calling it the world warm

00:35:02,770 --> 00:35:07,960
call state management because it's based

00:35:05,470 --> 00:35:11,300
on the idea that you have a lot of local

00:35:07,960 --> 00:35:13,250
state combo localized to the smaller

00:35:11,300 --> 00:35:15,050
possible part of your state tree and

00:35:13,250 --> 00:35:16,630
then you have one calls to make

00:35:15,050 --> 00:35:19,040
different parts of your state

00:35:16,630 --> 00:35:21,860
communicate with each other so the

00:35:19,040 --> 00:35:23,570
principle is that when you have state

00:35:21,860 --> 00:35:25,370
that belongs just to a single component

00:35:23,570 --> 00:35:27,380
where just a single component cares

00:35:25,370 --> 00:35:30,530
about that you can just use local state

00:35:27,380 --> 00:35:32,480
with react hooks now it's super easy to

00:35:30,530 --> 00:35:34,550
use local state without too much trouble

00:35:32,480 --> 00:35:36,290
you don't have to deal with the set

00:35:34,550 --> 00:35:38,960
state you still have a set state

00:35:36,290 --> 00:35:40,910
function but it you don't have to build

00:35:38,960 --> 00:35:42,890
a class-based component just to have

00:35:40,910 --> 00:35:45,470
state you can use functional components

00:35:42,890 --> 00:35:47,990
which are in my opinion - or to work

00:35:45,470 --> 00:35:50,060
with and you can use look state locally

00:35:47,990 --> 00:35:52,130
and it's self-contained within the

00:35:50,060 --> 00:35:54,380
component anyone who looks at that

00:35:52,130 --> 00:35:56,060
component can always know everything the

00:35:54,380 --> 00:35:58,130
death component does all of the business

00:35:56,060 --> 00:36:00,020
logic it's using you can then if you

00:35:58,130 --> 00:36:01,460
have different components that work

00:36:00,020 --> 00:36:04,880
tightly together that are really

00:36:01,460 --> 00:36:06,470
actually tightly coupled like well we'll

00:36:04,880 --> 00:36:08,780
do some examples later but let's say you

00:36:06,470 --> 00:36:10,550
have a button and a display component

00:36:08,780 --> 00:36:12,800
next to it that shows how many times

00:36:10,550 --> 00:36:14,660
that button has been clicked you can

00:36:12,800 --> 00:36:16,220
just share state between those two

00:36:14,660 --> 00:36:19,010
components you don't have to go all the

00:36:16,220 --> 00:36:21,050
way around to your global state just to

00:36:19,010 --> 00:36:25,010
change something that it's that's right

00:36:21,050 --> 00:36:28,070
next to you imagine imagine if every

00:36:25,010 --> 00:36:31,040
time you want to ask your coworker to

00:36:28,070 --> 00:36:33,500
help you out with something you would

00:36:31,040 --> 00:36:35,420
have to write a form a formal request

00:36:33,500 --> 00:36:37,400
for help then you would have to pass it

00:36:35,420 --> 00:36:40,160
on to your manager then your manager

00:36:37,400 --> 00:36:41,840
would pass it on to his manager then his

00:36:40,160 --> 00:36:45,040
manager would pass it on to her manager

00:36:41,840 --> 00:36:47,150
and then the CEO would look at that for

00:36:45,040 --> 00:36:50,330
request for help and she would be like

00:36:47,150 --> 00:36:53,060
me yes it does sound likes wizards needs

00:36:50,330 --> 00:36:55,760
needs and his help okay this is good and

00:36:53,060 --> 00:36:58,250
then she would put that into HR and then

00:36:55,760 --> 00:37:00,290
HR would look at it eventually and maybe

00:36:58,250 --> 00:37:02,000
five days later it would come back to nd

00:37:00,290 --> 00:37:03,710
who's sitting right next to you and she

00:37:02,000 --> 00:37:05,150
would say yeah totally you can just

00:37:03,710 --> 00:37:07,040
click that button over there or just

00:37:05,150 --> 00:37:09,170
copy/paste that thing and it's gonna be

00:37:07,040 --> 00:37:11,240
fine so that's that's kind of how we

00:37:09,170 --> 00:37:13,250
work with redux and Moe backs is if you

00:37:11,240 --> 00:37:16,340
go all the way around to do the simplest

00:37:13,250 --> 00:37:18,560
possible things so with the more with

00:37:16,340 --> 00:37:21,200
the one call pattern you get the

00:37:18,560 --> 00:37:22,850
colocation of logic so anyone who looks

00:37:21,200 --> 00:37:23,330
at the component can always understand

00:37:22,850 --> 00:37:27,050
that

00:37:23,330 --> 00:37:28,640
you minimize you as a as the result you

00:37:27,050 --> 00:37:30,710
also minimize the amount of code that

00:37:28,640 --> 00:37:32,840
needs to be understood because you'll

00:37:30,710 --> 00:37:35,690
see with some react hooks you can then

00:37:32,840 --> 00:37:38,600
make it very easy to share state between

00:37:35,690 --> 00:37:41,060
components without introducing a lot of

00:37:38,600 --> 00:37:43,400
extra code you're not using any

00:37:41,060 --> 00:37:45,770
libraries which is great for performance

00:37:43,400 --> 00:37:47,660
because it means you're not downloading

00:37:45,770 --> 00:37:50,360
extra libraries you're not compiling

00:37:47,660 --> 00:37:52,550
extra libraries you're just using every

00:37:50,360 --> 00:37:55,580
stuff that comes with react already and

00:37:52,550 --> 00:37:57,560
at least in my experience this scale

00:37:55,580 --> 00:37:59,750
this same approach scales pretty well

00:37:57,560 --> 00:38:03,380
from very small apps that you're

00:37:59,750 --> 00:38:05,420
building is a tiny example to huge apps

00:38:03,380 --> 00:38:07,340
that need that have a lot of different

00:38:05,420 --> 00:38:10,270
layers or a lot of different segments of

00:38:07,340 --> 00:38:14,030
the app that needs to work together so

00:38:10,270 --> 00:38:16,460
rather than talk to you and talk your

00:38:14,030 --> 00:38:19,010
ear off about the theory I figured I

00:38:16,460 --> 00:38:22,400
would just show you how this works if we

00:38:19,010 --> 00:38:25,250
go to this code sandbox over here so you

00:38:22,400 --> 00:38:27,980
should still see my screen and I wanna

00:38:25,250 --> 00:38:30,320
I'm gonna show you how the wormhole

00:38:27,980 --> 00:38:32,510
state management pattern evolves from

00:38:30,320 --> 00:38:36,020
the smallest example to something that

00:38:32,510 --> 00:38:37,910
is more like a bigger app using code and

00:38:36,020 --> 00:38:40,340
a bit of life coding I haven't prepared

00:38:37,910 --> 00:38:41,720
a whole lot in advance because you don't

00:38:40,340 --> 00:38:43,940
need a whole lot in the end that's kind

00:38:41,720 --> 00:38:49,280
of the point of this pattern is that

00:38:43,940 --> 00:38:51,860
it's simple and easy to understand you

00:38:49,280 --> 00:38:53,750
will however need to be relatively

00:38:51,860 --> 00:38:55,730
familiar with hooks because if you're

00:38:53,750 --> 00:38:58,250
not then it doesn't work so let's say we

00:38:55,730 --> 00:39:00,860
have we have this code sign box over

00:38:58,250 --> 00:39:03,890
here and we want to make this plus one

00:39:00,860 --> 00:39:05,840
button that is a simple counter I know

00:39:03,890 --> 00:39:07,520
that this is a contrived example that's

00:39:05,840 --> 00:39:09,650
kind of the point is that we don't have

00:39:07,520 --> 00:39:11,360
to worry too much about the actual logic

00:39:09,650 --> 00:39:13,880
behind it I can let me show you how I

00:39:11,360 --> 00:39:16,850
use this in a more serious application

00:39:13,880 --> 00:39:19,010
but the basic idea is that if you have a

00:39:16,850 --> 00:39:21,590
counter component it doesn't really need

00:39:19,010 --> 00:39:25,100
a whole lot you can say that you have a

00:39:21,590 --> 00:39:28,420
count count and a set count function you

00:39:25,100 --> 00:39:31,060
take those from States you can use a

00:39:28,420 --> 00:39:34,060
starting prop to set the starting value

00:39:31,060 --> 00:39:37,110
then you create a plus one function

00:39:34,060 --> 00:39:39,960
which calls set count

00:39:37,110 --> 00:39:42,570
the current count and returns count plus

00:39:39,960 --> 00:39:46,140
one so very simple function pretty

00:39:42,570 --> 00:39:49,650
simple logic we when we click the button

00:39:46,140 --> 00:39:52,470
we're going to call plus one and let's

00:39:49,650 --> 00:39:57,000
also display the current count like this

00:39:52,470 --> 00:39:59,130
I'm gonna add a breakpoint here but that

00:39:57,000 --> 00:40:01,890
so now when I click on this you see the

00:39:59,130 --> 00:40:04,230
count goes down I have am using

00:40:01,890 --> 00:40:07,320
completely local state all of my logic

00:40:04,230 --> 00:40:09,270
is contained in the component and it's

00:40:07,320 --> 00:40:11,220
still a functional component and just

00:40:09,270 --> 00:40:14,160
set saying okay count is now a state

00:40:11,220 --> 00:40:17,780
whenever I call the set count function

00:40:14,160 --> 00:40:20,520
it get it takes as its first argument a

00:40:17,780 --> 00:40:22,140
it takes it takes a function as an

00:40:20,520 --> 00:40:24,300
argument so that we can make it more

00:40:22,140 --> 00:40:26,190
dynamic Rick the current count from

00:40:24,300 --> 00:40:28,110
state and updates the state which then

00:40:26,190 --> 00:40:30,120
triggers already render of the counter

00:40:28,110 --> 00:40:32,120
component so we now have a counter

00:40:30,120 --> 00:40:34,470
component that works completely

00:40:32,120 --> 00:40:36,630
independently we can make multiple of

00:40:34,470 --> 00:40:39,210
them and it's still gonna work might

00:40:36,630 --> 00:40:42,990
need to add me let's turn this into a

00:40:39,210 --> 00:40:45,600
div so they don't overlap so we now have

00:40:42,990 --> 00:40:48,030
to counter components that have separate

00:40:45,600 --> 00:40:49,800
pieces of state and you can render this

00:40:48,030 --> 00:40:52,350
anywhere and it's completely independent

00:40:49,800 --> 00:40:54,300
and it always know what's HAP happening

00:40:52,350 --> 00:40:58,590
let's say this one needs to start from

00:40:54,300 --> 00:41:00,420
five loads OC Code sandbox is nice

00:40:58,590 --> 00:41:02,970
enough to actually maintain state

00:41:00,420 --> 00:41:06,750
between reloads so that worked nice as

00:41:02,970 --> 00:41:08,910
well so you see that hot reloading works

00:41:06,750 --> 00:41:12,090
with this approach and all of that stuff

00:41:08,910 --> 00:41:15,270
now let's say that the each count

00:41:12,090 --> 00:41:17,880
component needs to have a separate

00:41:15,270 --> 00:41:20,070
display component and that display

00:41:17,880 --> 00:41:21,660
component could be further down into

00:41:20,070 --> 00:41:23,910
three but they're two they're basically

00:41:21,660 --> 00:41:27,320
two components that work together so

00:41:23,910 --> 00:41:31,190
we're gonna say if it's a display and

00:41:27,320 --> 00:41:36,480
it's gonna get count as a normal prop

00:41:31,190 --> 00:41:39,840
but then say consti display is component

00:41:36,480 --> 00:41:42,420
that gets some count and it returns a

00:41:39,840 --> 00:41:45,270
function that's going to render

00:41:42,420 --> 00:41:47,940
paragraph which is going to show that

00:41:45,270 --> 00:41:50,640
count now no longer need the breakpoint

00:41:47,940 --> 00:41:52,259
now I know this still looks

00:41:50,640 --> 00:41:55,109
this still looks kind of lame and like a

00:41:52,259 --> 00:41:59,789
stupid example but imagine if this were

00:41:55,109 --> 00:42:04,200
three components deep or if it was like

00:41:59,789 --> 00:42:06,930
this could be I don't know a widget on

00:42:04,200 --> 00:42:08,730
your page somewhere that has something

00:42:06,930 --> 00:42:10,980
where five to five components need to

00:42:08,730 --> 00:42:12,720
work closely together we can also say

00:42:10,980 --> 00:42:14,910
that okay you know what might these

00:42:12,720 --> 00:42:17,609
default buttons are kind of lame let's

00:42:14,910 --> 00:42:20,249
make a red button component that looks

00:42:17,609 --> 00:42:23,460
better so we create a red button

00:42:20,249 --> 00:42:29,819
component and this one is going to get

00:42:23,460 --> 00:42:33,150
the set count callback and we return a

00:42:29,819 --> 00:42:36,329
button that has let's research plus one

00:42:33,150 --> 00:42:40,829
so let's put in plus one and it's on

00:42:36,329 --> 00:42:44,069
click and let's give it a background red

00:42:40,829 --> 00:42:47,489
so that you can see it's red button so

00:42:44,069 --> 00:42:53,489
we now have a heart we need to actually

00:42:47,489 --> 00:42:55,440
pass it in nice when when Eddie suddenly

00:42:53,489 --> 00:42:58,259
starts reminding us that we forgot stuff

00:42:55,440 --> 00:43:00,299
so we have we still have a pretty simple

00:42:58,259 --> 00:43:02,759
approach where we have a button that

00:43:00,299 --> 00:43:04,710
does counting and we have a display and

00:43:02,759 --> 00:43:07,039
we are doing this is basically the old

00:43:04,710 --> 00:43:10,710
prop drilling approach where we have

00:43:07,039 --> 00:43:13,289
localized state that is shared between

00:43:10,710 --> 00:43:15,779
two components that work very closely

00:43:13,289 --> 00:43:17,730
together this is great for when you need

00:43:15,779 --> 00:43:21,509
to build widgets that are relatively

00:43:17,730 --> 00:43:23,970
self-contained or widgets that are I'm

00:43:21,509 --> 00:43:26,670
having trouble coming up with a fun

00:43:23,970 --> 00:43:29,279
example but basically imagine if you had

00:43:26,670 --> 00:43:31,380
a header that needs to share some state

00:43:29,279 --> 00:43:33,630
between just a couple of components in

00:43:31,380 --> 00:43:37,349
the header itself you could do that with

00:43:33,630 --> 00:43:40,019
this approach now what if we want to

00:43:37,349 --> 00:43:42,930
contain connect both counters together

00:43:40,019 --> 00:43:45,690
so that they are counting with the same

00:43:42,930 --> 00:43:48,269
the same global state so now we have

00:43:45,690 --> 00:43:50,160
components that live far apart in the

00:43:48,269 --> 00:43:53,249
state tree and they need to work

00:43:50,160 --> 00:43:55,289
together to manage global state we could

00:43:53,249 --> 00:43:58,049
go with redux and do a bunch of stuff

00:43:55,289 --> 00:44:00,569
but instead what I prepared was a

00:43:58,049 --> 00:44:04,020
wormhole context provider so we're now

00:44:00,569 --> 00:44:05,610
going to create a wormhole that

00:44:04,020 --> 00:44:07,740
going to share state between two

00:44:05,610 --> 00:44:10,560
components that are very far apart and

00:44:07,740 --> 00:44:13,940
these two components will have an

00:44:10,560 --> 00:44:16,170
indirect way of communicating without us

00:44:13,940 --> 00:44:19,770
we're going to kind of were kind of

00:44:16,170 --> 00:44:23,490
hoisting state but not too much they do

00:44:19,770 --> 00:44:33,150
here okay so we're going to import the

00:44:23,490 --> 00:44:40,170
wormhole context provider from doesn't

00:44:33,150 --> 00:44:44,580
it autocomplete and the wormhole context

00:44:40,170 --> 00:44:46,890
provider is a react component that does

00:44:44,580 --> 00:44:48,840
a few things with its own local state to

00:44:46,890 --> 00:44:51,180
make the state shareable and I'll show

00:44:48,840 --> 00:44:54,600
you how that works so we take these two

00:44:51,180 --> 00:44:58,590
and we render them inside the wormhole

00:44:54,600 --> 00:45:01,410
context provider that so they're now

00:44:58,590 --> 00:45:03,990
both children of the same global

00:45:01,410 --> 00:45:06,720
provider this is similar to your redux

00:45:03,990 --> 00:45:09,450
provider your mo backs provider except

00:45:06,720 --> 00:45:13,590
we're going to do a few tricks to make

00:45:09,450 --> 00:45:16,740
them easier to use let's see so we have

00:45:13,590 --> 00:45:20,250
the wormhole contact provider now we can

00:45:16,740 --> 00:45:23,690
go into our counter and instead of using

00:45:20,250 --> 00:45:26,610
state like this we're going to stay

00:45:23,690 --> 00:45:28,860
we're going to take state from our

00:45:26,610 --> 00:45:32,670
context and we're going to take a little

00:45:28,860 --> 00:45:34,380
function i called set shared count so

00:45:32,670 --> 00:45:39,120
set your count and we say in this

00:45:34,380 --> 00:45:42,690
context it's going to be one context

00:45:39,120 --> 00:45:45,750
which we also need to port so we import

00:45:42,690 --> 00:45:47,970
one call context from here and i'll

00:45:45,750 --> 00:45:51,780
explain a little bit how this works so

00:45:47,970 --> 00:45:56,880
now we have display count which is going

00:45:51,780 --> 00:45:59,790
to display state dot shared count this

00:45:56,880 --> 00:46:01,530
is where if you're using what's it

00:45:59,790 --> 00:46:03,090
called if you're using typescript this

00:46:01,530 --> 00:46:05,670
makes it easier because it gives you

00:46:03,090 --> 00:46:08,400
autocomplete on all of these states and

00:46:05,670 --> 00:46:11,700
stuff I didn't want to deal with that

00:46:08,400 --> 00:46:14,310
because I I just felt like it was too

00:46:11,700 --> 00:46:18,060
much for this example and now instead of

00:46:14,310 --> 00:46:21,570
set count we're going to set share count

00:46:18,060 --> 00:46:28,740
and we're going to just set it to state

00:46:21,570 --> 00:46:32,310
dollar shirt state shirt how did I

00:46:28,740 --> 00:46:35,370
actually call it plus one no it's not

00:46:32,310 --> 00:46:39,060
kept we take the new state dog shirt

00:46:35,370 --> 00:46:41,700
count plus one and now in theory this

00:46:39,060 --> 00:46:45,060
should just magically work as long as we

00:46:41,700 --> 00:46:47,220
import use context from react let's see

00:46:45,060 --> 00:46:50,250
so you see now I'm clicking one button

00:46:47,220 --> 00:46:52,470
and enter both updating yay super

00:46:50,250 --> 00:46:54,450
awesome right and we'll go one step

00:46:52,470 --> 00:46:57,690
further and make this even easier to use

00:46:54,450 --> 00:47:01,050
so we now have two buttons that are

00:46:57,690 --> 00:47:03,600
connected via a context provider so the

00:47:01,050 --> 00:47:05,580
car the reacted context kind of works as

00:47:03,600 --> 00:47:08,220
a wormhole in the background to connect

00:47:05,580 --> 00:47:11,190
to components that are in theory very

00:47:08,220 --> 00:47:15,030
far apart how the contact is does that

00:47:11,190 --> 00:47:18,090
is that we are creating a context called

00:47:15,030 --> 00:47:19,920
wormhole context this will in practice

00:47:18,090 --> 00:47:22,290
you would probably have named this

00:47:19,920 --> 00:47:26,280
differently for different sections of

00:47:22,290 --> 00:47:28,170
your application I forget what those

00:47:26,280 --> 00:47:30,570
would be called in redux because it's

00:47:28,170 --> 00:47:33,390
been around two years since I seriously

00:47:30,570 --> 00:47:35,490
used redux last but the idea is that you

00:47:33,390 --> 00:47:39,930
create this context you put in some

00:47:35,490 --> 00:47:41,820
state and you put in your actions or

00:47:39,930 --> 00:47:43,890
your functions that you use to

00:47:41,820 --> 00:47:46,650
manipulate that's it we're going to make

00:47:43,890 --> 00:47:48,150
that even better in a little bit so then

00:47:46,650 --> 00:47:52,350
then you create a wormhole context

00:47:48,150 --> 00:47:56,910
provider functional component which has

00:47:52,350 --> 00:48:00,510
a state using just local state which is

00:47:56,910 --> 00:48:02,700
a state or with a single variable but

00:48:00,510 --> 00:48:04,890
that variable is an object so we are

00:48:02,700 --> 00:48:08,700
able to have both shared count and you

00:48:04,890 --> 00:48:11,490
can add let's say random string which

00:48:08,700 --> 00:48:14,490
sells random and I'll show you how that

00:48:11,490 --> 00:48:17,340
works later or actually not gonna show

00:48:14,490 --> 00:48:20,940
now so if we now have random string and

00:48:17,340 --> 00:48:25,140
we want to display that over here we can

00:48:20,940 --> 00:48:27,360
say state dot random string and it

00:48:25,140 --> 00:48:30,420
should show up right next to us

00:48:27,360 --> 00:48:31,410
let's see I need to load yeah so we now

00:48:30,420 --> 00:48:33,960
have

00:48:31,410 --> 00:48:36,750
I'm string so basically we're using a

00:48:33,960 --> 00:48:38,990
single piece of state but that state can

00:48:36,750 --> 00:48:42,000
contain an object which then has a

00:48:38,990 --> 00:48:43,650
richer more complex piece of state that

00:48:42,000 --> 00:48:46,049
you did you actually use for your

00:48:43,650 --> 00:48:49,349
application so we have that one called

00:48:46,049 --> 00:48:52,619
context we then we have our initial

00:48:49,349 --> 00:48:54,690
state we have our state state and we

00:48:52,619 --> 00:48:58,380
have the context value which is another

00:48:54,690 --> 00:49:01,440
piece of you state from react that holds

00:48:58,380 --> 00:49:03,720
our application state and help any

00:49:01,440 --> 00:49:06,059
helper methods that we need so right now

00:49:03,720 --> 00:49:08,789
we just have set shared count you could

00:49:06,059 --> 00:49:10,890
then add more actions here or I'll show

00:49:08,789 --> 00:49:14,099
you in a bit you can use reducer to

00:49:10,890 --> 00:49:19,500
clean up this part as well then to avoid

00:49:14,099 --> 00:49:21,630
having multiple rear Enders whenever so

00:49:19,500 --> 00:49:26,059
to avoid having multiple rear Enders we

00:49:21,630 --> 00:49:30,030
then use a use effect to ensure that our

00:49:26,059 --> 00:49:32,280
component only rear Enders when we when

00:49:30,030 --> 00:49:34,530
our internal state changes so not when

00:49:32,280 --> 00:49:36,630
the context value changes but when the

00:49:34,530 --> 00:49:39,690
state's stored inside the context value

00:49:36,630 --> 00:49:41,549
in the object changes then we render in

00:49:39,690 --> 00:49:43,559
Warhawk context provider with our

00:49:41,549 --> 00:49:47,339
context value and all of its children

00:49:43,559 --> 00:49:51,240
which gives us the nested the nested

00:49:47,339 --> 00:49:53,970
stuff below so what's happening now is

00:49:51,240 --> 00:49:57,299
that when Mike when we call set shared

00:49:53,970 --> 00:50:00,900
count that that goes into react

00:49:57,299 --> 00:50:05,430
context via D by the provider goes into

00:50:00,900 --> 00:50:09,359
context value now let me change how I'm

00:50:05,430 --> 00:50:11,670
explaining that so when we now render

00:50:09,359 --> 00:50:14,039
something we take the wormhole context

00:50:11,670 --> 00:50:17,369
out of our react context and we take its

00:50:14,039 --> 00:50:20,039
state and a setter or an a helper method

00:50:17,369 --> 00:50:23,130
when we call that helper method it's

00:50:20,039 --> 00:50:26,579
actually being passed in from our

00:50:23,130 --> 00:50:28,829
context provider which then calls this

00:50:26,579 --> 00:50:31,980
function that we defined here that

00:50:28,829 --> 00:50:36,450
function calls set state and updates the

00:50:31,980 --> 00:50:38,940
state which then triggers a rerender via

00:50:36,450 --> 00:50:40,740
this effect of our entire application of

00:50:38,940 --> 00:50:43,030
everything that depends on that stage

00:50:40,740 --> 00:50:44,890
now this isn't this but

00:50:43,030 --> 00:50:47,170
actually isn't as performant as

00:50:44,890 --> 00:50:48,820
something like mo bags because it

00:50:47,170 --> 00:50:51,280
doesn't keep track of what's actually

00:50:48,820 --> 00:50:53,170
listening to which parts of state but in

00:50:51,280 --> 00:50:55,720
practice it usually works well enough if

00:50:53,170 --> 00:50:57,880
you're using Redux this I think they say

00:50:55,720 --> 00:50:59,890
actually I haven't benchmarked it but

00:50:57,880 --> 00:51:03,340
this should be about as performance in

00:50:59,890 --> 00:51:05,470
swedux so we have that now what we can

00:51:03,340 --> 00:51:07,930
do to make this even easier to use

00:51:05,470 --> 00:51:10,960
here you see we had all of this stuff

00:51:07,930 --> 00:51:13,420
right so we have a have a context and we

00:51:10,960 --> 00:51:16,030
have something that lets us manipulate

00:51:13,420 --> 00:51:17,260
that context and it's kind of nice it's

00:51:16,030 --> 00:51:19,390
nice that we have it in the counter

00:51:17,260 --> 00:51:22,120
component but we can actually make it

00:51:19,390 --> 00:51:24,820
even better let's change let's turn this

00:51:22,120 --> 00:51:29,980
into a custom component so we're going

00:51:24,820 --> 00:51:34,090
to say Const use shared counter you've

00:51:29,980 --> 00:51:35,860
shared count which is going to be a I'll

00:51:34,090 --> 00:51:40,120
just call it the function function use

00:51:35,860 --> 00:51:44,650
share count which doesn't really take

00:51:40,120 --> 00:51:48,010
anything and it takes it takes stuff out

00:51:44,650 --> 00:51:52,180
of context creates a +1 function and

00:51:48,010 --> 00:51:55,480
it's going to return our current state

00:51:52,180 --> 00:51:59,350
or shared count and D plus 1 function

00:51:55,480 --> 00:52:03,700
actually easier to do it this way to

00:51:59,350 --> 00:52:07,510
share count and +1 function so we now

00:52:03,700 --> 00:52:08,380
have a custom hook is this complaining

00:52:07,510 --> 00:52:11,020
ok it's fine

00:52:08,380 --> 00:52:14,110
so we have a custom cook hook called use

00:52:11,020 --> 00:52:16,960
shared count which talks to our react

00:52:14,110 --> 00:52:19,600
context creates the wormhole creates if

00:52:16,960 --> 00:52:22,930
and easier to use function that just

00:52:19,600 --> 00:52:26,230
does +1 and export and returns both of

00:52:22,930 --> 00:52:29,860
those as the count and s +1 so now when

00:52:26,230 --> 00:52:35,680
we go into the counter here we can say

00:52:29,860 --> 00:52:38,640
cost plus 1 equals nil shared count that

00:52:35,680 --> 00:52:41,470
will just work and then display can be

00:52:38,640 --> 00:52:44,320
let's turn that into a display count

00:52:41,470 --> 00:52:47,320
component you can display count which no

00:52:44,320 --> 00:52:51,190
longer needs to take any props instead

00:52:47,320 --> 00:52:55,140
what it can do is say some constant

00:52:51,190 --> 00:53:01,570
shared count equals use

00:52:55,140 --> 00:53:04,630
so it should now just work magically so

00:53:01,570 --> 00:53:07,720
let's see if it does yep so we now

00:53:04,630 --> 00:53:09,640
created a hook that we can use in any

00:53:07,720 --> 00:53:12,130
component no matter where it is in our

00:53:09,640 --> 00:53:15,430
component tree that independently

00:53:12,130 --> 00:53:17,920
connects to our global state or whatever

00:53:15,430 --> 00:53:20,110
shared state we have and uses that state

00:53:17,920 --> 00:53:22,780
work just locally in the same component

00:53:20,110 --> 00:53:29,650
so now if you're if you imagine how this

00:53:22,780 --> 00:53:31,630
works from a what did I do out here so

00:53:29,650 --> 00:53:34,540
now if you imagine how this works from

00:53:31,630 --> 00:53:37,840
the perspective of a junior that's

00:53:34,540 --> 00:53:39,340
joining your team or even you who hasn't

00:53:37,840 --> 00:53:41,500
been working on a part of the code base

00:53:39,340 --> 00:53:43,360
for six months or whatever or you've

00:53:41,500 --> 00:53:45,520
just forgotten what you're doing or how

00:53:43,360 --> 00:53:47,770
it works you can come to the counter

00:53:45,520 --> 00:53:50,380
component and you say okay it's using

00:53:47,770 --> 00:53:52,270
the shared count which is probably some

00:53:50,380 --> 00:53:55,570
context and we're just taking out the

00:53:52,270 --> 00:53:58,480
plus one the plus one function and we

00:53:55,570 --> 00:54:01,420
call it in the red button on click cool

00:53:58,480 --> 00:54:06,070
we can even completely remove this and

00:54:01,420 --> 00:54:09,850
call this the plus button so we change

00:54:06,070 --> 00:54:14,890
this to the plus button we then move

00:54:09,850 --> 00:54:18,460
this over here so we're using the shared

00:54:14,890 --> 00:54:21,490
count hook directly we call plus one and

00:54:18,460 --> 00:54:24,270
you see it's still gonna work so what

00:54:21,490 --> 00:54:26,710
what you just saw is how easy it is to

00:54:24,270 --> 00:54:29,620
refactor your components it's easy to

00:54:26,710 --> 00:54:31,570
move using shared State to a different

00:54:29,620 --> 00:54:33,900
to a completely different component all

00:54:31,570 --> 00:54:35,890
of this component our components are

00:54:33,900 --> 00:54:37,630
relatively independent there are no

00:54:35,890 --> 00:54:39,130
longer tightly coupled they can always

00:54:37,630 --> 00:54:41,890
get your own State

00:54:39,130 --> 00:54:43,630
from the ship from the wormhole and they

00:54:41,890 --> 00:54:45,760
can always use that state to do whatever

00:54:43,630 --> 00:54:48,940
they need with it which is really nice

00:54:45,760 --> 00:54:50,740
because you can then it makes it easier

00:54:48,940 --> 00:54:52,660
to move things around makes it easier to

00:54:50,740 --> 00:54:54,790
refactor it makes easier to say okay

00:54:52,660 --> 00:54:56,800
this is the plus the plus button just

00:54:54,790 --> 00:54:59,710
takes plus one from user that counts and

00:54:56,800 --> 00:55:02,200
the stuff with that and we didn't have

00:54:59,710 --> 00:55:06,970
to use any libraries to achieve this we

00:55:02,200 --> 00:55:09,819
just used a bunch of default we

00:55:06,970 --> 00:55:13,150
I can't okay we used a bunch of default

00:55:09,819 --> 00:55:16,329
react machinery and it all kind of just

00:55:13,150 --> 00:55:20,650
works too you can make this even simpler

00:55:16,329 --> 00:55:22,960
if you go to go here and instead of your

00:55:20,650 --> 00:55:24,670
state you can then use reducer I'm not

00:55:22,960 --> 00:55:27,310
going to show you how to do that because

00:55:24,670 --> 00:55:35,520
I think it would take a little too long

00:55:27,310 --> 00:55:39,069
so there is more flexibility and then

00:55:35,520 --> 00:55:42,579
here instead of a reducer you would then

00:55:39,069 --> 00:55:46,000
just pass any dispatch function on your

00:55:42,579 --> 00:55:47,440
reducer and you then get really calm and

00:55:46,000 --> 00:55:50,079
then you get basically the same

00:55:47,440 --> 00:55:52,180
complexity but not the same complexity

00:55:50,079 --> 00:55:54,550
but you get the same power that you have

00:55:52,180 --> 00:55:57,460
with redux where you can call this patch

00:55:54,550 --> 00:55:59,680
on your reducer which then triggers the

00:55:57,460 --> 00:56:03,730
same stuff here

00:55:59,680 --> 00:56:06,640
the same stuff for your like for the

00:56:03,730 --> 00:56:08,440
rear Enders and all of that kind of a

00:56:06,640 --> 00:56:11,619
kind of trailed off there I'm sorry but

00:56:08,440 --> 00:56:13,359
the idea is that if you like reducers or

00:56:11,619 --> 00:56:15,700
if you have complex state that needs to

00:56:13,359 --> 00:56:18,640
work together you can use reducer and

00:56:15,700 --> 00:56:21,310
you still get all of the same ease of

00:56:18,640 --> 00:56:24,130
use you get the same flexibility you get

00:56:21,310 --> 00:56:26,079
the same collocation of your logic and

00:56:24,130 --> 00:56:29,770
your what you're actually using that

00:56:26,079 --> 00:56:32,260
logic and you can still you can still

00:56:29,770 --> 00:56:34,540
have all of the power that you need one

00:56:32,260 --> 00:56:39,069
other thing that I wanted to mention was

00:56:34,540 --> 00:56:41,230
that with this pattern I know that in

00:56:39,069 --> 00:56:44,619
redux and mo backs and a couple of those

00:56:41,230 --> 00:56:46,750
others it becomes very complicated what

00:56:44,619 --> 00:56:50,440
to do when you have asynchronous actions

00:56:46,750 --> 00:56:52,630
with with this approach it doesn't have

00:56:50,440 --> 00:56:55,690
to be complicated because this can be an

00:56:52,630 --> 00:56:58,569
async function so you now have an async

00:56:55,690 --> 00:57:00,970
function that just works and calls set

00:56:58,569 --> 00:57:03,040
state whenever it's ready and react with

00:57:00,970 --> 00:57:04,990
the update and rerender your stuff and

00:57:03,040 --> 00:57:08,230
it's gonna be fine you don't need to you

00:57:04,990 --> 00:57:10,150
don't need any special knowledge of how

00:57:08,230 --> 00:57:11,980
things work it still just functions that

00:57:10,150 --> 00:57:14,650
use functions working together functions

00:57:11,980 --> 00:57:20,330
and you can insert asynchronous stuff

00:57:14,650 --> 00:57:22,070
wherever you want so that was

00:57:20,330 --> 00:57:25,940
that was what I had to show you today I

00:57:22,070 --> 00:57:28,370
know it's kind of a pretty simple

00:57:25,940 --> 00:57:32,510
example and I couldn't drive a counter

00:57:28,370 --> 00:57:34,130
as much as I could to make it to make it

00:57:32,510 --> 00:57:36,200
understandable where I'm going at with

00:57:34,130 --> 00:57:38,030
the wormhole state management pattern

00:57:36,200 --> 00:57:41,120
but still understandable so we're not

00:57:38,030 --> 00:57:44,660
getting into the weeds of application

00:57:41,120 --> 00:57:47,060
logic so yeah I hope you enjoyed the

00:57:44,660 --> 00:57:49,340
talk and I hope that this gives you

00:57:47,060 --> 00:57:51,440
useful ideas for how to approach stuff I

00:57:49,340 --> 00:57:53,960
know I'm pretty sure you can use this

00:57:51,440 --> 00:57:55,940
with redux or in any existing react

00:57:53,960 --> 00:57:57,860
application you can just start using it

00:57:55,940 --> 00:57:59,690
and it's gonna be fine I know it's not a

00:57:57,860 --> 00:58:02,990
library it's just a pattern which I

00:57:59,690 --> 00:58:06,500
prefer because it reduces dependencies

00:58:02,990 --> 00:58:08,960
and helps you it's more about how to

00:58:06,500 --> 00:58:10,160
think about state management versus use

00:58:08,960 --> 00:58:12,290
this library and it's gonna do

00:58:10,160 --> 00:58:14,630
everything for you which I prefer and

00:58:12,290 --> 00:58:17,140
yeah so if there's any questions I'm

00:58:14,630 --> 00:58:24,980
around otherwise you can hit me up on

00:58:17,140 --> 00:58:30,230
Twitter later and yeah that's it I will

00:58:24,980 --> 00:58:33,860
start my video and yeah so let's go for

00:58:30,230 --> 00:58:38,390
it first question what are the best

00:58:33,860 --> 00:58:41,270
small steps and sides I can start

00:58:38,390 --> 00:58:43,910
learning react fast I have never used it

00:58:41,270 --> 00:58:47,810
but I use Jas and how many years have

00:58:43,910 --> 00:58:51,770
you been coding oh okay let me just make

00:58:47,810 --> 00:58:56,630
sure that my camera works there we go I

00:58:51,770 --> 00:59:00,490
have to change my battery so yeah I've

00:58:56,630 --> 00:59:04,300
been coding for a really long time like

00:59:00,490 --> 00:59:06,980
22 years now so it's been a while and

00:59:04,300 --> 00:59:09,080
what I would suggest for learning react

00:59:06,980 --> 00:59:11,450
fast is to actually just go through the

00:59:09,080 --> 00:59:14,450
dogs the documentation is really good

00:59:11,450 --> 00:59:17,690
these days and they did a great job of

00:59:14,450 --> 00:59:20,270
starting with small examples and going

00:59:17,690 --> 00:59:22,460
from there you can also find there's a

00:59:20,270 --> 00:59:24,760
lot of articles and blogs about this

00:59:22,460 --> 00:59:27,650
stuff online

00:59:24,760 --> 00:59:29,570
yeah I think if you look for react for

00:59:27,650 --> 00:59:31,070
beginners there's going to be a lot of

00:59:29,570 --> 00:59:33,829
really good information out there I

00:59:31,070 --> 00:59:36,259
don't have any that I know of

00:59:33,829 --> 00:59:38,299
from the top of my head and just build

00:59:36,259 --> 00:59:40,309
stuff the more stuff you built the more

00:59:38,299 --> 00:59:43,039
you're going to get used to react and

00:59:40,309 --> 00:59:45,109
how it works and I think that now that

00:59:43,039 --> 00:59:51,920
we have hooks it's become a lot easier

00:59:45,109 --> 00:59:52,549
to get started then it used to be thank

00:59:51,920 --> 00:59:55,400
you

00:59:52,549 --> 00:59:59,329
the second question is what do you think

00:59:55,400 --> 01:00:01,190
about the recoil Andy I honestly I just

00:59:59,329 --> 01:00:04,069
put it into a Google and this is the

01:00:01,190 --> 01:00:06,200
first time I have heard about it it's

01:00:04,069 --> 01:00:10,309
state management library weather what

01:00:06,200 --> 01:00:12,799
about these wizards I've I haven't had a

01:00:10,309 --> 01:00:14,569
chance to play with recoil yet so I

01:00:12,799 --> 01:00:17,839
can't really speak much about it it

01:00:14,569 --> 01:00:19,849
seems to be something that Facebook

01:00:17,839 --> 01:00:23,630
invented to solve their own problems

01:00:19,849 --> 01:00:25,609
primarily and one of the things I would

01:00:23,630 --> 01:00:29,869
urge you to consider before you jump

01:00:25,609 --> 01:00:32,779
into recoil is do I have 50,000 plus

01:00:29,869 --> 01:00:35,869
components like Facebook and a thousand

01:00:32,779 --> 01:00:38,180
developers working on my codebase if you

01:00:35,869 --> 01:00:39,650
don't you might not have the same

01:00:38,180 --> 01:00:41,660
problems that they were solving with

01:00:39,650 --> 01:00:43,459
recoil if you do that it's probably

01:00:41,660 --> 01:00:48,289
perfect for you and you should already

01:00:43,459 --> 01:00:52,459
be thinking about migrating great answer

01:00:48,289 --> 01:00:55,039
I have one question myself so most of

01:00:52,459 --> 01:00:57,739
the time the pattern with Redux is that

01:00:55,039 --> 01:01:00,890
between your components and the store

01:00:57,739 --> 01:01:04,069
you put some layer like selectors for

01:01:00,890 --> 01:01:08,779
example just to compute the values over

01:01:04,069 --> 01:01:12,529
the state so without need to recompute

01:01:08,779 --> 01:01:14,959
it when it's not necessary so where

01:01:12,529 --> 01:01:15,949
would you put some kind of heavy logic

01:01:14,959 --> 01:01:19,339
for example

01:01:15,949 --> 01:01:21,199
sososo tasks which are taking a lot of

01:01:19,339 --> 01:01:24,199
time how do you memorize it

01:01:21,199 --> 01:01:27,619
how would you extend your solution with

01:01:24,199 --> 01:01:30,769
a great question let me think a little

01:01:27,619 --> 01:01:32,539
bit so I've done relatively complex

01:01:30,769 --> 01:01:36,400
stuff with this pattern and I haven't

01:01:32,539 --> 01:01:40,190
needed selectors the main thing is that

01:01:36,400 --> 01:01:42,259
if you make your context small enough

01:01:40,190 --> 01:01:46,069
and I see that that's a question in Q&A

01:01:42,259 --> 01:01:47,869
as well is you can use multiple contexts

01:01:46,069 --> 01:01:50,660
I would actually avoid having a

01:01:47,869 --> 01:01:53,390
single context for all of my application

01:01:50,660 --> 01:01:56,180
state I would try to have contacts that

01:01:53,390 --> 01:01:58,009
are very localized like a special

01:01:56,180 --> 01:02:00,319
context just for authentication a

01:01:58,009 --> 01:02:03,079
special context just for your shopping

01:02:00,319 --> 01:02:06,079
cart stuff like that then once you have

01:02:03,079 --> 01:02:08,150
those context it becomes easier to make

01:02:06,079 --> 01:02:10,009
helper functions on top of it because

01:02:08,150 --> 01:02:13,099
they don't have to be that complicated

01:02:10,009 --> 01:02:16,190
I would put them in the link we made a

01:02:13,099 --> 01:02:18,740
use shirt count function that's where

01:02:16,190 --> 01:02:20,029
that's where I would put those I guess

01:02:18,740 --> 01:02:22,880
what you would call them are selectors

01:02:20,029 --> 01:02:24,890
so it export it returns a function that

01:02:22,880 --> 01:02:27,799
you can then use to make it easier to

01:02:24,890 --> 01:02:31,190
talk to this store and honestly if the

01:02:27,799 --> 01:02:33,589
logic is not something that multiple

01:02:31,190 --> 01:02:35,509
components need to do if a single

01:02:33,589 --> 01:02:37,400
component needs to do a lot of logic on

01:02:35,509 --> 01:02:40,400
top of your stake just put it in that

01:02:37,400 --> 01:02:43,190
component and calculate it every time

01:02:40,400 --> 01:02:44,839
like JavaScript is really fast these

01:02:43,190 --> 01:02:46,940
days and I know that it can add up if

01:02:44,839 --> 01:02:49,970
you're doing fuel processing ten

01:02:46,940 --> 01:02:52,039
thousand nine ten thousand item arrays

01:02:49,970 --> 01:02:54,890
but for most things in most universe

01:02:52,039 --> 01:02:57,230
it's actually pretty fast I think and

01:02:54,890 --> 01:02:59,599
even if you're using it within the

01:02:57,230 --> 01:03:02,119
reactive component it's tough if it's

01:02:59,599 --> 01:03:04,730
slow we have used memo so you can

01:03:02,119 --> 01:03:07,700
memorize it automatically with the code

01:03:04,730 --> 01:03:10,460
that with machinery that you already get

01:03:07,700 --> 01:03:15,170
in react yeah does that answer your

01:03:10,460 --> 01:03:17,329
question yeah sure thank you some some

01:03:15,170 --> 01:03:19,849
other questions a beard while you

01:03:17,329 --> 01:03:22,730
weren't where you were answering one

01:03:19,849 --> 01:03:25,220
really connected to this would you

01:03:22,730 --> 01:03:28,549
recommend to use more context or just

01:03:25,220 --> 01:03:30,799
use one global like redux doesn't it get

01:03:28,549 --> 01:03:36,140
a bit messy if you have let's say 10 to

01:03:30,799 --> 01:03:38,809
20 contexts in your in your app so yes

01:03:36,140 --> 01:03:42,859
if you have multiple contexts it can get

01:03:38,809 --> 01:03:44,930
messy in theory the question is what is

01:03:42,859 --> 01:03:48,619
the smallest number of components that

01:03:44,930 --> 01:03:50,749
need to share some state and when you

01:03:48,619 --> 01:03:52,400
find that you can create a context for

01:03:50,749 --> 01:03:53,869
those components to make it easier for

01:03:52,400 --> 01:03:56,390
them to communicate between each other

01:03:53,869 --> 01:03:58,759
and then use global context for

01:03:56,390 --> 01:04:01,220
everything else so you wouldn't you

01:03:58,759 --> 01:04:01,550
wouldn't wrap your root component in 20

01:04:01,220 --> 01:04:02,750
different

01:04:01,550 --> 01:04:05,270
context you would wrap your root

01:04:02,750 --> 01:04:07,040
component in one global context or a

01:04:05,270 --> 01:04:08,630
couple global context that you really

01:04:07,040 --> 01:04:10,820
need to be global and then you would

01:04:08,630 --> 01:04:14,510
have sub trees and you would just you

01:04:10,820 --> 01:04:17,810
can wrap a part of a sub tree in your

01:04:14,510 --> 01:04:20,300
context so it's more like think of it

01:04:17,810 --> 01:04:22,280
the original title for this talk was

01:04:20,300 --> 01:04:24,410
push your edge to push your state to the

01:04:22,280 --> 01:04:27,830
edge that's kind of the idea you you're

01:04:24,410 --> 01:04:29,870
trying to find the most edge the

01:04:27,830 --> 01:04:31,310
smallest part of your edge components

01:04:29,870 --> 01:04:32,990
that need to actually share some state

01:04:31,310 --> 01:04:34,340
and then share it only between those

01:04:32,990 --> 01:04:38,900
because that makes it easier to

01:04:34,340 --> 01:04:41,290
understand and read your code you're

01:04:38,900 --> 01:04:46,640
pretty pretty much I I agree with this

01:04:41,290 --> 01:04:49,310
that once once you start refactoring

01:04:46,640 --> 01:04:51,560
your Redux store you end up with the

01:04:49,310 --> 01:04:54,470
realization that you put it in the

01:04:51,560 --> 01:04:59,000
global state just because you could and

01:04:54,470 --> 01:05:01,400
it was so easy and actually the the

01:04:59,000 --> 01:05:05,030
stuff that is really global there is

01:05:01,400 --> 01:05:07,280
minimum of that for us it was some like

01:05:05,030 --> 01:05:09,560
language currency and aesthetic data

01:05:07,280 --> 01:05:11,390
which need to be shared across across

01:05:09,560 --> 01:05:13,660
that and everything else can be used

01:05:11,390 --> 01:05:14,990
yeah III pretty much agree with this

01:05:13,660 --> 01:05:18,080
awesome

01:05:14,990 --> 01:05:21,470
another question is what would be the

01:05:18,080 --> 01:05:23,990
easiest way to find where the context

01:05:21,470 --> 01:05:28,760
provider is defined for a particular use

01:05:23,990 --> 01:05:30,830
of a shared state great question so if

01:05:28,760 --> 01:05:33,890
you using I don't know about other

01:05:30,830 --> 01:05:36,740
editors if you're using vs code you can

01:05:33,890 --> 01:05:38,660
come and click on the hook that connect

01:05:36,740 --> 01:05:41,180
you to the state so in our example it

01:05:38,660 --> 01:05:44,060
would be the use shared count function

01:05:41,180 --> 01:05:46,040
or hook you command click on that it

01:05:44,060 --> 01:05:48,470
goes to the file where that function is

01:05:46,040 --> 01:05:52,910
defined and at the top of that file it

01:05:48,470 --> 01:05:55,280
says it says import context from X and

01:05:52,910 --> 01:05:56,870
that X is where your context is defined

01:05:55,280 --> 01:06:01,070
and where the provider is defined as

01:05:56,870 --> 01:06:02,720
well so it's like one step one click and

01:06:01,070 --> 01:06:04,190
you find it especially if you're using

01:06:02,720 --> 01:06:06,250
typescript I think that works even

01:06:04,190 --> 01:06:09,200
better mm-hmm

01:06:06,250 --> 01:06:10,010
Roman I hope this answers your your

01:06:09,200 --> 01:06:13,370
question

01:06:10,010 --> 01:06:17,510
if not you can specify it even more in

01:06:13,370 --> 01:06:22,760
another one and some more questions

01:06:17,510 --> 01:06:25,400
appearing was from Pershing how would

01:06:22,760 --> 01:06:27,860
you go around a scenario where you need

01:06:25,400 --> 01:06:30,920
two independent parallel wormholes for

01:06:27,860 --> 01:06:33,620
the same context let's say you want to

01:06:30,920 --> 01:06:36,710
display two independent plus one buttons

01:06:33,620 --> 01:06:37,250
with their display components far in the

01:06:36,710 --> 01:06:43,570
dome

01:06:37,250 --> 01:06:47,180
I see so for that so where you have a

01:06:43,570 --> 01:06:50,390
similar type of state but it's not the

01:06:47,180 --> 01:06:53,000
same state specifically I haven't tried

01:06:50,390 --> 01:06:56,800
that before an approach I think would

01:06:53,000 --> 01:07:00,080
work is to have to create two contexts

01:06:56,800 --> 01:07:02,870
so you could then make it a little bit

01:07:00,080 --> 01:07:06,770
more complicated and make your shared

01:07:02,870 --> 01:07:09,770
state provider accept a context function

01:07:06,770 --> 01:07:11,840
in it or you know what we called create

01:07:09,770 --> 01:07:14,240
context and created the actual contest

01:07:11,840 --> 01:07:17,300
to share stuff you could pass that as a

01:07:14,240 --> 01:07:20,120
prop into your provider and then you

01:07:17,300 --> 01:07:22,630
could use that then you could have your

01:07:20,120 --> 01:07:25,700
you could potentially then have your

01:07:22,630 --> 01:07:29,500
hook that looks at the shared state also

01:07:25,700 --> 01:07:33,020
accept the context as an argument so

01:07:29,500 --> 01:07:35,030
that would kind of work I think that

01:07:33,020 --> 01:07:38,960
that could get messy very quickly I

01:07:35,030 --> 01:07:40,480
would question whether it depends it

01:07:38,960 --> 01:07:42,710
really depends on your use case but

01:07:40,480 --> 01:07:44,420
somewhere in that line it would be more

01:07:42,710 --> 01:07:47,600
like using context directly rather than

01:07:44,420 --> 01:07:50,470
through a separate helper hook but you

01:07:47,600 --> 01:07:52,700
could do it so you would basically

01:07:50,470 --> 01:07:54,440
instantiate multiple contexts and then

01:07:52,700 --> 01:07:54,830
have the same machinery attached to them

01:07:54,440 --> 01:07:58,280
mm-hm

01:07:54,830 --> 01:08:03,310
yeah I think that will work but I

01:07:58,280 --> 01:08:06,230
haven't tried it yep another question

01:08:03,310 --> 01:08:08,390
with the formal context do you recommend

01:08:06,230 --> 01:08:10,280
having one huge context per application

01:08:08,390 --> 01:08:12,410
or several small context each pair

01:08:10,280 --> 01:08:16,070
logical subdomain I think we answered

01:08:12,410 --> 01:08:18,230
answered this already will Apple a local

01:08:16,070 --> 01:08:21,500
state management replace all other state

01:08:18,230 --> 01:08:22,010
management libraries that's a good

01:08:21,500 --> 01:08:24,320
question

01:08:22,010 --> 01:08:26,750
I don't I don't know I don't think it

01:08:24,320 --> 01:08:29,509
will it's haven't you

01:08:26,750 --> 01:08:32,029
they haven't used the actual upon local

01:08:29,509 --> 01:08:34,040
state stuff I've used Apollo's graph QL

01:08:32,029 --> 01:08:37,310
stuff which is I think pretty similar

01:08:34,040 --> 01:08:49,430
and that works really nicely I guess

01:08:37,310 --> 01:08:50,480
time hotel it really depends ok let's

01:08:49,430 --> 01:08:52,670
see another one

01:08:50,480 --> 01:08:55,100
do you recommend any resources online

01:08:52,670 --> 01:09:01,100
where I can find more complex examples

01:08:55,100 --> 01:09:03,890
using this pattern with react can't blog

01:09:01,100 --> 01:09:06,080
is actually really good I would also

01:09:03,890 --> 01:09:10,430
recommend checking out my use off

01:09:06,080 --> 01:09:17,089
library I can link it down here so if

01:09:10,430 --> 01:09:21,710
you look for so this is the library

01:09:17,089 --> 01:09:24,200
where I vanished when I click send so

01:09:21,710 --> 01:09:25,670
use office the library where I first

01:09:24,200 --> 01:09:28,790
developed this pattern and started

01:09:25,670 --> 01:09:30,020
really using it and it uses this pattern

01:09:28,790 --> 01:09:34,250
to manage everything about

01:09:30,020 --> 01:09:36,770
authentication in your entire name so

01:09:34,250 --> 01:09:39,350
it's relatively complex it also uses the

01:09:36,770 --> 01:09:43,910
use we do certain stuff because it has

01:09:39,350 --> 01:09:45,680
so much straight mm-hmm the next

01:09:43,910 --> 01:09:47,540
question really great one is there any

01:09:45,680 --> 01:09:49,670
tool similar to redock step tools that

01:09:47,540 --> 01:09:56,270
you could use for debugging with react

01:09:49,670 --> 01:09:58,550
context but this is a pretty strong side

01:09:56,270 --> 01:10:00,940
of the of the redux that's the dueling

01:09:58,550 --> 01:10:04,460
yes at least when you need it is there

01:10:00,940 --> 01:10:06,530
yeah so I don't I haven't used Redux

01:10:04,460 --> 01:10:09,980
tooling in a while so I'm not sure what

01:10:06,530 --> 01:10:12,170
it provides these days I know that react

01:10:09,980 --> 01:10:15,050
dev tools they were working very hard on

01:10:12,170 --> 01:10:18,020
making hooks in context more directly

01:10:15,050 --> 01:10:20,870
with the normal reactive tools but I

01:10:18,020 --> 01:10:23,600
honestly haven't needed it because this

01:10:20,870 --> 01:10:25,610
pattern is easy enough to use that I

01:10:23,600 --> 01:10:27,470
don't have to I can just put a couple

01:10:25,610 --> 01:10:31,810
console logs where I'm actually using

01:10:27,470 --> 01:10:34,880
the Kochs and that works I've honestly

01:10:31,810 --> 01:10:36,890
not had a need to try to look at dev

01:10:34,880 --> 01:10:38,330
tools to fix it but maybe there's

01:10:36,890 --> 01:10:40,960
something I'm missing that I don't even

01:10:38,330 --> 01:10:40,960
know how I could have

01:10:41,810 --> 01:10:46,770
like I could probably imagine a better

01:10:44,790 --> 01:10:48,239
to link because in the reactive tools

01:10:46,770 --> 01:10:51,120
you can always just click on the

01:10:48,239 --> 01:10:54,480
component and see the local state but

01:10:51,120 --> 01:10:56,880
this can get like pretty hard with the

01:10:54,480 --> 01:11:01,050
context when they are all over the place

01:10:56,880 --> 01:11:04,620
so yeah but console logs for further win

01:11:01,050 --> 01:11:11,220
into JavaScript ecosystem yeah I mean I

01:11:04,620 --> 01:11:16,650
love console logs yeah another question

01:11:11,220 --> 01:11:17,910
have you heard slash used X state what

01:11:16,650 --> 01:11:19,980
do you think of the concept of

01:11:17,910 --> 01:11:24,120
separating logics from rendering the

01:11:19,980 --> 01:11:26,340
with state machines so X state I haven't

01:11:24,120 --> 01:11:29,730
used it it's a really good library it's

01:11:26,340 --> 01:11:31,860
how I originally taught people to use

01:11:29,730 --> 01:11:37,230
redux was to think of it as a state

01:11:31,860 --> 01:11:39,390
machine and use actions as movement like

01:11:37,230 --> 01:11:40,950
if you draw a state machine each action

01:11:39,390 --> 01:11:44,300
is an arrow between different states and

01:11:40,950 --> 01:11:47,489
then your reducer does the states you

01:11:44,300 --> 01:11:49,860
while I haven't tried it I think you can

01:11:47,489 --> 01:11:52,440
use X State with the wormhole approach

01:11:49,860 --> 01:11:55,500
it's just work where I did the use state

01:11:52,440 --> 01:11:57,270
part inside the context provider you

01:11:55,500 --> 01:12:03,480
could use X state there and it would

01:11:57,270 --> 01:12:04,710
work the same yeah if you have something

01:12:03,480 --> 01:12:06,690
that fits a state machine I would

01:12:04,710 --> 01:12:09,860
definitely recommend using X because it

01:12:06,690 --> 01:12:09,860
solves a lot of problems for you

01:12:14,060 --> 01:12:17,299
[Music]

01:12:20,540 --> 01:12:29,820
typescript depends what you're doing if

01:12:26,550 --> 01:12:31,739
you if you it pretty much ends up or

01:12:29,820 --> 01:12:40,020
links to a discussion whether you need

01:12:31,739 --> 01:12:42,450
new types or not but in my personal

01:12:40,020 --> 01:12:45,480
opinion I recommend them it helped me to

01:12:42,450 --> 01:12:47,820
debug a lot it helps with your factors

01:12:45,480 --> 01:12:51,060
you change something and the types will

01:12:47,820 --> 01:12:53,489
tell you whether you are just breaking

01:12:51,060 --> 01:12:54,179
your application up it catches a lot of

01:12:53,489 --> 01:12:56,909
type

01:12:54,179 --> 01:12:58,920
style mistakes and yeah actually the

01:12:56,909 --> 01:13:02,610
best part about typescript if you're

01:12:58,920 --> 01:13:04,440
using vs code is that you get hints on

01:13:02,610 --> 01:13:05,909
your functions so you don't have to go

01:13:04,440 --> 01:13:08,100
look at the functional definition you

01:13:05,909 --> 01:13:12,739
can see directly in the editor what you

01:13:08,100 --> 01:13:15,600
need and that's awesome exactly this

01:13:12,739 --> 01:13:17,760
there is a question about the materials

01:13:15,600 --> 01:13:22,770
can you write down here the websites you

01:13:17,760 --> 01:13:23,760
you name it probably can touch the Q

01:13:22,770 --> 01:13:26,730
word

01:13:23,760 --> 01:13:28,469
yep react is that block and others

01:13:26,730 --> 01:13:31,800
please my brother is so in here is

01:13:28,469 --> 01:13:34,320
chitchat Thanks oh maybe we can write up

01:13:31,800 --> 01:13:38,070
some summary also for the for the slack

01:13:34,320 --> 01:13:44,880
so people can find fun in deep there if

01:13:38,070 --> 01:13:46,860
they are there then what was there there

01:13:44,880 --> 01:13:49,679
was a one last question if you have a

01:13:46,860 --> 01:13:53,489
context fair domain in brackets no

01:13:49,679 --> 01:14:03,870
global context what value does creating

01:13:53,489 --> 01:14:08,310
hooks over the context do you have it it

01:14:03,870 --> 01:14:10,620
continues that to use the use counter

01:14:08,310 --> 01:14:13,140
context you create it which looks like a

01:14:10,620 --> 01:14:18,600
shell of wrapper we could use context

01:14:13,140 --> 01:14:20,429
directly so that's true you can use

01:14:18,600 --> 01:14:23,790
context directly for something this

01:14:20,429 --> 01:14:26,190
simple if you look at my use off library

01:14:23,790 --> 01:14:28,320
you'll see that having a helper hook is

01:14:26,190 --> 01:14:31,140
really helpful because like we said

01:14:28,320 --> 01:14:34,050
earlier you can use it to make sort of

01:14:31,140 --> 01:14:38,610
selectors that combine logic on top of

01:14:34,050 --> 01:14:41,640
your state you can make a easier API for

01:14:38,610 --> 01:14:44,550
managing your state so what I like to do

01:14:41,640 --> 01:14:47,969
is use reducer and then put the dispatch

01:14:44,550 --> 01:14:49,620
function into my context so I can call

01:14:47,969 --> 01:14:53,040
this patch and dispatch actions from

01:14:49,620 --> 01:14:56,580
wherever it's basically it's just a way

01:14:53,040 --> 01:14:58,469
of providing a nicer API on top of the

01:14:56,580 --> 01:15:01,170
count on top of the context itself so

01:14:58,469 --> 01:15:03,150
that you have both the logic separated

01:15:01,170 --> 01:15:05,800
into its own so you have business logic

01:15:03,150 --> 01:15:07,720
separated shared

01:15:05,800 --> 01:15:09,220
this logic separated into its own hook

01:15:07,720 --> 01:15:11,560
so you don't have to re-implement it

01:15:09,220 --> 01:15:12,820
every time in every component I think

01:15:11,560 --> 01:15:14,920
that makes it nicer but yeah

01:15:12,820 --> 01:15:21,490
you can still use use context directly

01:15:14,920 --> 01:15:25,510
and not have a separate hook at all yep

01:15:21,490 --> 01:15:28,180
and the last question so we will not

01:15:25,510 --> 01:15:29,620
ignore it and you be here where can I

01:15:28,180 --> 01:15:31,780
start applying to junior react

01:15:29,620 --> 01:15:34,210
developers positions is there some kind

01:15:31,780 --> 01:15:36,910
of a list of tools I need to know how to

01:15:34,210 --> 01:15:42,490
use or maybe I just need to build a

01:15:36,910 --> 01:15:44,830
couple of pet projects this is kind of a

01:15:42,490 --> 01:15:51,970
general question let me help with the

01:15:44,830 --> 01:15:53,920
answer there like if you just type react

01:15:51,970 --> 01:15:56,230
generate developer position into a

01:15:53,920 --> 01:15:58,300
Google and do not find anything suitable

01:15:56,230 --> 01:16:02,470
then probably your internet is not

01:15:58,300 --> 01:16:05,680
working correctly and when start pretty

01:16:02,470 --> 01:16:08,650
much try to experiment with the

01:16:05,680 --> 01:16:11,650
libraries mentioned here the the react

01:16:08,650 --> 01:16:14,620
as a library itself there is a lot of

01:16:11,650 --> 01:16:17,590
IDs which are online for example coats

01:16:14,620 --> 01:16:19,390
and books where you can without needing

01:16:17,590 --> 01:16:21,190
to setup anything you can just start

01:16:19,390 --> 01:16:24,790
writing your code and your first

01:16:21,190 --> 01:16:29,650
tutorials and the read documentation is

01:16:24,790 --> 01:16:32,020
a full of great links to two other other

01:16:29,650 --> 01:16:36,190
great people in the ring that causes

01:16:32,020 --> 01:16:39,190
them like Dan Abramov Kent dots and and

01:16:36,190 --> 01:16:41,320
many others so so so feel free to start

01:16:39,190 --> 01:16:46,060
there and you can't make a mistake

01:16:41,320 --> 01:16:48,490
pretty much yeah and one thing I would

01:16:46,060 --> 01:16:52,920
add to that is just start applying it's

01:16:48,490 --> 01:16:55,300
their job to say no not yours yeah and

01:16:52,920 --> 01:17:01,020
you will find out what they are

01:16:55,300 --> 01:17:06,960
interested in what the requirements are

01:17:01,020 --> 01:17:11,380
okay so we answered all the questions

01:17:06,960 --> 01:17:14,380
thank you Swiss it was awesome here I

01:17:11,380 --> 01:17:18,250
hope you enjoyed it as well as I did

01:17:14,380 --> 01:17:22,660
just few remarks

01:17:18,250 --> 01:17:24,610
at the end please try to provide the

01:17:22,660 --> 01:17:27,460
feedback for us in the selectional it's

01:17:24,610 --> 01:17:29,530
really important it helped us to get

01:17:27,460 --> 01:17:35,790
better and better and you enjoyed the

01:17:29,530 --> 01:17:39,130
talks more so all all feedback well done

01:17:35,790 --> 01:17:42,760
thanks for joining us I hope that you

01:17:39,130 --> 01:17:46,240
will join us again next time just to

01:17:42,760 --> 01:17:49,240
mention the next time the meta speaker

01:17:46,240 --> 01:17:51,580
will be in benning's and the talk will

01:17:49,240 --> 01:17:54,610
be a framework to lead a team to success

01:17:51,580 --> 01:17:55,960
in a challenging environment I think

01:17:54,610 --> 01:17:59,290
that currently we have a really

01:17:55,960 --> 01:18:00,730
challenging environment all of us so so

01:17:59,290 --> 01:18:04,900
that sounds like a really interesting

01:18:00,730 --> 01:18:07,750
topic at this time and the main speaker

01:18:04,900 --> 01:18:11,200
and that dog will be by Chen huge ink

01:18:07,750 --> 01:18:16,720
and the top will be about CSS for

01:18:11,200 --> 01:18:19,450
internalization so so stay tuned and

01:18:16,720 --> 01:18:21,850
follow the socials for more information

01:18:19,450 --> 01:18:26,080
thank you all have a great evening

01:18:21,850 --> 01:18:31,620
hope you finished your beers and yep

01:18:26,080 --> 01:18:31,620
thank you all bye folks

01:18:37,700 --> 01:18:39,760

YouTube URL: https://www.youtube.com/watch?v=OJ7ZDfQ4snc


