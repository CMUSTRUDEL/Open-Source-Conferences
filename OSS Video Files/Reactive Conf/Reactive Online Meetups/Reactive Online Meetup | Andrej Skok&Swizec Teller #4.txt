Title: Reactive Online Meetup | Andrej Skok&Swizec Teller #4
Publication date: 2020-05-29
Playlist: Reactive Online Meetups
Description: 
	NEXT REACTIVE ONLINE MEETUP ➡️JUNE 9TH, 7 PM CEST
TIM BENNIKS&CHEN HUI JING

J͟o͟i͟n͟ ͟t͟h͟e͟ ͟m͟e͟e͟t͟u͟p͟ ͟v͟i͟a͟ ͟S͟l͟a͟c͟k͟ ͟c͟h͟a͟n͟n͟e͟l͟:͟
https://bit.ly/Reactive_slack_networking

--------------------

SPEAKERS
#metatalk - ANDREJ SKOK - Mind the perf
#devtalk - SWIZEC TELLER - Push your state to the edge


--------------------


ANDREJ SKOK
#metatalk

𝗧𝗔𝗟𝗞
Mind the perf

𝗧𝗔𝗟𝗞 𝗔𝗕𝗦𝗧𝗥𝗔𝗖𝗧
Adding more and more new features almost always comes at a cost. Let’s look at some ways how to keep heavy frontend in react performant even when the codebase is growing like crazy.
--------------------

SWIZEC TELLER 
#devtalk

𝗧𝗔𝗟𝗞
Push your state to the edge

𝗧𝗔𝗟𝗞 𝗔𝗕𝗦𝗧𝗥𝗔𝗖𝗧
React revolutionized the way most of us think about the state. No more binding, no more mess, just a beautiful unidirectional flow of data. It was great.

Until your app grew.

How the heck do you scale a central store of all app state? Where do you drill all the props? Why does every update go through a bazillion nested layers before it shows?

React Hooks enable a new architecture.

An architecture where state lives where you need it, business logic is where you use it, and anyone can understand your code without studying the whole codebase.

𝗕𝗜𝗢
Swizec is a prolific engineer, instructor, blogger, vlogger, conference speaker, and author. He's written many books including ReactForDataViz.com, Data Visualization with D3.js, the work-in-progress SeverlessHandbook.Dev, and ServerlessReact.Dev. He has trained the engineering teams from multiple Fortune 500 companies on React, Redux, GraphQL, Serverless, and other modern web technologies.

links:
ReactiveOnline Meetups are powered by Vacuumlabs
https://www.vacuumlabs.com

Swizec Teller / Twitter: @Swizec / w: https://swizec.com

Andrej Skok / Twitter: @andrejskoki
Captions: 
	00:00:06,960 --> 00:00:19,830
hello everyone welcome to our

00:00:14,490 --> 00:00:22,080
online Meetup first of all let me let me

00:00:19,830 --> 00:00:25,320
tell you that I really hope that you are

00:00:22,080 --> 00:00:28,529
all staying home safe with your families

00:00:25,320 --> 00:00:30,890
and you are not stressed out about the

00:00:28,529 --> 00:00:34,530
coffee situation and you are enjoying

00:00:30,890 --> 00:00:37,800
some great books or games or or online

00:00:34,530 --> 00:00:39,870
presentations I'm really excited that

00:00:37,800 --> 00:00:43,070
you made the decision to stay ahead of

00:00:39,870 --> 00:00:45,780
the curve and spent this evening with us

00:00:43,070 --> 00:00:50,699
it's really great to see so many

00:00:45,780 --> 00:00:54,449
attendees to introduce myself and the

00:00:50,699 --> 00:00:58,559
Scott I will be host today and I will be

00:00:54,449 --> 00:01:01,229
also the meta speaker I work for for

00:00:58,559 --> 00:01:04,979
Viking labs which is the company that

00:01:01,229 --> 00:01:07,970
stays behind and was behind the original

00:01:04,979 --> 00:01:12,740
idea of the reactive come from back in

00:01:07,970 --> 00:01:15,240
2015 we are focused on providing the

00:01:12,740 --> 00:01:17,130
flexible and reliable software engineers

00:01:15,240 --> 00:01:20,340
to clients all over the all over the

00:01:17,130 --> 00:01:24,000
world from Los Angeles to Tokyo

00:01:20,340 --> 00:01:28,380
basically focused mainly on feedback and

00:01:24,000 --> 00:01:31,649
blockchain projects my position in the

00:01:28,380 --> 00:01:36,950
company is that for four years already

00:01:31,649 --> 00:01:41,539
I am from tenth calculate working for

00:01:36,950 --> 00:01:44,880
tv.com the point Achatz in company

00:01:41,539 --> 00:01:48,210
before my presentation begins with me

00:01:44,880 --> 00:01:51,179
just give you a few notes how this will

00:01:48,210 --> 00:01:53,609
be organized so first of all there is a

00:01:51,179 --> 00:01:56,549
QA QA

00:01:53,609 --> 00:01:58,770
there is an option to ask questions on

00:01:56,549 --> 00:02:02,579
the bottom of your select windows feel

00:01:58,770 --> 00:02:05,969
free to ask questions anytime during the

00:02:02,579 --> 00:02:08,700
talk after meta talk and even after the

00:02:05,969 --> 00:02:10,560
main talk there will be two separate QA

00:02:08,700 --> 00:02:13,040
sessions and hopefully all your

00:02:10,560 --> 00:02:15,390
questions will be answered

00:02:13,040 --> 00:02:17,010
secondly there is a select channel

00:02:15,390 --> 00:02:20,850
reactive online Meetup

00:02:17,010 --> 00:02:24,270
that's like calm feel free to join and

00:02:20,850 --> 00:02:28,410
ask questions and discuss topics even

00:02:24,270 --> 00:02:32,010
after the talk so will be really

00:02:28,410 --> 00:02:37,590
but if if you will join visits and also

00:02:32,010 --> 00:02:41,430
me we are both there also there is a

00:02:37,590 --> 00:02:42,660
main speaker available on the call so

00:02:41,430 --> 00:02:50,570
welcomes with it

00:02:42,660 --> 00:02:54,200
how are you doing hurry yeah also great

00:02:50,570 --> 00:02:58,200
I'm really excited for the talks of

00:02:54,200 --> 00:03:00,930
course for your more than for mine but

00:02:58,200 --> 00:03:06,060
it might not be the same for all of the

00:03:00,930 --> 00:03:08,520
attendees hopefully so pretty much what

00:03:06,060 --> 00:03:10,590
is left to say is that stage is mine and

00:03:08,520 --> 00:03:14,520
I will just start with my presentation

00:03:10,590 --> 00:03:20,070
so enjoy enjoy your evening grab your

00:03:14,520 --> 00:03:28,740
beers and let's start hopefully you can

00:03:20,070 --> 00:03:31,470
see my screen perfect so I choose the

00:03:28,740 --> 00:03:36,990
title for my meta tall to be mined the

00:03:31,470 --> 00:03:41,850
Perth and and I hope that you will mind

00:03:36,990 --> 00:03:48,510
the performance a little bit more after

00:03:41,850 --> 00:03:51,660
this after this meta talk first of all

00:03:48,510 --> 00:03:54,390
who is behind the screen so I have

00:03:51,660 --> 00:03:59,489
already introduced myself for four years

00:03:54,390 --> 00:04:01,620
working for only on the web in a travel

00:03:59,489 --> 00:04:04,410
industry I've been part of vacuum labs

00:04:01,620 --> 00:04:10,250
for four five years so that's my coding

00:04:04,410 --> 00:04:14,580
career my handle on the most popular

00:04:10,250 --> 00:04:18,209
ornithologist website is at Andres kaki

00:04:14,580 --> 00:04:27,240
so you can get get in touch with me

00:04:18,209 --> 00:04:29,700
there I read to eat a lot of time so to

00:04:27,240 --> 00:04:32,430
give you a context and some initial

00:04:29,700 --> 00:04:35,040
setting so how we were thinking about

00:04:32,430 --> 00:04:39,200
the performance where we start when we

00:04:35,040 --> 00:04:41,630
started and I will try to just show you

00:04:39,200 --> 00:04:45,270
the steps

00:04:41,630 --> 00:04:45,720
that we have taken just to reach reached

00:04:45,270 --> 00:04:49,250
our goal

00:04:45,720 --> 00:04:51,180
so when we first started the codebase

00:04:49,250 --> 00:04:52,860
when we started thinking about

00:04:51,180 --> 00:04:55,560
performance at the performance is our

00:04:52,860 --> 00:04:59,070
problem the code base was five to six

00:04:55,560 --> 00:05:01,860
years old the problem was that the tech

00:04:59,070 --> 00:05:04,950
changed multiple times and majored in

00:05:01,860 --> 00:05:08,670
times of JavaScript fatigue so there was

00:05:04,950 --> 00:05:11,010
a really great idea every every day what

00:05:08,670 --> 00:05:14,460
we should do differently and we never

00:05:11,010 --> 00:05:17,370
speak to one one proper technology for a

00:05:14,460 --> 00:05:19,350
longer period of time the code base was

00:05:17,370 --> 00:05:23,340
growing pretty much features were more

00:05:19,350 --> 00:05:26,340
important than performance and we were

00:05:23,340 --> 00:05:28,490
adding new features maybe tests we were

00:05:26,340 --> 00:05:31,470
going through a lot of rate redesigns

00:05:28,490 --> 00:05:34,620
after the some UX research first was

00:05:31,470 --> 00:05:36,780
done the up up felt slow

00:05:34,620 --> 00:05:39,030
we made some measurements and find out

00:05:36,780 --> 00:05:41,220
that we are really lagging behind the

00:05:39,030 --> 00:05:43,230
industry standard if in terms of basic

00:05:41,220 --> 00:05:46,230
performance like time to interacting

00:05:43,230 --> 00:05:48,810
visually complete or page load time for

00:05:46,230 --> 00:05:50,730
us the initial load stopped around one

00:05:48,810 --> 00:05:53,010
megabyte of JavaScript and five megabyte

00:05:50,730 --> 00:05:56,160
of total assets after the compression it

00:05:53,010 --> 00:06:00,020
may not sound like like much but

00:05:56,160 --> 00:06:03,240
industry standard was maybe half of that

00:06:00,020 --> 00:06:06,390
today my main goal is to summarize the

00:06:03,240 --> 00:06:08,370
steps which we gradually took and which

00:06:06,390 --> 00:06:11,010
Butcher pushed us to much better

00:06:08,370 --> 00:06:12,780
performance and in the end improved our

00:06:11,010 --> 00:06:17,550
code based quality and also the

00:06:12,780 --> 00:06:20,340
processes the prerequisite of the tech

00:06:17,550 --> 00:06:23,370
you should know is pretty much the web

00:06:20,340 --> 00:06:25,890
pack Babel and the basics of Jessica

00:06:23,370 --> 00:06:28,560
system it will be really high level and

00:06:25,890 --> 00:06:34,260
it will be more about concepts that than

00:06:28,560 --> 00:06:37,080
some really specific configurations my

00:06:34,260 --> 00:06:39,570
my first recommendation is that mind the

00:06:37,080 --> 00:06:40,350
dependencies and might mind them from

00:06:39,570 --> 00:06:43,890
the start

00:06:40,350 --> 00:06:48,450
start it made sound sound really trivial

00:06:43,890 --> 00:06:50,880
but at first our dependencies or

00:06:48,450 --> 00:06:54,919
third-party libraries in our code made

00:06:50,880 --> 00:06:54,919
up more than 60% of the codebase

00:06:55,060 --> 00:06:59,520
there is nothing inherently wrong with

00:06:56,919 --> 00:07:02,370
using the dependencies and using

00:06:59,520 --> 00:07:05,110
third-party code and using it wisely

00:07:02,370 --> 00:07:07,570
because pretty much that's what we all

00:07:05,110 --> 00:07:10,510
do like we reuse someone else else's

00:07:07,570 --> 00:07:13,300
code because we do not want all to build

00:07:10,510 --> 00:07:16,600
everything from ground up on the green

00:07:13,300 --> 00:07:18,610
field but make sure that you are using

00:07:16,600 --> 00:07:21,280
your dependencies wisely and to the

00:07:18,610 --> 00:07:23,980
fullest and you are not including that

00:07:21,280 --> 00:07:26,710
ends of kilobytes of code and using just

00:07:23,980 --> 00:07:28,960
a few functions from it that really

00:07:26,710 --> 00:07:31,479
makes no sense and further analysis

00:07:28,960 --> 00:07:34,720
could have been done what is more

00:07:31,479 --> 00:07:37,389
important that it's it's not just a

00:07:34,720 --> 00:07:44,710
library self about the dependencies that

00:07:37,389 --> 00:07:46,750
come I'll come with that library what

00:07:44,710 --> 00:07:48,550
we're our our steps we're that we

00:07:46,750 --> 00:07:51,010
started to actively search for libraries

00:07:48,550 --> 00:07:54,419
that do exactly the things that we need

00:07:51,010 --> 00:07:58,180
it to do and the library itself has

00:07:54,419 --> 00:08:00,610
minimum dependencies that's pretty much

00:07:58,180 --> 00:08:03,490
like using Rambla overload ash rambha

00:08:00,610 --> 00:08:06,340
has dependencies I think date functions

00:08:03,490 --> 00:08:08,800
our moment or throwing away the

00:08:06,340 --> 00:08:11,919
libraries which you probably do not need

00:08:08,800 --> 00:08:13,479
may be immutable Jas like we know that

00:08:11,919 --> 00:08:16,210
we cannot get rid of it completely

00:08:13,479 --> 00:08:17,979
because it's dependency to all too many

00:08:16,210 --> 00:08:21,280
other libraries but at least we can try

00:08:17,979 --> 00:08:25,510
and do not have it there in our bound on

00:08:21,280 --> 00:08:28,300
multiple times for example this has

00:08:25,510 --> 00:08:30,430
other great consequences like having

00:08:28,300 --> 00:08:36,520
faster pipeline installed time of the

00:08:30,430 --> 00:08:44,440
application faster security old it ran

00:08:36,520 --> 00:08:46,060
on NPM I recommend the using some of the

00:08:44,440 --> 00:08:47,650
pay web pages which will tell you more

00:08:46,060 --> 00:08:50,290
about the libraries that you are using

00:08:47,650 --> 00:08:53,110
or going to install like pantophobia

00:08:50,290 --> 00:08:55,620
comm which is a pretty great overview

00:08:53,110 --> 00:08:58,240
that what the size of the library

00:08:55,620 --> 00:09:01,839
whether it's dependencies how big they

00:08:58,240 --> 00:09:04,150
are how the size of the library is

00:09:01,839 --> 00:09:06,280
changing with the versions so that's

00:09:04,150 --> 00:09:07,810
this is a really nice to do at least the

00:09:06,280 --> 00:09:09,400
basic track of

00:09:07,810 --> 00:09:13,060
some dependency that you are going to

00:09:09,400 --> 00:09:14,860
add to your to your coat also we started

00:09:13,060 --> 00:09:17,680
to periodically check whether the

00:09:14,860 --> 00:09:19,810
pendency still make sense so maybe there

00:09:17,680 --> 00:09:21,790
is some better alternative which may not

00:09:19,810 --> 00:09:26,080
have existed before when we started to

00:09:21,790 --> 00:09:27,580
start the programming or maybe there are

00:09:26,080 --> 00:09:30,310
some dependencies which can be dropped

00:09:27,580 --> 00:09:32,470
altogether which may always happen in a

00:09:30,310 --> 00:09:39,010
pretty big codebase that the clean up is

00:09:32,470 --> 00:09:41,200
not always on 100% my second

00:09:39,010 --> 00:09:44,290
recommendation is that if you have to

00:09:41,200 --> 00:09:45,610
use the dependencies to reshape them so

00:09:44,290 --> 00:09:47,050
if you do not feel like we're moving in

00:09:45,610 --> 00:09:49,510
the library that's still fine

00:09:47,050 --> 00:09:51,730
maybe there is nothing better which can

00:09:49,510 --> 00:09:55,720
be used at the time but you can always

00:09:51,730 --> 00:09:57,760
save a few kilobytes if you if you tree

00:09:55,720 --> 00:09:59,080
shake it properly it may be the case

00:09:57,760 --> 00:10:01,300
that you are just importing the eight

00:09:59,080 --> 00:10:03,850
entities in the front way and you should

00:10:01,300 --> 00:10:06,640
just install some babel plugin or web

00:10:03,850 --> 00:10:09,540
deploy perfect plugin which will just

00:10:06,640 --> 00:10:13,900
during the translation of the code

00:10:09,540 --> 00:10:17,260
adjust the imports so they are used they

00:10:13,900 --> 00:10:22,089
are used properly and in such a way that

00:10:17,260 --> 00:10:25,060
they can be true shaken in my own

00:10:22,089 --> 00:10:27,310
experience some web pack plugins are a

00:10:25,060 --> 00:10:30,130
little bit dangerous for example for

00:10:27,310 --> 00:10:32,410
lavash because they alter the the the

00:10:30,130 --> 00:10:34,720
behavior of the library they tries to

00:10:32,410 --> 00:10:36,670
optimize so much that they will they

00:10:34,720 --> 00:10:40,240
will even remove something that was

00:10:36,670 --> 00:10:46,559
really important so be aware but at

00:10:40,240 --> 00:10:49,529
least give it a try next step

00:10:46,559 --> 00:10:53,789
our next step was to analyze our bundle

00:10:49,529 --> 00:10:56,549
size and our analyze is it regularly so

00:10:53,789 --> 00:10:59,309
we started to use webpack analyzer to do

00:10:56,549 --> 00:11:01,679
at least basic bundle structure overview

00:10:59,309 --> 00:11:03,809
so this is pretty much how it looks like

00:11:01,679 --> 00:11:06,629
today it gives you a pretty great

00:11:03,809 --> 00:11:08,789
overview but without the big chunks in

00:11:06,629 --> 00:11:12,779
your code like all this is the lightest

00:11:08,789 --> 00:11:14,969
JSON can I remove it do we need it where

00:11:12,779 --> 00:11:17,369
is this having 100 kilobytes can I

00:11:14,969 --> 00:11:20,939
remove it can I split maybe some chunks

00:11:17,369 --> 00:11:23,279
even more who knows is it worth it so

00:11:20,939 --> 00:11:28,529
you can start asking a lot of useful

00:11:23,279 --> 00:11:31,979
questions based on what you can see so

00:11:28,529 --> 00:11:35,219
so the tooling was essential and and

00:11:31,979 --> 00:11:37,799
then we start asking questions and at

00:11:35,219 --> 00:11:41,399
first pretty much basically we had one

00:11:37,799 --> 00:11:44,729
bundle and everything was everywhere

00:11:41,399 --> 00:11:47,339
everything was in one chunk it was quite

00:11:44,729 --> 00:11:49,259
easy to spot some low-hanging fruit big

00:11:47,339 --> 00:11:52,379
chunks of code which are loaded at the

00:11:49,259 --> 00:11:55,889
wrong time or do not need to be loaded

00:11:52,379 --> 00:11:57,599
at all it was just that code and there

00:11:55,889 --> 00:12:01,109
was so much of it that it was pretty

00:11:57,599 --> 00:12:04,679
much obvious that it has to go away and

00:12:01,109 --> 00:12:08,639
our main goal was to start using dynamic

00:12:04,679 --> 00:12:12,899
imports where we could and minimizing

00:12:08,639 --> 00:12:15,899
the visibility of loading on the page

00:12:12,899 --> 00:12:18,179
due to code not being ready yet so we

00:12:15,899 --> 00:12:20,399
started off loading the features in

00:12:18,179 --> 00:12:23,369
models the features which are not so

00:12:20,399 --> 00:12:26,069
heavily used based on our analytics or

00:12:23,369 --> 00:12:29,429
for example in which medications for

00:12:26,069 --> 00:12:32,039
date functions or or moment libraries

00:12:29,429 --> 00:12:34,189
that's that there are pretty huge chunks

00:12:32,039 --> 00:12:37,919
of code and they are probably not needed

00:12:34,189 --> 00:12:39,479
because because you need just at one

00:12:37,919 --> 00:12:43,259
language which the users currently

00:12:39,479 --> 00:12:46,499
currently using and and see quite

00:12:43,259 --> 00:12:48,209
naturally we came to a point where we

00:12:46,499 --> 00:12:50,939
started to use dynamic imports per

00:12:48,209 --> 00:12:52,709
screen I will call it the scene and

00:12:50,939 --> 00:12:56,429
created one chunk for common code of

00:12:52,709 --> 00:12:58,490
course but the result was not as we

00:12:56,429 --> 00:13:01,370
expected

00:12:58,490 --> 00:13:03,860
we ended up pretty much which each each

00:13:01,370 --> 00:13:05,810
scene having one two one two five

00:13:03,860 --> 00:13:08,899
percent of the total size of the code

00:13:05,810 --> 00:13:11,270
and when become a chunk having the rest

00:13:08,899 --> 00:13:12,020
seventy-five percent of the size of of

00:13:11,270 --> 00:13:14,209
the codebase

00:13:12,020 --> 00:13:18,110
so that was pretty much not ideal we

00:13:14,209 --> 00:13:22,839
were hoping for something more even so

00:13:18,110 --> 00:13:26,540
this is something which helped a bit in

00:13:22,839 --> 00:13:30,920
terms of performance of loading of our

00:13:26,540 --> 00:13:33,620
page but it was far from optimal so we

00:13:30,920 --> 00:13:37,250
decided to split them on a load and the

00:13:33,620 --> 00:13:39,830
main problem was that which we realized

00:13:37,250 --> 00:13:42,140
pretty quickly that there are some some

00:13:39,830 --> 00:13:44,990
some big notes in our dependency graph

00:13:42,140 --> 00:13:47,750
which were pretty much the files which

00:13:44,990 --> 00:13:50,540
which included a lot of other files and

00:13:47,750 --> 00:13:52,790
we're gluing the codebase together so a

00:13:50,540 --> 00:13:56,600
nice example if you are using relax is

00:13:52,790 --> 00:13:59,770
your your register in which you are

00:13:56,600 --> 00:14:02,959
combining all the all of the other users

00:13:59,770 --> 00:14:05,570
so this is pretty much where you are

00:14:02,959 --> 00:14:07,510
importing all the other reducers those

00:14:05,570 --> 00:14:10,820
are in importing the actions they are

00:14:07,510 --> 00:14:13,190
importing maybe maybe some types some

00:14:10,820 --> 00:14:15,829
utils and whatever so so these were

00:14:13,190 --> 00:14:17,720
really the glue of the code base and the

00:14:15,829 --> 00:14:21,470
second problem was that we were cross

00:14:17,720 --> 00:14:23,300
importing too much like there were the

00:14:21,470 --> 00:14:27,020
the files from common were importing

00:14:23,300 --> 00:14:29,120
from other scenes the scenes were

00:14:27,020 --> 00:14:31,160
importing one from from from another

00:14:29,120 --> 00:14:34,730
instead of putting the the code in

00:14:31,160 --> 00:14:37,190
common so it was quite quite quite mess

00:14:34,730 --> 00:14:42,829
but it was not visible at the first

00:14:37,190 --> 00:14:45,890
sight so so we started to do to clean up

00:14:42,829 --> 00:14:47,930
clean up the mess and we started with

00:14:45,890 --> 00:14:51,110
isolated rules because Iceland for the

00:14:47,930 --> 00:14:53,709
win when you need to enforce something

00:14:51,110 --> 00:14:57,709
which can be done by static analysis

00:14:53,709 --> 00:15:00,890
just try to write a static excellent

00:14:57,709 --> 00:15:03,350
rule for it because there is no chance

00:15:00,890 --> 00:15:06,140
that if you write it in some code review

00:15:03,350 --> 00:15:08,690
guideline that people will not overload

00:15:06,140 --> 00:15:11,930
pigs will stick to it you have to really

00:15:08,690 --> 00:15:12,259
enforce it properly so we started to

00:15:11,930 --> 00:15:14,600
write

00:15:12,259 --> 00:15:18,499
a lot of excellent rules for restricted

00:15:14,600 --> 00:15:22,009
paths world can be imported from where

00:15:18,499 --> 00:15:25,189
and start cleaning cleaning up to code

00:15:22,009 --> 00:15:28,309
and pretty much breaking up all the all

00:15:25,189 --> 00:15:31,069
the notes which are going to the

00:15:28,309 --> 00:15:37,939
codebase together but they didn't have

00:15:31,069 --> 00:15:40,369
to it was just our fault we took also an

00:15:37,939 --> 00:15:42,289
extra step for length in page because

00:15:40,369 --> 00:15:50,359
the one the landing page loading time

00:15:42,289 --> 00:15:53,089
was the most important for us so we

00:15:50,359 --> 00:15:55,669
really what we really wanted to achieve

00:15:53,089 --> 00:15:59,660
was that for running page we would load

00:15:55,669 --> 00:16:01,819
just the code which is needed for to be

00:15:59,660 --> 00:16:03,529
run on the on the landing page so we

00:16:01,819 --> 00:16:06,410
will not waste time parsing and

00:16:03,529 --> 00:16:08,989
executing the common common code which

00:16:06,410 --> 00:16:11,359
ended up in a common chunk and load it

00:16:08,989 --> 00:16:14,989
on the landing page but was not actually

00:16:11,359 --> 00:16:18,470
used there so we ended up with two

00:16:14,989 --> 00:16:22,789
common common chunks the first one was

00:16:18,470 --> 00:16:24,980
the was the one was the common part of

00:16:22,789 --> 00:16:27,799
the code but was landing on the landing

00:16:24,980 --> 00:16:30,259
page and in the includes just the common

00:16:27,799 --> 00:16:32,899
code shared by the landing page and the

00:16:30,259 --> 00:16:37,339
other modules and the second chunk was

00:16:32,899 --> 00:16:39,289
the common code loaded shared just

00:16:37,339 --> 00:16:42,019
between the rest of the of the other

00:16:39,289 --> 00:16:44,509
chunks so on landing page reload the

00:16:42,019 --> 00:16:49,759
just the first one and all of the other

00:16:44,509 --> 00:16:53,119
pages really loved it this they say this

00:16:49,759 --> 00:16:56,230
was a great saving for us it saved us

00:16:53,119 --> 00:17:01,009
like 20 percent of the of the code size

00:16:56,230 --> 00:17:02,629
so this this we were on a really good

00:17:01,009 --> 00:17:04,789
track here

00:17:02,629 --> 00:17:07,370
the second optimization we made here was

00:17:04,789 --> 00:17:09,169
that we separated the so called stable

00:17:07,370 --> 00:17:12,350
libraries and the dependencies which we

00:17:09,169 --> 00:17:16,519
do not update very often like react

00:17:12,350 --> 00:17:21,470
maybe style components which which are

00:17:16,519 --> 00:17:24,860
not like crazy updated or and but only

00:17:21,470 --> 00:17:25,510
on just some regular basis so that we

00:17:24,860 --> 00:17:29,190
can use

00:17:25,510 --> 00:17:31,960
we can cash it for four regular users

00:17:29,190 --> 00:17:35,800
this also helped much wait for

00:17:31,960 --> 00:17:38,320
subsequent wizards even some more

00:17:35,800 --> 00:17:42,190
optimizations with it and summarize it

00:17:38,320 --> 00:17:44,590
on one slide pretty much we prepared two

00:17:42,190 --> 00:17:47,620
different bundles modern one and the

00:17:44,590 --> 00:17:51,310
legacy one and we serve them based on

00:17:47,620 --> 00:17:53,200
the browser so there is a great

00:17:51,310 --> 00:17:55,750
advantage when you do not have to

00:17:53,200 --> 00:17:59,440
transpile the code to some some some

00:17:55,750 --> 00:18:02,650
legacy constructs and use directly what

00:17:59,440 --> 00:18:05,250
browser is allowing you you to use it

00:18:02,650 --> 00:18:08,350
results in a lot less lines of code

00:18:05,250 --> 00:18:09,970
pretty much we could drop majority of

00:18:08,350 --> 00:18:13,060
the polyfills for new web browser

00:18:09,970 --> 00:18:17,970
sectors and we saved around around 10 to

00:18:13,060 --> 00:18:20,980
15% just a trace translation itself I

00:18:17,970 --> 00:18:23,890
also strongly advise to start pre

00:18:20,980 --> 00:18:28,470
connecting to domains which are which

00:18:23,890 --> 00:18:32,830
have and provide blocking resources I

00:18:28,470 --> 00:18:35,380
even suggest to shave off some time by

00:18:32,830 --> 00:18:38,890
declaring in your head head of the

00:18:35,380 --> 00:18:43,360
document the the scripts which need to

00:18:38,890 --> 00:18:46,000
be pre-loaded so it will not block the

00:18:43,360 --> 00:18:49,120
parsing but the browser will start start

00:18:46,000 --> 00:18:52,180
fetching those resources and also

00:18:49,120 --> 00:18:55,240
optionally as I said we want to minimize

00:18:52,180 --> 00:18:57,460
the loading which is which is which is

00:18:55,240 --> 00:19:00,190
shown to user because the code is not

00:18:57,460 --> 00:19:03,670
loaded yet so we started to pretty

00:19:00,190 --> 00:19:06,220
heavily use also prefetching but only in

00:19:03,670 --> 00:19:07,720
times of course when the user will

00:19:06,220 --> 00:19:10,650
choose that now is the right time to

00:19:07,720 --> 00:19:14,200
prefetch the code and not forcing it to

00:19:10,650 --> 00:19:19,930
fetch it at times when it has a lot of

00:19:14,200 --> 00:19:22,690
work to do - - to load - all the page we

00:19:19,930 --> 00:19:25,660
lazy load each other assets assets which

00:19:22,690 --> 00:19:27,760
which which we could of all off screen

00:19:25,660 --> 00:19:33,420
screen contact account content all the

00:19:27,760 --> 00:19:37,720
images all the non-critical CSS so this

00:19:33,420 --> 00:19:41,710
say that saved us another Millis

00:19:37,720 --> 00:19:43,500
constants of milliseconds and and a lot

00:19:41,710 --> 00:19:48,400
of a lot of bandwidth

00:19:43,500 --> 00:19:51,490
during the first lot just to keep the

00:19:48,400 --> 00:19:56,380
bar high do not rely on the code reviews

00:19:51,490 --> 00:19:58,780
only you have to just enforce it by

00:19:56,380 --> 00:20:01,960
rules against back best bad practices

00:19:58,780 --> 00:20:04,840
and then habits pretty much best

00:20:01,960 --> 00:20:06,100
squirreling what winters are for and I

00:20:04,840 --> 00:20:09,940
would suggest to use them whenever

00:20:06,100 --> 00:20:12,160
possible you need to you need to do at

00:20:09,940 --> 00:20:14,440
least some basic sanity check checks in

00:20:12,160 --> 00:20:16,810
CI for example check for your size

00:20:14,440 --> 00:20:19,510
limits set some proper size limits for

00:20:16,810 --> 00:20:23,320
your chunk and keep tracking them and

00:20:19,510 --> 00:20:24,970
let your pipeline warn you or fail and

00:20:23,320 --> 00:20:27,580
then of course production time

00:20:24,970 --> 00:20:30,760
monitoring on server side the response

00:20:27,580 --> 00:20:33,550
time nineteen ninety fifth percentile

00:20:30,760 --> 00:20:36,550
response time request I'd taking more

00:20:33,550 --> 00:20:39,130
than X milliseconds whatever may feel

00:20:36,550 --> 00:20:42,400
slow for a user and on the client-side

00:20:39,130 --> 00:20:44,860
tools like Pingdom speaker and checking

00:20:42,400 --> 00:20:46,930
their for a total total bundle size time

00:20:44,860 --> 00:20:49,420
to interactive time to first byte and

00:20:46,930 --> 00:20:54,160
and some others if you find them

00:20:49,420 --> 00:20:56,770
interesting and to just wrap it up our

00:20:54,160 --> 00:20:58,840
final results where that after one year

00:20:56,770 --> 00:21:02,710
of gradually factors while I thinking

00:20:58,840 --> 00:21:04,720
features so not no situations like we

00:21:02,710 --> 00:21:07,120
have to stop adding features for a week

00:21:04,720 --> 00:21:08,140
because I have to do one properly factor

00:21:07,120 --> 00:21:12,400
nothing like that

00:21:08,140 --> 00:21:15,160
our HTML size dropped from 200 to twenty

00:21:12,400 --> 00:21:18,280
five kilobytes we got rid of 100

00:21:15,160 --> 00:21:21,550
kilobytes of CSS by using styled

00:21:18,280 --> 00:21:24,130
components and having critical CSS in

00:21:21,550 --> 00:21:26,230
the HTML and our JavaScript size

00:21:24,130 --> 00:21:28,480
decreased not increased so that's also

00:21:26,230 --> 00:21:30,940
pretty important and we managed to

00:21:28,480 --> 00:21:35,320
reduce the time to interactive monitored

00:21:30,940 --> 00:21:40,030
and the page load time by 20% time to

00:21:35,320 --> 00:21:44,410
visual complete by 50 40 % was the

00:21:40,030 --> 00:21:48,580
saving of the JavaScript all together

00:21:44,410 --> 00:21:50,410
and we shaved off nearly 60% of the

00:21:48,580 --> 00:21:51,420
total size of the page so currently

00:21:50,410 --> 00:21:54,280
something

00:21:51,420 --> 00:21:55,600
around two megabytes not five like it

00:21:54,280 --> 00:21:58,480
used to be

00:21:55,600 --> 00:22:01,960
of course like with everything there is

00:21:58,480 --> 00:22:04,570
one catch that is that you need a really

00:22:01,960 --> 00:22:07,270
awesome team full of great full of great

00:22:04,570 --> 00:22:11,500
developers to achieve something like

00:22:07,270 --> 00:22:15,220
that and a constant support so so so

00:22:11,500 --> 00:22:20,700
really big thanks to them but it was a

00:22:15,220 --> 00:22:23,260
great experience that one here yeah I'm

00:22:20,700 --> 00:22:27,760
pretty much that's it does everything

00:22:23,260 --> 00:22:41,110
from me I will not just stop sharing and

00:22:27,760 --> 00:22:44,410
we can move to Q&A so let's see no

00:22:41,110 --> 00:22:48,130
questions there I actually have a

00:22:44,410 --> 00:22:50,800
question oh let's go for it so you

00:22:48,130 --> 00:22:52,450
mentioned that limiting dependencies was

00:22:50,800 --> 00:22:54,280
something that really helped you with

00:22:52,450 --> 00:22:56,680
your bundle sizes and how much

00:22:54,280 --> 00:22:59,350
JavaScript you load how do you feel

00:22:56,680 --> 00:23:01,990
about copy paste dependencies where you

00:22:59,350 --> 00:23:03,550
find a project on github that does what

00:23:01,990 --> 00:23:07,360
you need it and you just copy paste its

00:23:03,550 --> 00:23:09,910
code into your posit ory mm-hmm that's a

00:23:07,360 --> 00:23:13,210
really great question like we have I

00:23:09,910 --> 00:23:15,730
don't think that this is something you

00:23:13,210 --> 00:23:17,260
want to do or on a regular basis or with

00:23:15,730 --> 00:23:19,030
the majority of your dependencies

00:23:17,260 --> 00:23:24,220
because then you have to support them

00:23:19,030 --> 00:23:25,410
all pretty much but I did it I did a few

00:23:24,220 --> 00:23:27,700
things

00:23:25,410 --> 00:23:29,940
sometimes when the dependency is really

00:23:27,700 --> 00:23:32,830
old I just copied it over and just

00:23:29,940 --> 00:23:36,310
rewrite it maybe to something more

00:23:32,830 --> 00:23:39,790
modern and maybe just got rid of the

00:23:36,310 --> 00:23:43,750
unnecessary parts so yeah I think that's

00:23:39,790 --> 00:23:46,210
doable and it can be done the second one

00:23:43,750 --> 00:23:48,690
was that I was forking and I'm still

00:23:46,210 --> 00:23:52,720
actively forking the repositories and

00:23:48,690 --> 00:23:54,640
making them more modern so I will get

00:23:52,720 --> 00:23:56,670
rid of for example two dependencies

00:23:54,640 --> 00:24:00,550
which have known critical dependence

00:23:56,670 --> 00:24:03,010
critical security issues with them and

00:24:00,550 --> 00:24:04,300
this may be the case for example when

00:24:03,010 --> 00:24:07,410
the library is not maintained

00:24:04,300 --> 00:24:10,840
for a year it almost certainly appear

00:24:07,410 --> 00:24:16,030
that these kind of issues so I'm doing

00:24:10,840 --> 00:24:18,190
these two approaches and I feel until

00:24:16,030 --> 00:24:20,800
now I feel fine with it but I wouldn't

00:24:18,190 --> 00:24:26,770
want to do it with many libraries to be

00:24:20,800 --> 00:24:30,160
honest yeah I got the idea from a CD

00:24:26,770 --> 00:24:32,710
light on Twitter he said that when he

00:24:30,160 --> 00:24:34,420
finds a small small package it's easier

00:24:32,710 --> 00:24:37,870
to just copy paste the code rather than

00:24:34,420 --> 00:24:40,780
have another NPM dependency yep even

00:24:37,870 --> 00:24:44,080
even more when the the code is using

00:24:40,780 --> 00:24:46,090
really dependencies which are not really

00:24:44,080 --> 00:24:55,020
necessary on or you do not feel

00:24:46,090 --> 00:24:58,240
comfortable with them so so yeah great

00:24:55,020 --> 00:25:01,810
awesome if you if any of you have any

00:24:58,240 --> 00:25:04,840
questions or I was too fast just write

00:25:01,810 --> 00:25:07,300
the questions down or just get in touch

00:25:04,840 --> 00:25:13,750
with me on the rack to online meetups

00:25:07,300 --> 00:25:16,480
like so feel free everyone ok so it's

00:25:13,750 --> 00:25:19,690
pretty much the stage is yours

00:25:16,480 --> 00:25:23,140
so repair your screen and we are really

00:25:19,690 --> 00:25:26,500
are all excited and looking forward so

00:25:23,140 --> 00:25:31,600
let's bring it on for a guy who is using

00:25:26,500 --> 00:25:38,020
redux for the half of his career so like

00:25:31,600 --> 00:25:40,920
let's do this screen okay so hi everyone

00:25:38,020 --> 00:25:42,970
i'm swiss force wizards depending on how

00:25:40,920 --> 00:25:46,050
Americanized you want to pronounce my

00:25:42,970 --> 00:25:49,660
name today I'm gonna talk to you about a

00:25:46,050 --> 00:25:51,490
pattern not a library it's a pattern I'm

00:25:49,660 --> 00:25:54,010
calling the wormhole state management

00:25:51,490 --> 00:25:56,680
pattern that I kind of developed when I

00:25:54,010 --> 00:25:58,600
was working on a library that some

00:25:56,680 --> 00:26:01,270
people are using and I discovered this

00:25:58,600 --> 00:26:04,300
really cool pattern that lets you manage

00:26:01,270 --> 00:26:06,760
state in a more manageable way without

00:26:04,300 --> 00:26:08,500
using any to any dependencies without

00:26:06,760 --> 00:26:12,700
state management libraries just using

00:26:08,500 --> 00:26:14,500
stuff that's already in react so oh by

00:26:12,700 --> 00:26:16,450
the way I don't have an intro slide

00:26:14,500 --> 00:26:17,330
because I don't like those if you want

00:26:16,450 --> 00:26:18,560
to

00:26:17,330 --> 00:26:21,020
more about me or if you want to reach

00:26:18,560 --> 00:26:23,780
out I think if you types wizards into

00:26:21,020 --> 00:26:27,950
Google you're gonna find a lot of stuff

00:26:23,780 --> 00:26:29,990
about me so I don't know how long you've

00:26:27,950 --> 00:26:32,180
all been react developers but you might

00:26:29,990 --> 00:26:35,090
remember back when react first came on

00:26:32,180 --> 00:26:37,490
the scene it made a huge splash with

00:26:35,090 --> 00:26:39,620
this unidirectional state management

00:26:37,490 --> 00:26:42,820
system or unidirectional data flow

00:26:39,620 --> 00:26:46,460
because back then this was what 2014

00:26:42,820 --> 00:26:47,990
2015 I don't have a mouse when I'm

00:26:46,460 --> 00:26:50,950
presenting that's fun cool

00:26:47,990 --> 00:26:54,290
so I can't open the chatroom so back in

00:26:50,950 --> 00:26:56,720
2015 2016 somewhere thereabouts the way

00:26:54,290 --> 00:27:01,640
we used to build these web apps was that

00:26:56,720 --> 00:27:04,100
you had a lot of painful pain with doing

00:27:01,640 --> 00:27:05,870
state management you could either use an

00:27:04,100 --> 00:27:08,000
event based system like backbone which

00:27:05,870 --> 00:27:10,490
very quickly grew to a point where you

00:27:08,000 --> 00:27:11,990
just had no idea what's going on you

00:27:10,490 --> 00:27:15,410
click the button and a bunch of events

00:27:11,990 --> 00:27:17,330
fired and you really couldn't tell what

00:27:15,410 --> 00:27:19,670
was gonna happen when you did anything

00:27:17,330 --> 00:27:23,000
on the page or there was still a lot of

00:27:19,670 --> 00:27:26,300
jQuery stuff things like that where

00:27:23,000 --> 00:27:28,700
every state update caused a bunch of

00:27:26,300 --> 00:27:32,180
rear Enders and a bunch of Dom reflows

00:27:28,700 --> 00:27:35,710
and it was just terrible so then oh and

00:27:32,180 --> 00:27:37,970
the other popular one was angular with

00:27:35,710 --> 00:27:39,440
bi-directional data flows where he had

00:27:37,970 --> 00:27:41,840
bi-directional binding and you could

00:27:39,440 --> 00:27:43,700
change the state of some variable and it

00:27:41,840 --> 00:27:45,530
would magically update everything that

00:27:43,700 --> 00:27:47,210
dependent on that variable which sounds

00:27:45,530 --> 00:27:50,650
really cool when you're building small

00:27:47,210 --> 00:27:54,230
temos but then it very quickly becomes

00:27:50,650 --> 00:27:57,920
very painful and grows gets out of hand

00:27:54,230 --> 00:27:59,900
and you just I'm actually not it

00:27:57,920 --> 00:28:01,940
basically becomes pretty problematic

00:27:59,900 --> 00:28:04,340
very quickly that I don't know if you've

00:28:01,940 --> 00:28:06,920
worked with code bases like that but it

00:28:04,340 --> 00:28:08,270
doesn't feel nice when you change

00:28:06,920 --> 00:28:10,700
something and you don't know exactly

00:28:08,270 --> 00:28:13,250
what's going to happen or you have to

00:28:10,700 --> 00:28:15,740
trace too much of the code to figure out

00:28:13,250 --> 00:28:17,960
how things are actually working so the

00:28:15,740 --> 00:28:20,090
UNIVAC unidirectional data flow was this

00:28:17,960 --> 00:28:23,360
wonderful idea from the Facebook team

00:28:20,090 --> 00:28:25,460
from Facebook's react team where you

00:28:23,360 --> 00:28:27,800
could suddenly understand how your

00:28:25,460 --> 00:28:30,830
entire application work data would

00:28:27,800 --> 00:28:33,260
always go just in one direction from the

00:28:30,830 --> 00:28:34,789
from your top component all the way down

00:28:33,260 --> 00:28:36,649
through your component tree to the

00:28:34,789 --> 00:28:38,450
bottom where something changed so you

00:28:36,649 --> 00:28:43,549
always knew exactly what was happening

00:28:38,450 --> 00:28:45,470
the idea was that your your UI would be

00:28:43,549 --> 00:28:48,529
a direct representation of state you

00:28:45,470 --> 00:28:50,330
would always know okay this is if I

00:28:48,529 --> 00:28:52,730
change state I know that everything

00:28:50,330 --> 00:28:55,279
updates and I don't have weird

00:28:52,730 --> 00:28:58,190
additional things on top of my head

00:28:55,279 --> 00:29:00,049
updates actually D sorry the chatroom

00:28:58,190 --> 00:29:02,690
notification is really bugging me so I

00:29:00,049 --> 00:29:06,950
have to click that maybe I can see the

00:29:02,690 --> 00:29:07,909
chat while I'm doing now it just shows

00:29:06,950 --> 00:29:11,750
there you go

00:29:07,909 --> 00:29:13,250
okay so okay so now I can see the chat I

00:29:11,750 --> 00:29:16,179
don't know if you can see the chat while

00:29:13,250 --> 00:29:19,940
I'm sharing the screen but whatever so

00:29:16,179 --> 00:29:22,750
basically the idea of the unidirectional

00:29:19,940 --> 00:29:24,860
data flow was that it makes your

00:29:22,750 --> 00:29:27,110
application more understandable your

00:29:24,860 --> 00:29:28,639
data is going only in one direction

00:29:27,110 --> 00:29:30,169
you always know what's happening you are

00:29:28,639 --> 00:29:32,450
is a pure representation of state

00:29:30,169 --> 00:29:34,909
because you have all of your states

00:29:32,450 --> 00:29:36,590
stored in a single source of truth it's

00:29:34,909 --> 00:29:38,809
very easy to sync between different

00:29:36,590 --> 00:29:40,639
components so you can know what's going

00:29:38,809 --> 00:29:42,590
on you can say okay I'm rendering

00:29:40,639 --> 00:29:45,169
something all the way here on the left

00:29:42,590 --> 00:29:47,299
and it depends on something a component

00:29:45,169 --> 00:29:49,970
over here on the right path and you

00:29:47,299 --> 00:29:51,590
connect them together over the single

00:29:49,970 --> 00:29:53,720
source of truth and everything is

00:29:51,590 --> 00:29:56,899
updating in super-awesome so that was

00:29:53,720 --> 00:29:58,850
nice but I think we kind of you know

00:29:56,899 --> 00:30:01,940
started taking it way too far

00:29:58,850 --> 00:30:03,799
we everybody who was teaching reacted

00:30:01,940 --> 00:30:05,659
back then and I think it still happens a

00:30:03,799 --> 00:30:09,440
lot was saying you should put everything

00:30:05,659 --> 00:30:10,850
in a in your top component top component

00:30:09,440 --> 00:30:12,590
should hold your state and you should

00:30:10,850 --> 00:30:14,750
hold the state for your entire

00:30:12,590 --> 00:30:17,000
application and then you had to deal

00:30:14,750 --> 00:30:18,380
with prop drilling you had to pass

00:30:17,000 --> 00:30:20,950
everything down then you have to pass

00:30:18,380 --> 00:30:23,659
callbacks back up this up the state tree

00:30:20,950 --> 00:30:25,610
so the property line was a huge problem

00:30:23,659 --> 00:30:27,950
you ended up with extremely tight

00:30:25,610 --> 00:30:29,929
coupling between components so if you

00:30:27,950 --> 00:30:32,929
wanted to move a component from the

00:30:29,929 --> 00:30:35,389
bottom of your Dom tree or of your

00:30:32,929 --> 00:30:37,519
reactor 3 to a different part you

00:30:35,389 --> 00:30:40,700
suddenly have to change every component

00:30:37,519 --> 00:30:42,590
that was on that path so everything that

00:30:40,700 --> 00:30:44,190
was between the component you were

00:30:42,590 --> 00:30:48,029
actually changing and

00:30:44,190 --> 00:30:49,440
component that was so everything that

00:30:48,029 --> 00:30:50,700
was between the component that held

00:30:49,440 --> 00:30:52,620
state and the component you were

00:30:50,700 --> 00:30:53,970
actually changing you had to change all

00:30:52,620 --> 00:30:55,799
of that if you wanted to move your

00:30:53,970 --> 00:30:56,789
component somewhere else so that was a

00:30:55,799 --> 00:30:59,940
huge pain in the ass

00:30:56,789 --> 00:31:01,769
so people very smart people were like

00:30:59,940 --> 00:31:05,240
you know what we can save we can solve

00:31:01,769 --> 00:31:07,379
with state libraries so then we had this

00:31:05,240 --> 00:31:09,960
proliferation of state libraries we had

00:31:07,379 --> 00:31:12,000
Redux we have mo bags I think we had a

00:31:09,960 --> 00:31:14,580
couple of others Redux and mobile

00:31:12,000 --> 00:31:17,840
scanning Redux and mo bags I think are

00:31:14,580 --> 00:31:20,370
still the main ones that people use and

00:31:17,840 --> 00:31:22,500
they're great they're awesome libraries

00:31:20,370 --> 00:31:25,049
amazing to use whenever when you're

00:31:22,500 --> 00:31:26,490
starting out well maybe they're not

00:31:25,049 --> 00:31:29,279
amazing to use when you're first

00:31:26,490 --> 00:31:32,100
starting out because it makes your

00:31:29,279 --> 00:31:35,279
application really complicated makes it

00:31:32,100 --> 00:31:37,139
very hard to know well it makes it

00:31:35,279 --> 00:31:39,659
relatively easy to know what's going on

00:31:37,139 --> 00:31:42,720
but the complexity of your application

00:31:39,659 --> 00:31:44,700
basically just explodes suddenly you

00:31:42,720 --> 00:31:46,409
need to change five files if you want to

00:31:44,700 --> 00:31:48,240
change how something works you need to

00:31:46,409 --> 00:31:50,340
add reducers you need to add actions

00:31:48,240 --> 00:31:52,350
then people are saying you should have

00:31:50,340 --> 00:31:54,090
all of your actions in one file but then

00:31:52,350 --> 00:31:56,700
your files become too big and you start

00:31:54,090 --> 00:31:59,340
changing things into sagas or chunks or

00:31:56,700 --> 00:32:02,429
whatever other things there are but

00:31:59,340 --> 00:32:04,379
basically your codebase becomes really

00:32:02,429 --> 00:32:06,840
difficult to understand whenever you

00:32:04,379 --> 00:32:09,000
change something you suddenly don't know

00:32:06,840 --> 00:32:11,789
everything it's connected to which is

00:32:09,000 --> 00:32:13,860
fine in a way because potentially if the

00:32:11,789 --> 00:32:16,019
abstractions are well done you don't

00:32:13,860 --> 00:32:18,000
want to know everything that's connected

00:32:16,019 --> 00:32:20,940
to your component right or connect it to

00:32:18,000 --> 00:32:23,009
your state you also get this really nice

00:32:20,940 --> 00:32:25,740
separation where you have a state layer

00:32:23,009 --> 00:32:27,840
that handle that lives outside of your

00:32:25,740 --> 00:32:29,460
component tree so that so it becomes

00:32:27,840 --> 00:32:32,009
easy to change to move components around

00:32:29,460 --> 00:32:35,279
you just hook them up to your Redux

00:32:32,009 --> 00:32:37,740
state or to your my back state and it

00:32:35,279 --> 00:32:39,629
kind of just works right it's a pain in

00:32:37,740 --> 00:32:41,639
the ass to set up you have to deal with

00:32:39,629 --> 00:32:43,799
a lot of boilerplate code to get

00:32:41,639 --> 00:32:44,250
everything working and set up and

00:32:43,799 --> 00:32:46,980
running

00:32:44,250 --> 00:32:50,190
when a new junior joins your team they

00:32:46,980 --> 00:32:52,409
probably really struggle with how to

00:32:50,190 --> 00:32:55,200
make anything work here but there's just

00:32:52,409 --> 00:32:57,850
a lot to understand you have a lot of

00:32:55,200 --> 00:32:59,620
complexity and what I think is

00:32:57,850 --> 00:33:01,600
the biggest problem of these libraries

00:32:59,620 --> 00:33:04,930
is that they break the colocation

00:33:01,600 --> 00:33:07,300
principle so suddenly what you're doing

00:33:04,930 --> 00:33:09,190
and what you're displaying or your UI

00:33:07,300 --> 00:33:11,290
and your business logic user

00:33:09,190 --> 00:33:13,750
interactions and all of that are just

00:33:11,290 --> 00:33:17,260
not close together anymore you have to

00:33:13,750 --> 00:33:21,520
keep a lot of context in mind to be able

00:33:17,260 --> 00:33:24,820
to make any change you have to I don't

00:33:21,520 --> 00:33:26,560
know how often you've approached a redux

00:33:24,820 --> 00:33:28,240
or mobile code base that somebody else

00:33:26,560 --> 00:33:30,040
built you weren't the one building it

00:33:28,240 --> 00:33:32,470
but if you don't understand

00:33:30,040 --> 00:33:34,600
the entire system it becomes almost

00:33:32,470 --> 00:33:37,750
impossible to understand how anything

00:33:34,600 --> 00:33:41,410
works I remember walking into a saga

00:33:37,750 --> 00:33:44,890
based into a saga based project once and

00:33:41,410 --> 00:33:48,070
it took me three or four days just to

00:33:44,890 --> 00:33:50,290
barely understand how it works because

00:33:48,070 --> 00:33:52,420
you could click something and a bunch of

00:33:50,290 --> 00:33:54,520
things happened and then a bunch of

00:33:52,420 --> 00:33:57,010
other things changed and I had a bun I

00:33:54,520 --> 00:33:58,960
had a lot of unknown side effects where

00:33:57,010 --> 00:34:00,460
things were really rendering and

00:33:58,960 --> 00:34:04,270
changing that I didn't even know existed

00:34:00,460 --> 00:34:07,210
or I wanted to just change how a button

00:34:04,270 --> 00:34:08,800
works and I changed that I made the made

00:34:07,210 --> 00:34:10,690
that small change in the button and

00:34:08,800 --> 00:34:12,550
suddenly my header started changing and

00:34:10,690 --> 00:34:14,500
I was like what no i didn't i don't want

00:34:12,550 --> 00:34:15,970
my header to change in all in all cases

00:34:14,500 --> 00:34:19,330
maybe i just want to change it in in

00:34:15,970 --> 00:34:20,950
some cases so all of that becomes really

00:34:19,330 --> 00:34:23,860
difficult and means that you have to be

00:34:20,950 --> 00:34:26,379
able to basically hold your your entire

00:34:23,860 --> 00:34:28,960
code base in your mind which is great as

00:34:26,379 --> 00:34:31,030
long as it's a small codebase if you use

00:34:28,960 --> 00:34:32,770
end this principle of splitting up your

00:34:31,030 --> 00:34:35,230
monolith it's great because you can have

00:34:32,770 --> 00:34:36,970
small simple apps each deployed in a

00:34:35,230 --> 00:34:39,460
separate gem stack or wherever you

00:34:36,970 --> 00:34:41,590
deploy them so that kind of helps with

00:34:39,460 --> 00:34:44,560
that complexity but eventually your

00:34:41,590 --> 00:34:47,169
complexity is going to grow I know we

00:34:44,560 --> 00:34:48,820
try to work with micro front-ends and

00:34:47,169 --> 00:34:51,399
that never really went anywhere and was

00:34:48,820 --> 00:34:54,669
a huge failure so what I'm gonna propose

00:34:51,399 --> 00:34:57,640
today is a new way of managing your

00:34:54,669 --> 00:35:00,730
state that mostly solves all of these

00:34:57,640 --> 00:35:02,770
problems and makes your life a lot

00:35:00,730 --> 00:35:05,470
better and I'm calling it the world warm

00:35:02,770 --> 00:35:07,960
call state management because it's based

00:35:05,470 --> 00:35:11,300
on the idea that you have a lot of local

00:35:07,960 --> 00:35:13,250
state combo localized to the smaller

00:35:11,300 --> 00:35:15,050
possible part of your state tree and

00:35:13,250 --> 00:35:16,630
then you have one calls to make

00:35:15,050 --> 00:35:19,040
different parts of your state

00:35:16,630 --> 00:35:21,860
communicate with each other so the

00:35:19,040 --> 00:35:23,570
principle is that when you have state

00:35:21,860 --> 00:35:25,370
that belongs just to a single component

00:35:23,570 --> 00:35:27,380
where just a single component cares

00:35:25,370 --> 00:35:30,530
about that you can just use local state

00:35:27,380 --> 00:35:32,480
with react hooks now it's super easy to

00:35:30,530 --> 00:35:34,550
use local state without too much trouble

00:35:32,480 --> 00:35:36,290
you don't have to deal with the set

00:35:34,550 --> 00:35:38,960
state you still have a set state

00:35:36,290 --> 00:35:40,910
function but it you don't have to build

00:35:38,960 --> 00:35:42,890
a class-based component just to have

00:35:40,910 --> 00:35:45,470
state you can use functional components

00:35:42,890 --> 00:35:47,990
which are in my opinion - or to work

00:35:45,470 --> 00:35:50,060
with and you can use look state locally

00:35:47,990 --> 00:35:52,130
and it's self-contained within the

00:35:50,060 --> 00:35:54,380
component anyone who looks at that

00:35:52,130 --> 00:35:56,060
component can always know everything the

00:35:54,380 --> 00:35:58,130
death component does all of the business

00:35:56,060 --> 00:36:00,020
logic it's using you can then if you

00:35:58,130 --> 00:36:01,460
have different components that work

00:36:00,020 --> 00:36:04,880
tightly together that are really

00:36:01,460 --> 00:36:06,470
actually tightly coupled like well we'll

00:36:04,880 --> 00:36:08,780
do some examples later but let's say you

00:36:06,470 --> 00:36:10,550
have a button and a display component

00:36:08,780 --> 00:36:12,800
next to it that shows how many times

00:36:10,550 --> 00:36:14,660
that button has been clicked you can

00:36:12,800 --> 00:36:16,220
just share state between those two

00:36:14,660 --> 00:36:19,010
components you don't have to go all the

00:36:16,220 --> 00:36:21,050
way around to your global state just to

00:36:19,010 --> 00:36:25,010
change something that it's that's right

00:36:21,050 --> 00:36:28,070
next to you imagine imagine if every

00:36:25,010 --> 00:36:31,040
time you want to ask your coworker to

00:36:28,070 --> 00:36:33,500
help you out with something you would

00:36:31,040 --> 00:36:35,420
have to write a form a formal request

00:36:33,500 --> 00:36:37,400
for help then you would have to pass it

00:36:35,420 --> 00:36:40,160
on to your manager then your manager

00:36:37,400 --> 00:36:41,840
would pass it on to his manager then his

00:36:40,160 --> 00:36:45,040
manager would pass it on to her manager

00:36:41,840 --> 00:36:47,150
and then the CEO would look at that for

00:36:45,040 --> 00:36:50,330
request for help and she would be like

00:36:47,150 --> 00:36:53,060
me yes it does sound likes wizards needs

00:36:50,330 --> 00:36:55,760
needs and his help okay this is good and

00:36:53,060 --> 00:36:58,250
then she would put that into HR and then

00:36:55,760 --> 00:37:00,290
HR would look at it eventually and maybe

00:36:58,250 --> 00:37:02,000
five days later it would come back to nd

00:37:00,290 --> 00:37:03,710
who's sitting right next to you and she

00:37:02,000 --> 00:37:05,150
would say yeah totally you can just

00:37:03,710 --> 00:37:07,040
click that button over there or just

00:37:05,150 --> 00:37:09,170
copy/paste that thing and it's gonna be

00:37:07,040 --> 00:37:11,240
fine so that's that's kind of how we

00:37:09,170 --> 00:37:13,250
work with redux and Moe backs is if you

00:37:11,240 --> 00:37:16,340
go all the way around to do the simplest

00:37:13,250 --> 00:37:18,560
possible things so with the more with

00:37:16,340 --> 00:37:21,200
the one call pattern you get the

00:37:18,560 --> 00:37:22,850
colocation of logic so anyone who looks

00:37:21,200 --> 00:37:23,330
at the component can always understand

00:37:22,850 --> 00:37:27,050
that

00:37:23,330 --> 00:37:28,640
you minimize you as a as the result you

00:37:27,050 --> 00:37:30,710
also minimize the amount of code that

00:37:28,640 --> 00:37:32,840
needs to be understood because you'll

00:37:30,710 --> 00:37:35,690
see with some react hooks you can then

00:37:32,840 --> 00:37:38,600
make it very easy to share state between

00:37:35,690 --> 00:37:41,060
components without introducing a lot of

00:37:38,600 --> 00:37:43,400
extra code you're not using any

00:37:41,060 --> 00:37:45,770
libraries which is great for performance

00:37:43,400 --> 00:37:47,660
because it means you're not downloading

00:37:45,770 --> 00:37:50,360
extra libraries you're not compiling

00:37:47,660 --> 00:37:52,550
extra libraries you're just using every

00:37:50,360 --> 00:37:55,580
stuff that comes with react already and

00:37:52,550 --> 00:37:57,560
at least in my experience this scale

00:37:55,580 --> 00:37:59,750
this same approach scales pretty well

00:37:57,560 --> 00:38:03,380
from very small apps that you're

00:37:59,750 --> 00:38:05,420
building is a tiny example to huge apps

00:38:03,380 --> 00:38:07,340
that need that have a lot of different

00:38:05,420 --> 00:38:10,270
layers or a lot of different segments of

00:38:07,340 --> 00:38:14,030
the app that needs to work together so

00:38:10,270 --> 00:38:16,460
rather than talk to you and talk your

00:38:14,030 --> 00:38:19,010
ear off about the theory I figured I

00:38:16,460 --> 00:38:22,400
would just show you how this works if we

00:38:19,010 --> 00:38:25,250
go to this code sandbox over here so you

00:38:22,400 --> 00:38:27,980
should still see my screen and I wanna

00:38:25,250 --> 00:38:30,320
I'm gonna show you how the wormhole

00:38:27,980 --> 00:38:32,510
state management pattern evolves from

00:38:30,320 --> 00:38:36,020
the smallest example to something that

00:38:32,510 --> 00:38:37,910
is more like a bigger app using code and

00:38:36,020 --> 00:38:40,340
a bit of life coding I haven't prepared

00:38:37,910 --> 00:38:41,720
a whole lot in advance because you don't

00:38:40,340 --> 00:38:43,940
need a whole lot in the end that's kind

00:38:41,720 --> 00:38:49,280
of the point of this pattern is that

00:38:43,940 --> 00:38:51,860
it's simple and easy to understand you

00:38:49,280 --> 00:38:53,750
will however need to be relatively

00:38:51,860 --> 00:38:55,730
familiar with hooks because if you're

00:38:53,750 --> 00:38:58,250
not then it doesn't work so let's say we

00:38:55,730 --> 00:39:00,860
have we have this code sign box over

00:38:58,250 --> 00:39:03,890
here and we want to make this plus one

00:39:00,860 --> 00:39:05,840
button that is a simple counter I know

00:39:03,890 --> 00:39:07,520
that this is a contrived example that's

00:39:05,840 --> 00:39:09,650
kind of the point is that we don't have

00:39:07,520 --> 00:39:11,360
to worry too much about the actual logic

00:39:09,650 --> 00:39:13,880
behind it I can let me show you how I

00:39:11,360 --> 00:39:16,850
use this in a more serious application

00:39:13,880 --> 00:39:19,010
but the basic idea is that if you have a

00:39:16,850 --> 00:39:21,590
counter component it doesn't really need

00:39:19,010 --> 00:39:25,100
a whole lot you can say that you have a

00:39:21,590 --> 00:39:28,420
count count and a set count function you

00:39:25,100 --> 00:39:31,060
take those from States you can use a

00:39:28,420 --> 00:39:34,060
starting prop to set the starting value

00:39:31,060 --> 00:39:37,110
then you create a plus one function

00:39:34,060 --> 00:39:39,960
which calls set count

00:39:37,110 --> 00:39:42,570
the current count and returns count plus

00:39:39,960 --> 00:39:46,140
one so very simple function pretty

00:39:42,570 --> 00:39:49,650
simple logic we when we click the button

00:39:46,140 --> 00:39:52,470
we're going to call plus one and let's

00:39:49,650 --> 00:39:57,000
also display the current count like this

00:39:52,470 --> 00:39:59,130
I'm gonna add a breakpoint here but that

00:39:57,000 --> 00:40:01,890
so now when I click on this you see the

00:39:59,130 --> 00:40:04,230
count goes down I have am using

00:40:01,890 --> 00:40:07,320
completely local state all of my logic

00:40:04,230 --> 00:40:09,270
is contained in the component and it's

00:40:07,320 --> 00:40:11,220
still a functional component and just

00:40:09,270 --> 00:40:14,160
set saying okay count is now a state

00:40:11,220 --> 00:40:17,780
whenever I call the set count function

00:40:14,160 --> 00:40:20,520
it get it takes as its first argument a

00:40:17,780 --> 00:40:22,140
it takes it takes a function as an

00:40:20,520 --> 00:40:24,300
argument so that we can make it more

00:40:22,140 --> 00:40:26,190
dynamic Rick the current count from

00:40:24,300 --> 00:40:28,110
state and updates the state which then

00:40:26,190 --> 00:40:30,120
triggers already render of the counter

00:40:28,110 --> 00:40:32,120
component so we now have a counter

00:40:30,120 --> 00:40:34,470
component that works completely

00:40:32,120 --> 00:40:36,630
independently we can make multiple of

00:40:34,470 --> 00:40:39,210
them and it's still gonna work might

00:40:36,630 --> 00:40:42,990
need to add me let's turn this into a

00:40:39,210 --> 00:40:45,600
div so they don't overlap so we now have

00:40:42,990 --> 00:40:48,030
to counter components that have separate

00:40:45,600 --> 00:40:49,800
pieces of state and you can render this

00:40:48,030 --> 00:40:52,350
anywhere and it's completely independent

00:40:49,800 --> 00:40:54,300
and it always know what's HAP happening

00:40:52,350 --> 00:40:58,590
let's say this one needs to start from

00:40:54,300 --> 00:41:00,420
five loads OC Code sandbox is nice

00:40:58,590 --> 00:41:02,970
enough to actually maintain state

00:41:00,420 --> 00:41:06,750
between reloads so that worked nice as

00:41:02,970 --> 00:41:08,910
well so you see that hot reloading works

00:41:06,750 --> 00:41:12,090
with this approach and all of that stuff

00:41:08,910 --> 00:41:15,270
now let's say that the each count

00:41:12,090 --> 00:41:17,880
component needs to have a separate

00:41:15,270 --> 00:41:20,070
display component and that display

00:41:17,880 --> 00:41:21,660
component could be further down into

00:41:20,070 --> 00:41:23,910
three but they're two they're basically

00:41:21,660 --> 00:41:27,320
two components that work together so

00:41:23,910 --> 00:41:31,190
we're gonna say if it's a display and

00:41:27,320 --> 00:41:36,480
it's gonna get count as a normal prop

00:41:31,190 --> 00:41:39,840
but then say consti display is component

00:41:36,480 --> 00:41:42,420
that gets some count and it returns a

00:41:39,840 --> 00:41:45,270
function that's going to render

00:41:42,420 --> 00:41:47,940
paragraph which is going to show that

00:41:45,270 --> 00:41:50,640
count now no longer need the breakpoint

00:41:47,940 --> 00:41:52,259
now I know this still looks

00:41:50,640 --> 00:41:55,109
this still looks kind of lame and like a

00:41:52,259 --> 00:41:59,789
stupid example but imagine if this were

00:41:55,109 --> 00:42:04,200
three components deep or if it was like

00:41:59,789 --> 00:42:06,930
this could be I don't know a widget on

00:42:04,200 --> 00:42:08,730
your page somewhere that has something

00:42:06,930 --> 00:42:10,980
where five to five components need to

00:42:08,730 --> 00:42:12,720
work closely together we can also say

00:42:10,980 --> 00:42:14,910
that okay you know what might these

00:42:12,720 --> 00:42:17,609
default buttons are kind of lame let's

00:42:14,910 --> 00:42:20,249
make a red button component that looks

00:42:17,609 --> 00:42:23,460
better so we create a red button

00:42:20,249 --> 00:42:29,819
component and this one is going to get

00:42:23,460 --> 00:42:33,150
the set count callback and we return a

00:42:29,819 --> 00:42:36,329
button that has let's research plus one

00:42:33,150 --> 00:42:40,829
so let's put in plus one and it's on

00:42:36,329 --> 00:42:44,069
click and let's give it a background red

00:42:40,829 --> 00:42:47,489
so that you can see it's red button so

00:42:44,069 --> 00:42:53,489
we now have a heart we need to actually

00:42:47,489 --> 00:42:55,440
pass it in nice when when Eddie suddenly

00:42:53,489 --> 00:42:58,259
starts reminding us that we forgot stuff

00:42:55,440 --> 00:43:00,299
so we have we still have a pretty simple

00:42:58,259 --> 00:43:02,759
approach where we have a button that

00:43:00,299 --> 00:43:04,710
does counting and we have a display and

00:43:02,759 --> 00:43:07,039
we are doing this is basically the old

00:43:04,710 --> 00:43:10,710
prop drilling approach where we have

00:43:07,039 --> 00:43:13,289
localized state that is shared between

00:43:10,710 --> 00:43:15,779
two components that work very closely

00:43:13,289 --> 00:43:17,730
together this is great for when you need

00:43:15,779 --> 00:43:21,509
to build widgets that are relatively

00:43:17,730 --> 00:43:23,970
self-contained or widgets that are I'm

00:43:21,509 --> 00:43:26,670
having trouble coming up with a fun

00:43:23,970 --> 00:43:29,279
example but basically imagine if you had

00:43:26,670 --> 00:43:31,380
a header that needs to share some state

00:43:29,279 --> 00:43:33,630
between just a couple of components in

00:43:31,380 --> 00:43:37,349
the header itself you could do that with

00:43:33,630 --> 00:43:40,019
this approach now what if we want to

00:43:37,349 --> 00:43:42,930
contain connect both counters together

00:43:40,019 --> 00:43:45,690
so that they are counting with the same

00:43:42,930 --> 00:43:48,269
the same global state so now we have

00:43:45,690 --> 00:43:50,160
components that live far apart in the

00:43:48,269 --> 00:43:53,249
state tree and they need to work

00:43:50,160 --> 00:43:55,289
together to manage global state we could

00:43:53,249 --> 00:43:58,049
go with redux and do a bunch of stuff

00:43:55,289 --> 00:44:00,569
but instead what I prepared was a

00:43:58,049 --> 00:44:04,020
wormhole context provider so we're now

00:44:00,569 --> 00:44:05,610
going to create a wormhole that

00:44:04,020 --> 00:44:07,740
going to share state between two

00:44:05,610 --> 00:44:10,560
components that are very far apart and

00:44:07,740 --> 00:44:13,940
these two components will have an

00:44:10,560 --> 00:44:16,170
indirect way of communicating without us

00:44:13,940 --> 00:44:19,770
we're going to kind of were kind of

00:44:16,170 --> 00:44:23,490
hoisting state but not too much they do

00:44:19,770 --> 00:44:33,150
here okay so we're going to import the

00:44:23,490 --> 00:44:40,170
wormhole context provider from doesn't

00:44:33,150 --> 00:44:44,580
it autocomplete and the wormhole context

00:44:40,170 --> 00:44:46,890
provider is a react component that does

00:44:44,580 --> 00:44:48,840
a few things with its own local state to

00:44:46,890 --> 00:44:51,180
make the state shareable and I'll show

00:44:48,840 --> 00:44:54,600
you how that works so we take these two

00:44:51,180 --> 00:44:58,590
and we render them inside the wormhole

00:44:54,600 --> 00:45:01,410
context provider that so they're now

00:44:58,590 --> 00:45:03,990
both children of the same global

00:45:01,410 --> 00:45:06,720
provider this is similar to your redux

00:45:03,990 --> 00:45:09,450
provider your mo backs provider except

00:45:06,720 --> 00:45:13,590
we're going to do a few tricks to make

00:45:09,450 --> 00:45:16,740
them easier to use let's see so we have

00:45:13,590 --> 00:45:20,250
the wormhole contact provider now we can

00:45:16,740 --> 00:45:23,690
go into our counter and instead of using

00:45:20,250 --> 00:45:26,610
state like this we're going to stay

00:45:23,690 --> 00:45:28,860
we're going to take state from our

00:45:26,610 --> 00:45:32,670
context and we're going to take a little

00:45:28,860 --> 00:45:34,380
function i called set shared count so

00:45:32,670 --> 00:45:39,120
set your count and we say in this

00:45:34,380 --> 00:45:42,690
context it's going to be one context

00:45:39,120 --> 00:45:45,750
which we also need to port so we import

00:45:42,690 --> 00:45:47,970
one call context from here and i'll

00:45:45,750 --> 00:45:51,780
explain a little bit how this works so

00:45:47,970 --> 00:45:56,880
now we have display count which is going

00:45:51,780 --> 00:45:59,790
to display state dot shared count this

00:45:56,880 --> 00:46:01,530
is where if you're using what's it

00:45:59,790 --> 00:46:03,090
called if you're using typescript this

00:46:01,530 --> 00:46:05,670
makes it easier because it gives you

00:46:03,090 --> 00:46:08,400
autocomplete on all of these states and

00:46:05,670 --> 00:46:11,700
stuff I didn't want to deal with that

00:46:08,400 --> 00:46:14,310
because I I just felt like it was too

00:46:11,700 --> 00:46:18,060
much for this example and now instead of

00:46:14,310 --> 00:46:21,570
set count we're going to set share count

00:46:18,060 --> 00:46:28,740
and we're going to just set it to state

00:46:21,570 --> 00:46:32,310
dollar shirt state shirt how did I

00:46:28,740 --> 00:46:35,370
actually call it plus one no it's not

00:46:32,310 --> 00:46:39,060
kept we take the new state dog shirt

00:46:35,370 --> 00:46:41,700
count plus one and now in theory this

00:46:39,060 --> 00:46:45,060
should just magically work as long as we

00:46:41,700 --> 00:46:47,220
import use context from react let's see

00:46:45,060 --> 00:46:50,250
so you see now I'm clicking one button

00:46:47,220 --> 00:46:52,470
and enter both updating yay super

00:46:50,250 --> 00:46:54,450
awesome right and we'll go one step

00:46:52,470 --> 00:46:57,690
further and make this even easier to use

00:46:54,450 --> 00:47:01,050
so we now have two buttons that are

00:46:57,690 --> 00:47:03,600
connected via a context provider so the

00:47:01,050 --> 00:47:05,580
car the reacted context kind of works as

00:47:03,600 --> 00:47:08,220
a wormhole in the background to connect

00:47:05,580 --> 00:47:11,190
to components that are in theory very

00:47:08,220 --> 00:47:15,030
far apart how the contact is does that

00:47:11,190 --> 00:47:18,090
is that we are creating a context called

00:47:15,030 --> 00:47:19,920
wormhole context this will in practice

00:47:18,090 --> 00:47:22,290
you would probably have named this

00:47:19,920 --> 00:47:26,280
differently for different sections of

00:47:22,290 --> 00:47:28,170
your application I forget what those

00:47:26,280 --> 00:47:30,570
would be called in redux because it's

00:47:28,170 --> 00:47:33,390
been around two years since I seriously

00:47:30,570 --> 00:47:35,490
used redux last but the idea is that you

00:47:33,390 --> 00:47:39,930
create this context you put in some

00:47:35,490 --> 00:47:41,820
state and you put in your actions or

00:47:39,930 --> 00:47:43,890
your functions that you use to

00:47:41,820 --> 00:47:46,650
manipulate that's it we're going to make

00:47:43,890 --> 00:47:48,150
that even better in a little bit so then

00:47:46,650 --> 00:47:52,350
then you create a wormhole context

00:47:48,150 --> 00:47:56,910
provider functional component which has

00:47:52,350 --> 00:48:00,510
a state using just local state which is

00:47:56,910 --> 00:48:02,700
a state or with a single variable but

00:48:00,510 --> 00:48:04,890
that variable is an object so we are

00:48:02,700 --> 00:48:08,700
able to have both shared count and you

00:48:04,890 --> 00:48:11,490
can add let's say random string which

00:48:08,700 --> 00:48:14,490
sells random and I'll show you how that

00:48:11,490 --> 00:48:17,340
works later or actually not gonna show

00:48:14,490 --> 00:48:20,940
now so if we now have random string and

00:48:17,340 --> 00:48:25,140
we want to display that over here we can

00:48:20,940 --> 00:48:27,360
say state dot random string and it

00:48:25,140 --> 00:48:30,420
should show up right next to us

00:48:27,360 --> 00:48:31,410
let's see I need to load yeah so we now

00:48:30,420 --> 00:48:33,960
have

00:48:31,410 --> 00:48:36,750
I'm string so basically we're using a

00:48:33,960 --> 00:48:38,990
single piece of state but that state can

00:48:36,750 --> 00:48:42,000
contain an object which then has a

00:48:38,990 --> 00:48:43,650
richer more complex piece of state that

00:48:42,000 --> 00:48:46,049
you did you actually use for your

00:48:43,650 --> 00:48:49,349
application so we have that one called

00:48:46,049 --> 00:48:52,619
context we then we have our initial

00:48:49,349 --> 00:48:54,690
state we have our state state and we

00:48:52,619 --> 00:48:58,380
have the context value which is another

00:48:54,690 --> 00:49:01,440
piece of you state from react that holds

00:48:58,380 --> 00:49:03,720
our application state and help any

00:49:01,440 --> 00:49:06,059
helper methods that we need so right now

00:49:03,720 --> 00:49:08,789
we just have set shared count you could

00:49:06,059 --> 00:49:10,890
then add more actions here or I'll show

00:49:08,789 --> 00:49:14,099
you in a bit you can use reducer to

00:49:10,890 --> 00:49:19,500
clean up this part as well then to avoid

00:49:14,099 --> 00:49:21,630
having multiple rear Enders whenever so

00:49:19,500 --> 00:49:26,059
to avoid having multiple rear Enders we

00:49:21,630 --> 00:49:30,030
then use a use effect to ensure that our

00:49:26,059 --> 00:49:32,280
component only rear Enders when we when

00:49:30,030 --> 00:49:34,530
our internal state changes so not when

00:49:32,280 --> 00:49:36,630
the context value changes but when the

00:49:34,530 --> 00:49:39,690
state's stored inside the context value

00:49:36,630 --> 00:49:41,549
in the object changes then we render in

00:49:39,690 --> 00:49:43,559
Warhawk context provider with our

00:49:41,549 --> 00:49:47,339
context value and all of its children

00:49:43,559 --> 00:49:51,240
which gives us the nested the nested

00:49:47,339 --> 00:49:53,970
stuff below so what's happening now is

00:49:51,240 --> 00:49:57,299
that when Mike when we call set shared

00:49:53,970 --> 00:50:00,900
count that that goes into react

00:49:57,299 --> 00:50:05,430
context via D by the provider goes into

00:50:00,900 --> 00:50:09,359
context value now let me change how I'm

00:50:05,430 --> 00:50:11,670
explaining that so when we now render

00:50:09,359 --> 00:50:14,039
something we take the wormhole context

00:50:11,670 --> 00:50:17,369
out of our react context and we take its

00:50:14,039 --> 00:50:20,039
state and a setter or an a helper method

00:50:17,369 --> 00:50:23,130
when we call that helper method it's

00:50:20,039 --> 00:50:26,579
actually being passed in from our

00:50:23,130 --> 00:50:28,829
context provider which then calls this

00:50:26,579 --> 00:50:31,980
function that we defined here that

00:50:28,829 --> 00:50:36,450
function calls set state and updates the

00:50:31,980 --> 00:50:38,940
state which then triggers a rerender via

00:50:36,450 --> 00:50:40,740
this effect of our entire application of

00:50:38,940 --> 00:50:43,030
everything that depends on that stage

00:50:40,740 --> 00:50:44,890
now this isn't this but

00:50:43,030 --> 00:50:47,170
actually isn't as performant as

00:50:44,890 --> 00:50:48,820
something like mo bags because it

00:50:47,170 --> 00:50:51,280
doesn't keep track of what's actually

00:50:48,820 --> 00:50:53,170
listening to which parts of state but in

00:50:51,280 --> 00:50:55,720
practice it usually works well enough if

00:50:53,170 --> 00:50:57,880
you're using Redux this I think they say

00:50:55,720 --> 00:50:59,890
actually I haven't benchmarked it but

00:50:57,880 --> 00:51:03,340
this should be about as performance in

00:50:59,890 --> 00:51:05,470
swedux so we have that now what we can

00:51:03,340 --> 00:51:07,930
do to make this even easier to use

00:51:05,470 --> 00:51:10,960
here you see we had all of this stuff

00:51:07,930 --> 00:51:13,420
right so we have a have a context and we

00:51:10,960 --> 00:51:16,030
have something that lets us manipulate

00:51:13,420 --> 00:51:17,260
that context and it's kind of nice it's

00:51:16,030 --> 00:51:19,390
nice that we have it in the counter

00:51:17,260 --> 00:51:22,120
component but we can actually make it

00:51:19,390 --> 00:51:24,820
even better let's change let's turn this

00:51:22,120 --> 00:51:29,980
into a custom component so we're going

00:51:24,820 --> 00:51:34,090
to say Const use shared counter you've

00:51:29,980 --> 00:51:35,860
shared count which is going to be a I'll

00:51:34,090 --> 00:51:40,120
just call it the function function use

00:51:35,860 --> 00:51:44,650
share count which doesn't really take

00:51:40,120 --> 00:51:48,010
anything and it takes it takes stuff out

00:51:44,650 --> 00:51:52,180
of context creates a +1 function and

00:51:48,010 --> 00:51:55,480
it's going to return our current state

00:51:52,180 --> 00:51:59,350
or shared count and D plus 1 function

00:51:55,480 --> 00:52:03,700
actually easier to do it this way to

00:51:59,350 --> 00:52:07,510
share count and +1 function so we now

00:52:03,700 --> 00:52:08,380
have a custom hook is this complaining

00:52:07,510 --> 00:52:11,020
ok it's fine

00:52:08,380 --> 00:52:14,110
so we have a custom cook hook called use

00:52:11,020 --> 00:52:16,960
shared count which talks to our react

00:52:14,110 --> 00:52:19,600
context creates the wormhole creates if

00:52:16,960 --> 00:52:22,930
and easier to use function that just

00:52:19,600 --> 00:52:26,230
does +1 and export and returns both of

00:52:22,930 --> 00:52:29,860
those as the count and s +1 so now when

00:52:26,230 --> 00:52:35,680
we go into the counter here we can say

00:52:29,860 --> 00:52:38,640
cost plus 1 equals nil shared count that

00:52:35,680 --> 00:52:41,470
will just work and then display can be

00:52:38,640 --> 00:52:44,320
let's turn that into a display count

00:52:41,470 --> 00:52:47,320
component you can display count which no

00:52:44,320 --> 00:52:51,190
longer needs to take any props instead

00:52:47,320 --> 00:52:55,140
what it can do is say some constant

00:52:51,190 --> 00:53:01,570
shared count equals use

00:52:55,140 --> 00:53:04,630
so it should now just work magically so

00:53:01,570 --> 00:53:07,720
let's see if it does yep so we now

00:53:04,630 --> 00:53:09,640
created a hook that we can use in any

00:53:07,720 --> 00:53:12,130
component no matter where it is in our

00:53:09,640 --> 00:53:15,430
component tree that independently

00:53:12,130 --> 00:53:17,920
connects to our global state or whatever

00:53:15,430 --> 00:53:20,110
shared state we have and uses that state

00:53:17,920 --> 00:53:22,780
work just locally in the same component

00:53:20,110 --> 00:53:29,650
so now if you're if you imagine how this

00:53:22,780 --> 00:53:31,630
works from a what did I do out here so

00:53:29,650 --> 00:53:34,540
now if you imagine how this works from

00:53:31,630 --> 00:53:37,840
the perspective of a junior that's

00:53:34,540 --> 00:53:39,340
joining your team or even you who hasn't

00:53:37,840 --> 00:53:41,500
been working on a part of the code base

00:53:39,340 --> 00:53:43,360
for six months or whatever or you've

00:53:41,500 --> 00:53:45,520
just forgotten what you're doing or how

00:53:43,360 --> 00:53:47,770
it works you can come to the counter

00:53:45,520 --> 00:53:50,380
component and you say okay it's using

00:53:47,770 --> 00:53:52,270
the shared count which is probably some

00:53:50,380 --> 00:53:55,570
context and we're just taking out the

00:53:52,270 --> 00:53:58,480
plus one the plus one function and we

00:53:55,570 --> 00:54:01,420
call it in the red button on click cool

00:53:58,480 --> 00:54:06,070
we can even completely remove this and

00:54:01,420 --> 00:54:09,850
call this the plus button so we change

00:54:06,070 --> 00:54:14,890
this to the plus button we then move

00:54:09,850 --> 00:54:18,460
this over here so we're using the shared

00:54:14,890 --> 00:54:21,490
count hook directly we call plus one and

00:54:18,460 --> 00:54:24,270
you see it's still gonna work so what

00:54:21,490 --> 00:54:26,710
what you just saw is how easy it is to

00:54:24,270 --> 00:54:29,620
refactor your components it's easy to

00:54:26,710 --> 00:54:31,570
move using shared State to a different

00:54:29,620 --> 00:54:33,900
to a completely different component all

00:54:31,570 --> 00:54:35,890
of this component our components are

00:54:33,900 --> 00:54:37,630
relatively independent there are no

00:54:35,890 --> 00:54:39,130
longer tightly coupled they can always

00:54:37,630 --> 00:54:41,890
get your own State

00:54:39,130 --> 00:54:43,630
from the ship from the wormhole and they

00:54:41,890 --> 00:54:45,760
can always use that state to do whatever

00:54:43,630 --> 00:54:48,940
they need with it which is really nice

00:54:45,760 --> 00:54:50,740
because you can then it makes it easier

00:54:48,940 --> 00:54:52,660
to move things around makes it easier to

00:54:50,740 --> 00:54:54,790
refactor it makes easier to say okay

00:54:52,660 --> 00:54:56,800
this is the plus the plus button just

00:54:54,790 --> 00:54:59,710
takes plus one from user that counts and

00:54:56,800 --> 00:55:02,200
the stuff with that and we didn't have

00:54:59,710 --> 00:55:06,970
to use any libraries to achieve this we

00:55:02,200 --> 00:55:09,819
just used a bunch of default we

00:55:06,970 --> 00:55:13,150
I can't okay we used a bunch of default

00:55:09,819 --> 00:55:16,329
react machinery and it all kind of just

00:55:13,150 --> 00:55:20,650
works too you can make this even simpler

00:55:16,329 --> 00:55:22,960
if you go to go here and instead of your

00:55:20,650 --> 00:55:24,670
state you can then use reducer I'm not

00:55:22,960 --> 00:55:27,310
going to show you how to do that because

00:55:24,670 --> 00:55:35,520
I think it would take a little too long

00:55:27,310 --> 00:55:39,069
so there is more flexibility and then

00:55:35,520 --> 00:55:42,579
here instead of a reducer you would then

00:55:39,069 --> 00:55:46,000
just pass any dispatch function on your

00:55:42,579 --> 00:55:47,440
reducer and you then get really calm and

00:55:46,000 --> 00:55:50,079
then you get basically the same

00:55:47,440 --> 00:55:52,180
complexity but not the same complexity

00:55:50,079 --> 00:55:54,550
but you get the same power that you have

00:55:52,180 --> 00:55:57,460
with redux where you can call this patch

00:55:54,550 --> 00:55:59,680
on your reducer which then triggers the

00:55:57,460 --> 00:56:03,730
same stuff here

00:55:59,680 --> 00:56:06,640
the same stuff for your like for the

00:56:03,730 --> 00:56:08,440
rear Enders and all of that kind of a

00:56:06,640 --> 00:56:11,619
kind of trailed off there I'm sorry but

00:56:08,440 --> 00:56:13,359
the idea is that if you like reducers or

00:56:11,619 --> 00:56:15,700
if you have complex state that needs to

00:56:13,359 --> 00:56:18,640
work together you can use reducer and

00:56:15,700 --> 00:56:21,310
you still get all of the same ease of

00:56:18,640 --> 00:56:24,130
use you get the same flexibility you get

00:56:21,310 --> 00:56:26,079
the same collocation of your logic and

00:56:24,130 --> 00:56:29,770
your what you're actually using that

00:56:26,079 --> 00:56:32,260
logic and you can still you can still

00:56:29,770 --> 00:56:34,540
have all of the power that you need one

00:56:32,260 --> 00:56:39,069
other thing that I wanted to mention was

00:56:34,540 --> 00:56:41,230
that with this pattern I know that in

00:56:39,069 --> 00:56:44,619
redux and mo backs and a couple of those

00:56:41,230 --> 00:56:46,750
others it becomes very complicated what

00:56:44,619 --> 00:56:50,440
to do when you have asynchronous actions

00:56:46,750 --> 00:56:52,630
with with this approach it doesn't have

00:56:50,440 --> 00:56:55,690
to be complicated because this can be an

00:56:52,630 --> 00:56:58,569
async function so you now have an async

00:56:55,690 --> 00:57:00,970
function that just works and calls set

00:56:58,569 --> 00:57:03,040
state whenever it's ready and react with

00:57:00,970 --> 00:57:04,990
the update and rerender your stuff and

00:57:03,040 --> 00:57:08,230
it's gonna be fine you don't need to you

00:57:04,990 --> 00:57:10,150
don't need any special knowledge of how

00:57:08,230 --> 00:57:11,980
things work it still just functions that

00:57:10,150 --> 00:57:14,650
use functions working together functions

00:57:11,980 --> 00:57:20,330
and you can insert asynchronous stuff

00:57:14,650 --> 00:57:22,070
wherever you want so that was

00:57:20,330 --> 00:57:25,940
that was what I had to show you today I

00:57:22,070 --> 00:57:28,370
know it's kind of a pretty simple

00:57:25,940 --> 00:57:32,510
example and I couldn't drive a counter

00:57:28,370 --> 00:57:34,130
as much as I could to make it to make it

00:57:32,510 --> 00:57:36,200
understandable where I'm going at with

00:57:34,130 --> 00:57:38,030
the wormhole state management pattern

00:57:36,200 --> 00:57:41,120
but still understandable so we're not

00:57:38,030 --> 00:57:44,660
getting into the weeds of application

00:57:41,120 --> 00:57:47,060
logic so yeah I hope you enjoyed the

00:57:44,660 --> 00:57:49,340
talk and I hope that this gives you

00:57:47,060 --> 00:57:51,440
useful ideas for how to approach stuff I

00:57:49,340 --> 00:57:53,960
know I'm pretty sure you can use this

00:57:51,440 --> 00:57:55,940
with redux or in any existing react

00:57:53,960 --> 00:57:57,860
application you can just start using it

00:57:55,940 --> 00:57:59,690
and it's gonna be fine I know it's not a

00:57:57,860 --> 00:58:02,990
library it's just a pattern which I

00:57:59,690 --> 00:58:06,500
prefer because it reduces dependencies

00:58:02,990 --> 00:58:08,960
and helps you it's more about how to

00:58:06,500 --> 00:58:10,160
think about state management versus use

00:58:08,960 --> 00:58:12,290
this library and it's gonna do

00:58:10,160 --> 00:58:14,630
everything for you which I prefer and

00:58:12,290 --> 00:58:17,140
yeah so if there's any questions I'm

00:58:14,630 --> 00:58:24,980
around otherwise you can hit me up on

00:58:17,140 --> 00:58:30,230
Twitter later and yeah that's it I will

00:58:24,980 --> 00:58:33,860
start my video and yeah so let's go for

00:58:30,230 --> 00:58:38,390
it first question what are the best

00:58:33,860 --> 00:58:41,270
small steps and sides I can start

00:58:38,390 --> 00:58:43,910
learning react fast I have never used it

00:58:41,270 --> 00:58:47,810
but I use Jas and how many years have

00:58:43,910 --> 00:58:51,770
you been coding oh okay let me just make

00:58:47,810 --> 00:58:56,630
sure that my camera works there we go I

00:58:51,770 --> 00:59:00,490
have to change my battery so yeah I've

00:58:56,630 --> 00:59:04,300
been coding for a really long time like

00:59:00,490 --> 00:59:06,980
22 years now so it's been a while and

00:59:04,300 --> 00:59:09,080
what I would suggest for learning react

00:59:06,980 --> 00:59:11,450
fast is to actually just go through the

00:59:09,080 --> 00:59:14,450
dogs the documentation is really good

00:59:11,450 --> 00:59:17,690
these days and they did a great job of

00:59:14,450 --> 00:59:20,270
starting with small examples and going

00:59:17,690 --> 00:59:22,460
from there you can also find there's a

00:59:20,270 --> 00:59:24,760
lot of articles and blogs about this

00:59:22,460 --> 00:59:27,650
stuff online

00:59:24,760 --> 00:59:29,570
yeah I think if you look for react for

00:59:27,650 --> 00:59:31,070
beginners there's going to be a lot of

00:59:29,570 --> 00:59:33,829
really good information out there I

00:59:31,070 --> 00:59:36,259
don't have any that I know of

00:59:33,829 --> 00:59:38,299
from the top of my head and just build

00:59:36,259 --> 00:59:40,309
stuff the more stuff you built the more

00:59:38,299 --> 00:59:43,039
you're going to get used to react and

00:59:40,309 --> 00:59:45,109
how it works and I think that now that

00:59:43,039 --> 00:59:51,920
we have hooks it's become a lot easier

00:59:45,109 --> 00:59:52,549
to get started then it used to be thank

00:59:51,920 --> 00:59:55,400
you

00:59:52,549 --> 00:59:59,329
the second question is what do you think

00:59:55,400 --> 01:00:01,190
about the recoil Andy I honestly I just

00:59:59,329 --> 01:00:04,069
put it into a Google and this is the

01:00:01,190 --> 01:00:06,200
first time I have heard about it it's

01:00:04,069 --> 01:00:10,309
state management library weather what

01:00:06,200 --> 01:00:12,799
about these wizards I've I haven't had a

01:00:10,309 --> 01:00:14,569
chance to play with recoil yet so I

01:00:12,799 --> 01:00:17,839
can't really speak much about it it

01:00:14,569 --> 01:00:19,849
seems to be something that Facebook

01:00:17,839 --> 01:00:23,630
invented to solve their own problems

01:00:19,849 --> 01:00:25,609
primarily and one of the things I would

01:00:23,630 --> 01:00:29,869
urge you to consider before you jump

01:00:25,609 --> 01:00:32,779
into recoil is do I have 50,000 plus

01:00:29,869 --> 01:00:35,869
components like Facebook and a thousand

01:00:32,779 --> 01:00:38,180
developers working on my codebase if you

01:00:35,869 --> 01:00:39,650
don't you might not have the same

01:00:38,180 --> 01:00:41,660
problems that they were solving with

01:00:39,650 --> 01:00:43,459
recoil if you do that it's probably

01:00:41,660 --> 01:00:48,289
perfect for you and you should already

01:00:43,459 --> 01:00:52,459
be thinking about migrating great answer

01:00:48,289 --> 01:00:55,039
I have one question myself so most of

01:00:52,459 --> 01:00:57,739
the time the pattern with Redux is that

01:00:55,039 --> 01:01:00,890
between your components and the store

01:00:57,739 --> 01:01:04,069
you put some layer like selectors for

01:01:00,890 --> 01:01:08,779
example just to compute the values over

01:01:04,069 --> 01:01:12,529
the state so without need to recompute

01:01:08,779 --> 01:01:14,959
it when it's not necessary so where

01:01:12,529 --> 01:01:15,949
would you put some kind of heavy logic

01:01:14,959 --> 01:01:19,339
for example

01:01:15,949 --> 01:01:21,199
sososo tasks which are taking a lot of

01:01:19,339 --> 01:01:24,199
time how do you memorize it

01:01:21,199 --> 01:01:27,619
how would you extend your solution with

01:01:24,199 --> 01:01:30,769
a great question let me think a little

01:01:27,619 --> 01:01:32,539
bit so I've done relatively complex

01:01:30,769 --> 01:01:36,400
stuff with this pattern and I haven't

01:01:32,539 --> 01:01:40,190
needed selectors the main thing is that

01:01:36,400 --> 01:01:42,259
if you make your context small enough

01:01:40,190 --> 01:01:46,069
and I see that that's a question in Q&A

01:01:42,259 --> 01:01:47,869
as well is you can use multiple contexts

01:01:46,069 --> 01:01:50,660
I would actually avoid having a

01:01:47,869 --> 01:01:53,390
single context for all of my application

01:01:50,660 --> 01:01:56,180
state I would try to have contacts that

01:01:53,390 --> 01:01:58,009
are very localized like a special

01:01:56,180 --> 01:02:00,319
context just for authentication a

01:01:58,009 --> 01:02:03,079
special context just for your shopping

01:02:00,319 --> 01:02:06,079
cart stuff like that then once you have

01:02:03,079 --> 01:02:08,150
those context it becomes easier to make

01:02:06,079 --> 01:02:10,009
helper functions on top of it because

01:02:08,150 --> 01:02:13,099
they don't have to be that complicated

01:02:10,009 --> 01:02:16,190
I would put them in the link we made a

01:02:13,099 --> 01:02:18,740
use shirt count function that's where

01:02:16,190 --> 01:02:20,029
that's where I would put those I guess

01:02:18,740 --> 01:02:22,880
what you would call them are selectors

01:02:20,029 --> 01:02:24,890
so it export it returns a function that

01:02:22,880 --> 01:02:27,799
you can then use to make it easier to

01:02:24,890 --> 01:02:31,190
talk to this store and honestly if the

01:02:27,799 --> 01:02:33,589
logic is not something that multiple

01:02:31,190 --> 01:02:35,509
components need to do if a single

01:02:33,589 --> 01:02:37,400
component needs to do a lot of logic on

01:02:35,509 --> 01:02:40,400
top of your stake just put it in that

01:02:37,400 --> 01:02:43,190
component and calculate it every time

01:02:40,400 --> 01:02:44,839
like JavaScript is really fast these

01:02:43,190 --> 01:02:46,940
days and I know that it can add up if

01:02:44,839 --> 01:02:49,970
you're doing fuel processing ten

01:02:46,940 --> 01:02:52,039
thousand nine ten thousand item arrays

01:02:49,970 --> 01:02:54,890
but for most things in most universe

01:02:52,039 --> 01:02:57,230
it's actually pretty fast I think and

01:02:54,890 --> 01:02:59,599
even if you're using it within the

01:02:57,230 --> 01:03:02,119
reactive component it's tough if it's

01:02:59,599 --> 01:03:04,730
slow we have used memo so you can

01:03:02,119 --> 01:03:07,700
memorize it automatically with the code

01:03:04,730 --> 01:03:10,460
that with machinery that you already get

01:03:07,700 --> 01:03:15,170
in react yeah does that answer your

01:03:10,460 --> 01:03:17,329
question yeah sure thank you some some

01:03:15,170 --> 01:03:19,849
other questions a beard while you

01:03:17,329 --> 01:03:22,730
weren't where you were answering one

01:03:19,849 --> 01:03:25,220
really connected to this would you

01:03:22,730 --> 01:03:28,549
recommend to use more context or just

01:03:25,220 --> 01:03:30,799
use one global like redux doesn't it get

01:03:28,549 --> 01:03:36,140
a bit messy if you have let's say 10 to

01:03:30,799 --> 01:03:38,809
20 contexts in your in your app so yes

01:03:36,140 --> 01:03:42,859
if you have multiple contexts it can get

01:03:38,809 --> 01:03:44,930
messy in theory the question is what is

01:03:42,859 --> 01:03:48,619
the smallest number of components that

01:03:44,930 --> 01:03:50,749
need to share some state and when you

01:03:48,619 --> 01:03:52,400
find that you can create a context for

01:03:50,749 --> 01:03:53,869
those components to make it easier for

01:03:52,400 --> 01:03:56,390
them to communicate between each other

01:03:53,869 --> 01:03:58,759
and then use global context for

01:03:56,390 --> 01:04:01,220
everything else so you wouldn't you

01:03:58,759 --> 01:04:01,550
wouldn't wrap your root component in 20

01:04:01,220 --> 01:04:02,750
different

01:04:01,550 --> 01:04:05,270
context you would wrap your root

01:04:02,750 --> 01:04:07,040
component in one global context or a

01:04:05,270 --> 01:04:08,630
couple global context that you really

01:04:07,040 --> 01:04:10,820
need to be global and then you would

01:04:08,630 --> 01:04:14,510
have sub trees and you would just you

01:04:10,820 --> 01:04:17,810
can wrap a part of a sub tree in your

01:04:14,510 --> 01:04:20,300
context so it's more like think of it

01:04:17,810 --> 01:04:22,280
the original title for this talk was

01:04:20,300 --> 01:04:24,410
push your edge to push your state to the

01:04:22,280 --> 01:04:27,830
edge that's kind of the idea you you're

01:04:24,410 --> 01:04:29,870
trying to find the most edge the

01:04:27,830 --> 01:04:31,310
smallest part of your edge components

01:04:29,870 --> 01:04:32,990
that need to actually share some state

01:04:31,310 --> 01:04:34,340
and then share it only between those

01:04:32,990 --> 01:04:38,900
because that makes it easier to

01:04:34,340 --> 01:04:41,290
understand and read your code you're

01:04:38,900 --> 01:04:46,640
pretty pretty much I I agree with this

01:04:41,290 --> 01:04:49,310
that once once you start refactoring

01:04:46,640 --> 01:04:51,560
your Redux store you end up with the

01:04:49,310 --> 01:04:54,470
realization that you put it in the

01:04:51,560 --> 01:04:59,000
global state just because you could and

01:04:54,470 --> 01:05:01,400
it was so easy and actually the the

01:04:59,000 --> 01:05:05,030
stuff that is really global there is

01:05:01,400 --> 01:05:07,280
minimum of that for us it was some like

01:05:05,030 --> 01:05:09,560
language currency and aesthetic data

01:05:07,280 --> 01:05:11,390
which need to be shared across across

01:05:09,560 --> 01:05:13,660
that and everything else can be used

01:05:11,390 --> 01:05:14,990
yeah III pretty much agree with this

01:05:13,660 --> 01:05:18,080
awesome

01:05:14,990 --> 01:05:21,470
another question is what would be the

01:05:18,080 --> 01:05:23,990
easiest way to find where the context

01:05:21,470 --> 01:05:28,760
provider is defined for a particular use

01:05:23,990 --> 01:05:30,830
of a shared state great question so if

01:05:28,760 --> 01:05:33,890
you using I don't know about other

01:05:30,830 --> 01:05:36,740
editors if you're using vs code you can

01:05:33,890 --> 01:05:38,660
come and click on the hook that connect

01:05:36,740 --> 01:05:41,180
you to the state so in our example it

01:05:38,660 --> 01:05:44,060
would be the use shared count function

01:05:41,180 --> 01:05:46,040
or hook you command click on that it

01:05:44,060 --> 01:05:48,470
goes to the file where that function is

01:05:46,040 --> 01:05:52,910
defined and at the top of that file it

01:05:48,470 --> 01:05:55,280
says it says import context from X and

01:05:52,910 --> 01:05:56,870
that X is where your context is defined

01:05:55,280 --> 01:06:01,070
and where the provider is defined as

01:05:56,870 --> 01:06:02,720
well so it's like one step one click and

01:06:01,070 --> 01:06:04,190
you find it especially if you're using

01:06:02,720 --> 01:06:06,250
typescript I think that works even

01:06:04,190 --> 01:06:09,200
better mm-hmm

01:06:06,250 --> 01:06:10,010
Roman I hope this answers your your

01:06:09,200 --> 01:06:13,370
question

01:06:10,010 --> 01:06:17,510
if not you can specify it even more in

01:06:13,370 --> 01:06:22,760
another one and some more questions

01:06:17,510 --> 01:06:25,400
appearing was from Pershing how would

01:06:22,760 --> 01:06:27,860
you go around a scenario where you need

01:06:25,400 --> 01:06:30,920
two independent parallel wormholes for

01:06:27,860 --> 01:06:33,620
the same context let's say you want to

01:06:30,920 --> 01:06:36,710
display two independent plus one buttons

01:06:33,620 --> 01:06:37,250
with their display components far in the

01:06:36,710 --> 01:06:43,570
dome

01:06:37,250 --> 01:06:47,180
I see so for that so where you have a

01:06:43,570 --> 01:06:50,390
similar type of state but it's not the

01:06:47,180 --> 01:06:53,000
same state specifically I haven't tried

01:06:50,390 --> 01:06:56,800
that before an approach I think would

01:06:53,000 --> 01:07:00,080
work is to have to create two contexts

01:06:56,800 --> 01:07:02,870
so you could then make it a little bit

01:07:00,080 --> 01:07:06,770
more complicated and make your shared

01:07:02,870 --> 01:07:09,770
state provider accept a context function

01:07:06,770 --> 01:07:11,840
in it or you know what we called create

01:07:09,770 --> 01:07:14,240
context and created the actual contest

01:07:11,840 --> 01:07:17,300
to share stuff you could pass that as a

01:07:14,240 --> 01:07:20,120
prop into your provider and then you

01:07:17,300 --> 01:07:22,630
could use that then you could have your

01:07:20,120 --> 01:07:25,700
you could potentially then have your

01:07:22,630 --> 01:07:29,500
hook that looks at the shared state also

01:07:25,700 --> 01:07:33,020
accept the context as an argument so

01:07:29,500 --> 01:07:35,030
that would kind of work I think that

01:07:33,020 --> 01:07:38,960
that could get messy very quickly I

01:07:35,030 --> 01:07:40,480
would question whether it depends it

01:07:38,960 --> 01:07:42,710
really depends on your use case but

01:07:40,480 --> 01:07:44,420
somewhere in that line it would be more

01:07:42,710 --> 01:07:47,600
like using context directly rather than

01:07:44,420 --> 01:07:50,470
through a separate helper hook but you

01:07:47,600 --> 01:07:52,700
could do it so you would basically

01:07:50,470 --> 01:07:54,440
instantiate multiple contexts and then

01:07:52,700 --> 01:07:54,830
have the same machinery attached to them

01:07:54,440 --> 01:07:58,280
mm-hm

01:07:54,830 --> 01:08:03,310
yeah I think that will work but I

01:07:58,280 --> 01:08:06,230
haven't tried it yep another question

01:08:03,310 --> 01:08:08,390
with the formal context do you recommend

01:08:06,230 --> 01:08:10,280
having one huge context per application

01:08:08,390 --> 01:08:12,410
or several small context each pair

01:08:10,280 --> 01:08:16,070
logical subdomain I think we answered

01:08:12,410 --> 01:08:18,230
answered this already will Apple a local

01:08:16,070 --> 01:08:21,500
state management replace all other state

01:08:18,230 --> 01:08:22,010
management libraries that's a good

01:08:21,500 --> 01:08:24,320
question

01:08:22,010 --> 01:08:26,750
I don't I don't know I don't think it

01:08:24,320 --> 01:08:29,509
will it's haven't you

01:08:26,750 --> 01:08:32,029
they haven't used the actual upon local

01:08:29,509 --> 01:08:34,040
state stuff I've used Apollo's graph QL

01:08:32,029 --> 01:08:37,310
stuff which is I think pretty similar

01:08:34,040 --> 01:08:49,430
and that works really nicely I guess

01:08:37,310 --> 01:08:50,480
time hotel it really depends ok let's

01:08:49,430 --> 01:08:52,670
see another one

01:08:50,480 --> 01:08:55,100
do you recommend any resources online

01:08:52,670 --> 01:09:01,100
where I can find more complex examples

01:08:55,100 --> 01:09:03,890
using this pattern with react can't blog

01:09:01,100 --> 01:09:06,080
is actually really good I would also

01:09:03,890 --> 01:09:10,430
recommend checking out my use off

01:09:06,080 --> 01:09:17,089
library I can link it down here so if

01:09:10,430 --> 01:09:21,710
you look for so this is the library

01:09:17,089 --> 01:09:24,200
where I vanished when I click send so

01:09:21,710 --> 01:09:25,670
use office the library where I first

01:09:24,200 --> 01:09:28,790
developed this pattern and started

01:09:25,670 --> 01:09:30,020
really using it and it uses this pattern

01:09:28,790 --> 01:09:34,250
to manage everything about

01:09:30,020 --> 01:09:36,770
authentication in your entire name so

01:09:34,250 --> 01:09:39,350
it's relatively complex it also uses the

01:09:36,770 --> 01:09:43,910
use we do certain stuff because it has

01:09:39,350 --> 01:09:45,680
so much straight mm-hmm the next

01:09:43,910 --> 01:09:47,540
question really great one is there any

01:09:45,680 --> 01:09:49,670
tool similar to redock step tools that

01:09:47,540 --> 01:09:56,270
you could use for debugging with react

01:09:49,670 --> 01:09:58,550
context but this is a pretty strong side

01:09:56,270 --> 01:10:00,940
of the of the redux that's the dueling

01:09:58,550 --> 01:10:04,460
yes at least when you need it is there

01:10:00,940 --> 01:10:06,530
yeah so I don't I haven't used Redux

01:10:04,460 --> 01:10:09,980
tooling in a while so I'm not sure what

01:10:06,530 --> 01:10:12,170
it provides these days I know that react

01:10:09,980 --> 01:10:15,050
dev tools they were working very hard on

01:10:12,170 --> 01:10:18,020
making hooks in context more directly

01:10:15,050 --> 01:10:20,870
with the normal reactive tools but I

01:10:18,020 --> 01:10:23,600
honestly haven't needed it because this

01:10:20,870 --> 01:10:25,610
pattern is easy enough to use that I

01:10:23,600 --> 01:10:27,470
don't have to I can just put a couple

01:10:25,610 --> 01:10:31,810
console logs where I'm actually using

01:10:27,470 --> 01:10:34,880
the Kochs and that works I've honestly

01:10:31,810 --> 01:10:36,890
not had a need to try to look at dev

01:10:34,880 --> 01:10:38,330
tools to fix it but maybe there's

01:10:36,890 --> 01:10:40,960
something I'm missing that I don't even

01:10:38,330 --> 01:10:40,960
know how I could have

01:10:41,810 --> 01:10:46,770
like I could probably imagine a better

01:10:44,790 --> 01:10:48,239
to link because in the reactive tools

01:10:46,770 --> 01:10:51,120
you can always just click on the

01:10:48,239 --> 01:10:54,480
component and see the local state but

01:10:51,120 --> 01:10:56,880
this can get like pretty hard with the

01:10:54,480 --> 01:11:01,050
context when they are all over the place

01:10:56,880 --> 01:11:04,620
so yeah but console logs for further win

01:11:01,050 --> 01:11:11,220
into JavaScript ecosystem yeah I mean I

01:11:04,620 --> 01:11:16,650
love console logs yeah another question

01:11:11,220 --> 01:11:17,910
have you heard slash used X state what

01:11:16,650 --> 01:11:19,980
do you think of the concept of

01:11:17,910 --> 01:11:24,120
separating logics from rendering the

01:11:19,980 --> 01:11:26,340
with state machines so X state I haven't

01:11:24,120 --> 01:11:29,730
used it it's a really good library it's

01:11:26,340 --> 01:11:31,860
how I originally taught people to use

01:11:29,730 --> 01:11:37,230
redux was to think of it as a state

01:11:31,860 --> 01:11:39,390
machine and use actions as movement like

01:11:37,230 --> 01:11:40,950
if you draw a state machine each action

01:11:39,390 --> 01:11:44,300
is an arrow between different states and

01:11:40,950 --> 01:11:47,489
then your reducer does the states you

01:11:44,300 --> 01:11:49,860
while I haven't tried it I think you can

01:11:47,489 --> 01:11:52,440
use X State with the wormhole approach

01:11:49,860 --> 01:11:55,500
it's just work where I did the use state

01:11:52,440 --> 01:11:57,270
part inside the context provider you

01:11:55,500 --> 01:12:03,480
could use X state there and it would

01:11:57,270 --> 01:12:04,710
work the same yeah if you have something

01:12:03,480 --> 01:12:06,690
that fits a state machine I would

01:12:04,710 --> 01:12:09,860
definitely recommend using X because it

01:12:06,690 --> 01:12:09,860
solves a lot of problems for you

01:12:14,060 --> 01:12:17,299
[Music]

01:12:20,540 --> 01:12:29,820
typescript depends what you're doing if

01:12:26,550 --> 01:12:31,739
you if you it pretty much ends up or

01:12:29,820 --> 01:12:40,020
links to a discussion whether you need

01:12:31,739 --> 01:12:42,450
new types or not but in my personal

01:12:40,020 --> 01:12:45,480
opinion I recommend them it helped me to

01:12:42,450 --> 01:12:47,820
debug a lot it helps with your factors

01:12:45,480 --> 01:12:51,060
you change something and the types will

01:12:47,820 --> 01:12:53,489
tell you whether you are just breaking

01:12:51,060 --> 01:12:54,179
your application up it catches a lot of

01:12:53,489 --> 01:12:56,909
type

01:12:54,179 --> 01:12:58,920
style mistakes and yeah actually the

01:12:56,909 --> 01:13:02,610
best part about typescript if you're

01:12:58,920 --> 01:13:04,440
using vs code is that you get hints on

01:13:02,610 --> 01:13:05,909
your functions so you don't have to go

01:13:04,440 --> 01:13:08,100
look at the functional definition you

01:13:05,909 --> 01:13:12,739
can see directly in the editor what you

01:13:08,100 --> 01:13:15,600
need and that's awesome exactly this

01:13:12,739 --> 01:13:17,760
there is a question about the materials

01:13:15,600 --> 01:13:22,770
can you write down here the websites you

01:13:17,760 --> 01:13:23,760
you name it probably can touch the Q

01:13:22,770 --> 01:13:26,730
word

01:13:23,760 --> 01:13:28,469
yep react is that block and others

01:13:26,730 --> 01:13:31,800
please my brother is so in here is

01:13:28,469 --> 01:13:34,320
chitchat Thanks oh maybe we can write up

01:13:31,800 --> 01:13:38,070
some summary also for the for the slack

01:13:34,320 --> 01:13:44,880
so people can find fun in deep there if

01:13:38,070 --> 01:13:46,860
they are there then what was there there

01:13:44,880 --> 01:13:49,679
was a one last question if you have a

01:13:46,860 --> 01:13:53,489
context fair domain in brackets no

01:13:49,679 --> 01:14:03,870
global context what value does creating

01:13:53,489 --> 01:14:08,310
hooks over the context do you have it it

01:14:03,870 --> 01:14:10,620
continues that to use the use counter

01:14:08,310 --> 01:14:13,140
context you create it which looks like a

01:14:10,620 --> 01:14:18,600
shell of wrapper we could use context

01:14:13,140 --> 01:14:20,429
directly so that's true you can use

01:14:18,600 --> 01:14:23,790
context directly for something this

01:14:20,429 --> 01:14:26,190
simple if you look at my use off library

01:14:23,790 --> 01:14:28,320
you'll see that having a helper hook is

01:14:26,190 --> 01:14:31,140
really helpful because like we said

01:14:28,320 --> 01:14:34,050
earlier you can use it to make sort of

01:14:31,140 --> 01:14:38,610
selectors that combine logic on top of

01:14:34,050 --> 01:14:41,640
your state you can make a easier API for

01:14:38,610 --> 01:14:44,550
managing your state so what I like to do

01:14:41,640 --> 01:14:47,969
is use reducer and then put the dispatch

01:14:44,550 --> 01:14:49,620
function into my context so I can call

01:14:47,969 --> 01:14:53,040
this patch and dispatch actions from

01:14:49,620 --> 01:14:56,580
wherever it's basically it's just a way

01:14:53,040 --> 01:14:58,469
of providing a nicer API on top of the

01:14:56,580 --> 01:15:01,170
count on top of the context itself so

01:14:58,469 --> 01:15:03,150
that you have both the logic separated

01:15:01,170 --> 01:15:05,800
into its own so you have business logic

01:15:03,150 --> 01:15:07,720
separated shared

01:15:05,800 --> 01:15:09,220
this logic separated into its own hook

01:15:07,720 --> 01:15:11,560
so you don't have to re-implement it

01:15:09,220 --> 01:15:12,820
every time in every component I think

01:15:11,560 --> 01:15:14,920
that makes it nicer but yeah

01:15:12,820 --> 01:15:21,490
you can still use use context directly

01:15:14,920 --> 01:15:25,510
and not have a separate hook at all yep

01:15:21,490 --> 01:15:28,180
and the last question so we will not

01:15:25,510 --> 01:15:29,620
ignore it and you be here where can I

01:15:28,180 --> 01:15:31,780
start applying to junior react

01:15:29,620 --> 01:15:34,210
developers positions is there some kind

01:15:31,780 --> 01:15:36,910
of a list of tools I need to know how to

01:15:34,210 --> 01:15:42,490
use or maybe I just need to build a

01:15:36,910 --> 01:15:44,830
couple of pet projects this is kind of a

01:15:42,490 --> 01:15:51,970
general question let me help with the

01:15:44,830 --> 01:15:53,920
answer there like if you just type react

01:15:51,970 --> 01:15:56,230
generate developer position into a

01:15:53,920 --> 01:15:58,300
Google and do not find anything suitable

01:15:56,230 --> 01:16:02,470
then probably your internet is not

01:15:58,300 --> 01:16:05,680
working correctly and when start pretty

01:16:02,470 --> 01:16:08,650
much try to experiment with the

01:16:05,680 --> 01:16:11,650
libraries mentioned here the the react

01:16:08,650 --> 01:16:14,620
as a library itself there is a lot of

01:16:11,650 --> 01:16:17,590
IDs which are online for example coats

01:16:14,620 --> 01:16:19,390
and books where you can without needing

01:16:17,590 --> 01:16:21,190
to setup anything you can just start

01:16:19,390 --> 01:16:24,790
writing your code and your first

01:16:21,190 --> 01:16:29,650
tutorials and the read documentation is

01:16:24,790 --> 01:16:32,020
a full of great links to two other other

01:16:29,650 --> 01:16:36,190
great people in the ring that causes

01:16:32,020 --> 01:16:39,190
them like Dan Abramov Kent dots and and

01:16:36,190 --> 01:16:41,320
many others so so so feel free to start

01:16:39,190 --> 01:16:46,060
there and you can't make a mistake

01:16:41,320 --> 01:16:48,490
pretty much yeah and one thing I would

01:16:46,060 --> 01:16:52,920
add to that is just start applying it's

01:16:48,490 --> 01:16:55,300
their job to say no not yours yeah and

01:16:52,920 --> 01:17:01,020
you will find out what they are

01:16:55,300 --> 01:17:06,960
interested in what the requirements are

01:17:01,020 --> 01:17:11,380
okay so we answered all the questions

01:17:06,960 --> 01:17:14,380
thank you Swiss it was awesome here I

01:17:11,380 --> 01:17:18,250
hope you enjoyed it as well as I did

01:17:14,380 --> 01:17:22,660
just few remarks

01:17:18,250 --> 01:17:24,610
at the end please try to provide the

01:17:22,660 --> 01:17:27,460
feedback for us in the selectional it's

01:17:24,610 --> 01:17:29,530
really important it helped us to get

01:17:27,460 --> 01:17:35,790
better and better and you enjoyed the

01:17:29,530 --> 01:17:39,130
talks more so all all feedback well done

01:17:35,790 --> 01:17:42,760
thanks for joining us I hope that you

01:17:39,130 --> 01:17:46,240
will join us again next time just to

01:17:42,760 --> 01:17:49,240
mention the next time the meta speaker

01:17:46,240 --> 01:17:51,580
will be in benning's and the talk will

01:17:49,240 --> 01:17:54,610
be a framework to lead a team to success

01:17:51,580 --> 01:17:55,960
in a challenging environment I think

01:17:54,610 --> 01:17:59,290
that currently we have a really

01:17:55,960 --> 01:18:00,730
challenging environment all of us so so

01:17:59,290 --> 01:18:04,900
that sounds like a really interesting

01:18:00,730 --> 01:18:07,750
topic at this time and the main speaker

01:18:04,900 --> 01:18:11,200
and that dog will be by Chen huge ink

01:18:07,750 --> 01:18:16,720
and the top will be about CSS for

01:18:11,200 --> 01:18:19,450
internalization so so stay tuned and

01:18:16,720 --> 01:18:21,850
follow the socials for more information

01:18:19,450 --> 01:18:26,080
thank you all have a great evening

01:18:21,850 --> 01:18:31,620
hope you finished your beers and yep

01:18:26,080 --> 01:18:31,620
thank you all bye folks

01:18:37,700 --> 01:18:39,760

YouTube URL: https://www.youtube.com/watch?v=OJ7ZDfQ4snc


