Title: ReactiveConf 2019 - Marion Schleifer: Live-coding demo
Publication date: 2019-10-31
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Discovery stage
-------------------------------------------------------------------
Live-coding demo – Build your own backend in the `redux` style with GraphQL mutations (dispatch), `pure` serverless functions (reducers), and GraphQL subscriptions (updated state)

What if it was possible to build backend features for our react apps in the same way that we use redux in our react apps? In this live-coding demo, I will show you how we’ll add backend business logic using the redux abstractions of dispatching actions, writing reducers as pure functions and subscribing to updated state. Our backend will be completely serverless and using open-source and managed services so that we’re not actually deploying and maintaining any servers. We will use GraphQL mutations from our react app to dispatch actions. These will trigger serverless functions which are pure and return the modified state, which will be persisted safely on a cloud-managed database. Portions of your app that are subscribed to the state using GraphQL subscriptions (live-queries) will automatically update! You will witness the raw awesomeness of being able to use javascript and graphql in a pattern that you are comfortable with to build backend features from scratch.
Captions: 
	00:00:02,720 --> 00:00:11,850
[Music]

00:00:13,830 --> 00:00:19,360
hi everyone thank you for coming to my

00:00:17,200 --> 00:00:21,130
talk so today I want to talk to you

00:00:19,360 --> 00:00:23,740
about how to build your back-end

00:00:21,130 --> 00:00:26,860
with graphical and server lists in redux

00:00:23,740 --> 00:00:28,570
style mental model so thank you for the

00:00:26,860 --> 00:00:32,230
nice introduction again I'm Marian from

00:00:28,570 --> 00:00:34,570
Zurich and I'm a community organizer but

00:00:32,230 --> 00:00:36,579
recently I started writing dirt packs

00:00:34,570 --> 00:00:39,280
because before I was a mechanic for my

00:00:36,579 --> 00:00:41,200
boyfriend and then I was like if I might

00:00:39,280 --> 00:00:43,600
as well do it as well so I started I

00:00:41,200 --> 00:00:49,180
will buy my own dirt bag next month so

00:00:43,600 --> 00:00:51,039
I'm really excited thank you yes and I

00:00:49,180 --> 00:00:52,660
work as a developer experience engineer

00:00:51,039 --> 00:00:55,780
at Hazara which means I'm responsible

00:00:52,660 --> 00:00:57,489
for documentation github issues and in

00:00:55,780 --> 00:00:59,590
general developer experience so if you

00:00:57,489 --> 00:01:04,269
try that and you have any feedback that

00:00:59,590 --> 00:01:06,580
would be very happy to talk to you so

00:01:04,269 --> 00:01:08,410
let's jump into the topic so I hope you

00:01:06,580 --> 00:01:11,680
all agree with me that Redux is awesome

00:01:08,410 --> 00:01:15,520
so if not maybe we can also discuss this

00:01:11,680 --> 00:01:17,740
later and so basically I'm not a

00:01:15,520 --> 00:01:20,650
reactive Ella professionally but of

00:01:17,740 --> 00:01:22,750
course I build a reactive with redux

00:01:20,650 --> 00:01:24,040
because I wanted to do this talk and I

00:01:22,750 --> 00:01:26,350
think it's pretty cool even though you

00:01:24,040 --> 00:01:28,229
have to write some boilerplate code once

00:01:26,350 --> 00:01:31,780
everything is set up it's really cool as

00:01:28,229 --> 00:01:34,570
state management tool so for those of

00:01:31,780 --> 00:01:38,439
you who are not familiar with redux or

00:01:34,570 --> 00:01:42,369
who need a small refresher so we have a

00:01:38,439 --> 00:01:45,790
UI UI component where something happens

00:01:42,369 --> 00:01:49,479
then an action gets dispatched and which

00:01:45,790 --> 00:01:52,420
calls a reducer the reducer update state

00:01:49,479 --> 00:01:54,880
and then the UI component that subscribe

00:01:52,420 --> 00:01:59,289
to the state's tank then get the update

00:01:54,880 --> 00:02:02,920
so this is the mental model of Redux now

00:01:59,289 --> 00:02:04,930
we said we will build this new

00:02:02,920 --> 00:02:07,329
architecture with serverless so let's

00:02:04,930 --> 00:02:09,190
also talk about serverless and I thought

00:02:07,329 --> 00:02:13,270
the best way to do this is to start off

00:02:09,190 --> 00:02:14,860
with an example so here I'm defining a

00:02:13,270 --> 00:02:18,100
function that's basically a very simple

00:02:14,860 --> 00:02:21,370
function which just returns a message

00:02:18,100 --> 00:02:24,940
that is hello world then I deployed this

00:02:21,370 --> 00:02:25,510
function to be serverless function on

00:02:24,940 --> 00:02:27,909
the cloud

00:02:25,510 --> 00:02:31,329
and then I can just call it and I get

00:02:27,909 --> 00:02:34,810
the message helloworld so this means

00:02:31,329 --> 00:02:37,180
like in 20 seconds or less I built my

00:02:34,810 --> 00:02:38,500
own API with very simple code and I

00:02:37,180 --> 00:02:42,730
think it's really cool to have this

00:02:38,500 --> 00:02:44,739
freedom to be able to write to spend the

00:02:42,730 --> 00:02:46,989
time on writing the code that we care

00:02:44,739 --> 00:02:50,049
about instead of having to deal with

00:02:46,989 --> 00:02:52,870
DevOps and operations because serverless

00:02:50,049 --> 00:02:54,489
functions if they run on the cloud they

00:02:52,870 --> 00:02:59,709
scale horizontally so you don't need to

00:02:54,489 --> 00:03:01,450
care about servers or anything now the

00:02:59,709 --> 00:03:04,180
third and last component of our

00:03:01,450 --> 00:03:07,359
architecture is graphical who's already

00:03:04,180 --> 00:03:11,139
working with graphical so a lot of

00:03:07,359 --> 00:03:13,870
people to introduce this to the other

00:03:11,139 --> 00:03:16,930
people I thought I just compared it to

00:03:13,870 --> 00:03:19,810
rest which is more traditional kind of

00:03:16,930 --> 00:03:22,629
architecture so in rest we have on the

00:03:19,810 --> 00:03:25,720
left hand side three tables product

00:03:22,629 --> 00:03:27,639
brands and category so now what if you

00:03:25,720 --> 00:03:30,819
want to have the product with the brand

00:03:27,639 --> 00:03:32,620
so in this case you would have to make

00:03:30,819 --> 00:03:34,419
an API call to get the product and then

00:03:32,620 --> 00:03:38,290
with the idea get the brands to have two

00:03:34,419 --> 00:03:40,750
API calls compared to graph QL on the

00:03:38,290 --> 00:03:42,879
right hand side where on the top we have

00:03:40,750 --> 00:03:46,419
a query where we get information about

00:03:42,879 --> 00:03:48,519
the product and then below another query

00:03:46,419 --> 00:03:50,650
where we get the product with the brand

00:03:48,519 --> 00:03:54,280
in one query so graph QL allows us to

00:03:50,650 --> 00:03:56,709
have nested resources so this and also

00:03:54,280 --> 00:04:00,329
the fact that you only have one endpoint

00:03:56,709 --> 00:04:03,760
for graph QL is why I like it a lot now

00:04:00,329 --> 00:04:05,290
we said we want to transfer this mental

00:04:03,760 --> 00:04:07,290
model of redux

00:04:05,290 --> 00:04:10,840
to apply for a whole back-end

00:04:07,290 --> 00:04:13,239
architecture so how will this look we

00:04:10,840 --> 00:04:15,340
still have a UI where some something

00:04:13,239 --> 00:04:19,299
happens but instead of dispatching an

00:04:15,340 --> 00:04:22,440
action we have a graphical mutation so

00:04:19,299 --> 00:04:25,690
we insert something into the database

00:04:22,440 --> 00:04:28,560
then the service function is called

00:04:25,690 --> 00:04:32,440
which is the reducer in our mental model

00:04:28,560 --> 00:04:36,000
the serverless function updates the

00:04:32,440 --> 00:04:38,159
state and then the UI components does

00:04:36,000 --> 00:04:42,629
subscribe to the state

00:04:38,159 --> 00:04:44,610
updated so we have on the ones

00:04:42,629 --> 00:04:47,219
sides the state of the UI owned on the

00:04:44,610 --> 00:04:49,529
other side the state of the backend so

00:04:47,219 --> 00:04:53,249
now what we'll be doing is we will have

00:04:49,529 --> 00:04:55,589
an app where we can type in bed and

00:04:53,249 --> 00:04:58,139
naughty words but we cannot display them

00:04:55,589 --> 00:05:00,449
in our application because of many

00:04:58,139 --> 00:05:05,789
reasons so we have to filter these bad

00:05:00,449 --> 00:05:07,679
words and return a sanitized content now

00:05:05,789 --> 00:05:09,599
again with our model how will this look

00:05:07,679 --> 00:05:13,649
so we have bad content that somebody

00:05:09,599 --> 00:05:17,719
types in we will save this raw content

00:05:13,649 --> 00:05:20,879
as with a mutation inside our database

00:05:17,719 --> 00:05:22,830
then with the insert we have an event

00:05:20,879 --> 00:05:24,959
trigger on our API which calls a

00:05:22,830 --> 00:05:28,050
serverless function the serverless

00:05:24,959 --> 00:05:30,240
function sanitizes the content and

00:05:28,050 --> 00:05:35,339
filters not the bad words and then

00:05:30,240 --> 00:05:38,610
updates the state for with the sanitized

00:05:35,339 --> 00:05:40,679
version and the UI components that care

00:05:38,610 --> 00:05:42,990
about the sanitized version get the

00:05:40,679 --> 00:05:44,699
update because they subscribe with

00:05:42,990 --> 00:05:52,199
graphical subscription to this

00:05:44,699 --> 00:05:56,309
information okay so let's see for the

00:05:52,199 --> 00:05:59,490
lifetime so the first thing we do this

00:05:56,309 --> 00:06:05,369
cute isn't it the first thing we do I

00:05:59,490 --> 00:06:07,319
already set up an API this is a Postgres

00:06:05,369 --> 00:06:09,360
database with tesora which is a

00:06:07,319 --> 00:06:14,779
graphical layer and it's deployed on

00:06:09,360 --> 00:06:19,889
Heroku so we create a table called

00:06:14,779 --> 00:06:23,669
tweets it has an ID that is a UUID and

00:06:19,889 --> 00:06:29,149
we generated randomly then the tweet has

00:06:23,669 --> 00:06:33,479
a raw version that is text and a

00:06:29,149 --> 00:06:36,089
sanitized version that is also text and

00:06:33,479 --> 00:06:38,639
this is this is in the beginning null so

00:06:36,089 --> 00:06:40,349
this is as we said before we will insert

00:06:38,639 --> 00:06:42,689
the road to it into the database and

00:06:40,349 --> 00:06:45,059
then later the server list function will

00:06:42,689 --> 00:06:48,509
update the tweet with the sanitized

00:06:45,059 --> 00:06:52,460
field so as a primary key we add the ID

00:06:48,509 --> 00:06:55,770
and we add the table

00:06:52,460 --> 00:07:08,120
so what we now have is we can do a

00:06:55,770 --> 00:07:08,120
mutation insert tweets and we saying

00:07:08,150 --> 00:07:20,790
something dangerous and we return the ID

00:07:14,580 --> 00:07:22,680
the raw and the sanitized so this is

00:07:20,790 --> 00:07:26,370
inserted in the database as expected

00:07:22,680 --> 00:07:29,729
with our content and with the sanitized

00:07:26,370 --> 00:07:31,710
field being null at the moment so now we

00:07:29,729 --> 00:07:36,419
cannot access this API because there

00:07:31,710 --> 00:07:40,530
will be bad words in it and so we go to

00:07:36,419 --> 00:07:43,020
our server list function I am I created

00:07:40,530 --> 00:07:46,380
this on glitch so it's an Express server

00:07:43,020 --> 00:07:49,080
dysfunction maybe to show you quickly

00:07:46,380 --> 00:07:51,870
how this setup works so we have a

00:07:49,080 --> 00:07:55,919
library with bad words so I cannot show

00:07:51,870 --> 00:07:59,190
these words really bad and so we have a

00:07:55,919 --> 00:08:02,270
reducer a function here and what we're

00:07:59,190 --> 00:08:05,310
doing is for the event that comes in

00:08:02,270 --> 00:08:09,389
that contains the information from the

00:08:05,310 --> 00:08:16,370
mutation that we create on the API we

00:08:09,389 --> 00:08:21,870
take the row here the raw field out of

00:08:16,370 --> 00:08:25,310
this of this tweet and then the ml and

00:08:21,870 --> 00:08:28,110
the AI which is in this case just reg X

00:08:25,310 --> 00:08:29,930
sanitizes this tweet and returns a clean

00:08:28,110 --> 00:08:32,880
version of it that we can actually show

00:08:29,930 --> 00:08:34,740
so it's very simple and then what we do

00:08:32,880 --> 00:08:36,870
here is we have another graph QL

00:08:34,740 --> 00:08:40,260
mutation but this time we don't insert

00:08:36,870 --> 00:08:44,010
anything but we update the tweet and we

00:08:40,260 --> 00:08:46,320
pass the sanitized the sanitized content

00:08:44,010 --> 00:08:48,959
that we create here to the sanitized

00:08:46,320 --> 00:08:51,020
field of this tweet with the respective

00:08:48,959 --> 00:08:56,430
adding here you can see the endpoint

00:08:51,020 --> 00:08:59,780
that we have here from our API and the

00:08:56,430 --> 00:09:03,060
rest is just server setup so this

00:08:59,780 --> 00:09:04,710
servlet function is created now we need

00:09:03,060 --> 00:09:08,010
to be able to trigger it so

00:09:04,710 --> 00:09:12,870
we create an event trigger called

00:09:08,010 --> 00:09:14,580
sanitized on the table tweets and we

00:09:12,870 --> 00:09:19,370
want to do it when a new tweet is

00:09:14,580 --> 00:09:19,370
inserted so now I have to get the URL

00:09:22,640 --> 00:09:28,290
create the event trigger so now let's

00:09:26,970 --> 00:09:31,530
see if this works

00:09:28,290 --> 00:09:32,970
so now I actually have to use one of the

00:09:31,530 --> 00:09:35,400
bad words because otherwise we cannot

00:09:32,970 --> 00:09:37,530
see if the sanitized thing is working

00:09:35,400 --> 00:09:40,050
and I found one that I can use which is

00:09:37,530 --> 00:09:40,830
hell so I think this is OK with the code

00:09:40,050 --> 00:09:47,370
of conduct

00:09:40,830 --> 00:09:50,450
so I say is hell nice and I save and now

00:09:47,370 --> 00:09:53,190
first I want to go and see if this event

00:09:50,450 --> 00:09:56,460
was delivered and it was it seems like

00:09:53,190 --> 00:10:00,420
it's fine with the time and then I go

00:09:56,460 --> 00:10:02,910
into the tweets and I can see here that

00:10:00,420 --> 00:10:07,590
the bad word has been replaced by the

00:10:02,910 --> 00:10:10,530
server dysfunction so so far we've seen

00:10:07,590 --> 00:10:12,420
the backend part is working but now

00:10:10,530 --> 00:10:15,180
we've been talking before about the UI

00:10:12,420 --> 00:10:17,400
components that change something and

00:10:15,180 --> 00:10:21,320
then trigger an update and also that

00:10:17,400 --> 00:10:25,590
some UI components subscribe to to these

00:10:21,320 --> 00:10:33,120
to this data so for this we have a react

00:10:25,590 --> 00:10:35,520
app and for those who already use graph

00:10:33,120 --> 00:10:37,530
QL you will be familiar with Apollo but

00:10:35,520 --> 00:10:42,030
I just want to quickly explain the setup

00:10:37,530 --> 00:10:45,900
so Apollo we can use to access graphical

00:10:42,030 --> 00:10:47,850
api's from any JavaScript framework and

00:10:45,900 --> 00:10:50,850
then we can do queries and mutations

00:10:47,850 --> 00:10:52,470
from our front-end then we need the

00:10:50,850 --> 00:10:55,110
WebSocket link because we will later

00:10:52,470 --> 00:10:57,300
have subscription so we need to have an

00:10:55,110 --> 00:11:01,520
open web socket for the API to be able

00:10:57,300 --> 00:11:05,340
to send updates to the front end here

00:11:01,520 --> 00:11:07,800
instantiate a new Apollo client and we

00:11:05,340 --> 00:11:11,070
pass a new WebSocket link which is the

00:11:07,800 --> 00:11:12,720
the URL from the endpoint we've seen

00:11:11,070 --> 00:11:16,380
before and from the API that we just

00:11:12,720 --> 00:11:18,300
created in the end we wrap the app

00:11:16,380 --> 00:11:21,090
inside Apollo provider

00:11:18,300 --> 00:11:23,430
allows us tend to use Apollo client in

00:11:21,090 --> 00:11:28,140
all of the components that we create in

00:11:23,430 --> 00:11:37,410
our app so let's see how this looks so

00:11:28,140 --> 00:11:41,910
far something nice now it just says

00:11:37,410 --> 00:11:47,340
dispatch so we need to add something

00:11:41,910 --> 00:11:49,560
here so to explain this we import

00:11:47,340 --> 00:11:54,210
graphical and use mutations from reactor

00:11:49,560 --> 00:11:57,090
the reactor is the way you can use graph

00:11:54,210 --> 00:12:00,840
QL and like more a newer way to use it

00:11:57,090 --> 00:12:03,210
compared to the commune components that

00:12:00,840 --> 00:12:05,040
you can also use with a problem the

00:12:03,210 --> 00:12:08,580
reactors are used mostly for functional

00:12:05,040 --> 00:12:10,740
components so we as you can see here

00:12:08,580 --> 00:12:12,780
this is the exact same mutation or a

00:12:10,740 --> 00:12:15,690
very similar mutation that we created

00:12:12,780 --> 00:12:18,990
before in the UI so it's nice that we

00:12:15,690 --> 00:12:21,420
can just integral check if the mutation

00:12:18,990 --> 00:12:23,220
is working and then copy paste it to our

00:12:21,420 --> 00:12:26,040
front-end because then it will it will

00:12:23,220 --> 00:12:28,590
work from there as well then we have our

00:12:26,040 --> 00:12:30,750
error function here and here we D

00:12:28,590 --> 00:12:32,880
structure the data with a Paolo client

00:12:30,750 --> 00:12:35,760
we have automatic access to the field

00:12:32,880 --> 00:12:38,400
data loading and error and here we say

00:12:35,760 --> 00:12:42,480
we use the mutation add tweet that we

00:12:38,400 --> 00:12:43,370
defined earlier here now we don't need

00:12:42,480 --> 00:12:47,040
this anymore

00:12:43,370 --> 00:12:49,080
and with the access to these three

00:12:47,040 --> 00:12:51,120
fields we can say if it's loading we

00:12:49,080 --> 00:12:52,530
display a span with loading if there's

00:12:51,120 --> 00:12:57,630
an error we want to display the error

00:12:52,530 --> 00:13:00,060
and if we have data we we have here the

00:12:57,630 --> 00:13:04,230
tweets that is component that we call

00:13:00,060 --> 00:13:06,390
with the data that we inserted and the

00:13:04,230 --> 00:13:09,900
rest is just the form that we've seen

00:13:06,390 --> 00:13:12,840
before now in the tweet silence

00:13:09,900 --> 00:13:14,760
component we use a subscription because

00:13:12,840 --> 00:13:16,950
this is the place where we want to have

00:13:14,760 --> 00:13:19,380
updates and we want to know what's the

00:13:16,950 --> 00:13:21,120
status of the tweet because if it's not

00:13:19,380 --> 00:13:22,770
yet sanitized we don't want to

00:13:21,120 --> 00:13:25,470
participate the content but as soon as

00:13:22,770 --> 00:13:28,590
it is sanitized we want to create to

00:13:25,470 --> 00:13:30,930
show the sanitized content so we have a

00:13:28,590 --> 00:13:33,120
subscription here and

00:13:30,930 --> 00:13:35,399
same way as we were using mutations we

00:13:33,120 --> 00:13:40,529
use subscriptions and what we're doing

00:13:35,399 --> 00:13:43,410
here is we say if we don't have data or

00:13:40,529 --> 00:13:44,490
if the data is not sanitized we cannot

00:13:43,410 --> 00:13:46,620
show the data so we're not showing

00:13:44,490 --> 00:13:50,279
anything except for a gift that we're

00:13:46,620 --> 00:13:54,330
still cleaning the data if there is data

00:13:50,279 --> 00:13:59,370
and there is the sanitized field of of

00:13:54,330 --> 00:14:01,620
this tweet is not null then we show the

00:13:59,370 --> 00:14:03,270
sanitized content and also a gift to

00:14:01,620 --> 00:14:06,420
show that now we're innocent that we can

00:14:03,270 --> 00:14:13,950
we can display the actual in the actual

00:14:06,420 --> 00:14:15,990
data so we'll see so what can i cannot

00:14:13,950 --> 00:14:29,339
say go to hell it's not nice but please

00:14:15,990 --> 00:14:31,170
go to ok so now it's loading it's

00:14:29,339 --> 00:14:33,270
loading a little bit to lock up so now

00:14:31,170 --> 00:14:35,580
it's cleaning and now this content is

00:14:33,270 --> 00:14:38,580
sanitized with the stars and we are

00:14:35,580 --> 00:14:45,050
innocent so it's it isn't it nice so

00:14:38,580 --> 00:14:45,050
this is working let's go back

00:14:47,930 --> 00:14:54,720
so the demo gods were nice to me so now

00:14:52,050 --> 00:14:57,899
this is now we've seen how we can

00:14:54,720 --> 00:15:00,360
implement also a kind of more backend

00:14:57,899 --> 00:15:05,160
architecture with the redux tile mental

00:15:00,360 --> 00:15:06,930
mental concept so we have an action that

00:15:05,160 --> 00:15:09,750
is dispatched that is in our case a

00:15:06,930 --> 00:15:11,880
graphical mutation geographical mutation

00:15:09,750 --> 00:15:13,920
has an event trigger that calls the

00:15:11,880 --> 00:15:16,380
server dysfunction which is our reducer

00:15:13,920 --> 00:15:19,589
the reducer updates the state the state

00:15:16,380 --> 00:15:21,600
is our graphical API and UI components

00:15:19,589 --> 00:15:24,290
that care about the state subscribe and

00:15:21,600 --> 00:15:27,540
then get updates with as live queries

00:15:24,290 --> 00:15:30,529
but now let's do a little bit something

00:15:27,540 --> 00:15:36,269
more complex that is also a lot of fun

00:15:30,529 --> 00:15:39,209
so if you're interested use this QR code

00:15:36,269 --> 00:15:40,649
because we are ordering food I mean it's

00:15:39,209 --> 00:15:43,940
quite late and I think everyone is

00:15:40,649 --> 00:15:50,940
hungry so get on this food ordering app

00:15:43,940 --> 00:15:55,440
or you can also use the URL down here ok

00:15:50,940 --> 00:16:01,290
so now I will order I will wait for a

00:15:55,440 --> 00:16:05,810
few more seconds now I want to place I

00:16:01,290 --> 00:16:10,260
want to order mango and now you can see

00:16:05,810 --> 00:16:12,540
four stages here so order validation

00:16:10,260 --> 00:16:15,060
payment restaurant approval and Driver

00:16:12,540 --> 00:16:17,550
assignment so these are all serverless

00:16:15,060 --> 00:16:19,740
functions or in our model reducers that

00:16:17,550 --> 00:16:22,860
get called based on something that is

00:16:19,740 --> 00:16:24,630
happening and now it stopped because

00:16:22,860 --> 00:16:27,839
it's waiting for my payment so I have to

00:16:24,630 --> 00:16:29,820
pay 500 rupees for my mango and it's

00:16:27,839 --> 00:16:32,430
done so now the restaurant approves this

00:16:29,820 --> 00:16:36,060
and the driver is assigned and now my

00:16:32,430 --> 00:16:38,760
order is complete now if I go to the

00:16:36,060 --> 00:16:42,240
analytics tab I can see you all ordering

00:16:38,760 --> 00:16:46,470
food and I can also see people don't

00:16:42,240 --> 00:16:49,829
like to pay for food because the brown

00:16:46,470 --> 00:16:52,320
and red lines are approval and

00:16:49,829 --> 00:16:54,870
validation and the green ones payment

00:16:52,320 --> 00:16:56,150
but then we just get free food is also

00:16:54,870 --> 00:16:58,190
fine

00:16:56,150 --> 00:17:02,870
and so what you can see is all these

00:16:58,190 --> 00:17:04,910
lines are UN component that subscribe to

00:17:02,870 --> 00:17:16,280
these herbalist functions and then get

00:17:04,910 --> 00:17:18,260
real-time updates so let's look at

00:17:16,280 --> 00:17:21,050
something more complex so my friend

00:17:18,260 --> 00:17:24,620
Shahid is ordering a thousand items of

00:17:21,050 --> 00:17:26,540
Indian food at the same time and this is

00:17:24,620 --> 00:17:28,160
what I was talking about the scaling

00:17:26,540 --> 00:17:30,200
before if you have a service function

00:17:28,160 --> 00:17:32,480
you don't need to care about scaling

00:17:30,200 --> 00:17:35,180
because with the platform and providers

00:17:32,480 --> 00:17:41,560
nowadays you have horizontal scaling so

00:17:35,180 --> 00:17:44,480
now 1,000 orders are being approved

00:17:41,560 --> 00:17:51,860
which is done and now he pays all of

00:17:44,480 --> 00:17:55,400
them so and now let's simulate a failure

00:17:51,860 --> 00:17:57,530
Network failure so let's say two AWS

00:17:55,400 --> 00:17:59,450
servers they just the land level was

00:17:57,530 --> 00:18:01,520
disconnected we're like oh no what about

00:17:59,450 --> 00:18:03,680
the restaurant business because some of

00:18:01,520 --> 00:18:05,870
these orders are in the middle of being

00:18:03,680 --> 00:18:08,030
processed and we might be scared that we

00:18:05,870 --> 00:18:11,930
will lose all the data because maybe

00:18:08,030 --> 00:18:15,590
some of the orders were paid but then in

00:18:11,930 --> 00:18:17,150
the middle they just get this function

00:18:15,590 --> 00:18:21,350
start running which you can see here

00:18:17,150 --> 00:18:27,290
it's completely come to a stop and if we

00:18:21,350 --> 00:18:29,570
go to see the rest the order page we see

00:18:27,290 --> 00:18:31,190
here an example where one order is stuck

00:18:29,570 --> 00:18:33,290
right in the middle so it's in the

00:18:31,190 --> 00:18:37,640
middle of the restaurant approval is the

00:18:33,290 --> 00:18:39,530
runs function so now we go back to AWS

00:18:37,640 --> 00:18:42,890
or we found the land cable to put it

00:18:39,530 --> 00:18:48,050
back in in the Amazon server and we

00:18:42,890 --> 00:18:50,120
enter the function and we save and then

00:18:48,050 --> 00:18:52,490
we can see that these functions just

00:18:50,120 --> 00:18:54,650
pick up where they left off so nothing

00:18:52,490 --> 00:18:57,560
is lost because there are subscriptions

00:18:54,650 --> 00:18:59,870
to the state in our graphical API that's

00:18:57,560 --> 00:19:02,120
that saved the current state and when

00:18:59,870 --> 00:19:04,190
the functions continue to run they just

00:19:02,120 --> 00:19:07,150
get the current state and can continue

00:19:04,190 --> 00:19:07,150
from where they left off

00:19:11,809 --> 00:19:20,040
so to summarize this we have a new order

00:19:16,620 --> 00:19:23,010
and in the beginning so we also have an

00:19:20,040 --> 00:19:25,050
orders table in our API in the beginning

00:19:23,010 --> 00:19:27,420
everything is false is validated is paid

00:19:25,050 --> 00:19:30,179
is approved and it's agent design it's

00:19:27,420 --> 00:19:32,340
all false then the first serverless

00:19:30,179 --> 00:19:35,190
function gets called and we want to

00:19:32,340 --> 00:19:38,070
validate the order then it's validated

00:19:35,190 --> 00:19:39,750
we change it to true then the second

00:19:38,070 --> 00:19:42,360
service function is called to check the

00:19:39,750 --> 00:19:44,700
payment when this is fine is paid

00:19:42,360 --> 00:19:46,740
becomes true then the restaurant needs

00:19:44,700 --> 00:19:50,520
to approve the order and is approved

00:19:46,740 --> 00:19:54,240
gets true and finally we need to assign

00:19:50,520 --> 00:19:57,420
the order to a driver and then also the

00:19:54,240 --> 00:20:00,240
last is agent assigned becomes true and

00:19:57,420 --> 00:20:01,950
what you can do here you can choose if

00:20:00,240 --> 00:20:05,700
you want to go through the whole process

00:20:01,950 --> 00:20:09,210
and then send the whole result back as a

00:20:05,700 --> 00:20:10,770
mutation to your to your API or you can

00:20:09,210 --> 00:20:12,840
have real-time updates after each

00:20:10,770 --> 00:20:15,480
service function to get an update on

00:20:12,840 --> 00:20:17,429
update on the UI which is probably what

00:20:15,480 --> 00:20:19,410
you want for a food ordering app because

00:20:17,429 --> 00:20:22,620
I want to know if my food is on the way

00:20:19,410 --> 00:20:24,270
or if the restaurant approved it so this

00:20:22,620 --> 00:20:29,880
is how it would work for in food

00:20:24,270 --> 00:20:32,040
ordering app and it's completed so this

00:20:29,880 --> 00:20:34,380
is everything for me you can check out

00:20:32,040 --> 00:20:38,550
the dangerous tweet app on my github

00:20:34,380 --> 00:20:40,770
account there's also two instructions

00:20:38,550 --> 00:20:43,830
how you what you have to add in your

00:20:40,770 --> 00:20:46,380
like in the Hazara project in the glitch

00:20:43,830 --> 00:20:49,470
project and in your react project to

00:20:46,380 --> 00:20:51,690
make it work if you have questions or

00:20:49,470 --> 00:20:54,750
want to talk about this architecture if

00:20:51,690 --> 00:20:56,610
you have different ideas of how we could

00:20:54,750 --> 00:20:58,980
do this I would be happy to talk to you

00:20:56,610 --> 00:21:01,170
and also have a lot of stickers and some

00:20:58,980 --> 00:21:03,309
t-shirts if you're interested so thank

00:21:01,170 --> 00:21:03,970
you very much

00:21:03,309 --> 00:21:08,180
you

00:21:03,970 --> 00:21:08,180

YouTube URL: https://www.youtube.com/watch?v=ccSgIdLv_EU


