Title: ReactiveConf 2019 - Benjie Gillam: Increasing Velocity with GraphQL and PostgreSQL
Publication date: 2019-10-31
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Millennium stage
-------------------------------------------------------------------
GraphQL has exploded in popularity since its public launch in 2015, and PostgreSQL is still going strong after 20 years of development, gaining market share and impressive features at an ever-increasing rate. These tools can pair beautifully, in particular, because they’re both strongly typed and declarative. In this talk, we’ll learn how combining these two technologies can lead to massively increased software development and delivery speed, faster APIs, fewer bugs, and ultimately enable you to focus on delivering value on the frontend rather than maintaining three different layers of data models and associated logic on the backend (DB, application, API).
Captions: 
	00:00:02,750 --> 00:00:11,900
[Music]

00:00:16,170 --> 00:00:21,820
hello everyone my name is Benji I'm a

00:00:19,420 --> 00:00:24,670
community-funded open source developer

00:00:21,820 --> 00:00:26,529
working in the graph QL nodejs and

00:00:24,670 --> 00:00:29,619
Postgres ecosystems

00:00:26,529 --> 00:00:32,439
it is my absolute pleasure and privilege

00:00:29,619 --> 00:00:34,570
to be here with you today speaking

00:00:32,439 --> 00:00:35,320
alongside all the incredible people that

00:00:34,570 --> 00:00:37,750
we'll be seeing

00:00:35,320 --> 00:00:40,030
talking about the various technologies

00:00:37,750 --> 00:00:43,840
that will shape the future of software

00:00:40,030 --> 00:00:46,090
development there's at least eight talks

00:00:43,840 --> 00:00:49,960
including this one that relate to graph

00:00:46,090 --> 00:00:52,960
QL at this conference and rightly so I

00:00:49,960 --> 00:00:57,090
fell in love with graph QL three years

00:00:52,960 --> 00:01:00,730
ago after 15 plus years of building and

00:00:57,090 --> 00:01:04,180
consuming api's and my feelings have

00:01:00,730 --> 00:01:07,660
only gotten stronger my main open source

00:01:04,180 --> 00:01:10,120
project is called post Bravo it looks at

00:01:07,660 --> 00:01:12,820
your post res database and it helps you

00:01:10,120 --> 00:01:16,450
to build a highly customizable graph QL

00:01:12,820 --> 00:01:19,299
API very rapidly I'm also a contributor

00:01:16,450 --> 00:01:21,400
to the graph cure specification working

00:01:19,299 --> 00:01:24,729
group and I helped to maintain the

00:01:21,400 --> 00:01:27,700
graphical graph to our IDE software and

00:01:24,729 --> 00:01:30,939
I have various other projects in the

00:01:27,700 --> 00:01:34,450
graph QL space but I'm not the only one

00:01:30,939 --> 00:01:37,030
passionate about graph QL since its

00:01:34,450 --> 00:01:40,090
release in 2015 graph QL has been

00:01:37,030 --> 00:01:42,280
growing in leaps and bounds fixing the

00:01:40,090 --> 00:01:45,100
problems of the biggest and the smallest

00:01:42,280 --> 00:01:47,619
companies alike and I'm certain that we

00:01:45,100 --> 00:01:50,649
will see it continue to grow over the

00:01:47,619 --> 00:01:54,670
coming years with its shiny new

00:01:50,649 --> 00:01:58,270
technology skyrocketing growth and huge

00:01:54,670 --> 00:02:01,299
impact it makes complete sense to see

00:01:58,270 --> 00:02:05,860
graph QL well-represented out reactive

00:02:01,299 --> 00:02:08,890
conf but it might seem strange that my

00:02:05,860 --> 00:02:12,490
talk is also about Postgres a relational

00:02:08,890 --> 00:02:14,890
database system even at my age it seems

00:02:12,490 --> 00:02:18,700
like relational databases have been

00:02:14,890 --> 00:02:20,650
around forever how do they fit into the

00:02:18,700 --> 00:02:24,069
technologies that will shape the future

00:02:20,650 --> 00:02:26,140
of software development well it turns

00:02:24,069 --> 00:02:28,330
out the relational database

00:02:26,140 --> 00:02:30,700
have been shaping the future for at

00:02:28,330 --> 00:02:33,610
least the last 30 years and are

00:02:30,700 --> 00:02:34,780
continuing to do so with that no signs

00:02:33,610 --> 00:02:38,410
of slowing down

00:02:34,780 --> 00:02:40,630
they are everywhere from the biggest

00:02:38,410 --> 00:02:43,090
internet scale companies to that save

00:02:40,630 --> 00:02:46,090
game file on your computer they're in

00:02:43,090 --> 00:02:48,100
your TVs on your set-top boxes they're

00:02:46,090 --> 00:02:52,120
in your smart phones and in your car's

00:02:48,100 --> 00:02:54,070
multimedia system in fact many of us are

00:02:52,120 --> 00:02:58,120
wearing relational databases on our

00:02:54,070 --> 00:03:01,240
wrists right now the term relational

00:02:58,120 --> 00:03:04,230
database was coined in 1970 but they

00:03:01,240 --> 00:03:07,020
really started to get big in the mid 80s

00:03:04,230 --> 00:03:09,520
by the mid 90s they were the dominant

00:03:07,020 --> 00:03:12,280
technology for large-scale data

00:03:09,520 --> 00:03:16,300
processing and they still hold that

00:03:12,280 --> 00:03:19,570
position today in the to thousands as

00:03:16,300 --> 00:03:22,120
the web began to get more dynamic it was

00:03:19,570 --> 00:03:24,040
natural to build our web applications on

00:03:22,120 --> 00:03:27,370
top of this pervasive database

00:03:24,040 --> 00:03:30,700
technology server-side languages such as

00:03:27,370 --> 00:03:33,459
PHP would construct the webpages and

00:03:30,700 --> 00:03:35,920
turn them into HTML and send them over

00:03:33,459 --> 00:03:39,910
the Internet to the web browser to be

00:03:35,920 --> 00:03:42,790
rendered databases weren't really as

00:03:39,910 --> 00:03:46,570
advanced back then focusing primarily on

00:03:42,790 --> 00:03:48,880
their central role of data storage so

00:03:46,570 --> 00:03:51,070
many people and engineers would treat

00:03:48,880 --> 00:03:54,010
the database as basically a glorified

00:03:51,070 --> 00:03:56,680
spreadsheet with the columns and the

00:03:54,010 --> 00:04:01,989
rows and the tables like you have tabs

00:03:56,680 --> 00:04:04,330
in Google Docs the application layer the

00:04:01,989 --> 00:04:07,270
layer that sat between the end user and

00:04:04,330 --> 00:04:11,620
the database written in a language like

00:04:07,270 --> 00:04:13,989
Ruby PHP Perl or Java was responsible

00:04:11,620 --> 00:04:15,820
for implementing the business logic the

00:04:13,989 --> 00:04:19,590
access control and other related

00:04:15,820 --> 00:04:21,820
concerns and this worked pretty well

00:04:19,590 --> 00:04:24,700
enter the 2010s

00:04:21,820 --> 00:04:28,900
and frameworks like backbone j/s and

00:04:24,700 --> 00:04:31,270
later react ember angular view and

00:04:28,900 --> 00:04:35,680
various others began to take center

00:04:31,270 --> 00:04:37,810
stage as JavaScript and the languages

00:04:35,680 --> 00:04:38,430
and the frameworks available within it

00:04:37,810 --> 00:04:41,670
became

00:04:38,430 --> 00:04:43,710
more and more powerful website started

00:04:41,670 --> 00:04:48,810
moving their rendering logic from the

00:04:43,710 --> 00:04:51,870
back end to the front end let's look at

00:04:48,810 --> 00:04:55,740
an example imagine that we've built a

00:04:51,870 --> 00:04:57,480
fully client rendered blog for the

00:04:55,740 --> 00:04:58,710
purpose of this example we're going to

00:04:57,480 --> 00:05:01,050
be pretty we're going to pretend that

00:04:58,710 --> 00:05:03,270
we're using react on the front end and a

00:05:01,050 --> 00:05:04,740
rails API on the back end but the

00:05:03,270 --> 00:05:07,950
pattern is similar for many other

00:05:04,740 --> 00:05:09,660
languages and frameworks now we want to

00:05:07,950 --> 00:05:12,480
add a feature to our blog we want to

00:05:09,660 --> 00:05:15,540
give users the ability to comment on our

00:05:12,480 --> 00:05:17,970
posts this might look something like

00:05:15,540 --> 00:05:19,980
this first of all we need somewhere to

00:05:17,970 --> 00:05:21,840
store the data so we're going to use

00:05:19,980 --> 00:05:24,360
something like a rails migration in

00:05:21,840 --> 00:05:28,380
order to create a database table like

00:05:24,360 --> 00:05:30,420
this one this one allows us to have a

00:05:28,380 --> 00:05:32,940
reference to the posts of the comment

00:05:30,420 --> 00:05:35,520
relates to the author of the comment and

00:05:32,940 --> 00:05:37,890
the text of the comment we need to

00:05:35,520 --> 00:05:39,960
represent this database table in rails

00:05:37,890 --> 00:05:42,180
and for that we'll use a model such as

00:05:39,960 --> 00:05:44,490
this one again stating that we have the

00:05:42,180 --> 00:05:46,710
relation to the post and the author and

00:05:44,490 --> 00:05:48,780
noting that certain of these are

00:05:46,710 --> 00:05:51,420
read-only fields we shouldn't update

00:05:48,780 --> 00:05:53,820
them we need a way of sending this data

00:05:51,420 --> 00:05:57,360
to the user and for that we'll use a

00:05:53,820 --> 00:06:00,210
view Orem rails a serializer to tell the

00:05:57,360 --> 00:06:01,920
framework how to take this model and to

00:06:00,210 --> 00:06:04,140
export it to the end-user

00:06:01,920 --> 00:06:07,680
and at this point we'll take the

00:06:04,140 --> 00:06:09,390
opportunity to maybe rename a few fields

00:06:07,680 --> 00:06:11,910
if they were in snake case and we want

00:06:09,390 --> 00:06:13,860
them in camel case in our API we might

00:06:11,910 --> 00:06:15,720
remove certain fields we don't want

00:06:13,860 --> 00:06:18,740
exposed or add additional information

00:06:15,720 --> 00:06:21,720
that might be useful

00:06:18,740 --> 00:06:25,230
we need a controller to describe which

00:06:21,720 --> 00:06:27,870
actions can take place and we need to

00:06:25,230 --> 00:06:29,550
expose those actions via something like

00:06:27,870 --> 00:06:33,840
a Rooter so that our client can actually

00:06:29,550 --> 00:06:36,840
issues them now parts of this process

00:06:33,840 --> 00:06:39,240
we've just seen can be templated but a

00:06:36,840 --> 00:06:41,760
lot of it requires human intervention

00:06:39,240 --> 00:06:44,490
especially later on if we get

00:06:41,760 --> 00:06:47,100
performance issues we might get issues

00:06:44,490 --> 00:06:49,080
like the n plus 1 problem or maybe the

00:06:47,100 --> 00:06:52,080
opposite maybe we're fetching too much

00:06:49,080 --> 00:06:53,759
data and that's giving us issues and for

00:06:52,080 --> 00:06:55,979
we may need to consult our old friend

00:06:53,759 --> 00:06:59,039
stackoverflow and figure out what the

00:06:55,979 --> 00:07:02,639
best way of solving this problem is in

00:06:59,039 --> 00:07:04,889
the client the story is similar we need

00:07:02,639 --> 00:07:07,500
a model to represent this data that we

00:07:04,889 --> 00:07:10,620
fetched from the API and in typescript

00:07:07,500 --> 00:07:13,830
it might look like this in Elm it might

00:07:10,620 --> 00:07:16,620
look like this but we've probably had to

00:07:13,830 --> 00:07:19,050
define this model by hand since we don't

00:07:16,620 --> 00:07:23,639
have a way to automatically generate it

00:07:19,050 --> 00:07:26,370
from our restful api we also need to

00:07:23,639 --> 00:07:28,830
manually write the code that coordinates

00:07:26,370 --> 00:07:31,440
the fetching of these related data

00:07:28,830 --> 00:07:33,180
models from the server and that needs to

00:07:31,440 --> 00:07:35,969
handle things like chained fetching

00:07:33,180 --> 00:07:38,340
network errors and maybe has something

00:07:35,969 --> 00:07:40,289
in it like some retry logic so we can

00:07:38,340 --> 00:07:44,819
handle those errors and still display

00:07:40,289 --> 00:07:46,919
something to the user we also probably

00:07:44,819 --> 00:07:49,860
need to write the code to handle our

00:07:46,919 --> 00:07:51,690
mutations and in order to build those we

00:07:49,860 --> 00:07:53,759
need to know what mutations the backend

00:07:51,690 --> 00:07:56,099
allows and for that we'll probably have

00:07:53,759 --> 00:07:58,800
to consult the backend documentation

00:07:56,099 --> 00:08:02,509
I hope it's up to date and that it tells

00:07:58,800 --> 00:08:06,659
us what the type of inputs expected are

00:08:02,509 --> 00:08:08,490
so we've just written a lot of code and

00:08:06,659 --> 00:08:10,770
we're not even going to be able to

00:08:08,490 --> 00:08:13,020
deploy it anytime soon because of the

00:08:10,770 --> 00:08:15,779
amount of both manual and automated

00:08:13,020 --> 00:08:18,000
testing that we need to do to give us

00:08:15,779 --> 00:08:22,199
confidence in the software that we've

00:08:18,000 --> 00:08:25,259
written for a typical web application

00:08:22,199 --> 00:08:28,830
backed by a relational database probably

00:08:25,259 --> 00:08:29,879
about 80 to 90 percent of your API will

00:08:28,830 --> 00:08:32,669
be like this

00:08:29,879 --> 00:08:35,909
fairly straightforward mappings from the

00:08:32,669 --> 00:08:38,880
database types all the way through to

00:08:35,909 --> 00:08:41,449
the front-end and this is true for

00:08:38,880 --> 00:08:45,329
things like customers products

00:08:41,449 --> 00:08:48,180
notifications emails teams very many of

00:08:45,329 --> 00:08:51,600
your database tables represent your

00:08:48,180 --> 00:08:54,260
business domain objects and they are

00:08:51,600 --> 00:08:56,550
then used throughout the entire stack

00:08:54,260 --> 00:08:58,800
sometimes you might need to add or

00:08:56,550 --> 00:09:00,480
remove fields from them or you might

00:08:58,800 --> 00:09:02,699
need to change the names of things

00:09:00,480 --> 00:09:05,110
slightly but overall the structure is

00:09:02,699 --> 00:09:07,000
very similar

00:09:05,110 --> 00:09:09,910
so let's go back to the drawing board

00:09:07,000 --> 00:09:14,440
and think about what we actually need in

00:09:09,910 --> 00:09:16,930
our code base in this the year 2019 if

00:09:14,440 --> 00:09:18,959
we minimize the amount of code we need

00:09:16,930 --> 00:09:21,730
to write then we can significantly

00:09:18,959 --> 00:09:25,589
increase the speed at which we can

00:09:21,730 --> 00:09:29,740
deliver awesome software to our users

00:09:25,589 --> 00:09:33,040
the first thing we need is a concise but

00:09:29,740 --> 00:09:34,870
expressive data definition language to

00:09:33,040 --> 00:09:37,360
describe what the shapes of our various

00:09:34,870 --> 00:09:40,620
entities are what fields they have what

00:09:37,360 --> 00:09:43,450
types that types those fields are and

00:09:40,620 --> 00:09:46,329
Harrod to those entities relate to one

00:09:43,450 --> 00:09:48,040
another and for that we've already got

00:09:46,329 --> 00:09:51,910
our create table statement we've already

00:09:48,040 --> 00:09:54,600
seen we also need to describe what

00:09:51,910 --> 00:09:56,709
actions can take place on this table in

00:09:54,600 --> 00:09:58,870
postcards we might do this with a grant

00:09:56,709 --> 00:10:01,540
statement saying which actions you can

00:09:58,870 --> 00:10:05,250
do and this is fine for our basic crud

00:10:01,540 --> 00:10:08,140
permissions create read update delete

00:10:05,250 --> 00:10:10,029
but if we need to go beyond crud

00:10:08,140 --> 00:10:12,339
then there's a way to do that in

00:10:10,029 --> 00:10:14,850
Postgres by using a function such as

00:10:12,339 --> 00:10:19,420
this one which allows us to flag

00:10:14,850 --> 00:10:21,130
inappropriate comments functions in post

00:10:19,420 --> 00:10:25,120
grades can be written in many different

00:10:21,130 --> 00:10:28,920
languages SQL of course but also Python

00:10:25,120 --> 00:10:32,320
Ruby and even JavaScript in our database

00:10:28,920 --> 00:10:35,230
so we've modeled our data types and

00:10:32,320 --> 00:10:37,870
their relations and the allowed actions

00:10:35,230 --> 00:10:40,690
on them but another need that we have is

00:10:37,870 --> 00:10:42,850
to define exactly which users are

00:10:40,690 --> 00:10:46,360
allowed to perform these actions and

00:10:42,850 --> 00:10:48,779
which rows or entities in our database

00:10:46,360 --> 00:10:53,140
are they allowed to manipulate with them

00:10:48,779 --> 00:10:55,810
now this is the tricky part for most of

00:10:53,140 --> 00:10:58,329
the past two decades there hasn't been a

00:10:55,810 --> 00:11:00,720
good way of expressing these granular

00:10:58,329 --> 00:11:03,399
security policies in Postgres

00:11:00,720 --> 00:11:05,199
so when people have attempted to solve

00:11:03,399 --> 00:11:09,040
this problem they may have used things

00:11:05,199 --> 00:11:12,100
like views and triggers and functions or

00:11:09,040 --> 00:11:15,190
even creating an individual database

00:11:12,100 --> 00:11:18,430
user for every application user that

00:11:15,190 --> 00:11:18,990
uses your application but these methods

00:11:18,430 --> 00:11:21,450
are

00:11:18,990 --> 00:11:23,820
really a good fit for our modern web

00:11:21,450 --> 00:11:25,350
applications they've caused lots of

00:11:23,820 --> 00:11:28,220
issues and headaches

00:11:25,350 --> 00:11:30,690
and this has led many people to say

00:11:28,220 --> 00:11:33,240
don't put your business logic in the

00:11:30,690 --> 00:11:35,820
database instead relying on the

00:11:33,240 --> 00:11:37,730
application layer to implement these

00:11:35,820 --> 00:11:41,670
permissions

00:11:37,730 --> 00:11:45,660
however it's key to note that technology

00:11:41,670 --> 00:11:48,360
advances it changes and improves and

00:11:45,660 --> 00:11:50,100
what was true in the past may not always

00:11:48,360 --> 00:11:52,920
be true in the future

00:11:50,100 --> 00:11:55,589
in fact the security policies that we

00:11:52,920 --> 00:11:58,980
need for our modern applications are now

00:11:55,589 --> 00:12:01,680
a feature that exists in Postgres it's

00:11:58,980 --> 00:12:05,279
called row-level security and it was

00:12:01,680 --> 00:12:09,330
introduced in Postgres 9.5 not even four

00:12:05,279 --> 00:12:11,670
years ago row-level security is very

00:12:09,330 --> 00:12:15,690
powerful it finally gives us the ability

00:12:11,670 --> 00:12:17,700
to express declaratively the granular

00:12:15,690 --> 00:12:20,730
permission system so our modern

00:12:17,700 --> 00:12:23,040
applications require when you define a

00:12:20,730 --> 00:12:25,320
row level security policy the filters

00:12:23,040 --> 00:12:28,250
defined within it are applied against

00:12:25,320 --> 00:12:30,870
every table access automatically and

00:12:28,250 --> 00:12:33,180
this is not only enforced for directly

00:12:30,870 --> 00:12:35,310
accessing the table it's also enforced

00:12:33,180 --> 00:12:38,130
when you access it through an aggregate

00:12:35,310 --> 00:12:41,100
or through a join or a sub query or a

00:12:38,130 --> 00:12:44,550
function call or any other way that you

00:12:41,100 --> 00:12:46,950
access that data and with very level

00:12:44,550 --> 00:12:49,410
security you share just one database

00:12:46,950 --> 00:12:51,089
role between all your applications users

00:12:49,410 --> 00:12:54,450
so it's very straightforward

00:12:51,089 --> 00:12:56,940
you can indicate the application user at

00:12:54,450 --> 00:13:01,560
runtime by just setting a session token

00:12:56,940 --> 00:13:04,950
in the transaction so row-level security

00:13:01,560 --> 00:13:07,250
is very powerful expressive and concise

00:13:04,950 --> 00:13:09,959
let's take a look at it

00:13:07,250 --> 00:13:12,329
our first policy starts with the create

00:13:09,959 --> 00:13:14,070
policy statement and we give it a name

00:13:12,329 --> 00:13:16,920
we want to be able to manage our own

00:13:14,070 --> 00:13:19,829
comments it applies to the comments

00:13:16,920 --> 00:13:22,459
table and it specifies what actions it

00:13:19,829 --> 00:13:25,560
governs in this case all of the actions

00:13:22,459 --> 00:13:28,440
but most importantly it then gives us a

00:13:25,560 --> 00:13:31,500
filter in this case we want to filter it

00:13:28,440 --> 00:13:32,520
to only the comment where I am the

00:13:31,500 --> 00:13:34,590
author here

00:13:32,520 --> 00:13:36,780
using a viewer ID function that we

00:13:34,590 --> 00:13:40,500
defined to find out what the current

00:13:36,780 --> 00:13:43,560
users ID is we might define other

00:13:40,500 --> 00:13:45,840
policies like one that says the admins

00:13:43,560 --> 00:13:48,680
can delete any comment that they want

00:13:45,840 --> 00:13:51,870
because maybe it's inappropriate and

00:13:48,680 --> 00:13:53,790
also we have another one that says that

00:13:51,870 --> 00:13:56,670
everyone can view comments because

00:13:53,790 --> 00:13:58,560
they're publicly visible an important

00:13:56,670 --> 00:14:01,920
thing to note about these is those

00:13:58,560 --> 00:14:04,680
filters are just SQL fragments so they

00:14:01,920 --> 00:14:07,200
can do anything that SQL can do they can

00:14:04,680 --> 00:14:09,270
query from other tables in sub queries

00:14:07,200 --> 00:14:13,920
they can cool functions they can do

00:14:09,270 --> 00:14:15,930
various other things so this looks to be

00:14:13,920 --> 00:14:19,020
exactly what we need for our modern

00:14:15,930 --> 00:14:21,660
applications but when it was first

00:14:19,020 --> 00:14:25,110
introduced it often suffered from quite

00:14:21,660 --> 00:14:27,300
significant performance issues and this

00:14:25,110 --> 00:14:29,490
isn't really surprising Postgres follows

00:14:27,300 --> 00:14:31,560
a great pattern of software development

00:14:29,490 --> 00:14:35,250
that you may will be familiar with make

00:14:31,560 --> 00:14:38,730
it work make it right and then make it

00:14:35,250 --> 00:14:40,860
fast in 2016 with the release of

00:14:38,730 --> 00:14:43,230
Postgres 9.5 they'd achieved the

00:14:40,860 --> 00:14:45,600
make-it-work part and a fair amount of

00:14:43,230 --> 00:14:47,850
the make it right part but it wasn't

00:14:45,600 --> 00:14:51,480
until the release of Postgres 10 in

00:14:47,850 --> 00:14:52,800
October 2017 just two years ago that

00:14:51,480 --> 00:14:55,890
they made it fast

00:14:52,800 --> 00:14:58,230
the legendary Tom Lane significantly

00:14:55,890 --> 00:15:00,510
improved the query planner so that

00:14:58,230 --> 00:15:05,430
well-written row-level security policies

00:15:00,510 --> 00:15:06,780
no longer have a performance penalty so

00:15:05,430 --> 00:15:08,640
we've seen that the past can be

00:15:06,780 --> 00:15:12,540
informative but it can also be

00:15:08,640 --> 00:15:14,220
misleading anyone who analyzed putting

00:15:12,540 --> 00:15:17,130
your permissions logic in your business

00:15:14,220 --> 00:15:20,460
logic into the database before this

00:15:17,130 --> 00:15:22,530
October 2017 release and found that it

00:15:20,460 --> 00:15:26,250
wasn't really a good fit was probably

00:15:22,530 --> 00:15:29,010
right but this is a conference about the

00:15:26,250 --> 00:15:32,330
future of software development it's time

00:15:29,010 --> 00:15:35,250
to reassess these outdated conclusions

00:15:32,330 --> 00:15:38,490
with new legislations such as the GDP

00:15:35,250 --> 00:15:41,520
our privacy in the news frequently a

00:15:38,490 --> 00:15:44,220
major security breaches seeming to

00:15:41,520 --> 00:15:46,410
happen all the time it's becoming more

00:15:44,220 --> 00:15:50,670
and more important to print

00:15:46,410 --> 00:15:53,730
Hecht you're users data why settle for

00:15:50,670 --> 00:15:57,690
putting all of this data in a big vault

00:15:53,730 --> 00:15:59,220
and hoping that no one gets in or that

00:15:57,690 --> 00:16:02,970
anyone that you let in behaves

00:15:59,220 --> 00:16:05,339
responsibly when instead you can have

00:16:02,970 --> 00:16:08,629
when in addition you can also have each

00:16:05,339 --> 00:16:11,850
piece of data have its own protection

00:16:08,629 --> 00:16:13,680
with row-level security if an attacker

00:16:11,850 --> 00:16:16,949
gets a direct connection to your

00:16:13,680 --> 00:16:21,889
database they still can't access other

00:16:16,949 --> 00:16:26,879
people's data that's really incredible

00:16:21,889 --> 00:16:29,100
so we've learnt that the SQL of 2019 can

00:16:26,879 --> 00:16:32,160
do a lot more to protect user data today

00:16:29,100 --> 00:16:34,110
than it could in the past but there are

00:16:32,160 --> 00:16:37,769
many reasons that we don't want to

00:16:34,110 --> 00:16:39,870
expose SQL to the client directly not

00:16:37,769 --> 00:16:42,810
least of which is because it doesn't fit

00:16:39,870 --> 00:16:45,540
the concerns and workflows the web

00:16:42,810 --> 00:16:48,240
application developers have they'd still

00:16:45,540 --> 00:16:50,970
need to abstract this data access like

00:16:48,240 --> 00:16:54,839
they do with typical REST API s in order

00:16:50,970 --> 00:16:57,089
to perform their everyday tasks can we

00:16:54,839 --> 00:17:00,319
remove the need for this layer of

00:16:57,089 --> 00:17:03,930
abstraction with a well-designed API I

00:17:00,319 --> 00:17:06,929
think we can enter graph q out

00:17:03,930 --> 00:17:09,839
graph QL encourages us to think in terms

00:17:06,929 --> 00:17:13,079
of the different entities or nodes in

00:17:09,839 --> 00:17:15,630
our business domain their properties and

00:17:13,079 --> 00:17:18,299
how they relate to each other these

00:17:15,630 --> 00:17:20,730
nodes their properties and the relations

00:17:18,299 --> 00:17:24,449
between them form a graph hence the name

00:17:20,730 --> 00:17:27,150
graph Q out the query language the QL

00:17:24,449 --> 00:17:28,940
allows the client to query this graph

00:17:27,150 --> 00:17:31,500
using a query such as this one

00:17:28,940 --> 00:17:34,200
retrieving all the data they need and

00:17:31,500 --> 00:17:37,409
only the data they've requested in a

00:17:34,200 --> 00:17:42,179
single query eliminating both under and

00:17:37,409 --> 00:17:43,980
over fetching but more importantly since

00:17:42,179 --> 00:17:47,630
we can get all the data that we need

00:17:43,980 --> 00:17:50,549
from the API in a convenient domain

00:17:47,630 --> 00:17:52,980
object-oriented shape we typically no

00:17:50,549 --> 00:17:55,110
longer need the client-side models in

00:17:52,980 --> 00:17:57,720
order to wrangle it into a more useful

00:17:55,110 --> 00:18:01,200
structure we can just use it directly

00:17:57,720 --> 00:18:04,230
and because graph qo is strongly typed

00:18:01,200 --> 00:18:06,899
and int respectable our editor can look

00:18:04,230 --> 00:18:09,179
at our graph QL API and it can give us a

00:18:06,899 --> 00:18:10,440
type-ahead to build our query it can

00:18:09,179 --> 00:18:13,200
even tell us when we've made a mistake

00:18:10,440 --> 00:18:16,620
or show us our documentation right there

00:18:13,200 --> 00:18:19,200
in line but it gets better

00:18:16,620 --> 00:18:21,600
this query which we wrote in next to no

00:18:19,200 --> 00:18:24,120
time thanks to autocomplete can be

00:18:21,600 --> 00:18:26,669
automatically converted into type safe

00:18:24,120 --> 00:18:28,710
code for fetching the data using

00:18:26,669 --> 00:18:32,039
something like the Guild's graph your

00:18:28,710 --> 00:18:34,320
code generator to use this query in a

00:18:32,039 --> 00:18:38,850
react component could be as easy as this

00:18:34,320 --> 00:18:40,830
single line of code this reduces the

00:18:38,850 --> 00:18:43,649
amount of code that we need to write

00:18:40,830 --> 00:18:46,980
quite significantly it makes it easier

00:18:43,649 --> 00:18:49,740
to write that code and it'll add ik

00:18:46,980 --> 00:18:53,419
eights entire classes of errors by

00:18:49,740 --> 00:18:56,789
thanks to the increased type of safety

00:18:53,419 --> 00:18:58,740
however building a graph QL API can be

00:18:56,789 --> 00:19:00,389
time-consuming and it has a lot of

00:18:58,740 --> 00:19:03,330
performance pitfalls you need to be

00:19:00,389 --> 00:19:06,240
aware of but this is where the power of

00:19:03,330 --> 00:19:08,730
Postgres comes in again thanks to post

00:19:06,240 --> 00:19:11,250
presses powerful features and strict

00:19:08,730 --> 00:19:14,250
contracts we can look at the database

00:19:11,250 --> 00:19:17,039
and automatically build a graph QL API

00:19:14,250 --> 00:19:19,409
by looking at the tables the

00:19:17,039 --> 00:19:22,500
relationships between the tables the

00:19:19,409 --> 00:19:25,049
index is on those tables the data types

00:19:22,500 --> 00:19:27,330
of our columns and the constraints the

00:19:25,049 --> 00:19:29,070
functions and the permissions and

00:19:27,330 --> 00:19:32,100
anything else that we see in the

00:19:29,070 --> 00:19:34,590
database of course we don't want to

00:19:32,100 --> 00:19:37,980
expose every structure in our database

00:19:34,590 --> 00:19:40,830
but we can use permissions hinting or

00:19:37,980 --> 00:19:46,289
even explicit instructions to govern

00:19:40,830 --> 00:19:48,149
what is exposed via our graph QL API so

00:19:46,289 --> 00:19:50,700
a significant amount of our graph your

00:19:48,149 --> 00:19:53,309
schema can be generated from our

00:19:50,700 --> 00:19:56,279
database massively reducing the amount

00:19:53,309 --> 00:19:58,769
of code that we need to write but this

00:19:56,279 --> 00:20:00,960
is only one piece of the puzzle

00:19:58,769 --> 00:20:03,029
we mentioned before that this is

00:20:00,960 --> 00:20:06,990
probably only going to work for about 80

00:20:03,029 --> 00:20:09,629
to 90 percent of our domain objects we

00:20:06,990 --> 00:20:11,430
also need to be able to add extra types

00:20:09,629 --> 00:20:14,910
and fields to better Express

00:20:11,430 --> 00:20:18,510
our API for example adding custom

00:20:14,910 --> 00:20:21,930
mutations or enabling access to services

00:20:18,510 --> 00:20:24,090
beyond our database or even integrating

00:20:21,930 --> 00:20:27,690
with third party API such as a payment

00:20:24,090 --> 00:20:29,880
provider post graph our enables you to

00:20:27,690 --> 00:20:32,370
accomplish this with schemer extensions

00:20:29,880 --> 00:20:35,190
or through its powerful plug-in system

00:20:32,370 --> 00:20:38,040
which enables comprehensive manipulation

00:20:35,190 --> 00:20:41,880
of how the graph QL schema itself is

00:20:38,040 --> 00:20:44,790
generated now once we've got all of this

00:20:41,880 --> 00:20:47,220
in place adding this commenting feature

00:20:44,790 --> 00:20:51,210
to our blog application becomes much

00:20:47,220 --> 00:20:53,250
more straightforward in the database we

00:20:51,210 --> 00:20:57,270
model the data and the relationships

00:20:53,250 --> 00:20:59,850
with our table statement we then outline

00:20:57,270 --> 00:21:01,920
the actions that can be performed on our

00:20:59,850 --> 00:21:04,050
table with the grant statement and we

00:21:01,920 --> 00:21:06,780
indicate which users may perform those

00:21:04,050 --> 00:21:08,880
actions with the policies in the

00:21:06,780 --> 00:21:10,740
front-end we then write the query that

00:21:08,880 --> 00:21:13,710
describes all the data that's necessary

00:21:10,740 --> 00:21:15,840
to render the page and finally we write

00:21:13,710 --> 00:21:18,420
that single line of code that runs the

00:21:15,840 --> 00:21:22,440
query and fetches the data in a type

00:21:18,420 --> 00:21:25,440
safe way and this is all the code

00:21:22,440 --> 00:21:27,990
required to model comments and their

00:21:25,440 --> 00:21:30,660
permissions and for the clients to fetch

00:21:27,990 --> 00:21:32,640
them when the client wants to do you

00:21:30,660 --> 00:21:35,940
mutations it will be similar to the code

00:21:32,640 --> 00:21:38,550
on the right-hand side so we don't need

00:21:35,940 --> 00:21:41,760
to write by hand the controller logic

00:21:38,550 --> 00:21:44,250
the serializers the Reuters the server

00:21:41,760 --> 00:21:47,010
side or the client side models the data

00:21:44,250 --> 00:21:51,060
fetching logic or the cache updating

00:21:47,010 --> 00:21:53,550
logic we can solely focus on the parts

00:21:51,060 --> 00:21:57,030
of the application where our efforts add

00:21:53,550 --> 00:22:02,370
value because everything else is

00:21:57,030 --> 00:22:05,130
standardized and automated and the icing

00:22:02,370 --> 00:22:08,250
on the cake is that both graph QL and

00:22:05,130 --> 00:22:11,550
SQL are declarative rather than

00:22:08,250 --> 00:22:14,550
imperative or functional languages so we

00:22:11,550 --> 00:22:17,160
can see the entire action that needs to

00:22:14,550 --> 00:22:20,340
take place ahead of time and we can plan

00:22:17,160 --> 00:22:23,250
accordingly for example our automated

00:22:20,340 --> 00:22:25,560
API might turn a graphical query such as

00:22:23,250 --> 00:22:28,140
this one into an SQL

00:22:25,560 --> 00:22:30,570
such as this one fetching all of the

00:22:28,140 --> 00:22:33,810
data that is needed and only the data

00:22:30,570 --> 00:22:36,690
that is needed in just one query this

00:22:33,810 --> 00:22:38,610
allows us to offload the complex task of

00:22:36,690 --> 00:22:41,010
figuring out how to retrieve the

00:22:38,610 --> 00:22:43,440
required data in the most efficient

00:22:41,010 --> 00:22:46,710
manner to software that has been honed

00:22:43,440 --> 00:22:47,790
over the past two decades for exactly

00:22:46,710 --> 00:22:51,120
this purpose

00:22:47,790 --> 00:22:53,790
modern Postgres even uses genetic

00:22:51,120 --> 00:22:58,460
algorithms in order to find the most

00:22:53,790 --> 00:23:01,110
efficient way of executing our queries

00:22:58,460 --> 00:23:02,970
so transforming our queries like this

00:23:01,110 --> 00:23:06,210
can lead to massively increased

00:23:02,970 --> 00:23:09,450
performance it also reduces the workload

00:23:06,210 --> 00:23:11,790
on the database it enables higher

00:23:09,450 --> 00:23:14,880
concurrency and reduces our request

00:23:11,790 --> 00:23:16,830
latency distant lights our users it

00:23:14,880 --> 00:23:20,250
pleases the people that are paying the

00:23:16,830 --> 00:23:22,380
server bills and it leads to wonderfully

00:23:20,250 --> 00:23:28,110
fast feature development which keeps our

00:23:22,380 --> 00:23:31,320
developers happy - so by embracing this

00:23:28,110 --> 00:23:34,110
modern tooling automation systems and

00:23:31,320 --> 00:23:36,690
code generation we've been able to

00:23:34,110 --> 00:23:39,540
massively reduce the amount of code we

00:23:36,690 --> 00:23:41,690
need to write and we've made it easier

00:23:39,540 --> 00:23:45,210
to write the code that we do need -

00:23:41,690 --> 00:23:47,220
we've reduced traffic not just from the

00:23:45,210 --> 00:23:50,070
client to the server but also between

00:23:47,220 --> 00:23:51,690
the server and the database minimizing

00:23:50,070 --> 00:23:54,030
the number of round trips in the amount

00:23:51,690 --> 00:23:57,930
of data transferred and reducing the

00:23:54,030 --> 00:24:00,270
workload across our entire stack we've

00:23:57,930 --> 00:24:03,330
also improved type safety not just

00:24:00,270 --> 00:24:06,150
within each of the individual layers but

00:24:03,330 --> 00:24:08,580
also between all of the layers which has

00:24:06,150 --> 00:24:12,300
helped to eradicate entire classes of

00:24:08,580 --> 00:24:14,640
bugs and most importantly we've

00:24:12,300 --> 00:24:18,530
increased the speed at which we can

00:24:14,640 --> 00:24:22,800
deliver excellent software to our users

00:24:18,530 --> 00:24:25,470
if you'd like to support or follow my

00:24:22,800 --> 00:24:28,410
open-source endeavors you can find me on

00:24:25,470 --> 00:24:30,930
github sponsors or Twitter as Benji I

00:24:28,410 --> 00:24:32,550
also carry stickers and a few cheat

00:24:30,930 --> 00:24:35,580
sheets so come and say hi during the

00:24:32,550 --> 00:24:35,910
conference thank you for listening to my

00:24:35,580 --> 00:24:39,270
talk

00:24:35,910 --> 00:24:41,490
it has barely scratched the surface

00:24:39,270 --> 00:24:44,370
of what is possible with graph QL and

00:24:41,490 --> 00:24:46,830
modern Postgres but I hope that it

00:24:44,370 --> 00:24:49,290
inspires you to reevaluate your

00:24:46,830 --> 00:24:53,150
preconceptions and to build things

00:24:49,290 --> 00:24:53,150
faster than ever before

00:24:54,320 --> 00:24:58,599

YouTube URL: https://www.youtube.com/watch?v=BNLcHlMn5X4


