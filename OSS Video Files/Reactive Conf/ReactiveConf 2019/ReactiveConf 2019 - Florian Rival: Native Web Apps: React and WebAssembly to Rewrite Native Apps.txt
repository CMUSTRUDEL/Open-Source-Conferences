Title: ReactiveConf 2019 - Florian Rival: Native Web Apps: React and WebAssembly to Rewrite Native Apps
Publication date: 2019-10-30
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Discovery stage
-------------------------------------------------------------------
Can React and web technologies compete with native toolkits when it comes to making super complex, rich desktop apps? Can we go further and create better-than-native applications?? Sounds like a good challenge

This talk introduces how React, JavaScript and WebAssembly can be used to write new ambitious apps, or port existing ones – with the real-world example of my open-source game development software. I’ll show how to leverage the React ecosystem to create performant applications: architecture, patterns, typing, useful open-source modules… and how to go one step further and provide a better user experience as well as a better developer experience.

These apps are not web apps, they are not native apps, they are hybrid “Native Web Apps” and can provide the best of both worlds.
Captions: 
	00:00:02,720 --> 00:00:11,850
[Music]

00:00:13,320 --> 00:00:17,020
all right thanks everyone for being

00:00:16,240 --> 00:00:20,050
there

00:00:17,020 --> 00:00:22,000
my name is frien I'm working at Google

00:00:20,050 --> 00:00:24,550
as a software engineer on the Android

00:00:22,000 --> 00:00:27,310
games team and there is two things that

00:00:24,550 --> 00:00:30,520
I like in life it's making applications

00:00:27,310 --> 00:00:31,869
and video games that's why I created the

00:00:30,520 --> 00:00:34,660
develop it's an open-source

00:00:31,869 --> 00:00:37,240
cross-platform game creator that people

00:00:34,660 --> 00:00:40,450
can use to create any kind of 2d games

00:00:37,240 --> 00:00:42,100
and it's a visual editor for games so

00:00:40,450 --> 00:00:44,739
there is a level editor that I will show

00:00:42,100 --> 00:00:46,809
just after and there is some kind of

00:00:44,739 --> 00:00:49,270
visual programming so that anyone can

00:00:46,809 --> 00:00:52,180
create games the rules of the game

00:00:49,270 --> 00:00:55,750
without having to do any kind of coding

00:00:52,180 --> 00:00:58,539
and at the end you're getting some html5

00:00:55,750 --> 00:01:01,989
games that can be outputted and played

00:00:58,539 --> 00:01:05,110
in a web browser or even on Android iOS

00:01:01,989 --> 00:01:07,810
or on desktop so that's what the

00:01:05,110 --> 00:01:10,120
software used to look like I say used to

00:01:07,810 --> 00:01:12,520
because that's the old version so it was

00:01:10,120 --> 00:01:15,280
all written in C++ as a desktop

00:01:12,520 --> 00:01:18,369
application that you could download for

00:01:15,280 --> 00:01:21,189
Windows Mac OS Linux so I will quickly

00:01:18,369 --> 00:01:22,869
show you oh it was walking and the

00:01:21,189 --> 00:01:24,430
visual programming I was talking about

00:01:22,869 --> 00:01:26,229
so you can see that there is the level

00:01:24,430 --> 00:01:28,450
editor on the Left it's done using

00:01:26,229 --> 00:01:30,070
OpenGL and you can create the level of

00:01:28,450 --> 00:01:32,860
the game and on the right there is a

00:01:30,070 --> 00:01:35,619
list of objects that are in your game so

00:01:32,860 --> 00:01:37,450
for example you have two player the

00:01:35,619 --> 00:01:39,729
platforms to button that is in the

00:01:37,450 --> 00:01:41,829
middle of the screen and so on and what

00:01:39,729 --> 00:01:43,780
I want to do is to add some rules to the

00:01:41,829 --> 00:01:45,700
game so that when the player is stepping

00:01:43,780 --> 00:01:47,350
on the button then the platform that is

00:01:45,700 --> 00:01:49,299
on the right is going a bit up in the

00:01:47,350 --> 00:01:51,250
air so that the player can step on it

00:01:49,299 --> 00:01:53,290
and continue in the lever so let's see

00:01:51,250 --> 00:01:55,479
how to do it so I'm putting the the

00:01:53,290 --> 00:01:59,170
button on the level and now I'm adding

00:01:55,479 --> 00:02:00,969
with visual events so evens are composed

00:01:59,170 --> 00:02:02,799
of condition and actions here I'm adding

00:02:00,969 --> 00:02:05,909
a condition to tell that if there is a

00:02:02,799 --> 00:02:09,100
collision between the player and the

00:02:05,909 --> 00:02:12,370
button then in this case I will launch

00:02:09,100 --> 00:02:14,290
two actions it's if then so the first

00:02:12,370 --> 00:02:16,960
action will be to change the animation

00:02:14,290 --> 00:02:19,390
of the button so that it goes in the

00:02:16,960 --> 00:02:22,060
state where it's priced and then I'm

00:02:19,390 --> 00:02:25,599
adding another action which is

00:02:22,060 --> 00:02:27,670
to move yes to add a force to add so

00:02:25,599 --> 00:02:30,220
that to the platform is moving up in the

00:02:27,670 --> 00:02:34,180
air so on the y-axis I'm adding of force

00:02:30,220 --> 00:02:36,069
and no I can press play and the world

00:02:34,180 --> 00:02:38,349
game is compiled to JavaScript and it's

00:02:36,069 --> 00:02:41,170
run in a browser and when I'm stepping

00:02:38,349 --> 00:02:43,390
on the button yeah it's walking so see

00:02:41,170 --> 00:02:45,220
it's fairly simple it's it's programming

00:02:43,390 --> 00:02:46,690
but for people that don't want or don't

00:02:45,220 --> 00:02:49,330
have the time to learn a new programming

00:02:46,690 --> 00:02:50,980
language and it's working very well

00:02:49,330 --> 00:02:53,260
people have been creating lots of

00:02:50,980 --> 00:02:56,580
different games with this I've done the

00:02:53,260 --> 00:02:59,980
one with the cat from the top left and

00:02:56,580 --> 00:03:01,780
fixed were going all right but at some

00:02:59,980 --> 00:03:05,260
point the wall editor was getting quite

00:03:01,780 --> 00:03:07,959
old I have lots of cross-platform issues

00:03:05,260 --> 00:03:10,450
with the UI toolkit and especially on

00:03:07,959 --> 00:03:12,640
Mac OS and Linux fins were crashing from

00:03:10,450 --> 00:03:16,180
time to time and iterating of the

00:03:12,640 --> 00:03:18,880
software was quite slow C++ building the

00:03:16,180 --> 00:03:21,880
UI was slow and I was limited to or do I

00:03:18,880 --> 00:03:23,380
components the native one and honestly

00:03:21,880 --> 00:03:25,750
the UX would need quite a lot of

00:03:23,380 --> 00:03:28,630
enhancements and also the entry barrier

00:03:25,750 --> 00:03:32,230
for new contributor was quite I suppose

00:03:28,630 --> 00:03:35,440
again so ya know it's time for me to

00:03:32,230 --> 00:03:37,299
react and my question was cool the web

00:03:35,440 --> 00:03:40,209
technologies help because I've been

00:03:37,299 --> 00:03:42,340
using quite a lot of react before my

00:03:40,209 --> 00:03:45,370
preview job and I was like I feel that's

00:03:42,340 --> 00:03:48,280
a better way to do things I think that

00:03:45,370 --> 00:03:48,790
it's perfect for making complex UI oh is

00:03:48,280 --> 00:03:51,100
it really

00:03:48,790 --> 00:03:53,290
can we have for example list of trees

00:03:51,100 --> 00:03:56,109
and of hundreds of elements dynamic

00:03:53,290 --> 00:03:59,109
panels 3d visualization nested dialogs

00:03:56,109 --> 00:04:01,660
drag and drop search and everything then

00:03:59,109 --> 00:04:03,910
make your app looks like a real dis of

00:04:01,660 --> 00:04:05,440
application rather than a web app can we

00:04:03,910 --> 00:04:07,660
make ambitious applications

00:04:05,440 --> 00:04:09,819
same with Java Script is perfect for

00:04:07,660 --> 00:04:11,950
most applications oh really

00:04:09,819 --> 00:04:15,340
what if we have an already existing

00:04:11,950 --> 00:04:17,500
native code base like I do oh if we want

00:04:15,340 --> 00:04:20,380
to do advanced computation or if we need

00:04:17,500 --> 00:04:23,710
consistent performance well let's let's

00:04:20,380 --> 00:04:26,229
take a look this is the world C++ code

00:04:23,710 --> 00:04:28,330
base of the software well that was the

00:04:26,229 --> 00:04:31,150
code base so that was in the middle of

00:04:28,330 --> 00:04:32,560
the code base the core classes what a

00:04:31,150 --> 00:04:35,270
game is what an object is what the

00:04:32,560 --> 00:04:37,670
texture is and the game in the game

00:04:35,270 --> 00:04:40,100
voters so that sticking with this model

00:04:37,670 --> 00:04:43,940
of a game and transpiling it to

00:04:40,100 --> 00:04:45,820
JavaScript as a WebGL game and on top of

00:04:43,940 --> 00:04:48,980
it there was everything ready to the

00:04:45,820 --> 00:04:51,170
graphic interface and the file system so

00:04:48,980 --> 00:04:53,270
I was thinking okay I could redo the

00:04:51,170 --> 00:04:53,810
whole interface using react and for the

00:04:53,270 --> 00:04:56,330
file system

00:04:53,810 --> 00:04:58,940
I could change it to use natural essence

00:04:56,330 --> 00:05:02,780
also browser adapters and run the

00:04:58,940 --> 00:05:04,940
wulfing on not jes or Chrome or run it

00:05:02,780 --> 00:05:06,230
or package it using electrons so that I

00:05:04,940 --> 00:05:10,370
have an application that people can

00:05:06,230 --> 00:05:13,250
download and what to do with the the C++

00:05:10,370 --> 00:05:17,870
code base where I could compile it to

00:05:13,250 --> 00:05:19,580
webassembly let's see this part so if

00:05:17,870 --> 00:05:21,620
you don't know about webassembly it's a

00:05:19,580 --> 00:05:24,590
low-level language that is running in

00:05:21,620 --> 00:05:29,210
your browser in all evil green browser

00:05:24,590 --> 00:05:31,520
it's supported by even on mobile phones

00:05:29,210 --> 00:05:32,990
on Android and iOS and it's a low-level

00:05:31,520 --> 00:05:35,440
language meaning that you're not writing

00:05:32,990 --> 00:05:37,850
web assembly and but you're compiling

00:05:35,440 --> 00:05:40,160
from another language to web assembly

00:05:37,850 --> 00:05:42,800
and it's running fast it's running fast

00:05:40,160 --> 00:05:45,220
because as its assembly like browser can

00:05:42,800 --> 00:05:47,120
optimize it much more quickly than

00:05:45,220 --> 00:05:50,450
JavaScript and you get consistent

00:05:47,120 --> 00:05:52,400
performance so I said that we are not

00:05:50,450 --> 00:05:54,110
writing directly to webassembly but

00:05:52,400 --> 00:05:56,240
using things like for example Krypton

00:05:54,110 --> 00:05:59,000
which is a project to compile from C++

00:05:56,240 --> 00:06:00,680
to web assembly or using a language like

00:05:59,000 --> 00:06:02,810
reversed all the languages that are

00:06:00,680 --> 00:06:06,050
combining to web assembly or you can

00:06:02,810 --> 00:06:07,520
even try it using assembly script which

00:06:06,050 --> 00:06:09,860
is a long range that looks like

00:06:07,520 --> 00:06:12,320
typescript and that combines to twelve

00:06:09,860 --> 00:06:14,060
assembly in my case I've been using EPS

00:06:12,320 --> 00:06:16,760
Krypton because I had V C++ code base

00:06:14,060 --> 00:06:18,950
that I wanted to port on the web so I

00:06:16,760 --> 00:06:21,890
will describe how it work and then we'll

00:06:18,950 --> 00:06:23,210
see the the part about remaking the

00:06:21,890 --> 00:06:25,670
world interface in react

00:06:23,210 --> 00:06:26,240
so first webassembly sorry first

00:06:25,670 --> 00:06:28,250
Emscripten

00:06:26,240 --> 00:06:30,020
if you want to try it it's not that

00:06:28,250 --> 00:06:32,270
complicated you have to clone the SDK

00:06:30,020 --> 00:06:34,640
with those comments that I won't detail

00:06:32,270 --> 00:06:35,870
and then you're getting a compiler

00:06:34,640 --> 00:06:38,480
called EMCC

00:06:35,870 --> 00:06:41,720
that you can run on the C or C++ file

00:06:38,480 --> 00:06:44,540
and you're getting as as the output a

00:06:41,720 --> 00:06:47,500
J's file that is running a web assembly

00:06:44,540 --> 00:06:49,120
file for larger projects

00:06:47,500 --> 00:06:51,190
Krypton is providing you with a

00:06:49,120 --> 00:06:55,450
replacement for your compiler so that

00:06:51,190 --> 00:06:57,940
you can swap your your project build and

00:06:55,450 --> 00:07:01,360
instead of getting a binary you will be

00:06:57,940 --> 00:07:04,060
getting a web assembly module so in my

00:07:01,360 --> 00:07:06,130
case I'm using Simek but depends on what

00:07:04,060 --> 00:07:10,690
could be Co you're trying to port to the

00:07:06,130 --> 00:07:12,640
web so if you're compiling the wulfing

00:07:10,690 --> 00:07:15,460
to webassembly you have this huge chunk

00:07:12,640 --> 00:07:17,140
of C++ compiler web assembly and that's

00:07:15,460 --> 00:07:19,900
not enough you have to expose the

00:07:17,140 --> 00:07:21,550
existing classes in in C++ or worse or

00:07:19,900 --> 00:07:23,530
whatever your language so that you can

00:07:21,550 --> 00:07:25,810
use them in JavaScript let's take an

00:07:23,530 --> 00:07:27,940
example here is a layout it's it's a

00:07:25,810 --> 00:07:30,280
scene it's a level of a game it's it's a

00:07:27,940 --> 00:07:33,100
C++ class and you can set the name get

00:07:30,280 --> 00:07:35,590
the name of the scene and you can insert

00:07:33,100 --> 00:07:38,020
or get an object on the scene though

00:07:35,590 --> 00:07:40,300
that's just an example we don't really

00:07:38,020 --> 00:07:42,550
care about what's inside this code the

00:07:40,300 --> 00:07:46,330
idea is that you are you have to write

00:07:42,550 --> 00:07:49,000
the interface so that Emscripten can

00:07:46,330 --> 00:07:51,040
know what classes to expose to Java

00:07:49,000 --> 00:07:52,750
scripts so that looks like this there

00:07:51,040 --> 00:07:55,120
are multiple ways of doing it in my case

00:07:52,750 --> 00:07:57,280
I've been using something called web IDL

00:07:55,120 --> 00:08:02,280
it's an interface definition language

00:07:57,280 --> 00:08:06,130
it's used by the w3c to write the

00:08:02,280 --> 00:08:09,729
specification for the Dom itself so we

00:08:06,130 --> 00:08:13,150
can also use it to to show to

00:08:09,729 --> 00:08:15,700
description what should be exposed to

00:08:13,150 --> 00:08:17,710
JavaScript so here I'm writing the

00:08:15,700 --> 00:08:19,570
interface of the class the layout with

00:08:17,710 --> 00:08:21,520
two methods that name gain name and

00:08:19,570 --> 00:08:23,680
choose a method to insert and get an

00:08:21,520 --> 00:08:27,640
object you can see that the type are

00:08:23,680 --> 00:08:30,010
slightly different and the idea that you

00:08:27,640 --> 00:08:32,770
have to look at the documentation of

00:08:30,010 --> 00:08:34,930
inscription or your language to see what

00:08:32,770 --> 00:08:39,280
type are being converted in your

00:08:34,930 --> 00:08:41,260
language and to to JavaScript don't you

00:08:39,280 --> 00:08:43,659
have it you can run it and Emscripten

00:08:41,260 --> 00:08:44,260
will be compiling your C++ code to

00:08:43,659 --> 00:08:46,450
webassembly

00:08:44,260 --> 00:08:48,460
and including these bindings that you've

00:08:46,450 --> 00:08:51,490
been writing generating some kind of

00:08:48,460 --> 00:08:53,380
glue code that is calling from so that

00:08:51,490 --> 00:08:56,530
when you called the JavaScript class

00:08:53,380 --> 00:08:58,570
it's inside it's calling web assembly

00:08:56,530 --> 00:09:01,210
that looks like this at the end you have

00:08:58,570 --> 00:09:04,120
a module that you instantiate getting

00:09:01,210 --> 00:09:06,880
the the object in a promise and then you

00:09:04,120 --> 00:09:08,860
can create a new object here layout call

00:09:06,880 --> 00:09:11,620
the function on it like set name

00:09:08,860 --> 00:09:13,720
same with other objects and you can even

00:09:11,620 --> 00:09:15,820
console.log the the result of a method

00:09:13,720 --> 00:09:19,030
returning returning a string and that's

00:09:15,820 --> 00:09:22,660
that's working well the primitive types

00:09:19,030 --> 00:09:25,750
like number of billions automatically

00:09:22,660 --> 00:09:28,570
converted to the equivalent in in your

00:09:25,750 --> 00:09:30,670
oast language so again look at the

00:09:28,570 --> 00:09:33,910
documentation to see for example the

00:09:30,670 --> 00:09:37,210
javascript strains are converted to an

00:09:33,910 --> 00:09:41,170
array of characters in NC if you pass an

00:09:37,210 --> 00:09:43,780
object you will get a reference to an

00:09:41,170 --> 00:09:46,120
object of a pointer in C++ and if you

00:09:43,780 --> 00:09:47,700
want to put things in the console in CS

00:09:46,120 --> 00:09:51,930
pressed will be automatically redirected

00:09:47,700 --> 00:09:55,150
to the console in Inyo in your debugger

00:09:51,930 --> 00:09:57,370
so that's what you getting if you're

00:09:55,150 --> 00:09:59,170
running the world library in the chrome

00:09:57,370 --> 00:10:03,070
debugger so you can see that on the top

00:09:59,170 --> 00:10:05,530
there are some logs that are outputted

00:10:03,070 --> 00:10:07,540
by the C++ library so it's it's walking

00:10:05,530 --> 00:10:09,580
and then you can create an object and

00:10:07,540 --> 00:10:12,310
call method and get the result of

00:10:09,580 --> 00:10:14,050
another one so yeah you have been

00:10:12,310 --> 00:10:17,110
something walking in your browser even

00:10:14,050 --> 00:10:19,720
if it's written in C++ or restos off or

00:10:17,110 --> 00:10:22,360
something else so that's a pretty good

00:10:19,720 --> 00:10:24,640
first step there are a few things to

00:10:22,360 --> 00:10:27,520
know first the memory management

00:10:24,640 --> 00:10:29,110
requires care because if you're creating

00:10:27,520 --> 00:10:30,420
something in the web assembly warned you

00:10:29,110 --> 00:10:34,930
have to destroy it

00:10:30,420 --> 00:10:37,000
meaning that let me explain if you

00:10:34,930 --> 00:10:39,670
creating a layout which is an object

00:10:37,000 --> 00:10:41,530
written in my library if you consult

00:10:39,670 --> 00:10:43,450
that log it you see that it's not a real

00:10:41,530 --> 00:10:47,410
JavaScript object it's a JavaScript

00:10:43,450 --> 00:10:50,170
object containing a pointer to some some

00:10:47,410 --> 00:10:51,940
number which is a number that is

00:10:50,170 --> 00:10:54,070
pointing to some part of the web

00:10:51,940 --> 00:10:56,470
assembly memory you can think of the web

00:10:54,070 --> 00:10:58,270
assembly memory as a big array that is

00:10:56,470 --> 00:11:00,310
empty at the beginning and when you're

00:10:58,270 --> 00:11:02,830
creating a new object the web assembly

00:11:00,310 --> 00:11:06,220
code is running some constructor to

00:11:02,830 --> 00:11:09,459
create new objects in memory and so it's

00:11:06,220 --> 00:11:10,399
an array of bits basically if you don't

00:11:09,459 --> 00:11:12,769
destroy it

00:11:10,399 --> 00:11:15,379
if you just forget about this layered

00:11:12,769 --> 00:11:17,899
variable in your JavaScript then the

00:11:15,379 --> 00:11:20,449
reference to this memory is lost forever

00:11:17,899 --> 00:11:22,670
basically you have a memory so you have

00:11:20,449 --> 00:11:25,160
to remember to call the GD when the

00:11:22,670 --> 00:11:27,589
module dot destroy method that will be

00:11:25,160 --> 00:11:30,019
basically running the destructor in

00:11:27,589 --> 00:11:33,559
super spruce rust whatever and we'll

00:11:30,019 --> 00:11:35,959
really the memory so that's something

00:11:33,559 --> 00:11:38,269
that you have to remember to do and for

00:11:35,959 --> 00:11:40,459
example if you're using a react that

00:11:38,269 --> 00:11:42,829
means that when you're mounting a

00:11:40,459 --> 00:11:44,480
component if you're creating an object

00:11:42,829 --> 00:11:45,829
in the web assembly world be sure to

00:11:44,480 --> 00:11:49,809
destroy it when the component is

00:11:45,829 --> 00:11:52,279
unwanted oh you can use an effective

00:11:49,809 --> 00:11:53,839
second thing to know that the output of

00:11:52,279 --> 00:11:55,809
the web assembly model will be quite

00:11:53,839 --> 00:11:59,149
large it's three megabytes for G develop

00:11:55,809 --> 00:12:01,699
you can can compress it and it's only a

00:11:59,149 --> 00:12:03,439
few megabytes honestly I don't really

00:12:01,699 --> 00:12:05,870
care because I'm making an application

00:12:03,439 --> 00:12:08,290
that is a rich application so a few

00:12:05,870 --> 00:12:11,420
megabytes more or less that's the same

00:12:08,290 --> 00:12:13,129
I'm happy I'm not happy but I'm fine

00:12:11,420 --> 00:12:15,170
with user having to wait a bit during

00:12:13,129 --> 00:12:17,569
the loading time of the application to

00:12:15,170 --> 00:12:20,839
get this because it's a rich experience

00:12:17,569 --> 00:12:23,420
also the wulfing can be downloaded using

00:12:20,839 --> 00:12:28,160
electron which is a few Android megabyte

00:12:23,420 --> 00:12:30,139
so one more one less something some last

00:12:28,160 --> 00:12:33,470
thing to know is that you better have a

00:12:30,139 --> 00:12:35,929
complete test set for your library that

00:12:33,470 --> 00:12:37,939
is compared to web assembly because this

00:12:35,929 --> 00:12:40,249
is the kind of error that you're getting

00:12:37,939 --> 00:12:43,160
is something is going wrong in your web

00:12:40,249 --> 00:12:45,800
assembly module so it's not it's not

00:12:43,160 --> 00:12:47,480
useful at whole and that can happen if

00:12:45,800 --> 00:12:50,899
for example you pass a wrong type of

00:12:47,480 --> 00:12:54,679
parameter to a method or you forget the

00:12:50,899 --> 00:12:56,389
parameter in this case your you your web

00:12:54,679 --> 00:12:58,339
assembly code will be expecting for

00:12:56,389 --> 00:13:00,649
example a pointer to an object

00:12:58,339 --> 00:13:04,069
if you pass instead a number which is

00:13:00,649 --> 00:13:06,170
meaning nothing then it will go to some

00:13:04,069 --> 00:13:09,110
place in the memory where there is

00:13:06,170 --> 00:13:11,179
garbage and bad things will happen that

00:13:09,110 --> 00:13:14,620
can also be the case if you are using a

00:13:11,179 --> 00:13:17,089
deleted object the best things are a bit

00:13:14,620 --> 00:13:19,220
manual walk that we are not used to do

00:13:17,089 --> 00:13:22,100
in JavaScript but once you get used to

00:13:19,220 --> 00:13:23,279
it it's it's fine and it's a it's mainly

00:13:22,100 --> 00:13:26,160
to remember to alway

00:13:23,279 --> 00:13:29,279
is use an object after creating it and

00:13:26,160 --> 00:13:31,470
deleting it and to pass to make sure to

00:13:29,279 --> 00:13:34,769
pass the proper types for the parameters

00:13:31,470 --> 00:13:36,209
this being said we now have the the core

00:13:34,769 --> 00:13:38,970
of the of the application that is

00:13:36,209 --> 00:13:40,860
compiled to web assembly and running in

00:13:38,970 --> 00:13:42,809
a browser that's a good first step let's

00:13:40,860 --> 00:13:44,970
now see if we can redo an interface on

00:13:42,809 --> 00:13:47,189
top of it that is better than what we

00:13:44,970 --> 00:13:49,680
had before so we want to make a complex

00:13:47,189 --> 00:13:54,540
UI and by complex UI I mean a UI with

00:13:49,680 --> 00:13:58,290
context menu thumbnails list of objects

00:13:54,540 --> 00:14:00,180
trees dialogues so the first thing I

00:13:58,290 --> 00:14:03,300
wanted to do was to find a component

00:14:00,180 --> 00:14:06,029
library matter UI rect tool box

00:14:03,300 --> 00:14:07,829
blueprint whatever my idea was to find

00:14:06,029 --> 00:14:09,959
something with an extensive list of high

00:14:07,829 --> 00:14:12,240
quality components good theming support

00:14:09,959 --> 00:14:14,569
accessibility maybe the most important

00:14:12,240 --> 00:14:17,189
thing and a good documentation quality

00:14:14,569 --> 00:14:20,730
in my case I've been using metal UI but

00:14:17,189 --> 00:14:22,139
others can be fine too then the first

00:14:20,730 --> 00:14:23,790
change I had when we were making this

00:14:22,139 --> 00:14:25,470
world interface in Arad was to display

00:14:23,790 --> 00:14:28,589
large lists of objects and when I say

00:14:25,470 --> 00:14:30,449
large it's sometimes Android of elements

00:14:28,589 --> 00:14:33,209
or thousands first about the list of

00:14:30,449 --> 00:14:35,639
objects in a game in this case using via

00:14:33,209 --> 00:14:37,199
tries list has been really useful using

00:14:35,639 --> 00:14:39,870
your example reactor to rise don't react

00:14:37,199 --> 00:14:41,759
window and the idea is that instead of

00:14:39,870 --> 00:14:43,920
just mapping on a list of objects and

00:14:41,759 --> 00:14:47,129
displaying all of them in the Dom in the

00:14:43,920 --> 00:14:49,410
browser the virtualization library will

00:14:47,129 --> 00:14:52,139
give you a list component with a

00:14:49,410 --> 00:14:54,689
function here called Ravinder and this

00:14:52,139 --> 00:14:57,740
function will be called to render only a

00:14:54,689 --> 00:15:00,870
subset of the list which is the the

00:14:57,740 --> 00:15:02,939
object data to display on the screen so

00:15:00,870 --> 00:15:05,550
if your screen is displaying 20 objects

00:15:02,939 --> 00:15:07,350
you will only have in the dom 20 object

00:15:05,550 --> 00:15:08,939
rather than a thousand and then when

00:15:07,350 --> 00:15:10,350
you're scrolling some object are being

00:15:08,939 --> 00:15:13,589
removed from the dom and other

00:15:10,350 --> 00:15:15,990
added you can even use react DND if you

00:15:13,589 --> 00:15:19,589
want to add drag and dropped to the vias

00:15:15,990 --> 00:15:21,959
list and it's working very well the next

00:15:19,589 --> 00:15:23,970
trend that I had was to display some

00:15:21,959 --> 00:15:26,100
panels or resizable editor because as

00:15:23,970 --> 00:15:28,379
I'm making I'm making a game engine a

00:15:26,100 --> 00:15:30,269
gave me detour people want to be able to

00:15:28,379 --> 00:15:33,449
customize that workspace and it's not

00:15:30,269 --> 00:15:35,850
something that we really used to do on

00:15:33,449 --> 00:15:36,899
the web but turns out that there are

00:15:35,850 --> 00:15:38,939
libraries that are do

00:15:36,899 --> 00:15:40,680
this forest so basically take a look at

00:15:38,939 --> 00:15:43,319
reacting mosaic it's awesome because

00:15:40,680 --> 00:15:44,819
it's giving you a kind of yeah window

00:15:43,319 --> 00:15:47,189
management library that is doing

00:15:44,819 --> 00:15:49,709
everything for you and so you can have a

00:15:47,189 --> 00:15:52,259
workspace that user can customize so

00:15:49,709 --> 00:15:55,230
it's very great then this next wrench

00:15:52,259 --> 00:15:57,269
was to display large trees on the on the

00:15:55,230 --> 00:15:59,069
screen so you can see that's the event I

00:15:57,269 --> 00:16:01,439
did thought that was done on the left in

00:15:59,069 --> 00:16:04,290
C++ in the native application it was

00:16:01,439 --> 00:16:06,629
quite complex and honestly up to

00:16:04,290 --> 00:16:07,319
maintain it was a two thousand line of

00:16:06,629 --> 00:16:11,579
C++

00:16:07,319 --> 00:16:14,279
so here I've been using again another

00:16:11,579 --> 00:16:16,769
library to make this tree of events

00:16:14,279 --> 00:16:21,029
because events can have sub events it's

00:16:16,769 --> 00:16:23,399
a bit like cut blocks that can have sub

00:16:21,029 --> 00:16:26,759
well not serve events but also cut

00:16:23,399 --> 00:16:28,800
blocks nested inside anyway here the

00:16:26,759 --> 00:16:30,749
transition again is really useful I've

00:16:28,800 --> 00:16:32,550
been using a react saw table tree which

00:16:30,749 --> 00:16:34,709
is giving you a good start if you want

00:16:32,550 --> 00:16:36,209
to make some kind of you know business

00:16:34,709 --> 00:16:38,819
rules that you can drag and drop on the

00:16:36,209 --> 00:16:41,910
screen in my case I'm using a evilly

00:16:38,819 --> 00:16:43,980
customized version of it and I think

00:16:41,910 --> 00:16:46,230
maybe the most complex thing to do was

00:16:43,980 --> 00:16:49,050
to remake the world level editor that

00:16:46,230 --> 00:16:52,350
was done before in OpenGL and know that

00:16:49,050 --> 00:16:54,480
I wanted to have on the web at this

00:16:52,350 --> 00:16:54,959
point using the dome was not an option

00:16:54,480 --> 00:16:57,089
anymore

00:16:54,959 --> 00:16:59,699
you can forget about it and start to

00:16:57,089 --> 00:17:03,269
think about using WebGL when using WebGL

00:16:59,699 --> 00:17:05,909
it's a bit harder to make to get started

00:17:03,269 --> 00:17:08,640
so I've been using a library which is

00:17:05,909 --> 00:17:11,640
called pixie Jas which is it's a

00:17:08,640 --> 00:17:14,399
rendering library rendering on on WebGL

00:17:11,640 --> 00:17:18,089
or canvas and there is also phaser

00:17:14,399 --> 00:17:20,579
Twitter Jas anyway think about it if you

00:17:18,089 --> 00:17:23,159
have to do something that is a bit too

00:17:20,579 --> 00:17:26,850
complex for the dome like 2d rendering

00:17:23,159 --> 00:17:29,480
of some of thousand of elements like you

00:17:26,850 --> 00:17:32,429
like Oliver in a game still some time

00:17:29,480 --> 00:17:34,140
the dome can be useful let's say that

00:17:32,429 --> 00:17:37,020
you want to have an editor where you're

00:17:34,140 --> 00:17:39,779
displaying the polygon to it box

00:17:37,020 --> 00:17:41,610
the collision mask of often objects so

00:17:39,779 --> 00:17:44,429
in my case I want people to be able in

00:17:41,610 --> 00:17:46,950
the entire game to say that this red

00:17:44,429 --> 00:17:48,880
area is the place where the spaceship of

00:17:46,950 --> 00:17:52,870
the player can be it and

00:17:48,880 --> 00:17:56,820
this is fine in this case the dome using

00:17:52,870 --> 00:17:59,410
SVG element can be really useful and

00:17:56,820 --> 00:18:03,250
especially consider that you can use the

00:17:59,410 --> 00:18:04,870
own pointer move up and down events you

00:18:03,250 --> 00:18:08,320
can get a polygon that you can display

00:18:04,870 --> 00:18:10,240
on screen quite easily using a react or

00:18:08,320 --> 00:18:12,610
your favorite from front-end framework

00:18:10,240 --> 00:18:14,680
and yeah using the Sun pointer move up

00:18:12,610 --> 00:18:17,800
and down events you can get something

00:18:14,680 --> 00:18:20,280
that can be dragged and drop on the

00:18:17,800 --> 00:18:23,530
screen so that I can go on on the vertex

00:18:20,280 --> 00:18:25,330
and then drag it so you have a visual

00:18:23,530 --> 00:18:28,030
read off what pretty good and it's done

00:18:25,330 --> 00:18:31,600
pretty easily sometimes things are not

00:18:28,030 --> 00:18:33,820
fast enough meaning that things are too

00:18:31,600 --> 00:18:36,220
slow to render on the screen in this

00:18:33,820 --> 00:18:39,220
case the best bet is in the case of

00:18:36,220 --> 00:18:41,710
react to use the react profiler so for

00:18:39,220 --> 00:18:44,200
example if you have something that is

00:18:41,710 --> 00:18:47,050
too slow to render take a look at the

00:18:44,200 --> 00:18:49,720
for finer it's displaying in all the

00:18:47,050 --> 00:18:52,180
components in your in your application

00:18:49,720 --> 00:18:54,550
and it's coloring and the component that

00:18:52,180 --> 00:18:57,190
that are being rendered after an

00:18:54,550 --> 00:19:00,100
interaction and so in my case you can

00:18:57,190 --> 00:19:04,030
see that the left part is filled with

00:19:00,100 --> 00:19:05,950
lots of colors and it's because I was

00:19:04,030 --> 00:19:08,110
some panel that was not even displayed

00:19:05,950 --> 00:19:11,320
on the screen has been rendered after

00:19:08,110 --> 00:19:14,410
each interaction stood I was getting a

00:19:11,320 --> 00:19:16,060
lot of well I was getting a performance

00:19:14,410 --> 00:19:18,100
hit for something that was not even on

00:19:16,060 --> 00:19:20,590
the screen so in this case the profiler

00:19:18,100 --> 00:19:22,660
is really useful at least to sanity

00:19:20,590 --> 00:19:25,690
check that you're not rendering more

00:19:22,660 --> 00:19:27,910
than needed something to remember

00:19:25,690 --> 00:19:29,950
measure performance of your application

00:19:27,910 --> 00:19:31,810
in production at least in the case of

00:19:29,950 --> 00:19:33,520
real item less familiar with other

00:19:31,810 --> 00:19:35,200
front-end frameworks in the case of

00:19:33,520 --> 00:19:37,690
react the development build is way

00:19:35,200 --> 00:19:39,400
slower because of the warnings so it can

00:19:37,690 --> 00:19:42,220
make a difference something that is

00:19:39,400 --> 00:19:44,020
taking like 1 seconds in development can

00:19:42,220 --> 00:19:47,950
be a few milliseconds or less in

00:19:44,020 --> 00:19:50,710
production and sometimes things are slow

00:19:47,950 --> 00:19:52,720
because you're not slow during the

00:19:50,710 --> 00:19:56,230
rendering but you're cutting too much of

00:19:52,720 --> 00:19:58,240
webassembly metals so be here of the

00:19:56,230 --> 00:20:01,470
overhead when you're calling webassembly

00:19:58,240 --> 00:20:03,480
the JavaScript has to convert you

00:20:01,470 --> 00:20:05,970
parameters to some kind of

00:20:03,480 --> 00:20:08,880
representation in your in your Austrian

00:20:05,970 --> 00:20:10,679
range meaning that if you're for example

00:20:08,880 --> 00:20:13,169
in this case if you're filtering and

00:20:10,679 --> 00:20:15,900
mapping on a list of Android or thousand

00:20:13,169 --> 00:20:18,000
of objects and for each of those objects

00:20:15,900 --> 00:20:19,890
that are Weber's of the objects you're

00:20:18,000 --> 00:20:22,409
calling a method like for example here

00:20:19,890 --> 00:20:25,860
get type or get variables that is giving

00:20:22,409 --> 00:20:28,950
you bad ass training all of these things

00:20:25,860 --> 00:20:31,500
have to to incur a cost of converting

00:20:28,950 --> 00:20:33,860
from webassembly string whether supplies

00:20:31,500 --> 00:20:37,950
to a string to a JavaScript string and

00:20:33,860 --> 00:20:40,440
that can take a bit of time in most

00:20:37,950 --> 00:20:42,480
cases in what it won't be noticeable but

00:20:40,440 --> 00:20:44,760
still might be a good idea to store

00:20:42,480 --> 00:20:46,710
things exhaust rings or the value on the

00:20:44,760 --> 00:20:48,960
dais side so don't you so that you don't

00:20:46,710 --> 00:20:51,270
have to cross the gap between JavaScript

00:20:48,960 --> 00:20:54,360
and the web assembly world every time

00:20:51,270 --> 00:20:56,220
you are rendering a component sometimes

00:20:54,360 --> 00:20:57,720
at some point your your code base is

00:20:56,220 --> 00:20:59,159
growing in my case as it's an open

00:20:57,720 --> 00:21:01,679
source software I'm getting contributors

00:20:59,159 --> 00:21:04,289
and here here are a few tips to keep

00:21:01,679 --> 00:21:06,360
your codebase saying the first thing is

00:21:04,289 --> 00:21:09,510
to just have components for everything

00:21:06,360 --> 00:21:11,490
if you have an alpha button if you want

00:21:09,510 --> 00:21:14,100
to have this alpha button that is a bit

00:21:11,490 --> 00:21:18,210
smaller on the screen don't just add the

00:21:14,100 --> 00:21:20,010
font size 12 and and be done just create

00:21:18,210 --> 00:21:22,320
a new component for it what I'm is

00:21:20,010 --> 00:21:26,340
saying basically is our design system

00:21:22,320 --> 00:21:29,159
and stick to it I'm not Yudin testing my

00:21:26,340 --> 00:21:31,650
visual components sorry when actually I

00:21:29,159 --> 00:21:35,010
do better and if there are some pathways

00:21:31,650 --> 00:21:37,620
there is logic what I do is to create

00:21:35,010 --> 00:21:40,080
visual stories so using a storybook or

00:21:37,620 --> 00:21:42,299
reacts a guy dissed you can create

00:21:40,080 --> 00:21:44,370
stories that are your components

00:21:42,299 --> 00:21:47,820
walking outside of your application so

00:21:44,370 --> 00:21:49,650
that you can work on them and test them

00:21:47,820 --> 00:21:51,809
without ruining the whole depiction it's

00:21:49,650 --> 00:21:53,250
very useful when for example you want to

00:21:51,809 --> 00:21:55,470
test that you're confident is displaying

00:21:53,250 --> 00:21:56,909
some kind of Eros that you'll not sing

00:21:55,470 --> 00:21:59,850
in a real because your software is

00:21:56,909 --> 00:22:01,860
working properly that's a huge huge

00:21:59,850 --> 00:22:03,120
advantage of a native development

00:22:01,860 --> 00:22:04,200
because you don't have to relaunch your

00:22:03,120 --> 00:22:08,490
wall application every time you're

00:22:04,200 --> 00:22:10,650
making some small changes and finally

00:22:08,490 --> 00:22:12,870
make sure to use types

00:22:10,650 --> 00:22:16,800
is a flow of Thai script I don't care

00:22:12,870 --> 00:22:19,770
just types will tell you that you forget

00:22:16,800 --> 00:22:21,780
you forget to pass a proper to remove a

00:22:19,770 --> 00:22:23,940
probe it helps for to completion it

00:22:21,780 --> 00:22:27,030
avoid most silly mistake or not so silly

00:22:23,940 --> 00:22:29,400
sometimes it documents the objects so I

00:22:27,030 --> 00:22:31,770
think that types are early shining when

00:22:29,400 --> 00:22:33,720
you or someone else is refactoring some

00:22:31,770 --> 00:22:35,730
part of the app and remember that after

00:22:33,720 --> 00:22:39,510
few months you will be a stranger to

00:22:35,730 --> 00:22:41,880
your own code base this being said I

00:22:39,510 --> 00:22:43,590
think that we have now the core of the

00:22:41,880 --> 00:22:45,900
software that is transpired to

00:22:43,590 --> 00:22:46,830
webassembly we have a new interface done

00:22:45,900 --> 00:22:50,400
using a react.js

00:22:46,830 --> 00:22:50,940
just a few words about packaging the

00:22:50,400 --> 00:22:52,290
whole thing

00:22:50,940 --> 00:22:54,480
you can either package this as a

00:22:52,290 --> 00:22:56,580
progressive web app using electron or

00:22:54,480 --> 00:22:59,010
even embed dual Phineas in the native

00:22:56,580 --> 00:23:02,070
application whatever you choose my

00:22:59,010 --> 00:23:03,960
advice is to build over to existing API

00:23:02,070 --> 00:23:06,390
so for example in electron you have API

00:23:03,960 --> 00:23:08,100
is to make context menus better use them

00:23:06,390 --> 00:23:10,130
to get a native feeling if you're

00:23:08,100 --> 00:23:14,429
distributing your application as a

00:23:10,130 --> 00:23:17,280
downloadable application so yeah that's

00:23:14,429 --> 00:23:20,070
that seems to work let's let's see the

00:23:17,280 --> 00:23:22,860
result so this is the new application

00:23:20,070 --> 00:23:25,290
running in electron but that can run in

00:23:22,860 --> 00:23:28,290
a web browser too and I'm doing the same

00:23:25,290 --> 00:23:32,130
thing as before meaning that I'm

00:23:28,290 --> 00:23:35,850
creating a button object and I would put

00:23:32,130 --> 00:23:38,130
it on the screen and as before adding a

00:23:35,850 --> 00:23:39,809
few visual events so that when I'm

00:23:38,130 --> 00:23:42,030
stepping on the button then the platform

00:23:39,809 --> 00:23:43,650
is going up in the air so yeah I'm

00:23:42,030 --> 00:23:45,000
putting the button on the screen and

00:23:43,650 --> 00:23:46,950
same thing as before

00:23:45,000 --> 00:23:48,809
I'm adding a new event with a condition

00:23:46,950 --> 00:23:51,480
so that if there is a collision between

00:23:48,809 --> 00:23:53,820
the player and the the button then the

00:23:51,480 --> 00:23:56,520
platform will move so you can see that

00:23:53,820 --> 00:23:59,070
it's more less the same thing it's a bit

00:23:56,520 --> 00:24:00,870
hard actually so the interface has been

00:23:59,070 --> 00:24:02,640
changing a bit again but you can see

00:24:00,870 --> 00:24:07,350
that it's a bit the same thing

00:24:02,640 --> 00:24:10,140
internally and yeah I can press play the

00:24:07,350 --> 00:24:13,550
wall oh no sorry I forgot the second

00:24:10,140 --> 00:24:15,990
action to change the state of the button

00:24:13,550 --> 00:24:19,020
so yeah when I'm done I can press play

00:24:15,990 --> 00:24:21,030
and the web assembly module will be

00:24:19,020 --> 00:24:23,960
compiling the world thing to to

00:24:21,030 --> 00:24:27,120
JavaScript and you have a game running

00:24:23,960 --> 00:24:29,880
and yeah that's that's well or

00:24:27,120 --> 00:24:31,740
at least for for my definition of a

00:24:29,880 --> 00:24:34,320
developer misfortune well what are the

00:24:31,740 --> 00:24:36,360
users seen where I be honest the first

00:24:34,320 --> 00:24:40,560
feedback about the patient were already

00:24:36,360 --> 00:24:42,270
bad why because people were used it was

00:24:40,560 --> 00:24:44,220
not because it was you done using Ektron

00:24:42,270 --> 00:24:46,650
or reactor it was some kind of web

00:24:44,220 --> 00:24:48,270
application it's just because even if

00:24:46,650 --> 00:24:50,550
the curve the software was the same as

00:24:48,270 --> 00:24:52,710
the previous version the wall interface

00:24:50,550 --> 00:24:54,210
was new and so I was missing features

00:24:52,710 --> 00:24:57,600
and so people were complaining about

00:24:54,210 --> 00:25:01,020
this lack of features and after a few

00:24:57,600 --> 00:25:03,480
months of work adding new features back

00:25:01,020 --> 00:25:05,910
like like the previous version people

00:25:03,480 --> 00:25:07,470
started to say ok that's that that is

00:25:05,910 --> 00:25:09,800
better that is better than the old

00:25:07,470 --> 00:25:11,970
version I can even be more productive on

00:25:09,800 --> 00:25:14,610
many aspect compared to the old version

00:25:11,970 --> 00:25:16,710
and now people are almost entirely using

00:25:14,610 --> 00:25:20,010
this new version compared to the old one

00:25:16,710 --> 00:25:24,240
so it works it works so well that the

00:25:20,010 --> 00:25:26,130
native app is better sorry the native

00:25:24,240 --> 00:25:28,980
web application is better than the

00:25:26,130 --> 00:25:31,200
entirely native application why better

00:25:28,980 --> 00:25:34,080
because I can iterate on it really fast

00:25:31,200 --> 00:25:35,730
ly because rather than waiting for one

00:25:34,080 --> 00:25:36,900
minute for the C++ code to compile

00:25:35,730 --> 00:25:39,960
whenever I'm making a change to the

00:25:36,900 --> 00:25:41,400
interface I have to wait only 10 seconds

00:25:39,960 --> 00:25:43,410
for a pack to complete the world things

00:25:41,400 --> 00:25:44,940
and 10 seconds is too it's too much no

00:25:43,410 --> 00:25:47,250
it's not that much compared to before

00:25:44,940 --> 00:25:48,770
and I can test it really fast using

00:25:47,250 --> 00:25:53,550
storybook I have a near-perfect

00:25:48,770 --> 00:25:55,950
cross-platform almost no issue no crush

00:25:53,550 --> 00:25:58,320
I can develop on Mac OS and this related

00:25:55,950 --> 00:26:00,030
to Windows and we went without even

00:25:58,320 --> 00:26:02,430
testing I'm still doing some tests I

00:26:00,030 --> 00:26:05,130
have as fast a lot of time auto-updates

00:26:02,430 --> 00:26:06,540
most contributors I can try it online I

00:26:05,130 --> 00:26:08,580
think that's something that was not even

00:26:06,540 --> 00:26:10,650
possible before you can go online and

00:26:08,580 --> 00:26:14,670
try the software we won't even download

00:26:10,650 --> 00:26:17,340
it I can put it to a phone and yeah it's

00:26:14,670 --> 00:26:19,440
actually working on a phone it's not

00:26:17,340 --> 00:26:21,570
made for but I'm adapting to interface

00:26:19,440 --> 00:26:26,280
so that we can you can run fairly well

00:26:21,570 --> 00:26:29,730
on a recent phone so I think that's it I

00:26:26,280 --> 00:26:31,890
wanted to show with this talk that we

00:26:29,730 --> 00:26:35,210
work with web technologies we can be

00:26:31,890 --> 00:26:37,910
ambitious and make things that are

00:26:35,210 --> 00:26:40,820
as good if not better than what we used

00:26:37,910 --> 00:26:46,760
to do in the native world thank you

00:26:40,820 --> 00:26:50,089
[Applause]

00:26:46,760 --> 00:26:50,089

YouTube URL: https://www.youtube.com/watch?v=sMfNWIbWUb0


