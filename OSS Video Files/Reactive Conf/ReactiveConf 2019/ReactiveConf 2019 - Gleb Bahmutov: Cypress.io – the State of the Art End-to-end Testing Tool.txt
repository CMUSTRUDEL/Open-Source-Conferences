Title: ReactiveConf 2019 - Gleb Bahmutov: Cypress.io – the State of the Art End-to-end Testing Tool
Publication date: 2019-10-30
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Millennium stage
-------------------------------------------------------------------
This talk shows how quick and simple it can be to write end-to-end tests for web applications – if your testing tools are not fighting you all the time. I will go over writing E2E tests using Cypress.io, controlling the network during tests, using visual testing and setting up continuous integration to perform E2E tests on each commit.
Captions: 
	00:00:02,750 --> 00:00:11,900
[Music]

00:00:16,279 --> 00:00:22,050
hi everyone it's a pleasure to be here

00:00:19,650 --> 00:00:24,869
I'm glia Bach muta from Cyprus I live in

00:00:22,050 --> 00:00:27,449
Boston I work at Cypress remotely and I

00:00:24,869 --> 00:00:30,060
will talk about the state of art in end

00:00:27,449 --> 00:00:31,590
to end testing but before I do that I

00:00:30,060 --> 00:00:32,510
have to talk about very very something

00:00:31,590 --> 00:00:35,760
important

00:00:32,510 --> 00:00:38,070
our planet is an immediate imminent

00:00:35,760 --> 00:00:41,340
danger like the heat waves during the

00:00:38,070 --> 00:00:44,160
summer Arctic without sea ice burn in

00:00:41,340 --> 00:00:46,500
California right now India Bangladesh

00:00:44,160 --> 00:00:49,260
running out of water the system is

00:00:46,500 --> 00:00:50,730
broken and imagine the heat wave at you

00:00:49,260 --> 00:00:52,739
experienced during the summer lasting

00:00:50,730 --> 00:00:55,920
for one month it kills all the crops

00:00:52,739 --> 00:00:59,160
what's your plan what's your plan for

00:00:55,920 --> 00:01:01,620
melting Arctic and the sea rising 50

00:00:59,160 --> 00:01:04,530
meters and I'll tell you but it's no

00:01:01,620 --> 00:01:08,220
 plan so I'm trying to act and

00:01:04,530 --> 00:01:12,930
change my behavior today so I only have

00:01:08,220 --> 00:01:15,030
one son I cutting down on flying I only

00:01:12,930 --> 00:01:18,270
use public transportation try to eat eat

00:01:15,030 --> 00:01:19,799
less meat solar farm so on and I'm

00:01:18,270 --> 00:01:21,689
trying to tell everyone to do the same

00:01:19,799 --> 00:01:24,570
because we can all influence ourselves

00:01:21,689 --> 00:01:28,080
and our immediate family and co-workers

00:01:24,570 --> 00:01:30,450
and finally you have to affect the way

00:01:28,080 --> 00:01:32,960
but government acts in the United States

00:01:30,450 --> 00:01:36,270
and trying to lobby for carbon pricing

00:01:32,960 --> 00:01:38,369
because I think we have technology to

00:01:36,270 --> 00:01:40,229
change our lives today and the only

00:01:38,369 --> 00:01:42,630
thing stopping from changing and

00:01:40,229 --> 00:01:44,670
averting the global climate catastrophe

00:01:42,630 --> 00:01:46,409
is the fossil fuels but trying to

00:01:44,670 --> 00:01:49,530
squeeze one more dollar before we all

00:01:46,409 --> 00:01:51,840
die here's my pledge here's my email

00:01:49,530 --> 00:01:54,299
Twitter if you working on profit or

00:01:51,840 --> 00:01:56,549
nonprofit organization but tries to

00:01:54,299 --> 00:01:59,189
change our climate and solve it I will

00:01:56,549 --> 00:02:04,290
help you for free I volunteer to help

00:01:59,189 --> 00:02:06,659
you with testing it's always hard to

00:02:04,290 --> 00:02:11,039
kind of switch back from that team but

00:02:06,659 --> 00:02:13,520
it's serious okay testing is a drag it

00:02:11,039 --> 00:02:17,320
slows you down of the

00:02:13,520 --> 00:02:19,850
[Applause]

00:02:17,320 --> 00:02:22,070
testing is a drug it slows you down

00:02:19,850 --> 00:02:23,570
while you're writing tests you cannot

00:02:22,070 --> 00:02:25,550
actually do features but you get paid

00:02:23,570 --> 00:02:28,220
for and testing doesn't pay

00:02:25,550 --> 00:02:29,690
it's like scaffolding you have to build

00:02:28,220 --> 00:02:31,880
it in order for you to finish the

00:02:29,690 --> 00:02:33,380
building but then you have to remove it

00:02:31,880 --> 00:02:35,180
because you're not selling the

00:02:33,380 --> 00:02:36,890
scaffolding and finally testing is

00:02:35,180 --> 00:02:38,690
boring and I'm surprised so many people

00:02:36,890 --> 00:02:40,150
actually picked me because I would

00:02:38,690 --> 00:02:44,270
expect everyone to be at a different

00:02:40,150 --> 00:02:46,760
stage in this presentation I will tell

00:02:44,270 --> 00:02:49,790
you how I personally avoid writing tests

00:02:46,760 --> 00:02:52,940
and how I pick which tests to write and

00:02:49,790 --> 00:02:55,100
how to make it fun so I have a lot of

00:02:52,940 --> 00:02:59,150
open source projects a lot of blog posts

00:02:55,100 --> 00:03:01,400
I do run engineering at Cypress so if

00:02:59,150 --> 00:03:03,140
you go and github give it the star every

00:03:01,400 --> 00:03:06,370
day I'm working on test runner coding

00:03:03,140 --> 00:03:09,560
every day these slides are available on

00:03:06,370 --> 00:03:12,170
slides that come and finally if you want

00:03:09,560 --> 00:03:15,530
to argue with me or praise me I'm on

00:03:12,170 --> 00:03:17,450
Twitter as well so why are we writing

00:03:15,530 --> 00:03:19,790
tests well personally I know that I

00:03:17,450 --> 00:03:21,620
write shitty code every time I write

00:03:19,790 --> 00:03:24,590
something it's not going to work

00:03:21,620 --> 00:03:26,390
I know that in any language for any

00:03:24,590 --> 00:03:28,700
platform I notice I'm gonna work on a

00:03:26,390 --> 00:03:30,590
second try or third try so the only

00:03:28,700 --> 00:03:33,320
reason I write tests is because I know

00:03:30,590 --> 00:03:35,390
myself so the simplest way for me to

00:03:33,320 --> 00:03:38,420
actually prove myself correct is not

00:03:35,390 --> 00:03:40,430
write tests but do a lint Chuck so in

00:03:38,420 --> 00:03:42,620
this case I'm adding two BS code CS

00:03:40,430 --> 00:03:47,300
check and immediately shows me hey you

00:03:42,620 --> 00:03:47,900
must stop here's an error we're a couple

00:03:47,300 --> 00:03:50,930
flinters

00:03:47,900 --> 00:03:53,600
so I usually talk about linting pyramid

00:03:50,930 --> 00:03:55,459
at the bottom we have prettier prettier

00:03:53,600 --> 00:03:57,860
reformats your JavaScript code so it

00:03:55,459 --> 00:04:01,580
looks uniform easy to read it's not an

00:03:57,860 --> 00:04:04,100
actual enter but it makes the test of

00:04:01,580 --> 00:04:06,260
your production code easier to read and

00:04:04,100 --> 00:04:09,320
easier to understand and for bugs not to

00:04:06,260 --> 00:04:11,269
hide there then you have es lint this is

00:04:09,320 --> 00:04:13,550
an actual intern it understands the

00:04:11,269 --> 00:04:15,350
structure of your code and it can tell

00:04:13,550 --> 00:04:17,269
you you're using a variable that you

00:04:15,350 --> 00:04:21,020
have not declared it's probably a

00:04:17,269 --> 00:04:23,060
mistake and even above it is things like

00:04:21,020 --> 00:04:25,139
TS check but actually use type

00:04:23,060 --> 00:04:28,530
information to test much

00:04:25,139 --> 00:04:30,689
and tell me if something's wrong and you

00:04:28,530 --> 00:04:34,469
can get all the benefits of type script

00:04:30,689 --> 00:04:36,449
checks without writing type script so

00:04:34,469 --> 00:04:38,759
here's how you do it you start with your

00:04:36,449 --> 00:04:41,250
regular JavaScript code let's say a

00:04:38,759 --> 00:04:44,069
function add and you write a comment I

00:04:41,250 --> 00:04:46,319
know a comment kind of weird right

00:04:44,069 --> 00:04:47,849
but in that comment you can say first

00:04:46,319 --> 00:04:49,740
parameter is a number and second

00:04:47,849 --> 00:04:51,900
parameter is a number and immediately

00:04:49,740 --> 00:04:53,580
you get benefits because if you hover

00:04:51,900 --> 00:04:54,000
over the belt function every time you

00:04:53,580 --> 00:04:56,909
use it

00:04:54,000 --> 00:04:59,270
where is intellisense pop-up but tells

00:04:56,909 --> 00:05:02,819
you hey this is what was function does

00:04:59,270 --> 00:05:05,610
but also can underline and tell you hey

00:05:02,819 --> 00:05:07,680
you are trying to pass a string and this

00:05:05,610 --> 00:05:10,289
function expects a number so you're

00:05:07,680 --> 00:05:13,080
doing something wrong you can actually

00:05:10,289 --> 00:05:14,729
set it up as a pre compile step where it

00:05:13,080 --> 00:05:17,219
will type check all your JavaScript code

00:05:14,729 --> 00:05:21,539
and tell you all the places but you call

00:05:17,219 --> 00:05:24,060
in function incorrectly but this brings

00:05:21,539 --> 00:05:26,039
me to my biggest pet peeve with every

00:05:24,060 --> 00:05:28,110
project I've been on nobody writes

00:05:26,039 --> 00:05:33,270
comments even when comments are very

00:05:28,110 --> 00:05:36,180
useful so when we were working on our

00:05:33,270 --> 00:05:39,389
comments for Cyprus we made a decision

00:05:36,180 --> 00:05:42,360
but every method but the API exposes

00:05:39,389 --> 00:05:44,550
should be well documented so any time is

00:05:42,360 --> 00:05:46,919
try to write tests you can hover over

00:05:44,550 --> 00:05:49,740
let's say type and it tells you here's

00:05:46,919 --> 00:05:51,449
what type does here's an example here's

00:05:49,740 --> 00:05:53,370
a link to actually find more

00:05:51,449 --> 00:05:55,979
documentation where we spent a lot of

00:05:53,370 --> 00:05:57,839
time writing ducks for every command

00:05:55,979 --> 00:06:03,180
because we know it's very very important

00:05:57,839 --> 00:06:05,009
I was thinking why is it important and I

00:06:03,180 --> 00:06:07,080
realized that I actually make more

00:06:05,009 --> 00:06:09,900
mistakes not even writing my own code

00:06:07,080 --> 00:06:12,210
but more mistakes using someone else's

00:06:09,900 --> 00:06:15,990
code or more mistakes even using my own

00:06:12,210 --> 00:06:18,180
code so here's the situation I write

00:06:15,990 --> 00:06:20,969
something an adult that I don't document

00:06:18,180 --> 00:06:22,889
it enough I have confusing API maybe I

00:06:20,969 --> 00:06:26,250
have options that don't make sense but

00:06:22,889 --> 00:06:28,919
are not named correctly so 10 developers

00:06:26,250 --> 00:06:29,580
try to use that library they all make

00:06:28,919 --> 00:06:32,699
mistakes

00:06:29,580 --> 00:06:35,370
they all have to submit an issue look at

00:06:32,699 --> 00:06:39,030
the code and so what happens achieved I

00:06:35,370 --> 00:06:41,550
became a 10x developer which is my goal

00:06:39,030 --> 00:06:44,040
but it's negative ten I just slowed down

00:06:41,550 --> 00:06:48,270
ten developers by writing bad code

00:06:44,040 --> 00:06:50,730
without examples no one should be an

00:06:48,270 --> 00:06:53,610
Einstein to actually use your library

00:06:50,730 --> 00:06:56,100
no one should look at the code and know

00:06:53,610 --> 00:06:56,910
the whole system just to fix a small

00:06:56,100 --> 00:06:59,670
issue

00:06:56,910 --> 00:07:02,730
please make nice abstractions document

00:06:59,670 --> 00:07:05,550
them to make itself more productive so

00:07:02,730 --> 00:07:09,980
use static types linting and please use

00:07:05,550 --> 00:07:09,980
more examples I love looking at examples

00:07:10,070 --> 00:07:13,890
when people talk about testing they

00:07:12,330 --> 00:07:15,660
usually talk about testing pyramid and

00:07:13,890 --> 00:07:17,460
they argue till they're blue in the face

00:07:15,660 --> 00:07:18,780
about types of tests to ride

00:07:17,460 --> 00:07:20,190
should I write more in test because

00:07:18,780 --> 00:07:21,270
they're faster or should I write more

00:07:20,190 --> 00:07:23,190
end-to-end tests because they're more

00:07:21,270 --> 00:07:23,400
productive and I say forget about all

00:07:23,190 --> 00:07:26,780
that

00:07:23,400 --> 00:07:29,669
like stop arguing about testing pyramid

00:07:26,780 --> 00:07:33,150
if you write in code you should test it

00:07:29,669 --> 00:07:34,650
if you writing API you should test it if

00:07:33,150 --> 00:07:36,360
you're writing a web application you

00:07:34,650 --> 00:07:39,210
should test it it doesn't matter how you

00:07:36,360 --> 00:07:42,510
call the test it has to be a test where

00:07:39,210 --> 00:07:45,990
it's only a test and only the thing that

00:07:42,510 --> 00:07:47,669
you doubt works if your thing is a

00:07:45,990 --> 00:07:52,050
function and you're not sure if it works

00:07:47,669 --> 00:07:53,850
or not you write a test if you think is

00:07:52,050 --> 00:07:57,200
a component in this case a react

00:07:53,850 --> 00:07:59,430
component you write a test in this case

00:07:57,200 --> 00:08:01,560
Cypress can mount this component and

00:07:59,430 --> 00:08:03,360
interact that component and you can run

00:08:01,560 --> 00:08:05,310
it and it looks kind of like this where

00:08:03,360 --> 00:08:09,419
you can see how your component reacts to

00:08:05,310 --> 00:08:11,970
events but you're sending if you think

00:08:09,419 --> 00:08:14,220
is an API volver is plug-in but every

00:08:11,970 --> 00:08:16,740
written where you can call your API with

00:08:14,220 --> 00:08:19,830
given arguments inspect back results

00:08:16,740 --> 00:08:22,440
maybe even show log messages from the

00:08:19,830 --> 00:08:25,919
server side I don't care how you call

00:08:22,440 --> 00:08:28,110
the test I call as a test if you think

00:08:25,919 --> 00:08:30,630
is a complete web application when you

00:08:28,110 --> 00:08:33,510
write a Cypress test where you visit the

00:08:30,630 --> 00:08:39,030
site and you exercise website you drive

00:08:33,510 --> 00:08:41,010
it just like a real user so if you think

00:08:39,030 --> 00:08:44,070
is not a web application itself

00:08:41,010 --> 00:08:47,100
but the style via CSS the visual

00:08:44,070 --> 00:08:49,830
appearance of your web app you write a

00:08:47,100 --> 00:08:52,250
test you just add plugins from other

00:08:49,830 --> 00:08:54,290
libraries that do visual diffing

00:08:52,250 --> 00:08:55,819
so in this case if someone submits a

00:08:54,290 --> 00:08:58,850
pull request and the pull request

00:08:55,819 --> 00:08:59,600
changes with SVG fuels style color to

00:08:58,850 --> 00:09:02,689
something else

00:08:59,600 --> 00:09:06,220
well that test can tell you pizza what

00:09:02,689 --> 00:09:09,560
used to be yellow now got a green crust

00:09:06,220 --> 00:09:13,910
is that what you wanted and you probably

00:09:09,560 --> 00:09:16,310
will say no tomorrow guilt AR will show

00:09:13,910 --> 00:09:18,560
how he does visual dipping and visual

00:09:16,310 --> 00:09:21,850
testing so make sure not to miss his

00:09:18,560 --> 00:09:24,649
presentation he's an excellent presenter

00:09:21,850 --> 00:09:26,750
if your thing is not a web application

00:09:24,649 --> 00:09:29,240
and not its style but its accessibility

00:09:26,750 --> 00:09:32,300
you write a test in the test you can

00:09:29,240 --> 00:09:34,459
inject very popular X accessibility

00:09:32,300 --> 00:09:36,230
testing library and just check

00:09:34,459 --> 00:09:39,050
everything for example in this case a

00:09:36,230 --> 00:09:41,389
color contrast and it will tell you hey

00:09:39,050 --> 00:09:43,639
you cannot read it right because the

00:09:41,389 --> 00:09:45,949
color country is so low so the test will

00:09:43,639 --> 00:09:49,129
tell you your website doesn't pass

00:09:45,949 --> 00:09:51,769
accessibility tests you can always write

00:09:49,129 --> 00:09:54,290
a test it just a question is picking a

00:09:51,769 --> 00:09:56,959
write plug-in but test the thing that

00:09:54,290 --> 00:09:58,850
you're trying to prove works with

00:09:56,959 --> 00:10:00,769
Cypress we created a platform where

00:09:58,850 --> 00:10:02,680
people can write in JavaScript plugins

00:10:00,769 --> 00:10:07,399
but do all sorts of different things

00:10:02,680 --> 00:10:08,720
more than we actually imagined there are

00:10:07,399 --> 00:10:12,740
two things that people ask me about

00:10:08,720 --> 00:10:15,470
testing what should I test and how long

00:10:12,740 --> 00:10:17,600
should my tests be so what should I test

00:10:15,470 --> 00:10:19,759
but a couple of ways you can say you

00:10:17,600 --> 00:10:22,610
have to write new tests or what tests

00:10:19,759 --> 00:10:24,709
are duplicate you can do it manually

00:10:22,610 --> 00:10:28,779
carefully collect user stories and for

00:10:24,709 --> 00:10:28,779
each user story write an end-to-end test

00:10:29,620 --> 00:10:34,519
but the thing but makes it difficult is

00:10:32,990 --> 00:10:36,439
that you have to maintain this

00:10:34,519 --> 00:10:39,079
one-to-one relationship as you add

00:10:36,439 --> 00:10:42,589
features or modify features or even

00:10:39,079 --> 00:10:45,259
deprecated features for example this to

00:10:42,589 --> 00:10:48,709
do MVC you can say well what does it do

00:10:45,259 --> 00:10:52,899
well feature a user can add to-do items

00:10:48,709 --> 00:10:55,910
ok users can complete to-do items and

00:10:52,899 --> 00:10:58,759
users can delete to-do items X on so we

00:10:55,910 --> 00:11:01,189
have three features and we'll keep track

00:10:58,759 --> 00:11:03,620
of them manually so we can write a test

00:11:01,189 --> 00:11:05,730
and we'll take the feature name as the

00:11:03,620 --> 00:11:08,579
test name so it adds two doses

00:11:05,730 --> 00:11:11,160
test it completes the dose is a task and

00:11:08,579 --> 00:11:14,670
then we can think oh wait none of my

00:11:11,160 --> 00:11:17,040
test is named delete to do this so we

00:11:14,670 --> 00:11:19,680
write one more test and it's very simple

00:11:17,040 --> 00:11:22,260
example but I think in general it's a

00:11:19,680 --> 00:11:25,110
very hard system to maintain because

00:11:22,260 --> 00:11:27,420
it's easy to match one test to one

00:11:25,110 --> 00:11:29,730
feature but once you start writing a

00:11:27,420 --> 00:11:31,740
couple of more features more tests it

00:11:29,730 --> 00:11:32,610
becomes harder and after a while you

00:11:31,740 --> 00:11:35,480
just get swamped

00:11:32,610 --> 00:11:37,470
you can not maintain this thing many I

00:11:35,480 --> 00:11:41,690
don't know what happened there like this

00:11:37,470 --> 00:11:44,910
is weird okay so we need an alternative

00:11:41,690 --> 00:11:47,010
alternative is to automate this feature

00:11:44,910 --> 00:11:48,540
mappings to test we can collect code

00:11:47,010 --> 00:11:50,579
coverage we can instrument our

00:11:48,540 --> 00:11:54,449
application code so we know which lines

00:11:50,579 --> 00:11:56,370
of code we executed during the tests so

00:11:54,449 --> 00:11:59,579
imagine you in starting it to implement

00:11:56,370 --> 00:12:00,990
this app and you say feature a users

00:11:59,579 --> 00:12:03,120
will be able to add items so you write

00:12:00,990 --> 00:12:04,680
some code and then you implement the

00:12:03,120 --> 00:12:07,709
second feature and you write some more

00:12:04,680 --> 00:12:09,630
code you maybe changed all code and then

00:12:07,709 --> 00:12:12,750
you influen the last feature which also

00:12:09,630 --> 00:12:14,279
adds code and then you run end to end

00:12:12,750 --> 00:12:16,620
test and because your code is already

00:12:14,279 --> 00:12:17,130
instrumented you can tell which lines of

00:12:16,620 --> 00:12:19,949
code

00:12:17,130 --> 00:12:24,060
those tests touched in this case martin

00:12:19,949 --> 00:12:26,010
green and varus is red and yellow the

00:12:24,060 --> 00:12:27,990
red lines are features that i have not

00:12:26,010 --> 00:12:30,120
tested and you played Sherlock Holmes

00:12:27,990 --> 00:12:32,459
and if you go out what test to write and

00:12:30,120 --> 00:12:34,440
you write one more test and now you

00:12:32,459 --> 00:12:38,550
covering all the lines so that's how

00:12:34,440 --> 00:12:40,769
code coverage works and it's not direct

00:12:38,550 --> 00:12:42,360
measurement right because it's indirect

00:12:40,769 --> 00:12:44,490
measurement you know what both features

00:12:42,360 --> 00:12:46,980
are implemented in code and you know

00:12:44,490 --> 00:12:51,720
this code gets executed when you run

00:12:46,980 --> 00:12:54,540
both tests and people strive to get 100%

00:12:51,720 --> 00:12:57,389
code coverage but it doesn't mean but

00:12:54,540 --> 00:13:00,240
once you get to 100% code coverage but

00:12:57,389 --> 00:13:02,790
you'll have zero box but one problem is

00:13:00,240 --> 00:13:06,180
that your code might not not actually

00:13:02,790 --> 00:13:08,430
implement with features correctly you

00:13:06,180 --> 00:13:11,130
can still cover the code but that code

00:13:08,430 --> 00:13:12,899
is doing the wrong things and the second

00:13:11,130 --> 00:13:15,930
problem is that your end-to-end test

00:13:12,899 --> 00:13:17,160
cases might be unrealistic yes we are

00:13:15,930 --> 00:13:19,860
covering

00:13:17,160 --> 00:13:22,680
the code but for example they use very

00:13:19,860 --> 00:13:25,050
simple email so if a user uses a

00:13:22,680 --> 00:13:27,030
realistic email your code might not

00:13:25,050 --> 00:13:30,180
actually work so hundred percent code

00:13:27,030 --> 00:13:32,820
coverage doesn't guarantee zero box so

00:13:30,180 --> 00:13:35,040
for Cyprus we have written a code

00:13:32,820 --> 00:13:37,020
coverage plugin where you instrument the

00:13:35,040 --> 00:13:38,790
code which is very easy to do and then

00:13:37,020 --> 00:13:41,390
that plug-in does the rest

00:13:38,790 --> 00:13:44,820
here's how it works you write your test

00:13:41,390 --> 00:13:48,480
it's a simple and to end test were a

00:13:44,820 --> 00:13:51,660
user visits the site finds the input box

00:13:48,480 --> 00:13:54,150
types free to deuce and then checks but

00:13:51,660 --> 00:13:56,010
were free to deuce in a list and we

00:13:54,150 --> 00:13:59,340
found that end-to-end tests like this

00:13:56,010 --> 00:14:01,560
one are extremely efficient at covering

00:13:59,340 --> 00:14:04,230
a lot of application source code in a

00:14:01,560 --> 00:14:06,660
single test this one test if you look at

00:14:04,230 --> 00:14:10,020
the report covers seventy two and a half

00:14:06,660 --> 00:14:11,730
percent of all application code just a

00:14:10,020 --> 00:14:14,490
single test because the whole

00:14:11,730 --> 00:14:19,770
application has to load initialize stop

00:14:14,490 --> 00:14:22,230
processing events and then the code

00:14:19,770 --> 00:14:24,870
coverage and a higher percent is not the

00:14:22,230 --> 00:14:27,600
goal of itself instead you should use

00:14:24,870 --> 00:14:31,590
VAT code coverage report as a guide or

00:14:27,600 --> 00:14:33,600
as a map to which tests to write so in

00:14:31,590 --> 00:14:35,520
this case if you look at this test and

00:14:33,600 --> 00:14:38,460
you look at the report and you look

00:14:35,520 --> 00:14:40,410
inside each source file inside that

00:14:38,460 --> 00:14:42,960
report you will see which clients were

00:14:40,410 --> 00:14:45,840
executed in this case I'm looking at the

00:14:42,960 --> 00:14:48,210
redux tour for the vet application and I

00:14:45,840 --> 00:14:50,940
can clearly see that the case had to do

00:14:48,210 --> 00:14:54,660
was covered because my tests really

00:14:50,940 --> 00:14:57,420
added free to do and in yellow you see

00:14:54,660 --> 00:15:00,000
the switch statements that were not

00:14:57,420 --> 00:15:02,220
executed and in red you see the source

00:15:00,000 --> 00:15:04,470
lines but were not executed by the SAS

00:15:02,220 --> 00:15:07,020
so you can see we need to write tests

00:15:04,470 --> 00:15:09,690
but delete to do edit to do complete to

00:15:07,020 --> 00:15:11,940
do and so on it becomes almost like a

00:15:09,690 --> 00:15:13,740
game with just civil lines but you have

00:15:11,940 --> 00:15:18,210
not tested and you write an end-to-end

00:15:13,740 --> 00:15:22,470
test to hit both lines so I've written

00:15:18,210 --> 00:15:24,900
motifs and I get ninety nine point two

00:15:22,470 --> 00:15:27,530
six percent code coverage just from end

00:15:24,900 --> 00:15:27,530
to end tests

00:15:28,980 --> 00:15:36,340
except where's one tiny problem I can

00:15:32,410 --> 00:15:38,380
see but one file missed something so if

00:15:36,340 --> 00:15:42,960
I look inside that file I can see a

00:15:38,380 --> 00:15:46,480
default case statement this little file

00:15:42,960 --> 00:15:48,790
implements the view filter do I want to

00:15:46,480 --> 00:15:51,100
see all to those active to those or

00:15:48,790 --> 00:15:53,440
completely to those and everything is

00:15:51,100 --> 00:15:56,520
fine but Antoine test is correct is just

00:15:53,440 --> 00:16:01,300
this default statement is not reachable

00:15:56,520 --> 00:16:02,860
from end to end interface from a user

00:16:01,300 --> 00:16:05,980
interface because my application is

00:16:02,860 --> 00:16:08,020
actually wired correctly so in that case

00:16:05,980 --> 00:16:10,240
I don't have to write end-to-end test I

00:16:08,020 --> 00:16:12,940
have to write a unit test but just

00:16:10,240 --> 00:16:13,360
excuse this piece of code and hits but

00:16:12,940 --> 00:16:16,840
lang

00:16:13,360 --> 00:16:18,670
so I write unit tests by importing wet

00:16:16,840 --> 00:16:22,120
class directly and calling it with

00:16:18,670 --> 00:16:24,160
invalid filter and cypress can run unit

00:16:22,120 --> 00:16:26,200
tests just as well in this case there is

00:16:24,160 --> 00:16:27,970
no website but it does execute your code

00:16:26,200 --> 00:16:32,410
and various code coverage information

00:16:27,970 --> 00:16:34,600
and when I look at the report I can see

00:16:32,410 --> 00:16:37,620
what I in this particular unit test I

00:16:34,600 --> 00:16:41,950
hit just wet line it was very targeted

00:16:37,620 --> 00:16:44,140
specific test and the cool thing is that

00:16:41,950 --> 00:16:47,260
cypress can combine information from

00:16:44,140 --> 00:16:48,790
end-to-end tests and unit tests and if

00:16:47,260 --> 00:16:51,370
you look at the combined report you get

00:16:48,790 --> 00:16:56,710
100% code coverage from your test but

00:16:51,370 --> 00:17:00,550
run by Cypress but wait but is always

00:16:56,710 --> 00:17:04,089
more so usually my web application is

00:17:00,550 --> 00:17:06,400
not just a static site it's not just a

00:17:04,089 --> 00:17:07,959
web application it has a back end and if

00:17:06,400 --> 00:17:09,730
you're writing our front end in

00:17:07,959 --> 00:17:13,630
JavaScript we probably are writing our

00:17:09,730 --> 00:17:16,060
back end in JavaScript using node so if

00:17:13,630 --> 00:17:18,790
you instrument your node code your

00:17:16,060 --> 00:17:21,339
server-side code in practice it's really

00:17:18,790 --> 00:17:24,390
easy so here's how you do it instead of

00:17:21,339 --> 00:17:27,520
saying npm start and running node server

00:17:24,390 --> 00:17:30,820
using start with coverage where you run

00:17:27,520 --> 00:17:33,490
a tool called and why c and you say

00:17:30,820 --> 00:17:37,690
instrument and start my node code that's

00:17:33,490 --> 00:17:39,760
it behind the scenes NYC will instrument

00:17:37,690 --> 00:17:42,130
every loaded file someone

00:17:39,760 --> 00:17:44,830
back end is running it actually collects

00:17:42,130 --> 00:17:46,780
code coverage information and cypress

00:17:44,830 --> 00:17:48,340
implements middlewares where you can

00:17:46,780 --> 00:17:50,560
just import depending on the server

00:17:48,340 --> 00:17:53,200
already using but can return that code

00:17:50,560 --> 00:17:55,360
coverage information so when the tests

00:17:53,200 --> 00:17:57,610
finish Cypress code coverage plug-in

00:17:55,360 --> 00:18:00,610
will ask hey give me everything from the

00:17:57,610 --> 00:18:02,680
back hand side that was covered by this

00:18:00,610 --> 00:18:05,560
test and when it just combines

00:18:02,680 --> 00:18:07,810
everything and now you get full stack

00:18:05,560 --> 00:18:12,220
code coverage from the same end-to-end

00:18:07,810 --> 00:18:14,230
tests in this case 91% again you don't

00:18:12,220 --> 00:18:16,870
have to exhaustively write with us

00:18:14,230 --> 00:18:21,300
because end-to-end tests are extremely

00:18:16,870 --> 00:18:26,170
effective at covering all parts of run

00:18:21,300 --> 00:18:28,600
even more tomorrow make sure not to miss

00:18:26,170 --> 00:18:30,430
Davis presentation so he's advocating

00:18:28,600 --> 00:18:33,550
and shows examples and has libraries

00:18:30,430 --> 00:18:37,240
which show final state machines that can

00:18:33,550 --> 00:18:39,490
drive application and if you can derive

00:18:37,240 --> 00:18:41,880
your application from final state

00:18:39,490 --> 00:18:44,530
machines you can also derive your tests

00:18:41,880 --> 00:18:47,050
automatically from a final state machine

00:18:44,530 --> 00:18:48,820
it becomes a graph problem so in this

00:18:47,050 --> 00:18:51,370
case both tests are not written by me

00:18:48,820 --> 00:18:54,520
instead I asked what final state machine

00:18:51,370 --> 00:18:57,640
give me all the possible paths for a

00:18:54,520 --> 00:19:00,130
tic-tac-toe game give me all the drawers

00:18:57,640 --> 00:19:02,800
and a single win for X and a single win

00:19:00,130 --> 00:19:04,180
for all and when Cypress transverse test

00:19:02,800 --> 00:19:06,190
and this test were automatically

00:19:04,180 --> 00:19:08,710
generated and I know that it's

00:19:06,190 --> 00:19:10,990
exhaustive set of tests because it's

00:19:08,710 --> 00:19:20,050
exhaustive set of paths in that finite

00:19:10,990 --> 00:19:22,510
state machine excellent so please use

00:19:20,050 --> 00:19:24,730
code coverage not as a goal don't strive

00:19:22,510 --> 00:19:26,980
to kill yourself achieving 100% code

00:19:24,730 --> 00:19:30,070
coverage instead look at the code

00:19:26,980 --> 00:19:31,720
coverage report and use missing lines as

00:19:30,070 --> 00:19:35,710
a guide to the tests that you want to

00:19:31,720 --> 00:19:38,650
write don't look at the number by itself

00:19:35,710 --> 00:19:40,930
don't look at 92 or 94 but instead on

00:19:38,650 --> 00:19:43,690
every poor request try to see a very

00:19:40,930 --> 00:19:45,280
sudden change if that number drops on a

00:19:43,690 --> 00:19:48,340
poor quest you probably have written

00:19:45,280 --> 00:19:51,310
code but you haven't tested or you

00:19:48,340 --> 00:19:53,380
emitted some necessary tests so it's the

00:19:51,310 --> 00:19:56,080
Delta in code coverage what matters

00:19:53,380 --> 00:19:57,880
not the number itself and finally like

00:19:56,080 --> 00:20:01,090
I'm really interested in looking beyond

00:19:57,880 --> 00:20:03,460
this simple lines of code code coverage

00:20:01,090 --> 00:20:06,790
number so state machine code coverage is

00:20:03,460 --> 00:20:08,740
important metric I think and the second

00:20:06,790 --> 00:20:10,840
question that people ask is that if I'm

00:20:08,740 --> 00:20:13,180
writing lots of tests some of my tests

00:20:10,840 --> 00:20:15,430
are short some tests along usually

00:20:13,180 --> 00:20:19,680
end-to-end tests are more realistic so

00:20:15,430 --> 00:20:22,180
they're longer how long is too long so a

00:20:19,680 --> 00:20:25,720
lot of unit tests a lot of short tests

00:20:22,180 --> 00:20:27,520
that we write are very short and they

00:20:25,720 --> 00:20:29,800
follow a couple of steps the first they

00:20:27,520 --> 00:20:31,870
arrange some data they may be importing

00:20:29,800 --> 00:20:34,120
a function set up arguments when they

00:20:31,870 --> 00:20:36,550
call what function with arguments they

00:20:34,120 --> 00:20:40,300
act and then they get results and they

00:20:36,550 --> 00:20:41,800
have a single assertion anything both

00:20:40,300 --> 00:20:43,630
tests are short and have usually a

00:20:41,800 --> 00:20:46,840
single assertion not because it's useful

00:20:43,630 --> 00:20:51,580
but because most of tests so far but are

00:20:46,840 --> 00:20:53,290
we running run in a terminal so if a

00:20:51,580 --> 00:20:58,080
test fails it becomes extremely

00:20:53,290 --> 00:21:00,370
extremely difficult to debug a long test

00:20:58,080 --> 00:21:02,170
because it might have multiple sources

00:21:00,370 --> 00:21:03,520
and multiple points of failure because

00:21:02,170 --> 00:21:05,560
we would have to rerun things in

00:21:03,520 --> 00:21:07,540
terminal maybe enable debug logs

00:21:05,560 --> 00:21:09,340
concentrate on that particular test so

00:21:07,540 --> 00:21:11,410
the terminal is not a good environment

00:21:09,340 --> 00:21:14,590
for running tests and debugging we're

00:21:11,410 --> 00:21:16,570
failures and I'm here to tell you it's

00:21:14,590 --> 00:21:20,230
okay to write longer tests if you have a

00:21:16,570 --> 00:21:22,480
better test Runner it's fine like start

00:21:20,230 --> 00:21:25,630
writing test now rightly a realistic

00:21:22,480 --> 00:21:28,120
task a test but represents a typical use

00:21:25,630 --> 00:21:32,320
case where a human comes in and uses

00:21:28,120 --> 00:21:35,380
your system in this case I'm testing a

00:21:32,320 --> 00:21:37,780
medium clone right where I'm writing a

00:21:35,380 --> 00:21:40,660
new blog post and filling all the fields

00:21:37,780 --> 00:21:42,490
and when kasib in common because where

00:21:40,660 --> 00:21:44,590
is the command log on the Left right now

00:21:42,490 --> 00:21:46,300
I'm hovering over each command from my

00:21:44,590 --> 00:21:50,260
test and it shows how the app looked

00:21:46,300 --> 00:21:53,590
during read step I can even click on a

00:21:50,260 --> 00:21:56,530
command open dev tools and debug you

00:21:53,590 --> 00:21:58,930
know xhr call for example in details and

00:21:56,530 --> 00:22:01,990
see everything with the application and

00:21:58,930 --> 00:22:04,090
my tests performed so if there is a

00:22:01,990 --> 00:22:07,059
failure somewhat in the middle of a test

00:22:04,090 --> 00:22:08,830
I can debug it easily

00:22:07,059 --> 00:22:10,990
I can see the behavior of an app and I

00:22:08,830 --> 00:22:18,789
can understand why it failed even before

00:22:10,990 --> 00:22:22,360
that assertion advant and still it's

00:22:18,789 --> 00:22:24,460
easy to get carried away everyone has

00:22:22,360 --> 00:22:26,769
their own time tolerance but I would

00:22:24,460 --> 00:22:29,350
save it for me anything longer than 20

00:22:26,769 --> 00:22:31,600
30 seconds is way too long of a test to

00:22:29,350 --> 00:22:33,789
work with effectively because every time

00:22:31,600 --> 00:22:36,490
I change something it has to way go for

00:22:33,789 --> 00:22:41,409
30 seconds of stuff before I know if my

00:22:36,490 --> 00:22:43,509
last command is passing or not so here's

00:22:41,409 --> 00:22:46,450
a typical example imagine you testing

00:22:43,509 --> 00:22:49,509
this multi-page form so you feel all the

00:22:46,450 --> 00:22:53,169
fields on the first page click next fill

00:22:49,509 --> 00:22:56,259
all the fields on the second page click

00:22:53,169 --> 00:22:58,029
next and then feel everything on a last

00:22:56,259 --> 00:23:00,999
page before you actually you know click

00:22:58,029 --> 00:23:03,159
sign up I slowed down typing here just

00:23:00,999 --> 00:23:05,230
to prove my point so this is way too

00:23:03,159 --> 00:23:07,899
long of a test and it goes through the

00:23:05,230 --> 00:23:10,809
setup of multiple pages just to confirm

00:23:07,899 --> 00:23:15,190
that the signup works what can we do to

00:23:10,809 --> 00:23:18,490
make it better we can split it into

00:23:15,190 --> 00:23:21,850
three tests but wait if I'm filling each

00:23:18,490 --> 00:23:23,470
page separately how it my last page get

00:23:21,850 --> 00:23:26,409
all the data but it needs to sign up

00:23:23,470 --> 00:23:29,139
well the way you do this is that each

00:23:26,409 --> 00:23:30,549
test and with a check point almost like

00:23:29,139 --> 00:23:33,610
a game check point where you save

00:23:30,549 --> 00:23:35,259
yourself and then respond later every

00:23:33,610 --> 00:23:37,330
new test doesn't start from a very

00:23:35,259 --> 00:23:39,460
beginning instead it starts immediately

00:23:37,330 --> 00:23:42,879
from a previously saved check point

00:23:39,460 --> 00:23:45,669
here's how it looks in my application if

00:23:42,879 --> 00:23:49,450
I'm running inside Cypress I will expose

00:23:45,669 --> 00:23:51,940
the app reference variable now my tests

00:23:49,450 --> 00:23:54,700
can access the application if I can do

00:23:51,940 --> 00:23:57,309
that when I can write a first test that

00:23:54,700 --> 00:24:00,070
only feels the first page goes to the

00:23:57,309 --> 00:24:03,159
second page and stops and that the very

00:24:00,070 --> 00:24:07,269
last command after it stops it grabs one

00:24:03,159 --> 00:24:10,659
window grabs that a preference accesses

00:24:07,269 --> 00:24:14,499
very dark State and make sure that it's

00:24:10,659 --> 00:24:16,840
correct it does deep equal and has a big

00:24:14,499 --> 00:24:18,080
object with all fields but I expect that

00:24:16,840 --> 00:24:21,230
form to

00:24:18,080 --> 00:24:24,230
whew so I know my tests go through page

00:24:21,230 --> 00:24:26,419
and ends in the same internal

00:24:24,230 --> 00:24:29,269
application state as I expect it to be

00:24:26,419 --> 00:24:32,630
and here's the start of a second test

00:24:29,269 --> 00:24:35,120
the very first command my test does it

00:24:32,630 --> 00:24:38,059
goes to the window grabs the application

00:24:35,120 --> 00:24:40,700
reference and in a single call says set

00:24:38,059 --> 00:24:44,720
your internal state into the Check Point

00:24:40,700 --> 00:24:47,000
object and when it starts filling the

00:24:44,720 --> 00:24:49,519
fields so here's the second test and

00:24:47,000 --> 00:24:51,860
here's me hovering over just set state

00:24:49,519 --> 00:24:54,889
command e c-curve application

00:24:51,860 --> 00:24:57,200
immediately switches from frost page to

00:24:54,889 --> 00:25:00,529
the beginning of a second page and it's

00:24:57,200 --> 00:25:02,870
internal data is set exactly the same

00:25:00,529 --> 00:25:06,080
way as if it filled everything on the

00:25:02,870 --> 00:25:09,260
first page but now I kinda like respond

00:25:06,080 --> 00:25:11,960
at the start of a second page and two

00:25:09,260 --> 00:25:15,610
application makes no difference if I

00:25:11,960 --> 00:25:21,169
fill the page or just reset the state

00:25:15,610 --> 00:25:23,120
every state starts at the last

00:25:21,169 --> 00:25:26,299
checkpoint of a previous almost like

00:25:23,120 --> 00:25:29,659
really erasing so I want to finish with

00:25:26,299 --> 00:25:31,519
a summary please please PLEASE document

00:25:29,659 --> 00:25:33,409
your code if you're writing JavaScript

00:25:31,519 --> 00:25:35,269
and I look at your library and it

00:25:33,409 --> 00:25:39,350
doesn't have examples I'll be very angry

00:25:35,269 --> 00:25:41,600
and I don't want to be angry the code

00:25:39,350 --> 00:25:43,669
coverage would have shown is not a

00:25:41,600 --> 00:25:46,070
target of itself it's just a tool for

00:25:43,669 --> 00:25:48,309
you to write tests that cover something

00:25:46,070 --> 00:25:51,289
else and don't repeat themselves and

00:25:48,309 --> 00:25:53,179
finally don't accept slow tests where

00:25:51,289 --> 00:25:55,580
are better ways to test so you don't

00:25:53,179 --> 00:25:58,399
have to wait for hours and hours and

00:25:55,580 --> 00:26:01,809
hours for them to finish thank you and

00:25:58,399 --> 00:26:01,809
shoot for the stars thank you

00:26:02,760 --> 00:26:08,800
thank you so much Claire we actually

00:26:05,890 --> 00:26:11,380
have a bunch of questions for you oh wow

00:26:08,800 --> 00:26:13,510
so we are now going to be able to answer

00:26:11,380 --> 00:26:15,940
all of them so let's start what do you

00:26:13,510 --> 00:26:17,830
think about new mutation tests

00:26:15,940 --> 00:26:19,900
I love mutation the mutation testing

00:26:17,830 --> 00:26:22,120
means you take the source code of your

00:26:19,900 --> 00:26:24,580
application and then randomly change

00:26:22,120 --> 00:26:26,290
variable or command and when you run all

00:26:24,580 --> 00:26:28,870
the tests and you see if tests actually

00:26:26,290 --> 00:26:31,330
fail if you actually did detect a

00:26:28,870 --> 00:26:33,040
mutation and if it don't that means your

00:26:31,330 --> 00:26:34,750
tests are not covering your application

00:26:33,040 --> 00:26:36,790
very well so I'm all for exploring

00:26:34,750 --> 00:26:37,270
mutation I didn't have time to implement

00:26:36,790 --> 00:26:39,130
it yet

00:26:37,270 --> 00:26:42,580
but if you want to talk to me I'm all

00:26:39,130 --> 00:26:45,640
for it next question the cyber support

00:26:42,580 --> 00:26:53,170
other browsers than Chrome if not then

00:26:45,640 --> 00:26:55,420
will be in future No so we support

00:26:53,170 --> 00:26:58,510
Chrome we're coming out with supporting

00:26:55,420 --> 00:27:00,580
edge beta and brave because they

00:26:58,510 --> 00:27:02,980
actually run on chromium but we have a

00:27:00,580 --> 00:27:06,400
pull request with Firefox support we

00:27:02,980 --> 00:27:09,460
have 3,000 full browser tests passing in

00:27:06,400 --> 00:27:11,260
chrome and out of 3,000 tests in Firefox

00:27:09,460 --> 00:27:13,420
we have only 15 failings so it's like

00:27:11,260 --> 00:27:16,450
this close this close with coming out

00:27:13,420 --> 00:27:19,660
with Firefox support can I use Cypress

00:27:16,450 --> 00:27:21,850
to test react native no so Cypress is

00:27:19,660 --> 00:27:24,520
only for anything which runs in the

00:27:21,850 --> 00:27:27,040
browser if you haven't converted every

00:27:24,520 --> 00:27:29,020
react native to the native app you

00:27:27,040 --> 00:27:32,260
probably can test it in a browser but

00:27:29,020 --> 00:27:34,420
afterwards unfortunately no checkpoints

00:27:32,260 --> 00:27:37,090
are only working with red X how would

00:27:34,420 --> 00:27:38,680
you do it with react context so the

00:27:37,090 --> 00:27:40,840
checkpoint scanner it's just an example

00:27:38,680 --> 00:27:44,080
but they used every application we can

00:27:40,840 --> 00:27:47,110
control it you can control it from end

00:27:44,080 --> 00:27:48,790
to end test and set its state or set its

00:27:47,110 --> 00:27:51,640
internal properties so it should work

00:27:48,790 --> 00:27:54,460
with every platform we have examples for

00:27:51,640 --> 00:27:57,340
view and angular and anything under the

00:27:54,460 --> 00:27:59,170
Sun how do check if my test is good the

00:27:57,340 --> 00:28:01,930
quality of it I have doubts that I'm

00:27:59,170 --> 00:28:04,360
testing right and it disappeared now

00:28:01,930 --> 00:28:06,400
it's they're testing great things right

00:28:04,360 --> 00:28:08,290
scenarios I would say the person who

00:28:06,400 --> 00:28:10,150
doubts that they have written a good

00:28:08,290 --> 00:28:11,560
test and they actually trying to see if

00:28:10,150 --> 00:28:12,850
it's good it's already on a path to

00:28:11,560 --> 00:28:14,260
writing good tests because they're

00:28:12,850 --> 00:28:14,800
doubting themselves and they're trying

00:28:14,260 --> 00:28:17,440
to improve

00:28:14,800 --> 00:28:20,170
I have not sure what makes a good test

00:28:17,440 --> 00:28:22,360
but I think if you review the test with

00:28:20,170 --> 00:28:24,070
your team just like we review your

00:28:22,360 --> 00:28:26,830
production code you can agree on a

00:28:24,070 --> 00:28:32,050
quality test the cyber support

00:28:26,830 --> 00:28:33,880
integration in given CI CD so you can

00:28:32,050 --> 00:28:36,100
run Cypress on your machine locally on

00:28:33,880 --> 00:28:38,350
every continuous integration platform go

00:28:36,100 --> 00:28:41,830
to our Docs we have example and running

00:28:38,350 --> 00:28:44,830
on every platform including gitlab how

00:28:41,830 --> 00:28:46,810
to service mock calls to and from API

00:28:44,830 --> 00:28:49,150
it marks on beautifully go to our Docs

00:28:46,810 --> 00:28:51,670
look at the documentation for Network

00:28:49,150 --> 00:28:54,100
stabbing you can spy and stub on

00:28:51,670 --> 00:28:55,870
Ajax calls from the application we come

00:28:54,100 --> 00:28:59,530
in with feature we can you stop and spy

00:28:55,870 --> 00:29:02,890
everything like everything is cypress

00:28:59,530 --> 00:29:04,840
using percy for visual tests cypress is

00:29:02,890 --> 00:29:07,450
just a tool and then there are plugins

00:29:04,840 --> 00:29:10,000
for visual testing so Percy has written

00:29:07,450 --> 00:29:12,340
their own library to mixture between

00:29:10,000 --> 00:29:14,620
Cyprus France it sends the things to

00:29:12,340 --> 00:29:16,750
Percy applitools has written a library

00:29:14,620 --> 00:29:19,390
for Cyprus as a plugin so you can send

00:29:16,750 --> 00:29:21,700
things to applitools vero open source

00:29:19,390 --> 00:29:23,170
image comparison libraries where cypress

00:29:21,700 --> 00:29:24,820
can generate snapshot and that bet

00:29:23,170 --> 00:29:26,770
library will do visual dipping for you

00:29:24,820 --> 00:29:29,050
so it's both commercial and open source

00:29:26,770 --> 00:29:32,430
things just go to a plugins page to find

00:29:29,050 --> 00:29:35,890
them it's possible to test react

00:29:32,430 --> 00:29:37,510
typescript with Cypress yes alright this

00:29:35,890 --> 00:29:40,750
is quick we have problems running

00:29:37,510 --> 00:29:43,660
Cypress tests on a CI request often time

00:29:40,750 --> 00:29:46,030
out when doing C why wait

00:29:43,660 --> 00:29:48,130
is this a known Cyprus problem or could

00:29:46,030 --> 00:29:50,950
be something on our side do remember I

00:29:48,130 --> 00:29:53,710
said but I write bad code right so I've

00:29:50,950 --> 00:29:55,870
written bad code and it fails right if

00:29:53,710 --> 00:29:59,440
you give us a producible example we'll

00:29:55,870 --> 00:30:02,050
debug it and we'll fix it it's reduction

00:29:59,440 --> 00:30:03,790
state committed to versioning system if

00:30:02,050 --> 00:30:06,490
yes isn't it too hard to maintain this

00:30:03,790 --> 00:30:08,200
just in long run a store is extended yes

00:30:06,490 --> 00:30:10,960
so you can meet it because I used it as

00:30:08,200 --> 00:30:13,390
an object it's up to you what to do but

00:30:10,960 --> 00:30:15,250
if you for example use just match

00:30:13,390 --> 00:30:17,230
snapshots it's kind of a same thing you

00:30:15,250 --> 00:30:19,750
have a trade-off between large fixture

00:30:17,230 --> 00:30:20,730
objects versus but test so you have to

00:30:19,750 --> 00:30:23,770
pick your battles

00:30:20,730 --> 00:30:27,160
is it possible to extract test results

00:30:23,770 --> 00:30:27,970
in eg g-unit Foreman or code coverage in

00:30:27,160 --> 00:30:29,950
different formats

00:30:27,970 --> 00:30:31,840
yes so the Cyprus plugins save the

00:30:29,950 --> 00:30:33,640
coverage report in multiple formats and

00:30:31,840 --> 00:30:35,650
you can configure additional ones so you

00:30:33,640 --> 00:30:38,530
can send it everywhere I'm gonna say

00:30:35,650 --> 00:30:43,960
last three questions how do we ete test

00:30:38,530 --> 00:30:46,420
and slow api okay you don't if your API

00:30:43,960 --> 00:30:51,760
calls and - entrance are slow you

00:30:46,420 --> 00:30:55,390
Malcolm who should rate Cyprus test

00:30:51,760 --> 00:30:56,800
front-end developer or the QA I think

00:30:55,390 --> 00:30:59,260
the developers who's working on

00:30:56,800 --> 00:31:01,870
application should write end to end test

00:30:59,260 --> 00:31:03,580
I mean QA can run them write them but

00:31:01,870 --> 00:31:05,260
when you working on a tool but test

00:31:03,580 --> 00:31:09,070
helped you to actually write better code

00:31:05,260 --> 00:31:10,990
right away last question glove what

00:31:09,070 --> 00:31:13,240
about integration of Cyprus with visual

00:31:10,990 --> 00:31:14,980
regression testing like taking

00:31:13,240 --> 00:31:16,780
screenshots when running some tests and

00:31:14,980 --> 00:31:19,120
comparing images just like I said for

00:31:16,780 --> 00:31:22,330
Percy and applitools for plugins that

00:31:19,120 --> 00:31:24,190
use open source local tools but do image

00:31:22,330 --> 00:31:26,710
comparison so just go to our plugins

00:31:24,190 --> 00:31:28,390
page or we have a visual testing guide

00:31:26,710 --> 00:31:30,790
in our documentation that covers pretty

00:31:28,390 --> 00:31:32,460
much every scenario thank you so much

00:31:30,790 --> 00:31:36,680
Claire as you can see

00:31:32,460 --> 00:31:36,680

YouTube URL: https://www.youtube.com/watch?v=JL3QKQO80fs


