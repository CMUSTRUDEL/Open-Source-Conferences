Title: ReactiveConf 2019 -Sean Grove: Rust in the Browser for Javascripters:New Frontiers,New Possibilities
Publication date: 2019-10-30
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Millennium stage
-------------------------------------------------------------------
Thanks to wasm, Rust can reach the platform with the largest reach: the browser. We’ll take a look at how thanks to the impressive language design, thoughtful compiler error messages, and great documentation, JavaScripters can unlock high-performance concurrency and graphics thanks to Rust. We’ll step through Rust/wasm/JS interop, see what it’s like to get a reference to a canvas instance, to communicate with services workers, and to pass data between all the pieces involved. We’ll take a look at what’s enabled, as well as pitfalls around the data boundaries involved, and the size of the final payload, so that it’s clear where the cost of introducing Rust is outweighed by its benefits. Finally, we’ll speculate on how the web may develop, with a Rust-core/JavaScript-surface design, combining high performance, safety, while maintaining ease-of-use.
Captions: 
	00:00:04,530 --> 00:00:08,379
[Music]

00:00:15,960 --> 00:00:21,310
well thank you very much for that warm

00:00:18,700 --> 00:00:24,340
introduction I'm going to be talking

00:00:21,310 --> 00:00:27,820
about roasts for JavaScript errs show of

00:00:24,340 --> 00:00:30,010
hands who has heard of roasts before

00:00:27,820 --> 00:00:33,160
all right cool looks like no one raised

00:00:30,010 --> 00:00:36,159
their hands as far as I could tell all

00:00:33,160 --> 00:00:37,449
right but first a quick bit about me I'm

00:00:36,159 --> 00:00:40,479
Shawn growth coming out of San Francisco

00:00:37,449 --> 00:00:41,460
I work at a company called one graph but

00:00:40,479 --> 00:00:43,870
I don't really talk about that today

00:00:41,460 --> 00:00:47,080
I'll give a little bit of context about

00:00:43,870 --> 00:00:50,710
my experience with rust the main project

00:00:47,080 --> 00:00:53,229
I shipped in rust was a cross-compiled

00:00:50,710 --> 00:00:55,449
arm embedded system and in kind of an

00:00:53,229 --> 00:00:56,920
IOT device and so you can imagine that

00:00:55,449 --> 00:00:58,900
we have these bits of hardware that

00:00:56,920 --> 00:01:00,549
we're shipping out to the edge and we

00:00:58,900 --> 00:01:03,729
need to be able to push updates to them

00:01:00,549 --> 00:01:05,650
very very reliably and so we had a lot

00:01:03,729 --> 00:01:08,140
of performance and a lot of security and

00:01:05,650 --> 00:01:09,670
a lot of correctness concerns with this

00:01:08,140 --> 00:01:11,170
project

00:01:09,670 --> 00:01:12,910
other than that though I used to work a

00:01:11,170 --> 00:01:14,680
lot enclosure enclosure script these

00:01:12,910 --> 00:01:20,170
days I mostly spend my time in reason

00:01:14,680 --> 00:01:24,930
and rust but I am here today to sell you

00:01:20,170 --> 00:01:27,850
on rust and this is serious business

00:01:24,930 --> 00:01:29,920
that's actually why I am dressed so

00:01:27,850 --> 00:01:31,060
nicely so that you know that this is

00:01:29,920 --> 00:01:34,840
serious business

00:01:31,060 --> 00:01:36,580
but I do have my button undone at the

00:01:34,840 --> 00:01:39,580
top so you know I'm trustworthy I'm kind

00:01:36,580 --> 00:01:42,030
of a chill business guy so with that

00:01:39,580 --> 00:01:45,040
said I've been practicing my pitch

00:01:42,030 --> 00:01:47,200
working with rust in the beginning is

00:01:45,040 --> 00:01:52,060
like banging your head against the wall

00:01:47,200 --> 00:01:53,590
I know we're all excited about that but

00:01:52,060 --> 00:01:56,440
I want to set expectations at the

00:01:53,590 --> 00:01:58,960
beginning of this talk it's good to

00:01:56,440 --> 00:02:01,210
think about rust from the negatives

00:01:58,960 --> 00:02:04,150
initially so you're at least setting

00:02:01,210 --> 00:02:06,400
expectations basically any time you have

00:02:04,150 --> 00:02:08,679
a bit of JavaScript code if you write

00:02:06,400 --> 00:02:11,890
the equivalent in rust it will be longer

00:02:08,679 --> 00:02:14,620
it will be more intricate and will have

00:02:11,890 --> 00:02:17,140
a lot more symbols it's not always true

00:02:14,620 --> 00:02:21,040
but it's just a good attitude to have

00:02:17,140 --> 00:02:24,250
it's true enough of the time now rust

00:02:21,040 --> 00:02:26,560
itself is described as a systems level

00:02:24,250 --> 00:02:30,930
programming language that cares about

00:02:26,560 --> 00:02:33,160
performance security and correctness I

00:02:30,930 --> 00:02:34,660
don't know if systems level programming

00:02:33,160 --> 00:02:36,160
is such a good description for it

00:02:34,660 --> 00:02:37,959
because it goes in a lot of interesting

00:02:36,160 --> 00:02:39,570
destinations but that's how they

00:02:37,959 --> 00:02:42,060
describe themselves so we'll run with it

00:02:39,570 --> 00:02:44,230
but from a JavaScript is point of view

00:02:42,060 --> 00:02:47,140
Russ is interesting because it's low

00:02:44,230 --> 00:02:49,870
level very very very low level but it

00:02:47,140 --> 00:02:52,090
has a lot of abstractions and they focus

00:02:49,870 --> 00:02:55,120
a lot on zero-cost abstractions in

00:02:52,090 --> 00:02:59,019
particular it also has guaranteed memory

00:02:55,120 --> 00:03:01,750
safety which is a big issue whenever you

00:02:59,019 --> 00:03:03,430
are working a lower-level language it

00:03:01,750 --> 00:03:06,070
also carries a lot about concurrency so

00:03:03,430 --> 00:03:07,150
has threads without data races and it

00:03:06,070 --> 00:03:09,970
has some nice things that kind of

00:03:07,150 --> 00:03:12,340
inherits some of the like reason type of

00:03:09,970 --> 00:03:15,390
features like type inference and pattern

00:03:12,340 --> 00:03:18,160
matching and has a very minimal runtime

00:03:15,390 --> 00:03:21,060
but why would you care why do you want

00:03:18,160 --> 00:03:24,850
to have low level but with abstractions

00:03:21,060 --> 00:03:27,640
rust is very focused on very predictable

00:03:24,850 --> 00:03:30,000
performance at any given time it's going

00:03:27,640 --> 00:03:33,700
to give you as much control as you need

00:03:30,000 --> 00:03:35,739
to eke out every bit of performance from

00:03:33,700 --> 00:03:37,630
your hardware this includes things like

00:03:35,739 --> 00:03:41,739
memory allocation layout garbage

00:03:37,630 --> 00:03:44,850
collection all that sort of thing but

00:03:41,739 --> 00:03:48,700
once you get access to all of that power

00:03:44,850 --> 00:03:50,110
basically you have this amazing gun that

00:03:48,700 --> 00:03:53,140
you will immediately point at your foot

00:03:50,110 --> 00:03:55,329
and pull the trigger it's very very

00:03:53,140 --> 00:03:57,040
difficult to ensure data integrity

00:03:55,329 --> 00:04:00,820
whenever you have this level of control

00:03:57,040 --> 00:04:03,880
in particular trying to maintain any

00:04:00,820 --> 00:04:04,600
sort of data integrity with that level

00:04:03,880 --> 00:04:07,680
of control

00:04:04,600 --> 00:04:10,959
with concurrency is next to impossible

00:04:07,680 --> 00:04:14,620
so many of the bugs that we face in our

00:04:10,959 --> 00:04:19,570
day to day usage of servers is because

00:04:14,620 --> 00:04:21,940
of threads with data races and type

00:04:19,570 --> 00:04:24,190
inference typing first is a topic that's

00:04:21,940 --> 00:04:26,140
near and dear to my heart but I would

00:04:24,190 --> 00:04:27,940
say before we explain what type

00:04:26,140 --> 00:04:29,800
inference is for like why not step back

00:04:27,940 --> 00:04:30,610
and actually ask what the hell are types

00:04:29,800 --> 00:04:34,870
for

00:04:30,610 --> 00:04:37,000
and if you ask Cee Cee says types are

00:04:34,870 --> 00:04:39,159
for performance types tell the compiler

00:04:37,000 --> 00:04:40,780
for all of your data how should it

00:04:39,159 --> 00:04:43,860
actually be represented at runtime

00:04:40,780 --> 00:04:47,080
both in memory and on the CPU and

00:04:43,860 --> 00:04:48,669
typescript and flow they don't care

00:04:47,080 --> 00:04:51,669
about the delay out of the data what

00:04:48,669 --> 00:04:53,620
they care about is correctness all right

00:04:51,669 --> 00:04:55,629
if you think about C it can't prevent

00:04:53,620 --> 00:04:57,969
many of the mistakes that you might have

00:04:55,629 --> 00:04:59,620
or where you pass one string when you

00:04:57,969 --> 00:05:01,210
should have passed an array I mean as

00:04:59,620 --> 00:05:04,990
long as they look like bytes it's fine

00:05:01,210 --> 00:05:07,479
and typescript you can add as many types

00:05:04,990 --> 00:05:09,340
as you want but it will never be used by

00:05:07,479 --> 00:05:11,830
v8 whenever you're actually running your

00:05:09,340 --> 00:05:13,690
code so you kind of have these two

00:05:11,830 --> 00:05:15,550
different values that Tice might offer

00:05:13,690 --> 00:05:18,159
and different languages will choose

00:05:15,550 --> 00:05:20,590
different pieces of it and Russ says

00:05:18,159 --> 00:05:24,240
that well types are for correctness and

00:05:20,590 --> 00:05:26,409
for performance why not do both and

00:05:24,240 --> 00:05:29,080
there is another language that has said

00:05:26,409 --> 00:05:31,870
this before Java I know

00:05:29,080 --> 00:05:35,319
Java is not very popular and if you look

00:05:31,870 --> 00:05:37,919
at Java right here so this is an example

00:05:35,319 --> 00:05:41,020
of declaring some variables in Java and

00:05:37,919 --> 00:05:44,110
you say hey I have an integer called

00:05:41,020 --> 00:05:46,750
number and it's 29 and I feel like this

00:05:44,110 --> 00:05:48,940
is like working with a compiler that's

00:05:46,750 --> 00:05:51,370
very hard of hearing right because I say

00:05:48,940 --> 00:05:52,750
hey my flag is false and you should know

00:05:51,370 --> 00:05:54,879
that it's a boolean right what else

00:05:52,750 --> 00:05:56,139
could it be I told you it's false but

00:05:54,879 --> 00:05:57,310
the compiler is like I'm sorry didn't

00:05:56,139 --> 00:06:00,039
hear you and so you have to kind of

00:05:57,310 --> 00:06:03,370
shout that's hey this is a boolean and

00:06:00,039 --> 00:06:05,349
you have to repeat yourself a lot so the

00:06:03,370 --> 00:06:07,659
idea is type inference actually says

00:06:05,349 --> 00:06:10,719
what if the compiler were to look

00:06:07,659 --> 00:06:13,839
through your code and say can I figure

00:06:10,719 --> 00:06:15,539
out the types for you so in this case

00:06:13,839 --> 00:06:17,529
I'm declaring a variable called elem and

00:06:15,539 --> 00:06:21,699
it's gonna be an element inside of my

00:06:17,529 --> 00:06:24,520
array and it's just 5 the u8 is a

00:06:21,699 --> 00:06:26,409
literal for an unsigned 8-bit integer

00:06:24,520 --> 00:06:28,750
you don't have to have it but it's nice

00:06:26,409 --> 00:06:29,919
if you want to have it and you see that

00:06:28,750 --> 00:06:33,099
I'm going to create a vector which is

00:06:29,919 --> 00:06:35,139
basically an array but I don't say what

00:06:33,099 --> 00:06:37,629
the vector is off I just say hey it's a

00:06:35,139 --> 00:06:40,240
vector and now whenever I push the

00:06:37,629 --> 00:06:43,419
element in to the vector Russ knows this

00:06:40,240 --> 00:06:44,460
must be a vector of unsigned 8-bit

00:06:43,419 --> 00:06:47,040
integers

00:06:44,460 --> 00:06:49,700
and the cool thing is that we have very

00:06:47,040 --> 00:06:52,860
very minimal type annotations that a

00:06:49,700 --> 00:06:54,780
programmer has to do but the compiler is

00:06:52,860 --> 00:06:56,670
still happy right the compiler can check

00:06:54,780 --> 00:06:58,860
for all sorts of bugs and it can

00:06:56,670 --> 00:07:01,950
optimize the exact memory layout of your

00:06:58,860 --> 00:07:03,660
code as much as you need and so the

00:07:01,950 --> 00:07:06,180
compiler is happy and the programmer is

00:07:03,660 --> 00:07:09,000
happy and it's kind of this principle in

00:07:06,180 --> 00:07:10,590
Ross where wherever possible the

00:07:09,000 --> 00:07:12,450
computer should be doing work for us

00:07:10,590 --> 00:07:16,920
rather than us doing work for the

00:07:12,450 --> 00:07:19,470
computer now why is a minimal runtime so

00:07:16,920 --> 00:07:22,530
important right so traditionally with

00:07:19,470 --> 00:07:25,050
things like C or C++ you're kind of

00:07:22,530 --> 00:07:27,360
targeting beefy machines right you're

00:07:25,050 --> 00:07:29,700
pushing to Linux somewhere and it has

00:07:27,360 --> 00:07:31,920
gigabytes of hard drive and gigabytes of

00:07:29,700 --> 00:07:33,240
RAM and it doesn't matter how big it is

00:07:31,920 --> 00:07:37,020
right because you'll download it once

00:07:33,240 --> 00:07:39,330
and it's fine but as we start to push to

00:07:37,020 --> 00:07:41,280
smaller devices or to the web in

00:07:39,330 --> 00:07:43,650
particular that puts a lot of pressure

00:07:41,280 --> 00:07:47,850
on how much data you can actually ship

00:07:43,650 --> 00:07:49,080
to your clients Sogo is another language

00:07:47,850 --> 00:07:51,890
that has been working really hard at

00:07:49,080 --> 00:07:54,900
having really great web assembly support

00:07:51,890 --> 00:07:57,750
the challenge is go was originally

00:07:54,900 --> 00:08:00,030
designed to run on servers where space

00:07:57,750 --> 00:08:02,340
and size are not a concern we care much

00:08:00,030 --> 00:08:06,060
more about performance than we do about

00:08:02,340 --> 00:08:07,950
size and so what that meant is that go

00:08:06,060 --> 00:08:11,390
has kind of built this culture where by

00:08:07,950 --> 00:08:14,340
default a hello world go application

00:08:11,390 --> 00:08:16,890
compiled to web assembly will start at

00:08:14,340 --> 00:08:19,200
two megabytes and if you pull in any

00:08:16,890 --> 00:08:22,440
library it's going to balloon to about

00:08:19,200 --> 00:08:23,580
ten megabytes very very quickly and I'll

00:08:22,440 --> 00:08:25,530
get the credit

00:08:23,580 --> 00:08:27,990
there's work on a thing called tiny go

00:08:25,530 --> 00:08:29,730
which is a subset of go that starts at

00:08:27,990 --> 00:08:33,030
10 kilobytes which is amazing

00:08:29,730 --> 00:08:35,510
but the challenge here is libraries

00:08:33,030 --> 00:08:38,700
actually have to add support for tiny go

00:08:35,510 --> 00:08:40,980
because the ecosystem has built up with

00:08:38,700 --> 00:08:44,010
this expectation that well having a big

00:08:40,980 --> 00:08:46,770
runtime is not a problem but Rost was

00:08:44,010 --> 00:08:49,290
originally designed to go everywhere

00:08:46,770 --> 00:08:53,250
including embedded devices that are so

00:08:49,290 --> 00:08:54,930
small they can't actually fit Lib C so

00:08:53,250 --> 00:08:57,520
you can write a Russ program that will

00:08:54,930 --> 00:08:59,800
compile with no standard library

00:08:57,520 --> 00:09:01,960
to bring your own but that gives you the

00:08:59,800 --> 00:09:03,430
ability to define exactly the size and

00:09:01,960 --> 00:09:07,900
performance characteristics of your

00:09:03,430 --> 00:09:10,930
application and like I said it rust

00:09:07,900 --> 00:09:13,150
inherits a lot from the ML language of

00:09:10,930 --> 00:09:17,050
family so like Haskell or Oh camera or

00:09:13,150 --> 00:09:18,070
reason in particular pattern matching so

00:09:17,050 --> 00:09:20,710
a pattern matching is near and dear to

00:09:18,070 --> 00:09:22,870
my heart so you can see here that I have

00:09:20,710 --> 00:09:25,000
a list of greetings so there were three

00:09:22,870 --> 00:09:27,790
of them what I'm gonna do is iterate

00:09:25,000 --> 00:09:30,520
over them and I'm going to get the index

00:09:27,790 --> 00:09:32,710
and the item and now I'm just gonna have

00:09:30,520 --> 00:09:35,200
a switch here basically match I'm gonna

00:09:32,710 --> 00:09:38,050
say based off of this index I want to

00:09:35,200 --> 00:09:39,850
print out a different breeding so if

00:09:38,050 --> 00:09:43,510
it's zero I'll printed English outs

00:09:39,850 --> 00:09:45,190
Korean or Swedish and this right here is

00:09:43,510 --> 00:09:49,360
not too bad right we can look at like

00:09:45,190 --> 00:09:51,430
the list of 1 through 0 through 1 2 and

00:09:49,360 --> 00:09:54,820
we can see that yes there are 3

00:09:51,430 --> 00:09:57,160
greetings there but what happens when

00:09:54,820 --> 00:09:59,320
there is a third one right now we can

00:09:57,160 --> 00:10:01,120
verify it but what if these two bits of

00:09:59,320 --> 00:10:03,850
data were actually a part in the code

00:10:01,120 --> 00:10:08,230
base then what will happen is this will

00:10:03,850 --> 00:10:10,630
crash so what happens is russ has

00:10:08,230 --> 00:10:12,940
exhaustive pattern matching where it

00:10:10,630 --> 00:10:15,760
says I have detected a case that you

00:10:12,940 --> 00:10:18,730
have not handled and in fact I will not

00:10:15,760 --> 00:10:22,480
compile this because it is guaranteed to

00:10:18,730 --> 00:10:23,590
crash if this case happens now you can

00:10:22,480 --> 00:10:26,110
see here that it's giving me this nice

00:10:23,590 --> 00:10:29,350
error message the error messages in Russ

00:10:26,110 --> 00:10:30,400
are heavily inspired by those in elm so

00:10:29,350 --> 00:10:31,480
it's a systems level programming

00:10:30,400 --> 00:10:34,300
language that really cares about

00:10:31,480 --> 00:10:36,850
developer experience you can see that

00:10:34,300 --> 00:10:39,400
hey you didn't cover this underscore

00:10:36,850 --> 00:10:43,690
case which is kind of a weird thing to

00:10:39,400 --> 00:10:45,490
say what it's saying is I looked at what

00:10:43,690 --> 00:10:48,910
you're mapping over your mapping over

00:10:45,490 --> 00:10:50,590
numbers it's really hard for you in one

00:10:48,910 --> 00:10:53,110
source code file to list every single

00:10:50,590 --> 00:10:55,930
number possible so you need to have a

00:10:53,110 --> 00:10:57,370
default case which is this underscore so

00:10:55,930 --> 00:11:00,220
it's literally telling you hey you need

00:10:57,370 --> 00:11:02,500
to add support for this default case if

00:11:00,220 --> 00:11:05,710
it was something else like say an enum

00:11:02,500 --> 00:11:07,450
that had maybe open or closed or some

00:11:05,710 --> 00:11:09,430
finite number of states it would have

00:11:07,450 --> 00:11:11,200
said hey you have open but not closed

00:11:09,430 --> 00:11:14,589
you should handle that case

00:11:11,200 --> 00:11:17,470
and the cool thing is they canonicalize

00:11:14,589 --> 00:11:18,790
all of their errors so you can see here

00:11:17,470 --> 00:11:20,470
if you want to know more information

00:11:18,790 --> 00:11:22,750
about that you can just say hey rust

00:11:20,470 --> 00:11:24,490
explain to me why why is it so important

00:11:22,750 --> 00:11:26,740
why are you bothering me about this and

00:11:24,490 --> 00:11:28,750
will actually print out documentation in

00:11:26,740 --> 00:11:30,639
your terminal or your editor saying hey

00:11:28,750 --> 00:11:32,320
here's a list of all the things that

00:11:30,639 --> 00:11:35,769
could go wrong that I'm watching out for

00:11:32,320 --> 00:11:38,829
you right now with this error so we add

00:11:35,769 --> 00:11:41,290
a default case and Russ is happy and

00:11:38,829 --> 00:11:46,060
we're happy because we know that this is

00:11:41,290 --> 00:11:47,680
never ever going to crash so from the

00:11:46,060 --> 00:11:51,930
correctness point of view I would say

00:11:47,680 --> 00:11:54,790
debugging sucks there is never a time

00:11:51,930 --> 00:11:57,970
that I'm excited about debugging unless

00:11:54,790 --> 00:11:59,829
it is so bad that I'm like oh man when I

00:11:57,970 --> 00:12:01,180
go to the pub tonight and I tell people

00:11:59,829 --> 00:12:03,430
about this oh it's gonna make for a

00:12:01,180 --> 00:12:06,850
great story but most of the time I don't

00:12:03,430 --> 00:12:09,250
want to be debugging so I say there are

00:12:06,850 --> 00:12:11,800
three questions from order of easiest to

00:12:09,250 --> 00:12:14,320
hardest about debugging the easiest is

00:12:11,800 --> 00:12:18,490
who should be doing the debugging second

00:12:14,320 --> 00:12:21,399
is when enter is where so who should do

00:12:18,490 --> 00:12:24,519
it well this is easy the language by

00:12:21,399 --> 00:12:25,540
virtue of construction the language

00:12:24,519 --> 00:12:30,959
should make it so that it is impossible

00:12:25,540 --> 00:12:33,160
for me to add bugs into my program

00:12:30,959 --> 00:12:34,390
wherever that's not possible because the

00:12:33,160 --> 00:12:36,850
language needs to give me more power

00:12:34,390 --> 00:12:39,100
that might introduce bugs the compiler

00:12:36,850 --> 00:12:41,620
should start checking my code right the

00:12:39,100 --> 00:12:44,440
compiler has access to all of my code it

00:12:41,620 --> 00:12:45,760
has access to all of my dependencies it

00:12:44,440 --> 00:12:48,100
should be checking through everything

00:12:45,760 --> 00:12:51,010
that the language couldn't to make sure

00:12:48,100 --> 00:12:52,660
that I didn't add any bugs and then

00:12:51,010 --> 00:12:54,160
maybe some automated tooling around like

00:12:52,660 --> 00:12:55,779
linters maybe this is something that my

00:12:54,160 --> 00:12:58,769
company has about some rules about how I

00:12:55,779 --> 00:13:02,649
should be coding finally there are tests

00:12:58,769 --> 00:13:04,569
if all of that fails and I'm ice I have

00:13:02,649 --> 00:13:06,100
to still debug then I guess it's me but

00:13:04,569 --> 00:13:08,230
if a developer doesn't do it then the

00:13:06,100 --> 00:13:11,290
user does it and that's the worst

00:13:08,230 --> 00:13:13,870
scenario right how many times have we

00:13:11,290 --> 00:13:16,329
been on a plane or train booking web

00:13:13,870 --> 00:13:19,269
site and you go to submit the form and

00:13:16,329 --> 00:13:22,329
it doesn't work and so you open up the

00:13:19,269 --> 00:13:23,980
console you get the HTML element and you

00:13:22,329 --> 00:13:24,440
manually submit it in the console and it

00:13:23,980 --> 00:13:26,899
works

00:13:24,440 --> 00:13:28,790
right so that it's possible for the user

00:13:26,899 --> 00:13:30,290
to debug and maybe that's a good thing

00:13:28,790 --> 00:13:34,220
but it's certainly not a great

00:13:30,290 --> 00:13:36,230
experience and so the question next

00:13:34,220 --> 00:13:40,639
question is then when should debugging

00:13:36,230 --> 00:13:42,980
happen and like Elm Russ says it should

00:13:40,639 --> 00:13:45,170
happen upfront you should push all of

00:13:42,980 --> 00:13:47,569
that up front because the moment that

00:13:45,170 --> 00:13:49,990
you introduced that bug is the moment

00:13:47,569 --> 00:13:52,399
when you had the most context to fix it

00:13:49,990 --> 00:13:53,959
so it's going to list out all of the

00:13:52,399 --> 00:13:57,709
bugs that you have at any given time and

00:13:53,959 --> 00:13:59,300
say fix these before I compile and that

00:13:57,709 --> 00:14:02,660
means that by the time you actually get

00:13:59,300 --> 00:14:05,360
it to compile it just works most of the

00:14:02,660 --> 00:14:07,459
time it's actually a very jarring

00:14:05,360 --> 00:14:09,319
experience especially coming from

00:14:07,459 --> 00:14:11,389
something like JavaScript which is

00:14:09,319 --> 00:14:14,240
amazingly flexible and a lot of fun to

00:14:11,389 --> 00:14:15,980
program in but it will allow you to make

00:14:14,240 --> 00:14:19,459
mistakes that will take you a long time

00:14:15,980 --> 00:14:20,750
to track down and I want to give one

00:14:19,459 --> 00:14:23,259
last shout out to the Russ community

00:14:20,750 --> 00:14:27,110
here because they have built a crazy

00:14:23,259 --> 00:14:29,180
empathetic and welcoming community most

00:14:27,110 --> 00:14:30,860
systems programming languages the

00:14:29,180 --> 00:14:33,949
community is not known for being very

00:14:30,860 --> 00:14:36,139
welcoming but this community cares

00:14:33,949 --> 00:14:38,870
hugely about the experience of new

00:14:36,139 --> 00:14:41,569
developers and experienced developers so

00:14:38,870 --> 00:14:44,089
much so that they regularly have surveys

00:14:41,569 --> 00:14:46,579
about the experience of different parts

00:14:44,089 --> 00:14:49,060
of rust and then they will actually take

00:14:46,579 --> 00:14:51,350
the top pains and form a working group

00:14:49,060 --> 00:14:53,269
so they knew that web assembly was going

00:14:51,350 --> 00:14:55,490
to be a really important task for them

00:14:53,269 --> 00:14:58,250
so they actually formed a working group

00:14:55,490 --> 00:15:00,829
to say your job is to make it so that

00:14:58,250 --> 00:15:03,139
someone who doesn't know rust can come

00:15:00,829 --> 00:15:06,380
to this website read through the docs

00:15:03,139 --> 00:15:11,509
and have a fully working Game of Life in

00:15:06,380 --> 00:15:15,829
30 minutes which is an insane task but

00:15:11,509 --> 00:15:19,100
it is they've done it so now why would

00:15:15,829 --> 00:15:21,620
you care as a JavaScript er and it's

00:15:19,100 --> 00:15:24,769
because Russ now actually compiles down

00:15:21,620 --> 00:15:28,670
to web assembling and web assembly is

00:15:24,769 --> 00:15:30,379
pretty crazy powerful it is

00:15:28,670 --> 00:15:32,720
I think unprecedented and how

00:15:30,379 --> 00:15:34,370
well-designed it is and how adopted it

00:15:32,720 --> 00:15:36,730
is usually a lot of great technology

00:15:34,370 --> 00:15:38,800
kind of never gets adopted

00:15:36,730 --> 00:15:39,700
I want to give another caveat here

00:15:38,800 --> 00:15:42,540
though

00:15:39,700 --> 00:15:44,920
using webassembly from JavaScript is

00:15:42,540 --> 00:15:47,230
currently a little bit on the ematic it

00:15:44,920 --> 00:15:49,720
feels a little bit weird but it's not

00:15:47,230 --> 00:15:51,730
too bad but that also means that because

00:15:49,720 --> 00:15:54,490
rust is compiling to web assembly that

00:15:51,730 --> 00:15:56,800
also be a little bit thankful but in

00:15:54,490 --> 00:15:58,690
particular rust is compiling down to

00:15:56,800 --> 00:16:02,800
JavaScript or sorry into web assembly

00:15:58,690 --> 00:16:07,390
and webassembly literally is just a big

00:16:02,800 --> 00:16:11,890
array of bytes ones and zeroes there are

00:16:07,390 --> 00:16:15,400
no strings there are no floats there are

00:16:11,890 --> 00:16:16,870
just ones and zeros and all the things

00:16:15,400 --> 00:16:19,780
that we take for granted in JavaScript

00:16:16,870 --> 00:16:21,250
don't really exist there and yet we want

00:16:19,780 --> 00:16:25,570
javascript to be able to call functions

00:16:21,250 --> 00:16:29,950
and pass in data and retrieve data more

00:16:25,570 --> 00:16:31,390
than just maybe ones and zeros so what

00:16:29,950 --> 00:16:34,870
we need to do is figure out how to

00:16:31,390 --> 00:16:38,500
interrupt between these two systems by

00:16:34,870 --> 00:16:40,330
default your JavaScript will load up it

00:16:38,500 --> 00:16:43,480
will reach out and download a big blob

00:16:40,330 --> 00:16:45,370
of wasum data it will instantiate it and

00:16:43,480 --> 00:16:47,260
pass in all of the functions from the

00:16:45,370 --> 00:16:49,570
outside world that the web assembly

00:16:47,260 --> 00:16:51,340
bundle is allowed to know about and then

00:16:49,570 --> 00:16:52,810
having instantiated it it can now call

00:16:51,340 --> 00:16:55,240
into functions that exist on the web

00:16:52,810 --> 00:16:57,280
assembly side so you can imagine here

00:16:55,240 --> 00:17:00,250
that I have my wasm and I call greet and

00:16:57,280 --> 00:17:02,320
I pass in hi that's going to go over to

00:17:00,250 --> 00:17:04,000
the web assembly side I've implemented a

00:17:02,320 --> 00:17:08,470
greet function there and I'm going to

00:17:04,000 --> 00:17:11,110
return a string back but this bridge

00:17:08,470 --> 00:17:14,709
right here going back and forth has to

00:17:11,110 --> 00:17:15,970
be implemented by me and when I'm

00:17:14,709 --> 00:17:17,709
implementing it I have a couple of

00:17:15,970 --> 00:17:20,560
different goals one is I want to

00:17:17,709 --> 00:17:22,540
minimize the copying because these are

00:17:20,560 --> 00:17:25,900
two separate worlds they both have their

00:17:22,540 --> 00:17:29,110
own view of memory they're a memory does

00:17:25,900 --> 00:17:31,150
not touch one another and so that means

00:17:29,110 --> 00:17:32,530
if I were in JavaScript and I just

00:17:31,150 --> 00:17:34,330
copied a bunch of memory and sent it

00:17:32,530 --> 00:17:35,950
over to the other side that would

00:17:34,330 --> 00:17:37,480
actually be really slow it would put a

00:17:35,950 --> 00:17:40,750
lot of pressure on the garbage

00:17:37,480 --> 00:17:42,820
collection and it would kind of in many

00:17:40,750 --> 00:17:44,110
ways like defeat the points of using

00:17:42,820 --> 00:17:46,030
rusts which is I want to have

00:17:44,110 --> 00:17:48,670
fine-grained control over memory

00:17:46,030 --> 00:17:49,940
allocation performance so what we're

00:17:48,670 --> 00:17:52,220
going to instead

00:17:49,940 --> 00:17:56,230
is on the web assembly side in rust

00:17:52,220 --> 00:18:00,470
we're going to create a huge array of

00:17:56,230 --> 00:18:01,610
memory and now on JavaScript we're going

00:18:00,470 --> 00:18:04,430
to actually just call a function like

00:18:01,610 --> 00:18:07,130
hey rust can you create the game world

00:18:04,430 --> 00:18:08,840
for me and this will initiate all of the

00:18:07,130 --> 00:18:11,690
or initialize all of the data structures

00:18:08,840 --> 00:18:13,340
the world the players etc and then it

00:18:11,690 --> 00:18:14,960
will just pass back pointers to

00:18:13,340 --> 00:18:17,540
JavaScript side and these are very very

00:18:14,960 --> 00:18:19,190
small and now javascript is going to

00:18:17,540 --> 00:18:22,570
just call functions using these pointers

00:18:19,190 --> 00:18:24,230
and rust will update everything and then

00:18:22,570 --> 00:18:26,800
javascript will be able to just reach

00:18:24,230 --> 00:18:30,800
into the memory and see the result and

00:18:26,800 --> 00:18:32,180
this is nice because javascript has so

00:18:30,800 --> 00:18:34,580
many things that we take for granted

00:18:32,180 --> 00:18:37,280
right access to dom to garbage

00:18:34,580 --> 00:18:38,120
collection like you have objects objects

00:18:37,280 --> 00:18:40,670
are cool

00:18:38,120 --> 00:18:42,260
you have arrays and strings like things

00:18:40,670 --> 00:18:43,700
that you don't feel are very special but

00:18:42,260 --> 00:18:45,160
whenever you don't have them you you

00:18:43,700 --> 00:18:47,600
really miss them

00:18:45,160 --> 00:18:50,360
whereas on rust you have all this nice

00:18:47,600 --> 00:18:52,130
performance and memory management but

00:18:50,360 --> 00:18:55,790
you don't really have objects you have

00:18:52,130 --> 00:18:58,310
like structs and you have arrays and

00:18:55,790 --> 00:19:00,770
vectors and you have two kinds of

00:18:58,310 --> 00:19:04,580
strings for whatever reason rust people

00:19:00,770 --> 00:19:07,820
say they don't I always say they do so

00:19:04,580 --> 00:19:10,580
what we're gonna do is have this shared

00:19:07,820 --> 00:19:12,650
memory between them javascript will call

00:19:10,580 --> 00:19:14,180
into rust rust will update the memory

00:19:12,650 --> 00:19:16,370
and then javascript can read the memory

00:19:14,180 --> 00:19:20,300
so we have this nice cycle flowing bit

00:19:16,370 --> 00:19:22,580
like react maybe and that means that we

00:19:20,300 --> 00:19:24,440
can make sure that we only pass small

00:19:22,580 --> 00:19:27,230
bits of data between the javascript and

00:19:24,440 --> 00:19:30,740
russ side and everything is able to

00:19:27,230 --> 00:19:34,040
actually kind of exist inside of the un8

00:19:30,740 --> 00:19:35,420
arrays but that we still have to on the

00:19:34,040 --> 00:19:38,570
JavaScript side even though we can read

00:19:35,420 --> 00:19:39,770
all those bytes it's still unpleasant we

00:19:38,570 --> 00:19:42,620
have to figure out how to construct

00:19:39,770 --> 00:19:46,040
strings and bullying's and whatnot from

00:19:42,620 --> 00:19:49,010
them but the rust people are aware of

00:19:46,040 --> 00:19:51,560
this and they have built phenomenal

00:19:49,010 --> 00:19:54,320
developer experience so what I've done

00:19:51,560 --> 00:19:58,280
here this is the game of life written in

00:19:54,320 --> 00:20:00,350
rust I have a cell which is an enum a

00:19:58,280 --> 00:20:02,330
cell in the game of life can either be

00:20:00,350 --> 00:20:04,309
dead or it can be alive

00:20:02,330 --> 00:20:06,019
and I'm saying hey rust I want you to

00:20:04,309 --> 00:20:07,730
represent this as a zero and I want you

00:20:06,019 --> 00:20:09,140
to represent this as a one the rest of

00:20:07,730 --> 00:20:10,399
the world should know but I care about

00:20:09,140 --> 00:20:12,019
how that's actually implemented in

00:20:10,399 --> 00:20:16,340
memory because I need that for

00:20:12,019 --> 00:20:18,260
performance or whatever now every tick

00:20:16,340 --> 00:20:19,580
that gets called from JavaScript I'm

00:20:18,260 --> 00:20:22,340
going to iterate through the entire

00:20:19,580 --> 00:20:24,890
board and I'm going to get a list of all

00:20:22,340 --> 00:20:26,330
the neighbors around a cell and I'm

00:20:24,890 --> 00:20:27,380
going to match and you can see this

00:20:26,330 --> 00:20:28,880
pattern matching again where I'm

00:20:27,380 --> 00:20:31,909
matching off of two items which is

00:20:28,880 --> 00:20:33,860
really cool and I can say hey if this

00:20:31,909 --> 00:20:36,019
cell is alive and the number of

00:20:33,860 --> 00:20:38,419
neighbors is less than two then the cell

00:20:36,019 --> 00:20:41,389
should be dead and so on and so forth

00:20:38,419 --> 00:20:42,019
so in this one line right here or this

00:20:41,389 --> 00:20:45,710
one chunk

00:20:42,019 --> 00:20:46,789
I can concisely encode all of the rules

00:20:45,710 --> 00:20:49,240
of the game of life

00:20:46,789 --> 00:20:54,440
it'll be type checked and will be

00:20:49,240 --> 00:20:56,899
immaculately out in memory now what Russ

00:20:54,440 --> 00:20:58,220
is going to do as part of this as an

00:20:56,899 --> 00:21:01,220
automatic part whenever they generates

00:20:58,220 --> 00:21:05,179
the webassembly code it will also

00:21:01,220 --> 00:21:08,149
generate an NPM package so that you on

00:21:05,179 --> 00:21:10,419
the JavaScript side will be able to pull

00:21:08,149 --> 00:21:13,399
in all of those functions and call them

00:21:10,419 --> 00:21:16,159
but knowing that remember that rust is

00:21:13,399 --> 00:21:18,250
statically typed it has intimate

00:21:16,159 --> 00:21:21,730
knowledge of all of the types in your

00:21:18,250 --> 00:21:24,980
application so it will also generate

00:21:21,730 --> 00:21:26,750
typescript bindings but not typescript

00:21:24,980 --> 00:21:28,490
bindings like I would writes where it's

00:21:26,750 --> 00:21:29,990
like oh it's any I'll come back and fix

00:21:28,490 --> 00:21:33,980
this later it writes them as though I

00:21:29,990 --> 00:21:35,840
were a really good programmer so now we

00:21:33,980 --> 00:21:36,950
can come in here and let's take a look

00:21:35,840 --> 00:21:40,370
at what this actually looks like with a

00:21:36,950 --> 00:21:41,960
real application so this is there's a

00:21:40,370 --> 00:21:45,830
component library or there's a library

00:21:41,960 --> 00:21:47,840
called U and U is inspired by Elm except

00:21:45,830 --> 00:21:50,960
that what it's going to do is you will

00:21:47,840 --> 00:21:52,580
have a JSX like syntax you'll have

00:21:50,960 --> 00:21:54,289
service workers that will get spun up in

00:21:52,580 --> 00:21:56,480
the background automatically to handle

00:21:54,289 --> 00:21:58,159
concurrency and Russ is going to

00:21:56,480 --> 00:22:00,679
guarantee that you have data integrity

00:21:58,159 --> 00:22:02,149
no race conditions all throughout the

00:22:00,679 --> 00:22:04,909
entire experience so you just write a

00:22:02,149 --> 00:22:06,380
normal rust application you compile it

00:22:04,909 --> 00:22:09,409
out and you can get all of these

00:22:06,380 --> 00:22:13,100
benefits so this is what it looks like

00:22:09,409 --> 00:22:14,690
to write a component using you so you

00:22:13,100 --> 00:22:15,310
can see I have this HTML with a bang

00:22:14,690 --> 00:22:18,250
this

00:22:15,310 --> 00:22:20,920
is really cool bang means this is a

00:22:18,250 --> 00:22:23,200
macro it's like a babble transform but

00:22:20,920 --> 00:22:25,900
it's built into the language so any

00:22:23,200 --> 00:22:28,810
library author can ship a JSX type of

00:22:25,900 --> 00:22:30,610
thing as part of their library they can

00:22:28,810 --> 00:22:35,380
bring the language into their domain and

00:22:30,610 --> 00:22:37,060
make it much more accessible and so this

00:22:35,380 --> 00:22:39,910
library has actually implemented their

00:22:37,060 --> 00:22:42,580
own HTML macro and all of these props

00:22:39,910 --> 00:22:44,290
here are actually typed so if you pass

00:22:42,580 --> 00:22:47,830
in the wrong type or you have the wrong

00:22:44,290 --> 00:22:49,420
children it won't compile so this is

00:22:47,830 --> 00:22:51,940
like an amazing experience to actually

00:22:49,420 --> 00:22:53,920
write HTML inside of this low-level

00:22:51,940 --> 00:22:57,040
language and have everything typed and

00:22:53,920 --> 00:23:01,450
compiled out nicely but then we have

00:22:57,040 --> 00:23:04,480
maybe events so imagine I have my in my

00:23:01,450 --> 00:23:06,730
core loop of my application I have a

00:23:04,480 --> 00:23:08,110
request so I'm gonna send this off to

00:23:06,730 --> 00:23:08,440
the service workers or they can send it

00:23:08,110 --> 00:23:11,950
to me

00:23:08,440 --> 00:23:15,600
and the response to it should come back

00:23:11,950 --> 00:23:19,450
as a answer what I'm gonna do is

00:23:15,600 --> 00:23:22,030
whenever I receive a signal I'm gonna

00:23:19,450 --> 00:23:24,070
match over that and say hey if the

00:23:22,030 --> 00:23:26,260
signal was a question then pull out the

00:23:24,070 --> 00:23:29,200
body and then send an answer to this

00:23:26,260 --> 00:23:31,320
saying hey that's cool and what this is

00:23:29,200 --> 00:23:33,640
going to do is this won't compile

00:23:31,320 --> 00:23:37,360
because the message might also be a

00:23:33,640 --> 00:23:39,730
response and also if I add for example

00:23:37,360 --> 00:23:43,300
maybe I have a question right now but

00:23:39,730 --> 00:23:45,310
maybe I want to add a demand later then

00:23:43,300 --> 00:23:48,370
if I add that in everywhere that

00:23:45,310 --> 00:23:49,930
reference is that will break and I'll be

00:23:48,370 --> 00:23:53,020
able to go through and fix everything

00:23:49,930 --> 00:23:57,220
once compile it out and it will just

00:23:53,020 --> 00:23:59,710
work now this is what it looks like if

00:23:57,220 --> 00:24:02,500
you're actually consuming the generated

00:23:59,710 --> 00:24:04,780
rust from JavaScript so right here this

00:24:02,500 --> 00:24:06,430
import memory this is the big bit of

00:24:04,780 --> 00:24:09,490
memory that we talked about that the

00:24:06,430 --> 00:24:11,800
rusts compiler generated for us so we're

00:24:09,490 --> 00:24:13,870
gonna pull that in and then we're going

00:24:11,800 --> 00:24:17,200
to initialize it it's just a big array

00:24:13,870 --> 00:24:20,080
of bytes we don't really care but from

00:24:17,200 --> 00:24:23,050
then on we're gonna say hey get the cell

00:24:20,080 --> 00:24:26,890
at this index and if that cell is dead

00:24:23,050 --> 00:24:28,750
then I want you to draw a dead color or

00:24:26,890 --> 00:24:30,850
else use the alive color

00:24:28,750 --> 00:24:34,000
and the thing I love here is this dead

00:24:30,850 --> 00:24:37,450
is actually the enum that we defined in

00:24:34,000 --> 00:24:40,360
rust so we don't care if it was 0 or 1

00:24:37,450 --> 00:24:43,270
or 2 or false or A or B it doesn't

00:24:40,360 --> 00:24:44,770
matter we get to code as though someone

00:24:43,270 --> 00:24:46,630
were a really good programmer on the

00:24:44,770 --> 00:24:50,559
other side and they gave us this really

00:24:46,630 --> 00:24:52,480
good API and that's all generated based

00:24:50,559 --> 00:24:55,390
off of the deep knowledge that rust has

00:24:52,480 --> 00:24:58,630
about your program I'll give a quick

00:24:55,390 --> 00:25:00,549
aside about the syntax I mentioned

00:24:58,630 --> 00:25:04,240
before that you know rust is a bit more

00:25:00,549 --> 00:25:09,220
verbose but it is also very heavy with

00:25:04,240 --> 00:25:11,789
symbols so just be prepared but the nice

00:25:09,220 --> 00:25:14,500
thing is they care so much about

00:25:11,789 --> 00:25:16,000
developer experience and onboarding that

00:25:14,500 --> 00:25:18,580
the error messages will oftentimes

00:25:16,000 --> 00:25:20,679
navigate you out so for example here I

00:25:18,580 --> 00:25:24,130
have foo it takes a B which I said is

00:25:20,679 --> 00:25:25,360
immutable unsigned 64-bit value and

00:25:24,130 --> 00:25:28,620
being very specific about what I want

00:25:25,360 --> 00:25:31,570
here and it's like hey you are trying to

00:25:28,620 --> 00:25:33,309
borrow a mutable value you can't do that

00:25:31,570 --> 00:25:35,950
maybe you should try just removing the

00:25:33,309 --> 00:25:38,169
an mutable and what happens is it guides

00:25:35,950 --> 00:25:39,370
you out of this problem enough times

00:25:38,169 --> 00:25:41,679
that you start to develop kind of a

00:25:39,370 --> 00:25:45,309
muscle memory about what is this symbol

00:25:41,679 --> 00:25:48,789
actually doing so I want to give one

00:25:45,309 --> 00:25:51,159
demo of what this actually looks like so

00:25:48,789 --> 00:25:56,200
this is an NES emulator written in rust

00:25:51,159 --> 00:26:00,340
and it is super fast super cool if we

00:25:56,200 --> 00:26:06,850
open up the developer tools and we take

00:26:00,340 --> 00:26:09,659
a profile you can see that the animation

00:26:06,850 --> 00:26:12,520
or sorry each of these frames is tiny

00:26:09,659 --> 00:26:13,630
it's incredibly performant it's very

00:26:12,520 --> 00:26:15,820
good on my battery it's in fact been

00:26:13,630 --> 00:26:19,470
running in the background for quite a

00:26:15,820 --> 00:26:22,090
while and my battery is still doing fine

00:26:19,470 --> 00:26:24,600
but the cool thing is with Russ you can

00:26:22,090 --> 00:26:27,640
also compile out that same application

00:26:24,600 --> 00:26:30,809
to a native application so this is it

00:26:27,640 --> 00:26:33,370
running using SDL instead of WebGL and

00:26:30,809 --> 00:26:35,740
this is Super Mario Brothers using the

00:26:33,370 --> 00:26:39,880
same code that's type checked and you

00:26:35,740 --> 00:26:41,530
can run this on a desktop or a mobile or

00:26:39,880 --> 00:26:42,220
you can compile to the web as we saw

00:26:41,530 --> 00:26:45,970
with the other

00:26:42,220 --> 00:26:47,620
example and then there are some pretty

00:26:45,970 --> 00:26:50,770
other crazy things that are happening so

00:26:47,620 --> 00:26:53,409
in particular this idea of webassembly

00:26:50,770 --> 00:26:55,659
like I said is crazy well-designed

00:26:53,409 --> 00:26:58,480
and someone has actually implemented a

00:26:55,659 --> 00:27:00,970
web assembly to rusts compiler so kind

00:26:58,480 --> 00:27:02,799
of like a D compiler and someone

00:27:00,970 --> 00:27:04,179
actually there's a subset of typescript

00:27:02,799 --> 00:27:05,740
called assembly script which is how a

00:27:04,179 --> 00:27:08,110
typescript people go to web assembly

00:27:05,740 --> 00:27:11,140
it's kind of the non allocating subset

00:27:08,110 --> 00:27:12,820
of typescript and someone wrote a really

00:27:11,140 --> 00:27:14,650
cool Gameboy emulator in that and they

00:27:12,820 --> 00:27:18,429
compile it out to webassembly fast and

00:27:14,650 --> 00:27:20,830
cool but then someone took the web

00:27:18,429 --> 00:27:22,900
assembly to rusty compiler turn that

00:27:20,830 --> 00:27:24,429
into rust and then they took the rust

00:27:22,900 --> 00:27:27,010
code and compile it out to a native

00:27:24,429 --> 00:27:29,470
application so it's kind of a crazy

00:27:27,010 --> 00:27:31,870
pipeline but like the future seems very

00:27:29,470 --> 00:27:34,360
exciting I'm gonna end on this note that

00:27:31,870 --> 00:27:37,870
I think that we are actually rust and

00:27:34,360 --> 00:27:41,200
webassembly represent a unprecedented

00:27:37,870 --> 00:27:43,150
opportunity in our industry because our

00:27:41,200 --> 00:27:46,059
industry only moves forward via

00:27:43,150 --> 00:27:48,010
secretion if there is any abstraction or

00:27:46,059 --> 00:27:51,850
any implementation that is even a little

00:27:48,010 --> 00:27:54,690
bit successful it never dies to that

00:27:51,850 --> 00:27:58,510
point I have a terminal in my computer a

00:27:54,690 --> 00:28:02,289
terminal is a end point like a keyboard

00:27:58,510 --> 00:28:04,179
that talks to a mainframe right and my

00:28:02,289 --> 00:28:06,190
terminal understands crazy old escape

00:28:04,179 --> 00:28:08,740
codes but that can never go away

00:28:06,190 --> 00:28:12,220
we are stuck with it forever and we're

00:28:08,740 --> 00:28:15,850
also stuck with like Lib C and Lipsy has

00:28:12,220 --> 00:28:18,220
caused unprecedented amount of good but

00:28:15,850 --> 00:28:19,630
also tons of security issues it has been

00:28:18,220 --> 00:28:22,690
very difficult to actually ship anything

00:28:19,630 --> 00:28:24,690
reliably with it and webassembly and

00:28:22,690 --> 00:28:28,299
rusts mean that we actually have a

00:28:24,690 --> 00:28:30,100
platform that it's not it's not in our

00:28:28,299 --> 00:28:32,740
best interest to ship all of linux all

00:28:30,100 --> 00:28:35,020
of Lib C to the browser we need to have

00:28:32,740 --> 00:28:36,820
a new smaller implementation of these

00:28:35,020 --> 00:28:39,340
things and maybe we can do it in a safe

00:28:36,820 --> 00:28:42,820
language that's also fast and also

00:28:39,340 --> 00:28:44,169
correct and that could be rust and I

00:28:42,820 --> 00:28:47,860
actually think that in the next five to

00:28:44,169 --> 00:28:52,630
ten years most of the JavaScript that we

00:28:47,860 --> 00:28:55,090
run will be written in rust I don't

00:28:52,630 --> 00:28:56,020
think most people will write rust but I

00:28:55,090 --> 00:29:00,070
think that

00:28:56,020 --> 00:29:01,840
most of the code we run will be like who

00:29:00,070 --> 00:29:03,790
will actually write it it's the people

00:29:01,840 --> 00:29:05,950
who really want fine-grain performance

00:29:03,790 --> 00:29:08,250
control and the people who want safety

00:29:05,950 --> 00:29:11,500
security and correctness guarantees and

00:29:08,250 --> 00:29:16,360
this is largely library authors right

00:29:11,500 --> 00:29:18,640
how like to what extent does the react

00:29:16,360 --> 00:29:20,620
authors or view or angular have to go

00:29:18,640 --> 00:29:23,470
through to eke out all the performance

00:29:20,620 --> 00:29:24,910
and correctness and so they're under

00:29:23,470 --> 00:29:26,710
tremendous pressures to actually do this

00:29:24,910 --> 00:29:29,410
and they need tooling that helps them

00:29:26,710 --> 00:29:31,600
and I think that's likely rust and

00:29:29,410 --> 00:29:34,360
actually think that web assembly and

00:29:31,600 --> 00:29:37,390
rust will also end up going to node

00:29:34,360 --> 00:29:39,460
where you can actually pull in all of

00:29:37,390 --> 00:29:41,620
these implementations of great rust

00:29:39,460 --> 00:29:43,540
libraries they're already compiled out

00:29:41,620 --> 00:29:46,300
to web assembly and it will just work

00:29:43,540 --> 00:29:50,020
inside of node no more lives sass

00:29:46,300 --> 00:29:52,990
compiling C++ nightmare so here's my

00:29:50,020 --> 00:29:55,090
closing pitch working with rusts at

00:29:52,990 --> 00:29:57,940
least in the beginning is like banging

00:29:55,090 --> 00:30:00,790
your head against the wall but at a very

00:29:57,940 --> 00:30:02,140
slight angle so that every time you hit

00:30:00,790 --> 00:30:05,470
the wall you actually make a little bit

00:30:02,140 --> 00:30:07,300
of progress and at the end you actually

00:30:05,470 --> 00:30:09,430
look back at this blood-stained wall and

00:30:07,300 --> 00:30:12,810
you're kind of happy because you built a

00:30:09,430 --> 00:30:15,310
thing that you didn't think was possible

00:30:12,810 --> 00:30:17,380
all right here are some links but

00:30:15,310 --> 00:30:18,660
otherwise thank you

00:30:17,380 --> 00:30:21,929
[Applause]

00:30:18,660 --> 00:30:21,929

YouTube URL: https://www.youtube.com/watch?v=teDOE7zcf_g


