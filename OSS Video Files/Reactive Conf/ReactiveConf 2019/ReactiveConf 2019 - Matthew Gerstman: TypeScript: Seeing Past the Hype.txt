Title: ReactiveConf 2019 - Matthew Gerstman: TypeScript: Seeing Past the Hype
Publication date: 2019-10-30
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Millennium stage
-------------------------------------------------------------------
Typescript is in full hype mode right now. Twitter gives us a new hot take daily, but most of us haven’t seen the long term benefits. Dropbox switched to Typescript in 2015 and we’ve seen the good, the bad, and the ugly. In this talk we’ll take a step back from the hype and cover what we’ve learned over the past four years. We’ll discuss how static typing has helped us scale a codebase, and when it’s worth it just to write an any and move on with your life.
Captions: 
	00:00:02,750 --> 00:00:11,850
[Music]

00:00:16,160 --> 00:00:23,039
hi everyone I am Matthew Gerstmann and

00:00:19,740 --> 00:00:25,500
today we are going to discuss typescript

00:00:23,039 --> 00:00:27,390
and I realized this talk kind of sounds

00:00:25,500 --> 00:00:28,920
like I'm about to go on an indictment of

00:00:27,390 --> 00:00:31,320
typescript but actually I love

00:00:28,920 --> 00:00:32,550
typescript I adore typescript I just

00:00:31,320 --> 00:00:34,860
want to kind of talk about it

00:00:32,550 --> 00:00:35,820
holistically to convince you that it is

00:00:34,860 --> 00:00:38,580
worth your time

00:00:35,820 --> 00:00:40,379
so whoo my my name is Mathew Kurtzman I

00:00:38,580 --> 00:00:42,420
am a software engineer Dropbox I live

00:00:40,379 --> 00:00:44,309
and work in New York you can find me on

00:00:42,420 --> 00:00:45,899
Twitter and for some reason people think

00:00:44,309 --> 00:00:47,219
following me on Twitter is a good idea

00:00:45,899 --> 00:00:50,010
so I'm gonna tell you why that's a bad

00:00:47,219 --> 00:00:52,890
idea first of all I tweet a lot about

00:00:50,010 --> 00:00:54,390
Taylor Swift this is me whenever I go on

00:00:52,890 --> 00:00:56,149
a bad date

00:00:54,390 --> 00:00:59,399
I also tweet a lot about Harry Potter

00:00:56,149 --> 00:01:02,820
this is a replica of me as a teenager

00:00:59,399 --> 00:01:04,680
just very angsty and finally I wrote a

00:01:02,820 --> 00:01:06,930
book on how to buy Broadway tickets and

00:01:04,680 --> 00:01:08,880
that is my shameless plug so thank you

00:01:06,930 --> 00:01:11,670
for indulging me let's go to typescript

00:01:08,880 --> 00:01:13,470
now so the reason I put this talk

00:01:11,670 --> 00:01:16,700
together was at the beginning of the

00:01:13,470 --> 00:01:19,439
year I noticed a lot of Twitter like

00:01:16,700 --> 00:01:21,330
Twitter chatter about typescript people

00:01:19,439 --> 00:01:22,860
were really really excited about type

00:01:21,330 --> 00:01:24,060
scratch people were saying that their

00:01:22,860 --> 00:01:26,310
new year's resolutions were to learn

00:01:24,060 --> 00:01:27,689
typescript and someone was like hey it's

00:01:26,310 --> 00:01:30,140
been two weeks we should all be experts

00:01:27,689 --> 00:01:33,119
by now right cuz that's how tech works

00:01:30,140 --> 00:01:33,930
and then someone's like I'm gonna try to

00:01:33,119 --> 00:01:35,729
embrace it

00:01:33,930 --> 00:01:37,560
I really appreciated how Jane Wong

00:01:35,729 --> 00:01:39,509
stepped in and was just like why is

00:01:37,560 --> 00:01:41,369
everyone saying this this kind of came

00:01:39,509 --> 00:01:43,799
out of nowhere and it wasn't just

00:01:41,369 --> 00:01:46,950
Twitter right it was Korra and read it

00:01:43,799 --> 00:01:48,750
and like medium and just anywhere you

00:01:46,950 --> 00:01:50,790
could find you could write an opinion

00:01:48,750 --> 00:01:54,240
someone was writing about typescript

00:01:50,790 --> 00:01:56,939
but this actually isn't new at all this

00:01:54,240 --> 00:01:59,280
is the Google trend for typescript

00:01:56,939 --> 00:02:03,060
interest over the past seven years

00:01:59,280 --> 00:02:05,579
so since 2013 and you'll see it's been

00:02:03,060 --> 00:02:08,780
steadily increasing in popularity since

00:02:05,579 --> 00:02:10,979
then so this isn't really new and

00:02:08,780 --> 00:02:12,959
something I've seen a lot of is people

00:02:10,979 --> 00:02:14,250
like to compare typescript to

00:02:12,959 --> 00:02:16,620
CoffeeScript because they're both

00:02:14,250 --> 00:02:18,390
popular languages that add some

00:02:16,620 --> 00:02:21,320
fundamental new thing to the language

00:02:18,390 --> 00:02:23,459
that compile down to JavaScript but

00:02:21,320 --> 00:02:25,120
CoffeeScript was three years old when it

00:02:23,459 --> 00:02:27,310
died whereas typescript is turning

00:02:25,120 --> 00:02:29,489
seven soon so I don't think we can

00:02:27,310 --> 00:02:31,840
meaningfully compare them anymore and

00:02:29,489 --> 00:02:33,819
CoffeeScript I know a lot of people like

00:02:31,840 --> 00:02:35,500
to talk about it and like poorly now

00:02:33,819 --> 00:02:37,330
that because it's just legacy code but

00:02:35,500 --> 00:02:39,099
that's what gave us promises that's what

00:02:37,330 --> 00:02:42,209
gave us and lambda as it gave us a lot

00:02:39,099 --> 00:02:45,099
of really interesting things at the time

00:02:42,209 --> 00:02:47,260
so today I want to get past the hype and

00:02:45,099 --> 00:02:49,750
the reason for that is I think when we

00:02:47,260 --> 00:02:52,530
are talking about our tools we spend way

00:02:49,750 --> 00:02:54,849
too much time looking like this and

00:02:52,530 --> 00:02:57,010
instead we should really be looking like

00:02:54,849 --> 00:03:04,720
this why do I have any Futurama fans

00:02:57,010 --> 00:03:06,730
here yeah sweet cool I will not so we're

00:03:04,720 --> 00:03:08,079
gonna go into the ugly parts and then

00:03:06,730 --> 00:03:10,180
we're gonna talk about why I think you

00:03:08,079 --> 00:03:11,739
should use it anyway because I want to

00:03:10,180 --> 00:03:13,870
convince you that this is a tool worth

00:03:11,739 --> 00:03:15,970
using and learning and frankly that's

00:03:13,870 --> 00:03:18,069
not gonna happen if we don't talk about

00:03:15,970 --> 00:03:22,030
like the bad parts of it so let's take

00:03:18,069 --> 00:03:25,569
ten steps back first what is a type well

00:03:22,030 --> 00:03:27,489
a type is an attribute of data that

00:03:25,569 --> 00:03:29,769
tells the computer how the programmer

00:03:27,489 --> 00:03:30,940
intends to use it and even if you don't

00:03:29,769 --> 00:03:32,650
work in typescript you're probably

00:03:30,940 --> 00:03:34,569
familiar with some basic types in

00:03:32,650 --> 00:03:37,349
JavaScript we have boolean which are

00:03:34,569 --> 00:03:40,690
true or false we have numbers so one

00:03:37,349 --> 00:03:42,549
73.5 whatever it is we have strings

00:03:40,690 --> 00:03:44,260
which are you know groups of characters

00:03:42,549 --> 00:03:46,900
it could be the entire text of Harry

00:03:44,260 --> 00:03:48,250
Potter which I would put in a string we

00:03:46,900 --> 00:03:49,780
also have arrays which are lists of

00:03:48,250 --> 00:03:51,669
things and we have objects which are

00:03:49,780 --> 00:03:53,530
maps these are all types that I hope

00:03:51,669 --> 00:03:55,510
you're familiar with we also have some

00:03:53,530 --> 00:03:56,980
falsey types right you've probably most

00:03:55,510 --> 00:03:58,569
of you have dealt with something with

00:03:56,980 --> 00:04:00,760
null or undefined being different and

00:03:58,569 --> 00:04:02,470
that typescript decided hey let's make

00:04:00,760 --> 00:04:04,690
this a little more confusing and add

00:04:02,470 --> 00:04:07,199
never and void which we're not really

00:04:04,690 --> 00:04:10,329
gonna cover today but know they exist

00:04:07,199 --> 00:04:12,699
types can also be derived from other

00:04:10,329 --> 00:04:14,500
types so we can do things like say the

00:04:12,699 --> 00:04:16,870
type of this is only one of these

00:04:14,500 --> 00:04:18,549
specific strings like it's an enum or we

00:04:16,870 --> 00:04:21,910
could say it's an object of this shape

00:04:18,549 --> 00:04:24,340
and the final thing I need you to know

00:04:21,910 --> 00:04:26,740
about for price type script types is any

00:04:24,340 --> 00:04:29,410
and what any is is it's an escape hatch

00:04:26,740 --> 00:04:30,910
it basically says hey typescript you

00:04:29,410 --> 00:04:32,260
don't know how to type this or I don't

00:04:30,910 --> 00:04:33,760
know how to type this but either way I

00:04:32,260 --> 00:04:36,190
really don't want you to do anything

00:04:33,760 --> 00:04:37,270
here so just trust me I'm a doctor

00:04:36,190 --> 00:04:41,569
I got

00:04:37,270 --> 00:04:44,240
so what exactly is typescript well type

00:04:41,569 --> 00:04:46,580
strip script is a strict superset of

00:04:44,240 --> 00:04:48,199
JavaScript strict might need a little

00:04:46,580 --> 00:04:50,210
asterisk now because someone came up

00:04:48,199 --> 00:04:52,039
with a nifty little counter example but

00:04:50,210 --> 00:04:55,069
let's go with it's a superset of

00:04:52,039 --> 00:04:57,259
JavaScript and it looks like this in

00:04:55,069 --> 00:04:58,789
fact if you look at this code the only

00:04:57,259 --> 00:05:01,159
thing that makes this different from

00:04:58,789 --> 00:05:03,139
traditional JavaScript are these type

00:05:01,159 --> 00:05:05,840
annotations right here these strings and

00:05:03,139 --> 00:05:11,180
boolean x' so i have a function that

00:05:05,840 --> 00:05:13,280
takes a string and if i run this code in

00:05:11,180 --> 00:05:16,069
my editor or if i compile it using

00:05:13,280 --> 00:05:18,169
typescript it will work just fine when i

00:05:16,069 --> 00:05:19,970
pass it a string but if i pass it a

00:05:18,169 --> 00:05:21,680
boolean it's gonna fail

00:05:19,970 --> 00:05:23,539
by the way gryffindor is for people who

00:05:21,680 --> 00:05:27,050
peaked in high school I'm very strong

00:05:23,539 --> 00:05:31,430
opinions typescript is also smart like

00:05:27,050 --> 00:05:33,770
really really smart so we have these Dom

00:05:31,430 --> 00:05:36,800
functions document get elements by tag

00:05:33,770 --> 00:05:39,440
name and we need to pass it different

00:05:36,800 --> 00:05:41,270
strings and return different types of

00:05:39,440 --> 00:05:43,849
elements based on what type of string we

00:05:41,270 --> 00:05:45,949
pass right because eight tags have href

00:05:43,849 --> 00:05:47,750
swear as divs don't and P tags have

00:05:45,949 --> 00:05:49,819
their own attributes so we want to

00:05:47,750 --> 00:05:51,949
return a completely different type based

00:05:49,819 --> 00:05:54,009
on what string is passed to this

00:05:51,949 --> 00:05:54,009
function

00:05:54,190 --> 00:05:59,090
typescript also makes big refractors

00:05:57,080 --> 00:06:04,969
really easy and that's where i'm gonna

00:05:59,090 --> 00:06:09,669
show you some of it so let me let me

00:06:04,969 --> 00:06:09,669
switch into let me do mirror for you

00:06:14,910 --> 00:06:20,800
cool so I have this code here and you

00:06:19,510 --> 00:06:23,490
can see I have a list of slytherins I

00:06:20,800 --> 00:06:25,990
said I was a big Harry Potter fan and in

00:06:23,490 --> 00:06:27,580
what we're doing is we have Taylor Swift

00:06:25,990 --> 00:06:29,470
who I've already told you I love we have

00:06:27,580 --> 00:06:30,940
lin-manuel Miranda who wrote Hamilton

00:06:29,470 --> 00:06:32,650
which is a great musical and we have

00:06:30,940 --> 00:06:37,990
Severus Snape he was kind of a pain but

00:06:32,650 --> 00:06:39,340
he's famous thank you and let's say we

00:06:37,990 --> 00:06:42,370
want to add a prop we want to add a

00:06:39,340 --> 00:06:45,790
points prop so we're gonna we're gonna

00:06:42,370 --> 00:06:48,370
put points here and we are going to type

00:06:45,790 --> 00:06:50,620
that out and this is super cool VIU's

00:06:48,370 --> 00:06:52,840
code immediately picks up that it can't

00:06:50,620 --> 00:06:54,760
find this variable name which it could

00:06:52,840 --> 00:06:56,020
probably do in traditional JavaScript I

00:06:54,760 --> 00:06:57,760
don't know we'll ask Brian afterwards

00:06:56,020 --> 00:06:59,800
but that's not really typescript

00:06:57,760 --> 00:07:02,230
specific so let's let's add it to our

00:06:59,800 --> 00:07:04,510
function signature now this is where we

00:07:02,230 --> 00:07:07,540
have an actual typescript error property

00:07:04,510 --> 00:07:10,600
points does not exist on type props with

00:07:07,540 --> 00:07:12,280
children's slow their improv mm/s is

00:07:10,600 --> 00:07:13,570
that you have to learn how to read but

00:07:12,280 --> 00:07:15,040
what this is effectively saying is

00:07:13,570 --> 00:07:18,250
slithering props which is right over

00:07:15,040 --> 00:07:19,360
here does not contain points and this is

00:07:18,250 --> 00:07:22,030
probably the coolest thing about

00:07:19,360 --> 00:07:24,520
typescript in my opinion if I add this

00:07:22,030 --> 00:07:27,460
prop you can see the second I type a P

00:07:24,520 --> 00:07:29,590
or any letter it lit up at the bottom

00:07:27,460 --> 00:07:32,560
with this red and the error message here

00:07:29,590 --> 00:07:35,890
is that we are missing the property

00:07:32,560 --> 00:07:37,540
points on all of these components and if

00:07:35,890 --> 00:07:39,580
you consider these are all in this file

00:07:37,540 --> 00:07:41,080
but imagine if I had my component

00:07:39,580 --> 00:07:43,600
library on one side of my application

00:07:41,080 --> 00:07:45,370
and there you see your their usages on

00:07:43,600 --> 00:07:47,080
the other you will catch these things

00:07:45,370 --> 00:07:47,920
very very quickly so let's give out some

00:07:47,080 --> 00:07:50,890
points shall we

00:07:47,920 --> 00:07:52,840
so Taylor Swift currently really just

00:07:50,890 --> 00:07:54,460
had a great album I'm very proud of her

00:07:52,840 --> 00:07:56,800
so we're gonna give her a whole bunch of

00:07:54,460 --> 00:07:58,480
points wind Manuel Miranda is literally

00:07:56,800 --> 00:08:01,150
printing money at the moment so he can

00:07:58,480 --> 00:08:04,890
have more and I don't like Snape so he

00:08:01,150 --> 00:08:07,780
can have negative three points cool and

00:08:04,890 --> 00:08:08,920
by the way if you were curious if you

00:08:07,780 --> 00:08:10,690
want to know what happens when you take

00:08:08,920 --> 00:08:13,180
this stupid little example and turn it

00:08:10,690 --> 00:08:15,520
into a fully fledged website you end up

00:08:13,180 --> 00:08:18,280
building this Slytherin dev which I did

00:08:15,520 --> 00:08:19,690
for another talk for fun fun fact Brian

00:08:18,280 --> 00:08:21,610
is not mentioned here because he has a

00:08:19,690 --> 00:08:22,420
ravenclaw but his wife Nicki who is

00:08:21,610 --> 00:08:25,270
present is there

00:08:22,420 --> 00:08:26,770
and also Miko one of our other great

00:08:25,270 --> 00:08:28,840
speakers is on here as well because she

00:08:26,770 --> 00:08:31,030
is a Slytherin so that's just fun and I

00:08:28,840 --> 00:08:34,650
wanted to share that now let's talk

00:08:31,030 --> 00:08:37,030
about vanilla JavaScript right so

00:08:34,650 --> 00:08:40,210
typescript claims to be incremental and

00:08:37,030 --> 00:08:42,070
it is especially at first so if I want

00:08:40,210 --> 00:08:45,370
to make a string muggle Vernon Dursley

00:08:42,070 --> 00:08:51,490
or just Dursley and if I want to do

00:08:45,370 --> 00:08:54,490
yelling muggle o Const yelling muggle

00:08:51,490 --> 00:08:56,770
equals muggle you'll see I immediately

00:08:54,490 --> 00:08:58,810
get da completion on every function

00:08:56,770 --> 00:09:00,730
that's on this string because I'm using

00:08:58,810 --> 00:09:01,960
typescript that's that's the kind of

00:09:00,730 --> 00:09:03,730
thing that you don't have right away so

00:09:01,960 --> 00:09:05,350
let's let's call to uppercase which is

00:09:03,730 --> 00:09:07,180
great and let's say I want to get a

00:09:05,350 --> 00:09:09,280
subset of this string right I want to

00:09:07,180 --> 00:09:14,860
call slice but let's say I make a type

00:09:09,280 --> 00:09:17,380
out I type splice well it gives me the

00:09:14,860 --> 00:09:20,160
great error property splice does not

00:09:17,380 --> 00:09:23,560
exist on type string did you mean slice

00:09:20,160 --> 00:09:25,720
and that's the kind of thing that just

00:09:23,560 --> 00:09:27,550
like we is amazing that when you get to

00:09:25,720 --> 00:09:29,080
start taking it for granted because I

00:09:27,550 --> 00:09:31,090
could have easily made this typo right

00:09:29,080 --> 00:09:33,040
and then that would have appeared in my

00:09:31,090 --> 00:09:36,100
browser as opposed to in my editor or

00:09:33,040 --> 00:09:37,600
even if I'm lucky my terminal so we've

00:09:36,100 --> 00:09:38,770
got that but these are just strings

00:09:37,600 --> 00:09:40,690
right let's do something a little more

00:09:38,770 --> 00:09:43,060
complicated let's make a wizard so we've

00:09:40,690 --> 00:09:47,350
a wizard and we want to do wizard name

00:09:43,060 --> 00:09:48,700
equals Harry Potter well this is

00:09:47,350 --> 00:09:50,620
interesting this is totally valid

00:09:48,700 --> 00:09:53,020
JavaScript this time and it says

00:09:50,620 --> 00:09:54,930
property name does not exist on type

00:09:53,020 --> 00:09:57,340
empty object that's a little obnoxious

00:09:54,930 --> 00:09:59,260
okay so let's let's fix that so let's

00:09:57,340 --> 00:10:01,780
make a type it's like a wizard type and

00:09:59,260 --> 00:10:05,740
wizards have names so we'll do that and

00:10:01,780 --> 00:10:07,540
we will add the type annotation and now

00:10:05,740 --> 00:10:10,270
we get a new error now it's saying

00:10:07,540 --> 00:10:12,670
property name is missing on type empty

00:10:10,270 --> 00:10:14,500
object but required in type wizards so

00:10:12,670 --> 00:10:17,260
okay so we have to do it this way we put

00:10:14,500 --> 00:10:19,480
the name in the thing and even though

00:10:17,260 --> 00:10:21,580
every example you just saw was totally

00:10:19,480 --> 00:10:24,040
valid JavaScript typescript is making us

00:10:21,580 --> 00:10:26,710
do it this way just because it needs to

00:10:24,040 --> 00:10:28,270
infer these types let's look at another

00:10:26,710 --> 00:10:31,600
example how many of you use lodash

00:10:28,270 --> 00:10:33,460
either willingly or grudgingly yeah

00:10:31,600 --> 00:10:34,830
everyone most people use lodash for

00:10:33,460 --> 00:10:39,089
something right so

00:10:34,830 --> 00:10:41,220
we import lodash and we get the same

00:10:39,089 --> 00:10:43,589
super cool dock completion on lodash

00:10:41,220 --> 00:10:45,120
which is an external library and I think

00:10:43,589 --> 00:10:47,100
lodash is a particularly cool example

00:10:45,120 --> 00:10:49,230
because of how powerful the types are

00:10:47,100 --> 00:10:51,029
here so you'll see right now it thinks

00:10:49,230 --> 00:10:53,310
that I might want to pass a collection

00:10:51,029 --> 00:10:55,680
of strings to this but the second I give

00:10:53,310 --> 00:10:57,269
it an array it's gonna assume that it is

00:10:55,680 --> 00:10:59,610
something or a like and it could be

00:10:57,269 --> 00:11:02,640
anything and when I start typing numbers

00:10:59,610 --> 00:11:04,649
it knows that it's a number and if I

00:11:02,640 --> 00:11:07,649
type string it knows that it's a string

00:11:04,649 --> 00:11:11,190
or a number so not only that but in my

00:11:07,649 --> 00:11:13,140
predicate it knows that value is of type

00:11:11,190 --> 00:11:14,910
number so if I had slice to this it's

00:11:13,140 --> 00:11:16,380
gonna say it doesn't exist on number so

00:11:14,910 --> 00:11:29,339
let's just make this work for values

00:11:16,380 --> 00:11:30,810
greater than ten cool sweet by the way

00:11:29,339 --> 00:11:33,990
so why not that was the thing I showed

00:11:30,810 --> 00:11:36,000
you so one of the takeaways I want you

00:11:33,990 --> 00:11:38,940
to have is that typescript is gonna get

00:11:36,000 --> 00:11:39,959
in your way for the first few months how

00:11:38,940 --> 00:11:42,170
many of you have used one of these

00:11:39,959 --> 00:11:44,100
functions lodash get or low dash dot set

00:11:42,170 --> 00:11:45,690
yeah they're kind of becoming less

00:11:44,100 --> 00:11:47,610
popular especially as optional chaining

00:11:45,690 --> 00:11:49,829
is a thing but these are virtually

00:11:47,610 --> 00:11:51,930
impossible to type getting the type so

00:11:49,829 --> 00:11:54,360
these allow you to arbitrarily drill

00:11:51,930 --> 00:11:55,950
into an object via a string and just

00:11:54,360 --> 00:11:57,360
kind of do something there and it's

00:11:55,950 --> 00:11:59,550
really hard to get that right in

00:11:57,360 --> 00:12:00,649
typescript and it's we're just gonna

00:11:59,550 --> 00:12:03,089
kind of give up that tool

00:12:00,649 --> 00:12:05,490
what about tests right like we have to

00:12:03,089 --> 00:12:07,320
write tests tests are gonna require very

00:12:05,490 --> 00:12:09,000
well mock data or you're gonna be using

00:12:07,320 --> 00:12:10,800
lots of any's what if you want to test

00:12:09,000 --> 00:12:12,300
the absence of a prop on a component

00:12:10,800 --> 00:12:13,920
especially if you're writing a library

00:12:12,300 --> 00:12:15,360
like where you don't know how your

00:12:13,920 --> 00:12:17,130
consumers are gonna use it or if they're

00:12:15,360 --> 00:12:18,680
gonna be using typescript you're you're

00:12:17,130 --> 00:12:21,029
gonna have to start throwing in any's

00:12:18,680 --> 00:12:23,160
what a lot of things come down to is

00:12:21,029 --> 00:12:26,399
advanced JavaScript ends up translating

00:12:23,160 --> 00:12:27,899
to advanced typescript an example I love

00:12:26,399 --> 00:12:29,010
to give our higher-order components how

00:12:27,899 --> 00:12:31,800
many of you are still using higher-order

00:12:29,010 --> 00:12:33,149
components yeah it's like they're

00:12:31,800 --> 00:12:35,310
they're not as popular as they used to

00:12:33,149 --> 00:12:37,170
be but they are one of the most

00:12:35,310 --> 00:12:39,750
interesting type cases I think because

00:12:37,170 --> 00:12:43,079
we have a wrapped component which is

00:12:39,750 --> 00:12:45,149
inside of the hoc it's receiving props

00:12:43,079 --> 00:12:46,070
from it and then it also needs to

00:12:45,149 --> 00:12:48,320
receive

00:12:46,070 --> 00:12:50,030
regular props from the outside which may

00:12:48,320 --> 00:12:52,580
or may not need to be read by the HSE

00:12:50,030 --> 00:12:55,040
and just to make this more complicated

00:12:52,580 --> 00:12:56,990
the rap component internally needs to be

00:12:55,040 --> 00:13:00,110
able to receive all the props it knew

00:12:56,990 --> 00:13:02,960
about and then also the hoc props this

00:13:00,110 --> 00:13:04,610
is really really hard to type you need

00:13:02,960 --> 00:13:06,140
to know about generics you need to know

00:13:04,610 --> 00:13:08,840
about intersections you need to know

00:13:06,140 --> 00:13:10,220
about discriminated unions and I don't

00:13:08,840 --> 00:13:12,320
expect you to know any of those things

00:13:10,220 --> 00:13:13,640
today you just want Dock completion on

00:13:12,320 --> 00:13:16,610
your strings like that's what you want

00:13:13,640 --> 00:13:18,110
early on so if you're interested I wrote

00:13:16,610 --> 00:13:20,030
a blog post you can check that out on

00:13:18,110 --> 00:13:22,340
how to type a higher-order component it

00:13:20,030 --> 00:13:23,900
took me 2 weeks in 2017 because there

00:13:22,340 --> 00:13:26,990
wasn't a lot of documentation back that

00:13:23,900 --> 00:13:29,000
and the other thing is typescript is not

00:13:26,990 --> 00:13:31,820
sound so what do I mean by sound

00:13:29,000 --> 00:13:33,770
well soundness implies that we can know

00:13:31,820 --> 00:13:35,630
at compile time that our code is safe to

00:13:33,770 --> 00:13:38,300
run and if it doesn't have that property

00:13:35,630 --> 00:13:40,390
it's considered not sound and the reason

00:13:38,300 --> 00:13:43,100
for this is anyone can put in any

00:13:40,390 --> 00:13:45,170
anywhere on your code base and remember

00:13:43,100 --> 00:13:46,760
how I said any is just like I trust me

00:13:45,170 --> 00:13:48,620
trust me I'm a doctor it's an escape

00:13:46,760 --> 00:13:56,030
hatch it's actually a little more like

00:13:48,620 --> 00:13:57,980
this glad I got something cool anyway so

00:13:56,030 --> 00:14:01,190
a great example of something that's very

00:13:57,980 --> 00:14:03,650
hard to type is react context so we have

00:14:01,190 --> 00:14:06,650
a provider and a consumer and this magic

00:14:03,650 --> 00:14:09,050
data flow in the middle and we can't

00:14:06,650 --> 00:14:10,970
really type that magic data flow we

00:14:09,050 --> 00:14:12,920
can't we can trust that reactant to do

00:14:10,970 --> 00:14:14,870
the right thing but the best we can do

00:14:12,920 --> 00:14:16,600
is pin the type on the provider and on

00:14:14,870 --> 00:14:19,160
the consumer and hope for the best

00:14:16,600 --> 00:14:20,930
react Redux takes this problem to the

00:14:19,160 --> 00:14:22,610
next level we have to deal with context

00:14:20,930 --> 00:14:24,260
and then we have thunks which are

00:14:22,610 --> 00:14:25,880
functions returning functions and

00:14:24,260 --> 00:14:27,740
inferring what each of those levels

00:14:25,880 --> 00:14:29,600
return and then when we're dispatching

00:14:27,740 --> 00:14:32,120
with middleware we're doing all this

00:14:29,600 --> 00:14:34,940
complicated typing and it just starts to

00:14:32,120 --> 00:14:36,980
get really challenging and all of this

00:14:34,940 --> 00:14:39,020
is because typescript is a strict

00:14:36,980 --> 00:14:42,020
superset of JavaScript

00:14:39,020 --> 00:14:44,690
we're bolting on types onto an untyped

00:14:42,020 --> 00:14:47,780
language this is totally valid

00:14:44,690 --> 00:14:49,760
JavaScript it's stupid but it's valid so

00:14:47,780 --> 00:14:50,270
this function if it gets hairy as an

00:14:49,760 --> 00:14:53,000
argument

00:14:50,270 --> 00:14:55,130
it returns seven if it gets wrong it

00:14:53,000 --> 00:14:57,380
returns undefined forgets hermione

00:14:55,130 --> 00:14:58,910
returns an object and if it gets

00:14:57,380 --> 00:15:00,060
anything else that returns wizards and

00:14:58,910 --> 00:15:01,140
you may be thinking

00:15:00,060 --> 00:15:02,940
why would I write a function that

00:15:01,140 --> 00:15:03,900
returns four different types but I

00:15:02,940 --> 00:15:06,060
actually showed you that at the

00:15:03,900 --> 00:15:08,460
beginning of the talk most Dom API s

00:15:06,060 --> 00:15:10,890
will return one of many different types

00:15:08,460 --> 00:15:12,720
based on what string you pass to it

00:15:10,890 --> 00:15:16,110
they're just not all as like as

00:15:12,720 --> 00:15:18,270
contrived as this one so here's where I

00:15:16,110 --> 00:15:19,160
tell you that all of this is still worth

00:15:18,270 --> 00:15:21,650
it

00:15:19,160 --> 00:15:24,450
typescript is just another tool

00:15:21,650 --> 00:15:27,360
typescript is not a silver bullet and

00:15:24,450 --> 00:15:30,210
what it does do is it eliminates an

00:15:27,360 --> 00:15:31,890
entire class of bugs how many of you

00:15:30,210 --> 00:15:34,320
have seen this error message in your

00:15:31,890 --> 00:15:35,940
console just like expect the entire

00:15:34,320 --> 00:15:37,290
audience to raise their hands right of

00:15:35,940 --> 00:15:38,670
course like at some point you've seen

00:15:37,290 --> 00:15:40,830
this and nine out of ten times

00:15:38,670 --> 00:15:42,660
typescript is gonna cut this out for you

00:15:40,830 --> 00:15:44,400
because it's just gonna no undefined is

00:15:42,660 --> 00:15:46,740
not there when you try to access that

00:15:44,400 --> 00:15:48,300
property same thing for this one when

00:15:46,740 --> 00:15:50,430
you try to call a function that isn't

00:15:48,300 --> 00:15:52,560
there it's gonna catch that in your

00:15:50,430 --> 00:15:54,180
editor with those red squiggly lines and

00:15:52,560 --> 00:15:55,680
not just like these things what about

00:15:54,180 --> 00:15:57,780
when the interface changes what about

00:15:55,680 --> 00:15:59,820
when I add a prop to a component that

00:15:57,780 --> 00:16:02,010
someone else on my team is using and I

00:15:59,820 --> 00:16:03,930
forgot to tell them it's gonna tell me

00:16:02,010 --> 00:16:06,000
in advance when this happens and this

00:16:03,930 --> 00:16:07,440
becomes an even bigger issue when you're

00:16:06,000 --> 00:16:09,570
talking about the scale of a company

00:16:07,440 --> 00:16:11,400
like Dropbox we have hundreds of

00:16:09,570 --> 00:16:13,910
engineer's working on the same codebase

00:16:11,400 --> 00:16:16,440
we have millions of lines of typescript

00:16:13,910 --> 00:16:18,510
hundreds of features and just to make it

00:16:16,440 --> 00:16:20,610
more challenging we have for engineering

00:16:18,510 --> 00:16:24,090
offices in three time zones so we have

00:16:20,610 --> 00:16:25,830
to coordinate well typescript is a core

00:16:24,090 --> 00:16:27,090
part of our front-end workflow and I

00:16:25,830 --> 00:16:28,920
want to show you some cool examples that

00:16:27,090 --> 00:16:31,110
you might not have thought of one of my

00:16:28,920 --> 00:16:33,390
favorite ones is library upgrades so

00:16:31,110 --> 00:16:35,550
there's this great typings library on

00:16:33,390 --> 00:16:37,950
github called definitely typed and what

00:16:35,550 --> 00:16:40,470
exists here are all of these types for

00:16:37,950 --> 00:16:42,390
any third-party library you can think of

00:16:40,470 --> 00:16:43,950
if it's not in the library itself it's

00:16:42,390 --> 00:16:46,980
almost definitely undef initely typed

00:16:43,950 --> 00:16:50,100
and the first thing we do when we go to

00:16:46,980 --> 00:16:52,080
swap out to upgrade a library is we swap

00:16:50,100 --> 00:16:55,290
out the types so let's say we're going

00:16:52,080 --> 00:16:56,880
from react 16 10 to 11 we will swap out

00:16:55,290 --> 00:16:59,400
the types and then if there are any

00:16:56,880 --> 00:17:01,530
breaking changes in the API we'll catch

00:16:59,400 --> 00:17:03,390
those almost immediately because it'll

00:17:01,530 --> 00:17:05,640
be in the typing layer and our compile

00:17:03,390 --> 00:17:09,240
will fail so the very first thing we fix

00:17:05,640 --> 00:17:10,740
is compilation some examples of the

00:17:09,240 --> 00:17:12,210
types of things that change or what

00:17:10,740 --> 00:17:13,320
happens when a feature gets deprecated

00:17:12,210 --> 00:17:15,690
what happens when we lose

00:17:13,320 --> 00:17:17,310
old context or we get rid of old refs or

00:17:15,690 --> 00:17:19,350
we get rid of component we'll do

00:17:17,310 --> 00:17:21,330
something and then also the types are

00:17:19,350 --> 00:17:22,830
changing right like sometimes function

00:17:21,330 --> 00:17:24,780
signatures change sometimes we add

00:17:22,830 --> 00:17:27,180
something or remove something and then

00:17:24,780 --> 00:17:28,860
often the types just get better a lot of

00:17:27,180 --> 00:17:31,050
the times someone will bump the types

00:17:28,860 --> 00:17:33,000
undef initely typed and they will catch

00:17:31,050 --> 00:17:34,560
something for us that is just some of

00:17:33,000 --> 00:17:35,640
the edge case where undefined was passed

00:17:34,560 --> 00:17:38,730
somewhere and you didn't even think of

00:17:35,640 --> 00:17:40,260
it honestly at our scale I don't know

00:17:38,730 --> 00:17:41,610
how we would upgrade why upgrade

00:17:40,260 --> 00:17:45,630
libraries without typescript we're

00:17:41,610 --> 00:17:48,360
talking millions of lines typescript

00:17:45,630 --> 00:17:50,520
also allows us to place constraints on

00:17:48,360 --> 00:17:52,140
our engineers and you might be thinking

00:17:50,520 --> 00:17:53,760
I don't want constraints on me I want

00:17:52,140 --> 00:17:55,950
the freedom to do whatever I want and

00:17:53,760 --> 00:17:57,630
I'd like to give you a metaphor so we

00:17:55,950 --> 00:18:00,750
have the beautiful charles bridge in

00:17:57,630 --> 00:18:02,400
prague and the simplest way with the

00:18:00,750 --> 00:18:04,230
fewest constraints to build this bridge

00:18:02,400 --> 00:18:06,930
would have been to dump a ton of

00:18:04,230 --> 00:18:08,820
concrete into the river maybe at the

00:18:06,930 --> 00:18:10,350
time several hundred years ago dumped a

00:18:08,820 --> 00:18:12,060
bunch of stone into the river and that

00:18:10,350 --> 00:18:13,860
would build a bridge that lets us cross

00:18:12,060 --> 00:18:15,690
it but we couldn't have boats get

00:18:13,860 --> 00:18:17,640
through we would ruin wildlife we would

00:18:15,690 --> 00:18:20,010
do terrible things to the environment

00:18:17,640 --> 00:18:21,840
and maybe we do that so when we're

00:18:20,010 --> 00:18:23,460
building bridges we do proper

00:18:21,840 --> 00:18:26,310
constraints and we want that with our

00:18:23,460 --> 00:18:29,160
engineers too so remember we talked

00:18:26,310 --> 00:18:31,200
about react upgrades we often want to

00:18:29,160 --> 00:18:32,760
test the latest version in production so

00:18:31,200 --> 00:18:34,680
we want to make sure that the newest

00:18:32,760 --> 00:18:37,590
latest thing is gonna run against the

00:18:34,680 --> 00:18:40,200
code that we have but we might need to

00:18:37,590 --> 00:18:43,470
rollback and here's the problem with

00:18:40,200 --> 00:18:46,470
that developers will start using new

00:18:43,470 --> 00:18:48,870
features as soon as we let them remember

00:18:46,470 --> 00:18:52,020
when hooks came out this is a simulation

00:18:48,870 --> 00:18:54,180
of our web platform team dealing with

00:18:52,020 --> 00:18:55,800
all of our engineers excited about hooks

00:18:54,180 --> 00:18:58,610
they are simba they are just trying to

00:18:55,800 --> 00:19:02,430
stay ahead of the pack to make this work

00:18:58,610 --> 00:19:04,820
so to solve this we roll out the latest

00:19:02,430 --> 00:19:07,890
version of react behind a feature gate

00:19:04,820 --> 00:19:10,500
but we keep the types of the previous

00:19:07,890 --> 00:19:12,780
versions so that at the compilation step

00:19:10,500 --> 00:19:14,220
they just can't use hooks until we know

00:19:12,780 --> 00:19:15,840
that we're not going to rollback and

00:19:14,220 --> 00:19:18,030
then once we're confident we'll add the

00:19:15,840 --> 00:19:19,710
types and this process sounds heavy it's

00:19:18,030 --> 00:19:22,230
actually it lasts maybe a week it's just

00:19:19,710 --> 00:19:23,940
you know we want to run latest react

00:19:22,230 --> 00:19:26,010
against ten or twenty or thirty percent

00:19:23,940 --> 00:19:27,770
of our users until we bump it up to a

00:19:26,010 --> 00:19:30,120
hundred and leave it

00:19:27,770 --> 00:19:32,789
another super cool thing we do is we

00:19:30,120 --> 00:19:34,110
restrict lodash usage so there's a lot

00:19:32,789 --> 00:19:35,700
of functions in lodash that are no

00:19:34,110 --> 00:19:38,250
longer really relevant they kind of made

00:19:35,700 --> 00:19:40,169
it into es5 or they're just like kind of

00:19:38,250 --> 00:19:43,440
heavy or whatever we don't want them and

00:19:40,169 --> 00:19:44,940
also well that's just 25k if you ship

00:19:43,440 --> 00:19:48,720
the whole bundle so you definitely want

00:19:44,940 --> 00:19:52,110
a smaller bundle excuse me

00:19:48,720 --> 00:19:55,020
so what we do is we have this Taipings

00:19:52,110 --> 00:19:56,820
firewall that prevents engineers from

00:19:55,020 --> 00:19:58,830
using functions that we don't want in

00:19:56,820 --> 00:20:00,330
our bundle and if they want to add it

00:19:58,830 --> 00:20:02,370
they submit a PR and it's a one-liner

00:20:00,330 --> 00:20:05,039
and we probably say yes if we think it's

00:20:02,370 --> 00:20:06,450
a good idea but otherwise we just like

00:20:05,039 --> 00:20:08,100
kind of default to not having this

00:20:06,450 --> 00:20:10,080
dependency and not sending down this

00:20:08,100 --> 00:20:11,700
extra code we wrote a really great blog

00:20:10,080 --> 00:20:13,200
post about all that and how we did that

00:20:11,700 --> 00:20:16,110
migration you can read that one later

00:20:13,200 --> 00:20:17,760
but what about for small teams right

00:20:16,110 --> 00:20:20,429
like I've been talking about hundreds of

00:20:17,760 --> 00:20:22,740
engineers but your team is probably 5 or

00:20:20,429 --> 00:20:25,500
10 or 20 or maybe it's just you maybe

00:20:22,740 --> 00:20:27,090
it's just you writing code and some

00:20:25,500 --> 00:20:29,370
people are gonna claim that typescript

00:20:27,090 --> 00:20:30,659
gives you free documentation and I'm not

00:20:29,370 --> 00:20:32,549
gonna tell you that I think you still

00:20:30,659 --> 00:20:35,159
need Docs especially to convey why eatin

00:20:32,549 --> 00:20:36,720
things some people are gonna claim that

00:20:35,159 --> 00:20:38,700
typescript is gonna give you free tests

00:20:36,720 --> 00:20:40,289
and I don't want to make that claim

00:20:38,700 --> 00:20:42,059
either you absolutely should be writing

00:20:40,289 --> 00:20:44,640
integration test and end-to-end tests

00:20:42,059 --> 00:20:46,289
and like dealing with that but here's

00:20:44,640 --> 00:20:48,000
what typescript is gonna give you it's

00:20:46,289 --> 00:20:50,820
gonna give you contract validation

00:20:48,000 --> 00:20:52,740
across the board so this is kind of a

00:20:50,820 --> 00:20:54,600
standard application right we have our

00:20:52,740 --> 00:20:55,770
API and then we have our data layer

00:20:54,600 --> 00:20:57,240
which might be redux

00:20:55,770 --> 00:20:59,640
it might be Apollo it might be hooks

00:20:57,240 --> 00:21:01,169
what we might be using hooks use reducer

00:20:59,640 --> 00:21:03,030
whatever it doesn't matter it's probably

00:21:01,169 --> 00:21:04,679
here then we have our components which

00:21:03,030 --> 00:21:06,360
are a little smarter and are doing some

00:21:04,679 --> 00:21:07,799
business logic and then we have kind of

00:21:06,360 --> 00:21:12,059
our dumber components in the front our

00:21:07,799 --> 00:21:14,610
component library and we can enforce

00:21:12,059 --> 00:21:17,880
contracts across this so a contract is a

00:21:14,610 --> 00:21:19,710
precise and verifiable interface for

00:21:17,880 --> 00:21:21,299
software components and the most

00:21:19,710 --> 00:21:25,080
important part of this is that it's

00:21:21,299 --> 00:21:26,610
verifiable so for example on our API an

00:21:25,080 --> 00:21:29,549
engineer who's probably writing in

00:21:26,610 --> 00:21:32,159
Python or go or rust is gonna want to

00:21:29,549 --> 00:21:35,190
make a change to some endpoint and what

00:21:32,159 --> 00:21:37,560
we do is we compile those types using a

00:21:35,190 --> 00:21:39,480
tool that we've open-source called stone

00:21:37,560 --> 00:21:41,520
and we have typescript types then and

00:21:39,480 --> 00:21:42,840
they will know immediately before they

00:21:41,520 --> 00:21:44,730
merge their code if they're going to

00:21:42,840 --> 00:21:47,310
break someone's usage somewhere on the

00:21:44,730 --> 00:21:48,780
front end similarly on the entire

00:21:47,310 --> 00:21:50,610
opposite end of the stack with our

00:21:48,780 --> 00:21:52,140
component library if you've got a

00:21:50,610 --> 00:21:54,000
Slytherin component and you want to add

00:21:52,140 --> 00:21:55,920
a prop that is now required or you want

00:21:54,000 --> 00:21:57,660
to remove a prop or add the type or

00:21:55,920 --> 00:21:59,910
change the type we're gonna catch that

00:21:57,660 --> 00:22:03,450
across the usages throughout our

00:21:59,910 --> 00:22:05,190
millions of lines of code and then not

00:22:03,450 --> 00:22:07,110
only that but engineers can do this

00:22:05,190 --> 00:22:09,810
within their own features which is super

00:22:07,110 --> 00:22:12,030
nice in fact I want to show you an

00:22:09,810 --> 00:22:14,280
example of that so I wrote this small

00:22:12,030 --> 00:22:15,630
sample app and the first thing you'll

00:22:14,280 --> 00:22:18,810
notice is that we have this type user

00:22:15,630 --> 00:22:21,450
and user has a user ID which is a number

00:22:18,810 --> 00:22:22,500
and a name which is a string we have

00:22:21,450 --> 00:22:24,780
this function which might be

00:22:22,500 --> 00:22:26,340
auto-generated from our tooling that

00:22:24,780 --> 00:22:28,560
call it's called fetch users and it

00:22:26,340 --> 00:22:30,090
returns a promise of list of user so

00:22:28,560 --> 00:22:31,830
we've brought this type from the back

00:22:30,090 --> 00:22:34,890
end to the front end using typescript

00:22:31,830 --> 00:22:36,900
and automated toy and our Redux layer

00:22:34,890 --> 00:22:39,480
we're gonna want to dispatch actions

00:22:36,900 --> 00:22:41,910
that can fetch the user and the payload

00:22:39,480 --> 00:22:44,600
is gonna be of type users so this type

00:22:41,910 --> 00:22:47,130
is slowly propagating across the system

00:22:44,600 --> 00:22:49,490
inside the function we are returning a

00:22:47,130 --> 00:22:52,440
type which has guaranteed that payload

00:22:49,490 --> 00:22:55,050
then in our actual store where we're

00:22:52,440 --> 00:22:57,570
storing the data we are still using this

00:22:55,050 --> 00:22:59,220
user type that came from some arbitrary

00:22:57,570 --> 00:23:01,140
place in the backend this could have

00:22:59,220 --> 00:23:02,250
been defined in a protobuf this could

00:23:01,140 --> 00:23:03,960
have been defined very close to the

00:23:02,250 --> 00:23:07,140
database but we are propagating this

00:23:03,960 --> 00:23:08,820
across our system now here is what I

00:23:07,140 --> 00:23:10,050
like to call a contract shift because

00:23:08,820 --> 00:23:13,050
what we're doing is we are taking the

00:23:10,050 --> 00:23:14,760
store or the shape of the store and that

00:23:13,050 --> 00:23:16,650
has a user in it and now we are

00:23:14,760 --> 00:23:20,340
returning a string that's what that type

00:23:16,650 --> 00:23:22,080
on the far right is so our view which

00:23:20,340 --> 00:23:24,780
really doesn't care about the backend or

00:23:22,080 --> 00:23:26,820
how any of this works has this name prop

00:23:24,780 --> 00:23:29,750
and all it's receiving is a string and

00:23:26,820 --> 00:23:32,190
it can just spit that out to the user so

00:23:29,750 --> 00:23:34,920
this type this user type from the

00:23:32,190 --> 00:23:37,170
backend is being propagated everywhere

00:23:34,920 --> 00:23:39,750
it's needed up until we have a contract

00:23:37,170 --> 00:23:40,860
that says hey we need a string for type

00:23:39,750 --> 00:23:44,030
user let's trade

00:23:40,860 --> 00:23:46,470
and then we give that out to the view I

00:23:44,030 --> 00:23:49,029
also like to argue that typescript

00:23:46,470 --> 00:23:51,549
increases in value over time

00:23:49,029 --> 00:23:53,289
this is kind of just like a contrived

00:23:51,549 --> 00:23:54,789
graph where I said the number of lines

00:23:53,289 --> 00:23:56,469
of code that you could generate by

00:23:54,789 --> 00:23:58,779
yourself over three years which is

00:23:56,469 --> 00:24:00,819
probably 20,000 maybe it's 50,000 maybe

00:23:58,779 --> 00:24:02,499
it's 100,000 you could write a lot of

00:24:00,819 --> 00:24:04,509
code by yourself and what happens if the

00:24:02,499 --> 00:24:06,249
team becomes five or ten you're easily

00:24:04,509 --> 00:24:08,859
producing hundreds of thousands of lines

00:24:06,249 --> 00:24:10,869
of code very quickly are you gonna

00:24:08,859 --> 00:24:12,519
remember how every part of your

00:24:10,869 --> 00:24:14,739
application integrates with every other

00:24:12,519 --> 00:24:16,689
part of your application how many of you

00:24:14,739 --> 00:24:18,459
have written a login form at some point

00:24:16,689 --> 00:24:20,649
in time as the very first thing you did

00:24:18,459 --> 00:24:23,949
and then forgotten about it it's kind of

00:24:20,649 --> 00:24:26,709
a common thing so what I like is that

00:24:23,949 --> 00:24:28,539
unlike tests typescript gets in your way

00:24:26,709 --> 00:24:31,389
it's in the middle of your editor it's

00:24:28,539 --> 00:24:33,369
in the middle of your compiler now it's

00:24:31,389 --> 00:24:35,379
not a silver bullet like I said I want

00:24:33,369 --> 00:24:36,729
you writing tests I want you doing code

00:24:35,379 --> 00:24:40,239
review and I want you thinking about

00:24:36,729 --> 00:24:42,339
architecture but I would argue that the

00:24:40,239 --> 00:24:44,709
metric for success on a code base is how

00:24:42,339 --> 00:24:47,159
few things you need to keep in your head

00:24:44,709 --> 00:24:49,899
at any given point in time and

00:24:47,159 --> 00:24:52,019
typescript allows you to forget about

00:24:49,899 --> 00:24:56,979
other caught parts of your code base and

00:24:52,019 --> 00:24:58,899
really the only cost is learning it so

00:24:56,979 --> 00:25:00,579
thank you so much my name is matthew

00:24:58,899 --> 00:25:07,400
gerstmann and i think we can do

00:25:00,579 --> 00:25:10,520
questions Thank You Matthew

00:25:07,400 --> 00:25:15,380
we have questions do you think duck

00:25:10,520 --> 00:25:17,240
typing is an anti-pattern so one of the

00:25:15,380 --> 00:25:19,460
interesting things about typescript

00:25:17,240 --> 00:25:24,050
especially is that it uses structural

00:25:19,460 --> 00:25:25,880
typing so I've been in cases where I did

00:25:24,050 --> 00:25:27,770
something like I had two types that were

00:25:25,880 --> 00:25:31,550
exactly the same and we decided to split

00:25:27,770 --> 00:25:33,740
them because they might change so is

00:25:31,550 --> 00:25:35,930
duck typing an anti-pattern the answer

00:25:33,740 --> 00:25:37,490
is depends on your use case like most

00:25:35,930 --> 00:25:40,880
things I don't really have a strong

00:25:37,490 --> 00:25:43,670
opinion here chances are if your UI

00:25:40,880 --> 00:25:46,429
props and you are very back of your your

00:25:43,670 --> 00:25:49,070
stack props or just function signature

00:25:46,429 --> 00:25:50,660
are exactly the same that they're

00:25:49,070 --> 00:25:52,850
probably gonna diverge at some point and

00:25:50,660 --> 00:25:54,740
maybe make two separate types but you

00:25:52,850 --> 00:25:56,420
can also start off with one the biggest

00:25:54,740 --> 00:25:59,000
thing I would avoid is just leave

00:25:56,420 --> 00:26:00,440
hasty abstractions where you abstract

00:25:59,000 --> 00:26:03,110
things that don't necessarily need to be

00:26:00,440 --> 00:26:06,860
abstracted why should I choose

00:26:03,110 --> 00:26:09,550
typescript overflow honestly I would

00:26:06,860 --> 00:26:12,770
just push you to use a type anything I

00:26:09,550 --> 00:26:14,840
do not have a stake in this holy war I

00:26:12,770 --> 00:26:17,059
work for Dropbox not Microsoft or

00:26:14,840 --> 00:26:18,650
Facebook so I really don't have a stake

00:26:17,059 --> 00:26:20,780
in it I can say in my experience

00:26:18,650 --> 00:26:22,790
typescript has a much stronger community

00:26:20,780 --> 00:26:24,910
it has much stronger third-party types

00:26:22,790 --> 00:26:28,280
and it seems to be getting more support

00:26:24,910 --> 00:26:29,179
but if flow is working for you like I'm

00:26:28,280 --> 00:26:32,270
not going to tell you to migrate your

00:26:29,179 --> 00:26:34,190
codebase keep using flow this one you

00:26:32,270 --> 00:26:38,030
might have to help me how much different

00:26:34,190 --> 00:26:42,500
is typescript did you do there's this

00:26:38,030 --> 00:26:44,540
native fencing and weights in text show

00:26:42,500 --> 00:26:46,929
significantly slow performance with big

00:26:44,540 --> 00:26:49,070
data structures interesting okay so

00:26:46,929 --> 00:26:51,620
typescript does the job for you that

00:26:49,070 --> 00:26:54,740
Babel traditionally does which down

00:26:51,620 --> 00:26:56,480
compiles your latest es next code with

00:26:54,740 --> 00:26:57,830
all the latest features into something

00:26:56,480 --> 00:27:00,320
that the browser can serve it can even

00:26:57,830 --> 00:27:02,830
do es 3 but normally it's doing s 5 I

00:27:00,320 --> 00:27:05,690
actually don't know the performance

00:27:02,830 --> 00:27:07,460
implications of using typescript first

00:27:05,690 --> 00:27:09,290
basball versus the native one I would

00:27:07,460 --> 00:27:11,630
imagine that the native async/await is

00:27:09,290 --> 00:27:12,770
probably the fastest one if you're in an

00:27:11,630 --> 00:27:15,050
environment where you're really

00:27:12,770 --> 00:27:17,390
optimizing for that you could serve the

00:27:15,050 --> 00:27:19,220
async/await as is but I don't think

00:27:17,390 --> 00:27:20,180
typescript really has much of an impact

00:27:19,220 --> 00:27:22,760
he

00:27:20,180 --> 00:27:25,430
compared to compared to any of the other

00:27:22,760 --> 00:27:27,260
options you're gonna choose next how

00:27:25,430 --> 00:27:30,230
typescript works with not type

00:27:27,260 --> 00:27:32,630
dependencies yeah so if it's not undef

00:27:30,230 --> 00:27:34,400
initely typed which is rare what you do

00:27:32,630 --> 00:27:37,610
is you make kind of an index file for

00:27:34,400 --> 00:27:39,320
yourself it's called a DTS file and it's

00:27:37,610 --> 00:27:41,600
similar to a header file in other

00:27:39,320 --> 00:27:44,000
languages and what you do there is you

00:27:41,600 --> 00:27:45,260
say this is the library and you can you

00:27:44,000 --> 00:27:47,570
can you have two options you can either

00:27:45,260 --> 00:27:48,620
take the time to type it yourself and

00:27:47,570 --> 00:27:51,290
maybe you want to commit that to the

00:27:48,620 --> 00:27:53,030
outside world or you can just say just

00:27:51,290 --> 00:27:54,560
trust me when I use this library and

00:27:53,030 --> 00:27:56,630
it's not gonna be type safe there but

00:27:54,560 --> 00:27:57,770
that's one of the nice things is that

00:27:56,630 --> 00:27:59,270
it's incremental so you don't

00:27:57,770 --> 00:28:01,520
immediately have to type your whole

00:27:59,270 --> 00:28:03,290
codebase it's also really useful to

00:28:01,520 --> 00:28:05,390
think of this not just for not type

00:28:03,290 --> 00:28:06,920
dependencies but for just parts of your

00:28:05,390 --> 00:28:09,290
code base that aren't typed a lot of the

00:28:06,920 --> 00:28:10,640
time when people do migrations they tend

00:28:09,290 --> 00:28:11,180
to start very inside and then move

00:28:10,640 --> 00:28:13,280
outwards

00:28:11,180 --> 00:28:16,430
there was a great talk from someone at

00:28:13,280 --> 00:28:18,590
Airbnb I believe about how they did that

00:28:16,430 --> 00:28:20,960
migration we gonna do last two questions

00:28:18,590 --> 00:28:24,350
Matt so how sleep is the learning curve

00:28:20,960 --> 00:28:26,030
for typescript so I hope you saw some of

00:28:24,350 --> 00:28:28,130
that in the incremental step that at

00:28:26,030 --> 00:28:29,420
first it's very simple like you have

00:28:28,130 --> 00:28:31,460
strings and you have numbers and you

00:28:29,420 --> 00:28:33,440
have primitives it does get complicated

00:28:31,460 --> 00:28:35,900
very quickly like you don't have to go

00:28:33,440 --> 00:28:38,720
from 1 to 11 like on the you know knobs

00:28:35,900 --> 00:28:41,120
1 to 10 but you do get to 6 rather fast

00:28:38,720 --> 00:28:43,130
and the reason for that is third-party

00:28:41,120 --> 00:28:44,120
libraries like lodash or react or what

00:28:43,130 --> 00:28:46,040
have you

00:28:44,120 --> 00:28:48,830
those are gonna require sufficiently

00:28:46,040 --> 00:28:50,450
complex types to be statically typed now

00:28:48,830 --> 00:28:52,070
you can always make the trade-off I want

00:28:50,450 --> 00:28:53,390
my code to be slightly less type safe

00:28:52,070 --> 00:28:55,250
and get some of the benefits of

00:28:53,390 --> 00:28:57,200
typescript that is that is totally a

00:28:55,250 --> 00:28:59,900
valid thing but if you're going for that

00:28:57,200 --> 00:29:03,380
like perfect typing all the time like

00:28:59,900 --> 00:29:05,030
yes there's a steep learning curve so I

00:29:03,380 --> 00:29:07,850
said last two questions but we have two

00:29:05,030 --> 00:29:12,410
more questions that are both competing

00:29:07,850 --> 00:29:14,570
so will there ever be in Tigger type and

00:29:12,410 --> 00:29:19,940
typescript ask Brian hold after I leave

00:29:14,570 --> 00:29:21,710
the stage all right my goodness and the

00:29:19,940 --> 00:29:23,630
last one how do you pass generic type

00:29:21,710 --> 00:29:24,350
into functional components yeah I do

00:29:23,630 --> 00:29:28,670
that all the time

00:29:24,350 --> 00:29:31,100
so you you can do what you end up doing

00:29:28,670 --> 00:29:31,960
is you do what Const it's easier if I

00:29:31,100 --> 00:29:35,139
actually typed

00:29:31,960 --> 00:29:36,639
you do Const react come type variable

00:29:35,139 --> 00:29:38,799
type of the react component and then you

00:29:36,639 --> 00:29:40,360
can pass a generic to it I don't think

00:29:38,799 --> 00:29:42,759
you can actually do generics with

00:29:40,360 --> 00:29:44,649
standard function space name of the

00:29:42,759 --> 00:29:46,720
function signature but you can do it

00:29:44,649 --> 00:29:48,700
with the stored in a variable syntax so

00:29:46,720 --> 00:29:51,009
there is one way to do it but it doesn't

00:29:48,700 --> 00:29:52,869
work the other one alright that's all

00:29:51,009 --> 00:29:55,300
the time we have thank you so much to us

00:29:52,869 --> 00:29:59,440
Mathew Kurtzman thank you so much

00:29:55,300 --> 00:29:59,440

YouTube URL: https://www.youtube.com/watch?v=KdvEGPiULAQ


