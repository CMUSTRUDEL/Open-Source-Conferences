Title: ReactiveConf 2019 - David Nolen: Are we there yet? Remix
Publication date: 2019-10-30
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Millennium stage
Captions: 
	00:00:02,760 --> 00:00:11,900
[Music]

00:00:16,850 --> 00:00:22,710
hello good morning this talk is called

00:00:21,689 --> 00:00:25,109
are we there yet

00:00:22,710 --> 00:00:29,310
remix I'm gonna explain the title in a

00:00:25,109 --> 00:00:31,380
second just a little bit about me I was

00:00:29,310 --> 00:00:33,690
an early adopter of react I think that's

00:00:31,380 --> 00:00:36,750
how I kind of got involved in reactive

00:00:33,690 --> 00:00:38,790
compiz because I think in 2013 I I

00:00:36,750 --> 00:00:40,680
talked about why I thought it was cool I

00:00:38,790 --> 00:00:43,079
know some of you that were around using

00:00:40,680 --> 00:00:44,579
it that long might remember but since

00:00:43,079 --> 00:00:46,140
then I've been doing a lot of

00:00:44,579 --> 00:00:47,789
professional closure development I'm

00:00:46,140 --> 00:00:49,530
currently a software engineer at this

00:00:47,789 --> 00:00:52,289
company called voucher IO where we're

00:00:49,530 --> 00:00:55,350
kind of rethinking security and

00:00:52,289 --> 00:00:57,840
cryptography but that that part's

00:00:55,350 --> 00:00:59,850
interesting but at its the only five

00:00:57,840 --> 00:01:01,920
developers at vouched IO it's a kind of

00:00:59,850 --> 00:01:03,780
a startup but our entire stack is

00:01:01,920 --> 00:01:05,360
functional programming we use closure

00:01:03,780 --> 00:01:07,710
and closure script for everything

00:01:05,360 --> 00:01:10,020
closures for all our back-end services

00:01:07,710 --> 00:01:12,570
we use closure script plus react native

00:01:10,020 --> 00:01:15,320
to build our mobile client and we also

00:01:12,570 --> 00:01:18,540
do this neat thing where we have an SDK

00:01:15,320 --> 00:01:20,729
version of our code base where we need

00:01:18,540 --> 00:01:23,729
to deploy that to for both Java

00:01:20,729 --> 00:01:25,740
consumers as well as objective-c Swift

00:01:23,729 --> 00:01:29,159
consumers and we only write that code

00:01:25,740 --> 00:01:32,189
once in closure script and we closure

00:01:29,159 --> 00:01:35,310
script inside of a wrapper which exposes

00:01:32,189 --> 00:01:37,049
the idiomatic api's for whoever is

00:01:35,310 --> 00:01:38,939
consuming that particular version of sdk

00:01:37,049 --> 00:01:40,700
which is pretty cool so we're able to be

00:01:38,939 --> 00:01:43,680
very productive with the very small team

00:01:40,700 --> 00:01:45,119
very agile which is interesting I'm not

00:01:43,680 --> 00:01:46,860
going to talk to one other thing about

00:01:45,119 --> 00:01:49,409
vouch IO that's pretty cool is we'd use

00:01:46,860 --> 00:01:50,579
this thing called day Tomic cloud which

00:01:49,409 --> 00:01:52,259
is a product from this company called

00:01:50,579 --> 00:01:53,460
caught in tech where I used to work so I

00:01:52,259 --> 00:01:55,680
don't work a kind of site anymore

00:01:53,460 --> 00:01:57,360
it was great if I work about Jo now what

00:01:55,680 --> 00:01:59,280
we're using cognate x-day Tomic cloud

00:01:57,360 --> 00:02:01,049
and that actually is interesting piece

00:01:59,280 --> 00:02:02,939
of technology if you're interested in

00:02:01,049 --> 00:02:05,310
enclosure enclosure script because it's

00:02:02,939 --> 00:02:07,229
basically Redux in the cloud right so if

00:02:05,310 --> 00:02:09,450
you like Redux and functional

00:02:07,229 --> 00:02:11,890
programming and having control over your

00:02:09,450 --> 00:02:13,180
state imagine if you had

00:02:11,890 --> 00:02:15,760
level of control over your entire

00:02:13,180 --> 00:02:18,970
database the atomic cloud is effectively

00:02:15,760 --> 00:02:22,140
a gigantic immutable j/s map in the

00:02:18,970 --> 00:02:25,060
cloud we can time travel over our entire

00:02:22,140 --> 00:02:27,490
business domain and that's pretty crazy

00:02:25,060 --> 00:02:28,990
I'm pretty cool so if you have questions

00:02:27,490 --> 00:02:31,390
about that I'm not gonna talk about much

00:02:28,990 --> 00:02:33,160
more about that today feel free to ask

00:02:31,390 --> 00:02:34,330
me any questions after the talk and I

00:02:33,160 --> 00:02:37,540
believe I want to be on the discovery

00:02:34,330 --> 00:02:40,660
stage today like 5:30 so if you have

00:02:37,540 --> 00:02:41,980
questions come come find me I'm gonna

00:02:40,660 --> 00:02:43,810
talk a bit about closure and closure

00:02:41,980 --> 00:02:45,580
script but this is not like this is not

00:02:43,810 --> 00:02:46,810
like a pitch right I'm not you know I'm

00:02:45,580 --> 00:02:49,209
not trying to convince anybody to use

00:02:46,810 --> 00:02:50,890
closure a closure script closure and

00:02:49,209 --> 00:02:52,810
closure script are great bits of

00:02:50,890 --> 00:02:54,970
technology I would say there we have a

00:02:52,810 --> 00:02:56,140
modest community it's sustainable I

00:02:54,970 --> 00:02:57,340
think that's the most important thing

00:02:56,140 --> 00:03:01,180
about a programming language you have a

00:02:57,340 --> 00:03:03,850
sustainable community closure is now 12

00:03:01,180 --> 00:03:06,100
years old and closure script is about to

00:03:03,850 --> 00:03:08,110
be 9 it's it's eight and a half months

00:03:06,100 --> 00:03:10,300
I've been the lead developer of closure

00:03:08,110 --> 00:03:13,180
script since 2011 so I've been there

00:03:10,300 --> 00:03:14,920
since the beginning again they're great

00:03:13,180 --> 00:03:19,090
technologies but the point about this

00:03:14,920 --> 00:03:21,489
talk is is you're probably doing es6 or

00:03:19,090 --> 00:03:22,930
you're doing typescript maybe maybe some

00:03:21,489 --> 00:03:26,040
of you are doing flow but based off the

00:03:22,930 --> 00:03:29,049
surveys I'm really a most of you doing

00:03:26,040 --> 00:03:31,920
JavaScript and typescript it's to think

00:03:29,049 --> 00:03:35,290
about what are the semantics that

00:03:31,920 --> 00:03:37,450
typescript and javascript give you where

00:03:35,290 --> 00:03:39,880
are they going and what is it that these

00:03:37,450 --> 00:03:41,620
other interesting languages like Elm

00:03:39,880 --> 00:03:44,230
like pure script like closure script

00:03:41,620 --> 00:03:46,150
that target the same platform right the

00:03:44,230 --> 00:03:48,040
whole the benefit of something like

00:03:46,150 --> 00:03:49,299
JavaScript being ubiquitous kind of like

00:03:48,040 --> 00:03:51,790
what I said we're doing at batch of i/o

00:03:49,299 --> 00:03:53,560
is that we're able to completely

00:03:51,790 --> 00:03:55,120
leverage the fact that javascript is

00:03:53,560 --> 00:03:57,430
everywhere we can target node we can

00:03:55,120 --> 00:04:00,940
target phones and there's a lot of power

00:03:57,430 --> 00:04:02,590
here and I think that now more than ever

00:04:00,940 --> 00:04:04,600
because I think things are changing with

00:04:02,590 --> 00:04:06,880
how quickly JavaScript or typescript can

00:04:04,600 --> 00:04:10,420
evolve it's a good time and it's very

00:04:06,880 --> 00:04:12,070
low risk to say well I'm already on the

00:04:10,420 --> 00:04:14,109
JavaScript platform let me play around

00:04:12,070 --> 00:04:17,799
with some of these different languages

00:04:14,109 --> 00:04:19,539
and see if they provide new tools for

00:04:17,799 --> 00:04:21,519
solving problems I mean that's really

00:04:19,539 --> 00:04:23,890
why one chooses a programming language a

00:04:21,519 --> 00:04:25,720
programming language may or may not let

00:04:23,890 --> 00:04:27,490
you write better software

00:04:25,720 --> 00:04:29,080
but it will definitely show you new ways

00:04:27,490 --> 00:04:31,360
to solve problems hopefully your whole

00:04:29,080 --> 00:04:34,480
team can understand that and that will

00:04:31,360 --> 00:04:36,490
allow you to ship better software faster

00:04:34,480 --> 00:04:39,250
you can't do it by yourself I mean it

00:04:36,490 --> 00:04:42,520
requires effort programming is in the

00:04:39,250 --> 00:04:44,470
Annis of social activity so the name of

00:04:42,520 --> 00:04:49,120
this talk is a riff on this talk by rich

00:04:44,470 --> 00:04:50,710
Hickey that he gave 10 years ago yes 10

00:04:49,120 --> 00:04:52,540
years ago just a little more than 10

00:04:50,710 --> 00:04:56,380
years ago at the jvm languages summit

00:04:52,540 --> 00:04:59,680
which is a yearly summit for both

00:04:56,380 --> 00:05:01,270
language designers and JVM implementers

00:04:59,680 --> 00:05:03,490
people who implement the virtual

00:05:01,270 --> 00:05:05,590
machines to come together and talk about

00:05:03,490 --> 00:05:07,360
how what are the challenges for

00:05:05,590 --> 00:05:10,210
implementing languages which are not

00:05:07,360 --> 00:05:12,700
Java on top of the JVM the JVM has a

00:05:10,210 --> 00:05:14,950
published bike code and so you're able

00:05:12,700 --> 00:05:16,840
to target that technology but of course

00:05:14,950 --> 00:05:18,730
there are things that the JVM could do

00:05:16,840 --> 00:05:20,860
to make the job easier or harder for

00:05:18,730 --> 00:05:23,950
language devs so when he gave this talk

00:05:20,860 --> 00:05:25,840
he was pointing out that in 2008 I mean

00:05:23,950 --> 00:05:27,070
Java and it's and nothing has changed in

00:05:25,840 --> 00:05:29,830
10 years I'm running to come back to

00:05:27,070 --> 00:05:32,110
that that main stream o.o has really

00:05:29,830 --> 00:05:34,690
succeeded and and this is not a bad

00:05:32,110 --> 00:05:36,220
thing right main stream o.o people

00:05:34,690 --> 00:05:37,780
learning in school it's effective

00:05:36,220 --> 00:05:40,270
there's a lot of literature on how to

00:05:37,780 --> 00:05:42,640
write good software using oo techniques

00:05:40,270 --> 00:05:44,590
and Java and c-sharp to me are kind of

00:05:42,640 --> 00:05:46,870
like the high-water mark of what's

00:05:44,590 --> 00:05:49,030
possible like there's not much in that

00:05:46,870 --> 00:05:51,130
space that's happen significantly right

00:05:49,030 --> 00:05:53,350
those technologies are good and there's

00:05:51,130 --> 00:05:55,780
some sort of minor activity around

00:05:53,350 --> 00:05:57,970
making things a little bit cleaner but I

00:05:55,780 --> 00:05:59,770
would say in 10 years not that much has

00:05:57,970 --> 00:06:02,050
change and in fact when rich Hickey had

00:05:59,770 --> 00:06:05,140
given this talk in 2008 not much had

00:06:02,050 --> 00:06:06,730
changed since really JDK 1.5 or or the

00:06:05,140 --> 00:06:08,919
or the versions of C sharp that were

00:06:06,730 --> 00:06:10,750
floating around and in this talk he

00:06:08,919 --> 00:06:12,160
talks about well what if we did things

00:06:10,750 --> 00:06:12,730
differently what about functional

00:06:12,160 --> 00:06:14,890
programming

00:06:12,730 --> 00:06:16,150
what about immutable data structures so

00:06:14,890 --> 00:06:18,190
if you're familiar with immutable J's

00:06:16,150 --> 00:06:21,490
from Facebook something that came out in

00:06:18,190 --> 00:06:23,470
2014 those those data structures were

00:06:21,490 --> 00:06:26,380
actually ones that rich Hickey designed

00:06:23,470 --> 00:06:29,080
himself and he did that work in 2004

00:06:26,380 --> 00:06:31,480
right so there was a 10 year gap from

00:06:29,080 --> 00:06:33,160
when rich Hickey innovated using some

00:06:31,480 --> 00:06:35,919
existing literature but did a lot of

00:06:33,160 --> 00:06:38,280
innovative work that ten years later

00:06:35,919 --> 00:06:41,930
that appears as immutable Jas

00:06:38,280 --> 00:06:45,150
so again this is all pretty old stuff

00:06:41,930 --> 00:06:47,550
but you really could give that talk

00:06:45,150 --> 00:06:48,900
again today and why I'm sort of giving

00:06:47,550 --> 00:06:49,320
this talking is why it's called are we

00:06:48,900 --> 00:06:52,140
there yet

00:06:49,320 --> 00:06:53,820
remix I follow the JavaScript community

00:06:52,140 --> 00:06:56,250
I don't do much JavaScript but of course

00:06:53,820 --> 00:06:58,050
I have to follow it I maintain a compile

00:06:56,250 --> 00:07:00,330
the JavaScript language I have to know

00:06:58,050 --> 00:07:01,860
what's best practice because users of

00:07:00,330 --> 00:07:03,600
clojurescript want to be able to

00:07:01,860 --> 00:07:06,720
leverage the ecosystem they want to use

00:07:03,600 --> 00:07:09,360
the same tools they want to build access

00:07:06,720 --> 00:07:12,120
all these libraries that are great than

00:07:09,360 --> 00:07:14,010
that you all have access to and perhaps

00:07:12,120 --> 00:07:15,780
in this in a simpler way because the

00:07:14,010 --> 00:07:18,450
tooling is already set up in closure

00:07:15,780 --> 00:07:19,500
script there's a hat for us because we

00:07:18,450 --> 00:07:21,750
use things like the Google closure

00:07:19,500 --> 00:07:23,910
compiler there's a bit of more work for

00:07:21,750 --> 00:07:25,830
us to do but we also want it to be easy

00:07:23,910 --> 00:07:29,580
because we believe there's tons of value

00:07:25,830 --> 00:07:31,710
in the ecosystem but so I follow things

00:07:29,580 --> 00:07:33,270
in in the JavaScript community and this

00:07:31,710 --> 00:07:34,710
last survey to me was very surprising

00:07:33,270 --> 00:07:36,840
because you know you see this massive

00:07:34,710 --> 00:07:40,200
es6 adoption which of course I think

00:07:36,840 --> 00:07:43,440
it's clear right for me personally I've

00:07:40,200 --> 00:07:47,040
been doing JavaScript since 2005 so I

00:07:43,440 --> 00:07:49,919
remember back in the days when you know

00:07:47,040 --> 00:07:52,050
the only clue you had was when ie6 would

00:07:49,919 --> 00:07:54,600
crash right when it crashed and then you

00:07:52,050 --> 00:07:56,190
could start putting like try caches or

00:07:54,600 --> 00:07:58,890
you know until the point where like okay

00:07:56,190 --> 00:08:01,290
hasn't crashed yet so I remember the the

00:07:58,890 --> 00:08:04,140
dark days of JavaScript so things have

00:08:01,290 --> 00:08:07,230
of course improved a lot specifically

00:08:04,140 --> 00:08:09,570
with es6 personally I'm extremely happy

00:08:07,230 --> 00:08:12,660
that they added modules as well as

00:08:09,570 --> 00:08:14,640
async/await those two for me removed so

00:08:12,660 --> 00:08:16,050
much incidental complexity I mean ten

00:08:14,640 --> 00:08:18,750
years of JavaScript there was no

00:08:16,050 --> 00:08:20,700
standard way to load some other bit of

00:08:18,750 --> 00:08:23,580
code I mean that ruined the ability to

00:08:20,700 --> 00:08:26,240
do serious live library development it

00:08:23,580 --> 00:08:28,680
ruined the ability to have a very

00:08:26,240 --> 00:08:29,820
sophisticated dependency chain like you

00:08:28,680 --> 00:08:32,310
have a lot of components you want to

00:08:29,820 --> 00:08:35,580
pull in and just solving that was huge

00:08:32,310 --> 00:08:37,110
and then of course all all JavaScript

00:08:35,580 --> 00:08:38,880
all meaningful JavaScript that you're

00:08:37,110 --> 00:08:41,490
gonna write is gonna involve asynchrony

00:08:38,880 --> 00:08:42,210
and that was never fun and I believe

00:08:41,490 --> 00:08:44,570
async/await

00:08:42,210 --> 00:08:47,880
reduces the sort of incidental sort of

00:08:44,570 --> 00:08:50,070
complexity around okay what does that

00:08:47,880 --> 00:08:51,400
code look like is it readable and how

00:08:50,070 --> 00:08:53,250
can I do the error handling in a

00:08:51,400 --> 00:08:56,380
sensible way and I think async/await

00:08:53,250 --> 00:08:58,510
covers just the most basic activities

00:08:56,380 --> 00:09:01,630
there so it's not surprising to me that

00:08:58,510 --> 00:09:04,030
es6 plus a single weight is seeing rapid

00:09:01,630 --> 00:09:06,460
adoption but the surprise for me was

00:09:04,030 --> 00:09:09,220
typescript you know in in this is last

00:09:06,460 --> 00:09:11,350
year that more than half the survey of

00:09:09,220 --> 00:09:12,880
people that took the survey ahead use

00:09:11,350 --> 00:09:15,370
typescript right almost all right almost

00:09:12,880 --> 00:09:17,860
half 46% not half but not quite half but

00:09:15,370 --> 00:09:20,230
almost half and that's very interesting

00:09:17,860 --> 00:09:22,600
to me and one thing that was hard to

00:09:20,230 --> 00:09:25,120
figure out from this survey was that is

00:09:22,600 --> 00:09:27,850
that are is that because you have

00:09:25,120 --> 00:09:31,360
JavaScript people who like es6 and

00:09:27,850 --> 00:09:37,200
they're interested in typing es6 or is

00:09:31,360 --> 00:09:37,200
it also the fact that you have a massive

00:09:37,320 --> 00:09:40,930
demographic of Java and c-sharp

00:09:39,190 --> 00:09:42,940
programmers that are like typescript

00:09:40,930 --> 00:09:45,490
lets me do Java and c-sharp which it

00:09:42,940 --> 00:09:48,010
does right it has all of the typing

00:09:45,490 --> 00:09:49,510
features one would expect generics of

00:09:48,010 --> 00:09:52,120
very sophisticated form of generics

00:09:49,510 --> 00:09:54,160
they've done a ton of work to be able to

00:09:52,120 --> 00:09:56,620
type relatively sophisticated functional

00:09:54,160 --> 00:09:59,050
patterns so there's very good coverage

00:09:56,620 --> 00:10:01,500
on Java stuff semantics but it lets you

00:09:59,050 --> 00:10:04,150
if you wanted to you could do full-on

00:10:01,500 --> 00:10:05,590
factory factory factory style java

00:10:04,150 --> 00:10:07,930
programming or c-sharp programming

00:10:05,590 --> 00:10:10,510
typescript enables that so mike so my

00:10:07,930 --> 00:10:12,040
question is is the is that number based

00:10:10,510 --> 00:10:13,660
off an influx of people who are like

00:10:12,040 --> 00:10:16,450
finally enterprise programming in

00:10:13,660 --> 00:10:18,400
JavaScript and again I'm not saying

00:10:16,450 --> 00:10:19,810
that's a good or bad thing but it's

00:10:18,400 --> 00:10:22,600
interesting because what does it mean

00:10:19,810 --> 00:10:25,030
for the evolution of JavaScript and how

00:10:22,600 --> 00:10:28,090
we use in how we think about it you know

00:10:25,030 --> 00:10:31,630
is the end game for JavaScript that

00:10:28,090 --> 00:10:34,630
javascript is basically a slightly more

00:10:31,630 --> 00:10:37,990
expressive you know Java or C sharp is

00:10:34,630 --> 00:10:40,930
that really the high-water mark for this

00:10:37,990 --> 00:10:42,760
language one interesting property of

00:10:40,930 --> 00:10:44,770
typescript and typescript is very cool

00:10:42,760 --> 00:10:45,910
bit of technology is that the thing that

00:10:44,770 --> 00:10:47,140
I like about typescript

00:10:45,910 --> 00:10:49,090
is that it has this thing called

00:10:47,140 --> 00:10:51,640
interface so you don't have to make a

00:10:49,090 --> 00:10:54,820
class so the interface allows you to

00:10:51,640 --> 00:10:56,940
decouple the shape of the thing you want

00:10:54,820 --> 00:10:59,260
to talk about from having to make any

00:10:56,940 --> 00:11:02,020
class for that thing and that's actually

00:10:59,260 --> 00:11:04,270
really big it means I mean you could say

00:11:02,020 --> 00:11:04,990
oh that lets me write take an existing

00:11:04,270 --> 00:11:07,480
untie

00:11:04,990 --> 00:11:09,220
program and make it type and that's one

00:11:07,480 --> 00:11:12,850
way to think about it another way to

00:11:09,220 --> 00:11:15,220
think about it is it lets you stay sort

00:11:12,850 --> 00:11:18,580
of data oriented you can focus on

00:11:15,220 --> 00:11:21,640
writing a data oriented functional sort

00:11:18,580 --> 00:11:24,820
of program and typescript allows you to

00:11:21,640 --> 00:11:27,070
express specifications about that

00:11:24,820 --> 00:11:28,900
without having to write a bunch of class

00:11:27,070 --> 00:11:31,090
oriented boilerplate right you can just

00:11:28,900 --> 00:11:32,830
write an object literal that has the

00:11:31,090 --> 00:11:34,570
properties you want you can write the

00:11:32,830 --> 00:11:37,480
type script interface for that and

00:11:34,570 --> 00:11:39,310
you're gonna get a nice specification a

00:11:37,480 --> 00:11:41,770
nice compile time error and I think

00:11:39,310 --> 00:11:44,290
that's really really nice and I'm

00:11:41,770 --> 00:11:45,910
curious again I don't use typescript and

00:11:44,290 --> 00:11:49,510
the survey didn't doesn't drill into

00:11:45,910 --> 00:11:51,580
this dimension is is that something that

00:11:49,510 --> 00:11:54,340
people are going to really embrace that

00:11:51,580 --> 00:11:56,590
typescript really does because of that

00:11:54,340 --> 00:11:58,420
feature interface it lets you think

00:11:56,590 --> 00:12:00,700
about constructing your type-check

00:11:58,420 --> 00:12:03,070
programs very differently if you were

00:12:00,700 --> 00:12:05,590
open to this idea than you would be if

00:12:03,070 --> 00:12:09,930
you were just had your Java or C sharp

00:12:05,590 --> 00:12:12,400
glasses on but in the end in the end

00:12:09,930 --> 00:12:13,690
even even if you go even if you do that

00:12:12,400 --> 00:12:15,160
way and I think that is interesting as

00:12:13,690 --> 00:12:19,470
an intranet would be an interesting way

00:12:15,160 --> 00:12:21,400
to think about typed JavaScript programs

00:12:19,470 --> 00:12:23,200
the question remains

00:12:21,400 --> 00:12:25,960
I mean what's what's really next right

00:12:23,200 --> 00:12:29,860
once JavaScript got async/await and once

00:12:25,960 --> 00:12:31,060
JavaScript got modules it becomes harder

00:12:29,860 --> 00:12:32,380
and harder and now that typescript is

00:12:31,060 --> 00:12:34,950
available and you can have comprehensive

00:12:32,380 --> 00:12:38,350
typing of all interesting major

00:12:34,950 --> 00:12:39,970
JavaScript idioms what's really next for

00:12:38,350 --> 00:12:41,920
JavaScript as a programming language a

00:12:39,970 --> 00:12:44,410
significant that's not about like

00:12:41,920 --> 00:12:46,330
platform stuff wasm of course there's a

00:12:44,410 --> 00:12:47,590
ton of work to do there concurrency

00:12:46,330 --> 00:12:50,340
there's a ton of work to do there and

00:12:47,590 --> 00:12:53,710
possibly things like okay we want long

00:12:50,340 --> 00:12:55,180
or Numa you enhance numerix because

00:12:53,710 --> 00:12:57,700
again that actually is more about

00:12:55,180 --> 00:13:00,070
platform stuff but purely from the

00:12:57,700 --> 00:13:01,570
standpoint of features that the language

00:13:00,070 --> 00:13:04,960
provides that help you solve problems

00:13:01,570 --> 00:13:06,760
differently what more can JavaScript

00:13:04,960 --> 00:13:09,400
really provide and I would actually

00:13:06,760 --> 00:13:11,800
argue given how long it took to even get

00:13:09,400 --> 00:13:14,080
to a single weight as well as modules

00:13:11,800 --> 00:13:17,530
because there's so many stakeholders I

00:13:14,080 --> 00:13:18,940
mean Google Apple Mozilla and Microsoft

00:13:17,530 --> 00:13:21,660
they all have to be ok

00:13:18,940 --> 00:13:23,800
anything that gets proposed to tc39

00:13:21,660 --> 00:13:25,060
anybody on any of those people vetoes it

00:13:23,800 --> 00:13:29,530
it's unlikely to happen because they

00:13:25,060 --> 00:13:30,880
implement the VMS so my my you know

00:13:29,530 --> 00:13:33,790
looking into the crystal ball is that

00:13:30,880 --> 00:13:35,560
actually I suspect innovation for

00:13:33,790 --> 00:13:36,880
JavaScript as the language is probably

00:13:35,560 --> 00:13:38,650
going to slow down to a snail's pace

00:13:36,880 --> 00:13:42,520
you'll probably see some syntactic sugar

00:13:38,650 --> 00:13:44,110
you may see some minor additions but I

00:13:42,520 --> 00:13:45,610
don't see that much happening and this

00:13:44,110 --> 00:13:48,280
is the moment where I think you can say

00:13:45,610 --> 00:13:51,220
look at the existing ecosystem of

00:13:48,280 --> 00:13:53,440
JavaScript as a platform and say okay we

00:13:51,220 --> 00:13:55,690
love the ecosystem we love the platform

00:13:53,440 --> 00:13:57,790
the technology but maybe it's time for

00:13:55,690 --> 00:13:59,110
us to be like we can do all the stuff we

00:13:57,790 --> 00:14:01,270
were doing but maybe we should assess

00:13:59,110 --> 00:14:04,300
our pure script closure script because

00:14:01,270 --> 00:14:06,700
those give us new tools new insights on

00:14:04,300 --> 00:14:09,160
how to write simpler problems sorry

00:14:06,700 --> 00:14:12,610
simple simpler programs that solve the

00:14:09,160 --> 00:14:14,500
same problems more effectively so the

00:14:12,610 --> 00:14:16,090
last bit of my talk is gonna show some

00:14:14,500 --> 00:14:17,770
closure script you don't have to no

00:14:16,090 --> 00:14:19,720
closure script it's it's not important

00:14:17,770 --> 00:14:22,090
all I want to demonstrate are some

00:14:19,720 --> 00:14:24,310
features of closure script that I now

00:14:22,090 --> 00:14:26,140
consider essential that in fact are

00:14:24,310 --> 00:14:28,120
missing from JavaScript without me doing

00:14:26,140 --> 00:14:29,230
a bunch of like boilerplate work that I

00:14:28,120 --> 00:14:30,820
don't think is interesting I'd rather

00:14:29,230 --> 00:14:33,460
just use a thing that solves that

00:14:30,820 --> 00:14:35,770
problem for me so I can just focus on my

00:14:33,460 --> 00:14:38,440
problem domain so there's three key

00:14:35,770 --> 00:14:43,990
things that I'd like to talk about the

00:14:38,440 --> 00:14:45,310
repple equality and specification so you

00:14:43,990 --> 00:14:46,810
know I suspect there'll be a lot of

00:14:45,310 --> 00:14:48,070
talks about typescript in the previous

00:14:46,810 --> 00:14:50,920
talk with also by typescript again

00:14:48,070 --> 00:14:53,440
typescript es6 all this stuff is cool I

00:14:50,920 --> 00:14:56,530
want to show you simply a different way

00:14:53,440 --> 00:14:57,850
a different way of thinking about the

00:14:56,530 --> 00:14:59,920
same types of problems you might want to

00:14:57,850 --> 00:15:01,660
solve but with different set of tools so

00:14:59,920 --> 00:15:03,220
the first thing is the repple so you all

00:15:01,660 --> 00:15:05,290
are familiar with the node repple you

00:15:03,220 --> 00:15:06,970
fire off node you use it you get to

00:15:05,290 --> 00:15:08,650
check a couple things but the thing is

00:15:06,970 --> 00:15:11,140
it's that's very different from how a

00:15:08,650 --> 00:15:13,240
list programmer or say a small talk

00:15:11,140 --> 00:15:14,830
programmer thinks about this like if

00:15:13,240 --> 00:15:17,650
you've ever seen Dan Ingalls talk about

00:15:14,830 --> 00:15:20,320
small talk you should run and see that

00:15:17,650 --> 00:15:21,670
if you haven't seen that yet and you

00:15:20,320 --> 00:15:23,590
know the idea there was that the

00:15:21,670 --> 00:15:25,960
programming system should be alive it's

00:15:23,590 --> 00:15:27,220
a living thing like it's not just I load

00:15:25,960 --> 00:15:30,340
a repple and I test a thing

00:15:27,220 --> 00:15:32,320
but really the repple is in a hole in

00:15:30,340 --> 00:15:36,279
interactive environment that's just on

00:15:32,320 --> 00:15:43,449
all the time so here in the background

00:15:36,279 --> 00:15:46,690
I have to is I'm sorry one second here

00:15:43,449 --> 00:15:49,000
in the background I have the browser

00:15:46,690 --> 00:15:53,079
open here Chrome I have Chrome open and

00:15:49,000 --> 00:15:55,449
it's on this page and I can type in an

00:15:53,079 --> 00:16:02,399
expression here and I'm gonna tell a j/o

00:15:55,449 --> 00:16:02,399
but let's let's start this again sorry

00:16:07,999 --> 00:16:11,109
sorry one second

00:16:25,520 --> 00:16:30,070
so here I have chrome and then let's see

00:16:27,709 --> 00:16:33,110
that this is this worse

00:16:30,070 --> 00:16:35,420
yes so what's interesting here is that

00:16:33,110 --> 00:16:36,830
so that you start node but I have the

00:16:35,420 --> 00:16:39,680
same thing that you would have and

00:16:36,830 --> 00:16:43,399
notice if I have it in my editor right

00:16:39,680 --> 00:16:45,680
I'm in my my my actual development

00:16:43,399 --> 00:16:51,520
environment and I have a repple and I

00:16:45,680 --> 00:16:53,779
can for example load this file right and

00:16:51,520 --> 00:16:55,279
all of this has been evaluated I've

00:16:53,779 --> 00:16:58,250
loaded ODEs if you're not you don't see

00:16:55,279 --> 00:17:06,459
anything sorry somebody should have said

00:16:58,250 --> 00:17:06,459
something let's fix this displays

00:17:06,699 --> 00:17:14,439
arrangement mirrored sorry about that

00:17:11,000 --> 00:17:14,439
okay that's better

00:17:15,459 --> 00:17:20,780
all right let me speed this up and let

00:17:18,980 --> 00:17:24,140
me just repeat what I just said so here

00:17:20,780 --> 00:17:26,720
I have Chrome it's open here I'm an

00:17:24,140 --> 00:17:29,000
intelligent in my in my in my source

00:17:26,720 --> 00:17:32,150
code editor I have a repple here I've

00:17:29,000 --> 00:17:34,490
loaded this file I can run expressions

00:17:32,150 --> 00:17:36,710
and what's happening is that this this

00:17:34,490 --> 00:17:38,929
repple has a connection to Chrome and

00:17:36,710 --> 00:17:40,460
it's compiling the JavaScript on the fly

00:17:38,929 --> 00:17:43,520
it's evaluating and returning here so

00:17:40,460 --> 00:17:46,010
that I can work from this text editor so

00:17:43,520 --> 00:17:49,730
I can put my cursor here I can switch

00:17:46,010 --> 00:17:54,350
into this library and I can evaluate

00:17:49,730 --> 00:17:56,300
these expressions right so so my first

00:17:54,350 --> 00:17:59,720
demo here is equality for all where I

00:17:56,300 --> 00:18:01,370
show that like I want equality to make

00:17:59,720 --> 00:18:03,170
sense in the sense that like in

00:18:01,370 --> 00:18:06,020
JavaScript you know this was something

00:18:03,170 --> 00:18:07,910
you can't fix equality was set so long

00:18:06,020 --> 00:18:10,730
ago there's no fixing it without

00:18:07,910 --> 00:18:12,490
breaking the internet enclosure script

00:18:10,730 --> 00:18:15,679
this is something that enclosure

00:18:12,490 --> 00:18:17,929
equality was just done right from the

00:18:15,679 --> 00:18:20,300
beginning so think there's no coercion

00:18:17,929 --> 00:18:21,950
equality is not coercive one is never

00:18:20,300 --> 00:18:23,900
going to be the blank string I don't

00:18:21,950 --> 00:18:27,679
have to use a special equality operator

00:18:23,900 --> 00:18:31,670
zero is never going to be equal to false

00:18:27,679 --> 00:18:34,580
right no coercion but more importantly I

00:18:31,670 --> 00:18:36,140
can take compound values right I can

00:18:34,580 --> 00:18:38,300
take two vectors and these are the

00:18:36,140 --> 00:18:39,259
exactly the same as JavaScript arrays

00:18:38,300 --> 00:18:42,200
but there are Moodle

00:18:39,259 --> 00:18:44,360
and I can say are these the same I don't

00:18:42,200 --> 00:18:46,580
need to go find a third-party library to

00:18:44,360 --> 00:18:49,549
check to values right so if you've

00:18:46,580 --> 00:18:51,950
written any non-trivial UI program

00:18:49,549 --> 00:18:53,389
you're like is this domain entity the

00:18:51,950 --> 00:18:55,519
same as the domain entity that I

00:18:53,389 --> 00:18:57,440
currently have right and you have to go

00:18:55,519 --> 00:19:00,110
find something or you're writing tests

00:18:57,440 --> 00:19:02,570
this very common in tests even more so

00:19:00,110 --> 00:19:04,279
than inside of your program is the value

00:19:02,570 --> 00:19:07,399
that gets returned this same as my

00:19:04,279 --> 00:19:09,860
example value and the fact that I don't

00:19:07,399 --> 00:19:12,080
have to do anything it's just a

00:19:09,860 --> 00:19:14,960
fundamental feature of the language is

00:19:12,080 --> 00:19:16,909
great down here I have a map it has a

00:19:14,960 --> 00:19:18,440
foo and blah blah blah so I can do the

00:19:16,909 --> 00:19:18,919
same thing for maps that's not that

00:19:18,440 --> 00:19:22,669
interesting

00:19:18,919 --> 00:19:24,769
but down here I can do complex keys so

00:19:22,669 --> 00:19:27,259
in JavaScript with JavaScript objects

00:19:24,769 --> 00:19:30,350
you can only have string based keys and

00:19:27,259 --> 00:19:32,629
that really limits how you can use the

00:19:30,350 --> 00:19:34,820
object inside of an algorithm right so a

00:19:32,629 --> 00:19:37,009
lot of times people say in order to

00:19:34,820 --> 00:19:39,590
write a good algorithm use the right

00:19:37,009 --> 00:19:43,249
data structure right so because I can

00:19:39,590 --> 00:19:45,379
embed complex keys I can often shape the

00:19:43,249 --> 00:19:47,029
map so that it fits the algorithm that

00:19:45,379 --> 00:19:50,149
I'm writing I don't have to go through

00:19:47,029 --> 00:19:53,929
some convoluted thing so here I can say

00:19:50,149 --> 00:19:56,960
find the item that has the key which is

00:19:53,929 --> 00:19:59,059
a vector with 1 & 2 and it gives me the

00:19:56,960 --> 00:20:01,460
value that I expect you may think that

00:19:59,059 --> 00:20:03,980
this works with es6 Maps but this is not

00:20:01,460 --> 00:20:07,129
true if you've ever tried to use the x6

00:20:03,980 --> 00:20:09,499
maps it's in my opinion completely

00:20:07,129 --> 00:20:12,109
broken so here I'm gonna make an es6 map

00:20:09,499 --> 00:20:13,940
and I'm gonna go get this is a

00:20:12,109 --> 00:20:16,129
JavaScript array this is not a this is

00:20:13,940 --> 00:20:18,289
not a vector this the j/s says make a

00:20:16,129 --> 00:20:20,600
JavaScript array and it made this map

00:20:18,289 --> 00:20:22,279
and I say give me the value that has the

00:20:20,600 --> 00:20:26,389
JavaScript array 1 2 and I get back

00:20:22,279 --> 00:20:29,840
nothing because es6 Maps only do look up

00:20:26,389 --> 00:20:32,989
by reference right I cannot use es6 map

00:20:29,840 --> 00:20:36,109
2 in algorithms out-of-the-box I can't

00:20:32,989 --> 00:20:37,909
use it in an interesting way and to me

00:20:36,109 --> 00:20:39,559
the fact that this was even shipped is

00:20:37,909 --> 00:20:40,779
this is definitely one of those cases

00:20:39,559 --> 00:20:43,100
where I have a lot of criticism because

00:20:40,779 --> 00:20:45,859
even you can do this in Java you can do

00:20:43,100 --> 00:20:48,259
this in Objective C but es6 maps are and

00:20:45,859 --> 00:20:51,200
sets because the same implementation

00:20:48,259 --> 00:20:52,919
really they're broken I have to pass the

00:20:51,200 --> 00:20:56,100
original array

00:20:52,919 --> 00:20:58,440
to get the thing that I want okay so

00:20:56,100 --> 00:21:00,240
lets we talked about that and i want to

00:20:58,440 --> 00:21:01,320
move quickly to specifications so this

00:21:00,240 --> 00:21:03,990
is going to be interesting for people

00:21:01,320 --> 00:21:04,880
who do typescript or interested in

00:21:03,990 --> 00:21:08,010
typescript

00:21:04,880 --> 00:21:09,960
so what does closure script offer for

00:21:08,010 --> 00:21:11,700
specification right we don't do with the

00:21:09,960 --> 00:21:13,740
dynamic programming language we don't do

00:21:11,700 --> 00:21:15,480
compile time checking you can use this

00:21:13,740 --> 00:21:17,309
for compile time checking and people

00:21:15,480 --> 00:21:19,830
have done it that's not its main purpose

00:21:17,309 --> 00:21:21,480
you can use it for that but I want to

00:21:19,830 --> 00:21:24,150
demonstrate things that are impossible

00:21:21,480 --> 00:21:26,340
to do or nearly impossible with a

00:21:24,150 --> 00:21:27,870
traditional compile time check type

00:21:26,340 --> 00:21:29,730
system so here I'm gonna make a

00:21:27,870 --> 00:21:31,950
specification for this thing called

00:21:29,730 --> 00:21:33,929
first name it has to be a string and

00:21:31,950 --> 00:21:36,450
last name these are going to be keys

00:21:33,929 --> 00:21:38,340
inside of a map and typescript

00:21:36,450 --> 00:21:40,890
typescript that would be like interface

00:21:38,340 --> 00:21:43,020
person first name last name cool they

00:21:40,890 --> 00:21:47,130
have to be strings this is semantically

00:21:43,020 --> 00:21:49,080
the same thing I am a person is a map a

00:21:47,130 --> 00:21:52,770
clojurescript map that has these two

00:21:49,080 --> 00:21:56,220
keys first name last name then I go is

00:21:52,770 --> 00:21:59,340
this is this map with just Bob a valid

00:21:56,220 --> 00:22:03,630
person it better be no because there's

00:21:59,340 --> 00:22:05,370
no last name down here I say explain to

00:22:03,630 --> 00:22:08,789
me why that that that's not a valid

00:22:05,370 --> 00:22:12,090
person and it tells me a person needs to

00:22:08,789 --> 00:22:15,270
have a last name right so I have a very

00:22:12,090 --> 00:22:17,190
succinct way for taking some data I

00:22:15,270 --> 00:22:19,500
might have written this data a year ago

00:22:17,190 --> 00:22:21,480
but I have a specification mechanism

00:22:19,500 --> 00:22:23,730
that lets me now talk about what that

00:22:21,480 --> 00:22:24,870
stuff should look like very similar type

00:22:23,730 --> 00:22:27,120
script this idea of doing something

00:22:24,870 --> 00:22:28,980
gradually you wrote a program now you

00:22:27,120 --> 00:22:31,049
want some more clarity about the meaning

00:22:28,980 --> 00:22:34,770
of the program you can do this so down

00:22:31,049 --> 00:22:36,809
here I go is this valid and it's true

00:22:34,770 --> 00:22:41,220
I'm gonna add a new thing called school

00:22:36,809 --> 00:22:44,429
and then okay nice and then what's a

00:22:41,220 --> 00:22:45,450
teacher we can reuse specs so you can't

00:22:44,429 --> 00:22:46,380
do this in typescript

00:22:45,450 --> 00:22:49,470
you can't just make a bunch of

00:22:46,380 --> 00:22:50,940
interfaces and say this interface is not

00:22:49,470 --> 00:22:51,779
I mean inheritance we were only want to

00:22:50,940 --> 00:22:53,100
talk about inheritance I don't really

00:22:51,779 --> 00:22:56,760
care about the inheritance relationship

00:22:53,100 --> 00:22:58,919
I just want to reuse an existing set of

00:22:56,760 --> 00:23:01,380
specifications and add one new piece of

00:22:58,919 --> 00:23:02,820
information like there's no real way to

00:23:01,380 --> 00:23:04,200
do there's a type script if you know

00:23:02,820 --> 00:23:06,120
about it please tell me I looked I

00:23:04,200 --> 00:23:08,400
looked around at the documentation but

00:23:06,120 --> 00:23:11,190
couldn't see a way to do this so here I

00:23:08,400 --> 00:23:16,110
say a teacher is a person who also has a

00:23:11,190 --> 00:23:17,429
school this person is not a teacher

00:23:16,110 --> 00:23:22,140
because they only have first and last

00:23:17,429 --> 00:23:26,279
name but this one this one is right

00:23:22,140 --> 00:23:28,830
because there's a school so to take it

00:23:26,279 --> 00:23:30,809
one step further you know types are

00:23:28,830 --> 00:23:33,120
great because they do really serve two

00:23:30,809 --> 00:23:34,830
purposes one purpose is for the computer

00:23:33,120 --> 00:23:37,529
the computer checks that all your types

00:23:34,830 --> 00:23:39,539
match ok that's cool and you you get the

00:23:37,529 --> 00:23:42,240
person gets that back but really to me

00:23:39,539 --> 00:23:44,490
the most valuable thing about types are

00:23:42,240 --> 00:23:45,899
their function as a specification that

00:23:44,490 --> 00:23:47,760
when I look at somebody's code without

00:23:45,899 --> 00:23:50,450
compiling the code without running it or

00:23:47,760 --> 00:23:53,399
doing anything the types tell me

00:23:50,450 --> 00:23:55,860
something about what the original author

00:23:53,399 --> 00:23:57,990
intended it's a form of documentation I

00:23:55,860 --> 00:23:59,669
actually think that is far more

00:23:57,990 --> 00:24:00,840
important than the compile time track

00:23:59,669 --> 00:24:02,850
type checking I don't think it's not

00:24:00,840 --> 00:24:04,669
important but I think the documentation

00:24:02,850 --> 00:24:07,350
part is the most important because again

00:24:04,669 --> 00:24:10,230
programming is a social activity how do

00:24:07,350 --> 00:24:12,419
we communicate with other programmers so

00:24:10,230 --> 00:24:14,549
down here I'm showing you that we can

00:24:12,419 --> 00:24:18,000
take our specs and we can annotate them

00:24:14,549 --> 00:24:20,760
so not only can I tell somebody this is

00:24:18,000 --> 00:24:22,890
what I meant you can take my spec and

00:24:20,760 --> 00:24:24,090
you can make examples from it right this

00:24:22,890 --> 00:24:24,779
is something you can't do with

00:24:24,090 --> 00:24:27,840
typescript

00:24:24,779 --> 00:24:31,620
or in most type systems so here I go ok

00:24:27,840 --> 00:24:34,049
first name last name and school and for

00:24:31,620 --> 00:24:36,510
each of these I now provide a set of

00:24:34,049 --> 00:24:40,409
example values down here I can say

00:24:36,510 --> 00:24:44,929
generate me a first name generate me a

00:24:40,409 --> 00:24:48,000
person write and generate me a teacher

00:24:44,929 --> 00:24:49,440
like that's that's amazing right I can

00:24:48,000 --> 00:24:51,210
jump to anybody's code if they gave me a

00:24:49,440 --> 00:24:52,710
spec and they took the time to document

00:24:51,210 --> 00:24:55,620
what the examples should look like

00:24:52,710 --> 00:24:57,600
I can generate the example right so many

00:24:55,620 --> 00:24:59,789
times in a look at API it's a convoluted

00:24:57,600 --> 00:25:01,200
domain object and I have to go find a

00:24:59,789 --> 00:25:03,750
test copy and paste this thing to figure

00:25:01,200 --> 00:25:05,760
out what does the thing actually look

00:25:03,750 --> 00:25:08,850
like the types don't tell me enough

00:25:05,760 --> 00:25:10,529
right and it's very tedious here we're

00:25:08,850 --> 00:25:12,899
really adding a next level of

00:25:10,529 --> 00:25:14,880
documentation to the specification that

00:25:12,899 --> 00:25:17,580
we're making so just to wrap it up I

00:25:14,880 --> 00:25:19,440
know I'm running out of time so here I

00:25:17,580 --> 00:25:22,020
have a function that takes a

00:25:19,440 --> 00:25:24,270
sure and extracts the school okay

00:25:22,020 --> 00:25:25,980
whatever so here I'm saying I want to

00:25:24,270 --> 00:25:28,260
specify that this has to be teacher

00:25:25,980 --> 00:25:30,390
notice that the function itself isn't

00:25:28,260 --> 00:25:32,520
annotated in any sort of way but I'm

00:25:30,390 --> 00:25:34,590
able to provide a spec after the fact

00:25:32,520 --> 00:25:36,420
and I think people often want to munge

00:25:34,590 --> 00:25:38,730
the types and the specification together

00:25:36,420 --> 00:25:41,520
and I think when you separate them

00:25:38,730 --> 00:25:43,530
there's a lot of power for example this

00:25:41,520 --> 00:25:45,150
spec actually can be used from closure a

00:25:43,530 --> 00:25:47,910
closure script we can use aspects

00:25:45,150 --> 00:25:49,470
anywhere anywhere right they don't have

00:25:47,910 --> 00:25:51,420
to doesn't matter which platform we're

00:25:49,470 --> 00:25:52,980
targeting and by keeping them separate

00:25:51,420 --> 00:25:55,050
that's actually very valuable because it

00:25:52,980 --> 00:25:57,600
may be the case that the platform

00:25:55,050 --> 00:25:59,310
implementations are different so here

00:25:57,600 --> 00:26:01,200
I'm going to instrument this tÃªte this

00:25:59,310 --> 00:26:03,600
function saying I want this to be

00:26:01,200 --> 00:26:07,530
checked here I can say generate a person

00:26:03,600 --> 00:26:10,140
and I want to call that function and

00:26:07,530 --> 00:26:12,840
it's gonna fail because teacher to

00:26:10,140 --> 00:26:17,220
school expects a teacher not a person

00:26:12,840 --> 00:26:19,230
and if I run the second one it's gonna

00:26:17,220 --> 00:26:21,930
work because that person has a school

00:26:19,230 --> 00:26:23,460
and finally this test is a broken test

00:26:21,930 --> 00:26:25,050
right you would think oh it's not

00:26:23,460 --> 00:26:26,850
compile time checking but with

00:26:25,050 --> 00:26:28,530
instrumentation you have to write tests

00:26:26,850 --> 00:26:30,120
anyway I don't care I don't care how

00:26:28,530 --> 00:26:31,860
many types you have right for your

00:26:30,120 --> 00:26:34,410
domain business logic you're gonna have

00:26:31,860 --> 00:26:36,390
to write tests anyway so instrumentation

00:26:34,410 --> 00:26:40,790
gives us this ability when we run the

00:26:36,390 --> 00:26:42,750
test we can get this this feeling of

00:26:40,790 --> 00:26:45,810
interactive checking because here it

00:26:42,750 --> 00:26:47,520
says teacher to school down here this

00:26:45,810 --> 00:26:49,230
doesn't conform to this spec because it

00:26:47,520 --> 00:26:54,540
doesn't contain a school so let me fix

00:26:49,230 --> 00:26:58,710
my test school bar right are we to find

00:26:54,540 --> 00:27:01,470
the test I rerun the test boom and

00:26:58,710 --> 00:27:04,140
notice I never left my text editor like

00:27:01,470 --> 00:27:06,990
this idea of I run a rep 'l only to test

00:27:04,140 --> 00:27:09,360
snippets it's just not how I work don't

00:27:06,990 --> 00:27:11,190
what you just saw is exactly how I

00:27:09,360 --> 00:27:13,500
actually program it's actually when I

00:27:11,190 --> 00:27:15,270
sit down to work everything that you saw

00:27:13,500 --> 00:27:17,700
me do is how I sit down and solve

00:27:15,270 --> 00:27:20,160
problems and hopefully again it does not

00:27:17,700 --> 00:27:22,650
use closure or use closure script it's

00:27:20,160 --> 00:27:25,830
compare my approach to solving problems

00:27:22,650 --> 00:27:29,010
to the set of tools that you have for

00:27:25,830 --> 00:27:30,810
solving problems and maybe I mean

00:27:29,010 --> 00:27:32,870
ideally this pick this could influence

00:27:30,810 --> 00:27:35,480
the way that you know hopefully

00:27:32,870 --> 00:27:37,400
wrong that that that javascript has a

00:27:35,480 --> 00:27:38,990
lot more to learn as a lot more to grow

00:27:37,400 --> 00:27:41,600
some of these things can happen through

00:27:38,990 --> 00:27:43,130
tc39 perhaps some of the things on

00:27:41,600 --> 00:27:45,710
demonstrating are just you writing a

00:27:43,130 --> 00:27:48,230
library saying that's a great idea we

00:27:45,710 --> 00:27:50,150
should embrace that again

00:27:48,230 --> 00:27:51,530
just some controversial statements like

00:27:50,150 --> 00:27:53,510
I've been I've been doing functional

00:27:51,530 --> 00:27:55,220
programming for a long time now for all

00:27:53,510 --> 00:27:57,890
types of work you I work back and work

00:27:55,220 --> 00:27:59,720
systems doesn't really matter but I

00:27:57,890 --> 00:28:02,900
haven't used classes or inheritance in

00:27:59,720 --> 00:28:04,400
years data all the things I think this

00:28:02,900 --> 00:28:06,830
is really important you should try this

00:28:04,400 --> 00:28:09,410
in JavaScript don't don't use that stuff

00:28:06,830 --> 00:28:11,510
no unmanaged state so people you use

00:28:09,410 --> 00:28:13,550
mutation so if you like redux

00:28:11,510 --> 00:28:15,650
why is Redux the only place where you

00:28:13,550 --> 00:28:16,910
use managed state transitions what

00:28:15,650 --> 00:28:19,670
happens if you use men and state

00:28:16,910 --> 00:28:20,990
transitions everywhere all the time does

00:28:19,670 --> 00:28:23,390
your program become easier to reason

00:28:20,990 --> 00:28:25,010
about and finally generality of

00:28:23,390 --> 00:28:27,140
specifications versus compile time

00:28:25,010 --> 00:28:29,059
checking only of types this is not anti

00:28:27,140 --> 00:28:31,280
compiled teching of type types I'm not

00:28:29,059 --> 00:28:33,679
anti that but hopefully I demonstrated

00:28:31,280 --> 00:28:36,290
some things that I know you will must

00:28:33,679 --> 00:28:38,870
know that it's very difficult to do with

00:28:36,290 --> 00:28:40,920
traditional type systems that's it I

00:28:38,870 --> 00:28:45,199
went over sorry but thank you

00:28:40,920 --> 00:28:45,199

YouTube URL: https://www.youtube.com/watch?v=ynhhuVQL3Y0


