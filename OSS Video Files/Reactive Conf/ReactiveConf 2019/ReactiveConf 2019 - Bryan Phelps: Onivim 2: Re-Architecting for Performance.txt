Title: ReactiveConf 2019 - Bryan Phelps: Onivim 2: Re-Architecting for Performance
Publication date: 2019-10-30
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Discovery stage
-------------------------------------------------------------------
Electron is one of the most popular platforms today for building cross-platform desktop applications. We shipped v1 of our code editor, Onivim, using Electron, and while it was wonderful to leverage web technologies and frameworks like ReactJS, we faced numerous performance challenges.

In order to meet our performance goals, we decided to re-architect and move to a native solution based on ReasonML. In the process, we built a new desktop application framework called Revery, which lets us enjoy the ReactJS & Redux style of development… but with native code performance! This move has drastically improved our startup time, responsiveness, and memory usage. In addition, we’ve been able to take a new approach to our core architecture – leveraging functional programming principles.

We’ll discuss our journey of shipping a cross-platform desktop app with this new technology stack, and share our successes and challenges in migrating from TypeScript/React/Electron to ReasonML/Revery for Onivim v2.
Captions: 
	00:00:02,720 --> 00:00:11,850
[Music]

00:00:14,200 --> 00:00:20,150
there we go

00:00:16,330 --> 00:00:22,759
hey reactive Kampf it's great to be here

00:00:20,150 --> 00:00:24,829
my name is Brian Phelps and I'm really

00:00:22,759 --> 00:00:26,689
excited to be here today to talk to you

00:00:24,829 --> 00:00:29,750
about a code editor I've been working on

00:00:26,689 --> 00:00:31,789
called own even I'm gonna share with you

00:00:29,750 --> 00:00:34,910
today how we re architected for

00:00:31,789 --> 00:00:36,199
performance not only is it faster but

00:00:34,910 --> 00:00:40,940
we're getting a cleaner application

00:00:36,199 --> 00:00:42,650
architecture out of it too and I'm the

00:00:40,940 --> 00:00:45,110
founder of a company called outrun labs

00:00:42,650 --> 00:00:47,809
before that I was working at Microsoft

00:00:45,110 --> 00:00:50,360
on a variety of cross platform and web

00:00:47,809 --> 00:00:56,030
applications you can find me on Twitter

00:00:50,360 --> 00:00:57,290
github discord as brief and here's an

00:00:56,030 --> 00:00:59,570
overview of what I'll be discussing

00:00:57,290 --> 00:01:01,850
today first I'll give you some

00:00:59,570 --> 00:01:04,089
background on owning them just enough so

00:01:01,850 --> 00:01:06,979
we can talk about the architecture

00:01:04,089 --> 00:01:10,610
second I'll describe our v1 architecture

00:01:06,979 --> 00:01:11,960
and the sort of challenges we faced and

00:01:10,610 --> 00:01:13,759
finally I'll talk about our v2

00:01:11,960 --> 00:01:18,470
architecture and the changes we've made

00:01:13,759 --> 00:01:18,860
and the results we had so what is only

00:01:18,470 --> 00:01:21,590
them

00:01:18,860 --> 00:01:24,200
it's a code editor but it's kind of an

00:01:21,590 --> 00:01:27,800
issue one names combine a few different

00:01:24,200 --> 00:01:31,130
worlds the first world is modal editing

00:01:27,800 --> 00:01:32,600
like vim it's kind of old-school but a

00:01:31,130 --> 00:01:34,940
modal editor is one that has different

00:01:32,600 --> 00:01:37,670
modes and insert mode is one we're used

00:01:34,940 --> 00:01:41,300
to in like vs code notepad word where

00:01:37,670 --> 00:01:43,040
you type in insert letters but modal

00:01:41,300 --> 00:01:45,140
editors have modes specifically for

00:01:43,040 --> 00:01:49,130
editing and navigating text too with

00:01:45,140 --> 00:01:51,710
just the keyboard the other world we

00:01:49,130 --> 00:01:54,409
want is a fast beautiful interface

00:01:51,710 --> 00:01:56,360
I think sublime text is the gold

00:01:54,409 --> 00:01:59,030
standard here it shows that you can have

00:01:56,360 --> 00:02:03,590
a GUI that's really fast and performing

00:01:59,030 --> 00:02:06,470
starts up instantly then we want top to

00:02:03,590 --> 00:02:08,509
your language support and vs code is the

00:02:06,470 --> 00:02:10,280
standard here it's just so good at

00:02:08,509 --> 00:02:15,680
understanding typescript and any

00:02:10,280 --> 00:02:17,209
language you throw at it and the

00:02:15,680 --> 00:02:19,220
ultimate vision for us is to be the

00:02:17,209 --> 00:02:21,650
fastest way to go from thoughta code to

00:02:19,220 --> 00:02:23,420
take your idea and put it on the code

00:02:21,650 --> 00:02:25,640
through this editor a tool that works

00:02:23,420 --> 00:02:27,980
for you always keeps up

00:02:25,640 --> 00:02:30,350
makes you wait or pauses or takes you

00:02:27,980 --> 00:02:33,380
out of the flow and it's been a journey

00:02:30,350 --> 00:02:34,610
and we're not there yet but for this

00:02:33,380 --> 00:02:36,470
talk I'd like to take you on that

00:02:34,610 --> 00:02:38,810
journey with me and share some of my

00:02:36,470 --> 00:02:40,130
thoughts and learnings along the way and

00:02:38,810 --> 00:02:42,830
hopefully even if you're not interested

00:02:40,130 --> 00:02:46,130
in editors of in the architecture pieces

00:02:42,830 --> 00:02:47,750
will at least be interesting so it's a

00:02:46,130 --> 00:02:52,280
wind a bit and talk about the start of

00:02:47,750 --> 00:02:55,160
the project rv1 so this is a screenshot

00:02:52,280 --> 00:02:58,730
of our v1 and it's really the same goals

00:02:55,160 --> 00:03:01,160
and visions we shipped our v1 as a cross

00:02:58,730 --> 00:03:03,709
platform electron app and we met some of

00:03:01,160 --> 00:03:06,290
these goals but really I think the most

00:03:03,709 --> 00:03:08,390
important outcome for our v1 was I found

00:03:06,290 --> 00:03:09,440
that there was a group of developers who

00:03:08,390 --> 00:03:13,670
were interested in this hybrid

00:03:09,440 --> 00:03:15,769
interested in this kind of initiator we

00:03:13,670 --> 00:03:17,720
also experiment with some fun ideas like

00:03:15,769 --> 00:03:19,489
vim and modal editing is historically

00:03:17,720 --> 00:03:20,989
like thought to be very hard to learn

00:03:19,489 --> 00:03:23,300
you have to learn all these key

00:03:20,989 --> 00:03:26,500
sequences and commands so we wanted to

00:03:23,300 --> 00:03:29,540
experiment with ways to make that easier

00:03:26,500 --> 00:03:32,120
but it wasn't perfect in particular we

00:03:29,540 --> 00:03:34,640
struggled with performance and it's a

00:03:32,120 --> 00:03:37,430
cool to hate on electron like I'm hacker

00:03:34,640 --> 00:03:38,750
news and stuff but the reality is there

00:03:37,430 --> 00:03:41,360
were issues that kept us from meeting

00:03:38,750 --> 00:03:43,220
that goal for our users part of the

00:03:41,360 --> 00:03:45,829
problem is that VM users have a very

00:03:43,220 --> 00:03:47,750
high bar for performance and so if we're

00:03:45,829 --> 00:03:51,320
not meeting that bar then we're asking

00:03:47,750 --> 00:03:53,209
them to make a sacrifice we sort of

00:03:51,320 --> 00:03:55,489
pursued more and more investments to get

00:03:53,209 --> 00:03:57,140
the performance that we wanted we also

00:03:55,489 --> 00:03:58,970
had some bugs around non-determinism

00:03:57,140 --> 00:04:00,739
with key presses which are the worst

00:03:58,970 --> 00:04:03,500
kind of bugs you can have in an editor

00:04:00,739 --> 00:04:05,299
and it was these combination of issues

00:04:03,500 --> 00:04:07,450
that let me to think about what an

00:04:05,299 --> 00:04:09,530
alternative architecture could look like

00:04:07,450 --> 00:04:14,989
so let's take a look at the tech stack

00:04:09,530 --> 00:04:17,780
of our v1 so we have a standard electron

00:04:14,989 --> 00:04:19,310
app which has two processes there's the

00:04:17,780 --> 00:04:22,160
main process which is sort of the

00:04:19,310 --> 00:04:24,140
orchestrator of that then there could be

00:04:22,160 --> 00:04:25,850
one or more render processes which are

00:04:24,140 --> 00:04:29,810
the actual like browser windows that you

00:04:25,850 --> 00:04:33,640
see we also had a separate node process

00:04:29,810 --> 00:04:33,640
that was our extension host

00:04:34,220 --> 00:04:38,480
and we used an open-source project

00:04:35,660 --> 00:04:42,380
called neo of em to handle all the vim

00:04:38,480 --> 00:04:47,180
heavy lifting for us let's zoom into

00:04:42,380 --> 00:04:49,490
that renderer piece so inside our render

00:04:47,180 --> 00:04:52,490
we had a pretty familiar web stack we

00:04:49,490 --> 00:04:55,790
used react and redux we use typescript

00:04:52,490 --> 00:04:57,680
compiled the JavaScript and for some

00:04:55,790 --> 00:04:59,390
performance critical pieces like the

00:04:57,680 --> 00:05:03,860
actual rendering of the editor surface

00:04:59,390 --> 00:05:06,140
we used WebGL and I really like this

00:05:03,860 --> 00:05:09,800
stack for web applications and for

00:05:06,140 --> 00:05:12,320
desktop applications and for the

00:05:09,800 --> 00:05:14,270
whatever hate electron gets the reality

00:05:12,320 --> 00:05:15,650
is it's never been easier for a small

00:05:14,270 --> 00:05:18,830
team to ship a cross-platform

00:05:15,650 --> 00:05:21,380
application and especially to be able to

00:05:18,830 --> 00:05:22,700
ship cross-platform with confidence what

00:05:21,380 --> 00:05:25,130
I mean by that is I can write my

00:05:22,700 --> 00:05:26,510
electron app on one platform and as long

00:05:25,130 --> 00:05:29,660
as I don't use a small set of

00:05:26,510 --> 00:05:31,100
platform-specific api's I can be pretty

00:05:29,660 --> 00:05:37,040
sure that it looks and feels the same

00:05:31,100 --> 00:05:39,200
everywhere and that's pretty huge but

00:05:37,040 --> 00:05:42,350
there were challenges for us otherwise I

00:05:39,200 --> 00:05:44,750
wouldn't be giving this talk as we built

00:05:42,350 --> 00:05:47,390
more and more the application would get

00:05:44,750 --> 00:05:49,760
slower to start and I kind of realized

00:05:47,390 --> 00:05:51,830
you don't really appreciate all that the

00:05:49,760 --> 00:05:53,750
browser or electron or a JavaScript

00:05:51,830 --> 00:05:57,110
engine is doing for you until you

00:05:53,750 --> 00:06:00,740
profile so let's check out a profile of

00:05:57,110 --> 00:06:02,720
the startup time so it's a little

00:06:00,740 --> 00:06:06,560
confusing because the timeline starts at

00:06:02,720 --> 00:06:08,740
a half a second but let's take a look at

00:06:06,560 --> 00:06:08,740
it

00:06:17,930 --> 00:06:23,879
so overall it took about three and a

00:06:20,759 --> 00:06:25,590
half seconds for us to load the app and

00:06:23,879 --> 00:06:30,389
this is just reloading the renderer

00:06:25,590 --> 00:06:32,250
process and for the first like second or

00:06:30,389 --> 00:06:40,550
so you can see the screens what's being

00:06:32,250 --> 00:06:43,289
rendered we just have a blake screen and

00:06:40,550 --> 00:06:45,960
you think about like a second is

00:06:43,289 --> 00:06:48,409
literally billions of cpu cycles on the

00:06:45,960 --> 00:06:50,870
intel i5 that i grabbed this profile

00:06:48,409 --> 00:06:53,400
this was kind of crazy

00:06:50,870 --> 00:06:57,530
finally at around the two second mark we

00:06:53,400 --> 00:06:59,220
get title so something finally shows up

00:06:57,530 --> 00:07:01,050
let me keep going

00:06:59,220 --> 00:07:03,389
we start to get some UI we see a tab

00:07:01,050 --> 00:07:09,300
come in and the cursor I think we're

00:07:03,389 --> 00:07:12,150
almost done but if you look at the top

00:07:09,300 --> 00:07:13,949
there's still like a bunch of stuff that

00:07:12,150 --> 00:07:24,719
we need to do before it's totally

00:07:13,949 --> 00:07:25,610
interactive so a two second mark and we

00:07:24,719 --> 00:07:31,860
keep going

00:07:25,610 --> 00:07:34,020
we have a sidebar kind of pop in but

00:07:31,860 --> 00:07:36,000
then it's going to kind of pop out and

00:07:34,020 --> 00:07:37,620
it's obviously a bug in our startup like

00:07:36,000 --> 00:07:40,710
we shouldn't have that jarring

00:07:37,620 --> 00:07:44,360
experience it's transient but you'll see

00:07:40,710 --> 00:07:44,360
it and it just won't look right so

00:07:44,810 --> 00:07:49,680
finally we hit our final rendering but

00:07:47,279 --> 00:07:51,719
there's still this JavaScript work left

00:07:49,680 --> 00:07:58,830
and now we're at a point where you can

00:07:51,719 --> 00:08:00,840
start using the application so it's

00:07:58,830 --> 00:08:03,710
interesting to look like where is all

00:08:00,840 --> 00:08:03,710
this time going

00:08:06,580 --> 00:08:12,130
if we take a look like at the bottom row

00:08:09,690 --> 00:08:14,500
these are all the steps that we're doing

00:08:12,130 --> 00:08:16,690
so we're loading various JavaScript

00:08:14,500 --> 00:08:19,320
files these evaluate scripts electron

00:08:16,690 --> 00:08:22,570
loading our JavaScript parsing it

00:08:19,320 --> 00:08:25,570
evaluating it compiling to bytecode and

00:08:22,570 --> 00:08:27,400
maybe cheating it and it's a pre full

00:08:25,570 --> 00:08:28,120
amount of time so 300 milliseconds for

00:08:27,400 --> 00:08:30,310
this one

00:08:28,120 --> 00:08:31,840
garbage collection this is another

00:08:30,310 --> 00:08:35,410
script that's loading another 300

00:08:31,840 --> 00:08:45,670
milliseconds and so this time really

00:08:35,410 --> 00:08:47,080
starts to add up and then there's some

00:08:45,670 --> 00:08:49,030
there's an animation frame that fires

00:08:47,080 --> 00:08:50,410
here that's a bug in our startup code we

00:08:49,030 --> 00:08:52,840
should have fixed that because we really

00:08:50,410 --> 00:08:58,540
shouldn't be animating anything until

00:08:52,840 --> 00:09:00,790
we're like have everything loaded but

00:08:58,540 --> 00:09:03,070
coming from languages like C or C++ that

00:09:00,790 --> 00:09:06,220
are compiled we're compiling code anyway

00:09:03,070 --> 00:09:07,990
with typescript so it's a kind of crazy

00:09:06,220 --> 00:09:10,360
equai does it need to compile again when

00:09:07,990 --> 00:09:13,420
I run it and I look around at other

00:09:10,360 --> 00:09:15,760
applications for inspiration vim starts

00:09:13,420 --> 00:09:18,610
up instantly sublime text starts up

00:09:15,760 --> 00:09:21,310
instantly notepad notepad plus plus

00:09:18,610 --> 00:09:24,160
start up instantly why can't my app

00:09:21,310 --> 00:09:30,100
start up that quickly to me and my users

00:09:24,160 --> 00:09:31,540
even a couple seconds it's too long so

00:09:30,100 --> 00:09:32,140
startup wasn't the only performance

00:09:31,540 --> 00:09:34,120
challenge

00:09:32,140 --> 00:09:36,390
there were several others but the main

00:09:34,120 --> 00:09:39,250
challenge on my mind was responsiveness

00:09:36,390 --> 00:09:41,110
and responsiveness is a time from

00:09:39,250 --> 00:09:44,160
processing user input like pressing a

00:09:41,110 --> 00:09:46,690
key to showing a result on the screen

00:09:44,160 --> 00:09:48,910
ideally we should chew for the absolute

00:09:46,690 --> 00:09:51,250
minimum ideally under at least 16

00:09:48,910 --> 00:09:52,320
milliseconds which is one frame at 60

00:09:51,250 --> 00:09:55,270
frames per second

00:09:52,320 --> 00:09:57,280
games render at this rate like entire 3d

00:09:55,270 --> 00:10:02,170
scenes like why shouldn't my code editor

00:09:57,280 --> 00:10:05,020
be able to do that to and out one

00:10:02,170 --> 00:10:07,330
challenge we had is we had sort of a

00:10:05,020 --> 00:10:09,910
back and forth some asynchronicity

00:10:07,330 --> 00:10:11,230
and how we handled the key press so key

00:10:09,910 --> 00:10:14,350
press would come in to our renderer

00:10:11,230 --> 00:10:16,210
process we'd send that over to neo vim

00:10:14,350 --> 00:10:19,060
and it's a separate process so we'd send

00:10:16,210 --> 00:10:20,760
it over a pipe that would get put on an

00:10:19,060 --> 00:10:22,750
event loop

00:10:20,760 --> 00:10:24,310
and then it would send us a couple of

00:10:22,750 --> 00:10:25,510
messages back would send us some

00:10:24,310 --> 00:10:28,450
information about what change with the

00:10:25,510 --> 00:10:30,550
buffer I would send us what the screen

00:10:28,450 --> 00:10:32,290
should look like it kind of represents

00:10:30,550 --> 00:10:35,589
it as like a grid of cells like a

00:10:32,290 --> 00:10:38,350
terminal but we also wanted to do some

00:10:35,589 --> 00:10:41,620
kind of rich rendering like a Dorner's

00:10:38,350 --> 00:10:43,300
color widgets mini map tab indents and

00:10:41,620 --> 00:10:45,190
to do that we need to know a little bit

00:10:43,300 --> 00:10:47,380
more about the window dimensions and the

00:10:45,190 --> 00:10:49,930
relation of the cursor position so to

00:10:47,380 --> 00:10:54,160
make another call to get window metrics

00:10:49,930 --> 00:10:56,110
sometimes more than one and then we get

00:10:54,160 --> 00:10:58,180
some information back and this would let

00:10:56,110 --> 00:11:00,070
us build up a map of a buffer position

00:10:58,180 --> 00:11:02,860
aligned in a column and a file to a

00:11:00,070 --> 00:11:04,810
pixel position on the screen we need to

00:11:02,860 --> 00:11:07,680
do all this back and forth within a

00:11:04,810 --> 00:11:09,839
frame within that 16 milliseconds and

00:11:07,680 --> 00:11:14,519
then we actually have to render and

00:11:09,839 --> 00:11:14,519
rendering wasn't always a trivial cost

00:11:16,769 --> 00:11:21,399
and we actually did a lot of things to

00:11:20,079 --> 00:11:26,050
try and squeeze more and more

00:11:21,399 --> 00:11:28,480
performance out of our stack first we

00:11:26,050 --> 00:11:30,519
implement a bundle splitting so instead

00:11:28,480 --> 00:11:32,620
of loading the entire JavaScript of the

00:11:30,519 --> 00:11:34,930
application at once we split it up into

00:11:32,620 --> 00:11:38,980
bundles so it could be loaded piecewise

00:11:34,930 --> 00:11:40,750
and on demand we also used async imports

00:11:38,980 --> 00:11:41,980
so we could kind of paralyze the loading

00:11:40,750 --> 00:11:45,519
and load some things while we're

00:11:41,980 --> 00:11:47,829
evaluating other things and we used

00:11:45,519 --> 00:11:50,290
minification to minimize the work that

00:11:47,829 --> 00:11:54,699
the JavaScript parser has to do less

00:11:50,290 --> 00:11:58,089
characters less work for runtime

00:11:54,699 --> 00:12:00,790
performance to get that responsiveness

00:11:58,089 --> 00:12:03,100
we implemented some things on top of

00:12:00,790 --> 00:12:05,440
that our architecture we implemented

00:12:03,100 --> 00:12:06,610
this feature called typing prediction so

00:12:05,440 --> 00:12:09,279
what happened is when the key press

00:12:06,610 --> 00:12:11,709
comes in we would try and guess the

00:12:09,279 --> 00:12:13,360
result of that before it goes over to

00:12:11,709 --> 00:12:16,990
the neo of M and we would render

00:12:13,360 --> 00:12:18,670
immediately the problem is sometimes we

00:12:16,990 --> 00:12:20,050
would guess wrong like maybe would be at

00:12:18,670 --> 00:12:21,339
the edge of the line and we wouldn't

00:12:20,050 --> 00:12:23,470
know that the line wraps so you'd see a

00:12:21,339 --> 00:12:27,130
character kind of dart out to the side

00:12:23,470 --> 00:12:31,710
for a second so it added some complexity

00:12:27,130 --> 00:12:33,960
and some bugs to our application

00:12:31,710 --> 00:12:36,270
we implement a deep balanced rendering

00:12:33,960 --> 00:12:37,830
so we had a Redux and react stack and

00:12:36,270 --> 00:12:40,170
every time we sent an action into a

00:12:37,830 --> 00:12:42,450
Redux door it would trigger the Dom to

00:12:40,170 --> 00:12:45,779
update and it turns out this was very

00:12:42,450 --> 00:12:47,070
noisy for us so we use this library that

00:12:45,779 --> 00:12:49,830
let us kind of synchronize it with

00:12:47,070 --> 00:12:51,570
requestanimationframe so that maybe a

00:12:49,830 --> 00:12:53,520
bunch of actions come in but we only

00:12:51,570 --> 00:12:58,170
render at once during that animation

00:12:53,520 --> 00:13:01,410
frame we also ended up having to split

00:12:58,170 --> 00:13:03,930
our redux doors we had so much state

00:13:01,410 --> 00:13:05,850
there that the actual cloning of the

00:13:03,930 --> 00:13:08,040
objects started to show up in our

00:13:05,850 --> 00:13:11,670
performance profile so by splitting it

00:13:08,040 --> 00:13:13,350
up we minimize that cloning cost but it

00:13:11,670 --> 00:13:17,730
at the cost of extra architectural

00:13:13,350 --> 00:13:20,070
complexity and finally we spent a lot of

00:13:17,730 --> 00:13:21,930
time in the paint profiler which is

00:13:20,070 --> 00:13:23,730
really cool tool and electron lets you

00:13:21,930 --> 00:13:26,490
see how much work it's doing when it has

00:13:23,730 --> 00:13:31,440
to redraw the UI and ideally you want to

00:13:26,490 --> 00:13:33,600
keep that as small as possible to be

00:13:31,440 --> 00:13:35,550
fair we really stopped short of a few

00:13:33,600 --> 00:13:37,560
potential optimizations like one that

00:13:35,550 --> 00:13:41,279
could have helped our startup time is

00:13:37,560 --> 00:13:43,170
ability to pre compile JavaScript but as

00:13:41,279 --> 00:13:45,720
a very small team you start to reach the

00:13:43,170 --> 00:13:47,310
point of diminishing returns and I could

00:13:45,720 --> 00:13:50,100
see us getting additional incremental

00:13:47,310 --> 00:13:53,150
gains but not the instant performance of

00:13:50,100 --> 00:13:55,230
like notepad plus plus or sublime text

00:13:53,150 --> 00:13:57,240
and in the back of my mind I was

00:13:55,230 --> 00:13:59,940
thinking why do we even have to battle

00:13:57,240 --> 00:14:04,140
this why can't our desktop app our

00:13:59,940 --> 00:14:05,820
technology just be fast by default and

00:14:04,140 --> 00:14:07,110
so I was thinking about our architecture

00:14:05,820 --> 00:14:09,750
from another perspective kind of

00:14:07,110 --> 00:14:12,320
top-down and at the very foundation we

00:14:09,750 --> 00:14:17,459
have sort of platform api's things like

00:14:12,320 --> 00:14:18,959
cocoa win32 api s OpenGL and then

00:14:17,459 --> 00:14:21,120
libraries that are common across

00:14:18,959 --> 00:14:25,079
platforms things like harf buzz and free

00:14:21,120 --> 00:14:29,399
type for text rendering then we have

00:14:25,079 --> 00:14:31,860
electron on top of that and then we had

00:14:29,399 --> 00:14:37,020
neogan to help us with modal editing

00:14:31,860 --> 00:14:39,750
experience then we had a lot of NPM

00:14:37,020 --> 00:14:41,430
modules and react and redux at the top

00:14:39,750 --> 00:14:44,649
of that a bunch of transitive

00:14:41,430 --> 00:14:46,820
dependencies to support that

00:14:44,649 --> 00:14:51,470
finally we had our application code

00:14:46,820 --> 00:14:53,839
sitting above that but then it felt like

00:14:51,470 --> 00:14:55,820
we had all this sort of accidental

00:14:53,839 --> 00:14:57,740
complexity that we had to implement to

00:14:55,820 --> 00:15:00,140
get the performance we wanted so these

00:14:57,740 --> 00:15:02,120
sort of things that aren't really core

00:15:00,140 --> 00:15:04,700
to the problem of building an editor but

00:15:02,120 --> 00:15:11,630
things that we had to add to try and get

00:15:04,700 --> 00:15:12,610
that performance what can we do about it

00:15:11,630 --> 00:15:15,260
though

00:15:12,610 --> 00:15:17,360
well for one we're using WebGL anyway

00:15:15,260 --> 00:15:19,040
and we're building a desktop app we

00:15:17,360 --> 00:15:21,350
don't plan on chipping this in the

00:15:19,040 --> 00:15:25,940
browser we could cut out the middleman

00:15:21,350 --> 00:15:28,700
and remove electron but if we get rid of

00:15:25,940 --> 00:15:29,570
node and chromium for our core editor we

00:15:28,700 --> 00:15:31,850
have to figure out what we're gonna do

00:15:29,570 --> 00:15:34,130
with react and NPM dependencies because

00:15:31,850 --> 00:15:36,290
if node and chromium are gone we can't

00:15:34,130 --> 00:15:37,520
really use JavaScript anymore but maybe

00:15:36,290 --> 00:15:41,500
we could replace them with some

00:15:37,520 --> 00:15:44,060
streamlined set of native dependencies I

00:15:41,500 --> 00:15:45,830
also wanted to switch our input handling

00:15:44,060 --> 00:15:49,330
to be synchronous so when you press a

00:15:45,830 --> 00:15:52,459
key we can render as quickly as possible

00:15:49,330 --> 00:15:57,080
remove a synchronicity from the path of

00:15:52,459 --> 00:15:59,930
pressing a key to rendering and finally

00:15:57,080 --> 00:16:02,360
I wanted to find a way to not have that

00:15:59,930 --> 00:16:06,320
accidental complexity that those extra

00:16:02,360 --> 00:16:08,750
features on the top of the stack so I

00:16:06,320 --> 00:16:11,420
kind of came up with what my ideal stack

00:16:08,750 --> 00:16:13,790
could be like what I really wanted was

00:16:11,420 --> 00:16:16,670
to have a react paradigm but something

00:16:13,790 --> 00:16:19,160
that is all native code if we didn't

00:16:16,670 --> 00:16:21,410
have to evaluate the JavaScript it could

00:16:19,160 --> 00:16:23,300
help our startup time tremendously and

00:16:21,410 --> 00:16:25,459
if we had a synchronous model for

00:16:23,300 --> 00:16:31,520
handling input we could process input

00:16:25,459 --> 00:16:34,130
and render immediately so I really like

00:16:31,520 --> 00:16:36,350
the react paradigm of UI as a pure

00:16:34,130 --> 00:16:38,690
function of State and also the Redux

00:16:36,350 --> 00:16:44,120
paradigm of your state as a function of

00:16:38,690 --> 00:16:47,350
previous state and in action but I

00:16:44,120 --> 00:16:50,959
wasn't really sure how to get there and

00:16:47,350 --> 00:16:52,339
I didn't really have an answer I kind of

00:16:50,959 --> 00:16:54,290
consider just putting a project on hold

00:16:52,339 --> 00:16:56,870
because I didn't think we could meet our

00:16:54,290 --> 00:16:57,890
goals with the current tech stack I've

00:16:56,870 --> 00:17:00,110
thought about switching to see

00:16:57,890 --> 00:17:02,240
plus a rust and using a UI framework

00:17:00,110 --> 00:17:07,250
there there's lots of popular ones like

00:17:02,240 --> 00:17:11,990
cute but I'd miss that react style of UI

00:17:07,250 --> 00:17:13,910
development that functional lien it just

00:17:11,990 --> 00:17:17,829
so happened around this time I learned

00:17:13,910 --> 00:17:21,230
about an exciting project called reason

00:17:17,829 --> 00:17:24,770
and reasons actually built by the

00:17:21,230 --> 00:17:25,610
creator of react join walk so imagine if

00:17:24,770 --> 00:17:29,990
you had a language that was

00:17:25,610 --> 00:17:31,970
purpose-built for react it's a

00:17:29,990 --> 00:17:34,220
functional language but it's pragmatic

00:17:31,970 --> 00:17:36,169
you can do imperative object-oriented

00:17:34,220 --> 00:17:39,200
programming you can have beautiful

00:17:36,169 --> 00:17:41,299
objects it's geared and optimized for a

00:17:39,200 --> 00:17:42,590
functional approach but also means you

00:17:41,299 --> 00:17:44,809
can be productive quickly without

00:17:42,590 --> 00:17:49,700
needing to climb an ivory tower of

00:17:44,809 --> 00:17:53,559
learning monads and category theory it

00:17:49,700 --> 00:17:56,600
looks like javascript has JSX solid box

00:17:53,559 --> 00:18:01,520
but importantly for me it could compile

00:17:56,600 --> 00:18:03,830
to native code and it actually isn't

00:18:01,520 --> 00:18:06,140
really a new language it's sort of a

00:18:03,830 --> 00:18:07,820
wrapper on an existing language oh camel

00:18:06,140 --> 00:18:09,559
which has been around for a long time

00:18:07,820 --> 00:18:15,620
and it's invested in by various

00:18:09,559 --> 00:18:18,260
companies like Jane Street so we started

00:18:15,620 --> 00:18:20,720
prototyping and our very first prototype

00:18:18,260 --> 00:18:24,679
was really ugly

00:18:20,720 --> 00:18:26,870
I mean text rendering is horrible

00:18:24,679 --> 00:18:28,400
no gamma correction it really makes you

00:18:26,870 --> 00:18:31,730
appreciate all the things that electron

00:18:28,400 --> 00:18:34,220
gives you out of the box but we had the

00:18:31,730 --> 00:18:36,950
pieces we needed we could render text we

00:18:34,220 --> 00:18:39,110
could render shapes and icons all the

00:18:36,950 --> 00:18:43,309
ingredients for a code editor the rest

00:18:39,110 --> 00:18:45,200
is just details and cleaning it up but

00:18:43,309 --> 00:18:47,059
we realized some of the pieces could be

00:18:45,200 --> 00:18:48,620
more general than a code editor so we

00:18:47,059 --> 00:18:52,309
factored it out into a UI framework

00:18:48,620 --> 00:18:54,010
called reverie and it's a UI and

00:18:52,309 --> 00:18:57,140
application framework built on reason

00:18:54,010 --> 00:18:58,880
it's a very similar to react so ideally

00:18:57,140 --> 00:19:03,440
you could take what you know about react

00:18:58,880 --> 00:19:07,040
and transfer it compiles to native code

00:19:03,440 --> 00:19:10,929
and it's desktop only for now but we'd

00:19:07,040 --> 00:19:10,929
like to branch out to mobile

00:19:11,660 --> 00:19:18,300
this is what a minimal revery app looks

00:19:14,100 --> 00:19:22,490
like and if you squint and don't look

00:19:18,300 --> 00:19:22,490
too hard it almost looks like JavaScript

00:19:22,730 --> 00:19:30,630
the uija dot start is a lot like react

00:19:25,710 --> 00:19:31,860
Dom render just in the native world and

00:19:30,630 --> 00:19:33,990
this is a little more involved example

00:19:31,860 --> 00:19:36,780
this is actually the component for the

00:19:33,990 --> 00:19:39,480
root of that prototype so it looks

00:19:36,780 --> 00:19:42,720
vaguely like react like the view kind of

00:19:39,480 --> 00:19:44,910
looks like react native this style looks

00:19:42,720 --> 00:19:47,970
vaguely familiar so it's similar similar

00:19:44,910 --> 00:19:50,130
paradigms and there's actually been some

00:19:47,970 --> 00:19:52,590
cool stuff built with it so we have an

00:19:50,130 --> 00:19:56,760
example app with some applications like

00:19:52,590 --> 00:19:58,650
this calculator app Kyle Davies about

00:19:56,760 --> 00:20:03,000
this cool chess app that shows like

00:19:58,650 --> 00:20:06,710
Mouse drag and drop and Ken wheeler

00:20:03,000 --> 00:20:06,710
built this really cool drum machine app

00:20:07,640 --> 00:20:17,280
and of course we started working trying

00:20:12,840 --> 00:20:19,140
to get our code editor working it's

00:20:17,280 --> 00:20:22,020
still pre-alpha but we're moving forward

00:20:19,140 --> 00:20:24,930
and the architecture that we landed on

00:20:22,020 --> 00:20:27,720
was a fast native code front-end built

00:20:24,930 --> 00:20:31,560
with reason and this uses reverie for

00:20:27,720 --> 00:20:33,870
the UI and the application lifecycle and

00:20:31,560 --> 00:20:35,700
we also created a library for vim called

00:20:33,870 --> 00:20:39,510
lib vim which is agnostic of the

00:20:35,700 --> 00:20:41,190
terminal but has a synchronous API that

00:20:39,510 --> 00:20:43,890
lets us have that synchronous flow of

00:20:41,190 --> 00:20:46,410
keypress to render and because the

00:20:43,890 --> 00:20:48,810
front-end is native code it really helps

00:20:46,410 --> 00:20:52,860
our starter performance we don't need to

00:20:48,810 --> 00:20:54,660
low and evaluate JavaScript anymore but

00:20:52,860 --> 00:20:57,480
we didn't get out of JavaScript entirely

00:20:54,660 --> 00:20:59,910
because we really wanted to leverage the

00:20:57,480 --> 00:21:02,040
vs code extension model so we actually

00:20:59,910 --> 00:21:05,430
still have an old process running in the

00:21:02,040 --> 00:21:08,640
backend it's actually the back part of

00:21:05,430 --> 00:21:11,640
es code so the extension hosts the

00:21:08,640 --> 00:21:14,100
interface for language services and

00:21:11,640 --> 00:21:16,580
other features so that's what we're

00:21:14,100 --> 00:21:18,420
working on right now is wiring that up

00:21:16,580 --> 00:21:20,670
so it's kind of an interesting

00:21:18,420 --> 00:21:23,050
architecture because we get the benefit

00:21:20,670 --> 00:21:24,760
of a fast native front-end

00:21:23,050 --> 00:21:28,860
while still being able to leverage the

00:21:24,760 --> 00:21:28,860
breadth and power of vs code extensions

00:21:29,520 --> 00:21:37,570
so looking at some performance numbers

00:21:33,330 --> 00:21:39,880
the last build of our v1 took about five

00:21:37,570 --> 00:21:41,440
seconds to start that's actually more

00:21:39,880 --> 00:21:44,290
than the profile I showed because this

00:21:41,440 --> 00:21:45,970
is measuring end to end from pressing

00:21:44,290 --> 00:21:49,360
the button in the terminal to launch it

00:21:45,970 --> 00:21:51,460
to actually having it be interactive and

00:21:49,360 --> 00:21:53,950
our v2 takes about a half second to

00:21:51,460 --> 00:21:56,980
launch with the same file so it's an

00:21:53,950 --> 00:21:59,490
order of magnitude difference then the

00:21:56,980 --> 00:22:01,990
memory usage is a pretty different -

00:21:59,490 --> 00:22:06,610
there's significantly less memory usage

00:22:01,990 --> 00:22:07,630
on startup for this small file and I

00:22:06,610 --> 00:22:09,400
think there's still a lot of low-hanging

00:22:07,630 --> 00:22:11,920
fruit left for us in the native code

00:22:09,400 --> 00:22:13,960
world our drawing layer right now is

00:22:11,920 --> 00:22:16,510
inefficient but still faster than what

00:22:13,960 --> 00:22:18,910
we had before there's a optimizing

00:22:16,510 --> 00:22:21,210
compiler for all Camel that reason can

00:22:18,910 --> 00:22:23,710
use that we haven't even hooked up yet

00:22:21,210 --> 00:22:29,260
there's blocking i/o on our startup path

00:22:23,710 --> 00:22:32,940
but it's still faster so I'll show a

00:22:29,260 --> 00:22:36,430
quick demo of our latest master build

00:22:32,940 --> 00:22:38,670
still kind of alpha still rough around

00:22:36,430 --> 00:22:38,670
the edges

00:22:49,970 --> 00:22:57,360
here we go I'm gonna open up a JSON file

00:22:53,760 --> 00:23:02,130
I got my favorite vyas code theme here

00:22:57,360 --> 00:23:05,640
it's called a laser wave I'm gonna open

00:23:02,130 --> 00:23:07,890
up Kiedis player so that you can see

00:23:05,640 --> 00:23:10,830
what I'm pressing J and K move up and

00:23:07,890 --> 00:23:14,520
down in vim and there's a bug here with

00:23:10,830 --> 00:23:18,780
my extension chippy dots you see I just

00:23:14,520 --> 00:23:21,690
changed dot C and then there's this easy

00:23:18,780 --> 00:23:29,309
section above I kind of want to move

00:23:21,690 --> 00:23:31,440
that after the build section so I can

00:23:29,309 --> 00:23:35,340
use Vince command say move 13 rows up

00:23:31,440 --> 00:23:36,780
highlight this delete it and then press

00:23:35,340 --> 00:23:42,960
% to move to the end of the block and

00:23:36,780 --> 00:23:44,580
paste it my favourite feature though is

00:23:42,960 --> 00:23:46,380
like lightweight manager made it splits

00:23:44,580 --> 00:23:48,630
so I'm gonna open up another JSON file

00:23:46,380 --> 00:23:53,010
as a horizontal split so it's on the top

00:23:48,630 --> 00:23:56,190
now and I want to sync up a dependency

00:23:53,010 --> 00:23:58,169
this reason STL - so I'm gonna grab this

00:23:56,190 --> 00:24:05,970
I just yanked it which is like a copy

00:23:58,169 --> 00:24:08,429
and move to my bottom window and paste

00:24:05,970 --> 00:24:10,169
it so now I have the version synced up

00:24:08,429 --> 00:24:16,169
by missing a comma so I'm going to

00:24:10,169 --> 00:24:20,250
insert at the end add the comma I'm done

00:24:16,169 --> 00:24:22,640
with this split I'll jump into a reason

00:24:20,250 --> 00:24:22,640
file now

00:24:29,410 --> 00:24:33,950
and this is like a preview we're working

00:24:32,510 --> 00:24:35,630
on language integration right now so I

00:24:33,950 --> 00:24:37,760
just started hooking up Diagnostics so

00:24:35,630 --> 00:24:38,990
you see that squiggle and an error

00:24:37,760 --> 00:24:42,080
message and you see it in the mini-map

00:24:38,990 --> 00:24:46,730
too and then now we're working on

00:24:42,080 --> 00:24:52,280
hooking up completion as well so

00:24:46,730 --> 00:24:55,040
hopefully that word so there's still a

00:24:52,280 --> 00:24:57,860
lot of fit and finish and polish and

00:24:55,040 --> 00:24:59,360
features we need to implement but we're

00:24:57,860 --> 00:25:01,130
moving forward and you can build

00:24:59,360 --> 00:25:06,980
something non-trivial with this tech

00:25:01,130 --> 00:25:09,110
stack there's been a lot of people

00:25:06,980 --> 00:25:11,150
across the board that have helped kind

00:25:09,110 --> 00:25:12,799
of build out this technology we've built

00:25:11,150 --> 00:25:15,049
on a lot of great open source projects

00:25:12,799 --> 00:25:18,500
people in the reason community people

00:25:15,049 --> 00:25:20,330
helped build revery and only them a big

00:25:18,500 --> 00:25:24,250
thanks to everyone who's helped support

00:25:20,330 --> 00:25:24,250
the project our backers and pre-orders

00:25:25,240 --> 00:25:29,220
so that's it thank you so much for

00:25:27,620 --> 00:25:30,290
coming to listen to my talk

00:25:29,220 --> 00:25:35,109
[Applause]

00:25:30,290 --> 00:25:35,109

YouTube URL: https://www.youtube.com/watch?v=QD9hpiBZQvA


