Title: ReactiveConf 2019 - David Khourshid: Mind-Reading with Intelligent & Adaptive UIs
Publication date: 2019-11-01
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Millennium stage
-------------------------------------------------------------------
What if you could predict user behavior with smart UIs? In this talk, we will explore how we can make adaptive and intelligent user interfaces that learn from how individual users use your apps, and personalize the interface and features just for them, in real-time. With probability-driven statecharts, decision trees, reinforcement learning and more, UIs can be developed in such a way that it automatically adapts to the userâ€™s behavior
Captions: 
	00:00:02,760 --> 00:00:11,850
[Music]

00:00:16,070 --> 00:00:20,640
hello everyone my name is David course

00:00:18,600 --> 00:00:24,090
shade I work in Microsoft and I am so

00:00:20,640 --> 00:00:25,920
excited to be here again in Prague the

00:00:24,090 --> 00:00:27,720
last time I was here I talked to you all

00:00:25,920 --> 00:00:30,330
about state charts and state machines

00:00:27,720 --> 00:00:31,980
and how they could help influence the

00:00:30,330 --> 00:00:34,890
way that we do developments in a

00:00:31,980 --> 00:00:36,680
positive way and today on Halloween

00:00:34,890 --> 00:00:38,670
which is why I'm wearing this costume

00:00:36,680 --> 00:00:40,950
I'm gonna be talking to you about

00:00:38,670 --> 00:00:44,010
mind-reading with intelligence and

00:00:40,950 --> 00:00:46,739
adaptive user interfaces and so the

00:00:44,010 --> 00:00:48,120
thing is with a Halloween a lot of

00:00:46,739 --> 00:00:50,399
people you might you know might

00:00:48,120 --> 00:00:52,320
celebrate here I don't know I saw a few

00:00:50,399 --> 00:00:54,809
people in costumes so especially at this

00:00:52,320 --> 00:00:57,420
conference and we saw that a lot of

00:00:54,809 --> 00:01:00,270
people like to dress as something that

00:00:57,420 --> 00:01:02,309
they're not and part of it is to express

00:01:00,270 --> 00:01:04,619
their own creativity or just something

00:01:02,309 --> 00:01:06,810
that they like and that's the important

00:01:04,619 --> 00:01:07,979
thing is that everyone is different and

00:01:06,810 --> 00:01:09,439
this is something that we have to keep

00:01:07,979 --> 00:01:12,479
in mind when we're developing

00:01:09,439 --> 00:01:15,060
applications and user interfaces because

00:01:12,479 --> 00:01:20,369
we all speak different languages we all

00:01:15,060 --> 00:01:23,430
come from different backgrounds so in my

00:01:20,369 --> 00:01:26,250
opinion when we do things like a be

00:01:23,430 --> 00:01:28,290
tests or final charts or final diagrams

00:01:26,250 --> 00:01:30,299
I feel like that sort of disingenuous

00:01:28,290 --> 00:01:33,420
and ineffective because those only

00:01:30,299 --> 00:01:35,220
target certain people and we make

00:01:33,420 --> 00:01:38,009
assumptions about the people that were

00:01:35,220 --> 00:01:40,710
developing our apps for and also the

00:01:38,009 --> 00:01:43,200
thing is that the user flows that are

00:01:40,710 --> 00:01:45,720
represented in our app are not always

00:01:43,200 --> 00:01:47,159
linear in fact users could do so many

00:01:45,720 --> 00:01:51,210
different things and we have to

00:01:47,159 --> 00:01:53,579
represent those in different ways so one

00:01:51,210 --> 00:01:57,210
example of an adaptive user interface is

00:01:53,579 --> 00:01:59,759
guest j/s which was made by I believe

00:01:57,210 --> 00:02:02,759
Sam Saucony at Google and this uses

00:01:59,759 --> 00:02:05,729
predictive analytics to intelligently

00:02:02,759 --> 00:02:08,129
prefetch resources on the page depending

00:02:05,729 --> 00:02:10,349
on where the user is likely to end up

00:02:08,129 --> 00:02:13,170
next and so this contributes to a

00:02:10,349 --> 00:02:13,450
positive user experience because when

00:02:13,170 --> 00:02:15,760
the

00:02:13,450 --> 00:02:17,430
or visits a webpage then they are going

00:02:15,760 --> 00:02:20,590
to be able to see the next webpage

00:02:17,430 --> 00:02:24,370
loaded a lot faster than if they had to

00:02:20,590 --> 00:02:26,110
wait to load the resource so this gets

00:02:24,370 --> 00:02:28,540
to the core of what adaptive user

00:02:26,110 --> 00:02:30,940
interfaces are you might have heard of

00:02:28,540 --> 00:02:33,940
responsive user interfaces which adapts

00:02:30,940 --> 00:02:36,340
to devices whether you have a laptop a

00:02:33,940 --> 00:02:38,980
desktop with your crazy 60-inch monitors

00:02:36,340 --> 00:02:41,739
or a cell phone or even the Apple watch

00:02:38,980 --> 00:02:45,120
or Google if they're still doing watches

00:02:41,739 --> 00:02:49,480
but the key is that adaptive interfaces

00:02:45,120 --> 00:02:51,730
adapts to us we are the device in which

00:02:49,480 --> 00:02:54,760
is interacting with the application and

00:02:51,730 --> 00:02:57,010
so one of the earliest examples of this

00:02:54,760 --> 00:02:59,319
you might remember is Clippy from

00:02:57,010 --> 00:03:03,010
Microsoft I'm legally obligated to

00:02:59,319 --> 00:03:06,940
include him in this in this slide so

00:03:03,010 --> 00:03:09,970
take for example email a user comes into

00:03:06,940 --> 00:03:12,430
this interface and is presented with an

00:03:09,970 --> 00:03:14,410
inbox in which they could choose in

00:03:12,430 --> 00:03:16,390
action to do they could view the latest

00:03:14,410 --> 00:03:19,720
messages or they could compose a new

00:03:16,390 --> 00:03:22,359
email and so while we might try to make

00:03:19,720 --> 00:03:25,870
a one-size-fits-all user interface that

00:03:22,359 --> 00:03:28,569
solves all the problems with with

00:03:25,870 --> 00:03:30,730
different users using the app we might

00:03:28,569 --> 00:03:33,639
see that users use it differently in

00:03:30,730 --> 00:03:36,220
this case this user might always try to

00:03:33,639 --> 00:03:39,040
view the latest email or when the user

00:03:36,220 --> 00:03:41,079
composes a new email then they might be

00:03:39,040 --> 00:03:43,209
more likely to send the email rather

00:03:41,079 --> 00:03:45,700
than save it as drafts so those are user

00:03:43,209 --> 00:03:49,690
flows that we could optimize for another

00:03:45,700 --> 00:03:52,840
example is in the Google inbox interface

00:03:49,690 --> 00:03:54,850
where instead of asking are you sure

00:03:52,840 --> 00:03:57,430
when you're deleting a message or when

00:03:54,850 --> 00:03:59,500
you're sending a message instead we

00:03:57,430 --> 00:04:02,260
could reduce that and create a more

00:03:59,500 --> 00:04:04,450
adaptive user interface by saying it's

00:04:02,260 --> 00:04:07,450
deleted and giving them the option to

00:04:04,450 --> 00:04:10,510
undo that and this completely eliminates

00:04:07,450 --> 00:04:12,730
a step in the user flow which is very

00:04:10,510 --> 00:04:14,349
good for the user because they're able

00:04:12,730 --> 00:04:18,160
to do their actions a lot more

00:04:14,349 --> 00:04:19,840
efficiently so another example in in

00:04:18,160 --> 00:04:21,849
Google inbox I don't know if you've seen

00:04:19,840 --> 00:04:23,650
this feature but I use this all the time

00:04:21,849 --> 00:04:26,410
is when you're composing a new message

00:04:23,650 --> 00:04:28,360
you see that it will actually

00:04:26,410 --> 00:04:31,360
dicks the next thing that you're going

00:04:28,360 --> 00:04:33,880
to type and sometimes it's not exactly

00:04:31,360 --> 00:04:36,460
what I want to type I'm lazy so I choose

00:04:33,880 --> 00:04:38,170
Google's suggestion anyway and you know

00:04:36,460 --> 00:04:40,270
the same thing happens in messages and

00:04:38,170 --> 00:04:43,060
you know maybe iPhone will do this one

00:04:40,270 --> 00:04:44,470
day too or I was gonna say Microsoft but

00:04:43,060 --> 00:04:49,450
that doesn't really exist

00:04:44,470 --> 00:04:51,760
so also adaptive user interfaces can

00:04:49,450 --> 00:04:53,950
adapt to whether your user is a power

00:04:51,760 --> 00:04:55,840
user and knows all the function now they

00:04:53,950 --> 00:04:57,730
are ready so you want to provide these

00:04:55,840 --> 00:05:00,280
power shortcuts for them to achieve

00:04:57,730 --> 00:05:02,380
their tasks as quickly as possible or

00:05:00,280 --> 00:05:04,060
maybe the user needs a little bit more

00:05:02,380 --> 00:05:06,790
guidance and so when the adaptive user

00:05:04,060 --> 00:05:08,890
interface can detect that and actually

00:05:06,790 --> 00:05:11,580
provide that guidance and help them

00:05:08,890 --> 00:05:14,920
achieve the same goals

00:05:11,580 --> 00:05:17,370
however developing adaptive user

00:05:14,920 --> 00:05:19,870
interfaces definitely has its challenges

00:05:17,370 --> 00:05:21,460
with adaptive user interfaces there's a

00:05:19,870 --> 00:05:23,860
lot of factors we need to take into

00:05:21,460 --> 00:05:26,620
consideration including user privacy

00:05:23,860 --> 00:05:29,110
whether we wants to adapt at the local

00:05:26,620 --> 00:05:31,840
level or in a global level such as

00:05:29,110 --> 00:05:36,700
adapting via routes versus you know

00:05:31,840 --> 00:05:39,760
adapting singular components or you know

00:05:36,700 --> 00:05:42,370
whether we want to you know provide the

00:05:39,760 --> 00:05:44,680
user an option to change it via settings

00:05:42,370 --> 00:05:46,660
so do we want to give the user manual

00:05:44,680 --> 00:05:50,980
control or do we want this to happen

00:05:46,660 --> 00:05:53,320
behind the scenes so one way that we

00:05:50,980 --> 00:05:55,780
could tackle this problem and actually

00:05:53,320 --> 00:05:57,910
introduce adapt abuser interfaces in our

00:05:55,780 --> 00:05:59,890
everyday development is by adopting

00:05:57,910 --> 00:06:03,250
what's called model driven development

00:05:59,890 --> 00:06:05,560
which is not a new concept at all so the

00:06:03,250 --> 00:06:09,310
idea is that you represent your

00:06:05,560 --> 00:06:11,110
application as an abstract model now if

00:06:09,310 --> 00:06:11,680
you've been doing design or working with

00:06:11,110 --> 00:06:13,510
designers

00:06:11,680 --> 00:06:17,800
you might recognize something called

00:06:13,510 --> 00:06:20,230
user flows and so these are they're

00:06:17,800 --> 00:06:22,510
technically a form of abstract models

00:06:20,230 --> 00:06:25,120
which tell you which state goes to which

00:06:22,510 --> 00:06:27,850
next state in the application and it's a

00:06:25,120 --> 00:06:29,680
very visually clear way to represent how

00:06:27,850 --> 00:06:32,350
your user is going to interact with the

00:06:29,680 --> 00:06:34,360
application now last year I talked about

00:06:32,350 --> 00:06:36,460
finite state machines and state charts

00:06:34,360 --> 00:06:39,220
and this is a way that we could

00:06:36,460 --> 00:06:40,030
introduce these abstract models into our

00:06:39,220 --> 00:06:42,520
application

00:06:40,030 --> 00:06:45,250
in case you forgot I'll just do a little

00:06:42,520 --> 00:06:47,380
bit of a reminder a finite state machine

00:06:45,250 --> 00:06:49,690
has an initial state such as a sign-in

00:06:47,380 --> 00:06:51,760
page it has a finite number of states

00:06:49,690 --> 00:06:53,920
which represents all of the possible

00:06:51,760 --> 00:06:56,500
states that the user can be in when

00:06:53,920 --> 00:06:58,540
they're interacting with your app it has

00:06:56,500 --> 00:07:00,100
a finite number of events which

00:06:58,540 --> 00:07:02,290
represents everything that could happen

00:07:00,100 --> 00:07:04,840
within the app whether that action is

00:07:02,290 --> 00:07:07,840
initiated by the user or within the app

00:07:04,840 --> 00:07:09,490
itself it has a mapping of state

00:07:07,840 --> 00:07:12,730
transitions which are triggered by these

00:07:09,490 --> 00:07:14,950
events and so these are deterministic

00:07:12,730 --> 00:07:16,930
and they say when were in one state such

00:07:14,950 --> 00:07:19,600
as the sign-in States and an event

00:07:16,930 --> 00:07:21,910
happens such as sign in now we're on the

00:07:19,600 --> 00:07:24,340
signing in state and so these arrows are

00:07:21,910 --> 00:07:26,200
going to be very important and there's

00:07:24,340 --> 00:07:29,410
also a finite number of final states

00:07:26,200 --> 00:07:32,380
which say the the user has completed

00:07:29,410 --> 00:07:34,750
this flow or we're done or this app is

00:07:32,380 --> 00:07:36,970
at its terminal points and you would

00:07:34,750 --> 00:07:39,430
have to restart or do something else to

00:07:36,970 --> 00:07:41,950
start the app over again now why do we

00:07:39,430 --> 00:07:44,320
use finite state machines well if you

00:07:41,950 --> 00:07:47,050
look at my talk last year it's to

00:07:44,320 --> 00:07:48,150
prevent impossible states such as this

00:07:47,050 --> 00:07:51,220
one

00:07:48,150 --> 00:07:54,610
now state charts are an extension of

00:07:51,220 --> 00:07:56,260
finite States and state charts have a

00:07:54,610 --> 00:07:57,940
lot more features that we're not going

00:07:56,260 --> 00:08:00,910
to get into right now because I don't

00:07:57,940 --> 00:08:03,100
have time but the idea is that using

00:08:00,910 --> 00:08:05,500
these concepts such as finite state

00:08:03,100 --> 00:08:07,360
machines and state charts help prevents

00:08:05,500 --> 00:08:10,540
impossible states and help you make

00:08:07,360 --> 00:08:13,150
sense of your application I created X

00:08:10,540 --> 00:08:14,979
State which which is a way of coding

00:08:13,150 --> 00:08:17,169
these state charts into your application

00:08:14,979 --> 00:08:19,630
and it has all these sorts of features

00:08:17,169 --> 00:08:21,700
and if you don't need these features

00:08:19,630 --> 00:08:24,490
then there's other options as well such

00:08:21,700 --> 00:08:26,830
as x8 FSM which is just for the finite

00:08:24,490 --> 00:08:29,020
state machine but long story short go

00:08:26,830 --> 00:08:30,280
check out the X State because it's going

00:08:29,020 --> 00:08:33,940
to be a great way for you to represent

00:08:30,280 --> 00:08:36,969
your state's also there's X dates for

00:08:33,940 --> 00:08:39,580
react as well I haven't released version

00:08:36,969 --> 00:08:42,729
1 yet but a lot of people are using the

00:08:39,580 --> 00:08:44,800
use machine hook in production right now

00:08:42,729 --> 00:08:47,830
and so the idea is you would have this

00:08:44,800 --> 00:08:49,720
used machine hook you would you would

00:08:47,830 --> 00:08:52,150
use it just like a used reducer hook and

00:08:49,720 --> 00:08:53,860
use it directly within your application

00:08:52,150 --> 00:08:56,950
now execute

00:08:53,860 --> 00:08:58,870
also be used with you angular's felt all

00:08:56,950 --> 00:09:01,050
these other things I don't have official

00:08:58,870 --> 00:09:03,279
plugins for these quite yet just because

00:09:01,050 --> 00:09:06,519
don't tell them reacting but it just

00:09:03,279 --> 00:09:10,120
works so with with react we sort of had

00:09:06,519 --> 00:09:11,740
to make it happy with hooks and so the

00:09:10,120 --> 00:09:14,680
idea is that we're trying to prevent

00:09:11,740 --> 00:09:17,350
this leak of faulty logic edge cases and

00:09:14,680 --> 00:09:21,790
race conditions instead of just lapping

00:09:17,350 --> 00:09:24,399
a disabled button everywhere and having

00:09:21,790 --> 00:09:26,110
that be the end of that so let's take an

00:09:24,399 --> 00:09:29,140
example application let's say that we

00:09:26,110 --> 00:09:31,480
have this this feedback form where

00:09:29,140 --> 00:09:33,399
you're asked how was your experience the

00:09:31,480 --> 00:09:35,200
user could click good in which it says

00:09:33,399 --> 00:09:37,990
things for your feedback or the user

00:09:35,200 --> 00:09:39,970
could click bad in which it says tell me

00:09:37,990 --> 00:09:42,399
why and then there's an option for the

00:09:39,970 --> 00:09:44,800
user to fill out the form so this is

00:09:42,399 --> 00:09:47,350
what that looks like you have a good

00:09:44,800 --> 00:09:50,550
says thanks for your feedback again it's

00:09:47,350 --> 00:09:53,850
a very very simple form you can say no

00:09:50,550 --> 00:09:58,269
it's submit thanks for your feedback

00:09:53,850 --> 00:10:00,160
nothing too difficult to to code but

00:09:58,269 --> 00:10:02,380
we're moving beyond just coding now we

00:10:00,160 --> 00:10:05,620
want to create an adaptive user

00:10:02,380 --> 00:10:07,570
interface so here's a game plan first we

00:10:05,620 --> 00:10:09,820
want to represent this app as an

00:10:07,570 --> 00:10:11,769
abstract model of course that's using

00:10:09,820 --> 00:10:14,290
state machines and state charts then

00:10:11,769 --> 00:10:18,399
we're going to use transition analytics

00:10:14,290 --> 00:10:20,500
to determine the just frequency of how

00:10:18,399 --> 00:10:23,800
often the user goes from one state to

00:10:20,500 --> 00:10:25,930
the next state and then we identify the

00:10:23,800 --> 00:10:28,630
paths that could be adaptive and improve

00:10:25,930 --> 00:10:31,959
the user experience and use the analysis

00:10:28,630 --> 00:10:35,440
from step two in that adaptation feeding

00:10:31,959 --> 00:10:37,570
it back in real time so we need a few

00:10:35,440 --> 00:10:40,029
concepts to learn in order to do this

00:10:37,570 --> 00:10:41,320
first one is weighted graphs you might

00:10:40,029 --> 00:10:43,240
have learned this in school but if you

00:10:41,320 --> 00:10:45,070
haven't it's actually a pretty simple

00:10:43,240 --> 00:10:46,660
concept let's say that when you're

00:10:45,070 --> 00:10:49,779
signing in you could be in a success

00:10:46,660 --> 00:10:52,540
state or a failure state in which case

00:10:49,779 --> 00:10:53,949
you're not able to sign in so what you

00:10:52,540 --> 00:10:56,890
could do is you can measure how

00:10:53,949 --> 00:10:59,410
frequently do users actually go from one

00:10:56,890 --> 00:11:02,140
state to the next States and so by doing

00:10:59,410 --> 00:11:04,329
that now you have a weight on that edge

00:11:02,140 --> 00:11:05,350
and you can represent it visually like

00:11:04,329 --> 00:11:08,870
this

00:11:05,350 --> 00:11:11,390
so our applications can be represented

00:11:08,870 --> 00:11:14,060
by these weighted graphs in a way that

00:11:11,390 --> 00:11:16,160
we could visually see what are the most

00:11:14,060 --> 00:11:18,320
frequently traversed paths throughout

00:11:16,160 --> 00:11:22,610
the application that users would go

00:11:18,320 --> 00:11:24,290
through and so a a path a diagram that

00:11:22,610 --> 00:11:26,270
looks like this might end up looking

00:11:24,290 --> 00:11:27,980
like this in reality in which we could

00:11:26,270 --> 00:11:31,250
see that some of the states aren't

00:11:27,980 --> 00:11:33,710
really traversed quite the same now in

00:11:31,250 --> 00:11:36,080
Visual Studio Live share I actually used

00:11:33,710 --> 00:11:39,020
this technique in the state machine that

00:11:36,080 --> 00:11:42,470
was used within vs code and we were able

00:11:39,020 --> 00:11:45,260
to measure just how frequently users

00:11:42,470 --> 00:11:48,110
were either signing in sharing a session

00:11:45,260 --> 00:11:50,330
adjoining a session whether we had a

00:11:48,110 --> 00:11:52,700
high frequency of errors or not in a

00:11:50,330 --> 00:11:55,070
very visually clear way that connected

00:11:52,700 --> 00:11:58,070
all the dots you know based on how the

00:11:55,070 --> 00:12:00,920
application worked okay so let's make

00:11:58,070 --> 00:12:04,520
this adaptive let's say that when the

00:12:00,920 --> 00:12:06,950
user clicks bad we want to sort of give

00:12:04,520 --> 00:12:09,980
them the option to either fill out the

00:12:06,950 --> 00:12:16,880
form or not so let's take a look at how

00:12:09,980 --> 00:12:20,180
that might work what we could do is we

00:12:16,880 --> 00:12:22,640
can measure each of the paths taken and

00:12:20,180 --> 00:12:24,500
hopefully prints of the demo gods here

00:12:22,640 --> 00:12:27,800
so for example when you click good and

00:12:24,500 --> 00:12:29,990
reload we measure the count so this is

00:12:27,800 --> 00:12:32,510
just a very simple example but let's say

00:12:29,990 --> 00:12:33,950
I click bad and I see this form I don't

00:12:32,510 --> 00:12:36,830
want to fill out this form so I just

00:12:33,950 --> 00:12:38,600
exit and so let's say that I keep having

00:12:36,830 --> 00:12:40,910
a bad experience but I really don't want

00:12:38,600 --> 00:12:43,220
to fill out the form and so this isn't

00:12:40,910 --> 00:12:46,610
good because this is an incomplete user

00:12:43,220 --> 00:12:48,950
flow but you see when we have an

00:12:46,610 --> 00:12:50,810
adaptive user interface we could

00:12:48,950 --> 00:12:52,820
actually you see what just happened

00:12:50,810 --> 00:12:55,730
there we could actually redirect the

00:12:52,820 --> 00:12:57,440
user to a different state and so this is

00:12:55,730 --> 00:12:59,540
easily done with these state machines

00:12:57,440 --> 00:13:01,970
and state charts because we have these

00:12:59,540 --> 00:13:05,000
hats represented as directed graphs and

00:13:01,970 --> 00:13:07,850
now we could just measure in the debt in

00:13:05,000 --> 00:13:12,620
real time based on what the users

00:13:07,850 --> 00:13:15,230
actions are so this is a way of

00:13:12,620 --> 00:13:17,270
analyzing by transitions and you could

00:13:15,230 --> 00:13:18,899
probably think of many more applications

00:13:17,270 --> 00:13:20,819
in which you could do this

00:13:18,899 --> 00:13:23,730
for example if you're on Instagram and

00:13:20,819 --> 00:13:26,129
you see when the user logs in that the

00:13:23,730 --> 00:13:28,559
most frequent state that they go to next

00:13:26,129 --> 00:13:31,499
is the camera instead of the gallery of

00:13:28,559 --> 00:13:33,689
the profile you could shortcut the fact

00:13:31,499 --> 00:13:35,879
that when they log in they go directly

00:13:33,689 --> 00:13:38,009
to the camera instead of whether they're

00:13:35,879 --> 00:13:39,720
whatever other default state that they

00:13:38,009 --> 00:13:43,079
might be in now

00:13:39,720 --> 00:13:46,050
decision trees can also be useful in in

00:13:43,079 --> 00:13:48,059
determining which paths we wants to take

00:13:46,050 --> 00:13:50,639
and so I'm not going to go through this

00:13:48,059 --> 00:13:52,589
but there's a lot of useful info in

00:13:50,639 --> 00:13:54,869
towards data science which I'm going to

00:13:52,589 --> 00:13:57,420
be mentioning later in this talk as well

00:13:54,869 --> 00:14:00,149
now prediction can also be done via

00:13:57,420 --> 00:14:03,740
shortest paths which I'm also not going

00:14:00,149 --> 00:14:07,019
to get into but we could use this

00:14:03,740 --> 00:14:09,089
analytics tracking within within our

00:14:07,019 --> 00:14:11,699
services so for example the next state

00:14:09,089 --> 00:14:14,459
we have this on transition callback

00:14:11,699 --> 00:14:16,740
which this is the only place in which

00:14:14,459 --> 00:14:19,079
we're tracking analytics because that's

00:14:16,740 --> 00:14:21,689
the singular place in which all state

00:14:19,079 --> 00:14:23,970
transitions are represented in other

00:14:21,689 --> 00:14:26,579
words what this means is you don't need

00:14:23,970 --> 00:14:28,949
to litter your entire application with

00:14:26,579 --> 00:14:30,480
analytics or telemetry calls you have

00:14:28,949 --> 00:14:33,329
one single place to do it

00:14:30,480 --> 00:14:36,360
and so you would provide a target event

00:14:33,329 --> 00:14:41,100
a source and possibly the time stamp for

00:14:36,360 --> 00:14:42,660
that event to happen so let's sort of

00:14:41,100 --> 00:14:45,689
think about some future ideas for

00:14:42,660 --> 00:14:47,790
analysis as well higher order Markov

00:14:45,689 --> 00:14:50,610
models are a very interesting topic

00:14:47,790 --> 00:14:52,230
because what they represent is let's say

00:14:50,610 --> 00:14:54,360
you have a weighted graph in which

00:14:52,230 --> 00:14:56,850
you're in state a and you're measuring

00:14:54,360 --> 00:14:59,519
whether your go to state B or C so it

00:14:56,850 --> 00:15:02,610
might seem that overall the the user

00:14:59,519 --> 00:15:04,949
goes from A to B most often but if

00:15:02,610 --> 00:15:08,040
they're coming from D then they might go

00:15:04,949 --> 00:15:10,079
to see more often and so that sort of

00:15:08,040 --> 00:15:12,589
changes the dynamic of how the user

00:15:10,079 --> 00:15:16,889
actually behaves with the application

00:15:12,589 --> 00:15:19,470
also store of a crazy concept but using

00:15:16,889 --> 00:15:22,740
deep reinforcement learning within your

00:15:19,470 --> 00:15:26,360
applications you could actually measure

00:15:22,740 --> 00:15:29,160
and train an agent to determine which

00:15:26,360 --> 00:15:31,470
which path is the most likely path a

00:15:29,160 --> 00:15:32,630
user is going to take and so that's done

00:15:31,470 --> 00:15:35,360
by the agents

00:15:32,630 --> 00:15:37,069
just experimenting and saying I think

00:15:35,360 --> 00:15:39,290
they're gonna go here and then what the

00:15:37,069 --> 00:15:41,120
user actually does is fed back into the

00:15:39,290 --> 00:15:42,800
agent and they're either rewarded or

00:15:41,120 --> 00:15:45,709
punished based on whether the user

00:15:42,800 --> 00:15:47,990
actually takes that action and so we

00:15:45,709 --> 00:15:49,850
could feed that into our environments

00:15:47,990 --> 00:15:52,699
which is the abstract model that we've

00:15:49,850 --> 00:15:56,449
created and use that to sort of adapt

00:15:52,699 --> 00:15:58,220
the user interface in real time so you

00:15:56,449 --> 00:16:00,470
might be thinking wait seriously like

00:15:58,220 --> 00:16:02,750
can I can we really use reinforcement

00:16:00,470 --> 00:16:06,259
learning in the browser while the user

00:16:02,750 --> 00:16:08,600
is interacting with the app and yes you

00:16:06,259 --> 00:16:11,060
can you're just gonna have to sort of

00:16:08,600 --> 00:16:15,350
take my word for it all right actually

00:16:11,060 --> 00:16:16,790
found let's see a demo so if you

00:16:15,350 --> 00:16:18,920
remember from last year I made this

00:16:16,790 --> 00:16:20,949
tic-tac-toe app using finite state

00:16:18,920 --> 00:16:24,290
machines because that's sort of my brand

00:16:20,949 --> 00:16:26,630
but you can see that this is just a

00:16:24,290 --> 00:16:29,899
normal tic-tac-toe game in which player

00:16:26,630 --> 00:16:31,550
X player oh can play but what you might

00:16:29,899 --> 00:16:34,370
not know I'm a terrible tic-tac-toe

00:16:31,550 --> 00:16:36,079
player all right there we go we drew but

00:16:34,370 --> 00:16:40,100
what you might not know is that we could

00:16:36,079 --> 00:16:42,410
capture analytics on what the user is

00:16:40,100 --> 00:16:45,110
most likely to do so if I turn on the

00:16:42,410 --> 00:16:47,600
frequency here I could see that the user

00:16:45,110 --> 00:16:50,000
is most likely to click for example the

00:16:47,600 --> 00:16:53,000
center one and then from here we played

00:16:50,000 --> 00:16:56,360
a bunch of games here and so you know

00:16:53,000 --> 00:16:59,540
I'll just play here we could see that

00:16:56,360 --> 00:17:02,750
even in bored states that we don't

00:16:59,540 --> 00:17:05,510
really we haven't really represented or

00:17:02,750 --> 00:17:08,809
played yet that those are all grayed out

00:17:05,510 --> 00:17:12,500
but when we reset we could see that

00:17:08,809 --> 00:17:14,059
things that we played again it shows up

00:17:12,500 --> 00:17:17,900
you know in the frequency of each of the

00:17:14,059 --> 00:17:20,260
squares so let's take this to the next

00:17:17,900 --> 00:17:23,209
level let's actually introduce a

00:17:20,260 --> 00:17:26,510
reinforcement learning agent and have it

00:17:23,209 --> 00:17:29,000
predict all of those unknown game states

00:17:26,510 --> 00:17:30,770
so what it's going to do is it's going

00:17:29,000 --> 00:17:36,230
to behave like a human so it might not

00:17:30,770 --> 00:17:39,320
be the best AI but it will it will try

00:17:36,230 --> 00:17:42,380
its best so what it's going to do is

00:17:39,320 --> 00:17:44,210
it's going to play like a human and you

00:17:42,380 --> 00:17:45,980
could see those learning values over

00:17:44,210 --> 00:17:47,690
here on each of the squares and

00:17:45,980 --> 00:17:50,150
I could play against it let's say I play

00:17:47,690 --> 00:17:52,429
here and you see it shows the most

00:17:50,150 --> 00:17:54,250
frequently traversed path so now let's

00:17:52,429 --> 00:17:57,559
say I do something new I go over here

00:17:54,250 --> 00:18:00,470
it's still going to try to adapt based

00:17:57,559 --> 00:18:06,250
on how the users have actually played

00:18:00,470 --> 00:18:09,080
and so in other words we have created a

00:18:06,250 --> 00:18:10,520
reinforcement learning agent right in

00:18:09,080 --> 00:18:19,730
the browser and I'm going to share this

00:18:10,520 --> 00:18:21,830
code after the demo so and of course if

00:18:19,730 --> 00:18:25,240
it failed I have a video to show you so

00:18:21,830 --> 00:18:28,100
the good news is that this does work and

00:18:25,240 --> 00:18:30,559
the bad news is that when I was trying

00:18:28,100 --> 00:18:32,990
this out a hundred times last night I

00:18:30,559 --> 00:18:34,970
got this fail to compile air and react

00:18:32,990 --> 00:18:37,250
of course but I got it because I had no

00:18:34,970 --> 00:18:40,160
space left on my device I'm not sure

00:18:37,250 --> 00:18:44,480
whether that's the fault of my analytics

00:18:40,160 --> 00:18:46,549
tool or my actual computer so again the

00:18:44,480 --> 00:18:48,740
idea is that we have an application we

00:18:46,549 --> 00:18:50,960
represent it as an executable model and

00:18:48,740 --> 00:18:53,390
then we use this metric tracking in

00:18:50,960 --> 00:18:55,400
real-time within our model and

00:18:53,390 --> 00:18:57,350
potentially even feed it to something

00:18:55,400 --> 00:19:01,130
like Google Analytics KISSmetrics

00:18:57,350 --> 00:19:03,679
segment do Mixpanel or even as your

00:19:01,130 --> 00:19:06,830
analytics and then we feed that back

00:19:03,679 --> 00:19:08,750
into the application and feed it into

00:19:06,830 --> 00:19:11,480
these adaptive transitions within our

00:19:08,750 --> 00:19:14,799
app and then we have an adaptive user

00:19:11,480 --> 00:19:19,669
interface that works in real-time so

00:19:14,799 --> 00:19:22,700
this is great in the process of having a

00:19:19,669 --> 00:19:25,280
great dev experience but also using your

00:19:22,700 --> 00:19:28,040
dev experience to create a great user

00:19:25,280 --> 00:19:30,260
experience as well because when we go

00:19:28,040 --> 00:19:33,260
from having the determinism of state

00:19:30,260 --> 00:19:35,030
machines to having the way to simulate

00:19:33,260 --> 00:19:37,250
how users are going to behave with our

00:19:35,030 --> 00:19:40,130
app through simulation and analytics

00:19:37,250 --> 00:19:42,650
then we ultimately can create a great

00:19:40,130 --> 00:19:44,929
user experience and go beyond the code

00:19:42,650 --> 00:19:48,980
that we just wrote to make the app work

00:19:44,929 --> 00:19:53,240
and use that exact same code to actually

00:19:48,980 --> 00:19:55,730
improve user experiences so ex-state

00:19:53,240 --> 00:19:58,669
does have a lot of utilities and tools

00:19:55,730 --> 00:19:59,610
that i've created and i actually just

00:19:58,669 --> 00:20:01,620
published x date

00:19:59,610 --> 00:20:04,679
analytics but do not use it yet because

00:20:01,620 --> 00:20:07,320
I do want to figure out that memory leak

00:20:04,679 --> 00:20:09,600
problem and so I would caution you

00:20:07,320 --> 00:20:12,030
against that and also the next version

00:20:09,600 --> 00:20:14,670
of X date 4.7 is coming soon

00:20:12,030 --> 00:20:16,410
thank you to Matias for really helping

00:20:14,670 --> 00:20:17,520
out with that and so if you want to play

00:20:16,410 --> 00:20:21,030
around with that right now you could

00:20:17,520 --> 00:20:23,549
just NPM install X date at next and also

00:20:21,030 --> 00:20:25,140
the first talk to stay Gatsby you would

00:20:23,549 --> 00:20:28,620
be surprised to know that if you use

00:20:25,140 --> 00:20:31,290
Gatsby in the background you are using X

00:20:28,620 --> 00:20:33,900
States because Gatsby uses this for it's

00:20:31,290 --> 00:20:37,470
very complex build processes which are

00:20:33,900 --> 00:20:38,970
of course very very important to making

00:20:37,470 --> 00:20:42,120
the dev experience as good as possible

00:20:38,970 --> 00:20:43,890
which it is working with Gatsby so

00:20:42,120 --> 00:20:46,049
there's a lot of resources if you want

00:20:43,890 --> 00:20:49,110
to learn more about working with state

00:20:46,049 --> 00:20:51,150
charts and also the documentation czar a

00:20:49,110 --> 00:20:53,880
good resource to I actually included

00:20:51,150 --> 00:20:56,340
embedded visualizations right within the

00:20:53,880 --> 00:20:56,880
X State documentation so go ahead and

00:20:56,340 --> 00:20:59,070
check that out

00:20:56,880 --> 00:21:01,500
and we have a vibrant spectrum community

00:20:59,070 --> 00:21:03,600
in which we talk about these abstract

00:21:01,500 --> 00:21:05,850
modeling concepts such as state machine

00:21:03,600 --> 00:21:06,540
state charts Petri Nets all this sort of

00:21:05,850 --> 00:21:08,280
stuff

00:21:06,540 --> 00:21:10,650
even if it doesn't have anything to do

00:21:08,280 --> 00:21:12,720
with X state it's just these old ideas

00:21:10,650 --> 00:21:15,290
of state machines and state charts which

00:21:12,720 --> 00:21:18,540
have been around for half a century

00:21:15,290 --> 00:21:20,760
which are just coming to light now and

00:21:18,540 --> 00:21:23,910
being more and more relevant in the

00:21:20,760 --> 00:21:26,340
front-end community so ultimately I want

00:21:23,910 --> 00:21:29,610
to make your code do more I want your

00:21:26,340 --> 00:21:33,000
code to actually be able to analyze have

00:21:29,610 --> 00:21:35,460
tests automatically generated have even

00:21:33,000 --> 00:21:37,350
documentation automatically generated be

00:21:35,460 --> 00:21:40,110
able to simulate how a user behaves in

00:21:37,350 --> 00:21:42,750
real life and possibly even predict how

00:21:40,110 --> 00:21:45,710
users behave so thank you very much

00:21:42,750 --> 00:21:45,710
reactive Compton

00:21:46,380 --> 00:21:52,130
[Applause]

00:21:49,490 --> 00:21:55,669
David cor she thank you so much we have

00:21:52,130 --> 00:21:58,460
some questions for you talking about DAF

00:21:55,669 --> 00:22:00,559
steps leading to various usage paths do

00:21:58,460 --> 00:22:03,740
you think it would be useful to adjust

00:22:00,559 --> 00:22:05,360
the UI even if an app based on the

00:22:03,740 --> 00:22:07,130
previous user activity

00:22:05,360 --> 00:22:09,230
have you ever interacted with an app

00:22:07,130 --> 00:22:11,059
that's just so complex and you find

00:22:09,230 --> 00:22:12,830
yourself doing the same steps over and

00:22:11,059 --> 00:22:15,080
over again what if those steps could be

00:22:12,830 --> 00:22:18,110
automated so I would say that yes it is

00:22:15,080 --> 00:22:20,809
very very useful to have these adaptive

00:22:18,110 --> 00:22:23,299
paths because ultimately the goal is to

00:22:20,809 --> 00:22:26,270
make the user do what they do faster and

00:22:23,299 --> 00:22:29,059
better can I write a test that is going

00:22:26,270 --> 00:22:31,940
through all possible UI states with AK

00:22:29,059 --> 00:22:34,730
State how does this approach work with

00:22:31,940 --> 00:22:36,679
manual and automated tests yes you can

00:22:34,730 --> 00:22:40,700
use X date to do that there is a library

00:22:36,679 --> 00:22:42,590
called x8 slash test and I actually gave

00:22:40,700 --> 00:22:45,140
a presentation that reacts rally a few

00:22:42,590 --> 00:22:46,909
months ago talking about that and it's

00:22:45,140 --> 00:22:48,799
called model-based testing which has

00:22:46,909 --> 00:22:51,649
also been around for quite a few years

00:22:48,799 --> 00:22:54,080
so yes short answer and the last

00:22:51,649 --> 00:22:55,970
question is there a plan to adapt this

00:22:54,080 --> 00:22:58,669
predictive design through Microsoft

00:22:55,970 --> 00:23:00,169
products so I try to think x8 and

00:22:58,669 --> 00:23:02,480
Microsoft products but there's only so

00:23:00,169 --> 00:23:05,299
much I could do maybe one day I could

00:23:02,480 --> 00:23:07,100
talk to them and hopefully do that thank

00:23:05,299 --> 00:23:10,280
you so much David Gore sheet

00:23:07,100 --> 00:23:10,280

YouTube URL: https://www.youtube.com/watch?v=na1-RumWtxE


