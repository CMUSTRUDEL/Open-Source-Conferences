Title: ReactiveConf 2019 Lightning Talks Day #2- Konstantin Lebedev
Publication date: 2019-10-31
Playlist: ReactiveConf 2019
Description: 
	Oct 30 - Nov 1, 2019
Prague, Czech Republic
https://reactiveconf.com/
Millennium stage
Captions: 
	00:00:02,240 --> 00:00:11,320
[Music]

00:00:16,029 --> 00:00:22,369
all right thanks for coming I guess we

00:00:19,789 --> 00:00:24,999
can start right away so we all want

00:00:22,369 --> 00:00:27,619
better experience for our users and

00:00:24,999 --> 00:00:30,429
animations is a crucial ingredient for

00:00:27,619 --> 00:00:34,780
providing a better experience subtle

00:00:30,429 --> 00:00:37,239
contextual animations engage users

00:00:34,780 --> 00:00:41,030
reinforce their interactions and

00:00:37,239 --> 00:00:43,760
generally create a more native feel for

00:00:41,030 --> 00:00:45,859
web applications however if these

00:00:43,760 --> 00:00:49,390
animations have poor runtime performance

00:00:45,859 --> 00:00:52,760
and cause application to lag work slowly

00:00:49,390 --> 00:00:55,399
then instead of improving UX we achieve

00:00:52,760 --> 00:00:57,710
the opposite effect so let's take a look

00:00:55,399 --> 00:01:00,019
at few techniques that we can use to

00:00:57,710 --> 00:01:02,570
make sure that our animations run

00:01:00,019 --> 00:01:07,370
smoothly every time even on low-end

00:01:02,570 --> 00:01:10,190
devices first of all if an element will

00:01:07,370 --> 00:01:11,360
be animated but it doesn't accept any

00:01:10,190 --> 00:01:14,390
input from the user

00:01:11,360 --> 00:01:17,120
though I can use pointer event none CSS

00:01:14,390 --> 00:01:21,020
property to let browser perform some

00:01:17,120 --> 00:01:24,050
micro optimizations under the hood we

00:01:21,020 --> 00:01:25,820
can also use will change property to let

00:01:24,050 --> 00:01:28,580
browser optimize things further

00:01:25,820 --> 00:01:31,550
however we should be aware that as a

00:01:28,580 --> 00:01:34,190
result the element will be promoted to a

00:01:31,550 --> 00:01:35,450
separate layout layer this is very

00:01:34,190 --> 00:01:37,790
expensive operation

00:01:35,450 --> 00:01:41,180
so it's important to use will change

00:01:37,790 --> 00:01:44,450
property correctly we should never use a

00:01:41,180 --> 00:01:47,900
wild card selector for the elements or

00:01:44,450 --> 00:01:50,300
all for the value and instead applied

00:01:47,900 --> 00:01:54,830
only to the elements that we know will

00:01:50,300 --> 00:01:56,630
change also for optimal performance it

00:01:54,830 --> 00:01:58,760
is recommended to it will change

00:01:56,630 --> 00:02:02,510
property right before animation begins

00:01:58,760 --> 00:02:04,820
and remove it after it finishes so for

00:02:02,510 --> 00:02:07,190
example if we animate element on click

00:02:04,820 --> 00:02:12,020
it's a good idea to add will change

00:02:07,190 --> 00:02:13,910
property on hover the most impactful

00:02:12,020 --> 00:02:16,650
optimization that we can make though is

00:02:13,910 --> 00:02:19,860
to animate only opacity and

00:02:16,650 --> 00:02:22,409
foreign properties one browser renders

00:02:19,860 --> 00:02:23,459
elements it usually does so in three

00:02:22,409 --> 00:02:26,400
steps

00:02:23,459 --> 00:02:28,909
it plays things out on the page paints

00:02:26,400 --> 00:02:31,590
the color and top of it and that applies

00:02:28,909 --> 00:02:35,459
transform adjustments during composite

00:02:31,590 --> 00:02:37,530
step animating most CSS properties will

00:02:35,459 --> 00:02:40,170
result in browser going through all

00:02:37,530 --> 00:02:42,930
three stages for every animation frame

00:02:40,170 --> 00:02:45,900
but if we animate only transform and

00:02:42,930 --> 00:02:49,769
opacity then the browser will have to do

00:02:45,900 --> 00:02:52,819
only the last one even more first two

00:02:49,769 --> 00:02:56,129
steps run on the main JavaScript thread

00:02:52,819 --> 00:02:58,730
whereas the last composite thread runs

00:02:56,129 --> 00:03:02,159
on a separate GPU accelerated thread

00:02:58,730 --> 00:03:04,829
which means that by animating opacity

00:03:02,159 --> 00:03:07,260
and transform properties not only do we

00:03:04,829 --> 00:03:09,420
get smoother animations but we also

00:03:07,260 --> 00:03:13,189
don't have to fight with the rest of our

00:03:09,420 --> 00:03:16,799
app for the time on the main thread and

00:03:13,189 --> 00:03:19,409
sometimes it may seem that we need to

00:03:16,799 --> 00:03:21,780
animate other properties but we still

00:03:19,409 --> 00:03:25,500
can get away with just transform

00:03:21,780 --> 00:03:28,290
animations when we want to animate the

00:03:25,500 --> 00:03:31,560
size of the element we can use scale

00:03:28,290 --> 00:03:33,629
counter scale technique for example if

00:03:31,560 --> 00:03:37,290
we want to animate the height of the

00:03:33,629 --> 00:03:41,250
element instead of animating height will

00:03:37,290 --> 00:03:43,889
apply scale Y transformation as a result

00:03:41,250 --> 00:03:46,440
the content of this element will get

00:03:43,889 --> 00:03:49,379
stretched out and so to counter that

00:03:46,440 --> 00:03:52,680
effect we'll wrap the insights into

00:03:49,379 --> 00:03:57,090
another container and apply inverse

00:03:52,680 --> 00:03:59,400
scale white transformation to it when we

00:03:57,090 --> 00:04:01,829
enemy when we need to animate both size

00:03:59,400 --> 00:04:05,340
and the position of the element we can

00:04:01,829 --> 00:04:07,680
use flip technique the way it works it

00:04:05,340 --> 00:04:11,099
remembers the bounding boxes for all

00:04:07,680 --> 00:04:14,069
animatable elements in the start and end

00:04:11,099 --> 00:04:16,260
position of the animation then calculate

00:04:14,069 --> 00:04:19,289
the difference between them and uses

00:04:16,260 --> 00:04:21,810
scale and translate transformations to

00:04:19,289 --> 00:04:24,750
run the animation there is a slightly

00:04:21,810 --> 00:04:27,479
more technical details to it but most of

00:04:24,750 --> 00:04:29,220
the time we don't really need to concern

00:04:27,479 --> 00:04:31,320
ourselves with it

00:04:29,220 --> 00:04:35,280
and just taken off the shelf library

00:04:31,320 --> 00:04:38,040
that implements it finally if you

00:04:35,280 --> 00:04:40,740
animate with react make sure to use a

00:04:38,040 --> 00:04:44,850
library that supports transient updates

00:04:40,740 --> 00:04:46,890
and that means that it can animate dumb

00:04:44,850 --> 00:04:49,440
elements without causing the whole

00:04:46,890 --> 00:04:52,500
component to re-render and two good

00:04:49,440 --> 00:04:56,580
examples of such libraries react spring

00:04:52,500 --> 00:04:58,740
and frame emotion anyway that's all I

00:04:56,580 --> 00:05:01,170
have time for if you want to talk about

00:04:58,740 --> 00:05:03,690
web animations you can find me in a

00:05:01,170 --> 00:05:05,570
break and I'm happy to answer your

00:05:03,690 --> 00:05:06,340
questions thank you

00:05:05,570 --> 00:05:09,529
[Applause]

00:05:06,340 --> 00:05:09,529

YouTube URL: https://www.youtube.com/watch?v=U4OjAr0NH_w


