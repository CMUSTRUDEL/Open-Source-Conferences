Title: ReactiveConf 2016 - Sean Grove: The Age of Reason(ML)
Publication date: 2016-11-24
Playlist: ReactiveConf 2016
Description: 
	https://reactiveconf.com 

Meet those driving the change! World-renowned mobile and web innovators got together for three days in one town.

ReactiveConf, October 26 - 28 2016, Bratislava, Slovakia

---

Sean Grove: Living in an async world of React Native

Reason is a new developer experience by Facebook built and championed by the same people behind React. Based on OCaml, it offers powerful type-checking, incredible tooling, fantastic performance, and truly unbelievable reach (as in you'll be sceptical that it's possibly true).

Let's look at the range of practical capabilities of Reason - building universal apps that output browser-targeted code indistinguishable from hand-written Javascript but also compiles down to ARM64 assembly for native iOS apps, or replaces 15 *million* lines of memory and type unsafe operating-system code to create unikernel servers that boot in 50 milliseconds and weigh between 200KB-10MB, all from the same codebase - to the more philosophical, such as how Reason is the first language ever to separate syntax and semantics, and all of the resulting implications - and even the more whimsical, like Reason's relentless focus on developer simplicity and joy.

Full-stack apps in one language, from hypervisor unikernel to clients written in React (or ReactNative) - As easy as JavaScript, as delightful as Elm, as powerful as native, and with unprecedented reach - we're finally entering into an age of Reason.

---

Have you heard about ReactiveConf? According to tech superstars such as David Nolen, Richard Feldman, or Brent Vatne, itâ€™s the best conference on web and mobile app development! It focuses on all things React and beyond and takes place annually in Bratislava, Slovakia.

In 2016, more than 700 attendees from all over the world spent three days in Bratislava getting inspired, sharing amazing new ideas, and meeting more than 30 awesome speakers from companies such as Google, Cognitect, NoRedInk, RethinkDB, Airbnb, Microsoft, Facebook, and the list could go on forever.

If you want to be part of the next event, get your tickets now at https://reactiveconf.com, and React with us!
Captions: 
	00:00:07,679 --> 00:00:12,840
so the rule for presentations is to keep

00:00:10,769 --> 00:00:15,629
it simple as few things as possible just

00:00:12,840 --> 00:00:16,740
focus on one thing so of course I'm

00:00:15,629 --> 00:00:18,689
gonna talk about about a hundred

00:00:16,740 --> 00:00:20,670
different things about a language so

00:00:18,689 --> 00:00:24,480
we're gonna fly through this first of

00:00:20,670 --> 00:00:24,930
all I'll have her talk reason oh this is

00:00:24,480 --> 00:00:26,940
beautiful

00:00:24,930 --> 00:00:30,360
alright how people have heard of Oh

00:00:26,940 --> 00:00:31,800
Chemosh Lee alright people raise their

00:00:30,360 --> 00:00:39,749
hands how many people have built on the

00:00:31,800 --> 00:00:41,100
vocabulary so reason is a language it's

00:00:39,749 --> 00:00:43,319
actually more of a developer experience

00:00:41,100 --> 00:00:46,409
based around okay okay I'll give you a

00:00:43,319 --> 00:00:49,469
bunch of very very cool features and the

00:00:46,409 --> 00:00:52,079
reason is basically a polishing and less

00:00:49,469 --> 00:00:54,269
drama so some of the goals behind it

00:00:52,079 --> 00:00:57,269
it's built by the same people that built

00:00:54,269 --> 00:00:59,940
reacts it's also smart to have a very

00:00:57,269 --> 00:01:01,920
friendly syntax a very very powerful

00:00:59,940 --> 00:01:03,809
tool very conscientious belief in the

00:01:01,920 --> 00:01:05,610
form of a very very deep editor

00:01:03,809 --> 00:01:09,420
integration and very carefully

00:01:05,610 --> 00:01:12,960
thought-out build so first off how do

00:01:09,420 --> 00:01:16,400
you guys have heard a pacman complete

00:01:12,960 --> 00:01:19,130
language so I like this

00:01:16,400 --> 00:01:20,510
this metric events so we are touring

00:01:19,130 --> 00:01:22,610
public languages but that's on a very

00:01:20,510 --> 00:01:24,590
interesting metric right there are lots

00:01:22,610 --> 00:01:25,370
of pretty boring languages that are very

00:01:24,590 --> 00:01:27,170
complete

00:01:25,370 --> 00:01:30,620
it's only a cool language if you can

00:01:27,170 --> 00:01:33,320
actually do normal background in it so

00:01:30,620 --> 00:01:35,840
just show you real quick I'm going to

00:01:33,320 --> 00:01:38,570
actually compile this this is a live

00:01:35,840 --> 00:01:41,510
nativity L or native OpenGL application

00:01:38,570 --> 00:01:42,710
built in reason it's real witness for

00:01:41,510 --> 00:01:45,740
those of you who are familiar with the

00:01:42,710 --> 00:01:48,050
game lemon actually go through here I

00:01:45,740 --> 00:01:49,610
mean that was really awesome right

00:01:48,050 --> 00:01:54,610
actually solve that maze in front of

00:01:49,610 --> 00:01:54,610
everyone under pressure but this is a

00:01:55,780 --> 00:02:00,800
reason can actually build native

00:01:57,860 --> 00:02:02,390
applications it's very cool so whenever

00:02:00,800 --> 00:02:04,220
we think about programming like I

00:02:02,390 --> 00:02:05,750
inherently think it's kind of a fun

00:02:04,220 --> 00:02:07,850
thing it's something I enjoy doing and I

00:02:05,750 --> 00:02:08,660
think most of us would say that if we

00:02:07,850 --> 00:02:10,220
were asked

00:02:08,660 --> 00:02:13,040
I will actually inherently enjoy

00:02:10,220 --> 00:02:15,560
programming but there are times where I

00:02:13,040 --> 00:02:17,240
find myself fostering programming and I

00:02:15,560 --> 00:02:19,790
try to separate those times and it kind

00:02:17,240 --> 00:02:23,120
of focus on what is it about programming

00:02:19,790 --> 00:02:25,310
that's I dislike at times sometimes it's

00:02:23,120 --> 00:02:27,480
kind of if the computer's not helping me

00:02:25,310 --> 00:02:30,450
out very much if there are bugs on

00:02:27,480 --> 00:02:33,209
 down and recent goes out of its

00:02:30,450 --> 00:02:34,049
way to address a lot of the issues that

00:02:33,209 --> 00:02:35,760
you might have

00:02:34,049 --> 00:02:37,830
whenever you're frustrated with whatever

00:02:35,760 --> 00:02:40,319
your programming so it's happened the

00:02:37,830 --> 00:02:42,000
goldilocks of languages where it

00:02:40,319 --> 00:02:45,110
actually helps it rise very very hard to

00:02:42,000 --> 00:02:47,640
help you whenever you're programming

00:02:45,110 --> 00:02:50,670
oftentimes so if you're another lot of

00:02:47,640 --> 00:02:52,860
different type systems feel like tech

00:02:50,670 --> 00:02:54,690
systems are like haters in the rap game

00:02:52,860 --> 00:02:56,519
right so the compiler is always there

00:02:54,690 --> 00:02:57,510
like looking for you to fail trying to

00:02:56,519 --> 00:02:59,610
send you like what you're doing wrong

00:02:57,510 --> 00:03:02,069
but actually reason does a really good

00:02:59,610 --> 00:03:04,230
job of kind of helping you along the way

00:03:02,069 --> 00:03:05,760
and saying actually suggesting how you

00:03:04,230 --> 00:03:08,700
can improve your code or how you can fix

00:03:05,760 --> 00:03:11,489
it and for those of you like it's a very

00:03:08,700 --> 00:03:14,160
subtle here but so you can see how hold

00:03:11,489 --> 00:03:14,519
it really very fun there it's very

00:03:14,160 --> 00:03:15,989
subtle

00:03:14,519 --> 00:03:17,310
you guys won't realize that but it's

00:03:15,989 --> 00:03:20,310
kind of subconscious because our

00:03:17,310 --> 00:03:21,690
thinking is already very fun so one of

00:03:20,310 --> 00:03:24,420
the things that makes it really fun is

00:03:21,690 --> 00:03:27,209
the tooling so recent it just focuses

00:03:24,420 --> 00:03:28,829
crazy part on tooling to the point where

00:03:27,209 --> 00:03:30,150
it's kind of like having a robotic pair

00:03:28,829 --> 00:03:31,470
buddy with you whenever you're first

00:03:30,150 --> 00:03:33,329
learning and one of the actually

00:03:31,470 --> 00:03:35,400
developing production applications a

00:03:33,329 --> 00:03:40,230
reason give you example what this looks

00:03:35,400 --> 00:03:41,040
like that we want to write function call

00:03:40,230 --> 00:03:42,299
it a Sode

00:03:41,040 --> 00:03:44,880
and what we're gonna do is actually

00:03:42,299 --> 00:03:46,799
enumerates we're gonna swig match on the

00:03:44,880 --> 00:03:49,079
integer and we need to write all those

00:03:46,799 --> 00:03:51,239
cases and so if we're writing a function

00:03:49,079 --> 00:03:54,750
we're saying if it's zero it's not all

00:03:51,239 --> 00:03:56,549
one it is - it is not and as soon as we

00:03:54,750 --> 00:03:59,669
hit save it's actually going to tell us

00:03:56,549 --> 00:04:02,489
by the way I checked your code you miss

00:03:59,669 --> 00:04:05,160
the case in fact here's an example of a

00:04:02,489 --> 00:04:08,200
value that you're going to have a run

00:04:05,160 --> 00:04:10,510
so know that as soon as you hit save

00:04:08,200 --> 00:04:12,190
your buddy is watching your back it's

00:04:10,510 --> 00:04:15,370
making sure that's like your code is

00:04:12,190 --> 00:04:18,190
safe but that's like more realistic

00:04:15,370 --> 00:04:20,380
example might be something like this we

00:04:18,190 --> 00:04:22,780
have a type of animal I know maybe a cat

00:04:20,380 --> 00:04:25,120
dog or a bird and we're gonna switch

00:04:22,780 --> 00:04:27,490
over it's inside our function and if we

00:04:25,120 --> 00:04:31,090
only return so say we only handle

00:04:27,490 --> 00:04:33,010
captain dog accentuated save it's going

00:04:31,090 --> 00:04:34,240
to tell us that we forgot heard and

00:04:33,010 --> 00:04:35,530
actually this is really important to

00:04:34,240 --> 00:04:37,570
take and imagine that there are lots of

00:04:35,530 --> 00:04:40,000
cases where you built some application

00:04:37,570 --> 00:04:42,670
kind of expecting a data structure

00:04:40,000 --> 00:04:44,140
someone has come in and happen a type

00:04:42,670 --> 00:04:44,590
two that somewhere else inside your code

00:04:44,140 --> 00:04:47,020
base

00:04:44,590 --> 00:04:49,270
it's very common but now all of your

00:04:47,020 --> 00:04:51,250
code like a human has to kind of think

00:04:49,270 --> 00:04:53,650
about at which the functions might be

00:04:51,250 --> 00:04:55,450
affected by this time right where are we

00:04:53,650 --> 00:04:57,550
actually missing code in here what is it

00:04:55,450 --> 00:04:59,230
and you got this certainly makes the

00:04:57,550 --> 00:05:04,240
point to production more exciting in a

00:04:59,230 --> 00:05:05,860
way but not very much fun I think it's

00:05:04,240 --> 00:05:08,020
way to kind of find make sure that all

00:05:05,860 --> 00:05:10,810
the tags match so let's say that we have

00:05:08,020 --> 00:05:11,860
some animals and some sounds and we want

00:05:10,810 --> 00:05:14,230
to make a function that gives us the

00:05:11,860 --> 00:05:17,170
sound for an animal if we mapped over

00:05:14,230 --> 00:05:19,990
here the third time or in case we have a

00:05:17,170 --> 00:05:21,550
string and it'll actually based off of

00:05:19,990 --> 00:05:23,620
how you've written this it looks like

00:05:21,550 --> 00:05:25,360
you probably one that is sound not a

00:05:23,620 --> 00:05:26,860
string so again it's just like having

00:05:25,360 --> 00:05:28,390
that root product pair buddy there's

00:05:26,860 --> 00:05:32,200
just watching you help you every time

00:05:28,390 --> 00:05:34,540
you hit save I know one of the things

00:05:32,200 --> 00:05:36,990
I'm really worried about with code is

00:05:34,540 --> 00:05:38,730
they catch all there are cases

00:05:36,990 --> 00:05:42,120
you think you want to be able to rule

00:05:38,730 --> 00:05:44,160
some code and you're pretty sure that

00:05:42,120 --> 00:05:46,980
it's not used but you have another

00:05:44,160 --> 00:05:48,900
person sure and so what happens is by

00:05:46,980 --> 00:05:51,030
your code develops these growths all

00:05:48,900 --> 00:05:52,590
over the codebase because everyone is a

00:05:51,030 --> 00:05:53,970
little bit afraid to remove it just in

00:05:52,590 --> 00:05:56,070
case you get an artery

00:05:53,970 --> 00:05:57,510
but actually your mother everybody in

00:05:56,070 --> 00:05:59,520
this case we're handling true and false

00:05:57,510 --> 00:06:01,800
over a boolean and notice how you look

00:05:59,520 --> 00:06:03,390
it's cool you got it like you don't need

00:06:01,800 --> 00:06:05,400
that very case you can go ahead and

00:06:03,390 --> 00:06:06,870
remove it it's a very safe it actually

00:06:05,400 --> 00:06:09,690
watches to make sure that you can remove

00:06:06,870 --> 00:06:12,570
as much code as possible

00:06:09,690 --> 00:06:15,660
and all that but reason goes pretty far

00:06:12,570 --> 00:06:17,190
and how much it wants to help you so if

00:06:15,660 --> 00:06:19,470
you think about let's say that we were

00:06:17,190 --> 00:06:22,590
telling the true or false we move on to

00:06:19,470 --> 00:06:24,360
a boolean comparison or conditional in

00:06:22,590 --> 00:06:25,890
this case we're actually to match over

00:06:24,360 --> 00:06:28,440
the true and the false

00:06:25,890 --> 00:06:32,400
but we could write if this then that's

00:06:28,440 --> 00:06:34,500
this or we can write a ternary but

00:06:32,400 --> 00:06:37,320
reason is super it's like it's

00:06:34,500 --> 00:06:39,270
iron-fisted hipster conformism it

00:06:37,320 --> 00:06:41,730
requires as soon as you hit save it says

00:06:39,270 --> 00:06:43,680
another no I looked at ast this is how

00:06:41,730 --> 00:06:45,300
we write it and it will easily rewrite

00:06:43,680 --> 00:06:48,990
it for you in the browser or start in

00:06:45,300 --> 00:06:50,640
your editor there is you know discussion

00:06:48,990 --> 00:06:52,250
about how you write this part if I

00:06:50,640 --> 00:06:55,490
represent this particular part of the

00:06:52,250 --> 00:06:59,240
and I tell you sometimes I feel

00:06:55,490 --> 00:07:00,890
frustrated with say another tool or

00:06:59,240 --> 00:07:03,860
developer tools and that it will tell me

00:07:00,890 --> 00:07:05,150
what is wrong and it sounds like here's

00:07:03,860 --> 00:07:07,280
what you should be doing but it doesn't

00:07:05,150 --> 00:07:09,020
do it for you right and so reasonable

00:07:07,280 --> 00:07:12,230
part of its way to actually rewrite it

00:07:09,020 --> 00:07:15,110
for you after working with it

00:07:12,230 --> 00:07:17,510
they also have crazy good errors right

00:07:15,110 --> 00:07:19,130
now has kind of inspired the I think

00:07:17,510 --> 00:07:21,980
develop the world to try much much

00:07:19,130 --> 00:07:23,270
harder for the developer experience make

00:07:21,980 --> 00:07:26,600
sure that errors are really reasonable

00:07:23,270 --> 00:07:29,960
so this is an example of what they error

00:07:26,600 --> 00:07:31,790
looked like before where you pass the

00:07:29,960 --> 00:07:34,640
string and it was expected to be boolean

00:07:31,790 --> 00:07:36,470
the way reason does it is very similar

00:07:34,640 --> 00:07:38,360
to L what we actually want to show you

00:07:36,470 --> 00:07:39,920
your code make sure that you understand

00:07:38,360 --> 00:07:41,180
exactly where there is happening and

00:07:39,920 --> 00:07:43,669
give you a suggestion about how to fix

00:07:41,180 --> 00:07:45,800
it and it was a bit further to the point

00:07:43,669 --> 00:07:46,850
where even when there are warnings with

00:07:45,800 --> 00:07:48,919
their parts of the language that are

00:07:46,850 --> 00:07:50,590
kind of hard to understand it's going to

00:07:48,919 --> 00:07:53,030
make sure that it explains to you why

00:07:50,590 --> 00:07:54,470
the suggestion is here and actually a

00:07:53,030 --> 00:07:57,130
few alternatives about why you might

00:07:54,470 --> 00:07:59,990
write this so it's kind of like you have

00:07:57,130 --> 00:08:01,550
or what if you start with a new language

00:07:59,990 --> 00:08:03,710
oftentimes it feels like you with you

00:08:01,550 --> 00:08:06,590
the process is banging your head against

00:08:03,710 --> 00:08:08,270
the wall for about two or three days for

00:08:06,590 --> 00:08:09,979
something very very simple but you know

00:08:08,270 --> 00:08:11,180
if someone was very experienced sitting

00:08:09,979 --> 00:08:12,500
next to you they'd be like autumn

00:08:11,180 --> 00:08:13,639
just through this it would be five

00:08:12,500 --> 00:08:15,440
minutes and you being you you would know

00:08:13,639 --> 00:08:17,240
it's only be done and that's what like

00:08:15,440 --> 00:08:19,100
having a robotic everybody reason is

00:08:17,240 --> 00:08:24,740
like they actually helps you learn after

00:08:19,100 --> 00:08:26,570
go alone but you know as fun as that is

00:08:24,740 --> 00:08:27,949
like it's not a very useful language

00:08:26,570 --> 00:08:30,800
unless you can actually deploy keep it

00:08:27,949 --> 00:08:33,140
in fun people and okay one has some

00:08:30,800 --> 00:08:37,159
pretty crazy reach how do you guys have

00:08:33,140 --> 00:08:39,050
heard of you know kernels a few all

00:08:37,159 --> 00:08:41,060
right so you know kernels are kind of a

00:08:39,050 --> 00:08:43,540
new way of building applications whereas

00:08:41,060 --> 00:08:46,370
right now we will develop an application

00:08:43,540 --> 00:08:49,310
we're very very careful right we loved

00:08:46,370 --> 00:08:50,450
elite code make the surface area of our

00:08:49,310 --> 00:08:52,820
code as small as possible

00:08:50,450 --> 00:08:55,370
we kind of are seasonally craft is a

00:08:52,820 --> 00:08:57,170
beautiful application right and then

00:08:55,370 --> 00:08:59,570
what we do is we pull in 15 million

00:08:57,170 --> 00:09:01,820
lines of memory on safe and type on safe

00:08:59,570 --> 00:09:05,620
code called the Linux kernel and we just

00:09:01,820 --> 00:09:09,050
deployed what could go wrong right I

00:09:05,620 --> 00:09:10,320
know if I'm not using all 50 million

00:09:09,050 --> 00:09:12,810
lines of the code over the

00:09:10,320 --> 00:09:14,130
it doesn't really happen right but

00:09:12,810 --> 00:09:16,800
actually there are cases where for

00:09:14,130 --> 00:09:19,440
example have just happened a code is

00:09:16,800 --> 00:09:21,390
enough for a security for building a 50

00:09:19,440 --> 00:09:23,700
million lines of code is no human being

00:09:21,390 --> 00:09:26,370
can keep that in their head there was a

00:09:23,700 --> 00:09:30,210
case in is an hypervisor for example

00:09:26,370 --> 00:09:33,360
where with venom where because of a

00:09:30,210 --> 00:09:36,210
legacy floppy disk driver that the

00:09:33,360 --> 00:09:37,560
hypervisor was presenting there was

00:09:36,210 --> 00:09:38,630
actually an escalation that allow you go

00:09:37,560 --> 00:09:40,890
through and break through the hypervisor

00:09:38,630 --> 00:09:43,590
how many of you guys are using floppy

00:09:40,890 --> 00:09:45,480
disks in the cloud these days not so

00:09:43,590 --> 00:09:46,920
many right but just the fact that was

00:09:45,480 --> 00:09:49,200
there was enough work there are going to

00:09:46,920 --> 00:09:51,090
be a very serious escalation so if we

00:09:49,200 --> 00:09:53,970
don't have this code it's much much

00:09:51,090 --> 00:09:56,040
better so you know kernels I know camel

00:09:53,970 --> 00:09:57,960
kind of leave the way here that is what

00:09:56,040 --> 00:09:59,820
we're gonna do is that compile-time

00:09:57,960 --> 00:10:02,010
we're actually going to reach out and

00:09:59,820 --> 00:10:03,780
pull in just the libraries we need so we

00:10:02,010 --> 00:10:08,250
need like pure or camel implementations

00:10:03,780 --> 00:10:10,770
of TCP and IP of TLS SSH all these kinds

00:10:08,250 --> 00:10:12,990
of libraries and usually this is a way

00:10:10,770 --> 00:10:15,180
that would be a crazy idea to try to

00:10:12,990 --> 00:10:16,320
build out but luckily a team out of

00:10:15,180 --> 00:10:18,270
Cambridge has been working for seven

00:10:16,320 --> 00:10:20,670
years to build it out and saw print on

00:10:18,270 --> 00:10:22,680
so that means whenever you compile your

00:10:20,670 --> 00:10:24,600
application there is no operating system

00:10:22,680 --> 00:10:26,850
we're literally going to pull in all the

00:10:24,600 --> 00:10:29,100
code and we're gonna produce a VM which

00:10:26,850 --> 00:10:31,800
is just your application there's no

00:10:29,100 --> 00:10:34,960
other services running and it is tiny

00:10:31,800 --> 00:10:37,630
you get some very very cool

00:10:34,960 --> 00:10:39,430
from this so instead of millions of

00:10:37,630 --> 00:10:41,589
lines of memory not safe

00:10:39,430 --> 00:10:44,050
our memory is constant icon safe code

00:10:41,589 --> 00:10:46,990
when tens of thousands of lines of

00:10:44,050 --> 00:10:48,850
memory and types a pro and this actually

00:10:46,990 --> 00:10:50,560
has huge security implications because

00:10:48,850 --> 00:10:53,230
they the attack surface of our

00:10:50,560 --> 00:10:54,970
application is vastly reduced and not

00:10:53,230 --> 00:10:56,770
only that but we can actually hold the

00:10:54,970 --> 00:10:59,290
entire stack all the way from the

00:10:56,770 --> 00:11:01,330
hypervisor up to our application in our

00:10:59,290 --> 00:11:03,640
heads a single human being can hold

00:11:01,330 --> 00:11:05,770
about 10,000 lines and follow the the

00:11:03,640 --> 00:11:07,390
lines of execution through that whereas

00:11:05,770 --> 00:11:11,980
with the late colonel even have a much

00:11:07,390 --> 00:11:14,620
more challenging time build from there

00:11:11,980 --> 00:11:17,529
end up being very very small so how

00:11:14,620 --> 00:11:20,320
small can you get a Linux VM pretty

00:11:17,529 --> 00:11:22,060
small maybe tens of megabytes hundreds

00:11:20,320 --> 00:11:23,830
of megabytes and you can boot it's in

00:11:22,060 --> 00:11:24,520
couple of seconds it's pretty good we're

00:11:23,830 --> 00:11:26,649
pretty happy with that

00:11:24,520 --> 00:11:28,750
you're the kernels actually are in

00:11:26,649 --> 00:11:31,000
hundreds of kilobytes there's gonna be

00:11:28,750 --> 00:11:33,310
the entire p.m. and they boot within say

00:11:31,000 --> 00:11:35,410
50 milliseconds and this is crazy

00:11:33,310 --> 00:11:38,470
because it is so small literally every

00:11:35,410 --> 00:11:41,020
time you do a deploy you can push that

00:11:38,470 --> 00:11:42,790
kernel and she'll get repo you have an

00:11:41,020 --> 00:11:44,860
entire block everything that has ever

00:11:42,790 --> 00:11:46,660
been deployed when your server and if

00:11:44,860 --> 00:11:48,880
you ever ever gets an arrow for example

00:11:46,660 --> 00:11:50,890
you can check out that exact version of

00:11:48,880 --> 00:11:55,150
the server and repo it locally it's

00:11:50,890 --> 00:11:57,070
amazing because if it's up so quickly it

00:11:55,150 --> 00:11:59,320
enables totally new kinds of deployment

00:11:57,070 --> 00:12:01,930
scenarios and that's before example that

00:11:59,320 --> 00:12:02,860
we have no servers running we have just

00:12:01,930 --> 00:12:05,530
a load

00:12:02,860 --> 00:12:08,080
a request comes in for our server with

00:12:05,530 --> 00:12:09,760
you literally the reply window for TCP

00:12:08,080 --> 00:12:12,730
is such that we can literally make shout

00:12:09,760 --> 00:12:16,240
boot up an entire p.m. just for this one

00:12:12,730 --> 00:12:17,890
connection connected and then as soon as

00:12:16,240 --> 00:12:19,870
that this connection is done she'll let

00:12:17,890 --> 00:12:22,030
me enter so you can kind of imagine it

00:12:19,870 --> 00:12:23,770
like the hug of death from hacker news

00:12:22,030 --> 00:12:25,330
or reddit or something like that as

00:12:23,770 --> 00:12:27,660
people are coming in we're literally

00:12:25,330 --> 00:12:30,250
going to boot new VMs for them and

00:12:27,660 --> 00:12:32,520
return them in the period of time that

00:12:30,250 --> 00:12:35,680
takes for the TCP connection to complete

00:12:32,520 --> 00:12:37,630
so if you guys have used AWS lambda like

00:12:35,680 --> 00:12:39,490
you can get it pretty fast you have like

00:12:37,630 --> 00:12:41,860
maybe a forty milliseconds overhead for

00:12:39,490 --> 00:12:45,520
a function we can put our entire server

00:12:41,860 --> 00:12:48,160
written reason in 50 milliseconds and in

00:12:45,520 --> 00:12:50,020
fact it's currently closer to 20 or 50

00:12:48,160 --> 00:12:51,250
milliseconds but if you do it's right

00:12:50,020 --> 00:12:55,540
you can get down to five or ten

00:12:51,250 --> 00:12:58,690
milliseconds it's crazy you can also for

00:12:55,540 --> 00:13:00,670
a traditional say with those

00:12:58,690 --> 00:13:02,830
applications or des of our latex

00:13:00,670 --> 00:13:05,020
applications just kind of a standard

00:13:02,830 --> 00:13:07,510
thing there and it has an amazing

00:13:05,020 --> 00:13:08,830
JavaScript story so this is one of the

00:13:07,510 --> 00:13:12,640
few languages where you can actually

00:13:08,830 --> 00:13:15,070
program you can make TCP stacks that are

00:13:12,640 --> 00:13:16,240
performance and secure but it's also an

00:13:15,070 --> 00:13:20,550
expressive language it allows you to

00:13:16,240 --> 00:13:23,170
write amazing you eyes and in this case

00:13:20,550 --> 00:13:25,090
PostScript is the compiler and it

00:13:23,170 --> 00:13:26,920
focuses on two things very smooth

00:13:25,090 --> 00:13:28,800
integration with existing JavaScript

00:13:26,920 --> 00:13:31,709
libraries so things like real

00:13:28,800 --> 00:13:35,190
motion etc and very clean generated code

00:13:31,709 --> 00:13:38,610
and it's not talking about that so just

00:13:35,190 --> 00:13:41,970
give you a quick tests this is some

00:13:38,610 --> 00:13:46,290
JavaScript this is some JavaScript which

00:13:41,970 --> 00:13:49,440
of these two is written by a human in

00:13:46,290 --> 00:13:52,470
the ideas first one second one second

00:13:49,440 --> 00:13:54,920
all right well they're by a compiler but

00:13:52,470 --> 00:13:57,420
you guys have to think about it

00:13:54,920 --> 00:14:00,810
so this is actually the old camel that's

00:13:57,420 --> 00:14:02,730
writes it but the compiler is actually

00:14:00,810 --> 00:14:05,700
super for performance and it generates

00:14:02,730 --> 00:14:07,800
just it the exact JavaScript that you

00:14:05,700 --> 00:14:10,620
might write by hand I this looks like

00:14:07,800 --> 00:14:12,480
it's written by a human you know then

00:14:10,620 --> 00:14:15,600
like a little comment there but all like

00:14:12,480 --> 00:14:17,519
this is the nice thing about the reason

00:14:15,600 --> 00:14:19,290
and kind of Facebook technologies just

00:14:17,519 --> 00:14:21,570
like reacts Facebook knows that you have

00:14:19,290 --> 00:14:23,610
to have this clear upgrade path where

00:14:21,570 --> 00:14:25,260
you can start with a small piece and in

00:14:23,610 --> 00:14:28,230
that's the name kind of have it grow and

00:14:25,260 --> 00:14:29,790
just like with that with a reason you

00:14:28,230 --> 00:14:31,980
need to you can pop down to JavaScript

00:14:29,790 --> 00:14:34,260
and introduce into your team in a way

00:14:31,980 --> 00:14:36,450
that is not going to radically require

00:14:34,260 --> 00:14:38,070
you to throw everything out and for your

00:14:36,450 --> 00:14:39,510
entire team to learn reason they need to

00:14:38,070 --> 00:14:41,550
be able to read the JavaScript and still

00:14:39,510 --> 00:14:42,870
understand what's going on so we won't

00:14:41,550 --> 00:14:44,430
have all the benefits of the type

00:14:42,870 --> 00:14:45,750
checking in that robotic care buddy but

00:14:44,430 --> 00:14:48,860
we still want to be able to work with

00:14:45,750 --> 00:14:51,690
the existing kind of JavaScript world

00:14:48,860 --> 00:14:53,700
all right not only that's but we can go

00:14:51,690 --> 00:14:56,850
down to our 64 it have some great

00:14:53,700 --> 00:14:59,280
compiler council native iOS for example

00:14:56,850 --> 00:15:02,760
or Android where we can

00:14:59,280 --> 00:15:05,760
or in SFI and so we're actually able to

00:15:02,760 --> 00:15:07,770
use the native iOS and Android libraries

00:15:05,760 --> 00:15:09,750
and we don't actually have a JIT that

00:15:07,770 --> 00:15:12,930
we're running so we have a very very

00:15:09,750 --> 00:15:14,880
predictable performance on platforms

00:15:12,930 --> 00:15:19,170
where we really care about every little

00:15:14,880 --> 00:15:20,490
bit or every single CPU cycle and this

00:15:19,170 --> 00:15:23,040
is for example of me taking that the

00:15:20,490 --> 00:15:24,480
same exact code that around earlier I

00:15:23,040 --> 00:15:26,280
put it up a docker image that had the

00:15:24,480 --> 00:15:28,500
compiler on coltrane that's all I

00:15:26,280 --> 00:15:30,750
compiled it out to forearm 64 and then

00:15:28,500 --> 00:15:34,140
running it on the Raspberry Pi so we can

00:15:30,750 --> 00:15:36,870
actually run Oh camel on the browser on

00:15:34,140 --> 00:15:42,000
desktop we can build you the kernels we

00:15:36,870 --> 00:15:44,190
can go to native mobile and time to sort

00:15:42,000 --> 00:15:45,420
of embedded devices in a Raspberry Pi as

00:15:44,190 --> 00:15:48,270
they get faster and faster every year

00:15:45,420 --> 00:15:49,560
but it's still any platform we really

00:15:48,270 --> 00:15:53,370
care about having a very particular

00:15:49,560 --> 00:15:54,950
performance envelope and kind of eating

00:15:53,370 --> 00:15:58,530
out every bit of the phones that we can

00:15:54,950 --> 00:16:03,120
so we have both great reach with reason

00:15:58,530 --> 00:16:04,470
and great semantics so it's like I said

00:16:03,120 --> 00:16:05,940
it's one these few languages that it's

00:16:04,470 --> 00:16:08,339
actually very well-suited for both

00:16:05,940 --> 00:16:10,500
systems language versus systems level

00:16:08,339 --> 00:16:12,990
programming but also for application

00:16:10,500 --> 00:16:15,210
development Oh Campbell itself which

00:16:12,990 --> 00:16:16,050
reason it's based long has a sometime

00:16:15,210 --> 00:16:18,890
worryingly

00:16:16,050 --> 00:16:21,839
or the querying obsession with

00:16:18,890 --> 00:16:23,300
performance they do crazy things to make

00:16:21,839 --> 00:16:26,130
it as fast as possible

00:16:23,300 --> 00:16:28,950
but unfortunately I'm on say in the

00:16:26,130 --> 00:16:31,820
browser and mobile platforms it has a

00:16:28,950 --> 00:16:33,710
very very predictable

00:16:31,820 --> 00:16:35,510
so we can always reason about our code

00:16:33,710 --> 00:16:38,300
if we see it being fast once we know

00:16:35,510 --> 00:16:42,080
it's going to be fast in the future so

00:16:38,300 --> 00:16:44,540
overall reason has great semantics

00:16:42,080 --> 00:16:46,520
it has crazy reach and this is not a

00:16:44,540 --> 00:16:48,410
like what was common denominator reach

00:16:46,520 --> 00:16:50,060
this is we can optimize for every

00:16:48,410 --> 00:16:52,430
platform individually with that same

00:16:50,060 --> 00:16:54,740
language we can share that code across

00:16:52,430 --> 00:16:56,150
all the different platforms if we change

00:16:54,740 --> 00:16:57,860
something and there's an error say for

00:16:56,150 --> 00:16:59,270
example in the back end and we're

00:16:57,860 --> 00:17:00,830
sharing code with the front end as soon

00:16:59,270 --> 00:17:02,600
as we had saved we're gonna know we

00:17:00,830 --> 00:17:03,860
broke the front end right we don't have

00:17:02,600 --> 00:17:05,870
to wait for tests not right for

00:17:03,860 --> 00:17:10,460
integrations we did say we know

00:17:05,870 --> 00:17:12,140
everything so kind of my pitch to say if

00:17:10,460 --> 00:17:14,060
you're coming from it or to this from a

00:17:12,140 --> 00:17:16,070
JavaScript point of view I would say to

00:17:14,060 --> 00:17:19,100
imagine that the flow and Babel scripts

00:17:16,070 --> 00:17:21,470
were there from the beginning any

00:17:19,100 --> 00:17:21,890
language that was very very carefully

00:17:21,470 --> 00:17:23,900
thought out

00:17:21,890 --> 00:17:25,760
that's an amazing engineers working on

00:17:23,900 --> 00:17:28,100
the from the beginning that had great

00:17:25,760 --> 00:17:32,030
tooling and could go basically anywhere

00:17:28,100 --> 00:17:35,240
that's reason so there is this question

00:17:32,030 --> 00:17:38,000
Oh cam was actually more than 20 years

00:17:35,240 --> 00:17:39,140
old like if it is so good where it

00:17:38,000 --> 00:17:41,440
hasn't been and it can't be decremented

00:17:39,140 --> 00:17:44,570
right and actually I would argue that

00:17:41,440 --> 00:17:46,250
there's this kind of chasm and the

00:17:44,570 --> 00:17:48,320
innovators here that's the saintly

00:17:46,250 --> 00:17:51,470
academics they've been working on ocal

00:17:48,320 --> 00:17:54,200
doing crazy cool things that's make the

00:17:51,470 --> 00:17:55,970
language very interesting and it's just

00:17:54,200 --> 00:17:57,710
early adopter stage where you have

00:17:55,970 --> 00:18:00,860
financial services continuing Jane

00:17:57,710 --> 00:18:04,070
Street facing all of their applications

00:18:00,860 --> 00:18:05,990
on it and they're actually trading with

00:18:04,070 --> 00:18:07,550
their actual money and so they like they

00:18:05,990 --> 00:18:09,710
care about the practice and performance

00:18:07,550 --> 00:18:12,260
in quite a bit so they're willing to pay

00:18:09,710 --> 00:18:13,820
a lot of the costs that come for the

00:18:12,260 --> 00:18:16,010
doctors and one mission that actually

00:18:13,820 --> 00:18:18,290
works but they're gonna kind of deal

00:18:16,010 --> 00:18:19,970
with any issues that come up the problem

00:18:18,290 --> 00:18:21,500
is there is this chasm there early

00:18:19,970 --> 00:18:22,790
maturity the practice they just want to

00:18:21,500 --> 00:18:25,430
get stuff done right most of us don't

00:18:22,790 --> 00:18:26,810
actually care about him it's cool to

00:18:25,430 --> 00:18:27,650
play with the language or not going to

00:18:26,810 --> 00:18:30,530
use it in production

00:18:27,650 --> 00:18:31,910
unless it actually works and so okay

00:18:30,530 --> 00:18:33,920
well that's basically this cathode is

00:18:31,910 --> 00:18:36,650
where cool tech goes to die it's very

00:18:33,920 --> 00:18:39,080
sad there's a lot of old secretary but

00:18:36,650 --> 00:18:40,790
kind of with the amount of resources and

00:18:39,080 --> 00:18:42,860
energy that Facebook has been investing

00:18:40,790 --> 00:18:44,390
in and recently we can kind of see it

00:18:42,860 --> 00:18:45,620
start to genre from the early adopter

00:18:44,390 --> 00:18:48,230
stage over to where it's actually

00:18:45,620 --> 00:18:49,970
pragmatic we can use reason today to

00:18:48,230 --> 00:18:53,750
actually build very very interesting

00:18:49,970 --> 00:18:56,720
applications so there are some very very

00:18:53,750 --> 00:18:58,760
cool projects and some Jared here

00:18:56,720 --> 00:19:01,430
actually is the author of some of them

00:18:58,760 --> 00:19:03,260
what'm is regions so you can kind of

00:19:01,430 --> 00:19:07,300
imagine also that whenever you're trying

00:19:03,260 --> 00:19:07,300
to integrate with JavaScript

00:19:07,780 --> 00:19:12,200
compiles everyone it gets into reasons

00:19:10,400 --> 00:19:14,330
you can get all those benefits of

00:19:12,200 --> 00:19:17,840
reasons by the robotic pair buddy the

00:19:14,330 --> 00:19:19,670
performance the reach etc there's a very

00:19:17,840 --> 00:19:21,200
kind of mechanical translation process

00:19:19,670 --> 00:19:23,090
that happens and it's not particularly

00:19:21,200 --> 00:19:24,680
fun where it's kind of like a monkey see

00:19:23,090 --> 00:19:26,600
a line of JavaScript code and monkey lot

00:19:24,680 --> 00:19:28,370
write a line of recent code

00:19:26,600 --> 00:19:31,010
so what Reach is does is actually the

00:19:28,370 --> 00:19:33,230
parse your JavaScript for you and we'll

00:19:31,010 --> 00:19:34,490
put reason joke it's not gonna run

00:19:33,230 --> 00:19:35,870
that's gonna take care of all of

00:19:34,490 --> 00:19:37,160
mechanical stuff so now you can go

00:19:35,870 --> 00:19:39,410
through and actually very very quickly

00:19:37,160 --> 00:19:42,560
translate your code over and then

00:19:39,410 --> 00:19:45,590
annotations so that you can get his work

00:19:42,560 --> 00:19:47,300
on reason and relay off is actually an

00:19:45,590 --> 00:19:49,430
example I think of a application for a

00:19:47,300 --> 00:19:51,410
project that uses it or use this

00:19:49,430 --> 00:19:53,830
initially which if you're familiar with

00:19:51,410 --> 00:19:56,330
the JavaScript implementation of flexbox

00:19:53,830 --> 00:19:59,240
Jordan actually implemented real layout

00:19:56,330 --> 00:20:01,610
which is a recent port where we took

00:19:59,240 --> 00:20:04,730
that JavaScript implementation wrote it

00:20:01,610 --> 00:20:07,010
in reason and now this runs in WebGL

00:20:04,730 --> 00:20:09,900
it runs on a while it runs in the

00:20:07,010 --> 00:20:11,040
browser and you can even learn it on

00:20:09,900 --> 00:20:13,050
not sure what you would pay out there

00:20:11,040 --> 00:20:16,320
but it's pretty cool there is a danger

00:20:13,050 --> 00:20:18,960
reason and is that every project seems

00:20:16,320 --> 00:20:20,900
to have to start with read to the funder

00:20:18,960 --> 00:20:25,020
we even have a really reactive now

00:20:20,900 --> 00:20:26,400
hopefully that changes so actually I

00:20:25,020 --> 00:20:28,170
would encourage you guys to ask some

00:20:26,400 --> 00:20:31,260
questions about the trade-offs between

00:20:28,170 --> 00:20:34,230
JavaScript loader script and L enclosure

00:20:31,260 --> 00:20:37,260
day today we did we built some products

00:20:34,230 --> 00:20:38,970
at L and compared with say for example

00:20:37,260 --> 00:20:43,980
JavaScript and flow and how they're

00:20:38,970 --> 00:20:45,660
different so actually there's a bunch of

00:20:43,980 --> 00:20:47,580
other stuff like ok well he's a crazy

00:20:45,660 --> 00:20:51,420
language like I said there's so much in

00:20:47,580 --> 00:20:53,430
here so reason actually allows you to

00:20:51,420 --> 00:20:56,160
separate your syntax and your semantics

00:20:53,430 --> 00:20:58,830
so they have they're able to say we all

00:20:56,160 --> 00:21:00,180
serialize to the same as T but that

00:20:58,830 --> 00:21:02,070
means that we can write a function that

00:21:00,180 --> 00:21:04,260
will take that ast and print it into

00:21:02,070 --> 00:21:05,910
different syntaxes in our editor so if

00:21:04,260 --> 00:21:08,430
for example you're like me and you like

00:21:05,910 --> 00:21:10,740
closure syntax you can read your recent

00:21:08,430 --> 00:21:13,080
code in closures in terms you're gonna

00:21:10,740 --> 00:21:14,640
save it out to this ast and whoever else

00:21:13,080 --> 00:21:16,680
opens it I was gonna see it in their

00:21:14,640 --> 00:21:20,160
printer but now we can actually start to

00:21:16,680 --> 00:21:22,690
move the language into our own vision

00:21:20,160 --> 00:21:24,519
and the problem with fast

00:21:22,690 --> 00:21:26,440
this is a bit like food like everyone

00:21:24,519 --> 00:21:28,529
feels entitled to an opinion

00:21:26,440 --> 00:21:31,869
all rights very very but it's the

00:21:28,529 --> 00:21:33,489
epitome of bike shelling topics and so

00:21:31,869 --> 00:21:34,869
this nice thing is now instead of bike

00:21:33,489 --> 00:21:36,279
shedding you can say if you want the

00:21:34,869 --> 00:21:37,960
difference in tax just right your

00:21:36,279 --> 00:21:39,279
printer for it and you'll have it you

00:21:37,960 --> 00:21:42,580
can see it however you like

00:21:39,279 --> 00:21:45,700
so kind of like a but if thousands index

00:21:42,580 --> 00:21:48,009
moonface so right now our reason

00:21:45,700 --> 00:21:49,720
actually has a built-in JSX support is

00:21:48,009 --> 00:21:51,849
just native the right thing on

00:21:49,720 --> 00:21:55,749
graphically well syntax there are super

00:21:51,849 --> 00:21:58,739
pulls off of it they're down to the

00:21:55,749 --> 00:22:00,669
bottom there but okay well has a new PR

00:21:58,739 --> 00:22:02,559
right now I gave up

00:22:00,669 --> 00:22:04,479
yeah super aggressive dead code

00:22:02,559 --> 00:22:06,789
elimination and this works across all

00:22:04,479 --> 00:22:09,849
the different targets but actually with

00:22:06,789 --> 00:22:12,159
this dead code elimination it works with

00:22:09,849 --> 00:22:13,570
our unit kernels where they were 100

00:22:12,159 --> 00:22:15,849
kilobytes before we can actually get the

00:22:13,570 --> 00:22:17,769
num2 kilobytes so you can imagine your

00:22:15,849 --> 00:22:20,950
entire server infrastructure is

00:22:17,769 --> 00:22:23,440
kilobytes boots in milliseconds and you

00:22:20,950 --> 00:22:26,919
can put up as many as you want as soon

00:22:23,440 --> 00:22:29,139
as a connector comes in so I think a

00:22:26,919 --> 00:22:34,210
couple of people for stock I think I'm

00:22:29,139 --> 00:22:38,259
getting close to the end or whatever

00:22:34,210 --> 00:22:39,909
anyway I might add new slides but we're

00:22:38,259 --> 00:22:41,830
actually on to enough real quick right

00:22:39,909 --> 00:22:43,179
before the talk is that

00:22:41,830 --> 00:22:45,399
for those of you who are familiar with

00:22:43,179 --> 00:22:47,049
closure cover which is a distributed

00:22:45,399 --> 00:22:48,879
kind of online programming binge

00:22:47,049 --> 00:22:50,889
foreclosure we're doing the equivalent

00:22:48,879 --> 00:22:52,539
for recently so if you've got a recent

00:22:50,889 --> 00:22:54,129
capital column and you want to kind of

00:22:52,539 --> 00:22:57,759
get into reason you want to try it out

00:22:54,129 --> 00:22:59,409
go there sign up and we'll actually come

00:22:57,759 --> 00:23:01,539
to the discord we want to get set up

00:22:59,409 --> 00:23:03,879
it's a super dense community definitely

00:23:01,539 --> 00:23:07,330
recommend kind of joining and hacking on

00:23:03,879 --> 00:23:13,029
reason it'll be a lot of fun happy to

00:23:07,330 --> 00:23:15,879
take the questions and I'm just getting

00:23:13,029 --> 00:23:19,210
down to be with you for the question

00:23:15,879 --> 00:23:22,179
senator okay so the top one here is the

00:23:19,210 --> 00:23:23,379
recent reason about reason so this is

00:23:22,179 --> 00:23:25,239
actually the other big danger with

00:23:23,379 --> 00:23:27,639
reason is there are so many bad puns

00:23:25,239 --> 00:23:30,369
this terrible everyone loves to make

00:23:27,639 --> 00:23:37,929
that jokes about reason but hopefully we

00:23:30,369 --> 00:23:40,809
get some way before that kind of thing

00:23:37,929 --> 00:23:43,269
the big thing with Ocampo keval relies

00:23:40,809 --> 00:23:44,950
on having a garbage garbage collector

00:23:43,269 --> 00:23:46,570
and that's about yes you need to have

00:23:44,950 --> 00:23:49,269
like you can't really interact with the

00:23:46,570 --> 00:23:51,340
host GC as of yet now they're talking

00:23:49,269 --> 00:23:53,679
about opening that up in the future but

00:23:51,340 --> 00:23:57,460
right now not really but the thing is

00:23:53,679 --> 00:23:59,919
that the semantics of reason poor really

00:23:57,460 --> 00:24:01,920
really well to the existing JavaScript

00:23:59,919 --> 00:24:04,920
engines so you can make sure that

00:24:01,920 --> 00:24:06,420
can you don't really need that's enough

00:24:04,920 --> 00:24:08,310
just as it is right now because it is

00:24:06,420 --> 00:24:14,280
super amenable to the optimizations that

00:24:08,310 --> 00:24:18,090
are applied in the JavaScript world does

00:24:14,280 --> 00:24:20,420
a unicorn make doctor obsolete they're

00:24:18,090 --> 00:24:23,070
very very different approaches right so

00:24:20,420 --> 00:24:25,080
docker containers are this very nice

00:24:23,070 --> 00:24:27,720
kind of incremental change right where

00:24:25,080 --> 00:24:29,250
they we can't just throw out our JVM you

00:24:27,720 --> 00:24:31,980
can't just throw it over existing

00:24:29,250 --> 00:24:33,510
infrastructure so darker allows you to

00:24:31,980 --> 00:24:36,630
container eyes and make these nice

00:24:33,510 --> 00:24:40,140
improvements camel can and reason can

00:24:36,630 --> 00:24:42,480
compile down to a native UNIX binary and

00:24:40,140 --> 00:24:43,980
run on there and you can run that inside

00:24:42,480 --> 00:24:46,140
of a docker container you get those nice

00:24:43,980 --> 00:24:47,910
benefits and then once you're you're

00:24:46,140 --> 00:24:50,070
comfortable mature ready you can then

00:24:47,910 --> 00:24:51,680
switch that over to running any unit so

00:24:50,070 --> 00:24:53,850
there's always this nice upgrade path

00:24:51,680 --> 00:24:56,760
everything about the reason is about

00:24:53,850 --> 00:25:00,870
they having a smooth clear easy upgrade

00:24:56,760 --> 00:25:03,480
path OS reason compared to L the job so

00:25:00,870 --> 00:25:05,550
has never actually there are a couple of

00:25:03,480 --> 00:25:08,220
different and important changes are

00:25:05,550 --> 00:25:10,020
differences one is reason has fantastic

00:25:08,220 --> 00:25:14,370
reach reason can go to all these

00:25:10,020 --> 00:25:16,350
different platforms and it has this

00:25:14,370 --> 00:25:17,970
braids kind of crazy academic team that

00:25:16,350 --> 00:25:20,070
has been investing in it for twenty

00:25:17,970 --> 00:25:22,680
years but one of the things that you're

00:25:20,070 --> 00:25:25,050
going to see is that L has is guaranteed

00:25:22,680 --> 00:25:27,600
that it will you will not have one time

00:25:25,050 --> 00:25:29,940
exceptions it is safer than reason in

00:25:27,600 --> 00:25:31,940
that regard at least right now there is

00:25:29,940 --> 00:25:34,140
a new feature kind of coming out

00:25:31,940 --> 00:25:37,020
hopefully within say the next year or so

00:25:34,140 --> 00:25:38,520
for for reason called effect hangers and

00:25:37,020 --> 00:25:40,080
the fact handlers totally changed it

00:25:38,520 --> 00:25:43,890
again kind of tooling you're gonna see

00:25:40,080 --> 00:25:46,050
that isn't possible and reason is never

00:25:43,890 --> 00:25:48,390
before ball so it's gonna be crazy

00:25:46,050 --> 00:25:51,030
but for the time being it offers some

00:25:48,390 --> 00:25:52,920
great safety and other than that they're

00:25:51,030 --> 00:25:55,950
very very similar so that one format

00:25:52,920 --> 00:26:00,420
imagine if novel format was required by

00:25:55,950 --> 00:26:02,010
everyone that's kind of how reason is so

00:26:00,420 --> 00:26:04,559
it looks amazing as a front-end engineer

00:26:02,010 --> 00:26:06,450
where would I use it probably on the

00:26:04,559 --> 00:26:08,429
front end how does it compare to a

00:26:06,450 --> 00:26:09,990
compliment with buckles rivet so buckle

00:26:08,429 --> 00:26:13,140
script is actually the compiler that

00:26:09,990 --> 00:26:15,870
will take reason and compile JavaScript

00:26:13,140 --> 00:26:18,780
and so there are findings it is super

00:26:15,870 --> 00:26:20,190
easy to write bindings for using Puckle

00:26:18,780 --> 00:26:23,640
script and reason for existing

00:26:20,190 --> 00:26:26,640
JavaScript so the recent couple column

00:26:23,640 --> 00:26:29,700
is actually built in reason using react

00:26:26,640 --> 00:26:34,590
and react emotion but it really was a

00:26:29,700 --> 00:26:37,980
pleasure to build others reason compared

00:26:34,590 --> 00:26:39,809
to elixir Erlang a very very difference

00:26:37,980 --> 00:26:43,770
in the sense you know early the

00:26:39,809 --> 00:26:47,700
fundamental process long is just very

00:26:43,770 --> 00:26:50,460
unique to the beam VM for the Turin

00:26:47,700 --> 00:26:52,260
rolling and they have very very kind of

00:26:50,460 --> 00:26:54,059
different domains unless if you are not

00:26:52,260 --> 00:26:56,040
going to get very very fast performance

00:26:54,059 --> 00:26:58,020
down the number of Russian reason is

00:26:56,040 --> 00:26:59,620
actually very very good their reason

00:26:58,020 --> 00:27:01,330
however is not going to have

00:26:59,620 --> 00:27:03,520
kind of beautiful supervisor treat

00:27:01,330 --> 00:27:07,030
approach where to just easily restore

00:27:03,520 --> 00:27:08,920
sure from your services it means never

00:27:07,030 --> 00:27:11,020
piss you off or knock leg actually love

00:27:08,920 --> 00:27:14,140
it I don't know if I can get them this

00:27:11,020 --> 00:27:16,870
is regardless can give an example okay I

00:27:14,140 --> 00:27:20,110
tracked my screen actually want to show

00:27:16,870 --> 00:27:24,010
a quick example what since someone asked

00:27:20,110 --> 00:27:26,260
if it's upsetting so basically the

00:27:24,010 --> 00:27:27,880
question is whenever a recent fix is

00:27:26,260 --> 00:27:31,360
your coat for you does that upset you

00:27:27,880 --> 00:27:32,590
and in the beginning right yeah you kind

00:27:31,360 --> 00:27:35,200
of like a hipster in like you want

00:27:32,590 --> 00:27:36,880
easily basic I want that character there

00:27:35,200 --> 00:27:39,400
and I want that character there but you

00:27:36,880 --> 00:27:42,100
get used to it very very quickly so the

00:27:39,400 --> 00:27:48,280
here's the example because a little bit

00:27:42,100 --> 00:27:50,290
bigger so this is an example of I'll say

00:27:48,280 --> 00:27:52,630
we have a cat here we're gonna peek

00:27:50,290 --> 00:27:55,960
inside of the box if the cat survives

00:27:52,630 --> 00:27:58,420
then we're going to just return it and

00:27:55,960 --> 00:28:01,390
if it doesn't survive then we are going

00:27:58,420 --> 00:28:03,790
to decrement one of its lives and as

00:28:01,390 --> 00:28:07,540
soon as we hit save it's gonna tell us

00:28:03,790 --> 00:28:11,710
hey this variable is unused so I'm going

00:28:07,540 --> 00:28:13,929
to remove that and then says by the way

00:28:11,710 --> 00:28:16,000
I noticed I checked your code the type

00:28:13,929 --> 00:28:18,400
Shorty's are kept only has a field

00:28:16,000 --> 00:28:20,350
called lives and you're using the

00:28:18,400 --> 00:28:22,690
JavaScript spread here and then you're

00:28:20,350 --> 00:28:23,980
also adding in lives you don't need to

00:28:22,690 --> 00:28:26,230
do that you've already exhaustively

00:28:23,980 --> 00:28:27,280
numerated all of the fields so you can

00:28:26,230 --> 00:28:29,050
kind of imagine

00:28:27,280 --> 00:28:31,450
we did some refactoring and we change

00:28:29,050 --> 00:28:34,180
the tightness we remove some fields and

00:28:31,450 --> 00:28:35,170
now robot but it's gonna tell us hey you

00:28:34,180 --> 00:28:41,260
don't need this anymore

00:28:35,170 --> 00:28:42,910
you can literally just write that and

00:28:41,260 --> 00:28:44,290
now it's happening so it's like this

00:28:42,910 --> 00:28:47,050
prepare money that kind of helps us go

00:28:44,290 --> 00:28:50,020
along and learn the language and this is

00:28:47,050 --> 00:28:55,630
really important for example let's say I

00:28:50,020 --> 00:29:01,150
wanted to do always dangers to a live

00:28:55,630 --> 00:29:03,610
demo to see how it goes alright so I'm

00:29:01,150 --> 00:29:08,620
gonna switch over William and I'm gonna

00:29:03,610 --> 00:29:14,380
say that if it's true I'm gonna do 0 and

00:29:08,620 --> 00:29:15,280
if it's false I'll do one and as soon as

00:29:14,380 --> 00:29:17,020
I get saved

00:29:15,280 --> 00:29:20,110
it's gonna tell me there the problem

00:29:17,020 --> 00:29:24,060
here it says that hey by the way at this

00:29:20,110 --> 00:29:24,060
point was expecting a closing bracket

00:29:30,690 --> 00:29:34,190
once again let's see

00:29:35,820 --> 00:29:38,660
everyone

00:29:42,299 --> 00:29:45,929
all right as soon as I hit save fingers

00:29:44,219 --> 00:29:47,969
crossed it actually automatically

00:29:45,929 --> 00:29:49,289
rewrites it's like this so it's amazing

00:29:47,969 --> 00:29:51,239
that you don't actually have to worry

00:29:49,289 --> 00:29:53,129
about how your course format it's like

00:29:51,239 --> 00:29:55,529
someone's saying instead of encoding

00:29:53,129 --> 00:29:56,849
your style guide in a text file and

00:29:55,529 --> 00:29:58,919
telling people hey follow this style

00:29:56,849 --> 00:30:00,359
guide it's all Roenick lis built into

00:29:58,919 --> 00:30:02,399
your editor you never have to worry

00:30:00,359 --> 00:30:03,899
about it so no it doesn't upset me is

00:30:02,399 --> 00:30:05,279
amazing I don't have to worry about this

00:30:03,899 --> 00:30:07,169
stuff anymore I think about the program

00:30:05,279 --> 00:30:08,159
and the editor and the tooling takes

00:30:07,169 --> 00:30:11,279
care of everything else

00:30:08,159 --> 00:30:13,529
by I don't want to go back to a world

00:30:11,279 --> 00:30:16,019
where I have to carry her about how the

00:30:13,529 --> 00:30:17,969
mood is formatted so I think that this

00:30:16,019 --> 00:30:20,099
time is about thank you very much check

00:30:17,969 --> 00:30:21,660
out recent opcom we love to talk with

00:30:20,099 --> 00:30:25,049
you guys

00:30:21,660 --> 00:30:25,049

YouTube URL: https://www.youtube.com/watch?v=8LCmLQ1-YqQ


