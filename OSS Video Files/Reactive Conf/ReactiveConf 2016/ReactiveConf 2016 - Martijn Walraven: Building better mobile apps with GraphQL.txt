Title: ReactiveConf 2016 - Martijn Walraven: Building better mobile apps with GraphQL
Publication date: 2016-11-24
Playlist: ReactiveConf 2016
Description: 
	https://reactiveconf.com 

Meet those driving the change! World-renowned mobile and web innovators got together for three days in one town.

ReactiveConf, October 26 - 28 2016, Bratislava, Slovakia

---
Martijn Walraven: Building better mobile apps with GraphQL

If you’ve used the Facebook iOS or Android app in the last four years, you’ve used a mobile app powered by GraphQL. In fact, development of GraphQL started in 2012 as part of Facebook’s effort to move from web-based to truly native mobile apps, and it is now a core part of the Facebook infrastructure. It is no surprise GraphQL was first conceived to serve the needs of mobile developers, and so comes with many benefits. We'll talk about all of them, and also why you should get a grasp of GraphQL in the near future if you haven't done so, whether you develop mobile apps using web technologies, React Native, native iOS or Android.

---

Have you heard about ReactiveConf? According to tech superstars such as David Nolen, Richard Feldman, or Brent Vatne, it’s the best conference on web and mobile app development! It focuses on all things React and beyond and takes place annually in Bratislava, Slovakia.

In 2016, more than 700 attendees from all over the world spent three days in Bratislava getting inspired, sharing amazing new ideas, and meeting more than 30 awesome speakers from companies such as Google, Cognitect, NoRedInk, RethinkDB, Airbnb, Microsoft, Facebook, and the list could go on forever.

If you want to be part of the next event, get your tickets now at https://reactiveconf.com, and React with us!
Captions: 
	00:00:05,250 --> 00:00:10,830
great to be here again this is the

00:00:07,140 --> 00:00:16,320
second year for me with the conference's

00:00:10,830 --> 00:00:19,560
well I think unfortunately I had to miss

00:00:16,320 --> 00:00:25,260
the first day of this conference but I

00:00:19,560 --> 00:00:27,480
have an excuse because two days ago we

00:00:25,260 --> 00:00:30,560
organized the first ever crafty old

00:00:27,480 --> 00:00:35,129
conference and it was pretty amazing

00:00:30,560 --> 00:00:39,719
completely sold out over like 350 people

00:00:35,129 --> 00:00:43,440
attending a lot of people attending from

00:00:39,719 --> 00:00:47,760
big tech companies and other well-known

00:00:43,440 --> 00:00:55,379
company and I think this is particularly

00:00:47,760 --> 00:00:59,070
exciting because it's 2016 and early

00:00:55,379 --> 00:01:01,949
2015 was when people first started

00:00:59,070 --> 00:01:03,660
talking publicly about grabbed well this

00:01:01,949 --> 00:01:06,869
was the first-ever public talk about

00:01:03,660 --> 00:01:11,430
craft well a tree a chaos conference in

00:01:06,869 --> 00:01:15,360
2015 and it's amazing how much has

00:01:11,430 --> 00:01:18,049
happened since this was mostly in

00:01:15,360 --> 00:01:23,280
technology used internally at Facebook

00:01:18,049 --> 00:01:28,049
and this talk introduced both craft well

00:01:23,280 --> 00:01:32,549
and relay a javascript rafael client

00:01:28,049 --> 00:01:34,200
that facebook had developed and what's

00:01:32,549 --> 00:01:40,369
interesting about this is not just that

00:01:34,200 --> 00:01:42,659
um it was using it was in 2015 but also

00:01:40,369 --> 00:01:45,540
that Rafael was introduced in the

00:01:42,659 --> 00:01:48,770
context of JavaScript it was introduced

00:01:45,540 --> 00:01:52,380
as data fetching for react application

00:01:48,770 --> 00:01:55,110
right now it's a much broader technology

00:01:52,380 --> 00:01:57,899
there are language implementations both

00:01:55,110 --> 00:02:01,890
on the server and on the client dozens

00:01:57,899 --> 00:02:04,680
of them and it's not surprising because

00:02:01,890 --> 00:02:09,269
craft well was not designed exclusively

00:02:04,680 --> 00:02:12,780
for javascript in fact Raquel was first

00:02:09,269 --> 00:02:16,080
developed in 2012 at Facebook and it was

00:02:12,780 --> 00:02:18,690
developed for the first native version

00:02:16,080 --> 00:02:22,050
of the main facebook I

00:02:18,690 --> 00:02:24,870
s ab some of you may remember the

00:02:22,050 --> 00:02:29,010
previous version of this app which was

00:02:24,870 --> 00:02:32,000
html5 base and generally people thought

00:02:29,010 --> 00:02:36,720
it didn't work well with a bit of a mess

00:02:32,000 --> 00:02:39,570
and during a project where they

00:02:36,720 --> 00:02:41,710
redevelop this app they also designed

00:02:39,570 --> 00:02:43,770
rescue L

00:02:41,710 --> 00:02:43,770
um

00:02:43,950 --> 00:02:51,750
I'll so a little more about Rafael on

00:02:46,800 --> 00:02:54,780
different platforms later on but first

00:02:51,750 --> 00:02:58,379
let's look at sort of the the underlying

00:02:54,780 --> 00:03:01,560
question why the Facebook developed

00:02:58,379 --> 00:03:06,480
breast well and why are people so

00:03:01,560 --> 00:03:08,010
excited about grass drought and one way

00:03:06,480 --> 00:03:10,890
is looking at this is to look at some of

00:03:08,010 --> 00:03:14,670
the pain points people experience with

00:03:10,890 --> 00:03:20,280
alternative technology mostly various

00:03:14,670 --> 00:03:22,680
sorts of restful api so I think these

00:03:20,280 --> 00:03:25,440
are pain points that most of us here in

00:03:22,680 --> 00:03:27,900
the audience will recognize let's say

00:03:25,440 --> 00:03:32,370
I'm building an app and I'd like to

00:03:27,900 --> 00:03:36,360
display a list of github repository so i

00:03:32,370 --> 00:03:40,560
use the github API I perform a get

00:03:36,360 --> 00:03:45,180
request and what do I get back a big

00:03:40,560 --> 00:03:49,019
JSON blob in fact this is just getting

00:03:45,180 --> 00:03:53,270
the github repositories under the Apollo

00:03:49,019 --> 00:03:56,570
stack organization but

00:03:53,270 --> 00:03:59,630
this is so it's actually so much data

00:03:56,570 --> 00:04:02,540
that this movie that i made i last a

00:03:59,630 --> 00:04:04,490
full minute but just to get the

00:04:02,540 --> 00:04:09,800
repositories under the Apollo stack name

00:04:04,490 --> 00:04:14,410
I get a full minute bus scrolling Jason

00:04:09,800 --> 00:04:17,510
text and that's not all because when I

00:04:14,410 --> 00:04:20,090
finally have that information it may not

00:04:17,510 --> 00:04:22,580
actually contain the information that I

00:04:20,090 --> 00:04:25,610
need to show you my app so for instance

00:04:22,580 --> 00:04:29,450
if I want to show the names of

00:04:25,610 --> 00:04:33,560
contributors I have to make I've have to

00:04:29,450 --> 00:04:35,990
make more calls to the server up to

00:04:33,560 --> 00:04:39,560
perform extra round trips and this is

00:04:35,990 --> 00:04:42,710
problematic in general it even more

00:04:39,560 --> 00:04:45,650
problematic on mobile because of the

00:04:42,710 --> 00:04:48,650
high latency at mobile networks and it

00:04:45,650 --> 00:04:52,070
also means that there might be a big

00:04:48,650 --> 00:04:54,080
load on the server so I'm not saying

00:04:52,070 --> 00:04:56,180
this to say that rest can be made

00:04:54,080 --> 00:04:59,570
performant I don't think performance if

00:04:56,180 --> 00:05:02,420
the biggest problem ress has but there's

00:04:59,570 --> 00:05:03,950
an underlying issue here and that is

00:05:02,420 --> 00:05:06,320
part of the cost of making rest

00:05:03,950 --> 00:05:08,270
performing and that is that there's

00:05:06,320 --> 00:05:11,000
there's a real tension and I think most

00:05:08,270 --> 00:05:14,720
people here will recognize that tension

00:05:11,000 --> 00:05:16,820
between on one hand having efficient

00:05:14,720 --> 00:05:19,630
endpoints that give clients the exact

00:05:16,820 --> 00:05:22,220
data they need and on the other hand

00:05:19,630 --> 00:05:25,910
keeping those endpoints manageable on

00:05:22,220 --> 00:05:29,150
the server so there's a whole spectrum

00:05:25,910 --> 00:05:31,120
of different API designs here either

00:05:29,150 --> 00:05:35,150
sort of sort of very decomposed

00:05:31,120 --> 00:05:38,180
resources or feature api's find specific

00:05:35,150 --> 00:05:42,640
API defines exact data for a certain

00:05:38,180 --> 00:05:46,400
screen the problem is that this tension

00:05:42,640 --> 00:05:49,880
occurs not just within the technologies

00:05:46,400 --> 00:05:51,919
but also between team your front-end

00:05:49,880 --> 00:05:54,350
team match we have to ask the backend

00:05:51,919 --> 00:05:57,770
team to develop specific API they made

00:05:54,350 --> 00:06:03,490
they may be blocking on the backend team

00:05:57,770 --> 00:06:03,490
delivering those endpoints so

00:06:04,340 --> 00:06:10,190
graft prof dwell has seen a lot of

00:06:07,430 --> 00:06:13,550
adoption over last year one of the major

00:06:10,190 --> 00:06:16,550
announcement was github opening up a

00:06:13,550 --> 00:06:23,030
public version of a great rescue lapi

00:06:16,550 --> 00:06:26,600
they've been using internally and what

00:06:23,030 --> 00:06:29,449
is the main does the main idea

00:06:26,600 --> 00:06:32,780
underlying rescue well it's that instead

00:06:29,449 --> 00:06:34,729
of a server exposing endpoints instead

00:06:32,780 --> 00:06:37,550
of a server deciding what data should be

00:06:34,729 --> 00:06:41,110
returned to client when they perform a

00:06:37,550 --> 00:06:45,169
request on a specific endpoint appliance

00:06:41,110 --> 00:06:49,910
and specify their own data needs using

00:06:45,169 --> 00:06:53,270
the breath query language it's a way to

00:06:49,910 --> 00:06:57,080
specify the exact data they need against

00:06:53,270 --> 00:06:59,740
a very well-defined type description of

00:06:57,080 --> 00:07:04,729
the capabilities that a server exposed

00:06:59,740 --> 00:07:08,930
and there's a very simple example I'll

00:07:04,729 --> 00:07:12,470
show some more examples later on but as

00:07:08,930 --> 00:07:15,010
you can see from from this simple query

00:07:12,470 --> 00:07:18,200
example it's a very readable language

00:07:15,010 --> 00:07:20,930
and it meant that way so for instance

00:07:18,200 --> 00:07:23,750
the query on the Left asked for the

00:07:20,930 --> 00:07:26,180
titles of posts it gets back the

00:07:23,750 --> 00:07:27,560
creation response that resembles the

00:07:26,180 --> 00:07:29,810
shape of the Prairie it's really easy to

00:07:27,560 --> 00:07:32,450
predict what the response will look like

00:07:29,810 --> 00:07:35,240
response is also standard Jason it's

00:07:32,450 --> 00:07:39,229
something clients will be able to deal

00:07:35,240 --> 00:07:41,090
with and the curry has been defined

00:07:39,229 --> 00:07:44,750
against a scheme at that the server

00:07:41,090 --> 00:07:48,320
provides so it's typed and b-type

00:07:44,750 --> 00:07:50,570
tracked validated you can use very short

00:07:48,320 --> 00:07:53,389
of fooling around it fits very well

00:07:50,570 --> 00:07:57,710
defined relationship between client and

00:07:53,389 --> 00:08:00,950
server I want to say right from the

00:07:57,710 --> 00:08:04,479
start though even though I started out

00:08:00,950 --> 00:08:08,000
with the example of resting point that

00:08:04,479 --> 00:08:09,620
graticule has been designed to sold it's

00:08:08,000 --> 00:08:13,060
more than that there have been other

00:08:09,620 --> 00:08:16,280
attempt to solve same pointing rest and

00:08:13,060 --> 00:08:17,810
I think press rel just gets a very

00:08:16,280 --> 00:08:19,980
particular spot

00:08:17,810 --> 00:08:22,500
that doesn't necessarily have anything

00:08:19,980 --> 00:08:24,900
through with performance and that's the

00:08:22,500 --> 00:08:26,490
fact that it has been designed from the

00:08:24,900 --> 00:08:29,550
start with the needs of product

00:08:26,490 --> 00:08:32,130
developer in mind so the idea is that

00:08:29,550 --> 00:08:34,409
it's a language for front-end developers

00:08:32,130 --> 00:08:37,560
native mobile developers people

00:08:34,409 --> 00:08:40,469
developing application UI it's not a

00:08:37,560 --> 00:08:44,910
very language designed for server

00:08:40,469 --> 00:08:48,960
developers or database administrators so

00:08:44,910 --> 00:08:51,270
one example of how the developer

00:08:48,960 --> 00:08:55,529
experience aggressive L is something

00:08:51,270 --> 00:08:58,610
that product developers really

00:08:55,529 --> 00:08:58,610
appreciate this

00:09:05,939 --> 00:09:07,999
you

00:09:08,160 --> 00:09:12,230
you can have lost my printer here

00:09:14,940 --> 00:09:17,000
you

00:09:22,480 --> 00:09:25,320
we have been

00:09:27,790 --> 00:09:33,660
so this is the same example query that

00:09:31,540 --> 00:09:36,340
we saw before getting to post of titles

00:09:33,660 --> 00:09:38,410
YouTube your results on the right but

00:09:36,340 --> 00:09:40,950
this is actually an embedded tool called

00:09:38,410 --> 00:09:45,760
graphical that is fairly well known in

00:09:40,950 --> 00:09:49,630
press qln and that really shows sort of

00:09:45,760 --> 00:09:52,780
how amazing this tool can be because it

00:09:49,630 --> 00:09:55,870
offers you auto completion that

00:09:52,780 --> 00:09:59,850
automatically it helps you construct

00:09:55,870 --> 00:10:02,080
prairies it shows immediate results if I

00:09:59,850 --> 00:10:07,150
projects as they feel that doesn't exist

00:10:02,080 --> 00:10:10,780
I get a validation error and in this way

00:10:07,150 --> 00:10:12,370
you can see product developers I mean in

00:10:10,780 --> 00:10:14,560
general for developers get very excited

00:10:12,370 --> 00:10:16,180
when they see this tool because for the

00:10:14,560 --> 00:10:18,040
first time it allows them to express

00:10:16,180 --> 00:10:20,590
their data needs in their own language

00:10:18,040 --> 00:10:23,070
instead of having to rely on back end

00:10:20,590 --> 00:10:23,070
developers

00:10:24,600 --> 00:10:31,240
it's a it's a language that has been

00:10:28,540 --> 00:10:34,720
carefully designed to not only describe

00:10:31,240 --> 00:10:36,900
to the simple data needs but also in

00:10:34,720 --> 00:10:40,570
ways that allow you to hook up to

00:10:36,900 --> 00:10:45,580
component-based you is I'll say a little

00:10:40,570 --> 00:10:46,960
about that later on and this in case

00:10:45,580 --> 00:10:48,910
you're wondering I won't really go into

00:10:46,960 --> 00:10:52,110
this but a graphical also has a way of

00:10:48,910 --> 00:10:55,210
performing mutations mutations are

00:10:52,110 --> 00:10:58,600
operations that both update states and

00:10:55,210 --> 00:11:00,910
also give you the ability to query state

00:10:58,600 --> 00:11:04,320
so give you back results that may have

00:11:00,910 --> 00:11:04,320
been modified by that operation

00:11:09,680 --> 00:11:13,940
so if you want to know more about the

00:11:11,690 --> 00:11:17,570
graphical language there is an excellent

00:11:13,940 --> 00:11:19,850
new website rescue org and actually this

00:11:17,570 --> 00:11:21,320
is something most people miss when they

00:11:19,850 --> 00:11:22,970
first encounter this but all the code

00:11:21,320 --> 00:11:25,190
examples are live I have the same

00:11:22,970 --> 00:11:28,910
embedded replica interface I think it's

00:11:25,190 --> 00:11:30,500
kind of awesome let's talk a bit more

00:11:28,910 --> 00:11:35,930
about what it means to be aggressive

00:11:30,500 --> 00:11:37,850
client it's it Brett girl has been

00:11:35,930 --> 00:11:41,300
designed to be used on and the ability

00:11:37,850 --> 00:11:43,790
to automatically update your UI keep

00:11:41,300 --> 00:11:45,230
results consistent between queries it's

00:11:43,790 --> 00:11:47,779
an important ingredient of what makes

00:11:45,230 --> 00:11:51,980
sort of the graphical developer

00:11:47,779 --> 00:11:54,170
experience you're awesome an example for

00:11:51,980 --> 00:12:00,230
those of you who when you go to our

00:11:54,170 --> 00:12:02,209
website dot Apollo datacom you see code

00:12:00,230 --> 00:12:05,089
examples in different environments the

00:12:02,209 --> 00:12:09,529
views react native we have an angular

00:12:05,089 --> 00:12:12,770
client and I myself am particularly

00:12:09,529 --> 00:12:15,589
proud of the iOS client that's something

00:12:12,770 --> 00:12:20,450
I've been working on for a while it's a

00:12:15,589 --> 00:12:22,720
swift clients and like you give a short

00:12:20,450 --> 00:12:22,720
demonstration

00:12:26,230 --> 00:12:29,580
so what I think is particularly

00:12:31,010 --> 00:12:35,270
nice about this is the way to integrate

00:12:33,050 --> 00:12:38,330
with Xcode and it really shows how you

00:12:35,270 --> 00:12:42,590
can work with your UI components and

00:12:38,330 --> 00:12:46,610
your data declaration side by side so it

00:12:42,590 --> 00:12:48,890
shows a swift file for table field

00:12:46,610 --> 00:12:50,720
controller in this case with a query on

00:12:48,890 --> 00:12:55,550
the rights that specifies the data

00:12:50,720 --> 00:12:58,010
dependencies those data dependencies

00:12:55,550 --> 00:13:01,160
actually come from a child component a

00:12:58,010 --> 00:13:02,930
table of your cell in this case you can

00:13:01,160 --> 00:13:04,250
see the query on the right changing

00:13:02,930 --> 00:13:06,320
automatically when I switch to a

00:13:04,250 --> 00:13:10,040
difference with file so it gives you a

00:13:06,320 --> 00:13:14,860
very nice integrated experience it also

00:13:10,040 --> 00:13:14,860
has inline validation

00:13:16,880 --> 00:13:22,340
and you get immediate feedback when a

00:13:20,030 --> 00:13:25,190
query doesn't contain the fields that

00:13:22,340 --> 00:13:27,680
you access in your Swift file because it

00:13:25,190 --> 00:13:30,560
relies on pro generation and uses very

00:13:27,680 --> 00:13:32,890
specific result types that's a very nice

00:13:30,560 --> 00:13:36,890
way of getting compile time data safety

00:13:32,890 --> 00:13:39,320
it's definitely something I think is

00:13:36,890 --> 00:13:42,680
right for iOS developers we are bringing

00:13:39,320 --> 00:13:46,100
the same technologies to Android there

00:13:42,680 --> 00:13:49,430
are community members working on a bad

00:13:46,100 --> 00:13:52,270
script target for the code generator

00:13:49,430 --> 00:13:52,270
flow as well

00:13:54,010 --> 00:13:59,740
so

00:13:56,870 --> 00:13:59,740
let me

00:14:02,730 --> 00:14:06,139
the back here

00:14:08,720 --> 00:14:12,800
and talk a little bit about the server

00:14:10,819 --> 00:14:15,860
side of me because you might be

00:14:12,800 --> 00:14:17,660
wondering how complicated it is to set

00:14:15,860 --> 00:14:22,459
up a graph dell server hoop it up for

00:14:17,660 --> 00:14:27,519
your existing data sources because that

00:14:22,459 --> 00:14:30,290
is something that i think rapid well

00:14:27,519 --> 00:14:32,420
those are doing particularly well it's a

00:14:30,290 --> 00:14:34,579
abstraction layer a very thin

00:14:32,420 --> 00:14:37,819
abstraction layer over different data

00:14:34,579 --> 00:14:39,769
sources it's not at all a sort of

00:14:37,819 --> 00:14:43,279
complete query language it doesn't try

00:14:39,769 --> 00:14:47,360
to offer arbitrary filters or selection

00:14:43,279 --> 00:14:51,519
mechanisms it relies on application

00:14:47,360 --> 00:14:57,439
level scheme at that very carefully

00:14:51,519 --> 00:15:01,699
exposed data so this is an example of a

00:14:57,439 --> 00:15:06,560
very simple rescue all server a part of

00:15:01,699 --> 00:15:09,769
a ref dell server and there is actually

00:15:06,560 --> 00:15:12,889
that much to it like i said it's a very

00:15:09,769 --> 00:15:14,420
thin layer this is the graphical jes

00:15:12,889 --> 00:15:15,980
reference implementation by the way that

00:15:14,420 --> 00:15:17,930
this is using together with some of the

00:15:15,980 --> 00:15:19,639
follow graphical tools that we've

00:15:17,930 --> 00:15:26,540
developed to make writing these servers

00:15:19,639 --> 00:15:29,269
easier but servers in other languages

00:15:26,540 --> 00:15:38,000
work similarly the ideas that you write

00:15:29,269 --> 00:15:41,059
resolver functions or or field and by

00:15:38,000 --> 00:15:44,389
doing so you sort of fill in the the

00:15:41,059 --> 00:15:46,309
schema you've defined and you can do

00:15:44,389 --> 00:15:49,370
arbitrary processing in sort of any

00:15:46,309 --> 00:15:51,740
field you can also perform asynchronous

00:15:49,370 --> 00:15:53,689
operations returning promises to some of

00:15:51,740 --> 00:15:58,610
those operations can be performed in

00:15:53,689 --> 00:16:00,439
parallel and this allows you to hook up

00:15:58,610 --> 00:16:03,949
your graphical scheme at some sort of

00:16:00,439 --> 00:16:06,680
arbitrary data sources one nice feature

00:16:03,949 --> 00:16:09,529
if this is actually combining data from

00:16:06,680 --> 00:16:11,240
different data sources transparently for

00:16:09,529 --> 00:16:12,790
product developers front-end developers

00:16:11,240 --> 00:16:14,959
don't have to know where data come from

00:16:12,790 --> 00:16:17,589
and they can follow relationships

00:16:14,959 --> 00:16:20,870
between you very different data sources

00:16:17,589 --> 00:16:22,600
and those deck and fetches can then go

00:16:20,870 --> 00:16:26,050
to e

00:16:22,600 --> 00:16:29,709
or the rest endpoints databases various

00:16:26,050 --> 00:16:32,730
kinds external systems like Phil for

00:16:29,709 --> 00:16:35,730
instance so it's very nice way of

00:16:32,730 --> 00:16:35,730
designing

00:16:36,880 --> 00:16:45,480
a whole set of capabilities that product

00:16:42,130 --> 00:16:45,480
developers can then move into

00:16:46,940 --> 00:16:52,100
um so I'm gonna get absolutely clear

00:16:49,340 --> 00:16:53,240
this is not sort of a wholesale opening

00:16:52,100 --> 00:16:55,040
up of your back end your not exposing

00:16:53,240 --> 00:16:59,900
any data that you would not normally

00:16:55,040 --> 00:17:03,530
expose it's actually kind of an art to

00:16:59,900 --> 00:17:06,709
carefully design a schema to only expose

00:17:03,530 --> 00:17:08,959
things that make sense to client in a

00:17:06,709 --> 00:17:10,640
way that makes sense to them so for

00:17:08,959 --> 00:17:16,280
instance you wouldn't normally expose

00:17:10,640 --> 00:17:19,970
arbitrary equal filters or we wouldn't

00:17:16,280 --> 00:17:21,650
normally expose corporations that may

00:17:19,970 --> 00:17:24,850
not be efficient enough to be used at

00:17:21,650 --> 00:17:27,230
scale by client but you can I

00:17:24,850 --> 00:17:29,150
implementation details behind similar

00:17:27,230 --> 00:17:31,610
interfaces so for instance if you have

00:17:29,150 --> 00:17:33,610
the ability to order stories either by

00:17:31,610 --> 00:17:37,340
date with a simple database query or

00:17:33,610 --> 00:17:40,400
algorithmically that can be a very

00:17:37,340 --> 00:17:41,840
simple filter switch for cryin but on

00:17:40,400 --> 00:17:45,100
the back end those can result in

00:17:41,840 --> 00:17:45,100
completely different operation

00:17:46,270 --> 00:17:52,590
so that's sort of the mantra prof dwell

00:17:49,450 --> 00:17:56,050
any back-end any clients any language

00:17:52,590 --> 00:17:57,720
and i think over the last year what has

00:17:56,050 --> 00:18:01,920
happened to make good on that promise

00:17:57,720 --> 00:18:05,140
there are implementations in various

00:18:01,920 --> 00:18:09,250
languages multiple implementations in

00:18:05,140 --> 00:18:11,530
many cases and that goes both for

00:18:09,250 --> 00:18:13,660
clients before for server environments

00:18:11,530 --> 00:18:17,530
and for client environments variety of

00:18:13,660 --> 00:18:21,340
tooling around it it's really turning

00:18:17,530 --> 00:18:24,340
into an ecosystem that i think a lot of

00:18:21,340 --> 00:18:28,960
future apps will be able to profit from

00:18:24,340 --> 00:18:30,340
and when you look at it's not just from

00:18:28,960 --> 00:18:33,940
a technological point of view but from

00:18:30,340 --> 00:18:36,250
the social point of view we've actually

00:18:33,940 --> 00:18:38,380
found in sort of the apps we've

00:18:36,250 --> 00:18:41,470
developed internally but also in talking

00:18:38,380 --> 00:18:44,770
to talking to varied members of the

00:18:41,470 --> 00:18:47,650
community and customers that it sort of

00:18:44,770 --> 00:18:49,210
changes your development workflow and

00:18:47,650 --> 00:18:53,650
we've been calling this graph you all

00:18:49,210 --> 00:18:56,590
first and graphical first relies on the

00:18:53,650 --> 00:18:59,710
fact that the schema the graphical

00:18:56,590 --> 00:19:02,950
schema is a very strong contract between

00:18:59,710 --> 00:19:04,950
front-end and back-end so it contains

00:19:02,950 --> 00:19:10,350
type information if you contain

00:19:04,950 --> 00:19:10,350
descriptions it can belt document and

00:19:11,580 --> 00:19:15,060
and powers and unblocks product

00:19:13,440 --> 00:19:16,950
developers they don't have to wait for

00:19:15,060 --> 00:19:20,940
back-end developers to actually

00:19:16,950 --> 00:19:22,970
implement the schema because they can

00:19:20,940 --> 00:19:26,520
use for instance various mocking tools

00:19:22,970 --> 00:19:28,080
to build on mock data to build their UI

00:19:26,520 --> 00:19:30,600
or mock data with the exact same

00:19:28,080 --> 00:19:34,320
interface that back-end developers are

00:19:30,600 --> 00:19:37,590
in parallel working on implementing and

00:19:34,320 --> 00:19:40,050
for back-end developers it means that

00:19:37,590 --> 00:19:43,020
they don't have to focus on writing

00:19:40,050 --> 00:19:44,940
endpoint for individual client they're

00:19:43,020 --> 00:19:47,580
not sort of bothered by individual

00:19:44,940 --> 00:19:50,460
requests like this screen change I now

00:19:47,580 --> 00:19:53,310
need this extra field instead they can

00:19:50,460 --> 00:19:54,930
focus on carefully designing a schema

00:19:53,310 --> 00:19:57,380
and exposing capabilities in an

00:19:54,930 --> 00:19:57,380
efficient way

00:19:59,570 --> 00:20:04,280
there's another aspect that I haven't

00:20:01,520 --> 00:20:07,970
really mentioned that i think is pretty

00:20:04,280 --> 00:20:12,350
amazing breath girl has been designed to

00:20:07,970 --> 00:20:17,600
be to allow the continuous evolution of

00:20:12,350 --> 00:20:19,400
schemas because you are always because

00:20:17,600 --> 00:20:24,130
you always specify the exact data you

00:20:19,400 --> 00:20:28,280
need as long as sort of existing field

00:20:24,130 --> 00:20:29,870
are available you can add sort of

00:20:28,280 --> 00:20:32,780
arbitrary new information and alt

00:20:29,870 --> 00:20:35,300
clients won't be affected by it so it

00:20:32,780 --> 00:20:37,490
allows you to keep developing your

00:20:35,300 --> 00:20:39,170
schema without versioning it you don't

00:20:37,490 --> 00:20:41,000
need a version one or version 2 or

00:20:39,170 --> 00:20:45,560
version 3 like you would for your rest

00:20:41,000 --> 00:20:48,350
api and like really amazing proof of

00:20:45,560 --> 00:20:50,960
this is the facebook schema which hasn't

00:20:48,350 --> 00:20:54,200
actually which is backwards compatible

00:20:50,960 --> 00:20:56,390
even after four years they have

00:20:54,200 --> 00:20:59,300
literally hundreds of versions off their

00:20:56,390 --> 00:21:02,150
of their main iOS and Android apps

00:20:59,300 --> 00:21:04,790
talking to the same endpoint and that

00:21:02,150 --> 00:21:08,690
endpoint still supports the facebook app

00:21:04,790 --> 00:21:10,240
from 2012 and like for mobile

00:21:08,690 --> 00:21:12,110
development that is pretty amazing

00:21:10,240 --> 00:21:17,480
because this is something a lot of

00:21:12,110 --> 00:21:19,580
people struggle with then something you

00:21:17,480 --> 00:21:23,559
might wonder about is sort of isn't this

00:21:19,580 --> 00:21:25,330
too dynamic am i not giving my

00:21:23,559 --> 00:21:26,649
front-end developers quartic developers

00:21:25,330 --> 00:21:29,289
too much power that is something a

00:21:26,649 --> 00:21:31,120
back-end developer might say because

00:21:29,289 --> 00:21:32,919
they might have sort of carefully tuned

00:21:31,120 --> 00:21:34,659
sequel queries and their existing REST

00:21:32,919 --> 00:21:41,379
API and they don't really know what to

00:21:34,659 --> 00:21:42,999
expect from this new interface so one of

00:21:41,379 --> 00:21:46,419
the things we had Apollo has been

00:21:42,999 --> 00:21:51,009
working on is a way of giving you

00:21:46,419 --> 00:21:54,759
insight into both usage and performance

00:21:51,009 --> 00:21:56,559
of your graph ql server so it keeps

00:21:54,759 --> 00:21:58,869
track of field usage she tells you which

00:21:56,559 --> 00:22:00,610
fields are used by which clients maybe

00:21:58,869 --> 00:22:06,389
even when you would be able to deprecate

00:22:00,610 --> 00:22:09,519
them it can tell you when schemas are

00:22:06,389 --> 00:22:12,190
not backwards compatible so you can

00:22:09,519 --> 00:22:15,159
adjust them and it gives you a very

00:22:12,190 --> 00:22:19,450
specific field level performance

00:22:15,159 --> 00:22:21,100
information so you want to check this

00:22:19,450 --> 00:22:23,830
out there is no we just announced this

00:22:21,100 --> 00:22:26,159
two days ago there's a 14 day trial

00:22:23,830 --> 00:22:26,159
available

00:22:27,470 --> 00:22:37,190
and with that I would like to thank

00:22:31,970 --> 00:22:41,740
everyone the organization and very happy

00:22:37,190 --> 00:22:56,890
to talk to people either questions or

00:22:41,740 --> 00:22:59,929
afterwards Thank You Julia let's see um

00:22:56,890 --> 00:23:02,720
I do have stickers but I think I left

00:22:59,929 --> 00:23:06,710
left them upstairs and this t-shirt is

00:23:02,720 --> 00:23:09,890
limited edition right now only people in

00:23:06,710 --> 00:23:13,490
our company have it but we think it's

00:23:09,890 --> 00:23:17,830
pretty amazing so we may find a way to

00:23:13,490 --> 00:23:21,590
get it to more people at some point a

00:23:17,830 --> 00:23:25,880
meteor question will meteor 1.5 ship

00:23:21,590 --> 00:23:27,740
with Apollo for those of you who are not

00:23:25,880 --> 00:23:30,890
familiar with meteor meteor is a

00:23:27,740 --> 00:23:32,929
full-stack JavaScript framework that the

00:23:30,890 --> 00:23:38,210
company I work for meteor development

00:23:32,929 --> 00:23:42,289
group developed Apollo an effort that

00:23:38,210 --> 00:23:45,200
it's meant to go like it's not meteor

00:23:42,289 --> 00:23:48,919
specific it's something that will work

00:23:45,200 --> 00:23:51,980
with a variety of technology and in fact

00:23:48,919 --> 00:23:54,799
there's no sort of special shipping or

00:23:51,980 --> 00:23:56,870
handling for meteor necessary it will it

00:23:54,799 --> 00:24:01,510
does in fact work right now and we use

00:23:56,870 --> 00:24:01,510
it in our internal media replications

00:24:02,830 --> 00:24:08,750
just graphical handle subscriptions

00:24:05,210 --> 00:24:11,590
that's a really good question so graft

00:24:08,750 --> 00:24:14,090
well the graph field spec currently

00:24:11,590 --> 00:24:16,820
doesn't include subscriptions but there

00:24:14,090 --> 00:24:20,980
are various proposals that are used

00:24:16,820 --> 00:24:24,169
internally at Facebook fairly flex out

00:24:20,980 --> 00:24:26,750
proposals and actually as part of Apollo

00:24:24,169 --> 00:24:28,700
client we build an implementation of

00:24:26,750 --> 00:24:30,200
grasp your subscriptions that these give

00:24:28,700 --> 00:24:37,539
you the ability to deliver real-time

00:24:30,200 --> 00:24:41,990
updates over web sockets and a number of

00:24:37,539 --> 00:24:44,600
press ql back end of the service vendors

00:24:41,990 --> 00:24:46,520
and server implementers have also

00:24:44,600 --> 00:24:48,980
indicated that they'd like to implement

00:24:46,520 --> 00:24:51,169
the same subscription transport that

00:24:48,980 --> 00:24:52,520
we've implemented though I think this is

00:24:51,169 --> 00:24:55,990
something that over the next couple of

00:24:52,520 --> 00:24:55,990
months will probably come together

00:24:57,389 --> 00:25:02,369
another really good question to relay

00:24:59,219 --> 00:25:06,509
versus Apollo what other differences the

00:25:02,369 --> 00:25:12,440
relay is a graph girl client developed

00:25:06,509 --> 00:25:14,999
at Facebook and but the reason like when

00:25:12,440 --> 00:25:17,759
Facebook first started talking about

00:25:14,999 --> 00:25:19,679
graft well it was done in the context of

00:25:17,759 --> 00:25:21,299
open sourcing relay in fact open

00:25:19,679 --> 00:25:22,950
sourcing relay was one of two read since

00:25:21,299 --> 00:25:24,749
they started talking about graph to L so

00:25:22,950 --> 00:25:28,349
we should be really thankful to the

00:25:24,749 --> 00:25:33,359
relay team for making that happen the

00:25:28,349 --> 00:25:36,709
relay team has also experimented with a

00:25:33,359 --> 00:25:39,239
variety of design features on the client

00:25:36,709 --> 00:25:42,869
some of which I think worked out well

00:25:39,239 --> 00:25:45,959
others maybe not so much they themselves

00:25:42,869 --> 00:25:49,409
have started working on a second version

00:25:45,959 --> 00:25:51,779
of relay relay to that is in some

00:25:49,409 --> 00:25:53,599
respect more similar to Apollo for

00:25:51,779 --> 00:25:56,759
instance it doesn't do dynamic

00:25:53,599 --> 00:25:58,739
reconstruction it does static for you

00:25:56,759 --> 00:26:02,219
we're static queries the way a follow

00:25:58,739 --> 00:26:03,839
does I think one of the most important

00:26:02,219 --> 00:26:06,299
differences between rate relay in a

00:26:03,839 --> 00:26:08,820
fellow is that follow is sort of

00:26:06,299 --> 00:26:10,919
developed in the open with a lot of

00:26:08,820 --> 00:26:12,509
community contributions but we have over

00:26:10,919 --> 00:26:15,839
a hundred contributors we've worked with

00:26:12,509 --> 00:26:18,409
them from the start it also a more i

00:26:15,839 --> 00:26:22,079
would say modular open architecture

00:26:18,409 --> 00:26:27,409
which supports multiple front-end

00:26:22,079 --> 00:26:30,829
technologies relay for to react and we

00:26:27,409 --> 00:26:34,619
we've developed a follow fine on top of

00:26:30,829 --> 00:26:36,179
Redux which is also if you in a way is

00:26:34,619 --> 00:26:40,559
sort of looking into the inner workings

00:26:36,179 --> 00:26:46,639
off the cash so definitely like if you

00:26:40,559 --> 00:26:46,639
have more questions come to me ask them

00:26:47,290 --> 00:26:52,520
is it possible to integrate declined

00:26:49,580 --> 00:26:55,940
with an ember Jas app I'm not sure

00:26:52,520 --> 00:26:57,410
actually we have number of unity has

00:26:55,940 --> 00:26:59,870
developed I know we have a few j/s

00:26:57,410 --> 00:27:02,420
implementation for instance amber I'm

00:26:59,870 --> 00:27:05,560
not sure about if you're interested in

00:27:02,420 --> 00:27:09,250
it integrations tend to be fairly thin

00:27:05,560 --> 00:27:13,640
because it's really not a very

00:27:09,250 --> 00:27:16,310
complicated interface so for someone who

00:27:13,640 --> 00:27:18,080
has like member experience maybe a nap

00:27:16,310 --> 00:27:20,270
in production they'd like to work on

00:27:18,080 --> 00:27:22,690
that would be an awesome open source

00:27:20,270 --> 00:27:22,690
project

00:27:23,600 --> 00:27:30,360
when would recipe recommended over graft

00:27:26,250 --> 00:27:33,090
well I mean

00:27:30,360 --> 00:27:36,570
I definitely don't want to say that no

00:27:33,090 --> 00:27:38,100
one should use rest I think for apps

00:27:36,570 --> 00:27:41,310
development and mobile app development

00:27:38,100 --> 00:27:43,860
in particular raphaelle makes a lot lot

00:27:41,310 --> 00:27:47,040
of sense like if you run into the credit

00:27:43,860 --> 00:27:50,000
problems I described with rest I think

00:27:47,040 --> 00:27:50,000
rascal is a great fit

00:27:50,610 --> 00:27:59,580
that being said rest is a sort of long

00:27:54,080 --> 00:28:02,940
existing open architecture with a few

00:27:59,580 --> 00:28:05,640
really nice features like the way it

00:28:02,940 --> 00:28:10,100
integrates with HTTP and catching at

00:28:05,640 --> 00:28:13,500
that level if that is something you

00:28:10,100 --> 00:28:17,809
currently use that might be a good fit I

00:28:13,500 --> 00:28:20,730
think in general rest probably won't

00:28:17,809 --> 00:28:23,370
soon go away on the back end we actually

00:28:20,730 --> 00:28:26,760
think that there's the most architecture

00:28:23,370 --> 00:28:29,669
you'll probably end up with a pref 12

00:28:26,760 --> 00:28:32,880
server in front off multiple backends

00:28:29,669 --> 00:28:34,530
including rest endpoints and especially

00:28:32,880 --> 00:28:39,270
if the traffic is sort of within data

00:28:34,530 --> 00:28:41,970
center the kind of performance problems

00:28:39,270 --> 00:28:44,840
receive it rest for app development may

00:28:41,970 --> 00:28:48,450
not actually be that important for you

00:28:44,840 --> 00:28:53,549
so it's definitely not opposed to rest

00:28:48,450 --> 00:28:55,880
and in some cases rest may be a better

00:28:53,549 --> 00:28:55,880

YouTube URL: https://www.youtube.com/watch?v=SWiegnVtYzM


