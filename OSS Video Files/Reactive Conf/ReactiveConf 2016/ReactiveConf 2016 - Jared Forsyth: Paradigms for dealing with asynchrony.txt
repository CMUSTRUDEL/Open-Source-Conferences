Title: ReactiveConf 2016 - Jared Forsyth: Paradigms for dealing with asynchrony
Publication date: 2016-11-25
Playlist: ReactiveConf 2016
Description: 
	https://reactiveconf.com 

Meet those driving the change! World-renowned mobile and web innovators got together for three days in one town.

ReactiveConf, October 26 - 28 2016, Bratislava, Slovakia

---

Jared Forsyth: Paradigms for dealing with asynchrony

State changing over time is a frequent cause of bugs, confusion, and general hair-pulling, and we've developed a number of ways of trying to tame itâ€”observables, concurrent sequential processes, continuation passing style, and async/await. Learn how each of these paradigms work, hear about the advantages and disadvantages of each, and more importantly, discover what they have in common, because they might be more similar than you think.

---

Have you heard about ReactiveConf? According to tech superstars such as David Nolen, Richard Feldman, or Brent Vatne, itâ€™s the best conference on web and mobile app development! It focuses on all things React and beyond and takes place annually in Bratislava, Slovakia.

In 2016, more than 700 attendees from all over the world spent three days in Bratislava getting inspired, sharing amazing new ideas, and meeting more than 30 awesome speakers from companies such as Google, Cognitect, NoRedInk, RethinkDB, Airbnb, Microsoft, Facebook, and the list could go on forever.

If you want to be part of the next event, get your tickets now at https://reactiveconf.com, and React with us!
Captions: 
	00:00:04,580 --> 00:00:09,080
Jared Forsyth I work on the mobile team

00:00:07,399 --> 00:00:10,879
at Khan Academy so I spent a lot of time

00:00:09,080 --> 00:00:14,030
in Java and objective-c

00:00:10,879 --> 00:00:16,039
and Swift but my roots are really in the

00:00:14,030 --> 00:00:18,980
web and so I spend all my personal

00:00:16,039 --> 00:00:20,900
projects are working with react and I

00:00:18,980 --> 00:00:22,910
keep pushing to get us on to react

00:00:20,900 --> 00:00:24,380
native in our mobile apps but we're not

00:00:22,910 --> 00:00:27,380
quite there yet

00:00:24,380 --> 00:00:32,660
but so in in our Android apps an or iOS

00:00:27,380 --> 00:00:34,910
app we use observables a lot and there

00:00:32,660 --> 00:00:36,680
are all kinds of asynchronous queries

00:00:34,910 --> 00:00:39,500
that we do and this happens on the web

00:00:36,680 --> 00:00:41,150
as well and one thing that I've always

00:00:39,500 --> 00:00:43,310
wondered is how do these things relate

00:00:41,150 --> 00:00:44,960
you've got observables and then there's

00:00:43,310 --> 00:00:46,700
promises and callbacks

00:00:44,960 --> 00:00:48,829
and if you've ever heard of core dot

00:00:46,700 --> 00:00:52,030
async or CSP there are all different

00:00:48,829 --> 00:00:55,130
ways to try and attack this problem of

00:00:52,030 --> 00:00:59,420
dealing with asynchrony in languages

00:00:55,130 --> 00:01:02,570
that are essentially non asynchronous

00:00:59,420 --> 00:01:03,739
they're synchronous there you execute

00:01:02,570 --> 00:01:04,570
one thing you execute the next thing

00:01:03,739 --> 00:01:06,439
after it

00:01:04,570 --> 00:01:09,289
so here the four things I'm going to be

00:01:06,439 --> 00:01:11,990
talking about callbacks promises and

00:01:09,289 --> 00:01:13,819
async await is just kind of a nicer

00:01:11,990 --> 00:01:16,459
syntax on top of promises and then

00:01:13,819 --> 00:01:21,590
observables and when I say observables I

00:01:16,459 --> 00:01:25,159
mean the reactive X observable Rx Java

00:01:21,590 --> 00:01:28,249
reactive cocoa rxjs and then

00:01:25,159 --> 00:01:30,499
communicating sequential processes which

00:01:28,249 --> 00:01:33,439
everyone says CSP because that is way

00:01:30,499 --> 00:01:35,689
too many syllables and this you might be

00:01:33,439 --> 00:01:38,659
familiar with from the go language the

00:01:35,689 --> 00:01:42,200
go blocks or if you are a closure a

00:01:38,659 --> 00:01:45,349
closure script person the core dot async

00:01:42,200 --> 00:01:47,209
give brings that to closure and there

00:01:45,349 --> 00:01:50,679
are a couple of libraries for Python and

00:01:47,209 --> 00:01:53,719
for JavaScript that also give that to us

00:01:50,679 --> 00:01:55,810
so why should you care about this you

00:01:53,719 --> 00:01:57,439
know in the good old days of JavaScript

00:01:55,810 --> 00:02:00,349
you don't have to worry about

00:01:57,439 --> 00:02:02,439
asynchronous stuff if you wanted the

00:02:00,349 --> 00:02:05,929
input from a user you use prompt and

00:02:02,439 --> 00:02:09,410
then it pauses the whole browser like

00:02:05,929 --> 00:02:11,989
all of the tabs stop and then wait for

00:02:09,410 --> 00:02:13,370
the user to put in their name and then

00:02:11,989 --> 00:02:18,250
you can just keep going you had

00:02:13,370 --> 00:02:18,250
synchronous Ajax requests it was great

00:02:21,020 --> 00:02:26,580
but even then there were event handlers

00:02:23,940 --> 00:02:29,400
there were a synchronous network

00:02:26,580 --> 00:02:31,290
requests and then Along Came node and

00:02:29,400 --> 00:02:32,970
there were all kinds of asynchronous

00:02:31,290 --> 00:02:38,640
things that we had to do there was file

00:02:32,970 --> 00:02:41,070
access networking databases and all of a

00:02:38,640 --> 00:02:44,100
sudden the the callback paradigm that we

00:02:41,070 --> 00:02:46,560
were used to from the web started to be

00:02:44,100 --> 00:02:48,960
used a lot more and we developed the

00:02:46,560 --> 00:02:50,430
error first callback pattern so that we

00:02:48,960 --> 00:02:52,620
could account for errors and callbacks

00:02:50,430 --> 00:02:54,270
and when I talk about callbacks for this

00:02:52,620 --> 00:02:58,230
talk I'm mostly talking about the error

00:02:54,270 --> 00:02:59,760
first pattern and then now in the modern

00:02:58,230 --> 00:03:01,650
web we have animations we have web

00:02:59,760 --> 00:03:04,320
workers we have indexdb all kinds of

00:03:01,650 --> 00:03:06,990
things where we're gonna have to deal

00:03:04,320 --> 00:03:12,120
with asynchronous processes and in many

00:03:06,990 --> 00:03:13,590
cases we have to coordinate them so

00:03:12,120 --> 00:03:15,030
first I'm gonna give an overview of

00:03:13,590 --> 00:03:18,240
these four different ways of dealing

00:03:15,030 --> 00:03:19,770
with asynchronous stuff callbacks I'm

00:03:18,240 --> 00:03:23,250
talking about error first callbacks from

00:03:19,770 --> 00:03:24,480
node J s the contract the implicit

00:03:23,250 --> 00:03:26,310
contract is that they're only called

00:03:24,480 --> 00:03:28,080
once I don't know if you've ever had a

00:03:26,310 --> 00:03:31,709
library that breaks that and then

00:03:28,080 --> 00:03:33,000
everything falls apart this is an

00:03:31,709 --> 00:03:36,060
example of what you might do with

00:03:33,000 --> 00:03:38,040
callbacks in node you read a file and

00:03:36,060 --> 00:03:39,300
then you do a network request and at the

00:03:38,040 --> 00:03:41,640
end you've got these two bits of data

00:03:39,300 --> 00:03:44,070
and you need to make sure to handle all

00:03:41,640 --> 00:03:46,260
of your errors so if error do something

00:03:44,070 --> 00:03:51,860
I'm not entering that errors very well

00:03:46,260 --> 00:03:54,150
here but I am handling them promises

00:03:51,860 --> 00:03:58,010
promises are different from callbacks

00:03:54,150 --> 00:04:00,330
and that they cache their result and

00:03:58,010 --> 00:04:03,590
they enforce that there's only ever one

00:04:00,330 --> 00:04:06,060
value which can be really valuable um

00:04:03,590 --> 00:04:08,580
the thing that has been super annoying

00:04:06,060 --> 00:04:10,050
about promises ever since they were

00:04:08,580 --> 00:04:12,180
introduced to JavaScript is that they

00:04:10,050 --> 00:04:14,940
eat errors for lunch like if you've ever

00:04:12,180 --> 00:04:17,549
tried to use a promise and then if

00:04:14,940 --> 00:04:20,370
something doesn't work it manifests

00:04:17,549 --> 00:04:22,950
itself in different ways but somehow you

00:04:20,370 --> 00:04:24,090
you have this niggling sensation in the

00:04:22,950 --> 00:04:26,070
back of your mind that somewhere a

00:04:24,090 --> 00:04:27,360
promise has eaten your error and you

00:04:26,070 --> 00:04:28,740
don't know where it is and so you go

00:04:27,360 --> 00:04:29,770
through you put breakpoints you do

00:04:28,740 --> 00:04:31,629
whatever the

00:04:29,770 --> 00:04:33,849
stays things are getting a little bit

00:04:31,629 --> 00:04:39,220
better I I saw actually yesterday that

00:04:33,849 --> 00:04:40,960
node version 7 is deprecating the this

00:04:39,220 --> 00:04:45,069
error eating behavior so unhandled

00:04:40,960 --> 00:04:46,539
promise exceptions will kill your node

00:04:45,069 --> 00:04:49,659
process in the future and give you a

00:04:46,539 --> 00:04:51,669
proper trace back so in the somewhat

00:04:49,659 --> 00:04:55,449
near future this will no longer be a

00:04:51,669 --> 00:04:58,270
problem and modern browsers also allow

00:04:55,449 --> 00:05:00,759
you to catch these exceptions when

00:04:58,270 --> 00:05:02,770
you're debugging but this is what the

00:05:00,759 --> 00:05:06,009
same code would look like if you were

00:05:02,770 --> 00:05:08,199
using promises you've got a promised

00:05:06,009 --> 00:05:10,750
version of reading a file and getting a

00:05:08,199 --> 00:05:15,069
website and then you can do something to

00:05:10,750 --> 00:05:17,020
get at the end and the catch Clause will

00:05:15,069 --> 00:05:18,430
be called with any errors that that

00:05:17,020 --> 00:05:22,930
happen from either of the promises and

00:05:18,430 --> 00:05:24,969
you can handle them there async await as

00:05:22,930 --> 00:05:28,210
I said is it's just kind of a prettier

00:05:24,969 --> 00:05:31,719
way to use promises the the underlying

00:05:28,210 --> 00:05:36,490
idea is the same a sink calls return

00:05:31,719 --> 00:05:39,789
promises and now in chrome 55 which is

00:05:36,490 --> 00:05:41,949
in beta async await is natively

00:05:39,789 --> 00:05:43,509
supported which is a huge thing if

00:05:41,949 --> 00:05:46,110
you've tried to use async await with

00:05:43,509 --> 00:05:48,250
translation be a tracer or babel

00:05:46,110 --> 00:05:50,650
debugging is just a nightmare because

00:05:48,250 --> 00:05:53,219
the the resulting state machine is so

00:05:50,650 --> 00:05:55,210
different from the code that you wrote

00:05:53,219 --> 00:05:57,370
especially if you have a source map

00:05:55,210 --> 00:06:01,539
turned on you you have no hope of

00:05:57,370 --> 00:06:03,310
figuring out what the errors are this is

00:06:01,539 --> 00:06:05,830
what that code would look like if we

00:06:03,310 --> 00:06:08,740
turned it into a single weight and you

00:06:05,830 --> 00:06:10,419
can see there is less nesting it's it's

00:06:08,740 --> 00:06:13,000
easier to keep track of variables within

00:06:10,419 --> 00:06:15,810
the same scope of a function but again

00:06:13,000 --> 00:06:15,810
make sure you catch those errors

00:06:16,100 --> 00:06:22,680
moving onto observables observables in

00:06:19,350 --> 00:06:24,210
CSP work on multiple values and so

00:06:22,680 --> 00:06:28,259
there's a lot more going on a lot more

00:06:24,210 --> 00:06:32,400
power and the underlying principle of

00:06:28,259 --> 00:06:35,550
observables is a stream of values you

00:06:32,400 --> 00:06:38,130
never really work on one value at a time

00:06:35,550 --> 00:06:41,069
all the transformations that you do take

00:06:38,130 --> 00:06:42,900
in a stream and return a new stream and

00:06:41,069 --> 00:06:44,069
it's immutable you you're not mutating

00:06:42,900 --> 00:06:46,319
the original stream you get a new

00:06:44,069 --> 00:06:48,479
version that has been transformed either

00:06:46,319 --> 00:06:51,509
by mapping over everything by filtering

00:06:48,479 --> 00:06:56,340
by cutting the stream in half starting

00:06:51,509 --> 00:06:57,720
late ending early and then this is a an

00:06:56,340 --> 00:06:59,789
example of code that has only been

00:06:57,720 --> 00:07:02,910
slightly modified from from where it is

00:06:59,789 --> 00:07:04,740
in our Android app actually there's a

00:07:02,910 --> 00:07:07,979
page where you can do math problems in

00:07:04,740 --> 00:07:10,620
the Khan Academy app and math problems

00:07:07,979 --> 00:07:13,740
are grouped into a sequence that is

00:07:10,620 --> 00:07:15,750
called a task and so here we need to get

00:07:13,740 --> 00:07:18,750
the task data this is for setting up

00:07:15,750 --> 00:07:20,820
this exercises screen you first need to

00:07:18,750 --> 00:07:23,909
get the task data and then you've got a

00:07:20,820 --> 00:07:25,620
stream of these problems and with the

00:07:23,909 --> 00:07:29,220
first problem we want to combine it with

00:07:25,620 --> 00:07:31,050
the task data and load that up but then

00:07:29,220 --> 00:07:32,639
all the subsequent problems we want to

00:07:31,050 --> 00:07:34,889
do something else it's a it's a simpler

00:07:32,639 --> 00:07:38,219
process to just swap in a new problem we

00:07:34,889 --> 00:07:39,840
don't need the task data and you don't

00:07:38,219 --> 00:07:41,610
have to understand all of this but this

00:07:39,840 --> 00:07:45,349
is just a gate you give you a feel of

00:07:41,610 --> 00:07:50,490
what it's like to work with observables

00:07:45,349 --> 00:07:52,139
CSP doesn't use streams as a concept

00:07:50,490 --> 00:07:55,710
instead you're working with each value

00:07:52,139 --> 00:07:59,039
individually which is a very important

00:07:55,710 --> 00:08:00,960
difference and there are lightweight

00:07:59,039 --> 00:08:05,310
threads if again if you're familiar with

00:08:00,960 --> 00:08:07,229
go the the go threads where when you

00:08:05,310 --> 00:08:10,409
send a value to another process you

00:08:07,229 --> 00:08:13,020
block until they accept it and when you

00:08:10,409 --> 00:08:15,120
ask for a value from another process you

00:08:13,020 --> 00:08:17,219
block until they send it and so there's

00:08:15,120 --> 00:08:19,469
coordination that goes on it's very

00:08:17,219 --> 00:08:21,630
different than the way that observables

00:08:19,469 --> 00:08:24,180
work where the producer just kind of

00:08:21,630 --> 00:08:26,699
starts putting out values as soon as

00:08:24,180 --> 00:08:28,090
they get subscribed to and the

00:08:26,699 --> 00:08:31,120
subscriber

00:08:28,090 --> 00:08:33,450
handles values as they happen it doesn't

00:08:31,120 --> 00:08:36,250
it doesn't wait it doesn't have a way to

00:08:33,450 --> 00:08:40,150
block the producer unless you get into

00:08:36,250 --> 00:08:42,419
more complicated operations but this is

00:08:40,150 --> 00:08:46,690
this is the same tasks from observables

00:08:42,419 --> 00:08:48,490
done with CSP so there there's an output

00:08:46,690 --> 00:08:52,150
channel that we're going to be sending

00:08:48,490 --> 00:08:55,630
our commands on and then the the yield

00:08:52,150 --> 00:09:00,820
function that this is using JSC SP which

00:08:55,630 --> 00:09:03,160
is the JavaScript CSV library and you

00:09:00,820 --> 00:09:07,029
you get the task data you get the first

00:09:03,160 --> 00:09:09,310
problem info and then you output a

00:09:07,029 --> 00:09:12,279
command and then you just do a while

00:09:09,310 --> 00:09:14,230
loop to go over all of the other problem

00:09:12,279 --> 00:09:16,600
infos and because this is a generator

00:09:14,230 --> 00:09:21,520
well every yield has the potential to

00:09:16,600 --> 00:09:23,310
block so if our our process that's doing

00:09:21,520 --> 00:09:27,010
the network requests to get the problem

00:09:23,310 --> 00:09:30,990
information takes a while this process

00:09:27,010 --> 00:09:33,760
will block and wait for the next one and

00:09:30,990 --> 00:09:35,980
I think I think the the difference here

00:09:33,760 --> 00:09:41,080
between this and the previous code is

00:09:35,980 --> 00:09:43,150
interesting where with sequential

00:09:41,080 --> 00:09:45,430
processes you can you can work on your

00:09:43,150 --> 00:09:47,529
data in the order that you think about

00:09:45,430 --> 00:09:49,750
it you don't have to deal with the whole

00:09:47,529 --> 00:09:53,050
stream at once but on the other hand

00:09:49,750 --> 00:09:57,190
with observables there's there's a kind

00:09:53,050 --> 00:09:59,320
of elegance to the thinking at a higher

00:09:57,190 --> 00:10:00,730
level thinking about all of the data at

00:09:59,320 --> 00:10:02,740
once and and how the functions that

00:10:00,730 --> 00:10:05,020
you're applying will transform that into

00:10:02,740 --> 00:10:09,279
a new stream so it's it's just different

00:10:05,020 --> 00:10:12,339
ways of thinking about your data so I

00:10:09,279 --> 00:10:15,459
came up with a bunch of different kind

00:10:12,339 --> 00:10:17,770
of attributes of these methods that I

00:10:15,459 --> 00:10:20,440
think are useful to look at where's the

00:10:17,770 --> 00:10:22,600
number of values and the the places that

00:10:20,440 --> 00:10:27,310
values can come from with callbacks and

00:10:22,600 --> 00:10:28,570
promises there's only one one value and

00:10:27,310 --> 00:10:31,420
one source of those values but

00:10:28,570 --> 00:10:33,760
observables and CSP can can merge values

00:10:31,420 --> 00:10:35,920
coming from many different places and a

00:10:33,760 --> 00:10:39,610
channel or an observable can contain up

00:10:35,920 --> 00:10:41,410
to an infinite number of values the

00:10:39,610 --> 00:10:44,050
number of destinations

00:10:41,410 --> 00:10:46,360
different promises they they cash their

00:10:44,050 --> 00:10:49,420
value and so you you can hand it out to

00:10:46,360 --> 00:10:50,860
any number of functions or clients that

00:10:49,420 --> 00:10:53,470
want that value and they'll all wait for

00:10:50,860 --> 00:10:55,509
it with callbacks that there's only one

00:10:53,470 --> 00:10:59,470
function that's gonna be receiving the

00:10:55,509 --> 00:11:02,800
value with observables again similar to

00:10:59,470 --> 00:11:05,079
promises every client that receives it

00:11:02,800 --> 00:11:06,699
will will see the same values it

00:11:05,079 --> 00:11:11,019
multiplexes by default

00:11:06,699 --> 00:11:12,759
essentially in CSP if that's not the

00:11:11,019 --> 00:11:14,410
default it there are some cases where

00:11:12,759 --> 00:11:16,209
you want that and you could there's

00:11:14,410 --> 00:11:18,009
there's an extra operator you can use to

00:11:16,209 --> 00:11:22,899
multiplex but it's a little bit more

00:11:18,009 --> 00:11:24,850
work and the the underlying concept of

00:11:22,899 --> 00:11:27,060
CSP is one process talking to another

00:11:24,850 --> 00:11:31,209
process and the exception is

00:11:27,060 --> 00:11:33,819
multiplexing error handling is another

00:11:31,209 --> 00:11:35,439
important thing in many cases with

00:11:33,819 --> 00:11:38,500
asynchronous work if you've got a

00:11:35,439 --> 00:11:40,420
database call a network request where

00:11:38,500 --> 00:11:42,819
you want to make sure that their errors

00:11:40,420 --> 00:11:44,680
are handled well I put the little kind

00:11:42,819 --> 00:11:47,800
of warning sign next to callbacks and

00:11:44,680 --> 00:11:50,680
CSP because they're not there's no

00:11:47,800 --> 00:11:54,610
first-class support in the types it with

00:11:50,680 --> 00:11:56,110
callbacks there's the error first way of

00:11:54,610 --> 00:11:57,639
doing things that note is established

00:11:56,110 --> 00:11:58,810
but there's no guarantee about that you

00:11:57,639 --> 00:12:02,110
know if you're using a type check

00:11:58,810 --> 00:12:05,130
language it gets a lot you can get more

00:12:02,110 --> 00:12:07,480
guarantees from that and in CSP a

00:12:05,130 --> 00:12:10,810
channel just holds a value and that

00:12:07,480 --> 00:12:13,209
value might be a number it might be an

00:12:10,810 --> 00:12:17,230
error and so in in the JavaScript

00:12:13,209 --> 00:12:19,480
library the convention is to if you're

00:12:17,230 --> 00:12:21,699
using a channel that might have errors

00:12:19,480 --> 00:12:24,490
on it to check the type of the value you

00:12:21,699 --> 00:12:25,959
get out do is instance with the with the

00:12:24,490 --> 00:12:30,040
result and if it's an error then you

00:12:25,959 --> 00:12:31,930
handle it if not then you you handle it

00:12:30,040 --> 00:12:34,410
caching is another difference as I said

00:12:31,930 --> 00:12:37,360
promises cache callbacks don't

00:12:34,410 --> 00:12:39,550
observables can they don't by default

00:12:37,360 --> 00:12:42,850
but their operators you can do but with

00:12:39,550 --> 00:12:46,660
CSP the concept of caching doesn't

00:12:42,850 --> 00:12:47,949
really make sense afternoon with

00:12:46,660 --> 00:12:49,360
observables it does because you're

00:12:47,949 --> 00:12:52,209
handing out this observable to many

00:12:49,360 --> 00:12:55,509
different things and they might come in

00:12:52,209 --> 00:12:58,360
late in the game and so you want them to

00:12:55,509 --> 00:13:01,720
see the past values that were sent

00:12:58,360 --> 00:13:05,470
through with CSP there is no late in the

00:13:01,720 --> 00:13:08,230
game because it waits to send things

00:13:05,470 --> 00:13:10,420
until you take them and also if you hand

00:13:08,230 --> 00:13:12,970
out a channel to multiple processes

00:13:10,420 --> 00:13:14,800
without multiplexing it they won't all

00:13:12,970 --> 00:13:16,810
see the same data as soon as you take

00:13:14,800 --> 00:13:18,579
something from a channel the other

00:13:16,810 --> 00:13:23,709
processes won't see it they'll they'll

00:13:18,579 --> 00:13:25,180
get the next value after that I talked

00:13:23,709 --> 00:13:27,220
about push versus pull a little bit

00:13:25,180 --> 00:13:29,259
where CSP is different from callbacks

00:13:27,220 --> 00:13:33,190
promises and observables I mean this is

00:13:29,259 --> 00:13:36,639
the this is the key insight where with

00:13:33,190 --> 00:13:41,069
callbacks promises and observables the

00:13:36,639 --> 00:13:44,290
decision for when an event gets handled

00:13:41,069 --> 00:13:45,850
happens at the source and it happens as

00:13:44,290 --> 00:13:49,600
a result of the transformations in the

00:13:45,850 --> 00:13:51,639
case of observables but with CSP the

00:13:49,600 --> 00:13:54,730
client can decide when they want that

00:13:51,639 --> 00:13:58,329
value and make they can coordinate for

00:13:54,730 --> 00:13:59,649
example between different streams and if

00:13:58,329 --> 00:14:01,329
there's a specific order that's

00:13:59,649 --> 00:14:04,420
important it's very fluid to do it

00:14:01,329 --> 00:14:06,940
whereas with observables that's kind of

00:14:04,420 --> 00:14:09,550
an anti-pattern if if you find yourself

00:14:06,940 --> 00:14:12,880
wanting to ensure an ordering of

00:14:09,550 --> 00:14:14,260
different streams you'll be fighting the

00:14:12,880 --> 00:14:16,779
framework a little bit and that's what

00:14:14,260 --> 00:14:21,250
I've seen in in the work that I've done

00:14:16,779 --> 00:14:22,899
with rx Java and reactive cocoa cancel

00:14:21,250 --> 00:14:26,380
ability at something that observables do

00:14:22,899 --> 00:14:27,490
really well though in brief if you want

00:14:26,380 --> 00:14:30,069
to cancel an observable

00:14:27,490 --> 00:14:31,899
you just unsubscribe from it as well as

00:14:30,069 --> 00:14:34,480
soon as there are no more people that no

00:14:31,899 --> 00:14:37,959
more clients waiting for the values the

00:14:34,480 --> 00:14:41,980
producer of this data be it you know a

00:14:37,959 --> 00:14:43,780
network request be it events can just

00:14:41,980 --> 00:14:46,180
stop producing the data

00:14:43,780 --> 00:14:50,070
and if it's a if it's an expensive

00:14:46,180 --> 00:14:50,070
ajax.request it can cancel that as well

00:14:50,310 --> 00:14:56,890
it with promises we are going to get

00:14:54,280 --> 00:14:59,740
cancel ability there's there's been so

00:14:56,890 --> 00:15:02,080
much discussion and controversy over how

00:14:59,740 --> 00:15:05,590
that make promises cancelable because

00:15:02,080 --> 00:15:07,900
the new fetch API that is so nice to

00:15:05,590 --> 00:15:11,620
work with can't be canceled because it

00:15:07,900 --> 00:15:13,150
returns a promise but things are

00:15:11,620 --> 00:15:16,620
probably moving in the direction of

00:15:13,150 --> 00:15:20,830
being cancelable so that'll be all right

00:15:16,620 --> 00:15:22,120
with CSP not having canceled is is a

00:15:20,830 --> 00:15:24,670
little bit less of a problem because

00:15:22,120 --> 00:15:26,530
it's pull based right if you want the

00:15:24,670 --> 00:15:29,820
producer to stop doing work you just

00:15:26,530 --> 00:15:32,080
don't ask for any and it will be blocked

00:15:29,820 --> 00:15:33,730
but there there's still no solution for

00:15:32,080 --> 00:15:36,040
if I wanted to actually cancel something

00:15:33,730 --> 00:15:39,430
that it started but I think this is an

00:15:36,040 --> 00:15:41,170
API level problem and I wouldn't be

00:15:39,430 --> 00:15:43,350
surprised to see libraries solve this in

00:15:41,170 --> 00:15:43,350
the future

00:15:44,100 --> 00:15:52,440
when I say private set I mean who gets

00:15:46,660 --> 00:15:55,540
to send values with a promise as I can

00:15:52,440 --> 00:15:58,750
show here but when you're creating a

00:15:55,540 --> 00:16:01,570
promise down below you get a resolve and

00:15:58,750 --> 00:16:05,980
a reject function inside of this closure

00:16:01,570 --> 00:16:08,320
and and no client of the promise can

00:16:05,980 --> 00:16:10,570
resolve it for you yet you have to

00:16:08,320 --> 00:16:12,460
handle the resolving or rejecting when

00:16:10,570 --> 00:16:15,040
you create it and it's similar with

00:16:12,460 --> 00:16:18,550
observables the the client of an

00:16:15,040 --> 00:16:24,300
observable can't affect the data that is

00:16:18,550 --> 00:16:28,660
on the stream but with with CSP a

00:16:24,300 --> 00:16:31,150
channel is writable by anyone which i

00:16:28,660 --> 00:16:32,950
think is a little bit dangerous and

00:16:31,150 --> 00:16:35,290
again this this is probably an API level

00:16:32,950 --> 00:16:39,000
problem the rust language has a

00:16:35,290 --> 00:16:42,400
primitive similar to CSP and they have a

00:16:39,000 --> 00:16:44,320
sender and a receiver Channel and you

00:16:42,400 --> 00:16:45,580
can pass the receiver channel to two

00:16:44,320 --> 00:16:52,030
other clients and they can't mess with

00:16:45,580 --> 00:16:53,770
it um but that's an API problem I also

00:16:52,030 --> 00:16:55,000
talked about mental overhead because I

00:16:53,770 --> 00:16:56,380
this is really important to consider

00:16:55,000 --> 00:16:57,250
when you're when you're thinking about

00:16:56,380 --> 00:17:00,340
okay I

00:16:57,250 --> 00:17:03,460
I'm looking at this problem here ways to

00:17:00,340 --> 00:17:06,520
solve it how annoying is it gonna be in

00:17:03,460 --> 00:17:08,589
the future to look at this and callbacks

00:17:06,520 --> 00:17:10,780
are so simple there's there's no

00:17:08,589 --> 00:17:13,540
overhead of course it gets really

00:17:10,780 --> 00:17:16,150
complicated when you try to coordinate

00:17:13,540 --> 00:17:17,800
between different things so that that is

00:17:16,150 --> 00:17:21,160
overhead but anyway you see a callback

00:17:17,800 --> 00:17:25,360
you know what's going on promises again

00:17:21,160 --> 00:17:29,050
with the the debug ability the this will

00:17:25,360 --> 00:17:34,150
get better but I've just spent a lot of

00:17:29,050 --> 00:17:35,290
time with observables and I'll I'll talk

00:17:34,150 --> 00:17:38,080
about this a little bit later but there

00:17:35,290 --> 00:17:39,940
there's a lot of work that you do in

00:17:38,080 --> 00:17:42,220
your head to try and figure out what the

00:17:39,940 --> 00:17:44,500
system is doing and I haven't worked

00:17:42,220 --> 00:17:51,520
with CSP enough to to be able to give a

00:17:44,500 --> 00:17:53,950
reading on how much overhead there is so

00:17:51,520 --> 00:17:55,270
an interesting way to compare these

00:17:53,950 --> 00:17:57,190
things to each other is what does it

00:17:55,270 --> 00:17:59,560
take to convert from one system to

00:17:57,190 --> 00:18:01,930
another if you've done anything with

00:17:59,560 --> 00:18:03,880
promises or called then you've probably

00:18:01,930 --> 00:18:06,520
had to convert from a promise to a call

00:18:03,880 --> 00:18:08,670
back and back and this is this is what

00:18:06,520 --> 00:18:11,800
it looked like

00:18:08,670 --> 00:18:13,960
can vary between CSP and callbacks angle

00:18:11,800 --> 00:18:17,080
be interesting to you in in the top we

00:18:13,960 --> 00:18:20,770
have a you get past a cut a function

00:18:17,080 --> 00:18:23,770
that expects a callback and you want to

00:18:20,770 --> 00:18:26,170
return a channel that will produce the

00:18:23,770 --> 00:18:29,650
value and so you you create this

00:18:26,170 --> 00:18:31,660
callback function give it to FN and then

00:18:29,650 --> 00:18:34,060
when you get the result you either push

00:18:31,660 --> 00:18:36,160
on the error or push on the result as I

00:18:34,060 --> 00:18:38,440
said there's no special handling for

00:18:36,160 --> 00:18:40,450
errors and then going the other

00:18:38,440 --> 00:18:42,070
direction you take the value off the

00:18:40,450 --> 00:18:44,140
channel and you have to check to see

00:18:42,070 --> 00:18:45,730
whether it's an error and then you you

00:18:44,140 --> 00:18:49,420
pass it as either the first argument or

00:18:45,730 --> 00:18:51,430
the second argument I'm going to skip

00:18:49,420 --> 00:18:56,830
past this comparison but this is this is

00:18:51,430 --> 00:18:58,630
CSP two observables and the the

00:18:56,830 --> 00:19:00,340
observables two CSP is very

00:18:58,630 --> 00:19:02,650
straightforward and the other way around

00:19:00,340 --> 00:19:06,429
takes a little bit more boilerplate a

00:19:02,650 --> 00:19:09,010
little bit more work because observables

00:19:06,429 --> 00:19:11,370
have nice abstractions for doing one

00:19:09,010 --> 00:19:14,280
thing to the whole

00:19:11,370 --> 00:19:15,240
whereas with CSP you you have to do the

00:19:14,280 --> 00:19:17,340
work yourself you have to write the

00:19:15,240 --> 00:19:21,870
while loop you have to kind of do all of

00:19:17,340 --> 00:19:24,360
the the plumbing there go into some pros

00:19:21,870 --> 00:19:25,830
and cons as I see him with callbacks as

00:19:24,360 --> 00:19:29,640
I've said before they're the least

00:19:25,830 --> 00:19:31,110
powerful but that can be a benefit there

00:19:29,640 --> 00:19:33,180
there are a number of places in our

00:19:31,110 --> 00:19:35,970
Android COBIT codebase where we are

00:19:33,180 --> 00:19:38,520
considering migrating from an observable

00:19:35,970 --> 00:19:40,200
to a callback removing a place where we

00:19:38,520 --> 00:19:41,730
thought oh you know observable is so

00:19:40,200 --> 00:19:45,450
powerful it'll give us all we want

00:19:41,730 --> 00:19:47,910
in fact it gave us more more mental

00:19:45,450 --> 00:19:49,830
overhead when all we needed was a simple

00:19:47,910 --> 00:19:53,490
callback so there are some trade-offs

00:19:49,830 --> 00:19:54,900
there but of course callbacks are very

00:19:53,490 --> 00:19:56,820
poor for coordinating between multiple

00:19:54,900 --> 00:19:59,780
things and you have all this distributed

00:19:56,820 --> 00:20:03,600
state and it's it's a nightmare

00:19:59,780 --> 00:20:05,430
promises pros are over callbacks s that

00:20:03,600 --> 00:20:09,000
they're caching and guarantee a single

00:20:05,430 --> 00:20:10,860
value and both of the cons are probably

00:20:09,000 --> 00:20:13,040
going away so it's likely than that in

00:20:10,860 --> 00:20:17,660
the future promises will be the go-to

00:20:13,040 --> 00:20:21,720
for single value single source

00:20:17,660 --> 00:20:24,930
asynchronous problems with observables

00:20:21,720 --> 00:20:27,210
I'm really impressed with all of the

00:20:24,930 --> 00:20:29,430
operators that you can do to a stream

00:20:27,210 --> 00:20:32,550
that the react effects people have done

00:20:29,430 --> 00:20:33,990
a lot of work to figure out what are the

00:20:32,550 --> 00:20:36,270
transformations that you might want to

00:20:33,990 --> 00:20:39,240
do there are I don't know about a

00:20:36,270 --> 00:20:41,760
hundred maybe more of things you can do

00:20:39,240 --> 00:20:43,620
to an observable and so most of the time

00:20:41,760 --> 00:20:45,360
when you're thinking oh if only I could

00:20:43,620 --> 00:20:48,030
do X you just have to look it up in the

00:20:45,360 --> 00:20:49,620
documentation and it works with many

00:20:48,030 --> 00:20:51,150
values you're thinking at a higher level

00:20:49,620 --> 00:20:55,380
and so it feels really elegant when

00:20:51,150 --> 00:20:57,990
you're making it but the the multitude

00:20:55,380 --> 00:21:00,770
of complex operators can also be a con

00:20:57,990 --> 00:21:03,240
where

00:21:00,770 --> 00:21:05,700
you have to memorize all these things

00:21:03,240 --> 00:21:07,320
and and there's just the upfront cost of

00:21:05,700 --> 00:21:10,590
learning what these operators do and

00:21:07,320 --> 00:21:13,920
especially how they interact I've seen a

00:21:10,590 --> 00:21:15,420
lot of bugs where we didn't expect this

00:21:13,920 --> 00:21:17,370
operator and this operator

00:21:15,420 --> 00:21:20,580
you know combining these two observables

00:21:17,370 --> 00:21:22,350
to do what it actually did and so that

00:21:20,580 --> 00:21:23,970
there can be some mismatch there between

00:21:22,350 --> 00:21:28,950
your mental model and what actually

00:21:23,970 --> 00:21:30,810
happens and observable zone the state of

00:21:28,950 --> 00:21:32,790
your kind of asynchronous state machine

00:21:30,810 --> 00:21:35,670
but they don't provide much insight into

00:21:32,790 --> 00:21:38,760
what's going on now Andres gonna talk

00:21:35,670 --> 00:21:40,020
tomorrow about visualizing your streams

00:21:38,760 --> 00:21:42,870
and so maybe that'll solve all my

00:21:40,020 --> 00:21:43,980
problems here but about a year and a

00:21:42,870 --> 00:21:46,110
half ago I got really excited about

00:21:43,980 --> 00:21:48,090
cycle j/s and all these observables and

00:21:46,110 --> 00:21:50,190
I wrote a little visualization library

00:21:48,090 --> 00:21:53,520
but I ran into some problems so I didn't

00:21:50,190 --> 00:21:54,900
continue but all the time when I'm

00:21:53,520 --> 00:21:57,240
working with observables I really wish

00:21:54,900 --> 00:22:02,610
if only I could see what's actually

00:21:57,240 --> 00:22:04,470
going on people talk about things being

00:22:02,610 --> 00:22:08,250
easy to reason about I think it started

00:22:04,470 --> 00:22:08,490
with react and when I say easy to reason

00:22:08,250 --> 00:22:12,060
about

00:22:08,490 --> 00:22:14,340
I mean how easily can a developer who's

00:22:12,060 --> 00:22:16,640
familiar with the tool but not with the

00:22:14,340 --> 00:22:19,140
project understand what's going on

00:22:16,640 --> 00:22:20,850
because a lot of things we see them and

00:22:19,140 --> 00:22:24,270
we think oh that's really complicated

00:22:20,850 --> 00:22:27,300
that's really unfamiliar that's probably

00:22:24,270 --> 00:22:28,680
very hard and the the only problem is

00:22:27,300 --> 00:22:32,280
you just haven't gotten familiar with

00:22:28,680 --> 00:22:34,320
the tech but what what stands out to me

00:22:32,280 --> 00:22:36,930
is when you have a group of people that

00:22:34,320 --> 00:22:38,970
are familiar with the tech and it's

00:22:36,930 --> 00:22:40,290
still difficult for them to understand

00:22:38,970 --> 00:22:42,690
what that's going on where there's

00:22:40,290 --> 00:22:44,400
there's probably something going on with

00:22:42,690 --> 00:22:49,230
the tech and maybe it's maybe it's dev

00:22:44,400 --> 00:22:51,270
tools but they're it's it's so difficult

00:22:49,230 --> 00:22:56,450
to coordinate streams especially when

00:22:51,270 --> 00:22:58,920
you're dealing with a stateful end

00:22:56,450 --> 00:23:01,320
product right where we're working with

00:22:58,920 --> 00:23:02,640
UI kit which is stateful and there are

00:23:01,320 --> 00:23:04,500
some guarantees that we would like to

00:23:02,640 --> 00:23:07,200
have about the order in which these

00:23:04,500 --> 00:23:08,610
asynchronous things happen that

00:23:07,200 --> 00:23:10,930
observables we did we just find

00:23:08,610 --> 00:23:13,510
ourselves fighting it

00:23:10,930 --> 00:23:15,250
and then the other part pragmatically is

00:23:13,510 --> 00:23:18,430
how hard is it to get to know the

00:23:15,250 --> 00:23:20,110
library if if that barrier is too large

00:23:18,430 --> 00:23:22,990
then new people coming out of your team

00:23:20,110 --> 00:23:25,810
are our Guinness waste a lot of time or

00:23:22,990 --> 00:23:27,570
spend a lot of time the speed and maybe

00:23:25,810 --> 00:23:33,190
that's not something you're ready to

00:23:27,570 --> 00:23:35,860
devote with with CSP like I said I

00:23:33,190 --> 00:23:38,320
haven't spent as much time on this but

00:23:35,860 --> 00:23:42,640
I'm as I look into it I'm I'm interested

00:23:38,320 --> 00:23:44,140
more and more in doing a trial run and

00:23:42,640 --> 00:23:47,490
maybe converting some of our observable

00:23:44,140 --> 00:23:50,050
stuff into CSP to see where it breaks

00:23:47,490 --> 00:23:53,100
but the pros that I see is that in

00:23:50,050 --> 00:23:56,560
normal code you write sequentially and

00:23:53,100 --> 00:23:58,570
CSP allows you to do that with your

00:23:56,560 --> 00:24:02,350
asynchronous stuff it's very similar to

00:23:58,570 --> 00:24:04,120
async await in that async await is is an

00:24:02,350 --> 00:24:08,470
easier syntax to work with than promises

00:24:04,120 --> 00:24:10,270
then callbacks and CSP allows you to do

00:24:08,470 --> 00:24:15,460
that for multiple values for these more

00:24:10,270 --> 00:24:17,440
complicated asynchronous situations so I

00:24:15,460 --> 00:24:20,680
put together this night chart for all of

00:24:17,440 --> 00:24:23,680
you it is deeply flawed and I tried to

00:24:20,680 --> 00:24:26,170
enumerate some of them but hopefully you

00:24:23,680 --> 00:24:28,660
can ruminate on this when you're you're

00:24:26,170 --> 00:24:33,850
thinking about okay I've got this thing

00:24:28,660 --> 00:24:36,180
it's asynchronous what do I use thank

00:24:33,850 --> 00:24:36,180
you very much

00:24:41,090 --> 00:24:49,370
awesome thank you let's look at the

00:24:45,890 --> 00:24:51,110
questions okay Redux saga I have not

00:24:49,370 --> 00:24:56,030
used it personally my understanding is

00:24:51,110 --> 00:24:57,290
it uses generators or async/await Redux

00:24:56,030 --> 00:24:59,060
saw Vega is the kind of thing that you

00:24:57,290 --> 00:25:03,770
would build on top of of one of these

00:24:59,060 --> 00:25:05,900
underlying primitives cancel tokens I am

00:25:03,770 --> 00:25:10,250
NOT gonna get into that there's a ton of

00:25:05,900 --> 00:25:14,330
politics ozz do you have some stickers I

00:25:10,250 --> 00:25:16,610
don't unfortunately sorry so which of

00:25:14,330 --> 00:25:24,440
the approaches do you use with react in

00:25:16,610 --> 00:25:26,600
Khan Academy we we haven't found any

00:25:24,440 --> 00:25:27,890
situations that are that are complicated

00:25:26,600 --> 00:25:29,870
enough where we have to coordinate

00:25:27,890 --> 00:25:32,330
between a lot of asynchronous things yet

00:25:29,870 --> 00:25:34,910
on the front end this is mostly a

00:25:32,330 --> 00:25:37,550
problem that we've run into in in our

00:25:34,910 --> 00:25:40,520
native apps what do you think of cycle

00:25:37,550 --> 00:25:41,720
das I think it's super cool I played

00:25:40,520 --> 00:25:44,450
around with it I tried to implement my

00:25:41,720 --> 00:25:45,860
own version and I think there's there's

00:25:44,450 --> 00:25:47,900
a lot of power in having everything

00:25:45,860 --> 00:25:50,330
defined in terms of observables when you

00:25:47,900 --> 00:25:51,350
don't have to interact with all of these

00:25:50,330 --> 00:25:54,500
stateful things and worry about

00:25:51,350 --> 00:25:56,150
coordination why would you use CSP and

00:25:54,500 --> 00:25:59,780
JavaScript while losing all guarantees

00:25:56,150 --> 00:26:01,190
from original CSP theory I would like to

00:25:59,780 --> 00:26:05,360
learn more about what you mean by that

00:26:01,190 --> 00:26:06,950
is deadlocking a real problem in the CSP

00:26:05,360 --> 00:26:10,580
way of handling a synchronous code yes

00:26:06,950 --> 00:26:11,840
so well I mean real problem is in it's

00:26:10,580 --> 00:26:16,220
possible to write code that deadlocks

00:26:11,840 --> 00:26:19,100
and but if if you are waiting on a

00:26:16,220 --> 00:26:21,860
channel that never produces a value then

00:26:19,100 --> 00:26:24,440
then you will die and so in many cases

00:26:21,860 --> 00:26:26,690
you want to include a timeout or other

00:26:24,440 --> 00:26:29,420
things but dead locking is is something

00:26:26,690 --> 00:26:30,860
that will happen whatever you do

00:26:29,420 --> 00:26:33,680
in terms of observables if you have a

00:26:30,860 --> 00:26:38,750
promise that never resolves that's you

00:26:33,680 --> 00:26:41,060
know a deadlock can you comment on

00:26:38,750 --> 00:26:43,400
aphrodite versus jss versus styled

00:26:41,060 --> 00:26:45,500
components yeah so Aphrodite is a

00:26:43,400 --> 00:26:48,410
library that we developed here at Khan

00:26:45,500 --> 00:26:50,600
Academy for doing JavaScript in your

00:26:48,410 --> 00:26:53,990
style sheets and I personally love it I

00:26:50,600 --> 00:26:59,120
use it in all of my personal projects

00:26:53,990 --> 00:27:02,390
and the Aphrodite was developed to

00:26:59,120 --> 00:27:06,200
address our needs right we need to

00:27:02,390 --> 00:27:09,260
server-side render and we want to have

00:27:06,200 --> 00:27:12,760
our Styles co-located but we also want

00:27:09,260 --> 00:27:16,279
to be able to use media queries and and

00:27:12,760 --> 00:27:21,200
hover in handle by CSS not handled by

00:27:16,279 --> 00:27:23,539
set state or JavaScript and so I I can't

00:27:21,200 --> 00:27:26,600
speak well enough to the other two but

00:27:23,539 --> 00:27:29,679
that's that's my take on Aphrodite what

00:27:26,600 --> 00:27:30,860
is your preferred way of handling async

00:27:29,679 --> 00:27:36,110
ie

00:27:30,860 --> 00:27:38,510
I go back and forth as soon as promises

00:27:36,110 --> 00:27:41,029
get the the property that they don't eat

00:27:38,510 --> 00:27:43,549
your errors and async/await is handled

00:27:41,029 --> 00:27:44,809
natively by at least the browser I use

00:27:43,549 --> 00:27:48,140
for development a single weight will

00:27:44,809 --> 00:27:50,720
probably be my go-to for most things but

00:27:48,140 --> 00:27:53,179
when you when you get to more

00:27:50,720 --> 00:27:54,919
complicated problems like coordinating

00:27:53,179 --> 00:27:57,020
between many asynchronous streams that

00:27:54,919 --> 00:28:00,860
have multiple values then go for

00:27:57,020 --> 00:28:03,140
observables or CSP I already answered

00:28:00,860 --> 00:28:05,179
cycled yes what can you say about

00:28:03,140 --> 00:28:14,690
working with async things specifically

00:28:05,179 --> 00:28:18,409
in react it I think this falls under the

00:28:14,690 --> 00:28:19,940
the question about doing doing work and

00:28:18,409 --> 00:28:23,500
react versus doing work in plain

00:28:19,940 --> 00:28:26,240
JavaScript I'll that there are a lot of

00:28:23,500 --> 00:28:28,220
headaches and bugs that come out of

00:28:26,240 --> 00:28:30,860
trying to do too much work in your in

00:28:28,220 --> 00:28:33,649
your react components react components

00:28:30,860 --> 00:28:37,250
by and large should not have complex

00:28:33,649 --> 00:28:38,899
logic in it um as far as testing you

00:28:37,250 --> 00:28:40,340
react components most of the time when

00:28:38,899 --> 00:28:42,049
you think oh this is this is getting

00:28:40,340 --> 00:28:43,159
complicated I should test it actually

00:28:42,049 --> 00:28:45,799
what you should do is tear out the logic

00:28:43,159 --> 00:28:47,330
put it in a pure function or in in some

00:28:45,799 --> 00:28:48,890
kind of plain JavaScript function and

00:28:47,330 --> 00:28:51,140
then test it there and I think the same

00:28:48,890 --> 00:28:53,179
applies for asynchronous code you want

00:28:51,140 --> 00:28:54,380
to be able to test that very well and it

00:28:53,179 --> 00:28:56,830
should not be tied into your rack

00:28:54,380 --> 00:28:56,830
components

00:28:57,390 --> 00:29:03,930
it's not easy to test CSP code with

00:29:00,670 --> 00:29:06,430
branches and asynchronous operations I

00:29:03,930 --> 00:29:12,040
think it is not easy to test

00:29:06,430 --> 00:29:14,830
asynchronous code in general I would I

00:29:12,040 --> 00:29:17,260
would be surprised if CSP were harder to

00:29:14,830 --> 00:29:21,070
test than observables I think it's it's

00:29:17,260 --> 00:29:22,630
just a difficult problem in general what

00:29:21,070 --> 00:29:25,090
about testability just talked about that

00:29:22,630 --> 00:29:28,690
wine native node modules do I still have

00:29:25,090 --> 00:29:31,810
time last 25 seconds okay

00:29:28,690 --> 00:29:33,970
why native node modules still don't use

00:29:31,810 --> 00:29:37,780
callbacks when there is native so they

00:29:33,970 --> 00:29:39,190
probably meant promises and I'm sure

00:29:37,780 --> 00:29:44,290
that is just a backwards compatibility

00:29:39,190 --> 00:29:47,320
thing and in general the the native

00:29:44,290 --> 00:29:48,790
hooks into whatever native land you have

00:29:47,320 --> 00:29:50,020
will just use callbacks because they are

00:29:48,790 --> 00:29:52,210
the simplest they're the least

00:29:50,020 --> 00:29:54,000
opinionated all of these are the things

00:29:52,210 --> 00:29:56,680
can interact with callbacks seamlessly

00:29:54,000 --> 00:29:59,440
but if if they chose promises or if they

00:29:56,680 --> 00:30:00,850
chose streams then you'd have problems

00:29:59,440 --> 00:30:01,650
if you wanted to expose an API that was

00:30:00,850 --> 00:30:05,760
different

00:30:01,650 --> 00:30:05,760

YouTube URL: https://www.youtube.com/watch?v=FSJEbFhjPHk


