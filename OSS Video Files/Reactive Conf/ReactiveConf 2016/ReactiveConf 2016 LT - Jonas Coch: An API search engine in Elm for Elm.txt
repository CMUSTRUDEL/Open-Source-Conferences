Title: ReactiveConf 2016 LT - Jonas Coch: An API search engine in Elm for Elm
Publication date: 2016-11-24
Playlist: ReactiveConf 2016
Description: 
	https://reactiveconf.com 

Meet those driving the change! World-renowned mobile and web innovators got together for three days in one town.

ReactiveConf, October 26 - 28 2016, Bratislava, Slovakia

For inspiration, look at one of the most-starred Lightning Talks proposals for ReactiveConf 2016.

---

Jonas Coch: An API search engine in Elm for Elm

Elm is a statically typed functional language that compiles to JavaScript. It’s well-known for its developer experience: the compiler provides nice error messages, the package system enforces semantic versioning for all published packages and makes sure every exposed value or type has some documentation and type annotations.

Elm-search builds on these nice properties and provides a search engine for all exposed values in the latest versions of all published packages. One can either search by name or by approximate type annotation. It’s like a basic Hoogle for Elm. In this talk I’ll show how the indexing and searching works, how Elm made it nice to develop and how the search can assist developers in their work.

https://gist.github.com/klaftertief/dc355759b9716516f46b861512936d60

---

Do you see yourself on the ReactiveConf stage? Do you want to become the next #ReactJS superstar? If you think you have a great idea everybody in the community should know about, join Lightning Talks, and share the spotlight with the best React experts at ReactiveConf next year!

All you need to do to become a part of them is to submit your proposal to Gist and leave the rest to the community.

The ten most-starred proposals will join our line-up, and the top three ones will get a free ReactiveConf ticket with an invitation to an exclusive dinner with our speakers and VIP guests.

Have you heard about ReactiveConf? According to tech superstars such as David Nolen, Richard Feldman, or Brent Vatne, it’s the best conference on web and mobile app development! It focuses on all things React and beyond and takes place annually in Bratislava, Slovakia.

In 2016, more than 700 attendees from all over the world spent three days in Bratislava getting inspired, sharing amazing new ideas, and meeting more than 30 awesome speakers from companies such as Google, Cognitect, NoRedInk, RethinkDB, Airbnb, Microsoft, Facebook, and the list could go on forever.

If you want to be part of the next event, get your tickets now at https://reactiveconf.com, and React with us!
Captions: 
	00:00:04,509 --> 00:00:09,250
hi my name is jewel osco Richard showed

00:00:07,240 --> 00:00:11,019
us a couple of minutes ago how to be

00:00:09,250 --> 00:00:13,809
productive in EM I'm going to show you

00:00:11,019 --> 00:00:15,910
how my extra first complete inept it's

00:00:13,809 --> 00:00:17,710
got em search the search engine that

00:00:15,910 --> 00:00:20,320
science exposed functions of all

00:00:17,710 --> 00:00:22,150
published and packages by approximate

00:00:20,320 --> 00:00:23,410
I'd signature I've developed developed

00:00:22,150 --> 00:00:24,699
it to learn the language itself the

00:00:23,410 --> 00:00:26,380
trolling around it and also some

00:00:24,699 --> 00:00:29,410
concepts of functional programming in

00:00:26,380 --> 00:00:31,000
January the aims not only hung her

00:00:29,410 --> 00:00:33,190
language to programming it also focuses

00:00:31,000 --> 00:00:34,899
on a nice developer experience that also

00:00:33,190 --> 00:00:37,569
manifests itself in how it tended

00:00:34,899 --> 00:00:39,699
packages as the search works on

00:00:37,569 --> 00:00:40,809
published packages at khajuraho m Peggy

00:00:39,699 --> 00:00:42,699
just look like how they are published

00:00:40,809 --> 00:00:45,460
and then how I am surg is great about

00:00:42,699 --> 00:00:47,379
the sedation the aim of us but when you

00:00:45,460 --> 00:00:49,839
add encode you mainly declare new types

00:00:47,379 --> 00:00:51,519
or use existing ones and you write

00:00:49,839 --> 00:00:53,139
functions that work on those types by

00:00:51,519 --> 00:00:55,479
accepting some arguments of returning

00:00:53,139 --> 00:00:57,789
value might be a little hard to quickly

00:00:55,479 --> 00:01:00,280
see what this function here does so you

00:00:57,789 --> 00:01:03,129
should add type annotation to clearly

00:01:00,280 --> 00:01:06,040
document the intent of the code m also

00:01:03,129 --> 00:01:07,420
has special documentation comments those

00:01:06,040 --> 00:01:09,520
are important when you want to publish a

00:01:07,420 --> 00:01:10,690
package to the package catalog as to

00:01:09,520 --> 00:01:12,250
truly make sure that all public

00:01:10,690 --> 00:01:15,700
functions are document are documented

00:01:12,250 --> 00:01:17,590
type annotated the same is also true for

00:01:15,700 --> 00:01:19,780
modulates every function lives on a

00:01:17,590 --> 00:01:21,520
modular model just the end source fired

00:01:19,780 --> 00:01:23,500
the contacts types and functions that

00:01:21,520 --> 00:01:26,470
belong together by some logical meaning

00:01:23,500 --> 00:01:28,920
one chod explicitly exposed types and

00:01:26,470 --> 00:01:32,170
values to define / moderate public a guy

00:01:28,920 --> 00:01:34,540
modules are then bonded as a pet as a

00:01:32,170 --> 00:01:37,180
package package there gets declared in

00:01:34,540 --> 00:01:40,720
an ad packages on fire exposed modules

00:01:37,180 --> 00:01:42,940
need to be explicitly declared so what

00:01:40,720 --> 00:01:45,220
happens to those packages packages

00:01:42,940 --> 00:01:47,140
uploaded to the package catalog with the

00:01:45,220 --> 00:01:48,610
nphc right make sure that exposed

00:01:47,140 --> 00:01:49,900
functions and modules are properly

00:01:48,610 --> 00:01:52,690
documented and that the version number

00:01:49,900 --> 00:01:54,760
Six's of semantic versioning words all

00:01:52,690 --> 00:01:56,470
the recommendations and type annotations

00:01:54,760 --> 00:01:59,050
gets written into a documentation oh

00:01:56,470 --> 00:02:01,240
jazel tay and the package catalog uses

00:01:59,050 --> 00:02:03,760
this jason to Bridget's documentation

00:02:01,240 --> 00:02:06,150
pages those look like this for the maybe

00:02:03,760 --> 00:02:08,560
module from Davis and crew and

00:02:06,150 --> 00:02:11,560
specifically like this for the map

00:02:08,560 --> 00:02:13,900
function the type annotation there

00:02:11,560 --> 00:02:14,560
contains links to the content types and

00:02:13,900 --> 00:02:16,959
the

00:02:14,560 --> 00:02:19,720
of the documentation comments they get

00:02:16,959 --> 00:02:21,970
some from from Markham into HTML the

00:02:19,720 --> 00:02:23,980
documentation Jason it reads contains a

00:02:21,970 --> 00:02:26,080
list of all exposed types and values who

00:02:23,980 --> 00:02:28,870
promote your the name type invitation

00:02:26,080 --> 00:02:30,550
and documentation comments of exposed

00:02:28,870 --> 00:02:32,680
functions are directly accessibility as

00:02:30,550 --> 00:02:34,420
feeds on an object and this jason is

00:02:32,680 --> 00:02:37,390
publicly available for each version of

00:02:34,420 --> 00:02:39,819
published packages so how does handlers

00:02:37,390 --> 00:02:41,709
so how does answer choose the existing

00:02:39,819 --> 00:02:43,840
package in fact on how does it work it

00:02:41,709 --> 00:02:45,190
downloads all the quotations as part of

00:02:43,840 --> 00:02:47,260
the latest published packages and

00:02:45,190 --> 00:02:49,150
creates one big combined index that you

00:02:47,260 --> 00:02:51,549
kill you on each big at the moment they

00:02:49,150 --> 00:02:54,190
are around 15,000 exposed functions in

00:02:51,549 --> 00:02:56,110
the index then it passes the type

00:02:54,190 --> 00:02:57,610
annotation swings into a custom type to

00:02:56,110 --> 00:02:59,080
some nights you speculate data the

00:02:57,610 --> 00:03:01,150
search can grow up on and it has a

00:02:59,080 --> 00:03:04,209
decent function that compares to type

00:03:01,150 --> 00:03:07,090
values by assigning and we're ready to

00:03:04,209 --> 00:03:09,670
the comparison the type definition and

00:03:07,090 --> 00:03:11,319
the pas de are direct are taken from the

00:03:09,670 --> 00:03:12,760
source code of the end package website

00:03:11,319 --> 00:03:15,010
so i did not only get the deputation

00:03:12,760 --> 00:03:17,410
data basically for free but also a great

00:03:15,010 --> 00:03:18,880
bit of code a type can either be a

00:03:17,410 --> 00:03:20,980
function with the list of arguments and

00:03:18,880 --> 00:03:22,690
return value type variable this is a

00:03:20,980 --> 00:03:25,900
placeholder for some specific type a

00:03:22,690 --> 00:03:29,170
type constructor a typo or record the

00:03:25,900 --> 00:03:32,980
type type is recursive so text can old

00:03:29,170 --> 00:03:34,810
other types and yeah this the type has a

00:03:32,980 --> 00:03:39,220
just that takes an education string and

00:03:34,810 --> 00:03:41,260
returns on every side so the distance

00:03:39,220 --> 00:03:43,720
hunter now is basically the only thing I

00:03:41,260 --> 00:03:45,940
have to come up with on my own it pay

00:03:43,720 --> 00:03:47,920
damages on the true past itit looks at

00:03:45,940 --> 00:03:49,840
interesting comparisons and simple

00:03:47,920 --> 00:03:52,660
comparisons it just calculated in a big

00:03:49,840 --> 00:03:54,700
knob a numerical value and when the past

00:03:52,660 --> 00:03:57,100
eyebrows are recursively save

00:03:54,700 --> 00:03:58,750
qualitative recursively and run then

00:03:57,100 --> 00:04:00,280
returns the mean of the different steps

00:03:58,750 --> 00:04:03,160
to get a normalized distance between

00:04:00,280 --> 00:04:07,180
zero and run so interesting comparisons

00:04:03,160 --> 00:04:10,000
include functions so the list comparison

00:04:07,180 --> 00:04:13,150
of the arguments the order there is not

00:04:10,000 --> 00:04:14,579
important and the comparison of the turn

00:04:13,150 --> 00:04:16,690
values are handled separately

00:04:14,579 --> 00:04:19,239
interesting comparisons also includes

00:04:16,690 --> 00:04:21,280
matching herbs and 20 type classes two

00:04:19,239 --> 00:04:22,170
types implementing those classes so for

00:04:21,280 --> 00:04:24,810
example

00:04:22,170 --> 00:04:27,240
about to a float on int or matching

00:04:24,810 --> 00:04:32,670
types with a special web counterparts

00:04:27,240 --> 00:04:36,810
like a or maybe a or reside a so in the

00:04:32,670 --> 00:04:39,420
list distance this simplified version

00:04:36,810 --> 00:04:41,130
the actual implementation check the list

00:04:39,420 --> 00:04:42,480
have similar length and make sure that

00:04:41,130 --> 00:04:44,280
the order of the lists are not important

00:04:42,480 --> 00:04:45,630
it basically works by applying the

00:04:44,280 --> 00:04:47,670
distance function to each pass some of

00:04:45,630 --> 00:04:50,460
the values up and calculate the mean so

00:04:47,670 --> 00:04:52,410
this is how the search looks like the

00:04:50,460 --> 00:04:54,360
app kennisha you load the file index p

00:04:52,410 --> 00:04:57,330
passes all the contact type annotations

00:04:54,360 --> 00:04:59,460
keeping those memory and then passes the

00:04:57,330 --> 00:05:02,640
search import compares each type of the

00:04:59,460 --> 00:05:07,470
existent type and shows search of the

00:05:02,640 --> 00:05:09,560
search result that's basically it thank

00:05:07,470 --> 00:05:09,560

YouTube URL: https://www.youtube.com/watch?v=OVlEEm_la8g


