Title: ReactiveConf 2016 - Michel Weststrate: Immer-mutable state management
Publication date: 2016-11-24
Playlist: ReactiveConf 2016
Description: 
	https://reactiveconf.com 

Meet those driving the change! World-renowned mobile and web innovators got together for three days in one town.

ReactiveConf, October 26 - 28 2016, Bratislava, Slovakia

---
Michel Weststrate: Immer-mutable state management

Mutable or immutable based state management. That is the question. But what if we could have both? In this talk we will explore an opinionated state container that serves both worlds. A single coin with two different sides. Mutable properties, instance methods, immutable trees, structural sharing, replay-able actions, time travelling, derived values, patches.. etc. This what next-gen state management might look like.

---

Have you heard about ReactiveConf? According to tech superstars such as David Nolen, Richard Feldman, or Brent Vatne, itâ€™s the best conference on web and mobile app development! It focuses on all things React and beyond and takes place annually in Bratislava, Slovakia.

In 2016, more than 700 attendees from all over the world spent three days in Bratislava getting inspired, sharing amazing new ideas, and meeting more than 30 awesome speakers from companies such as Google, Cognitect, NoRedInk, RethinkDB, Airbnb, Microsoft, Facebook, and the list could go on forever.

If you want to be part of the next event, get your tickets now at https://reactiveconf.com, and React with us!
Captions: 
	00:00:05,040 --> 00:00:13,230
hi everyone welcome to the quest for M

00:00:08,850 --> 00:00:16,199
immutable data and emerge here is the

00:00:13,230 --> 00:00:19,380
contraction of the German Emmer which

00:00:16,199 --> 00:00:22,439
stands for always and amused the world

00:00:19,380 --> 00:00:26,150
like never so that sounds like a

00:00:22,439 --> 00:00:28,499
contradiction but maybe it isn't but

00:00:26,150 --> 00:00:32,070
first of all very important

00:00:28,499 --> 00:00:34,770
I brought stickers even in two flavors

00:00:32,070 --> 00:00:36,960
so now we're raining down so you can you

00:00:34,770 --> 00:00:42,300
get them why not when there's a break or

00:00:36,960 --> 00:00:47,219
something so over a year ago I figured

00:00:42,300 --> 00:00:52,140
that developers are too smart also

00:00:47,219 --> 00:00:55,800
they're too expensive to have them do

00:00:52,140 --> 00:00:58,410
stupid administrative tasks I mean if

00:00:55,800 --> 00:01:00,420
you try to order a keyboard keyboard and

00:00:58,410 --> 00:01:02,910
you have to fill in an Excel form

00:01:00,420 --> 00:01:08,070
probably you will be a mer to developer

00:01:02,910 --> 00:01:10,200
right we don't like it so thinks it can

00:01:08,070 --> 00:01:13,910
be done better by computers should be

00:01:10,200 --> 00:01:19,200
done by computers and so we're always

00:01:13,910 --> 00:01:22,800
striving for automating our tasks so a

00:01:19,200 --> 00:01:25,080
few examples in the past we did for many

00:01:22,800 --> 00:01:28,350
Oh releases and this will say cumbersome

00:01:25,080 --> 00:01:30,930
task and we figured well servers can do

00:01:28,350 --> 00:01:34,130
that as well so we moved to continuous

00:01:30,930 --> 00:01:36,810
deployment also we figured that

00:01:34,130 --> 00:01:39,690
manipulating the Dom it's a tiresome

00:01:36,810 --> 00:01:43,050
task and that's having components and

00:01:39,690 --> 00:01:47,340
facial Dom that powers it is a way more

00:01:43,050 --> 00:01:52,050
powerful abstraction the same hell holds

00:01:47,340 --> 00:01:55,740
for data flow there we can have the same

00:01:52,050 --> 00:01:59,340
gains instead of mainly pushing our data

00:01:55,740 --> 00:02:01,530
around your applications we can just use

00:01:59,340 --> 00:02:06,030
transparent check programming and have

00:02:01,530 --> 00:02:09,090
it all working for us and also everybody

00:02:06,030 --> 00:02:12,160
is there yet but I think this is what

00:02:09,090 --> 00:02:15,460
you will appreciate at some time

00:02:12,160 --> 00:02:19,660
so what was the idea of Mobius when I

00:02:15,460 --> 00:02:23,140
presented it a year ago so say you have

00:02:19,660 --> 00:02:26,950
some data in this case representing me

00:02:23,140 --> 00:02:30,640
and I have some components that renders

00:02:26,950 --> 00:02:34,090
my name and then I use react to put it

00:02:30,640 --> 00:02:38,560
into the dome then from that point on

00:02:34,090 --> 00:02:56,110
I'm no longer interested and if I change

00:02:38,560 --> 00:02:58,690
this data a to Larry oh thanks so that

00:02:56,110 --> 00:03:02,020
point will no longer interested in

00:02:58,690 --> 00:03:05,170
thinking about how should we propagate

00:03:02,020 --> 00:03:06,820
these changes to our dome how do you

00:03:05,170 --> 00:03:09,910
make sure that the right data is

00:03:06,820 --> 00:03:13,480
rendered and so that is what's no big

00:03:09,910 --> 00:03:16,720
fuss basically what you do is you say

00:03:13,480 --> 00:03:19,270
this data is observable so I said it's

00:03:16,720 --> 00:03:21,910
still the same and a component you

00:03:19,270 --> 00:03:24,220
declare it as being observer of the data

00:03:21,910 --> 00:03:28,270
at that point what makes we'll figure

00:03:24,220 --> 00:03:30,550
out what is needed to be observed so if

00:03:28,270 --> 00:03:32,170
you then change the person's name the

00:03:30,550 --> 00:03:35,800
component to render but if I change

00:03:32,170 --> 00:03:38,050
their age it won't so it's very

00:03:35,800 --> 00:03:39,910
optimized and you don't have to write a

00:03:38,050 --> 00:03:45,820
should component today it's ever to

00:03:39,910 --> 00:03:49,860
achieve that so they've told you that

00:03:45,820 --> 00:03:53,550
the view is a function of the state and

00:03:49,860 --> 00:03:56,470
it's true but I'm not satisfied by that

00:03:53,550 --> 00:03:59,709
actually what I want is that the view is

00:03:56,470 --> 00:04:01,890
a transformation of my state and not

00:03:59,709 --> 00:04:04,540
just a transformation a live

00:04:01,890 --> 00:04:07,090
transformation if it's just a function

00:04:04,540 --> 00:04:12,790
I'm still responsible of invoking that

00:04:07,090 --> 00:04:15,630
function so what happened next is quite

00:04:12,790 --> 00:04:19,150
amazing Moe Biggs became quite popular

00:04:15,630 --> 00:04:21,160
prior to my surprise and it even became

00:04:19,150 --> 00:04:23,260
the second most popular state

00:04:21,160 --> 00:04:28,570
management's library and the recent

00:04:23,260 --> 00:04:31,750
survey on the JavaScript world so how

00:04:28,570 --> 00:04:34,120
did people response to more Biggs well

00:04:31,750 --> 00:04:36,760
quite differently so people are really

00:04:34,120 --> 00:04:39,940
in Jessica because it's so simple and

00:04:36,760 --> 00:04:42,340
fast both performance wise and speed in

00:04:39,940 --> 00:04:45,700
which you can adds new features and

00:04:42,340 --> 00:04:48,669
implement and on average when people

00:04:45,700 --> 00:04:52,720
migrate to move X they usually use lose

00:04:48,669 --> 00:04:54,370
about 30% of their code so then there

00:04:52,720 --> 00:04:58,180
are a lot of poor requests that look

00:04:54,370 --> 00:05:01,450
like this but our people are more

00:04:58,180 --> 00:05:06,310
concerned say oh it's a lot of magic

00:05:01,450 --> 00:05:08,860
which is happening here but well that is

00:05:06,310 --> 00:05:10,600
the price we pay for objection we see

00:05:08,860 --> 00:05:13,180
the same when we use react I mean we

00:05:10,600 --> 00:05:15,150
don't care how the virtual Dom works as

00:05:13,180 --> 00:05:18,789
long as the semantics are clear and

00:05:15,150 --> 00:05:20,800
maybe we now still understand artificial

00:05:18,789 --> 00:05:22,840
dumb works but that time will be gone

00:05:20,800 --> 00:05:24,820
once there will be fibers in there and

00:05:22,840 --> 00:05:27,520
then we won't have any clue anymore how

00:05:24,820 --> 00:05:31,690
it works but if it's heaps of semantics

00:05:27,520 --> 00:05:33,789
we don't care a lot of people are happy

00:05:31,690 --> 00:05:35,620
about no base because it's been open yet

00:05:33,789 --> 00:05:37,960
it's on how you structure your data

00:05:35,620 --> 00:05:41,620
I will strict your stores buy your store

00:05:37,960 --> 00:05:43,690
stuff but for the same reason the maples

00:05:41,620 --> 00:05:45,669
are not be happy about it because it

00:05:43,690 --> 00:05:48,850
doesn't tell you how to build

00:05:45,669 --> 00:05:50,909
applications it just manages data flows

00:05:48,850 --> 00:05:53,199
for you

00:05:50,909 --> 00:05:55,599
and some people are happy that I choose

00:05:53,199 --> 00:05:57,539
immutable data because fix our mental

00:05:55,599 --> 00:06:00,899
model and it's easy to work with

00:05:57,539 --> 00:06:04,059
everybody is comfortable and using it

00:06:00,899 --> 00:06:06,969
but on the other hand people are sad

00:06:04,059 --> 00:06:08,529
because it uses immutable data and there

00:06:06,969 --> 00:06:13,169
are very interesting and medical

00:06:08,529 --> 00:06:17,649
properties of using immutable data so

00:06:13,169 --> 00:06:21,129
immutable data or mutable data or maybe

00:06:17,649 --> 00:06:25,419
to make it more who creates Peters or

00:06:21,129 --> 00:06:29,379
Mobile's or more important question Elsa

00:06:25,419 --> 00:06:31,300
or Anna now you might be wondering how

00:06:29,379 --> 00:06:34,839
this relates to the previous question

00:06:31,300 --> 00:06:38,259
but I have two small daughters one of

00:06:34,839 --> 00:06:40,719
three ml of x5 so this is a question I

00:06:38,259 --> 00:06:46,479
hear the most so I have to answer this

00:06:40,719 --> 00:06:51,099
one first so Anna is a very well

00:06:46,479 --> 00:06:52,689
controlled girl she likes protocols she

00:06:51,099 --> 00:06:55,029
she knows to have things in a

00:06:52,689 --> 00:06:58,179
predictable way and what is really cool

00:06:55,029 --> 00:07:02,439
she can freeze things in time it's

00:06:58,179 --> 00:07:07,569
really awesome and now on your heads

00:07:02,439 --> 00:07:10,740
she's very agile and she loves to run

00:07:07,569 --> 00:07:15,999
through things and do things quickly and

00:07:10,740 --> 00:07:17,079
most of all she hates her mone I hope

00:07:15,999 --> 00:07:18,939
are you were reading the slides not

00:07:17,079 --> 00:07:21,269
listening to what I was telling doesn't

00:07:18,939 --> 00:07:24,339
make any sense

00:07:21,269 --> 00:07:26,949
but how do you choose between those two

00:07:24,339 --> 00:07:28,989
that's a difficult question and I cannot

00:07:26,949 --> 00:07:31,779
answer that question at least not from a

00:07:28,989 --> 00:07:34,329
neutral point of view but I think the

00:07:31,779 --> 00:07:38,919
benefits of each approaches have a

00:07:34,329 --> 00:07:40,839
different ways in each project so but

00:07:38,919 --> 00:07:43,329
actually is more hand pressing than

00:07:40,839 --> 00:07:46,559
answering the question is looking a bit

00:07:43,329 --> 00:07:49,719
deeper what are the driving principles

00:07:46,559 --> 00:07:55,479
behind those two seemingly opposite

00:07:49,719 --> 00:07:58,689
approaches to redux is all about

00:07:55,479 --> 00:08:00,459
predictability and how does it provide

00:07:58,689 --> 00:08:02,860
predictability that provides

00:08:00,459 --> 00:08:03,970
transactional states at any moment in

00:08:02,860 --> 00:08:05,680
time you have your States

00:08:03,970 --> 00:08:07,870
you have the actions which have been

00:08:05,680 --> 00:08:10,180
played on to that state actually can

00:08:07,870 --> 00:08:15,360
always reproduce and see what it's going

00:08:10,180 --> 00:08:19,480
on the other hand mo Biggs is more about

00:08:15,360 --> 00:08:23,470
finding your state in a very confined

00:08:19,480 --> 00:08:27,160
minimal way and try to derive as much

00:08:23,470 --> 00:08:29,910
from this as is possible we want to be

00:08:27,160 --> 00:08:33,520
reasoning just in terms of our state and

00:08:29,910 --> 00:08:37,659
changes that are made to it and we don't

00:08:33,520 --> 00:08:38,919
want to be reasoning and like components

00:08:37,659 --> 00:08:43,360
what's happening there they should be

00:08:38,919 --> 00:08:44,860
just derived and those principles which

00:08:43,360 --> 00:08:47,770
is very interesting they are not

00:08:44,860 --> 00:08:53,080
conflicting they are just talking about

00:08:47,770 --> 00:08:56,700
another part of your data flow so it's

00:08:53,080 --> 00:08:59,830
basically the quest for a lot of cores

00:08:56,700 --> 00:09:02,410
so this quality might feel like I earned

00:08:59,830 --> 00:09:10,450
those two opposite things then they move

00:09:02,410 --> 00:09:13,960
in two directions the last year I showed

00:09:10,450 --> 00:09:16,030
you this demo where you can have boxers

00:09:13,960 --> 00:09:19,180
being dragged around and what makes make

00:09:16,030 --> 00:09:20,860
sure that the arrows stay at Estill box

00:09:19,180 --> 00:09:24,660
because the arrows are just draft from

00:09:20,860 --> 00:09:29,470
the state and it also had time traveling

00:09:24,660 --> 00:09:35,380
so you could go back and go forth in

00:09:29,470 --> 00:09:38,080
time so how did that work actually it

00:09:35,380 --> 00:09:41,470
was pretty simple it just takes the

00:09:38,080 --> 00:09:44,470
store she lies it to some JSON object

00:09:41,470 --> 00:09:46,110
and pushes that onto our list where for

00:09:44,470 --> 00:09:49,870
all the states we have and then we can

00:09:46,110 --> 00:09:54,250
this realize it again to have to be back

00:09:49,870 --> 00:09:55,870
at a previous state and it is and

00:09:54,250 --> 00:09:57,940
because you put a mobile auto room

00:09:55,870 --> 00:10:00,210
around it and make sure that whenever

00:09:57,940 --> 00:10:04,089
something relevant in the state exchange

00:10:00,210 --> 00:10:05,860
distinction or an again and you will

00:10:04,089 --> 00:10:07,540
recognize this pattern this is the same

00:10:05,860 --> 00:10:11,110
pattern as what we did with our

00:10:07,540 --> 00:10:12,910
components components our function let's

00:10:11,110 --> 00:10:15,459
transform the state

00:10:12,910 --> 00:10:17,769
in two components and this realization

00:10:15,459 --> 00:10:20,470
is just a function that transforms the

00:10:17,769 --> 00:10:24,100
state into some JSON structure but the

00:10:20,470 --> 00:10:26,079
principle is the same so a snapshot

00:10:24,100 --> 00:10:30,190
that's basically a live with information

00:10:26,079 --> 00:10:34,899
of our state however there are some

00:10:30,190 --> 00:10:36,579
problems with this first of all of X

00:10:34,899 --> 00:10:38,709
because it doesn't make any assumptions

00:10:36,579 --> 00:10:41,500
on how you structure your state cannot

00:10:38,709 --> 00:10:44,290
provide a standardized chile's ation

00:10:41,500 --> 00:10:46,300
function maybe you are closer you are

00:10:44,290 --> 00:10:52,120
using classes and deserializing classes

00:10:46,300 --> 00:10:54,569
is a hard problem also realizing your

00:10:52,120 --> 00:10:58,060
entire state is a very expensive process

00:10:54,569 --> 00:11:02,079
basically your deep cloning all of your

00:10:58,060 --> 00:11:04,149
states and also it uses lots of memory

00:11:02,079 --> 00:11:06,910
because every time you get this fresh

00:11:04,149 --> 00:11:09,279
deep Club there's no structural sharing

00:11:06,910 --> 00:11:11,500
so you have an entire new copy all of

00:11:09,279 --> 00:11:14,829
your state so it's not really feasible

00:11:11,500 --> 00:11:18,810
this approach however there are

00:11:14,829 --> 00:11:22,569
solutions to this problem first of all

00:11:18,810 --> 00:11:25,959
what if we constrain ourselves to using

00:11:22,569 --> 00:11:27,970
trees serializing trees is

00:11:25,959 --> 00:11:32,560
straightforward we know how to do that

00:11:27,970 --> 00:11:35,500
and secondly as I just told you a

00:11:32,560 --> 00:11:40,120
snapshot is just a derived failure from

00:11:35,500 --> 00:11:42,430
your state and rendering a tree web

00:11:40,120 --> 00:11:44,500
structural sharing let's approve me over

00:11:42,430 --> 00:11:47,170
already solved that's what we did for

00:11:44,500 --> 00:11:49,480
components I figure under components and

00:11:47,170 --> 00:11:51,220
some state changes only there are

00:11:49,480 --> 00:11:53,439
components affected by this change

00:11:51,220 --> 00:11:56,110
re-rendered and the others are kept as

00:11:53,439 --> 00:12:02,110
ifs so what if we could do the same for

00:11:56,110 --> 00:12:04,300
our Jason tree so let's talk a bit about

00:12:02,110 --> 00:12:08,620
how objects computed failures work and

00:12:04,300 --> 00:12:11,740
what's special about them so here is a

00:12:08,620 --> 00:12:14,529
very basic person class and it has a

00:12:11,740 --> 00:12:18,370
pool name I get there would also be a

00:12:14,529 --> 00:12:22,440
function and it just realizes the

00:12:18,370 --> 00:12:24,720
current state into an array

00:12:22,440 --> 00:12:27,420
tricky thing of course is if it's time

00:12:24,720 --> 00:12:30,000
this getter is accessed it's large

00:12:27,420 --> 00:12:32,930
picture and you get a fresh array so

00:12:30,000 --> 00:12:37,100
even although this arrays are structural

00:12:32,930 --> 00:12:39,390
equivalents there are different arrays

00:12:37,100 --> 00:12:41,580
so what you see as we change the

00:12:39,390 --> 00:12:44,850
person's name and then we lock the full

00:12:41,580 --> 00:12:48,150
name twice it will print calculating the

00:12:44,850 --> 00:12:50,340
full name twice that's because we are

00:12:48,150 --> 00:12:54,570
pooling all the values through our

00:12:50,340 --> 00:12:56,730
system other observables regulate the

00:12:54,570 --> 00:13:00,630
railroads they change pool based

00:12:56,730 --> 00:13:02,250
dataflow to push based data flow so if

00:13:00,630 --> 00:13:04,500
you have observable properties and a

00:13:02,250 --> 00:13:07,980
computed value that combines those

00:13:04,500 --> 00:13:10,860
values and if you then change the name

00:13:07,980 --> 00:13:13,410
at that exact moment in time Ettore

00:13:10,860 --> 00:13:14,580
computes the full name because it

00:13:13,410 --> 00:13:17,730
notifies the full name

00:13:14,580 --> 00:13:20,580
hey this data has changed but after that

00:13:17,730 --> 00:13:23,280
if we request for the value of this full

00:13:20,580 --> 00:13:25,860
name we can get the same value back it's

00:13:23,280 --> 00:13:28,080
time because we know that the backing

00:13:25,860 --> 00:13:30,540
data of the computed value then change

00:13:28,080 --> 00:13:33,570
we know that products knows that it can

00:13:30,540 --> 00:13:35,460
just return the same value so what

00:13:33,570 --> 00:13:38,370
actually is happening here on a very

00:13:35,460 --> 00:13:43,230
small scale is that we have virtual

00:13:38,370 --> 00:13:45,510
sharing of the time so when we take a

00:13:43,230 --> 00:13:47,940
principle and we have some clouds

00:13:45,510 --> 00:13:50,280
representing it to do we can just

00:13:47,940 --> 00:13:53,370
introduce a computed value which gives

00:13:50,280 --> 00:13:57,390
the reputation of this class as a

00:13:53,370 --> 00:13:59,850
playing JavaScript object and the output

00:13:57,390 --> 00:14:01,740
of this function will not change unless

00:13:59,850 --> 00:14:04,530
we change some of the data that has been

00:14:01,740 --> 00:14:06,900
used inside that function

00:14:04,530 --> 00:14:08,610
and so if we don't have it to do so

00:14:06,900 --> 00:14:12,390
which contains a collection of the do's

00:14:08,610 --> 00:14:14,870
and we map over to our Studios it's time

00:14:12,390 --> 00:14:17,850
this computer's value is involved our

00:14:14,870 --> 00:14:19,860
estate to recompute at your map of Rolla

00:14:17,850 --> 00:14:22,050
two duels but for most of them to those

00:14:19,860 --> 00:14:25,590
or to the resident change that will

00:14:22,050 --> 00:14:27,060
return the same JSON object so to put it

00:14:25,590 --> 00:14:31,650
in a picture what's happening if we

00:14:27,060 --> 00:14:33,990
change corner over here a fresh snapshot

00:14:31,650 --> 00:14:36,600
of fresh - reputation will be generated

00:14:33,990 --> 00:14:39,600
that triggers the computed value and

00:14:36,600 --> 00:14:43,230
it's a do store to rerun but it will

00:14:39,600 --> 00:14:44,780
reuse snapshots of yarra - deuce and so

00:14:43,230 --> 00:14:47,850
on and so on

00:14:44,780 --> 00:14:50,070
so but just using computed values we

00:14:47,850 --> 00:14:53,010
have achieved structural sharing and

00:14:50,070 --> 00:14:57,570
sides a derived value namely our

00:14:53,010 --> 00:15:00,540
snapshot based on that's principle I

00:14:57,570 --> 00:15:04,320
wrote a small experimental package that

00:15:00,540 --> 00:15:06,600
leverages this concept and does the

00:15:04,320 --> 00:15:10,950
sterilization and a standardized way for

00:15:06,600 --> 00:15:13,700
you so its core concept is that you have

00:15:10,950 --> 00:15:15,990
your state it's a tree of models and

00:15:13,700 --> 00:15:18,870
each of those moles is a tree itself

00:15:15,990 --> 00:15:21,900
again and those moles are mutable to

00:15:18,870 --> 00:15:24,210
observe all their edge and at any moment

00:15:21,900 --> 00:15:28,800
in time you can just have a very cheap

00:15:24,210 --> 00:15:30,800
cheap snapshot of them and so those

00:15:28,800 --> 00:15:33,810
models are created using factories and

00:15:30,800 --> 00:15:36,660
factory just takes an example model an

00:15:33,810 --> 00:15:38,910
example to do and every time you need

00:15:36,660 --> 00:15:41,310
new instance I just copied purposes

00:15:38,910 --> 00:15:43,830
object and mixes in the snapshot to

00:15:41,310 --> 00:15:45,990
provide - this allows you to go back

00:15:43,830 --> 00:15:48,720
from snapshots to objects that have

00:15:45,990 --> 00:15:52,050
computed values methods and all those

00:15:48,720 --> 00:15:54,810
kind of things so here's a factory that

00:15:52,050 --> 00:15:57,510
creates a box and after that we can just

00:15:54,810 --> 00:16:00,060
invoke that function we get from factory

00:15:57,510 --> 00:16:03,420
with a partial of a complete or a

00:16:00,060 --> 00:16:06,990
complete snapshots and we get back a

00:16:03,420 --> 00:16:09,150
model instance and the same for the

00:16:06,990 --> 00:16:11,870
store or we can define that you want to

00:16:09,150 --> 00:16:11,870
use collections

00:16:11,960 --> 00:16:19,710
so where does sepsis useful the mobic

00:16:17,310 --> 00:16:22,440
sagely tree library provides Street

00:16:19,710 --> 00:16:24,800
functions want to get a snapshot

00:16:22,440 --> 00:16:27,780
I want to apply snapshots back to an

00:16:24,800 --> 00:16:31,110
existing model instance and also a

00:16:27,780 --> 00:16:35,700
listener to retrieve a new snapshot it's

00:16:31,110 --> 00:16:38,790
time some data exchange so with that we

00:16:35,700 --> 00:16:41,550
can build actual trial every time

00:16:38,790 --> 00:16:45,360
carefully which isn't expensive TP wise

00:16:41,550 --> 00:16:48,330
or memory wise they can just attach to a

00:16:45,360 --> 00:16:50,070
model I'm a snapshot listener and if we

00:16:48,330 --> 00:16:54,960
want to rewind the state the apply it

00:16:50,070 --> 00:16:58,080
back but what you can also do is build

00:16:54,960 --> 00:17:01,830
forms and I take an aide to do and

00:16:58,080 --> 00:17:04,800
doesn't change the short model until you

00:17:01,830 --> 00:17:06,750
press submit on the form and how do you

00:17:04,800 --> 00:17:09,420
do that but it just make a clog of the

00:17:06,750 --> 00:17:11,490
to do and then once the form is

00:17:09,420 --> 00:17:12,959
submitted you get the snapshot of the

00:17:11,490 --> 00:17:15,870
cloud and you apply it back to the

00:17:12,959 --> 00:17:18,209
original and this way you can control

00:17:15,870 --> 00:17:21,390
perfectly at Witts moments in time your

00:17:18,209 --> 00:17:23,550
say it was modified by the way a cloud

00:17:21,390 --> 00:17:25,079
is a built-in function but it just takes

00:17:23,550 --> 00:17:26,640
takes the factory of the model and

00:17:25,079 --> 00:17:28,800
invokes it to a perceptual of the model

00:17:26,640 --> 00:17:32,420
and then you get a complete fresh

00:17:28,800 --> 00:17:32,420
instance and exactly the same state

00:17:33,710 --> 00:17:38,760
poofing yourself that's makes also

00:17:35,850 --> 00:17:41,790
testing very easy so we can clone some

00:17:38,760 --> 00:17:45,240
base data info connection on the clone

00:17:41,790 --> 00:17:47,160
and then assert in the ends that the

00:17:45,240 --> 00:17:50,640
internal state or the serialized state

00:17:47,160 --> 00:17:54,660
is as what we would expected and this

00:17:50,640 --> 00:17:56,940
integrates very nicely if just but has a

00:17:54,660 --> 00:18:05,670
built in snapshot feature and makes

00:17:56,940 --> 00:18:07,950
testing really trivial that's actually

00:18:05,670 --> 00:18:10,230
cool is that I currently don't have this

00:18:07,950 --> 00:18:15,120
demo running once I friend running twice

00:18:10,230 --> 00:18:17,220
and as two demos aren't synced but what

00:18:15,120 --> 00:18:20,870
I can do is whenever I see your snapshot

00:18:17,220 --> 00:18:20,870
send it over a socket

00:18:21,890 --> 00:18:27,710
to whoever is listening and if we

00:18:24,720 --> 00:18:36,090
receive from that original socket yes

00:18:27,710 --> 00:18:39,060
apply the snapshot we receive every now

00:18:36,090 --> 00:18:41,160
drag around you see that snapshots are

00:18:39,060 --> 00:18:43,680
sent of the sockets and the applications

00:18:41,160 --> 00:18:48,530
sync and in the log on the bottom right

00:18:43,680 --> 00:18:53,540
you see all the snapshots pulsing by

00:18:48,530 --> 00:18:56,430
that this might seem a bit inefficient

00:18:53,540 --> 00:18:59,340
but there's something very cool because

00:18:56,430 --> 00:19:01,080
we don't have immutable data as the at

00:18:59,340 --> 00:19:03,510
the core of our state it's just a

00:19:01,080 --> 00:19:06,480
derivation we still have observable

00:19:03,510 --> 00:19:09,200
mutable data as our single source of

00:19:06,480 --> 00:19:11,610
truth and the nice thing about

00:19:09,200 --> 00:19:14,370
observable mutable data is that you can

00:19:11,610 --> 00:19:16,890
precisely see what's going on you don't

00:19:14,370 --> 00:19:18,450
get a pressed state of the world which

00:19:16,890 --> 00:19:21,930
is the only information you have when

00:19:18,450 --> 00:19:25,440
something happens now you can see

00:19:21,930 --> 00:19:27,480
exactly what changed in this state so

00:19:25,440 --> 00:19:32,850
that this means that the packet sports

00:19:27,480 --> 00:19:34,440
Jason fetches out of the box for patches

00:19:32,850 --> 00:19:37,380
there are two functions similar to a

00:19:34,440 --> 00:19:40,140
snapshot we can just listen to patches

00:19:37,380 --> 00:19:41,730
which are emitted when for example an

00:19:40,140 --> 00:19:44,690
attribute is changed and we can apply

00:19:41,730 --> 00:19:44,690
them back to our model

00:19:45,050 --> 00:19:50,190
so if we apply that principle to our

00:19:47,910 --> 00:19:52,110
demo they stop listening to snapshots

00:19:50,190 --> 00:19:58,860
and instead start listening to pictures

00:19:52,110 --> 00:20:02,010
and if you then apply the patch and we

00:19:58,860 --> 00:20:05,160
receive a message you see that we have

00:20:02,010 --> 00:20:07,140
still the same working reality but now

00:20:05,160 --> 00:20:09,330
we're sending actual actual Jason

00:20:07,140 --> 00:20:12,150
patches across the wire it's our very

00:20:09,330 --> 00:20:15,800
smaller oh it's our actually a useful

00:20:12,150 --> 00:20:15,800
way of integrating with a beckons

00:20:19,390 --> 00:20:25,970
and the nice thing about stay trees is

00:20:23,150 --> 00:20:29,090
that they are a fractal structure there

00:20:25,970 --> 00:20:31,850
are trees of trees of trees and I can

00:20:29,090 --> 00:20:33,770
demonstrate it easily if I attach a

00:20:31,850 --> 00:20:37,220
listener four patches at two different

00:20:33,770 --> 00:20:39,380
points in the tree so persister attaches

00:20:37,220 --> 00:20:43,010
to the root of the store and second one

00:20:39,380 --> 00:20:45,440
attests attaches to a specific box if I

00:20:43,010 --> 00:20:49,910
then move that box around I get two

00:20:45,440 --> 00:20:52,970
patches both with the relative path from

00:20:49,910 --> 00:20:55,730
where they were a test so what is

00:20:52,970 --> 00:20:56,210
happening is if I change the box over

00:20:55,730 --> 00:20:58,940
here

00:20:56,210 --> 00:21:02,120
it emits adjacent beds but at leaf and

00:20:58,940 --> 00:21:04,220
also bubbles up and emits some data and

00:21:02,120 --> 00:21:08,030
its parent and that event again bubbles

00:21:04,220 --> 00:21:11,180
up and all the events are corrected to

00:21:08,030 --> 00:21:13,700
the place where they are quiet and this

00:21:11,180 --> 00:21:18,020
doesn't work for just snapshots or

00:21:13,700 --> 00:21:19,340
patches it also works for snapshots and

00:21:18,020 --> 00:21:20,930
what you see here it's a recursive

00:21:19,340 --> 00:21:24,110
structure but we need that you can

00:21:20,930 --> 00:21:26,450
safely take the arrows direction put

00:21:24,110 --> 00:21:29,090
into a separate repository put into a

00:21:26,450 --> 00:21:31,280
separate package tested over there have

00:21:29,090 --> 00:21:33,560
all the actions over there and then in

00:21:31,280 --> 00:21:35,870
your application compose all the trees

00:21:33,560 --> 00:21:41,840
together and then you can do the

00:21:35,870 --> 00:21:43,940
high-level stuff at the root so far I

00:21:41,840 --> 00:21:46,190
didn't talk about actions you'll solve

00:21:43,940 --> 00:21:49,940
them just invoke functions or model

00:21:46,190 --> 00:21:52,040
classes but of course we have a problem

00:21:49,940 --> 00:21:53,960
there because you want to be playable

00:21:52,040 --> 00:21:55,940
actions because without replayable

00:21:53,960 --> 00:21:58,400
actions we don't have transactional

00:21:55,940 --> 00:22:00,050
States we have snapshots which we don't

00:21:58,400 --> 00:22:05,510
know what happens in between the

00:22:00,050 --> 00:22:08,270
snapshots so what if we put inverse the

00:22:05,510 --> 00:22:10,820
principle of dispatching what if instead

00:22:08,270 --> 00:22:12,830
of dispatching some description of an

00:22:10,820 --> 00:22:14,960
action we could just invoke a function

00:22:12,830 --> 00:22:20,830
and get this description of detection as

00:22:14,960 --> 00:22:23,780
a result so that's how actions work

00:22:20,830 --> 00:22:26,090
action can be declared by just adding it

00:22:23,780 --> 00:22:29,280
to the model they will be automatically

00:22:26,090 --> 00:22:32,610
bound and they are marked by action

00:22:29,280 --> 00:22:35,669
and then I can just infer get function

00:22:32,610 --> 00:22:38,010
nothing exciting so far except that

00:22:35,669 --> 00:22:40,169
action is really straightforward and I

00:22:38,010 --> 00:22:44,490
don't have to rebuild the entire world

00:22:40,169 --> 00:22:46,260
unable to move some coordinates and like

00:22:44,490 --> 00:22:50,789
patches except shots I can also listen

00:22:46,260 --> 00:22:53,820
to action events and can apply them and

00:22:50,789 --> 00:22:56,850
actions listeners can actually use as

00:22:53,820 --> 00:22:59,580
middleware so here's a very simple

00:22:56,850 --> 00:23:01,890
logging middleware which just listens to

00:22:59,580 --> 00:23:04,200
the store prints the action then invokes

00:23:01,890 --> 00:23:06,960
the next middleware of course the last

00:23:04,200 --> 00:23:11,130
Miller being actually executing the

00:23:06,960 --> 00:23:14,370
axiom so if I then move a box I just get

00:23:11,130 --> 00:23:16,470
a description of that action I know

00:23:14,370 --> 00:23:24,570
what's method was involved at which

00:23:16,470 --> 00:23:27,960
place with its arguments so of course I

00:23:24,570 --> 00:23:31,350
cannot just sing fetches I can also take

00:23:27,960 --> 00:23:36,230
actions and this is middleware so I have

00:23:31,350 --> 00:23:36,230
to debug the next industry

00:23:42,290 --> 00:23:47,450
regular rounds instead of patching spear

00:23:44,900 --> 00:23:55,640
matches being synced by actual actions

00:23:47,450 --> 00:23:59,090
that are involved are synced also you

00:23:55,640 --> 00:24:00,530
can dispensable if you have forms and I

00:23:59,090 --> 00:24:02,750
just demoed that you can do that with

00:24:00,530 --> 00:24:04,820
snapshots but if you have move tool

00:24:02,750 --> 00:24:07,240
users editing the same data it might be

00:24:04,820 --> 00:24:09,680
more interesting interesting to just

00:24:07,240 --> 00:24:12,920
record to the actions that were applied

00:24:09,680 --> 00:24:15,140
to a club and then at the end apply

00:24:12,920 --> 00:24:18,320
those actions when form submitted back

00:24:15,140 --> 00:24:20,810
to your original object and the cool

00:24:18,320 --> 00:24:23,500
thing of a big story is because this

00:24:20,810 --> 00:24:25,880
recursive I can attach these listeners

00:24:23,500 --> 00:24:27,350
specifically to this to do so I don't

00:24:25,880 --> 00:24:29,540
know about all the actions that are

00:24:27,350 --> 00:24:31,490
happening in my application I'm just

00:24:29,540 --> 00:24:34,640
interested in actions that are applied

00:24:31,490 --> 00:24:37,370
they're specific to do so I can replay

00:24:34,640 --> 00:24:43,100
actions on a very confined space in my

00:24:37,370 --> 00:24:44,600
state tree so actions are based on the

00:24:43,100 --> 00:24:48,350
objects action principle they are

00:24:44,600 --> 00:24:50,630
transactional and take a look and lock a

00:24:48,350 --> 00:24:54,080
part of the state tree for editing the

00:24:50,630 --> 00:24:56,270
actions cannot modify any states outside

00:24:54,080 --> 00:25:03,500
the round scope which ensure that their

00:24:56,270 --> 00:25:06,550
replayable preferences so forever

00:25:03,500 --> 00:25:10,840
talking about trees but trees have

00:25:06,550 --> 00:25:15,800
announced the principle and that's a day

00:25:10,840 --> 00:25:18,260
don't support references going all our

00:25:15,800 --> 00:25:21,610
outs and sometimes that's fine sometimes

00:25:18,260 --> 00:25:21,610
sometimes it isn't

00:25:21,730 --> 00:25:27,020
- what you can do is when we assign some

00:25:24,800 --> 00:25:30,740
data normally you would get an exception

00:25:27,020 --> 00:25:34,610
on this one because it's already part of

00:25:30,740 --> 00:25:38,860
a say tree I'm gonna skip this part with

00:25:34,610 --> 00:25:42,530
us yep time time the next part is cooler

00:25:38,860 --> 00:25:45,800
so so far we have a minimally defied

00:25:42,530 --> 00:25:50,540
snap suitable state container with

00:25:45,800 --> 00:25:52,670
replayable actions and a lot of things

00:25:50,540 --> 00:25:55,910
more middleware and patches dependency

00:25:52,670 --> 00:26:00,530
injection so it's like we combines the

00:25:55,910 --> 00:26:05,150
best of two worlds so to demonstrate

00:26:00,530 --> 00:26:08,510
that here is the redux to do MVC

00:26:05,150 --> 00:26:14,060
application and I can change the dose

00:26:08,510 --> 00:26:19,130
and I can advance I can play it back and

00:26:14,060 --> 00:26:20,960
forth but actually it's not really the

00:26:19,130 --> 00:26:24,230
redux to do and see example anymore

00:26:20,960 --> 00:26:24,980
it still has its actions still uses the

00:26:24,230 --> 00:26:26,900
dispatcher

00:26:24,980 --> 00:26:29,150
I still use this Redux components like

00:26:26,900 --> 00:26:31,820
provider and connect so you're the Redux

00:26:29,150 --> 00:26:35,260
dev tools but it doesn't have a Redux

00:26:31,820 --> 00:26:38,120
store and it doesn't have any reducers

00:26:35,260 --> 00:26:41,770
instead of that it has object state

00:26:38,120 --> 00:26:44,090
three factories and what makes actions

00:26:41,770 --> 00:26:46,030
you might be wondering how's that

00:26:44,090 --> 00:26:49,430
possible

00:26:46,030 --> 00:26:51,410
but actually the reason for that is we

00:26:49,430 --> 00:26:53,270
can convert the one into the other

00:26:51,410 --> 00:26:56,830
because more big state threes are

00:26:53,270 --> 00:27:00,860
transactional we can mimic Redux tours

00:26:56,830 --> 00:27:03,980
to where that works is basically a list

00:27:00,860 --> 00:27:05,960
of renames so area that store has a get

00:27:03,980 --> 00:27:09,200
state method which is basically our get

00:27:05,960 --> 00:27:11,540
snapshot function and thus patching an

00:27:09,200 --> 00:27:14,840
action is basically applying an action

00:27:11,540 --> 00:27:17,060
to the root of our model and subscribing

00:27:14,840 --> 00:27:20,030
especially listening to your snapshots

00:27:17,060 --> 00:27:23,870
that become available

00:27:20,030 --> 00:27:26,090
so this is roughly what I read at my

00:27:23,870 --> 00:27:28,010
store in the redux to do MC example now

00:27:26,090 --> 00:27:32,210
looks like it's a lot more

00:27:28,010 --> 00:27:33,980
straightforward I think and of course

00:27:32,210 --> 00:27:37,910
because that works the other way around

00:27:33,980 --> 00:27:40,580
also works so this is the move X say 3

00:27:37,910 --> 00:27:44,030
demo it doesn't have any Redux inside of

00:27:40,580 --> 00:27:47,630
it but still great exact tools work for

00:27:44,030 --> 00:27:50,270
that we can just use the time traveling

00:27:47,630 --> 00:27:54,790
over there because their principals

00:27:50,270 --> 00:27:54,790
injection all state are still preserved

00:27:55,000 --> 00:28:02,660
so just give the try it's still

00:27:58,580 --> 00:28:05,180
experimental but it might provide a nice

00:28:02,660 --> 00:28:10,060
opinionated way to build stores with

00:28:05,180 --> 00:28:12,740
rubrics but the important message is

00:28:10,060 --> 00:28:14,780
projection all state is just a reactive

00:28:12,740 --> 00:28:16,970
information away reactive

00:28:14,780 --> 00:28:18,520
transformations are really really

00:28:16,970 --> 00:28:22,280
powerful

00:28:18,520 --> 00:28:24,680
maybe so far like function applications

00:28:22,280 --> 00:28:28,940
are really really powerful but they're

00:28:24,680 --> 00:28:33,320
like having images but you have to take

00:28:28,940 --> 00:28:35,270
them yourself at a time of cameras we

00:28:33,320 --> 00:28:37,040
have reactive function application we

00:28:35,270 --> 00:28:40,250
can do really cool stuff with that I

00:28:37,040 --> 00:28:43,100
hope that's feeling that you will leave

00:28:40,250 --> 00:28:44,120
with if you want to know more about

00:28:43,100 --> 00:28:46,070
moving yourself

00:28:44,120 --> 00:28:47,840
pull out the egghead course you know all

00:28:46,070 --> 00:28:51,530
the essential parts in half an hour

00:28:47,840 --> 00:28:55,300
but just follow me on Twitter and it's

00:28:51,530 --> 00:28:55,300
time for questions thank you

00:28:57,990 --> 00:29:14,970
I don't know

00:29:10,260 --> 00:29:18,470
presto Jas but the immutable structures

00:29:14,970 --> 00:29:21,149
here are just plain JavaScript objects

00:29:18,470 --> 00:29:23,429
like were different Redux but it'll be

00:29:21,149 --> 00:29:27,450
no problem to just generate immutable

00:29:23,429 --> 00:29:29,960
Jas immutable objects for example as

00:29:27,450 --> 00:29:29,960
snapshots

00:29:30,860 --> 00:29:36,870
yes proxies are very nice I can't wait

00:29:35,190 --> 00:29:40,350
for the moment that they have landed and

00:29:36,870 --> 00:29:42,270
all major browsers because for example

00:29:40,350 --> 00:29:45,360
there are few limitations to Mobile's so

00:29:42,270 --> 00:29:48,299
for example you can't on the fly adds

00:29:45,360 --> 00:29:51,539
new observable properties to existing

00:29:48,299 --> 00:29:58,049
objects and that is something that

00:29:51,539 --> 00:30:02,840
proxies would solve as mobis related to

00:29:58,049 --> 00:30:02,840
RTS good question

00:30:03,049 --> 00:30:07,070
RHCs

00:30:04,200 --> 00:30:10,340
is are strange and they're all about

00:30:07,070 --> 00:30:16,049
events however Mobius is more about

00:30:10,340 --> 00:30:17,730
concrete tangible data so when for

00:30:16,049 --> 00:30:21,600
example time is important or you're just

00:30:17,730 --> 00:30:24,419
reading about events then RHCs is a way

00:30:21,600 --> 00:30:27,049
to go because you can combine present

00:30:24,419 --> 00:30:30,179
and past events you can build and delays

00:30:27,049 --> 00:30:33,960
can really combine events in complex

00:30:30,179 --> 00:30:36,029
ways however if you have like data you

00:30:33,960 --> 00:30:38,520
want to preserve a state that you want

00:30:36,029 --> 00:30:42,809
to be able to see and touch and work

00:30:38,520 --> 00:30:45,539
with with all data objects I think what

00:30:42,809 --> 00:30:47,220
makes this a benefit but also happens is

00:30:45,539 --> 00:30:49,409
that people combine the two so for

00:30:47,220 --> 00:30:51,779
example you have some input and you have

00:30:49,409 --> 00:30:54,419
some RHCs extreme that it bounces the

00:30:51,779 --> 00:30:57,210
values and in the end when there's some

00:30:54,419 --> 00:31:00,510
exact door output at that point you

00:30:57,210 --> 00:31:07,230
update your observable state

00:31:00,510 --> 00:31:12,150
I assume that obex

00:31:07,230 --> 00:31:15,390
works on top of ten Gators obex runs in

00:31:12,150 --> 00:31:18,240
any years five supporting browser so

00:31:15,390 --> 00:31:23,510
that's basically any browser we know

00:31:18,240 --> 00:31:23,510
about except for a tenth Explorer eight

00:31:23,600 --> 00:31:29,730
what do you think about psycho Diaz I

00:31:26,540 --> 00:31:33,660
think psycho jess is really cool and I

00:31:29,730 --> 00:31:37,770
really like the mental model and to me

00:31:33,660 --> 00:31:40,290
it makes lots of sense similar to RTS as

00:31:37,770 --> 00:31:44,250
long as you're talking about events

00:31:40,290 --> 00:31:46,490
where time plays a role however to do

00:31:44,250 --> 00:31:51,840
simple updates

00:31:46,490 --> 00:31:55,590
small pieces of data to do updates of

00:31:51,840 --> 00:31:57,980
attributes to me makes more sense to use

00:31:55,590 --> 00:32:00,630
reactive observable data structures

00:31:57,980 --> 00:32:03,930
instead of combining streams over there

00:32:00,630 --> 00:32:06,780
so that's at one point in time you can

00:32:03,930 --> 00:32:09,720
really touch the data inspect it and

00:32:06,780 --> 00:32:16,920
from their own go back to the reactive

00:32:09,720 --> 00:32:19,680
world again did you do the full

00:32:16,920 --> 00:32:22,470
evolution circle from locality s sake

00:32:19,680 --> 00:32:25,250
less and make observables yes I think so

00:32:22,470 --> 00:32:28,830
I think the conceptual model of

00:32:25,250 --> 00:32:33,660
Knockouts makes lots of sense same for

00:32:28,830 --> 00:32:39,090
meteor I think it's how we expect the

00:32:33,660 --> 00:32:40,740
world to work we think in terms of

00:32:39,090 --> 00:32:44,190
mutable identities

00:32:40,740 --> 00:32:46,890
that's how we people reason and a way to

00:32:44,190 --> 00:32:49,680
prove that is that the most successful

00:32:46,890 --> 00:32:51,860
software product ever Excel spreadsheets

00:32:49,680 --> 00:32:53,850
they are based on this principle

00:32:51,860 --> 00:32:55,800
everybody understands them you don't

00:32:53,850 --> 00:32:57,480
have to be a software engineer it don't

00:32:55,800 --> 00:32:59,060
have to be an academics for five years

00:32:57,480 --> 00:33:02,850
together

00:32:59,060 --> 00:33:04,590
the problem with blackouts and meteor

00:33:02,850 --> 00:33:07,080
also in some accept is that it was

00:33:04,590 --> 00:33:09,480
unpredictable when it would run in

00:33:07,080 --> 00:33:11,190
salvations and they weren't ordered you

00:33:09,480 --> 00:33:14,279
could get glitches and those kind of

00:33:11,190 --> 00:33:17,700
things so these are the things I think

00:33:14,279 --> 00:33:21,889
Oh Blake says so and I think that's so

00:33:17,700 --> 00:33:25,769
circle back to reactive data structure

00:33:21,889 --> 00:33:29,039
this is our last question how do you

00:33:25,769 --> 00:33:29,580
manage UI state and Upstate good

00:33:29,039 --> 00:33:32,279
question

00:33:29,580 --> 00:33:34,559
what we usually do is that most of our

00:33:32,279 --> 00:33:37,259
domain-specific state which is specific

00:33:34,559 --> 00:33:40,080
to the application we put at a store so

00:33:37,259 --> 00:33:43,109
that we can test them separately without

00:33:40,080 --> 00:33:46,559
UI and we can test all the business

00:33:43,109 --> 00:33:50,609
logic however this also always some

00:33:46,559 --> 00:33:54,809
volatile data like which that page is

00:33:50,609 --> 00:33:57,659
currently selected as a section box open

00:33:54,809 --> 00:34:00,210
or not and this kind of states makes

00:33:57,659 --> 00:34:02,460
more sense for me to just put into your

00:34:00,210 --> 00:34:05,989
component or in some store that

00:34:02,460 --> 00:34:05,989

YouTube URL: https://www.youtube.com/watch?v=Ql8KUUUOHNc


