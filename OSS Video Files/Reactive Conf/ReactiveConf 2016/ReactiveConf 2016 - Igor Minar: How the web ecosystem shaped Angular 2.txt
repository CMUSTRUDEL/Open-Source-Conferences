Title: ReactiveConf 2016 - Igor Minar: How the web ecosystem shaped Angular 2
Publication date: 2016-11-25
Playlist: ReactiveConf 2016
Description: 
	https://reactiveconf.com 

Meet those driving the change! World-renowned mobile and web innovators got together for three days in one town.

ReactiveConf, October 26 - 28 2016, Bratislava, Slovakia

---

Igor Minar: How the web ecosystem shaped Angular 2 

No open source software is developed in a vacuum these days. We are all part of a larger ecosystem where ideas and solutions to problems are shared, improved upon, and shared again. In this talk, we'll look at what Angular learned from its past as well as other libraries and frameworks like React, Polymer, and Ember, and which ideas influenced the design of Angular 2.

---

Have you heard about ReactiveConf? According to tech superstars such as David Nolen, Richard Feldman, or Brent Vatne, it’s the best conference on web and mobile app development! It focuses on all things React and beyond and takes place annually in Bratislava, Slovakia.

In 2016, more than 700 attendees from all over the world spent three days in Bratislava getting inspired, sharing amazing new ideas, and meeting more than 30 awesome speakers from companies such as Google, Cognitect, NoRedInk, RethinkDB, Airbnb, Microsoft, Facebook, and the list could go on forever.

If you want to be part of the next event, get your tickets now at https://reactiveconf.com, and React with us!
Captions: 
	00:00:04,340 --> 00:00:05,560
Hello, everybody!

00:00:06,200 --> 00:00:06,700
How you doing?

00:00:09,320 --> 00:00:09,880
Really?

00:00:09,880 --> 00:00:11,340
OK, that's better!

00:00:13,600 --> 00:00:15,520
I'm really excited to be here at this conference

00:00:15,520 --> 00:00:20,400
I looked at the speaker lineup, and I was quite amazed to see such a great lineup here in Slovakia.

00:00:21,080 --> 00:00:25,000
My name is Igor Minar, I'm a software engineer at Google.

00:00:25,000 --> 00:00:28,920
More specifically, I'm the tech lead of the Angular project.

00:00:29,720 --> 00:00:36,040
I live in California now, and it's a special honor for me to be here because when I was preparing for this talk,

00:00:36,040 --> 00:00:41,020
I realized this was the first talk that I'm giving in Slovakia.

00:00:41,440 --> 00:00:46,720
I've travelled round the world and spoken all over the place, so thanks for having me here.

00:00:47,200 --> 00:00:51,120
You might be wondering what is this Angular guy doing here.

00:00:51,120 --> 00:00:54,960
Is he gonna sell us Angular? I'm not here to sell you Angular.

00:00:54,960 --> 00:01:00,280
I believe in Angular, I love Angular, but I believe that a good product should sell itself.

00:01:00,840 --> 00:01:05,000
What I'm here to do is to give you a sneak peek behind the scenes,

00:01:05,680 --> 00:01:09,760
kinda show you how we think when developing a framework like Angular,

00:01:09,760 --> 00:01:12,319
and what goes into building a framework like Angular.

00:01:13,040 --> 00:01:17,939
I strongly believe that no software today is build in a vacuum.

00:01:19,340 --> 00:01:23,020
Just like artists, we influence each other,

00:01:23,120 --> 00:01:26,920
when we look at different software, we think about what other people are solving.

00:01:27,800 --> 00:01:36,459
And one thing I want you to take away from this conference is that you should keep your mind open to new ideas.

00:01:36,460 --> 00:01:38,360
Because you never know what's out there.

00:01:39,740 --> 00:01:42,780
I mentioned artistry and art,

00:01:42,780 --> 00:01:45,920
and when many people think about software engineering,

00:01:45,940 --> 00:01:49,500
they think about a bunch of people in a basement coding all night.

00:01:49,900 --> 00:01:51,819
For me, it's quite different.

00:01:51,820 --> 00:01:53,660
For me, it's more like an art.

00:01:53,660 --> 00:01:59,060
We're artists, we study each other's work, we influence each other, we inspire each other.

00:01:59,180 --> 00:02:01,979
And we collaborate on creating great art.

00:02:01,980 --> 00:02:06,820
This is what building software is for me, and I believe it's also for many people out there.

00:02:08,460 --> 00:02:15,100
When talking about what are the influences for Angular, we actually have to go quite far back into the past.

00:02:15,720 --> 00:02:23,820
We started building Angular in mid-2009 or late-2009, and the landscape back then was quite different that what it is now.

00:02:25,100 --> 00:02:29,360
There were many projects that influenced the decisions behind Angular

00:02:29,360 --> 00:02:34,540
because we were inspired by them or we didn't like them that much and wanted to build something better.

00:02:35,160 --> 00:02:40,819
I'm not gonna tell you which belongs to which category because all of us have different preferences,

00:02:41,200 --> 00:02:49,040
but back then, there were things like jQuery, GWT, Adobe Flex – and all of these influenced Angular in one way or another.

00:02:50,880 --> 00:02:55,020
When thinking about Angular and what it meant to build Angular back then,

00:02:55,140 --> 00:02:58,340
we used this as a mental model,

00:02:58,579 --> 00:03:04,899
we tried to imagine what a browser would have been if it had been designed for building web applications.

00:03:05,880 --> 00:03:16,200
And what we mean by that is that back in 2010, most of the applications were built with Ruby on Rails, Java, .Net, etc.

00:03:16,780 --> 00:03:20,120
And they were very few really cool client-side applications.

00:03:20,120 --> 00:03:22,979
Yes, there were some exceptions like Google Maps or Gmail,

00:03:22,980 --> 00:03:25,780
but those were really just very few.

00:03:25,780 --> 00:03:30,500
And we saw this opportunity to build really interactive client-side applications,

00:03:30,500 --> 00:03:32,500
and that's what we set out to do.

00:03:33,280 --> 00:03:37,040
Three years later, we finally launched Angular 1.

00:03:37,040 --> 00:03:41,680
It took us three years, which is amazing because that's a long time,

00:03:41,680 --> 00:03:43,400
but back then, nobody cared.

00:03:43,400 --> 00:03:47,280
The situation was quite different with Angular 2 if you followed along.

00:03:49,340 --> 00:03:55,879
The interesting thing in 2012, when we launched, was that this is the moment when we saw that

00:03:55,880 --> 00:03:59,600
Angular started influencing the rest of the web ecosystem.

00:03:59,600 --> 00:04:02,020
This was the first time when we thought: "WOW!"

00:04:02,020 --> 00:04:07,500
You know, it's very gratifying to build something that you see other people copy or improve.

00:04:07,500 --> 00:04:08,460
It's awesome!

00:04:09,340 --> 00:04:14,659
So we started building Angular applications at Google and outside with Angular 1,

00:04:14,660 --> 00:04:20,140
and as we were building bigger and bigger applications, we were realizing there are areas for improvements.

00:04:20,140 --> 00:04:26,900
And another thing that we saw was this big tectonic shift coming into the web ecosystem,

00:04:26,900 --> 00:04:36,140
and we thought: "Maybe this is the opportunity for us to rethink how Angular works and improve it."

00:04:36,720 --> 00:04:39,760
So we started thinking about this in mid-2013,

00:04:41,000 --> 00:04:48,580
and again, there were bunch of things that influenced the design and influenced our thinking about Angular 2.

00:04:49,280 --> 00:04:51,879
One of them was ECMAScript.

00:04:51,880 --> 00:04:57,300
Back in 2013, ES6 was still this dream pipe.

00:04:57,300 --> 00:05:02,899
It was just a bunch of proposals, it wasn't really ready, it wasn't clear when it was going to launch.

00:05:02,900 --> 00:05:09,300
But there were many things we saw in many of the proposals that eventually made it into ES6 that we liked.

00:05:09,940 --> 00:05:15,420
There were things like classes that allowed us to finally express what we meant in JavaScript

00:05:15,420 --> 00:05:18,720
without using third-party libraries or all kinds of idioms and hacks,

00:05:18,720 --> 00:05:25,500
and there were things like the module system that really would help us improve scaling our large applications

00:05:25,500 --> 00:05:27,580
as they were growing and growing in size.

00:05:28,260 --> 00:05:32,420
And lastly, there was a lot of syntactic sugar like fat arrows.

00:05:32,940 --> 00:05:37,260
We, as developers, really like to make a code look beautiful.

00:05:38,140 --> 00:05:40,460
We want to be proud of what we write,

00:05:40,460 --> 00:05:42,800
and having syntactic sugar allows us to do this.

00:05:44,420 --> 00:05:47,180
There were other things that influenced the design.

00:05:47,180 --> 00:05:51,340
For example, at Google, we have a programming language called Dart.

00:05:51,340 --> 00:05:57,760
We built several projects with Dart in 2013, and there were several things we liked about Dart.

00:05:58,140 --> 00:06:03,680
One of them was the concept of metadata that is implemented in Dart using annotations.

00:06:04,400 --> 00:06:10,020
Using this concept, you can attach information about classes and properties,

00:06:10,020 --> 00:06:12,420
and use them during static analysis.

00:06:12,420 --> 00:06:17,180
We liked this so much that we wanted to have this in JavaScipt, and this is why we paired together

00:06:17,180 --> 00:06:22,300
with the TouchScript team and Yehuda Katz from Ember to create a proposal for decorators

00:06:22,300 --> 00:06:26,480
that is now part of the ES6 standards track.

00:06:28,020 --> 00:06:31,120
We later used it to build Angular 2.

00:06:31,120 --> 00:06:38,120
There were things like static analysis, which allows us to look for errors early on and provide better tooling,

00:06:38,120 --> 00:06:41,639
and this was something that we really wanted, but what was difficult to do in JavaScript

00:06:41,640 --> 00:06:43,680
because of its dynamic nature.

00:06:44,220 --> 00:06:48,700
And lastly, the thing that totally blew our minds, was zones.

00:06:48,880 --> 00:06:52,740
It's very difficult to explain zones in thirty seconds, but I'll give it a try.

00:06:53,320 --> 00:07:06,340
Imagine that zones is to async event in programming what thread locals are to multithreaded concurrent programming.

00:07:06,340 --> 00:07:11,860
It basically allows you to attach contextual information to a sequence of events.

00:07:12,320 --> 00:07:15,439
And using this, we can do really really cool stuff.

00:07:16,420 --> 00:07:24,240
We can even take over the schedule of the browser and invoke things at the right time in an almost magical way.

00:07:24,600 --> 00:07:30,540
We liked zones so much in Dart that once again, we took the core ideas and propose the primitives

00:07:30,540 --> 00:07:36,920
to the TC39 standards committee as something that should be considered for all the browsers and made part of the spec.

00:07:36,920 --> 00:07:41,180
This still an on-going process and we're hoping that it's gonna be built into the browsers in the future,

00:07:41,680 --> 00:07:46,800
but in the meantime, we already have a polyfill that is being used by all of the Angular 2 applications today.

00:07:49,700 --> 00:07:54,260
Around 2014, Web Components started to get some traction.

00:07:54,760 --> 00:07:56,840
We looked into Web Components,

00:07:56,840 --> 00:08:03,000
and we realized that we face this question that Hamlet faced in the 17th century.

00:08:03,580 --> 00:08:08,060
And the question was: "To be, or not to be DOM, that is the question."

00:08:09,000 --> 00:08:09,840
What does that mean?

00:08:11,260 --> 00:08:17,920
What we needed to decide was whether DOM was the fundamental building block of Angular applications,

00:08:17,920 --> 00:08:19,720
the fabric of the framework,

00:08:19,720 --> 00:08:23,040
or if it was just something that the framework rendered into.

00:08:23,440 --> 00:08:30,440
We did a ton of research to figure out the pros and cons, and there were things we really liked about WebWorkers.

00:08:30,440 --> 00:08:35,980
We liked the interoperability, we liked the composition model, we liked the encapsulation that they give us.

00:08:36,620 --> 00:08:41,360
We also liked the public IPA that can be defined through properties and vends.

00:08:41,840 --> 00:08:47,919
This influenced the design of the template syntax and the binding systems in Angular 2.

00:08:48,540 --> 00:08:54,080
And at the end, we made the hard choice that while DOM is cool,

00:08:54,580 --> 00:09:01,000
we can do much more if we decouple ourselves from DOM, and just use it as a rendering platform or target.

00:09:01,220 --> 00:09:05,560
This allowed us to have better control over the life cycle of the application,

00:09:05,560 --> 00:09:11,960
and even do performance optimalization tricks that would not be possible if DOM was built into the Angular's core.

00:09:13,140 --> 00:09:18,320
Interestingly enough, there was this project that probably some of you know about – React –

00:09:18,320 --> 00:09:23,800
that validated this choice and showed that yes, using DOM as a rendering target is a good idea.

00:09:24,540 --> 00:09:29,159
For many people out there, the thing that React brought,

00:09:29,160 --> 00:09:33,240
the highlight of the React's contribution to the community,

00:09:33,740 --> 00:09:34,860
was virtual DOM.

00:09:34,940 --> 00:09:36,220
Well, I beg to differ.

00:09:36,740 --> 00:09:41,760
I think the highlight, the most important thing that React brought to the community,

00:09:41,760 --> 00:09:44,360
was the idea of the unidirectional data flow.

00:09:44,780 --> 00:09:47,920
At Google, when building larger and larger applications,

00:09:47,920 --> 00:09:51,400
we realized that it was really difficult to start reasoning about this applications

00:09:51,400 --> 00:09:57,220
because when you have hundred, two hundred, or several hundred app developers working on the single code base,

00:09:57,220 --> 00:09:59,220
you have very complex applications,

00:09:59,220 --> 00:10:03,120
and when there are events fighting left and right that mutate the data all over the place,

00:10:03,120 --> 00:10:08,040
it's really difficult to find bugs, to debug stuff, and to reason about the application.

00:10:08,080 --> 00:10:13,560
This is what the unidirectional data flow solves, and it's something we built into Angular

00:10:13,720 --> 00:10:16,440
thanks to the example that React provided to us.

00:10:17,120 --> 00:10:24,899
And I have to say that unidirectional data flow is actually the last nail in the coffin of Object.observe,

00:10:24,900 --> 00:10:30,680
a proposal for a standard that many frameworks and libraries at the time believed

00:10:30,680 --> 00:10:35,880
could solve the problems of faction tracking that we face, including in Angular.

00:10:35,920 --> 00:10:41,820
We thought that was a good idea, but eventually we saw that it would make things more difficult,

00:10:41,820 --> 00:10:44,159
and unidirectional data flows was a better way to go.

00:10:45,480 --> 00:10:53,380
A little bit later, then, looking at React we met with Ben Lesh and Jafar Husain from Netflix,

00:10:53,380 --> 00:10:58,420
and if you know Ben and Jafar, you know that they are very convincing people.

00:10:58,680 --> 00:11:02,200
We had several discussions with them, and during these discussions,

00:11:02,200 --> 00:11:06,800
I had this "a-ha moment" that I had several years ago when I looked into promises

00:11:06,800 --> 00:11:09,840
and realised that this actually solves a real problem,

00:11:09,840 --> 00:11:14,560
and it's a very powerful primitive for dealing with Async.

00:11:14,700 --> 00:11:21,700
I looked at Observables the way Jafar and Ben explained it to me and I was like: "Well, this is actually way better!"

00:11:21,880 --> 00:11:25,880
And we made a big bet on Observables and built them into Angular.

00:11:27,180 --> 00:11:30,740
Well, this is a Reactive conference so I'm probably preaching to the choir.

00:11:30,740 --> 00:11:36,220
You know what Observables are about, but I have to say we really fell in love with Reactive programming.

00:11:36,220 --> 00:11:41,820
We saw Observables as this very important primitive with a good composition model

00:11:42,060 --> 00:11:47,300
that is able to tame the Async madness that is happening with web applications.

00:11:47,400 --> 00:11:54,040
And we built Observables into Angular, we made several APIs of the Angular core using Observables,

00:11:54,320 --> 00:11:58,340
and we also made it super easy to bind Observables into Angular templates

00:11:58,340 --> 00:12:03,820
so that it's very easy for you to expose your streams into the UI.

00:12:06,780 --> 00:12:11,420
The next inspiration came from a very unusual place – from Microsoft.

00:12:11,660 --> 00:12:18,700
We, as I've already mentioned, we looked at Dart, we liked annotations, we liked the static analysis,

00:12:19,060 --> 00:12:23,320
and wanted the same in JavaScript so we had this crazy idea for a while

00:12:23,320 --> 00:12:29,580
that we're going to build our own language by extending JavaScript 6 by adding types and annotations.

00:12:29,860 --> 00:12:34,580
And fortunately, the Typescript team came along and said: "You guys are crazy,

00:12:34,980 --> 00:12:40,340
let us help you. We can build this into Typescript, and it's gonna be way better."

00:12:41,180 --> 00:12:45,620
They knew what they were doing back then because we didn't realize how much work it would be to build our own language.

00:12:47,480 --> 00:12:51,740
This relationship with Typescript was actually quite awesome

00:12:51,740 --> 00:12:57,180
because the two teams found a symbiotic relationship

00:12:57,260 --> 00:13:02,180
where we influence Typescript, and Typescript influences Angular in a really good way,

00:13:02,180 --> 00:13:13,580
and both projects were able to advance forward in a much faster pace than what it would have been if we built our own language.

00:13:14,580 --> 00:13:17,340
The things we liked about Typescript are, of course, error checking.

00:13:17,340 --> 00:13:20,720
We want to know about errors as soon as possible, and TouchScript gives us this.

00:13:21,280 --> 00:13:26,139
We liked the automated refactoring and IDE support that we get with Typescript,

00:13:26,140 --> 00:13:29,980
but most importantly, we liked the JavaScript interoperability.

00:13:29,980 --> 00:13:34,000
Touchscript is just an extension of JavaScript so you can use all of your JavaScript,

00:13:34,000 --> 00:13:36,580
and you can easily translate Typescript into JavaScript

00:13:36,660 --> 00:13:39,140
so the interoperability is awesome.

00:13:40,520 --> 00:13:45,160
We were so inspired by something called Language Services – Typescript Languages Services –

00:13:45,360 --> 00:13:52,080
which are used to power all of the IDEs that we're building our own language services using their example.

00:13:52,080 --> 00:13:56,760
This is a screenshot of something that's going to be released in a month or two,

00:13:56,760 --> 00:14:02,360
it's gonna be called Angular Language Services, and it's gonna power IDEs

00:14:02,360 --> 00:14:07,159
so that you get all the completion, error checking, refactoring in your IDEs.

00:14:07,160 --> 00:14:12,880
And because it's modelled by the Typescript example, it's gonna be very easy to integrate to many editors

00:14:12,880 --> 00:14:16,420
like VS Code or whatever you're using today.

00:14:19,160 --> 00:14:25,480
As we were using more and more tooling to check for errors, transpile our awesome futuristic JavaScript,

00:14:25,480 --> 00:14:28,400
we realized that always tooling was getting in the way

00:14:28,400 --> 00:14:30,660
of the developer trying to build their awesome applications.

00:14:30,740 --> 00:14:32,340
And we didn't like this.

00:14:32,340 --> 00:14:35,139
We thought maybe there's a way we can help.

00:14:37,060 --> 00:14:43,260
We firstly talked to the Ember team, and we got really warmed welcome from the Ember CLI team

00:14:43,260 --> 00:14:50,500
who arguably is one of the best examples of how a CLI can help framework and framework developers

00:14:50,500 --> 00:14:52,380
become really productive very quickly.

00:14:52,920 --> 00:15:00,020
With things like build tools integration, having conventions so you can jump from one project to another,

00:15:00,220 --> 00:15:04,540
and overall just productivity gains using integrated tooling.

00:15:06,360 --> 00:15:11,560
Using this example, we build our own CLI, which is currently in beta or a release candidate phase,

00:15:11,680 --> 00:15:15,880
but I encourage you to take it up for a spin and give us feedback on what you like

00:15:15,880 --> 00:15:18,040
and what is there to be improved.

00:15:18,220 --> 00:15:25,960
I'm looking forward to the future where people will not be afraid of tools when building applications

00:15:25,960 --> 00:15:28,840
because the tools will just work out of the box very smoothly.

00:15:30,480 --> 00:15:37,740
It was around 2015 when the web went crazy with 60fps and building applications

00:15:37,740 --> 00:15:41,480
that rendered 60 frames per seconds very smoothly and very interactively.

00:15:41,700 --> 00:15:47,240
We looked into this and thought: "Well, if this is what it takes to build great user interfaces,

00:15:47,240 --> 00:15:52,320
a framework like Angular should help, should guide developers how to achieve this."

00:15:52,900 --> 00:15:59,380
And we started analyzing what does it take to build an application that is as responsive as 60fps.

00:15:59,380 --> 00:16:03,280
We realized we can't really do much work on the main thread

00:16:03,580 --> 00:16:08,280
because browsers are single threaded if you look at the main thread.

00:16:08,760 --> 00:16:15,020
And if you happen to do just little too much work on the main thread, you will start blocking the rendering,

00:16:15,020 --> 00:16:16,920
and the framerate will drop.

00:16:17,460 --> 00:16:21,520
So we thought if we can't do much work on the main thread,

00:16:21,520 --> 00:16:29,460
can we use WebWorkers and concurrency model to build applications where most of the logic runs on a different thread?

00:16:30,700 --> 00:16:35,240
We looked at WebWorkers, and we liked the concurrency and multi-threading model,

00:16:35,240 --> 00:16:39,540
but we were wondering why is nobody using them, this is really cool.

00:16:39,980 --> 00:16:41,660
And soon we discovered why.

00:16:42,200 --> 00:16:47,040
The ease of use is a problem because in a WebWorker context, you don't have access to DOM,

00:16:47,040 --> 00:16:50,360
which means that if your application is running a WebWorker,

00:16:50,360 --> 00:16:55,939
it has to send a lot of messages to the main thread and tell the main tread how to render stuff.

00:16:56,180 --> 00:17:02,780
And this is very cumbersome and becomes a blocker for mainstream use of WebWorkers in applications today.

00:17:02,780 --> 00:17:07,860
So we thought: "Well, Angular is a framework, we're trying to help developers to build applications.

00:17:07,900 --> 00:17:09,100
Maybe we can solve this for them."

00:17:11,060 --> 00:17:18,060
The way we thought about this was: we are not coupled to DOM anymore because of the earlier decision we made,

00:17:18,060 --> 00:17:20,980
what if we decoupled the rendering completely

00:17:21,740 --> 00:17:28,060
and made it something loggable so that we can either render to DOM directly from the main thread

00:17:28,220 --> 00:17:35,640
or we can run the application in the WebWorker thread, and use proxy and internal messaging to handle all the rendering.

00:17:35,780 --> 00:17:40,040
And this is what we did with Angular – we built it so that if you want to use Webworkers,

00:17:40,040 --> 00:17:47,720
you can take your application and just move it to the WebWorker thread and run it from there just by changing the bootstrap call.

00:17:48,080 --> 00:17:52,000
This assumes that you are not doing any custom DOM manipulation, and if you are,

00:17:52,000 --> 00:17:55,480
then we have APIs that allow you to do that from the WebWorker thread as well.

00:17:57,460 --> 00:18:03,980
So with these smooth applications, another inspiration that we saw,

00:18:04,420 --> 00:18:08,660
was we have smooth applications, but we want them to start fast.

00:18:09,280 --> 00:18:18,040
And there was a project Meteor and several others that explore the path of so-called isomorphic applications.

00:18:18,220 --> 00:18:22,260
Those are, basically, applications that can run on the server, render static HTML,

00:18:22,260 --> 00:18:27,440
shoot it to the browser where browser quickly renders it, and while the users are looking at static HTML,

00:18:27,480 --> 00:18:33,140
in the background, the client-side application version of that application is bootstrapping,

00:18:33,140 --> 00:18:39,580
and eventually takes over, so it can handle all of the interactions with the user.

00:18:39,580 --> 00:18:43,480
So you get the best of both words.

00:18:43,880 --> 00:18:47,920
You get the fast bootstrap the server-side rendering gives you,

00:18:47,920 --> 00:18:51,320
but also all the interactivity of client-side applications.

00:18:52,080 --> 00:18:58,879
And not only this is cool about server-side rendering, the things Meteor did,

00:18:59,120 --> 00:19:02,800
but it can also improve search engine optimalization.

00:19:02,900 --> 00:19:11,100
If you are building applications for crawlers that require static HTML, Google already handles JavaScript

00:19:11,100 --> 00:19:15,360
and files the application, so it's not a big deal for Google, but there are many other crawlers that don't.

00:19:15,680 --> 00:19:18,400
Having server-side rendering can help.

00:19:18,460 --> 00:19:23,480
And lastly, if you want the application to be shared widely on Facebook, Twitter, Google+,

00:19:23,480 --> 00:19:28,900
and whatever social media you're using, having an ability to generate previews is also very powerful.

00:19:30,060 --> 00:19:36,080
So we took all of these ideas and built something called Universal.

00:19:37,300 --> 00:19:42,980
It's a server-side rendering for Angular, and it works quite well for these kinds of use cases.

00:19:44,280 --> 00:19:48,520
We talked about mobile quite a bit today, but let's dive deeper.

00:19:48,740 --> 00:19:53,620
Let's see what it is that makes mobile applications different and how these requirements

00:19:53,620 --> 00:19:56,980
should influence a framework like Angular.

00:19:57,840 --> 00:20:02,659
One of the things that is different on mobile applications is that usually run on devices

00:20:02,659 --> 00:20:07,699
that usually have lower memory than the desktop devices that we use.

00:20:08,520 --> 00:20:15,520
What this means for a framework or applications in general is that you should generate very little garbage

00:20:15,520 --> 00:20:19,639
so that you minimize garbage collection so that you don't have garbage collection pauses

00:20:19,639 --> 00:20:21,100
and a small memory footprint.

00:20:21,760 --> 00:20:28,640
This is what we built into Angular to make sure we generate very little garbage, and we don't consume much memory.

00:20:30,800 --> 00:20:36,000
Now a thing that's very specific to mobile applications is that they run on devices that have a slow CPU.

00:20:36,000 --> 00:20:41,440
Especially the low-end devices, even when they are multi-core, the core is not very powerful,

00:20:41,520 --> 00:20:45,840
so you want the code that runs of on them as efficient as possible.

00:20:46,380 --> 00:20:54,800
This is why we did a ton of research to see what kind of code optimizes in the best way the virtual machines

00:20:54,800 --> 00:21:01,160
that run JavaScript and wrote the hot pieces of code in Angular

00:21:01,160 --> 00:21:05,940
and also the code we generate in a way that is very easy for VMs to optimize.

00:21:07,100 --> 00:21:12,700
And lastly, mobile devices are mobile, so they often have to deal with slow network,

00:21:12,920 --> 00:21:18,940
even though we live in cities where we have 4G connection, as soon as you enter a building

00:21:18,940 --> 00:21:22,020
or you pass under bridge, your connection might drop.

00:21:22,440 --> 00:21:28,060
And that's why having small payload size is very important.

00:21:28,380 --> 00:21:33,740
This is why we thought a lot about how can we reduce the payload size of Angular,

00:21:33,740 --> 00:21:39,720
the application but also the third-party components that are used for building Angular applications.

00:21:39,720 --> 00:21:45,020
And additionally we thought about ways how to make lazy loading very simple to use

00:21:45,140 --> 00:21:50,819
so that you upfront load only the code that is necessary to bootstrap the application

00:21:50,820 --> 00:21:55,580
and lazy load the code that is needed later when it's needed.

00:21:57,460 --> 00:22:05,900
Around 2016 or late 2015, Progressive Web Apps started to get some traction.

00:22:06,240 --> 00:22:08,819
What are Progressive Web Apps? How are they different?

00:22:08,820 --> 00:22:12,200
The things we like about Progressive Web Apps is that they work offline,

00:22:12,240 --> 00:22:20,020
they use smart caching strategies, and they look and feel and have this user experience affordances

00:22:20,020 --> 00:22:26,340
that are more common to mobile devices, native mobile applications, than they are to web applications.

00:22:26,740 --> 00:22:32,740
And this is why we invested heavily into Progressive Web Apps and we made sure that Angular

00:22:32,740 --> 00:22:34,359
is a suitable platform for building PWAs.

00:22:35,100 --> 00:22:43,299
I've already mentioned that with the decoupling from DOM, we're able to render into multiple targets with Angular.

00:22:43,660 --> 00:22:53,700
and what was interesting about this is that it really took off and inspired many people to build

00:22:53,700 --> 00:22:55,500
integrations with Angular.

00:22:55,580 --> 00:23:04,140
We saw frameworks like Ionic, Onsen UI, or NativeScript taking Angular while it was still being developed,

00:23:04,260 --> 00:23:13,700
while it was not stable, and started integrating with it, validating some of the ideas or pointing out flaws.

00:23:13,800 --> 00:23:19,400
We've even seen integrations with Electron.

00:23:19,620 --> 00:23:24,980
This was awesome because it gave us very good feedback on what works and doesn't

00:23:24,980 --> 00:23:26,620
before we even went final.

00:23:28,460 --> 00:23:34,460
One of the last things that we added to Angular earlier this year was CodeGen,

00:23:34,460 --> 00:23:38,020
generating code ahead of time of compilation.

00:23:38,320 --> 00:23:44,860
What this means is that when Angular starts the applications, it analyzes it,

00:23:44,860 --> 00:23:52,260
and looks at all the metadata, the templates, the binding, the overall application composition,

00:23:52,260 --> 00:23:59,160
and tries to understand it so that it generate code that is tailored to that specific application.

00:24:01,020 --> 00:24:03,500
Not only this allows us to generate very efficient code,

00:24:03,500 --> 00:24:10,360
we can do this ahead of time in a build step so that we don't need to do this when the application is starting,

00:24:10,360 --> 00:24:18,100
which is important because it means that we can lower the payload size because we don't need to ship a big chunk of the framework,

00:24:18,100 --> 00:24:21,779
the complier actually makes most of the framework at this point,

00:24:22,380 --> 00:24:27,320
we can just use it in a build step and not chip into the runtime, into production.

00:24:28,460 --> 00:24:32,940
But it also allows us to significantly improve the bootstrap speed

00:24:33,140 --> 00:24:36,660
because there is nothing to analyze when the application's starting,

00:24:36,700 --> 00:24:41,919
we already have the code that will generate the UI for the user so that the user can start using the application

00:24:42,020 --> 00:24:43,080
right away.

00:24:44,700 --> 00:24:49,980
And we also get error checking. We know about the errors during the build steps

00:24:49,980 --> 00:24:54,760
so that you are not surprised about problems in production, and this is quite important.

00:24:56,400 --> 00:24:59,440
I couldn't give a talk about Angular without mentioning the community.

00:24:59,540 --> 00:25:04,040
When we started in 2009, community was not afterthought.

00:25:04,040 --> 00:25:06,140
It was something we built into the framework

00:25:06,140 --> 00:25:10,180
because we believe that having a community of good people around the framework

00:25:10,180 --> 00:25:15,080
will make the framework very strong and it will pay off in the long run.

00:25:16,020 --> 00:25:22,120
It's not an easy investment, it takes a lot of time working with people, but it's also very rewarding.

00:25:22,120 --> 00:25:26,580
And it really paid off with Angular 2 because by the time we were ready to ship,

00:25:26,880 --> 00:25:33,820
there were things like courses, tutorials, books, events, and integration with partners

00:25:33,820 --> 00:25:41,120
that were ready, and these were things that were giving us the feedback before we even went final.

00:25:46,720 --> 00:25:51,680
I mentioned at the beginning of my talk that I'm hoping to convince you that

00:25:57,140 --> 00:25:59,379
software is not build in a vacuum.

00:26:04,400 --> 00:26:09,280
And just about a month and a half ago, we finally managed to ship Angular 2,

00:26:10,180 --> 00:26:16,299
and I find this to be really a tribute to not only the core team who worked hard to launch the framework,

00:26:16,300 --> 00:26:19,820
but also to the community and the whole web ecosystem.

00:26:19,820 --> 00:26:26,080
People like you that contributed with their ideas, with the problems that you were solving while building applications,

00:26:26,380 --> 00:26:32,800
that made Angular better, and I'm hoping that Angular will further keep on improving the ecosystem as well.

00:26:33,380 --> 00:26:38,320
So at the beginning I told you that no software is made in a vacuum.

00:26:38,320 --> 00:26:41,120
I hope that I provided sufficient evidence that this is the case.

00:26:41,320 --> 00:26:47,960
And I'm hoping that you will walk away from this talk with your mind open, and you will look for new ideas

00:26:48,000 --> 00:26:53,080
that can influence how you think about problems, how you approach your life and your projects as well,

00:26:53,220 --> 00:26:57,040
and how these ideas can make your projects much better.

00:26:58,100 --> 00:26:58,819

YouTube URL: https://www.youtube.com/watch?v=41ffY2whXoU


