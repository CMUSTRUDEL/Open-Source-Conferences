Title: ReactiveConf 2016 - Guillermo Rauch: What's Next? Exploring the future of React
Publication date: 2016-11-25
Playlist: ReactiveConf 2016
Description: 
	https://reactiveconf.com 

Meet those driving the change! World-renowned mobile and web innovators got together for three days in one town.

ReactiveConf, October 26 - 28 2016, Bratislava, Slovakia

---

Guillermo Rauch: What's Next? Exploring the future of React

This talk will explore future directions for the creation of reactive applications.

---

Have you heard about ReactiveConf? According to tech superstars such as David Nolen, Richard Feldman, or Brent Vatne, itâ€™s the best conference on web and mobile app development! It focuses on all things React and beyond and takes place annually in Bratislava, Slovakia.

In 2016, more than 700 attendees from all over the world spent three days in Bratislava getting inspired, sharing amazing new ideas, and meeting more than 30 awesome speakers from companies such as Google, Cognitect, NoRedInk, RethinkDB, Airbnb, Microsoft, Facebook, and the list could go on forever.

If you want to be part of the next event, get your tickets now at https://reactiveconf.com, and React with us!
Captions: 
	00:00:04,080 --> 00:00:08,549
I was just mentioning I'm like a

00:00:06,029 --> 00:00:10,799
just-in-time compiler in that I usually

00:00:08,549 --> 00:00:14,190
show up right before my presentation and

00:00:10,799 --> 00:00:18,270
today over miscalculated so I'm sorry

00:00:14,190 --> 00:00:21,990
over so the talk is called what's next

00:00:18,270 --> 00:00:24,570
to react and it was sort of meant to be

00:00:21,990 --> 00:00:27,119
a pun because when I sent the

00:00:24,570 --> 00:00:28,650
presentation title this project next

00:00:27,119 --> 00:00:32,099
that I'm going to be talking about today

00:00:28,650 --> 00:00:34,559
wasn't public yet it's been made public

00:00:32,099 --> 00:00:37,920
in the last 48 hours so I'll be talking

00:00:34,559 --> 00:00:39,510
a lot about it today before I go on I'll

00:00:37,920 --> 00:00:42,059
tell you a little bit about me my name

00:00:39,510 --> 00:00:43,830
is guillermo rauch i'm on pretty much

00:00:42,059 --> 00:00:47,940
every social media website that I could

00:00:43,830 --> 00:00:50,010
get my username on as Reggie I'm the CEO

00:00:47,940 --> 00:00:53,760
and co-founder of a company called Zeit

00:00:50,010 --> 00:00:56,970
and I blog at Roger Gigi calm I don't

00:00:53,760 --> 00:00:59,400
blog often but when I do it's very long

00:00:56,970 --> 00:01:02,000
essays so brace yourselves and I'm going

00:00:59,400 --> 00:01:05,129
to be talking about two of those today

00:01:02,000 --> 00:01:09,030
so we're known for this product called

00:01:05,129 --> 00:01:12,750
now you're gonna be seeing this sort of

00:01:09,030 --> 00:01:14,250
scheme during my presentation now is a

00:01:12,750 --> 00:01:17,220
service that takes in your source code

00:01:14,250 --> 00:01:20,880
and uploads through the cloud deploys it

00:01:17,220 --> 00:01:23,250
and scales scales it seamlessly so your

00:01:20,880 --> 00:01:25,530
project could have a docker file package

00:01:23,250 --> 00:01:29,910
at Jason or maybe it's just a bunch of

00:01:25,530 --> 00:01:34,320
HTML files you execute this one command

00:01:29,910 --> 00:01:35,909
now we give you a new URL for each

00:01:34,320 --> 00:01:39,210
deployment this is why we call it

00:01:35,909 --> 00:01:40,860
immutable deployment and if you want to

00:01:39,210 --> 00:01:43,590
learn more about it just go to now that

00:01:40,860 --> 00:01:45,930
is H and and this is important because

00:01:43,590 --> 00:01:51,740
this approach of just doing something

00:01:45,930 --> 00:01:54,420
with one command or expressing your

00:01:51,740 --> 00:01:57,330
workflows in this way it's very critical

00:01:54,420 --> 00:02:01,200
and it also explains a lot about this

00:01:57,330 --> 00:02:04,140
project next so next is is a framework

00:02:01,200 --> 00:02:07,110
for universal JavaScript web

00:02:04,140 --> 00:02:11,430
applications because I'm a big believer

00:02:07,110 --> 00:02:13,680
in GDD coined by me as far as I know

00:02:11,430 --> 00:02:16,440
give driven development I'll show you a

00:02:13,680 --> 00:02:18,170
quick gift of how next works you start

00:02:16,440 --> 00:02:20,720
with a package of JSON file

00:02:18,170 --> 00:02:24,410
you include the next dependency and you

00:02:20,720 --> 00:02:26,930
just run next you go to your URL and you

00:02:24,410 --> 00:02:29,180
start populating your application

00:02:26,930 --> 00:02:32,030
directly in the file system so here I'm

00:02:29,180 --> 00:02:35,209
going to define the index route inside

00:02:32,030 --> 00:02:37,819
the pages directory and all it does is

00:02:35,209 --> 00:02:40,040
JavaScript functions and components so

00:02:37,819 --> 00:02:40,670
in this case I'm going to return some

00:02:40,040 --> 00:02:43,850
JSX

00:02:40,670 --> 00:02:45,440
and hot code reloading and server-side

00:02:43,850 --> 00:02:47,840
rendering and all of that is configured

00:02:45,440 --> 00:02:50,150
on your behalf so by the time I save it

00:02:47,840 --> 00:02:52,250
it hot code reloads notice that here I'm

00:02:50,150 --> 00:02:53,989
using this link component that I'm gonna

00:02:52,250 --> 00:02:56,959
be talking about later I made a

00:02:53,989 --> 00:02:59,690
client-side route transition to the

00:02:56,959 --> 00:03:02,209
about page and here I sort of show off

00:02:59,690 --> 00:03:04,910
the counterpart to the stateless

00:03:02,209 --> 00:03:08,150
function component which is defining a

00:03:04,910 --> 00:03:10,760
class that gets some data before it's

00:03:08,150 --> 00:03:13,970
rendered through this method called get

00:03:10,760 --> 00:03:17,690
initial props and then we just return

00:03:13,970 --> 00:03:19,700
some JSX and by the time I save it this

00:03:17,690 --> 00:03:22,700
particular example shows off the

00:03:19,700 --> 00:03:25,190
capability of fetching data isomorphic

00:03:22,700 --> 00:03:28,280
li so by inspecting that request

00:03:25,190 --> 00:03:30,500
parameter in get initial props I can

00:03:28,280 --> 00:03:32,600
determine if I'm in the server context

00:03:30,500 --> 00:03:34,549
or in the client context and notice that

00:03:32,600 --> 00:03:36,739
when I serve a render it's gonna say

00:03:34,549 --> 00:03:38,690
server when I make client transitions

00:03:36,739 --> 00:03:42,019
it's gonna say client so that's a very

00:03:38,690 --> 00:03:43,910
very simple approach to recap we take

00:03:42,019 --> 00:03:45,590
advantage of the filesystem as an API so

00:03:43,910 --> 00:03:49,430
all you do is create a pages directory

00:03:45,590 --> 00:03:51,769
and inside you declare your components

00:03:49,430 --> 00:03:53,209
you can override this as well and I'll

00:03:51,769 --> 00:03:55,010
talk about that later on

00:03:53,209 --> 00:03:57,260
but this is basically all it takes to

00:03:55,010 --> 00:04:00,440
start your universal java application

00:03:57,260 --> 00:04:02,630
there are some principles about neck's

00:04:00,440 --> 00:04:05,810
that are worth mentioning so easy start

00:04:02,630 --> 00:04:08,209
obviously you just run next that's why I

00:04:05,810 --> 00:04:10,250
said you know to deploy you just run now

00:04:08,209 --> 00:04:13,190
to create your application you just run

00:04:10,250 --> 00:04:15,859
next it's a small and minimalistic every

00:04:13,190 --> 00:04:18,049
single feature we've included has been

00:04:15,859 --> 00:04:19,579
very purposefully included and we're

00:04:18,049 --> 00:04:21,680
very mindful about the bundle size

00:04:19,579 --> 00:04:23,810
because we're big believers in this idea

00:04:21,680 --> 00:04:25,460
of server rendering as a way of getting

00:04:23,810 --> 00:04:27,919
the content out of the use of really

00:04:25,460 --> 00:04:30,650
quickly we are very mindful about our

00:04:27,919 --> 00:04:32,960
runtime size size as well

00:04:30,650 --> 00:04:35,690
so out-of-the-box we do universal and

00:04:32,960 --> 00:04:38,419
isomorphic rendering hot code reloading

00:04:35,690 --> 00:04:41,060
so we use webpack and babel underneath

00:04:38,419 --> 00:04:43,729
which you'll be able to expose and

00:04:41,060 --> 00:04:46,160
configure in your behalf as well we do

00:04:43,729 --> 00:04:48,139
lazy loading and code splitting

00:04:46,160 --> 00:04:49,850
basically instead of generating a big

00:04:48,139 --> 00:04:52,639
bundle for your entire application each

00:04:49,850 --> 00:04:55,910
top level component creates its own

00:04:52,639 --> 00:04:58,669
bundle that gets dynamically or loaded

00:04:55,910 --> 00:05:01,160
with a set of render and then the

00:04:58,669 --> 00:05:03,860
approach to deploy this to take it to

00:05:01,160 --> 00:05:07,010
production is you just run next build

00:05:03,860 --> 00:05:08,840
and then next start so there is

00:05:07,010 --> 00:05:11,270
basically add there's a very simple

00:05:08,840 --> 00:05:13,130
workflow for the development side of

00:05:11,270 --> 00:05:14,780
things which enables hot code reloading

00:05:13,130 --> 00:05:17,960
and some other features and the

00:05:14,780 --> 00:05:19,850
production ready workflow which involves

00:05:17,960 --> 00:05:23,419
producing and compressing bundles and

00:05:19,850 --> 00:05:25,160
generating basically a cache of the

00:05:23,419 --> 00:05:29,570
routes that your application exposes and

00:05:25,160 --> 00:05:31,910
so on so before I go into how we came up

00:05:29,570 --> 00:05:33,289
with this set of constraints and the

00:05:31,910 --> 00:05:35,810
science I'm going to talk about what

00:05:33,289 --> 00:05:38,030
inspired is so in 2014 I wrote this

00:05:35,810 --> 00:05:41,450
essay called the seven principles of

00:05:38,030 --> 00:05:43,490
rich web applications and in the end I

00:05:41,450 --> 00:05:44,690
mentioned that if you follow these seven

00:05:43,490 --> 00:05:48,139
principles you would have built a

00:05:44,690 --> 00:05:52,160
unicorn so you can think of necks as our

00:05:48,139 --> 00:05:54,620
approach to taking your source code and

00:05:52,160 --> 00:05:56,389
outputting a unicorn and this is

00:05:54,620 --> 00:05:57,349
basically what it does so the first

00:05:56,389 --> 00:05:58,940
principle that I think the most

00:05:57,349 --> 00:06:00,970
important one here is that server

00:05:58,940 --> 00:06:04,820
rendering is not optional when you're

00:06:00,970 --> 00:06:08,780
designing an application the TLDR of

00:06:04,820 --> 00:06:11,389
that is perhaps it's not as common to

00:06:08,780 --> 00:06:12,530
think that today but at the time a lot

00:06:11,389 --> 00:06:15,039
of people thought that server rendering

00:06:12,530 --> 00:06:17,750
had exclusively to deal with for example

00:06:15,039 --> 00:06:21,020
Google's ability to access your content

00:06:17,750 --> 00:06:22,699
a lot of crawlers have since improved

00:06:21,020 --> 00:06:23,960
and they can dynamically execute

00:06:22,699 --> 00:06:27,470
JavaScript and so on

00:06:23,960 --> 00:06:29,479
but the principle that if I can from the

00:06:27,470 --> 00:06:32,120
server perform a lot of optimizations in

00:06:29,479 --> 00:06:34,639
output HTML I'm much more likely to have

00:06:32,120 --> 00:06:36,289
greater performance than not and in

00:06:34,639 --> 00:06:38,090
addition there are several features that

00:06:36,289 --> 00:06:40,340
are critical for web applications like

00:06:38,090 --> 00:06:42,919
including and responding with certain

00:06:40,340 --> 00:06:44,070
meta headers for social media websites

00:06:42,919 --> 00:06:45,630
and so on so the

00:06:44,070 --> 00:06:48,030
there are a lot of advantages to

00:06:45,630 --> 00:06:51,120
thinking about server rendering and I'm

00:06:48,030 --> 00:06:54,540
gonna mention three in particular so the

00:06:51,120 --> 00:06:55,740
first one is this lifecycle of the

00:06:54,540 --> 00:06:59,400
interaction between the user and the

00:06:55,740 --> 00:07:01,440
server starts with a URL for example you

00:06:59,400 --> 00:07:02,250
go to a page called a slash user and you

00:07:01,440 --> 00:07:05,460
pass it an ID

00:07:02,250 --> 00:07:08,610
therefore the server already knows what

00:07:05,460 --> 00:07:10,350
the user is interested in so the server

00:07:08,610 --> 00:07:12,780
can perform a lot of optimizations for

00:07:10,350 --> 00:07:13,550
example prefetch that data and respond

00:07:12,780 --> 00:07:17,070
it directly

00:07:13,550 --> 00:07:19,440
number to the server already knows the

00:07:17,070 --> 00:07:22,560
capability of the user so for example if

00:07:19,440 --> 00:07:24,120
I go to github.com there are two

00:07:22,560 --> 00:07:25,620
different representations for that page

00:07:24,120 --> 00:07:27,480
whether you're logged in or logged out

00:07:25,620 --> 00:07:29,790
so with server rendering we have the

00:07:27,480 --> 00:07:32,220
ability to return a layout that matches

00:07:29,790 --> 00:07:33,840
that user's capability in this case you

00:07:32,220 --> 00:07:35,940
know you would render a login form or

00:07:33,840 --> 00:07:39,240
you would render the admin panel of your

00:07:35,940 --> 00:07:42,690
application finally because the server

00:07:39,240 --> 00:07:44,400
can return an HTML and CSS stream we can

00:07:42,690 --> 00:07:46,110
take advantage of the fact that the

00:07:44,400 --> 00:07:47,840
browser can render progressively if

00:07:46,110 --> 00:07:50,250
you're just building a single page

00:07:47,840 --> 00:07:52,710
application now the server has to

00:07:50,250 --> 00:07:54,120
download all the JavaScript code perhaps

00:07:52,710 --> 00:07:56,790
you've made some Network level

00:07:54,120 --> 00:07:58,620
opportunities to push data but still we

00:07:56,790 --> 00:08:03,480
have to pre-process interpret run

00:07:58,620 --> 00:08:05,370
everything and then pass some Dom to the

00:08:03,480 --> 00:08:06,960
browser so that the user sees the data

00:08:05,370 --> 00:08:08,690
that they are interested in so because

00:08:06,960 --> 00:08:11,100
of these three reasons we think that a

00:08:08,690 --> 00:08:14,400
this type of ideal web application

00:08:11,100 --> 00:08:16,500
necessitates server rendering the rest

00:08:14,400 --> 00:08:18,720
of the principles have to deal with ok

00:08:16,500 --> 00:08:21,030
server rendering is so critical do they

00:08:18,720 --> 00:08:24,750
actually need client-side JavaScript at

00:08:21,030 --> 00:08:26,610
all and this is a very nernst theme I

00:08:24,750 --> 00:08:28,980
think because for a lot of applications

00:08:26,610 --> 00:08:31,560
arguably don't need any client-side

00:08:28,980 --> 00:08:33,450
JavaScript for example pretty much

00:08:31,560 --> 00:08:35,719
everyone here for example uses hacker

00:08:33,450 --> 00:08:38,040
news I think hacker news probably has

00:08:35,719 --> 00:08:40,349
some lines of JavaScript for toggling

00:08:38,040 --> 00:08:42,930
comments and I would guess that that's

00:08:40,349 --> 00:08:44,610
pretty much it and it's at the center of

00:08:42,930 --> 00:08:46,500
this industry yet it's never used any

00:08:44,610 --> 00:08:48,780
client-side JavaScript so with next

00:08:46,500 --> 00:08:50,250
we've made it so that you can also build

00:08:48,780 --> 00:08:52,620
that sort of application you don't

00:08:50,250 --> 00:08:54,780
really need to execute our runtime at

00:08:52,620 --> 00:08:55,740
all so we have this flexibility to

00:08:54,780 --> 00:08:56,940
decide how much

00:08:55,740 --> 00:08:59,190
to render on the server how much you

00:08:56,940 --> 00:09:02,430
render in the client and so on we do

00:08:59,190 --> 00:09:04,560
think that for a big space of

00:09:02,430 --> 00:09:07,800
applications client-side JavaScript is

00:09:04,560 --> 00:09:10,709
critical for example features pertaining

00:09:07,800 --> 00:09:12,990
to offline access or getting instant

00:09:10,709 --> 00:09:15,240
feedback after you perform a certain

00:09:12,990 --> 00:09:17,610
action without having to wait on the

00:09:15,240 --> 00:09:20,100
network in reality this is sort of a

00:09:17,610 --> 00:09:21,630
function of the quality of our

00:09:20,100 --> 00:09:24,089
connectivity right because if the server

00:09:21,630 --> 00:09:26,250
is so close to the user as it ideally

00:09:24,089 --> 00:09:29,430
should be maybe we don't really need

00:09:26,250 --> 00:09:31,050
that much client-side JavaScript this

00:09:29,430 --> 00:09:33,630
sixth principle how to deal with

00:09:31,050 --> 00:09:35,700
thinking about code the same way we

00:09:33,630 --> 00:09:39,450
think about data so it's pretty obvious

00:09:35,700 --> 00:09:41,399
to anyone today that ideally the data

00:09:39,450 --> 00:09:44,190
that's rendered on the screen updates in

00:09:41,399 --> 00:09:46,560
real time if something changes on the

00:09:44,190 --> 00:09:48,959
backend or the data set that the user is

00:09:46,560 --> 00:09:51,450
rendering changes is pretty much well

00:09:48,959 --> 00:09:53,490
accepted today that we need to show

00:09:51,450 --> 00:09:54,660
those changes to the user immediately we

00:09:53,490 --> 00:09:56,490
think that that should be also the case

00:09:54,660 --> 00:09:58,800
for code and there are a lot of

00:09:56,490 --> 00:10:00,180
similarities between creating a model

00:09:58,800 --> 00:10:03,450
for an application that is able to

00:10:00,180 --> 00:10:06,209
update code and update data in real time

00:10:03,450 --> 00:10:09,089
and finally and this is perhaps the most

00:10:06,209 --> 00:10:11,730
important notion today is that the key

00:10:09,089 --> 00:10:15,480
to great performance is anticipation or

00:10:11,730 --> 00:10:17,730
prediction so this goes both for data

00:10:15,480 --> 00:10:18,870
like I said we can anticipate what data

00:10:17,730 --> 00:10:20,910
the user is going to be interested in

00:10:18,870 --> 00:10:23,100
based on the URL but it also might have

00:10:20,910 --> 00:10:25,079
to do with UI for example we may need to

00:10:23,100 --> 00:10:27,420
prefetch a certain part of the screen

00:10:25,079 --> 00:10:30,510
based on the trajectory of the input and

00:10:27,420 --> 00:10:33,320
so on so the big question that remains

00:10:30,510 --> 00:10:36,510
in our minds to complete this vision was

00:10:33,320 --> 00:10:39,240
how do we resume the rendering of some

00:10:36,510 --> 00:10:41,459
contents and Dom that's been rendered on

00:10:39,240 --> 00:10:45,390
the server this is a pretty tricky thing

00:10:41,459 --> 00:10:47,100
to do and that's where react came in and

00:10:45,390 --> 00:10:49,380
for us solve this problem in a very very

00:10:47,100 --> 00:10:52,500
elegant way by introducing a new model

00:10:49,380 --> 00:10:55,350
for how to reason about the separation

00:10:52,500 --> 00:10:57,450
between data and UI I wrote this

00:10:55,350 --> 00:10:59,880
subsequent essay Pierrot I that went

00:10:57,450 --> 00:11:03,029
into this idea that we're thinking about

00:10:59,880 --> 00:11:05,130
our UI as a pure function of data and

00:11:03,029 --> 00:11:07,589
and this is one of the two things that

00:11:05,130 --> 00:11:08,940
is critical to make this work is we have

00:11:07,589 --> 00:11:09,690
to have a render function that doesn't

00:11:08,940 --> 00:11:12,150
know

00:11:09,690 --> 00:11:14,610
or doesn't fetch the data directly it's

00:11:12,150 --> 00:11:16,230
just accessing some state or some props

00:11:14,610 --> 00:11:17,490
perhaps the props like I mentioned

00:11:16,230 --> 00:11:20,640
earlier come from the server perhaps

00:11:17,490 --> 00:11:21,930
they come from the client and secondly

00:11:20,640 --> 00:11:23,730
and this is the other critical

00:11:21,930 --> 00:11:25,920
ingredient to this is that you need to

00:11:23,730 --> 00:11:28,320
be able to take control of the lifecycle

00:11:25,920 --> 00:11:29,850
in other words we have to think of

00:11:28,320 --> 00:11:30,990
rendering from the server and then

00:11:29,850 --> 00:11:33,330
picking it up on the client as a

00:11:30,990 --> 00:11:34,980
continuation this is why it's so

00:11:33,330 --> 00:11:37,920
critical that in react for example

00:11:34,980 --> 00:11:39,960
component did mount only actually fires

00:11:37,920 --> 00:11:42,090
if the component has been mounted onto

00:11:39,960 --> 00:11:45,990
the screen so we can add a lot of code

00:11:42,090 --> 00:11:47,070
that's client to specific and an example

00:11:45,990 --> 00:11:49,800
of that would be that we started with a

00:11:47,070 --> 00:11:51,990
static snapshot of data and on upon

00:11:49,800 --> 00:11:53,970
component did mount we subscribe to

00:11:51,990 --> 00:11:55,830
real-time updates to that data or

00:11:53,970 --> 00:11:58,950
perhaps we have to invalidate it all

00:11:55,830 --> 00:12:00,990
together this is why top level top-down

00:11:58,950 --> 00:12:02,640
rendering is so important because we

00:12:00,990 --> 00:12:03,960
have to consider that when you serve a

00:12:02,640 --> 00:12:05,670
render something and then you pick it up

00:12:03,960 --> 00:12:07,620
on the client it's almost like you've

00:12:05,670 --> 00:12:09,360
gone offline and then there's an

00:12:07,620 --> 00:12:11,880
uncertainty about the state of the data

00:12:09,360 --> 00:12:16,020
that the user subscribed to is in by the

00:12:11,880 --> 00:12:18,200
time he or she reconnects so the other

00:12:16,020 --> 00:12:21,210
critical thing that was missing was

00:12:18,200 --> 00:12:23,370
determining how do we slice that

00:12:21,210 --> 00:12:25,590
lifecycle how do we determine that

00:12:23,370 --> 00:12:28,220
something is ready to be server

00:12:25,590 --> 00:12:31,620
rendering and this is an asynchronous

00:12:28,220 --> 00:12:33,870
process so we spent a lot of time in

00:12:31,620 --> 00:12:36,660
this state thinking about this problem

00:12:33,870 --> 00:12:38,670
and what we came up with was the

00:12:36,660 --> 00:12:41,010
counterpart to a function that was

00:12:38,670 --> 00:12:43,170
already exposed or method that was

00:12:41,010 --> 00:12:45,120
already exposed and react whenever you

00:12:43,170 --> 00:12:46,500
were using react create class which was

00:12:45,120 --> 00:12:48,270
get initial State

00:12:46,500 --> 00:12:50,550
we thought about adding the counterpart

00:12:48,270 --> 00:12:54,360
of this as a static method to classes

00:12:50,550 --> 00:12:56,910
which is get initial props so with this

00:12:54,360 --> 00:12:58,200
we can aesthetically analyze classes

00:12:56,910 --> 00:13:00,930
that are exposed to stop level

00:12:58,200 --> 00:13:03,180
components and decide okay I need to

00:13:00,930 --> 00:13:05,610
wait on this function to complete before

00:13:03,180 --> 00:13:06,990
I proceed to serve a render so this has

00:13:05,610 --> 00:13:10,230
numerous advantages also for the

00:13:06,990 --> 00:13:12,870
client-side but it's also very easy it's

00:13:10,230 --> 00:13:15,870
very easy and very clear how and what's

00:13:12,870 --> 00:13:17,850
happening here is what by the time next

00:13:15,870 --> 00:13:19,850
goes and fetches your component this

00:13:17,850 --> 00:13:22,110
function resolves to a JavaScript object

00:13:19,850 --> 00:13:23,459
that's another critical thing because

00:13:22,110 --> 00:13:26,129
you can plug in

00:13:23,459 --> 00:13:28,709
any sort of data adapter here including

00:13:26,129 --> 00:13:30,649
client-side stateful adapters which I'll

00:13:28,709 --> 00:13:34,980
get into in a minute

00:13:30,649 --> 00:13:36,629
by analyzing that those parameters had

00:13:34,980 --> 00:13:38,279
come to get initial probes you're able

00:13:36,629 --> 00:13:41,189
to basically get the data from wherever

00:13:38,279 --> 00:13:43,199
you want so another question that I

00:13:41,189 --> 00:13:46,170
posed in that essay was what is the

00:13:43,199 --> 00:13:49,559
strict technical difference between a

00:13:46,170 --> 00:13:51,899
website and a web app anything this

00:13:49,559 --> 00:13:54,540
question is something that in our minds

00:13:51,899 --> 00:13:55,800
we refer to a lot we say oh that this is

00:13:54,540 --> 00:13:58,110
a web app type thing or this is a

00:13:55,800 --> 00:14:01,139
website type thing but we thus far

00:13:58,110 --> 00:14:04,439
haven't technically delineated which is

00:14:01,139 --> 00:14:06,540
which so I have a contribution to that

00:14:04,439 --> 00:14:09,869
question which I think there are two two

00:14:06,540 --> 00:14:12,149
key things that make something an app as

00:14:09,869 --> 00:14:14,550
opposed to the site or at least that I

00:14:12,149 --> 00:14:19,019
observe in our usage of that one is

00:14:14,550 --> 00:14:20,699
global state if we have an app that is

00:14:19,019 --> 00:14:22,800
extra key server rendered it's

00:14:20,699 --> 00:14:24,600
impossible to keep some state in on the

00:14:22,800 --> 00:14:27,269
client-side in JavaScript and for

00:14:24,600 --> 00:14:31,110
example make a really quick transition

00:14:27,269 --> 00:14:33,600
to another page based on a cache so I

00:14:31,110 --> 00:14:35,839
think that in order to make really great

00:14:33,600 --> 00:14:38,910
UI's you have to have the ability to

00:14:35,839 --> 00:14:41,249
respond optimistically to user input and

00:14:38,910 --> 00:14:44,429
keep some data cached on the client-side

00:14:41,249 --> 00:14:46,350
so this is something that makes for a

00:14:44,429 --> 00:14:50,129
web app type feel as opposed to the

00:14:46,350 --> 00:14:52,410
traditional web 1.0 web site type feel

00:14:50,129 --> 00:14:54,240
and it's also critical for features that

00:14:52,410 --> 00:14:57,149
you might be interested in like offline

00:14:54,240 --> 00:14:59,519
support optimistic feedback based on

00:14:57,149 --> 00:15:03,170
user input the other really important

00:14:59,519 --> 00:15:06,089
notion is ahead of time code loading and

00:15:03,170 --> 00:15:09,449
that's what I was saying that our idea

00:15:06,089 --> 00:15:11,369
of fetching data before these requires

00:15:09,449 --> 00:15:14,249
that it's also true for fetching code

00:15:11,369 --> 00:15:15,899
before the user needs it and it's also

00:15:14,249 --> 00:15:17,639
of course very important if you want to

00:15:15,899 --> 00:15:19,499
create a very good offline experience

00:15:17,639 --> 00:15:21,959
because it allows you to navigate your

00:15:19,499 --> 00:15:23,879
app or website while then for example

00:15:21,959 --> 00:15:25,780
while the user is offline or while

00:15:23,879 --> 00:15:28,540
network problems are occurring

00:15:25,780 --> 00:15:31,090
so to give you an example of the extreme

00:15:28,540 --> 00:15:32,650
of the app side of things when you

00:15:31,090 --> 00:15:34,540
download the Facebook iOS app for

00:15:32,650 --> 00:15:36,940
example you're downloading a 200 mega

00:15:34,540 --> 00:15:38,650
byte code bundle that pretty much has

00:15:36,940 --> 00:15:39,880
every possible interaction that you

00:15:38,650 --> 00:15:42,670
would ever perform with the app

00:15:39,880 --> 00:15:45,420
pre-loaded they have some web views but

00:15:42,670 --> 00:15:48,820
in reality they're going on these

00:15:45,420 --> 00:15:51,160
extreme side of things where the app is

00:15:48,820 --> 00:15:52,840
bound to perform really well even when

00:15:51,160 --> 00:15:55,150
the network is down because you've

00:15:52,840 --> 00:15:58,780
loaded all the code in advance so

00:15:55,150 --> 00:16:02,740
someone did a simple dump of their

00:15:58,780 --> 00:16:05,530
application and basically you can read

00:16:02,740 --> 00:16:07,330
all the class names and I think that

00:16:05,530 --> 00:16:10,240
person concluded there were like 18,000

00:16:07,330 --> 00:16:14,740
classes or so and for those that are

00:16:10,240 --> 00:16:16,930
curious if you sort this the the longest

00:16:14,740 --> 00:16:18,190
classroom is profile set events calendar

00:16:16,930 --> 00:16:20,550
subscription status mutation of the

00:16:18,190 --> 00:16:23,800
music daily factory protocol protocol so

00:16:20,550 --> 00:16:26,620
this is great I think because if you can

00:16:23,800 --> 00:16:28,600
afford to make that initial investment

00:16:26,620 --> 00:16:31,210
in that you downloaded everything

00:16:28,600 --> 00:16:32,860
advanced then by the time you need to

00:16:31,210 --> 00:16:34,210
set events in the calendar with

00:16:32,860 --> 00:16:35,410
subscriptions to the static mutation

00:16:34,210 --> 00:16:37,240
optimistically with payload factory

00:16:35,410 --> 00:16:40,450
protocol protocol the YouTube stream is

00:16:37,240 --> 00:16:42,880
going to be great so our take on this is

00:16:40,450 --> 00:16:46,000
that we can converge those two models

00:16:42,880 --> 00:16:49,180
this is why we have this link component

00:16:46,000 --> 00:16:50,710
built in so link is what I show also in

00:16:49,180 --> 00:16:52,690
the gif it allows you to create

00:16:50,710 --> 00:16:56,339
client-side transitions between routes

00:16:52,690 --> 00:16:59,530
and of course it is optional as well and

00:16:56,339 --> 00:17:00,820
what we do is it's so the reason we need

00:16:59,530 --> 00:17:03,490
is of course the reason we need

00:17:00,820 --> 00:17:05,530
client-side transitions because if we

00:17:03,490 --> 00:17:08,140
want to honor a global client-side cache

00:17:05,530 --> 00:17:11,740
we can't afford to perform whole page

00:17:08,140 --> 00:17:13,060
refreshes every time and secondly in the

00:17:11,740 --> 00:17:15,480
most important thing and this is what

00:17:13,060 --> 00:17:19,300
allows us to converge the app and web

00:17:15,480 --> 00:17:21,130
model is we prefetch links aggressively

00:17:19,300 --> 00:17:25,120
so I'm going to show you an example from

00:17:21,130 --> 00:17:27,220
our website so every time you click

00:17:25,120 --> 00:17:29,650
something on our website everything is

00:17:27,220 --> 00:17:31,120
in mediate and the reason to admit it's

00:17:29,650 --> 00:17:34,060
not because we downloaded a really big

00:17:31,120 --> 00:17:36,940
app j/s bundle is because when you first

00:17:34,060 --> 00:17:38,320
load we serve a render according to what

00:17:36,940 --> 00:17:39,519
the user needs

00:17:38,320 --> 00:17:41,110
it's an interesting patient server

00:17:39,519 --> 00:17:43,360
render because you can see that Code

00:17:41,110 --> 00:17:45,850
mirror which is the editor that we use

00:17:43,360 --> 00:17:48,190
for the API example that's it's not an

00:17:45,850 --> 00:17:50,110
isomorphic component so this is

00:17:48,190 --> 00:17:51,639
something that you could see there in

00:17:50,110 --> 00:17:54,399
action that we're loading a ton of

00:17:51,639 --> 00:17:57,159
JavaScript that is code split for this

00:17:54,399 --> 00:17:58,990
page and it only happened on the client

00:17:57,159 --> 00:18:01,059
but I was already able to consume the

00:17:58,990 --> 00:18:02,769
documentation and while this is

00:18:01,059 --> 00:18:05,529
happening a service worker on the

00:18:02,769 --> 00:18:07,389
background is fetching all the links

00:18:05,529 --> 00:18:09,070
that the user could be interested in in

00:18:07,389 --> 00:18:11,950
the future because they are part of this

00:18:09,070 --> 00:18:15,460
rendering iteration so by the time a I

00:18:11,950 --> 00:18:17,440
go to the blog about next j/s and so it

00:18:15,460 --> 00:18:19,269
are very likely to be pre-loaded so

00:18:17,440 --> 00:18:23,590
that's how we sort of converge those

00:18:19,269 --> 00:18:27,210
ideas it's almost like by prefetching

00:18:23,590 --> 00:18:29,830
aggressively we're doing the and

00:18:27,210 --> 00:18:31,059
analyzing obviously the things that are

00:18:29,830 --> 00:18:33,700
interesting to prefetch not just

00:18:31,059 --> 00:18:35,730
prefetch everything we're able to get

00:18:33,700 --> 00:18:38,019
that both the best of both worlds

00:18:35,730 --> 00:18:40,659
experience where the initial download

00:18:38,019 --> 00:18:43,570
works like the web 1.0 but then we have

00:18:40,659 --> 00:18:46,419
an app style download the entire world

00:18:43,570 --> 00:18:48,309
approach once the page is loaded and

00:18:46,419 --> 00:18:50,490
this is really interesting because it's

00:18:48,309 --> 00:18:53,200
better than an app because you're only

00:18:50,490 --> 00:18:54,700
downloading the subset of the world that

00:18:53,200 --> 00:18:57,820
the user could be interested in

00:18:54,700 --> 00:19:01,179
by analyzing that that tree of

00:18:57,820 --> 00:19:03,970
components and code splitting is what

00:19:01,179 --> 00:19:06,940
prevents the that very big initial

00:19:03,970 --> 00:19:09,549
penalty that a lot of applications incur

00:19:06,940 --> 00:19:12,009
in so this one is an example of code

00:19:09,549 --> 00:19:14,889
mirror but we use d3 in other parts of

00:19:12,009 --> 00:19:16,450
the website for showing UI statistics

00:19:14,889 --> 00:19:18,519
about deployments and these are very

00:19:16,450 --> 00:19:22,360
expensive things and when it comes down

00:19:18,519 --> 00:19:24,850
to scalability of your codebase and your

00:19:22,360 --> 00:19:26,259
teams this is critical because when

00:19:24,850 --> 00:19:27,909
someone is working a slice of the

00:19:26,259 --> 00:19:30,389
application they're not introducing

00:19:27,909 --> 00:19:32,049
global effects that slow down the

00:19:30,389 --> 00:19:35,500
performance of other parts of the

00:19:32,049 --> 00:19:36,850
website and finally there are two things

00:19:35,500 --> 00:19:39,250
that are critical for several rendering

00:19:36,850 --> 00:19:42,850
that we had to handle specially one was

00:19:39,250 --> 00:19:44,620
CSS and one was introducing effects into

00:19:42,850 --> 00:19:46,779
the header so everything is a component

00:19:44,620 --> 00:19:51,920
but in a lot of cases we have to break

00:19:46,779 --> 00:19:54,350
out of the component basically sandbox

00:19:51,920 --> 00:19:56,780
so the the most common thing for this

00:19:54,350 --> 00:19:58,910
type of application is introducing for

00:19:56,780 --> 00:20:01,700
example the meta tag for mobile

00:19:58,910 --> 00:20:02,390
readiness or changing the title from

00:20:01,700 --> 00:20:05,990
page to page

00:20:02,390 --> 00:20:08,420
so we bundle this very handy and small

00:20:05,990 --> 00:20:10,580
component for introducing effects on the

00:20:08,420 --> 00:20:12,470
head of the page and also this is

00:20:10,580 --> 00:20:14,150
important because when we serve a render

00:20:12,470 --> 00:20:17,750
we have to take a slightly different

00:20:14,150 --> 00:20:19,220
path for obtaining this and rendering

00:20:17,750 --> 00:20:22,660
then when you were making client-side

00:20:19,220 --> 00:20:25,010
transitions and the other one is CSS so

00:20:22,660 --> 00:20:29,270
there's been a lot of debate about CSS

00:20:25,010 --> 00:20:32,600
in j/s versus pure CSS and the reason

00:20:29,270 --> 00:20:35,240
that we again picked aside in this

00:20:32,600 --> 00:20:36,560
question so to speak it's because we can

00:20:35,240 --> 00:20:38,900
make a lot of optimizations for the

00:20:36,560 --> 00:20:41,240
server rendering pipeline and it offers

00:20:38,900 --> 00:20:42,650
really great performance for us because

00:20:41,240 --> 00:20:45,560
as you are making transitions between

00:20:42,650 --> 00:20:47,930
client-side pages we want to be able to

00:20:45,560 --> 00:20:49,340
detach styles that are not interested

00:20:47,930 --> 00:20:52,330
interesting anymore

00:20:49,340 --> 00:20:55,880
in addition we found that CSS nsj

00:20:52,330 --> 00:20:58,100
composes a lot better than plain CSS

00:20:55,880 --> 00:21:02,210
style sheets we actually for site

00:20:58,100 --> 00:21:05,060
started with using pre-processed CSS

00:21:02,210 --> 00:21:07,070
that in order to isolate we would

00:21:05,060 --> 00:21:09,770
basically mangle all the class names and

00:21:07,070 --> 00:21:11,570
it didn't scale very well for us in

00:21:09,770 --> 00:21:13,370
particular build time was increasing a

00:21:11,570 --> 00:21:15,950
lot memory usage was increasing a lot

00:21:13,370 --> 00:21:18,800
just to transform and parse all this

00:21:15,950 --> 00:21:20,720
really huge amounts of CSS something

00:21:18,800 --> 00:21:23,570
that we will served empirically is that

00:21:20,720 --> 00:21:25,730
your CSS tends to grow a lot more easily

00:21:23,570 --> 00:21:30,860
and faster than your Jas so this is why

00:21:25,730 --> 00:21:32,870
we expose this CSS nsj approach but

00:21:30,860 --> 00:21:37,520
later on I'll talk about what our long

00:21:32,870 --> 00:21:38,960
term vision for CSS is and those are the

00:21:37,520 --> 00:21:42,650
five things I want to mention about

00:21:38,960 --> 00:21:45,710
what's next for next pun intended so the

00:21:42,650 --> 00:21:48,320
first one is while we what we think that

00:21:45,710 --> 00:21:49,460
you know analyzing the file system

00:21:48,320 --> 00:21:51,560
provides a really great way to get

00:21:49,460 --> 00:21:54,260
started in a lot of cases you do have to

00:21:51,560 --> 00:21:57,230
go in and for example define fancy

00:21:54,260 --> 00:21:59,180
custom routing schemes or interrupt and

00:21:57,230 --> 00:22:01,880
short-circuit a type of request or

00:21:59,180 --> 00:22:05,299
introduce global checks for it requests

00:22:01,880 --> 00:22:07,669
so that's why we're introducing a way of

00:22:05,299 --> 00:22:09,919
buying a handler for the request and

00:22:07,669 --> 00:22:12,529
response lifecycle so you can sort of

00:22:09,919 --> 00:22:14,960
say for example if the request comes for

00:22:12,529 --> 00:22:17,869
the route a you can render component B

00:22:14,960 --> 00:22:20,509
as opposed to letting next decide based

00:22:17,869 --> 00:22:23,629
on the shape of the file system number

00:22:20,509 --> 00:22:26,570
two you might have noticed that in a lot

00:22:23,629 --> 00:22:29,480
of cases we have to import rig from

00:22:26,570 --> 00:22:31,820
react every time you use JSX because the

00:22:29,480 --> 00:22:34,850
compilation results in react create

00:22:31,820 --> 00:22:36,889
element but in reality you're not seeing

00:22:34,850 --> 00:22:40,609
react being used anywhere so it's not

00:22:36,889 --> 00:22:43,129
only confusing but not very agnostic and

00:22:40,609 --> 00:22:45,320
not very general so we would like to see

00:22:43,129 --> 00:22:46,460
in the future and and for each of these

00:22:45,320 --> 00:22:48,440
things that I'm mentioning here we have

00:22:46,460 --> 00:22:50,629
issues where I would love to get input

00:22:48,440 --> 00:22:52,429
from the community we would love to see

00:22:50,629 --> 00:22:54,559
a situation where you don't even have to

00:22:52,429 --> 00:22:56,690
expose you don't even have to import

00:22:54,559 --> 00:22:59,629
react you can just return your JSX

00:22:56,690 --> 00:23:01,249
directly there are a few things that we

00:22:59,629 --> 00:23:03,409
can also get from react in the future

00:23:01,249 --> 00:23:05,600
that are going to make this code even

00:23:03,409 --> 00:23:07,879
smaller so as you can see I crossed out

00:23:05,600 --> 00:23:09,679
the first line so once we get fragments

00:23:07,879 --> 00:23:11,539
we no longer need to do top-level

00:23:09,679 --> 00:23:13,940
wrapping so it's going to be even more

00:23:11,539 --> 00:23:15,879
expressive in that you just return that

00:23:13,940 --> 00:23:19,700
in this case ahead and the paragraph

00:23:15,879 --> 00:23:22,340
then I don't this probably has come up I

00:23:19,700 --> 00:23:22,970
would like to write class directly not

00:23:22,340 --> 00:23:25,100
name

00:23:22,970 --> 00:23:29,320
I think the future that we also will be

00:23:25,100 --> 00:23:33,590
shortening this even further so I think

00:23:29,320 --> 00:23:34,730
the the CSS nsj forces pure CSS debate

00:23:33,590 --> 00:23:37,850
is tricky and I think there are benefits

00:23:34,730 --> 00:23:39,889
of both sides we personally have found

00:23:37,850 --> 00:23:42,139
that CSS and J's fits our workflow a lot

00:23:39,889 --> 00:23:45,109
better it gives us a higher level of

00:23:42,139 --> 00:23:48,369
correctness because we're able to type

00:23:45,109 --> 00:23:51,830
our CSS basically we're able to

00:23:48,369 --> 00:23:53,809
co-locate our CSS and markup better

00:23:51,830 --> 00:23:55,759
which gives us an idea of if the

00:23:53,809 --> 00:23:57,950
components are very well separated or

00:23:55,759 --> 00:24:02,029
not or we were having tons of unneeded

00:23:57,950 --> 00:24:04,369
CSS it allows the or it allows us to not

00:24:02,029 --> 00:24:07,279
fall into the problem having style dot

00:24:04,369 --> 00:24:10,009
CSS and having like dramatic amounts of

00:24:07,279 --> 00:24:13,070
CSS among other problems but I do think

00:24:10,009 --> 00:24:15,799
that we have to be able to reconcile and

00:24:13,070 --> 00:24:17,280
allow for greater CSS to work well

00:24:15,799 --> 00:24:18,810
within this model and

00:24:17,280 --> 00:24:20,730
most important thing for CSS to work

00:24:18,810 --> 00:24:22,350
well within this model is that the CSS

00:24:20,730 --> 00:24:25,980
that you defined within a component only

00:24:22,350 --> 00:24:29,460
impacts that component so perhaps by

00:24:25,980 --> 00:24:32,880
using the web components are custom

00:24:29,460 --> 00:24:35,460
elements slash shadow Dom api's we would

00:24:32,880 --> 00:24:38,820
be able to get rid of the CSS nsj at

00:24:35,460 --> 00:24:41,520
least for the initial presentation of

00:24:38,820 --> 00:24:43,470
the framework and we'll be able to like

00:24:41,520 --> 00:24:45,360
just include regular CSS and in this

00:24:43,470 --> 00:24:46,920
case obviously that paragraph style

00:24:45,360 --> 00:24:51,420
would only apply to that very paragraph

00:24:46,920 --> 00:24:53,220
and it would look a lot shorter and

00:24:51,420 --> 00:24:56,550
nicer as well so that would be the end

00:24:53,220 --> 00:24:59,930
result of this evolution finally we are

00:24:56,550 --> 00:25:02,640
looking into making rendering pluggable

00:24:59,930 --> 00:25:04,230
so for example if you don't want to use

00:25:02,640 --> 00:25:04,710
rigs and if you want to try something

00:25:04,230 --> 00:25:07,560
else

00:25:04,710 --> 00:25:09,750
you all you would have to do is I have a

00:25:07,560 --> 00:25:12,450
really thin layer on top of this that

00:25:09,750 --> 00:25:15,960
registers some hooks for rendering since

00:25:12,450 --> 00:25:18,180
the users and API the contract is very

00:25:15,960 --> 00:25:20,460
simple it's just stateless components as

00:25:18,180 --> 00:25:22,740
functions or classes with a render

00:25:20,460 --> 00:25:24,510
method we think that there's an

00:25:22,740 --> 00:25:29,100
opportunity here for a lot of different

00:25:24,510 --> 00:25:32,010
runners to exist I already said that and

00:25:29,100 --> 00:25:35,310
finally so the approach that we've taken

00:25:32,010 --> 00:25:38,910
with babel is where we're transpiling as

00:25:35,310 --> 00:25:40,380
much as v8 supports so we support async

00:25:38,910 --> 00:25:42,360
functions because they just landed in v8

00:25:40,380 --> 00:25:46,380
we don't support class decorators

00:25:42,360 --> 00:25:48,300
because they're not in v8 yet so this

00:25:46,380 --> 00:25:51,720
kind of takes away a lot of Jas fatigue

00:25:48,300 --> 00:25:54,840
for us because we're sort of targeting a

00:25:51,720 --> 00:25:57,060
very interesting subset we use node 6

00:25:54,840 --> 00:25:58,500
which has a very node is doing a really

00:25:57,060 --> 00:26:00,240
great job at keeping track of the latest

00:25:58,500 --> 00:26:02,400
versions of the AIDS and we normally

00:26:00,240 --> 00:26:05,250
develop an on Chrome which would

00:26:02,400 --> 00:26:07,830
completely eliminate the translation

00:26:05,250 --> 00:26:10,680
step at least for development and then

00:26:07,830 --> 00:26:12,570
you only pay that penalty upon next

00:26:10,680 --> 00:26:14,910
build to be able to be backwards

00:26:12,570 --> 00:26:17,250
compatible but we still think that there

00:26:14,910 --> 00:26:19,770
are very legitimate cases for plugging

00:26:17,250 --> 00:26:22,170
in custom stuff like you might want to

00:26:19,770 --> 00:26:26,880
use decorator so you can add it as a

00:26:22,170 --> 00:26:29,790
Babel can fix them so the two URLs to

00:26:26,880 --> 00:26:30,500
learn more about the project is you can

00:26:29,790 --> 00:26:33,200
go to our blog

00:26:30,500 --> 00:26:38,240
slash necks or you can go to github

00:26:33,200 --> 00:26:40,669
slash zyt slash next yes and finally I

00:26:38,240 --> 00:26:43,100
want to make it really clear that when

00:26:40,669 --> 00:26:46,700
it comes to frameworks we don't think

00:26:43,100 --> 00:26:49,190
there are silver bullets and I tweeted

00:26:46,700 --> 00:26:51,679
this a few weeks ago because I got

00:26:49,190 --> 00:26:54,169
excited about the progress that a lot of

00:26:51,679 --> 00:26:57,470
Wranglers are making in this territory

00:26:54,169 --> 00:26:58,669
like B UJ s and and amber with fast food

00:26:57,470 --> 00:27:00,980
there are a lot of interesting

00:26:58,669 --> 00:27:03,500
approaches solving this problem and with

00:27:00,980 --> 00:27:05,570
now we want to support them all and we

00:27:03,500 --> 00:27:07,370
think that the user experience of the

00:27:05,570 --> 00:27:10,070
entire web is going to become better as

00:27:07,370 --> 00:27:11,450
a result but also there is a lot of

00:27:10,070 --> 00:27:13,700
really interesting feedback to give back

00:27:11,450 --> 00:27:15,919
to the web platform as well like for

00:27:13,700 --> 00:27:18,500
example can we serve a rendered Shadow

00:27:15,919 --> 00:27:21,740
Dom elements and a few interesting

00:27:18,500 --> 00:27:25,760
things that this opens up so that's it

00:27:21,740 --> 00:27:32,179
for today and thank you awesome thank

00:27:25,760 --> 00:27:34,460
you very much changing sides

00:27:32,179 --> 00:27:39,289
where can we have the questions please

00:27:34,460 --> 00:27:42,320
on slide Oh fantastic 55 likes let's go

00:27:39,289 --> 00:27:45,350
for that one so the future of react of

00:27:42,320 --> 00:27:48,860
course is very well defined in the road

00:27:45,350 --> 00:27:52,190
map the the part of the future of reg

00:27:48,860 --> 00:27:54,530
that we are interested in is word what

00:27:52,190 --> 00:27:56,870
are the what is the API surface that can

00:27:54,530 --> 00:28:01,039
sort of become universal and I can

00:27:56,870 --> 00:28:05,240
enable this really cool principles and I

00:28:01,039 --> 00:28:08,210
think part of part of the spirit of

00:28:05,240 --> 00:28:11,360
neck's is trying to reduce a lot of the

00:28:08,210 --> 00:28:14,000
boilerplate involved in setting up react

00:28:11,360 --> 00:28:16,070
for example and some day covering the

00:28:14,000 --> 00:28:18,650
FAQ as well is what is the difference

00:28:16,070 --> 00:28:22,520
between create create react app and this

00:28:18,650 --> 00:28:24,559
and the bottom line is that depending on

00:28:22,520 --> 00:28:26,179
what your target application is and what

00:28:24,559 --> 00:28:28,400
do you want to use react to specifically

00:28:26,179 --> 00:28:29,690
for your gonna go lower level to

00:28:28,400 --> 00:28:32,559
something I create a react app or you're

00:28:29,690 --> 00:28:32,559
going to use something this

00:28:36,450 --> 00:28:41,500
so the next question this looks good for

00:28:39,130 --> 00:28:43,000
a quick start with what is reprimand

00:28:41,500 --> 00:28:46,299
ating large-scale projects tweaking

00:28:43,000 --> 00:28:48,790
requirements by tweaking I don't know

00:28:46,299 --> 00:28:50,710
specifically what you referred to we

00:28:48,790 --> 00:28:53,100
found a lot of fish cases that had to do

00:28:50,710 --> 00:28:56,860
for example libraries not being

00:28:53,100 --> 00:28:59,400
isomorphic ready we actually find a lot

00:28:56,860 --> 00:29:04,419
of edge cases with our application where

00:28:59,400 --> 00:29:05,890
bill times were too too long so we had

00:29:04,419 --> 00:29:07,540
to make a lot of optimizations for that

00:29:05,890 --> 00:29:09,220
so when you start going into the

00:29:07,540 --> 00:29:11,350
large-scale application territory some

00:29:09,220 --> 00:29:13,210
interesting problems come up part of

00:29:11,350 --> 00:29:14,380
that is why we're not translating CSS we

00:29:13,210 --> 00:29:17,200
found that Legos bring in that or

00:29:14,380 --> 00:29:20,860
performance a lot part of that is while

00:29:17,200 --> 00:29:22,840
we are looking into app mounting where

00:29:20,860 --> 00:29:25,090
you can take a path within your

00:29:22,840 --> 00:29:26,530
application and refer to a smaller

00:29:25,090 --> 00:29:28,809
application that lives in a different

00:29:26,530 --> 00:29:31,240
server so that we can scale as and

00:29:28,809 --> 00:29:32,590
separate them independently and another

00:29:31,240 --> 00:29:35,530
approach for example when it comes into

00:29:32,590 --> 00:29:36,820
tweaking is so one of them is the first

00:29:35,530 --> 00:29:38,919
thing I mentioned on our roadmap which

00:29:36,820 --> 00:29:41,200
is you want to be able to like take over

00:29:38,919 --> 00:29:44,410
the HTTP server completely so that's

00:29:41,200 --> 00:29:46,090
certainly within our interest to support

00:29:44,410 --> 00:29:48,880
another thinking sometimes you need

00:29:46,090 --> 00:29:50,110
custom build pipelines but in general I

00:29:48,880 --> 00:29:52,600
don't think the best approach for doing

00:29:50,110 --> 00:29:54,580
that is to have this gigantic web pack

00:29:52,600 --> 00:29:56,049
config that takes care of every edge

00:29:54,580 --> 00:29:57,820
case what we've done for those

00:29:56,049 --> 00:30:00,940
situations is we break down the

00:29:57,820 --> 00:30:03,340
component that we want to tweak into a

00:30:00,940 --> 00:30:05,230
different repository and the contract is

00:30:03,340 --> 00:30:08,260
very simple as long as it exposes a

00:30:05,230 --> 00:30:10,390
react component or stateless react

00:30:08,260 --> 00:30:12,820
function we can import it within this

00:30:10,390 --> 00:30:15,700
framework so in reality it's worked

00:30:12,820 --> 00:30:19,030
really well for our needs 34 more

00:30:15,700 --> 00:30:20,440
questions two minutes to go so let's go

00:30:19,030 --> 00:30:23,500
through the interested I'll speak really

00:30:20,440 --> 00:30:26,860
quickly so I already answered the create

00:30:23,500 --> 00:30:28,419
react app and Express you can certainly

00:30:26,860 --> 00:30:29,500
use Express for example when you take

00:30:28,419 --> 00:30:31,450
over the server and if you want to

00:30:29,500 --> 00:30:33,820
define a lot of custom routing we didn't

00:30:31,450 --> 00:30:35,860
think that bundling Express made sense

00:30:33,820 --> 00:30:38,320
because the only thing we really need is

00:30:35,860 --> 00:30:39,460
the HTTP server as I said earlier one of

00:30:38,320 --> 00:30:42,159
our goals is to make this as

00:30:39,460 --> 00:30:43,450
minimalistic as possible not everyone

00:30:42,159 --> 00:30:45,610
needs to do routing not everyone needs

00:30:43,450 --> 00:30:46,270
to handle post requests an example of

00:30:45,610 --> 00:30:47,860
that is

00:30:46,270 --> 00:30:52,000
we use micro micro service architecture

00:30:47,860 --> 00:30:55,450
so we don't even handle any post methods

00:30:52,000 --> 00:30:57,760
on our next server next is basically a

00:30:55,450 --> 00:31:00,370
server that is a 100% in charge of

00:30:57,760 --> 00:31:02,550
rendering everything else is deferred to

00:31:00,370 --> 00:31:06,070
other services services within our

00:31:02,550 --> 00:31:07,750
architecture so the goal is to for next

00:31:06,070 --> 00:31:10,660
to actually do less and less and less

00:31:07,750 --> 00:31:12,940
and express sort of brings that up a

00:31:10,660 --> 00:31:14,230
little bit but it's something you can

00:31:12,940 --> 00:31:17,350
incorporate if you want to take over the

00:31:14,230 --> 00:31:19,960
server and you want to pass an express

00:31:17,350 --> 00:31:24,220
function to the HTTP that greater recall

00:31:19,960 --> 00:31:27,460
it's certainly up to you can use the

00:31:24,220 --> 00:31:29,650
next with reason so I think this is an

00:31:27,460 --> 00:31:32,170
interesting parallel be very interesting

00:31:29,650 --> 00:31:33,280
someone asked can I use reason on the

00:31:32,170 --> 00:31:36,070
front end I think this is a very

00:31:33,280 --> 00:31:37,570
interesting pattern with where it's

00:31:36,070 --> 00:31:40,000
interesting to explore alternatives

00:31:37,570 --> 00:31:40,990
because some of the processes that we

00:31:40,000 --> 00:31:44,040
run on the back and they're actually

00:31:40,990 --> 00:31:46,540
pretty expensive and pretty slow so

00:31:44,040 --> 00:31:48,610
executing react on the backend it's not

00:31:46,540 --> 00:31:51,160
as fast as we would like it to be for

00:31:48,610 --> 00:31:53,530
example so some limitations have to do

00:31:51,160 --> 00:31:56,200
with JavaScript some limitations have to

00:31:53,530 --> 00:31:57,940
do with the frameworks themselves for

00:31:56,200 --> 00:32:00,690
example we are incorporating streaming

00:31:57,940 --> 00:32:03,760
of HTML whenever it becomes available

00:32:00,690 --> 00:32:07,120
but it's really interesting to take this

00:32:03,760 --> 00:32:08,830
surface area and try to implement it in

00:32:07,120 --> 00:32:11,800
other languages and another great thing

00:32:08,830 --> 00:32:14,740
is recent supports I think with as of

00:32:11,800 --> 00:32:16,210
recently JSX directly so if you're

00:32:14,740 --> 00:32:19,360
really interesting to also not have to

00:32:16,210 --> 00:32:23,380
deal with that transformation step let's

00:32:19,360 --> 00:32:24,880
do a last question yeah so Dom

00:32:23,380 --> 00:32:26,860
difference is like I mentioned I give an

00:32:24,880 --> 00:32:28,570
example with code mirror so the server

00:32:26,860 --> 00:32:32,290
is rendering something that didn't have

00:32:28,570 --> 00:32:34,630
that editor rendered on the page so we

00:32:32,290 --> 00:32:37,060
do that very easily because on the get

00:32:34,630 --> 00:32:39,130
initial props we say edit or false or

00:32:37,060 --> 00:32:42,250
something exists and that's all it takes

00:32:39,130 --> 00:32:45,580
in this case we did because of a few

00:32:42,250 --> 00:32:47,020
things first of all voting the entire

00:32:45,580 --> 00:32:49,900
code mirror code based on the server

00:32:47,020 --> 00:32:53,740
side is quite expensive secondly

00:32:49,900 --> 00:32:56,710
the interaction or the things that we

00:32:53,740 --> 00:32:57,490
can server rendered from the editor we

00:32:56,710 --> 00:32:59,290
would like to have a static

00:32:57,490 --> 00:33:00,160
representation of it so this is the

00:32:59,290 --> 00:33:02,050
beauty of next in

00:33:00,160 --> 00:33:04,210
that like you can have a complete

00:33:02,050 --> 00:33:06,310
different dawn between server and client

00:33:04,210 --> 00:33:09,850
when client resumes and component is

00:33:06,310 --> 00:33:12,010
mount fires you can load arbitrary you

00:33:09,850 --> 00:33:15,730
could even like do jQuery stuff if you

00:33:12,010 --> 00:33:18,730
so desired and we react us give you a

00:33:15,730 --> 00:33:21,070
warning when the Dom doesn't match which

00:33:18,730 --> 00:33:23,170
is very useful in certain cases because

00:33:21,070 --> 00:33:24,700
you're doing something that you

00:33:23,170 --> 00:33:27,670
shouldn't be doing but in a lot of cases

00:33:24,700 --> 00:33:29,860
you do want the Dom to not match so an

00:33:27,670 --> 00:33:32,740
example where that doesn't make a lot of

00:33:29,860 --> 00:33:34,780
sense for us is the date because we

00:33:32,740 --> 00:33:36,610
configure the date according to a cookie

00:33:34,780 --> 00:33:39,670
that tells us where you're from or what

00:33:36,610 --> 00:33:41,170
your timezone offset is we don't know

00:33:39,670 --> 00:33:43,720
this ahead of time so it's hard for us

00:33:41,170 --> 00:33:45,850
to say if it happened two hours ago

00:33:43,720 --> 00:33:48,160
relative to GMT or if it happened eight

00:33:45,850 --> 00:33:49,900
hours ago so this is an example where we

00:33:48,160 --> 00:33:51,550
do want the Dom in certain cases do not

00:33:49,900 --> 00:33:53,230
match just because we can't make it

00:33:51,550 --> 00:33:55,900
match because we don't know what time it

00:33:53,230 --> 00:33:57,580
is where you're from so that's an

00:33:55,900 --> 00:34:01,540
example of Dom reconciliation that we've

00:33:57,580 --> 00:34:03,100
run into and we're out of time okay

00:34:01,540 --> 00:34:08,770
think it's so much good I'm appreciated

00:34:03,100 --> 00:34:08,770

YouTube URL: https://www.youtube.com/watch?v=lYt2_N31bGM


