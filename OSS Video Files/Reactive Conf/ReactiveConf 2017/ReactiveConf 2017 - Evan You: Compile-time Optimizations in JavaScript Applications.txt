Title: ReactiveConf 2017 - Evan You: Compile-time Optimizations in JavaScript Applications
Publication date: 2017-11-20
Playlist: ReactiveConf 2017
Description: 
	Main stage talk

https://reactiveconf.com/
25th - 27th October 2017, Bratislava, Slovakia
Captions: 
	00:00:02,040 --> 00:00:08,639
[Music]

00:00:14,580 --> 00:00:22,020
hello everyone my name is Evan you and

00:00:18,150 --> 00:00:24,990
I'm the author of UJS and really happy

00:00:22,020 --> 00:00:28,830
to be here I was actually invited last

00:00:24,990 --> 00:00:32,060
year but had some schedule conflicts and

00:00:28,830 --> 00:00:34,920
I'm really excited to be here this year

00:00:32,060 --> 00:00:37,860
so today's talk is about compile time

00:00:34,920 --> 00:00:39,360
optimization in JavaScript applications

00:00:37,860 --> 00:00:41,399
as I was watching

00:00:39,360 --> 00:00:43,890
Igor's talk I realized there's actually

00:00:41,399 --> 00:00:45,480
actually a pretty good synergy between

00:00:43,890 --> 00:00:46,680
the talks because we're gonna be

00:00:45,480 --> 00:00:50,160
mentioning some of the concepts that

00:00:46,680 --> 00:00:52,079
Igor leveraged in his in his demo and

00:00:50,160 --> 00:00:54,870
this talk is not going to be

00:00:52,079 --> 00:00:58,469
specifically about view but there will

00:00:54,870 --> 00:01:02,429
be some few specific parts just to be

00:00:58,469 --> 00:01:04,320
clear about it okay so front-end used to

00:01:02,429 --> 00:01:05,730
have no build steps when we first

00:01:04,320 --> 00:01:08,820
started everything is just plug-and-play

00:01:05,730 --> 00:01:10,530
you drop a script into a page and you

00:01:08,820 --> 00:01:13,040
open the page in the browser and things

00:01:10,530 --> 00:01:16,170
start working but today right

00:01:13,040 --> 00:01:18,660
compliation or a build step is is an

00:01:16,170 --> 00:01:21,090
essential part of our workflow now we

00:01:18,660 --> 00:01:23,430
have Babel the JavaScript compile a ssin

00:01:21,090 --> 00:01:26,370
infrastructure we have bundlers like web

00:01:23,430 --> 00:01:28,830
pack roll-up we have compiled tjs

00:01:26,370 --> 00:01:32,550
languages like CoffeeScript typescript

00:01:28,830 --> 00:01:34,110
and you know even reason or Elm also

00:01:32,550 --> 00:01:37,680
compile to JavaScript

00:01:34,110 --> 00:01:40,080
we have CSS preprocessors like sass

00:01:37,680 --> 00:01:42,270
lasts and also post CSS which is more

00:01:40,080 --> 00:01:45,960
like the compiler infrastructure for CSS

00:01:42,270 --> 00:01:49,500
so we have all of these tools that we

00:01:45,960 --> 00:01:51,480
leverage today but I want to go take a

00:01:49,500 --> 00:01:55,010
step back and think about like in the

00:01:51,480 --> 00:01:58,500
early days we've actually been using

00:01:55,010 --> 00:02:01,410
compliation optimizations way before

00:01:58,500 --> 00:02:04,950
these tools okay but before that let's

00:02:01,410 --> 00:02:07,080
think about what compiler really is this

00:02:04,950 --> 00:02:09,330
is not the compiler in the strict you

00:02:07,080 --> 00:02:11,849
know backing the C days we're just

00:02:09,330 --> 00:02:14,580
talking about it in a very cross

00:02:11,849 --> 00:02:16,290
language term as a as a cross language

00:02:14,580 --> 00:02:18,360
term really it's just something that

00:02:16,290 --> 00:02:21,090
takes the source code in omits target

00:02:18,360 --> 00:02:24,180
code whether it's compiled JavaScript or

00:02:21,090 --> 00:02:26,580
binary code we don't really care and the

00:02:24,180 --> 00:02:28,080
process usually involves you know

00:02:26,580 --> 00:02:31,290
parsing the saw

00:02:28,080 --> 00:02:33,000
coding to an ast and then manipulated

00:02:31,290 --> 00:02:37,770
transformed in some way and eventually

00:02:33,000 --> 00:02:39,900
generating the target code and in this s

00:02:37,770 --> 00:02:41,310
ast transformation phase this is our

00:02:39,900 --> 00:02:44,760
opportunity to apply a lot of

00:02:41,310 --> 00:02:48,300
interesting transforms analyzing the

00:02:44,760 --> 00:02:52,950
structure of the ast and do all kinds of

00:02:48,300 --> 00:02:55,710
possible optimizations right and one of

00:02:52,950 --> 00:02:58,350
the earliest way we've leveraged compile

00:02:55,710 --> 00:03:00,060
time optimizations is just minifiers and

00:02:58,350 --> 00:03:04,020
if you think about minifiers many fires

00:03:00,060 --> 00:03:06,990
are essentially compilers right they

00:03:04,020 --> 00:03:10,230
take some inputs your source code and

00:03:06,990 --> 00:03:12,240
then emits the minified code and in

00:03:10,230 --> 00:03:14,190
doing that it usually requires properly

00:03:12,240 --> 00:03:15,840
parsing a JavaScript understanding the

00:03:14,190 --> 00:03:18,570
structure of your code and then applying

00:03:15,840 --> 00:03:20,790
the proper optimizations if we look at

00:03:18,570 --> 00:03:22,770
some of the main most prominent

00:03:20,790 --> 00:03:26,010
minifiers we have closure compiler up

00:03:22,770 --> 00:03:28,830
with ideas Bobbili I think it's renamed

00:03:26,010 --> 00:03:31,110
to Babel mattify now and butternut which

00:03:28,830 --> 00:03:33,120
is the minify written by rich Harris who

00:03:31,110 --> 00:03:35,269
basically writes a cop writes an

00:03:33,120 --> 00:03:38,070
alternative implementation of everything

00:03:35,269 --> 00:03:40,019
if you think about those closure

00:03:38,070 --> 00:03:42,660
compiler basically says in this name is

00:03:40,019 --> 00:03:45,300
a compiler uglify j s has its own

00:03:42,660 --> 00:03:48,269
implementation of a parser is a st

00:03:45,300 --> 00:03:49,890
format it's cogent babel minify is built

00:03:48,269 --> 00:03:52,260
on top of Babel which is a compiler

00:03:49,890 --> 00:03:54,390
infrastructure butternut has a similar

00:03:52,260 --> 00:03:57,300
architecture to Buble the lightweight

00:03:54,390 --> 00:04:00,660
es2015 compiler which is also a compiler

00:03:57,300 --> 00:04:02,910
so we've been using compile time

00:04:00,660 --> 00:04:07,019
optimizations long before we realized it

00:04:02,910 --> 00:04:09,830
but well it's only 60 the arrival of

00:04:07,019 --> 00:04:13,050
these compiler instructure tools like

00:04:09,830 --> 00:04:15,330
babel in post CSS we start to doing more

00:04:13,050 --> 00:04:18,630
interesting things in this area in

00:04:15,330 --> 00:04:22,800
recent yes and we'll explore that in the

00:04:18,630 --> 00:04:24,660
rest of this talk so first thing so

00:04:22,800 --> 00:04:26,729
going along with the minifiers theme

00:04:24,660 --> 00:04:28,890
we're trying to make our code slimmer

00:04:26,729 --> 00:04:31,380
this is a unique problem for browser

00:04:28,890 --> 00:04:32,820
code because we really care about how

00:04:31,380 --> 00:04:34,770
much code we eventually send to the

00:04:32,820 --> 00:04:37,200
client to to save bandwidth make pages

00:04:34,770 --> 00:04:38,880
load faster so tree shaking is one

00:04:37,200 --> 00:04:40,449
important thing which igor already

00:04:38,880 --> 00:04:43,990
mentioned in his talk

00:04:40,449 --> 00:04:47,139
specifically tree shaking is implemented

00:04:43,990 --> 00:04:49,150
by doing module sculpt posting right so

00:04:47,139 --> 00:04:51,069
if we look at yes MA jewels we have a

00:04:49,150 --> 00:04:53,379
main je s in two files that's being

00:04:51,069 --> 00:04:59,379
imported and we are calling the calling

00:04:53,379 --> 00:05:03,009
the code in the main je s right and with

00:04:59,379 --> 00:05:05,110
module scope hosting we'll just put them

00:05:03,009 --> 00:05:07,120
inside the same file so without module

00:05:05,110 --> 00:05:10,270
scope hoisting if we look at the code

00:05:07,120 --> 00:05:12,729
generated by browserify or web pack

00:05:10,270 --> 00:05:14,319
without the module concatenation plug-in

00:05:12,729 --> 00:05:16,900
you'll see that each module is wrapped

00:05:14,319 --> 00:05:19,689
in a function scope which makes it

00:05:16,900 --> 00:05:21,219
difficult for minifiers to analyze what

00:05:19,689 --> 00:05:23,259
things can actually be dropped

00:05:21,219 --> 00:05:25,539
however with module scope hoisting or

00:05:23,259 --> 00:05:28,389
module concatenation everything is put

00:05:25,539 --> 00:05:30,370
in the same scope this is what roll-up

00:05:28,389 --> 00:05:32,740
does by default and what web pack does

00:05:30,370 --> 00:05:35,740
if you enable them opting into the

00:05:32,740 --> 00:05:37,689
module concatenation plugging and the

00:05:35,740 --> 00:05:39,639
cool part is when we comment out the

00:05:37,689 --> 00:05:42,610
code that actually uses these imports

00:05:39,639 --> 00:05:45,879
now the mini fire is able to infer that

00:05:42,610 --> 00:05:48,669
things are not actually used and able to

00:05:45,879 --> 00:05:49,509
just shake them and we end up with

00:05:48,669 --> 00:05:52,449
nothing

00:05:49,509 --> 00:05:55,599
if we don't actually use anything right

00:05:52,449 --> 00:05:57,699
so that's retaking and that's also a

00:05:55,599 --> 00:06:01,120
form of compile time optimization and

00:05:57,699 --> 00:06:04,060
it's it's it's the collaborative work of

00:06:01,120 --> 00:06:06,159
our bundlers which is smart enough to

00:06:04,060 --> 00:06:09,909
infer the relationship of your modules

00:06:06,159 --> 00:06:13,330
and variables and the Opta and the midi

00:06:09,909 --> 00:06:16,360
fires which takes the outputs by the

00:06:13,330 --> 00:06:20,919
module bundler and then performed its

00:06:16,360 --> 00:06:22,599
own optimizations okay so yeah in

00:06:20,919 --> 00:06:23,919
webpack you need to opt in to the module

00:06:22,599 --> 00:06:29,319
concatenation plugging to get this

00:06:23,919 --> 00:06:31,330
behavior and so that was that was about

00:06:29,319 --> 00:06:34,749
making Colt smaller then let's think

00:06:31,330 --> 00:06:37,089
about template compilation right so this

00:06:34,749 --> 00:06:40,120
is loosely related to reacting some way

00:06:37,089 --> 00:06:42,129
because we also need to compile JSX into

00:06:40,120 --> 00:06:44,080
raw JavaScript but its more common for

00:06:42,129 --> 00:06:47,680
other frameworks which use leverages

00:06:44,080 --> 00:06:51,490
templates such as view angular svelte or

00:06:47,680 --> 00:06:53,199
ember or have templates and they all

00:06:51,490 --> 00:06:53,860
need compilers to compile these

00:06:53,199 --> 00:06:55,900
templates

00:06:53,860 --> 00:06:58,560
and the strategy each of these

00:06:55,900 --> 00:07:01,060
frameworks take are slightly different

00:06:58,560 --> 00:07:01,539
well well we'll briefly go through each

00:07:01,060 --> 00:07:04,389
of them

00:07:01,539 --> 00:07:06,190
but in terms of in terms of the detailed

00:07:04,389 --> 00:07:09,220
Optim and the optimization techniques

00:07:06,190 --> 00:07:11,530
we'll be focusing a bit more on view in

00:07:09,220 --> 00:07:13,599
the later part of this talk so this is

00:07:11,530 --> 00:07:16,560
more like a higher level overview of

00:07:13,599 --> 00:07:21,430
what each framework is doing right so

00:07:16,560 --> 00:07:24,400
for view many of you probably know in

00:07:21,430 --> 00:07:26,319
view 2.0 we rewrote the rendering layer

00:07:24,400 --> 00:07:29,530
and we essentially compile all view

00:07:26,319 --> 00:07:31,599
templates in to render functions and on

00:07:29,530 --> 00:07:33,159
the underlying so once compounding to

00:07:31,599 --> 00:07:34,900
render functions it goes into the

00:07:33,159 --> 00:07:36,669
similar domain of virtual Dom our

00:07:34,900 --> 00:07:38,199
rendering and this thing's similar to

00:07:36,669 --> 00:07:41,740
react and all the virtual Dom inspire

00:07:38,199 --> 00:07:43,750
libraries and during this template to

00:07:41,740 --> 00:07:46,990
render function compile phase we're

00:07:43,750 --> 00:07:49,000
actually because we get an AST of the

00:07:46,990 --> 00:07:50,710
template we're actually able to apply

00:07:49,000 --> 00:07:54,849
some pretty interesting optimizations

00:07:50,710 --> 00:07:57,819
which we'll talk about later in angular

00:07:54,849 --> 00:08:02,219
so this is this is a screenshot taken

00:07:57,819 --> 00:08:05,199
from a talk at ng-conf on the the

00:08:02,219 --> 00:08:08,500
optimizations brought you into the

00:08:05,199 --> 00:08:10,270
angular compiler in angular 4 so if you

00:08:08,500 --> 00:08:12,699
look at the comparison on the right you

00:08:10,270 --> 00:08:14,380
see the code generated by angular 2 and

00:08:12,699 --> 00:08:18,550
on the left you see the code generated

00:08:14,380 --> 00:08:21,460
by angular 4 so angular 2 takes a more

00:08:18,550 --> 00:08:23,919
direct style where you directly generate

00:08:21,460 --> 00:08:26,169
all the code that imperatively creates

00:08:23,919 --> 00:08:28,419
the the elements and binds the

00:08:26,169 --> 00:08:31,960
directives and performs the updates in

00:08:28,419 --> 00:08:33,520
angular 4 it's optimized in by

00:08:31,960 --> 00:08:36,190
extracting some of the more repetitive

00:08:33,520 --> 00:08:38,709
parts into into the wrong time into the

00:08:36,190 --> 00:08:42,190
share runtime and expose these reusable

00:08:38,709 --> 00:08:44,140
functions that that's used in the

00:08:42,190 --> 00:08:47,529
generated code so this was a big

00:08:44,140 --> 00:08:49,420
improvement because it greatly reduced

00:08:47,529 --> 00:08:51,699
the final bundle size of angular

00:08:49,420 --> 00:08:53,709
applications without you know changing

00:08:51,699 --> 00:08:55,779
anything in terms of user written code

00:08:53,709 --> 00:08:57,880
the template is the same but just

00:08:55,779 --> 00:09:00,370
because we improve the compiler angular

00:08:57,880 --> 00:09:04,420
is able to greatly improve the

00:09:00,370 --> 00:09:06,610
performance and spout is also a great

00:09:04,420 --> 00:09:07,720
idea in case you're not familiar with it

00:09:06,610 --> 00:09:10,030
spelled is also rich

00:09:07,720 --> 00:09:14,410
by rich harris was the author of rola

00:09:10,030 --> 00:09:16,630
Buble and other things so spelt also

00:09:14,410 --> 00:09:19,240
uses templates but it takes a slightly

00:09:16,630 --> 00:09:22,150
different strategy by compiling the

00:09:19,240 --> 00:09:25,540
templates into more direct Dom

00:09:22,150 --> 00:09:26,800
manipulations with opt-in runtime so if

00:09:25,540 --> 00:09:28,870
you look at the code it actually looks

00:09:26,800 --> 00:09:32,620
pretty similar to the version 2 code

00:09:28,870 --> 00:09:36,340
that's generated by angular but the the

00:09:32,620 --> 00:09:39,610
big unique thing about spelt is it's

00:09:36,340 --> 00:09:41,620
wrong time code is are pretty much the

00:09:39,610 --> 00:09:43,960
majority of this runtime code is opt in

00:09:41,620 --> 00:09:46,720
so if you create a hello world spout

00:09:43,960 --> 00:09:49,780
apps the bondo'd runtime is only like

00:09:46,720 --> 00:09:52,450
less than 200 lines of code

00:09:49,780 --> 00:09:54,460
it only bound owes the necessary runtime

00:09:52,450 --> 00:09:57,250
code when your template actually uses a

00:09:54,460 --> 00:10:01,480
certain feature so this results in very

00:09:57,250 --> 00:10:05,250
small default bundles because it uses a

00:10:01,480 --> 00:10:05,250
very specific style of code generation

00:10:05,460 --> 00:10:10,540
and then there is a glimmer which is

00:10:08,890 --> 00:10:12,670
also pretty unique in the in the

00:10:10,540 --> 00:10:16,180
compilation strategy by compiling

00:10:12,670 --> 00:10:18,700
handlebars templates into op codes so

00:10:16,180 --> 00:10:20,770
these op codes are then feed into the

00:10:18,700 --> 00:10:22,930
runtime which is called deliver glimmer

00:10:20,770 --> 00:10:24,760
vm which tom dell will actually be

00:10:22,930 --> 00:10:27,750
talking about it in more details

00:10:24,760 --> 00:10:30,160
tomorrow but the most unique thing about

00:10:27,750 --> 00:10:33,270
dilemma out codes is that they are

00:10:30,160 --> 00:10:36,610
binary friendly so it's possible to

00:10:33,270 --> 00:10:39,130
generate the binary generate the op

00:10:36,610 --> 00:10:41,650
codes as binary artifacts at compile

00:10:39,130 --> 00:10:43,900
time and then you can just directly

00:10:41,650 --> 00:10:47,500
fetch them as a binary stream and

00:10:43,900 --> 00:10:51,400
instantiate them as a you know a typed

00:10:47,500 --> 00:10:53,440
array and which which gets rid of a lot

00:10:51,400 --> 00:10:56,280
of the parsing and evaluation if you're

00:10:53,440 --> 00:11:00,570
using a raw JavaScript or JSON format

00:10:56,280 --> 00:11:04,120
it's also pretty webassembly friendly

00:11:00,570 --> 00:11:06,460
okay so these are the some of the common

00:11:04,120 --> 00:11:07,930
strategies different different styles of

00:11:06,460 --> 00:11:09,700
compliation template compliation

00:11:07,930 --> 00:11:13,000
different frameworks but the common

00:11:09,700 --> 00:11:16,110
theme among them is also alt versus JIT

00:11:13,000 --> 00:11:18,880
ahead of time versus just-in-time

00:11:16,110 --> 00:11:20,950
so so a lot of frameworks in the past

00:11:18,880 --> 00:11:24,370
for example handlebars and

00:11:20,950 --> 00:11:26,650
view version 1 in angular 1 also most of

00:11:24,370 --> 00:11:29,710
them perform the template compilation

00:11:26,650 --> 00:11:32,110
directly in the browser so the cost of

00:11:29,710 --> 00:11:35,470
parsing the compiler analyzing the

00:11:32,110 --> 00:11:37,630
structure and generating code has to be

00:11:35,470 --> 00:11:40,120
performed on the client it takes up the

00:11:37,630 --> 00:11:43,330
time to interactive for in a user

00:11:40,120 --> 00:11:45,070
application so the natural step is if we

00:11:43,330 --> 00:11:46,960
already have a build step we definitely

00:11:45,070 --> 00:11:48,820
should move this template compilation

00:11:46,960 --> 00:11:51,640
step to the build time to avoid the

00:11:48,820 --> 00:11:54,850
runtime cost so this is the default I

00:11:51,640 --> 00:11:57,430
believe angular already moved to alt by

00:11:54,850 --> 00:11:58,570
default correct me if I'm wrong if you

00:11:57,430 --> 00:12:01,240
use the view see how I generate

00:11:58,570 --> 00:12:04,420
templates we use alt by default as well

00:12:01,240 --> 00:12:06,550
I believe if you scaffold an app with

00:12:04,420 --> 00:12:08,680
ember with latest glimmer its alt by

00:12:06,550 --> 00:12:10,570
default as well so this is a common

00:12:08,680 --> 00:12:12,640
thing that's implemented by most

00:12:10,570 --> 00:12:16,570
frameworks and I believe spelt doesn't

00:12:12,640 --> 00:12:20,590
even have a JIT option so you have to do

00:12:16,570 --> 00:12:22,630
alt compile a IOT compliation and the

00:12:20,590 --> 00:12:25,630
next thing interesting thing we can do

00:12:22,630 --> 00:12:27,970
by having a compliation step is scope

00:12:25,630 --> 00:12:29,980
CSS simulation so this is not

00:12:27,970 --> 00:12:32,410
technically a performance optimization

00:12:29,980 --> 00:12:34,120
but more like a developer experience

00:12:32,410 --> 00:12:37,540
optimization or a developer patent

00:12:34,120 --> 00:12:40,330
optimization right so the rise of CSS

00:12:37,540 --> 00:12:43,390
and J's was a large Association yes

00:12:40,330 --> 00:12:45,340
obviously have some unique advantages in

00:12:43,390 --> 00:12:48,310
certain areas due to its closer

00:12:45,340 --> 00:12:52,540
relationship to JavaScript but the the

00:12:48,310 --> 00:12:54,610
prime reason that CSS jas came up as a

00:12:52,540 --> 00:12:58,210
solution was to solve the component

00:12:54,610 --> 00:13:00,640
styling problem we want to limit CSS to

00:12:58,210 --> 00:13:04,030
certain to our component as a boundary

00:13:00,640 --> 00:13:05,310
and plain CSS was a nightmare to

00:13:04,030 --> 00:13:10,330
maintain because of the default

00:13:05,310 --> 00:13:13,930
cascading behavior so in angular 2 in

00:13:10,330 --> 00:13:18,400
view & Spell we we all have a similar

00:13:13,930 --> 00:13:20,590
strategy by simulating scope CSS at the

00:13:18,400 --> 00:13:23,970
compile during the compilation step so

00:13:20,590 --> 00:13:26,770
we can because our styles and our

00:13:23,970 --> 00:13:29,830
component templates aren't naturally

00:13:26,770 --> 00:13:31,660
connected or they are either coded in a

00:13:29,830 --> 00:13:32,329
single file component or they are some

00:13:31,660 --> 00:13:36,170
wards

00:13:32,329 --> 00:13:38,059
what imported have a module dependency

00:13:36,170 --> 00:13:39,860
relationship the compiler is able to

00:13:38,059 --> 00:13:43,189
infer the relationship between the

00:13:39,860 --> 00:13:46,009
template and the CSS in order to rewrite

00:13:43,189 --> 00:13:49,910
both at the same time so that the

00:13:46,009 --> 00:13:51,499
template and the CSS are perfectly so so

00:13:49,910 --> 00:13:53,509
the template is rewritten with extra

00:13:51,499 --> 00:13:56,509
attributes hooked on to each element and

00:13:53,509 --> 00:14:01,369
the CSS has its selectors rewritten to

00:13:56,509 --> 00:14:03,379
be more specific specified so the CSS

00:14:01,369 --> 00:14:06,189
will be all scoped to only the elements

00:14:03,379 --> 00:14:08,869
of the current component and this

00:14:06,189 --> 00:14:11,059
simulation this almost perfectly

00:14:08,869 --> 00:14:13,549
simulates what we would expect in a

00:14:11,059 --> 00:14:14,989
shadow Dom scope CSS that's support

00:14:13,549 --> 00:14:16,610
natively but it doesn't require any

00:14:14,989 --> 00:14:20,959
polyfills and it works all the way back

00:14:16,610 --> 00:14:23,869
to IE 9 which is pretty nice even in CSS

00:14:20,959 --> 00:14:29,269
even in CSS in JSON we also have

00:14:23,869 --> 00:14:32,809
solutions like style JSX by site which

00:14:29,269 --> 00:14:35,509
is somewhat inspired by the scoped CSS

00:14:32,809 --> 00:14:39,919
implementation using angular view in

00:14:35,509 --> 00:14:42,529
spelt that allows you to embed CSS

00:14:39,919 --> 00:14:45,379
strain in your javascript and then use a

00:14:42,529 --> 00:14:49,519
Babel plugin to analyze and transform

00:14:45,379 --> 00:14:52,929
the CSS at the compilation time it's

00:14:49,519 --> 00:14:56,720
either able to support sass or other

00:14:52,929 --> 00:14:59,660
pre-processors in CSS nsj by adding

00:14:56,720 --> 00:15:02,389
plugins to the Babel plugins so plug-ins

00:14:59,660 --> 00:15:06,470
for plugins for plugins because we have

00:15:02,389 --> 00:15:08,809
compilers why not okay so the simulation

00:15:06,470 --> 00:15:11,959
pretty much looks like this so this is a

00:15:08,809 --> 00:15:16,489
view specific implementation if we have

00:15:11,959 --> 00:15:19,480
a class equals read we will we'll add a

00:15:16,489 --> 00:15:22,850
unique data attribute to the element and

00:15:19,480 --> 00:15:25,489
the selector will be rewritten with the

00:15:22,850 --> 00:15:28,040
with a specific attribute selector to

00:15:25,489 --> 00:15:32,919
make it only match this specific

00:15:28,040 --> 00:15:35,629
elements so we've talked a lot about

00:15:32,919 --> 00:15:39,529
analyzing static stuff like templates

00:15:35,629 --> 00:15:43,160
and and CSS but how about react right so

00:15:39,529 --> 00:15:45,110
the thing about react is react is almost

00:15:43,160 --> 00:15:45,779
all JavaScript you put everything in

00:15:45,110 --> 00:15:47,850
JavaScript

00:15:45,779 --> 00:15:50,879
sexist JavaScript CSS in Jazz's

00:15:47,850 --> 00:15:53,180
JavaScript and we have babel for

00:15:50,879 --> 00:15:55,920
JavaScript right Babel is the compiler

00:15:53,180 --> 00:15:57,959
infrastructure for JavaScript which is

00:15:55,920 --> 00:16:00,240
why it's natural to perform all of these

00:15:57,959 --> 00:16:02,730
similar compile time optimizations for

00:16:00,240 --> 00:16:06,059
react using babel plugins and there is

00:16:02,730 --> 00:16:09,120
so james cow has this great babel react

00:16:06,059 --> 00:16:11,040
optimized plugin which performs a bunch

00:16:09,120 --> 00:16:13,769
of common optimization strategies by

00:16:11,040 --> 00:16:16,139
default we're not going to dig into all

00:16:13,769 --> 00:16:17,639
of them but the most prominent one in a

00:16:16,139 --> 00:16:21,089
lot of you probably know about is

00:16:17,639 --> 00:16:24,059
hoisting static elements right the the

00:16:21,089 --> 00:16:26,160
culprit of virtual dom is on every

00:16:24,059 --> 00:16:29,339
render we are recreating all of these

00:16:26,160 --> 00:16:32,370
virtual nodes and a common problem is if

00:16:29,339 --> 00:16:34,800
you have a large chunk of nodes that are

00:16:32,370 --> 00:16:38,339
just static they don't have any dynamic

00:16:34,800 --> 00:16:40,740
bindings to them we're still comparing

00:16:38,339 --> 00:16:44,009
them in trying to diff them on

00:16:40,740 --> 00:16:47,069
subsequent rear Enders so if we hurt if

00:16:44,009 --> 00:16:49,680
we're able to detect such static trees

00:16:47,069 --> 00:16:50,910
at compile time before we even ship

00:16:49,680 --> 00:16:53,370
things to the browser we were able to

00:16:50,910 --> 00:16:55,860
just transform the code and hoist the

00:16:53,370 --> 00:16:58,290
element out into a constant right so

00:16:55,860 --> 00:17:00,600
this was actually this idea came up as

00:16:58,290 --> 00:17:02,100
early as in like February 2015 which is

00:17:00,600 --> 00:17:04,319
like more than two years ago if you

00:17:02,100 --> 00:17:08,970
think about it how how fast time moves

00:17:04,319 --> 00:17:10,409
in JavaScript land and obviously we have

00:17:08,970 --> 00:17:13,500
similar optimizations and all the

00:17:10,409 --> 00:17:15,750
template based solutions as well and to

00:17:13,500 --> 00:17:17,399
be so this is not Bashan we add but to

00:17:15,750 --> 00:17:19,470
be honest because of the dynamic nature

00:17:17,399 --> 00:17:23,039
of javascript it's usually a bit more

00:17:19,470 --> 00:17:26,010
difficult to this type of optimizations

00:17:23,039 --> 00:17:28,260
because javascript is too dynamic so you

00:17:26,010 --> 00:17:30,450
can there are a lot fewer assumptions

00:17:28,260 --> 00:17:33,169
you can make and there are more cases

00:17:30,450 --> 00:17:35,730
that you have to bail out or the apps

00:17:33,169 --> 00:17:37,350
basically you you give up saying like

00:17:35,730 --> 00:17:43,280
this part we cannot analyze we cannot

00:17:37,350 --> 00:17:45,899
optimize it so to quote from Tom Dale

00:17:43,280 --> 00:17:47,909
what we call web frameworks or

00:17:45,899 --> 00:17:50,970
transforming from runtime libraries into

00:17:47,909 --> 00:17:53,130
optimizing compilers and I think we're

00:17:50,970 --> 00:17:55,370
going to see more of that trend coming

00:17:53,130 --> 00:17:55,370
up

00:17:55,720 --> 00:18:02,930
okay so on top of so going with that

00:18:00,470 --> 00:18:05,300
theme frameworks becoming compilers

00:18:02,930 --> 00:18:07,670
right so there are a bunch of meta

00:18:05,300 --> 00:18:10,310
optimizations that's even outside of the

00:18:07,670 --> 00:18:13,120
the template or style scope there are

00:18:10,310 --> 00:18:16,370
application level optimizations that are

00:18:13,120 --> 00:18:18,430
some words cross framework so webpack

00:18:16,370 --> 00:18:21,230
codes limiting code splitting igor

00:18:18,430 --> 00:18:23,630
mentioned how how it can help us improve

00:18:21,230 --> 00:18:25,970
performance and in fact it's also a

00:18:23,630 --> 00:18:28,280
category of compile time optimizations

00:18:25,970 --> 00:18:30,740
because we're using the es dynamic

00:18:28,280 --> 00:18:33,950
import syntax as a compilation hint

00:18:30,740 --> 00:18:36,020
given to to web pack so whenever web

00:18:33,950 --> 00:18:40,070
pack sparser sees the dynamic import

00:18:36,020 --> 00:18:42,650
syntax it will convert it into a Ajax

00:18:40,070 --> 00:18:45,380
request which fetches the content

00:18:42,650 --> 00:18:48,320
it also splits your output coding to

00:18:45,380 --> 00:18:50,000
pieces and then it includes this runtime

00:18:48,320 --> 00:18:51,740
piece of code that is responsible for

00:18:50,000 --> 00:18:55,390
fetching the asynchronous part and

00:18:51,740 --> 00:18:57,740
returning it to you as a promise and

00:18:55,390 --> 00:18:59,570
this is the usage combined with views

00:18:57,740 --> 00:19:01,340
async components this is essentially how

00:18:59,570 --> 00:19:03,950
you would just turn a view component

00:19:01,340 --> 00:19:08,180
into an asynchronously fetched one if

00:19:03,950 --> 00:19:10,310
you use webpack we also have some great

00:19:08,180 --> 00:19:13,430
ideas coming from really modern

00:19:10,310 --> 00:19:15,380
so really modern rewrite was mostly

00:19:13,430 --> 00:19:18,250
about performance in order to perform

00:19:15,380 --> 00:19:20,720
perform to improve performance there

00:19:18,250 --> 00:19:24,200
their conclusion was that they need to

00:19:20,720 --> 00:19:26,030
do more at compile time right so what

00:19:24,200 --> 00:19:28,510
really Molden does is it can pre compose

00:19:26,030 --> 00:19:31,180
graph curl queries and schemas and

00:19:28,510 --> 00:19:34,190
generates runtime artifacts and types

00:19:31,180 --> 00:19:37,160
that can be fed into the application at

00:19:34,190 --> 00:19:38,720
runtime but originally if this

00:19:37,160 --> 00:19:40,370
compilation phase needs to be performed

00:19:38,720 --> 00:19:42,890
at runtime it just takes it too much

00:19:40,370 --> 00:19:43,850
time is not even cost effective but if

00:19:42,890 --> 00:19:46,370
you can powered it

00:19:43,850 --> 00:19:49,130
performing at compile time it becomes a

00:19:46,370 --> 00:19:52,310
complete gain a pure gain so which is

00:19:49,130 --> 00:19:54,320
this is a great great idea so although

00:19:52,310 --> 00:19:58,340
it's like results in slightly more

00:19:54,320 --> 00:20:00,560
complex deployment operations still the

00:19:58,340 --> 00:20:02,890
performance k greatly outweighs this

00:20:00,560 --> 00:20:02,890
trade-off

00:20:03,280 --> 00:20:08,890
and then we have pre-pack right this is

00:20:06,400 --> 00:20:11,020
like meta meta level optimization you

00:20:08,890 --> 00:20:13,090
just give it your JavaScript in terms of

00:20:11,020 --> 00:20:15,730
JavaScript into more optimized

00:20:13,090 --> 00:20:20,620
JavaScript by doing partial evaluation

00:20:15,730 --> 00:20:23,530
right so so the strategy it takes is

00:20:20,620 --> 00:20:27,280
it'll essentially run whatever code is

00:20:23,530 --> 00:20:30,340
possible in your source code and try to

00:20:27,280 --> 00:20:32,770
produce the code that produces that

00:20:30,340 --> 00:20:35,470
results in the the same side effect

00:20:32,770 --> 00:20:39,880
right so if you have a fable Archy

00:20:35,470 --> 00:20:42,309
function and and you call so the code on

00:20:39,880 --> 00:20:44,049
the Left if we look at it the only side

00:20:42,309 --> 00:20:45,730
effect the eventual side effect that

00:20:44,049 --> 00:20:48,909
we're producing for the whole code

00:20:45,730 --> 00:20:50,980
bundle is the global variable X and

00:20:48,909 --> 00:20:54,250
that's the only side effect this whole

00:20:50,980 --> 00:20:57,010
bundle is producing so pre-pack is able

00:20:54,250 --> 00:20:58,570
to run your code and draw draw the

00:20:57,010 --> 00:21:01,150
conclusion that the only side effect we

00:20:58,570 --> 00:21:02,830
really care about is the value of x so

00:21:01,150 --> 00:21:07,480
it results in the code on the right

00:21:02,830 --> 00:21:09,039
which is pretty smart but this it also

00:21:07,480 --> 00:21:11,500
does things like for loop unrolling

00:21:09,039 --> 00:21:14,700
which turns your for loops into

00:21:11,500 --> 00:21:18,309
sequential imperative calls but

00:21:14,700 --> 00:21:21,270
sometimes it's just you it's a trade-off

00:21:18,309 --> 00:21:24,010
between code size and execution speed so

00:21:21,270 --> 00:21:26,590
pre pack still has some way to some

00:21:24,010 --> 00:21:28,870
improvements to do in that aspect but

00:21:26,590 --> 00:21:31,090
still it shows great potential in the

00:21:28,870 --> 00:21:33,780
future optimization of our javascript

00:21:31,090 --> 00:21:36,039
code and it's not bound to any sort of

00:21:33,780 --> 00:21:39,460
framework implementation you can applied

00:21:36,039 --> 00:21:43,809
it to any code that you write and then

00:21:39,460 --> 00:21:47,200
there's a proof concept which 3.1 Sony

00:21:43,809 --> 00:21:50,350
open shared this idea at react correct

00:21:47,200 --> 00:21:53,740
Europe earlier earlier this year I

00:21:50,350 --> 00:21:54,880
believe so I'd recommend people checking

00:21:53,740 --> 00:21:56,799
it out because I think it's a pretty

00:21:54,880 --> 00:21:58,570
interesting idea unfortunately this is

00:21:56,799 --> 00:22:01,659
just a proof concept I don't think he

00:21:58,570 --> 00:22:04,539
continued working on it but idea is we

00:22:01,659 --> 00:22:08,200
use yes decorators in the source code as

00:22:04,539 --> 00:22:10,870
of a compiler organization hints so for

00:22:08,200 --> 00:22:12,730
example it's the compiler is able to

00:22:10,870 --> 00:22:14,260
detect parts of the app that says all

00:22:12,730 --> 00:22:15,910
this part I

00:22:14,260 --> 00:22:18,820
to for example during service my

00:22:15,910 --> 00:22:20,950
rendering I need to just skip it and

00:22:18,820 --> 00:22:23,500
don't render around the client or this

00:22:20,950 --> 00:22:25,360
part needs to be code splitted so there

00:22:23,500 --> 00:22:27,460
are all kinds of ideas you have these

00:22:25,360 --> 00:22:30,430
interesting decorators that in your code

00:22:27,460 --> 00:22:31,990
that turns your source turns your

00:22:30,430 --> 00:22:33,730
eventual output into complete different

00:22:31,990 --> 00:22:36,280
things and I think this is a very

00:22:33,730 --> 00:22:37,840
interesting direction and if done

00:22:36,280 --> 00:22:41,170
correctly this can also be done in a

00:22:37,840 --> 00:22:45,520
framework as the agnostic fashion which

00:22:41,170 --> 00:22:47,400
I believe was Sunil's original his

00:22:45,520 --> 00:22:51,100
original vision

00:22:47,400 --> 00:22:54,820
alright so now time for some view

00:22:51,100 --> 00:22:56,260
specific stuff so we mentioned that you

00:22:54,820 --> 00:22:58,420
can have templates in to render

00:22:56,260 --> 00:23:01,000
functions and we in fact do a lot of

00:22:58,420 --> 00:23:03,130
interesting things during that face the

00:23:01,000 --> 00:23:06,880
first is obviously holding static static

00:23:03,130 --> 00:23:11,560
trees we detect static contents in your

00:23:06,880 --> 00:23:14,800
templates and take them out stored

00:23:11,560 --> 00:23:16,390
somewhere as constants and inks I'll run

00:23:14,800 --> 00:23:19,060
a function we simply return the same

00:23:16,390 --> 00:23:21,000
note over and over again and these nodes

00:23:19,060 --> 00:23:23,740
are considered static and during

00:23:21,000 --> 00:23:25,510
subsequent patches we don't do anything

00:23:23,740 --> 00:23:28,890
about them we just we see oh these are

00:23:25,510 --> 00:23:31,780
the same knows we just skip them

00:23:28,890 --> 00:23:34,650
skipping static bindings if you have a

00:23:31,780 --> 00:23:38,290
class binding that is a plane strain

00:23:34,650 --> 00:23:40,960
it's different it's put into a different

00:23:38,290 --> 00:23:43,300
name space compared to dynamic client

00:23:40,960 --> 00:23:45,130
span class bindings and so all the

00:23:43,300 --> 00:23:46,690
static attributes and Static classes

00:23:45,130 --> 00:23:51,010
don't even need to go through the

00:23:46,690 --> 00:23:54,190
different phase if we are performing

00:23:51,010 --> 00:23:56,770
things correctly and then there's a

00:23:54,190 --> 00:24:00,640
thing called skipping children array

00:23:56,770 --> 00:24:03,880
normalization so if you use JSX or inner

00:24:00,640 --> 00:24:07,410
functions we know that when you you can

00:24:03,880 --> 00:24:12,580
return an array as children of another

00:24:07,410 --> 00:24:15,730
of another element so the result is each

00:24:12,580 --> 00:24:17,770
virtual element can have a children

00:24:15,730 --> 00:24:20,110
array that has nested arrays inside of

00:24:17,770 --> 00:24:22,870
it so it is necessary for the virtual

00:24:20,110 --> 00:24:26,140
Dom runtime to flatten the children

00:24:22,870 --> 00:24:28,100
array in order to perform proper

00:24:26,140 --> 00:24:30,380
distance or if you don't fly

00:24:28,100 --> 00:24:31,820
then you have to cater for the nested

00:24:30,380 --> 00:24:33,850
array scenarios in your in your

00:24:31,820 --> 00:24:38,600
different algorithm which results in

00:24:33,850 --> 00:24:41,090
also results in run time cost so in view

00:24:38,600 --> 00:24:43,010
we also have this problem like for

00:24:41,090 --> 00:24:46,280
example if you use a V for loop things

00:24:43,010 --> 00:24:48,500
inside the children of the UL you will

00:24:46,280 --> 00:24:50,929
have an array a children array with

00:24:48,500 --> 00:24:54,530
nested arrays by default and we will

00:24:50,929 --> 00:24:58,010
need to flatten it and also because

00:24:54,530 --> 00:25:00,409
views jazz the Janicek syntax or the

00:24:58,010 --> 00:25:02,480
hyper script syntax for view render

00:25:00,409 --> 00:25:05,330
functions is pretty flexible so you can

00:25:02,480 --> 00:25:09,260
pass primitive values such as strings

00:25:05,330 --> 00:25:11,270
and numbers as children into the render

00:25:09,260 --> 00:25:13,549
function call so all of these things

00:25:11,270 --> 00:25:16,850
needs to be normalized into actual no

00:25:13,549 --> 00:25:20,360
virtual notes before we pass it to the

00:25:16,850 --> 00:25:22,400
different algorithm so the thing we do

00:25:20,360 --> 00:25:27,080
in the template compiler is we will

00:25:22,400 --> 00:25:28,909
detect cases where we know that the we

00:25:27,080 --> 00:25:31,309
generate codes that basically ensures

00:25:28,909 --> 00:25:34,789
that the children of every elements are

00:25:31,309 --> 00:25:36,320
already a flat array of virtual nodes so

00:25:34,789 --> 00:25:38,600
there will be no edge cases where you

00:25:36,320 --> 00:25:41,480
need to flatten nested arrays or term

00:25:38,600 --> 00:25:44,750
primitives into virtual nodes everything

00:25:41,480 --> 00:25:47,539
is directly generated as pre normalized

00:25:44,750 --> 00:25:49,760
values so this allows our wrong time to

00:25:47,539 --> 00:25:52,700
completely skip the normalization phase

00:25:49,760 --> 00:25:54,200
and so as you can see on the right so

00:25:52,700 --> 00:25:56,720
this is not the exact code that we're

00:25:54,200 --> 00:25:59,419
generating but it kind of gives you the

00:25:56,720 --> 00:26:02,659
idea so we passing additional arguments

00:25:59,419 --> 00:26:04,669
into the into the render function call

00:26:02,659 --> 00:26:07,010
the create element call telling it that

00:26:04,669 --> 00:26:08,450
the children is our pre pre normalized

00:26:07,010 --> 00:26:10,460
so at runtime we don't need to do

00:26:08,450 --> 00:26:12,440
anything about it and for large lists

00:26:10,460 --> 00:26:14,480
this significantly performed our

00:26:12,440 --> 00:26:18,890
improves performance especially on route

00:26:14,480 --> 00:26:23,840
very fast rear Enders and for service I

00:26:18,890 --> 00:26:26,750
rendering right so virtual Tom's virtual

00:26:23,840 --> 00:26:29,630
down based solutions can do service I

00:26:26,750 --> 00:26:31,549
rendering but usually needs to because

00:26:29,630 --> 00:26:34,429
of the nature of virtual Dom you need to

00:26:31,549 --> 00:26:37,460
first create the virtual Dom tree in

00:26:34,429 --> 00:26:39,710
memory before you can serialize it in to

00:26:37,460 --> 00:26:40,780
JavaScript dal-su relies it into

00:26:39,710 --> 00:26:42,730
strengths

00:26:40,780 --> 00:26:45,130
this is one of the primary reasons why

00:26:42,730 --> 00:26:47,080
virtual down based service on rendering

00:26:45,130 --> 00:26:50,200
is typically slower than pure

00:26:47,080 --> 00:26:53,140
string-based templates engines compared

00:26:50,200 --> 00:26:55,750
to compared to playing string templating

00:26:53,140 --> 00:26:57,580
engines or frameworks that perform

00:26:55,750 --> 00:26:59,740
service I rendering using a spilly

00:26:57,580 --> 00:27:01,960
stream based charity like spelt or

00:26:59,740 --> 00:27:03,310
Markel will see that virtual Dom based

00:27:01,960 --> 00:27:08,080
solutions are usually significantly

00:27:03,310 --> 00:27:10,780
slower but so however in the case of

00:27:08,080 --> 00:27:12,250
view we have the template to virtual

00:27:10,780 --> 00:27:14,200
town compilation layer and we can use

00:27:12,250 --> 00:27:17,650
the similar static content detecting

00:27:14,200 --> 00:27:20,170
strategies to optimize part of the

00:27:17,650 --> 00:27:21,820
template that can be any part of the

00:27:20,170 --> 00:27:23,980
template that can be optimizing to pure

00:27:21,820 --> 00:27:25,660
string concatenation z' will be turn

00:27:23,980 --> 00:27:26,350
into pure string concatenation z' at

00:27:25,660 --> 00:27:29,140
compile time

00:27:26,350 --> 00:27:30,670
so this significantly reduces the cost

00:27:29,140 --> 00:27:32,710
of server-side rendering because we no

00:27:30,670 --> 00:27:36,220
longer need to generate all these all of

00:27:32,710 --> 00:27:37,900
these virtual nodes and then and then

00:27:36,220 --> 00:27:40,150
iterate through them to to stringify

00:27:37,900 --> 00:27:43,570
them everything is already a strengths

00:27:40,150 --> 00:27:46,390
and the greatest part is this can still

00:27:43,570 --> 00:27:49,060
be mixed with raw virtual Dom so you get

00:27:46,390 --> 00:27:51,460
the full benefits of being able to drop

00:27:49,060 --> 00:27:54,010
down into the virtual Dom layer and do

00:27:51,460 --> 00:27:56,860
advanced abstraction stuff while

00:27:54,010 --> 00:27:59,110
preserving while gaining performance

00:27:56,860 --> 00:28:00,880
boosts for server-side rendering for

00:27:59,110 --> 00:28:03,880
components that there are still leverage

00:28:00,880 --> 00:28:08,260
and templates so you get kind of get the

00:28:03,880 --> 00:28:10,240
benefits of both worlds and then during

00:28:08,260 --> 00:28:12,970
service our rendering we also have some

00:28:10,240 --> 00:28:17,020
build time optimizations by generating

00:28:12,970 --> 00:28:19,480
to build man effects fests from from web

00:28:17,020 --> 00:28:21,310
pack so we generate one manifest for the

00:28:19,480 --> 00:28:23,680
client and one manifests for the server

00:28:21,310 --> 00:28:25,330
and when we set up the server a server

00:28:23,680 --> 00:28:27,490
renderer we can compare the two

00:28:25,330 --> 00:28:32,650
manifests and being able to infer the

00:28:27,490 --> 00:28:35,230
async chunks we so week we first turned

00:28:32,650 --> 00:28:37,810
the two manifests into a data structure

00:28:35,230 --> 00:28:39,100
that's fed into the server renderer now

00:28:37,810 --> 00:28:40,930
the server rendering has information

00:28:39,100 --> 00:28:43,210
about the both the client and the server

00:28:40,930 --> 00:28:45,510
build and it is able to infer the

00:28:43,210 --> 00:28:48,130
correct async chunks that's required

00:28:45,510 --> 00:28:51,000
when you initiate a request to the

00:28:48,130 --> 00:28:53,910
server so with that we're able to

00:28:51,000 --> 00:28:58,770
forgive ID this meta information

00:28:53,910 --> 00:29:01,020
into the into the HTML template or to

00:28:58,770 --> 00:29:04,580
the server to your raw server so the

00:29:01,020 --> 00:29:07,500
result is we can do things like

00:29:04,580 --> 00:29:09,150
embedding async chunks and automatically

00:29:07,500 --> 00:29:11,100
generating preload and prefetch

00:29:09,150 --> 00:29:13,710
directives for the async chunks needed

00:29:11,100 --> 00:29:15,810
for a specific route and if you set up

00:29:13,710 --> 00:29:17,910
set up this system correctly you don't

00:29:15,810 --> 00:29:19,470
need to do anything manually once this

00:29:17,910 --> 00:29:21,270
is setup everything is automatically

00:29:19,470 --> 00:29:25,680
inferred and in line into the templates

00:29:21,270 --> 00:29:27,780
for you so you're no longer pay the

00:29:25,680 --> 00:29:30,120
penalty of an one extra round-trip of

00:29:27,780 --> 00:29:32,280
when you do code splitting you can't

00:29:30,120 --> 00:29:34,530
just safely split every route which is

00:29:32,280 --> 00:29:38,490
great and another thing is we also

00:29:34,530 --> 00:29:41,460
inline critical CSS be your compile time

00:29:38,490 --> 00:29:43,320
optimizations because the CSS ynx is

00:29:41,460 --> 00:29:45,740
inside a single file view components and

00:29:43,320 --> 00:29:49,440
we're in we're able to convert it

00:29:45,740 --> 00:29:52,710
instead of instead of importing the

00:29:49,440 --> 00:29:54,420
style directly we associate the style

00:29:52,710 --> 00:29:57,090
injection to the lifecycle of the

00:29:54,420 --> 00:29:58,890
component it is placed in this way when

00:29:57,090 --> 00:30:01,080
a component is used during Surfside

00:29:58,890 --> 00:30:03,150
rendering it's associative styles will

00:30:01,080 --> 00:30:05,190
be collected during them during the

00:30:03,150 --> 00:30:07,050
server-side rendering so we know exactly

00:30:05,190 --> 00:30:08,940
which components are used and their

00:30:07,050 --> 00:30:11,540
styles are therefore required for this

00:30:08,940 --> 00:30:14,760
specific request this allows us to

00:30:11,540 --> 00:30:17,160
generate the minimal amount of component

00:30:14,760 --> 00:30:19,410
critical CSS for us for a given request

00:30:17,160 --> 00:30:23,850
Duren serves our rendering and as you

00:30:19,410 --> 00:30:27,330
can see there is this critical CSS part

00:30:23,850 --> 00:30:29,430
which is aligned in the in the final

00:30:27,330 --> 00:30:31,560
result so this is the example request

00:30:29,430 --> 00:30:36,600
you get from the view HT hacker news

00:30:31,560 --> 00:30:37,950
clone demo and finally we have something

00:30:36,600 --> 00:30:39,510
called custom modules for the view

00:30:37,950 --> 00:30:43,320
template compilers so this is a pretty

00:30:39,510 --> 00:30:45,240
advanced feature but if you want to you

00:30:43,320 --> 00:30:47,700
can actually hook into the compilation

00:30:45,240 --> 00:30:50,070
phase of that view template compiler and

00:30:47,700 --> 00:30:54,570
you can provide custom modules and each

00:30:50,070 --> 00:30:59,100
module can transform the ast a template

00:30:54,570 --> 00:31:01,530
AST it can it can also do post

00:30:59,100 --> 00:31:04,020
transforms like just completely rewrite

00:31:01,530 --> 00:31:06,720
the generated code you get a lot of

00:31:04,020 --> 00:31:09,900
flexibility in this architecture and

00:31:06,720 --> 00:31:12,870
one of the prime examples of the such

00:31:09,900 --> 00:31:17,060
usage is bill time internationalization

00:31:12,870 --> 00:31:19,590
so previously the the view

00:31:17,060 --> 00:31:21,080
internationalization package performs

00:31:19,590 --> 00:31:23,250
pure runtime internal

00:31:21,080 --> 00:31:25,350
internationalization but that comes with

00:31:23,250 --> 00:31:29,100
a cost because you're you're shipping

00:31:25,350 --> 00:31:31,500
the whole locales data structure to the

00:31:29,100 --> 00:31:35,190
client and you have to pay the wrong

00:31:31,500 --> 00:31:38,880
time lookup cost and every time

00:31:35,190 --> 00:31:41,070
everywhere you need to do every time you

00:31:38,880 --> 00:31:42,570
need to do internationalization becomes

00:31:41,070 --> 00:31:45,090
a dynamic binding right

00:31:42,570 --> 00:31:47,520
but with compile time optimizations by

00:31:45,090 --> 00:31:50,130
injecting a custom compiler module at

00:31:47,520 --> 00:31:52,110
compile time you can turn all the

00:31:50,130 --> 00:31:56,190
translation internationalization

00:31:52,110 --> 00:31:59,130
directives into purely just setting the

00:31:56,190 --> 00:32:02,520
text contents so this is same as static

00:31:59,130 --> 00:32:03,780
text essentially now you completely get

00:32:02,520 --> 00:32:05,310
rid of all the wrong time cost

00:32:03,780 --> 00:32:07,170
associated with with

00:32:05,310 --> 00:32:09,300
internationalization and you just

00:32:07,170 --> 00:32:14,430
generate different copies of your app

00:32:09,300 --> 00:32:16,890
for different locales okay so I'm

00:32:14,430 --> 00:32:19,410
running out of time but so I will just

00:32:16,890 --> 00:32:21,810
move fast here we do some pretty

00:32:19,410 --> 00:32:23,130
interesting optimizations in weeks which

00:32:21,810 --> 00:32:26,430
is essentially the react native

00:32:23,130 --> 00:32:28,680
equivalent review inside certain types

00:32:26,430 --> 00:32:30,840
of recycle is we generate a different

00:32:28,680 --> 00:32:32,850
code so that we delegate more to the

00:32:30,840 --> 00:32:35,880
native renderer rather than spending the

00:32:32,850 --> 00:32:37,560
Java Runtime so this results in greatly

00:32:35,880 --> 00:32:42,020
improved or list rendering performance

00:32:37,560 --> 00:32:44,760
and some ideas on exploration include

00:32:42,020 --> 00:32:46,980
similar inspired by your spelt we can

00:32:44,760 --> 00:32:51,420
remove features that's not in using your

00:32:46,980 --> 00:32:53,490
view app by doing static analysis we can

00:32:51,420 --> 00:32:55,200
turn compile a single file component

00:32:53,490 --> 00:32:57,150
directly into web components

00:32:55,200 --> 00:33:00,300
this is similar to what stencil in spell

00:32:57,150 --> 00:33:03,750
dies we can even do star on style atomic

00:33:00,300 --> 00:33:05,460
CSS generation at built time because all

00:33:03,750 --> 00:33:07,560
the styles inside your whole view app

00:33:05,460 --> 00:33:09,180
can be extracted and analyzed together

00:33:07,560 --> 00:33:12,510
at the compile time you can do

00:33:09,180 --> 00:33:15,810
minification dedupe and atomic CSS

00:33:12,510 --> 00:33:17,670
generation so static analysis opens

00:33:15,810 --> 00:33:19,110
doors for all kinds of exciting future

00:33:17,670 --> 00:33:21,870
possibilities

00:33:19,110 --> 00:33:23,370
quoting rich heiress and I believe we're

00:33:21,870 --> 00:33:25,380
just getting started I think there are a

00:33:23,370 --> 00:33:27,360
lot more possibilities they are not

00:33:25,380 --> 00:33:30,870
specifically bound to a specific

00:33:27,360 --> 00:33:32,940
framework so I I'm really excited about

00:33:30,870 --> 00:33:36,360
this I think everyone should explore

00:33:32,940 --> 00:33:38,400
this area and I'm I want to see more of

00:33:36,360 --> 00:33:41,420
this kind of experiments coming out for

00:33:38,400 --> 00:33:41,420
other frameworks thank you

00:33:49,779 --> 00:33:51,840

YouTube URL: https://www.youtube.com/watch?v=7iy8XQ7TSnc


