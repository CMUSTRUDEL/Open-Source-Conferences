Title: ReactiveConf 2017: Igor Minar AMA
Publication date: 2017-11-20
Playlist: ReactiveConf 2017
Description: 
	Discovery stage

https://reactiveconf.com/
25th - 27th October 2017, Bratislava, Slovakia
Captions: 
	00:00:02,500 --> 00:00:08,639
[Music]

00:00:09,180 --> 00:00:11,240
you

00:00:14,620 --> 00:00:19,120
have you tried familiar ways for example

00:00:16,960 --> 00:00:21,880
the maybe the webpack approach this like

00:00:19,120 --> 00:00:23,470
the webpack runtime analyzer or these

00:00:21,880 --> 00:00:26,260
alternative approaches to some of these

00:00:23,470 --> 00:00:29,590
ideas I'm not familiar with a back room

00:00:26,260 --> 00:00:32,110
time analyzer can you just quickly

00:00:29,590 --> 00:00:36,040
describe it what does it do you know I

00:00:32,110 --> 00:00:37,450
personally cannot so the thing with

00:00:36,040 --> 00:00:39,610
webpack is that there are lots of

00:00:37,450 --> 00:00:41,860
plugins lots of different options and

00:00:39,610 --> 00:00:43,720
it's hard to figure out what are the

00:00:41,860 --> 00:00:45,400
right ones and that was the point of my

00:00:43,720 --> 00:00:47,320
talk and it's not just web pack it's

00:00:45,400 --> 00:00:48,340
like the whole ecosystem if you want to

00:00:47,320 --> 00:00:50,590
be successful in building the

00:00:48,340 --> 00:00:51,970
application today you're not only to

00:00:50,590 --> 00:00:53,830
understand my pack and all of its

00:00:51,970 --> 00:00:57,160
plugins and the defaults you need to

00:00:53,830 --> 00:00:58,900
override and opt into but you also need

00:00:57,160 --> 00:01:01,330
to understand the libraries you're using

00:00:58,900 --> 00:01:02,740
make sure that using the right format of

00:01:01,330 --> 00:01:05,740
those libraries whether it's coming Jess

00:01:02,740 --> 00:01:09,460
or ESM and then if you have a transpiler

00:01:05,740 --> 00:01:11,170
type secure Babel understand how they

00:01:09,460 --> 00:01:13,450
transpired because that can cause

00:01:11,170 --> 00:01:15,700
problems for uglify so this whole chain

00:01:13,450 --> 00:01:19,479
and anything that chain can cause

00:01:15,700 --> 00:01:21,100
problems we are making sure that this

00:01:19,479 --> 00:01:23,170
gets better over time but today just

00:01:21,100 --> 00:01:25,499
need to be aware of these things and be

00:01:23,170 --> 00:01:29,140
able to opt in to the right options

00:01:25,499 --> 00:01:32,619
which is not fun this is certainly a

00:01:29,140 --> 00:01:35,200
fair point maybe just best guessing

00:01:32,619 --> 00:01:36,609
based off of the name I think a lot of

00:01:35,200 --> 00:01:38,140
the technically kind of talked about are

00:01:36,609 --> 00:01:40,270
traditionally focus on the static

00:01:38,140 --> 00:01:43,030
analysis level right so at compilation

00:01:40,270 --> 00:01:44,259
time we don't have information about say

00:01:43,030 --> 00:01:44,770
for example the runtime types or

00:01:44,259 --> 00:01:46,899
something like that

00:01:44,770 --> 00:01:49,389
if you thought about for example using

00:01:46,899 --> 00:01:50,740
profile guided taking a profile of how

00:01:49,389 --> 00:01:54,939
the application runs and then using that

00:01:50,740 --> 00:02:00,159
in any of these optimizations so one

00:01:54,939 --> 00:02:04,240
thing that we found useful is to look at

00:02:00,159 --> 00:02:10,270
the coverage the coverage report in

00:02:04,240 --> 00:02:11,709
Chrome and Safari code coverage so sorry

00:02:10,270 --> 00:02:15,160
if you if you bootstrap the application

00:02:11,709 --> 00:02:18,819
in dev tools you can check how you code

00:02:15,160 --> 00:02:22,240
ran and which lines execute it and this

00:02:18,819 --> 00:02:24,459
can identify chunks of that code that

00:02:22,240 --> 00:02:25,270
were downloaded but we're not needed

00:02:24,459 --> 00:02:28,480
because we did

00:02:25,270 --> 00:02:29,980
execute them often these dead branches

00:02:28,480 --> 00:02:31,660
are in if statements and there's not

00:02:29,980 --> 00:02:33,460
much you can do about it except the big

00:02:31,660 --> 00:02:37,600
ref and refactoring if it's possible but

00:02:33,460 --> 00:02:39,130
sometimes it finds big chunks of code

00:02:37,600 --> 00:02:40,840
that are just functions that are just

00:02:39,130 --> 00:02:42,880
sitting in the bundle never execute and

00:02:40,840 --> 00:02:43,960
then you can target those and see why

00:02:42,880 --> 00:02:47,140
are they here

00:02:43,960 --> 00:02:48,670
find the retainer and perform the

00:02:47,140 --> 00:02:51,040
optimization necessary to remove those

00:02:48,670 --> 00:02:52,480
is that generally a manual process or is

00:02:51,040 --> 00:02:54,340
there some so right tooling that helps

00:02:52,480 --> 00:02:57,910
out with that right now it's very manual

00:02:54,340 --> 00:02:59,560
process and I'm hoping that as we focus

00:02:57,910 --> 00:03:01,000
more and more of our attention on

00:02:59,560 --> 00:03:03,070
solving these kinds of problems the

00:03:01,000 --> 00:03:06,040
tooling will get better even just

00:03:03,070 --> 00:03:08,470
analyzing dependency graph today is is

00:03:06,040 --> 00:03:10,510
not trivial because usually the tools we

00:03:08,470 --> 00:03:12,880
have they don't show the right kind of

00:03:10,510 --> 00:03:15,700
graph or they get overwhelmed with the

00:03:12,880 --> 00:03:17,200
amount of data because often if you just

00:03:15,700 --> 00:03:19,390
look in the symbol table it can contain

00:03:17,200 --> 00:03:21,040
like thousands and ten hundreds of

00:03:19,390 --> 00:03:22,990
thousands of symbols for a large

00:03:21,040 --> 00:03:25,090
application and these tools get

00:03:22,990 --> 00:03:27,490
overwhelmed you just see big graph with

00:03:25,090 --> 00:03:28,900
like lots of nodes and lots of lots of

00:03:27,490 --> 00:03:30,940
edges between the nodes and you're like

00:03:28,900 --> 00:03:35,350
okay this looks pretty but it doesn't

00:03:30,940 --> 00:03:37,270
tell me anything so I think the more we

00:03:35,350 --> 00:03:40,510
work on these problems we will build

00:03:37,270 --> 00:03:42,070
tools that will help us visualize this

00:03:40,510 --> 00:03:44,620
in a better way I think it's actually

00:03:42,070 --> 00:03:47,230
very similar to what we went through

00:03:44,620 --> 00:03:51,180
when analyzing memory leaks because in a

00:03:47,230 --> 00:03:55,330
way the way I'm starting to think about

00:03:51,180 --> 00:03:58,209
the payload size problem it's it's very

00:03:55,330 --> 00:04:01,350
similar to memory leak issue but instead

00:03:58,209 --> 00:04:06,190
of being runtime memory leak it's like a

00:04:01,350 --> 00:04:07,930
Build time code leak and the same

00:04:06,190 --> 00:04:10,600
techniques that we used to debug memory

00:04:07,930 --> 00:04:13,450
leaks can now be used to debug these

00:04:10,600 --> 00:04:16,510
code leaks and I think the same way how

00:04:13,450 --> 00:04:18,760
we over time build tools to debug and

00:04:16,510 --> 00:04:20,709
visualize problems with memory leaks we

00:04:18,760 --> 00:04:22,000
will do the same thing with this kha'zix

00:04:20,709 --> 00:04:24,340
that's quite a useful analogy I think

00:04:22,000 --> 00:04:26,890
it's oftentimes useful if you can think

00:04:24,340 --> 00:04:28,870
actually this is a problem that has the

00:04:26,890 --> 00:04:30,280
same is Congress with another domain

00:04:28,870 --> 00:04:32,230
over here it's very nice to be able to

00:04:30,280 --> 00:04:34,270
apply those same techniques yeah and and

00:04:32,230 --> 00:04:35,560
it's a generic thing in social

00:04:34,270 --> 00:04:37,000
engineering like most of

00:04:35,560 --> 00:04:40,419
most of the problems we are solving

00:04:37,000 --> 00:04:42,520
today have been already solved in C C++

00:04:40,419 --> 00:04:45,730
Java whatever it is and we're just

00:04:42,520 --> 00:04:47,500
reinventing the same solutions and often

00:04:45,730 --> 00:04:50,380
it's better to just look at how it was

00:04:47,500 --> 00:04:52,780
solved and copied the solution from

00:04:50,380 --> 00:04:54,340
there but the hard part is to find the

00:04:52,780 --> 00:04:56,110
analogy and realize that oh this is the

00:04:54,340 --> 00:04:57,910
same problem as over there but over

00:04:56,110 --> 00:05:00,730
there it was a memory leak for us here

00:04:57,910 --> 00:05:02,790
we're dealing with with pillow ties so

00:05:00,730 --> 00:05:05,860
there's some kind of questions around

00:05:02,790 --> 00:05:08,350
say if you had a theoretically ideal

00:05:05,860 --> 00:05:11,530
tree-shaking approach like you should

00:05:08,350 --> 00:05:13,570
have no dead code whatsoever right what

00:05:11,530 --> 00:05:15,940
is the challenge and kind of like as you

00:05:13,570 --> 00:05:18,280
approach this ideal what are the

00:05:15,940 --> 00:05:21,820
challenges in getting to that not

00:05:18,280 --> 00:05:24,210
breaking because the more

00:05:21,820 --> 00:05:28,240
aggressive you get with optimizations

00:05:24,210 --> 00:05:29,560
the less the less confidence you have

00:05:28,240 --> 00:05:32,620
that you're doing the right thing and

00:05:29,560 --> 00:05:33,760
you're not breaking things a good

00:05:32,620 --> 00:05:35,820
example is closure compiler

00:05:33,760 --> 00:05:39,370
it's the closure compiler is amazing at

00:05:35,820 --> 00:05:42,250
figuring out which code can be removed

00:05:39,370 --> 00:05:44,620
and it does it at a much more granule

00:05:42,250 --> 00:05:46,660
level than any other tools out there

00:05:44,620 --> 00:05:48,580
today because it can actually remove

00:05:46,660 --> 00:05:50,440
methods that are not called in your

00:05:48,580 --> 00:05:53,650
application you can remove properties

00:05:50,440 --> 00:05:56,320
can do rewrites the structure of the

00:05:53,650 --> 00:05:59,380
code in in a crazy way but it only works

00:05:56,320 --> 00:06:01,750
if you provide sufficient type

00:05:59,380 --> 00:06:07,300
information which is very difficult to

00:06:01,750 --> 00:06:09,400
do in in the open source land today at

00:06:07,300 --> 00:06:11,650
Google we have very controlled ecosystem

00:06:09,400 --> 00:06:13,510
where we have typings for all of the api

00:06:11,650 --> 00:06:16,240
is even the library libraries that we

00:06:13,510 --> 00:06:19,090
use but most most of the software we

00:06:16,240 --> 00:06:21,039
compile with closure compiler is built

00:06:19,090 --> 00:06:22,840
at Google and for those we have

00:06:21,039 --> 00:06:25,660
sufficient type information to do this

00:06:22,840 --> 00:06:28,479
kind of optimization safely externally

00:06:25,660 --> 00:06:29,530
also we don't have this so this is this

00:06:28,479 --> 00:06:31,960
is the biggest challenge for closed

00:06:29,530 --> 00:06:33,970
compiler and applying the advanced

00:06:31,960 --> 00:06:35,979
optimizations that are coming from the

00:06:33,970 --> 00:06:38,470
closure compiler in the open source

00:06:35,979 --> 00:06:40,710
community because it often just breaks

00:06:38,470 --> 00:06:43,270
stuff and it's very frustrating to debug

00:06:40,710 --> 00:06:44,770
yeah I'm a huge fan of the Google

00:06:43,270 --> 00:06:45,169
closure compiler especially coming from

00:06:44,770 --> 00:06:47,240
the

00:06:45,169 --> 00:06:49,849
your scripts like it's the things they

00:06:47,240 --> 00:06:53,509
can do are quite amazing you talked a

00:06:49,849 --> 00:06:54,979
little bit about the ability for the

00:06:53,509 --> 00:06:57,259
Google closure compiler to do all sorts

00:06:54,979 --> 00:06:59,029
of crazy optimizations there's a

00:06:57,259 --> 00:07:01,189
question about why is it able to do

00:06:59,029 --> 00:07:03,050
these things where algo phytase for

00:07:01,189 --> 00:07:04,099
example or this other ones are not maybe

00:07:03,050 --> 00:07:06,169
you can tell us like how the type

00:07:04,099 --> 00:07:07,460
information helps it to be able to do

00:07:06,169 --> 00:07:10,430
this kind of thing like what are the

00:07:07,460 --> 00:07:14,300
things that like how does it enable you

00:07:10,430 --> 00:07:16,550
to make these optimizations I'm not an

00:07:14,300 --> 00:07:18,889
expert on the closure compiler internals

00:07:16,550 --> 00:07:21,620
but my understanding is that it uses

00:07:18,889 --> 00:07:24,589
type information to do all of these

00:07:21,620 --> 00:07:27,409
optimizations so if you have a class on

00:07:24,589 --> 00:07:29,960
that you know that has seven methods and

00:07:27,409 --> 00:07:31,969
you see that in the application you use

00:07:29,960 --> 00:07:34,490
this class on in these three different

00:07:31,969 --> 00:07:35,810
sites and you call only two methods then

00:07:34,490 --> 00:07:37,759
you can remove the ones that are not

00:07:35,810 --> 00:07:39,919
used but to do this safely you need to

00:07:37,759 --> 00:07:41,659
know where the call sites are which you

00:07:39,919 --> 00:07:43,069
cannot do in JavaScript because you

00:07:41,659 --> 00:07:46,069
don't have type information everything

00:07:43,069 --> 00:07:49,520
is very dynamically and just decided

00:07:46,069 --> 00:07:50,810
runtime once you do have the type

00:07:49,520 --> 00:07:52,939
information then you can statically

00:07:50,810 --> 00:07:55,099
analyze the code and then realize that

00:07:52,939 --> 00:07:58,569
oh these three methods are not used

00:07:55,099 --> 00:08:01,159
let's remove them how does that kind of

00:07:58,569 --> 00:08:02,899
so given that you need to have a lot of

00:08:01,159 --> 00:08:06,080
this information at build time or

00:08:02,899 --> 00:08:07,550
compile time and then you have you can

00:08:06,080 --> 00:08:10,159
collect this information like we said at

00:08:07,550 --> 00:08:11,300
runtime how does this kind of reflect on

00:08:10,159 --> 00:08:13,339
some of the approaches like Facebook's

00:08:11,300 --> 00:08:15,169
pre-pack or something like that is that

00:08:13,339 --> 00:08:17,300
an interesting route to take where we

00:08:15,169 --> 00:08:20,360
can do some some partial evaluation of

00:08:17,300 --> 00:08:24,110
it at build time we're looking into like

00:08:20,360 --> 00:08:26,149
combining this approaches we don't have

00:08:24,110 --> 00:08:28,580
enough experience to know whether this

00:08:26,149 --> 00:08:29,749
is gonna work or how successful it's

00:08:28,580 --> 00:08:31,189
gonna be but we're definitely looking

00:08:29,749 --> 00:08:34,579
into like can we combine different

00:08:31,189 --> 00:08:38,599
approaches to make these optimizations

00:08:34,579 --> 00:08:41,060
more powerful from an ergonomics point

00:08:38,599 --> 00:08:43,729
of view for angular are you planning

00:08:41,060 --> 00:08:45,500
you've mentioned a little bit about the

00:08:43,729 --> 00:08:47,810
migration path like how do you actually

00:08:45,500 --> 00:08:49,990
go about making it so that the upgrade

00:08:47,810 --> 00:08:53,420
process is as smooth as possible

00:08:49,990 --> 00:08:55,490
so upgrade this is a big challenge for

00:08:53,420 --> 00:08:56,220
from many of the teams that we are

00:08:55,490 --> 00:08:58,440
working

00:08:56,220 --> 00:09:03,029
especially the ones that have large code

00:08:58,440 --> 00:09:05,790
bases we devised several strategies and

00:09:03,029 --> 00:09:09,029
and realize that different strategies

00:09:05,790 --> 00:09:10,980
work for different teams so energy

00:09:09,029 --> 00:09:15,750
upgrade is a library that that we offer

00:09:10,980 --> 00:09:18,149
as a way to crosslink angularjs and

00:09:15,750 --> 00:09:20,639
angular applications at the component

00:09:18,149 --> 00:09:23,819
level what we found out is that this

00:09:20,639 --> 00:09:27,930
works for certain projects but many of

00:09:23,819 --> 00:09:30,300
the teams that are that I'm upgrading to

00:09:27,930 --> 00:09:32,250
to angular they actually want to have

00:09:30,300 --> 00:09:34,199
whole section of application that is

00:09:32,250 --> 00:09:38,910
built just with angular not with the

00:09:34,199 --> 00:09:41,759
legacy angularjs so with with the energy

00:09:38,910 --> 00:09:43,350
energy upgrade approach that we had it

00:09:41,759 --> 00:09:45,600
actually created a single application

00:09:43,350 --> 00:09:47,970
that was using both angular and

00:09:45,600 --> 00:09:51,389
angularjs in the very tightly coupled

00:09:47,970 --> 00:09:53,579
way and these teams found it undesirable

00:09:51,389 --> 00:09:55,379
to have such Ted connection so what they

00:09:53,579 --> 00:09:57,269
asked for was like could we actually

00:09:55,379 --> 00:10:00,569
split the application into two sub

00:09:57,269 --> 00:10:02,939
applications where one is our angularjs

00:10:00,569 --> 00:10:05,220
codebase and the other part is just

00:10:02,939 --> 00:10:07,319
angular and when we need to communicate

00:10:05,220 --> 00:10:09,810
we will manage the communication between

00:10:07,319 --> 00:10:11,360
the two at the service level but at the

00:10:09,810 --> 00:10:13,649
component level we don't want to mix

00:10:11,360 --> 00:10:15,630
angular and English components which is

00:10:13,649 --> 00:10:19,380
a whole section application thankfully

00:10:15,630 --> 00:10:21,870
so because of this we improved the

00:10:19,380 --> 00:10:23,880
energy upgrade library to have a what we

00:10:21,870 --> 00:10:26,279
called energy upgrade light option which

00:10:23,880 --> 00:10:27,750
allows you to create this whole section

00:10:26,279 --> 00:10:30,389
of the application to be either in

00:10:27,750 --> 00:10:32,160
angular or angularjs and this approach

00:10:30,389 --> 00:10:35,880
has been more successful with with large

00:10:32,160 --> 00:10:39,420
teams Google cloud they're going to make

00:10:35,880 --> 00:10:42,680
a big migration right now and they they

00:10:39,420 --> 00:10:45,809
using this approach interesting so is it

00:10:42,680 --> 00:10:47,339
kind of largely a manual process in the

00:10:45,809 --> 00:10:48,899
sense of like here are best practices

00:10:47,339 --> 00:10:51,569
for upgrading here are some tools that

00:10:48,899 --> 00:10:55,639
will give you the best migration path

00:10:51,569 --> 00:10:58,559
versus like an automated kind of upgrade

00:10:55,639 --> 00:11:02,790
there are a few tools that help with

00:10:58,559 --> 00:11:05,490
with automation of the tasks but because

00:11:02,790 --> 00:11:06,769
angular JS is so dynamic it's very

00:11:05,490 --> 00:11:09,739
difficult to

00:11:06,769 --> 00:11:11,300
to statically analyze it and this is the

00:11:09,739 --> 00:11:13,220
biggest difference between angular and

00:11:11,300 --> 00:11:15,350
intelligence with angular we can

00:11:13,220 --> 00:11:17,449
statically analyze the code and use

00:11:15,350 --> 00:11:20,179
tooling to make refactorings with

00:11:17,449 --> 00:11:22,790
English it's not possible so our focus

00:11:20,179 --> 00:11:23,509
is on making the manual work as painless

00:11:22,790 --> 00:11:27,769
as possible

00:11:23,509 --> 00:11:30,350
so that teams can can move over on the

00:11:27,769 --> 00:11:32,360
implementation side of angular kind of

00:11:30,350 --> 00:11:34,309
diving under the hood a little bit you

00:11:32,360 --> 00:11:36,019
know react kind of popularized this idea

00:11:34,309 --> 00:11:37,220
of a virtual DOM and whatnot and it's

00:11:36,019 --> 00:11:41,449
kind of taken off in a few other

00:11:37,220 --> 00:11:44,420
frameworks as well obviously why I mean

00:11:41,449 --> 00:11:46,040
can you speak to maybe why you don't

00:11:44,420 --> 00:11:47,660
adopt this kind of idea or your

00:11:46,040 --> 00:11:48,889
alternative approach to this like the

00:11:47,660 --> 00:11:55,249
trade-offs may be that you did you

00:11:48,889 --> 00:11:57,410
thought about so virtual Dom is the

00:11:55,249 --> 00:12:01,100
change detection mechanism for within

00:11:57,410 --> 00:12:03,670
within react in angular we generate code

00:12:01,100 --> 00:12:06,980
that checks expressions and we do the

00:12:03,670 --> 00:12:10,129
change detection at the model level

00:12:06,980 --> 00:12:15,079
rather than on the under view level we

00:12:10,129 --> 00:12:18,220
found this to be more performant but

00:12:15,079 --> 00:12:20,980
there are certain trade-offs there are

00:12:18,220 --> 00:12:23,720
certain nice properties of hemler saddam

00:12:20,980 --> 00:12:25,369
that we're looking into adopting and

00:12:23,720 --> 00:12:28,100
maybe in the future this is a research

00:12:25,369 --> 00:12:30,230
project we are exploring now you mean

00:12:28,100 --> 00:12:33,740
adopting those features or adopting a

00:12:30,230 --> 00:12:35,779
virtual Dom adopting the the actual

00:12:33,740 --> 00:12:38,689
solution doesn't matter what we are

00:12:35,779 --> 00:12:40,699
after is bringing the features in how is

00:12:38,689 --> 00:12:43,009
it implemented whether to chill Dom or

00:12:40,699 --> 00:12:45,769
not it's not important but we would like

00:12:43,009 --> 00:12:47,449
to give developers a little more

00:12:45,769 --> 00:12:49,249
flexibility when it comes to controlling

00:12:47,449 --> 00:12:50,959
for example projection through the

00:12:49,249 --> 00:12:53,419
components and there are a few other

00:12:50,959 --> 00:12:56,990
features that developers start building

00:12:53,419 --> 00:12:58,579
highly dynamic applications where the

00:12:56,990 --> 00:13:01,399
structure of the application is not

00:12:58,579 --> 00:13:03,970
known at the build time they're asking

00:13:01,399 --> 00:13:07,339
for so we're trying to figure out how to

00:13:03,970 --> 00:13:08,329
bring these features into angular make

00:13:07,339 --> 00:13:11,239
sense

00:13:08,329 --> 00:13:14,149
maybe one of the the benefits that we

00:13:11,239 --> 00:13:15,410
get from optimizations is that we can

00:13:14,149 --> 00:13:16,579
have our cake and eat it too kind of

00:13:15,410 --> 00:13:18,470
thing right I can pull in all of my

00:13:16,579 --> 00:13:19,130
defenses and I never really worry about

00:13:18,470 --> 00:13:20,810
it because

00:13:19,130 --> 00:13:22,490
you know you're going to magically go

00:13:20,810 --> 00:13:23,630
through and shake the tree and make

00:13:22,490 --> 00:13:28,510
magic so that I don't have to worry

00:13:23,630 --> 00:13:30,470
about it but is it wrong to think about

00:13:28,510 --> 00:13:32,600
optimizations in the sense of like now I

00:13:30,470 --> 00:13:35,600
get to go to the buffet and eat and I'll

00:13:32,600 --> 00:13:39,970
never get fat kind of thing I don't

00:13:35,600 --> 00:13:43,100
think it's wrong it's just you shouldn't

00:13:39,970 --> 00:13:46,130
you can rely on it if you also have

00:13:43,100 --> 00:13:47,810
proof that it works and this was my one

00:13:46,130 --> 00:13:49,370
of the last points my presentation is

00:13:47,810 --> 00:13:51,590
that if you don't measure and monitor

00:13:49,370 --> 00:13:54,470
what the end result that you're building

00:13:51,590 --> 00:13:56,600
is then you might be unpleasantly

00:13:54,470 --> 00:13:58,850
surprised when the your users start

00:13:56,600 --> 00:14:02,630
using your application so having the

00:13:58,850 --> 00:14:04,820
understanding what the user experience

00:14:02,630 --> 00:14:07,190
is like and how it's changing as you are

00:14:04,820 --> 00:14:08,840
developing application features is

00:14:07,190 --> 00:14:11,330
important because that can tell you

00:14:08,840 --> 00:14:12,820
whether you do need to worry or not you

00:14:11,330 --> 00:14:15,500
don't need to worry about these things

00:14:12,820 --> 00:14:17,900
you will quickly find out if things work

00:14:15,500 --> 00:14:19,040
or done yeah make sense as long as

00:14:17,900 --> 00:14:20,560
you're measuring it you're aware of this

00:14:19,040 --> 00:14:22,550
kind of yeah

00:14:20,560 --> 00:14:25,220
so there's a nishan kind of question

00:14:22,550 --> 00:14:27,110
about so you can do these optimizations

00:14:25,220 --> 00:14:28,670
within a kind of controlled environment

00:14:27,110 --> 00:14:31,040
right Google closure for example is

00:14:28,670 --> 00:14:33,470
aware of all this etiquette type you can

00:14:31,040 --> 00:14:35,180
do lots of magic but oftentimes we don't

00:14:33,470 --> 00:14:36,620
control the dependencies that we bring

00:14:35,180 --> 00:14:37,910
we've had the choice not to bring them

00:14:36,620 --> 00:14:39,710
in but you know maybe we're not going to

00:14:37,910 --> 00:14:42,230
re-implement them so there's this huge

00:14:39,710 --> 00:14:45,080
fast kind of sea of npm and all these

00:14:42,230 --> 00:14:46,840
other JavaScript packages out there how

00:14:45,080 --> 00:14:49,430
should we think about approaching

00:14:46,840 --> 00:14:50,870
applying these optimizations to all

00:14:49,430 --> 00:14:52,340
these dependencies like do we just draw

00:14:50,870 --> 00:14:53,720
a line and we say we can't do anything

00:14:52,340 --> 00:14:58,010
for you over here we can't do this tree

00:14:53,720 --> 00:14:58,820
shaking no or not I think it's it's all

00:14:58,010 --> 00:15:03,710
about awareness

00:14:58,820 --> 00:15:06,800
I think the libraries that are causing

00:15:03,710 --> 00:15:08,930
problems for developers and our

00:15:06,800 --> 00:15:11,890
resulting in poor user experience will

00:15:08,930 --> 00:15:14,240
fall out of favor if they don't change

00:15:11,890 --> 00:15:17,690
the problem we have today it's not even

00:15:14,240 --> 00:15:19,250
clear who's causing the problem you know

00:15:17,690 --> 00:15:21,800
you have you have lots of dependencies

00:15:19,250 --> 00:15:24,560
lots of transformations in the build

00:15:21,800 --> 00:15:26,030
pipeline so I didn't find the culprit is

00:15:24,560 --> 00:15:28,490
very difficult

00:15:26,030 --> 00:15:31,100
but once we do and once we make it clear

00:15:28,490 --> 00:15:32,240
that library expert and why does not

00:15:31,100 --> 00:15:34,550
optimize and prevents other

00:15:32,240 --> 00:15:36,770
optimizations in the application then

00:15:34,550 --> 00:15:38,750
the library either needs to be fixed or

00:15:36,770 --> 00:15:40,130
we need to find a replacement for the

00:15:38,750 --> 00:15:42,850
library that doesn't cause the problem

00:15:40,130 --> 00:15:45,500
those bones is there some sort of

00:15:42,850 --> 00:15:47,300
recommendation or guides that you you

00:15:45,500 --> 00:15:48,560
kind of wish that the JavaScript

00:15:47,300 --> 00:15:50,390
community would adhere to that would

00:15:48,560 --> 00:15:53,480
enable more of these kind of consistent

00:15:50,390 --> 00:15:55,790
optimizations I think just jumping on

00:15:53,480 --> 00:15:57,860
the years modules is the single most

00:15:55,790 --> 00:15:59,990
important thing everybody can help with

00:15:57,860 --> 00:16:02,000
everybody who ships libraries there

00:15:59,990 --> 00:16:05,870
should be an option for shipping yes

00:16:02,000 --> 00:16:08,570
modules it's it's four different

00:16:05,870 --> 00:16:13,250
libraries it can be either easy or

00:16:08,570 --> 00:16:15,050
difficult because we don't want to break

00:16:13,250 --> 00:16:16,940
the ecosystem common jeaious is

00:16:15,050 --> 00:16:20,000
currently used by lots of node

00:16:16,940 --> 00:16:23,090
applications we found a way how we can

00:16:20,000 --> 00:16:25,490
ship both common J's and ears modules in

00:16:23,090 --> 00:16:28,070
the same package and this is what we do

00:16:25,490 --> 00:16:30,640
for all of the angular libraries it

00:16:28,070 --> 00:16:32,900
works because of the the style of

00:16:30,640 --> 00:16:33,470
modular ization that we use within the

00:16:32,900 --> 00:16:35,720
packages

00:16:33,470 --> 00:16:37,910
it was much trickier to do it in eric's

00:16:35,720 --> 00:16:41,150
chairs where there are lots of lots of

00:16:37,910 --> 00:16:43,310
paths from which you import each

00:16:41,150 --> 00:16:48,970
operator can be imported from a new a

00:16:43,310 --> 00:16:52,960
new path and this kind of deeply

00:16:48,970 --> 00:16:55,280
modularized as ironic as it sounds

00:16:52,960 --> 00:16:56,990
packages are problematic when it comes

00:16:55,280 --> 00:16:59,630
to shipping in both countries and here's

00:16:56,990 --> 00:17:02,120
Martian version so I think what we did

00:16:59,630 --> 00:17:04,100
in in rxjs we worked with our access

00:17:02,120 --> 00:17:06,170
team and we implemented a solution where

00:17:04,100 --> 00:17:08,060
you have to opt in and create this alias

00:17:06,170 --> 00:17:10,610
for ears modules to be pulled into

00:17:08,060 --> 00:17:13,340
webpack ideally you shouldn't need to do

00:17:10,610 --> 00:17:16,640
anything the package.json should

00:17:13,340 --> 00:17:18,680
describe enough you should have enough

00:17:16,640 --> 00:17:20,630
information for the tools to just do the

00:17:18,680 --> 00:17:24,590
right thing out of the box and I think

00:17:20,630 --> 00:17:26,450
we'll make some changes in the RHS API

00:17:24,590 --> 00:17:29,480
use to make this work out of the box in

00:17:26,450 --> 00:17:31,250
the next major version but summary would

00:17:29,480 --> 00:17:32,540
be definitely es modules is the biggest

00:17:31,250 --> 00:17:35,230
thing that we need to be doing as a

00:17:32,540 --> 00:17:35,230
JavaScript community

00:17:35,810 --> 00:17:39,380
kind of along those lines though you

00:17:37,910 --> 00:17:40,450
know there's a spectrum between the

00:17:39,380 --> 00:17:43,790
optimizations you can do obviously

00:17:40,450 --> 00:17:45,050
statically with limited information you

00:17:43,790 --> 00:17:46,930
have kind of think of it a little things

00:17:45,050 --> 00:17:50,810
like free pack you have runtime profile

00:17:46,930 --> 00:17:51,890
guided optimizations that you can do are

00:17:50,810 --> 00:17:54,050
there any concerns kind of one of your

00:17:51,890 --> 00:17:55,190
dynamically loading these modules say

00:17:54,050 --> 00:17:56,150
like you don't necessarily know what

00:17:55,190 --> 00:17:58,220
you're going to be calling ahead of time

00:17:56,150 --> 00:18:01,280
or you're kind of loading them in

00:17:58,220 --> 00:18:05,560
browser like what concerns might you

00:18:01,280 --> 00:18:07,430
have around that versions queue

00:18:05,560 --> 00:18:10,280
especially if you have long-running

00:18:07,430 --> 00:18:13,160
applications this is something that many

00:18:10,280 --> 00:18:14,390
people don't think about much until it's

00:18:13,160 --> 00:18:16,210
too late

00:18:14,390 --> 00:18:18,740
if you have application like Gmail or

00:18:16,210 --> 00:18:21,530
calendar that are open for long periods

00:18:18,740 --> 00:18:23,180
of time and after the application has

00:18:21,530 --> 00:18:24,590
been running for a week somebody clicks

00:18:23,180 --> 00:18:26,780
on the button and you're lazy load code

00:18:24,590 --> 00:18:27,860
if you don't have the right version of

00:18:26,780 --> 00:18:29,540
that code available on the server

00:18:27,860 --> 00:18:32,810
because in the meantime you deploy the

00:18:29,540 --> 00:18:34,700
new version you will have some

00:18:32,810 --> 00:18:37,400
unpleasant surprises on the on the

00:18:34,700 --> 00:18:39,890
client side so these are things that we

00:18:37,400 --> 00:18:42,380
often don't even think about outside of

00:18:39,890 --> 00:18:43,970
like these huge projects that have

00:18:42,380 --> 00:18:46,850
sufficient infrastructure to deal with

00:18:43,970 --> 00:18:50,000
these problems but I think as we build

00:18:46,850 --> 00:18:52,100
more and more applications that are

00:18:50,000 --> 00:18:53,570
sophisticated and running in for a long

00:18:52,100 --> 00:18:54,410
time in the browser we will need to

00:18:53,570 --> 00:18:56,570
build dealing with these problems

00:18:54,410 --> 00:18:59,210
serviceworker is a nice solution because

00:18:56,570 --> 00:19:01,310
it allows you to download the whole

00:18:59,210 --> 00:19:02,600
application in the background and cache

00:19:01,310 --> 00:19:03,940
it and that way you don't need to worry

00:19:02,600 --> 00:19:06,230
about the versioning on the server side

00:19:03,940 --> 00:19:07,280
but even there the serviceworker needs

00:19:06,230 --> 00:19:08,720
to be implemented in the right way

00:19:07,280 --> 00:19:11,270
because you can have multiple tabs open

00:19:08,720 --> 00:19:13,060
at different time and you might have

00:19:11,270 --> 00:19:17,030
different version of the serviceworker

00:19:13,060 --> 00:19:18,740
active in these tabs version of the

00:19:17,030 --> 00:19:19,910
application opening this time this is

00:19:18,740 --> 00:19:23,240
quite a unique problem to think about

00:19:19,910 --> 00:19:25,070
actually so angular elements was

00:19:23,240 --> 00:19:26,510
announced recently I don't maybe can

00:19:25,070 --> 00:19:27,950
speak a little bit about that if you

00:19:26,510 --> 00:19:29,330
have anything that you think is

00:19:27,950 --> 00:19:29,720
particularly interesting for this

00:19:29,330 --> 00:19:32,150
audience

00:19:29,720 --> 00:19:34,700
angular elements is a way to expose

00:19:32,150 --> 00:19:37,220
angular components as custom elements so

00:19:34,700 --> 00:19:38,930
if you have an application where you

00:19:37,220 --> 00:19:42,210
just want to drop in certain components

00:19:38,930 --> 00:19:43,920
that you built in angular

00:19:42,210 --> 00:19:45,960
that's not angular applications just

00:19:43,920 --> 00:19:48,450
some ink ups encapsulate the component

00:19:45,960 --> 00:19:50,430
and angular elements is the solution for

00:19:48,450 --> 00:19:53,370
that it's currently in angular lab so

00:19:50,430 --> 00:19:56,910
we're still gathering feedback and

00:19:53,370 --> 00:19:58,500
testing invariants environments but it's

00:19:56,910 --> 00:20:02,160
been very popular especially for

00:19:58,500 --> 00:20:04,560
solutions where you have a CMS site that

00:20:02,160 --> 00:20:08,340
needs to bring in different widgets on a

00:20:04,560 --> 00:20:09,960
page how does that affect things like

00:20:08,340 --> 00:20:11,460
maybe the bundle size right if I'm

00:20:09,960 --> 00:20:15,000
pulling in all these angular elements

00:20:11,460 --> 00:20:15,930
for a CMS so this is this is one of the

00:20:15,000 --> 00:20:20,670
things that we are still exploring

00:20:15,930 --> 00:20:23,040
because it depends on should how

00:20:20,670 --> 00:20:24,300
sophisticated the component is because

00:20:23,040 --> 00:20:26,520
we have to option basically either

00:20:24,300 --> 00:20:29,220
bundle angular with the component for

00:20:26,520 --> 00:20:33,470
each component which is which is

00:20:29,220 --> 00:20:36,090
possible as long as the component is not

00:20:33,470 --> 00:20:36,990
using a whole lot of features of angular

00:20:36,090 --> 00:20:40,440
because then you have a lot of

00:20:36,990 --> 00:20:42,390
duplication the other option is you load

00:20:40,440 --> 00:20:44,460
angular ones and have all these custom

00:20:42,390 --> 00:20:49,380
elements share it the challenge there is

00:20:44,460 --> 00:20:50,850
how do we ensure that there is version

00:20:49,380 --> 00:20:52,380
compatibility between all of these

00:20:50,850 --> 00:20:54,200
custom elements because they might have

00:20:52,380 --> 00:20:56,070
been developed at different times so

00:20:54,200 --> 00:20:58,440
these are the things that we're still

00:20:56,070 --> 00:20:59,640
looking into and gathering feedback from

00:20:58,440 --> 00:21:00,270
the community and people that are using

00:20:59,640 --> 00:21:02,130
these sources

00:21:00,270 --> 00:21:03,690
how about concerns around for example

00:21:02,130 --> 00:21:04,500
performance if I have multiple versions

00:21:03,690 --> 00:21:07,620
of these things

00:21:04,500 --> 00:21:09,090
and they're all say for example not

00:21:07,620 --> 00:21:11,910
sharing the same version of angular

00:21:09,090 --> 00:21:13,170
should I be concerned about having

00:21:11,910 --> 00:21:15,180
multiple versions of the games running

00:21:13,170 --> 00:21:17,490
are we talking about runtime performance

00:21:15,180 --> 00:21:23,850
runtime performance yes it's doesn't

00:21:17,490 --> 00:21:26,490
matter doesn't matter very cool I said

00:21:23,850 --> 00:21:27,840
basically someone wants to know do you

00:21:26,490 --> 00:21:29,520
have anything groundbreaking

00:21:27,840 --> 00:21:30,960
announcements you want to to give us for

00:21:29,520 --> 00:21:32,130
for angular is there anything really

00:21:30,960 --> 00:21:34,200
cool that you're working on that we

00:21:32,130 --> 00:21:37,110
should be looking forward to version 5

00:21:34,200 --> 00:21:38,790
is almost out I need to check with the

00:21:37,110 --> 00:21:41,130
team because we have just working on the

00:21:38,790 --> 00:21:45,480
very last few things I think the last RC

00:21:41,130 --> 00:21:48,480
went out last night so unless there are

00:21:45,480 --> 00:21:50,970
any more new problems five should be out

00:21:48,480 --> 00:21:51,910
should be backwards compatible for most

00:21:50,970 --> 00:21:54,580
of the

00:21:51,910 --> 00:21:56,190
patience using version for today so the

00:21:54,580 --> 00:22:00,370
upgrade should be super smooth smooth

00:21:56,190 --> 00:22:02,620
and we baked in a whole bunch of nice

00:22:00,370 --> 00:22:04,000
features and size optimization and stuff

00:22:02,620 --> 00:22:05,320
like what what are you most proud of in

00:22:04,000 --> 00:22:06,850
terms of the features were most excited

00:22:05,320 --> 00:22:08,440
about I'm excited about the

00:22:06,850 --> 00:22:11,380
serviceworker becoming first class

00:22:08,440 --> 00:22:12,700
citizen within the angular ecosystem so

00:22:11,380 --> 00:22:15,540
we're gonna be shipping a library that

00:22:12,700 --> 00:22:18,850
makes it super easy to integrate

00:22:15,540 --> 00:22:21,910
serviceworker into application and with

00:22:18,850 --> 00:22:25,030
serviceworker we're gonna be solving the

00:22:21,910 --> 00:22:27,520
problem of the network latency which was

00:22:25,030 --> 00:22:30,490
yesterday when i was demonstrating the

00:22:27,520 --> 00:22:32,290
application i showed like half of this

00:22:30,490 --> 00:22:35,050
time is spent in network and the other

00:22:32,290 --> 00:22:37,810
half is javascript serious results that

00:22:35,050 --> 00:22:39,610
first half of the problem so that's

00:22:37,810 --> 00:22:43,630
gonna be look cool it's gonna enable

00:22:39,610 --> 00:22:46,360
offline applications upgrading in the

00:22:43,630 --> 00:22:48,460
background stuff are there concerns

00:22:46,360 --> 00:22:51,340
about managing maybe the complexity like

00:22:48,460 --> 00:22:53,200
as we get more sophisticated tooling and

00:22:51,340 --> 00:22:55,840
more options right we have more power at

00:22:53,200 --> 00:22:56,890
our disposal there are more and more

00:22:55,840 --> 00:22:59,770
things that we actually have to be aware

00:22:56,890 --> 00:23:01,360
of now right we have to be aware of the

00:22:59,770 --> 00:23:02,650
time it takes to maybe parsed tons of

00:23:01,360 --> 00:23:05,040
java scripts right which was not a thing

00:23:02,650 --> 00:23:08,410
that we really worried about beforehand

00:23:05,040 --> 00:23:10,000
is there some way that you have of

00:23:08,410 --> 00:23:11,740
maintaining the complexity across all

00:23:10,000 --> 00:23:14,950
these different concerns inside of an

00:23:11,740 --> 00:23:17,070
application I think the most important

00:23:14,950 --> 00:23:20,200
thing is that we have the right defaults

00:23:17,070 --> 00:23:22,750
which we currently don't and that that's

00:23:20,200 --> 00:23:24,550
what I showed in in my presentation

00:23:22,750 --> 00:23:27,100
yesterday because once you have the

00:23:24,550 --> 00:23:29,440
right defaults then many of these things

00:23:27,100 --> 00:23:32,460
you don't think about they just work if

00:23:29,440 --> 00:23:34,990
you need to opt into every best practice

00:23:32,460 --> 00:23:36,850
then you need to know about every best

00:23:34,990 --> 00:23:38,290
practice even though it's not something

00:23:36,850 --> 00:23:40,660
you should be concerned about like you

00:23:38,290 --> 00:23:43,390
shouldn't really be concerned about rxjs

00:23:40,660 --> 00:23:45,940
being shipped in yes modules or babel

00:23:43,390 --> 00:23:48,550
transplanting your code and fitting into

00:23:45,940 --> 00:23:49,990
web pack using these modules you should

00:23:48,550 --> 00:23:51,850
just write their code and web pack

00:23:49,990 --> 00:23:54,670
should pull it in in the most efficient

00:23:51,850 --> 00:23:58,060
way for it to do the optimizations so i

00:23:54,670 --> 00:24:02,260
think it's very important that everybody

00:23:58,060 --> 00:24:03,720
who contributes to the web ecosystem has

00:24:02,260 --> 00:24:06,030
this in mind and

00:24:03,720 --> 00:24:11,010
works with everybody else in the

00:24:06,030 --> 00:24:14,760
ecosystem to get us on the true good

00:24:11,010 --> 00:24:16,919
default kind of along those lines so I

00:24:14,760 --> 00:24:18,179
want to have good defaults I want to

00:24:16,919 --> 00:24:19,770
have the ability to measure all these

00:24:18,179 --> 00:24:21,240
things is anything you recommend for

00:24:19,770 --> 00:24:26,309
kind of automated measuring and

00:24:21,240 --> 00:24:29,309
monitoring of these applications what we

00:24:26,309 --> 00:24:31,830
did is in in some of the applications

00:24:29,309 --> 00:24:34,169
that I work on we integrated a

00:24:31,830 --> 00:24:37,799
lighthouse into our Co infrastructure so

00:24:34,169 --> 00:24:41,010
we run on each pull request and merge we

00:24:37,799 --> 00:24:44,340
run lighthouse tests that called a bunch

00:24:41,010 --> 00:24:47,159
of issues we also monitor the payload

00:24:44,340 --> 00:24:48,960
size we don't use any fancy tools for

00:24:47,159 --> 00:24:50,789
this we're just building application and

00:24:48,960 --> 00:24:54,150
then storing the the current size in a

00:24:50,789 --> 00:24:56,429
firebase database and we break the build

00:24:54,150 --> 00:24:59,340
if there is an unexpected change in the

00:24:56,429 --> 00:25:01,590
payload size so then we'll proceed or

00:24:59,340 --> 00:25:03,570
have to fix it or they have to explain

00:25:01,590 --> 00:25:07,350
why it cannot why we have to increase

00:25:03,570 --> 00:25:08,880
the current budget we have and justify

00:25:07,350 --> 00:25:10,590
it it's quite an interesting process

00:25:08,880 --> 00:25:12,600
it's kind of it's not initially an

00:25:10,590 --> 00:25:13,590
automated thing but it's baked into the

00:25:12,600 --> 00:25:15,059
culture of how you have to do this

00:25:13,590 --> 00:25:17,640
process you're aware if you're

00:25:15,059 --> 00:25:19,110
accidentally I think one because if you

00:25:17,640 --> 00:25:23,580
if you don't create this kind of checks

00:25:19,110 --> 00:25:25,320
things will just creep in over time and

00:25:23,580 --> 00:25:28,530
then it's very difficult to come back

00:25:25,320 --> 00:25:32,190
and and figure out wise application

00:25:28,530 --> 00:25:35,010
large initially if you spend a lot of

00:25:32,190 --> 00:25:38,220
time decreasing the size and understand

00:25:35,010 --> 00:25:40,799
where the gaps are you understand this

00:25:38,220 --> 00:25:43,950
is the best we can do today if you say

00:25:40,799 --> 00:25:46,860
like if we go any anything about this

00:25:43,950 --> 00:25:49,080
then we better have a good reason for

00:25:46,860 --> 00:25:50,340
this and you have an automated check

00:25:49,080 --> 00:25:52,590
then you can enforce it throughout the

00:25:50,340 --> 00:25:54,450
team I really like this idea like I'm

00:25:52,590 --> 00:25:55,740
not relying on my own discipline to

00:25:54,450 --> 00:25:57,210
always be aware of this rather I have

00:25:55,740 --> 00:25:59,039
tools that are enforced like telling me

00:25:57,210 --> 00:26:01,320
whenever I'm it's not about you know the

00:25:59,039 --> 00:26:04,500
thing is that most of us work on the

00:26:01,320 --> 00:26:06,120
team with many other people and I'm not

00:26:04,500 --> 00:26:10,380
saying that people are not disciplined

00:26:06,120 --> 00:26:13,580
but it's hard I am certainly not sir I'm

00:26:10,380 --> 00:26:17,650
trying and failing but if you have

00:26:13,580 --> 00:26:19,670
you'll see I tell you hey this is wrong

00:26:17,650 --> 00:26:21,920
there is something wrong with it with

00:26:19,670 --> 00:26:24,290
your code it also shows that during code

00:26:21,920 --> 00:26:26,930
reviews and that's the best time when

00:26:24,290 --> 00:26:29,000
you can deal with these issues so just

00:26:26,930 --> 00:26:31,730
putting it into making it into the

00:26:29,000 --> 00:26:34,150
process just like we added tests and

00:26:31,730 --> 00:26:37,970
automated testing into the process

00:26:34,150 --> 00:26:40,520
adding size monitoring inter-process

00:26:37,970 --> 00:26:42,800
it's very good so maybe one last

00:26:40,520 --> 00:26:45,500
question then there was a question about

00:26:42,800 --> 00:26:46,820
if I'm an angular developer how would

00:26:45,500 --> 00:26:49,400
you recommend that I kind of improve my

00:26:46,820 --> 00:26:51,500
skills like how do I actually become the

00:26:49,400 --> 00:26:52,910
best angular developer possible why do

00:26:51,500 --> 00:26:55,250
you want to become the best angular

00:26:52,910 --> 00:26:57,590
they're all possible oh I want to be

00:26:55,250 --> 00:27:00,920
effective at my I think you should work

00:26:57,590 --> 00:27:02,480
on being the best developer possible are

00:27:00,920 --> 00:27:04,160
rather than best angular position and

00:27:02,480 --> 00:27:06,230
angular developer possible because

00:27:04,160 --> 00:27:09,670
angular is just a tool to build

00:27:06,230 --> 00:27:12,920
applications and I kind of worried that

00:27:09,670 --> 00:27:14,870
if people focus just on one technology

00:27:12,920 --> 00:27:17,390
and become masters of the technology

00:27:14,870 --> 00:27:18,500
they often lose out on many other things

00:27:17,390 --> 00:27:20,590
that are happening outside of the

00:27:18,500 --> 00:27:26,090
technology so I think the goal should be

00:27:20,590 --> 00:27:28,520
know your tool but also be good

00:27:26,090 --> 00:27:30,170
generalist and understand the principles

00:27:28,520 --> 00:27:33,520
you know how things work like yesterday

00:27:30,170 --> 00:27:36,710
the talk I gave it was angular it was

00:27:33,520 --> 00:27:38,420
relevant to the angular community but

00:27:36,710 --> 00:27:40,580
it's also it was also relevant to

00:27:38,420 --> 00:27:42,470
anybody who knows not using angular and

00:27:40,580 --> 00:27:44,570
I think it's important to understand

00:27:42,470 --> 00:27:47,270
these kind of things like how things

00:27:44,570 --> 00:27:49,070
work in general rather than be highly

00:27:47,270 --> 00:27:51,080
focused on on one area how do you

00:27:49,070 --> 00:27:54,440
balance the concerns then of this

00:27:51,080 --> 00:27:57,170
problem of being a jack of all trades

00:27:54,440 --> 00:27:59,240
and a master of none so like I I'm

00:27:57,170 --> 00:28:00,680
familiar with a bit of Haskell and a bit

00:27:59,240 --> 00:28:03,380
of PHP and a bit of JavaScript and I

00:28:00,680 --> 00:28:05,270
can't actually ship anything right isn't

00:28:03,380 --> 00:28:07,810
it kind of good to go very very deep in

00:28:05,270 --> 00:28:07,810
some tools

00:28:08,070 --> 00:28:11,190
[Music]

00:28:12,080 --> 00:28:19,990
I think just having the right balance is

00:28:17,019 --> 00:28:23,539
still the way to go

00:28:19,990 --> 00:28:25,850
understanding how what works what makes

00:28:23,539 --> 00:28:27,440
good applications good even just from

00:28:25,850 --> 00:28:29,090
the product perspective you know this is

00:28:27,440 --> 00:28:33,350
what many developers are missing like

00:28:29,090 --> 00:28:35,059
why why is this application good from

00:28:33,350 --> 00:28:38,059
the product perspective does it fulfill

00:28:35,059 --> 00:28:41,000
the user needs does it make people happy

00:28:38,059 --> 00:28:43,850
and productive when they are using it we

00:28:41,000 --> 00:28:45,169
often don't understand these things as

00:28:43,850 --> 00:28:48,889
developers because we are so focused on

00:28:45,169 --> 00:28:50,929
technology and then we build solutions

00:28:48,889 --> 00:28:53,600
that are technologically super advanced

00:28:50,929 --> 00:28:57,289
but users that are using it they hate in

00:28:53,600 --> 00:29:00,730
it because they can't find the button or

00:28:57,289 --> 00:29:02,840
whatever you know like user problem that

00:29:00,730 --> 00:29:06,649
we are solving problems that they don't

00:29:02,840 --> 00:29:09,080
have right so looking at the the problem

00:29:06,649 --> 00:29:10,940
from the bigger perspective and

00:29:09,080 --> 00:29:13,700
understanding what is it that actually

00:29:10,940 --> 00:29:15,289
helps people and then finding the right

00:29:13,700 --> 00:29:17,419
technology and the right approach to

00:29:15,289 --> 00:29:19,490
implement the solution is the way to go

00:29:17,419 --> 00:29:20,870
it sounds quite actionable very nice

00:29:19,490 --> 00:29:21,980
thank you very much please give it up

00:29:20,870 --> 00:29:25,989
for Gore

00:29:21,980 --> 00:29:25,989
[Applause]

00:29:30,590 --> 00:29:32,650

YouTube URL: https://www.youtube.com/watch?v=pYn-zQrRi7k


