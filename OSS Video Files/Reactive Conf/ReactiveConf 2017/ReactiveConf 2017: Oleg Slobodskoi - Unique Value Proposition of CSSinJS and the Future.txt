Title: ReactiveConf 2017: Oleg Slobodskoi - Unique Value Proposition of CSSinJS and the Future
Publication date: 2017-11-20
Playlist: ReactiveConf 2017
Description: 
	Discovery stage

https://reactiveconf.com/
25th - 27th October 2017, Bratislava, Slovakia
Captions: 
	00:00:02,020 --> 00:00:07,440
[Music]

00:00:09,200 --> 00:00:11,260
you

00:00:14,610 --> 00:00:23,040
alright hello everyone and welcome back

00:00:18,900 --> 00:00:26,939
to the future for too many of us or

00:00:23,040 --> 00:00:34,260
citizen GS is about a few years old but

00:00:26,939 --> 00:00:38,370
in reality it's over 20 years old so the

00:00:34,260 --> 00:00:41,190
concept is really old and imagine you

00:00:38,370 --> 00:00:44,100
just came back from to the future and

00:00:41,190 --> 00:00:45,989
you know something has changed in this

00:00:44,100 --> 00:00:48,180
new beautiful world of software

00:00:45,989 --> 00:00:51,180
engineering something is different now

00:00:48,180 --> 00:00:54,750
we are not thinking in websites anymore

00:00:51,180 --> 00:00:56,580
we are thinking in components and we are

00:00:54,750 --> 00:01:03,089
basically not building websites anymore

00:00:56,580 --> 00:01:05,790
we are building applications so I work

00:01:03,089 --> 00:01:08,430
at the company called great and we are

00:01:05,790 --> 00:01:11,310
building a chat application which is

00:01:08,430 --> 00:01:14,580
similar to slag and I consider these to

00:01:11,310 --> 00:01:17,760
be an application so what what is an

00:01:14,580 --> 00:01:20,250
actual difference between web sites and

00:01:17,760 --> 00:01:25,580
applications I couldn't find any good

00:01:20,250 --> 00:01:28,890
explanation to that so I created mine

00:01:25,580 --> 00:01:30,840
and so I think that web apps have

00:01:28,890 --> 00:01:33,620
complex interactions and maintain a

00:01:30,840 --> 00:01:39,720
state on the client while web sites

00:01:33,620 --> 00:01:42,180
mostly render static information so as I

00:01:39,720 --> 00:01:44,790
created this library called JSS I was

00:01:42,180 --> 00:01:47,040
asked a lot like what is a unique value

00:01:44,790 --> 00:01:49,350
what what can it do that you cannot do

00:01:47,040 --> 00:01:55,290
otherwise with all the pre-processing

00:01:49,350 --> 00:01:57,330
tools on a server and that I was always

00:01:55,290 --> 00:01:59,700
trying to explain why I do CSS and J's

00:01:57,330 --> 00:02:01,380
and you know I was not really explaining

00:01:59,700 --> 00:02:05,010
the unique value proposition of it

00:02:01,380 --> 00:02:07,440
because it has so many things you have

00:02:05,010 --> 00:02:09,119
to know about it that we have been

00:02:07,440 --> 00:02:11,640
always talking about unique class names

00:02:09,119 --> 00:02:14,250
and modules and variables and all that

00:02:11,640 --> 00:02:17,610
but those things can be done on the

00:02:14,250 --> 00:02:19,620
server whisper processing right so today

00:02:17,610 --> 00:02:22,650
I'm gonna talk about things which I

00:02:19,620 --> 00:02:26,569
think are more unique to CSS yes

00:02:22,650 --> 00:02:29,780
and my agenda is publishing theming

00:02:26,569 --> 00:02:33,079
data-driven styling and a little bit

00:02:29,780 --> 00:02:38,540
about the future of sessions and yes so

00:02:33,079 --> 00:02:41,420
let's talk about publishing software

00:02:38,540 --> 00:02:45,859
engineering is complex this is probably

00:02:41,420 --> 00:02:48,200
the only thing we all agree on so the

00:02:45,859 --> 00:02:50,450
only way I know to make software

00:02:48,200 --> 00:02:55,030
engineering easier is to rely on own

00:02:50,450 --> 00:02:56,989
work of each other and the modern way to

00:02:55,030 --> 00:02:59,419
publish something and to produce

00:02:56,989 --> 00:03:02,870
something is to use the NPM registry

00:02:59,419 --> 00:03:06,379
which has almost 600,000 packages which

00:03:02,870 --> 00:03:11,120
is enormous though the real problem is

00:03:06,379 --> 00:03:14,419
with this is equality and kmgl is

00:03:11,120 --> 00:03:16,099
basically so easy to use that you can it

00:03:14,419 --> 00:03:21,230
begs you basically to publish something

00:03:16,099 --> 00:03:24,139
so if we speak about the quality for

00:03:21,230 --> 00:03:26,510
JavaScript we have a bunch of tools we

00:03:24,139 --> 00:03:29,419
have linters we have typing's tests and

00:03:26,510 --> 00:03:31,879
I even consider runtime errors to be a

00:03:29,419 --> 00:03:33,919
quality tool because if you handle them

00:03:31,879 --> 00:03:35,840
properly you can make sure that your

00:03:33,919 --> 00:03:37,989
interface doesn't break and you'll get a

00:03:35,840 --> 00:03:41,689
notification when something goes wrong

00:03:37,989 --> 00:03:45,109
so what do we have for CSS which is part

00:03:41,689 --> 00:03:47,509
of every front-end package for a lot of

00:03:45,109 --> 00:03:50,449
fundin packages this is an famous

00:03:47,509 --> 00:03:52,879
bootstrap CSS library which says just

00:03:50,449 --> 00:03:54,859
copy/paste the sell link into your

00:03:52,879 --> 00:03:57,620
head before other style sheets to load

00:03:54,859 --> 00:04:01,599
our senses and that's it you're done

00:03:57,620 --> 00:04:04,400
right sounds nice but unfortunately

00:04:01,599 --> 00:04:07,430
there are some issues issues like name

00:04:04,400 --> 00:04:09,349
spacing and specificity and now they

00:04:07,430 --> 00:04:12,319
have to do this at scale of NPM which

00:04:09,349 --> 00:04:14,540
means we want packages which can be used

00:04:12,319 --> 00:04:19,570
all together and don't conflict on break

00:04:14,540 --> 00:04:22,669
each other so don't worry I have a new

00:04:19,570 --> 00:04:26,300
methodology for you it's called PAC

00:04:22,669 --> 00:04:29,690
package block element modifier so now

00:04:26,300 --> 00:04:33,259
it's just like BAM but it's for NPM you

00:04:29,690 --> 00:04:36,510
know you can prefix every single class

00:04:33,259 --> 00:04:42,540
every single modifier with these and you

00:04:36,510 --> 00:04:45,030
right well I don't like that and I don't

00:04:42,540 --> 00:04:48,870
want to do that and I think ultimately

00:04:45,030 --> 00:04:53,040
it's not maintainable so we have to do

00:04:48,870 --> 00:04:56,450
something better and when I think of CSS

00:04:53,040 --> 00:05:00,210
and yes I think of constraint automation

00:04:56,450 --> 00:05:04,280
because if you use a powerful language

00:05:00,210 --> 00:05:08,010
as JavaScript you have the power to

00:05:04,280 --> 00:05:12,750
restrict the usage of CSS in a way that

00:05:08,010 --> 00:05:14,910
doesn't break other people's code also

00:05:12,750 --> 00:05:17,040
there is another approach which is

00:05:14,910 --> 00:05:18,960
called shadow Dom I don't go into detail

00:05:17,040 --> 00:05:22,680
right now but you're familiar with it

00:05:18,960 --> 00:05:26,250
it could solve most of CSS issues we

00:05:22,680 --> 00:05:30,420
have right now but it didn't because

00:05:26,250 --> 00:05:33,000
first of all it's not really second it's

00:05:30,420 --> 00:05:35,880
not well supported and I adapt it's fast

00:05:33,000 --> 00:05:37,950
and it will not have any performance

00:05:35,880 --> 00:05:40,380
issues in the future because if you use

00:05:37,950 --> 00:05:42,180
shaded on in order to encapsulate every

00:05:40,380 --> 00:05:43,890
component like every button you will

00:05:42,180 --> 00:05:49,620
have hundreds and hundreds of them on

00:05:43,890 --> 00:05:53,400
one document so my take on this is

00:05:49,620 --> 00:05:57,330
always bet on JavaScript or any other

00:05:53,400 --> 00:06:01,440
language which will replace at some four

00:05:57,330 --> 00:06:04,170
in JavaScript because it it is more

00:06:01,440 --> 00:06:06,840
powerful language than CSS and it allows

00:06:04,170 --> 00:06:11,520
you to avoid or fix problems we have

00:06:06,840 --> 00:06:13,400
right now or in the future my next topic

00:06:11,520 --> 00:06:17,070
is theming

00:06:13,400 --> 00:06:18,990
what is the theme anyways I couldn't

00:06:17,070 --> 00:06:21,680
find again any proper definitions or

00:06:18,990 --> 00:06:24,390
else my own theme is a configuration

00:06:21,680 --> 00:06:28,080
that defines a look and feel of an

00:06:24,390 --> 00:06:31,470
application let's have a look an example

00:06:28,080 --> 00:06:34,200
on an example here's material library

00:06:31,470 --> 00:06:37,590
for react which implements Google's

00:06:34,200 --> 00:06:40,920
material design and this one is the most

00:06:37,590 --> 00:06:43,050
popular one in the ecosystem and here

00:06:40,920 --> 00:06:45,260
how a theme looks like in this library

00:06:43,050 --> 00:06:48,330
it's basically an object which contains

00:06:45,260 --> 00:06:50,780
colors typography arrows transitions

00:06:48,330 --> 00:06:54,960
space in break points and so on

00:06:50,780 --> 00:06:57,020
lots of things if you don't want to use

00:06:54,960 --> 00:07:03,080
something like that we won't just

00:06:57,020 --> 00:07:05,970
low-level vaniville CSS what would we do

00:07:03,080 --> 00:07:10,110
one one of the most popular approaches

00:07:05,970 --> 00:07:11,940
is to use built-in theme as I call it so

00:07:10,110 --> 00:07:14,490
basically you have this configuration

00:07:11,940 --> 00:07:16,820
but somewhere before you do the build

00:07:14,490 --> 00:07:19,730
and when you do the build the theme is

00:07:16,820 --> 00:07:23,750
inside of the CSS you have produced and

00:07:19,730 --> 00:07:27,900
so you basically load already built in

00:07:23,750 --> 00:07:30,120
CS teeming with visual senses so the

00:07:27,900 --> 00:07:32,730
problem that is first of all if you have

00:07:30,120 --> 00:07:35,850
many themes we have to redownload a CSS

00:07:32,730 --> 00:07:40,500
with all of it and the second one the

00:07:35,850 --> 00:07:42,380
bigger one redesign becomes complex if

00:07:40,500 --> 00:07:45,390
you have remove just multi team set up

00:07:42,380 --> 00:07:48,470
imagine if you have a product where many

00:07:45,390 --> 00:07:50,730
teams are working on the same product so

00:07:48,470 --> 00:07:54,090
every team is responsible so for some

00:07:50,730 --> 00:07:56,340
page or some component and now you do

00:07:54,090 --> 00:07:58,580
the redesign you have to change

00:07:56,340 --> 00:08:02,010
something in your theme ask every team

00:07:58,580 --> 00:08:04,950
to adapt accordingly to create the

00:08:02,010 --> 00:08:06,450
builds and you know to coordinate all

00:08:04,950 --> 00:08:09,960
the support and at some point you

00:08:06,450 --> 00:08:11,490
finally can build your final bundle and

00:08:09,960 --> 00:08:13,460
release it it's a lot of coordination

00:08:11,490 --> 00:08:16,410
work

00:08:13,460 --> 00:08:20,250
another approach to theming is to use

00:08:16,410 --> 00:08:23,610
CSS variables or custom properties and I

00:08:20,250 --> 00:08:26,280
quote CSS variables are subject to to

00:08:23,610 --> 00:08:28,320
the Cascade and inherit their value from

00:08:26,280 --> 00:08:30,210
their parent which essentially means

00:08:28,320 --> 00:08:33,659
they have all the same problems we have

00:08:30,210 --> 00:08:36,450
with regular CSS rules and additionally

00:08:33,659 --> 00:08:39,089
we have to make sure that custom

00:08:36,450 --> 00:08:41,490
properties don't collide so we have to

00:08:39,089 --> 00:08:44,550
ensure uniqueness which we still need a

00:08:41,490 --> 00:08:46,350
bill to or a tool at runtime which makes

00:08:44,550 --> 00:08:51,810
sure that those names of those

00:08:46,350 --> 00:08:54,870
properties are unique so we don't get

00:08:51,810 --> 00:08:57,570
collisions and the last problem which is

00:08:54,870 --> 00:08:59,790
the biggest one is it is not well

00:08:57,570 --> 00:09:02,339
supported there is no support in I 11

00:08:59,790 --> 00:09:05,210
and below and so for most production

00:09:02,339 --> 00:09:08,280
applications is no good

00:09:05,210 --> 00:09:13,800
when I think think of theming in their

00:09:08,280 --> 00:09:17,220
react I think that CSS variables are a

00:09:13,800 --> 00:09:19,110
lock like react reacts context and it's

00:09:17,220 --> 00:09:20,880
not just react many other libraries and

00:09:19,110 --> 00:09:24,960
frameworks have also a notion of this

00:09:20,880 --> 00:09:28,140
context subject so why I think it is

00:09:24,960 --> 00:09:30,180
similar to CSS variables let's let's

00:09:28,140 --> 00:09:32,670
take an example we create a theme this

00:09:30,180 --> 00:09:34,050
one is using material UI our API to

00:09:32,670 --> 00:09:36,320
create the team we just defined some

00:09:34,050 --> 00:09:41,460
colors nothing fancy

00:09:36,320 --> 00:09:44,250
now let's use that theme the way you do

00:09:41,460 --> 00:09:47,490
it in react with this library is you use

00:09:44,250 --> 00:09:49,710
a provider which accepts a theme object

00:09:47,490 --> 00:09:52,230
we just created and then we wrap them

00:09:49,710 --> 00:09:56,940
entire application into this provider so

00:09:52,230 --> 00:10:00,810
all the inner components like buttons on

00:09:56,940 --> 00:10:04,800
this example will have an access to the

00:10:00,810 --> 00:10:06,480
theme using the context which means that

00:10:04,800 --> 00:10:09,180
we can change the theme anytime at

00:10:06,480 --> 00:10:12,870
runtime and everything inside adapts

00:10:09,180 --> 00:10:15,420
accordingly another interesting thing

00:10:12,870 --> 00:10:17,280
about it is that you can nest providers

00:10:15,420 --> 00:10:19,500
which means that you can use another

00:10:17,280 --> 00:10:22,680
provider inside of this provider and use

00:10:19,500 --> 00:10:26,520
a second theme or a different theme in

00:10:22,680 --> 00:10:28,230
order to style part of the page in a

00:10:26,520 --> 00:10:30,150
different way so exactly the same

00:10:28,230 --> 00:10:31,890
component will look differently in a

00:10:30,150 --> 00:10:37,440
different part of the page you can throw

00:10:31,890 --> 00:10:42,360
in a component and it just adapts okay

00:10:37,440 --> 00:10:44,339
next topic is data-driven styling and I

00:10:42,360 --> 00:10:48,480
know of two kinds of data-driven

00:10:44,339 --> 00:10:50,730
stylings first one is state-based which

00:10:48,480 --> 00:10:52,740
means basically anything that defines

00:10:50,730 --> 00:10:54,330
the state of your application can

00:10:52,740 --> 00:10:56,250
influence the appearance of the

00:10:54,330 --> 00:10:59,600
application could be user settings could

00:10:56,250 --> 00:11:02,640
be whether your mood or whatever else so

00:10:59,600 --> 00:11:06,110
anything that can define how your

00:11:02,640 --> 00:11:15,850
application looks and feels and another

00:11:06,110 --> 00:11:17,560
kind of data-driven styling is

00:11:15,850 --> 00:11:20,080
streaming animations and this is the

00:11:17,560 --> 00:11:22,660
most interesting one to me because it's

00:11:20,080 --> 00:11:26,070
really hard to do it on the web if you

00:11:22,660 --> 00:11:31,330
look at this simple switch button

00:11:26,070 --> 00:11:34,600
from iris it feels very natural to use

00:11:31,330 --> 00:11:36,670
and the reason is it's not a simple

00:11:34,600 --> 00:11:39,160
animation it's not something static you

00:11:36,670 --> 00:11:41,260
can produce with simple key phrase or

00:11:39,160 --> 00:11:42,970
something because the moment you swipe

00:11:41,260 --> 00:11:45,160
this button you apply a certain

00:11:42,970 --> 00:11:49,240
acceleration to the button and then

00:11:45,160 --> 00:11:52,060
physics engine takes this and simulates

00:11:49,240 --> 00:11:53,710
gravity on this button so and it moves

00:11:52,060 --> 00:11:56,410
in a way that feels natural to your eye

00:11:53,710 --> 00:11:59,920
because we we are used to see things

00:11:56,410 --> 00:12:04,270
which act and move naturally this is why

00:11:59,920 --> 00:12:07,300
mobile interface is way better than the

00:12:04,270 --> 00:12:09,820
web they are more natural and so if you

00:12:07,300 --> 00:12:12,730
want to do these on the web you

00:12:09,820 --> 00:12:14,980
obviously cannot use can really use

00:12:12,730 --> 00:12:16,570
transitions and keyframes because if you

00:12:14,980 --> 00:12:18,070
use them you have to know in advance

00:12:16,570 --> 00:12:21,190
when the animation starts and when it

00:12:18,070 --> 00:12:23,440
ends and how it look it runs and these

00:12:21,190 --> 00:12:25,660
are informations which are provided at

00:12:23,440 --> 00:12:27,630
the moment animation happens when user

00:12:25,660 --> 00:12:30,220
or swipe so does something else

00:12:27,630 --> 00:12:33,400
so on the web or to implement those

00:12:30,220 --> 00:12:36,100
things you usually would use inline

00:12:33,400 --> 00:12:38,080
styles and in react ignorant inline

00:12:36,100 --> 00:12:42,040
style services have some overhead

00:12:38,080 --> 00:12:45,130
because reactive has components and

00:12:42,040 --> 00:12:47,530
those components have encapsulation and

00:12:45,130 --> 00:12:49,270
so to apply styles or they have to do

00:12:47,530 --> 00:12:51,430
reconciliation the components and then

00:12:49,270 --> 00:12:53,830
they have to apply the styles and the

00:12:51,430 --> 00:12:57,220
styles application also because it is

00:12:53,830 --> 00:12:58,780
declarative it is slower because you

00:12:57,220 --> 00:13:00,850
have to loop all the objects see what

00:12:58,780 --> 00:13:02,770
has changed what has been removed and

00:13:00,850 --> 00:13:07,450
removed it remove it from the Dom and

00:13:02,770 --> 00:13:10,030
apply the new the new changes if you

00:13:07,450 --> 00:13:11,920
want extreme performance and you want

00:13:10,030 --> 00:13:13,840
extreme performance because you are

00:13:11,920 --> 00:13:16,030
trying to if you're trying to achieve

00:13:13,840 --> 00:13:18,490
these natural animations there are

00:13:16,030 --> 00:13:20,260
materialistic animations you need the

00:13:18,490 --> 00:13:23,290
maximum of the performance you cannot

00:13:20,260 --> 00:13:25,480
afford any overhead and so as we are

00:13:23,290 --> 00:13:28,090
running as we have to control with

00:13:25,480 --> 00:13:30,760
JavaScript every frame of this animation

00:13:28,090 --> 00:13:33,490
at 60fps and we have just one threat

00:13:30,760 --> 00:13:35,590
where something else also can happen we

00:13:33,490 --> 00:13:41,860
need all performance optimizations we

00:13:35,590 --> 00:13:44,140
can get and so I think one feature many

00:13:41,860 --> 00:13:47,700
people don't know about is CSS object

00:13:44,140 --> 00:13:52,240
model and the thing is it's actually

00:13:47,700 --> 00:13:55,140
very fast and this is an example of how

00:13:52,240 --> 00:13:58,750
the API of CSS object model looks like

00:13:55,140 --> 00:14:02,890
so we create an element style element

00:13:58,750 --> 00:14:05,620
you put it to the head and now the fancy

00:14:02,890 --> 00:14:07,110
stuff we just insert a CSS rule into

00:14:05,620 --> 00:14:10,510
that element so we basically

00:14:07,110 --> 00:14:14,560
programmatically generate CSS and this

00:14:10,510 --> 00:14:16,540
is how how easy it is and if you want to

00:14:14,560 --> 00:14:19,120
update the CSS rule we can just access

00:14:16,540 --> 00:14:20,470
it and access the style object same

00:14:19,120 --> 00:14:25,540
style object we have from the inline

00:14:20,470 --> 00:14:28,060
Styles and just change the property now

00:14:25,540 --> 00:14:30,730
this code was quite low level you don't

00:14:28,060 --> 00:14:34,150
want to do that a new product right

00:14:30,730 --> 00:14:36,880
so in JSS we have a better interface we

00:14:34,150 --> 00:14:40,240
have function values and function values

00:14:36,880 --> 00:14:43,120
are basically values which are defined

00:14:40,240 --> 00:14:47,440
as a function and when you call update

00:14:43,120 --> 00:14:49,810
in GSS you pass your data or probes when

00:14:47,440 --> 00:14:52,360
it's react and so this function takes it

00:14:49,810 --> 00:14:54,760
and reacts accordingly and returns an

00:14:52,360 --> 00:14:58,960
actual CSS value which adjusts to that

00:14:54,760 --> 00:15:02,560
then takes and applies to CSS RM room so

00:14:58,960 --> 00:15:06,250
this is a very direct approach it has

00:15:02,560 --> 00:15:08,860
very low overhead and additionally you

00:15:06,250 --> 00:15:11,500
can optimize that by simply using should

00:15:08,860 --> 00:15:15,340
component update who can return false so

00:15:11,500 --> 00:15:17,830
there is no react involved at all in in

00:15:15,340 --> 00:15:22,630
the entire update cycle for for these

00:15:17,830 --> 00:15:24,000
Styles here isn't in demo I hope it

00:15:22,630 --> 00:15:26,590
works

00:15:24,000 --> 00:15:29,170
right now we are rendering this object

00:15:26,590 --> 00:15:34,330
with just yourself now we have 10 object

00:15:29,170 --> 00:15:36,310
no 1470 let's I don't know if you can

00:15:34,330 --> 00:15:38,980
see the FPS meter but right now at 60

00:15:36,310 --> 00:15:41,620
fps let's render as many objects so we

00:15:38,980 --> 00:15:46,900
can see the drop dropping

00:15:41,620 --> 00:15:48,730
frame now I'm animating almost 300

00:15:46,900 --> 00:15:52,510
objects and still not quite dropping

00:15:48,730 --> 00:15:54,910
well now it dropped to 50 fps right now

00:15:52,510 --> 00:16:01,020
exactly the same using react in line

00:15:54,910 --> 00:16:04,540
styles frame rate rate dropped like to

00:16:01,020 --> 00:16:10,480
11:10 it's two or even three times

00:16:04,540 --> 00:16:13,180
faster now if you want to build some

00:16:10,480 --> 00:16:14,920
really complex animations something very

00:16:13,180 --> 00:16:17,680
very complex where many streams are

00:16:14,920 --> 00:16:20,670
involved many data streams observables

00:16:17,680 --> 00:16:24,160
is the right interface to do so and

00:16:20,670 --> 00:16:26,050
observables are hopefully getting into

00:16:24,160 --> 00:16:29,050
our standards someday so there is a

00:16:26,050 --> 00:16:31,750
proposal on the github which is under

00:16:29,050 --> 00:16:33,250
this link so please go ahead and take a

00:16:31,750 --> 00:16:36,100
look at it and stir it because

00:16:33,250 --> 00:16:40,839
observables at its core are a beautiful

00:16:36,100 --> 00:16:44,200
concept here is an example of how GSS in

00:16:40,839 --> 00:16:46,150
the world 9 is using observables so it's

00:16:44,200 --> 00:16:48,940
basically the same like function values

00:16:46,150 --> 00:16:51,339
instead you you're providing an

00:16:48,940 --> 00:16:53,890
observable I've added just a very

00:16:51,339 --> 00:16:57,940
trivial example so you can see that it's

00:16:53,890 --> 00:17:00,700
basically an object which can receive a

00:16:57,940 --> 00:17:02,680
value so I'm setting right now just the

00:17:00,700 --> 00:17:04,750
next value right away in a realistic

00:17:02,680 --> 00:17:07,959
case you would use an elaborate like

00:17:04,750 --> 00:17:09,579
Eric's chest or something to you know to

00:17:07,959 --> 00:17:12,610
manipulate the streams and then to

00:17:09,579 --> 00:17:14,890
return the right value at the end and

00:17:12,610 --> 00:17:18,270
the beauty of it is also especially

00:17:14,890 --> 00:17:20,650
because it is so simple and at its core

00:17:18,270 --> 00:17:24,360
the only thing I had to do in order to

00:17:20,650 --> 00:17:27,970
support observables in GSS was first to

00:17:24,360 --> 00:17:31,179
identify an observable object which is

00:17:27,970 --> 00:17:34,390
easily done this tiny package and then

00:17:31,179 --> 00:17:37,120
just to subscribe to the value and once

00:17:34,390 --> 00:17:40,630
I have an update and I see the value has

00:17:37,120 --> 00:17:44,500
changed I'd update the CSS rule with

00:17:40,630 --> 00:17:45,730
this call so that's it ahead that's all

00:17:44,500 --> 00:17:49,510
I had to do in order to support

00:17:45,730 --> 00:17:51,490
observables in jss and the core of

00:17:49,510 --> 00:17:53,830
absorbance which TC certain ion is

00:17:51,490 --> 00:17:55,000
trying to standardize is compatible with

00:17:53,830 --> 00:17:57,850
most

00:17:55,000 --> 00:17:59,830
active libraries like Eric's yes bacon

00:17:57,850 --> 00:18:04,620
kaffir so you can get the entire

00:17:59,830 --> 00:18:06,490
breakfast and another thing is

00:18:04,620 --> 00:18:09,460
observables are push-based

00:18:06,490 --> 00:18:12,940
which means they they are a perfect fit

00:18:09,460 --> 00:18:16,150
for handling events like mousemove which

00:18:12,940 --> 00:18:18,130
are very frequent or data stream from a

00:18:16,150 --> 00:18:19,810
physics engine so basically it's the

00:18:18,130 --> 00:18:22,030
right interface to coordinate the

00:18:19,810 --> 00:18:26,010
streams of all the data sources you

00:18:22,030 --> 00:18:28,840
might want to use and also think are

00:18:26,010 --> 00:18:32,050
observables and CSS object model are a

00:18:28,840 --> 00:18:34,450
perfect fit because they are both

00:18:32,050 --> 00:18:37,720
decoupled observables is decoupled from

00:18:34,450 --> 00:18:40,150
the data source and CSS RM is decoupled

00:18:37,720 --> 00:18:41,830
from the Dom they are both lazy

00:18:40,150 --> 00:18:45,670
observables don't do anything until

00:18:41,830 --> 00:18:48,550
actual events start happening and they

00:18:45,670 --> 00:18:51,220
are both extremely reusable for instance

00:18:48,550 --> 00:18:54,520
you the entire animation is built on top

00:18:51,220 --> 00:18:56,260
of CSS rule and the only connection

00:18:54,520 --> 00:19:00,190
between the CSS rule and the Dom node is

00:18:56,260 --> 00:19:03,160
the hopefully generated class name which

00:19:00,190 --> 00:19:05,380
can be passed around you can you can

00:19:03,160 --> 00:19:07,060
built a dome before or later you can

00:19:05,380 --> 00:19:09,040
pass the class name at any point of time

00:19:07,060 --> 00:19:11,710
you can reuse the same class name on

00:19:09,040 --> 00:19:13,450
many elements and the styles apply there

00:19:11,710 --> 00:19:20,320
is a lot of things you can do because of

00:19:13,450 --> 00:19:23,680
this strong decoupling my last topic is

00:19:20,320 --> 00:19:29,500
in the future the future of CSS and J's

00:19:23,680 --> 00:19:31,480
and so it's my quad the biggest issue at

00:19:29,500 --> 00:19:34,810
scale we currently have with all CSS and

00:19:31,480 --> 00:19:36,190
J's implementations is they are not

00:19:34,810 --> 00:19:39,930
shareable without the runtime which

00:19:36,190 --> 00:19:43,300
means I'll explain later

00:19:39,930 --> 00:19:47,520
so the solution we currently work on is

00:19:43,300 --> 00:19:53,290
called is TF which is interoperable

00:19:47,520 --> 00:19:58,330
style transfer format and the people

00:19:53,290 --> 00:20:02,820
behind it I will here so Glenn Martin

00:19:58,330 --> 00:20:05,920
from styled components or Deb Adkins who

00:20:02,820 --> 00:20:08,600
actually works on real specifications at

00:20:05,920 --> 00:20:10,820
CSS he wrote most of the specifications

00:20:08,600 --> 00:20:11,840
in helped a lot with the ICF

00:20:10,820 --> 00:20:14,900
specification as well

00:20:11,840 --> 00:20:17,480
Sultan wrote them the most performant

00:20:14,900 --> 00:20:20,720
CSS parser ever and the smallest one as

00:20:17,480 --> 00:20:23,660
well and feel especially few he who is

00:20:20,720 --> 00:20:24,910
also a core at L components he is

00:20:23,660 --> 00:20:28,610
building right now

00:20:24,910 --> 00:20:34,370
first is TF prototype and like investing

00:20:28,610 --> 00:20:34,960
a lot of time huge props to him so what

00:20:34,370 --> 00:20:38,360
is it

00:20:34,960 --> 00:20:40,730
first interoperable the idea between

00:20:38,360 --> 00:20:43,460
this behind this word is that you can

00:20:40,730 --> 00:20:47,000
use any library citizen J's library or

00:20:43,460 --> 00:20:49,760
even regular CSS to publish CSS to NPM

00:20:47,000 --> 00:20:51,920
in a certain format and then you can

00:20:49,760 --> 00:20:53,690
consume with any other library which

00:20:51,920 --> 00:20:56,120
means that components which has been

00:20:53,690 --> 00:20:58,850
published with style components can now

00:20:56,120 --> 00:21:02,480
be consumed or using GSS so you don't

00:20:58,850 --> 00:21:03,980
have to bundle every runtime for every

00:21:02,480 --> 00:21:06,020
component you might find because we have

00:21:03,980 --> 00:21:07,700
a lot of sense in JS libraries and if

00:21:06,020 --> 00:21:09,860
you install components from NPM you will

00:21:07,700 --> 00:21:12,520
find that you know you have to bundle a

00:21:09,860 --> 00:21:15,850
lot of libraries and this doesn't scale

00:21:12,520 --> 00:21:18,770
second thing is it supports all CSS

00:21:15,850 --> 00:21:22,480
features and also it supports all CSS

00:21:18,770 --> 00:21:24,830
and J's features because seasoned GS is

00:21:22,480 --> 00:21:26,510
has more features than success it

00:21:24,830 --> 00:21:28,460
supports everything that CSS supports

00:21:26,510 --> 00:21:33,250
and also on top of that it has things

00:21:28,460 --> 00:21:33,250
like function values or observables

00:21:33,520 --> 00:21:41,930
transfer transfer stands for compact and

00:21:36,890 --> 00:21:44,720
fast format because we can download it

00:21:41,930 --> 00:21:46,610
from NPM it has to be compact but that's

00:21:44,720 --> 00:21:48,860
not such a big issue but we also want to

00:21:46,610 --> 00:21:51,380
use this at runtime which means we have

00:21:48,860 --> 00:21:53,750
to bundle is in and load out in the

00:21:51,380 --> 00:21:59,060
browser so we can dynamically generate

00:21:53,750 --> 00:22:02,540
CSS out of it so the best thing about it

00:21:59,060 --> 00:22:05,180
is actually it's built for parcels not

00:22:02,540 --> 00:22:09,110
for humans CSS is built for humans that

00:22:05,180 --> 00:22:12,470
it has a lot of complex things parser

00:22:09,110 --> 00:22:15,890
has to consider in order to properly par

00:22:12,470 --> 00:22:18,970
CSS and it's really hard

00:22:15,890 --> 00:22:21,860
so this one is created for parcels it's

00:22:18,970 --> 00:22:24,740
optimized to be fast for parsing

00:22:21,860 --> 00:22:26,990
and it's basically so easy to implement

00:22:24,740 --> 00:22:30,790
a parser for it it's no brainer it's

00:22:26,990 --> 00:22:33,860
like ten lines of code here's an example

00:22:30,790 --> 00:22:37,220
on the top is just a regular CSS and

00:22:33,860 --> 00:22:39,380
down there is a step which looks a lot

00:22:37,220 --> 00:22:42,500
more at the first glance but those

00:22:39,380 --> 00:22:45,530
constants are just constant therefore to

00:22:42,500 --> 00:22:48,140
show actually those concerns will be

00:22:45,530 --> 00:22:50,000
just as some just a number and those

00:22:48,140 --> 00:22:52,400
additional areas could be actually

00:22:50,000 --> 00:22:57,380
optimized so it's just one array with a

00:22:52,400 --> 00:23:00,740
number of values at the end of the day

00:22:57,380 --> 00:23:05,660
all CSS NGS is about building more

00:23:00,740 --> 00:23:10,520
robust applications faster it's really

00:23:05,660 --> 00:23:14,990
all it is about and I have a coding

00:23:10,520 --> 00:23:18,309
challenge for you so I love this cat he

00:23:14,990 --> 00:23:21,860
was created by David Khurshid and

00:23:18,309 --> 00:23:24,080
reported this get to GS s as it is with

00:23:21,860 --> 00:23:24,650
all their keyframe animations and so on

00:23:24,080 --> 00:23:28,040
and so on

00:23:24,650 --> 00:23:31,220
so now if you go to CSS and J's dot

00:23:28,040 --> 00:23:34,640
works slash swinging head go ahead find

00:23:31,220 --> 00:23:38,059
it for kit and use observables in order

00:23:34,640 --> 00:23:40,040
to control this cat go fancy like create

00:23:38,059 --> 00:23:43,370
some animations like control to the

00:23:40,040 --> 00:23:47,270
mouse or whatever you want and make this

00:23:43,370 --> 00:23:49,610
cap do things any weird things and I

00:23:47,270 --> 00:23:52,549
would love to share that and I will put

00:23:49,610 --> 00:23:57,169
all the best examples on on the

00:23:52,549 --> 00:24:00,070
documentation page Thanks that's it

00:23:57,169 --> 00:24:00,070
thanks for having

00:24:02,120 --> 00:24:13,820
I guess we have time for questions right

00:24:09,800 --> 00:24:21,890
yeah no yeah nice talk I say the nice

00:24:13,820 --> 00:24:25,760
Jesus logo just kidding when it's ice-t

00:24:21,890 --> 00:24:28,940
f will be a thing you think so

00:24:25,760 --> 00:24:31,040
some estimation I can do any estimates

00:24:28,940 --> 00:24:34,610
because it's something we are working on

00:24:31,040 --> 00:24:38,390
and basically right now it's on fuel who

00:24:34,610 --> 00:24:40,460
is implementing entirely from scratch a

00:24:38,390 --> 00:24:42,860
CSS parser because of the oil

00:24:40,460 --> 00:24:46,160
requirements because we could not use

00:24:42,860 --> 00:24:48,470
any existing one so he has quite a lot

00:24:46,160 --> 00:24:52,780
of work to do so I hope his employee

00:24:48,470 --> 00:24:56,090
will give him a bit time to do that so

00:24:52,780 --> 00:24:57,560
specification is like to 90% finished I

00:24:56,090 --> 00:25:00,260
guess there will be some edge cases but

00:24:57,560 --> 00:25:04,100
it's mostly finished it's on github so

00:25:00,260 --> 00:25:06,230
we are right now just waiting for Phil

00:25:04,100 --> 00:25:08,870
to finish the implementation it could

00:25:06,230 --> 00:25:12,640
take a couple of months or something but

00:25:08,870 --> 00:25:12,640
it will be there we're going there

00:25:18,460 --> 00:25:30,880
I have just one question is this mainly

00:25:24,520 --> 00:25:33,850
targeted for the web well actually no I

00:25:30,880 --> 00:25:38,760
mean it's universal okay look can you

00:25:33,850 --> 00:25:41,740
maybe caliber work a little bit more how

00:25:38,760 --> 00:25:44,590
how could it work with reg native or

00:25:41,740 --> 00:25:46,660
something we have right now no specific

00:25:44,590 --> 00:25:51,190
plans to you know integrate it into

00:25:46,660 --> 00:25:54,660
react native but actually if like the

00:25:51,190 --> 00:25:57,700
way we we think it should work is that

00:25:54,660 --> 00:26:00,850
every season JS library supports this

00:25:57,700 --> 00:26:03,340
format natively which means that if

00:26:00,850 --> 00:26:05,170
style components already supports react

00:26:03,340 --> 00:26:06,900
native and has all the components you

00:26:05,170 --> 00:26:10,810
can use it will be automatically

00:26:06,900 --> 00:26:13,110
available on react native and that's it

00:26:10,810 --> 00:26:15,880
because it's a very low level format

00:26:13,110 --> 00:26:18,550
it's just a format for transportation

00:26:15,880 --> 00:26:21,910
transportation and parsing in an

00:26:18,550 --> 00:26:23,500
efficient way so it will be available

00:26:21,910 --> 00:26:26,880
everywhere at some point you don't even

00:26:23,500 --> 00:26:26,880
know that you use it but you use it

00:26:40,450 --> 00:26:46,370
there were a lot of questions on

00:26:42,770 --> 00:26:51,500
Croatians before about using external

00:26:46,370 --> 00:26:53,840
libraries and the problems is using

00:26:51,500 --> 00:26:57,730
external libraries and you told again

00:26:53,840 --> 00:27:00,740
the standard is is aimed to fix that but

00:26:57,730 --> 00:27:03,860
actually what I care when I try to use

00:27:00,740 --> 00:27:09,440
external library and use some components

00:27:03,860 --> 00:27:13,220
from that is its API so I have to be

00:27:09,440 --> 00:27:18,790
sure that components that are provided I

00:27:13,220 --> 00:27:22,910
can accept a class names and if they not

00:27:18,790 --> 00:27:27,950
why I should care the class names and

00:27:22,910 --> 00:27:34,850
pass them as object so imagine if we if

00:27:27,950 --> 00:27:39,350
we would have some kind of typing for

00:27:34,850 --> 00:27:44,540
the component class names so we use

00:27:39,350 --> 00:27:47,630
component and we can just use class

00:27:44,540 --> 00:27:51,230
names as strings right inside when I use

00:27:47,630 --> 00:27:55,730
when you use the component itself and it

00:27:51,230 --> 00:27:58,750
could be also support it could also

00:27:55,730 --> 00:28:02,660
support for example auto completion and

00:27:58,750 --> 00:28:08,240
it supposed API could be could be

00:28:02,660 --> 00:28:11,510
supported and it could be cross any CSS

00:28:08,240 --> 00:28:14,390
NGS and whatever component related

00:28:11,510 --> 00:28:17,060
applications if I understand right so

00:28:14,390 --> 00:28:21,020
you are asking for an interface that

00:28:17,060 --> 00:28:25,640
unifies from the user perspective every

00:28:21,020 --> 00:28:29,240
senses ingest implementation right we

00:28:25,640 --> 00:28:31,000
cannot do right now because the the

00:28:29,240 --> 00:28:34,310
reason we have so many citizens yes

00:28:31,000 --> 00:28:36,470
implementations is that they provide

00:28:34,310 --> 00:28:38,060
different interfaces because they look

00:28:36,470 --> 00:28:40,210
at problems in a different from

00:28:38,060 --> 00:28:42,290
different angles and try to you know

00:28:40,210 --> 00:28:45,290
interface with the user in a different

00:28:42,290 --> 00:28:48,830
way so if we unify all of them we don't

00:28:45,290 --> 00:28:51,020
need all of them we don't need all of

00:28:48,830 --> 00:28:52,150
them we don't need all of them but there

00:28:51,020 --> 00:28:56,620
are

00:28:52,150 --> 00:28:59,350
a few approaches so and they are all

00:28:56,620 --> 00:29:01,990
interesting for different use cases and

00:28:59,350 --> 00:29:04,200
so right now we are just it's a process

00:29:01,990 --> 00:29:09,160
where we figure out which approaches are

00:29:04,200 --> 00:29:11,110
most popular and fit for most use cases

00:29:09,160 --> 00:29:13,060
and so at some point there will be two

00:29:11,110 --> 00:29:16,750
or three libraries which provide the

00:29:13,060 --> 00:29:18,520
best takes developer experience and we

00:29:16,750 --> 00:29:23,320
have we will have like more or less

00:29:18,520 --> 00:29:26,500
popular interfaces everyone can use but

00:29:23,320 --> 00:29:29,800
I don't think we can ever standardized

00:29:26,500 --> 00:29:35,500
or you unify all the interfaces too many

00:29:29,800 --> 00:29:40,720
too many possibilities is that answering

00:29:35,500 --> 00:29:43,420
the question right I I can the problem

00:29:40,720 --> 00:29:46,540
is but what I see I'm taking the

00:29:43,420 --> 00:29:49,750
component I want to change something in

00:29:46,540 --> 00:29:53,820
in its styling in my context yeah how I

00:29:49,750 --> 00:29:58,300
should do that in some Universal way

00:29:53,820 --> 00:30:02,170
well there are some popular ways which

00:29:58,300 --> 00:30:04,240
is always accept a class name or if you

00:30:02,170 --> 00:30:07,390
if you want to allow user to style inner

00:30:04,240 --> 00:30:09,700
components except a classes hash with

00:30:07,390 --> 00:30:13,300
all the class names for instance this is

00:30:09,700 --> 00:30:16,240
one another is always provide some

00:30:13,300 --> 00:30:19,120
theming API or overrides API which

00:30:16,240 --> 00:30:20,850
allows the user to style everything take

00:30:19,120 --> 00:30:24,370
a look at the overrides and timming

00:30:20,850 --> 00:30:27,160
module UI library is taking I think it's

00:30:24,370 --> 00:30:30,220
one of the most flexible why you is

00:30:27,160 --> 00:30:32,530
because just to make a point we are

00:30:30,220 --> 00:30:36,190
using this library inside inside of our

00:30:32,530 --> 00:30:38,530
shed which is not really it doesn't

00:30:36,190 --> 00:30:40,960
which doesn't look really materialistic

00:30:38,530 --> 00:30:43,630
it's like a different kind of look and

00:30:40,960 --> 00:30:45,760
feel but it uses material UI which means

00:30:43,630 --> 00:30:48,180
I could completely customize and change

00:30:45,760 --> 00:30:52,150
everything it's basically a task flow

00:30:48,180 --> 00:30:54,250
for the library to be able to be

00:30:52,150 --> 00:30:57,510
customizable not something we can

00:30:54,250 --> 00:31:01,020
standardize upon not right now at least

00:30:57,510 --> 00:31:01,020
maybe in the future

00:31:01,260 --> 00:31:04,490
thanks for question

00:31:09,020 --> 00:31:11,080

YouTube URL: https://www.youtube.com/watch?v=i3TIrcnMIng


