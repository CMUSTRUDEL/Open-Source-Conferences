Title: ReactiveConf 2017 - Igor Minar: Let's Tree-shake it...
Publication date: 2017-11-20
Playlist: ReactiveConf 2017
Description: 
	Main stage talk

https://reactiveconf.com/
25th - 27th October 2017, Bratislava, Slovakia
Captions: 
	00:00:02,040 --> 00:00:08,639
[Music]

00:00:14,610 --> 00:00:19,200
so my name is Igor Minar I'm a software

00:00:17,100 --> 00:00:20,730
engineer at Google in California and I

00:00:19,200 --> 00:00:23,490
lead the engineering team that works on

00:00:20,730 --> 00:00:25,890
angular I came here to share some

00:00:23,490 --> 00:00:27,029
information about things we discovered

00:00:25,890 --> 00:00:29,130
as we were working on making things

00:00:27,029 --> 00:00:31,650
small making things faster specifically

00:00:29,130 --> 00:00:33,120
when it comes to true shaking and dead

00:00:31,650 --> 00:00:34,680
code elimination which are two

00:00:33,120 --> 00:00:37,050
optimization techniques we come and rely

00:00:34,680 --> 00:00:39,510
on but if we if you start talking about

00:00:37,050 --> 00:00:41,220
these techniques we quickly realized

00:00:39,510 --> 00:00:43,350
that nobody really understands the whole

00:00:41,220 --> 00:00:46,170
thing end-to-end and there are lots of

00:00:43,350 --> 00:00:49,470
surprises once you have the big picture

00:00:46,170 --> 00:00:51,089
in your head and you see how complex the

00:00:49,470 --> 00:00:54,809
system is and how easy it is to make

00:00:51,089 --> 00:00:57,500
mistakes so let's dive in everybody says

00:00:54,809 --> 00:00:59,580
that applications should be fast right

00:00:57,500 --> 00:01:04,110
anybody's building some applications

00:00:59,580 --> 00:01:06,060
intentionally hopefully not but let's

00:01:04,110 --> 00:01:09,390
define what fast means and how do we

00:01:06,060 --> 00:01:10,979
measure it the most reliable way to do

00:01:09,390 --> 00:01:14,010
it is to focus on the critical rendering

00:01:10,979 --> 00:01:15,930
path and the time to attend to

00:01:14,010 --> 00:01:18,870
interactive turn to interactive is the

00:01:15,930 --> 00:01:20,910
time it takes for application to render

00:01:18,870 --> 00:01:23,220
some something useful and become

00:01:20,910 --> 00:01:24,990
responsive to user input optimize the

00:01:23,220 --> 00:01:27,060
application renders the most important

00:01:24,990 --> 00:01:29,880
part at the beginning as soon as

00:01:27,060 --> 00:01:31,140
possible and then slowly loads more and

00:01:29,880 --> 00:01:33,030
more functionality makes that available

00:01:31,140 --> 00:01:35,040
to the user an optimized application

00:01:33,030 --> 00:01:37,110
loads everything upfront and then

00:01:35,040 --> 00:01:41,880
provides all the functionality at much

00:01:37,110 --> 00:01:47,340
later point in time to the user so how

00:01:41,880 --> 00:01:48,630
do we achieve fast tree-shaking right at

00:01:47,340 --> 00:01:50,790
least that's what I'm being told because

00:01:48,630 --> 00:01:51,930
everybody when we start discussing this

00:01:50,790 --> 00:01:53,790
everybody's like oh just use tree

00:01:51,930 --> 00:01:55,200
shaking it's gonna be fine okay so let's

00:01:53,790 --> 00:01:57,720
see how it works let's build an

00:01:55,200 --> 00:01:59,550
application and we're gonna build a very

00:01:57,720 --> 00:02:00,900
simple application which is gonna use

00:01:59,550 --> 00:02:03,420
vanilla JavaScript so that we have a

00:02:00,900 --> 00:02:04,590
little few dependencies as possible so

00:02:03,420 --> 00:02:07,860
that we can focus on the things that

00:02:04,590 --> 00:02:10,860
matter I'm gonna bring rxjs anybody

00:02:07,860 --> 00:02:12,269
knows through our chairs here quite a

00:02:10,860 --> 00:02:14,640
few people yeah we want the application

00:02:12,269 --> 00:02:16,830
to be reactive to be fast so our X J's

00:02:14,640 --> 00:02:18,959
comes in and then we bring web pack

00:02:16,830 --> 00:02:21,239
because tree shaking right by peg does

00:02:18,959 --> 00:02:23,600
tree shaking so we need the two shaking

00:02:21,239 --> 00:02:26,520
we put it in and it's gonna be awesome

00:02:23,600 --> 00:02:28,090
before I go any further I'm not trying

00:02:26,520 --> 00:02:30,910
to bash anybody I'm gonna show

00:02:28,090 --> 00:02:32,860
stuff that is not pretty my goal is to

00:02:30,910 --> 00:02:35,680
point out how this stuff works today and

00:02:32,860 --> 00:02:37,629
what we are doing to fix it so if I

00:02:35,680 --> 00:02:39,970
picked any other solution I would find

00:02:37,629 --> 00:02:43,150
problems this is just a combo that I put

00:02:39,970 --> 00:02:47,019
together to demonstrate the problems so

00:02:43,150 --> 00:02:50,099
here it is my application there are no

00:02:47,019 --> 00:02:53,200
applause okay

00:02:50,099 --> 00:02:56,080
much very much sorry so my application

00:02:53,200 --> 00:02:58,690
is is a stark dashboard it just displays

00:02:56,080 --> 00:03:00,310
a few starts get some data from stock

00:02:58,690 --> 00:03:03,190
exchange and displace it it's all fake

00:03:00,310 --> 00:03:04,840
it doesn't really do anything useful but

00:03:03,190 --> 00:03:06,250
it's a good exploration and good

00:03:04,840 --> 00:03:06,989
application to explore how this stuff

00:03:06,250 --> 00:03:09,130
works

00:03:06,989 --> 00:03:10,780
so the architecture of the application

00:03:09,130 --> 00:03:13,120
is super simple I just have few

00:03:10,780 --> 00:03:15,430
JavaScript modules I have the index.js

00:03:13,120 --> 00:03:17,920
file which brings in the view layer that

00:03:15,430 --> 00:03:20,920
I hand coded and the data layer and

00:03:17,920 --> 00:03:22,989
bootstrap the application the view the

00:03:20,920 --> 00:03:24,940
view rendering layer it's just a bunch

00:03:22,989 --> 00:03:27,489
of string concatenation and inner HTML

00:03:24,940 --> 00:03:28,420
don't judge me I was trying to make it

00:03:27,489 --> 00:03:30,760
as small as possible

00:03:28,420 --> 00:03:33,160
and then the data layer we use

00:03:30,760 --> 00:03:35,109
observables to create a stream of data

00:03:33,160 --> 00:03:37,359
that will be fetching from the stock

00:03:35,109 --> 00:03:39,220
exchange the stock exchange it's all in

00:03:37,359 --> 00:03:43,150
memory everything's fake so it's super

00:03:39,220 --> 00:03:45,639
tiny and we're using rxjs to use a few

00:03:43,150 --> 00:03:47,859
operators from rxjs to to do all of this

00:03:45,639 --> 00:03:52,359
to create the stream it's really just a

00:03:47,859 --> 00:03:54,609
fraction of our X J's okay awesome the

00:03:52,359 --> 00:03:56,410
application is really small just 125

00:03:54,609 --> 00:03:59,200
lines of code with white space and

00:03:56,410 --> 00:04:02,200
comments and like 3.7 kilobytes and

00:03:59,200 --> 00:04:04,359
optimized just raw source code super

00:04:02,200 --> 00:04:06,940
tiny it should load in the browser in a

00:04:04,359 --> 00:04:10,419
fraction of a second right because it's

00:04:06,940 --> 00:04:15,190
reactive and tree shakin so let's put it

00:04:10,419 --> 00:04:16,780
on web page test this is slow motion so

00:04:15,190 --> 00:04:18,669
we see in one second there is nothing on

00:04:16,780 --> 00:04:22,270
the screen still we're making connection

00:04:18,669 --> 00:04:24,910
this is on a 3G device low and low end

00:04:22,270 --> 00:04:27,130
device after two seconds we have loading

00:04:24,910 --> 00:04:29,830
because our static HTML arrived and

00:04:27,130 --> 00:04:31,960
displayed loading and in about 3.8

00:04:29,830 --> 00:04:35,440
seconds we have something useful on the

00:04:31,960 --> 00:04:38,710
screen so it really took 3.8 seconds to

00:04:35,440 --> 00:04:41,020
render application application that has

00:04:38,710 --> 00:04:44,260
3.7 kilobytes of source code

00:04:41,020 --> 00:04:46,540
that's really bizarre let's take a look

00:04:44,260 --> 00:04:49,120
at what happened so this is the

00:04:46,540 --> 00:04:50,970
waterfall chart that shows us how the

00:04:49,120 --> 00:04:53,230
time was spent to render this

00:04:50,970 --> 00:04:54,850
application and what we see right away

00:04:53,230 --> 00:04:57,250
is that about half of the time we've

00:04:54,850 --> 00:05:00,310
spent waiting for the network and about

00:04:57,250 --> 00:05:03,040
the other half was spent downloading

00:05:00,310 --> 00:05:06,100
evaluating JavaScript and rendering the

00:05:03,040 --> 00:05:07,780
UI so the first half there is not really

00:05:06,100 --> 00:05:09,610
much we can do about it except for

00:05:07,780 --> 00:05:11,890
servers were using serviceworker which

00:05:09,610 --> 00:05:13,750
is used for useful for return visitors

00:05:11,890 --> 00:05:15,640
but for the initial visitors that even

00:05:13,750 --> 00:05:17,440
need to install a serviceworker this is

00:05:15,640 --> 00:05:19,810
what they will pay this is hosted on

00:05:17,440 --> 00:05:22,450
firebase which is super optimized it has

00:05:19,810 --> 00:05:24,970
like all the tricks HTTP to it's really

00:05:22,450 --> 00:05:27,100
hard to do much better than this so we

00:05:24,970 --> 00:05:29,320
can really only optimize the application

00:05:27,100 --> 00:05:30,160
by focusing on the second half so we see

00:05:29,320 --> 00:05:31,240
that there is a lot of JavaScript

00:05:30,160 --> 00:05:34,450
activity happening

00:05:31,240 --> 00:05:35,950
let's check why well there's 220

00:05:34,450 --> 00:05:40,120
kilobytes of JavaScript in this

00:05:35,950 --> 00:05:41,610
application that's really weird how did

00:05:40,120 --> 00:05:44,470
that happen

00:05:41,610 --> 00:05:47,290
we have several tools at our disposal to

00:05:44,470 --> 00:05:49,510
analyze what what is being shipped what

00:05:47,290 --> 00:05:51,730
is being loaded by the browser I'm using

00:05:49,510 --> 00:05:54,640
too in this presentation of a pack

00:05:51,730 --> 00:05:58,300
bundle analyzer and source map Explorer

00:05:54,640 --> 00:05:59,590
they both target the same J's file but

00:05:58,300 --> 00:06:01,840
they showed slightly different

00:05:59,590 --> 00:06:05,050
perspectives on what is what is present

00:06:01,840 --> 00:06:06,220
in the bundle this slides and everything

00:06:05,050 --> 00:06:07,240
is going to be shared with you so you

00:06:06,220 --> 00:06:09,550
don't need to worry about missing

00:06:07,240 --> 00:06:13,360
anything let's just focus on what is

00:06:09,550 --> 00:06:15,790
happening on the screen web pack bundle

00:06:13,360 --> 00:06:17,680
Nizer shows us the internal structure of

00:06:15,790 --> 00:06:19,990
the bundle as web pack generated so it

00:06:17,680 --> 00:06:22,330
contains boundaries that web pack

00:06:19,990 --> 00:06:24,790
generated to isolate modules while the

00:06:22,330 --> 00:06:27,040
source map Explorer contains just a

00:06:24,790 --> 00:06:29,860
mapping of the raw ranges in the bundle

00:06:27,040 --> 00:06:31,450
to the original source code and as we

00:06:29,860 --> 00:06:34,450
optimize web pack and the internal

00:06:31,450 --> 00:06:36,520
bundle architecture or the structure

00:06:34,450 --> 00:06:38,790
we'll see how these two views diverge in

00:06:36,520 --> 00:06:42,310
a significant way

00:06:38,790 --> 00:06:46,120
okay so 220 kilobytes we see there is a

00:06:42,310 --> 00:06:50,080
lot of rxjs we should do something about

00:06:46,120 --> 00:06:51,580
it but let's start by going through the

00:06:50,080 --> 00:06:54,639
process of creating a bundle what does

00:06:51,580 --> 00:06:57,400
it take to build a bundle so first

00:06:54,639 --> 00:06:58,840
we have our application source code and

00:06:57,400 --> 00:07:00,219
the application source code often

00:06:58,840 --> 00:07:02,080
reference system third-party libraries

00:07:00,219 --> 00:07:04,930
the application source code if it's not

00:07:02,080 --> 00:07:06,400
built in JavaScript that is runnable in

00:07:04,930 --> 00:07:08,379
a browser today we need to transpile it

00:07:06,400 --> 00:07:10,900
for that we use things like babel

00:07:08,379 --> 00:07:13,930
typescript arm compiler anything similar

00:07:10,900 --> 00:07:16,120
to that this will produce application

00:07:13,930 --> 00:07:18,460
JavaScript modules which then run in the

00:07:16,120 --> 00:07:19,689
browser and we need to take these and

00:07:18,460 --> 00:07:21,280
link them against the third-party

00:07:19,689 --> 00:07:24,969
modules up against the libraries that we

00:07:21,280 --> 00:07:27,430
were using for this we use typically web

00:07:24,969 --> 00:07:29,580
pack or roll-up I'm using webpack

00:07:27,430 --> 00:07:31,689
because I need code splitting and

00:07:29,580 --> 00:07:33,129
roll-up doesn't do it so what pack is

00:07:31,689 --> 00:07:34,599
really the only option if you if you're

00:07:33,129 --> 00:07:39,400
doing code splitting that you can use

00:07:34,599 --> 00:07:41,139
today this will produce a bundle so

00:07:39,400 --> 00:07:43,960
bundle is a single file or multiple

00:07:41,139 --> 00:07:45,580
files depending on your configuration if

00:07:43,960 --> 00:07:48,189
the derry-o doing chunking or code

00:07:45,580 --> 00:07:49,960
splitting and this bundle is not

00:07:48,189 --> 00:07:52,779
minified it didn't go through any kind

00:07:49,960 --> 00:07:53,979
of like JavaScript code optimization so

00:07:52,779 --> 00:07:56,169
we need to run it through mini fire

00:07:53,979 --> 00:07:58,900
whether it's ugly fie closure compiler

00:07:56,169 --> 00:08:00,940
or there are still other options you get

00:07:58,900 --> 00:08:03,400
minified bundle and this is what we ship

00:08:00,940 --> 00:08:05,229
to the client okay so now we see that we

00:08:03,400 --> 00:08:07,599
have all these pieces it looks slightly

00:08:05,229 --> 00:08:09,550
complicated we talked about to

00:08:07,599 --> 00:08:12,339
optimizations tree shaking and dead code

00:08:09,550 --> 00:08:14,979
elimination tree shaking as we refer to

00:08:12,339 --> 00:08:17,710
it in the web community often refers to

00:08:14,979 --> 00:08:19,330
what's happening in the bundle and that

00:08:17,710 --> 00:08:22,000
code elimination is what is happening in

00:08:19,330 --> 00:08:24,939
the minification phase okay great

00:08:22,000 --> 00:08:28,360
so let's look at what is happening we're

00:08:24,939 --> 00:08:31,659
back so tree shaking my pack is really

00:08:28,360 --> 00:08:33,760
live code inclusion that is happening at

00:08:31,659 --> 00:08:35,349
the module level the granularity is

00:08:33,760 --> 00:08:37,269
modulo this is how web pack 3 works

00:08:35,349 --> 00:08:38,740
there might this might happen in the

00:08:37,269 --> 00:08:41,409
future version of web pack but this is

00:08:38,740 --> 00:08:44,050
how web pack works today the downside of

00:08:41,409 --> 00:08:46,360
this is that it will over include stuff

00:08:44,050 --> 00:08:49,149
because even if you have import to file

00:08:46,360 --> 00:08:52,000
that is not used web pack will bring it

00:08:49,149 --> 00:08:53,980
in if you have a module from which

00:08:52,000 --> 00:08:56,230
you're using just one function but the

00:08:53,980 --> 00:08:57,640
module contains 20 functions web pack

00:08:56,230 --> 00:09:00,519
will bring all the fun functional

00:08:57,640 --> 00:09:03,100
not very good but this is why we have

00:09:00,519 --> 00:09:05,260
the second stage of optimization so

00:09:03,100 --> 00:09:07,089
let's take a look let's for web pack we

00:09:05,260 --> 00:09:08,230
define an entry point that points to a

00:09:07,089 --> 00:09:10,600
module

00:09:08,230 --> 00:09:12,850
then WebEx starts reversing this module

00:09:10,600 --> 00:09:14,500
graph and finds the module is needed

00:09:12,850 --> 00:09:18,430
because it's the entry point then we'll

00:09:14,500 --> 00:09:20,110
go to B B refers to C D and we'll find

00:09:18,430 --> 00:09:21,880
out that a and F is not used to it and

00:09:20,110 --> 00:09:23,830
will not bring it and it will create a

00:09:21,880 --> 00:09:27,160
bundle just from these just from these

00:09:23,830 --> 00:09:29,230
modules great so once we have the bundle

00:09:27,160 --> 00:09:31,540
created that's when the Dead come dead

00:09:29,230 --> 00:09:34,090
code elimination comes in this is what

00:09:31,540 --> 00:09:36,640
is happening uglify this is code from my

00:09:34,090 --> 00:09:39,580
sample application that I built just

00:09:36,640 --> 00:09:42,700
bunch of functions what uglify does it

00:09:39,580 --> 00:09:47,140
analyzes the code finds entry points

00:09:42,700 --> 00:09:49,390
using code analysis it finds nodes in

00:09:47,140 --> 00:09:51,160
the ast that have side effect and then

00:09:49,390 --> 00:09:53,140
traces everything from those entry

00:09:51,160 --> 00:09:55,300
points and finds what is reliable is not

00:09:53,140 --> 00:09:58,750
so in this case we have a backpack

00:09:55,300 --> 00:10:01,150
export it's a it's a property assignment

00:09:58,750 --> 00:10:02,650
for web pack fo uglify that means that

00:10:01,150 --> 00:10:04,840
it must be retained for this application

00:10:02,650 --> 00:10:07,240
to work so everything that is retained

00:10:04,840 --> 00:10:09,400
from here must be in the application so

00:10:07,240 --> 00:10:12,280
we see that this assignment reference is

00:10:09,400 --> 00:10:15,220
a data feed for function so we need to

00:10:12,280 --> 00:10:17,710
take that mark it as needed data fit for

00:10:15,220 --> 00:10:19,540
also references a retry function which

00:10:17,710 --> 00:10:23,500
is defined somewhere else we mark that

00:10:19,540 --> 00:10:25,540
as needed and webpack sees that take

00:10:23,500 --> 00:10:30,160
until is not used by anybody else so it

00:10:25,540 --> 00:10:32,830
can remove it great so let's go back to

00:10:30,160 --> 00:10:36,400
application and let's inspect the code

00:10:32,830 --> 00:10:38,800
to see why why do we have so much of it

00:10:36,400 --> 00:10:41,890
we couldn't be looking for expensive

00:10:38,800 --> 00:10:43,990
imports there are different ways to do

00:10:41,890 --> 00:10:45,760
this I still go back and forth about

00:10:43,990 --> 00:10:47,860
what is the most efficient one the

00:10:45,760 --> 00:10:49,180
tooling really sucks so you have to have

00:10:47,860 --> 00:10:52,030
a little bit of luck a little bit of

00:10:49,180 --> 00:10:54,550
knowing what to look for good one is

00:10:52,030 --> 00:10:56,020
visualizing the dependencies sometimes

00:10:54,550 --> 00:10:58,300
it can be too noisy it's not going to

00:10:56,020 --> 00:11:00,070
show you much but it's it's a good one

00:10:58,300 --> 00:11:01,420
to try the other one is just picking a

00:11:00,070 --> 00:11:03,820
symbol that you know should not be in

00:11:01,420 --> 00:11:05,470
the final application and then tracing

00:11:03,820 --> 00:11:08,320
it back and seeing what other retainers

00:11:05,470 --> 00:11:11,290
and then from there you see what the

00:11:08,320 --> 00:11:13,690
problem is so by doing this by a lot of

00:11:11,290 --> 00:11:16,090
through a little frustration we find

00:11:13,690 --> 00:11:18,730
this import in the stock exchange yes

00:11:16,090 --> 00:11:21,100
we're importing observable from the

00:11:18,730 --> 00:11:22,060
module rxjs if you know anything about

00:11:21,100 --> 00:11:23,800
rxjs you know

00:11:22,060 --> 00:11:25,900
that this is the way to get observable

00:11:23,800 --> 00:11:27,940
that is fully featured it has all the

00:11:25,900 --> 00:11:30,010
operators monkey patch on the prototype

00:11:27,940 --> 00:11:31,870
so you get all of the operators out of

00:11:30,010 --> 00:11:33,220
box super convenient when you are

00:11:31,870 --> 00:11:35,380
debugging when you're developing

00:11:33,220 --> 00:11:36,700
application because everything is right

00:11:35,380 --> 00:11:39,490
there so you can just write the code

00:11:36,700 --> 00:11:42,370
like I did inter all start with map

00:11:39,490 --> 00:11:45,310
every chain and everything beautiful

00:11:42,370 --> 00:11:47,500
other completion works in ID nice but

00:11:45,310 --> 00:11:49,690
then we end up with 220 K so it's not

00:11:47,500 --> 00:11:54,160
good what can we do about it there are

00:11:49,690 --> 00:11:56,680
two ways original when my pack when rxjs

00:11:54,160 --> 00:12:00,700
5 came out the solution to this problem

00:11:56,680 --> 00:12:02,680
was using this side-effect imports with

00:12:00,700 --> 00:12:05,170
side-effects through which you can bring

00:12:02,680 --> 00:12:07,930
operators as you need them this has

00:12:05,170 --> 00:12:10,450
several challenges if you change the

00:12:07,930 --> 00:12:13,720
code you will not there is there's no

00:12:10,450 --> 00:12:15,910
association between the operator and the

00:12:13,720 --> 00:12:18,370
code that uses it so if you refactor the

00:12:15,910 --> 00:12:21,550
code it's very easy to leave unused

00:12:18,370 --> 00:12:22,630
imports in or change the code and break

00:12:21,550 --> 00:12:25,840
it because you've removed the

00:12:22,630 --> 00:12:29,410
side-effect 3 imports and the code no

00:12:25,840 --> 00:12:31,060
longer works in run time so in our X is

00:12:29,410 --> 00:12:33,760
five point five we replace this with a

00:12:31,060 --> 00:12:37,960
different way of doing it our X is 525

00:12:33,760 --> 00:12:39,490
rule is just just last week and it has a

00:12:37,960 --> 00:12:41,980
lot of cool features so this is one of

00:12:39,490 --> 00:12:44,320
them what it allows us to do is to use

00:12:41,980 --> 00:12:47,770
this little operators it's a much more

00:12:44,320 --> 00:12:49,540
modular way of doing using rxjs and

00:12:47,770 --> 00:12:51,040
using this we can only bring things that

00:12:49,540 --> 00:12:54,900
we need so instead of bringing the whole

00:12:51,040 --> 00:12:58,120
rxjs or doing the unreliable side-effect

00:12:54,900 --> 00:13:00,580
non side-effect free imports we can use

00:12:58,120 --> 00:13:04,180
this proper imports bringing what we

00:13:00,580 --> 00:13:06,520
need use it great if we do this we just

00:13:04,180 --> 00:13:09,010
shaved of 71 kilobytes from application

00:13:06,520 --> 00:13:11,920
awesome there is still a lot work to be

00:13:09,010 --> 00:13:16,210
done but this is a good start so

00:13:11,920 --> 00:13:19,450
recommendation from this is use modular

00:13:16,210 --> 00:13:22,060
api's don't use monolithic api's often

00:13:19,450 --> 00:13:24,280
if you look at low - if you look at rxj

00:13:22,060 --> 00:13:25,900
as many other libraries now they're

00:13:24,280 --> 00:13:27,370
starting to offer more and more modular

00:13:25,900 --> 00:13:30,100
api its look for those and use them

00:13:27,370 --> 00:13:34,360
right linters or use linters that will

00:13:30,100 --> 00:13:35,860
catch any kind of usage of the old aps

00:13:34,360 --> 00:13:38,330
then bring every

00:13:35,860 --> 00:13:42,019
so if you look at the bundles right now

00:13:38,330 --> 00:13:45,589
um we see that they are smaller but

00:13:42,019 --> 00:13:48,050
there is still a lot of rxjs and we're

00:13:45,589 --> 00:13:50,000
not using that much of rxjs I really use

00:13:48,050 --> 00:13:51,769
just three operators my application so

00:13:50,000 --> 00:13:55,640
even if there are trusted dependences

00:13:51,769 --> 00:13:58,430
this is way too much unfortunately and

00:13:55,640 --> 00:14:01,130
the problem here is that we are pulling

00:13:58,430 --> 00:14:03,470
rxjs and also application in common J's

00:14:01,130 --> 00:14:06,140
format this is something that is super

00:14:03,470 --> 00:14:07,579
difficult to find because nobody wants

00:14:06,140 --> 00:14:09,110
you about it even that pack is very

00:14:07,579 --> 00:14:11,930
silent about it unless you install

00:14:09,110 --> 00:14:14,480
several plugins on that and gives you

00:14:11,930 --> 00:14:16,519
warnings so in this case I just knew

00:14:14,480 --> 00:14:19,550
because I used with userexists quite a

00:14:16,519 --> 00:14:23,329
bit that the path points to the CGS

00:14:19,550 --> 00:14:28,459
modules CGS is problematic we want to

00:14:23,329 --> 00:14:30,140
use ESM when we can why ESM allows us to

00:14:28,459 --> 00:14:32,300
statically analyze code without

00:14:30,140 --> 00:14:33,980
evaluating code we can find the imports

00:14:32,300 --> 00:14:38,630
and exports find the shape of the module

00:14:33,980 --> 00:14:42,680
and use optimizations to create smaller

00:14:38,630 --> 00:14:47,420
bundles to tree shake stuff to just do

00:14:42,680 --> 00:14:50,600
better the benefits come from being able

00:14:47,420 --> 00:14:53,510
to unused to remove unused imports we're

00:14:50,600 --> 00:14:56,300
able to concatenate modules and we're

00:14:53,510 --> 00:14:57,950
also able to do code splitting which is

00:14:56,300 --> 00:14:59,690
tricky if you if you're not using its

00:14:57,950 --> 00:15:03,079
modules possible but but it gets really

00:14:59,690 --> 00:15:05,750
messy an answer from so how do we do it

00:15:03,079 --> 00:15:07,190
in our XJS it's opt-in right now because

00:15:05,750 --> 00:15:09,200
we need to be backwards compatible so

00:15:07,190 --> 00:15:11,060
you have to create this alias it's ugly

00:15:09,200 --> 00:15:12,470
I hate it but this is the only way how

00:15:11,060 --> 00:15:14,899
we were able to do it without breaking

00:15:12,470 --> 00:15:16,250
the world in the next major version this

00:15:14,899 --> 00:15:19,699
is gonna be the default so you will not

00:15:16,250 --> 00:15:23,020
need to think about it if we do this we

00:15:19,699 --> 00:15:26,660
shave of 3k that's strange

00:15:23,020 --> 00:15:30,199
and we'll sad the reason for this is

00:15:26,660 --> 00:15:32,690
that for ESM optimizations to fully work

00:15:30,199 --> 00:15:34,550
you need to have almost everything to be

00:15:32,690 --> 00:15:36,230
an ASM format if you have even small

00:15:34,550 --> 00:15:38,420
part of the application especially the

00:15:36,230 --> 00:15:40,399
entry points be in the common J's format

00:15:38,420 --> 00:15:42,760
many of these optimizations will not

00:15:40,399 --> 00:15:42,760
work properly

00:15:43,600 --> 00:15:50,540
so let's let's fix the second source of

00:15:48,380 --> 00:15:54,200
common J's modules which is an

00:15:50,540 --> 00:15:57,740
application by default if you use

00:15:54,200 --> 00:16:01,730
webpack babel loader it will down level

00:15:57,740 --> 00:16:03,920
the important imports to common J's this

00:16:01,730 --> 00:16:07,100
is sad but that's how it is

00:16:03,920 --> 00:16:09,170
I wish the default was different and I'm

00:16:07,100 --> 00:16:10,640
hoping that in the future you will not

00:16:09,170 --> 00:16:14,600
need to opt into this stuff we should

00:16:10,640 --> 00:16:17,510
not need to obtain if we opt in we shave

00:16:14,600 --> 00:16:21,350
off 80k because now all of our modules

00:16:17,510 --> 00:16:24,800
is module is modules and webpack can can

00:16:21,350 --> 00:16:26,780
do more optimizations remove stuff so

00:16:24,800 --> 00:16:30,290
the recommendation is avoid common J's

00:16:26,780 --> 00:16:32,000
remove avoid um DS because they're

00:16:30,290 --> 00:16:35,150
basically common J's in slightly

00:16:32,000 --> 00:16:36,770
different form and do it from both your

00:16:35,150 --> 00:16:38,810
application and any kind of libraries

00:16:36,770 --> 00:16:40,160
that using if you do need to pulling

00:16:38,810 --> 00:16:42,830
some temporary library that is in common

00:16:40,160 --> 00:16:44,720
J's format try to do it in a lazy loaded

00:16:42,830 --> 00:16:48,350
chunk because that will isolate the rest

00:16:44,720 --> 00:16:49,580
of the application so now if you look at

00:16:48,350 --> 00:16:52,700
the bundles this is the previous

00:16:49,580 --> 00:16:55,940
structure and this is the new one we see

00:16:52,700 --> 00:16:57,770
that it's it's better I'm not expecting

00:16:55,940 --> 00:17:00,800
you to read stuff just visually if you

00:16:57,770 --> 00:17:05,900
if you see busy screen that's bad we

00:17:00,800 --> 00:17:09,020
want simple big big boxes okay so we are

00:17:05,900 --> 00:17:11,900
reducing the number number of modules in

00:17:09,020 --> 00:17:15,230
the in the bundle but there's still all

00:17:11,900 --> 00:17:18,140
of stuff that is remains but we are

00:17:15,230 --> 00:17:19,760
making some progress so what are the

00:17:18,140 --> 00:17:21,680
other optimizations that we can do i

00:17:19,760 --> 00:17:24,709
mentioned that es modules is capable of

00:17:21,680 --> 00:17:27,740
module concatenation what does it mean

00:17:24,709 --> 00:17:29,360
we have two years modules we can analyze

00:17:27,740 --> 00:17:31,640
them find the imports and exports and

00:17:29,360 --> 00:17:34,430
then safely merge those two modules

00:17:31,640 --> 00:17:35,870
together to have just one module we

00:17:34,430 --> 00:17:36,920
don't want to do this when we develop

00:17:35,870 --> 00:17:38,840
code because we would just end up with

00:17:36,920 --> 00:17:40,220
one giant file that contains all of our

00:17:38,840 --> 00:17:42,290
code and that is that would be a mess

00:17:40,220 --> 00:17:44,210
but we want tools to do it safely so we

00:17:42,290 --> 00:17:46,670
can write code in modular way and then

00:17:44,210 --> 00:17:49,130
do tools are used tools to analyze

00:17:46,670 --> 00:17:52,010
everything optimize stuff for us would

00:17:49,130 --> 00:17:56,030
assume this is possible but you have to

00:17:52,010 --> 00:17:56,510
opt in it's not on by default okay so we

00:17:56,030 --> 00:17:58,549
update

00:17:56,510 --> 00:18:00,470
we use this plugin that is part of the

00:17:58,549 --> 00:18:04,750
core it's just not a it's not on by

00:18:00,470 --> 00:18:07,880
default and we shave off another 40k

00:18:04,750 --> 00:18:12,290
that's pretty good we went from 220

00:18:07,880 --> 00:18:14,090
kilobytes to 29 usually through just

00:18:12,290 --> 00:18:18,890
opting into like the proper way of doing

00:18:14,090 --> 00:18:21,620
stuff okay so if we compare the output

00:18:18,890 --> 00:18:24,559
from our analyzers we see that it's

00:18:21,620 --> 00:18:27,470
significantly different this is what we

00:18:24,559 --> 00:18:32,090
want simple stuff big boxes with big

00:18:27,470 --> 00:18:35,210
letters what this means is that when the

00:18:32,090 --> 00:18:37,070
bundles created webpack takes all of our

00:18:35,210 --> 00:18:39,710
code and merges them into a single

00:18:37,070 --> 00:18:44,000
closure that contains all of the symbols

00:18:39,710 --> 00:18:46,760
and this is great for uglify because it

00:18:44,000 --> 00:18:49,490
can analyze and find that dead code much

00:18:46,760 --> 00:18:51,380
easier without this optimization webpack

00:18:49,490 --> 00:18:54,559
often generates code for internal

00:18:51,380 --> 00:18:56,210
registry orchestration it needs to

00:18:54,559 --> 00:18:58,250
create closures for each of the module

00:18:56,210 --> 00:19:00,500
and connect them together and by

00:18:58,250 --> 00:19:03,380
generating this code it often becomes

00:19:00,500 --> 00:19:05,299
the thing that prevents uglify from

00:19:03,380 --> 00:19:07,010
removing the code that is not used by

00:19:05,299 --> 00:19:09,799
application but just web packet happen

00:19:07,010 --> 00:19:12,380
to generate code for it so once you do

00:19:09,799 --> 00:19:14,809
turn on concatenation webpack does less

00:19:12,380 --> 00:19:17,120
of code generation in the bundle ugly if

00:19:14,809 --> 00:19:20,720
I can remove stuff and stuff just drops

00:19:17,120 --> 00:19:23,059
great Soyuz module concatenation this

00:19:20,720 --> 00:19:25,250
will reduce the module overhead and will

00:19:23,059 --> 00:19:26,960
improve the dead code animation so with

00:19:25,250 --> 00:19:29,480
all these optimizations when we look at

00:19:26,960 --> 00:19:32,179
how our application is performing now

00:19:29,480 --> 00:19:34,730
we'll see that we can put the pixels on

00:19:32,179 --> 00:19:36,740
the screen in about 3.3 seconds so

00:19:34,730 --> 00:19:38,299
that's time to interact you can keep in

00:19:36,740 --> 00:19:40,309
mind that the first two seconds that's

00:19:38,299 --> 00:19:42,260
the network not much we can do so we are

00:19:40,309 --> 00:19:47,720
focusing on the second part so we shaved

00:19:42,260 --> 00:19:50,750
off half a second so far we can do

00:19:47,720 --> 00:19:54,230
better so the next optimization we can

00:19:50,750 --> 00:19:56,330
use is code splitting right now our

00:19:54,230 --> 00:19:58,100
application is not showing anything

00:19:56,330 --> 00:20:00,650
until we have all the code present in

00:19:58,100 --> 00:20:04,549
the browser so even though it's just 29

00:20:00,650 --> 00:20:06,559
K there is a delay could we split the

00:20:04,549 --> 00:20:09,559
application so that we can render

00:20:06,559 --> 00:20:10,780
something useful and then let you load

00:20:09,559 --> 00:20:14,540
the rest of the code

00:20:10,780 --> 00:20:17,330
we can in my application the way

00:20:14,540 --> 00:20:19,760
architected it is the view layer can

00:20:17,330 --> 00:20:22,280
actually be rendered separately from the

00:20:19,760 --> 00:20:25,240
rest of application this means that we

00:20:22,280 --> 00:20:27,110
can render the the footer the header and

00:20:25,240 --> 00:20:29,180
basically the whole layout of the

00:20:27,110 --> 00:20:33,350
application without bringing any data

00:20:29,180 --> 00:20:35,900
this is great what does that mean is

00:20:33,350 --> 00:20:39,260
that in a current application we just

00:20:35,900 --> 00:20:41,480
add a seam that allows us to split the

00:20:39,260 --> 00:20:43,190
whole the graph into two chunks in the

00:20:41,480 --> 00:20:44,960
main chunk that is useful rendering and

00:20:43,190 --> 00:20:47,660
the second chunk that is just all the

00:20:44,960 --> 00:20:51,680
data data layer and pulling pulling data

00:20:47,660 --> 00:20:53,120
in how does it look in the code we look

00:20:51,680 --> 00:20:55,070
at the imports we analyze the

00:20:53,120 --> 00:20:58,940
problematic one which is the the data

00:20:55,070 --> 00:21:01,040
import and the code that uses it and we

00:20:58,940 --> 00:21:03,140
replace this with system import which is

00:21:01,040 --> 00:21:05,630
the dynamic import soon this will be

00:21:03,140 --> 00:21:08,330
just import function thanks to the new

00:21:05,630 --> 00:21:10,210
standard that was approved right now in

00:21:08,330 --> 00:21:14,300
web pack you have to use system import

00:21:10,210 --> 00:21:15,890
basically the same thing once we do this

00:21:14,300 --> 00:21:18,200
we can analyze the bundles and what

00:21:15,890 --> 00:21:20,930
we'll see is that we didn't shave off

00:21:18,200 --> 00:21:22,490
any code sometimes we add a few one

00:21:20,930 --> 00:21:24,200
kilobyte or two kilobytes because now we

00:21:22,490 --> 00:21:26,900
need to stitch the two two bundles

00:21:24,200 --> 00:21:29,540
together but what is important is that

00:21:26,900 --> 00:21:32,510
we now removed mostly code from the

00:21:29,540 --> 00:21:35,240
critical path the main bundle is just

00:21:32,510 --> 00:21:37,700
three kilobytes large while the data

00:21:35,240 --> 00:21:39,980
layer that we are lazily loading is 27

00:21:37,700 --> 00:21:41,660
kilobytes and if you look at the source

00:21:39,980 --> 00:21:43,670
map Explorer that points just to the

00:21:41,660 --> 00:21:46,160
main bundle we see that it's really just

00:21:43,670 --> 00:21:48,200
the code that we wrote and the operators

00:21:46,160 --> 00:21:49,580
that are necessary for application great

00:21:48,200 --> 00:21:52,580
this is what we want to see in the in

00:21:49,580 --> 00:21:54,920
the critical path and when we look at

00:21:52,580 --> 00:21:57,080
the numbers we see that we defer 27

00:21:54,920 --> 00:22:00,170
kilobytes okay

00:21:57,080 --> 00:22:02,690
let's compare the user experience so

00:22:00,170 --> 00:22:05,780
before we were at 3.3 seconds now we can

00:22:02,690 --> 00:22:07,940
render something useful at 2.5 seconds

00:22:05,780 --> 00:22:10,460
so we have the layout we have some basic

00:22:07,940 --> 00:22:13,880
stuff we don't have any data yet at 3.5

00:22:10,460 --> 00:22:17,900
seconds we have data great this is

00:22:13,880 --> 00:22:21,230
awesome what sucks is that the data is

00:22:17,900 --> 00:22:22,740
rendered 0.2 seconds later than what it

00:22:21,230 --> 00:22:26,070
originally was

00:22:22,740 --> 00:22:27,840
why is that once you start code

00:22:26,070 --> 00:22:30,630
splitting you're making a request and

00:22:27,840 --> 00:22:32,130
this requests the create waterfall so

00:22:30,630 --> 00:22:33,600
that means the application needs to

00:22:32,130 --> 00:22:35,250
render the initial screen and then

00:22:33,600 --> 00:22:37,380
realizes oh I need to go fetch the data

00:22:35,250 --> 00:22:40,559
let me fetch the code for data and only

00:22:37,380 --> 00:22:43,020
then the request is made what I can do

00:22:40,559 --> 00:22:45,929
about it we can do about it is optimize

00:22:43,020 --> 00:22:48,450
the network through prefetch preload or

00:22:45,929 --> 00:22:51,179
HTTP push in my case because I'm on

00:22:48,450 --> 00:22:53,039
firebase I just use HTTP push this means

00:22:51,179 --> 00:22:55,200
that what this does is when I make the

00:22:53,039 --> 00:22:58,409
acress for my application the server

00:22:55,200 --> 00:23:01,080
will send the index.html and with that

00:22:58,409 --> 00:23:03,450
we also send both the main and also the

00:23:01,080 --> 00:23:06,990
the lazy data module in that order with

00:23:03,450 --> 00:23:11,309
those priorities the end result is that

00:23:06,990 --> 00:23:13,020
we render the initial screen in two

00:23:11,309 --> 00:23:15,840
point two seconds as opposed to two

00:23:13,020 --> 00:23:18,090
point five and the full screen into

00:23:15,840 --> 00:23:19,559
point six so we improved both the full

00:23:18,090 --> 00:23:22,409
load but also time to interactive

00:23:19,559 --> 00:23:25,529
because a 2.2 application is interactive

00:23:22,409 --> 00:23:29,549
so this is awesome this is this is where

00:23:25,529 --> 00:23:32,130
we want to be we now adding just about

00:23:29,549 --> 00:23:34,710
0.2 seconds on top of the network time

00:23:32,130 --> 00:23:37,230
so if we have serviceworker application

00:23:34,710 --> 00:23:39,419
already bootstrap in just 0.2 seconds if

00:23:37,230 --> 00:23:41,730
you look at what the the waterfall

00:23:39,419 --> 00:23:45,059
diagram looks like it's much more busier

00:23:41,730 --> 00:23:46,980
we have we have several steps in there

00:23:45,059 --> 00:23:48,740
and this is this what we want to see we

00:23:46,980 --> 00:23:51,929
want to see parallelization of request

00:23:48,740 --> 00:23:54,360
parallelization of work so the

00:23:51,929 --> 00:23:57,029
recommendation number four is use code

00:23:54,360 --> 00:23:58,860
splitting ad seems to application but

00:23:57,029 --> 00:24:01,470
keep in mind the network latency issues

00:23:58,860 --> 00:24:04,320
and how that can bind T and bind bind by

00:24:01,470 --> 00:24:09,899
to you so using a combination with HTTP

00:24:04,320 --> 00:24:13,610
2 or 3 load prefetch optimizations so we

00:24:09,899 --> 00:24:16,350
talked a lot about the tree shaking and

00:24:13,610 --> 00:24:20,010
let's take it some time to look at that

00:24:16,350 --> 00:24:21,840
code elimination so as I explained

00:24:20,010 --> 00:24:23,340
before that elimination is kind of

00:24:21,840 --> 00:24:25,230
similar to what web pack doesn't

00:24:23,340 --> 00:24:27,390
backpack calls tree shaking

00:24:25,230 --> 00:24:29,520
you can see how hesitant I am about

00:24:27,390 --> 00:24:31,889
these terms because if you think about

00:24:29,520 --> 00:24:34,049
it that both tools do something very

00:24:31,889 --> 00:24:35,520
similar just a different level web pack

00:24:34,049 --> 00:24:36,570
does it at the module level where it

00:24:35,520 --> 00:24:38,820
operates with the import

00:24:36,570 --> 00:24:41,130
and export uglify does something very

00:24:38,820 --> 00:24:47,130
similar but it operates on a SD it

00:24:41,130 --> 00:24:48,630
operates on the symbols in a code one

00:24:47,130 --> 00:24:50,370
thing to realize with dead code

00:24:48,630 --> 00:24:53,850
elimination however is that because it

00:24:50,370 --> 00:24:55,440
operates on a SD it has much harder time

00:24:53,850 --> 00:24:57,990
to statically analyze the application

00:24:55,440 --> 00:25:01,259
the es modules were designed to be

00:24:57,990 --> 00:25:03,120
statically analyzable javascript has big

00:25:01,259 --> 00:25:05,460
limitations when it comes to static and

00:25:03,120 --> 00:25:08,639
analyze ability so ugly phi has to do

00:25:05,460 --> 00:25:11,399
much more has to use heuristics and has

00:25:08,639 --> 00:25:13,980
to keep things safe and often opt out

00:25:11,399 --> 00:25:15,000
and bail out of optimizations what are

00:25:13,980 --> 00:25:17,809
the things that you should keep in mind

00:25:15,000 --> 00:25:20,730
when it comes to that code elimination

00:25:17,809 --> 00:25:22,559
usually it comes to side-effect the code

00:25:20,730 --> 00:25:24,539
in the top level of the module so if you

00:25:22,559 --> 00:25:26,340
have your module if your file and if you

00:25:24,539 --> 00:25:29,009
in that file you are executing a

00:25:26,340 --> 00:25:31,230
function or you have a Fe then that's

00:25:29,009 --> 00:25:34,409
the thing that web and that uglify will

00:25:31,230 --> 00:25:36,570
consider us alive and not removable even

00:25:34,409 --> 00:25:38,460
if it doesn't have any side effects

00:25:36,570 --> 00:25:41,190
outside of that if a it will still be

00:25:38,460 --> 00:25:44,820
preserved the most common way to down

00:25:41,190 --> 00:25:47,730
level classes is using a face so if you

00:25:44,820 --> 00:25:49,710
write any class down level two C is five

00:25:47,730 --> 00:25:53,360
you will end up with a Fe that ugly if I

00:25:49,710 --> 00:25:55,919
cannot remove any more that sucks the

00:25:53,360 --> 00:25:57,450
next next thing we say besides if is

00:25:55,919 --> 00:25:59,309
this function calls often useful

00:25:57,450 --> 00:26:00,809
function when you have a factory

00:25:59,309 --> 00:26:04,169
function that just initializes some

00:26:00,809 --> 00:26:06,570
state constructor calls again if you

00:26:04,169 --> 00:26:08,009
have just like bar new logger in your

00:26:06,570 --> 00:26:10,740
application and nobody uses the logger

00:26:08,009 --> 00:26:12,509
it will be preserved when the last one

00:26:10,740 --> 00:26:14,549
is property assignment which is the

00:26:12,509 --> 00:26:17,039
problem for web pack because web pack

00:26:14,549 --> 00:26:21,360
use this property Simon Oliver to stitch

00:26:17,039 --> 00:26:23,549
internal module structures together the

00:26:21,360 --> 00:26:26,730
good news is that uglify can take some

00:26:23,549 --> 00:26:28,200
hints and this was added recently a

00:26:26,730 --> 00:26:30,509
couple months ago they added support for

00:26:28,200 --> 00:26:32,429
pure annotations through which you can

00:26:30,509 --> 00:26:35,509
mark code that otherwise would be

00:26:32,429 --> 00:26:39,210
considered as unsafe to remove and

00:26:35,509 --> 00:26:41,279
uglify now can remove it so what we did

00:26:39,210 --> 00:26:43,350
is we when actually through the whole

00:26:41,279 --> 00:26:46,019
rxjs and marked all the code that we

00:26:43,350 --> 00:26:47,370
know has no side effects most of our

00:26:46,019 --> 00:26:48,590
code doesn't have side effects so it's

00:26:47,370 --> 00:26:52,300
safe to do it

00:26:48,590 --> 00:26:56,270
good examples of that is we have this

00:26:52,300 --> 00:26:58,790
retry subscriber which was a class was

00:26:56,270 --> 00:27:01,190
down leveled retained by uglify if we

00:26:58,790 --> 00:27:03,530
mark it with pure it will it will be

00:27:01,190 --> 00:27:04,820
removed if not used by anybody else the

00:27:03,530 --> 00:27:06,920
same with observable this is a good

00:27:04,820 --> 00:27:08,840
example of a getter or factory factory

00:27:06,920 --> 00:27:11,180
function that is retained usually

00:27:08,840 --> 00:27:15,890
without the pure annotation new

00:27:11,180 --> 00:27:17,440
constructor call and so on so what would

00:27:15,890 --> 00:27:20,380
happen if we stripped all of these

00:27:17,440 --> 00:27:23,540
annotations and build the application I

00:27:20,380 --> 00:27:25,970
wrote this shell command to just

00:27:23,540 --> 00:27:27,980
experiment with this it turns out we

00:27:25,970 --> 00:27:29,570
will add 86 kilobytes back into a bundle

00:27:27,980 --> 00:27:31,850
so after all of these symptom

00:27:29,570 --> 00:27:34,100
optimizations we did if we strip these

00:27:31,850 --> 00:27:36,080
annotations that already ship and ArcGIS

00:27:34,100 --> 00:27:39,260
and you get them out of box today if you

00:27:36,080 --> 00:27:42,650
use RHCs 5.5 if we remove the

00:27:39,260 --> 00:27:44,980
annotations you will be getting extra 86

00:27:42,650 --> 00:27:47,330
k not fun

00:27:44,980 --> 00:27:50,000
so is it safe to use this pure

00:27:47,330 --> 00:27:52,640
annotation everywhere not quite if it

00:27:50,000 --> 00:27:54,410
was a glyph I wouldn't need hints it

00:27:52,640 --> 00:27:55,900
really comes down to best practices if

00:27:54,410 --> 00:27:58,340
you write code that doesn't have

00:27:55,900 --> 00:28:00,760
non-local side-effects it's safe to do

00:27:58,340 --> 00:28:03,230
it this is what we usually do and

00:28:00,760 --> 00:28:04,760
sometimes if you if you're breaking this

00:28:03,230 --> 00:28:08,840
rule is it's really just like when

00:28:04,760 --> 00:28:11,240
you're writing polyfills or polyfills is

00:28:08,840 --> 00:28:13,130
probably the most common example if you

00:28:11,240 --> 00:28:15,800
have code that has a global registry

00:28:13,130 --> 00:28:18,170
that you put stuff into as the code is

00:28:15,800 --> 00:28:21,050
being loaded that's when the code is not

00:28:18,170 --> 00:28:25,130
safe because you would just be removing

00:28:21,050 --> 00:28:26,420
stuff that might be needed so be careful

00:28:25,130 --> 00:28:31,580
about where you put these pure

00:28:26,420 --> 00:28:34,340
annotations the good news is that while

00:28:31,580 --> 00:28:37,040
today uglify takes these hints in the

00:28:34,340 --> 00:28:41,270
future a version of web pack web pack

00:28:37,040 --> 00:28:45,380
for will accept package level hint

00:28:41,270 --> 00:28:47,060
called side-effects false certificate

00:28:45,380 --> 00:28:49,070
free or I'm not sure about the property

00:28:47,060 --> 00:28:51,080
names because it changes there will be a

00:28:49,070 --> 00:28:53,240
way to mark a package in the package of

00:28:51,080 --> 00:28:55,310
JSON as free of side effects and that

00:28:53,240 --> 00:28:58,550
will allow to do similar optimizations

00:28:55,310 --> 00:29:00,910
in the end of a pack level during tree

00:28:58,550 --> 00:29:00,910
shaking

00:29:01,779 --> 00:29:06,529
so you might be thinking this is

00:29:03,860 --> 00:29:08,779
insanity right like who should know all

00:29:06,529 --> 00:29:13,490
this stuff and how do we discover this

00:29:08,779 --> 00:29:15,440
how do we prevent regressions well the

00:29:13,490 --> 00:29:17,509
only recommendation I have right now is

00:29:15,440 --> 00:29:19,820
you should measure and you should

00:29:17,509 --> 00:29:21,440
monitor you should know what the

00:29:19,820 --> 00:29:22,940
application is performing us today you

00:29:21,440 --> 00:29:24,559
should have a budget and know what they

00:29:22,940 --> 00:29:27,019
are meeting the budget or not and you

00:29:24,559 --> 00:29:29,120
should continuously monitor the

00:29:27,019 --> 00:29:31,309
performance of the application this is

00:29:29,120 --> 00:29:33,049
this is the best we can do today as we

00:29:31,309 --> 00:29:36,619
are improving the defaults and making it

00:29:33,049 --> 00:29:38,659
harder for you to not opt in or you

00:29:36,619 --> 00:29:40,399
would have to opt out you will have to

00:29:38,659 --> 00:29:44,779
think about this less and less but right

00:29:40,399 --> 00:29:46,610
now really just measure and monitor so

00:29:44,779 --> 00:29:51,110
let's let's look at the final effect of

00:29:46,610 --> 00:29:53,860
optimizations before we were loading the

00:29:51,110 --> 00:29:56,960
useful bits on the screen at 3.8 seconds

00:29:53,860 --> 00:29:58,639
so TTI is 3.8 and after all these

00:29:56,960 --> 00:30:01,879
optimizations we got it down to two

00:29:58,639 --> 00:30:04,519
point two seconds with the data arriving

00:30:01,879 --> 00:30:06,740
at 2.6 seconds this is much much better

00:30:04,519 --> 00:30:12,710
again with serviceworker you can shave

00:30:06,740 --> 00:30:16,570
it down to 0.2 and 0.6 so summary of the

00:30:12,710 --> 00:30:20,779
recommendations use modularized api's

00:30:16,570 --> 00:30:22,340
use is modules throughout I wish

00:30:20,779 --> 00:30:23,720
somebody would wrote a plugin that would

00:30:22,340 --> 00:30:25,249
make it more obvious when you're not

00:30:23,720 --> 00:30:28,299
doing it this is something that you can

00:30:25,249 --> 00:30:30,710
help with turn on module concatenation

00:30:28,299 --> 00:30:33,369
there should be warning if you are not

00:30:30,710 --> 00:30:35,690
doing it but it's not the case today

00:30:33,369 --> 00:30:37,879
use code splitting two different code

00:30:35,690 --> 00:30:40,730
that you don't need for the rendering of

00:30:37,879 --> 00:30:44,119
the initial screen and the last one is

00:30:40,730 --> 00:30:45,799
if you have code that ugly if I cannot

00:30:44,119 --> 00:30:47,419
remove because it might contain

00:30:45,799 --> 00:30:49,549
side-effects and you know that it

00:30:47,419 --> 00:30:52,039
doesn't use the hints to tell uglify

00:30:49,549 --> 00:30:54,289
that can be removed this is this is more

00:30:52,039 --> 00:30:56,179
of a recommendation for library authors

00:30:54,289 --> 00:30:57,679
but if you think about it everybody here

00:30:56,179 --> 00:30:59,330
is a library author if you build big

00:30:57,679 --> 00:31:01,279
enough application because you have

00:30:59,330 --> 00:31:04,460
shared code and that's where this

00:31:01,279 --> 00:31:06,950
problem becomes visible and the last one

00:31:04,460 --> 00:31:09,049
is measure and monitor because without

00:31:06,950 --> 00:31:11,330
that you will be frustrated through

00:31:09,049 --> 00:31:13,549
regressions you will fix things just

00:31:11,330 --> 00:31:14,050
just to have more regressions tomorrow

00:31:13,549 --> 00:31:15,880
and

00:31:14,050 --> 00:31:18,490
will not even know about it and usually

00:31:15,880 --> 00:31:20,050
as you iterate as you continuously

00:31:18,490 --> 00:31:22,180
change the application if you identify

00:31:20,050 --> 00:31:24,340
the resizer regression early on it's

00:31:22,180 --> 00:31:26,980
much easier to know why it happened and

00:31:24,340 --> 00:31:28,870
fix it if you just test the size of the

00:31:26,980 --> 00:31:30,490
application once a month you made so

00:31:28,870 --> 00:31:33,730
many changes it's really hard to you but

00:31:30,490 --> 00:31:36,940
basically starting from scratch so yes

00:31:33,730 --> 00:31:39,520
all this is messed up it shouldn't be

00:31:36,940 --> 00:31:42,250
this way but that's how it is and we

00:31:39,520 --> 00:31:44,590
have to deal with it it's improving we

00:31:42,250 --> 00:31:46,480
my team the angular team is working with

00:31:44,590 --> 00:31:49,150
other teams to make sure that these

00:31:46,480 --> 00:31:52,120
things become default and so you don't

00:31:49,150 --> 00:31:53,620
have to think about it if you use CLI in

00:31:52,120 --> 00:31:55,510
the CLI many of these optimization

00:31:53,620 --> 00:31:58,930
angular CLI many of these optimizations

00:31:55,510 --> 00:32:01,210
come turned on by default and I believe

00:31:58,930 --> 00:32:03,550
that if we work together we can make the

00:32:01,210 --> 00:32:06,700
switch over to the better path faster so

00:32:03,550 --> 00:32:09,730
if you can help please help thank you

00:32:06,700 --> 00:32:13,190
I'm leaving the slides here

00:32:09,730 --> 00:32:13,190
[Applause]

00:32:13,290 --> 00:32:18,300
Igor thank you very much thank you very

00:32:15,610 --> 00:32:18,300
much for the talk

00:32:24,179 --> 00:32:26,240

YouTube URL: https://www.youtube.com/watch?v=75ObMlqrhFY


