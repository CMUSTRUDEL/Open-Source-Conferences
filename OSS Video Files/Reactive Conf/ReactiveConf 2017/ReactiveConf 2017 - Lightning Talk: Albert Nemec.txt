Title: ReactiveConf 2017 - Lightning Talk: Albert Nemec
Publication date: 2017-11-24
Playlist: ReactiveConf 2017
Description: 
	Main stage talk

https://reactiveconf.com/
25th - 27th October 2017, Bratislava, Slovakia
Captions: 
	00:00:02,040 --> 00:00:07,440
[Music]

00:00:20,150 --> 00:00:27,080
so hello I'm Albert Camus and I am

00:00:24,610 --> 00:00:29,689
programming in JavaScript during the day

00:00:27,080 --> 00:00:32,390
and in the night I miss around Haskell

00:00:29,689 --> 00:00:34,879
and I came to talk about mana

00:00:32,390 --> 00:00:37,730
decomposition in rags application or

00:00:34,879 --> 00:00:38,989
react like applications so just to know

00:00:37,730 --> 00:00:42,620
where I stand

00:00:38,989 --> 00:00:45,379
who knows what is a monad oh that's

00:00:42,620 --> 00:00:46,480
quite okay so we are going for some

00:00:45,379 --> 00:00:51,710
business

00:00:46,480 --> 00:00:55,879
all right so finish we are you are

00:00:51,710 --> 00:00:57,440
incredibly talented and you know - you

00:00:55,879 --> 00:01:01,790
know how to think about a lot of things

00:00:57,440 --> 00:01:04,100
in one time yet you are stuck with

00:01:01,790 --> 00:01:07,640
writing boring cold and boilerplate code

00:01:04,100 --> 00:01:10,189
and it's especially when you are dealing

00:01:07,640 --> 00:01:13,340
with something more complex like a

00:01:10,189 --> 00:01:15,439
synchronous asynchronous word you tend

00:01:13,340 --> 00:01:18,080
to write like this is I think promise

00:01:15,439 --> 00:01:20,420
middleware and it's a lot of code it's

00:01:18,080 --> 00:01:24,020
not abstract enough and you really want

00:01:20,420 --> 00:01:27,980
to go for the abstraction but it's not

00:01:24,020 --> 00:01:31,040
easy thing to do because each data

00:01:27,980 --> 00:01:33,860
behaves in a different way some data

00:01:31,040 --> 00:01:36,200
might not be there some data might may

00:01:33,860 --> 00:01:36,830
not be there yet some data you want to

00:01:36,200 --> 00:01:39,800
walk

00:01:36,830 --> 00:01:42,080
it's those hidden properties that you

00:01:39,800 --> 00:01:44,180
wouldn't normally describe in an

00:01:42,080 --> 00:01:46,400
object-oriented way where you define

00:01:44,180 --> 00:01:49,250
methods and that's the way you describe

00:01:46,400 --> 00:01:51,470
the data in a functional programming you

00:01:49,250 --> 00:01:54,409
would describe it by property so it's

00:01:51,470 --> 00:01:56,870
will be different thing use complex type

00:01:54,409 --> 00:01:58,400
systems for it and you don't have that

00:01:56,870 --> 00:01:58,970
in JavaScript so you have to help

00:01:58,400 --> 00:02:01,520
yourself

00:01:58,970 --> 00:02:02,750
in the different ways this is this is

00:02:01,520 --> 00:02:04,850
like the equation when I was

00:02:02,750 --> 00:02:07,220
brainstorming how to describe the

00:02:04,850 --> 00:02:08,690
problem with abstraction and it's when

00:02:07,220 --> 00:02:10,879
you have a lot of cool lot of boring

00:02:08,690 --> 00:02:14,150
code is probably because you are not

00:02:10,879 --> 00:02:16,099
abstract enough but when you are highly

00:02:14,150 --> 00:02:19,099
abstract and you can have like thousands

00:02:16,099 --> 00:02:23,239
of OB classes that are inheriting from

00:02:19,099 --> 00:02:26,480
each other it can be quite unreadable so

00:02:23,239 --> 00:02:29,480
when you need good trait readability and

00:02:26,480 --> 00:02:31,129
you know you need her abstraction that's

00:02:29,480 --> 00:02:33,980
a good pattern you need to search for

00:02:31,129 --> 00:02:35,930
and since I like functional

00:02:33,980 --> 00:02:38,269
gramming let's talk about functional

00:02:35,930 --> 00:02:40,879
programming because that's where we are

00:02:38,269 --> 00:02:44,599
stealing the ideas from for react and

00:02:40,879 --> 00:02:47,299
for JavaScript at least for now so you

00:02:44,599 --> 00:02:49,459
might say okay but we are already going

00:02:47,299 --> 00:02:51,290
that path we know what functional

00:02:49,459 --> 00:02:53,180
programming is and we have react

00:02:51,290 --> 00:02:56,120
it's like composition of pure function

00:02:53,180 --> 00:02:58,910
it's so awesome and that is true and I'm

00:02:56,120 --> 00:03:00,709
so glad that we exist but that's just

00:02:58,910 --> 00:03:02,660
part of your application there is also

00:03:00,709 --> 00:03:05,090
the data part of your application and

00:03:02,660 --> 00:03:07,099
things you may you may say okay we have

00:03:05,090 --> 00:03:10,400
read acts for that or more bags or

00:03:07,099 --> 00:03:12,200
whatever but that's that's solving the

00:03:10,400 --> 00:03:15,260
problem of how to obtain the data and

00:03:12,200 --> 00:03:17,510
have to store the data but the model the

00:03:15,260 --> 00:03:18,859
model of the application is actually how

00:03:17,510 --> 00:03:21,079
to transform the data and how you

00:03:18,859 --> 00:03:26,660
connect the data and we don't describe

00:03:21,079 --> 00:03:28,940
that in na and a pattern ish way so this

00:03:26,660 --> 00:03:33,620
is your component tree or like render

00:03:28,940 --> 00:03:36,920
functions it splits pretty good it looks

00:03:33,620 --> 00:03:38,959
like a graph which is a great thing it

00:03:36,920 --> 00:03:40,940
also is composable which is another

00:03:38,959 --> 00:03:44,389
great thing because you can work with it

00:03:40,940 --> 00:03:46,609
like an algebraic data type if some of

00:03:44,389 --> 00:03:49,130
you like category theory likes

00:03:46,609 --> 00:03:52,340
categories who knows at least something

00:03:49,130 --> 00:03:54,709
a little bit about category theory okay

00:03:52,340 --> 00:03:57,109
that's impressive about for people at

00:03:54,709 --> 00:03:58,880
school let's go I like it so okay you

00:03:57,109 --> 00:04:01,370
have react and that's a good thing so

00:03:58,880 --> 00:04:05,780
for data you probably have free - and

00:04:01,370 --> 00:04:07,400
it's very pure right well it is not that

00:04:05,780 --> 00:04:08,440
pure because what is a return value of

00:04:07,400 --> 00:04:10,280
this patch

00:04:08,440 --> 00:04:13,099
I'm just owning you it's not that

00:04:10,280 --> 00:04:15,440
important but it's not a scrap it's not

00:04:13,099 --> 00:04:17,269
describing your model model in a way

00:04:15,440 --> 00:04:19,579
that you could just look what happened

00:04:17,269 --> 00:04:21,680
what happened to this prop when it was

00:04:19,579 --> 00:04:25,570
traveling across this whole application

00:04:21,680 --> 00:04:29,210
of higher-order components and stuff so

00:04:25,570 --> 00:04:34,370
we need something that would contain our

00:04:29,210 --> 00:04:36,410
data and describe it it would it should

00:04:34,370 --> 00:04:38,330
be composable and it should look like a

00:04:36,410 --> 00:04:40,250
graph because we know how to visualize

00:04:38,330 --> 00:04:42,950
graph II know how to reason about graph

00:04:40,250 --> 00:04:45,620
we know that from react so you need

00:04:42,950 --> 00:04:48,500
abstraction composition and therefore

00:04:45,620 --> 00:04:52,710
you probably need monads because why not

00:04:48,500 --> 00:04:54,240
is the thing for those of you who don't

00:04:52,710 --> 00:04:56,100
know what a monad is this is like a

00:04:54,240 --> 00:04:59,040
sloppy definition that I try to write

00:04:56,100 --> 00:05:01,590
because it can get very academic quite

00:04:59,040 --> 00:05:03,300
quickly so monad is a kind of a data

00:05:01,590 --> 00:05:06,150
structure that encapsulates your data

00:05:03,300 --> 00:05:08,400
and highs annoying operations in the

00:05:06,150 --> 00:05:10,140
composition a knowing composite an Inc

00:05:08,400 --> 00:05:13,670
operation could be something like

00:05:10,140 --> 00:05:18,120
handling acing data so what is handling

00:05:13,670 --> 00:05:21,840
the internal strip promises so there is

00:05:18,120 --> 00:05:24,270
this the thing if you is a composition

00:05:21,840 --> 00:05:27,570
of render functions why Cannot the model

00:05:24,270 --> 00:05:30,360
be the composition of then functions

00:05:27,570 --> 00:05:32,760
because it Benny then you when you have

00:05:30,360 --> 00:05:35,970
it on one data you can log eight you can

00:05:32,760 --> 00:05:38,310
inspect it you can see the chain of pure

00:05:35,970 --> 00:05:40,260
functions which you can reason about you

00:05:38,310 --> 00:05:43,800
can compose multiple promise that will

00:05:40,260 --> 00:05:47,340
wait on each other and that's melodic

00:05:43,800 --> 00:05:49,170
composition and you want to try it so we

00:05:47,340 --> 00:05:51,150
end up with a graph it looks like

00:05:49,170 --> 00:05:53,400
inverted because you are usually usually

00:05:51,150 --> 00:05:55,850
for one component composing multiple

00:05:53,400 --> 00:06:00,240
promises into one that will eventually

00:05:55,850 --> 00:06:03,170
and now you we have a problem how to map

00:06:00,240 --> 00:06:07,110
those graphs we need to work it together

00:06:03,170 --> 00:06:08,340
so that there are also started to think

00:06:07,110 --> 00:06:10,920
okay category theory

00:06:08,340 --> 00:06:14,480
I saw a few videos and expert therefore

00:06:10,920 --> 00:06:17,760
an expert how could we solve this well I

00:06:14,480 --> 00:06:19,290
cannot in seven minutes tell you

00:06:17,760 --> 00:06:22,050
everything about it so this is like the

00:06:19,290 --> 00:06:24,240
fault process you can work on algebraic

00:06:22,050 --> 00:06:27,030
data types like numbers there is some

00:06:24,240 --> 00:06:28,830
way how we can combine compose when it

00:06:27,030 --> 00:06:31,140
combined number and a number you get a

00:06:28,830 --> 00:06:33,870
number the same is with functors when

00:06:31,140 --> 00:06:36,480
you map over func doors which array is a

00:06:33,870 --> 00:06:39,480
factor you get another factor so when

00:06:36,480 --> 00:06:41,940
you have promises and components you

00:06:39,480 --> 00:06:47,910
have to write your decorator that will

00:06:41,940 --> 00:06:49,620
paint those two graphs together but

00:06:47,910 --> 00:06:52,860
there's a problem when you start passing

00:06:49,620 --> 00:06:55,980
promises through react component three

00:06:52,860 --> 00:06:57,960
it will break because component

00:06:55,980 --> 00:07:00,450
update does not work with promises very

00:06:57,960 --> 00:07:01,300
much so I was very certain I will okay

00:07:00,450 --> 00:07:04,030
what I'm doing

00:07:01,300 --> 00:07:07,060
do this talk about no topic I know

00:07:04,030 --> 00:07:08,860
nothing but you also have said state

00:07:07,060 --> 00:07:11,650
with which you can solve this for you

00:07:08,860 --> 00:07:13,510
and to be quite honest the said state

00:07:11,650 --> 00:07:15,490
park isn't that important you go you can

00:07:13,510 --> 00:07:19,420
also first update it in the component

00:07:15,490 --> 00:07:23,110
and it will work as well yes I usually

00:07:19,420 --> 00:07:25,240
answer with a meme so what can you do

00:07:23,110 --> 00:07:26,980
you can trail the data when it's coming

00:07:25,240 --> 00:07:29,110
you just promise that all in a heart and

00:07:26,980 --> 00:07:32,410
the component be sure to maintain all

00:07:29,110 --> 00:07:34,840
the logic that is appending Vance and

00:07:32,410 --> 00:07:36,550
transforming the promise in a

00:07:34,840 --> 00:07:42,820
higher-order component because we still

00:07:36,550 --> 00:07:49,240
want to separate oh no no okay

00:07:42,820 --> 00:07:53,140
this is the last almost okay second

00:07:49,240 --> 00:07:55,210
class okay hey sugan is inspecting that

00:07:53,140 --> 00:07:58,200
you can merge the data you can transform

00:07:55,210 --> 00:08:02,440
data and all kind of when you

00:07:58,200 --> 00:08:06,120
describe your data encapsulation of a

00:08:02,440 --> 00:08:08,820
promise or a monad and this is a screen

00:08:06,120 --> 00:08:11,820
thank you so much thank y'all Burt

00:08:08,820 --> 00:08:11,820
created

00:08:17,510 --> 00:08:19,570

YouTube URL: https://www.youtube.com/watch?v=ogA0-5_n4G4


