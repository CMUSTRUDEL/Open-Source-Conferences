Title: ReactiveConf 2017: Gabe Scholz - Property-Based Testing for Godly Tests
Publication date: 2017-11-20
Playlist: ReactiveConf 2017
Description: 
	Main stage talk

https://reactiveconf.com/
25th - 27th October 2017, Bratislava, Slovakia
Captions: 
	00:00:02,020 --> 00:00:08,639
[Music]

00:00:14,640 --> 00:00:23,009
thank you for coming my name is Gabe and

00:00:19,890 --> 00:00:25,710
I'm coming from Vancouver Canada

00:00:23,009 --> 00:00:28,680
on github my user name is garbles

00:00:25,710 --> 00:00:29,939
and if you have any questions after this

00:00:28,680 --> 00:00:32,250
talk that you don't get into the slide

00:00:29,939 --> 00:00:35,460
oh you can email me at reactive at Gabe

00:00:32,250 --> 00:00:39,449
pizza I work for a company called

00:00:35,460 --> 00:00:41,940
Unbounce in Vancouver we make marketing

00:00:39,449 --> 00:00:44,489
automation software for people who do

00:00:41,940 --> 00:00:46,110
online marketing and today I'm gonna be

00:00:44,489 --> 00:00:48,600
talking to you about property based

00:00:46,110 --> 00:00:50,940
testing so property based testing is

00:00:48,600 --> 00:00:54,780
something that's quite popular in a lot

00:00:50,940 --> 00:00:58,409
of languages like Haskell Erlang Scala

00:00:54,780 --> 00:00:59,960
not so popular in JavaScript and there

00:00:58,409 --> 00:01:02,940
are good reasons for that

00:00:59,960 --> 00:01:04,500
but I'm gonna talk about how we make it

00:01:02,940 --> 00:01:08,159
work at Unbounce

00:01:04,500 --> 00:01:11,400
and the thing is that it can often be

00:01:08,159 --> 00:01:14,580
much more effective than the typical

00:01:11,400 --> 00:01:16,650
example based unit tests that you're

00:01:14,580 --> 00:01:18,119
used to writing that's why I'm really

00:01:16,650 --> 00:01:18,420
excited to sort of share this with you

00:01:18,119 --> 00:01:20,640
today

00:01:18,420 --> 00:01:24,420
and really I'm only scratching the

00:01:20,640 --> 00:01:27,690
surface of what's possible here so yeah

00:01:24,420 --> 00:01:28,860
let's just dive into it and so I'll sort

00:01:27,690 --> 00:01:31,140
of pause it a question to you like why

00:01:28,860 --> 00:01:33,020
do we write tests there are a lot of

00:01:31,140 --> 00:01:36,690
really good reasons to write tests and

00:01:33,020 --> 00:01:39,000
you know probably you want to reduce

00:01:36,690 --> 00:01:40,680
bugs in your software so when you make a

00:01:39,000 --> 00:01:43,860
change it doesn't cost you a whole bunch

00:01:40,680 --> 00:01:46,260
of money for me personally I get a ton

00:01:43,860 --> 00:01:48,420
of anxiety when I come across a module

00:01:46,260 --> 00:01:50,940
and there are no tests for it like the

00:01:48,420 --> 00:01:51,890
very first thing I do is write tests to

00:01:50,940 --> 00:01:56,730
make sure that I don't break something

00:01:51,890 --> 00:01:58,680
and so kind of a bold claim but most of

00:01:56,730 --> 00:02:01,140
the tests we write or to prevent

00:01:58,680 --> 00:02:03,330
regressions in our software we don't

00:02:01,140 --> 00:02:06,300
write tests to uncover flaws in our

00:02:03,330 --> 00:02:08,789
software and so Dijkstra once said that

00:02:06,300 --> 00:02:11,519
program testing can be a very effective

00:02:08,789 --> 00:02:14,010
way to show the presence of bugs but it

00:02:11,519 --> 00:02:16,440
is hopelessly inadequate for showing

00:02:14,010 --> 00:02:18,060
their absence right it's not like we

00:02:16,440 --> 00:02:20,370
never have bugs in our production

00:02:18,060 --> 00:02:23,340
software like we we get that and people

00:02:20,370 --> 00:02:24,900
report bugs you know maybe customer

00:02:23,340 --> 00:02:27,420
service comes to us and says yeah we got

00:02:24,900 --> 00:02:28,450
this bug we have to fix it so bugs sneak

00:02:27,420 --> 00:02:29,709
into production and

00:02:28,450 --> 00:02:31,810
the reason why bugs sneak into

00:02:29,709 --> 00:02:34,900
production is because we cannot test

00:02:31,810 --> 00:02:36,370
everything right there are limits to the

00:02:34,900 --> 00:02:38,260
level of testing that we're doing that

00:02:36,370 --> 00:02:42,010
causes these bugs to sneak in otherwise

00:02:38,260 --> 00:02:43,690
we would have caught them and so a test

00:02:42,010 --> 00:02:45,580
case is really only as good as the data

00:02:43,690 --> 00:02:48,250
that you're using and when your program

00:02:45,580 --> 00:02:52,360
becomes sufficiently complex the inputs

00:02:48,250 --> 00:02:54,849
become complex and therefore it becomes

00:02:52,360 --> 00:02:57,790
much more difficult to have good data in

00:02:54,849 --> 00:03:00,400
your test so tests prevent regressions

00:02:57,790 --> 00:03:03,280
but tests only prevent regressions that

00:03:00,400 --> 00:03:05,950
you know about right like how can I

00:03:03,280 --> 00:03:10,510
write a test for some flaw in my

00:03:05,950 --> 00:03:11,680
software that I don't know I have and so

00:03:10,510 --> 00:03:13,900
this is what we typically do with

00:03:11,680 --> 00:03:16,180
example based tests so we're gonna start

00:03:13,900 --> 00:03:17,500
with this we're gonna go over to another

00:03:16,180 --> 00:03:19,540
extreme and we're gonna find a nice

00:03:17,500 --> 00:03:22,180
middle ground and this is what we

00:03:19,540 --> 00:03:23,860
usually do so we're gonna start simple

00:03:22,180 --> 00:03:25,930
because I think this sort of gets the

00:03:23,860 --> 00:03:27,940
idea across and then we'll move on to a

00:03:25,930 --> 00:03:29,980
more real-world example but say you have

00:03:27,940 --> 00:03:31,299
a sort function and so this sort

00:03:29,980 --> 00:03:32,530
function is just going to take an array

00:03:31,299 --> 00:03:34,180
of numbers and return an array of

00:03:32,530 --> 00:03:36,100
numbers right and presumably they're

00:03:34,180 --> 00:03:38,170
sorted so we'll write some tests for

00:03:36,100 --> 00:03:41,019
that the first one might be well I

00:03:38,170 --> 00:03:43,389
expect that if I pass in an empty array

00:03:41,019 --> 00:03:46,090
I get back an empty array if I pass in

00:03:43,389 --> 00:03:48,489
the array six to one I get back one to

00:03:46,090 --> 00:03:51,010
six and if I pass in something that's

00:03:48,489 --> 00:03:52,389
already sorted I get back the same thing

00:03:51,010 --> 00:03:55,709
because it doesn't need to be sorted

00:03:52,389 --> 00:03:58,600
again and like these are good right but

00:03:55,709 --> 00:04:00,760
in the end if we think about all of the

00:03:58,600 --> 00:04:02,859
possible data points that we can have

00:04:00,760 --> 00:04:04,540
we're really only picking one out of the

00:04:02,859 --> 00:04:06,069
entire set of everything we're taking

00:04:04,540 --> 00:04:11,380
one data point for each of those

00:04:06,069 --> 00:04:14,170
different cases and so if example these

00:04:11,380 --> 00:04:16,090
testing is on like this extreme then on

00:04:14,170 --> 00:04:19,090
the other extreme we have fuzz testing

00:04:16,090 --> 00:04:21,160
and like the most naive way to define

00:04:19,090 --> 00:04:23,650
this is like say I have a function that

00:04:21,160 --> 00:04:25,450
says give me an array of random numbers

00:04:23,650 --> 00:04:27,639
right I don't care what I get I just

00:04:25,450 --> 00:04:29,650
want an array of random numbers and I'm

00:04:27,639 --> 00:04:32,110
just gonna pass it into my function sort

00:04:29,650 --> 00:04:33,419
and it's not gonna throw that's all I

00:04:32,110 --> 00:04:35,770
care about

00:04:33,419 --> 00:04:37,560
of course this is very naive but the

00:04:35,770 --> 00:04:39,689
thing is that if we ran this test enough

00:04:37,560 --> 00:04:42,869
then the set

00:04:39,689 --> 00:04:44,309
of all possible inputs that we get then

00:04:42,869 --> 00:04:46,319
becomes larger and larger and larger and

00:04:44,309 --> 00:04:49,199
we start to cover this this circle here

00:04:46,319 --> 00:04:51,209
and eventually you'll get to the point

00:04:49,199 --> 00:04:55,379
where you're convinced that this is not

00:04:51,209 --> 00:04:58,110
gonna blow up at least that right so

00:04:55,379 --> 00:05:00,209
wouldn't it be great if we could still

00:04:58,110 --> 00:05:04,110
use that function that array of random

00:05:00,209 --> 00:05:08,579
numbers to generate our inputs and still

00:05:04,110 --> 00:05:09,869
be able to do some check like we expect

00:05:08,579 --> 00:05:11,999
that we sort this and it's equal to

00:05:09,869 --> 00:05:15,569
something but the problem then becomes

00:05:11,999 --> 00:05:17,969
if I don't know what my input is how

00:05:15,569 --> 00:05:19,829
could I know what my output was right I

00:05:17,969 --> 00:05:22,199
when I call this function I'm not gonna

00:05:19,829 --> 00:05:27,209
get back 6 to 1 I'm gonna get back I

00:05:22,199 --> 00:05:30,569
don't know something so I don't know the

00:05:27,209 --> 00:05:32,789
the data ahead of time and so this is

00:05:30,569 --> 00:05:35,579
sort of where we get into property based

00:05:32,789 --> 00:05:39,209
testing and so a property is some

00:05:35,579 --> 00:05:42,839
logical truth about a system under test

00:05:39,209 --> 00:05:47,909
that is going to hold for all inputs of

00:05:42,839 --> 00:05:50,279
a given type so part of the trade-off

00:05:47,909 --> 00:05:51,839
here is that properties themselves as

00:05:50,279 --> 00:05:54,059
we'll see they become a little bit more

00:05:51,839 --> 00:05:57,119
nebulous to define it's not so clear-cut

00:05:54,059 --> 00:05:59,129
as this thing equals this thing it's

00:05:57,119 --> 00:06:00,449
it's a little bit more vague and that's

00:05:59,129 --> 00:06:02,909
because the inputs are not known ahead

00:06:00,449 --> 00:06:04,619
of time so I have to be a little bit

00:06:02,909 --> 00:06:07,050
more vague about my expectations so

00:06:04,619 --> 00:06:09,269
here's some examples say I have an array

00:06:07,050 --> 00:06:14,159
of random numbers if I sort that array

00:06:09,269 --> 00:06:15,779
it doesn't change its length if I have

00:06:14,159 --> 00:06:17,849
an array of random numbers and I sort it

00:06:15,779 --> 00:06:21,599
twice it's the same thing as sorting at

00:06:17,849 --> 00:06:23,849
once and if I have an array of random

00:06:21,599 --> 00:06:27,389
numbers and I sort it then the resulting

00:06:23,849 --> 00:06:29,399
array is going to have numbers going

00:06:27,389 --> 00:06:30,779
upward in value so the first value is

00:06:29,399 --> 00:06:32,519
always going to be less than or equal to

00:06:30,779 --> 00:06:34,319
the next and then the next will be less

00:06:32,519 --> 00:06:36,689
than equal to the one after that and so

00:06:34,319 --> 00:06:39,929
on right that's just what a sorted array

00:06:36,689 --> 00:06:42,589
is and so if we did this enough of

00:06:39,929 --> 00:06:45,089
course we we get this distribution of

00:06:42,589 --> 00:06:46,979
possible inputs and become more and more

00:06:45,089 --> 00:06:51,749
confident that these properties are

00:06:46,979 --> 00:06:52,870
gonna hold and so Jessica Kerr she gives

00:06:51,749 --> 00:06:54,820
a lot of talks on

00:06:52,870 --> 00:06:56,470
property-based testing and she gave on a

00:06:54,820 --> 00:06:58,240
few years ago the Midwest conference and

00:06:56,470 --> 00:07:00,790
she said that example based tests are

00:06:58,240 --> 00:07:03,670
very narrow in their input and broad in

00:07:00,790 --> 00:07:06,580
their expectations so I have that exact

00:07:03,670 --> 00:07:09,460
array six to one and I get back exactly

00:07:06,580 --> 00:07:12,160
one to six so I'm saying just this one

00:07:09,460 --> 00:07:17,230
little sliver of data in and I'm saying

00:07:12,160 --> 00:07:19,240
it has to be exactly this fuzz fuzz

00:07:17,230 --> 00:07:21,640
testing is like the opposite right like

00:07:19,240 --> 00:07:23,620
it could be any input but I have like no

00:07:21,640 --> 00:07:25,720
expectation about what the result is I

00:07:23,620 --> 00:07:27,760
just it just it has to work like that's

00:07:25,720 --> 00:07:29,440
it so property based testing is

00:07:27,760 --> 00:07:31,360
somewhere in the middle where we're very

00:07:29,440 --> 00:07:34,480
broad in our inputs it could be any

00:07:31,360 --> 00:07:35,920
array but we're narrowing our

00:07:34,480 --> 00:07:37,840
expectations so there isn't no

00:07:35,920 --> 00:07:40,540
expectation there's just a smaller

00:07:37,840 --> 00:07:44,470
expectation and so it's sort of this

00:07:40,540 --> 00:07:45,580
cross between examples and fuzz so you

00:07:44,470 --> 00:07:46,990
know I don't care about the input as

00:07:45,580 --> 00:07:50,350
long as it's valid but I still want to

00:07:46,990 --> 00:07:52,570
make assertions and this idea originally

00:07:50,350 --> 00:07:55,060
comes from quick check a library

00:07:52,570 --> 00:07:57,160
originally written in Haskell and so

00:07:55,060 --> 00:07:59,650
there's implementations of this in like

00:07:57,160 --> 00:08:00,850
all mainstream languages you can just

00:07:59,650 --> 00:08:05,380
check it up like Java Script has like

00:08:00,850 --> 00:08:08,470
ten of course and so it goes that given

00:08:05,380 --> 00:08:10,780
some property of a system we should

00:08:08,470 --> 00:08:12,760
attempt to generate sets of inputs that

00:08:10,780 --> 00:08:14,470
would cause that property to fail to

00:08:12,760 --> 00:08:16,300
expose a flaw in our code so it's

00:08:14,470 --> 00:08:19,510
actually generating the test cases for

00:08:16,300 --> 00:08:21,550
us and if it does manage to find some

00:08:19,510 --> 00:08:24,190
failing input what it's going to do is

00:08:21,550 --> 00:08:26,800
it's going to work backwards to locate

00:08:24,190 --> 00:08:28,600
the simplest failing case and this last

00:08:26,800 --> 00:08:30,910
step is actually super super important

00:08:28,600 --> 00:08:33,730
that I'll tell you why let's say for my

00:08:30,910 --> 00:08:35,290
sort function I called my array of

00:08:33,730 --> 00:08:39,100
random numbers function and I got back

00:08:35,290 --> 00:08:40,660
an array with 2,000 values in it and I

00:08:39,100 --> 00:08:43,480
pass that into the sort and it blows up

00:08:40,660 --> 00:08:45,610
and then my test runner comes back to me

00:08:43,480 --> 00:08:48,760
and my test runner says well we blew up

00:08:45,610 --> 00:08:52,000
and here's the array that did that like

00:08:48,760 --> 00:08:53,560
if I look at that I have no idea what

00:08:52,000 --> 00:08:56,260
caused that to fail my only guess is

00:08:53,560 --> 00:08:57,940
that it was too long other than that I'm

00:08:56,260 --> 00:08:59,860
just totally clueless right so we have

00:08:57,940 --> 00:09:02,320
to be able to shrink that down to

00:08:59,860 --> 00:09:04,300
something that shows us a little bit

00:09:02,320 --> 00:09:06,730
more like concrete evidence about what

00:09:04,300 --> 00:09:09,260
is going on and why is that failing

00:09:06,730 --> 00:09:11,990
okay and so I'm gonna be talking about

00:09:09,260 --> 00:09:17,060
I'm gonna include tests check Jas which

00:09:11,990 --> 00:09:19,760
is a transpiled version of test check

00:09:17,060 --> 00:09:22,310
which is a closure core library that's

00:09:19,760 --> 00:09:23,930
been passed through closure scripts and

00:09:22,310 --> 00:09:25,910
then wrapped with like a really nice

00:09:23,930 --> 00:09:28,340
JavaScript wrapper so you can do it sort

00:09:25,910 --> 00:09:30,140
of JavaScript style it's really nice and

00:09:28,340 --> 00:09:32,060
a common theme with all these libraries

00:09:30,140 --> 00:09:35,630
is that there is some deliberate

00:09:32,060 --> 00:09:37,430
randomness here so it may seem that the

00:09:35,630 --> 00:09:38,780
values we're getting back are completely

00:09:37,430 --> 00:09:41,900
random but that's not exactly true

00:09:38,780 --> 00:09:44,180
there's there's a deliberate mechanism

00:09:41,900 --> 00:09:46,190
going on in the background and what I

00:09:44,180 --> 00:09:48,920
mean is that like remember that array of

00:09:46,190 --> 00:09:50,300
random numbers function well it just

00:09:48,920 --> 00:09:52,070
returns an array of random numbers and

00:09:50,300 --> 00:09:53,660
it's a one-off every time so every time

00:09:52,070 --> 00:09:55,700
I call this function you know I could

00:09:53,660 --> 00:09:58,190
call this a thousand times and possibly

00:09:55,700 --> 00:10:02,690
never get an array that is length less

00:09:58,190 --> 00:10:04,730
than 50 so there's no coordination going

00:10:02,690 --> 00:10:05,930
on behind the scenes but with libraries

00:10:04,730 --> 00:10:07,610
like quick check in with test check

00:10:05,930 --> 00:10:12,770
there is there is this deliberate

00:10:07,610 --> 00:10:15,890
randomness it's a search for failure so

00:10:12,770 --> 00:10:19,910
like you might say that depending on the

00:10:15,890 --> 00:10:22,250
context an empty array is a different

00:10:19,910 --> 00:10:23,690
kind of array than an array with one

00:10:22,250 --> 00:10:27,560
value or an array with ten values

00:10:23,690 --> 00:10:29,420
depending on how it's being used or if

00:10:27,560 --> 00:10:31,040
we're talking about people's age then

00:10:29,420 --> 00:10:34,490
the number negative one is definitely

00:10:31,040 --> 00:10:39,350
not a net like a valid value and so we

00:10:34,490 --> 00:10:41,000
need to check for that and and so this

00:10:39,350 --> 00:10:44,030
is accomplished with generators and what

00:10:41,000 --> 00:10:47,270
generators are are just a way for you to

00:10:44,030 --> 00:10:49,820
compose these data structures together

00:10:47,270 --> 00:10:52,280
so that you can represent what random

00:10:49,820 --> 00:10:53,900
value you would like to have so you sort

00:10:52,280 --> 00:10:56,510
of give it the types that you want and

00:10:53,900 --> 00:10:58,900
when you pass it in to the runner it

00:10:56,510 --> 00:11:01,700
will generate random values for you and

00:10:58,900 --> 00:11:04,100
some examples of this would be if I use

00:11:01,700 --> 00:11:06,800
gen string I could be able to generate

00:11:04,100 --> 00:11:08,990
some strings by Jews gen int I could

00:11:06,800 --> 00:11:14,060
generate some mints if I use gen bool

00:11:08,990 --> 00:11:15,590
you get it and then we can compose these

00:11:14,060 --> 00:11:17,540
things together like I said so I could

00:11:15,590 --> 00:11:19,910
call gen dot object and so that allows

00:11:17,540 --> 00:11:23,240
me to generate generators for objects

00:11:19,910 --> 00:11:25,910
so now I have the name key and the H key

00:11:23,240 --> 00:11:29,510
and so I just would generate objects for

00:11:25,910 --> 00:11:30,560
me that are people I guess for a sort

00:11:29,510 --> 00:11:33,590
function we could use something like

00:11:30,560 --> 00:11:35,270
this where we say I want a array of

00:11:33,590 --> 00:11:36,560
integers right and then if I use this

00:11:35,270 --> 00:11:38,720
with my runner it would give me back an

00:11:36,560 --> 00:11:39,950
array of integers every time and then

00:11:38,720 --> 00:11:43,220
you can compose things that are already

00:11:39,950 --> 00:11:46,220
composed etc so a sample of what this

00:11:43,220 --> 00:11:47,900
would look like so if I took that array

00:11:46,220 --> 00:11:52,960
of integers I would get back something

00:11:47,900 --> 00:11:55,700
like this just randomly random stuff and

00:11:52,960 --> 00:11:57,470
if I tried my person generator I get

00:11:55,700 --> 00:11:58,670
back something like this it's kind of

00:11:57,470 --> 00:11:59,960
all over the place you actually notice

00:11:58,670 --> 00:12:05,840
the first thing it tries is an empty

00:11:59,960 --> 00:12:08,570
string at 0 and so this is it's it's

00:12:05,840 --> 00:12:09,980
pretty easy to integrate with with your

00:12:08,570 --> 00:12:11,390
favorite test frameworks there's like an

00:12:09,980 --> 00:12:13,790
integration for all of them with gest

00:12:11,390 --> 00:12:16,520
which is what i use there's a library

00:12:13,790 --> 00:12:17,990
called jasmine checked so you just do a

00:12:16,520 --> 00:12:19,940
quick install step and then you're good

00:12:17,990 --> 00:12:21,800
to go so your tests can go from

00:12:19,940 --> 00:12:24,460
something like this where we have that

00:12:21,800 --> 00:12:28,190
array of random numbers function to this

00:12:24,460 --> 00:12:30,980
where we now have a function check it

00:12:28,190 --> 00:12:32,720
instead of just it and we also pass

00:12:30,980 --> 00:12:34,970
extra arguments which are our generators

00:12:32,720 --> 00:12:36,590
and then those generators resolve to

00:12:34,970 --> 00:12:38,630
values that get passed into that

00:12:36,590 --> 00:12:40,250
function so we see that are there which

00:12:38,630 --> 00:12:41,870
is the array that gets generated and

00:12:40,250 --> 00:12:44,450
this will run several times so by

00:12:41,870 --> 00:12:45,440
default I think it's 20 you can set it

00:12:44,450 --> 00:12:49,100
to whatever you want you could set it to

00:12:45,440 --> 00:12:50,330
2,000 if you like you know so we could

00:12:49,100 --> 00:12:53,330
do this for all of our tests for our

00:12:50,330 --> 00:12:54,830
sort function and so because I have

00:12:53,330 --> 00:13:00,020
three tests here it would generate sixty

00:12:54,830 --> 00:13:02,960
tests by default and if I run this I get

00:13:00,020 --> 00:13:03,350
a failing spec and you see that what it

00:13:02,960 --> 00:13:08,540
says

00:13:03,350 --> 00:13:10,280
so I deliberately like I don purpose so

00:13:08,540 --> 00:13:12,380
you can see there right there that the

00:13:10,280 --> 00:13:14,420
case that caused it to fail was negative

00:13:12,380 --> 00:13:19,760
7 negative 7 and it doesn't keep the

00:13:14,420 --> 00:13:21,710
same length if I run this again then I'm

00:13:19,760 --> 00:13:23,960
gonna get the same thing like it fails

00:13:21,710 --> 00:13:28,220
now it tells me that my failing case was

00:13:23,960 --> 00:13:30,610
1 1 and if I run it one more time I get

00:13:28,220 --> 00:13:30,610
it again

00:13:30,840 --> 00:13:35,730
and it's negative four negative four and

00:13:33,660 --> 00:13:36,870
I guarantee you that it didn't just come

00:13:35,730 --> 00:13:38,790
up with this valley it wasn't just like

00:13:36,870 --> 00:13:40,980
negative four day before try that out it

00:13:38,790 --> 00:13:43,470
managed to generate a bigger array and

00:13:40,980 --> 00:13:45,540
it saw that there were two values that

00:13:43,470 --> 00:13:47,100
were the same number and that caused it

00:13:45,540 --> 00:13:50,280
to fail so then it worked backward from

00:13:47,100 --> 00:13:51,660
that to figure out what was wrong and I

00:13:50,280 --> 00:13:54,330
alluded to this before this is called

00:13:51,660 --> 00:13:57,480
shrinking and so this is sort of the raw

00:13:54,330 --> 00:13:59,760
output that test track gives you so you

00:13:57,480 --> 00:14:01,530
see that it actually failed with an

00:13:59,760 --> 00:14:03,630
entry with five elements in it and it

00:14:01,530 --> 00:14:06,930
worked backward to one with two and this

00:14:03,630 --> 00:14:08,550
is like super useful right I hope you

00:14:06,930 --> 00:14:12,840
can appreciate how useful this is like

00:14:08,550 --> 00:14:14,550
this is a silly example but specifically

00:14:12,840 --> 00:14:17,100
because I don't have to say anything

00:14:14,550 --> 00:14:19,350
about the input but I don't have to

00:14:17,100 --> 00:14:21,420
generate those test cases the framework

00:14:19,350 --> 00:14:25,920
does that for me I just say that these

00:14:21,420 --> 00:14:29,730
are some truths about the outcome right

00:14:25,920 --> 00:14:31,530
so it generates the test cases and you

00:14:29,730 --> 00:14:33,390
know like oh yeah I just say that this

00:14:31,530 --> 00:14:36,420
property should hold for all inputs of

00:14:33,390 --> 00:14:38,070
this type and when you do this it's

00:14:36,420 --> 00:14:40,070
actually like it's shocking you you

00:14:38,070 --> 00:14:42,600
start to uncover bugs in your code

00:14:40,070 --> 00:14:46,140
because again when the inputs become

00:14:42,600 --> 00:14:49,410
sufficiently complex you you start to

00:14:46,140 --> 00:14:51,600
generate data that is something that you

00:14:49,410 --> 00:14:54,360
could never even think of right imagine

00:14:51,600 --> 00:14:56,310
generating imagine having 200 unit tests

00:14:54,360 --> 00:14:57,930
for a single function right we're just

00:14:56,310 --> 00:15:01,440
not gonna do that that's a nightmare to

00:14:57,930 --> 00:15:03,660
maintain it's too much work but of

00:15:01,440 --> 00:15:05,160
course like like where does this fall

00:15:03,660 --> 00:15:08,190
apart in JavaScript why isn't this more

00:15:05,160 --> 00:15:11,880
popular and the answer is that this

00:15:08,190 --> 00:15:15,930
falls apart in real life so when you try

00:15:11,880 --> 00:15:17,550
to use this outside of a toy app this

00:15:15,930 --> 00:15:20,820
completely falls apart and I'll show you

00:15:17,550 --> 00:15:23,250
why so I'm gonna use a little bit of

00:15:20,820 --> 00:15:24,840
like flow type declarations here but say

00:15:23,250 --> 00:15:26,880
you have that same thing that we talked

00:15:24,840 --> 00:15:28,830
about before a person where you have the

00:15:26,880 --> 00:15:30,600
name which is a string and the age which

00:15:28,830 --> 00:15:32,670
is a number if you had a function safe

00:15:30,600 --> 00:15:34,770
person I can easily generate input for

00:15:32,670 --> 00:15:36,600
this right my person is very simple and

00:15:34,770 --> 00:15:39,750
we've already seen this I generate my

00:15:36,600 --> 00:15:41,190
person like that and then I'll generate

00:15:39,750 --> 00:15:44,250
values and

00:15:41,190 --> 00:15:46,800
do my property thing but what if you

00:15:44,250 --> 00:15:49,800
have something like this this this is

00:15:46,800 --> 00:15:52,800
the like this is the God object for a

00:15:49,800 --> 00:15:54,150
project that I used to work on and it's

00:15:52,800 --> 00:15:56,600
huge and there's a lot of fields here

00:15:54,150 --> 00:15:59,220
and I'll just highlight a few too to

00:15:56,600 --> 00:16:02,070
show you some of the complexity this has

00:15:59,220 --> 00:16:03,810
actually been version 10 times so

00:16:02,070 --> 00:16:07,800
there's a hard-coded schema version in

00:16:03,810 --> 00:16:09,030
this type definition and and so that we

00:16:07,800 --> 00:16:11,550
do this because like we deprecated

00:16:09,030 --> 00:16:13,320
fields or we change the name or you know

00:16:11,550 --> 00:16:14,970
sometimes the subtype changes or

00:16:13,320 --> 00:16:16,080
something like that and we and so we we

00:16:14,970 --> 00:16:18,090
want to make sure that we know exactly

00:16:16,080 --> 00:16:20,760
what version of this type we're getting

00:16:18,090 --> 00:16:24,480
and then if we look at like some of

00:16:20,760 --> 00:16:27,240
these subtypes the trigger like is also

00:16:24,480 --> 00:16:28,950
non-trivial the trigger is just like

00:16:27,240 --> 00:16:30,720
this mish-mosh of stuff and it's

00:16:28,950 --> 00:16:33,060
actually a tagged Union and what a

00:16:30,720 --> 00:16:35,940
tagged Union is is it's a list of

00:16:33,060 --> 00:16:38,400
possible shapes that this trigger could

00:16:35,940 --> 00:16:40,470
have but it can only be one of them at a

00:16:38,400 --> 00:16:42,570
time so it can only ever be an exit

00:16:40,470 --> 00:16:49,410
trigger or a welcome trigger and so on

00:16:42,570 --> 00:16:51,570
and then in addition to that we have

00:16:49,410 --> 00:16:54,660
this type called any activation rule and

00:16:51,570 --> 00:16:57,600
so any activation rule is the tag union

00:16:54,660 --> 00:17:01,110
of all of the title all of the versions

00:16:57,600 --> 00:17:02,850
of the activation rule and for reasons

00:17:01,110 --> 00:17:05,250
that I won't get into like we have to

00:17:02,850 --> 00:17:08,069
when the user saves their activation

00:17:05,250 --> 00:17:12,360
rule we may not be saving the latest one

00:17:08,069 --> 00:17:14,040
and that's just because of how they're

00:17:12,360 --> 00:17:16,800
stored and how we have to access them

00:17:14,040 --> 00:17:18,569
and if you're totally confused at this

00:17:16,800 --> 00:17:20,160
point like that's perfect that's exactly

00:17:18,569 --> 00:17:22,290
what I'm going for I want you to be

00:17:20,160 --> 00:17:24,360
confused because this is what happens in

00:17:22,290 --> 00:17:25,829
real life right this is what happens we

00:17:24,360 --> 00:17:28,140
have a high degree of complexity and

00:17:25,829 --> 00:17:30,480
this these programs grow organically and

00:17:28,140 --> 00:17:33,090
our requirements change organically we

00:17:30,480 --> 00:17:35,970
end up in situations like this so as a

00:17:33,090 --> 00:17:37,440
team we protect ourselves from this by

00:17:35,970 --> 00:17:39,870
having a function called upgrade

00:17:37,440 --> 00:17:41,850
activation rule and so what upgrade

00:17:39,870 --> 00:17:43,710
activation rule does is it takes a

00:17:41,850 --> 00:17:46,290
version number the version that the

00:17:43,710 --> 00:17:48,210
program consuming this needs and it

00:17:46,290 --> 00:17:49,530
takes an activation rule and it upgrades

00:17:48,210 --> 00:17:51,930
it to whatever that version is or

00:17:49,530 --> 00:17:55,669
downgrades it because it may not

00:17:51,930 --> 00:17:57,809
actually need the latest version

00:17:55,669 --> 00:17:59,580
and we do this at the boundary of our

00:17:57,809 --> 00:18:00,899
program so that the rest of the program

00:17:59,580 --> 00:18:05,669
can just assume that there's one type of

00:18:00,899 --> 00:18:07,139
activation rule and so well okay if we

00:18:05,669 --> 00:18:09,899
write a test for this we have it we do

00:18:07,139 --> 00:18:11,820
have a property and it's that this needs

00:18:09,899 --> 00:18:13,799
to be backwards compatible so if I

00:18:11,820 --> 00:18:16,889
generate a random activation rule with a

00:18:13,799 --> 00:18:18,539
random version and I upgrade the

00:18:16,889 --> 00:18:20,759
activation rule all the way to the max

00:18:18,539 --> 00:18:25,259
version the latest one and I downgrade

00:18:20,759 --> 00:18:27,259
it back then the upgraded downgraded one

00:18:25,259 --> 00:18:30,210
is the exact same as the original one

00:18:27,259 --> 00:18:31,860
and this is like this is a perfect

00:18:30,210 --> 00:18:35,250
candidate for this property based

00:18:31,860 --> 00:18:36,840
testing okay so why don't we create a

00:18:35,250 --> 00:18:39,120
generator for our activation rules since

00:18:36,840 --> 00:18:41,549
that's how you do it okay well it's an

00:18:39,120 --> 00:18:44,519
object and you have some you know

00:18:41,549 --> 00:18:46,259
trivial fields and then you try to

00:18:44,519 --> 00:18:48,840
create the generator for the trigger

00:18:46,259 --> 00:18:51,629
type and you're just in over your head

00:18:48,840 --> 00:18:55,710
immediately so the generator is one of

00:18:51,629 --> 00:18:57,990
this object or another object or another

00:18:55,710 --> 00:19:01,159
object and it very quickly gets out of

00:18:57,990 --> 00:19:04,320
hand however this is sort of necessary

00:19:01,159 --> 00:19:07,019
right because these things like if we

00:19:04,320 --> 00:19:08,580
want to find edge cases in this code we

00:19:07,019 --> 00:19:09,840
need to have these sorts of mechanisms

00:19:08,580 --> 00:19:11,669
in place that we have to use this

00:19:09,840 --> 00:19:14,269
otherwise we're gonna get bugs and we

00:19:11,669 --> 00:19:17,490
cannot have bugs in this piece of code

00:19:14,269 --> 00:19:18,990
so it's awful to maintain and the reason

00:19:17,490 --> 00:19:20,519
why it's awful to maintain is that of

00:19:18,990 --> 00:19:22,379
course the generators are not synched

00:19:20,519 --> 00:19:24,480
with our type definitions like I already

00:19:22,379 --> 00:19:27,269
know what my types are and my program is

00:19:24,480 --> 00:19:28,679
consuming those types with flow but I

00:19:27,269 --> 00:19:32,460
don't want to have to define them in two

00:19:28,679 --> 00:19:34,799
different places so to get around this

00:19:32,460 --> 00:19:37,529
what we did was we created a babel

00:19:34,799 --> 00:19:40,110
transform called Babel plug and

00:19:37,529 --> 00:19:41,940
transform flow to gen and this is open

00:19:40,110 --> 00:19:45,480
source and you can go and look at this

00:19:41,940 --> 00:19:47,909
if you want it does what we want so like

00:19:45,480 --> 00:19:51,149
if you have issues with it I probably

00:19:47,909 --> 00:19:52,769
will not merge your pull request but

00:19:51,149 --> 00:19:54,419
it's really easy integrate you just add

00:19:52,769 --> 00:19:57,059
it to your test plugins before you strip

00:19:54,419 --> 00:19:58,440
your flow types and then what what it

00:19:57,059 --> 00:20:01,889
does is exactly what it says it

00:19:58,440 --> 00:20:04,679
transforms your flow type definitions to

00:20:01,889 --> 00:20:06,960
generators and so you get this object

00:20:04,679 --> 00:20:08,460
and you just call to gen on it and then

00:20:06,960 --> 00:20:12,810
it creates a generator from what

00:20:08,460 --> 00:20:14,550
your type definition and so that

00:20:12,810 --> 00:20:17,750
previous property that we had becomes

00:20:14,550 --> 00:20:20,130
this where we're now just passing in

00:20:17,750 --> 00:20:22,230
activation rule to Jen any activation

00:20:20,130 --> 00:20:24,420
rule to Jen and then we're using that in

00:20:22,230 --> 00:20:26,150
the function and again it's runs like 20

00:20:24,420 --> 00:20:28,620
times I think actually we have this run

00:20:26,150 --> 00:20:29,910
several hundred times just to just to be

00:20:28,620 --> 00:20:34,500
sure every time we make a change to this

00:20:29,910 --> 00:20:36,450
code so you know when I did this for the

00:20:34,500 --> 00:20:39,840
first time when we when we initially

00:20:36,450 --> 00:20:43,140
integrated the babel transform with our

00:20:39,840 --> 00:20:46,980
test suite i found so many issues like i

00:20:43,140 --> 00:20:49,140
spent days fixing our code because there

00:20:46,980 --> 00:20:52,110
were so many issues and actually a lot

00:20:49,140 --> 00:20:55,110
of them were generated from type

00:20:52,110 --> 00:20:56,910
definitions that were just too loose so

00:20:55,110 --> 00:21:00,270
we did not real like we just assumed

00:20:56,910 --> 00:21:02,520
that a type was a certain way and that

00:21:00,270 --> 00:21:05,820
we would never use it in an incorrect

00:21:02,520 --> 00:21:07,550
way but the generator doesn't really

00:21:05,820 --> 00:21:10,830
care about that

00:21:07,550 --> 00:21:13,140
so some outcomes here generating

00:21:10,830 --> 00:21:14,670
generators generate success so the only

00:21:13,140 --> 00:21:17,250
reason that we continue to use property

00:21:14,670 --> 00:21:20,400
based testing right now on this these

00:21:17,250 --> 00:21:22,140
projects is because of this ability to

00:21:20,400 --> 00:21:25,290
generate generators from our type

00:21:22,140 --> 00:21:27,060
definitions so previously tests and

00:21:25,290 --> 00:21:30,690
typing these were two different

00:21:27,060 --> 00:21:32,580
validation processes and this sort of

00:21:30,690 --> 00:21:36,390
like marries them together so now the

00:21:32,580 --> 00:21:37,980
two sets of expectations are the same so

00:21:36,390 --> 00:21:39,810
you know before you could fail the

00:21:37,980 --> 00:21:41,430
typing but then the test would pass or

00:21:39,810 --> 00:21:43,110
you could fail the test

00:21:41,430 --> 00:21:45,240
but then the typing would pass like it's

00:21:43,110 --> 00:21:46,920
super annoying and not only that like

00:21:45,240 --> 00:21:49,550
you you're not even sure if your

00:21:46,920 --> 00:21:53,010
generators are generating like the total

00:21:49,550 --> 00:21:55,100
gambit of like possible valid values

00:21:53,010 --> 00:21:57,870
that could be passed into this function

00:21:55,100 --> 00:21:59,970
the second is that it like I said it

00:21:57,870 --> 00:22:01,470
locks down your type definitions so

00:21:59,970 --> 00:22:04,380
sometimes we were too permissive and

00:22:01,470 --> 00:22:07,620
like it would generate things that we

00:22:04,380 --> 00:22:10,470
like colloquially would never expect we

00:22:07,620 --> 00:22:12,930
just never expect these values and like

00:22:10,470 --> 00:22:14,250
a quick example of something that

00:22:12,930 --> 00:22:16,980
occurred it's like say you have some

00:22:14,250 --> 00:22:18,440
function and some function accepts an

00:22:16,980 --> 00:22:20,970
array of strings but it is knowledge

00:22:18,440 --> 00:22:22,210
amongst the developers that this is

00:22:20,970 --> 00:22:24,850
always an

00:22:22,210 --> 00:22:26,740
with three values in it every time for

00:22:24,850 --> 00:22:30,520
whatever reason right these sorts of

00:22:26,740 --> 00:22:32,280
things happen and if we were to run if

00:22:30,520 --> 00:22:34,570
we were to take this type and then run

00:22:32,280 --> 00:22:35,440
create turn it into a generator and run

00:22:34,570 --> 00:22:37,960
it through like it would immediately

00:22:35,440 --> 00:22:39,400
fail like almost immediately the first

00:22:37,960 --> 00:22:43,570
thing it's gonna try is an empty array

00:22:39,400 --> 00:22:45,610
and it would break so you need to change

00:22:43,570 --> 00:22:48,220
it to something like this it has to be

00:22:45,610 --> 00:22:51,010
three strings right and and this is much

00:22:48,220 --> 00:22:54,670
tighter now that knowledge is no longer

00:22:51,010 --> 00:22:56,050
codified in up here it's now directly in

00:22:54,670 --> 00:22:58,120
the code and it forces you to be much

00:22:56,050 --> 00:22:59,950
more explicit and so this tightens up

00:22:58,120 --> 00:23:03,340
your your types which sort of tightens

00:22:59,950 --> 00:23:05,140
up your API the next is is fuzz testing

00:23:03,340 --> 00:23:07,000
so I talked about fuzz testing at the

00:23:05,140 --> 00:23:08,880
beginning but this lets you do it like

00:23:07,000 --> 00:23:11,800
super easy

00:23:08,880 --> 00:23:15,610
say for example you know I'm using react

00:23:11,800 --> 00:23:18,700
and redux I could generate a random

00:23:15,610 --> 00:23:21,550
initial state and then generate a list

00:23:18,700 --> 00:23:25,180
of possible actions and then just say

00:23:21,550 --> 00:23:27,040
well create my store mount my UI using

00:23:25,180 --> 00:23:29,590
that store and then just dispatch all of

00:23:27,040 --> 00:23:35,230
those actions and see if I get an error

00:23:29,590 --> 00:23:37,240
right and so then also to make this

00:23:35,230 --> 00:23:39,040
easier what we did was we added a static

00:23:37,240 --> 00:23:41,020
member to all of the functions in your

00:23:39,040 --> 00:23:42,910
program only in the test suite called

00:23:41,020 --> 00:23:46,000
2gn and so if you've called that what

00:23:42,910 --> 00:23:47,770
you get back is the arguments array for

00:23:46,000 --> 00:23:49,900
the function so long as all the inputs

00:23:47,770 --> 00:23:51,640
are typed so in this case here you just

00:23:49,900 --> 00:23:55,270
get back an array of numbers but it can

00:23:51,640 --> 00:23:58,630
be anything okay so some things that

00:23:55,270 --> 00:24:00,550
suck you can't type check your tests

00:23:58,630 --> 00:24:02,260
anymore if you care about that that's

00:24:00,550 --> 00:24:05,380
like you've gone out the window because

00:24:02,260 --> 00:24:07,150
now you're using types as values and if

00:24:05,380 --> 00:24:08,920
you want a flow type you're like float

00:24:07,150 --> 00:24:11,740
check your tests like it's just gonna

00:24:08,920 --> 00:24:13,210
barf on you so you can't do that people

00:24:11,740 --> 00:24:13,750
who come to the team have to know that

00:24:13,210 --> 00:24:16,210
you're doing this

00:24:13,750 --> 00:24:18,280
of course it like this is a hack this is

00:24:16,210 --> 00:24:20,890
a way that we can achieve property based

00:24:18,280 --> 00:24:21,790
testing with a very little effort but of

00:24:20,890 --> 00:24:24,970
course there are hacks because

00:24:21,790 --> 00:24:29,430
JavaScript isn't made for this it's very

00:24:24,970 --> 00:24:31,810
very slow so you know we run this

00:24:29,430 --> 00:24:33,160
property for our upgrade activation role

00:24:31,810 --> 00:24:35,919
function and it takes something like 20

00:24:33,160 --> 00:24:37,870
seconds if you're doing TDD

00:24:35,919 --> 00:24:38,980
you're you're not gonna get very quick

00:24:37,870 --> 00:24:41,590
feedback that you're expecting

00:24:38,980 --> 00:24:43,720
especially if it fails if it fails and

00:24:41,590 --> 00:24:46,480
then it's trying to like work backward

00:24:43,720 --> 00:24:48,760
to figure out what what is the minimum

00:24:46,480 --> 00:24:51,820
failing case it's gonna have a it's

00:24:48,760 --> 00:24:53,890
gonna take a long time and this is not

00:24:51,820 --> 00:24:55,659
some sort of silver bullet this you

00:24:53,890 --> 00:24:57,370
still need to use this with proper unit

00:24:55,659 --> 00:24:59,650
tests right to make sure that your

00:24:57,370 --> 00:25:04,510
program works as you expect it with very

00:24:59,650 --> 00:25:09,700
specific inputs but it can uncover a lot

00:25:04,510 --> 00:25:12,610
of bugs for you like I said so uh you

00:25:09,700 --> 00:25:15,130
know recently typescript and flow have

00:25:12,610 --> 00:25:16,870
made it so that it is now possible for

00:25:15,130 --> 00:25:18,610
you to ensure that your generators are

00:25:16,870 --> 00:25:19,900
giving you back the proper types so

00:25:18,610 --> 00:25:22,539
perhaps you don't need this

00:25:19,900 --> 00:25:24,789
typescript calls them mapped types in

00:25:22,539 --> 00:25:27,669
flow I think you gotta use those weird

00:25:24,789 --> 00:25:29,710
undocumented like probably Dec

00:25:27,669 --> 00:25:34,210
deprecated super-secret types that they

00:25:29,710 --> 00:25:35,440
have so but but you can get around this

00:25:34,210 --> 00:25:38,919
you don't need this but it's still kind

00:25:35,440 --> 00:25:40,630
of a pain to maintain so the conclusion

00:25:38,919 --> 00:25:42,490
the point that I want you to take away

00:25:40,630 --> 00:25:44,980
is that property based testing finds

00:25:42,490 --> 00:25:46,830
flaws in your code for you because the

00:25:44,980 --> 00:25:49,480
computer comes up with the test cases

00:25:46,830 --> 00:25:53,320
and it doesn't much faster than you can

00:25:49,480 --> 00:25:55,270
and so I in the next year I think we can

00:25:53,320 --> 00:25:57,419
really do a lot of work to make this

00:25:55,270 --> 00:26:00,419
sort of thing easy to do in JavaScript

00:25:57,419 --> 00:26:00,419
Thanks

00:26:04,479 --> 00:26:08,739
thank you very much

00:26:05,869 --> 00:26:11,359
now let's have a look at the questions

00:26:08,739 --> 00:26:16,279
so the first one is can you share your

00:26:11,359 --> 00:26:21,320
views on a test first or TDD okay it's

00:26:16,279 --> 00:26:24,799
good I don't know I I don't do it often

00:26:21,320 --> 00:26:26,719
i I I look at like unit tests or

00:26:24,799 --> 00:26:29,239
integration tests as a form of like

00:26:26,719 --> 00:26:30,769
preventing me from creating issues or

00:26:29,239 --> 00:26:33,379
the next person from creating issues in

00:26:30,769 --> 00:26:35,089
the future so I don't often do TDD and I

00:26:33,379 --> 00:26:37,789
find that it can get in the way if

00:26:35,089 --> 00:26:39,109
you're trying to design something what

00:26:37,789 --> 00:26:41,539
do you think about putting logic into

00:26:39,109 --> 00:26:45,589
the test who tests the code of the test

00:26:41,539 --> 00:26:50,210
I have no thoughts on that I don't even

00:26:45,589 --> 00:26:52,070
know to say ok as you period your idea

00:26:50,210 --> 00:26:53,690
how long it takes with your test where

00:26:52,070 --> 00:26:55,190
it's kept to keep this one do you

00:26:53,690 --> 00:27:00,259
consider a good idea to read logic

00:26:55,190 --> 00:27:03,200
inside tests how does it work with just

00:27:00,259 --> 00:27:06,049
component snapshot yeah ok that's a good

00:27:03,200 --> 00:27:07,609
question um so what you can do if you

00:27:06,049 --> 00:27:09,409
really want to use snapshots what you

00:27:07,609 --> 00:27:11,749
can do is one of the options that you

00:27:09,409 --> 00:27:14,029
can pass to the runner on a per like

00:27:11,749 --> 00:27:15,859
check-it basis is that you can give it

00:27:14,029 --> 00:27:17,450
the random seed that it uses so usually

00:27:15,859 --> 00:27:19,879
it generates a random seed and then it

00:27:17,450 --> 00:27:22,460
bases the inputs off of that random seed

00:27:19,879 --> 00:27:24,830
so I guess you could set the seed and

00:27:22,460 --> 00:27:28,820
then that means that the generated

00:27:24,830 --> 00:27:31,460
values will always be the same so if you

00:27:28,820 --> 00:27:33,109
do that then you can just snapshot

00:27:31,460 --> 00:27:36,169
everything but I found that as soon as

00:27:33,109 --> 00:27:40,489
you change the generator your entire

00:27:36,169 --> 00:27:42,049
like it's it gets very loud and what is

00:27:40,489 --> 00:27:45,679
the difference between this and faker J

00:27:42,049 --> 00:27:48,919
is so faker like faker just gives you

00:27:45,679 --> 00:27:50,899
nice to look at values right like this

00:27:48,919 --> 00:27:53,479
is this is like literally generating

00:27:50,899 --> 00:27:55,070
garbage garbage values it even it'll

00:27:53,479 --> 00:27:58,129
even use special characters in a lot of

00:27:55,070 --> 00:28:01,039
cases to try and fool you know whatever

00:27:58,129 --> 00:28:04,099
logic you have faker is just about you

00:28:01,039 --> 00:28:05,629
know I I want a a nice name so generate

00:28:04,099 --> 00:28:08,919
me a nice-looking name it's never gonna

00:28:05,629 --> 00:28:11,929
give you or perhaps perhaps it does but

00:28:08,919 --> 00:28:14,389
like deliberately going for like empty

00:28:11,929 --> 00:28:15,650
values it's more about like generating

00:28:14,389 --> 00:28:18,260
nice fake data

00:28:15,650 --> 00:28:22,430
and can random data make it difficult to

00:28:18,260 --> 00:28:24,680
reproduce a test fail uh no because

00:28:22,430 --> 00:28:28,370
you're told what the failing output is

00:28:24,680 --> 00:28:31,820
so then you can just rerun the test okay

00:28:28,370 --> 00:28:33,680
time for two more questions so you you

00:28:31,820 --> 00:28:35,210
think it would make sense to provide /

00:28:33,680 --> 00:28:40,940
integrate real data phone numbers

00:28:35,210 --> 00:28:43,010
country names etc if you absolutely have

00:28:40,940 --> 00:28:45,170
to yeah but you could generate all that

00:28:43,010 --> 00:28:48,050
information as well okay the last

00:28:45,170 --> 00:28:53,929
question is do you have typescript

00:28:48,050 --> 00:28:55,490
support no it's it's so I a long time

00:28:53,929 --> 00:28:57,590
ago stopped working on this because we

00:28:55,490 --> 00:29:02,110
actually switched we're switching all of

00:28:57,590 --> 00:29:07,370
our JavaScript to typescript and so the

00:29:02,110 --> 00:29:09,710
the plug-in is basically dead it would

00:29:07,370 --> 00:29:12,380
be nice to use it with with typescript

00:29:09,710 --> 00:29:14,179
I think cogeneration is probably the way

00:29:12,380 --> 00:29:17,170
that will go if I had to re-implement it

00:29:14,179 --> 00:29:19,370
I do a like cogeneration instead of a

00:29:17,170 --> 00:29:21,679
transform because the transform kind of

00:29:19,370 --> 00:29:23,240
gets in the way with cogeneration you

00:29:21,679 --> 00:29:25,850
can just generate some files and then

00:29:23,240 --> 00:29:28,400
require them like that so that's how I

00:29:25,850 --> 00:29:30,110
will probably do it if I really meant

00:29:28,400 --> 00:29:33,380
this for typescript and the last

00:29:30,110 --> 00:29:36,290
question a bonus one where to look to

00:29:33,380 --> 00:29:38,960
get started with this you could email me

00:29:36,290 --> 00:29:41,990
or you could go look at the readme I

00:29:38,960 --> 00:29:45,410
think it does a decent job of sort of

00:29:41,990 --> 00:29:46,760
explaining how it works but yeah come

00:29:45,410 --> 00:29:50,330
find me I feel like I'm not hard to find

00:29:46,760 --> 00:29:54,640
more in the Internet sure so great games

00:29:50,330 --> 00:29:54,640
thank you so much yeah awesome thank you

00:30:00,550 --> 00:30:02,610

YouTube URL: https://www.youtube.com/watch?v=lfoRs9leE2A


