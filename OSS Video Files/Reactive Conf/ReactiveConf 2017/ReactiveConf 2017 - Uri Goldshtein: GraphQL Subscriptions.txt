Title: ReactiveConf 2017 - Uri Goldshtein: GraphQL Subscriptions
Publication date: 2017-11-20
Playlist: ReactiveConf 2017
Description: 
	Main stage talk
https://reactiveconf.com/
25th - 27th October 2017, Bratislava, Slovakia314282

Uri Goldshtein (https://github.com/urigo), a member of the team that added GraphQL Subscriptions into the official spec, gives a complete overview of GraphQL Subscriptions, how to use it today in production and how the future looks like with Live Queries (including working examples).

Here are the links to the examples:
- All examples: https://github.com/urigo 
- GraphQL Server with both Subscriptions and Live Queries with RxJS: https://github.com/Urigo/WhatsApp-Server-GraphQL-Live-RxJS-Meteor 
- Angular Frontend with GraphQL that is connected to the sever: https://github.com/Urigo/WhatsApp-Clone-GraphQL-Angular-Material/tree/1.0 
- GraphQL Codegen library: https://github.com/dotansimha/graphql-code-generator/

You can watch Uri's Lightning talk on ReactiveConf 2017 here: https://youtu.be/CN_bTBP9spM
Captions: 
	00:00:02,040 --> 00:00:08,639
[Music]

00:00:14,660 --> 00:00:21,650
my name is Louie and a few in the last

00:00:18,980 --> 00:00:24,200
few months I've been part of a team like

00:00:21,650 --> 00:00:26,110
a joint team between Facebook and Apollo

00:00:24,200 --> 00:00:29,689
and other people from the community

00:00:26,110 --> 00:00:32,150
where we basically build together the

00:00:29,689 --> 00:00:35,140
spec for graphical subscriptions it's

00:00:32,150 --> 00:00:37,580
the new version of the graphical spec

00:00:35,140 --> 00:00:40,550
and today I'm going to talk a bit about

00:00:37,580 --> 00:00:43,640
it and how you can use it today and also

00:00:40,550 --> 00:00:45,650
how you can like use more stuff that are

00:00:43,640 --> 00:00:50,210
maybe not in the spec right now and use

00:00:45,650 --> 00:00:51,680
it already in your apps today so so yeah

00:00:50,210 --> 00:00:53,780
so a few months ago we started working

00:00:51,680 --> 00:00:56,390
on the graphical spec for graphical

00:00:53,780 --> 00:00:59,000
subscriptions it was the first time that

00:00:56,390 --> 00:01:00,920
graphic yo subscriptions added a spec

00:00:59,000 --> 00:01:03,440
with a collaboration from outside

00:01:00,920 --> 00:01:05,390
Facebook and it was a really really

00:01:03,440 --> 00:01:09,560
interesting process we set a lot and

00:01:05,390 --> 00:01:11,240
thought about what to add and what our

00:01:09,560 --> 00:01:14,600
graphical subscriptions but also what is

00:01:11,240 --> 00:01:17,360
not graphic your subscriptions and at

00:01:14,600 --> 00:01:20,450
the end we ended up here which is Rob

00:01:17,360 --> 00:01:22,610
Zhu from Facebook DDP are including

00:01:20,450 --> 00:01:24,680
graphical subscriptions

00:01:22,610 --> 00:01:29,079
into the graphical official Garfield

00:01:24,680 --> 00:01:31,250
spec an IP are the graphical GS official

00:01:29,079 --> 00:01:35,540
reference implementation to add

00:01:31,250 --> 00:01:38,869
subscriptions into that and then on may

00:01:35,540 --> 00:01:40,880
on a graphical Europe we announce that

00:01:38,869 --> 00:01:42,530
it's officially in the spec and you can

00:01:40,880 --> 00:01:47,090
use it even though you could use it

00:01:42,530 --> 00:01:49,430
before so yeah so graph new

00:01:47,090 --> 00:01:52,909
subscriptions talks about how to

00:01:49,430 --> 00:01:55,670
basically also push data real-time data

00:01:52,909 --> 00:01:57,530
from the server to the client but

00:01:55,670 --> 00:02:01,490
there's many ways of doing that and I'll

00:01:57,530 --> 00:02:03,920
explain a bit the whole process but

00:02:01,490 --> 00:02:05,840
first for those of you still don't know

00:02:03,920 --> 00:02:08,739
what the fk is I'll do like a very quick

00:02:05,840 --> 00:02:11,480
intro so Raphael is a query language

00:02:08,739 --> 00:02:16,220
that's it just a query language you can

00:02:11,480 --> 00:02:17,810
query data which data any data so we'll

00:02:16,220 --> 00:02:20,260
see it right now I can basically just

00:02:17,810 --> 00:02:23,090
describe my data in a very simple way

00:02:20,260 --> 00:02:25,340
then I can ask for what I want and I get

00:02:23,090 --> 00:02:26,470
exactly that I know what I'll get no

00:02:25,340 --> 00:02:31,100
more no less

00:02:26,470 --> 00:02:33,230
so how does it actually work so first of

00:02:31,100 --> 00:02:34,970
all I describe my data so I'm writing it

00:02:33,230 --> 00:02:37,459
in a very simple language as you can see

00:02:34,970 --> 00:02:40,490
here like just types and there and there

00:02:37,459 --> 00:02:42,050
and there are notations but then what

00:02:40,490 --> 00:02:44,930
you see in the middle here this is the

00:02:42,050 --> 00:02:47,660
graphical engine luckily you don't need

00:02:44,930 --> 00:02:49,760
to write this thing so this thing just

00:02:47,660 --> 00:02:51,920
from rewriting your types can

00:02:49,760 --> 00:02:54,380
automatically bring the data from

00:02:51,920 --> 00:02:56,840
whatever the data is and send it back to

00:02:54,380 --> 00:02:59,480
the client like the client one is want

00:02:56,840 --> 00:03:02,450
it to be so if I'm writing now the

00:02:59,480 --> 00:03:06,709
client query which looks pretty similar

00:03:02,450 --> 00:03:10,370
pretty easy and then the client sends a

00:03:06,709 --> 00:03:12,350
request for the graphical engine now the

00:03:10,370 --> 00:03:15,650
graphical engine starts to fulfill that

00:03:12,350 --> 00:03:19,580
data no matter where it is and then

00:03:15,650 --> 00:03:22,280
combine that data together into one a

00:03:19,580 --> 00:03:25,010
single response that looks exactly like

00:03:22,280 --> 00:03:27,590
what you queried so that means that you

00:03:25,010 --> 00:03:30,290
don't need to wait anymore for syncing

00:03:27,590 --> 00:03:31,700
multiple requests into your client and

00:03:30,290 --> 00:03:34,220
the next the other thing that you don't

00:03:31,700 --> 00:03:35,630
need to do is actually now after you get

00:03:34,220 --> 00:03:37,670
all the data into the client start to

00:03:35,630 --> 00:03:40,310
structure the data in a way that you can

00:03:37,670 --> 00:03:42,769
render it you get the data exactly like

00:03:40,310 --> 00:03:45,140
it looks like so for example let's add

00:03:42,769 --> 00:03:47,750
another request which maybe we'll call

00:03:45,140 --> 00:03:50,060
another data source and now the

00:03:47,750 --> 00:03:52,880
graphical does basically the same but

00:03:50,060 --> 00:03:54,829
you can see that it will also query now

00:03:52,880 --> 00:03:58,280
it's query the user then the user name

00:03:54,829 --> 00:03:59,959
and messages from the server but then

00:03:58,280 --> 00:04:02,180
let's say the content of those messages

00:03:59,959 --> 00:04:04,940
will come from a third party API let's

00:04:02,180 --> 00:04:08,180
say WordPress API or something or

00:04:04,940 --> 00:04:11,120
content full and the amazing thing here

00:04:08,180 --> 00:04:14,209
is that again it will call a third party

00:04:11,120 --> 00:04:17,030
API the client doesn't know time doesn't

00:04:14,209 --> 00:04:19,340
know it doesn't care and then you will

00:04:17,030 --> 00:04:22,460
get back the response in exactly the way

00:04:19,340 --> 00:04:25,030
that you expect so it simplifies tons of

00:04:22,460 --> 00:04:27,500
code both on the server and the client

00:04:25,030 --> 00:04:30,380
but more than that it also gives you

00:04:27,500 --> 00:04:31,850
type safety over the network so when I'm

00:04:30,380 --> 00:04:36,590
writing and I'll quote on a client

00:04:31,850 --> 00:04:38,780
I know exactly what data can I get and I

00:04:36,590 --> 00:04:40,330
know if I'm making a mistake in

00:04:38,780 --> 00:04:42,220
development time

00:04:40,330 --> 00:04:44,139
know that I'm making a mistake I don't

00:04:42,220 --> 00:04:46,150
need to go to production code to a REST

00:04:44,139 --> 00:04:48,729
API and then one day I'll get one data

00:04:46,150 --> 00:04:50,110
it's specific data and the next day I'll

00:04:48,729 --> 00:04:53,169
get something else because the server

00:04:50,110 --> 00:04:55,210
developer decided to change something so

00:04:53,169 --> 00:04:58,590
this is very powerful but also I get

00:04:55,210 --> 00:05:00,580
from those just from typing those a few

00:04:58,590 --> 00:05:03,370
describing that data with this like

00:05:00,580 --> 00:05:05,860
simple schema language I get automatic

00:05:03,370 --> 00:05:07,750
Doc's all the docs that you need out of

00:05:05,860 --> 00:05:09,219
the box like everything you see here you

00:05:07,750 --> 00:05:13,210
don't need to develop it's already

00:05:09,219 --> 00:05:16,080
developed but what if I can tell you

00:05:13,210 --> 00:05:20,530
that any data also mean your local data

00:05:16,080 --> 00:05:23,830
what if I can run those queries from my

00:05:20,530 --> 00:05:25,690
components of my app so I can do

00:05:23,830 --> 00:05:27,819
basically the same process that I've

00:05:25,690 --> 00:05:30,669
done before but against doing a remote

00:05:27,819 --> 00:05:33,879
server I'm doing it against my Redux

00:05:30,669 --> 00:05:35,620
store for example and that makes that

00:05:33,879 --> 00:05:37,599
gives me a huge benefit because I can

00:05:35,620 --> 00:05:40,120
delete a lot of code on a client that we

00:05:37,599 --> 00:05:42,430
do today with like actions and reducers

00:05:40,120 --> 00:05:43,840
and all kinds of like code that we write

00:05:42,430 --> 00:05:45,069
ourselves this thing can do it

00:05:43,840 --> 00:05:48,190
automatically for us

00:05:45,069 --> 00:05:50,590
well it's only in the client so I can

00:05:48,190 --> 00:05:54,250
actually do that just on a client and

00:05:50,590 --> 00:05:56,080
then keep using rest and HTTP I don't

00:05:54,250 --> 00:05:58,839
even need my back-end developers to know

00:05:56,080 --> 00:06:01,389
what graphical is so that's actually

00:05:58,839 --> 00:06:03,550
something very very interesting so in a

00:06:01,389 --> 00:06:06,009
user evolution I think in the concept of

00:06:03,550 --> 00:06:08,050
graph QL and if you really want to see

00:06:06,009 --> 00:06:09,849
how it's done in a good way and not how

00:06:08,050 --> 00:06:12,099
I showed you now you should really check

00:06:09,849 --> 00:06:15,099
out tomorrow's talk app Peggy's

00:06:12,099 --> 00:06:17,080
tomorrow's talk it's going to blow your

00:06:15,099 --> 00:06:19,330
mind like seriously you have to watch

00:06:17,080 --> 00:06:21,520
the talk and the last thing that I'm

00:06:19,330 --> 00:06:23,860
going to talk about in the intro to

00:06:21,520 --> 00:06:26,560
graph QL is actually that we can

00:06:23,860 --> 00:06:29,889
actually today from the schema do even

00:06:26,560 --> 00:06:32,529
more we can generate code so we have

00:06:29,889 --> 00:06:36,279
this static typings we can generate

00:06:32,529 --> 00:06:40,180
typescript typings c-sharp classes java

00:06:36,279 --> 00:06:45,430
classes and even actual code or RAM code

00:06:40,180 --> 00:06:47,080
and full backends so like in two hours

00:06:45,430 --> 00:06:49,180
from now I giving a lightning talk just

00:06:47,080 --> 00:06:52,250
about that subject where I'll just

00:06:49,180 --> 00:06:55,910
create a full back-end

00:06:52,250 --> 00:06:57,860
from just like running in one script and

00:06:55,910 --> 00:07:00,650
it's open source it's not like back-end

00:06:57,860 --> 00:07:03,590
as a service or something so I hope you

00:07:00,650 --> 00:07:05,990
can come to that as well but there's

00:07:03,590 --> 00:07:07,730
there's one more thing which is actually

00:07:05,990 --> 00:07:09,970
the reason that I'm here and the reason

00:07:07,730 --> 00:07:15,440
they invited me here which is real-time

00:07:09,970 --> 00:07:18,910
so graph QL actually gives us because it

00:07:15,440 --> 00:07:21,590
works on any protocol or on any data

00:07:18,910 --> 00:07:23,240
then we don't need to think it in terms

00:07:21,590 --> 00:07:26,270
of rest anymore and the rest is very

00:07:23,240 --> 00:07:29,600
limited in the in the NH rest this limit

00:07:26,270 --> 00:07:32,450
is sorry connected directly to HTTP and

00:07:29,600 --> 00:07:34,970
HTTP is a bit limited with graphical we

00:07:32,450 --> 00:07:36,710
can use any transport so we can expand

00:07:34,970 --> 00:07:39,860
the things that we can do real-time is

00:07:36,710 --> 00:07:42,470
one of them and when we talk about

00:07:39,860 --> 00:07:44,560
real-time I think we should distinguish

00:07:42,470 --> 00:07:47,360
about what is actually real-time and

00:07:44,560 --> 00:07:50,720
just many types of real times that are

00:07:47,360 --> 00:07:53,419
or in real-time implementations that are

00:07:50,720 --> 00:07:56,720
fitted to each different use case so it

00:07:53,419 --> 00:07:59,480
can be a chat it can be just a presence

00:07:56,720 --> 00:08:02,660
like is MMB is the user online or

00:07:59,480 --> 00:08:06,230
offline we can just so see like the

00:08:02,660 --> 00:08:08,270
graphs for stock markets and many more

00:08:06,230 --> 00:08:10,550
other like use cases now the reason I'm

00:08:08,270 --> 00:08:12,169
putting there the use cases here is that

00:08:10,550 --> 00:08:16,940
soon I'm going to talk about basically

00:08:12,169 --> 00:08:19,450
three types of real time protocols or

00:08:16,940 --> 00:08:23,000
ways to do real-time polling

00:08:19,450 --> 00:08:25,640
subscriptions and live queries and I'm

00:08:23,000 --> 00:08:27,169
going to explain them because for us in

00:08:25,640 --> 00:08:28,970
the spec we need to realize what

00:08:27,169 --> 00:08:31,820
graphical subscription is and what is

00:08:28,970 --> 00:08:34,099
not and for which use cases graphical

00:08:31,820 --> 00:08:36,770
subscription fits and which use cases

00:08:34,099 --> 00:08:38,750
you would rather do polling or live

00:08:36,770 --> 00:08:44,060
queries so I'm going to cover that a bit

00:08:38,750 --> 00:08:46,010
as well so too often when you hear about

00:08:44,060 --> 00:08:48,040
real-time you think about like this like

00:08:46,010 --> 00:08:52,010
magical service in the cloud that

00:08:48,040 --> 00:08:54,200
basically just propagates data into your

00:08:52,010 --> 00:08:57,920
into your application so you just it's

00:08:54,200 --> 00:09:00,740
like you're running a local query on

00:08:57,920 --> 00:09:03,080
your on your devices on your clients you

00:09:00,740 --> 00:09:05,720
write all your code on your client you

00:09:03,080 --> 00:09:07,550
just update like this simple store

00:09:05,720 --> 00:09:09,949
on your client and then everything match

00:09:07,550 --> 00:09:12,139
magically being synced everywhere and

00:09:09,949 --> 00:09:13,850
that's true like you can do that and

00:09:12,139 --> 00:09:17,899
there's amazing services that does did

00:09:13,850 --> 00:09:22,430
they do that but but that's actually

00:09:17,899 --> 00:09:25,519
very hard and why is it hard because in

00:09:22,430 --> 00:09:27,980
order for me to actually to listen to

00:09:25,519 --> 00:09:31,040
data and to know when data is happening

00:09:27,980 --> 00:09:32,779
when data is changed I have to realize

00:09:31,040 --> 00:09:34,850
all the dependencies of the data and

00:09:32,779 --> 00:09:37,519
this is something not super simple and

00:09:34,850 --> 00:09:40,540
you need to have specific infrastructure

00:09:37,519 --> 00:09:43,630
to do that for example today you can use

00:09:40,540 --> 00:09:45,920
rethink DB which is an interesting

00:09:43,630 --> 00:09:48,649
database that gives you that ability you

00:09:45,920 --> 00:09:50,600
can use firebase and firestore which

00:09:48,649 --> 00:09:53,209
maybe I'll touch a bit on them and the

00:09:50,600 --> 00:09:55,040
differences between them and also you

00:09:53,209 --> 00:09:57,290
can use with meteor meteor

00:09:55,040 --> 00:09:59,569
basically listens to the module upload

00:09:57,290 --> 00:10:02,480
and then gives you those abilities as

00:09:59,569 --> 00:10:05,660
well but there's a problem with all

00:10:02,480 --> 00:10:07,670
those solutions what if I don't have a

00:10:05,660 --> 00:10:10,130
reactive bacon what if I currently have

00:10:07,670 --> 00:10:13,510
an existing app maybe I work in a bank

00:10:10,130 --> 00:10:17,329
on an IBM infrastructure maybe I have

00:10:13,510 --> 00:10:20,389
Postclassic PO maybe I have I don't know

00:10:17,329 --> 00:10:23,209
an existing database without a

00:10:20,389 --> 00:10:26,000
meteor and I can't now just put meteor

00:10:23,209 --> 00:10:28,040
on all my stuff and another thing what

00:10:26,000 --> 00:10:30,680
if I can't pay a service to do that I

00:10:28,040 --> 00:10:32,480
want my data to live internally and I

00:10:30,680 --> 00:10:37,850
don't know what is happening with my

00:10:32,480 --> 00:10:42,490
data and I on the cloud so I think one

00:10:37,850 --> 00:10:45,170
solution that people are too often are

00:10:42,490 --> 00:10:47,089
looking at something that is not good is

00:10:45,170 --> 00:10:49,279
polling but it's actually a great

00:10:47,089 --> 00:10:51,680
solution because you can use what is

00:10:49,279 --> 00:10:52,430
polling polling is basically okay I have

00:10:51,680 --> 00:10:55,760
a query

00:10:52,430 --> 00:10:58,699
I'll just run it again and again and

00:10:55,760 --> 00:11:01,310
again like every second or every twenty

00:10:58,699 --> 00:11:03,319
seconds and that actually solves a lot

00:11:01,310 --> 00:11:05,389
of problems it means that I know that

00:11:03,319 --> 00:11:10,220
the data will keep being consistent on

00:11:05,389 --> 00:11:11,870
my client and I know that I don't need

00:11:10,220 --> 00:11:14,810
to change anything like if ever like an

00:11:11,870 --> 00:11:17,120
old HTTP server it will work I don't

00:11:14,810 --> 00:11:18,740
need to change nothing but there are

00:11:17,120 --> 00:11:19,400
some issues with polling like one of

00:11:18,740 --> 00:11:22,700
them for

00:11:19,400 --> 00:11:24,860
if I'm sending a query and and get back

00:11:22,700 --> 00:11:27,170
the result and then twas the change I

00:11:24,860 --> 00:11:29,180
will miss the change and then only the

00:11:27,170 --> 00:11:32,480
next time I will query it will happen

00:11:29,180 --> 00:11:34,970
another problem is I might be send a lot

00:11:32,480 --> 00:11:37,640
of requests they are just too expensive

00:11:34,970 --> 00:11:42,940
that nothing happened why would I send

00:11:37,640 --> 00:11:47,690
those requests and overload my server so

00:11:42,940 --> 00:11:50,270
what can we do with real time even if we

00:11:47,690 --> 00:11:53,540
don't have reactive patterns what can we

00:11:50,270 --> 00:11:57,290
say on our backends that can tell us

00:11:53,540 --> 00:12:01,460
this happened right now so let's think

00:11:57,290 --> 00:12:04,339
about like a regular server and I have a

00:12:01,460 --> 00:12:09,140
client and the client basically proforms

00:12:04,339 --> 00:12:12,950
a regular HTTP request now on the server

00:12:09,140 --> 00:12:15,770
if you can see the code on the bottom is

00:12:12,950 --> 00:12:19,910
basically there's a regular server

00:12:15,770 --> 00:12:21,440
method add message and I just saved a

00:12:19,910 --> 00:12:23,450
new message in the database get a

00:12:21,440 --> 00:12:26,150
response did it happen and then return

00:12:23,450 --> 00:12:28,190
this response but I actually know right

00:12:26,150 --> 00:12:29,870
now that then you have a new messages

00:12:28,190 --> 00:12:32,420
happen so I can actually trigger a

00:12:29,870 --> 00:12:35,060
change and if I had some kind of

00:12:32,420 --> 00:12:37,100
mechanism to trigger a change or trigger

00:12:35,060 --> 00:12:40,339
an event and send it to the client

00:12:37,100 --> 00:12:42,470
then we'll get real-time even though we

00:12:40,339 --> 00:12:44,150
don't have a reactive back-end and this

00:12:42,470 --> 00:12:45,560
can run on any code they wrote here with

00:12:44,150 --> 00:12:48,950
JavaScript well but it can be you know

00:12:45,560 --> 00:12:53,390
like I know Perl code or C++ code or

00:12:48,950 --> 00:12:56,000
whatever so pub/sub or publish/subscribe

00:12:53,390 --> 00:12:58,430
it's a known method to do those things

00:12:56,000 --> 00:13:01,240
and there's many solutions that give you

00:12:58,430 --> 00:13:05,120
that ability you basically one side is

00:13:01,240 --> 00:13:08,209
subscribe to an event and the other side

00:13:05,120 --> 00:13:10,400
is listening to it so now I can from the

00:13:08,209 --> 00:13:12,709
server just call a method on the on the

00:13:10,400 --> 00:13:14,839
pub sub and the pub sub will take care

00:13:12,709 --> 00:13:18,200
of sending that to my client and I get

00:13:14,839 --> 00:13:20,029
real-time on top of my existing data now

00:13:18,200 --> 00:13:21,920
if you think about solutions that give

00:13:20,029 --> 00:13:25,160
you that pub sub mechanisms like

00:13:21,920 --> 00:13:28,730
services you can think about PubNub or

00:13:25,160 --> 00:13:30,530
pusher and those kinds of things but

00:13:28,730 --> 00:13:32,570
also there's a lot of open-source

00:13:30,530 --> 00:13:33,230
solutions out there that will give you

00:13:32,570 --> 00:13:35,720
those ability

00:13:33,230 --> 00:13:37,580
so in the next slides I'm going to lay

00:13:35,720 --> 00:13:40,190
in later on in the talk I'm going to

00:13:37,580 --> 00:13:43,220
like dive deep a bit into how you

00:13:40,190 --> 00:13:44,930
actually go in and do this those things

00:13:43,220 --> 00:13:48,500
yourself and all the things that you

00:13:44,930 --> 00:13:50,540
need to take care of but let's say no we

00:13:48,500 --> 00:13:53,780
have publish/subscribe method and we get

00:13:50,540 --> 00:13:57,560
real-time and that's great but there's a

00:13:53,780 --> 00:13:59,570
few problems with that one is the client

00:13:57,560 --> 00:14:02,300
how do I know which events can I

00:13:59,570 --> 00:14:04,370
subscribe to it can change any day right

00:14:02,300 --> 00:14:07,100
we're all developers everything breaks

00:14:04,370 --> 00:14:09,920
and changes every day another thing is

00:14:07,100 --> 00:14:12,380
you know in when I park when the server

00:14:09,920 --> 00:14:15,320
published data it went to publish an

00:14:12,380 --> 00:14:16,940
event it'll also send data but I don't

00:14:15,320 --> 00:14:19,180
know what data the server can send me

00:14:16,940 --> 00:14:22,670
and I don't know if I can get it or not

00:14:19,180 --> 00:14:24,680
so that means that I have a problem with

00:14:22,670 --> 00:14:27,560
every event that's happening maybe the

00:14:24,680 --> 00:14:30,190
server will decide to send too many too

00:14:27,560 --> 00:14:32,870
much information overloading my network

00:14:30,190 --> 00:14:35,630
the next the other thing or maybe I'll

00:14:32,870 --> 00:14:38,420
take another thing and I will say ok a

00:14:35,630 --> 00:14:41,210
message you added was added here is the

00:14:38,420 --> 00:14:43,700
idea of the message now what the client

00:14:41,210 --> 00:14:45,830
can do is again go and send an HTTP

00:14:43,700 --> 00:14:49,160
request with the new message which is a

00:14:45,830 --> 00:14:51,350
valuable solution but what if we could

00:14:49,160 --> 00:14:55,850
actually decide what data on the client

00:14:51,350 --> 00:14:57,560
we want to get and query it also like if

00:14:55,850 --> 00:14:58,880
again like if something changed on the

00:14:57,560 --> 00:15:00,380
server I want to know that I'm not

00:14:58,880 --> 00:15:02,270
breaking anything and all the content

00:15:00,380 --> 00:15:07,760
I'm trying on or running on a client is

00:15:02,270 --> 00:15:10,520
still ok a long time so that sounds very

00:15:07,760 --> 00:15:11,930
familiar like those those problems that

00:15:10,520 --> 00:15:15,680
we actually talked about is actually

00:15:11,930 --> 00:15:19,130
what graph QL is solved for HTTP so what

00:15:15,680 --> 00:15:21,470
if we can bring graph QL into that space

00:15:19,130 --> 00:15:23,960
as well and this is exactly what the

00:15:21,470 --> 00:15:26,530
oculus subscription is so graphic your

00:15:23,960 --> 00:15:29,450
subscription basically let the server

00:15:26,530 --> 00:15:35,140
describe in the same schema that you saw

00:15:29,450 --> 00:15:38,150
before what events are being exposed and

00:15:35,140 --> 00:15:41,270
also what data can be sent over the

00:15:38,150 --> 00:15:43,130
network every with those events and then

00:15:41,270 --> 00:15:45,470
the client just like a graphical query

00:15:43,130 --> 00:15:46,720
can decide which events you want to

00:15:45,470 --> 00:15:49,240
subscribe to and

00:15:46,720 --> 00:15:53,290
and which data exactly wants to get back

00:15:49,240 --> 00:15:56,740
they want to get back and the most

00:15:53,290 --> 00:15:59,110
important thing like like graph QL it

00:15:56,740 --> 00:16:02,650
can work on top of any event source and

00:15:59,110 --> 00:16:07,240
any data source so let's see how it

00:16:02,650 --> 00:16:09,460
actually works so first thing we write a

00:16:07,240 --> 00:16:12,910
schema so you can see on the bottom left

00:16:09,460 --> 00:16:14,620
we have we just added it to the to our

00:16:12,910 --> 00:16:18,310
schema we headed a subscription this was

00:16:14,620 --> 00:16:20,080
subscription says message added and then

00:16:18,310 --> 00:16:21,940
on the client what we want to say is I

00:16:20,080 --> 00:16:24,280
want to subscribe to message edit and

00:16:21,940 --> 00:16:27,780
every time a message was added I want to

00:16:24,280 --> 00:16:31,450
I want to get the author and the content

00:16:27,780 --> 00:16:34,120
so this is already very powerful on the

00:16:31,450 --> 00:16:36,040
client I can say which events I can

00:16:34,120 --> 00:16:38,770
subscribe to and get the data and do

00:16:36,040 --> 00:16:41,260
whatever I want with you so let's see

00:16:38,770 --> 00:16:43,960
how it what happens actually so the

00:16:41,260 --> 00:16:46,150
client sends a query but this time if

00:16:43,960 --> 00:16:49,300
you see the line between the client and

00:16:46,150 --> 00:16:52,750
the and the graph QL this is actually a

00:16:49,300 --> 00:16:54,670
two-way connection which we'll talk a

00:16:52,750 --> 00:16:56,200
bit in a second but it's like WebSockets

00:16:54,670 --> 00:16:58,540
or something like that I need to send a

00:16:56,200 --> 00:17:00,540
request and I need to get a response and

00:16:58,540 --> 00:17:03,430
keep getting responses later from that

00:17:00,540 --> 00:17:06,370
and what happens now is that I basically

00:17:03,430 --> 00:17:09,010
created a subscription and now the

00:17:06,370 --> 00:17:12,220
server can send that message that we saw

00:17:09,010 --> 00:17:14,130
before into graph QL now once the server

00:17:12,220 --> 00:17:17,199
will send that message into graph QL

00:17:14,130 --> 00:17:20,199
graph QL will do a very amazing thing in

00:17:17,199 --> 00:17:24,520
order to send me the data that I want it

00:17:20,199 --> 00:17:27,579
can go ahead and parse that query that I

00:17:24,520 --> 00:17:30,510
act for the specific client and get me

00:17:27,579 --> 00:17:34,270
all the data that I want from any source

00:17:30,510 --> 00:17:36,730
so that means that let's say I fired an

00:17:34,270 --> 00:17:39,460
event on on on the on the client or on

00:17:36,730 --> 00:17:42,490
the server I can still get real-time

00:17:39,460 --> 00:17:46,690
data not only for my server but for my

00:17:42,490 --> 00:17:47,950
third party API and I'll get the reason

00:17:46,690 --> 00:17:50,560
and the response that I'll get is

00:17:47,950 --> 00:17:53,380
exactly like a query exactly what I want

00:17:50,560 --> 00:17:56,020
and I actually enriched the data he had

00:17:53,380 --> 00:17:57,820
the power to get just the limited amount

00:17:56,020 --> 00:18:00,350
of data that I want but also if I want

00:17:57,820 --> 00:18:02,090
data from github API I can

00:18:00,350 --> 00:18:05,299
that even though the source of the event

00:18:02,090 --> 00:18:07,730
was my own server but the source of my

00:18:05,299 --> 00:18:13,340
event can actually even be like an IOT

00:18:07,730 --> 00:18:16,910
device I can trigger an IOT device or it

00:18:13,340 --> 00:18:18,890
can be a web hook or it can be an SQL

00:18:16,910 --> 00:18:21,320
trigger or whatever I want

00:18:18,890 --> 00:18:25,539
trigger that response and again run

00:18:21,320 --> 00:18:27,950
through all that to the regular

00:18:25,539 --> 00:18:30,110
graphical engine and get exactly the

00:18:27,950 --> 00:18:33,490
data that I want so this is very

00:18:30,110 --> 00:18:38,120
powerful I can put this I I can put this

00:18:33,490 --> 00:18:40,159
box or technology open-source technology

00:18:38,120 --> 00:18:42,650
into my existing stacks no matter what

00:18:40,159 --> 00:18:45,500
it is it can be like the oldest thing in

00:18:42,650 --> 00:18:47,929
the book like one time one thing that I

00:18:45,500 --> 00:18:50,780
did was go into a bank and actually add

00:18:47,929 --> 00:18:54,950
that on top of like this really really

00:18:50,780 --> 00:18:57,620
really old cue from IBM and it worked

00:18:54,950 --> 00:19:00,289
it made us have accomplished real-time

00:18:57,620 --> 00:19:07,340
updates on the react native app for the

00:19:00,289 --> 00:19:10,850
bank so but if so this is like all fair

00:19:07,340 --> 00:19:12,919
and square this is great but actually

00:19:10,850 --> 00:19:16,250
there are some problems when when we get

00:19:12,919 --> 00:19:20,360
into real-time bi-directional data and

00:19:16,250 --> 00:19:22,970
things like that now one thing that I

00:19:20,360 --> 00:19:25,580
want like let's like to talk about three

00:19:22,970 --> 00:19:26,870
common problems one is I need to send

00:19:25,580 --> 00:19:28,880
bi-directional data over the network

00:19:26,870 --> 00:19:31,250
I'll talk a bit little bit about that

00:19:28,880 --> 00:19:34,760
and other thing is what happens if the

00:19:31,250 --> 00:19:36,530
data if the connection fails what do I

00:19:34,760 --> 00:19:38,570
do with the data and the events that

00:19:36,530 --> 00:19:41,600
happened when I was offline in the Train

00:19:38,570 --> 00:19:44,539
or I don't know when and the third thing

00:19:41,600 --> 00:19:47,929
is scaling like there's a problem now

00:19:44,539 --> 00:19:50,990
because all the clients are staying

00:19:47,929 --> 00:19:53,870
connected to my server and this is maybe

00:19:50,990 --> 00:19:59,030
harder to scale now one thing that I

00:19:53,870 --> 00:20:01,340
want to say here is that too often the

00:19:59,030 --> 00:20:04,190
information about those things when you

00:20:01,340 --> 00:20:06,710
go online and Google those things is a

00:20:04,190 --> 00:20:09,320
bit misleading and the reason is that

00:20:06,710 --> 00:20:12,380
the companies the service companies that

00:20:09,320 --> 00:20:13,659
provides those pub/sub mechanisms out of

00:20:12,380 --> 00:20:16,279
the box in the cloud

00:20:13,659 --> 00:20:18,139
their interest sometimes and it's not

00:20:16,279 --> 00:20:20,539
that they're bad it's just how marketing

00:20:18,139 --> 00:20:23,869
works is to tell you that their solution

00:20:20,539 --> 00:20:26,779
is super super simple and if you do it

00:20:23,869 --> 00:20:28,789
yourself it's super super hard but

00:20:26,779 --> 00:20:30,289
that's not completely true you need to

00:20:28,789 --> 00:20:32,690
take care of a lot of things without

00:20:30,289 --> 00:20:34,669
coverage some of them it's not like

00:20:32,690 --> 00:20:38,179
giving a talk about scaling can be like

00:20:34,669 --> 00:20:40,309
a now we're long but all those problems

00:20:38,179 --> 00:20:42,019
are actually can be done with open

00:20:40,309 --> 00:20:44,959
source tools that are very advanced and

00:20:42,019 --> 00:20:49,279
are used by companies like Twitter and

00:20:44,959 --> 00:20:51,889
Google and Facebook so let's talk about

00:20:49,279 --> 00:20:54,139
one first problem bi-directional

00:20:51,889 --> 00:20:57,169
transport so what you see here is that

00:20:54,139 --> 00:21:00,229
we created basically a link between our

00:20:57,169 --> 00:21:03,919
clients and our graphical servers but

00:21:00,229 --> 00:21:06,649
this link is constant it's there and

00:21:03,919 --> 00:21:08,659
also one thing that we forgot and it's

00:21:06,649 --> 00:21:12,399
important to mention it's the internet

00:21:08,659 --> 00:21:16,789
on the other side so one thing that we

00:21:12,399 --> 00:21:20,389
HTTP simply is harder for the HTTP to

00:21:16,789 --> 00:21:23,179
actually accomplish those bi-directional

00:21:20,389 --> 00:21:25,219
transports we call them I won't go too

00:21:23,179 --> 00:21:27,669
deep into that but what I can tell you

00:21:25,219 --> 00:21:30,409
is that there are solutions for that

00:21:27,669 --> 00:21:34,159
that are very wide spurts and this is

00:21:30,409 --> 00:21:36,409
those are known problems that are in

00:21:34,159 --> 00:21:38,659
solved problems so one thing one of the

00:21:36,409 --> 00:21:41,149
most often things that people use our

00:21:38,659 --> 00:21:45,019
WebSockets WebSockets now support are

00:21:41,149 --> 00:21:47,690
supported in any web browser and there's

00:21:45,019 --> 00:21:50,119
a amazing amount of code in libraries

00:21:47,690 --> 00:21:55,070
that do WebSockets in very high

00:21:50,119 --> 00:21:56,509
performance and scale but and one of the

00:21:55,070 --> 00:21:58,820
things that they do is also let's say

00:21:56,509 --> 00:22:01,849
there's your somehow your connection

00:21:58,820 --> 00:22:04,339
can't your browser can't come up with

00:22:01,849 --> 00:22:06,829
web brow with WebSockets maybe because

00:22:04,339 --> 00:22:09,019
it's a very old browser or maybe because

00:22:06,829 --> 00:22:11,239
you're behind firewall those libraries

00:22:09,019 --> 00:22:12,559
will fall back into other solutions for

00:22:11,239 --> 00:22:14,869
you you don't need to take care of that

00:22:12,559 --> 00:22:16,820
and other thing is actually to use like

00:22:14,869 --> 00:22:20,299
all the existing solutions like

00:22:16,820 --> 00:22:23,659
server-side events an HTTP long polling

00:22:20,299 --> 00:22:25,700
which are part of HTTP another thing

00:22:23,659 --> 00:22:26,980
that you can do is actually use MQTT org

00:22:25,700 --> 00:22:29,950
all kinds of cumin

00:22:26,980 --> 00:22:31,990
q our messaging things in order to make

00:22:29,950 --> 00:22:34,210
sure that everything you sent over the

00:22:31,990 --> 00:22:36,520
network will get there but basically

00:22:34,210 --> 00:22:38,800
what I'm trying to say is that there is

00:22:36,520 --> 00:22:40,300
many many solutions for that it's a

00:22:38,800 --> 00:22:42,700
known problem and you can basically use

00:22:40,300 --> 00:22:45,910
anything out there the graphical spec

00:22:42,700 --> 00:22:51,190
doesn't dictate which technology you use

00:22:45,910 --> 00:22:55,060
Oh everything that I talked about that

00:22:51,190 --> 00:22:58,600
was the next problem is offline

00:22:55,060 --> 00:23:03,220
what happens if now the Internet is gone

00:22:58,600 --> 00:23:05,050
I'm behind Internet so here also what

00:23:03,220 --> 00:23:08,950
those services are giving us is actually

00:23:05,050 --> 00:23:11,110
a local store that with some logic that

00:23:08,950 --> 00:23:12,930
tells us what to do when the network is

00:23:11,110 --> 00:23:16,630
off what to do when the network is on

00:23:12,930 --> 00:23:19,150
and that's okay but there's open source

00:23:16,630 --> 00:23:21,340
solutions for that if you confirm to an

00:23:19,150 --> 00:23:24,040
open API like ruff your subscriptions

00:23:21,340 --> 00:23:27,580
then there's tools you can build

00:23:24,040 --> 00:23:30,190
yourself to do that or use open source

00:23:27,580 --> 00:23:33,280
tools the tools that does that for you

00:23:30,190 --> 00:23:35,590
like Apollo client and relay so those

00:23:33,280 --> 00:23:37,690
solutions will actually have a built in

00:23:35,590 --> 00:23:39,670
waistt in an open source way that you

00:23:37,690 --> 00:23:44,590
can change in order to handle those

00:23:39,670 --> 00:23:46,960
things so and to hear more about those

00:23:44,590 --> 00:23:53,530
things you should really again check out

00:23:46,960 --> 00:23:56,410
Peggy's talk tomorrow ok I keep

00:23:53,530 --> 00:23:59,860
forgetting that there's a animation

00:23:56,410 --> 00:24:01,450
there so the less problem is scaling and

00:23:59,860 --> 00:24:03,520
that's probably like the main thing that

00:24:01,450 --> 00:24:07,540
I'll cover right now in a hope I'll have

00:24:03,520 --> 00:24:09,700
time so scaling is a hard problem but

00:24:07,540 --> 00:24:13,200
again we and maybe it's a bit harder

00:24:09,700 --> 00:24:16,570
with live queries and publish subscribe

00:24:13,200 --> 00:24:18,400
but it's also a known problem and

00:24:16,570 --> 00:24:21,100
there's a few things you can make sure

00:24:18,400 --> 00:24:23,560
to do in order to make that problem much

00:24:21,100 --> 00:24:25,240
easier for you first concept that you

00:24:23,560 --> 00:24:28,630
should remember is actually separate the

00:24:25,240 --> 00:24:31,120
stateful things and the stateless thing

00:24:28,630 --> 00:24:34,540
what do I mean by that a graphical

00:24:31,120 --> 00:24:36,430
server is stateless every time it it's

00:24:34,540 --> 00:24:37,930
like an HTTP server every time it will

00:24:36,430 --> 00:24:41,040
get a request it will send a response

00:24:37,930 --> 00:24:43,990
and it doesn't hold any state what

00:24:41,040 --> 00:24:46,150
but when we were connected into that

00:24:43,990 --> 00:24:49,540
graphical server with the with an event

00:24:46,150 --> 00:24:51,910
stream or with a transport like

00:24:49,540 --> 00:24:54,670
WebSocket we now the client actually

00:24:51,910 --> 00:24:56,440
subscribed to an event so the client is

00:24:54,670 --> 00:24:59,290
state there are like I need to know

00:24:56,440 --> 00:25:02,920
which client are subscribing to my data

00:24:59,290 --> 00:25:04,690
so this is actual state so this is one

00:25:02,920 --> 00:25:09,370
thing I'll show you now how to separate

00:25:04,690 --> 00:25:11,530
the two yeah and then the next thing is

00:25:09,370 --> 00:25:13,450
that sometimes when you scale you need

00:25:11,530 --> 00:25:15,870
to make sure that the right data will

00:25:13,450 --> 00:25:18,640
get to the right places because maybe

00:25:15,870 --> 00:25:20,530
you know you have multiple instances and

00:25:18,640 --> 00:25:23,050
some event happens you need to make sure

00:25:20,530 --> 00:25:25,480
that the right first of all this

00:25:23,050 --> 00:25:26,980
everyone who wants that event will get

00:25:25,480 --> 00:25:30,190
that event and the second thing that

00:25:26,980 --> 00:25:33,070
that event one fire if someone else has

00:25:30,190 --> 00:25:35,260
already handled that for example but

00:25:33,070 --> 00:25:39,850
again here you have existing solutions

00:25:35,260 --> 00:25:42,280
like like like Redis and Kafka and all

00:25:39,850 --> 00:25:44,050
kinds of existing solutions that all

00:25:42,280 --> 00:25:47,140
companies are using today with great

00:25:44,050 --> 00:25:49,720
success and not so much trouble so how

00:25:47,140 --> 00:25:51,970
can we actually do that right now we

00:25:49,720 --> 00:25:53,590
have a lot of clients that are connected

00:25:51,970 --> 00:25:56,530
to the same graph to the server and this

00:25:53,590 --> 00:25:58,870
can overload the server what we can do

00:25:56,530 --> 00:26:03,360
is actually scale that scales those

00:25:58,870 --> 00:26:07,000
servers and then put like some kind of a

00:26:03,360 --> 00:26:09,450
pubsub mechanism it can be a service but

00:26:07,000 --> 00:26:13,090
it can also be an open-source tool like

00:26:09,450 --> 00:26:15,910
Redis or Kafka that will make sure that

00:26:13,090 --> 00:26:17,350
the right messages will go into the

00:26:15,910 --> 00:26:19,330
right servers and then you can scale

00:26:17,350 --> 00:26:22,030
your servers as much as possible the

00:26:19,330 --> 00:26:24,190
graphical servers can just be scaled as

00:26:22,030 --> 00:26:26,020
much as you want

00:26:24,190 --> 00:26:30,460
another thing that those tools will do

00:26:26,020 --> 00:26:33,370
is actually quality of service QoS you

00:26:30,460 --> 00:26:36,220
have all kinds of levels of QoS like I'm

00:26:33,370 --> 00:26:37,930
sending a message is it guarantee that

00:26:36,220 --> 00:26:39,880
the other site will get the message or

00:26:37,930 --> 00:26:41,800
not maybe I send a message that I don't

00:26:39,880 --> 00:26:45,100
care if it will guarantee and there's

00:26:41,800 --> 00:26:47,110
costs for everything now the open-source

00:26:45,100 --> 00:26:48,850
tools actually gives you the level of

00:26:47,110 --> 00:26:51,790
control over that you can just control

00:26:48,850 --> 00:26:53,710
that and you understand exactly how much

00:26:51,790 --> 00:26:54,640
does it cost and how much not with

00:26:53,710 --> 00:26:56,590
services it's not

00:26:54,640 --> 00:26:58,390
always the same they decide for you

00:26:56,590 --> 00:27:01,650
what's the quality of service you want

00:26:58,390 --> 00:27:05,050
and what's the price you're gonna pay

00:27:01,650 --> 00:27:07,210
another thing is the actual subscribing

00:27:05,050 --> 00:27:10,450
and the publishing of events let's say

00:27:07,210 --> 00:27:12,370
I'm listening to my data source but I

00:27:10,450 --> 00:27:15,010
want to scale and send it to multiple

00:27:12,370 --> 00:27:17,080
trends again the graphical servers are

00:27:15,010 --> 00:27:19,870
status so I can just scale them

00:27:17,080 --> 00:27:22,570
Horizonte and then the pub/sub will make

00:27:19,870 --> 00:27:24,400
sure that everyone who needs that

00:27:22,570 --> 00:27:27,370
information would get that information

00:27:24,400 --> 00:27:29,140
and if you want to scale your databases

00:27:27,370 --> 00:27:30,790
also there's many many possible

00:27:29,140 --> 00:27:37,030
solutions out there I won't cover that

00:27:30,790 --> 00:27:39,820
today okay so what you can maybe until

00:27:37,030 --> 00:27:41,500
now understand from my talk is that live

00:27:39,820 --> 00:27:43,900
queries are really awesome and really

00:27:41,500 --> 00:27:46,540
good I always want to do live queries

00:27:43,900 --> 00:27:48,540
but if I can't I will just use

00:27:46,540 --> 00:27:51,250
subscriptions over my existing data

00:27:48,540 --> 00:27:53,350
that's not entirely true and this is a

00:27:51,250 --> 00:27:56,380
huge debate that we had also in the spec

00:27:53,350 --> 00:27:59,500
work actually what we came up with is

00:27:56,380 --> 00:28:02,110
that subscriptions are valuable because

00:27:59,500 --> 00:28:05,230
they give more power to the client and

00:28:02,110 --> 00:28:08,050
they tell you not just that data has

00:28:05,230 --> 00:28:10,480
changed they tell you why so you can

00:28:08,050 --> 00:28:11,980
respond to that change for example if

00:28:10,480 --> 00:28:15,310
we're looking at thinking about the use

00:28:11,980 --> 00:28:17,020
cases before maybe on them on a if I

00:28:15,310 --> 00:28:19,120
just want to display the price of

00:28:17,020 --> 00:28:21,550
Bitcoin I can do it in a live query

00:28:19,120 --> 00:28:24,370
because I can just put the updated data

00:28:21,550 --> 00:28:26,170
all the time but if it's a chat maybe I

00:28:24,370 --> 00:28:28,060
want to get a notification when it

00:28:26,170 --> 00:28:30,400
happens or maybe I want to do an

00:28:28,060 --> 00:28:32,860
animation so with subscriptions it's

00:28:30,400 --> 00:28:36,250
actually a better solution for those

00:28:32,860 --> 00:28:37,090
types of use cases and with graphical

00:28:36,250 --> 00:28:39,040
subscriptions

00:28:37,090 --> 00:28:44,080
it's actually if you think about it it's

00:28:39,040 --> 00:28:46,390
a bit in the middle because you get kind

00:28:44,080 --> 00:28:48,880
of both walls in a way because I get

00:28:46,390 --> 00:28:51,160
pub/sub messages but I also get the data

00:28:48,880 --> 00:28:53,530
that I want and their updated data so

00:28:51,160 --> 00:28:56,290
it's very very powerful and maybe I

00:28:53,530 --> 00:28:59,290
don't even need life for us at all but

00:28:56,290 --> 00:29:01,200
like I said sometimes you do and people

00:28:59,290 --> 00:29:03,490
think that live queries are a bit for

00:29:01,200 --> 00:29:06,010
simplistic use cases like I'm building a

00:29:03,490 --> 00:29:08,020
POC I will put a live query in and it

00:29:06,010 --> 00:29:10,690
will just work and that's true

00:29:08,020 --> 00:29:12,760
but it's also for very hard cases for

00:29:10,690 --> 00:29:14,890
example what if all those data

00:29:12,760 --> 00:29:18,160
dependencies that I have are so many

00:29:14,890 --> 00:29:20,950
events that I can't cover those I can't

00:29:18,160 --> 00:29:23,140
let's say I want to update the likes on

00:29:20,950 --> 00:29:25,090
a post there's many things that could

00:29:23,140 --> 00:29:28,210
happen maybe some one hand like a post

00:29:25,090 --> 00:29:28,960
maybe someone deleted their account from

00:29:28,210 --> 00:29:31,180
Facebook

00:29:28,960 --> 00:29:33,430
maybe someone became my friend so I need

00:29:31,180 --> 00:29:35,650
to also put by the number also my

00:29:33,430 --> 00:29:37,120
friends it's very hard to cover so in

00:29:35,650 --> 00:29:41,890
that case actually live queries

00:29:37,120 --> 00:29:45,100
simplifies the code for us so what if

00:29:41,890 --> 00:29:46,120
you can if you could but but it's not in

00:29:45,100 --> 00:29:47,560
the spec right graph to the

00:29:46,120 --> 00:29:51,550
subscriptions is in the spec live

00:29:47,560 --> 00:29:51,940
queries or not well that's not quite

00:29:51,550 --> 00:29:54,100
true

00:29:51,940 --> 00:29:56,260
so it's not in the spec but there's a

00:29:54,100 --> 00:29:57,820
lot of work that we have been doing in

00:29:56,260 --> 00:29:59,950
order to support that one

00:29:57,820 --> 00:30:05,410
very nice library is a library called

00:29:59,950 --> 00:30:08,290
graph QL rxjs which basically instead on

00:30:05,410 --> 00:30:10,810
each point that we get data instead of

00:30:08,290 --> 00:30:13,420
getting data through one time for

00:30:10,810 --> 00:30:16,150
example like through a promise I can

00:30:13,420 --> 00:30:17,890
actually get an observable and the data

00:30:16,150 --> 00:30:21,730
point will keep firing back I'll show

00:30:17,890 --> 00:30:23,860
you how it's done so what you see here

00:30:21,730 --> 00:30:26,440
is that on the query I put a just on the

00:30:23,860 --> 00:30:28,390
content on the specific data that I want

00:30:26,440 --> 00:30:32,530
to be live I'm putting in live

00:30:28,390 --> 00:30:34,360
annotation and then what I can do is I

00:30:32,530 --> 00:30:37,000
will do the queries again and like

00:30:34,360 --> 00:30:40,780
regular query everything will be solved

00:30:37,000 --> 00:30:42,940
and and I'll get back I'll back back

00:30:40,780 --> 00:30:45,190
back get back the query that I want now

00:30:42,940 --> 00:30:47,260
that's okay but I keep one two things

00:30:45,190 --> 00:30:49,660
are happening here one the client is

00:30:47,260 --> 00:30:53,650
still connected to their graphical

00:30:49,660 --> 00:30:55,690
server the other thing is that the dot

00:30:53,650 --> 00:30:58,690
on the bottom is still connected to my

00:30:55,690 --> 00:31:01,540
reactive database so now if something

00:30:58,690 --> 00:31:06,360
will change in my reactive database the

00:31:01,540 --> 00:31:09,850
following thing would happen I will get

00:31:06,360 --> 00:31:13,090
that data just the data propagating

00:31:09,850 --> 00:31:14,950
again and fire into my client and the

00:31:13,090 --> 00:31:17,650
data that I'm gonna get is just the

00:31:14,950 --> 00:31:19,600
Delta then what change and where is it

00:31:17,650 --> 00:31:21,940
changing so my tools on the client can

00:31:19,600 --> 00:31:25,950
just pop it into my data store

00:31:21,940 --> 00:31:29,170
and everything will be updated magically

00:31:25,950 --> 00:31:31,750
so I don't have a lot of time but so you

00:31:29,170 --> 00:31:34,420
can use graphical graphical live lives

00:31:31,750 --> 00:31:37,150
live queries today how can you do that

00:31:34,420 --> 00:31:39,190
well you can use all the existing stuff

00:31:37,150 --> 00:31:41,470
that I showed you like like firestorm

00:31:39,190 --> 00:31:43,210
but in that context you put fire store

00:31:41,470 --> 00:31:45,340
where I think it belongs

00:31:43,210 --> 00:31:47,530
it belongs as your reactive database

00:31:45,340 --> 00:31:49,630
notice the solution for your whole thing

00:31:47,530 --> 00:31:52,330
the tea and you can easily migrate from

00:31:49,630 --> 00:31:54,430
you can use react rethink the be you can

00:31:52,330 --> 00:31:56,770
use meteor but then there's the new

00:31:54,430 --> 00:31:59,850
thing which I want to this is the first

00:31:56,770 --> 00:32:02,710
time I'm talking about it but there's

00:31:59,850 --> 00:32:05,500
 3.6 I don't know if you heard is

00:32:02,710 --> 00:32:07,450
gonna come out with a new change stream

00:32:05,500 --> 00:32:09,730
ability kind of like what we think the

00:32:07,450 --> 00:32:13,330
bee is doing it's very new but in it in

00:32:09,730 --> 00:32:16,180
RX r c0 it was published two weeks ago

00:32:13,330 --> 00:32:19,630
and actually that week this week and I

00:32:16,180 --> 00:32:22,960
wrote for that talk the library called

00:32:19,630 --> 00:32:27,910
the RX GS which now you can use

00:32:22,960 --> 00:32:29,410
that and it's under my github and yeah

00:32:27,910 --> 00:32:32,350
like one minute I'm finishing and

00:32:29,410 --> 00:32:33,820
promise and you can use it today and

00:32:32,350 --> 00:32:36,130
then it means that if you use

00:32:33,820 --> 00:32:37,660
today you can also get live queries you

00:32:36,130 --> 00:32:38,640
don't need to move in two different

00:32:37,660 --> 00:32:43,360
things

00:32:38,640 --> 00:32:46,750
okay I'm finishing up so again our

00:32:43,360 --> 00:32:50,080
service is bad no they're great but if

00:32:46,750 --> 00:32:52,390
you would use all it today you can use

00:32:50,080 --> 00:32:55,180
in all the end of the solutions you can

00:32:52,390 --> 00:32:57,100
use standard protocols and that means

00:32:55,180 --> 00:32:58,810
that you can migrate from a solution you

00:32:57,100 --> 00:33:02,080
can put the solution where they belong

00:32:58,810 --> 00:33:07,210
to so some libraries that you can use

00:33:02,080 --> 00:33:09,270
are here and also I wrote a lot of

00:33:07,210 --> 00:33:12,730
examples for many many different

00:33:09,270 --> 00:33:14,740
implementations and and technologies

00:33:12,730 --> 00:33:16,180
under my github repo I won't cover it

00:33:14,740 --> 00:33:22,930
because I'm being thrown out of the

00:33:16,180 --> 00:33:25,510
stage I'll just ask one last thing let's

00:33:22,930 --> 00:33:28,600
all together request from the service

00:33:25,510 --> 00:33:32,170
providers to move to a standard protocol

00:33:28,600 --> 00:33:34,180
over their solutions so we can have more

00:33:32,170 --> 00:33:35,740
power in using them the way that we want

00:33:34,180 --> 00:33:37,630
and if they want do

00:33:35,740 --> 00:33:40,120
you can just go to my determine do it

00:33:37,630 --> 00:33:43,420
yourself thank you great thank you very

00:33:40,120 --> 00:33:43,920
much for you thank you very much for the

00:33:43,420 --> 00:33:46,270
talk

00:33:43,920 --> 00:33:49,510
unfortunately he's eaten through the the

00:33:46,270 --> 00:33:50,920
time for QA but where can the guys find

00:33:49,510 --> 00:33:53,530
you during the coffee break if they want

00:33:50,920 --> 00:33:56,380
to you know talk to one-on-one right

00:33:53,530 --> 00:33:58,450
there yeah right there great so after

00:33:56,380 --> 00:34:00,490
this talk you'll be there for asking

00:33:58,450 --> 00:34:02,410
questions you know the old school way on

00:34:00,490 --> 00:34:05,490
offline what do you think you so much

00:34:02,410 --> 00:34:05,490
ready she ate it thank you

00:34:11,510 --> 00:34:13,570

YouTube URL: https://www.youtube.com/watch?v=Wi7P39sF2nw


