Title: ReactiveConf 2018 â€“ David Khourshid: Reactive State Machines and Statecharts
Publication date: 2018-11-03
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Main stage
-------------------------------------------------------------------
Reactive State Machines and Statecharts

Have you ever worked on an app that started off simple, but as the number of features, states, and edge cases grew, it became much more difficult to maintain? Most of us know this struggle all too well. As the number of possible states in your app grows, developing UIs can become exponentially more complex. With the help of finite state machines (FSMs) and statecharts, you will be able to manage your app's states in a simple, robust way, and even visualize them, and interpret them reactively, with the help of xstate and RxJS From traffic lights to avionics systems and space missions, FSMs and statecharts have been used in many critical systems and user interfaces worldwide for decades. By taking a top-down approach of formalizing your app's states and actions into declarative statecharts, you can develop apps that are robust, testable, extendable, and easily communicable with project managers and designers. In this session, we'll learn what FSMs and statecharts are and how they can take your UIs to the next level, with innovative techniques for implementing, testing, and visualizing your app's finite states in a robust, automated way. There will plenty of use cases, resources, and real-life examples that work in any framework, or even plain JS.
Captions: 
	00:00:02,210 --> 00:00:08,680
[Music]

00:00:12,720 --> 00:00:18,779
all right well we are all here for one

00:00:16,270 --> 00:00:21,939
reason and that reason is because

00:00:18,779 --> 00:00:25,390
reactive systems are difficult to

00:00:21,939 --> 00:00:26,919
develop I mean that's the reason we're

00:00:25,390 --> 00:00:28,419
all here and it doesn't matter whether

00:00:26,919 --> 00:00:30,220
you're working in the front end or the

00:00:28,419 --> 00:00:32,380
back end when we're dealing with

00:00:30,220 --> 00:00:35,950
reactive systems that's systems that

00:00:32,380 --> 00:00:37,870
work when events come over time then we

00:00:35,950 --> 00:00:41,310
have so many problems to think about and

00:00:37,870 --> 00:00:44,620
so much complexity that's a possibility

00:00:41,310 --> 00:00:49,360
so my name is David courseid also known

00:00:44,620 --> 00:00:52,780
as at David Kay piano and I do this

00:00:49,360 --> 00:00:54,880
weekly show called the key framers and I

00:00:52,780 --> 00:00:57,250
do it with my friends Shaw and what we

00:00:54,880 --> 00:00:59,740
do is we tackle these complex user

00:00:57,250 --> 00:01:03,760
interfaces and we try to recreate them

00:00:59,740 --> 00:01:06,970
using HTML CSS and only a little bit of

00:01:03,760 --> 00:01:11,229
JavaScript and so as we do all these we

00:01:06,970 --> 00:01:13,179
we start to discover patterns where your

00:01:11,229 --> 00:01:14,619
application or your user interfaces

00:01:13,179 --> 00:01:17,289
could be in different states at

00:01:14,619 --> 00:01:21,009
different times and you have to handle

00:01:17,289 --> 00:01:24,249
and predict how you should handle for

00:01:21,009 --> 00:01:29,399
example animations or user application

00:01:24,249 --> 00:01:29,399
behavior based on what happens over time

00:01:29,429 --> 00:01:34,329
so just to describe what what the

00:01:32,530 --> 00:01:36,310
problem is in an example let's say that

00:01:34,329 --> 00:01:38,799
you have a button this fetch data button

00:01:36,310 --> 00:01:41,880
right here and it does just as you would

00:01:38,799 --> 00:01:45,670
expect you press the button and

00:01:41,880 --> 00:01:47,979
eventually you get a results so now

00:01:45,670 --> 00:01:51,369
let's see what happens when that

00:01:47,979 --> 00:01:53,770
operation takes a little bit of time so

00:01:51,369 --> 00:01:56,829
we could show a spinner sure that helps

00:01:53,770 --> 00:01:59,709
right that tells the user hey your dad

00:01:56,829 --> 00:02:04,599
is coming eventually and then we get the

00:01:59,709 --> 00:02:08,440
data but that's not always how users

00:02:04,599 --> 00:02:11,380
behave for instance if I saw this screen

00:02:08,440 --> 00:02:13,570
and it was taking maybe 10 15 seconds

00:02:11,380 --> 00:02:16,870
you better believe I would be pressing

00:02:13,570 --> 00:02:18,370
that button repeatedly until and making

00:02:16,870 --> 00:02:20,739
all of these API requests but

00:02:18,370 --> 00:02:22,870
you as a developer your smarts your

00:02:20,739 --> 00:02:25,599
liking I know what I'm gonna do I'm

00:02:22,870 --> 00:02:28,420
going to disable that button and that

00:02:25,599 --> 00:02:31,420
way the users never going to you know be

00:02:28,420 --> 00:02:34,810
able to click it more than once but what

00:02:31,420 --> 00:02:38,799
if your user is me and I go into the dev

00:02:34,810 --> 00:02:41,290
tools and I make it enabled again now I

00:02:38,799 --> 00:02:42,579
could just keep making API requests so

00:02:41,290 --> 00:02:45,340
in my opinion the most neglected

00:02:42,579 --> 00:02:49,090
variable in software programming is time

00:02:45,340 --> 00:02:50,980
sure we could think of our applications

00:02:49,090 --> 00:02:54,209
on the front-end back-end

00:02:50,980 --> 00:02:57,849
user interfaces as you get a state and

00:02:54,209 --> 00:02:59,859
when an event occurs you get a next

00:02:57,849 --> 00:03:01,959
state we've seen this equation many

00:02:59,859 --> 00:03:04,720
times but this doesn't tell the full

00:03:01,959 --> 00:03:07,390
story in fact we have to think about

00:03:04,720 --> 00:03:09,879
what happens over time where when an

00:03:07,390 --> 00:03:12,040
event occurs we get a next state but

00:03:09,879 --> 00:03:14,500
then we have effects that happen too and

00:03:12,040 --> 00:03:17,590
these effects could in turn send more

00:03:14,500 --> 00:03:19,269
events and so we have so many different

00:03:17,590 --> 00:03:23,650
ways of dealing with time whether it's

00:03:19,269 --> 00:03:25,329
callbacks promises async await or my

00:03:23,650 --> 00:03:31,720
favorite which was just talked about

00:03:25,329 --> 00:03:33,629
observe a balls so we we have many

00:03:31,720 --> 00:03:36,310
different solutions to this problem but

00:03:33,629 --> 00:03:38,709
we don't have a very precise way of

00:03:36,310 --> 00:03:41,590
describing it and so we end up with code

00:03:38,709 --> 00:03:44,859
like this for example let's let's put

00:03:41,590 --> 00:03:46,840
our actual fetch button to code so we

00:03:44,859 --> 00:03:49,239
have a search request here we have in

00:03:46,840 --> 00:03:50,530
the events handler and we're fetching

00:03:49,239 --> 00:03:52,419
the data and then we show the data when

00:03:50,530 --> 00:03:54,790
the results are retrieved but of course

00:03:52,419 --> 00:03:57,699
we need to add a loading indicator and

00:03:54,790 --> 00:04:00,280
so we go ahead and do that so we have a

00:03:57,699 --> 00:04:02,709
loading flag but we also have to turn

00:04:00,280 --> 00:04:04,150
that loading flag false when we get the

00:04:02,709 --> 00:04:07,329
data just so that we're not showing a

00:04:04,150 --> 00:04:09,150
spinner but what if there's an error so

00:04:07,329 --> 00:04:13,599
now we have an error flag and that

00:04:09,150 --> 00:04:15,310
boolean flag we have to set it to true

00:04:13,599 --> 00:04:16,780
and set the loading black to false

00:04:15,310 --> 00:04:20,049
because we don't want to show it loading

00:04:16,780 --> 00:04:21,760
and then the error at the same time okay

00:04:20,049 --> 00:04:24,039
so now what if we try to restart the

00:04:21,760 --> 00:04:28,360
search then we have to reset those flags

00:04:24,039 --> 00:04:30,280
set loading to true error to false it's

00:04:28,360 --> 00:04:32,139
the right looking a little complex so

00:04:30,280 --> 00:04:33,939
now we have to get even further

00:04:32,139 --> 00:04:36,039
let's say we want to cancel the search

00:04:33,939 --> 00:04:38,110
request I don't know if you could see

00:04:36,039 --> 00:04:43,389
that let me zoom in for you

00:04:38,110 --> 00:04:45,279
this gets extremely complicated and and

00:04:43,389 --> 00:04:48,490
so this is called the bottom-up approach

00:04:45,279 --> 00:04:51,669
and that's when we stuff a lot of logic

00:04:48,490 --> 00:04:53,499
into our event listeners in this logic

00:04:51,669 --> 00:04:55,749
could be all sorts of logic conditional

00:04:53,499 --> 00:04:58,270
logic business logic party logic I don't

00:04:55,749 --> 00:05:00,400
know side effects you could update state

00:04:58,270 --> 00:05:02,800
maybe have another side effect you could

00:05:00,400 --> 00:05:04,930
have a sync operations inside your event

00:05:02,800 --> 00:05:06,610
handler you know make some updates to

00:05:04,930 --> 00:05:09,580
either local or global state and

00:05:06,610 --> 00:05:12,009
eventually you know you you want to test

00:05:09,580 --> 00:05:15,490
but it's so complex that you don't even

00:05:12,009 --> 00:05:17,680
know where to start so this is called

00:05:15,490 --> 00:05:20,050
bottom-up code and bottom-up code has a

00:05:17,680 --> 00:05:22,539
few attributes first of all it's very

00:05:20,050 --> 00:05:24,270
difficult to test because things inside

00:05:22,539 --> 00:05:27,400
your event handlers happen over time

00:05:24,270 --> 00:05:29,680
it's difficult to understand - if you

00:05:27,400 --> 00:05:30,849
tried to describe a feature you have to

00:05:29,680 --> 00:05:33,490
look at so many different events

00:05:30,849 --> 00:05:36,699
handlers to see where this feature is

00:05:33,490 --> 00:05:38,650
defined it will contain bugs just

00:05:36,699 --> 00:05:42,279
because you can't test every single

00:05:38,650 --> 00:05:44,620
possible use case it's difficult to

00:05:42,279 --> 00:05:46,930
enhance so when someone comes to you and

00:05:44,620 --> 00:05:48,909
says we need to add a feature it becomes

00:05:46,930 --> 00:05:50,560
very difficult - because you need to

00:05:48,909 --> 00:05:53,439
understand the logic in all of your

00:05:50,560 --> 00:05:55,479
event handlers and features in fact make

00:05:53,439 --> 00:05:57,479
it worse because they increase the

00:05:55,479 --> 00:06:00,969
complexity of your application behavior

00:05:57,479 --> 00:06:02,680
so I play piano you know that's why my

00:06:00,969 --> 00:06:06,430
name is David KPI my last name is not

00:06:02,680 --> 00:06:08,289
piano but I play piano so that's why

00:06:06,430 --> 00:06:10,360
and so in Vienna we have this thing

00:06:08,289 --> 00:06:12,029
called music notation but the

00:06:10,360 --> 00:06:15,189
interesting about this is that this is

00:06:12,029 --> 00:06:17,289
understandable by anyone who plays any

00:06:15,189 --> 00:06:19,180
instruments and has had musical training

00:06:17,289 --> 00:06:20,860
it doesn't matter which instrument I

00:06:19,180 --> 00:06:22,810
mean you probably can't play this on

00:06:20,860 --> 00:06:24,310
I don't know guitar or something this is

00:06:22,810 --> 00:06:26,259
mostly a piano thing but at least you

00:06:24,310 --> 00:06:30,699
could read it you could understand it

00:06:26,259 --> 00:06:32,500
and so as a musician I constantly think

00:06:30,699 --> 00:06:35,620
can we have something like this for

00:06:32,500 --> 00:06:38,199
software where we could model the

00:06:35,620 --> 00:06:39,939
behavior in a declarative way and reuse

00:06:38,199 --> 00:06:42,219
it no matter what framework we're using

00:06:39,939 --> 00:06:44,000
what libraries were using or even what

00:06:42,219 --> 00:06:45,920
languages were using

00:06:44,000 --> 00:06:48,620
and so that brings me the finite state

00:06:45,920 --> 00:06:50,030
machines and state charts some of you

00:06:48,620 --> 00:06:52,610
might have taken this class in

00:06:50,030 --> 00:06:55,400
university or looked up a Wikipedia

00:06:52,610 --> 00:06:57,590
article it looks really nasty so just

00:06:55,400 --> 00:07:00,860
try not to go that route I'm gonna try

00:06:57,590 --> 00:07:03,170
to explain it to you real quick so a

00:07:00,860 --> 00:07:05,030
finite state machine has one initial

00:07:03,170 --> 00:07:07,130
State that's your starting state where

00:07:05,030 --> 00:07:09,320
your app starts at it has a finite

00:07:07,130 --> 00:07:12,140
number of states that your app could be

00:07:09,320 --> 00:07:14,600
in and then we have to define what the

00:07:12,140 --> 00:07:17,750
user or what other events can happen

00:07:14,600 --> 00:07:20,210
that transition between those states and

00:07:17,750 --> 00:07:23,000
then we have some final states which

00:07:20,210 --> 00:07:26,570
tell the the overall state machine were

00:07:23,000 --> 00:07:29,750
done processing so let's take a look

00:07:26,570 --> 00:07:31,880
back at our Fetchit components so we

00:07:29,750 --> 00:07:34,040
have an idle state and then when we do a

00:07:31,880 --> 00:07:36,620
search event we go to this searching

00:07:34,040 --> 00:07:38,750
state and now we could define the search

00:07:36,620 --> 00:07:40,400
events to not do anything to stay in

00:07:38,750 --> 00:07:42,110
that searching state instead of

00:07:40,400 --> 00:07:44,090
repeating the action of searching and

00:07:42,110 --> 00:07:46,640
then depending on whether we resolve or

00:07:44,090 --> 00:07:49,250
rejects that promise we go to a success

00:07:46,640 --> 00:07:52,669
or failure State this is understandable

00:07:49,250 --> 00:07:54,260
by anyone no matter if they know

00:07:52,669 --> 00:07:56,210
programming or they don't know

00:07:54,260 --> 00:07:59,090
programming all you have to do is follow

00:07:56,210 --> 00:08:00,800
the arrows and events and you could it's

00:07:59,090 --> 00:08:02,960
just like a follow your own adventure

00:08:00,800 --> 00:08:05,870
type of thing so what does this look

00:08:02,960 --> 00:08:07,310
like in code the way I write it you

00:08:05,870 --> 00:08:10,300
could write it using switch statements

00:08:07,310 --> 00:08:12,800
but I prefer to use object notation and

00:08:10,300 --> 00:08:14,780
there's a few good reasons why first of

00:08:12,800 --> 00:08:16,970
all we could enumerate all of these

00:08:14,780 --> 00:08:20,180
states and it's a little bit more

00:08:16,970 --> 00:08:22,820
concise than switch notation to and so

00:08:20,180 --> 00:08:25,280
we're defining here transitions between

00:08:22,820 --> 00:08:27,080
states so here's all of our states we

00:08:25,280 --> 00:08:31,340
have idle searching success in failure

00:08:27,080 --> 00:08:34,159
and then whenever an event occurs we map

00:08:31,340 --> 00:08:35,900
it to what the next state should be it's

00:08:34,159 --> 00:08:38,210
that simple and so our transition

00:08:35,900 --> 00:08:41,180
function but this is all it has to be

00:08:38,210 --> 00:08:43,610
it's a simple object to lookup you get

00:08:41,180 --> 00:08:46,040
the state whenever you receive event

00:08:43,610 --> 00:08:49,370
look up what the next state should be

00:08:46,040 --> 00:08:52,040
based on that event and in fact you

00:08:49,370 --> 00:08:53,660
could put it inside of a react I know

00:08:52,040 --> 00:08:56,180
we're all talking about react hooks so I

00:08:53,660 --> 00:08:57,950
decide to make my own and so here's a

00:08:56,180 --> 00:09:01,639
simple traffic light example

00:08:57,950 --> 00:09:03,110
in react and so here's what it looks

00:09:01,639 --> 00:09:05,779
like in real life I'm doing story the

00:09:03,110 --> 00:09:07,730
same thing here using my library X date

00:09:05,779 --> 00:09:09,889
which is the same notation that you saw

00:09:07,730 --> 00:09:12,110
but it's a library that handles a few

00:09:09,889 --> 00:09:15,410
more things so for example this is a

00:09:12,110 --> 00:09:19,550
Flickr application and so if I type

00:09:15,410 --> 00:09:22,660
Prague do the search event and I cancel

00:09:19,550 --> 00:09:25,220
I have cancellation built in because

00:09:22,660 --> 00:09:28,519
when I go to cancel it goes to the

00:09:25,220 --> 00:09:31,070
gallery States and so on search success

00:09:28,519 --> 00:09:33,709
there's no advance transition defined

00:09:31,070 --> 00:09:36,800
for that event so we get natural

00:09:33,709 --> 00:09:40,160
cancellation and then you see we could

00:09:36,800 --> 00:09:46,240
model things pretty clearly that looks

00:09:40,160 --> 00:09:48,740
pretty good by just at lunch so yeah and

00:09:46,240 --> 00:09:50,600
so with this software books are made

00:09:48,740 --> 00:09:52,940
visually clear if you were to make a

00:09:50,600 --> 00:09:55,490
simple application like this where you

00:09:52,940 --> 00:09:57,380
have idle loading success all of your

00:09:55,490 --> 00:10:00,230
code works all of your unit tests fast

00:09:57,380 --> 00:10:03,310
good for you your codes broken still and

00:10:00,230 --> 00:10:06,019
here's why what's wrong with this code

00:10:03,310 --> 00:10:08,180
take a look at the loading state what

00:10:06,019 --> 00:10:11,360
happens if we have an error this is

00:10:08,180 --> 00:10:14,630
something that linters and type systems

00:10:11,360 --> 00:10:19,940
and so on for the most part scans check

00:10:14,630 --> 00:10:22,250
and so we should define a state to

00:10:19,940 --> 00:10:24,949
handle the error but then there's

00:10:22,250 --> 00:10:27,709
another problem this failure state it

00:10:24,949 --> 00:10:29,480
has no way to go back so we could

00:10:27,709 --> 00:10:31,910
visually see clearly that we're missing

00:10:29,480 --> 00:10:33,079
a transition from failure back to

00:10:31,910 --> 00:10:35,600
loading so that we could retry that

00:10:33,079 --> 00:10:38,060
request and this is made visually clear

00:10:35,600 --> 00:10:42,319
by visualizing the state machine so does

00:10:38,060 --> 00:10:44,390
this scale no it doesn't but that's why

00:10:42,319 --> 00:10:46,910
there's state charts also known as

00:10:44,390 --> 00:10:49,970
extended or hierarchical state machines

00:10:46,910 --> 00:10:53,120
and it's a visual formalism for complex

00:10:49,970 --> 00:10:55,029
systems made for reactive systems and

00:10:53,120 --> 00:10:59,360
this was invented by David Harrell in

00:10:55,029 --> 00:11:01,730
1997 to give you an idea that's over 20

00:10:59,360 --> 00:11:05,180
30 I cants math right now but it's like

00:11:01,730 --> 00:11:07,850
many many decades ago so none of this is

00:11:05,180 --> 00:11:09,589
a new idea these are very old ideas that

00:11:07,850 --> 00:11:10,950
have been used in many industries in

00:11:09,589 --> 00:11:13,890
having proven time and time

00:11:10,950 --> 00:11:16,950
again to work so state charts add a

00:11:13,890 --> 00:11:19,620
little bit more first of all we add

00:11:16,950 --> 00:11:21,750
actions we have on inch reactions on

00:11:19,620 --> 00:11:24,720
exit actions and actions within

00:11:21,750 --> 00:11:26,640
transitions and actions are those side

00:11:24,720 --> 00:11:28,230
effects that I was talking about those

00:11:26,640 --> 00:11:30,960
are the things that actually make your

00:11:28,230 --> 00:11:34,280
application do things like display to

00:11:30,960 --> 00:11:37,290
the screen send a fetch request etc

00:11:34,280 --> 00:11:38,940
guards are what prevents transitions

00:11:37,290 --> 00:11:41,880
from happening if certain conditions

00:11:38,940 --> 00:11:43,920
aren't met and then we have ways to

00:11:41,880 --> 00:11:46,410
simplify state machines and this is

00:11:43,920 --> 00:11:48,690
where state charts scale you could nest

00:11:46,410 --> 00:11:50,880
dates together you could do parallel

00:11:48,690 --> 00:11:53,430
states which we'll explain in a bit but

00:11:50,880 --> 00:11:56,220
that means that you could have two two

00:11:53,430 --> 00:11:59,310
states that are both active at the same

00:11:56,220 --> 00:12:02,010
time and you have other cool little

00:11:59,310 --> 00:12:04,020
things like history and things like that

00:12:02,010 --> 00:12:05,100
so here's where parallel states come in

00:12:04,020 --> 00:12:08,010
handy

00:12:05,100 --> 00:12:10,950
there's a thing called Carta I think

00:12:08,010 --> 00:12:13,080
Cartesian the Cartesian product where

00:12:10,950 --> 00:12:14,850
let's say that you're modeling a text

00:12:13,080 --> 00:12:17,250
editor and you have bold italic and

00:12:14,850 --> 00:12:19,410
underlined buttons to model the state of

00:12:17,250 --> 00:12:21,600
your text editor you have to take in

00:12:19,410 --> 00:12:24,300
accounts the on/off States of each of

00:12:21,600 --> 00:12:26,580
those buttons which if you remember your

00:12:24,300 --> 00:12:28,770
permutations combinations that's through

00:12:26,580 --> 00:12:30,960
the power of three or eight states add

00:12:28,770 --> 00:12:35,600
another one such as strikethrough that

00:12:30,960 --> 00:12:38,370
becomes 16 32 64 it exponentially grows

00:12:35,600 --> 00:12:41,490
with state charts we could simplify that

00:12:38,370 --> 00:12:44,310
by just making those orthogonal regions

00:12:41,490 --> 00:12:48,090
or regions that don't really affect one

00:12:44,310 --> 00:12:51,180
another and so nesting helps simplify

00:12:48,090 --> 00:12:52,560
your same machines in the same way for

00:12:51,180 --> 00:12:55,260
instance over here we see that the

00:12:52,560 --> 00:12:57,600
success and failure state have the same

00:12:55,260 --> 00:12:59,880
outgoing transitions on the search

00:12:57,600 --> 00:13:01,290
events they both go to surgery so we

00:12:59,880 --> 00:13:04,050
could group those two states and

00:13:01,290 --> 00:13:07,890
simplify the behavior of both of them

00:13:04,050 --> 00:13:11,310
and so here's an example I love doing

00:13:07,890 --> 00:13:13,770
reactive animations and so this is one

00:13:11,310 --> 00:13:17,810
that I saw and it was complex enough

00:13:13,770 --> 00:13:23,340
that I modeled it as a state charts

00:13:17,810 --> 00:13:24,920
write down yeah right down here and I'll

00:13:23,340 --> 00:13:28,550
show you this day turnin in it but

00:13:24,920 --> 00:13:35,070
when I first saw the animation it was

00:13:28,550 --> 00:13:36,779
not working it was complex enough that I

00:13:35,070 --> 00:13:38,279
had to think about all of the possible

00:13:36,779 --> 00:13:40,620
different states that could be for

00:13:38,279 --> 00:13:42,420
example this rectangle dragging what

00:13:40,620 --> 00:13:45,260
happens if I let go without selecting in

00:13:42,420 --> 00:13:47,460
elements you have to keep that in mind

00:13:45,260 --> 00:13:49,589
but now I'm in the state where I have

00:13:47,460 --> 00:13:52,710
elements selected so now dragging is

00:13:49,589 --> 00:13:54,720
going to do something different it's

00:13:52,710 --> 00:13:58,440
going to allow me to get rid of these

00:13:54,720 --> 00:14:03,120
days and make my weekends a little bit

00:13:58,440 --> 00:14:07,440
longer and so the cool thing about this

00:14:03,120 --> 00:14:10,490
is this model as a state machine I could

00:14:07,440 --> 00:14:13,860
copy and paste this configuration and

00:14:10,490 --> 00:14:16,430
visualize it and so this is not a manual

00:14:13,860 --> 00:14:18,360
step it's an automatic step where the

00:14:16,430 --> 00:14:20,910
visualization of the state machine is

00:14:18,360 --> 00:14:23,790
over here for you you see every single

00:14:20,910 --> 00:14:26,279
state automatically generated on this

00:14:23,790 --> 00:14:28,500
visualizer and so if we go back to the

00:14:26,279 --> 00:14:31,080
gallery example you could see that

00:14:28,500 --> 00:14:32,610
that's exactly what I did here and not

00:14:31,080 --> 00:14:34,650
only could you visualize it you could

00:14:32,610 --> 00:14:38,190
simulate what happens when certain

00:14:34,650 --> 00:14:40,800
events occur and so this becomes a very

00:14:38,190 --> 00:14:44,880
powerful tool for showing stakeholders

00:14:40,800 --> 00:14:47,220
or project managers and so on so as I

00:14:44,880 --> 00:14:51,000
mentioned I was working on this library

00:14:47,220 --> 00:14:53,880
called X dates for a while now and I

00:14:51,000 --> 00:14:55,140
just write it over here I'm blind

00:14:53,880 --> 00:14:57,210
because the lights are right in my eyes

00:14:55,140 --> 00:15:02,250
but I want to know how many of you are

00:14:57,210 --> 00:15:03,780
actually using X date in your job okay

00:15:02,250 --> 00:15:08,430
I'm gonna assume a few hands are up

00:15:03,780 --> 00:15:10,080
anyway so X date it handles finite state

00:15:08,430 --> 00:15:11,370
machines but it also handles many

00:15:10,080 --> 00:15:13,860
aspects of state charts like

00:15:11,370 --> 00:15:16,560
hierarchical States parallel States

00:15:13,860 --> 00:15:19,560
actions which are declarative side

00:15:16,560 --> 00:15:22,410
effects that you could model and mock if

00:15:19,560 --> 00:15:26,040
you want history states conditional

00:15:22,410 --> 00:15:29,450
transitions and a few more things and so

00:15:26,040 --> 00:15:36,390
I want to show you a quick preview of

00:15:29,450 --> 00:15:38,339
what's coming up so the next date I've

00:15:36,390 --> 00:15:40,740
been working on a few things

00:15:38,339 --> 00:15:44,189
and one of the things is called the

00:15:40,740 --> 00:15:46,259
assigned property and this is a or the

00:15:44,189 --> 00:15:49,199
assigned method and so this is a

00:15:46,259 --> 00:15:51,149
declarative way of updating your data so

00:15:49,199 --> 00:15:53,160
you define your state machine here now

00:15:51,149 --> 00:15:56,519
we've all programmed something like a

00:15:53,160 --> 00:15:59,279
tic-tac-toe application those are not

00:15:56,519 --> 00:16:01,709
difficult to do so I decided to model it

00:15:59,279 --> 00:16:02,579
as a state machine where we're in one of

00:16:01,709 --> 00:16:06,629
three states

00:16:02,579 --> 00:16:10,470
we're either playing X 0 X 0 we have a

00:16:06,629 --> 00:16:13,350
winner or we draw and whenever we're

00:16:10,470 --> 00:16:15,930
playing we check if there's a winner or

00:16:13,350 --> 00:16:18,240
if there's a draw and as long as the

00:16:15,930 --> 00:16:20,999
move is valid we update the board using

00:16:18,240 --> 00:16:23,759
those assign actions so in this way it's

00:16:20,999 --> 00:16:25,860
sort of like Redux so you get an event

00:16:23,759 --> 00:16:30,990
and then you handle what happens with

00:16:25,860 --> 00:16:32,939
that event and so the result is this you

00:16:30,990 --> 00:16:36,420
have a live game where you know you

00:16:32,939 --> 00:16:40,050
could see who wins who loses you know

00:16:36,420 --> 00:16:45,029
you could do a draw if I could oh oh one

00:16:40,050 --> 00:16:49,259
well anyway so you might be thinking

00:16:45,029 --> 00:16:51,389
this is cool I guess you're just you're

00:16:49,259 --> 00:16:53,939
just programming this in a different way

00:16:51,389 --> 00:16:55,170
I already know how to do this with redux

00:16:53,939 --> 00:16:56,970
I already know how to do this with my

00:16:55,170 --> 00:17:00,029
backs heck I don't even need a library

00:16:56,970 --> 00:17:02,129
to do this so why would I want to model

00:17:00,029 --> 00:17:04,020
like go through the trouble of modeling

00:17:02,129 --> 00:17:05,069
it as a state machine or state chart I'm

00:17:04,020 --> 00:17:06,419
wondering if that's actually one of the

00:17:05,069 --> 00:17:08,689
questions I can't see it right now but

00:17:06,419 --> 00:17:11,339
model a that's a state chart and

00:17:08,689 --> 00:17:14,909
actually you know do something with it

00:17:11,339 --> 00:17:18,630
so what I did and of course this is a

00:17:14,909 --> 00:17:21,990
react application using that exact same

00:17:18,630 --> 00:17:24,179
state machine what I did was there's

00:17:21,990 --> 00:17:26,370
this get shortest value pass function

00:17:24,179 --> 00:17:28,559
that's available in x8 and that does

00:17:26,370 --> 00:17:31,049
some graph theory algorithms where

00:17:28,559 --> 00:17:34,070
basically traces all of the shortest

00:17:31,049 --> 00:17:38,159
paths throughout the state machine and

00:17:34,070 --> 00:17:43,049
using this I want to see which of those

00:17:38,159 --> 00:17:46,080
paths results in a draw and so these

00:17:43,049 --> 00:17:47,760
paths which are pairings of states and

00:17:46,080 --> 00:17:49,710
events and states and events so just

00:17:47,760 --> 00:17:51,110
like a do this and do that then do this

00:17:49,710 --> 00:17:54,590
and do that

00:17:51,110 --> 00:17:57,650
I'm looping through them and I'm using

00:17:54,590 --> 00:17:59,059
puppeteer to actually you know click the

00:17:57,650 --> 00:18:00,740
right elements and map like for example

00:17:59,059 --> 00:18:03,170
this play event

00:18:00,740 --> 00:18:12,679
it's just clicking the correct square

00:18:03,170 --> 00:18:15,920
and so if all goes well come on it will

00:18:12,679 --> 00:18:18,710
stimulate every single possible game

00:18:15,920 --> 00:18:20,570
state in which a draw occurs by actually

00:18:18,710 --> 00:18:23,270
playing through the game I didn't tell

00:18:20,570 --> 00:18:24,950
my tests how to play tic-tac-toe I just

00:18:23,270 --> 00:18:26,929
gave it the exact same state machine

00:18:24,950 --> 00:18:29,480
that I used for my application and you

00:18:26,929 --> 00:18:32,390
could see it's generating all of those

00:18:29,480 --> 00:18:34,940
possible play States and so I could go

00:18:32,390 --> 00:18:37,790
further I could ask it like show me all

00:18:34,940 --> 00:18:41,929
of the games where X wins and five moves

00:18:37,790 --> 00:18:45,620
are less for example and so all of this

00:18:41,929 --> 00:18:47,809
is now available in X date version four

00:18:45,620 --> 00:18:50,360
which I literally just released a half

00:18:47,809 --> 00:18:52,669
hour ago and so it includes a few extra

00:18:50,360 --> 00:18:55,730
things such as external state delayed

00:18:52,669 --> 00:18:58,400
transitions and events an interpreter so

00:18:55,730 --> 00:19:00,290
you don't have to roll your own final

00:18:58,400 --> 00:19:03,049
states which are very very useful for

00:19:00,290 --> 00:19:04,520
modeling simultaneous processes and

00:19:03,049 --> 00:19:06,710
making sure that they all finished

00:19:04,520 --> 00:19:08,510
sort of like promised at all invoking

00:19:06,710 --> 00:19:11,330
external machines which have been a big

00:19:08,510 --> 00:19:13,100
question like why would I model my

00:19:11,330 --> 00:19:14,809
application is a huge state machine you

00:19:13,100 --> 00:19:16,910
shouldn't you should be using multiple

00:19:14,809 --> 00:19:19,820
state machines that all communicate with

00:19:16,910 --> 00:19:22,280
each other and new visualization and

00:19:19,820 --> 00:19:24,380
simulation tools which are coming up and

00:19:22,280 --> 00:19:26,990
there's so much more and I probably

00:19:24,380 --> 00:19:29,900
don't have time to talk about all of

00:19:26,990 --> 00:19:32,540
that but one big thing that I want to

00:19:29,900 --> 00:19:34,850
emphasize is that X States and these

00:19:32,540 --> 00:19:38,540
tools that I'm working on are nothing

00:19:34,850 --> 00:19:41,840
invented in fact as I said stay charts

00:19:38,540 --> 00:19:43,640
were invented in 1997 and they've been

00:19:41,840 --> 00:19:46,040
used in many different technological

00:19:43,640 --> 00:19:48,770
fields such as automotive technology

00:19:46,040 --> 00:19:51,919
embedded electronics avionics and more

00:19:48,770 --> 00:19:55,040
and there's even a w3c standard for it

00:19:51,919 --> 00:19:57,770
that's been out since September 2015 and

00:19:55,040 --> 00:20:00,140
this standard is used by tool such as qt

00:19:57,770 --> 00:20:01,610
and you can do state machine tools which

00:20:00,140 --> 00:20:04,429
work for different languages such as

00:20:01,610 --> 00:20:07,610
Python C++

00:20:04,429 --> 00:20:09,740
Java and more and so what that means is

00:20:07,610 --> 00:20:13,279
that the same code that you write for X

00:20:09,740 --> 00:20:16,039
date in theory can work in different

00:20:13,279 --> 00:20:18,799
environments whether you're using C++ or

00:20:16,039 --> 00:20:22,279
Java or Python or anything that can

00:20:18,799 --> 00:20:25,190
interpret this standard and so there's

00:20:22,279 --> 00:20:27,919
many advantages of using statecharts but

00:20:25,190 --> 00:20:30,769
my favorite is this story from NASA

00:20:27,919 --> 00:20:33,889
where they actually used a charts to

00:20:30,769 --> 00:20:36,470
auto code the Curiosity rover now think

00:20:33,889 --> 00:20:38,600
about as an engineer trying to unit test

00:20:36,470 --> 00:20:40,539
this integration test this you want to

00:20:38,600 --> 00:20:43,759
make sure that you have absolutely

00:20:40,539 --> 00:20:46,519
everything modeled because if one thing

00:20:43,759 --> 00:20:48,799
goes wrong if one test fails that's a

00:20:46,519 --> 00:20:50,299
multi-billion dollar mistake you know

00:20:48,799 --> 00:20:53,230
you don't you don't want that on your

00:20:50,299 --> 00:20:55,759
resume so we have visualized modeling

00:20:53,230 --> 00:20:58,039
very precise diagrams that they could

00:20:55,759 --> 00:21:01,009
hand off to designers and project

00:20:58,039 --> 00:21:03,289
managers automatic code generation which

00:21:01,009 --> 00:21:05,299
means they take their diagrams that they

00:21:03,289 --> 00:21:07,580
manually manipulate and they generate

00:21:05,299 --> 00:21:09,740
code from them comprehensive test covers

00:21:07,580 --> 00:21:12,049
that test all possible things that could

00:21:09,740 --> 00:21:14,570
happen and accommodation of

00:21:12,049 --> 00:21:16,100
late-breaking requirement changes this

00:21:14,570 --> 00:21:19,369
is one of the most important ones

00:21:16,100 --> 00:21:20,659
because we've I'm sure all of us are in

00:21:19,369 --> 00:21:23,720
agreement that we've never been in the

00:21:20,659 --> 00:21:27,049
project where changes didn't come later

00:21:23,720 --> 00:21:29,330
and so that's where complexity starts to

00:21:27,049 --> 00:21:31,399
creep in and we have all of these to-do

00:21:29,330 --> 00:21:34,070
comments in our code like get rid of

00:21:31,399 --> 00:21:35,690
this this is a hack that's because of

00:21:34,070 --> 00:21:37,850
these late-breaking requirement changes

00:21:35,690 --> 00:21:41,509
that stay charts because it's visually

00:21:37,850 --> 00:21:43,249
modeled solved for you now of course I

00:21:41,509 --> 00:21:45,350
need to talk about the disadvantages too

00:21:43,249 --> 00:21:47,539
first of all there is a learning curve

00:21:45,350 --> 00:21:49,999
but since stay charts are visual

00:21:47,539 --> 00:21:52,070
learning visual language in a visual

00:21:49,999 --> 00:21:54,379
formalism I find that this learning

00:21:52,070 --> 00:21:56,830
curve is mitigated by just intuitively

00:21:54,379 --> 00:21:59,179
understanding what these diagrams mean

00:21:56,830 --> 00:22:01,309
modeling does require planning ahead

00:21:59,179 --> 00:22:03,379
that doesn't that means you can't just

00:22:01,309 --> 00:22:05,539
go into the code and start coding away

00:22:03,379 --> 00:22:08,629
you actually have to sit down with a

00:22:05,539 --> 00:22:10,429
pencil and paper and actually plan out

00:22:08,629 --> 00:22:12,649
what you're going to code but the good

00:22:10,429 --> 00:22:14,809
thing about that is that once you have

00:22:12,649 --> 00:22:16,660
all of that on paper it becomes really

00:22:14,809 --> 00:22:18,810
easy to transfer the code

00:22:16,660 --> 00:22:21,790
and of course you can't smuggle

00:22:18,810 --> 00:22:24,430
absolutely everything it's not a hammer

00:22:21,790 --> 00:22:26,320
that just works for everything you have

00:22:24,430 --> 00:22:28,840
to pick and choose what parts of your

00:22:26,320 --> 00:22:31,090
application can be modeled as a state

00:22:28,840 --> 00:22:33,970
chart and of course there's complexity

00:22:31,090 --> 00:22:36,670
trade-offs to by what we do using

00:22:33,970 --> 00:22:38,830
bottom-up programming we see a linear

00:22:36,670 --> 00:22:41,890
increasing complexity the more lines of

00:22:38,830 --> 00:22:44,200
code we write with finite state machines

00:22:41,890 --> 00:22:46,120
we see an initial decrease in complexity

00:22:44,200 --> 00:22:48,640
but as we talked about with state

00:22:46,120 --> 00:22:50,770
explosion and all of that that

00:22:48,640 --> 00:22:52,540
exponentially increases with state

00:22:50,770 --> 00:22:54,430
charts there's a higher upfront cost but

00:22:52,540 --> 00:22:58,570
the more complex your application

00:22:54,430 --> 00:23:02,800
becomes the it levels out and it becomes

00:22:58,570 --> 00:23:05,020
easier to manage and so there's a few

00:23:02,800 --> 00:23:07,210
outside sources that I've seen using

00:23:05,020 --> 00:23:09,730
state charts and using my library which

00:23:07,210 --> 00:23:11,410
I'm really excited about first of all

00:23:09,730 --> 00:23:13,810
Brian Florence's workshop taught me

00:23:11,410 --> 00:23:16,690
which is live tech training for industry

00:23:13,810 --> 00:23:19,270
experts he was one of the first to use X

00:23:16,690 --> 00:23:21,610
state when I first announced it a little

00:23:19,270 --> 00:23:23,800
bit over a year ago for the payment flow

00:23:21,610 --> 00:23:26,350
and so I literally dug into the minified

00:23:23,800 --> 00:23:28,480
code looked for be a state chart

00:23:26,350 --> 00:23:30,820
definition and copy pasted into the

00:23:28,480 --> 00:23:32,980
visualizer and you know I saw how

00:23:30,820 --> 00:23:33,460
everything worked so that was pretty

00:23:32,980 --> 00:23:36,700
cool

00:23:33,460 --> 00:23:38,830
and if you're using Gatsby Gatsby uses

00:23:36,700 --> 00:23:42,340
x8 for some of its internal processes

00:23:38,830 --> 00:23:44,740
and so I'm very excited to see that and

00:23:42,340 --> 00:23:47,110
the newest one I've seen was by a

00:23:44,740 --> 00:23:50,140
hatchet Corp who made vagrants their

00:23:47,110 --> 00:23:52,540
vault product they have this advanced

00:23:50,140 --> 00:23:55,090
user flow where they have interactive

00:23:52,540 --> 00:23:57,130
tutorials for the user as they're going

00:23:55,090 --> 00:23:59,800
through their application and so there's

00:23:57,130 --> 00:24:02,290
a quick video of of how that looks and

00:23:59,800 --> 00:24:04,600
so it was really cool to see X state

00:24:02,290 --> 00:24:08,170
being used for this and that is open

00:24:04,600 --> 00:24:09,970
source as well so there's many resources

00:24:08,170 --> 00:24:12,400
and tools on the internet for using

00:24:09,970 --> 00:24:14,770
state machines and state charts and the

00:24:12,400 --> 00:24:16,720
community is growing everyday and I hope

00:24:14,770 --> 00:24:19,090
that you know it grows even more because

00:24:16,720 --> 00:24:21,460
I'm very passionate about it and I want

00:24:19,090 --> 00:24:23,800
more software developers like you all to

00:24:21,460 --> 00:24:26,080
become passionate about it because it

00:24:23,800 --> 00:24:27,580
saves you time and energy and effort and

00:24:26,080 --> 00:24:29,539
it makes things a lot easier for

00:24:27,580 --> 00:24:31,369
everyone involved

00:24:29,539 --> 00:24:35,799
so basically I want you to make your

00:24:31,369 --> 00:24:35,799
code do more Thank You reactive pause

00:24:41,470 --> 00:24:47,809
thank you David for the nice talk in the

00:24:45,500 --> 00:24:51,890
meantime there has been a slider battle

00:24:47,809 --> 00:24:55,070
going on so some people were like relax

00:24:51,890 --> 00:24:57,860
Sokka relax I go go go and the other

00:24:55,070 --> 00:24:59,360
group was like additional state states

00:24:57,860 --> 00:25:05,540
which one do you prefer

00:24:59,360 --> 00:25:07,130
Oh so with with steam machines since

00:25:05,540 --> 00:25:08,809
it's just a transition functions just to

00:25:07,130 --> 00:25:10,309
reduce our function you could use it

00:25:08,809 --> 00:25:13,070
with redux Agha you could use it with

00:25:10,309 --> 00:25:17,030
redux with mob ex with view and Euler

00:25:13,070 --> 00:25:18,650
react so that doesn't really matter how

00:25:17,030 --> 00:25:21,350
do you handle additional state data that

00:25:18,650 --> 00:25:22,700
only exists in certain States will you

00:25:21,350 --> 00:25:25,429
put them into your main state so that

00:25:22,700 --> 00:25:28,280
goes into state machines communicating

00:25:25,429 --> 00:25:29,600
with external state machines so for

00:25:28,280 --> 00:25:33,110
example let's say you're creating a

00:25:29,600 --> 00:25:34,700
to-do list your to-do item could itself

00:25:33,110 --> 00:25:36,919
be its own state machine with its own

00:25:34,700 --> 00:25:38,630
internal state that communicates with

00:25:36,919 --> 00:25:40,640
the parents and these are the patterns

00:25:38,630 --> 00:25:43,549
just as you would expect with react

00:25:40,640 --> 00:25:45,169
where you listen to on change accept

00:25:43,549 --> 00:25:47,000
react doesn't have a very good story of

00:25:45,169 --> 00:25:50,090
the parents communicating with the child

00:25:47,000 --> 00:25:53,000
yet to use rests for that but it's just

00:25:50,090 --> 00:25:55,370
an example of how that work let's see

00:25:53,000 --> 00:25:59,630
what happens by defaults for invalid

00:25:55,370 --> 00:26:02,900
transitions for invalid transitions what

00:25:59,630 --> 00:26:04,760
happens is it defaults well so the way

00:26:02,900 --> 00:26:07,280
that hierarchical state machines work is

00:26:04,760 --> 00:26:09,860
if the transition is invalid here it

00:26:07,280 --> 00:26:11,270
checks the parents and if it's invalid

00:26:09,860 --> 00:26:13,220
in the parents it goes to the parent and

00:26:11,270 --> 00:26:15,470
so on so it's the same type of event

00:26:13,220 --> 00:26:18,850
delegation that happens in your normal

00:26:15,470 --> 00:26:21,350
Dom manipulation and all of that

00:26:18,850 --> 00:26:23,630
otherwise there is strict mode where it

00:26:21,350 --> 00:26:26,419
will throw an error saying you cannot do

00:26:23,630 --> 00:26:28,190
this it's invalid but as a developer you

00:26:26,419 --> 00:26:31,070
should be handling invalid transitions

00:26:28,190 --> 00:26:34,070
yourself would you like to take the

00:26:31,070 --> 00:26:35,960
behavior trace how do you consider them

00:26:34,070 --> 00:26:38,299
have you considered them there are

00:26:35,960 --> 00:26:40,700
hierarchical state machines on steroids

00:26:38,299 --> 00:26:44,150
to use in game development and out of 10

00:26:40,700 --> 00:26:47,210
what do you think uh so I looked briefly

00:26:44,150 --> 00:26:48,260
into behavior trees and also decision

00:26:47,210 --> 00:26:52,280
trees that they're the same thing

00:26:48,260 --> 00:26:54,410
they're probably not but I talked about

00:26:52,280 --> 00:26:55,190
how you could use date charts and state

00:26:54,410 --> 00:26:57,470
machines

00:26:55,190 --> 00:26:59,000
for analysis and based on that analysis

00:26:57,470 --> 00:27:01,420
you could create adaptive user

00:26:59,000 --> 00:27:04,750
interfaces and so what that is is you

00:27:01,420 --> 00:27:08,180
analyze every time a user does an event

00:27:04,750 --> 00:27:09,950
you give each transition so from state

00:27:08,180 --> 00:27:12,260
to state you get that transition of

00:27:09,950 --> 00:27:14,570
weight so if more users are going from

00:27:12,260 --> 00:27:17,000
one state to the other then that edge

00:27:14,570 --> 00:27:19,460
gets a higher weight and so you could

00:27:17,000 --> 00:27:22,400
feed that data into a decision tree or a

00:27:19,460 --> 00:27:25,460
behavior tree and automatically adapt

00:27:22,400 --> 00:27:27,860
the application to to best fit the users

00:27:25,460 --> 00:27:29,900
so it's sort of like you're getting rid

00:27:27,860 --> 00:27:33,010
of a be testing and instead you're

00:27:29,900 --> 00:27:37,730
having the application adapt itself to

00:27:33,010 --> 00:27:40,040
make users happier I think we have two

00:27:37,730 --> 00:27:43,220
more minutes if there is one you like we

00:27:40,040 --> 00:27:44,690
can take it all right if you see machine

00:27:43,220 --> 00:27:47,180
how do you know if you need to show the

00:27:44,690 --> 00:27:49,370
spinner or not based on flags or the

00:27:47,180 --> 00:27:51,880
state name so you should do it based on

00:27:49,370 --> 00:27:54,890
the state name here's why flags are bad

00:27:51,880 --> 00:27:57,530
let's say you have is loading and is

00:27:54,890 --> 00:27:58,960
error and is success by having those

00:27:57,530 --> 00:28:00,980
three different variables

00:27:58,960 --> 00:28:03,440
technically all three of them could be

00:28:00,980 --> 00:28:05,480
true at the same time and then you have

00:28:03,440 --> 00:28:07,280
like I remember my car got struck by

00:28:05,480 --> 00:28:09,410
lightning a few years ago and all the

00:28:07,280 --> 00:28:11,000
lights came on and some of the lights

00:28:09,410 --> 00:28:13,610
were like everything's good and some of

00:28:11,000 --> 00:28:15,440
the lights were your cars dead and all

00:28:13,610 --> 00:28:17,090
those happened at the same time and so

00:28:15,440 --> 00:28:19,370
that's what that looks like and as a

00:28:17,090 --> 00:28:21,590
programmer you are having to keep track

00:28:19,370 --> 00:28:23,900
of all right it is loading and showing I

00:28:21,590 --> 00:28:26,990
shouldn't be showing is error but what

00:28:23,900 --> 00:28:28,850
you really want is in enumeration you

00:28:26,990 --> 00:28:32,480
want your state to either be loading or

00:28:28,850 --> 00:28:34,430
error or success and never all three at

00:28:32,480 --> 00:28:39,530
the same time so you want to try to make

00:28:34,430 --> 00:28:41,390
impossible States impossible thank you

00:28:39,530 --> 00:28:43,940
thank you thank you

00:28:41,390 --> 00:28:46,000
[Applause]

00:28:43,940 --> 00:28:46,000

YouTube URL: https://www.youtube.com/watch?v=DrHccvns-L0


