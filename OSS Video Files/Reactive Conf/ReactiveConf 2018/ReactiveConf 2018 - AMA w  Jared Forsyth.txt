Title: ReactiveConf 2018 - AMA w  Jared Forsyth
Publication date: 2018-11-05
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Discovery stage
-------------------------------------------------------------------
Ask Me Anything session, moderated by Gerard Sans.
Based on Jared's previous talk on ReactiveConf Main stage: https://www.youtube.com/watch?v=RV997YRIMZs
Captions: 
	00:00:02,490 --> 00:00:08,960
[Music]

00:00:12,340 --> 00:00:20,390
so we are going to kick off the last ask

00:00:17,390 --> 00:00:24,349
me anything session and we are pretty

00:00:20,390 --> 00:00:28,279
excited to have with us Jarrett and he

00:00:24,349 --> 00:00:33,260
has been doing amazing work on reason

00:00:28,279 --> 00:00:39,620
and I will I will let him do a small as

00:00:33,260 --> 00:00:42,820
Molly intro sure so for for context the

00:00:39,620 --> 00:00:45,500
video or the talk I just gave was about

00:00:42,820 --> 00:00:49,340
kind of a general intro to reason and

00:00:45,500 --> 00:00:52,400
using reason with react as far as myself

00:00:49,340 --> 00:00:55,280
i I do mobile and web development at

00:00:52,400 --> 00:00:58,520
Khan Academy so I'm regularly working in

00:00:55,280 --> 00:01:03,380
JavaScript with react native and also

00:00:58,520 --> 00:01:06,369
Java and Swift and objective-c I've been

00:01:03,380 --> 00:01:09,860
involved with the recent project for

00:01:06,369 --> 00:01:14,030
what three years now ish two and a half

00:01:09,860 --> 00:01:19,729
maybe on and off and so I've made some

00:01:14,030 --> 00:01:26,120
core contributions to the recent parser

00:01:19,729 --> 00:01:31,100
and I wrote the IDE plugin for vs code

00:01:26,120 --> 00:01:34,970
and other editors yeah awesome

00:01:31,100 --> 00:01:38,510
just as a refresh of this little app you

00:01:34,970 --> 00:01:40,640
need to use this has LC 18 and we will

00:01:38,510 --> 00:01:42,770
take questions from from the audience

00:01:40,640 --> 00:01:46,280
but if you are more comfortable you can

00:01:42,770 --> 00:01:48,860
also use as little so we have one

00:01:46,280 --> 00:01:53,630
question - do we not have the questions

00:01:48,860 --> 00:01:56,950
that were asked during my talk it seems

00:01:53,630 --> 00:02:01,220
it's not it's not absolute yet okay but

00:01:56,950 --> 00:02:02,240
okay maybe we can we can start with with

00:02:01,220 --> 00:02:06,759
a separate question

00:02:02,240 --> 00:02:10,970
sure so have you seen how we would you

00:02:06,759 --> 00:02:15,140
say that it's been the progress in the

00:02:10,970 --> 00:02:16,430
later the later month regarding a reason

00:02:15,140 --> 00:02:18,819
ml and and react

00:02:16,430 --> 00:02:22,260
have you seen their good progress there

00:02:18,819 --> 00:02:24,690
in terms of development or adoption or

00:02:22,260 --> 00:02:26,340
I would say more adoption okay yeah

00:02:24,690 --> 00:02:31,500
tooling around it

00:02:26,340 --> 00:02:33,480
sure so you know it's it's always fun

00:02:31,500 --> 00:02:35,040
every couple of weeks when a company

00:02:33,480 --> 00:02:36,629
makes a pull request to the reason

00:02:35,040 --> 00:02:38,700
website saying hey we're using reason

00:02:36,629 --> 00:02:42,870
can you put our logo up on the you know

00:02:38,700 --> 00:02:44,760
list of people using reason and so you

00:02:42,870 --> 00:02:48,739
know adoptions coming along it's

00:02:44,760 --> 00:02:53,069
certainly not hit the mainstream yet but

00:02:48,739 --> 00:02:54,360
there are I don't know that there have

00:02:53,069 --> 00:02:57,590
been kind of slow and steady

00:02:54,360 --> 00:03:00,769
developments in the the tooling area

00:02:57,590 --> 00:03:04,860
things getting faster and more robust

00:03:00,769 --> 00:03:06,390
just kind of basic stuff from my pro

00:03:04,860 --> 00:03:09,630
point of view I've seen a lot of

00:03:06,390 --> 00:03:12,420
excitement around it so maybe you have

00:03:09,630 --> 00:03:14,519
maybe playing it down right I mean

00:03:12,420 --> 00:03:17,099
there's there's a lot of exciting

00:03:14,519 --> 00:03:20,340
possibilities and and a fair amount of

00:03:17,099 --> 00:03:23,549
hype okay and what about the tooling

00:03:20,340 --> 00:03:27,389
have you seen any new tools that will

00:03:23,549 --> 00:03:32,040
help streamline working with a reason

00:03:27,389 --> 00:03:36,019
within react or with that now I mean so

00:03:32,040 --> 00:03:39,840
fast pack there was talk about that that

00:03:36,019 --> 00:03:43,170
is a very fast bundler written in reason

00:03:39,840 --> 00:03:49,889
it works well when writing reason react

00:03:43,170 --> 00:03:55,410
apps there are the sketch SH that I

00:03:49,889 --> 00:03:57,690
showed is cool for for quick demos no no

00:03:55,410 --> 00:04:00,720
there's a lot of stuff coming out okay

00:03:57,690 --> 00:04:03,420
well that was just until we catch have

00:04:00,720 --> 00:04:06,690
with the questions so let's take let's

00:04:03,420 --> 00:04:09,209
take some of these questions do you use

00:04:06,690 --> 00:04:12,959
reason in production would you recommend

00:04:09,209 --> 00:04:17,519
it why why or why not

00:04:12,959 --> 00:04:20,700
in your experience sure so I I use

00:04:17,519 --> 00:04:23,340
reason in production on a variety of

00:04:20,700 --> 00:04:25,200
personal projects there's the the app

00:04:23,340 --> 00:04:30,659
that I've the game that I've shipped to

00:04:25,200 --> 00:04:33,090
the app stores and a couple of projects

00:04:30,659 --> 00:04:35,610
that you know get a couple thousand

00:04:33,090 --> 00:04:38,159
users a month the kind of thing

00:04:35,610 --> 00:04:42,599
at work at Khan Academy we don't use

00:04:38,159 --> 00:04:45,389
reason in production yet for a couple of

00:04:42,599 --> 00:04:47,490
reasons one of them being we the past

00:04:45,389 --> 00:04:50,389
two years we've adopted react native

00:04:47,490 --> 00:04:53,639
we've added flow we've had a graph QL

00:04:50,389 --> 00:04:55,650
there we add a Kotlin on the back end

00:04:53,639 --> 00:04:57,840
there's just been a lot of you know a

00:04:55,650 --> 00:04:59,009
lot of changes and switching from

00:04:57,840 --> 00:05:01,740
JavaScript to a new blank which is

00:04:59,009 --> 00:05:05,250
probably one too many at this point and

00:05:01,740 --> 00:05:08,430
then the other reason being that you

00:05:05,250 --> 00:05:11,280
know our developer team is 20 or 30

00:05:08,430 --> 00:05:15,060
people which is kind of a lot to try and

00:05:11,280 --> 00:05:17,490
migrate on to a new language so from in

00:05:15,060 --> 00:05:21,120
in my talk I tried to give a good kind

00:05:17,490 --> 00:05:23,250
of a balanced perspective of here's when

00:05:21,120 --> 00:05:28,229
it's makes sense right now to use reason

00:05:23,250 --> 00:05:30,659
and here's when it doesn't okay so we

00:05:28,229 --> 00:05:33,569
will reference them to just check out

00:05:30,659 --> 00:05:35,939
you know you will give much more

00:05:33,569 --> 00:05:37,800
information there yeah I think so

00:05:35,939 --> 00:05:39,930
most of the reasons not to use reason

00:05:37,800 --> 00:05:41,909
are community based and not stability

00:05:39,930 --> 00:05:46,409
based right the the foundation is very

00:05:41,909 --> 00:05:49,229
solid and it's it's not moving quickly

00:05:46,409 --> 00:05:52,949
right so if there's stability but in

00:05:49,229 --> 00:05:54,629
terms of community support and community

00:05:52,949 --> 00:05:56,009
size that kind of thing those are the

00:05:54,629 --> 00:05:59,310
reasons to hesitate if you have a large

00:05:56,009 --> 00:06:02,610
team okay so let's take another another

00:05:59,310 --> 00:06:11,039
question maybe we have a question here

00:06:02,610 --> 00:06:14,330
from the audience okay okay

00:06:11,039 --> 00:06:14,330
he had a question

00:06:19,090 --> 00:06:29,420
for JavaScript and native yeah so there

00:06:25,730 --> 00:06:32,900
is a there is a syntax plug-in that I

00:06:29,420 --> 00:06:36,140
wrote called let anything that you can

00:06:32,900 --> 00:06:38,600
use in your in your JavaScript code and

00:06:36,140 --> 00:06:41,870
your native code right now that

00:06:38,600 --> 00:06:43,220
basically gives you a sink await in in

00:06:41,870 --> 00:06:46,520
JavaScript you can use it with promises

00:06:43,220 --> 00:06:50,419
on in native compilation you can use it

00:06:46,520 --> 00:06:52,970
with LWT which is the Oh camel async

00:06:50,419 --> 00:06:54,890
library or the Oh camel library called

00:06:52,970 --> 00:06:58,460
async which is the competitor because

00:06:54,890 --> 00:07:08,870
there are always two everything but yes

00:06:58,460 --> 00:07:11,780
so so async is fully supported right so

00:07:08,870 --> 00:07:13,760
the so in order to use it there there is

00:07:11,780 --> 00:07:16,910
a syntax plug-in kind of like a babel

00:07:13,760 --> 00:07:18,919
plugin that you will install the the

00:07:16,910 --> 00:07:21,350
pull request has not been merged into

00:07:18,919 --> 00:07:25,850
the core syntax yet but you can still

00:07:21,350 --> 00:07:28,760
use it as a plugin awesome

00:07:25,850 --> 00:07:32,030
let's take now another question from Lee

00:07:28,760 --> 00:07:34,460
though so does type safety kicked in at

00:07:32,030 --> 00:07:37,460
run time if we are fetching some data

00:07:34,460 --> 00:07:39,800
from an external resource like network

00:07:37,460 --> 00:07:42,140
or disk or how that works is that the

00:07:39,800 --> 00:07:47,330
scenario good question

00:07:42,140 --> 00:07:50,229
so if you are getting external data it

00:07:47,330 --> 00:07:54,100
depends on whether you use safe methods

00:07:50,229 --> 00:07:58,790
right so if you say get a juice on blob

00:07:54,100 --> 00:08:02,540
and you use for example PS JSON is a

00:07:58,790 --> 00:08:05,870
popular library for a reason for

00:08:02,540 --> 00:08:07,360
decoding JSON basically taking it apart

00:08:05,870 --> 00:08:12,140
to make sure that it matches your type

00:08:07,360 --> 00:08:14,390
it is safe and it will and it'll force

00:08:12,140 --> 00:08:15,979
you to handle the error case you know

00:08:14,390 --> 00:08:18,410
what if it doesn't have this attribute

00:08:15,979 --> 00:08:20,419
and then you decide am I gonna just

00:08:18,410 --> 00:08:24,169
crash the app am I going to show a

00:08:20,419 --> 00:08:26,680
warning message whatever if you there

00:08:24,169 --> 00:08:28,940
you know if you use the unsafe parts of

00:08:26,680 --> 00:08:31,099
buckle script and say oh I'm just gonna

00:08:28,940 --> 00:08:37,450
assume that this works

00:08:31,099 --> 00:08:41,120
then then you don't get type safety okay

00:08:37,450 --> 00:08:45,100
so let's take the next question what is

00:08:41,120 --> 00:08:48,010
the debugging experience like for reason

00:08:45,100 --> 00:08:50,240
so using the dev tools and soul maps and

00:08:48,010 --> 00:08:53,029
reading generated JavaScript so is

00:08:50,240 --> 00:08:56,290
something like that or yeah yeah great

00:08:53,029 --> 00:08:59,149
question so reason with buccal script

00:08:56,290 --> 00:09:04,040
there is a there's a flag you can turn

00:08:59,149 --> 00:09:06,440
on that will add chrome dev tools magic

00:09:04,040 --> 00:09:09,860
such that when you when you log out a

00:09:06,440 --> 00:09:13,190
value you can see it as a record or a

00:09:09,860 --> 00:09:15,709
list and that that makes debugging a lot

00:09:13,190 --> 00:09:19,579
easier in the browser there are no

00:09:15,709 --> 00:09:21,200
source Maps currently so you you just

00:09:19,579 --> 00:09:24,019
read the generated JavaScript as opposed

00:09:21,200 --> 00:09:28,550
to you know a source map version of the

00:09:24,019 --> 00:09:30,470
original source and I've found it to to

00:09:28,550 --> 00:09:33,950
be pretty easy to read pretty easy to to

00:09:30,470 --> 00:09:35,660
step through and debug of course using

00:09:33,950 --> 00:09:39,709
using a stronger language like reason

00:09:35,660 --> 00:09:42,670
you don't end up having to drop down as

00:09:39,709 --> 00:09:44,300
often because you get fewer exceptions

00:09:42,670 --> 00:09:46,790
there are definitely still some

00:09:44,300 --> 00:09:51,010
annoyances though with the exceptions

00:09:46,790 --> 00:09:54,290
that you get okay

00:09:51,010 --> 00:09:57,260
moving into a next question so how

00:09:54,290 --> 00:09:59,540
reason deals with NPM packages yeah

00:09:57,260 --> 00:10:01,880
what's the situation there yeah so you

00:09:59,540 --> 00:10:06,740
you can use NPM packages as reason

00:10:01,880 --> 00:10:08,899
definitely there are some tutorials you

00:10:06,740 --> 00:10:10,370
can you can look at I think there's a

00:10:08,899 --> 00:10:14,120
reason to an episode that deals with

00:10:10,370 --> 00:10:16,790
this directly but basically if if there

00:10:14,120 --> 00:10:18,860
is already a library publish that wraps

00:10:16,790 --> 00:10:20,420
a JavaScript library for a reason you

00:10:18,860 --> 00:10:22,279
know that does the externals then you

00:10:20,420 --> 00:10:24,980
can grab that more often than not it's

00:10:22,279 --> 00:10:27,380
not the case and so you will write the

00:10:24,980 --> 00:10:31,490
book on script externals yourself i've

00:10:27,380 --> 00:10:35,720
found these quite easy to write and get

00:10:31,490 --> 00:10:37,579
started with so yes you do npm install

00:10:35,720 --> 00:10:39,020
and then you write an external

00:10:37,579 --> 00:10:40,220
declaration that says here's the module

00:10:39,020 --> 00:10:41,930
that i want here's the function that I

00:10:40,220 --> 00:10:42,990
want this is the type signature that it

00:10:41,930 --> 00:10:46,080
has and then you can use

00:10:42,990 --> 00:10:49,470
I was thinking about a question of

00:10:46,080 --> 00:10:52,770
myself and I'll take advantage of being

00:10:49,470 --> 00:10:55,800
a sitting here and I was thinking that

00:10:52,770 --> 00:10:58,380
probably you have been seeing a lot of

00:10:55,800 --> 00:11:01,589
developers moving from JavaScript to a

00:10:58,380 --> 00:11:03,930
reason and what what are the their

00:11:01,589 --> 00:11:06,390
struggles like what are their struggling

00:11:03,930 --> 00:11:08,940
points for JavaScript developers like

00:11:06,390 --> 00:11:14,580
trying to move into reason in your in

00:11:08,940 --> 00:11:18,660
your experience yeah lots of little

00:11:14,580 --> 00:11:21,930
things the the syntax errors that you

00:11:18,660 --> 00:11:25,050
get in reason are currently really bad

00:11:21,930 --> 00:11:27,120
um they just say syntax error and not

00:11:25,050 --> 00:11:32,420
they don't tell you how to fix it

00:11:27,120 --> 00:11:36,630
so that's annoying up until recently the

00:11:32,420 --> 00:11:38,810
the ID in the IDE integration was hard

00:11:36,630 --> 00:11:42,980
to set up and ended up being quite flaky

00:11:38,810 --> 00:11:50,040
so I wrote a new one and hopefully it's

00:11:42,980 --> 00:11:52,770
much more robust and yeah I mean the the

00:11:50,040 --> 00:11:55,350
core language concepts there are there

00:11:52,770 --> 00:11:57,089
are definitely some weirder ones but you

00:11:55,350 --> 00:11:57,990
don't end up having to use them right

00:11:57,089 --> 00:11:59,880
when you're just getting started with

00:11:57,990 --> 00:12:01,500
reason it it's basically of this is

00:11:59,880 --> 00:12:04,770
functions it looks like JavaScript this

00:12:01,500 --> 00:12:07,050
is fine so mostly you would say that

00:12:04,770 --> 00:12:09,120
they can take import more of the

00:12:07,050 --> 00:12:11,880
knowledge and then maybe you find some

00:12:09,120 --> 00:12:14,250
of these issues and then they will try

00:12:11,880 --> 00:12:18,380
to figure out what this error message is

00:12:14,250 --> 00:12:21,300
mean but as long as they progress using

00:12:18,380 --> 00:12:25,279
reason then they will solve this mostly

00:12:21,300 --> 00:12:27,779
on then on their own yeah and definitely

00:12:25,279 --> 00:12:29,100
join the discord channel if you're

00:12:27,779 --> 00:12:31,740
getting started with reason so that you

00:12:29,100 --> 00:12:34,740
can ask beginner questions because there

00:12:31,740 --> 00:12:36,779
are I don't know that there are so much

00:12:34,740 --> 00:12:39,029
patterns as everybody has a different

00:12:36,779 --> 00:12:40,680
question and the people there will well

00:12:39,029 --> 00:12:43,050
know how to answer it for you yeah

00:12:40,680 --> 00:12:45,240
that's a good resource okay so let's

00:12:43,050 --> 00:12:47,970
take another question can reason be

00:12:45,240 --> 00:12:50,970
introduced incrementally is that an

00:12:47,970 --> 00:12:53,100
option from a you know legacy JavaScript

00:12:50,970 --> 00:12:55,620
project definitely definitely and and I

00:12:53,100 --> 00:12:59,010
spend about five minutes

00:12:55,620 --> 00:13:01,830
in in my talked talking about how to use

00:12:59,010 --> 00:13:03,870
a for example a reason component that

00:13:01,830 --> 00:13:07,860
you wrote a reason we are component you

00:13:03,870 --> 00:13:10,200
can do exactly the same thing for a you

00:13:07,860 --> 00:13:11,910
know just an algorithmic function that

00:13:10,200 --> 00:13:15,089
you want to write in reason and then use

00:13:11,910 --> 00:13:17,910
it from JavaScript and then at the end I

00:13:15,089 --> 00:13:19,589
talked about how to retain type safety

00:13:17,910 --> 00:13:24,810
if you're using reason from typescript

00:13:19,589 --> 00:13:27,779
or flow also let's see let's see what's

00:13:24,810 --> 00:13:30,900
next for each new feature in react which

00:13:27,779 --> 00:13:35,010
we're now talking we have seen a lot of

00:13:30,900 --> 00:13:39,300
yes around hooks you have to prepare

00:13:35,010 --> 00:13:43,020
that same feature support for four

00:13:39,300 --> 00:13:47,610
reason or what's what's going on right

00:13:43,020 --> 00:13:54,120
right so reason react has has tried to

00:13:47,610 --> 00:13:56,040
be more stable for example there the new

00:13:54,120 --> 00:13:59,420
context API that came out i don't know

00:13:56,040 --> 00:13:59,420
how sex months ago or eight months ago

00:14:00,110 --> 00:14:06,390
still hasn't been added to reason we act

00:14:03,240 --> 00:14:09,780
core you can you can write yourself in a

00:14:06,390 --> 00:14:12,240
couple lines but it's there's definitely

00:14:09,780 --> 00:14:14,100
a trade-off to you know is this feature

00:14:12,240 --> 00:14:16,100
really going to be used a lot

00:14:14,100 --> 00:14:19,620
can you already do it some other way

00:14:16,100 --> 00:14:21,540
hooks are maybe an exception because the

00:14:19,620 --> 00:14:25,020
the introduction of hooks will make it

00:14:21,540 --> 00:14:26,370
so much simpler to do reason react will

00:14:25,020 --> 00:14:31,350
be able to cut like eighty percent of

00:14:26,370 --> 00:14:34,320
the code and so assuming that hooks gets

00:14:31,350 --> 00:14:38,720
landed in something like its current

00:14:34,320 --> 00:14:42,870
stage I think will will definitely be

00:14:38,720 --> 00:14:47,280
experimenting with that in reason okay

00:14:42,870 --> 00:14:50,640
things we're getting now typescript

00:14:47,280 --> 00:14:52,980
so is it possible to generate recently

00:14:50,640 --> 00:14:55,470
buccal strip bindings for libraries from

00:14:52,980 --> 00:14:59,520
existing typescript definition file

00:14:55,470 --> 00:15:06,540
types good question there are some

00:14:59,520 --> 00:15:08,579
experimental projects that do this and I

00:15:06,540 --> 00:15:11,279
think reasonably typed you

00:15:08,579 --> 00:15:14,970
the one that's gotten the farthest so

00:15:11,279 --> 00:15:17,069
you can google that and yeah it's it's

00:15:14,970 --> 00:15:19,579
basically saying if you have typescript

00:15:17,069 --> 00:15:23,279
you know I definitely typed definition

00:15:19,579 --> 00:15:26,399
being able to generate bindings for an

00:15:23,279 --> 00:15:29,549
NPM module so that can bring a lot of

00:15:26,399 --> 00:15:31,769
the work done for type scape into into

00:15:29,549 --> 00:15:34,470
reason with a reasonable effort yeah

00:15:31,769 --> 00:15:38,549
yeah so it it definitely doesn't have

00:15:34,470 --> 00:15:41,639
first-class support yet but it's totally

00:15:38,549 --> 00:15:47,160
possible and an exciting prospect in a

00:15:41,639 --> 00:15:50,129
lot of cases you end up wanting to do a

00:15:47,160 --> 00:15:53,239
little bit more wrapping anyway because

00:15:50,129 --> 00:15:55,619
because tight typescript is so tightly

00:15:53,239 --> 00:15:59,429
with JavaScript as far as the runtime

00:15:55,619 --> 00:16:01,649
goes in reason we want a little bit more

00:15:59,429 --> 00:16:04,559
purity a little bit more immutability

00:16:01,649 --> 00:16:06,569
that kind of thing and so often the

00:16:04,559 --> 00:16:09,860
right choice will be I'm gonna have a

00:16:06,569 --> 00:16:12,509
thicker layer where I remove some of the

00:16:09,860 --> 00:16:14,699
you know a lot of JavaScript libraries

00:16:12,509 --> 00:16:17,519
they have function overloading where you

00:16:14,699 --> 00:16:19,559
know it's impossible to generate a same

00:16:17,519 --> 00:16:20,970
type signature for this function because

00:16:19,559 --> 00:16:23,999
it can be called in eleven different

00:16:20,970 --> 00:16:26,189
ways and so there's there's a little

00:16:23,999 --> 00:16:28,110
more work involved making function names

00:16:26,189 --> 00:16:30,559
that make sense that will map to the

00:16:28,110 --> 00:16:36,029
different invocations of that function I

00:16:30,559 --> 00:16:40,799
say okay so we have another question is

00:16:36,029 --> 00:16:44,639
it possible to use code compiled from

00:16:40,799 --> 00:16:47,309
reason or the server-side there were a

00:16:44,639 --> 00:16:48,419
couple ways to take that question I will

00:16:47,309 --> 00:16:54,989
answer all of them

00:16:48,419 --> 00:16:58,199
the first way can you use reason with no

00:16:54,989 --> 00:17:00,869
js' answer is yes there are there are

00:16:58,199 --> 00:17:03,709
people that are shipping Express you

00:17:00,869 --> 00:17:09,059
know reason apps compiled to JavaScript

00:17:03,709 --> 00:17:12,539
using Express that works or if you want

00:17:09,059 --> 00:17:14,639
to use any up AWS lambda and the kind of

00:17:12,539 --> 00:17:18,240
nodejs route there with reason source

00:17:14,639 --> 00:17:20,610
code that also works if you want to

00:17:18,240 --> 00:17:24,539
compile reason to native

00:17:20,610 --> 00:17:29,010
you know to native assembly you can also

00:17:24,539 --> 00:17:30,299
do that how far you'll get with and how

00:17:29,010 --> 00:17:34,950
much pain will be involved depends on

00:17:30,299 --> 00:17:38,640
your application there are there's not

00:17:34,950 --> 00:17:41,700
nearly the ecosystem around native

00:17:38,640 --> 00:17:47,909
libraries as there is around NPM up

00:17:41,700 --> 00:17:50,789
naturally I have made a kind of a demo

00:17:47,909 --> 00:17:52,649
web server that's compiled to native but

00:17:50,789 --> 00:17:54,480
there are a lot of pieces that you'll

00:17:52,649 --> 00:17:57,260
miss when it's like oh I wish I had

00:17:54,480 --> 00:18:01,049
passport or oh I wish I had you know

00:17:57,260 --> 00:18:03,210
form parsing that made sense things like

00:18:01,049 --> 00:18:08,279
that it it's not nearly as

00:18:03,210 --> 00:18:11,130
well-developed of an area understood so

00:18:08,279 --> 00:18:14,250
this is related to one previous question

00:18:11,130 --> 00:18:17,669
and it's you know porting these new

00:18:14,250 --> 00:18:19,889
features into an inter ISM so exactly is

00:18:17,669 --> 00:18:22,519
what's happening with context API is

00:18:19,889 --> 00:18:31,950
there a plan to add official bindings

00:18:22,519 --> 00:18:33,809
what will be the date yeah I again hooks

00:18:31,950 --> 00:18:36,990
have been announced for like four days

00:18:33,809 --> 00:18:39,169
or whatever so it's kind of ridiculous

00:18:36,990 --> 00:18:44,490
how much people are talking about them

00:18:39,169 --> 00:18:50,190
but if if hooks turn out to be the way

00:18:44,490 --> 00:18:52,159
that react ends up working then yes

00:18:50,190 --> 00:18:54,899
there I'm sure there will be an official

00:18:52,159 --> 00:19:01,320
official support for the hooks context

00:18:54,899 --> 00:19:04,049
API and that would include the the new

00:19:01,320 --> 00:19:09,240
context API with the provider and such

00:19:04,049 --> 00:19:10,169
if not then I'm like react will go in a

00:19:09,240 --> 00:19:13,769
different direction will have to deal

00:19:10,169 --> 00:19:16,679
with that yeah that's quite interesting

00:19:13,769 --> 00:19:22,470
what what is going on yeah it's quite

00:19:16,679 --> 00:19:26,490
unique mm-hmm okay so we got into the

00:19:22,470 --> 00:19:29,370
same conversation so the this question

00:19:26,490 --> 00:19:32,179
is them if we

00:19:29,370 --> 00:19:36,419
kind of porting the features like how

00:19:32,179 --> 00:19:38,309
coupled are these two like react and

00:19:36,419 --> 00:19:42,690
reason right right

00:19:38,309 --> 00:19:44,100
so reason can definitely be used with

00:19:42,690 --> 00:19:46,230
other view libraries

00:19:44,100 --> 00:19:48,059
it has first-class support for react

00:19:46,230 --> 00:19:54,809
because their creators are excited about

00:19:48,059 --> 00:19:57,629
react understandably the JSX transform

00:19:54,809 --> 00:20:00,539
is actually expressed in such a way that

00:19:57,629 --> 00:20:03,299
you could use it differently I've

00:20:00,539 --> 00:20:06,059
actually used reasons JSX

00:20:03,299 --> 00:20:12,289
on the native side to do static site

00:20:06,059 --> 00:20:16,980
generation which was fun and I think

00:20:12,289 --> 00:20:20,220
somebody's done a bridge with view to

00:20:16,980 --> 00:20:21,809
reason there certainly isn't nearly as

00:20:20,220 --> 00:20:23,159
much community about it because often

00:20:21,809 --> 00:20:24,210
the people that are excited about reason

00:20:23,159 --> 00:20:28,409
are people that are already excited

00:20:24,210 --> 00:20:29,909
about react so there's certain coupling

00:20:28,409 --> 00:20:31,980
what is more from coming from the

00:20:29,909 --> 00:20:34,799
community which is a little bit biased

00:20:31,980 --> 00:20:36,679
yeah yeah yeah that's that's

00:20:34,799 --> 00:20:41,070
understandable

00:20:36,679 --> 00:20:45,629
okay we have another another question I

00:20:41,070 --> 00:20:48,869
think you answer this one but on talking

00:20:45,629 --> 00:20:51,809
on a reason on the backend do you think

00:20:48,869 --> 00:20:53,369
it can at some point be you know that

00:20:51,809 --> 00:20:56,940
platform for back-end

00:20:53,369 --> 00:20:58,320
similarly to a doubt maybe even replace

00:20:56,940 --> 00:21:04,490
it

00:20:58,320 --> 00:21:08,429
I don't think Java it's going anywhere

00:21:04,490 --> 00:21:12,059
so from that perspective it will not

00:21:08,429 --> 00:21:14,759
replace nodejs go is really cool and it

00:21:12,059 --> 00:21:20,610
hasn't replaced nodejs javascript is

00:21:14,759 --> 00:21:22,919
just a mega giant so I I think it has

00:21:20,610 --> 00:21:25,919
potential to be a really viable target

00:21:22,919 --> 00:21:28,860
in the same way that go is and I think

00:21:25,919 --> 00:21:31,769
you know assuming that reason keeps

00:21:28,860 --> 00:21:33,899
going strong and gets bigger I think you

00:21:31,769 --> 00:21:35,639
will end up with people saying oh we

00:21:33,899 --> 00:21:38,100
moved from node.js on the backend to

00:21:35,639 --> 00:21:39,809
native reason compilation and it was

00:21:38,100 --> 00:21:40,080
such a good idea or it was such a bad

00:21:39,809 --> 00:21:42,900
idea

00:21:40,080 --> 00:21:46,500
I don't know and what will

00:21:42,900 --> 00:21:49,380
the main reasons for doing that it will

00:21:46,500 --> 00:21:51,300
be just performance or it will be some

00:21:49,380 --> 00:21:57,510
other benefits what would be in your

00:21:51,300 --> 00:21:59,400
mind some of those so if we're

00:21:57,510 --> 00:22:04,380
considering given that reason can go to

00:21:59,400 --> 00:22:06,660
JavaScript or to native the the benefits

00:22:04,380 --> 00:22:09,000
of going to JavaScript with no js' of

00:22:06,660 --> 00:22:12,360
course are the huge ecosystem the

00:22:09,000 --> 00:22:15,840
benefits of going to native are bundle

00:22:12,360 --> 00:22:18,540
size right where if you are say shipping

00:22:15,840 --> 00:22:21,960
a docker container and you need all of

00:22:18,540 --> 00:22:23,460
node modules and a node runtime you know

00:22:21,960 --> 00:22:27,180
that this is hundreds of megabytes

00:22:23,460 --> 00:22:31,500
already I shipped a docker container to

00:22:27,180 --> 00:22:34,910
now dot SH that contained only the

00:22:31,500 --> 00:22:40,050
native compiled binary server and it was

00:22:34,910 --> 00:22:41,790
nine megabytes so there there's the

00:22:40,050 --> 00:22:43,590
bundle size aspect there's also the

00:22:41,790 --> 00:22:48,150
speed aspect of course native

00:22:43,590 --> 00:22:51,060
compilation a lot like nodejs is startup

00:22:48,150 --> 00:22:52,890
time is already 200 milliseconds so if

00:22:51,060 --> 00:22:55,190
you want a server that can respond

00:22:52,890 --> 00:22:59,430
quicker than that you can't use node

00:22:55,190 --> 00:23:02,040
that's great ok let's take another

00:22:59,430 --> 00:23:13,530
question maybe you have some questions

00:23:02,040 --> 00:23:13,890
here yes yeah so there there is a an

00:23:13,530 --> 00:23:17,640
official

00:23:13,890 --> 00:23:22,710
it's called BS react native four buckle

00:23:17,640 --> 00:23:23,880
script and so but some people have

00:23:22,710 --> 00:23:25,050
played around with that I don't know if

00:23:23,880 --> 00:23:29,550
anyone's using in a production at the

00:23:25,050 --> 00:23:32,790
moment but definitely promising and

00:23:29,550 --> 00:23:35,520
actually the the people at call stack

00:23:32,790 --> 00:23:39,000
are really excited about reason and the

00:23:35,520 --> 00:23:40,920
possibility of react native but with

00:23:39,000 --> 00:23:46,260
reason compiled to native using the

00:23:40,920 --> 00:23:49,770
react native back-end as well I have

00:23:46,260 --> 00:23:54,110
another question and some months ago I

00:23:49,770 --> 00:23:56,460
heard some experiments on some online

00:23:54,110 --> 00:23:59,190
environments maybe having

00:23:56,460 --> 00:24:03,990
port for a reason what's the status of

00:23:59,190 --> 00:24:06,810
of this at this point so code ten bucks

00:24:03,990 --> 00:24:10,290
io recently-released support repple it

00:24:06,810 --> 00:24:13,400
also those are those are the two main

00:24:10,290 --> 00:24:20,540
ones that have support currently

00:24:13,400 --> 00:24:23,070
excellent great nails okay so this one

00:24:20,540 --> 00:24:25,910
okay which tools for a good reason

00:24:23,070 --> 00:24:30,570
workflow do you recommend you have any

00:24:25,910 --> 00:24:33,740
preference on IVs so according to the

00:24:30,570 --> 00:24:38,070
the reason Community Survey that ran

00:24:33,740 --> 00:24:40,320
last month some ridiculous percentage of

00:24:38,070 --> 00:24:43,380
users are using BS code it's like 75

00:24:40,320 --> 00:24:46,200
percent so that's definitely the the

00:24:43,380 --> 00:24:51,120
popular choice and the one that will

00:24:46,200 --> 00:24:55,260
have the most most support so yeah go

00:24:51,120 --> 00:24:57,810
with that okay so we have probably at

00:24:55,260 --> 00:25:00,780
time for another couple of questions

00:24:57,810 --> 00:25:04,770
let's see them have you heard of fable

00:25:00,780 --> 00:25:08,340
f-sharp compiled with JavaScript how

00:25:04,770 --> 00:25:10,590
will you compare it to reason yes I have

00:25:08,340 --> 00:25:18,360
heard of fable fables very cool f-sharp

00:25:10,590 --> 00:25:25,440
also cool f-sharp

00:25:18,360 --> 00:25:33,050
is still I don't know it inherits a lot

00:25:25,440 --> 00:25:35,100
of object oriented mindset I think and

00:25:33,050 --> 00:25:36,600
hasn't been around know as long as I

00:25:35,100 --> 00:25:43,820
came along those were probably the two

00:25:36,600 --> 00:25:47,310
biggest differences so but f-sharp has a

00:25:43,820 --> 00:25:51,420
larger community I don't know if Abel

00:25:47,310 --> 00:25:55,770
necessarily does being you know kind of

00:25:51,420 --> 00:25:57,840
a separate thing but it's cool I I

00:25:55,770 --> 00:25:58,860
looked at F sharps implementation of

00:25:57,840 --> 00:26:03,630
async/await when I was trying to figure

00:25:58,860 --> 00:26:05,990
out how to do it for a reason okay so

00:26:03,630 --> 00:26:10,009
let's I'm going to peek

00:26:05,990 --> 00:26:12,590
the second question because there's a

00:26:10,009 --> 00:26:14,960
lot of people may be more familiar these

00:26:12,590 --> 00:26:18,049
days with type scrip and they want to

00:26:14,960 --> 00:26:21,440
figure out where a reason fits you know

00:26:18,049 --> 00:26:24,649
closer to their experience today so how

00:26:21,440 --> 00:26:27,830
can you give them like some information

00:26:24,649 --> 00:26:32,440
about the differences and you know maybe

00:26:27,830 --> 00:26:34,639
extra features right watch my talk I

00:26:32,440 --> 00:26:36,529
addressed this if there are any

00:26:34,639 --> 00:26:38,600
follow-up questions about this from

00:26:36,529 --> 00:26:38,899
people that have watched the talk let me

00:26:38,600 --> 00:26:41,450
know

00:26:38,899 --> 00:26:44,480
yeah no problem I think probably the

00:26:41,450 --> 00:26:46,700
most interesting question is the one at

00:26:44,480 --> 00:26:49,009
the bottom so what are the next big

00:26:46,700 --> 00:26:51,679
features and changes planned for reason

00:26:49,009 --> 00:26:57,049
and we can we can use that to wrap up

00:26:51,679 --> 00:27:03,110
this sure definitely the the async/await

00:26:57,049 --> 00:27:05,059
as a core syntax support is the thing

00:27:03,110 --> 00:27:12,649
lots of people are interested in excited

00:27:05,059 --> 00:27:16,779
about I don't know that there's lots of

00:27:12,649 --> 00:27:22,090
just little little housekeeping stuff

00:27:16,779 --> 00:27:24,830
better syntax errors better support for

00:27:22,090 --> 00:27:29,529
you know handling that and recovering

00:27:24,830 --> 00:27:32,990
from that to see rust-eze question there

00:27:29,529 --> 00:27:34,730
also there's there's been a lot of work

00:27:32,990 --> 00:27:36,769
trying to get a good native compilation

00:27:34,730 --> 00:27:40,759
story to have a package manager that can

00:27:36,769 --> 00:27:44,240
support node modules and also Oh Pam Oh

00:27:40,759 --> 00:27:47,659
camels module system and then eventually

00:27:44,240 --> 00:27:50,330
cross compilation so that that's

00:27:47,659 --> 00:27:53,269
probably the the change that is coming

00:27:50,330 --> 00:27:55,309
up I mean that the core language just

00:27:53,269 --> 00:27:59,659
does not have a lot of churn right it

00:27:55,309 --> 00:28:01,279
doesn't change a lot and they're there

00:27:59,659 --> 00:28:02,749
every once in a while there's a syntax

00:28:01,279 --> 00:28:05,720
feature or some you know some bit of

00:28:02,749 --> 00:28:07,070
sugar that happens but most of the

00:28:05,720 --> 00:28:10,580
growth and development is around the

00:28:07,070 --> 00:28:12,679
tool chain cool well thanks a lot for

00:28:10,580 --> 00:28:15,289
being at the last ask me anything

00:28:12,679 --> 00:28:18,430
session if you have any more questions

00:28:15,289 --> 00:28:22,450
feel free to to reach to Jared

00:28:18,430 --> 00:28:25,720
well now we are going to the end the

00:28:22,450 --> 00:28:28,690
closing keynote so I would recommend you

00:28:25,720 --> 00:28:32,680
to go to the main stage and just enjoy

00:28:28,690 --> 00:28:34,510
the ending of reactive counts but thank

00:28:32,680 --> 00:28:38,730
you for being here and attending this

00:28:34,510 --> 00:28:38,730

YouTube URL: https://www.youtube.com/watch?v=OQaKttZDO7I


