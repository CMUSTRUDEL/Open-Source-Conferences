Title: ReactiveConf 2018 - Luis Roman: Typed HOCs with Flow
Publication date: 2018-11-22
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Final stage
-------------------------------------------------------------------
Typed HOCs with Flow

Composition over inheritance is one of the recommended patterns in OOP and in functional programming is just how things work by default. So when using React we work by composing components together to build a whole App and the more we can extract common behavior the more re-usable our code is, this is where Higher Order Components come into play. Weâ€™ll quickly cover some of its basics and benefits of Higher Order Components and then jump into how we can type them with Flow for better developer experience.
Captions: 
	00:00:02,490 --> 00:00:08,960
[Music]

00:00:12,019 --> 00:00:15,450
hey everybody

00:00:13,559 --> 00:00:18,900
thank you for coming I hope you've been

00:00:15,450 --> 00:00:21,840
enjoying reactive cone so far my name is

00:00:18,900 --> 00:00:23,880
Louise Herman and I'm gonna be talking

00:00:21,840 --> 00:00:24,390
about type higher-order components with

00:00:23,880 --> 00:00:27,119
flow

00:00:24,390 --> 00:00:29,070
I'm a senior front-end developer at STR

00:00:27,119 --> 00:00:31,980
B which is a company based here in Prak

00:00:29,070 --> 00:00:35,540
and before jumping into the presentation

00:00:31,980 --> 00:00:39,960
itself on to talk you a little bit about

00:00:35,540 --> 00:00:43,650
my last weekend so this is me watching

00:00:39,960 --> 00:00:45,989
reactive golf I reckon and I'm joined

00:00:43,650 --> 00:00:48,390
dynaroo mouth talking about this cool

00:00:45,989 --> 00:00:53,580
things called hot and then suddenly I'm

00:00:48,390 --> 00:00:56,820
starting to think like hooks hot hooks

00:00:53,580 --> 00:00:58,860
and then I suddenly realized that oh

00:00:56,820 --> 00:01:00,809
 I have a presentation about

00:00:58,860 --> 00:01:03,690
higher-order components and these guys

00:01:00,809 --> 00:01:06,840
coming with this new cool stuff that my

00:01:03,690 --> 00:01:10,560
make hired components obsolete so I was

00:01:06,840 --> 00:01:13,049
you know propagating some dark energy

00:01:10,560 --> 00:01:15,060
wishing he will get a blue screen of

00:01:13,049 --> 00:01:20,130
death but then I realized he was using

00:01:15,060 --> 00:01:22,590
Mac so I come down and I some sense can

00:01:20,130 --> 00:01:25,679
came to me and I realized that okay

00:01:22,590 --> 00:01:27,659
there's still an alpha higher order

00:01:25,679 --> 00:01:30,149
components are still valid and will

00:01:27,659 --> 00:01:31,649
still need to be able to work with

00:01:30,149 --> 00:01:35,630
higher the components and current

00:01:31,649 --> 00:01:38,070
projects hoots are bleeding edge so

00:01:35,630 --> 00:01:39,960
before they stabilize higher the

00:01:38,070 --> 00:01:43,170
components will still be very very

00:01:39,960 --> 00:01:47,450
valuable for us and we'll still need to

00:01:43,170 --> 00:01:50,630
be working with them so now to the talk

00:01:47,450 --> 00:01:53,280
now I'm the first part I'm just gonna

00:01:50,630 --> 00:01:55,469
explain a little bit about harder

00:01:53,280 --> 00:01:58,049
components and a little bit about flow

00:01:55,469 --> 00:02:00,479
so everybody's on the same page probably

00:01:58,049 --> 00:02:03,630
you know some of this stuff already but

00:02:00,479 --> 00:02:08,299
then we'll jump in the third part into

00:02:03,630 --> 00:02:08,299
how we can type them so

00:02:09,920 --> 00:02:15,500
let's check the base signature of a

00:02:12,440 --> 00:02:18,770
higher-order component it's just a

00:02:15,500 --> 00:02:21,890
function that takes a component as input

00:02:18,770 --> 00:02:24,290
and returns a new component the

00:02:21,890 --> 00:02:26,750
component it returns is an enhanced

00:02:24,290 --> 00:02:29,330
version which might have like extra

00:02:26,750 --> 00:02:32,120
properties or during this process of

00:02:29,330 --> 00:02:34,550
enhancing this function we might perform

00:02:32,120 --> 00:02:38,890
some side effects and if we go to the

00:02:34,550 --> 00:02:41,780
react inspector we'll see that B JSX

00:02:38,890 --> 00:02:45,470
that corresponds with this and Hanson

00:02:41,780 --> 00:02:46,970
will look like this the outer enhanced

00:02:45,470 --> 00:02:49,160
component is going to be outside and

00:02:46,970 --> 00:02:53,120
inside is going to be organized that

00:02:49,160 --> 00:02:55,040
component so now let's take a look at

00:02:53,120 --> 00:02:58,790
practical example let's assume we have a

00:02:55,040 --> 00:03:03,250
reduce class base component that look

00:02:58,790 --> 00:03:03,250
like this I hope you is big enough yeah

00:03:03,430 --> 00:03:09,800
so what is doing is some component it

00:03:07,160 --> 00:03:13,040
now is gonna fetch some data from the

00:03:09,800 --> 00:03:15,940
server and then when this Gator comes

00:03:13,040 --> 00:03:17,840
back we're gonna map head to our state

00:03:15,940 --> 00:03:21,079
it's pretty straightforward

00:03:17,840 --> 00:03:24,860
now if the data is not already there

00:03:21,079 --> 00:03:27,950
will show a loader and if all goes right

00:03:24,860 --> 00:03:30,400
then we will do what we actually wanted

00:03:27,950 --> 00:03:31,519
to show on the first place which is the

00:03:30,400 --> 00:03:34,760
JSX

00:03:31,519 --> 00:03:37,670
the HTML that corresponds to the reviews

00:03:34,760 --> 00:03:41,720
so the lay is the styles everything that

00:03:37,670 --> 00:03:44,269
goes there that matters so old-school

00:03:41,720 --> 00:03:46,910
but let's say we are we have more

00:03:44,269 --> 00:03:50,299
components so now we have a film's

00:03:46,910 --> 00:03:52,910
component this film's component is doing

00:03:50,299 --> 00:03:58,370
the same thing as the other component

00:03:52,910 --> 00:04:01,370
was doing so it's just the thing that

00:03:58,370 --> 00:04:04,220
changes is just the route and the

00:04:01,370 --> 00:04:07,250
mapping and then of course what we

00:04:04,220 --> 00:04:09,890
return on the actual render so the the

00:04:07,250 --> 00:04:12,290
HTML the Styles might be different the

00:04:09,890 --> 00:04:15,680
data is different but the rest is just

00:04:12,290 --> 00:04:18,109
the same so we're kind of having to

00:04:15,680 --> 00:04:20,790
copy-paste the same logic every time we

00:04:18,109 --> 00:04:23,700
go to different components

00:04:20,790 --> 00:04:26,570
and the actual render medic gets a

00:04:23,700 --> 00:04:29,580
little bit obscure because all these

00:04:26,570 --> 00:04:33,780
extra logic just to perform this

00:04:29,580 --> 00:04:36,480
fetching so this is a problem that

00:04:33,780 --> 00:04:40,170
higher-order components could solve so

00:04:36,480 --> 00:04:44,130
let's take a look how you look same

00:04:40,170 --> 00:04:46,260
version but stateless here we have just

00:04:44,130 --> 00:04:48,810
a function based component and it's

00:04:46,260 --> 00:04:52,320
pretty clear straight away what is the

00:04:48,810 --> 00:04:54,960
HTML of this component it's pretty

00:04:52,320 --> 00:04:58,470
straightforward and then on the bottom

00:04:54,960 --> 00:05:01,170
we configure or higher-order component

00:04:58,470 --> 00:05:04,470
which is this function here that we just

00:05:01,170 --> 00:05:06,750
pass the URL and the data mapper that we

00:05:04,470 --> 00:05:13,770
need and then on the bottom we just

00:05:06,750 --> 00:05:16,710
enhance these films component and we get

00:05:13,770 --> 00:05:19,860
the same functionality we had before but

00:05:16,710 --> 00:05:23,250
now this enhancer is something we could

00:05:19,860 --> 00:05:28,050
reuse in our reviews component or in any

00:05:23,250 --> 00:05:30,600
component and it's pretty clear the HTML

00:05:28,050 --> 00:05:33,630
and the logic is gonna be down the

00:05:30,600 --> 00:05:37,260
bottom now let's take a look at how

00:05:33,630 --> 00:05:39,600
these with data feature looks so the

00:05:37,260 --> 00:05:43,590
first part is just we have the

00:05:39,600 --> 00:05:46,020
configuration part so we pass the URL

00:05:43,590 --> 00:05:47,940
and the mapper function and what we're

00:05:46,020 --> 00:05:49,560
going to return is the actual

00:05:47,940 --> 00:05:52,140
higher-order component so the first

00:05:49,560 --> 00:05:54,120
function is those configuration second

00:05:52,140 --> 00:05:56,550
is gonna be hired a component it takes

00:05:54,120 --> 00:05:59,340
the base component the previous case it

00:05:56,550 --> 00:06:02,220
was the films and now we return a

00:05:59,340 --> 00:06:03,900
class-based component and this class is

00:06:02,220 --> 00:06:05,940
going to look very similar to what we

00:06:03,900 --> 00:06:08,550
had in the beginning and component the

00:06:05,940 --> 00:06:12,000
noun is gonna fetch some data and it's

00:06:08,550 --> 00:06:14,730
gonna use the URL that we toss and the

00:06:12,000 --> 00:06:17,760
mapper and it's gonna then change the

00:06:14,730 --> 00:06:21,360
loaded state to true whether we get this

00:06:17,760 --> 00:06:24,840
data render metal will look similar as

00:06:21,360 --> 00:06:28,020
the films and so when the state is

00:06:24,840 --> 00:06:30,810
loaded whether the state is not loaded

00:06:28,020 --> 00:06:34,350
will show loader and otherwise we will

00:06:30,810 --> 00:06:37,020
combine the props the state and we will

00:06:34,350 --> 00:06:40,140
pass these two or bass component so it's

00:06:37,020 --> 00:06:42,270
pretty much we just extracted what we

00:06:40,140 --> 00:06:44,700
had on the first component and we just

00:06:42,270 --> 00:06:50,430
put it here in this function there wraps

00:06:44,700 --> 00:06:52,980
whatever we call with it now I'd like to

00:06:50,430 --> 00:06:56,130
think as for high order components as

00:06:52,980 --> 00:06:59,910
something like a checklist so we can

00:06:56,130 --> 00:07:02,250
take whatever we have on our list of

00:06:59,910 --> 00:07:04,080
higher order components and just check

00:07:02,250 --> 00:07:06,450
what we can use to enhance the

00:07:04,080 --> 00:07:09,030
components we have so let's say we have

00:07:06,450 --> 00:07:11,610
a loader and then we want to add with

00:07:09,030 --> 00:07:14,490
data fetcher to this component and let's

00:07:11,610 --> 00:07:17,130
say some extra random functionality and

00:07:14,490 --> 00:07:20,640
it becomes very trivial to just add or

00:07:17,130 --> 00:07:23,790
remove data functionality to our

00:07:20,640 --> 00:07:26,490
components and of course this also makes

00:07:23,790 --> 00:07:31,200
possible that we can share easily all

00:07:26,490 --> 00:07:34,280
these functionality so compulsive Allah

00:07:31,200 --> 00:07:37,830
T is what hire the components provide

00:07:34,280 --> 00:07:40,170
now let's take a look now at a little

00:07:37,830 --> 00:07:42,420
bit of flow we're just gonna cover what

00:07:40,170 --> 00:07:45,600
we're gonna need to understand how we

00:07:42,420 --> 00:07:48,180
can type higher-order components so

00:07:45,600 --> 00:07:51,570
let's take a look at the basic type in

00:07:48,180 --> 00:07:55,230
is we're gonna have this square function

00:07:51,570 --> 00:07:59,280
which just take X and multiply it by

00:07:55,230 --> 00:08:02,010
itself that's it so what we want to do

00:07:59,280 --> 00:08:05,010
is gonna we're going to type the input

00:08:02,010 --> 00:08:08,100
which is the first X to do it we just

00:08:05,010 --> 00:08:11,310
put this colon and then the type that we

00:08:08,100 --> 00:08:14,100
want these types could be strings arrays

00:08:11,310 --> 00:08:16,650
objects whatever you think as a any

00:08:14,100 --> 00:08:18,990
basic or primitive type in JavaScript

00:08:16,650 --> 00:08:21,390
you will put it here and then for the

00:08:18,990 --> 00:08:23,910
return type the only thing we do is

00:08:21,390 --> 00:08:26,130
after the column after the parents of

00:08:23,910 --> 00:08:29,670
the function we just put columns and the

00:08:26,130 --> 00:08:31,890
type now it's pretty basic but it's

00:08:29,670 --> 00:08:33,180
pretty important that you remember the

00:08:31,890 --> 00:08:37,020
position because in higher-order

00:08:33,180 --> 00:08:39,870
components it can get a bit messy now

00:08:37,020 --> 00:08:43,070
another important part that we need to

00:08:39,870 --> 00:08:46,020
understand is generics generics is a

00:08:43,070 --> 00:08:47,790
powerful concept that some type system

00:08:46,020 --> 00:08:52,020
used to introduce some

00:08:47,790 --> 00:08:54,510
sort of type variability in the normally

00:08:52,020 --> 00:08:56,970
hard-coded types we usually just type in

00:08:54,510 --> 00:09:01,650
this is a number there's a string this

00:08:56,970 --> 00:09:06,090
is an array but generics just provide us

00:09:01,650 --> 00:09:08,100
with a way to be more dynamic so let's

00:09:06,090 --> 00:09:10,830
take a look here we just have identity

00:09:08,100 --> 00:09:13,650
function that takes some value returns

00:09:10,830 --> 00:09:15,990
same value pretty simple and on the

00:09:13,650 --> 00:09:18,450
second line we're just calling identity

00:09:15,990 --> 00:09:22,620
over five and this is supposed to return

00:09:18,450 --> 00:09:24,840
a number now to use generics the first

00:09:22,620 --> 00:09:28,860
part that we're gonna need is to add

00:09:24,840 --> 00:09:33,560
these angle brackets before the function

00:09:28,860 --> 00:09:36,030
parens and this is gonna be like a let

00:09:33,560 --> 00:09:38,790
variable definition in JavaScript this

00:09:36,030 --> 00:09:40,350
is just the name of the type variable

00:09:38,790 --> 00:09:42,720
that we're gonna use there's nothing

00:09:40,350 --> 00:09:47,820
special it has no value at this point

00:09:42,720 --> 00:09:51,810
it's just where we define it now we want

00:09:47,820 --> 00:09:55,020
to get the value so to get some type

00:09:51,810 --> 00:09:58,020
value to this T we're just gonna put it

00:09:55,020 --> 00:10:01,290
here on the input and the value will

00:09:58,020 --> 00:10:04,430
flow from whatever we pass when we call

00:10:01,290 --> 00:10:06,840
this function it's just at call time

00:10:04,430 --> 00:10:09,990
when we call this function the type will

00:10:06,840 --> 00:10:16,080
flow to the T and then eventually it

00:10:09,990 --> 00:10:19,470
will flow to the left so this T that

00:10:16,080 --> 00:10:24,300
lives on the Left will have or number

00:10:19,470 --> 00:10:26,510
type in this case now now that we have

00:10:24,300 --> 00:10:29,490
it here on the Left we can reuse it in

00:10:26,510 --> 00:10:31,890
the return type or whatever we want in

00:10:29,490 --> 00:10:34,530
this case is just for the return type so

00:10:31,890 --> 00:10:39,210
just think of it at it as we're

00:10:34,530 --> 00:10:43,980
replacing this by actual types but we

00:10:39,210 --> 00:10:46,710
didn't have to specify them okay now

00:10:43,980 --> 00:10:50,550
let's take a look at object spread it

00:10:46,710 --> 00:10:53,340
works pretty much as in JavaScript we

00:10:50,550 --> 00:10:55,980
have to type objects here and what we

00:10:53,340 --> 00:10:58,220
want to do is that we want to take the

00:10:55,980 --> 00:11:01,320
properties on the first object and

00:10:58,220 --> 00:11:05,610
extend the second object with it so

00:11:01,320 --> 00:11:08,220
we do is we just put the dot dot to

00:11:05,610 --> 00:11:11,100
spread it and that's it this vector

00:11:08,220 --> 00:11:15,450
object will have the three properties X

00:11:11,100 --> 00:11:19,500
Y and C and in reality we'll need to add

00:11:15,450 --> 00:11:22,050
this exact wrapper around it but I'm not

00:11:19,500 --> 00:11:26,310
gonna show it on the next example just

00:11:22,050 --> 00:11:29,550
be a word that you need it now we're

00:11:26,310 --> 00:11:34,500
finally into the part that we want to

00:11:29,550 --> 00:11:37,110
discuss so let's start by talking about

00:11:34,500 --> 00:11:40,110
the most basic element that we want here

00:11:37,110 --> 00:11:42,120
which is the component a component if we

00:11:40,110 --> 00:11:44,570
just think on functional components it's

00:11:42,120 --> 00:11:49,470
just a function that takes some

00:11:44,570 --> 00:11:52,830
properties and returns react element now

00:11:49,470 --> 00:11:55,380
we're here defining an alias just to

00:11:52,830 --> 00:11:56,820
make a shorter version of this so what

00:11:55,380 --> 00:11:59,460
we do is define this dollar sign

00:11:56,820 --> 00:12:02,970
component and whatever we have this

00:11:59,460 --> 00:12:04,950
input P and it will flow here to the P

00:12:02,970 --> 00:12:07,980
on the right so this will be open or

00:12:04,950 --> 00:12:10,650
props the problem is that this will only

00:12:07,980 --> 00:12:13,230
work with function based components and

00:12:10,650 --> 00:12:17,250
we have class-based components so floor

00:12:13,230 --> 00:12:19,140
already provides us with the utility

00:12:17,250 --> 00:12:21,860
function that would do this for us so

00:12:19,140 --> 00:12:24,330
this will be the same thing as before

00:12:21,860 --> 00:12:26,970
but it will also work with classes

00:12:24,330 --> 00:12:29,220
though we'll still be using this dollar

00:12:26,970 --> 00:12:38,310
sign component just make things a little

00:12:29,220 --> 00:12:41,370
bit smaller now Roy you have to try to

00:12:38,310 --> 00:12:43,860
type harder components before and one

00:12:41,370 --> 00:12:46,320
approach could be not using inference at

00:12:43,860 --> 00:12:48,390
all so let's say we have four like a

00:12:46,320 --> 00:12:51,810
lucky number component which renders a

00:12:48,390 --> 00:12:54,900
string that depends on name and random

00:12:51,810 --> 00:12:58,380
properties to this we define them on the

00:12:54,900 --> 00:13:02,640
top and we say that the argument equals

00:12:58,380 --> 00:13:04,410
to these props now all good here but if

00:13:02,640 --> 00:13:06,690
we're gonna use a higher-order component

00:13:04,410 --> 00:13:11,130
here like this these props are going to

00:13:06,690 --> 00:13:12,990
be provided by two hearts then we will

00:13:11,130 --> 00:13:14,700
use with random which will provide

00:13:12,990 --> 00:13:17,400
random property and maps

00:13:14,700 --> 00:13:21,180
to props from readers and this will

00:13:17,400 --> 00:13:25,110
provide the name and now we want to

00:13:21,180 --> 00:13:27,650
enhance it and return now because we're

00:13:25,110 --> 00:13:30,030
providing these properties from the

00:13:27,650 --> 00:13:30,660
higher-order component and not from the

00:13:30,030 --> 00:13:34,170
Perrin

00:13:30,660 --> 00:13:37,110
we need to cast the result of enhancing

00:13:34,170 --> 00:13:39,420
this and say this is a component that

00:13:37,110 --> 00:13:42,270
expects no properties at all so when the

00:13:39,420 --> 00:13:44,250
parent calls this flow won't give an

00:13:42,270 --> 00:13:47,340
error saying hey you're not passing me

00:13:44,250 --> 00:13:50,100
random or not our name now there are

00:13:47,340 --> 00:13:51,870
several problems with this approach the

00:13:50,100 --> 00:13:55,350
first one is that there is no type

00:13:51,870 --> 00:13:58,700
safety here in the enhance in there

00:13:55,350 --> 00:14:02,600
enhancers or compose function is

00:13:58,700 --> 00:14:06,630
literally not type check at this moment

00:14:02,600 --> 00:14:09,510
so we're just bypassing this and we're

00:14:06,630 --> 00:14:11,940
also duplicating the properties that the

00:14:09,510 --> 00:14:14,430
higher-order component is gonna add so

00:14:11,940 --> 00:14:16,290
with we have to check with random is

00:14:14,430 --> 00:14:18,810
going to add this property connect is

00:14:16,290 --> 00:14:21,180
going to act this disorder 1 and if we

00:14:18,810 --> 00:14:23,520
remove one we need to update our props

00:14:21,180 --> 00:14:26,520
but what we want is some sort of

00:14:23,520 --> 00:14:28,440
cohesion between the types and the high

00:14:26,520 --> 00:14:32,670
order component so we add something

00:14:28,440 --> 00:14:37,080
it adds the types immediately so how we

00:14:32,670 --> 00:14:41,160
can do that let's say let's take a look

00:14:37,080 --> 00:14:44,970
at the hierarch Manan with random which

00:14:41,160 --> 00:14:48,300
will just take base component and return

00:14:44,970 --> 00:14:51,210
and hence version which will have this

00:14:48,300 --> 00:14:54,420
random number and the rest of the

00:14:51,210 --> 00:14:56,670
property is pretty simple and let's say

00:14:54,420 --> 00:14:58,790
on a different file we have this lucky

00:14:56,670 --> 00:15:03,300
number which is the same one as before

00:14:58,790 --> 00:15:06,630
and we're just enhancing with random and

00:15:03,300 --> 00:15:09,840
that's it if you notice now we're not

00:15:06,630 --> 00:15:13,740
using map state 2 props so name has to

00:15:09,840 --> 00:15:20,580
be passed by whoever calls this lucky

00:15:13,740 --> 00:15:22,770
number so let's start typing so the

00:15:20,580 --> 00:15:25,020
first thing that we're gonna focus is on

00:15:22,770 --> 00:15:27,120
the return type of the higher-order

00:15:25,020 --> 00:15:31,019
component

00:15:27,120 --> 00:15:33,449
so we're by adding this after the

00:15:31,019 --> 00:15:35,309
parents we just say hey this whatever

00:15:33,449 --> 00:15:39,360
whenever we call this we're gonna return

00:15:35,309 --> 00:15:42,689
a component that takes no properties in

00:15:39,360 --> 00:15:45,509
if we inspect what is on the wrapper

00:15:42,689 --> 00:15:48,540
sigh on the bottle we'll see that this

00:15:45,509 --> 00:15:50,850
is a component that takes no property so

00:15:48,540 --> 00:15:54,449
at least this is not our component but

00:15:50,850 --> 00:15:57,509
it will not be very useful because the

00:15:54,449 --> 00:15:59,610
inner component lucky number don't it

00:15:57,509 --> 00:16:02,670
won't even have any kind of type it will

00:15:59,610 --> 00:16:06,360
be type empty and basically it will be

00:16:02,670 --> 00:16:08,809
not be type safe so let's work now on

00:16:06,360 --> 00:16:10,709
the inner component the base component

00:16:08,809 --> 00:16:14,220
we do the same thing

00:16:10,709 --> 00:16:17,970
we say base component is this component

00:16:14,220 --> 00:16:21,240
with empty properties and that's it now

00:16:17,970 --> 00:16:24,870
just remember that this is going to be

00:16:21,240 --> 00:16:28,680
what is in what's gonna be rubber so in

00:16:24,870 --> 00:16:31,529
this case a lucky number and flow will

00:16:28,680 --> 00:16:34,199
know that the props in this case is an

00:16:31,529 --> 00:16:37,139
empty object now name and random will

00:16:34,199 --> 00:16:39,660
have some error because of course name

00:16:37,139 --> 00:16:43,079
and random does not exist in this empty

00:16:39,660 --> 00:16:45,269
object so let's keep working on that but

00:16:43,079 --> 00:16:49,589
let's focus again on the outer component

00:16:45,269 --> 00:16:52,019
now whenever somebody calls a lucky

00:16:49,589 --> 00:16:57,660
number from outside we want them to pass

00:16:52,019 --> 00:17:01,170
the name and in order to do it we

00:16:57,660 --> 00:17:04,199
specify here on the return type of the

00:17:01,170 --> 00:17:07,819
Huq and now whoever calls this needs to

00:17:04,199 --> 00:17:11,760
pass name otherwise we'll get an error

00:17:07,819 --> 00:17:13,949
if we inspect what is with random now is

00:17:11,760 --> 00:17:21,539
gonna say is this component with the

00:17:13,949 --> 00:17:24,839
expecting name string now let's type the

00:17:21,539 --> 00:17:28,159
inner component we're gonna say the the

00:17:24,839 --> 00:17:32,580
base component is going to take a

00:17:28,159 --> 00:17:35,309
property's name and random so this will

00:17:32,580 --> 00:17:36,539
match directly with whatever we call so

00:17:35,309 --> 00:17:38,549
in this case is going to be a lucky

00:17:36,539 --> 00:17:40,650
number and the props is going to turn

00:17:38,549 --> 00:17:44,190
into being this name

00:17:40,650 --> 00:17:47,180
and string a string and random number so

00:17:44,190 --> 00:17:51,560
right now it is completely tied check

00:17:47,180 --> 00:17:53,940
but the problem is that everything is

00:17:51,560 --> 00:17:56,850
tightly coupled between the higher-order

00:17:53,940 --> 00:17:58,650
component and or component that we want

00:17:56,850 --> 00:18:01,080
to enhance so this will only work with

00:17:58,650 --> 00:18:05,790
lucky number which is terrible but at

00:18:01,080 --> 00:18:10,200
least this is what we want to get infer

00:18:05,790 --> 00:18:15,060
my flow so let's start adding some

00:18:10,200 --> 00:18:17,970
generics and just remember we just put

00:18:15,060 --> 00:18:22,230
the in the angle brackets before the

00:18:17,970 --> 00:18:25,680
function call ah the P which is gonna be

00:18:22,230 --> 00:18:28,860
or perhaps and what we want is get the

00:18:25,680 --> 00:18:30,690
properties from the pairing so the

00:18:28,860 --> 00:18:34,380
properties that are passed to this

00:18:30,690 --> 00:18:36,840
component so we're going to replace P in

00:18:34,380 --> 00:18:39,960
the return type in the outer component

00:18:36,840 --> 00:18:43,170
but right now we have no types because

00:18:39,960 --> 00:18:48,150
nobody is specifying that this component

00:18:43,170 --> 00:18:51,960
is gonna need name as a string from

00:18:48,150 --> 00:18:55,700
outside so we need to add this casting

00:18:51,960 --> 00:18:58,230
again and what we're saying here is that

00:18:55,700 --> 00:19:01,520
this is a component that takes name

00:18:58,230 --> 00:19:05,360
string and whatever we put here on the

00:19:01,520 --> 00:19:08,850
component is going to flow directly to

00:19:05,360 --> 00:19:11,730
the return type so now flow can infer

00:19:08,850 --> 00:19:15,540
whatever we put here on the button is

00:19:11,730 --> 00:19:21,060
gonna use it here now as you can see we

00:19:15,540 --> 00:19:25,350
have now named string and we also use it

00:19:21,060 --> 00:19:31,290
on the inner component so we can replace

00:19:25,350 --> 00:19:33,810
what we previously have and that way we

00:19:31,290 --> 00:19:38,030
just spread the P which contains the

00:19:33,810 --> 00:19:42,120
main string and right now we will have

00:19:38,030 --> 00:19:44,700
exactly as we did before but just we

00:19:42,120 --> 00:19:47,970
type inference so this component is no

00:19:44,700 --> 00:19:49,830
longer couple with with this high order

00:19:47,970 --> 00:19:51,840
come on is no longer couple with this

00:19:49,830 --> 00:19:54,750
lucky number because we're just taking

00:19:51,840 --> 00:19:57,390
whatever is infer on the cast

00:19:54,750 --> 00:20:03,780
from the bottom and then spreading it

00:19:57,390 --> 00:20:05,400
inside the base component now we could

00:20:03,780 --> 00:20:07,440
do even a bit better

00:20:05,400 --> 00:20:09,420
this is fully type there's not nothing

00:20:07,440 --> 00:20:13,320
we can improve on their type in so far

00:20:09,420 --> 00:20:15,840
but we can make it more easy easier to

00:20:13,320 --> 00:20:20,030
to add these higher-order components

00:20:15,840 --> 00:20:23,730
types so what we do we could do is add

00:20:20,030 --> 00:20:27,120
create a helper so let's say here we

00:20:23,730 --> 00:20:28,920
just have this type Huck but the only

00:20:27,120 --> 00:20:30,750
thing we're gonna pass is the extra

00:20:28,920 --> 00:20:33,810
properties that this higher-order

00:20:30,750 --> 00:20:36,600
component is gonna be adding and on the

00:20:33,810 --> 00:20:39,660
right is just a normal signature that I

00:20:36,600 --> 00:20:41,670
show you before so it's just a function

00:20:39,660 --> 00:20:43,470
that takes a component and returns the

00:20:41,670 --> 00:20:46,010
new component you notice that we have

00:20:43,470 --> 00:20:49,140
here the angle brackets with the P and

00:20:46,010 --> 00:20:54,090
on the return type we also have replaced

00:20:49,140 --> 00:20:55,770
the P so it works similar as before the

00:20:54,090 --> 00:20:59,040
only thing that we have to do now is

00:20:55,770 --> 00:21:02,880
spread what is passed from the parent

00:20:59,040 --> 00:21:06,360
from outside into the base component the

00:21:02,880 --> 00:21:09,540
weather comes as input and we add the

00:21:06,360 --> 00:21:14,220
extra properties that we specify on the

00:21:09,540 --> 00:21:18,600
left so now becomes very trivial to type

00:21:14,220 --> 00:21:20,820
or component so let's say we have again

00:21:18,600 --> 00:21:23,640
the same with random but there is no

00:21:20,820 --> 00:21:26,100
types there's nothing here so the only

00:21:23,640 --> 00:21:29,820
thing we need to add now is this helper

00:21:26,100 --> 00:21:32,820
and specify what is the this

00:21:29,820 --> 00:21:34,850
higher-order component adding in general

00:21:32,820 --> 00:21:38,250
in this case system is just one property

00:21:34,850 --> 00:21:41,340
random and this is gonna be spreaded in

00:21:38,250 --> 00:21:44,640
your helper now we could use the same

00:21:41,340 --> 00:21:47,190
thing as we did before and that's it it

00:21:44,640 --> 00:21:49,440
worked exactly as it did but then we

00:21:47,190 --> 00:21:51,570
could declare this hoc helper as a

00:21:49,440 --> 00:21:54,120
global and we could reuse it in many

00:21:51,570 --> 00:21:56,220
places and it becomes very very easy to

00:21:54,120 --> 00:22:03,510
just type at least this type of

00:21:56,220 --> 00:22:06,060
component so are wrapping up hugs are

00:22:03,510 --> 00:22:08,080
still valid so strike all generic

00:22:06,060 --> 00:22:12,880
functionality you can in

00:22:08,080 --> 00:22:15,130
- higher components now you know how you

00:22:12,880 --> 00:22:18,059
know know the building blocks to type

00:22:15,130 --> 00:22:22,630
your higher components so please do so

00:22:18,059 --> 00:22:25,419
and just remember if we use type

00:22:22,630 --> 00:22:27,490
inference will bake the types directly

00:22:25,419 --> 00:22:29,830
into a higher component so every time

00:22:27,490 --> 00:22:33,070
we'd remove let's say with random it

00:22:29,830 --> 00:22:34,929
will change the types automatically that

00:22:33,070 --> 00:22:36,880
the component is gonna be expecting

00:22:34,929 --> 00:22:39,669
there's no need to duplicate the code

00:22:36,880 --> 00:22:41,350
and this is a problem that it's

00:22:39,669 --> 00:22:45,039
currently with times great that we have

00:22:41,350 --> 00:22:48,159
to repeat or or props again and in some

00:22:45,039 --> 00:22:50,470
local basis that we have a lot of long

00:22:48,159 --> 00:22:52,720
list of properties that are coming from

00:22:50,470 --> 00:22:55,269
high order component especially from mob

00:22:52,720 --> 00:22:57,399
stay to props all that could be inferred

00:22:55,269 --> 00:23:02,019
just by using this there's no need to

00:22:57,399 --> 00:23:05,049
retype again and just remember hoc is

00:23:02,019 --> 00:23:07,179
just a pattern there is also the new

00:23:05,049 --> 00:23:09,370
hooks which are in alpha but might be

00:23:07,179 --> 00:23:14,139
interesting in the future and there is

00:23:09,370 --> 00:23:17,549
also render - props but I think I really

00:23:14,139 --> 00:23:26,260
like higher the components so I hope you

00:23:17,549 --> 00:23:29,230
learn something and that's it guys thank

00:23:26,260 --> 00:23:32,980
you thank you very much so again of

00:23:29,230 --> 00:23:35,950
questions yeah first off why did you

00:23:32,980 --> 00:23:38,590
choose throw over type screen okay I was

00:23:35,950 --> 00:23:42,250
using typescript before like two years

00:23:38,590 --> 00:23:45,429
ago I it was pretty good but the support

00:23:42,250 --> 00:23:51,059
for react was not that good at the

00:23:45,429 --> 00:23:51,059
moment so I switched to to flow and

00:23:51,419 --> 00:24:00,130
everyone I switched to flow and it was a

00:23:57,940 --> 00:24:02,830
pretty interesting experience no

00:24:00,130 --> 00:24:06,490
typescript is gotten way way way better

00:24:02,830 --> 00:24:08,200
it's really good at this point and this

00:24:06,490 --> 00:24:10,899
might change in the future

00:24:08,200 --> 00:24:13,720
but still when we're using higher-order

00:24:10,899 --> 00:24:16,120
components flow we'll have the upper

00:24:13,720 --> 00:24:18,490
hand because there is no way at this

00:24:16,120 --> 00:24:20,380
moment that Tyler can get this type

00:24:18,490 --> 00:24:22,040
inference that I show you you have to

00:24:20,380 --> 00:24:24,720
type exactly

00:24:22,040 --> 00:24:26,850
every property that you expect now I'm

00:24:24,720 --> 00:24:29,490
not expert in typescript but that it was

00:24:26,850 --> 00:24:31,380
like this last time I checked but this

00:24:29,490 --> 00:24:34,680
might change in the future so that's

00:24:31,380 --> 00:24:37,800
like the main reason I choose flow over

00:24:34,680 --> 00:24:40,740
touchscreen right thank you I think you

00:24:37,800 --> 00:24:43,260
addressed about the next to both of the

00:24:40,740 --> 00:24:48,360
next two questions in one of your last

00:24:43,260 --> 00:24:51,330
rites but if you want to address it okay

00:24:48,360 --> 00:24:55,380
more okay three different patterns

00:24:51,330 --> 00:24:57,750
they're pretty useful but render drops

00:24:55,380 --> 00:24:59,910
is good when you want to be like very

00:24:57,750 --> 00:25:02,430
explicit about what you're going to do

00:24:59,910 --> 00:25:05,360
so it's very useful in some cases I use

00:25:02,430 --> 00:25:08,130
it then a lot but if I want to like add

00:25:05,360 --> 00:25:09,990
five higher-order components I will

00:25:08,130 --> 00:25:12,180
probably not be doing that with render

00:25:09,990 --> 00:25:16,620
two props because it will become a mess

00:25:12,180 --> 00:25:19,680
in nesting all these JSX so I really

00:25:16,620 --> 00:25:21,540
like to keep at least on my call even

00:25:19,680 --> 00:25:25,050
though the we are expect story will

00:25:21,540 --> 00:25:27,150
change I like to keep flat by enhancing

00:25:25,050 --> 00:25:29,520
so if I want to be perfect explicit and

00:25:27,150 --> 00:25:32,730
it's only one thing that I want to

00:25:29,520 --> 00:25:36,540
enhance I'll probably use render props

00:25:32,730 --> 00:25:41,250
otherwise I'll just be using hoops and

00:25:36,540 --> 00:25:44,130
do you think I do think that higher

00:25:41,250 --> 00:25:46,710
other components will become less use

00:25:44,130 --> 00:25:49,080
but I'm thinking that there will be some

00:25:46,710 --> 00:25:51,030
sort of combination between higher than

00:25:49,080 --> 00:25:55,170
components and hooks and then exporting

00:25:51,030 --> 00:25:57,780
hooks but I do like that that in higher

00:25:55,170 --> 00:25:59,790
components is sort of like a dependency

00:25:57,780 --> 00:26:02,580
injection you'll be injecting the

00:25:59,790 --> 00:26:05,340
properties from outside the component

00:26:02,580 --> 00:26:07,050
and with hooks you're pretty much what

00:26:05,340 --> 00:26:08,990
you import you have like direct

00:26:07,050 --> 00:26:13,130
dependencies there in the render method

00:26:08,990 --> 00:26:15,480
so at least for I'll be using an outer

00:26:13,130 --> 00:26:17,550
higher-order component that will inject

00:26:15,480 --> 00:26:20,010
the properties that comes from the hoods

00:26:17,550 --> 00:26:21,810
but I still haven't experimented a lot

00:26:20,010 --> 00:26:24,150
with it but I still think that

00:26:21,810 --> 00:26:27,570
higher-order components will be used in

00:26:24,150 --> 00:26:29,880
a listicle basis right now right thank

00:26:27,570 --> 00:26:32,820
you and the last question we still have

00:26:29,880 --> 00:26:34,080
a couple minutes so are you hosting non

00:26:32,820 --> 00:26:37,169
react static

00:26:34,080 --> 00:26:40,380
and following graphs are you who is in

00:26:37,169 --> 00:26:43,500
higher-order components and also you can

00:26:40,380 --> 00:26:47,309
address the render probes art okay I

00:26:43,500 --> 00:26:49,429
honestly haven't run into this so

00:26:47,309 --> 00:26:53,010
unfortunately I cannot answer this one

00:26:49,429 --> 00:26:53,600
alright okay so thank you very much

00:26:53,010 --> 00:26:56,910
again

00:26:53,600 --> 00:26:56,910

YouTube URL: https://www.youtube.com/watch?v=U2jviGt4HAk


