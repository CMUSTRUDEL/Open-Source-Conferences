Title: ReactiveConf 2018: Lightning Talks - Day 1
Publication date: 2018-11-02
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Main stage
-------------------------------------------------------------------
1. Speaker: Sergey Tkachenko
Do we need types in JavaScript?
In this talk, I want to share my experience gained during the development of frontend applications in several programming languages. I think it's not a secret for anybody that developing large JavaScript applications is not so easy as it seems at first glance. We all want something simpler and more reliable. Therefore, many developers and even entire companies switch to different, compiled in JavaScript, programming languages. The bulk of such transitions is accounted for TypeScript and flow, and often, developers faced with more problems than they were before. I wasn't the exception. Moving to a new project, I started using TypeScript and was disappointed. Luckily in my next project I used ClojureScript and it was like everything is illuminated! Since then, I know exactly what the recipe for simple and reliable code (even in plain old JavaScript). And I want to share this recipe with you.

2.Speaker: David Kopal
Write better React
Do you want to write better React? In that case, you shouldnâ€™t use it with JavaScript. Why? Because JavaScript isn't compatible with React's core principles, meaning you need to mimic them using many external libraries. Fortunately, Reason is here and ready to help you out through writing safer and cleaner React code.

3. Speaker: Jakub Svehla
Avoid runtime errors with 0 lines of tests & types.
I'll show you how to not to waste your time with resolving runtime errors. Our company has only 2.5 developers so we have literally no time for writing tests or types (yeee... it's still boring). We will use the most modern bleeding edge Javascript stack based on graphQL & relay modern & flowtype for solving this pain. And don't be scared, everything is production ready and we are using it.

4. Speaker: Stefan Nieuwenhuis
How to build a framework independent component library with StencilJS
Challenge: Build a frontend component library for multiple teams with a technology stack ranging from VanillaJs to React. Let's take up this challenge with StencilJS!
What is StencilJS? StencilJS is a compiler that generates Web Components. It combines the best concepts of the most popular frameworks into a simple build-time tool.
What you can expect to see How to build a Web Component with StencilJS How to use it in an Angular, Vue.js and React app
Captions: 
	00:00:02,220 --> 00:00:08,679
[Music]

00:00:11,730 --> 00:00:18,119
my name is Sergei I'm from Moscow and

00:00:15,240 --> 00:00:20,529
working for a company called ACORN and

00:00:18,119 --> 00:00:22,929
today I want to share with you some

00:00:20,529 --> 00:00:25,240
thoughts and recites that I found useful

00:00:22,929 --> 00:00:27,720
during my development experience in

00:00:25,240 --> 00:00:31,419
several programming languages so

00:00:27,720 --> 00:00:35,200
basically it was JavaScript typescript

00:00:31,419 --> 00:00:37,780
and closure script but keep in mind that

00:00:35,200 --> 00:00:40,629
there is no silver bullet so probably my

00:00:37,780 --> 00:00:43,180
recite wouldn't work for every job you

00:00:40,629 --> 00:00:46,510
might have but if you are trying to be

00:00:43,180 --> 00:00:49,480
agile flexible to changes and productive

00:00:46,510 --> 00:00:53,890
I'm sure that those types will work for

00:00:49,480 --> 00:00:58,539
you so just recite used tools that make

00:00:53,890 --> 00:01:01,719
your code simple very basic example say

00:00:58,539 --> 00:01:05,440
we have an a book and we want to get

00:01:01,719 --> 00:01:07,600
title from this book it's just one line

00:01:05,440 --> 00:01:10,840
of code but so many things could go

00:01:07,600 --> 00:01:13,780
wrong the server could not respond or we

00:01:10,840 --> 00:01:15,940
this can run this code before we get

00:01:13,780 --> 00:01:22,000
server spawns or it could be a hundred

00:01:15,940 --> 00:01:26,650
of other reasons and at some point of

00:01:22,000 --> 00:01:29,260
time in time I thought that I can fix it

00:01:26,650 --> 00:01:33,040
with types so I start using typescript

00:01:29,260 --> 00:01:36,190
and instead one line of code I've got

00:01:33,040 --> 00:01:38,080
seven and just think about it it's this

00:01:36,190 --> 00:01:41,020
is extra code has nothing about your

00:01:38,080 --> 00:01:43,150
product or business logic it's just some

00:01:41,020 --> 00:01:48,100
kind of workaround of single line of

00:01:43,150 --> 00:01:52,030
code so what if this code will just work

00:01:48,100 --> 00:01:54,340
without any extra manipulations and I

00:01:52,030 --> 00:01:56,710
found the answer this is a kosher script

00:01:54,340 --> 00:02:00,700
code and it's basically do the same as

00:01:56,710 --> 00:02:04,150
previous and it will work no matter how

00:02:00,700 --> 00:02:07,270
hard you try to break it if you familiar

00:02:04,150 --> 00:02:10,780
with functional programming concepts you

00:02:07,270 --> 00:02:13,810
might notice that this behavior pretty

00:02:10,780 --> 00:02:16,989
similar to maybe Monett in from other

00:02:13,810 --> 00:02:18,100
functional languages and the good thing

00:02:16,989 --> 00:02:20,350
is that in closure

00:02:18,100 --> 00:02:23,260
and Gaza Strip you don't have to think

00:02:20,350 --> 00:02:25,930
much about it you just use plain data

00:02:23,260 --> 00:02:29,220
structures and keep your code simple but

00:02:25,930 --> 00:02:33,660
under the hood it will work like monitor

00:02:29,220 --> 00:02:36,790
so next type use immutable values

00:02:33,660 --> 00:02:39,430
immutability has many benefits and it's

00:02:36,790 --> 00:02:41,410
really hard to overestimate but from is

00:02:39,430 --> 00:02:43,690
the most important thing in immutability

00:02:41,410 --> 00:02:46,810
is that you get the proper meaning of

00:02:43,690 --> 00:02:50,200
the quality for free so in this example

00:02:46,810 --> 00:02:53,380
for human it's obvious that those two

00:02:50,200 --> 00:02:56,950
objects are equal right and but

00:02:53,380 --> 00:02:59,590
javascript it's not in JavaScript all

00:02:56,950 --> 00:03:02,620
data structures are immutable by default

00:02:59,590 --> 00:03:05,530
so it's really easy to make assumptions

00:03:02,620 --> 00:03:09,370
about them you could compare nested

00:03:05,530 --> 00:03:12,100
objects array sets or whatever you can

00:03:09,370 --> 00:03:15,310
simplify a dozens of algorithms which

00:03:12,100 --> 00:03:18,070
operates on data and you never have to

00:03:15,310 --> 00:03:21,060
implement things like shoot components

00:03:18,070 --> 00:03:25,300
update method inside react components

00:03:21,060 --> 00:03:27,490
due to immutability you get the minimum

00:03:25,300 --> 00:03:30,550
rendering cycles in your react

00:03:27,490 --> 00:03:31,960
application so I think it's a really

00:03:30,550 --> 00:03:37,450
great feature

00:03:31,960 --> 00:03:39,240
so next type is a focus on data when we

00:03:37,450 --> 00:03:41,800
are talking about functional programming

00:03:39,240 --> 00:03:43,960
we talk about pure functions

00:03:41,800 --> 00:03:46,540
higher-order functions function

00:03:43,960 --> 00:03:49,180
composition and things like that but I

00:03:46,540 --> 00:03:50,350
think it's a little bit wrong view to

00:03:49,180 --> 00:03:53,020
the functional programming

00:03:50,350 --> 00:03:55,600
I think functional programming is the

00:03:53,020 --> 00:03:57,820
first of all about data not functions of

00:03:55,600 --> 00:04:01,150
course we will use a lot of them but

00:03:57,820 --> 00:04:03,640
only to assist to the data flow for

00:04:01,150 --> 00:04:06,040
example in Haskell pure functional

00:04:03,640 --> 00:04:09,190
language you can do nothing without Moe

00:04:06,040 --> 00:04:11,530
not even bring something to the terminal

00:04:09,190 --> 00:04:13,870
and those manat it's just data

00:04:11,530 --> 00:04:15,760
structures that will be mapped to the

00:04:13,870 --> 00:04:19,900
side effects at the borders of your

00:04:15,760 --> 00:04:22,360
application and this is true a sense of

00:04:19,900 --> 00:04:24,510
the functional programming you have a

00:04:22,360 --> 00:04:28,230
pure functional core and

00:04:24,510 --> 00:04:31,220
a very small infinitive shell that know

00:04:28,230 --> 00:04:34,050
how to deal with the rest of the world

00:04:31,220 --> 00:04:36,540
in college we don't have built-in

00:04:34,050 --> 00:04:38,460
monarchs like in Haskell but we have

00:04:36,540 --> 00:04:41,460
supercharged immutable data structures

00:04:38,460 --> 00:04:43,950
and we use them to express things like

00:04:41,460 --> 00:04:48,930
HTTP requests to deal with the browser

00:04:43,950 --> 00:04:51,960
api's and make third-party services

00:04:48,930 --> 00:04:56,340
communication so data is our cornerstone

00:04:51,960 --> 00:05:00,210
and I you should keep focus on that and

00:04:56,340 --> 00:05:02,730
the last type it's grow your mindset so

00:05:00,210 --> 00:05:05,570
color script is really awesome and it

00:05:02,730 --> 00:05:08,610
helps a lot in a day to day programming

00:05:05,570 --> 00:05:10,850
but I think the true value of course or

00:05:08,610 --> 00:05:13,470
script is a way of thinking about

00:05:10,850 --> 00:05:17,010
programming in general about programming

00:05:13,470 --> 00:05:18,660
problems and today I have covered only a

00:05:17,010 --> 00:05:19,880
little piece of what core script can

00:05:18,660 --> 00:05:22,770
offer to you

00:05:19,880 --> 00:05:25,380
just give it a try start learning or

00:05:22,770 --> 00:05:28,260
write little pet project bring the main

00:05:25,380 --> 00:05:30,500
ideas from core script to your code no

00:05:28,260 --> 00:05:33,120
matter which language you are using I

00:05:30,500 --> 00:05:37,260
assure you it will reduce the head age

00:05:33,120 --> 00:05:39,380
and level up you as a developer so thank

00:05:37,260 --> 00:05:39,380
you

00:05:44,610 --> 00:05:54,220
Thank You Sergei do we have any

00:05:49,960 --> 00:06:00,520
questions we have time for maybe one now

00:05:54,220 --> 00:06:02,050
is your chance shoot no one maybe was

00:06:00,520 --> 00:06:04,790
really fast it was super clear then

00:06:02,050 --> 00:06:07,420
thank you very much thank you

00:06:04,790 --> 00:06:13,949
[Applause]

00:06:07,420 --> 00:06:13,949
[Music]

00:06:17,770 --> 00:06:24,260
so hi everyone my name is David I have a

00:06:22,100 --> 00:06:27,290
Twitter coding underscore lawyer and

00:06:24,260 --> 00:06:32,120
today I will tell you how to write

00:06:27,290 --> 00:06:35,000
better react so react is one of the most

00:06:32,120 --> 00:06:38,240
popular ways to build user interfaces in

00:06:35,000 --> 00:06:42,550
JavaScript so react is pretty cool right

00:06:38,240 --> 00:06:46,910
but could you make it even cooler better

00:06:42,550 --> 00:06:50,390
in order to write better react we need

00:06:46,910 --> 00:06:54,980
to understand its problems so what's the

00:06:50,390 --> 00:06:58,820
main problem of react well react isn't a

00:06:54,980 --> 00:07:00,980
native JavaScript library I mean if you

00:06:58,820 --> 00:07:03,680
take a closer look at it you will see

00:07:00,980 --> 00:07:07,210
that some of its principles are foreign

00:07:03,680 --> 00:07:10,520
to JavaScript let's visualize this

00:07:07,210 --> 00:07:12,740
immutability in react we want to keep

00:07:10,520 --> 00:07:15,020
our stuff immutable we don't want to

00:07:12,740 --> 00:07:17,690
emulate our our state and our props

00:07:15,020 --> 00:07:21,620
because if we did we will get some weird

00:07:17,690 --> 00:07:24,530
consequences in JavaScript we don't have

00:07:21,620 --> 00:07:27,260
immutability out of the box so if you

00:07:24,530 --> 00:07:29,510
want to keep your stuff immutable you

00:07:27,260 --> 00:07:34,360
need to use external libraries such as

00:07:29,510 --> 00:07:37,910
immutable Jas or do it by a convention

00:07:34,360 --> 00:07:40,010
functional programming we act is based

00:07:37,910 --> 00:07:42,650
on the functional programming I mean

00:07:40,010 --> 00:07:46,340
react applications are composition of

00:07:42,650 --> 00:07:48,530
functions JavaScript on the other hand

00:07:46,340 --> 00:07:50,630
although it has some functional

00:07:48,530 --> 00:07:53,390
programming features such as first-class

00:07:50,630 --> 00:07:56,090
function it's not functional programming

00:07:53,390 --> 00:07:58,040
language because if you really want to

00:07:56,090 --> 00:08:00,350
write some nice declarative JavaScript

00:07:58,040 --> 00:08:04,460
code you need to use external libraries

00:08:00,350 --> 00:08:08,330
such as lambda or low - FP type system

00:08:04,460 --> 00:08:11,480
in react we have a probe types and probe

00:08:08,330 --> 00:08:15,169
types is a way how to simulate static

00:08:11,480 --> 00:08:18,560
types in JavaScript because javascript

00:08:15,169 --> 00:08:20,450
is an statically typed language if you

00:08:18,560 --> 00:08:23,030
really want to use some advanced types

00:08:20,450 --> 00:08:24,740
in JavaScript again you need to use

00:08:23,030 --> 00:08:28,460
external libraries

00:08:24,740 --> 00:08:30,680
such as flow or typescript so if you

00:08:28,460 --> 00:08:33,620
take a look at our chart you can see

00:08:30,680 --> 00:08:37,640
that the JavaScript is incompatible with

00:08:33,620 --> 00:08:39,919
Reax core principles so the question is

00:08:37,640 --> 00:08:43,690
is there some other language it might be

00:08:39,919 --> 00:08:46,300
more compatible with react in JavaScript

00:08:43,690 --> 00:08:48,890
fortunately there's reason ml

00:08:46,300 --> 00:08:51,890
immutability in reason we have

00:08:48,890 --> 00:08:54,620
immutability out-of-the-box functional

00:08:51,890 --> 00:08:57,860
programming reason is based on Oh camel

00:08:54,620 --> 00:09:02,540
functional programming language type

00:08:57,860 --> 00:09:04,910
system reason has strong type system so

00:09:02,540 --> 00:09:07,279
if you take a look at our chart again

00:09:04,910 --> 00:09:10,220
you can see that the reason is more

00:09:07,279 --> 00:09:13,790
compatible with react than JavaScript

00:09:10,220 --> 00:09:16,420
so what's reason it's not a new

00:09:13,790 --> 00:09:19,880
programming language it's an alternative

00:09:16,420 --> 00:09:21,680
JavaScript like syntax for Oakham oh the

00:09:19,880 --> 00:09:24,010
functional programming language that has

00:09:21,680 --> 00:09:27,050
been around for more than 20 years and

00:09:24,010 --> 00:09:29,660
things to reason you can write oh kammo

00:09:27,050 --> 00:09:32,450
using javascript like syntax that

00:09:29,660 --> 00:09:35,060
compiles to JavaScript and thanks to

00:09:32,450 --> 00:09:37,700
this you can take advantage of all the

00:09:35,060 --> 00:09:40,220
cool or camel features such as its

00:09:37,700 --> 00:09:43,670
strong built in type system or pattern

00:09:40,220 --> 00:09:46,790
matching and other features but this

00:09:43,670 --> 00:09:49,399
talk is about react and we can write

00:09:46,790 --> 00:09:53,570
react in reason thanks to recent react

00:09:49,399 --> 00:09:56,899
library maybe you are not now thinking

00:09:53,570 --> 00:09:59,660
why should I use react in reason well

00:09:56,899 --> 00:10:03,800
we've already mentioned that reason is

00:09:59,660 --> 00:10:07,100
compatible with react and why why is it

00:10:03,800 --> 00:10:10,370
compatible because react was developed

00:10:07,100 --> 00:10:13,010
for reason more specifically it was

00:10:10,370 --> 00:10:14,980
developed for oak ammo because first we

00:10:13,010 --> 00:10:18,079
expert type was built in standard ml

00:10:14,980 --> 00:10:21,110
cousin of oak ammo then it was moved to

00:10:18,079 --> 00:10:25,850
Oak ammo and transcribed to JavaScript

00:10:21,110 --> 00:10:29,540
and when JavaScript when react came into

00:10:25,850 --> 00:10:32,720
JavaScript we need to adjust JavaScript

00:10:29,540 --> 00:10:35,270
to reacts needs so we created a lot of

00:10:32,720 --> 00:10:38,600
tools and libraries to make development

00:10:35,270 --> 00:10:42,980
smoother and this means another layer

00:10:38,600 --> 00:10:45,440
complexity for our application so your

00:10:42,980 --> 00:10:49,730
typical react application will have at

00:10:45,440 --> 00:10:53,630
least these dependencies now what we

00:10:49,730 --> 00:10:55,730
swap react for reason react do we still

00:10:53,630 --> 00:11:00,019
need all these dependencies

00:10:55,730 --> 00:11:03,350
I mean immutability in reason we have

00:11:00,019 --> 00:11:05,209
built an immutability static typing in

00:11:03,350 --> 00:11:08,870
reason we have a strong type system

00:11:05,209 --> 00:11:11,350
built in router we have a router built

00:11:08,870 --> 00:11:15,110
inside reason react library

00:11:11,350 --> 00:11:17,000
yes lent lent Inc we have a compiler

00:11:15,110 --> 00:11:20,300
that provides us with readable warning

00:11:17,000 --> 00:11:22,759
and error messages prettier code from

00:11:20,300 --> 00:11:24,800
adding in reason we have reason

00:11:22,759 --> 00:11:26,720
formatter and it's a built-in formatter

00:11:24,800 --> 00:11:30,259
that will form at your code in the only

00:11:26,720 --> 00:11:32,750
possible way helper functions such as

00:11:30,259 --> 00:11:34,790
from de or lo - we have enough helper

00:11:32,750 --> 00:11:37,790
functions builds inside reason

00:11:34,790 --> 00:11:39,529
so if you write react in reason you

00:11:37,790 --> 00:11:43,880
won't need these and many other

00:11:39,529 --> 00:11:45,980
dependencies and why because the reason

00:11:43,880 --> 00:11:47,930
is based on Oh camel the functional

00:11:45,980 --> 00:11:50,240
programming language the majored

00:11:47,930 --> 00:11:52,370
language with all of its core principles

00:11:50,240 --> 00:11:57,980
and rules how to structure your code

00:11:52,370 --> 00:12:01,069
stable and in place and I'd like to end

00:11:57,980 --> 00:12:03,829
this talk by citing the creator of

00:12:01,069 --> 00:12:07,670
reason and creator of react

00:12:03,829 --> 00:12:13,509
Jordan walk reason is the best way to

00:12:07,670 --> 00:12:13,509
take react to the next level thank you

00:12:18,060 --> 00:12:23,370
Thank You Davi we have some nice

00:12:20,610 --> 00:12:26,100
questions for you here can you think of

00:12:23,370 --> 00:12:29,460
a reason not to use reason can you think

00:12:26,100 --> 00:12:33,150
about reason not to use reason yeah

00:12:29,460 --> 00:12:36,030
that's really cheeky one yeah so I guess

00:12:33,150 --> 00:12:39,420
still a reason is development it is

00:12:36,030 --> 00:12:41,190
still under development so sometimes you

00:12:39,420 --> 00:12:43,890
just don't want to use reason you just

00:12:41,190 --> 00:12:46,140
don't want to start throwing away your

00:12:43,890 --> 00:12:47,610
app and rebuild it in reason the best

00:12:46,140 --> 00:12:50,940
way how to try it is to do it

00:12:47,610 --> 00:12:52,410
incrementally so I guess you do you

00:12:50,940 --> 00:12:54,060
really don't want to be really hyped

00:12:52,410 --> 00:12:55,350
about that and start everything doing

00:12:54,060 --> 00:12:56,850
reason you need to think about it if

00:12:55,350 --> 00:12:59,490
it's the best thing you really want to

00:12:56,850 --> 00:13:02,190
want to build so it's it's there's no

00:12:59,490 --> 00:13:06,240
answer like yes or no it's always like

00:13:02,190 --> 00:13:08,330
it's up to you right there's reason

00:13:06,240 --> 00:13:12,030
integrate with JavaScript libraries

00:13:08,330 --> 00:13:15,120
reasonably yeah it integrates what do

00:13:12,030 --> 00:13:17,040
you there's a there's a special there's

00:13:15,120 --> 00:13:19,710
you need to write bindings but there are

00:13:17,040 --> 00:13:23,280
many buy bindings already written so you

00:13:19,710 --> 00:13:26,940
can use them as NPM package but if you

00:13:23,280 --> 00:13:28,620
need to use some library some JavaScript

00:13:26,940 --> 00:13:31,020
library without these bindings you need

00:13:28,620 --> 00:13:32,610
to write them yourself and thus like

00:13:31,020 --> 00:13:33,900
thing you need to learn so that's a

00:13:32,610 --> 00:13:35,910
little bit complicated part of the

00:13:33,900 --> 00:13:37,590
reason but the community is growing and

00:13:35,910 --> 00:13:40,560
there are more and more bindings for

00:13:37,590 --> 00:13:42,750
JavaScript libraries so for so you have

00:13:40,560 --> 00:13:45,030
for example bindings for react bindings

00:13:42,750 --> 00:13:48,120
for express and the number of binding

00:13:45,030 --> 00:13:50,210
this is growing so you can you can this

00:13:48,120 --> 00:13:54,080
way how you integrate the libraries

00:13:50,210 --> 00:13:54,080
thank you thank you

00:13:54,920 --> 00:14:01,390
[Music]

00:14:04,980 --> 00:14:08,980
okay so hello everyone my name is kuba

00:14:08,260 --> 00:14:11,890
Mahalo

00:14:08,980 --> 00:14:15,370
I'm from Brno is like the second biggest

00:14:11,890 --> 00:14:19,000
city there in Czech Republic

00:14:15,370 --> 00:14:22,090
I'm CTO in startup code face up in our

00:14:19,000 --> 00:14:26,290
company there is like one programmer

00:14:22,090 --> 00:14:28,840
it's me and to freelance half time

00:14:26,290 --> 00:14:32,400
developer so we are really trying to

00:14:28,840 --> 00:14:36,970
avoid spending our time with unnecessary

00:14:32,400 --> 00:14:39,900
codes okay so everyone loves javascript

00:14:36,970 --> 00:14:43,090
javascript is super awesome and cool and

00:14:39,900 --> 00:14:46,780
this function is really ready readable

00:14:43,090 --> 00:14:49,150
and awesome but if we will call this

00:14:46,780 --> 00:14:52,120
function with bit argument it will turn

00:14:49,150 --> 00:14:55,890
us runtime error as we expected and

00:14:52,120 --> 00:14:59,680
runtime errors you know we don't want it

00:14:55,890 --> 00:15:03,310
okay so how we can fix it we should

00:14:59,680 --> 00:15:05,320
write some tests but my CTO told me that

00:15:03,310 --> 00:15:11,740
it's boring and no one liked writing

00:15:05,320 --> 00:15:14,740
test so thank you so we should try to

00:15:11,740 --> 00:15:17,140
write some static types okay

00:15:14,740 --> 00:15:20,800
second example is kind of similar as the

00:15:17,140 --> 00:15:23,980
first one I have some human type yeah I

00:15:20,800 --> 00:15:27,280
think it's really readable and if I will

00:15:23,980 --> 00:15:30,220
put bit arguments to this function it

00:15:27,280 --> 00:15:32,380
will not fall in a runtime but the app

00:15:30,220 --> 00:15:36,340
will not be compiled so everything is

00:15:32,380 --> 00:15:40,540
awesome but there is one big thing you

00:15:36,340 --> 00:15:42,070
have to define this interface and I I

00:15:40,540 --> 00:15:47,500
don't know what about you but I have no

00:15:42,070 --> 00:15:51,100
time for doing it ok and real example

00:15:47,500 --> 00:15:53,980
this is like standard application with

00:15:51,100 --> 00:15:55,780
Redux and rest api server now try to

00:15:53,980 --> 00:15:59,110
imagine where you have to define

00:15:55,780 --> 00:16:01,450
interface there is so many players every

00:15:59,110 --> 00:16:05,320
action reduced so you know it's wow it's

00:16:01,450 --> 00:16:10,560
really a lot of code ok so relax is not

00:16:05,320 --> 00:16:12,910
the way so how many of you know graph QL

00:16:10,560 --> 00:16:16,150
that's kinda nice yeah

00:16:12,910 --> 00:16:19,690
so graph QL is like REST API on steroids

00:16:16,150 --> 00:16:23,530
it's super cool and awesome you define

00:16:19,690 --> 00:16:25,690
some schema and you ask to that scheme

00:16:23,530 --> 00:16:28,180
others like name is doing you know

00:16:25,690 --> 00:16:33,340
tagline is string it's really it's

00:16:28,180 --> 00:16:35,920
really nice model of your API so now try

00:16:33,340 --> 00:16:37,900
to imagine that your single page

00:16:35,920 --> 00:16:41,790
application will be synced with server

00:16:37,900 --> 00:16:45,490
your state of single page application if

00:16:41,790 --> 00:16:48,250
each of component in your application

00:16:45,490 --> 00:16:51,670
will be single server and each of that

00:16:48,250 --> 00:16:56,550
component will fetch data directly from

00:16:51,670 --> 00:17:00,070
server you can know did that data types

00:16:56,550 --> 00:17:02,080
which will back-end returned because

00:17:00,070 --> 00:17:03,640
there is this graphical schema if we

00:17:02,080 --> 00:17:07,120
will ask graphical hey give me name

00:17:03,640 --> 00:17:11,820
graph QL know did the name is string so

00:17:07,120 --> 00:17:14,680
you can define schema on back-end and

00:17:11,820 --> 00:17:19,180
generate static types from graph QL

00:17:14,680 --> 00:17:23,560
schema may be looks kind of tricky and

00:17:19,180 --> 00:17:24,339
magic but I have also an example so this

00:17:23,560 --> 00:17:29,250
is my code

00:17:24,339 --> 00:17:32,800
it's like average react component and

00:17:29,250 --> 00:17:35,650
I'm like hey this is my graph QL query

00:17:32,800 --> 00:17:40,630
I would like to fetch ID first name and

00:17:35,650 --> 00:17:46,570
for example second name okay now I will

00:17:40,630 --> 00:17:50,770
run my CLI compiler which compiled this

00:17:46,570 --> 00:17:54,220
schema and check if it's valid it

00:17:50,770 --> 00:17:56,110
generates me static types with flow you

00:17:54,220 --> 00:18:01,200
can see that there a second name is

00:17:56,110 --> 00:18:05,530
string and now we can just write hey

00:18:01,200 --> 00:18:13,750
second name second name

00:18:05,530 --> 00:18:18,550
okay and try if it works hmm

00:18:13,750 --> 00:18:21,220
interesting yeah sorry my fault okay

00:18:18,550 --> 00:18:24,760
yeah and you see it works and if I will

00:18:21,220 --> 00:18:28,450
do miss click like give me viewer that's

00:18:24,760 --> 00:18:31,510
a good name eggs and save it flow give

00:18:28,450 --> 00:18:33,370
me an error message that you cannot get

00:18:31,510 --> 00:18:35,350
view over a second name eggs because

00:18:33,370 --> 00:18:37,450
it's you know it's not valid because my

00:18:35,350 --> 00:18:40,510
probe types are here and there is only

00:18:37,450 --> 00:18:46,890
second name and not second night mix so

00:18:40,510 --> 00:18:50,230
I have like 100 percent 100 person

00:18:46,890 --> 00:18:55,500
static type application with 0 lines of

00:18:50,230 --> 00:18:55,500
types and is awesome so yeah this is

00:18:57,150 --> 00:19:06,600
[Applause]

00:19:01,580 --> 00:19:10,740
Thank You yeah goodbye does it work with

00:19:06,600 --> 00:19:15,780
Apollo oh this is a good question no it

00:19:10,740 --> 00:19:17,820
doesn't work but if this is a really

00:19:15,780 --> 00:19:20,910
modern library its from Facebook it's

00:19:17,820 --> 00:19:23,220
really awesome but if you want to start

00:19:20,910 --> 00:19:26,460
programming like this you have to

00:19:23,220 --> 00:19:30,660
prepare that you will spend most nights

00:19:26,460 --> 00:19:33,180
with debugger and google chrome console

00:19:30,660 --> 00:19:35,940
because this library is kinda hard to

00:19:33,180 --> 00:19:38,100
understand so maybe I don't know if

00:19:35,940 --> 00:19:42,720
Apollo is better but no it doesn't work

00:19:38,100 --> 00:19:46,370
with Apollo yet maybe sometimes thank

00:19:42,720 --> 00:19:46,370
you very much then okay

00:19:47,040 --> 00:19:53,510
[Music]

00:19:56,830 --> 00:20:01,399
well good afternoon everybody my name is

00:20:00,350 --> 00:20:04,700
Stephanie knives

00:20:01,399 --> 00:20:06,200
I work exactly at ball comm the largest

00:20:04,700 --> 00:20:08,359
online retailer in the Netherlands

00:20:06,200 --> 00:20:10,369
Belgium and today I'm going to tell you

00:20:08,359 --> 00:20:13,299
all about our framework independent

00:20:10,369 --> 00:20:15,950
components library built with stance ojs

00:20:13,299 --> 00:20:18,379
well above that come our goal is to

00:20:15,950 --> 00:20:20,509
provide the best shopping experience for

00:20:18,379 --> 00:20:23,299
our customers they ever had

00:20:20,509 --> 00:20:25,340
we do this with about 60 development

00:20:23,299 --> 00:20:28,460
teams each with their own way of working

00:20:25,340 --> 00:20:31,639
and each team is free to choose whatever

00:20:28,460 --> 00:20:34,009
tech stake they like so some teams go

00:20:31,639 --> 00:20:36,759
for angular others go for react and

00:20:34,009 --> 00:20:41,659
understand to stick with vanilla Jas

00:20:36,759 --> 00:20:45,320
this freedom of choice really enhances

00:20:41,659 --> 00:20:49,759
productivity creativity and adds to the

00:20:45,320 --> 00:20:53,509
products but the downside is that yeah

00:20:49,759 --> 00:20:55,700
every team has different solutions to

00:20:53,509 --> 00:20:58,820
similar problems which results in

00:20:55,700 --> 00:21:01,070
differences in the Luca fill of supposed

00:20:58,820 --> 00:21:03,919
to be uniform shopping platform that

00:21:01,070 --> 00:21:06,379
ball that come actually is so we have to

00:21:03,919 --> 00:21:10,220
get us B teams on the same page again

00:21:06,379 --> 00:21:12,950
and how do we do that well we ask teams

00:21:10,220 --> 00:21:16,249
what they need to do in order to achieve

00:21:12,950 --> 00:21:18,350
this and this was their conclusion they

00:21:16,249 --> 00:21:22,700
basically need a components library

00:21:18,350 --> 00:21:26,989
that's framework independence contains

00:21:22,700 --> 00:21:30,769
one single source of truth they really

00:21:26,989 --> 00:21:32,450
want to be able to contribute and the

00:21:30,769 --> 00:21:35,679
ones who have flawless integration with

00:21:32,450 --> 00:21:38,690
the current tech specs and want to stop

00:21:35,679 --> 00:21:41,659
reinventing a square wheel over and over

00:21:38,690 --> 00:21:45,080
again so no more different solutions for

00:21:41,659 --> 00:21:48,669
similar problems but they want to keep

00:21:45,080 --> 00:21:51,950
their freedom as well and besides that

00:21:48,669 --> 00:21:54,289
we really want to enable all developers

00:21:51,950 --> 00:21:56,059
of all levels to contribute to the

00:21:54,289 --> 00:22:00,289
components library so we want to make

00:21:56,059 --> 00:22:02,480
that as easy as possible and last but

00:22:00,289 --> 00:22:03,290
not least we want to have it performance

00:22:02,480 --> 00:22:06,320
scalable

00:22:03,290 --> 00:22:09,230
as well so this is quite a long list and

00:22:06,320 --> 00:22:11,690
yeah it was quite a challenge to find a

00:22:09,230 --> 00:22:14,150
solution to all the needs of the

00:22:11,690 --> 00:22:18,170
developers and we thought we found a

00:22:14,150 --> 00:22:21,590
solution with web components and web

00:22:18,170 --> 00:22:23,240
Commandments makes it really flexible we

00:22:21,590 --> 00:22:27,110
don't have to worry about framework

00:22:23,240 --> 00:22:30,380
locking components are reusable and that

00:22:27,110 --> 00:22:32,630
enables us to provide components with a

00:22:30,380 --> 00:22:36,860
generic look at fuel throughout our

00:22:32,630 --> 00:22:38,900
shopping platform but as always there's

00:22:36,860 --> 00:22:42,140
a downside and this time it's the

00:22:38,900 --> 00:22:45,170
learning curve especially for developers

00:22:42,140 --> 00:22:47,240
that aren't add experience yes it's very

00:22:45,170 --> 00:22:50,060
hard to build web components from

00:22:47,240 --> 00:22:53,000
scratch and we really want to enable all

00:22:50,060 --> 00:22:56,450
developers of all levels to contribute

00:22:53,000 --> 00:22:59,270
to this components library so we had to

00:22:56,450 --> 00:23:03,680
go for the extra mile and we found extra

00:22:59,270 --> 00:23:08,030
mile in stencil j/s stencil J's is a web

00:23:03,680 --> 00:23:11,720
components compiler which generates 100%

00:23:08,030 --> 00:23:15,740
web standards mates components it's

00:23:11,720 --> 00:23:20,420
really performance and have a very easy

00:23:15,740 --> 00:23:23,510
API its future ready and we don't have

00:23:20,420 --> 00:23:26,240
to worry about framework lock-in and

00:23:23,510 --> 00:23:29,660
best of all it's compatible with all the

00:23:26,240 --> 00:23:34,220
major frameworks around and even without

00:23:29,660 --> 00:23:37,490
any frameworks so teams are able to to

00:23:34,220 --> 00:23:42,380
implement it in their text tags

00:23:37,490 --> 00:23:46,280
flawlessly so how did we combine the

00:23:42,380 --> 00:23:49,400
power of stencil jas with web components

00:23:46,280 --> 00:23:52,550
into our components library well we did

00:23:49,400 --> 00:23:54,860
it and with this um here we see our

00:23:52,550 --> 00:23:58,070
components library and the base is stand

00:23:54,860 --> 00:24:00,470
suggests and it basically generates web

00:23:58,070 --> 00:24:04,340
components and if a team wants to use

00:24:00,470 --> 00:24:07,640
one of the components it easily goes to

00:24:04,340 --> 00:24:09,370
the components library and gets one via

00:24:07,640 --> 00:24:10,520
our internal repository manager

00:24:09,370 --> 00:24:13,130
artifactory

00:24:10,520 --> 00:24:15,950
and if they want to contribute to a

00:24:13,130 --> 00:24:16,830
component library well they simply do so

00:24:15,950 --> 00:24:20,039
well

00:24:16,830 --> 00:24:24,059
a repository that's available for all

00:24:20,039 --> 00:24:26,070
teams around so that's how we combine

00:24:24,059 --> 00:24:30,210
the power of stencil chess with web

00:24:26,070 --> 00:24:32,850
components at Balcombe so to conclude my

00:24:30,210 --> 00:24:37,140
story everything we do at ball that come

00:24:32,850 --> 00:24:40,440
and is to provide the best shopping

00:24:37,140 --> 00:24:42,510
experience for every user out there we

00:24:40,440 --> 00:24:44,760
do this by providing a community of

00:24:42,510 --> 00:24:46,380
developers with the tools they need to

00:24:44,760 --> 00:24:48,990
get them together get them on the same

00:24:46,380 --> 00:24:52,260
page and enable them to speak the same

00:24:48,990 --> 00:24:54,389
language how by building a framework

00:24:52,260 --> 00:24:57,269
independent components library with

00:24:54,389 --> 00:24:58,679
stencils yes my name is Steve Nunez and

00:24:57,269 --> 00:25:00,950
would like to thank you for your

00:24:58,679 --> 00:25:00,950
attention

00:25:04,370 --> 00:25:08,970
Thank You Stefan

00:25:06,389 --> 00:25:11,730
I think there are some people who want

00:25:08,970 --> 00:25:14,909
to know if there are any downsides of

00:25:11,730 --> 00:25:18,659
stencil J's yes there are some downsides

00:25:14,909 --> 00:25:21,179
because well web components and not all

00:25:18,659 --> 00:25:23,370
browsers are fully supporting them so

00:25:21,179 --> 00:25:26,010
you can see death as a downside of

00:25:23,370 --> 00:25:30,360
stencil yes because stencil yes build

00:25:26,010 --> 00:25:33,299
some web components okay and what about

00:25:30,360 --> 00:25:35,010
any overhead to using web components in

00:25:33,299 --> 00:25:37,740
an application as opposed to classic

00:25:35,010 --> 00:25:39,299
frameworks specific components and

00:25:37,740 --> 00:25:44,460
you're a tree using web console

00:25:39,299 --> 00:25:46,950
application yeah well there's love

00:25:44,460 --> 00:25:49,559
there's a bit more of configuration and

00:25:46,950 --> 00:25:52,740
then episode earlier polyfills as well

00:25:49,559 --> 00:26:01,470
so you can see that as some overhead I

00:25:52,740 --> 00:26:04,260
have okay what about browser support bra

00:26:01,470 --> 00:26:07,830
support yeah as I said earlier stem

00:26:04,260 --> 00:26:11,639
suggest is supported by all browsers say

00:26:07,830 --> 00:26:13,590
it with polyfills I think we can take

00:26:11,639 --> 00:26:16,200
one where's your very efficient why

00:26:13,590 --> 00:26:19,169
stencil over a polymer of a polymer

00:26:16,200 --> 00:26:22,139
that's a very good question we want we

00:26:19,169 --> 00:26:24,539
didn't want to be a framework we didn't

00:26:22,139 --> 00:26:27,659
want to have a framework lock in

00:26:24,539 --> 00:26:30,389
so yeah after some intensive research we

00:26:27,659 --> 00:26:33,629
ended up with stencil yes because it

00:26:30,389 --> 00:26:37,289
suited our requirements better than

00:26:33,629 --> 00:26:40,789
polymer as well thank you Stefan thank

00:26:37,289 --> 00:26:40,789

YouTube URL: https://www.youtube.com/watch?v=dSrKyi43fRI


