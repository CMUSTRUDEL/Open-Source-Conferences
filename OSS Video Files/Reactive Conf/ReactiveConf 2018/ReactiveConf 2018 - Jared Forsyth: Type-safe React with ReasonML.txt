Title: ReactiveConf 2018 - Jared Forsyth: Type-safe React with ReasonML
Publication date: 2018-11-05
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Main stage
-------------------------------------------------------------------
Type-safe React with ReasonML

Types can be invaluable when working on a large project, by making refactoring less error-prone, enabling better coordinating between teammates, and improving readability. Reason gives you a powerful, battle-tested type system with cross-file inference, macros, and excellent JavaScript interop. Come learn what differentiates it from added-on type systems like Flow and TypeScript, what it looks like to build React UIs in Reason, and what makes it easy to start into and integrate with your current JavaScript app.
Captions: 
	00:00:02,270 --> 00:00:08,730
[Music]

00:00:12,280 --> 00:00:18,590
thank you very much so like I said I'm

00:00:15,860 --> 00:00:20,599
Jared Forsyth on Twitter i am at Jared

00:00:18,590 --> 00:00:22,700
Forsyth and if you want to follow along

00:00:20,599 --> 00:00:23,930
with these slides or look back at

00:00:22,700 --> 00:00:28,130
something later the link is at the

00:00:23,930 --> 00:00:30,410
bottom I am also the co-host of Reason

00:00:28,130 --> 00:00:32,509
Town podcast about the reason language

00:00:30,410 --> 00:00:33,559
so if at the end of this you're really

00:00:32,509 --> 00:00:35,630
excited about reason wanna learn more

00:00:33,559 --> 00:00:37,160
check that out we've got a bunch of

00:00:35,630 --> 00:00:42,280
beginner friendly episodes and also some

00:00:37,160 --> 00:00:44,210
more advanced topics so what we're gonna

00:00:42,280 --> 00:00:46,609
what we're going to talk about today is

00:00:44,210 --> 00:00:48,050
first why reason why should you be

00:00:46,609 --> 00:00:50,960
interested reason especially in the

00:00:48,050 --> 00:00:53,120
context of react applications and then

00:00:50,960 --> 00:00:54,710
I'll give you a little bit of view of

00:00:53,120 --> 00:00:56,719
what it looks like what the syntax looks

00:00:54,710 --> 00:00:58,489
like how to use it with react and then

00:00:56,719 --> 00:01:01,159
finally I'll cover how you can get

00:00:58,489 --> 00:01:03,260
started really quick ways for you to dig

00:01:01,159 --> 00:01:07,010
into reasons see what it feels like and

00:01:03,260 --> 00:01:11,680
then learn more but before I start I

00:01:07,010 --> 00:01:13,880
should ask who here likes types okay

00:01:11,680 --> 00:01:15,860
y'all know like web development with

00:01:13,880 --> 00:01:18,350
types is the best thing everybody who

00:01:15,860 --> 00:01:23,000
didn't raise their hands I gave a talk

00:01:18,350 --> 00:01:24,049
last year at react conf that is titled

00:01:23,000 --> 00:01:27,140
type systems will make you a better

00:01:24,049 --> 00:01:29,689
JavaScript developer and there I lay out

00:01:27,140 --> 00:01:30,740
my reasons for why I think I don't I

00:01:29,689 --> 00:01:33,380
don't want to do JavaScript without

00:01:30,740 --> 00:01:34,729
types anymore and if you are convinced

00:01:33,380 --> 00:01:39,950
but your boss isn't or your co-workers

00:01:34,729 --> 00:01:42,289
aren't you can show them this video now

00:01:39,950 --> 00:01:44,270
to define some terms you might be asking

00:01:42,289 --> 00:01:46,909
what what in the world is reason right

00:01:44,270 --> 00:01:49,640
reason is a new syntax and toolchain for

00:01:46,909 --> 00:01:50,869
oh camel which from any of you brings up

00:01:49,640 --> 00:01:53,960
a new question what is Oh camel

00:01:50,869 --> 00:01:56,659
Oh camel is one of those languages that

00:01:53,960 --> 00:01:58,280
you'll you'll find on blog posts that

00:01:56,659 --> 00:01:59,570
are like five languages that will change

00:01:58,280 --> 00:02:02,420
the way you think about programming

00:01:59,570 --> 00:02:04,939
right on there is Haskell and probably a

00:02:02,420 --> 00:02:07,009
list maybe closure and Oh camel comes up

00:02:04,939 --> 00:02:09,170
a lot as well it's one of those kind of

00:02:07,009 --> 00:02:10,880
grandparent languages that a lot of the

00:02:09,170 --> 00:02:13,490
new languages that are coming out are

00:02:10,880 --> 00:02:17,570
inspired by so rust heavily inspired by

00:02:13,490 --> 00:02:18,980
Oh camel Swift as well but it's been

00:02:17,570 --> 00:02:20,989
mostly relegated to

00:02:18,980 --> 00:02:23,269
academia with a couple of key industry

00:02:20,989 --> 00:02:26,510
players but certainly not the kind of

00:02:23,269 --> 00:02:28,330
community development that you'd find in

00:02:26,510 --> 00:02:33,409
something like Python which is also

00:02:28,330 --> 00:02:36,950
decades old and I'm also gonna mention

00:02:33,409 --> 00:02:39,440
buckle script where buckle script is a

00:02:36,950 --> 00:02:42,049
new compiler that will take oak Hamel or

00:02:39,440 --> 00:02:46,370
reason code and turn it into performant

00:02:42,049 --> 00:02:51,410
readable JavaScript and it's also very

00:02:46,370 --> 00:02:54,620
fast as a compiler as well so first why

00:02:51,410 --> 00:02:56,750
reason right and if you were paying

00:02:54,620 --> 00:02:58,280
attention during David cope all's

00:02:56,750 --> 00:03:00,560
lightning talk yesterday you already

00:02:58,280 --> 00:03:04,760
know the answer to this right reason is

00:03:00,560 --> 00:03:06,920
the best way to write react and the

00:03:04,760 --> 00:03:09,319
reasons for this are that react was

00:03:06,920 --> 00:03:11,870
originally developed not in JavaScript

00:03:09,319 --> 00:03:15,049
but in standard ml which is a cousin

00:03:11,870 --> 00:03:16,910
language to Oh camel and so core

00:03:15,049 --> 00:03:21,019
principles of react like immutability

00:03:16,910 --> 00:03:23,630
like defining prop types feel a little

00:03:21,019 --> 00:03:27,760
foreign in JavaScript but or right at

00:03:23,630 --> 00:03:27,760
home in reason and reason react

00:03:28,419 --> 00:03:35,329
another reason a question that people

00:03:32,299 --> 00:03:36,769
ask me is well I've already got types in

00:03:35,329 --> 00:03:40,400
my JavaScript right lots of you raise

00:03:36,769 --> 00:03:43,730
your hands using typescript or flow so

00:03:40,400 --> 00:03:47,720
why why would I care about reason and I

00:03:43,730 --> 00:03:52,130
like to answer this by using using an

00:03:47,720 --> 00:03:55,130
analogy here are two seagoing vessels

00:03:52,130 --> 00:03:58,130
right on the left is USS JavaScript and

00:03:55,130 --> 00:03:59,090
then there's the USS Oh camel and right

00:03:58,130 --> 00:04:02,090
away you can see there are some

00:03:59,090 --> 00:04:03,919
differences right JavaScript looks a lot

00:04:02,090 --> 00:04:06,260
more fun it's got a lot more going on

00:04:03,919 --> 00:04:08,000
right there there's some fresh pie in

00:04:06,260 --> 00:04:09,910
the window if you can see that and a

00:04:08,000 --> 00:04:13,609
ping-pong table fireworks

00:04:09,910 --> 00:04:15,349
whereas okay mo looks quite drab by

00:04:13,609 --> 00:04:18,859
comparison there's not as much going on

00:04:15,349 --> 00:04:21,079
it's gray but you'll notice in this

00:04:18,859 --> 00:04:26,960
picture you can't see the most important

00:04:21,079 --> 00:04:28,610
part of the boat which is the hull and

00:04:26,960 --> 00:04:31,240
now you can see there's important

00:04:28,610 --> 00:04:32,810
differences here as well

00:04:31,240 --> 00:04:35,660
javascript for

00:04:32,810 --> 00:04:39,590
for all of the fun that it is has some

00:04:35,660 --> 00:04:42,830
holes in it um maybe this is you know

00:04:39,590 --> 00:04:45,440
undefined is not a function or you know

00:04:42,830 --> 00:04:47,510
this this was a string you're trying to

00:04:45,440 --> 00:04:52,220
get the name attribute off of it that

00:04:47,510 --> 00:04:55,240
doesn't exist and with especially when

00:04:52,220 --> 00:04:57,470
you're working in a large project or

00:04:55,240 --> 00:04:59,750
you've got lots of developers touching

00:04:57,470 --> 00:05:01,400
the same code these these can come to

00:04:59,750 --> 00:05:02,780
bite you one of the most frustrating

00:05:01,400 --> 00:05:05,720
things that I've found when working in

00:05:02,780 --> 00:05:07,520
large JavaScript projects is I get an

00:05:05,720 --> 00:05:11,300
error that's like you know undefined

00:05:07,520 --> 00:05:12,919
it's not a function and I have no idea

00:05:11,300 --> 00:05:14,180
where it came from right I know what

00:05:12,919 --> 00:05:17,090
what was undefined

00:05:14,180 --> 00:05:19,190
but how did it become undefined and and

00:05:17,090 --> 00:05:20,930
I have to trace it back usually you know

00:05:19,190 --> 00:05:23,000
with breakpoints and console logs all

00:05:20,930 --> 00:05:26,000
over the place to try and figure out and

00:05:23,000 --> 00:05:28,970
often it was many many call stacks away

00:05:26,000 --> 00:05:30,050
where it's like oh I I made a wrong

00:05:28,970 --> 00:05:33,580
assumption about the shape of this

00:05:30,050 --> 00:05:37,669
object or the type of this value um

00:05:33,580 --> 00:05:40,669
whereas Oh camel with built in from the

00:05:37,669 --> 00:05:43,340
ground up type safety just rules that

00:05:40,669 --> 00:05:44,960
out now the fact that javascript has

00:05:43,340 --> 00:05:47,270
holes in it doesn't mean it's gonna sink

00:05:44,960 --> 00:05:53,810
right we're we're shipping JavaScript

00:05:47,270 --> 00:05:56,300
applications they work and so if water

00:05:53,810 --> 00:05:59,180
gets in the boat you just pump it out in

00:05:56,300 --> 00:06:01,729
in this case maybe this is unit tests

00:05:59,180 --> 00:06:03,860
right if we get 100% coverage then we'll

00:06:01,729 --> 00:06:06,800
know that our code doesn't have any bugs

00:06:03,860 --> 00:06:10,789
or at least it doesn't have bugs that we

00:06:06,800 --> 00:06:12,740
wrote tests for and but there are more

00:06:10,789 --> 00:06:16,160
holes than that so maybe you add in

00:06:12,740 --> 00:06:19,430
strict linting you add in you know

00:06:16,160 --> 00:06:21,200
strict code review to try and guard

00:06:19,430 --> 00:06:23,810
yourself from all of the foot guns that

00:06:21,200 --> 00:06:27,260
are honestly included in javascript um

00:06:23,810 --> 00:06:29,600
and once once you add all these things

00:06:27,260 --> 00:06:31,130
on top of it it becomes less fun right

00:06:29,600 --> 00:06:33,280
you can't even see the ping pong table

00:06:31,130 --> 00:06:36,710
anymore

00:06:33,280 --> 00:06:38,240
now flow in typescript take a different

00:06:36,710 --> 00:06:40,280
approach right it's it's not bailing

00:06:38,240 --> 00:06:43,190
water out let's patch up the holes right

00:06:40,280 --> 00:06:45,979
this is fine we will add on a type

00:06:43,190 --> 00:06:46,580
system that knows how to prevent you

00:06:45,979 --> 00:06:49,430
from

00:06:46,580 --> 00:06:53,060
using undefined as a function and things

00:06:49,430 --> 00:06:56,660
like that but it can't cover all the

00:06:53,060 --> 00:06:59,270
holes and they these are evolving

00:06:56,660 --> 00:07:01,280
technologies that you know each month or

00:06:59,270 --> 00:07:02,840
every couple of months they make changes

00:07:01,280 --> 00:07:06,260
to the type system try and make it more

00:07:02,840 --> 00:07:08,240
robust and the other issue is they have

00:07:06,260 --> 00:07:10,310
to work with the existing JavaScript

00:07:08,240 --> 00:07:12,950
right so your your your patching on

00:07:10,310 --> 00:07:17,240
safety on to a fundamentally unsafe

00:07:12,950 --> 00:07:21,740
structure and my thesis is that it's far

00:07:17,240 --> 00:07:25,220
easier to start with a foundation that

00:07:21,740 --> 00:07:27,340
is solid and sound and add on a little

00:07:25,220 --> 00:07:29,900
bit of party add on a little bit of

00:07:27,340 --> 00:07:32,420
ease-of-use community development that

00:07:29,900 --> 00:07:35,870
kind of thing then to try and start from

00:07:32,420 --> 00:07:37,280
an unsafe place and make it safe to

00:07:35,870 --> 00:07:40,100
present this in a little bit more boring

00:07:37,280 --> 00:07:43,370
way here's a chart for you where

00:07:40,100 --> 00:07:46,490
javascript is much more easy to use but

00:07:43,370 --> 00:07:48,770
very low on the safety scale and flow in

00:07:46,490 --> 00:07:52,160
typescript try and bring it more towards

00:07:48,770 --> 00:07:55,340
safety whereas Oh camel starts out much

00:07:52,160 --> 00:07:57,800
safer less easy to use and reason is

00:07:55,340 --> 00:07:59,360
trying to make it more easy to use easy

00:07:57,800 --> 00:08:02,960
to get started easy to integrate with

00:07:59,360 --> 00:08:07,280
JavaScript that kind of thing No

00:08:02,960 --> 00:08:08,630
so kind of TLDR of this is types Griffin

00:08:07,280 --> 00:08:11,900
flow they just don't have the same kind

00:08:08,630 --> 00:08:12,680
of safety guarantees but definitely

00:08:11,900 --> 00:08:16,250
they're better than just using

00:08:12,680 --> 00:08:17,990
JavaScript by itself the other question

00:08:16,250 --> 00:08:20,420
people ask me is well how about Elm

00:08:17,990 --> 00:08:23,990
right why why should I be interested in

00:08:20,420 --> 00:08:28,250
reason and not Elm and if you're already

00:08:23,990 --> 00:08:31,610
using Elm I say power to you like Elm is

00:08:28,250 --> 00:08:34,790
really awesome there has some really

00:08:31,610 --> 00:08:37,120
excellent error messages really

00:08:34,790 --> 00:08:40,040
thoughtful leadership by Evans of plic

00:08:37,120 --> 00:08:41,840
I'm just impressed with with everything

00:08:40,040 --> 00:08:43,850
they do so if you're already using Elm I

00:08:41,840 --> 00:08:46,250
don't want to dissuade you now if you

00:08:43,850 --> 00:08:48,830
are currently using typescript or flow

00:08:46,250 --> 00:08:50,450
or JavaScript and are asking which of

00:08:48,830 --> 00:08:53,110
these two should I pick right what are

00:08:50,450 --> 00:08:56,480
the differences here's here's kind of

00:08:53,110 --> 00:08:58,040
some of the key differences the most

00:08:56,480 --> 00:09:00,410
obvious one when you look at some code

00:08:58,040 --> 00:09:03,379
is the syntax right and some people

00:09:00,410 --> 00:09:05,839
say it doesn't matter but it's I see it

00:09:03,379 --> 00:09:08,660
as one fewer thing for you to try and

00:09:05,839 --> 00:09:11,000
one fewer hurdle if you're trying to get

00:09:08,660 --> 00:09:12,620
started so reason has put a lot of

00:09:11,000 --> 00:09:15,709
effort into being very JavaScript like

00:09:12,620 --> 00:09:18,259
whereas elm is written in Haskell

00:09:15,709 --> 00:09:22,250
inspired by Haskell syntax in many ways

00:09:18,259 --> 00:09:24,709
and then the the other difference is

00:09:22,250 --> 00:09:28,269
mostly boil down to a difference in

00:09:24,709 --> 00:09:34,250
philosophy Elm takes the stance of

00:09:28,269 --> 00:09:36,589
safety and purity overall if if there's

00:09:34,250 --> 00:09:38,000
something where it's like oh it would be

00:09:36,589 --> 00:09:41,420
easier if we did this but a little bit

00:09:38,000 --> 00:09:43,399
less safe alum says no it's not worth it

00:09:41,420 --> 00:09:48,410
and I I know people where where they

00:09:43,399 --> 00:09:51,769
love that that viewpoint reason on the

00:09:48,410 --> 00:09:54,290
other hand says mmm we want more ease of

00:09:51,769 --> 00:09:56,089
use even if it means a little bit less

00:09:54,290 --> 00:09:58,399
safety a good example of this is

00:09:56,089 --> 00:09:59,959
JavaScript Interop right if if you are

00:09:58,399 --> 00:10:01,480
writing an elm app and you have some

00:09:59,959 --> 00:10:05,420
existing JavaScript that you want to use

00:10:01,480 --> 00:10:08,029
there's kind of a lot of a lot of work

00:10:05,420 --> 00:10:09,139
required to get that integrated right

00:10:08,029 --> 00:10:10,880
you have to set up a message passing

00:10:09,139 --> 00:10:14,180
protocol you can't call a javascript

00:10:10,880 --> 00:10:18,769
function synchronous incra nicely and so

00:10:14,180 --> 00:10:22,810
of course you can't use a like a react

00:10:18,769 --> 00:10:25,880
component very easily from your elm UI

00:10:22,810 --> 00:10:28,069
reason on the other hand wants to make

00:10:25,880 --> 00:10:30,529
it as easy as possible for you to take

00:10:28,069 --> 00:10:33,019
your existing JavaScript react app and

00:10:30,529 --> 00:10:35,110
add in reason a little bit at a time get

00:10:33,019 --> 00:10:39,350
a little bit of type safety at a time

00:10:35,110 --> 00:10:42,829
and so if for example the JavaScript

00:10:39,350 --> 00:10:44,269
function is misbehaving that that could

00:10:42,829 --> 00:10:47,209
still crash your app that that could

00:10:44,269 --> 00:10:50,360
cause problems whereas in elm because

00:10:47,209 --> 00:10:52,639
you do the extra legwork to isolate

00:10:50,360 --> 00:10:55,160
things you're more protected from the

00:10:52,639 --> 00:10:58,000
unsafe T of JavaScript another example

00:10:55,160 --> 00:11:02,110
of this is mutation right in in elm

00:10:58,000 --> 00:11:05,959
immutability is the only way in reason

00:11:02,110 --> 00:11:08,360
immutability is the default and but

00:11:05,959 --> 00:11:11,980
there are some algorithms you'll find

00:11:08,360 --> 00:11:14,360
maybe a performance sensitive area where

00:11:11,980 --> 00:11:16,910
really the only way to do a perform

00:11:14,360 --> 00:11:20,450
is to use mutation and you you can reach

00:11:16,910 --> 00:11:23,420
for that so in in elm you might find

00:11:20,450 --> 00:11:25,370
yourself needing to go out to JavaScript

00:11:23,420 --> 00:11:27,170
right right the core algorithm in

00:11:25,370 --> 00:11:29,630
JavaScript and then do message passing

00:11:27,170 --> 00:11:30,680
whereas in reason because it's a little

00:11:29,630 --> 00:11:37,850
bit less safe

00:11:30,680 --> 00:11:39,920
you can stay within reason now I also

00:11:37,850 --> 00:11:41,899
want to say why not reason right I'm not

00:11:39,920 --> 00:11:45,620
some starry-eyed evangelist there are

00:11:41,899 --> 00:11:47,180
definitely reasons not to use reason the

00:11:45,620 --> 00:11:50,269
first one being that the community is

00:11:47,180 --> 00:11:54,050
still small only only started up a

00:11:50,269 --> 00:11:57,290
couple years ago still growing and that

00:11:54,050 --> 00:12:00,890
can be a downside especially if you have

00:11:57,290 --> 00:12:02,510
a large team the second reason is tied

00:12:00,890 --> 00:12:03,769
to it there are fewer tutorials and

00:12:02,510 --> 00:12:06,529
documentation that kind of thing that

00:12:03,769 --> 00:12:09,589
come along with a community and so if

00:12:06,529 --> 00:12:12,019
you have a team of 15 developers where

00:12:09,589 --> 00:12:14,300
you want them all to onboard onto this

00:12:12,019 --> 00:12:18,740
new language this can be a sticking

00:12:14,300 --> 00:12:21,670
point and the third reason is just that

00:12:18,740 --> 00:12:25,130
change is hard right don't underestimate

00:12:21,670 --> 00:12:26,540
the cost of taking a production

00:12:25,130 --> 00:12:28,160
JavaScript app and moving it to a

00:12:26,540 --> 00:12:31,940
different language if it's Elm if its

00:12:28,160 --> 00:12:34,790
reason if its closure whatever it's also

00:12:31,940 --> 00:12:36,529
hard to onboard people if you have a

00:12:34,790 --> 00:12:41,269
large team to to get them all to move

00:12:36,529 --> 00:12:43,339
over but I do think that reason is ready

00:12:41,269 --> 00:12:45,620
for production there are many companies

00:12:43,339 --> 00:12:48,410
using it in production today especially

00:12:45,620 --> 00:12:50,209
if you have a smaller team where

00:12:48,410 --> 00:12:53,390
everyone is excited about functional

00:12:50,209 --> 00:12:56,300
programming and types and is ready to do

00:12:53,390 --> 00:12:58,220
get over the initial hurdle the

00:12:56,300 --> 00:13:02,779
productivity gains after that I think

00:12:58,220 --> 00:13:04,490
are impressive so now what what does it

00:13:02,779 --> 00:13:05,870
look like hopefully you're you're

00:13:04,490 --> 00:13:09,079
interested you're a little excited about

00:13:05,870 --> 00:13:11,449
learning about reason here's the basic

00:13:09,079 --> 00:13:14,660
syntax and like I said it's trying to be

00:13:11,449 --> 00:13:18,110
very much like JavaScript this is a

00:13:14,660 --> 00:13:21,470
function declaration so it looks like an

00:13:18,110 --> 00:13:23,120
arrow function and doing some a little

00:13:21,470 --> 00:13:24,880
math in there the difference you'll

00:13:23,120 --> 00:13:28,579
notice is there's no return statement in

00:13:24,880 --> 00:13:31,339
reason similar to closure

00:13:28,579 --> 00:13:33,829
and rust and some other more functional

00:13:31,339 --> 00:13:36,619
languages just about everything is an

00:13:33,829 --> 00:13:39,170
expression so this this block has a

00:13:36,619 --> 00:13:42,049
return value and it's just the value of

00:13:39,170 --> 00:13:44,449
the last thing in the block this also

00:13:42,049 --> 00:13:46,309
gets used here in a switch block where

00:13:44,449 --> 00:13:49,249
the value of the switch block is just

00:13:46,309 --> 00:13:53,379
the value of whatever case was matched

00:13:49,249 --> 00:13:56,059
and so we can assign that to a variable

00:13:53,379 --> 00:13:57,290
another cool thing that reason has that

00:13:56,059 --> 00:13:59,689
I take advantage of a lot is named

00:13:57,290 --> 00:14:02,059
arguments which if you've used Python or

00:13:59,689 --> 00:14:03,980
Swift you'll be familiar with and named

00:14:02,059 --> 00:14:06,350
arguments can be optional and they can

00:14:03,980 --> 00:14:09,670
have default values which comes in handy

00:14:06,350 --> 00:14:13,160
a lot we also have JSX

00:14:09,670 --> 00:14:15,529
as as a language that wants first-class

00:14:13,160 --> 00:14:19,970
react support of course we need JSX and

00:14:15,529 --> 00:14:21,980
it's very similar to JavaScript it's JSX

00:14:19,970 --> 00:14:26,360
like so here's a here's an event handler

00:14:21,980 --> 00:14:28,819
and creating you know making a custom

00:14:26,360 --> 00:14:30,949
component looks the same here we can

00:14:28,819 --> 00:14:33,169
take advantage of the fact that an if

00:14:30,949 --> 00:14:35,239
block is an expression right it has a

00:14:33,169 --> 00:14:38,239
value and so you don't need to have

00:14:35,239 --> 00:14:40,429
nested turn Ares like like you might in

00:14:38,239 --> 00:14:45,019
Java scripts JSX you can just have an if

00:14:40,429 --> 00:14:48,470
block and it works fine another nice

00:14:45,019 --> 00:14:50,569
feature of reasons JSX is the property

00:14:48,470 --> 00:14:53,869
punning if you have a property that

00:14:50,569 --> 00:14:56,569
doesn't have a value instead of being

00:14:53,869 --> 00:14:59,689
that name equals true it's in this case

00:14:56,569 --> 00:15:00,709
data equals data which comes in handy

00:14:59,689 --> 00:15:02,410
when you're passing a lot of props

00:15:00,709 --> 00:15:06,049
around

00:15:02,410 --> 00:15:07,699
so let's actually look at react and what

00:15:06,049 --> 00:15:10,699
it looks like to to make a react

00:15:07,699 --> 00:15:13,819
component in reason here's the basic

00:15:10,699 --> 00:15:15,319
stateless component and we're

00:15:13,819 --> 00:15:20,989
introducing some new syntax here so a

00:15:15,319 --> 00:15:23,720
module is a just a way to encapsulate

00:15:20,989 --> 00:15:26,059
some functionality kind of like an

00:15:23,720 --> 00:15:28,249
embedded file all files or modules and

00:15:26,059 --> 00:15:31,699
you can have modules in modules and this

00:15:28,249 --> 00:15:35,209
is the way that reasons JSX knows about

00:15:31,699 --> 00:15:38,029
custom components so we we define a

00:15:35,209 --> 00:15:39,780
stateless component and we create a

00:15:38,029 --> 00:15:43,290
render function for it

00:15:39,780 --> 00:15:46,680
and the the props are actually just

00:15:43,290 --> 00:15:51,090
arguments to the make function that we

00:15:46,680 --> 00:15:54,450
can then use in render and we'll see in

00:15:51,090 --> 00:15:58,350
the JSX transform that in in JavaScript

00:15:54,450 --> 00:16:00,360
I if you're familiar with the outputted

00:15:58,350 --> 00:16:02,340
JavaScript it becomes react dot create

00:16:00,360 --> 00:16:05,610
element and then my component and then a

00:16:02,340 --> 00:16:07,650
props object whereas in reason it

00:16:05,610 --> 00:16:10,440
becomes you know reason react out create

00:16:07,650 --> 00:16:12,120
element but then my component make so

00:16:10,440 --> 00:16:14,790
it's it's calling that make function

00:16:12,120 --> 00:16:17,880
that we had before with the props that

00:16:14,790 --> 00:16:19,290
we passed in as arguments so hopefully

00:16:17,880 --> 00:16:21,120
hopefully that makes sense the make

00:16:19,290 --> 00:16:25,020
function gets called and that's how

00:16:21,120 --> 00:16:27,480
that's set up you know getting to local

00:16:25,020 --> 00:16:29,790
state this is one of the places that

00:16:27,480 --> 00:16:33,660
reason react really shines where it is

00:16:29,790 --> 00:16:36,600
innovated on the models that react had

00:16:33,660 --> 00:16:41,280
brought in a little bit of redux but

00:16:36,600 --> 00:16:43,140
still true to the react ideas here we

00:16:41,280 --> 00:16:46,260
have a counter component that I'm

00:16:43,140 --> 00:16:50,910
creating and we need to find an action

00:16:46,260 --> 00:16:53,490
type at the top and we have a reduce

00:16:50,910 --> 00:16:56,810
function that if you've used Redux at

00:16:53,490 --> 00:16:59,040
all taking an action and state and then

00:16:56,810 --> 00:17:02,010
creating a new state from that action

00:16:59,040 --> 00:17:05,310
and updating the state will be very

00:17:02,010 --> 00:17:07,709
familiar to you and then down in the

00:17:05,310 --> 00:17:09,839
render function in an event callback we

00:17:07,709 --> 00:17:13,500
can call self dot send which is the same

00:17:09,839 --> 00:17:16,860
as redux as dispatch and what you get

00:17:13,500 --> 00:17:19,650
here is basically the organizational

00:17:16,860 --> 00:17:22,470
benefits of redux where you have all of

00:17:19,650 --> 00:17:24,390
your state transitions well-defined you

00:17:22,470 --> 00:17:26,760
have all of the actions that might

00:17:24,390 --> 00:17:29,250
happen in the same place but you still

00:17:26,760 --> 00:17:30,870
get component local state one of the

00:17:29,250 --> 00:17:32,570
difficulties when when using redux

00:17:30,870 --> 00:17:36,750
especially in a large application is

00:17:32,570 --> 00:17:38,370
that components are now dependent on the

00:17:36,750 --> 00:17:40,050
global state you can't compose them as

00:17:38,370 --> 00:17:41,880
well you can't reuse them as well

00:17:40,050 --> 00:17:43,860
because of the global nature of redux

00:17:41,880 --> 00:17:46,830
with this you get the best of both

00:17:43,860 --> 00:17:50,910
worlds and of course the the hooks

00:17:46,830 --> 00:17:53,490
announcement last weekend uses has a use

00:17:50,910 --> 00:17:56,160
reducer that is inspired by reason

00:17:53,490 --> 00:17:59,400
react so there they're getting jealous

00:17:56,160 --> 00:18:03,000
and brings some of that em so of course

00:17:59,400 --> 00:18:06,540
I had to do a hoax demo right this is

00:18:03,000 --> 00:18:10,650
from the announcement blog post that is

00:18:06,540 --> 00:18:12,840
using the used state hook and if if

00:18:10,650 --> 00:18:16,590
hooks get accepted right it's still an

00:18:12,840 --> 00:18:19,679
RFC then it will make reason react a lot

00:18:16,590 --> 00:18:22,830
more similar right because it's just

00:18:19,679 --> 00:18:25,080
embracing functional ideas the reason

00:18:22,830 --> 00:18:27,420
looks almost exactly the same because

00:18:25,080 --> 00:18:29,850
you you can call the the hooks you state

00:18:27,420 --> 00:18:34,110
you can get the the current state and

00:18:29,850 --> 00:18:35,880
the the setter function and it will

00:18:34,110 --> 00:18:38,040
actually make the differences between

00:18:35,880 --> 00:18:42,900
using react and JavaScript and react and

00:18:38,040 --> 00:18:47,610
reason much much fewer so how do you get

00:18:42,900 --> 00:18:49,190
started there in in the past couple of

00:18:47,610 --> 00:18:52,590
months there have been a couple of

00:18:49,190 --> 00:18:56,370
really neat innovations in online

00:18:52,590 --> 00:18:57,720
services to help you try out reason one

00:18:56,370 --> 00:19:00,570
of our community members created sketch

00:18:57,720 --> 00:19:02,370
SH which you can look up and if you're

00:19:00,570 --> 00:19:04,200
familiar with ipython notebooks or

00:19:02,370 --> 00:19:07,170
Jupiter notebooks it's very much in the

00:19:04,200 --> 00:19:10,530
same line you can have markdown nodes

00:19:07,170 --> 00:19:12,750
and you can have code that gets

00:19:10,530 --> 00:19:15,840
evaluated in line it's a it's a repple

00:19:12,750 --> 00:19:18,750
essentially and speaking of rebels

00:19:15,840 --> 00:19:21,450
repple dot it is an excellent service

00:19:18,750 --> 00:19:24,330
that has a staggering number of

00:19:21,450 --> 00:19:26,010
programming languages supported and they

00:19:24,330 --> 00:19:28,050
just recently added support for reason

00:19:26,010 --> 00:19:30,480
react so you can you can get up and

00:19:28,050 --> 00:19:32,790
running there as well and code sound

00:19:30,480 --> 00:19:35,160
sandbox also recently added support for

00:19:32,790 --> 00:19:37,890
a reason react so if whichever you used

00:19:35,160 --> 00:19:41,280
to using you can keep using that and try

00:19:37,890 --> 00:19:42,690
out reason but what if you want reason

00:19:41,280 --> 00:19:46,429
on your own computer right you want to

00:19:42,690 --> 00:19:51,000
actually dig in create react app has a

00:19:46,429 --> 00:19:54,800
reason preset that you can use and it

00:19:51,000 --> 00:19:54,800
will it will create a project for you

00:19:56,630 --> 00:20:01,140
another thing that we put a lot of

00:19:58,350 --> 00:20:03,990
emphasis on like I said before is using

00:20:01,140 --> 00:20:06,450
reason integrating it into an existing

00:20:03,990 --> 00:20:07,350
JavaScript app alright so I'm gonna go

00:20:06,450 --> 00:20:10,289
through a little bit what

00:20:07,350 --> 00:20:12,240
looks like to get that done first you

00:20:10,289 --> 00:20:14,309
need to add BS platformer that stands

00:20:12,240 --> 00:20:18,179
for buckle script platform if you're

00:20:14,309 --> 00:20:20,640
wondering and there's a config file that

00:20:18,179 --> 00:20:22,230
tells it kind of how you want to compile

00:20:20,640 --> 00:20:24,390
the reason into JavaScript and where you

00:20:22,230 --> 00:20:28,350
want to put it and once you run these

00:20:24,390 --> 00:20:30,270
commands it will for every dot re file

00:20:28,350 --> 00:20:35,270
in your source directory it will create

00:20:30,270 --> 00:20:38,220
a dot J's file right next to it so in

00:20:35,270 --> 00:20:39,780
your say we've got this recent component

00:20:38,220 --> 00:20:42,179
that we're building and we want to use

00:20:39,780 --> 00:20:45,210
it from JavaScript right so at the top

00:20:42,179 --> 00:20:48,210
we've got our our module that has a make

00:20:45,210 --> 00:20:52,250
function in it like I I demoed earlier

00:20:48,210 --> 00:20:55,289
and then we need to do a little bit of

00:20:52,250 --> 00:20:58,020
wrapping to show okay this is how you

00:20:55,289 --> 00:21:00,230
use JavaScript props translate between

00:20:58,020 --> 00:21:02,760
the two languages just a little bit

00:21:00,230 --> 00:21:05,220
because JavaScript props are an object

00:21:02,760 --> 00:21:06,840
and you need to pull out in this case

00:21:05,220 --> 00:21:09,169
the name and the age and then pass them

00:21:06,840 --> 00:21:11,159
to the make function as arguments and

00:21:09,169 --> 00:21:11,610
then from JavaScript it couldn't be

00:21:11,159 --> 00:21:13,140
easier

00:21:11,610 --> 00:21:16,799
right it's it's literally just grabbing

00:21:13,140 --> 00:21:18,000
my component from the the javascript

00:21:16,799 --> 00:21:21,409
file that was generated in the same

00:21:18,000 --> 00:21:23,730
directory and using it as normal and

00:21:21,409 --> 00:21:26,490
then the other way around is even

00:21:23,730 --> 00:21:29,580
simpler so first we declare that there's

00:21:26,490 --> 00:21:31,380
an external you know not in reason value

00:21:29,580 --> 00:21:34,799
that we want to use it's in this some

00:21:31,380 --> 00:21:38,700
component Jas and it's of type reason we

00:21:34,799 --> 00:21:42,179
act out react class and we create a make

00:21:38,700 --> 00:21:44,400
a make function that takes in the props

00:21:42,179 --> 00:21:47,130
as arguments again and then creates a

00:21:44,400 --> 00:21:53,480
javascript object to pass in to the

00:21:47,130 --> 00:21:58,260
underlying javascript react component so

00:21:53,480 --> 00:22:00,650
what's next and actually I've got a

00:21:58,260 --> 00:22:05,520
little bit extra time so I've got some

00:22:00,650 --> 00:22:07,020
I've got some extra content here you

00:22:05,520 --> 00:22:10,049
might be wondering you know if I've got

00:22:07,020 --> 00:22:11,850
if I'm using flow and typescript already

00:22:10,049 --> 00:22:14,580
in my JavaScript and then I add in

00:22:11,850 --> 00:22:18,299
reason I want to make sure I'm not

00:22:14,580 --> 00:22:20,650
losing type safety by adding in you know

00:22:18,299 --> 00:22:24,940
this new type safe language right

00:22:20,650 --> 00:22:27,340
for example from the from the using a

00:22:24,940 --> 00:22:33,090
reason component in JavaScript what if I

00:22:27,340 --> 00:22:35,590
had what if I misspelled a property name

00:22:33,090 --> 00:22:37,660
currently this wouldn't be caught

00:22:35,590 --> 00:22:38,860
because the the JavaScript object that

00:22:37,660 --> 00:22:42,430
reason sees it doesn't know what the

00:22:38,860 --> 00:22:45,550
type is right and then on the other side

00:22:42,430 --> 00:22:47,080
in your typescript file it doesn't know

00:22:45,550 --> 00:22:49,450
what the type of the reason component is

00:22:47,080 --> 00:22:57,429
it can't check for you it's essentially

00:22:49,450 --> 00:23:01,360
opaque to it so there's a and going the

00:22:57,429 --> 00:23:05,620
other direction also is has potential

00:23:01,360 --> 00:23:07,900
errors in it right if you have in your

00:23:05,620 --> 00:23:10,600
reason wrapper file you're not using the

00:23:07,900 --> 00:23:13,240
right types that typescript expects in

00:23:10,600 --> 00:23:15,790
its component and there's a project that

00:23:13,240 --> 00:23:17,820
was released recently it's still in

00:23:15,790 --> 00:23:21,760
development but it's called Jen type and

00:23:17,820 --> 00:23:24,790
it will basically allow you to take a

00:23:21,760 --> 00:23:28,600
for example a reason react component you

00:23:24,790 --> 00:23:31,570
add this decorator to it and then it

00:23:28,600 --> 00:23:35,550
will create a typescript file for you

00:23:31,570 --> 00:23:37,420
that has the prop types there correctly

00:23:35,550 --> 00:23:39,910
such that when you use it from

00:23:37,420 --> 00:23:42,160
typescript it will get everything right

00:23:39,910 --> 00:23:46,120
and there it also does the wrapping for

00:23:42,160 --> 00:23:49,020
you so that you aren't using the

00:23:46,120 --> 00:23:51,820
JavaScript object incorrectly by mistake

00:23:49,020 --> 00:23:55,090
so this this props declaration is

00:23:51,820 --> 00:23:57,790
auto-generated and this might make call

00:23:55,090 --> 00:23:58,450
is also auto-generated and it goes the

00:23:57,790 --> 00:24:00,970
other way as well

00:23:58,450 --> 00:24:05,740
right so you can you can do it a Jen

00:24:00,970 --> 00:24:08,350
type on your import when you're using

00:24:05,740 --> 00:24:11,860
for example a typescript react component

00:24:08,350 --> 00:24:13,990
from your reason and it will it will

00:24:11,860 --> 00:24:20,620
generate the interface for you to make

00:24:13,990 --> 00:24:24,429
sure that all the types line up a couple

00:24:20,620 --> 00:24:29,290
more things that I like about using

00:24:24,429 --> 00:24:34,049
react in reason here's the the render

00:24:29,290 --> 00:24:36,869
prop pattern where

00:24:34,049 --> 00:24:38,519
you know is been been popular for six

00:24:36,869 --> 00:24:42,059
months at least so maybe they've heard

00:24:38,519 --> 00:24:45,599
of it and this is where you want to do a

00:24:42,059 --> 00:24:48,389
higher door component but it's just a

00:24:45,599 --> 00:24:50,969
different way of doing it and the way to

00:24:48,389 --> 00:24:53,339
do it is to have again a render prop and

00:24:50,969 --> 00:24:56,249
you call the render prop with for

00:24:53,339 --> 00:24:58,320
example the data that you've got and it

00:24:56,249 --> 00:25:01,440
looks basically the same as in

00:24:58,320 --> 00:25:05,579
JavaScript there's also the the proxy

00:25:01,440 --> 00:25:07,559
component pattern wherein in JavaScript

00:25:05,579 --> 00:25:11,219
if you've got some component that you

00:25:07,559 --> 00:25:12,599
want to pre-fill a prop for say this

00:25:11,219 --> 00:25:15,869
some other component it takes a lot of

00:25:12,599 --> 00:25:18,479
props and you just want to pre fill some

00:25:15,869 --> 00:25:20,519
prop and then have a component where you

00:25:18,479 --> 00:25:26,579
don't need to pass that in right this

00:25:20,519 --> 00:25:29,299
this happens sometimes and in in reason

00:25:26,579 --> 00:25:32,489
we get to take advantage of currying

00:25:29,299 --> 00:25:36,509
where every argument to a function can

00:25:32,489 --> 00:25:38,129
be provided separately here's a basic

00:25:36,509 --> 00:25:40,320
example of currying with simple math

00:25:38,129 --> 00:25:43,529
functions where we have add two numbers

00:25:40,320 --> 00:25:45,629
and it takes two arguments we can pass

00:25:43,529 --> 00:25:46,859
the first one and then it will return a

00:25:45,629 --> 00:25:49,559
function that's waiting for the second

00:25:46,859 --> 00:25:52,649
one and this all makes sense once we get

00:25:49,559 --> 00:25:54,899
to the way that reason does make

00:25:52,649 --> 00:25:56,429
functions right where it is it's just a

00:25:54,899 --> 00:25:58,589
function waiting for some arguments so

00:25:56,429 --> 00:26:00,179
we can pre-fill one of the arguments to

00:25:58,589 --> 00:26:02,149
the make function and return a new

00:26:00,179 --> 00:26:07,940
component that is essentially waiting

00:26:02,149 --> 00:26:09,779
for all of the rest of the problems and

00:26:07,940 --> 00:26:14,599
one of the things that I'm most excited

00:26:09,779 --> 00:26:18,419
about in reason is the ability to

00:26:14,599 --> 00:26:20,909
compile to multiple platforms right Oh

00:26:18,419 --> 00:26:23,489
camel initially wasn't meant for the web

00:26:20,909 --> 00:26:27,179
at all right it it compiles to native or

00:26:23,489 --> 00:26:30,029
to bytecode and so the o camel community

00:26:27,179 --> 00:26:32,539
has created cross compilers that will

00:26:30,029 --> 00:26:35,849
take in reason or Oh camel code and

00:26:32,539 --> 00:26:37,950
output native iOS binary or native

00:26:35,849 --> 00:26:40,399
Android binary that you can then use

00:26:37,950 --> 00:26:43,049
from objective-c or Swift or Java in

00:26:40,399 --> 00:26:46,649
addition to being able to compile your

00:26:43,049 --> 00:26:47,370
reason code to JavaScript and I did a

00:26:46,649 --> 00:26:50,610
little proof

00:26:47,370 --> 00:26:53,900
cept of this earlier at the beginning of

00:26:50,610 --> 00:26:57,480
the year I made a game for phones and

00:26:53,900 --> 00:27:00,660
it's the same codebase shipped on the

00:26:57,480 --> 00:27:04,410
web and on the App Store and on the

00:27:00,660 --> 00:27:08,430
Google Play Store just to try it out and

00:27:04,410 --> 00:27:10,110
it all worked 100% code reuse but the

00:27:08,430 --> 00:27:11,400
next the next frontier the thing that

00:27:10,110 --> 00:27:14,790
I'm really excited about especially with

00:27:11,400 --> 00:27:18,210
react is having a react native that's

00:27:14,790 --> 00:27:19,500
really native right not just a you know

00:27:18,210 --> 00:27:22,020
we're using react but it's in a

00:27:19,500 --> 00:27:24,840
JavaScript VM and so it's slow sometimes

00:27:22,020 --> 00:27:28,230
and you've got to talk across the bridge

00:27:24,840 --> 00:27:30,809
which can get blocked if we were able to

00:27:28,230 --> 00:27:32,640
have you know the same reason react code

00:27:30,809 --> 00:27:35,490
that you're writing but compiled to

00:27:32,640 --> 00:27:40,040
actually native it unlocks a world of

00:27:35,490 --> 00:27:40,040
possibilities thank you very much

00:27:43,320 --> 00:27:45,380

YouTube URL: https://www.youtube.com/watch?v=RV997YRIMZs


