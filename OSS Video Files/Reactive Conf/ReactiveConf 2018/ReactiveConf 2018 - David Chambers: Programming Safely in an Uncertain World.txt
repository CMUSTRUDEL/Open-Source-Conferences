Title: ReactiveConf 2018 - David Chambers: Programming Safely in an Uncertain World
Publication date: 2018-11-05
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Main stage
-------------------------------------------------------------------
Programming Safely in an Uncertain World

The world is an uncertain place. If we write programs that interact with the outside world—sometimes known as useful programs—we must acknowledge the possibility of failure. Every time we request a resource over the network, parse user input, or consume the output of another program, it's possible that the operation will not succeed. Imperative languages give us a few options in such cases: raising an exception, returning an error code, or succeeding with a bogus value such as NaN.
Algebraic data types such as Maybe, Either, and Future allow us to deal with uncertainty in a principled, unified manner: no more conditional logic; no more exceptions. Instead, we get simple building blocks that snap together. In conjunction with map and flat-map, algebraic data types allow us to collapse multiple sources of uncertainty into a single success or failure value. The decision about what to do in the case of an error is left to the caller, allowing the same error to be handled differently in different contexts.
JavaScript is not typically considered a functional language, but it is possible to define and use algebraic data types in JavaScript. This presentation will introduce the Maybe type in a JavaScript setting, and show how it can be used to write code that is dramatically simpler than the equivalent imperative code. The concepts learned during the presentation will be directly applicable to true functional languages such as Haskell.
Captions: 
	00:00:02,140 --> 00:00:08,610
[Music]

00:00:12,369 --> 00:00:17,510
okay so I gave this talk earlier this

00:00:15,500 --> 00:00:19,610
year and it was a two hour workshop so I

00:00:17,510 --> 00:00:22,280
need to put my head down and go at about

00:00:19,610 --> 00:00:24,350
four times the usual pace but we'll get

00:00:22,280 --> 00:00:26,180
through it together okay so this talk is

00:00:24,350 --> 00:00:28,850
about programming safely in an uncertain

00:00:26,180 --> 00:00:32,509
world which is the world in which we all

00:00:28,850 --> 00:00:35,629
program so we're going to start by

00:00:32,509 --> 00:00:42,170
launching the ripple and bringing in a

00:00:35,629 --> 00:00:45,859
couple of dependencies sanctuary and

00:00:42,170 --> 00:00:50,449
sanctuary def and we'll be using these a

00:00:45,859 --> 00:00:53,510
lot so I'm going to unpack nothing and

00:00:50,449 --> 00:00:55,670
just okay that's what we need for now

00:00:53,510 --> 00:00:59,809
let's have a look at a function so s dot

00:00:55,670 --> 00:01:01,429
words if you just type in any function

00:00:59,809 --> 00:01:03,409
name into the ripple you'll get back the

00:01:01,429 --> 00:01:06,200
type signature so we can see that words

00:01:03,409 --> 00:01:08,870
takes a string and returns an array of

00:01:06,200 --> 00:01:13,910
strings so let's check that it really

00:01:08,870 --> 00:01:17,480
does do that great so we've we've used a

00:01:13,910 --> 00:01:18,830
function yes no surprises so far okay

00:01:17,480 --> 00:01:21,590
this is very quick but this is an

00:01:18,830 --> 00:01:23,180
algebraic data type this is a definition

00:01:21,590 --> 00:01:26,450
that you would see in Haskell we're

00:01:23,180 --> 00:01:29,300
defining the bull' data type and it has

00:01:26,450 --> 00:01:31,280
two data constructors false and true and

00:01:29,300 --> 00:01:33,320
so we can see that false is a member of

00:01:31,280 --> 00:01:35,900
the bull-type true is also a member of

00:01:33,320 --> 00:01:37,310
the bull type so that's one that you're

00:01:35,900 --> 00:01:38,930
familiar with this is one you might not

00:01:37,310 --> 00:01:44,420
be familiar with this is the definition

00:01:38,930 --> 00:01:47,060
of the Navy type and so we say that to

00:01:44,420 --> 00:01:49,490
create a value of type maybe a we either

00:01:47,060 --> 00:01:51,650
use the nothing data constructor or we

00:01:49,490 --> 00:01:54,440
use the just data constructor and you'll

00:01:51,650 --> 00:01:56,180
note that the just data constructor is

00:01:54,440 --> 00:01:59,720
parameterised we need to provide a value

00:01:56,180 --> 00:02:02,090
of type a so nothing that's a value of

00:01:59,720 --> 00:02:05,030
type maybe a just zero that's a value of

00:02:02,090 --> 00:02:06,770
type maybe number okay let's have a look

00:02:05,030 --> 00:02:10,930
at our function that uses that type

00:02:06,770 --> 00:02:14,540
so sanctuary has a positon here we have

00:02:10,930 --> 00:02:16,460
hasn't is a function that actually takes

00:02:14,540 --> 00:02:17,810
two arguments but one at a time so this

00:02:16,460 --> 00:02:19,310
is a curried function

00:02:17,810 --> 00:02:23,420
all functions and sanctuary are curried

00:02:19,310 --> 00:02:27,080
functions let's actually use pars int to

00:02:23,420 --> 00:02:29,420
pass a base 16 string so let's try one

00:02:27,080 --> 00:02:31,400
that is valid and we get back the result

00:02:29,420 --> 00:02:33,650
and it's inside adjust and the just

00:02:31,400 --> 00:02:36,349
tells us that that computation was

00:02:33,650 --> 00:02:39,019
successful if we try something that

00:02:36,349 --> 00:02:40,430
isn't a valid basic steen string we get

00:02:39,019 --> 00:02:43,610
back nothing that tells us that the

00:02:40,430 --> 00:02:46,280
computation failed for comparison let's

00:02:43,610 --> 00:02:49,489
try the built-in JavaScript function

00:02:46,280 --> 00:02:55,489
with those same two inputs so hasn't

00:02:49,489 --> 00:02:58,880
with the ffff succeeds we try a an

00:02:55,489 --> 00:03:00,709
invalid input we get back nan so similar

00:02:58,880 --> 00:03:04,580
but you can see that because we don't

00:03:00,709 --> 00:03:06,620
have the the extra context we're not

00:03:04,580 --> 00:03:08,390
able to describe success or failure

00:03:06,620 --> 00:03:12,230
we're forced to resort to this bogus

00:03:08,390 --> 00:03:14,540
value so the maybe type saves us from

00:03:12,230 --> 00:03:17,180
throwing exceptions and it saves us from

00:03:14,540 --> 00:03:20,540
using these bogus values that we should

00:03:17,180 --> 00:03:22,340
avoid the maybe type answers this rather

00:03:20,540 --> 00:03:23,989
philosophical and pointless question

00:03:22,340 --> 00:03:27,769
what is the first element of an empty

00:03:23,989 --> 00:03:31,370
array the answer is obvious once we look

00:03:27,769 --> 00:03:32,959
at the type signature hid takes an array

00:03:31,370 --> 00:03:35,450
of elements of type a and returns are

00:03:32,959 --> 00:03:37,880
maybe a this is obvious when we consider

00:03:35,450 --> 00:03:41,540
that in this case we're not providing a

00:03:37,880 --> 00:03:43,959
single a so we have to return nothing if

00:03:41,540 --> 00:03:46,910
we pass in fubar bears

00:03:43,959 --> 00:03:51,560
we'll get just foo it makes sense

00:03:46,910 --> 00:03:53,720
no more undefined no exceptions how do

00:03:51,560 --> 00:03:55,579
we operate on a value inside a maybe it

00:03:53,720 --> 00:03:57,650
seems difficult because we've put it in

00:03:55,579 --> 00:04:00,019
this this context it's actually really

00:03:57,650 --> 00:04:03,470
simple because we do this all the time

00:04:00,019 --> 00:04:06,560
with arrays so we're familiar with

00:04:03,470 --> 00:04:09,530
mapping over arrays so we can let's

00:04:06,560 --> 00:04:12,470
subtract one from each of these values

00:04:09,530 --> 00:04:14,870
and we get back 0 1 2 just as we would

00:04:12,470 --> 00:04:18,320
expect all we need to do is change the

00:04:14,870 --> 00:04:23,300
input let's try mapping over just 100

00:04:18,320 --> 00:04:26,599
and we get back just 99 no surprises at

00:04:23,300 --> 00:04:30,229
all and we can map over nothing and we

00:04:26,599 --> 00:04:31,760
get back nothing so far so good and one

00:04:30,229 --> 00:04:33,890
way to get an intuition for this

00:04:31,760 --> 00:04:37,430
is that nothing is equivalent to empty

00:04:33,890 --> 00:04:39,440
array if you squint and just a hundred

00:04:37,430 --> 00:04:41,810
is equivalent to a singleton array that

00:04:39,440 --> 00:04:43,550
just has the value 100 and side we could

00:04:41,810 --> 00:04:46,250
do those same mapping operations and we

00:04:43,550 --> 00:04:51,350
would get back either empty array or a

00:04:46,250 --> 00:04:53,270
singleton array containing 99 so yes map

00:04:51,350 --> 00:04:56,600
is very general we can even map over

00:04:53,270 --> 00:05:00,590
string maps this would give us back X 0

00:04:56,600 --> 00:05:03,560
Y 1 z 2 just as you would expect so

00:05:00,590 --> 00:05:07,190
let's have a look at the type of map ok

00:05:03,560 --> 00:05:11,150
we're not going to do delve into the the

00:05:07,190 --> 00:05:12,320
meaning of this functor but just look at

00:05:11,150 --> 00:05:14,270
this and you'll see that it's a very

00:05:12,320 --> 00:05:17,960
general type signature we're not hard

00:05:14,270 --> 00:05:22,760
coding a single type anywhere so what I

00:05:17,960 --> 00:05:25,640
find helpful is to actually specialize

00:05:22,760 --> 00:05:27,470
these general types so that we can get

00:05:25,640 --> 00:05:29,720
our head around what this is actually

00:05:27,470 --> 00:05:33,260
going to do it do for us in practice so

00:05:29,720 --> 00:05:37,630
let's replace all the A's with string

00:05:33,260 --> 00:05:42,700
let's say let's replace all the B's with

00:05:37,630 --> 00:05:45,320
integer and let's replace all of the ifs

00:05:42,700 --> 00:05:49,640
with array and let's see what that gives

00:05:45,320 --> 00:05:51,500
us so this tells us that if we want to

00:05:49,640 --> 00:05:53,600
use map in this way

00:05:51,500 --> 00:05:55,370
it can be a function that takes a

00:05:53,600 --> 00:05:57,830
function from string to integer so that

00:05:55,370 --> 00:05:59,510
might be the string length function it

00:05:57,830 --> 00:06:01,010
takes an array of strings and it gives

00:05:59,510 --> 00:06:03,710
us back an array of integers that's

00:06:01,010 --> 00:06:08,000
great but what's so wonderful about this

00:06:03,710 --> 00:06:10,760
parametric sea is that we can substitute

00:06:08,000 --> 00:06:14,180
something different in the place of F

00:06:10,760 --> 00:06:16,790
and look that same map function is doing

00:06:14,180 --> 00:06:19,220
something very different its operating

00:06:16,790 --> 00:06:21,800
within the context of a maybe so that's

00:06:19,220 --> 00:06:24,740
why we're able to use this function in

00:06:21,800 --> 00:06:26,980
these different contexts function

00:06:24,740 --> 00:06:29,810
composition limits complexity it is the

00:06:26,980 --> 00:06:32,450
method of limiting complexity in our

00:06:29,810 --> 00:06:35,300
programs it's also central to the

00:06:32,450 --> 00:06:39,080
sanctuary experience just for a you know

00:06:35,300 --> 00:06:41,300
joy of programming reason so the way

00:06:39,080 --> 00:06:45,030
that we compose is usually using the

00:06:41,300 --> 00:06:49,680
pipe function so what pipe lets us do

00:06:45,030 --> 00:06:54,180
is provide a foldable of functions such

00:06:49,680 --> 00:06:57,120
as an array of functions and thread a

00:06:54,180 --> 00:07:01,200
value through all of those computations

00:06:57,120 --> 00:07:03,750
so let's try this and we gave it no

00:07:01,200 --> 00:07:06,540
functions to compose so obviously it

00:07:03,750 --> 00:07:07,590
just gave us back the input but let's

00:07:06,540 --> 00:07:10,920
try doing something more interesting

00:07:07,590 --> 00:07:13,410
let's start by getting the words okay

00:07:10,920 --> 00:07:15,960
now we have these three words but let's

00:07:13,410 --> 00:07:18,240
add another step to the to the pipeline

00:07:15,960 --> 00:07:21,000
let's now map over those words and for

00:07:18,240 --> 00:07:26,610
each word let's access the length

00:07:21,000 --> 00:07:28,890
property so now we have the lengths of

00:07:26,610 --> 00:07:31,710
the words of the input string let's

00:07:28,890 --> 00:07:32,760
let's go a bit further and you can see

00:07:31,710 --> 00:07:34,190
that there's the style of programming

00:07:32,760 --> 00:07:37,500
particularly when you're writing in a

00:07:34,190 --> 00:07:39,990
text file rather than in a tape in a

00:07:37,500 --> 00:07:43,620
repple is very fun because it's just

00:07:39,990 --> 00:07:45,660
adding one computation and getting

00:07:43,620 --> 00:07:49,230
immediate feedback so this time let's

00:07:45,660 --> 00:07:54,300
also map and get the square root of each

00:07:49,230 --> 00:07:57,750
of those okay and as a final step let's

00:07:54,300 --> 00:07:59,900
get the let's get the sum of all of

00:07:57,750 --> 00:07:59,900
those

00:08:05,930 --> 00:08:12,919
okay so that's how we compose functions

00:08:09,490 --> 00:08:14,570
using sanctuaries pipe function you can

00:08:12,919 --> 00:08:16,729
see the type changing here we have a to

00:08:14,570 --> 00:08:19,820
a now we have string to array of string

00:08:16,729 --> 00:08:22,580
the type is changing as we compose more

00:08:19,820 --> 00:08:24,590
functions now we have a challenge let's

00:08:22,580 --> 00:08:26,509
create a two-dimensional array of all

00:08:24,590 --> 00:08:31,130
the words and all the lines of a string

00:08:26,509 --> 00:08:36,650
so let's make a string let's go with 1a

00:08:31,130 --> 00:08:43,690
1b 1c new line and then let's just go to

00:08:36,650 --> 00:08:47,630
A to B to C and let's go with just 3a 3b

00:08:43,690 --> 00:08:50,209
something like that okay so we can use

00:08:47,630 --> 00:08:53,260
sanctuaries lines function works very

00:08:50,209 --> 00:08:57,410
similarly to words but it operates on

00:08:53,260 --> 00:08:59,779
lines of text okay so we have now an

00:08:57,410 --> 00:09:02,779
array of lines we want to operate on

00:08:59,779 --> 00:09:06,500
each line so let's map and get the words

00:09:02,779 --> 00:09:08,810
of each line okay so we now have this

00:09:06,500 --> 00:09:14,060
two dimensional array we've solved our

00:09:08,810 --> 00:09:16,130
challenge so a question how would we go

00:09:14,060 --> 00:09:18,970
about creating a one dimensional array

00:09:16,130 --> 00:09:21,050
rather than a two dimensional array

00:09:18,970 --> 00:09:24,080
let's have a look at this join function

00:09:21,050 --> 00:09:27,170
this is nothing to do with array join

00:09:24,080 --> 00:09:28,790
it's a very different thing and we can

00:09:27,170 --> 00:09:31,570
tell when we look at the type signature

00:09:28,790 --> 00:09:36,160
let's not worry about what a chain is

00:09:31,570 --> 00:09:42,740
but again let's try specializing this

00:09:36,160 --> 00:09:45,290
type let's replace all M's with array so

00:09:42,740 --> 00:09:48,800
you can see that we have a function that

00:09:45,290 --> 00:09:52,010
gives us a way of taking a nested array

00:09:48,800 --> 00:09:53,660
and removing one level of nesting this

00:09:52,010 --> 00:09:56,200
is not flattening this just removes one

00:09:53,660 --> 00:09:59,209
level of nesting similarly let's try

00:09:56,200 --> 00:10:02,480
replacing array with maybe this is

00:09:59,209 --> 00:10:04,400
getting quite repetitive you can see

00:10:02,480 --> 00:10:07,220
that these functions are very general

00:10:04,400 --> 00:10:10,940
and we can use them with arrays and

00:10:07,220 --> 00:10:12,529
Maeby's interchangeably okay so this can

00:10:10,940 --> 00:10:14,779
solve our problem because we can come

00:10:12,529 --> 00:10:17,900
back to the code that we wrote before

00:10:14,779 --> 00:10:20,690
this gave us the unwanted nesting and

00:10:17,900 --> 00:10:23,800
we can use join to remove it now we have

00:10:20,690 --> 00:10:27,170
a one-dimensional array that's great

00:10:23,800 --> 00:10:29,240
here it is written using pipe but

00:10:27,170 --> 00:10:32,470
instead of mapping men joining we could

00:10:29,240 --> 00:10:35,180
have avoided the unwanted nesting by

00:10:32,470 --> 00:10:37,220
using a more precise function and that

00:10:35,180 --> 00:10:40,310
function is chain this is sometimes

00:10:37,220 --> 00:10:42,230
called flat map and if we look at the

00:10:40,310 --> 00:10:45,860
type signature it's very similar to the

00:10:42,230 --> 00:10:50,000
type of of map and let's try to

00:10:45,860 --> 00:10:51,740
specialize this to get a feel for it so

00:10:50,000 --> 00:10:54,740
let's say we're going to replace all

00:10:51,740 --> 00:10:57,830
occurrences of a with string we'll

00:10:54,740 --> 00:11:01,540
replace all occurrences of B with string

00:10:57,830 --> 00:11:05,510
and we'll replace all occurrences of em

00:11:01,540 --> 00:11:11,590
with array let's see where that gets us

00:11:05,510 --> 00:11:14,560
okay so look that this way chain takes a

00:11:11,590 --> 00:11:17,060
function from string to array of string

00:11:14,560 --> 00:11:18,770
it takes as a second argument and array

00:11:17,060 --> 00:11:21,050
of strings and it returns us an array of

00:11:18,770 --> 00:11:22,880
strings now why is this a perfect fit

00:11:21,050 --> 00:11:26,480
for our use case well what's the type of

00:11:22,880 --> 00:11:30,260
s dot words string to array of string

00:11:26,480 --> 00:11:34,370
this exactly matches the type that we

00:11:30,260 --> 00:11:37,550
can that we can give to chain so if we

00:11:34,370 --> 00:11:41,960
chain with the words function and give

00:11:37,550 --> 00:11:43,700
it the lines of text we get back the one

00:11:41,960 --> 00:11:45,980
dimensional array that we wanted so it's

00:11:43,700 --> 00:11:48,050
flat map that's a good way to think

00:11:45,980 --> 00:11:49,790
about it okay

00:11:48,050 --> 00:11:52,520
so you can see that what we've done is

00:11:49,790 --> 00:11:55,520
we've replaced what was two operations

00:11:52,520 --> 00:11:57,260
this map plus join with chain and the

00:11:55,520 --> 00:11:59,990
wonderful thing about programming with

00:11:57,260 --> 00:12:01,790
laws that's a word I haven't heard

00:11:59,990 --> 00:12:04,100
mentioned too many times in the last two

00:12:01,790 --> 00:12:06,590
days but laws are a wonderful thing once

00:12:04,100 --> 00:12:09,710
we have laws we can refactor with

00:12:06,590 --> 00:12:11,750
confidence we know with certainty these

00:12:09,710 --> 00:12:15,790
two expressions are equivalent we can

00:12:11,750 --> 00:12:19,370
always replace map plus join with chain

00:12:15,790 --> 00:12:22,250
flap mapping allows us to chain together

00:12:19,370 --> 00:12:25,070
operations which may fail and there are

00:12:22,250 --> 00:12:27,350
so many different types of failure that

00:12:25,070 --> 00:12:30,440
we deal with every day in our programs

00:12:27,350 --> 00:12:31,670
so here's a challenge get the first

00:12:30,440 --> 00:12:33,980
element of the first

00:12:31,670 --> 00:12:40,880
of a two-dimensional array this sounds

00:12:33,980 --> 00:12:44,090
so silly that we almost don't need to

00:12:40,880 --> 00:12:48,100
write any code so let's define this

00:12:44,090 --> 00:12:49,970
array of arrays let's call it happy and

00:12:48,100 --> 00:12:51,670
we've solved the problem

00:12:49,970 --> 00:12:55,220
okay so I'll move on to the next thing

00:12:51,670 --> 00:12:56,590
actually let's just check let's just

00:12:55,220 --> 00:13:00,320
check another couple of things first

00:12:56,590 --> 00:13:04,130
let's create a second test case and

00:13:00,320 --> 00:13:05,570
let's see how this works okay so that's

00:13:04,130 --> 00:13:08,540
undefined

00:13:05,570 --> 00:13:10,280
maybe maybe undefined is okay though

00:13:08,540 --> 00:13:12,170
we'll just let the next thing in the in

00:13:10,280 --> 00:13:17,030
the program crash and say it was their

00:13:12,170 --> 00:13:20,930
fault but let's try let's try sad okay

00:13:17,030 --> 00:13:23,390
so that's clearly not a good solution so

00:13:20,930 --> 00:13:28,010
let's think about it let's try to get

00:13:23,390 --> 00:13:30,410
the head of of happy great okay what can

00:13:28,010 --> 00:13:31,970
we do with a maybe well we know that we

00:13:30,410 --> 00:13:33,770
need to operate on the value inside the

00:13:31,970 --> 00:13:35,330
navy how do we do that

00:13:33,770 --> 00:13:39,350
the first thing to reach for is always

00:13:35,330 --> 00:13:42,620
map so let's map over the result and get

00:13:39,350 --> 00:13:45,320
the head of the result okay but we

00:13:42,620 --> 00:13:49,640
introduced unwanted nesting so what we

00:13:45,320 --> 00:13:53,120
wanted was chain and we have the

00:13:49,640 --> 00:13:55,100
solution and what's lovely is that the

00:13:53,120 --> 00:13:58,280
head function has forced us to handle

00:13:55,100 --> 00:14:02,230
the success case and the two distinct

00:13:58,280 --> 00:14:06,620
failure cases so unhappy just works and

00:14:02,230 --> 00:14:08,750
sad just works so there was no way to

00:14:06,620 --> 00:14:10,660
forget to handle the failure case we

00:14:08,750 --> 00:14:13,610
were forced to handle that by the

00:14:10,660 --> 00:14:17,570
descriptive value that we were given by

00:14:13,610 --> 00:14:20,840
the head function so here it is with map

00:14:17,570 --> 00:14:23,380
and join here it is with chain so it's

00:14:20,840 --> 00:14:26,900
just two very simple steps

00:14:23,380 --> 00:14:30,170
so yeah chaining over nothing is going

00:14:26,900 --> 00:14:32,960
to give us nothing in this case we have

00:14:30,170 --> 00:14:35,510
an array but the head operation fails

00:14:32,960 --> 00:14:37,250
and gives us nothing and in this case we

00:14:35,510 --> 00:14:39,940
have an array the head operation

00:14:37,250 --> 00:14:42,860
succeeds and we'll get back just 13

00:14:39,940 --> 00:14:45,590
pausing jason is another operation which

00:14:42,860 --> 00:14:47,840
may fail so let's prove it to us

00:14:45,590 --> 00:14:51,080
let's pose some what looks like

00:14:47,840 --> 00:14:51,650
incomplete Jason let's see what that

00:14:51,080 --> 00:14:54,320
gives us

00:14:51,650 --> 00:14:58,370
unexpected end of Jason input okay so

00:14:54,320 --> 00:15:00,520
sanctuary never throws exceptions unless

00:14:58,370 --> 00:15:04,460
we you know make a programming error

00:15:00,520 --> 00:15:05,870
okay so it Pass Jason it takes some

00:15:04,460 --> 00:15:09,050
predicate that we'll get to in a minute

00:15:05,870 --> 00:15:10,490
and a string and it returns a maybe a

00:15:09,050 --> 00:15:13,640
this is not a very helpful type

00:15:10,490 --> 00:15:16,370
signature but let's have a play with it

00:15:13,640 --> 00:15:19,160
so let's give it a value that satisfies

00:15:16,370 --> 00:15:22,820
the type signature and let's try our

00:15:19,160 --> 00:15:25,820
invalid jason input okay we got nothing

00:15:22,820 --> 00:15:27,560
so say goodbye to try catch we never

00:15:25,820 --> 00:15:31,310
ever want to use try catch in our

00:15:27,560 --> 00:15:34,400
programs okay so that was great let's

00:15:31,310 --> 00:15:38,810
try making this valid and now we have we

00:15:34,400 --> 00:15:40,390
have the result so far so good now we're

00:15:38,810 --> 00:15:42,170
going to have a brief look at some

00:15:40,390 --> 00:15:45,520
functionality that sanctuary def

00:15:42,170 --> 00:15:48,710
provides so we're going to ask whether

00:15:45,520 --> 00:15:52,760
this value is a member of the integer

00:15:48,710 --> 00:15:54,770
type and it isn't but let's try changing

00:15:52,760 --> 00:15:57,890
this to something that we know to be an

00:15:54,770 --> 00:16:00,260
integer okay so that's that's neat

00:15:57,890 --> 00:16:02,570
nothing too crazy there but this is

00:16:00,260 --> 00:16:05,270
where it starts to get really nice we

00:16:02,570 --> 00:16:10,780
have the ability to describe types in

00:16:05,270 --> 00:16:16,310
real detail so we can ask whether this

00:16:10,780 --> 00:16:20,510
this value is an array of integers so

00:16:16,310 --> 00:16:22,480
let's try let's try this so that's not

00:16:20,510 --> 00:16:25,460
an array of integers but let's try this

00:16:22,480 --> 00:16:27,080
that is so that's really sweet now let's

00:16:25,460 --> 00:16:30,080
come back to pause Jason so that

00:16:27,080 --> 00:16:32,960
predicate that we ignored initially is

00:16:30,080 --> 00:16:36,020
actually really helpful so this

00:16:32,960 --> 00:16:38,270
predicate allows us to place a

00:16:36,020 --> 00:16:40,370
constraint on what we will accept as a

00:16:38,270 --> 00:16:42,290
valid value so first of all pass jason

00:16:40,370 --> 00:16:44,480
will ensure that the passing succeeds

00:16:42,290 --> 00:16:47,570
and we'll deal with any exception that

00:16:44,480 --> 00:16:49,880
may be thrown and it will then give us

00:16:47,570 --> 00:16:51,980
the resulting value and allow us to do

00:16:49,880 --> 00:16:55,460
something with it okay

00:16:51,980 --> 00:16:56,779
so we can say pass jason we can say are

00:16:55,460 --> 00:17:03,230
you

00:16:56,779 --> 00:17:08,409
an array of integers and then let's give

00:17:03,230 --> 00:17:12,350
it some input 1 2 3 let's make it valid

00:17:08,409 --> 00:17:14,679
and we get back just 1 2 3 so we know

00:17:12,350 --> 00:17:18,439
that the type of this expression is

00:17:14,679 --> 00:17:20,959
maybe array of integer we've dealt with

00:17:18,439 --> 00:17:23,029
all the uncertainty in one place at the

00:17:20,959 --> 00:17:24,769
very edge of our program and we can now

00:17:23,029 --> 00:17:28,039
program with confidence knowing exactly

00:17:24,769 --> 00:17:30,080
what we're dealing with lookups may fail

00:17:28,039 --> 00:17:31,580
so I don't need to run these in the

00:17:30,080 --> 00:17:35,090
repple you'll all know what these will

00:17:31,580 --> 00:17:36,919
do yeah lookups are a problem not when

00:17:35,090 --> 00:17:38,539
dealing with code that we write where we

00:17:36,919 --> 00:17:40,789
have control over the shape of things

00:17:38,539 --> 00:17:43,610
but when dealing with input from other

00:17:40,789 --> 00:17:46,309
people so sanctuary provides a get

00:17:43,610 --> 00:17:49,340
function which is specialized for

00:17:46,309 --> 00:17:51,320
dealing with this problem so it's

00:17:49,340 --> 00:17:53,360
similar to pass JSON in that it gives us

00:17:51,320 --> 00:17:57,500
this ability to use a predicate to

00:17:53,360 --> 00:17:59,840
decide whether a value is valid if in

00:17:57,500 --> 00:18:02,240
fact there is a in this case visible

00:17:59,840 --> 00:18:04,639
property we're going to assert that it's

00:18:02,240 --> 00:18:11,720
a boolean and we'll get back in this

00:18:04,639 --> 00:18:15,500
case just false sequence is amazing it

00:18:11,720 --> 00:18:18,260
has this type that is perhaps a bit

00:18:15,500 --> 00:18:20,120
confusing but if we look at this type if

00:18:18,260 --> 00:18:26,539
we would have specialized this if we

00:18:20,120 --> 00:18:28,789
were to replace f with promise and tea

00:18:26,539 --> 00:18:31,429
with array we would have a function that

00:18:28,789 --> 00:18:33,740
takes an array of promises of a and

00:18:31,429 --> 00:18:37,639
gives us back a promise for an array of

00:18:33,740 --> 00:18:39,740
a that's promised at all but I recommend

00:18:37,639 --> 00:18:43,070
never to use promises they are an

00:18:39,740 --> 00:18:45,769
abomination but had they been well

00:18:43,070 --> 00:18:49,130
designed we could have used our sequence

00:18:45,769 --> 00:18:52,100
function with them so sequence we can

00:18:49,130 --> 00:18:56,720
use it here we're turning an array of

00:18:52,100 --> 00:19:00,919
Navis into a maybe containing an array

00:18:56,720 --> 00:19:03,200
so this would give us back and this

00:19:00,919 --> 00:19:05,980
would give us back a maybe containing

00:19:03,200 --> 00:19:08,870
the array 1 2 3 this would give us back

00:19:05,980 --> 00:19:09,320
nothing so sequence has this all or

00:19:08,870 --> 00:19:10,970
nothing

00:19:09,320 --> 00:19:14,210
characteristic that is going to become

00:19:10,970 --> 00:19:16,220
useful in this final challenge so five

00:19:14,210 --> 00:19:17,779
minutes to go pars a given JSON string

00:19:16,220 --> 00:19:20,720
and return the sum of the elements at

00:19:17,779 --> 00:19:21,919
XYZ if they're all heck strings okay

00:19:20,720 --> 00:19:23,960
this is how we would do it in

00:19:21,919 --> 00:19:26,779
straightforward JavaScript coding for

00:19:23,960 --> 00:19:30,230
the happy path we pass the string we do

00:19:26,779 --> 00:19:31,639
the lookups X Y Zed we fold and we get

00:19:30,230 --> 00:19:33,409
back the result but what are the

00:19:31,639 --> 00:19:34,909
problems well this could throw an

00:19:33,409 --> 00:19:36,710
exception that's a problem

00:19:34,909 --> 00:19:38,149
this could throw an exception this could

00:19:36,710 --> 00:19:41,059
throw an exception this could throw an

00:19:38,149 --> 00:19:42,830
exception this could actually XYZ it

00:19:41,059 --> 00:19:44,600
could be there but not be an array so

00:19:42,830 --> 00:19:46,639
there's no reduce so this could throw an

00:19:44,600 --> 00:19:48,559
exception we're assuming that it's an

00:19:46,639 --> 00:19:50,929
array of strings s might not be a string

00:19:48,559 --> 00:19:52,129
pausing might not like the non string

00:19:50,929 --> 00:19:54,379
input we give it this could be an

00:19:52,129 --> 00:19:58,009
exception parsing could fail give us an

00:19:54,379 --> 00:19:59,570
an contaminate the whole computation so

00:19:58,009 --> 00:20:01,789
we've got about seven different failure

00:19:59,570 --> 00:20:03,919
cases here and we are not handling any

00:20:01,789 --> 00:20:06,590
of them so let's think about how we

00:20:03,919 --> 00:20:08,149
would do this the right way so I am

00:20:06,590 --> 00:20:11,330
really gonna put my head down here and

00:20:08,149 --> 00:20:14,029
just go because we have limited time so

00:20:11,330 --> 00:20:15,710
okay we're gonna do parse JSON and for

00:20:14,029 --> 00:20:19,820
now we're just going to say anything

00:20:15,710 --> 00:20:22,220
goes and what we're then going to do is

00:20:19,820 --> 00:20:25,879
we're going to chain and we're going to

00:20:22,220 --> 00:20:29,240
get again saying anything goes we're

00:20:25,879 --> 00:20:32,120
going to get the X and we're going to

00:20:29,240 --> 00:20:33,580
give it oh this is a challenge doing

00:20:32,120 --> 00:20:43,929
this quickly but we're going to give it

00:20:33,580 --> 00:20:48,799
X Y Z never write JSON by hand folks 28

00:20:43,929 --> 00:20:51,049
29 and 20 a let's try this okay so we

00:20:48,799 --> 00:20:52,580
have just this it's going to get painful

00:20:51,049 --> 00:20:56,690
we're going to have to do two more chain

00:20:52,580 --> 00:21:00,289
gets so let's use some nice sugar we're

00:20:56,690 --> 00:21:02,509
going to replace this with gets which is

00:21:00,289 --> 00:21:05,269
the plural of get we can then provide an

00:21:02,509 --> 00:21:10,970
array and we'll provide the other two

00:21:05,269 --> 00:21:12,830
and see where that gets us okay so now

00:21:10,970 --> 00:21:14,809
we have this now we need to operate on

00:21:12,830 --> 00:21:17,149
those strings they're inside an array

00:21:14,809 --> 00:21:20,919
which is inside a maybe so we need to

00:21:17,149 --> 00:21:23,070
map twice so let's give that a go

00:21:20,919 --> 00:21:27,539
so we need to do s stop

00:21:23,070 --> 00:21:29,519
map of s top map of in this case s top

00:21:27,539 --> 00:21:32,039
sequence sequence remember is the

00:21:29,519 --> 00:21:32,909
turning inside out thingy there's no way

00:21:32,039 --> 00:21:38,009
to describe it

00:21:32,909 --> 00:21:40,559
I've tried it's impossible and let's see

00:21:38,009 --> 00:21:43,220
where this gets us ok this gets us to

00:21:40,559 --> 00:21:44,700
type error so we can see here that I've

00:21:43,220 --> 00:21:47,039
made a mistake

00:21:44,700 --> 00:21:49,980
and a sanctuary def is providing us with

00:21:47,039 --> 00:21:53,279
some some nice error messages in this

00:21:49,980 --> 00:21:55,110
case but I see what I've done wrong and

00:21:53,279 --> 00:21:57,899
I will quickly try to correct that I got

00:21:55,110 --> 00:22:00,629
one step ahead of myself so we first

00:21:57,899 --> 00:22:03,870
need to do the gets operation we then

00:22:00,629 --> 00:22:08,399
need to do the this should be the PA's

00:22:03,870 --> 00:22:12,600
end operation base 16 and I think I have

00:22:08,399 --> 00:22:15,330
the right number of parens there okay so

00:22:12,600 --> 00:22:18,240
now we have this thing which is getting

00:22:15,330 --> 00:22:20,789
us closer we we finally need to use

00:22:18,240 --> 00:22:22,620
sequence to turn this inside out because

00:22:20,789 --> 00:22:25,529
we have a maybe containing an array

00:22:22,620 --> 00:22:27,299
containing maybes we want the the maybes

00:22:25,529 --> 00:22:30,509
to get together so that we can join them

00:22:27,299 --> 00:22:33,690
out of existence so let's quickly try

00:22:30,509 --> 00:22:37,080
this we're going to we're going to chain

00:22:33,690 --> 00:22:44,250
we're going to map with Parsons and

00:22:37,080 --> 00:22:48,419
we're going to chain with sequence and

00:22:44,250 --> 00:22:50,610
sequence needs this type hint and I'm

00:22:48,419 --> 00:22:53,669
then going to actually just go ahead and

00:22:50,610 --> 00:23:00,240
do the final step which is to take the

00:22:53,669 --> 00:23:00,809
sum of these values and voila just one

00:23:00,240 --> 00:23:03,480
two three

00:23:00,809 --> 00:23:04,889
so we've handled all these cases there's

00:23:03,480 --> 00:23:07,830
actually one thing that I skipped here

00:23:04,889 --> 00:23:11,129
which is this predicate should really be

00:23:07,830 --> 00:23:12,779
S dot is dollar dot array of dollar dot

00:23:11,129 --> 00:23:14,580
string and that guarantees that the

00:23:12,779 --> 00:23:16,679
value at XYZ is in fact an array of

00:23:14,580 --> 00:23:19,740
strings and that guarantees that all

00:23:16,679 --> 00:23:21,539
these future operations will succeed so

00:23:19,740 --> 00:23:24,240
let's just step through it one more time

00:23:21,539 --> 00:23:28,590
pass jason that handles the invalid

00:23:24,240 --> 00:23:30,690
jason we do these chained gets which we

00:23:28,590 --> 00:23:34,690
can replace with a single call to s dot

00:23:30,690 --> 00:23:36,910
gets we can then replace this

00:23:34,690 --> 00:23:38,590
place holder predicate with something

00:23:36,910 --> 00:23:41,680
that will assert that we have an array

00:23:38,590 --> 00:23:44,680
of strings and fail the computation if

00:23:41,680 --> 00:23:46,450
not and by fail I mean produce nothing

00:23:44,680 --> 00:23:49,450
not throw an exception we never throw

00:23:46,450 --> 00:23:52,870
exceptions then we can map over each of

00:23:49,450 --> 00:23:56,470
those strings parse them in a way that

00:23:52,870 --> 00:23:59,800
is safe and if any one of those strings

00:23:56,470 --> 00:24:02,110
fails to pass will again fail the

00:23:59,800 --> 00:24:05,110
computation as a whole we then use

00:24:02,110 --> 00:24:07,450
sequence and sequence look at this we

00:24:05,110 --> 00:24:09,460
have a maybe array of maybe integers and

00:24:07,450 --> 00:24:12,370
look what happens when we sequence we

00:24:09,460 --> 00:24:14,290
now have a maybe maybe of array of

00:24:12,370 --> 00:24:16,960
integer and what can we do when we have

00:24:14,290 --> 00:24:18,910
nesting like that we use our own friend

00:24:16,960 --> 00:24:21,160
our old friend join and we've removed

00:24:18,910 --> 00:24:23,350
the nesting now we just have maybe array

00:24:21,160 --> 00:24:25,210
of integer and and of course we can

00:24:23,350 --> 00:24:28,240
replace map and join with chain we've

00:24:25,210 --> 00:24:30,490
learnt that already and then we can map

00:24:28,240 --> 00:24:33,010
to get the sum now we have a function

00:24:30,490 --> 00:24:36,010
from string to maybe integer beautiful

00:24:33,010 --> 00:24:38,830
and one thing you'll notice is there's

00:24:36,010 --> 00:24:42,190
actually no branching in this you have

00:24:38,830 --> 00:24:45,940
100% branch coverage without writing any

00:24:42,190 --> 00:24:48,400
tests so that's pretty nice this is the

00:24:45,940 --> 00:24:50,580
equivalent imperative JavaScript we need

00:24:48,400 --> 00:24:53,050
to use try catch to do the JSON parsing

00:24:50,580 --> 00:24:56,830
we need three null checks for the nested

00:24:53,050 --> 00:24:58,180
lookups this is a ray check and then we

00:24:56,830 --> 00:25:00,910
need to check that we're dealing with a

00:24:58,180 --> 00:25:03,250
string we need to do some extra pausing

00:25:00,910 --> 00:25:06,250
to handle quirks and the built-in

00:25:03,250 --> 00:25:08,140
parsing function and we have to return

00:25:06,250 --> 00:25:11,890
an explicitly in three different places

00:25:08,140 --> 00:25:13,780
and moreover our type is a lie its

00:25:11,890 --> 00:25:18,130
string to number and we're using a bogus

00:25:13,780 --> 00:25:20,550
value nan so sanctuary oh that's meant

00:25:18,130 --> 00:25:24,010
to say refuge from unsafe JavaScript

00:25:20,550 --> 00:25:27,070
yeah check it out at sanctuary J's org

00:25:24,010 --> 00:25:29,410
and I'd love to chat with you about it

00:25:27,070 --> 00:25:29,950
after this 12 seconds to go so good

00:25:29,410 --> 00:25:32,150
timing

00:25:29,950 --> 00:25:35,380
that's it

00:25:32,150 --> 00:25:35,380
[Applause]

00:25:38,140 --> 00:25:41,840
all right we got a couple questions for

00:25:40,310 --> 00:25:43,940
you ready yes sure

00:25:41,840 --> 00:25:45,980
what's that command line you using

00:25:43,940 --> 00:25:49,130
that's called the node Ripple

00:25:45,980 --> 00:25:50,930
so all we needed to do to make this work

00:25:49,130 --> 00:25:54,400
you might be wondering how do we get

00:25:50,930 --> 00:25:58,670
these nice type signatures if you

00:25:54,400 --> 00:26:02,060
specify util dot inspect custom it's a

00:25:58,670 --> 00:26:04,730
symbol then you can customize the

00:26:02,060 --> 00:26:07,850
representation of values when they're

00:26:04,730 --> 00:26:09,470
printed in the ripple how is nothing

00:26:07,850 --> 00:26:11,060
better than syntax error

00:26:09,470 --> 00:26:12,800
oh it's infinitely better what do you do

00:26:11,060 --> 00:26:14,690
with syntax error I mean unless you're

00:26:12,800 --> 00:26:16,790
talking about actually just passing

00:26:14,690 --> 00:26:18,920
around an error as a value which I

00:26:16,790 --> 00:26:20,780
haven't seen anyone do I assume you're

00:26:18,920 --> 00:26:24,920
talking about throwing a syntax error

00:26:20,780 --> 00:26:27,830
and well you can't compose functions

00:26:24,920 --> 00:26:31,340
that are throwing exceptions and we want

00:26:27,830 --> 00:26:35,690
to compose because composition is the

00:26:31,340 --> 00:26:38,660
solution to limiting complexity next one

00:26:35,690 --> 00:26:43,640
can you compare sanctuary to Ram des yes

00:26:38,660 --> 00:26:46,730
so from 2014 to 2016 I contributed

00:26:43,640 --> 00:26:48,800
heavily to ram des there was a

00:26:46,730 --> 00:26:51,500
discussion specifically about the head

00:26:48,800 --> 00:26:53,690
function ram does head function has the

00:26:51,500 --> 00:26:57,980
same problems that you know the

00:26:53,690 --> 00:27:02,540
JavaScript Java Script said example has

00:26:57,980 --> 00:27:04,370
and I wanted to change that there was

00:27:02,540 --> 00:27:06,320
some disagreement within the ram de team

00:27:04,370 --> 00:27:09,830
as to whether we could push it this far

00:27:06,320 --> 00:27:11,840
and in the end I decided to create a

00:27:09,830 --> 00:27:16,780
separate library that at the time was

00:27:11,840 --> 00:27:19,970
just to accompany ram de but in the last

00:27:16,780 --> 00:27:22,400
three or four years it's really become

00:27:19,970 --> 00:27:24,230
its own thing and in many projects I now

00:27:22,400 --> 00:27:28,070
use sanctuary without Ram de but they

00:27:24,230 --> 00:27:30,020
still work well together alright next

00:27:28,070 --> 00:27:30,890
one what is wrong with promises and what

00:27:30,020 --> 00:27:34,910
would you recommend

00:27:30,890 --> 00:27:37,040
so I anticipated this question and I

00:27:34,910 --> 00:27:40,100
recommend that you all read about broken

00:27:37,040 --> 00:27:43,640
promises this is written by a friend of

00:27:40,100 --> 00:27:44,890
mine Olin vlasblom and there are many

00:27:43,640 --> 00:27:46,970
many problems with

00:27:44,890 --> 00:27:48,950
promises okay you wanted to know what's

00:27:46,970 --> 00:27:51,200
wrong with them let's make this quick

00:27:48,950 --> 00:27:52,430
okay there they trigger side effects at

00:27:51,200 --> 00:27:54,080
the time that you create them

00:27:52,430 --> 00:27:57,170
that's awful because we want to actually

00:27:54,080 --> 00:27:59,570
just compose things and then trigger

00:27:57,170 --> 00:28:01,820
them when we're ready that's one problem

00:27:59,570 --> 00:28:03,800
so let me just look at the cliff notes

00:28:01,820 --> 00:28:07,190
eagerness cancellation promises don't

00:28:03,800 --> 00:28:09,470
support cancellation they should there's

00:28:07,190 --> 00:28:10,820
a specialized API so promises require us

00:28:09,470 --> 00:28:13,580
to learn all these promise functions

00:28:10,820 --> 00:28:16,490
well if we learn sanctuary and we learn

00:28:13,580 --> 00:28:18,080
map chain join we never need to learn

00:28:16,490 --> 00:28:20,270
another API we can go to these

00:28:18,080 --> 00:28:22,460
conferences and nobody needs to say

00:28:20,270 --> 00:28:24,200
anything about any API because they're

00:28:22,460 --> 00:28:26,210
just providing types that satisfy these

00:28:24,200 --> 00:28:27,860
requirements and we just use the ten

00:28:26,210 --> 00:28:29,840
functions that we already know so

00:28:27,860 --> 00:28:32,030
specialized API thumbs-down promised are

00:28:29,840 --> 00:28:34,490
all thumbs down yeah no good error

00:28:32,030 --> 00:28:36,230
handling oh it's I have no idea who came

00:28:34,490 --> 00:28:39,830
up with this but the idea that they

00:28:36,230 --> 00:28:41,690
failed so an error of programming error

00:28:39,830 --> 00:28:43,910
inside one of our functions when we're

00:28:41,690 --> 00:28:48,860
using then can somehow turn into a

00:28:43,910 --> 00:28:50,950
rejected promise is it's well diabolical

00:28:48,860 --> 00:28:53,540
I would say because we then have this

00:28:50,950 --> 00:28:55,820
this possibility of saying well we're

00:28:53,540 --> 00:28:57,800
going to handle our error by responding

00:28:55,820 --> 00:28:59,690
to the user with a 404 because clearly

00:28:57,800 --> 00:29:00,020
the reason we got into this state was

00:28:59,690 --> 00:29:03,140
that

00:29:00,020 --> 00:29:05,120
well our database query failed when in

00:29:03,140 --> 00:29:07,520
fact it was you know a typo in our code

00:29:05,120 --> 00:29:11,450
every single user request coming in is

00:29:07,520 --> 00:29:13,250
just getting a 404 response so you know

00:29:11,450 --> 00:29:15,740
programming bugs should crash our code

00:29:13,250 --> 00:29:17,900
they shouldn't just silently turn into

00:29:15,740 --> 00:29:20,780
failures that's like the nan thing all

00:29:17,900 --> 00:29:24,320
over again yeah mixing exceptions with

00:29:20,780 --> 00:29:27,020
failures that's that's really it so yeah

00:29:24,320 --> 00:29:28,700
don't use promises Aldona has been

00:29:27,020 --> 00:29:31,550
working for the last few years on this

00:29:28,700 --> 00:29:33,560
library called future it's amazing it

00:29:31,550 --> 00:29:36,200
integrates flawlessly with sanctuary and

00:29:33,560 --> 00:29:38,330
once you're using once you're using

00:29:36,200 --> 00:29:40,520
fluid you'll probably want to use pure

00:29:38,330 --> 00:29:42,410
script and you know really have all

00:29:40,520 --> 00:29:44,560
these tools have it a very very

00:29:42,410 --> 00:29:46,550
passionate about it it's fantastic

00:29:44,560 --> 00:29:48,910
alright maybe time for one more question

00:29:46,550 --> 00:29:51,500
how's runtime performance of sanctuary

00:29:48,910 --> 00:29:54,020
this old type system Chucky bringing too

00:29:51,500 --> 00:29:55,490
much computational overhead sorry yes it

00:29:54,020 --> 00:29:57,470
definitely does bring computational

00:29:55,490 --> 00:29:58,580
overhead but we can turn it off it's

00:29:57,470 --> 00:30:00,830
very simple

00:29:58,580 --> 00:30:03,290
there's a create function in sanctuary

00:30:00,830 --> 00:30:05,930
that returns a new sanctuary module and

00:30:03,290 --> 00:30:08,930
we can say check types false when we

00:30:05,930 --> 00:30:11,480
create that new sanctuary module so we

00:30:08,930 --> 00:30:13,130
can even use a check like you know node

00:30:11,480 --> 00:30:14,180
and vehicles production then we'll use

00:30:13,130 --> 00:30:16,490
type checking

00:30:14,180 --> 00:30:18,230
then we'll disable type checking

00:30:16,490 --> 00:30:20,270
otherwise we'll have it on because we're

00:30:18,230 --> 00:30:21,770
in development all right thank you very

00:30:20,270 --> 00:30:24,890
much thank you give David a head

00:30:21,770 --> 00:30:24,890

YouTube URL: https://www.youtube.com/watch?v=a2astdDbOjk


