Title: ReactiveConf 2018 - Sean Grove: Help Your Computer Help You
Publication date: 2018-11-05
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Main stage
-------------------------------------------------------------------
Help Your Computer Help You
Captions: 
	00:00:02,140 --> 00:00:08,610
[Music]

00:00:12,320 --> 00:00:16,890
all right I was told that I can't move

00:00:15,179 --> 00:00:19,259
around like normal I have to stay static

00:00:16,890 --> 00:00:20,939
for the camera so unfortunately I can't

00:00:19,259 --> 00:00:22,559
show off a lot of my acrobatic skills

00:00:20,939 --> 00:00:23,669
like I normally would I know you guys

00:00:22,559 --> 00:00:25,950
are looking forward to that I'm sure at

00:00:23,669 --> 00:00:29,250
the end of the day but I'm gonna be

00:00:25,950 --> 00:00:36,270
talking about all the manual work that

00:00:29,250 --> 00:00:40,410
we do as programmers perfect all right

00:00:36,270 --> 00:00:43,110
and I think that you know while work is

00:00:40,410 --> 00:00:45,420
a good thing right it's better to work

00:00:43,110 --> 00:00:46,500
than to be idle I think we can go ahead

00:00:45,420 --> 00:00:49,220
and take it a little bit easier on

00:00:46,500 --> 00:00:51,420
ourselves maybe we can go ahead and

00:00:49,220 --> 00:00:53,160
teach the computers to help us a little

00:00:51,420 --> 00:00:56,160
bit more as I want to talk today about

00:00:53,160 --> 00:01:01,170
helping to teach the computers to help

00:00:56,160 --> 00:01:05,220
us so the opening statement here is that

00:01:01,170 --> 00:01:09,179
as programmers we spend way way too much

00:01:05,220 --> 00:01:11,729
time doing very manual tasks our entire

00:01:09,179 --> 00:01:14,310
job is typically to automate other

00:01:11,729 --> 00:01:17,579
people's work and there's still so much

00:01:14,310 --> 00:01:20,549
of our work that we don't automate I

00:01:17,579 --> 00:01:23,670
would say that like the amount of work

00:01:20,549 --> 00:01:25,170
that we do that is manual right now is

00:01:23,670 --> 00:01:28,200
about 90 percent the computer automates

00:01:25,170 --> 00:01:29,999
about 10 percent of what is possible and

00:01:28,200 --> 00:01:31,200
I would say that in the next couple of

00:01:29,999 --> 00:01:33,929
years I'd really like to see it get

00:01:31,200 --> 00:01:36,479
closer to maybe you know we're doing

00:01:33,929 --> 00:01:37,799
about 20 percent of the work by 20

00:01:36,479 --> 00:01:40,469
percent of the work that we do is

00:01:37,799 --> 00:01:42,899
actually creative it's interesting right

00:01:40,469 --> 00:01:45,539
whether it's a you know a user process

00:01:42,899 --> 00:01:48,569
or user interface design or product

00:01:45,539 --> 00:01:50,459
design or algorithms that can be very

00:01:48,569 --> 00:01:53,639
very interesting a lot of the stuff we

00:01:50,459 --> 00:01:55,109
do is not very interesting I think there

00:01:53,639 --> 00:01:57,179
are a lot of people who who know the

00:01:55,109 --> 00:01:59,279
feeling whenever you go to debug a test

00:01:57,179 --> 00:02:02,399
and you're just you're not feeling up to

00:01:59,279 --> 00:02:06,090
it and I think this president although I

00:02:02,399 --> 00:02:08,610
think 90% to 20% sounds like a very big

00:02:06,090 --> 00:02:10,970
jump it sounds a little bit unrealistic

00:02:08,610 --> 00:02:13,189
but I do think that there's presidents a

00:02:10,970 --> 00:02:16,980
long long time ago

00:02:13,189 --> 00:02:17,940
every CPU for example had instruction

00:02:16,980 --> 00:02:20,330
sets that

00:02:17,940 --> 00:02:24,270
were initially targeted towards humans

00:02:20,330 --> 00:02:27,030
the idea was that when I designed a CPU

00:02:24,270 --> 00:02:29,220
I would write up documentation for other

00:02:27,030 --> 00:02:32,610
humans to read so that they could write

00:02:29,220 --> 00:02:35,490
assembler for my CPU and the problem was

00:02:32,610 --> 00:02:38,070
that computers could execute that

00:02:35,490 --> 00:02:39,240
assembler code but they could not

00:02:38,070 --> 00:02:41,400
understand it

00:02:39,240 --> 00:02:43,680
right they could only run it and so as

00:02:41,400 --> 00:02:46,740
humans it was up to us to build up these

00:02:43,680 --> 00:02:51,420
amazing towers of complexity to run on

00:02:46,740 --> 00:02:54,540
these old CPUs but today nearly no CPUs

00:02:51,420 --> 00:02:55,770
are designed for humans to use right

00:02:54,540 --> 00:02:57,690
raise your hand

00:02:55,770 --> 00:03:00,390
it's the like the last time that she

00:02:57,690 --> 00:03:02,580
wrote x86 assembler it's probably some

00:03:00,390 --> 00:03:07,230
people right but very very few of us

00:03:02,580 --> 00:03:08,460
right just directly for CPUs the CPUs

00:03:07,230 --> 00:03:11,700
are actually designed for other

00:03:08,460 --> 00:03:14,940
computers the CPUs are designed for

00:03:11,700 --> 00:03:17,490
compilers these days and the result of

00:03:14,940 --> 00:03:21,480
that is that we actually write very

00:03:17,490 --> 00:03:24,630
little of our own code right even if we

00:03:21,480 --> 00:03:26,459
writes maybe hundreds or thousands or

00:03:24,630 --> 00:03:30,030
tens of thousands of lines of JavaScript

00:03:26,459 --> 00:03:32,370
if you think about how fast a CPU is

00:03:30,030 --> 00:03:35,489
they can do billions of operations per

00:03:32,370 --> 00:03:37,590
second and your JavaScript takes one and

00:03:35,489 --> 00:03:40,320
a half seconds to load right that's

00:03:37,590 --> 00:03:43,140
billions of operations it Dwarfs the

00:03:40,320 --> 00:03:46,680
amount of code that we write by a huge

00:03:43,140 --> 00:03:48,090
margin and so and actually that's really

00:03:46,680 --> 00:03:50,010
really nice because I don't want to be

00:03:48,090 --> 00:03:51,870
spending my time and I think very few of

00:03:50,010 --> 00:03:54,300
us want to be spending our time really

00:03:51,870 --> 00:03:57,000
at that low level right so by enabling

00:03:54,300 --> 00:03:59,820
computers to actually write our code for

00:03:57,000 --> 00:04:01,290
us we've freed ourselves up to focus on

00:03:59,820 --> 00:04:03,510
things that matter much much more and

00:04:01,290 --> 00:04:04,769
are much more interesting not only that

00:04:03,510 --> 00:04:06,420
but like we've taught them so well that

00:04:04,769 --> 00:04:07,950
typically not only do they write the

00:04:06,420 --> 00:04:09,720
code faster than we would but they

00:04:07,950 --> 00:04:12,780
typically write it better right it would

00:04:09,720 --> 00:04:14,790
take me a long long time to figure out

00:04:12,780 --> 00:04:17,090
all of the nuances of how the CPUs work

00:04:14,790 --> 00:04:21,540
in order to actually outperform

00:04:17,090 --> 00:04:23,100
compilers another example of this I

00:04:21,540 --> 00:04:25,830
think that is probably maybe near and

00:04:23,100 --> 00:04:28,590
dear to a lot of our hearts is Babel so

00:04:25,830 --> 00:04:30,999
with compilers write compilers enabled

00:04:28,590 --> 00:04:33,610
computers to write code for us

00:04:30,999 --> 00:04:35,679
what Babel did is made it so that

00:04:33,610 --> 00:04:38,529
computers can actually read our

00:04:35,679 --> 00:04:40,689
JavaScript code right previously was

00:04:38,529 --> 00:04:41,889
that we had JavaScript engines that

00:04:40,689 --> 00:04:43,479
could run it but they couldn't really

00:04:41,889 --> 00:04:47,110
read it they couldn't reason about it at

00:04:43,479 --> 00:04:48,939
all but now we do and imagine life I

00:04:47,110 --> 00:04:51,849
mean this is all very fresh in our minds

00:04:48,939 --> 00:04:55,360
right life before Babel and life after

00:04:51,849 --> 00:04:57,969
Babel is remarkably different and I

00:04:55,360 --> 00:05:00,879
would say remarkably better right there

00:04:57,969 --> 00:05:03,219
are so many nice tools now because we've

00:05:00,879 --> 00:05:04,659
taught the computer how to read the code

00:05:03,219 --> 00:05:07,149
right to turn into an abstract syntax

00:05:04,659 --> 00:05:09,519
tree pass that around to libraries and

00:05:07,149 --> 00:05:12,009
suddenly we can experiment with

00:05:09,519 --> 00:05:14,679
different syntaxes right we can try

00:05:12,009 --> 00:05:16,899
things very very easily as a community

00:05:14,679 --> 00:05:19,749
without having to get the entire

00:05:16,899 --> 00:05:22,119
standards body on board and so this has

00:05:19,749 --> 00:05:24,009
enabled a huge amounts of creativity by

00:05:22,119 --> 00:05:30,309
teaching computers to be able to read

00:05:24,009 --> 00:05:34,269
our code the third example here I would

00:05:30,309 --> 00:05:36,489
say is performance profiling so you know

00:05:34,269 --> 00:05:38,499
there's a lot of times where whenever

00:05:36,489 --> 00:05:40,300
you're getting started with your

00:05:38,499 --> 00:05:42,699
application you probably not take

00:05:40,300 --> 00:05:44,800
keeping performance in mind so you build

00:05:42,699 --> 00:05:46,059
it all up you get it to work right which

00:05:44,800 --> 00:05:49,539
is how you should probably do it and

00:05:46,059 --> 00:05:51,429
then it comes time to make it

00:05:49,539 --> 00:05:55,599
performance so you have to profile it

00:05:51,429 --> 00:05:58,119
and typically the profiling tools in the

00:05:55,599 --> 00:06:00,369
beginning are kind of text-oriented

00:05:58,119 --> 00:06:02,860
right so in this case I'm using closures

00:06:00,369 --> 00:06:04,989
trace function it's beautiful it's great

00:06:02,860 --> 00:06:07,419
you can see how like I can see each of

00:06:04,989 --> 00:06:09,459
these nested calls I can see the

00:06:07,419 --> 00:06:11,559
parameters and the return I can see

00:06:09,459 --> 00:06:14,379
maybe how much time they took and as a

00:06:11,559 --> 00:06:16,779
human this is really really nice as a

00:06:14,379 --> 00:06:19,269
computer however the computer has not

00:06:16,779 --> 00:06:20,679
like this is not usable right the

00:06:19,269 --> 00:06:23,039
computer does not going to be able to

00:06:20,679 --> 00:06:28,360
reason about the performance of our code

00:06:23,039 --> 00:06:30,909
given this bit of data but now most

00:06:28,360 --> 00:06:32,579
performance tools and profiling tools no

00:06:30,909 --> 00:06:35,679
one actually reads the profiling data

00:06:32,579 --> 00:06:39,129
that data is meant exclusively for

00:06:35,679 --> 00:06:41,829
computers to read and now we have these

00:06:39,129 --> 00:06:44,800
really really nice tools right because

00:06:41,829 --> 00:06:47,620
computers can read so much

00:06:44,800 --> 00:06:49,509
denser data than humans can we have

00:06:47,620 --> 00:06:51,729
amazing tools that can show us you know

00:06:49,509 --> 00:06:53,530
not just the stack trace but show me

00:06:51,729 --> 00:06:53,860
like where is all my memory going right

00:06:53,530 --> 00:06:55,690
now

00:06:53,860 --> 00:06:57,610
right what are the the objects that

00:06:55,690 --> 00:07:01,210
haven't been garbage collected yet where

00:06:57,610 --> 00:07:03,729
where was my program slow as I played

00:07:01,210 --> 00:07:07,270
through it previously these tools are

00:07:03,729 --> 00:07:10,569
invaluable and they can't exist if we

00:07:07,270 --> 00:07:15,430
have this as our basis we have to teach

00:07:10,569 --> 00:07:18,280
the computers to do more and I think the

00:07:15,430 --> 00:07:20,319
fact that designing for exclusively for

00:07:18,280 --> 00:07:23,259
computers is really an important key

00:07:20,319 --> 00:07:25,330
here we very often mix up these two

00:07:23,259 --> 00:07:27,520
things where we'll do a little bit of

00:07:25,330 --> 00:07:30,129
data for computer and then a little bit

00:07:27,520 --> 00:07:32,169
of data for a human right Docs or

00:07:30,129 --> 00:07:34,360
something like that for humans and

00:07:32,169 --> 00:07:36,699
that's actually not I think a great

00:07:34,360 --> 00:07:39,610
approach because computers will actually

00:07:36,699 --> 00:07:41,919
do most of the reading right so you read

00:07:39,610 --> 00:07:43,349
your JavaScript code one second or you

00:07:41,919 --> 00:07:46,360
know maybe it's several times per day

00:07:43,349 --> 00:07:49,000
but computers will read that millions

00:07:46,360 --> 00:07:51,190
and millions and millions of times and

00:07:49,000 --> 00:07:54,880
computers are able to take a computer

00:07:51,190 --> 00:07:57,400
readable version and present a human

00:07:54,880 --> 00:07:59,620
readable version right going the other

00:07:57,400 --> 00:08:01,900
way around is very difficult but

00:07:59,620 --> 00:08:05,889
computers can do this and the really

00:08:01,900 --> 00:08:08,169
cool thing is that computer ideas that

00:08:05,889 --> 00:08:10,509
are meant or and intended for computers

00:08:08,169 --> 00:08:13,900
to be able to read are then composable

00:08:10,509 --> 00:08:15,039
by humans and if we take the previous

00:08:13,900 --> 00:08:17,379
two examples that we looked at

00:08:15,039 --> 00:08:21,219
beforehand where computers are able to

00:08:17,379 --> 00:08:23,440
write our code for us and they're able

00:08:21,219 --> 00:08:28,180
to reason about the performance of our

00:08:23,440 --> 00:08:30,729
code we get a JIT right and we all rely

00:08:28,180 --> 00:08:35,289
heavily in our professional day-to-day

00:08:30,729 --> 00:08:35,740
lives and as users on JIT compilers but

00:08:35,289 --> 00:08:37,870
jits

00:08:35,740 --> 00:08:40,060
are not meant for humans at all right

00:08:37,870 --> 00:08:42,459
they have all the data's oriented for

00:08:40,060 --> 00:08:45,250
computers and then they write these

00:08:42,459 --> 00:08:46,720
compilers right for CPUs and instruction

00:08:45,250 --> 00:08:49,329
sets that were meant for compilers not

00:08:46,720 --> 00:08:51,040
really for humans like being able to

00:08:49,329 --> 00:08:54,000
compose these computer ideas is

00:08:51,040 --> 00:08:54,000
incredibly powerful

00:08:54,970 --> 00:08:58,829
and there is a place for a

00:08:56,230 --> 00:09:00,939
human-readable layer right ultimately

00:08:58,829 --> 00:09:04,029
the reason that we do anything with

00:09:00,939 --> 00:09:05,290
computers is to affect humans somehow so

00:09:04,029 --> 00:09:07,839
we do want to have a human readable

00:09:05,290 --> 00:09:10,180
layer but it should be very very thin

00:09:07,839 --> 00:09:13,300
and it should always be the last stage

00:09:10,180 --> 00:09:16,959
of a paid or of the pipeline and the

00:09:13,300 --> 00:09:19,600
reason is the definition of misery is

00:09:16,959 --> 00:09:24,189
trying to recover computer readability

00:09:19,600 --> 00:09:25,600
from a human oriented system so you know

00:09:24,189 --> 00:09:28,269
the very famous example here is maybe

00:09:25,600 --> 00:09:30,370
sequel right sequel is incredibly

00:09:28,269 --> 00:09:32,199
powerful and it's beautiful like the

00:09:30,370 --> 00:09:34,660
relations the relational databases are

00:09:32,199 --> 00:09:37,240
just amazing they have what decades

00:09:34,660 --> 00:09:40,329
nearly half a century of research that

00:09:37,240 --> 00:09:42,730
has gone into them and people are scared

00:09:40,329 --> 00:09:45,310
to use them in many cases because it was

00:09:42,730 --> 00:09:47,800
originally designed for a human to use

00:09:45,310 --> 00:09:49,750
the thought was that a human would sit

00:09:47,800 --> 00:09:51,759
down at the terminal and would type in

00:09:49,750 --> 00:09:53,410
strings and so it was very important

00:09:51,759 --> 00:09:56,230
that would be a string oriented language

00:09:53,410 --> 00:09:58,569
and that everything would be streamed

00:09:56,230 --> 00:10:00,939
based like kind of a nice little

00:09:58,569 --> 00:10:03,639
language and actually argued that I

00:10:00,939 --> 00:10:05,410
think a lot of the reason that people

00:10:03,639 --> 00:10:07,569
were into no sequel for example is

00:10:05,410 --> 00:10:09,670
because it took a computer readable

00:10:07,569 --> 00:10:11,769
thing and then presented a human

00:10:09,670 --> 00:10:14,050
readable version on top of that right

00:10:11,769 --> 00:10:16,449
string interpolation with sequel is the

00:10:14,050 --> 00:10:19,139
source of so many different security

00:10:16,449 --> 00:10:22,720
attacks and it's just incredibly painful

00:10:19,139 --> 00:10:23,920
like being able to compose functions in

00:10:22,720 --> 00:10:26,769
our code is something we all take for

00:10:23,920 --> 00:10:28,809
granted but if you try to compose sequel

00:10:26,769 --> 00:10:30,490
functions from your programming language

00:10:28,809 --> 00:10:33,009
that's an incredibly difficult thing to

00:10:30,490 --> 00:10:35,769
do you effectively have to write a

00:10:33,009 --> 00:10:38,649
compiler you have to teach the computer

00:10:35,769 --> 00:10:41,019
how to read sequel or at least how to

00:10:38,649 --> 00:10:44,470
write sequel and the other example here

00:10:41,019 --> 00:10:45,850
is maybe site scrapers so I was at a

00:10:44,470 --> 00:10:51,069
company where I had to maintain more

00:10:45,850 --> 00:10:52,389
than 100 scrapers sometimes with

00:10:51,069 --> 00:10:55,000
companies who didn't want us to be

00:10:52,389 --> 00:10:57,250
scraping their sites and so I know like

00:10:55,000 --> 00:10:59,680
how easy it is for scrapers to break

00:10:57,250 --> 00:11:01,839
because scrape like webpages are not

00:10:59,680 --> 00:11:03,610
meant for computers to read they're

00:11:01,839 --> 00:11:06,480
meant for computers to render for a

00:11:03,610 --> 00:11:06,480
human to look at

00:11:07,120 --> 00:11:13,629
so again keep the human layer very very

00:11:10,329 --> 00:11:16,529
thin because I need any amount of energy

00:11:13,629 --> 00:11:20,050
that you invest and that human layer is

00:11:16,529 --> 00:11:21,999
lost to the computer so you always want

00:11:20,050 --> 00:11:23,949
to ask yourself could I be pushing this

00:11:21,999 --> 00:11:27,699
down into a computer level and then

00:11:23,949 --> 00:11:29,620
maybe generating this human layer again

00:11:27,699 --> 00:11:31,660
the crux of this is going from human

00:11:29,620 --> 00:11:34,269
computer readable to human is much much

00:11:31,660 --> 00:11:36,249
better than the alternative did you

00:11:34,269 --> 00:11:41,170
drive this home I'll take an example

00:11:36,249 --> 00:11:42,670
here let's say that's given a API I want

00:11:41,170 --> 00:11:44,889
to actually generate maybe some tools I

00:11:42,670 --> 00:11:46,269
want to like explore this API I want to

00:11:44,889 --> 00:11:48,759
know what it's like maybe I want to

00:11:46,269 --> 00:11:51,639
generate like a an autocomplete tool for

00:11:48,759 --> 00:11:53,230
my editor so these are beautiful

00:11:51,639 --> 00:11:55,420
documents right there generator I think

00:11:53,230 --> 00:11:57,100
by reading the i/o Trello has taken a

00:11:55,420 --> 00:12:01,240
lot of effort painting effort to

00:11:57,100 --> 00:12:03,339
describe their API really really well so

00:12:01,240 --> 00:12:04,899
as a programmer like maybe you start to

00:12:03,339 --> 00:12:07,269
break it down right there is a pretty

00:12:04,899 --> 00:12:08,829
repeatable structure here all right

00:12:07,269 --> 00:12:11,589
maybe we notice that there's a list of

00:12:08,829 --> 00:12:13,420
actions over here on the left maybe we

00:12:11,589 --> 00:12:15,189
you know we get out our scraper and we

00:12:13,420 --> 00:12:16,329
start breaking down the Dom and we

00:12:15,189 --> 00:12:18,339
noticed that all right well there's a

00:12:16,329 --> 00:12:19,809
method and there's some paths and I

00:12:18,339 --> 00:12:22,120
could probably like write a little bit

00:12:19,809 --> 00:12:23,649
of a maybe split the string on certain

00:12:22,120 --> 00:12:26,559
characters and extract the parameters

00:12:23,649 --> 00:12:29,259
and eventually you'll work your way to

00:12:26,559 --> 00:12:32,439
something like this and from this like

00:12:29,259 --> 00:12:35,589
JSON we can all probably rice in a very

00:12:32,439 --> 00:12:37,870
nice autocompletes tool but that was a

00:12:35,589 --> 00:12:39,579
lot of work to go from those beautiful

00:12:37,870 --> 00:12:42,579
doc despite how beautiful they were it's

00:12:39,579 --> 00:12:45,639
still a lot of work whereas if you're

00:12:42,579 --> 00:12:47,499
dudes the alternative it would look like

00:12:45,639 --> 00:12:50,050
this right you would start with that

00:12:47,499 --> 00:12:52,329
computer readable version if your goal

00:12:50,050 --> 00:12:53,290
was to write an autocomplete tool you

00:12:52,329 --> 00:12:56,679
would start with the thing that was

00:12:53,290 --> 00:12:58,509
computer readable but the documents

00:12:56,679 --> 00:13:00,670
would naturally come out of that you

00:12:58,509 --> 00:13:04,959
could naturally generate these beautiful

00:13:00,670 --> 00:13:07,689
documents and I think that this affects

00:13:04,959 --> 00:13:10,089
us in so many different areas of our

00:13:07,689 --> 00:13:12,490
data life our day to day life and we're

00:13:10,089 --> 00:13:14,319
so numb to the pain it's hard to even

00:13:12,490 --> 00:13:17,589
notice at times we just go through the

00:13:14,319 --> 00:13:18,320
same motions the same manual labor again

00:13:17,589 --> 00:13:21,079
and a

00:13:18,320 --> 00:13:24,560
and again things like integration

00:13:21,079 --> 00:13:27,680
analytics documentation testing mocking

00:13:24,560 --> 00:13:30,529
on and on and on let me talk a little

00:13:27,680 --> 00:13:33,079
bit about integration an integration by

00:13:30,529 --> 00:13:36,139
its very nature is meant for two

00:13:33,079 --> 00:13:40,009
computers to talk to each other that is

00:13:36,139 --> 00:13:42,470
the entire goal of integration and yet

00:13:40,009 --> 00:13:45,410
whenever we write our api's we write

00:13:42,470 --> 00:13:47,180
them for a human right we'd write them

00:13:45,410 --> 00:13:50,930
so that a human can come and read the

00:13:47,180 --> 00:13:52,930
API instead like what we should be doing

00:13:50,930 --> 00:13:55,519
is probably writing for the computer

00:13:52,930 --> 00:13:57,560
because whenever you write for a human I

00:13:55,519 --> 00:14:00,889
can actually see how you do pagination

00:13:57,560 --> 00:14:02,420
in your API that's great right

00:14:00,889 --> 00:14:03,620
pagination how many different pagination

00:14:02,420 --> 00:14:06,620
strategies are there really

00:14:03,620 --> 00:14:09,199
maybe there's page based offset base

00:14:06,620 --> 00:14:13,069
cursor based I can't think of too many

00:14:09,199 --> 00:14:15,019
more the amazing thing though is despite

00:14:13,069 --> 00:14:18,980
how few different patterns there are

00:14:15,019 --> 00:14:21,970
there is no one Universal pagination

00:14:18,980 --> 00:14:27,170
client there's no getting me more

00:14:21,970 --> 00:14:29,569
resources client because every endpoint

00:14:27,170 --> 00:14:31,190
is basically human oriented and so the

00:14:29,569 --> 00:14:33,139
computer cannot figure out they can't

00:14:31,190 --> 00:14:34,730
derive what are the parameters that goes

00:14:33,139 --> 00:14:36,620
into your pagination what are the

00:14:34,730 --> 00:14:38,660
sorting parameters what are the the

00:14:36,620 --> 00:14:41,990
offsets that doesn't whatever it is if

00:14:38,660 --> 00:14:44,389
you put it into a form that a universal

00:14:41,990 --> 00:14:46,240
pagination client could use then

00:14:44,389 --> 00:14:50,360
suddenly we don't need to write

00:14:46,240 --> 00:14:55,670
pagination logic one-off bespoke every

00:14:50,360 --> 00:14:57,769
single time rate limits is another

00:14:55,670 --> 00:15:00,920
really big one raise your hand if you

00:14:57,769 --> 00:15:03,380
have ever dealt with rate limits in some

00:15:00,920 --> 00:15:06,319
way like say the Twitter API or anything

00:15:03,380 --> 00:15:08,810
like that so rate limits I think are

00:15:06,319 --> 00:15:11,420
actually phenomenally difficult they're

00:15:08,810 --> 00:15:14,120
quite esoteric how to handle with them

00:15:11,420 --> 00:15:16,370
properly because of how difficult they

00:15:14,120 --> 00:15:18,050
are so let's say that you're writing a

00:15:16,370 --> 00:15:20,600
little tool for Twitter and what you

00:15:18,050 --> 00:15:22,750
want to do is to reach into Twitter and

00:15:20,600 --> 00:15:25,100
pull out a list of all of your tweets

00:15:22,750 --> 00:15:29,480
Twitter I believe limit you to something

00:15:25,100 --> 00:15:31,939
like a hundred API calls per hour what's

00:15:29,480 --> 00:15:34,429
going to happen is you'll hit

00:15:31,939 --> 00:15:36,079
that rate limit error and now you're

00:15:34,429 --> 00:15:37,879
going to have to reach into at the time

00:15:36,079 --> 00:15:39,619
you make an API call you're gonna have

00:15:37,879 --> 00:15:41,059
to look at the results and rather than

00:15:39,619 --> 00:15:42,919
just expecting data to be there you have

00:15:41,059 --> 00:15:44,149
to check for an error and you have to

00:15:42,919 --> 00:15:46,129
check for the class of an error is it a

00:15:44,149 --> 00:15:47,720
rate limit error so now you're in the

00:15:46,129 --> 00:15:50,209
rate limits world and what do you do

00:15:47,720 --> 00:15:52,639
right so the typical thing is just

00:15:50,209 --> 00:15:55,369
exponential back-off it's easy enough to

00:15:52,639 --> 00:15:58,279
think about but exponential back-off is

00:15:55,369 --> 00:16:00,439
a non-local thing right I suddenly have

00:15:58,279 --> 00:16:02,539
to restructure my entire code to figure

00:16:00,439 --> 00:16:04,999
out how to accommodate the execution

00:16:02,539 --> 00:16:06,559
strategy that the server wants because

00:16:04,999 --> 00:16:09,019
the server is not communicating to my

00:16:06,559 --> 00:16:12,139
client in a way where the clients knows

00:16:09,019 --> 00:16:14,119
how to just back off and this actually

00:16:12,139 --> 00:16:16,279
gets really really bad if you have more

00:16:14,119 --> 00:16:18,379
than one process or more than one worker

00:16:16,279 --> 00:16:19,879
or you have a user who's using this at

00:16:18,379 --> 00:16:21,289
the same time as one of your workers

00:16:19,879 --> 00:16:23,749
because now you actually have the

00:16:21,289 --> 00:16:26,059
coordinates that back off across all

00:16:23,749 --> 00:16:27,889
these different non-local sources you

00:16:26,059 --> 00:16:30,169
now need to centralize and rate limit on

00:16:27,889 --> 00:16:31,909
your own side so this is a phenomenally

00:16:30,169 --> 00:16:33,769
difficult thing that should be pushed

00:16:31,909 --> 00:16:35,599
down into the system we should

00:16:33,769 --> 00:16:39,349
absolutely be teaching computers how to

00:16:35,599 --> 00:16:40,999
handle rate limits another one I think

00:16:39,349 --> 00:16:46,099
is really interesting is API analytics

00:16:40,999 --> 00:16:48,289
so as a provider of an API how much do

00:16:46,099 --> 00:16:51,199
you actually know about its usage right

00:16:48,289 --> 00:16:53,239
in with a REST API for example at best

00:16:51,199 --> 00:16:56,569
you probably know that some routes are

00:16:53,239 --> 00:16:59,509
more popular than others but actually

00:16:56,569 --> 00:17:01,159
let's say that you go into one of your

00:16:59,509 --> 00:17:03,439
endpoints and you decide that you want

00:17:01,159 --> 00:17:05,120
to remove a field we're gonna make a

00:17:03,439 --> 00:17:07,459
breaking change in some way or maybe

00:17:05,120 --> 00:17:09,919
even you found out that the field had a

00:17:07,459 --> 00:17:11,360
bug and you what you want to do is go

00:17:09,919 --> 00:17:14,240
and tell all of the people who were

00:17:11,360 --> 00:17:15,620
affected that they should check the

00:17:14,240 --> 00:17:19,399
validity of the data maybe they should

00:17:15,620 --> 00:17:21,559
research some new data if you don't have

00:17:19,399 --> 00:17:23,839
a good understanding of how your API is

00:17:21,559 --> 00:17:26,360
being used your only option is basically

00:17:23,839 --> 00:17:28,730
to email everyone and say hey we messed

00:17:26,360 --> 00:17:31,159
up but maybe there are only three

00:17:28,730 --> 00:17:33,379
clients who are affected by that it

00:17:31,159 --> 00:17:35,059
would be much much better if the

00:17:33,379 --> 00:17:35,659
computer could tell you don't worry

00:17:35,059 --> 00:17:38,809
about it

00:17:35,659 --> 00:17:41,210
it's only these three clients if the

00:17:38,809 --> 00:17:44,029
computer is able to read the usage

00:17:41,210 --> 00:17:46,600
patterns of your API the computer can

00:17:44,029 --> 00:17:49,580
help you in these cases

00:17:46,600 --> 00:17:50,960
it can even do things I think like if

00:17:49,580 --> 00:17:53,390
you know which fields are being used by

00:17:50,960 --> 00:17:55,340
which clients it can go it can make it

00:17:53,390 --> 00:17:57,050
so that you could actually help them

00:17:55,340 --> 00:17:59,180
migrate whenever you make a breaking

00:17:57,050 --> 00:18:01,640
change automatically so rather than just

00:17:59,180 --> 00:18:04,100
telling them hey this code is about the

00:18:01,640 --> 00:18:06,190
code that you have is going to break you

00:18:04,100 --> 00:18:10,370
know December 12th

00:18:06,190 --> 00:18:12,050
good luck what would be better is I see

00:18:10,370 --> 00:18:14,300
that you're using these four fields

00:18:12,050 --> 00:18:15,920
these three are being deprecated they've

00:18:14,300 --> 00:18:17,990
moved over here this is the new way to

00:18:15,920 --> 00:18:20,540
do it and in fact here's a function that

00:18:17,990 --> 00:18:24,130
will rewrite your data dependencies as

00:18:20,540 --> 00:18:24,130
much as possible

00:18:25,630 --> 00:18:30,760
documentation is one you know right

00:18:27,560 --> 00:18:33,950
there are lies there are damn lies and

00:18:30,760 --> 00:18:37,730
then there's API documentation right

00:18:33,950 --> 00:18:41,060
like they are so rarely in sync with the

00:18:37,730 --> 00:18:43,330
actual implementation because again they

00:18:41,060 --> 00:18:46,460
are written by humans for humans and

00:18:43,330 --> 00:18:51,410
they should be written for computers to

00:18:46,460 --> 00:18:52,520
then write for humans and you can even

00:18:51,410 --> 00:18:54,950
do things if you could combine these two

00:18:52,520 --> 00:18:57,710
different ideas right whenever I am

00:18:54,950 --> 00:19:01,940
reading your API documentation I'm

00:18:57,710 --> 00:19:06,400
basically at point X and my goal is to

00:19:01,940 --> 00:19:09,680
get to point Z that's all I want to do

00:19:06,400 --> 00:19:12,460
anything else is a distraction the

00:19:09,680 --> 00:19:14,930
faster you can get me there the better

00:19:12,460 --> 00:19:18,710
so if you could take that computer

00:19:14,930 --> 00:19:21,350
understanding of API usage you could say

00:19:18,710 --> 00:19:24,380
we actually know that people like you or

00:19:21,350 --> 00:19:26,750
early users typically 90 percent of them

00:19:24,380 --> 00:19:29,240
want to do this we're actually gonna

00:19:26,750 --> 00:19:31,580
prioritize this automatically changing

00:19:29,240 --> 00:19:38,150
over time based off of the usage so that

00:19:31,580 --> 00:19:40,600
we best serve our users discoverability

00:19:38,150 --> 00:19:44,930
just helping me know what's available

00:19:40,600 --> 00:19:47,180
mocking is another one if you - if you

00:19:44,930 --> 00:19:50,690
describe what the shape of your data is

00:19:47,180 --> 00:19:53,870
to a computer then a computer can just

00:19:50,690 --> 00:19:57,960
generate some dummy data I don't have to

00:19:53,870 --> 00:20:00,149
write any mocking logic it's really nice

00:19:57,960 --> 00:20:02,490
and language-specific clients I actually

00:20:00,149 --> 00:20:05,330
think are a symptom of this ultimately

00:20:02,490 --> 00:20:09,860
the fact that there is a github node

00:20:05,330 --> 00:20:14,279
clients a github ruby clients is madness

00:20:09,860 --> 00:20:17,090
how much work is wasted is overlapping

00:20:14,279 --> 00:20:20,130
because there is not a sufficient

00:20:17,090 --> 00:20:22,679
description of the underlying API to

00:20:20,130 --> 00:20:28,440
generate these clients and then add a

00:20:22,679 --> 00:20:29,850
nice human layer at the top so I want to

00:20:28,440 --> 00:20:32,029
show a quick demo of what that would

00:20:29,850 --> 00:20:32,029
look like

00:20:32,299 --> 00:20:37,919
so this is actually written by a friend

00:20:35,370 --> 00:20:39,570
of mine so this is how many of you are

00:20:37,919 --> 00:20:45,270
familiar richer and if you are not

00:20:39,570 --> 00:20:46,730
familiar with Google everyone okay yeah

00:20:45,270 --> 00:20:49,080
so most people not familiar with Google

00:20:46,730 --> 00:20:52,230
Google is this really cool idea in

00:20:49,080 --> 00:20:55,830
Haskell because Haskell forces its users

00:20:52,230 --> 00:20:58,710
to describe in detail a lot of the

00:20:55,830 --> 00:21:01,169
different aspects of the language of the

00:20:58,710 --> 00:21:03,620
libraries and so you can generate really

00:21:01,169 --> 00:21:07,140
cool tooling and you can say for example

00:21:03,620 --> 00:21:09,299
inside of this library I have a list of

00:21:07,140 --> 00:21:11,220
integers and I want to get one integer

00:21:09,299 --> 00:21:13,980
what are the different functions that

00:21:11,220 --> 00:21:18,929
could do that for me this is a similar

00:21:13,980 --> 00:21:22,549
idea so Ram des and date if NS date

00:21:18,929 --> 00:21:25,890
functions they have good documentation

00:21:22,549 --> 00:21:27,779
but they are bespoke the work that when

00:21:25,890 --> 00:21:30,539
interim des did not help date functions

00:21:27,779 --> 00:21:34,679
and even with that set of documentation

00:21:30,539 --> 00:21:38,149
there's not a tooling like cool so this

00:21:34,679 --> 00:21:40,950
idea here is that I have a new date and

00:21:38,149 --> 00:21:42,659
I want to get true show me all the

00:21:40,950 --> 00:21:46,529
different functions inside of this

00:21:42,659 --> 00:21:48,750
library that could do that or maybe I

00:21:46,529 --> 00:21:53,399
want to stay for example I have a list

00:21:48,750 --> 00:21:56,399
of four items and the result should be

00:21:53,399 --> 00:21:58,770
four and it can just evaluate it and say

00:21:56,399 --> 00:22:00,630
this is where you're starting from this

00:21:58,770 --> 00:22:04,169
is your destination these are the

00:22:00,630 --> 00:22:06,389
possible paths this is such a better way

00:22:04,169 --> 00:22:08,730
if you describe to the computer how your

00:22:06,389 --> 00:22:11,610
programming works the computer can help

00:22:08,730 --> 00:22:13,860
you how often have we been sitting

00:22:11,610 --> 00:22:15,299
a JavaScript library thinking I don't

00:22:13,860 --> 00:22:16,380
know how to get that kind of object I

00:22:15,299 --> 00:22:18,240
don't know what you want

00:22:16,380 --> 00:22:20,520
like what are the intervening steps to

00:22:18,240 --> 00:22:22,770
get there just tell me I'll do it if you

00:22:20,520 --> 00:22:28,410
tell me so we should make it so that the

00:22:22,770 --> 00:22:30,809
computers can tell us and this is not a

00:22:28,410 --> 00:22:33,440
super new idea you know we've seen this

00:22:30,809 --> 00:22:36,179
with soap versus rest I think probably

00:22:33,440 --> 00:22:38,040
not so many people have had a chance to

00:22:36,179 --> 00:22:41,220
work with soap these days soap was

00:22:38,040 --> 00:22:43,740
really good at being descriptive you

00:22:41,220 --> 00:22:45,720
could generate clients automatically for

00:22:43,740 --> 00:22:49,020
any language from the description of the

00:22:45,720 --> 00:22:51,270
API the problem was it was also very

00:22:49,020 --> 00:22:54,450
very heavy heavy weight and so you

00:22:51,270 --> 00:22:56,190
basically had to generate clients and so

00:22:54,450 --> 00:22:58,460
there's you know there is a master's

00:22:56,190 --> 00:23:01,140
thesis I believe that rest is based on

00:22:58,460 --> 00:23:04,500
but the rest that most of us have used

00:23:01,140 --> 00:23:05,970
is not that it is actually I think a bit

00:23:04,500 --> 00:23:08,160
more of a reaction against kind of the

00:23:05,970 --> 00:23:11,040
heavy weight prescriptive nature of soap

00:23:08,160 --> 00:23:13,440
and so we wanted to use JSON we want to

00:23:11,040 --> 00:23:15,270
move much more quickly we could do a lot

00:23:13,440 --> 00:23:17,970
of you know convention over

00:23:15,270 --> 00:23:20,820
configuration and you know in many ways

00:23:17,970 --> 00:23:24,240
it did help us in many ways it is much

00:23:20,820 --> 00:23:26,669
much more fun to work with the problem

00:23:24,240 --> 00:23:29,100
was in the transition computers

00:23:26,669 --> 00:23:33,260
basically have no ability to read

00:23:29,100 --> 00:23:35,610
anything about your REST API at best

00:23:33,260 --> 00:23:38,640
there's some general pattern that you're

00:23:35,610 --> 00:23:41,970
hopefully following that you can use to

00:23:38,640 --> 00:23:43,860
as generate some of your tools and this

00:23:41,970 --> 00:23:49,620
will keep repeating itself so there's AA

00:23:43,860 --> 00:23:52,049
data versus graph QL RPC vs. sequel so I

00:23:49,620 --> 00:23:55,230
want to show two more demos getting to

00:23:52,049 --> 00:23:58,890
the end of the talk I actually think

00:23:55,230 --> 00:24:02,809
that we can generate such good tooling

00:23:58,890 --> 00:24:06,390
like Google much better documentation

00:24:02,809 --> 00:24:08,910
much better developer experiences that

00:24:06,390 --> 00:24:11,730
it actually can be dangerous so I will

00:24:08,910 --> 00:24:16,760
show you a demo of a tool called

00:24:11,730 --> 00:24:20,190
graphical so graphical is pretty amazing

00:24:16,760 --> 00:24:22,890
it actually allows you to points at any

00:24:20,190 --> 00:24:25,200
graph QL server and it will generate

00:24:22,890 --> 00:24:25,560
autocomplete for you in a beautiful way

00:24:25,200 --> 00:24:27,960
so

00:24:25,560 --> 00:24:29,580
I can explore any server then come in

00:24:27,960 --> 00:24:31,800
here and I get autocomplete at any

00:24:29,580 --> 00:24:32,970
different level so I can say maybe I

00:24:31,800 --> 00:24:35,100
want to go into the github

00:24:32,970 --> 00:24:39,060
what does github have I see they have

00:24:35,100 --> 00:24:42,390
maybe a repo and I CV I get autocomplete

00:24:39,060 --> 00:24:44,730
for the different arguments that it

00:24:42,390 --> 00:24:46,980
takes I'm gonna come in here maybe pull

00:24:44,730 --> 00:24:49,080
out a repo and I'm not sure what its

00:24:46,980 --> 00:24:50,880
gonna return but it knows that it's

00:24:49,080 --> 00:24:53,550
syntactically incorrect I can see that

00:24:50,880 --> 00:24:57,420
if I hover over it it tells me that I

00:24:53,550 --> 00:24:59,430
get documentation in line right because

00:24:57,420 --> 00:25:01,680
it's able to introspect the API it's

00:24:59,430 --> 00:25:04,590
such a deep level it can provide amazing

00:25:01,680 --> 00:25:08,280
tooling imagine trying to overlay this

00:25:04,590 --> 00:25:10,650
level of tooling on your REST API how

00:25:08,280 --> 00:25:12,180
much work would it take how much work

00:25:10,650 --> 00:25:17,070
would you have to do if you took it to

00:25:12,180 --> 00:25:19,800
the next REST API in fact we can do

00:25:17,070 --> 00:25:22,710
really cool things this is my favorite

00:25:19,800 --> 00:25:27,150
way to explore API is now so this is a

00:25:22,710 --> 00:25:28,620
visual tree so I work at one graph it is

00:25:27,150 --> 00:25:30,810
a graph QL wrapper around lots of

00:25:28,620 --> 00:25:32,730
different services and the thing is the

00:25:30,810 --> 00:25:35,670
majority of our users don't actually

00:25:32,730 --> 00:25:38,190
have no graph QL because the very first

00:25:35,670 --> 00:25:39,450
thing they do is they come in here they

00:25:38,190 --> 00:25:42,450
open up the Explorer and they start to

00:25:39,450 --> 00:25:44,880
see what's available so for example site

00:25:42,450 --> 00:25:45,840
site has beautiful documentation but

00:25:44,880 --> 00:25:47,970
maybe I just want to see what's

00:25:45,840 --> 00:25:49,560
available isn't like a mutation and I

00:25:47,970 --> 00:25:51,090
see I can purchase a domain in here I

00:25:49,560 --> 00:25:53,040
can just kind of like click my way

00:25:51,090 --> 00:25:55,020
through as though it were like a file

00:25:53,040 --> 00:25:57,510
system or something I can fill out the

00:25:55,020 --> 00:26:05,370
arguments I'm gonna buy let's say

00:25:57,510 --> 00:26:08,130
reactive comm 2018 demo comm and success

00:26:05,370 --> 00:26:09,270
and I'll just run that and it's gonna

00:26:08,130 --> 00:26:11,520
take a little while because it's

00:26:09,270 --> 00:26:14,190
actually negotiating through zase sites

00:26:11,520 --> 00:26:15,870
API to buy an upstream domain but I will

00:26:14,190 --> 00:26:20,550
actually soon be the proud owner

00:26:15,870 --> 00:26:22,740
I hope of reactive conf 2018 and as a

00:26:20,550 --> 00:26:24,870
developer this is a phenomenal

00:26:22,740 --> 00:26:27,000
experience right being able to actually

00:26:24,870 --> 00:26:31,470
explore and interact with an API like

00:26:27,000 --> 00:26:34,230
this is unprecedented Doc's are dead

00:26:31,470 --> 00:26:36,260
things it takes a lot of work to turn a

00:26:34,230 --> 00:26:38,280
document that I'm reading about your API

00:26:36,260 --> 00:26:39,210
into a thing where that I can actually

00:26:38,280 --> 00:26:42,840
try

00:26:39,210 --> 00:26:51,510
so now I own reactive coffee 2013 demo

00:26:42,840 --> 00:26:53,220
calm dark 2018 I think so I want to

00:26:51,510 --> 00:26:55,470
highlight that this is such a good

00:26:53,220 --> 00:26:58,080
experience for developers that actually

00:26:55,470 --> 00:27:00,390
there's a bit of an uncanny valley you

00:26:58,080 --> 00:27:04,740
want to be careful again there is a

00:27:00,390 --> 00:27:07,020
place for a human readable layer and I'm

00:27:04,740 --> 00:27:10,980
going to show you this is what the

00:27:07,020 --> 00:27:12,450
actual site domain experience is like so

00:27:10,980 --> 00:27:15,290
hobby I think worked on this quite a bit

00:27:12,450 --> 00:27:17,730
he was speaking here yesterday I believe

00:27:15,290 --> 00:27:23,790
but I'm gonna come in here and say

00:27:17,730 --> 00:27:25,740
reacted conf 2018 and it's gonna as I

00:27:23,790 --> 00:27:28,920
scroll it's checking several hundred

00:27:25,740 --> 00:27:31,680
different domain TLDs the design is

00:27:28,920 --> 00:27:34,350
beautiful it's very efficient right if I

00:27:31,680 --> 00:27:36,180
were to do this inside of that you know

00:27:34,350 --> 00:27:41,520
demo I showed you it would take a long

00:27:36,180 --> 00:27:43,620
time to check 600 different TLDs so I'm

00:27:41,520 --> 00:27:46,230
not saying that we should build tooling

00:27:43,620 --> 00:27:49,080
to generate UI to actually ship to

00:27:46,230 --> 00:27:51,510
end-users it's in arguable that this is

00:27:49,080 --> 00:27:55,350
an infinitely better experience than

00:27:51,510 --> 00:27:58,800
clicking around inside of graphical but

00:27:55,350 --> 00:28:04,770
as developers that experience is still

00:27:58,800 --> 00:28:06,840
incredibly valuable so I'm gonna have

00:28:04,770 --> 00:28:08,370
one last demo and I want to kind of do

00:28:06,840 --> 00:28:11,510
it so in a way that just brings together

00:28:08,370 --> 00:28:15,360
all these ideas to emphasize how much

00:28:11,510 --> 00:28:19,800
manual work we do that could potentially

00:28:15,360 --> 00:28:22,260
be automated and this is incredibly beta

00:28:19,800 --> 00:28:24,600
this is not ready for production at all

00:28:22,260 --> 00:28:26,130
the team has been working like mad for

00:28:24,600 --> 00:28:28,350
the past couple of days I literally just

00:28:26,130 --> 00:28:30,750
got it working two minutes before coming

00:28:28,350 --> 00:28:33,410
onstage so this is beta it could break

00:28:30,750 --> 00:28:36,630
in some ways but I want to show the idea

00:28:33,410 --> 00:28:39,180
notice here in particular the importance

00:28:36,630 --> 00:28:42,000
of being able to compose all of these

00:28:39,180 --> 00:28:44,270
different ideas as an end user very very

00:28:42,000 --> 00:28:44,270
quickly

00:28:49,669 --> 00:28:56,899
okay so this is similar to the graphical

00:28:54,109 --> 00:29:01,070
demo but I have this little test mode

00:28:56,899 --> 00:29:03,829
thing so I can run it and this stock

00:29:01,070 --> 00:29:06,889
demo it's gonna go and you know get the

00:29:03,829 --> 00:29:10,070
current stock price of Apple I can look

00:29:06,889 --> 00:29:11,479
and see what is that data but it's in

00:29:10,070 --> 00:29:13,579
test mode so it's actually not going to

00:29:11,479 --> 00:29:16,969
hit production it's gonna mock all of

00:29:13,579 --> 00:29:20,539
the data for me automatically so the

00:29:16,969 --> 00:29:21,679
symbol is obviously not hello world but

00:29:20,539 --> 00:29:24,289
this is enough for me to actually

00:29:21,679 --> 00:29:27,200
experiment with with my code maybe I

00:29:24,289 --> 00:29:29,149
don't want to hit the production yet

00:29:27,200 --> 00:29:31,369
maybe I don't want to actually purchase

00:29:29,149 --> 00:29:32,419
a domain on every keystroke but I do

00:29:31,369 --> 00:29:33,529
want to know if I'm writing an

00:29:32,419 --> 00:29:33,889
application that does something like

00:29:33,529 --> 00:29:35,809
that

00:29:33,889 --> 00:29:38,799
I wanted feedback as immediately as

00:29:35,809 --> 00:29:41,859
possible so what I'm gonna do here is

00:29:38,799 --> 00:29:45,129
actually start to chain these together

00:29:41,859 --> 00:29:48,950
so there's this idea of subscriptions in

00:29:45,129 --> 00:29:51,559
graph QL so I'm gonna say that I want to

00:29:48,950 --> 00:29:53,149
subscribe to Twilio and while I like

00:29:51,559 --> 00:29:55,369
typing I think I'm gonna open this up

00:29:53,149 --> 00:29:59,499
and just now get through here so I'm

00:29:55,369 --> 00:30:03,529
gonna go into truly oh sorry uh Coolio

00:29:59,499 --> 00:30:07,339
I'm gonna do a web hook URL the idea

00:30:03,529 --> 00:30:09,919
here is that for the subscription every

00:30:07,339 --> 00:30:11,629
time that I get a new SMS I want you to

00:30:09,919 --> 00:30:14,389
post the results of this to that web

00:30:11,629 --> 00:30:17,119
book URL so I can debug it but I also

00:30:14,389 --> 00:30:21,109
want to get the information about the

00:30:17,119 --> 00:30:22,969
SMS so given the SMS I want the body I

00:30:21,109 --> 00:30:25,519
want to know who it was from and who it

00:30:22,969 --> 00:30:33,769
was sent to in this case I'm gonna go

00:30:25,519 --> 00:30:36,769
look at my Twilio number all right so

00:30:33,769 --> 00:30:38,690
this subscription is now set up so that

00:30:36,769 --> 00:30:41,899
it's going to automatically get called

00:30:38,690 --> 00:30:46,729
every single time this phone number gets

00:30:41,899 --> 00:30:48,739
an SMS and the idea is like maybe now

00:30:46,729 --> 00:30:51,769
what we want to do is act on that in

00:30:48,739 --> 00:30:54,859
some way so I say that I'm actually

00:30:51,769 --> 00:30:59,509
going to go into sites where I have a

00:30:54,859 --> 00:31:02,200
lot of my domains so I'm gonna give them

00:30:59,509 --> 00:31:02,200
a title real quick

00:31:04,520 --> 00:31:15,020
Twilio coming ass mess too from and body

00:31:15,200 --> 00:31:22,760
I'm going to give this a name Giulio SMS

00:31:18,380 --> 00:31:25,529
open up a new one I call this site

00:31:22,760 --> 00:31:28,320
domains what I'm going to do is go into

00:31:25,529 --> 00:31:30,240
Zeit I'm going to get a list of my

00:31:28,320 --> 00:31:32,250
domains so these are all the domains

00:31:30,240 --> 00:31:33,360
that have already purchased and for each

00:31:32,250 --> 00:31:36,840
of the domains I'm gonna get the name

00:31:33,360 --> 00:31:38,669
and when I bought it but what I'm

00:31:36,840 --> 00:31:43,049
actually gonna do is make it so that

00:31:38,669 --> 00:31:46,590
this takes a variable and do domain name

00:31:43,049 --> 00:31:49,470
it's a required string and I want to

00:31:46,590 --> 00:31:53,549
know is this domain available so that's

00:31:49,470 --> 00:31:55,289
gonna be a domain name and get whether

00:31:53,549 --> 00:31:57,360
or not it's available and while we're at

00:31:55,289 --> 00:32:01,950
it in case it is available I want to

00:31:57,360 --> 00:32:03,419
know the price of it good so I can click

00:32:01,950 --> 00:32:04,559
through that and now what I want to do

00:32:03,419 --> 00:32:06,510
is actually tie these two things

00:32:04,559 --> 00:32:11,490
together so I'm gonna say that this site

00:32:06,510 --> 00:32:13,049
domains relies on the Twilio SMS and as

00:32:11,490 --> 00:32:16,590
I come in here again remember this is

00:32:13,049 --> 00:32:24,020
all just mocked out and so I'm gonna say

00:32:16,590 --> 00:32:40,230
that I want to return the Twilio SMS

00:32:24,020 --> 00:32:46,230
data dot data Twilio c Twilio that's

00:32:40,230 --> 00:32:49,620
incoming SMS dot from our body so now

00:32:46,230 --> 00:32:51,779
what I can do is the text from the

00:32:49,620 --> 00:32:54,090
Twitter SMS is going to flow into this

00:32:51,779 --> 00:32:58,020
variable and it's gonna go and execute

00:32:54,090 --> 00:33:01,260
this domains query and if the domain is

00:32:58,020 --> 00:33:05,899
available what I'm gonna do is actually

00:33:01,260 --> 00:33:05,899
tie this in into now whoops

00:33:07,460 --> 00:33:13,110
alright so we'll just skip through that

00:33:10,520 --> 00:33:14,970
so we can actually tie that into it so

00:33:13,110 --> 00:33:16,240
imagine that's still there but we can

00:33:14,970 --> 00:33:20,080
tie that into a github

00:33:16,240 --> 00:33:23,230
a repository now so same idea I actually

00:33:20,080 --> 00:33:29,230
want to go into github and given the

00:33:23,230 --> 00:33:34,929
domain name I want to do a github create

00:33:29,230 --> 00:33:37,179
a repository and the input is going to

00:33:34,929 --> 00:33:40,320
be the name of this repository is the

00:33:37,179 --> 00:33:43,390
thing that I text it in from SMS and

00:33:40,320 --> 00:33:51,070
I'll just get the project the repository

00:33:43,390 --> 00:33:52,960
ID the next thing I would want to do is

00:33:51,070 --> 00:33:56,820
go into the site and actually do a

00:33:52,960 --> 00:33:59,590
mutation here some site allows you to do

00:33:56,820 --> 00:34:05,530
to create deploys so what I'm going to

00:33:59,590 --> 00:34:06,760
do is actually purchase the domain the

00:34:05,530 --> 00:34:10,690
expected price is going to be the domain

00:34:06,760 --> 00:34:15,580
price that we saw earlier and it's going

00:34:10,690 --> 00:34:16,770
to be the domain name and we'll get

00:34:15,580 --> 00:34:19,840
whether or not it was successful now

00:34:16,770 --> 00:34:26,379
again I'm gonna run over here and we'll

00:34:19,840 --> 00:34:27,940
do another mutation in site and what I

00:34:26,379 --> 00:34:30,429
want to do is actually create a

00:34:27,940 --> 00:34:33,750
deployment and this is pretty cool the

00:34:30,429 --> 00:34:36,940
way you can do this you can actually say

00:34:33,750 --> 00:34:39,730
that I want to upload a file directly

00:34:36,940 --> 00:34:42,639
from this query so the project name is

00:34:39,730 --> 00:34:47,320
going to be the same domain name and the

00:34:42,639 --> 00:34:52,750
list of files is this and the file is

00:34:47,320 --> 00:35:00,040
going to be index.html and the data is

00:34:52,750 --> 00:35:01,720
going to be welcome and we'll get the

00:35:00,040 --> 00:35:08,310
idea and the ready States in case we

00:35:01,720 --> 00:35:10,840
need it later and finally I'm going to

00:35:08,310 --> 00:35:13,230
associate that domain I just bought this

00:35:10,840 --> 00:35:13,230
in mutation

00:35:19,450 --> 00:35:24,589
so we'll alias the deployment that we

00:35:22,160 --> 00:35:31,520
just created the deploy ID will come

00:35:24,589 --> 00:35:34,700
from the previous query and the alias is

00:35:31,520 --> 00:35:37,300
going to be the domain name that we had

00:35:34,700 --> 00:35:40,250
earlier and we'll get the UID

00:35:37,300 --> 00:35:44,089
and now we're almost finished we have a

00:35:40,250 --> 00:35:46,520
pipeline where from a text SMS I can

00:35:44,089 --> 00:35:47,180
text it it'll go and see if a domain is

00:35:46,520 --> 00:35:49,820
available

00:35:47,180 --> 00:35:52,310
it'll buy it it'll create a github

00:35:49,820 --> 00:35:54,650
project for me automatically it'll

00:35:52,310 --> 00:35:56,330
create a site's deployment with a

00:35:54,650 --> 00:35:59,300
default index at HTML

00:35:56,330 --> 00:36:07,640
it'll associate that domain and now the

00:35:59,300 --> 00:36:08,619
last step is to send a reply so we want

00:36:07,640 --> 00:36:13,130
to go into

00:36:08,619 --> 00:36:16,310
Tullio send a message well what we do is

00:36:13,130 --> 00:36:19,790
we'd send it back to the original from

00:36:16,310 --> 00:36:21,530
in the original query and the idea is

00:36:19,790 --> 00:36:23,480
you know although this is like I said

00:36:21,530 --> 00:36:24,349
super beta and the UI needs a lot of

00:36:23,480 --> 00:36:27,740
work and whatnot

00:36:24,349 --> 00:36:29,950
the idea is a lot of the applications

00:36:27,740 --> 00:36:32,180
that I have built over the past 10 years

00:36:29,950 --> 00:36:34,670
could be built in something like this

00:36:32,180 --> 00:36:38,570
with a computer helping me in about five

00:36:34,670 --> 00:36:41,150
minutes there is so much work that I do

00:36:38,570 --> 00:36:44,330
that I would much rather the computer

00:36:41,150 --> 00:36:47,930
does so I have a final call to action

00:36:44,330 --> 00:36:50,690
for you here please please start making

00:36:47,930 --> 00:36:53,869
your api's self documenting and self

00:36:50,690 --> 00:36:56,900
describing whenever you are writing Docs

00:36:53,869 --> 00:36:59,359
for a human maybe start with data

00:36:56,900 --> 00:37:01,820
instead start with something that the

00:36:59,359 --> 00:37:03,440
computer can read and see if you can

00:37:01,820 --> 00:37:07,640
generate those Doc's that you were going

00:37:03,440 --> 00:37:09,020
to write and then once you've started

00:37:07,640 --> 00:37:10,849
doing that you can take a look at

00:37:09,020 --> 00:37:12,470
actually how many tools exists what are

00:37:10,849 --> 00:37:14,510
the pros and cons of the tools that are

00:37:12,470 --> 00:37:18,230
out there already that do this things

00:37:14,510 --> 00:37:20,660
like swagger or I would recommend just

00:37:18,230 --> 00:37:23,720
use graph QL in which case I can just

00:37:20,660 --> 00:37:26,359
point my service at it or anyone can

00:37:23,720 --> 00:37:27,589
point to their graphical at it and I can

00:37:26,359 --> 00:37:30,650
compose all those different ideas

00:37:27,589 --> 00:37:32,450
together in a way that is not possible

00:37:30,650 --> 00:37:37,510
if it's only

00:37:32,450 --> 00:37:37,510
for humans thank you

00:37:37,740 --> 00:37:43,630
[Applause]

00:37:44,930 --> 00:37:50,130
well that was frightening ly impressive

00:37:47,690 --> 00:37:51,570
all right so we have time for some

00:37:50,130 --> 00:37:54,119
questions I'm not sure we don't have a

00:37:51,570 --> 00:37:56,760
time yet we do when should one decide to

00:37:54,119 --> 00:38:00,030
use elastic SQL DB instead of cluster of

00:37:56,760 --> 00:38:02,070
single DBS well I mean it depends on how

00:38:00,030 --> 00:38:04,560
many you know gigabytes change the Frog

00:38:02,070 --> 00:38:08,960
of per second I guess I don't know I

00:38:04,560 --> 00:38:08,960
don't know the elastic sequel probably

00:38:10,220 --> 00:38:16,470
way later than you think you do

00:38:12,660 --> 00:38:20,130
yeah wait way later all right

00:38:16,470 --> 00:38:22,200
concise how to use custom graph QL types

00:38:20,130 --> 00:38:24,720
important for NPM package in Apollo's

00:38:22,200 --> 00:38:25,470
graph QL so this is actually a major

00:38:24,720 --> 00:38:27,960
sort

00:38:25,470 --> 00:38:30,660
so for those of you don't know graph QL

00:38:27,960 --> 00:38:32,880
api's are self describing you have to

00:38:30,660 --> 00:38:34,440
tell the computer here all my fields

00:38:32,880 --> 00:38:37,260
here the documentation strings on them

00:38:34,440 --> 00:38:39,990
here are their types but that is

00:38:37,260 --> 00:38:42,150
limiting because graph GL only has

00:38:39,990 --> 00:38:44,700
certain kind of types built-in strings

00:38:42,150 --> 00:38:48,060
and integers and lists and associated

00:38:44,700 --> 00:38:49,619
lists and that kind of thing and so you

00:38:48,060 --> 00:38:51,359
know sometimes it's nice to be able to

00:38:49,619 --> 00:38:53,609
say this string is not just a string

00:38:51,359 --> 00:38:55,589
it's a date and to be able to

00:38:53,609 --> 00:38:57,660
deserialize it into a date automatically

00:38:55,589 --> 00:38:59,640
on the other side but the really big

00:38:57,660 --> 00:39:02,400
problem here whenever you do that a

00:38:59,640 --> 00:39:04,770
custom data type as it exists in graph

00:39:02,400 --> 00:39:07,020
QL right now does not have to be

00:39:04,770 --> 00:39:09,930
represented as one of the underlying

00:39:07,020 --> 00:39:12,060
types and so that means that it's now an

00:39:09,930 --> 00:39:14,010
opaque blob the computer does not know

00:39:12,060 --> 00:39:16,380
how to deal with it in an automated way

00:39:14,010 --> 00:39:19,670
you actually have to tell it how to

00:39:16,380 --> 00:39:23,369
deserialize this blob now and most

00:39:19,670 --> 00:39:26,570
services most applications don't handle

00:39:23,369 --> 00:39:29,339
custom types in Apollo well at all so

00:39:26,570 --> 00:39:31,859
there is some work right now and there's

00:39:29,339 --> 00:39:35,250
a discussion and an RFC for graph QL

00:39:31,859 --> 00:39:37,109
that is arguing really although you can

00:39:35,250 --> 00:39:38,849
have a date you should still at least

00:39:37,109 --> 00:39:41,010
describe that it's implemented in terms

00:39:38,849 --> 00:39:43,140
of a string so if I'm just writing some

00:39:41,010 --> 00:39:44,490
middleware at the very least I can pass

00:39:43,140 --> 00:39:46,800
through it I can do a little bit of work

00:39:44,490 --> 00:39:48,900
on it and then I don't break just

00:39:46,800 --> 00:39:50,190
because this is an opaque blob so I

00:39:48,900 --> 00:39:50,550
would say that we don't handle it very

00:39:50,190 --> 00:39:52,400
well

00:39:50,550 --> 00:39:55,650
or we don't use it very well right now

00:39:52,400 --> 00:39:56,310
okay you showed a tool to find the

00:39:55,650 --> 00:39:58,950
specific

00:39:56,310 --> 00:40:01,170
we can use what was that this was a tool

00:39:58,950 --> 00:40:03,120
by Matty he's sitting down here in the

00:40:01,170 --> 00:40:07,380
front you should come talk to him he's

00:40:03,120 --> 00:40:11,070
like literally how you use it yeah but

00:40:07,380 --> 00:40:15,120
the idea there is actually that the any

00:40:11,070 --> 00:40:17,250
library that would write its data in a

00:40:15,120 --> 00:40:18,570
way that this to understood would

00:40:17,250 --> 00:40:20,610
automatically work with that with no

00:40:18,570 --> 00:40:22,830
additional effort and so yeah it would

00:40:20,610 --> 00:40:25,110
be really cool to see this tool get some

00:40:22,830 --> 00:40:30,360
more love I'll actually post a link to

00:40:25,110 --> 00:40:33,920
the demo of it after the talk okay what

00:40:30,360 --> 00:40:33,920
did you use to see options for RAM DES

00:40:34,550 --> 00:40:39,270
we used the tool so what we did is we

00:40:37,230 --> 00:40:42,000
built this tool that are not we Mathew

00:40:39,270 --> 00:40:44,550
built this tool that took a data

00:40:42,000 --> 00:40:46,380
description of the API and then was able

00:40:44,550 --> 00:40:48,630
to see all the things that were there so

00:40:46,380 --> 00:40:51,300
that the documentation it could run eval

00:40:48,630 --> 00:40:54,450
could do a lot of different things so we

00:40:51,300 --> 00:40:56,400
we did the manual work we went in or

00:40:54,450 --> 00:40:57,930
Massey did some handiwork he went in

00:40:56,400 --> 00:41:00,030
read all of the docs for RAM de and

00:40:57,930 --> 00:41:03,030
encoded it in a computer readable

00:41:00,030 --> 00:41:06,810
version and so that is the tool that we

00:41:03,030 --> 00:41:09,030
used what about corner cases possible

00:41:06,810 --> 00:41:13,700
exceptions different accepted values etc

00:41:09,030 --> 00:41:13,700
and API accepts if you get rid of Doc's

00:41:16,040 --> 00:41:22,500
no I think it's a decent question so I

00:41:20,280 --> 00:41:24,360
typically write in a language called

00:41:22,500 --> 00:41:25,680
reason you know as Jarrod talked about

00:41:24,360 --> 00:41:29,130
earlier today and I think David

00:41:25,680 --> 00:41:32,280
yesterday and languages like reason are

00:41:29,130 --> 00:41:34,710
really good at saying nope no exceptions

00:41:32,280 --> 00:41:36,570
you have to deal with this how do you

00:41:34,710 --> 00:41:38,310
deal with this you can't just punt you

00:41:36,570 --> 00:41:39,900
can't just say well you know I'll just

00:41:38,310 --> 00:41:41,010
describe it to a human because the

00:41:39,900 --> 00:41:42,390
computer can't read it anymore

00:41:41,010 --> 00:41:44,130
and one of the things I really like

00:41:42,390 --> 00:41:45,900
about reason is how much the computer

00:41:44,130 --> 00:41:48,600
can read the code and how much it can

00:41:45,900 --> 00:41:50,250
help me as a result of that so it argued

00:41:48,600 --> 00:41:52,920
that a lot of the times there are

00:41:50,250 --> 00:41:54,300
exceptions or corner cases there may be

00:41:52,920 --> 00:41:57,240
some decent reasons for it but

00:41:54,300 --> 00:41:58,860
oftentimes it's for a lack of kind of

00:41:57,240 --> 00:42:01,050
understanding the underlying model and

00:41:58,860 --> 00:42:02,190
it's better to try to minimize those if

00:42:01,050 --> 00:42:04,140
you have to have them then go ahead

00:42:02,190 --> 00:42:06,090
right you can have those opaque things

00:42:04,140 --> 00:42:07,860
that the computer can't read but like I

00:42:06,090 --> 00:42:09,690
said be careful because anytime you do

00:42:07,860 --> 00:42:10,170
that if you don't describe it in a way

00:42:09,690 --> 00:42:12,960
that it can

00:42:10,170 --> 00:42:14,880
can read that's the lost effort right

00:42:12,960 --> 00:42:17,070
that exists in your head and in a

00:42:14,880 --> 00:42:18,090
convention and any of your co-workers or

00:42:17,070 --> 00:42:19,830
future coworkers

00:42:18,090 --> 00:42:21,450
don't know about that whereas if the

00:42:19,830 --> 00:42:25,980
computer knows it can tell everyone

00:42:21,450 --> 00:42:28,560
forever all right final question sounds

00:42:25,980 --> 00:42:31,230
very close URI dialogue spec ADN was it

00:42:28,560 --> 00:42:33,060
your inspiration yes I'm a huge fan of

00:42:31,230 --> 00:42:35,460
closure I worked in closure

00:42:33,060 --> 00:42:38,640
professionally for many years I really

00:42:35,460 --> 00:42:41,220
like the data oriented approach and rich

00:42:38,640 --> 00:42:44,310
Hickey has talked about this at length

00:42:41,220 --> 00:42:46,410
he speaks very eloquently about it I'm a

00:42:44,310 --> 00:42:47,690
huge fan of these things it wasn't

00:42:46,410 --> 00:42:50,100
necessarily my inspiration for this

00:42:47,690 --> 00:42:53,190
because I think actually even for

00:42:50,100 --> 00:42:55,260
closure a lot of the things could be

00:42:53,190 --> 00:42:57,390
done in a more automated way so there's

00:42:55,260 --> 00:42:59,640
a new closure documentation site by

00:42:57,390 --> 00:43:01,350
Martin that is I believe more

00:42:59,640 --> 00:43:02,790
data-driven I think that we're gonna see

00:43:01,350 --> 00:43:04,680
some really really interesting things

00:43:02,790 --> 00:43:06,240
happen as that can get even that

00:43:04,680 --> 00:43:08,730
community which is already leading in

00:43:06,240 --> 00:43:10,470
many many different ways as they begin

00:43:08,730 --> 00:43:12,030
to adopt more data-driven tools we're

00:43:10,470 --> 00:43:14,340
gonna see even more interesting things

00:43:12,030 --> 00:43:15,480
come out of there all right thank you

00:43:14,340 --> 00:43:17,840
very much Sean let's give it a regular

00:43:15,480 --> 00:43:17,840

YouTube URL: https://www.youtube.com/watch?v=Ya8SffTEHGA


