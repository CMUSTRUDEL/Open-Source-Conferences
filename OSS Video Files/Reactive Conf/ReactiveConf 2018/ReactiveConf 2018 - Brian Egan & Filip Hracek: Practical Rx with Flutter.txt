Title: ReactiveConf 2018 - Brian Egan & Filip Hracek: Practical Rx with Flutter
Publication date: 2018-11-04
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Main stage
-------------------------------------------------------------------
Practical Rx with Flutter

In this talk, Brian and Filip will skip all the theory about reactive extensions (Rx) and dive right into practical use. How can Rx help you with autocomplete? What about when you have several fallback scenarios? What if the state of your app depends on three separate data sources, all asynchronous and live? We’ll be live-coding with Flutter and its handy StreamBuilder widget — but these little patterns are applicable everywhere else.
Captions: 
	00:00:02,310 --> 00:00:08,769
[Music]

00:00:11,980 --> 00:00:16,430
thank you so much for having us today

00:00:14,719 --> 00:00:23,869
Philips gonna go ahead and get plugged

00:00:16,430 --> 00:00:27,320
in and then we'll get rolling live

00:00:23,869 --> 00:00:33,339
coding ready almost ready emulator

00:00:27,320 --> 00:00:33,339
locked and loaded all right hey

00:00:34,990 --> 00:00:41,210
okay cool all right well thanks so much

00:00:38,719 --> 00:00:44,329
for joining us my name is Brian Egan

00:00:41,210 --> 00:00:45,980
I am the co-author of rx start which is

00:00:44,329 --> 00:00:49,370
the reactive extensions for the dart

00:00:45,980 --> 00:00:51,140
language and I'm joined by today hi my

00:00:49,370 --> 00:00:54,500
name is Philip I'm a developer advocate

00:00:51,140 --> 00:00:55,879
for follower at Google all right and so

00:00:54,500 --> 00:00:58,280
today we're gonna be talking about

00:00:55,879 --> 00:01:00,890
practical applications of reactive

00:00:58,280 --> 00:01:02,929
extensions with flutter but we hope this

00:01:00,890 --> 00:01:05,540
talk will be practical and applicable to

00:01:02,929 --> 00:01:08,030
other areas of expertise as well such as

00:01:05,540 --> 00:01:10,190
JavaScript or Android development or

00:01:08,030 --> 00:01:12,530
Swift development we're hoping to talk

00:01:10,190 --> 00:01:15,800
more generally but we'll be using rx and

00:01:12,530 --> 00:01:17,750
flutter to implement these concepts so

00:01:15,800 --> 00:01:19,880
in our case we're gonna be talking about

00:01:17,750 --> 00:01:21,620
building reactive apps and just to

00:01:19,880 --> 00:01:24,380
really set the stage before we really

00:01:21,620 --> 00:01:26,450
dive into the practical part you know we

00:01:24,380 --> 00:01:29,090
can sort of think about two approaches

00:01:26,450 --> 00:01:30,530
to developing apps right and so in most

00:01:29,090 --> 00:01:32,810
apps right you have some sort of data

00:01:30,530 --> 00:01:35,540
source or some sort of component that

00:01:32,810 --> 00:01:37,190
talks to a data source and something

00:01:35,540 --> 00:01:39,260
will change with this data source right

00:01:37,190 --> 00:01:41,960
and then we need to update our UI is

00:01:39,260 --> 00:01:43,250
like the classic problem and so there

00:01:41,960 --> 00:01:44,900
are a couple different approaches the

00:01:43,250 --> 00:01:48,020
first is of course is a proactive

00:01:44,900 --> 00:01:50,000
approach so in this case the component

00:01:48,020 --> 00:01:52,280
that talks to your data source it might

00:01:50,000 --> 00:01:54,350
drive the UI and tell it exactly what to

00:01:52,280 --> 00:01:57,230
do so if we were building a search

00:01:54,350 --> 00:01:59,510
screen and you enter the screen you're

00:01:57,230 --> 00:02:01,550
proactive component might say okay UI go

00:01:59,510 --> 00:02:03,320
ahead and show the node term to let the

00:02:01,550 --> 00:02:05,660
user know they can type something in and

00:02:03,320 --> 00:02:07,340
then as the user starts typing something

00:02:05,660 --> 00:02:09,800
in we're gonna want to fetch some search

00:02:07,340 --> 00:02:11,959
results and so our proactive component

00:02:09,800 --> 00:02:14,030
will say okay let's hide that node term

00:02:11,959 --> 00:02:15,440
and let's show the loading spinner

00:02:14,030 --> 00:02:18,210
instead

00:02:15,440 --> 00:02:20,370
finally when the results come back that

00:02:18,210 --> 00:02:21,810
proactive component will say okay now

00:02:20,370 --> 00:02:23,900
it's time to hide that loading spinner

00:02:21,810 --> 00:02:26,670
and show the results that we've received

00:02:23,900 --> 00:02:28,620
and this is actually a really popular

00:02:26,670 --> 00:02:30,090
approach if you come from Android

00:02:28,620 --> 00:02:32,280
development and you've worked with

00:02:30,090 --> 00:02:34,500
something like the MVP pattern it's

00:02:32,280 --> 00:02:37,200
really common to have this presenter

00:02:34,500 --> 00:02:39,630
component telling a view component what

00:02:37,200 --> 00:02:41,430
it needs to do but one thing that I

00:02:39,630 --> 00:02:43,320
experienced and that other I think folks

00:02:41,430 --> 00:02:45,390
might experience is that you can get

00:02:43,320 --> 00:02:47,700
some interesting bugs with this right

00:02:45,390 --> 00:02:51,150
so say those search results come back

00:02:47,700 --> 00:02:53,910
and for some reason your presenter or

00:02:51,150 --> 00:02:55,920
the component that's driving the view it

00:02:53,910 --> 00:02:57,180
doesn't tell it to hide the loading

00:02:55,920 --> 00:02:59,880
spinner it just tells it to show the

00:02:57,180 --> 00:03:02,160
results and this is an actual bug that

00:02:59,880 --> 00:03:03,989
I've seen on apps and that I've done

00:03:02,160 --> 00:03:06,930
myself right

00:03:03,989 --> 00:03:08,340
you know bugs they crop up and so it's

00:03:06,930 --> 00:03:09,450
really interesting so sometimes you'll

00:03:08,340 --> 00:03:11,459
actually see some apps where they're

00:03:09,450 --> 00:03:13,350
almost like showing two screens on top

00:03:11,459 --> 00:03:15,000
of each other and that's a really

00:03:13,350 --> 00:03:16,500
interesting bug and it's it's a

00:03:15,000 --> 00:03:17,850
difficult bug to solve because you kind

00:03:16,500 --> 00:03:19,920
of need to go through your proactive

00:03:17,850 --> 00:03:22,769
component and figure out okay where

00:03:19,920 --> 00:03:24,150
along the way did I mess up now if we

00:03:22,769 --> 00:03:26,489
compare that to a reactive approach

00:03:24,150 --> 00:03:28,860
right in this case what we will do is

00:03:26,489 --> 00:03:31,200
rather than having a proactive component

00:03:28,860 --> 00:03:34,049
telling the view what to do will allow

00:03:31,200 --> 00:03:36,360
the view to respond to events and in

00:03:34,049 --> 00:03:39,000
this case we'll be listening to a stream

00:03:36,360 --> 00:03:42,269
of events and now we can almost think

00:03:39,000 --> 00:03:44,640
about our view as a function right we

00:03:42,269 --> 00:03:47,130
get some input and we expect it to have

00:03:44,640 --> 00:03:48,420
some UI output for folks at this

00:03:47,130 --> 00:03:49,709
conference I'm sure this is stuff you're

00:03:48,420 --> 00:03:52,650
doing all the time since we're at

00:03:49,709 --> 00:03:53,730
reactive conf and so in this case what

00:03:52,650 --> 00:03:56,040
we're going to do is we're going to be

00:03:53,730 --> 00:03:57,450
listening to a stream of events and the

00:03:56,040 --> 00:03:59,970
stream of events will deliver a

00:03:57,450 --> 00:04:02,610
different data over time so it might

00:03:59,970 --> 00:04:04,560
deliver the no term and your UI can

00:04:02,610 --> 00:04:07,290
simply take that data and render the

00:04:04,560 --> 00:04:09,120
correct UI then when it's being when

00:04:07,290 --> 00:04:11,190
it's told to show the loading spinner or

00:04:09,120 --> 00:04:13,829
that something is loading your UI knows

00:04:11,190 --> 00:04:15,450
what to do and finally when the results

00:04:13,829 --> 00:04:17,459
come back it will know hey I need to

00:04:15,450 --> 00:04:20,419
show those results right you have these

00:04:17,459 --> 00:04:22,710
inputs and you presented a UI output and

00:04:20,419 --> 00:04:24,539
this is really nice for larger apps

00:04:22,710 --> 00:04:26,910
where you probably are going to be

00:04:24,539 --> 00:04:28,170
having screens or widgets or components

00:04:26,910 --> 00:04:30,690
that are listening to multiple

00:04:28,170 --> 00:04:32,850
data sources and this is nice because

00:04:30,690 --> 00:04:34,710
you have essentially a single code path

00:04:32,850 --> 00:04:37,650
right you know that you have some input

00:04:34,710 --> 00:04:39,180
and an output and so if you happen to

00:04:37,650 --> 00:04:41,070
have this mistake where you might be

00:04:39,180 --> 00:04:43,200
showing two things won't run right on

00:04:41,070 --> 00:04:45,030
top of the other you just need to go and

00:04:43,200 --> 00:04:47,220
look at your sort of functional

00:04:45,030 --> 00:04:49,020
transformation and say hey given a

00:04:47,220 --> 00:04:52,020
certain input why am i delivering this

00:04:49,020 --> 00:04:53,460
screen so that's the theoretical part

00:04:52,020 --> 00:04:55,320
and we just wanted to use that to set

00:04:53,460 --> 00:04:57,900
the stage but I think it's time to get

00:04:55,320 --> 00:05:00,270
practical and let's go ahead and build a

00:04:57,900 --> 00:05:02,790
search screen so what we'll do is we'll

00:05:00,270 --> 00:05:04,530
actually live code search screen and

00:05:02,790 --> 00:05:07,110
we'll start with a little bit more of a

00:05:04,530 --> 00:05:09,750
proactive approach and we'll refactor it

00:05:07,110 --> 00:05:12,420
into more of a reactive approach using

00:05:09,750 --> 00:05:15,590
the reactive extensions in this case

00:05:12,420 --> 00:05:19,530
we'll also be using flutter write so

00:05:15,590 --> 00:05:21,540
flutter is a mobile app as DK right it's

00:05:19,530 --> 00:05:24,230
something for building or toolkit for

00:05:21,540 --> 00:05:28,530
building apps for iOS and Android and

00:05:24,230 --> 00:05:32,910
the one of the characteristics of this

00:05:28,530 --> 00:05:35,430
is that it compiles to machine code

00:05:32,910 --> 00:05:38,790
right it compiles to native arm code

00:05:35,430 --> 00:05:43,410
that then paints right directly to

00:05:38,790 --> 00:05:46,650
OpenGL or Vulcan so we do that because

00:05:43,410 --> 00:05:48,900
we want to enable apps like reflect Li

00:05:46,650 --> 00:05:52,050
here reflect Li is an app that was

00:05:48,900 --> 00:05:54,720
published not so long ago and as you can

00:05:52,050 --> 00:05:59,340
see it's very dynamic it's very animated

00:05:54,720 --> 00:06:02,010
it's very smooth as well and you know

00:05:59,340 --> 00:06:06,420
the compilation - native code enables

00:06:02,010 --> 00:06:08,730
that so the reason why we want to enable

00:06:06,420 --> 00:06:11,310
apps like this is that if you look at

00:06:08,730 --> 00:06:14,340
app stores today these are the top apps

00:06:11,310 --> 00:06:16,620
right they're not kind of cookie cutter

00:06:14,340 --> 00:06:21,810
apps they're very custom and very

00:06:16,620 --> 00:06:24,690
animated flower is reactive or like a

00:06:21,810 --> 00:06:27,450
decorative framework so it makes sense

00:06:24,690 --> 00:06:29,940
to use something like rx or reactive

00:06:27,450 --> 00:06:33,140
programming in general it actually is

00:06:29,940 --> 00:06:35,970
even impossible to do anything else but

00:06:33,140 --> 00:06:38,070
it's not like rx is not the only

00:06:35,970 --> 00:06:41,129
approach that you can take the reason

00:06:38,070 --> 00:06:45,029
why I'm talking here at you know about

00:06:41,129 --> 00:06:48,779
Rx is that big flower apps built at

00:06:45,029 --> 00:06:51,629
Google are using Rx and so that's what I

00:06:48,779 --> 00:06:54,509
have some experience with so let's

00:06:51,629 --> 00:06:56,909
actually life goat or show some code

00:06:54,509 --> 00:06:59,099
here right so on the right here we have

00:06:56,909 --> 00:07:02,939
an app or we have a screen in an app

00:06:59,099 --> 00:07:05,489
that just searches things so I can you

00:07:02,939 --> 00:07:08,489
know I search these are vegetables and

00:07:05,489 --> 00:07:11,249
fruits and I can search for a term and

00:07:08,489 --> 00:07:13,699
it will give me immediately some kind of

00:07:11,249 --> 00:07:19,080
results it will filter the results right

00:07:13,699 --> 00:07:22,319
obviously so it's a screen so in for how

00:07:19,080 --> 00:07:24,330
you do that most of the time is using a

00:07:22,319 --> 00:07:26,099
stream builder everything in flour is a

00:07:24,330 --> 00:07:28,589
widget and stream builder is a widget

00:07:26,099 --> 00:07:31,589
stream builder is very what conceptually

00:07:28,589 --> 00:07:34,019
is very easy to understand it basically

00:07:31,589 --> 00:07:35,699
it takes a stream of data and then

00:07:34,019 --> 00:07:38,490
anytime there's a new event on that

00:07:35,699 --> 00:07:41,789
stream it will use this function to

00:07:38,490 --> 00:07:45,599
rebuild itself or repulse it it's

00:07:41,789 --> 00:07:49,379
chillum right so and then in here we

00:07:45,599 --> 00:07:52,529
just generate rows and all that this the

00:07:49,379 --> 00:07:55,379
results or the stream of results is a

00:07:52,529 --> 00:07:58,349
some kind of API right like we have some

00:07:55,379 --> 00:08:01,740
kind of object somewhere that is taking

00:07:58,349 --> 00:08:04,589
care of you know the search and here we

00:08:01,740 --> 00:08:07,139
just listen to it and on another place

00:08:04,589 --> 00:08:10,050
here actually we were creating the

00:08:07,139 --> 00:08:11,759
search box and we're winding it up to a

00:08:10,050 --> 00:08:13,649
controller and then control that

00:08:11,759 --> 00:08:17,459
controller anytime there's a change in

00:08:13,649 --> 00:08:23,069
the input box we will just you know put

00:08:17,459 --> 00:08:25,860
the term into that API and then here we

00:08:23,069 --> 00:08:27,990
listen to the outputs right the the cool

00:08:25,860 --> 00:08:30,689
thing about this is that the view code

00:08:27,990 --> 00:08:33,930
doesn't really need to worry about how

00:08:30,689 --> 00:08:34,709
that search service is implemented it's

00:08:33,930 --> 00:08:36,959
just like it

00:08:34,709 --> 00:08:40,039
it keeps gives it the terms that you're

00:08:36,959 --> 00:08:42,930
searching and then it also is reactively

00:08:40,039 --> 00:08:46,589
listening to updates to the search

00:08:42,930 --> 00:08:51,899
results so we'll spend most of our time

00:08:46,589 --> 00:08:54,970
now in the search service and basically

00:08:51,899 --> 00:08:56,259
just with these few lines right so

00:08:54,970 --> 00:08:58,209
right now we have this kind of like a

00:08:56,259 --> 00:09:00,550
half reactive approach where we are

00:08:58,209 --> 00:09:02,769
assert we're listening to the stream of

00:09:00,550 --> 00:09:08,100
search terms and anytime there's a new

00:09:02,769 --> 00:09:10,629
term we are using our like Search API to

00:09:08,100 --> 00:09:14,290
synchronously ask for the results and

00:09:10,629 --> 00:09:18,069
then add them to the stream of results

00:09:14,290 --> 00:09:22,199
right so let's see like it kind of works

00:09:18,069 --> 00:09:25,180
as I showed before right and so you can

00:09:22,199 --> 00:09:29,019
search for different things and that's

00:09:25,180 --> 00:09:31,269
great but this is an ideal case we are

00:09:29,019 --> 00:09:35,110
actually so that I instrumented the

00:09:31,269 --> 00:09:37,870
Search API to always return the result

00:09:35,110 --> 00:09:41,860
after I think 200 milliseconds right

00:09:37,870 --> 00:09:43,959
which like in a test that's great but

00:09:41,860 --> 00:09:46,300
then in a real life that's not going to

00:09:43,959 --> 00:09:50,019
be always the case so I also

00:09:46,300 --> 00:09:53,170
instrumented it so that one particular

00:09:50,019 --> 00:09:55,660
search will take much longer and that's

00:09:53,170 --> 00:09:59,110
the search for the letter P so if I

00:09:55,660 --> 00:10:01,899
search for letter P just letter B it it

00:09:59,110 --> 00:10:03,819
will take something like a second to get

00:10:01,899 --> 00:10:06,040
the results back it's more realistic

00:10:03,819 --> 00:10:09,009
like you have things that will take more

00:10:06,040 --> 00:10:11,230
time things will go out of sync and so

00:10:09,009 --> 00:10:13,870
on and so forth right so if you only

00:10:11,230 --> 00:10:16,209
search for letter P that's just you know

00:10:13,870 --> 00:10:18,309
it's just annoying but that's not a big

00:10:16,209 --> 00:10:20,170
deal but most people don't searches for

00:10:18,309 --> 00:10:22,779
letter P most people search for

00:10:20,170 --> 00:10:25,300
something like pine because they want to

00:10:22,779 --> 00:10:28,980
search for pineapple and then did you

00:10:25,300 --> 00:10:31,689
see what happened I search for pine and

00:10:28,980 --> 00:10:35,709
it was there pineapple was there for a

00:10:31,689 --> 00:10:37,629
minute and then it was rewritten by the

00:10:35,709 --> 00:10:41,110
search for the letter P because it went

00:10:37,629 --> 00:10:44,019
you know it came later so what the hell

00:10:41,110 --> 00:10:46,389
Brian is you that you said our x is

00:10:44,019 --> 00:10:49,329
great yeah you just know just more

00:10:46,389 --> 00:10:51,339
problems right now so in this case right

00:10:49,329 --> 00:10:52,720
we're dealing with a synchro does philip

00:10:51,339 --> 00:10:55,059
mentioned and we're dealing with a

00:10:52,720 --> 00:10:57,699
problem where we can't guarantee that

00:10:55,059 --> 00:11:00,069
these results will come back in order so

00:10:57,699 --> 00:11:01,629
in this case the happy path right is you

00:11:00,069 --> 00:11:03,670
search for the letter P and the results

00:11:01,629 --> 00:11:06,750
come back within you know constant time

00:11:03,670 --> 00:11:09,660
200 milliseconds then P I then

00:11:06,750 --> 00:11:11,939
and then pine finally and in this case

00:11:09,660 --> 00:11:13,740
your UI will be just fine you your users

00:11:11,939 --> 00:11:15,480
won't notice any bugs you might think

00:11:13,740 --> 00:11:17,699
like hey I've developed my feature and

00:11:15,480 --> 00:11:19,920
it's working so I'm gonna ship it but

00:11:17,699 --> 00:11:22,500
then maybe your users are out in the

00:11:19,920 --> 00:11:24,389
wild and they get bad 3G or something

00:11:22,500 --> 00:11:26,430
for a few minutes and they search for

00:11:24,389 --> 00:11:27,720
the letter P as we've sort of

00:11:26,430 --> 00:11:29,939
instrumented here and all of a sudden

00:11:27,720 --> 00:11:32,189
that's gonna take maybe 2 to 5 seconds

00:11:29,939 --> 00:11:34,470
or even longer but then they keep

00:11:32,189 --> 00:11:36,959
searching and for some reason those next

00:11:34,470 --> 00:11:39,029
results come back just perfectly on time

00:11:36,959 --> 00:11:40,709
so what's happening is that we're

00:11:39,029 --> 00:11:43,259
actually displaying the results for pine

00:11:40,709 --> 00:11:45,569
but then the search results for the

00:11:43,259 --> 00:11:47,370
letter P come back and it just wipes out

00:11:45,569 --> 00:11:49,290
what we had previously so that's what

00:11:47,370 --> 00:11:51,540
the effect you were saying on screen and

00:11:49,290 --> 00:11:54,000
that's why at first you saw results for

00:11:51,540 --> 00:11:56,850
the search term pine and all of a sudden

00:11:54,000 --> 00:11:59,579
just got wiped out and so this is an

00:11:56,850 --> 00:12:02,550
interesting problem and we've I think

00:11:59,579 --> 00:12:05,370
we've got a solution for it so yeah so

00:12:02,550 --> 00:12:10,290
one thing that we can do is actually you

00:12:05,370 --> 00:12:12,120
know again look at look at our X and

00:12:10,290 --> 00:12:14,519
what it gives us and think about the

00:12:12,120 --> 00:12:16,939
search screen as a function right so

00:12:14,519 --> 00:12:21,839
search screen is a function that takes

00:12:16,939 --> 00:12:24,149
the search terms and returns the search

00:12:21,839 --> 00:12:27,180
results that's all it does right it's a

00:12:24,149 --> 00:12:30,300
it's a pure function and it just happens

00:12:27,180 --> 00:12:32,459
to be you know shown on screen and it

00:12:30,300 --> 00:12:35,250
happens to be a synchronous so that's

00:12:32,459 --> 00:12:38,389
exactly what our X is for so instead of

00:12:35,250 --> 00:12:41,100
just creating a new like new resolved

00:12:38,389 --> 00:12:43,500
subject and then like adding things to

00:12:41,100 --> 00:12:46,920
it we can just transform the search

00:12:43,500 --> 00:12:51,209
terms through things and then return

00:12:46,920 --> 00:12:53,639
that return the the result so we're not

00:12:51,209 --> 00:12:56,699
going to use this we're actually

00:12:53,639 --> 00:12:58,079
starting with search terms and then

00:12:56,699 --> 00:12:59,699
whenever in functional reactive

00:12:58,079 --> 00:13:03,449
programming whenever you're trying to

00:12:59,699 --> 00:13:05,069
transform one iterable in this case it's

00:13:03,449 --> 00:13:08,670
an iterable that is a synchronous so

00:13:05,069 --> 00:13:11,160
stream but if you are mapping from one

00:13:08,670 --> 00:13:15,839
stream to another stream would you use

00:13:11,160 --> 00:13:18,420
map right we could use map well we can't

00:13:15,839 --> 00:13:19,889
use map because what we are using the

00:13:18,420 --> 00:13:24,059
API is a synchronous

00:13:19,889 --> 00:13:27,209
so we need to use is a sink map so let

00:13:24,059 --> 00:13:29,819
me do just that all right and so in this

00:13:27,209 --> 00:13:33,660
case a sink map will take in a function

00:13:29,819 --> 00:13:34,709
and it needs to return a future and in

00:13:33,660 --> 00:13:36,569
this case if you come from the

00:13:34,709 --> 00:13:38,669
JavaScript world you can really think of

00:13:36,569 --> 00:13:41,369
a future just like a JavaScript promise

00:13:38,669 --> 00:13:43,079
they've got a very similar API so in

00:13:41,369 --> 00:13:45,419
this case we're marking the function as

00:13:43,079 --> 00:13:48,470
async we're going to await the result

00:13:45,419 --> 00:13:50,999
and then we're gonna return that result

00:13:48,470 --> 00:13:55,350
so let's see if that actually fixed up

00:13:50,999 --> 00:13:58,379
the problem so I search for pine and it

00:13:55,350 --> 00:14:00,720
fixes the problem as you could see that

00:13:58,379 --> 00:14:03,299
there's no longer a race condition but

00:14:00,720 --> 00:14:06,480
there's another problem and that's that

00:14:03,299 --> 00:14:09,449
we are actually waiting for the P to

00:14:06,480 --> 00:14:12,449
finish before going ahead right so for

00:14:09,449 --> 00:14:15,119
from the experience of the user that's

00:14:12,449 --> 00:14:16,829
actually not that like it's it's better

00:14:15,119 --> 00:14:19,290
because you get the result in the end

00:14:16,829 --> 00:14:21,449
but it's actually pretty bad experience

00:14:19,290 --> 00:14:22,759
you're waiting for the long time so

00:14:21,449 --> 00:14:27,629
there's something wrong here

00:14:22,759 --> 00:14:32,939
so maybe async map is not the operator

00:14:27,629 --> 00:14:34,169
that we want to use we're gonna we're

00:14:32,939 --> 00:14:37,739
gonna try out another operator

00:14:34,169 --> 00:14:39,389
this one's called switch map and this

00:14:37,739 --> 00:14:41,610
this operators a bit different in that

00:14:39,389 --> 00:14:43,829
every time a new search term comes in

00:14:41,610 --> 00:14:46,709
it's just gonna go ahead and disregard

00:14:43,829 --> 00:14:49,110
any discard scuse me any of the previous

00:14:46,709 --> 00:14:50,790
search terms that were in flight so if

00:14:49,110 --> 00:14:52,769
it's making some calls or doing things

00:14:50,790 --> 00:14:54,600
like that it's just gonna say hey drop

00:14:52,769 --> 00:14:57,480
the last call that you are making and

00:14:54,600 --> 00:14:58,799
let's only use the latest call so in

00:14:57,480 --> 00:15:01,319
this case what we've done is we've

00:14:58,799 --> 00:15:03,149
transformed the function and switch map

00:15:01,319 --> 00:15:05,549
actually needs to return a stream of

00:15:03,149 --> 00:15:07,350
events rather than a future so what

00:15:05,549 --> 00:15:10,169
we've done is we've actually gone from

00:15:07,350 --> 00:15:12,539
an async function to an async star or an

00:15:10,169 --> 00:15:13,889
async generator function and this is

00:15:12,539 --> 00:15:16,889
really nice because it provides a way

00:15:13,889 --> 00:15:18,869
for us to actually emit values yeah via

00:15:16,889 --> 00:15:20,970
the yield keyword and so this will

00:15:18,869 --> 00:15:23,819
actually return a stream and every time

00:15:20,970 --> 00:15:25,799
we say okay yield the results from the

00:15:23,819 --> 00:15:27,209
from the back end then that'll get

00:15:25,799 --> 00:15:29,669
emitted as part of a stream and

00:15:27,209 --> 00:15:32,819
everything just works so I search for

00:15:29,669 --> 00:15:33,690
fine and there we get so we we don't

00:15:32,819 --> 00:15:36,060
have

00:15:33,690 --> 00:15:39,120
the weight and we don't have the risk

00:15:36,060 --> 00:15:42,870
condition so everything is great except

00:15:39,120 --> 00:15:44,699
as you can see here we're you know we're

00:15:42,870 --> 00:15:48,120
printing every time that we're actually

00:15:44,699 --> 00:15:52,350
making a request to the Search API so

00:15:48,120 --> 00:15:54,779
like if I search for Apple you can see

00:15:52,350 --> 00:15:56,310
that we're actually creating every

00:15:54,779 --> 00:16:00,149
request along the way

00:15:56,310 --> 00:16:03,240
a a pepper PO apple and an apple finally

00:16:00,149 --> 00:16:05,490
right switch map is great because it

00:16:03,240 --> 00:16:07,740
cancels all these things but that still

00:16:05,490 --> 00:16:10,350
means we are starting those requests

00:16:07,740 --> 00:16:14,040
which is pretty bad for the battery it

00:16:10,350 --> 00:16:16,920
could be bad for you know your data it

00:16:14,040 --> 00:16:21,389
could be bad for your back-end because

00:16:16,920 --> 00:16:23,610
like you're basically trying to send

00:16:21,389 --> 00:16:26,339
back all these things that nobody really

00:16:23,610 --> 00:16:29,040
needs nobody really wants so what can we

00:16:26,339 --> 00:16:30,959
use for that yeah so what if we just

00:16:29,040 --> 00:16:33,149
waited and allowed the user to pause for

00:16:30,959 --> 00:16:35,250
a couple seconds or maybe you know just

00:16:33,149 --> 00:16:37,709
half a second before we actually ran the

00:16:35,250 --> 00:16:39,810
search and to do that we can actually

00:16:37,709 --> 00:16:41,910
use another operator provided by rx

00:16:39,810 --> 00:16:44,160
start which is the debounce operator and

00:16:41,910 --> 00:16:45,870
what this will do is this will listen to

00:16:44,160 --> 00:16:48,720
the stream of terms as they come in and

00:16:45,870 --> 00:16:51,720
then once the user pauses in this case

00:16:48,720 --> 00:16:54,089
for 500 milliseconds then it'll forward

00:16:51,720 --> 00:16:56,970
that last thing on to our switch map

00:16:54,089 --> 00:17:01,019
function so now if we take a look at it

00:16:56,970 --> 00:17:03,540
so if I search for Apple now I really

00:17:01,019 --> 00:17:05,159
only search as you can see here I really

00:17:03,540 --> 00:17:10,140
only search for Apple and not the

00:17:05,159 --> 00:17:12,030
intermediates right if I if I if I do if

00:17:10,140 --> 00:17:16,230
I'm too slow and do something like this

00:17:12,030 --> 00:17:18,480
it does search for app but not things

00:17:16,230 --> 00:17:20,459
that are intermediate right yep okay

00:17:18,480 --> 00:17:23,909
cool so we have this we fixed our

00:17:20,459 --> 00:17:26,549
problem we are pretty happy with

00:17:23,909 --> 00:17:30,270
ourselves but then the PM comes and he

00:17:26,549 --> 00:17:33,270
says she says you know what we actually

00:17:30,270 --> 00:17:34,140
have a new requirement there is a new

00:17:33,270 --> 00:17:37,490
stream of data

00:17:34,140 --> 00:17:40,440
it's a like live data stream that says

00:17:37,490 --> 00:17:43,890
which veggies and which fruits are out

00:17:40,440 --> 00:17:46,500
of stock at this moment and so we this

00:17:43,890 --> 00:17:49,560
can happen at any time

00:17:46,500 --> 00:17:53,430
and we don't want to we don't want to

00:17:49,560 --> 00:17:56,790
show veggies and fruits to people which

00:17:53,430 --> 00:17:58,770
are I mean the the ones that are out of

00:17:56,790 --> 00:17:59,400
stock we don't want to show in search

00:17:58,770 --> 00:18:02,150
results

00:17:59,400 --> 00:18:05,910
right so this is great but this kind of

00:18:02,150 --> 00:18:08,100
breaks our nice approach almost right

00:18:05,910 --> 00:18:10,380
because we have we're listening to this

00:18:08,100 --> 00:18:14,280
stream of events and now we have another

00:18:10,380 --> 00:18:17,610
stream of events and we somehow need to

00:18:14,280 --> 00:18:20,040
I would almost say combine it yeah yeah

00:18:17,610 --> 00:18:22,650
well luckily we have the combined latest

00:18:20,040 --> 00:18:24,330
operator with rx start and so the

00:18:22,650 --> 00:18:26,220
combined latest operator is really nice

00:18:24,330 --> 00:18:28,680
because what you can do is you can

00:18:26,220 --> 00:18:31,530
essentially listen to two or three or

00:18:28,680 --> 00:18:33,390
even more streams and whenever one of

00:18:31,530 --> 00:18:35,430
those streams changes you can run a

00:18:33,390 --> 00:18:37,440
function to combine the results from

00:18:35,430 --> 00:18:40,380
both of those streams and output that

00:18:37,440 --> 00:18:42,360
combination so in this case what we'll

00:18:40,380 --> 00:18:46,020
use is we'll use the combined latest to

00:18:42,360 --> 00:18:48,210
factory method and this will take in the

00:18:46,020 --> 00:18:50,040
stream of results which we started with

00:18:48,210 --> 00:18:51,810
and we've already looked at and then

00:18:50,040 --> 00:18:54,660
it'll take in this other stream that

00:18:51,810 --> 00:18:57,720
informs us with live updates of which

00:18:54,660 --> 00:18:59,280
veggies are in stock or out of stock so

00:18:57,720 --> 00:19:01,050
what we'll do is we'll listen to both of

00:18:59,280 --> 00:19:03,600
those streams and we'll create a

00:19:01,050 --> 00:19:05,940
combiner function and what this function

00:19:03,600 --> 00:19:07,500
will do is it will take this to the list

00:19:05,940 --> 00:19:10,200
of results that we've got from our

00:19:07,500 --> 00:19:13,410
search service and we'll combine it and

00:19:10,200 --> 00:19:15,810
we'll filter it using the out of stock

00:19:13,410 --> 00:19:18,000
veggies and so in this case if a

00:19:15,810 --> 00:19:19,890
vegetable is out of stock we'll just go

00:19:18,000 --> 00:19:22,470
ahead and filter it out of the list and

00:19:19,890 --> 00:19:24,600
this is using the where keyword which is

00:19:22,470 --> 00:19:30,120
a similar to filter if you come from

00:19:24,600 --> 00:19:33,800
JavaScript world alright so we've got

00:19:30,120 --> 00:19:33,800
our combiner take a bit

00:19:34,860 --> 00:19:40,500
oh maybe I should actually yeah I should

00:19:38,760 --> 00:19:51,090
actually use the results right

00:19:40,500 --> 00:19:54,600
does it help okay cool all right all

00:19:51,090 --> 00:19:56,070
right demo gods are with us yes so so

00:19:54,600 --> 00:19:59,220
anyway so now we're searching for

00:19:56,070 --> 00:20:02,400
everything and I again I've instrumented

00:19:59,220 --> 00:20:04,860
the app so that what was it cranberries

00:20:02,400 --> 00:20:07,890
yeah cranberries go out of stock every

00:20:04,860 --> 00:20:10,290
second and then go ahead back to stop

00:20:07,890 --> 00:20:14,460
every second we are too but that's

00:20:10,290 --> 00:20:16,440
that's what happens and so you know here

00:20:14,460 --> 00:20:20,850
it's not that great but like if he

00:20:16,440 --> 00:20:22,980
actually search for berries then we see

00:20:20,850 --> 00:20:26,669
that these two things are actually

00:20:22,980 --> 00:20:29,910
combined so we do get back the result of

00:20:26,669 --> 00:20:33,690
the search and we are combining it with

00:20:29,910 --> 00:20:37,650
the live data that is come from our API

00:20:33,690 --> 00:20:41,150
and we're combining the two right so I

00:20:37,650 --> 00:20:43,770
think we are done here all right so

00:20:41,150 --> 00:20:45,720
let's go ahead and do a quick recap and

00:20:43,770 --> 00:20:48,120
talk about these different operators

00:20:45,720 --> 00:20:51,030
that we just saw so the first thing we

00:20:48,120 --> 00:20:53,880
saw is that with async code we can deal

00:20:51,030 --> 00:20:55,830
with ordering issues and so the RX

00:20:53,880 --> 00:21:00,570
reactive extensions whether it's for

00:20:55,830 --> 00:21:02,700
rxjs rx Java etc or rx start they allow

00:21:00,570 --> 00:21:05,760
us to solve this out of order problem

00:21:02,700 --> 00:21:07,980
with the switch map operator and so as I

00:21:05,760 --> 00:21:09,870
said this will basically discard all of

00:21:07,980 --> 00:21:12,419
the previous results that were being

00:21:09,870 --> 00:21:15,870
loaded and only worry about delivering

00:21:12,419 --> 00:21:18,120
the latest results to the user but the

00:21:15,870 --> 00:21:19,500
cool thing is and this is really kind of

00:21:18,120 --> 00:21:22,049
the more general point of this

00:21:19,500 --> 00:21:24,750
functional input to functional output or

00:21:22,049 --> 00:21:26,790
streams of input to streams of output we

00:21:24,750 --> 00:21:29,370
can actually use other types of map as

00:21:26,790 --> 00:21:32,429
well so in the case of infinite

00:21:29,370 --> 00:21:34,740
pagination you might have a stream and

00:21:32,429 --> 00:21:36,660
as the user is scrolling down your page

00:21:34,740 --> 00:21:38,429
whether it's on the web or a flutter app

00:21:36,660 --> 00:21:40,380
and maybe they're getting about five

00:21:38,429 --> 00:21:42,000
hundred or a thousand pixels away from

00:21:40,380 --> 00:21:44,940
the bottom and you want to start loading

00:21:42,000 --> 00:21:47,760
some data so you might emit a stream of

00:21:44,940 --> 00:21:49,220
hay load the next page as a user is

00:21:47,760 --> 00:21:52,280
getting closer to the

00:21:49,220 --> 00:21:54,080
in this case however we might omit this

00:21:52,280 --> 00:21:56,150
event a lot of times especially if it's

00:21:54,080 --> 00:21:58,610
listening to like a scroll controller or

00:21:56,150 --> 00:22:00,530
the window on scroll event and so what

00:21:58,610 --> 00:22:03,710
we want is we want something that will

00:22:00,530 --> 00:22:05,960
fetch fetch the next page when it's

00:22:03,710 --> 00:22:08,570
first told and then it'll kind of just

00:22:05,960 --> 00:22:10,610
ignore the rest of the input and for

00:22:08,570 --> 00:22:12,559
this we can use exhaust map and so it's

00:22:10,610 --> 00:22:14,330
perfect for this situation so as the

00:22:12,559 --> 00:22:16,370
user Scrolls towards the bottom you've

00:22:14,330 --> 00:22:19,160
got this stream emitting events to load

00:22:16,370 --> 00:22:21,590
the next page you have a function that

00:22:19,160 --> 00:22:24,020
is using the exhaust map operator it'll

00:22:21,590 --> 00:22:25,940
load the next page and then when it

00:22:24,020 --> 00:22:28,429
finally has results it'll deliver those

00:22:25,940 --> 00:22:31,070
results and at that point it'll update

00:22:28,429 --> 00:22:32,929
your UI and at that point you shouldn't

00:22:31,070 --> 00:22:35,150
be that close to the bottom anymore so

00:22:32,929 --> 00:22:38,210
you can actually just kind of keep going

00:22:35,150 --> 00:22:40,120
so this is just a really to make a point

00:22:38,210 --> 00:22:42,860
that there are a variety of maps

00:22:40,120 --> 00:22:44,929
provided by a reactive extensions flat

00:22:42,860 --> 00:22:46,880
map switched map exhaust map a few

00:22:44,929 --> 00:22:49,100
others and these can be really useful

00:22:46,880 --> 00:22:51,290
for different situations when you need

00:22:49,100 --> 00:22:55,040
to control what data should be delivered

00:22:51,290 --> 00:22:57,460
to your view or your UI the other thing

00:22:55,040 --> 00:23:01,370
we saw is the ability to combine streams

00:22:57,460 --> 00:23:03,230
and in most cases you know in our case

00:23:01,370 --> 00:23:04,580
we had this Cranberries example and it

00:23:03,230 --> 00:23:06,770
just sort of went in and out of stock

00:23:04,580 --> 00:23:08,720
and you know you might think okay that's

00:23:06,770 --> 00:23:10,970
like kind of a fake example but this is

00:23:08,720 --> 00:23:13,010
something that I've done in production

00:23:10,970 --> 00:23:15,800
so when I worked at Sound Cloud we've

00:23:13,010 --> 00:23:17,990
got for example a playlist and as you're

00:23:15,800 --> 00:23:20,030
playing that playlist you might see that

00:23:17,990 --> 00:23:22,040
the player will change tracks and when

00:23:20,030 --> 00:23:23,900
it does you want to update the playlist

00:23:22,040 --> 00:23:26,510
to show which track is currently playing

00:23:23,900 --> 00:23:28,790
so you can sort of see that this now

00:23:26,510 --> 00:23:30,920
playing moving down the screen as the

00:23:28,790 --> 00:23:32,870
tracks are changed and this is a classic

00:23:30,920 --> 00:23:35,840
combination of using combined latest say

00:23:32,870 --> 00:23:37,970
hey you know give me the playlist via a

00:23:35,840 --> 00:23:40,640
stream and give me the current now

00:23:37,970 --> 00:23:42,770
playing track and I'll display every

00:23:40,640 --> 00:23:43,850
time that that now playing track emits a

00:23:42,770 --> 00:23:46,400
new new item

00:23:43,850 --> 00:23:49,400
I'll just emit a new value and my UI

00:23:46,400 --> 00:23:51,140
will reflect that value so this is the

00:23:49,400 --> 00:23:52,970
combined latest operator and it's a

00:23:51,140 --> 00:23:56,090
super handy operator for a lot of

00:23:52,970 --> 00:23:58,640
different situations another interesting

00:23:56,090 --> 00:24:00,860
situation and this is another example

00:23:58,640 --> 00:24:02,080
we've got I was just another one from

00:24:00,860 --> 00:24:03,490
SoundCloud because I

00:24:02,080 --> 00:24:05,019
worked on this screen and so it's really

00:24:03,490 --> 00:24:06,700
I actually really liked this one when I

00:24:05,019 --> 00:24:07,690
when I found out about pink at I was

00:24:06,700 --> 00:24:10,809
like yes this solves my problem

00:24:07,690 --> 00:24:13,330
perfectly so in this case you might have

00:24:10,809 --> 00:24:16,299
a few likes stored in your database and

00:24:13,330 --> 00:24:19,090
then we also want as you're searching to

00:24:16,299 --> 00:24:22,120
call a Web API and get search

00:24:19,090 --> 00:24:24,070
suggestions and so what we can do is we

00:24:22,120 --> 00:24:25,870
can use the concat operator to combine

00:24:24,070 --> 00:24:29,620
streams and so what we'll do is we'll

00:24:25,870 --> 00:24:32,799
first load the results for local tracks

00:24:29,620 --> 00:24:35,799
and then we'll next make a call to our

00:24:32,799 --> 00:24:37,870
web service and so this delivers results

00:24:35,799 --> 00:24:39,519
really fast because it'll start with the

00:24:37,870 --> 00:24:41,710
local results which usually come back

00:24:39,519 --> 00:24:43,690
within just a less than 100 milliseconds

00:24:41,710 --> 00:24:45,250
and then it can worry about fetching the

00:24:43,690 --> 00:24:47,470
other stuff and so you can see here it

00:24:45,250 --> 00:24:50,440
starts by displaying the local tracks

00:24:47,470 --> 00:24:52,840
and then in a second port it shows the

00:24:50,440 --> 00:24:54,610
the search suggestions so yeah there's

00:24:52,840 --> 00:24:56,590
different ways to combine streams you

00:24:54,610 --> 00:24:59,799
can merge streams you can zip streams

00:24:56,590 --> 00:25:01,570
you can concatenate or combine latest in

00:24:59,799 --> 00:25:04,750
general this is one of the cool things

00:25:01,570 --> 00:25:06,669
about our exes that it allows you to to

00:25:04,750 --> 00:25:09,010
do these types of combinations and you

00:25:06,669 --> 00:25:10,960
know I think you know kind of create

00:25:09,010 --> 00:25:14,760
like almost computed values from two

00:25:10,960 --> 00:25:16,870
different live streams of data and

00:25:14,760 --> 00:25:18,549
finally of course we saw our over

00:25:16,870 --> 00:25:21,130
fetching problem where we kept searching

00:25:18,549 --> 00:25:23,080
for every single letter and in order to

00:25:21,130 --> 00:25:25,389
solve this problem we used something

00:25:23,080 --> 00:25:28,330
like debounce which just allowed us to

00:25:25,389 --> 00:25:29,620
say hey let the user chill out for 500

00:25:28,330 --> 00:25:32,080
milliseconds and then we'll call our

00:25:29,620 --> 00:25:33,519
back-end and that was the really good as

00:25:32,080 --> 00:25:35,019
Phillip mentioned because this will save

00:25:33,519 --> 00:25:37,330
your phone's battery life where your

00:25:35,019 --> 00:25:39,159
users phone's battery life maybe if

00:25:37,330 --> 00:25:41,019
they're on a restricted data plan it

00:25:39,159 --> 00:25:42,909
won't actually end up making these API

00:25:41,019 --> 00:25:45,250
calls to try to fetch this data and

00:25:42,909 --> 00:25:47,710
consume an data plan that's limited and

00:25:45,250 --> 00:25:48,549
of course for your own servers you don't

00:25:47,710 --> 00:25:51,399
want to hit them with too much

00:25:48,549 --> 00:25:52,899
unnecessary traffic it not only costs

00:25:51,399 --> 00:25:54,970
you money but it could also of course

00:25:52,899 --> 00:25:56,950
lead to issues if you have millions and

00:25:54,970 --> 00:25:59,169
millions of users all searching for app

00:25:56,950 --> 00:26:04,750
just AP you know and it's like a useless

00:25:59,169 --> 00:26:06,940
search term so so if you'd like to see

00:26:04,750 --> 00:26:09,519
more now we've got a series of examples

00:26:06,940 --> 00:26:11,169
here and so you can go to the rx start

00:26:09,519 --> 00:26:15,500
repo or we've got a similar search

00:26:11,169 --> 00:26:17,330
example or we also have something like

00:26:15,500 --> 00:26:20,210
architecture samples which is similar to

00:26:17,330 --> 00:26:23,210
to do NBC and we've got a stream based

00:26:20,210 --> 00:26:25,010
version that of that architecture so you

00:26:23,210 --> 00:26:26,780
can sort of see how to use the reactive

00:26:25,010 --> 00:26:28,730
extensions on the maybe a slightly more

00:26:26,780 --> 00:26:32,059
complex although not a super complex app

00:26:28,730 --> 00:26:33,919
and finally we showed the example with

00:26:32,059 --> 00:26:36,409
infinite pagination and how to use

00:26:33,919 --> 00:26:37,640
exhaust map to achieve that and if you'd

00:26:36,409 --> 00:26:42,470
like to look at that you can check out

00:26:37,640 --> 00:26:44,840
this m/v i sealed unions repository yeah

00:26:42,470 --> 00:26:47,270
so so what we wanted to show you today

00:26:44,840 --> 00:26:51,559
is that you know rx is not some kind of

00:26:47,270 --> 00:26:55,730
medical mystical thing that only lives

00:26:51,559 --> 00:26:59,390
in you know with marbles and with people

00:26:55,730 --> 00:27:02,450
who like understand you know functional

00:26:59,390 --> 00:27:04,130
programming from universities but it's

00:27:02,450 --> 00:27:08,870
actually really practical and there's no

00:27:04,130 --> 00:27:12,320
reason to like view that and it is used

00:27:08,870 --> 00:27:13,570
in in real world apps today so thank you

00:27:12,320 --> 00:27:16,900
thank you very much

00:27:13,570 --> 00:27:16,900
[Applause]

00:27:16,920 --> 00:27:18,980

YouTube URL: https://www.youtube.com/watch?v=7O1UO5rEpRc


