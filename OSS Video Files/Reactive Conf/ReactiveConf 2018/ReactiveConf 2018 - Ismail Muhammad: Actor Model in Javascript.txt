Title: ReactiveConf 2018 - Ismail Muhammad: Actor Model in Javascript
Publication date: 2018-11-05
Playlist: ReactiveConf 2018
Description: 
	29th - 31st October 2018, Prague, Czech Republic
https://reactiveconf.com/
Discovery stage
-------------------------------------------------------------------
Actor Model in Javascript

Asynchronous processes in Javascript are hard. Not just hard to write, but especially hard to reason about. Will things happen in the order we intended? Complexity caused by async exists in all programming languages. In multi-threaded environments like Erlang and Java there is an elegant approach to manage the complexity caused by async: Actor model. In this talk we will see how Actor Model can be applied to Javascript. It does not just result in simpler code, but also in an conceptual model of processes that is much easier to reason about. We compiled our experience into our own library: Actrix.
We will show how the Actor model solve async problem in a very elegant way by exchanging messages between actors. We will dive into several different actor patterns, like bindings between the actors world and the UI, optimizations by skipping messages, or even cancelling async operations.
The Actrix library bring much more to the table: uniform communication method for local and remote actors. It also does not force developers to write actor in a peculiar way, allowing standard OO pattern like inheritance or composition to be applied. Not to mention type safety with TypeScript so that errors can be identified faster and developers will have full support on their IDE for feature like auto-completion and such.
Captions: 
	00:00:02,490 --> 00:00:08,960
[Music]

00:00:12,219 --> 00:00:19,310
well good morning everyone it's really

00:00:15,650 --> 00:00:20,810
exciting to be here is a short

00:00:19,310 --> 00:00:22,939
introduction about myself my name is

00:00:20,810 --> 00:00:24,470
this my hobby mohammad i'm software

00:00:22,939 --> 00:00:26,840
engineering working for mendax as a

00:00:24,470 --> 00:00:28,550
company in netherlands and just like any

00:00:26,840 --> 00:00:29,869
other technology company we're always

00:00:28,550 --> 00:00:34,130
hiring so if you're looking for

00:00:29,869 --> 00:00:36,170
something just talk to me afterwards I'm

00:00:34,130 --> 00:00:38,059
going to talk about actor/model

00:00:36,170 --> 00:00:41,660
on JavaScript environment and the

00:00:38,059 --> 00:00:44,480
library that we built on that basis

00:00:41,660 --> 00:00:46,940
which is called actrix so just like what

00:00:44,480 --> 00:00:49,970
what mission wastes rot say to yesterday

00:00:46,940 --> 00:00:52,460
in the mainstage it's it's nice to be

00:00:49,970 --> 00:00:54,650
able to give ideas and trying to inspire

00:00:52,460 --> 00:00:56,570
other people with my talk so it's not

00:00:54,650 --> 00:00:59,570
necessarily about promotion of the

00:00:56,570 --> 00:01:02,210
library itself is about inspire others

00:00:59,570 --> 00:01:04,100
but that would pretty much depend on

00:01:02,210 --> 00:01:09,340
whether I can stop my knee from shaking

00:01:04,100 --> 00:01:09,340
the next 15 minutes so let's let's go

00:01:09,759 --> 00:01:15,320
that's a bit unfortunate but what it

00:01:12,140 --> 00:01:17,720
says there it's a synchronous process is

00:01:15,320 --> 00:01:20,870
hard so I'm coming from Java background

00:01:17,720 --> 00:01:24,470
and well especially there when I was

00:01:20,870 --> 00:01:27,229
working there's not much a synchronous

00:01:24,470 --> 00:01:29,060
API or you basically see mostly

00:01:27,229 --> 00:01:31,130
synchronous things and when I start

00:01:29,060 --> 00:01:33,799
doing things in in JavaScript or in

00:01:31,130 --> 00:01:36,500
typescript then you cannot really hide

00:01:33,799 --> 00:01:39,320
from doing things in a synchronous way

00:01:36,500 --> 00:01:41,030
and it's not just hard to write but also

00:01:39,320 --> 00:01:43,549
especially it's difficult to reason

00:01:41,030 --> 00:01:44,960
about like sometimes you you just don't

00:01:43,549 --> 00:01:48,020
know anymore what's what's happening

00:01:44,960 --> 00:01:49,729
there because well the flow the flow of

00:01:48,020 --> 00:01:52,070
control is not visible on the code you

00:01:49,729 --> 00:01:55,340
can't see it there this is probably also

00:01:52,070 --> 00:01:57,710
why well we in JavaScript start with

00:01:55,340 --> 00:02:01,549
this callback we have a callback hell

00:01:57,710 --> 00:02:04,040
and then used their promise things are

00:02:01,549 --> 00:02:06,799
start to improve a bit and then

00:02:04,040 --> 00:02:09,409
eventually I think wait which is like

00:02:06,799 --> 00:02:12,140
quite quite a good situation but it's

00:02:09,409 --> 00:02:14,480
it's it doesn't cover everything yet

00:02:12,140 --> 00:02:17,660
there are still some challenge that we

00:02:14,480 --> 00:02:21,980
have when we're writing a synchronous

00:02:17,660 --> 00:02:26,930
could behavior in JavaScript this is an

00:02:21,980 --> 00:02:30,140
example of a chop of a chatroom here I'm

00:02:26,930 --> 00:02:32,630
creating a mock function I call it a

00:02:30,140 --> 00:02:34,640
connect so basically when you want to

00:02:32,630 --> 00:02:38,330
have your code to connect to a chatroom

00:02:34,640 --> 00:02:40,610
server this is basically just a code

00:02:38,330 --> 00:02:42,950
that will resolve somewhere between 0

00:02:40,610 --> 00:02:46,220
milliseconds to 2,000 milliseconds so

00:02:42,950 --> 00:02:49,370
nothing special here and here is the

00:02:46,220 --> 00:02:51,980
implementation I call it just a naive

00:02:49,370 --> 00:02:53,690
chat user where you have a listener here

00:02:51,980 --> 00:02:55,430
don't pay too much attention to it this

00:02:53,690 --> 00:02:58,100
is just a binding to the UI you can use

00:02:55,430 --> 00:02:59,870
whatever you want to use and there is a

00:02:58,100 --> 00:03:02,660
method that is called subscribe to room

00:02:59,870 --> 00:03:04,940
which will trigger the asynchronous call

00:03:02,660 --> 00:03:08,840
to the connect function that we that I

00:03:04,940 --> 00:03:11,060
saw earlier and afterwards triggering

00:03:08,840 --> 00:03:13,820
the callback listener and sending a

00:03:11,060 --> 00:03:16,270
message that you are connected to room

00:03:13,820 --> 00:03:20,660
something

00:03:16,270 --> 00:03:23,209
and here's another short code which is

00:03:20,660 --> 00:03:25,610
pretty obvious first part is when you

00:03:23,209 --> 00:03:28,220
instantiate the the object of a knife

00:03:25,610 --> 00:03:31,370
chat user with a callback that you want

00:03:28,220 --> 00:03:33,890
to provide and also the part where

00:03:31,370 --> 00:03:35,959
you're subscribing to a specific room

00:03:33,890 --> 00:03:40,120
that you trigger from an event like

00:03:35,959 --> 00:03:42,860
clicking or switching or whatever and

00:03:40,120 --> 00:03:45,320
this is a bit of a demo to show what

00:03:42,860 --> 00:03:48,470
kind of problem we have with that dead

00:03:45,320 --> 00:03:50,989
code when trying to do a synchronous

00:03:48,470 --> 00:03:54,560
call when switching from one room to

00:03:50,989 --> 00:03:56,709
another room so here you see there is a

00:03:54,560 --> 00:04:00,110
radio button basically three options

00:03:56,709 --> 00:04:03,050
from 1 to 3 so you're trying to connect

00:04:00,110 --> 00:04:05,300
one of the room and when you click to

00:04:03,050 --> 00:04:08,900
one room and then you get connected it

00:04:05,300 --> 00:04:12,320
will print a message to the screen but

00:04:08,900 --> 00:04:16,640
as you can see once I start to click

00:04:12,320 --> 00:04:19,070
like crazy switching between rooms at

00:04:16,640 --> 00:04:20,530
the end you see that a message that you

00:04:19,070 --> 00:04:23,510
are connected to room number 1 but my

00:04:20,530 --> 00:04:27,050
radio button actually in the rule number

00:04:23,510 --> 00:04:28,970
2 this is because of the situation with

00:04:27,050 --> 00:04:32,869
a synchronous a call you will never know

00:04:28,970 --> 00:04:35,399
which call that you trigger will be

00:04:32,869 --> 00:04:37,769
coming in what what kind of order so you

00:04:35,399 --> 00:04:41,339
don't know you don't have a much control

00:04:37,769 --> 00:04:48,269
over that there is a simple solution for

00:04:41,339 --> 00:04:50,429
this by just adding adding an ID and

00:04:48,269 --> 00:04:52,469
then you you keep that IDU keep

00:04:50,429 --> 00:04:54,569
incrementing it whenever the subscribe

00:04:52,469 --> 00:04:57,449
to room method is being triggered and

00:04:54,569 --> 00:04:58,169
then at the end of the asynchronous call

00:04:57,449 --> 00:05:01,709
you check it

00:04:58,169 --> 00:05:03,929
see if that same ID as you start in the

00:05:01,709 --> 00:05:05,789
beginning and if it's the case then you

00:05:03,929 --> 00:05:08,999
can continue with the triggering the

00:05:05,789 --> 00:05:11,009
callback but otherwise just yeah skip it

00:05:08,999 --> 00:05:16,079
and then because you know that it's not

00:05:11,009 --> 00:05:20,609
the latest callback that you actually

00:05:16,079 --> 00:05:25,139
trigger from the user interface here's a

00:05:20,609 --> 00:05:27,299
bit of a demo of that solution now you

00:05:25,139 --> 00:05:29,039
see there is much less message because a

00:05:27,299 --> 00:05:32,609
lot of message are being ignored because

00:05:29,039 --> 00:05:37,199
the ID is no longer equal to the latest

00:05:32,609 --> 00:05:40,259
one that you trigger so it kind of works

00:05:37,199 --> 00:05:42,749
right it works like we expected but I

00:05:40,259 --> 00:05:48,299
would argue that and this is not the

00:05:42,749 --> 00:05:50,339
best solution one you have to put a

00:05:48,299 --> 00:05:54,089
check every time you make a synchronous

00:05:50,339 --> 00:05:55,739
call to actually see if it's still the

00:05:54,089 --> 00:05:57,389
continuation of the latest call that

00:05:55,739 --> 00:05:59,309
you're making imagine if you have much

00:05:57,389 --> 00:06:01,589
more complex code more a synchronous

00:05:59,309 --> 00:06:04,769
call there then you have to put it

00:06:01,589 --> 00:06:07,319
everywhere and also it's it's still a

00:06:04,769 --> 00:06:09,029
bit difficult to process in your head

00:06:07,319 --> 00:06:10,289
because every time you work on this

00:06:09,029 --> 00:06:12,029
method you have to think about that

00:06:10,289 --> 00:06:14,459
situation again or you do something

00:06:12,029 --> 00:06:16,049
different like blocking the UI but

00:06:14,459 --> 00:06:21,479
that's completely different discussion I

00:06:16,049 --> 00:06:23,369
think so before we are talking about how

00:06:21,479 --> 00:06:24,659
we solve this in a better way I would

00:06:23,369 --> 00:06:28,349
like to talk a little bit about the

00:06:24,659 --> 00:06:34,139
actor model itself so what is an actor

00:06:28,349 --> 00:06:36,899
model so an actor model is a model that

00:06:34,139 --> 00:06:39,059
treat actors as the universal primitives

00:06:36,899 --> 00:06:41,759
of concurrent computation it's quite a

00:06:39,059 --> 00:06:43,589
mouthful it's not really necessary to

00:06:41,759 --> 00:06:45,139
understand the entire thing but this is

00:06:43,589 --> 00:06:48,470
something that you also see

00:06:45,139 --> 00:06:53,650
in other environment like a small talk

00:06:48,470 --> 00:06:58,939
in JVM with with akka or in Erlang and

00:06:53,650 --> 00:07:01,219
what is actor itself so actor is like

00:06:58,939 --> 00:07:02,810
it's like an object it's a bit similar

00:07:01,219 --> 00:07:04,639
to an object it's a building block for

00:07:02,810 --> 00:07:08,539
application so you can build your

00:07:04,639 --> 00:07:11,389
application based on based on actors but

00:07:08,539 --> 00:07:13,699
instead of in something inside

00:07:11,389 --> 00:07:16,099
inside it like what you usually do with

00:07:13,699 --> 00:07:19,039
an object you're sending message to it

00:07:16,099 --> 00:07:24,259
and this message is being sent as in a

00:07:19,039 --> 00:07:26,810
synchronous way and actor or handles

00:07:24,259 --> 00:07:29,479
those message in a sequential fashion so

00:07:26,810 --> 00:07:32,180
it never does two things at the same

00:07:29,479 --> 00:07:35,150
time but the message that is being sent

00:07:32,180 --> 00:07:37,729
to an actor will actually be cued in

00:07:35,150 --> 00:07:40,639
something that sometimes we call the

00:07:37,729 --> 00:07:44,629
mailbox and then the actor can process

00:07:40,639 --> 00:07:49,490
that sequentially according to what it

00:07:44,629 --> 00:07:53,240
wish and an actor also keep local states

00:07:49,490 --> 00:07:55,460
so it doesn't share it states or even

00:07:53,240 --> 00:07:59,479
allow other actors to mutate it states

00:07:55,460 --> 00:08:02,599
directly they have to use the messaging

00:07:59,479 --> 00:08:07,009
mechanism to be able to influence one

00:08:02,599 --> 00:08:13,219
another and actor leaves inside an actor

00:08:07,009 --> 00:08:15,409
system so like historically why why do

00:08:13,219 --> 00:08:18,050
we use actor model like in the

00:08:15,409 --> 00:08:20,839
multi-threaded environment initially

00:08:18,050 --> 00:08:24,020
there is a need to solve concurrency

00:08:20,839 --> 00:08:26,599
problem and the traditional solution

00:08:24,020 --> 00:08:30,440
with with thread base in the multitrader

00:08:26,599 --> 00:08:34,880
environments they're using lock so

00:08:30,440 --> 00:08:38,599
basically whenever a code needs to reach

00:08:34,880 --> 00:08:41,779
a certain value that is being shared by

00:08:38,599 --> 00:08:44,750
multiple threads then one of the process

00:08:41,779 --> 00:08:47,779
will lock access to depth variables and

00:08:44,750 --> 00:08:50,029
causing the other process to wait until

00:08:47,779 --> 00:08:52,160
that's done this this is causing a lot

00:08:50,029 --> 00:08:54,110
of problems one of them is the resources

00:08:52,160 --> 00:08:55,910
because thread trail is not trade are

00:08:54,110 --> 00:08:57,680
not cheap so there is a limited amount

00:08:55,910 --> 00:09:00,410
of threads you can you can have

00:08:57,680 --> 00:09:03,080
in the system you can get into a

00:09:00,410 --> 00:09:04,670
deadlock situation because one process

00:09:03,080 --> 00:09:06,310
block another and the other block

00:09:04,670 --> 00:09:10,040
another and then you create a circular

00:09:06,310 --> 00:09:12,080
waiting and it also results in horrible

00:09:10,040 --> 00:09:16,640
code which is also really hard to follow

00:09:12,080 --> 00:09:18,140
and to maintain what about extra model

00:09:16,640 --> 00:09:21,020
in JavaScript like what's the state of

00:09:18,140 --> 00:09:23,630
actor model in JavaScript I try to look

00:09:21,020 --> 00:09:28,000
around a bit but most of the

00:09:23,630 --> 00:09:30,380
implementation one they are not very

00:09:28,000 --> 00:09:32,240
much adopted so there are some adoption

00:09:30,380 --> 00:09:35,360
but not not that much and they are very

00:09:32,240 --> 00:09:37,399
much design for the node.js environment

00:09:35,360 --> 00:09:39,950
only but the asynchronous problem is not

00:09:37,399 --> 00:09:44,060
some problem that we only have in

00:09:39,950 --> 00:09:46,520
node.js but also in the browser this is

00:09:44,060 --> 00:09:52,910
why we decided to build a library called

00:09:46,520 --> 00:09:54,890
actrix so this is libraries available as

00:09:52,910 --> 00:09:55,490
an open source project you can check it

00:09:54,890 --> 00:09:58,070
later

00:09:55,490 --> 00:09:59,300
I would not suggest you to use it in

00:09:58,070 --> 00:10:01,610
production yet because it is still

00:09:59,300 --> 00:10:04,310
pretty much in very early stage although

00:10:01,610 --> 00:10:09,820
in in mendax we are we are using them so

00:10:04,310 --> 00:10:13,070
but we build it so it's up to us the

00:10:09,820 --> 00:10:14,950
chat room example again but now we are

00:10:13,070 --> 00:10:17,750
trying to implement it in actrix

00:10:14,950 --> 00:10:19,670
as you can see in the code there is not

00:10:17,750 --> 00:10:22,790
much difference between this code and

00:10:19,670 --> 00:10:24,050
the code that I saw earlier with with

00:10:22,790 --> 00:10:27,980
the naive implementation of a

00:10:24,050 --> 00:10:30,680
synchronous process the things that

00:10:27,980 --> 00:10:35,779
differ here is that the implementation

00:10:30,680 --> 00:10:38,480
extends an actor but the subscribe to

00:10:35,779 --> 00:10:40,990
room implementation here is exactly the

00:10:38,480 --> 00:10:45,650
same as we see in the previous one and

00:10:40,990 --> 00:10:48,680
let's see what happened well there there

00:10:45,650 --> 00:10:50,839
is a other synthetic things like how you

00:10:48,680 --> 00:10:52,459
create an actor you create an actor

00:10:50,839 --> 00:10:53,959
system first and then you korean actor

00:10:52,459 --> 00:10:56,839
giving it a template which is basically

00:10:53,959 --> 00:10:59,839
just a class name giving some parameter

00:10:56,839 --> 00:11:02,390
options where we pass the call back to

00:10:59,839 --> 00:11:06,020
the reactor so that the UI can update

00:11:02,390 --> 00:11:08,959
itself accordingly and the most

00:11:06,020 --> 00:11:11,330
interesting part is how you trigger or

00:11:08,959 --> 00:11:13,760
actually sending message

00:11:11,330 --> 00:11:16,970
so you're either you are sending a

00:11:13,760 --> 00:11:18,650
message in a fire-and-forget fashion so

00:11:16,970 --> 00:11:20,900
you send it and then you don't care what

00:11:18,650 --> 00:11:24,560
happened we did later or you're actually

00:11:20,900 --> 00:11:26,300
asking something to an actor where you

00:11:24,560 --> 00:11:28,310
actually want to await and you were

00:11:26,300 --> 00:11:30,500
you're interested in seeing if there is

00:11:28,310 --> 00:11:33,050
any response from that actor

00:11:30,500 --> 00:11:35,510
that this difference might be subtle but

00:11:33,050 --> 00:11:39,830
depending on the use case it's important

00:11:35,510 --> 00:11:42,290
to think about it so a bit of a demo of

00:11:39,830 --> 00:11:47,860
that implementation still the same

00:11:42,290 --> 00:11:52,070
examples chatroom examples you see here

00:11:47,860 --> 00:11:55,160
I'm switching between between the room

00:11:52,070 --> 00:11:59,600
and Indian it connected to the room too

00:11:55,160 --> 00:12:00,920
as we see in the UI as well but well you

00:11:59,600 --> 00:12:05,030
you must have noticed something

00:12:00,920 --> 00:12:07,430
something else here as well like in the

00:12:05,030 --> 00:12:10,520
end you are in the right state you're in

00:12:07,430 --> 00:12:12,080
the correct room but at the same time it

00:12:10,520 --> 00:12:14,870
doesn't give you will give a good

00:12:12,080 --> 00:12:18,170
feedback this is due to the sequence

00:12:14,870 --> 00:12:20,000
you're processing that every effort

00:12:18,170 --> 00:12:23,570
process takes a certain amount of time

00:12:20,000 --> 00:12:26,420
we implement that in something between 0

00:12:23,570 --> 00:12:30,530
to 2000 milliseconds and then when you

00:12:26,420 --> 00:12:32,180
actually make a multiple cause rapidly

00:12:30,530 --> 00:12:34,850
then you're filling the mailbox and

00:12:32,180 --> 00:12:36,770
since actor process the mailbox one by

00:12:34,850 --> 00:12:41,180
one there is some kind of delay on your

00:12:36,770 --> 00:12:42,910
user interface so sequential process is

00:12:41,180 --> 00:12:45,320
really nice it's solve the problem of

00:12:42,910 --> 00:12:48,440
the difficulties of trying to reason

00:12:45,320 --> 00:12:52,970
your code but on the other hand the user

00:12:48,440 --> 00:12:56,300
experience is it's not the best so well

00:12:52,970 --> 00:12:58,670
it's not the end of the world so we can

00:12:56,300 --> 00:13:01,250
still look into what is possible in an

00:12:58,670 --> 00:13:03,440
injector I was actually expecting some

00:13:01,250 --> 00:13:06,230
kind of reaction here because this is

00:13:03,440 --> 00:13:09,350
wrong this should be the one so we need

00:13:06,230 --> 00:13:10,970
to try to optimize the things what is

00:13:09,350 --> 00:13:16,310
possible with this with this approach

00:13:10,970 --> 00:13:18,910
what can we do better so the one of the

00:13:16,310 --> 00:13:22,310
most obvious way is to to do

00:13:18,910 --> 00:13:24,030
short-circuiting so in the method itself

00:13:22,310 --> 00:13:28,560
to subscribe to room method that

00:13:24,030 --> 00:13:30,630
so earlier we can easily just check by

00:13:28,560 --> 00:13:33,000
picking into the mailbox to see if there

00:13:30,630 --> 00:13:36,390
are more message there with the same

00:13:33,000 --> 00:13:39,450
type in this case it was a subscribe to

00:13:36,390 --> 00:13:40,800
room and if there are messaged there

00:13:39,450 --> 00:13:42,780
which is at the same time you probably

00:13:40,800 --> 00:13:45,090
don't want to continue with executing

00:13:42,780 --> 00:13:46,830
the current message that you're handling

00:13:45,090 --> 00:13:53,100
now because you know that it will be

00:13:46,830 --> 00:13:55,440
outdated anyway but what happened if we

00:13:53,100 --> 00:13:58,230
already actually running the process and

00:13:55,440 --> 00:14:01,470
the process is not just like two seconds

00:13:58,230 --> 00:14:05,160
but it can be much longer so we probably

00:14:01,470 --> 00:14:10,020
need some kind of cancellation strategy

00:14:05,160 --> 00:14:13,830
and in actrix cancellation is possible

00:14:10,020 --> 00:14:15,930
because we have a handler for every time

00:14:13,830 --> 00:14:17,790
there is a new message coming into the

00:14:15,930 --> 00:14:18,810
actor and this is called the all new

00:14:17,790 --> 00:14:21,690
message

00:14:18,810 --> 00:14:23,880
you can pick into the the mailbox you

00:14:21,690 --> 00:14:27,270
can see what type of message there are

00:14:23,880 --> 00:14:29,130
and you can also decide to trigger the

00:14:27,270 --> 00:14:31,020
function that is provided in the act and

00:14:29,130 --> 00:14:33,360
the actrix in the actors actor we just

00:14:31,020 --> 00:14:35,340
called the cancel for current execution

00:14:33,360 --> 00:14:37,890
but how is this possible

00:14:35,340 --> 00:14:39,480
I mean there is no cancellation in

00:14:37,890 --> 00:14:43,250
promise or at least there is a lot of

00:14:39,480 --> 00:14:43,250
conversation about it but nothing really

00:14:43,340 --> 00:14:50,460
materialized but in actor and actress we

00:14:47,700 --> 00:14:52,980
provide a function to turn generators

00:14:50,460 --> 00:14:56,040
into a consumable promise so this is

00:14:52,980 --> 00:14:59,010
exactly the same as as normal promise

00:14:56,040 --> 00:15:00,840
but with a cancel feature the only

00:14:59,010 --> 00:15:05,780
difference here is that instead of using

00:15:00,840 --> 00:15:07,800
a sync syntax we're using star which is

00:15:05,780 --> 00:15:09,990
something that you use to create a

00:15:07,800 --> 00:15:13,050
generator and instead of using a wait

00:15:09,990 --> 00:15:14,730
you're using yield and then everything

00:15:13,050 --> 00:15:19,830
every everything else are exactly the

00:15:14,730 --> 00:15:23,070
same as the code that we saw earlier to

00:15:19,830 --> 00:15:28,070
PO to put them all together it's like

00:15:23,070 --> 00:15:32,010
how it looks like the chat user actor

00:15:28,070 --> 00:15:34,740
implements an actor it has in it method

00:15:32,010 --> 00:15:36,700
where you set the callback to the UI you

00:15:34,740 --> 00:15:40,000
have their own new message handler

00:15:36,700 --> 00:15:42,490
to handle a new incoming message in case

00:15:40,000 --> 00:15:44,410
that you want you want to cancel current

00:15:42,490 --> 00:15:46,920
execution and you also have this

00:15:44,410 --> 00:15:54,670
slightly altered subscribe to room

00:15:46,920 --> 00:15:58,960
method so a demo again same demo with

00:15:54,670 --> 00:16:02,650
the optimized actor solution and you see

00:15:58,960 --> 00:16:04,560
here whenever you're switching rapidly

00:16:02,650 --> 00:16:07,330
you don't actually continue with the

00:16:04,560 --> 00:16:10,510
execution but you just go to the next

00:16:07,330 --> 00:16:15,310
one because you're either canceling the

00:16:10,510 --> 00:16:20,710
currently running process or your source

00:16:15,310 --> 00:16:21,760
including the code itself so well it's

00:16:20,710 --> 00:16:23,200
nice can we do better

00:16:21,760 --> 00:16:26,650
of course because it's very generic

00:16:23,200 --> 00:16:29,010
solution and it's we can simply just

00:16:26,650 --> 00:16:32,110
make it into the the actor itself

00:16:29,010 --> 00:16:33,970
something that I called a strategy so

00:16:32,110 --> 00:16:36,280
basically if you decide that you want to

00:16:33,970 --> 00:16:38,950
have this strategy to ignore order

00:16:36,280 --> 00:16:41,680
message with the same type then you

00:16:38,950 --> 00:16:44,230
don't have to put in all the extra

00:16:41,680 --> 00:16:46,270
boilerplate from before and instead this

00:16:44,230 --> 00:16:47,410
is the entire code that you will need to

00:16:46,270 --> 00:16:51,700
have you still need to have the

00:16:47,410 --> 00:16:54,670
cancellable promise implemented in

00:16:51,700 --> 00:17:00,450
generator but the the on new message

00:16:54,670 --> 00:17:04,839
handler is no longer necessary here so

00:17:00,450 --> 00:17:07,329
then I am I'm saying like at the end

00:17:04,839 --> 00:17:09,280
it's possible to try to generally solve

00:17:07,329 --> 00:17:12,370
the sequence problem because actor model

00:17:09,280 --> 00:17:14,949
itself that approach itself it gives a

00:17:12,370 --> 00:17:17,140
better control of a flow execution so

00:17:14,949 --> 00:17:20,050
instead of doing things like the way

00:17:17,140 --> 00:17:23,100
object does actor have a better control

00:17:20,050 --> 00:17:23,100
because they are actually

00:17:23,439 --> 00:17:28,569
executing things in exocrine dysfunction

00:17:25,750 --> 00:17:30,549
and they're keeping the queue keeping

00:17:28,569 --> 00:17:32,320
the queue on their own hand so they can

00:17:30,549 --> 00:17:34,570
decide and they can do interesting

00:17:32,320 --> 00:17:40,200
things with it like what I've shown

00:17:34,570 --> 00:17:43,000
earlier ok well that's kind of example

00:17:40,200 --> 00:17:47,110
but we haven't really implemented the

00:17:43,000 --> 00:17:49,780
chat itself it's just a method to try to

00:17:47,110 --> 00:17:54,360
connect to a mock function but let's go

00:17:49,780 --> 00:17:57,429
and try to implement the rest so I tried

00:17:54,360 --> 00:18:00,880
to implement it by first making a design

00:17:57,429 --> 00:18:02,909
diagram here you see a user actor and

00:18:00,880 --> 00:18:07,419
then there are more user actors which

00:18:02,909 --> 00:18:09,789
can probably recite on different

00:18:07,419 --> 00:18:12,010
browsers and then you have from actor

00:18:09,789 --> 00:18:15,640
since we have three rooms then I call

00:18:12,010 --> 00:18:19,179
them room actor one two and three here

00:18:15,640 --> 00:18:22,000
you have arrows connecting between the

00:18:19,179 --> 00:18:23,860
actors and also something there which is

00:18:22,000 --> 00:18:26,020
not really feasible but basically it

00:18:23,860 --> 00:18:28,809
says post and subscribe to those are the

00:18:26,020 --> 00:18:31,659
type of message that you want to use to

00:18:28,809 --> 00:18:35,980
bind the actor with the non actor word

00:18:31,659 --> 00:18:38,080
which is in this case UI itself from an

00:18:35,980 --> 00:18:39,820
actor to a room you can subscribe you

00:18:38,080 --> 00:18:42,100
can subscribe and you can also post a

00:18:39,820 --> 00:18:44,250
message and room can send a new message

00:18:42,100 --> 00:18:48,130
whenever there is a new one coming and

00:18:44,250 --> 00:18:51,669
but that seems to be very simplistic

00:18:48,130 --> 00:18:53,919
because those actors are located in

00:18:51,669 --> 00:18:57,669
different place and the user actor will

00:18:53,919 --> 00:18:59,650
be recites in browsers but the room

00:18:57,669 --> 00:19:02,460
actors they are typically on the node.js

00:18:59,650 --> 00:19:07,450
environment on the server side

00:19:02,460 --> 00:19:09,220
well that generally makes things a bit

00:19:07,450 --> 00:19:11,380
harder because then you have to start

00:19:09,220 --> 00:19:13,630
building all this piping between the

00:19:11,380 --> 00:19:16,240
client and the server all this code that

00:19:13,630 --> 00:19:19,120
you have to implement but it doesn't

00:19:16,240 --> 00:19:23,190
have to be that way with actor model

00:19:19,120 --> 00:19:26,890
because actor model can make it simpler

00:19:23,190 --> 00:19:29,500
well same picture as before so basically

00:19:26,890 --> 00:19:33,340
what happened here the user actor

00:19:29,500 --> 00:19:36,070
resides in in a browser which has an

00:19:33,340 --> 00:19:38,530
actor system in the browser and

00:19:36,070 --> 00:19:41,920
room actors they have actor system on

00:19:38,530 --> 00:19:44,860
the UH Nanaji is what if we can just

00:19:41,920 --> 00:19:46,540
like merge them together instead of

00:19:44,860 --> 00:19:48,820
making the complexity resides on the

00:19:46,540 --> 00:19:51,940
communication we can just abstract that

00:19:48,820 --> 00:19:55,030
away by connecting to a actor actor

00:19:51,940 --> 00:19:56,560
system together and the actors

00:19:55,030 --> 00:19:58,810
themselves the implementation of actors

00:19:56,560 --> 00:20:02,230
themselves then they don't need to know

00:19:58,810 --> 00:20:04,660
exactly where an actor actually reside

00:20:02,230 --> 00:20:07,210
so the communication between actors can

00:20:04,660 --> 00:20:12,460
be done as if they're in the same

00:20:07,210 --> 00:20:16,150
machine so this is a code to bind to

00:20:12,460 --> 00:20:17,770
actor system together using socket IO

00:20:16,150 --> 00:20:20,110
this is just an example of

00:20:17,770 --> 00:20:22,600
implementation I have an idea to

00:20:20,110 --> 00:20:24,400
actually try to implement this in many

00:20:22,600 --> 00:20:27,210
other ways like using HTTP or other

00:20:24,400 --> 00:20:32,230
things but this is a simple example and

00:20:27,210 --> 00:20:35,710
the implementation of the user actors we

00:20:32,230 --> 00:20:39,760
have the SUBSCRIBE function which is the

00:20:35,710 --> 00:20:41,800
same as before we have well there are

00:20:39,760 --> 00:20:45,010
some extension here because we also want

00:20:41,800 --> 00:20:46,780
to subscribe to the previous room if the

00:20:45,010 --> 00:20:50,410
users already subscribed to another room

00:20:46,780 --> 00:20:53,650
before we can also post a new message

00:20:50,410 --> 00:20:57,160
which is a fairly straightforward call

00:20:53,650 --> 00:20:59,110
to the room actor with the message that

00:20:57,160 --> 00:21:01,840
we have and there's also a handler

00:20:59,110 --> 00:21:05,260
whenever you receive a new message from

00:21:01,840 --> 00:21:06,820
the room actor its implementation for

00:21:05,260 --> 00:21:09,640
the room actor you have a subscribe

00:21:06,820 --> 00:21:11,890
method whenever a user actor try to

00:21:09,640 --> 00:21:15,550
subscribe for message you have

00:21:11,890 --> 00:21:19,600
unsubscribe as well and also when you

00:21:15,550 --> 00:21:22,870
want to post something then it will it

00:21:19,600 --> 00:21:24,940
will go through the list of subscription

00:21:22,870 --> 00:21:27,010
and broadcast that message again this

00:21:24,940 --> 00:21:30,100
this coat is well it's not important to

00:21:27,010 --> 00:21:32,080
follow all of them right now I already

00:21:30,100 --> 00:21:34,000
have some repository which shows the

00:21:32,080 --> 00:21:36,190
examples on how this can be used not

00:21:34,000 --> 00:21:42,820
exactly the same as this one but pretty

00:21:36,190 --> 00:21:46,570
similar so a little bit of demo on that

00:21:42,820 --> 00:21:49,390
one you see two browsers here so they

00:21:46,570 --> 00:21:50,719
are really two browsers I didn't it

00:21:49,390 --> 00:21:53,059
the first

00:21:50,719 --> 00:21:55,009
immediately connect to the room tree and

00:21:53,059 --> 00:21:57,229
then say something but because the other

00:21:55,009 --> 00:21:58,849
browser hasn't been connected yet you

00:21:57,229 --> 00:22:00,739
don't see anything but once they are

00:21:58,849 --> 00:22:03,379
connected together and they start

00:22:00,739 --> 00:22:07,549
sending message the update can happen on

00:22:03,379 --> 00:22:09,529
both browsers immediately so it's it's

00:22:07,549 --> 00:22:10,069
pretty simple implementation for a

00:22:09,529 --> 00:22:13,759
chatroom

00:22:10,069 --> 00:22:16,099
which it's it's it's not that hard to do

00:22:13,759 --> 00:22:17,139
once you follow the entire concept of

00:22:16,099 --> 00:22:21,139
actor/model

00:22:17,139 --> 00:22:23,569
and these things are possible because

00:22:21,139 --> 00:22:25,759
the message passing mechanism the

00:22:23,569 --> 00:22:28,849
asynchronous messaging it enables

00:22:25,759 --> 00:22:30,679
uniform communication patterns for intra

00:22:28,849 --> 00:22:32,359
and interactor system communication so

00:22:30,679 --> 00:22:34,459
it doesn't really matter whether the

00:22:32,359 --> 00:22:36,349
actor that you need to reach actually

00:22:34,459 --> 00:22:38,239
resides within the same actor system or

00:22:36,349 --> 00:22:40,099
in different actor system you can talk

00:22:38,239 --> 00:22:42,739
to them as if they are the same thing

00:22:40,099 --> 00:22:45,979
and it hides the complexities are kind

00:22:42,739 --> 00:22:52,699
of hidden away by the implementation of

00:22:45,979 --> 00:22:56,179
actor model actrix here well that's that

00:22:52,699 --> 00:22:58,369
there are some patterns but are there

00:22:56,179 --> 00:22:59,989
more yeah probably more there are a lot

00:22:58,369 --> 00:23:02,659
of things that you can do with with

00:22:59,989 --> 00:23:04,819
actor model you can create a

00:23:02,659 --> 00:23:09,499
fault-tolerant system with supervisor

00:23:04,819 --> 00:23:11,389
strategy there are also ideas of doing

00:23:09,499 --> 00:23:14,239
actors in cluster so you have multiple

00:23:11,389 --> 00:23:16,219
backends instantiate it and you can talk

00:23:14,239 --> 00:23:19,909
to each other without actually needing

00:23:16,219 --> 00:23:23,749
to know where they are and there are

00:23:19,909 --> 00:23:25,699
also a possibility to make delivery or

00:23:23,749 --> 00:23:28,219
order guarantee a bit more on a generic

00:23:25,699 --> 00:23:33,889
level when you're talking about

00:23:28,219 --> 00:23:35,479
distributed actor system that's well

00:23:33,889 --> 00:23:38,920
that's all my presentation thank you for

00:23:35,479 --> 00:23:44,000
listening hopefully inspire some of you

00:23:38,920 --> 00:23:47,070
[Applause]

00:23:44,000 --> 00:23:49,140
yeah actually that's a great example of

00:23:47,070 --> 00:23:52,670
trying to apply some of these patterns

00:23:49,140 --> 00:23:55,800
from one language to another

00:23:52,670 --> 00:23:57,630
probably the risk of doing these is that

00:23:55,800 --> 00:23:59,400
maybe you don't know some of the

00:23:57,630 --> 00:24:01,440
patterns that we use in JavaScript

00:23:59,400 --> 00:24:04,380
that's true that that can do similar

00:24:01,440 --> 00:24:07,110
things but you know it's all a learning

00:24:04,380 --> 00:24:09,930
experience yeah okay

00:24:07,110 --> 00:24:12,960
so we have some questions and probably

00:24:09,930 --> 00:24:15,270
pointing to what I was saying let's take

00:24:12,960 --> 00:24:19,560
the first one so have you got any

00:24:15,270 --> 00:24:21,180
experience with Eric GS I did some few

00:24:19,560 --> 00:24:23,850
things with Eric's Java and look a

00:24:21,180 --> 00:24:26,970
little bit into rxjs so I don't I don't

00:24:23,850 --> 00:24:31,800
have like a very extensive experience

00:24:26,970 --> 00:24:35,280
with rxjs but it's still like it still

00:24:31,800 --> 00:24:39,540
have some differences like you can use

00:24:35,280 --> 00:24:41,640
rxjs for for few things first you you

00:24:39,540 --> 00:24:44,040
have to change your way of doing things

00:24:41,640 --> 00:24:45,900
with rxjs because it's basically like a

00:24:44,040 --> 00:24:47,340
functional reactive programming and it

00:24:45,900 --> 00:24:51,150
is completely different from if you are

00:24:47,340 --> 00:24:52,980
coming from the imperative way of doing

00:24:51,150 --> 00:24:55,290
things so I don't want to push that to

00:24:52,980 --> 00:24:58,650
people who prefer to do things in the

00:24:55,290 --> 00:25:01,170
imperative way and secondly I think even

00:24:58,650 --> 00:25:03,360
with Eric's yes you can still have some

00:25:01,170 --> 00:25:05,820
of problems so some problems can be

00:25:03,360 --> 00:25:07,740
fixed with rxjs things like it has the

00:25:05,820 --> 00:25:09,450
bound so for example it can prevent you

00:25:07,740 --> 00:25:11,700
from actually triggering things in a

00:25:09,450 --> 00:25:17,370
rapid fashion in a short time but it

00:25:11,700 --> 00:25:21,030
doesn't really give you control over a

00:25:17,370 --> 00:25:24,930
sequence ility of execution at least

00:25:21,030 --> 00:25:27,810
that's what I understand sure okay so

00:25:24,930 --> 00:25:29,850
let's see what what other questions we

00:25:27,810 --> 00:25:33,090
have I think we have enough time we are

00:25:29,850 --> 00:25:35,360
going into the break just next but here

00:25:33,090 --> 00:25:38,490
we have how do you test this type of

00:25:35,360 --> 00:25:42,930
applications this is this is a very good

00:25:38,490 --> 00:25:46,170
question so I don't have a very clear

00:25:42,930 --> 00:25:49,020
idea yet on how how to do that we do

00:25:46,170 --> 00:25:53,100
have some implementation of a actor

00:25:49,020 --> 00:25:54,690
actor test on our system because you can

00:25:53,100 --> 00:25:57,840
make your system running in production

00:25:54,690 --> 00:26:00,600
without testing them but it's it's still

00:25:57,840 --> 00:26:01,860
kind of case per case basis and that's

00:26:00,600 --> 00:26:03,419
one of the thing that I would like to

00:26:01,860 --> 00:26:05,070
improve in actrix to actually provide

00:26:03,419 --> 00:26:07,169
some kind of framework to make it easy

00:26:05,070 --> 00:26:09,600
for everyone to be able to test the

00:26:07,169 --> 00:26:12,120
director director that they implemented

00:26:09,600 --> 00:26:15,450
so very good questions I don't have to

00:26:12,120 --> 00:26:19,679
answer right now okay maybe we take the

00:26:15,450 --> 00:26:22,049
last one let's see can can the same kind

00:26:19,679 --> 00:26:24,210
of functionality be done with redux Agha

00:26:22,049 --> 00:26:27,299
are you familiar with I've heard about

00:26:24,210 --> 00:26:29,279
it not very familiar with Redux I think

00:26:27,299 --> 00:26:34,679
the similarities is that they're both

00:26:29,279 --> 00:26:36,779
use generator but well that's it I don't

00:26:34,679 --> 00:26:38,399
know much about it so I can't I can't

00:26:36,779 --> 00:26:40,710
really answer that question okay that's

00:26:38,399 --> 00:26:43,769
fine that's fine so if you have more

00:26:40,710 --> 00:26:47,100
questions you can reach him on the

00:26:43,769 --> 00:26:51,049
brakes or maybe later today but thanks a

00:26:47,100 --> 00:26:51,049

YouTube URL: https://www.youtube.com/watch?v=4PMVS_h4iR4


