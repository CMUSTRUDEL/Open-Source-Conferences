Title: Measuring and Summarizing Latencies using the Trace Event Subsystem - Tom Zanussi, Intel
Publication date: 2018-03-14
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	Measuring and Summarizing Latencies using the Trace Event Subsystem - Tom Zanussi, Intel

The RT-devel kernel has recently merged a patchset designed to replace the RT kernel's latency histogram feature with a new version built on top of a more generic 'inter-event' facility. This new 'inter-event' capability in turn builds on the general-purpose Trace Event subsystem, and is expected to be merged into the mainstream kernel at some point.

This presentation will describe the new capabilities from a set of real-world examples all the way down to the 'bare metal' of the event subsystem. It will also discuss how these new inter-event capabilities can be used with other tracing facilities, and will cover possible future tasks that can/should be done to up-level and in turn build further on this work.

About Tom Zanussi
Tom Zanussi is a software engineer at Intel's Open Source Technology Center. He's given talks on the subjects of embedded systems and tracing at various conferences in the past including ELC, OLS and the Intelligent Systems Conference, and has been an active contributor to the Linux kernel focusing on various areas within tracing and perf.
Captions: 
	00:00:00,030 --> 00:00:04,350
okay I guess we could start hi my name

00:00:03,120 --> 00:00:07,589
is tamas a new CEO I'm a software

00:00:04,350 --> 00:00:08,639
engineer at Intel and today we're going

00:00:07,589 --> 00:00:11,250
to be talking about measuring and

00:00:08,639 --> 00:00:16,139
summarizing latency is using the trace

00:00:11,250 --> 00:00:17,789
event subsystem I'll start off with a

00:00:16,139 --> 00:00:19,800
quick overview of trace events for

00:00:17,789 --> 00:00:25,070
people who may not be that familiar with

00:00:19,800 --> 00:00:26,880
it and then I'll jump right into

00:00:25,070 --> 00:00:31,529
functionality that's implemented by a

00:00:26,880 --> 00:00:33,809
patch set the inner event patch set that

00:00:31,529 --> 00:00:39,270
I posted upstream I think we're on

00:00:33,809 --> 00:00:41,489
version 9 now that implements basically

00:00:39,270 --> 00:00:44,969
inner event quantities and latency being

00:00:41,489 --> 00:00:48,870
the most important one of those I'll

00:00:44,969 --> 00:00:51,750
start with basic latency calculations

00:00:48,870 --> 00:00:57,170
and what you can do with them and then

00:00:51,750 --> 00:01:00,000
I'll move on to latency histograms and

00:00:57,170 --> 00:01:02,010
another new feature that this patch that

00:01:00,000 --> 00:01:06,090
implements which is synthetic events and

00:01:02,010 --> 00:01:09,900
how those basically enable the latency

00:01:06,090 --> 00:01:14,100
histograms then I'll talk about there's

00:01:09,900 --> 00:01:16,590
a object tracing tracking objects Layton

00:01:14,100 --> 00:01:20,850
sees I'm using a couple examples and

00:01:16,590 --> 00:01:24,119
then I'll I'll talk about Lacey latency

00:01:20,850 --> 00:01:26,729
tracing and reference to new another new

00:01:24,119 --> 00:01:28,680
patch that that just went up stream

00:01:26,729 --> 00:01:32,400
recently has it's been posted but it's

00:01:28,680 --> 00:01:36,600
not merged yet the Steve Ross sets

00:01:32,400 --> 00:01:39,540
function event spatula so I'm just a

00:01:36,600 --> 00:01:42,180
quick overview of trace events itself so

00:01:39,540 --> 00:01:44,520
Linux has a large set of trace of trace

00:01:42,180 --> 00:01:46,170
events these are just places in the

00:01:44,520 --> 00:01:50,159
kernel where it's you it may be useful

00:01:46,170 --> 00:01:54,320
to blog relevant information when

00:01:50,159 --> 00:01:56,689
execution hits those points and they're

00:01:54,320 --> 00:01:58,799
called trace events and there there are

00:01:56,689 --> 00:02:00,750
hundreds of those hundreds of them in

00:01:58,799 --> 00:02:05,250
the kernel at this point thousand maybe

00:02:00,750 --> 00:02:08,099
thousands a couple thousand okay

00:02:05,250 --> 00:02:09,539
so to make debatably to make those

00:02:08,099 --> 00:02:12,020
manageable they're grouped into

00:02:09,539 --> 00:02:12,020
subsystems

00:02:12,080 --> 00:02:18,780
sorry yeah I was forced I I couldn't get

00:02:17,280 --> 00:02:22,019
my Linux laptop hooked up so I'd use my

00:02:18,780 --> 00:02:26,280
window the one that's the work updating

00:02:22,019 --> 00:02:28,290
in the middle of my presentation but so

00:02:26,280 --> 00:02:30,540
anyway yeah so they're grouped into

00:02:28,290 --> 00:02:34,409
subsystems such as you know things like

00:02:30,540 --> 00:02:36,000
networking block etc and those are

00:02:34,409 --> 00:02:38,790
contained in a subdirectory under

00:02:36,000 --> 00:02:41,099
tracing events and then within each of

00:02:38,790 --> 00:02:45,989
those in each within each of those sub

00:02:41,099 --> 00:02:49,049
system directories are the directory for

00:02:45,989 --> 00:02:51,120
each event our event our directories for

00:02:49,049 --> 00:02:53,970
the events themselves on one for each

00:02:51,120 --> 00:02:59,489
event and within those directories are a

00:02:53,970 --> 00:03:03,659
set of files that describe and control

00:02:59,489 --> 00:03:06,870
that particular event so one of the one

00:03:03,659 --> 00:03:08,819
of the files one of those file is called

00:03:06,870 --> 00:03:11,099
the format file and it's an exhaustive

00:03:08,819 --> 00:03:14,430
description of everything that gets

00:03:11,099 --> 00:03:20,760
logged when that when that event has

00:03:14,430 --> 00:03:24,269
logged in the form of a set of field so

00:03:20,760 --> 00:03:27,269
by default an event the NMS data doesn't

00:03:24,269 --> 00:03:28,590
doesn't go doesn't go into a trace

00:03:27,269 --> 00:03:31,859
buffer it doesn't get logged anywhere

00:03:28,590 --> 00:03:36,410
unless it's exquisitely enabled and to

00:03:31,859 --> 00:03:39,299
do that you use one of the control files

00:03:36,410 --> 00:03:41,310
associated with the event or the

00:03:39,299 --> 00:03:43,500
subsystem called enable and you

00:03:41,310 --> 00:03:47,579
basically just echo one to that that

00:03:43,500 --> 00:03:48,930
file and after that point you're logging

00:03:47,579 --> 00:03:53,280
the events and you can go and look at

00:03:48,930 --> 00:03:57,299
the the output at any time by reading

00:03:53,280 --> 00:03:59,730
the trace file tracing the reading the

00:03:57,299 --> 00:04:04,919
trace buffer through this a tracing

00:03:59,730 --> 00:04:07,019
trace slash trace file and this isn't

00:04:04,919 --> 00:04:11,280
this is a thing here are a few examples

00:04:07,019 --> 00:04:13,549
of things that actually logged the

00:04:11,280 --> 00:04:16,289
basically when when record for each

00:04:13,549 --> 00:04:20,219
event and then associated with the

00:04:16,289 --> 00:04:23,940
records each record you see the the

00:04:20,219 --> 00:04:24,400
fields filled in according to what was

00:04:23,940 --> 00:04:32,490
in the form

00:04:24,400 --> 00:04:35,050
file so so in addition to or instead of

00:04:32,490 --> 00:04:37,259
logging things to logging those events

00:04:35,050 --> 00:04:39,550
to the the trace buffer you can also

00:04:37,259 --> 00:04:42,070
send them to a histogram and so

00:04:39,550 --> 00:04:45,340
essentially that data be aggregated in

00:04:42,070 --> 00:04:48,130
some way through a histogram the way to

00:04:45,340 --> 00:04:50,590
do that is through yet another and yet

00:04:48,130 --> 00:04:54,789
another file associated with the event

00:04:50,590 --> 00:04:57,360
called the trigger file and you to

00:04:54,789 --> 00:05:03,940
enable history I'm you send it a his'n

00:04:57,360 --> 00:05:05,979
like like this line here so so in this

00:05:03,940 --> 00:05:09,550
case so you can think of that the

00:05:05,979 --> 00:05:12,130
histogram is that as a as a hash table

00:05:09,550 --> 00:05:17,050
with key and associated values and in

00:05:12,130 --> 00:05:20,500
the case of the F trace histograms the

00:05:17,050 --> 00:05:22,720
keys and the values are just one or more

00:05:20,500 --> 00:05:26,440
of the format of the fields described in

00:05:22,720 --> 00:05:29,949
the format file so in this in this

00:05:26,440 --> 00:05:32,770
example we have a histogram and the key

00:05:29,949 --> 00:05:36,160
is the process ID common pit that's a

00:05:32,770 --> 00:05:40,599
value that every event has a field that

00:05:36,160 --> 00:05:44,169
every event has and and the values here

00:05:40,599 --> 00:05:45,610
bytes lock and hit how so you send that

00:05:44,169 --> 00:05:48,610
to the trigger and then at any point

00:05:45,610 --> 00:05:50,620
after that you can see the current state

00:05:48,610 --> 00:05:52,680
of the histogram it's constantly running

00:05:50,620 --> 00:05:56,560
and you can look at it anytime you want

00:05:52,680 --> 00:06:00,430
and you do that by reading this another

00:05:56,560 --> 00:06:02,830
another file called hist and look at the

00:06:00,430 --> 00:06:07,570
output and and and this is a typical

00:06:02,830 --> 00:06:10,210
output here we have a line for each

00:06:07,570 --> 00:06:13,090
unique bid and then associated with each

00:06:10,210 --> 00:06:15,330
one of those processes we have a running

00:06:13,090 --> 00:06:18,070
total of the number of bytes allocated

00:06:15,330 --> 00:06:24,400
by cam came Alec on behalf of that

00:06:18,070 --> 00:06:27,280
process in this example so this is just

00:06:24,400 --> 00:06:28,599
a sort of a more graphical way of

00:06:27,280 --> 00:06:31,840
looking the same thing and I'm going to

00:06:28,599 --> 00:06:34,169
use this this kind of diagram throughout

00:06:31,840 --> 00:06:37,090
the talk so I'll explain a little bit

00:06:34,169 --> 00:06:38,940
right now so the on the left hand side

00:06:37,090 --> 00:06:41,710
is your standard

00:06:38,940 --> 00:06:42,370
Colonel userspace layering diagram you

00:06:41,710 --> 00:06:44,050
know userspace

00:06:42,370 --> 00:06:45,490
called into the colonel and the colonel

00:06:44,050 --> 00:06:48,599
calls the driver and talked to the

00:06:45,490 --> 00:06:52,620
hardware etc and on the right hand side

00:06:48,599 --> 00:06:56,229
there's just a piece of the colonel

00:06:52,620 --> 00:06:57,550
broken out in this case it's f traces

00:06:56,229 --> 00:07:01,900
the subsystem that we're talking about

00:06:57,550 --> 00:07:04,389
so on the right hand side we see the the

00:07:01,900 --> 00:07:06,340
trace buffer that associated with F

00:07:04,389 --> 00:07:11,139
trace that's where all the events go and

00:07:06,340 --> 00:07:13,569
then on the left of the left of that

00:07:11,139 --> 00:07:17,470
diagram there are those are the

00:07:13,569 --> 00:07:19,270
histograms and those are just these are

00:07:17,470 --> 00:07:21,669
just two two representations of the same

00:07:19,270 --> 00:07:24,819
thing they're the same histogram this is

00:07:21,669 --> 00:07:27,580
more of tabular form and this is just

00:07:24,819 --> 00:07:30,130
the same thing flipped on side and the

00:07:27,580 --> 00:07:33,509
weights given some weights for the value

00:07:30,130 --> 00:07:37,539
of the the what it contains

00:07:33,509 --> 00:07:41,500
so going that's the left hand side we

00:07:37,539 --> 00:07:43,690
see in this case we have two two

00:07:41,500 --> 00:07:46,240
processes there baton probably making a

00:07:43,690 --> 00:07:50,830
system call going in the current line

00:07:46,240 --> 00:07:52,449
coming back and the dots the dots in the

00:07:50,830 --> 00:07:54,310
middle of their execution are meant to

00:07:52,449 --> 00:07:57,580
represent the time when the points when

00:07:54,310 --> 00:08:00,069
they had a trace point so each one of

00:07:57,580 --> 00:08:02,949
them is hitting a trace point and you

00:08:00,069 --> 00:08:05,469
can see that the the the trace event

00:08:02,949 --> 00:08:09,639
data goes into the F trace buffer and

00:08:05,469 --> 00:08:12,219
it's also sent to a histogram and you

00:08:09,639 --> 00:08:13,479
can see it for that for every for each

00:08:12,219 --> 00:08:16,150
each process because it's only slot in

00:08:13,479 --> 00:08:21,550
the histogram and that's where the data

00:08:16,150 --> 00:08:23,380
is aggregated for that process okay so

00:08:21,550 --> 00:08:25,180
so everything I've described so far is

00:08:23,380 --> 00:08:26,770
already in the kernel you can go and

00:08:25,180 --> 00:08:28,990
play with the histograms you can go and

00:08:26,770 --> 00:08:32,669
play the trace events it's all very well

00:08:28,990 --> 00:08:35,770
documented in documentation slash trace

00:08:32,669 --> 00:08:38,700
what I'm going to talk about here for

00:08:35,770 --> 00:08:40,860
henceforward is

00:08:38,700 --> 00:08:45,990
basically functionality implemented by

00:08:40,860 --> 00:08:47,640
the inter event pets so which covers

00:08:45,990 --> 00:08:52,230
latency is probably the most important

00:08:47,640 --> 00:08:54,150
quantity and by latency I just mean just

00:08:52,230 --> 00:08:55,830
a quantity derived from two events when

00:08:54,150 --> 00:08:57,270
later in time than the other and the

00:08:55,830 --> 00:09:03,750
time different time different time

00:08:57,270 --> 00:09:05,220
stamps between those and we can use to

00:09:03,750 --> 00:09:07,040
calculate a latency we can actually make

00:09:05,220 --> 00:09:09,060
use of the histograms we already have

00:09:07,040 --> 00:09:10,230
and what the patch that with the

00:09:09,060 --> 00:09:13,050
internet catch that does one of the

00:09:10,230 --> 00:09:16,470
things it does is enable you to put

00:09:13,050 --> 00:09:19,980
variables on on the histogram so that

00:09:16,470 --> 00:09:23,040
you can save and retrieve very variables

00:09:19,980 --> 00:09:26,880
between events so here's an example I

00:09:23,040 --> 00:09:29,220
have two events scheduled a king and

00:09:26,880 --> 00:09:32,700
sky's switch they're both keyed on the

00:09:29,220 --> 00:09:35,010
process ID and in the first one we're

00:09:32,700 --> 00:09:36,690
saving basically when that event gets

00:09:35,010 --> 00:09:39,720
hit we're saving the comment the

00:09:36,690 --> 00:09:42,720
timestamp in two variables yes zero and

00:09:39,720 --> 00:09:45,240
then later on when the SCAD switch event

00:09:42,720 --> 00:09:48,720
comes along retrieving that timestamp

00:09:45,240 --> 00:09:50,670
and subtracting it from the current

00:09:48,720 --> 00:09:54,060
timestamp on that event and then saving

00:09:50,670 --> 00:09:57,600
it into another variable on that trigger

00:09:54,060 --> 00:10:00,270
in this case waking latency and that's

00:09:57,600 --> 00:10:03,180
just the latency that we want so

00:10:00,270 --> 00:10:05,910
graphically it looks like this so you

00:10:03,180 --> 00:10:08,460
have a user space process making a

00:10:05,910 --> 00:10:13,860
system call I'm at some point it hits

00:10:08,460 --> 00:10:16,980
the it hits the the trace point logs its

00:10:13,860 --> 00:10:21,000
data into the trace buffer you see the

00:10:16,980 --> 00:10:25,710
event there and then it also sends it it

00:10:21,000 --> 00:10:28,820
it also saves this timestamp variable in

00:10:25,710 --> 00:10:32,490
that slot associated with that process

00:10:28,820 --> 00:10:36,750
then sometimes later sometime later the

00:10:32,490 --> 00:10:38,520
sched switch event happens and it saves

00:10:36,750 --> 00:10:42,830
it basically has a timestamp that's

00:10:38,520 --> 00:10:47,930
associated with the same slot and

00:10:42,830 --> 00:10:52,160
in addition it sends that's its data to

00:10:47,930 --> 00:10:54,110
the the trace buffer at this point we

00:10:52,160 --> 00:10:56,810
have enough to do to do our latency to

00:10:54,110 --> 00:11:00,130
create a latency out of those two things

00:10:56,810 --> 00:11:03,290
we just subtract them and we end up with

00:11:00,130 --> 00:11:06,529
our latency still again associated with

00:11:03,290 --> 00:11:12,649
with that process and that's that's

00:11:06,529 --> 00:11:16,820
pretty much all there is to it yeah and

00:11:12,649 --> 00:11:17,959
so so now we have a latency so what do

00:11:16,820 --> 00:11:23,750
we do what can we do with it at this

00:11:17,959 --> 00:11:25,610
point well I mean in the case of a

00:11:23,750 --> 00:11:27,019
latency one of the things most important

00:11:25,610 --> 00:11:28,670
things you can do with latency or one

00:11:27,019 --> 00:11:32,329
thing is that most useful things to do

00:11:28,670 --> 00:11:34,640
is to actually figure out if if it's the

00:11:32,329 --> 00:11:37,790
maximum latency you've seen so far so

00:11:34,640 --> 00:11:40,339
that's what this these icons are

00:11:37,790 --> 00:11:43,220
supposed to represent is we've got a

00:11:40,339 --> 00:11:46,190
latency now we're feeding it into this

00:11:43,220 --> 00:11:47,959
thing called a call I call handler I'm

00:11:46,190 --> 00:11:52,399
in this case it's supposed to represent

00:11:47,959 --> 00:11:54,920
the basically a function that compares

00:11:52,399 --> 00:11:58,520
the latency you're passing in to the

00:11:54,920 --> 00:12:02,060
maximum we've seen so far and if it's

00:11:58,520 --> 00:12:04,520
not larger do nothing if it is then do

00:12:02,060 --> 00:12:06,589
this do do the action on the right and

00:12:04,520 --> 00:12:09,610
in this case the action is this piggy

00:12:06,589 --> 00:12:12,829
bank is meant to represent save so same

00:12:09,610 --> 00:12:15,410
saying is if this we have a menu maximum

00:12:12,829 --> 00:12:20,180
save some state associated with that

00:12:15,410 --> 00:12:22,670
maximum so in terms of insert in terms

00:12:20,180 --> 00:12:29,390
of the triggers this is what it looks

00:12:22,670 --> 00:12:32,839
like so we have so here's well we were

00:12:29,390 --> 00:12:34,850
doing is adding this line here and to

00:12:32,839 --> 00:12:36,320
the left of the dot is the Handler and

00:12:34,850 --> 00:12:38,690
the right is the action so in this case

00:12:36,320 --> 00:12:40,220
the handler is saying okay well here

00:12:38,690 --> 00:12:43,370
actually here we're calculating the

00:12:40,220 --> 00:12:45,980
latency and then passing it to this on

00:12:43,370 --> 00:12:49,480
max function the handler and then if if

00:12:45,980 --> 00:12:52,040
it's larger then we're invoking this

00:12:49,480 --> 00:12:54,800
action on the right and in this case

00:12:52,040 --> 00:12:58,459
what it's doing is saving

00:12:54,800 --> 00:13:02,120
a bunch of fields from the sched which

00:12:58,459 --> 00:13:07,760
event in in a variable associated with

00:13:02,120 --> 00:13:11,380
that entry so if we do that and then we

00:13:07,760 --> 00:13:13,250
look at the output if we look at the the

00:13:11,380 --> 00:13:18,380
Scouts which event this is where we

00:13:13,250 --> 00:13:21,250
attach the on max handler we see it's

00:13:18,380 --> 00:13:24,079
telling us the maximum so far is 67 and

00:13:21,250 --> 00:13:26,060
when that maximum was hit here are the

00:13:24,079 --> 00:13:29,269
variable the values of the variables

00:13:26,060 --> 00:13:31,810
that we asked it to save and it

00:13:29,269 --> 00:13:34,970
presumably we're telling it to save

00:13:31,810 --> 00:13:38,029
variables that will help us determine

00:13:34,970 --> 00:13:40,550
source of let's say a high latency you

00:13:38,029 --> 00:13:44,540
might want to look at the previous the

00:13:40,550 --> 00:13:46,040
previous process and it's a priority and

00:13:44,540 --> 00:13:48,170
help you maybe there's something going

00:13:46,040 --> 00:13:53,870
on with that particular process that you

00:13:48,170 --> 00:13:55,430
can then go take a look at so that's

00:13:53,870 --> 00:13:57,320
useful but you can you can ask you can

00:13:55,430 --> 00:13:59,209
actually do much more than that you can

00:13:57,320 --> 00:14:01,190
chain handlers at basil yeah well we're

00:13:59,209 --> 00:14:03,110
adding we can add in more handlers of

00:14:01,190 --> 00:14:06,410
the same type on top of it and do you

00:14:03,110 --> 00:14:08,600
get even more information so for example

00:14:06,410 --> 00:14:10,970
another thing we could do is use the

00:14:08,600 --> 00:14:12,980
same handler add another instance of the

00:14:10,970 --> 00:14:17,240
same Handler on max but never get the

00:14:12,980 --> 00:14:18,950
same maximum and do this action in this

00:14:17,240 --> 00:14:21,470
case this action represents the snapshot

00:14:18,950 --> 00:14:25,820
so the idea is that you're running your

00:14:21,470 --> 00:14:28,390
workload and and you you you present you

00:14:25,820 --> 00:14:32,020
enable a bunch of events that are

00:14:28,390 --> 00:14:35,300
pertinent to your what you expect to

00:14:32,020 --> 00:14:37,100
pertinent to your your application and

00:14:35,300 --> 00:14:40,899
basically or all the events in the

00:14:37,100 --> 00:14:44,209
system and when you hit that maximum

00:14:40,899 --> 00:14:45,620
it'll it'll in addition to saving those

00:14:44,209 --> 00:14:49,459
values and told to it also take a

00:14:45,620 --> 00:14:53,300
snapshot so and then you can go look at

00:14:49,459 --> 00:14:56,360
the snapshot and it'll give you a wealth

00:14:53,300 --> 00:14:58,070
of information in addition you know the

00:14:56,360 --> 00:14:59,750
saving stuff is great but having

00:14:58,070 --> 00:15:02,329
basically the whole state of the system

00:14:59,750 --> 00:15:05,329
as in the in the snapshot buffer is

00:15:02,329 --> 00:15:06,440
infinitely more useful for digging into

00:15:05,329 --> 00:15:09,139
the problem

00:15:06,440 --> 00:15:10,730
so here here's what it looks like in

00:15:09,139 --> 00:15:15,050
terms of the trigger all we did here was

00:15:10,730 --> 00:15:16,370
add another on max Handler and in

00:15:15,050 --> 00:15:20,480
addition to the save we're doing the

00:15:16,370 --> 00:15:24,199
snapshot and looking at the output of

00:15:20,480 --> 00:15:27,459
that we see in this case same thing we

00:15:24,199 --> 00:15:29,449
have a maximum latency we have our

00:15:27,459 --> 00:15:31,189
variables that we've saved and we also

00:15:29,449 --> 00:15:35,120
have another max that corresponds to the

00:15:31,189 --> 00:15:38,689
snapshot which isn't here but if you

00:15:35,120 --> 00:15:40,490
look in the tracing snapshot if you look

00:15:38,689 --> 00:15:44,629
at the snapshot using this tracing

00:15:40,490 --> 00:15:47,149
snapshot file you will see that your

00:15:44,629 --> 00:15:48,589
snapshot data so in this case I'm here

00:15:47,149 --> 00:15:51,889
we have our skies switch this is what

00:15:48,589 --> 00:15:54,230
actually triggered the snapshot and the

00:15:51,889 --> 00:15:56,149
corresponding SCAD wakeup is here and if

00:15:54,230 --> 00:15:59,660
you add if you subtract these two you'll

00:15:56,149 --> 00:16:02,660
you'll see exactly the max that was

00:15:59,660 --> 00:16:10,370
reported by the latency which is 99 in

00:16:02,660 --> 00:16:12,290
this case okay so so that's uh so that's

00:16:10,370 --> 00:16:15,199
a lot of useful information about one

00:16:12,290 --> 00:16:17,329
particular latency so we have the Mac we

00:16:15,199 --> 00:16:21,410
have we have the this data we've saved

00:16:17,329 --> 00:16:23,029
and we've had a snapshot for one

00:16:21,410 --> 00:16:24,290
particular latency the maximum latency

00:16:23,029 --> 00:16:26,000
but really what we want

00:16:24,290 --> 00:16:27,680
in addition is to be able to do

00:16:26,000 --> 00:16:30,139
something with every single Mac latency

00:16:27,680 --> 00:16:33,980
that we see so we can we can add a

00:16:30,139 --> 00:16:36,500
handler to do that as well in this case

00:16:33,980 --> 00:16:37,819
it's called it is the name of it is the

00:16:36,500 --> 00:16:41,120
on match handler so there's a match

00:16:37,819 --> 00:16:44,389
there so but the idea is basically every

00:16:41,120 --> 00:16:46,610
time you have a match between your

00:16:44,389 --> 00:16:49,069
events and in this case we're generating

00:16:46,610 --> 00:16:50,870
latency from that match every time we

00:16:49,069 --> 00:16:54,790
have a match then do this action on the

00:16:50,870 --> 00:16:56,920
right and in this case this action is

00:16:54,790 --> 00:16:59,059
supposed to is meant to represent

00:16:56,920 --> 00:17:02,180
another new functionality either by the

00:16:59,059 --> 00:17:04,010
patch set which is a user generated

00:17:02,180 --> 00:17:05,539
synthetic event so we're going to create

00:17:04,010 --> 00:17:10,929
basically we're going to we're going to

00:17:05,539 --> 00:17:13,839
have this create a user who created

00:17:10,929 --> 00:17:15,730
event of our own design and it we've

00:17:13,839 --> 00:17:20,289
designed it can to contain the latent

00:17:15,730 --> 00:17:22,559
the latency so so whenever we have a

00:17:20,289 --> 00:17:28,059
match we have it generate that a user

00:17:22,559 --> 00:17:30,850
our custom event and you can see here

00:17:28,059 --> 00:17:35,159
it's it goes into the buffer the trace

00:17:30,850 --> 00:17:37,119
buffer just like any other event and and

00:17:35,159 --> 00:17:39,720
but what's important about that is

00:17:37,119 --> 00:17:43,240
because it's a sectional a bonafide then

00:17:39,720 --> 00:17:46,119
we can apply all the machinery that we

00:17:43,240 --> 00:17:48,820
can to that event as we do to any other

00:17:46,119 --> 00:17:51,309
event such as create a histogram for

00:17:48,820 --> 00:17:56,740
instance where we take snapshots or

00:17:51,309 --> 00:17:59,549
essay or whatever so in terms of in

00:17:56,740 --> 00:18:02,860
terms of the triggers it looks like this

00:17:59,549 --> 00:18:05,019
the first line the first line is how we

00:18:02,860 --> 00:18:07,809
actually go about creating our synthetic

00:18:05,019 --> 00:18:10,119
event there's a file this file of

00:18:07,809 --> 00:18:11,710
synthetic events you just all you need

00:18:10,119 --> 00:18:16,149
to do is it's pretty simply just echo

00:18:11,710 --> 00:18:18,399
the description of the event which is

00:18:16,149 --> 00:18:20,590
just the name of the event and a set of

00:18:18,399 --> 00:18:22,769
fields and their types and then once

00:18:20,590 --> 00:18:25,509
you've done that you end up with a

00:18:22,769 --> 00:18:27,970
synthetic event an event here under the

00:18:25,509 --> 00:18:32,529
synthetic subsystem with the name that

00:18:27,970 --> 00:18:33,970
you gave it so now we can use those in

00:18:32,529 --> 00:18:37,119
our trigger and basically all we do is

00:18:33,970 --> 00:18:39,399
add this on match which just says okay

00:18:37,119 --> 00:18:41,490
whenever you have a match whenever we we

00:18:39,399 --> 00:18:44,499
have a match with the sched web and

00:18:41,490 --> 00:18:46,539
generate do the action on the right

00:18:44,499 --> 00:18:47,409
which is generating a synthetic event

00:18:46,539 --> 00:18:49,090
and this is the scent

00:18:47,409 --> 00:18:52,690
the syntax for generating us and think

00:18:49,090 --> 00:18:56,080
at a synthetic event you just use it's

00:18:52,690 --> 00:18:58,450
like a function call it's modeled after

00:18:56,080 --> 00:19:01,600
a function call you just use the the

00:18:58,450 --> 00:19:04,029
name of the event and then pass it the

00:19:01,600 --> 00:19:07,720
parameters and those parameters will

00:19:04,029 --> 00:19:12,450
fill in the fields of the event so here

00:19:07,720 --> 00:19:12,450
we have our waking or waking latency

00:19:12,869 --> 00:19:17,740
variable we're passing it in as a first

00:19:15,460 --> 00:19:21,799
and that gets assigned to their lat and

00:19:17,740 --> 00:19:24,150
then the same thing we have the pit

00:19:21,799 --> 00:19:26,790
here verse the gift that's assigned to

00:19:24,150 --> 00:19:30,780
that and then finally not we that we

00:19:26,790 --> 00:19:32,940
have a new event we can do whatever we

00:19:30,780 --> 00:19:37,500
would do with any other event and we can

00:19:32,940 --> 00:19:39,630
do the same thing as put a histogram on

00:19:37,500 --> 00:19:42,900
on that event and we can see then we'll

00:19:39,630 --> 00:19:44,460
be able to see the distribution of

00:19:42,900 --> 00:19:47,660
Layton sees through the histogram so

00:19:44,460 --> 00:19:53,250
that's basically just a simple histogram

00:19:47,660 --> 00:19:55,559
definition on our new event and when we

00:19:53,250 --> 00:19:57,000
look at the output we get a similar kind

00:19:55,559 --> 00:19:59,820
of thing we still have on Macs so that's

00:19:57,000 --> 00:20:03,390
there 97 in this case and the things we

00:19:59,820 --> 00:20:05,910
saved and then we also have the snapshot

00:20:03,390 --> 00:20:07,950
still around so here's the snapshot and

00:20:05,910 --> 00:20:13,500
we can see that the very last thing in

00:20:07,950 --> 00:20:17,910
there is our our custom event waking

00:20:13,500 --> 00:20:19,770
latency containing our our maximum

00:20:17,910 --> 00:20:21,980
latency just as we would expect and of

00:20:19,770 --> 00:20:27,270
course these should match up to they do

00:20:21,980 --> 00:20:29,160
and finally here's the output of the

00:20:27,270 --> 00:20:31,740
histogram that we put on our new custom

00:20:29,160 --> 00:20:35,640
event and so here we have a distribution

00:20:31,740 --> 00:20:39,330
of Layton sees and down here we have our

00:20:35,640 --> 00:20:40,980
as we would expect the biggest latency

00:20:39,330 --> 00:20:50,850
we have has already been flagged by the

00:20:40,980 --> 00:20:52,530
snapshot and the save okay so I'm so

00:20:50,850 --> 00:20:54,929
everything that I've talked about so far

00:20:52,530 --> 00:20:57,330
has is is part of the inter event patch

00:20:54,929 --> 00:21:01,650
set with the exception of the snapshot

00:20:57,330 --> 00:21:02,820
that's something I added I have that as

00:21:01,650 --> 00:21:05,970
a follow on past supper which I haven't

00:21:02,820 --> 00:21:07,530
posted yet but it is available in in the

00:21:05,970 --> 00:21:09,809
last slide I have a pointer to the git

00:21:07,530 --> 00:21:12,929
repository it has all the code that I

00:21:09,809 --> 00:21:15,330
use to generate these examples and it

00:21:12,929 --> 00:21:16,950
has snapshots and and the stuff I'll be

00:21:15,330 --> 00:21:20,820
talking about for the rest of the talk

00:21:16,950 --> 00:21:21,929
I'm in there as well so you can we can

00:21:20,820 --> 00:21:25,799
look at that if you're interested in

00:21:21,929 --> 00:21:29,190
playing around with it so optically and

00:21:25,799 --> 00:21:30,960
sees in some cases you know in some

00:21:29,190 --> 00:21:33,909
cases that makes sense it's more natural

00:21:30,960 --> 00:21:37,959
to use like an object

00:21:33,909 --> 00:21:40,479
address of an object as a key for for

00:21:37,959 --> 00:21:44,409
the latency calculations so for the

00:21:40,479 --> 00:21:48,989
histogram you use using an object an

00:21:44,409 --> 00:21:53,820
object address for those for the key

00:21:48,989 --> 00:21:57,789
example is in the networking subsystem

00:21:53,820 --> 00:21:59,769
you have if you look at the events in

00:21:57,789 --> 00:22:02,619
the networking system subsystem a lot of

00:21:59,769 --> 00:22:04,570
them have an actual skb address as one

00:22:02,619 --> 00:22:07,329
of the fields in the event and that's

00:22:04,570 --> 00:22:12,099
that makes a nice histogram key for us

00:22:07,329 --> 00:22:13,209
to use to essentially think of it as you

00:22:12,099 --> 00:22:15,669
know latency with reference to that

00:22:13,209 --> 00:22:17,320
particular object and if you also think

00:22:15,669 --> 00:22:19,659
of it as if you say if you set up a

00:22:17,320 --> 00:22:22,209
series of Layton sees I'm using that

00:22:19,659 --> 00:22:24,129
address it's sort of like tracking that

00:22:22,209 --> 00:22:26,440
particular object through the kernel and

00:22:24,129 --> 00:22:38,259
and and calculating and seeing its

00:22:26,440 --> 00:22:42,339
latency so yeah hardware no still

00:22:38,259 --> 00:22:45,419
software yeah this is the trace event

00:22:42,339 --> 00:22:49,179
subsystem it's it's available just by

00:22:45,419 --> 00:22:52,659
turning the some kernel options on and

00:22:49,179 --> 00:22:54,399
you'll have trace events for ending

00:22:52,659 --> 00:22:56,379
anywhere in the kernel that defines a

00:22:54,399 --> 00:22:57,519
trace point if you have the heart

00:22:56,379 --> 00:22:59,349
obviously they're not gonna trigger

00:22:57,519 --> 00:23:02,729
unless you have the hardware for you

00:22:59,349 --> 00:23:02,729
know in the driver or something but

00:23:06,040 --> 00:23:32,050
I don't think so I mean that sounds kind

00:23:30,190 --> 00:23:35,230
of advanced - I don't know chain them

00:23:32,050 --> 00:23:54,220
that way um we can talk about it I mean

00:23:35,230 --> 00:23:56,470
I I really understand the okay yeah so

00:23:54,220 --> 00:23:59,680
they but for the latency they you you

00:23:56,470 --> 00:24:11,040
use skb and then you you discard it and

00:23:59,680 --> 00:24:15,910
then it goes to the next guy right right

00:24:11,040 --> 00:24:18,010
so but but yeah so you're saying you

00:24:15,910 --> 00:24:20,200
could end up a situation where you put

00:24:18,010 --> 00:24:22,360
the you get the first part of the

00:24:20,200 --> 00:24:23,860
latency and then you miss the second

00:24:22,360 --> 00:24:32,050
part and then you come back with this

00:24:23,860 --> 00:24:36,010
the first part again yeah I'm not quite

00:24:32,050 --> 00:24:37,660
sure those yeah I mean this is an

00:24:36,010 --> 00:24:40,180
example I I'm not a networking guy so

00:24:37,660 --> 00:24:42,940
I'm assuming that you have an S KB

00:24:40,180 --> 00:24:45,960
address and then you know you have the

00:24:42,940 --> 00:24:49,660
two events on the dress on that and then

00:24:45,960 --> 00:24:50,650
you you you'll get the first event and

00:24:49,660 --> 00:24:56,140
then at some point later you get the

00:24:50,650 --> 00:25:07,680
second one before you know before it

00:24:56,140 --> 00:25:07,680
gets recycled so I'm not really okay

00:25:11,470 --> 00:25:16,040
okay so yeah in this case I'm using an

00:25:14,510 --> 00:25:20,150
amazing that does start transmitting

00:25:16,040 --> 00:25:22,640
that not to have transmitted using skb

00:25:20,150 --> 00:25:25,340
address and so this is what it looks

00:25:22,640 --> 00:25:28,220
like and using that's KB addresses

00:25:25,340 --> 00:25:30,740
it's just similar to what we've seen

00:25:28,220 --> 00:25:34,820
before treating the two triggers and

00:25:30,740 --> 00:25:36,920
then generating the synthetic latency

00:25:34,820 --> 00:25:39,110
synthetic event using using the result

00:25:36,920 --> 00:25:43,880
of that and then you'll end up with

00:25:39,110 --> 00:25:47,390
something like this which works

00:25:43,880 --> 00:25:50,450
initially and then it will stop working

00:25:47,390 --> 00:25:51,830
because we're using an address as the

00:25:50,450 --> 00:25:53,200
key and there's nothing freeing the

00:25:51,830 --> 00:25:56,840
address once we're done with the latency

00:25:53,200 --> 00:26:00,020
so so what happen ends up what ends up

00:25:56,840 --> 00:26:03,890
happening is that we fill up the hash

00:26:00,020 --> 00:26:06,200
table fill up the histogram with with

00:26:03,890 --> 00:26:07,550
object addresses and then since that

00:26:06,200 --> 00:26:09,890
since not you know we've finished the

00:26:07,550 --> 00:26:12,200
latency nothing removes them we end up

00:26:09,890 --> 00:26:14,180
overflowing the table and we see we

00:26:12,200 --> 00:26:16,760
start dropping events and once we've

00:26:14,180 --> 00:26:18,200
started dropping events we're pretty

00:26:16,760 --> 00:26:19,940
much hos because we're not doing Layton

00:26:18,200 --> 00:26:24,200
sees anymore and there's no way to get

00:26:19,940 --> 00:26:28,490
the space back so the solution to that

00:26:24,200 --> 00:26:30,470
is to add a delete operation and

00:26:28,490 --> 00:26:35,330
basically they the trace of the the

00:26:30,470 --> 00:26:38,350
histograms are based on tracing map and

00:26:35,330 --> 00:26:41,840
the tracing map doesn't have a delete I

00:26:38,350 --> 00:26:44,330
didn't have a delete until colleague of

00:26:41,840 --> 00:26:46,970
mine at Intel been on Cattell added the

00:26:44,330 --> 00:26:50,630
delete operation of tracing map so once

00:26:46,970 --> 00:26:53,870
we had that then we added a delete

00:26:50,630 --> 00:26:58,400
history action to take advantage of that

00:26:53,870 --> 00:27:01,100
and the the the the delete that the

00:26:58,400 --> 00:27:04,730
delete actually use it requires a new

00:27:01,100 --> 00:27:06,920
new facility really simple thing called

00:27:04,730 --> 00:27:09,020
tags it just basically allows you to tag

00:27:06,920 --> 00:27:12,890
a histogram with a name say tag equals

00:27:09,020 --> 00:27:14,570
XXX whatever your name is and the idea

00:27:12,890 --> 00:27:17,480
behind it is that you know you you

00:27:14,570 --> 00:27:20,920
essentially refer every every every

00:27:17,480 --> 00:27:25,860
trigger that participates in the latency

00:27:20,920 --> 00:27:29,110
with this tag and then once once the

00:27:25,860 --> 00:27:31,450
what's latency wasn't calculated it will

00:27:29,110 --> 00:27:34,060
go ahead and delete its entry and in the

00:27:31,450 --> 00:27:36,220
table along with all the other matching

00:27:34,060 --> 00:27:37,930
entries in the other tag tables so you

00:27:36,220 --> 00:27:42,160
you're not freeing up basically those

00:27:37,930 --> 00:27:46,390
slot slots for the next object that

00:27:42,160 --> 00:27:47,890
comes along has KB or whatever and a

00:27:46,390 --> 00:27:49,060
nice side effect of having these tags

00:27:47,890 --> 00:27:51,190
that you don't have to use them for

00:27:49,060 --> 00:27:55,690
delete you can use them for you can just

00:27:51,190 --> 00:27:58,900
give any any set of triggers a tag and

00:27:55,690 --> 00:28:01,570
then you can remove them all at once by

00:27:58,900 --> 00:28:03,910
using this a new remove all the command

00:28:01,570 --> 00:28:05,920
that I added to do that so you can just

00:28:03,910 --> 00:28:10,000
remove all at once instead of one by one

00:28:05,920 --> 00:28:13,470
like you pretty much have to do now so

00:28:10,000 --> 00:28:15,960
and this here is just an example of how

00:28:13,470 --> 00:28:20,380
that's of using that so we're just

00:28:15,960 --> 00:28:24,250
tagging these two triggers with that

00:28:20,380 --> 00:28:29,740
with eggs MIT tag and then the last one

00:28:24,250 --> 00:28:32,590
we invoke delete transmit and that will

00:28:29,740 --> 00:28:34,170
cause that entry to be freed up when

00:28:32,590 --> 00:28:36,430
we're done with the latency calculation

00:28:34,170 --> 00:28:39,550
and then here's just an example of the

00:28:36,430 --> 00:28:46,480
removal again we're referencing the tag

00:28:39,550 --> 00:28:48,480
and and and then executing that on on

00:28:46,480 --> 00:28:50,770
one of the history of the triggers and

00:28:48,480 --> 00:28:53,380
it doesn't matter which trigger you use

00:28:50,770 --> 00:28:56,320
it'll it'll it'll go through and find

00:28:53,380 --> 00:29:01,090
all the other events with the same tag

00:28:56,320 --> 00:29:03,460
and remove them I mean here's the result

00:29:01,090 --> 00:29:05,800
it's just you look at the histogram one

00:29:03,460 --> 00:29:07,510
of the histograms you see we see it's

00:29:05,800 --> 00:29:10,030
empty completely empty even though we've

00:29:07,510 --> 00:29:11,650
had five hits I'm and the reason it's

00:29:10,030 --> 00:29:15,180
empty is because we also had five delese

00:29:11,650 --> 00:29:15,180
so it works

00:29:20,240 --> 00:29:24,300
yeah but in this case it's kind of being

00:29:22,800 --> 00:29:28,110
not used as something to look at it's

00:29:24,300 --> 00:29:29,460
being something used to track you know

00:29:28,110 --> 00:29:32,130
we're interested in the output of

00:29:29,460 --> 00:29:34,530
latency and the other histogram these

00:29:32,130 --> 00:29:35,970
ones that are we're putting you know

00:29:34,530 --> 00:29:38,310
we're using to calculate latency we

00:29:35,970 --> 00:29:40,320
don't care about so we just look at it

00:29:38,310 --> 00:29:43,470
but I just looked at it I verify that

00:29:40,320 --> 00:29:48,300
the it was actually empty and stuff was

00:29:43,470 --> 00:29:51,690
getting a deleted so that's that's one

00:29:48,300 --> 00:29:55,050
example and just one more example it's

00:29:51,690 --> 00:29:58,350
very similar thing with the block layer

00:29:55,050 --> 00:29:59,790
instead so I just kind of wanted to give

00:29:58,350 --> 00:30:04,080
somebody you know some idea of how you

00:29:59,790 --> 00:30:06,030
might go about using this stuff to sort

00:30:04,080 --> 00:30:08,790
of track down cause the cause of a

00:30:06,030 --> 00:30:10,740
latency possibly fix or the process you

00:30:08,790 --> 00:30:11,550
go about one process you might use to go

00:30:10,740 --> 00:30:15,620
about doing that

00:30:11,550 --> 00:30:18,510
and in this case the black layer so

00:30:15,620 --> 00:30:20,070
basically assuming that you you you have

00:30:18,510 --> 00:30:23,610
some problem that you suspect is Ria's

00:30:20,070 --> 00:30:24,990
is caused by some latency problem the

00:30:23,610 --> 00:30:27,060
black layer like you know maybe you're

00:30:24,990 --> 00:30:29,580
reading files and every once in a while

00:30:27,060 --> 00:30:31,920
you just stall for a really long time no

00:30:29,580 --> 00:30:34,110
apparent reason which I've seen plenty

00:30:31,920 --> 00:30:37,170
times before and would like to look into

00:30:34,110 --> 00:30:38,520
it but so that's kind of thing is if we

00:30:37,170 --> 00:30:40,890
run across something like that we want

00:30:38,520 --> 00:30:44,520
to look for latency is to try to

00:30:40,890 --> 00:30:47,040
possibly track it down one way to do

00:30:44,520 --> 00:30:53,940
that is to write a simple script like

00:30:47,040 --> 00:30:57,120
this and just it just it just excuse the

00:30:53,940 --> 00:30:58,860
workload and before before it does that

00:30:57,120 --> 00:31:05,040
it turns tracing on and turns tracing

00:30:58,860 --> 00:31:07,470
off and and enables those those events

00:31:05,040 --> 00:31:09,240
which we think which are a good starting

00:31:07,470 --> 00:31:11,190
point I guess for tracing the block

00:31:09,240 --> 00:31:13,050
layer I mean this is just it's just

00:31:11,190 --> 00:31:15,150
called F trace me blah or trace me block

00:31:13,050 --> 00:31:18,240
and it's based on one of Steve Ross

00:31:15,150 --> 00:31:22,140
studs examples in one of his articles so

00:31:18,240 --> 00:31:24,220
it's really just a simple script and

00:31:22,140 --> 00:31:25,330
so looking at the output

00:31:24,220 --> 00:31:26,710
you know the idea is what you want to do

00:31:25,330 --> 00:31:28,630
is try to find a couple of events that

00:31:26,710 --> 00:31:31,210
could be that are that might be good

00:31:28,630 --> 00:31:33,730
candidates for hanging latency

00:31:31,210 --> 00:31:37,419
calculations off of and looking through

00:31:33,730 --> 00:31:39,580
them these two kind of are look like

00:31:37,419 --> 00:31:43,720
good examples block RQ issue and block

00:31:39,580 --> 00:31:47,950
our key complete so if we go and look at

00:31:43,720 --> 00:31:49,630
those look at those events it's black RQ

00:31:47,950 --> 00:31:52,809
issue for example i'm there doesn't

00:31:49,630 --> 00:31:55,120
really seem to be that anything that's

00:31:52,809 --> 00:31:59,230
really directly applicable to using as a

00:31:55,120 --> 00:32:01,240
key for a histogram not like the network

00:31:59,230 --> 00:32:04,360
that were healing rate hit they actually

00:32:01,240 --> 00:32:09,220
gave us an s kb address of an object to

00:32:04,360 --> 00:32:12,190
use as as part of the event but that

00:32:09,220 --> 00:32:15,100
doesn't mean all is lost because we also

00:32:12,190 --> 00:32:18,120
know that if we have given any function

00:32:15,100 --> 00:32:20,830
in like in the kernel we can actually

00:32:18,120 --> 00:32:23,580
create a trace create a trace event that

00:32:20,830 --> 00:32:28,679
pretty much exports any kind of any data

00:32:23,580 --> 00:32:33,010
we want from at the point it's called

00:32:28,679 --> 00:32:37,510
for instance using k probe events for

00:32:33,010 --> 00:32:39,250
instance so so then i get it said you

00:32:37,510 --> 00:32:40,750
know and you know the fact is that we

00:32:39,250 --> 00:32:42,429
did find a couple of events that were

00:32:40,750 --> 00:32:46,409
that were at good points and time to

00:32:42,429 --> 00:32:49,360
hang in latency off it just happens that

00:32:46,409 --> 00:32:51,070
there for our purposes we just don't

00:32:49,360 --> 00:32:53,380
they just didn't give us the data that

00:32:51,070 --> 00:32:56,950
we exact data that we that we you really

00:32:53,380 --> 00:33:00,640
want so basically the problem transfers

00:32:56,950 --> 00:33:03,850
over to finding some functions nearby

00:33:00,640 --> 00:33:08,380
the trace points that we like that we

00:33:03,850 --> 00:33:11,289
can use for a similar purpose and and

00:33:08,380 --> 00:33:13,929
and to do that we can just add this line

00:33:11,289 --> 00:33:16,059
to the previous script which is turning

00:33:13,929 --> 00:33:19,780
on function graph and then when we look

00:33:16,059 --> 00:33:20,799
at the output we will see see our

00:33:19,780 --> 00:33:22,030
original trace points that were

00:33:20,799 --> 00:33:25,659
interested in but we can all we also see

00:33:22,030 --> 00:33:27,400
a graph function call graph surrounding

00:33:25,659 --> 00:33:28,900
those and that we can sort of try to

00:33:27,400 --> 00:33:31,539
pick and choose some things that might

00:33:28,900 --> 00:33:34,630
work and this is this is the kind of

00:33:31,539 --> 00:33:36,760
output typical output you see so

00:33:34,630 --> 00:33:40,410
we have black RQ issue that we're

00:33:36,760 --> 00:33:42,370
interested in black are complete and

00:33:40,410 --> 00:33:45,370
looking around certainly looking around

00:33:42,370 --> 00:33:48,880
those two events in the output we see a

00:33:45,370 --> 00:33:50,800
couple of candidates black MQ start

00:33:48,880 --> 00:33:55,000
requests and block IO complete

00:33:50,800 --> 00:34:01,960
completion so let's pretend that we want

00:33:55,000 --> 00:34:03,730
to use those for our trace events so if

00:34:01,960 --> 00:34:05,260
we look at the look at the the source

00:34:03,730 --> 00:34:07,570
code and look at the kernel source that

00:34:05,260 --> 00:34:11,820
we look at those two functions and they

00:34:07,570 --> 00:34:14,440
do both of them have this struct request

00:34:11,820 --> 00:34:17,260
object that looks perfect for our

00:34:14,440 --> 00:34:19,659
purposes so now we have a function and

00:34:17,260 --> 00:34:24,010
we have the data that we want to export

00:34:19,659 --> 00:34:25,690
as a trace event there's a number like I

00:34:24,010 --> 00:34:29,639
mentioned you can use the K probe events

00:34:25,690 --> 00:34:33,070
to do that the syntax is a little

00:34:29,639 --> 00:34:36,750
off-putting I guess and it's architect

00:34:33,070 --> 00:34:39,490
art specific a similar equivalent way of

00:34:36,750 --> 00:34:47,280
creating trace points for those

00:34:39,490 --> 00:34:49,810
functions would be perfection z' but for

00:34:47,280 --> 00:34:52,270
for the purposes of this talk I'm going

00:34:49,810 --> 00:34:53,649
to be using Steve Ross's function event

00:34:52,270 --> 00:34:56,290
a new function of that patch that that

00:34:53,649 --> 00:34:57,460
he posted a few weeks ago and the idea

00:34:56,290 --> 00:35:00,340
behind it is basically that you could

00:34:57,460 --> 00:35:02,170
take very easily any function in the

00:35:00,340 --> 00:35:06,220
kernel and just directly create a trace

00:35:02,170 --> 00:35:08,920
point for it with with all the

00:35:06,220 --> 00:35:11,830
parameters and with all the parameters

00:35:08,920 --> 00:35:15,600
of the event in addition to a whole lot

00:35:11,830 --> 00:35:18,280
else a whole lot more you can you can

00:35:15,600 --> 00:35:19,720
you can go through structures you can do

00:35:18,280 --> 00:35:24,270
a global events and so on but this is

00:35:19,720 --> 00:35:28,480
just using it to to basically export

00:35:24,270 --> 00:35:34,930
when one of the parameters so if you do

00:35:28,480 --> 00:35:40,540
that so yeah anyways yeah to do that

00:35:34,930 --> 00:35:43,060
basically you you just you you you echo

00:35:40,540 --> 00:35:44,450
the the name of the function and the

00:35:43,060 --> 00:35:46,519
parameter you want

00:35:44,450 --> 00:35:50,569
into the dysfunction events file and

00:35:46,519 --> 00:35:54,829
then you'll end up with an event like

00:35:50,569 --> 00:35:57,109
this and you can see it's it's the name

00:35:54,829 --> 00:36:00,640
of the function and it's under this font

00:35:57,109 --> 00:36:04,990
the function subsystem and here's our

00:36:00,640 --> 00:36:04,990
request object that we are interested in

00:36:46,460 --> 00:36:52,010
okay yeah so anyway this is just as just

00:36:49,910 --> 00:36:53,420
the same along the same theme we have

00:36:52,010 --> 00:36:55,880
our triggers that we have now we have

00:36:53,420 --> 00:36:59,720
our request object that we can use as

00:36:55,880 --> 00:37:02,980
the as the key and you know we're just

00:36:59,720 --> 00:37:05,210
creating a synthetic event and then

00:37:02,980 --> 00:37:09,220
creating generating histogram from that

00:37:05,210 --> 00:37:11,660
and so here we have our output of

00:37:09,220 --> 00:37:15,710
request latency between those two

00:37:11,660 --> 00:37:17,780
functions that we just picked out I'm so

00:37:15,710 --> 00:37:21,349
you know basically having having this

00:37:17,780 --> 00:37:25,490
ability to you know at will create a

00:37:21,349 --> 00:37:27,109
trace event at any function basically we

00:37:25,490 --> 00:37:30,050
you know very easily do that with any

00:37:27,109 --> 00:37:32,540
exporting any data we need allows us to

00:37:30,050 --> 00:37:37,010
go from situation like this where we

00:37:32,540 --> 00:37:38,420
have just a handful of available trace

00:37:37,010 --> 00:37:43,869
points that may or may not have the data

00:37:38,420 --> 00:37:47,660
we need to this where we essentially can

00:37:43,869 --> 00:37:49,369
very easily calculate the the latencies

00:37:47,660 --> 00:37:53,990
and show histogram between any two

00:37:49,369 --> 00:37:55,880
functions in the kernel if we just by

00:37:53,990 --> 00:38:00,170
doing some similar problems to what I

00:37:55,880 --> 00:38:02,240
did and in fact this is this is kind of

00:38:00,170 --> 00:38:06,530
an initial stab it's kind of a twice

00:38:02,240 --> 00:38:09,200
script that that tries to do that it's

00:38:06,530 --> 00:38:11,960
it's called func event latency you just

00:38:09,200 --> 00:38:14,180
hand it to functions and a key and it

00:38:11,960 --> 00:38:16,730
will generate everything all the

00:38:14,180 --> 00:38:19,670
machinery needed to create a histogram

00:38:16,730 --> 00:38:21,950
between those two functions so here it

00:38:19,670 --> 00:38:24,230
does it takes that the function names

00:38:21,950 --> 00:38:26,569
and makes a function and and makes

00:38:24,230 --> 00:38:29,150
function events out of them and then it

00:38:26,569 --> 00:38:31,460
creates two triggers you know that save

00:38:29,150 --> 00:38:36,380
the latency and then calculate the

00:38:31,460 --> 00:38:40,069
latency here keyed on the key and and

00:38:36,380 --> 00:38:45,460
then finally it also it also creates a

00:38:40,069 --> 00:38:45,460
synthetic event named that func lat and

00:38:45,670 --> 00:38:51,170
in generates and uses on match to

00:38:48,349 --> 00:38:53,180
generate a synthetic event with that

00:38:51,170 --> 00:38:55,010
latency and then now that we have an

00:38:53,180 --> 00:38:56,150
event with that latency we can just put

00:38:55,010 --> 00:39:01,240
the histogram on it

00:38:56,150 --> 00:39:04,190
and just like here on the synthetic

00:39:01,240 --> 00:39:08,299
event that we created for it yeah

00:39:04,190 --> 00:39:10,279
exactly yeah like I said it was it's a

00:39:08,299 --> 00:39:13,099
toy program at this point you know you'd

00:39:10,279 --> 00:39:15,079
have to be some you know you'd have you

00:39:13,099 --> 00:39:18,890
be much smarter about matching things up

00:39:15,079 --> 00:39:20,299
and you know you're with the parameters

00:39:18,890 --> 00:39:21,859
here first parameter and the second

00:39:20,299 --> 00:39:24,410
parameter on the other one or maybe it's

00:39:21,859 --> 00:39:27,250
it's you know some other variable in a

00:39:24,410 --> 00:39:30,230
structure somewhere but you know it's uh

00:39:27,250 --> 00:39:32,930
yeah someone who's better at shell

00:39:30,230 --> 00:39:35,450
program and could you know do do it

00:39:32,930 --> 00:39:39,349
justice but that's just sort of

00:39:35,450 --> 00:39:51,260
illustrating the the basic potential of

00:39:39,349 --> 00:39:53,930
the thing I think yeah you need so to do

00:39:51,260 --> 00:39:58,700
this you need you basically what I did

00:39:53,930 --> 00:40:00,500
was I I took my pet I took the I took

00:39:58,700 --> 00:40:03,319
the the inner event patch as I posted it

00:40:00,500 --> 00:40:06,920
I put them on top of Steve function

00:40:03,319 --> 00:40:09,079
patch function event patch that and then

00:40:06,920 --> 00:40:13,099
I I added on top of that these other

00:40:09,079 --> 00:40:14,750
changes that I'm talking about and so

00:40:13,099 --> 00:40:16,849
eventually they'll all get mixed up they

00:40:14,750 --> 00:40:18,380
all get unmixed but for now you know

00:40:16,849 --> 00:40:22,010
they're available in that get repository

00:40:18,380 --> 00:40:24,109
I put everything in there I know you

00:40:22,010 --> 00:40:28,210
know whenever things go up stream then

00:40:24,109 --> 00:40:28,210
it'll get sorted out but for now yeah

00:40:31,240 --> 00:40:36,950
yeah oh I'll show you on the last slide

00:40:34,760 --> 00:40:42,109
I made couple slides from now actually I

00:40:36,950 --> 00:40:44,599
have a I have a git repo that has all

00:40:42,109 --> 00:40:47,569
the stuff and you can actually just go

00:40:44,599 --> 00:40:52,160
get the slides from the ELC website and

00:40:47,569 --> 00:40:55,849
then just directly go to it so anyway

00:40:52,160 --> 00:40:57,859
that's so so this is the this is the end

00:40:55,849 --> 00:41:00,400
result is you have this func event

00:40:57,859 --> 00:41:04,480
latency and

00:41:00,400 --> 00:41:07,000
a script and one line you-you-you-you

00:41:04,480 --> 00:41:09,390
basically created this latency and

00:41:07,000 --> 00:41:12,190
because you have it is actually a

00:41:09,390 --> 00:41:14,260
latency they are actually fully fledged

00:41:12,190 --> 00:41:16,960
events you can do all the other things

00:41:14,260 --> 00:41:19,770
with it as well not just create this

00:41:16,960 --> 00:41:22,540
histogram so yeah so anyway this is the

00:41:19,770 --> 00:41:26,800
the the two functions I gave it the

00:41:22,540 --> 00:41:28,480
request and had after you run this one

00:41:26,800 --> 00:41:30,700
line you end up with the histogram that

00:41:28,480 --> 00:41:36,430
you look at and that's the output just

00:41:30,700 --> 00:41:41,620
like all the previous examples so yeah

00:41:36,430 --> 00:41:46,360
that's that's all I had then here's the

00:41:41,620 --> 00:41:48,850
here's a link to the to the code and

00:41:46,360 --> 00:41:50,950
that's pretty much it thanks for

00:41:48,850 --> 00:42:04,740
attending and if there are any questions

00:41:50,950 --> 00:42:04,740
I'll be happy to answer them pardon sure

00:42:05,440 --> 00:42:08,510
[Music]

00:42:55,430 --> 00:43:17,930
oh the slides yep they're there if you

00:43:14,930 --> 00:43:21,680
yeah if you go to my slot on the

00:43:17,930 --> 00:43:23,230
schedule for this for free LC you should

00:43:21,680 --> 00:43:28,460
be able to just go get the slides there

00:43:23,230 --> 00:43:29,900
they're on there and I did my email here

00:43:28,460 --> 00:43:32,359
so in case that doesn't work you could

00:43:29,900 --> 00:43:38,859
email me but you can just look for the

00:43:32,359 --> 00:43:38,859
patches okay any other questions

00:44:03,359 --> 00:44:07,990
well this is just all right there you're

00:44:07,000 --> 00:44:10,780
at the command line you have it

00:44:07,990 --> 00:44:12,430
available and you know it's not meant to

00:44:10,780 --> 00:44:15,760
it's not supposed to be like we play you

00:44:12,430 --> 00:44:17,559
know something that would be a really in

00:44:15,760 --> 00:44:19,030
competition with in fact one of the

00:44:17,559 --> 00:44:21,160
things I was going to do for this talk

00:44:19,030 --> 00:44:26,829
that I didn't have time to do was

00:44:21,160 --> 00:44:28,660
actually you know BCC is a tool that

00:44:26,829 --> 00:44:31,000
uses BPF and it has some examples

00:44:28,660 --> 00:44:36,400
similar to these what I was going to do

00:44:31,000 --> 00:44:39,430
was take basically try to you know plug

00:44:36,400 --> 00:44:42,640
this into into BCC that you so that you

00:44:39,430 --> 00:44:46,420
could you could actually make use of of

00:44:42,640 --> 00:44:48,460
this as a component instead of you know

00:44:46,420 --> 00:44:51,299
calling it you know creating the BPF

00:44:48,460 --> 00:44:53,650
program and then all that machinery so

00:44:51,299 --> 00:44:55,660
it's not mutually exclusive it's just

00:44:53,650 --> 00:44:57,730
you know and you know and one example

00:44:55,660 --> 00:45:02,680
you know like the block event a layer

00:44:57,730 --> 00:45:04,210
for instance has a lot of stuff that you

00:45:02,680 --> 00:45:06,549
know we're never waiting you know you

00:45:04,210 --> 00:45:07,990
like you have to write you you have to

00:45:06,549 --> 00:45:10,150
write little code snippet to get the

00:45:07,990 --> 00:45:11,770
major minor and things like that which

00:45:10,150 --> 00:45:13,180
we don't have any way of doing that here

00:45:11,770 --> 00:45:16,420
and I don't think we ever will because

00:45:13,180 --> 00:45:19,900
that's basically writing some code as

00:45:16,420 --> 00:45:22,869
part of the probe and this is just kind

00:45:19,900 --> 00:45:26,430
of what you can wire up you know with

00:45:22,869 --> 00:45:30,299
just just wires instead of not logic I

00:45:26,430 --> 00:45:30,299
mean not not actual

00:45:46,060 --> 00:45:52,650
any other questions I guess not

00:45:50,870 --> 00:46:00,130
well thanks for attending

00:45:52,650 --> 00:46:00,130

YouTube URL: https://www.youtube.com/watch?v=5mxOxjRCEpE


