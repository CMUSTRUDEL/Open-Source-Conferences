Title: Maintaining a Real Time Stable Kernel - Steven Rostedt, VMware
Publication date: 2018-03-14
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	Maintaining a Real Time Stable Kernel - Steven Rostedt, VMware

 It wont be much longer before the PREEMPT_RT patch makes it into mainline. But what about supporting it for your devices? Maintaining a RT stable tree is a bit different than maintaining a normal vanilla stable tree. One must understand how the Real Time kernel works, and be able to spot changes that can cause priority inversion, or simply break the kernel. There is now an effort to have multiple people maintain various versions of Linux with the RT patch applied. This talk will present what is required to maintain a stable RT tree, such as tools that you can use. What tricks can be done with git to find properly backport patches that are RT specific. It will also cover the current tests that are performed to make sure the released RT stable kernel is fully functional. 

About Steven Rostedt
Steven Rostedt first started playing inside the Linux kernel in 1998. Since 2001 he's been a professional full time kernel developer. Steven is one of the original developers of the PREEMPT_RT patch; he started working on it in 2004 with the goal of turning Linux into a Real Time designed operating system. Although, the PREEMPT_RT patch still exists out of tree, several of its features have made it into the vanilla kernel. One of these features being Ftrace, the official tracer of Linux. Steven is the main author, developer and maintainer of Ftrace. He has also created ktest.pl, which lives inside the kernel source tree and is a testing framework within the Linux kernel, and is the one responsible for the kernel build option "make localmodconfig". Outside of development, Steven has done numerous presentations around the world. Steven is one the Linux Foundation's Technical Advisory Board (TAB) members, which represents the kernel community to the foundation. Steven currently works for VMware Inc.
Captions: 
	00:00:00,269 --> 00:00:06,750
so my job today is that they put me

00:00:04,290 --> 00:00:10,679
after lunch well so I have to wake you

00:00:06,750 --> 00:00:14,240
up and I'm doing it with a

00:00:10,679 --> 00:00:16,699
process-oriented presentation challenge

00:00:14,240 --> 00:00:19,859
I love a challenge

00:00:16,699 --> 00:00:21,570
okay so might as well start it I got a

00:00:19,859 --> 00:00:23,640
lot to talk about

00:00:21,570 --> 00:00:27,570
it's funny I start off with 15 slides I

00:00:23,640 --> 00:00:29,279
think I have like 50 3s now so so

00:00:27,570 --> 00:00:32,279
everyone here is for the stable real

00:00:29,279 --> 00:00:34,260
time not stable or real time but the

00:00:32,279 --> 00:00:40,399
stable real time or real time stable

00:00:34,260 --> 00:00:44,399
whatever so for the Upstate excellence

00:00:40,399 --> 00:00:46,850
so for the upstream stable releases so

00:00:44,399 --> 00:00:49,200
you're all hopefully familiar with

00:00:46,850 --> 00:00:52,460
everyone who's here not familiar with

00:00:49,200 --> 00:00:57,059
the stable upstream stable releases okay

00:00:52,460 --> 00:01:00,300
yes so everyone knows about we have the

00:00:57,059 --> 00:01:02,129
stable releases just the overview of

00:01:00,300 --> 00:01:05,220
exactly some of the process that's going

00:01:02,129 --> 00:01:08,760
to so after like you know three fourteen

00:01:05,220 --> 00:01:11,369
is released you'll have a three of sorry

00:01:08,760 --> 00:01:13,140
fourth 14 is released you have a four 13

00:01:11,369 --> 00:01:16,530
that gets you know stable releases for

00:01:13,140 --> 00:01:19,259
13.1 - blah blah blah blah when four

00:01:16,530 --> 00:01:21,060
fifteen rc1 is kind of released the

00:01:19,259 --> 00:01:25,170
previous release four thirteen is no

00:01:21,060 --> 00:01:28,049
longer supported and four fourteen is

00:01:25,170 --> 00:01:30,119
now the stable releases so really it's

00:01:28,049 --> 00:01:31,470
just one back one that we do this table

00:01:30,119 --> 00:01:32,939
really since this is the way we started

00:01:31,470 --> 00:01:34,380
this is a way we liked it but some

00:01:32,939 --> 00:01:36,479
people didn't think that was good enough

00:01:34,380 --> 00:01:38,340
so we now have what was called the

00:01:36,479 --> 00:01:40,079
long-term stable releases and every so

00:01:38,340 --> 00:01:41,820
often you know I think Gregg has

00:01:40,079 --> 00:01:43,380
switched it to was it once a year now

00:01:41,820 --> 00:01:44,850
he's going to make one release a

00:01:43,380 --> 00:01:46,500
real-time stable over the east or

00:01:44,850 --> 00:01:48,329
something he's before he just randomly

00:01:46,500 --> 00:01:51,119
picked one hoping that people wanted to

00:01:48,329 --> 00:01:52,290
just bombard that one release with us we

00:01:51,119 --> 00:01:54,240
got these features and we got get these

00:01:52,290 --> 00:01:56,100
features in whatever so but now he's

00:01:54,240 --> 00:01:57,869
saying okay that's it's been better

00:01:56,100 --> 00:02:01,020
lately he's kind of like controlled

00:01:57,869 --> 00:02:05,159
people so there's now right now as of

00:02:01,020 --> 00:02:08,280
today well actually yes I see the three

00:02:05,159 --> 00:02:09,959
sixteen it shouldn't be up there is it

00:02:08,280 --> 00:02:11,700
no yeah it's still there so three two

00:02:09,959 --> 00:02:13,560
three sixty four one four four four nine

00:02:11,700 --> 00:02:16,440
four fourteen they're all

00:02:13,560 --> 00:02:21,180
projected end of life's are the those

00:02:16,440 --> 00:02:25,440
dates I have up there so now with the

00:02:21,180 --> 00:02:26,910
real-time stable releases currently we

00:02:25,440 --> 00:02:30,720
have what we call a development branch

00:02:26,910 --> 00:02:31,739
which is right now on for 14 Sebastien

00:02:30,720 --> 00:02:34,230
not going to try to pronounce his last

00:02:31,739 --> 00:02:37,830
name right now it's he works with Tomas

00:02:34,230 --> 00:02:40,560
collection err and he maintains the 414

00:02:37,830 --> 00:02:43,739
development cycles so all new new code

00:02:40,560 --> 00:02:47,370
or anything that we need to fix or find

00:02:43,739 --> 00:02:50,370
problems with it happens on the 414

00:02:47,370 --> 00:02:52,380
release and right now it's been when 414

00:02:50,370 --> 00:02:54,810
came out we kind of like started on that

00:02:52,380 --> 00:02:58,170
and been working on that for a couple

00:02:54,810 --> 00:03:01,110
years and like is usually could take

00:02:58,170 --> 00:03:04,349
maybe one two or three leases before we

00:03:01,110 --> 00:03:05,940
switch to the next real time kernel

00:03:04,349 --> 00:03:08,670
release to be the development branch

00:03:05,940 --> 00:03:10,950
because we want to make sure that we

00:03:08,670 --> 00:03:13,080
stabilize all the real time development

00:03:10,950 --> 00:03:14,760
or you know make sure that this kernel

00:03:13,080 --> 00:03:16,440
works for real time and sometimes it

00:03:14,760 --> 00:03:19,890
takes a long time it takes two or three

00:03:16,440 --> 00:03:21,570
releases to make sure that happens where

00:03:19,890 --> 00:03:25,980
it's good enough to pass off to the

00:03:21,570 --> 00:03:27,239
stable team and that's why you know 416

00:03:25,980 --> 00:03:29,370
will come out it's going to be the new

00:03:27,239 --> 00:03:32,459
real time so 414 is pretty much stable

00:03:29,370 --> 00:03:34,230
at this moment but until four sixteen

00:03:32,459 --> 00:03:36,420
comes out Sebastian will still maintain

00:03:34,230 --> 00:03:39,180
it once force sixteen comes out he's

00:03:36,420 --> 00:03:41,370
going to stop work on 414 and say Steve

00:03:39,180 --> 00:03:44,489
take it and I will pull it into the

00:03:41,370 --> 00:03:46,980
stable tree at whatever he did is what I

00:03:44,489 --> 00:03:48,660
will start working with and work on it

00:03:46,980 --> 00:03:51,299
so I will be working on the four

00:03:48,660 --> 00:03:53,310
fourteen once that happens so again this

00:03:51,299 --> 00:03:57,150
is about the stable release process not

00:03:53,310 --> 00:04:00,000
about the development process as I

00:03:57,150 --> 00:04:01,410
mentioned there's four fourteen that's

00:04:00,000 --> 00:04:04,859
how his last name is like I said I can't

00:04:01,410 --> 00:04:06,569
pronounce it so right now that we have

00:04:04,859 --> 00:04:09,600
the stable releases are four nine

00:04:06,569 --> 00:04:13,709
maintained by Julia for four maintained

00:04:09,600 --> 00:04:17,039
by Danielle wherever he is for one is

00:04:13,709 --> 00:04:19,260
Julia as well and three 18 is Thompson

00:04:17,039 --> 00:04:23,159
Dulce is going to be maintaining that

00:04:19,260 --> 00:04:25,260
more as a learning process because if

00:04:23,159 --> 00:04:26,760
you're on the 318 Colonel anyone here

00:04:25,260 --> 00:04:27,090
using a three year to eighteen colonel

00:04:26,760 --> 00:04:30,720
and

00:04:27,090 --> 00:04:31,680
how about 3:18 RT colonel you're usually

00:04:30,720 --> 00:04:36,510
308 ERT

00:04:31,680 --> 00:04:38,310
we need to talk because really I was

00:04:36,510 --> 00:04:40,200
told like it's done like we're not

00:04:38,310 --> 00:04:41,910
really helping out so hopefully it still

00:04:40,200 --> 00:04:45,090
works we would really highly recommend

00:04:41,910 --> 00:04:46,650
going beyond that but yeah I still also

00:04:45,090 --> 00:04:48,600
do three too but I don't do any back

00:04:46,650 --> 00:04:50,220
port patches of anything that Sebastian

00:04:48,600 --> 00:04:53,280
comes up with because it's so far away

00:04:50,220 --> 00:04:54,510
that it really is almost meaningless to

00:04:53,280 --> 00:04:56,310
bring it all the way back to three two

00:04:54,510 --> 00:04:57,870
so when three two comes out with a new

00:04:56,310 --> 00:05:00,090
stable release I'll check every so often

00:04:57,870 --> 00:05:03,270
say oh three two has updated the stable

00:05:00,090 --> 00:05:07,760
or a stable colonel I'll forward port it

00:05:03,270 --> 00:05:10,200
or pull in the patches and all that so

00:05:07,760 --> 00:05:16,560
keeping up with the mainline stable

00:05:10,200 --> 00:05:18,090
releases so what do we do so each of the

00:05:16,560 --> 00:05:19,889
our team stable releases if you notice

00:05:18,090 --> 00:05:21,810
maps to one of the long-term stable

00:05:19,889 --> 00:05:23,520
releases we don't usually care about the

00:05:21,810 --> 00:05:24,960
short terms although the development

00:05:23,520 --> 00:05:26,520
process may work on the short terms and

00:05:24,960 --> 00:05:28,500
then go on and then switch up to the

00:05:26,520 --> 00:05:29,820
next one but the stable releases for the

00:05:28,500 --> 00:05:33,720
real-time stable releases we don't care

00:05:29,820 --> 00:05:36,300
about the term kernels we only care

00:05:33,720 --> 00:05:38,280
about the real of those long term stable

00:05:36,300 --> 00:05:40,110
releases and that's what we work on and

00:05:38,280 --> 00:05:43,200
we usually say that we will maintain

00:05:40,110 --> 00:05:45,930
that real-time kernel for as long as

00:05:43,200 --> 00:05:48,180
it's maintained upstream you know so

00:05:45,930 --> 00:05:49,320
three eight three eighteen keeps going

00:05:48,180 --> 00:05:51,570
forward and forward it's like the one

00:05:49,320 --> 00:05:53,010
that it never wants to end but we said

00:05:51,570 --> 00:05:57,389
we're done with it it's just too much

00:05:53,010 --> 00:06:02,970
time too much time consuming but Tom now

00:05:57,389 --> 00:06:04,560
you have a customer so we should

00:06:02,970 --> 00:06:06,860
technically we should really sync up

00:06:04,560 --> 00:06:09,270
with stable releases twice a month

00:06:06,860 --> 00:06:13,889
because Greg Crowe Hartmann is a monster

00:06:09,270 --> 00:06:16,200
machine he seems to pop out stable

00:06:13,889 --> 00:06:20,850
releases like a rabbit pops up you know

00:06:16,200 --> 00:06:22,979
baby rabbits but what you know sometimes

00:06:20,850 --> 00:06:24,600
we're also working we're busy we don't

00:06:22,979 --> 00:06:26,940
always keep up with the stable artis but

00:06:24,600 --> 00:06:30,000
so we try to be good and backboard all

00:06:26,940 --> 00:06:32,310
that so how do we do this when we have a

00:06:30,000 --> 00:06:34,860
new one when we say we're going for

00:06:32,310 --> 00:06:36,450
report to say the stable releases have a

00:06:34,860 --> 00:06:37,680
lot of releases that are out there and

00:06:36,450 --> 00:06:39,210
like we you know we've got to catch up

00:06:37,680 --> 00:06:40,800
we have to you know pull in all the

00:06:39,210 --> 00:06:42,870
fixes that the staples have so

00:06:40,800 --> 00:06:44,520
the real-time kernels not susceptible to

00:06:42,870 --> 00:06:47,520
all the vulnerabilities that the stable

00:06:44,520 --> 00:06:49,590
releases are very fixed so we say okay

00:06:47,520 --> 00:06:52,500
well it's time to know the way I did it

00:06:49,590 --> 00:06:54,569
was I would increment each one so if I

00:06:52,500 --> 00:06:57,000
was like four or five six releases

00:06:54,569 --> 00:06:59,490
behind I would merge in each one

00:06:57,000 --> 00:07:04,080
individually and label and increment the

00:06:59,490 --> 00:07:07,080
RT count each one one one when I do back

00:07:04,080 --> 00:07:08,819
ports from Sebastian's tree which is

00:07:07,080 --> 00:07:11,729
basically he'll find things like oh crap

00:07:08,819 --> 00:07:14,159
this is this breaks real time and it

00:07:11,729 --> 00:07:16,020
affects all this table there affects a

00:07:14,159 --> 00:07:18,060
stable tree as doing suspect one stable

00:07:16,020 --> 00:07:22,530
tree I'll pull we have to pull back

00:07:18,060 --> 00:07:24,300
those fixes as well so every time we

00:07:22,530 --> 00:07:27,840
update with a stable we try to increment

00:07:24,300 --> 00:07:31,349
it so what I do is you know I'll do a

00:07:27,840 --> 00:07:33,240
get merge of four 951 update the local

00:07:31,349 --> 00:07:35,909
version RT everyone know about the local

00:07:33,240 --> 00:07:37,979
version RT or local version files if you

00:07:35,909 --> 00:07:42,419
want to give a little extra tag when you

00:07:37,979 --> 00:07:44,039
do like you name of a your you name - R

00:07:42,419 --> 00:07:46,770
to see what kernel version you're using

00:07:44,039 --> 00:07:49,020
you'll see like - RT one well that comes

00:07:46,770 --> 00:07:50,610
from a local version file so if you have

00:07:49,020 --> 00:07:51,930
a local version file in your kernel this

00:07:50,610 --> 00:07:54,750
is for anyone you want to add an

00:07:51,930 --> 00:07:55,889
extension to make it special so when you

00:07:54,750 --> 00:07:57,479
boot it you can actually see it this is

00:07:55,889 --> 00:08:00,120
a different kernel create a file called

00:07:57,479 --> 00:08:01,169
local version well one word and put

00:08:00,120 --> 00:08:04,050
something in it and that will be

00:08:01,169 --> 00:08:05,130
appended to the kernel version number so

00:08:04,050 --> 00:08:07,500
if you didn't know about that now you

00:08:05,130 --> 00:08:08,759
know so we used somebody called vocal

00:08:07,500 --> 00:08:10,169
version - Marty because it's kind of

00:08:08,759 --> 00:08:12,719
nice because these local version nut

00:08:10,169 --> 00:08:14,550
files that when the make process pulls

00:08:12,719 --> 00:08:17,069
us in it just searches for anything that

00:08:14,550 --> 00:08:18,930
starts with the letters local version so

00:08:17,069 --> 00:08:21,930
we could put local version - RT and add

00:08:18,930 --> 00:08:25,289
an updated so I would read 't it change

00:08:21,930 --> 00:08:27,599
it from RT 4241 commit - a you know make

00:08:25,289 --> 00:08:29,610
a tag on it you know then go to the next

00:08:27,599 --> 00:08:31,740
release since so on and so forth so when

00:08:29,610 --> 00:08:34,380
you look at that if I do a git tag I do

00:08:31,740 --> 00:08:36,240
grep for nine five I see all my releases

00:08:34,380 --> 00:08:38,789
and you'll see it's you know 41 42 43 44

00:08:36,240 --> 00:08:40,890
and I have it actually this is I was way

00:08:38,789 --> 00:08:45,089
behind and caught up by hitting every

00:08:40,890 --> 00:08:52,470
single one of these but it stopped

00:08:45,089 --> 00:08:53,640
happening and so I looked at this I went

00:08:52,470 --> 00:08:54,720
wait a minute where's writing these

00:08:53,640 --> 00:08:57,180
slides I'm like this doesn't

00:08:54,720 --> 00:08:59,519
work like this something happened and I

00:08:57,180 --> 00:09:01,019
first blamed the wrong person and then

00:08:59,519 --> 00:09:06,180
we had a really long discussion with the

00:09:01,019 --> 00:09:07,980
right person so what happened because

00:09:06,180 --> 00:09:09,329
when I first started doing this I kind

00:09:07,980 --> 00:09:11,639
of did it this way but then I was told

00:09:09,329 --> 00:09:15,680
no it's better to label everything every

00:09:11,639 --> 00:09:20,939
single one of them but Julia wasn't i

00:09:15,680 --> 00:09:22,350
Julie the you know she didn't know the

00:09:20,939 --> 00:09:24,689
rationale for why I was doing it

00:09:22,350 --> 00:09:26,160
remember that and actually I had when

00:09:24,689 --> 00:09:28,050
she asked me about that I couldn't even

00:09:26,160 --> 00:09:30,000
remember what the rationale was to tell

00:09:28,050 --> 00:09:32,639
her why we did it for each one why not

00:09:30,000 --> 00:09:33,870
just merge it in and set it so I'm

00:09:32,639 --> 00:09:35,819
thinking well maybe we don't need to do

00:09:33,870 --> 00:09:38,040
this so yesterday we had a real time

00:09:35,819 --> 00:09:40,319
meeting we had a discussion and actually

00:09:38,040 --> 00:09:42,149
there's actually a rationale to do it

00:09:40,319 --> 00:09:43,319
but we don't what there's a compromise

00:09:42,149 --> 00:09:46,139
we don't have to do it for every single

00:09:43,319 --> 00:09:47,910
release so when you look at this if you

00:09:46,139 --> 00:09:50,970
do an increment with the RT what it's

00:09:47,910 --> 00:09:53,670
not always this could happen so if I go

00:09:50,970 --> 00:09:58,649
back and you notice that it was 76 the

00:09:53,670 --> 00:10:00,839
next one was you know for 984 so to do

00:09:58,649 --> 00:10:02,850
this you have to merge in you start off

00:10:00,839 --> 00:10:05,399
with you know get check out for nine RT

00:10:02,850 --> 00:10:07,920
and it's currently at the four 976 rt1

00:10:05,399 --> 00:10:09,779
you do get merged of 84 and you get

00:10:07,920 --> 00:10:12,059
these conflicts now you gotta go and

00:10:09,779 --> 00:10:14,069
look at the conflicts and work on fixed

00:10:12,059 --> 00:10:16,980
so make sure they're right now they go

00:10:14,069 --> 00:10:19,050
back and I looked at this those are

00:10:16,980 --> 00:10:22,829
three conflicts that happened at three

00:10:19,050 --> 00:10:24,629
different stable releases but right now

00:10:22,829 --> 00:10:26,970
we only see it at one we only see it at

00:10:24,629 --> 00:10:29,490
that first at the one with the RT base

00:10:26,970 --> 00:10:31,500
so if something went wrong with that and

00:10:29,490 --> 00:10:34,050
we have to investigate it more it's a

00:10:31,500 --> 00:10:35,759
little bit more difficult to figure out

00:10:34,050 --> 00:10:38,189
the conflicts when you're not at the

00:10:35,759 --> 00:10:40,500
place that introduced the conflict so

00:10:38,189 --> 00:10:43,160
what we're planning on doing from now on

00:10:40,500 --> 00:10:47,399
we agreed that this makes sense is

00:10:43,160 --> 00:10:49,170
instead we could jump we could skip but

00:10:47,399 --> 00:10:52,379
if anything has a conflict we need to

00:10:49,170 --> 00:10:54,629
tag it at that release so we tagged it

00:10:52,379 --> 00:10:56,220
once resolve one conflict go to the next

00:10:54,629 --> 00:10:57,540
one resolve the next conflicts go to the

00:10:56,220 --> 00:10:58,980
next one resolve the next time like so

00:10:57,540 --> 00:11:00,779
it makes it a little bit easier if

00:10:58,980 --> 00:11:02,399
something went wrong because when we're

00:11:00,779 --> 00:11:04,800
resolving conflicts a lot of times it's

00:11:02,399 --> 00:11:06,000
just us doing it so it's only Julia

00:11:04,800 --> 00:11:08,220
doing it it's only myself doing it when

00:11:06,000 --> 00:11:10,860
I'm doing it dan Daniel

00:11:08,220 --> 00:11:12,360
so if we screw up we may not know it may

00:11:10,860 --> 00:11:13,770
work new camera or test it everything

00:11:12,360 --> 00:11:15,060
works but then someone else goes out to

00:11:13,770 --> 00:11:16,410
the field and uses it and they say wait

00:11:15,060 --> 00:11:19,080
this thing's broken we got down to this

00:11:16,410 --> 00:11:20,670
conflict or it was this merge request we

00:11:19,080 --> 00:11:22,890
want to really know exactly where it

00:11:20,670 --> 00:11:24,090
happened so that's so we plan on tagging

00:11:22,890 --> 00:11:27,000
it where the conflicts happen

00:11:24,090 --> 00:11:29,040
so if you see random spots that's why a

00:11:27,000 --> 00:11:31,830
conflict captain here we tagged it we

00:11:29,040 --> 00:11:33,270
fixed it so now it's easier to find one

00:11:31,830 --> 00:11:35,310
of the discussions came up was should we

00:11:33,270 --> 00:11:38,160
add it just a tag just before the

00:11:35,310 --> 00:11:40,830
conflict - well that way you can see if

00:11:38,160 --> 00:11:43,410
it works that works that's kind of up in

00:11:40,830 --> 00:11:47,070
the air we may or may not so that's not

00:11:43,410 --> 00:11:48,930
a requirement we may do it we may not so

00:11:47,070 --> 00:11:51,810
going back to it so what we plan on

00:11:48,930 --> 00:11:53,190
doing now is that each table release if

00:11:51,810 --> 00:11:55,650
a table if there's conflicts we're going

00:11:53,190 --> 00:11:59,280
to tag it or at least we'll do that in

00:11:55,650 --> 00:12:01,920
the future so we do a git merge for 978

00:11:59,280 --> 00:12:03,810
solve the conflicts get commit increment

00:12:01,920 --> 00:12:06,720
the local rip version file go to the

00:12:03,810 --> 00:12:08,610
next one get solve effect when you catch

00:12:06,720 --> 00:12:10,050
up to all this because right now when we

00:12:08,610 --> 00:12:11,400
even we do resolve conflicts now about

00:12:10,050 --> 00:12:13,590
how you don't want to resolve complex on

00:12:11,400 --> 00:12:16,290
one eye basically okay resolved I'll

00:12:13,590 --> 00:12:18,900
just compile the kernel boot it run a

00:12:16,290 --> 00:12:20,670
few simple tests basically does it boot

00:12:18,900 --> 00:12:22,680
up does it run does it can handle some

00:12:20,670 --> 00:12:24,030
you know priority inheritance work yes

00:12:22,680 --> 00:12:26,610
it does okay good enough go to the next

00:12:24,030 --> 00:12:28,290
one and I don't spend too much time on

00:12:26,610 --> 00:12:31,260
it because once I get to that final one

00:12:28,290 --> 00:12:33,060
where I catch up to main line stable

00:12:31,260 --> 00:12:34,440
that's why I'm gonna do all my tests and

00:12:33,060 --> 00:12:35,760
my test could take several hours and I

00:12:34,440 --> 00:12:37,860
don't want to waste the time each time

00:12:35,760 --> 00:12:39,750
is it you know this takes time and we're

00:12:37,860 --> 00:12:42,540
not doing this full-time this is kind of

00:12:39,750 --> 00:12:46,200
off we have other jobs to do so this is

00:12:42,540 --> 00:12:48,240
hopefully extra so once you catch up to

00:12:46,200 --> 00:12:49,530
the final release that you're now equal

00:12:48,240 --> 00:12:51,000
to what's stable out there although

00:12:49,530 --> 00:12:53,040
usually when I'm done with my test

00:12:51,000 --> 00:12:56,180
Gregor Hartman put out another stable

00:12:53,040 --> 00:12:56,180
and I usually curse them for that

00:12:56,750 --> 00:13:02,820
so we catch up we run our tests it

00:13:00,600 --> 00:13:04,710
passes great you know our test passes is

00:13:02,820 --> 00:13:07,950
good we're solid so we need to make a

00:13:04,710 --> 00:13:10,350
release now we also have to make a

00:13:07,950 --> 00:13:14,150
tarball because actually here's probably

00:13:10,350 --> 00:13:18,530
good question that asks the audience

00:13:14,150 --> 00:13:21,510
well here's use the preempt RT patch RT

00:13:18,530 --> 00:13:26,010
okay who does it from

00:13:21,510 --> 00:13:29,820
get only ooh who uses the tarballs

00:13:26,010 --> 00:13:32,510
or the patch cues okay good

00:13:29,820 --> 00:13:36,959
so it is okay so we'll continue this

00:13:32,510 --> 00:13:39,240
thank you so when I first started doing

00:13:36,959 --> 00:13:41,459
this become creating the stable arty

00:13:39,240 --> 00:13:44,040
patches all I would do is just merge the

00:13:41,459 --> 00:13:46,740
stuff and I used get cherry to create

00:13:44,040 --> 00:13:48,899
the patch quilt and got this little

00:13:46,740 --> 00:13:50,940
patch queue and I kept pushing I made my

00:13:48,899 --> 00:13:53,490
patch queue by using you know merge the

00:13:50,940 --> 00:13:55,290
stuff use get cherry to give me all the

00:13:53,490 --> 00:13:58,170
changes that's different and then make

00:13:55,290 --> 00:13:59,459
the queue and blah blah blah well people

00:13:58,170 --> 00:14:05,240
are telling me that these patches did

00:13:59,459 --> 00:14:07,920
not apply it didn't work so I had this

00:14:05,240 --> 00:14:12,510
patch that I had to apply that's from

00:14:07,920 --> 00:14:13,889
Sebastian and for those that don't have

00:14:12,510 --> 00:14:18,209
good eyesight like myself here's a

00:14:13,889 --> 00:14:21,060
little zoom in so if you look at it it

00:14:18,209 --> 00:14:23,970
did something simple it just removed you

00:14:21,060 --> 00:14:25,769
know a function and I hello why exactly

00:14:23,970 --> 00:14:28,290
I had some sort of issue boom bla bla

00:14:25,769 --> 00:14:29,490
bla so he found out that this wasn't

00:14:28,290 --> 00:14:31,500
needed we could just delete it

00:14:29,490 --> 00:14:34,440
for the real-time patch I'm not going to

00:14:31,500 --> 00:14:36,449
go into the details of why this so now

00:14:34,440 --> 00:14:39,870
you go to the thing the thing is you go

00:14:36,449 --> 00:14:42,480
to the next release and one of the

00:14:39,870 --> 00:14:44,339
stable releases modified that function

00:14:42,480 --> 00:14:48,569
all did was change the work queue to

00:14:44,339 --> 00:14:50,699
make it a little bit different and next

00:14:48,569 --> 00:14:53,490
thing you know you go to look at what

00:14:50,699 --> 00:14:54,810
was changed and I just realized by

00:14:53,490 --> 00:14:57,000
looking at this you know Sebastian

00:14:54,810 --> 00:14:59,339
somewhere they did this because this was

00:14:57,000 --> 00:15:00,329
before I went to real-time I went to the

00:14:59,339 --> 00:15:02,610
stable release this is actually

00:15:00,329 --> 00:15:06,449
Sebastian's work I'm wondering if it

00:15:02,610 --> 00:15:09,089
will still crash with this update so

00:15:06,449 --> 00:15:14,069
maybe this is even needed that's a good

00:15:09,089 --> 00:15:15,269
thing we should probably bugging while

00:15:14,069 --> 00:15:18,209
giving a presentation because I just

00:15:15,269 --> 00:15:21,060
thought about that now anyway you notice

00:15:18,209 --> 00:15:22,889
the conflict right now with this the

00:15:21,060 --> 00:15:24,870
fact that one changes so I tried to

00:15:22,889 --> 00:15:27,990
apply the patch I'm going to get this

00:15:24,870 --> 00:15:31,769
error you know hump fail bla bla bla bla

00:15:27,990 --> 00:15:33,420
that's because it doesn't match so you

00:15:31,769 --> 00:15:35,250
can't just do a cherry-pick of all the

00:15:33,420 --> 00:15:38,010
patches that are different you

00:15:35,250 --> 00:15:41,460
need to make a queue that's based off of

00:15:38,010 --> 00:15:45,060
the latest stable release so once we got

00:15:41,460 --> 00:15:48,420
up to four nine like say for 911 on this

00:15:45,060 --> 00:15:50,790
case if you look into the stable get

00:15:48,420 --> 00:15:53,160
tree you'll notice that there's get a

00:15:50,790 --> 00:15:56,790
stable tree but you also see a - rebase

00:15:53,160 --> 00:15:59,670
tree the stable tree numbers where you

00:15:56,790 --> 00:16:02,400
see our t1 or t2 whatever they never are

00:15:59,670 --> 00:16:04,410
we based so if you pull from it and

00:16:02,400 --> 00:16:05,880
develop on it you don't need to worry

00:16:04,410 --> 00:16:07,350
about it breaking your code when you do

00:16:05,880 --> 00:16:09,990
the next pull they never may never

00:16:07,350 --> 00:16:12,960
rebase we update them and that's it

00:16:09,990 --> 00:16:15,720
so we make a rebase branch because as

00:16:12,960 --> 00:16:17,760
the name suggests is we rebase it every

00:16:15,720 --> 00:16:20,400
time so the rebased branch will always

00:16:17,760 --> 00:16:23,160
rebase and we tag it with a rebase the

00:16:20,400 --> 00:16:24,930
difference between the two branches if

00:16:23,160 --> 00:16:26,520
you do if you notice get diff there that

00:16:24,930 --> 00:16:28,170
actually if you do a git diff between

00:16:26,520 --> 00:16:29,790
the non-tree base and the rebased branch

00:16:28,170 --> 00:16:32,490
they are identical they are there's

00:16:29,790 --> 00:16:33,960
nothing different of the code base but

00:16:32,490 --> 00:16:36,810
how you got there are completely

00:16:33,960 --> 00:16:38,190
different one is incremental we apply

00:16:36,810 --> 00:16:39,839
too much of real-time patches did a

00:16:38,190 --> 00:16:41,880
bunch of merges of stable added some

00:16:39,839 --> 00:16:44,310
more real-time patches then more merges

00:16:41,880 --> 00:16:48,660
and so on and so forth the rebase branch

00:16:44,310 --> 00:16:51,750
starts from the stable release so for

00:16:48,660 --> 00:16:54,390
9/11 here and it will actually have all

00:16:51,750 --> 00:16:56,730
the patches built on top of it so when I

00:16:54,390 --> 00:16:58,410
make a quilt queue or whatever I use the

00:16:56,730 --> 00:16:59,880
rebased branch to pull I just say give

00:16:58,410 --> 00:17:01,350
me all the changes from here to here

00:16:59,880 --> 00:17:03,540
because I know they all will apply

00:17:01,350 --> 00:17:10,920
nicely for when you guys download the

00:17:03,540 --> 00:17:13,170
code so a little arty overview now RT is

00:17:10,920 --> 00:17:15,350
coming to mainline it will be there

00:17:13,170 --> 00:17:15,350
shortly

00:17:17,089 --> 00:17:24,110
everyone says yeah yeah

00:17:19,709 --> 00:17:29,190
bye latest 2020 hopefully by 2019

00:17:24,110 --> 00:17:32,340
possibly by the end of this year depends

00:17:29,190 --> 00:17:35,820
on several factors that's beyond the

00:17:32,340 --> 00:17:37,290
scope of this talk but this is very

00:17:35,820 --> 00:17:40,380
important because people are gonna have

00:17:37,290 --> 00:17:42,390
to start understanding how RT sort of

00:17:40,380 --> 00:17:44,490
works or a little bit of the concepts

00:17:42,390 --> 00:17:46,560
because when you are working on the

00:17:44,490 --> 00:17:48,960
kernel and you don't care about real

00:17:46,560 --> 00:17:51,029
time if real times in main

00:17:48,960 --> 00:17:52,590
mine that means that you if you break

00:17:51,029 --> 00:17:53,870
real time you've got to change your code

00:17:52,590 --> 00:18:02,760
to fix it

00:17:53,870 --> 00:18:04,289
yes config time you either enable it or

00:18:02,760 --> 00:18:07,169
you disable it but it doesn't matter you

00:18:04,289 --> 00:18:09,990
can have it disabled and if you are you

00:18:07,169 --> 00:18:11,970
developing a Linux kernel you could

00:18:09,990 --> 00:18:14,309
break real time without ever turning it

00:18:11,970 --> 00:18:16,649
on and we're going to hopefully have

00:18:14,309 --> 00:18:18,120
bots and stuff like that complained to

00:18:16,649 --> 00:18:20,159
you as soon as you push it to get trees

00:18:18,120 --> 00:18:22,049
or whatever we're going to start we're

00:18:20,159 --> 00:18:25,260
going to start monitoring people and

00:18:22,049 --> 00:18:27,960
policing you folks so we're going to

00:18:25,260 --> 00:18:29,580
give you some ideas about things one of

00:18:27,960 --> 00:18:32,580
the few things that real time does is it

00:18:29,580 --> 00:18:34,529
turns spin locks into mutexes that makes

00:18:32,580 --> 00:18:37,289
the things much more preemptable so a

00:18:34,529 --> 00:18:39,390
spin lock don't expect it to be

00:18:37,289 --> 00:18:41,940
preemptable or not a turn preemption off

00:18:39,390 --> 00:18:44,399
so if you need to if you need to

00:18:41,940 --> 00:18:47,159
basically make sure that this code here

00:18:44,399 --> 00:18:48,419
is not preempted a spin lock is not

00:18:47,159 --> 00:18:49,740
going to guarantee that that will happen

00:18:48,419 --> 00:18:52,080
once you turn into the real-time world

00:18:49,740 --> 00:18:55,620
it will guarantee that you stay on that

00:18:52,080 --> 00:18:57,029
CPU so it disables migration so in the

00:18:55,620 --> 00:18:59,700
real time place if you do a spin lock

00:18:57,029 --> 00:19:01,020
your migration will be disabled so you

00:18:59,700 --> 00:19:03,059
could guarantee that you'll still stay

00:19:01,020 --> 00:19:04,230
on that CPU but it doesn't mean that

00:19:03,059 --> 00:19:05,820
something else can't come in and do

00:19:04,230 --> 00:19:08,820
something there so you have to worry

00:19:05,820 --> 00:19:10,919
about that spin lock irq save does not

00:19:08,820 --> 00:19:12,320
will not disable interrupts but in the

00:19:10,919 --> 00:19:15,270
real-time world interrupts our threads

00:19:12,320 --> 00:19:17,070
so I thread interrup could still come in

00:19:15,270 --> 00:19:19,230
there so it still needs that spin lock

00:19:17,070 --> 00:19:22,500
so spin lock req save if you do spin

00:19:19,230 --> 00:19:25,260
lock eirick you save and access per CPU

00:19:22,500 --> 00:19:26,279
variables that the interrupts shouldn't

00:19:25,260 --> 00:19:27,720
handle and you're saying well I just

00:19:26,279 --> 00:19:31,350
able to interrupts so this guy shouldn't

00:19:27,720 --> 00:19:33,120
care about it well it can still get to

00:19:31,350 --> 00:19:34,770
it unless there's a spin lock protecting

00:19:33,120 --> 00:19:36,059
that section in the in the interrupt

00:19:34,770 --> 00:19:37,289
handler so spin lock eirick you save

00:19:36,059 --> 00:19:39,270
does that mean that it's going to

00:19:37,289 --> 00:19:40,770
prevent a interrupt from actually happy

00:19:39,270 --> 00:19:42,090
in that case in the real-time world so

00:19:40,770 --> 00:19:44,070
we have to think about this and by the

00:19:42,090 --> 00:19:45,630
way thread and erips are in mainline

00:19:44,070 --> 00:19:48,360
kernel so actually kind of true

00:19:45,630 --> 00:19:49,559
regardless although ya smell like eirick

00:19:48,360 --> 00:19:52,039
you save does it's disables preemption

00:19:49,559 --> 00:19:54,450
in mainline so it still protects it

00:19:52,039 --> 00:19:56,279
priority inheritance is there so

00:19:54,450 --> 00:19:57,600
sleeping locks the sleeping locks will

00:19:56,279 --> 00:20:01,270
get the same priority inheritance that

00:19:57,600 --> 00:20:02,799
few texas have today so

00:20:01,270 --> 00:20:04,090
here's my I love I always have to throw

00:20:02,799 --> 00:20:06,520
this slide and I think I threw the slide

00:20:04,090 --> 00:20:09,789
in back in 2007 when game I talked at

00:20:06,520 --> 00:20:12,220
the Ottawa Linux suppose iam about

00:20:09,789 --> 00:20:14,649
understanding the real-time patch and I

00:20:12,220 --> 00:20:17,200
just love this slide so I have to reuse

00:20:14,649 --> 00:20:21,429
it and all my talks about real time just

00:20:17,200 --> 00:20:24,940
so those who here is uncuffed about what

00:20:21,429 --> 00:20:28,419
priority inversion is okay you all so

00:20:24,940 --> 00:20:29,890
guy skip it so normal case you have

00:20:28,419 --> 00:20:32,740
prior inversion I'll be quick then you

00:20:29,890 --> 00:20:35,799
know prior heritance will inherit the

00:20:32,740 --> 00:20:38,220
task so task C gets the priority and

00:20:35,799 --> 00:20:40,690
then the guy so going back to this one

00:20:38,220 --> 00:20:43,270
the old I know I'm gonna explain this

00:20:40,690 --> 00:20:46,270
you guys already know this ace highest

00:20:43,270 --> 00:20:48,760
priority B's second C's third if C runs

00:20:46,270 --> 00:20:51,070
gets preempted a bronze grabs a lock

00:20:48,760 --> 00:20:53,919
that C owns so C runs again it gets

00:20:51,070 --> 00:20:56,710
preempted by B goes on forever and a

00:20:53,919 --> 00:20:59,320
never runs so be not only blocks C but

00:20:56,710 --> 00:21:00,610
also prevents a from running so priority

00:20:59,320 --> 00:21:02,529
heritance means that you know once you

00:21:00,610 --> 00:21:04,809
give the lock up if we're sorry when a

00:21:02,529 --> 00:21:07,419
blocks on C it C will inherit the

00:21:04,809 --> 00:21:10,899
priority of a so a runs so when B wakes

00:21:07,419 --> 00:21:13,539
up it can't interrupt or preempted C so

00:21:10,899 --> 00:21:15,640
then it could finish and once it

00:21:13,539 --> 00:21:18,010
releases a lock it loses a priority so a

00:21:15,640 --> 00:21:21,299
gets go ron's finish this sleeps and B

00:21:18,010 --> 00:21:24,520
continues priority inheritance

00:21:21,299 --> 00:21:26,409
implementation is hard okay can be get

00:21:24,520 --> 00:21:29,440
really complex it's been through several

00:21:26,409 --> 00:21:31,510
iterations it looks nothing like it was

00:21:29,440 --> 00:21:37,179
when we first introduced it way back in

00:21:31,510 --> 00:21:38,289
2004 or three maybe perhaps and one of

00:21:37,179 --> 00:21:39,490
the things that you have to realize in

00:21:38,289 --> 00:21:44,070
the real-time kernel that we're going to

00:21:39,490 --> 00:21:47,409
do is read reader read writer locks

00:21:44,070 --> 00:21:51,340
where you have multiple readers and a

00:21:47,409 --> 00:21:54,730
single writer to do it to keep the same

00:21:51,340 --> 00:21:56,380
paradigm as the Linux kernel you'd and

00:21:54,730 --> 00:21:57,970
you want to keep priority heritance you

00:21:56,380 --> 00:22:00,039
have to have multiple priority

00:21:57,970 --> 00:22:01,270
inheritance which means this if you have

00:22:00,039 --> 00:22:02,919
a bunch of readers running at low

00:22:01,270 --> 00:22:04,510
priority and a high priority processes

00:22:02,919 --> 00:22:07,480
running and grabs a writer lock and

00:22:04,510 --> 00:22:09,639
preempts to get priority version from

00:22:07,480 --> 00:22:11,590
happening because now it's blocked on

00:22:09,639 --> 00:22:13,389
every single reader until all those

00:22:11,590 --> 00:22:14,860
readers release their lock the writer

00:22:13,389 --> 00:22:16,900
can't go

00:22:14,860 --> 00:22:19,150
so multiple prior inheritance means that

00:22:16,900 --> 00:22:23,920
you have to update the priority of every

00:22:19,150 --> 00:22:27,220
single thread that that writer is

00:22:23,920 --> 00:22:29,049
waiting on that gets complex it gets

00:22:27,220 --> 00:22:31,630
actually exponentially more complex than

00:22:29,049 --> 00:22:34,270
the original real priority inheritance

00:22:31,630 --> 00:22:35,650
code so there's three things that we

00:22:34,270 --> 00:22:36,880
could do or well Thomas will say two

00:22:35,650 --> 00:22:40,750
things that we can do because Thomas

00:22:36,880 --> 00:22:43,510
hates the third one and I implement it

00:22:40,750 --> 00:22:44,309
once so I but he always says I'm just

00:22:43,510 --> 00:22:48,370
crazy

00:22:44,309 --> 00:22:50,320
first thing is serialize our readers so

00:22:48,370 --> 00:22:52,270
we turn in fact actually that's what the

00:22:50,320 --> 00:22:54,520
real time I think I don't we switched it

00:22:52,270 --> 00:22:56,559
back yet for a longest time out we're

00:22:54,520 --> 00:22:58,780
discussing switching to two but the

00:22:56,559 --> 00:23:00,580
first thing we do is we serialize all

00:22:58,780 --> 00:23:02,070
readers so if you have a reader write a

00:23:00,580 --> 00:23:05,650
lock

00:23:02,070 --> 00:23:07,270
they become it comes up mutex so every

00:23:05,650 --> 00:23:09,429
reader will now see relies on every

00:23:07,270 --> 00:23:11,830
other reader so if you have you know a

00:23:09,429 --> 00:23:14,020
reader/writer lock across 60 CPUs and

00:23:11,830 --> 00:23:15,820
you have 60 readers go they just went

00:23:14,020 --> 00:23:17,500
one two three and they all have to wait

00:23:15,820 --> 00:23:19,900
for the one that has a reader that could

00:23:17,500 --> 00:23:22,600
be a long latency there that's it causes

00:23:19,900 --> 00:23:25,260
slowdown because of performance problems

00:23:22,600 --> 00:23:27,610
it causes a lot of bad things to happen

00:23:25,260 --> 00:23:29,530
we would love to get rid of reader

00:23:27,610 --> 00:23:31,870
writer locks used RCU or find some other

00:23:29,530 --> 00:23:33,429
way of doing it because reader writer

00:23:31,870 --> 00:23:34,870
locks are horrible on the cache line for

00:23:33,429 --> 00:23:36,490
main line kernels so just because like

00:23:34,870 --> 00:23:38,770
oh it's a bad for real time no it's also

00:23:36,490 --> 00:23:40,330
bad for main line because of the cache

00:23:38,770 --> 00:23:41,620
bouncing around you could actually kill

00:23:40,330 --> 00:23:44,260
performance with redirector locks as

00:23:41,620 --> 00:23:46,809
well so we like saying get rid of it but

00:23:44,260 --> 00:23:48,220
if you have it the second thing we're

00:23:46,809 --> 00:23:49,809
thinking of doing is saying screw it

00:23:48,220 --> 00:23:52,000
reader writer locks are not going to be

00:23:49,809 --> 00:23:55,210
converted to priority inheritance if you

00:23:52,000 --> 00:23:56,860
use reader writer locks good luck you

00:23:55,210 --> 00:24:00,640
could you could have priority inversion

00:23:56,860 --> 00:24:00,910
and so be it third thing is to say screw

00:24:00,640 --> 00:24:04,120
it

00:24:00,910 --> 00:24:07,390
do it the complex way my way I've done

00:24:04,120 --> 00:24:10,480
this twice I've implemented multi

00:24:07,390 --> 00:24:12,880
multiple reader priority inheritance

00:24:10,480 --> 00:24:14,380
it actually works rather well but Thomas

00:24:12,880 --> 00:24:18,040
hates it because of it adds the added

00:24:14,380 --> 00:24:19,480
complexity is at a higher level then the

00:24:18,040 --> 00:24:21,190
Linux kernel should actually have

00:24:19,480 --> 00:24:23,410
something that you need something stable

00:24:21,190 --> 00:24:26,760
on it's almost almost impossible to

00:24:23,410 --> 00:24:30,030
prove that it's correct but it's there

00:24:26,760 --> 00:24:30,030
it's fun

00:24:31,179 --> 00:24:35,240
now I said preemption usually gets

00:24:33,710 --> 00:24:38,750
disabled by spin locks and preamp tarty

00:24:35,240 --> 00:24:40,279
it doesn't so if you have per CPU

00:24:38,750 --> 00:24:43,460
critical sections you have to be careful

00:24:40,279 --> 00:24:47,450
that you're used to you know spin lock

00:24:43,460 --> 00:24:49,820
our Q safe so some places we have you

00:24:47,450 --> 00:24:51,139
don't use spin locks we have a lot of

00:24:49,820 --> 00:24:53,000
place that you just do preamp disable

00:24:51,139 --> 00:24:54,230
and I've seen places where they do primp

00:24:53,000 --> 00:24:56,120
disable and then they grab a spin lock

00:24:54,230 --> 00:24:58,519
or something which will break Artie

00:24:56,120 --> 00:25:02,509
because Artie spin locks are mutexes and

00:24:58,519 --> 00:25:04,669
in in the main Linux kernel you can't do

00:25:02,509 --> 00:25:05,480
preamp disable and call a mutex that

00:25:04,669 --> 00:25:07,129
breaks as well

00:25:05,480 --> 00:25:08,750
so since spin locks are mutex it's in

00:25:07,129 --> 00:25:11,149
real time you can't do pre have disable

00:25:08,750 --> 00:25:12,799
and I call a spin lock what we have

00:25:11,149 --> 00:25:14,179
instead is what we call a local luck

00:25:12,799 --> 00:25:16,279
because usually we need to primp disable

00:25:14,179 --> 00:25:18,379
you're doing it mainly to serialize some

00:25:16,279 --> 00:25:20,570
critical section you have some data

00:25:18,379 --> 00:25:22,129
that's usually per CPU and you know that

00:25:20,570 --> 00:25:23,120
the only way to protect it instead of

00:25:22,129 --> 00:25:24,620
worry about cache lines because

00:25:23,120 --> 00:25:26,299
reader/writer locks are horrible so what

00:25:24,620 --> 00:25:32,570
you do is you one thing you do instead

00:25:26,299 --> 00:25:35,000
is you create a per CPU data and this

00:25:32,570 --> 00:25:36,409
per CPU data is just protected by a

00:25:35,000 --> 00:25:38,509
preamp disable because once you preempt

00:25:36,409 --> 00:25:40,009
this able and you know what to worry

00:25:38,509 --> 00:25:42,049
about say if interrupts don't touch it

00:25:40,009 --> 00:25:44,389
no other thread can touch that data

00:25:42,049 --> 00:25:45,830
because it's per CPU so that's a normal

00:25:44,389 --> 00:25:47,029
common way of doing getting rid of read

00:25:45,830 --> 00:25:49,190
or write or walks like I said rewrite

00:25:47,029 --> 00:25:52,190
locks are bad priam disables good well

00:25:49,190 --> 00:25:53,840
now for real-time so these sometimes you

00:25:52,190 --> 00:25:55,580
get these huge sections of preamp

00:25:53,840 --> 00:25:56,750
disabled which means that whatever huge

00:25:55,580 --> 00:25:58,190
section of print-disabled that means the

00:25:56,750 --> 00:25:59,960
latency of waking up a task that needs

00:25:58,190 --> 00:26:01,940
to run right away has to wait for that

00:25:59,960 --> 00:26:04,070
preempt is able to finish so that adds

00:26:01,940 --> 00:26:05,570
latency so we don't want that what we

00:26:04,070 --> 00:26:07,220
haven't said is a new feature that's

00:26:05,570 --> 00:26:10,309
going to come next at the mainline

00:26:07,220 --> 00:26:14,000
kernel so it's coming this year probably

00:26:10,309 --> 00:26:16,250
in a month or two is local locks local

00:26:14,000 --> 00:26:19,820
lock is a way of replacing both preamp

00:26:16,250 --> 00:26:22,820
disable and even irq disable you say

00:26:19,820 --> 00:26:25,669
local lock you give it a name and in the

00:26:22,820 --> 00:26:27,679
real time or in the mainline kernel that

00:26:25,669 --> 00:26:29,840
local lock is nothing more than preamp

00:26:27,679 --> 00:26:31,490
disable your code actually does not

00:26:29,840 --> 00:26:34,580
change or if you compile it it's

00:26:31,490 --> 00:26:36,889
identical to what you have today so come

00:26:34,580 --> 00:26:39,139
see you slow clock now why is this good

00:26:36,889 --> 00:26:40,490
for you you don't care about preempt RT

00:26:39,139 --> 00:26:42,620
you don't care about real time you only

00:26:40,490 --> 00:26:46,790
care about your code your mainline code

00:26:42,620 --> 00:26:48,860
it annotates what you're protecting this

00:26:46,790 --> 00:26:50,120
way you could say hey a lot of times

00:26:48,860 --> 00:26:50,990
have you I don't know how many people

00:26:50,120 --> 00:26:52,070
have done this I've done this a few

00:26:50,990 --> 00:26:53,420
times look at your kernel you see a

00:26:52,070 --> 00:26:53,600
print-disabled look right good you see

00:26:53,420 --> 00:26:57,220
it

00:26:53,600 --> 00:27:00,740
local Eric you disabled and you say why

00:26:57,220 --> 00:27:02,570
how many people have done that whew okay

00:27:00,740 --> 00:27:04,160
there's a lot of times you go through

00:27:02,570 --> 00:27:06,410
and you'll see preempt disabled like why

00:27:04,160 --> 00:27:08,300
is this here and there's this all this

00:27:06,410 --> 00:27:10,340
code that goes on and it's because

00:27:08,300 --> 00:27:12,830
something here and here are related

00:27:10,340 --> 00:27:15,080
nothing tells you why so we have to go

00:27:12,830 --> 00:27:18,980
through get logs history talk to the

00:27:15,080 --> 00:27:21,309
author who usually says to you I forgot

00:27:18,980 --> 00:27:25,340
[Laughter]

00:27:21,309 --> 00:27:27,200
so local lock is actually a way to put a

00:27:25,340 --> 00:27:29,690
name there and then you can actually say

00:27:27,200 --> 00:27:31,850
this is protected by the local lock this

00:27:29,690 --> 00:27:34,190
so now you actually know when you see

00:27:31,850 --> 00:27:35,929
local lock with a name on it hey this

00:27:34,190 --> 00:27:37,880
actually has a rationale I know I could

00:27:35,929 --> 00:27:39,980
figure this in the future even when I

00:27:37,880 --> 00:27:42,320
forgot why I wrote this code I know why

00:27:39,980 --> 00:27:44,150
this preemption was disabled but it's

00:27:42,320 --> 00:27:49,910
really a local lock that says okay this

00:27:44,150 --> 00:27:52,730
prevents you know other things yes it's

00:27:49,910 --> 00:27:54,230
a macro that will turn in into a preamp

00:27:52,730 --> 00:27:56,710
disable actually it could be a yeah I

00:27:54,230 --> 00:27:59,690
think it's a macro or it could also be a

00:27:56,710 --> 00:28:01,340
inline what's called static inline

00:27:59,690 --> 00:28:03,230
function but it's going to be like a

00:28:01,340 --> 00:28:06,500
macro and depending on the configuration

00:28:03,230 --> 00:28:07,610
it'll change in reeled in on RT what it

00:28:06,500 --> 00:28:12,250
will turn into will be turning into

00:28:07,610 --> 00:28:12,250
actually a mutex with migration disabled

00:28:12,760 --> 00:28:18,290
yes it's basically you can annotate what

00:28:16,580 --> 00:28:20,300
you're protecting so that's the

00:28:18,290 --> 00:28:22,640
rationale of giving it to mainline even

00:28:20,300 --> 00:28:25,070
though it helps RT greatly it's going to

00:28:22,640 --> 00:28:27,290
help main line as well so the local box

00:28:25,070 --> 00:28:34,760
our way of annotating blocks were that

00:28:27,290 --> 00:28:36,860
annotation that name will be yes yes

00:28:34,760 --> 00:28:39,650
stay for the next presentation julia has

00:28:36,860 --> 00:28:41,360
some yes so stage she's going to tell

00:28:39,650 --> 00:28:42,320
you a lot of stuff that I'm talking

00:28:41,360 --> 00:28:46,850
about right now but you'll get a lot

00:28:42,320 --> 00:28:50,510
more details yes so I'll just follow you

00:28:46,850 --> 00:28:52,280
want after this talk anyway so the local

00:28:50,510 --> 00:28:53,929
locks are good for that and it becomes a

00:28:52,280 --> 00:28:55,670
mutex or whatever and it's also a per

00:28:53,929 --> 00:28:56,360
CPU mutex so you don't worry about the

00:28:55,670 --> 00:28:58,280
cache line

00:28:56,360 --> 00:29:00,170
bouncing so when you grab a local lock

00:28:58,280 --> 00:29:02,840
it's only grabbing a lock for that CPU

00:29:00,170 --> 00:29:03,980
so if it if you schedule out migrations

00:29:02,840 --> 00:29:06,080
disabled you're always going to stay on

00:29:03,980 --> 00:29:07,670
that CPU but if something schedules in

00:29:06,080 --> 00:29:09,170
and goes to that same critical path

00:29:07,670 --> 00:29:11,480
they're going to block on that local

00:29:09,170 --> 00:29:12,950
lock until the other guy comes back and

00:29:11,480 --> 00:29:14,900
it has priority inheritance and all the

00:29:12,950 --> 00:29:16,820
wonderful stuff to get everything moving

00:29:14,900 --> 00:29:17,750
flowing just like a normal spin lock but

00:29:16,820 --> 00:29:19,250
you don't have to worry about that

00:29:17,750 --> 00:29:21,530
that's we take care of all the details

00:29:19,250 --> 00:29:25,760
just protect your sections with these

00:29:21,530 --> 00:29:27,470
local locks interrupts are the same way

00:29:25,760 --> 00:29:30,440
now interrupts a little bit more we have

00:29:27,470 --> 00:29:33,799
a lot of times you'll have per CPU data

00:29:30,440 --> 00:29:37,160
that can be accessed by interrupts now

00:29:33,799 --> 00:29:38,720
in mainline local irq save it was good

00:29:37,160 --> 00:29:40,340
enough to do this because when the

00:29:38,720 --> 00:29:41,510
interrupt goes off you're going to have

00:29:40,340 --> 00:29:43,190
the same thing you have to interrupt

00:29:41,510 --> 00:29:45,380
that goes into the that may access this

00:29:43,190 --> 00:29:46,549
per CPU data and you have to stop the

00:29:45,380 --> 00:29:48,799
inter from happening so preemption

00:29:46,549 --> 00:29:50,750
disable is not enough because preemption

00:29:48,799 --> 00:29:52,700
will keep other tasks from coming in it

00:29:50,750 --> 00:29:54,770
doesn't stop interrupts so local Eric

00:29:52,700 --> 00:29:56,450
you save so we'll we got now is instead

00:29:54,770 --> 00:29:59,750
of using local Eric you save you use

00:29:56,450 --> 00:30:02,210
local lock irq safe and you annotate it

00:29:59,750 --> 00:30:05,240
and then the interrupt itself will have

00:30:02,210 --> 00:30:07,640
to say it will only do local lock irq

00:30:05,240 --> 00:30:09,620
memory that's only a preamp disable in

00:30:07,640 --> 00:30:11,179
main line but it doesn't matter preamp

00:30:09,620 --> 00:30:14,090
disable and interrupt this kind of a no

00:30:11,179 --> 00:30:17,650
op so you know what this you still mark

00:30:14,090 --> 00:30:21,020
it and then you could say what it is

00:30:17,650 --> 00:30:21,980
another thing that we have to is we're

00:30:21,020 --> 00:30:23,120
coding I don't know if we're going to

00:30:21,980 --> 00:30:24,410
try to get rid of this I don't know if

00:30:23,120 --> 00:30:25,910
we're going to keep it but if you're

00:30:24,410 --> 00:30:27,200
ever doing anything stable artis again

00:30:25,910 --> 00:30:30,200
look at this we have something called

00:30:27,200 --> 00:30:33,200
local RQ disabled underscore no RT which

00:30:30,200 --> 00:30:35,540
basically says if you don't have RT

00:30:33,200 --> 00:30:38,360
configured it's local Eric you disabled

00:30:35,540 --> 00:30:41,120
if you do have our RT configured it's a

00:30:38,360 --> 00:30:43,130
no op but those are ugly I think we're

00:30:41,120 --> 00:30:47,330
trying to get we're afraid of adding

00:30:43,130 --> 00:30:49,130
those there they're just kind of ugly so

00:30:47,330 --> 00:30:52,429
eventually you go and you do a merge and

00:30:49,130 --> 00:30:55,640
you do a git merge for your stable tree

00:30:52,429 --> 00:30:58,100
and you get a conflict you guy an oh

00:30:55,640 --> 00:30:59,750
crap I actually have to think because a

00:30:58,100 --> 00:31:00,830
lot of times stable releases if you do a

00:30:59,750 --> 00:31:02,690
get merge and everything goes fine

00:31:00,830 --> 00:31:04,490
there's no thinking it's really just

00:31:02,690 --> 00:31:06,200
monkey work you just ok get merged just

00:31:04,490 --> 00:31:08,390
boom-boom Bhosle scripts so it's get

00:31:06,200 --> 00:31:10,040
there yeah yeah do this you just read

00:31:08,390 --> 00:31:11,780
Facebook while you're you know

00:31:10,040 --> 00:31:13,220
automated processes going on and when

00:31:11,780 --> 00:31:15,290
it's done like okay you commit and do

00:31:13,220 --> 00:31:20,060
everything but then if you do a get

00:31:15,290 --> 00:31:23,920
merge you say oh crap I actually have to

00:31:20,060 --> 00:31:27,560
think now conflicts are actually good

00:31:23,920 --> 00:31:30,580
because there's a lot of times I not a

00:31:27,560 --> 00:31:33,470
lot of times there's a few times that a

00:31:30,580 --> 00:31:35,780
merge happened where it didn't conflict

00:31:33,470 --> 00:31:40,030
and that actually but it had a bug in

00:31:35,780 --> 00:31:42,410
there I'll talk about that later so

00:31:40,030 --> 00:31:47,480
let's say you're dealing with conflicts

00:31:42,410 --> 00:31:50,270
I do a get merge of four 935 it gives me

00:31:47,480 --> 00:31:53,210
ba ba ba bump and says oh crap I do a

00:31:50,270 --> 00:31:58,190
git diff and I see all this for those

00:31:53,210 --> 00:32:01,610
with bad eyes little zoom in and you see

00:31:58,190 --> 00:32:03,920
that oh there's this head which is

00:32:01,610 --> 00:32:07,040
remember the head is the RT branch so

00:32:03,920 --> 00:32:10,910
head I have this sick you free current

00:32:07,040 --> 00:32:13,100
first below that is reschedule ba bla

00:32:10,910 --> 00:32:14,570
and this is kind of a trivial one I said

00:32:13,100 --> 00:32:16,610
this is a easy one I actually could tell

00:32:14,570 --> 00:32:18,770
right from here how easy it is because I

00:32:16,610 --> 00:32:21,140
could see that I changed it looks like I

00:32:18,770 --> 00:32:23,870
probably changed the Sig Q free from

00:32:21,140 --> 00:32:25,700
into the main line and below down below

00:32:23,870 --> 00:32:29,390
you'll see this disappearing worn on

00:32:25,700 --> 00:32:31,340
once test something here so the way I

00:32:29,390 --> 00:32:33,080
the way I handle this I'm not sure if

00:32:31,340 --> 00:32:38,180
Julia does this but the first thing I do

00:32:33,080 --> 00:32:40,940
is I do okay you get diff for 934 the

00:32:38,180 --> 00:32:43,250
Manila colonel with my colonel that I

00:32:40,940 --> 00:32:46,370
was started at before I got the conflict

00:32:43,250 --> 00:32:48,020
I want to see what did I change what was

00:32:46,370 --> 00:32:51,050
exactly the change that the real-time

00:32:48,020 --> 00:32:53,960
kernel performed and sure enough looking

00:32:51,050 --> 00:32:57,050
at this yes it renamed the Sig Q free to

00:32:53,960 --> 00:32:58,970
the Sig Q free current first so we

00:32:57,050 --> 00:33:01,190
there's a reason we did that okay

00:32:58,970 --> 00:33:05,720
simple down below there was a worn on

00:33:01,190 --> 00:33:08,320
once and okay it was we added one so

00:33:05,720 --> 00:33:13,100
then I go and say okay let's see what

00:33:08,320 --> 00:33:16,430
happened with three four 935 so I diff

00:33:13,100 --> 00:33:19,310
the exact same source so I know for 934

00:33:16,430 --> 00:33:22,580
to see what four 935 did and let's look

00:33:19,310 --> 00:33:23,570
at what it did okay yeah there's some

00:33:22,580 --> 00:33:28,610
stuff in the top and

00:33:23,570 --> 00:33:31,670
okay I added in this little rescale not

00:33:28,610 --> 00:33:34,460
too hard down below it added a little

00:33:31,670 --> 00:33:35,900
red sky timer equals false okay so

00:33:34,460 --> 00:33:38,390
there's a little conflict there it's

00:33:35,900 --> 00:33:40,670
pretty easy so you know finally this is

00:33:38,390 --> 00:33:42,650
the final result yeah I do the rename

00:33:40,670 --> 00:33:46,640
add this do some changes

00:33:42,650 --> 00:33:49,220
easy conflict resolution a little more

00:33:46,640 --> 00:33:52,910
non-trivial and this actually goes back

00:33:49,220 --> 00:33:55,030
to the bug I think happened before so I

00:33:52,910 --> 00:33:59,660
did this you know you go up to for 961

00:33:55,030 --> 00:34:04,190
get diff I see wake up all locked wake

00:33:59,660 --> 00:34:06,800
up all okay it moved so I do the same

00:34:04,190 --> 00:34:08,900
thing diff the RT code against the

00:34:06,800 --> 00:34:11,060
stable release that it was a get based

00:34:08,900 --> 00:34:12,920
against okay I renamed wake up all

00:34:11,060 --> 00:34:15,560
locked or wake up all to wake up all

00:34:12,920 --> 00:34:18,140
locked good then I go and look at what

00:34:15,560 --> 00:34:20,300
the upstream kernel did compared to the

00:34:18,140 --> 00:34:25,330
same baseline and it moved away cabal

00:34:20,300 --> 00:34:29,990
outside the raw clock so obvious answer

00:34:25,330 --> 00:34:32,590
right well you know it's the obvious

00:34:29,990 --> 00:34:37,880
answer so you know what's wrong

00:34:32,590 --> 00:34:42,860
why come on it's a pretty easy one okay

00:34:37,880 --> 00:34:46,880
now exactly Hugh German friends left no

00:34:42,860 --> 00:34:49,100
the yes it's no longer walk wake up all

00:34:46,880 --> 00:34:52,940
locked is in main it's also a main line

00:34:49,100 --> 00:34:56,120
but it's also nice an RT and because

00:34:52,940 --> 00:34:58,700
it's okay it's a wake up cue the wake up

00:34:56,120 --> 00:35:01,400
cue has its own walk it's a sleeping

00:34:58,700 --> 00:35:03,890
lock main line uses this for

00:35:01,400 --> 00:35:06,200
optimization goes if you could say hey I

00:35:03,890 --> 00:35:09,530
have a lock that protects a work queue

00:35:06,200 --> 00:35:13,310
why do I go and use the work you lock as

00:35:09,530 --> 00:35:16,040
well well here's the thing if you go

00:35:13,310 --> 00:35:18,680
back and look at what it did you notice

00:35:16,040 --> 00:35:21,020
that there's a Ross pin lock there now a

00:35:18,680 --> 00:35:23,960
Ross pin lock does not get converted

00:35:21,020 --> 00:35:26,600
into a mutex it stays a spin lock just

00:35:23,960 --> 00:35:28,970
like it is in mainline it disables

00:35:26,600 --> 00:35:32,480
preemption it's a spinner

00:35:28,970 --> 00:35:35,420
it doesn't sleep well wake up ball has a

00:35:32,480 --> 00:35:37,400
cue or wake up has a wake up ball has a

00:35:35,420 --> 00:35:39,020
queue lock that's a spin lock

00:35:37,400 --> 00:35:41,570
well will we snow about spin locks he

00:35:39,020 --> 00:35:43,910
turned into mutexes grabby a raw lock

00:35:41,570 --> 00:35:47,150
and then a mutex and then a really say

00:35:43,910 --> 00:35:50,540
raw black is bad bad in mainline bad in

00:35:47,150 --> 00:35:52,340
RT so we had to convert it to wake up

00:35:50,540 --> 00:35:54,920
all lock because what wake up all locked

00:35:52,340 --> 00:35:59,060
is telling the kernel hey I had this

00:35:54,920 --> 00:36:01,280
work I had the skew wake you that I have

00:35:59,060 --> 00:36:05,000
my own protection don't waste the energy

00:36:01,280 --> 00:36:07,910
of grabbing another lock to do it so we

00:36:05,000 --> 00:36:10,910
prevent the lock but you're right so the

00:36:07,910 --> 00:36:13,760
correct oh yeah here's where I talked

00:36:10,910 --> 00:36:15,680
about the spin locks so of all if I did

00:36:13,760 --> 00:36:17,510
was just move it out it would be wrong

00:36:15,680 --> 00:36:19,760
because the locked and is now pretty not

00:36:17,510 --> 00:36:21,950
protected at all so when I just move it

00:36:19,760 --> 00:36:24,140
I actually keep the exact same change

00:36:21,950 --> 00:36:26,300
that the upstream did just move it out

00:36:24,140 --> 00:36:27,620
so this actually this actually removes

00:36:26,300 --> 00:36:29,900
one of the patches from the real-time

00:36:27,620 --> 00:36:34,870
kernel by adding this in the real-time

00:36:29,900 --> 00:36:38,450
kernel doesn't need to modify it so

00:36:34,870 --> 00:36:41,530
delia with no conflicts like I said

00:36:38,450 --> 00:36:43,550
sometimes things are very subtle and

00:36:41,530 --> 00:36:45,380
this is actually a little bit of a

00:36:43,550 --> 00:36:47,690
misnomer because my slide shows a

00:36:45,380 --> 00:36:49,880
conflict and thank God there was a

00:36:47,690 --> 00:36:51,740
conflict on this idea because if there

00:36:49,880 --> 00:36:54,080
wasn't a conflict if the original code

00:36:51,740 --> 00:36:57,800
went in first before another code went

00:36:54,080 --> 00:37:01,070
in we would never saw the breakage and

00:36:57,800 --> 00:37:03,560
it would have just merged completely

00:37:01,070 --> 00:37:07,550
nicely and we would never know an issue

00:37:03,560 --> 00:37:10,490
happened and luckily the code that got

00:37:07,550 --> 00:37:12,560
brought back had a pre code brought back

00:37:10,490 --> 00:37:15,080
that the real-time patch the reason why

00:37:12,560 --> 00:37:17,780
I bring this one up is on 49 this was

00:37:15,080 --> 00:37:19,490
fine on 4:18 we back ported this patch

00:37:17,780 --> 00:37:24,380
and they didn't do the update because

00:37:19,490 --> 00:37:27,200
there was no conflict the conflict here

00:37:24,380 --> 00:37:31,850
is this so if I go through and did a get

00:37:27,200 --> 00:37:35,450
diff for 965 to 66 I see what it did it

00:37:31,850 --> 00:37:38,270
moved this little block of half RT push

00:37:35,450 --> 00:37:42,590
IP I and I wrote the code for this so I

00:37:38,270 --> 00:37:45,170
knew exactly when I knew the problem was

00:37:42,590 --> 00:37:48,500
going to be there so it moved it down

00:37:45,170 --> 00:37:50,619
here if I look at what did the real-time

00:37:48,500 --> 00:37:53,499
kernel do it added

00:37:50,619 --> 00:37:55,869
that one line that one line is very

00:37:53,499 --> 00:38:00,880
important because in the real-time

00:37:55,869 --> 00:38:02,740
kernel the spin the irq work it doesn't

00:38:00,880 --> 00:38:05,230
actually happen in irq well it does

00:38:02,740 --> 00:38:08,499
because irq handlers are now threaded so

00:38:05,230 --> 00:38:11,319
hierarchical works are now threaded well

00:38:08,499 --> 00:38:16,210
the scheduler has its own eirick you

00:38:11,319 --> 00:38:19,319
work that would be kind of destroying

00:38:16,210 --> 00:38:22,779
the point of mate using the irq work if

00:38:19,319 --> 00:38:26,529
it required scheduling so this is a way

00:38:22,779 --> 00:38:29,920
that does the real-time tasks push and

00:38:26,529 --> 00:38:32,950
pull logic uses irq work in the kernel

00:38:29,920 --> 00:38:35,529
so if the scheduler so if the scheduler

00:38:32,950 --> 00:38:37,539
calls a irq work that gets scheduled out

00:38:35,529 --> 00:38:39,519
the real-time tasks aren't going to

00:38:37,539 --> 00:38:41,829
merge in until that irq work which is

00:38:39,519 --> 00:38:43,599
not a real-time tasks get scheduled into

00:38:41,829 --> 00:38:46,809
say oh this real-time tasks can be moved

00:38:43,599 --> 00:38:47,920
over here kind of kills everything but

00:38:46,809 --> 00:38:49,690
no one would know that unless you

00:38:47,920 --> 00:38:51,130
actually knew the code so sometimes you

00:38:49,690 --> 00:38:53,140
got to actually look at some of the code

00:38:51,130 --> 00:38:55,089
or look at mainline upstream say okay

00:38:53,140 --> 00:38:56,650
what did they do make sure it works

00:38:55,089 --> 00:38:58,450
backwards so this like said this is one

00:38:56,650 --> 00:39:01,720
of the hard things that are very you

00:38:58,450 --> 00:39:04,319
have to be very careful about and this

00:39:01,720 --> 00:39:08,339
is where I kind of explained what it is

00:39:04,319 --> 00:39:10,509
so next is backporting party patches

00:39:08,339 --> 00:39:11,829
stable is the easy part like I said

00:39:10,509 --> 00:39:13,720
that's a lot especially if there's no

00:39:11,829 --> 00:39:15,160
conflicts it really is mundane you just

00:39:13,720 --> 00:39:17,410
go through run through a bunch of tests

00:39:15,160 --> 00:39:22,480
you get a lot of Facebook reading in at

00:39:17,410 --> 00:39:24,730
the time or Google+ for somebody so

00:39:22,480 --> 00:39:26,349
whenever new arty patch or document

00:39:24,730 --> 00:39:31,450
coming or when new development comes out

00:39:26,349 --> 00:39:33,400
the we look for stable arty tags if a

00:39:31,450 --> 00:39:35,170
stable arty tag is in there Sebastian

00:39:33,400 --> 00:39:36,880
will say when Sebastian's writing code

00:39:35,170 --> 00:39:37,869
and he doesn't commit there's certain

00:39:36,880 --> 00:39:40,359
things I he says okay

00:39:37,869 --> 00:39:42,549
this is broken in past kernel releases

00:39:40,359 --> 00:39:45,249
he'll put just like in mainline when you

00:39:42,549 --> 00:39:45,730
see see stable a bigger dat kernel

00:39:45,249 --> 00:39:47,710
that'll work

00:39:45,730 --> 00:39:50,799
the real-time code has the same idea of

00:39:47,710 --> 00:39:52,119
doing stable RT at bigger Corrigan we

00:39:50,799 --> 00:39:54,150
will scans with these and any of these

00:39:52,119 --> 00:39:57,900
we will pull in and that's very uh

00:39:54,150 --> 00:40:00,009
that's useful but I also found out that

00:39:57,900 --> 00:40:01,599
he there's a lot of patches that should

00:40:00,009 --> 00:40:03,279
go beep backported that you know

00:40:01,599 --> 00:40:04,359
Sebastian doesn't really think is

00:40:03,279 --> 00:40:05,769
important but

00:40:04,359 --> 00:40:08,380
when I look at it and I know come I am I

00:40:05,769 --> 00:40:10,150
use use cases I'm like no I think that

00:40:08,380 --> 00:40:11,799
is important so a lot of times a lot of

00:40:10,150 --> 00:40:13,660
changes in upstream and the backboard

00:40:11,799 --> 00:40:14,890
patches we back pour almost a lot a lot

00:40:13,660 --> 00:40:16,869
of patches and some things we just don't

00:40:14,890 --> 00:40:18,180
back for it matters how much of a change

00:40:16,869 --> 00:40:20,680
in it is a big impact

00:40:18,180 --> 00:40:22,269
do we not we may not back port it

00:40:20,680 --> 00:40:23,739
sometimes we add new features to the

00:40:22,269 --> 00:40:24,849
real-time patch not so much anymore

00:40:23,739 --> 00:40:26,710
because we're getting ready to push it

00:40:24,849 --> 00:40:27,849
to mainline but the lot of times we add

00:40:26,710 --> 00:40:32,410
new features to the real-time patch

00:40:27,849 --> 00:40:34,989
those never get back ported so how do we

00:40:32,410 --> 00:40:36,700
synchronize among all our ports so we

00:40:34,989 --> 00:40:38,529
right now I said we have four nine four

00:40:36,700 --> 00:40:41,650
four four one and three eighteen that

00:40:38,529 --> 00:40:43,930
are right now dealing with back ports so

00:40:41,650 --> 00:40:48,880
we're working on using Google Docs so we

00:40:43,930 --> 00:40:51,099
write down all the any one of us of the

00:40:48,880 --> 00:40:54,849
stable meteors can add to this saying

00:40:51,099 --> 00:40:56,829
hey here's the commit name here's the

00:40:54,849 --> 00:40:58,869
upstream commit ID that's in Sebastian's

00:40:56,829 --> 00:41:02,559
tree that has okay and then I'm going to

00:40:58,869 --> 00:41:04,359
say I applied it and I'm going to and

00:41:02,559 --> 00:41:06,430
then other people we could all go and

00:41:04,359 --> 00:41:08,259
look at this and say hey so-and-so

00:41:06,430 --> 00:41:08,890
pulled this patch in maybe I should look

00:41:08,259 --> 00:41:10,749
at it too

00:41:08,890 --> 00:41:12,400
and then if it's not applicable because

00:41:10,749 --> 00:41:14,380
sometimes the only effects like some

00:41:12,400 --> 00:41:16,450
like the one I said you see the n/a is

00:41:14,380 --> 00:41:17,980
there that was one of the patches was

00:41:16,450 --> 00:41:19,930
only applicable for four four didn't

00:41:17,980 --> 00:41:21,999
effect for one or beyond so the other

00:41:19,930 --> 00:41:23,829
two doesn't matter so this is a way we

00:41:21,999 --> 00:41:33,989
synchronize among us our selves to use

00:41:23,829 --> 00:41:35,950
this still have updated for one yeah

00:41:33,989 --> 00:41:38,019
what's wrong with it it doesn't it seems

00:41:35,950 --> 00:41:39,670
to work and it's not many it's not

00:41:38,019 --> 00:41:40,960
really cuz I like this shows you that

00:41:39,670 --> 00:41:42,460
there's really that much more work going

00:41:40,960 --> 00:41:44,079
on with the upstream kernel we're right

00:41:42,460 --> 00:41:46,299
now working about getting it ready to go

00:41:44,079 --> 00:41:47,799
into mainline so right now the focus is

00:41:46,299 --> 00:41:50,410
that so we were actually having less and

00:41:47,799 --> 00:41:56,619
less issues with mainline kernel so it's

00:41:50,410 --> 00:41:58,599
getting really close so what do we do to

00:41:56,619 --> 00:42:02,739
back port it usually what I do is I

00:41:58,599 --> 00:42:05,230
always save a branch from what was the

00:42:02,739 --> 00:42:08,019
last time I back ported so say for 14 or

00:42:05,230 --> 00:42:09,759
15 our teen 13 was the last time I did a

00:42:08,019 --> 00:42:13,029
back port from Sebastian's branch now

00:42:09,759 --> 00:42:14,529
he's up to 24 RT 19 now I'm like okay

00:42:13,029 --> 00:42:17,470
let me go see what he's changed and see

00:42:14,529 --> 00:42:18,250
if I want to back pour anything so what

00:42:17,470 --> 00:42:21,430
I do is I

00:42:18,250 --> 00:42:24,580
first thing I do is I I kind of to step

00:42:21,430 --> 00:42:26,080
out here is I go to my tree my my stable

00:42:24,580 --> 00:42:28,990
tree say it's for 9rt

00:42:26,080 --> 00:42:31,720
I will branch I will make a copy of it

00:42:28,990 --> 00:42:34,600
like a temp branch copy of it then I

00:42:31,720 --> 00:42:37,150
merge oh wait sorry

00:42:34,600 --> 00:42:39,100
let me go back now I don't start with my

00:42:37,150 --> 00:42:41,590
tree I'm working on for nine I actually

00:42:39,100 --> 00:42:45,430
take the tree that I last backported the

00:42:41,590 --> 00:42:47,290
for 1415 RT 13 I pulled that this is the

00:42:45,430 --> 00:42:49,990
last time I actually backported patches

00:42:47,290 --> 00:42:54,970
from Sebastian I make that into a temp

00:42:49,990 --> 00:42:58,870
tree then I merged for 14 24 into that

00:42:54,970 --> 00:43:00,430
tree so because that matches the stable

00:42:58,870 --> 00:43:02,290
release that he based his stuff on

00:43:00,430 --> 00:43:04,210
because I don't care about anything that

00:43:02,290 --> 00:43:07,480
he pulled from stable I only care about

00:43:04,210 --> 00:43:10,260
what he changed so to have a proper

00:43:07,480 --> 00:43:13,210
comparison I need to start make my tree

00:43:10,260 --> 00:43:15,520
equivalent to his stable to see his

00:43:13,210 --> 00:43:19,030
differences so what I do is I go and I

00:43:15,520 --> 00:43:21,670
start with my 414 or T or for 1415 or

00:43:19,030 --> 00:43:24,790
teen 13 make into pull into a branch

00:43:21,670 --> 00:43:27,130
pull in for 14 24 it has a bunch of

00:43:24,790 --> 00:43:28,810
conflicts you know what I don't care I

00:43:27,130 --> 00:43:30,340
save them all as is where I go in and

00:43:28,810 --> 00:43:33,700
delete them I don't care about the

00:43:30,340 --> 00:43:34,870
result I only care about commits as long

00:43:33,700 --> 00:43:36,580
as it goes up there I just want to know

00:43:34,870 --> 00:43:37,690
what's the difference that he has so I

00:43:36,580 --> 00:43:38,380
don't have to actually even spend any

00:43:37,690 --> 00:43:40,750
brainpower

00:43:38,380 --> 00:43:44,740
fixing the commits Louis they're they

00:43:40,750 --> 00:43:49,930
they're irrelevant and then how many

00:43:44,740 --> 00:43:51,250
people here know about get cherry okay

00:43:49,930 --> 00:43:55,600
how many people the rest of people don't

00:43:51,250 --> 00:43:58,240
know about get cherry okay so what get

00:43:55,600 --> 00:43:59,680
cherry Daniel now knows which he's like

00:43:58,240 --> 00:44:01,060
darn it I wish I knew about that a long

00:43:59,680 --> 00:44:04,000
time ago because he actually almost

00:44:01,060 --> 00:44:05,860
rewrote get cherry get cherry i booze

00:44:04,000 --> 00:44:10,630
for a long time it's an awesome utility

00:44:05,860 --> 00:44:12,340
so here get cherry will take the branch

00:44:10,630 --> 00:44:13,990
so right now remember I said I'm at

00:44:12,340 --> 00:44:17,220
technically I'm at let me go back up

00:44:13,990 --> 00:44:17,220
staff oh geez

00:44:20,579 --> 00:44:27,089
so I'm at 4:14 well actually I'm at 4:14

00:44:23,219 --> 00:44:31,709
24 RT 13 technically because I merged 24

00:44:27,089 --> 00:44:34,410
there so I'm at 4:14 RT throat 24 RT 13

00:44:31,709 --> 00:44:38,759
I do get cherry of head this shows me

00:44:34,410 --> 00:44:41,999
all the commits that are in the RT 19

00:44:38,759 --> 00:44:45,719
that are not in RT 13 it shows me boom

00:44:41,999 --> 00:44:47,910
you'll see there's the 18 19 20 boom

00:44:45,719 --> 00:44:49,199
boom or whatever I was at so our 14 15

00:44:47,910 --> 00:44:51,900
see you'll see all the commits that's

00:44:49,199 --> 00:44:53,880
added I only care about care about his

00:44:51,900 --> 00:44:56,309
version commits I only care about what

00:44:53,880 --> 00:44:58,140
he added so I take these out and then

00:44:56,309 --> 00:45:00,660
this is what I use to build a quilt

00:44:58,140 --> 00:45:02,880
queue and I will now look at each

00:45:00,660 --> 00:45:04,559
individual patch and examine it myself

00:45:02,880 --> 00:45:07,349
so this is more of a manual work of

00:45:04,559 --> 00:45:08,609
saying if it has a stable RT on it I

00:45:07,349 --> 00:45:10,679
pull it it's going to be part of the

00:45:08,609 --> 00:45:13,079
things I pull it if it doesn't I look at

00:45:10,679 --> 00:45:15,239
it and say should I pull it sometimes

00:45:13,079 --> 00:45:19,400
yes sometimes no sometimes I try and

00:45:15,239 --> 00:45:19,400
that's it thank you

00:45:26,190 --> 00:45:29,190
questions

00:45:46,540 --> 00:45:52,630
so wait so what you're saying that if we

00:45:50,170 --> 00:45:55,360
have a conflict when we pull in yeah we

00:45:52,630 --> 00:46:03,550
tagged it well we should well I always

00:45:55,360 --> 00:46:06,730
did Julia will from now on so yes so

00:46:03,550 --> 00:46:08,380
well like I said no I do it and you

00:46:06,730 --> 00:46:10,330
might missed it I said that what I have

00:46:08,380 --> 00:46:12,490
a conflict well I usually pull pull pull

00:46:10,330 --> 00:46:13,690
pull and I tag each one but now I really

00:46:12,490 --> 00:46:15,760
don't have to tag the one that has a

00:46:13,690 --> 00:46:18,220
conflict on it so I pull one in have a

00:46:15,760 --> 00:46:20,680
conflict on it I fixed a conflict I'll

00:46:18,220 --> 00:46:24,160
build and boot the colonel run a few

00:46:20,680 --> 00:46:26,850
tests just I basically spend maybe after

00:46:24,160 --> 00:46:29,920
the things built maybe 15 minutes on it

00:46:26,850 --> 00:46:32,680
it's smoke tested and then I go on until

00:46:29,920 --> 00:46:34,150
I hit I catch up to main line cut go

00:46:32,680 --> 00:46:35,830
stable and that's why I run my full

00:46:34,150 --> 00:46:37,210
stream if I screw it up usually a lot of

00:46:35,830 --> 00:46:39,580
times if I screwed up that conflict one

00:46:37,210 --> 00:46:42,910
the full run will actually find a buck

00:46:39,580 --> 00:46:44,650
and then I go back - yeah if I hit a bug

00:46:42,910 --> 00:46:46,000
I say wait a minute I fix the bat and

00:46:44,650 --> 00:46:48,220
now I might actually revert all the way

00:46:46,000 --> 00:46:49,750
back to that first one and say did this

00:46:48,220 --> 00:46:53,280
a man run the full test suite on that

00:46:49,750 --> 00:46:53,280
first one I've only had to do that once

00:46:53,940 --> 00:46:57,090
anyway else

00:47:18,339 --> 00:47:30,529
wait right okay so wait you revert

00:47:21,049 --> 00:47:32,950
everything pull everything in I'm

00:47:30,529 --> 00:47:35,329
completely you you

00:47:32,950 --> 00:47:42,289
yeah the merge conflicts will still be

00:47:35,329 --> 00:47:46,869
there oh wait wait you get you guessed

00:47:42,289 --> 00:47:46,869
it you pull from my stable tree or folk

00:47:47,200 --> 00:48:04,130
yeah okay yeah so wait you're trying to

00:48:01,910 --> 00:48:06,289
but you'd why not revert or you can't do

00:48:04,130 --> 00:48:11,839
revert sir I mean you can't do rebase

00:48:06,289 --> 00:48:14,180
--is on your tree or something okay so

00:48:11,839 --> 00:48:16,160
basically okay oh I so so maybe let me

00:48:14,180 --> 00:48:17,869
ask you this okay so this be recording

00:48:16,160 --> 00:48:20,410
you no one knows what you're saying so

00:48:17,869 --> 00:48:22,970
it's just like me talking on the phone

00:48:20,410 --> 00:48:26,059
so anyway basically I think what you're

00:48:22,970 --> 00:48:27,619
saying is you have you use the stable

00:48:26,059 --> 00:48:29,059
tree you're pushing up to other people

00:48:27,619 --> 00:48:31,670
maybe adding your own stuff or something

00:48:29,059 --> 00:48:33,470
to it and then then your what but you

00:48:31,670 --> 00:48:35,089
but other people rely on your work so

00:48:33,470 --> 00:48:36,589
ideally what you do is you're reverting

00:48:35,089 --> 00:48:38,109
everything out and you're coming back

00:48:36,589 --> 00:48:41,150
and pull it in so once you have the

00:48:38,109 --> 00:48:43,250
conflict to get the mainline stable what

00:48:41,150 --> 00:48:45,349
happens I be tried instead of reverting

00:48:43,250 --> 00:48:46,940
trying to do a pull from the main line

00:48:45,349 --> 00:48:48,170
so the real-time stable right there

00:48:46,940 --> 00:48:49,549
because it might actually fix everything

00:48:48,170 --> 00:48:52,549
for you it should so instead of pulling

00:48:49,549 --> 00:48:54,950
back to the stable just pull from the

00:48:52,549 --> 00:48:57,440
next RT or stable and it will actually

00:48:54,950 --> 00:49:08,559
have the updates that fix that fixes the

00:48:57,440 --> 00:49:08,559
conflicts for you okay

00:49:08,760 --> 00:49:18,280
mom okay if it works for you no I mean

00:49:16,690 --> 00:49:21,609
like I said it's it's right now I can

00:49:18,280 --> 00:49:24,780
say if it works for you let's do it yeah

00:49:21,609 --> 00:49:24,780
yeah yep

00:49:25,440 --> 00:49:31,380

YouTube URL: https://www.youtube.com/watch?v=pIJ3Zv_uxn0


