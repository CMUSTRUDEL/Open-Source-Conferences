Title: An Introduction to Asymmetric Multiprocessing: When this Architecture can be a Game Changer
Publication date: 2018-03-13
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	An Introduction to Asymmetric Multiprocessing: When this Architecture can be a Game Changer and How to Survive It - Nicola La Gloria & Laura Nao, Kynetics

 Asymmetric multi-processing (AMP) systems fulfill the need for high performance and real-time by combining the responsiveness of a MCU with the processing power of an application processor which runs a full OS.

This talk will present a technical overview on asymmetric multiprocessing platforms focussing on motivations, use cases and how to handle interprocess communication between MCU and MPU in practice.

Tools and strategies on how to develop software on such platforms will be presented, as well as debugging techniques which take into account the diversity and complexity of such systems. A case of study based on AMP architecture is analyzed. Low-latency tasks such as high-rate reading/sampling can be handled more easily and efficiently by the MCU core running a RTOS while data visualization can displayed by the Master core running a full Linux operating system. 

About Nicola La Gloria
Nicola La Gloria, is a serial entrepreneur. CoÂ­founder and CEO of Kynetics, an IoT full stack development company. He works primarily on IoT architectures, embracing both embedded and backend development. Nicola led the development of the OS and app store for one of the first Android smart watches and he is co-founder of the Warpx.io community (http://www.warpx.io) which develops a reference design of a small footprint single board computer for IoT and wearable applications. Nicola has a Ph.D in Astronautics and Satellite Sciences with specialization in autonomous navigation and attitude determination of microsatellites using Kalman estimators. He is passionate about machine learning and stochastic systems. 

About Laura Nao
Laura Nao is an Embedded Engineer focussed on Asymmetric SOCs, primarily i.MX7. She combines her knowledge of MCU and RTOS development with application processor OSes like Linux and Android. At Kynetics, she is following hybrid architectures which interface high frequencies and precise IMU devices handled by real-time OSes and their data visualization on Android. She also follows the development of microcontroller code for BLE applications.
Captions: 
	00:00:00,030 --> 00:00:05,609
so this session would be like a primer

00:00:02,220 --> 00:00:07,529
for a symmetric multiprocessing is there

00:00:05,609 --> 00:00:09,420
anyone here that has already experienced

00:00:07,529 --> 00:00:14,849
on a symmetric multiprocessing or work

00:00:09,420 --> 00:00:19,230
into that field zero okay so I would be

00:00:14,849 --> 00:00:20,850
very like high level then I would be

00:00:19,230 --> 00:00:23,039
like supported by Laura that's a

00:00:20,850 --> 00:00:25,650
colleague of mine we work at kinetics we

00:00:23,039 --> 00:00:28,349
do embedded software especially in the

00:00:25,650 --> 00:00:32,300
Android space so what we do is like

00:00:28,349 --> 00:00:35,010
heavily customized OS space or Android

00:00:32,300 --> 00:00:40,920
this is like our experience that we

00:00:35,010 --> 00:00:45,629
built on top of the azamati

00:00:40,920 --> 00:00:47,879
multi-processing and let me start how we

00:00:45,629 --> 00:00:51,570
got like involved with a symmetric

00:00:47,879 --> 00:00:53,870
multiprocessing I guess I'm glad that

00:00:51,570 --> 00:00:58,890
you came because I'm talking about this

00:00:53,870 --> 00:01:01,829
so we have been involved into an open

00:00:58,890 --> 00:01:03,949
source project called the work the work

00:01:01,829 --> 00:01:08,760
was like a wearable reference platform

00:01:03,949 --> 00:01:11,909
based on imx6 and because he was

00:01:08,760 --> 00:01:14,430
addressing the wearable market uh you

00:01:11,909 --> 00:01:18,960
know we were like talking about hey how

00:01:14,430 --> 00:01:21,330
can we make wearables to do things like

00:01:18,960 --> 00:01:23,100
in order to save battery time because

00:01:21,330 --> 00:01:26,009
you know if you are having a full

00:01:23,100 --> 00:01:28,860
operating system on your watch and

00:01:26,009 --> 00:01:31,500
because you want display graphic power

00:01:28,860 --> 00:01:35,790
consumption is really heavily a driver

00:01:31,500 --> 00:01:37,500
for your life cycle while we thought was

00:01:35,790 --> 00:01:39,119
interesting and yet you have the

00:01:37,500 --> 00:01:40,500
colleagues of revolution robotics that

00:01:39,119 --> 00:01:43,829
they develop the hardware for this

00:01:40,500 --> 00:01:45,990
community board we actually thought

00:01:43,829 --> 00:01:48,270
about an ivory architecture I mean

00:01:45,990 --> 00:01:51,119
architecture is really simple we have

00:01:48,270 --> 00:01:55,110
like one board that has a microprocessor

00:01:51,119 --> 00:01:57,030
on it and we have an interface that is

00:01:55,110 --> 00:01:58,740
like based on you art that goes into a

00:01:57,030 --> 00:02:01,320
dollar board that is featuring a

00:01:58,740 --> 00:02:02,460
microcontroller a breed architectures

00:02:01,320 --> 00:02:05,280
means that we are two different

00:02:02,460 --> 00:02:07,469
operating system working on like or bare

00:02:05,280 --> 00:02:11,790
metal code on a microcontroller we use

00:02:07,469 --> 00:02:14,120
actually a K 16 from an XP

00:02:11,790 --> 00:02:17,730
and a full operating system on the

00:02:14,120 --> 00:02:20,010
embedded board featuring the imx6 we use

00:02:17,730 --> 00:02:24,349
the solar light actually the board the

00:02:20,010 --> 00:02:29,909
picture is there is very tiny board and

00:02:24,349 --> 00:02:34,829
the idea was to run like MCU driven

00:02:29,909 --> 00:02:37,170
tasks on the dollar board like a

00:02:34,829 --> 00:02:38,849
pedometer right you have a pedometer on

00:02:37,170 --> 00:02:41,639
the daughter board you're on a gator

00:02:38,849 --> 00:02:43,680
they don't only from the daughter or and

00:02:41,639 --> 00:02:45,689
then eventually send those data to the

00:02:43,680 --> 00:02:50,400
application processor for displaying if

00:02:45,689 --> 00:02:53,609
you have an app this was like an old

00:02:50,400 --> 00:02:55,650
slide a very high level slide to how we

00:02:53,609 --> 00:02:59,280
handle software in an architecture like

00:02:55,650 --> 00:03:02,040
that basically we invented something

00:02:59,280 --> 00:03:04,620
from scratch right and it was like

00:03:02,040 --> 00:03:07,379
pretty effective but not really

00:03:04,620 --> 00:03:09,450
optimized so this is actually based on a

00:03:07,379 --> 00:03:11,220
high-level language like Java so we

00:03:09,450 --> 00:03:13,590
thought about okay let's say that we

00:03:11,220 --> 00:03:15,989
have something written in Java and we

00:03:13,590 --> 00:03:18,959
want to get our data from the pedometer

00:03:15,989 --> 00:03:21,810
how can we handle that case so basically

00:03:18,959 --> 00:03:23,310
we have sensor attached to the MCU let's

00:03:21,810 --> 00:03:26,250
say like a pedometer

00:03:23,310 --> 00:03:28,889
and then we have a code that like

00:03:26,250 --> 00:03:33,359
handling messages through a JSON for

00:03:28,889 --> 00:03:36,540
example streaming so you serialize all

00:03:33,359 --> 00:03:39,299
the information to to JSON messages and

00:03:36,540 --> 00:03:41,459
you send over you are and the you are is

00:03:39,299 --> 00:03:44,069
connected to the SOC and then you have

00:03:41,459 --> 00:03:47,340
the your JVM and your I don't know like

00:03:44,069 --> 00:03:48,479
whatever library right basically because

00:03:47,340 --> 00:03:50,190
you are dealing with you are you

00:03:48,479 --> 00:03:53,400
probably need another library these are

00:03:50,190 --> 00:03:56,819
XTX on top of it in order for Java to

00:03:53,400 --> 00:03:59,549
handle they are coming from the UART as

00:03:56,819 --> 00:04:02,310
you can see this is a you know like a

00:03:59,549 --> 00:04:04,590
very interesting solution but when the

00:04:02,310 --> 00:04:08,150
imx7 so when we have these little

00:04:04,590 --> 00:04:12,199
packages that are carrying both

00:04:08,150 --> 00:04:15,569
microprocessor and microcontroller on it

00:04:12,199 --> 00:04:17,130
the use cases were like pretty extended

00:04:15,569 --> 00:04:19,470
or there is we were not talking anymore

00:04:17,130 --> 00:04:21,660
like battery savings like how can we

00:04:19,470 --> 00:04:25,290
build a wearable device which

00:04:21,660 --> 00:04:31,230
can have a more like longevity in terms

00:04:25,290 --> 00:04:33,240
of life span but also can we run softer

00:04:31,230 --> 00:04:36,120
in two different area completely

00:04:33,240 --> 00:04:39,660
segregated so we have an MCU domain when

00:04:36,120 --> 00:04:43,290
we run our toes or bare metal code and

00:04:39,660 --> 00:04:48,690
then on the CPU we are running a fool OS

00:04:43,290 --> 00:04:52,740
can be Linux or Android so you probably

00:04:48,690 --> 00:04:55,440
are very familiar with the SMP so SMP is

00:04:52,740 --> 00:04:58,920
a way for a single OS to deal with

00:04:55,440 --> 00:05:02,340
multi-core so because every single core

00:04:58,920 --> 00:05:05,430
as a limitation in terms of speed right

00:05:02,340 --> 00:05:08,490
the only way you can optimize the time

00:05:05,430 --> 00:05:10,920
and the performance is is about

00:05:08,490 --> 00:05:12,750
splitting things so your operating

00:05:10,920 --> 00:05:16,410
system is taking care about splitting

00:05:12,750 --> 00:05:20,160
all the tasks on task but splitting

00:05:16,410 --> 00:05:22,590
threads and in such over multi-core

00:05:20,160 --> 00:05:23,880
right and then you have apps on top of

00:05:22,590 --> 00:05:26,310
the head that doesn't know anything

00:05:23,880 --> 00:05:27,990
about this but you gain in performance

00:05:26,310 --> 00:05:32,690
is because you are splitting everything

00:05:27,990 --> 00:05:32,690
along your multi-core platform a

00:05:32,900 --> 00:05:38,820
different things happens if you have

00:05:35,280 --> 00:05:40,800
like a symmetrical architecture so

00:05:38,820 --> 00:05:44,100
symmetrical means that you have

00:05:40,800 --> 00:05:52,020
different OSS that runs on different

00:05:44,100 --> 00:05:54,660
cores something new because if you're

00:05:52,020 --> 00:05:57,480
familiar with framework like Mentor

00:05:54,660 --> 00:05:59,640
Graphics framework or Greenhill did they

00:05:57,480 --> 00:06:02,640
do those things like every in the

00:05:59,640 --> 00:06:06,150
automotive on the aerospace or you know

00:06:02,640 --> 00:06:09,090
fie control systems so what happens if I

00:06:06,150 --> 00:06:12,030
have a deterministic software that has

00:06:09,090 --> 00:06:14,010
to run on a microcontroller and then I

00:06:12,030 --> 00:06:16,290
have a completely different domain where

00:06:14,010 --> 00:06:19,350
I would say display something on the

00:06:16,290 --> 00:06:21,720
screen and I don't want the T domain to

00:06:19,350 --> 00:06:24,560
be connected in order for example if I

00:06:21,720 --> 00:06:27,720
have a kernel panic I don't actually

00:06:24,560 --> 00:06:32,150
panic what is that what is going on on

00:06:27,720 --> 00:06:34,979
the are toss or in the bare metal code

00:06:32,150 --> 00:06:38,219
basically how to deal with our symmetric

00:06:34,979 --> 00:06:40,710
processing is done through a special

00:06:38,219 --> 00:06:42,180
layer of API so right now you have two

00:06:40,710 --> 00:06:44,639
different operating system and these two

00:06:42,180 --> 00:06:46,919
operating systems or you know like our

00:06:44,639 --> 00:06:48,509
toss because you may have like two

00:06:46,919 --> 00:06:51,449
different full OS running on different

00:06:48,509 --> 00:06:54,479
core or you may have like if you have

00:06:51,449 --> 00:06:56,789
like a like a CPU write like a

00:06:54,479 --> 00:06:58,830
multi-core CPU or if you have in the

00:06:56,789 --> 00:07:01,289
same package a microcontroller you can

00:06:58,830 --> 00:07:03,810
run our toss or bare metal code but how

00:07:01,289 --> 00:07:06,240
these two worlds actually communicate

00:07:03,810 --> 00:07:09,539
together so we are here just to talk

00:07:06,240 --> 00:07:12,689
about exactly how to handle this

00:07:09,539 --> 00:07:16,830
communication that is driven by API

00:07:12,689 --> 00:07:19,499
basically so there is like a layer that

00:07:16,830 --> 00:07:26,189
does what is called the inter processor

00:07:19,499 --> 00:07:28,770
communication the sweet things is like

00:07:26,189 --> 00:07:31,339
it is a very segregated environment so

00:07:28,770 --> 00:07:34,099
you can really take advantage of having

00:07:31,339 --> 00:07:37,259
system that they don't know anything

00:07:34,099 --> 00:07:41,509
about each other other than what you

00:07:37,259 --> 00:07:41,509
want to communicate between each other

00:07:42,139 --> 00:07:54,830
so always you may have different choices

00:07:48,499 --> 00:07:58,069
one of the very basic difference between

00:07:54,830 --> 00:08:01,110
very mission critical system and like

00:07:58,069 --> 00:08:02,759
even if you are working with segregated

00:08:01,110 --> 00:08:05,959
environment not mission critical

00:08:02,759 --> 00:08:08,909
environments is the use of a hypervisor

00:08:05,959 --> 00:08:12,060
again if you go back to products like

00:08:08,909 --> 00:08:14,249
mental graphics they use a hypervisor to

00:08:12,060 --> 00:08:17,399
manage oximetry multi processing that

00:08:14,249 --> 00:08:19,319
means that the two CPU they don't

00:08:17,399 --> 00:08:22,199
communicate each other directly they go

00:08:19,319 --> 00:08:24,990
through an hypervisor that means that if

00:08:22,199 --> 00:08:28,020
something goes bad is the I per visor

00:08:24,990 --> 00:08:30,469
that takes care about a kernel panic so

00:08:28,020 --> 00:08:34,800
I wanted to reboot eventually a guest

00:08:30,469 --> 00:08:36,899
operating system and the two CPU are

00:08:34,800 --> 00:08:38,130
completely disconnected each other that

00:08:36,899 --> 00:08:40,529
you know so they don't ever like a

00:08:38,130 --> 00:08:42,149
connection that is a direct connection

00:08:40,529 --> 00:08:44,720
between them they are not sharing any

00:08:42,149 --> 00:08:47,130
interim basically

00:08:44,720 --> 00:08:51,240
so you have strong isolation in that

00:08:47,130 --> 00:08:54,570
case actually a very secure and robust

00:08:51,240 --> 00:08:57,930
system but you added like a layer of

00:08:54,570 --> 00:09:00,060
software I per visor in the embedded

00:08:57,930 --> 00:09:02,370
world and probably these people that

00:09:00,060 --> 00:09:05,660
knows more than me in that domain they

00:09:02,370 --> 00:09:09,680
can be divided in different areas

00:09:05,660 --> 00:09:12,300
heavily in the in the embedded world

00:09:09,680 --> 00:09:13,700
monolithic hypervisor so monolithic

00:09:12,300 --> 00:09:19,050
digitalization is heavily used

00:09:13,700 --> 00:09:20,580
monolithic visualization is what so the

00:09:19,050 --> 00:09:23,670
hypervisor is taking care of drivers

00:09:20,580 --> 00:09:26,610
basically when we install VMware in our

00:09:23,670 --> 00:09:29,040
Mac we don't have we don't need special

00:09:26,610 --> 00:09:31,470
drivers we use the the guest OS drivers

00:09:29,040 --> 00:09:34,280
basically to to handle all the

00:09:31,470 --> 00:09:37,590
input-output operation in the guest OS

00:09:34,280 --> 00:09:40,800
but you know like like sin that's like

00:09:37,590 --> 00:09:43,410
this but in the embedded side if you

00:09:40,800 --> 00:09:46,110
want a more I would say more

00:09:43,410 --> 00:09:49,140
performances you may want to have like a

00:09:46,110 --> 00:09:51,240
monolithic type of visualization that

00:09:49,140 --> 00:09:54,450
means that yes you have to drive your

00:09:51,240 --> 00:09:57,930
own driver for the hypervisor but

00:09:54,450 --> 00:10:00,750
luckily we were taking a look to some

00:09:57,930 --> 00:10:04,080
technology in that space they share the

00:10:00,750 --> 00:10:06,480
same Linux header for the driver so it's

00:10:04,080 --> 00:10:08,250
not so difficult to recompile if you

00:10:06,480 --> 00:10:12,000
have to recompile a driver that you want

00:10:08,250 --> 00:10:14,760
to share with your guest OS on the other

00:10:12,000 --> 00:10:16,440
side we have not supervised solutions so

00:10:14,760 --> 00:10:18,960
this is what we will see today so you

00:10:16,440 --> 00:10:21,960
can have you know you can basically have

00:10:18,960 --> 00:10:23,970
like a quite reliable system not such

00:10:21,960 --> 00:10:27,450
the the first one but you know quite

00:10:23,970 --> 00:10:29,580
quite good anyway so with not supervised

00:10:27,450 --> 00:10:31,320
so not supervised or no visualization

00:10:29,580 --> 00:10:33,180
and you have the CPU that are actually

00:10:31,320 --> 00:10:34,770
sharing interrupts with each other when

00:10:33,180 --> 00:10:40,140
something happens and you want to share

00:10:34,770 --> 00:10:45,260
messages between the two and we will see

00:10:40,140 --> 00:10:45,260
demo and examples in the specific case

00:10:46,190 --> 00:10:51,780
what is very important about what we

00:10:49,500 --> 00:10:54,990
would be seeing especially when Laura

00:10:51,780 --> 00:10:56,940
will be talking about details about we

00:10:54,990 --> 00:10:57,740
we will develop and what we discover

00:10:56,940 --> 00:11:00,690
lately

00:10:57,740 --> 00:11:03,840
is okay how these inter-process

00:11:00,690 --> 00:11:06,420
communication actually works basically

00:11:03,840 --> 00:11:09,300
if you think about like an easier Aussie

00:11:06,420 --> 00:11:12,090
layer type of thing so when we have like

00:11:09,300 --> 00:11:13,680
a physical layer right like the TCP or

00:11:12,090 --> 00:11:15,660
sorry like the when we talk about

00:11:13,680 --> 00:11:18,150
networking right so we have like a

00:11:15,660 --> 00:11:22,410
physical layer that in this case is

00:11:18,150 --> 00:11:25,320
shared memory and then you have like a

00:11:22,410 --> 00:11:28,230
media access control layer that is the

00:11:25,320 --> 00:11:32,040
layer number two so the link layer that

00:11:28,230 --> 00:11:35,370
in this case is done by views io v io

00:11:32,040 --> 00:11:39,180
you probably is who is familiar with k

00:11:35,370 --> 00:11:44,330
vm so with the para virtualization or k

00:11:39,180 --> 00:11:48,600
vm v t io is what takes care about

00:11:44,330 --> 00:11:51,990
taking memory buffers and put in a queue

00:11:48,600 --> 00:11:56,250
that is like a rig a ring buffer right

00:11:51,990 --> 00:11:59,220
and the other core take those memory

00:11:56,250 --> 00:12:03,780
buffers from the queue and process it

00:11:59,220 --> 00:12:07,250
and send an interrupt when is done and

00:12:03,780 --> 00:12:12,210
then we have finally the transport layer

00:12:07,250 --> 00:12:14,250
where the primary driver or device you

00:12:12,210 --> 00:12:15,780
know like there is a driver and

00:12:14,250 --> 00:12:18,240
otherwise it's called RP message is a

00:12:15,780 --> 00:12:19,920
framework so basically open am I don't

00:12:18,240 --> 00:12:23,430
know if you guys are familiar we open am

00:12:19,920 --> 00:12:26,030
open amp is providing frameworks for

00:12:23,430 --> 00:12:29,840
lifecycle and message management between

00:12:26,030 --> 00:12:33,990
different cores in in a symmetrical

00:12:29,840 --> 00:12:37,020
architecture every message is built on

00:12:33,990 --> 00:12:40,740
top of your t io actually is an API so

00:12:37,020 --> 00:12:45,530
you have really API API driven in C and

00:12:40,740 --> 00:12:49,050
is provided both for the artists and

00:12:45,530 --> 00:12:52,970
actually the Linux kernel already at VRT

00:12:49,050 --> 00:12:56,130
io & RP message on mainstream kernel but

00:12:52,970 --> 00:13:00,540
open and add the same features to bare

00:12:56,130 --> 00:13:02,220
metal and a real-time operating system

00:13:00,540 --> 00:13:07,800
there was not a variable before so they

00:13:02,220 --> 00:13:10,950
did like a lady like a great job so I

00:13:07,800 --> 00:13:14,970
guess that now we get into this

00:13:10,950 --> 00:13:18,750
things we have done with the imx7 and I

00:13:14,970 --> 00:13:21,180
caldera that we did like recently a lot

00:13:18,750 --> 00:13:25,170
of work on the topic and she will be

00:13:21,180 --> 00:13:27,990
presenting the type of words we have

00:13:25,170 --> 00:13:30,570
working on which framework we used which

00:13:27,990 --> 00:13:32,910
tool we use for debugging and finally

00:13:30,570 --> 00:13:34,050
the demo that we did to show you how

00:13:32,910 --> 00:13:36,390
these inter process communication

00:13:34,050 --> 00:13:40,700
actually works in practice

00:13:36,390 --> 00:13:40,700
okay thank you so much please welcome

00:13:45,650 --> 00:13:50,910
thank you for being here and thinking a

00:13:48,630 --> 00:13:52,650
call out for the introduction so I will

00:13:50,910 --> 00:13:54,750
guide you to the steps that we took to

00:13:52,650 --> 00:13:57,960
develop an application on an hybrid

00:13:54,750 --> 00:14:01,590
system we chose to develop on the an XP

00:13:57,960 --> 00:14:04,530
imx7 processor which has a cortex a7

00:14:01,590 --> 00:14:07,470
core alongside a cortex m4 core on in

00:14:04,530 --> 00:14:10,050
the same as hosi we have a master slave

00:14:07,470 --> 00:14:12,600
architecture where the cortex a7 is the

00:14:10,050 --> 00:14:15,480
master core and the m4 is the slave this

00:14:12,600 --> 00:14:18,830
means that the a7 is actually in charge

00:14:15,480 --> 00:14:22,020
of loading the femur and actually

00:14:18,830 --> 00:14:25,500
release the cortex m4 from reset mode so

00:14:22,020 --> 00:14:28,770
it takes it is responsible for booting

00:14:25,500 --> 00:14:31,530
the m4 and from that point on they run

00:14:28,770 --> 00:14:34,260
completely independently from each other

00:14:31,530 --> 00:14:37,560
and they actually run at different

00:14:34,260 --> 00:14:39,720
speeds so we need an inch processor

00:14:37,560 --> 00:14:42,210
communication protocol to ensure that

00:14:39,720 --> 00:14:46,130
the two cores can communicate between

00:14:42,210 --> 00:14:50,640
each other and the hardware model on the

00:14:46,130 --> 00:14:52,440
imx7 board that it is enabling this kind

00:14:50,640 --> 00:14:54,630
of communication is the messaging unit

00:14:52,440 --> 00:14:56,940
while the software component that

00:14:54,630 --> 00:14:58,890
enables communication is the RP message

00:14:56,940 --> 00:15:01,260
component which uses the openam

00:14:58,890 --> 00:15:05,910
framework we will see a little bit more

00:15:01,260 --> 00:15:08,460
in details this comprehends the two

00:15:05,910 --> 00:15:10,980
cores in an a symmetric multiprocessing

00:15:08,460 --> 00:15:14,550
system actually access the same

00:15:10,980 --> 00:15:17,220
peripherals and memory areas so we make

00:15:14,550 --> 00:15:21,240
sure that we have a mechanism to avoid

00:15:17,220 --> 00:15:21,510
conflicts we will go into details of

00:15:21,240 --> 00:15:24,420
this

00:15:21,510 --> 00:15:26,850
so the RDC is the resource to make

00:15:24,420 --> 00:15:30,440
Tolar and it's a hardware module of the

00:15:26,850 --> 00:15:34,079
imx7 processor that allows to create

00:15:30,440 --> 00:15:36,690
isolated resource domains so basically

00:15:34,079 --> 00:15:40,500
each peripheral or memory area can be

00:15:36,690 --> 00:15:41,970
assigned to one or more domain here in

00:15:40,500 --> 00:15:44,339
the picture you can see we have the

00:15:41,970 --> 00:15:47,190
application core which has we choose

00:15:44,339 --> 00:15:49,350
this on this kind of peripherals

00:15:47,190 --> 00:15:50,820
exclusively and then you can have of

00:15:49,350 --> 00:15:55,260
course shared peripherals

00:15:50,820 --> 00:15:58,350
so the RTC make sure that resources that

00:15:55,260 --> 00:16:03,060
access to shared resources is controlled

00:15:58,350 --> 00:16:05,850
and that there are no conflicts this is

00:16:03,060 --> 00:16:08,060
actually the component that the hardware

00:16:05,850 --> 00:16:10,529
component on the imx7 processor that

00:16:08,060 --> 00:16:13,500
enables passing messages between the

00:16:10,529 --> 00:16:16,410
cores so we basically have a set of

00:16:13,500 --> 00:16:19,230
registers and interrupts we have two

00:16:16,410 --> 00:16:22,829
sets of matching register one on each

00:16:19,230 --> 00:16:26,190
side and we need to because the two

00:16:22,829 --> 00:16:28,800
processor can work at different clock

00:16:26,190 --> 00:16:30,029
speeds so we need a way to synchronize

00:16:28,800 --> 00:16:32,610
them when they're passing messages

00:16:30,029 --> 00:16:34,800
between each other of course you have

00:16:32,610 --> 00:16:37,820
interrupts to signal the other core when

00:16:34,800 --> 00:16:40,440
new data is available and you have also

00:16:37,820 --> 00:16:42,209
for general-purpose interrupts on each

00:16:40,440 --> 00:16:44,370
side that you can use for

00:16:42,209 --> 00:16:46,230
general-purpose signaling we actually

00:16:44,370 --> 00:16:48,360
used in our demo application some of

00:16:46,230 --> 00:16:52,230
these general-purpose interrupts and we

00:16:48,360 --> 00:16:54,779
will see later how so as nicola said

00:16:52,230 --> 00:16:57,420
before the software component that

00:16:54,779 --> 00:17:01,260
enables communication interval social

00:16:57,420 --> 00:17:04,319
communication is RPM f RP msg and it

00:17:01,260 --> 00:17:08,459
fits on top of the video bus so this is

00:17:04,319 --> 00:17:10,709
a quick overview of the of how its video

00:17:08,459 --> 00:17:15,900
is implemented in the RP message

00:17:10,709 --> 00:17:18,809
framework we have in the detail

00:17:15,900 --> 00:17:20,880
implementation we have the viewing data

00:17:18,809 --> 00:17:23,730
structure which has some veering

00:17:20,880 --> 00:17:27,569
descriptors which are basically pointers

00:17:23,730 --> 00:17:31,290
to shared buffer buffers in memory which

00:17:27,569 --> 00:17:34,440
represents our message our actual market

00:17:31,290 --> 00:17:38,140
message and the width cue that we see

00:17:34,440 --> 00:17:40,840
here on the left is a user of

00:17:38,140 --> 00:17:44,350
direction that provides access to this

00:17:40,840 --> 00:17:46,510
peering structure and provide some api's

00:17:44,350 --> 00:17:49,450
as well so basically our RP message

00:17:46,510 --> 00:17:53,170
component uses this video abstractions

00:17:49,450 --> 00:17:57,640
to send and receive messages in the form

00:17:53,170 --> 00:18:01,570
of buffers in shared memory from the

00:17:57,640 --> 00:18:03,940
higher level from a higher level view we

00:18:01,570 --> 00:18:08,260
have the RP message component design

00:18:03,940 --> 00:18:11,230
here each remote core in the RP message

00:18:08,260 --> 00:18:13,600
framework is represented as a RP message

00:18:11,230 --> 00:18:17,620
device and provides a communication

00:18:13,600 --> 00:18:21,040
channel through the master core so the

00:18:17,620 --> 00:18:26,020
RP message devices also knows as alpha

00:18:21,040 --> 00:18:28,660
master channel and it has an ID which is

00:18:26,020 --> 00:18:31,720
a textual name that is used to identify

00:18:28,660 --> 00:18:34,750
each RPMs each channel has source

00:18:31,720 --> 00:18:37,690
address and a destination address and on

00:18:34,750 --> 00:18:41,460
top of these rpms each channel we have

00:18:37,690 --> 00:18:44,470
logical end points that are provided by

00:18:41,460 --> 00:18:46,300
we have a logical connection sorry on

00:18:44,470 --> 00:18:48,940
top of the RP message channels which are

00:18:46,300 --> 00:18:52,630
provided by these end points that are

00:18:48,940 --> 00:18:55,090
represented here as these pipes and each

00:18:52,630 --> 00:18:56,860
hand point has a local address and a

00:18:55,090 --> 00:18:57,310
callback function associated to this

00:18:56,860 --> 00:18:59,770
address

00:18:57,310 --> 00:19:01,720
so every time a new message arrives on

00:18:59,770 --> 00:19:04,180
the channel and has the destination

00:19:01,720 --> 00:19:06,430
address equal to the source address of

00:19:04,180 --> 00:19:09,970
the end point the callback function is

00:19:06,430 --> 00:19:13,000
immediately called and it can handle the

00:19:09,970 --> 00:19:15,640
payload of the message one thing to keep

00:19:13,000 --> 00:19:18,700
in mind is that currently in the RP

00:19:15,640 --> 00:19:22,090
message implementation in Linux the

00:19:18,700 --> 00:19:24,310
channel is only dynamically created so

00:19:22,090 --> 00:19:28,150
the remote service sent a special

00:19:24,310 --> 00:19:31,540
message to the RP message bus which says

00:19:28,150 --> 00:19:34,090
like I want to instantiate a new channel

00:19:31,540 --> 00:19:38,500
the RP message bus takes care of this

00:19:34,090 --> 00:19:41,230
message creates the channel and from

00:19:38,500 --> 00:19:43,540
that point on an end point a default end

00:19:41,230 --> 00:19:49,030
point is created and communication can

00:19:43,540 --> 00:19:51,070
go on from this point so this is the

00:19:49,030 --> 00:19:51,820
actual implementation of the RP message

00:19:51,070 --> 00:19:54,880
component

00:19:51,820 --> 00:19:57,400
Lenox the remote car is of course

00:19:54,880 --> 00:20:00,340
represented as a platform device which

00:19:57,400 --> 00:20:04,270
stands on the platform bus we have this

00:20:00,340 --> 00:20:07,000
driver which is the IMX RPM SG custom

00:20:04,270 --> 00:20:10,930
platform driver which takers of this

00:20:07,000 --> 00:20:13,690
remote platform device and registers a

00:20:10,930 --> 00:20:16,150
virtual device then we have another

00:20:13,690 --> 00:20:18,970
driver which is the VAR p message bus

00:20:16,150 --> 00:20:21,640
driver which is like a bridge from the

00:20:18,970 --> 00:20:25,270
vittorio bus to the RP message bus and

00:20:21,640 --> 00:20:29,380
registers an RP message device here we

00:20:25,270 --> 00:20:31,720
have one last custom driver which is the

00:20:29,380 --> 00:20:34,900
RP message card driver which was is

00:20:31,720 --> 00:20:36,880
quite recent it has been introduced in

00:20:34,900 --> 00:20:40,750
the four point eight eleven kernel Linux

00:20:36,880 --> 00:20:44,980
version and of course it registers

00:20:40,750 --> 00:20:48,730
itself as an RP message driver and as

00:20:44,980 --> 00:20:51,040
soon as it is probed it creates this

00:20:48,730 --> 00:20:54,460
character device here which represents

00:20:51,040 --> 00:20:57,190
our remote core so you basically exports

00:20:54,460 --> 00:21:00,070
the remote core abstraction as a

00:20:57,190 --> 00:21:03,520
character device which is really useful

00:21:00,070 --> 00:21:04,930
if you have to write like a new space

00:21:03,520 --> 00:21:08,440
application I have to deal with

00:21:04,930 --> 00:21:11,340
communication with this remote for so as

00:21:08,440 --> 00:21:14,800
soon as we have this device available

00:21:11,340 --> 00:21:18,390
the user space application can do an IO

00:21:14,800 --> 00:21:21,190
CTL operation on this kind of device and

00:21:18,390 --> 00:21:24,430
asked for a request the creation of an

00:21:21,190 --> 00:21:26,470
endpoint as soon as this happens another

00:21:24,430 --> 00:21:29,290
character device is created which

00:21:26,470 --> 00:21:31,690
represents the end point and if this dev

00:21:29,290 --> 00:21:34,270
RP message adds character device and

00:21:31,690 --> 00:21:37,000
from this point on user space has access

00:21:34,270 --> 00:21:39,310
to the end point and can send and

00:21:37,000 --> 00:21:41,320
receive RP message messages just by

00:21:39,310 --> 00:21:46,090
writing and reading on the character

00:21:41,320 --> 00:21:50,350
device so we developed a demo

00:21:46,090 --> 00:21:52,270
application on the I am on an imx7 base

00:21:50,350 --> 00:21:55,180
board which is the boundary devices

00:21:52,270 --> 00:21:57,370
nitrogen 7 we are actually replicating

00:21:55,180 --> 00:22:01,690
the same demo on our carrier ball by

00:21:57,370 --> 00:22:03,130
toradex with the imx7 zone and the goal

00:22:01,690 --> 00:22:07,420
of our demo

00:22:03,130 --> 00:22:10,510
to have free artists running on the

00:22:07,420 --> 00:22:13,980
cortex m4 and Linux

00:22:10,510 --> 00:22:19,930
I think the version was 4.9 on the

00:22:13,980 --> 00:22:22,030
cortex a7 so on the cortex m4 side we

00:22:19,930 --> 00:22:24,580
are pulling an IMU so in inertial

00:22:22,030 --> 00:22:26,560
measurement unit we are reading data

00:22:24,580 --> 00:22:29,320
from the sensor and we want to send them

00:22:26,560 --> 00:22:33,520
to the master core and visualize them

00:22:29,320 --> 00:22:35,800
somehow one particularly use case that

00:22:33,520 --> 00:22:38,070
we wanted to address was to safely

00:22:35,800 --> 00:22:41,350
recover from a kernel panic on the

00:22:38,070 --> 00:22:44,470
master core we will see later all the

00:22:41,350 --> 00:22:49,660
details but first I wanted to introduce

00:22:44,470 --> 00:22:51,730
them on how to build an environment or

00:22:49,660 --> 00:22:56,860
prepare your environment for developing

00:22:51,730 --> 00:22:59,320
a an application on an AMD system so the

00:22:56,860 --> 00:23:01,900
first thing you want to do is bring up

00:22:59,320 --> 00:23:03,310
your remote core and of course you have

00:23:01,900 --> 00:23:07,720
to download the three are two sources

00:23:03,310 --> 00:23:08,440
the new GCC toolchain and you're pretty

00:23:07,720 --> 00:23:11,950
much ready to go

00:23:08,440 --> 00:23:14,050
because in the three Archos sources you

00:23:11,950 --> 00:23:16,870
have a sub directory which is examples

00:23:14,050 --> 00:23:20,500
that has a bunch of applications already

00:23:16,870 --> 00:23:23,530
ready to be built for multiple boards

00:23:20,500 --> 00:23:25,810
and you also have an arm GCC sub folder

00:23:23,530 --> 00:23:27,970
where you have build scripts so you

00:23:25,810 --> 00:23:30,670
basically can just launch this build

00:23:27,970 --> 00:23:34,870
scripts from shell and have your binary

00:23:30,670 --> 00:23:37,060
right away second step is to actually

00:23:34,870 --> 00:23:39,550
deploy the application on the cortex and

00:23:37,060 --> 00:23:42,670
for you have a couple of choices

00:23:39,550 --> 00:23:43,120
I usually prefer to do it but from you

00:23:42,670 --> 00:23:45,910
bud

00:23:43,120 --> 00:23:49,720
so use the you boost mass storage gadget

00:23:45,910 --> 00:23:52,510
to mount DMC on my PC and I just drag

00:23:49,720 --> 00:23:54,970
and drop on my binary and then I use the

00:23:52,510 --> 00:23:56,740
and for update you would comment to

00:23:54,970 --> 00:24:00,400
actually deploy the application on the

00:23:56,740 --> 00:24:03,160
cortex and for you have a couple other

00:24:00,400 --> 00:24:04,750
choices you can use also a remote prop

00:24:03,160 --> 00:24:06,940
framework which is still part of the

00:24:04,750 --> 00:24:08,740
open framework and all documentation is

00:24:06,940 --> 00:24:11,890
under the open amp

00:24:08,740 --> 00:24:15,730
documentation or you can use the and for

00:24:11,890 --> 00:24:16,809
film or loader for an XP so either of

00:24:15,730 --> 00:24:19,419
these methods

00:24:16,809 --> 00:24:21,039
do the job basically depends on when you

00:24:19,419 --> 00:24:25,450
want your coat checks and for to be

00:24:21,039 --> 00:24:28,029
started then you can choose from which

00:24:25,450 --> 00:24:31,870
memory you want to run your application

00:24:28,029 --> 00:24:33,700
from the preferred memory is usually the

00:24:31,870 --> 00:24:37,450
TCM so the tightly coupled memory

00:24:33,700 --> 00:24:39,850
because it's a small fast memory

00:24:37,450 --> 00:24:42,249
dedicated entirely to the cortex and for

00:24:39,850 --> 00:24:44,950
the drawback is that it's only 32

00:24:42,249 --> 00:24:46,870
kilobytes so you have to make sure that

00:24:44,950 --> 00:24:51,809
your free Archos application is

00:24:46,870 --> 00:24:54,549
optimized to fit into this small size so

00:24:51,809 --> 00:24:57,490
as I said before you can build your

00:24:54,549 --> 00:24:59,830
applications from shell very easily by

00:24:57,490 --> 00:25:01,869
using the build scripts but you can

00:24:59,830 --> 00:25:04,480
choose of course to use an IDE you have

00:25:01,869 --> 00:25:08,110
a couple of commercial choices here

00:25:04,480 --> 00:25:12,210
imported ds5 or social code bench that

00:25:08,110 --> 00:25:16,269
they have like a lot of tools especially

00:25:12,210 --> 00:25:18,309
tailored for EMP debugging I decided

00:25:16,269 --> 00:25:21,159
actually to go with the plain Eclipse

00:25:18,309 --> 00:25:23,230
way so I just took eclipse and I

00:25:21,159 --> 00:25:27,429
equipped it with a few tools that can

00:25:23,230 --> 00:25:31,480
have debugging on AMT systems I was

00:25:27,429 --> 00:25:33,970
using j-link secure debugger so I needed

00:25:31,480 --> 00:25:37,090
like the set of tools which is which are

00:25:33,970 --> 00:25:39,879
the new MCU Eclipse plugins to out

00:25:37,090 --> 00:25:43,960
support for my probe then of course you

00:25:39,879 --> 00:25:46,779
you will need gdb if you're using as

00:25:43,960 --> 00:25:50,169
well j-link debugger you will need

00:25:46,779 --> 00:25:52,960
jailing scripts to debug both the cortex

00:25:50,169 --> 00:25:56,590
a7 core and the cortex m4 simultaneously

00:25:52,960 --> 00:25:59,529
and then I use also the free Archer

00:25:56,590 --> 00:26:01,809
scanner awareness plug-in from NXP which

00:25:59,529 --> 00:26:04,619
is not it's the only thing that it's not

00:26:01,809 --> 00:26:08,409
open source but it's really useful to

00:26:04,619 --> 00:26:10,679
debug free artists application you can

00:26:08,409 --> 00:26:14,289
see like the status over your tasks

00:26:10,679 --> 00:26:17,669
start usage heap usage and everything

00:26:14,289 --> 00:26:21,070
that's useful for this kind of debugging

00:26:17,669 --> 00:26:24,220
so after you set up your at leap plain

00:26:21,070 --> 00:26:26,379
Eclipse IDE it should look like this you

00:26:24,220 --> 00:26:29,139
have of course the classic breakpoints

00:26:26,379 --> 00:26:30,490
view right now I have only one

00:26:29,139 --> 00:26:31,660
breakpoint in the end

00:26:30,490 --> 00:26:33,400
to you but of course you can have

00:26:31,660 --> 00:26:35,260
multiple break points on the MP you as

00:26:33,400 --> 00:26:37,990
well you have your free archers can

00:26:35,260 --> 00:26:41,980
awareness plugin for debugging the tasks

00:26:37,990 --> 00:26:44,440
and then of course you have consoles for

00:26:41,980 --> 00:26:48,640
debugging both the cortex m4 and the

00:26:44,440 --> 00:26:51,730
cortex a7 simultaneously so back to our

00:26:48,640 --> 00:26:53,890
demo application that we developed on

00:26:51,730 --> 00:26:57,820
the remote core we have free Archos

00:26:53,890 --> 00:26:59,950
application and we sample the inertial

00:26:57,820 --> 00:27:02,559
measurement unit every 10 milliseconds

00:26:59,950 --> 00:27:05,410
we calculate an objective function in

00:27:02,559 --> 00:27:07,390
our case was basically calculating the

00:27:05,410 --> 00:27:09,280
module of the vectors of the

00:27:07,390 --> 00:27:13,030
acceleration accelerometer magnetometer

00:27:09,280 --> 00:27:17,020
and gyroscope data then we are storing

00:27:13,030 --> 00:27:20,770
these samples on a buffer which is in

00:27:17,020 --> 00:27:24,610
our case is only three hundred three

00:27:20,770 --> 00:27:29,530
hundred elements and the reason that we

00:27:24,610 --> 00:27:31,630
use this Q this Q the size of our Q is

00:27:29,530 --> 00:27:33,490
that we wanted to store our application

00:27:31,630 --> 00:27:35,559
on the TCM so we only had like two

00:27:33,490 --> 00:27:39,040
kilobytes so we have a pretty small

00:27:35,559 --> 00:27:45,970
buffer but it's enough for the demo we

00:27:39,040 --> 00:27:48,130
are studying and then items are DQ'd

00:27:45,970 --> 00:27:51,910
from this buffer and sent to the master

00:27:48,130 --> 00:27:56,590
core for visualization so we send ten

00:27:51,910 --> 00:27:59,080
items at a time and every 100

00:27:56,590 --> 00:28:01,240
milliseconds on the master code we have

00:27:59,080 --> 00:28:04,059
a much simpler application it's a user

00:28:01,240 --> 00:28:06,250
space Linux application that just pulls

00:28:04,059 --> 00:28:09,340
the character device which represents

00:28:06,250 --> 00:28:13,540
the RPMs each endpoint and dumps the

00:28:09,340 --> 00:28:15,780
data are received on our text file so

00:28:13,540 --> 00:28:18,190
here we have an overview of the

00:28:15,780 --> 00:28:20,800
architecture of the demo application and

00:28:18,190 --> 00:28:24,340
on the left side we on the right side

00:28:20,800 --> 00:28:26,950
sorry we have the cortex m4 which is

00:28:24,340 --> 00:28:29,380
running FreeRTOS and we have two as

00:28:26,950 --> 00:28:31,809
synchronous tasks we have the email

00:28:29,380 --> 00:28:36,730
polling task which actually continuously

00:28:31,809 --> 00:28:39,820
pose the EMU and in queues our samples

00:28:36,730 --> 00:28:42,520
in the share buffer and then we have the

00:28:39,820 --> 00:28:43,880
data center task which is in charge for

00:28:42,520 --> 00:28:47,090
the initialization

00:28:43,880 --> 00:28:50,570
of the RPMs a channel and it is in

00:28:47,090 --> 00:28:52,460
charge of the queuing samples from the

00:28:50,570 --> 00:28:55,429
shed queue and sending it to the master

00:28:52,460 --> 00:28:58,669
core here we can see the arguments

00:28:55,429 --> 00:29:01,610
channel as well as the end points and on

00:28:58,669 --> 00:29:02,960
the left side we have the Linux side so

00:29:01,610 --> 00:29:05,980
our master curve which is running in

00:29:02,960 --> 00:29:11,030
Linux we can see the rpms each car

00:29:05,980 --> 00:29:14,539
kernel driver which exports our endpoint

00:29:11,030 --> 00:29:16,820
data as character devices and finally we

00:29:14,539 --> 00:29:20,000
have our user space application that

00:29:16,820 --> 00:29:24,200
interacts with the character devices to

00:29:20,000 --> 00:29:27,409
read data and dump them dump data on our

00:29:24,200 --> 00:29:29,120
text file we also used three

00:29:27,409 --> 00:29:31,039
general-purpose interrupts that were

00:29:29,120 --> 00:29:33,530
provided by the messaging unit to

00:29:31,039 --> 00:29:36,200
actually see know from states of the

00:29:33,530 --> 00:29:38,960
master to the remote car these are all

00:29:36,200 --> 00:29:42,200
triggered by the master towards the

00:29:38,960 --> 00:29:45,320
remote core we call them start CMD stop

00:29:42,200 --> 00:29:47,690
CMD and heartbeat so starts MD is an

00:29:45,320 --> 00:29:50,059
interrupt that it's used to signal that

00:29:47,690 --> 00:29:53,270
master has created the endpoint and it's

00:29:50,059 --> 00:29:55,280
ready to receive data stops Indy is used

00:29:53,270 --> 00:29:57,799
to a signal that the endpoint has been

00:29:55,280 --> 00:29:59,900
destroyed and this actually happens

00:29:57,799 --> 00:30:02,150
every time we close the RP message car

00:29:59,900 --> 00:30:04,429
client applications since there's no

00:30:02,150 --> 00:30:07,400
need of keep receiving data for not

00:30:04,429 --> 00:30:11,289
using it and last one is the heartbeat

00:30:07,400 --> 00:30:15,110
so we needed a way to for the cortex m4

00:30:11,289 --> 00:30:16,760
to know whether the cortex a7 was still

00:30:15,110 --> 00:30:19,840
up and running or if it crashed

00:30:16,760 --> 00:30:22,490
for some reason so basically we're

00:30:19,840 --> 00:30:25,730
generating an interrupt from the master

00:30:22,490 --> 00:30:28,520
periodically and the cortex m4 just

00:30:25,730 --> 00:30:30,710
checks if this interrupts arrived at

00:30:28,520 --> 00:30:32,720
certain times and if it doesn't it just

00:30:30,710 --> 00:30:37,400
assumes that the master is dead for some

00:30:32,720 --> 00:30:40,159
reason so yes this is was the previous

00:30:37,400 --> 00:30:44,630
image and you can see we have the same

00:30:40,159 --> 00:30:46,429
pretty much the same structure here we

00:30:44,630 --> 00:30:49,280
have the control flow on the two cores

00:30:46,429 --> 00:30:51,409
so on the left side we have our key

00:30:49,280 --> 00:30:54,290
message car client on the lane so the

00:30:51,409 --> 00:30:56,419
Linux user space application we have a

00:30:54,290 --> 00:30:57,180
first transition from state where the

00:30:56,419 --> 00:31:01,010
RPMs

00:30:57,180 --> 00:31:04,800
is not created to a state where it's up

00:31:01,010 --> 00:31:08,000
then the user application just opens the

00:31:04,800 --> 00:31:10,410
dev RP message 0 character device and

00:31:08,000 --> 00:31:13,050
with this action the endpoint is

00:31:10,410 --> 00:31:17,010
actually created and then we stay in

00:31:13,050 --> 00:31:20,970
this s2 state we just keeps reading data

00:31:17,010 --> 00:31:23,130
in coming to the RPMs a channel and then

00:31:20,970 --> 00:31:25,440
when we want to close our application we

00:31:23,130 --> 00:31:27,270
just close the dev RP message 0

00:31:25,440 --> 00:31:31,410
character device the endpoint is

00:31:27,270 --> 00:31:33,960
destroyed and that's it on the right

00:31:31,410 --> 00:31:37,650
side we have the flow of the data sender

00:31:33,960 --> 00:31:39,750
task on the free artists side also here

00:31:37,650 --> 00:31:43,290
we have a first transition from where

00:31:39,750 --> 00:31:46,320
the channel is not there to the state

00:31:43,290 --> 00:31:49,410
where the channel is created then we

00:31:46,320 --> 00:31:52,980
just our task just waits for start CMD

00:31:49,410 --> 00:31:58,320
interrupts goes into this state where it

00:31:52,980 --> 00:32:00,960
just keeps sending the email samples to

00:31:58,320 --> 00:32:02,670
the master core and checks for the

00:32:00,960 --> 00:32:06,420
master habit

00:32:02,670 --> 00:32:10,320
if stop CMD interrupts arrives it just

00:32:06,420 --> 00:32:13,410
goes back to just reading samples from

00:32:10,320 --> 00:32:16,560
the email and buffering data and if the

00:32:13,410 --> 00:32:20,760
master habit doesn't arrive on the

00:32:16,560 --> 00:32:23,130
expected time it the MCU just assumes

00:32:20,760 --> 00:32:25,260
that the mpu has crashed and goes back

00:32:23,130 --> 00:32:31,890
destroys the channel and goes back to

00:32:25,260 --> 00:32:34,260
first state so we had to figure out what

00:32:31,890 --> 00:32:38,880
to do if the Linux kernel panic on the

00:32:34,260 --> 00:32:40,800
master side using a watchdog to just

00:32:38,880 --> 00:32:44,010
trigger a full reboot was not an option

00:32:40,800 --> 00:32:47,970
here because in the imx7 architecture if

00:32:44,010 --> 00:32:51,180
you reboot your cortex a7 core also the

00:32:47,970 --> 00:32:53,850
m4 core will be rebooted we still wanted

00:32:51,180 --> 00:32:56,340
the application to run to keep running

00:32:53,850 --> 00:32:59,430
on the cortex m4 and just reboot the

00:32:56,340 --> 00:33:01,980
Linux kernel on the a7 so the solution

00:32:59,430 --> 00:33:06,230
we came up with was to use a key exact

00:33:01,980 --> 00:33:08,179
which allows to load

00:33:06,230 --> 00:33:12,320
colonel from the currently running

00:33:08,179 --> 00:33:17,120
colonel and the reason we chose k exact

00:33:12,320 --> 00:33:20,090
is that it does not reset all the

00:33:17,120 --> 00:33:23,360
hardware devices but it's just like a

00:33:20,090 --> 00:33:26,120
soft reboot and so it doesn't actually

00:33:23,360 --> 00:33:29,600
touch our application running on the

00:33:26,120 --> 00:33:31,370
cortex and for this mechanism is usually

00:33:29,600 --> 00:33:35,780
used in conjunction with kdump

00:33:31,370 --> 00:33:38,240
to also dump the crushed kernel memory

00:33:35,780 --> 00:33:40,669
for further debugging we actually didn't

00:33:38,240 --> 00:33:44,900
use K dump in Sita this demo application

00:33:40,669 --> 00:33:49,910
we only needed k exact we also used two

00:33:44,900 --> 00:33:52,100
kernel images wanted that it is booted

00:33:49,910 --> 00:33:56,270
every time normally in a normal boat and

00:33:52,100 --> 00:33:59,210
one that it is executed only in case of

00:33:56,270 --> 00:34:03,410
a kernel panic so we had to add some

00:33:59,210 --> 00:34:05,570
extra options both to the normal kernel

00:34:03,410 --> 00:34:08,419
comment line and both into the crash

00:34:05,570 --> 00:34:11,780
pokemon line and then we had to use like

00:34:08,419 --> 00:34:14,090
this option to signal that the crush

00:34:11,780 --> 00:34:17,720
kernel has to be loaded only in case of

00:34:14,090 --> 00:34:19,790
a kernel panic or keep in mind that

00:34:17,720 --> 00:34:23,050
cakes I can pay dam support on our

00:34:19,790 --> 00:34:28,340
platform is still experimental so we had

00:34:23,050 --> 00:34:30,740
some problems with the demo we solved

00:34:28,340 --> 00:34:33,619
some problems and we still have some

00:34:30,740 --> 00:34:37,280
other ones that we need to have a more

00:34:33,619 --> 00:34:39,290
detailed look at but we will see what

00:34:37,280 --> 00:34:46,060
are the promises are still open in our

00:34:39,290 --> 00:34:46,060
demo so we have a video of the term

00:34:54,200 --> 00:35:00,200
so what we have is on the left side we

00:34:57,980 --> 00:35:03,710
have the cortex a7 which is Bowden Linux

00:35:00,200 --> 00:35:07,270
and on the right side we have our cortex

00:35:03,710 --> 00:35:09,680
m4 with FreeRTOS you can also see that

00:35:07,270 --> 00:35:12,770
the free artis application has already

00:35:09,680 --> 00:35:16,130
started and has initialized the sensors

00:35:12,770 --> 00:35:19,849
and it's actually already sampling the

00:35:16,130 --> 00:35:23,210
EMU and buffering our data so as soon as

00:35:19,849 --> 00:35:26,540
the cortex a7 is up we just log in and

00:35:23,210 --> 00:35:28,430
we launch our RP message car client

00:35:26,540 --> 00:35:31,549
application which is the user space

00:35:28,430 --> 00:35:33,559
application and we can see that the data

00:35:31,549 --> 00:35:38,480
is starting to flow from the cortex m4

00:35:33,559 --> 00:35:41,420
to the cortex a7 yeah we are writing our

00:35:38,480 --> 00:35:44,329
samples you know text file you can see

00:35:41,420 --> 00:35:48,619
that data is correctly arriving on the

00:35:44,329 --> 00:35:52,339
master side down here we are loading the

00:35:48,619 --> 00:35:54,859
crash colonel with the options that we

00:35:52,339 --> 00:35:58,430
saw earlier and here we are actually

00:35:54,859 --> 00:36:01,369
closing a kernel panic so here you can

00:35:58,430 --> 00:36:03,619
see that the cortex m4 said master is

00:36:01,369 --> 00:36:05,990
dead so he actually realizes that the

00:36:03,619 --> 00:36:09,640
master core is not up anymore and it

00:36:05,990 --> 00:36:13,430
just keeps running and the cortex a7 is

00:36:09,640 --> 00:36:16,190
rebooting its crash kernel so as soon as

00:36:13,430 --> 00:36:18,890
the crash kernel is up and running the

00:36:16,190 --> 00:36:22,970
channel the RPMs a channel is recreated

00:36:18,890 --> 00:36:25,420
again and we can relaunch our user space

00:36:22,970 --> 00:36:29,119
applications you see that data is still

00:36:25,420 --> 00:36:32,390
recovered that's what we're doing here

00:36:29,119 --> 00:36:36,349
so cortex m4 starts sending all the data

00:36:32,390 --> 00:36:41,660
that it has sampled and buffered to the

00:36:36,349 --> 00:36:47,829
cortex a7 and there is still arriving on

00:36:41,660 --> 00:36:47,829
the master side so that's it

00:36:49,940 --> 00:36:56,730
but to our presentation

00:36:54,050 --> 00:36:59,400
okay so here are the problems that we

00:36:56,730 --> 00:37:02,330
encountered during the development of

00:36:59,400 --> 00:37:05,490
this demo application first of all

00:37:02,330 --> 00:37:08,000
before announcing the remote service the

00:37:05,490 --> 00:37:11,820
remote core actually checks whether the

00:37:08,000 --> 00:37:14,460
master core is up or not we saw that if

00:37:11,820 --> 00:37:16,710
this notification arrives too early in

00:37:14,460 --> 00:37:22,170
the booting process of the crash kernel

00:37:16,710 --> 00:37:24,840
the system actually might hang so we we

00:37:22,170 --> 00:37:27,390
did a kind of a workaround by adding a

00:37:24,840 --> 00:37:29,040
delay between the moment that the remote

00:37:27,390 --> 00:37:32,220
core realises that the master code is

00:37:29,040 --> 00:37:35,849
dead and the moment where it tries to

00:37:32,220 --> 00:37:38,580
reinitiate the RP message channel but we

00:37:35,849 --> 00:37:41,910
don't who didn't understand very well

00:37:38,580 --> 00:37:44,010
what the system hanks sometimes when

00:37:41,910 --> 00:37:48,030
this notification arrives too early and

00:37:44,010 --> 00:37:50,640
the other problem which is a big one is

00:37:48,030 --> 00:37:53,910
that key exact still hangs sometimes and

00:37:50,640 --> 00:37:56,670
it happens like randomly it's really

00:37:53,910 --> 00:38:00,270
hard to debug and but we saw that it

00:37:56,670 --> 00:38:02,339
happens more frequently when the flow of

00:38:00,270 --> 00:38:05,280
data is continuous from the remote core

00:38:02,339 --> 00:38:07,920
to the master core so I think that

00:38:05,280 --> 00:38:09,750
something's wrong with the interrupts

00:38:07,920 --> 00:38:12,390
that are arriving so if there are too

00:38:09,750 --> 00:38:14,310
many interrupts at the system I hang but

00:38:12,390 --> 00:38:16,170
we we will need to do some further

00:38:14,310 --> 00:38:18,750
investigation on this problem because

00:38:16,170 --> 00:38:24,270
it's hard to debug and we didn't solve

00:38:18,750 --> 00:38:33,300
it on time so that said if you have any

00:38:24,270 --> 00:38:35,599
questions oh yeah any questions

00:38:33,300 --> 00:38:35,599
yep

00:38:38,770 --> 00:38:48,680
yes actually from the on the remote core

00:38:43,640 --> 00:38:51,220
side your use RTC to actually say which

00:38:48,680 --> 00:38:53,540
peripherals and which memory areas are

00:38:51,220 --> 00:38:56,090
dedicated to the real-time core and

00:38:53,540 --> 00:38:59,500
which one or not so they're completely

00:38:56,090 --> 00:39:09,190
independent and access to resources is

00:38:59,500 --> 00:39:09,190
safe yes

00:39:16,790 --> 00:39:30,710
if the master decides to send interrupts

00:39:20,360 --> 00:39:33,410
the river yes this is true we need a way

00:39:30,710 --> 00:39:38,960
to make the real town called aware of

00:39:33,410 --> 00:39:41,030
the status of the master core also I we

00:39:38,960 --> 00:39:43,520
used the general-purpose interrupts

00:39:41,030 --> 00:39:47,000
provided by the messaging unit so I just

00:39:43,520 --> 00:39:58,700
assumed that it was kind of safe to send

00:39:47,000 --> 00:40:01,370
those kind of interrupts yeah the

00:39:58,700 --> 00:40:04,180
messaging unit should take care of this

00:40:01,370 --> 00:40:04,180
actually

00:40:18,680 --> 00:40:27,040
is it I'm sorry can you repeat I know

00:40:26,210 --> 00:40:30,320
it's just

00:40:27,040 --> 00:40:32,810
there is a packet structure but it's

00:40:30,320 --> 00:40:47,990
only data written shed memory it's not

00:40:32,810 --> 00:40:51,620
like a real packet well it depends on

00:40:47,990 --> 00:40:53,030
when you want your cortex and for to be

00:40:51,620 --> 00:40:55,430
started if you wanted to be started

00:40:53,030 --> 00:40:58,970
before the cortex a7 or if you wanted to

00:40:55,430 --> 00:41:03,530
be started later I didn't actually study

00:40:58,970 --> 00:41:05,570
performances or I I don't really know if

00:41:03,530 --> 00:41:09,670
there are differences on performances I

00:41:05,570 --> 00:41:09,670
always used like the u-boot version

00:41:37,380 --> 00:41:40,519
which is decided

00:42:00,840 --> 00:42:06,330
no we're using a open arm I mean

00:42:03,630 --> 00:42:18,420
freertos has the whole open army to

00:42:06,330 --> 00:42:25,100
we're just ready no we didn't we use the

00:42:18,420 --> 00:42:25,100
plane of open arm implementation yes

00:42:33,740 --> 00:42:40,799
no I think it can actually work with

00:42:36,690 --> 00:42:43,770
other like if you have an artisan and

00:42:40,799 --> 00:42:46,859
other artists the opening implementation

00:42:43,770 --> 00:42:50,510
has a bunch of cases use cases that you

00:42:46,859 --> 00:42:53,309
can use and you can also use an FPGA so

00:42:50,510 --> 00:42:55,890
there are multiple scenarios where you

00:42:53,309 --> 00:43:05,970
can use this framework and it's all

00:42:55,890 --> 00:43:09,859
documented in the open documentation we

00:43:05,970 --> 00:43:09,859
didn't actually measure our

00:43:51,220 --> 00:43:54,220
yes

00:43:56,620 --> 00:43:59,550
yep

00:44:15,240 --> 00:44:20,990
I didn't actually understand only sorry

00:44:18,240 --> 00:44:20,990
I came here

00:44:37,460 --> 00:44:43,550
yeah actually the RP message card driver

00:44:40,430 --> 00:44:45,829
used uses socket buffer to store

00:44:43,550 --> 00:45:01,130
incoming data and export it to use this

00:44:45,829 --> 00:45:04,210
place I don't know if that's was I just

00:45:01,130 --> 00:45:04,210
use this socket

00:45:51,830 --> 00:46:05,580
yes we wanted to but we didn't actually

00:46:02,970 --> 00:46:08,670
because we had a hard time to like have

00:46:05,580 --> 00:46:17,030
all the system we can exactly we didn't

00:46:08,670 --> 00:46:17,030
make it on time I'm sorry yes

00:46:33,840 --> 00:46:37,080
yeah we

00:47:42,940 --> 00:47:50,120
also like the in our case we were using

00:47:47,630 --> 00:47:53,570
the boundary devices board they already

00:47:50,120 --> 00:47:58,520
provide like PSP for free artists and as

00:47:53,570 --> 00:48:00,350
well as candle sources which everything

00:47:58,520 --> 00:48:03,560
is pretty much ready also your food

00:48:00,350 --> 00:48:07,280
sources so everything is already taken

00:48:03,560 --> 00:48:10,130
care of so the effort of just deploying

00:48:07,280 --> 00:48:13,370
the kernel and the application I mean

00:48:10,130 --> 00:48:16,840
it's basically straight forward we

00:48:13,370 --> 00:48:16,840
didn't actually have to

00:49:38,930 --> 00:49:41,650
yeah

00:49:43,510 --> 00:49:50,329
now you can actually you have like

00:49:47,029 --> 00:49:56,029
different power states on the tool you

00:49:50,329 --> 00:49:59,329
can also go to Power Save mode on the

00:49:56,029 --> 00:50:02,240
cortex a7 and just wake up the cortex a7

00:49:59,329 --> 00:50:04,460
as you want from the cortex m4 so power

00:50:02,240 --> 00:50:09,190
management from that point of view is

00:50:04,460 --> 00:50:09,190
independent so yeah we can do that

00:50:35,240 --> 00:50:55,119
against operation without you guys you

00:50:48,320 --> 00:50:55,119
guys stop the MCU because actually give

00:50:56,349 --> 00:51:48,970
up the power yeah we have won the

00:51:46,070 --> 00:51:48,970
arguments trimmer

00:52:00,430 --> 00:52:03,630
as following

00:52:14,680 --> 00:52:17,670
anything else

00:52:18,119 --> 00:52:24,419
okay thank you

00:52:19,820 --> 00:52:24,419

YouTube URL: https://www.youtube.com/watch?v=xXQ2cqIwo8E


