Title: Secure Containers in Embedded Deployments - Stefano Stabellini, Xen Project
Publication date: 2018-03-14
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	Secure Containers in Embedded Deployments - Stefano Stabellini, Xen Project

Containers are extremely convenient to package applications and deploy them quickly across the data center. They enable microservices oriented approaches to the development of complex apps. These technologies and trends are benefitting the data center, but are struggling to find their place in embedded environments.

As embedded developers, we would like the convenience of containers for deployment, while retaining real-time capabilities and supporting mixing and matching of applications with different safety and criticality profiles on the same board. This hasn't been possible so far.

This talk will present a novel approach based on embedded hypervisors to run container apps on small embedded devices without sacrificing real-time or safety. The presentation will discuss ways to reduce the footprint of Docker apps and will show safe techniques to give them direct access to hardware. 

About Stefano Stabellini
Stefano Stabellini serves as virtualization expert and Linux kernel lead at Aporeto, a VC funded early stage start-up in the Bay Area. Previously, as Senior Principal Software Engineer in Citrix, he led a small group of passionate engineers working on Open Source projects. Stefano has been involved in Xen development since 2007. He created libxenlight in November 2009 and started the Xen port to ARM with virtualization extensions in 2011. Today he is a Xen Project committer, and he maintains Xen on ARM and Xen support in Linux and QEMU.
Captions: 
	00:00:00,000 --> 00:00:03,720
hi everybody my name is Stefano and I

00:00:02,760 --> 00:00:06,629
would like to talk to you about

00:00:03,720 --> 00:00:09,389
containers containers are cool right

00:00:06,629 --> 00:00:10,980
everybody loves containers I for one I

00:00:09,389 --> 00:00:13,170
do like containers and I use them almost

00:00:10,980 --> 00:00:16,400
every day for my work so let's see how

00:00:13,170 --> 00:00:19,170
we can make them work in embedded and

00:00:16,400 --> 00:00:21,060
first of all like to start by well

00:00:19,170 --> 00:00:22,740
continuing is a solution is a technology

00:00:21,060 --> 00:00:23,850
right what's the problem let's talk

00:00:22,740 --> 00:00:26,400
about the problem that we're trying to

00:00:23,850 --> 00:00:30,029
solve and I think the problem has two

00:00:26,400 --> 00:00:31,800
sides one is packaging we need to find a

00:00:30,029 --> 00:00:34,350
way to package an application for our

00:00:31,800 --> 00:00:39,239
target a way to share an application

00:00:34,350 --> 00:00:40,950
across teams Oregon for example and this

00:00:39,239 --> 00:00:43,170
packaging needs to have some you know it

00:00:40,950 --> 00:00:43,710
has some requirements such as in this

00:00:43,170 --> 00:00:45,539
container

00:00:43,710 --> 00:00:48,960
needs to contain the battery of the

00:00:45,539 --> 00:00:51,930
application but also the dependencies in

00:00:48,960 --> 00:00:54,390
also needs to be in a format so that the

00:00:51,930 --> 00:00:57,449
application then is easy to update so

00:00:54,390 --> 00:00:59,160
you will want to ship even dynamically

00:00:57,449 --> 00:01:01,500
potentially ship an application to our

00:00:59,160 --> 00:01:05,309
target embedded board or IOT device and

00:01:01,500 --> 00:01:06,960
then update it easily right so that in

00:01:05,309 --> 00:01:08,369
maybe if we have more than one

00:01:06,960 --> 00:01:12,299
application more than one container

00:01:08,369 --> 00:01:16,439
running on our IOT device we might want

00:01:12,299 --> 00:01:18,270
to handle their updates independently so

00:01:16,439 --> 00:01:20,070
that's one part of the problem the

00:01:18,270 --> 00:01:22,350
second part of the problem is running

00:01:20,070 --> 00:01:23,720
the application actually on the target

00:01:22,350 --> 00:01:26,220
so now that we have found a way to

00:01:23,720 --> 00:01:28,290
install and manage the updates of the

00:01:26,220 --> 00:01:30,930
apps in on our target we need to find a

00:01:28,290 --> 00:01:33,090
way to run them securely in any nozzle

00:01:30,930 --> 00:01:35,640
in isolation so that the apps don't

00:01:33,090 --> 00:01:37,320
interfere with one another now this are

00:01:35,640 --> 00:01:42,299
actually quite two quite different

00:01:37,320 --> 00:01:44,100
problems and well one idea is to solve

00:01:42,299 --> 00:01:45,450
them both with docker right because

00:01:44,100 --> 00:01:48,479
doctor actually comes with a set of

00:01:45,450 --> 00:01:52,979
technologies that allow us to kind of do

00:01:48,479 --> 00:01:56,520
both now let's dig a bit more into this

00:01:52,979 --> 00:01:59,640
and what actually means so first of all

00:01:56,520 --> 00:02:02,399
even within the container world

00:01:59,640 --> 00:02:04,560
packaging and runtime are two different

00:02:02,399 --> 00:02:07,079
technologies that are covered by two

00:02:04,560 --> 00:02:09,000
different specifications one is the OCI

00:02:07,079 --> 00:02:11,489
stands for open container initiative

00:02:09,000 --> 00:02:13,799
image specification and the other one is

00:02:11,489 --> 00:02:15,359
the runtime specification

00:02:13,799 --> 00:02:18,120
they're kind of related but they are

00:02:15,359 --> 00:02:21,359
independent one it covered the format in

00:02:18,120 --> 00:02:22,980
which you package the container in fact

00:02:21,359 --> 00:02:25,109
containers you see the new girl loaded

00:02:22,980 --> 00:02:28,469
words because sometimes you use it to

00:02:25,109 --> 00:02:29,849
mean the packaging the up packet as you

00:02:28,469 --> 00:02:32,609
download it from the docker hub and

00:02:29,849 --> 00:02:34,769
sometime you need you you use it to say

00:02:32,609 --> 00:02:35,909
I'm running this container and then

00:02:34,769 --> 00:02:37,590
you're talking about the runtime

00:02:35,909 --> 00:02:38,849
environment which are actually two

00:02:37,590 --> 00:02:40,169
completely different things

00:02:38,849 --> 00:02:44,519
two completely different set of

00:02:40,169 --> 00:02:46,919
technologies now in an example workflow

00:02:44,519 --> 00:02:48,450
you have you used docker and you fetch a

00:02:46,919 --> 00:02:50,310
container from the docker registry at

00:02:48,450 --> 00:02:52,349
this point we are talking about the

00:02:50,310 --> 00:02:54,510
image format specification so you are

00:02:52,349 --> 00:02:57,599
fetching a tarball with a binary more

00:02:54,510 --> 00:03:00,209
than one inside right in a manifest file

00:02:57,599 --> 00:03:02,489
and then it gets installed on your local

00:03:00,209 --> 00:03:03,750
machine again this is about packaging

00:03:02,489 --> 00:03:06,120
the format in which you're downloading

00:03:03,750 --> 00:03:07,859
it and untiring it you know and then

00:03:06,120 --> 00:03:11,310
laying it out on the file system on your

00:03:07,859 --> 00:03:14,030
host and then once it's installed then

00:03:11,310 --> 00:03:17,400
you enter the problem of running it

00:03:14,030 --> 00:03:21,150
specifically usually is run using Linux

00:03:17,400 --> 00:03:24,409
namespaces so I'll gonna try in this

00:03:21,150 --> 00:03:26,970
talk to refer at the packaging as

00:03:24,409 --> 00:03:28,650
separately from the runtime and maybe no

00:03:26,970 --> 00:03:29,939
user work container that's confusing but

00:03:28,650 --> 00:03:31,590
it's very different difficult because

00:03:29,939 --> 00:03:37,439
continuous that's a nice world that's a

00:03:31,590 --> 00:03:40,129
nice ring to it so the the docker the

00:03:37,439 --> 00:03:42,030
docker binary I mean itself had been

00:03:40,129 --> 00:03:44,879
disaggregated in a number of smaller

00:03:42,030 --> 00:03:48,720
binaries and now the architecture of the

00:03:44,879 --> 00:03:51,090
project matches the specifications so

00:03:48,720 --> 00:03:53,250
you have container D which is the daemon

00:03:51,090 --> 00:03:55,139
that basically deal with the packaging

00:03:53,250 --> 00:03:56,849
downloading the packets from the hub and

00:03:55,139 --> 00:03:59,430
installing it on your local file system

00:03:56,849 --> 00:04:00,780
and then there is a separate application

00:03:59,430 --> 00:04:03,209
which is called a separate binary in

00:04:00,780 --> 00:04:05,699
fact separate project on on github which

00:04:03,209 --> 00:04:10,049
is called run C which is a default way

00:04:05,699 --> 00:04:11,609
of running your application as a matter

00:04:10,049 --> 00:04:14,129
of fact containers these pawns

00:04:11,609 --> 00:04:17,190
you know fork and exec run C when is a

00:04:14,129 --> 00:04:19,739
time of running your application and run

00:04:17,190 --> 00:04:21,329
C uses Linux namespaces but is one of

00:04:19,739 --> 00:04:25,529
the impossible implementations there are

00:04:21,329 --> 00:04:26,190
alternatives so what's it what's good

00:04:25,529 --> 00:04:28,260
and what's bad

00:04:26,190 --> 00:04:31,410
containers you know packaging around

00:04:28,260 --> 00:04:34,680
time so the packaging I think is it's

00:04:31,410 --> 00:04:36,780
fantastic and docker comes with very

00:04:34,680 --> 00:04:38,910
powerful tool to create these packages

00:04:36,780 --> 00:04:41,730
as well as they help to distribute them

00:04:38,910 --> 00:04:44,010
there are very few downside with using

00:04:41,730 --> 00:04:46,860
this packaging format even in embed that

00:04:44,010 --> 00:04:49,590
is a great way to share the product of

00:04:46,860 --> 00:04:52,890
your teams between them or just deploy

00:04:49,590 --> 00:04:55,320
them on your target the problem is with

00:04:52,890 --> 00:04:58,140
the runtime environment so Linux these

00:04:55,320 --> 00:05:02,280
pieces are ok for some use cases but not

00:04:58,140 --> 00:05:04,320
for all why well because Lino's

00:05:02,280 --> 00:05:07,560
namespaces are based on on a single

00:05:04,320 --> 00:05:09,930
kernel instance on top of which all the

00:05:07,560 --> 00:05:13,380
application run using separate again

00:05:09,930 --> 00:05:15,270
namespaces but however the Cisco

00:05:13,380 --> 00:05:18,480
interface exposed by the kernel to the

00:05:15,270 --> 00:05:20,220
application it's quite large and it's

00:05:18,480 --> 00:05:22,470
kind of difficult to secure so this

00:05:20,220 --> 00:05:23,970
calculation is is a bit old and it's

00:05:22,470 --> 00:05:26,250
very difficult actually to find to find

00:05:23,970 --> 00:05:28,230
out the precise number of privilege

00:05:26,250 --> 00:05:30,450
escalation vulnerability but the last

00:05:28,230 --> 00:05:33,960
time somebody counted they count about

00:05:30,450 --> 00:05:36,420
three for a billing us release now this

00:05:33,960 --> 00:05:38,070
is it's not because there is a problem

00:05:36,420 --> 00:05:40,170
in the process or there is a problem

00:05:38,070 --> 00:05:42,420
with the people actually I mean I think

00:05:40,170 --> 00:05:44,040
we are a civilian community we are doing

00:05:42,420 --> 00:05:46,140
an excellent job you know in making

00:05:44,040 --> 00:05:48,050
releases compared to other projects in

00:05:46,140 --> 00:05:51,150
such as the interface is so large that

00:05:48,050 --> 00:05:53,220
is extremely difficult to make it back

00:05:51,150 --> 00:05:54,030
free write more more lines of code means

00:05:53,220 --> 00:05:55,440
more bugs

00:05:54,030 --> 00:05:58,890
some of these bugs are going to be

00:05:55,440 --> 00:06:00,570
privilege escalations so what happens is

00:05:58,890 --> 00:06:02,910
if you by mistake

00:06:00,570 --> 00:06:05,970
for any reason because the application

00:06:02,910 --> 00:06:07,710
was provided by a third party if you

00:06:05,970 --> 00:06:10,380
deploy a malicious application on your

00:06:07,710 --> 00:06:12,630
born your target port then it's

00:06:10,380 --> 00:06:15,030
relatively easy for this application to

00:06:12,630 --> 00:06:16,620
find one of these vulnerability break

00:06:15,030 --> 00:06:19,380
into the current and from there

00:06:16,620 --> 00:06:23,010
basically take over the old thing which

00:06:19,380 --> 00:06:25,020
is definitely not what we want now this

00:06:23,010 --> 00:06:27,930
is a very well-known problem in the

00:06:25,020 --> 00:06:30,240
cloud as well and a lot of talks have

00:06:27,930 --> 00:06:32,310
been made on this topic a lot of

00:06:30,240 --> 00:06:34,470
recommendations have been made white

00:06:32,310 --> 00:06:36,270
papers have been written I particularly

00:06:34,470 --> 00:06:37,200
like this white paper is a couple of

00:06:36,270 --> 00:06:39,160
years old

00:06:37,200 --> 00:06:40,290
but it's very detailed very

00:06:39,160 --> 00:06:42,100
I think very well written is

00:06:40,290 --> 00:06:45,670
understanding and hardening Linux

00:06:42,100 --> 00:06:49,360
containers by NCC group is a long read

00:06:45,670 --> 00:06:52,630
so take your time they make many many

00:06:49,360 --> 00:06:55,180
recommendations including running

00:06:52,630 --> 00:06:57,880
containers you know unprivileged using

00:06:55,180 --> 00:07:00,280
SC Linux building custom kernel binaries

00:06:57,880 --> 00:07:02,410
as small as possible applying Diskin

00:07:00,280 --> 00:07:04,840
storage limits using C groups

00:07:02,410 --> 00:07:08,110
dropping capabilities using gr security

00:07:04,840 --> 00:07:10,150
patches using sacrum and doing a lot of

00:07:08,110 --> 00:07:13,600
monitoring still and using

00:07:10,150 --> 00:07:16,900
virtualization when possible so the

00:07:13,600 --> 00:07:19,570
bottom line is it is actually possible

00:07:16,900 --> 00:07:21,700
to secure lineage namespaces it's just

00:07:19,570 --> 00:07:23,440
that it's very very difficult and it

00:07:21,700 --> 00:07:25,780
requires the users of technology such as

00:07:23,440 --> 00:07:28,390
a saline access a comp they are not easy

00:07:25,780 --> 00:07:30,310
to use and often require the know

00:07:28,390 --> 00:07:34,120
detailed knowledge of what is running

00:07:30,310 --> 00:07:37,330
inside your your container your Linux

00:07:34,120 --> 00:07:39,790
namespace well monitoring is always a

00:07:37,330 --> 00:07:41,710
good thing and still at the end of the

00:07:39,790 --> 00:07:45,100
day butyl is asian hardware

00:07:41,710 --> 00:07:46,600
virtualization is still recommended so

00:07:45,100 --> 00:07:48,940
this is just a simple test I'd run

00:07:46,600 --> 00:07:51,550
actually last week if you type the doora

00:07:48,940 --> 00:07:55,570
out to disable three atop the top for

00:07:51,550 --> 00:08:00,160
auto completion is a silly knocks you

00:07:55,570 --> 00:08:02,380
can try for fun so what's the solution

00:08:00,160 --> 00:08:03,700
in the cloud because I mean we are

00:08:02,380 --> 00:08:05,260
talking about embedded here but

00:08:03,700 --> 00:08:06,850
containers you know are coming from the

00:08:05,260 --> 00:08:09,610
cloud and they're been dealing with this

00:08:06,850 --> 00:08:11,580
for a while now right so what people do

00:08:09,610 --> 00:08:14,140
in the cloud is they basically

00:08:11,580 --> 00:08:16,990
instantiate a different virtual machine

00:08:14,140 --> 00:08:19,720
for each owner so each team got his own

00:08:16,990 --> 00:08:21,520
or each person each engineer this way

00:08:19,720 --> 00:08:25,120
the virtual machine is still the one

00:08:21,520 --> 00:08:26,560
that enforces the security so VMs are

00:08:25,120 --> 00:08:29,080
still used for security and isolation

00:08:26,560 --> 00:08:30,820
and Linux namespaces are only used for

00:08:29,080 --> 00:08:33,099
convenience to run your app but they are

00:08:30,820 --> 00:08:35,849
not really in charge of you know

00:08:33,099 --> 00:08:39,700
multi-tenancy or separating

00:08:35,849 --> 00:08:44,860
responsibilities isolating false and

00:08:39,700 --> 00:08:46,780
malicious applications so what does it

00:08:44,860 --> 00:08:49,900
mean for our and very embedded use case

00:08:46,780 --> 00:08:51,310
right it means well first conclusion is

00:08:49,900 --> 00:08:54,639
multi tendencies really

00:08:51,310 --> 00:08:56,889
recommended people in the cloud don't do

00:08:54,639 --> 00:09:01,839
it and we shouldn't do it on our you

00:08:56,889 --> 00:09:03,759
know small devices either then this is

00:09:01,839 --> 00:09:05,259
not such a terrible limitation because I

00:09:03,759 --> 00:09:07,899
guess in embed that is not so common

00:09:05,259 --> 00:09:10,569
that you get third-party application to

00:09:07,899 --> 00:09:13,029
run on your board can happen but is not

00:09:10,569 --> 00:09:15,370
as common what's really bad so is the

00:09:13,029 --> 00:09:17,290
next point which is miksa criticality

00:09:15,370 --> 00:09:19,779
workloads then does not support it

00:09:17,290 --> 00:09:21,100
because if you cannot trust if you

00:09:19,779 --> 00:09:22,689
cannot trust the enforcement the

00:09:21,100 --> 00:09:25,540
isolation enforcement then you cannot

00:09:22,689 --> 00:09:27,189
really run using Linux namespaces

00:09:25,540 --> 00:09:29,079
applications that are that have

00:09:27,189 --> 00:09:29,920
different criticality levels let me

00:09:29,079 --> 00:09:32,970
explain what I mean

00:09:29,920 --> 00:09:36,249
very often in embedded or IOT or

00:09:32,970 --> 00:09:38,769
automotive transportation industries you

00:09:36,249 --> 00:09:40,600
have a very critical application and the

00:09:38,769 --> 00:09:43,059
far far less critical application

00:09:40,600 --> 00:09:46,089
running on the same board I can make a

00:09:43,059 --> 00:09:48,759
lot of examples one example is the

00:09:46,089 --> 00:09:50,559
infotainment system on a car there gonna

00:09:48,759 --> 00:09:52,660
be something that has access to the

00:09:50,559 --> 00:09:54,999
canvas and then the UI

00:09:52,660 --> 00:09:57,160
okay let's suppose it's all info team

00:09:54,999 --> 00:09:59,350
the canvas is where the brakes ignition

00:09:57,160 --> 00:10:00,790
everything is connected you really don't

00:09:59,350 --> 00:10:02,319
want to mess with it right and the

00:10:00,790 --> 00:10:04,240
infotainment system is really Android

00:10:02,319 --> 00:10:07,480
usually write something based on Android

00:10:04,240 --> 00:10:09,639
pretty large prone to crashing what if

00:10:07,480 --> 00:10:11,559
it takes down the whole system including

00:10:09,639 --> 00:10:14,860
what has access to the canvas what if he

00:10:11,559 --> 00:10:17,079
breaks into whatever is your application

00:10:14,860 --> 00:10:18,910
that has access to the canvas which this

00:10:17,079 --> 00:10:22,480
is what happened in 2015 was a famous

00:10:18,910 --> 00:10:24,279
Jeep kind of disaster where two occurs

00:10:22,480 --> 00:10:26,170
managed to break into a Jeep back or

00:10:24,279 --> 00:10:28,059
while running on a highway using the

00:10:26,170 --> 00:10:29,559
internet connecting to you connect this

00:10:28,059 --> 00:10:31,930
was the infotainment systems and they

00:10:29,559 --> 00:10:34,120
broke from there into another nearby

00:10:31,930 --> 00:10:36,160
firmware from which they could issue

00:10:34,120 --> 00:10:39,189
commands on the canvas and takes down

00:10:36,160 --> 00:10:41,399
the whole thing okay there are a lot of

00:10:39,189 --> 00:10:45,129
other examples even in the infotainment

00:10:41,399 --> 00:10:46,990
system again let's remove canvas which

00:10:45,129 --> 00:10:47,800
is really not a good idea to expose it

00:10:46,990 --> 00:10:50,709
to infotainment

00:10:47,800 --> 00:10:53,230
but let's talk about a simpler like a

00:10:50,709 --> 00:10:55,209
less less critical when you're backing

00:10:53,230 --> 00:10:57,459
off on a very corner nowadays you have

00:10:55,209 --> 00:11:00,429
the rear view camera nicely display on

00:10:57,459 --> 00:11:02,860
your you know display what if you

00:11:00,429 --> 00:11:04,120
crashes is not good right because it

00:11:02,860 --> 00:11:04,630
actually happened on a ball will be a

00:11:04,120 --> 00:11:07,570
call I think

00:11:04,630 --> 00:11:09,520
one year and a half ago he crashes is it

00:11:07,570 --> 00:11:11,140
the rear view camera crash the drive

00:11:09,520 --> 00:11:12,220
when you were backing off and the guy

00:11:11,140 --> 00:11:15,730
ran into a pole

00:11:12,220 --> 00:11:17,410
it could have run into somebody right so

00:11:15,730 --> 00:11:19,810
this is not just critical its life

00:11:17,410 --> 00:11:22,900
critical okay and this is just a stupid

00:11:19,810 --> 00:11:25,090
rear view camera okay so you don't want

00:11:22,900 --> 00:11:26,740
the Android complex Android system

00:11:25,090 --> 00:11:28,960
that's running your application may be

00:11:26,740 --> 00:11:31,210
uploaded from your phone being able to

00:11:28,960 --> 00:11:34,470
crash the rear view camera while you're

00:11:31,210 --> 00:11:37,810
backing off now stop talking about

00:11:34,470 --> 00:11:40,630
infotainment system on on cars but like

00:11:37,810 --> 00:11:42,250
another example is is a flying drone so

00:11:40,630 --> 00:11:44,890
now Anna Frye I want a flying drone you

00:11:42,250 --> 00:11:47,050
usually have two pieces nowadays one

00:11:44,890 --> 00:11:48,790
component is the autopilot which is

00:11:47,050 --> 00:11:51,310
usually a real-time operating system is

00:11:48,790 --> 00:11:53,920
really small tightly written few bugs

00:11:51,310 --> 00:11:56,950
and then alongside you have another

00:11:53,920 --> 00:11:59,860
component which compress and stream the

00:11:56,950 --> 00:12:01,870
camera input back to the user so that

00:11:59,860 --> 00:12:05,400
the user can see on his device what the

00:12:01,870 --> 00:12:08,800
cables drone is seeing right now if the

00:12:05,400 --> 00:12:11,440
if the input camera software you know

00:12:08,800 --> 00:12:13,270
crashes okay the guy got a still image

00:12:11,440 --> 00:12:15,580
but it can still land the drone safely

00:12:13,270 --> 00:12:17,590
if they'll tow pilot software you know

00:12:15,580 --> 00:12:19,450
get compromised somehow it doesn't even

00:12:17,590 --> 00:12:21,130
get just doesn't get scheduled for a

00:12:19,450 --> 00:12:23,170
couple seconds so real-time requirements

00:12:21,130 --> 00:12:25,000
are not met the drone can heat them to

00:12:23,170 --> 00:12:28,090
something could heat into somebody and

00:12:25,000 --> 00:12:29,950
so on and so forth so miksa criticality

00:12:28,090 --> 00:12:33,610
is something extremely common in

00:12:29,950 --> 00:12:36,190
embedded so something critical some time

00:12:33,610 --> 00:12:37,870
life critical is run alongside some

00:12:36,190 --> 00:12:40,510
things that is not critical far larger

00:12:37,870 --> 00:12:42,640
and trunk to crushing what you really

00:12:40,510 --> 00:12:44,710
want usually is to keep that you as

00:12:42,640 --> 00:12:46,600
separate as possible and the best way to

00:12:44,710 --> 00:12:49,120
do it short of having two different

00:12:46,600 --> 00:12:51,730
boards is to run them on a single board

00:12:49,120 --> 00:12:54,160
with with virtualization linens nice

00:12:51,730 --> 00:12:56,920
pieces really done so don't support that

00:12:54,160 --> 00:13:00,490
kind of even just resource limitations

00:12:56,920 --> 00:13:02,410
is hard on on with secret Pro related

00:13:00,490 --> 00:13:05,080
technology to really enforce memory

00:13:02,410 --> 00:13:09,970
users or CPU time users with very hard

00:13:05,080 --> 00:13:12,250
limits and also real time support so

00:13:09,970 --> 00:13:14,050
it's difficult to offer real time

00:13:12,250 --> 00:13:17,200
support to applications that use Linux

00:13:14,050 --> 00:13:18,370
namespaces I mean it is easier usually

00:13:17,200 --> 00:13:20,170
the Linux kernel that was

00:13:18,370 --> 00:13:21,730
and she could talk about real time

00:13:20,170 --> 00:13:23,079
Reno's criminals but that tend to be

00:13:21,730 --> 00:13:25,420
different releases different

00:13:23,079 --> 00:13:27,430
configurations from the user the very

00:13:25,420 --> 00:13:30,579
large kernel which you use for Linux

00:13:27,430 --> 00:13:32,350
namespaces applications certifications

00:13:30,579 --> 00:13:34,569
well sometimes you need to certify for

00:13:32,350 --> 00:13:36,699
safety for safety your software to run

00:13:34,569 --> 00:13:39,670
like on a car safety certifications are

00:13:36,699 --> 00:13:41,350
required and the smaller the better so

00:13:39,670 --> 00:13:43,240
again if you have a very large Linux

00:13:41,350 --> 00:13:47,709
kernel it's kind of very difficult to

00:13:43,240 --> 00:13:50,050
certify for that use case this is just

00:13:47,709 --> 00:13:51,670
an example I've Word which I'm going to

00:13:50,050 --> 00:13:53,649
repeat to you because I think it kind of

00:13:51,670 --> 00:13:57,490
explain also the situation very well

00:13:53,649 --> 00:13:59,259
so if your device the purpose of your

00:13:57,490 --> 00:14:01,720
device is handling pictures of cats

00:13:59,259 --> 00:14:04,809
right if it's a packed pictures of cats

00:14:01,720 --> 00:14:06,699
handling system then after all maybe

00:14:04,809 --> 00:14:09,579
Linux next page there are more than

00:14:06,699 --> 00:14:11,259
enough ok but maybe if it's a system

00:14:09,579 --> 00:14:13,660
that handles money right money

00:14:11,259 --> 00:14:16,300
transaction or has to do with liability

00:14:13,660 --> 00:14:18,339
or there is again is life critical then

00:14:16,300 --> 00:14:20,319
you have to think very hard about you

00:14:18,339 --> 00:14:25,120
know what to use in your runtime

00:14:20,319 --> 00:14:27,699
environment right so what is the

00:14:25,120 --> 00:14:30,160
consequence the consequence is this is a

00:14:27,699 --> 00:14:32,379
real life example the consequence is

00:14:30,160 --> 00:14:35,800
that people to run containers inside the

00:14:32,379 --> 00:14:39,370
end even in embedded so this a pump is

00:14:35,800 --> 00:14:41,110
an infotainment solution for cars so

00:14:39,370 --> 00:14:43,240
it's based on them they're running so

00:14:41,110 --> 00:14:45,279
this is hypervisor they're running atom

00:14:43,240 --> 00:14:48,160
0 that's the first day the first VNT

00:14:45,279 --> 00:14:51,490
puts a small as possible because usually

00:14:48,160 --> 00:14:54,459
more privileged than other VMs then you

00:14:51,490 --> 00:14:56,679
have a driver domain it's a domain with

00:14:54,459 --> 00:14:59,860
the graphic car designs so the sound

00:14:56,679 --> 00:15:02,649
card and input devices sign to it it's

00:14:59,860 --> 00:15:04,809
also in charge of the rendering but it

00:15:02,649 --> 00:15:06,939
shares these devices with other games as

00:15:04,809 --> 00:15:09,459
well specifically this one on the right

00:15:06,939 --> 00:15:12,699
is an out is a classic infotainment

00:15:09,459 --> 00:15:16,179
Android VM and it connects over parable

00:15:12,699 --> 00:15:19,240
tries driver to the driver domain VM to

00:15:16,179 --> 00:15:21,850
do the rendering and audio and stuff

00:15:19,240 --> 00:15:23,290
like that this one in the middle is the

00:15:21,850 --> 00:15:26,319
one that is interesting to us for this

00:15:23,290 --> 00:15:29,620
talk is a fusion VM is is a VM its

00:15:26,319 --> 00:15:32,320
purpose is to download at runtime in a

00:15:29,620 --> 00:15:34,390
way little telemetry plugins

00:15:32,320 --> 00:15:36,040
I'm calling them plugins but release our

00:15:34,390 --> 00:15:38,470
containers they have downloaded from the

00:15:36,040 --> 00:15:41,920
cloud and the runners container inside

00:15:38,470 --> 00:15:43,899
this VM so as you see the model is very

00:15:41,920 --> 00:15:47,380
similar to the model utilized in the

00:15:43,899 --> 00:15:49,600
cloud so you use VM for isolations and

00:15:47,380 --> 00:15:51,480
you know security and then you use

00:15:49,600 --> 00:15:56,230
container just you know as a way to run

00:15:51,480 --> 00:15:58,450
this application so I asked myself is

00:15:56,230 --> 00:16:01,769
real easy really this is the best way to

00:15:58,450 --> 00:16:04,750
do it I mean why can't we just use

00:16:01,769 --> 00:16:07,149
container for everything so maybe we can

00:16:04,750 --> 00:16:08,860
at least the packaging format so what

00:16:07,149 --> 00:16:11,290
I'm suggesting is view if you if we go

00:16:08,860 --> 00:16:13,300
back to the architecture of docker and

00:16:11,290 --> 00:16:15,310
the specification if you remember the

00:16:13,300 --> 00:16:17,320
image format specification and the

00:16:15,310 --> 00:16:18,880
runtime specification we can actually

00:16:17,320 --> 00:16:21,519
use the packaging for everything there

00:16:18,880 --> 00:16:24,220
is no downside to the packaging maybe we

00:16:21,519 --> 00:16:25,540
can just change the runtime so

00:16:24,220 --> 00:16:28,300
specifically there is a project called

00:16:25,540 --> 00:16:29,980
run V which M is not the one I'm not I'm

00:16:28,300 --> 00:16:31,839
gonna talk to you about in this talk but

00:16:29,980 --> 00:16:34,779
today is one of the other effort in this

00:16:31,839 --> 00:16:37,899
pace which is a runtime specification

00:16:34,779 --> 00:16:40,510
compatible so you could swap it with run

00:16:37,899 --> 00:16:43,000
see and use run B instead which use I'd

00:16:40,510 --> 00:16:47,079
providers including KB I'm qaq I'm going

00:16:43,000 --> 00:16:49,540
then to run your application so let's

00:16:47,079 --> 00:16:53,800
talk a little bit about butyl ization as

00:16:49,540 --> 00:16:56,230
a container runtime so visualization of

00:16:53,800 --> 00:16:57,970
a stronger form of security I can do

00:16:56,230 --> 00:17:00,279
harder partitioning so you can assign

00:16:57,970 --> 00:17:02,920
devices to different VM I could give

00:17:00,279 --> 00:17:04,449
direct access to order support

00:17:02,920 --> 00:17:05,169
multi-tenancy mix the criticality

00:17:04,449 --> 00:17:07,360
workloads

00:17:05,169 --> 00:17:10,059
it's componentization meaning that you

00:17:07,360 --> 00:17:12,189
can actually you know when you have a

00:17:10,059 --> 00:17:14,500
white board and you draw nice you know

00:17:12,189 --> 00:17:15,910
rectangles with what each team is

00:17:14,500 --> 00:17:17,169
supposed to be working on and then at

00:17:15,910 --> 00:17:18,579
the time of the point of software

00:17:17,169 --> 00:17:21,309
everything gets mashed together in a

00:17:18,579 --> 00:17:23,319
single system well that's not good right

00:17:21,309 --> 00:17:24,970
so componentization is idea that you can

00:17:23,319 --> 00:17:27,699
actually deploy them a separate unit

00:17:24,970 --> 00:17:31,360
which are strongly isolated and you can

00:17:27,699 --> 00:17:33,700
use the ends for that resilience and

00:17:31,360 --> 00:17:36,520
this is your point resilience is because

00:17:33,700 --> 00:17:38,820
if a VM crashes or for some reason is

00:17:36,520 --> 00:17:42,250
compromised or there is malware in it

00:17:38,820 --> 00:17:45,340
only one VM is compromised

00:17:42,250 --> 00:17:48,490
only one VM goes down nozzle system

00:17:45,340 --> 00:17:52,570
and real-time support it more often is

00:17:48,490 --> 00:17:55,180
easier now I'm talking about embedded AI

00:17:52,570 --> 00:17:57,190
providers so not cloud AI providers it's

00:17:55,180 --> 00:17:59,050
a pretty big difference so in embedded

00:17:57,190 --> 00:18:02,170
we have very different requirements in

00:17:59,050 --> 00:18:05,200
fact one requirement is we do want

00:18:02,170 --> 00:18:08,080
real-time support many of our many of

00:18:05,200 --> 00:18:10,950
our use cases have at least some sort of

00:18:08,080 --> 00:18:15,910
soft real-time requirements if not hard

00:18:10,950 --> 00:18:17,470
I don't know of any single I provides a

00:18:15,910 --> 00:18:19,450
deployment in the cloud that has any

00:18:17,470 --> 00:18:21,070
kind of real-time support because it's

00:18:19,450 --> 00:18:24,940
just not something that is very useful

00:18:21,070 --> 00:18:26,680
in cloud smart codebase again if you

00:18:24,940 --> 00:18:28,510
want to certify your system the is

00:18:26,680 --> 00:18:30,370
privileged execution level where you run

00:18:28,510 --> 00:18:33,610
the hypervisor the software other level

00:18:30,370 --> 00:18:37,330
you really need to certify if is large

00:18:33,610 --> 00:18:39,850
it becomes maybe not an impossible but

00:18:37,330 --> 00:18:42,250
close to impossible task so you want the

00:18:39,850 --> 00:18:44,590
codebase to be small short boot times

00:18:42,250 --> 00:18:46,570
you sit on a character now you turn up

00:18:44,590 --> 00:18:47,920
the infotainment system it has to be

00:18:46,570 --> 00:18:50,500
media you don't want to wait a couple of

00:18:47,920 --> 00:18:52,240
minutes right while on clouds usually

00:18:50,500 --> 00:18:55,300
you put the server once and then it is

00:18:52,240 --> 00:18:58,180
supposed to be 99.999 and nine and more

00:18:55,300 --> 00:19:01,510
nine available so who cares if it takes

00:18:58,180 --> 00:19:03,780
five minutes to boot so this is another

00:19:01,510 --> 00:19:06,760
example very different requirements

00:19:03,780 --> 00:19:11,320
device assignment driver domains and so

00:19:06,760 --> 00:19:12,910
in general if you see if you go back to

00:19:11,320 --> 00:19:14,530
this slide you not only need to assign

00:19:12,910 --> 00:19:16,570
devices to VM like in this case a

00:19:14,530 --> 00:19:18,610
graphic device has been assigned to this

00:19:16,570 --> 00:19:22,090
VM but you also need to share it from

00:19:18,610 --> 00:19:23,920
here to this other VM the reason why we

00:19:22,090 --> 00:19:27,970
want to do this is if for any reason

00:19:23,920 --> 00:19:29,620
this VM crash the graphic VM yes it's

00:19:27,970 --> 00:19:31,090
bad for an infotainment system to lose

00:19:29,620 --> 00:19:32,860
control of the display all right

00:19:31,090 --> 00:19:35,560
but at least you can still reboot you

00:19:32,860 --> 00:19:39,460
can still upgrade you can still you know

00:19:35,560 --> 00:19:41,320
at least crash get a crash information

00:19:39,460 --> 00:19:43,930
out of the system you can still do a lot

00:19:41,320 --> 00:19:46,030
of stuff you could theoretically reboot

00:19:43,930 --> 00:19:51,460
the graphic VM without rebooting the

00:19:46,030 --> 00:19:52,840
whole system yes and coprocessors

00:19:51,460 --> 00:19:54,790
virtualization is we are used to

00:19:52,840 --> 00:19:57,280
thinking of devices and utilization of

00:19:54,790 --> 00:19:59,030
devices but well you probably noticed in

00:19:57,280 --> 00:20:01,430
2018 the Bisons and

00:19:59,030 --> 00:20:03,890
are kind of merging right so you have

00:20:01,430 --> 00:20:05,540
more and more complex devices like GPUs

00:20:03,890 --> 00:20:08,270
that are really are cool processors and

00:20:05,540 --> 00:20:10,960
you are actually coprocessors so we need

00:20:08,270 --> 00:20:13,160
to be able to visualize those as well so

00:20:10,960 --> 00:20:15,620
I'm gonna be talking now a bit about

00:20:13,160 --> 00:20:17,840
xenon Arabic because well it does meet

00:20:15,620 --> 00:20:21,050
all this requirement set on x86 as well

00:20:17,840 --> 00:20:25,610
but on arm I guess for embedded is more

00:20:21,050 --> 00:20:28,550
relevant so Zen is a hypervisor with a

00:20:25,610 --> 00:20:30,470
microkernel design what does it mean is

00:20:28,550 --> 00:20:32,540
is the reason running on the highest

00:20:30,470 --> 00:20:34,970
privilege execution level and then a lot

00:20:32,540 --> 00:20:37,760
of things can be the privilege and run

00:20:34,970 --> 00:20:39,860
the privilege inside the VM so it has an

00:20:37,760 --> 00:20:41,570
extensive feature set so it comes with

00:20:39,860 --> 00:20:45,320
real-time support out of the box the

00:20:41,570 --> 00:20:48,140
Vice assignment on x86 are 32 and 64 a

00:20:45,320 --> 00:20:50,210
wide range of hardware being supported

00:20:48,140 --> 00:20:52,280
and a lot of people drivers PV drivers

00:20:50,210 --> 00:20:55,670
to share devices such as network block

00:20:52,280 --> 00:20:58,160
console graphic and so on so exams

00:20:55,670 --> 00:20:59,480
support K config so the is actually

00:20:58,160 --> 00:21:02,720
works the same way as the Linux kernel

00:20:59,480 --> 00:21:06,230
so you can cut you know the codebase

00:21:02,720 --> 00:21:08,540
quite significantly and it can go below

00:21:06,230 --> 00:21:11,870
60 60 thousand lines of code Forks and

00:21:08,540 --> 00:21:14,240
an arm easily what else it comes with

00:21:11,870 --> 00:21:16,490
real-time schedulers as well as spinning

00:21:14,240 --> 00:21:18,530
so if you care really about latency what

00:21:16,490 --> 00:21:22,670
you want to do is to fully dedicate a

00:21:18,530 --> 00:21:25,820
CPU core to one V CPU so get 100% of the

00:21:22,670 --> 00:21:28,250
time but you can also if you want run a

00:21:25,820 --> 00:21:30,620
scheduler with real-time properties and

00:21:28,250 --> 00:21:34,010
then come with two real-time scheduler

00:21:30,620 --> 00:21:36,020
so you can choose now Zarin arm

00:21:34,010 --> 00:21:38,180
I think is actually better than xenon

00:21:36,020 --> 00:21:40,280
x86 because it was you know kind of a

00:21:38,180 --> 00:21:43,280
clean design from just from this from

00:21:40,280 --> 00:21:45,200
scratch so it doesn't know him there is

00:21:43,280 --> 00:21:47,270
no emulation there is no qmo a smaller

00:21:45,200 --> 00:21:47,810
surface of attack and only one type of

00:21:47,270 --> 00:21:49,670
cast

00:21:47,810 --> 00:21:52,520
I've been saying this for years but now

00:21:49,670 --> 00:21:55,280
x86 finally I come kind of coming along

00:21:52,520 --> 00:21:57,320
so inside x86 guy on the right 66 side

00:21:55,280 --> 00:21:59,420
there is a new type of cast which is

00:21:57,320 --> 00:22:01,850
called pbh which is very similar to the

00:21:59,420 --> 00:22:04,550
type of cast on arm finally it doesn't

00:22:01,850 --> 00:22:06,860
require Khemu it only uses parameterize

00:22:04,550 --> 00:22:10,840
interfaces for i/o which are fast but at

00:22:06,860 --> 00:22:12,980
the same time uses harder brutalization

00:22:10,840 --> 00:22:15,350
something that we don't have yet

00:22:12,980 --> 00:22:18,050
but we really we really really be good

00:22:15,350 --> 00:22:20,480
to have is a cake config option to build

00:22:18,050 --> 00:22:22,690
then with only PVH support on x86 and

00:22:20,480 --> 00:22:24,800
that's that I know it will be coming

00:22:22,690 --> 00:22:26,090
security process so this is really

00:22:24,800 --> 00:22:29,060
important especially if you are a vendor

00:22:26,090 --> 00:22:30,460
of us of a system a system integrator so

00:22:29,060 --> 00:22:33,500
when you choose an open-source project

00:22:30,460 --> 00:22:35,990
really look at the security process and

00:22:33,500 --> 00:22:39,980
this is a guarantees in term of security

00:22:35,990 --> 00:22:43,070
CBE is handling that the process gives

00:22:39,980 --> 00:22:44,780
you some of the open source project out

00:22:43,070 --> 00:22:47,510
there they don't make any guarantees at

00:22:44,780 --> 00:22:50,420
all so then it's up to you as downstream

00:22:47,510 --> 00:22:54,250
user and service provider to provide

00:22:50,420 --> 00:22:54,250
security support on your own

00:22:54,290 --> 00:22:58,190
send that support the other security

00:22:56,780 --> 00:23:00,110
process you can check it out online

00:22:58,190 --> 00:23:01,520
there is a document clearly stated what

00:23:00,110 --> 00:23:03,620
happened when they're just q-tip owner

00:23:01,520 --> 00:23:05,750
ability and this supports pre disclosure

00:23:03,620 --> 00:23:08,120
so you can sign up and receive

00:23:05,750 --> 00:23:10,370
notification of security vulnerability

00:23:08,120 --> 00:23:14,360
before their public so that you can read

00:23:10,370 --> 00:23:16,100
your fix right yes okay we got a bit

00:23:14,360 --> 00:23:19,370
sidetracked here but does he run

00:23:16,100 --> 00:23:22,640
containers right this is your point yes

00:23:19,370 --> 00:23:25,010
it can run containers but what I'm

00:23:22,640 --> 00:23:27,950
talking about here is really not about I

00:23:25,010 --> 00:23:30,620
mean starting an Ubuntu VM installing

00:23:27,950 --> 00:23:32,930
doctor on the VM and then running the

00:23:30,620 --> 00:23:33,350
container there's not what I'm talking

00:23:32,930 --> 00:23:35,810
about

00:23:33,350 --> 00:23:38,870
so what we want to do is known on the

00:23:35,810 --> 00:23:41,300
host of our small IOT device do document

00:23:38,870 --> 00:23:44,510
and what happens is the application is

00:23:41,300 --> 00:23:46,670
run as a VM transparently and the way

00:23:44,510 --> 00:23:48,530
it's done is by basically adding a

00:23:46,670 --> 00:23:50,930
little Linux kernel as small as possible

00:23:48,530 --> 00:23:54,710
inside the VM just to run this

00:23:50,930 --> 00:23:56,810
application so that the overhead is

00:23:54,710 --> 00:23:58,160
quite small it's a small as as you can

00:23:56,810 --> 00:24:00,080
get and then you can mix and match

00:23:58,160 --> 00:24:02,420
container application with traditional

00:24:00,080 --> 00:24:06,440
application you can run qnx is one of

00:24:02,420 --> 00:24:08,510
the IBM alongside how do we do it okay

00:24:06,440 --> 00:24:12,110
this is the idea so you know sounds good

00:24:08,510 --> 00:24:14,660
on a slide but how does actually work so

00:24:12,110 --> 00:24:15,110
it can work in actually more than one

00:24:14,660 --> 00:24:17,480
way

00:24:15,110 --> 00:24:19,640
first of all let's remember right the

00:24:17,480 --> 00:24:22,040
packaging is actually pretty simple once

00:24:19,640 --> 00:24:24,920
is installed once you do doctor fetch

00:24:22,040 --> 00:24:26,600
basically you you get your container

00:24:24,920 --> 00:24:28,370
installed on your local machine

00:24:26,600 --> 00:24:32,090
what really is is just a filesystem

00:24:28,370 --> 00:24:34,880
bundle it just a root of s so converting

00:24:32,090 --> 00:24:38,390
a root of s into VM is actually really

00:24:34,880 --> 00:24:42,049
trivial so if you know beforehand how

00:24:38,390 --> 00:24:43,669
many application you want to run maybe

00:24:42,049 --> 00:24:45,230
you are dealing with a smaller UT device

00:24:43,669 --> 00:24:47,000
you only have three container

00:24:45,230 --> 00:24:51,559
application to run you might as well

00:24:47,000 --> 00:24:53,390
convert them by hand otherwise I mean

00:24:51,559 --> 00:24:55,220
otherwise you can do that dynamically

00:24:53,390 --> 00:24:57,530
there are a number of projects that

00:24:55,220 --> 00:25:01,190
allow you to do this transparently and

00:24:57,530 --> 00:25:02,780
dynamically at runtime the one I'm going

00:25:01,190 --> 00:25:05,690
to talk into you I'll be talking to you

00:25:02,780 --> 00:25:07,640
about is rocket and stage ones then I'm

00:25:05,690 --> 00:25:09,559
going to also mention another project

00:25:07,640 --> 00:25:11,960
called singularity just to say that the

00:25:09,559 --> 00:25:18,230
same ideas are going around in a lot of

00:25:11,960 --> 00:25:20,450
very different spaces in circular arc is

00:25:18,230 --> 00:25:23,000
a project for HPC high-performance

00:25:20,450 --> 00:25:25,400
computing have a similar issue they like

00:25:23,000 --> 00:25:27,350
containers for packaging zabi you know

00:25:25,400 --> 00:25:29,870
they have a multi-million dollar server

00:25:27,350 --> 00:25:31,610
under their feet they do really don't

00:25:29,870 --> 00:25:33,470
want to use containers to run I mean

00:25:31,610 --> 00:25:35,690
Linux namespaces to run the application

00:25:33,470 --> 00:25:38,240
because they're far better more powerful

00:25:35,690 --> 00:25:42,159
and more efficient api's so what they do

00:25:38,240 --> 00:25:45,380
is they use singularity which handles

00:25:42,159 --> 00:25:49,280
container as a package and then you can

00:25:45,380 --> 00:25:52,760
run this package as your native direct

00:25:49,280 --> 00:25:54,860
execution inside one HPC node so best

00:25:52,760 --> 00:25:57,620
performance and the best packaging

00:25:54,860 --> 00:26:01,340
format okay

00:25:57,620 --> 00:26:03,590
rocket so you might have heard the

00:26:01,340 --> 00:26:07,700
rocket rocket is a project by caress is

00:26:03,590 --> 00:26:09,500
an alternative to docker it's nice

00:26:07,700 --> 00:26:12,280
because it was designed from the start

00:26:09,500 --> 00:26:17,299
with the packaging versus runtime

00:26:12,280 --> 00:26:19,970
separation specifically the packaging is

00:26:17,299 --> 00:26:22,640
handled by a thing called stage 0 things

00:26:19,970 --> 00:26:25,850
are naming it tried to mimic real rocket

00:26:22,640 --> 00:26:28,039
ok so there are packages on Tobias a

00:26:25,850 --> 00:26:29,929
thing called rocket and it's called

00:26:28,039 --> 00:26:32,570
stage 0 but then the execution

00:26:29,929 --> 00:26:34,970
environment is created and managed by

00:26:32,570 --> 00:26:36,010
another component which is called stage

00:26:34,970 --> 00:26:38,470
00:26:36,010 --> 00:26:42,700
roughly these choose a map to container

00:26:38,470 --> 00:26:45,400
D and run see in the docker world so

00:26:42,700 --> 00:26:47,650
what I did is I wrote a stage one based

00:26:45,400 --> 00:26:50,950
on Zen so what you do is when you do

00:26:47,650 --> 00:26:53,260
rocket run it instantiate a new VM

00:26:50,950 --> 00:26:57,250
instead of a set of Linux namespaces but

00:26:53,260 --> 00:26:59,110
everything else is exactly the same yeah

00:26:57,250 --> 00:27:02,050
so how is it written it's actually

00:26:59,110 --> 00:27:04,930
pretty simple it just based on bash it

00:27:02,050 --> 00:27:07,930
invokes the Excel command to start yams

00:27:04,930 --> 00:27:11,250
is using nine PFS to share the file

00:27:07,930 --> 00:27:13,570
system of the application inside the VM

00:27:11,250 --> 00:27:15,120
there is a bit of Golan to handle

00:27:13,570 --> 00:27:19,330
networking

00:27:15,120 --> 00:27:22,450
speaking of networking now we're used to

00:27:19,330 --> 00:27:25,900
think we are used to thinking of VM as

00:27:22,450 --> 00:27:28,960
pretty large thing you know made to run

00:27:25,900 --> 00:27:32,860
Windows XP multiple windows XP on my PC

00:27:28,960 --> 00:27:34,900
right but the technology is really not

00:27:32,860 --> 00:27:39,940
it doesn't have to be that way right so

00:27:34,900 --> 00:27:42,280
if we know that we are running container

00:27:39,940 --> 00:27:45,190
applications we can take many many

00:27:42,280 --> 00:27:47,980
shortcuts for example instead of

00:27:45,190 --> 00:27:50,740
utilizing a network card as a network

00:27:47,980 --> 00:27:53,620
card we can virtualize directly as a

00:27:50,740 --> 00:27:56,230
POSIX API level because well all this

00:27:53,620 --> 00:27:57,490
application are Linux apps right so

00:27:56,230 --> 00:27:59,950
they're gonna to connect to the internet

00:27:57,490 --> 00:28:02,290
or going to make socket a cept list and

00:27:59,950 --> 00:28:03,820
bind connect receive match the send

00:28:02,290 --> 00:28:06,640
message and that's asking pretty much

00:28:03,820 --> 00:28:09,400
all the calls are gonna make so why

00:28:06,640 --> 00:28:12,880
don't we butyl eyes available it is

00:28:09,400 --> 00:28:14,740
possible and that was PP courses it

00:28:12,880 --> 00:28:16,720
could work with any Cisco's but is made

00:28:14,740 --> 00:28:18,250
specifically for the networking Cisco's

00:28:16,720 --> 00:28:21,760
I mean that's the initial set has been

00:28:18,250 --> 00:28:24,430
implemented so this way basically all

00:28:21,760 --> 00:28:27,220
the Cisco's goes to the gas kernel but

00:28:24,430 --> 00:28:31,330
if you get forwarded to the hosts and

00:28:27,220 --> 00:28:32,830
run on the host yeah this is actually

00:28:31,330 --> 00:28:35,980
how it is implemented so there is a

00:28:32,830 --> 00:28:37,840
front-end in Linux and this small set of

00:28:35,980 --> 00:28:40,960
Cisco's are sent to the host and

00:28:37,840 --> 00:28:43,840
executed on the Austin as a consequence

00:28:40,960 --> 00:28:46,120
when the VM open a port like for example

00:28:43,840 --> 00:28:49,160
I suppose you're running as a container

00:28:46,120 --> 00:28:50,990
and UNIX it opens port 80

00:28:49,160 --> 00:28:54,650
if you using P vehicles you can actually

00:28:50,990 --> 00:28:57,680
have nginx open port 80 on your hosts

00:28:54,650 --> 00:28:58,160
because well the request is sent to the

00:28:57,680 --> 00:29:02,630
host

00:28:58,160 --> 00:29:03,950
they asked executor requests the end so

00:29:02,630 --> 00:29:05,840
it's a great match for container

00:29:03,950 --> 00:29:08,390
especially you know rocket as a

00:29:05,840 --> 00:29:10,520
networking mode called host was that

00:29:08,390 --> 00:29:12,200
exactly what is supposed to happen

00:29:10,520 --> 00:29:14,900
so port open inside a container are

00:29:12,200 --> 00:29:17,750
supposed to be open on the host so you

00:29:14,900 --> 00:29:19,280
can use that for that right so I have

00:29:17,750 --> 00:29:23,180
only terminus I'm gonna go very quickly

00:29:19,280 --> 00:29:26,450
over this so meltdown is the worst of

00:29:23,180 --> 00:29:29,360
the vulnerabilities that were disclosed

00:29:26,450 --> 00:29:31,880
at the beginning of the year with

00:29:29,360 --> 00:29:35,390
meltdown an application can use this

00:29:31,880 --> 00:29:37,670
vulnerability to attack Linux with

00:29:35,390 --> 00:29:41,030
meltdown also a kernel or an application

00:29:37,670 --> 00:29:42,310
inside the VM can use meltdown to attack

00:29:41,030 --> 00:29:45,230
the hypervisor

00:29:42,310 --> 00:29:48,590
however kernels and hypervisors have

00:29:45,230 --> 00:29:50,390
been differently affected so Linux has

00:29:48,590 --> 00:29:54,380
been affected on x86 and arm and has

00:29:50,390 --> 00:29:56,090
been fixed great but most hypervisors

00:29:54,380 --> 00:29:59,330
actually have not been affected why

00:29:56,090 --> 00:30:01,940
because it requires it requires

00:29:59,330 --> 00:30:04,040
basically a shared address space not

00:30:01,940 --> 00:30:06,230
quite entirely sure but the quraan needs

00:30:04,040 --> 00:30:08,020
to be part of the address space even so

00:30:06,230 --> 00:30:11,540
not acceptable because it privileged

00:30:08,020 --> 00:30:14,210
almost hypervisors nowadays nested

00:30:11,540 --> 00:30:17,240
paging is used and so basically meltdown

00:30:14,210 --> 00:30:20,030
doesn't affect specifically cannon-armed

00:30:17,240 --> 00:30:22,790
has not been affected sign on x86 pv h

00:30:20,030 --> 00:30:25,450
and h vm has not been affected and pv is

00:30:22,790 --> 00:30:26,660
the only mode that has been affected

00:30:25,450 --> 00:30:30,110
yeah

00:30:26,660 --> 00:30:33,110
so I'm running some benchmarks and the

00:30:30,110 --> 00:30:34,790
results is so I'm not told telling you

00:30:33,110 --> 00:30:36,470
these to tell you all now running

00:30:34,790 --> 00:30:38,720
benchmark inside VM is faster than or

00:30:36,470 --> 00:30:41,210
native let's be clear I'm telling you

00:30:38,720 --> 00:30:43,700
this to say random benchmark in this

00:30:41,210 --> 00:30:47,420
case compiled bench inside the VM is so

00:30:43,700 --> 00:30:49,220
close to native that sometimes can be

00:30:47,420 --> 00:30:55,160
faster now especially with the

00:30:49,220 --> 00:30:57,620
mitigation to meltdown yes alright so

00:30:55,160 --> 00:31:00,470
now I have the conclusion is containers

00:30:57,620 --> 00:31:02,809
are a great packaging format I would

00:31:00,470 --> 00:31:04,279
recommend to use an across-the-board be

00:31:02,809 --> 00:31:07,429
careful about the runtime environment

00:31:04,279 --> 00:31:09,259
Linux namespaces are suitable for some

00:31:07,429 --> 00:31:11,899
use cases certainly pictures of cats

00:31:09,259 --> 00:31:13,789
maybe others but if you are dealing with

00:31:11,899 --> 00:31:18,019
life critical system you certainly want

00:31:13,789 --> 00:31:19,580
to look at something else like building

00:31:18,019 --> 00:31:21,620
this system is still not trivial so

00:31:19,580 --> 00:31:23,330
monitor you know Linux Foundation

00:31:21,620 --> 00:31:24,830
announcement things and project we're

00:31:23,330 --> 00:31:27,049
going to be probably an announcement in

00:31:24,830 --> 00:31:30,379
the next to three months about new

00:31:27,049 --> 00:31:32,179
project to help you build critic safety

00:31:30,379 --> 00:31:35,240
critical system more easily based on

00:31:32,179 --> 00:31:36,740
virtualization technologies now before I

00:31:35,240 --> 00:31:40,850
go to questions I want to show you a

00:31:36,740 --> 00:31:43,909
small quick demo so I'm going to SSH

00:31:40,850 --> 00:31:45,619
into the network work so we have a

00:31:43,909 --> 00:31:49,970
chance of making this happen so we have

00:31:45,619 --> 00:31:51,619
this is an armed 64 system okay I'll be

00:31:49,970 --> 00:31:54,740
honest this is really not an embedded

00:31:51,619 --> 00:31:57,889
system this is at under X kaboom server

00:31:54,740 --> 00:32:00,649
so if we look at how many no details I

00:31:57,889 --> 00:32:02,749
think it has 96 yeah there's not an

00:32:00,649 --> 00:32:06,320
embedded system but let's pretend is

00:32:02,749 --> 00:32:09,649
your you know small arm 64 board with a

00:32:06,320 --> 00:32:12,499
4 processor or something so what I want

00:32:09,649 --> 00:32:16,220
to show you is well that out transparent

00:32:12,499 --> 00:32:19,220
your processes so I'll you can use

00:32:16,220 --> 00:32:22,190
rocket fetch to fetch the latest nginx

00:32:19,220 --> 00:32:24,919
container application from the docker

00:32:22,190 --> 00:32:27,769
hub in secure option equal image is

00:32:24,919 --> 00:32:29,990
required because still there is no

00:32:27,769 --> 00:32:33,980
signing on these application packaging

00:32:29,990 --> 00:32:39,019
yet so and then we can use rocket to run

00:32:33,980 --> 00:32:41,149
also this application transparently now

00:32:39,019 --> 00:32:42,230
interestingly it's a bit slow it's a bit

00:32:41,149 --> 00:32:44,779
slow because I'm using the

00:32:42,230 --> 00:32:46,759
out-of-the-box golang provided with the

00:32:44,779 --> 00:32:49,340
latest Ubuntu LPS which is now almost

00:32:46,759 --> 00:32:51,169
two years old and it wasn't very very

00:32:49,340 --> 00:32:54,200
much optimized at that point yet but

00:32:51,169 --> 00:32:59,059
nowadays go long gone are 64 is actually

00:32:54,200 --> 00:33:00,590
far better so yes and I'm so yeah so

00:32:59,059 --> 00:33:03,259
this point is going to take a few

00:33:00,590 --> 00:33:08,950
seconds then has not even being invoked

00:33:03,259 --> 00:33:12,559
yet this is all going still go long

00:33:08,950 --> 00:33:14,940
and now is then

00:33:12,559 --> 00:33:18,320
right engine X is running and is

00:33:14,940 --> 00:33:22,549
listening on port 80 on port 80 now

00:33:18,320 --> 00:33:25,799
I'm gonna connect to the aust

00:33:22,549 --> 00:33:28,919
oops wrong command you can see if there

00:33:25,799 --> 00:33:33,470
is a VM running you can also see with

00:33:28,919 --> 00:33:35,970
rocket that there is a container running

00:33:33,470 --> 00:33:37,559
you see both abstraction

00:33:35,970 --> 00:33:39,450
they're completely seamless and they

00:33:37,559 --> 00:33:41,190
work together as a matter of fact you

00:33:39,450 --> 00:33:43,200
can run some containers using Linux

00:33:41,190 --> 00:33:44,999
namespaces alongside would be fine you

00:33:43,200 --> 00:33:48,330
can also run some vm's along silence

00:33:44,999 --> 00:33:50,399
will be okay now what is cool I think I

00:33:48,330 --> 00:33:53,460
hope you find it cool if I do this will

00:33:50,399 --> 00:33:54,599
what do you think will happen so if

00:33:53,460 --> 00:33:56,909
you're familiar with our visor

00:33:54,599 --> 00:33:59,190
technologies this should not work

00:33:56,909 --> 00:34:01,739
because usually you have a bridge and

00:33:59,190 --> 00:34:04,889
the VM has its own IP so if you do

00:34:01,739 --> 00:34:06,299
double you get local lost you are pretty

00:34:04,889 --> 00:34:11,190
certain you're not going to connect to

00:34:06,299 --> 00:34:12,619
the WebM but in this case it came down

00:34:11,190 --> 00:34:16,980
pretty quickly

00:34:12,619 --> 00:34:19,649
welcome to onznx why did it work because

00:34:16,980 --> 00:34:21,990
I'm using Pittacus so it's port 80

00:34:19,649 --> 00:34:24,839
inside the VM has actually be all opened

00:34:21,990 --> 00:34:28,500
on the Aust I can show it to you next at

00:34:24,839 --> 00:34:33,659
minus something and give you that port

00:34:28,500 --> 00:34:36,480
80 is here so again VMs you should think

00:34:33,659 --> 00:34:39,389
of them as a secure isolation technology

00:34:36,480 --> 00:34:41,760
not at the old way to run Windows XP

00:34:39,389 --> 00:34:44,159
multiple copies of them on your PC right

00:34:41,760 --> 00:34:59,609
that's I guess if this is a one take

00:34:44,159 --> 00:35:01,950
away right questions I I think so what I

00:34:59,609 --> 00:35:04,589
want to do is to port stage one then to

00:35:01,950 --> 00:35:05,849
the OCIO runtime interface which should

00:35:04,589 --> 00:35:07,890
be actually pretty simple because

00:35:05,849 --> 00:35:10,079
they're not identical but they're

00:35:07,890 --> 00:35:11,990
similar so yeah that's what I intend to

00:35:10,079 --> 00:35:15,589
do yeah

00:35:11,990 --> 00:35:15,589
other questions

00:35:15,730 --> 00:35:29,440
a minimal internal like ram utilization

00:35:26,980 --> 00:35:38,500
or number of physical CPU minimal in

00:35:29,440 --> 00:35:40,090
what so I'm so there is this potential

00:35:38,500 --> 00:35:43,690
new project was telling you about to run

00:35:40,090 --> 00:35:47,380
safe container virtualization might be

00:35:43,690 --> 00:35:49,090
announced in the short short future we

00:35:47,380 --> 00:36:02,619
are considering to support the pine 64

00:35:49,090 --> 00:36:04,330
so pine 64 is raspberry supply class so

00:36:02,619 --> 00:36:05,920
the prong with the Raspberry Pi 0 is

00:36:04,330 --> 00:36:08,950
that unfortunately is not kind of

00:36:05,920 --> 00:36:11,380
standard compliant so if you give me an

00:36:08,950 --> 00:36:13,450
example of an order on 32 board which is

00:36:11,380 --> 00:36:16,150
exactly like the Raspberry Pi same price

00:36:13,450 --> 00:36:18,280
but it uses regular standard arm

00:36:16,150 --> 00:36:20,170
interrupt controller then I will be

00:36:18,280 --> 00:36:22,810
replying yes I think you could probably

00:36:20,170 --> 00:36:24,220
use it for that unfortunately result pi

00:36:22,810 --> 00:36:25,990
went the wrong way and use a

00:36:24,220 --> 00:36:27,970
non-standard interrupt controller which

00:36:25,990 --> 00:36:30,940
is not design support virtualization and

00:36:27,970 --> 00:36:34,200
then you cannot run Xen unit or any

00:36:30,940 --> 00:36:37,480
other I provider of following I am aware

00:36:34,200 --> 00:36:39,970
right so I think if you go so there is a

00:36:37,480 --> 00:36:41,650
number of our muscle tissue boards which

00:36:39,970 --> 00:36:43,270
you could be used and I think it's more

00:36:41,650 --> 00:36:46,030
than processor I will look at the RAM

00:36:43,270 --> 00:36:49,000
constraints so I will I think you really

00:36:46,030 --> 00:36:51,220
need at least I think one gigabyte I

00:36:49,000 --> 00:36:55,380
think the CPU power is more than enough

00:36:51,220 --> 00:36:55,380
on the cortex a15 for example

00:37:03,110 --> 00:37:08,690
yeah or contact me I think yes my email

00:37:07,310 --> 00:37:10,850
isn't there so if you have any questions

00:37:08,690 --> 00:37:13,120
or you want to have some pointers send

00:37:10,850 --> 00:37:13,120
me an email

00:37:17,110 --> 00:37:22,010
they are already actually I was late I

00:37:19,730 --> 00:37:24,500
admit but I uploaded them right before

00:37:22,010 --> 00:37:26,360
entering this room I'm going to also

00:37:24,500 --> 00:37:37,160
post them on Twitter shortly after so

00:37:26,360 --> 00:37:39,230
yeah more questions now in the case

00:37:37,160 --> 00:37:40,150
thank you for listening and have a good

00:37:39,230 --> 00:37:43,249
rest of the day

00:37:40,150 --> 00:37:43,249

YouTube URL: https://www.youtube.com/watch?v=GF07a5zivZI


