Title: Implementing State-of-the-Art U-Boot Port, 2018 Edition - Marek Vasut, Self-employed
Publication date: 2018-03-14
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	Implementing State-of-the-Art U-Boot Port, 2018 Edition - Marek Vasut, Self-employed

This presentation is a practical guide to implementing U-Boot bootloader port to a new system from scratch. At the beginning, two main pillars of contemporary U-Boot, device tree (DT) support and driver model (DM), are explained. This is followed by an in-depth look at the crucial subsystems, clock, pinmux, serial, block and a few other commonly used ones. Finally, systems with limited resources and multi-stage booting is discussed. The talk includes examples and experiences from platforms recently added to mainline U-Boot. 

About Marek Vasut
I have been contractor for multiple companies for many years. My primary responsibility is designing and implementing customer specific functionality. One important aspect of my work is leveraging the benefits of working inside the mainline Linux, U-Boot and OE / Yocto Project, explaining our customers the benefits of pushing the newly produced code back into mainline and effectively doing the contributions. I am therefore heavily involved with both mainline U-Boot and Linux kernel, be it my role as R-Car, SoCFPGA or USB maintainer for U-Boot, MTD co-maintainer in Linux or others. My speaking experience includes giving talks at ELCE, LinuxCon Japan, EmbeddedWorld and various smaller events across Europe.
Captions: 
	00:00:00,030 --> 00:00:03,330
my name is Maura crusher and today I'm

00:00:01,650 --> 00:00:05,879
gonna talk about doing the u-boot

00:00:03,330 --> 00:00:11,309
bootloader report right with all the

00:00:05,879 --> 00:00:13,530
latest features just briefly about me I

00:00:11,309 --> 00:00:15,990
work as a software engineer contractor

00:00:13,530 --> 00:00:19,590
I'm one of the maintainer Xindi wood

00:00:15,990 --> 00:00:24,029
project I in that project I work on the

00:00:19,590 --> 00:00:30,810
USB a couple of supports this in telic

00:00:24,029 --> 00:00:33,540
scale the renesis our car and altar of

00:00:30,810 --> 00:00:35,399
tsuki fpga that's what I maintain I also

00:00:33,540 --> 00:00:37,590
do some sort of work on the Linux kernel

00:00:35,399 --> 00:00:40,170
and open and beat it and I'm an FPGA are

00:00:37,590 --> 00:00:42,120
based so in case you have interest in

00:00:40,170 --> 00:00:45,149
any of these topics please talk to me

00:00:42,120 --> 00:00:48,629
after this and tomorrow I'm happy to

00:00:45,149 --> 00:00:50,340
discuss that stuff now I decided to

00:00:48,629 --> 00:00:52,739
split this talk into multiple sections

00:00:50,340 --> 00:00:54,480
first of all if you have no idea what

00:00:52,739 --> 00:00:58,500
you Buddhist I would like to show you

00:00:54,480 --> 00:01:00,120
what that is and what is capable of once

00:00:58,500 --> 00:01:03,149
we get through that I would like to do a

00:01:00,120 --> 00:01:06,659
brief news flash just to sync people up

00:01:03,149 --> 00:01:08,250
who did you with ports before you tell

00:01:06,659 --> 00:01:10,560
them like what's new and so on very

00:01:08,250 --> 00:01:13,110
quickly and once we get through that

00:01:10,560 --> 00:01:16,140
I'll go through basics like building new

00:01:13,110 --> 00:01:19,740
boot from source the structure of the

00:01:16,140 --> 00:01:22,590
u-boot directory tree this sort of stuff

00:01:19,740 --> 00:01:24,659
so the basic things then i'll I would

00:01:22,590 --> 00:01:27,360
like to look into device 3 control and

00:01:24,659 --> 00:01:30,659
you would driver model and once we go

00:01:27,360 --> 00:01:34,380
through these fundamental things I will

00:01:30,659 --> 00:01:35,490
go into doing you with ports because you

00:01:34,380 --> 00:01:39,659
will have all the knowledge at that

00:01:35,490 --> 00:01:42,570
point to actually do a basic Ubud port

00:01:39,659 --> 00:01:44,490
now since enabling all that stuff will

00:01:42,570 --> 00:01:47,430
probably make you but grow up quite a

00:01:44,490 --> 00:01:49,649
bit we'll talk about shrinking you boot

00:01:47,430 --> 00:01:53,549
size at the end so that's that's what

00:01:49,649 --> 00:01:57,329
this talk is gonna be about so first of

00:01:53,549 --> 00:02:00,270
all you boot loader what is it well so a

00:01:57,329 --> 00:02:01,860
boot loaders piece of code which is

00:02:00,270 --> 00:02:04,170
running super early on on your platform

00:02:01,860 --> 00:02:08,099
and it's responsible for initializing

00:02:04,170 --> 00:02:11,190
the platform only enough so it is

00:02:08,099 --> 00:02:12,630
capable of loading the next stage which

00:02:11,190 --> 00:02:14,760
in case of a

00:02:12,630 --> 00:02:18,120
there is usually a operating system

00:02:14,760 --> 00:02:20,370
kernel into memory and starting that

00:02:18,120 --> 00:02:22,980
next stage and this is what you boot can

00:02:20,370 --> 00:02:24,990
do it can behave as a bootloader but it

00:02:22,980 --> 00:02:26,670
can also behave as much more it can

00:02:24,990 --> 00:02:29,730
behave as a boot monitor that means it

00:02:26,670 --> 00:02:33,120
gives you a shell and it can behave as a

00:02:29,730 --> 00:02:36,060
debug tool so you can fiddle around with

00:02:33,120 --> 00:02:39,930
memory you can operate buses you can

00:02:36,060 --> 00:02:43,800
access USB I square CSPI storage sat I

00:02:39,930 --> 00:02:46,110
know this sort of stuff all that you can

00:02:43,800 --> 00:02:49,010
do with you boot so it's a really

00:02:46,110 --> 00:02:51,060
powerful tool now here is an example of

00:02:49,010 --> 00:02:53,850
slightly older version of you boot

00:02:51,060 --> 00:02:56,640
actually this is two releases old but

00:02:53,850 --> 00:02:58,440
this sort of print out you get when you

00:02:56,640 --> 00:03:01,230
start the system which has you boot on

00:02:58,440 --> 00:03:05,010
it doesn't really change what you can

00:03:01,230 --> 00:03:08,220
see here is you boot 2017 point 11

00:03:05,010 --> 00:03:12,780
actually a new version 2018 point zero 3

00:03:08,220 --> 00:03:15,390
was released yesterday with again some

00:03:12,780 --> 00:03:19,520
improvements now what else you see in

00:03:15,390 --> 00:03:22,500
this printout is CPU type of the board

00:03:19,520 --> 00:03:23,730
some sort of RAM some sort of flash this

00:03:22,500 --> 00:03:27,240
sort of stuff

00:03:23,730 --> 00:03:29,940
we have also Ethernet and ultimately we

00:03:27,240 --> 00:03:32,070
reach the boot monitor prompt where I'm

00:03:29,940 --> 00:03:33,990
dumping memory so this is just an

00:03:32,070 --> 00:03:36,060
example of showing you that you can do a

00:03:33,990 --> 00:03:37,680
lot of stuff with you but and how it

00:03:36,060 --> 00:03:40,320
looks when you power up a system which

00:03:37,680 --> 00:03:43,380
contains you boot now if you're asking

00:03:40,320 --> 00:03:46,050
for some sort of help online about you

00:03:43,380 --> 00:03:48,570
boot I especially when IRC and in the

00:03:46,050 --> 00:03:50,190
mailing list it's really convenient if

00:03:48,570 --> 00:03:53,340
you include the you boot version at

00:03:50,190 --> 00:03:55,920
least which CPU with is and which board

00:03:53,340 --> 00:03:57,870
it is in the report it makes it much

00:03:55,920 --> 00:04:00,000
easier for the you boot developers to

00:03:57,870 --> 00:04:02,780
help you out because if you don't do

00:04:00,000 --> 00:04:05,700
that and the the next question will be

00:04:02,780 --> 00:04:08,790
which version which port which CPU and

00:04:05,700 --> 00:04:11,340
this is all conveniently you like here

00:04:08,790 --> 00:04:13,890
in in the sprint out you can just like

00:04:11,340 --> 00:04:16,320
copy paste that into your email and be

00:04:13,890 --> 00:04:20,459
done with it it will make our life much

00:04:16,320 --> 00:04:21,690
easier so that's what humor is about and

00:04:20,459 --> 00:04:24,270
now

00:04:21,690 --> 00:04:27,480
very quickly about news and you booth we

00:04:24,270 --> 00:04:30,930
are progressing in converting you boot

00:04:27,480 --> 00:04:33,600
to drive them device three control and

00:04:30,930 --> 00:04:35,880
driver model that is we are moving away

00:04:33,600 --> 00:04:38,910
from the old hard coding everything into

00:04:35,880 --> 00:04:43,880
a binary to much more flexible model up

00:04:38,910 --> 00:04:46,200
just supplying a device three and having

00:04:43,880 --> 00:04:48,300
significantly better drivers in new boot

00:04:46,200 --> 00:04:51,810
I'll talk about that in detail in a bit

00:04:48,300 --> 00:04:54,870
we recently got EFI support that means

00:04:51,810 --> 00:04:57,660
you boot can behave as an EFI library

00:04:54,870 --> 00:04:59,910
and provide EFI services to for example

00:04:57,660 --> 00:05:02,220
grub so then you can kind of start an

00:04:59,910 --> 00:05:04,980
EFI application like grub which is using

00:05:02,220 --> 00:05:07,050
this actual protocol to talk to you boot

00:05:04,980 --> 00:05:10,770
and consume services like serial port

00:05:07,050 --> 00:05:11,690
access block access network access that

00:05:10,770 --> 00:05:13,980
sort of stuff

00:05:11,690 --> 00:05:18,240
which I believe might be interesting

00:05:13,980 --> 00:05:20,100
especially for this throw people we also

00:05:18,240 --> 00:05:22,920
have distributed command support which

00:05:20,100 --> 00:05:25,280
is a sort of a predecessor of that it's

00:05:22,920 --> 00:05:27,480
just a standard urban environment which

00:05:25,280 --> 00:05:29,490
in case you're rolling out some sort of

00:05:27,480 --> 00:05:34,260
development kit you should enable it

00:05:29,490 --> 00:05:35,970
alls it again it lets this throws expect

00:05:34,260 --> 00:05:38,669
something from the boot environment some

00:05:35,970 --> 00:05:40,380
sort of standard and they can tap into

00:05:38,669 --> 00:05:44,640
it and it's again much easier for the

00:05:40,380 --> 00:05:46,650
distro people now we recently good

00:05:44,640 --> 00:05:50,240
support for applying device three

00:05:46,650 --> 00:05:52,680
overlays and this is a bit of a tool for

00:05:50,240 --> 00:05:54,560
circumventing the current situation with

00:05:52,680 --> 00:05:57,390
device three overlays loading in Linux

00:05:54,560 --> 00:05:59,460
so what basically happens in Linux is

00:05:57,390 --> 00:06:01,040
that the device three overlays support

00:05:59,460 --> 00:06:03,240
is all there but the configure has

00:06:01,040 --> 00:06:05,940
device three overlay though loader is

00:06:03,240 --> 00:06:07,560
not there so it's kind of good moved

00:06:05,940 --> 00:06:08,970
into you booth and you boot is able to

00:06:07,560 --> 00:06:11,220
take device three apply device three

00:06:08,970 --> 00:06:14,130
overlays on top of that device three and

00:06:11,220 --> 00:06:15,419
pass that to Linux instead so you do not

00:06:14,130 --> 00:06:18,390
have to patch your kernel with the

00:06:15,419 --> 00:06:21,390
configure bus loader now even more

00:06:18,390 --> 00:06:24,419
recently we got support for applying

00:06:21,390 --> 00:06:29,220
device threes overlays through the Ubud

00:06:24,419 --> 00:06:31,319
image if this tells you nothing it's

00:06:29,220 --> 00:06:33,629
probably not your sort of niche

00:06:31,319 --> 00:06:35,669
and you don't really have to care about

00:06:33,629 --> 00:06:37,939
that so it doesn't have to stress you if

00:06:35,669 --> 00:06:41,069
you don't understand what I just said

00:06:37,939 --> 00:06:42,749
and if you're interested in that we can

00:06:41,069 --> 00:06:47,129
talk about it later but it's unrelated

00:06:42,749 --> 00:06:49,529
to this talk so one last thing I want to

00:06:47,129 --> 00:06:51,360
talk about is that we now use Travis CI

00:06:49,529 --> 00:06:54,629
to do continuous integration on new boot

00:06:51,360 --> 00:06:56,039
and you can also do that yourself if

00:06:54,629 --> 00:06:58,589
you're submitting patches just get a

00:06:56,039 --> 00:07:00,569
github account enable Travis CI the

00:06:58,589 --> 00:07:04,110
u-boot source is now contained Travis

00:07:00,569 --> 00:07:06,869
that IML file so when you push it to get

00:07:04,110 --> 00:07:08,909
help it will just run the entire u-boot

00:07:06,869 --> 00:07:11,009
source tree and that will build it for

00:07:08,909 --> 00:07:12,419
multiple architectures just to make sure

00:07:11,009 --> 00:07:14,189
that your patch didn't break anything

00:07:12,419 --> 00:07:17,249
it's really convenient this sort of

00:07:14,189 --> 00:07:19,469
stuff and it also makes it easier for

00:07:17,249 --> 00:07:21,659
you so you don't have to like grab all

00:07:19,469 --> 00:07:25,680
the tool chains and just use the yeah

00:07:21,659 --> 00:07:30,930
Travis CI nowadays so that's it for the

00:07:25,680 --> 00:07:32,279
you would use now let's get to building

00:07:30,930 --> 00:07:33,839
you boot so if you want to build your

00:07:32,279 --> 00:07:36,569
boot you obviously need to get the

00:07:33,839 --> 00:07:39,569
sources from somewhere the master you

00:07:36,569 --> 00:07:42,029
would repo is available through get at

00:07:39,569 --> 00:07:45,300
this at this address is also available

00:07:42,029 --> 00:07:48,449
through HTTP so we can get it from there

00:07:45,300 --> 00:07:51,419
if you also need power balls then they

00:07:48,449 --> 00:07:52,800
are available again there it can just so

00:07:51,419 --> 00:07:54,269
happen that you are developing some sort

00:07:52,800 --> 00:07:56,550
of feature and you're probably talking

00:07:54,269 --> 00:07:59,309
to one of the maintainer of the

00:07:56,550 --> 00:08:02,699
subsystems at which point they may tell

00:07:59,309 --> 00:08:04,379
you okay so I have this stuff on which I

00:08:02,699 --> 00:08:08,069
would like you to base your new feature

00:08:04,379 --> 00:08:10,169
on and it's available in my maintainer

00:08:08,069 --> 00:08:12,330
repo so the maintainer repos are

00:08:10,169 --> 00:08:14,279
available in this on this second address

00:08:12,330 --> 00:08:18,719
usually you're not gonna need it but

00:08:14,279 --> 00:08:20,099
anyways it's that's what it is so once

00:08:18,719 --> 00:08:21,930
you have the you boot sources you

00:08:20,099 --> 00:08:24,209
probably want to build them and to build

00:08:21,930 --> 00:08:27,659
the u-boot sources use the following

00:08:24,209 --> 00:08:29,969
methods so just change into the you

00:08:27,659 --> 00:08:37,289
would source directory export there's

00:08:29,969 --> 00:08:38,519
two variables the first ones like the

00:08:37,289 --> 00:08:39,779
architecture for which you are building

00:08:38,519 --> 00:08:43,649
so in case you are building for example

00:08:39,779 --> 00:08:44,529
forearm this will be R equals arm the

00:08:43,649 --> 00:08:48,370
other one is your

00:08:44,529 --> 00:08:50,470
first compiler toolchain prefix forearm

00:08:48,370 --> 00:08:51,970
this will be something like arm linux -

00:08:50,470 --> 00:08:53,889
something like that

00:08:51,970 --> 00:08:55,990
for Mapes it's gonna be like mips no

00:08:53,889 --> 00:08:58,329
norm its linux whatever this sort of

00:08:55,990 --> 00:09:01,059
thing now once you have the environment

00:08:58,329 --> 00:09:04,300
set up you need to configure the you

00:09:01,059 --> 00:09:06,189
boots or tsa's and for that you need to

00:09:04,300 --> 00:09:09,819
support the configuration which you can

00:09:06,189 --> 00:09:11,139
locate under the config directory once

00:09:09,819 --> 00:09:14,740
you locate your configuration for your

00:09:11,139 --> 00:09:17,889
boards do you like make your port that's

00:09:14,740 --> 00:09:21,160
gonna fake the Yubel sources will get

00:09:17,889 --> 00:09:23,170
configure it and then use make to

00:09:21,160 --> 00:09:24,879
compile it it will produce some sort of

00:09:23,170 --> 00:09:30,160
binary which you can then install on

00:09:24,879 --> 00:09:33,579
your system there is one more detail to

00:09:30,160 --> 00:09:36,279
this you can now compile unison user

00:09:33,579 --> 00:09:38,170
space Linux application with the sandbox

00:09:36,279 --> 00:09:40,629
stuff config at which point you don't

00:09:38,170 --> 00:09:43,300
need to export any of the arch and

00:09:40,629 --> 00:09:45,279
cross-compile options you just do like

00:09:43,300 --> 00:09:46,779
make sandbox that config and make and it

00:09:45,279 --> 00:09:49,509
will generate you boot

00:09:46,779 --> 00:09:51,550
elf binary the Linux application which

00:09:49,509 --> 00:09:53,500
you can then lounge and it will give you

00:09:51,550 --> 00:09:54,519
a huge shell so if you want to play

00:09:53,500 --> 00:09:57,639
around with you boot shell without

00:09:54,519 --> 00:10:02,470
having any sort of development kit you

00:09:57,639 --> 00:10:04,059
can do that with the sandbox ok now if

00:10:02,470 --> 00:10:06,370
you want to add any sort of stuff into

00:10:04,059 --> 00:10:09,189
the new boot or if you want to hack on

00:10:06,370 --> 00:10:10,600
it it's probably a good idea to know the

00:10:09,189 --> 00:10:13,990
directory structure of the you boot

00:10:10,600 --> 00:10:17,230
source 3 it actually designed in such a

00:10:13,990 --> 00:10:20,589
way that it matches that external for

00:10:17,230 --> 00:10:25,959
the most part so there are specific

00:10:20,589 --> 00:10:29,199
stuff is in arch directory in arch slash

00:10:25,959 --> 00:10:34,029
something like arm or MIPS whatever are

00:10:29,199 --> 00:10:36,429
the CPU specific things if you have some

00:10:34,029 --> 00:10:38,879
sort of CPU vendor then it goes into my

00:10:36,429 --> 00:10:42,670
food here

00:10:38,879 --> 00:10:46,990
unlike Linux the device 3 source files

00:10:42,670 --> 00:10:49,240
are in arch slash whatever slash DTS

00:10:46,990 --> 00:10:52,300
directly it's not an arm slash whatever

00:10:49,240 --> 00:10:57,110
slash boot so that's a small difference

00:10:52,300 --> 00:10:59,310
there we have board support in the

00:10:57,110 --> 00:11:02,279
boertie directory which you won't find

00:10:59,310 --> 00:11:05,220
in the end of linux kernel tree and then

00:11:02,279 --> 00:11:09,980
the rest is very similar so conflicts

00:11:05,220 --> 00:11:12,180
contain k config iced board Def Con fix

00:11:09,980 --> 00:11:14,130
the thing is we are still in the process

00:11:12,180 --> 00:11:16,980
of migrating to K convicts so you will

00:11:14,130 --> 00:11:21,000
find a couple of legacy config options

00:11:16,980 --> 00:11:22,740
in include slash convicts still this

00:11:21,000 --> 00:11:26,220
might be the sort of duality might be a

00:11:22,740 --> 00:11:29,459
little confusing but anyway so gate grab

00:11:26,220 --> 00:11:32,990
will give you an idea where either of

00:11:29,459 --> 00:11:35,519
these is now we have drivers and drivers

00:11:32,990 --> 00:11:39,089
you boot shell commands implementation

00:11:35,519 --> 00:11:41,490
is internal days common code is in

00:11:39,089 --> 00:11:46,740
common lip networking stack is in net

00:11:41,490 --> 00:11:49,320
and file system code is in FS it kind is

00:11:46,740 --> 00:11:50,940
logically organized like so you will

00:11:49,320 --> 00:11:53,010
also notice that if you look into the

00:11:50,940 --> 00:11:56,160
boot sources there's a lot of k config

00:11:53,010 --> 00:11:59,519
and cables make files so yeah you boot

00:11:56,160 --> 00:12:02,490
is nowadays migrating the word k config

00:11:59,519 --> 00:12:05,880
and k build it's still kinda in progress

00:12:02,490 --> 00:12:08,120
but we are just trying to move over and

00:12:05,880 --> 00:12:09,870
that's why you still have a couple of

00:12:08,120 --> 00:12:11,730
configure options which are not

00:12:09,870 --> 00:12:15,300
converted and include context

00:12:11,730 --> 00:12:18,839
unfortunately but any new you boot

00:12:15,300 --> 00:12:21,000
configure options are k config only if

00:12:18,839 --> 00:12:22,470
you have some option which is not going

00:12:21,000 --> 00:12:25,260
to configure only you can verify that

00:12:22,470 --> 00:12:27,540
it's still not been converted by looking

00:12:25,260 --> 00:12:29,790
into this file but if you are submitting

00:12:27,540 --> 00:12:33,959
any any sort of new stuff it has to be a

00:12:29,790 --> 00:12:36,420
config only now to give you an idea how

00:12:33,959 --> 00:12:39,390
such a k config config option looks like

00:12:36,420 --> 00:12:44,940
I just pulled out drivers net k config

00:12:39,390 --> 00:12:46,589
here so in this file we have DM e th

00:12:44,940 --> 00:12:48,570
configure option if you like to make

00:12:46,589 --> 00:12:52,110
meadow config you would be able to find

00:12:48,570 --> 00:12:54,990
this in the manual config out pad so

00:12:52,110 --> 00:12:59,880
this option enables driver model for

00:12:54,990 --> 00:13:02,279
Ethernet the entry is of type boo

00:12:59,880 --> 00:13:04,529
if you look it up in like make many

00:13:02,279 --> 00:13:06,930
conflict you will be able to locate this

00:13:04,529 --> 00:13:08,899
sort of line in there

00:13:06,930 --> 00:13:12,920
this specific configure option

00:13:08,899 --> 00:13:15,410
depends on driver model and you'd be

00:13:12,920 --> 00:13:18,050
able to like list out the sort of help

00:13:15,410 --> 00:13:21,769
in the again for example make Mary

00:13:18,050 --> 00:13:25,990
config so this is all similar to the

00:13:21,769 --> 00:13:29,899
Linux kernel you can find it all there

00:13:25,990 --> 00:13:33,829
now there is this sort of small weird

00:13:29,899 --> 00:13:35,809
quirk in that if you add a que configure

00:13:33,829 --> 00:13:38,389
option it will not have the config

00:13:35,809 --> 00:13:40,819
underscore prefix in the que config file

00:13:38,389 --> 00:13:43,850
but in the make files it is all used

00:13:40,819 --> 00:13:45,559
with the conflict underscore prefix and

00:13:43,850 --> 00:13:47,540
even if you look into your like a config

00:13:45,559 --> 00:13:49,910
dot config file it will be with the

00:13:47,540 --> 00:13:52,850
config underscore prefix so this is a

00:13:49,910 --> 00:13:56,540
little bit inconsistent but that's how

00:13:52,850 --> 00:13:59,300
the config system is this is something

00:13:56,540 --> 00:14:01,459
you should probably be careful about now

00:13:59,300 --> 00:14:03,499
if you decide to add a new configure

00:14:01,459 --> 00:14:05,779
option into you boot it's just a matter

00:14:03,499 --> 00:14:07,189
of adding it into the cake config or

00:14:05,779 --> 00:14:09,499
adding the matching cake config entry

00:14:07,189 --> 00:14:11,809
into the right file if you have any

00:14:09,499 --> 00:14:16,779
sources attached to that modify to make

00:14:11,809 --> 00:14:20,029
file add the sources it's that easy

00:14:16,779 --> 00:14:22,160
except in case it's some sort of

00:14:20,029 --> 00:14:24,079
hardware configuration option then you

00:14:22,160 --> 00:14:25,279
should not add it into the cake config

00:14:24,079 --> 00:14:32,779
but instead you should add it into

00:14:25,279 --> 00:14:34,639
device 3 now what is the device 3 just a

00:14:32,779 --> 00:14:37,249
survey how many of you know what a

00:14:34,639 --> 00:14:40,309
device 3 is double check that okay

00:14:37,249 --> 00:14:44,089
that's amazing yeah super but anyway

00:14:40,309 --> 00:14:45,920
just for the record device 3 is data

00:14:44,089 --> 00:14:48,559
structure which is used to describe

00:14:45,920 --> 00:14:50,389
hardware to the software and it's

00:14:48,559 --> 00:14:53,870
especially useful if your hardware

00:14:50,389 --> 00:14:55,970
cannot be detected then you can describe

00:14:53,870 --> 00:14:58,339
or the entire hardware structure in the

00:14:55,970 --> 00:14:59,720
device 3 and pass this information to

00:14:58,339 --> 00:15:03,699
the software and the software will know

00:14:59,720 --> 00:15:07,160
that apology of your hardware now this a

00:15:03,699 --> 00:15:10,850
device 3 has a standard ins been around

00:15:07,160 --> 00:15:13,399
since very long time it is actually

00:15:10,850 --> 00:15:15,529
governed by the e paper and if you want

00:15:13,399 --> 00:15:19,009
to find more information about it I

00:15:15,529 --> 00:15:22,320
think you look at device 3 dot org

00:15:19,009 --> 00:15:25,050
website this is what it

00:15:22,320 --> 00:15:27,960
the latest information are formerly the

00:15:25,050 --> 00:15:32,670
device three is three like structure

00:15:27,960 --> 00:15:34,530
which has notes in it and each node can

00:15:32,670 --> 00:15:39,510
have multiple nodes underneath that or

00:15:34,530 --> 00:15:41,850
it can have key value pairs device three

00:15:39,510 --> 00:15:43,680
properties now instead of describing it

00:15:41,850 --> 00:15:45,720
elaborately like so I can just give you

00:15:43,680 --> 00:15:48,240
an example which I pulled out from you

00:15:45,720 --> 00:15:49,980
booth and in fact since device three is

00:15:48,240 --> 00:15:52,860
a standard both you booth and Linux

00:15:49,980 --> 00:15:56,850
share the same device three sources

00:15:52,860 --> 00:15:59,120
which is the way it's supposed to be so

00:15:56,850 --> 00:16:03,030
if you look at the device three sources

00:15:59,120 --> 00:16:04,890
you will see stuff like this in this

00:16:03,030 --> 00:16:08,700
particular example there is this include

00:16:04,890 --> 00:16:12,240
directive which is a special detail of

00:16:08,700 --> 00:16:14,240
you both Linux and so on because these

00:16:12,240 --> 00:16:16,560
projects from the device three sources

00:16:14,240 --> 00:16:19,140
before they do anything with them

00:16:16,560 --> 00:16:23,180
through the C preprocessor just to

00:16:19,140 --> 00:16:26,940
expand macros like what do we have here

00:16:23,180 --> 00:16:29,400
like the irq type level high and so on

00:16:26,940 --> 00:16:31,020
so you don't have to encode raw numbers

00:16:29,400 --> 00:16:33,810
into the device resource but you can

00:16:31,020 --> 00:16:37,350
just use these symbolic names so that's

00:16:33,810 --> 00:16:38,310
what happens first and after that what

00:16:37,350 --> 00:16:40,020
do we have here

00:16:38,310 --> 00:16:41,670
so here is the root node here are a

00:16:40,020 --> 00:16:43,650
couple of device three properties which

00:16:41,670 --> 00:16:46,470
say okay yeah this is some sort of board

00:16:43,650 --> 00:16:50,000
it's compatible with something then we

00:16:46,470 --> 00:16:52,590
have a CPU note here describing the CPU

00:16:50,000 --> 00:16:54,840
which again is compatible with something

00:16:52,590 --> 00:16:58,650
there are a couple of properties

00:16:54,840 --> 00:17:01,320
attached to that CPU note and we have a

00:16:58,650 --> 00:17:04,890
P mu and so on and so forth there is a

00:17:01,320 --> 00:17:06,750
small detail in here which is called the

00:17:04,890 --> 00:17:09,060
P hanwen that allows you to reference

00:17:06,750 --> 00:17:12,180
different nodes within the device tree

00:17:09,060 --> 00:17:16,079
so it's referencing the CPU code there

00:17:12,180 --> 00:17:18,600
and this makes it more of a graft and

00:17:16,079 --> 00:17:21,030
actually tree so device tree is kind of

00:17:18,600 --> 00:17:25,560
not really a tree but it's tree like

00:17:21,030 --> 00:17:27,449
structure still alright and this can be

00:17:25,560 --> 00:17:31,350
used to describe the entire hardware

00:17:27,449 --> 00:17:33,680
topology to the software now you would

00:17:31,350 --> 00:17:35,960
use this device three in two ways

00:17:33,680 --> 00:17:38,330
so first of all if your platform is

00:17:35,960 --> 00:17:40,130
device three capable and your Linux is

00:17:38,330 --> 00:17:42,770
divided the next kernel is device three

00:17:40,130 --> 00:17:46,070
capable you would is able to pass device

00:17:42,770 --> 00:17:48,170
three doodle in external and while doing

00:17:46,070 --> 00:17:50,809
so it actually does some modifications

00:17:48,170 --> 00:17:53,809
to the device three like it looks up the

00:17:50,809 --> 00:17:57,230
aliases note and patches for example and

00:17:53,809 --> 00:17:58,970
MAC address into the device three from

00:17:57,230 --> 00:18:00,950
the urban environment which allows you

00:17:58,970 --> 00:18:03,320
to share the same MAC address between

00:18:00,950 --> 00:18:05,890
you boot and Linux so this is what

00:18:03,320 --> 00:18:08,330
happens but that's kind of boring right

00:18:05,890 --> 00:18:10,340
the other way you would can use device

00:18:08,330 --> 00:18:12,470
three is it can set up device three

00:18:10,340 --> 00:18:14,510
access very early on in the you boot

00:18:12,470 --> 00:18:16,700
boot process and then you would extract

00:18:14,510 --> 00:18:18,679
the the hardware topology from the

00:18:16,700 --> 00:18:20,510
device tree and this is governed by the

00:18:18,679 --> 00:18:24,260
configure web control you boot

00:18:20,510 --> 00:18:26,770
configuration option but for you to

00:18:24,260 --> 00:18:29,929
appreciate when the device 3 access

00:18:26,770 --> 00:18:32,960
becomes available like how early on it

00:18:29,929 --> 00:18:35,150
becomes available we should take a look

00:18:32,960 --> 00:18:40,070
at you would early stages and how it

00:18:35,150 --> 00:18:42,260
actually boots up so when you power on

00:18:40,070 --> 00:18:45,740
your platform and does its power

00:18:42,260 --> 00:18:47,559
sequencing and stuff the CPU will start

00:18:45,740 --> 00:18:50,870
executing some code at the reset vector

00:18:47,559 --> 00:18:53,690
which is likely usually you boo

00:18:50,870 --> 00:18:55,640
now the code which it will start

00:18:53,690 --> 00:18:57,440
executing lives it somewhere in the arc

00:18:55,640 --> 00:19:01,010
directories and it's a piece of code

00:18:57,440 --> 00:19:02,660
which is architecture specific and it's

00:19:01,010 --> 00:19:05,570
not generic it's just specific to your

00:19:02,660 --> 00:19:07,720
CPU now it will execute that code which

00:19:05,570 --> 00:19:10,850
will be just a small piece of it and

00:19:07,720 --> 00:19:13,670
then it will jump into CRT zero to DES

00:19:10,850 --> 00:19:15,110
which is setting up the C runtime this

00:19:13,670 --> 00:19:17,120
is still assembly code but this is a

00:19:15,110 --> 00:19:19,490
common assembly code for your

00:19:17,120 --> 00:19:22,190
architecture now once the ski runtime is

00:19:19,490 --> 00:19:24,650
set up the first C code can be executed

00:19:22,190 --> 00:19:29,270
and this first C code which is executed

00:19:24,650 --> 00:19:31,610
lives in port underscore F dot C now the

00:19:29,270 --> 00:19:33,950
board underscore F that C means that

00:19:31,610 --> 00:19:37,040
this is a code which is supposed to be

00:19:33,950 --> 00:19:41,170
executed from flash and this is a bit of

00:19:37,040 --> 00:19:43,490
a legacy naming honestly so nowadays

00:19:41,170 --> 00:19:45,240
this is not the case but there used to

00:19:43,490 --> 00:19:47,130
be times with

00:19:45,240 --> 00:19:49,050
this piece of code was running with a

00:19:47,130 --> 00:19:51,780
limited environment it's usually with

00:19:49,050 --> 00:19:54,240
stack running in locked cache lines sort

00:19:51,780 --> 00:19:59,190
of limited environment nowadays it's

00:19:54,240 --> 00:20:00,480
running from RAM but you should expect

00:19:59,190 --> 00:20:05,400
that sort of limitation in that

00:20:00,480 --> 00:20:08,490
environment so this code the board

00:20:05,400 --> 00:20:10,020
underscore F code contains a list of

00:20:08,490 --> 00:20:12,120
functions which are executed in this

00:20:10,020 --> 00:20:13,950
limited environment these functions are

00:20:12,120 --> 00:20:16,770
usually responsible for bringing up the

00:20:13,950 --> 00:20:19,080
RAM starting it up and ultimately when

00:20:16,770 --> 00:20:22,140
these functions finish uber is relegated

00:20:19,080 --> 00:20:25,380
at the end of the RAM and the code

00:20:22,140 --> 00:20:28,830
starts continent board underscore R

00:20:25,380 --> 00:20:30,780
that's you which is like the second half

00:20:28,830 --> 00:20:32,040
of the you boot boot process which

00:20:30,780 --> 00:20:35,160
executes functions which are running

00:20:32,040 --> 00:20:37,950
from RAM and when the board underscore R

00:20:35,160 --> 00:20:40,410
that's he completes you will get the you

00:20:37,950 --> 00:20:42,240
boot out of boot prompt and then you can

00:20:40,410 --> 00:20:45,390
interrupt it and enter B you will shell

00:20:42,240 --> 00:20:47,250
for example now all the way at the

00:20:45,390 --> 00:20:49,740
beginning like one of the first

00:20:47,250 --> 00:20:51,690
functions in board underscore after the

00:20:49,740 --> 00:20:54,180
C sets up the access to the flattened

00:20:51,690 --> 00:20:56,940
device three blob so even at that point

00:20:54,180 --> 00:21:00,180
so early on like the first function in

00:20:56,940 --> 00:21:02,480
the C code allows you to access or set

00:21:00,180 --> 00:21:05,010
up the access to the device tree and

00:21:02,480 --> 00:21:08,000
from their own you can extract

00:21:05,010 --> 00:21:10,620
information from the device three-block

00:21:08,000 --> 00:21:13,770
yeah one minor detail if you are ever

00:21:10,620 --> 00:21:18,060
debugging the u-boot init process take a

00:21:13,770 --> 00:21:20,250
look at the lip in it called C which

00:21:18,060 --> 00:21:22,290
contains like to debug statements and if

00:21:20,250 --> 00:21:24,200
you replace them with printf you boot

00:21:22,290 --> 00:21:27,240
will give you a list of every single

00:21:24,200 --> 00:21:28,770
init call it makes so if you're looking

00:21:27,240 --> 00:21:31,020
for something like you would hang

00:21:28,770 --> 00:21:33,840
somewhere in the middle of these init

00:21:31,020 --> 00:21:36,120
sequences just replace them the debug

00:21:33,840 --> 00:21:39,900
statements in the lip in it called C

00:21:36,120 --> 00:21:43,020
with printf and you will know which was

00:21:39,900 --> 00:21:46,560
the last in its statement in those lists

00:21:43,020 --> 00:21:49,740
which still completed and where it

00:21:46,560 --> 00:21:51,960
actually therefore got stuck it's really

00:21:49,740 --> 00:21:54,770
convenient this this sort of debug ate

00:21:51,960 --> 00:21:58,720
there so okay

00:21:54,770 --> 00:21:58,720
noted yeah go ahead

00:22:09,210 --> 00:22:15,520
yeah so the question is if the device 3

00:22:13,210 --> 00:22:16,870
is compiled into you boot because you

00:22:15,520 --> 00:22:19,390
boot is not able to read it from the

00:22:16,870 --> 00:22:21,669
file system so early on actually there

00:22:19,390 --> 00:22:24,549
are two ways to do it you can embed the

00:22:21,669 --> 00:22:26,049
device 3 flatten device 3 blob into the

00:22:24,549 --> 00:22:27,820
Year booth and it's part of a special

00:22:26,049 --> 00:22:31,270
section of the Ubud binary this is

00:22:27,820 --> 00:22:34,090
configure FM bad or you can have

00:22:31,270 --> 00:22:37,630
configure a separate which allows you to

00:22:34,090 --> 00:22:40,360
attach device flatten device 3 blob at

00:22:37,630 --> 00:22:41,919
the end of the u-boot binary has not

00:22:40,360 --> 00:22:44,610
compiled into the Ubud binary it's

00:22:41,919 --> 00:22:47,740
really just concatenated to the end and

00:22:44,610 --> 00:22:50,679
the target of this other option is that

00:22:47,740 --> 00:22:52,570
you are able to build single you with

00:22:50,679 --> 00:22:56,260
binary but attach different device 3

00:22:52,570 --> 00:22:57,850
blobs to it yeah but it's definitely not

00:22:56,260 --> 00:22:58,809
reading it from the file system it is

00:22:57,850 --> 00:23:01,570
one way or the other

00:22:58,809 --> 00:23:07,540
attached somehow to the u-boot binary

00:23:01,570 --> 00:23:09,340
yes thanks yeah so what's continue you

00:23:07,540 --> 00:23:12,309
will device 3 access right so now that

00:23:09,340 --> 00:23:15,280
you have device 3 access set up in the

00:23:12,309 --> 00:23:16,660
you boot boot process if you grab

00:23:15,280 --> 00:23:17,980
through the you boot source 3 you will

00:23:16,660 --> 00:23:21,370
see that there are multiple ways to

00:23:17,980 --> 00:23:23,950
access the device 3 this can be

00:23:21,370 --> 00:23:26,440
confusing but there are basically three

00:23:23,950 --> 00:23:29,650
ways to do it using the fdt underscore

00:23:26,440 --> 00:23:34,690
functions which are basically they're

00:23:29,650 --> 00:23:37,450
all fdt calls and you should for the

00:23:34,690 --> 00:23:40,030
most part not use that because just you

00:23:37,450 --> 00:23:41,830
you just need to code around a lot of

00:23:40,030 --> 00:23:44,200
boilerplate code if you use these

00:23:41,830 --> 00:23:46,210
functions it could be that you need to

00:23:44,200 --> 00:23:47,950
do something special with the device 3

00:23:46,210 --> 00:23:49,750
and in that case you may need to use

00:23:47,950 --> 00:23:51,850
those functions but otherwise you

00:23:49,750 --> 00:23:53,740
probably shouldn't use them

00:23:51,850 --> 00:23:57,220
there are convenience wrappers around

00:23:53,740 --> 00:23:59,380
this which are the FTT tag functions so

00:23:57,220 --> 00:24:01,270
these just hide the boilerplate code and

00:23:59,380 --> 00:24:05,049
allow you to conveniently extract

00:24:01,270 --> 00:24:07,840
information from the control device 3 so

00:24:05,049 --> 00:24:10,780
if you are outside of the u-boot driver

00:24:07,840 --> 00:24:12,700
model these functions might be what you

00:24:10,780 --> 00:24:15,730
want to use to extract information from

00:24:12,700 --> 00:24:17,510
the device 3 now if you are within that

00:24:15,730 --> 00:24:19,820
you would driver model

00:24:17,510 --> 00:24:23,180
you should use the def underscore

00:24:19,820 --> 00:24:25,940
functions to extract information from

00:24:23,180 --> 00:24:28,130
the DT so you see the death rate

00:24:25,940 --> 00:24:29,720
functions allow you to extract

00:24:28,130 --> 00:24:34,670
information from the device three note

00:24:29,720 --> 00:24:36,200
associated with a specific driver and if

00:24:34,670 --> 00:24:40,430
you are within that context you should

00:24:36,200 --> 00:24:45,890
use these functions so speaking of

00:24:40,430 --> 00:24:47,420
driver model I didn't figure out a good

00:24:45,890 --> 00:24:50,000
way to describe what the you would

00:24:47,420 --> 00:24:54,830
driver model is but I can basically tell

00:24:50,000 --> 00:24:57,110
you what this stemmed from so it was

00:24:54,830 --> 00:25:00,080
like six years ago when the hardware

00:24:57,110 --> 00:25:02,000
started to become more and more complex

00:25:00,080 --> 00:25:04,730
and you would at that point was still

00:25:02,000 --> 00:25:08,570
configured with boatload of F devs right

00:25:04,730 --> 00:25:10,790
and people started requiring stuff like

00:25:08,570 --> 00:25:12,730
well we have two different I squared C

00:25:10,790 --> 00:25:15,380
buses using two different drivers and

00:25:12,730 --> 00:25:19,180
you would just doesn't have any way to

00:25:15,380 --> 00:25:22,100
support that so we will just code this

00:25:19,180 --> 00:25:24,560
extra driver which supports our platform

00:25:22,100 --> 00:25:26,630
and this sort of stuff started like

00:25:24,560 --> 00:25:29,090
appearing in the Ubud codebase and it

00:25:26,630 --> 00:25:33,920
just didn't scale and it was becoming a

00:25:29,090 --> 00:25:36,800
massive mess so at my university we

00:25:33,920 --> 00:25:39,250
started the you would driver model as a

00:25:36,800 --> 00:25:42,580
sort of semester old project and

00:25:39,250 --> 00:25:46,070
ultimately we got something going and

00:25:42,580 --> 00:25:48,860
after that Simon glass from Google took

00:25:46,070 --> 00:25:51,890
over and started pushing more and more

00:25:48,860 --> 00:25:56,900
of that stuff into upstream so nowadays

00:25:51,890 --> 00:25:58,790
we have really decent but driver model

00:25:56,900 --> 00:26:02,080
without too much overhead which is

00:25:58,790 --> 00:26:04,730
fitting very well into the bootloader

00:26:02,080 --> 00:26:10,310
now the UB driver model consists of

00:26:04,730 --> 00:26:13,310
three major object types in there first

00:26:10,310 --> 00:26:17,660
one is the u-boot classes now the u-boot

00:26:13,310 --> 00:26:20,390
class is sort of an interface or sort of

00:26:17,660 --> 00:26:22,730
an object which provides the u-boot as a

00:26:20,390 --> 00:26:26,330
consumer some sort of API for a specific

00:26:22,730 --> 00:26:28,550
hardware class think of it like a serial

00:26:26,330 --> 00:26:30,420
you boot class is providing you boot

00:26:28,550 --> 00:26:32,940
with generic functions

00:26:30,420 --> 00:26:35,490
put character or get character test if

00:26:32,940 --> 00:26:37,230
there's character in FIFO reconfigure

00:26:35,490 --> 00:26:39,810
about rate generator that sort of thing

00:26:37,230 --> 00:26:42,540
the u-boot class is also tracking driver

00:26:39,810 --> 00:26:46,050
instances so every single driver

00:26:42,540 --> 00:26:47,850
instance of that particular type that is

00:26:46,050 --> 00:26:50,490
like serial port driver instance would

00:26:47,850 --> 00:26:54,780
be registering with the serial port you

00:26:50,490 --> 00:26:57,510
boot class so we're the other object

00:26:54,780 --> 00:27:02,940
which exists within the u-boot driver

00:26:57,510 --> 00:27:04,770
model are driver well drivers which

00:27:02,940 --> 00:27:07,230
implement the specific register poking

00:27:04,770 --> 00:27:11,330
and the specific interface for reboot

00:27:07,230 --> 00:27:14,700
class this is defined for each type of

00:27:11,330 --> 00:27:18,570
Ubud drivers and then there are devices

00:27:14,700 --> 00:27:20,340
or instances of drivers so when you

00:27:18,570 --> 00:27:23,150
instantiate the driver some sort of

00:27:20,340 --> 00:27:27,480
metadata get allocated and it registers

00:27:23,150 --> 00:27:31,640
with the u-boot class that way you can

00:27:27,480 --> 00:27:34,440
have both two different types of drivers

00:27:31,640 --> 00:27:40,140
instantiated at the same time in the

00:27:34,440 --> 00:27:43,620
running gear boot as well as two drivers

00:27:40,140 --> 00:27:46,620
of the same type instantiated at the

00:27:43,620 --> 00:27:48,690
same time while you boot is running it's

00:27:46,620 --> 00:27:50,700
not a problem if you need to select

00:27:48,690 --> 00:27:53,850
which of these drivers should be used

00:27:50,700 --> 00:27:58,980
this is configured on the u-boot u class

00:27:53,850 --> 00:28:02,330
level right now the u driver model core

00:27:58,980 --> 00:28:05,370
itself is designed to be massively lazy

00:28:02,330 --> 00:28:07,280
this is because if you're booting I mean

00:28:05,370 --> 00:28:10,800
you want the boot loader to just

00:28:07,280 --> 00:28:13,290
initialize as little as possible of the

00:28:10,800 --> 00:28:16,020
hardware and then load the next stage

00:28:13,290 --> 00:28:17,760
just start next stage and get going

00:28:16,020 --> 00:28:19,440
right you do not want to initialize

00:28:17,760 --> 00:28:21,330
stuff which you do not need so that's

00:28:19,440 --> 00:28:24,510
why the driver model core is designed to

00:28:21,330 --> 00:28:26,070
be really lazy now one day you Buddha is

00:28:24,510 --> 00:28:28,680
coming up and the driver model is

00:28:26,070 --> 00:28:30,960
initializing itself the only thing which

00:28:28,680 --> 00:28:33,840
happens is that the driver model core

00:28:30,960 --> 00:28:37,920
instantiates a route driver as about it

00:28:33,840 --> 00:28:41,070
if device 3 control is enabled then it

00:28:37,920 --> 00:28:42,590
scans the device 3 and binds all the

00:28:41,070 --> 00:28:45,740
drivers under

00:28:42,590 --> 00:28:48,259
driver in the way that is described in

00:28:45,740 --> 00:28:53,120
the device 3 but it does not initialize

00:28:48,259 --> 00:28:55,879
anything at all to give you an idea how

00:28:53,120 --> 00:28:58,940
the u-boot route driver and all this

00:28:55,879 --> 00:29:02,690
other stuff is bound we have this

00:28:58,940 --> 00:29:05,779
convenient dm3 command which will list

00:29:02,690 --> 00:29:08,480
all the drivers which are bound that

00:29:05,779 --> 00:29:11,360
means attached into the u-boot driver 3

00:29:08,480 --> 00:29:13,639
as well as those that are approved now

00:29:11,360 --> 00:29:16,519
the driver is probed that means the

00:29:13,639 --> 00:29:18,769
hardware is initialized only when

00:29:16,519 --> 00:29:22,460
someone is first time requesting its

00:29:18,769 --> 00:29:24,950
services that means for example if I'm

00:29:22,460 --> 00:29:28,429
loading anything from SD MMC the first

00:29:24,950 --> 00:29:30,889
time I do any sort of block access the

00:29:28,429 --> 00:29:34,129
SD MMC controller will get probed and

00:29:30,889 --> 00:29:36,499
initialized and it could happen that

00:29:34,129 --> 00:29:39,740
this SD MMC controller will require for

00:29:36,499 --> 00:29:41,379
example o'clock and then at that point

00:29:39,740 --> 00:29:44,450
also the clock driver will be

00:29:41,379 --> 00:29:47,389
initialized for the first time now every

00:29:44,450 --> 00:29:48,919
other time when I then reuse that

00:29:47,389 --> 00:29:51,049
hardware it is not really initialized

00:29:48,919 --> 00:29:56,119
again it's just initialized the first

00:29:51,049 --> 00:29:58,639
time I access it but right from the

00:29:56,119 --> 00:30:00,259
get-go it is available to you boot so it

00:29:58,639 --> 00:30:01,879
is bound and you would sees it as a

00:30:00,259 --> 00:30:03,440
device it's just the first time it will

00:30:01,879 --> 00:30:06,169
be a little slower because the hardware

00:30:03,440 --> 00:30:08,600
needs to be initialized in this case

00:30:06,169 --> 00:30:10,399
what you see in this in this picture is

00:30:08,600 --> 00:30:13,850
that serial port is actually probed

00:30:10,399 --> 00:30:16,220
because this out path is coming out on

00:30:13,850 --> 00:30:19,340
the serial port right so it has to be

00:30:16,220 --> 00:30:21,980
probed and it has to be started what

00:30:19,340 --> 00:30:25,369
else do we see here pin configuration is

00:30:21,980 --> 00:30:27,860
also set up because serial port needs

00:30:25,369 --> 00:30:33,769
pin configuration it also needs clocks

00:30:27,860 --> 00:30:36,409
of the clock are also in probed now this

00:30:33,769 --> 00:30:38,119
slide just lists what it actually is

00:30:36,409 --> 00:30:44,029
available to the Ubud driver

00:30:38,119 --> 00:30:45,769
what sort of modes of operation so yeah

00:30:44,029 --> 00:30:49,500
you would driver can be bound this is

00:30:45,769 --> 00:30:53,100
what happens by default it is

00:30:49,500 --> 00:30:54,570
Propst only when required one small

00:30:53,100 --> 00:30:57,360
detail is that when you are implementing

00:30:54,570 --> 00:30:58,920
you would driver you usually do not have

00:30:57,360 --> 00:31:00,990
to implement the bind and unbind

00:30:58,920 --> 00:31:04,320
functions there are generic

00:31:00,990 --> 00:31:05,700
implementations of those it could only

00:31:04,320 --> 00:31:08,850
happen that if you have some sort of

00:31:05,700 --> 00:31:10,110
specific weird requirement that you will

00:31:08,850 --> 00:31:11,880
have to really implement the bind

00:31:10,110 --> 00:31:14,460
functions otherwise you can just leave

00:31:11,880 --> 00:31:17,940
them blank and but you would just bind

00:31:14,460 --> 00:31:19,770
it using the generic code you will have

00:31:17,940 --> 00:31:21,390
to implement probe function because this

00:31:19,770 --> 00:31:23,040
is what initializes the hardware so

00:31:21,390 --> 00:31:23,670
there will be some register poking and

00:31:23,040 --> 00:31:26,130
so on

00:31:23,670 --> 00:31:28,170
you should also implement the remove

00:31:26,130 --> 00:31:29,970
function now remove function is

00:31:28,170 --> 00:31:33,330
responsible for shutting the hardware

00:31:29,970 --> 00:31:36,090
down before you leave you boot and it

00:31:33,330 --> 00:31:37,680
could happen that if you do not

00:31:36,090 --> 00:31:39,480
implement that your hardware will do

00:31:37,680 --> 00:31:41,370
something funny when Linux is trying to

00:31:39,480 --> 00:31:45,660
reinitialize that hardware so you should

00:31:41,370 --> 00:31:50,070
implement that usually this is useful

00:31:45,660 --> 00:31:51,930
when you have like USB controllers they

00:31:50,070 --> 00:31:53,550
have some sort of built-in DMA engine if

00:31:51,930 --> 00:31:56,070
you do not shut it down it could happen

00:31:53,550 --> 00:31:58,440
then when Linux restarts that controller

00:31:56,070 --> 00:32:01,140
it will just trigger some sort of bus

00:31:58,440 --> 00:32:05,070
master access into DRAM and just corrupt

00:32:01,140 --> 00:32:06,900
um this could happen all right so that's

00:32:05,070 --> 00:32:08,910
pretty much it for the u-boot device 3

00:32:06,900 --> 00:32:11,490
control driver model and so on the

00:32:08,910 --> 00:32:17,610
basics and now let's take a look at how

00:32:11,490 --> 00:32:20,220
do we do you boot port port so if you're

00:32:17,610 --> 00:32:23,310
doing any sort of new you boot board

00:32:20,220 --> 00:32:26,190
port please start small I mean if you

00:32:23,310 --> 00:32:27,960
put everything into the you boot port

00:32:26,190 --> 00:32:29,610
port right away you will not be able to

00:32:27,960 --> 00:32:31,500
debug it if something happens because

00:32:29,610 --> 00:32:33,840
you will have so much complexity and so

00:32:31,500 --> 00:32:37,610
much stuff in there that it will be

00:32:33,840 --> 00:32:41,430
impossible so start small just with I

00:32:37,610 --> 00:32:43,430
know serial port out that so you can see

00:32:41,430 --> 00:32:46,080
that the board is doing something at all

00:32:43,430 --> 00:32:49,380
now even the serial port out path is

00:32:46,080 --> 00:32:50,910
nowadays complex enough because on the

00:32:49,380 --> 00:32:54,570
modernist of seas you need to set up

00:32:50,910 --> 00:32:57,630
like pin muxing clock control just to

00:32:54,570 --> 00:33:00,060
get any out pad on the serial port but

00:32:57,630 --> 00:33:02,539
the thing is you can kind of split this

00:33:00,060 --> 00:33:05,179
into multiple tasks that

00:33:02,539 --> 00:33:09,139
you can pre configure the clock and the

00:33:05,179 --> 00:33:11,360
pin muxing within your board file and

00:33:09,139 --> 00:33:14,179
just focus on writing the serial port

00:33:11,360 --> 00:33:16,850
driver now once you have the serial port

00:33:14,179 --> 00:33:18,830
driver implemented you can slowly move

00:33:16,850 --> 00:33:22,279
on and implement the clock driver then

00:33:18,830 --> 00:33:24,500
remove the ad hoc clock configuration

00:33:22,279 --> 00:33:26,690
from your board file and once you have

00:33:24,500 --> 00:33:29,720
that working you can again write a pin

00:33:26,690 --> 00:33:33,230
control driver and remove the ad hoc pin

00:33:29,720 --> 00:33:34,759
configuration from your report file so

00:33:33,230 --> 00:33:38,720
this is what you can do you can get to

00:33:34,759 --> 00:33:41,509
split this task into multiple so if you

00:33:38,720 --> 00:33:44,240
are adding any sort of new stuff into

00:33:41,509 --> 00:33:45,889
u-boot that are pretty much like three

00:33:44,240 --> 00:33:49,190
things you can add a complete

00:33:45,889 --> 00:33:50,919
architecture support if you do that that

00:33:49,190 --> 00:33:54,379
sort of stuff goes into our slash

00:33:50,919 --> 00:33:58,940
through for example arc slash maps would

00:33:54,379 --> 00:34:00,799
be a new MIPS architecture support if

00:33:58,940 --> 00:34:03,409
you are adding new architecture it would

00:34:00,799 --> 00:34:07,399
be really a good idea if you also added

00:34:03,409 --> 00:34:09,710
at least single board so that you would

00:34:07,399 --> 00:34:11,210
can be continuing the u-boot continues

00:34:09,710 --> 00:34:12,859
integration can be done on that

00:34:11,210 --> 00:34:16,790
architecture so it doesn't stop bit

00:34:12,859 --> 00:34:19,639
routing now if you are adding new board

00:34:16,790 --> 00:34:23,470
support that will go into like board

00:34:19,639 --> 00:34:26,000
slash manufacturer name slash birth name

00:34:23,470 --> 00:34:29,419
all right and what you need to fill in

00:34:26,000 --> 00:34:32,750
there is a config file make file and

00:34:29,419 --> 00:34:36,050
your port file dot C although if you're

00:34:32,750 --> 00:34:38,030
adding a new board the board file dot C

00:34:36,050 --> 00:34:39,800
should not contain anything pretty much

00:34:38,030 --> 00:34:41,500
it should be just a sort of like a

00:34:39,800 --> 00:34:44,929
placeholder file for the build system

00:34:41,500 --> 00:34:46,940
ideally it should be empty all the stuff

00:34:44,929 --> 00:34:51,260
you should be adding should just be in

00:34:46,940 --> 00:34:53,089
drivers and in device three you will

00:34:51,260 --> 00:34:56,240
this need to also add a configuration

00:34:53,089 --> 00:34:58,730
file which will go into config slash

00:34:56,240 --> 00:35:01,339
your board F config and probably a

00:34:58,730 --> 00:35:03,349
couple of legacy configuration options

00:35:01,339 --> 00:35:07,069
which will go into include configs your

00:35:03,349 --> 00:35:09,410
board age you also need to link the

00:35:07,069 --> 00:35:12,920
board's cake or fake into your

00:35:09,410 --> 00:35:14,040
architecture cake config files so there

00:35:12,920 --> 00:35:16,710
will be like a

00:35:14,040 --> 00:35:21,600
the line pointing to this config file in

00:35:16,710 --> 00:35:23,580
our ex leche something the other thing

00:35:21,600 --> 00:35:28,470
you can add are obviously drivers which

00:35:23,580 --> 00:35:30,330
goes into drivers okay so let's take a

00:35:28,470 --> 00:35:33,150
look at how it looks when you add the

00:35:30,330 --> 00:35:35,160
driver so if you want to implement the

00:35:33,150 --> 00:35:37,800
u-boot driver model driver you use the

00:35:35,160 --> 00:35:40,410
you would driver macro to define such a

00:35:37,800 --> 00:35:42,930
driver and you give it single parameter

00:35:40,410 --> 00:35:45,420
which is the name of the driver now what

00:35:42,930 --> 00:35:48,600
this does actually behind the scenes is

00:35:45,420 --> 00:35:52,410
it generates a structure it prefixes the

00:35:48,600 --> 00:35:55,020
in this case serial SH with a couple of

00:35:52,410 --> 00:35:56,520
extra information but ultimately it

00:35:55,020 --> 00:35:59,280
generates a structure which is put into

00:35:56,520 --> 00:36:03,420
a special ubud section alongside the

00:35:59,280 --> 00:36:06,180
other drivers so each of these driver

00:36:03,420 --> 00:36:09,900
structures must have a name of the

00:36:06,180 --> 00:36:12,150
driver which is different than this one

00:36:09,900 --> 00:36:14,880
or can be different than the name of the

00:36:12,150 --> 00:36:16,890
structure all right

00:36:14,880 --> 00:36:20,820
you should come up with a sensible name

00:36:16,890 --> 00:36:24,390
though obviously it has to have you boot

00:36:20,820 --> 00:36:26,610
you class which specifies what type of

00:36:24,390 --> 00:36:28,860
driver is this in case of a serial port

00:36:26,610 --> 00:36:32,550
driver it's you class serial

00:36:28,860 --> 00:36:34,740
it must have also driver ops associated

00:36:32,550 --> 00:36:36,810
with it this has to match the you class

00:36:34,740 --> 00:36:40,110
so these are the operations which the

00:36:36,810 --> 00:36:41,940
driver is providing to the u-boot in

00:36:40,110 --> 00:36:44,970
case of a huge serial driver it's like

00:36:41,940 --> 00:36:47,210
get and set character and so on this

00:36:44,970 --> 00:36:50,040
sort of stuff I'll show you in a bit

00:36:47,210 --> 00:36:53,490
in case the driver is device three

00:36:50,040 --> 00:36:55,980
probing capable you will have OS match

00:36:53,490 --> 00:36:58,710
table for the device three compatible

00:36:55,980 --> 00:37:02,400
strings then obviously you need to have

00:36:58,710 --> 00:37:07,050
a probe function unlike the Linux kernel

00:37:02,400 --> 00:37:09,630
driver model all the private data of the

00:37:07,050 --> 00:37:12,810
driver are pre-allocated when the driver

00:37:09,630 --> 00:37:14,580
is instantiated so you do not or you

00:37:12,810 --> 00:37:16,650
should not use malloc and the probe

00:37:14,580 --> 00:37:18,870
function there is no need for that you

00:37:16,650 --> 00:37:22,770
can just have the pre allocation of the

00:37:18,870 --> 00:37:23,360
private data now what else do we have

00:37:22,770 --> 00:37:27,020
here

00:37:23,360 --> 00:37:28,820
oh yeah right in case you want to

00:37:27,020 --> 00:37:32,330
support both device three probing and

00:37:28,820 --> 00:37:35,030
all platform data probing the u-boot

00:37:32,330 --> 00:37:37,160
driver model is capable of that actually

00:37:35,030 --> 00:37:39,260
you can provide a function which

00:37:37,160 --> 00:37:40,850
converts device three data into platform

00:37:39,260 --> 00:37:44,390
data again the platform data are

00:37:40,850 --> 00:37:46,880
pre-allocated here and this is

00:37:44,390 --> 00:37:49,400
convenient because then you can take the

00:37:46,880 --> 00:37:51,230
device three data pre convert them into

00:37:49,400 --> 00:37:53,630
some sort of structure and then pass

00:37:51,230 --> 00:37:56,270
that to the bind function and the probe

00:37:53,630 --> 00:37:59,830
function so neither of these functions

00:37:56,270 --> 00:38:03,500
has to mess with device three at all

00:37:59,830 --> 00:38:06,410
finally there is this flags and three

00:38:03,500 --> 00:38:07,730
which is just saying that this is a

00:38:06,410 --> 00:38:10,270
serial port driver it should be

00:38:07,730 --> 00:38:12,620
available early on in the boot process

00:38:10,270 --> 00:38:15,320
yeah this is the device three probing

00:38:12,620 --> 00:38:16,880
and how that works so you have a table

00:38:15,320 --> 00:38:19,280
of compatible entries

00:38:16,880 --> 00:38:22,160
that's the Oh F match here similar to

00:38:19,280 --> 00:38:24,020
the Linux kernel conversion of the

00:38:22,160 --> 00:38:26,540
device three data the platform data is

00:38:24,020 --> 00:38:30,170
implemented using this function which in

00:38:26,540 --> 00:38:32,420
this example is pulling out register

00:38:30,170 --> 00:38:36,200
offset or the base address of this

00:38:32,420 --> 00:38:38,120
platform from the device three and if it

00:38:36,200 --> 00:38:41,540
is father that is just setting it into

00:38:38,120 --> 00:38:43,130
the platform data so this value will be

00:38:41,540 --> 00:38:44,990
available to the probe function and

00:38:43,130 --> 00:38:47,510
point function and can use that value

00:38:44,990 --> 00:38:52,810
immediately without having to pull it

00:38:47,510 --> 00:38:56,150
from the device three again and yeah the

00:38:52,810 --> 00:38:58,040
platform data are pre-allocated so I'm

00:38:56,150 --> 00:39:00,800
just specifying in the u-boot driver

00:38:58,040 --> 00:39:02,390
structure how much of a data I want to

00:39:00,800 --> 00:39:04,970
pre allocate for the platform later

00:39:02,390 --> 00:39:08,030
now finally the implementation of ops

00:39:04,970 --> 00:39:11,390
looks like this for the serial port it's

00:39:08,030 --> 00:39:17,120
TM serial ops which contain gets he put

00:39:11,390 --> 00:39:19,970
C implementations which just get and

00:39:17,120 --> 00:39:22,580
send character over the serial port we

00:39:19,970 --> 00:39:26,660
have implementation of pending function

00:39:22,580 --> 00:39:30,410
which is there to check whether there is

00:39:26,660 --> 00:39:32,270
character pending in the you at FIFO so

00:39:30,410 --> 00:39:35,120
if the UART received any character it's

00:39:32,270 --> 00:39:36,620
like test C and we have set B RG which

00:39:35,120 --> 00:39:38,540
is set bout rate generator

00:39:36,620 --> 00:39:40,490
and actually all these functions have to

00:39:38,540 --> 00:39:42,350
be implemented here is an implementation

00:39:40,490 --> 00:39:44,840
that you have to get see well there

00:39:42,350 --> 00:39:46,250
should be register poking in here except

00:39:44,840 --> 00:39:49,040
it's calling some sort of generic

00:39:46,250 --> 00:39:50,780
function so it's not explicitly there

00:39:49,040 --> 00:39:53,840
but there would be some sort of memory

00:39:50,780 --> 00:39:58,370
rights and memory reads in this function

00:39:53,840 --> 00:40:01,760
implementation also there is one more

00:39:58,370 --> 00:40:04,130
detail in case you need a little serial

00:40:01,760 --> 00:40:07,070
console like before the driver model is

00:40:04,130 --> 00:40:10,400
running you would support that through

00:40:07,070 --> 00:40:14,120
config debug you are but it's quite

00:40:10,400 --> 00:40:16,490
specific and in case you're interested

00:40:14,120 --> 00:40:18,830
in that just look up the config debug

00:40:16,490 --> 00:40:20,810
UART in in you boot it's mostly if you

00:40:18,830 --> 00:40:22,640
have like a dedicated debug you are you

00:40:20,810 --> 00:40:26,150
can implement that most of the

00:40:22,640 --> 00:40:29,270
platform's do not implement it this is

00:40:26,150 --> 00:40:31,640
how it looks like if you enable this for

00:40:29,270 --> 00:40:33,950
example on the anther or implements a

00:40:31,640 --> 00:40:36,800
couple of functions which explicitly in

00:40:33,950 --> 00:40:40,730
it the complete serial hardware and then

00:40:36,800 --> 00:40:43,400
allow you to print on the serial port of

00:40:40,730 --> 00:40:45,770
the debug keyword directly by just

00:40:43,400 --> 00:40:51,350
poking the registers so it's a sort of a

00:40:45,770 --> 00:40:53,330
hack ish anyway the other thing I wanted

00:40:51,350 --> 00:40:54,980
to talk about this quad framework which

00:40:53,330 --> 00:40:59,210
from the implement from the driver

00:40:54,980 --> 00:41:01,250
implementation point of view looks quite

00:40:59,210 --> 00:41:03,650
similar to the serial port I mean it

00:41:01,250 --> 00:41:08,150
just contains different you voodoo class

00:41:03,650 --> 00:41:10,310
ID and different ops which contains

00:41:08,150 --> 00:41:13,310
something like enable clock disable

00:41:10,310 --> 00:41:16,730
clock get rate and set rate so that's

00:41:13,310 --> 00:41:17,900
kind of boring but what I would like to

00:41:16,730 --> 00:41:20,660
show you is how it looks from the

00:41:17,900 --> 00:41:22,880
consumer side so a consumer of the clock

00:41:20,660 --> 00:41:26,300
framework is using CLK underscore

00:41:22,880 --> 00:41:28,250
functions in this case I am again

00:41:26,300 --> 00:41:32,030
pulling this out from the serial port

00:41:28,250 --> 00:41:34,640
driver so what this does is first of all

00:41:32,030 --> 00:41:40,190
it looks up the clock based on the

00:41:34,640 --> 00:41:42,800
device 3 and 3 in the serial node so if

00:41:40,190 --> 00:41:46,250
the serial node contains the fck clock

00:41:42,800 --> 00:41:48,180
entry it will populate this through

00:41:46,250 --> 00:41:51,180
clock

00:41:48,180 --> 00:41:52,950
now if this works out we will have

00:41:51,180 --> 00:41:57,510
followed the reference to the club

00:41:52,950 --> 00:41:59,910
drivers clock handle and we can do with

00:41:57,510 --> 00:42:03,270
that stuff like enable those clock and

00:41:59,910 --> 00:42:05,910
get that rate this is what we can do

00:42:03,270 --> 00:42:08,760
with using the clock framework

00:42:05,910 --> 00:42:10,920
obviously this platform would have to

00:42:08,760 --> 00:42:15,480
have implemented and instantiate that

00:42:10,920 --> 00:42:17,670
clock driver the last thing I want to

00:42:15,480 --> 00:42:20,480
talk about is pin control framework

00:42:17,670 --> 00:42:23,040
which again from the driver

00:42:20,480 --> 00:42:29,099
implementation point of view is similar

00:42:23,040 --> 00:42:30,540
to the serial port driver except the pin

00:42:29,099 --> 00:42:34,559
control framework is kind of two

00:42:30,540 --> 00:42:36,390
frameworks in one so that might be a

00:42:34,559 --> 00:42:39,030
little confusing the pin control

00:42:36,390 --> 00:42:40,829
framework implements two functionality

00:42:39,030 --> 00:42:43,619
is one of them is pin marks which allows

00:42:40,829 --> 00:42:47,970
you to select which of the blocks within

00:42:43,619 --> 00:42:51,900
the CPU gets most to a specific pin on

00:42:47,970 --> 00:42:53,250
the CPU package and pin con which allows

00:42:51,900 --> 00:42:57,720
you to select the properties of the

00:42:53,250 --> 00:43:01,650
specific CPU pin like voltage pull up

00:42:57,720 --> 00:43:04,500
pull down this server properties now all

00:43:01,650 --> 00:43:07,349
of that from the consumer side is

00:43:04,500 --> 00:43:13,230
selected in like one fell swoop just by

00:43:07,349 --> 00:43:16,559
calling pin control select state and the

00:43:13,230 --> 00:43:18,780
way this whole thing looks like is that

00:43:16,559 --> 00:43:21,930
in the rice tree you have multiple

00:43:18,780 --> 00:43:24,440
entries one for each possible pin

00:43:21,930 --> 00:43:27,450
configuration of a pin control group and

00:43:24,440 --> 00:43:31,829
then the driver which is the consumer of

00:43:27,450 --> 00:43:35,400
that pin control group just select one

00:43:31,829 --> 00:43:36,690
of these pin states that is if you call

00:43:35,400 --> 00:43:38,609
the pin control select state it

00:43:36,690 --> 00:43:41,339
reconfigures and then entire a group of

00:43:38,609 --> 00:43:43,140
pins it selects the multiplex saying it

00:43:41,339 --> 00:43:45,210
selects the voltage levels the pull-ups

00:43:43,140 --> 00:43:50,910
pull-downs and so on so you do not do it

00:43:45,210 --> 00:43:52,500
on a bare pin basis okay

00:43:50,910 --> 00:43:54,540
that's pretty much it for the pin

00:43:52,500 --> 00:43:56,760
control the other frameworks they are

00:43:54,540 --> 00:43:59,530
also quite similar they are pretty much

00:43:56,760 --> 00:44:02,890
converted except for writing MTD which

00:43:59,530 --> 00:44:05,050
missing couple of things but in general

00:44:02,890 --> 00:44:09,340
most of you boot is converted now to

00:44:05,050 --> 00:44:10,720
driver model if there are some legacy

00:44:09,340 --> 00:44:13,840
things which are not getting converted

00:44:10,720 --> 00:44:16,300
they will most likely soon be removed so

00:44:13,840 --> 00:44:17,740
in case you still have something which

00:44:16,300 --> 00:44:20,230
you care about in Ubud which is not

00:44:17,740 --> 00:44:22,450
converted to device three control and

00:44:20,230 --> 00:44:28,000
driver model now is the time to do it

00:44:22,450 --> 00:44:29,740
and submit patches but enabling driver

00:44:28,000 --> 00:44:31,210
model and device three control will make

00:44:29,740 --> 00:44:37,270
you would grow up a bit

00:44:31,210 --> 00:44:40,300
possible considerably so we should talk

00:44:37,270 --> 00:44:41,770
about reducing the size of you booth

00:44:40,300 --> 00:44:44,710
there's one thing which is kind of

00:44:41,770 --> 00:44:46,320
orthogonal to driver model and device

00:44:44,710 --> 00:44:48,700
three control which is you would SPL

00:44:46,320 --> 00:44:52,990
because this has been in for quite a

00:44:48,700 --> 00:44:55,630
while and the USP L is basically a small

00:44:52,990 --> 00:44:58,980
build of you booth which is responsible

00:44:55,630 --> 00:45:01,930
to fit usually into an on-chip Ram

00:44:58,980 --> 00:45:05,400
initialize the deer m then load the new

00:45:01,930 --> 00:45:08,020
boot and execute the you boot in RAM and

00:45:05,400 --> 00:45:10,030
this is especially important for systems

00:45:08,020 --> 00:45:12,400
which have some sort of size limitations

00:45:10,030 --> 00:45:16,170
now the you would SPL can be configured

00:45:12,400 --> 00:45:18,460
in such a way that it doesn't have

00:45:16,170 --> 00:45:20,770
device tree control it doesn't have

00:45:18,460 --> 00:45:23,710
driver model these are optional in the

00:45:20,770 --> 00:45:27,040
u.s. PL and the you SPL properties can

00:45:23,710 --> 00:45:28,900
be configured separately from the main

00:45:27,040 --> 00:45:31,420
you but it has like config underscore

00:45:28,900 --> 00:45:34,450
SPL options so if you have like board

00:45:31,420 --> 00:45:36,220
def config you can select how the SPL

00:45:34,450 --> 00:45:38,830
will look like and how the u-boot will

00:45:36,220 --> 00:45:40,150
look like it could also happen that you

00:45:38,830 --> 00:45:42,190
will run into something called you boot

00:45:40,150 --> 00:45:44,950
TPL which is like ternary program loader

00:45:42,190 --> 00:45:47,830
I hope you will not run into it but

00:45:44,950 --> 00:45:49,660
there are specific use cases where you

00:45:47,830 --> 00:45:51,640
need to strip down you would even

00:45:49,660 --> 00:45:54,310
further it to like units of kilobytes

00:45:51,640 --> 00:45:58,349
and this is what the TPL is for but this

00:45:54,310 --> 00:45:58,349
is usually super board specific and

00:45:59,119 --> 00:46:03,329
you really need to know what you're

00:46:01,559 --> 00:46:07,529
doing if you are getting yourself into

00:46:03,329 --> 00:46:10,469
the u-boot TPL stuff now i said that in

00:46:07,529 --> 00:46:13,229
this PL you can strip out the driver

00:46:10,469 --> 00:46:16,109
model and device three control this is

00:46:13,229 --> 00:46:18,869
possible but there are also other ways

00:46:16,109 --> 00:46:22,049
to reduce the u-boot size so on the SPL

00:46:18,869 --> 00:46:24,029
if you use device three control all the

00:46:22,049 --> 00:46:26,369
nodes from the control device three will

00:46:24,029 --> 00:46:29,309
be stripped if they don't contain you

00:46:26,369 --> 00:46:34,109
booty and prieur a log entry and this is

00:46:29,309 --> 00:46:36,119
to reduce the device three blob size it

00:46:34,109 --> 00:46:38,369
can be quite considerably big the device

00:46:36,119 --> 00:46:39,719
three blob so what we knew is we

00:46:38,369 --> 00:46:42,359
stripped out everything which is not

00:46:39,719 --> 00:46:44,009
needed for the Ubud SPL to actually

00:46:42,359 --> 00:46:48,299
initialize itself and load the next

00:46:44,009 --> 00:46:49,589
stage this way another thing is you can

00:46:48,299 --> 00:46:51,420
completely remove the device three

00:46:49,589 --> 00:46:54,449
control and then probe all the drivers

00:46:51,420 --> 00:46:56,309
from your board file are using platform

00:46:54,449 --> 00:46:58,739
data so that's another option because

00:46:56,309 --> 00:47:01,380
the lip ftt itself is quite large in

00:46:58,739 --> 00:47:05,779
size and yeah this can help you reduce

00:47:01,380 --> 00:47:08,309
the boot size a little bit further and

00:47:05,779 --> 00:47:12,109
this is pretty much it for this entire

00:47:08,309 --> 00:47:14,459
talk i should probably wrap it up but

00:47:12,109 --> 00:47:16,440
what I would suggest you is if you're

00:47:14,459 --> 00:47:17,269
doing new you would talk new you're good

00:47:16,440 --> 00:47:19,589
port

00:47:17,269 --> 00:47:23,670
please use device three control and

00:47:19,589 --> 00:47:25,319
Driver model absolutely we use as much

00:47:23,670 --> 00:47:28,049
code as possible so if there are drivers

00:47:25,319 --> 00:47:30,900
which you can reuse just do that extend

00:47:28,049 --> 00:47:32,369
them submit patches if you have any

00:47:30,900 --> 00:47:33,989
questions they could look into the boot

00:47:32,369 --> 00:47:36,059
documentation and the doctor directory

00:47:33,989 --> 00:47:37,680
if you have questions which I don't know

00:47:36,059 --> 00:47:39,449
the answer there or if you want to just

00:47:37,680 --> 00:47:42,119
some sort of real-time interaction with

00:47:39,449 --> 00:47:44,069
the u-boot developers you're welcome to

00:47:42,119 --> 00:47:47,729
visit the u-boot IRC on freenode

00:47:44,069 --> 00:47:49,739
you are also welcome to send any

00:47:47,729 --> 00:47:52,319
questions or patches to the mailing list

00:47:49,739 --> 00:47:53,430
that would be very nice and with that I

00:47:52,319 --> 00:47:57,289
would like to thank you for your

00:47:53,430 --> 00:48:00,949
attention and do you have any questions

00:47:57,289 --> 00:48:00,949
yeah go ahead

00:48:09,290 --> 00:48:14,310
so the question is if the SPL is used

00:48:12,150 --> 00:48:18,750
typically if you need to initialize DRAM

00:48:14,310 --> 00:48:21,060
and ubud image yet that's it pretty much

00:48:18,750 --> 00:48:23,430
so the systems on which he would SPL is

00:48:21,060 --> 00:48:25,470
used are those where the butum does not

00:48:23,430 --> 00:48:27,720
initialize the DRAM you need to load

00:48:25,470 --> 00:48:29,790
some sort of small piece of code into

00:48:27,720 --> 00:48:31,290
their own chip Ram which does the

00:48:29,790 --> 00:48:33,450
initialization for you and then loads

00:48:31,290 --> 00:48:36,600
the next stage and the thing I missed

00:48:33,450 --> 00:48:38,880
when I spoke about the you SPL is that

00:48:36,600 --> 00:48:42,270
the you SPL does not necessarily have to

00:48:38,880 --> 00:48:44,400
load you would proper it can load linux

00:48:42,270 --> 00:48:51,290
directly as well that's called the

00:48:44,400 --> 00:48:51,290
Falcon Falcon boot mode thanks yeah

00:49:06,550 --> 00:49:10,390
so the question is with all the you

00:49:09,160 --> 00:49:13,300
would version you have to initialize

00:49:10,390 --> 00:49:15,610
memory in the board file and if this can

00:49:13,300 --> 00:49:18,070
be placed into the device 3 this is

00:49:15,610 --> 00:49:20,440
actually platform specific and there are

00:49:18,070 --> 00:49:22,090
platforms which to initialize memory

00:49:20,440 --> 00:49:22,990
controller based on information in the

00:49:22,090 --> 00:49:29,130
device 3 already

00:49:22,990 --> 00:49:29,130
so yes yeah go ahead

00:49:37,500 --> 00:49:42,850
so the question is how difficult it is

00:49:40,210 --> 00:49:46,180
to take a Linux driver and port it over

00:49:42,850 --> 00:49:49,390
to you boot that depends on which

00:49:46,180 --> 00:49:51,820
subsystem you're reporting it to the USB

00:49:49,390 --> 00:49:55,300
subsystem is trying to be held in sync

00:49:51,820 --> 00:49:57,070
with Linux kernels so in that subsystem

00:49:55,300 --> 00:50:00,040
it's not that difficult you obviously

00:49:57,070 --> 00:50:03,220
need to do some sort of adjustments but

00:50:00,040 --> 00:50:07,470
in general it should not be that hard to

00:50:03,220 --> 00:50:07,470
the reporting if you have the code ones

00:50:09,780 --> 00:50:14,560
yeah if you're starting some sort of

00:50:12,100 --> 00:50:16,330
worth port then yeah getting the serial

00:50:14,560 --> 00:50:18,310
port running this is the most difficult

00:50:16,330 --> 00:50:26,170
one because you have no indication from

00:50:18,310 --> 00:50:30,040
the board that it's doing anything it

00:50:26,170 --> 00:50:33,460
depends on the on the subsystem like I

00:50:30,040 --> 00:50:37,090
said the USB is good in that it's mostly

00:50:33,460 --> 00:50:39,460
in sync with Linux I believe we are now

00:50:37,090 --> 00:50:42,970
getting SPI no subsystem imported from

00:50:39,460 --> 00:50:44,710
Linux which will be very good then you

00:50:42,970 --> 00:50:49,690
will be able to just pull in all the SPI

00:50:44,710 --> 00:50:51,840
drivers from Linux easily thanks any

00:50:49,690 --> 00:50:55,140
other questions

00:50:51,840 --> 00:50:55,140
yeah go ahead

00:50:57,910 --> 00:51:00,969
[Music]

00:51:01,150 --> 00:51:06,190
so the question is if you have secured

00:51:03,610 --> 00:51:09,220
booth enabled in you booth when does the

00:51:06,190 --> 00:51:10,450
signature check-in happen well I cannot

00:51:09,220 --> 00:51:14,890
really answer that because I don't know

00:51:10,450 --> 00:51:17,950
which platform you are using so this is

00:51:14,890 --> 00:51:20,050
kind of specific to the platform usually

00:51:17,950 --> 00:51:22,660
what happens is that the bootrom on that

00:51:20,050 --> 00:51:24,730
platform is doing some sort of signature

00:51:22,660 --> 00:51:27,580
check of the next stage which would be

00:51:24,730 --> 00:51:29,230
probably the UBS pl and then the UBS PL

00:51:27,580 --> 00:51:31,570
is able to continue that sort of chain

00:51:29,230 --> 00:51:34,570
of trust and verify that you boot has

00:51:31,570 --> 00:51:37,840
not been tampered with and move on from

00:51:34,570 --> 00:51:40,240
there to Linux and so on so that's the

00:51:37,840 --> 00:51:43,480
generic way to do it we can talk about

00:51:40,240 --> 00:51:50,340
that later if you want Thanks

00:51:43,480 --> 00:51:50,340
any other questions yeah good

00:52:02,350 --> 00:52:05,470
so the question is that the device three

00:52:04,120 --> 00:52:07,480
files are both in the Linux kernel

00:52:05,470 --> 00:52:10,180
source 3 and then the u-boot source 3

00:52:07,480 --> 00:52:11,890
and possibly in other places and if

00:52:10,180 --> 00:52:13,750
there is any effort to actually unify

00:52:11,890 --> 00:52:16,000
them so what happens on the u-boot size

00:52:13,750 --> 00:52:19,390
is we are synchronizing the device 3

00:52:16,000 --> 00:52:21,250
files from the Linux kernel and yeah

00:52:19,390 --> 00:52:22,810
ideally they should be pulled out from

00:52:21,250 --> 00:52:25,060
all these places and we should have it

00:52:22,810 --> 00:52:27,370
like one single repository with device

00:52:25,060 --> 00:52:29,380
trees but I believe that's a question

00:52:27,370 --> 00:52:32,250
for the device three masters really when

00:52:29,380 --> 00:52:32,250
this is going to happen

00:52:45,410 --> 00:53:08,960
well device three is supposed to be a

00:52:47,600 --> 00:53:10,730
stable ABI yes right yeah so the

00:53:08,960 --> 00:53:12,230
question is that there are a couple of

00:53:10,730 --> 00:53:15,140
places where the Ubud bindings did

00:53:12,230 --> 00:53:17,600
diverge from the linux bindings which I

00:53:15,140 --> 00:53:19,840
believe is through I wouldn't be

00:53:17,600 --> 00:53:24,980
surprised by that what's that

00:53:19,840 --> 00:53:29,990
ouch okay yeah so ideally patches are

00:53:24,980 --> 00:53:33,110
welcome hubris to a community project

00:53:29,990 --> 00:53:35,240
and unless someone does the cleanup and

00:53:33,110 --> 00:53:38,660
the work then we're not getting anywhere

00:53:35,240 --> 00:53:40,370
with that but yeah if there is a problem

00:53:38,660 --> 00:53:42,800
in the regulator framework it definitely

00:53:40,370 --> 00:53:52,040
should be fixed up to match the linux

00:53:42,800 --> 00:53:54,080
bindings it has to be done I'll try to

00:53:52,040 --> 00:53:54,710
bring it up with the regulator

00:53:54,080 --> 00:53:58,360
maintainer

00:53:54,710 --> 00:53:58,360
thanks for letting me know about that

00:53:58,990 --> 00:54:01,990
yeah

00:54:09,630 --> 00:54:13,170
so the question is if there is a

00:54:11,550 --> 00:54:15,540
possibility of having like multiple

00:54:13,170 --> 00:54:17,730
device 3 attached to you boot and you

00:54:15,540 --> 00:54:19,800
would can select that based on some sort

00:54:17,730 --> 00:54:21,360
of pin configuration I believe there is

00:54:19,800 --> 00:54:23,400
something like that as a really new

00:54:21,360 --> 00:54:26,490
feature so it happened like very

00:54:23,400 --> 00:54:31,380
recently that you but can have multiple

00:54:26,490 --> 00:54:33,510
device 3 attached to it I would grab in

00:54:31,380 --> 00:54:36,810
the device in the u-boot source 3 for

00:54:33,510 --> 00:54:39,060
multi underscore fit or multi underscore

00:54:36,810 --> 00:54:42,180
dtb or multi image something like that

00:54:39,060 --> 00:54:45,380
and it landed really very recently in

00:54:42,180 --> 00:54:48,030
new boot yes there is such a possibility

00:54:45,380 --> 00:54:49,920
the other option which you could do if

00:54:48,030 --> 00:54:53,010
your boards are kind of similar to one

00:54:49,920 --> 00:54:55,740
another is apply device 3 overlays on

00:54:53,010 --> 00:54:57,450
the u-boot the live device 3 this is

00:54:55,740 --> 00:55:00,180
also possible nowadays with a bit of

00:54:57,450 --> 00:55:03,450
effort so then you can kind of factor

00:55:00,180 --> 00:55:06,710
out only those changes which you have

00:55:03,450 --> 00:55:13,290
specific to your different devices

00:55:06,710 --> 00:55:17,390
Thanks any more questions no more

00:55:13,290 --> 00:55:17,390
questions so thank you very much

00:55:19,360 --> 00:55:22,599

YouTube URL: https://www.youtube.com/watch?v=rJtlAi8rxgs


