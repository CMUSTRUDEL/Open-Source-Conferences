Title: What Every Driver Developer Should Know about RT - Julia Cartwright, National Instruments
Publication date: 2018-03-14
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	What Every Driver Developer Should Know about RT - Julia Cartwright, National Instruments

PREEMPT_RT, also known as "the rt patch" is a patchset ontop of the vanilla Linux kernel which helps provide bound timing guarantees for user task execution, a required property for any real-time application.

The rt patch has a long history out of mainline. What used to be a slow trickle of patches moving from the rt patch to mainline has now accelerated with the formation of the Real Time Linux LF project, which is actively funding the engineering work necessary to bring merge the patch into mainline.

However, long after the core PREEMPT_RT changes land in mainline, we'll still be stuck dealing with a long tail of problems in Linux's thousands of device drivers. The intent of this presentation is to describe the classes of problems in drivers which have detrimental impact to RT, why they cause issues on RT, and how they might be resolved."

About Julia Cartwright
Julia is a software engineer at National Instruments where she's been involved in Linux Kernel and device driver projects spanning nearly ten years. Her most active interests are real-time system design and the PREEMPT_RT patch. She's currently acting maintainer on a stable release of the RT patch. Her other interests include task scheduling, ARM SoC support, FPGAs, and power management.

She's previously spoken at a variety of venues including ELC, the Embedded Systems Conference (ESC), the Real-Time Linux Workshop (RTLWS) and the Real-Time Summit. On any given day, you can also find her answering questions on the linux-rt-users mailing list and on IRC in #linux-rt and #kernelnewbies on OFTC.
Captions: 
	00:00:00,030 --> 00:00:06,859
all right everyone ready how many of you

00:00:03,330 --> 00:00:09,360
came from Stephens firehose I mean talk

00:00:06,859 --> 00:00:11,960
all right those of us that have seen

00:00:09,360 --> 00:00:15,210
Stephen present for years know how

00:00:11,960 --> 00:00:16,650
overwhelming it could be at times so my

00:00:15,210 --> 00:00:18,810
name is Julia Cartwright I work in

00:00:16,650 --> 00:00:21,630
National Instruments I'm also one of the

00:00:18,810 --> 00:00:24,570
stable real time maintainer zazz even

00:00:21,630 --> 00:00:26,090
image in the last presentation I've been

00:00:24,570 --> 00:00:30,449
involved in Linux for about ten years

00:00:26,090 --> 00:00:35,340
involved in the RT project for about six

00:00:30,449 --> 00:00:36,420
years I think at this point I maintain

00:00:35,340 --> 00:00:38,460
one of the stable releases actually two

00:00:36,420 --> 00:00:40,440
of the stable releases as Steven

00:00:38,460 --> 00:00:42,030
mentioned but I've also followed the

00:00:40,440 --> 00:00:45,149
Atlantic's RT users list so there's a

00:00:42,030 --> 00:00:46,739
mailing list feature kernel.org this is

00:00:45,149 --> 00:00:48,390
a user list where a lot of people talk

00:00:46,739 --> 00:00:50,969
about the issues that they've run into

00:00:48,390 --> 00:00:53,160
lots of bug reports happen there and

00:00:50,969 --> 00:00:55,649
from this information gathered over

00:00:53,160 --> 00:00:58,910
years it's pretty clear to see that

00:00:55,649 --> 00:01:02,160
there are different classes of bugs that

00:00:58,910 --> 00:01:04,979
our users the prematurity users are

00:01:02,160 --> 00:01:06,810
running into and reporting that are

00:01:04,979 --> 00:01:09,360
issues in actually issues and device

00:01:06,810 --> 00:01:12,210
drivers so the purpose of this

00:01:09,360 --> 00:01:13,530
presentation is to present these issues

00:01:12,210 --> 00:01:14,670
as they exist and I'll talk about some

00:01:13,530 --> 00:01:18,150
of the features to even mentioned like

00:01:14,670 --> 00:01:20,040
local locks and so on as we go along so

00:01:18,150 --> 00:01:24,979
how many of you are actually running

00:01:20,040 --> 00:01:24,979
preempt RT in production right now I

00:01:25,670 --> 00:01:30,900
would have expected more honestly so how

00:01:28,740 --> 00:01:34,140
many of you are like evaluating it as a

00:01:30,900 --> 00:01:36,240
potential future our toss platform about

00:01:34,140 --> 00:01:38,340
the same okay that's interesting

00:01:36,240 --> 00:01:40,710
all right well maybe I hope you will

00:01:38,340 --> 00:01:42,840
find this interesting how many you view

00:01:40,710 --> 00:01:45,689
work on upstream device drivers within

00:01:42,840 --> 00:01:48,030
the community great you are kind of my

00:01:45,689 --> 00:01:50,880
target audience so if anything I say is

00:01:48,030 --> 00:01:55,380
unclear you have any questions please

00:01:50,880 --> 00:01:56,729
ask so I'm going to talk about a class

00:01:55,380 --> 00:01:59,579
of systems that we all run into if you

00:01:56,729 --> 00:02:05,909
if you're defining designing an embedded

00:01:59,579 --> 00:02:08,000
system that has did yeah oh no they

00:02:05,909 --> 00:02:11,390
don't see my slides I don't know how to

00:02:08,000 --> 00:02:11,390
have we not switched

00:02:13,319 --> 00:02:26,650
haha I'm that one nothing over here

00:02:16,810 --> 00:02:31,330
though okay alright great so now we

00:02:26,650 --> 00:02:33,250
haven't looked out yeah thank you so I'm

00:02:31,330 --> 00:02:35,290
gonna describe a class of what I'm

00:02:33,250 --> 00:02:36,970
calling mixed criticality systems so

00:02:35,290 --> 00:02:39,849
most complex embedded systems might have

00:02:36,970 --> 00:02:42,250
might run to different types of tasks

00:02:39,849 --> 00:02:43,540
you're gonna run task them to have some

00:02:42,250 --> 00:02:45,910
real time requirements and latency

00:02:43,540 --> 00:02:47,739
bounded latency requirements then you

00:02:45,910 --> 00:02:50,890
also might run some non time critical

00:02:47,739 --> 00:02:53,680
stuff you know doing basic monitoring or

00:02:50,890 --> 00:02:54,970
disk or or maybe not even any i/o or you

00:02:53,680 --> 00:02:58,930
have some throughput tasks whatever it

00:02:54,970 --> 00:03:00,030
is those two need to run together maybe

00:02:58,930 --> 00:03:02,230
need to communicate with one another

00:03:00,030 --> 00:03:05,920
it's mixed criticality in the sense that

00:03:02,230 --> 00:03:08,019
there's two different degrees of time

00:03:05,920 --> 00:03:09,489
sensitiveness so one way you might

00:03:08,019 --> 00:03:11,769
actually design this actually split it

00:03:09,489 --> 00:03:15,280
up into two different hardware devices

00:03:11,769 --> 00:03:17,049
you might have an arm series arc or on a

00:03:15,280 --> 00:03:18,850
board and you deploy your super time

00:03:17,049 --> 00:03:21,880
critical stuff there or maybe you're

00:03:18,850 --> 00:03:23,019
using like an FPGA or CPL d you're

00:03:21,880 --> 00:03:24,970
pushing all your super time-sensitive

00:03:23,019 --> 00:03:28,540
stuff onto a separate hardware device

00:03:24,970 --> 00:03:30,250
and then on unlike an arm a series chip

00:03:28,540 --> 00:03:33,430
maybe you're you're running Linux a full

00:03:30,250 --> 00:03:35,579
neck stack so this is this is one of the

00:03:33,430 --> 00:03:38,440
models however it has some downsides

00:03:35,579 --> 00:03:41,019
it's expensive per unit cost now you

00:03:38,440 --> 00:03:42,099
produce a board you have to have you

00:03:41,019 --> 00:03:44,709
know two different sets of hardware

00:03:42,099 --> 00:03:47,440
accomplishing two different things if

00:03:44,709 --> 00:03:50,109
there's is interaction between the mix

00:03:47,440 --> 00:03:51,250
criticality is like crossing the domains

00:03:50,109 --> 00:03:52,810
and now you have to define some

00:03:51,250 --> 00:03:55,359
communication channel between the two

00:03:52,810 --> 00:03:57,519
Hardware pieces that's up to you to

00:03:55,359 --> 00:03:59,260
define but you do get really good

00:03:57,519 --> 00:04:02,079
isolation so the stuff that's happening

00:03:59,260 --> 00:04:05,169
on the non real-time Linux side is an

00:04:02,079 --> 00:04:07,450
influencing your time critical stuff so

00:04:05,169 --> 00:04:09,370
some might choose this different set of

00:04:07,450 --> 00:04:10,720
trade-offs if you look at something like

00:04:09,370 --> 00:04:13,239
Zen oh my I don't know if you are all

00:04:10,720 --> 00:04:15,040
and yawns talk today he was talking

00:04:13,239 --> 00:04:17,109
about it's in a my and it's it's it

00:04:15,040 --> 00:04:19,570
follows this hypervisor I think they

00:04:17,109 --> 00:04:22,690
called the Co kernel approach it's

00:04:19,570 --> 00:04:26,140
effectively like you can you run

00:04:22,690 --> 00:04:29,440
a separate operating system within the

00:04:26,140 --> 00:04:30,940
realm of a well I'm gonna call it a

00:04:29,440 --> 00:04:32,980
hypervisor here it doesn't necessarily

00:04:30,940 --> 00:04:34,690
have to be a hypervisor there's a MP

00:04:32,980 --> 00:04:36,310
solutions where you can partition like

00:04:34,690 --> 00:04:38,200
okay these these cores are going to run

00:04:36,310 --> 00:04:41,980
free artists and these are going to run

00:04:38,200 --> 00:04:44,470
Linux again there's there's trade-offs

00:04:41,980 --> 00:04:46,150
to be made about usability and

00:04:44,470 --> 00:04:49,540
communication between these makes

00:04:46,150 --> 00:04:52,980
criticality systems premium tarty sort

00:04:49,540 --> 00:04:52,980
of just chosen a different path here

00:04:53,670 --> 00:04:58,750
systems that run preamp dirty are

00:04:55,870 --> 00:05:02,050
sharing the kernel they're sharing a

00:04:58,750 --> 00:05:05,140
scheduler they're sharing a device stack

00:05:02,050 --> 00:05:08,110
all the subsystems are being shared so

00:05:05,140 --> 00:05:09,690
you don't get as much isolation but you

00:05:08,110 --> 00:05:12,040
get a lot of usability benefits

00:05:09,690 --> 00:05:15,670
applications can just use standard Linux

00:05:12,040 --> 00:05:20,440
IPC mechanisms to communicate it's

00:05:15,670 --> 00:05:22,270
effectively like thinking that the

00:05:20,440 --> 00:05:25,030
traditional Linux process isolation

00:05:22,270 --> 00:05:30,000
model is good enough to isolate real

00:05:25,030 --> 00:05:32,410
time tasks from non real-time tasks and

00:05:30,000 --> 00:05:35,350
but like I said the driver stacks are

00:05:32,410 --> 00:05:40,960
shared between them and therefore the

00:05:35,350 --> 00:05:44,290
drivers can misbehave and so I'll talk

00:05:40,960 --> 00:05:46,150
about ways that they can misbehave but

00:05:44,290 --> 00:05:47,860
first I want to talk about latency this

00:05:46,150 --> 00:05:49,990
is what I'm going to call the Delta this

00:05:47,860 --> 00:05:53,200
is what we all care about if you care

00:05:49,990 --> 00:05:55,060
about real-time guarantees you have a

00:05:53,200 --> 00:05:56,560
time in which an external event occurs

00:05:55,060 --> 00:06:00,640
maybe it's an interrupt firing a timer

00:05:56,560 --> 00:06:02,650
or some i/o device saying hey I need to

00:06:00,640 --> 00:06:07,030
be serviced the time it takes from that

00:06:02,650 --> 00:06:10,600
event to occur until a the relevant

00:06:07,030 --> 00:06:14,740
real-time tasks actually execute this is

00:06:10,600 --> 00:06:15,850
my bound of defining naming Delta most

00:06:14,740 --> 00:06:18,040
of you should already know this if you

00:06:15,850 --> 00:06:19,419
care about real-time systems real-time

00:06:18,040 --> 00:06:23,040
systems will try to characterize and

00:06:19,419 --> 00:06:25,780
bound this and some meaningful way so

00:06:23,040 --> 00:06:27,520
this is how this is one of the example

00:06:25,780 --> 00:06:28,810
texting techniques that the RTE

00:06:27,520 --> 00:06:30,460
community especially the prematurity

00:06:28,810 --> 00:06:32,740
community uses to characterize this

00:06:30,460 --> 00:06:34,770
Delta so this is a super simplified

00:06:32,740 --> 00:06:36,550
version of a test we call cyclic test

00:06:34,770 --> 00:06:38,650
so stick to stick with

00:06:36,550 --> 00:06:40,810
test is pretty simple all it does is

00:06:38,650 --> 00:06:42,850
take a time stamp and it sleeps for a

00:06:40,810 --> 00:06:44,740
fixed duration say like 10 milliseconds

00:06:42,850 --> 00:06:47,350
and then takes a time stamp when that

00:06:44,740 --> 00:06:49,480
threat is woken up and if you take the

00:06:47,350 --> 00:06:51,940
difference between those two time stamps

00:06:49,480 --> 00:06:54,460
I've collected that's the amount of time

00:06:51,940 --> 00:06:55,960
that the thread actually slept and then

00:06:54,460 --> 00:06:58,060
I'm expecting to sleep for the duration

00:06:55,960 --> 00:07:00,430
so I can subtract that out and that

00:06:58,060 --> 00:07:03,070
difference is that Delta and so if you

00:07:00,430 --> 00:07:05,380
plot that in a histogram it can look

00:07:03,070 --> 00:07:07,330
something like this so in the purple is

00:07:05,380 --> 00:07:09,580
actually just a I ran this on my laptop

00:07:07,330 --> 00:07:11,920
this is like the regular can take config

00:07:09,580 --> 00:07:14,260
preempt setting in a mainline kernel

00:07:11,920 --> 00:07:15,700
this is what you would see the latency

00:07:14,260 --> 00:07:17,800
samples look like you can kind of see

00:07:15,700 --> 00:07:19,840
the distribution has a really long tail

00:07:17,800 --> 00:07:22,750
I think I only ran this for like a

00:07:19,840 --> 00:07:24,280
minute and I saw that 342 microseconds

00:07:22,750 --> 00:07:26,730
spike it's not a real-time operating

00:07:24,280 --> 00:07:29,050
system so you know that's to be expected

00:07:26,730 --> 00:07:32,800
and the green is on the same hardware

00:07:29,050 --> 00:07:34,780
system this is the preamp tarty patch

00:07:32,800 --> 00:07:36,310
you can see that it has in that same

00:07:34,780 --> 00:07:38,470
duration I remember how long I ran it

00:07:36,310 --> 00:07:41,050
you can see that it has a max bound of

00:07:38,470 --> 00:07:46,090
16 micro seconds much more well behaved

00:07:41,050 --> 00:07:48,330
for real-time use cases so if you if you

00:07:46,090 --> 00:07:51,820
think about this Delta and what is

00:07:48,330 --> 00:07:54,370
contributing to this Delta I break it

00:07:51,820 --> 00:07:57,430
down into two different phases so

00:07:54,370 --> 00:07:59,470
there's a desire cute dispatch latency

00:07:57,430 --> 00:08:01,090
this is the amount of time it takes

00:07:59,470 --> 00:08:04,270
between the hardware than actually

00:08:01,090 --> 00:08:06,130
firing to the interrupt for the relevant

00:08:04,270 --> 00:08:08,710
thread to actually be woken up to for

00:08:06,130 --> 00:08:11,170
the the interrupt dispatch to have

00:08:08,710 --> 00:08:13,360
occurred and the thread the scheduler

00:08:11,170 --> 00:08:16,420
the thread scheduler being told this

00:08:13,360 --> 00:08:18,970
thread needs to run that latency I'm I'm

00:08:16,420 --> 00:08:21,400
calling this lower case Delta if you

00:08:18,970 --> 00:08:22,870
dispatch and then the second one is

00:08:21,400 --> 00:08:24,670
scheduling latency this is the amount of

00:08:22,870 --> 00:08:27,430
time it takes now that the scheduler has

00:08:24,670 --> 00:08:29,860
been made aware that this high priority

00:08:27,430 --> 00:08:34,810
tasks needed to be run the time it takes

00:08:29,860 --> 00:08:37,810
from that moment to the CPU being given

00:08:34,810 --> 00:08:39,820
that task to actually execute it being

00:08:37,810 --> 00:08:41,500
scheduled in on that CPU so these are

00:08:39,820 --> 00:08:43,720
the two phases that I'm defining for the

00:08:41,500 --> 00:08:44,710
purpose of this conversation and I'm

00:08:43,720 --> 00:08:46,150
gonna dive into each one of them

00:08:44,710 --> 00:08:48,430
individually so I'm going to start

00:08:46,150 --> 00:08:50,350
looking at Iorek you dispatch latency

00:08:48,430 --> 00:08:53,770
specifically and sort of talking about

00:08:50,350 --> 00:08:57,580
the causes of this latency and issues we

00:08:53,770 --> 00:08:59,380
might might see so this is mainline

00:08:57,580 --> 00:09:01,330
model so what one of the main

00:08:59,380 --> 00:09:03,610
contributors to this is actually

00:09:01,330 --> 00:09:07,300
long-running interrupts in mainline so

00:09:03,610 --> 00:09:10,570
and main line because interrupt handlers

00:09:07,300 --> 00:09:12,700
are executed in hard irq context they

00:09:10,570 --> 00:09:15,730
are implicitly executed with interrupts

00:09:12,700 --> 00:09:17,050
disabled and so here's this diagram the

00:09:15,730 --> 00:09:19,770
scheduling diagram like you might have

00:09:17,050 --> 00:09:22,510
seen before this is all mainline again

00:09:19,770 --> 00:09:25,180
x-axis the time we have some thread

00:09:22,510 --> 00:09:27,520
executing in user mode at some point

00:09:25,180 --> 00:09:29,410
there's some interrupts that fire say

00:09:27,520 --> 00:09:30,580
for example it's like Network and you

00:09:29,410 --> 00:09:32,050
don't even care about network and your

00:09:30,580 --> 00:09:34,180
real-time application but yeah it

00:09:32,050 --> 00:09:37,000
happened interrupts happen

00:09:34,180 --> 00:09:39,280
and then at some later time well at the

00:09:37,000 --> 00:09:41,200
time that that event occurs the CPU is

00:09:39,280 --> 00:09:42,970
going to vector off into heart interrupt

00:09:41,200 --> 00:09:44,590
context and start executing the handler

00:09:42,970 --> 00:09:47,980
associated with that Network device or

00:09:44,590 --> 00:09:50,190
whatever device it is and say during the

00:09:47,980 --> 00:09:52,510
duration of that interrupt handler a

00:09:50,190 --> 00:09:54,400
high-priority event that I care about

00:09:52,510 --> 00:09:56,730
I'm here and calling this external event

00:09:54,400 --> 00:09:59,410
that I care about more say that it fires

00:09:56,730 --> 00:10:01,900
well it's not actually able to be

00:09:59,410 --> 00:10:06,490
scheduled on the CPU until that low

00:10:01,900 --> 00:10:09,190
priority interrupt is done executing so

00:10:06,490 --> 00:10:11,140
if you in this this Delta here between

00:10:09,190 --> 00:10:12,670
this external event firing and that read

00:10:11,140 --> 00:10:16,240
task executing that's a direct

00:10:12,670 --> 00:10:20,500
contributor to that irq just batch

00:10:16,240 --> 00:10:22,390
latency as I mentioned and it should be

00:10:20,500 --> 00:10:23,860
obvious without the real-time patch if

00:10:22,390 --> 00:10:26,530
you want to try to define bounds on this

00:10:23,860 --> 00:10:29,200
well it would be a mess because the

00:10:26,530 --> 00:10:32,920
balance would be the bound of the

00:10:29,200 --> 00:10:34,480
longest running interrupt handler in the

00:10:32,920 --> 00:10:36,250
system the longest running interrupt

00:10:34,480 --> 00:10:38,440
handler is going to be informing what

00:10:36,250 --> 00:10:39,400
your worst case I or acute ass but I are

00:10:38,440 --> 00:10:43,240
huge especially and see will be

00:10:39,400 --> 00:10:45,130
hopefully that's made clear and then at

00:10:43,240 --> 00:10:46,780
the point your task where you'd be the

00:10:45,130 --> 00:10:49,030
inter up and over executed and wake up

00:10:46,780 --> 00:10:55,780
your real-time task and and everything's

00:10:49,030 --> 00:10:57,250
good this is main line so on on RT when

00:10:55,780 --> 00:10:59,650
you when you apply the RT patch and

00:10:57,250 --> 00:11:00,940
actually enable the RT patch and then

00:10:59,650 --> 00:11:03,130
Stephen mentioned this as well what we

00:11:00,940 --> 00:11:05,080
do is actually force irq threads

00:11:03,130 --> 00:11:06,610
so what this means is that there's

00:11:05,080 --> 00:11:07,990
actually very little code that we

00:11:06,610 --> 00:11:09,760
actually execute in heart interrupt

00:11:07,990 --> 00:11:11,860
context very little they're just little

00:11:09,760 --> 00:11:14,500
shims that execute because they have to

00:11:11,860 --> 00:11:17,680
and all those little shims do or wake up

00:11:14,500 --> 00:11:20,830
these threads that are that are going to

00:11:17,680 --> 00:11:22,630
be executing your handler if that makes

00:11:20,830 --> 00:11:25,900
sense so you might have some low

00:11:22,630 --> 00:11:28,600
priority tasks running you have some not

00:11:25,900 --> 00:11:30,940
unimportant irq that fires but only a

00:11:28,600 --> 00:11:32,950
very small portion of time has actually

00:11:30,940 --> 00:11:35,950
spent just waking up The Associated

00:11:32,950 --> 00:11:38,950
handler thread and the duration of that

00:11:35,950 --> 00:11:41,140
shim can be well understood the bounds

00:11:38,950 --> 00:11:45,820
of it can be well understood for

00:11:41,140 --> 00:11:48,370
real-time purposes and it provides other

00:11:45,820 --> 00:11:50,590
guarantees such that because it's now

00:11:48,370 --> 00:11:53,350
running in executing in a thread those

00:11:50,590 --> 00:11:56,140
threads can now be preempted so if I

00:11:53,350 --> 00:11:58,900
then have my higher priority RT critical

00:11:56,140 --> 00:12:03,610
interrupts firing that higher Q thread

00:11:58,900 --> 00:12:05,410
can be scheduled immediately so that

00:12:03,610 --> 00:12:07,960
actually reduces that irq dispatch

00:12:05,410 --> 00:12:12,310
latency does that make sense it provides

00:12:07,960 --> 00:12:14,500
a more easily characterized bound that's

00:12:12,310 --> 00:12:17,230
what that works now for you as a device

00:12:14,500 --> 00:12:19,690
driver developer I have some good news

00:12:17,230 --> 00:12:22,090
this is just gonna happen like we are

00:12:19,690 --> 00:12:23,290
going to be when you when you enable RT

00:12:22,090 --> 00:12:25,030
kernel it's gonna force tire queue

00:12:23,290 --> 00:12:26,770
threats just even alluded to this thread

00:12:25,030 --> 00:12:29,170
irq actually exists a mainline right now

00:12:26,770 --> 00:12:31,780
you can boot a kernel and pass the

00:12:29,170 --> 00:12:34,870
thread I our Q's parameter and it will

00:12:31,780 --> 00:12:36,160
thread all your interrupts so this a

00:12:34,870 --> 00:12:37,870
significant portion of this

00:12:36,160 --> 00:12:39,880
infrastructure is in place the things

00:12:37,870 --> 00:12:45,250
that aren't in place for RT is a force

00:12:39,880 --> 00:12:49,960
to the Nabal bin so that's good it's

00:12:45,250 --> 00:12:52,330
good except when it's not so for and

00:12:49,960 --> 00:12:56,200
there are cases where it's not okay it's

00:12:52,330 --> 00:12:58,990
not okay when your drivers are invoked

00:12:56,200 --> 00:13:02,170
as part of interrupt dispatch so if you

00:12:58,990 --> 00:13:05,230
actually are invoked in the process of

00:13:02,170 --> 00:13:07,900
delivering an interrupt then you can't

00:13:05,230 --> 00:13:09,550
be threaded so the things that fall into

00:13:07,900 --> 00:13:12,490
this category are irq chip

00:13:09,550 --> 00:13:15,610
implementations those are important to

00:13:12,490 --> 00:13:16,780
not be threaded so if you're a device

00:13:15,610 --> 00:13:22,990
driver author working on our

00:13:16,780 --> 00:13:26,290
chips keep that in mind and so yeah

00:13:22,990 --> 00:13:30,280
that's all I really had there it's also

00:13:26,290 --> 00:13:33,010
not great in the case where you I can be

00:13:30,280 --> 00:13:34,810
invoked by the scheduler directly so

00:13:33,010 --> 00:13:35,980
there are a class of device drivers in

00:13:34,810 --> 00:13:39,010
the kernel tree right now that can be

00:13:35,980 --> 00:13:41,830
invoked by the scheduler itself things

00:13:39,010 --> 00:13:43,180
like CPU freak these things cannot be

00:13:41,830 --> 00:13:45,640
threaded so if these drivers are

00:13:43,180 --> 00:13:46,840
requiring interrupts then you need to be

00:13:45,640 --> 00:13:48,670
registering these interrupt handlers

00:13:46,840 --> 00:13:51,010
with this extra flag so if you use

00:13:48,670 --> 00:13:53,050
request irq request threaded irq there's

00:13:51,010 --> 00:13:55,120
a flags parameter because i rqf know

00:13:53,050 --> 00:13:56,560
thread is what you can pass to actually

00:13:55,120 --> 00:13:58,990
cause the interrupt cord and not

00:13:56,560 --> 00:14:01,030
actually thread your interrupts so keep

00:13:58,990 --> 00:14:02,470
that in mind the fortunate thing is the

00:14:01,030 --> 00:14:04,510
vast majority of you I would hope are

00:14:02,470 --> 00:14:06,460
not working on CPU freak drivers now

00:14:04,510 --> 00:14:09,070
working on irq triple bond asians if you

00:14:06,460 --> 00:14:10,870
are then i'm willing to help you out if

00:14:09,070 --> 00:14:12,760
you have problems so please send me an

00:14:10,870 --> 00:14:15,730
e-mail or send an email to the linux

00:14:12,760 --> 00:14:18,970
here to users list so that is talking

00:14:15,730 --> 00:14:23,110
about implicit interrupts being disabled

00:14:18,970 --> 00:14:24,850
during interrupt handler execution there

00:14:23,110 --> 00:14:25,930
is a different another class of

00:14:24,850 --> 00:14:28,240
interrupts being disabled that is

00:14:25,930 --> 00:14:30,730
explicitly disabling interrupts using

00:14:28,240 --> 00:14:33,850
local irq disable or look liar if you

00:14:30,730 --> 00:14:36,700
save device drivers should not be using

00:14:33,850 --> 00:14:38,200
these things but they are in fact I

00:14:36,700 --> 00:14:41,560
think I did it grab there's about 80

00:14:38,200 --> 00:14:44,080
users of these api's and then the

00:14:41,560 --> 00:14:46,270
drivers portion of the kernel tree which

00:14:44,080 --> 00:14:47,530
is I think manageable it's something we

00:14:46,270 --> 00:14:49,090
can actually go through and audit each

00:14:47,530 --> 00:14:51,940
of these and figure out what they're

00:14:49,090 --> 00:14:53,590
doing but to give an example why this is

00:14:51,940 --> 00:14:55,720
problematic I would hope you do know at

00:14:53,590 --> 00:14:57,820
this point but it's problematic in the

00:14:55,720 --> 00:14:59,920
case that the external event can

00:14:57,820 --> 00:15:01,960
actually once it's fired it can't

00:14:59,920 --> 00:15:03,790
actually execute to interrupt handler

00:15:01,960 --> 00:15:05,710
because interrupts are disabled and so

00:15:03,790 --> 00:15:06,700
it doesn't actually execute until

00:15:05,710 --> 00:15:09,390
interrupts have been re-enabled

00:15:06,700 --> 00:15:09,390
yes question

00:15:14,249 --> 00:15:19,449
yeah so that's at the question so it's

00:15:17,829 --> 00:15:21,790
so it's a great question the question is

00:15:19,449 --> 00:15:23,410
what is my definition of external event

00:15:21,790 --> 00:15:25,439
I should have been more specific what I

00:15:23,410 --> 00:15:27,519
mean by this is a hardware event

00:15:25,439 --> 00:15:29,980
whatever that means it could be a timer

00:15:27,519 --> 00:15:34,629
irq that fires it could be an i/o device

00:15:29,980 --> 00:15:44,170
that says hey please give me a sample it

00:15:34,629 --> 00:15:47,490
depends on what you mean by priority I'm

00:15:44,170 --> 00:15:47,490
not sure I understand the question

00:15:56,900 --> 00:16:00,350
so when I when you call local irq

00:15:58,700 --> 00:16:02,960
disabled to all the interrupts are

00:16:00,350 --> 00:16:07,430
disabled in the local CPU correct I'm

00:16:02,960 --> 00:16:09,470
sorry the same level okay so you're

00:16:07,430 --> 00:16:12,950
referring to a hardware prioritization

00:16:09,470 --> 00:16:15,080
of interrupts features right so I don't

00:16:12,950 --> 00:16:16,400
actually have a complete answer to that

00:16:15,080 --> 00:16:19,060
question I'd be interested to hear about

00:16:16,400 --> 00:16:20,900
how you're using that feature because

00:16:19,060 --> 00:16:23,029
talk to me afterwards good I'm

00:16:20,900 --> 00:16:24,980
interested in that question but yeah I'm

00:16:23,029 --> 00:16:28,670
not assuming a hardware prioritization

00:16:24,980 --> 00:16:32,260
of interrupts this is all purely a

00:16:28,670 --> 00:16:36,890
software dispatch hierarchy dispatch a

00:16:32,260 --> 00:16:38,390
great question so there is a lot of

00:16:36,890 --> 00:16:41,000
questions I have like I told you there's

00:16:38,390 --> 00:16:42,470
like 80 instances of this being used and

00:16:41,000 --> 00:16:47,690
the drivers portion of the kernel tree

00:16:42,470 --> 00:16:49,250
as of 4:14 i said don't use it of course

00:16:47,690 --> 00:16:51,230
I can't make that like really strong

00:16:49,250 --> 00:16:53,089
state and never use it there are

00:16:51,230 --> 00:16:56,420
situations where it's actually required

00:16:53,089 --> 00:16:58,580
again if you are absolutely going to be

00:16:56,420 --> 00:16:59,839
executed in hard interrupt context or

00:16:58,580 --> 00:17:03,230
you're involved in interrupts dispatch

00:16:59,839 --> 00:17:07,069
in some way that's GPIO irq chip

00:17:03,230 --> 00:17:09,140
implementations or irq chips those sort

00:17:07,069 --> 00:17:13,250
of things it makes sense to use o'clair

00:17:09,140 --> 00:17:15,740
if you disable maybe but it could also

00:17:13,250 --> 00:17:18,260
be that it's just buggy or for example

00:17:15,740 --> 00:17:20,030
the drive the device driver is wasn't

00:17:18,260 --> 00:17:23,390
written with SMP in mind and so there's

00:17:20,030 --> 00:17:25,040
assumptions being made that the

00:17:23,390 --> 00:17:27,709
interrupts always going to be delivered

00:17:25,040 --> 00:17:29,090
to the local CPU and so it might just be

00:17:27,709 --> 00:17:31,190
buggy I'm hoping that there's very few

00:17:29,090 --> 00:17:32,630
of these I haven't actually done a

00:17:31,190 --> 00:17:36,020
complete audit but it needs to be done

00:17:32,630 --> 00:17:37,820
at some point and probably the most

00:17:36,020 --> 00:17:39,620
common usage here and Steven alluded

00:17:37,820 --> 00:17:42,650
this as well is that it's kind of a

00:17:39,620 --> 00:17:45,530
heavy-handed way to prevent the task

00:17:42,650 --> 00:17:50,290
that's being executed from being ripped

00:17:45,530 --> 00:17:54,559
away from the CPU so if that task is is

00:17:50,290 --> 00:17:56,090
these two acts as sum per CPU data this

00:17:54,559 --> 00:17:58,970
might be one way that the driver uses

00:17:56,090 --> 00:18:01,610
that and there's a solution for those

00:17:58,970 --> 00:18:02,900
people that's using local locks so

00:18:01,610 --> 00:18:05,360
there's a question about local locks in

00:18:02,900 --> 00:18:07,970
the last section this is what local

00:18:05,360 --> 00:18:09,490
looks local locks look like currently in

00:18:07,970 --> 00:18:11,590
the RT patch now I should be

00:18:09,490 --> 00:18:14,110
I should make this clear this is a

00:18:11,590 --> 00:18:15,790
feature in the arty patch currently that

00:18:14,110 --> 00:18:18,910
in the next few months will be proposed

00:18:15,790 --> 00:18:21,670
for mainline inclusion but here's what

00:18:18,910 --> 00:18:26,200
the API looks like you use this define

00:18:21,670 --> 00:18:28,270
local irq lock declare etre macro and

00:18:26,200 --> 00:18:33,100
then within your function you can

00:18:28,270 --> 00:18:34,720
replace local irq disabled and they'll

00:18:33,100 --> 00:18:38,679
Clark you enable with these local lock

00:18:34,720 --> 00:18:40,960
irq and local unlock irq and if you

00:18:38,679 --> 00:18:44,380
don't build on RT these will end up

00:18:40,960 --> 00:18:47,650
redirecting to local irq disable and

00:18:44,380 --> 00:18:50,050
when you build with RT it provides it

00:18:47,650 --> 00:18:51,580
the following guarantees so writing your

00:18:50,050 --> 00:18:55,140
device driver these are the semantics

00:18:51,580 --> 00:18:58,980
you should be expecting from these api's

00:18:55,140 --> 00:19:03,820
the semantics are as follows basically

00:18:58,980 --> 00:19:08,920
what it prevents is two different tasks

00:19:03,820 --> 00:19:11,309
running on the same CPU from running in

00:19:08,920 --> 00:19:15,040
the critical sections at the same time

00:19:11,309 --> 00:19:18,190
this is a we looked at the the semantics

00:19:15,040 --> 00:19:21,190
that drivers are typically requiring for

00:19:18,190 --> 00:19:23,170
these sort of synchronization model and

00:19:21,190 --> 00:19:25,179
that appeared to be what is really

00:19:23,170 --> 00:19:26,860
required for a lot of PCP you accesses

00:19:25,179 --> 00:19:30,490
and so on and they'll Clark you disable

00:19:26,860 --> 00:19:32,679
and so if these are the semantics that

00:19:30,490 --> 00:19:35,950
are good enough for your driver and what

00:19:32,679 --> 00:19:37,929
guarantees you need then local irq lock

00:19:35,950 --> 00:19:42,070
is a good fit I'm not going to go in

00:19:37,929 --> 00:19:44,860
each of these in details but under

00:19:42,070 --> 00:19:47,980
contention there's a mutex in place

00:19:44,860 --> 00:19:50,410
there's proper priority inheritance and

00:19:47,980 --> 00:19:52,090
so on again if you have questions about

00:19:50,410 --> 00:19:54,360
this you can send an email to me in your

00:19:52,090 --> 00:19:56,590
Steven or the Linux party users list

00:19:54,360 --> 00:19:59,500
because sometimes the semantics can be a

00:19:56,590 --> 00:20:02,710
little complicated but it might be a

00:19:59,500 --> 00:20:04,270
good fit so some of you might be

00:20:02,710 --> 00:20:06,850
wondering okay well I don't see a lot of

00:20:04,270 --> 00:20:09,220
local irq disabled loci or Q&A bowl

00:20:06,850 --> 00:20:11,710
calls and the drivers tree but what I do

00:20:09,220 --> 00:20:14,559
see is a lot of these functions I see

00:20:11,710 --> 00:20:17,350
spinlock irq I see spinlock irq save

00:20:14,559 --> 00:20:19,720
what's going on with them well it turns

00:20:17,350 --> 00:20:22,630
out when you enable RT if you do spend

00:20:19,720 --> 00:20:22,900
like irq interrupts are not disabled we

00:20:22,630 --> 00:20:25,330
just

00:20:22,900 --> 00:20:28,020
nor it you just use it like it has been

00:20:25,330 --> 00:20:30,430
locked or in their arty case it's mutex

00:20:28,020 --> 00:20:32,470
and we just ignore the hint that says

00:20:30,430 --> 00:20:34,630
also please disable interrupts and we

00:20:32,470 --> 00:20:37,510
can do that because interrupts are

00:20:34,630 --> 00:20:38,620
threaded and I'll talk about spin locks

00:20:37,510 --> 00:20:43,890
a little bit more when I talk about

00:20:38,620 --> 00:20:47,250
scheduling latency so now I enter into a

00:20:43,890 --> 00:20:52,870
different class of problems that still

00:20:47,250 --> 00:20:54,880
cause this irq dispatch latency and so

00:20:52,870 --> 00:20:56,680
this is a unique situation that we've we

00:20:54,880 --> 00:20:59,470
continue run into run into on our

00:20:56,680 --> 00:21:02,860
products and so I'm making device driver

00:20:59,470 --> 00:21:04,390
authors aware so to give you a little

00:21:02,860 --> 00:21:07,690
bit of background I was running a cyclic

00:21:04,390 --> 00:21:09,190
test to test on my on my desk and I had

00:21:07,690 --> 00:21:11,200
an Ethernet cable running to this box

00:21:09,190 --> 00:21:14,230
and it was one of those Ethernet cables

00:21:11,200 --> 00:21:16,090
for the rj45 connector like the little

00:21:14,230 --> 00:21:17,290
plastic pin was broken off you know

00:21:16,090 --> 00:21:20,110
you've always dealt all dealt with this

00:21:17,290 --> 00:21:22,090
I'm sure and the test was running and I

00:21:20,110 --> 00:21:23,470
bumped the cable out I got up to go get

00:21:22,090 --> 00:21:24,730
a cup of a cup of coffee or something I

00:21:23,470 --> 00:21:26,890
bumped the cable out and I plugged it

00:21:24,730 --> 00:21:28,990
back in and there was just this mass of

00:21:26,890 --> 00:21:31,830
latency spike and I was like what the

00:21:28,990 --> 00:21:36,910
hell happened like I just wanted coffee

00:21:31,830 --> 00:21:39,130
and so we did a lot of debugging and it

00:21:36,910 --> 00:21:42,130
was very confusing but we eventually

00:21:39,130 --> 00:21:43,300
figured out what the root cause was and

00:21:42,130 --> 00:21:45,100
it's something that you might not

00:21:43,300 --> 00:21:49,390
actually think about I'm asking you to

00:21:45,100 --> 00:21:51,850
think about it so here is bait the basic

00:21:49,390 --> 00:21:53,230
the basics of what was going on so the

00:21:51,850 --> 00:21:54,520
device when it was being initialized

00:21:53,230 --> 00:21:56,140
when I was I'm plugging the cable and re

00:21:54,520 --> 00:21:57,760
plugging in the cable as soon as I

00:21:56,140 --> 00:21:59,650
plugged in the cable did the network

00:21:57,760 --> 00:22:02,470
interface went up and down as soon as it

00:21:59,650 --> 00:22:04,360
went up I went down in and up when the

00:22:02,470 --> 00:22:06,340
interface went up there was just a bunch

00:22:04,360 --> 00:22:08,530
of register rights to like some

00:22:06,340 --> 00:22:10,780
configuration block and this particular

00:22:08,530 --> 00:22:12,400
hardware device and then there was a

00:22:10,780 --> 00:22:13,780
read and the read was like okay well I

00:22:12,400 --> 00:22:15,040
wrote all this configuration data and

00:22:13,780 --> 00:22:19,450
now tell me when you're done doing your

00:22:15,040 --> 00:22:22,660
configuration whatever now on this

00:22:19,450 --> 00:22:26,320
particular device there was a pretty it

00:22:22,660 --> 00:22:28,420
was a PCI device and PCI rights are

00:22:26,320 --> 00:22:29,770
posted so they're effectively buffered

00:22:28,420 --> 00:22:31,990
in the interconnect to be delivered to

00:22:29,770 --> 00:22:33,850
the to the device and that read that

00:22:31,990 --> 00:22:36,490
comes in is going to push all of those

00:22:33,850 --> 00:22:36,909
rights out of those those store buffers

00:22:36,490 --> 00:22:38,440
in the end

00:22:36,909 --> 00:22:41,409
connect until they get to the device and

00:22:38,440 --> 00:22:44,889
then it's going to return the the read

00:22:41,409 --> 00:22:48,669
response back to the CPU but the thing

00:22:44,889 --> 00:22:51,119
we've encountered is that the CPU

00:22:48,669 --> 00:22:55,119
actually cannot dispatch interrupts

00:22:51,119 --> 00:22:56,349
until it gets that read response back so

00:22:55,119 --> 00:22:58,149
then you see something like this where

00:22:56,349 --> 00:22:59,139
you see ok I've seen this thread it did

00:22:58,149 --> 00:22:59,649
a bunch of record write write write

00:22:59,139 --> 00:23:02,200
write write

00:22:59,649 --> 00:23:04,059
and then it did a read and it just like

00:23:02,200 --> 00:23:05,859
was waiting for those buffers to

00:23:04,059 --> 00:23:07,450
propagate down to the device and for the

00:23:05,859 --> 00:23:10,749
device to do its thing and then to come

00:23:07,450 --> 00:23:13,359
back and in that interim time the timer

00:23:10,749 --> 00:23:14,710
had fired for the cyclic test thread and

00:23:13,359 --> 00:23:17,940
it can't be serviced because

00:23:14,710 --> 00:23:20,259
architectural e it's required that

00:23:17,940 --> 00:23:24,399
interrupts are delivered in that

00:23:20,259 --> 00:23:26,019
particular instruction order so there's

00:23:24,399 --> 00:23:27,580
some order architectural constraints in

00:23:26,019 --> 00:23:29,739
the hardware that requires this ordering

00:23:27,580 --> 00:23:31,179
and so therefore interrupts won't be

00:23:29,739 --> 00:23:35,229
able to monkey delivered until the read

00:23:31,179 --> 00:23:36,279
completes and so and not when once I

00:23:35,229 --> 00:23:38,679
read completes been the interrupt

00:23:36,279 --> 00:23:42,249
convicted off but you can measure that

00:23:38,679 --> 00:23:45,070
latency and so I did so this is one this

00:23:42,249 --> 00:23:46,330
the test prior to me bumping this cable

00:23:45,070 --> 00:23:48,999
out

00:23:46,330 --> 00:23:51,399
and so you see after this test run you

00:23:48,999 --> 00:23:54,639
have a max where's case latency 17

00:23:51,399 --> 00:23:56,109
microseconds not that bad and then I

00:23:54,639 --> 00:23:57,549
wrote a test case that all I did was

00:23:56,109 --> 00:23:59,769
just to write write write write write

00:23:57,549 --> 00:24:01,929
like it picks a PCI device a memory bar

00:23:59,769 --> 00:24:03,849
that I knew is gonna be safe and just

00:24:01,929 --> 00:24:06,159
like pile down a bunch of writes and

00:24:03,849 --> 00:24:08,559
follow it by a read and then and then

00:24:06,159 --> 00:24:10,679
measure the latency and this is what I

00:24:08,559 --> 00:24:10,679
get

00:24:10,889 --> 00:24:15,249
so this spiked all the way up to a

00:24:13,179 --> 00:24:17,799
hundred that's like a tin tin X spike

00:24:15,249 --> 00:24:21,399
here to 174 microseconds

00:24:17,799 --> 00:24:25,179
that's pretty atrocious so the lesson is

00:24:21,399 --> 00:24:26,489
don't bump my Ethernet cable I guess but

00:24:25,179 --> 00:24:29,349
the question is what do we do about this

00:24:26,489 --> 00:24:31,299
and what am I asking you as device

00:24:29,349 --> 00:24:33,789
driver developers to consider when

00:24:31,299 --> 00:24:35,229
you're authoring your drivers what I

00:24:33,789 --> 00:24:36,340
would ask of you is to consider this

00:24:35,229 --> 00:24:38,409
case where there's buffering in the

00:24:36,340 --> 00:24:41,529
interconnect what we actually did to

00:24:38,409 --> 00:24:44,049
solve this is actually follow each write

00:24:41,529 --> 00:24:45,970
by a read back and that actually

00:24:44,049 --> 00:24:48,009
prevents the the writes from being

00:24:45,970 --> 00:24:49,240
stacked up on one another in the

00:24:48,009 --> 00:24:50,890
interconnect

00:24:49,240 --> 00:24:53,680
it's kind of a crappy solution I wish

00:24:50,890 --> 00:24:56,710
there was a better one but it's what we

00:24:53,680 --> 00:24:58,870
have available if you have any other

00:24:56,710 --> 00:25:01,240
idea that'd be great there I've heard

00:24:58,870 --> 00:25:03,430
mumblings that in some of these CPUs you

00:25:01,240 --> 00:25:06,370
can have some buffering at least in the

00:25:03,430 --> 00:25:08,290
CPU complex itself construct timeout

00:25:06,370 --> 00:25:10,660
control timeouts and the store buffers

00:25:08,290 --> 00:25:13,360
and so on but that just seems like a lot

00:25:10,660 --> 00:25:15,750
of architectural black magic so question

00:25:13,360 --> 00:25:15,750
yeah

00:25:25,230 --> 00:25:33,590
yeah I agree

00:25:34,360 --> 00:25:41,960
this is where the throughput and latency

00:25:37,870 --> 00:25:44,059
considerations just I mean they come at

00:25:41,960 --> 00:25:46,820
one another and I don't know what the

00:25:44,059 --> 00:25:48,669
right solution is maybe the right

00:25:46,820 --> 00:25:52,340
solution is to provide a higher level

00:25:48,669 --> 00:25:53,750
access er that's like a Rydell with read

00:25:52,340 --> 00:25:56,840
back and then like if you're building on

00:25:53,750 --> 00:25:59,120
RT then do the read back otherwise don't

00:25:56,840 --> 00:26:00,890
do it if you're not building for RT to

00:25:59,120 --> 00:26:04,659
bound that latency I mean I don't know

00:26:00,890 --> 00:26:04,659
we have options I don't know we're there

00:26:04,840 --> 00:26:09,710
yeah the enemy is hardware yeah so the

00:26:07,370 --> 00:26:11,149
solution to this class of bugs is to

00:26:09,710 --> 00:26:14,750
take care take the drugs away from the

00:26:11,149 --> 00:26:17,120
hardware people yeah yeah speaking of

00:26:14,750 --> 00:26:20,380
drugs and hardware people some

00:26:17,120 --> 00:26:24,200
additional mmm I was as I call them

00:26:20,380 --> 00:26:26,140
we've seen this not not just buffering

00:26:24,200 --> 00:26:29,510
in the interconnect we have one device

00:26:26,140 --> 00:26:31,490
that we've seen that actually will enter

00:26:29,510 --> 00:26:33,760
into some lower power state and then

00:26:31,490 --> 00:26:36,289
when when an mm IO transaction happens

00:26:33,760 --> 00:26:38,750
it will like exit from that low-power

00:26:36,289 --> 00:26:41,750
state and that exit latency can actually

00:26:38,750 --> 00:26:43,940
be measured on the CPU side so again

00:26:41,750 --> 00:26:45,110
take the drugs away or at least ask the

00:26:43,940 --> 00:26:46,490
hardware people to provide some knobs

00:26:45,110 --> 00:26:49,539
that you can tweak it say oh don't go

00:26:46,490 --> 00:26:49,539
into this low-power state please

00:26:50,409 --> 00:26:55,220
secondly another thing we run out and

00:26:53,090 --> 00:26:57,350
run into is like this I think was like

00:26:55,220 --> 00:26:59,840
some spy EEPROM it was just memory

00:26:57,350 --> 00:27:03,760
mapped there's a terrible idea but it

00:26:59,840 --> 00:27:03,760
was done and don't do that please

00:27:04,419 --> 00:27:08,210
so that's all I had on I'm nayara key

00:27:06,830 --> 00:27:09,380
just patch latency any questions there

00:27:08,210 --> 00:27:15,860
otherwise I'm going to talk about the

00:27:09,380 --> 00:27:18,860
other phase okay so at this point you

00:27:15,860 --> 00:27:21,320
have a thread that has been you've told

00:27:18,860 --> 00:27:24,470
the scheduler please execute this

00:27:21,320 --> 00:27:26,720
real-time thread and from now on I'm

00:27:24,470 --> 00:27:28,520
counting the time spent from that point

00:27:26,720 --> 00:27:30,200
to the youth to that arty thread

00:27:28,520 --> 00:27:31,760
actually being scheduled in as the

00:27:30,200 --> 00:27:34,520
scheduling latency I'm going to talk

00:27:31,760 --> 00:27:38,299
about causes of or potential causes of

00:27:34,520 --> 00:27:41,570
this scheduling latency so to show you

00:27:38,299 --> 00:27:43,549
one of one such example this is very

00:27:41,570 --> 00:27:46,070
similar to the local irq disable acquire

00:27:43,549 --> 00:27:46,930
a queue enable case but this is instead

00:27:46,070 --> 00:27:48,850
the

00:27:46,930 --> 00:27:52,060
set of accessors the disabled preemption

00:27:48,850 --> 00:27:53,500
on the local cpu so just to give you

00:27:52,060 --> 00:27:55,960
what that looks like in the diagram so

00:27:53,500 --> 00:28:00,610
you have some thread executing it does a

00:27:55,960 --> 00:28:03,100
preempt disable and an external event

00:28:00,610 --> 00:28:04,930
happens and the AP interrupts the

00:28:03,100 --> 00:28:06,850
interrupts aren't disabled so it just it

00:28:04,930 --> 00:28:08,560
executes immediately the CPU vectors off

00:28:06,850 --> 00:28:10,690
into this interrupt handler the

00:28:08,560 --> 00:28:13,720
interrupt handler is gonna wake up this

00:28:10,690 --> 00:28:15,670
high prior priority thread but it can

00:28:13,720 --> 00:28:18,670
actually be scheduled in on return from

00:28:15,670 --> 00:28:21,910
interrupt because preemption is disabled

00:28:18,670 --> 00:28:24,700
and so you have to wait until that

00:28:21,910 --> 00:28:26,080
thread has done a preempted able and at

00:28:24,700 --> 00:28:27,760
that point you can schedule in the

00:28:26,080 --> 00:28:30,550
higher priority thread so it should be

00:28:27,760 --> 00:28:34,660
clear that usage of preempt disabled

00:28:30,550 --> 00:28:41,880
preempt and abel are going to impact

00:28:34,660 --> 00:28:41,880
that that delta any questions about that

00:28:42,450 --> 00:28:46,360
the only reason that I can come up with

00:28:44,800 --> 00:28:47,920
a after thinking about this and maybe

00:28:46,360 --> 00:28:52,030
you can think of some other other ones

00:28:47,920 --> 00:28:54,400
but is that why device drivers should be

00:28:52,030 --> 00:28:56,110
using creme de sablé and that is if you

00:28:54,400 --> 00:28:59,680
need to synchronize with the act of

00:28:56,110 --> 00:29:02,050
scheduling itself if you don't fall into

00:28:59,680 --> 00:29:03,730
this category then probably should not

00:29:02,050 --> 00:29:05,860
be using preamp disable and you can use

00:29:03,730 --> 00:29:13,150
local locks as an alternate solution

00:29:05,860 --> 00:29:16,090
here and I did a grep it wasn't that bad

00:29:13,150 --> 00:29:19,420
I think it was only like 60 users in the

00:29:16,090 --> 00:29:21,730
drivers tree so not that bad it's not

00:29:19,420 --> 00:29:22,810
like we're talking about analyzing you

00:29:21,730 --> 00:29:25,000
know a hundred I wasn't spinlock

00:29:22,810 --> 00:29:29,500
critical sections or something

00:29:25,000 --> 00:29:31,960
so it's manageable auditable speaking of

00:29:29,500 --> 00:29:33,670
spin locks however on mainline when you

00:29:31,960 --> 00:29:38,250
do a spin lock it's been unlock on

00:29:33,670 --> 00:29:40,840
mainline preemption is actually disabled

00:29:38,250 --> 00:29:42,130
so if you look at a mainline execution

00:29:40,840 --> 00:29:45,220
trace and you want to look at these

00:29:42,130 --> 00:29:47,410
these Layton sees you see the same sort

00:29:45,220 --> 00:29:50,280
of behavior the way that we sell them

00:29:47,410 --> 00:29:55,300
the Artie case is make spin lock

00:29:50,280 --> 00:29:57,010
critical sections preemptable and we do

00:29:55,300 --> 00:30:00,010
that by turning turning them into pio

00:29:57,010 --> 00:30:00,460
where mutexes and escaping migration is

00:30:00,010 --> 00:30:04,690
a little

00:30:00,460 --> 00:30:06,519
semantics quibble but in that case when

00:30:04,690 --> 00:30:08,769
spinlock when it's been lock is being

00:30:06,519 --> 00:30:11,169
held by a thread it can be preempted by

00:30:08,769 --> 00:30:14,110
a higher priority thread and so

00:30:11,169 --> 00:30:17,590
therefore you can bring in that that

00:30:14,110 --> 00:30:20,350
outer bound any questions about that

00:30:17,590 --> 00:30:20,950
that's a did you have to think about

00:30:20,350 --> 00:30:22,690
this for a while

00:30:20,950 --> 00:30:24,789
think about the spin locks sleeping for

00:30:22,690 --> 00:30:28,570
a long time before it's like how is that

00:30:24,789 --> 00:30:30,549
even okay and if you combine sleeping

00:30:28,570 --> 00:30:32,289
spin locks and forced irq threading

00:30:30,549 --> 00:30:33,879
you're gonna have to have both of those

00:30:32,289 --> 00:30:35,830
pieces together

00:30:33,879 --> 00:30:38,649
and think about them together to

00:30:35,830 --> 00:30:42,429
understand how they actually work and

00:30:38,649 --> 00:30:43,749
are successful for prima Tartine so it

00:30:42,429 --> 00:30:45,669
is unclear to you I'm happy to talk

00:30:43,749 --> 00:30:48,789
about it afterwards because it's

00:30:45,669 --> 00:30:50,679
definitely confusing and again the story

00:30:48,789 --> 00:30:53,289
is pretty clear so if you are writing a

00:30:50,679 --> 00:30:55,509
device driver and you're using spin

00:30:53,289 --> 00:31:01,330
locks then you're not really gonna

00:30:55,509 --> 00:31:05,230
impact a party thread priority or RT

00:31:01,330 --> 00:31:08,440
priority thread so you're just lucky now

00:31:05,230 --> 00:31:10,539
again it works until it doesn't work and

00:31:08,440 --> 00:31:14,499
so if you're in the situation where you

00:31:10,539 --> 00:31:18,460
do need to synchronize with some code

00:31:14,499 --> 00:31:19,809
running an interrupt dispatch or things

00:31:18,460 --> 00:31:22,809
that can be invoked from the scheduler

00:31:19,809 --> 00:31:27,070
so example for example like the spin the

00:31:22,809 --> 00:31:29,710
the scheduling core all of its spin

00:31:27,070 --> 00:31:32,259
locks internally are raw spin locks and

00:31:29,710 --> 00:31:39,340
raw spin locks are traditional spinning

00:31:32,259 --> 00:31:41,529
locks under contention and if you use

00:31:39,340 --> 00:31:43,210
the raw spin lock API which looks pretty

00:31:41,529 --> 00:31:47,200
much exactly like the regular spin lock

00:31:43,210 --> 00:31:50,110
API by design before you consider doing

00:31:47,200 --> 00:31:51,850
so think about the cases where you might

00:31:50,110 --> 00:31:54,100
need to I need to do this because I am

00:31:51,850 --> 00:31:55,659
invoked from hard interrupt context I'm

00:31:54,100 --> 00:31:57,730
involved in interrupts dispatch I'm

00:31:55,659 --> 00:31:59,679
involved in scheduling that's a good

00:31:57,730 --> 00:32:01,929
good enough justification but think

00:31:59,679 --> 00:32:03,879
about it when you were doing it because

00:32:01,929 --> 00:32:05,799
you need to think about the critical

00:32:03,879 --> 00:32:08,129
sections themselves and you want to

00:32:05,799 --> 00:32:11,720
ensure that they are doing the absolute

00:32:08,129 --> 00:32:14,690
minimal amount of work possible and

00:32:11,720 --> 00:32:16,580
especially that it's bounded because any

00:32:14,690 --> 00:32:20,870
critical section is going to impact that

00:32:16,580 --> 00:32:21,890
worst-case Delta so please keep that in

00:32:20,870 --> 00:32:26,570
mind if you're going to do this in the

00:32:21,890 --> 00:32:29,320
future and again we're always happy to

00:32:26,570 --> 00:32:31,970
review things or at least I am

00:32:29,320 --> 00:32:34,220
so in conclusion these are the four

00:32:31,970 --> 00:32:35,960
things I hope you walk away with so the

00:32:34,220 --> 00:32:37,909
first one is if your drivers aren't

00:32:35,960 --> 00:32:39,049
involved in interrupts dispatch and you

00:32:37,909 --> 00:32:40,130
probably shouldn't be using local

00:32:39,049 --> 00:32:41,770
hierarchy to say oh we probably

00:32:40,130 --> 00:32:47,210
shouldn't be using look like you say

00:32:41,770 --> 00:32:49,370
look at using local locks secondly just

00:32:47,210 --> 00:32:51,309
consider mmm i/o accesses I don't have a

00:32:49,370 --> 00:32:54,919
good story here just to think about it

00:32:51,309 --> 00:32:58,100
and see if you might get away with doing

00:32:54,919 --> 00:32:59,690
read backs that might be suitable look

00:32:58,100 --> 00:33:03,049
at your own applications to see if you

00:32:59,690 --> 00:33:04,100
can yeah I don't know there's I don't

00:33:03,049 --> 00:33:06,830
have a really good story here but just

00:33:04,100 --> 00:33:09,320
think about it if your drivers aren't

00:33:06,830 --> 00:33:12,190
involved in scheduling then you probably

00:33:09,320 --> 00:33:15,080
shouldn't be using preamp disabled and

00:33:12,190 --> 00:33:18,880
instead use it use a per CPU accessors

00:33:15,080 --> 00:33:21,559
so the RT patch also introduces a a

00:33:18,880 --> 00:33:25,309
different set of per CPU accessors

00:33:21,559 --> 00:33:27,740
called get local CPU get local get local

00:33:25,309 --> 00:33:30,409
CPU and get local or something and put

00:33:27,740 --> 00:33:32,720
local local VAR yeah yeah I get see ya

00:33:30,409 --> 00:33:34,580
local bar and put local bar and those

00:33:32,720 --> 00:33:36,650
are access primitives that allow you to

00:33:34,580 --> 00:33:39,500
do per CPU access that only disable pre

00:33:36,650 --> 00:33:42,830
only disable migration and don't disable

00:33:39,500 --> 00:33:46,370
preemption so that might be an option

00:33:42,830 --> 00:33:47,960
for you if your drivers are involved in

00:33:46,370 --> 00:33:49,610
interrupts dispatch a schedule England

00:33:47,960 --> 00:33:51,559
you need to use Ross pin locks

00:33:49,610 --> 00:33:55,190
you can't nest a regular spin lock

00:33:51,559 --> 00:33:57,320
within a raw spin lock that's bad in

00:33:55,190 --> 00:33:59,330
fact we've discussed it for a long time

00:33:57,320 --> 00:34:02,419
about making that trigger locked up

00:33:59,330 --> 00:34:04,070
splats right now in mainline so we can

00:34:02,419 --> 00:34:07,580
catch these issues we haven't done that

00:34:04,070 --> 00:34:08,839
yet but it's possibly coming in the

00:34:07,580 --> 00:34:13,639
future or certainly coming in the future

00:34:08,839 --> 00:34:15,290
I just don't know when so and it's a

00:34:13,639 --> 00:34:18,320
little early and I have plenty of time

00:34:15,290 --> 00:34:20,089
so if you have questions please ask me

00:34:18,320 --> 00:34:22,700
if you have questions afterwards or want

00:34:20,089 --> 00:34:24,859
clarification you can reach me at Juliet

00:34:22,700 --> 00:34:25,730
and I calm our Juliet Colonel that I

00:34:24,859 --> 00:34:29,359
work

00:34:25,730 --> 00:34:31,280
or my twitter handler or linux art users

00:34:29,359 --> 00:34:33,559
list that's actually a great resource

00:34:31,280 --> 00:34:38,720
also great resources that panel antics

00:34:33,559 --> 00:34:39,980
are tno pc so all the cool kids hang out

00:34:38,720 --> 00:34:44,559
I'm told I don't know do I fall in that

00:34:39,980 --> 00:34:44,559
category forget stuff question up here

00:34:58,160 --> 00:35:07,130
yeah so that definitely falls into the

00:35:00,620 --> 00:35:08,900
category of sure yeah so yeah yeah so

00:35:07,130 --> 00:35:11,240
this this gentleman mentioned that he

00:35:08,900 --> 00:35:14,300
had also run into what appeared to be

00:35:11,240 --> 00:35:18,110
some mm IO or mm I was I like to call

00:35:14,300 --> 00:35:20,300
them and where he was saying you

00:35:18,110 --> 00:35:21,770
triggered a race cycle for a flash and

00:35:20,300 --> 00:35:23,030
then when you read the status register

00:35:21,770 --> 00:35:24,800
it blocks in the pipeline until it's

00:35:23,030 --> 00:35:26,390
delivered yeah that certainly definitely

00:35:24,800 --> 00:35:27,590
falls into that same category of thing

00:35:26,390 --> 00:35:30,980
and I don't know what the right answer

00:35:27,590 --> 00:35:32,900
is but yeah that would use it PowerPC

00:35:30,980 --> 00:35:34,370
also suffers from from this pipeline

00:35:32,900 --> 00:35:44,330
stole so yeah I don't know what the

00:35:34,370 --> 00:35:45,740
writings were yeah yeah yeah yeah I'd be

00:35:44,330 --> 00:35:47,210
interesting to talk if you had solutions

00:35:45,740 --> 00:35:48,980
for that I don't know if you did or not

00:35:47,210 --> 00:35:51,860
you did okay I'd like to talk about that

00:35:48,980 --> 00:35:55,880
and maybe afterwards there's a question

00:35:51,860 --> 00:35:58,040
in the back here if you can get the

00:35:55,880 --> 00:36:01,070
slides yes they will be up on the on the

00:35:58,040 --> 00:36:02,770
scheduler page after this talk also my

00:36:01,070 --> 00:36:05,770
twitter feed if you need them before the

00:36:02,770 --> 00:36:05,770
question

00:36:28,270 --> 00:36:35,089
so so the question is and and the

00:36:33,440 --> 00:36:36,829
question is how does irq threading work

00:36:35,089 --> 00:36:38,329
so let me describe a little bit more

00:36:36,829 --> 00:36:39,950
about how it works and hopefully that

00:36:38,329 --> 00:36:44,000
answer your question and then if it

00:36:39,950 --> 00:36:46,339
doesn't please ask again in order to

00:36:44,000 --> 00:36:48,200
support irq threading it requires the

00:36:46,339 --> 00:36:50,089
use of the IQ chip primitives is

00:36:48,200 --> 00:36:51,829
implemented so what actually happens is

00:36:50,089 --> 00:36:54,740
when the interrupt fires we jump into

00:36:51,829 --> 00:36:57,319
that little shim as I showed the shim

00:36:54,740 --> 00:36:59,660
actually will mask the interrupts act

00:36:57,319 --> 00:37:01,039
the interrupt controller right so the

00:36:59,660 --> 00:37:02,930
device is still asserting its interrupts

00:37:01,039 --> 00:37:05,660
because it hasn't been handled yet but

00:37:02,930 --> 00:37:09,890
it's been masked right and then we wake

00:37:05,660 --> 00:37:12,380
up the The Associated irq thread and if

00:37:09,890 --> 00:37:14,539
that irq thread happens to be the next

00:37:12,380 --> 00:37:16,130
highest priority thread to be executed

00:37:14,539 --> 00:37:18,530
then the scheduler is going to execute

00:37:16,130 --> 00:37:21,039
it and on the tail end of that handler

00:37:18,530 --> 00:37:23,390
after the Associated handlers executed

00:37:21,039 --> 00:37:27,280
right before the thread goes back to

00:37:23,390 --> 00:37:27,280
sleep it actually will do the unmasked

00:37:30,579 --> 00:37:34,819
okay so the question is what happens if

00:37:32,900 --> 00:37:36,589
you have two real-time like rhythm

00:37:34,819 --> 00:37:40,789
events happening or interrupts happening

00:37:36,589 --> 00:37:42,619
at the same time well it if that occurs

00:37:40,789 --> 00:37:44,960
then it's up to the user or system

00:37:42,619 --> 00:37:46,579
integrator to properly prioritize those

00:37:44,960 --> 00:37:48,500
interrupts because you're now in the

00:37:46,579 --> 00:37:50,539
realm of scheduling you have all the

00:37:48,500 --> 00:37:54,650
tools available to you in that realm

00:37:50,539 --> 00:37:57,470
like adjusting priorities or adjusting

00:37:54,650 --> 00:38:00,650
scheduling class even you can adjust

00:37:57,470 --> 00:38:05,650
these to be like round robin or FIFO or

00:38:00,650 --> 00:38:05,650
deadline even I'm sure I don't know

00:38:05,790 --> 00:38:25,080
oh yeah so there's there is a a function

00:38:23,640 --> 00:38:26,940
called request threaded irq so there's

00:38:25,080 --> 00:38:30,510
two main registration functions there's

00:38:26,940 --> 00:38:33,450
request IQ and across threaded irq so on

00:38:30,510 --> 00:38:35,460
main line how this works is is that the

00:38:33,450 --> 00:38:37,710
traditional ones request irq the

00:38:35,460 --> 00:38:40,830
handlers are invoked and hard interrupt

00:38:37,710 --> 00:38:42,630
context if on main line you use request

00:38:40,830 --> 00:38:45,090
threaded irq you actually specify two

00:38:42,630 --> 00:38:46,410
handlers one of those handlers is

00:38:45,090 --> 00:38:49,080
actually what's executed in hard

00:38:46,410 --> 00:38:51,930
interrupt context and then that handler

00:38:49,080 --> 00:38:53,370
can return irq wake thread and our key

00:38:51,930 --> 00:38:55,950
wake thread will actually wake the

00:38:53,370 --> 00:38:58,680
associated irq thread that will actually

00:38:55,950 --> 00:39:02,580
run in thread context so that's how it

00:38:58,680 --> 00:39:04,260
works in mainline today so RT the way

00:39:02,580 --> 00:39:07,080
this works is that actually will force

00:39:04,260 --> 00:39:13,490
thread the higher the hard irq handler

00:39:07,080 --> 00:39:17,450
and the iraqis road in mainline you know

00:39:13,490 --> 00:39:17,450
maybe I didn't get your point go ahead

00:39:57,400 --> 00:40:05,299
yeah so threatening accuses is also kind

00:40:00,559 --> 00:40:06,650
of a generic work deferral for interrupt

00:40:05,299 --> 00:40:08,569
handling so it falls into that category

00:40:06,650 --> 00:40:11,839
so there are mainline uses where it

00:40:08,569 --> 00:40:13,759
makes a lot of sense as well so thank

00:40:11,839 --> 00:40:20,380
you Stephen there's a question in the

00:40:13,759 --> 00:40:20,380
back corner okay great question

00:40:44,920 --> 00:40:58,550
yeah yeah actually yes yeah yeah yeah I

00:40:57,260 --> 00:41:00,850
don't know that that's true I think we'd

00:40:58,550 --> 00:41:03,440
have to look I believe this was changed

00:41:00,850 --> 00:41:04,760
in the past several releases because

00:41:03,440 --> 00:41:07,340
there were device drivers that we're

00:41:04,760 --> 00:41:12,470
doing trying to acquire a spin lock in

00:41:07,340 --> 00:41:14,180
their top handler I don't know that we

00:41:12,470 --> 00:41:15,710
did I mean we can look at I will

00:41:14,180 --> 00:41:18,500
absolutely look afterwards if you want

00:41:15,710 --> 00:41:20,600
to but or Stephens gonna look right now

00:41:18,500 --> 00:41:25,480
but I believe even the top handler is

00:41:20,600 --> 00:41:25,480
threaded in our T as it exists now yeah

00:41:32,860 --> 00:41:39,050
yeah there is yeah so tasks tasks lid is

00:41:36,230 --> 00:41:40,400
is one higher queue work the question is

00:41:39,050 --> 00:41:41,870
about is there anything special about

00:41:40,400 --> 00:41:44,330
tasks quits

00:41:41,870 --> 00:41:47,480
not really only that if you raise the

00:41:44,330 --> 00:41:50,690
task of soft irq its associated with the

00:41:47,480 --> 00:41:52,460
thread in which you've raised it and so

00:41:50,690 --> 00:41:54,740
when that thread is done executing the

00:41:52,460 --> 00:41:56,780
handler then it will start executing the

00:41:54,740 --> 00:41:59,450
software cues that were raised in that

00:41:56,780 --> 00:42:01,790
thread so therefore in that thread

00:41:59,450 --> 00:42:04,130
context right you have your irq thread

00:42:01,790 --> 00:42:05,480
is executing it will execute the handler

00:42:04,130 --> 00:42:07,880
that has been forced threaded that

00:42:05,480 --> 00:42:10,220
handlers are gonna raise the task of

00:42:07,880 --> 00:42:12,890
software cue and at the termination of

00:42:10,220 --> 00:42:14,660
the handler it's still in that thread

00:42:12,890 --> 00:42:18,470
it's gonna run the task that right then

00:42:14,660 --> 00:42:21,230
have a variant in the context of that

00:42:18,470 --> 00:42:22,640
hierarchy thread yes and that's true of

00:42:21,230 --> 00:42:24,470
all side not just taslitz but that's

00:42:22,640 --> 00:42:27,520
true of all software software cues that

00:42:24,470 --> 00:42:30,520
are raised in thread context yeah

00:42:27,520 --> 00:42:30,520
question

00:42:34,510 --> 00:42:40,130
correct yeah yeah so the question is

00:42:37,670 --> 00:42:41,660
doesn't this break any device drivers

00:42:40,130 --> 00:42:43,010
that might be involved in the real-time

00:42:41,660 --> 00:42:51,020
portion of this applicative an

00:42:43,010 --> 00:42:54,830
application the answer is it depends you

00:42:51,020 --> 00:42:58,400
might see higher latency because now

00:42:54,830 --> 00:43:02,120
there are more context switches but you

00:42:58,400 --> 00:43:04,730
should get better bounded behavior for

00:43:02,120 --> 00:43:06,140
those and you have to also do all the

00:43:04,730 --> 00:43:07,910
configuration necessary to actually get

00:43:06,140 --> 00:43:12,290
these things prioritized with respective

00:43:07,910 --> 00:43:14,770
your RT app application but maybe I

00:43:12,290 --> 00:43:14,770
would hope not

00:43:18,490 --> 00:43:26,540
yeah yeah that's a pretty tight bound

00:43:23,060 --> 00:43:30,050
depending on your on your system for

00:43:26,540 --> 00:43:34,070
microseconds is pretty pretty tight I

00:43:30,050 --> 00:43:35,840
don't know if you'll hit that yeah so

00:43:34,070 --> 00:43:38,030
even on the highest power like the

00:43:35,840 --> 00:43:41,690
answer stupid I've tested on I'm still

00:43:38,030 --> 00:43:44,000
seeing like 10 microseconds worst case

00:43:41,690 --> 00:43:48,220
execution now in the arm systems we have

00:43:44,000 --> 00:43:48,220
we see maybe 25 30 microseconds

00:43:53,120 --> 00:43:58,800
yeah I mean and like I said like for

00:43:56,160 --> 00:43:59,730
those really tight bounds and yon

00:43:58,800 --> 00:44:01,530
mentioned this before in his

00:43:59,730 --> 00:44:03,570
presentation because if you need those

00:44:01,530 --> 00:44:05,640
tight bounds you might choose a

00:44:03,570 --> 00:44:06,300
different strategy you might go to using

00:44:05,640 --> 00:44:08,040
Zinn am I

00:44:06,300 --> 00:44:10,770
you might spin up and push all this

00:44:08,040 --> 00:44:13,380
stuff into another hardware unit you can

00:44:10,770 --> 00:44:15,330
offload those might be solutions or

00:44:13,380 --> 00:44:17,760
maybe it's not possible on this

00:44:15,330 --> 00:44:23,630
particular pub I don't know it really

00:44:17,760 --> 00:44:23,630
depends any other questions

00:44:30,900 --> 00:44:36,319
was this was this just a general

00:44:32,730 --> 00:44:36,319
statement because I agree

00:44:39,770 --> 00:44:45,270
okay sit for debugging this yeah so

00:44:43,109 --> 00:44:48,569
first of all I repeat the the statement

00:44:45,270 --> 00:44:51,210
that Olaf made he says that debugging

00:44:48,569 --> 00:44:54,500
priority inheritance problems that exist

00:44:51,210 --> 00:44:57,180
between a real-time application and a

00:44:54,500 --> 00:44:58,950
interrupts thread can be painful to

00:44:57,180 --> 00:45:02,130
debug what techniques can be used to

00:44:58,950 --> 00:45:04,799
debug them I typically just use the

00:45:02,130 --> 00:45:07,049
standard sched timer or trace points

00:45:04,799 --> 00:45:09,029
there's sched the timer and I our cues

00:45:07,049 --> 00:45:11,670
or the typical ones I enable but it's

00:45:09,029 --> 00:45:12,779
really just slogging through some traces

00:45:11,670 --> 00:45:15,660
and figuring out what's going on that's

00:45:12,779 --> 00:45:18,210
not an ideal situation there was a

00:45:15,660 --> 00:45:21,119
conversation yesterday I had that was a

00:45:18,210 --> 00:45:22,890
little bit interesting which was that it

00:45:21,119 --> 00:45:26,789
might be possible to leverage something

00:45:22,890 --> 00:45:30,480
like well let me let me back up a little

00:45:26,789 --> 00:45:31,770
bit there are funds in Imai apparently I

00:45:30,480 --> 00:45:35,190
don't I haven't used this in a my much

00:45:31,770 --> 00:45:37,589
but for an application you can have it

00:45:35,190 --> 00:45:39,480
such that if that application if that

00:45:37,589 --> 00:45:41,880
real-time application actually invokes a

00:45:39,480 --> 00:45:45,359
system call or something that exhibits

00:45:41,880 --> 00:45:47,400
known unbounded probably undoubted

00:45:45,359 --> 00:45:49,920
execution behavior it is sent a signal

00:45:47,400 --> 00:45:51,750
and then that task can either figure out

00:45:49,920 --> 00:45:53,609
what it wants to do dump state or pour

00:45:51,750 --> 00:45:56,309
whatever has an application debugging

00:45:53,609 --> 00:45:58,020
tool it should be conceivable to

00:45:56,309 --> 00:46:02,069
implement something like that using comm

00:45:58,020 --> 00:46:03,660
in Linux so I'd like to pursue that as

00:46:02,069 --> 00:46:04,950
like a usability to bug ability poke

00:46:03,660 --> 00:46:07,160
tool especially for people that are

00:46:04,950 --> 00:46:11,039
taking applications from non Linux

00:46:07,160 --> 00:46:12,960
platforms to Linux but yeah I would

00:46:11,039 --> 00:46:16,369
agree with you in general there's a it's

00:46:12,960 --> 00:46:16,369
there's a debug ability problem

00:46:22,980 --> 00:46:30,640
yah yah yah yah yah yah yah so the

00:46:29,110 --> 00:46:32,770
comment is even if we chose some set

00:46:30,640 --> 00:46:33,850
comp a solution it's gonna be difficult

00:46:32,770 --> 00:46:35,830
to maintain because there's gonna

00:46:33,850 --> 00:46:37,450
necessarily be a blacklist or whitelist

00:46:35,830 --> 00:46:39,910
that we use to determine whether or not

00:46:37,450 --> 00:46:42,580
a system call is allowed or not allowed

00:46:39,910 --> 00:46:43,600
but exhibits be certain behaviors or

00:46:42,580 --> 00:46:46,660
doesn't and that's going to be a

00:46:43,600 --> 00:46:47,590
difficult thing to maintain maybe it's

00:46:46,660 --> 00:46:49,420
gonna be good enough for just

00:46:47,590 --> 00:46:52,260
application to bug ability might not be

00:46:49,420 --> 00:46:54,850
useful to actually enable in deployment

00:46:52,260 --> 00:46:59,590
so I think there's there's some

00:46:54,850 --> 00:47:04,390
trade-offs we can consider there any

00:46:59,590 --> 00:47:08,740
other questions otherwise again I'm

00:47:04,390 --> 00:47:11,310
happy to answer questions via email how

00:47:08,740 --> 00:47:13,630
to review pageants let me know great

00:47:11,310 --> 00:47:19,079
thanks

00:47:13,630 --> 00:47:19,079

YouTube URL: https://www.youtube.com/watch?v=-J0y_usjYxo


