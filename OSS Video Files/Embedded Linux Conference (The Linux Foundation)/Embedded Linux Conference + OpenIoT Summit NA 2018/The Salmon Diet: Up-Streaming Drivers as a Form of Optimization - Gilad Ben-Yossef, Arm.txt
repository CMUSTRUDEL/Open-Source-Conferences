Title: The Salmon Diet: Up-Streaming Drivers as a Form of Optimization - Gilad Ben-Yossef, Arm
Publication date: 2018-03-15
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	The Salmon Diet: Up-Streaming Drivers as a Form of Optimization - Gilad Ben-Yossef, Arm

 As Linux developers we know that up-streaming device drivers is a good idea for many reasons: maintainability, ease of customer access and even just doing the right thing.

There is however one more benefit less talked about: up-streaming makes your code better.

Since February 2017 my team has worked on up-streaming the than out-of-tree CryptoCell REE device driver, which existed and has been in active use and development for several years.

As part of this effort, we diligently followed the instructions of the community and mentors to bring the code to the desired quality and style and noticed a surprising pattern: almost each set of changes reduced the code line count, and yet the functionality stayed the same while the bug count decreased and we ended up with 30% less lines of code doing the same thing, yet better.

This is the story of this project and what can be learned from it. 

About Gilad Ben-Yossef
Gilad Ben-Yossef is a principal software engineer working at Arm on upstream kernel security at large and Arm CryptCell engine support in particular. Gilad is the co-author of O’Reilly’s “Building Embedded Linux Systems” 2nd edition, co-founder of the Israeli FOSS NGO "HaMakor" and presented at LinuxWorld, Embedded Linux Conference Europe and the Ottawa Linux Symposium.
Captions: 
	00:00:00,030 --> 00:00:07,470
so hello everybody good morning and

00:00:04,890 --> 00:00:11,490
happy pi day for all of you who are

00:00:07,470 --> 00:00:11,929
celebrating that and this is a Salman

00:00:11,490 --> 00:00:14,700
Diet

00:00:11,929 --> 00:00:18,869
upstreaming device drivers as a form of

00:00:14,700 --> 00:00:20,850
optimization and I'm glad ben youssef so

00:00:18,869 --> 00:00:23,060
I thought I'd say a few words about Who

00:00:20,850 --> 00:00:27,019
am I and what am i doing

00:00:23,060 --> 00:00:31,710
I'm the maintainer of a device driver of

00:00:27,019 --> 00:00:33,960
the arm Trussell encrypted cell piece of

00:00:31,710 --> 00:00:36,230
IP I'll say a few word about that I also

00:00:33,960 --> 00:00:39,750
dabble with general internal

00:00:36,230 --> 00:00:41,280
cryptography and security to give a

00:00:39,750 --> 00:00:43,850
taste of the kind of thing I do I've

00:00:41,280 --> 00:00:47,940
submitted a patch set to introduce the

00:00:43,850 --> 00:00:51,390
Chinese SM for crypto algorithm to the

00:00:47,940 --> 00:00:53,789
kernel lately I've been working on

00:00:51,390 --> 00:00:56,250
various forum in and around the Linux

00:00:53,789 --> 00:00:59,250
kernel and other open source project for

00:00:56,250 --> 00:01:02,219
quite a while enough that you can see

00:00:59,250 --> 00:01:03,719
all the white hairs Co offered building

00:01:02,219 --> 00:01:07,530
the bedded Linux system the second

00:01:03,719 --> 00:01:10,340
edition and I'm done a few other stuff

00:01:07,530 --> 00:01:16,200
that you can see here

00:01:10,340 --> 00:01:21,479
so yesterday I sort of frolic around the

00:01:16,200 --> 00:01:24,630
hotel and found out to my amusement that

00:01:21,479 --> 00:01:27,840
we were actually on Salman Street which

00:01:24,630 --> 00:01:30,600
is kind of makes sense because as I've

00:01:27,840 --> 00:01:35,130
been told Portland OR Oregon people

00:01:30,600 --> 00:01:37,950
really really like this Salman which is

00:01:35,130 --> 00:01:40,619
logical you can see here a picture taken

00:01:37,950 --> 00:01:44,360
at William it falls which I gather is

00:01:40,619 --> 00:01:47,520
not too far away of salmon leaping

00:01:44,360 --> 00:01:52,049
upstream because this is what Salman's

00:01:47,520 --> 00:01:54,689
do but it appears that being upstream is

00:01:52,049 --> 00:01:57,329
not unique just for Salman's it also

00:01:54,689 --> 00:01:59,640
happened when the Linux kernel and the

00:01:57,329 --> 00:02:03,060
Linux kernel main list

00:01:59,640 --> 00:02:06,619
leaping upstream for device driver and

00:02:03,060 --> 00:02:09,270
device driver writers is when you have

00:02:06,619 --> 00:02:12,569
some piece of code the device driver in

00:02:09,270 --> 00:02:16,439
my case that

00:02:12,569 --> 00:02:20,549
is already written and you wish to

00:02:16,439 --> 00:02:25,349
submit it to the Linux kernel but as

00:02:20,549 --> 00:02:27,569
these things often happen some piece of

00:02:25,349 --> 00:02:30,269
code is not necessarily at least in the

00:02:27,569 --> 00:02:32,340
beginning of this process in the form

00:02:30,269 --> 00:02:34,439
that is acceptable to the Linux kernel

00:02:32,340 --> 00:02:39,269
community and therefore there's a

00:02:34,439 --> 00:02:42,030
process of getting that fixed in order

00:02:39,269 --> 00:02:43,799
to be able to that piece of code to be

00:02:42,030 --> 00:02:47,400
formally extracted into the Linux kernel

00:02:43,799 --> 00:02:51,239
and that process is called the staging

00:02:47,400 --> 00:02:55,650
tree basically a sort of the Linux

00:02:51,239 --> 00:02:58,379
kernel community except your code on

00:02:55,650 --> 00:03:02,449
probation on the condition that you work

00:02:58,379 --> 00:03:05,310
with the community to get that fixed and

00:03:02,449 --> 00:03:08,430
when all the things that needs fixing

00:03:05,310 --> 00:03:12,900
and eyes do community are fixed the code

00:03:08,430 --> 00:03:15,090
can mature into the main country now as

00:03:12,900 --> 00:03:17,129
I've said before I actually have been

00:03:15,090 --> 00:03:19,979
working in and around Linux for quite

00:03:17,129 --> 00:03:22,109
some time I've submitted patches I did

00:03:19,979 --> 00:03:26,609
changing in the kernel but I never went

00:03:22,109 --> 00:03:31,290
to this process until one year ago when

00:03:26,609 --> 00:03:36,930
I was hired by arm to handle the arm

00:03:31,290 --> 00:03:39,389
trust zone crypto cell device driver the

00:03:36,930 --> 00:03:42,329
arm trust still encrypted cell device

00:03:39,389 --> 00:03:44,220
driver or untrusted encrypted cell

00:03:42,329 --> 00:03:47,639
itself it's it's a piece of hardware

00:03:44,220 --> 00:03:50,299
basically designed for how to IP is they

00:03:47,639 --> 00:03:53,970
call that started its life in some other

00:03:50,299 --> 00:03:56,699
company called the skeptics originally

00:03:53,970 --> 00:04:00,569
then sansa which are bought and when I'm

00:03:56,699 --> 00:04:03,090
bought that company discovered that it

00:04:00,569 --> 00:04:06,120
does have a device driver but it was out

00:04:03,090 --> 00:04:08,729
of tree and when arm what the company it

00:04:06,120 --> 00:04:12,569
was decided to do the right thing and

00:04:08,729 --> 00:04:15,840
upstream the damn thing which is where I

00:04:12,569 --> 00:04:18,539
came in I got hired to do that now

00:04:15,840 --> 00:04:20,459
before we go into the specifics and

00:04:18,539 --> 00:04:22,820
what's happened there and some of the

00:04:20,459 --> 00:04:24,350
interesting things that I learned along

00:04:22,820 --> 00:04:26,450
way and I hope to share with you I

00:04:24,350 --> 00:04:29,260
thought to say a few words about what

00:04:26,450 --> 00:04:31,670
the hell is our untrusted encrypted cell

00:04:29,260 --> 00:04:34,460
because I'm not a marketing guy I went

00:04:31,670 --> 00:04:36,080
to the marketing department and asked

00:04:34,460 --> 00:04:38,380
them to get some slide and explain what

00:04:36,080 --> 00:04:40,850
it is and what does it do

00:04:38,380 --> 00:04:44,420
unfortunately and he gave me this slide

00:04:40,850 --> 00:04:47,180
unfortunately I thought I knew what that

00:04:44,420 --> 00:04:48,440
piece of IP does but after reading the

00:04:47,180 --> 00:04:50,330
description that the marketing

00:04:48,440 --> 00:04:53,030
department gave me I was not sure so

00:04:50,330 --> 00:04:55,580
sure anymore so that's why I decided

00:04:53,030 --> 00:04:59,360
that that is not helpful and in right

00:04:55,580 --> 00:05:02,600
now and reader Digest version so

00:04:59,360 --> 00:05:04,820
basically I'm try some crypto so it's a

00:05:02,600 --> 00:05:07,250
hardwood block which arm designs and

00:05:04,820 --> 00:05:09,590
people implement that handle a lot of

00:05:07,250 --> 00:05:11,510
aspects of system security so it

00:05:09,590 --> 00:05:14,270
provides cryptographic algorithm but

00:05:11,510 --> 00:05:18,200
also root of trust secure boot security

00:05:14,270 --> 00:05:20,930
bug basically it's a block of hardware

00:05:18,200 --> 00:05:22,430
that does security it goes inside the

00:05:20,930 --> 00:05:24,290
system an achievement it's not part of

00:05:22,430 --> 00:05:27,560
the core but it is part of the system of

00:05:24,290 --> 00:05:29,570
the chip and itself both trusted and

00:05:27,560 --> 00:05:31,130
untrusted world for those of you who are

00:05:29,570 --> 00:05:32,720
familiar with farm trustzone there's

00:05:31,130 --> 00:05:34,520
some distinction there and that's

00:05:32,720 --> 00:05:37,850
basically all you need to know for the

00:05:34,520 --> 00:05:40,100
purpose of this presentation so when I

00:05:37,850 --> 00:05:43,130
got hired I you know took that the

00:05:40,100 --> 00:05:45,710
driver of the thing and it should be

00:05:43,130 --> 00:05:48,290
noted that by this time you know there

00:05:45,710 --> 00:05:51,140
was an existing device driver it was

00:05:48,290 --> 00:05:55,040
working it was being used in the field

00:05:51,140 --> 00:05:57,830
by numerous customers and on a lot of

00:05:55,040 --> 00:06:01,400
devices so it was really not a case of

00:05:57,830 --> 00:06:05,570
something new and untested and I started

00:06:01,400 --> 00:06:08,740
the work to get it upstream via the

00:06:05,570 --> 00:06:12,980
staging tree so this is sort of the

00:06:08,740 --> 00:06:14,510
original commit that I send actually I

00:06:12,980 --> 00:06:16,130
think I'm lying I think it's the second

00:06:14,510 --> 00:06:18,530
one I bought the first one you know I

00:06:16,130 --> 00:06:21,920
sent it but if I didn't really know how

00:06:18,530 --> 00:06:24,080
to do it I I sent an email with a link

00:06:21,920 --> 00:06:26,270
to the git repository because they

00:06:24,080 --> 00:06:28,550
figured it's a big driver I'm not going

00:06:26,270 --> 00:06:30,320
to pull all seven thousand lines of it

00:06:28,550 --> 00:06:31,640
in the mailing list but I was told not

00:06:30,320 --> 00:06:33,440
this is not a way to do it you have to

00:06:31,640 --> 00:06:36,360
break it down so it's a process it's

00:06:33,440 --> 00:06:39,640
interesting process

00:06:36,360 --> 00:06:41,800
the thing about this is that you know

00:06:39,640 --> 00:06:44,170
does this device driver it's a bunch of

00:06:41,800 --> 00:06:45,760
code it is actually working and the

00:06:44,170 --> 00:06:47,320
people working on it has done a good job

00:06:45,760 --> 00:06:50,080
in the sense you know this is something

00:06:47,320 --> 00:06:53,950
critical the people depends on but then

00:06:50,080 --> 00:06:57,360
again it is open source because it is it

00:06:53,950 --> 00:07:00,880
was licensed under the GPL even before

00:06:57,360 --> 00:07:03,280
but it's not necessarily that the people

00:07:00,880 --> 00:07:05,650
who wrote it thought about somebody else

00:07:03,280 --> 00:07:06,910
taking a look at it and of course when

00:07:05,650 --> 00:07:08,920
you go through the process of up

00:07:06,910 --> 00:07:12,010
streaming that is exactly what happens

00:07:08,920 --> 00:07:15,750
and I found this little meme that

00:07:12,010 --> 00:07:18,460
explains how that made me feel right now

00:07:15,750 --> 00:07:21,040
you have all this stuff in the driver

00:07:18,460 --> 00:07:23,950
that people put in there it's you know

00:07:21,040 --> 00:07:27,580
it's working but it's maybe not very

00:07:23,950 --> 00:07:30,130
nice on the eyes ok so I started this

00:07:27,580 --> 00:07:31,810
process of abstaining and a big part of

00:07:30,130 --> 00:07:33,820
the process is getting the feedback from

00:07:31,810 --> 00:07:36,130
the kernel community for the mentor ok

00:07:33,820 --> 00:07:41,350
you're not using this API correctly and

00:07:36,130 --> 00:07:43,600
so on and so forth basically changes to

00:07:41,350 --> 00:07:48,190
places where things were not being done

00:07:43,600 --> 00:07:50,260
exactly as they should that was actually

00:07:48,190 --> 00:07:52,090
a rather small part of the process a

00:07:50,260 --> 00:07:56,680
very important one but a small one a

00:07:52,090 --> 00:07:58,750
huge part of my time has been spent with

00:07:56,680 --> 00:08:00,790
a personal enemy of mine called check

00:07:58,750 --> 00:08:02,460
patch those of you not familiar with

00:08:00,790 --> 00:08:05,350
this creature

00:08:02,460 --> 00:08:07,390
it's basically script lives in the Linux

00:08:05,350 --> 00:08:09,640
kernel and you're supposed to run it on

00:08:07,390 --> 00:08:11,640
your patches or code and it lets you

00:08:09,640 --> 00:08:15,010
know where you screwed up

00:08:11,640 --> 00:08:17,980
sometimes big screw-up but usually

00:08:15,010 --> 00:08:20,230
things like all you did not match the

00:08:17,980 --> 00:08:22,690
alignment of the parentheses and so on

00:08:20,230 --> 00:08:25,360
or you forgot some trailing whitespace

00:08:22,690 --> 00:08:27,160
and it's a really helpful tool when you

00:08:25,360 --> 00:08:29,410
know you make this change to the kernel

00:08:27,160 --> 00:08:33,250
and you know want it to be accepted and

00:08:29,410 --> 00:08:34,960
goes to the standard but in this

00:08:33,250 --> 00:08:37,810
particular mode of operation where you

00:08:34,960 --> 00:08:40,750
have this huge chunk of pre-existing

00:08:37,810 --> 00:08:43,540
code that I'm only started to get

00:08:40,750 --> 00:08:45,130
familiar with and none of this none of

00:08:43,540 --> 00:08:47,200
it is written according to the kernel

00:08:45,130 --> 00:08:49,960
college style and you run it

00:08:47,200 --> 00:08:52,710
on your uncheck patch on the code well

00:08:49,960 --> 00:08:56,620
it's you know your own version of hell

00:08:52,710 --> 00:08:58,900
right you get this huge output of the

00:08:56,620 --> 00:09:01,780
bazillion lines of oh you missed the

00:08:58,900 --> 00:09:03,690
space there and stuff like that but what

00:09:01,780 --> 00:09:05,980
can you do

00:09:03,690 --> 00:09:09,130
there's a reason why the kernel called

00:09:05,980 --> 00:09:11,650
the style exists and like it or not this

00:09:09,130 --> 00:09:15,340
is what I needed to do so I start doing

00:09:11,650 --> 00:09:18,250
that so side by side with the bigger

00:09:15,340 --> 00:09:21,610
issue and advices that I got from the

00:09:18,250 --> 00:09:23,920
mentors and check that I you know

00:09:21,610 --> 00:09:26,680
started working addressing the issues

00:09:23,920 --> 00:09:28,570
learning a little bit about both the

00:09:26,680 --> 00:09:31,690
driver which was new to me and I Piazza

00:09:28,570 --> 00:09:34,570
new kernel it was using and little by

00:09:31,690 --> 00:09:37,420
little it got better in the sense that

00:09:34,570 --> 00:09:39,910
it adheres better to the Linux kernel

00:09:37,420 --> 00:09:44,800
coding style and the code looked better

00:09:39,910 --> 00:09:48,220
and so on and this I guess is a natural

00:09:44,800 --> 00:09:52,000
process but at some point in time I

00:09:48,220 --> 00:09:54,400
began to notice a strange pattern okay I

00:09:52,000 --> 00:09:56,380
was making these changes and mind you

00:09:54,400 --> 00:09:59,200
these changes were not adding features

00:09:56,380 --> 00:10:01,090
not subtracting features just you know

00:09:59,200 --> 00:10:03,790
changing you know this space universe

00:10:01,090 --> 00:10:07,510
with that or using that API versus this

00:10:03,790 --> 00:10:11,920
and making the logical changes that grow

00:10:07,510 --> 00:10:14,650
for from this so while there was a

00:10:11,920 --> 00:10:18,280
general expectation that the code will

00:10:14,650 --> 00:10:20,890
get better what I did not expect and I

00:10:18,280 --> 00:10:24,910
found surprising is that this pattern

00:10:20,890 --> 00:10:27,880
emerged that the line the count of the

00:10:24,910 --> 00:10:31,390
line of code in a driver kept falling so

00:10:27,880 --> 00:10:34,780
each commit said that I would send for

00:10:31,390 --> 00:10:39,160
review had more lines deleted than lines

00:10:34,780 --> 00:10:42,160
added and in the beginning you know that

00:10:39,160 --> 00:10:43,600
made me rather pleased you know when

00:10:42,160 --> 00:10:46,270
you're deleting stuff it's usually a

00:10:43,600 --> 00:10:48,220
good sign for called quality but at some

00:10:46,270 --> 00:10:50,260
point you know I'm not it this is not

00:10:48,220 --> 00:10:51,850
something random it keeps happening more

00:10:50,260 --> 00:10:54,750
and more and more sometimes there's like

00:10:51,850 --> 00:10:57,340
a huge drop and I changed something and

00:10:54,750 --> 00:11:00,070
the conclusion of this process from

00:10:57,340 --> 00:11:00,970
where started until it ended was that I

00:11:00,070 --> 00:11:04,870
actually

00:11:00,970 --> 00:11:08,199
deleted 30% of the line code of the

00:11:04,870 --> 00:11:12,850
driver and it still kept doing the exact

00:11:08,199 --> 00:11:14,769
same thing now this is good

00:11:12,850 --> 00:11:17,350
right this is a good thing but it is

00:11:14,769 --> 00:11:19,209
also surprising right because think

00:11:17,350 --> 00:11:22,779
about it what that means that means that

00:11:19,209 --> 00:11:27,459
30% of the code or the driver as it was

00:11:22,779 --> 00:11:29,889
previously eaten didn't do anything okay

00:11:27,459 --> 00:11:32,170
there were useless or actually there

00:11:29,889 --> 00:11:34,029
were eros than useless because when you

00:11:32,170 --> 00:11:37,240
have code that you can remove and the

00:11:34,029 --> 00:11:40,300
code still does the same thing you just

00:11:37,240 --> 00:11:43,029
have room for more bugs right and and

00:11:40,300 --> 00:11:45,129
this is a security critical part of the

00:11:43,029 --> 00:11:47,620
system it handles stuff like work of

00:11:45,129 --> 00:11:50,500
trust and encryption keys and so on it's

00:11:47,620 --> 00:11:54,670
really not good to have auxilary code in

00:11:50,500 --> 00:11:58,779
there so this just got me intrigued and

00:11:54,670 --> 00:12:01,959
I asked myself well what went on there

00:11:58,779 --> 00:12:05,879
how was I able to cut this 40% of the

00:12:01,959 --> 00:12:08,290
code that did nothing what what was the

00:12:05,879 --> 00:12:12,069
reason we had 30 percent of the code

00:12:08,290 --> 00:12:15,040
that was useless and and what was it

00:12:12,069 --> 00:12:18,939
that that process of abstaining made me

00:12:15,040 --> 00:12:21,180
do and what can we learn from it and as

00:12:18,939 --> 00:12:23,889
you can expect from these kind of things

00:12:21,180 --> 00:12:27,720
there's no one cause right I've actually

00:12:23,889 --> 00:12:33,639
been able to identify I think it's seven

00:12:27,720 --> 00:12:36,160
different causes or reason and you can

00:12:33,639 --> 00:12:39,279
look at it both ways either for adding

00:12:36,160 --> 00:12:43,809
useless code or for the streaming

00:12:39,279 --> 00:12:45,339
process to remove bad code so this is

00:12:43,809 --> 00:12:48,339
basically this is what I'm going to talk

00:12:45,339 --> 00:12:50,889
about I'm going to share with you what

00:12:48,339 --> 00:12:52,480
kind of patterns will reveal to me as I

00:12:50,889 --> 00:12:55,990
went through this ops training process

00:12:52,480 --> 00:12:58,199
and what I learned from it some of them

00:12:55,990 --> 00:13:03,069
are rather mundane you're not surprising

00:12:58,199 --> 00:13:05,170
some of them I don't know maybe can be

00:13:03,069 --> 00:13:06,790
learned a little bit we can learn

00:13:05,170 --> 00:13:09,220
something interesting from looking at so

00:13:06,790 --> 00:13:11,439
let's get started so the first thing

00:13:09,220 --> 00:13:13,630
that was really obvious is something

00:13:11,439 --> 00:13:14,350
which I chose to dub reinventing the

00:13:13,630 --> 00:13:16,960
wheel

00:13:14,350 --> 00:13:18,910
now I know the font is way too small for

00:13:16,960 --> 00:13:20,470
you to see and that it's fine because

00:13:18,910 --> 00:13:22,750
the detail here don't matter all that

00:13:20,470 --> 00:13:25,960
much what you're seeing here is an

00:13:22,750 --> 00:13:29,620
original function the SSI buffer manager

00:13:25,960 --> 00:13:33,100
and copies catalyst portion which in the

00:13:29,620 --> 00:13:35,230
end after all the changes continue to do

00:13:33,100 --> 00:13:35,830
the exact thing same thing and now looks

00:13:35,230 --> 00:13:38,230
like this

00:13:35,830 --> 00:13:42,130
so the name changed but also you can see

00:13:38,230 --> 00:13:44,580
it kind of shrunk and you know you can

00:13:42,130 --> 00:13:49,240
ask yourself well what happened here and

00:13:44,580 --> 00:13:52,140
the answer is so the major thing that

00:13:49,240 --> 00:13:55,000
this function was doing was actually

00:13:52,140 --> 00:13:57,040
replicating a certain API that already

00:13:55,000 --> 00:13:59,020
existed in the kernel and when you

00:13:57,040 --> 00:14:00,790
express it was not doing it exactly the

00:13:59,020 --> 00:14:01,960
same way but you can sort of massage it

00:14:00,790 --> 00:14:04,510
you know you can see change the

00:14:01,960 --> 00:14:07,000
parameter a little bit and compound

00:14:04,510 --> 00:14:08,470
something so that you can express the

00:14:07,000 --> 00:14:10,690
old function in the terms in your new

00:14:08,470 --> 00:14:13,780
function with a little wrapper and that

00:14:10,690 --> 00:14:16,690
got that big function down into this one

00:14:13,780 --> 00:14:19,030
and this in itself is not a surprising

00:14:16,690 --> 00:14:21,550
thing but the question that this raises

00:14:19,030 --> 00:14:23,440
is well how can identify this pattern

00:14:21,550 --> 00:14:25,570
either when I'm writing the code or when

00:14:23,440 --> 00:14:28,180
I'm reviewing code for a screening and

00:14:25,570 --> 00:14:30,160
it turns out there's some really easy

00:14:28,180 --> 00:14:32,020
way I think to think about this ask

00:14:30,160 --> 00:14:33,790
yourself the following question what

00:14:32,020 --> 00:14:38,460
does this cow do obviously need to do

00:14:33,790 --> 00:14:41,080
what it does right and ask yourself is

00:14:38,460 --> 00:14:42,700
what I'm doing here is the problem that

00:14:41,080 --> 00:14:45,010
I'm trying to solve here is something

00:14:42,700 --> 00:14:46,630
which is unique to my specific case to

00:14:45,010 --> 00:14:49,480
my specific how other to my specific

00:14:46,630 --> 00:14:52,120
driver or it's something which is common

00:14:49,480 --> 00:14:55,210
that other driver in the same subsystem

00:14:52,120 --> 00:14:57,640
for example who have the same problem to

00:14:55,210 --> 00:14:59,230
deal with the same issue and if so ask

00:14:57,640 --> 00:15:01,420
yourself well what are these guys doing

00:14:59,230 --> 00:15:03,280
right because if they're doing something

00:15:01,420 --> 00:15:09,010
and it's the same problem probably I can

00:15:03,280 --> 00:15:10,870
do the same and this methodical process

00:15:09,010 --> 00:15:12,610
when you read code or write code

00:15:10,870 --> 00:15:14,650
whatever the case may be of asking

00:15:12,610 --> 00:15:17,860
yourself is this problem unique to me

00:15:14,650 --> 00:15:21,730
and if it isn't go found out find out

00:15:17,860 --> 00:15:25,030
what the other users or the other code

00:15:21,730 --> 00:15:27,490
which has the same issue is doing and

00:15:25,030 --> 00:15:29,440
two things can happen okay most of the

00:15:27,490 --> 00:15:31,060
time you'll find out that there is one

00:15:29,440 --> 00:15:34,120
or more set of API which you could just

00:15:31,060 --> 00:15:37,330
use and be done with it

00:15:34,120 --> 00:15:40,800
and sometimes and that happened to me as

00:15:37,330 --> 00:15:43,000
well you will find that there's similar

00:15:40,800 --> 00:15:47,200
spirited code replicated in a lot of

00:15:43,000 --> 00:15:49,870
places and then you if you want to be a

00:15:47,200 --> 00:15:52,120
good kernel citizen get the extra

00:15:49,870 --> 00:15:53,890
pleasure of writing that new API they

00:15:52,120 --> 00:15:56,740
expresses that and changes all these

00:15:53,890 --> 00:16:01,900
places to do that and if you follow this

00:15:56,740 --> 00:16:07,870
process it actually deletes quite a big

00:16:01,900 --> 00:16:10,120
chunk of your driver because your driver

00:16:07,870 --> 00:16:12,340
probably lives in sub subsystem and

00:16:10,120 --> 00:16:14,200
probably that a lot of the issues that

00:16:12,340 --> 00:16:17,230
your driver is dealing with are the same

00:16:14,200 --> 00:16:19,840
across the whole subsystem so this is

00:16:17,230 --> 00:16:24,070
the reinventing the wheel patent don't

00:16:19,840 --> 00:16:26,770
do it another thing which had a great

00:16:24,070 --> 00:16:28,780
impact once anyone look at it is the

00:16:26,770 --> 00:16:30,850
whole issue of backwards compatibility

00:16:28,780 --> 00:16:32,140
and there's a lot of jokes about

00:16:30,850 --> 00:16:33,520
backwards compatibility

00:16:32,140 --> 00:16:35,920
you know backwards compatibility is

00:16:33,520 --> 00:16:37,990
compatibility down backwards or this

00:16:35,920 --> 00:16:39,640
quote from some Don Mattrick

00:16:37,990 --> 00:16:41,560
in Microsoft if you're backwards

00:16:39,640 --> 00:16:45,250
compatible you're really backwards and

00:16:41,560 --> 00:16:47,740
so on how does this come to play so in

00:16:45,250 --> 00:16:50,380
my specific case it meant that the

00:16:47,740 --> 00:16:53,350
driver that remember live as an outer

00:16:50,380 --> 00:16:55,650
tree project on the side had a whole

00:16:53,350 --> 00:16:58,120
bunch of these if deaths right it was

00:16:55,650 --> 00:16:59,710
targeting a certain version of the

00:16:58,120 --> 00:17:02,410
kernel but it had heave deaths for the

00:16:59,710 --> 00:17:04,870
older version so obviously if you go and

00:17:02,410 --> 00:17:08,740
just delete those things get simpler and

00:17:04,870 --> 00:17:10,990
smaller but this does not stop here I

00:17:08,740 --> 00:17:12,790
mean this code is here because we need

00:17:10,990 --> 00:17:14,800
it backwards compatibility because sadly

00:17:12,790 --> 00:17:18,120
not all our customers are necessarily on

00:17:14,800 --> 00:17:22,450
the bleeding edge so just deleting this

00:17:18,120 --> 00:17:25,600
is really not a good solution so that

00:17:22,450 --> 00:17:30,190
leads to the question how does one

00:17:25,600 --> 00:17:32,170
handle backwards compatibility with all

00:17:30,190 --> 00:17:34,840
the kernel when you have a piece of

00:17:32,170 --> 00:17:38,140
hardware that you need to support across

00:17:34,840 --> 00:17:38,680
any kernel version and it turns out this

00:17:38,140 --> 00:17:43,900
is actual

00:17:38,680 --> 00:17:45,160
tied to something else which seems seems

00:17:43,900 --> 00:17:48,040
like a different issue but is actually

00:17:45,160 --> 00:17:50,440
related and that is how do you treat a

00:17:48,040 --> 00:17:53,590
different version of the same hardware

00:17:50,440 --> 00:17:55,210
and I don't know if this is a general

00:17:53,590 --> 00:17:58,090
pattern although I think it is this is

00:17:55,210 --> 00:18:01,510
what we were doing right we have this

00:17:58,090 --> 00:18:02,790
pattern of say a certain version of the

00:18:01,510 --> 00:18:08,980
hardware here its

00:18:02,790 --> 00:18:11,640
CC re crypto celery 712 so we had some

00:18:08,980 --> 00:18:16,780
version of the driver 1.1 in this case

00:18:11,640 --> 00:18:19,750
and it's supported kernel 3.18 and 4.9

00:18:16,780 --> 00:18:24,430
right with these if deaths and as

00:18:19,750 --> 00:18:28,720
development progresses the driver got a

00:18:24,430 --> 00:18:31,420
new version and a new version and at

00:18:28,720 --> 00:18:33,280
some point in time maybe they add a new

00:18:31,420 --> 00:18:36,400
kernel version that were supported and

00:18:33,280 --> 00:18:39,790
some point in time when a new project

00:18:36,400 --> 00:18:42,400
was started in this basically a hardware

00:18:39,790 --> 00:18:44,260
company they sort of replicated the same

00:18:42,400 --> 00:18:47,320
logic that guided the hardware

00:18:44,260 --> 00:18:49,900
development that is just like the

00:18:47,320 --> 00:18:53,860
hardware design was replicated right and

00:18:49,900 --> 00:18:55,990
started there and you to form CC re 713

00:18:53,860 --> 00:18:58,710
they did the same thing with the driver

00:18:55,990 --> 00:19:03,070
that basically it right so

00:18:58,710 --> 00:19:06,220
version say 1.2 of the C 3 712 became

00:19:03,070 --> 00:19:10,000
version 1.0 it started out as the same

00:19:06,220 --> 00:19:13,870
code base of CC re 713 just with the

00:19:10,000 --> 00:19:15,640
small adjustment to support 713 and

00:19:13,870 --> 00:19:19,180
maybe there was a change in kernel

00:19:15,640 --> 00:19:20,650
version and that continued onwards and

00:19:19,180 --> 00:19:22,240
of course it is does not stop here

00:19:20,650 --> 00:19:24,850
because you have more version of

00:19:22,240 --> 00:19:27,130
products and more version of the kernel

00:19:24,850 --> 00:19:29,950
you wish to support and that gave rise

00:19:27,130 --> 00:19:34,080
to two things a those if thefts in the

00:19:29,950 --> 00:19:37,450
code and B that you now have several

00:19:34,080 --> 00:19:39,400
very similar but not the same not

00:19:37,450 --> 00:19:43,390
compatible versions of the driver to

00:19:39,400 --> 00:19:47,110
support version of the hobro this is the

00:19:43,390 --> 00:19:49,930
way things worked and I would maybe call

00:19:47,110 --> 00:19:51,049
it a hard liquor way of managing stuff

00:19:49,930 --> 00:19:54,019
because you need

00:19:51,049 --> 00:19:56,179
liquor to handle all this complexity

00:19:54,019 --> 00:19:59,809
just think about what happens if there's

00:19:56,179 --> 00:20:01,429
some issue in one of the discovered in

00:19:59,809 --> 00:20:03,350
one of the version you need to find out

00:20:01,429 --> 00:20:07,369
now if it affects all the others and

00:20:03,350 --> 00:20:10,460
they make the necessary changes so to

00:20:07,369 --> 00:20:11,929
get over this what we ended up doing and

00:20:10,460 --> 00:20:16,039
actually still in the process of doing

00:20:11,929 --> 00:20:18,230
was changes on its head okay and move to

00:20:16,039 --> 00:20:21,259
down back to the future way of handling

00:20:18,230 --> 00:20:22,549
things and in the back of the future way

00:20:21,259 --> 00:20:25,519
of handling things we're doing things

00:20:22,549 --> 00:20:28,759
different we have the upstream kernel

00:20:25,519 --> 00:20:30,529
version and of course over time we add

00:20:28,759 --> 00:20:34,429
more features a change bug and so on

00:20:30,529 --> 00:20:38,359
with the new kernel version so 1.1 1.2

00:20:34,429 --> 00:20:42,529
one country that grows in newer and

00:20:38,359 --> 00:20:45,769
newer kernel version and in them we add

00:20:42,529 --> 00:20:48,590
support for new product revision so the

00:20:45,769 --> 00:20:51,200
same driver now support all the products

00:20:48,590 --> 00:20:53,960
incrementing Lee and that means that

00:20:51,200 --> 00:20:56,570
when some bug is found we don't need to

00:20:53,960 --> 00:20:59,539
ask the question of ok which other

00:20:56,570 --> 00:21:01,850
product line does this affect so this is

00:20:59,539 --> 00:21:03,889
very convenient but it does leave the

00:21:01,850 --> 00:21:06,980
question ok but what about the backwards

00:21:03,889 --> 00:21:09,980
compatibility what about back ports so

00:21:06,980 --> 00:21:11,299
it turns out and this still there is

00:21:09,980 --> 00:21:14,119
proof at least internally in our

00:21:11,299 --> 00:21:18,639
organization but I suspect it will prove

00:21:14,119 --> 00:21:21,379
itself that it's way easier to take the

00:21:18,639 --> 00:21:24,769
latest version in the latest kernel in

00:21:21,379 --> 00:21:28,279
the upstream and back port that to a

00:21:24,769 --> 00:21:31,129
known stable kernel then do it the other

00:21:28,279 --> 00:21:33,710
way around and there is a real project

00:21:31,129 --> 00:21:35,600
with significant infrastructure or the

00:21:33,710 --> 00:21:39,259
backboards project that helps you do

00:21:35,600 --> 00:21:41,600
that ok they have a lot of mechanics if

00:21:39,259 --> 00:21:44,210
you will a framework to do this now

00:21:41,600 --> 00:21:46,129
think about what that means not a cell

00:21:44,210 --> 00:21:47,690
in the eyes of an engineer but more as a

00:21:46,129 --> 00:21:51,529
product manager from the business side

00:21:47,690 --> 00:21:53,539
it means that you always support all the

00:21:51,529 --> 00:21:55,730
versions so the same of the products

00:21:53,539 --> 00:21:58,850
with the same driver for a customer that

00:21:55,730 --> 00:22:01,039
want to switch to a new revision of the

00:21:58,850 --> 00:22:02,690
hardware it's very easy it's using the

00:22:01,039 --> 00:22:03,700
same driver so everything works are the

00:22:02,690 --> 00:22:06,940
same

00:22:03,700 --> 00:22:09,460
a bug that is found in a version is

00:22:06,940 --> 00:22:12,669
automatically obviously fixed the course

00:22:09,460 --> 00:22:14,049
older version of the product and if you

00:22:12,669 --> 00:22:16,299
don't get it right if you're using

00:22:14,049 --> 00:22:19,779
infrastructure for the semi-automatic

00:22:16,299 --> 00:22:21,760
back porting that means that when a

00:22:19,779 --> 00:22:23,940
customer comes and say well it's really

00:22:21,760 --> 00:22:27,850
great that you're on the bleeding edge

00:22:23,940 --> 00:22:31,000
4.17 I'm really still on four point nine

00:22:27,850 --> 00:22:32,730
or four point fourteen or whatever you

00:22:31,000 --> 00:22:35,500
have an automated process you can

00:22:32,730 --> 00:22:39,340
practically click a button and get a

00:22:35,500 --> 00:22:41,260
version that suits them now you still

00:22:39,340 --> 00:22:45,399
have to verify that right you still have

00:22:41,260 --> 00:22:48,309
to go through QA or whatever but at

00:22:45,399 --> 00:22:50,139
least you took out from the equation the

00:22:48,309 --> 00:22:52,419
engineering effort to do the backward

00:22:50,139 --> 00:22:55,210
right if you put that into the machinery

00:22:52,419 --> 00:22:58,120
of your litigation that works really

00:22:55,210 --> 00:23:01,240
really well and this way of doing things

00:22:58,120 --> 00:23:03,340
allowed us to remove all the backwards

00:23:01,240 --> 00:23:06,070
support all these steps that we saw and

00:23:03,340 --> 00:23:08,620
it turns out that even after adding the

00:23:06,070 --> 00:23:10,720
support for the previous version that we

00:23:08,620 --> 00:23:13,510
wanted the support of the product we

00:23:10,720 --> 00:23:16,240
still get a significant drop-off line

00:23:13,510 --> 00:23:18,340
counts and if you want to think of it

00:23:16,240 --> 00:23:20,559
from a different perspective if you look

00:23:18,340 --> 00:23:23,110
at the total line of counter of line of

00:23:20,559 --> 00:23:26,110
code that we needed to support of course

00:23:23,110 --> 00:23:27,970
all the versions that significally

00:23:26,110 --> 00:23:31,929
reduced itself because before we have

00:23:27,970 --> 00:23:33,399
server versions of slightly similar the

00:23:31,929 --> 00:23:35,289
same driver for different version of the

00:23:33,399 --> 00:23:40,380
harbor now we have just one and of

00:23:35,289 --> 00:23:43,870
course most of it is exactly the same so

00:23:40,380 --> 00:23:47,500
backwards compatibility isn't was

00:23:43,870 --> 00:23:50,409
another source of code that we found out

00:23:47,500 --> 00:23:56,350
that we can remove and actually get

00:23:50,409 --> 00:24:01,389
things better moving forward there are a

00:23:56,350 --> 00:24:04,690
lot of places where the programmers were

00:24:01,389 --> 00:24:07,419
simply using the wrong API and this is

00:24:04,690 --> 00:24:10,510
really a great example so the original

00:24:07,419 --> 00:24:13,960
driver had the sisyphus interface to

00:24:10,510 --> 00:24:16,870
allow basically low-level debugging or

00:24:13,960 --> 00:24:17,660
picking into some registers to find out

00:24:16,870 --> 00:24:20,000
what's going

00:24:17,660 --> 00:24:22,450
and tracing of events in the driver

00:24:20,000 --> 00:24:25,460
which were really not of interest to

00:24:22,450 --> 00:24:27,860
almost any of the users it was really

00:24:25,460 --> 00:24:29,840
for the development and debugging and it

00:24:27,860 --> 00:24:32,330
was originally as I said ever up with

00:24:29,840 --> 00:24:34,310
Sisyphus now Sisyphus as the

00:24:32,330 --> 00:24:36,080
documentation says is duffle system for

00:24:34,310 --> 00:24:40,070
exporting killer object whatever that

00:24:36,080 --> 00:24:41,840
means and it provides the mean to export

00:24:40,070 --> 00:24:43,370
kernel data structure their tribute in

00:24:41,840 --> 00:24:47,570
the linkage between them to user space

00:24:43,370 --> 00:24:49,520
so this is you know if if you are

00:24:47,570 --> 00:24:52,670
external developer not necessarily in

00:24:49,520 --> 00:24:54,170
one that is in tune with the kernel

00:24:52,670 --> 00:24:56,720
community way of doing things you read

00:24:54,170 --> 00:24:59,000
this and say okay so make sense this

00:24:56,720 --> 00:25:01,670
looks like a good interface to use in

00:24:59,000 --> 00:25:05,120
order to push my debug levers or

00:25:01,670 --> 00:25:07,040
whatever but actually it's really wrong

00:25:05,120 --> 00:25:09,230
the wrong one this is not the one you

00:25:07,040 --> 00:25:11,870
want to use for the kind of things that

00:25:09,230 --> 00:25:15,380
I'll describe basically debug tracing

00:25:11,870 --> 00:25:17,780
there's actually debug if S which has

00:25:15,380 --> 00:25:19,190
the reputation says exists is a simple

00:25:17,780 --> 00:25:21,500
way for kernel developers to make

00:25:19,190 --> 00:25:26,270
information available user space itself

00:25:21,500 --> 00:25:29,630
etc uh and the difference may seem I

00:25:26,270 --> 00:25:32,930
didn't know semiotic but in the end of

00:25:29,630 --> 00:25:35,710
the day when we took the line count of

00:25:32,930 --> 00:25:39,890
implementing pretty much the same thing

00:25:35,710 --> 00:25:42,350
over Sisyphus and then then did it over

00:25:39,890 --> 00:25:45,940
the buggy fests lo and behold we cut

00:25:42,350 --> 00:25:51,500
down almost four times the line of code

00:25:45,940 --> 00:25:53,780
okay because the person who designed the

00:25:51,500 --> 00:25:57,830
buggy FS or destroy the code through it

00:25:53,780 --> 00:25:59,990
I'm not sure it was designed was trying

00:25:57,830 --> 00:26:03,320
to do something very specific right to

00:25:59,990 --> 00:26:05,450
help debug provide like a debug window

00:26:03,320 --> 00:26:07,610
into a driver or piece of code and

00:26:05,450 --> 00:26:09,710
therefore they had infrastructure that

00:26:07,610 --> 00:26:13,550
exactly matched what we needed to do and

00:26:09,710 --> 00:26:16,640
we didn't need to write it now I'm just

00:26:13,550 --> 00:26:18,170
in the sake of honesty the whole picture

00:26:16,640 --> 00:26:19,880
should be mentioned that some of the

00:26:18,170 --> 00:26:25,220
functionality we can just remove because

00:26:19,880 --> 00:26:28,010
it basically also replicated perf K or F

00:26:25,220 --> 00:26:28,890
trace depending on what you wanted no

00:26:28,010 --> 00:26:33,150
but

00:26:28,890 --> 00:26:38,190
again the big change was due for two

00:26:33,150 --> 00:26:42,860
just using the right API so lesson

00:26:38,190 --> 00:26:45,179
number three use the right API okay the

00:26:42,860 --> 00:26:46,799
fact that you could do something with a

00:26:45,179 --> 00:26:47,700
certain API does not necessarily mean

00:26:46,799 --> 00:26:49,799
it's the right one

00:26:47,700 --> 00:26:52,049
sometimes there's several API that may

00:26:49,799 --> 00:26:53,760
fit and it's worth the time of the

00:26:52,049 --> 00:27:00,750
effort was the question which one of

00:26:53,760 --> 00:27:04,679
them is the best moving along what I'd

00:27:00,750 --> 00:27:08,040
like to call duct-tape engineering which

00:27:04,679 --> 00:27:11,309
is it goes like this this is best

00:27:08,040 --> 00:27:14,010
described as an example so we have a

00:27:11,309 --> 00:27:16,169
device driver that supported some a

00:27:14,010 --> 00:27:19,559
synchronic hardwood that work with DMA

00:27:16,169 --> 00:27:21,720
and so forth to handle crypto operation

00:27:19,559 --> 00:27:24,390
now it turns out that the linux kernel

00:27:21,720 --> 00:27:27,360
actually have two sort of flavors of api

00:27:24,390 --> 00:27:31,980
to ask for cryptographic operation

00:27:27,360 --> 00:27:34,440
that's in chronics one which we was was

00:27:31,980 --> 00:27:37,080
very natural or native for us to support

00:27:34,440 --> 00:27:39,660
and a synchronous one which is actually

00:27:37,080 --> 00:27:41,850
meant for a basically software that runs

00:27:39,660 --> 00:27:44,220
on the CPU which may or may not use

00:27:41,850 --> 00:27:46,230
specialized instruction but it's for

00:27:44,220 --> 00:27:48,030
stuff that is actually inherent to stuff

00:27:46,230 --> 00:27:49,710
that is in the core it actually has

00:27:48,030 --> 00:27:53,730
access to that he'll be in the MMU of

00:27:49,710 --> 00:27:56,190
the court the thing is there is a lot of

00:27:53,730 --> 00:27:58,440
security oriented software on models in

00:27:56,190 --> 00:28:02,700
the kernel such as the inverter for

00:27:58,440 --> 00:28:06,210
example that was written to use the

00:28:02,700 --> 00:28:09,720
synchronous API and we can go into a

00:28:06,210 --> 00:28:13,440
whole article of asking yourself why is

00:28:09,720 --> 00:28:16,559
that and that is actually a presentation

00:28:13,440 --> 00:28:19,410
by itself basically the short answer is

00:28:16,559 --> 00:28:21,900
because the a synchronic API and the

00:28:19,410 --> 00:28:25,080
most common way of using it was too

00:28:21,900 --> 00:28:27,000
complicated and I actually offered an

00:28:25,080 --> 00:28:29,850
upstream a set of patches to fix that

00:28:27,000 --> 00:28:33,690
but that is the side point the point is

00:28:29,850 --> 00:28:38,580
that before that I came in the way that

00:28:33,690 --> 00:28:39,360
our driver or the previous developed

00:28:38,580 --> 00:28:40,830
dealt with that

00:28:39,360 --> 00:28:42,690
we're saying the following thing so

00:28:40,830 --> 00:28:45,680
there's a bunch of software in the

00:28:42,690 --> 00:28:47,880
kernel that actually uses cryptographic

00:28:45,680 --> 00:28:49,920
algorithm that we can accelerate but

00:28:47,880 --> 00:28:50,880
it's using the synchronous API not a

00:28:49,920 --> 00:28:53,310
synchronous one

00:28:50,880 --> 00:28:55,800
so obviously the right thing to do for

00:28:53,310 --> 00:29:00,630
us would be to support also the

00:28:55,800 --> 00:29:02,520
synchronous API which may sound like it

00:29:00,630 --> 00:29:05,330
makes sense if you don't go into the

00:29:02,520 --> 00:29:11,340
details but the reality is that if you

00:29:05,330 --> 00:29:16,950
try to take DMA using off core piece of

00:29:11,340 --> 00:29:20,670
hardware and make it behave or expose

00:29:16,950 --> 00:29:25,590
yourself as a totally synchronic API

00:29:20,670 --> 00:29:27,330
which was born or design for basically a

00:29:25,590 --> 00:29:32,190
piece of software on the CPU and have

00:29:27,330 --> 00:29:35,070
access to the MMU what you get is damn

00:29:32,190 --> 00:29:38,670
ugly okay really really ugly and

00:29:35,070 --> 00:29:42,240
unstable and there is an obvious

00:29:38,670 --> 00:29:44,790
solution to the same problem which is

00:29:42,240 --> 00:29:48,260
much much simpler and require much much

00:29:44,790 --> 00:29:51,930
less code inside the driver and that is

00:29:48,260 --> 00:29:54,630
go to the in Verity ask the question why

00:29:51,930 --> 00:29:57,630
is it using the synchronous API and when

00:29:54,630 --> 00:30:00,240
you find out the dancer is not a really

00:29:57,630 --> 00:30:02,780
good reason just change it okay this is

00:30:00,240 --> 00:30:06,090
the glory of open source

00:30:02,780 --> 00:30:09,630
don't try and this is a big one don't

00:30:06,090 --> 00:30:12,120
try to fix in your device driver stuff

00:30:09,630 --> 00:30:14,490
that is broken or can be optimized

00:30:12,120 --> 00:30:17,810
elsewhere because when you do your

00:30:14,490 --> 00:30:21,150
device driver just expands ridiculously

00:30:17,810 --> 00:30:22,950
use the source look right you have that

00:30:21,150 --> 00:30:25,260
access to just go and fix what need to

00:30:22,950 --> 00:30:27,600
succeed in the other side and it turns

00:30:25,260 --> 00:30:29,700
out that the amount of code needed to

00:30:27,600 --> 00:30:31,410
actually fix the in Verity was very

00:30:29,700 --> 00:30:35,190
small the amount of effort was very

00:30:31,410 --> 00:30:37,410
small and that allowed us to cut down a

00:30:35,190 --> 00:30:42,680
huge amount of code which was also buggy

00:30:37,410 --> 00:30:45,390
from the device driver itself okay so

00:30:42,680 --> 00:30:50,220
avoid duct-tape engineering fix stuff

00:30:45,390 --> 00:30:52,190
the right way use the fact that Linux is

00:30:50,220 --> 00:30:55,309
an open source platform and you

00:30:52,190 --> 00:30:59,080
don't need to try to work around the

00:30:55,309 --> 00:31:03,289
problem just fix the problem much easier

00:30:59,080 --> 00:31:06,500
next time theme on the list I'm not sure

00:31:03,289 --> 00:31:10,970
it's a general one but it's it's worth

00:31:06,500 --> 00:31:14,690
mentioning I called it macro gymnastics

00:31:10,970 --> 00:31:18,639
I'm not sure why actually I have clue

00:31:14,690 --> 00:31:23,330
okay I think it came about because of

00:31:18,639 --> 00:31:25,639
this horrible idea called a hull of PAL

00:31:23,330 --> 00:31:29,919
hardware abstraction layer platform

00:31:25,639 --> 00:31:32,809
abstraction layer there's this idea that

00:31:29,919 --> 00:31:35,360
if you write a device driver that maybe

00:31:32,809 --> 00:31:37,600
someday someone we want to use in some

00:31:35,360 --> 00:31:42,620
different platform the right way is to

00:31:37,600 --> 00:31:45,080
put a bunch of code that hides away as

00:31:42,620 --> 00:31:46,549
if it that is actually possible the

00:31:45,080 --> 00:31:48,500
specific of the interface to the

00:31:46,549 --> 00:31:52,070
hardware on the software and then code

00:31:48,500 --> 00:31:55,070
above that as you can tell I'm not very

00:31:52,070 --> 00:31:58,490
fond of the idea these abstraction tend

00:31:55,070 --> 00:32:00,799
to be very leaky what usually ends up is

00:31:58,490 --> 00:32:03,679
that nobody is actually using the name

00:32:00,799 --> 00:32:05,600
driver on other operating system and if

00:32:03,679 --> 00:32:07,669
they do they're using some fork off

00:32:05,600 --> 00:32:09,799
version that is very different but you

00:32:07,669 --> 00:32:13,460
still get stuck with all those mechanics

00:32:09,799 --> 00:32:15,559
of those hardware abstraction layer they

00:32:13,460 --> 00:32:18,799
are actually have a great effect on

00:32:15,559 --> 00:32:20,929
performance even wasn't that even worse

00:32:18,799 --> 00:32:22,580
than that they have a huge effect on the

00:32:20,929 --> 00:32:26,000
design of your driver because when

00:32:22,580 --> 00:32:28,009
you're trying to go to this to serve a

00:32:26,000 --> 00:32:29,809
couple of operating systems or platforms

00:32:28,009 --> 00:32:32,690
you have to go to the lowest common

00:32:29,809 --> 00:32:37,220
denominator that's really bad

00:32:32,690 --> 00:32:38,990
so in our specific case the actual hull

00:32:37,220 --> 00:32:39,500
pile concept was not really there

00:32:38,990 --> 00:32:41,600
anymore

00:32:39,500 --> 00:32:42,919
the people who program this were smart

00:32:41,600 --> 00:32:45,950
enough to figure out it doesn't really

00:32:42,919 --> 00:32:49,549
work and remove it the driver was only

00:32:45,950 --> 00:32:53,360
supporting Linux but yet we had this

00:32:49,549 --> 00:32:56,269
legacy of trying to base something on

00:32:53,360 --> 00:32:59,539
this no longer existing interface and

00:32:56,269 --> 00:33:05,240
that manifests itself by having stuff

00:32:59,539 --> 00:33:06,170
like just go and read a register looking

00:33:05,240 --> 00:33:08,630
like this

00:33:06,170 --> 00:33:11,480
right it's this macro that has the name

00:33:08,630 --> 00:33:15,290
of the register and there was this

00:33:11,480 --> 00:33:19,190
really I guess I'll be polite and say

00:33:15,290 --> 00:33:21,410
rich set of macros calling macros that

00:33:19,190 --> 00:33:24,110
wrap it and I'm sure there was a reason

00:33:21,410 --> 00:33:25,820
at some point in time for making all

00:33:24,110 --> 00:33:28,100
this maybe not a good one but it

00:33:25,820 --> 00:33:31,280
certainly no longer existed when I took

00:33:28,100 --> 00:33:34,670
over the driver so I was able to turn on

00:33:31,280 --> 00:33:37,130
all that crap into just this okay just a

00:33:34,670 --> 00:33:40,190
simple static in line with a simple

00:33:37,130 --> 00:33:44,270
backhoe just to make it so I don't have

00:33:40,190 --> 00:33:46,550
to write a big define that was

00:33:44,270 --> 00:33:52,370
auto-generated in anywhere and can just

00:33:46,550 --> 00:33:54,020
use the name so again it is worth when

00:33:52,370 --> 00:33:56,420
you write code and when you review other

00:33:54,020 --> 00:34:00,310
people code it is both looking into

00:33:56,420 --> 00:34:03,410
things and if you start to see too much

00:34:00,310 --> 00:34:05,540
macro wrappers it's it's a good idea to

00:34:03,410 --> 00:34:08,020
stop and ask yourself is this really

00:34:05,540 --> 00:34:11,690
clear is this really serving the purpose

00:34:08,020 --> 00:34:15,890
because this is not maintainable but

00:34:11,690 --> 00:34:21,620
this is okay and again that cut a few

00:34:15,890 --> 00:34:24,040
more lines of code that's a favorite of

00:34:21,620 --> 00:34:31,300
mine that's actually quite surprising

00:34:24,040 --> 00:34:35,419
zombie code okay you would think that

00:34:31,300 --> 00:34:38,179
there would not be too much of code

00:34:35,419 --> 00:34:41,600
inside a device driver that somebody

00:34:38,179 --> 00:34:44,659
maintains that nobody is actually using

00:34:41,600 --> 00:34:46,640
anymore and maybe never used but as

00:34:44,659 --> 00:34:48,830
we've heard before in one of the

00:34:46,640 --> 00:34:50,899
keynotes what is true for the bigger

00:34:48,830 --> 00:34:52,820
Linux is certainly true often for my

00:34:50,899 --> 00:34:56,060
small device driver there was huge

00:34:52,820 --> 00:34:59,260
amount of code that was never used now

00:34:56,060 --> 00:35:01,940
part of this was never used at all ever

00:34:59,260 --> 00:35:04,220
because it was some structures which

00:35:01,940 --> 00:35:07,010
which auto-generated from description of

00:35:04,220 --> 00:35:08,870
registers that we got from the the

00:35:07,010 --> 00:35:13,610
huddle guys and so on but we never

00:35:08,870 --> 00:35:17,210
actually used some of the got to be

00:35:13,610 --> 00:35:19,559
unused when we move from proprietary or

00:35:17,210 --> 00:35:22,920
specific mechanism to general colonel

00:35:19,559 --> 00:35:26,059
mechanism such for stuff like tracing

00:35:22,920 --> 00:35:31,109
for example which made some of the code

00:35:26,059 --> 00:35:33,539
unneeded and some of this of that I'm

00:35:31,109 --> 00:35:35,579
I'm just not sure right there was just

00:35:33,539 --> 00:35:38,099
some code that we removed and when we

00:35:35,579 --> 00:35:40,859
started to unravel what that code needed

00:35:38,099 --> 00:35:42,359
and start deleting all the code that was

00:35:40,859 --> 00:35:44,789
no longer needed because we made

00:35:42,359 --> 00:35:47,339
something work a little bit different we

00:35:44,789 --> 00:35:50,219
just began to see that we can delete a

00:35:47,339 --> 00:35:54,449
whole bunch of stuff so you can see that

00:35:50,219 --> 00:35:56,759
it's both a while if you had an ongoing

00:35:54,449 --> 00:35:59,130
project and certainly if you do an

00:35:56,759 --> 00:36:01,349
absolutely work to go over the code and

00:35:59,130 --> 00:36:03,329
ask yourself is somebody actually using

00:36:01,349 --> 00:36:06,930
this and get crap is really a good

00:36:03,329 --> 00:36:11,789
friend in this in this endeavor because

00:36:06,930 --> 00:36:13,469
remember code which is not their data

00:36:11,789 --> 00:36:15,539
structure which are not there cannot be

00:36:13,469 --> 00:36:18,859
used against you right they cannot hold

00:36:15,539 --> 00:36:22,739
bugs and this even have a new and

00:36:18,859 --> 00:36:24,599
frightening new meaning in the brave new

00:36:22,739 --> 00:36:27,299
world of spectra if you think about that

00:36:24,599 --> 00:36:30,299
okay code that is never called can still

00:36:27,299 --> 00:36:32,729
be speculatively executed with specter

00:36:30,299 --> 00:36:34,679
variant too so it's really bad idea to

00:36:32,729 --> 00:36:36,359
leave out code there especially one that

00:36:34,679 --> 00:36:40,679
you is not maintained because you know

00:36:36,359 --> 00:36:46,189
it's not getting caught maybe one

00:36:40,679 --> 00:36:49,289
example of this is worth focusing into

00:36:46,189 --> 00:36:50,759
some of it was not actually code but as

00:36:49,289 --> 00:36:52,439
I said definition that got

00:36:50,759 --> 00:36:54,809
auto-generated from somehow to a

00:36:52,439 --> 00:36:56,759
register description files and and we

00:36:54,809 --> 00:36:59,130
see that a lot I think in the kernel

00:36:56,759 --> 00:37:02,130
right there's this huge H file with

00:36:59,130 --> 00:37:04,380
description of the registers now I'm not

00:37:02,130 --> 00:37:05,910
saying we should just kill all of them

00:37:04,380 --> 00:37:08,339
and leave just the one that you using

00:37:05,910 --> 00:37:10,949
but you know maybe it's worthwhile to

00:37:08,339 --> 00:37:13,199
ask the question does it really add

00:37:10,949 --> 00:37:15,509
something if we have you know this H

00:37:13,199 --> 00:37:17,579
file of 32,000 or whatever register

00:37:15,509 --> 00:37:21,179
definition and the driver only uses ten

00:37:17,579 --> 00:37:24,709
I don't know it's it's a good question

00:37:21,179 --> 00:37:28,309
I'm quite very much aware that these are

00:37:24,709 --> 00:37:31,229
auto-generated in a lot of cases but

00:37:28,309 --> 00:37:32,600
when you want to debug something do you

00:37:31,229 --> 00:37:37,580
really need all that crap

00:37:32,600 --> 00:37:39,980
is it helpful so in our case we left

00:37:37,580 --> 00:37:43,910
some of the definitions and remove

00:37:39,980 --> 00:37:45,470
others according to specific it's a hard

00:37:43,910 --> 00:37:48,350
road blocks or pattern of usage that

00:37:45,470 --> 00:37:50,300
made sense to us you know in some cases

00:37:48,350 --> 00:37:52,280
we took the whole auto-generated file we

00:37:50,300 --> 00:37:56,420
left it there some case we said you know

00:37:52,280 --> 00:37:58,250
what we really will will never be using

00:37:56,420 --> 00:37:59,720
any of the other you know registers and

00:37:58,250 --> 00:38:01,790
so on there for a very specific purpose

00:37:59,720 --> 00:38:05,650
it's not relevant if we will need them

00:38:01,790 --> 00:38:10,340
we'll add them later again and that

00:38:05,650 --> 00:38:14,480
helped us drop even more code the last

00:38:10,340 --> 00:38:17,120
one is kind of mundane I mean it's the

00:38:14,480 --> 00:38:19,550
kind of thing you learn when you first

00:38:17,120 --> 00:38:21,860
start to program you know programming

00:38:19,550 --> 00:38:24,500
one on one don't repeat yourself you

00:38:21,860 --> 00:38:26,300
have to function they're basically doing

00:38:24,500 --> 00:38:28,430
the same thing but maybe with a small

00:38:26,300 --> 00:38:31,460
change so don't write the whole code

00:38:28,430 --> 00:38:33,950
again just write one single function and

00:38:31,460 --> 00:38:36,770
do a wrapper and so on there were not a

00:38:33,950 --> 00:38:38,540
lot of this but there was some and that

00:38:36,770 --> 00:38:40,910
was not because the previous program

00:38:38,540 --> 00:38:43,010
were necessarily bad it's just that when

00:38:40,910 --> 00:38:45,680
you have a large enough codebase and

00:38:43,010 --> 00:38:51,170
enough engineers walking around it

00:38:45,680 --> 00:38:52,820
sometimes in different times they're not

00:38:51,170 --> 00:38:55,070
necessarily aware of all the things that

00:38:52,820 --> 00:38:57,110
happening out of place of the driver but

00:38:55,070 --> 00:38:59,870
one of the opportunities that presented

00:38:57,110 --> 00:39:01,310
itself when we looked in the whole

00:38:59,870 --> 00:39:04,340
driver and did this work of app

00:39:01,310 --> 00:39:07,490
streaming was to locate these places

00:39:04,340 --> 00:39:09,500
were something slipped by and we had

00:39:07,490 --> 00:39:12,140
really common functionality that can be

00:39:09,500 --> 00:39:14,000
brought in to a single function and

00:39:12,140 --> 00:39:16,130
quite interesting some of it has been

00:39:14,000 --> 00:39:18,350
sort of hidden by the other changes

00:39:16,130 --> 00:39:20,570
right so the code name was maybe more

00:39:18,350 --> 00:39:22,340
complex so we were using all this macro

00:39:20,570 --> 00:39:24,140
gymnastics so it's not obvious that we

00:39:22,340 --> 00:39:25,730
was actually doing the same thing but

00:39:24,140 --> 00:39:28,340
once we went through some of the

00:39:25,730 --> 00:39:30,290
simplification motion it then became

00:39:28,340 --> 00:39:34,220
clear that it actually is doing the same

00:39:30,290 --> 00:39:37,100
thing so there is this acceleration

00:39:34,220 --> 00:39:40,400
effect right nonlinear effect that when

00:39:37,100 --> 00:39:42,410
you tidy something up it sort of helps

00:39:40,400 --> 00:39:46,840
you see the other opportunities for

00:39:42,410 --> 00:39:46,840
simplification musician

00:39:47,260 --> 00:39:58,600
okay so those were the you know the

00:39:54,590 --> 00:40:01,730
things that I learned that actually made

00:39:58,600 --> 00:40:05,240
the upstream drivers so much better and

00:40:01,730 --> 00:40:10,100
we got to happy and right really I think

00:40:05,240 --> 00:40:11,930
this morning I saw Gregor Hoffman email

00:40:10,100 --> 00:40:15,400
a keying this change it removed the

00:40:11,930 --> 00:40:20,530
staging copy because the crypto tree

00:40:15,400 --> 00:40:24,620
accepted formally the device driver and

00:40:20,530 --> 00:40:26,420
it took something like a year okay it's

00:40:24,620 --> 00:40:28,700
it's a question of resource investment

00:40:26,420 --> 00:40:31,790
really but I think it's really worth

00:40:28,700 --> 00:40:34,030
asking what did we get from this okay so

00:40:31,790 --> 00:40:37,940
I deleted a bunch of lines of code but

00:40:34,030 --> 00:40:40,430
really that driver got better and I

00:40:37,940 --> 00:40:43,250
don't mean better in the sense that okay

00:40:40,430 --> 00:40:46,160
it performs now one nanosecond faster

00:40:43,250 --> 00:40:48,710
some a obscure AES operation no not that

00:40:46,160 --> 00:40:52,670
kind of better I'm talking about better

00:40:48,710 --> 00:40:55,640
of being higher quality okay so it's

00:40:52,670 --> 00:40:58,190
faster time-to-market to make a new

00:40:55,640 --> 00:41:00,530
revision for a new hardware revision

00:40:58,190 --> 00:41:02,450
it's more secure because I have less

00:41:00,530 --> 00:41:04,070
code then it's much easier for me to go

00:41:02,450 --> 00:41:06,830
over it and make sure I didn't do a

00:41:04,070 --> 00:41:09,770
mistaken for others to do the same it's

00:41:06,830 --> 00:41:12,170
higher quality code that our customer

00:41:09,770 --> 00:41:14,570
that use these things in critical part

00:41:12,170 --> 00:41:18,980
of the system this stuff is what make

00:41:14,570 --> 00:41:22,010
sure it's a security critical component

00:41:18,980 --> 00:41:27,830
so it's really important in the business

00:41:22,010 --> 00:41:31,100
down top line sense got better and we

00:41:27,830 --> 00:41:33,110
got that benefit by doing up streaming

00:41:31,100 --> 00:41:36,770
and this is something important to

00:41:33,110 --> 00:41:38,870
remember okay yes we starting doing this

00:41:36,770 --> 00:41:41,090
because it's the right thing and this is

00:41:38,870 --> 00:41:42,470
standard operating procedure if possible

00:41:41,090 --> 00:41:45,890
in how to do the right thing in this

00:41:42,470 --> 00:41:48,590
regard not always easy or possible but

00:41:45,890 --> 00:41:50,150
when it is possible and we all knew it's

00:41:48,590 --> 00:41:56,270
the right thing and we'll make the code

00:41:50,150 --> 00:41:58,829
better but we really got the attention

00:41:56,270 --> 00:42:01,380
of a

00:41:58,829 --> 00:42:04,259
community some of them world expert at

00:42:01,380 --> 00:42:08,789
what they're doing working of us helping

00:42:04,259 --> 00:42:10,679
this code be better that's completely

00:42:08,789 --> 00:42:12,269
untrue Ville and I think it's also a

00:42:10,679 --> 00:42:14,479
good opportunity to say thank you to

00:42:12,269 --> 00:42:18,179
these guys not all of them are here I

00:42:14,479 --> 00:42:19,920
took this mostly out of just the get log

00:42:18,179 --> 00:42:22,319
of the changes that went in into this

00:42:19,920 --> 00:42:25,199
driver now think about it for a second

00:42:22,319 --> 00:42:28,469
okay it's a obscure piece of hardware I

00:42:25,199 --> 00:42:30,509
mean it's been used by a bazillion

00:42:28,469 --> 00:42:33,539
devices but you know most people don't

00:42:30,509 --> 00:42:35,339
have access to it or don't think about

00:42:33,539 --> 00:42:36,989
it although some of you may even run

00:42:35,339 --> 00:42:40,109
this on their phones they are not aware

00:42:36,989 --> 00:42:42,410
but we got all these people to

00:42:40,109 --> 00:42:45,929
contribute town and effort some of them

00:42:42,410 --> 00:42:49,259
you know Greco Hartman David Miller have

00:42:45,929 --> 00:42:52,079
it soon and so on to give us critical

00:42:49,259 --> 00:42:54,390
input that made this driver better in

00:42:52,079 --> 00:42:57,059
the business sense that certainly is

00:42:54,390 --> 00:42:59,189
worthwhile and it wasn't didn't take

00:42:57,059 --> 00:43:01,829
that long it's one engineer me working

00:42:59,189 --> 00:43:03,359
at this from one year taking into

00:43:01,829 --> 00:43:06,630
account that this is not the only thing

00:43:03,359 --> 00:43:08,579
I was working on and this was new code

00:43:06,630 --> 00:43:11,699
to me okay so it wasn't that difficult

00:43:08,579 --> 00:43:14,209
the benefit was huge and I really owe a

00:43:11,699 --> 00:43:19,339
debt of gratitude to all these guys so

00:43:14,209 --> 00:43:19,339
thank you if you're seeing the video and

00:43:19,670 --> 00:43:27,599
there's basically two things before I

00:43:25,140 --> 00:43:32,099
will let you ask questions should you

00:43:27,599 --> 00:43:36,630
have them one of them is a tradition I

00:43:32,099 --> 00:43:38,279
did not start but I'm happy to continue

00:43:36,630 --> 00:43:40,469
and that is to take a speaker survey

00:43:38,279 --> 00:43:42,479
with all of you so if one of you don't

00:43:40,469 --> 00:43:49,799
want to get picked in the picture this

00:43:42,479 --> 00:43:53,390
is a good time to duck and one last

00:43:49,799 --> 00:43:55,799
thing before questions is as it says

00:43:53,390 --> 00:43:58,019
just don't worry about it keep calm and

00:43:55,799 --> 00:43:59,729
upstream on it's really really worth the

00:43:58,019 --> 00:44:03,119
effort you learn a lot the code gets

00:43:59,729 --> 00:44:05,160
better I know it's hard to convince some

00:44:03,119 --> 00:44:07,650
time management so hopefully show them

00:44:05,160 --> 00:44:09,730
this presentation I'm sure they're smart

00:44:07,650 --> 00:44:19,609
people and will understand

00:44:09,730 --> 00:44:28,849
questions wow I was really that clear

00:44:19,609 --> 00:44:40,549
excellent alright then

00:44:28,849 --> 00:44:42,740
yes well it's a good question it

00:44:40,549 --> 00:44:47,390
certainly felt that way a couple of

00:44:42,740 --> 00:44:50,150
times but ok I I would be the question

00:44:47,390 --> 00:44:52,099
the question was were there a situation

00:44:50,150 --> 00:44:54,799
where I felt that the community led me

00:44:52,099 --> 00:44:58,369
astray or you know did not work with me

00:44:54,799 --> 00:44:59,690
so it's a good question I think it felt

00:44:58,369 --> 00:45:03,460
that way couple of times

00:44:59,690 --> 00:45:07,970
ok for I'll give a concrete example

00:45:03,460 --> 00:45:10,160
which I think will help explain my my

00:45:07,970 --> 00:45:11,809
answer better just in the beginning you

00:45:10,160 --> 00:45:14,390
know I have this huge R of seven

00:45:11,809 --> 00:45:18,980
thousand lines of code which I wanted

00:45:14,390 --> 00:45:20,660
you know to submit for review and I was

00:45:18,980 --> 00:45:22,430
kind of scratching who I had how to do

00:45:20,660 --> 00:45:25,190
it of course you can make a patch like a

00:45:22,430 --> 00:45:27,650
big seventeen thousand lines patch and

00:45:25,190 --> 00:45:29,269
submitting that that didn't seem you

00:45:27,650 --> 00:45:31,519
know sending that in a mainly so I tried

00:45:29,269 --> 00:45:34,220
put it on you know a git repository and

00:45:31,519 --> 00:45:37,700
sending like and we still know you need

00:45:34,220 --> 00:45:41,480
to break it down into committable or you

00:45:37,700 --> 00:45:44,089
know separate commutable atomic parts or

00:45:41,480 --> 00:45:46,279
the driver so we can review that so on

00:45:44,089 --> 00:45:47,900
one hand the logic of that made total

00:45:46,279 --> 00:45:49,190
sense they want to review it they can

00:45:47,900 --> 00:45:51,529
look at this thing on the other hand

00:45:49,190 --> 00:45:54,259
this is huge driver that already exists

00:45:51,529 --> 00:45:56,059
how do you tear it apart right it's I

00:45:54,259 --> 00:46:00,499
did not know how to do it at first it

00:45:56,059 --> 00:46:03,230
was quite kind of frustrating but

00:46:00,499 --> 00:46:05,180
there's one thing that really kept in

00:46:03,230 --> 00:46:08,119
the back of my mind for all this process

00:46:05,180 --> 00:46:10,910
and that is that I'm really going to a

00:46:08,119 --> 00:46:13,579
bunch of world expert or just random

00:46:10,910 --> 00:46:16,759
people and basically asking them to

00:46:13,579 --> 00:46:19,640
invest time in helping me so if they ask

00:46:16,759 --> 00:46:22,339
me to do something I need to do this I

00:46:19,640 --> 00:46:24,410
feel even if it does not seem wisdom

00:46:22,339 --> 00:46:27,170
and the point and when I started

00:46:24,410 --> 00:46:29,660
thinking about this I realize that what

00:46:27,170 --> 00:46:33,410
they're asking were not that difficult

00:46:29,660 --> 00:46:35,150
to do once you you know relieved

00:46:33,410 --> 00:46:40,999
yourself of the option of not doing this

00:46:35,150 --> 00:46:43,099
let's say and and so I did that and I

00:46:40,999 --> 00:46:46,249
actually got something in return

00:46:43,099 --> 00:46:48,949
so uh and that is that when I you know

00:46:46,249 --> 00:46:51,469
when t2 the mechanics of understanding

00:46:48,949 --> 00:46:53,390
how to actually slice the driver into

00:46:51,469 --> 00:46:56,029
pieces I learned something about the

00:46:53,390 --> 00:46:57,559
driver was not aware of before how its

00:46:56,029 --> 00:46:59,329
structured what's the different pieces

00:46:57,559 --> 00:47:02,539
that can function together what are not

00:46:59,329 --> 00:47:05,749
the the interdependencies and I think

00:47:02,539 --> 00:47:09,049
that this is a good example because what

00:47:05,749 --> 00:47:12,109
it says is that what's important is not

00:47:09,049 --> 00:47:15,109
necessarily any specific advice per se

00:47:12,109 --> 00:47:18,049
it's the process so even if I a certain

00:47:15,109 --> 00:47:20,269
point God may be less than actionable

00:47:18,049 --> 00:47:22,099
advices or something that you know it's

00:47:20,269 --> 00:47:24,319
not that important I think the whole

00:47:22,099 --> 00:47:26,509
process of somebody asking you it's like

00:47:24,319 --> 00:47:27,349
a huge exercising peer programming with

00:47:26,509 --> 00:47:30,259
some of the world

00:47:27,349 --> 00:47:32,329
you know best minds was useful in itself

00:47:30,259 --> 00:47:34,539
so even if somebody told me to do

00:47:32,329 --> 00:47:37,279
something which ended up being wrong

00:47:34,539 --> 00:47:38,929
understanding why it's wrong and being

00:47:37,279 --> 00:47:40,759
able to explain it to somebody which is

00:47:38,929 --> 00:47:46,640
the complete stranger and has no idea

00:47:40,759 --> 00:47:48,160
what my harder is was beneficial any

00:47:46,640 --> 00:47:51,160
more questions

00:47:48,160 --> 00:47:51,160
yes

00:47:58,230 --> 00:48:06,310
so the question is did we had problems

00:48:03,040 --> 00:48:09,730
getting customer to use the backboards

00:48:06,310 --> 00:48:11,110
web project so my answer has two parts

00:48:09,730 --> 00:48:14,020
first this is something which is still

00:48:11,110 --> 00:48:17,380
ongoing but our plan is not to let the

00:48:14,020 --> 00:48:19,420
customer use the back port project but

00:48:17,380 --> 00:48:22,690
for us right we use it as infrastructure

00:48:19,420 --> 00:48:25,300
we commit to the said customers on

00:48:22,690 --> 00:48:27,520
specific version that we support we use

00:48:25,300 --> 00:48:29,980
the back port mechanism in order to

00:48:27,520 --> 00:48:31,930
enable us to easily make the back port

00:48:29,980 --> 00:48:33,760
and deliver it to them so there's no

00:48:31,930 --> 00:48:35,500
expectation for the customer to do it of

00:48:33,760 --> 00:48:37,060
course through the customer want to use

00:48:35,500 --> 00:48:40,450
it to back port to some version which is

00:48:37,060 --> 00:48:43,030
not blessed by arm the business entity

00:48:40,450 --> 00:48:48,750
they are welcome to do it but that's up

00:48:43,030 --> 00:48:52,690
to them any more questions

00:48:48,750 --> 00:48:54,430
okay well thank you very much it's been

00:48:52,690 --> 00:48:57,390
a pleasure I hope you enjoyed it

00:48:54,430 --> 00:48:57,390

YouTube URL: https://www.youtube.com/watch?v=5PrM-wSWLjs


