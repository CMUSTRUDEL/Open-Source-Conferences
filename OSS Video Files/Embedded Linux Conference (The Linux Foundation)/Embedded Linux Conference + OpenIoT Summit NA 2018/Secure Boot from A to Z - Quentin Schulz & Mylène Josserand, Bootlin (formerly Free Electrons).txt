Title: Secure Boot from A to Z - Quentin Schulz & Mylène Josserand, Bootlin (formerly Free Electrons)
Publication date: 2018-03-14
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	Secure Boot from A to Z - Quentin Schulz & Mylène Josserand, Bootlin (formerly Free Electrons)

Based on our complementary experience on building a secure system on an i.MX6 custom board, we'll present how to build a complete chain-of-trust for a platform.

This talk will introduce each and every link of the chain-of-trust from the boot ROM to filesystem, as well as the bootloader and kernel with real life examples.

We'll go through everything needed from the signing of binaries (U-Boot and kernel) to the secured automation of kernel booting within the bootloader, the use of dm-verity and switchroot for securing the filesystem, and more. 

About Mylène Josserand
Mylène joined Bootlin (formerly Free Electrons) in 2016 as an embedded Linux engineer. She has 3 years of experience with Yocto Project / OpenEmbedded, both at Bootlin (formerly Free Electrons) and an automative company. At Bootlin (formerly Free Electrons), she helps customers to make their Yocto Project more usable and closer to best practices from the Yocto Project. Mylene is also a trainer for Bootlin (formerly Free Electrons) Yocto Project course, and made numerous updates and improvements to the training materials.As a Linux kernel developer, she has contributed patches for RTC drivers, audio support for Allwinner processors and a touchscreen driver.She spoke about Yocto Project at Embedded Recipes 2017. 

About Quentin Schulz
Quentin joined Bootlin (formerly Free Electrons) in mid-2016 as an embedded Linux engineer after spending a 6-month internship designing and building a board farm, and integrating it into KernelCI.

Since then, Quentin has been involved in various kernel and bootloader development tasks, such as support for PMIC, DVFS and ADCs for Allwinner SoCs, and adding support for new platforms based on the Allwinner A33 and Freescale/NXP i.MX6.

He presented the lab he built during his internship at ELCE 2016, presented PMICs support in the kernel at ELC 2017 and porting the Linux kernel and U-Boot to ARM boards at ELCE 2017.
Captions: 
	00:00:00,030 --> 00:00:06,569
good morning everybody yeah good morning

00:00:03,449 --> 00:00:10,320
so thank you for attending presentation

00:00:06,569 --> 00:00:13,080
so I'm mirin and with my colleague come

00:00:10,320 --> 00:00:18,359
come town we will present you the secure

00:00:13,080 --> 00:00:21,050
boot a short presentation so we are

00:00:18,359 --> 00:00:25,519
embedded Linux engineer at butene

00:00:21,050 --> 00:00:29,220
formally free electrons but due to some

00:00:25,519 --> 00:00:31,410
trademark dispute we change our company

00:00:29,220 --> 00:00:33,000
name but that's it we just change the

00:00:31,410 --> 00:00:36,450
company name we are still the same

00:00:33,000 --> 00:00:41,040
engineer the same team and still we are

00:00:36,450 --> 00:00:43,860
the strong open-source focus for

00:00:41,040 --> 00:00:47,910
customer we implemented a full chain of

00:00:43,860 --> 00:00:51,660
trust on a custom imx6 board and we

00:00:47,910 --> 00:00:55,860
wanted to share it in case it can help

00:00:51,660 --> 00:01:01,320
other people so this is what we are

00:00:55,860 --> 00:01:03,650
going to talk in this presentation short

00:01:01,320 --> 00:01:07,500
disclaimer we are definitely not

00:01:03,650 --> 00:01:12,360
security expert and we are presenting

00:01:07,500 --> 00:01:15,720
you one way to verify both on the board

00:01:12,360 --> 00:01:20,400
based on specific family of associate

00:01:15,720 --> 00:01:24,689
but some part can be applied to other

00:01:20,400 --> 00:01:31,740
board and container will tell you when

00:01:24,689 --> 00:01:36,960
there is some specificity on IMX SOC so

00:01:31,740 --> 00:01:41,670
first in iteration who wants to verify

00:01:36,960 --> 00:01:44,250
the boot sequence and why so there is

00:01:41,670 --> 00:01:47,939
product vendors they want to make sure

00:01:44,250 --> 00:01:50,729
that the device are used in the same way

00:01:47,939 --> 00:01:55,920
they should be and not for a different

00:01:50,729 --> 00:01:58,740
purpose also not for running an

00:01:55,920 --> 00:02:03,530
appropriate software so for example a

00:01:58,740 --> 00:02:08,789
company may have some software

00:02:03,530 --> 00:02:10,979
limitation and we'll need license for

00:02:08,789 --> 00:02:13,050
customer to have a fully featured

00:02:10,979 --> 00:02:16,260
software so VC

00:02:13,050 --> 00:02:20,970
it can be used with a Sheng of twist to

00:02:16,260 --> 00:02:23,150
be sure that the user using the fully

00:02:20,970 --> 00:02:28,260
featured software with the license and

00:02:23,150 --> 00:02:32,790
of course to protect customers without

00:02:28,260 --> 00:02:35,670
having some malware on your system so

00:02:32,790 --> 00:02:38,130
it's also an users they may want to make

00:02:35,670 --> 00:02:39,650
sure that the system has not been

00:02:38,130 --> 00:02:43,200
tampered with

00:02:39,650 --> 00:02:46,290
so basically it's to make sure that the

00:02:43,200 --> 00:02:50,640
diner is you are trying to load both our

00:02:46,290 --> 00:02:56,730
execute were built by a person that you

00:02:50,640 --> 00:02:59,490
trust so I would does it work everything

00:02:56,730 --> 00:03:01,740
is based on digital signature

00:02:59,490 --> 00:03:05,220
verification which is different from

00:03:01,740 --> 00:03:07,010
encryption so compound will show you in

00:03:05,220 --> 00:03:12,060
next slides the difference between

00:03:07,010 --> 00:03:14,370
signature verification and encryption so

00:03:12,060 --> 00:03:17,640
in fact the first element in the boot

00:03:14,370 --> 00:03:19,739
process authenticate the second one the

00:03:17,640 --> 00:03:22,380
second one will authenticate the third

00:03:19,739 --> 00:03:25,320
one at the transit and that's why it

00:03:22,380 --> 00:03:29,880
called a chain of trust because you have

00:03:25,320 --> 00:03:33,560
this chain mechanism and if any element

00:03:29,880 --> 00:03:36,480
is authenticate authenticated but not

00:03:33,560 --> 00:03:39,600
sufficiently locked down so for example

00:03:36,480 --> 00:03:42,750
if you let console access in bootloader

00:03:39,600 --> 00:03:46,190
or would access in userspace

00:03:42,750 --> 00:03:54,800
the device is not verified anymore and

00:03:46,190 --> 00:03:58,590
so you will break the chain of trust so

00:03:54,800 --> 00:04:02,280
this is how the chain of trust looks

00:03:58,590 --> 00:04:06,030
like so you have the one card it has a

00:04:02,280 --> 00:04:08,940
public key it used this public key to

00:04:06,030 --> 00:04:09,450
perform a signature verification on the

00:04:08,940 --> 00:04:13,530
bootloader

00:04:09,450 --> 00:04:16,590
then the bootloader public key and which

00:04:13,530 --> 00:04:19,140
will perform signature verification on

00:04:16,590 --> 00:04:21,600
the kernel and the kernel will have a

00:04:19,140 --> 00:04:25,140
digest to perform ash

00:04:21,600 --> 00:04:26,610
verification on the root filesystem so

00:04:25,140 --> 00:04:30,060
every component e

00:04:26,610 --> 00:04:33,569
verified using its digital signature and

00:04:30,060 --> 00:04:36,289
public key the root filesystem integrity

00:04:33,569 --> 00:04:41,189
is verified using ash mechanism we see

00:04:36,289 --> 00:04:43,860
later in next slide how it works and our

00:04:41,189 --> 00:04:45,900
experience so as I said before we

00:04:43,860 --> 00:04:51,330
implemented it on a system

00:04:45,900 --> 00:04:55,530
imx6 bond content work on the chain of

00:04:51,330 --> 00:04:59,789
trust from one card to the counter and I

00:04:55,530 --> 00:05:04,219
worked on the root filesystem box okay

00:04:59,789 --> 00:05:06,419
so now a little a little bit of well

00:05:04,219 --> 00:05:08,819
explanation on what are the differences

00:05:06,419 --> 00:05:12,090
between encryption and signature so

00:05:08,819 --> 00:05:14,430
husband told you the verified boot

00:05:12,090 --> 00:05:16,800
sequence or a secure boot as you call as

00:05:14,430 --> 00:05:19,439
it's called is based on signature and

00:05:16,800 --> 00:05:21,900
not encryption these are different

00:05:19,439 --> 00:05:23,759
things but they are compatible you can

00:05:21,900 --> 00:05:26,759
actually have encrypted that others that

00:05:23,759 --> 00:05:29,279
is also signed so here is the mandatory

00:05:26,759 --> 00:05:33,539
Alice and Bob example about encryption

00:05:29,279 --> 00:05:36,180
so the point of encryption is to well be

00:05:33,539 --> 00:05:41,009
able to send some data that is

00:05:36,180 --> 00:05:42,810
unreadable for anyone else that isn't

00:05:41,009 --> 00:05:46,110
supposed to receive for example the mail

00:05:42,810 --> 00:05:49,050
so here and we want to be sure that mail

00:05:46,110 --> 00:05:52,020
alice is sending it to Bob what I can

00:05:49,050 --> 00:05:55,110
only be read or written by red pipe on

00:05:52,020 --> 00:05:58,409
so you have as input the data and the

00:05:55,110 --> 00:06:01,259
public key of Bob which is the input to

00:05:58,409 --> 00:06:04,349
a math function so we don't care what is

00:06:01,259 --> 00:06:06,509
it but it's math function and then it

00:06:04,349 --> 00:06:08,330
outputs the encrypted data you send it

00:06:06,509 --> 00:06:11,460
over the Internet nobody can read it

00:06:08,330 --> 00:06:14,879
except Bob Bob receives the encrypted

00:06:11,460 --> 00:06:18,990
data and it put it into a math function

00:06:14,879 --> 00:06:22,680
along with the it's his public/private

00:06:18,990 --> 00:06:26,310
key sorry which is the only one to owns

00:06:22,680 --> 00:06:27,779
of course it's his private key into your

00:06:26,310 --> 00:06:30,779
math function and then you have the

00:06:27,779 --> 00:06:32,960
decrypted data and your sure Bob is the

00:06:30,779 --> 00:06:36,229
only one who is able to read this data

00:06:32,960 --> 00:06:39,280
the next one is actually the signature

00:06:36,229 --> 00:06:42,160
verification so here is the

00:06:39,280 --> 00:06:45,610
different purpose here you want to be

00:06:42,160 --> 00:06:47,580
sure that alleys so the one who sent

00:06:45,610 --> 00:06:49,660
them a to Bob is actually a lease and

00:06:47,580 --> 00:06:52,720
not somebody else

00:06:49,660 --> 00:06:57,730
the data is unencrypted so everybody can

00:06:52,720 --> 00:07:01,270
read it so basically a lease will take

00:06:57,730 --> 00:07:03,820
her private key and herded her put it

00:07:01,270 --> 00:07:06,850
into a math function will output a sign

00:07:03,820 --> 00:07:09,760
data it's readable by anyone as it

00:07:06,850 --> 00:07:12,820
seemed very important concept everybody

00:07:09,760 --> 00:07:16,150
can read it and go through the internet

00:07:12,820 --> 00:07:19,030
and Bob receives it you can read it and

00:07:16,150 --> 00:07:22,840
to attest that alice is the one who sent

00:07:19,030 --> 00:07:26,260
the mail well we'll use the public key

00:07:22,840 --> 00:07:28,570
of alice to actually verify the

00:07:26,260 --> 00:07:30,910
signature goes into a map function again

00:07:28,570 --> 00:07:33,550
a different one and what the data is

00:07:30,910 --> 00:07:36,820
verifying or not so we can attest it's

00:07:33,550 --> 00:07:38,530
actually Alice who has sent mail so

00:07:36,820 --> 00:07:41,710
that's it for the differences between

00:07:38,530 --> 00:07:45,130
encryption and signature so now you have

00:07:41,710 --> 00:07:48,430
to know that well the six or boot

00:07:45,130 --> 00:07:51,960
sequence it's it has consequences of

00:07:48,430 --> 00:07:55,120
course it's costly in terms of well

00:07:51,960 --> 00:07:57,490
putting it setting up the whole

00:07:55,120 --> 00:07:59,919
architecture for managing your keys

00:07:57,490 --> 00:08:03,520
creating your keys signing all your

00:07:59,919 --> 00:08:06,640
binaries etc so for of course it's a bit

00:08:03,520 --> 00:08:10,120
longer to handle all these cases those

00:08:06,640 --> 00:08:12,280
cases you have some added complexity to

00:08:10,120 --> 00:08:14,289
your workflow for developers because

00:08:12,280 --> 00:08:18,070
well once your platform is locked down

00:08:14,289 --> 00:08:21,810
and can only boot verified binaries you

00:08:18,070 --> 00:08:24,580
have to sign those binaries to test them

00:08:21,810 --> 00:08:26,860
and of course the good time is well

00:08:24,580 --> 00:08:28,660
increased because well you have a a

00:08:26,860 --> 00:08:32,349
bunch of authentication along the way to

00:08:28,660 --> 00:08:36,039
do prompt boot to the Linux prompt sorry

00:08:32,349 --> 00:08:37,390
and well last but not least you really

00:08:36,039 --> 00:08:39,669
have to be careful with your private

00:08:37,390 --> 00:08:42,070
keys because if one gets stolen or

00:08:39,669 --> 00:08:44,320
leaked then well you're pretty much

00:08:42,070 --> 00:08:47,920
screwed up because well anyone can sign

00:08:44,320 --> 00:08:50,380
your your binaries and then it's not

00:08:47,920 --> 00:08:52,630
secure anymore so that was it for the

00:08:50,380 --> 00:08:54,400
introduction and now we can go to the

00:08:52,630 --> 00:08:56,980
element of the chain of trust the ROM

00:08:54,400 --> 00:08:59,380
card order or as it's called the root of

00:08:56,980 --> 00:09:04,180
trust so this is really the main point

00:08:59,380 --> 00:09:06,460
of your chain of trust it's very

00:09:04,180 --> 00:09:09,910
specific to the SSE so it depends on

00:09:06,460 --> 00:09:14,410
your vendors not all SOC support secure

00:09:09,910 --> 00:09:16,840
booting and well as I told you before

00:09:14,410 --> 00:09:19,270
you need the public key to be able to

00:09:16,840 --> 00:09:21,100
verify the signature of binary so you

00:09:19,270 --> 00:09:23,680
need a way to securely store it

00:09:21,100 --> 00:09:28,030
somewhere that the ROM code can look at

00:09:23,680 --> 00:09:32,650
and well that depends on every vendor

00:09:28,030 --> 00:09:34,270
and implementation and it's definitely

00:09:32,650 --> 00:09:36,100
embedded in the ROM code so you don't

00:09:34,270 --> 00:09:38,320
have access to it you have to trace your

00:09:36,100 --> 00:09:40,180
vendor and there are definitely

00:09:38,320 --> 00:09:43,090
different vendors that implement some

00:09:40,180 --> 00:09:44,770
kind of sexual route so it's not the

00:09:43,090 --> 00:09:46,570
main one I would say exiting it's a

00:09:44,770 --> 00:09:51,220
garage male and Experian cetera and

00:09:46,570 --> 00:09:54,610
missing some short so now you have to

00:09:51,220 --> 00:09:58,690
have a way to store your public keys so

00:09:54,610 --> 00:10:03,190
this is very the specific way for an XP

00:09:58,690 --> 00:10:04,750
to end all the public keys so basically

00:10:03,190 --> 00:10:07,390
it's a non-volatile memory of course

00:10:04,750 --> 00:10:11,980
because you need it to be up when the

00:10:07,390 --> 00:10:14,530
good from start an expert uses OTP so

00:10:11,980 --> 00:10:19,420
one-time programmable fuses so basically

00:10:14,530 --> 00:10:24,220
a fuse if used also is well we could

00:10:19,420 --> 00:10:25,990
illustrate it with a wire and when the

00:10:24,220 --> 00:10:29,230
current path through the wire then it's

00:10:25,990 --> 00:10:31,510
a binary one and you apply a very very

00:10:29,230 --> 00:10:34,570
very high current to it and it disrupts

00:10:31,510 --> 00:10:36,820
the wire and then you can get a binary 0

00:10:34,570 --> 00:10:40,690
that's how it works and it's

00:10:36,820 --> 00:10:45,270
irreversible so once you have blow flus

00:10:40,690 --> 00:10:48,310
a fuse then what never gets wired again

00:10:45,270 --> 00:10:52,170
OTP fuses are really really expensive in

00:10:48,310 --> 00:10:55,210
terms of size of Cupid on your PCB and

00:10:52,170 --> 00:10:58,960
whereas the public is already at least

00:10:55,210 --> 00:11:01,850
one kilobyte and sometimes up to four

00:10:58,960 --> 00:11:03,350
kilobytes so

00:11:01,850 --> 00:11:05,959
maybe a good idea would be to actually

00:11:03,350 --> 00:11:10,360
store the hash of this key which is way

00:11:05,959 --> 00:11:13,339
way smaller in true well the OTP and

00:11:10,360 --> 00:11:15,440
have the public key in another place for

00:11:13,339 --> 00:11:18,380
example in the binary you're going to

00:11:15,440 --> 00:11:20,240
load that way you just have to check the

00:11:18,380 --> 00:11:23,089
hash of the public key that is embedded

00:11:20,240 --> 00:11:24,490
somewhere else and if it matches then

00:11:23,089 --> 00:11:28,250
you're good to go

00:11:24,490 --> 00:11:32,240
well now we have plenty of space so

00:11:28,250 --> 00:11:34,639
we're not using maybe four keys so that

00:11:32,240 --> 00:11:39,170
we can actually revoke some if some gets

00:11:34,639 --> 00:11:42,680
stolen or well lost so that way you can

00:11:39,170 --> 00:11:44,449
just revoke one key and just say well

00:11:42,680 --> 00:11:47,630
this one we don't want to use it anymore

00:11:44,449 --> 00:11:52,940
we can use any of the three remaining

00:11:47,630 --> 00:11:54,199
one so that's it for the next slide yeah

00:11:52,940 --> 00:11:57,259
thank you

00:11:54,199 --> 00:11:59,889
the rom code so basically the process is

00:11:57,259 --> 00:12:03,230
to know the bootloader in your secure

00:11:59,889 --> 00:12:06,589
space to avoid physical physical attacks

00:12:03,230 --> 00:12:08,990
so the point is here if you load you

00:12:06,589 --> 00:12:11,959
will recover and authenticate it from a

00:12:08,990 --> 00:12:15,560
space that isn't secure the problem is

00:12:11,959 --> 00:12:19,189
once you have to actually boot execute

00:12:15,560 --> 00:12:21,350
the binary well this is a time frame

00:12:19,189 --> 00:12:24,980
where an attacker can actually change

00:12:21,350 --> 00:12:28,759
the binary and make it like it was a ton

00:12:24,980 --> 00:12:32,149
skated while it was definitely not you

00:12:28,759 --> 00:12:35,630
then it loads a married public key which

00:12:32,149 --> 00:12:38,209
was in which is in you would put on the

00:12:35,630 --> 00:12:40,009
binary for example it checks the hash of

00:12:38,209 --> 00:12:42,380
the public key which is embedded in the

00:12:40,009 --> 00:12:45,529
binary of the bootloader against the one

00:12:42,380 --> 00:12:49,339
which is in a hash table of made of

00:12:45,529 --> 00:12:51,139
different otps fuses you check the

00:12:49,339 --> 00:12:54,110
public key then you execute the

00:12:51,139 --> 00:12:59,480
bootloader binary if it matches and on

00:12:54,110 --> 00:13:05,389
an XP for IMX etc as we see family it's

00:12:59,480 --> 00:13:08,000
called hav four high hands turns boot so

00:13:05,389 --> 00:13:11,779
how do you set it up for your board it's

00:13:08,000 --> 00:13:15,080
again very specific to your vendor here

00:13:11,779 --> 00:13:18,110
you use code signing tools so CST

00:13:15,080 --> 00:13:21,140
for creating the keys so the private and

00:13:18,110 --> 00:13:25,100
private keys and certificates you flush

00:13:21,140 --> 00:13:28,910
the shoes is using working and verified

00:13:25,100 --> 00:13:31,670
you good again using an XP specific code

00:13:28,910 --> 00:13:34,670
which is fuse flash or something I let

00:13:31,670 --> 00:13:37,339
fuse prog I think with a few stable

00:13:34,670 --> 00:13:40,399
written by CST you signed a good brother

00:13:37,339 --> 00:13:42,440
using again CST and you check the status

00:13:40,399 --> 00:13:45,020
of the bootloader HIV Andrew Scott

00:13:42,440 --> 00:13:48,110
status from the boot reference so from

00:13:45,020 --> 00:13:50,000
you good with a sign G boot which is

00:13:48,110 --> 00:13:53,330
also an expert specific and if you have

00:13:50,000 --> 00:13:55,070
reached this step successfully then you

00:13:53,330 --> 00:13:58,220
can decide to lock down your bootloader

00:13:55,070 --> 00:14:01,459
to actually restrict the loading of the

00:13:58,220 --> 00:14:05,630
bootloader to 1 which is authenticated

00:14:01,459 --> 00:14:08,149
so very fine and well if you just create

00:14:05,630 --> 00:14:10,130
one of the previous item and you you

00:14:08,149 --> 00:14:15,080
blow the locking few then you screwed up

00:14:10,130 --> 00:14:18,680
so be sure you doing the right thing so

00:14:15,080 --> 00:14:21,380
this is the to example the results of

00:14:18,680 --> 00:14:24,440
HIV status from your boot the first

00:14:21,380 --> 00:14:26,029
example you have the first line which is

00:14:24,440 --> 00:14:27,950
actually with disable this is because I

00:14:26,029 --> 00:14:30,350
haven't blown actually the locking fuse

00:14:27,950 --> 00:14:33,279
when it's blown then it's secure boot

00:14:30,350 --> 00:14:36,200
enabled if you have any HIV event

00:14:33,279 --> 00:14:37,690
following this line it means that you

00:14:36,200 --> 00:14:42,350
would rather hasn't been authenticated

00:14:37,690 --> 00:14:44,360
so it failed in the next example you can

00:14:42,350 --> 00:14:45,800
see no HIV haven't found well you

00:14:44,360 --> 00:14:49,010
successfully authenticated you put

00:14:45,800 --> 00:14:52,970
rudder so that was it for the ROM code

00:14:49,010 --> 00:14:55,690
part 228 well the bootloader but now you

00:14:52,970 --> 00:14:59,060
have to it on Sketchup kernel

00:14:55,690 --> 00:15:02,060
so just know one

00:14:59,060 --> 00:15:03,350
it's just no one so there is no point of

00:15:02,060 --> 00:15:06,950
having a sexual bootloader

00:15:03,350 --> 00:15:09,800
it's not a ton skated by the rom code so

00:15:06,950 --> 00:15:13,399
by that I mean if you can actually

00:15:09,800 --> 00:15:15,950
switch the bootloader with something

00:15:13,399 --> 00:15:19,790
that isn't authenticated then there is

00:15:15,950 --> 00:15:22,579
no point actually taking the time to

00:15:19,790 --> 00:15:25,310
authenticate it because well we they're

00:15:22,579 --> 00:15:28,340
not not authenticated bootloader you can

00:15:25,310 --> 00:15:29,930
do whatever you want after that

00:15:28,340 --> 00:15:31,790
the bootloader has to be sufficiently

00:15:29,930 --> 00:15:34,460
locked down so it depends on the

00:15:31,790 --> 00:15:37,570
bootloader binary your booting and this

00:15:34,460 --> 00:15:41,540
is there is a very specific use case

00:15:37,570 --> 00:15:44,480
well example for you boot in main line

00:15:41,540 --> 00:15:47,750
new booting main line has a environment

00:15:44,480 --> 00:15:49,940
wire were called verify if it's set to

00:15:47,750 --> 00:15:54,560
know your boot stops to verify the

00:15:49,940 --> 00:15:57,230
signature of images and that's what were

00:15:54,560 --> 00:15:59,300
what we want so we definitely do not

00:15:57,230 --> 00:16:01,010
want any user to access the console to

00:15:59,300 --> 00:16:03,440
set the environment variable from there

00:16:01,010 --> 00:16:08,690
so you have to disable the console at

00:16:03,440 --> 00:16:11,450
all well very important part point you

00:16:08,690 --> 00:16:13,310
should under no circumstances trust

00:16:11,450 --> 00:16:17,060
anything that isn't in an authenticated

00:16:13,310 --> 00:16:20,870
binary so I means that well environments

00:16:17,060 --> 00:16:22,340
are often on other mediums but there you

00:16:20,870 --> 00:16:24,890
can trust them because you cannot enter

00:16:22,340 --> 00:16:26,570
educate them so you should use the one

00:16:24,890 --> 00:16:28,430
which is definitely in the you would

00:16:26,570 --> 00:16:33,110
binary that was authenticated by the ROM

00:16:28,430 --> 00:16:36,980
cob well that doesn't really work with

00:16:33,110 --> 00:16:40,670
update software from Linux kernel

00:16:36,980 --> 00:16:43,940
because they always they often interact

00:16:40,670 --> 00:16:46,450
with the new boot environments to say

00:16:43,940 --> 00:16:50,450
you should put this image or this image

00:16:46,450 --> 00:16:51,980
so I've a painting patch for you to only

00:16:50,450 --> 00:16:58,030
load a handful of variables that you can

00:16:51,980 --> 00:17:02,300
control from the u-boot embedded

00:16:58,030 --> 00:17:04,910
environment binary and it can load from

00:17:02,300 --> 00:17:10,190
whichever medium you want to load the

00:17:04,910 --> 00:17:13,270
environment from so yeah that's it so

00:17:10,190 --> 00:17:16,220
now how it actually works you're gonna

00:17:13,270 --> 00:17:19,209
use the device rip blob which is

00:17:16,220 --> 00:17:23,690
basically the same as it's in kernel

00:17:19,209 --> 00:17:27,170
it's used to actually embed the public

00:17:23,690 --> 00:17:28,730
key within you with binary and this

00:17:27,170 --> 00:17:32,500
public key will be used to check the

00:17:28,730 --> 00:17:35,180
signature of the kernel images and

00:17:32,500 --> 00:17:37,190
because it's appended to the Ubud binary

00:17:35,180 --> 00:17:39,650
it's also authenticated by the wrong

00:17:37,190 --> 00:17:41,420
card so you can actually trust the

00:17:39,650 --> 00:17:46,400
public key which is with

00:17:41,420 --> 00:17:51,380
well you would binary so now to be a bit

00:17:46,400 --> 00:17:54,560
more practical and well simple to use to

00:17:51,380 --> 00:17:56,990
check the signature of different images

00:17:54,560 --> 00:17:58,790
you have two choices either you load one

00:17:56,990 --> 00:18:00,860
image and then it's signature and then

00:17:58,790 --> 00:18:03,350
the second image and its signature etc

00:18:00,860 --> 00:18:05,990
or you use the feed image which is

00:18:03,350 --> 00:18:09,050
basically container storing a lot of

00:18:05,990 --> 00:18:12,800
different binaries and there are hashes

00:18:09,050 --> 00:18:15,230
and MK image so the tool to actually

00:18:12,800 --> 00:18:18,110
compile the fit image has already built

00:18:15,230 --> 00:18:20,930
in support for signing in well doing the

00:18:18,110 --> 00:18:25,970
binaries hash so what we all nook so

00:18:20,930 --> 00:18:30,010
where I use this tool so well now in the

00:18:25,970 --> 00:18:32,540
process to get through to the next chain

00:18:30,010 --> 00:18:35,660
in a chain of trust you have to create

00:18:32,540 --> 00:18:37,850
actually your keys to verify the kernel

00:18:35,660 --> 00:18:40,340
signature to actually sign the boot

00:18:37,850 --> 00:18:43,460
Roger the sorry to sign the kernel and

00:18:40,340 --> 00:18:46,790
verified from the bootloader so the

00:18:43,460 --> 00:18:48,410
first line is to create an RSA for K key

00:18:46,790 --> 00:18:50,690
which is called my in Rose cocky

00:18:48,410 --> 00:18:52,490
this is a private key and then you

00:18:50,690 --> 00:18:57,560
create or certificate certificates is

00:18:52,490 --> 00:19:00,880
really close to public key so it's

00:18:57,560 --> 00:19:03,440
really an image requires the use of

00:19:00,880 --> 00:19:06,500
certificates and not public hits well

00:19:03,440 --> 00:19:08,480
it's a choice and it's really really

00:19:06,500 --> 00:19:10,790
important that your certificate and your

00:19:08,480 --> 00:19:16,190
privately owned in the same otherwise

00:19:10,790 --> 00:19:18,530
I'm climate reason work at all so this

00:19:16,190 --> 00:19:21,020
is an example of a source source file

00:19:18,530 --> 00:19:23,990
for the well the device tree used to

00:19:21,020 --> 00:19:26,870
embed the public key within the you good

00:19:23,990 --> 00:19:29,660
binary so we have to sing that through

00:19:26,870 --> 00:19:33,050
device Vinod if you ball already has

00:19:29,660 --> 00:19:35,120
device three well you should be able to

00:19:33,050 --> 00:19:38,870
use it and just add the signature device

00:19:35,120 --> 00:19:42,290
you know something to note is that key

00:19:38,870 --> 00:19:46,670
name hint and the suffix - Keith - DT

00:19:42,290 --> 00:19:48,470
note has to be the same value or name as

00:19:46,670 --> 00:19:50,600
the one you have given to your key so in

00:19:48,470 --> 00:19:54,770
the previous slide was - Corky you have

00:19:50,600 --> 00:19:57,590
to well use the same there is also

00:19:54,770 --> 00:20:01,070
which is called required it's it's

00:19:57,590 --> 00:20:03,590
either image or configuration it depends

00:20:01,070 --> 00:20:07,429
on which level you want to actually do

00:20:03,590 --> 00:20:10,120
your signature verification and you can

00:20:07,429 --> 00:20:12,350
find well the explanation in the

00:20:10,120 --> 00:20:16,550
documentation here in the you would

00:20:12,350 --> 00:20:18,679
project so what's the fifth image I say

00:20:16,550 --> 00:20:22,700
it's basically container so you have a

00:20:18,679 --> 00:20:25,490
set of images different 1 1 2 3 kernel

00:20:22,700 --> 00:20:27,170
whatever the same four device tree is

00:20:25,490 --> 00:20:31,179
interim phase we have also support for

00:20:27,170 --> 00:20:33,559
other kind of files like scripts and

00:20:31,179 --> 00:20:36,530
then you have also configuration so

00:20:33,559 --> 00:20:41,330
configurations are a way to force the

00:20:36,530 --> 00:20:43,460
user to load binaries together so for

00:20:41,330 --> 00:20:47,150
example here you have conf at one so the

00:20:43,460 --> 00:20:48,770
the red box which force the user to load

00:20:47,150 --> 00:20:52,190
the first candle the third device tree

00:20:48,770 --> 00:20:55,490
and the first instrument s so that's a

00:20:52,190 --> 00:20:57,620
way to force your user to put a 13

00:20:55,490 --> 00:21:00,970
configuration a certain configuration

00:20:57,620 --> 00:21:04,460
it supports different architectures OS

00:21:00,970 --> 00:21:06,410
image types and a lot of other things

00:21:04,460 --> 00:21:08,480
and you can find all of them in the

00:21:06,410 --> 00:21:13,550
source code in common slash image let's

00:21:08,480 --> 00:21:17,600
see so this is really a quick example of

00:21:13,550 --> 00:21:21,410
a source file for fit image so we have

00:21:17,600 --> 00:21:23,929
the image images device tree node with

00:21:21,410 --> 00:21:26,980
all the different binaries where we can

00:21:23,929 --> 00:21:31,370
find them where you can load your

00:21:26,980 --> 00:21:33,710
binaries which key to use to sign each

00:21:31,370 --> 00:21:35,570
of the binaries and you have the

00:21:33,710 --> 00:21:38,390
configurations on the on the on the

00:21:35,570 --> 00:21:42,530
right and there is an important line

00:21:38,390 --> 00:21:44,840
which is default equals cut one and this

00:21:42,530 --> 00:21:47,809
will be importance in the next upcoming

00:21:44,840 --> 00:21:52,010
slides and you can see that the convert

00:21:47,809 --> 00:21:54,170
one has kernel is equal to kernel at 1

00:21:52,010 --> 00:21:56,630
so it will be using the first kernel and

00:21:54,170 --> 00:22:03,679
the device reads which is also the first

00:21:56,630 --> 00:22:05,929
one so there is a little bit of tricks

00:22:03,679 --> 00:22:08,679
to do before compiling YouTube with

00:22:05,929 --> 00:22:13,249
binary you have to actually

00:22:08,679 --> 00:22:16,909
compile your divisor which contains the

00:22:13,249 --> 00:22:20,749
embedded publicly outside of usually

00:22:16,909 --> 00:22:25,580
would well source repository and this is

00:22:20,749 --> 00:22:27,950
because we need to use MK met which is a

00:22:25,580 --> 00:22:30,259
tool from you good to actually embed the

00:22:27,950 --> 00:22:35,419
public key before we are going to build

00:22:30,259 --> 00:22:37,789
the u-boot binary so you use DTC to do

00:22:35,419 --> 00:22:39,489
well first calculation of the u-boot

00:22:37,789 --> 00:22:42,379
public key the TTB

00:22:39,489 --> 00:22:46,249
then you compile all the tools from you

00:22:42,379 --> 00:22:48,739
boot your run MK image to actually build

00:22:46,249 --> 00:22:52,159
the fit image and at the same time embed

00:22:48,739 --> 00:22:54,019
the publicly within the device tree and

00:22:52,159 --> 00:22:55,970
then you compile you with binary using

00:22:54,019 --> 00:22:58,659
the external device rip lob which is

00:22:55,970 --> 00:23:02,389
called you boot underscore public key

00:22:58,659 --> 00:23:04,989
these did the order well the

00:23:02,389 --> 00:23:08,210
configuration you have to put to enable

00:23:04,989 --> 00:23:12,379
the fits fit image signature

00:23:08,210 --> 00:23:15,440
verification on a new good to say

00:23:12,379 --> 00:23:19,070
configure wave control is for embedding

00:23:15,440 --> 00:23:22,580
actually using actually the device Rabab

00:23:19,070 --> 00:23:29,629
support in you good and first two items

00:23:22,580 --> 00:23:32,330
are an expert specific so this is

00:23:29,629 --> 00:23:34,190
actually what it looks like to boot the

00:23:32,330 --> 00:23:36,980
fit image with all the verification

00:23:34,190 --> 00:23:39,470
steps etc so provided you have a 50

00:23:36,980 --> 00:23:45,080
minute laure that directs 15 let's say

00:23:39,470 --> 00:23:47,859
so you do boot m0x 15 pound cut 1 but

00:23:45,080 --> 00:23:51,320
since the default in the config age

00:23:47,859 --> 00:23:53,149
configurations node in the source file

00:23:51,320 --> 00:23:55,220
of your feet image you know that

00:23:53,149 --> 00:23:57,679
configure convert 1 is the default one

00:23:55,220 --> 00:24:00,889
so you can actually just keep the part

00:23:57,679 --> 00:24:04,789
after the pound so with them so X 15 is

00:24:00,889 --> 00:24:08,049
fine you can see that it's using convert

00:24:04,789 --> 00:24:10,909
1 it's trying to load the kernel at one

00:24:08,049 --> 00:24:13,249
there's all the things and verify the

00:24:10,909 --> 00:24:18,080
hash integrity which says well it's ok

00:24:13,249 --> 00:24:21,349
so let's get to the next binary in the

00:24:18,080 --> 00:24:22,250
in the fit image which is the joy siree

00:24:21,349 --> 00:24:24,710
Bob

00:24:22,250 --> 00:24:25,900
it checks it was fine so let's get

00:24:24,710 --> 00:24:29,660
started with the colonel

00:24:25,900 --> 00:24:33,290
but then someone touched the device

00:24:29,660 --> 00:24:36,500
revolve and well hopefully you will get

00:24:33,290 --> 00:24:38,930
it and stops the wood and that's what

00:24:36,500 --> 00:24:40,580
happened in the lower part of the this

00:24:38,930 --> 00:24:43,130
slide it's verifying the highest

00:24:40,580 --> 00:24:46,070
integrity they say no I cannot verify it

00:24:43,130 --> 00:24:48,170
so well I'm stopping there and I'm

00:24:46,070 --> 00:24:51,830
thrashing you which you shouldn't stop

00:24:48,170 --> 00:24:55,910
stop here so I think that was it for the

00:24:51,830 --> 00:24:58,970
part up to the root filesystem so now

00:24:55,910 --> 00:25:00,100
million we will present her part on root

00:24:58,970 --> 00:25:04,400
filesystem

00:25:00,100 --> 00:25:08,360
so it's the final part of the chain of

00:25:04,400 --> 00:25:12,100
trust to have a very fun root filesystem

00:25:08,360 --> 00:25:16,010
we have chosen in the following solution

00:25:12,100 --> 00:25:19,850
it's you can have other kind of solution

00:25:16,010 --> 00:25:23,180
but this is what we choose so first of

00:25:19,850 --> 00:25:26,120
all we did we wanted to have an inert

00:25:23,180 --> 00:25:29,030
variable file system so we choose to

00:25:26,120 --> 00:25:32,510
have a read-only file system so it's

00:25:29,030 --> 00:25:35,510
impossible to modify it so we use a

00:25:32,510 --> 00:25:39,170
squash surface image which is a type for

00:25:35,510 --> 00:25:41,930
read only file system so this part is

00:25:39,170 --> 00:25:44,570
not really part of the secure boot

00:25:41,930 --> 00:25:49,490
process but it was important for us and

00:25:44,570 --> 00:25:52,880
for our customer so the identification

00:25:49,490 --> 00:25:56,540
of the root filesystem so it's really is

00:25:52,880 --> 00:25:58,970
a part of the chain of trust we use the

00:25:56,540 --> 00:26:01,910
EM Verity so then Verity it's an

00:25:58,970 --> 00:26:04,460
infrastructure to check if the what file

00:26:01,910 --> 00:26:07,940
system is the one we are expecting to

00:26:04,460 --> 00:26:11,600
have so in fact it's the authentication

00:26:07,940 --> 00:26:14,420
of the squash FS image and then Verity

00:26:11,600 --> 00:26:17,750
needs user space application to

00:26:14,420 --> 00:26:23,330
authenticate the system and so you need

00:26:17,750 --> 00:26:25,910
to have this tools available so that's

00:26:23,330 --> 00:26:29,270
why we choose to you to have any

00:26:25,910 --> 00:26:31,929
trophies as first file system and in

00:26:29,270 --> 00:26:34,850
this image from FSU will have the

00:26:31,929 --> 00:26:38,660
application tools too

00:26:34,850 --> 00:26:43,430
from the authentication of the root

00:26:38,660 --> 00:26:46,150
filesystem the Anitra FS is built-in in

00:26:43,430 --> 00:26:51,110
the kernel so thanks to that it doesn't

00:26:46,150 --> 00:26:53,750
break the chain of trust because as

00:26:51,110 --> 00:26:56,510
content told you before the kernel it's

00:26:53,750 --> 00:27:04,070
already in the chain of threads using

00:26:56,510 --> 00:27:07,550
fit image so now the ability so DM it

00:27:04,070 --> 00:27:09,770
stands for device mapper it's an

00:27:07,550 --> 00:27:13,510
infrastructure in the Linux kernel to

00:27:09,770 --> 00:27:16,970
create virtual layers on block devices

00:27:13,510 --> 00:27:20,030
so device mapper Verity

00:27:16,970 --> 00:27:24,280
it's provides integrity checking of

00:27:20,030 --> 00:27:28,550
block devices using kernel crypto API

00:27:24,280 --> 00:27:32,570
the MVT could ask the whole block device

00:27:28,550 --> 00:27:35,270
and then compare the ash with an

00:27:32,570 --> 00:27:37,460
expected - but it's not doing that

00:27:35,270 --> 00:27:41,450
otherwise the boot time will be very

00:27:37,460 --> 00:27:45,590
very wrong so instead of that it's use

00:27:41,450 --> 00:27:48,800
cryptographic hash tree and your block

00:27:45,590 --> 00:27:53,570
device will be split in small block and

00:27:48,800 --> 00:27:57,920
each block will have it ash and it will

00:27:53,570 --> 00:28:00,500
create a stream until the last ash which

00:27:57,920 --> 00:28:04,370
is called wood ash we will use this wood

00:28:00,500 --> 00:28:09,560
ash in the authentication mechanism so

00:28:04,370 --> 00:28:14,660
we will sit in next slice and this block

00:28:09,560 --> 00:28:18,770
are hashed only on access so instead of

00:28:14,660 --> 00:28:20,720
having longer boot time we will just

00:28:18,770 --> 00:28:26,809
have a smaller

00:28:20,720 --> 00:28:30,020
no access on blog device and as I said

00:28:26,809 --> 00:28:33,740
before I am very teen its user space

00:28:30,020 --> 00:28:36,890
application so pretty setup package

00:28:33,740 --> 00:28:38,990
provide different tools such as Verity

00:28:36,890 --> 00:28:43,220
setup so we see in next slide

00:28:38,990 --> 00:28:48,400
levity setup is a tool to create the ash

00:28:43,220 --> 00:28:48,400
tree and also to authenticate the device

00:28:48,880 --> 00:28:58,270
so they are Vivat in our case so we have

00:28:53,299 --> 00:29:01,159
a kernel the ability has some

00:28:58,270 --> 00:29:03,350
configuration in the kernel so you need

00:29:01,159 --> 00:29:06,919
to enable this configuration to have

00:29:03,350 --> 00:29:09,590
them damn VVT and as I said before we

00:29:06,919 --> 00:29:12,679
have a need from FS and we created in

00:29:09,590 --> 00:29:15,980
the script that will use Verity setup

00:29:12,679 --> 00:29:20,150
tool to perform the verification on our

00:29:15,980 --> 00:29:22,909
blog device for our use case we use ubi

00:29:20,150 --> 00:29:27,220
block device but it can be also a kind

00:29:22,909 --> 00:29:30,700
of block device if the verification is

00:29:27,220 --> 00:29:33,590
successful then you can use mount

00:29:30,700 --> 00:29:38,030
command for example to have access of

00:29:33,590 --> 00:29:41,320
you squash FS that you verified and if

00:29:38,030 --> 00:29:45,140
it's not the case then it will fail to

00:29:41,320 --> 00:29:47,860
monitor squash FS and it will stop the

00:29:45,140 --> 00:29:47,860
init here

00:29:48,730 --> 00:29:57,130
so now let's see how to create the ash

00:29:53,090 --> 00:30:02,059
tree that we have seen in previous slide

00:29:57,130 --> 00:30:06,440
so there it is setup can create the ash

00:30:02,059 --> 00:30:09,470
tree on device or images for in this

00:30:06,440 --> 00:30:13,220
example it's on images but you can do it

00:30:09,470 --> 00:30:17,000
on device node so we have a squash FS

00:30:13,220 --> 00:30:22,220
image we perform Verity setup format

00:30:17,000 --> 00:30:25,130
command the resulting image is ash image

00:30:22,220 --> 00:30:28,400
and it's containing the ash tree that we

00:30:25,130 --> 00:30:32,390
will use to authenticate the device and

00:30:28,400 --> 00:30:35,630
it also prints on your screen

00:30:32,390 --> 00:30:38,390
- and we will you need to keep it

00:30:35,630 --> 00:30:41,540
because we will use it to auto ticket

00:30:38,390 --> 00:30:44,960
the device to be sure that to squash the

00:30:41,540 --> 00:30:48,530
first image that we've created actually

00:30:44,960 --> 00:30:52,940
what now it's the correct one that we

00:30:48,530 --> 00:30:56,720
want to authenticate so by default the

00:30:52,940 --> 00:31:01,100
damn velvety and very setup expect to

00:30:56,720 --> 00:31:04,090
have block device with data in there and

00:31:01,100 --> 00:31:08,360
another block device with the ash tree

00:31:04,090 --> 00:31:11,720
so the common used is very decent tap

00:31:08,360 --> 00:31:15,920
format then the data device and the ash

00:31:11,720 --> 00:31:18,890
device but in fact in our use case we

00:31:15,920 --> 00:31:21,950
want it to have only one device so our

00:31:18,890 --> 00:31:25,760
block device will add the squash FS

00:31:21,950 --> 00:31:29,360
image and also it will contains the ash

00:31:25,760 --> 00:31:33,500
tree for that we can contain the ash

00:31:29,360 --> 00:31:37,520
image at the end of the squash FS image

00:31:33,500 --> 00:31:43,520
to have at the end final squash FS

00:31:37,520 --> 00:31:50,000
containing also the ash tree to do that

00:31:43,520 --> 00:31:57,560
very witty setup tool as an option ash

00:31:50,000 --> 00:32:00,380
offset and to to say out to locate the

00:31:57,560 --> 00:32:06,050
ash area in the same device or image

00:32:00,380 --> 00:32:08,240
so yeah it's example of the command so

00:32:06,050 --> 00:32:11,660
very it is a table format then we set

00:32:08,240 --> 00:32:17,030
the offset so where we can find our tree

00:32:11,660 --> 00:32:22,070
in the same device or image pew NT in

00:32:17,030 --> 00:32:25,100
our example because ash tree is at the

00:32:22,070 --> 00:32:29,150
end of the squash FS image so offset is

00:32:25,100 --> 00:32:32,450
the size of the squash image image and

00:32:29,150 --> 00:32:36,770
then the data device so in our use case

00:32:32,450 --> 00:32:37,400
it's squash FS image and final visiting

00:32:36,770 --> 00:32:41,180
wizard

00:32:37,400 --> 00:32:47,420
so it's the squash FS image and also

00:32:41,180 --> 00:32:51,290
as image so now we have created our ash

00:32:47,420 --> 00:32:56,090
tree we have the wood ash and we will

00:32:51,290 --> 00:32:59,660
see how to authenticate the device so

00:32:56,090 --> 00:33:02,840
now we on our platform we flash flash

00:32:59,660 --> 00:33:06,200
all the different images and we are we

00:33:02,840 --> 00:33:10,400
have block device that contains the

00:33:06,200 --> 00:33:13,220
squash FS and ash image we use very T

00:33:10,400 --> 00:33:16,790
setup create command that we need the

00:33:13,220 --> 00:33:21,590
offset to know where to find the ash

00:33:16,790 --> 00:33:24,890
tree and also the wood ash if the ash

00:33:21,590 --> 00:33:28,250
correspond to the one that is available

00:33:24,890 --> 00:33:32,540
in the ash tree then you have a mapper

00:33:28,250 --> 00:33:35,000
device on the surface very fine so at

00:33:32,540 --> 00:33:38,960
the end you will have a slash dev slash

00:33:35,000 --> 00:33:42,260
mapper slash something and on this

00:33:38,960 --> 00:33:46,070
device mapper you can use the stone de

00:33:42,260 --> 00:33:50,260
mount command to then have access to

00:33:46,070 --> 00:33:54,980
your verified squash surface so the

00:33:50,260 --> 00:33:58,730
common use is very tight very tight VVT

00:33:54,980 --> 00:34:01,309
setup create then the name of the device

00:33:58,730 --> 00:34:06,530
mapper so in our example it's good file

00:34:01,309 --> 00:34:11,720
system it can be another one we again we

00:34:06,530 --> 00:34:16,970
use the ash offset option of Verity

00:34:11,720 --> 00:34:21,950
setup to say where to locate the ash

00:34:16,970 --> 00:34:25,760
tree in the device block then there is a

00:34:21,950 --> 00:34:30,290
data device and ash device in our use

00:34:25,760 --> 00:34:34,879
case into same one and finally the wood

00:34:30,290 --> 00:34:39,550
ash so because we use the same block

00:34:34,879 --> 00:34:45,350
device and it contains both data and ash

00:34:39,550 --> 00:34:48,290
image we use ubi block 0 twice of course

00:34:45,350 --> 00:34:52,460
if you use the default mechanism so if

00:34:48,290 --> 00:34:53,820
you have for example the data on ubi

00:34:52,460 --> 00:34:57,270
block 0

00:34:53,820 --> 00:35:00,540
the ash tree on ubi block 1 then you

00:34:57,270 --> 00:35:03,390
don't choose our offset parameters and

00:35:00,540 --> 00:35:10,170
you will have block 0 and block 1 in

00:35:03,390 --> 00:35:13,260
your command very to setup create yeah

00:35:10,170 --> 00:35:18,480
so if you can see that we have the

00:35:13,260 --> 00:35:22,080
offset and ash parameters and we need a

00:35:18,480 --> 00:35:27,150
way to have it available in the kernel

00:35:22,080 --> 00:35:30,410
so in fact we use Botox and for that we

00:35:27,150 --> 00:35:33,810
created a you boot environment script

00:35:30,410 --> 00:35:37,260
but this new component component can be

00:35:33,810 --> 00:35:40,620
attacked so to not again break the chain

00:35:37,260 --> 00:35:42,870
of trust we added in the fit image so in

00:35:40,620 --> 00:35:48,570
the Fatimid we have the boot environment

00:35:42,870 --> 00:35:51,140
script with the ash with with which has

00:35:48,570 --> 00:35:54,060
the signature of the ash of the binary

00:35:51,140 --> 00:35:58,320
then you boot check the signature of

00:35:54,060 --> 00:36:02,220
this new boot on human script if the

00:35:58,320 --> 00:36:05,880
signature is matching then you can

00:36:02,220 --> 00:36:11,340
source B script and in the script we

00:36:05,880 --> 00:36:14,610
have some variables to to retrieve the

00:36:11,340 --> 00:36:17,430
offset and ash and also of course it set

00:36:14,610 --> 00:36:22,770
the boot ax thanks to that we can

00:36:17,430 --> 00:36:26,340
achieve it in the corner so it's the

00:36:22,770 --> 00:36:28,910
final mechanism so as I said before we

00:36:26,340 --> 00:36:32,370
have you boot it check the signature of

00:36:28,910 --> 00:36:35,120
the you boot or even script if it's not

00:36:32,370 --> 00:36:37,950
the correct one it will fail to sauce it

00:36:35,120 --> 00:36:38,880
if it's the correct no one it will

00:36:37,950 --> 00:36:41,730
source the script

00:36:38,880 --> 00:36:46,170
thanks to that in the boot arts we will

00:36:41,730 --> 00:36:49,530
add offset and ash then we have our

00:36:46,170 --> 00:36:52,230
kernel with the mvet enabled are in it 1

00:36:49,530 --> 00:36:55,170
FS with the init script that will use

00:36:52,230 --> 00:36:58,910
the verity setup command to do the

00:36:55,170 --> 00:37:01,530
verification on the ubi block device of

00:36:58,910 --> 00:37:04,560
course as we have seen before the UT

00:37:01,530 --> 00:37:06,770
setup command needs the ash and so upset

00:37:04,560 --> 00:37:10,550
so thanks to the boot abs

00:37:06,770 --> 00:37:13,160
can retrieve it and if the verification

00:37:10,550 --> 00:37:16,570
is successful then you have a device

00:37:13,160 --> 00:37:20,060
mapper and you can do

00:37:16,570 --> 00:37:22,190
Switchfoot so in our use case we use

00:37:20,060 --> 00:37:25,370
switch routes instead of mount because

00:37:22,190 --> 00:37:28,120
we want it to have to switch the root

00:37:25,370 --> 00:37:31,730
filesystem from the image from FS to the

00:37:28,120 --> 00:37:34,460
verified surface otherwise our system

00:37:31,730 --> 00:37:40,060
will always be on the init 1 FS and we

00:37:34,460 --> 00:37:44,360
don't want that and to complete the

00:37:40,060 --> 00:37:46,700
shine of twist so if as we did a new

00:37:44,360 --> 00:37:49,160
component so you would have a man script

00:37:46,700 --> 00:37:55,220
for example we add it in the feed image

00:37:49,160 --> 00:37:59,060
to not work the chain of truth thanks

00:37:55,220 --> 00:38:03,640
Billy so now we have actually well

00:37:59,060 --> 00:38:08,450
completed our chain of trust so

00:38:03,640 --> 00:38:13,340
basically now to summarize what has been

00:38:08,450 --> 00:38:16,280
done yet until now so into the in the

00:38:13,340 --> 00:38:19,670
rom code you have up to four hash of

00:38:16,280 --> 00:38:21,380
public keys which are used to verify the

00:38:19,670 --> 00:38:23,870
public key which is embedded in the

00:38:21,380 --> 00:38:26,570
binary of the bootloader

00:38:23,870 --> 00:38:28,820
then when it's verified to public key

00:38:26,570 --> 00:38:29,990
then you can use it to verify actually

00:38:28,820 --> 00:38:32,060
the signature of the bootloader

00:38:29,990 --> 00:38:35,000
once that's done you have another

00:38:32,060 --> 00:38:36,950
publicly in the u-boot binary which is

00:38:35,000 --> 00:38:38,750
used to verify the signature of the

00:38:36,950 --> 00:38:40,040
kernel and the little B well basically

00:38:38,750 --> 00:38:42,440
the fitting with the whole foot image

00:38:40,040 --> 00:38:45,230
that you would script and then present

00:38:42,440 --> 00:38:47,240
it just the slides before and once

00:38:45,230 --> 00:38:49,340
that's done you have the digest within

00:38:47,240 --> 00:38:53,210
the fit image which is used to verify

00:38:49,340 --> 00:38:56,810
and would allocate the root of s so yeah

00:38:53,210 --> 00:39:00,020
but it will not stun but now we really

00:38:56,810 --> 00:39:03,800
want some kind of oh it's a distribution

00:39:00,020 --> 00:39:06,200
as a root of s and we don't want to well

00:39:03,800 --> 00:39:08,990
do it manually we can use build roads

00:39:06,200 --> 00:39:11,540
Yocto whatever build system you want but

00:39:08,990 --> 00:39:14,450
in our case it was Yocto but Yocto has a

00:39:11,540 --> 00:39:19,310
really specific way to handle to create

00:39:14,450 --> 00:39:20,539
bit image fit images and currently it's

00:39:19,310 --> 00:39:23,239
the kernel recipe

00:39:20,539 --> 00:39:27,469
actually in a rate there colonel 50 mhm

00:39:23,239 --> 00:39:31,219
class and that means that well it's done

00:39:27,469 --> 00:39:33,769
after the root of s bitter sorry before

00:39:31,219 --> 00:39:36,049
the root of has been created and I think

00:39:33,769 --> 00:39:39,019
the point is that actually people want

00:39:36,049 --> 00:39:43,009
to have fit image the kernel or ever

00:39:39,019 --> 00:39:46,309
within the /boot of the root of s but

00:39:43,009 --> 00:39:49,660
our script needs the root of s to be

00:39:46,309 --> 00:39:51,979
actually compiled built so that we can

00:39:49,660 --> 00:39:57,499
compute the hash and put it in the

00:39:51,979 --> 00:40:00,229
u-boot script but well we wanted in the

00:39:57,499 --> 00:40:03,380
fit image which is created before the

00:40:00,229 --> 00:40:05,089
root of s so we didn't so you end up

00:40:03,380 --> 00:40:08,449
with a dependency loop in Yocto and

00:40:05,089 --> 00:40:10,489
that's really hard to debug so well we

00:40:08,449 --> 00:40:13,219
throw away the kernel fisherman's class

00:40:10,489 --> 00:40:15,529
and wrote a new image and class recipes

00:40:13,219 --> 00:40:19,579
to work around this issue it's really I

00:40:15,529 --> 00:40:22,910
would say the level of draft or proof of

00:40:19,579 --> 00:40:29,569
concept but that works so how was it for

00:40:22,910 --> 00:40:32,869
us so well it was very specific example

00:40:29,569 --> 00:40:36,169
we present it today to have only read

00:40:32,869 --> 00:40:39,319
read-only file system but well you

00:40:36,169 --> 00:40:42,829
definitely may want to have some rich

00:40:39,319 --> 00:40:46,969
write file system besides your read-only

00:40:42,829 --> 00:40:51,439
file system so if it stores not critical

00:40:46,969 --> 00:40:53,749
data well just mounted just alongside

00:40:51,439 --> 00:40:55,939
your read-only file system that's fine

00:40:53,749 --> 00:40:58,459
you can so large use data

00:40:55,939 --> 00:41:01,640
well you don't care well it's if it's

00:40:58,459 --> 00:41:04,099
critical well we haven't really looked

00:41:01,640 --> 00:41:07,219
at it but a hint would be to look at

00:41:04,099 --> 00:41:10,099
I am a evm we have provided a bit of

00:41:07,219 --> 00:41:16,009
what rulings to look at it I don't know

00:41:10,099 --> 00:41:20,479
how it works just have a look at it so -

00:41:16,009 --> 00:41:21,349
well end this talk remember I told you

00:41:20,479 --> 00:41:24,140
to trust no one

00:41:21,349 --> 00:41:27,829
well you cannot even trust the the

00:41:24,140 --> 00:41:29,839
vendor of usoc so an XP had publicly

00:41:27,829 --> 00:41:32,089
disclosed about a year ago that they had

00:41:29,839 --> 00:41:37,159
secure boot vulnerabilities in our in

00:41:32,089 --> 00:41:41,239
their HIV verification code for imx6

00:41:37,159 --> 00:41:43,009
and your the funny SOC is but I think

00:41:41,239 --> 00:41:45,019
right now it should be fixed or you

00:41:43,009 --> 00:41:49,099
should ask them if you want to base your

00:41:45,019 --> 00:41:53,929
product on it and I attended well

00:41:49,099 --> 00:41:56,109
yesterday a good talk on introduction to

00:41:53,929 --> 00:41:59,359
reverse engineering by Michael Anderson

00:41:56,109 --> 00:42:01,999
and it was really interesting because

00:41:59,359 --> 00:42:04,969
well nothing is a hundred percent secure

00:42:01,999 --> 00:42:09,199
so what do we want to protect yourself

00:42:04,969 --> 00:42:09,650
from so well indeed with this look at

00:42:09,199 --> 00:42:14,179
him

00:42:09,650 --> 00:42:16,659
Tim sorry his talk to see what can be

00:42:14,179 --> 00:42:19,849
done to actually break your thing

00:42:16,659 --> 00:42:21,919
so I was it thank you for your attention

00:42:19,849 --> 00:42:25,659
if you have any question I'll be in the

00:42:21,919 --> 00:42:25,659
audience to pursue the microphone

00:42:25,750 --> 00:42:29,260
[Applause]

00:42:36,080 --> 00:42:40,890
hello

00:42:38,910 --> 00:42:46,500
hello okay how long did it take your

00:42:40,890 --> 00:42:49,380
team to implement all this so actually

00:42:46,500 --> 00:42:53,279
from the beginning to actually look at

00:42:49,380 --> 00:42:54,990
all the software everything I would say

00:42:53,279 --> 00:43:00,019
for both of us

00:42:54,990 --> 00:43:10,109
- like six-month but not full-time so

00:43:00,019 --> 00:43:11,609
I'd say mark days definitely um two

00:43:10,109 --> 00:43:14,160
questions one of oh I saw that you're

00:43:11,609 --> 00:43:17,490
using sha-1 you probably shouldn't use

00:43:14,160 --> 00:43:20,400
that as a hash algorithm anymore just is

00:43:17,490 --> 00:43:22,380
it totally broken number two where's

00:43:20,400 --> 00:43:25,319
your code that you actually talked about

00:43:22,380 --> 00:43:26,519
that works for doing the switch root

00:43:25,319 --> 00:43:35,640
thing so you don't get a dependency

00:43:26,519 --> 00:43:37,109
problem well it's a bit different the

00:43:35,640 --> 00:43:40,049
problem with the dependence loop is

00:43:37,109 --> 00:43:42,480
within your toe it does not have

00:43:40,049 --> 00:43:45,420
something to do with the final root of s

00:43:42,480 --> 00:43:46,019
so it's only when you actually build the

00:43:45,420 --> 00:43:50,720
root efest

00:43:46,019 --> 00:43:53,819
there is the problem well it's a new

00:43:50,720 --> 00:43:57,630
well recipe so that's how you have to

00:43:53,819 --> 00:44:01,769
work so the question is is the recipe in

00:43:57,630 --> 00:44:07,680
your toe yet no it's well in our Yocto

00:44:01,769 --> 00:44:10,220
yeah no but well definitely would want

00:44:07,680 --> 00:44:10,220
to work on it

00:44:14,339 --> 00:44:20,039
so I have two questions - firstly how

00:44:17,999 --> 00:44:23,849
many boards do you actually break doing

00:44:20,039 --> 00:44:29,039
this and secondly is it emulator bull

00:44:23,849 --> 00:44:31,680
and sang like qmu so a good question the

00:44:29,039 --> 00:44:32,759
first one have how many boards are we

00:44:31,680 --> 00:44:37,259
broken yet

00:44:32,759 --> 00:44:40,799
so none yeah there are a lot of

00:44:37,259 --> 00:44:43,170
tutorials on the internet so luckily we

00:44:40,799 --> 00:44:47,130
you know have to break any boards so

00:44:43,170 --> 00:44:54,150
well we're happy with this the next

00:44:47,130 --> 00:44:58,130
question was QM use support I haven't I

00:44:54,150 --> 00:44:58,130
yeah I don't know sorry

00:45:04,439 --> 00:45:21,299
you mentioned performance impact so I

00:45:18,709 --> 00:45:24,929
think there's not really a point

00:45:21,299 --> 00:45:26,819
measuring it because if you need a

00:45:24,929 --> 00:45:32,099
secure device

00:45:26,819 --> 00:45:36,089
well the latency you don't carry on the

00:45:32,099 --> 00:45:38,209
root of s part they pretend that the IO

00:45:36,089 --> 00:45:44,239
takes so much time compared to the hash

00:45:38,209 --> 00:45:44,239
computation that well you can ignore it

00:45:46,579 --> 00:45:54,209
any verification of your root FS and

00:45:51,179 --> 00:46:01,799
kernel and not you boot so for example

00:45:54,209 --> 00:46:04,920
can you boot read this blog device so

00:46:01,799 --> 00:46:09,539
the question is word verification of the

00:46:04,920 --> 00:46:13,079
root of s is why not in your boot there

00:46:09,539 --> 00:46:19,979
is no support for FS first and second is

00:46:13,079 --> 00:46:23,640
that all oh how was it it's on two

00:46:19,979 --> 00:46:25,769
different mediums for media for our

00:46:23,640 --> 00:46:28,030
clients so the first one is used to

00:46:25,769 --> 00:46:32,850
store the kernel etc

00:46:28,030 --> 00:46:32,850
and the root of us is on another video

00:46:41,130 --> 00:46:48,490
so there is a really interesting remarks

00:46:45,100 --> 00:46:53,260
and I forgot about it it's actually done

00:46:48,490 --> 00:46:54,880
only on the read access of your data so

00:46:53,260 --> 00:46:58,180
you cannot actually use the good order

00:46:54,880 --> 00:47:00,490
to verify your writ of s because it's

00:46:58,180 --> 00:47:03,480
done only when you accessed data which

00:47:00,490 --> 00:47:03,480
is done only but it colonel

00:47:05,580 --> 00:47:10,720
you have four public key is stored in

00:47:08,350 --> 00:47:15,250
your in your boot image how do you

00:47:10,720 --> 00:47:16,540
revoke one if one's bad the same way you

00:47:15,250 --> 00:47:20,380
actually flashed

00:47:16,540 --> 00:47:22,930
public key so you blow a fuse and this

00:47:20,380 --> 00:47:30,220
fuse just say what this one is revoked

00:47:22,930 --> 00:47:32,830
that's it Oh from from reboot so with a

00:47:30,220 --> 00:47:37,990
new boot with your update scripts or

00:47:32,830 --> 00:47:40,750
whatever you asked you to blow the fuse

00:47:37,990 --> 00:47:48,540
but yeah if it's already too late and

00:47:40,750 --> 00:47:48,540
you screwed anyone

00:47:55,510 --> 00:48:01,359
I actually have an observation on an

00:47:57,760 --> 00:48:02,800
earlier common one-time verification of

00:48:01,359 --> 00:48:04,869
the squash if s is not good enough

00:48:02,800 --> 00:48:06,730
whilst the squash surface itself is

00:48:04,869 --> 00:48:09,310
read-only it does not cache all your

00:48:06,730 --> 00:48:10,780
data so if you're sneaky you can go in

00:48:09,310 --> 00:48:13,420
and rewrite the data that's in the

00:48:10,780 --> 00:48:15,310
squash FS we found this because one of

00:48:13,420 --> 00:48:17,020
our clients accidentally ran their

00:48:15,310 --> 00:48:19,330
upgrade system against their currently

00:48:17,020 --> 00:48:22,390
running squash surface this makes the

00:48:19,330 --> 00:48:24,750
kernel very unhappy and crashes the

00:48:22,390 --> 00:48:24,750
system

00:48:32,120 --> 00:48:39,000
when will the URL work I tried it do it

00:48:35,910 --> 00:48:40,160
Hearns file not found the URL on up

00:48:39,000 --> 00:48:43,290
there I tried it

00:48:40,160 --> 00:48:49,230
yeah it's not up yet well it's on the

00:48:43,290 --> 00:48:52,940
scared aargh website so it's gonna be

00:48:49,230 --> 00:48:56,690
available hopefully next week tops okay

00:48:52,940 --> 00:48:56,690
any other question

00:48:56,780 --> 00:49:05,649
well thank you but Appetit

00:49:00,010 --> 00:49:05,649

YouTube URL: https://www.youtube.com/watch?v=jtLQ8SzfrDU


