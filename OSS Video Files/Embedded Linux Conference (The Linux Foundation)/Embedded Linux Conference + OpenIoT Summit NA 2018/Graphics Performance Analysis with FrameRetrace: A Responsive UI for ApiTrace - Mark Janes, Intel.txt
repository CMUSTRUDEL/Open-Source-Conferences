Title: Graphics Performance Analysis with FrameRetrace: A Responsive UI for ApiTrace - Mark Janes, Intel
Publication date: 2018-03-14
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	Graphics Performance Analysis with FrameRetrace: A Responsive UI for ApiTrace - Mark Janes, Intel

 FrameRetrace is the first fully open-source graphics performance analysis tool for OpenGL on Linux platforms. This talk will describe the current state of FrameRetrace, and why it is a compelling tool for OpenGL application and driver developers. A demo of FrameRetrace will illustrate and fix a performance problem in the mesa driver.

The following live experiments allow a developer to alter the frame and immediately see the impact on both performance and rendering:

shader editing and recompilation
changes to GL state settings
changes to uniforms values

Because FrameRetrace is built on top of ApiTrace, it can analyze most OpenGL applications. It can also provide parallel analysis of the same frame on Windows and Linux platforms, to highlight driver differences.

Source and documentation available at: https://github.com/janesma/apitrace/wiki/frameretrace-branch

About Mark Janes
Since 2011, Mark has been working on graphics performance analysis tools, including FrameRetrace, which enables rapid performance and debugging on top of ApiTrace. He also implemented and maintains the i965 Mesa Continous Integration system, dramatically improving the velocity and quality of Intel's Mesa team. Before joining Mesa, Mark worked on Intel's widely used Graphics FrameAnalyzer for DX (https://software.intel.com/en-us/gpa/graphics-frame-analyzer). The FrameRetrace use cases are based on FrameAnalyzer.

Before joining Intel Mark implemented the industry-leading real-time distributed audio platform for commercial installations (http://biamp.com/products/tesira).
Captions: 
	00:00:00,000 --> 00:00:06,120
thanks for coming to my talk I it's a

00:00:02,939 --> 00:00:07,410
really nice opportunity to come to the

00:00:06,120 --> 00:00:11,580
embedded Linux conference this is my

00:00:07,410 --> 00:00:14,000
second second time talking here I came

00:00:11,580 --> 00:00:17,460
to the embedded Linux conference for

00:00:14,000 --> 00:00:19,080
half a dozen years in the early 2000s

00:00:17,460 --> 00:00:22,500
when I was building embedded Linux

00:00:19,080 --> 00:00:27,990
products and I had to say it was such a

00:00:22,500 --> 00:00:33,059
helpful conference and so I'm you know I

00:00:27,990 --> 00:00:34,829
feel like every year we traveled around

00:00:33,059 --> 00:00:37,230
the Sun we come back to the same spot

00:00:34,829 --> 00:00:40,710
and timbered is still here welcomes us

00:00:37,230 --> 00:00:42,239
back and and doing the embedded Linux

00:00:40,710 --> 00:00:45,200
conference has been going for a long

00:00:42,239 --> 00:00:48,120
time and I got a lot of good advice here

00:00:45,200 --> 00:00:51,000
yesterday a colleague that I worked with

00:00:48,120 --> 00:00:54,840
on a distributed real-time embedded

00:00:51,000 --> 00:00:57,390
audio system reminded me that we

00:00:54,840 --> 00:00:59,789
actually did audio system in this room

00:00:57,390 --> 00:01:04,760
and there's a little controller back

00:00:59,789 --> 00:01:08,010
there that we made so like all embedded

00:01:04,760 --> 00:01:10,020
products it is unlocked or has the

00:01:08,010 --> 00:01:11,220
default password so if you want to go

00:01:10,020 --> 00:01:15,740
back and rickroll me you could probably

00:01:11,220 --> 00:01:20,009
plug in and and play some music for us

00:01:15,740 --> 00:01:23,880
but definitely you get a lot of great

00:01:20,009 --> 00:01:26,580
advice here and it's great to see Lucas

00:01:23,880 --> 00:01:29,040
reset here he last year I talked a

00:01:26,580 --> 00:01:31,229
little bit about why and how you would

00:01:29,040 --> 00:01:33,119
want to use open-source graphics drivers

00:01:31,229 --> 00:01:35,880
in embedded products and we talked with

00:01:33,119 --> 00:01:38,820
him about if you don't need compositing

00:01:35,880 --> 00:01:42,390
bring up just just bring up a

00:01:38,820 --> 00:01:45,509
full-screen rendering context and with

00:01:42,390 --> 00:01:47,790
it like in KMS and he works with the

00:01:45,509 --> 00:01:49,200
kodi linux project and went and did that

00:01:47,790 --> 00:01:51,630
and it simplified a lot of things for

00:01:49,200 --> 00:01:53,040
him and I saw him at FOSDEM where he

00:01:51,630 --> 00:01:56,420
presented on on what a great

00:01:53,040 --> 00:01:59,310
simplification it was for their

00:01:56,420 --> 00:02:01,469
multi-platform you know media solution

00:01:59,310 --> 00:02:02,750
which is used by just tons and tons of

00:02:01,469 --> 00:02:04,700
users so

00:02:02,750 --> 00:02:09,530
it's it's great I mean the the advice

00:02:04,700 --> 00:02:12,260
forget you're here is real so hopefully

00:02:09,530 --> 00:02:14,030
I can give you guys some some good

00:02:12,260 --> 00:02:17,170
advices so like I said I've been working

00:02:14,030 --> 00:02:19,580
on Linux for well over ten years and

00:02:17,170 --> 00:02:23,000
just on graphics for the past five years

00:02:19,580 --> 00:02:25,400
or so I worked on the graphics

00:02:23,000 --> 00:02:28,430
performance analyzers team starting

00:02:25,400 --> 00:02:31,700
around 2011 to help them address and

00:02:28,430 --> 00:02:35,750
target Android and so my former

00:02:31,700 --> 00:02:38,180
technical lead is here as well and I'm

00:02:35,750 --> 00:02:40,520
terrified because of all the people he

00:02:38,180 --> 00:02:43,820
can totally destroy my talk with some

00:02:40,520 --> 00:02:46,130
tough questions and to give him credit

00:02:43,820 --> 00:02:48,410
in fact everything I've done has really

00:02:46,130 --> 00:02:53,750
been along the lines of the product that

00:02:48,410 --> 00:02:56,000
he envisioned and created and so his his

00:02:53,750 --> 00:02:58,910
work I think really has enabled Linux

00:02:56,000 --> 00:03:02,150
Intel graphics in a way that most people

00:02:58,910 --> 00:03:04,480
can't say they helped any any product so

00:03:02,150 --> 00:03:08,930
he's really a critical person and

00:03:04,480 --> 00:03:11,930
hopefully I haven't haven't done wrong

00:03:08,930 --> 00:03:14,810
but what we'll see what he thinks of my

00:03:11,930 --> 00:03:18,650
demo so I've been working on Mesa for

00:03:14,810 --> 00:03:23,300
several years Mesa is a very successful

00:03:18,650 --> 00:03:25,550
open-source driver for 3d graphics used

00:03:23,300 --> 00:03:29,120
by millions and millions of people I

00:03:25,550 --> 00:03:30,950
mean ten percent of the market in China

00:03:29,120 --> 00:03:35,239
pre-shift with with Mesa as their

00:03:30,950 --> 00:03:37,430
graphics solution so it's it's big

00:03:35,239 --> 00:03:39,040
numbers we get a lot of users and I've

00:03:37,430 --> 00:03:42,980
been working on this performance tool

00:03:39,040 --> 00:03:45,080
but more on automating the developer

00:03:42,980 --> 00:03:48,410
process for the for the team which has

00:03:45,080 --> 00:03:53,030
been very helpful as well for them okay

00:03:48,410 --> 00:03:56,390
so just before we start my tool is

00:03:53,030 --> 00:03:58,510
really focused on sort of deeply

00:03:56,390 --> 00:04:00,970
investigating performance problems and a

00:03:58,510 --> 00:04:03,380
frame that you're rendering with the GPU

00:04:00,970 --> 00:04:05,510
you really don't want to go and

00:04:03,380 --> 00:04:06,800
investigate at that level until you're

00:04:05,510 --> 00:04:09,130
confident that that's where your

00:04:06,800 --> 00:04:13,240
bottleneck is so

00:04:09,130 --> 00:04:16,030
all of the graphics rendering happens

00:04:13,240 --> 00:04:18,880
with two sort of asynchronous processors

00:04:16,030 --> 00:04:21,040
where the CPU will nq-- a whole bunch of

00:04:18,880 --> 00:04:24,640
work for the GPU to then consume and so

00:04:21,040 --> 00:04:26,680
if your CPU cannot produce the work for

00:04:24,640 --> 00:04:28,990
the GPU fast enough and your GPU will be

00:04:26,680 --> 00:04:31,120
idle and there's no sense in going and

00:04:28,990 --> 00:04:33,340
looking at your GPU performance you need

00:04:31,120 --> 00:04:38,020
to go and use the standard tools on the

00:04:33,340 --> 00:04:40,030
CPU side to fix your CPU bottlenecks but

00:04:38,020 --> 00:04:41,380
then if you are bottlenecked on the GPU

00:04:40,030 --> 00:04:44,410
that's that's when you want to go use a

00:04:41,380 --> 00:04:46,480
tool like frame retrace so you can use

00:04:44,410 --> 00:04:48,670
top to see you know what your what your

00:04:46,480 --> 00:04:52,360
CPU utilization is there's a new tool

00:04:48,670 --> 00:04:53,890
called GPU top that OTC has been making

00:04:52,360 --> 00:04:56,230
that works on on Linux and there's

00:04:53,890 --> 00:04:58,090
similar tools for every single graphics

00:04:56,230 --> 00:05:00,640
card out there that'll tell you how busy

00:04:58,090 --> 00:05:04,750
is the GPU Apple is a tool that'll tell

00:05:00,640 --> 00:05:06,760
you where your power is going so

00:05:04,750 --> 00:05:07,990
typically for with embedded processors

00:05:06,760 --> 00:05:10,090
you might be you might have a thermal

00:05:07,990 --> 00:05:12,580
budget and the BIOS have turned down

00:05:10,090 --> 00:05:14,380
your clocks if you use too much power so

00:05:12,580 --> 00:05:16,570
you need to look at Rapala you might

00:05:14,380 --> 00:05:17,890
have a hundred percent GPU utilization

00:05:16,570 --> 00:05:20,290
but in fact your clocks are running at

00:05:17,890 --> 00:05:25,390
half speed because your chip can't

00:05:20,290 --> 00:05:27,310
support that that amount of load so yeah

00:05:25,390 --> 00:05:29,350
so you go look in the GPU side if you

00:05:27,310 --> 00:05:32,650
have a hundred % GP utilization and your

00:05:29,350 --> 00:05:34,210
CPU utilization is low you could

00:05:32,650 --> 00:05:36,280
probably do some simple things like just

00:05:34,210 --> 00:05:38,860
set makes a debug equals perf and it'll

00:05:36,280 --> 00:05:41,020
output a whole ton of advice for you

00:05:38,860 --> 00:05:46,120
when you've made sort of bad rendering

00:05:41,020 --> 00:05:48,280
decisions yeah so we all know how to

00:05:46,120 --> 00:05:51,010
optimize performance problems on the CPU

00:05:48,280 --> 00:05:53,260
I think the tools here are fantastic

00:05:51,010 --> 00:05:55,600
they're one of the reasons why embedded

00:05:53,260 --> 00:05:57,490
Linux is successful and Linux as a whole

00:05:55,600 --> 00:06:00,910
because it's so wonderful to be a

00:05:57,490 --> 00:06:02,950
developer on the Linux platform but on

00:06:00,910 --> 00:06:04,170
the GPU side you have a completely

00:06:02,950 --> 00:06:08,670
different story

00:06:04,170 --> 00:06:11,190
typically you have a vendor specific

00:06:08,670 --> 00:06:14,130
GPU analysis tools that they've made to

00:06:11,190 --> 00:06:16,050
help their developers target their

00:06:14,130 --> 00:06:21,320
platform and they're not interested at

00:06:16,050 --> 00:06:23,130
all in enabling another vendor for

00:06:21,320 --> 00:06:24,630
improving performance and in fact

00:06:23,130 --> 00:06:26,400
they'll they'll often try to disrupt

00:06:24,630 --> 00:06:28,920
each other like you might see one a

00:06:26,400 --> 00:06:32,640
large GPU vendor provide a free tool

00:06:28,920 --> 00:06:34,560
that helps you you know generate a scene

00:06:32,640 --> 00:06:36,720
and it does all of this or

00:06:34,560 --> 00:06:38,130
metaprogramming for you but in fact what

00:06:36,720 --> 00:06:39,690
it's doing is injecting hundreds of

00:06:38,130 --> 00:06:41,490
millions of vertices into what's a flat

00:06:39,690 --> 00:06:43,230
wall because they know that their

00:06:41,490 --> 00:06:46,950
competition can't deal with a whole lot

00:06:43,230 --> 00:06:49,050
of vertices right so when you go and you

00:06:46,950 --> 00:06:51,000
want to improve performance for your GPU

00:06:49,050 --> 00:06:53,550
workload you're kind of dealing with

00:06:51,000 --> 00:06:56,930
tools that are kind of more in the

00:06:53,550 --> 00:07:00,320
interest of the vendors sometimes so

00:06:56,930 --> 00:07:03,390
QAPI trace is a open source

00:07:00,320 --> 00:07:05,550
multi-platform tool that you can use to

00:07:03,390 --> 00:07:07,500
go and invest in investigate and debug

00:07:05,550 --> 00:07:09,690
frame so that's an exception another

00:07:07,500 --> 00:07:11,030
great exception is render dock valve has

00:07:09,690 --> 00:07:14,280
really been investing heavily in

00:07:11,030 --> 00:07:15,420
supporting render dock and really

00:07:14,280 --> 00:07:18,750
because of their investment I think a

00:07:15,420 --> 00:07:20,850
whole lot of it GPU vendors are forced

00:07:18,750 --> 00:07:23,340
to go and and and participate in that in

00:07:20,850 --> 00:07:24,930
that tool as well they all do the same

00:07:23,340 --> 00:07:27,390
thing though if they're performing

00:07:24,930 --> 00:07:29,910
performance analyzers they'll leverage

00:07:27,390 --> 00:07:32,850
the hardware counters on the GPU to help

00:07:29,910 --> 00:07:34,110
you understand the cost of the

00:07:32,850 --> 00:07:36,150
asynchronous work that you're in

00:07:34,110 --> 00:07:38,220
queueing for the GPU without that you I

00:07:36,150 --> 00:07:39,810
really have no hope of understanding why

00:07:38,220 --> 00:07:44,250
your your workload is slow because all

00:07:39,810 --> 00:07:47,220
you get is frame rate they will often

00:07:44,250 --> 00:07:48,990
have other features like give you some

00:07:47,220 --> 00:07:50,430
live experimentation so you can twiddle

00:07:48,990 --> 00:07:52,710
around with a workload and try to figure

00:07:50,430 --> 00:07:55,170
out ok well how do i how do I fix this

00:07:52,710 --> 00:07:56,970
performance bottleneck but generally

00:07:55,170 --> 00:08:01,250
they'll let you dive right down into the

00:07:56,970 --> 00:08:03,720
deep details of a graphics workload so

00:08:01,250 --> 00:08:05,870
the real problems with most of the tools

00:08:03,720 --> 00:08:08,040
is like I said they're Hardware specific

00:08:05,870 --> 00:08:12,600
really most of them are coming from a

00:08:08,040 --> 00:08:13,200
Windows background because you know to

00:08:12,600 --> 00:08:15,840
be frank

00:08:13,200 --> 00:08:17,520
that's where 3d is it's all of these

00:08:15,840 --> 00:08:19,530
high-end triple-a titles are running on

00:08:17,520 --> 00:08:20,430
Windows that's what the vendors want to

00:08:19,530 --> 00:08:24,110
support

00:08:20,430 --> 00:08:28,469
and Linux is really an afterthought so

00:08:24,110 --> 00:08:31,619
maybe you'll get a silicon vendor to go

00:08:28,469 --> 00:08:32,880
and port part of their tool to Linux but

00:08:31,619 --> 00:08:34,860
really they might pour just the

00:08:32,880 --> 00:08:37,919
collection side and so you'll still need

00:08:34,860 --> 00:08:41,219
a Windows host to run forms-based UI to

00:08:37,919 --> 00:08:44,490
go and and instrument your your embedded

00:08:41,219 --> 00:08:46,829
target but another thing that can happen

00:08:44,490 --> 00:08:50,269
with them is I mean they're in index

00:08:46,829 --> 00:08:53,639
I think the tracing and retracing is

00:08:50,269 --> 00:08:56,490
perhaps easier when you get into OpenGL

00:08:53,639 --> 00:08:59,010
especially above OpenGL ES there's a ton

00:08:56,490 --> 00:09:01,380
of extensions that can be optionally

00:08:59,010 --> 00:09:02,730
supported and so if you have the task of

00:09:01,380 --> 00:09:04,500
understanding the state of the GPU and

00:09:02,730 --> 00:09:07,139
you want to retrace it you might be

00:09:04,500 --> 00:09:09,240
using extensions that are not I mean it

00:09:07,139 --> 00:09:10,829
works on NVIDIA for example and you can

00:09:09,240 --> 00:09:12,660
get the tool working on a video but if

00:09:10,829 --> 00:09:14,790
you go to AMD then the tracing breaks

00:09:12,660 --> 00:09:16,800
horribly because those extensions are

00:09:14,790 --> 00:09:19,050
not available for querying the state and

00:09:16,800 --> 00:09:22,620
that happened to a tool called Vogel

00:09:19,050 --> 00:09:24,300
that you know valve I think was also

00:09:22,620 --> 00:09:27,300
working on and and it struggled because

00:09:24,300 --> 00:09:30,899
of the tracing support the other thing

00:09:27,300 --> 00:09:31,889
is that frankly there's just low numbers

00:09:30,899 --> 00:09:33,870
of users

00:09:31,889 --> 00:09:36,839
I think graphics programming is a niche

00:09:33,870 --> 00:09:38,639
within computer science but Linux

00:09:36,839 --> 00:09:41,190
graphics programming is a micro niche

00:09:38,639 --> 00:09:43,319
you know you guys if you're programming

00:09:41,190 --> 00:09:48,720
graphics on these platforms you are the

00:09:43,319 --> 00:09:51,240
exotic few who are so intriguing my six

00:09:48,720 --> 00:09:53,880
users you know actually I don't know I

00:09:51,240 --> 00:09:56,100
mean I think it's gonna be growing the

00:09:53,880 --> 00:09:58,800
fact that the Google Playstore is coming

00:09:56,100 --> 00:10:01,740
to Linux platforms on Chrome OS that

00:09:58,800 --> 00:10:03,810
just means you have hundreds of

00:10:01,740 --> 00:10:06,120
thousands of 3d titles that are gonna be

00:10:03,810 --> 00:10:08,730
running on Linux you know for the first

00:10:06,120 --> 00:10:11,449
time there's a stable API avi where

00:10:08,730 --> 00:10:14,220
commercial vendors can go and write

00:10:11,449 --> 00:10:16,579
applications and charge for them and

00:10:14,220 --> 00:10:19,889
have them running on a Linux platform so

00:10:16,579 --> 00:10:21,240
another the reason why these tools

00:10:19,889 --> 00:10:23,160
haven't worked on Linux is because the

00:10:21,240 --> 00:10:25,980
counters haven't been there we really

00:10:23,160 --> 00:10:27,750
haven't been enabled until recently to

00:10:25,980 --> 00:10:29,110
expose this information for whatever

00:10:27,750 --> 00:10:31,740
reason and

00:10:29,110 --> 00:10:34,450
been true for other vendors as well but

00:10:31,740 --> 00:10:36,399
Radeon and is now exposing GPU

00:10:34,450 --> 00:10:38,920
performance counters and in Mesa and so

00:10:36,399 --> 00:10:40,050
is Intel so that's what enables this

00:10:38,920 --> 00:10:44,260
work

00:10:40,050 --> 00:10:46,600
so I have written a tool on calling

00:10:44,260 --> 00:10:50,459
frame or trace it's based on API trace

00:10:46,600 --> 00:10:54,459
which is perhaps the most widely used

00:10:50,459 --> 00:10:58,240
OpenGL debugging tool out there it has

00:10:54,459 --> 00:10:59,620
really high quality retracing and it's

00:10:58,240 --> 00:11:02,829
used by tons of vendors it was written

00:10:59,620 --> 00:11:06,610
by VMware they use it all the time to

00:11:02,829 --> 00:11:08,829
verify their DX to GL translation when

00:11:06,610 --> 00:11:13,300
they're running a Windows guest on a

00:11:08,829 --> 00:11:16,209
Linux host and for that reason it's it's

00:11:13,300 --> 00:11:18,670
a really healthy project typically like

00:11:16,209 --> 00:11:20,200
for example valve might find that they

00:11:18,670 --> 00:11:21,880
of the ancients does not trace and

00:11:20,200 --> 00:11:23,649
retrace properly and and because of that

00:11:21,880 --> 00:11:27,040
they cannot debug their own application

00:11:23,649 --> 00:11:28,390
so they'll enhance API trace or they're

00:11:27,040 --> 00:11:31,149
all enhance their own application to

00:11:28,390 --> 00:11:33,550
enable that API traces cross-platform

00:11:31,149 --> 00:11:36,640
like I said valve VMware is using it for

00:11:33,550 --> 00:11:37,959
Windows analysis and because it's

00:11:36,640 --> 00:11:40,890
cross-platform that means that my tool

00:11:37,959 --> 00:11:43,060
also is cross-platform and that's a huge

00:11:40,890 --> 00:11:47,709
benefit to driver developers

00:11:43,060 --> 00:11:49,870
particularly its Hardware agnostic

00:11:47,709 --> 00:11:53,829
it's was written for Intel because

00:11:49,870 --> 00:11:57,790
that's what that's where I work until is

00:11:53,829 --> 00:12:01,260
now shipping AMD GPUs on package in that

00:11:57,790 --> 00:12:04,420
and the cab you like GE processor and so

00:12:01,260 --> 00:12:05,560
AMD has kind of been enabling frame

00:12:04,420 --> 00:12:08,380
retrace to work on their hardware and

00:12:05,560 --> 00:12:12,040
that allows us to go and analyze that

00:12:08,380 --> 00:12:14,260
platform there are other platforms I you

00:12:12,040 --> 00:12:17,399
know I gave a similar talk at the X

00:12:14,260 --> 00:12:21,850
Developers Conference in the fall and

00:12:17,399 --> 00:12:24,190
other Mesa driver trees are adding

00:12:21,850 --> 00:12:26,980
support so that there you can instrument

00:12:24,190 --> 00:12:28,839
their driver in this tool as well it's

00:12:26,980 --> 00:12:31,060
already been used by the Mesa team

00:12:28,839 --> 00:12:31,809
pretty heavily to go and find gaps in

00:12:31,060 --> 00:12:34,369
our driver

00:12:31,809 --> 00:12:36,649
for reasons in the demo maybe I'll

00:12:34,369 --> 00:12:40,339
explain exactly why it's so easy to use

00:12:36,649 --> 00:12:45,859
this tool to find gaps in the driver so

00:12:40,339 --> 00:12:47,449
it's effective it's in use so here's a

00:12:45,859 --> 00:12:49,129
list of some of the features that we

00:12:47,449 --> 00:12:51,169
have in the tool I'm not going to go

00:12:49,129 --> 00:12:52,790
through them because really the demo

00:12:51,169 --> 00:12:54,980
will we'll go through them but if you

00:12:52,790 --> 00:12:59,329
know people are looking online they can

00:12:54,980 --> 00:13:05,239
see this in the notes all right so let's

00:12:59,329 --> 00:13:16,489
switch to a demo all right should have

00:13:05,239 --> 00:13:24,379
done this before alright so let's open a

00:13:16,489 --> 00:13:25,999
file and so this opens a file you can

00:13:24,379 --> 00:13:27,980
specify the host that you want to

00:13:25,999 --> 00:13:29,600
connect to if you're working on an

00:13:27,980 --> 00:13:31,160
embedded platform you typically don't

00:13:29,600 --> 00:13:33,679
want to render the graphics for the tool

00:13:31,160 --> 00:13:35,540
actually on on the localhost you'll want

00:13:33,679 --> 00:13:41,419
to connect to it this is a really crusty

00:13:35,540 --> 00:13:43,309
old benchmark which unfortunately people

00:13:41,419 --> 00:13:45,889
still pay attention to but because it's

00:13:43,309 --> 00:13:47,209
old it's been hacked in tons of ways and

00:13:45,889 --> 00:13:52,339
there's plenty of performance problems

00:13:47,209 --> 00:13:57,499
to look at so I will show you some of

00:13:52,339 --> 00:13:59,269
those ok so just a shout-out to my

00:13:57,499 --> 00:14:01,339
former tech lead who he will recognize

00:13:59,269 --> 00:14:02,600
this UI immediately because I totally

00:14:01,339 --> 00:14:07,339
stole it from his very successful

00:14:02,600 --> 00:14:09,949
product and I hope it's a namahage to

00:14:07,339 --> 00:14:11,269
him so here that here are some of the

00:14:09,949 --> 00:14:13,339
metrics that we support you can see

00:14:11,269 --> 00:14:16,999
there's just tons of metrics it's almost

00:14:13,339 --> 00:14:20,449
too many to look at typically you'll

00:14:16,999 --> 00:14:22,160
just want to filter down so if you want

00:14:20,449 --> 00:14:25,759
to know how much things cost you graph

00:14:22,160 --> 00:14:27,350
the number of clocks there and so you

00:14:25,759 --> 00:14:31,789
can see right away that this is the most

00:14:27,350 --> 00:14:34,309
expensive render so the render target

00:14:31,789 --> 00:14:37,870
will show you the render at each draw so

00:14:34,309 --> 00:14:40,450
if you select save

00:14:37,870 --> 00:14:43,330
some renders here and you highlight them

00:14:40,450 --> 00:14:46,060
it will tell you what those renders are

00:14:43,330 --> 00:14:48,040
coloring you might stop at the render to

00:14:46,060 --> 00:14:49,840
you know iterate through the frame and

00:14:48,040 --> 00:14:54,279
see how it's being composed with each

00:14:49,840 --> 00:14:55,930
draw or clear before render just to see

00:14:54,279 --> 00:14:58,240
the pixels that that specific render is

00:14:55,930 --> 00:15:00,510
touching right so this helps you figure

00:14:58,240 --> 00:15:05,980
out exactly what's going on in the frame

00:15:00,510 --> 00:15:07,930
just by looking around there's API calls

00:15:05,980 --> 00:15:09,480
I mean it was pretty standard stuff but

00:15:07,930 --> 00:15:14,230
like if you were looking for clear calls

00:15:09,480 --> 00:15:15,520
you might you know clear and so these

00:15:14,230 --> 00:15:19,980
are the these are the renders that are

00:15:15,520 --> 00:15:22,150
calling you know clear this this I think

00:15:19,980 --> 00:15:23,710
the UI could use some work it'd be nice

00:15:22,150 --> 00:15:24,970
to have different colors for the bars if

00:15:23,710 --> 00:15:30,550
they're clear so you can really see them

00:15:24,970 --> 00:15:32,680
easily some other nice features so for

00:15:30,550 --> 00:15:36,160
every render I capture the batch

00:15:32,680 --> 00:15:37,540
disassembly that's the actual binary

00:15:36,160 --> 00:15:40,779
instructions that are sent down to the

00:15:37,540 --> 00:15:42,220
GPU and I don't think this feature is

00:15:40,779 --> 00:15:44,589
really available in any other driver

00:15:42,220 --> 00:15:47,650
where you can instantly go and get a

00:15:44,589 --> 00:15:48,640
dump of all the information so for

00:15:47,650 --> 00:15:49,720
driver developers there's a lot of

00:15:48,640 --> 00:15:51,280
features that need to be added to this

00:15:49,720 --> 00:15:53,410
tool but for driver developers they can

00:15:51,280 --> 00:15:55,870
find anything they need to understand

00:15:53,410 --> 00:15:58,360
the details of a specific draw call

00:15:55,870 --> 00:16:03,430
whether it's using one texture format or

00:15:58,360 --> 00:16:05,290
another in the shader view we will

00:16:03,430 --> 00:16:07,330
capture the vertex and the fragment

00:16:05,290 --> 00:16:09,280
shader but we also display the

00:16:07,330 --> 00:16:12,160
intermediate representation and this

00:16:09,280 --> 00:16:17,650
static single assignment form and then

00:16:12,160 --> 00:16:19,450
the 78 or 78 16 binary compiled shader

00:16:17,650 --> 00:16:21,339
that sent down to the GPU so that can be

00:16:19,450 --> 00:16:22,450
helpful for driver developers or

00:16:21,339 --> 00:16:26,170
compiler developers who want to

00:16:22,450 --> 00:16:29,670
understand why they're why the shader

00:16:26,170 --> 00:16:29,670
has compiled in a certain way in is slow

00:16:30,819 --> 00:16:38,919
what else can I show you should see the

00:16:35,669 --> 00:16:42,160
the metrics so as I said there's tons of

00:16:38,919 --> 00:16:43,749
metrics and they have longer

00:16:42,160 --> 00:16:47,019
descriptions that you can look at if you

00:16:43,749 --> 00:16:48,699
don't really know what a des Stahl is

00:16:47,019 --> 00:16:51,429
you can see that its domain shaders

00:16:48,699 --> 00:16:53,979
that's not really something for the the

00:16:51,429 --> 00:16:55,239
t-rex demo but there's tons and tons of

00:16:53,979 --> 00:16:58,179
them and if you're looking at a specific

00:16:55,239 --> 00:17:00,069
render or set of renders it'll tell you

00:16:58,179 --> 00:17:03,750
what the cost is of that selection

00:17:00,069 --> 00:17:06,459
relative to the rest of the frame so

00:17:03,750 --> 00:17:08,949
this is a pretty helpful way for you to

00:17:06,459 --> 00:17:11,259
quickly narrow down what's expensive how

00:17:08,949 --> 00:17:16,179
expensive is it and then you can proceed

00:17:11,259 --> 00:17:18,639
to go and experiment so for example this

00:17:16,179 --> 00:17:21,610
expensive shader if you wanted to

00:17:18,639 --> 00:17:23,199
replace it with a simple shader let's

00:17:21,610 --> 00:17:25,929
look at the shader real quickly so the

00:17:23,199 --> 00:17:28,659
vertex shader is nothing because in fact

00:17:25,929 --> 00:17:31,259
you can tell it's just drawing two

00:17:28,659 --> 00:17:35,409
triangles to present a rec to the screen

00:17:31,259 --> 00:17:38,500
but the fragment shader is a little bit

00:17:35,409 --> 00:17:41,409
more complicated if you replace it with

00:17:38,500 --> 00:17:43,330
a simple shader the shader just turns to

00:17:41,409 --> 00:17:45,039
draw the pixel pink that's about as

00:17:43,330 --> 00:17:48,070
simple as you can get and the render

00:17:45,039 --> 00:17:51,009
target is now completely pink the

00:17:48,070 --> 00:17:51,580
metrics will show that the cost is much

00:17:51,009 --> 00:17:53,529
cheaper

00:17:51,580 --> 00:17:57,759
no that cheap though it's a lot of

00:17:53,529 --> 00:17:58,870
pixels so yeah so that's the way the

00:17:57,759 --> 00:18:02,230
experiment so you can disable the draw

00:17:58,870 --> 00:18:03,370
completely and you can see what the

00:18:02,230 --> 00:18:05,860
overall frame rate would be if you

00:18:03,370 --> 00:18:08,620
weren't doing that drawing all right so

00:18:05,860 --> 00:18:11,379
the reason I picked this is because this

00:18:08,620 --> 00:18:14,500
particular shader has an expensive

00:18:11,379 --> 00:18:16,330
motion blur effect and if you look at

00:18:14,500 --> 00:18:19,539
the render so here's the render target

00:18:16,330 --> 00:18:24,100
you look at the renders before that what

00:18:19,539 --> 00:18:26,409
you'll see is kind of a league reen

00:18:24,100 --> 00:18:28,059
screen and what that's doing it's it's

00:18:26,409 --> 00:18:30,519
kind of changing the pixel value based

00:18:28,059 --> 00:18:32,200
on how fast the objects moving and the

00:18:30,519 --> 00:18:34,059
render and then in the final shader

00:18:32,200 --> 00:18:36,009
it'll sample from those pixels and based

00:18:34,059 --> 00:18:39,250
on the value it will figure out how much

00:18:36,009 --> 00:18:40,570
it wants to kind of Swizzle the the

00:18:39,250 --> 00:18:41,419
texture state a little bit to make a

00:18:40,570 --> 00:18:45,139
blur effect

00:18:41,419 --> 00:18:47,299
so the problem with that is if you

00:18:45,139 --> 00:18:52,279
looked at that texture it was mostly

00:18:47,299 --> 00:18:55,909
zero mostly is not moving and what this

00:18:52,279 --> 00:18:58,549
shader does is get the right share what

00:18:55,909 --> 00:19:01,579
this shader does is it will for every

00:18:58,549 --> 00:19:04,479
pixel cut it down by 25% and then sample

00:19:01,579 --> 00:19:08,979
from the adjacent adjacent pixels

00:19:04,479 --> 00:19:13,450
depending on what that value is so

00:19:08,979 --> 00:19:16,669
there's a really simple hack that you

00:19:13,450 --> 00:19:21,679
can do which is I'll just paste in

00:19:16,669 --> 00:19:24,079
another shader so you can edit this so

00:19:21,679 --> 00:19:26,509
if I type something in and compile it'll

00:19:24,079 --> 00:19:27,799
give me a syntax error but if you select

00:19:26,509 --> 00:19:31,039
it all and paste in a completely new

00:19:27,799 --> 00:19:32,509
shader what this will do is if the

00:19:31,039 --> 00:19:34,820
motion value is 0

00:19:32,509 --> 00:19:36,919
don't bother sampling four times from

00:19:34,820 --> 00:19:39,679
exactly the same value and then adding

00:19:36,919 --> 00:19:40,820
them together to get the same number

00:19:39,679 --> 00:19:43,309
that you would have gotten just sample

00:19:40,820 --> 00:19:45,829
once so watch the cost of this render

00:19:43,309 --> 00:19:48,079
when I compile it it goes down by you

00:19:45,829 --> 00:19:50,209
know thirty percent so that's enough for

00:19:48,079 --> 00:19:51,499
like seven or eight percent for this

00:19:50,209 --> 00:19:55,729
whole benchmark to change that one

00:19:51,499 --> 00:19:58,219
shader so this is not something that we

00:19:55,729 --> 00:19:59,979
can put in Mesa because it's an

00:19:58,219 --> 00:20:02,570
optimization designed specifically to

00:19:59,979 --> 00:20:03,859
alter the score of a benchmark to make

00:20:02,570 --> 00:20:05,899
our hardware look like it can process

00:20:03,859 --> 00:20:08,209
this bad shader but if you have a

00:20:05,899 --> 00:20:10,969
proprietary driver from a vendor who's

00:20:08,209 --> 00:20:13,279
giving you a large forty megabyte binary

00:20:10,969 --> 00:20:16,339
blob you have to ask yourself what's in

00:20:13,279 --> 00:20:18,139
that blob and probably what's in it is a

00:20:16,339 --> 00:20:19,549
lot of shaders for benchmarks that

00:20:18,139 --> 00:20:22,249
they've rewritten the shaders to try to

00:20:19,549 --> 00:20:27,109
give you you know if I happen to be

00:20:22,249 --> 00:20:28,700
running you know benchmark X don't do

00:20:27,109 --> 00:20:30,559
what it says let's do it the right way

00:20:28,700 --> 00:20:32,359
like let's avoid our own glass jaw and

00:20:30,559 --> 00:20:34,820
and rewrite the shader completely so

00:20:32,359 --> 00:20:36,169
like I said lots of dirty tricks that

00:20:34,820 --> 00:20:40,279
you can you can play with a proprietary

00:20:36,169 --> 00:20:41,809
driver stack all right in fact if you

00:20:40,279 --> 00:20:43,599
look at the render target it is exactly

00:20:41,809 --> 00:20:47,239
its pixel the same right it's equivalent

00:20:43,599 --> 00:20:48,919
we did have a bug when we went and tried

00:20:47,239 --> 00:20:50,779
to implement this we weren't getting the

00:20:48,919 --> 00:20:52,819
performance benefit and it turned out we

00:20:50,779 --> 00:20:54,469
did our math wrong and so it you know

00:20:52,819 --> 00:20:54,980
just an example of how you can

00:20:54,469 --> 00:20:59,960
experiment

00:20:54,980 --> 00:21:02,240
quickly if you say okay well let's just

00:20:59,960 --> 00:21:04,160
make those pixels black for if I'm in

00:21:02,240 --> 00:21:05,600
this if case and you could compile and

00:21:04,160 --> 00:21:07,100
you look at the render target and it's

00:21:05,600 --> 00:21:08,960
actually interesting I wouldn't have

00:21:07,100 --> 00:21:10,190
from the green we render target I

00:21:08,960 --> 00:21:13,160
wouldn't have noticed that the waterfall

00:21:10,190 --> 00:21:15,169
was also moving slightly but you can you

00:21:13,160 --> 00:21:17,750
can quickly change the shader recompile

00:21:15,169 --> 00:21:19,250
and re-render see the performance

00:21:17,750 --> 00:21:21,110
difference and and try to find the bugs

00:21:19,250 --> 00:21:23,840
in your shader so this is a performance

00:21:21,110 --> 00:21:25,429
tool but it's I think even more so a

00:21:23,840 --> 00:21:27,860
shader debugger tool and that's really

00:21:25,429 --> 00:21:33,850
what's missing in the linux graphic

00:21:27,860 --> 00:21:37,610
space alright I think that's enough for

00:21:33,850 --> 00:21:39,760
just make sure okay so let's let's go on

00:21:37,610 --> 00:21:42,200
quickly to a more complicated demo

00:21:39,760 --> 00:21:47,049
because that workload is not that

00:21:42,200 --> 00:21:49,580
interesting so for this one I'm gonna

00:21:47,049 --> 00:21:51,200
disable I'm gonna enable the shader

00:21:49,580 --> 00:21:54,260
cache we have a new transparent shader

00:21:51,200 --> 00:21:57,260
cache and Mesa which makes things much

00:21:54,260 --> 00:21:59,299
faster and that's lovely for all of our

00:21:57,260 --> 00:22:01,450
users unfortunately when you're not

00:21:59,299 --> 00:22:03,919
compiling the shaders this tool can't

00:22:01,450 --> 00:22:10,309
collect all the intermediate assembly

00:22:03,919 --> 00:22:11,870
and give you the binary the 70 16 so we

00:22:10,309 --> 00:22:13,880
wouldn't we'd still be waiting right now

00:22:11,870 --> 00:22:16,120
if I didn't have the shader caching

00:22:13,880 --> 00:22:16,120
table

00:22:19,260 --> 00:22:26,080
so those of you who are writing Mesa

00:22:21,880 --> 00:22:27,640
master I think that's it's good for you

00:22:26,080 --> 00:22:29,710
and the shade of cash is there for you

00:22:27,640 --> 00:22:32,380
and I think it will stop your games from

00:22:29,710 --> 00:22:36,310
jittering as you enter the room where

00:22:32,380 --> 00:22:40,000
new things are rendered ok so this is a

00:22:36,310 --> 00:22:43,510
stack ruins it's the I think it's the

00:22:40,000 --> 00:22:45,070
newest GFX bench benchmark that people

00:22:43,510 --> 00:22:47,890
are working towards but again you can

00:22:45,070 --> 00:22:51,360
see in the profile that the performance

00:22:47,890 --> 00:22:56,700
is totally dominated by a few renders

00:22:51,360 --> 00:22:59,530
specifically this one and in fact if you

00:22:56,700 --> 00:23:02,080
it's always the it's always they compose

00:22:59,530 --> 00:23:03,220
composed the final frame what's this

00:23:02,080 --> 00:23:05,470
frame doing I'm gonna zoom in a little

00:23:03,220 --> 00:23:08,620
bit if you look at the renders leading

00:23:05,470 --> 00:23:11,680
up to it what you'll see is different

00:23:08,620 --> 00:23:12,880
blurry blurriness right so it's

00:23:11,680 --> 00:23:14,320
surrendering the same thing over and

00:23:12,880 --> 00:23:16,680
over again with different blur effects

00:23:14,320 --> 00:23:18,640
and then in this frame it's it's

00:23:16,680 --> 00:23:21,400
composing them completely you can see

00:23:18,640 --> 00:23:23,590
maybe in the back here there's a little

00:23:21,400 --> 00:23:24,820
thing that's far off and if you look at

00:23:23,590 --> 00:23:27,070
the previous one to show you just clear

00:23:24,820 --> 00:23:28,570
up a little bit so it gets clear so

00:23:27,070 --> 00:23:29,920
depth of field effect right so it's

00:23:28,570 --> 00:23:33,070
trying to make it look like a cameras

00:23:29,920 --> 00:23:36,880
focused still expensive if you look at

00:23:33,070 --> 00:23:41,170
the render you'll see that out sorry

00:23:36,880 --> 00:23:43,530
vertex shader is nothing but in the

00:23:41,170 --> 00:23:47,440
fragment shader

00:23:43,530 --> 00:23:50,620
it appears that GFX bench has noticed

00:23:47,440 --> 00:23:52,000
that that everyone is replacing their

00:23:50,620 --> 00:23:53,020
shader and making it more efficient

00:23:52,000 --> 00:23:54,970
because in this case they actually do

00:23:53,020 --> 00:23:56,770
check to see if there's anything and

00:23:54,970 --> 00:23:59,560
it's only in the else case where they

00:23:56,770 --> 00:24:03,130
iterate through and and go and sample

00:23:59,560 --> 00:24:06,400
for the for the blur effect so that's

00:24:03,130 --> 00:24:08,260
that's good I really want to look at

00:24:06,400 --> 00:24:11,410
this frame though more to show you some

00:24:08,260 --> 00:24:13,930
of the other debugging features

00:24:11,410 --> 00:24:16,570
well there's experiments I mean it's

00:24:13,930 --> 00:24:20,100
interesting if you disable this and look

00:24:16,570 --> 00:24:23,500
at the render target it's it's the same

00:24:20,100 --> 00:24:26,140
but there's also memory or barrier I

00:24:23,500 --> 00:24:27,910
mean you know I think if you're the

00:24:26,140 --> 00:24:29,200
author of the program or a real expert

00:24:27,910 --> 00:24:30,760
in Glu can you know

00:24:29,200 --> 00:24:33,039
to read into this stuff and and and

00:24:30,760 --> 00:24:34,299
dissect the program there's similar

00:24:33,039 --> 00:24:36,490
tools for DX and actually is pretty

00:24:34,299 --> 00:24:38,350
interesting online to go see someone go

00:24:36,490 --> 00:24:40,750
dissect grand theft auto and tell you

00:24:38,350 --> 00:24:43,360
how all the shaders work and what

00:24:40,750 --> 00:24:45,760
they're doing so it's a great way this

00:24:43,360 --> 00:24:48,100
was a great way to learn OpenGL and

00:24:45,760 --> 00:24:50,130
other shader debugger tools are great

00:24:48,100 --> 00:24:53,429
for learning DX whatever something

00:24:50,130 --> 00:24:55,330
alright so I didn't show you uniforms

00:24:53,429 --> 00:24:56,470
these are the constants that are

00:24:55,330 --> 00:24:58,809
attached to every program that

00:24:56,470 --> 00:25:00,130
parameterize the execution so typically

00:24:58,809 --> 00:25:01,720
they might rotate a triangle in space

00:25:00,130 --> 00:25:05,139
and put it in the right spot for

00:25:01,720 --> 00:25:09,779
rendering before I do this I want to

00:25:05,139 --> 00:25:09,779
locate the character in the screen so

00:25:09,929 --> 00:25:17,080
let's see so let's look at the number of

00:25:15,399 --> 00:25:18,820
triangles and that'll kind of give us a

00:25:17,080 --> 00:25:23,740
hint where there's lots of triangles

00:25:18,820 --> 00:25:26,649
going on okay so that's her face I

00:25:23,740 --> 00:25:30,130
didn't show you the multiple render

00:25:26,649 --> 00:25:31,419
targets so typically more complicated

00:25:30,130 --> 00:25:33,940
applications will render to more than

00:25:31,419 --> 00:25:35,350
one render target or more than one frame

00:25:33,940 --> 00:25:37,090
buffer at a time and then use those

00:25:35,350 --> 00:25:41,850
later in the frame to compose things so

00:25:37,090 --> 00:25:45,750
it's kind of interesting to see that but

00:25:41,850 --> 00:25:45,750
let's zoom in on this

00:25:48,400 --> 00:26:01,460
okay so let's go care one more

00:25:56,870 --> 00:26:05,570
okay so this is the character and if you

00:26:01,460 --> 00:26:08,990
look at the uniforms so here's the

00:26:05,570 --> 00:26:12,950
projection and if I change a value and

00:26:08,990 --> 00:26:16,130
hit return it should reiax acute you can

00:26:12,950 --> 00:26:17,419
see actually her her head has kind of

00:26:16,130 --> 00:26:19,039
been moved over to the side right

00:26:17,419 --> 00:26:22,700
because I've changed changed where those

00:26:19,039 --> 00:26:24,260
triangles are transformed them it's kind

00:26:22,700 --> 00:26:29,289
of eerie her eyes are still in place

00:26:24,260 --> 00:26:33,850
which is a little creepy but so you know

00:26:29,289 --> 00:26:35,840
some like the eyes that are out okay

00:26:33,850 --> 00:26:38,390
yeah so if you have a problem with

00:26:35,840 --> 00:26:40,909
uniforms and you're getting riding your

00:26:38,390 --> 00:26:42,590
game you can go and figure out what

00:26:40,909 --> 00:26:46,240
they're doing all right change them find

00:26:42,590 --> 00:26:49,779
your bugs so put her head back on and

00:26:46,240 --> 00:26:51,789
but there's so yeah that's uniforms and

00:26:49,779 --> 00:26:56,630
the other thing I've been adding is

00:26:51,789 --> 00:26:58,820
entries for the GL state so this is not

00:26:56,630 --> 00:27:00,140
a complete collection of GL state but

00:26:58,820 --> 00:27:03,919
it's what I would have been able to add

00:27:00,140 --> 00:27:08,960
so far I kind of wrote my own cute qml

00:27:03,919 --> 00:27:10,460
hierarchical tree thing and so the

00:27:08,960 --> 00:27:11,929
problem with like putting things in

00:27:10,460 --> 00:27:13,279
folders is like you can never find what

00:27:11,929 --> 00:27:15,289
you're looking for so if you're looking

00:27:13,279 --> 00:27:19,250
for something like the scissor state you

00:27:15,289 --> 00:27:22,789
can just filter to define what you're

00:27:19,250 --> 00:27:25,640
looking for for example some state has

00:27:22,789 --> 00:27:29,120
you know multiple red blue red green

00:27:25,640 --> 00:27:31,039
blue alpha some has like near far all of

00:27:29,120 --> 00:27:33,429
the sort of indices for the state are

00:27:31,039 --> 00:27:38,270
correctly displayed and if you have an

00:27:33,429 --> 00:27:40,940
enum the correct values are offered to

00:27:38,270 --> 00:27:44,720
you for selection and you can you can

00:27:40,940 --> 00:27:47,289
change those and yeah so if we go down

00:27:44,720 --> 00:27:47,289
and look for

00:27:49,310 --> 00:27:59,010
what am i thank you for uh yeah like the

00:27:54,960 --> 00:28:00,690
right mask so if red is enabled that

00:27:59,010 --> 00:28:02,760
means that when you're rendering a red

00:28:00,690 --> 00:28:04,860
pixel the red channel is written and if

00:28:02,760 --> 00:28:06,150
you disable it that means the red pixels

00:28:04,860 --> 00:28:07,740
are not going to be written it's gonna

00:28:06,150 --> 00:28:10,380
keep whatever red value it had before

00:28:07,740 --> 00:28:12,150
and so about look at the render target

00:28:10,380 --> 00:28:15,270
and the character is kind of see-through

00:28:12,150 --> 00:28:17,220
because the red in her frame has not

00:28:15,270 --> 00:28:20,370
been written it's got the same value I

00:28:17,220 --> 00:28:25,050
had before so there's a an example of

00:28:20,370 --> 00:28:27,240
that you can go and coaling is another

00:28:25,050 --> 00:28:31,020
thing so calling is on and it's calling

00:28:27,240 --> 00:28:32,430
the back face of triangles so in a model

00:28:31,020 --> 00:28:34,170
there's a bunch of triangles as she

00:28:32,430 --> 00:28:35,910
turns around a bunch of triangles are

00:28:34,170 --> 00:28:37,770
facing the opposite direction and you

00:28:35,910 --> 00:28:39,150
don't need to run the shader on those

00:28:37,770 --> 00:28:41,310
triangles because they're they're facing

00:28:39,150 --> 00:28:44,220
away so it calls the back face if you

00:28:41,310 --> 00:28:46,080
call the front face and go back to the

00:28:44,220 --> 00:28:47,670
render target it's just kind of turned

00:28:46,080 --> 00:28:50,970
her around except for her eyes which is

00:28:47,670 --> 00:28:52,800
also creepy but she's she's decided that

00:28:50,970 --> 00:28:55,320
it's too dangerous to go after the gem

00:28:52,800 --> 00:28:58,740
and she's you know gonna turn around and

00:28:55,320 --> 00:29:00,480
walk out yeah so you can change any of

00:28:58,740 --> 00:29:02,490
this state and I think it's pretty easy

00:29:00,480 --> 00:29:04,770
to add new state items to just kind of

00:29:02,490 --> 00:29:06,420
look through the GL spec and collect it

00:29:04,770 --> 00:29:08,250
and then overwrite it when you're when

00:29:06,420 --> 00:29:12,060
you're retracing it if you go to the end

00:29:08,250 --> 00:29:13,740
it's interesting her she hasn't turned

00:29:12,060 --> 00:29:15,540
around in the final frame but that that

00:29:13,740 --> 00:29:18,030
turns out to be because if you remember

00:29:15,540 --> 00:29:19,380
we turned this shader off with the GI

00:29:18,030 --> 00:29:22,630
memory barrier and if I turn it back on

00:29:19,380 --> 00:29:23,770
in the in the render target she's

00:29:22,630 --> 00:29:27,790
rendering around so you can hack the

00:29:23,770 --> 00:29:36,850
stuff yeah so I think there's anything

00:29:27,790 --> 00:29:38,650
else I wanted to see you can do a

00:29:36,850 --> 00:29:40,780
scissor state and forget about we let's

00:29:38,650 --> 00:29:45,660
let's move on in the interest of time

00:29:40,780 --> 00:29:50,410
okay so I want to show you a really

00:29:45,660 --> 00:29:51,790
complex frame not a nada benchmark not

00:29:50,410 --> 00:29:55,050
something simplified just to exercise

00:29:51,790 --> 00:30:03,580
your GPU but an actual Unreal demo and

00:29:55,050 --> 00:30:08,020
see what 29 so this is like OpenGL 44 I

00:30:03,580 --> 00:30:10,390
think and it's not the fastest thing

00:30:08,020 --> 00:30:13,120
it's it's intended to provide a lot of

00:30:10,390 --> 00:30:15,310
photo realistic effects this is the kind

00:30:13,120 --> 00:30:16,330
of thing that a lot of retracing these

00:30:15,310 --> 00:30:18,340
are that these are the workloads that

00:30:16,330 --> 00:30:19,870
they're gonna fall over on so if you

00:30:18,340 --> 00:30:22,900
don't have a tool like kpx just build on

00:30:19,870 --> 00:30:24,790
top of and you're unreal it's you're

00:30:22,900 --> 00:30:26,020
gonna want to go look at this

00:30:24,790 --> 00:30:29,740
complicated workload it's not gonna work

00:30:26,020 --> 00:30:31,150
so it takes a little while for it to

00:30:29,740 --> 00:30:37,950
iterate over the frame to give you all

00:30:31,150 --> 00:30:45,610
the metrics so again you're gonna see

00:30:37,950 --> 00:30:46,990
dominated by a few a few bars so this is

00:30:45,610 --> 00:30:51,640
this is where the where the time is

00:30:46,990 --> 00:30:54,120
going and if you want to go and give it

00:30:51,640 --> 00:30:54,120
a second

00:30:54,790 --> 00:30:59,770
there we go so if you want to go and

00:30:57,130 --> 00:31:01,540
look at the dish aiders what you'll see

00:30:59,770 --> 00:31:03,130
is there's actually not a fragment

00:31:01,540 --> 00:31:06,580
shader or vertex shader it's a it's a

00:31:03,130 --> 00:31:09,850
computer and the reason why it's

00:31:06,580 --> 00:31:11,590
expensive is like it's a it's pretty I

00:31:09,850 --> 00:31:13,150
don't do you guys have like limitations

00:31:11,590 --> 00:31:15,400
on how far you can indent code when

00:31:13,150 --> 00:31:17,830
you're when you're when you can share

00:31:15,400 --> 00:31:21,970
anything because yeah this one is a

00:31:17,830 --> 00:31:26,290
monster right like so so that's why it's

00:31:21,970 --> 00:31:28,540
expensive I think the other one is the

00:31:26,290 --> 00:31:30,100
last one this is not a computer but

00:31:28,540 --> 00:31:33,670
actually it's just one call and it's

00:31:30,100 --> 00:31:34,990
flush so again if you want to go and

00:31:33,670 --> 00:31:36,970
find the performance bottom I've seen

00:31:34,990 --> 00:31:38,200
you you simply cannot look at the

00:31:36,970 --> 00:31:39,700
framerate right you really have to know

00:31:38,200 --> 00:31:42,180
and understand what's going on the frame

00:31:39,700 --> 00:31:44,320
and experiment and and get that feedback

00:31:42,180 --> 00:31:45,670
if you have a flush it might mean that

00:31:44,320 --> 00:31:47,590
you've got two different threads that

00:31:45,670 --> 00:31:51,550
are ping-ponging back and forth ones

00:31:47,590 --> 00:31:52,840
preparing the GL commands for one frame

00:31:51,550 --> 00:31:53,980
and then the other ones gonna do the

00:31:52,840 --> 00:31:57,100
other frame and then they're gonna be

00:31:53,980 --> 00:31:58,360
rendered in a single context and so so

00:31:57,100 --> 00:32:00,460
they're probably trying to work around

00:31:58,360 --> 00:32:02,500
underpowered CPUs and I would recommend

00:32:00,460 --> 00:32:03,610
that they use Intel processors if that's

00:32:02,500 --> 00:32:05,860
a problem for them because we have

00:32:03,610 --> 00:32:08,200
really powerful CPUs and our GPUs you

00:32:05,860 --> 00:32:09,430
know are not as powerful so you can get

00:32:08,200 --> 00:32:14,500
by pretty well you don't need this kind

00:32:09,430 --> 00:32:16,600
of crazy programming technique yeah so

00:32:14,500 --> 00:32:21,150
if you go and let's disable these things

00:32:16,600 --> 00:32:21,150
kind of bring bring bring up the other

00:32:25,920 --> 00:32:31,440
you can do it there's not a lot of demos

00:32:29,110 --> 00:32:34,990
a TLC because it's risky

00:32:31,440 --> 00:32:40,330
but I'm living on the edge here so all

00:32:34,990 --> 00:32:44,380
right if we look in this range what

00:32:40,330 --> 00:32:47,140
we'll see if we wait long enough is that

00:32:44,380 --> 00:32:54,280
this is sort of rendering the the fight

00:32:47,140 --> 00:32:55,780
scene and so these are the renders that

00:32:54,280 --> 00:32:57,730
are kind of drawing out the actual

00:32:55,780 --> 00:33:00,520
geometry and so this is another example

00:32:57,730 --> 00:33:06,220
of like when you want to say stop a

00:33:00,520 --> 00:33:08,100
render so so you can see it's kind of

00:33:06,220 --> 00:33:11,680
drawing the floor in the background

00:33:08,100 --> 00:33:13,980
gonna move moves forward starts drawing

00:33:11,680 --> 00:33:17,680
some of the stuff and then eventually

00:33:13,980 --> 00:33:19,780
starts drawing the characters the little

00:33:17,680 --> 00:33:23,050
new weapons that they have on their bone

00:33:19,780 --> 00:33:25,170
their belt in their heads and so this is

00:33:23,050 --> 00:33:29,530
really an elemental elementary

00:33:25,170 --> 00:33:33,880
performance rendering mistake that is

00:33:29,530 --> 00:33:36,520
easy to do and if you program GL maybe

00:33:33,880 --> 00:33:37,930
you can recognize what's what's costly

00:33:36,520 --> 00:33:41,010
or wrong about their way they're

00:33:37,930 --> 00:33:41,010
rendering the scene is anybody know

00:33:42,240 --> 00:33:47,920
they're rendering back to front right so

00:33:46,600 --> 00:33:50,860
when you when you render back to front

00:33:47,920 --> 00:33:51,880
you have to draw all the pixels and then

00:33:50,860 --> 00:33:53,140
you're gonna render the thing in front

00:33:51,880 --> 00:33:54,870
of it's gonna draw all those pixels on

00:33:53,140 --> 00:33:58,540
top of the pixels you already drew and

00:33:54,870 --> 00:34:00,820
GL has this thing it's called the depth

00:33:58,540 --> 00:34:03,690
test and they've got the death test on

00:34:00,820 --> 00:34:05,650
and if they had started at the front and

00:34:03,690 --> 00:34:07,270
drawing the characters and then drawn

00:34:05,650 --> 00:34:08,710
the wall behind them most of the

00:34:07,270 --> 00:34:09,940
pictures in the wall would have not

00:34:08,710 --> 00:34:11,139
passed the depth test it would have

00:34:09,940 --> 00:34:12,820
recognized that those triangles are

00:34:11,139 --> 00:34:14,290
further away and you wouldn't have had

00:34:12,820 --> 00:34:18,909
to go and execute the fragment shader so

00:34:14,290 --> 00:34:21,070
it went faster so interestingly over

00:34:18,909 --> 00:34:23,710
draw that's called over draw that's

00:34:21,070 --> 00:34:25,570
that's like the feature that unreal was

00:34:23,710 --> 00:34:27,310
asking from from this tools like we want

00:34:25,570 --> 00:34:28,240
an over draw a reference citation so we

00:34:27,310 --> 00:34:30,639
can figure out like

00:34:28,240 --> 00:34:34,119
winter whenever when are we doing things

00:34:30,639 --> 00:34:35,589
in the wrong order yeah okay so I don't

00:34:34,119 --> 00:34:36,849
want to spend too much time on this as

00:34:35,589 --> 00:34:38,740
the features are there but it's just an

00:34:36,849 --> 00:34:41,379
example of a more complicated workload

00:34:38,740 --> 00:34:44,560
that you can go investigate and analyze

00:34:41,379 --> 00:34:48,099
and find mistakes as a as a driver as a

00:34:44,560 --> 00:35:00,790
game developer is there anything else -

00:34:48,099 --> 00:35:02,710
you know yeah okay okay so things that

00:35:00,790 --> 00:35:05,560
maybe didn't this demo did not show off

00:35:02,710 --> 00:35:08,800
I talked previously about the windows

00:35:05,560 --> 00:35:11,500
support this is critical for the driver

00:35:08,800 --> 00:35:13,770
team if you can envision taking a single

00:35:11,500 --> 00:35:16,119
trace either on Windows or on Linux

00:35:13,770 --> 00:35:18,400
playing it back on the on the two

00:35:16,119 --> 00:35:21,400
platforms and having the exact same UI

00:35:18,400 --> 00:35:25,180
with the precise set of metrics that are

00:35:21,400 --> 00:35:28,780
exactly the same you can easily find out

00:35:25,180 --> 00:35:31,330
where your driver stack is has a gap or

00:35:28,780 --> 00:35:34,030
or your your other drivers stack has a

00:35:31,330 --> 00:35:35,530
gap and so the cross-platform nature and

00:35:34,030 --> 00:35:37,780
multi-platform nature is going to enable

00:35:35,530 --> 00:35:40,119
a lot of sort of competitive analysis of

00:35:37,780 --> 00:35:42,790
these workloads but yeah for Mesa

00:35:40,119 --> 00:35:43,869
developers we can both you know kind of

00:35:42,790 --> 00:35:44,950
make recommendations so the Windows

00:35:43,869 --> 00:35:47,170
driver is like hey there's this

00:35:44,950 --> 00:35:48,880
optimization you're missing or we can

00:35:47,170 --> 00:35:50,410
find that hey we totally totally missed

00:35:48,880 --> 00:35:52,200
this feature and in our hardware

00:35:50,410 --> 00:35:55,060
enabling and that's why we're slow on

00:35:52,200 --> 00:35:56,830
certain platform so it's been the key to

00:35:55,060 --> 00:36:00,160
finding and fixing problems in our

00:35:56,830 --> 00:36:03,670
driver things that I need to add which

00:36:00,160 --> 00:36:04,990
really I'm taking as a template graphics

00:36:03,670 --> 00:36:08,170
performance analyzers tool which i think

00:36:04,990 --> 00:36:11,290
is just a fantastic product that matt

00:36:08,170 --> 00:36:13,420
made but displaying and experimenting

00:36:11,290 --> 00:36:15,369
with the texture state displaying the

00:36:13,420 --> 00:36:17,920
geometry mesh so that people can see the

00:36:15,369 --> 00:36:19,540
vertices and understand what what each

00:36:17,920 --> 00:36:22,089
straw is drawing depth buffer

00:36:19,540 --> 00:36:23,440
visualization you can mess with the

00:36:22,089 --> 00:36:24,670
depth state but like actually seeing

00:36:23,440 --> 00:36:27,040
what what the values are in the depth

00:36:24,670 --> 00:36:28,960
buffer is very helpful and overdrawn hot

00:36:27,040 --> 00:36:30,880
spot if you can look think of the render

00:36:28,960 --> 00:36:33,310
target is something where the color

00:36:30,880 --> 00:36:35,500
rarely represents how expensive that

00:36:33,310 --> 00:36:37,450
each pixel was that's that's kind of the

00:36:35,500 --> 00:36:37,990
thing you need as a game developer to

00:36:37,450 --> 00:36:42,130
figure out where

00:36:37,990 --> 00:36:44,619
go look UI improvements I'm not a cutie

00:36:42,130 --> 00:36:47,650
qml developers with my first sort of

00:36:44,619 --> 00:36:50,020
attempt so I'm trying all the time to

00:36:47,650 --> 00:36:51,580
make it a little better but also adding

00:36:50,020 --> 00:36:54,670
support for more hardware and Android

00:36:51,580 --> 00:36:56,380
specifically you know API trace drop

00:36:54,670 --> 00:36:58,180
support for Android because it didn't

00:36:56,380 --> 00:37:00,100
seem like anyone was using it but it's

00:36:58,180 --> 00:37:01,690
really the thing Google has kind of

00:37:00,100 --> 00:37:05,290
signed up to re-enable Android support

00:37:01,690 --> 00:37:08,710
an API trace and that'll they let people

00:37:05,290 --> 00:37:10,630
like Mesa developers or game developers

00:37:08,710 --> 00:37:15,520
go and figure out like how can they

00:37:10,630 --> 00:37:16,960
fixed performance problems it's not a

00:37:15,520 --> 00:37:18,400
huge project right now it's mostly me

00:37:16,960 --> 00:37:20,560
but I have a bunch of people who've

00:37:18,400 --> 00:37:24,400
helped me especially Robert Bragg and

00:37:20,560 --> 00:37:25,990
Lionel Lander willing they definitely

00:37:24,400 --> 00:37:28,480
have enabled the performance counters

00:37:25,990 --> 00:37:32,250
that this is all based on and so that's

00:37:28,480 --> 00:37:34,570
great I'm actually gonna try to show

00:37:32,250 --> 00:37:37,900
Lionel's tool next as well because

00:37:34,570 --> 00:37:40,330
that's pretty pretty neat one problem is

00:37:37,900 --> 00:37:41,890
that when you replace a shader in a

00:37:40,330 --> 00:37:43,180
program you have to recompile all the

00:37:41,890 --> 00:37:45,130
source and you have to make a new

00:37:43,180 --> 00:37:47,230
program and you have to attach every

00:37:45,130 --> 00:37:49,480
single thing to that program all the

00:37:47,230 --> 00:37:53,350
constants and all the vertices and so

00:37:49,480 --> 00:37:55,300
that can be kind of intricate and you

00:37:53,350 --> 00:37:57,820
know the workloads that I that I've

00:37:55,300 --> 00:38:00,460
looked at it works but yeah I mean with

00:37:57,820 --> 00:38:03,430
it's gonna be a process of getting more

00:38:00,460 --> 00:38:06,160
and more users to use the tool and and

00:38:03,430 --> 00:38:07,300
report things that I can fix the other

00:38:06,160 --> 00:38:10,540
thing is not all the workloads have

00:38:07,300 --> 00:38:12,280
single frame run loops so dota 2 is like

00:38:10,540 --> 00:38:14,080
this where the way they ping-pong their

00:38:12,280 --> 00:38:15,700
threads back and forth if you just

00:38:14,080 --> 00:38:17,290
choose the single frame and iterate over

00:38:15,700 --> 00:38:21,010
it it won't render properly and so

00:38:17,290 --> 00:38:23,740
that's another thing I need to fix yeah

00:38:21,010 --> 00:38:29,320
so what's new is ambi performance

00:38:23,740 --> 00:38:32,290
monitor support so engineers from AMD

00:38:29,320 --> 00:38:35,859
have helpfully implemented this this

00:38:32,290 --> 00:38:40,420
interface and getting it into memory

00:38:35,859 --> 00:38:43,900
trace which is pretty trivial but now we

00:38:40,420 --> 00:38:46,590
have a whole pile of metrics that will

00:38:43,900 --> 00:38:50,340
help us go and look at the

00:38:46,590 --> 00:38:52,170
Cabul 8g unfortunately one of the things

00:38:50,340 --> 00:38:54,600
about the way they implemented this this

00:38:52,170 --> 00:38:56,940
extension date they didn't really do it

00:38:54,600 --> 00:38:58,530
as written what they did is they expose

00:38:56,940 --> 00:39:01,320
just the raw registers from their

00:38:58,530 --> 00:39:03,570
performance fabric and so if you say how

00:39:01,320 --> 00:39:06,180
many counters do you have I have 50,000

00:39:03,570 --> 00:39:08,490
counters and you need a third-party tool

00:39:06,180 --> 00:39:10,620
to go and interpret that and turn it

00:39:08,490 --> 00:39:12,030
into real metrics they luckily they've

00:39:10,620 --> 00:39:13,950
open sourced that as well

00:39:12,030 --> 00:39:16,140
it's called GPA which is a little bit

00:39:13,950 --> 00:39:20,910
confusing for those of us who worked on

00:39:16,140 --> 00:39:23,520
the GPA team at Intel but since they put

00:39:20,910 --> 00:39:26,340
it on github it was you know not too

00:39:23,520 --> 00:39:28,350
hard to go and and and fix it but I

00:39:26,340 --> 00:39:31,560
found out though when I went and tested

00:39:28,350 --> 00:39:33,540
that is that the GPA library that AMD

00:39:31,560 --> 00:39:35,280
makes has never ever run on Mesa it's

00:39:33,540 --> 00:39:39,540
only run on the catalyst driver for

00:39:35,280 --> 00:39:41,610
Linux so you know this is why we need

00:39:39,540 --> 00:39:45,090
open source tools because you can't

00:39:41,610 --> 00:39:46,620
depend on your upstream producers to

00:39:45,090 --> 00:39:48,570
solve all your problems for you you need

00:39:46,620 --> 00:39:50,100
to be able to take their their

00:39:48,570 --> 00:39:52,140
implementation and put it in your

00:39:50,100 --> 00:39:54,180
embedded product and figure out why it

00:39:52,140 --> 00:39:56,390
doesn't work and then go and fix it

00:39:54,180 --> 00:40:01,260
it's really critical for everyone here

00:39:56,390 --> 00:40:03,930
so that's what's happened GPA so it's

00:40:01,260 --> 00:40:06,540
this is fresh out of the oven it's it'll

00:40:03,930 --> 00:40:09,240
burn your fingers I mean I think I'm the

00:40:06,540 --> 00:40:12,840
only person who's ever gotten

00:40:09,240 --> 00:40:15,090
AMD Metrix off of Mesa so if you run

00:40:12,840 --> 00:40:18,330
right now to my frame retrace branch and

00:40:15,090 --> 00:40:19,500
and look for a GPA branch next to it you

00:40:18,330 --> 00:40:23,610
could be the second person in the world

00:40:19,500 --> 00:40:27,240
to look at radeon metrics for a graphics

00:40:23,610 --> 00:40:29,670
workload on linux as a side effect

00:40:27,240 --> 00:40:31,020
though Raspberry Pi and Nouveau they

00:40:29,670 --> 00:40:33,120
both added support for the AMD

00:40:31,020 --> 00:40:34,920
performance monitor so all those

00:40:33,120 --> 00:40:37,380
developers are eager to get the same

00:40:34,920 --> 00:40:42,120
support for their for their platforms

00:40:37,380 --> 00:40:45,120
and and those will be arriving soon okay

00:40:42,120 --> 00:40:46,320
a little bit time so I want to talk a

00:40:45,120 --> 00:40:50,730
little bit if you remember I mentioned

00:40:46,320 --> 00:40:55,160
and you use GPU top to see the system

00:40:50,730 --> 00:40:55,160
load and I'd like to show that for you

00:40:59,180 --> 00:41:04,890
so I just need to since it's collecting

00:41:03,540 --> 00:41:07,530
metrics from the whole system it needs

00:41:04,890 --> 00:41:11,070
to run a server as route so you start

00:41:07,530 --> 00:41:15,660
GPU top and then start the GPU top UI

00:41:11,070 --> 00:41:19,830
and Lionel has done a fantastic job of

00:41:15,660 --> 00:41:21,770
adding tons of features to this he USB

00:41:19,830 --> 00:41:24,270
GPU top was kind of like a web

00:41:21,770 --> 00:41:26,850
javascript thing you could connect and

00:41:24,270 --> 00:41:29,010
view and your web browser but he decided

00:41:26,850 --> 00:41:31,080
that this rendering engine called I am

00:41:29,010 --> 00:41:33,600
GUI is like the coolest thing he loves

00:41:31,080 --> 00:41:35,550
it and he it's amazing how fast he can

00:41:33,600 --> 00:41:38,970
get things done with it so if you

00:41:35,550 --> 00:41:41,280
haven't seen I am GUI especially for the

00:41:38,970 --> 00:41:43,680
embedded world it sounds like it sounds

00:41:41,280 --> 00:41:51,090
like a rocks so I would I would take a

00:41:43,680 --> 00:41:53,250
look at that alright so so we connect to

00:41:51,090 --> 00:41:55,260
the server you again you'd want to run

00:41:53,250 --> 00:41:56,940
this on a different system because I am

00:41:55,260 --> 00:42:02,610
GUI has its own graphics and that's

00:41:56,940 --> 00:42:05,370
gonna cause GPU work to be running on

00:42:02,610 --> 00:42:07,290
your on your system but my system is a

00:42:05,370 --> 00:42:13,590
carry like GT 3 so there's three slices

00:42:07,290 --> 00:42:18,180
each with a use so let's see if I can

00:42:13,590 --> 00:42:21,150
remember so if we choose the render

00:42:18,180 --> 00:42:23,340
basic that's kind of like the general

00:42:21,150 --> 00:42:27,420
metrics you want and then we start

00:42:23,340 --> 00:42:33,960
sampling this up top it's just the CPU

00:42:27,420 --> 00:42:36,630
utilization but if we show the live

00:42:33,960 --> 00:42:38,610
counters there it is I'll give you a

00:42:36,630 --> 00:42:42,090
nice little this is this pretty much the

00:42:38,610 --> 00:42:43,140
same counters as API tree as the frame

00:42:42,090 --> 00:42:44,190
rate race tool you can choose a

00:42:43,140 --> 00:42:46,740
different counter set for different

00:42:44,190 --> 00:42:49,140
holes but you can see whether the e is

00:42:46,740 --> 00:42:51,570
active or stalled and how busy the GPU

00:42:49,140 --> 00:42:57,300
is there's not a lot going on there's

00:42:51,570 --> 00:43:00,000
also a time line let's not do that

00:42:57,300 --> 00:43:08,310
oh yeah

00:43:00,000 --> 00:43:12,810
timeline so if you add that you stall

00:43:08,310 --> 00:43:14,700
and EU active and GPU busy it's kind of

00:43:12,810 --> 00:43:23,280
graphing it over time and so I'll go and

00:43:14,700 --> 00:43:25,590
start a workload so again this is our

00:43:23,280 --> 00:43:31,650
our benchmark where she wants to go and

00:43:25,590 --> 00:43:34,110
get the gem and you can see that the GPU

00:43:31,650 --> 00:43:36,510
is much busier we actually have quite a

00:43:34,110 --> 00:43:38,490
bit of stall here and so it seems to me

00:43:36,510 --> 00:43:40,200
that we have some opportunity to try to

00:43:38,490 --> 00:43:43,650
figure out on our hardware platform

00:43:40,200 --> 00:43:47,390
what exactly is stalling and try to

00:43:43,650 --> 00:43:51,380
optimize this this workload quite a bit

00:43:47,390 --> 00:43:57,110
so you can see she's got the gem but now

00:43:51,380 --> 00:44:00,540
there's gonna be bad things happen so

00:43:57,110 --> 00:44:05,100
yeah one other thing though if you

00:44:00,540 --> 00:44:08,700
notice over on the CPU land it the the

00:44:05,100 --> 00:44:11,520
CPU is pegged at a hundred percent so in

00:44:08,700 --> 00:44:13,260
fact the GPU is not at a hundred percent

00:44:11,520 --> 00:44:15,810
and so this is a classic case of where

00:44:13,260 --> 00:44:18,300
you you don't want to go and optimize

00:44:15,810 --> 00:44:20,610
the the workload too hard because it's

00:44:18,300 --> 00:44:21,870
not gonna improve your framerate it's

00:44:20,610 --> 00:44:24,750
just not going to improve your framerate

00:44:21,870 --> 00:44:25,970
because that's not what's slowing you

00:44:24,750 --> 00:44:29,670
down

00:44:25,970 --> 00:44:31,860
so this you have to understand this is

00:44:29,670 --> 00:44:33,300
an API trace of the benchmark it may be

00:44:31,860 --> 00:44:35,040
they're running the benchmark itself is

00:44:33,300 --> 00:44:36,960
not GPU bound but I just want to show

00:44:35,040 --> 00:44:40,710
you an example of why you need to look

00:44:36,960 --> 00:44:44,000
at the system over so alright so this is

00:44:40,710 --> 00:44:44,000
the part that's like really

00:44:47,260 --> 00:44:54,720
yeah interesting so if we say alright

00:44:55,260 --> 00:44:59,640
this is what Lionel's working on now

00:44:57,090 --> 00:45:01,680
it's really cool these are events that

00:44:59,640 --> 00:45:04,320
are happening and so if you stop

00:45:01,680 --> 00:45:06,630
sampling you can kind of zoom in and and

00:45:04,320 --> 00:45:10,890
see what's going on in different

00:45:06,630 --> 00:45:12,270
rendering threads so more to come here I

00:45:10,890 --> 00:45:13,680
think this is really cool if you're

00:45:12,270 --> 00:45:15,600
missing a vsync event and you're

00:45:13,680 --> 00:45:17,970
stuttering because you can't get the

00:45:15,600 --> 00:45:20,310
graphics workload done in time there's

00:45:17,970 --> 00:45:21,960
gonna be events like when was the

00:45:20,310 --> 00:45:24,540
working queued when did the context

00:45:21,960 --> 00:45:27,330
switch right when did was the last frame

00:45:24,540 --> 00:45:29,280
flipped and that will give you hints as

00:45:27,330 --> 00:45:31,530
to why you're missing that deadline so

00:45:29,280 --> 00:45:36,330
in order to actually show that I need to

00:45:31,530 --> 00:45:37,920
run a kernel and a brand-new kernel

00:45:36,330 --> 00:45:40,590
which is an upstream and I did not want

00:45:37,920 --> 00:45:43,680
to risk my my demo on that particular

00:45:40,590 --> 00:45:45,660
kernel you know it's still in the oven

00:45:43,680 --> 00:45:48,090
it's not cooked and I don't want the raw

00:45:45,660 --> 00:45:52,050
chicken to cause my my demo to puke all

00:45:48,090 --> 00:45:53,190
over but I think you guys get the idea

00:45:52,050 --> 00:45:54,780
that there's there's a lot of features

00:45:53,190 --> 00:45:57,180
there and there's there's gonna be a lot

00:45:54,780 --> 00:45:59,360
of information for you to look at all

00:45:57,180 --> 00:45:59,360
right

00:46:01,610 --> 00:46:07,650
that's that's it those are the tools

00:46:03,810 --> 00:46:10,220
that we have and I hope you find that

00:46:07,650 --> 00:46:12,330
it's interesting or you know helps you

00:46:10,220 --> 00:46:14,640
think of things to look at with your

00:46:12,330 --> 00:46:18,380
driver stack so you have any questions

00:46:14,640 --> 00:46:18,380
about the product yeah

00:46:20,790 --> 00:46:24,020
platforms to be able to run out

00:46:27,500 --> 00:46:32,570
yeah yeah yeah I mean you know like

00:46:30,250 --> 00:46:34,340
before performance kind of support you

00:46:32,570 --> 00:46:36,260
click on the metric drop-down so the

00:46:34,340 --> 00:46:37,820
question is is it just the performance

00:46:36,260 --> 00:46:40,190
counters that we need in order to make

00:46:37,820 --> 00:46:43,250
the tool run on other other platforms

00:46:40,190 --> 00:46:44,750
and I mean the bar graph is the most

00:46:43,250 --> 00:46:47,510
important part of that tool if you're

00:46:44,750 --> 00:46:49,040
looking at performance if you don't have

00:46:47,510 --> 00:46:52,010
performance counters the number of

00:46:49,040 --> 00:46:55,490
metrics you get to graph is one and it's

00:46:52,010 --> 00:46:57,050
called no metric and it just is a flat

00:46:55,490 --> 00:46:59,330
bar graph you can still use the

00:46:57,050 --> 00:47:02,240
debugging because OpenGL is OpenGL on

00:46:59,330 --> 00:47:06,710
this intercepts at the OpenGL layer so I

00:47:02,240 --> 00:47:09,950
know that the Broadcom driver developer

00:47:06,710 --> 00:47:17,530
has fired it up to go look at at

00:47:09,950 --> 00:47:17,530
workloads just for debugging else

00:47:19,040 --> 00:47:24,350
all right well thanks for your time I

00:47:22,430 --> 00:47:26,820
hope it's interesting and I hope you

00:47:24,350 --> 00:47:31,479
enjoy the rest of the conference

00:47:26,820 --> 00:47:31,479

YouTube URL: https://www.youtube.com/watch?v=q-5YkK3dGtI


