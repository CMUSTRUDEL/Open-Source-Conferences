Title: I + I2C = I3C: What's in this Additional 'I'? - Boris Brezillon, Bootlin (formerly Free Electrons)
Publication date: 2018-03-14
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	I + I2C = I3C: What's in this Additional 'I'? - Boris Brezillon, Bootlin (formerly Free Electrons)

The MIPI Alliance recently released version 1 of the I3C (pronounce 'eye-three-see') bus specification, which is supposed to be an improvement over the long-standing I2C and SPI protocols. Compared to I2C/SPI, I3C provides a higher data rate, lower power consumption and additional features such as dynamic address assignment, host join, in-band interrupts. For the last year or so, Free Electrons has been working with Cadence Design Systems on supporting this new kind of bus in Linux.

With this talk we would like to introduce this new bus and the concepts it brings to the table. We will also detail how we plan to expose the new features exposed by the I3C protocol in Linux and go through future possible improvements of the I3C framework that has already been submitted for review on the Linux kernel mailing list. 

About Boris Brezillon
Since 2014, Boris works at Bootlin (formerly Free Electrons), a company offering development, consulting and training services to embedded Linux system developers worldwide. He has been working on embedded systems since 2008, mostly Linux on ARM. Boris is the maintainer of the MTD NAND subsystem, and has contributed to the support for Atmel and Allwinner ARM SoCs in the Linux kernel. He has recently been involved in the development of a new subsystem to expose the I3C bus in Linux.
Captions: 
	00:00:00,030 --> 00:00:08,309
hello everyone so today I'm gonna talk

00:00:04,980 --> 00:00:11,340
about ice Chrissy first a few words

00:00:08,309 --> 00:00:16,310
about me so I'm working at Boot lien

00:00:11,340 --> 00:00:19,230
which some of you knew as Freck Tron's

00:00:16,310 --> 00:00:22,380
we had to change our name because of

00:00:19,230 --> 00:00:24,210
legal issues but we're really the same

00:00:22,380 --> 00:00:26,760
team of engineers working in the same

00:00:24,210 --> 00:00:30,750
company nothing has changed except the

00:00:26,760 --> 00:00:33,870
name so few things about me and in the

00:00:30,750 --> 00:00:39,450
community the maintainer of the of the

00:00:33,870 --> 00:00:42,090
MTD subsystem I worked on our mesas his

00:00:39,450 --> 00:00:46,800
reports or developing drivers or the

00:00:42,090 --> 00:00:50,760
supporting platforms and so on yeah what

00:00:46,800 --> 00:00:55,140
we are really interested here is that I

00:00:50,760 --> 00:01:00,210
submitted or FC for the ICC of subsystem

00:00:55,140 --> 00:01:03,149
so let's see what this is exactly so for

00:01:00,210 --> 00:01:07,280
the revenue we knew I square C has

00:01:03,149 --> 00:01:11,460
persimmons inter integrated secret

00:01:07,280 --> 00:01:14,760
actually the new I which is what we are

00:01:11,460 --> 00:01:19,080
looking after means improved so if it's

00:01:14,760 --> 00:01:25,259
improved it's obviously better yeah

00:01:19,080 --> 00:01:28,290
I think I'm done okay

00:01:25,259 --> 00:01:31,229
you don't seem Iran's seem to be

00:01:28,290 --> 00:01:36,900
convinced luckily I had a few backup

00:01:31,229 --> 00:01:41,130
slides so let's ever get what I 3 C is

00:01:36,900 --> 00:01:44,070
exactly so i square C and SP I have been

00:01:41,130 --> 00:01:50,490
there for quite a long time it's been

00:01:44,070 --> 00:01:55,140
created invented the haiti's they work

00:01:50,490 --> 00:02:00,119
fine I mean we are using them all every

00:01:55,140 --> 00:02:02,250
day but still there are a bit limited so

00:02:00,119 --> 00:02:05,070
let's have a look at what they provide

00:02:02,250 --> 00:02:08,550
so they both are relatively simple to

00:02:05,070 --> 00:02:12,090
implement they both require or limiting

00:02:08,550 --> 00:02:13,250
the amount of pins to connect a few

00:02:12,090 --> 00:02:18,750
devices

00:02:13,250 --> 00:02:22,110
but I square C is really slow SPI is not

00:02:18,750 --> 00:02:25,500
that slow actually you can have devices

00:02:22,110 --> 00:02:32,360
which support I don't remember but it's

00:02:25,500 --> 00:02:35,580
around 550 megahertz clocks but the

00:02:32,360 --> 00:02:37,170
downside of SPI is that for each new

00:02:35,580 --> 00:02:40,110
device you want to connect on bus you

00:02:37,170 --> 00:02:42,959
have to add a new chip select pin so

00:02:40,110 --> 00:02:46,040
it's not that chip in term of the number

00:02:42,959 --> 00:02:52,650
of pins you need to connect devices on

00:02:46,040 --> 00:02:56,250
spiders both need extra pins to signal

00:02:52,650 --> 00:02:59,850
interrupts they don't support a plug

00:02:56,250 --> 00:03:06,030
they don't support automatic discovery

00:02:59,850 --> 00:03:07,500
of devices on the bus so on I square C

00:03:06,030 --> 00:03:09,299
you can at least know if there is

00:03:07,500 --> 00:03:13,819
something on the bus but you can't

00:03:09,299 --> 00:03:18,780
define what's of I ever wanted address

00:03:13,819 --> 00:03:20,670
and on I square C bus a you have the

00:03:18,780 --> 00:03:22,500
address creation program so if you have

00:03:20,670 --> 00:03:23,850
two devices two different devices you

00:03:22,500 --> 00:03:25,799
want to connect on the same bus you have

00:03:23,850 --> 00:03:27,930
to make sure that they have different

00:03:25,799 --> 00:03:32,519
addresses otherwise there is a collision

00:03:27,930 --> 00:03:34,410
and the transaction won't work so what

00:03:32,519 --> 00:03:37,590
if we could overcome this limitation

00:03:34,410 --> 00:03:43,709
with a new protocol and this is what I

00:03:37,590 --> 00:03:47,820
three C is here for so I couldn't decide

00:03:43,709 --> 00:03:49,920
it me P the fact that the i3c standard

00:03:47,820 --> 00:03:51,750
is pushed and developed by me P was a

00:03:49,920 --> 00:03:53,459
good thing or bad thing so I left it

00:03:51,750 --> 00:03:57,329
here

00:03:53,459 --> 00:03:59,160
I let you decide but the good things

00:03:57,329 --> 00:04:01,350
about the protocol is that it addresses

00:03:59,160 --> 00:04:05,340
most of the problems we had with I

00:04:01,350 --> 00:04:08,819
square C and spy first thing you still

00:04:05,340 --> 00:04:12,420
need only to pians like I square C but

00:04:08,819 --> 00:04:15,239
now the protocol supports what the coal

00:04:12,420 --> 00:04:17,639
in bending trips which means if you want

00:04:15,239 --> 00:04:19,200
to signal interrupts you don't eat you

00:04:17,639 --> 00:04:21,780
don't need to add an extra pin per

00:04:19,200 --> 00:04:23,729
device to do that it's already

00:04:21,780 --> 00:04:26,040
everything goes through the best

00:04:23,729 --> 00:04:30,240
directly

00:04:26,040 --> 00:04:33,540
it provides higher throughput it's still

00:04:30,240 --> 00:04:38,010
not what would that ship with a spy bus

00:04:33,540 --> 00:04:44,190
but obviously better than what you have

00:04:38,010 --> 00:04:46,680
with a squeezy it's better in terms of

00:04:44,190 --> 00:04:50,550
poor management then I square see oh

00:04:46,680 --> 00:04:53,820
that's not that easy to determine but we

00:04:50,550 --> 00:04:56,040
had the calculation based the

00:04:53,820 --> 00:04:59,400
calculation done by the meet my BP

00:04:56,040 --> 00:05:03,630
Alliance was based on the per bit basis

00:04:59,400 --> 00:05:06,240
so it might happen that if you have a

00:05:03,630 --> 00:05:09,750
nice quasi device connected on I squared

00:05:06,240 --> 00:05:13,710
C bus it will probably consume less than

00:05:09,750 --> 00:05:14,160
if it was connected to a nice and i3c

00:05:13,710 --> 00:05:18,000
bus

00:05:14,160 --> 00:05:21,000
that's still it's a good thing it

00:05:18,000 --> 00:05:24,380
supports all plug natively you can

00:05:21,000 --> 00:05:26,940
discover devices on the bus which has

00:05:24,380 --> 00:05:29,130
much easy to support than a week to

00:05:26,940 --> 00:05:33,180
declare all devices take it statically

00:05:29,130 --> 00:05:36,090
in your frame where it support dynamic

00:05:33,180 --> 00:05:38,280
address ins assignment which means the

00:05:36,090 --> 00:05:42,990
device is no longer of the address

00:05:38,280 --> 00:05:45,870
assigned statically one important thing

00:05:42,990 --> 00:05:48,330
in my opinion that you have backward

00:05:45,870 --> 00:05:50,880
compatibility with I squared C which

00:05:48,330 --> 00:05:53,820
means on the ice we see bus you can

00:05:50,880 --> 00:05:56,910
connect your old I square C devices or

00:05:53,820 --> 00:05:58,640
most of them will see a bit later that

00:05:56,910 --> 00:06:03,720
is not always the case

00:05:58,640 --> 00:06:06,870
um I'm not sure about the last one but I

00:06:03,720 --> 00:06:10,110
guess this is what the plane to do in

00:06:06,870 --> 00:06:12,840
the ice ice crystal group I think the

00:06:10,110 --> 00:06:15,600
plan to standardize the device profiles

00:06:12,840 --> 00:06:18,750
pretty much like what you have with USB

00:06:15,600 --> 00:06:20,220
classes so you say that you have such

00:06:18,750 --> 00:06:22,320
kind of device and then there is a

00:06:20,220 --> 00:06:24,000
common interface to control this device

00:06:22,320 --> 00:06:27,660
and relearn have to implement a driver

00:06:24,000 --> 00:06:32,520
for each new device created by a new

00:06:27,660 --> 00:06:35,970
vendor so the downside with ICC is that

00:06:32,520 --> 00:06:39,199
it will likely be harder to implement in

00:06:35,970 --> 00:06:48,830
your ad where then I squared C was

00:06:39,199 --> 00:06:53,389
SBI worth so let's have a look at the

00:06:48,830 --> 00:06:56,090
protocol in more details the first thing

00:06:53,389 --> 00:06:58,129
you have to keep in mind that ICC has

00:06:56,090 --> 00:07:03,529
been developed with backward

00:06:58,129 --> 00:07:06,669
compatibility and 9y simply because all

00:07:03,529 --> 00:07:10,240
the I squared C devices won't go away

00:07:06,669 --> 00:07:12,529
we want to be able to support them and

00:07:10,240 --> 00:07:15,770
to support them we have two solutions

00:07:12,529 --> 00:07:19,129
either we have two bases one for the

00:07:15,770 --> 00:07:22,250
icrc devices one for the i3c devices or

00:07:19,129 --> 00:07:24,409
we make sure that i 3c versus or

00:07:22,250 --> 00:07:26,659
backward compatible with I squared C

00:07:24,409 --> 00:07:29,330
devices and that that's what they

00:07:26,659 --> 00:07:32,629
decided to do simply because you want

00:07:29,330 --> 00:07:37,370
you you don't want you add two more pins

00:07:32,629 --> 00:07:39,529
to expose devices but backward

00:07:37,370 --> 00:07:45,439
compatibility goes the other way I want

00:07:39,529 --> 00:07:48,439
you I mean if you are nice

00:07:45,439 --> 00:07:52,129
3c device vendor you want your device to

00:07:48,439 --> 00:07:56,589
work differently on an ice perseveres on

00:07:52,129 --> 00:08:00,379
or an i3 sea bass and that's why you

00:07:56,589 --> 00:08:03,229
will like the backward compatibility

00:08:00,379 --> 00:08:07,520
with I squared C so that's also

00:08:03,229 --> 00:08:10,219
supported and in the proto so let's have

00:08:07,520 --> 00:08:13,909
a look at the physical layer now as I

00:08:10,219 --> 00:08:17,330
said it's really similar to the I square

00:08:13,909 --> 00:08:21,500
C protocol and we have two lines the

00:08:17,330 --> 00:08:24,680
clock line data line the data line is

00:08:21,500 --> 00:08:28,550
most of the time in open drain mode with

00:08:24,680 --> 00:08:32,269
a bullet you add the same start repeat

00:08:28,550 --> 00:08:35,870
start stop act next sequence so these

00:08:32,269 --> 00:08:38,089
kind of things didn't change still we

00:08:35,870 --> 00:08:42,560
have a few few things that have changed

00:08:38,089 --> 00:08:47,390
and one of them is that we no longer use

00:08:42,560 --> 00:08:52,510
we no longer drive the clock and open

00:08:47,390 --> 00:08:55,810
drain so let's see why if you have a

00:08:52,510 --> 00:09:00,040
a clock running at say 400 make curates

00:08:55,810 --> 00:09:01,090
and you have a line driven with open

00:09:00,040 --> 00:09:03,070
drain with a pull-up

00:09:01,090 --> 00:09:06,520
you'll have a signal which looks like

00:09:03,070 --> 00:09:08,950
like that the same signal driven in

00:09:06,520 --> 00:09:11,980
push-pull so you see that the open drain

00:09:08,950 --> 00:09:15,760
one takes a bit more time to rise and to

00:09:11,980 --> 00:09:19,390
go over the logical high level so that's

00:09:15,760 --> 00:09:22,020
fine because the clock period is large

00:09:19,390 --> 00:09:25,540
enough to be able to detect when the

00:09:22,020 --> 00:09:28,860
level goes I am when it goes low but net

00:09:25,540 --> 00:09:32,230
then takes the same signal and period at

00:09:28,860 --> 00:09:34,660
12 megabits and you see that with the

00:09:32,230 --> 00:09:38,590
open drain and with a plop approach your

00:09:34,660 --> 00:09:42,460
signal will actually never rise fast

00:09:38,590 --> 00:09:44,620
enough to go over the eye level logical

00:09:42,460 --> 00:09:46,990
eye level and that's a problem because

00:09:44,620 --> 00:09:50,800
we want to be able to transmit things

00:09:46,990 --> 00:09:53,770
faster on the bus so we have to move to

00:09:50,800 --> 00:09:58,960
push pool in order to increase the clock

00:09:53,770 --> 00:10:01,930
frequency but when doing that we break a

00:09:58,960 --> 00:10:04,990
bit of the backward compatibility for

00:10:01,930 --> 00:10:06,790
example devices which are doing clock

00:10:04,990 --> 00:10:08,950
stretching so clock stretching is about

00:10:06,790 --> 00:10:10,990
retaining the clock low so that the

00:10:08,950 --> 00:10:14,050
master comes and the next bit of data

00:10:10,990 --> 00:10:16,330
because the slave is too slow to endure

00:10:14,050 --> 00:10:26,380
more data then that's no longer

00:10:16,330 --> 00:10:29,410
supported with as we see also SDA is

00:10:26,380 --> 00:10:32,470
still most of the time of in open drain

00:10:29,410 --> 00:10:36,070
except when you want to do I speed

00:10:32,470 --> 00:10:38,410
transfers in this case for the very much

00:10:36,070 --> 00:10:41,800
reason you have to switch in push Pole

00:10:38,410 --> 00:10:44,860
because you want your signal to raise to

00:10:41,800 --> 00:10:51,700
rise fast enough to you to be able to

00:10:44,860 --> 00:10:53,880
detect the change and then the last

00:10:51,700 --> 00:10:56,920
thing that changes that they added new

00:10:53,880 --> 00:11:00,220
modes of transmission so you what the

00:10:56,920 --> 00:11:03,130
cool idler rate mod and then you have

00:11:00,220 --> 00:11:05,500
several signals so you can use either

00:11:03,130 --> 00:11:06,140
DDR which means you are transmitting

00:11:05,500 --> 00:11:09,770
things on

00:11:06,140 --> 00:11:13,490
clocks on both eggs edges of the clock

00:11:09,770 --> 00:11:16,670
or you can turn the ternary based mode

00:11:13,490 --> 00:11:21,080
were you in cuttings using the two

00:11:16,670 --> 00:11:30,230
signals so each transition as in career

00:11:21,080 --> 00:11:32,450
using s da and SEL not only SDA so I

00:11:30,230 --> 00:11:37,100
said that we want to use push/pull to be

00:11:32,450 --> 00:11:39,920
able to achieve higher that that's not

00:11:37,100 --> 00:11:42,980
simple I mean I squared C has been

00:11:39,920 --> 00:11:46,450
designed to use open drain with a probe

00:11:42,980 --> 00:11:49,040
um there are several reasons for them

00:11:46,450 --> 00:11:52,460
the first one is that it's simpler to

00:11:49,040 --> 00:11:55,460
implement and the second one is that it

00:11:52,460 --> 00:11:58,460
helps when several devices on the bus

00:11:55,460 --> 00:12:00,620
have to take control of the bus if you

00:11:58,460 --> 00:12:02,650
use a nope and Ramos pull up a brush

00:12:00,620 --> 00:12:05,450
that means that the default state is

00:12:02,650 --> 00:12:08,870
high level and when someone wants to

00:12:05,450 --> 00:12:12,350
drive the line low then it drives the

00:12:08,870 --> 00:12:15,290
line a little bit if two devices there

00:12:12,350 --> 00:12:17,810
is never two devices which drive one

00:12:15,290 --> 00:12:21,320
devices drive the line low and the other

00:12:17,810 --> 00:12:26,420
one there's a one drive the line high

00:12:21,320 --> 00:12:28,670
which would then be a problem so we

00:12:26,420 --> 00:12:36,070
still have to support those devices

00:12:28,670 --> 00:12:39,620
which want to to use open drain sometime

00:12:36,070 --> 00:12:42,740
so forth the clock line that means that

00:12:39,620 --> 00:12:48,020
of course we can do clock stretching and

00:12:42,740 --> 00:12:56,000
also we can't have milchester so that

00:12:48,020 --> 00:13:01,070
means that yeah that's it for the SDA

00:12:56,000 --> 00:13:03,560
line there are some phases were you warm

00:13:01,070 --> 00:13:05,720
the slave device to control the data

00:13:03,560 --> 00:13:08,090
line which means in this case you have

00:13:05,720 --> 00:13:11,540
to switch from push tool to open drain

00:13:08,090 --> 00:13:14,180
and actually the I 3c master controller

00:13:11,540 --> 00:13:16,370
is doing that dynamically so depending

00:13:14,180 --> 00:13:18,560
on where it is in this state machine it

00:13:16,370 --> 00:13:20,750
will decide to drive the line input

00:13:18,560 --> 00:13:24,500
or switch to open drain to let the slave

00:13:20,750 --> 00:13:28,760
device control align and that's all you

00:13:24,500 --> 00:13:34,910
can make sure ice Percy devices still

00:13:28,760 --> 00:13:38,870
work fine on ice receiver system so what

00:13:34,910 --> 00:13:40,960
about performances when you run the

00:13:38,870 --> 00:13:45,890
clock at 12 megahertz

00:13:40,960 --> 00:13:48,710
you are about you are at about 1.4 make

00:13:45,890 --> 00:13:51,260
a byte per second but then you have

00:13:48,710 --> 00:13:54,020
another problem I mean I squares the

00:13:51,260 --> 00:13:56,300
devices have not been developed to

00:13:54,020 --> 00:13:59,690
support such high speed clock

00:13:56,300 --> 00:14:02,270
they usually realm some of them might

00:13:59,690 --> 00:14:06,140
support that but at least it it's not

00:14:02,270 --> 00:14:12,770
always the case so we have to make sure

00:14:06,140 --> 00:14:16,430
that devices on the adversity devices on

00:14:12,770 --> 00:14:17,600
the the bus still work correctly the

00:14:16,430 --> 00:14:22,190
first solution is to slow down

00:14:17,600 --> 00:14:25,250
everything so slow the clock down or we

00:14:22,190 --> 00:14:27,920
can find a solution to make the I

00:14:25,250 --> 00:14:32,230
squared C devices think that the clock

00:14:27,920 --> 00:14:35,990
signal stays low and that's what the I

00:14:32,230 --> 00:14:38,600
Tracy I three seek protocol is doing so

00:14:35,990 --> 00:14:42,320
instead of having a symmetric clock

00:14:38,600 --> 00:14:46,430
signal where the low period is equal to

00:14:42,320 --> 00:14:50,330
the IPL you have a clock signal which

00:14:46,430 --> 00:14:54,110
feels a symmetric with the high period

00:14:50,330 --> 00:14:57,500
which is below 15 nanoseconds and the I

00:14:54,110 --> 00:15:01,330
period which the low period which can be

00:14:57,500 --> 00:15:04,400
extended and because some devices embed

00:15:01,330 --> 00:15:07,370
spike filters so they detect that the

00:15:04,400 --> 00:15:10,640
signal was not maintained more than 50

00:15:07,370 --> 00:15:13,730
nanoseconds then what they see on the

00:15:10,640 --> 00:15:17,120
bus is just a low level and nothing more

00:15:13,730 --> 00:15:20,209
and thanks to that you can achieve

00:15:17,120 --> 00:15:24,320
better performance then if you drive the

00:15:20,209 --> 00:15:26,060
wall clock signal at lower rates so of

00:15:24,320 --> 00:15:29,150
course you're not you're not achieving

00:15:26,060 --> 00:15:31,880
the full performance because you're not

00:15:29,150 --> 00:15:33,800
running the clock at 12 point

00:15:31,880 --> 00:15:36,530
five megahertz but it's still better

00:15:33,800 --> 00:15:45,770
than slowing the war boost at the

00:15:36,530 --> 00:15:49,400
slowest device rate so that's some a

00:15:45,770 --> 00:15:51,530
nice three sea bass can be in three

00:15:49,400 --> 00:15:54,650
different configuration you can have the

00:15:51,530 --> 00:15:56,690
pure bus configuration which in which

00:15:54,650 --> 00:15:59,530
case you only have ice receded ice is

00:15:56,690 --> 00:16:04,040
connected on it the clock signal runs at

00:15:59,530 --> 00:16:07,400
12.5 megahertz you can support all I

00:16:04,040 --> 00:16:11,390
data rate mods and of course this is

00:16:07,400 --> 00:16:13,760
what your want to use but sometimes you

00:16:11,390 --> 00:16:16,840
have to put ice burst devices on the bus

00:16:13,760 --> 00:16:21,110
and in this case you have two sub cases

00:16:16,840 --> 00:16:24,170
the fast bus mod mixed fast blastmon

00:16:21,110 --> 00:16:27,550
which means all the devices all the icrc

00:16:24,170 --> 00:16:31,280
devices on the bus contains and high

00:16:27,550 --> 00:16:35,030
spike filter and then you can use the

00:16:31,280 --> 00:16:38,420
trick with just tin or some of the

00:16:35,030 --> 00:16:40,640
devices on the bus don't contain the spy

00:16:38,420 --> 00:16:46,130
filter and in this case you have to run

00:16:40,640 --> 00:16:49,460
the clock at the lowest rate supported

00:16:46,130 --> 00:16:52,040
by the exquisite devices so obviously

00:16:49,460 --> 00:16:54,620
the last cases you don't want to end up

00:16:52,040 --> 00:17:01,610
in this case because in this case I

00:16:54,620 --> 00:17:04,640
three seals pretty much useless so let's

00:17:01,610 --> 00:17:07,339
switch to addressing scheme we've seen

00:17:04,640 --> 00:17:11,360
the physical layer now how can we

00:17:07,339 --> 00:17:15,410
address devices in each receive well

00:17:11,360 --> 00:17:17,870
it's all it's also pretty similar to

00:17:15,410 --> 00:17:21,410
Aiswarya see you have seven bit

00:17:17,870 --> 00:17:25,250
addresses devices are expected to act or

00:17:21,410 --> 00:17:27,880
nak the transaction and still there are

00:17:25,250 --> 00:17:30,680
a few differences the first one is that

00:17:27,880 --> 00:17:32,930
devices are no longer statically

00:17:30,680 --> 00:17:35,960
assigned their addresses so the master

00:17:32,930 --> 00:17:38,480
decide which address will be assigned to

00:17:35,960 --> 00:17:40,880
the device and then that means you don't

00:17:38,480 --> 00:17:43,160
have any collision that's that's a good

00:17:40,880 --> 00:17:45,200
thing the second thing is that there is

00:17:43,160 --> 00:17:47,690
a broad cutter broadcast address

00:17:45,200 --> 00:17:49,909
and the ways this broadcast address you

00:17:47,690 --> 00:17:53,029
will be able to address all the devices

00:17:49,909 --> 00:17:57,350
on the bus at the same time so that's

00:17:53,029 --> 00:17:59,570
also a new thing of course this address

00:17:57,350 --> 00:18:02,179
has been picked in the reserve branch of

00:17:59,570 --> 00:18:04,970
the ICRC protocol so that you're sure

00:18:02,179 --> 00:18:11,539
that no ice Persie device should add

00:18:04,970 --> 00:18:13,999
this exact address so let's sum up what

00:18:11,539 --> 00:18:16,330
we've found but I squared C backward

00:18:13,999 --> 00:18:19,249
compatibility

00:18:16,330 --> 00:18:20,720
obviously the Phi and Mac layer have

00:18:19,249 --> 00:18:24,769
been designed to be backward compatible

00:18:20,720 --> 00:18:25,330
with I square C but still that's not

00:18:24,769 --> 00:18:28,609
enough

00:18:25,330 --> 00:18:30,559
for example you won't be able to connect

00:18:28,609 --> 00:18:33,200
slaves which are doing clock stretching

00:18:30,559 --> 00:18:36,830
because that's completely forbidden in

00:18:33,200 --> 00:18:38,989
ice we see if you have a I squared C

00:18:36,830 --> 00:18:41,210
devices you might be able to connect

00:18:38,989 --> 00:18:44,090
them to the bus but remember that if you

00:18:41,210 --> 00:18:46,809
if they don't have spike filters then

00:18:44,090 --> 00:18:51,309
the performance will be really low

00:18:46,809 --> 00:18:51,309
obviously though you don't want that

00:18:51,700 --> 00:18:58,090
also you have to remember that some of

00:18:54,379 --> 00:19:01,100
the Ida trade modes are not usable when

00:18:58,090 --> 00:19:02,330
some devices some I square C devices are

00:19:01,100 --> 00:19:05,330
present on a bus

00:19:02,330 --> 00:19:10,299
so it's backward compatibility

00:19:05,330 --> 00:19:10,299
compatible but still has some drawbacks

00:19:11,980 --> 00:19:19,159
so we've seen the addressing and

00:19:14,600 --> 00:19:22,460
physical layer now let's see the

00:19:19,159 --> 00:19:24,799
functional differences between ICC and I

00:19:22,460 --> 00:19:28,549
square C which is what most developers

00:19:24,799 --> 00:19:32,179
software developers are interested in so

00:19:28,549 --> 00:19:34,269
what are the ICRC and ICC physical and

00:19:32,179 --> 00:19:37,100
addressing layer were pretty similar

00:19:34,269 --> 00:19:40,279
from a functional point of view right we

00:19:37,100 --> 00:19:43,509
see an i3 C are really different for

00:19:40,279 --> 00:19:45,859
example as I said several times

00:19:43,509 --> 00:19:48,049
addresses are not statically assigned

00:19:45,859 --> 00:19:52,549
but now they are dynamically assigned by

00:19:48,049 --> 00:19:54,649
the master but one of the most

00:19:52,549 --> 00:19:56,690
interesting point here is that all

00:19:54,649 --> 00:19:59,070
devices on the bus can be discovered and

00:19:56,690 --> 00:20:01,860
you will no longer have to describe

00:19:59,070 --> 00:20:06,690
them statically in your device tree or

00:20:01,860 --> 00:20:09,419
or a new board file or whatever also

00:20:06,690 --> 00:20:11,309
devices are self-descriptive that means

00:20:09,419 --> 00:20:13,889
that when you discover something on the

00:20:11,309 --> 00:20:17,159
bus you will know exactly which device

00:20:13,889 --> 00:20:19,919
this is you will be able to easily

00:20:17,159 --> 00:20:25,919
attach the device to a specific driver

00:20:19,919 --> 00:20:27,899
and leanness some masters and slaves can

00:20:25,919 --> 00:20:30,840
support a plug so that's not mandatory

00:20:27,899 --> 00:20:36,990
but I guess most of them will support

00:20:30,840 --> 00:20:39,149
that of course because of the functional

00:20:36,990 --> 00:20:41,960
differences that means that this

00:20:39,149 --> 00:20:44,909
management is likely to be more

00:20:41,960 --> 00:20:47,129
complicated than with I squared C so

00:20:44,909 --> 00:20:49,710
we'll see a bit later to controlled

00:20:47,129 --> 00:20:51,690
abuse at you assign addresses but of

00:20:49,710 --> 00:20:55,279
course it's it's a bit more complicated

00:20:51,690 --> 00:20:58,019
than what you have with a square C and

00:20:55,279 --> 00:21:02,490
the last thing is that you have

00:20:58,019 --> 00:21:06,480
different transactions so the first type

00:21:02,490 --> 00:21:09,929
of transaction we'll look at is the CCC

00:21:06,480 --> 00:21:14,639
transaction which is meaning command

00:21:09,929 --> 00:21:16,879
command cuts so these are all the $10

00:21:14,639 --> 00:21:19,200
comments we will use to manage the bus

00:21:16,879 --> 00:21:21,659
so thanks to that you will be able to

00:21:19,200 --> 00:21:23,909
discover all devices on the bus you will

00:21:21,659 --> 00:21:27,149
be able to a query information about the

00:21:23,909 --> 00:21:29,990
device each device and you will be able

00:21:27,149 --> 00:21:33,629
to keep the bus in a consistent state

00:21:29,990 --> 00:21:36,029
and they also plan to use those generate

00:21:33,629 --> 00:21:38,669
commands to do generic operation that

00:21:36,029 --> 00:21:45,480
means operation which are not tied to a

00:21:38,669 --> 00:21:48,929
specific kind of device let's forget

00:21:45,480 --> 00:21:52,830
what this kind of frame looks like you

00:21:48,929 --> 00:21:54,809
will have an 8 bit opcode the most

00:21:52,830 --> 00:21:57,659
efficient significant bit in this opcode

00:21:54,809 --> 00:21:59,070
will encode the whether this is

00:21:57,659 --> 00:22:05,759
broadcast or a unicast

00:21:59,070 --> 00:22:09,419
current and the 7 bits will encode the

00:22:05,759 --> 00:22:11,410
actual action that will be sent to the

00:22:09,419 --> 00:22:14,050
device

00:22:11,410 --> 00:22:17,280
you can have a payroll attached to you

00:22:14,050 --> 00:22:20,050
come on CCC

00:22:17,280 --> 00:22:22,540
so the payroll in case this is the

00:22:20,050 --> 00:22:24,460
unicast command the first byte of the

00:22:22,540 --> 00:22:28,870
payload will contain the device address

00:22:24,460 --> 00:22:32,470
and then after that we have real data

00:22:28,870 --> 00:22:34,420
that are passed to the command so just a

00:22:32,470 --> 00:22:38,740
few examples of commands that you will

00:22:34,420 --> 00:22:42,820
be able to send the first one is start

00:22:38,740 --> 00:22:45,880
da a or so da is 4 stands for dynamic

00:22:42,820 --> 00:22:50,250
address assignment and this is basically

00:22:45,880 --> 00:22:54,490
the auto discovery procedure you have

00:22:50,250 --> 00:22:58,780
enter activity state X so X is just

00:22:54,490 --> 00:23:00,940
number and this is about managing power

00:22:58,780 --> 00:23:04,630
management so asking a device to enter

00:23:00,940 --> 00:23:07,270
low-power state for itself then you have

00:23:04,630 --> 00:23:09,600
our commands which are used to retrieve

00:23:07,270 --> 00:23:13,120
information about the device who get PID

00:23:09,600 --> 00:23:16,440
get this your get this year so PID is

00:23:13,120 --> 00:23:19,570
the unique Aden I identify of the device

00:23:16,440 --> 00:23:21,580
abuse characteristic is about what the

00:23:19,570 --> 00:23:25,900
device reports in terms of transfers

00:23:21,580 --> 00:23:28,440
types and at which speed and then the

00:23:25,900 --> 00:23:35,470
device characteristic is about

00:23:28,440 --> 00:23:38,230
classifying the devices so let's have a

00:23:35,470 --> 00:23:41,140
look at one of these criminals which is

00:23:38,230 --> 00:23:43,690
in my opinion the most important one and

00:23:41,140 --> 00:23:45,400
this is the one you will use when you

00:23:43,690 --> 00:23:47,710
initialize the best to discover

00:23:45,400 --> 00:23:51,580
everything that is connecting other the

00:23:47,710 --> 00:23:54,850
bus so this command is called mdaa for

00:23:51,580 --> 00:23:59,860
enter DAA which stands for dynamic

00:23:54,850 --> 00:24:01,960
address assignment to do that the master

00:23:59,860 --> 00:24:04,510
will actually send a command and then

00:24:01,960 --> 00:24:07,150
emit emit directly after that repeated

00:24:04,510 --> 00:24:10,360
start and then after after each repeated

00:24:07,150 --> 00:24:16,110
start all devices or I switch devices on

00:24:10,360 --> 00:24:19,990
the bus will emit their PID VCR and DCR

00:24:16,110 --> 00:24:22,720
information while they do that while all

00:24:19,990 --> 00:24:23,690
slaves do that they have to monitor the

00:24:22,720 --> 00:24:27,110
state of the is

00:24:23,690 --> 00:24:29,899
da line and every time the state of the

00:24:27,110 --> 00:24:32,470
SD a line is not what they intend to

00:24:29,899 --> 00:24:35,360
emit that means they lost the

00:24:32,470 --> 00:24:40,190
arbitration that means they have to stop

00:24:35,360 --> 00:24:42,139
emitting things on the bus the last

00:24:40,190 --> 00:24:45,019
device that is remaining emitting

00:24:42,139 --> 00:24:48,409
something on the bus that means it

00:24:45,019 --> 00:24:52,360
when's the arbitration and the master

00:24:48,409 --> 00:24:57,639
will then assign it an address so if we

00:24:52,360 --> 00:25:00,710
just look at a stunner mdaa procedure

00:24:57,639 --> 00:25:04,039
the master starts emitting NDAA

00:25:00,710 --> 00:25:07,250
which forces all devices on the bus to

00:25:04,039 --> 00:25:10,399
enter specific state then it emits a

00:25:07,250 --> 00:25:16,039
ribbon start we have two devices on this

00:25:10,399 --> 00:25:18,799
bus they've also made their PID DCR and

00:25:16,039 --> 00:25:24,289
BC are at the same time except that only

00:25:18,799 --> 00:25:27,379
slave one may wince arbitration then

00:25:24,289 --> 00:25:30,529
slave to our us to be as to stay silent

00:25:27,379 --> 00:25:33,009
until the next repeated start the i3

00:25:30,529 --> 00:25:36,440
semester assigned an address to slave 1

00:25:33,009 --> 00:25:39,649
which is now able to communicate on the

00:25:36,440 --> 00:25:40,909
bus and then emit a new repeated start

00:25:39,649 --> 00:25:44,149
damn

00:25:40,909 --> 00:25:46,759
same thing with slave to you which now

00:25:44,149 --> 00:25:49,490
is about you receive a new address and

00:25:46,759 --> 00:25:52,100
you end up with a repeated start which

00:25:49,490 --> 00:25:54,679
is followed by no one arcing the

00:25:52,100 --> 00:25:58,690
transaction which means the discovery

00:25:54,679 --> 00:26:04,509
procedure is done and the bus is

00:25:58,690 --> 00:26:04,509
operational so that's it

00:26:04,730 --> 00:26:08,820
so let's have a look at those

00:26:06,690 --> 00:26:13,320
information which are transmitted during

00:26:08,820 --> 00:26:16,350
GAA the PID is what we will use when

00:26:13,320 --> 00:26:20,250
trying to determine which driver which

00:26:16,350 --> 00:26:22,200
will be connected to the device when the

00:26:20,250 --> 00:26:26,160
PID you will find the manufacturer ID

00:26:22,200 --> 00:26:28,620
the part ID an instance ID in case you

00:26:26,160 --> 00:26:31,800
want to put several devices of the same

00:26:28,620 --> 00:26:34,290
type on the same bus so usually this

00:26:31,800 --> 00:26:37,320
instance ID is control with external

00:26:34,290 --> 00:26:40,320
switches or directly using the pins of

00:26:37,320 --> 00:26:42,840
the other of the device and you have

00:26:40,320 --> 00:26:47,490
extra information which I actually don't

00:26:42,840 --> 00:26:50,010
know what they are used for but this is

00:26:47,490 --> 00:26:54,540
something that vendors can put specific

00:26:50,010 --> 00:26:56,520
data in to differentiate the devices you

00:26:54,540 --> 00:26:59,280
also have this you are which is

00:26:56,520 --> 00:27:03,060
incurring what the device is capable off

00:26:59,280 --> 00:27:05,520
so if the devices is the device capable

00:27:03,060 --> 00:27:08,330
of sending interrupts is a device

00:27:05,520 --> 00:27:12,000
capable of supporting either trade modes

00:27:08,330 --> 00:27:16,080
what is the maximum transfer speed and

00:27:12,000 --> 00:27:21,140
so on and the last thing is that is the

00:27:16,080 --> 00:27:23,760
DCR which is encoding the device type so

00:27:21,140 --> 00:27:27,270
ideas here are supposed to be

00:27:23,760 --> 00:27:32,870
standardized by the EP Alliance and they

00:27:27,270 --> 00:27:36,380
are but yet I don't see what there are

00:27:32,870 --> 00:27:39,360
meaningful for because there is still no

00:27:36,380 --> 00:27:41,310
common interface for each type which

00:27:39,360 --> 00:27:43,350
means you know what kind of device this

00:27:41,310 --> 00:27:45,900
is that you don't know what you interact

00:27:43,350 --> 00:27:49,380
with it you don't know what you query

00:27:45,900 --> 00:27:51,900
information and so on so right now it's

00:27:49,380 --> 00:27:54,390
just informational and you can't use

00:27:51,900 --> 00:27:56,790
that to to implement a generic driver

00:27:54,390 --> 00:28:03,630
which has about to handle all kind of

00:27:56,790 --> 00:28:07,290
devices of this type another kind of

00:28:03,630 --> 00:28:10,920
transaction is as the art transfers or

00:28:07,290 --> 00:28:14,340
private transfers so they are meant to

00:28:10,920 --> 00:28:16,590
replace I squared C transfers except

00:28:14,340 --> 00:28:17,510
that this time they are using the food

00:28:16,590 --> 00:28:22,730
speed month

00:28:17,510 --> 00:28:28,760
so clock running at hopefully 1212

00:28:22,730 --> 00:28:31,790
megahertz there is no standard to say

00:28:28,760 --> 00:28:33,669
which kind of information or send to the

00:28:31,790 --> 00:28:36,980
device so it's completely free and

00:28:33,669 --> 00:28:39,950
devices are able to implement what they

00:28:36,980 --> 00:28:42,710
want and and all they like so it's

00:28:39,950 --> 00:28:47,559
basically what we see with i-square see

00:28:42,710 --> 00:28:52,730
already then we have HDR transfers which

00:28:47,559 --> 00:28:56,210
are used to achieve even higher data

00:28:52,730 --> 00:28:59,929
rate so we have three different modes

00:28:56,210 --> 00:29:02,030
the DDR mod is obviously one where you

00:28:59,929 --> 00:29:03,890
will transmit data on both edges of the

00:29:02,030 --> 00:29:05,960
clock and then you have determined turn

00:29:03,890 --> 00:29:09,380
on modes which are is to encode data

00:29:05,960 --> 00:29:12,620
using the two the clock and the data

00:29:09,380 --> 00:29:15,770
signals but bit complicated you see you

00:29:12,620 --> 00:29:20,240
can encode data with both SCL and SDA

00:29:15,770 --> 00:29:22,429
but that that works and you have two of

00:29:20,240 --> 00:29:24,919
them actually because depending on

00:29:22,429 --> 00:29:27,799
whether there are I squared C devices on

00:29:24,919 --> 00:29:30,350
the base or not you may have to ensure

00:29:27,799 --> 00:29:34,250
that the row the high period is lower

00:29:30,350 --> 00:29:36,320
than 50 nanoseconds because of the spike

00:29:34,250 --> 00:29:42,710
filtering and all the stuff we've seen

00:29:36,320 --> 00:29:45,280
before the data you transmit using edge

00:29:42,710 --> 00:29:48,049
your transfers are a bit more

00:29:45,280 --> 00:29:50,860
standardized and the easier as your

00:29:48,049 --> 00:29:54,679
transfers so you have to first emit a

00:29:50,860 --> 00:29:57,679
16-bit word which contains a common code

00:29:54,679 --> 00:30:00,679
and then again there is a range reserved

00:29:57,679 --> 00:30:03,890
for generic common caps so hopefully

00:30:00,679 --> 00:30:08,780
we'll we should see soon some generic

00:30:03,890 --> 00:30:11,540
comments which will be used by the ICC

00:30:08,780 --> 00:30:14,390
specification and some vendors district

00:30:11,540 --> 00:30:20,600
Commons which will be useful for those

00:30:14,390 --> 00:30:24,230
specific drivers last thing we want to

00:30:20,600 --> 00:30:27,620
talk about here is in Benin trips so how

00:30:24,230 --> 00:30:31,120
do you avoid having to add a new new

00:30:27,620 --> 00:30:31,120
signal to signal in

00:30:32,809 --> 00:30:39,809
so how does that work

00:30:36,020 --> 00:30:41,640
basically all devices on the bus all I

00:30:39,809 --> 00:30:45,210
switch the devices on the bus are able

00:30:41,640 --> 00:30:50,070
to take control of the bus temporarily

00:30:45,210 --> 00:30:53,130
to just send the IBI and the master

00:30:50,070 --> 00:30:57,840
which is in control of the bus well

00:30:53,130 --> 00:31:03,420
either AK or nak dibi but once yeah a

00:30:57,840 --> 00:31:07,320
snack dibi dibi it will have to retrieve

00:31:03,420 --> 00:31:11,390
the payload and to determine which

00:31:07,320 --> 00:31:15,360
device wins when an idea is generated

00:31:11,390 --> 00:31:18,030
there is the address arbitration which

00:31:15,360 --> 00:31:20,850
means the lowest the lower the device

00:31:18,030 --> 00:31:23,520
address the eye or the priority so that

00:31:20,850 --> 00:31:25,380
means you have to carefully choose the

00:31:23,520 --> 00:31:29,030
dynamic address assigned to each device

00:31:25,380 --> 00:31:33,290
because this encodes the priority of the

00:31:29,030 --> 00:31:33,290
indigent generation on the best

00:31:36,470 --> 00:31:46,140
adjoin it's basically what we call out

00:31:41,309 --> 00:31:48,420
plug for other protocols it's pretty

00:31:46,140 --> 00:31:50,760
much the same as ibi when a device is

00:31:48,420 --> 00:31:53,460
connected on the bus and it well it has

00:31:50,760 --> 00:31:56,490
it still has no dynamic address it's

00:31:53,460 --> 00:31:59,250
able to send an interrupt saying that it

00:31:56,490 --> 00:32:02,490
wants to join the bus and then the

00:31:59,250 --> 00:32:05,940
master will be able to AK or knock this

00:32:02,490 --> 00:32:07,920
request and if the master acts the

00:32:05,940 --> 00:32:10,440
request then they asked you assign a

00:32:07,920 --> 00:32:12,590
dynamic address and as we've seen before

00:32:10,440 --> 00:32:18,179
assigning a dynamic address is about

00:32:12,590 --> 00:32:23,640
entering GAA so yeah that's how obtain

00:32:18,179 --> 00:32:29,100
words and the last thing we'll see here

00:32:23,640 --> 00:32:31,070
is multi master capabilities so as we

00:32:29,100 --> 00:32:34,050
see in supporting multi master natively

00:32:31,070 --> 00:32:38,030
that means that you'll be able to have

00:32:34,050 --> 00:32:41,250
several masters on the same bus unlike

00:32:38,030 --> 00:32:43,510
what we add with i-square see we're all

00:32:41,250 --> 00:32:45,610
masters were able to

00:32:43,510 --> 00:32:48,520
control of the bus at the same time here

00:32:45,610 --> 00:32:51,070
it's a negotiation which between the

00:32:48,520 --> 00:32:54,280
Masters to know to know which one of

00:32:51,070 --> 00:32:56,980
them is controlling the bus so you have

00:32:54,280 --> 00:32:59,380
to type of three semesters the main

00:32:56,980 --> 00:33:02,770
master which is responsible for in the

00:32:59,380 --> 00:33:06,430
Nixon initial is a the the bus and the

00:33:02,770 --> 00:33:09,450
semester which is acting as slave at

00:33:06,430 --> 00:33:12,100
first and then when it needs to be meets

00:33:09,450 --> 00:33:14,710
frame on the best and it will have to

00:33:12,100 --> 00:33:20,200
negotiate with the current master to

00:33:14,710 --> 00:33:22,840
gain ownership of the bus so that's a

00:33:20,200 --> 00:33:28,480
bit more complicated than what we add

00:33:22,840 --> 00:33:30,850
with IX queries of course busan up ship

00:33:28,480 --> 00:33:32,770
can be requested by an inactive master

00:33:30,850 --> 00:33:35,890
which wants to take control of the best

00:33:32,770 --> 00:33:40,030
or it can also be requested by the

00:33:35,890 --> 00:33:42,370
active while master when it wants to go

00:33:40,030 --> 00:33:45,790
sleep for example and it wants someone

00:33:42,370 --> 00:33:51,810
else to endow the bus that's that's it -

00:33:45,790 --> 00:33:55,120
waiting so these or just introduction

00:33:51,810 --> 00:33:57,580
this or just a piece of him information

00:33:55,120 --> 00:34:00,370
about ice received and obviously I

00:33:57,580 --> 00:34:02,860
omitted a lot of things so if you want

00:34:00,370 --> 00:34:06,850
to know more you can go check the ICC

00:34:02,860 --> 00:34:09,490
specification which is for once open but

00:34:06,850 --> 00:34:14,910
that's not usual for me P stuff but

00:34:09,490 --> 00:34:20,860
that's a good thing actually and yeah

00:34:14,910 --> 00:34:23,530
you can go check it so let's see how we

00:34:20,860 --> 00:34:26,440
plan to support that in the next so

00:34:23,530 --> 00:34:32,080
that's basically what has been proposed

00:34:26,440 --> 00:34:32,470
in in the Earth's RFC so if you go back

00:34:32,080 --> 00:34:35,280
a bit

00:34:32,470 --> 00:34:38,680
you remember that ice we see is a bit

00:34:35,280 --> 00:34:40,900
tricky to categorize because it's

00:34:38,680 --> 00:34:44,670
backward compatible with ice core see

00:34:40,900 --> 00:34:48,790
device still it's a lot different

00:34:44,670 --> 00:34:52,060
functionally from handling iOS devices

00:34:48,790 --> 00:34:55,510
is a lot different from adding ice Bercy

00:34:52,060 --> 00:34:57,280
device so we have to keep the existing

00:34:55,510 --> 00:35:00,520
ice Persico system

00:34:57,280 --> 00:35:03,010
working without changing anything but we

00:35:00,520 --> 00:35:05,410
want you add support for new assistive

00:35:03,010 --> 00:35:08,920
functionalities and to do that we had

00:35:05,410 --> 00:35:10,900
two options the first one is extending

00:35:08,920 --> 00:35:13,620
the ice persevere mark you had ice

00:35:10,900 --> 00:35:16,900
receive features the second one is to

00:35:13,620 --> 00:35:20,230
add a new framework and then connect it

00:35:16,900 --> 00:35:26,560
to the I square C frame so we went for

00:35:20,230 --> 00:35:30,730
option two and that's basically what we

00:35:26,560 --> 00:35:34,570
have so on the bottom of the diagram and

00:35:30,730 --> 00:35:37,120
you see the other stuff and you see two

00:35:34,570 --> 00:35:40,480
bases one is receivers one ice

00:35:37,120 --> 00:35:44,380
perseveres those bases are exposed to

00:35:40,480 --> 00:35:47,860
Linux through their controller which are

00:35:44,380 --> 00:35:51,100
then connected to the I squared C or I

00:35:47,860 --> 00:35:53,950
3-3 framework and if if you go look at

00:35:51,100 --> 00:35:57,130
the devices which are connected on both

00:35:53,950 --> 00:35:59,800
lists we will see that they are then

00:35:57,130 --> 00:36:04,210
connected to their appropriate driver so

00:35:59,800 --> 00:36:06,400
if you go look at the yellow device the

00:36:04,210 --> 00:36:08,800
ice for us we see device and yellow

00:36:06,400 --> 00:36:10,930
you'll see that it's directly connected

00:36:08,800 --> 00:36:14,080
to the driver that was registered to the

00:36:10,930 --> 00:36:16,780
ice Christopher work you can also have I

00:36:14,080 --> 00:36:21,460
squared C devices connected to the i3

00:36:16,780 --> 00:36:23,890
see bus so the this is the purple one in

00:36:21,460 --> 00:36:26,430
this case it will be connected to the I

00:36:23,890 --> 00:36:30,730
squared C framework going through the

00:36:26,430 --> 00:36:32,410
ICC framework so we are basically using

00:36:30,730 --> 00:36:35,440
the same infrastructure which means if

00:36:32,410 --> 00:36:36,940
you add a nice Percy driver it will work

00:36:35,440 --> 00:36:39,400
the same way it used to work

00:36:36,940 --> 00:36:42,130
even if the device is connected on a

00:36:39,400 --> 00:36:47,050
nice free sip does that's that's

00:36:42,130 --> 00:36:50,980
supported now we have more complicated

00:36:47,050 --> 00:36:53,830
case cases for example we said that some

00:36:50,980 --> 00:36:57,190
devices are compatible with both ice

00:36:53,830 --> 00:36:59,530
Percy and ICC and in this case you want

00:36:57,190 --> 00:37:01,900
the device to be discovered when it's

00:36:59,530 --> 00:37:04,150
connected on a square bus and you want

00:37:01,900 --> 00:37:07,660
it to be discovered when it's connected

00:37:04,150 --> 00:37:10,130
on my three signals and you want the

00:37:07,660 --> 00:37:12,739
same device to be connected to the

00:37:10,130 --> 00:37:15,019
the both device both devices to be

00:37:12,739 --> 00:37:20,539
connected to the same driver so you had

00:37:15,019 --> 00:37:24,559
to add a way to register single driver

00:37:20,539 --> 00:37:26,920
to both framework that's what we did we

00:37:24,559 --> 00:37:30,739
have a new macro which is able to

00:37:26,920 --> 00:37:33,319
register a device a driver in both

00:37:30,739 --> 00:37:35,119
subsistence so that you have a single

00:37:33,319 --> 00:37:37,519
driver which has evolved gendell the

00:37:35,119 --> 00:37:39,380
device which is operating an ice Percy

00:37:37,519 --> 00:37:45,710
mode and the same device which is

00:37:39,380 --> 00:37:49,160
operating in a threesome on a few more

00:37:45,710 --> 00:37:51,759
words about the design choices first

00:37:49,160 --> 00:37:54,680
thing is that we separated the API for

00:37:51,759 --> 00:38:02,569
device driver and master controller

00:37:54,680 --> 00:38:05,210
drivers that mainly to is implementation

00:38:02,569 --> 00:38:08,720
of both kind of drivers so people don't

00:38:05,210 --> 00:38:10,609
have to guess oh is this an API for the

00:38:08,720 --> 00:38:12,890
controller part or is this an API for

00:38:10,609 --> 00:38:15,380
device driver part everything is

00:38:12,890 --> 00:38:21,170
supergene and to place in two different

00:38:15,380 --> 00:38:24,170
places so that's that's good one other

00:38:21,170 --> 00:38:27,489
important thing is that even though we

00:38:24,170 --> 00:38:31,670
have a single bus which is the i3c bus

00:38:27,489 --> 00:38:34,640
when you look in CSFs you'll see two

00:38:31,670 --> 00:38:37,069
buses represented the ice for c1 and the

00:38:34,640 --> 00:38:39,229
ice we see one and this is mainly

00:38:37,069 --> 00:38:43,609
because we didn't want to break the ice

00:38:39,229 --> 00:38:46,969
Percy ecosystem so we have to keep

00:38:43,609 --> 00:38:49,910
everything working as as before but

00:38:46,969 --> 00:38:52,359
still those buses are the same thing and

00:38:49,910 --> 00:38:56,809
they are usually connected through the

00:38:52,359 --> 00:38:59,599
parenting of so the the bus is declared

00:38:56,809 --> 00:39:01,700
by a specific controller and when you

00:38:59,599 --> 00:39:04,430
look at the controller you will be able

00:39:01,700 --> 00:39:10,670
to connect the ice perseveres to the ICC

00:39:04,430 --> 00:39:13,880
bus and then how do we bind devices to

00:39:10,670 --> 00:39:15,980
specific drivers we are basically using

00:39:13,880 --> 00:39:18,950
the DC R and P

00:39:15,980 --> 00:39:22,580
values so PID is anchoring the

00:39:18,950 --> 00:39:24,350
manufacturer and part ID and this you

00:39:22,580 --> 00:39:26,990
are is anchoring the class of the device

00:39:24,350 --> 00:39:31,400
so we use that to connect a specific

00:39:26,990 --> 00:39:35,270
device to a driver and the last thing

00:39:31,400 --> 00:39:38,900
that is - that is important to note is

00:39:35,270 --> 00:39:45,400
that IB eyes are not exposed as regular

00:39:38,900 --> 00:39:49,400
I accuse simply because most of the time

00:39:45,400 --> 00:39:52,460
they do not look like regular I accuse

00:39:49,400 --> 00:39:57,800
you have payloads which are added to the

00:39:52,460 --> 00:39:59,810
interrupt you also want to send messages

00:39:57,800 --> 00:40:01,820
on the bus after that and will see that

00:39:59,810 --> 00:40:05,060
it's not really possible in an atomic

00:40:01,820 --> 00:40:08,900
context so we decided to just simplify

00:40:05,060 --> 00:40:13,490
things and and treating them as not rare

00:40:08,900 --> 00:40:18,170
I accuse so let's have a look at the

00:40:13,490 --> 00:40:21,470
device driver API first it's exposed in

00:40:18,170 --> 00:40:25,359
Linux ice ice receipt device dot H and

00:40:21,470 --> 00:40:30,320
you'll be able to declare driver

00:40:25,359 --> 00:40:34,130
register rate you'll be able to stem as

00:40:30,320 --> 00:40:35,119
your ITR transfers and you'll be able no

00:40:34,130 --> 00:40:39,230
you're not

00:40:35,119 --> 00:40:41,540
you know you're not able to choose 7cc

00:40:39,230 --> 00:40:44,030
comments yes because as I said it's

00:40:41,540 --> 00:40:46,220
mainly here to manage the bus and I

00:40:44,030 --> 00:40:48,980
don't think it's needed for device

00:40:46,220 --> 00:40:51,170
drivers but if it appeared it appeared

00:40:48,980 --> 00:40:54,890
to be needed at some point then we will

00:40:51,170 --> 00:40:57,440
probably change that and you will of

00:40:54,890 --> 00:41:01,940
course be able to register IPIN lers and

00:40:57,440 --> 00:41:03,400
activate/deactivate dibi dibi so let's

00:41:01,940 --> 00:41:05,810
have a look at the device driver

00:41:03,400 --> 00:41:07,580
declaration that's pretty much the same

00:41:05,810 --> 00:41:09,560
thing you have for any kind of driver

00:41:07,580 --> 00:41:13,160
you have a pro function and remove

00:41:09,560 --> 00:41:16,780
function a table of device ID which are

00:41:13,160 --> 00:41:19,670
used to bind devices to drivers and

00:41:16,780 --> 00:41:23,390
that's all then you go you declare your

00:41:19,670 --> 00:41:26,390
driver structure and you call module ICC

00:41:23,390 --> 00:41:29,960
driver and it registers the driver to

00:41:26,390 --> 00:41:33,530
the receive frame so nothing new

00:41:29,960 --> 00:41:38,300
here the same thing goes for the SDR

00:41:33,530 --> 00:41:41,330
transfers so it's pretty simple

00:41:38,300 --> 00:41:42,830
it looks like the things you've been

00:41:41,330 --> 00:41:45,080
using with ICRC

00:41:42,830 --> 00:41:48,800
so you declare a table of transfers

00:41:45,080 --> 00:41:54,050
whether these are read or write and then

00:41:48,800 --> 00:41:57,050
use some transfers to the device and

00:41:54,050 --> 00:42:00,830
pretty much the same for HDR transfers

00:41:57,050 --> 00:42:05,450
except that now you'll have to specify a

00:42:00,830 --> 00:42:08,660
specific up cub and the mod you want to

00:42:05,450 --> 00:42:11,960
send they want the mod you want to use

00:42:08,660 --> 00:42:15,950
to send this transfer nothing really

00:42:11,960 --> 00:42:20,180
complicated you do idea is a bit more

00:42:15,950 --> 00:42:24,500
complicated so you'll have to first

00:42:20,180 --> 00:42:27,859
declare an ibn Andrew this IBM annular

00:42:24,500 --> 00:42:34,869
is called from a non atomic context so

00:42:27,859 --> 00:42:34,869
you can send a new message in this idea

00:42:35,080 --> 00:42:43,970
when you request an ABI an IDI you will

00:42:38,510 --> 00:42:46,450
have to specify the max payload size so

00:42:43,970 --> 00:42:50,240
normally this is defined in the

00:42:46,450 --> 00:42:52,700
datasheet of the device and then you

00:42:50,240 --> 00:42:57,020
have to define the maximum number of

00:42:52,700 --> 00:43:00,770
slots allocated to this ibi this is

00:42:57,020 --> 00:43:05,210
mainly useful because since you you're

00:43:00,770 --> 00:43:07,970
not only that in intra-atomic context

00:43:05,210 --> 00:43:11,420
and the interrupt context that means

00:43:07,970 --> 00:43:14,150
that you may have several ideas hued in

00:43:11,420 --> 00:43:18,170
the device before the device before they

00:43:14,150 --> 00:43:22,010
work you actually called IBM so if

00:43:18,170 --> 00:43:26,020
you're not using if you're not reserving

00:43:22,010 --> 00:43:29,900
enough slots you might lose some IP eyes

00:43:26,020 --> 00:43:32,839
maybe that's not such a good idea to do

00:43:29,900 --> 00:43:36,410
that but that's what we come Moo came up

00:43:32,839 --> 00:43:38,599
with to to address the problem and then

00:43:36,410 --> 00:43:41,000
once you have requested the ibi is that

00:43:38,599 --> 00:43:42,170
means all resources needed for this ibi

00:43:41,000 --> 00:43:45,589
have been okay

00:43:42,170 --> 00:43:48,230
you can enable the IBI and in your

00:43:45,589 --> 00:43:54,800
removin Larry can disable the IBI and

00:43:48,230 --> 00:44:03,380
free the IPA resources now the master

00:43:54,800 --> 00:44:06,050
controller API so it's the interface

00:44:03,380 --> 00:44:09,109
which you're supposed to implement when

00:44:06,050 --> 00:44:13,760
you want to support to declare a new

00:44:09,109 --> 00:44:16,270
master is not that big it leaves a lot

00:44:13,760 --> 00:44:19,970
of freedom to the controller driver and

00:44:16,270 --> 00:44:23,180
I did that because actually the I only

00:44:19,970 --> 00:44:27,470
worked on one of them I'm not sure

00:44:23,180 --> 00:44:30,140
exactly where which part already come on

00:44:27,470 --> 00:44:33,980
to everyone and which parts are specific

00:44:30,140 --> 00:44:36,740
to the one I worked so instead of adding

00:44:33,980 --> 00:44:40,010
a lot of logic in the in the core right

00:44:36,740 --> 00:44:46,220
now I decided to Pewter a lot of logic

00:44:40,010 --> 00:44:48,170
in the controller driver basically what

00:44:46,220 --> 00:44:51,020
the controller drivers will have to do

00:44:48,170 --> 00:44:57,980
is initialize the bus and initializing

00:44:51,020 --> 00:45:00,140
the bus is quite vague so it will have

00:44:57,980 --> 00:45:02,030
to declare all the devices which are

00:45:00,140 --> 00:45:05,990
statically defined that means all

00:45:02,030 --> 00:45:08,119
ice-crazy devices you also have some ice

00:45:05,990 --> 00:45:09,880
crystal devices which can be statically

00:45:08,119 --> 00:45:13,460
defined so again you will have to

00:45:09,880 --> 00:45:16,430
declare them in controller and then once

00:45:13,460 --> 00:45:19,730
this is done you will start DAA to

00:45:16,430 --> 00:45:23,089
discover all the devices on the bus and

00:45:19,730 --> 00:45:25,339
you will them declare all the devices

00:45:23,089 --> 00:45:29,000
you've discovered on the bus to the

00:45:25,339 --> 00:45:31,460
framework so that's basically what you

00:45:29,000 --> 00:45:34,730
have to do when initial is initializing

00:45:31,460 --> 00:45:38,210
the bus then you will also have to

00:45:34,730 --> 00:45:40,550
provide some methods to sum all kind of

00:45:38,210 --> 00:45:41,150
transfers so you have one for private

00:45:40,550 --> 00:45:44,300
sensors

00:45:41,150 --> 00:45:49,390
it's yarn currents and city securement

00:45:44,300 --> 00:45:52,550
and also one for I specific transfers

00:45:49,390 --> 00:45:54,050
for common you can you have a

00:45:52,550 --> 00:45:58,220
support system

00:45:54,050 --> 00:46:01,520
which which is used to check that the CC

00:45:58,220 --> 00:46:03,560
common is supported because not all CC

00:46:01,520 --> 00:46:06,320
comments are mandatory so your

00:46:03,560 --> 00:46:09,590
controller may is important or not a

00:46:06,320 --> 00:46:13,970
specific common and the important thing

00:46:09,590 --> 00:46:16,580
in here is that all those books are

00:46:13,970 --> 00:46:19,150
working in a synchronous manner that

00:46:16,580 --> 00:46:22,790
means when you call this function a

00:46:19,150 --> 00:46:24,830
yield and this function returns that

00:46:22,790 --> 00:46:28,160
means that the transaction on the bus is

00:46:24,830 --> 00:46:30,590
done and you don't have to wait for a

00:46:28,160 --> 00:46:31,040
callback to be cold or or things like

00:46:30,590 --> 00:46:38,900
that

00:46:31,040 --> 00:46:40,730
everything is synchronous IB is so

00:46:38,900 --> 00:46:44,000
pretty much the same function you add in

00:46:40,730 --> 00:46:45,950
the API in device driver API except that

00:46:44,000 --> 00:46:49,520
here you have to implement them so

00:46:45,950 --> 00:46:52,250
request API bi bi bi Anabella ID ID

00:46:49,520 --> 00:46:55,100
Isabella VI so that's pretty abuse there

00:46:52,250 --> 00:46:57,770
is one more which is air to recycle a

00:46:55,100 --> 00:46:59,360
slot that was used to store a payload of

00:46:57,770 --> 00:47:03,650
an IV and I di

00:46:59,360 --> 00:47:07,880
and yes again one of the important

00:47:03,650 --> 00:47:12,770
design choice we made was to execute ipi

00:47:07,880 --> 00:47:18,730
handlers in non-atomic context so in a

00:47:12,770 --> 00:47:21,050
work you can test this because the other

00:47:18,730 --> 00:47:23,750
transfers are done in secure ins manner

00:47:21,050 --> 00:47:26,330
that means that from the eye burglar you

00:47:23,750 --> 00:47:30,740
are able to stand a new something new on

00:47:26,330 --> 00:47:32,930
the bus still if you can avoid it

00:47:30,740 --> 00:47:35,090
you should avoid it because there is one

00:47:32,930 --> 00:47:37,040
more huppert controller that means that

00:47:35,090 --> 00:47:40,010
if you send something on the bus you

00:47:37,040 --> 00:47:42,980
block every other IP errors maybe we'll

00:47:40,010 --> 00:47:48,830
have to rework that a bit too to make it

00:47:42,980 --> 00:47:51,200
a bit scalable a bit more scalable and

00:47:48,830 --> 00:47:55,160
yeah the idea is lot have been allocated

00:47:51,200 --> 00:47:57,830
a lot of time that means that if the IBI

00:47:55,160 --> 00:48:00,860
device driver is not the queuing the IBI

00:47:57,830 --> 00:48:03,220
fast enough it will lose some of the

00:48:00,860 --> 00:48:03,220
ideas

00:48:05,050 --> 00:48:12,880
adjoin again not a lot of facility and

00:48:09,490 --> 00:48:16,260
the framework because I'm not sure our

00:48:12,880 --> 00:48:19,090
other controllers will under that so

00:48:16,260 --> 00:48:21,280
it's basically an interrupt to you will

00:48:19,090 --> 00:48:23,350
receive from the controller and you will

00:48:21,280 --> 00:48:27,430
have to when you receive that you will

00:48:23,350 --> 00:48:32,500
have to trigger a new DAA so really

00:48:27,430 --> 00:48:36,280
nothing else we can expose the error so

00:48:32,500 --> 00:48:39,310
that's basically all we've done the

00:48:36,280 --> 00:48:42,580
statute is that we have submitted two

00:48:39,310 --> 00:48:45,490
version of the RFC everything that I

00:48:42,580 --> 00:48:49,270
just described in the slides have been

00:48:45,490 --> 00:48:51,610
tested and implemented the only problem

00:48:49,270 --> 00:48:54,580
right now or the the primary we had

00:48:51,610 --> 00:48:57,550
before was that we didn't have any real

00:48:54,580 --> 00:48:59,530
device so we were using a dummy slave

00:48:57,550 --> 00:49:03,550
device which we were more or less

00:48:59,530 --> 00:49:05,100
controlling that then that that was a

00:49:03,550 --> 00:49:07,540
problem

00:49:05,100 --> 00:49:10,650
the next version should have a real

00:49:07,540 --> 00:49:15,730
device driver for a GPIO expander so

00:49:10,650 --> 00:49:19,840
should be able to use all of the IEP I

00:49:15,730 --> 00:49:26,200
have been exposing in the device dot H

00:49:19,840 --> 00:49:30,780
file well that's it not much time for

00:49:26,200 --> 00:49:30,780
questions let's let's go

00:49:33,460 --> 00:49:40,760
sorry so the question is what if we are

00:49:37,640 --> 00:49:44,540
in it what if we have in identical parts

00:49:40,760 --> 00:49:51,730
connected on the same bus right yeah so

00:49:44,540 --> 00:49:51,730
there is an instance ID error I find it

00:49:58,230 --> 00:50:04,349
well there is an instance ID so so you

00:50:00,900 --> 00:50:06,660
can by controlling some some of the pins

00:50:04,349 --> 00:50:08,940
of the device we can assign a specific

00:50:06,660 --> 00:50:11,730
instance ID which will provide a

00:50:08,940 --> 00:50:13,109
different PID which then means that you

00:50:11,730 --> 00:50:15,839
will be assigned a different address

00:50:13,109 --> 00:50:23,010
generic address so that that works

00:50:15,839 --> 00:50:25,410
that's supported yeah so it will likely

00:50:23,010 --> 00:50:29,250
have to be configurable differently in

00:50:25,410 --> 00:50:33,440
our air whether it's with switches or by

00:50:29,250 --> 00:50:33,440
connecting pins to different levels so

00:50:34,640 --> 00:50:39,030
how much sure is the hot plug support

00:50:37,170 --> 00:50:42,390
because that looks very handy for making

00:50:39,030 --> 00:50:44,609
smart peripherals how much sorry Alex

00:50:42,390 --> 00:50:47,099
how mature is a hard plug hot plug

00:50:44,609 --> 00:50:48,390
support how mature is that like um is

00:50:47,099 --> 00:50:51,470
there other devices I can get out there

00:50:48,390 --> 00:50:54,720
for example and embedded I think the

00:50:51,470 --> 00:50:58,349
specification does not say anything

00:50:54,720 --> 00:51:02,220
about how to plug devices physically on

00:50:58,349 --> 00:51:05,880
the bus so that's not define of all now

00:51:02,220 --> 00:51:08,790
for the soft how to generate an

00:51:05,880 --> 00:51:11,760
interrupt you signal and adjoin event

00:51:08,790 --> 00:51:14,760
this is really I think it it's mature

00:51:11,760 --> 00:51:17,339
enough but out you actually plug the

00:51:14,760 --> 00:51:20,520
device and not disturb also devices on

00:51:17,339 --> 00:51:24,050
the bus is not dealt with and in the

00:51:20,520 --> 00:51:24,050
spec unfortunately

00:51:26,950 --> 00:51:33,589
so about that so the mipi group is

00:51:31,400 --> 00:51:37,930
defining the spec right it's totally

00:51:33,589 --> 00:51:37,930
free of licensing and stuff like that

00:51:39,220 --> 00:51:45,289
okay so then my question comes who is

00:51:42,279 --> 00:51:46,849
assigning and defending V IDs and PIDs

00:51:45,289 --> 00:51:49,250
because like that's part of the reason

00:51:46,849 --> 00:51:51,410
you pay in the USB is so that those are

00:51:49,250 --> 00:51:54,200
defined and no one else clobbers over

00:51:51,410 --> 00:51:58,640
your vision but I guess this is maybe

00:51:54,200 --> 00:52:01,940
we'll we will assign to our IDs at least

00:51:58,640 --> 00:52:04,220
okay and then so finally on that about

00:52:01,940 --> 00:52:06,819
the hot plug question so that's not

00:52:04,220 --> 00:52:09,650
defined what triggers that at all so

00:52:06,819 --> 00:52:11,089
like in the case in I squared C you have

00:52:09,650 --> 00:52:13,220
it's very common to have I square C

00:52:11,089 --> 00:52:15,529
muxes and so I'm wondering like in a MUX

00:52:13,220 --> 00:52:17,269
case how do you say okay I've switched

00:52:15,529 --> 00:52:19,880
to the other branch of the MUX I need to

00:52:17,269 --> 00:52:21,980
go hot plug these new devices in again

00:52:19,880 --> 00:52:25,640
it's not specified in a specification so

00:52:21,980 --> 00:52:29,299
so it's up to the device manufacturer to

00:52:25,640 --> 00:52:36,740
decide out you trigger the joint event

00:52:29,299 --> 00:52:38,869
yeah how this compares to USB because

00:52:36,740 --> 00:52:42,140
I'm thinking about you know two data

00:52:38,869 --> 00:52:45,079
lines you have a blog you have device

00:52:42,140 --> 00:52:50,720
recognition it's much slower than USB

00:52:45,079 --> 00:52:53,599
for for sure and it's also that's better

00:52:50,720 --> 00:52:57,980
energy efficiency then and it's ready

00:52:53,599 --> 00:53:01,369
for small and mid devices and it's it's

00:52:57,980 --> 00:53:05,450
about energy saving so it's good

00:53:01,369 --> 00:53:06,740
couldn't be replaced by a USB it's just

00:53:05,450 --> 00:53:08,779
sort of a follow up on that

00:53:06,740 --> 00:53:11,390
are you expecting sort of a common

00:53:08,779 --> 00:53:13,730
device driver for peripherals to start

00:53:11,390 --> 00:53:15,650
coming out it seems like right now with

00:53:13,730 --> 00:53:17,900
this concept drivers you're gonna need

00:53:15,650 --> 00:53:19,789
we're done and drivers being implemented

00:53:17,900 --> 00:53:21,829
for all peripherals to maintain

00:53:19,789 --> 00:53:24,410
backwards compatibility and some of that

00:53:21,829 --> 00:53:26,869
could be alleviated if there are common

00:53:24,410 --> 00:53:29,990
drivers so that means like CDC that you

00:53:26,869 --> 00:53:31,940
find it yeah yeah actually until the

00:53:29,990 --> 00:53:36,470
define a common interface for specific

00:53:31,940 --> 00:53:38,509
kind of device it's not possible so so

00:53:36,470 --> 00:53:39,460
we need to wait for them to standardize

00:53:38,509 --> 00:53:42,880
things

00:53:39,460 --> 00:53:51,550
I can tell if it will even happen it's

00:53:42,880 --> 00:53:54,130
it's not yet decided I think so another

00:53:51,550 --> 00:53:57,970
hot plug question one of the things

00:53:54,130 --> 00:54:00,670
that's caused a lot of hassle for some

00:53:57,970 --> 00:54:04,420
of the other method buses with their hot

00:54:00,670 --> 00:54:05,859
plug support is what happens if you have

00:54:04,420 --> 00:54:07,990
a device you want to put a very low

00:54:05,859 --> 00:54:11,440
power mode by physically removing its

00:54:07,990 --> 00:54:12,430
power then re materializes on the bus

00:54:11,440 --> 00:54:18,040
remunerate s--

00:54:12,430 --> 00:54:20,680
yeah and the the bus core is then got a

00:54:18,040 --> 00:54:23,859
workout that actually this was a device

00:54:20,680 --> 00:54:26,950
already knew about yeah yet aren't

00:54:23,859 --> 00:54:29,559
listening not in the veto of the RFC but

00:54:26,950 --> 00:54:31,780
I'm working on that so I'm working on

00:54:29,559 --> 00:54:34,329
trying to figure out how this is new

00:54:31,780 --> 00:54:36,400
device okay I assigned a new address but

00:54:34,329 --> 00:54:38,290
actually an and you this device so I

00:54:36,400 --> 00:54:40,960
shouldn't create a new wall on us

00:54:38,290 --> 00:54:43,119
instance in Linux and I should instead

00:54:40,960 --> 00:54:46,390
update the address instead of creating a

00:54:43,119 --> 00:54:48,970
new device so that's things we I'm I'm

00:54:46,390 --> 00:54:56,920
working on hopefully it should be

00:54:48,970 --> 00:54:59,490
supported correctly okay thanks one last

00:54:56,920 --> 00:54:59,490
question maybe

00:55:01,040 --> 00:55:07,870
yeah so the question is when do I expect

00:55:03,260 --> 00:55:10,380
to see actual devices ready don't know

00:55:07,870 --> 00:55:16,090
okay thanks thanks a lot

00:55:10,380 --> 00:55:16,090

YouTube URL: https://www.youtube.com/watch?v=WnXvRBxLlGY


