Title: Drive your NAND within Linux - Miquèl Raynal, Bootlin (formerly Free Electrons)
Publication date: 2018-03-13
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	Drive your NAND within Linux - Miquèl Raynal, Bootlin (formerly Free Electrons)

NAND flash chips are almost everywhere, sometimes hidden in eMMCs, sometimes they are just parallel NAND chips under the orders of your favorite NAND controller. Each NAND vendor follows its own rules. Each SoC vendor creates his preferred abstraction for interacting with these chips.

Handling all of that requires some abstraction, and that is currently being enhanced in Linux! A new interface, called exec_op is showing up. It has been designed to match the most diverse situations. It should ease the support of advanced controllers as well as the implementation of vendor-specific NAND flash features.

This talk will start with some basics about NAND memories, especially their weaknesses and how we get rid of them. It will also show how the interaction between NAND chips and controllers has been standardized over the years and how it is planned to drive NAND controllers within Linux. 

About Miquèl Raynal
Miquèl is a kernel and embedded Linux engineer at Bootlin (formerly Free Electrons) since 2017. He acquired a wide low-level software and hardware technical background during his studies at INSA Toulouse (engineering school). His interest for Operating Systems grown over the time until he decided to be part of the Linux kernel community. He recently contributed the -exec_op() interface to the NAND framework and migrated two drivers to it.
Captions: 
	00:00:00,030 --> 00:00:06,540
I'm Miguel welcome everyone I work for

00:00:03,149 --> 00:00:10,139
Boonton which is formerly a free

00:00:06,540 --> 00:00:12,690
electrons I've been quite active

00:00:10,139 --> 00:00:16,320
recently in the non subsystem that's why

00:00:12,690 --> 00:00:18,630
I'm gonna show you today the new

00:00:16,320 --> 00:00:24,090
interface that has been merged recently

00:00:18,630 --> 00:00:26,010
to handle non-flash I live in Toulouse

00:00:24,090 --> 00:00:31,439
in France so please excuse my French

00:00:26,010 --> 00:00:35,250
accent I will try to do my best so I

00:00:31,439 --> 00:00:38,850
decided to start actually I I wanted to

00:00:35,250 --> 00:00:41,280
show you the stack in Linux but while I

00:00:38,850 --> 00:00:43,170
was writing the slides I found it was

00:00:41,280 --> 00:00:45,780
kind of boring to spend an hour on that

00:00:43,170 --> 00:00:48,300
so I decided to add the bigger part

00:00:45,780 --> 00:00:52,289
about the physical aspects of non

00:00:48,300 --> 00:00:57,300
memories but then I will show I will

00:00:52,289 --> 00:01:00,510
explain how none flashes are are linked

00:00:57,300 --> 00:01:05,159
to you associ and how you can control

00:01:00,510 --> 00:01:08,580
them using this interface exocomp so

00:01:05,159 --> 00:01:11,400
before starting I'm not a non-expert I

00:01:08,580 --> 00:01:15,420
will probably simplify aspects about the

00:01:11,400 --> 00:01:18,240
physical part and I will focus on SL

00:01:15,420 --> 00:01:19,560
xenon which is with which which stands

00:01:18,240 --> 00:01:22,560
for a single-level cell

00:01:19,560 --> 00:01:24,600
today there are other technologies MLC

00:01:22,560 --> 00:01:28,049
or Chelsea that can have more than one

00:01:24,600 --> 00:01:35,070
bit memory cell but to simplify things I

00:01:28,049 --> 00:01:38,939
will stick to SLC today so before the

00:01:35,070 --> 00:01:41,310
technical aspects just some commercial

00:01:38,939 --> 00:01:45,180
information nones we have ones designed

00:01:41,310 --> 00:01:48,140
to replace hard disk drives and you can

00:01:45,180 --> 00:01:51,720
find them they are widely spread in

00:01:48,140 --> 00:01:55,950
consumer electronics like USB sticks SSD

00:01:51,720 --> 00:01:59,640
is on SD cards and so on Andheri common

00:01:55,950 --> 00:02:01,799
they come and the different flavours so

00:01:59,640 --> 00:02:04,890
the one I just talked about our

00:02:01,799 --> 00:02:08,220
management you don't see its flash it's

00:02:04,890 --> 00:02:13,010
a non inside you just see it as a way of

00:02:08,220 --> 00:02:19,640
storing data I will speak about

00:02:13,010 --> 00:02:24,170
only also called parallel nuns so let's

00:02:19,640 --> 00:02:28,459
start with the explanation of how non

00:02:24,170 --> 00:02:30,349
memory cell works well I'll start deep

00:02:28,459 --> 00:02:32,599
into the matter with the silicon atom

00:02:30,349 --> 00:02:35,959
you can see here on the screen it's M

00:02:32,599 --> 00:02:39,799
but it has 14 electrons and also 14

00:02:35,959 --> 00:02:42,890
protons the electrons are spread across

00:02:39,799 --> 00:02:45,080
three orbits the external one is called

00:02:42,890 --> 00:02:48,290
the valence shell where are the valence

00:02:45,080 --> 00:02:51,470
electrons each of these four valence

00:02:48,290 --> 00:02:57,410
electrons will bind with another valence

00:02:51,470 --> 00:03:00,230
electron of another atom and for one

00:02:57,410 --> 00:03:04,220
silicon atom will bind with four other

00:03:00,230 --> 00:03:06,410
silicon atoms it makes a crystal the

00:03:04,220 --> 00:03:10,220
crystal is so is electrically neutral

00:03:06,410 --> 00:03:13,880
and you don't have any electricity in it

00:03:10,220 --> 00:03:16,310
unless at least it would be an complete

00:03:13,880 --> 00:03:20,299
insulator at zero Kelvin but in our

00:03:16,310 --> 00:03:22,280
world if for instance light strikes an

00:03:20,299 --> 00:03:24,859
electron on the valence shell it will

00:03:22,280 --> 00:03:27,940
absorb a quantum of energy and jump to

00:03:24,859 --> 00:03:30,590
the upper orbit the conduction band

00:03:27,940 --> 00:03:34,310
there it will drift randomly in the

00:03:30,590 --> 00:03:37,459
matter and if you would apply a voltage

00:03:34,310 --> 00:03:41,329
across the matter it would create u-dub

00:03:37,459 --> 00:03:46,579
electricity so to make this state

00:03:41,329 --> 00:03:49,250
permanent people invented doping doping

00:03:46,579 --> 00:03:54,410
is about adding impurities in the

00:03:49,250 --> 00:03:57,430
silicon crystal I mean if you add other

00:03:54,410 --> 00:04:00,709
atoms than silicon in a pure crystal

00:03:57,430 --> 00:04:02,630
this if these atoms have either one more

00:04:00,709 --> 00:04:06,290
or one less electrons on the valence

00:04:02,630 --> 00:04:09,319
shell you will have either one electron

00:04:06,290 --> 00:04:15,760
that will be free or you will lack an

00:04:09,319 --> 00:04:18,590
electron on the on the binding atoms so

00:04:15,760 --> 00:04:22,400
it's n doping when you have one more

00:04:18,590 --> 00:04:25,760
electron because it's a negative charge

00:04:22,400 --> 00:04:29,780
that moves and P doping for positive

00:04:25,760 --> 00:04:35,050
when you have a hole that means you you

00:04:29,780 --> 00:04:35,050
Adam is only bound to three of the

00:04:35,530 --> 00:04:45,050
silicon atoms and four actually four and

00:04:40,400 --> 00:04:47,900
one of these atoms will have a free

00:04:45,050 --> 00:04:51,770
electron which is which aims to bind

00:04:47,900 --> 00:04:54,890
with another one that cannot if you put

00:04:51,770 --> 00:04:59,380
side by side these two regions and and P

00:04:54,890 --> 00:05:04,510
regions are you create a diode electrons

00:04:59,380 --> 00:05:08,360
close to the junction will jump into the

00:05:04,510 --> 00:05:11,030
P substrate and combine into holes in

00:05:08,360 --> 00:05:16,700
the P substrate close to this Junction

00:05:11,030 --> 00:05:20,390
it makes this area of the the P

00:05:16,700 --> 00:05:23,330
substrate electrically and not not

00:05:20,390 --> 00:05:26,180
natural and same on the other side and

00:05:23,330 --> 00:05:28,460
it creates a small electric field that

00:05:26,180 --> 00:05:33,800
will prevent other electrons to combine

00:05:28,460 --> 00:05:37,940
with other holes a bit further if you

00:05:33,800 --> 00:05:40,640
apply a voltage across the diode well if

00:05:37,940 --> 00:05:43,250
you apply a positive voltage on the on

00:05:40,640 --> 00:05:47,510
the inside electrons will be attracted

00:05:43,250 --> 00:05:49,610
but you won't have any current however

00:05:47,510 --> 00:05:52,430
if you apply a positive voltage on the P

00:05:49,610 --> 00:05:54,020
side the electrons that were close to

00:05:52,430 --> 00:05:57,260
the junction will jump from hole to hole

00:05:54,020 --> 00:05:59,120
until they get out of the sacred freeing

00:05:57,260 --> 00:06:02,210
the holes close to this junction

00:05:59,120 --> 00:06:04,730
junction letting other electrons from

00:06:02,210 --> 00:06:11,180
the n substrate to jump across that

00:06:04,730 --> 00:06:14,440
barrier I'm there you have current so

00:06:11,180 --> 00:06:18,680
this is the basic of the MOSFET the

00:06:14,440 --> 00:06:21,100
transistor which is made of in in the

00:06:18,680 --> 00:06:24,320
center it's a metal oxide semiconductor

00:06:21,100 --> 00:06:27,650
area because you have one leg in which

00:06:24,320 --> 00:06:30,950
is conductive and in sorry an insulator

00:06:27,650 --> 00:06:35,350
which is the oxide the oxide and then

00:06:30,950 --> 00:06:35,350
the P substrate the semiconductor

00:06:37,310 --> 00:06:42,470
if you apply a voltage across the

00:06:39,990 --> 00:06:45,630
external legs you won't have any current

00:06:42,470 --> 00:06:50,540
but if you also apply a positive voltage

00:06:45,630 --> 00:06:54,150
on the gate which is leg in the middle

00:06:50,540 --> 00:06:56,970
positive charges will go on the on the

00:06:54,150 --> 00:07:00,510
gate and will repeal other positive

00:06:56,970 --> 00:07:04,110
charges in the bulk letting a small

00:07:00,510 --> 00:07:08,100
channel letting the electrical the

00:07:04,110 --> 00:07:11,100
electrons from one inside going through

00:07:08,100 --> 00:07:15,750
the other inside jumping over the P

00:07:11,100 --> 00:07:19,050
substrate through a thin channel so this

00:07:15,750 --> 00:07:21,030
is the basic of transistor but we will

00:07:19,050 --> 00:07:23,490
agree that you cannot store data with

00:07:21,030 --> 00:07:26,910
that that's why people added an extra

00:07:23,490 --> 00:07:31,740
floating gate this extra floating gate

00:07:26,910 --> 00:07:36,450
is surrounded by an insulator still the

00:07:31,740 --> 00:07:37,020
same oxide and if you do the same thing

00:07:36,450 --> 00:07:39,390
as before

00:07:37,020 --> 00:07:41,280
I mean applying voltage across the

00:07:39,390 --> 00:07:43,890
external legs and also a positive

00:07:41,280 --> 00:07:45,870
voltage on the gate you will still have

00:07:43,890 --> 00:07:50,669
your thin channel of electrons moving

00:07:45,870 --> 00:07:54,600
from one inside to the other however if

00:07:50,669 --> 00:07:57,590
you have a lot of electrons in the

00:07:54,600 --> 00:08:01,410
floating gate you'll have a big negative

00:07:57,590 --> 00:08:04,260
be a big amount of negative charges that

00:08:01,410 --> 00:08:08,610
will attract the holes from the P

00:08:04,260 --> 00:08:10,620
substrate and kind of create a big

00:08:08,610 --> 00:08:15,960
positive barrier that electrons could

00:08:10,620 --> 00:08:17,760
not jump over anymore and this way you

00:08:15,960 --> 00:08:20,160
actually have a zero because you don't

00:08:17,760 --> 00:08:23,340
have any current anymore through the

00:08:20,160 --> 00:08:26,880
trans through the mosfet through the

00:08:23,340 --> 00:08:29,220
transistor so when there is no current

00:08:26,880 --> 00:08:31,590
we call that a zero and if I go back one

00:08:29,220 --> 00:08:34,200
slide when you have a current that is

00:08:31,590 --> 00:08:41,310
flowing through the the transistor it's

00:08:34,200 --> 00:08:43,860
it's a one so what you have to ask right

00:08:41,310 --> 00:08:45,900
now is okay but the floating gate is

00:08:43,860 --> 00:08:48,450
surrounded by an insulator so how do you

00:08:45,900 --> 00:08:50,520
put charges into the floating gate

00:08:48,450 --> 00:08:51,930
and this is quantum mechanics it's

00:08:50,520 --> 00:08:56,400
called the following ode I'm channeling

00:08:51,930 --> 00:08:59,400
effect it's when you apply a very high

00:08:56,400 --> 00:09:03,900
positive voltage on the gate that will

00:08:59,400 --> 00:09:06,660
attract and help to nail help electrons

00:09:03,900 --> 00:09:10,320
to nails through the oxide layer until

00:09:06,660 --> 00:09:13,770
they get into the floating gate please

00:09:10,320 --> 00:09:16,080
notice that the oxide on the top is a

00:09:13,770 --> 00:09:19,410
bit thicker than the one at the bottom

00:09:16,080 --> 00:09:21,840
so electrons will jump from the

00:09:19,410 --> 00:09:26,240
substrate into the floating gate but not

00:09:21,840 --> 00:09:29,700
from the floating gate to the metal gate

00:09:26,240 --> 00:09:34,890
that's how you program a cell to a zero

00:09:29,700 --> 00:09:37,260
state in the other way around if you

00:09:34,890 --> 00:09:40,860
apply a high negative voltage on the

00:09:37,260 --> 00:09:44,280
gate putting a lot of electrons on the

00:09:40,860 --> 00:09:46,530
gate will repel the electrons that are

00:09:44,280 --> 00:09:49,470
trapped into the floating gate back into

00:09:46,530 --> 00:09:56,340
the substrate and that's how you erase

00:09:49,470 --> 00:09:59,580
the cell so this is a much simpler view

00:09:56,340 --> 00:10:01,650
of this exact same transistor you still

00:09:59,580 --> 00:10:05,640
have the floating gate in the middle if

00:10:01,650 --> 00:10:08,640
I put two cells like that side-by-side I

00:10:05,640 --> 00:10:12,810
should have an NPN then another NPN

00:10:08,640 --> 00:10:15,030
region on my substrate but instead of

00:10:12,810 --> 00:10:18,090
doing that and adding a wire between two

00:10:15,030 --> 00:10:21,810
and regions what what a hardware

00:10:18,090 --> 00:10:24,420
designer did is to only take one P

00:10:21,810 --> 00:10:27,930
substrate and insulate and on dope n

00:10:24,420 --> 00:10:32,610
regions regular at regular intervals so

00:10:27,930 --> 00:10:36,000
that you would layout is much smaller

00:10:32,610 --> 00:10:41,310
and you can have much more cells in this

00:10:36,000 --> 00:10:44,790
on the same silicon area just a side

00:10:41,310 --> 00:10:49,640
note when you have like this two cells

00:10:44,790 --> 00:10:55,140
side by side in series if you want I a

00:10:49,640 --> 00:10:58,770
logic zero on the right side you have to

00:10:55,140 --> 00:11:02,160
apply logic one on both gates so that

00:10:58,770 --> 00:11:06,629
this point would be

00:11:02,160 --> 00:11:08,790
at the ground and this is this makes if

00:11:06,629 --> 00:11:11,399
you put a 1 under one then you get a

00:11:08,790 --> 00:11:13,860
zero this is the non gate right that's

00:11:11,399 --> 00:11:18,810
why we call this kind of memory non

00:11:13,860 --> 00:11:21,149
memory cell so two cells is good but not

00:11:18,810 --> 00:11:25,649
good enough to store actual data so what

00:11:21,149 --> 00:11:30,389
we do is we create strings of memory of

00:11:25,649 --> 00:11:34,649
non memory cells in series of course you

00:11:30,389 --> 00:11:39,410
can go up to that to maybe 64 cells in

00:11:34,649 --> 00:11:44,670
series the only thing the only thing is

00:11:39,410 --> 00:11:48,720
to cross diode you must apply about 0.6

00:11:44,670 --> 00:11:51,209
0.7 volts across it so the more cells

00:11:48,720 --> 00:11:54,180
you put the more higher voltage you will

00:11:51,209 --> 00:11:58,439
need to to make a current passing

00:11:54,180 --> 00:12:02,370
through all the transistors so how do we

00:11:58,439 --> 00:12:06,060
read one bit one cell one bit from one

00:12:02,370 --> 00:12:08,009
from this string just a paying a

00:12:06,060 --> 00:12:09,689
positive voltage on the gate as we've

00:12:08,009 --> 00:12:11,819
done before it's not enough because if

00:12:09,689 --> 00:12:14,160
the other transistors in the same string

00:12:11,819 --> 00:12:17,250
are not passing you won't have any

00:12:14,160 --> 00:12:21,240
current in any way so what we do is

00:12:17,250 --> 00:12:24,959
applying an higher voltage on the other

00:12:21,240 --> 00:12:28,500
gate not that high otherwise you would

00:12:24,959 --> 00:12:31,410
produce the channeling effect but not

00:12:28,500 --> 00:12:36,569
what we want but high enough so that

00:12:31,410 --> 00:12:39,899
these these transistors will be passing

00:12:36,569 --> 00:12:42,689
anyway no matter the if they are charged

00:12:39,899 --> 00:12:47,389
or not in the floating gate and that's

00:12:42,689 --> 00:12:50,579
how you can read one cell from a string

00:12:47,389 --> 00:12:53,790
if you put a lot of cells in parallel

00:12:50,579 --> 00:12:58,500
there you have absolutely no limitations

00:12:53,790 --> 00:13:04,009
on that you get what we call in with our

00:12:58,500 --> 00:13:08,129
terms a block for those who be quite

00:13:04,009 --> 00:13:10,709
used to manage none flashes it's called

00:13:08,129 --> 00:13:13,329
yeah you know the terms blocks on pages

00:13:10,709 --> 00:13:19,589
a page is actually

00:13:13,329 --> 00:13:23,920
a row of of cells connected by their

00:13:19,589 --> 00:13:25,869
body by either gate so when you want to

00:13:23,920 --> 00:13:28,259
select one bit you actually select the

00:13:25,869 --> 00:13:34,619
wall page that's why you can only

00:13:28,259 --> 00:13:34,619
program and read one page at a time I

00:13:36,269 --> 00:13:42,999
lied to you a bit before actually to

00:13:40,569 --> 00:13:45,399
erase the cell you do not apply a high

00:13:42,999 --> 00:13:48,639
negative voltage on the gate because

00:13:45,399 --> 00:13:50,529
it's kind of difficult to creative in

00:13:48,639 --> 00:13:52,929
the middle sistent and we already need a

00:13:50,529 --> 00:13:55,629
high positive voltage so instead we

00:13:52,929 --> 00:13:57,689
apply the high positive voltage on the

00:13:55,629 --> 00:14:00,639
bulk it has the same effect of

00:13:57,689 --> 00:14:06,040
attracting electrons into back into the

00:14:00,639 --> 00:14:08,259
substrate however one the the bulk is

00:14:06,040 --> 00:14:11,889
shared across all the cells in one block

00:14:08,259 --> 00:14:15,819
that's why non memories when you want to

00:14:11,889 --> 00:14:25,360
erase none none none none cells you have

00:14:15,819 --> 00:14:26,470
to do it blocks per block so this is a

00:14:25,360 --> 00:14:31,299
bit to say map

00:14:26,470 --> 00:14:33,249
you cannot program a cell to a one state

00:14:31,299 --> 00:14:36,610
you can only program it to a zero state

00:14:33,249 --> 00:14:38,889
and if you want to erase a cell you have

00:14:36,610 --> 00:14:41,199
to raise the wall block and so you have

00:14:38,889 --> 00:14:46,360
to erase the wall block before writing

00:14:41,199 --> 00:14:49,689
the page inside it you can feel that

00:14:46,360 --> 00:14:53,709
this design is a bit fragile depending

00:14:49,689 --> 00:14:56,649
on the positive levels you choose you'll

00:14:53,709 --> 00:15:01,149
have for an autumn effect which will be

00:14:56,649 --> 00:15:05,049
strong or weak you can have there are

00:15:01,149 --> 00:15:07,480
several flaws in the designs and let me

00:15:05,049 --> 00:15:10,239
explain a few of them so bit flips

00:15:07,480 --> 00:15:14,350
everybody know what it is it's your

00:15:10,239 --> 00:15:16,929
writing your you're writing a bit you

00:15:14,350 --> 00:15:18,639
expect value and when you read it

00:15:16,929 --> 00:15:24,610
actually you don't have the value you

00:15:18,639 --> 00:15:26,560
expected if for instance the cell was

00:15:24,610 --> 00:15:29,589
not fully erased or programmed

00:15:26,560 --> 00:15:33,519
it happens because some of the electrons

00:15:29,589 --> 00:15:36,069
that tunnels through the side won't get

00:15:33,519 --> 00:15:39,550
it to the floating gate and will get

00:15:36,069 --> 00:15:44,199
trapped into the insulator this creates

00:15:39,550 --> 00:15:46,360
a small small negative area that will

00:15:44,199 --> 00:15:49,629
repeal some electrons to tunnels through

00:15:46,360 --> 00:15:54,999
the oxide and will prevent the sale to

00:15:49,629 --> 00:15:58,029
the cell to be programmed there is also

00:15:54,999 --> 00:16:03,759
that our data and retention issue

00:15:58,029 --> 00:16:06,220
it means you write your you you write a

00:16:03,759 --> 00:16:09,249
page you put you on on the side for a

00:16:06,220 --> 00:16:09,879
few months maybe years and when you take

00:16:09,249 --> 00:16:12,189
it back

00:16:09,879 --> 00:16:15,879
you don't read the data you you wrote

00:16:12,189 --> 00:16:18,389
that's because when tunneling some

00:16:15,879 --> 00:16:22,209
electrons collided with the material and

00:16:18,389 --> 00:16:24,670
damaged it so it kind of creates some

00:16:22,209 --> 00:16:28,959
paths between the floating gate on the P

00:16:24,670 --> 00:16:31,540
substrate and that's why with time some

00:16:28,959 --> 00:16:35,079
electrons will get back into the

00:16:31,540 --> 00:16:37,779
substrate and you will lose the charge

00:16:35,079 --> 00:16:42,279
you the charges you put in the floating

00:16:37,779 --> 00:16:44,649
gate unfine aliy obviously read and

00:16:42,279 --> 00:16:47,319
write disturbances you remember the

00:16:44,649 --> 00:16:50,259
string where you have to apply high

00:16:47,319 --> 00:16:54,819
voltages on all the gates to read one

00:16:50,259 --> 00:16:57,779
cell of course channeling is a

00:16:54,819 --> 00:17:01,949
stochastic effect you cannot know how if

00:16:57,779 --> 00:17:06,789
if all the electrons will go in will

00:17:01,949 --> 00:17:08,640
enter the the the floating gates you

00:17:06,789 --> 00:17:13,809
don't want to modify

00:17:08,640 --> 00:17:16,860
so yeah it's you can do this read and

00:17:13,809 --> 00:17:20,110
write write and erase cycles about

00:17:16,860 --> 00:17:25,209
100,000 times for Nestle xenon it's much

00:17:20,110 --> 00:17:30,309
less for mlc non actually and that's all

00:17:25,209 --> 00:17:35,520
for the physical part now you know how

00:17:30,309 --> 00:17:38,230
we know how an on cell work and let's

00:17:35,520 --> 00:17:40,980
think about just the non ship now and

00:17:38,230 --> 00:17:45,510
how you can wire it in you

00:17:40,980 --> 00:17:48,210
in your design you do this for parallel

00:17:45,510 --> 00:17:52,800
nuns of course through the use of the

00:17:48,210 --> 00:17:55,410
non controller the non controller is

00:17:52,800 --> 00:17:58,710
wired to you none chip is wired to you

00:17:55,410 --> 00:18:01,940
to you none controller through an i/o

00:17:58,710 --> 00:18:07,760
bus which is either 8 or 16-bit wide and

00:18:01,940 --> 00:18:12,120
a lot of logic around it around them

00:18:07,760 --> 00:18:15,840
I'll start with the lines at the top the

00:18:12,120 --> 00:18:18,570
chip-enabled line is here to select one

00:18:15,840 --> 00:18:21,060
chip the host the non controller will

00:18:18,570 --> 00:18:24,900
select a chip actually it could select a

00:18:21,060 --> 00:18:30,630
die because you can see die as logical

00:18:24,900 --> 00:18:33,480
non chips in one package but for

00:18:30,630 --> 00:18:37,560
examples let's say there is only one one

00:18:33,480 --> 00:18:40,140
die in our chip and the redeposit pin he

00:18:37,560 --> 00:18:43,140
works in the other way around it tells

00:18:40,140 --> 00:18:46,680
the host that the non chip is ready or

00:18:43,140 --> 00:18:50,580
not and maybe he it is processing some

00:18:46,680 --> 00:18:52,910
some commands and need more time the

00:18:50,580 --> 00:18:58,110
right product line is here to prevent

00:18:52,910 --> 00:19:00,510
any loss of data so the non ship won't

00:18:58,110 --> 00:19:05,880
accept any erased no program operations

00:19:00,510 --> 00:19:10,170
I will go back on the last remaining

00:19:05,880 --> 00:19:14,960
lines just I want to show you the worst

00:19:10,170 --> 00:19:17,330
non protocol it's only three type of

00:19:14,960 --> 00:19:21,150
cycles that can happen on the i/o bus

00:19:17,330 --> 00:19:23,930
the common cycles the address cycles on

00:19:21,150 --> 00:19:27,000
the data cell cycles data can go

00:19:23,930 --> 00:19:30,780
obviously in both ways while addressing

00:19:27,000 --> 00:19:38,280
commands are always sent by the the host

00:19:30,780 --> 00:19:41,400
the non controller that's how we use

00:19:38,280 --> 00:19:44,490
these lines Cle stands for common legend

00:19:41,400 --> 00:19:47,710
Abel it means a command is being sent by

00:19:44,490 --> 00:19:51,150
the host controller as a non controller

00:19:47,710 --> 00:19:53,290
al e stands for address let's enable and

00:19:51,150 --> 00:19:56,830
reasonable right enable the last two

00:19:53,290 --> 00:19:59,680
lines are here to inform who will talk

00:19:56,830 --> 00:20:03,670
on the bus if it's either the non

00:19:59,680 --> 00:20:07,030
controller or the non chip so putting

00:20:03,670 --> 00:20:10,300
together non instructions you get none

00:20:07,030 --> 00:20:13,990
operation to achieve a real goal like

00:20:10,300 --> 00:20:17,800
reading something these are these are

00:20:13,990 --> 00:20:20,890
examples to read Nora let's start with

00:20:17,800 --> 00:20:22,450
the simplest one there is it if you want

00:20:20,890 --> 00:20:26,080
to read up the chip it's just a matter

00:20:22,450 --> 00:20:30,670
of sending a common which is 30 no it's

00:20:26,080 --> 00:20:32,920
a FF sorry and then wait for the non

00:20:30,670 --> 00:20:36,790
ship to be ready again and that's all

00:20:32,920 --> 00:20:39,580
for a bit mum the the read page is a bit

00:20:36,790 --> 00:20:42,400
more complex you'll have to send the

00:20:39,580 --> 00:20:45,070
zero command one common cycle then a few

00:20:42,400 --> 00:20:47,020
address cycles so the first common cycle

00:20:45,070 --> 00:20:49,770
tells the chip okay I want to read

00:20:47,020 --> 00:20:54,130
something I will read the page actually

00:20:49,770 --> 00:20:57,190
then you send it you send it address

00:20:54,130 --> 00:21:01,510
cycles to tell it where you want to read

00:20:57,190 --> 00:21:04,180
the 30 byte the second common cycle is

00:21:01,510 --> 00:21:08,410
here to tell the chip to the chip okay

00:21:04,180 --> 00:21:12,340
now you can go into the actual NAND and

00:21:08,410 --> 00:21:15,430
bring the data into your local cache at

00:21:12,340 --> 00:21:18,520
this moment the chip will assert the

00:21:15,430 --> 00:21:20,710
buzzie pin so you'll have to wait for

00:21:18,520 --> 00:21:23,410
the operation to finish and once this is

00:21:20,710 --> 00:21:26,740
finished the host controller will accept

00:21:23,410 --> 00:21:30,100
the right enable line so the non chip

00:21:26,740 --> 00:21:37,600
will send the data through the bus to

00:21:30,100 --> 00:21:42,600
the non controller these controllers are

00:21:37,600 --> 00:21:45,760
coming to very large there are a few

00:21:42,600 --> 00:21:46,390
many flavours of them some are really

00:21:45,760 --> 00:21:48,760
simple

00:21:46,390 --> 00:21:51,880
now they tend to be more complicated

00:21:48,760 --> 00:21:56,200
more so we get sophisticated the main

00:21:51,880 --> 00:21:57,890
job is to talk to the non chip but more

00:21:56,200 --> 00:22:01,940
and more they embed additional

00:21:57,890 --> 00:22:03,710
logic like error correction code ECC to

00:22:01,940 --> 00:22:06,680
handle directly the Fitbit fritz

00:22:03,710 --> 00:22:11,000
and also some advanced logic to announce

00:22:06,680 --> 00:22:17,080
the truth the throughput so let's see

00:22:11,000 --> 00:22:17,080
now how it's handled in the Linux kernel

00:22:18,400 --> 00:22:28,040
this is the MTD stack memory technology

00:22:23,630 --> 00:22:33,350
devices tacky you probably already heard

00:22:28,040 --> 00:22:34,460
about ubi on ubi FS file system level I

00:22:33,350 --> 00:22:41,210
won't talk about it

00:22:34,460 --> 00:22:43,370
today you'll you your request will go

00:22:41,210 --> 00:22:47,720
through the entity layer which abstracts

00:22:43,370 --> 00:22:54,020
the type of flash I can be no onand spy

00:22:47,720 --> 00:22:57,590
row anything if it comes to none - Nance

00:22:54,020 --> 00:23:00,860
- Perelman's it will go through the non

00:22:57,590 --> 00:23:04,010
call also and then the non call will

00:23:00,860 --> 00:23:08,470
translate the the instructions from the

00:23:04,010 --> 00:23:13,220
entity layer into some understandable

00:23:08,470 --> 00:23:16,010
request to the controller drivers so

00:23:13,220 --> 00:23:22,540
let's see how it was done until recently

00:23:16,010 --> 00:23:26,420
we used a lot of hooks to achieve that

00:23:22,540 --> 00:23:28,490
and who has already been into the

00:23:26,420 --> 00:23:31,730
non-test subsystem here please raise

00:23:28,490 --> 00:23:34,730
your hand just - okay only one person

00:23:31,730 --> 00:23:38,090
two three okay so these are the hooks

00:23:34,730 --> 00:23:45,380
that are usually implemented in the

00:23:38,090 --> 00:23:48,980
non-core non controller drivers comment

00:23:45,380 --> 00:23:52,130
funk is the one in the none layer non

00:23:48,980 --> 00:23:56,480
core layer it was supposed to handle all

00:23:52,130 --> 00:23:59,030
the command and address cycles and it

00:23:56,480 --> 00:24:01,220
calls one hook from the controller

00:23:59,030 --> 00:24:05,780
driver which is called common control

00:24:01,220 --> 00:24:09,410
and send it each time one command or one

00:24:05,780 --> 00:24:09,950
address cycle and that's one other Oaks

00:24:09,410 --> 00:24:12,200
from

00:24:09,950 --> 00:24:14,690
the controller drivers were used like

00:24:12,200 --> 00:24:16,240
wet form of Devorah G to wait for the

00:24:14,690 --> 00:24:19,789
machine on ship to be ready

00:24:16,240 --> 00:24:25,299
also various books written rights byte

00:24:19,789 --> 00:24:25,299
word of birth to retrieve or write data

00:24:25,990 --> 00:24:31,809
but this approach has some limitations

00:24:33,130 --> 00:24:41,120
the non controllers have become more and

00:24:35,539 --> 00:24:43,909
more complex and started old ones could

00:24:41,120 --> 00:24:46,010
just send independent cycles common

00:24:43,909 --> 00:24:50,149
address of data cycles with no no

00:24:46,010 --> 00:24:52,370
problem new ones started to aggregate

00:24:50,149 --> 00:24:56,899
all of that in order to enhance the

00:24:52,370 --> 00:25:02,960
throughput for instance well it's not a

00:24:56,899 --> 00:25:05,720
big issue to these hooks cannot handle

00:25:02,960 --> 00:25:08,630
this kind of operation but that's not an

00:25:05,720 --> 00:25:12,470
issue the the non controller can still

00:25:08,630 --> 00:25:16,789
be driven by these hooks but some of

00:25:12,470 --> 00:25:19,250
controllers started started to not

00:25:16,789 --> 00:25:22,809
implement the possibility to send only

00:25:19,250 --> 00:25:26,809
one command or one address cycle so

00:25:22,809 --> 00:25:31,970
developers started to overload common

00:25:26,809 --> 00:25:34,279
funk from the controller driver and now

00:25:31,970 --> 00:25:40,850
we have plenty of different

00:25:34,279 --> 00:25:44,000
implementations of that hook but a bit

00:25:40,850 --> 00:25:46,010
annoying because first when you have to

00:25:44,000 --> 00:25:48,380
re-implement something that should be in

00:25:46,010 --> 00:25:51,710
the core that was in the core you have a

00:25:48,380 --> 00:25:58,059
lot of situations to handle and people

00:25:51,710 --> 00:26:00,919
just support it they they own use case

00:25:58,059 --> 00:26:03,350
the logic because it changes from one

00:26:00,919 --> 00:26:07,120
driver to the other one cannot be change

00:26:03,350 --> 00:26:11,980
as easily as we would like

00:26:07,120 --> 00:26:14,750
non-windows still add new new operations

00:26:11,980 --> 00:26:18,320
if we trust voyage bazillion which is a

00:26:14,750 --> 00:26:20,360
current non maintainer but we cannot add

00:26:18,320 --> 00:26:23,160
the support of these operations because

00:26:20,360 --> 00:26:25,410
it would be too much trouble handling

00:26:23,160 --> 00:26:31,070
all different implementations of common

00:26:25,410 --> 00:26:33,240
common funk and most importantly

00:26:31,070 --> 00:26:39,090
something which is really really

00:26:33,240 --> 00:26:42,090
dangerous drivers started to predict

00:26:39,090 --> 00:26:44,580
what the next move of the car would be

00:26:42,090 --> 00:26:47,100
because common foam does not provide the

00:26:44,580 --> 00:26:50,010
i/o length you cannot know from common

00:26:47,100 --> 00:26:54,500
funk how much data you will have to read

00:26:50,010 --> 00:26:58,170
all right and people started yeah

00:26:54,500 --> 00:27:03,090
thinking what would be the length of the

00:26:58,170 --> 00:27:05,730
of the data data move it's a clear

00:27:03,090 --> 00:27:08,340
symptom that the non-call did not fit

00:27:05,730 --> 00:27:11,100
anymore the needs I'm pretty sure it fit

00:27:08,340 --> 00:27:14,640
the needs at the very first beginning at

00:27:11,100 --> 00:27:17,480
the very beginning when controllers were

00:27:14,640 --> 00:27:25,200
quite simple but not anymore

00:27:17,480 --> 00:27:30,060
so that's why we introduced X I cap this

00:27:25,200 --> 00:27:34,370
interface is in the non-core and like

00:27:30,060 --> 00:27:38,040
common funk and the other hooks before

00:27:34,370 --> 00:27:43,830
it aims to translate MTD requests into

00:27:38,040 --> 00:27:45,720
non operations we truly believe that it

00:27:43,830 --> 00:27:49,920
will fit most of the non controllers

00:27:45,720 --> 00:27:53,010
available today it has been merging the

00:27:49,920 --> 00:27:56,010
followed 16 kernel and the Marvel non

00:27:53,010 --> 00:28:00,090
controller is already converted the fsnc

00:27:56,010 --> 00:28:06,330
one to some other the really close to be

00:28:00,090 --> 00:28:11,100
or we it's it's on the roadmap so how

00:28:06,330 --> 00:28:12,720
does it work well from the controller

00:28:11,100 --> 00:28:15,780
drive a point of view you will receive

00:28:12,720 --> 00:28:19,080
an array of instructions that makes the

00:28:15,780 --> 00:28:22,830
overall operation that's the difference

00:28:19,080 --> 00:28:26,520
with before your driver will have to

00:28:22,830 --> 00:28:29,760
split the operation into separation if

00:28:26,520 --> 00:28:33,030
needed if it cannot handle the world

00:28:29,760 --> 00:28:35,700
block and if it cannot handle at all the

00:28:33,030 --> 00:28:36,179
operation it will return any row that

00:28:35,700 --> 00:28:40,080
wasn't

00:28:36,179 --> 00:28:44,399
before neither so maybe in the near

00:28:40,080 --> 00:28:46,950
future the non-core could could take

00:28:44,399 --> 00:28:48,869
over on try with another operation to do

00:28:46,950 --> 00:28:51,529
the same thing there are multiple ways

00:28:48,869 --> 00:28:57,059
to do the same thing same things with

00:28:51,529 --> 00:28:59,159
none the protocol so for simple

00:28:57,059 --> 00:29:01,619
controllers just a matter of looking at

00:28:59,159 --> 00:29:03,360
each instruction and executing it one by

00:29:01,619 --> 00:29:08,309
one and that's all but for more complex

00:29:03,360 --> 00:29:12,929
controller we introduced parser the

00:29:08,309 --> 00:29:17,549
parser is here too to make the logic

00:29:12,929 --> 00:29:22,350
much more simple and let the non-core be

00:29:17,549 --> 00:29:25,649
clever not non-drivers and the way to

00:29:22,350 --> 00:29:28,529
implement it is to fill an array of

00:29:25,649 --> 00:29:31,259
supported patterns each pattern is an

00:29:28,529 --> 00:29:36,690
array of instructions known instructions

00:29:31,259 --> 00:29:40,559
and a callback this is a simple example

00:29:36,690 --> 00:29:44,070
of what it could be the first pattern is

00:29:40,559 --> 00:29:46,830
a command and can support a command up

00:29:44,070 --> 00:29:49,889
to five address cycles and up to 1k of

00:29:46,830 --> 00:29:54,240
data move the second one can handle

00:29:49,889 --> 00:29:56,970
either a common cycle and all a weight

00:29:54,240 --> 00:30:03,899
cycle and the third one can only handle

00:29:56,970 --> 00:30:06,889
one K up to 1024 bytes of data so for if

00:30:03,899 --> 00:30:13,499
for instance you want to reset your chip

00:30:06,889 --> 00:30:16,169
with this kind of of driver you will

00:30:13,499 --> 00:30:18,419
give to the non-core to the parser both

00:30:16,169 --> 00:30:23,690
the operations that were given to you by

00:30:18,419 --> 00:30:28,139
the non call and the the passer array

00:30:23,690 --> 00:30:30,570
the patterns you support so that the

00:30:28,139 --> 00:30:33,269
passer will go through all the supported

00:30:30,570 --> 00:30:36,240
patterns find a match and execute the

00:30:33,269 --> 00:30:38,999
callback and that's all and it makes the

00:30:36,240 --> 00:30:43,379
logic from the control driver really

00:30:38,999 --> 00:30:46,019
really simple so in our case the reset

00:30:43,379 --> 00:30:49,590
command could be handled directly by the

00:30:46,019 --> 00:30:51,450
second pattern the

00:30:49,590 --> 00:30:53,370
secondary lady could be handled by the

00:30:51,450 --> 00:30:55,140
first one there is no problem even if

00:30:53,370 --> 00:30:57,750
there is only one address cycle we don't

00:30:55,140 --> 00:31:01,350
care we can handle up to five address

00:30:57,750 --> 00:31:05,539
cycles in this one so it's okay but the

00:31:01,350 --> 00:31:08,370
last one is a bit tricker there is no

00:31:05,539 --> 00:31:11,700
button that will handle directly the

00:31:08,370 --> 00:31:14,820
wall operation so the passer will split

00:31:11,700 --> 00:31:17,039
it into three shanks the first one we'll

00:31:14,820 --> 00:31:20,909
have will be just the common cycle on

00:31:17,039 --> 00:31:24,330
both address cycles and the first

00:31:20,909 --> 00:31:27,270
pattern will handle it then probably the

00:31:24,330 --> 00:31:29,490
second callback will be will be used to

00:31:27,270 --> 00:31:32,309
send just the second common cycle and

00:31:29,490 --> 00:31:35,549
finally you will use the third callback

00:31:32,309 --> 00:31:38,669
to send the data but it will be called

00:31:35,549 --> 00:31:46,110
twice because in this example you can

00:31:38,669 --> 00:31:49,470
only 1k of data at a time so this is how

00:31:46,110 --> 00:31:52,529
exact copies supposed to work that's all

00:31:49,470 --> 00:31:55,980
for this interface but I found

00:31:52,529 --> 00:32:00,029
interesting to give you a bit more at

00:31:55,980 --> 00:32:02,010
least two other two other hooks

00:32:00,029 --> 00:32:06,840
I'll help us that you have to implement

00:32:02,010 --> 00:32:09,270
from you your controller driver so the

00:32:06,840 --> 00:32:12,450
exit cop is one of them but you also

00:32:09,270 --> 00:32:15,899
have the setup data interface which is

00:32:12,450 --> 00:32:18,480
here to change timings from the

00:32:15,899 --> 00:32:20,220
controller side because of course you

00:32:18,480 --> 00:32:23,010
can handle an on-chip at different

00:32:20,220 --> 00:32:25,890
speeds and it's important that both your

00:32:23,010 --> 00:32:28,980
non controller onion on ship will run at

00:32:25,890 --> 00:32:34,020
the same speed and the last one is

00:32:28,980 --> 00:32:37,399
select chip which is a way to select the

00:32:34,020 --> 00:32:40,919
non die actually not the entire chip and

00:32:37,399 --> 00:32:44,010
it's for simple controllers it will be

00:32:40,919 --> 00:32:46,590
just the handling of the the pin that

00:32:44,010 --> 00:32:48,659
selects the chip but you can also maybe

00:32:46,590 --> 00:32:51,720
change the timings if you have multiple

00:32:48,659 --> 00:32:55,730
chips in parallel if you are not using

00:32:51,720 --> 00:32:58,890
the same time means for all the chips

00:32:55,730 --> 00:33:02,490
yeah that's why for the that's all for

00:32:58,890 --> 00:33:05,070
the for the entity stack if some people

00:33:02,490 --> 00:33:08,240
want to help migrate to migrate these

00:33:05,070 --> 00:33:12,030
drivers are welcome

00:33:08,240 --> 00:33:15,809
just a few few chips maybe you can use

00:33:12,030 --> 00:33:19,260
the you should use the userspace utils

00:33:15,809 --> 00:33:21,600
now not the one in the kernel there are

00:33:19,260 --> 00:33:25,770
modules that do the same things but they

00:33:21,600 --> 00:33:30,510
are deep recreated on will might be

00:33:25,770 --> 00:33:32,429
removed quite soon yeah don't do not

00:33:30,510 --> 00:33:35,399
hesitate to read the documentation even

00:33:32,429 --> 00:33:39,390
if there is almost none oh it's really

00:33:35,399 --> 00:33:41,490
really really old so I would suggest you

00:33:39,390 --> 00:33:44,520
instead to contact us on the mailing

00:33:41,490 --> 00:33:46,770
list and please do not forget the non

00:33:44,520 --> 00:33:50,179
maintainer it makes him in a bad mood

00:33:46,770 --> 00:33:53,669
when it has to read the world list and

00:33:50,179 --> 00:33:57,330
that's all if you are more if you enters

00:33:53,669 --> 00:34:01,110
interested in a non framework I suggest

00:33:57,330 --> 00:34:04,919
you to to have a look to the torque of

00:34:01,110 --> 00:34:07,200
Bowie's Brazilian in Berlin in 2016 and

00:34:04,919 --> 00:34:08,970
also at the torque of Arnaud van der

00:34:07,200 --> 00:34:10,800
Kappa which is about the physics of the

00:34:08,970 --> 00:34:15,810
non memories it gives much more in

00:34:10,800 --> 00:34:19,040
detail it was the same year in Bali yeah

00:34:15,810 --> 00:34:19,040
thank you very much for your attention

00:34:19,489 --> 00:34:27,510
[Applause]

00:34:23,419 --> 00:34:29,630
if you have any questions I'd be pleased

00:34:27,510 --> 00:34:29,630
to answer

00:34:49,089 --> 00:34:56,210
what kind of security will be

00:34:51,679 --> 00:34:59,960
implementing the passer we do also check

00:34:56,210 --> 00:35:02,989
in the non-core so both in the passer on

00:34:59,960 --> 00:35:06,849
the the functions that will call you

00:35:02,989 --> 00:35:11,269
functions from the non controller driver

00:35:06,849 --> 00:35:15,140
so you should you shouldn't have to

00:35:11,269 --> 00:35:17,059
worry about all of these arrows from the

00:35:15,140 --> 00:35:20,269
controller driver it has already been

00:35:17,059 --> 00:35:23,839
checked in before in both in the passer

00:35:20,269 --> 00:35:34,339
on in the non read on non functions that

00:35:23,839 --> 00:35:36,700
are in the core supposedly any other

00:35:34,339 --> 00:35:36,700
question

00:35:38,290 --> 00:35:44,459
okay well thank you

00:35:41,110 --> 00:35:44,459

YouTube URL: https://www.youtube.com/watch?v=3PROYAbwCmY


