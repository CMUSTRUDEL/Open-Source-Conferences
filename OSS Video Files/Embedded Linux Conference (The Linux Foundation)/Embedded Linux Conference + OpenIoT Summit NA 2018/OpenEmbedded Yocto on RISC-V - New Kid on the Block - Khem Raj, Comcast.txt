Title: OpenEmbedded Yocto on RISC-V - New Kid on the Block - Khem Raj, Comcast
Publication date: 2018-03-13
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	OpenEmbedded/Yocto on RISC-V - New Kid on the Block - Khem Raj, Comcast

RISC-V a new open source ISA based architecture is rapidly gaining acceptance in embedded space. Several core packages e.g. gcc toolchain, linux kernel, binutils, newlib, qemu has already been ported for risc-v, At this point OpenEmbedded is one of first embedded linux distribution frameworks to support RISC-V architecture. This talk will cover the status of support as the core support has been upstreamed into OpenEmbedded-core, additionally SOC layer meta-riscv is also created which would serve as common layer for all RISC-V based SOCs.

While key infrastructures are being ported to support RISC-V, there are key challenges still there.

This talk would also introduce the status of various other important packages e.g. Qemu, glibc, which are essential for boot strapping a linux distribution on RISC-V and how OpenEmbedded is currently providing the support and gaps needed to be addressed 

About Khem Raj
Working on Comcast's Reference Design Kit for STBs, Gateway and IoT platforms. Working on deploying optimal open source software practices into development and contribution procedures. Previously worked at Juniper where he was responsible to creating and maintaining Linux base operating system for upcoming Junos( Juniper's Network Operating System) based on Yocto project. He is a contributor and maintainer for Core pieces in OpenEmbedded and Yocto Project. Last he spoke at ELC Portland in 2016
Captions: 
	00:00:00,060 --> 00:00:06,629
all right so welcome everyone thanks for

00:00:05,040 --> 00:00:09,000
coming

00:00:06,629 --> 00:00:12,870
you heard about race fight this morning

00:00:09,000 --> 00:00:17,490
from Yin sub and so I'm going to talk

00:00:12,870 --> 00:00:20,960
about the risk 5 for architecture port

00:00:17,490 --> 00:00:25,019
actually on openembedded so where we are

00:00:20,960 --> 00:00:27,150
what we've done and you know where we

00:00:25,019 --> 00:00:28,400
are going and what are things that are

00:00:27,150 --> 00:00:34,320
still pending

00:00:28,400 --> 00:00:39,149
so pretty much introduction a little bit

00:00:34,320 --> 00:00:45,059
on both projects and what works I'll try

00:00:39,149 --> 00:00:48,629
to give a demo if it works and then what

00:00:45,059 --> 00:00:55,289
we are working on right now and what are

00:00:48,629 --> 00:01:04,519
some of the items for future so this 5

00:00:55,289 --> 00:01:08,729
is free is a that started in Berkeley

00:01:04,519 --> 00:01:11,790
there are others like open risk and MIPS

00:01:08,729 --> 00:01:13,530
and all but this fire started off as a

00:01:11,790 --> 00:01:17,670
clean slate

00:01:13,530 --> 00:01:20,700
and it's not called risk V or something

00:01:17,670 --> 00:01:22,259
it's called Wis 5 genealogy goes from

00:01:20,700 --> 00:01:26,790
risk 1 2 3 4

00:01:22,259 --> 00:01:31,170
likewise this is 5 and it's licensed

00:01:26,790 --> 00:01:33,509
under a BSD license and started in 2010

00:01:31,170 --> 00:01:36,990
so there were other architectures that

00:01:33,509 --> 00:01:43,640
were available at the time but they were

00:01:36,990 --> 00:01:47,420
lacking in few things and they were also

00:01:43,640 --> 00:01:51,509
copyrights and other stuff that were

00:01:47,420 --> 00:01:55,680
causing issues back then so did this

00:01:51,509 --> 00:01:58,380
started as a clean slate in 2010 so by

00:01:55,680 --> 00:02:03,119
now there is a foundation risk by

00:01:58,380 --> 00:02:05,060
foundation that manages the activities

00:02:03,119 --> 00:02:12,220
around development and

00:02:05,060 --> 00:02:19,069
the the is a and specs around this five

00:02:12,220 --> 00:02:20,510
they also have a github handle you are

00:02:19,069 --> 00:02:23,450
welcome to go there they have several

00:02:20,510 --> 00:02:26,170
projects and they see a lot of projects

00:02:23,450 --> 00:02:29,930
there that are being ported to risk five

00:02:26,170 --> 00:02:33,319
and then eventually they make upstream

00:02:29,930 --> 00:02:36,709
and you know they still manage them for

00:02:33,319 --> 00:02:39,440
a while but eventually once they are up

00:02:36,709 --> 00:02:41,690
streamed then you see a less and less

00:02:39,440 --> 00:02:45,019
activity on these projects more and more

00:02:41,690 --> 00:02:47,150
activity upstream there are several

00:02:45,019 --> 00:02:51,700
commercial adapters for risk five right

00:02:47,150 --> 00:02:54,650
now it's still in very early stages but

00:02:51,700 --> 00:02:56,900
you've heard of low five boards high

00:02:54,650 --> 00:02:59,690
five volts so there are words that are

00:02:56,900 --> 00:03:06,560
coming out which are based off of risk

00:02:59,690 --> 00:03:08,780
five Yocto and openembedded so it's

00:03:06,560 --> 00:03:11,959
actually an infrastructure to create our

00:03:08,780 --> 00:03:14,799
own distributions it's not one of the

00:03:11,959 --> 00:03:18,500
given distributions that you might know

00:03:14,799 --> 00:03:22,040
you know like we have Fedora Debian and

00:03:18,500 --> 00:03:25,400
others they are distribution with

00:03:22,040 --> 00:03:28,280
policies and things whereas Yocto

00:03:25,400 --> 00:03:31,700
project along users open embedded

00:03:28,280 --> 00:03:33,859
technology to provide that feature for

00:03:31,700 --> 00:03:38,600
you to be able to generate your own

00:03:33,859 --> 00:03:40,910
embedded Linux distribution and Yocto

00:03:38,600 --> 00:03:43,450
project actually is not a single project

00:03:40,910 --> 00:03:47,959
there are several projects underneath it

00:03:43,450 --> 00:03:52,040
with a motive to improve embedded Linux

00:03:47,959 --> 00:03:54,019
development experience so they are

00:03:52,040 --> 00:04:00,829
contributing to several other projects

00:03:54,019 --> 00:04:03,890
under the same umbrella it uses open

00:04:00,829 --> 00:04:07,400
embedded build system as I said and they

00:04:03,890 --> 00:04:12,200
enhance it improve it add new features

00:04:07,400 --> 00:04:14,989
to it open where it gives you a lot of

00:04:12,200 --> 00:04:17,260
flexibility at the cost of some learning

00:04:14,989 --> 00:04:20,890
curve

00:04:17,260 --> 00:04:23,640
and but this is required in embedded

00:04:20,890 --> 00:04:27,240
systems many times you want a

00:04:23,640 --> 00:04:29,770
possibility for you to customize things

00:04:27,240 --> 00:04:31,570
the beauty of this is that it gives you

00:04:29,770 --> 00:04:33,550
a horizontal scale you have the same

00:04:31,570 --> 00:04:37,870
infrastructure that can scale from a

00:04:33,550 --> 00:04:40,570
very small you know a system to a very

00:04:37,870 --> 00:04:43,240
large system large in the sense of

00:04:40,570 --> 00:04:50,140
packages and and features that you want

00:04:43,240 --> 00:04:52,300
to put on the box so right now it

00:04:50,140 --> 00:04:56,650
provides development environment

00:04:52,300 --> 00:04:58,810
workflow tools test is weak so you can

00:04:56,650 --> 00:05:03,300
run other tests for example there is a

00:04:58,810 --> 00:05:08,050
lot of work happening in this area and

00:05:03,300 --> 00:05:10,600
SDKs is another stellar feature which we

00:05:08,050 --> 00:05:14,700
you can distribute your SDKs to others

00:05:10,600 --> 00:05:17,170
to let them do development on top of

00:05:14,700 --> 00:05:21,940
what you would have put together as a

00:05:17,170 --> 00:05:24,100
platform layered architecture is

00:05:21,940 --> 00:05:26,760
actually very powerful because many a

00:05:24,100 --> 00:05:29,230
times you have this monolithic systems

00:05:26,760 --> 00:05:32,500
where you might be needing only a

00:05:29,230 --> 00:05:35,530
handful of packages but you end up you

00:05:32,500 --> 00:05:37,360
know with a big blob of thousands of

00:05:35,530 --> 00:05:42,190
packages even if you don't want them you

00:05:37,360 --> 00:05:45,250
have no big choice and in many cases

00:05:42,190 --> 00:05:47,470
it's fine if they don't interfere with

00:05:45,250 --> 00:05:52,840
your work but most of time that's not

00:05:47,470 --> 00:05:56,200
the case with layered architecture we

00:05:52,840 --> 00:05:58,870
can actually leave out certain pieces

00:05:56,200 --> 00:06:02,950
that we don't need and you can add

00:05:58,870 --> 00:06:06,660
specific pieces that that you need into

00:06:02,950 --> 00:06:09,520
your projects so that gives you more

00:06:06,660 --> 00:06:16,150
targeted packages and leaves out a lot

00:06:09,520 --> 00:06:18,070
of unused code for you so bringing all

00:06:16,150 --> 00:06:21,040
this power of openembedded

00:06:18,070 --> 00:06:24,880
to a new architecture like Chris 5 is

00:06:21,040 --> 00:06:27,430
fun so we gonna go into that and just

00:06:24,880 --> 00:06:29,700
talk about that today so feel free to

00:06:27,430 --> 00:06:33,540
ask questions or comments and if

00:06:29,700 --> 00:06:38,400
you have in between and we'll take it

00:06:33,540 --> 00:06:40,500
there so what we've done we talked about

00:06:38,400 --> 00:06:46,830
layers so we created a layer

00:06:40,500 --> 00:06:49,320
it's called matter is five and this is

00:06:46,830 --> 00:06:53,460
actually architecture layer right now it

00:06:49,320 --> 00:06:55,620
has emulator machine and there might be

00:06:53,460 --> 00:06:58,550
more reference boards added in future

00:06:55,620 --> 00:07:05,130
but right now it only has an emulator

00:06:58,550 --> 00:07:08,970
for a machine and it has additional

00:07:05,130 --> 00:07:13,440
packages that you would you have to kind

00:07:08,970 --> 00:07:17,010
of either fix or tweak to get it working

00:07:13,440 --> 00:07:18,810
on RIS file and if you go there look

00:07:17,010 --> 00:07:24,120
into the layer there aren't very many

00:07:18,810 --> 00:07:28,020
left anymore and I will talk about that

00:07:24,120 --> 00:07:36,510
as we move six months ago it was not so

00:07:28,020 --> 00:07:39,480
so the case so the setup is this is a

00:07:36,510 --> 00:07:42,570
minimal setup I've mentioned here it

00:07:39,480 --> 00:07:44,580
only depends upon the core layer so you

00:07:42,570 --> 00:07:47,340
just check out the core layer and then

00:07:44,580 --> 00:07:49,610
check out there is five layer and then

00:07:47,340 --> 00:07:58,310
you know you set up your environment and

00:07:49,610 --> 00:08:01,380
you are all set after you have set it up

00:07:58,310 --> 00:08:06,380
you select the machine to be Kim you

00:08:01,380 --> 00:08:09,570
miss cui 64 and off you go you can build

00:08:06,380 --> 00:08:15,060
you can start your build so it's just

00:08:09,570 --> 00:08:17,580
these three steps there is only 64 bit

00:08:15,060 --> 00:08:21,330
GME right now 32-bit is not yet

00:08:17,580 --> 00:08:23,490
supported there are some gaps there for

00:08:21,330 --> 00:08:26,670
example gilepsy doesn't work yet so

00:08:23,490 --> 00:08:32,430
there are portions missing as far as

00:08:26,670 --> 00:08:34,110
32-bit port is considered so while

00:08:32,430 --> 00:08:37,349
you're building for first time they

00:08:34,110 --> 00:08:41,710
build might take a little longer so I

00:08:37,349 --> 00:08:44,320
just mentioned that here so

00:08:41,710 --> 00:08:52,300
you can have your lunch coffee will not

00:08:44,320 --> 00:08:56,500
be enough and once you have the image

00:08:52,300 --> 00:08:58,720
built successfully you can do both user

00:08:56,500 --> 00:09:01,810
level user mode networking as well as

00:08:58,720 --> 00:09:05,680
normal tab based networking both of them

00:09:01,810 --> 00:09:10,590
work so openembedded provides

00:09:05,680 --> 00:09:13,360
infrastructure to run TMU and all those

00:09:10,590 --> 00:09:15,820
options that you are required to supply

00:09:13,360 --> 00:09:20,010
are actually very nicely abstracted

00:09:15,820 --> 00:09:23,260
underneath these tools called run key mu

00:09:20,010 --> 00:09:25,480
and it runs in the same environment

00:09:23,260 --> 00:09:27,790
where you build it it uses that

00:09:25,480 --> 00:09:30,340
environment to have to extract out

00:09:27,790 --> 00:09:33,550
information about your architecture your

00:09:30,340 --> 00:09:36,790
machine and and then uses that

00:09:33,550 --> 00:09:38,470
information to search for images in your

00:09:36,790 --> 00:09:41,080
deploy area and then run it so

00:09:38,470 --> 00:09:44,770
essentially from user perspective if you

00:09:41,080 --> 00:09:47,890
just run this command with no graphic

00:09:44,770 --> 00:09:51,510
which means you want a console only

00:09:47,890 --> 00:09:53,440
image and then it comes up with the

00:09:51,510 --> 00:09:57,370
images so you don't have to worry about

00:09:53,440 --> 00:10:00,370
all the options you need to pass yet you

00:09:57,370 --> 00:10:05,080
could modify it if you want to so all

00:10:00,370 --> 00:10:08,440
those are actually parameterised in in

00:10:05,080 --> 00:10:10,420
in the machine configuration file so you

00:10:08,440 --> 00:10:15,250
can change values if you want for

00:10:10,420 --> 00:10:17,290
example the default memory is 256 Meg so

00:10:15,250 --> 00:10:19,660
if you want to make it 2 gig or

00:10:17,290 --> 00:10:22,930
something you can go in the machine that

00:10:19,660 --> 00:10:26,740
config and and change that to whatever

00:10:22,930 --> 00:10:29,940
value you would like to have so if

00:10:26,740 --> 00:10:34,690
you're running in in user mode

00:10:29,940 --> 00:10:38,740
you know the port 22 is forwarded to 2 2

00:10:34,690 --> 00:10:42,340
2 2 on your little host and you can do

00:10:38,740 --> 00:10:47,290
local SSH using that or if you use the

00:10:42,340 --> 00:10:50,020
normal tab based in networking you can

00:10:47,290 --> 00:10:54,370
directly as a search into it using a

00:10:50,020 --> 00:10:59,400
specific address 192 168 7 or 2 volt

00:10:54,370 --> 00:10:59,400
that a bit later

00:11:00,000 --> 00:11:13,089
so pudding status so right now if you

00:11:07,839 --> 00:11:16,750
build it these are the key components

00:11:13,089 --> 00:11:19,420
that I've listed here and then listed

00:11:16,750 --> 00:11:21,820
their status colonel actually we are I'm

00:11:19,420 --> 00:11:24,160
building that from this looks risk V

00:11:21,820 --> 00:11:30,300
port but actually the support is all

00:11:24,160 --> 00:11:35,440
upstream so I haven't yet tried 4.16 rc4

00:11:30,300 --> 00:11:41,320
but it should be buildable so 4.15 is

00:11:35,440 --> 00:11:44,560
when the support was up streamed G Lib C

00:11:41,320 --> 00:11:48,970
is all upstream and in openembedded we

00:11:44,560 --> 00:11:51,310
are using GFC 227 so we carry no patches

00:11:48,970 --> 00:11:55,180
it's just using it from openembedded

00:11:51,310 --> 00:11:57,640
core GCC is same way it is there are no

00:11:55,180 --> 00:12:05,260
patches in the core Benadryl same way

00:11:57,640 --> 00:12:07,810
gdb well this is a little absolute

00:12:05,260 --> 00:12:10,870
information here but yesterday it was

00:12:07,810 --> 00:12:15,339
accepted upstream so this slide is

00:12:10,870 --> 00:12:19,990
little obsolete and it's still using

00:12:15,339 --> 00:12:23,290
this bv needles TMU is again it's using

00:12:19,990 --> 00:12:26,740
this week mu but Kimmy support also got

00:12:23,290 --> 00:12:29,140
accepted last week upstream so the next

00:12:26,740 --> 00:12:35,500
release of Kimmi will have this phi

00:12:29,140 --> 00:12:37,390
support out of box so as you can see the

00:12:35,500 --> 00:12:39,240
tools major tools i mentioned two of

00:12:37,390 --> 00:12:41,890
them are already upstream so basically

00:12:39,240 --> 00:12:44,980
everything that's on that slide is

00:12:41,890 --> 00:12:47,860
upstream except the risk v tools and

00:12:44,980 --> 00:12:51,610
these tools are essentially will mention

00:12:47,860 --> 00:12:54,070
more about those but these tools help to

00:12:51,610 --> 00:12:56,500
launch the kernel so you can think of

00:12:54,070 --> 00:12:59,370
them as you know BSP tools like

00:12:56,500 --> 00:12:59,370
bootloader tools

00:13:02,970 --> 00:13:15,160
so what works so there are several

00:13:08,260 --> 00:13:17,320
reference images in in core and so most

00:13:15,160 --> 00:13:20,110
of the command line or most of the non

00:13:17,320 --> 00:13:23,110
graphic images they are buildable and

00:13:20,110 --> 00:13:27,310
they're they run so core image minimal

00:13:23,110 --> 00:13:30,910
is very small just you know console

00:13:27,310 --> 00:13:33,579
utilities and and library then you have

00:13:30,910 --> 00:13:35,380
the base image which has a lot more like

00:13:33,579 --> 00:13:38,260
networking stack and things like that

00:13:35,380 --> 00:13:40,870
and then there is coal image fulsomely

00:13:38,260 --> 00:13:46,810
line which is essentially a full kind of

00:13:40,870 --> 00:13:51,339
server ish image and on top of that the

00:13:46,810 --> 00:13:53,410
SDKs equivalents of those work too so

00:13:51,339 --> 00:13:55,540
you could generate an SDK for any of

00:13:53,410 --> 00:13:58,779
these three images you can generate an

00:13:55,540 --> 00:14:00,760
extensible SDK out of these images so if

00:13:58,779 --> 00:14:02,920
you are open embedded you have to

00:14:00,760 --> 00:14:08,160
developer you probably know that

00:14:02,920 --> 00:14:11,980
extensible SDK is is new feature in in

00:14:08,160 --> 00:14:15,250
openembedded where you ship the open

00:14:11,980 --> 00:14:17,560
embedded built environment as sdk and

00:14:15,250 --> 00:14:20,920
it's very powerful it's extensible

00:14:17,560 --> 00:14:23,410
because generally SDKs are pretty static

00:14:20,920 --> 00:14:25,750
you give your SDK and suddenly there's a

00:14:23,410 --> 00:14:29,560
dependency somebody needs and so either

00:14:25,750 --> 00:14:32,910
you regenerate the SDK or you have to

00:14:29,560 --> 00:14:35,649
create that dependency in your package

00:14:32,910 --> 00:14:37,630
extensible SDK kind of helps you there

00:14:35,649 --> 00:14:40,990
because you can just add that dependency

00:14:37,630 --> 00:14:48,640
right there and extend their SDK so it's

00:14:40,990 --> 00:14:52,300
very powerful from that aspect so in its

00:14:48,640 --> 00:14:55,839
systems so we have three inert systems

00:14:52,300 --> 00:14:59,140
in openembedded all three work six five

00:14:55,839 --> 00:15:02,550
init and systemd and busybox

00:14:59,140 --> 00:15:07,980
all of those you can pick and choose and

00:15:02,550 --> 00:15:07,980
they all work with with these five

00:15:10,830 --> 00:15:20,620
as I mentioned before you could use

00:15:14,010 --> 00:15:22,960
networking you can run qmu and both user

00:15:20,620 --> 00:15:27,400
mode as well as tap both of them work

00:15:22,960 --> 00:15:32,320
fine so a little bit of booting in kmu

00:15:27,400 --> 00:15:34,090
so the kernel so the way these five

00:15:32,320 --> 00:15:38,590
boots up they have something called

00:15:34,090 --> 00:15:43,350
proxy kernel and what it does is it

00:15:38,590 --> 00:15:45,760
bundles a Berkeley boot loader bbl as

00:15:43,350 --> 00:15:50,710
kernel as a payload into that boot

00:15:45,760 --> 00:15:54,340
loader so what you will see is when we

00:15:50,710 --> 00:15:57,970
run kmu we give bbl as a command line

00:15:54,340 --> 00:16:02,890
tool kernel or the call VBL as our

00:15:57,970 --> 00:16:06,460
kernel command line two key mu the

00:16:02,890 --> 00:16:10,980
reason for that is that the proxy kernel

00:16:06,460 --> 00:16:15,880
basically provides that as a payload to

00:16:10,980 --> 00:16:19,570
bbl so I provided a link if you are

00:16:15,880 --> 00:16:24,130
interested to dig further into the RIS v

00:16:19,570 --> 00:16:27,700
PK recipe how it is grabbing the kernel

00:16:24,130 --> 00:16:29,770
after it's deployed and then generating

00:16:27,700 --> 00:16:37,030
a bbl which is basically your bootable

00:16:29,770 --> 00:16:38,800
kernel in in key mu and the root of s is

00:16:37,030 --> 00:16:42,700
normal normal root of s that you

00:16:38,800 --> 00:16:45,100
generally have for other qme images it's

00:16:42,700 --> 00:16:51,280
exactly same there is nothing special

00:16:45,100 --> 00:16:53,050
special about that so when you boot so

00:16:51,280 --> 00:16:59,620
this is a couple of screenshots I have

00:16:53,050 --> 00:17:02,880
attached they are very blurry but I can

00:16:59,620 --> 00:17:02,880
probably show you

00:17:25,660 --> 00:17:33,540
so here you can see it's it's booted

00:17:28,630 --> 00:17:37,830
right now so if you just launched it

00:17:33,540 --> 00:17:41,140
with no graphics that's what those

00:17:37,830 --> 00:17:43,540
screenshots were showing you and it's

00:17:41,140 --> 00:17:46,900
it's launching the vvl logo at the very

00:17:43,540 --> 00:17:49,990
beginning and then you get to see the

00:17:46,900 --> 00:17:52,630
login screen and you might have observed

00:17:49,990 --> 00:17:56,290
that there are two login screens it's a

00:17:52,630 --> 00:17:59,640
it's a bug in the serial driver that is

00:17:56,290 --> 00:18:03,700
that seemed kind of interfering with

00:17:59,640 --> 00:18:08,650
with the early print kay so that's a

00:18:03,700 --> 00:18:10,570
known problem so we talked about SDKs so

00:18:08,650 --> 00:18:12,940
I thought that I actually generated an

00:18:10,570 --> 00:18:14,560
SDK and I've installed it so while it's

00:18:12,940 --> 00:18:19,090
working I'll just show you that

00:18:14,560 --> 00:18:22,660
and so it's installed here and I've set

00:18:19,090 --> 00:18:27,370
up the environment so if you see you can

00:18:22,660 --> 00:18:29,460
see that right now it's actually showing

00:18:27,370 --> 00:18:34,950
the CC variables and all those from the

00:18:29,460 --> 00:18:40,450
generated SDK and then I have a little

00:18:34,950 --> 00:18:42,610
script here which basically builds a

00:18:40,450 --> 00:18:46,060
hello world and then transfers it over

00:18:42,610 --> 00:18:50,830
to the emulator and then we'll see

00:18:46,060 --> 00:18:54,610
whether it runs so it just copied it

00:18:50,830 --> 00:19:01,540
over and let's see if it is there so you

00:18:54,610 --> 00:19:07,420
can see it and so that basically gives

00:19:01,540 --> 00:19:09,370
you a full cross build environment where

00:19:07,420 --> 00:19:11,980
you can build your apps in a cross

00:19:09,370 --> 00:19:15,460
environment using the SDK and then

00:19:11,980 --> 00:19:23,320
transfer it over s22 emulator and and do

00:19:15,460 --> 00:19:25,630
your work build it over there so now I'm

00:19:23,320 --> 00:19:28,270
going to move on to some of the work in

00:19:25,630 --> 00:19:32,400
progress in other words what currently

00:19:28,270 --> 00:19:37,360
it doesn't work and is being worked on

00:19:32,400 --> 00:19:39,220
so what we currently have is as I

00:19:37,360 --> 00:19:42,760
mentioned earlier graphics

00:19:39,220 --> 00:19:45,130
it doesn't work and as you can see when

00:19:42,760 --> 00:19:47,500
you build one of the graphical images it

00:19:45,130 --> 00:19:50,350
ends up in in building

00:19:47,500 --> 00:19:51,880
GStreamer and then gstreamer actually

00:19:50,350 --> 00:19:54,789
throws this error at you could not

00:19:51,880 --> 00:19:56,740
detect architecture don't know whether

00:19:54,789 --> 00:19:59,650
it supports another nine and aligned

00:19:56,740 --> 00:20:02,020
access please file a bug so clearly

00:19:59,650 --> 00:20:08,789
there is some work to be done in this

00:20:02,020 --> 00:20:12,940
area we haven't yet doubt deep into this

00:20:08,789 --> 00:20:16,630
so we did some patches there is a

00:20:12,940 --> 00:20:20,169
potential issue in in GCC as well where

00:20:16,630 --> 00:20:22,530
when you enable pthread option then

00:20:20,169 --> 00:20:27,909
there is an internal define called -

00:20:22,530 --> 00:20:30,490
reentrant which seems to be missing this

00:20:27,909 --> 00:20:33,490
becomes a big deal when you have other

00:20:30,490 --> 00:20:40,059
tools trying to detect threading support

00:20:33,490 --> 00:20:43,750
and they use this this variable this

00:20:40,059 --> 00:20:45,610
define rather to validate whether you

00:20:43,750 --> 00:20:48,659
know threading support is working on a

00:20:45,610 --> 00:20:52,780
given tool chain and architecture and

00:20:48,659 --> 00:20:57,370
without this it just comes out to be not

00:20:52,780 --> 00:20:59,470
supporting threading so so I think that

00:20:57,370 --> 00:21:01,809
there was some discussion on the s5

00:20:59,470 --> 00:21:04,480
mailing list on that but there hasn't

00:21:01,809 --> 00:21:07,870
been much traction whether you know we

00:21:04,480 --> 00:21:13,799
need to fix it or not so probably we

00:21:07,870 --> 00:21:20,409
need to delve more into it as we move so

00:21:13,799 --> 00:21:23,650
LTT and G again you know when we build

00:21:20,409 --> 00:21:26,530
this development images and larger

00:21:23,650 --> 00:21:29,559
images delta t ng and other profiling

00:21:26,530 --> 00:21:33,370
packages they get included and currently

00:21:29,559 --> 00:21:35,500
alt T and G fails to build cannot build

00:21:33,370 --> 00:21:42,070
another can recognize architecture

00:21:35,500 --> 00:21:46,480
detected so I hope that doesn't remain

00:21:42,070 --> 00:21:50,140
the case for long and GCC sanitizers

00:21:46,480 --> 00:21:52,509
they don't yet built and so that's also

00:21:50,140 --> 00:21:54,999
work in progress probably

00:21:52,509 --> 00:22:06,190
we will have some some support that in

00:21:54,999 --> 00:22:10,149
gc8 order 8.0 so in open Buried auto

00:22:06,190 --> 00:22:13,059
testing doesn't yet work there seems to

00:22:10,149 --> 00:22:19,179
be some issues with how it connects to

00:22:13,059 --> 00:22:20,829
emulator and it seems to be that there

00:22:19,179 --> 00:22:24,879
might be some misunderstanding between

00:22:20,829 --> 00:22:29,619
how the RIS 5 emulator is showing the

00:22:24,879 --> 00:22:33,219
consoles to the Kimmi testing framework

00:22:29,619 --> 00:22:35,349
that's in open limited so I've included

00:22:33,219 --> 00:22:38,919
here if you know any of you are

00:22:35,349 --> 00:22:41,619
interested in trying it out and fixing

00:22:38,919 --> 00:22:44,379
it sending patches then this is how you

00:22:41,619 --> 00:22:47,639
could basically enable your test image

00:22:44,379 --> 00:22:50,499
and then you can reproduce the problem

00:22:47,639 --> 00:22:52,929
this is actually very helpful if you get

00:22:50,499 --> 00:22:55,359
that fixed because then it enables a lot

00:22:52,929 --> 00:22:58,179
of testing run time testing further

00:22:55,359 --> 00:23:03,699
packages on emulator so I know a lot of

00:22:58,179 --> 00:23:11,139
bugs can be can be found and then fixed

00:23:03,699 --> 00:23:13,599
once we get this going so we've

00:23:11,139 --> 00:23:16,079
supported actually all the support that

00:23:13,599 --> 00:23:19,449
is needed in code layer is actually

00:23:16,079 --> 00:23:21,669
submitted upstream all the patches some

00:23:19,449 --> 00:23:24,399
of them are already applied some of them

00:23:21,669 --> 00:23:31,119
are in flight right now and hoping that

00:23:24,399 --> 00:23:33,129
by 2.5 release or Yocto in April 2013 we

00:23:31,119 --> 00:23:36,519
might have all the core pieces that are

00:23:33,129 --> 00:23:39,059
required to build risk 5 and obviously

00:23:36,519 --> 00:23:41,769
you need to have the BSP layers which is

00:23:39,059 --> 00:23:44,409
matter is 5 for now and then maybe

00:23:41,769 --> 00:23:52,869
further aboard specific layers as they

00:23:44,409 --> 00:23:57,759
develop so cross free link we use cross

00:23:52,869 --> 00:23:59,979
free link not only to to support

00:23:57,759 --> 00:24:03,350
accelerated loading that's one feature

00:23:59,979 --> 00:24:06,049
of cross free link but we also use it to

00:24:03,350 --> 00:24:07,760
to help us detect some library

00:24:06,049 --> 00:24:12,380
dependencies during crossbills because

00:24:07,760 --> 00:24:16,910
ldd cannot be used so so we use free

00:24:12,380 --> 00:24:22,370
links our TLD to to do that detection

00:24:16,910 --> 00:24:25,240
and currently what that means is the

00:24:22,370 --> 00:24:29,330
free link has to understand this five

00:24:25,240 --> 00:24:35,030
architecture as a machine for it to work

00:24:29,330 --> 00:24:37,730
even in cross environment so but there's

00:24:35,030 --> 00:24:40,580
a patch the porting patch is already

00:24:37,730 --> 00:24:43,720
submitted upstream for cross link cross

00:24:40,580 --> 00:24:43,720
free link to be included

00:24:44,110 --> 00:24:49,400
then leave atomic ops support is

00:24:47,150 --> 00:24:54,039
actually up streamed already we don't

00:24:49,400 --> 00:24:56,929
have yet a release awfully Gotama cops

00:24:54,039 --> 00:24:59,929
that is being used in Oakland barrel so

00:24:56,929 --> 00:25:03,190
we are actually carrying patches for

00:24:59,929 --> 00:25:05,450
Lieber Tommy cops in matter is five

00:25:03,190 --> 00:25:07,850
whenever the next release happens and

00:25:05,450 --> 00:25:11,150
open embedded upgrades to that release

00:25:07,850 --> 00:25:13,640
we will basically be able to throw away

00:25:11,150 --> 00:25:17,929
these patches and then just move to the

00:25:13,640 --> 00:25:21,440
upstream releases on the same lines

00:25:17,929 --> 00:25:23,860
there are few more libraries which are

00:25:21,440 --> 00:25:28,789
carrying these five support patches

00:25:23,860 --> 00:25:32,179
leave FFI and SPR lib GPG are so these

00:25:28,789 --> 00:25:34,130
those are a few of few actually probably

00:25:32,179 --> 00:25:41,090
the only ones which are currently left

00:25:34,130 --> 00:25:42,500
as far as we call is concerned the good

00:25:41,090 --> 00:25:44,030
thing is they are carrying the local

00:25:42,500 --> 00:25:46,850
patches which are already submitted

00:25:44,030 --> 00:25:48,799
upstream and I'm hoping that they will

00:25:46,850 --> 00:25:52,570
get included in the future releases of

00:25:48,799 --> 00:25:52,570
these packages as well

00:25:55,070 --> 00:26:07,700
so some of the future things for the

00:26:03,910 --> 00:26:09,740
architecture in openembedded if you want

00:26:07,700 --> 00:26:10,820
to make it cover architecture there are

00:26:09,740 --> 00:26:14,840
things that are missing

00:26:10,820 --> 00:26:19,310
for example gdb well it is upstream now

00:26:14,840 --> 00:26:21,620
but likewise muscle support you know

00:26:19,310 --> 00:26:24,200
there are patches already available they

00:26:21,620 --> 00:26:27,080
are being considered for the next

00:26:24,200 --> 00:26:29,870
release of muscle hopefully we'll be

00:26:27,080 --> 00:26:35,600
able to get them up streamed into muscle

00:26:29,870 --> 00:26:39,050
next release golang support it is a core

00:26:35,600 --> 00:26:41,480
infrastructure in openembedded so we

00:26:39,050 --> 00:26:47,030
would basically require golang to work

00:26:41,480 --> 00:26:51,040
as well and we need the Kimmi support

00:26:47,030 --> 00:26:53,300
upstream as well which is already

00:26:51,040 --> 00:26:56,750
accepted upstream so hopefully the next

00:26:53,300 --> 00:27:00,230
release of km you will have you know the

00:26:56,750 --> 00:27:02,470
needed support for is v in upstream as

00:27:00,230 --> 00:27:02,470
well

00:27:08,860 --> 00:27:18,039
so there is a hackathon going on today

00:27:12,190 --> 00:27:21,159
and they are actually working on the the

00:27:18,039 --> 00:27:24,880
sci-fi freedom you 540 soft base board

00:27:21,159 --> 00:27:28,890
and the plan there is that we would like

00:27:24,880 --> 00:27:32,980
to have openembedded support that BSP as

00:27:28,890 --> 00:27:35,970
one of the first you know real boards to

00:27:32,980 --> 00:27:39,549
be supported on openembedded so

00:27:35,970 --> 00:27:41,919
hopefully you know in the hackathon some

00:27:39,549 --> 00:27:44,500
some of this will come out and probably

00:27:41,919 --> 00:27:47,740
will have you patches done for

00:27:44,500 --> 00:27:50,100
supporting that platform directly using

00:27:47,740 --> 00:27:54,250
openembedded

00:27:50,100 --> 00:27:59,230
32-bit risc 5 i talked about it we need

00:27:54,250 --> 00:28:02,980
32-bit jilebi support and I guess the

00:27:59,230 --> 00:28:06,429
other other major tools like GCC and

00:28:02,980 --> 00:28:09,039
everything they do have 32-bit support

00:28:06,429 --> 00:28:11,350
already in there so probably once we

00:28:09,039 --> 00:28:14,320
have 32-bit support in G Lib C and

00:28:11,350 --> 00:28:18,429
muscle maybe either of those or both of

00:28:14,320 --> 00:28:23,049
them even better then we will be able to

00:28:18,429 --> 00:28:31,659
support 32-bit user space as well along

00:28:23,049 --> 00:28:34,330
with this one so there are a few risk 5

00:28:31,659 --> 00:28:39,730
resources if you are interested to work

00:28:34,330 --> 00:28:42,370
on these 5 they there is a IRC channel

00:28:39,730 --> 00:28:44,529
which is pretty active on freenode so

00:28:42,370 --> 00:28:48,419
hop on free feel free to hop on to that

00:28:44,529 --> 00:28:52,149
and ask questions if you have any and

00:28:48,419 --> 00:28:55,419
there are several repositories on github

00:28:52,149 --> 00:28:57,820
on risks we handle that are very

00:28:55,419 --> 00:29:01,059
interesting and if you are interested in

00:28:57,820 --> 00:29:04,269
contributing to some of those then you

00:29:01,059 --> 00:29:07,950
are welcome and there are mailing lists

00:29:04,269 --> 00:29:10,929
they are not very high volume right now

00:29:07,950 --> 00:29:14,669
but one of them would be interesting is

00:29:10,929 --> 00:29:19,330
the SW dev for example that in a lot of

00:29:14,669 --> 00:29:23,590
software issues are being discussed and

00:29:19,330 --> 00:29:25,300
questions and answers so it's it's in

00:29:23,590 --> 00:29:27,970
very early stages it's the time where

00:29:25,300 --> 00:29:31,080
you can make contribution to you know

00:29:27,970 --> 00:29:34,600
the the ecosystem how they define the

00:29:31,080 --> 00:29:36,930
various building blocks so it's very

00:29:34,600 --> 00:29:40,150
good time if you want to influence that

00:29:36,930 --> 00:29:43,960
to go there and participate in in those

00:29:40,150 --> 00:29:46,900
discussions about you know various

00:29:43,960 --> 00:29:49,990
things like how directly structure

00:29:46,900 --> 00:29:52,300
should look like or other pieces you

00:29:49,990 --> 00:29:55,420
know how the multi-leaf should work or

00:29:52,300 --> 00:30:00,100
should it work at all and those kind of

00:29:55,420 --> 00:30:02,890
questions are being discussed if you are

00:30:00,100 --> 00:30:05,560
interested in Yocto project resources

00:30:02,890 --> 00:30:08,640
finding out more about it listed few

00:30:05,560 --> 00:30:11,880
links here to the git repositories for

00:30:08,640 --> 00:30:15,790
opening buried and Yocto project and

00:30:11,880 --> 00:30:18,130
also link to the main website so there's

00:30:15,790 --> 00:30:21,570
a new newly launched website which

00:30:18,130 --> 00:30:25,300
probably is very informative and now and

00:30:21,570 --> 00:30:28,720
you can also look into openembedded wiki

00:30:25,300 --> 00:30:34,000
or there are IFC channels as well Yocto

00:30:28,720 --> 00:30:36,400
and we handles on freenode and mailing

00:30:34,000 --> 00:30:41,320
lists if you're new feel free to

00:30:36,400 --> 00:30:43,780
contribute to openembedded or to any

00:30:41,320 --> 00:30:44,640
other layers that are on top of

00:30:43,780 --> 00:30:51,940
openembedded

00:30:44,640 --> 00:30:54,160
for putting at least five so I think I'm

00:30:51,940 --> 00:30:59,040
open for questions now thank you for

00:30:54,160 --> 00:30:59,040
listening patiently yes sir

00:31:06,640 --> 00:31:15,460
okay so I think the question is that you

00:31:10,870 --> 00:31:22,630
know people have wireless five right so

00:31:15,460 --> 00:31:26,830
I think the if you look at software

00:31:22,630 --> 00:31:30,130
right in past 20 years or more how it

00:31:26,830 --> 00:31:32,470
has become so prevalent so today you are

00:31:30,130 --> 00:31:33,309
talking continuous delivery continuous

00:31:32,470 --> 00:31:35,290
integration

00:31:33,309 --> 00:31:37,450
you know you commit the code and you

00:31:35,290 --> 00:31:40,630
want to see it in next hour deployed

00:31:37,450 --> 00:31:44,049
right there are projects like that so it

00:31:40,630 --> 00:31:47,770
has achieved that level by becoming

00:31:44,049 --> 00:31:49,750
mature not and all this actually

00:31:47,770 --> 00:31:52,419
involves a lot of open source software

00:31:49,750 --> 00:31:54,760
that goes underneath it right

00:31:52,419 --> 00:31:59,470
so what RIS five is trying to do is it's

00:31:54,760 --> 00:32:01,480
trying to give you an open eye assay if

00:31:59,470 --> 00:32:05,730
you are a hardware developer who are

00:32:01,480 --> 00:32:09,549
developing some IP and and then tools

00:32:05,730 --> 00:32:13,419
that you can then build on top of it so

00:32:09,549 --> 00:32:16,090
you are you're not licensing there are

00:32:13,419 --> 00:32:19,150
no need for that you can pick the I say

00:32:16,090 --> 00:32:23,260
add your IP on top and then build a

00:32:19,150 --> 00:32:25,750
custom chip right on top of that the

00:32:23,260 --> 00:32:28,559
tooling that's being added that is

00:32:25,750 --> 00:32:33,780
actually very powerful where you can

00:32:28,559 --> 00:32:39,220
design a custom chip in a very fast time

00:32:33,780 --> 00:32:41,890
turnaround time so in this you know IOT

00:32:39,220 --> 00:32:44,950
world where all applications will be

00:32:41,890 --> 00:32:46,990
different I believe that you can't solve

00:32:44,950 --> 00:32:49,840
everything in software you shouldn't

00:32:46,990 --> 00:32:52,690
write many of those are you might want

00:32:49,840 --> 00:32:55,600
to have custom hardware doing specific

00:32:52,690 --> 00:33:00,520
things if you can have an infrastructure

00:32:55,600 --> 00:33:04,299
that can let you make a system within

00:33:00,520 --> 00:33:05,490
the costs a hardware systems I'm sure

00:33:04,299 --> 00:33:08,080
you would do it

00:33:05,490 --> 00:33:10,360
similarly with software what you're

00:33:08,080 --> 00:33:13,990
doing with software your cost of you

00:33:10,360 --> 00:33:17,650
know free spinning and then changing are

00:33:13,990 --> 00:33:20,169
lower so it is fine it could be

00:33:17,650 --> 00:33:23,679
something else right as

00:33:20,169 --> 00:33:27,220
long as it is in open is a so respite

00:33:23,679 --> 00:33:29,529
happens to be an open is a right so that

00:33:27,220 --> 00:33:32,169
is why it is being picked right now so

00:33:29,529 --> 00:33:35,169
it's not that it has anything specific

00:33:32,169 --> 00:33:37,989
obviously it has features that you you

00:33:35,169 --> 00:33:39,759
want to have that we're lacking in the

00:33:37,989 --> 00:33:41,830
you know other open architectures it's

00:33:39,759 --> 00:33:44,109
not the first one as I mentioned open

00:33:41,830 --> 00:33:46,869
risk is there like that was already

00:33:44,109 --> 00:33:49,359
available but it's missing certain

00:33:46,869 --> 00:33:51,369
pieces like you know I Triple E 7 5 8

00:33:49,359 --> 00:33:53,919
implementation is not there right so

00:33:51,369 --> 00:33:59,169
there are the compressed instruction

00:33:53,919 --> 00:34:01,389
sets are not there so so they they what

00:33:59,169 --> 00:34:05,259
it is trying to do is provide you a a

00:34:01,389 --> 00:34:09,700
modern architecture in a more with open

00:34:05,259 --> 00:34:12,669
source is a so anybody who is trying to

00:34:09,700 --> 00:34:15,040
invent or innovate on top of using

00:34:12,669 --> 00:34:20,849
hardware IP they have a little easier

00:34:15,040 --> 00:34:20,849
for them thank you yeah

00:34:42,190 --> 00:34:46,640
yes so I think the question is if you

00:34:44,720 --> 00:34:50,080
customize then what are the challenges

00:34:46,640 --> 00:34:52,850
of customization on software so I think

00:34:50,080 --> 00:34:57,020
there it is challenging if you change a

00:34:52,850 --> 00:35:00,380
bi for example right so and I'm I'm

00:34:57,020 --> 00:35:03,890
encouraged by seeing these five like

00:35:00,380 --> 00:35:06,470
foundation take this and define it right

00:35:03,890 --> 00:35:09,650
so they are adding definitions as to how

00:35:06,470 --> 00:35:12,440
the ABI should look like and the idea

00:35:09,650 --> 00:35:15,440
that we shouldn't be breaking ABI you

00:35:12,440 --> 00:35:18,590
know so basically having a system where

00:35:15,440 --> 00:35:20,630
yes you added more IP but from software

00:35:18,590 --> 00:35:23,510
aspect you may not want to add that as

00:35:20,630 --> 00:35:25,370
to your you know your your basically

00:35:23,510 --> 00:35:26,930
your standard interface you still might

00:35:25,370 --> 00:35:28,580
have extensions that you might want to

00:35:26,930 --> 00:35:31,460
add to compiler and things like that to

00:35:28,580 --> 00:35:34,120
take advantage of that but it will not

00:35:31,460 --> 00:35:36,770
break your software say if you are

00:35:34,120 --> 00:35:38,420
generating without your customizations

00:35:36,770 --> 00:35:41,300
that software will still run on your

00:35:38,420 --> 00:35:44,180
system but if you customized it and you

00:35:41,300 --> 00:35:47,270
know you want to run that on the older

00:35:44,180 --> 00:35:49,910
hardware or you know the non custom

00:35:47,270 --> 00:35:52,180
hardware that might not work but if you

00:35:49,910 --> 00:35:55,720
recompile it it might work

00:35:52,180 --> 00:35:55,720
thank you yeah

00:36:33,430 --> 00:36:40,780
right

00:36:35,050 --> 00:36:40,780
yeah yeah

00:36:41,710 --> 00:36:44,710
yes

00:36:55,750 --> 00:37:01,280
right so again it's an extension to the

00:36:58,910 --> 00:37:03,860
question that previously we were

00:37:01,280 --> 00:37:06,050
discussing actually there are actually

00:37:03,860 --> 00:37:09,080
four of variants that are currently

00:37:06,050 --> 00:37:11,450
allowed if you look in there right so in

00:37:09,080 --> 00:37:14,060
a sense there are four a B is if you

00:37:11,450 --> 00:37:17,060
consider map it to MIPS there were much

00:37:14,060 --> 00:37:19,970
more right so the four ABI is are pretty

00:37:17,060 --> 00:37:22,460
much set in the tools and also in the

00:37:19,970 --> 00:37:25,000
kernel so as long as you remain within

00:37:22,460 --> 00:37:27,500
the bounds of those four a B is right

00:37:25,000 --> 00:37:30,650
that is the intention to go forward

00:37:27,500 --> 00:37:32,570
right and any extensions you might have

00:37:30,650 --> 00:37:35,060
are extensions on top of those

00:37:32,570 --> 00:37:38,810
they should not be breaking the existing

00:37:35,060 --> 00:37:42,110
a B is that are in there so how you add

00:37:38,810 --> 00:37:44,990
those support into your tools for

00:37:42,110 --> 00:37:47,450
example you know you are not going to

00:37:44,990 --> 00:37:50,150
submit a passing to GCC saying that okay

00:37:47,450 --> 00:37:52,130
let's change vectorizer to use my fancy

00:37:50,150 --> 00:37:54,260
extension that's not that's where that's

00:37:52,130 --> 00:37:56,300
what I'm meaning here that the

00:37:54,260 --> 00:37:57,950
fundamental instruction set still remain

00:37:56,300 --> 00:38:00,830
same that the compiler uses to generate

00:37:57,950 --> 00:38:03,830
the code you might have additional

00:38:00,830 --> 00:38:08,210
instructions that you want to use for

00:38:03,830 --> 00:38:11,090
those specific extended profiles but

00:38:08,210 --> 00:38:11,600
fundamentally if you were to build for

00:38:11,090 --> 00:38:14,780
sale

00:38:11,600 --> 00:38:17,210
q me RQ is five he can take that same

00:38:14,780 --> 00:38:20,869
binary and run it on your custom chip

00:38:17,210 --> 00:38:22,940
and it will work right so you are able

00:38:20,869 --> 00:38:27,020
to reuse a lot of source code when you

00:38:22,940 --> 00:38:28,990
are customizing a lot of the programs

00:38:27,020 --> 00:38:31,850
that are already available to you are

00:38:28,990 --> 00:38:33,470
are reusable from that sense so it's

00:38:31,850 --> 00:38:37,760
more of a you're building on top rather

00:38:33,470 --> 00:38:40,420
not forking on the side and changing the

00:38:37,760 --> 00:38:40,420
compatibility

00:38:45,210 --> 00:38:53,279
yes yes correct so I think you should

00:38:49,470 --> 00:38:55,170
basically be able to I mean there will

00:38:53,279 --> 00:38:57,180
be AM tunes and all those things you

00:38:55,170 --> 00:38:59,730
know so you want to take advantage of

00:38:57,180 --> 00:39:01,529
instruction sets so GCC will have white

00:38:59,730 --> 00:39:03,539
lines and all those optimizations which

00:39:01,529 --> 00:39:06,599
actually currently don't exist as much

00:39:03,539 --> 00:39:07,559
so you could choose those depending upon

00:39:06,599 --> 00:39:08,970
what is your fundamental

00:39:07,559 --> 00:39:13,410
microarchitecture that you are

00:39:08,970 --> 00:39:17,430
customizing on top of so so I hope that

00:39:13,410 --> 00:39:18,930
that you know e weather if you ask me

00:39:17,430 --> 00:39:21,750
whether you can fork it yes you are

00:39:18,930 --> 00:39:23,640
allowed to write so nobody is stopping

00:39:21,750 --> 00:39:29,730
you from doing that but that is not the

00:39:23,640 --> 00:39:31,890
intention to so the fundamental support

00:39:29,730 --> 00:39:34,020
that went into Linux for example defines

00:39:31,890 --> 00:39:36,690
the Linux API now right

00:39:34,020 --> 00:39:38,339
so that's your contract for future there

00:39:36,690 --> 00:39:41,250
are no new additions that are going to

00:39:38,339 --> 00:39:43,250
come without you know being discussed in

00:39:41,250 --> 00:39:48,930
the community and being agreed upon

00:39:43,250 --> 00:39:51,630
right so it wasn't the case with MIPS

00:39:48,930 --> 00:39:53,910
right for example people submitted their

00:39:51,630 --> 00:39:56,450
own ports and they did all bunch of

00:39:53,910 --> 00:39:56,450
stuff in there

00:40:26,799 --> 00:40:35,779
yeah yes yes I think that's that's a

00:40:33,079 --> 00:40:37,519
great idea I mean the thing is as as I'm

00:40:35,779 --> 00:40:40,670
saying here you know there aren't very

00:40:37,519 --> 00:40:43,339
many variants available for that to kind

00:40:40,670 --> 00:40:46,249
of cause a pain right now but something

00:40:43,339 --> 00:40:48,380
of that order is probably on the cards

00:40:46,249 --> 00:40:52,460
right when somebody comes up with a real

00:40:48,380 --> 00:40:55,519
chip that kind of have wide acceptance

00:40:52,460 --> 00:40:56,989
and has few additional things that you

00:40:55,519 --> 00:40:59,509
want to consider and then you have an

00:40:56,989 --> 00:41:01,309
array of machines to support and all

00:40:59,509 --> 00:41:03,920
those tools you probably might have

00:41:01,309 --> 00:41:08,059
these plugins or extensions that plug in

00:41:03,920 --> 00:41:14,019
into those tools so it's it's pretty

00:41:08,059 --> 00:41:14,019
much on the cards at that point yes

00:41:16,950 --> 00:41:24,090
I can't speak to that because you know I

00:41:21,810 --> 00:41:27,800
don't work for a company that implements

00:41:24,090 --> 00:41:34,640
it so even if they have I would not know

00:41:27,800 --> 00:41:34,640
yeah I am the open source developer yes

00:41:45,290 --> 00:41:51,150
right yeah so I think the question is

00:41:48,300 --> 00:41:52,320
whether bbl is the only bootloader or

00:41:51,150 --> 00:41:54,420
you know so

00:41:52,320 --> 00:41:57,600
bbl is one of the boot loaders right now

00:41:54,420 --> 00:42:00,240
so it is used to bootstrap actually FPGA

00:41:57,600 --> 00:42:03,600
and things like that but there is work

00:42:00,240 --> 00:42:05,730
happening on euphy and work happening on

00:42:03,600 --> 00:42:07,650
you boot and actually you know you are

00:42:05,730 --> 00:42:09,780
welcome to contribute to your boot a lot

00:42:07,650 --> 00:42:12,480
so there's a hackathon going on and I

00:42:09,780 --> 00:42:13,860
think you know if you step up there you

00:42:12,480 --> 00:42:16,140
know they would be happy to kind of

00:42:13,860 --> 00:42:18,330
brief you on what they are doing in

00:42:16,140 --> 00:42:21,180
terms of boot loaders but certainly it's

00:42:18,330 --> 00:42:23,460
not tied to those boot loaders those are

00:42:21,180 --> 00:42:24,930
just ones that are available the reason

00:42:23,460 --> 00:42:28,080
for that is that there is a spike

00:42:24,930 --> 00:42:31,260
simulator framework from Berkeley that

00:42:28,080 --> 00:42:33,900
was used before the you know key mu and

00:42:31,260 --> 00:42:36,780
all this came along and the way to

00:42:33,900 --> 00:42:44,010
bootstrap the system was you know using

00:42:36,780 --> 00:42:46,460
VBA so that's just here so more

00:42:44,010 --> 00:42:46,460
questions

00:42:54,800 --> 00:43:00,510
yes so I think there is a talk whether

00:42:57,810 --> 00:43:04,580
this will be taken up by a race five

00:43:00,510 --> 00:43:06,060
foundation so they might maintain it

00:43:04,580 --> 00:43:08,160
don't know yet

00:43:06,060 --> 00:43:09,750
I think it remains to be seen hopefully

00:43:08,160 --> 00:43:10,200
that you know it will find a different

00:43:09,750 --> 00:43:12,360
place

00:43:10,200 --> 00:43:15,690
it's just seated there right now

00:43:12,360 --> 00:43:17,580
eventually idea is that you know as I

00:43:15,690 --> 00:43:19,260
talked about making it fly first-class

00:43:17,580 --> 00:43:22,320
architecture and openembedded we might

00:43:19,260 --> 00:43:25,830
not need it per se you know it might

00:43:22,320 --> 00:43:34,790
just be supported out of box so but yeah

00:43:25,830 --> 00:43:34,790
good question so more questions comments

00:43:37,010 --> 00:43:44,910
okay so I hope you enjoyed the talk and

00:43:40,500 --> 00:43:47,370
you know you go home and check out and

00:43:44,910 --> 00:43:50,190
you know I'm expecting patches from you

00:43:47,370 --> 00:43:56,260
on my github handle thank you very much

00:43:50,190 --> 00:43:56,260

YouTube URL: https://www.youtube.com/watch?v=TdsmjqWJmfc


