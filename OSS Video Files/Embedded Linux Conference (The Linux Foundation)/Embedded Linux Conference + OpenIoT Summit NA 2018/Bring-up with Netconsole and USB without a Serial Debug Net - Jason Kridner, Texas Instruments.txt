Title: Bring-up with Netconsole and USB without a Serial Debug Net - Jason Kridner, Texas Instruments
Publication date: 2018-03-13
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2018
Description: 
	Bring-up with Netconsole and USB without a Serial Debug Net - Jason Kridner, Texas Instruments and BeagleBoard.org Foundation

 A serial debug console and even JTAG are often assumed for new board bring-up. This presentation will illustrate opportunities for bringing up some designs with neither a serial UART interface or JTAG when doing new bootloader and kernel development. This will include usage of Buildroot to do a complete build management. Utilization of bootloader provided debug resources to the kernel, such as EFI, will also be explored. Demonstration and reproduction materials will be provided on PocketBeagle boards using only a USB connection. 

About Jason Kridner
Jason Kridner is a software architecture manager for embedded processors at Texas Instruments Incorporated (TI). A 25-year veteran of TI, Kridner is also a co-founder of the BeagleBoard.org Foundation, maintainer of open-source development tools such as BeagleBoard, -xM, -X15, BeagleBone, Black, BeagleBone Blue and the new PocketBeagle, a Linux-based open-source USB-key-fob computer. Kridner has previously engaged the open-source community at ELC, Collaboration Summit, Android Builders, OSCON, CES and others.
Captions: 
	00:00:00,030 --> 00:00:08,280
hi I'm Jason cried nur I am a employee

00:00:04,740 --> 00:00:12,320
of Texas Instruments been there a fair

00:00:08,280 --> 00:00:14,849
amount of time but about ten years ago

00:00:12,320 --> 00:00:18,690
started up this project called be

00:00:14,849 --> 00:00:20,609
gleborg later to become a non-profit

00:00:18,690 --> 00:00:24,449
separate entity the BeagleBoard org

00:00:20,609 --> 00:00:26,820
foundation of which you're you know we

00:00:24,449 --> 00:00:29,160
have it's a non-profit foundation which

00:00:26,820 --> 00:00:30,510
we have five board members and then you

00:00:29,160 --> 00:00:31,560
know paid executive director and then

00:00:30,510 --> 00:00:33,750
everybody else's you know kind of

00:00:31,560 --> 00:00:36,120
contract jobs here and there you're

00:00:33,750 --> 00:00:38,370
fortunate enough that we have a quorum

00:00:36,120 --> 00:00:40,559
in here today we have two other board

00:00:38,370 --> 00:00:43,170
members so I'm the only board member

00:00:40,559 --> 00:00:44,579
that works for forty I drew works for

00:00:43,170 --> 00:00:47,870
OSH Park just some contract work for

00:00:44,579 --> 00:00:50,610
Adafruit Roberts full-time at digi-key

00:00:47,870 --> 00:00:52,890
other two guys are professors and didn't

00:00:50,610 --> 00:00:55,800
travel to abetted likes conference so

00:00:52,890 --> 00:00:58,320
ones at Rose home and the other ones was

00:00:55,800 --> 00:00:59,760
at Brown and MIT Moe's a professor at

00:00:58,320 --> 00:01:01,350
MIT most recently I think he's might

00:00:59,760 --> 00:01:03,329
still be there

00:01:01,350 --> 00:01:05,189
but he has a new kids also so that's um

00:01:03,329 --> 00:01:08,040
keeping his luck busy so that's that's

00:01:05,189 --> 00:01:10,680
the the structure of BeagleBoard but I'm

00:01:08,040 --> 00:01:15,180
still an employee of Ti but BeagleBoard

00:01:10,680 --> 00:01:17,009
is itself a a separate entity I want to

00:01:15,180 --> 00:01:19,110
talk to you about USB net console or

00:01:17,009 --> 00:01:23,580
bringing bringing up doing board bring

00:01:19,110 --> 00:01:25,770
up using net console and us be without a

00:01:23,580 --> 00:01:28,229
serial debug net that's not really a

00:01:25,770 --> 00:01:29,250
hundred percent practical today but we

00:01:28,229 --> 00:01:30,930
want to try to dive into the issues

00:01:29,250 --> 00:01:32,070
hopefully some of the folks in the room

00:01:30,930 --> 00:01:33,180
are actually some of the ones that were

00:01:32,070 --> 00:01:38,549
going to be working with to ultimately

00:01:33,180 --> 00:01:40,770
solve the problems that still exist that

00:01:38,549 --> 00:01:43,229
they they're there's still a handful of

00:01:40,770 --> 00:01:45,329
them that are that are that are real but

00:01:43,229 --> 00:01:48,780
things are to a point that you can

00:01:45,329 --> 00:01:51,630
essentially boot over USB get to a you

00:01:48,780 --> 00:01:54,689
boot prompt which is really cool and

00:01:51,630 --> 00:01:57,210
then and also get to you know to kernel

00:01:54,689 --> 00:01:58,920
to reasonably early curl messages

00:01:57,210 --> 00:02:01,829
although I have some some work of myself

00:01:58,920 --> 00:02:07,469
to birth regards to USB anyway I won't

00:02:01,829 --> 00:02:10,110
don't give away the ending so I don't

00:02:07,469 --> 00:02:12,840
need to go over that that was that that

00:02:10,110 --> 00:02:14,030
was in near your show description so I'm

00:02:12,840 --> 00:02:15,380
gonna talk about what USB

00:02:14,030 --> 00:02:18,050
that console is that's kind of the

00:02:15,380 --> 00:02:23,390
background theory then I'm going to go

00:02:18,050 --> 00:02:26,000
into my example and then I'm gonna kind

00:02:23,390 --> 00:02:30,020
of step back out of that at the end just

00:02:26,000 --> 00:02:32,870
to try to give you you know some some

00:02:30,020 --> 00:02:33,380
inputs on why this is this is really

00:02:32,870 --> 00:02:35,480
cool

00:02:33,380 --> 00:02:37,730
you must think it's might be kind of

00:02:35,480 --> 00:02:39,530
cool in some way maybe you wouldn't be

00:02:37,730 --> 00:02:41,090
there and then I'll in talking to Thomas

00:02:39,530 --> 00:02:44,440
um these just how many of you have

00:02:41,090 --> 00:02:46,280
actually used net console already

00:02:44,440 --> 00:02:48,470
because I know a number of people I've

00:02:46,280 --> 00:02:50,090
met a views net console on server farm

00:02:48,470 --> 00:02:53,510
so I did try to eliminate the serial

00:02:50,090 --> 00:02:56,660
cable nightmare but not too many of you

00:02:53,510 --> 00:03:01,069
have used that so I imagine even fewer

00:02:56,660 --> 00:03:04,850
of as anybody ever used USB networking

00:03:01,069 --> 00:03:05,750
and net console at the same time that's

00:03:04,850 --> 00:03:06,920
impressive

00:03:05,750 --> 00:03:11,209
there was that there was anybody that

00:03:06,920 --> 00:03:13,250
even tried it which is cool but we're

00:03:11,209 --> 00:03:14,870
after by the time you're out of here you

00:03:13,250 --> 00:03:20,660
go to the github and follow this you'll

00:03:14,870 --> 00:03:24,350
you too will be able to do USB based net

00:03:20,660 --> 00:03:28,040
console how many of you have any patches

00:03:24,350 --> 00:03:31,850
in the kernel a few ok quite quite a few

00:03:28,040 --> 00:03:34,220
yes awesome ok I feel this is going to

00:03:31,850 --> 00:03:38,989
be a super incredibly productive thing

00:03:34,220 --> 00:03:42,440
then yes traditional the way that we

00:03:38,989 --> 00:03:44,720
usually work with embedded systems kind

00:03:42,440 --> 00:03:48,560
of just jumping past JTAG right you know

00:03:44,720 --> 00:03:49,820
JTAG is is what a lot of people what a

00:03:48,560 --> 00:03:52,340
lot of people do but when you get into

00:03:49,820 --> 00:03:54,260
linux SBC world right and you get into

00:03:52,340 --> 00:03:56,450
the kernel right just give me the

00:03:54,260 --> 00:03:59,180
stinking serial port and let me do print

00:03:56,450 --> 00:04:02,000
k and I'm gonna debug all my drivers

00:03:59,180 --> 00:04:04,489
with print k and and that's a really

00:04:02,000 --> 00:04:06,620
really really common well yes lots of

00:04:04,489 --> 00:04:09,650
thumbs up on that get rid of that

00:04:06,620 --> 00:04:12,019
obnoxious little JTAG thing and you know

00:04:09,650 --> 00:04:14,299
allow me to do my printf sand allow me

00:04:12,019 --> 00:04:15,890
to add my debug statements the sooner I

00:04:14,299 --> 00:04:18,650
can get to trace functions the better

00:04:15,890 --> 00:04:20,269
but you know for now like as I'm trying

00:04:18,650 --> 00:04:22,669
to do Mitchell you know to do that bring

00:04:20,269 --> 00:04:24,289
up just print K and that's really that's

00:04:22,669 --> 00:04:26,150
really pretty cool it typically looks

00:04:24,289 --> 00:04:27,590
like is you know you have two wires

00:04:26,150 --> 00:04:28,880
really that matter

00:04:27,590 --> 00:04:31,760
there's power ground and there's the

00:04:28,880 --> 00:04:35,240
transmit and receive lines to wire it up

00:04:31,760 --> 00:04:37,910
on a board sometimes you'll need some

00:04:35,240 --> 00:04:39,770
other ones right you might need RTS CTS

00:04:37,910 --> 00:04:43,550
those are the most common clear to send

00:04:39,770 --> 00:04:45,830
and ready to send as handshaking most

00:04:43,550 --> 00:04:47,990
most you guys doing embedded system Z

00:04:45,830 --> 00:04:50,030
stuff will will not use those in your

00:04:47,990 --> 00:04:53,000
configs and just say you know let

00:04:50,030 --> 00:04:55,970
everything flow flow free and if I drop

00:04:53,000 --> 00:04:56,990
stuff I drop snow for whatever because

00:04:55,970 --> 00:04:59,030
you just want to you just want to get

00:04:56,990 --> 00:05:00,320
some output and there's other signals

00:04:59,030 --> 00:05:02,150
but like so there's a little bit of

00:05:00,320 --> 00:05:04,400
wiring challenge it's not that complex

00:05:02,150 --> 00:05:07,940
from a wiring standpoint but you do have

00:05:04,400 --> 00:05:10,910
to dedicate a port you do have to get

00:05:07,940 --> 00:05:14,450
something physically wired up in order

00:05:10,910 --> 00:05:17,330
to go and do that and you know any time

00:05:14,450 --> 00:05:19,130
you're doing debug but you really care

00:05:17,330 --> 00:05:21,500
about is reducing configuration steps

00:05:19,130 --> 00:05:23,330
that are error-prone right you you don't

00:05:21,500 --> 00:05:25,070
want to run to the situation you know a

00:05:23,330 --> 00:05:28,130
JTAG it's mostly did I get to pull ups

00:05:25,070 --> 00:05:30,020
or pull downs right with USB did I get

00:05:28,130 --> 00:05:33,350
the baud rate right did I have the right

00:05:30,020 --> 00:05:37,100
number of stop bits you know in it you

00:05:33,350 --> 00:05:42,710
know you can get data bits 8 in 1 these

00:05:37,100 --> 00:05:44,180
days is a pretty safe assumption and but

00:05:42,710 --> 00:05:45,710
but you still have the baud rate to deal

00:05:44,180 --> 00:05:47,419
with well how fast is your serial port

00:05:45,710 --> 00:05:48,889
running out you have to you know you can

00:05:47,419 --> 00:05:50,630
kind of try to do some auto baud rate

00:05:48,889 --> 00:05:53,479
detection if you have the right hardware

00:05:50,630 --> 00:05:54,620
but if you get it wrong you screw up so

00:05:53,479 --> 00:05:58,460
there's there still it's still

00:05:54,620 --> 00:06:03,080
error-prone even even at that level when

00:05:58,460 --> 00:06:05,300
configuring the hardware so it is a net

00:06:03,080 --> 00:06:08,510
console that's essentially networked

00:06:05,300 --> 00:06:11,450
serial right it's a way to get the base

00:06:08,510 --> 00:06:14,090
functionality of a serial connection but

00:06:11,450 --> 00:06:17,120
instead of transmitting it over the

00:06:14,090 --> 00:06:20,389
transmen receive lines I'm going to send

00:06:17,120 --> 00:06:22,910
you DP packets and the format is really

00:06:20,389 --> 00:06:25,039
really really simple if I want to send a

00:06:22,910 --> 00:06:27,560
data byte I throw it in a UDP packet UDP

00:06:25,039 --> 00:06:29,330
packet and it's the length of the the

00:06:27,560 --> 00:06:32,630
length of the UDP packet says how much

00:06:29,330 --> 00:06:34,340
data there is and and that's it that's

00:06:32,630 --> 00:06:37,070
how I send data one direction and

00:06:34,340 --> 00:06:40,099
receive it the other direction over the

00:06:37,070 --> 00:06:41,990
wire pretty darn simple not a lot of

00:06:40,099 --> 00:06:44,030
configuration headaches you

00:06:41,990 --> 00:06:45,560
and potentially configure it you get a

00:06:44,030 --> 00:06:47,960
create a configuration issue here with

00:06:45,560 --> 00:06:51,350
the port number you know if you're doing

00:06:47,960 --> 00:06:56,180
that console the the typical thing is to

00:06:51,350 --> 00:07:00,350
put it over port six six six six the

00:06:56,180 --> 00:07:02,360
extra six is important I don't know what

00:07:00,350 --> 00:07:04,940
these guys were thinking you know they

00:07:02,360 --> 00:07:10,340
thought it was particularly evil or

00:07:04,940 --> 00:07:12,080
extra extra evil anyway and then you

00:07:10,340 --> 00:07:13,190
know you know specify some little IP

00:07:12,080 --> 00:07:16,730
addresses and go

00:07:13,190 --> 00:07:18,320
so that IP address specification part

00:07:16,730 --> 00:07:20,360
right is also kind of tricky right

00:07:18,320 --> 00:07:24,020
you're trying to boot up a device and

00:07:20,360 --> 00:07:26,510
get into it and go to other things so so

00:07:24,020 --> 00:07:29,480
you know you can you can hard code those

00:07:26,510 --> 00:07:32,570
on a subnet if you haven't isolated you

00:07:29,480 --> 00:07:35,150
know Ethernet subnet and and and go

00:07:32,570 --> 00:07:36,770
about things that way but if you're

00:07:35,150 --> 00:07:38,000
sharing the network with other things

00:07:36,770 --> 00:07:40,130
then you need to think a little bit more

00:07:38,000 --> 00:07:42,830
about the process for getting those

00:07:40,130 --> 00:07:44,360
those those magic IP addresses and if

00:07:42,830 --> 00:07:45,800
you've seen that the networking stacks

00:07:44,360 --> 00:07:48,680
right this is essentially to build up

00:07:45,800 --> 00:07:52,070
you got your Ethernet packet you know

00:07:48,680 --> 00:07:53,690
and you're using IP just specify so the

00:07:52,070 --> 00:07:56,420
the source address destination address

00:07:53,690 --> 00:07:58,190
right so it's IP routed and then you've

00:07:56,420 --> 00:08:00,830
got the UDP packet which has the port

00:07:58,190 --> 00:08:02,780
numbers in it to say that it's source

00:08:00,830 --> 00:08:04,160
port destination port just do six six

00:08:02,780 --> 00:08:06,230
six six don't do play with any of the

00:08:04,160 --> 00:08:08,780
funny port remapping stuff anyway

00:08:06,230 --> 00:08:11,420
just accept those ports don't have to do

00:08:08,780 --> 00:08:13,130
anything funky there and then the length

00:08:11,420 --> 00:08:15,620
and then their payload right and the

00:08:13,130 --> 00:08:17,960
payloads or bits right so it's it's it's

00:08:15,620 --> 00:08:20,480
it's pretty simple from from from a

00:08:17,960 --> 00:08:22,220
networking perspective that IP address

00:08:20,480 --> 00:08:23,630
stuff is the only place where you can

00:08:22,220 --> 00:08:26,780
add some you need you need to put up a

00:08:23,630 --> 00:08:29,450
couple services somewhere to kind of

00:08:26,780 --> 00:08:30,860
handle these things on that network now

00:08:29,450 --> 00:08:33,830
if you have any other computers on the

00:08:30,860 --> 00:08:37,130
network with running network stacks they

00:08:33,830 --> 00:08:37,790
already do this right so at least with

00:08:37,130 --> 00:08:39,890
the first one

00:08:37,790 --> 00:08:43,850
so ARP is the address resolution

00:08:39,890 --> 00:08:46,220
protocol that's how you get the IP

00:08:43,850 --> 00:08:48,500
address you associate the MAC address of

00:08:46,220 --> 00:08:50,300
the IP address of the server that you're

00:08:48,500 --> 00:08:51,740
going to be talking to where who's this

00:08:50,300 --> 00:08:54,050
in this case the server is the one

00:08:51,740 --> 00:08:54,640
you're viewing all the net console data

00:08:54,050 --> 00:08:55,810
right so there

00:08:54,640 --> 00:09:00,310
the server and then there's the target

00:08:55,810 --> 00:09:03,790
system and so the the target system is

00:09:00,310 --> 00:09:07,450
going to send out an ARP proxy or probe

00:09:03,790 --> 00:09:09,610
probe that's the term an art probe and

00:09:07,450 --> 00:09:11,860
then everything on the land is gonna

00:09:09,610 --> 00:09:13,180
send back here's my IP address and

00:09:11,860 --> 00:09:15,430
here's my MAC address so what do you

00:09:13,180 --> 00:09:17,950
want to send Ethernet packets to this IP

00:09:15,430 --> 00:09:20,830
address you send them to this Ethernet

00:09:17,950 --> 00:09:24,220
MAC address and so it makes it so that

00:09:20,830 --> 00:09:26,890
builds up an ARP table on the the target

00:09:24,220 --> 00:09:28,870
and it can send - you know it has that

00:09:26,890 --> 00:09:32,080
that it now knows the MAC address for

00:09:28,870 --> 00:09:34,030
the particular IP address but then if

00:09:32,080 --> 00:09:35,230
they're sitting on an on a network and

00:09:34,030 --> 00:09:37,500
you know you you could you could

00:09:35,230 --> 00:09:40,180
potentially statically configure the IP

00:09:37,500 --> 00:09:42,970
and and but you'd have to still know the

00:09:40,180 --> 00:09:45,640
MAC address anyway you could do that on

00:09:42,970 --> 00:09:47,470
all on the target but more typically for

00:09:45,640 --> 00:09:48,970
sending on a shared network or just just

00:09:47,470 --> 00:09:50,500
about any real configuration you want to

00:09:48,970 --> 00:09:54,010
try to do something like bootp or DHCP

00:09:50,500 --> 00:09:55,780
to get the targets IP address right so

00:09:54,010 --> 00:09:57,310
the ARP tells the target what the

00:09:55,780 --> 00:09:59,230
server's IP address is now how does it

00:09:57,310 --> 00:10:04,530
find out its own it's gonna go do a

00:09:59,230 --> 00:10:08,500
bootp and try to get its own IP address

00:10:04,530 --> 00:10:10,840
so it may also this may be also where it

00:10:08,500 --> 00:10:13,720
gets the magic information of well what

00:10:10,840 --> 00:10:15,100
am I actually going to load to boot so

00:10:13,720 --> 00:10:18,130
if I'm going to boot I'm gonna transfer

00:10:15,100 --> 00:10:20,680
with a with TFTP the bootp packet would

00:10:18,130 --> 00:10:22,810
also contain the file name of what it

00:10:20,680 --> 00:10:24,880
wants you to load so what the server

00:10:22,810 --> 00:10:28,470
wants to serve up on the to the to the

00:10:24,880 --> 00:10:32,170
part target device to boot this is

00:10:28,470 --> 00:10:35,560
hopefully this is a lot of detail but

00:10:32,170 --> 00:10:38,800
I'm not going to go any deeper so you

00:10:35,560 --> 00:10:40,330
need those in order to to get the the IP

00:10:38,800 --> 00:10:41,710
addresses and that's kind of the hardest

00:10:40,330 --> 00:10:44,890
part in the configuration but there's

00:10:41,710 --> 00:10:50,020
their stuff there to do that now we're

00:10:44,890 --> 00:10:52,180
gonna add that extra layer maybe I

00:10:50,020 --> 00:10:54,550
should do these out of order we're gonna

00:10:52,180 --> 00:10:59,790
now we needed to add that extra layer

00:10:54,550 --> 00:10:59,790
which is to do that all over instead of

00:10:59,910 --> 00:11:03,910
instead of over a real ethernet hardware

00:11:02,290 --> 00:11:06,160
Ethernet so we've got an Ethernet card

00:11:03,910 --> 00:11:07,870
in both computers we're going to do that

00:11:06,160 --> 00:11:11,950
over you

00:11:07,870 --> 00:11:13,990
be so the the drawing looks pretty

00:11:11,950 --> 00:11:15,990
similar except down here down at the

00:11:13,990 --> 00:11:18,760
very bottom for the physical layer

00:11:15,990 --> 00:11:22,720
you've got this extra element to the

00:11:18,760 --> 00:11:26,830
protocol which is our indus remote

00:11:22,720 --> 00:11:28,180
network if i don't forget no just it's

00:11:26,830 --> 00:11:31,000
the that's the that's the way to

00:11:28,180 --> 00:11:36,940
encapsulate it's a way to encapsulate

00:11:31,000 --> 00:11:41,020
Ethernet packets over USB the the CDC

00:11:36,940 --> 00:11:44,860
standard has another way ECM there's T

00:11:41,020 --> 00:11:46,630
la la la but but it's it's a way that

00:11:44,860 --> 00:11:50,260
we're gonna be used in to to transfer

00:11:46,630 --> 00:11:51,880
those Ethernet packets over your USB bus

00:11:50,260 --> 00:11:55,480
hopefully I don't have to explain USB as

00:11:51,880 --> 00:11:59,790
a TL I know I may not know what USB is

00:11:55,480 --> 00:12:03,640
we're in the right room thank you

00:11:59,790 --> 00:12:04,779
somebody's listening anyway um so we're

00:12:03,640 --> 00:12:06,339
gonna you we're gonna use for our

00:12:04,779 --> 00:12:07,750
example we're gonna use our index right

00:12:06,339 --> 00:12:09,850
there's different different ways that

00:12:07,750 --> 00:12:12,850
you can go and do about and are just

00:12:09,850 --> 00:12:14,650
plus TFTP the nice thing is it's

00:12:12,850 --> 00:12:16,000
supported in the processor that we're

00:12:14,650 --> 00:12:19,089
gonna be using it's supporting the blue

00:12:16,000 --> 00:12:21,760
ROM so the boot ROM actually under

00:12:19,089 --> 00:12:25,990
spanned spans how to do USB or Indus

00:12:21,760 --> 00:12:30,820
it's gonna look like a network device to

00:12:25,990 --> 00:12:32,470
my to my host computer and the this

00:12:30,820 --> 00:12:34,480
there's some of this is kind of just it

00:12:32,470 --> 00:12:36,910
gets incorporated all within the device

00:12:34,480 --> 00:12:39,900
side driver so that's the the host PC

00:12:36,910 --> 00:12:42,730
looks like it gets an ethernet device

00:12:39,900 --> 00:12:44,110
but inside the the target device it also

00:12:42,730 --> 00:12:45,220
looks like it has you know then the

00:12:44,110 --> 00:12:48,040
driver it has its own Ethernet devices

00:12:45,220 --> 00:12:50,200
so it looks like there's two Ethernet

00:12:48,040 --> 00:12:52,480
adapters connected directly to each

00:12:50,200 --> 00:12:56,110
other over an Ethernet cable but yet no

00:12:52,480 --> 00:12:58,000
Ethernet exists right so USB just makes

00:12:56,110 --> 00:13:00,250
it you know all the USB class drivers

00:12:58,000 --> 00:13:02,320
just make it look like your host gets an

00:13:00,250 --> 00:13:04,150
internet adapter I have my virtual

00:13:02,320 --> 00:13:05,200
Ethernet adapter and we're gonna talk

00:13:04,150 --> 00:13:08,529
eat or not even though there's no

00:13:05,200 --> 00:13:10,930
Ethernet there's just USB lose everybody

00:13:08,529 --> 00:13:12,400
I saw some heads nod that's awesome

00:13:10,930 --> 00:13:14,050
because that's the hardest that's the

00:13:12,400 --> 00:13:16,930
hardest concept I'm going to go over

00:13:14,050 --> 00:13:21,310
today alright it's all downhill from

00:13:16,930 --> 00:13:23,080
here but but it's nice that the the

00:13:21,310 --> 00:13:26,950
Rahm and the device actually understands

00:13:23,080 --> 00:13:29,740
our Indus and TFTP you provide it code

00:13:26,950 --> 00:13:32,800
that you wanted to run by TFTP it shoves

00:13:29,740 --> 00:13:36,850
that into the internal SRAM in the the

00:13:32,800 --> 00:13:40,270
processor that then configures the DDR

00:13:36,850 --> 00:13:44,170
on the processor and triggers off so you

00:13:40,270 --> 00:13:46,660
boot you boot itself there's a SPL thing

00:13:44,170 --> 00:13:48,400
the secondary program loader that's tiny

00:13:46,660 --> 00:13:51,450
and it fits inside that internal memory

00:13:48,400 --> 00:13:56,589
that understands USB are in this and

00:13:51,450 --> 00:13:59,279
TFTP as well so from that SPL you can

00:13:56,589 --> 00:14:02,050
you know so the SPL configures the DDR

00:13:59,279 --> 00:14:05,410
so from that SPL we're gonna TFTP now

00:14:02,050 --> 00:14:09,220
into the DDR and we're gonna put in

00:14:05,410 --> 00:14:11,320
there is you boot so you boot itself the

00:14:09,220 --> 00:14:13,450
big you boot not the tiny little version

00:14:11,320 --> 00:14:15,910
of it that's SPL that's all shrunk down

00:14:13,450 --> 00:14:17,850
to just do one exact thing now we've got

00:14:15,910 --> 00:14:20,350
you boot which is an extremely flexible

00:14:17,850 --> 00:14:23,080
bootloader base that we have to work

00:14:20,350 --> 00:14:24,970
from and a great way to do your board

00:14:23,080 --> 00:14:28,810
debug and bring up right so you're now

00:14:24,970 --> 00:14:31,000
in a nice environment so that so SPL

00:14:28,810 --> 00:14:33,760
knows how to do that our Indus and TFTP

00:14:31,000 --> 00:14:37,510
and get you into u-boat and you boot

00:14:33,760 --> 00:14:39,430
supports net console and it really

00:14:37,510 --> 00:14:42,100
doesn't care what it's putting that

00:14:39,430 --> 00:14:46,270
console over it wants to put it it needs

00:14:42,100 --> 00:14:48,040
UDP packets and and that's all it needs

00:14:46,270 --> 00:14:51,040
you poop provides a service for doing

00:14:48,040 --> 00:14:54,070
networking it plugs into that stack that

00:14:51,040 --> 00:14:55,450
does it over USB alright so see you boot

00:14:54,070 --> 00:14:59,470
doesn't necessarily care if you're using

00:14:55,450 --> 00:15:01,690
Ethernet or at least at some some level

00:14:59,470 --> 00:15:04,089
of abstraction it doesn't care whether

00:15:01,690 --> 00:15:07,030
it's using each real Ethernet or USB

00:15:04,089 --> 00:15:09,459
Ethernet but we'll deal with some of the

00:15:07,030 --> 00:15:11,800
particulars and also Linux understands

00:15:09,459 --> 00:15:13,510
how to do I mean obviously Linux knows

00:15:11,800 --> 00:15:15,550
how to do everything but it knows how to

00:15:13,510 --> 00:15:20,050
do the USB are in descend that console

00:15:15,550 --> 00:15:21,880
as well I'm gonna move back talk about

00:15:20,050 --> 00:15:23,650
how some of that's accomplished I think

00:15:21,880 --> 00:15:28,180
you know just to kind of make sure you

00:15:23,650 --> 00:15:29,530
got that that USB gadget concepts so the

00:15:28,180 --> 00:15:31,500
client drivers are running on the target

00:15:29,530 --> 00:15:34,190
alright so you've got you've got this

00:15:31,500 --> 00:15:36,650
this gadget

00:15:34,190 --> 00:15:38,390
driver so that that's the that's the

00:15:36,650 --> 00:15:41,210
Linux terminology for at least but it

00:15:38,390 --> 00:15:43,460
just means that I'm acting like a device

00:15:41,210 --> 00:15:45,770
a target not the not the guy that's

00:15:43,460 --> 00:15:47,480
actually driving the USB bus let the guy

00:15:45,770 --> 00:15:49,940
that's like answering the USB bus

00:15:47,480 --> 00:15:51,500
requests right and USB all the

00:15:49,940 --> 00:15:53,630
transactions all the transfers are

00:15:51,500 --> 00:15:55,910
initiated by the host and the target

00:15:53,630 --> 00:15:57,140
just really answers them so there's a

00:15:55,910 --> 00:16:01,220
driver that knows how to answer those

00:15:57,140 --> 00:16:03,800
requests and treat them as as as Network

00:16:01,220 --> 00:16:06,170
right so a gadget driver like you know

00:16:03,800 --> 00:16:08,990
it's to something like act like the you

00:16:06,170 --> 00:16:10,970
at the USB fob that storage you have

00:16:08,990 --> 00:16:14,360
that you plug in has the the flash

00:16:10,970 --> 00:16:17,210
memory on it to act like the fob not to

00:16:14,360 --> 00:16:18,590
host the fob right it's not what you

00:16:17,210 --> 00:16:19,220
it's not what it's not what's reading

00:16:18,590 --> 00:16:21,140
the disk

00:16:19,220 --> 00:16:24,800
it's what's serving the information of

00:16:21,140 --> 00:16:27,980
the disk off and and in a USB everything

00:16:24,800 --> 00:16:29,510
all the clients are grouped in classes

00:16:27,980 --> 00:16:32,540
to simplify the host design right so

00:16:29,510 --> 00:16:37,040
there's so we just you know we're using

00:16:32,540 --> 00:16:39,620
a networking class driver and artist is

00:16:37,040 --> 00:16:42,260
one of those classes that provides USB

00:16:39,620 --> 00:16:43,430
Ethernet CDC ECM is another but you know

00:16:42,260 --> 00:16:45,290
forget about that that's actually a

00:16:43,430 --> 00:16:47,630
better one and tremendous amount of

00:16:45,290 --> 00:16:50,030
respects but it's not the one at the am

00:16:47,630 --> 00:16:55,370
three three five ROM implements that's

00:16:50,030 --> 00:16:57,800
where the the train goes so why did I

00:16:55,370 --> 00:17:01,070
want to do any of this in the first

00:16:57,800 --> 00:17:05,900
place it's actually oh there's a lot of

00:17:01,070 --> 00:17:08,030
reasons ultimately trying to actually

00:17:05,900 --> 00:17:12,290
boot these devices from the browser and

00:17:08,030 --> 00:17:15,380
really expose you know more users to

00:17:12,290 --> 00:17:16,939
really low levels so they can build some

00:17:15,380 --> 00:17:18,920
understanding but from a practical

00:17:16,939 --> 00:17:21,140
standpoint what was the tipping point I

00:17:18,920 --> 00:17:22,640
said okay I'm actually gonna open up a

00:17:21,140 --> 00:17:24,980
Pandora's box and start playing with us

00:17:22,640 --> 00:17:26,480
peanut console it was actually the

00:17:24,980 --> 00:17:28,400
pocket beagle production so it's a new

00:17:26,480 --> 00:17:31,160
that's what I'm doing the demos on it's

00:17:28,400 --> 00:17:32,690
a new single board computer that's 25

00:17:31,160 --> 00:17:34,460
bucks and all that stuff but we needed

00:17:32,690 --> 00:17:36,500
some way to test them in production and

00:17:34,460 --> 00:17:37,820
a uniquely serial number of them because

00:17:36,500 --> 00:17:39,230
we do that for all the beagles and we

00:17:37,820 --> 00:17:42,679
like to be able to identify when it was

00:17:39,230 --> 00:17:43,790
built and and and all this fun stuff I

00:17:42,679 --> 00:17:45,770
don't know if the serial numbers are all

00:17:43,790 --> 00:17:47,300
that really necessary but we've kind of

00:17:45,770 --> 00:17:49,190
committed to doing it

00:17:47,300 --> 00:17:50,240
and so we're gonna do it and so we

00:17:49,190 --> 00:17:53,240
needed some place where we can get those

00:17:50,240 --> 00:17:57,290
unique numbers and really quick so the

00:17:53,240 --> 00:18:01,100
the pocket big old tester runs in like

00:17:57,290 --> 00:18:05,660
three seconds like two three seconds you

00:18:01,100 --> 00:18:07,160
know and it's we what I started out

00:18:05,660 --> 00:18:09,370
actually trying to boot everything over

00:18:07,160 --> 00:18:12,050
USB but it boots up a whole lot faster

00:18:09,370 --> 00:18:14,900
if I boot you boot off of the micro sd

00:18:12,050 --> 00:18:17,660
so I ended up using you the micro sd to

00:18:14,900 --> 00:18:20,030
boot you boot but it then enabled net

00:18:17,660 --> 00:18:21,760
console for communications over the USB

00:18:20,030 --> 00:18:23,930
line we're fetching the serial numbers

00:18:21,760 --> 00:18:26,270
fetching some basic test spacings

00:18:23,930 --> 00:18:29,420
fetching some scripts that are actually

00:18:26,270 --> 00:18:31,550
gonna go and like set the LEDs so the

00:18:29,420 --> 00:18:35,000
you know that it did it actually issues

00:18:31,550 --> 00:18:37,370
those those those commands over the the

00:18:35,000 --> 00:18:39,050
USB net console and I'm actually gonna

00:18:37,370 --> 00:18:40,760
bring up some code now here because this

00:18:39,050 --> 00:18:43,100
is alive

00:18:40,760 --> 00:18:48,110
oh I'm not gonna bring up some code

00:18:43,100 --> 00:18:51,560
because I can't get to the internet and

00:18:48,110 --> 00:18:54,260
I wanted to show that so in the end this

00:18:51,560 --> 00:18:56,960
just there's mic like that that

00:18:54,260 --> 00:18:58,400
particular I checked in binary files but

00:18:56,960 --> 00:19:00,920
there's always ugly but I did also

00:18:58,400 --> 00:19:03,380
include the commit IDs so you could look

00:19:00,920 --> 00:19:05,330
at the versions of you boots that I that

00:19:03,380 --> 00:19:08,870
I built with this and and you know to my

00:19:05,330 --> 00:19:10,670
repo that has the the patches for it but

00:19:08,870 --> 00:19:13,390
I actually have a JavaScript routine

00:19:10,670 --> 00:19:15,590
that I'm running on a BeagleBone black

00:19:13,390 --> 00:19:17,840
I'm actually a BeagleBone black Wireless

00:19:15,590 --> 00:19:20,360
technically that when you when you want

00:19:17,840 --> 00:19:23,450
to test the pocket beagles you plug in

00:19:20,360 --> 00:19:25,670
the micro SD that has you boot on it and

00:19:23,450 --> 00:19:29,270
then you you plug in the USB coming out

00:19:25,670 --> 00:19:34,220
of the the the the BeagleBone black

00:19:29,270 --> 00:19:36,410
wireless and it that powers it up right

00:19:34,220 --> 00:19:38,620
so the USB connection powers it up boots

00:19:36,410 --> 00:19:38,620
up

00:19:38,850 --> 00:19:44,309
the the you boot and enables the net

00:19:41,700 --> 00:19:46,919
console I then in the JavaScript code

00:19:44,309 --> 00:19:49,559
I'm just using the UDP I'm using that

00:19:46,919 --> 00:19:53,820
the tcp/ip framework that's on the

00:19:49,559 --> 00:19:57,049
Pocket beagle to you know just send

00:19:53,820 --> 00:19:59,370
streams of of a viewboot commands

00:19:57,049 --> 00:20:00,779
alright so I just needed to send the

00:19:59,370 --> 00:20:02,159
streams of you boot commands to do

00:20:00,779 --> 00:20:03,990
different operations including writing a

00:20:02,159 --> 00:20:05,580
serial number and then the serial number

00:20:03,990 --> 00:20:07,230
that's on its living you know this the

00:20:05,580 --> 00:20:08,220
file that stores the serial numbers

00:20:07,230 --> 00:20:10,350
living there on the BeagleBone black

00:20:08,220 --> 00:20:13,350
wireless and it increments that every

00:20:10,350 --> 00:20:14,970
time a test once successfully and it

00:20:13,350 --> 00:20:17,820
updates the LEDs to tell you if it

00:20:14,970 --> 00:20:22,259
actually completed or not happens really

00:20:17,820 --> 00:20:24,029
quick and it's nice but since then you

00:20:22,259 --> 00:20:25,649
know last minute of course always but

00:20:24,029 --> 00:20:27,480
that's what gave me the confidence that

00:20:25,649 --> 00:20:30,539
said I can come out here and talk about

00:20:27,480 --> 00:20:32,070
this but it wasn't really where I wanted

00:20:30,539 --> 00:20:35,070
to be at to come talk and that all

00:20:32,070 --> 00:20:37,200
happened in the last couple of days but

00:20:35,070 --> 00:20:39,710
we took this this project that we done

00:20:37,200 --> 00:20:43,080
at last year's google Summer of Code

00:20:39,710 --> 00:20:45,690
called node beagle boot which implements

00:20:43,080 --> 00:20:49,080
the all those critical servers that

00:20:45,690 --> 00:20:53,009
we're talking about over node USB which

00:20:49,080 --> 00:20:55,289
is just a node.js wrapper for lib USB so

00:20:53,009 --> 00:20:57,659
it takes live USB if it sees the right

00:20:55,289 --> 00:20:59,610
vendors IDs it grabs it and says it's

00:20:57,659 --> 00:21:01,019
mine and then it implements all of those

00:20:59,610 --> 00:21:02,399
protocols it implements there are in

00:21:01,019 --> 00:21:04,019
this and implements the ARP it

00:21:02,399 --> 00:21:09,960
implements the bootp and implements the

00:21:04,019 --> 00:21:12,750
TFTP all in nodejs alright so so it so

00:21:09,960 --> 00:21:16,019
it it provides all those and so I wanted

00:21:12,750 --> 00:21:19,080
to add onto that the support for net

00:21:16,019 --> 00:21:22,259
console which is now there so hopefully

00:21:19,080 --> 00:21:23,750
I actually have a demo the nice thing

00:21:22,259 --> 00:21:26,519
about putting it all into this one

00:21:23,750 --> 00:21:29,100
application versus just using the

00:21:26,519 --> 00:21:30,450
services that are on the the device is

00:21:29,100 --> 00:21:32,309
heck I can't even remember how I

00:21:30,450 --> 00:21:34,289
configured my BeagleBone black wireless

00:21:32,309 --> 00:21:36,509
in order to make it answer all the

00:21:34,289 --> 00:21:38,340
services things like it just takes away

00:21:36,509 --> 00:21:41,039
the confusion and make sure everything

00:21:38,340 --> 00:21:43,860
all in one place right so it doesn't

00:21:41,039 --> 00:21:45,750
depend on the host configuration like

00:21:43,860 --> 00:21:48,210
you're not messing with the host network

00:21:45,750 --> 00:21:49,580
stack right if this is my platform that

00:21:48,210 --> 00:21:52,190
I want to be you know acting

00:21:49,580 --> 00:21:54,080
with do I really want to like you know

00:21:52,190 --> 00:21:55,850
set up the specific network interfaces

00:21:54,080 --> 00:21:58,489
to always come up to these static IPS

00:21:55,850 --> 00:22:02,779
where if I'm on wireless network it's it

00:21:58,489 --> 00:22:05,179
becomes a royal pain in the ass so we

00:22:02,779 --> 00:22:08,090
get rid of any that that changes to your

00:22:05,179 --> 00:22:10,940
to your real host system and you know we

00:22:08,090 --> 00:22:13,399
want to get this into like different

00:22:10,940 --> 00:22:15,919
electron taps namely etcher all right so

00:22:13,399 --> 00:22:19,489
HR is a tool that like the node Beall

00:22:15,919 --> 00:22:21,080
boat was originally done to bring up USB

00:22:19,489 --> 00:22:23,029
mass-storage class on the target device

00:22:21,080 --> 00:22:24,580
so that you can actually write the

00:22:23,029 --> 00:22:27,409
onboard flash of a BeagleBone black

00:22:24,580 --> 00:22:28,999
right without having to have you know

00:22:27,409 --> 00:22:31,489
any other boot source right you just

00:22:28,999 --> 00:22:33,769
boot up over USB and I can reflash the

00:22:31,489 --> 00:22:36,559
device so she'll bring up either you

00:22:33,769 --> 00:22:39,409
want you a mess in either Linux or in

00:22:36,559 --> 00:22:41,749
even you boot has UMS support now

00:22:39,409 --> 00:22:44,869
so the nodejs one is actually using the

00:22:41,749 --> 00:22:46,309
UMS on in you boot the previous

00:22:44,869 --> 00:22:49,129
generation that we wrote at the the

00:22:46,309 --> 00:22:50,480
server and see had used you know a small

00:22:49,129 --> 00:22:51,649
Linux image and it's using that the

00:22:50,480 --> 00:22:53,679
linux image is a little bit faster

00:22:51,649 --> 00:22:57,169
acting is mext or mass storage class

00:22:53,679 --> 00:23:00,830
then you boot is but you really like

00:22:57,169 --> 00:23:02,570
simplicity is king and just getting it

00:23:00,830 --> 00:23:05,330
to it and you boot is really really nice

00:23:02,570 --> 00:23:06,889
so you can make an electron app if you

00:23:05,330 --> 00:23:08,090
don't know it's a node.js framework for

00:23:06,889 --> 00:23:11,179
actually making GUI standalone

00:23:08,090 --> 00:23:13,070
applications in this cross-platform you

00:23:11,179 --> 00:23:14,450
know potentially now with this I can you

00:23:13,070 --> 00:23:17,629
create an electrode app it's going to

00:23:14,450 --> 00:23:22,190
give me a console you boot console in an

00:23:17,629 --> 00:23:26,149
electron app and in the future because

00:23:22,190 --> 00:23:29,320
of the API for Lib USB for node USB is

00:23:26,149 --> 00:23:35,090
largely similar to the to the web USB

00:23:29,320 --> 00:23:36,080
API I'll go ahead and throw in the well

00:23:35,090 --> 00:23:37,399
I'm thinking about them I'll go ahead

00:23:36,080 --> 00:23:40,279
and throw them some limitations

00:23:37,399 --> 00:23:41,480
web USB does have an issue that we were

00:23:40,279 --> 00:23:44,239
a little bit concerned about initially

00:23:41,480 --> 00:23:46,460
issue I see it's not very secure to

00:23:44,239 --> 00:23:48,769
begin with but from a security

00:23:46,460 --> 00:23:53,720
standpoint it says if your host has a

00:23:48,769 --> 00:23:57,320
driver for that device you know it's

00:23:53,720 --> 00:23:58,999
gonna grab the it's gonna grab a hold of

00:23:57,320 --> 00:24:01,190
it and and you're not going to be able

00:23:58,999 --> 00:24:02,980
to grab it with Libya with with sorry

00:24:01,190 --> 00:24:05,200
with web USB

00:24:02,980 --> 00:24:08,080
the workaround is pretty simple we

00:24:05,200 --> 00:24:10,059
change all the descriptors so it doesn't

00:24:08,080 --> 00:24:11,200
load a driver right if you control the

00:24:10,059 --> 00:24:13,809
other end of the wire just change the

00:24:11,200 --> 00:24:16,660
descriptors web USB won't grab it and we

00:24:13,809 --> 00:24:19,000
can grab it you know kind of sucks from

00:24:16,660 --> 00:24:20,320
a from a you know but you know keeping

00:24:19,000 --> 00:24:23,559
everything general so if you want to

00:24:20,320 --> 00:24:28,059
build other hosts stacks you can but it

00:24:23,559 --> 00:24:31,360
allows us to take control over it now

00:24:28,059 --> 00:24:32,590
the other thing is you know yeah and so

00:24:31,360 --> 00:24:33,850
implement I already mentioned that it

00:24:32,590 --> 00:24:38,740
implements all these different protocols

00:24:33,850 --> 00:24:40,240
so let's get on to it you know I I'm

00:24:38,740 --> 00:24:41,410
trying to put some of these slides in

00:24:40,240 --> 00:24:43,120
front because once I actually go into

00:24:41,410 --> 00:24:47,530
the demo I don't want to try to go back

00:24:43,120 --> 00:24:49,450
to slides so goals for node BeagleBone

00:24:47,530 --> 00:24:52,210
right we want to try to get don't beagle

00:24:49,450 --> 00:24:54,070
boot in this neck console context get to

00:24:52,210 --> 00:24:55,330
interactivity as soon as possible right

00:24:54,070 --> 00:24:57,730
get to the point where we're we're

00:24:55,330 --> 00:25:00,429
actually you know peaking peaking and

00:24:57,730 --> 00:25:02,140
poking things inside the device under

00:25:00,429 --> 00:25:03,669
our control as quickly as possible

00:25:02,140 --> 00:25:05,679
really minimize the hardware

00:25:03,669 --> 00:25:08,799
dependencies right so all I need for a

00:25:05,679 --> 00:25:11,200
system now is USB right USB is providing

00:25:08,799 --> 00:25:14,440
power around communications you know

00:25:11,200 --> 00:25:19,330
it's booting it I don't need anything

00:25:14,440 --> 00:25:21,040
else and you know yeah so running in a

00:25:19,330 --> 00:25:22,630
browser is where we're headed ed sure is

00:25:21,040 --> 00:25:27,370
also inserted that kind of redundant

00:25:22,630 --> 00:25:30,370
there eventually keeping at it so right

00:25:27,370 --> 00:25:35,020
now the limitation of my demo is that it

00:25:30,370 --> 00:25:37,480
comes up to you boot net console for you

00:25:35,020 --> 00:25:41,770
know I'm not able to take that on into

00:25:37,480 --> 00:25:45,040
the kernel booting so it's possible and

00:25:41,770 --> 00:25:46,150
I've got some my slides are kind of add

00:25:45,040 --> 00:25:47,440
or order and this I'm gonna answer it

00:25:46,150 --> 00:25:49,809
here and not spend the time on the other

00:25:47,440 --> 00:25:52,780
slide it's possible to actually create a

00:25:49,809 --> 00:25:55,480
console in you boot and expose that

00:25:52,780 --> 00:25:58,179
through UEFI and essentially carry that

00:25:55,480 --> 00:25:59,740
console on through boot right so that as

00:25:58,179 --> 00:26:01,809
the kernel is booting if you're

00:25:59,740 --> 00:26:04,330
providing the UEFI service it keeps that

00:26:01,809 --> 00:26:05,980
stuff alive essentially if you're a das

00:26:04,330 --> 00:26:10,929
programmer like thank terminate and stay

00:26:05,980 --> 00:26:13,540
resident sort of like like world but it

00:26:10,929 --> 00:26:15,760
creates hooks so that I can I could do

00:26:13,540 --> 00:26:17,860
that in the future where

00:26:15,760 --> 00:26:20,560
keep that console alive the same console

00:26:17,860 --> 00:26:23,320
on through the process of booting the

00:26:20,560 --> 00:26:24,910
kernel you know today you can run some

00:26:23,320 --> 00:26:27,490
scripts and kind of restart and a

00:26:24,910 --> 00:26:30,040
console the biggest one of the one of

00:26:27,490 --> 00:26:33,370
the bigger issues I should say with

00:26:30,040 --> 00:26:37,420
running that console over USB with the

00:26:33,370 --> 00:26:41,580
kernel is the wonderful advent of config

00:26:37,420 --> 00:26:45,430
FS config FS if if you know if you're

00:26:41,580 --> 00:26:47,290
for those who know it you know provide

00:26:45,430 --> 00:26:48,730
you configure your USB but it doesn't

00:26:47,290 --> 00:26:50,560
allow you to do it statically in pre

00:26:48,730 --> 00:26:52,000
boot right it doesn't really get you it

00:26:50,560 --> 00:26:53,800
doesn't get very early it actually

00:26:52,000 --> 00:26:57,280
relies on user space being up before you

00:26:53,800 --> 00:26:58,930
start poking eke config FS that's great

00:26:57,280 --> 00:27:01,330
for those of us that love to hack and

00:26:58,930 --> 00:27:03,540
and you know create keyboard emulators

00:27:01,330 --> 00:27:05,560
and all the cool stuff that it can do

00:27:03,540 --> 00:27:08,710
but it's a pain in the ass when you want

00:27:05,560 --> 00:27:10,510
it up really early so like ideally for

00:27:08,710 --> 00:27:14,560
me it would be both in the device tree

00:27:10,510 --> 00:27:17,020
as well as in config FS but most of

00:27:14,560 --> 00:27:19,270
those drivers don't support today as far

00:27:17,020 --> 00:27:21,940
as I know don't support any sort of like

00:27:19,270 --> 00:27:25,330
device tree level configuration you can

00:27:21,940 --> 00:27:26,650
compile G multi and hard code that into

00:27:25,330 --> 00:27:30,490
the to the kernel so it's kind of a

00:27:26,650 --> 00:27:33,220
legacy gadget driver you can you can get

00:27:30,490 --> 00:27:35,020
there reasonably early that way but

00:27:33,220 --> 00:27:36,460
you'll see in my final wrap-up slides

00:27:35,020 --> 00:27:38,860
next steps that's something I haven't

00:27:36,460 --> 00:27:42,910
tried to this point because I was just

00:27:38,860 --> 00:27:45,130
happy to get my you boot stuff running

00:27:42,910 --> 00:27:48,300
so what can you do in you boot so what's

00:27:45,130 --> 00:27:52,240
this big deal about getting to a console

00:27:48,300 --> 00:27:55,300
you know booted over USB you boot well I

00:27:52,240 --> 00:27:56,860
can do a lot in USB I can read and write

00:27:55,300 --> 00:27:59,350
memory all over the place I can read and

00:27:56,860 --> 00:28:00,910
write files and on just about any sort

00:27:59,350 --> 00:28:03,090
of file system I can read them write

00:28:00,910 --> 00:28:09,100
them off the best ecards are USB sticks

00:28:03,090 --> 00:28:13,510
spy flash NAND flash and you know all

00:28:09,100 --> 00:28:15,970
all sorts of devices I'm now unable to

00:28:13,510 --> 00:28:18,250
go and and talk to and create scripts

00:28:15,970 --> 00:28:19,660
and do things so that I can verify my

00:28:18,250 --> 00:28:22,840
hardware

00:28:19,660 --> 00:28:27,020
you know before bringing it up into to

00:28:22,840 --> 00:28:28,910
Linux I can toggle GPIO I can

00:28:27,020 --> 00:28:32,870
you know just do generic I squared C or

00:28:28,910 --> 00:28:36,610
SPI accesses and the most importantly

00:28:32,870 --> 00:28:39,980
you know I can boot the kernel right

00:28:36,610 --> 00:28:42,470
there's currently a a bug in you boot

00:28:39,980 --> 00:28:44,360
with regards to net console that I

00:28:42,470 --> 00:28:48,260
haven't yet narrowed down but if you

00:28:44,360 --> 00:28:51,290
leave net console alive while doing TFTP

00:28:48,260 --> 00:28:55,430
you boot will crash

00:28:51,290 --> 00:28:59,900
so my workaround is to cut and paste

00:28:55,430 --> 00:29:03,320
this line in at the the end in order to

00:28:59,900 --> 00:29:07,040
boot my kernel right so I turn that

00:29:03,320 --> 00:29:11,510
console off but standard in and standard

00:29:07,040 --> 00:29:13,940
out I do my FTP transfers I then turn

00:29:11,510 --> 00:29:16,550
that console back on again

00:29:13,940 --> 00:29:18,440
and then I'm back at the prompt with the

00:29:16,550 --> 00:29:21,530
TFTP s happening in the background the

00:29:18,440 --> 00:29:23,630
meantime on my host I can watch things

00:29:21,530 --> 00:29:25,640
happen right because I see all the TT

00:29:23,630 --> 00:29:27,110
FTP transfers happening so I kind of

00:29:25,640 --> 00:29:30,620
still know everything's good and clean

00:29:27,110 --> 00:29:33,560
but I don't get my console back up until

00:29:30,620 --> 00:29:35,000
the end and then I can interactively

00:29:33,560 --> 00:29:36,860
just run these last few things though

00:29:35,000 --> 00:29:38,390
the RAM Marg just sets up the boot args

00:29:36,860 --> 00:29:39,830
and I'll show you that sets up the boot

00:29:38,390 --> 00:29:42,740
arcs for the kernel and then boot Z

00:29:39,830 --> 00:29:49,430
actually loads and runs the kernel so at

00:29:42,740 --> 00:29:52,760
that point at that point well okay this

00:29:49,430 --> 00:29:57,680
is where to get the code my github no -

00:29:52,760 --> 00:30:01,400
beagle boot it's on the net console fork

00:29:57,680 --> 00:30:02,900
or yeah branch

00:30:01,400 --> 00:30:04,820
sorry branch get might get terminology

00:30:02,900 --> 00:30:06,560
right so then doesn't net net console

00:30:04,820 --> 00:30:09,320
branch I've got it referred to by a

00:30:06,560 --> 00:30:11,570
build root build image so I can build

00:30:09,320 --> 00:30:13,750
kind of everything all in one place it

00:30:11,570 --> 00:30:15,530
builds my kernel my root filesystem and

00:30:13,750 --> 00:30:18,470
everything so I have something nice and

00:30:15,530 --> 00:30:20,120
reproducible for node beagle boat itself

00:30:18,470 --> 00:30:23,150
you get into that directory you do npm

00:30:20,120 --> 00:30:26,090
install sudo NPM starts you do need to

00:30:23,150 --> 00:30:30,140
point the bin folder into the build

00:30:26,090 --> 00:30:32,930
routes output images folder in order to

00:30:30,140 --> 00:30:34,820
get to them plug in my pocket beagle and

00:30:32,930 --> 00:30:36,290
then I'm at the net console prompt you

00:30:34,820 --> 00:30:38,500
believe me anybody thinks this is gonna

00:30:36,290 --> 00:30:38,500
work

00:30:38,890 --> 00:30:42,750
does does anybody think this is gonna

00:30:41,740 --> 00:30:47,980
work

00:30:42,750 --> 00:30:51,490
all right man you're way overconfident

00:30:47,980 --> 00:30:54,240
so I'm gonna I'm gonna so so I do have

00:30:51,490 --> 00:30:58,450
this other so I I talked about being

00:30:54,240 --> 00:31:00,790
without a serial debug net reality is

00:30:58,450 --> 00:31:02,440
I've got a thrill debug net it's it's

00:31:00,790 --> 00:31:04,870
hidden over there so I've got the head

00:31:02,440 --> 00:31:06,340
up on the console it's nice to kind of

00:31:04,870 --> 00:31:10,510
see things as we're going along but

00:31:06,340 --> 00:31:11,770
realize I'm not gonna to to do stuff

00:31:10,510 --> 00:31:15,580
over there other than to show you that

00:31:11,770 --> 00:31:17,440
this is make sure you know like this is

00:31:15,580 --> 00:31:21,280
currently running running Linux that I

00:31:17,440 --> 00:31:22,720
booted earlier but it's just gonna be

00:31:21,280 --> 00:31:26,260
sitting around there for for nice pretty

00:31:22,720 --> 00:31:30,900
information pictures this is the my let

00:31:26,260 --> 00:31:30,900
me control see this this is me running

00:31:31,110 --> 00:31:39,490
fat finger my keyboard I feel like I did

00:31:33,430 --> 00:31:42,000
yep and so that that's that's my my my

00:31:39,490 --> 00:31:47,020
node.js based server so I'm gonna click

00:31:42,000 --> 00:31:50,970
reset button and TFT peeing the run from

00:31:47,020 --> 00:31:54,730
the wrong TFT peeing the hole you boot

00:31:50,970 --> 00:31:56,590
you know then when you do the DHCP for

00:31:54,730 --> 00:31:59,950
some reason it immediately tries to

00:31:56,590 --> 00:32:04,930
transfer you boot image all the time as

00:31:59,950 --> 00:32:07,510
default my default boot our boot args so

00:32:04,930 --> 00:32:08,830
this this again this is this is run this

00:32:07,510 --> 00:32:09,880
that Windows running do wonder what

00:32:08,830 --> 00:32:11,230
you're looking at right here is running

00:32:09,880 --> 00:32:15,490
that console I can do print

00:32:11,230 --> 00:32:18,610
boot command this is what ran right so

00:32:15,490 --> 00:32:21,600
it did the DHCP that caused the boot

00:32:18,610 --> 00:32:24,580
image to run took to transfer over again

00:32:21,600 --> 00:32:27,970
that's just the way the DHCP thing seems

00:32:24,580 --> 00:32:34,660
to work I set my environment to the ncip

00:32:27,970 --> 00:32:36,430
to be the server I print server IP Edie

00:32:34,660 --> 00:32:41,370
lost it also needs you know because over

00:32:36,430 --> 00:32:44,050
DHCP it also got the print IP address

00:32:41,370 --> 00:32:47,050
the IP address for the the target device

00:32:44,050 --> 00:32:51,549
both of those were provided by the node

00:32:47,050 --> 00:32:54,679
program that answered the DHCP request

00:32:51,549 --> 00:32:57,470
so dhcp set the network environment then

00:32:54,679 --> 00:32:59,570
set the standard out so when i compiled

00:32:57,470 --> 00:33:02,419
you boots i conveyor it compiled it so

00:32:59,570 --> 00:33:04,070
that it would t so that you can can you

00:33:02,419 --> 00:33:05,929
can compiled you boots so that it has

00:33:04,070 --> 00:33:07,700
net console and then there's another

00:33:05,929 --> 00:33:10,130
extra configuration saying it says you

00:33:07,700 --> 00:33:11,990
can have more than one at a time so I

00:33:10,130 --> 00:33:14,929
can put a comma in there so I'm keeping

00:33:11,990 --> 00:33:17,470
a serial active so I haven't completely

00:33:14,929 --> 00:33:21,049
turned off my my debug net at this point

00:33:17,470 --> 00:33:25,910
my serial net and I set standard out

00:33:21,049 --> 00:33:27,710
standard error and a standard in all to

00:33:25,910 --> 00:33:29,059
be net console and then I printed

00:33:27,710 --> 00:33:31,100
version right you can see that the

00:33:29,059 --> 00:33:35,419
version of you boot printed on the

00:33:31,100 --> 00:33:36,770
screen hey it worked

00:33:35,419 --> 00:33:38,990
so at least two there right so we

00:33:36,770 --> 00:33:42,710
released now a new boot and I mentioned

00:33:38,990 --> 00:33:44,299
you could do a lot of things and you

00:33:42,710 --> 00:33:46,130
boot oh and this is kind of cool like

00:33:44,299 --> 00:33:47,299
anytime I type in here that's the over

00:33:46,130 --> 00:33:48,559
the ste report right it just

00:33:47,299 --> 00:33:53,000
automatically shows up on the net

00:33:48,559 --> 00:33:58,970
console over the UDP packets but I can

00:33:53,000 --> 00:34:00,950
do things like GPIO set 53 oh I've got a

00:33:58,970 --> 00:34:05,360
cape on the top of this but that turned

00:34:00,950 --> 00:34:09,800
on that turned on an LED under there 53

00:34:05,360 --> 00:34:11,480
is the user 0 LED oh I can't limitation

00:34:09,800 --> 00:34:15,040
sorry I'm so used to working at the

00:34:11,480 --> 00:34:19,369
serial port what I'm currently doing on

00:34:15,040 --> 00:34:21,350
in nodejs it's not actually going to

00:34:19,369 --> 00:34:25,570
capture any of the standard in until I

00:34:21,350 --> 00:34:29,119
press ENTER so I'm used to just typing

00:34:25,570 --> 00:34:30,710
its if if I edit my nodejs thing to

00:34:29,119 --> 00:34:32,419
actually grab live keys it would be

00:34:30,710 --> 00:34:34,940
sending those over because right now I

00:34:32,419 --> 00:34:37,429
can't press can't press the history and

00:34:34,940 --> 00:34:40,820
do all that that fun stuff but that's a

00:34:37,429 --> 00:34:43,510
that's a no js' side thing you've got a

00:34:40,820 --> 00:34:50,899
lot of commands in here too many to show

00:34:43,510 --> 00:34:56,990
I to see all right you where's the help

00:34:50,899 --> 00:35:00,710
that's not much help so I can do spi

00:34:56,990 --> 00:35:02,710
commands if I can remember the right one

00:35:00,710 --> 00:35:13,599
sspi

00:35:02,710 --> 00:35:21,900
1 : 1 bit length of 32 data out of 4000

00:35:13,599 --> 00:35:21,900
0 0 sounds good oh crap

00:35:22,690 --> 00:35:26,859
apparently that wasn't quite the right

00:35:24,250 --> 00:35:29,530
that they could to correct the right spi

00:35:26,859 --> 00:35:31,510
command line but um you know you could

00:35:29,530 --> 00:35:35,589
it's gonna try to turn on some more fun

00:35:31,510 --> 00:35:39,940
LEDs anyway brought me right back into

00:35:35,589 --> 00:35:42,609
here I'm I'm happy again you know if I

00:35:39,940 --> 00:35:44,859
plug in a USB Drive I did test like I

00:35:42,609 --> 00:35:49,119
could do USB start and unlist contents

00:35:44,859 --> 00:35:52,950
and discs there I can you know I print

00:35:49,119 --> 00:35:59,770
out what the the SPL has configured the

00:35:52,950 --> 00:36:01,780
what's the BD info oh yeah so you can

00:35:59,770 --> 00:36:03,790
see some of the stuff embedded in the

00:36:01,780 --> 00:36:05,589
info there's a there's a there's a lot

00:36:03,790 --> 00:36:08,500
of stuff that you could you can you can

00:36:05,589 --> 00:36:10,599
do from here to to to work with your

00:36:08,500 --> 00:36:12,069
target environment I'm gonna bring up a

00:36:10,599 --> 00:36:15,630
new board and they haven't had to add

00:36:12,069 --> 00:36:18,220
anything funky to your board I want to

00:36:15,630 --> 00:36:19,540
copy and paste that line let me see if I

00:36:18,220 --> 00:36:21,250
can do it from memory what's the chances

00:36:19,540 --> 00:36:26,410
I could do that the kernel boot from

00:36:21,250 --> 00:36:30,780
memory probably not very good standards

00:36:26,410 --> 00:36:34,780
standard out to cereal set environment

00:36:30,780 --> 00:36:35,859
standards into cereal I don't know I

00:36:34,780 --> 00:36:36,760
don't think I've to do standard error

00:36:35,859 --> 00:36:40,089
cause I don't think it tries to send

00:36:36,760 --> 00:36:45,869
anything across it TFTP the kernel into

00:36:40,089 --> 00:36:48,040
the load address the image TFTP the

00:36:45,869 --> 00:36:49,960
let's get the short one let's get the

00:36:48,040 --> 00:36:54,280
let's get the finite device tree first

00:36:49,960 --> 00:36:56,650
or flattened device tree sorry fly put

00:36:54,280 --> 00:37:02,530
the right number of DS in there am 3 3 3

00:36:56,650 --> 00:37:09,609
5 X pocket Beagle TTB TFTP the RAM disk

00:37:02,530 --> 00:37:12,590
the Rd ad are it's called rude FS that

00:37:09,609 --> 00:37:15,050
CPI Pio

00:37:12,590 --> 00:37:18,430
you boot has to be a boot packaged one

00:37:15,050 --> 00:37:20,390
of the 10-minute thank you

00:37:18,430 --> 00:37:22,040
at that point I should have everything

00:37:20,390 --> 00:37:25,210
loaded in memory so we're gonna set

00:37:22,040 --> 00:37:31,330
environment standard out back to serial

00:37:25,210 --> 00:37:36,020
comma neck console and set environment

00:37:31,330 --> 00:37:41,690
standard in back to serial and net

00:37:36,020 --> 00:37:42,800
console pray everybody prepared pray him

00:37:41,690 --> 00:37:46,550
if you got them I don't know is that

00:37:42,800 --> 00:37:49,160
quite work and now we're gonna actually

00:37:46,550 --> 00:37:53,590
go and do that the the TFTP transfers of

00:37:49,160 --> 00:37:56,600
all those of all those other images so

00:37:53,590 --> 00:37:58,790
while that's running this is a good

00:37:56,600 --> 00:38:00,560
point for a few questions because

00:37:58,790 --> 00:38:04,120
because this this is the meat of the

00:38:00,560 --> 00:38:04,120
demo this is this part - supposed to you

00:38:16,460 --> 00:38:20,940
I'm not in the colonel so you can't say

00:38:19,740 --> 00:38:22,560
that a lot needs to function in the

00:38:20,940 --> 00:38:29,840
colonel for this because I'm not in the

00:38:22,560 --> 00:38:29,840
colonel I'm in the bootloader so yeah

00:38:30,590 --> 00:38:34,770
yeah so that the the statement is is

00:38:33,450 --> 00:38:35,910
this isn't really that great for

00:38:34,770 --> 00:38:37,680
bringing up the colonel because if

00:38:35,910 --> 00:38:40,350
there's a bug in the kernel where it

00:38:37,680 --> 00:38:42,830
can't bring up memory you know I'm not

00:38:40,350 --> 00:38:52,260
gonna get any sort of useful feedback

00:38:42,830 --> 00:38:54,510
yes yes completely completely agree you

00:38:52,260 --> 00:38:57,990
artists you art is much easier from a

00:38:54,510 --> 00:39:00,030
from inside the kernel perspective you

00:38:57,990 --> 00:39:05,010
know my assertion is that this is

00:39:00,030 --> 00:39:08,940
becoming much more stable and that the

00:39:05,010 --> 00:39:10,050
the big thing from from our perspective

00:39:08,940 --> 00:39:12,119
is that some of the things like memory I

00:39:10,050 --> 00:39:13,890
mean in you boot I can do a lot of the

00:39:12,119 --> 00:39:16,260
the hardware testing like I could test

00:39:13,890 --> 00:39:19,650
the memory I can test all the the things

00:39:16,260 --> 00:39:22,619
that are really gonna fail at mostly at

00:39:19,650 --> 00:39:26,160
the at the hardware level from from a

00:39:22,619 --> 00:39:28,470
kernel and system level with the what

00:39:26,160 --> 00:39:31,350
makes this useful is using something

00:39:28,470 --> 00:39:32,940
like the the system in package that

00:39:31,350 --> 00:39:35,160
we're using on the pocket beagle because

00:39:32,940 --> 00:39:37,140
the things that we need for to get the

00:39:35,160 --> 00:39:39,320
kernel to run are all that you know very

00:39:37,140 --> 00:39:41,580
very static and very much the same

00:39:39,320 --> 00:39:44,369
between those systems the only thing

00:39:41,580 --> 00:39:48,540
that I have to have work to get back

00:39:44,369 --> 00:39:52,650
that the connection to the to the the

00:39:48,540 --> 00:39:54,420
processor is essentially the USB well

00:39:52,650 --> 00:39:55,950
everything at this point everything that

00:39:54,420 --> 00:40:00,140
would need for to wrote was already be

00:39:55,950 --> 00:40:03,540
tested by bringing it up in a new boot

00:40:00,140 --> 00:40:06,540
the SOC support is upstream the device

00:40:03,540 --> 00:40:08,790
tree I I can use a minimal device tree

00:40:06,540 --> 00:40:12,390
that doesn't configure anything outside

00:40:08,790 --> 00:40:15,359
of the the SIP except for the USB so I

00:40:12,390 --> 00:40:17,240
can get that kernel booted without any

00:40:15,359 --> 00:40:21,720
sort of other board level dependencies

00:40:17,240 --> 00:40:25,130
so yes in the case I bring up a really

00:40:21,720 --> 00:40:28,289
totally new architecture or a new

00:40:25,130 --> 00:40:30,690
you know a subsystem with with with

00:40:28,289 --> 00:40:32,910
different controllers this doesn't

00:40:30,690 --> 00:40:35,460
really scale well for bringing up new

00:40:32,910 --> 00:40:37,440
boards based on this system and package

00:40:35,460 --> 00:40:40,259
this is really enough

00:40:37,440 --> 00:40:42,839
in fact we've done like with basically

00:40:40,259 --> 00:40:44,640
this set of infrastructure you know

00:40:42,839 --> 00:40:54,690
board bring up for you know some odd

00:40:44,640 --> 00:40:57,509
twenty boards so the question is if you

00:40:54,690 --> 00:41:02,430
really want to use a USB connector why

00:40:57,509 --> 00:41:05,539
not use UART over USB that's a that's a

00:41:02,430 --> 00:41:09,089
pretty good question and the what what

00:41:05,539 --> 00:41:11,809
what spawned this off initially is the

00:41:09,089 --> 00:41:18,029
fact that the bootrom chose to use

00:41:11,809 --> 00:41:21,569
network over USB and and you know you're

00:41:18,029 --> 00:41:24,930
still either way on the the device side

00:41:21,569 --> 00:41:28,109
needing to bring up a USB stack and an

00:41:24,930 --> 00:41:29,579
unknown driver so does it matter too

00:41:28,109 --> 00:41:31,470
much if you're bringing up the serial

00:41:29,579 --> 00:41:35,009
drive the serial gadget driver or the

00:41:31,470 --> 00:41:36,720
serial network driver my assertion is it

00:41:35,009 --> 00:41:41,339
doesn't matter too much because those

00:41:36,720 --> 00:41:42,720
bits are pretty darn proven but from a

00:41:41,339 --> 00:41:44,309
practical standpoint it could reduce

00:41:42,720 --> 00:41:48,150
your host infrastructure if you use

00:41:44,309 --> 00:41:50,519
serial my big limitation though is I

00:41:48,150 --> 00:41:55,079
needed to do the the ARP the bootp all

00:41:50,519 --> 00:41:56,660
that other junk to handle the rom and

00:41:55,079 --> 00:41:58,440
and that there's no other real good

00:41:56,660 --> 00:42:00,359
justification for that other than the

00:41:58,440 --> 00:42:02,579
fact that I had to do them to handle the

00:42:00,359 --> 00:42:06,210
ROM code but before you boot loader

00:42:02,579 --> 00:42:07,470
loads and runs but my approach here is

00:42:06,210 --> 00:42:12,989
that because I had to do those things

00:42:07,470 --> 00:42:15,539
anyway why not keep doing them maybe I

00:42:12,989 --> 00:42:18,420
can bring up the the serial gadget and

00:42:15,539 --> 00:42:20,190
the kernel faster in the boot stream so

00:42:18,420 --> 00:42:23,069
I can get more of the printer print

00:42:20,190 --> 00:42:25,230
messages I really think the solution for

00:42:23,069 --> 00:42:27,920
getting early messages in the kernel is

00:42:25,230 --> 00:42:27,920
efi

00:42:32,630 --> 00:42:37,349
okay now that's a that's that's not

00:42:35,369 --> 00:42:39,750
that's not that's not quite right so

00:42:37,349 --> 00:42:42,329
that the comment was I could use a small

00:42:39,750 --> 00:42:48,029
hardware piece to essentially convert

00:42:42,329 --> 00:42:49,589
from the the target USB to some hardware

00:42:48,029 --> 00:42:51,569
serial where I can connect up hardware

00:42:49,589 --> 00:42:53,250
serial externally that's not quite right

00:42:51,569 --> 00:42:56,579
because at that point I still I have to

00:42:53,250 --> 00:42:59,900
have a host driver on the USB target

00:42:56,579 --> 00:43:01,890
anyway to get to serial so at that point

00:42:59,900 --> 00:43:05,099
you know because I've had to add

00:43:01,890 --> 00:43:07,380
external hardware there for it and I'm

00:43:05,099 --> 00:43:08,609
depending on at this point I'm depending

00:43:07,380 --> 00:43:10,859
on the infrastructure to actually go and

00:43:08,609 --> 00:43:14,519
you know act as the host and configure

00:43:10,859 --> 00:43:16,980
that that that UART I still need to

00:43:14,519 --> 00:43:19,200
depend on the system booting up to that

00:43:16,980 --> 00:43:23,009
point to get that it doesn't it doesn't

00:43:19,200 --> 00:43:28,890
come for free to turn that into a host

00:43:23,009 --> 00:43:30,569
port versus a slave for it the question

00:43:28,890 --> 00:43:32,700
is a common is you don't need USB at all

00:43:30,569 --> 00:43:33,809
on the target you just use a USB serial

00:43:32,700 --> 00:43:36,119
yes you're still connecting to the

00:43:33,809 --> 00:43:37,920
hardware serial on the target and that's

00:43:36,119 --> 00:43:41,430
a and if you look at what I've actually

00:43:37,920 --> 00:43:42,960
got what I'm actually using on here we

00:43:41,430 --> 00:43:44,579
don't do any of this in the production

00:43:42,960 --> 00:43:47,160
tester and we don't necessarily in a bit

00:43:44,579 --> 00:43:49,319
much on the board bring up occasionally

00:43:47,160 --> 00:43:52,259
we still do use USB serial but that's

00:43:49,319 --> 00:43:54,240
exactly what I have here this USB this

00:43:52,259 --> 00:43:56,430
USB side connection is actually on the

00:43:54,240 --> 00:44:00,869
top board is actually the USB to serial

00:43:56,430 --> 00:44:03,450
a converter that looks at the console so

00:44:00,869 --> 00:44:07,140
that's what's showing up in this and

00:44:03,450 --> 00:44:08,069
this other get my arrows in the right

00:44:07,140 --> 00:44:09,359
place

00:44:08,069 --> 00:44:11,099
that's what's showing up in that other

00:44:09,359 --> 00:44:13,829
window that's actually this USB to

00:44:11,099 --> 00:44:16,740
serial so that yes that's that's the

00:44:13,829 --> 00:44:19,650
state of it is today my aspirations for

00:44:16,740 --> 00:44:21,089
this talk is actually to encourage those

00:44:19,650 --> 00:44:24,180
people who help maintain these

00:44:21,089 --> 00:44:26,839
subsystems to look at these issues of

00:44:24,180 --> 00:44:30,329
bringing up something like USB gadget

00:44:26,839 --> 00:44:32,640
networking and net counsel very early

00:44:30,329 --> 00:44:34,470
looking at problems that consoles that

00:44:32,640 --> 00:44:36,450
are over it and translating those into

00:44:34,470 --> 00:44:38,240
the kernels and look at doing this

00:44:36,450 --> 00:44:41,990
really without the serial debug net

00:44:38,240 --> 00:44:44,270
because it you know that might not be a

00:44:41,990 --> 00:44:45,710
this year or this two years thing but

00:44:44,270 --> 00:44:48,290
like you know three or four years down

00:44:45,710 --> 00:44:50,390
the line we're gonna get into a

00:44:48,290 --> 00:44:53,420
situation we just don't need the

00:44:50,390 --> 00:44:57,170
usb-to-serial anymore it's it's it you

00:44:53,420 --> 00:44:58,550
know it's just like we don't weep for

00:44:57,170 --> 00:44:59,750
most of us in this room we don't need

00:44:58,550 --> 00:45:01,790
JTAG anymore

00:44:59,750 --> 00:45:03,920
right you know you're never not gonna

00:45:01,790 --> 00:45:05,390
need JTAG right there's somebody's gonna

00:45:03,920 --> 00:45:07,850
need J tags they're gonna need to get

00:45:05,390 --> 00:45:10,820
into the the shift registers of the

00:45:07,850 --> 00:45:15,640
device itself but I'd say that you know

00:45:10,820 --> 00:45:19,490
does anybody use J tag on a daily basis

00:45:15,640 --> 00:45:25,600
yeah so you're you're you're in the

00:45:19,490 --> 00:45:28,220
minority at this point you know so it's

00:45:25,600 --> 00:45:30,619
and that's and cereal is gonna go that

00:45:28,220 --> 00:45:33,590
way too and that's that I'm trying to

00:45:30,619 --> 00:45:38,000
start trying that vector because cereal

00:45:33,590 --> 00:45:40,070
is gonna go that that way as well and

00:45:38,000 --> 00:45:42,550
not that it's not that it's not needed I

00:45:40,070 --> 00:45:44,840
you know occasionally I still need JTAG

00:45:42,550 --> 00:45:46,460
but it's it's tends to be very

00:45:44,840 --> 00:45:47,980
specialized and very early on in the

00:45:46,460 --> 00:45:50,060
direction where just there's just more

00:45:47,980 --> 00:45:52,700
infrastructure that's being already

00:45:50,060 --> 00:45:55,640
brought up and before you know people

00:45:52,700 --> 00:45:58,670
are doing board level system designs I

00:45:55,640 --> 00:46:01,100
mean I mean let me conclusion here let

00:45:58,670 --> 00:46:04,790
me just show the the kernel running so I

00:46:01,100 --> 00:46:05,930
loaded everything let me do what's the

00:46:04,790 --> 00:46:11,350
first thing I need to do to load the

00:46:05,930 --> 00:46:14,840
kernel should know this Oh run remarks

00:46:11,350 --> 00:46:17,390
now what does this setup boot orgs so

00:46:14,840 --> 00:46:27,170
dads are saying boot orgs and I do boot

00:46:17,390 --> 00:46:29,869
Z load address and device tree so the

00:46:27,170 --> 00:46:32,630
RAM disk and the device tree and at that

00:46:29,869 --> 00:46:34,340
point in all practical purposes because

00:46:32,630 --> 00:46:36,290
I haven't done the EFI thing I don't

00:46:34,340 --> 00:46:38,660
have the early kernel stuff my net

00:46:36,290 --> 00:46:41,540
console stuff becomes largely useless

00:46:38,660 --> 00:46:42,950
and but we can go over here to the

00:46:41,540 --> 00:46:47,869
cereal stuff we see the kernel is

00:46:42,950 --> 00:46:50,090
booting right up and I've got a ram disk

00:46:47,869 --> 00:46:52,250
you know root filesystem up and I'm

00:46:50,090 --> 00:46:56,610
loading I'm running Linux entirely

00:46:52,250 --> 00:46:59,670
booted over USB no SD car

00:46:56,610 --> 00:47:02,850
you know that that's straight from from

00:46:59,670 --> 00:47:06,650
blue ROM there's no boot medium on that

00:47:02,850 --> 00:47:17,370
device it's just USB all from a

00:47:06,650 --> 00:47:19,320
JavaScript app yeah so next steps look

00:47:17,370 --> 00:47:20,760
this this is this is the some of the

00:47:19,320 --> 00:47:22,280
motivation right so actually point to

00:47:20,760 --> 00:47:25,170
the problem so thank you actually for

00:47:22,280 --> 00:47:26,250
playing it because it's not ready for

00:47:25,170 --> 00:47:29,520
primetime

00:47:26,250 --> 00:47:31,710
I mentioned the config FS thing you know

00:47:29,520 --> 00:47:34,500
what I plan to try is G multi to see if

00:47:31,710 --> 00:47:37,560
I can get it earlier on initially and

00:47:34,500 --> 00:47:39,650
then going from there to EFI I don't

00:47:37,560 --> 00:47:42,540
understand it today but my understanding

00:47:39,650 --> 00:47:45,060
belief is is that it does provide some

00:47:42,540 --> 00:47:47,970
way to extend the console from the

00:47:45,060 --> 00:47:49,980
bootloader into that to the kernel for

00:47:47,970 --> 00:47:52,230
initial boots we can keep that open

00:47:49,980 --> 00:47:54,060
I mentioned the crash if you leave the

00:47:52,230 --> 00:47:58,890
the net console live are trying to do

00:47:54,060 --> 00:48:00,450
the TFTP and then also just integrating

00:47:58,890 --> 00:48:02,850
in this into more things now we've kind

00:48:00,450 --> 00:48:04,500
of got this root framework we want to

00:48:02,850 --> 00:48:06,390
try to make sure it runs on different

00:48:04,500 --> 00:48:08,490
host architectures because the I mean

00:48:06,390 --> 00:48:09,840
that the the torpedo here is getting

00:48:08,490 --> 00:48:12,480
people running Windows and Mac systems

00:48:09,840 --> 00:48:14,550
to try out Linux right so this gives you

00:48:12,480 --> 00:48:18,000
a way to to have them do that without

00:48:14,550 --> 00:48:20,310
having any real infrastructure and you

00:48:18,000 --> 00:48:21,840
know that using etchers for turning on

00:48:20,310 --> 00:48:24,090
flashing to the other sort of automation

00:48:21,840 --> 00:48:26,580
web USB if you want to learn more about

00:48:24,090 --> 00:48:31,020
UEFI last year alexandra graph gabe

00:48:26,580 --> 00:48:32,730
regret talk so and that's it I don't

00:48:31,020 --> 00:48:34,560
think I have any questions for time for

00:48:32,730 --> 00:48:36,930
questions I think I'm over if you want

00:48:34,560 --> 00:48:40,770
to find me I will be at the technical

00:48:36,930 --> 00:48:43,260
showcase tomorrow please come by and see

00:48:40,770 --> 00:48:45,510
me there I'll also go stand at the back

00:48:43,260 --> 00:48:48,480
of the room if you have any questions

00:48:45,510 --> 00:48:49,890
for me to today really appreciate your

00:48:48,480 --> 00:48:54,030
time and your patience I hope you

00:48:49,890 --> 00:48:56,089
enjoyed that and are inspired thank you

00:48:54,030 --> 00:48:56,089

YouTube URL: https://www.youtube.com/watch?v=9CxfKfjykz4


