Title: Industrial I O and You: Nonsense Hacks! - Matt Ranostay, Konsulko Group
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Industrial I/O and You: Nonsense Hacks! - Matt Ranostay, Konsulko Group

Learn about how to develop an Industrial I/O subsystem driver for an entirely new sensor, and how userspace HALs can process data with reduce system I/O than a pure "userspace driver". Some of the things that will be covered is iio channel consumers + definition, SW + HW triggers, and ring buffer interface. There will be some in-depth overview of the development API to implement a new driver, or add functionality to an existing iio driver. Also will demo of several sensors using the various functionality of iio, including but not limited to hrtimer sw triggers, and buffered data to userspace HALs.

About Matt Ranostay
Matt has worked in the Embedded Linux field in various roles for 10+ years at various companies including Embedded Alley, Mentor Graphics, and Intel's Open Source Technology Center.
Captions: 
	00:00:00,560 --> 00:00:06,020
okay a little thing we get started a my

00:00:04,350 --> 00:00:08,580
name is Pat RINO stay

00:00:06,020 --> 00:00:11,040
thanks kind of my talk about industrial

00:00:08,580 --> 00:00:17,250
IO subsystem and how you can use it for

00:00:11,040 --> 00:00:19,710
sensors and other other applications so

00:00:17,250 --> 00:00:22,020
I've been a contributor to Ino for about

00:00:19,710 --> 00:00:24,150
two years pretty much any of the weird

00:00:22,020 --> 00:00:26,160
chemical sensors have you seen on the

00:00:24,150 --> 00:00:30,269
list and that that's me

00:00:26,160 --> 00:00:31,949
also pH gas sensors feel free to ask

00:00:30,269 --> 00:00:37,530
questions during the talk I generally

00:00:31,949 --> 00:00:38,640
talk pretty fast so yeah so for those

00:00:37,530 --> 00:00:42,390
who don't know what the industrial i/o

00:00:38,640 --> 00:00:46,399
subsystem is it's just subsystem mainly

00:00:42,390 --> 00:00:48,930
for sensors that that don't fit into a

00:00:46,399 --> 00:00:51,780
hardware monitor or subsystem mainly

00:00:48,930 --> 00:00:57,600
stuff that's very high high frequency

00:00:51,780 --> 00:01:02,430
updates like a TCS detail has triggers

00:00:57,600 --> 00:01:04,019
sampling you know also FIFO buffers an

00:01:02,430 --> 00:01:06,540
advantage of using IO

00:01:04,019 --> 00:01:09,240
instead of like miscellaneous devices

00:01:06,540 --> 00:01:13,979
there's a stable API for a user space

00:01:09,240 --> 00:01:16,170
help live i/o is so what is the official

00:01:13,979 --> 00:01:18,830
preferred one I have a demo later on

00:01:16,170 --> 00:01:23,790
using live live IO

00:01:18,830 --> 00:01:27,509
communicating to a digital oximeter it's

00:01:23,790 --> 00:01:31,020
a simple API course that's an IV holder

00:01:27,509 --> 00:01:34,290
I guess to each development sensors a

00:01:31,020 --> 00:01:36,390
lot of boilerplate code exist and since

00:01:34,290 --> 00:01:41,369
most sensors are I to see or spy

00:01:36,390 --> 00:01:43,259
generally there's a lot of reuse and

00:01:41,369 --> 00:01:50,670
like said it only needs generally slight

00:01:43,259 --> 00:01:52,439
modifications so basically these are all

00:01:50,670 --> 00:01:54,930
mostly sensors but there's a few things

00:01:52,439 --> 00:01:58,259
that aren't sensors that actually have

00:01:54,930 --> 00:02:01,680
IO drivers a example would be kilometers

00:01:58,259 --> 00:02:03,750
there's a few of those Dax and clock

00:02:01,680 --> 00:02:07,770
generators these would generally end up

00:02:03,750 --> 00:02:11,370
in des miscellaneous but since the ABI

00:02:07,770 --> 00:02:14,120
their changes and like per device it's

00:02:11,370 --> 00:02:14,120
better to use IO

00:02:14,450 --> 00:02:20,490
also Android devices have been slowly

00:02:16,560 --> 00:02:28,800
going from the dead misc and input

00:02:20,490 --> 00:02:31,080
drivers input to using iio so here's

00:02:28,800 --> 00:02:35,959
some of the examples of sensor types at

00:02:31,080 --> 00:02:38,870
the i/o has sport for various drivers

00:02:35,959 --> 00:02:43,980
seller ometer cyrus copes manometers so

00:02:38,870 --> 00:02:46,230
IMU devices by temperature and humidity

00:02:43,980 --> 00:02:49,950
devices but they don't fit into a harbor

00:02:46,230 --> 00:02:51,200
monitor basically have high updates like

00:02:49,950 --> 00:02:53,160
hundred hertz a second

00:02:51,200 --> 00:02:57,050
otherwise you should go into hardware

00:02:53,160 --> 00:02:59,850
monitor a lot of ambient light sensors

00:02:57,050 --> 00:03:02,040
gesture sensors so that's kind of like a

00:02:59,850 --> 00:03:05,130
thing i would normally go into input but

00:03:02,040 --> 00:03:08,870
there's a lot of high-speed data coming

00:03:05,130 --> 00:03:12,000
off at NIEHS processing and user space

00:03:08,870 --> 00:03:16,730
some chemical sensors health sensors

00:03:12,000 --> 00:03:16,730
like my demo later on insects eMeter yep

00:03:18,540 --> 00:03:22,769
well that's just coming up but basically

00:03:20,549 --> 00:03:25,590
llm centers that's using hardware

00:03:22,769 --> 00:03:27,420
monitors so it's pretty limited to like

00:03:25,590 --> 00:03:30,510
humidity and temperature sensors inside

00:03:27,420 --> 00:03:31,920
of like it's server chassis yeah for i/o

00:03:30,510 --> 00:03:33,360
you wouldn't use that you would use it

00:03:31,920 --> 00:03:36,239
for something more like a thermocouple

00:03:33,360 --> 00:03:40,290
that has like a probe it can be updated

00:03:36,239 --> 00:03:45,750
really fast yeah there's also some sense

00:03:40,290 --> 00:03:49,620
sensor hub code so here's a little

00:03:45,750 --> 00:03:52,440
overview that i'll go over is an i/o

00:03:49,620 --> 00:03:54,720
channels the triggers that you can use

00:03:52,440 --> 00:03:58,910
for i/o other software hardware based

00:03:54,720 --> 00:04:01,739
ones the data buffers since these are

00:03:58,910 --> 00:04:04,470
since these are coming off a spy in IG c

00:04:01,739 --> 00:04:06,570
there's a good chance that some data can

00:04:04,470 --> 00:04:09,870
get dropped so this allows would be

00:04:06,570 --> 00:04:10,380
gracefully dropped since if you lose it

00:04:09,870 --> 00:04:13,829
you lose it

00:04:10,380 --> 00:04:15,930
like from abc's data also there's

00:04:13,829 --> 00:04:17,400
single-shot data access for like this

00:04:15,930 --> 00:04:19,620
temperature you don't need to setup with

00:04:17,400 --> 00:04:21,120
buffer or any triggers to actually start

00:04:19,620 --> 00:04:26,210
reading

00:04:21,120 --> 00:04:28,280
there's i/o events for base for like

00:04:26,210 --> 00:04:30,979
fall like a fall detection from an

00:04:28,280 --> 00:04:34,220
assault from a solver ometer from a

00:04:30,979 --> 00:04:36,680
phone so you can have interrupt there's

00:04:34,220 --> 00:04:40,130
also a channel consumers so other other

00:04:36,680 --> 00:04:42,160
devices other drivers and from different

00:04:40,130 --> 00:04:44,570
kernel subsystems can excess i/o

00:04:42,160 --> 00:04:47,630
channels which is useful for like

00:04:44,570 --> 00:04:51,460
battery chargers you get a voltage from

00:04:47,630 --> 00:05:01,430
ADC and you can tell to stop charging

00:04:51,460 --> 00:05:03,260
take increased charging well it's not

00:05:01,430 --> 00:05:06,500
really that means you can you can't have

00:05:03,260 --> 00:05:09,380
triggers set up but it's more to keep it

00:05:06,500 --> 00:05:14,479
more of a concise API because versus

00:05:09,380 --> 00:05:20,990
writing one off ADC driver so yeah the

00:05:14,479 --> 00:05:24,260
answer questions are no later on so so

00:05:20,990 --> 00:05:26,300
basically i/o driver the steps as you

00:05:24,260 --> 00:05:28,190
should really think should can this be a

00:05:26,300 --> 00:05:31,099
hardware monitor driver because on the

00:05:28,190 --> 00:05:34,490
list generally if there's no good reason

00:05:31,099 --> 00:05:35,840
you'll generally get rejected and you'll

00:05:34,490 --> 00:05:38,120
need to rewrite a hardware monitor so

00:05:35,840 --> 00:05:40,460
basically anything it's doing a an

00:05:38,120 --> 00:05:43,250
update every couple seconds or like once

00:05:40,460 --> 00:05:47,330
a second that should not be IO driver

00:05:43,250 --> 00:05:49,550
for temperature or humidity sensors now

00:05:47,330 --> 00:05:52,750
for anything else that could be

00:05:49,550 --> 00:05:55,970
debatable but yeah you should also

00:05:52,750 --> 00:05:59,360
deduce what interface to the chip is if

00:05:55,970 --> 00:06:02,889
it's IPC spy GPIO bit banging there's a

00:05:59,360 --> 00:06:05,330
few of those temperature sensors and uh

00:06:02,889 --> 00:06:07,520
also should it be you should use reg map

00:06:05,330 --> 00:06:10,990
or you should just do overall I can see

00:06:07,520 --> 00:06:14,240
our spy read generally shouldn't but and

00:06:10,990 --> 00:06:16,669
if there's any interrupt lines up you

00:06:14,240 --> 00:06:18,530
can use that as a trigger for signaling

00:06:16,669 --> 00:06:22,789
to user space there's data that needs to

00:06:18,530 --> 00:06:24,289
be read from the buffer so they can that

00:06:22,789 --> 00:06:25,910
would be a hardware trigger an example

00:06:24,289 --> 00:06:28,910
software trigger there's a high

00:06:25,910 --> 00:06:31,580
resolution timer one so you keep it

00:06:28,910 --> 00:06:34,610
basically you can pull the sensor which

00:06:31,580 --> 00:06:36,400
is using but using the a charge timer so

00:06:34,610 --> 00:06:38,159
you can have kind of a deterministic

00:06:36,400 --> 00:06:40,169
reading

00:06:38,159 --> 00:06:41,610
that's using blue of an interrupt line

00:06:40,169 --> 00:06:46,889
or if you don't have like internet

00:06:41,610 --> 00:06:51,300
flooding and also another IO driver can

00:06:46,889 --> 00:06:55,080
trigger another IO driver a few examples

00:06:51,300 --> 00:06:57,239
of that also ADCs

00:06:55,080 --> 00:06:58,979
generally should export the export their

00:06:57,239 --> 00:07:02,779
arm channels so other consumers can use

00:06:58,979 --> 00:07:02,779
it like example of a battery charger

00:07:02,899 --> 00:07:12,409
single Shh there's single shot readings

00:07:05,369 --> 00:07:17,069
or there's a triggered Cape kf5 buffers

00:07:12,409 --> 00:07:20,459
and you should determine if this new

00:07:17,069 --> 00:07:24,050
channel type for since I owe for the

00:07:20,459 --> 00:07:27,479
chemical sensors we need to add IO pH

00:07:24,050 --> 00:07:34,369
channel modifier I'll channel channel

00:07:27,479 --> 00:07:34,369
type and a few modifiers yeah

00:07:48,280 --> 00:07:59,960
yeah well if you need the samples and a

00:07:57,650 --> 00:08:02,030
buffer trick really fast if you're doing

00:07:59,960 --> 00:08:04,190
like single shot read only you probably

00:08:02,030 --> 00:08:05,509
just do hardware monitor but that's the

00:08:04,190 --> 00:08:07,639
only if it's a temperature or humidity

00:08:05,509 --> 00:08:10,370
sensor or something of something that

00:08:07,639 --> 00:08:12,229
goes into LM sensors effectively yeah

00:08:10,370 --> 00:08:15,199
okay so there's no if there's no

00:08:12,229 --> 00:08:17,919
requirement to use via we know the

00:08:15,199 --> 00:08:17,919
buffer itself

00:08:28,889 --> 00:08:34,169
I don't think there's like a written

00:08:32,669 --> 00:08:36,209
rule but if it's like over a couple

00:08:34,169 --> 00:08:38,519
Hertz yeah just going to go each

00:08:36,209 --> 00:08:41,490
probably zyo because otherwise you're

00:08:38,519 --> 00:08:44,219
just pulling a suspense it's too fast

00:08:41,490 --> 00:08:50,670
entry and hardware mind so that's

00:08:44,219 --> 00:08:54,660
generally wild latency yeah like I said

00:08:50,670 --> 00:08:57,899
so the hm-hm on some doesn't subsystem

00:08:54,660 --> 00:09:00,200
doesn't fit into the sensor usage just

00:08:57,899 --> 00:09:03,450
like the typically low speed sensors

00:09:00,200 --> 00:09:06,420
yeah use that otherwise IO is probably

00:09:03,450 --> 00:09:07,800
best bad for you like I said if the

00:09:06,420 --> 00:09:11,579
sensor dad needs to be term mystic

00:09:07,800 --> 00:09:13,649
because you can't really know how long

00:09:11,579 --> 00:09:15,750
it's going to take to read from you know

00:09:13,649 --> 00:09:19,170
sis if it's a tree how what the

00:09:15,750 --> 00:09:21,420
timestamp is IO allows to have like soft

00:09:19,170 --> 00:09:23,970
timestamp and a hard time stamp a part

00:09:21,420 --> 00:09:26,880
of the sample so you can kind which is

00:09:23,970 --> 00:09:30,720
important for certain ADCs and other

00:09:26,880 --> 00:09:33,930
applications and also it will start

00:09:30,720 --> 00:09:39,149
dropping samples instead of trying to

00:09:33,930 --> 00:09:41,459
keep up into the FIFO so that so like if

00:09:39,149 --> 00:09:43,800
you lose ADC samples it you can't really

00:09:41,459 --> 00:09:48,060
get to recover gracefully so the best

00:09:43,800 --> 00:09:50,010
way is just just ignore them except

00:09:48,060 --> 00:09:57,079
battery chargers on this example of

00:09:50,010 --> 00:09:59,459
using I oh that's us okay so this is a

00:09:57,079 --> 00:10:02,220
this is a struct at to how you define

00:09:59,459 --> 00:10:05,490
channels so channel would be like one

00:10:02,220 --> 00:10:09,810
temperature elements or once you made

00:10:05,490 --> 00:10:14,339
the element like or one voltage a couple

00:10:09,810 --> 00:10:17,160
voltage elements for a DC so and the

00:10:14,339 --> 00:10:19,740
naming is backwards compatible with

00:10:17,160 --> 00:10:24,390
harbor monitor so so there's an

00:10:19,740 --> 00:10:26,730
advantage of that here it's like set

00:10:24,390 --> 00:10:28,649
examples there's a modifiers type

00:10:26,730 --> 00:10:32,730
modifiers for what kind of data you want

00:10:28,649 --> 00:10:35,850
temperature humidity like I owe 10 and

00:10:32,730 --> 00:10:41,579
also modifiers on top of that so for

00:10:35,850 --> 00:10:42,220
instance in the rio rye-oh concentration

00:10:41,579 --> 00:10:45,540
i had

00:10:42,220 --> 00:10:49,770
a modifier for co2 gas and also for

00:10:45,540 --> 00:10:52,360
volatile organic compounds to to up to

00:10:49,770 --> 00:10:57,430
to allow you to know what what this

00:10:52,360 --> 00:10:59,350
channel actually means and also there's

00:10:57,430 --> 00:11:02,350
a bit mask for the numeration of the

00:10:59,350 --> 00:11:04,660
features so there's generally you won't

00:11:02,350 --> 00:11:06,820
have data sent out raw and the userspace

00:11:04,660 --> 00:11:08,580
does the processing but there's some

00:11:06,820 --> 00:11:11,290
times where that's not possible because

00:11:08,580 --> 00:11:14,680
there's some coefficient that's only

00:11:11,290 --> 00:11:17,470
valid then so then you would do i o

00:11:14,680 --> 00:11:20,650
channel co processed or if the debt or

00:11:17,470 --> 00:11:25,080
if that in the raw data is in the right

00:11:20,650 --> 00:11:27,670
unit for io and ABI and there's usually

00:11:25,080 --> 00:11:29,800
sometimes there's an offset value it's

00:11:27,670 --> 00:11:33,430
like from a datasheet also a scaling

00:11:29,800 --> 00:11:35,350
value that you've multiplied the actual

00:11:33,430 --> 00:11:39,940
raw value by to get the actual result in

00:11:35,350 --> 00:11:41,590
userspace generally the direction of the

00:11:39,940 --> 00:11:44,080
channels are inputs but there's a few

00:11:41,590 --> 00:11:47,770
example of outputs one is like a heater

00:11:44,080 --> 00:11:50,740
control for a humidity sensor i think

00:11:47,770 --> 00:11:53,070
it's the only one currently but they can

00:11:50,740 --> 00:11:53,070
be bi-directional

00:11:57,800 --> 00:12:06,920
you generally get that from the

00:11:59,360 --> 00:12:08,209
datasheet of the sensor yeah yeah no no

00:12:06,920 --> 00:12:11,089
that's why you write an entirely

00:12:08,209 --> 00:12:13,370
different driver to that or you have a

00:12:11,089 --> 00:12:19,610
different like ship struck just for that

00:12:13,370 --> 00:12:21,200
one the filters generally do that user

00:12:19,610 --> 00:12:22,640
space so if you don't you don't want to

00:12:21,200 --> 00:12:25,040
touch that that's why you generally do

00:12:22,640 --> 00:12:30,649
the stuff in raw and not processed

00:12:25,040 --> 00:12:32,870
unless you've need to so here's an

00:12:30,649 --> 00:12:35,810
example of a channel structure that

00:12:32,870 --> 00:12:40,190
would you find an i/o driver so this is

00:12:35,810 --> 00:12:42,860
a thermocouple so you see the type is a

00:12:40,190 --> 00:12:46,670
temperature the address is just kind of

00:12:42,860 --> 00:12:48,649
internal internal to the struct it could

00:12:46,670 --> 00:12:52,579
be the address of you know ICC address

00:12:48,649 --> 00:12:57,980
or I mean I to see a register I think

00:12:52,579 --> 00:12:59,959
this case it's a spy offset then it's

00:12:57,980 --> 00:13:02,540
just saying that the the mask is

00:12:59,959 --> 00:13:05,390
separate which between this data type io

00:13:02,540 --> 00:13:08,480
temperature it's for all data and

00:13:05,390 --> 00:13:11,149
there's a scaling value which you would

00:13:08,480 --> 00:13:14,060
find later in your driver in a one

00:13:11,149 --> 00:13:16,190
function and it tells you to scan index

00:13:14,060 --> 00:13:20,240
which since generally this is a block of

00:13:16,190 --> 00:13:23,510
data you need to know what the data is

00:13:20,240 --> 00:13:27,130
pushed to the buffer to user space what

00:13:23,510 --> 00:13:32,360
offset in that and the data is that

00:13:27,130 --> 00:13:34,550
information and the scan type says the

00:13:32,360 --> 00:13:39,110
data is coming in a cheetah process is a

00:13:34,550 --> 00:13:42,199
sign bit signed fourteen bit value but

00:13:39,110 --> 00:13:44,899
it takes 16 bits of storage in the

00:13:42,199 --> 00:13:47,690
actual read so you need to shift it two

00:13:44,899 --> 00:13:50,720
to the right and it tells you the

00:13:47,690 --> 00:13:53,720
endianness so you know which processing

00:13:50,720 --> 00:13:58,100
you need to do on your cpu if you need

00:13:53,720 --> 00:14:00,800
to change endianness or not yeah so

00:13:58,100 --> 00:14:02,360
here's the second channel kind of like

00:14:00,800 --> 00:14:06,470
this is similar to the first one but you

00:14:02,360 --> 00:14:08,630
notice there's a modifier so the ambient

00:14:06,470 --> 00:14:10,170
modifier in this case we use it for the

00:14:08,630 --> 00:14:12,630
cold Junction temperature

00:14:10,170 --> 00:14:13,920
since thermocouples have the probe

00:14:12,630 --> 00:14:16,860
temperature and they also have the cold

00:14:13,920 --> 00:14:19,020
Junction temperature that really useful

00:14:16,860 --> 00:14:20,490
but it's nice to have it's not really

00:14:19,020 --> 00:14:23,610
useful for user space to know that but

00:14:20,490 --> 00:14:30,540
it's nice to have so and you can see

00:14:23,610 --> 00:14:32,730
though there's also the salt soft time

00:14:30,540 --> 00:14:43,710
stamp so it's not it just what the clock

00:14:32,730 --> 00:14:46,620
has at that time yeah that's actually

00:14:43,710 --> 00:14:48,720
defined in the a/b is what does with

00:14:46,620 --> 00:14:51,590
what the raw value times the scale value

00:14:48,720 --> 00:14:51,590
what that equals

00:15:00,780 --> 00:15:05,820
yeah yeah the scale of this the scaling

00:15:04,170 --> 00:15:09,170
of the the the scaling value should

00:15:05,820 --> 00:15:13,020
match to what to make it to every sum

00:15:09,170 --> 00:15:15,270
every datatype the same yeah yeah I mean

00:15:13,020 --> 00:15:17,970
it's some of its kind of arbitrary

00:15:15,270 --> 00:15:19,620
because like it's noble Celsius to be

00:15:17,970 --> 00:15:24,530
backwards compatible with a harbor

00:15:19,620 --> 00:15:27,590
monitor yeah and yeah it's all document

00:15:24,530 --> 00:15:30,450
whatever whatever the API says yeah yeah

00:15:27,590 --> 00:15:33,180
so there's a few different kind of

00:15:30,450 --> 00:15:36,930
triggers on hardware base one could be

00:15:33,180 --> 00:15:39,420
GPIO interrupts or some other sort of

00:15:36,930 --> 00:15:42,480
hardware based interrupts the software

00:15:39,420 --> 00:15:44,460
based ones there's a success this is SH

00:15:42,480 --> 00:15:46,920
one which is just echo one into a

00:15:44,460 --> 00:15:51,840
trigger it's not really that useful for

00:15:46,920 --> 00:15:53,310
debugging the HR timer for ones that

00:15:51,840 --> 00:15:56,490
don't have interrupt line or if you just

00:15:53,310 --> 00:15:58,520
want to pull it as certain interval they

00:15:56,490 --> 00:16:00,690
have to have be pushed into the buffer

00:15:58,520 --> 00:16:04,140
and triggers can be mapped to multiple

00:16:00,690 --> 00:16:10,710
devices like the sample HR timer can be

00:16:04,140 --> 00:16:14,220
used on multiple i/o devices and the GS

00:16:10,710 --> 00:16:17,490
extend signals to each other and also

00:16:14,220 --> 00:16:21,090
they can up yes with the IO trigger pull

00:16:17,490 --> 00:16:26,970
call and a driver can be a provider or a

00:16:21,090 --> 00:16:29,850
consumer of a trigger as well okay so

00:16:26,970 --> 00:16:35,340
the buffers the overview is the data is

00:16:29,850 --> 00:16:37,020
usually not processed so so the channels

00:16:35,340 --> 00:16:38,910
need to have some fritters figuration

00:16:37,020 --> 00:16:43,020
describe a few points that was the part

00:16:38,910 --> 00:16:45,020
in the struct before the scan types so

00:16:43,020 --> 00:16:48,510
you need two storage size the real size

00:16:45,020 --> 00:16:51,750
the left but actually the right shifting

00:16:48,510 --> 00:16:55,380
avetis should be watched you think the

00:16:51,750 --> 00:16:59,580
endianness with the buck data is usually

00:16:55,380 --> 00:17:01,950
a per all read this past user space and

00:16:59,580 --> 00:17:08,360
it's up to the user space how to decode

00:17:01,950 --> 00:17:08,360
it which split io does for you

00:17:08,850 --> 00:17:15,730
so the buffers are k5o back so stuff

00:17:14,290 --> 00:17:17,560
will start being dropped until you start

00:17:15,730 --> 00:17:18,809
reading them from it again

00:17:17,560 --> 00:17:21,730
[Music]

00:17:18,809 --> 00:17:25,510
so trigger buffers from you know

00:17:21,730 --> 00:17:27,970
software hardware events as well you can

00:17:25,510 --> 00:17:30,190
you can configure the sample size for

00:17:27,970 --> 00:17:33,190
the for the buffer it's going to be a

00:17:30,190 --> 00:17:37,920
power of two I think so how many samples

00:17:33,190 --> 00:17:40,420
you want there's poor device buffers so

00:17:37,920 --> 00:17:42,640
there's trigger buffers and there's just

00:17:40,420 --> 00:17:46,540
buffers that don't have triggers that

00:17:42,640 --> 00:17:48,910
are externally visible example will be a

00:17:46,540 --> 00:17:52,200
device this doesn't have one because

00:17:48,910 --> 00:17:56,440
it's a FIFO that just gets interrupt and

00:17:52,200 --> 00:17:59,260
pushes it into that so there's no hard

00:17:56,440 --> 00:18:02,110
wah HR timer support or anything that

00:17:59,260 --> 00:18:05,920
you can use there's callback buffers

00:18:02,110 --> 00:18:10,120
this disallow some I our drivers to send

00:18:05,920 --> 00:18:12,700
data processed to another driver sounds

00:18:10,120 --> 00:18:15,100
like it's really used except for like

00:18:12,700 --> 00:18:17,620
one one sensor I think because it's

00:18:15,100 --> 00:18:20,559
getting data from a DC and it's doing a

00:18:17,620 --> 00:18:22,600
conversion because it has some

00:18:20,559 --> 00:18:27,870
configuration that needed some member

00:18:22,600 --> 00:18:32,400
correctly okay so here's a here's a

00:18:27,870 --> 00:18:36,730
buffer trigger handler so it's basically

00:18:32,400 --> 00:18:39,700
this is GPIO so you know no actually

00:18:36,730 --> 00:18:41,800
this is one of the HR timer ones so you

00:18:39,700 --> 00:18:45,910
said generally set the polling to 100

00:18:41,800 --> 00:18:47,950
Hertz and so 100 times a second this

00:18:45,910 --> 00:18:51,610
gets called so it's a wide our

00:18:47,950 --> 00:18:54,610
measurement to the buffers then it

00:18:51,610 --> 00:18:57,640
pushes it with the timestamp soft

00:18:54,610 --> 00:19:00,010
timestamp and it notifies user space

00:18:57,640 --> 00:19:06,390
that it's completed the trigger so can

00:19:00,010 --> 00:19:06,390
read then it notifies it's handled

00:19:08,109 --> 00:19:14,559
single shot access in the case of you

00:19:12,219 --> 00:19:17,379
can read the temperature and humidity

00:19:14,559 --> 00:19:19,659
directly or the voltage MATC but

00:19:17,379 --> 00:19:21,729
obviously it's not deterministic when

00:19:19,659 --> 00:19:27,399
that happened and it's generally not

00:19:21,729 --> 00:19:28,929
good to pull it some some data can't be

00:19:27,399 --> 00:19:31,269
a single shot like for the exotic

00:19:28,929 --> 00:19:32,950
scimitar here the ATC doesn't mean

00:19:31,269 --> 00:19:35,559
anything to you for greeting one sample

00:19:32,950 --> 00:19:40,029
it's got to be deterministic and

00:19:35,559 --> 00:19:42,519
described a ton of samples and sometimes

00:19:40,029 --> 00:19:44,679
you want to list the secondary channels

00:19:42,519 --> 00:19:47,379
I have no real application like the cold

00:19:44,679 --> 00:19:49,779
Junction temperature doesn't hurt to

00:19:47,379 --> 00:19:51,999
have it so and you have to read the

00:19:49,779 --> 00:19:54,729
entire a spy block for that ship I

00:19:51,999 --> 00:19:57,209
remember correctly so it might also tell

00:19:54,729 --> 00:19:57,209
what it is

00:19:58,709 --> 00:20:06,590
well

00:20:00,830 --> 00:20:08,670
it could be okay I'm is saying there's

00:20:06,590 --> 00:20:10,580
I'm just saying there's samples where

00:20:08,670 --> 00:20:18,480
you don't need it although some some

00:20:10,580 --> 00:20:22,140
some sensors ok so here's an example of

00:20:18,480 --> 00:20:27,090
a capture so we got an i/o device 0

00:20:22,140 --> 00:20:28,950
which is this is the thermal coupler so

00:20:27,090 --> 00:20:33,060
there's the wall temperature from the

00:20:28,950 --> 00:20:35,010
probe and there's ambient temperature

00:20:33,060 --> 00:20:42,690
raw and you can see the to scaling

00:20:35,010 --> 00:20:49,740
values so so yeah you multiply 298 by

00:20:42,690 --> 00:20:54,720
250 and 416 by 62.5 and that gives you

00:20:49,740 --> 00:20:56,370
the mill Celsius reading there so yeah

00:20:54,720 --> 00:20:57,720
so then you needed the conversion

00:20:56,370 --> 00:21:01,950
obviously divided by thousand and you

00:20:57,720 --> 00:21:04,230
have unit Celsius and there's a few

00:21:01,950 --> 00:21:06,360
examples of units being this way because

00:21:04,230 --> 00:21:07,470
it's just backwards compatible with

00:21:06,360 --> 00:21:13,290
hardware monitor if you don't worry

00:21:07,470 --> 00:21:15,900
about two floating points there example

00:21:13,290 --> 00:21:18,660
of iowa vents that's usually used for

00:21:15,900 --> 00:21:22,730
like solar ometer x' for freefall

00:21:18,660 --> 00:21:27,450
interrupt you or rising and falling of

00:21:22,730 --> 00:21:29,580
certain direction interface yeah first

00:21:27,450 --> 00:21:34,190
you like humidity sensors there's some

00:21:29,580 --> 00:21:34,190
sensors to have a trip point also

00:21:35,300 --> 00:21:38,850
they're different than the d buffers

00:21:37,470 --> 00:21:41,160
because they don't come up they don't

00:21:38,850 --> 00:21:46,110
come through a buffer they're just an i

00:21:41,160 --> 00:21:49,940
octo event yeah so you need it so user

00:21:46,110 --> 00:21:49,940
space application needs to a pole fort

00:21:52,440 --> 00:22:02,859
and here's an example of one so there's

00:21:58,840 --> 00:22:12,309
a threshold of rising and also there's a

00:22:02,859 --> 00:22:16,989
mass separate value and enable okay so I

00:22:12,309 --> 00:22:20,109
owe consumer channels so it allows the

00:22:16,989 --> 00:22:21,549
channel to be a lot of it provides a

00:22:20,109 --> 00:22:23,979
channel that can be consumed by others

00:22:21,549 --> 00:22:29,369
inside the kernel so generally is eight

00:22:23,979 --> 00:22:29,369
oh yeah

00:22:35,050 --> 00:22:38,670
and the driver

00:22:41,350 --> 00:22:45,850
well when you're doing the processing

00:22:43,509 --> 00:22:54,399
like that when code it's better to do

00:22:45,850 --> 00:22:56,350
that in the user space yes yeah I mean

00:22:54,399 --> 00:22:58,149
you could you could write the driver

00:22:56,350 --> 00:22:59,830
however you wanted but it's just you

00:22:58,149 --> 00:23:02,289
generally do the processing in user

00:22:59,830 --> 00:23:08,799
space because it doesn't have a like

00:23:02,289 --> 00:23:11,110
interrupts for like free fall or yeah so

00:23:08,799 --> 00:23:14,620
the consumers uh so there's some API

00:23:11,110 --> 00:23:17,320
calls to read like ADT data so there's a

00:23:14,620 --> 00:23:18,850
channel read that recent raw and read

00:23:17,320 --> 00:23:21,309
processes generally which want to use

00:23:18,850 --> 00:23:26,169
because you don't necessarily know the

00:23:21,309 --> 00:23:28,539
scaling value of the ADC so but that we

00:23:26,169 --> 00:23:31,960
thought that that relies on the ADC

00:23:28,539 --> 00:23:34,509
having its own I Oh info channel process

00:23:31,960 --> 00:23:39,100
to just to do the scaling to the

00:23:34,509 --> 00:23:44,340
millivolts and hardware monitor actually

00:23:39,100 --> 00:23:51,029
has a driver that can use the IO n io

00:23:44,340 --> 00:23:56,039
ADC or reporting which like LM sensors

00:23:51,029 --> 00:23:56,039
CS killing will be handled transparently

00:24:00,140 --> 00:24:05,720
so data which says should be unprocessed

00:24:02,710 --> 00:24:09,770
impossible because it's not the part of

00:24:05,720 --> 00:24:11,570
the kernel and keep the time spent in

00:24:09,770 --> 00:24:15,200
the kernel to a minimum in case there's

00:24:11,570 --> 00:24:16,340
another interrupt that happens and also

00:24:15,200 --> 00:24:18,440
a lot of stuff is floating-point

00:24:16,340 --> 00:24:22,400
calculations which obviously you can't

00:24:18,440 --> 00:24:25,630
do in the kernel there's times when like

00:24:22,400 --> 00:24:34,910
say channel process is required because

00:24:25,630 --> 00:24:36,980
example the it's one of the BMP 280 has

00:24:34,910 --> 00:24:40,160
a temperature coefficient that affects

00:24:36,980 --> 00:24:47,480
the humidity and the pressure readings

00:24:40,160 --> 00:24:51,470
so you needed to a processing then so SI

00:24:47,480 --> 00:24:55,820
units are typically used depends what if

00:24:51,470 --> 00:24:58,610
it's like meters or centimeters it

00:24:55,820 --> 00:25:01,580
really depends on I think we yeah we use

00:24:58,610 --> 00:25:04,640
meters but the example weird ones would

00:25:01,580 --> 00:25:08,510
be a middle of Celsius and millivolts

00:25:04,640 --> 00:25:10,070
but also ohms so you kinda have to look

00:25:08,510 --> 00:25:13,580
at the API to make sure that you're

00:25:10,070 --> 00:25:17,510
scaling values matches what is in the

00:25:13,580 --> 00:25:22,600
API documentation and that's documented

00:25:17,510 --> 00:25:25,820
in yeah in testing assistive s plus IO

00:25:22,600 --> 00:25:28,340
so there's a few little ities to mostly

00:25:25,820 --> 00:25:31,130
for debugging but also to help with IO

00:25:28,340 --> 00:25:37,340
just basically lists all the available

00:25:31,130 --> 00:25:40,970
triggers channels their type and what

00:25:37,340 --> 00:25:43,700
devices there are there's an event

00:25:40,970 --> 00:25:47,630
monitor so you can go test your driver

00:25:43,700 --> 00:25:49,309
for freefall generic buffer so you can

00:25:47,630 --> 00:25:53,600
just read the raw data coming off the

00:25:49,309 --> 00:25:56,500
buffered or you can have a process from

00:25:53,600 --> 00:25:56,500
a device's buffer

00:25:57,520 --> 00:26:04,039
so here's an example of output

00:26:00,730 --> 00:26:06,530
thermocouple and you can see the

00:26:04,039 --> 00:26:08,330
temperature raw that's agreed and then

00:26:06,530 --> 00:26:12,380
we enter all you can read using a single

00:26:08,330 --> 00:26:17,440
shot reading and also there's a chemical

00:26:12,380 --> 00:26:18,820
sensor so you in concentration and

00:26:17,440 --> 00:26:20,780
underscore input

00:26:18,820 --> 00:26:23,210
backward-compatible of hardware monitor

00:26:20,780 --> 00:26:27,940
that that means that that information is

00:26:23,210 --> 00:26:30,909
processed so that's the overall data so

00:26:27,940 --> 00:26:34,250
that will that will come back and

00:26:30,909 --> 00:26:42,400
parts-per-billion a number correctly for

00:26:34,250 --> 00:26:42,400
co2 and yeah also the resistance there

00:26:42,700 --> 00:26:50,840
so here's an example of how you would

00:26:45,110 --> 00:26:55,610
set up a buffer data capture so you so

00:26:50,840 --> 00:26:57,909
the hardware time software trigger is

00:26:55,610 --> 00:27:01,159
actually consider a queue tick of s

00:26:57,909 --> 00:27:03,020
created so you can go make directory

00:27:01,159 --> 00:27:06,470
with the Chiru trigger name there

00:27:03,020 --> 00:27:08,870
trigger 0 you can you can configure how

00:27:06,470 --> 00:27:11,750
many Hertz you want like I'm we updates

00:27:08,870 --> 00:27:17,240
a second so do we set it to 50 in the

00:27:11,750 --> 00:27:20,000
sampling frequency then we then we echo

00:27:17,240 --> 00:27:21,470
trigger one to the that device to tell

00:27:20,000 --> 00:27:25,610
that's the current trigger we want to

00:27:21,470 --> 00:27:26,929
use we we see what we enable the scan

00:27:25,610 --> 00:27:28,789
elements we want to see we want to the

00:27:26,929 --> 00:27:32,960
temperature the ambient temperature and

00:27:28,789 --> 00:27:34,760
the timestamp that we hit echo one to

00:27:32,960 --> 00:27:39,140
buffer enable and that will start

00:27:34,760 --> 00:27:42,110
sampling and this is like this is the

00:27:39,140 --> 00:27:44,000
raw data depending on what's Keano

00:27:42,110 --> 00:27:48,230
unless you enable the padding will be

00:27:44,000 --> 00:27:52,090
different so take that into effect so

00:27:48,230 --> 00:27:57,860
the last eight bytes there's a timestamp

00:27:52,090 --> 00:28:00,350
the first four are at the first four the

00:27:57,860 --> 00:28:05,630
actual temperature reading and you would

00:28:00,350 --> 00:28:08,780
you would use to scan the the data the

00:28:05,630 --> 00:28:11,590
enumeration of how you need to shift it

00:28:08,780 --> 00:28:14,270
and what endian it is

00:28:11,590 --> 00:28:21,650
yeah and it's also padded to eight since

00:28:14,270 --> 00:28:25,610
the time stamp is eight not exactly

00:28:21,650 --> 00:28:27,530
no it's it'll say it's FIFO

00:28:25,610 --> 00:28:29,450
you keep pushing to it a little it will

00:28:27,530 --> 00:28:33,590
not add until you start removing stuff

00:28:29,450 --> 00:28:35,810
so yeah so here's an example of how you

00:28:33,590 --> 00:28:40,520
would process that data so stuff the

00:28:35,810 --> 00:28:45,710
stuff in bold so you see that the index

00:28:40,520 --> 00:28:51,650
0 the scan elements so that that tells

00:28:45,710 --> 00:28:54,080
you so it's big-endian so only 14 14

00:28:51,650 --> 00:28:58,460
bits of that is what we actual doubt

00:28:54,080 --> 00:29:06,520
data split stored in 16 so shift shift

00:28:58,460 --> 00:29:13,010
over to so like that gives you 188 and X

00:29:06,520 --> 00:29:15,950
shifted over 298 times 250 and you get

00:29:13,010 --> 00:29:18,770
your that's the scale value and that's

00:29:15,950 --> 00:29:20,980
in mil Celsius so it's twenty four point

00:29:18,770 --> 00:29:20,980
five

00:29:25,730 --> 00:29:31,580
so yeah here's the generic buffer so

00:29:27,590 --> 00:29:33,440
it's a little more assuming the same

00:29:31,580 --> 00:29:35,990
feeling the same thing but it's

00:29:33,440 --> 00:29:39,950
obviously more readable so you can see

00:29:35,990 --> 00:29:43,820
the 24 you can see the two first two

00:29:39,950 --> 00:29:45,529
numbers are the temperature and the cold

00:29:43,820 --> 00:29:54,740
Junction temperature and the timestamp

00:29:45,529 --> 00:29:59,360
the soft timestamp okay so I get to my

00:29:54,740 --> 00:30:04,820
demo here so I got a BeagleBone exact

00:29:59,360 --> 00:30:07,010
scimitar chip and I'm using alibi Oh use

00:30:04,820 --> 00:30:11,510
speech application actually over the

00:30:07,010 --> 00:30:13,929
network to my Mac the IO Damon's running

00:30:11,510 --> 00:30:17,929
on it so it basically allows you to

00:30:13,929 --> 00:30:20,389
connect its ill it's the live IO is OS

00:30:17,929 --> 00:30:24,049
nossek so you can use it from any system

00:30:20,389 --> 00:30:24,380
Mac Windows Linux the backend obviously

00:30:24,049 --> 00:30:27,919
isn't

00:30:24,380 --> 00:30:30,799
it's obviously Linux then I'll stream

00:30:27,919 --> 00:30:36,220
graphs with the new plot probably not

00:30:30,799 --> 00:30:36,220
the best way but so

00:30:39,419 --> 00:30:43,440
let's see if I can get this

00:30:57,080 --> 00:31:01,300
take swallow because it needs to do a

00:30:59,030 --> 00:31:01,300
baseline

00:31:02,220 --> 00:31:05,400
[Music]

00:31:10,230 --> 00:31:17,970
so right now it's reading off the to an

00:31:13,920 --> 00:31:21,090
ad see if it has 18 bit ADC it's reading

00:31:17,970 --> 00:31:24,330
the values off two LEDs one infrared and

00:31:21,090 --> 00:31:27,210
one red the red ones for the heart rate

00:31:24,330 --> 00:31:30,600
the infra red ones for doing a ratio to

00:31:27,210 --> 00:31:34,470
calculate what oxygen so football

00:31:30,600 --> 00:31:37,770
auction is about 99 percent and the

00:31:34,470 --> 00:31:43,890
heart rates about 42 which might not be

00:31:37,770 --> 00:31:46,320
correct but yeah yeah the problem is

00:31:43,890 --> 00:31:49,080
it's uh it's doing a sampling it's doing

00:31:46,320 --> 00:31:51,500
an averaging over like 20 seconds so and

00:31:49,080 --> 00:32:00,440
if I'm moving and talking changes this

00:31:51,500 --> 00:32:00,440
so let's see if it ever just out

00:32:03,160 --> 00:32:12,640
yeah okay so that's probably more

00:32:09,470 --> 00:32:12,640
accurate there yeah

00:32:19,710 --> 00:32:22,700
yeah okay

00:32:29,190 --> 00:32:33,330
so yeah here is in case they didn't work

00:32:31,289 --> 00:32:35,820
at all so yeah that's the debt that

00:32:33,330 --> 00:32:38,879
applied it on it okay so in conclusion

00:32:35,820 --> 00:32:41,909
on the industrial IO is a good solution

00:32:38,879 --> 00:32:45,149
for us fast updating sensors and giving

00:32:41,909 --> 00:32:49,769
data to user space drilling a limit to

00:32:45,149 --> 00:32:51,570
what IO can do sensor wise and it's much

00:32:49,769 --> 00:32:56,669
more stable than just using another

00:32:51,570 --> 00:32:57,359
miscellaneous driver so I also patch

00:32:56,669 --> 00:33:04,970
this welcome

00:32:57,359 --> 00:33:04,970
so quite anyone have any questions sure

00:33:13,410 --> 00:33:24,960
yeah so there's there's a Python binding

00:33:15,840 --> 00:33:29,250
for obviously live i/o such as the

00:33:24,960 --> 00:33:33,890
that's just the data keeps it keeps too

00:33:29,250 --> 00:33:37,310
damaging but as the buffer here is on

00:33:33,890 --> 00:33:37,310
this search for

00:33:41,690 --> 00:33:47,890
so so basically it's looking for a

00:33:44,840 --> 00:33:51,080
network context so I have a hard-coded

00:33:47,890 --> 00:33:54,380
it's planning a device which is defined

00:33:51,080 --> 00:33:55,730
already the driver name you could have

00:33:54,380 --> 00:33:57,940
an issue if there's multiple devices at

00:33:55,730 --> 00:34:04,100
the same name but you would just use the

00:33:57,940 --> 00:34:07,580
i/o device zero and or i/o device one we

00:34:04,100 --> 00:34:17,020
enabling both both ADC channels so it's

00:34:07,580 --> 00:34:19,030
zero and one then function to read and

00:34:17,020 --> 00:34:23,510
it's reading it just sets up a buffer

00:34:19,030 --> 00:34:24,919
then tells you how many it tells how

00:34:23,510 --> 00:34:30,110
many samples and once before it returns

00:34:24,919 --> 00:34:38,060
and add to the buffer that it just

00:34:30,110 --> 00:34:43,550
averaging to display the chart any more

00:34:38,060 --> 00:34:45,200
questions you he said they're going to

00:34:43,550 --> 00:34:48,970
know whether output devices currently

00:34:45,200 --> 00:34:52,360
reside maybe just one kind of all

00:34:48,970 --> 00:34:53,980
yeah just heating control for work

00:34:52,360 --> 00:34:58,710
oh wait I'll take that back the

00:34:53,980 --> 00:35:02,380
potentiometers and output yeah because

00:34:58,710 --> 00:35:09,340
no no it's for configuration parameters

00:35:02,380 --> 00:35:10,990
not that yeah yeah you're you're echoing

00:35:09,340 --> 00:35:20,290
the own value you want so it's an output

00:35:10,990 --> 00:35:24,100
yeah yeah yeah yeah and like our people

00:35:20,290 --> 00:35:27,160
doing order I haven't heard of that

00:35:24,100 --> 00:35:30,040
anyone doing it so yeah I could be wrong

00:35:27,160 --> 00:35:31,360
but I don't think I've heard I'm trying

00:35:30,040 --> 00:35:33,460
to figure out the balance between user

00:35:31,360 --> 00:35:36,880
space in ia oh I have a lot of users

00:35:33,460 --> 00:35:38,170
that just don't believe in using even

00:35:36,880 --> 00:35:39,850
chrome drivers that you're trying

00:35:38,170 --> 00:35:50,890
everything in user space including a

00:35:39,850 --> 00:35:52,510
colorama tur yeah so is it attacker that

00:35:50,890 --> 00:35:57,130
they're using control some of the

00:35:52,510 --> 00:35:59,320
stuffer for the motor control or will do

00:35:57,130 --> 00:36:03,010
remembering master control of PW have

00:35:59,320 --> 00:36:04,390
Wow to do so they controlling user state

00:36:03,010 --> 00:36:07,330
they're controlling drivers and user

00:36:04,390 --> 00:36:16,050
space now like having the control richer

00:36:07,330 --> 00:36:16,050
of the PWM remapping those and then

00:36:16,110 --> 00:36:24,850
doing a GC dev or the top dude I am used

00:36:20,590 --> 00:36:27,130
rather than using IO to pump is you yeah

00:36:24,850 --> 00:36:29,710
and they're they're convinced that that

00:36:27,130 --> 00:36:35,590
get them to low in white no it doesn't

00:36:29,710 --> 00:36:38,160
there's no way I could yeah they try

00:36:35,590 --> 00:36:38,160
using e

00:36:38,650 --> 00:36:44,680
which I am you that one's pretty well

00:36:43,210 --> 00:36:54,069
supported I'm surprised they have an

00:36:44,680 --> 00:36:57,789
issue and their numbers like doing

00:36:54,069 --> 00:37:00,809
quadcopter Vallely I'd like you're

00:36:57,789 --> 00:37:00,809
something else at play there I think

00:37:05,759 --> 00:37:10,269
they are running our decrease but they

00:37:08,469 --> 00:37:11,739
don't report you're doing with this are

00:37:10,269 --> 00:37:17,559
key scheduling without our country as

00:37:11,739 --> 00:37:20,769
well and it's the word I have big a very

00:37:17,559 --> 00:37:22,599
like this two millisecond loop but the

00:37:20,769 --> 00:37:24,880
longest time great is the IAO read of

00:37:22,599 --> 00:37:27,130
the IMU which is like over like horn

00:37:24,880 --> 00:37:28,509
place like around 1/2 milliseconds then

00:37:27,130 --> 00:37:33,400
there's there's probably a bug in the

00:37:28,509 --> 00:37:34,930
driver somewhere or yeah yeah yeah the

00:37:33,400 --> 00:37:47,880
using a recent Colonel or an old colonel

00:37:34,930 --> 00:37:47,880
oh do do not do old any more questions

00:37:48,539 --> 00:37:54,880
yeah well there's there's

00:37:52,599 --> 00:37:57,880
microcontrollers effectively that you

00:37:54,880 --> 00:38:00,430
know basically diffusion code they can

00:37:57,880 --> 00:38:02,469
read from multiple sensors usually

00:38:00,430 --> 00:38:05,019
require Terry so some of that stuff I

00:38:02,469 --> 00:38:07,269
really haven't looked into but yeah so

00:38:05,019 --> 00:38:10,900
it's it's more of a fusion code thing

00:38:07,269 --> 00:38:12,609
that's offloads having it on the CPU

00:38:10,900 --> 00:38:15,069
itself because a lot of that stuff is

00:38:12,609 --> 00:38:17,579
very CPU intensive if you're doing a ton

00:38:15,069 --> 00:38:23,460
of like 100 i/o to see reads a second or

00:38:17,579 --> 00:38:23,460
spy reads okay

00:38:32,500 --> 00:38:38,490
you mean software or an actual actual

00:38:35,230 --> 00:38:38,490
actual sensor hubs

00:38:48,800 --> 00:38:53,420
and I don't think there's any use case

00:38:50,900 --> 00:38:54,830
for that right now also that goes into

00:38:53,420 --> 00:38:56,870
the eternally do that processing and

00:38:54,830 --> 00:38:59,570
user space unless there's molesters a

00:38:56,870 --> 00:39:01,160
reason to do it because you're not

00:38:59,570 --> 00:39:03,670
saving any CPU time

00:39:01,160 --> 00:39:03,670
really

00:39:10,580 --> 00:39:15,580
that is true but there's no plan for

00:39:13,460 --> 00:39:15,580
that

00:39:34,190 --> 00:39:38,440
I would example that would

00:39:41,680 --> 00:39:44,160
we

00:39:44,859 --> 00:39:47,859
hmm

00:39:49,290 --> 00:39:56,250
let's just interrupt or yeah you could

00:39:54,960 --> 00:40:00,030
just use like one if you just use

00:39:56,250 --> 00:40:01,620
interrupts to trigger a reading can all

00:40:00,030 --> 00:40:05,760
these centers actually have a power

00:40:01,620 --> 00:40:08,220
management already support yeah a lot of

00:40:05,760 --> 00:40:12,170
its either it's in the sensor itself or

00:40:08,220 --> 00:40:12,170
it's in IO doing it directly

00:40:33,730 --> 00:40:36,300
what

00:40:39,820 --> 00:40:43,780
yeah well let's certainly use the

00:40:42,190 --> 00:40:47,790
interrupts for that but I guess I don't

00:40:43,780 --> 00:40:47,790
how you would do that program

00:40:58,230 --> 00:41:17,540
okay

00:41:01,060 --> 00:41:19,280
any more questions you would generally

00:41:17,540 --> 00:41:23,870
it suffice tree I mean it's a static who

00:41:19,280 --> 00:41:25,310
use device Sherita well that you can

00:41:23,870 --> 00:41:27,320
tell us I don't think I've actually come

00:41:25,310 --> 00:41:34,370
up to actually or what kind of data are

00:41:27,320 --> 00:41:36,530
you talking just you'd probably have to

00:41:34,370 --> 00:41:39,260
use the one of the regiment's interfaces

00:41:36,530 --> 00:41:43,540
or but yeah I don't think of known

00:41:39,260 --> 00:41:43,540
examples of that currently yeah

00:41:55,329 --> 00:42:04,030
yes using PWM or using like interrupts

00:42:01,140 --> 00:42:10,540
and we not gonna have it's not going to

00:42:04,030 --> 00:42:12,790
be deterministic so I don't know yeah

00:42:10,540 --> 00:42:14,980
yeah yeah I don't think you could you

00:42:12,790 --> 00:42:19,500
couldn't deterministically to have a you

00:42:14,980 --> 00:42:19,500
know the pulse be correct

00:42:57,590 --> 00:43:00,850
any more questions

00:43:06,130 --> 00:43:11,060
yeah I don't think actually I think

00:43:08,630 --> 00:43:12,620
analog of Isis has a few examples of the

00:43:11,060 --> 00:43:17,120
IO face I think it's all that stuff's in

00:43:12,620 --> 00:43:18,890
staging but yeah yeah analog device is

00:43:17,120 --> 00:43:21,370
the one actually did most of these live

00:43:18,890 --> 00:43:21,370
i/o work

00:43:39,369 --> 00:43:42,890
that's one way to do it I mean I mean

00:43:41,810 --> 00:43:48,170
central hubs is basically a

00:43:42,890 --> 00:43:54,160
microcontroller so yeah any more

00:43:48,170 --> 00:43:54,160
questions all right thanks for coming

00:43:54,640 --> 00:43:59,060

YouTube URL: https://www.youtube.com/watch?v=lBU77crSvcI


