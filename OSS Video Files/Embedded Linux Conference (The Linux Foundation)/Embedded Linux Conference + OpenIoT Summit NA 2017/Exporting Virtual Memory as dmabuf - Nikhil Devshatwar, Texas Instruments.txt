Title: Exporting Virtual Memory as dmabuf - Nikhil Devshatwar, Texas Instruments
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Exporting Virtual Memory as dmabuf - Nikhil Devshatwar, Texas Instruments

Exporting virtual memory as dmabuf (Nikhil Devshatwar, Texas Instruments) - For sharing buffers across different drivers, dmabuf is introduced. In this presentation, Nikhil will discuss some of the challenges faced in integrating some of the legacy drivers and RTOS applications with Linux. He has a proposed solution to solve these problems using a simple approach. He will discuss on the concept, implementation, advantages and security concerns with respect to this solution.

About Nikhil Devshatwar
Nikhil Devshatwar is a Linux kernel developer at Texas Instruments India Pvt Ltd. He mainly works on embedded Linux kernel drivers for camera and video subsystem. Nikhil is also involved in Base port support for the different automotive chips. He has been working on different kernel frameworks for the past 4 years and his expertise include device tree, I2C, V4L2 and DRM frameworks. Currently he is working on integration of RTOS automotive vision applications with Linux. He has started community contributions with some patch fixes and features in the V4L2 and device tree domains.
Captions: 
	00:00:00,030 --> 00:00:04,920
hello everyone so this presentation is

00:00:02,550 --> 00:00:07,170
about exporting virtual memory as d-m

00:00:04,920 --> 00:00:09,540
above I think two to three years back we

00:00:07,170 --> 00:00:12,420
had the member of concept presented in

00:00:09,540 --> 00:00:13,590
the same ELC now this is just a

00:00:12,420 --> 00:00:16,859
different angle to it

00:00:13,590 --> 00:00:18,810
just trying to export virtual memory as

00:00:16,859 --> 00:00:21,890
DM above so I'll just start with some

00:00:18,810 --> 00:00:21,890
introduction from my side

00:00:26,890 --> 00:00:29,670
won't work

00:00:32,219 --> 00:00:36,680
okay

00:00:34,010 --> 00:00:39,230
so hi my name is nicki lerczak waar I

00:00:36,680 --> 00:00:42,410
work at Texas Instruments Bangalore

00:00:39,230 --> 00:00:44,630
India and mostly I work on the kernel

00:00:42,410 --> 00:00:47,230
part so the key areas that I work on is

00:00:44,630 --> 00:00:49,610
video subsystem camera drivers and

00:00:47,230 --> 00:00:52,280
recently I have started working on the

00:00:49,610 --> 00:00:54,410
Linux and artists implement artists

00:00:52,280 --> 00:00:57,110
integration so mostly for the automotive

00:00:54,410 --> 00:00:59,180
use cases there is a trend that you want

00:00:57,110 --> 00:01:02,270
to run Linux and artists on the same

00:00:59,180 --> 00:01:04,790
ship so I am working on that so I have

00:01:02,270 --> 00:01:06,229
not much done contributions in the

00:01:04,790 --> 00:01:08,360
open-source community but a few

00:01:06,229 --> 00:01:10,640
contributions from my cider than for v4

00:01:08,360 --> 00:01:14,479
are two drivers and in the device tree

00:01:10,640 --> 00:01:16,460
compilers ok so this is the outline of

00:01:14,479 --> 00:01:19,340
the presentation so what we are going to

00:01:16,460 --> 00:01:21,530
talk about is we @ti faced a problem

00:01:19,340 --> 00:01:24,110
when trying to integrate the Linux and

00:01:21,530 --> 00:01:29,060
artists operating system applications

00:01:24,110 --> 00:01:31,280
together so we had some problems we try

00:01:29,060 --> 00:01:33,590
to fix it in some way and then I think

00:01:31,280 --> 00:01:35,090
that the solution that we have taken is

00:01:33,590 --> 00:01:37,910
generic enough that it can be applied to

00:01:35,090 --> 00:01:40,130
the community use cases so we'll go

00:01:37,910 --> 00:01:42,350
through the specific solution what we

00:01:40,130 --> 00:01:44,119
dealt with and then we'll try to jump to

00:01:42,350 --> 00:01:45,610
how this can be applied to a generic

00:01:44,119 --> 00:01:47,990
level and then we'll go through them

00:01:45,610 --> 00:01:50,509
implementation details and then if there

00:01:47,990 --> 00:01:53,119
are any security concerns or if there

00:01:50,509 --> 00:01:56,929
are any questions I can take so I'll

00:01:53,119 --> 00:01:59,360
just point out that the solution that I

00:01:56,929 --> 00:02:01,490
am trying to tour trying to propose is

00:01:59,360 --> 00:02:03,229
not meant for all the use cases it is

00:02:01,490 --> 00:02:05,420
only meant for like the embedded use

00:02:03,229 --> 00:02:08,539
cases there are some a lot of

00:02:05,420 --> 00:02:13,580
assumptions behind this I will clarify

00:02:08,539 --> 00:02:16,730
as and when we encounter them so so this

00:02:13,580 --> 00:02:19,760
is the typical use case I would say in

00:02:16,730 --> 00:02:21,770
the case of integrating Linux and Artos

00:02:19,760 --> 00:02:23,510
applications so typically you would have

00:02:21,770 --> 00:02:26,150
like the memory divided into two parts

00:02:23,510 --> 00:02:28,220
so most chunk of the memory would be

00:02:26,150 --> 00:02:31,790
used by Linux and you'll have a

00:02:28,220 --> 00:02:35,990
dedicated memory region which is carved

00:02:31,790 --> 00:02:37,220
out for the are dos now you may have

00:02:35,990 --> 00:02:39,530
different types of applications

00:02:37,220 --> 00:02:41,060
accessing these memories you will have

00:02:39,530 --> 00:02:42,799
like typical infotainment applications

00:02:41,060 --> 00:02:44,360
running on Linux a - applications

00:02:42,799 --> 00:02:45,090
running on our tour so this is stopping

00:02:44,360 --> 00:02:47,550
talking

00:02:45,090 --> 00:02:49,140
the automotive point of view so that's

00:02:47,550 --> 00:02:51,150
why I have mentioned it has applications

00:02:49,140 --> 00:02:53,220
but in the middle you see that there is

00:02:51,150 --> 00:02:55,379
info at us so what I mean by that is

00:02:53,220 --> 00:02:57,180
this informational address so basically

00:02:55,379 --> 00:02:59,400
these are the applications where you

00:02:57,180 --> 00:03:01,319
will use the HL OS features from Linux

00:02:59,400 --> 00:03:03,480
but at the same time you want to utilize

00:03:01,319 --> 00:03:04,799
the hardware acceleration and the

00:03:03,480 --> 00:03:07,110
algorithms that are running on the

00:03:04,799 --> 00:03:10,410
artists so if you look at that

00:03:07,110 --> 00:03:12,870
application so these kinds of

00:03:10,410 --> 00:03:14,940
applications would be accessing the

00:03:12,870 --> 00:03:16,950
memory on the Linux as well as on the

00:03:14,940 --> 00:03:19,650
artists side you can see that the

00:03:16,950 --> 00:03:21,959
buffers that it is using is actually red

00:03:19,650 --> 00:03:24,450
and blue which is which indicates that

00:03:21,959 --> 00:03:26,579
it is using the Linux and artists memory

00:03:24,450 --> 00:03:28,410
now the problems when we are trying to

00:03:26,579 --> 00:03:30,810
build these kind of applications is that

00:03:28,410 --> 00:03:33,660
the typical architecture does not allow

00:03:30,810 --> 00:03:36,030
you to like have accesses to other

00:03:33,660 --> 00:03:38,579
memory which is cut out from Linux so

00:03:36,030 --> 00:03:41,099
what we want to have is we want access

00:03:38,579 --> 00:03:43,110
to the artists memory at the same time

00:03:41,099 --> 00:03:45,720
not just accessing that memory we want

00:03:43,110 --> 00:03:47,940
to give that memory to other drivers

00:03:45,720 --> 00:03:50,160
like typical use cases for these kind of

00:03:47,940 --> 00:03:52,500
applications would be let's say you'll

00:03:50,160 --> 00:03:54,060
have some camera capture running on our

00:03:52,500 --> 00:03:56,370
toast application and there are some

00:03:54,060 --> 00:03:58,500
I'll go to them sir running on the

00:03:56,370 --> 00:04:00,299
capture and then after everything is

00:03:58,500 --> 00:04:02,370
done you will have the video data coming

00:04:00,299 --> 00:04:04,709
in and that video data you want to

00:04:02,370 --> 00:04:07,019
display on to Linux so because you want

00:04:04,709 --> 00:04:11,190
to use the HLS features you will have

00:04:07,019 --> 00:04:12,739
the fancy graphics GUI and all the stack

00:04:11,190 --> 00:04:16,190
that is running on the Linux and the

00:04:12,739 --> 00:04:18,329
standard Linux drivers like the DRM and

00:04:16,190 --> 00:04:21,900
standard application frameworks like

00:04:18,329 --> 00:04:23,880
gstreamer will and will be used to you

00:04:21,900 --> 00:04:26,190
know consume those buffers coming from

00:04:23,880 --> 00:04:28,860
artists now the requirement here is to

00:04:26,190 --> 00:04:31,440
be able to access the artists memory

00:04:28,860 --> 00:04:33,870
which is not really part of the Linux

00:04:31,440 --> 00:04:36,000
that memory and share that memory with

00:04:33,870 --> 00:04:42,120
the standard Linux drivers that we have

00:04:36,000 --> 00:04:45,330
in place so I'll start with the short

00:04:42,120 --> 00:04:47,310
note on what DMF is so DMA buff is

00:04:45,330 --> 00:04:49,530
generic mechanism to share buffers

00:04:47,310 --> 00:04:52,380
across the driver so Linux kernel has

00:04:49,530 --> 00:04:54,240
this whole framework designed in such a

00:04:52,380 --> 00:04:56,789
way that you can have one driver which

00:04:54,240 --> 00:04:57,620
is allocating the buffers and then you

00:04:56,789 --> 00:04:59,800
can import

00:04:57,620 --> 00:05:01,699
export that buffer into just a simple

00:04:59,800 --> 00:05:03,800
anonymous file descriptor

00:05:01,699 --> 00:05:05,630
once the anonymous file descriptor is

00:05:03,800 --> 00:05:07,790
available at the application level you

00:05:05,630 --> 00:05:10,130
can pass this descriptor all the way to

00:05:07,790 --> 00:05:12,380
different different drivers and each of

00:05:10,130 --> 00:05:15,260
the driver would be able to find out

00:05:12,380 --> 00:05:18,050
what that descriptor means so from that

00:05:15,260 --> 00:05:19,580
descriptive you will the driver will be

00:05:18,050 --> 00:05:21,910
able to figure out the physical

00:05:19,580 --> 00:05:24,500
addresses and then the corresponding

00:05:21,910 --> 00:05:26,870
travel functions can be done so if

00:05:24,500 --> 00:05:38,300
anyone has any questions on DN above I

00:05:26,870 --> 00:05:40,910
would like to take that now in this case

00:05:38,300 --> 00:05:42,770
there is only one Linux only one OS I am

00:05:40,910 --> 00:05:45,229
showing the previous diagram in this

00:05:42,770 --> 00:05:46,610
case these tools and OS are running on

00:05:45,229 --> 00:05:48,410
the same hardware but there is no

00:05:46,610 --> 00:05:50,419
hypervisor these are actually running on

00:05:48,410 --> 00:05:52,340
two different processors so artists will

00:05:50,419 --> 00:05:54,199
be running on a dedicated so this is a

00:05:52,340 --> 00:05:56,720
heterogeneous architecture kind of thing

00:05:54,199 --> 00:06:00,610
where you have two processors one which

00:05:56,720 --> 00:06:05,450
is let's say a 15 series running the

00:06:00,610 --> 00:06:07,520
Linux and you will have a typical low

00:06:05,450 --> 00:06:09,050
latency processor designed for the

00:06:07,520 --> 00:06:11,479
artists kind of application so there is

00:06:09,050 --> 00:06:13,310
no hypervisor in value these are just

00:06:11,479 --> 00:06:18,830
two separate CPUs running two different

00:06:13,310 --> 00:06:20,870
ways and for different use cases yes yes

00:06:18,830 --> 00:06:23,300
so this is a typical embedded use case

00:06:20,870 --> 00:06:25,669
where you will have a common DDR there

00:06:23,300 --> 00:06:28,370
is no separate GPU memory or anything of

00:06:25,669 --> 00:06:33,190
that sort and all the memory accesses is

00:06:28,370 --> 00:06:35,960
driven through a common email interface

00:06:33,190 --> 00:06:37,910
so as I explained that the DMF allows

00:06:35,960 --> 00:06:39,919
you to share buffers between drivers and

00:06:37,910 --> 00:06:42,620
all that but all of this is specific to

00:06:39,919 --> 00:06:44,900
linux because there should be a linux

00:06:42,620 --> 00:06:46,940
driver which exports the DM above and

00:06:44,900 --> 00:06:50,449
then of course there are a lot of DMF

00:06:46,940 --> 00:06:52,160
importers which can take those DMA fds

00:06:50,449 --> 00:06:55,010
and then figure out what is the physical

00:06:52,160 --> 00:06:57,260
addresses and access the memory

00:06:55,010 --> 00:06:58,910
corresponding to that so what we have

00:06:57,260 --> 00:07:01,160
done is to solve the problem that I

00:06:58,910 --> 00:07:02,990
faced like we want to access the artists

00:07:01,160 --> 00:07:05,719
memory as well as share this memory with

00:07:02,990 --> 00:07:07,940
the other drivers so in this case what

00:07:05,719 --> 00:07:10,030
you see here is that on the left side we

00:07:07,940 --> 00:07:13,390
have the artists

00:07:10,030 --> 00:07:17,830
no stack so what I have here is that the

00:07:13,390 --> 00:07:19,660
artists application has some memory but

00:07:17,830 --> 00:07:22,390
this memory is mapped into the Linux

00:07:19,660 --> 00:07:25,240
space by whatever means like currently

00:07:22,390 --> 00:07:28,480
you can simply use dev mem or you can

00:07:25,240 --> 00:07:30,280
have a driver the typically there Tower

00:07:28,480 --> 00:07:32,650
which is handling with the artists

00:07:30,280 --> 00:07:34,860
loading and remote prog driver let's say

00:07:32,650 --> 00:07:37,390
you can map the memory into the

00:07:34,860 --> 00:07:38,740
application so once you have mapped the

00:07:37,390 --> 00:07:41,560
memory you will get the virtual address

00:07:38,740 --> 00:07:43,840
now this is what I mean by exporting a

00:07:41,560 --> 00:07:45,490
virtual memory as DM above so typical

00:07:43,840 --> 00:07:50,020
use cases in Linux you would have seen

00:07:45,490 --> 00:07:52,480
that all the drivers that do support DM

00:07:50,020 --> 00:07:54,790
above export are most of the time are a

00:07:52,480 --> 00:07:57,250
locators of the buffers like if you take

00:07:54,790 --> 00:07:59,440
V for l2 for example DRM for examples

00:07:57,250 --> 00:08:01,830
only the drivers which allocate those

00:07:59,440 --> 00:08:03,790
buffers are capable of exporting the

00:08:01,830 --> 00:08:05,620
buffer as DMF

00:08:03,790 --> 00:08:07,840
now in this case what I am trying to

00:08:05,620 --> 00:08:10,600
demonstrate here is that we have a

00:08:07,840 --> 00:08:11,950
virtual memory which is mapped into the

00:08:10,600 --> 00:08:14,410
application and then you have a

00:08:11,950 --> 00:08:15,760
completely different driver which is no

00:08:14,410 --> 00:08:17,560
connection with the memory that we are

00:08:15,760 --> 00:08:19,840
talking about but you give the pointer

00:08:17,560 --> 00:08:22,860
of this memory to the driver and it

00:08:19,840 --> 00:08:26,080
exports that memory chunk as the DMF of

00:08:22,860 --> 00:08:31,890
DMF and then you can get that as a file

00:08:26,080 --> 00:08:31,890
descriptor so the way yes

00:08:36,070 --> 00:08:44,500
right yes yes so there will be a common

00:08:41,579 --> 00:08:47,470
common bus and there are multiple

00:08:44,500 --> 00:08:49,209
processors and peripherals accessing the

00:08:47,470 --> 00:08:52,329
memory through that bus so at the same

00:08:49,209 --> 00:08:54,279
time linux and artists can access the

00:08:52,329 --> 00:08:58,930
memory but of course the memory is

00:08:54,279 --> 00:09:01,569
divided divided as in logically divided

00:08:58,930 --> 00:09:03,430
so if you have like 4gb of RAM when 3 GB

00:09:01,569 --> 00:09:05,380
will be given for Linux and 1 GB or

00:09:03,430 --> 00:09:15,910
maybe half GB given four artists

00:09:05,380 --> 00:09:17,740
applications something like ok no no my

00:09:15,910 --> 00:09:19,420
point is like the memory is there 4gb

00:09:17,740 --> 00:09:20,800
it's up to the software configuration

00:09:19,420 --> 00:09:22,240
how much you want to carve out four

00:09:20,800 --> 00:09:25,060
artists depending on the applications

00:09:22,240 --> 00:09:27,279
need you may decide like 128 MB all the

00:09:25,060 --> 00:09:28,690
way to 1 GB depending on the application

00:09:27,279 --> 00:09:31,750
and use case that you are running on our

00:09:28,690 --> 00:09:33,519
toes I mean this is a specific solution

00:09:31,750 --> 00:09:37,690
but it does not have anything to do with

00:09:33,519 --> 00:09:40,560
the idea of exporting the virtual memory

00:09:37,690 --> 00:09:40,560
you had some question

00:10:20,010 --> 00:10:24,459
yeah so to answer your question the

00:10:22,660 --> 00:10:26,560
concept of paging applies mostly in the

00:10:24,459 --> 00:10:28,959
case of linux now in case of artists you

00:10:26,560 --> 00:10:31,270
will not have like like multiple layers

00:10:28,959 --> 00:10:33,220
of levels of translations an artists

00:10:31,270 --> 00:10:36,399
application is as simple as you can just

00:10:33,220 --> 00:10:38,490
map a address and you will start writing

00:10:36,399 --> 00:10:41,260
into it because there won't be a lot of

00:10:38,490 --> 00:10:43,420
paging or translations because it's very

00:10:41,260 --> 00:10:45,970
simple in the processor that is running

00:10:43,420 --> 00:10:48,490
artists is going to be very simple

00:10:45,970 --> 00:10:52,330
processor so you will not have the

00:10:48,490 --> 00:10:54,459
paging paging facility there so you

00:10:52,330 --> 00:11:18,040
would be it would be a direct access to

00:10:54,459 --> 00:11:20,080
the physical addresses yes right so in

00:11:18,040 --> 00:11:22,240
the device tree we typically carve out

00:11:20,080 --> 00:11:24,279
some memory region and of course that

00:11:22,240 --> 00:11:26,830
will be continuous memory region and you

00:11:24,279 --> 00:11:28,930
specify those region values at the start

00:11:26,830 --> 00:11:31,240
of the boot up of the artists processor

00:11:28,930 --> 00:11:33,820
and then all the artists applications

00:11:31,240 --> 00:11:38,200
will be able to start allocating buffers

00:11:33,820 --> 00:11:40,990
from that region so I know I have

00:11:38,200 --> 00:11:43,660
started with like lot of complicated

00:11:40,990 --> 00:11:45,100
things but if you have any questions I

00:11:43,660 --> 00:11:48,810
would like to clarify them because I am

00:11:45,100 --> 00:11:48,810
going to build on this

00:12:04,530 --> 00:12:07,340
correct

00:12:09,699 --> 00:12:16,149
no the virtual address of course will be

00:12:11,980 --> 00:12:18,399
for the meaning the mapping of that

00:12:16,149 --> 00:12:19,779
buffer is done in the application so the

00:12:18,399 --> 00:12:26,859
virtual address is part of the

00:12:19,779 --> 00:12:29,799
application meaning user space yeah so

00:12:26,859 --> 00:12:31,569
the point here is that you can map the

00:12:29,799 --> 00:12:35,350
memory and get the virtual address and

00:12:31,569 --> 00:12:37,660
the way this is the solution is designed

00:12:35,350 --> 00:12:39,459
in the way is that you get a virtual

00:12:37,660 --> 00:12:41,859
address and from that virtual address

00:12:39,459 --> 00:12:44,410
you give it to a new driver the one that

00:12:41,859 --> 00:12:47,259
is mentioned in the green box vm m exp i

00:12:44,410 --> 00:12:49,470
call it virtual memory exporter so this

00:12:47,259 --> 00:12:53,499
VM ma XP driver is the one which is

00:12:49,470 --> 00:12:55,269
newly created driver so what it is doing

00:12:53,499 --> 00:12:57,879
here is that it just takes the virtual

00:12:55,269 --> 00:12:59,439
address of any memory and then it finds

00:12:57,879 --> 00:13:00,910
out what is the corresponding physical

00:12:59,439 --> 00:13:02,559
addresses corresponding to that memory

00:13:00,910 --> 00:13:05,439
and then once you have the physical

00:13:02,559 --> 00:13:06,999
addresses you can export this as da

00:13:05,439 --> 00:13:10,480
member if you need to implement a bunch

00:13:06,999 --> 00:13:11,939
of DM above ops operations and once you

00:13:10,480 --> 00:13:15,039
have implemented those ops

00:13:11,939 --> 00:13:16,959
give this DMA FD to all other Linux

00:13:15,039 --> 00:13:19,059
drivers and from that point onwards all

00:13:16,959 --> 00:13:21,519
the Linux standard Linux drivers which

00:13:19,059 --> 00:13:23,859
are capable of importing the game above

00:13:21,519 --> 00:13:25,869
will be able to access those buffers

00:13:23,859 --> 00:13:31,049
using the DMF of offs that have been

00:13:25,869 --> 00:13:31,049
implemented by the vm m exp driver

00:13:44,110 --> 00:13:50,330
No so it says that once you get the IU

00:13:48,170 --> 00:13:52,850
CTL with the virtual address all you get

00:13:50,330 --> 00:13:54,800
is a DM FD so that's just an anonymous

00:13:52,850 --> 00:13:57,410
file descriptor representing the buffer

00:13:54,800 --> 00:13:59,360
so it's much similar to what would

00:13:57,410 --> 00:14:01,340
happen let's say if in V for l2 if you

00:13:59,360 --> 00:14:04,340
let's say a locker buffer and then run

00:14:01,340 --> 00:14:06,680
and ioctl to let's say V buff IOC

00:14:04,340 --> 00:14:09,140
underscore export you get a DM above FD

00:14:06,680 --> 00:14:10,820
so that's just a anonymous file

00:14:09,140 --> 00:14:12,980
descriptor which is again representing

00:14:10,820 --> 00:14:14,900
to the memory so in it's a concept of

00:14:12,980 --> 00:14:17,630
DMM buff is that you userspace need not

00:14:14,900 --> 00:14:20,120
have physical address or even virtual

00:14:17,630 --> 00:14:21,950
address you just get one file descriptor

00:14:20,120 --> 00:14:23,420
you can map it to get what virtual

00:14:21,950 --> 00:14:25,640
address but in general when you export

00:14:23,420 --> 00:14:27,380
you just get the file descriptor and the

00:14:25,640 --> 00:14:29,300
same case is happening in this case also

00:14:27,380 --> 00:14:31,790
the only difference is that we may

00:14:29,300 --> 00:14:34,520
experience the owner of the buffer it

00:14:31,790 --> 00:14:36,680
just has been given a pointer to the

00:14:34,520 --> 00:14:38,030
application memory and it is trying to

00:14:36,680 --> 00:14:43,720
figure out the corresponding physical

00:14:38,030 --> 00:14:46,610
addresses based on the memory so so this

00:14:43,720 --> 00:14:50,240
was a specific solution now we will try

00:14:46,610 --> 00:14:51,920
to apply the same solution on to the two

00:14:50,240 --> 00:14:56,150
to make it generally so what I am trying

00:14:51,920 --> 00:14:58,910
to explain here is that what we have

00:14:56,150 --> 00:15:02,090
done here is to take a virtual memory

00:14:58,910 --> 00:15:03,950
and then export it as DM above the

00:15:02,090 --> 00:15:06,440
advantage that we get with this is so

00:15:03,950 --> 00:15:08,060
now you can remove the artists in from

00:15:06,440 --> 00:15:10,250
the picture because artists was only

00:15:08,060 --> 00:15:12,560
introduced for the problem that we

00:15:10,250 --> 00:15:14,180
solved now you can have any memory that

00:15:12,560 --> 00:15:15,860
is there as part of the application and

00:15:14,180 --> 00:15:19,480
you want to share this memory with the

00:15:15,860 --> 00:15:21,980
other Linux drivers that you have so to

00:15:19,480 --> 00:15:24,350
work with other drivers which are

00:15:21,980 --> 00:15:26,150
capable of DM above import you still

00:15:24,350 --> 00:15:28,580
want to have that memory to be

00:15:26,150 --> 00:15:31,550
represented as DM above now this driver

00:15:28,580 --> 00:15:33,620
enables you to convert any virtual

00:15:31,550 --> 00:15:36,170
memory chunk into the DM above so the

00:15:33,620 --> 00:15:37,880
way that so the use cases that are

00:15:36,170 --> 00:15:40,670
enabled with that is you may have the

00:15:37,880 --> 00:15:43,400
memory mapped directly from let's say

00:15:40,670 --> 00:15:45,860
/dev /lm device you may have that memory

00:15:43,400 --> 00:15:47,420
from file descriptor file or you may

00:15:45,860 --> 00:15:50,390
have this memory mapped from a different

00:15:47,420 --> 00:15:52,040
driver so the the possibilities

00:15:50,390 --> 00:15:53,690
are countless you just need to have the

00:15:52,040 --> 00:15:55,280
virtual address pointer once you have

00:15:53,690 --> 00:15:57,580
the virtual address pointer you just

00:15:55,280 --> 00:16:01,210
give FD and give it to other drivers and

00:15:57,580 --> 00:16:04,490
from that point the use case is seamless

00:16:01,210 --> 00:16:07,220
so the ABI here is a simple character

00:16:04,490 --> 00:16:10,640
device you will have like /dev /v mm

00:16:07,220 --> 00:16:13,160
expe device and then currently there are

00:16:10,640 --> 00:16:14,780
like only two to three ioctl s define so

00:16:13,160 --> 00:16:17,510
it's a character driver with customized

00:16:14,780 --> 00:16:20,480
ADL's defined you just need to there's a

00:16:17,510 --> 00:16:22,280
stand there is a data structure defined

00:16:20,480 --> 00:16:24,620
where you need to pass a virtual address

00:16:22,280 --> 00:16:27,470
once you pass the virtual address so as

00:16:24,620 --> 00:16:28,910
it says in the diagram before you need

00:16:27,470 --> 00:16:32,060
to pass the virtual address to the

00:16:28,910 --> 00:16:34,760
driver and once the driver is able to do

00:16:32,060 --> 00:16:37,660
all the translations it will return DMA

00:16:34,760 --> 00:16:40,880
FD which application can use to pass on

00:16:37,660 --> 00:16:42,830
so as you pointed out how would you able

00:16:40,880 --> 00:16:45,920
to find out the physical addresses

00:16:42,830 --> 00:16:47,780
because to work with DMA buff you need

00:16:45,920 --> 00:16:51,160
to have the physical addresses the only

00:16:47,780 --> 00:16:53,360
way all the like as I mentioned typical

00:16:51,160 --> 00:16:55,670
DMF of exporters have been the

00:16:53,360 --> 00:16:57,890
allocators so if a driver is allocating

00:16:55,670 --> 00:16:59,150
the buffer that driver surely has the

00:16:57,890 --> 00:17:01,100
physical address because that's the one

00:16:59,150 --> 00:17:03,650
which is allocating the buffer so in

00:17:01,100 --> 00:17:05,750
case of v4 l2 and drm that's very easy

00:17:03,650 --> 00:17:07,339
but in this case all you have got is

00:17:05,750 --> 00:17:08,900
virtual address and you need to convert

00:17:07,339 --> 00:17:10,760
that virtual address into the physical

00:17:08,900 --> 00:17:13,190
address to actually find out the

00:17:10,760 --> 00:17:16,880
different pages that the memory points

00:17:13,190 --> 00:17:20,060
to so the way this is achieved is by

00:17:16,880 --> 00:17:22,820
drawing a software page walk so I will

00:17:20,060 --> 00:17:24,560
go through what exactly that is so

00:17:22,820 --> 00:17:26,420
basically you have a virtual address and

00:17:24,560 --> 00:17:27,980
then you need to find out what is the

00:17:26,420 --> 00:17:30,770
what are the different pages which are

00:17:27,980 --> 00:17:33,200
mapped by that virtual address and then

00:17:30,770 --> 00:17:35,660
once you have the list of all the pages

00:17:33,200 --> 00:17:39,250
that are point that are pointed by the

00:17:35,660 --> 00:17:44,060
virtual address you can export them as

00:17:39,250 --> 00:17:45,920
DMA ft so we are just highlighting one

00:17:44,060 --> 00:17:48,050
more time the features of these drivers

00:17:45,920 --> 00:17:50,930
are like you can export any virtual

00:17:48,050 --> 00:17:52,580
address so by emphasizing any what I

00:17:50,930 --> 00:17:55,010
mean by that is this is not specific to

00:17:52,580 --> 00:17:57,620
the artists application you can have

00:17:55,010 --> 00:17:59,600
memory mapped by a different driver

00:17:57,620 --> 00:18:03,110
which does not support PMF of export

00:17:59,600 --> 00:18:03,720
like you will have lot of C CMA drivers

00:18:03,110 --> 00:18:06,360
like for

00:18:03,720 --> 00:18:06,840
well Texas Instrument has this driver

00:18:06,360 --> 00:18:11,549
called

00:18:06,840 --> 00:18:13,919
CMM which is used for handling the seam

00:18:11,549 --> 00:18:15,840
areas continuous memory allocator but

00:18:13,919 --> 00:18:17,250
that driver is not capable of be a

00:18:15,840 --> 00:18:18,750
member of exporting so you can just

00:18:17,250 --> 00:18:20,400
allocate the buffers but once you have

00:18:18,750 --> 00:18:22,470
allocated the buffer you cannot give it

00:18:20,400 --> 00:18:24,419
to any other driver simply because the

00:18:22,470 --> 00:18:26,429
driver does not support the a member of

00:18:24,419 --> 00:18:27,960
export and this is just one example I'm

00:18:26,429 --> 00:18:29,909
sure in community there are a lot of

00:18:27,960 --> 00:18:32,159
drivers which are capable of handling

00:18:29,909 --> 00:18:34,140
the CMA buffers they are capable of

00:18:32,159 --> 00:18:36,059
allocating the buffers you can map the

00:18:34,140 --> 00:18:38,429
buffers but there does not have the

00:18:36,059 --> 00:18:40,740
support for DMF of export and

00:18:38,429 --> 00:18:42,990
essentially you cannot use this with the

00:18:40,740 --> 00:18:45,360
full chain of all other levers which can

00:18:42,990 --> 00:18:48,600
only work with the MFF import so that is

00:18:45,360 --> 00:18:51,330
one use case which is possible by you

00:18:48,600 --> 00:18:52,559
just map the different memory and once

00:18:51,330 --> 00:18:54,900
you have the memory mapped into the

00:18:52,559 --> 00:19:00,840
application you can export it as DM

00:18:54,900 --> 00:19:04,169
above so when I say a stable walk so

00:19:00,840 --> 00:19:07,020
this is a somebody had a question all

00:19:04,169 --> 00:19:08,549
right so this is a typical page table or

00:19:07,020 --> 00:19:10,770
walk diagram that you would see like

00:19:08,549 --> 00:19:12,630
this is an example for 32-bit ARM

00:19:10,770 --> 00:19:15,299
processor where you would have like a

00:19:12,630 --> 00:19:17,850
32-bit address now that address is

00:19:15,299 --> 00:19:19,860
divided into different parts like you

00:19:17,850 --> 00:19:23,669
need to go from the process specific

00:19:19,860 --> 00:19:25,740
page directory from the PG DPM DPT and

00:19:23,669 --> 00:19:28,260
then you will have the offset so in a

00:19:25,740 --> 00:19:30,690
typical Linux kernel depending on the

00:19:28,260 --> 00:19:33,780
architecture you may have the size of

00:19:30,690 --> 00:19:35,100
PGD PMD PT depending on the architecture

00:19:33,780 --> 00:19:36,929
it may vary this is just the example

00:19:35,100 --> 00:19:40,429
given further that it would be Tam

00:19:36,929 --> 00:19:42,750
processor so the logic here is that the

00:19:40,429 --> 00:19:45,240
address is divided into multiple pieces

00:19:42,750 --> 00:19:48,330
and you just need to figure out the

00:19:45,240 --> 00:19:51,080
right page pointing to that so you find

00:19:48,330 --> 00:19:57,570
out the process specific directory and

00:19:51,080 --> 00:19:59,549
you it's it's an array with a array with

00:19:57,570 --> 00:20:01,470
the contents pointing to a different

00:19:59,549 --> 00:20:03,750
page so basically you just need to take

00:20:01,470 --> 00:20:05,610
the PMD and index it with the PGD and

00:20:03,750 --> 00:20:08,460
then you will get the PT once you get

00:20:05,610 --> 00:20:11,190
the PT then it's again an array of the

00:20:08,460 --> 00:20:12,600
pages you need to index the page table

00:20:11,190 --> 00:20:14,760
and then you will get the actual

00:20:12,600 --> 00:20:16,600
addresses so this is how the typical

00:20:14,760 --> 00:20:18,730
paging works but most of the

00:20:16,600 --> 00:20:21,490
is actually done by hardware so of

00:20:18,730 --> 00:20:22,690
course all the architectures I mean at

00:20:21,490 --> 00:20:24,610
least the ARM architecture Intel

00:20:22,690 --> 00:20:26,860
Architecture have support for these in

00:20:24,610 --> 00:20:29,650
hardware so everything is happening in

00:20:26,860 --> 00:20:31,930
hardware but in this case what I am what

00:20:29,650 --> 00:20:33,580
I am doing here is a software page table

00:20:31,930 --> 00:20:35,020
work what I mean by that is I'm not

00:20:33,580 --> 00:20:36,940
really accessing I'm not really

00:20:35,020 --> 00:20:39,580
interested in accessing the memory

00:20:36,940 --> 00:20:42,330
pointed by the virtual address what I'm

00:20:39,580 --> 00:20:44,560
interested is I want to know what the

00:20:42,330 --> 00:20:46,570
physical address is pointed by that

00:20:44,560 --> 00:20:49,000
virtual address so what I am doing is I

00:20:46,570 --> 00:20:51,070
am just trying to go or the kernel data

00:20:49,000 --> 00:20:54,340
structures trying to find out where

00:20:51,070 --> 00:20:56,290
exactly these virtual address maps to so

00:20:54,340 --> 00:21:01,450
typically the virtual address is in

00:20:56,290 --> 00:21:02,770
continuous space but in DDR or in the

00:21:01,450 --> 00:21:04,600
physical space that might not be

00:21:02,770 --> 00:21:06,790
continuous so if you have like a range

00:21:04,600 --> 00:21:08,830
of one megabytes of virtual address

00:21:06,790 --> 00:21:10,870
range that may not mean that other

00:21:08,830 --> 00:21:13,660
physical address is actually cut here so

00:21:10,870 --> 00:21:16,420
you may have pages of 4k scattered all

00:21:13,660 --> 00:21:18,850
over the memory so you will end up

00:21:16,420 --> 00:21:22,870
finding out a scatter or gather list of

00:21:18,850 --> 00:21:25,120
addresses for the memory chunks that was

00:21:22,870 --> 00:21:27,130
continuous in virtual address so this is

00:21:25,120 --> 00:21:29,170
a typical use case like in the case of

00:21:27,130 --> 00:21:30,280
continuous virtual address it need not

00:21:29,170 --> 00:21:33,760
be the case that the physical address

00:21:30,280 --> 00:21:42,190
will also be continuous any questions on

00:21:33,760 --> 00:21:43,600
the page table software page table of

00:21:42,190 --> 00:21:46,660
course yes yes

00:21:43,600 --> 00:21:48,930
so driver did not do the full page table

00:21:46,660 --> 00:21:53,350
so there are in Linux kernel we have

00:21:48,930 --> 00:21:55,210
utility functions for for per page walk

00:21:53,350 --> 00:21:59,160
exactly and the driver uses those

00:21:55,210 --> 00:21:59,160
functions yeah

00:22:00,019 --> 00:22:07,549
sorry overcome it what exactly do you

00:22:05,190 --> 00:22:07,549
mean by that

00:22:13,090 --> 00:22:16,090
okay

00:22:17,000 --> 00:22:24,620
correct yeah so that's a really nice

00:22:22,190 --> 00:22:27,289
question actually so later in the

00:22:24,620 --> 00:22:28,429
slideshow I would show that in this

00:22:27,289 --> 00:22:30,530
implementation the current

00:22:28,429 --> 00:22:33,640
implementation we are not triggering the

00:22:30,530 --> 00:22:35,809
pitch fall so so the question here is to

00:22:33,640 --> 00:22:37,280
that how are we handling the over

00:22:35,809 --> 00:22:39,950
comments in the sense like sometimes

00:22:37,280 --> 00:22:42,650
your application may request that I want

00:22:39,950 --> 00:22:44,270
to allocate one megabytes of memory now

00:22:42,650 --> 00:22:45,890
in this case kernel may not actually

00:22:44,270 --> 00:22:48,289
allocate the man megabytes of memory

00:22:45,890 --> 00:22:50,390
so there are virtual addresses for which

00:22:48,289 --> 00:22:52,700
there is no physical address so the only

00:22:50,390 --> 00:22:54,919
way the physical pages will be allocated

00:22:52,700 --> 00:22:57,260
is when the application actually starts

00:22:54,919 --> 00:22:58,909
using the virtual addresses now his

00:22:57,260 --> 00:23:00,620
question is that how will you find the

00:22:58,909 --> 00:23:02,330
physical address if there is no mapping

00:23:00,620 --> 00:23:04,340
set between the virtual and physical

00:23:02,330 --> 00:23:06,230
addresses so the only way that can

00:23:04,340 --> 00:23:07,820
happen is if you trigger the page fault

00:23:06,230 --> 00:23:09,650
so generally the trigger the page fault

00:23:07,820 --> 00:23:11,450
will be triggered only if the

00:23:09,650 --> 00:23:13,730
application is trying to access that

00:23:11,450 --> 00:23:16,400
memory and that is generally handled by

00:23:13,730 --> 00:23:17,840
hardware because hardware the memory

00:23:16,400 --> 00:23:19,909
management unit will just trigger a

00:23:17,840 --> 00:23:21,620
interrupt and the kernel will take care

00:23:19,909 --> 00:23:23,659
of making sure that there is a page

00:23:21,620 --> 00:23:25,100
associated with this now in this case

00:23:23,659 --> 00:23:26,960
you are not accessing the memory you are

00:23:25,100 --> 00:23:28,220
just trying to find the mapping but you

00:23:26,960 --> 00:23:29,690
want to make sure that there is a

00:23:28,220 --> 00:23:32,030
mapping before you try to get the

00:23:29,690 --> 00:23:34,250
mapping so that can be done by

00:23:32,030 --> 00:23:36,169
triggering the page faults manually

00:23:34,250 --> 00:23:46,450
that's the theory but it is not

00:23:36,169 --> 00:23:46,450
currently implemented okay sorry

00:23:47,500 --> 00:23:50,220
sorry

00:23:54,680 --> 00:23:58,750
what do you mean by special mappings

00:24:14,020 --> 00:24:18,400
so this part is done in colonel so once

00:24:17,170 --> 00:24:20,230
the application gives the virtual

00:24:18,400 --> 00:24:22,270
address all over the next all of the

00:24:20,230 --> 00:24:24,280
next procedure is done by colonel so

00:24:22,270 --> 00:24:29,590
colonel will get the physical address by

00:24:24,280 --> 00:24:32,429
walking through the page table I am NOT

00:24:29,590 --> 00:24:32,429
able to hear you clearly

00:24:42,030 --> 00:24:46,050
yes so this is just an example depending

00:24:44,940 --> 00:24:50,670
on the architecture it will be a

00:24:46,050 --> 00:24:52,710
different PT PMD but in Colonel the EPS

00:24:50,670 --> 00:24:54,630
that are there are generic enough that

00:24:52,710 --> 00:24:56,070
the same code that we have will work on

00:24:54,630 --> 00:24:58,770
different architects just depending on

00:24:56,070 --> 00:25:08,010
the different sized PT and PM DS that we

00:24:58,770 --> 00:25:09,570
have any other questions all right so I

00:25:08,010 --> 00:25:12,450
have been talking a lot about you know

00:25:09,570 --> 00:25:15,060
trying to convert the virtual address

00:25:12,450 --> 00:25:17,820
into the physical address so but very

00:25:15,060 --> 00:25:19,320
lack unlikely we will use this to the

00:25:17,820 --> 00:25:22,080
extent that I have been talking about

00:25:19,320 --> 00:25:24,330
typically we will use it for the buffers

00:25:22,080 --> 00:25:26,180
which we really intend to share like for

00:25:24,330 --> 00:25:28,920
example there is no point sharing

00:25:26,180 --> 00:25:30,900
non-contiguous before with the driver

00:25:28,920 --> 00:25:33,090
which expects a continuous buffer so

00:25:30,900 --> 00:25:34,770
let's say if you allow Malaka buffer of

00:25:33,090 --> 00:25:36,000
course that will be continuous in

00:25:34,770 --> 00:25:37,860
virtual address but it will not be

00:25:36,000 --> 00:25:40,290
continuous in the physical address space

00:25:37,860 --> 00:25:41,670
now you can export that buffer as a DM

00:25:40,290 --> 00:25:44,010
above you will get the scatter the other

00:25:41,670 --> 00:25:46,200
list but if you get the if you get this

00:25:44,010 --> 00:25:47,580
DMA FD and give it to a driver which

00:25:46,200 --> 00:25:50,370
expects a continuous buffer it will

00:25:47,580 --> 00:25:52,670
simply fail so the drag the driver that

00:25:50,370 --> 00:25:56,280
we are talking about enables you to

00:25:52,670 --> 00:25:57,810
export virtual memory as DM above but

00:25:56,280 --> 00:26:01,050
that does not mean that it solves your

00:25:57,810 --> 00:26:04,500
problem of you know it acts as a MMU it

00:26:01,050 --> 00:26:08,100
cannot act as mmm you the device are the

00:26:04,500 --> 00:26:10,650
peripherals are not smart enough to work

00:26:08,100 --> 00:26:13,020
with katawaga so if the device expects

00:26:10,650 --> 00:26:15,240
physical memory physically continuous

00:26:13,020 --> 00:26:17,220
memory you got to pass the buffer which

00:26:15,240 --> 00:26:19,200
is actually physically continuous even

00:26:17,220 --> 00:26:20,580
if you pass like a virtually continuous

00:26:19,200 --> 00:26:24,510
buffer you will get a scatter the other

00:26:20,580 --> 00:26:26,100
list with let's say 100 entries so the

00:26:24,510 --> 00:26:29,010
important driver will simply fail

00:26:26,100 --> 00:26:31,890
because the physical buffer is not

00:26:29,010 --> 00:26:37,340
continuous in space sorry it is not

00:26:31,890 --> 00:26:37,340
continuous in physical space yes

00:26:45,500 --> 00:26:50,640
so even if the application crashes

00:26:48,450 --> 00:26:52,890
crashes when the application crashes you

00:26:50,640 --> 00:26:55,170
will have all the file descriptors

00:26:52,890 --> 00:26:56,520
associated with that application will be

00:26:55,170 --> 00:26:57,990
closed at the time of killing the

00:26:56,520 --> 00:26:59,790
application or exiting the application

00:26:57,990 --> 00:27:03,150
so it's the Colonel's job to make sure

00:26:59,790 --> 00:27:06,390
that the DMM of ref count is decreased

00:27:03,150 --> 00:27:08,340
by one every time descriptive associated

00:27:06,390 --> 00:27:11,250
with that is closed and once the DMF of

00:27:08,340 --> 00:27:12,990
count ref count reaches to zero because

00:27:11,250 --> 00:27:14,760
when I'm talking about ref counting

00:27:12,990 --> 00:27:18,240
because the same DMF will be used by

00:27:14,760 --> 00:27:20,220
multiple drivers so I add at one point

00:27:18,240 --> 00:27:22,530
there would be a case where when the

00:27:20,220 --> 00:27:23,130
application has crashed all the DMM of

00:27:22,530 --> 00:27:25,410
FDS

00:27:23,130 --> 00:27:27,630
will be closed one by one and at one

00:27:25,410 --> 00:27:29,910
point of time the ref count of the DMF

00:27:27,630 --> 00:27:32,190
will go 0 and then that kernel kernel

00:27:29,910 --> 00:27:33,630
callbacks gets triggered in and at that

00:27:32,190 --> 00:27:37,850
point of time you can do all the cleanup

00:27:33,630 --> 00:27:41,460
that is necessary to handle the scenario

00:27:37,850 --> 00:27:44,340
does that answer your question all right

00:27:41,460 --> 00:27:46,440
so this driver supports both physically

00:27:44,340 --> 00:27:48,810
continuous buffers or scatter gather

00:27:46,440 --> 00:27:51,650
buffers it is generic enough but it's up

00:27:48,810 --> 00:27:53,880
to the usage of how you want to use it

00:27:51,650 --> 00:27:56,960
second point I want to mention here is

00:27:53,880 --> 00:27:59,340
that I have been talking about pages

00:27:56,960 --> 00:28:01,380
what I mean by that is if you give me a

00:27:59,340 --> 00:28:04,650
virtual address which is not really page

00:28:01,380 --> 00:28:07,830
aligned now it's a question about how do

00:28:04,650 --> 00:28:09,750
I share this chunk of memory with

00:28:07,830 --> 00:28:12,390
another driver because I will typically

00:28:09,750 --> 00:28:13,860
share a scatter gather list with let's

00:28:12,390 --> 00:28:18,960
say these are these are all the pages

00:28:13,860 --> 00:28:21,090
that are part of this DM above but I can

00:28:18,960 --> 00:28:22,590
include an offset but most of the DM of

00:28:21,090 --> 00:28:25,020
imported drivers that are there

00:28:22,590 --> 00:28:27,120
currently they do not respect the offset

00:28:25,020 --> 00:28:29,130
so even if you if you gave let's say 10

00:28:27,120 --> 00:28:31,380
pages but you say that the first first

00:28:29,130 --> 00:28:33,360
page offset is let us say 2 K the driver

00:28:31,380 --> 00:28:35,910
generally are typically ignores the

00:28:33,360 --> 00:28:37,860
offset and starts using the pages from

00:28:35,910 --> 00:28:39,840
the first byte itself so it is generally

00:28:37,860 --> 00:28:43,230
recommended that you try to use this

00:28:39,840 --> 00:28:44,820
method only for the cases where the

00:28:43,230 --> 00:28:47,610
physical or the virtual addresses are

00:28:44,820 --> 00:28:49,120
page aligned but it will still work for

00:28:47,610 --> 00:28:51,280
the non non

00:28:49,120 --> 00:28:55,000
and use cases but it is not recommended

00:28:51,280 --> 00:29:15,600
because other drivers do not respect the

00:28:55,000 --> 00:29:15,600
officers know it gets the DM FD yes

00:29:20,880 --> 00:29:35,460
again in the kernel space yes so this

00:29:24,520 --> 00:29:35,460
diagram here explains it correct no no

00:29:39,750 --> 00:29:59,800
yes yes first thing in very rare use

00:29:57,880 --> 00:30:01,870
cases in embedded applications you will

00:29:59,800 --> 00:30:03,910
not have most of the swapping in place

00:30:01,870 --> 00:30:05,500
in case you have the swapping in place

00:30:03,910 --> 00:30:07,900
we will have the control in such a way

00:30:05,500 --> 00:30:10,630
that whenever you are accessing a

00:30:07,900 --> 00:30:12,460
specific virtual address and exporting

00:30:10,630 --> 00:30:14,590
it as DM above the driver makes sure

00:30:12,460 --> 00:30:19,150
that the it pins the buffer into the

00:30:14,590 --> 00:30:21,520
memory so that at any point of time no

00:30:19,150 --> 00:30:22,930
no but this is all happening from the

00:30:21,520 --> 00:30:25,600
Linux so let's say if you have a virtual

00:30:22,930 --> 00:30:27,550
address you give it to the Qatar kernel

00:30:25,600 --> 00:30:29,620
driver now the kernel driver makes sure

00:30:27,550 --> 00:30:31,720
that this page is pinned into the memory

00:30:29,620 --> 00:30:33,520
so that kernel does not swap it out if

00:30:31,720 --> 00:30:35,560
the kernel does not swap it out that

00:30:33,520 --> 00:30:38,350
virtual address also remains to be same

00:30:35,560 --> 00:30:40,620
as long as the DMM of in question is in

00:30:38,350 --> 00:30:40,620
use

00:30:42,850 --> 00:30:49,360
an application and you want to associate

00:30:46,060 --> 00:31:11,800
it with one some specific pre-allocated

00:30:49,360 --> 00:31:14,020
physical address by doing the page table

00:31:11,800 --> 00:31:16,000
walk but once you have the page done the

00:31:14,020 --> 00:31:19,090
page table walk you find out the all the

00:31:16,000 --> 00:31:23,160
pages and you you pin them so you make

00:31:19,090 --> 00:31:23,160
sure that the swapping swapping does not

00:31:32,280 --> 00:31:36,940
sure yeah oh sorry I have taken a lot of

00:31:35,320 --> 00:31:42,220
time okay I'll just run through quickly

00:31:36,940 --> 00:31:44,050
so yeah so basically to make it generic

00:31:42,220 --> 00:31:46,000
what I am trying to say here is that you

00:31:44,050 --> 00:31:49,060
can map a memory you can map a driver

00:31:46,000 --> 00:31:50,980
handle you can map a file and for each

00:31:49,060 --> 00:31:52,330
of these use cases you'll have a virtual

00:31:50,980 --> 00:31:54,970
address and the corresponding physical

00:31:52,330 --> 00:31:56,620
addresses so depending on what happens

00:31:54,970 --> 00:31:58,300
in the page fault handler you may be

00:31:56,620 --> 00:32:00,700
simply accessing the memory you may be

00:31:58,300 --> 00:32:02,500
actually reading from the file or you

00:32:00,700 --> 00:32:05,050
may be reading from that's a driver

00:32:02,500 --> 00:32:06,940
specific callback you just trigger the

00:32:05,050 --> 00:32:10,630
page fault handler and then get the

00:32:06,940 --> 00:32:13,840
memory done so the way this will come up

00:32:10,630 --> 00:32:16,270
in the use case is that you can somehow

00:32:13,840 --> 00:32:17,710
map the memory into the application get

00:32:16,270 --> 00:32:20,020
the virtual address and then pass this

00:32:17,710 --> 00:32:23,920
virtual address to the driver and then

00:32:20,020 --> 00:32:25,960
start sharing that memory so yeah as you

00:32:23,920 --> 00:32:28,840
said now we will move to the part where

00:32:25,960 --> 00:32:32,020
how does this apply to you know generic

00:32:28,840 --> 00:32:35,110
use cases so I talked about the regular

00:32:32,020 --> 00:32:37,810
Linux frameworks like gstreamer and Vail

00:32:35,110 --> 00:32:41,740
and trying to use these at you use these

00:32:37,810 --> 00:32:44,230
memory so a typical use case what you

00:32:41,740 --> 00:32:47,650
would see is if you allocate from the mm

00:32:44,230 --> 00:32:48,940
of exporter you need to export using the

00:32:47,650 --> 00:32:50,590
same driver the first thing you have to

00:32:48,940 --> 00:32:52,840
do is allocate the memory and then you

00:32:50,590 --> 00:32:54,279
have to export it but in this case the

00:32:52,840 --> 00:32:56,649
advantage you can get is you can

00:32:54,279 --> 00:32:58,690
a locate first sorry you can allocate

00:32:56,649 --> 00:33:00,639
from any driver and then you can export

00:32:58,690 --> 00:33:02,229
like in the typical embedded use cases

00:33:00,639 --> 00:33:04,929
you will have let's say ten drivers but

00:33:02,229 --> 00:33:06,849
out of them only one driver supports TMF

00:33:04,929 --> 00:33:08,769
of export typically the drm driver which

00:33:06,849 --> 00:33:10,479
supports the DMM of exports oh you

00:33:08,769 --> 00:33:12,999
allocate from drm and then give it to

00:33:10,479 --> 00:33:14,200
all other drivers but in this case you

00:33:12,999 --> 00:33:16,119
can actually allocate from a different

00:33:14,200 --> 00:33:18,070
driver as I mentioned there might be a

00:33:16,119 --> 00:33:19,840
si mi driver that you you that you are

00:33:18,070 --> 00:33:21,249
interested to allocate buffers from you

00:33:19,840 --> 00:33:23,019
can allocate the buffers from there and

00:33:21,249 --> 00:33:24,549
then simply export so there's this

00:33:23,019 --> 00:33:27,879
avoids the dependency between the

00:33:24,549 --> 00:33:30,460
allocation and export so another point

00:33:27,879 --> 00:33:32,559
to look at it this way is that from a

00:33:30,460 --> 00:33:35,139
GStreamer use case perfectly you will

00:33:32,559 --> 00:33:36,909
have like multiple pipelines multiple

00:33:35,139 --> 00:33:39,969
elements in the pipeline now the way

00:33:36,909 --> 00:33:41,499
some of the plugins are or elements are

00:33:39,969 --> 00:33:43,450
written in such a way that they allocate

00:33:41,499 --> 00:33:45,009
their own memory I mean for example it's

00:33:43,450 --> 00:33:47,019
a video test asaji I'm just giving an

00:33:45,009 --> 00:33:49,149
example it might not be correct let us

00:33:47,019 --> 00:33:51,099
say video test SRC it says open it's a

00:33:49,149 --> 00:33:53,320
software element which is just to

00:33:51,099 --> 00:33:55,690
generate a test video data no it does

00:33:53,320 --> 00:33:57,249
not have any special buffer requirement

00:33:55,690 --> 00:33:59,619
so it will just allocate the buffers on

00:33:57,249 --> 00:34:01,960
its own using let's say malloc now you

00:33:59,619 --> 00:34:03,519
cannot use this memory to share it with

00:34:01,960 --> 00:34:05,499
other drivers because simply it is not a

00:34:03,519 --> 00:34:07,629
game above so the only way it will work

00:34:05,499 --> 00:34:10,270
is you need to allocate buffers using

00:34:07,629 --> 00:34:12,220
DRM share those buffers with the source

00:34:10,270 --> 00:34:15,730
element and then generate the content

00:34:12,220 --> 00:34:17,319
into it and then use it for the all

00:34:15,730 --> 00:34:20,139
whatever operation you are supposed to

00:34:17,319 --> 00:34:22,619
do so there is a dependency on content

00:34:20,139 --> 00:34:25,480
generation so even if you want if the

00:34:22,619 --> 00:34:27,669
element wants to generate content by its

00:34:25,480 --> 00:34:29,710
own it is not allowed to allocate

00:34:27,669 --> 00:34:31,329
buffers of its own in it it needs to ask

00:34:29,710 --> 00:34:34,119
somebody else to allocate buffers for

00:34:31,329 --> 00:34:36,579
itself and then write content into it so

00:34:34,119 --> 00:34:40,470
with this what the this dependency is

00:34:36,579 --> 00:34:43,270
not there because you can simply ask the

00:34:40,470 --> 00:34:46,109
element to allocate memory from and then

00:34:43,270 --> 00:34:50,289
you can share it with the other driver

00:34:46,109 --> 00:34:55,270
so second part is about the memory

00:34:50,289 --> 00:34:59,260
sharing so in typical compositor

00:34:55,270 --> 00:35:01,000
applications you will have like graphics

00:34:59,260 --> 00:35:03,819
applications which are acting as a

00:35:01,000 --> 00:35:06,380
clients and then there is a composition

00:35:03,819 --> 00:35:08,480
server like Western or x11

00:35:06,380 --> 00:35:09,620
and so basically the communication

00:35:08,480 --> 00:35:11,630
between the client and the server

00:35:09,620 --> 00:35:13,700
happens wire socket and the memory

00:35:11,630 --> 00:35:16,370
shared using the socket because they are

00:35:13,700 --> 00:35:18,590
these are two different processes you

00:35:16,370 --> 00:35:21,010
need to use shared memory to access to

00:35:18,590 --> 00:35:24,530
share buffers from let's say a client to

00:35:21,010 --> 00:35:26,900
server so a typical graph except example

00:35:24,530 --> 00:35:28,750
if you take away veil and application so

00:35:26,900 --> 00:35:32,750
in such case if you have a texture or

00:35:28,750 --> 00:35:35,000
shader which is when run from a client

00:35:32,750 --> 00:35:37,490
application now that needs to be

00:35:35,000 --> 00:35:39,110
allocated in a shared memory first you

00:35:37,490 --> 00:35:41,690
need to allocate a shared memory and

00:35:39,110 --> 00:35:44,120
then render all your content into that

00:35:41,690 --> 00:35:49,280
one only then you can give that buffer

00:35:44,120 --> 00:35:51,410
to the villain server for it to be

00:35:49,280 --> 00:35:54,110
displayed in a zero copy manner if that

00:35:51,410 --> 00:35:56,420
does not happen then you will let's say

00:35:54,110 --> 00:35:59,590
allocate in your own application space

00:35:56,420 --> 00:36:01,460
and then when you give that buffer to

00:35:59,590 --> 00:36:03,650
Waylon that won't happen

00:36:01,460 --> 00:36:05,090
so the way internally Waylon would do is

00:36:03,650 --> 00:36:07,100
like it will allocate a shared memory

00:36:05,090 --> 00:36:08,540
copy your buffer from your application

00:36:07,100 --> 00:36:11,420
into the shared memory and then start

00:36:08,540 --> 00:36:14,870
using it so by doing this you are

00:36:11,420 --> 00:36:17,410
actually essentially sharing one

00:36:14,870 --> 00:36:20,690
processors memory to another process by

00:36:17,410 --> 00:36:23,930
by the means of VM above so I think this

00:36:20,690 --> 00:36:25,490
diagram will be helpful here so it's a

00:36:23,930 --> 00:36:27,500
simple diagram where you have like two

00:36:25,490 --> 00:36:30,920
processes process 1 and process 2 and

00:36:27,500 --> 00:36:33,380
let's say the middle layer is the

00:36:30,920 --> 00:36:36,080
virtual address space and then the much

00:36:33,380 --> 00:36:38,240
middle level is the applications virtual

00:36:36,080 --> 00:36:40,340
address space and the final level is the

00:36:38,240 --> 00:36:42,530
physical address space you can see that

00:36:40,340 --> 00:36:44,570
each virtual address may be mapped like

00:36:42,530 --> 00:36:47,360
different addresses you may have some

00:36:44,570 --> 00:36:50,750
shared shared pages which are common for

00:36:47,360 --> 00:36:52,790
like two processes now if you use the

00:36:50,750 --> 00:36:56,630
virtual memory exporter driver and if

00:36:52,790 --> 00:36:58,430
you want to export one of the one of the

00:36:56,630 --> 00:37:00,620
memory chunk from let us say process 1

00:36:58,430 --> 00:37:02,570
to process two the way it can be done is

00:37:00,620 --> 00:37:05,360
you can get this virtual address give it

00:37:02,570 --> 00:37:08,120
to the virtual memory exporter driver

00:37:05,360 --> 00:37:10,460
and then you will get the DM ft with the

00:37:08,120 --> 00:37:13,340
socket FD passing you can pass this FD

00:37:10,460 --> 00:37:15,530
to the different process and then map it

00:37:13,340 --> 00:37:17,180
so once you have a map you are actually

00:37:15,530 --> 00:37:19,759
accessing a different processors memory

00:37:17,180 --> 00:37:22,249
as a memory from process

00:37:19,759 --> 00:37:24,559
the way this happens is now you can see

00:37:22,249 --> 00:37:27,139
that after the export and map the same

00:37:24,559 --> 00:37:28,909
page which was earlier part of dedicated

00:37:27,139 --> 00:37:31,069
for process one has now become a shared

00:37:28,909 --> 00:37:32,749
page so in this case you're not

00:37:31,069 --> 00:37:34,669
allocating share in memory and then

00:37:32,749 --> 00:37:36,529
utilizing it at here already utilized a

00:37:34,669 --> 00:37:38,779
memory you already have a buffer which

00:37:36,529 --> 00:37:41,059
is part of an application now by doing

00:37:38,779 --> 00:37:43,399
this you are sharing the existing buffer

00:37:41,059 --> 00:37:45,619
into another process this is quite

00:37:43,399 --> 00:37:47,659
useful when you have to integrate let's

00:37:45,619 --> 00:37:50,569
say open source applications like you

00:37:47,659 --> 00:37:52,880
may have a lot of so the second point

00:37:50,569 --> 00:37:54,469
here is about components allocating own

00:37:52,880 --> 00:37:56,869
memory for buffers like you will have

00:37:54,469 --> 00:37:58,969
lot of GStreamer plugins custom shared

00:37:56,869 --> 00:38:00,889
shaders and textures just for

00:37:58,969 --> 00:38:02,779
prototyping purpose you want to utilize

00:38:00,889 --> 00:38:05,299
them as is now if it is allocating

00:38:02,779 --> 00:38:08,329
buffers of its own you cannot pass it to

00:38:05,299 --> 00:38:09,679
a different process and the the use case

00:38:08,329 --> 00:38:11,929
for passing into different processes

00:38:09,679 --> 00:38:15,259
also valid use case like in case of

00:38:11,929 --> 00:38:16,609
Weiland or any display compositor

00:38:15,259 --> 00:38:18,529
application you need to pass it to a

00:38:16,609 --> 00:38:20,749
server and which is going to be an

00:38:18,529 --> 00:38:23,299
essentially different process so this

00:38:20,749 --> 00:38:27,579
will help you to solve that problem

00:38:23,299 --> 00:38:27,579
without doing any buffer copy yes

00:38:40,530 --> 00:38:53,010
yes DRM does so yes yes yes

00:38:50,610 --> 00:38:55,050
so now DRM supports importing of DM

00:38:53,010 --> 00:38:57,060
above so as long as the buffer

00:38:55,050 --> 00:38:59,580
constraints are met I am NOT saying that

00:38:57,060 --> 00:39:01,590
you can you can export any memory but

00:38:59,580 --> 00:39:04,080
you cannot consume any memory so if the

00:39:01,590 --> 00:39:06,840
memories contiguous and DRM is okay with

00:39:04,080 --> 00:39:08,850
that continuous memory and if it is if

00:39:06,840 --> 00:39:11,250
it satisfies all the constraints which

00:39:08,850 --> 00:39:14,600
DRM expects for importing it will be

00:39:11,250 --> 00:39:17,600
able to share that memory with zero copy

00:39:14,600 --> 00:39:17,600
yes

00:39:31,320 --> 00:39:37,300
so we have not done any performance

00:39:34,300 --> 00:39:39,280
analysis but surely in the case of

00:39:37,300 --> 00:39:43,150
embedded use cases you will not be doing

00:39:39,280 --> 00:39:47,260
lot of lot of maps and unnerves in the

00:39:43,150 --> 00:39:50,050
sense in case you want the in case you

00:39:47,260 --> 00:39:53,110
want the access of that memory from CPU

00:39:50,050 --> 00:39:56,620
only then you will map in regular use

00:39:53,110 --> 00:39:58,870
cases you want the the device on the

00:39:56,620 --> 00:40:01,540
peripheral to access it so in such cases

00:39:58,870 --> 00:40:03,280
only DMA for above would suffice only if

00:40:01,540 --> 00:40:05,410
you want a CPU access in that case you

00:40:03,280 --> 00:40:07,510
will do a memory mapping and as you said

00:40:05,410 --> 00:40:09,640
if you do map you need to make sure that

00:40:07,510 --> 00:40:11,560
the cache is for that process is updated

00:40:09,640 --> 00:40:13,630
so that the new mapping are reflected

00:40:11,560 --> 00:40:15,010
but of course if you want to do a CPU

00:40:13,630 --> 00:40:18,190
mapping you need to make sure that the

00:40:15,010 --> 00:40:23,800
CPR the cache overheads are I mean you

00:40:18,190 --> 00:40:27,070
need to plan for that I think last two

00:40:23,800 --> 00:40:28,420
points is like yeah export as DMA buff

00:40:27,070 --> 00:40:31,120
and share across process I have already

00:40:28,420 --> 00:40:33,550
talked about that so basically this is

00:40:31,120 --> 00:40:35,100
almost like share memory but it's in a

00:40:33,550 --> 00:40:38,050
different way that you are actually

00:40:35,100 --> 00:40:41,770
sharing an existing memory so you have a

00:40:38,050 --> 00:40:44,170
memory from one process and this after

00:40:41,770 --> 00:40:46,360
some point of time let's say you think

00:40:44,170 --> 00:40:48,910
that okay this part should have been a

00:40:46,360 --> 00:40:50,590
shared memory now the only way it can

00:40:48,910 --> 00:40:52,120
work is you allocate a new buffer which

00:40:50,590 --> 00:40:54,820
is a shared memory between two processes

00:40:52,120 --> 00:40:56,410
and then copy the contents but with this

00:40:54,820 --> 00:40:58,120
driver you don't have to actually do any

00:40:56,410 --> 00:41:01,180
copy you can just simply use the DM

00:40:58,120 --> 00:41:06,240
above pass the DMF using socket and then

00:41:01,180 --> 00:41:06,240
once you have done this passing you can

00:41:06,270 --> 00:41:12,580
map it to a different process I think

00:41:09,910 --> 00:41:15,160
that's it yeah okay so I have already

00:41:12,580 --> 00:41:17,890
talked about the use cases of course the

00:41:15,160 --> 00:41:19,600
first thing that I would say is this

00:41:17,890 --> 00:41:21,700
solution helped us to integrate the

00:41:19,600 --> 00:41:25,150
artists applications with Linux it

00:41:21,700 --> 00:41:27,280
enables you to use some of the drivers

00:41:25,150 --> 00:41:29,500
which are not capable of DM above export

00:41:27,280 --> 00:41:31,750
you just map the memory and then use

00:41:29,500 --> 00:41:35,080
this driver which essentially provides

00:41:31,750 --> 00:41:37,300
you the DMF of export capability then

00:41:35,080 --> 00:41:40,000
eyesand about the shared memory map from

00:41:37,300 --> 00:41:43,510
different drivers okay there is another

00:41:40,000 --> 00:41:44,100
interesting use case like now I am

00:41:43,510 --> 00:41:45,990
talking about

00:41:44,100 --> 00:41:47,820
GPU and displays specifically here only

00:41:45,990 --> 00:41:48,240
for this specific use case I am talking

00:41:47,820 --> 00:41:50,970
about

00:41:48,240 --> 00:41:53,460
so GPU typically has MMU so it's not

00:41:50,970 --> 00:41:55,740
like a dumb device it is a smart device

00:41:53,460 --> 00:41:57,900
which has got a MMU so it can handle

00:41:55,740 --> 00:41:59,940
scatter the other pages so with this

00:41:57,900 --> 00:42:01,980
driver I am able to actually allocate a

00:41:59,940 --> 00:42:04,800
buffer from using malach and then

00:42:01,980 --> 00:42:08,370
convert it into a DMF and pass it to drm

00:42:04,800 --> 00:42:10,500
so before this drm never supported to

00:42:08,370 --> 00:42:12,420
accept any user pointer kind of use

00:42:10,500 --> 00:42:14,700
cases but with this you can just simply

00:42:12,420 --> 00:42:17,460
allocate a buffer using malloc and then

00:42:14,700 --> 00:42:19,980
pass it to DRAM with DM above so that

00:42:17,460 --> 00:42:24,420
was one of the new use case we were able

00:42:19,980 --> 00:42:25,950
to achieve and then share a processors

00:42:24,420 --> 00:42:29,700
memory to other processor have covered

00:42:25,950 --> 00:42:31,830
that yeah and last point is about the

00:42:29,700 --> 00:42:34,020
gstreamer integration where you have the

00:42:31,830 --> 00:42:35,430
software components lot of software

00:42:34,020 --> 00:42:37,440
components which are allocating memory

00:42:35,430 --> 00:42:39,450
on its own once they have allocated the

00:42:37,440 --> 00:42:41,660
memory you can simply export it using

00:42:39,450 --> 00:42:41,660
DMA

00:42:41,900 --> 00:42:47,130
think yeah okay so when we are talking

00:42:45,420 --> 00:42:48,390
about you know converting from physical

00:42:47,130 --> 00:42:50,370
virtual address to physical address

00:42:48,390 --> 00:42:53,610
there are a lot of security concerns

00:42:50,370 --> 00:42:55,140
here like should we be doing the correct

00:42:53,610 --> 00:42:57,270
ref counting should we be doing the

00:42:55,140 --> 00:42:59,370
shoot should we be making sure that the

00:42:57,270 --> 00:43:01,230
purchase pages don't get swapped out

00:42:59,370 --> 00:43:03,420
from the memory you need to make sure

00:43:01,230 --> 00:43:05,160
that let's say application says that

00:43:03,420 --> 00:43:07,620
this is my virtual address and I want

00:43:05,160 --> 00:43:09,810
like 4 MB after that virtual address but

00:43:07,620 --> 00:43:12,000
you are actually allocated only 2 MB so

00:43:09,810 --> 00:43:13,950
application may give you a wrong sizes

00:43:12,000 --> 00:43:15,540
but it's the kernels job to find out

00:43:13,950 --> 00:43:18,000
that there are no segmentation errors

00:43:15,540 --> 00:43:19,710
but that generally typically happens in

00:43:18,000 --> 00:43:21,870
the case when you are doing page work

00:43:19,710 --> 00:43:23,430
you would try to find out for each page

00:43:21,870 --> 00:43:26,210
and at some point of time you will find

00:43:23,430 --> 00:43:28,470
out that that is a page fault

00:43:26,210 --> 00:43:30,360
now the first question that came here

00:43:28,470 --> 00:43:32,790
was how to how do you handle the

00:43:30,360 --> 00:43:35,040
overcome it but yeah that can be handled

00:43:32,790 --> 00:43:37,080
by doing the PI triggering the page

00:43:35,040 --> 00:43:38,790
fault so that the mapping between the

00:43:37,080 --> 00:43:43,140
virtual and physical addresses is

00:43:38,790 --> 00:43:45,630
created before you sty doing the page

00:43:43,140 --> 00:43:47,100
walk and then there are some open

00:43:45,630 --> 00:43:48,990
questions like sure we should be

00:43:47,100 --> 00:43:51,060
restriction off certain memory because

00:43:48,990 --> 00:43:52,590
we now we can share any memory so we can

00:43:51,060 --> 00:43:54,480
share like data segment we can share

00:43:52,590 --> 00:43:55,420
code segment so there might be some

00:43:54,480 --> 00:43:56,950
psychotic

00:43:55,420 --> 00:44:00,190
concerns because you don't want to share

00:43:56,950 --> 00:44:02,130
a specific segment of process to another

00:44:00,190 --> 00:44:04,599
process so should there be any

00:44:02,130 --> 00:44:06,760
constraints on to you know you want to

00:44:04,599 --> 00:44:09,579
share only the data segment or let's say

00:44:06,760 --> 00:44:12,010
you want to not share a specific segment

00:44:09,579 --> 00:44:15,519
of the memory so these are the questions

00:44:12,010 --> 00:44:17,650
which are like kept open and I hope that

00:44:15,519 --> 00:44:21,480
community would give me the right

00:44:17,650 --> 00:44:23,619
responses to that yeah and as also one

00:44:21,480 --> 00:44:25,420
gentleman mentioned that you need to

00:44:23,619 --> 00:44:27,789
handle the races between like if the

00:44:25,420 --> 00:44:29,470
application crisis hour let's say are

00:44:27,789 --> 00:44:31,000
different there are multiple users and

00:44:29,470 --> 00:44:35,470
how do you handle between the race case

00:44:31,000 --> 00:44:37,839
of the unmanned closed thing that's it

00:44:35,470 --> 00:44:44,559
these are all the references if you have

00:44:37,839 --> 00:44:47,500
any questions so this has been

00:44:44,559 --> 00:44:51,010
implemented on 4.4 kernel but I think

00:44:47,500 --> 00:44:53,170
I'm planning to put a proposal and then

00:44:51,010 --> 00:44:54,910
I'm not really sure how much time will

00:44:53,170 --> 00:44:56,589
it take but at least the idea will start

00:44:54,910 --> 00:44:58,660
I will start rolling out in the mailing

00:44:56,589 --> 00:45:00,400
list and depending on how many rounds it

00:44:58,660 --> 00:45:02,319
take for the different patch sets I

00:45:00,400 --> 00:45:04,650
cannot commit but at least I'll try my

00:45:02,319 --> 00:45:04,650
best

00:45:05,670 --> 00:45:09,299
any other questions

00:45:11,099 --> 00:45:15,709
all right thank you then I'm out sorry

00:45:16,609 --> 00:45:20,420
sorry can you be a little louder

00:45:25,369 --> 00:45:32,069
depends on who is owning the buffer if

00:45:28,650 --> 00:45:34,589
like typically the artist is not smart

00:45:32,069 --> 00:45:36,329
enough like it cannot reconfigure the

00:45:34,589 --> 00:45:38,759
memory address space to have a different

00:45:36,329 --> 00:45:40,709
visibility typically if you have given

00:45:38,759 --> 00:45:43,289
let's say a specific memory chunk to the

00:45:40,709 --> 00:45:45,119
artists it will only have access to that

00:45:43,289 --> 00:45:49,739
memory chunk now if you want to give a

00:45:45,119 --> 00:45:51,749
Linux memory to artists if you want to

00:45:49,739 --> 00:45:53,549
give a Linux memory to artists you need

00:45:51,749 --> 00:45:55,079
to have as new mapping created for

00:45:53,549 --> 00:45:57,680
artists processor because it will not

00:45:55,079 --> 00:46:01,529
understand any memory which is given to

00:45:57,680 --> 00:46:03,900
it while at the boot up so only there's

00:46:01,529 --> 00:46:05,880
less static mapping done by by artists

00:46:03,900 --> 00:46:07,890
because you have only limited memory

00:46:05,880 --> 00:46:10,259
access and the even the address space

00:46:07,890 --> 00:46:12,569
that is there for this artists processor

00:46:10,259 --> 00:46:16,400
is limited so you do not have access to

00:46:12,569 --> 00:46:19,469
like full 4gb memory so if you want to

00:46:16,400 --> 00:46:21,089
share Linux memory to artists memory

00:46:19,469 --> 00:46:23,339
again it has to be from a specific

00:46:21,089 --> 00:46:25,469
region you cannot randomly take any

00:46:23,339 --> 00:46:26,969
memory and say that now I want to share

00:46:25,469 --> 00:46:30,239
it with artists it has to be from a

00:46:26,969 --> 00:46:38,269
dedicated piece which is already mapped

00:46:30,239 --> 00:46:38,269
into the artists region okay

00:46:39,680 --> 00:46:45,359
so the MFF concept is only useful for

00:46:43,079 --> 00:46:47,910
linux all the Linux drivers will use the

00:46:45,359 --> 00:46:50,220
DMF if you are taking a buffer from our

00:46:47,910 --> 00:46:52,380
toes and then converting into DM above

00:46:50,220 --> 00:46:54,270
you can do all the operations using all

00:46:52,380 --> 00:46:55,680
the Linux drivers once all the

00:46:54,270 --> 00:46:57,599
operations are finished of course the

00:46:55,680 --> 00:46:59,970
physical memory remains the same and you

00:46:57,599 --> 00:47:01,079
can give it back to artis without doing

00:46:59,970 --> 00:47:05,040
anything because the physical address

00:47:01,079 --> 00:47:08,760
remains to be same its DMF is only linux

00:47:05,040 --> 00:47:11,030
means of accessing that buffer from user

00:47:08,760 --> 00:47:11,030
space

00:47:25,950 --> 00:47:32,410
so once you get the list of physical

00:47:30,640 --> 00:47:34,630
addresses you need to implement this

00:47:32,410 --> 00:47:37,030
bunch of appala ops which is called DMF

00:47:34,630 --> 00:47:38,980
of operations so there would be like map

00:47:37,030 --> 00:47:41,290
and map and all these operations so

00:47:38,980 --> 00:47:44,440
every time an importer driver tries to

00:47:41,290 --> 00:47:47,020
access the actual memory it would call

00:47:44,440 --> 00:47:49,360
attach map detach all those APs and

00:47:47,020 --> 00:47:51,280
those are they pH which needs to be

00:47:49,360 --> 00:47:53,350
implemented by the DM above exporter

00:47:51,280 --> 00:47:55,660
driver in this case this driver has

00:47:53,350 --> 00:47:58,300
implemented all those api's so that

00:47:55,660 --> 00:47:59,680
anytime an importer calls those ApS the

00:47:58,300 --> 00:48:07,530
corresponding actions are taken and

00:47:59,680 --> 00:48:07,530
that's all the MFF is all about yes

00:48:12,670 --> 00:48:18,619
currently it is being taken in such a

00:48:15,559 --> 00:48:20,750
way that it Maps for bi-directional so

00:48:18,619 --> 00:48:22,819
at any point of time application wants

00:48:20,750 --> 00:48:31,160
to read or write it will make sure that

00:48:22,819 --> 00:48:35,119
the DMA is always bi-directional yes

00:48:31,160 --> 00:48:37,609
so the typical okay the intent behind

00:48:35,119 --> 00:48:39,650
doing this use case is not to actually

00:48:37,609 --> 00:48:41,539
do any CP access in this at least

00:48:39,650 --> 00:48:44,420
specifically in this application you

00:48:41,539 --> 00:48:46,250
don't see application working with that

00:48:44,420 --> 00:48:48,529
virtual address it is just mapped and

00:48:46,250 --> 00:48:50,299
then converted into DM above but there's

00:48:48,529 --> 00:48:53,390
no CPU access happening because all of

00:48:50,299 --> 00:48:55,579
the all of the operations are actually

00:48:53,390 --> 00:48:57,829
hardware accelerated so there is like a

00:48:55,579 --> 00:48:59,930
GPU driver there is an encode driver and

00:48:57,829 --> 00:49:02,630
all of these are peripherals which will

00:48:59,930 --> 00:49:04,579
which are not part of CPU so if you just

00:49:02,630 --> 00:49:06,470
give a DM above that's it CPU does not

00:49:04,579 --> 00:49:08,029
have to access it it's just that you are

00:49:06,470 --> 00:49:10,099
creating a virtual mapping but you are

00:49:08,029 --> 00:49:13,250
not really accessing it if you do access

00:49:10,099 --> 00:49:20,180
it you will have to do the penalty of in

00:49:13,250 --> 00:49:24,079
cache penalty exactly so I mentioned

00:49:20,180 --> 00:49:25,880
about I mentioned about the ABI so there

00:49:24,079 --> 00:49:28,990
will be and I was there will be an ioctl

00:49:25,880 --> 00:49:32,690
which asks let's say an application

00:49:28,990 --> 00:49:34,760
willing willingly wants to let say flush

00:49:32,690 --> 00:49:36,950
cash on invalidate cache so you will

00:49:34,760 --> 00:49:39,680
have a specific ioctl for that so you

00:49:36,950 --> 00:49:42,020
can once you open the slash dev slash VM

00:49:39,680 --> 00:49:43,369
exp you can either export the buffer and

00:49:42,020 --> 00:49:45,079
then you can use the second type of i/o

00:49:43,369 --> 00:49:47,020
seeded where you can say that I want to

00:49:45,079 --> 00:49:49,490
sink a shower I want to invalidate cache

00:49:47,020 --> 00:49:51,650
so that's an API provided to the

00:49:49,490 --> 00:49:56,150
application in case application wants to

00:49:51,650 --> 00:49:59,770
specifically handle caches on its own in

00:49:56,150 --> 00:49:59,770
general it is considered bidirectional

00:50:00,670 --> 00:50:04,599
all right any other questions

00:50:07,490 --> 00:50:13,650
all right thank you

00:50:09,540 --> 00:50:13,650

YouTube URL: https://www.youtube.com/watch?v=LFU39w7lY08


