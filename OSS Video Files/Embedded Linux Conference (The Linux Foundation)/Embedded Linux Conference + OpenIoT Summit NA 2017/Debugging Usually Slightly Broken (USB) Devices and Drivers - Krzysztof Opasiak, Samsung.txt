Title: Debugging Usually Slightly Broken (USB) Devices and Drivers - Krzysztof Opasiak, Samsung
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Debugging Usually Slightly Broken (USB) Devices and Drivers - Krzysztof Opasiak, Samsung R&D Institute Poland

USB is definitely the most common external interface. Millions of people are using it every day and thousands of them have problems with it. Driver not found, incorrect driver bound, kernel oops are just examples of common problems which we are all facing. How to solve them or at least debug? If youâ€™d like to find out, then this talk is exactly for you!

We will start with a gentle introduction to the USB protocol itself. Then standard Linux host side infrastructure will be discussed. How drivers are chosen? How can we modify matching rules of a particular driver? That's only couple of questions which will be answered in this part. Final part will be an introduction to USB communication sniffing. Krzysztof will show how to monitor and analyze USB traffic without expensive USB analyzers.

About Krzysztof Opasiak
Krzysztof is a PhD student at Warsaw University of Technology. He works as Kernel and System Developer at Samsung R&D Institute Poland. Since 2013 involved in USB support development in Tizen OS. Maintainer of libusbgx - library for USB gadgets management through ConfigFS. Open Source enthusiast and speaker at several Linux | and Open Source Conferences.
Captions: 
	00:00:00,410 --> 00:00:08,760
okay so can everyone hear me okay cool

00:00:05,549 --> 00:00:10,530
so my name is Gustavo boishakh for some

00:00:08,760 --> 00:00:12,809
non polish speakers I think there are

00:00:10,530 --> 00:00:16,500
some Christopher Chris would be good

00:00:12,809 --> 00:00:20,939
enough I work for Samsung R&D Institute

00:00:16,500 --> 00:00:23,279
Poland I do some USB support in Tizen

00:00:20,939 --> 00:00:26,220
operating system it's based on the Linux

00:00:23,279 --> 00:00:29,670
kernel so we share the same kernel as

00:00:26,220 --> 00:00:31,380
most Linux distributions today I would

00:00:29,670 --> 00:00:34,980
like to tell you a few words about

00:00:31,380 --> 00:00:39,899
debugging let's say the compost common

00:00:34,980 --> 00:00:43,469
problems with the USB it's not going to

00:00:39,899 --> 00:00:46,260
be a very let's say advanced stock

00:00:43,469 --> 00:00:49,379
it's rather for beginners some tips and

00:00:46,260 --> 00:00:51,920
tricks what you can do to add use some

00:00:49,379 --> 00:00:56,100
common drivers to work with your

00:00:51,920 --> 00:00:58,920
specific hardware or how to where to

00:00:56,100 --> 00:01:01,680
start debugging those drivers and what

00:00:58,920 --> 00:01:03,539
are the most common mistakes so in the

00:01:01,680 --> 00:01:06,119
beginning I would like to give you some

00:01:03,539 --> 00:01:09,180
brief introduction to the USB protocol

00:01:06,119 --> 00:01:11,310
then we will talk a few words about the

00:01:09,180 --> 00:01:14,250
plug-and-play functionality how drivers

00:01:11,310 --> 00:01:16,830
are are chosen what we can do with this

00:01:14,250 --> 00:01:18,750
we will do some tips and tricks with the

00:01:16,830 --> 00:01:22,619
driver how we can modify the criminal

00:01:18,750 --> 00:01:26,310
policy what can we do to force some

00:01:22,619 --> 00:01:28,860
driver to bind to our device even if it

00:01:26,310 --> 00:01:32,790
was not designed to bind to this design

00:01:28,860 --> 00:01:35,220
to this device and how we can snip what

00:01:32,790 --> 00:01:38,070
the driver is really talking to our

00:01:35,220 --> 00:01:42,299
device how we can get this in the end

00:01:38,070 --> 00:01:45,720
some summary and the Q&A session so to

00:01:42,299 --> 00:01:49,020
clarify this presentation is generally

00:01:45,720 --> 00:01:51,840
about us be about USB devices management

00:01:49,020 --> 00:01:54,780
about sniffing the USB traffic modifying

00:01:51,840 --> 00:01:58,860
drivers policy it's not going to be a

00:01:54,780 --> 00:02:01,740
talk about the KGB or trace trace point

00:01:58,860 --> 00:02:03,540
or any other kernel debugging tanks so

00:02:01,740 --> 00:02:05,759
if you came here to listen about this

00:02:03,540 --> 00:02:07,770
now it's the time to change the room to

00:02:05,759 --> 00:02:12,239
some other presentation there also cool

00:02:07,770 --> 00:02:14,270
so okay so we are everyone here to talk

00:02:12,239 --> 00:02:18,720
about the USB

00:02:14,270 --> 00:02:21,240
so USB basics first of all to talk about

00:02:18,720 --> 00:02:25,560
the USB we have to learn a few things

00:02:21,240 --> 00:02:29,520
about it first of all what USB is really

00:02:25,560 --> 00:02:32,880
about some people say that USB is rather

00:02:29,520 --> 00:02:34,890
a network than a bus because it's about

00:02:32,880 --> 00:02:38,490
pretty the same thing as the Internet

00:02:34,890 --> 00:02:40,020
it's about providing a service of course

00:02:38,490 --> 00:02:42,480
it's a little bit different level of

00:02:40,020 --> 00:02:45,420
service because we have rather storage

00:02:42,480 --> 00:02:48,120
printing internet camera or any other

00:02:45,420 --> 00:02:52,650
services but they are all provided by

00:02:48,120 --> 00:02:54,990
USB devices so in Internet world

00:02:52,650 --> 00:02:58,920
we have a well-known architecture client

00:02:54,990 --> 00:03:00,870
server in the USB world we have our USB

00:02:58,920 --> 00:03:03,270
host which is the master on the bus

00:03:00,870 --> 00:03:05,910
which is the device which is being used

00:03:03,270 --> 00:03:09,510
by the end-user and we have our the USB

00:03:05,910 --> 00:03:13,920
devices which are which provides

00:03:09,510 --> 00:03:16,050
additional functionality to USB host so

00:03:13,920 --> 00:03:18,720
that's a little bit equivalent of the

00:03:16,050 --> 00:03:21,090
server from the internet world single

00:03:18,720 --> 00:03:24,990
USB device may provide multiple

00:03:21,090 --> 00:03:27,360
functionalities single device may be

00:03:24,990 --> 00:03:30,600
connected only to one host in the same

00:03:27,360 --> 00:03:34,740
time but single USB host may have

00:03:30,600 --> 00:03:37,050
multiple devices connected okay so let's

00:03:34,740 --> 00:03:41,970
go to some basic entities from the USB

00:03:37,050 --> 00:03:44,280
world endpoints in TCP world in or

00:03:41,970 --> 00:03:47,190
generally in the internet world we have

00:03:44,280 --> 00:03:49,140
the abstraction of ports to identify the

00:03:47,190 --> 00:03:52,140
application which we want to communicate

00:03:49,140 --> 00:03:54,360
with in the USB word we have let's say a

00:03:52,140 --> 00:03:59,100
little big bit equivalent of that ports

00:03:54,360 --> 00:04:01,350
it calls endpoints single USB device may

00:03:59,100 --> 00:04:03,870
have up to 31 endpoints including

00:04:01,350 --> 00:04:07,709
endpoint 0 which is the only one which

00:04:03,870 --> 00:04:10,890
is mandatory each end point apart from

00:04:07,709 --> 00:04:14,100
endpoint 0 may transfer data only in one

00:04:10,890 --> 00:04:18,510
direction it means that endpoint is in

00:04:14,100 --> 00:04:22,680
or out if endpoint is in it means that

00:04:18,510 --> 00:04:26,100
it may transfer the data from device to

00:04:22,680 --> 00:04:26,820
the host if endpoint is out it means

00:04:26,100 --> 00:04:29,430
that it is

00:04:26,820 --> 00:04:31,890
able to transfer the data from host to

00:04:29,430 --> 00:04:34,610
the device so we always match the

00:04:31,890 --> 00:04:37,620
direction from the host perspective

00:04:34,610 --> 00:04:39,750
endpoint zero is the only one which is

00:04:37,620 --> 00:04:43,650
mandatory it is different because it may

00:04:39,750 --> 00:04:46,200
transfer the data in both directions so

00:04:43,650 --> 00:04:49,260
in internet words generally we have to

00:04:46,200 --> 00:04:52,050
choose between TCP or between UDP

00:04:49,260 --> 00:04:55,230
depending on our requirements in the USB

00:04:52,050 --> 00:04:58,410
world we have four different types of

00:04:55,230 --> 00:05:00,810
endpoints possible first of them is the

00:04:58,410 --> 00:05:04,470
control one this is the type which is

00:05:00,810 --> 00:05:06,630
reserved for endpoint 0 so each device

00:05:04,470 --> 00:05:08,880
is able to speak using the control

00:05:06,630 --> 00:05:11,850
transfer is the only one which is be

00:05:08,880 --> 00:05:16,140
directional it is used to discover USB

00:05:11,850 --> 00:05:18,870
device capabilities the next one bulk is

00:05:16,140 --> 00:05:21,000
the most common one and it is used to

00:05:18,870 --> 00:05:23,970
transfer a large amount of non time

00:05:21,000 --> 00:05:26,850
sensitive data it means that you give a

00:05:23,970 --> 00:05:32,520
package of data and so okay send it when

00:05:26,850 --> 00:05:36,480
the bus will have time to do this next

00:05:32,520 --> 00:05:39,090
to our endpoints which are our transfer

00:05:36,480 --> 00:05:42,200
types which are called periodic because

00:05:39,090 --> 00:05:45,510
they reserved bandwidth on the bus

00:05:42,200 --> 00:05:49,250
interrupt is used to transfer a small

00:05:45,510 --> 00:05:53,520
amount of time sensitive data

00:05:49,250 --> 00:05:57,080
this one the in this one that and in all

00:05:53,520 --> 00:06:00,270
those to the delivery is guaranteed and

00:05:57,080 --> 00:06:02,340
in isochronous which is used to transfer

00:06:00,270 --> 00:06:05,300
a large amount of time sensitive data

00:06:02,340 --> 00:06:08,250
there is no guarantee of delivery

00:06:05,300 --> 00:06:12,510
so it's let's say more or less

00:06:08,250 --> 00:06:15,240
equivalent of UDP and it is used to

00:06:12,510 --> 00:06:19,910
stream audio or video through the USB

00:06:15,240 --> 00:06:23,750
bus how does endpoint fits into device

00:06:19,910 --> 00:06:27,330
endpoints are grouped into interfaces

00:06:23,750 --> 00:06:31,340
interface is a group of endpoints which

00:06:27,330 --> 00:06:35,430
are used to implement some well-defined

00:06:31,340 --> 00:06:38,040
functionality usually we place let's say

00:06:35,430 --> 00:06:40,580
to bulk endpoints to have B directional

00:06:38,040 --> 00:06:43,870
communication channel inter

00:06:40,580 --> 00:06:47,120
faces are grouped into configurations

00:06:43,870 --> 00:06:49,789
single USB single configuration may have

00:06:47,120 --> 00:06:53,000
multiple interfaces and all of them are

00:06:49,789 --> 00:06:55,430
available in the same time single USB

00:06:53,000 --> 00:06:58,370
device may have multiple configurations

00:06:55,430 --> 00:06:59,379
but only one of them may be active in

00:06:58,370 --> 00:07:03,469
the same time

00:06:59,379 --> 00:07:06,129
all interfaces from configuration may be

00:07:03,469 --> 00:07:09,110
used only if configuration is active

00:07:06,129 --> 00:07:12,259
endpoint 0 is the only one which is not

00:07:09,110 --> 00:07:17,030
grouped into any interface it's always

00:07:12,259 --> 00:07:19,759
available how do we discover the

00:07:17,030 --> 00:07:22,370
capabilities of our device we do this

00:07:19,759 --> 00:07:25,669
using the data structures called USB

00:07:22,370 --> 00:07:28,520
descriptors what are the most important

00:07:25,669 --> 00:07:31,699
descriptors first of all the device

00:07:28,520 --> 00:07:34,639
descriptor the most important fields for

00:07:31,699 --> 00:07:37,310
us from the perspective of choosing a

00:07:34,639 --> 00:07:40,340
driver are the vendor information and

00:07:37,310 --> 00:07:42,439
class information ID vendor is a number

00:07:40,340 --> 00:07:44,449
which you can get from the USB or of

00:07:42,439 --> 00:07:48,740
course you have to pay for it it's not

00:07:44,449 --> 00:07:51,440
free when you get your ID vendor you get

00:07:48,740 --> 00:07:54,310
the whole pool of ID products so you may

00:07:51,440 --> 00:07:56,300
release your products with particular

00:07:54,310 --> 00:07:58,430
identification you may use this to

00:07:56,300 --> 00:08:02,629
choose a driver which is specific for

00:07:58,430 --> 00:08:05,509
your device model but of course this is

00:08:02,629 --> 00:08:09,199
not the exact model of the device it

00:08:05,509 --> 00:08:11,870
identifies the model from the USB point

00:08:09,199 --> 00:08:14,389
of view for example if you connect your

00:08:11,870 --> 00:08:16,849
samsung phone to the computer usually

00:08:14,389 --> 00:08:20,719
you will get that this is the let's say

00:08:16,849 --> 00:08:23,240
galaxy s2 because all galaxies from s 2

00:08:20,719 --> 00:08:26,120
to s 7 are backward compatible from the

00:08:23,240 --> 00:08:28,779
USB point of view so there is no reason

00:08:26,120 --> 00:08:31,669
to update the ID vendor because your

00:08:28,779 --> 00:08:35,260
your operating system is used to that

00:08:31,669 --> 00:08:37,640
idea vendor and knows how to handle it

00:08:35,260 --> 00:08:40,010
class information the same class

00:08:37,640 --> 00:08:44,180
information this triple is repeated in

00:08:40,010 --> 00:08:46,699
interface because single USB device may

00:08:44,180 --> 00:08:48,800
provide multiple functionalities those

00:08:46,699 --> 00:08:52,220
functionalities may be totally unrelated

00:08:48,800 --> 00:08:54,500
so that's why on the u.s. in device

00:08:52,220 --> 00:08:56,810
descriptor we can say ok

00:08:54,500 --> 00:08:59,570
use the information for each interface

00:08:56,810 --> 00:09:02,630
from the interface descriptor what kind

00:08:59,570 --> 00:09:04,370
of classes we have generally all the

00:09:02,630 --> 00:09:09,470
stuff which is well known mass storage

00:09:04,370 --> 00:09:11,690
pendrive audio class application

00:09:09,470 --> 00:09:15,200
specific and vendor specific that are

00:09:11,690 --> 00:09:17,720
wrong which are used when you do Arduino

00:09:15,200 --> 00:09:21,860
or some other stuff which when you

00:09:17,720 --> 00:09:23,630
develop your own USB functions human

00:09:21,860 --> 00:09:30,890
interface of course the mouse keyboard

00:09:23,630 --> 00:09:33,440
etc okay then we have three strings the

00:09:30,890 --> 00:09:36,320
string which identifies the manufacturer

00:09:33,440 --> 00:09:38,240
product the serial number of course the

00:09:36,320 --> 00:09:40,880
serial any of these strings is not

00:09:38,240 --> 00:09:42,770
mandatory you can place whatever you

00:09:40,880 --> 00:09:45,290
want and watch out for the serials

00:09:42,770 --> 00:09:48,290
because especially for cheap devices

00:09:45,290 --> 00:09:51,430
they like to be almost the same like one

00:09:48,290 --> 00:09:53,930
two three four five because yes of

00:09:51,430 --> 00:09:57,440
course the information about number of

00:09:53,930 --> 00:09:59,390
available configurations in inter in

00:09:57,440 --> 00:10:01,940
configurations we have information about

00:09:59,390 --> 00:10:03,620
how many power the device needs to

00:10:01,940 --> 00:10:05,780
derive from the host to use this

00:10:03,620 --> 00:10:09,950
configuration and the number of

00:10:05,780 --> 00:10:12,730
interfaces then we have our interfaces

00:10:09,950 --> 00:10:14,870
with the class information the string

00:10:12,730 --> 00:10:17,420
describing the interface functionality

00:10:14,870 --> 00:10:19,790
and of course the endpoint descriptor

00:10:17,420 --> 00:10:22,700
which defines the endpoint address and

00:10:19,790 --> 00:10:25,040
defines the type of design point is it

00:10:22,700 --> 00:10:27,800
bulk is it block interrupt

00:10:25,040 --> 00:10:31,030
aisel and of course the maximum packet

00:10:27,800 --> 00:10:34,610
size which can be sent to this end point

00:10:31,030 --> 00:10:37,010
plug-and-play this is one of the

00:10:34,610 --> 00:10:39,320
functionalities user liked the most in

00:10:37,010 --> 00:10:41,890
USB because you may simply connect your

00:10:39,320 --> 00:10:46,640
device and it's working out of the box

00:10:41,890 --> 00:10:48,560
so how does it happen first of all we

00:10:46,640 --> 00:10:50,330
need to plug in the device that's the

00:10:48,560 --> 00:10:53,120
mandatory step without this it's not

00:10:50,330 --> 00:10:55,910
going to work then your host needs to

00:10:53,120 --> 00:10:58,430
detect the connection set address

00:10:55,910 --> 00:11:01,250
because each device on a USB bus has a

00:10:58,430 --> 00:11:05,300
unique address assigned by the host in

00:11:01,250 --> 00:11:07,160
the beginning of the communication then

00:11:05,300 --> 00:11:08,270
you need to get information about the

00:11:07,160 --> 00:11:12,290
device it means get

00:11:08,270 --> 00:11:15,680
the descriptors choose a configuration

00:11:12,290 --> 00:11:20,390
and then choose drivers for interfaces

00:11:15,680 --> 00:11:23,390
yes generally Linux choose chooses

00:11:20,390 --> 00:11:26,480
drivers for interfaces not for the

00:11:23,390 --> 00:11:28,790
device as a whole each interface may

00:11:26,480 --> 00:11:30,560
provide different functionality so we

00:11:28,790 --> 00:11:36,170
need a different driver to provide this

00:11:30,560 --> 00:11:41,020
functionality to the user space wallet

00:11:36,170 --> 00:11:45,200
addresses starts from 1 and ends at 128

00:11:41,020 --> 00:11:47,240
other as 0 is reserved for the new USB

00:11:45,200 --> 00:11:50,410
device which arrives to the system and

00:11:47,240 --> 00:11:54,410
has not before we set the address is

00:11:50,410 --> 00:11:58,490
used to communicate this usually is just

00:11:54,410 --> 00:12:01,640
simply the next available address and

00:11:58,490 --> 00:12:03,649
nothing more device details it means

00:12:01,640 --> 00:12:06,830
that the scripters or that information

00:12:03,649 --> 00:12:11,200
will be later available to you via SMS

00:12:06,830 --> 00:12:14,300
and which configuration we should choose

00:12:11,200 --> 00:12:17,300
first of all if the device has one

00:12:14,300 --> 00:12:20,180
configuration there is no problem if the

00:12:17,300 --> 00:12:22,760
device has multiple configuration we

00:12:20,180 --> 00:12:25,850
choose the first one which first

00:12:22,760 --> 00:12:29,270
interface class is different than vendor

00:12:25,850 --> 00:12:33,020
specific the comment in Linux kernel

00:12:29,270 --> 00:12:37,940
says that Linux is not the most popular

00:12:33,020 --> 00:12:41,270
operating system yet so we are more

00:12:37,940 --> 00:12:44,060
likely to have a driver for some

00:12:41,270 --> 00:12:47,390
well-known standardized communication

00:12:44,060 --> 00:12:51,820
protocol done for some vendor specific

00:12:47,390 --> 00:12:54,920
protocol so that's why we by default

00:12:51,820 --> 00:12:57,560
choose a configuration which provides

00:12:54,920 --> 00:12:59,720
well-known standardized functionality

00:12:57,560 --> 00:13:02,390
which belongs to some class like human

00:12:59,720 --> 00:13:06,529
interface or mass storage or that kind

00:13:02,390 --> 00:13:08,390
of stuff when configuration is chosen

00:13:06,529 --> 00:13:12,079
all interfaces from that configuration

00:13:08,390 --> 00:13:14,300
becomes available to our system so now

00:13:12,079 --> 00:13:17,709
we have to choose a driver for each

00:13:14,300 --> 00:13:20,680
interface but would this driver release

00:13:17,709 --> 00:13:22,100
first of all is a piece of current code

00:13:20,680 --> 00:13:26,240
describe you

00:13:22,100 --> 00:13:29,209
extract USB driver it usually provides

00:13:26,240 --> 00:13:31,459
something to the user space because user

00:13:29,209 --> 00:13:34,759
connected some device to use it

00:13:31,459 --> 00:13:37,430
functionality we connect our pendrive to

00:13:34,759 --> 00:13:39,319
use the flash memory which is on it so

00:13:37,430 --> 00:13:42,259
that's why we have to provide something

00:13:39,319 --> 00:13:42,949
to the user space something means blog

00:13:42,259 --> 00:13:45,470
device

00:13:42,949 --> 00:13:47,899
something's mean network interface all

00:13:45,470 --> 00:13:51,220
that kind of stuff which can be used in

00:13:47,899 --> 00:13:54,110
the standard way by our operating system

00:13:51,220 --> 00:13:56,240
the driver itself is really an

00:13:54,110 --> 00:13:59,690
implementation of some communication

00:13:56,240 --> 00:14:03,440
protocol because what driver really does

00:13:59,690 --> 00:14:06,110
is just the generic calls from

00:14:03,440 --> 00:14:10,069
the user space like send me this packet

00:14:06,110 --> 00:14:12,769
to that network address it parks it and

00:14:10,069 --> 00:14:18,410
send it via the USB bus to the USB

00:14:12,769 --> 00:14:21,620
device that's nothing more how we choose

00:14:18,410 --> 00:14:24,350
our driver we're in a standard Linux way

00:14:21,620 --> 00:14:27,079
it means that kernel maintains a list of

00:14:24,350 --> 00:14:30,050
registered drivers and each drivers

00:14:27,079 --> 00:14:33,230
declares a list of compatible device

00:14:30,050 --> 00:14:36,019
identities then caralyn goes through the

00:14:33,230 --> 00:14:39,230
list and it find a match calls a probe

00:14:36,019 --> 00:14:44,149
function what does it mean that driver

00:14:39,230 --> 00:14:48,170
declares a list of known device IDs well

00:14:44,149 --> 00:14:51,410
we have destruct USB device ID and here

00:14:48,170 --> 00:14:54,259
are all all fields which can be used for

00:14:51,410 --> 00:14:58,329
matching with the device identity those

00:14:54,259 --> 00:15:00,439
values are similar to those from the USB

00:14:58,329 --> 00:15:02,870
descriptors from the USB device

00:15:00,439 --> 00:15:06,050
descriptor for example the ID vendor and

00:15:02,870 --> 00:15:08,959
ID product and the one field which is

00:15:06,050 --> 00:15:11,959
here the mass flux it is used to define

00:15:08,959 --> 00:15:14,540
which of fields from the structures

00:15:11,959 --> 00:15:17,410
contain valid data and should be used to

00:15:14,540 --> 00:15:23,180
match against there is also additional

00:15:17,410 --> 00:15:25,339
field which is used to declare what kind

00:15:23,180 --> 00:15:28,310
of query should be used for this

00:15:25,339 --> 00:15:30,860
particular device model it means that

00:15:28,310 --> 00:15:34,510
some device we have generally we have a

00:15:30,860 --> 00:15:35,680
generic drivers but some models of

00:15:34,510 --> 00:15:39,830
device

00:15:35,680 --> 00:15:42,020
require some special handling so drivers

00:15:39,830 --> 00:15:44,330
place this information about require

00:15:42,020 --> 00:15:46,880
special handling in this field and

00:15:44,330 --> 00:15:49,300
that's why they can use the same driver

00:15:46,880 --> 00:15:52,520
it might be used for let's say multiple

00:15:49,300 --> 00:15:56,390
quite similar but not really the same

00:15:52,520 --> 00:16:00,140
devices how does it look on a big

00:15:56,390 --> 00:16:02,930
picture we have our USB device the host

00:16:00,140 --> 00:16:05,600
controller driver for this cost

00:16:02,930 --> 00:16:07,910
controller structure which represents

00:16:05,600 --> 00:16:10,700
the USB device as a whole and the

00:16:07,910 --> 00:16:14,480
generic driver which simply creates our

00:16:10,700 --> 00:16:17,650
interfaces we have interfaces USB

00:16:14,480 --> 00:16:20,300
drivers bound to those interfaces and

00:16:17,650 --> 00:16:23,810
something provided to the user space

00:16:20,300 --> 00:16:26,870
which can be used by our generic user

00:16:23,810 --> 00:16:31,520
space entities like X 11 or our web

00:16:26,870 --> 00:16:34,670
browser if it's networking interface so

00:16:31,520 --> 00:16:37,340
everything happens automatically it's

00:16:34,670 --> 00:16:40,790
good general it's good because it's

00:16:37,340 --> 00:16:44,120
exactly what users like but what if we

00:16:40,790 --> 00:16:49,750
need to modify somehow some parts of

00:16:44,120 --> 00:16:52,210
this policy first of all now USB is

00:16:49,750 --> 00:16:55,190
being a security threat

00:16:52,210 --> 00:16:57,050
it means that there is a lot of attacks

00:16:55,190 --> 00:16:59,690
which does for example the host

00:16:57,050 --> 00:17:03,760
fingerprinting and check which drivers

00:16:59,690 --> 00:17:06,130
are available and then find the

00:17:03,760 --> 00:17:09,620
vulnerabilities and try to exploit them

00:17:06,130 --> 00:17:11,420
there is a bad USB attack which simply

00:17:09,620 --> 00:17:14,300
introduced your pendrive as a keyboard

00:17:11,420 --> 00:17:17,209
and try to execute some code so

00:17:14,300 --> 00:17:20,360
generally in secure systems we would

00:17:17,209 --> 00:17:24,650
like to limit the number of allowed USB

00:17:20,360 --> 00:17:27,890
devices or maybe limit the number to the

00:17:24,650 --> 00:17:32,780
list of functionalities so we would like

00:17:27,890 --> 00:17:34,580
to use only particular interfaces what

00:17:32,780 --> 00:17:37,670
can we do if we run configuration has

00:17:34,580 --> 00:17:41,480
been chosen our color kernel choose the

00:17:37,670 --> 00:17:43,460
configuration which has which class of

00:17:41,480 --> 00:17:45,560
the first interface is not vendor

00:17:43,460 --> 00:17:48,980
specific and what if you would like to

00:17:45,560 --> 00:17:49,460
change it what we can do if driver has

00:17:48,980 --> 00:17:52,130
not been

00:17:49,460 --> 00:17:55,840
found or wrong driver has been bounced

00:17:52,130 --> 00:17:58,490
to our USB device first of all all

00:17:55,840 --> 00:18:01,970
information about connected USB devices

00:17:58,490 --> 00:18:05,090
is available via CFS we go to sis bus

00:18:01,970 --> 00:18:08,659
USB devices and what can we find there

00:18:05,090 --> 00:18:11,090
we have three types of catalogs first of

00:18:08,659 --> 00:18:11,510
them it's called USB and some number

00:18:11,090 --> 00:18:13,909
here

00:18:11,510 --> 00:18:16,820
does the directory which corresponds to

00:18:13,909 --> 00:18:20,750
the host controller which is built-in in

00:18:16,820 --> 00:18:23,990
our machine the second type is the USB

00:18:20,750 --> 00:18:27,679
device how does the direction how those

00:18:23,990 --> 00:18:30,110
names are created X is the number of

00:18:27,679 --> 00:18:33,289
host controller to which this device is

00:18:30,110 --> 00:18:36,289
attached then we got the physical path

00:18:33,289 --> 00:18:36,980
to the port to which USB device is

00:18:36,289 --> 00:18:41,200
connected

00:18:36,980 --> 00:18:46,480
for example this printer is connected to

00:18:41,200 --> 00:18:51,140
third part of route hub second part of

00:18:46,480 --> 00:18:53,659
next hub and the third part of the last

00:18:51,140 --> 00:19:01,070
hub it means that its directory name

00:18:53,659 --> 00:19:03,110
would be three to three simple then

00:19:01,070 --> 00:19:06,770
we've got directories which corresponds

00:19:03,110 --> 00:19:09,710
to the interfaces it's the it starts

00:19:06,770 --> 00:19:11,899
with the USB device identified entity

00:19:09,710 --> 00:19:14,360
and then we've got the configuration

00:19:11,899 --> 00:19:18,110
number and the index of the interface

00:19:14,360 --> 00:19:20,830
inside this configuration how can we

00:19:18,110 --> 00:19:23,779
limit the number of allowed USB devices

00:19:20,830 --> 00:19:27,110
we can use the kernel feature which is

00:19:23,779 --> 00:19:31,130
called the USB device authorization what

00:19:27,110 --> 00:19:33,140
does it mean each host cons each USB

00:19:31,130 --> 00:19:36,230
device has an authorized attribute if

00:19:33,140 --> 00:19:39,080
this attribute is set to 0 then

00:19:36,230 --> 00:19:42,919
configuration for this device is not

00:19:39,080 --> 00:19:45,980
being chosen it means that this device

00:19:42,919 --> 00:19:50,299
is relatively unusable until we

00:19:45,980 --> 00:19:52,610
authorize it each host controller has an

00:19:50,299 --> 00:19:55,130
authorized default attribute which is

00:19:52,610 --> 00:19:57,649
the default value for the authorized

00:19:55,130 --> 00:20:01,130
attribute for each new device which

00:19:57,649 --> 00:20:02,780
arrives to the system so this gives us

00:20:01,130 --> 00:20:05,630
time to

00:20:02,780 --> 00:20:08,000
execute for example LS USB and check

00:20:05,630 --> 00:20:10,610
what we have really connected and based

00:20:08,000 --> 00:20:12,920
on that information we can decide if you

00:20:10,610 --> 00:20:16,280
like if we really want to use this

00:20:12,920 --> 00:20:18,530
device or not all that stuff can be

00:20:16,280 --> 00:20:21,710
automated using the USB guard project

00:20:18,530 --> 00:20:24,140
which is the security project which aims

00:20:21,710 --> 00:20:28,760
at providing filtering for the USB

00:20:24,140 --> 00:20:32,180
devices what if you would like to let's

00:20:28,760 --> 00:20:35,930
say improve this and allow only

00:20:32,180 --> 00:20:39,020
particular types of communication for

00:20:35,930 --> 00:20:42,410
example we want to allow only pen drives

00:20:39,020 --> 00:20:45,100
but we would like to use this for

00:20:42,410 --> 00:20:48,320
multiple USB devices

00:20:45,100 --> 00:20:51,140
what if our device provides together a

00:20:48,320 --> 00:20:53,030
pen drive and keyboard functionality but

00:20:51,140 --> 00:20:55,490
we would like to use only the pen drive

00:20:53,030 --> 00:21:00,110
functionality then we can use the

00:20:55,490 --> 00:21:03,680
interface authorization pretty the same

00:21:00,110 --> 00:21:07,040
as for USB device but there are some

00:21:03,680 --> 00:21:09,650
difference first of all when you use the

00:21:07,040 --> 00:21:13,430
interface authorization configuration

00:21:09,650 --> 00:21:16,250
for your USB device is chosen it means

00:21:13,430 --> 00:21:19,490
that in device here are he you will see

00:21:16,250 --> 00:21:23,000
also the USB interfaces but those

00:21:19,490 --> 00:21:25,010
interfaces are not available for drivers

00:21:23,000 --> 00:21:27,500
or not available for user space

00:21:25,010 --> 00:21:29,870
application to communicate using the

00:21:27,500 --> 00:21:32,060
Aleppo USB they are simply filtered

00:21:29,870 --> 00:21:35,030
kernel checks if the interface is

00:21:32,060 --> 00:21:37,580
authorized or not if you decide to

00:21:35,030 --> 00:21:40,700
authorize the interface there is no

00:21:37,580 --> 00:21:44,300
automatic driving Driver probing like it

00:21:40,700 --> 00:21:46,280
was in device authorization case it

00:21:44,300 --> 00:21:54,320
means that you have to manually trigger

00:21:46,280 --> 00:21:56,810
probing of driver for interfaces what we

00:21:54,320 --> 00:21:59,270
can do if configuration which is chosen

00:21:56,810 --> 00:22:01,970
by kernel it's not the most suitable for

00:21:59,270 --> 00:22:05,630
us when we can well we can simply just

00:22:01,970 --> 00:22:08,420
go to this FS and change it no

00:22:05,630 --> 00:22:13,310
philosophy it's single right to this

00:22:08,420 --> 00:22:16,580
attribute so now let's go to some stuff

00:22:13,310 --> 00:22:19,130
related to the drivers we have some

00:22:16,580 --> 00:22:22,970
of drivers for example on some vendor

00:22:19,130 --> 00:22:25,610
Colonel on our board and then some new

00:22:22,970 --> 00:22:28,370
device appears on the market it is

00:22:25,610 --> 00:22:31,640
backward compatible with some old driver

00:22:28,370 --> 00:22:35,179
but this old driver doesn't have a

00:22:31,640 --> 00:22:37,700
suitable entry in device ID table it

00:22:35,179 --> 00:22:39,890
means that it didn't declare that it is

00:22:37,700 --> 00:22:42,409
compatible with this device because the

00:22:39,890 --> 00:22:46,580
driver is older than the device on the

00:22:42,409 --> 00:22:48,470
market generally we can recompile the

00:22:46,580 --> 00:22:50,149
kernel and simply add this to the code

00:22:48,470 --> 00:22:53,510
and that's the way we should go

00:22:50,149 --> 00:22:56,690
but sometimes we may not have the source

00:22:53,510 --> 00:22:59,360
code or the config file all that kind of

00:22:56,690 --> 00:23:02,269
problems or we just simply want to make

00:22:59,360 --> 00:23:06,350
it work now without recompiling the

00:23:02,269 --> 00:23:09,860
kernel and uploading it so we may add

00:23:06,350 --> 00:23:10,580
some vendor ID and Product ID power to

00:23:09,860 --> 00:23:14,690
the driver

00:23:10,580 --> 00:23:18,080
using the Sisyphus infrastructure what

00:23:14,690 --> 00:23:22,159
is what we can really do we can add a

00:23:18,080 --> 00:23:24,529
simple vendor ID and Product ID per we

00:23:22,159 --> 00:23:28,490
can add vendor ID product ID and the

00:23:24,529 --> 00:23:32,059
interface class or we can add vendor ID

00:23:28,490 --> 00:23:34,309
product ID interface class and the

00:23:32,059 --> 00:23:36,769
device information you remember the

00:23:34,309 --> 00:23:39,700
field from the device ID table I told

00:23:36,769 --> 00:23:44,059
you which is used to store some quirks

00:23:39,700 --> 00:23:46,940
for the devices this is exactly the data

00:23:44,059 --> 00:23:50,990
format which can be used to reference

00:23:46,940 --> 00:23:53,360
the quirks from another device those two

00:23:50,990 --> 00:23:56,600
fields are used to go through the device

00:23:53,360 --> 00:24:03,440
table in the driver and copy the value

00:23:56,600 --> 00:24:06,320
of the quirks to this entry remember

00:24:03,440 --> 00:24:10,250
that all numbers here are interpreted as

00:24:06,320 --> 00:24:12,860
hex it means that when you execute the

00:24:10,250 --> 00:24:15,909
ls USB you will get the interface class

00:24:12,860 --> 00:24:19,130
which is vendor specific for example 255

00:24:15,909 --> 00:24:22,190
but if you will try to write the

00:24:19,130 --> 00:24:24,049
interface class 255 it will simply get

00:24:22,190 --> 00:24:30,760
an error you should use the hex format

00:24:24,049 --> 00:24:34,480
and simply write FF we add new device ID

00:24:30,760 --> 00:24:38,080
in the driver driver directory we simply

00:24:34,480 --> 00:24:40,630
write the new ID file to show the list

00:24:38,080 --> 00:24:43,510
who may simply just cut this file and

00:24:40,630 --> 00:24:47,730
remove the previous entry using the

00:24:43,510 --> 00:24:50,559
remove ID file if you would like to

00:24:47,730 --> 00:24:53,830
check which driver is bound to our

00:24:50,559 --> 00:24:56,200
device we might just go to the device

00:24:53,830 --> 00:24:58,480
directory and check the driver symbolic

00:24:56,200 --> 00:25:00,809
link if you would like to unbind the

00:24:58,480 --> 00:25:04,179
driver we just simply write the

00:25:00,809 --> 00:25:07,059
interface directory name to the unbind

00:25:04,179 --> 00:25:10,990
file in the drivers in the driver

00:25:07,059 --> 00:25:15,640
directory or to bind a driver we simply

00:25:10,990 --> 00:25:19,450
write here is an error it should be bind

00:25:15,640 --> 00:25:22,620
not unbind of course we simply write the

00:25:19,450 --> 00:25:27,870
interface directory name to the into the

00:25:22,620 --> 00:25:31,750
bind file okay so let's try to do this

00:25:27,870 --> 00:25:33,760
what I have here is the droid board it's

00:25:31,750 --> 00:25:37,990
let's say a little bit equivalent of

00:25:33,760 --> 00:25:41,559
galaxy s3 it has the USB chip from the

00:25:37,990 --> 00:25:50,140
synopsis I'm running there

00:25:41,559 --> 00:25:51,790
Tyson I don't serial console okay so

00:25:50,140 --> 00:25:55,390
this is the serial console from my

00:25:51,790 --> 00:25:58,990
adroit board I will use now config FS

00:25:55,390 --> 00:26:02,700
lip USB G and gadget to to construct

00:25:58,990 --> 00:26:02,700
some USB device on this

00:26:11,940 --> 00:26:19,830
okay I have just created the USB device

00:26:14,980 --> 00:26:19,830
and now I will connect it to my system

00:26:24,900 --> 00:26:30,250
okay first of all what we should do is

00:26:28,000 --> 00:26:34,870
to check the domestic for the details

00:26:30,250 --> 00:26:37,030
about our device and we have the

00:26:34,870 --> 00:26:40,809
information that new device has been

00:26:37,030 --> 00:26:43,840
found the vendor ID Product ID strings

00:26:40,809 --> 00:26:47,260
and here we have information that some

00:26:43,840 --> 00:26:51,850
driver has been bound to interfaces from

00:26:47,260 --> 00:26:55,780
that device what we can do now is to use

00:26:51,850 --> 00:27:01,140
LS USB to check what we have really

00:26:55,780 --> 00:27:01,140
connected and this is the device

00:27:08,590 --> 00:27:14,630
okay what we got here first of all is

00:27:12,770 --> 00:27:17,360
the data from the device descriptor

00:27:14,630 --> 00:27:20,150
together with strings then we have

00:27:17,360 --> 00:27:22,120
information about configurations we see

00:27:20,150 --> 00:27:25,490
that this device has two configurations

00:27:22,120 --> 00:27:30,110
first of them contains the ethernet

00:27:25,490 --> 00:27:32,660
function and the second one contains the

00:27:30,110 --> 00:27:35,870
vendor specific interface but I know

00:27:32,660 --> 00:27:38,450
that this interface is simply a generic

00:27:35,870 --> 00:27:41,600
cereal function so it provides a serial

00:27:38,450 --> 00:27:44,240
port for now what is available in my

00:27:41,600 --> 00:27:52,450
system is network interface if I do if

00:27:44,240 --> 00:27:56,299
config - a I've got the USB 0 interface

00:27:52,450 --> 00:28:01,340
we saw in our damage that this USB

00:27:56,299 --> 00:28:04,940
device is connected to port 3-2 so now

00:28:01,340 --> 00:28:12,200
let's go to the sisyphus we I am insist

00:28:04,940 --> 00:28:15,110
bus USB devices and go to 3-2 okay this

00:28:12,200 --> 00:28:17,630
is my device what I would like to do now

00:28:15,110 --> 00:28:25,000
is to show you for example the interface

00:28:17,630 --> 00:28:33,730
authorization I will write 0 2 USB 3

00:28:25,000 --> 00:28:33,730
interface authorized default oops

00:28:37,059 --> 00:28:39,749
cool

00:28:42,920 --> 00:28:48,890
of course zero it means that each new

00:28:46,130 --> 00:28:54,200
interface which will appear on this bus

00:28:48,890 --> 00:29:03,460
will be unauthorized by default so if I

00:28:54,200 --> 00:29:06,460
now go to the device directory and do a

00:29:03,460 --> 00:29:06,460
co2

00:29:10,680 --> 00:29:17,250
we configuration value then the network

00:29:14,700 --> 00:29:19,290
interface disappeared because I changed

00:29:17,250 --> 00:29:27,840
the configuration to the second one in

00:29:19,290 --> 00:29:32,280
which the serial is available and if I

00:29:27,840 --> 00:29:35,160
change back to the first configuration

00:29:32,280 --> 00:29:39,860
in which the network interface should be

00:29:35,160 --> 00:29:49,620
available it won't be available still

00:29:39,860 --> 00:29:53,850
because all interfaces for example this

00:29:49,620 --> 00:29:58,430
one is not authorized to authorize this

00:29:53,850 --> 00:29:58,430
interface I have to simply write one

00:30:04,530 --> 00:30:09,730
to authorize because this function use

00:30:07,270 --> 00:30:13,780
two interfaces I have to do this also

00:30:09,730 --> 00:30:16,990
for the second one and then I have to

00:30:13,780 --> 00:30:17,830
trigger the driver probing for that

00:30:16,990 --> 00:30:21,700
interface

00:30:17,830 --> 00:30:28,380
it means writing eco and the directory

00:30:21,700 --> 00:30:28,380
name 3-2 : 1.0 2

00:30:37,600 --> 00:30:43,179
- and of course because this is

00:30:47,360 --> 00:30:55,929
and once the error nope

00:30:58,210 --> 00:31:01,210
Iko

00:31:13,380 --> 00:31:24,600
now it's fine and if I do if config I

00:31:17,690 --> 00:31:27,179
have the USB interface once again we can

00:31:24,600 --> 00:31:32,580
do also the modification of driver

00:31:27,179 --> 00:31:34,650
probing policy so we just go to let's

00:31:32,580 --> 00:31:37,890
say I told you that I have the serial

00:31:34,650 --> 00:31:39,960
function and for now this serial

00:31:37,890 --> 00:31:43,350
function is not usable because the

00:31:39,960 --> 00:31:46,860
generic cerasale driver doesn't bind to

00:31:43,350 --> 00:31:52,070
my vendor ID and Product ID / so I may

00:31:46,860 --> 00:32:04,309
go to cell function serial driver

00:31:52,070 --> 00:32:04,309
generic drivers generic eco

00:32:15,730 --> 00:32:23,480
4ff which is the interface class this is

00:32:20,570 --> 00:32:26,240
the bender ID and Product ID of my USB

00:32:23,480 --> 00:32:30,620
device as you saw from the LS USB output

00:32:26,240 --> 00:32:35,660
and then I simply may do this to new ID

00:32:30,620 --> 00:32:36,080
and now if I go back here and do echo of

00:32:35,660 --> 00:32:38,180
course

00:32:36,080 --> 00:32:40,880
let's turn turn of the interface

00:32:38,180 --> 00:32:44,950
authorization so it means that each new

00:32:40,880 --> 00:32:44,950
interface will be authorized by default

00:32:46,930 --> 00:32:53,330
and we now have to switch the

00:32:51,410 --> 00:32:55,310
configuration to the second one because

00:32:53,330 --> 00:32:58,000
serial function is available in second

00:32:55,310 --> 00:32:58,000
configuration

00:33:08,720 --> 00:33:17,570
and let's check our D message and we've

00:33:13,970 --> 00:33:20,180
got new serial port new TTI available in

00:33:17,570 --> 00:33:24,730
our system which means that generic cell

00:33:20,180 --> 00:33:28,820
driver has now bound to this interface

00:33:24,730 --> 00:33:32,390
okay so we know how to force a driver to

00:33:28,820 --> 00:33:33,680
bind to our USB device but what if

00:33:32,390 --> 00:33:37,930
something gets wrong

00:33:33,680 --> 00:33:40,940
what if our drivers start behaving

00:33:37,930 --> 00:33:44,630
unexpectedly probably we would like to

00:33:40,940 --> 00:33:48,820
debug it but it's pretty hard to debug a

00:33:44,630 --> 00:33:53,810
code if we don't know what happened our

00:33:48,820 --> 00:33:56,960
problem so that's why it's really useful

00:33:53,810 --> 00:34:00,110
to know what kind of data device is

00:33:56,960 --> 00:34:05,270
sending to our driver that it gets into

00:34:00,110 --> 00:34:10,160
the trouble so first of all let's start

00:34:05,270 --> 00:34:13,820
with a little bit of theory USB bus is a

00:34:10,160 --> 00:34:16,550
host control bus it means that nothing

00:34:13,820 --> 00:34:19,880
on this bus can happened without hosts

00:34:16,550 --> 00:34:23,720
first initiating it so if our driver

00:34:19,880 --> 00:34:28,220
will not ask for data it will not get

00:34:23,720 --> 00:34:31,190
them the same with the control transfers

00:34:28,220 --> 00:34:34,100
and all kinds of transfer if hosts don't

00:34:31,190 --> 00:34:41,950
doesn't ask for data device is unable to

00:34:34,100 --> 00:34:45,520
send it on very low-level USB transport

00:34:41,950 --> 00:34:49,490
the transfer is divided into transaction

00:34:45,520 --> 00:34:53,150
transaction means the livery of single

00:34:49,490 --> 00:34:57,160
packet which is sized up to max packet

00:34:53,150 --> 00:35:00,850
size declared in an endpoint descriptor

00:34:57,160 --> 00:35:03,860
transfer is set of consecutive

00:35:00,850 --> 00:35:06,830
transactions from which all of them are

00:35:03,860 --> 00:35:09,800
maximum size and the last one may be the

00:35:06,830 --> 00:35:15,050
short one shorter than available data

00:35:09,800 --> 00:35:19,460
and the level on which our drivers

00:35:15,050 --> 00:35:22,460
operate is the transfer which means it

00:35:19,460 --> 00:35:25,369
means a bound of bound of data which

00:35:22,460 --> 00:35:28,730
is sent from host to the device the

00:35:25,369 --> 00:35:31,730
level of transaction is a level of we on

00:35:28,730 --> 00:35:34,400
which USB host controller driver

00:35:31,730 --> 00:35:38,420
operates or the USB device driver

00:35:34,400 --> 00:35:43,720
operate so it's a let's say it's very

00:35:38,420 --> 00:35:47,140
low lower lower level the base

00:35:43,720 --> 00:35:52,550
abstraction in Linux kernel for the USB

00:35:47,140 --> 00:35:56,000
transfer is the USB request block kernel

00:35:52,550 --> 00:35:58,580
provides the definition of structure

00:35:56,000 --> 00:36:01,640
which is a kind of envelope for our data

00:35:58,580 --> 00:36:04,970
which is sent by the driver to through

00:36:01,640 --> 00:36:07,490
the USB bus first of all we have a

00:36:04,970 --> 00:36:11,330
pointer to the device we have the pipe

00:36:07,490 --> 00:36:14,950
field which is encoded of the endpoint

00:36:11,330 --> 00:36:18,670
number so the destination of our data

00:36:14,950 --> 00:36:21,320
status field which describes if this

00:36:18,670 --> 00:36:23,240
bunch of data has been successfully

00:36:21,320 --> 00:36:26,619
delivered or there were some problems

00:36:23,240 --> 00:36:28,970
and the transfer did not finished

00:36:26,619 --> 00:36:32,480
transfer flags which can be used to

00:36:28,970 --> 00:36:35,630
modify some transfer behaviors the

00:36:32,480 --> 00:36:38,599
buffer so the data which we would like

00:36:35,630 --> 00:36:41,270
to send over the USB bus length of the

00:36:38,599 --> 00:36:44,210
data and the actual length which means

00:36:41,270 --> 00:36:48,980
how many data has been sent before for

00:36:44,210 --> 00:36:50,930
example ever occurred if we are using

00:36:48,980 --> 00:36:52,970
the control transfer we have to

00:36:50,930 --> 00:36:56,180
additionally provide a set up packet

00:36:52,970 --> 00:36:58,460
it's a predefined structure which simply

00:36:56,180 --> 00:37:02,990
contains couple of integers which are

00:36:58,460 --> 00:37:07,490
used to identify the request type I send

00:37:02,990 --> 00:37:11,480
you to the USB space to find what those

00:37:07,490 --> 00:37:14,180
numbers exactly means and we have the

00:37:11,480 --> 00:37:17,330
context which is the pointer to be used

00:37:14,180 --> 00:37:20,150
by the driver as the context of this

00:37:17,330 --> 00:37:22,130
particular data delivery and of course

00:37:20,150 --> 00:37:24,800
the complete routine which will be

00:37:22,130 --> 00:37:27,740
called when this bunch of data will be

00:37:24,800 --> 00:37:29,900
delivered or error occurred or for

00:37:27,740 --> 00:37:32,089
example it has been cancelled to

00:37:29,900 --> 00:37:35,180
allocate the USB request blog you should

00:37:32,089 --> 00:37:36,320
use this function and free it with a

00:37:35,180 --> 00:37:38,450
suitable function

00:37:36,320 --> 00:37:42,110
because your host controller might do

00:37:38,450 --> 00:37:45,140
some mapping to the memory etc so that's

00:37:42,110 --> 00:37:47,660
why you should not allocate this

00:37:45,140 --> 00:37:52,850
structure on your own injuring the

00:37:47,660 --> 00:37:57,170
driver so how does typical USB driver

00:37:52,850 --> 00:38:00,290
looks like generally we have 3 USB

00:37:57,170 --> 00:38:02,630
related functions it's a probe functions

00:38:00,290 --> 00:38:04,760
it's a probe function which is used to

00:38:02,630 --> 00:38:07,760
check the device and allocate the

00:38:04,760 --> 00:38:09,560
resources then we've got the disconnect

00:38:07,760 --> 00:38:13,400
function which is used to release the

00:38:09,560 --> 00:38:16,670
resources complete routine which is used

00:38:13,400 --> 00:38:19,910
to check the statute which should check

00:38:16,670 --> 00:38:23,090
the USB request block status and many

00:38:19,910 --> 00:38:27,080
drivers doesn't check it get the data

00:38:23,090 --> 00:38:30,880
from the usb request block and resubmit

00:38:27,080 --> 00:38:34,130
the work why I said resubmit well

00:38:30,880 --> 00:38:36,710
generally drivers doesn't like to

00:38:34,130 --> 00:38:37,940
deallocate and allocate USB request

00:38:36,710 --> 00:38:40,730
blocks all the time

00:38:37,940 --> 00:38:43,970
that's why driver usually allocate a

00:38:40,730 --> 00:38:47,270
bunch of USB requests and then just

00:38:43,970 --> 00:38:52,190
simply reuse them only placing the data

00:38:47,270 --> 00:38:54,980
in suitable position all other functions

00:38:52,190 --> 00:38:57,020
will be related to other subsystem which

00:38:54,980 --> 00:38:59,450
is used to provide the USB device

00:38:57,020 --> 00:39:02,270
functionality to the user space for

00:38:59,450 --> 00:39:07,730
example in pendrive it will be related

00:39:02,270 --> 00:39:12,500
to the block subsystem typical box in

00:39:07,730 --> 00:39:15,710
the USB device missing descriptors well

00:39:12,500 --> 00:39:23,450
first of all USB devices can do really

00:39:15,710 --> 00:39:27,530
such really unbelievable things that's

00:39:23,450 --> 00:39:30,530
how the bugs are being found for example

00:39:27,530 --> 00:39:34,760
using the faster the you map to or

00:39:30,530 --> 00:39:37,880
something it means that device can be

00:39:34,760 --> 00:39:40,430
very different than what you expect it

00:39:37,880 --> 00:39:43,460
for example device with your vendor ID

00:39:40,430 --> 00:39:45,080
and Product ID may have 0 endpoints or

00:39:43,460 --> 00:39:48,110
may have endpoints with very different

00:39:45,080 --> 00:39:49,660
types than you expected so each time

00:39:48,110 --> 00:39:52,420
when you could

00:39:49,660 --> 00:39:54,819
function is cold you should check if the

00:39:52,420 --> 00:39:56,500
device provides really what you expect

00:39:54,819 --> 00:40:00,579
and you should check of course for

00:39:56,500 --> 00:40:03,130
errors there is no error puffs on

00:40:00,579 --> 00:40:07,270
missing entities so for example if

00:40:03,130 --> 00:40:10,059
endpoint is missing then driver tries to

00:40:07,270 --> 00:40:12,520
get this endpoint and it gets the null

00:40:10,059 --> 00:40:16,450
and we simply have the null pointer the

00:40:12,520 --> 00:40:18,940
reference then later in the code driver

00:40:16,450 --> 00:40:22,210
has problems problems with correct error

00:40:18,940 --> 00:40:24,339
handling in complete function it means

00:40:22,210 --> 00:40:28,359
that when the device disappeared in the

00:40:24,339 --> 00:40:30,640
middle of USB transfer there is a prote

00:40:28,359 --> 00:40:32,559
there is a new pointer the reference or

00:40:30,640 --> 00:40:34,750
accessing the data which has not been

00:40:32,559 --> 00:40:37,930
sent by the device this was for example

00:40:34,750 --> 00:40:40,750
the case with the driver to display link

00:40:37,930 --> 00:40:44,950
the one they want the open source driver

00:40:40,750 --> 00:40:47,799
to display links and of course USB

00:40:44,950 --> 00:40:50,170
drivers our implementation of some

00:40:47,799 --> 00:40:53,369
communication protocol they are

00:40:50,170 --> 00:40:55,900
vulnerable to some mal format packages

00:40:53,369 --> 00:40:58,000
so remember that if you are

00:40:55,900 --> 00:41:01,450
communicating with the device you should

00:40:58,000 --> 00:41:04,750
always do some sanity checking of sizes

00:41:01,450 --> 00:41:06,220
declared by the device for example when

00:41:04,750 --> 00:41:10,089
we asked about the configuration

00:41:06,220 --> 00:41:12,940
descriptor we asked for the total size

00:41:10,089 --> 00:41:15,730
to allocate the buffer then we allocate

00:41:12,940 --> 00:41:18,910
the buffer and then we asked once again

00:41:15,730 --> 00:41:21,099
with a different size and we assume that

00:41:18,910 --> 00:41:28,029
the device will send us the same amount

00:41:21,099 --> 00:41:31,450
of data it may not so how can we learn

00:41:28,029 --> 00:41:33,250
what device sends to us first of all

00:41:31,450 --> 00:41:35,859
there are some hardware solutions they

00:41:33,250 --> 00:41:37,990
are pretty good the one from Alice's is

00:41:35,859 --> 00:41:41,170
the one I have on my desk this one is

00:41:37,990 --> 00:41:44,049
also really good and what is the benefit

00:41:41,170 --> 00:41:48,390
of having them they they will not only

00:41:44,049 --> 00:41:51,609
show you the data on the transfer level

00:41:48,390 --> 00:41:55,150
they will also show you the low level

00:41:51,609 --> 00:41:56,950
data from the transaction level it means

00:41:55,150 --> 00:41:59,710
that they will show you how many NOx

00:41:56,950 --> 00:42:03,310
there was from the device what is the

00:41:59,710 --> 00:42:06,370
delay between single transaction

00:42:03,310 --> 00:42:09,310
etc so they are pretty good but as this

00:42:06,370 --> 00:42:13,270
as you see pretty expensive there is a

00:42:09,310 --> 00:42:17,560
cheaper solution it's called the open

00:42:13,270 --> 00:42:20,230
this SLI if someone is using it I will

00:42:17,560 --> 00:42:23,260
be happy to have a conversation about it

00:42:20,230 --> 00:42:26,170
I heard about this project I didn't use

00:42:23,260 --> 00:42:28,570
it personally I'm talking about here

00:42:26,170 --> 00:42:31,270
because I want to find some community of

00:42:28,570 --> 00:42:34,720
this board because the project let's say

00:42:31,270 --> 00:42:36,460
it's a mystery for me it looks dead but

00:42:34,720 --> 00:42:39,870
some people climb that they are using

00:42:36,460 --> 00:42:42,400
this board and this is an open-source

00:42:39,870 --> 00:42:51,340
Hardware on open-source communication

00:42:42,400 --> 00:42:54,880
analyzer on FPGA board so that's the

00:42:51,340 --> 00:42:57,490
hardware solution fortunately we have a

00:42:54,880 --> 00:43:00,730
cost free solution which is called the

00:42:57,490 --> 00:43:03,340
USB monitor it's a simple logger for

00:43:00,730 --> 00:43:06,760
events like submit or complete and

00:43:03,340 --> 00:43:09,990
submit ever so you can get all the data

00:43:06,760 --> 00:43:13,240
on the trend on the transfer level and

00:43:09,990 --> 00:43:15,790
only on the transfer level you are not

00:43:13,240 --> 00:43:18,790
going to get the data about single

00:43:15,790 --> 00:43:22,330
transactions from here because it's a

00:43:18,790 --> 00:43:24,910
simple logger it's nothing more we have

00:43:22,330 --> 00:43:28,420
text interface the binary interface and

00:43:24,910 --> 00:43:30,970
there will be one instance of the binary

00:43:28,420 --> 00:43:35,170
and text interface for each USB bus

00:43:30,970 --> 00:43:37,360
available in your system having a text

00:43:35,170 --> 00:43:39,850
interface is great having a binary

00:43:37,360 --> 00:43:41,740
interface is also great but interpreting

00:43:39,850 --> 00:43:44,680
this in your but writing your own

00:43:41,740 --> 00:43:47,350
program to interpret this is really not

00:43:44,680 --> 00:43:50,290
a thing you want to do to debug your USB

00:43:47,350 --> 00:43:53,860
traffic that's why we should go and use

00:43:50,290 --> 00:43:57,010
the Wireshark but remember that when

00:43:53,860 --> 00:44:01,570
there are two kinds of events we have

00:43:57,010 --> 00:44:04,360
submit when driver submits the USB

00:44:01,570 --> 00:44:07,600
request which means asks for transfer

00:44:04,360 --> 00:44:10,240
and then the complete routine that the

00:44:07,600 --> 00:44:15,550
transfer has been completed and the data

00:44:10,240 --> 00:44:16,849
is not always valid if you have endpoint

00:44:15,550 --> 00:44:18,619
which is in

00:44:16,849 --> 00:44:21,499
which is used to send the data from the

00:44:18,619 --> 00:44:25,039
device to the host the data is valid

00:44:21,499 --> 00:44:27,799
only in complete routine if you have out

00:44:25,039 --> 00:44:30,739
end point which is used to send the data

00:44:27,799 --> 00:44:33,309
from the host to the device the valid

00:44:30,739 --> 00:44:36,769
data buffer is only on submit function

00:44:33,309 --> 00:44:42,200
so don't check the data if it is not

00:44:36,769 --> 00:44:45,890
valid okay so now let's try to catch

00:44:42,200 --> 00:44:48,829
something in our Wireshark you remember

00:44:45,890 --> 00:44:51,710
that we have serial device connected to

00:44:48,829 --> 00:45:03,710
our computer to my computer so now let's

00:44:51,710 --> 00:45:08,450
open the screen okay so that's the

00:45:03,710 --> 00:45:12,319
serial output now let's go to the this

00:45:08,450 --> 00:45:17,109
is the device control now I will oh it

00:45:12,319 --> 00:45:17,109
would be better to run Wireshark now

00:45:18,579 --> 00:45:26,259
first of all to use the USB monitor you

00:45:21,499 --> 00:45:26,259
have to not probe the USB Mon module

00:45:43,619 --> 00:45:50,789
and when you run your Wireshark you will

00:45:46,559 --> 00:45:53,579
see couple of USB Mon devices the number

00:45:50,789 --> 00:45:56,759
of the device is the bus identity we use

00:45:53,579 --> 00:46:01,289
the third bus so I will start listening

00:45:56,759 --> 00:46:03,210
on the USB Mon free and because that's

00:46:01,289 --> 00:46:06,029
not only device which is connected to

00:46:03,210 --> 00:46:09,359
the bus I get a lot of mass and I don't

00:46:06,029 --> 00:46:11,819
want to play with it so I will simply

00:46:09,359 --> 00:46:17,239
just filter it using the device address

00:46:11,819 --> 00:46:25,999
and the device address for my device was

00:46:17,239 --> 00:46:25,999
Hollis USB the device address is seven

00:46:30,210 --> 00:46:39,359
equals to seven go now I will just

00:46:36,900 --> 00:46:41,609
simply send the test message from the

00:46:39,359 --> 00:46:44,089
device that's the serial console to to

00:46:41,609 --> 00:46:44,089
the odd roid

00:46:55,990 --> 00:47:03,010
and as you see it appeared in the screen

00:46:59,890 --> 00:47:08,849
so my host received the message from

00:47:03,010 --> 00:47:13,359
from the USB device and if I go to the

00:47:08,849 --> 00:47:18,760
Wireshark I will see that the in data

00:47:13,359 --> 00:47:22,210
has been sent we have this one is

00:47:18,760 --> 00:47:23,109
complete because driver submitted in

00:47:22,210 --> 00:47:28,690
oops

00:47:23,109 --> 00:47:34,660
when I opened the serial TTI so now I

00:47:28,690 --> 00:47:37,480
have the complete routine that's exactly

00:47:34,660 --> 00:47:40,750
the message which I sent from the device

00:47:37,480 --> 00:47:44,230
to the host and then I have another

00:47:40,750 --> 00:47:46,510
event which is ARP submit which means

00:47:44,230 --> 00:47:53,580
that driver is waiting for more data

00:47:46,510 --> 00:47:59,500
from the device ok so that's pretty old

00:47:53,580 --> 00:48:01,960
so just to swim up to identify your USB

00:47:59,500 --> 00:48:05,230
device you generally use the values from

00:48:01,960 --> 00:48:07,690
the USB descriptors you can get them

00:48:05,230 --> 00:48:11,380
using the LS USB it's really friendly

00:48:07,690 --> 00:48:14,980
and useful to remember to check it each

00:48:11,380 --> 00:48:18,520
driver binds to the device based on the

00:48:14,980 --> 00:48:21,490
Clark compatible USB device device list

00:48:18,520 --> 00:48:24,280
but of course you can modify this and

00:48:21,490 --> 00:48:27,880
you can sniff what your driver is

00:48:24,280 --> 00:48:31,119
sending to the device for free using USB

00:48:27,880 --> 00:48:34,750
mode so thank you I think we have some

00:48:31,119 --> 00:48:40,859
time for let's say two questions if

00:48:34,750 --> 00:48:40,859
there are some yeah

00:48:52,099 --> 00:49:01,710
are there effective well okay so the

00:48:59,339 --> 00:49:03,900
question is that I used Wireshark and

00:49:01,710 --> 00:49:06,359
the question is about the commercial USB

00:49:03,900 --> 00:49:09,240
analyzers if they are effective

00:49:06,359 --> 00:49:12,089
well yes generally they are effective

00:49:09,240 --> 00:49:14,490
they can do not only the USB transfers

00:49:12,089 --> 00:49:17,520
so because the transfer level is the

00:49:14,490 --> 00:49:20,010
level on which USB drivers operate but

00:49:17,520 --> 00:49:22,760
if you would like to write a driver for

00:49:20,010 --> 00:49:25,230
a host controller or device controller

00:49:22,760 --> 00:49:28,410
probably you would like to not only know

00:49:25,230 --> 00:49:31,339
the level of the USB protocol but also

00:49:28,410 --> 00:49:34,800
the lower the lower level the level of

00:49:31,339 --> 00:49:39,839
sending single transactions sink

00:49:34,800 --> 00:49:42,660
receiving NOx etc yeah yeah exactly that

00:49:39,839 --> 00:49:45,750
does the stuff for which you should do

00:49:42,660 --> 00:49:48,150
the hardware analyzers to check them of

00:49:45,750 --> 00:49:51,150
course there are detectors also for the

00:49:48,150 --> 00:49:54,210
protocols on the top like mass storage

00:49:51,150 --> 00:49:56,579
human interface etc but Wireshark

00:49:54,210 --> 00:49:59,099
usually also have them of course they

00:49:56,579 --> 00:50:03,560
are much better and the performance is

00:49:59,099 --> 00:50:16,290
better etc but you know they cost a lot

00:50:03,560 --> 00:50:17,880
okay well I I don't know your USB the

00:50:16,290 --> 00:50:22,670
question is if we can use logic

00:50:17,880 --> 00:50:22,670
analyzers and for the USB

00:51:42,890 --> 00:51:49,800
okay so just to sum up and logic

00:51:47,520 --> 00:51:51,930
analyzer can be used if it is fast

00:51:49,800 --> 00:51:56,820
enough and you have a suitable software

00:51:51,930 --> 00:52:02,970
to define to detect trance the physical

00:51:56,820 --> 00:52:04,410
liar okay any other questions okay so

00:52:02,970 --> 00:52:11,120
thank you very much

00:52:04,410 --> 00:52:11,120

YouTube URL: https://www.youtube.com/watch?v=6UHqtbiJX94


