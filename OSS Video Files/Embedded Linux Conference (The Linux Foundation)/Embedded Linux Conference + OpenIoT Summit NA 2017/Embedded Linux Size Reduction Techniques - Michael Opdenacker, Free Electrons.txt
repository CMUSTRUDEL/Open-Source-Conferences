Title: Embedded Linux Size Reduction Techniques - Michael Opdenacker, Free Electrons
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Embedded Linux Size Reduction Techniques - Michael Opdenacker, Free Electrons

Are you interested in running Linux in a system with very small RAM
and storage resources? Or are you just trying to make the Linux kernel
and its filesystem as small as possible, typically to boot faster?

This talk will detail approaches for reducing the size of the kernel,
of individual applications and of the whole filesystem. Benchmarks
will you show how much you can expect to save with each approach.

Michael will also try to collect valuable experience from participants
to the talk, as well as ideas for further improvements, to add to the
materials he will publish after the conference.

Disclaimer: the only thing Michael won't try to reduce is the
size of his presentation, as there are many resources worth exploring.

About Michael Opdenacker
Michael Opdenacker is the founder of Free Electrons, a company best known | for its freely available training materials on the Linux kernel and | in embedded Linux in general. Michael has a long time interest in boot | time reduction, and therefore in one of its prerequisites, which is size | reduction.
Captions: 
	00:00:00,290 --> 00:00:07,400
so this is going to be a presentation

00:00:02,820 --> 00:00:10,530
about various hi David levied a

00:00:07,400 --> 00:00:12,120
presentation about techniques that you

00:00:10,530 --> 00:00:13,490
can apply to reduce the size of your

00:00:12,120 --> 00:00:17,820
system

00:00:13,490 --> 00:00:22,080
so first I'm Michael Decker founder of

00:00:17,820 --> 00:00:28,710
free electrons and I've been interested

00:00:22,080 --> 00:00:31,230
in in topics like size but also fastboot

00:00:28,710 --> 00:00:35,489
time and a small size is a requirement

00:00:31,230 --> 00:00:37,020
for for fast booting like the fast the

00:00:35,489 --> 00:00:41,309
smaller the kernel is the faster it

00:00:37,020 --> 00:00:46,850
boots and yeah there's less data you

00:00:41,309 --> 00:00:49,829
have you can copy from from storage so

00:00:46,850 --> 00:00:53,760
why reduce size there are various

00:00:49,829 --> 00:00:58,739
reasons for doing that first to turn on

00:00:53,760 --> 00:01:02,600
I use T systems very small systems we

00:00:58,739 --> 00:01:05,070
like to use Linux because of the only

00:01:02,600 --> 00:01:07,049
functionality that it provides which is

00:01:05,070 --> 00:01:09,180
sometimes useful

00:01:07,049 --> 00:01:11,700
some people can also run Linux as a

00:01:09,180 --> 00:01:14,460
bootloader so that you don't have to

00:01:11,700 --> 00:01:16,170
really recreate drivers for your

00:01:14,460 --> 00:01:20,640
bootloader and want your reuse as much

00:01:16,170 --> 00:01:22,830
as you can from from Linux of course

00:01:20,640 --> 00:01:25,799
boot fast booting faster is one of also

00:01:22,830 --> 00:01:29,400
one of the cases typically I've seen

00:01:25,799 --> 00:01:32,790
people booting their systems on an FPGA

00:01:29,400 --> 00:01:34,560
like the SOC doesn't exist yet and it's

00:01:32,790 --> 00:01:36,540
really slow when they have to immolate

00:01:34,560 --> 00:01:39,439
it on any pga so it's nice to have a

00:01:36,540 --> 00:01:41,850
kernel that is as small as possible

00:01:39,439 --> 00:01:43,710
because like it takes a few minutes to

00:01:41,850 --> 00:01:46,290
get to the command line prompt even more

00:01:43,710 --> 00:01:49,680
sometimes so it's it's nice to have a

00:01:46,290 --> 00:01:53,909
very small system also one of the goals

00:01:49,680 --> 00:01:55,860
could be to reduce power consumption and

00:01:53,909 --> 00:01:58,259
this is also the idea of writing whole

00:01:55,860 --> 00:02:00,500
system in an internal Ram if that's

00:01:58,259 --> 00:02:03,210
possible if the CPU has enough RAM

00:02:00,500 --> 00:02:07,079
internal Ram that's the case of one of

00:02:03,210 --> 00:02:10,560
the processors that are mentioned on the

00:02:07,079 --> 00:02:12,900
tiny that wicky-wicky kernel dog but HD

00:02:10,560 --> 00:02:13,560
they have like a few processors that

00:02:12,900 --> 00:02:16,800
could

00:02:13,560 --> 00:02:19,170
fit the whole Linux kernel and system

00:02:16,800 --> 00:02:20,880
inside a an internal round because DRM

00:02:19,170 --> 00:02:23,910
is expensive in terms of power

00:02:20,880 --> 00:02:26,610
consumption needs to be refreshed if you

00:02:23,910 --> 00:02:28,590
want to keep things inside and I just

00:02:26,610 --> 00:02:31,290
added the security at the last minute

00:02:28,590 --> 00:02:33,510
because it was talked about in the

00:02:31,290 --> 00:02:36,209
keynote this morning like it you could

00:02:33,510 --> 00:02:38,280
also try to add some security by

00:02:36,209 --> 00:02:40,319
reducing the attack surface on your

00:02:38,280 --> 00:02:43,590
system like not implementing system

00:02:40,319 --> 00:02:45,209
calls and then helping

00:02:43,590 --> 00:02:48,989
I mean reducing the functionality that

00:02:45,209 --> 00:02:51,989
could it could be vulnerable the reasons

00:02:48,989 --> 00:02:53,989
for for this talk is there's nothing

00:02:51,989 --> 00:02:55,950
much new and fortunately in this area

00:02:53,989 --> 00:03:01,730
but there hasn't been any talk about

00:02:55,950 --> 00:03:06,090
size since ELC to one year and half ago

00:03:01,730 --> 00:03:11,720
but I wanted to see what how things look

00:03:06,090 --> 00:03:15,260
like now what projects are what progress

00:03:11,720 --> 00:03:17,970
projects may have made and also as a

00:03:15,260 --> 00:03:19,890
personal interest looking at things I

00:03:17,970 --> 00:03:23,040
didn't try yet as and share this

00:03:19,890 --> 00:03:25,980
experience with you like trying with the

00:03:23,040 --> 00:03:27,390
muscle library things like so things

00:03:25,980 --> 00:03:30,510
that have been around for quite a while

00:03:27,390 --> 00:03:31,739
but which I didn't play with yet things

00:03:30,510 --> 00:03:35,069
like tada toy box

00:03:31,739 --> 00:03:37,019
GCC LTO some experiments with the latest

00:03:35,069 --> 00:03:39,000
GCC versions compiling with clang and

00:03:37,019 --> 00:03:41,430
things like that just to share an update

00:03:39,000 --> 00:03:43,049
and so there's nothing extraordinary and

00:03:41,430 --> 00:03:45,299
I don't expect too much but at least

00:03:43,049 --> 00:03:47,579
you'll have some figures which which may

00:03:45,299 --> 00:03:49,530
help you in making your decisions and

00:03:47,579 --> 00:03:54,989
trying I guide you in the choices that

00:03:49,530 --> 00:03:57,810
you will make and it's also I when I

00:03:54,989 --> 00:04:01,500
submitted this talk proposal I also is

00:03:57,810 --> 00:04:03,840
it ated between above and I talked so I

00:04:01,500 --> 00:04:05,579
like to have like half of the session

00:04:03,840 --> 00:04:07,440
and dedicated questions and answers and

00:04:05,579 --> 00:04:11,389
proof I mean people talking about what

00:04:07,440 --> 00:04:14,100
they could do to improve size issues and

00:04:11,389 --> 00:04:15,959
how how they could get involved what we

00:04:14,100 --> 00:04:19,340
could do as a community to to make

00:04:15,959 --> 00:04:21,900
things better so that there's a like

00:04:19,340 --> 00:04:24,049
both part in this talk if we have enough

00:04:21,900 --> 00:04:24,049
time

00:04:24,990 --> 00:04:31,060
so essentially how small a Linux kernel

00:04:28,300 --> 00:04:32,830
the Linux system can be essentially you

00:04:31,060 --> 00:04:37,390
when you have like two six Meg's of RAM

00:04:32,830 --> 00:04:43,390
for that that a regular kernel will fit

00:04:37,390 --> 00:04:46,470
within this size and you need something

00:04:43,390 --> 00:04:50,020
like 8 16 Meg's to have enough space for

00:04:46,470 --> 00:04:51,640
4 uses for four user space whatever you

00:04:50,020 --> 00:04:54,220
do in user space for your applications

00:04:51,640 --> 00:04:55,870
and the allocations you make of course

00:04:54,220 --> 00:04:57,790
you have if you have more RAM you have

00:04:55,870 --> 00:05:01,450
more performance because you can cache

00:04:57,790 --> 00:05:03,220
things as far as so I'm talking about a

00:05:01,450 --> 00:05:06,070
regular system without really doing

00:05:03,220 --> 00:05:10,570
anything really hacky - to reduce the

00:05:06,070 --> 00:05:13,810
size then storage you basically need

00:05:10,570 --> 00:05:15,670
between 2 and 4 megabytes of space to

00:05:13,810 --> 00:05:17,110
store the immediate kernel and user

00:05:15,670 --> 00:05:19,870
space can fit in a few hundreds of

00:05:17,110 --> 00:05:22,420
kilobytes that's really nice it's easy

00:05:19,870 --> 00:05:24,370
to have a standalone application that

00:05:22,420 --> 00:05:28,390
fits in within a few hundreds of

00:05:24,370 --> 00:05:33,010
kilobytes at most so if the user space

00:05:28,390 --> 00:05:36,400
is not too complex 8 to 16 megabytes of

00:05:33,010 --> 00:05:40,510
space is really more than enough if you

00:05:36,400 --> 00:05:42,400
have a dedicated system of course so I'm

00:05:40,510 --> 00:05:44,710
gonna give you a list of things you can

00:05:42,400 --> 00:05:48,640
do to reduce that a little bit so of

00:05:44,710 --> 00:05:50,440
course there's the OS option of GCC to

00:05:48,640 --> 00:05:52,360
reduce size and it's nice because it

00:05:50,440 --> 00:05:55,780
like it automatically selects the

00:05:52,360 --> 00:06:00,780
optimizations based on what GCC can do

00:05:55,780 --> 00:06:05,740
so essentially it's - OH - plus - the

00:06:00,780 --> 00:06:08,260
optimizations that increase size it's

00:06:05,740 --> 00:06:10,150
quite impressive if you look at the all

00:06:08,260 --> 00:06:11,680
the options that are provided by GCC if

00:06:10,150 --> 00:06:14,080
you couldn't really want to investigate

00:06:11,680 --> 00:06:16,390
what GCC can do it you have a very long

00:06:14,080 --> 00:06:19,090
list of options with very detailed

00:06:16,390 --> 00:06:22,590
descriptions of the approaches that are

00:06:19,090 --> 00:06:27,790
that are taken it's very interesting I

00:06:22,590 --> 00:06:29,500
also make a quick check to see how what

00:06:27,790 --> 00:06:33,400
you see the impact of using a more

00:06:29,500 --> 00:06:34,340
recent compiler on sighs so that I did

00:06:33,400 --> 00:06:37,820
that on arm

00:06:34,340 --> 00:06:39,920
on the board that I booted so between

00:06:37,820 --> 00:06:41,510
GCC for at seven and six the to there

00:06:39,920 --> 00:06:42,950
isn't much change in terms of the

00:06:41,510 --> 00:06:45,680
optimization power

00:06:42,950 --> 00:06:49,370
I just saved zero to four percent in

00:06:45,680 --> 00:06:51,830
size in kernel size so it's not so much

00:06:49,370 --> 00:06:53,690
don't expect too much from GCC it's

00:06:51,830 --> 00:06:58,570
already already good doing a pretty good

00:06:53,690 --> 00:07:02,660
job there's also the link time of

00:06:58,570 --> 00:07:05,600
optimizations feature of GCC cinched ECC

00:07:02,660 --> 00:07:08,060
for that seven essentially what it does

00:07:05,600 --> 00:07:11,870
is GCC keeps more information about the

00:07:08,060 --> 00:07:14,180
source in a special format I mean in a

00:07:11,870 --> 00:07:16,070
special elf section when it creates dot

00:07:14,180 --> 00:07:18,710
o files it adds some more information in

00:07:16,070 --> 00:07:20,360
special sections and this is used at the

00:07:18,710 --> 00:07:23,630
end when linking or all the object files

00:07:20,360 --> 00:07:27,070
together to to have better optimizations

00:07:23,630 --> 00:07:29,780
like inlining across the various objects

00:07:27,070 --> 00:07:32,870
removing a detecting dead code and

00:07:29,780 --> 00:07:34,580
things like that and surprisingly it's

00:07:32,870 --> 00:07:36,550
all so it's it's nice - something you

00:07:34,580 --> 00:07:38,870
should try when you build software

00:07:36,550 --> 00:07:43,340
surprisingly it even works pretty well

00:07:38,870 --> 00:07:45,320
on single dot C file files so I find I

00:07:43,340 --> 00:07:51,230
found a pretty nice project which is

00:07:45,320 --> 00:07:53,600
called from this guy SMCC project

00:07:51,230 --> 00:07:56,690
singlefied programs this guy took a few

00:07:53,600 --> 00:08:00,860
prop a regular programs like ok and can

00:07:56,690 --> 00:08:03,440
a few others and just just put all the C

00:08:00,860 --> 00:08:06,620
files together in a single C file and

00:08:03,440 --> 00:08:08,060
it's very nice for GCC benchmarks of C

00:08:06,620 --> 00:08:10,970
compiler benchmark because you have just

00:08:08,060 --> 00:08:12,590
went up big dot C file and and see what

00:08:10,970 --> 00:08:16,340
how and you can play with the GCC

00:08:12,590 --> 00:08:20,030
options on all those Big C files so this

00:08:16,340 --> 00:08:23,150
for example a gank program was fitting

00:08:20,030 --> 00:08:26,480
in 1.7 megabytes so I used it several

00:08:23,150 --> 00:08:28,280
times to to make some measurements so

00:08:26,480 --> 00:08:31,670
here if you want to compile with LT oh

00:08:28,280 --> 00:08:36,650
we just add - f LT o to it in addition

00:08:31,670 --> 00:08:43,490
to OS this is a link to more details

00:08:36,650 --> 00:08:46,970
about LT o in and GCC so with still on

00:08:43,490 --> 00:08:49,519
org angered see if you use

00:08:46,970 --> 00:08:53,300
you compare LTO without LTO and without

00:08:49,519 --> 00:08:55,970
tio you can save about 2.6 percent in

00:08:53,300 --> 00:08:59,420
the stripped executable which is quite

00:08:55,970 --> 00:09:01,490
good and given the size of the

00:08:59,420 --> 00:09:06,259
executable at the end so it's pretty

00:09:01,490 --> 00:09:09,350
pretty nice that was on x86 64 on my

00:09:06,259 --> 00:09:13,519
essentially on my laptop and in forearm

00:09:09,350 --> 00:09:16,399
it's the same kind of saving as well

00:09:13,519 --> 00:09:18,649
- 2.8 percent in terms of the strip

00:09:16,399 --> 00:09:23,209
ticket people executable so you can like

00:09:18,649 --> 00:09:25,220
reduce a few essentially a few hundreds

00:09:23,209 --> 00:09:27,740
of kilobytes sometimes if the executable

00:09:25,220 --> 00:09:30,500
is big so that might be worth with it or

00:09:27,740 --> 00:09:33,889
a few tens of kilobytes don't compare

00:09:30,500 --> 00:09:35,839
the x86 64 code of course code size with

00:09:33,889 --> 00:09:39,040
the arm one you were talking about 64

00:09:35,839 --> 00:09:39,040
bits so it's not fair

00:09:41,860 --> 00:09:51,439
and then I tried clang versus GCC versus

00:09:46,699 --> 00:09:57,559
GCC so on regular GCC on that are on x86

00:09:51,439 --> 00:10:01,339
64 amid the chest and still with a gank

00:09:57,559 --> 00:10:03,949
and also confided with GCC clang are on

00:10:01,339 --> 00:10:06,019
the same same program and I got at 5%

00:10:03,949 --> 00:10:08,329
size reduction out of the box without

00:10:06,019 --> 00:10:10,970
doing anything just passing OS you know

00:10:08,329 --> 00:10:13,100
clang is trying to meet this to be

00:10:10,970 --> 00:10:16,309
compatible with GCC so you can pass the

00:10:13,100 --> 00:10:18,559
same options not FLT oh but essentially

00:10:16,309 --> 00:10:21,829
the basic options you have they just

00:10:18,559 --> 00:10:25,279
work so it's minus 5% and then I

00:10:21,829 --> 00:10:27,170
compared it again with a GCC LTO see and

00:10:25,279 --> 00:10:30,139
GCC LTO is trying to achieve something

00:10:27,170 --> 00:10:35,350
like what clang does it's bit less

00:10:30,139 --> 00:10:39,050
efficient so it left - 2.7 percent here

00:10:35,350 --> 00:10:42,949
so it's doing some of the job that the

00:10:39,050 --> 00:10:46,189
client can do Jesus you can still window

00:10:42,949 --> 00:10:49,250
for very small programs like in hello

00:10:46,189 --> 00:10:53,180
that see it's it's a bit a little

00:10:49,250 --> 00:10:55,939
smaller my one way wonder 2% with his in

00:10:53,180 --> 00:10:58,209
many bytes though because it's a small

00:10:55,939 --> 00:10:58,209
program

00:10:59,840 --> 00:11:06,410
you may wonder also on Anyang platform

00:11:02,810 --> 00:11:08,270
whether it's whether to use thumb thumb

00:11:06,410 --> 00:11:11,030
to actually under latest processors or

00:11:08,270 --> 00:11:12,800
arm the arm instruction sets so the arm

00:11:11,030 --> 00:11:17,090
instruction set is taught to beta and

00:11:12,800 --> 00:11:18,620
thumb to is 16-bit it's more compact but

00:11:17,090 --> 00:11:21,050
to express the same things you need more

00:11:18,620 --> 00:11:23,000
instructions and therefore you don't

00:11:21,050 --> 00:11:25,700
like divide this the code size by two of

00:11:23,000 --> 00:11:28,280
course so I to first to recognize the

00:11:25,700 --> 00:11:31,610
code that you get it's it's good to do

00:11:28,280 --> 00:11:36,200
you I am doing on Linux optional - s -

00:11:31,610 --> 00:11:38,360
like honor on an object code tronic turn

00:11:36,200 --> 00:11:41,180
it into assembly and ice and I and then

00:11:38,360 --> 00:11:42,500
you can see the size of object you can

00:11:41,180 --> 00:11:44,870
see that how the code look like so for

00:11:42,500 --> 00:11:48,620
arm you can see yet the addresses are

00:11:44,870 --> 00:11:51,560
multiple multiples of four and you have

00:11:48,620 --> 00:11:53,540
32-bit instructions while with thumb you

00:11:51,560 --> 00:11:56,840
have like addresses which are multiple

00:11:53,540 --> 00:11:59,060
of two as expected and also 16-bit

00:11:56,840 --> 00:12:01,610
instructions as well so you that's a way

00:11:59,060 --> 00:12:03,080
to recognize from I didn't I didn't find

00:12:01,610 --> 00:12:07,460
any other way to recognize fun than

00:12:03,080 --> 00:12:09,470
disassembling and I did that because it

00:12:07,460 --> 00:12:12,350
turned out that my compiler by default

00:12:09,470 --> 00:12:13,940
was compiling for fun the way that you

00:12:12,350 --> 00:12:18,920
have in a bone to compile for fun by

00:12:13,940 --> 00:12:20,810
default so you don't really have to

00:12:18,920 --> 00:12:23,930
think about using fun because it's often

00:12:20,810 --> 00:12:27,200
built in your compiler depending perhaps

00:12:23,930 --> 00:12:30,860
on the compiler you you get on your

00:12:27,200 --> 00:12:35,570
platforms so to compile in arm mode you

00:12:30,860 --> 00:12:37,910
can use - me I'm arm and thumb instead

00:12:35,570 --> 00:12:40,490
and you can also of course tune for a

00:12:37,910 --> 00:12:44,210
specific CPU and see where whether you

00:12:40,490 --> 00:12:46,760
can get in some some code size so thumb

00:12:44,210 --> 00:12:50,450
in that case was like - seven percent

00:12:46,760 --> 00:12:52,160
smaller than pure I didn't arm though

00:12:50,450 --> 00:12:55,940
when I was compiling with arm I actually

00:12:52,160 --> 00:12:57,589
got a mixed of arm and thumb code so I

00:12:55,940 --> 00:13:00,680
don't really know why this happens but

00:12:57,589 --> 00:13:03,140
that's what I observed with this program

00:13:00,680 --> 00:13:08,020
I had some with an arm I had some thumb

00:13:03,140 --> 00:13:08,020
code inside as well I don't mind

00:13:10,680 --> 00:13:17,580
the next question is how to get a small

00:13:13,410 --> 00:13:20,940
kernel since I'm not going to talk about

00:13:17,580 --> 00:13:23,420
the past the very old kernel so since 3

00:13:20,940 --> 00:13:27,060
that 18 you can run make tiny config

00:13:23,420 --> 00:13:32,310
which was brought by a Josh triplet is

00:13:27,060 --> 00:13:34,770
see around in the conference no and I

00:13:32,310 --> 00:13:37,200
looked at what tiny config is it's

00:13:34,770 --> 00:13:42,360
actually just make on the kinetic plug

00:13:37,200 --> 00:13:44,520
plus a config fragment or exactly how to

00:13:42,360 --> 00:13:47,670
call it so if you look at the make file

00:13:44,520 --> 00:13:51,090
it's just all new config plus a few edit

00:13:47,670 --> 00:13:53,760
settings that that actually reduce size

00:13:51,090 --> 00:13:56,700
so it's even smaller than owner convict

00:13:53,760 --> 00:14:00,480
on all the country look at that

00:13:56,700 --> 00:14:03,270
it's what it does is use GCC optimized

00:14:00,480 --> 00:14:07,350
for size so the code may be slower but

00:14:03,270 --> 00:14:11,460
it's smaller you turn on kernel exit

00:14:07,350 --> 00:14:14,430
compression it is optimized in inlining

00:14:11,460 --> 00:14:17,280
the slope support so slub is one of the

00:14:14,430 --> 00:14:21,660
low level of slab allocators it's a

00:14:17,280 --> 00:14:24,540
little smaller than then slab or slab in

00:14:21,660 --> 00:14:26,460
size you just save a few like 6

00:14:24,540 --> 00:14:29,280
kilobytes or 10 kilobytes though I

00:14:26,460 --> 00:14:30,750
didn't check on the memory usage so

00:14:29,280 --> 00:14:32,160
maybe it's even better it's supposed to

00:14:30,750 --> 00:14:36,060
be like saving a few hundreds of

00:14:32,160 --> 00:14:40,560
kilobytes in in memory usage in a real

00:14:36,060 --> 00:14:43,500
life system though it doesn't scale and

00:14:40,560 --> 00:14:48,960
on on x86 you also have like no high

00:14:43,500 --> 00:14:50,820
MEMS and support that's added vanished

00:14:48,960 --> 00:14:54,420
I don't checked the kernel size with

00:14:50,820 --> 00:14:57,600
tank with tiny config and it's not so

00:14:54,420 --> 00:14:59,910
bad like you expect like the kernel size

00:14:57,600 --> 00:15:02,760
to grow up and up and have an app it

00:14:59,910 --> 00:15:06,630
actually it's so actually it's going

00:15:02,760 --> 00:15:09,000
down on are on your own platform so the

00:15:06,630 --> 00:15:11,430
total I'm looking at the tototo

00:15:09,000 --> 00:15:13,050
vm linux size assuming that this is

00:15:11,430 --> 00:15:15,960
going to be what you load in memory do

00:15:13,050 --> 00:15:17,760
you did what you're going to consume in

00:15:15,960 --> 00:15:19,890
memory so I didn't look at the

00:15:17,760 --> 00:15:20,680
compressed sites though I will show it

00:15:19,890 --> 00:15:25,930
as well

00:15:20,680 --> 00:15:28,540
so look like this that's the default the

00:15:25,930 --> 00:15:30,399
full-size and it went down in the 4.4

00:15:28,540 --> 00:15:33,670
for that five I don't know I didn't have

00:15:30,399 --> 00:15:37,660
time to exist investigate why perhaps

00:15:33,670 --> 00:15:41,410
because of some some drivers that associ

00:15:37,660 --> 00:15:50,339
drivers being moved to a proper drivers

00:15:41,410 --> 00:15:57,100
directory and then being optional yes no

00:15:50,339 --> 00:16:05,740
yeah I didn't know oh yeah now that's a

00:15:57,100 --> 00:16:06,100
good point to regular make so yep that's

00:16:05,740 --> 00:16:08,379
true

00:16:06,100 --> 00:16:11,230
so it's bigger than its it is at runtime

00:16:08,379 --> 00:16:14,019
thank you any idea what could have

00:16:11,230 --> 00:16:22,809
happened at 144 for that I mean for the

00:16:14,019 --> 00:16:29,009
five for the size reduction it's the

00:16:22,809 --> 00:16:32,170
same compiler like at that time maybe

00:16:29,009 --> 00:16:34,149
that's good anyway if you look at the

00:16:32,170 --> 00:16:35,860
x86 it's more progress it's it's more

00:16:34,149 --> 00:16:38,920
like constant almost constant so it

00:16:35,860 --> 00:16:44,679
doesn't grow that much over the course

00:16:38,920 --> 00:16:48,059
of like 12 versions it's a little bigger

00:16:44,679 --> 00:16:52,929
of course but it's it's x86 as well

00:16:48,059 --> 00:16:56,249
64-bit as well so it's bigger so it

00:16:52,929 --> 00:16:58,629
isn't you may think as the

00:16:56,249 --> 00:17:00,970
technification project is not so active

00:16:58,629 --> 00:17:03,370
that it's going to like grow very

00:17:00,970 --> 00:17:03,999
exponentially it's not it's not what

00:17:03,370 --> 00:17:07,000
happens

00:17:03,999 --> 00:17:08,919
ready yet it's still under control as

00:17:07,000 --> 00:17:13,209
also it means we could like reverse the

00:17:08,919 --> 00:17:15,549
trend I made a test like I really wanted

00:17:13,209 --> 00:17:21,360
to make sure I have a kernel that boots

00:17:15,549 --> 00:17:25,990
so I booted the for the 10 kernel Anya

00:17:21,360 --> 00:17:28,870
cumulated versatile PB arm platform so

00:17:25,990 --> 00:17:30,700
the said image was 400 kilobytes which

00:17:28,870 --> 00:17:33,770
is quite good we fix that compression

00:17:30,700 --> 00:17:38,660
and yeah the total

00:17:33,770 --> 00:17:43,550
sighs and strips is a little over one

00:17:38,660 --> 00:17:45,170
megabyte and then I tried to with qmu

00:17:43,550 --> 00:17:47,930
it's nice because you can reduce you can

00:17:45,170 --> 00:17:51,260
like simulate a machine with the hump

00:17:47,930 --> 00:17:54,590
how much whatever amount of ram you want

00:17:51,260 --> 00:17:57,320
so I went down as little as three

00:17:54,590 --> 00:17:59,000
megabytes and when I reached three

00:17:57,320 --> 00:18:01,430
megabytes in the system I couldn't boot

00:17:59,000 --> 00:18:05,090
any more so at least it boots with four

00:18:01,430 --> 00:18:07,310
megabytes so with more aggressive work I

00:18:05,090 --> 00:18:11,510
guess two megabytes or three megabytes

00:18:07,310 --> 00:18:13,400
are probably achievable so it's in

00:18:11,510 --> 00:18:17,270
between three and four have no choice in

00:18:13,400 --> 00:18:29,060
qmu I think to to like know exactly what

00:18:17,270 --> 00:18:31,100
the threshold is all right so that's

00:18:29,060 --> 00:18:33,110
that's one of my questions to what what

00:18:31,100 --> 00:18:35,600
hardware could be used to play with

00:18:33,110 --> 00:18:37,310
those things and it's it's more likely

00:18:35,600 --> 00:18:39,950
to convince kernel developers if you're

00:18:37,310 --> 00:18:46,030
using real hardware than qmu to get some

00:18:39,950 --> 00:18:46,030
code accepted okay oh yeah

00:18:48,630 --> 00:18:52,710
so a few words about the state of the

00:18:50,580 --> 00:18:55,410
current ina fication project project

00:18:52,710 --> 00:18:56,820
which was started by a Josh triplet and

00:18:55,410 --> 00:19:02,010
let's forget about everything that went

00:18:56,820 --> 00:19:05,310
on before they like about one year ago

00:19:02,010 --> 00:19:08,550
they were he had like a few patches left

00:19:05,310 --> 00:19:10,890
in the Linux tax tree and they were they

00:19:08,550 --> 00:19:12,240
were you didn't have time to kill

00:19:10,890 --> 00:19:16,530
take care about them and and therefore

00:19:12,240 --> 00:19:18,420
they were removed from the tree but the

00:19:16,530 --> 00:19:20,420
tree is still available the patches are

00:19:18,420 --> 00:19:23,160
still available or we could like

00:19:20,420 --> 00:19:26,130
resurrect them if we want yeah the

00:19:23,160 --> 00:19:28,170
problem is there's a if you follow the

00:19:26,130 --> 00:19:31,080
discussions there's skepticism about

00:19:28,170 --> 00:19:34,740
like adding some extra kernel

00:19:31,080 --> 00:19:36,600
configuration options to further allow

00:19:34,740 --> 00:19:38,400
to remove features from the kernel like

00:19:36,600 --> 00:19:40,620
the kernel developers don't like to they

00:19:38,400 --> 00:19:43,200
already have to deal with K config

00:19:40,620 --> 00:19:45,330
complexity which is rather big so is it

00:19:43,200 --> 00:19:49,650
really the way to go through to add some

00:19:45,330 --> 00:19:52,890
more kernel configuration options to to

00:19:49,650 --> 00:19:55,440
allow to disable things this has proved

00:19:52,890 --> 00:19:57,450
to be useful in the past like you see

00:19:55,440 --> 00:20:00,090
the benefits of the Dyna fication

00:19:57,450 --> 00:20:03,390
project and how small a kernel can be

00:20:00,090 --> 00:20:06,000
and I'm Elementor like ten years back I

00:20:03,390 --> 00:20:09,420
had roughly the same kernel size I as I

00:20:06,000 --> 00:20:11,280
have now now so it's like people like

00:20:09,420 --> 00:20:13,680
Josh have and Mac Michael and others

00:20:11,280 --> 00:20:16,320
have been done a great job of keeping

00:20:13,680 --> 00:20:20,550
the the size to a minimum it hasn't

00:20:16,320 --> 00:20:23,250
grown over time so it was useful but is

00:20:20,550 --> 00:20:26,790
this the new way to go and if you look

00:20:23,250 --> 00:20:28,470
at discussions people are more likely to

00:20:26,790 --> 00:20:31,770
be interested in exploring automated

00:20:28,470 --> 00:20:34,920
ways of detecting and used features a

00:20:31,770 --> 00:20:37,410
news code reveal Ruby I'm detecting that

00:20:34,920 --> 00:20:40,020
and then having mechanisms to remove

00:20:37,410 --> 00:20:42,920
them from the kernel code so that they

00:20:40,020 --> 00:20:45,930
don't do the kernel is smaller based on

00:20:42,920 --> 00:20:47,940
what you like you like you trace your

00:20:45,930 --> 00:20:50,040
system you make it run and see what

00:20:47,940 --> 00:20:52,020
exactly what you use at runtime during

00:20:50,040 --> 00:20:54,450
some well-defined test scenario and then

00:20:52,020 --> 00:20:56,220
remove the code that you don't need like

00:20:54,450 --> 00:20:58,020
the system calls the praça de proc

00:20:56,220 --> 00:21:00,510
contents the current kernel command-line

00:20:58,020 --> 00:21:01,130
parameters you never access so that's

00:21:00,510 --> 00:21:03,140
may

00:21:01,130 --> 00:21:06,170
the way to go according to the current

00:21:03,140 --> 00:21:09,170
of developers there's a lack of

00:21:06,170 --> 00:21:10,880
volunteers with time and with time to

00:21:09,170 --> 00:21:17,720
drive the mainlining effort anyway that

00:21:10,880 --> 00:21:21,020
that's one of the problems to a few

00:21:17,720 --> 00:21:23,240
words about LTO it can be an interesting

00:21:21,020 --> 00:21:27,140
solution it was patches were proposed by

00:21:23,240 --> 00:21:31,370
Andy keen in back in 2012 the problem is

00:21:27,140 --> 00:21:33,590
at the time the patch was submitted they

00:21:31,370 --> 00:21:36,140
were creating new problems more

00:21:33,590 --> 00:21:38,180
difficult to investigate problems so

00:21:36,140 --> 00:21:42,080
they couldn't be accepted back at that

00:21:38,180 --> 00:21:44,000
time and we had people that Linnaeus

00:21:42,080 --> 00:21:46,190
likeliness didn't really trust the to

00:21:44,000 --> 00:21:49,280
change at that time and we're really

00:21:46,190 --> 00:21:51,650
afraid of getting new bugs or yeah

00:21:49,280 --> 00:21:54,020
creating new bugs with LTO that will be

00:21:51,650 --> 00:21:55,010
difficult to investigate that may be

00:21:54,020 --> 00:21:59,620
worth trying again

00:21:55,010 --> 00:22:02,270
or another possibility is to use Clank

00:21:59,620 --> 00:22:07,820
better so in the one of the slides

00:22:02,270 --> 00:22:10,280
forward you could also use if you really

00:22:07,820 --> 00:22:12,980
have a very small system one of the ways

00:22:10,280 --> 00:22:16,070
to go is to use kernel xip execution in

00:22:12,980 --> 00:22:18,410
place in which case you keep the kernel

00:22:16,070 --> 00:22:20,060
text in flash so you execute kernel from

00:22:18,410 --> 00:22:23,390
flash directly from flash you'll never

00:22:20,060 --> 00:22:28,130
copy it to Ram you just use RAM for data

00:22:23,390 --> 00:22:29,750
and allocated data so it works if you

00:22:28,130 --> 00:22:34,520
have no flash of course that's

00:22:29,750 --> 00:22:36,800
accessible as if it was Ram and yes

00:22:34,520 --> 00:22:38,690
that's the only solution if you have

00:22:36,800 --> 00:22:41,690
very little ram like cortex and

00:22:38,690 --> 00:22:43,100
brilliant something like that an arm is

00:22:41,690 --> 00:22:47,320
apparently the only platform supporting

00:22:43,100 --> 00:22:50,169
it though there were some efforts on x86

00:22:47,320 --> 00:22:55,149
but they are not mainline yet

00:22:50,169 --> 00:22:59,580
I saw that actually used it was a long

00:22:55,149 --> 00:22:59,580
time ago so is anybody still using that

00:23:02,940 --> 00:23:06,399
okay but it's not in the mainline kernel

00:23:05,649 --> 00:23:13,169
yet right

00:23:06,399 --> 00:23:13,169
is it okay Rob

00:23:28,340 --> 00:23:31,340
so the question is can you me your

00:23:30,170 --> 00:23:34,970
amulet flash on a

00:23:31,340 --> 00:23:40,430
qmu to to user xip with qm you to like

00:23:34,970 --> 00:23:42,410
to developers to play with that we had a

00:23:40,430 --> 00:23:42,950
patch like ten years back but didn't get

00:23:42,410 --> 00:23:45,230
accepted

00:23:42,950 --> 00:23:48,370
unfortunately i would be awesome to have

00:23:45,230 --> 00:23:48,370
like nor flash on cue

00:23:53,550 --> 00:23:59,160
if you still want to help with kernel

00:23:55,530 --> 00:24:02,280
magnification and add a few more kernel

00:23:59,160 --> 00:24:03,950
configuration options you can there are

00:24:02,280 --> 00:24:08,040
several things you can do is look for

00:24:03,950 --> 00:24:09,980
simply simply object - my statements in

00:24:08,040 --> 00:24:11,970
kernel make files and you can see that

00:24:09,980 --> 00:24:14,580
you can see some opportunities for

00:24:11,970 --> 00:24:16,520
simplification like here the really you

00:24:14,580 --> 00:24:19,440
really need P try support all the time

00:24:16,520 --> 00:24:21,660
which takes 14 K on arm if you take the

00:24:19,440 --> 00:24:25,320
size of the dot o files or without

00:24:21,660 --> 00:24:28,410
reboot support that will be fun you may

00:24:25,320 --> 00:24:33,720
not need to reboot because it's Linux so

00:24:28,410 --> 00:24:37,740
why would you reboot oh there's a way of

00:24:33,720 --> 00:24:39,210
rebooting anyway yes exactly

00:24:37,740 --> 00:24:40,530
another way is to look at the compiled

00:24:39,210 --> 00:24:42,210
logs I'm sure you do that all the time

00:24:40,530 --> 00:24:44,160
because it takes time to compile Linux

00:24:42,210 --> 00:24:47,610
and you can just see why am i compiling

00:24:44,160 --> 00:24:49,320
that stuff so then you can wonder

00:24:47,610 --> 00:24:51,630
whether it's really useful in your case

00:24:49,320 --> 00:24:53,700
or not and whether it could how

00:24:51,630 --> 00:24:57,000
difficult it could be to remove it from

00:24:53,700 --> 00:24:59,580
from the kernel build process other

00:24:57,000 --> 00:25:02,790
thing you can do and so I'm coating some

00:24:59,580 --> 00:25:04,890
parts of the kernel wiki for

00:25:02,790 --> 00:25:07,290
technification you could just use nm-

00:25:04,890 --> 00:25:11,670
size sort in via linux and you'll see

00:25:07,290 --> 00:25:14,250
the biggest symbols that we so it's like

00:25:11,670 --> 00:25:16,590
the whole low-hanging fruit the easiest

00:25:14,250 --> 00:25:20,070
way is the the ones that would save most

00:25:16,590 --> 00:25:21,840
if you remove them you can also also use

00:25:20,070 --> 00:25:24,240
the bloat ohmmeter from a Mac nickel

00:25:21,840 --> 00:25:30,000
they're still available in scripts that

00:25:24,240 --> 00:25:33,030
compares to VM Linux files so they are

00:25:30,000 --> 00:25:35,520
fairly easy and it tells you which it

00:25:33,030 --> 00:25:37,830
can detect size regressions functions

00:25:35,520 --> 00:25:40,610
that have increased in size compared to

00:25:37,830 --> 00:25:40,610
the previous versions

00:25:42,550 --> 00:25:47,950
there's the LLVM linux project we which

00:25:46,300 --> 00:25:50,350
is trying to use clang to compile the

00:25:47,950 --> 00:25:53,410
next kernel and effectively opens the

00:25:50,350 --> 00:25:57,070
door to nice performance and size of

00:25:53,410 --> 00:25:59,460
optimizations and probably better than

00:25:57,070 --> 00:26:01,690
what GCC LTO could could achieve

00:25:59,460 --> 00:26:03,610
unfortunately the project doesn't look

00:26:01,690 --> 00:26:06,460
very active I mean from the website at

00:26:03,610 --> 00:26:10,300
least it does seem stalled any any more

00:26:06,460 --> 00:26:13,440
than that we had all right

00:26:10,300 --> 00:26:13,440
okay busy with other things

00:26:17,400 --> 00:26:26,010
[Music]

00:26:19,520 --> 00:26:40,980
awesome so quickly I find the references

00:26:26,010 --> 00:26:42,659
okay okay okay I've done donut I'll ask

00:26:40,980 --> 00:26:46,220
you actually I'll send them in to you I

00:26:42,659 --> 00:26:46,220
get the address I added to the slides

00:26:52,400 --> 00:27:02,400
thanks burnout nice

00:26:54,990 --> 00:27:04,230
so there's progress good now I'm moving

00:27:02,400 --> 00:27:07,860
to user space and things you can do to

00:27:04,230 --> 00:27:11,659
reduce size so I compared busy box and

00:27:07,860 --> 00:27:14,130
toy box and I'm glad that Rob is here so

00:27:11,659 --> 00:27:18,360
yeah so feel free to interrupt and and

00:27:14,130 --> 00:27:20,760
and and add more explanations if needed

00:27:18,360 --> 00:27:23,130
so I just compared like I built busy box

00:27:20,760 --> 00:27:25,679
and toy box with like this the same set

00:27:23,130 --> 00:27:27,870
of applications not necessarily the same

00:27:25,679 --> 00:27:30,409
features but more more or less I tried

00:27:27,870 --> 00:27:33,510
to to meet to have the same features so

00:27:30,409 --> 00:27:39,780
I compared busy box and toy box busy box

00:27:33,510 --> 00:27:41,669
was a hundred kilobytes and and and and

00:27:39,780 --> 00:27:45,360
toy box as you can see for the same

00:27:41,669 --> 00:27:49,559
features was 84,000 kilobyte a few

00:27:45,360 --> 00:27:55,380
thousand bytes so it's it's smaller for

00:27:49,559 --> 00:28:00,030
the same set of features as you can see

00:27:55,380 --> 00:28:06,630
and if you just want a shell toy box is

00:28:00,030 --> 00:28:09,200
going to be much better okay at least it

00:28:06,630 --> 00:28:09,200
works but

00:28:11,450 --> 00:28:14,900
Wow okay

00:28:24,680 --> 00:28:28,060
oh it can't okay

00:28:28,780 --> 00:28:35,930
yep I think I've caught a tuck took them

00:28:34,190 --> 00:28:45,890
from the pending directory I'm not sure

00:28:35,930 --> 00:28:49,550
okay that's where I took it from

00:28:45,890 --> 00:28:52,280
effectively well at least if you can try

00:28:49,550 --> 00:28:54,200
and country country beaut if you want if

00:28:52,280 --> 00:28:57,340
you just need any other solutions if you

00:28:54,200 --> 00:28:57,340
just want a small shell

00:29:09,740 --> 00:29:13,950
alright I'm just talking about just

00:29:12,390 --> 00:29:15,990
something that can run a few things like

00:29:13,950 --> 00:29:18,780
mount and start up a system without

00:29:15,990 --> 00:29:21,230
creating that doing that in C but yeah

00:29:18,780 --> 00:29:21,230
for okay

00:29:28,020 --> 00:29:33,309
Thanks

00:29:29,890 --> 00:29:35,290
so from what I've won from toy box it

00:29:33,309 --> 00:29:37,960
wins if your goal is to reduce size and

00:29:35,290 --> 00:29:41,110
have a tiny rooted fest it's apparently

00:29:37,960 --> 00:29:42,670
better than busy box for very small root

00:29:41,110 --> 00:29:45,220
file system that just loads a few

00:29:42,670 --> 00:29:48,059
modules and mounts proc and and a few

00:29:45,220 --> 00:29:49,179
things like that so it's sufficient

00:29:48,059 --> 00:29:50,799
busybox

00:29:49,179 --> 00:29:53,080
would win in terms of configurability

00:29:50,799 --> 00:29:55,299
like if you for the moment at least if

00:29:53,080 --> 00:29:57,610
you want to add like color support in LS

00:29:55,299 --> 00:30:00,910
and things like that or a few things in

00:29:57,610 --> 00:30:03,220
some applications if you have more

00:30:00,910 --> 00:30:09,370
elaborate needs but it's going to be

00:30:03,220 --> 00:30:13,000
bigger i made some tests with various c

00:30:09,370 --> 00:30:14,559
libraries so I used busybox as an

00:30:13,000 --> 00:30:16,840
example of a program that you can

00:30:14,559 --> 00:30:19,360
compile it's not really a typical

00:30:16,840 --> 00:30:21,040
program but that's one up to compile

00:30:19,360 --> 00:30:24,940
that the programs that you may compile

00:30:21,040 --> 00:30:28,080
so busybox if you compile it with the

00:30:24,940 --> 00:30:29,650
muscle library it's with the same

00:30:28,080 --> 00:30:32,410
statically with the same configuration

00:30:29,650 --> 00:30:39,100
as before like supporting 16 commands

00:30:32,410 --> 00:30:44,169
it's it's 183 thousand bytes with you

00:30:39,100 --> 00:30:47,679
see lips Eng it's 210 thousand bytes so

00:30:44,169 --> 00:30:51,010
it's more like you say like three

00:30:47,679 --> 00:30:52,929
hundred but thirty thousand bytes and if

00:30:51,010 --> 00:30:56,080
you compile of course with GCC against G

00:30:52,929 --> 00:30:58,299
Lipsy it's gonna be like seven hundred

00:30:56,080 --> 00:31:00,460
fifty-five thousand bytes so it's much

00:30:58,299 --> 00:31:02,470
bigger of course but that's expected so

00:31:00,460 --> 00:31:04,960
we are if you're still using is you see

00:31:02,470 --> 00:31:10,870
Lipsy you should really give a muscle a

00:31:04,960 --> 00:31:13,240
try because it's it's nice I also just

00:31:10,870 --> 00:31:16,120
just as I was doing that I also compared

00:31:13,240 --> 00:31:17,919
the dynamic executable size which should

00:31:16,120 --> 00:31:20,740
be the almost the same on the old cases

00:31:17,919 --> 00:31:22,720
versus muscle you see the PNG and Angie

00:31:20,740 --> 00:31:27,190
deep sea but it turns out that GCC is a

00:31:22,720 --> 00:31:31,120
little bigger than then muscle and you

00:31:27,190 --> 00:31:32,470
see deep sea can be and if you're

00:31:31,120 --> 00:31:34,630
looking at the hello let's see program

00:31:32,470 --> 00:31:36,730
with recent compilers that's that's

00:31:34,630 --> 00:31:38,320
again there's nothing very new in that

00:31:36,730 --> 00:31:41,299
which is just to give you an update and

00:31:38,320 --> 00:31:43,429
what you can achieve today is do

00:31:41,299 --> 00:31:46,549
see when the six the three it's seven

00:31:43,429 --> 00:31:48,950
thousand three hundred bytes for muscle

00:31:46,549 --> 00:31:50,289
so it's very very small executive all

00:31:48,950 --> 00:31:53,149
with of course you can do much better

00:31:50,289 --> 00:31:55,700
like you can have a like hello program

00:31:53,149 --> 00:31:56,419
in like as little as like 60 bytes or

00:31:55,700 --> 00:32:01,220
something like that

00:31:56,419 --> 00:32:04,580
if you do a lot of manual tweaking with

00:32:01,220 --> 00:32:08,059
GCC same GCC with you see lips E and G

00:32:04,580 --> 00:32:14,509
it's going to be seventy sixty seven

00:32:08,059 --> 00:32:17,419
thousand bytes so much bigger and it's

00:32:14,509 --> 00:32:20,090
almost five hundred kilo we five hundred

00:32:17,419 --> 00:32:21,970
kilobytes with with GDP I compiled

00:32:20,090 --> 00:32:25,789
statically so it's going to be very big

00:32:21,970 --> 00:32:29,419
so for small executables a mess well is

00:32:25,789 --> 00:32:33,350
also a clear winner here are people

00:32:29,419 --> 00:32:36,769
using a muscle in their products or more

00:32:33,350 --> 00:32:42,700
Rawal utility any maturity problems with

00:32:36,769 --> 00:32:42,700
not soul yes

00:32:44,549 --> 00:32:47,149
nice

00:32:57,029 --> 00:32:59,689
okay

00:33:14,010 --> 00:33:16,970
honest things

00:33:20,070 --> 00:33:22,640
yeah

00:33:30,690 --> 00:33:34,859
alright thanks I I was using a cross

00:33:32,940 --> 00:33:38,359
tool ng to build the tool chain but it's

00:33:34,859 --> 00:33:38,359
nice to have another solution as well

00:33:38,539 --> 00:33:44,399
and they're still the old the super

00:33:41,820 --> 00:33:47,279
strip that still exists you can get it

00:33:44,399 --> 00:33:49,919
and compile it very easily it's just an

00:33:47,279 --> 00:33:52,470
executable that's eliminates a few

00:33:49,919 --> 00:33:56,789
health sections that are not needed at

00:33:52,470 --> 00:33:58,710
runtime and you just save a few hundreds

00:33:56,789 --> 00:34:01,559
of thousands a year thousands of

00:33:58,710 --> 00:34:04,019
kilobytes it's not much but every every

00:34:01,559 --> 00:34:06,869
byte can count and the nice thing about

00:34:04,019 --> 00:34:08,789
the earth trip is that it's a it's

00:34:06,869 --> 00:34:11,789
platform independent unlike Strip which

00:34:08,789 --> 00:34:13,649
is really for our more x86 or other

00:34:11,789 --> 00:34:16,619
platforms i-strip is platform

00:34:13,649 --> 00:34:18,179
independent you can run it as it like

00:34:16,619 --> 00:34:20,849
compile it and run it you don't need to

00:34:18,179 --> 00:34:25,770
be you only don't need it to be part of

00:34:20,849 --> 00:34:27,480
your tool chain you have like all those

00:34:25,770 --> 00:34:29,129
all the C libraries which haven't been

00:34:27,480 --> 00:34:33,809
updated for a while so let's assume they

00:34:29,129 --> 00:34:36,149
are completely stalled I also looked at

00:34:33,809 --> 00:34:38,010
optimizing libraries on the target and

00:34:36,149 --> 00:34:39,809
target file system you could use

00:34:38,010 --> 00:34:41,720
something that's called MK lips that's

00:34:39,809 --> 00:34:44,399
provided by distributions but this

00:34:41,720 --> 00:34:46,710
there's no magic in it it's just copying

00:34:44,399 --> 00:34:49,319
the libraries that are needed for a set

00:34:46,710 --> 00:34:53,579
of executables and that's that's

00:34:49,319 --> 00:34:55,919
something I assumed the building tools

00:34:53,579 --> 00:34:58,529
like built route or Yocto project to

00:34:55,919 --> 00:35:01,650
already take care of like not just

00:34:58,529 --> 00:35:04,349
compiling just copying the dot iso files

00:35:01,650 --> 00:35:06,240
that are needed for each system so this

00:35:04,349 --> 00:35:07,380
there's nothing it's not very

00:35:06,240 --> 00:35:10,740
interesting and that's something you can

00:35:07,380 --> 00:35:13,410
do manually as well what I'm looking for

00:35:10,740 --> 00:35:15,539
is something like the library optimizer

00:35:13,410 --> 00:35:19,289
from Monte Vista which is still

00:35:15,539 --> 00:35:21,119
available on SourceForge which actually

00:35:19,289 --> 00:35:23,369
looks at the executive balls that you

00:35:21,119 --> 00:35:25,380
have in your system and looks at what

00:35:23,369 --> 00:35:28,770
parts of the shared libraries it uses

00:35:25,380 --> 00:35:30,210
and then tries to optimize the libraries

00:35:28,770 --> 00:35:32,760
to remove the symbols that are not in

00:35:30,210 --> 00:35:34,559
use in your programs though I didn't

00:35:32,760 --> 00:35:36,299
have time to investigate that it is

00:35:34,559 --> 00:35:39,839
anyone using that approach to reduce

00:35:36,299 --> 00:35:41,970
size another way of course is to have a

00:35:39,839 --> 00:35:43,470
big static executable that just contains

00:35:41,970 --> 00:35:44,230
the the parts of the libraries that you

00:35:43,470 --> 00:35:46,060
need if you

00:35:44,230 --> 00:35:48,280
just need one executable in your system

00:35:46,060 --> 00:35:51,400
as your main application you get that as

00:35:48,280 --> 00:35:53,440
well for free but if your system is a

00:35:51,400 --> 00:35:54,910
bit more elaborate yeah like you have

00:35:53,440 --> 00:35:56,230
multiple programs you need shared

00:35:54,910 --> 00:36:00,630
libraries and therefore you might want

00:35:56,230 --> 00:36:00,630
to to reduce the size of libraries to

00:36:01,109 --> 00:36:05,980
achieve a small file system size the

00:36:04,540 --> 00:36:08,470
best solution of course is to boot on an

00:36:05,980 --> 00:36:10,930
instrument s because you would earlier

00:36:08,470 --> 00:36:12,580
you don't have to initialize a file

00:36:10,930 --> 00:36:14,470
system and storage driver your kernel

00:36:12,580 --> 00:36:18,640
doesn't need to have one so you

00:36:14,470 --> 00:36:23,080
immediately boot programs on on the file

00:36:18,640 --> 00:36:26,140
cache so that's very fast you can use a

00:36:23,080 --> 00:36:28,119
static single executable so no no

00:36:26,140 --> 00:36:29,290
libraries to share and you just include

00:36:28,119 --> 00:36:31,420
the parts of the libraries that you need

00:36:29,290 --> 00:36:33,940
and you have a bit if you have a bigger

00:36:31,420 --> 00:36:35,980
size of course you can use regular file

00:36:33,940 --> 00:36:37,990
systems compressing file systems such as

00:36:35,980 --> 00:36:39,520
squash infest if you have black block

00:36:37,990 --> 00:36:44,950
storage but we're talking about much

00:36:39,520 --> 00:36:47,530
bigger stuff Jeff fs2 for flash also if

00:36:44,950 --> 00:36:49,440
you have a small partitions ubi is going

00:36:47,530 --> 00:36:52,480
to be is going to have too much overhead

00:36:49,440 --> 00:36:56,350
so you can still you should stick to GFS

00:36:52,480 --> 00:36:58,090
- and then you could also use fancy

00:36:56,350 --> 00:37:00,130
block file systems on top of that ROM

00:36:58,090 --> 00:37:03,190
which is a compressed block device and

00:37:00,130 --> 00:37:06,820
Ram so you might you might use that as

00:37:03,190 --> 00:37:09,790
well but if you have if you have a tiny

00:37:06,820 --> 00:37:13,510
amount of RAM it's you won't use that

00:37:09,790 --> 00:37:16,510
but as a floor system that needs to

00:37:13,510 --> 00:37:18,430
optimize Ram and still has enough RAM

00:37:16,510 --> 00:37:23,260
budget that might be worth it to to use

00:37:18,430 --> 00:37:26,640
this some conclusions before we we can

00:37:23,260 --> 00:37:29,560
go into questions so there hasn't been

00:37:26,640 --> 00:37:31,930
apparently recent mining efforts but the

00:37:29,560 --> 00:37:35,770
kernel size is still decent if you use

00:37:31,930 --> 00:37:39,520
make tiny config and you can boot it

00:37:35,770 --> 00:37:43,790
easily on the system with less that with

00:37:39,520 --> 00:37:46,070
four Meg's of RAM at least so that's

00:37:43,790 --> 00:37:48,890
yep that's what you can achieve at least

00:37:46,070 --> 00:37:53,900
one arm it will be very effective ly to

00:37:48,890 --> 00:37:57,460
try on x86 64 on the intel board for

00:37:53,900 --> 00:38:00,950
compilers you can use clam or GCC LTO

00:37:57,460 --> 00:38:03,910
hopefully for the kernel as well this

00:38:00,950 --> 00:38:07,130
new library worth using which is muscle

00:38:03,910 --> 00:38:09,260
it's also worth giving toybox a try if

00:38:07,130 --> 00:38:10,640
your city if you like essentially you

00:38:09,260 --> 00:38:12,350
don't have like much scripts in your

00:38:10,640 --> 00:38:16,910
system and you just like run a few

00:38:12,350 --> 00:38:19,790
commands type box is going to help in

00:38:16,910 --> 00:38:21,530
reducing the size and as we can see

00:38:19,790 --> 00:38:23,570
there's a still significant room from

00:38:21,530 --> 00:38:26,780
improvement in user space and kernel

00:38:23,570 --> 00:38:29,510
space I'm mostly talking about kernel

00:38:26,780 --> 00:38:31,790
space here the question is can we add

00:38:29,510 --> 00:38:34,400
some more configuration settings to the

00:38:31,790 --> 00:38:37,400
kernel to to make other things removable

00:38:34,400 --> 00:38:39,500
it's going to add to the complexity that

00:38:37,400 --> 00:38:40,970
the kernel developers face so are they

00:38:39,500 --> 00:38:45,920
going to AK they are going to accept

00:38:40,970 --> 00:38:48,820
that that's the open question now I

00:38:45,920 --> 00:38:51,859
propose to move to a kind of buff part

00:38:48,820 --> 00:38:54,740
any recent achievements that didn't

00:38:51,859 --> 00:39:00,590
didn't mention so we are not thanks for

00:38:54,740 --> 00:39:04,300
the LLVM porting effort that's one thing

00:39:00,590 --> 00:39:07,910
I added to the to the report any

00:39:04,300 --> 00:39:10,369
anything any people to I should have

00:39:07,910 --> 00:39:12,760
seen something on this area progressing

00:39:10,369 --> 00:39:12,760
yes Rob

00:39:30,890 --> 00:39:32,920
Oh

00:39:45,670 --> 00:39:48,450
hmm

00:39:58,030 --> 00:40:00,660
Wow

00:40:04,920 --> 00:40:12,499
so was that for 314 he said it wasn't 14

00:40:10,170 --> 00:40:12,499
okay

00:40:21,099 --> 00:40:27,970
rob was mentioning some some some

00:40:24,500 --> 00:40:33,800
patches to to improve temper FS support

00:40:27,970 --> 00:40:38,920
back in 3000 oh sorry no 2013 so I'll

00:40:33,800 --> 00:40:38,920
try to add a reference to it thanks yes

00:40:42,340 --> 00:40:46,790
right okay

00:40:43,940 --> 00:40:52,780
like micro Yocto with that was that

00:40:46,790 --> 00:40:52,780
micro Yocto or something like this okay

00:41:00,040 --> 00:41:02,790
oh yeah

00:41:11,049 --> 00:41:21,039
is there in your resources you're using

00:41:14,140 --> 00:41:23,470
that I'd mention and then the most

00:41:21,039 --> 00:41:25,510
important question perhaps is like what

00:41:23,470 --> 00:41:30,190
community friendly hardware we could use

00:41:25,510 --> 00:41:33,849
to run ten the next tiny it makes tiny

00:41:30,190 --> 00:41:36,640
tiny fide projects so that we we can

00:41:33,849 --> 00:41:38,109
convert we have like more better reasons

00:41:36,640 --> 00:41:41,200
for convincing the kernel developers

00:41:38,109 --> 00:41:42,609
tool to integrate code if we support

00:41:41,200 --> 00:41:45,760
real hardware it's going to be better

00:41:42,609 --> 00:41:48,160
than just qmu so any any suggestions for

00:41:45,760 --> 00:41:50,309
a nice community friendly board we could

00:41:48,160 --> 00:41:50,309
use for

00:42:10,319 --> 00:42:13,910
but it has too much ROM right

00:42:15,930 --> 00:42:53,880
you all right said hey can't you go to

00:42:52,230 --> 00:42:57,329
for make supply so you know we already

00:42:53,880 --> 00:42:59,869
bought parts so you have nervous

00:42:57,329 --> 00:43:03,930
solution that's that's nice officially

00:42:59,869 --> 00:43:09,770
any other solutions for I mean target

00:43:03,930 --> 00:43:09,770
Hardware yep I should

00:43:17,460 --> 00:43:24,589
oh yeah

00:43:26,640 --> 00:43:29,640
yeah

00:43:31,230 --> 00:43:36,630
hmm that's probably okay

00:43:40,890 --> 00:43:46,650
any anything else what do you think

00:43:43,170 --> 00:43:50,700
about the Econoline you think Asian

00:43:46,650 --> 00:43:52,470
effort is there I'm not sure we have the

00:43:50,700 --> 00:43:55,110
the right kind of developers in the room

00:43:52,470 --> 00:43:58,500
to to discuss that but what do you guys

00:43:55,110 --> 00:44:01,470
think about the kernel technification

00:43:58,500 --> 00:44:05,870
occasion Pro project should we continue

00:44:01,470 --> 00:44:05,870
and revive the patches from Josh

00:44:14,770 --> 00:44:19,270
I could help a little bit like taking

00:44:16,870 --> 00:44:21,130
one patch and pushing it from time to

00:44:19,270 --> 00:44:25,150
time is okay doesn't take that much time

00:44:21,130 --> 00:44:27,610
is it worth it you gettin either good

00:44:25,150 --> 00:44:51,250
arguments for providing someplace cute

00:44:27,610 --> 00:44:53,020
complexity to the kernel though we're

00:44:51,250 --> 00:44:55,600
glad that this work has been done for

00:44:53,020 --> 00:44:59,470
the Stannah fication work has been done

00:44:55,600 --> 00:45:02,400
because it's useful for us so I guess we

00:44:59,470 --> 00:45:02,400
should continue in some way

00:45:06,540 --> 00:45:13,730
for you mean RAM usage or flashlight

00:45:17,150 --> 00:45:28,790
yeah yeah go ahead yep my yep

00:45:55,770 --> 00:45:59,460
sooo Rob says that using less fryer

00:45:57,780 --> 00:46:01,860
means some more better cache efficiency

00:45:59,460 --> 00:46:06,770
and things like that so it's worth it to

00:46:01,860 --> 00:46:06,770
have more or less code fixity

00:46:09,230 --> 00:46:12,040
oh yeah

00:46:18,920 --> 00:46:23,569
one of the major problems there

00:46:21,069 --> 00:46:27,099
notification projects concentrate a lot

00:46:23,569 --> 00:46:34,039
of removing things that just aren't

00:46:27,099 --> 00:46:36,609
right unless you have a dedicated

00:46:34,039 --> 00:46:36,609
instance

00:47:01,410 --> 00:47:05,130
yeah I think the good thing is that

00:47:03,059 --> 00:47:06,779
Linux is a general-purpose system you

00:47:05,130 --> 00:47:08,609
you never know what users are going to

00:47:06,779 --> 00:47:09,779
do so let's give them more options

00:47:08,609 --> 00:47:14,819
that's what I believe

00:47:09,779 --> 00:47:17,400
as leanness said so a few references

00:47:14,819 --> 00:47:18,930
here that's worth reading if you it's

00:47:17,400 --> 00:47:22,819
more for people reading the slides and

00:47:18,930 --> 00:47:26,130
wanting to know more about this like

00:47:22,819 --> 00:47:28,259
like for example there's the document

00:47:26,130 --> 00:47:32,999
from Tim bird it's it's quite old but

00:47:28,259 --> 00:47:37,589
shows some efforts to like to look for

00:47:32,999 --> 00:47:40,109
I mean analyzing the the kernel usage

00:47:37,589 --> 00:47:43,499
and trying to eliminate things that are

00:47:40,109 --> 00:47:46,470
not used at runtime stuff like that and

00:47:43,499 --> 00:47:49,289
some of some presentations from recent

00:47:46,470 --> 00:47:52,559
conferences recently enough conferences

00:47:49,289 --> 00:47:55,619
given the history of ELC especially the

00:47:52,559 --> 00:47:59,279
work of Vitali bull effectively booting

00:47:55,619 --> 00:48:02,150
Linux on stm32 systems with quite

00:47:59,279 --> 00:48:04,440
aggressive solutions for reducing size

00:48:02,150 --> 00:48:06,599
so you can get some ideas if you want to

00:48:04,440 --> 00:48:08,989
contribute there those presentations are

00:48:06,599 --> 00:48:13,650
full of ideas that will be worth

00:48:08,989 --> 00:48:14,940
exploring and upstreaming if possible at

00:48:13,650 --> 00:48:17,670
least you can discuss that with the

00:48:14,940 --> 00:48:20,219
community and see what what what

00:48:17,670 --> 00:48:22,999
response you get whether it's whether to

00:48:20,219 --> 00:48:22,999
have it main line or not

00:48:24,630 --> 00:48:28,819
during this week you have other talks

00:48:26,460 --> 00:48:33,239
that that if you're interested in size

00:48:28,819 --> 00:48:34,920
there's a tutorial from Rob today about

00:48:33,239 --> 00:48:37,079
building the simple as possible the next

00:48:34,920 --> 00:48:39,440
system so you understand how how simple

00:48:37,079 --> 00:48:44,160
system can be and Rob is one of the best

00:48:39,440 --> 00:48:46,890
to make simple things there's also the

00:48:44,160 --> 00:48:50,519
talk about optimizing C for micron

00:48:46,890 --> 00:48:53,460
controls from Kamaraj it's more on the

00:48:50,519 --> 00:48:56,219
IOT track but it's interesting too and

00:48:53,460 --> 00:48:59,519
also g cg clank optimizations for

00:48:56,219 --> 00:49:04,640
embedded linux on thursday which could

00:48:59,519 --> 00:49:04,640
be interesting as well any questions

00:49:04,850 --> 00:49:16,320
ooh right in time thank you

00:49:12,190 --> 00:49:16,320

YouTube URL: https://www.youtube.com/watch?v=ynNLlzOElOU


