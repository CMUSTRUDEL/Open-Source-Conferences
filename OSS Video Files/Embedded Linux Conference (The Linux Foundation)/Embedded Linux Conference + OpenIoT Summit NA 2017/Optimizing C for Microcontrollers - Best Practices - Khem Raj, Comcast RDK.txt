Title: Optimizing C for Microcontrollers - Best Practices - Khem Raj, Comcast RDK
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Optimizing C for Microcontrollers - Best Practices - Khem Raj, Comcast RDK

This talk will cover the tips and techniques to write best possible C programs for microcontrollers. It will use Zephyr as usecase and demonstrate the size and performance optimizations and tradeoffs. Besides C language itself, it will also present how to squeeze benefits out of GCC for microcontrolles and RTOSes like Zephyr

About Khem Raj
Working on deploying Yocto Project/OpenEmbedded into Comcast's community Reference Design Kit for STB, Gateway and IoT platforms. Working on designing optimal open source software development and contribution procedures. Previously worked at Juniper where he was responsible to creating and maintaining Linux base operating system for upcoming Junos( Juniper's Network Operating System) again it was based on Yocto project. He is a contributor and maintainer for pieces in OpenEmbedded and Yocto Project. Last he spoke at ELCE Berlin in 2016.
Captions: 
	00:00:00,170 --> 00:00:08,550
all right thanks for coming my name is

00:00:04,620 --> 00:00:11,340
Kim Raj I work for Comcast on the RDK

00:00:08,550 --> 00:00:14,340
project which is the reference design

00:00:11,340 --> 00:00:16,920
kit it's a very innovative name which is

00:00:14,340 --> 00:00:24,689
basically our setup box operating system

00:00:16,920 --> 00:00:26,699
which is based on Linux part of my work

00:00:24,689 --> 00:00:30,210
involves working with embedded Linux but

00:00:26,699 --> 00:00:33,329
then it's also extending to other

00:00:30,210 --> 00:00:36,899
smaller devices like security cameras

00:00:33,329 --> 00:00:42,809
and sensors and stuff that goes in your

00:00:36,899 --> 00:00:45,120
home for security or otherwise and so

00:00:42,809 --> 00:00:52,110
today what we are going to talk here is

00:00:45,120 --> 00:00:55,620
about some of the C language constructs

00:00:52,110 --> 00:01:01,289
that we will read that are specific for

00:00:55,620 --> 00:01:05,549
microcontroller programming and what I'm

00:01:01,289 --> 00:01:08,970
going to cover is you know these few

00:01:05,549 --> 00:01:11,729
items so just know your tools very

00:01:08,970 --> 00:01:14,310
important because there are several tool

00:01:11,729 --> 00:01:18,030
chains different compilers other tools

00:01:14,310 --> 00:01:19,680
that we use and they all behave

00:01:18,030 --> 00:01:24,210
differently so it's very important to

00:01:19,680 --> 00:01:27,689
know them data types and sizes you know

00:01:24,210 --> 00:01:32,670
more on embedded systems generally when

00:01:27,689 --> 00:01:35,310
you have general-purpose chips you know

00:01:32,670 --> 00:01:38,159
the the length the process of word

00:01:35,310 --> 00:01:40,860
lengths are known but in microcontroller

00:01:38,159 --> 00:01:45,479
there are 8-bit 16-bit 32-bit you need

00:01:40,860 --> 00:01:48,180
to know which one it is and then how

00:01:45,479 --> 00:01:50,610
variables and function types can help

00:01:48,180 --> 00:01:53,430
and then what can you do in loops and

00:01:50,610 --> 00:01:55,950
then assembly we talked about assembly

00:01:53,430 --> 00:01:57,630
it's contentious many times it depends

00:01:55,950 --> 00:02:02,610
what you're doing which compiler you are

00:01:57,630 --> 00:02:04,530
using and then some thoughts on Ram

00:02:02,610 --> 00:02:06,240
optimizations and then in summary what

00:02:04,530 --> 00:02:10,619
you can do keep in mind when you're

00:02:06,240 --> 00:02:13,569
programming for microcontrollers so it's

00:02:10,619 --> 00:02:15,370
a open session feel free you know I

00:02:13,569 --> 00:02:17,349
to present something that's wrong or you

00:02:15,370 --> 00:02:19,989
feel that can be done better I'll be

00:02:17,349 --> 00:02:24,760
very happy to discuss it further so feel

00:02:19,989 --> 00:02:28,450
free to jump in anytime you know with

00:02:24,760 --> 00:02:30,370
your experiences I love to here what

00:02:28,450 --> 00:02:34,959
I've done is I've taken Zephyr

00:02:30,370 --> 00:02:38,379
as a sample here and I'm going to cover

00:02:34,959 --> 00:02:40,569
the GNU Compiler mainly so you know

00:02:38,379 --> 00:02:43,359
there are other vendors and other

00:02:40,569 --> 00:02:45,819
compilers which might offer more options

00:02:43,359 --> 00:02:50,579
I'm not going to cover that here as much

00:02:45,819 --> 00:02:54,819
so it's primarily around these two

00:02:50,579 --> 00:02:57,159
projects so knowing your tool chains as

00:02:54,819 --> 00:02:59,919
I was saying many vendors there is a

00:02:57,159 --> 00:03:04,750
glue compiler and then you know I our

00:02:59,919 --> 00:03:07,329
system mom there are many and each

00:03:04,750 --> 00:03:10,569
compiler over there they have either

00:03:07,329 --> 00:03:15,750
added new features that are not in

00:03:10,569 --> 00:03:19,540
standard or they have certain additional

00:03:15,750 --> 00:03:22,720
options that are very fitting for you

00:03:19,540 --> 00:03:25,870
know the target microcontroller they are

00:03:22,720 --> 00:03:30,030
targeting and they may so you have to

00:03:25,870 --> 00:03:32,379
know what tools you have at hand and

00:03:30,030 --> 00:03:34,419
it's very important that you go through

00:03:32,379 --> 00:03:36,310
the whole documentation how they do

00:03:34,419 --> 00:03:39,629
prevent file pointers how they represent

00:03:36,310 --> 00:03:44,709
near pointers you know they may differ

00:03:39,629 --> 00:03:46,919
so if you are in for writing more

00:03:44,709 --> 00:03:49,359
portable code it's very important that

00:03:46,919 --> 00:03:53,500
you can either find alternatives to

00:03:49,359 --> 00:03:55,689
those or you can use them minutes in

00:03:53,500 --> 00:03:59,290
such a way that you can disable those

00:03:55,689 --> 00:04:04,000
features or have them as no-ops when you

00:03:59,290 --> 00:04:10,930
are really not using you know those

00:04:04,000 --> 00:04:15,129
compilers or those tools compiler

00:04:10,930 --> 00:04:20,620
switches so what I've seen here is I've

00:04:15,129 --> 00:04:23,340
given you a simple table what I did is I

00:04:20,620 --> 00:04:27,400
took the first hello world application

00:04:23,340 --> 00:04:32,380
and I compiled it with different of

00:04:27,400 --> 00:04:35,949
nation levels and OS definitely you know

00:04:32,380 --> 00:04:40,810
meant for size optimization so it it

00:04:35,949 --> 00:04:44,860
basically so keep in mind that this is

00:04:40,810 --> 00:04:48,790
GCC in in purview other compilers might

00:04:44,860 --> 00:04:52,710
have different you know naming

00:04:48,790 --> 00:04:56,260
conventions for these - all options so

00:04:52,710 --> 00:04:59,290
as you can see with code performance if

00:04:56,260 --> 00:05:02,500
you are really looking at help from GCC

00:04:59,290 --> 00:05:06,880
to optimize your code Mac series o - and

00:05:02,500 --> 00:05:10,570
O 3 or - or fast so what happens is as

00:05:06,880 --> 00:05:13,949
you keep increasing your o level you

00:05:10,570 --> 00:05:16,150
know it starts getting a little bit more

00:05:13,949 --> 00:05:18,940
inaccurate as well so you have to know

00:05:16,150 --> 00:05:21,940
when you change an optimization level

00:05:18,940 --> 00:05:24,460
whether your algorithm can sustain it so

00:05:21,940 --> 00:05:26,020
most of the time compilers you know keep

00:05:24,460 --> 00:05:28,389
in mind our tools written by other

00:05:26,020 --> 00:05:31,000
people so I'm myself I'm a compiler

00:05:28,389 --> 00:05:32,770
developer so those are applications -

00:05:31,000 --> 00:05:34,870
and you know they need help when you

00:05:32,770 --> 00:05:38,950
feed them with write kind of stuff they

00:05:34,870 --> 00:05:42,099
give you good results so now most of the

00:05:38,950 --> 00:05:44,740
time I will cover here in this talk that

00:05:42,099 --> 00:05:48,610
what can you help compiler with to get

00:05:44,740 --> 00:05:51,970
maximum out of the compiler so as you

00:05:48,610 --> 00:05:56,110
can see the code size goes up as you

00:05:51,970 --> 00:05:58,060
increase your optimization levels but if

00:05:56,110 --> 00:06:00,340
you have a real world application you

00:05:58,060 --> 00:06:04,120
would see the execution will be faster

00:06:00,340 --> 00:06:05,919
as well in some cases in some cases

00:06:04,120 --> 00:06:09,699
actually when you do optimization for

00:06:05,919 --> 00:06:13,510
size it improves your human code

00:06:09,699 --> 00:06:16,360
performance it depends upon your bus

00:06:13,510 --> 00:06:21,550
width and how you can compare how you

00:06:16,360 --> 00:06:23,949
can utilize the memory bus for example

00:06:21,550 --> 00:06:26,349
if you have like 32-bit memory bits and

00:06:23,949 --> 00:06:28,590
you have 16-bit instructions set it can

00:06:26,349 --> 00:06:31,660
improve your instruction cache usage and

00:06:28,590 --> 00:06:34,240
there are loads that when you compile

00:06:31,660 --> 00:06:38,650
say you know in 16-bit may perform

00:06:34,240 --> 00:06:42,930
better compared to 32-bit so so

00:06:38,650 --> 00:06:51,880
execution time really depends upon those

00:06:42,930 --> 00:06:54,490
kind of constraints now og is relatively

00:06:51,880 --> 00:06:56,800
a new optimization that's added what it

00:06:54,490 --> 00:06:59,200
is do is the during development for

00:06:56,800 --> 00:07:01,960
example you can use this option to get

00:06:59,200 --> 00:07:04,660
good debug view so it doesn't give you

00:07:01,960 --> 00:07:07,540
just raw translation which means you

00:07:04,660 --> 00:07:09,370
have highly an optimized code but what

00:07:07,540 --> 00:07:12,280
it does is it applies optimizations

00:07:09,370 --> 00:07:14,460
which gives you a good view of debugging

00:07:12,280 --> 00:07:16,630
so it doesn't tamper your debug view

00:07:14,460 --> 00:07:18,640
because most of the times when you

00:07:16,630 --> 00:07:21,460
enable optimizations you start debugging

00:07:18,640 --> 00:07:25,060
and you know it flips around and you

00:07:21,460 --> 00:07:26,680
don't have the logic slow and when you

00:07:25,060 --> 00:07:30,040
are stepping through the code you know

00:07:26,680 --> 00:07:32,830
you lose the context very easily so it's

00:07:30,040 --> 00:07:36,370
a good way for if your developer you

00:07:32,830 --> 00:07:38,490
want to kind of try out some debugging

00:07:36,370 --> 00:07:44,880
help and want to get good debugging

00:07:38,490 --> 00:07:44,880
experience this is a good option to try

00:07:45,390 --> 00:07:53,380
so other item in your tools portfolio is

00:07:50,670 --> 00:07:55,180
your linker script very important where

00:07:53,380 --> 00:08:01,060
you place your code in in microphone

00:07:55,180 --> 00:08:05,680
dollars so you decide how where the code

00:08:01,060 --> 00:08:09,880
goes and you need to know like GCC also

00:08:05,680 --> 00:08:13,500
has a very elaborate linker scripting

00:08:09,880 --> 00:08:18,520
language and you can really define your

00:08:13,500 --> 00:08:23,350
flash memory out outline and how it is

00:08:18,520 --> 00:08:26,970
loaded with sections goes where and you

00:08:23,350 --> 00:08:30,490
can also define symbols and other items

00:08:26,970 --> 00:08:34,510
wherever you want in your code for help

00:08:30,490 --> 00:08:38,070
during execution so if you look into new

00:08:34,510 --> 00:08:45,340
linker manual they have a very elaborate

00:08:38,070 --> 00:08:49,120
syntax for linker scripting most of the

00:08:45,340 --> 00:08:51,430
time it's you know we take a linker

00:08:49,120 --> 00:08:54,550
script and then we kind of enhance it

00:08:51,430 --> 00:08:55,160
what I found is it's very interesting

00:08:54,550 --> 00:08:57,350
and

00:08:55,160 --> 00:08:59,990
Gordon to understand all the construct

00:08:57,350 --> 00:09:02,959
that goes in and how you define your

00:08:59,990 --> 00:09:05,720
segments what are your sections and what

00:09:02,959 --> 00:09:09,170
are your alignments and how you define

00:09:05,720 --> 00:09:12,079
your total length of your data sections

00:09:09,170 --> 00:09:14,389
and where you begin them where you end

00:09:12,079 --> 00:09:19,120
them how you want to initialize them all

00:09:14,389 --> 00:09:19,120
that goes into your yeah question

00:09:28,600 --> 00:09:32,720
yeah

00:09:30,079 --> 00:09:35,899
right so I think the question is is

00:09:32,720 --> 00:09:39,670
there any recipe actually a template for

00:09:35,899 --> 00:09:45,319
writing your linker script so I think

00:09:39,670 --> 00:09:49,129
generally when you have you know it

00:09:45,319 --> 00:09:51,230
really depends on your architecture how

00:09:49,129 --> 00:09:53,569
where you are storing your code where

00:09:51,230 --> 00:09:56,899
you are executing from right so many

00:09:53,569 --> 00:09:58,519
times use your story of code in flash

00:09:56,899 --> 00:10:01,040
and then you copy it over and you

00:09:58,519 --> 00:10:03,949
execute from Ram right in many times you

00:10:01,040 --> 00:10:06,860
do execution in place right and you are

00:10:03,949 --> 00:10:08,899
executing from flash and then sometimes

00:10:06,860 --> 00:10:13,339
you have SRAM sometimes you don't have s

00:10:08,899 --> 00:10:16,160
Ram right so so what you do is you

00:10:13,339 --> 00:10:19,550
basically define your data in your flash

00:10:16,160 --> 00:10:21,500
segments accordingly and and of course

00:10:19,550 --> 00:10:23,630
alignment is very important when where

00:10:21,500 --> 00:10:27,350
you align them where your addresses are

00:10:23,630 --> 00:10:30,019
so generally your read/write data right

00:10:27,350 --> 00:10:32,529
and an initialized data is what you

00:10:30,019 --> 00:10:35,180
consider for your Flash size and then

00:10:32,529 --> 00:10:37,730
how much stacks if you want stacks

00:10:35,180 --> 00:10:42,670
elsewhere or where you want to lay your

00:10:37,730 --> 00:10:46,610
runtime Ram data all those things

00:10:42,670 --> 00:10:47,870
basically depends upon your size there

00:10:46,610 --> 00:10:52,490
is no I will say that there is a

00:10:47,870 --> 00:10:54,500
recommended way you could do it but the

00:10:52,490 --> 00:10:56,839
effort of splits is that it gives you

00:10:54,500 --> 00:11:00,740
all the tools to define your memory Maps

00:10:56,839 --> 00:11:02,629
the way you want it so it's important

00:11:00,740 --> 00:11:04,819
that you read through all the key words

00:11:02,629 --> 00:11:07,220
what is available for you how can you

00:11:04,819 --> 00:11:08,480
define a memory overlay or you know how

00:11:07,220 --> 00:11:10,790
you can define

00:11:08,480 --> 00:11:13,839
other important aspects of your

00:11:10,790 --> 00:11:19,540
scripting that you will need during

00:11:13,839 --> 00:11:24,740
execution of your programs so linker map

00:11:19,540 --> 00:11:28,430
it's it's a good tool to see the output

00:11:24,740 --> 00:11:30,589
of how you link to your application many

00:11:28,430 --> 00:11:33,560
times you know we link the application

00:11:30,589 --> 00:11:36,350
and we want to see where the whole thing

00:11:33,560 --> 00:11:40,610
is lying you know which section went

00:11:36,350 --> 00:11:44,540
where and it kind of gives you the whole

00:11:40,610 --> 00:11:46,850
view of your memory how it is all laid

00:11:44,540 --> 00:11:49,880
out very important for a small

00:11:46,850 --> 00:11:52,100
application where you are either doing

00:11:49,880 --> 00:11:52,790
some optimizations or you are looking at

00:11:52,100 --> 00:11:54,920
okay

00:11:52,790 --> 00:11:57,889
is there any dead code that got linked

00:11:54,920 --> 00:12:00,500
in or is there any code that is placed

00:11:57,889 --> 00:12:03,110
strongly for example your inner sections

00:12:00,500 --> 00:12:08,630
might be required at a certain address

00:12:03,110 --> 00:12:12,889
is it there right or you know simple

00:12:08,630 --> 00:12:15,050
things like which function is is kind of

00:12:12,889 --> 00:12:18,949
adding a lot of code into my application

00:12:15,050 --> 00:12:21,700
you're looking at optimizing for size or

00:12:18,949 --> 00:12:23,079
maybe other reasons so it's a very good

00:12:21,700 --> 00:12:26,440
[Music]

00:12:23,079 --> 00:12:30,980
you know to at that point when you

00:12:26,440 --> 00:12:32,600
create Maps during your link step they

00:12:30,980 --> 00:12:34,940
can give you a lot of insights into how

00:12:32,600 --> 00:12:37,430
you build your application and there are

00:12:34,940 --> 00:12:39,800
also post processing tools at least they

00:12:37,430 --> 00:12:42,860
work with new linker which can give you

00:12:39,800 --> 00:12:44,930
more what I've given is a dump of what

00:12:42,860 --> 00:12:47,389
linker will put at you but you should

00:12:44,930 --> 00:12:48,860
want it in a more human readable fashion

00:12:47,389 --> 00:12:52,639
there are tools which can take it and

00:12:48,860 --> 00:12:57,339
give you more you know view of this is

00:12:52,639 --> 00:13:00,199
how much memory it is using or how much

00:12:57,339 --> 00:13:02,269
where things are and so you can do all

00:13:00,199 --> 00:13:07,339
this kind of visualization there are

00:13:02,269 --> 00:13:10,760
tools like that available as well what

00:13:07,339 --> 00:13:13,550
it also giving you is what it ignored

00:13:10,760 --> 00:13:15,620
right sometimes you spend a lot of time

00:13:13,550 --> 00:13:20,990
looking at okay certain function was

00:13:15,620 --> 00:13:22,790
just thrown away by the linker so it

00:13:20,990 --> 00:13:25,130
also gives you that the

00:13:22,790 --> 00:13:27,470
okay these these functions or symbols I

00:13:25,130 --> 00:13:29,570
found are unused so I decided to throw

00:13:27,470 --> 00:13:31,010
them away all right so you get that

00:13:29,570 --> 00:13:33,020
information there very good debugging

00:13:31,010 --> 00:13:35,270
health many times you debug through to

00:13:33,020 --> 00:13:40,399
find that a certain piece of code was

00:13:35,270 --> 00:13:43,700
thrown away so a very good tool I guess

00:13:40,399 --> 00:13:46,149
you know to to really visualize how the

00:13:43,700 --> 00:13:50,060
whole application in the end is laid out

00:13:46,149 --> 00:13:53,930
and then be noodles also often offer a

00:13:50,060 --> 00:13:56,839
few tools which are very useful so ABS

00:13:53,930 --> 00:14:02,029
dump one of the features I use very

00:13:56,839 --> 00:14:05,390
often is minus D with s what it gives me

00:14:02,029 --> 00:14:08,510
is it interleaves source with assembly

00:14:05,390 --> 00:14:12,050
so it takes your final L file and then

00:14:08,510 --> 00:14:14,630
interlace your assembly code with your

00:14:12,050 --> 00:14:16,910
source code so I get a good view of what

00:14:14,630 --> 00:14:21,050
code was generated for this particular

00:14:16,910 --> 00:14:22,640
line of my C code so many times when

00:14:21,050 --> 00:14:26,060
you're looking out for various

00:14:22,640 --> 00:14:28,910
optimizations or maybe wrong code

00:14:26,060 --> 00:14:30,950
generation helps this this is very

00:14:28,910 --> 00:14:32,720
useful at that point when you can

00:14:30,950 --> 00:14:36,920
associate your assembly code to your C

00:14:32,720 --> 00:14:41,150
code and there is a size utility it

00:14:36,920 --> 00:14:43,550
gives you a size that particular

00:14:41,150 --> 00:14:46,790
application is going to take in terms of

00:14:43,550 --> 00:14:52,190
text which is your code and data and

00:14:46,790 --> 00:14:54,800
initialize uninitialized data so this is

00:14:52,190 --> 00:14:57,709
a good way like you can keep a tap on

00:14:54,800 --> 00:14:59,930
when you're adding new code you are not

00:14:57,709 --> 00:15:03,650
bloating your code so you know you can

00:14:59,930 --> 00:15:05,900
put like a watch on this value and maybe

00:15:03,650 --> 00:15:08,390
you can add it to your build system at

00:15:05,900 --> 00:15:10,190
the very end to dump the size and and

00:15:08,390 --> 00:15:12,890
then see how much size is being added

00:15:10,190 --> 00:15:15,709
when you are writing code so very

00:15:12,890 --> 00:15:19,779
important actually to regularly manage

00:15:15,709 --> 00:15:23,620
the size of your code and a few tools

00:15:19,779 --> 00:15:28,550
helps you do actually it's actually

00:15:23,620 --> 00:15:32,420
giving you some dump of your application

00:15:28,550 --> 00:15:35,060
what it shows is you can see the program

00:15:32,420 --> 00:15:35,870
header so you know it also gives you

00:15:35,060 --> 00:15:37,640
similar information

00:15:35,870 --> 00:15:40,900
like what size does but it's much more

00:15:37,640 --> 00:15:43,250
refined where it tells you you know what

00:15:40,900 --> 00:15:46,730
addresses is allocated what physical

00:15:43,250 --> 00:15:48,500
address it is located at and flags

00:15:46,730 --> 00:15:52,390
what kind of flags are allocated to it

00:15:48,500 --> 00:15:54,800
so so these are few tools that gives you

00:15:52,390 --> 00:15:57,020
some more insights into when you are

00:15:54,800 --> 00:15:59,240
developing these are part of the GNU

00:15:57,020 --> 00:16:00,620
Compiler collection as well I'm pretty

00:15:59,240 --> 00:16:03,140
sure that the tools that we'll get from

00:16:00,620 --> 00:16:05,960
other vendors also have similar tools

00:16:03,140 --> 00:16:07,760
available so you can look into

00:16:05,960 --> 00:16:13,070
equivalent to those tools or maybe there

00:16:07,760 --> 00:16:16,339
are better ones so now moving into like

00:16:13,070 --> 00:16:20,150
what are kind of things you need to keep

00:16:16,339 --> 00:16:24,440
in mind so variables you know size is

00:16:20,150 --> 00:16:28,220
important usually it's very important

00:16:24,440 --> 00:16:31,100
that you know the word that the

00:16:28,220 --> 00:16:32,930
processor word length which is if it is

00:16:31,100 --> 00:16:35,660
a 16-bit processor your integer is

00:16:32,930 --> 00:16:41,450
16-bit if it is a 32-bit processor your

00:16:35,660 --> 00:16:45,110
integer is 32-bit so usually it's a very

00:16:41,450 --> 00:16:48,320
good way to go when you use the natural

00:16:45,110 --> 00:16:51,529
world and that is your microcontrollers

00:16:48,320 --> 00:16:54,410
processor is reporting we will have few

00:16:51,529 --> 00:16:56,870
examples where we will so we will show

00:16:54,410 --> 00:17:05,510
that this is how this can kind of cause

00:16:56,870 --> 00:17:06,470
inefficiencies and Global's generally

00:17:05,510 --> 00:17:09,620
Global's

00:17:06,470 --> 00:17:11,839
they have value where you know you can

00:17:09,620 --> 00:17:15,920
access their state but they also have a

00:17:11,839 --> 00:17:18,640
cost the cost being that compiler cannot

00:17:15,920 --> 00:17:20,689
assume that they their state is

00:17:18,640 --> 00:17:24,670
available all the time so it has to

00:17:20,689 --> 00:17:27,559
always load and store them which incurs

00:17:24,670 --> 00:17:30,950
extra load stores which can get you very

00:17:27,559 --> 00:17:33,350
inefficient code so it's very important

00:17:30,950 --> 00:17:36,559
that you look at whether your function

00:17:33,350 --> 00:17:38,090
can deal with local data or you can

00:17:36,559 --> 00:17:45,420
achieve what you want to do in or other

00:17:38,090 --> 00:17:48,920
than using local data so

00:17:45,420 --> 00:17:52,590
here is a little example as you can see

00:17:48,920 --> 00:17:56,610
it's about the length that I was talking

00:17:52,590 --> 00:18:00,750
about so this example is actually from a

00:17:56,610 --> 00:18:03,240
Kotex m3 code generation and what you

00:18:00,750 --> 00:18:07,980
can see here is the new in the function

00:18:03,240 --> 00:18:10,170
I'm using a I'm passing integers to it

00:18:07,980 --> 00:18:13,410
and then similar function I am passing

00:18:10,170 --> 00:18:15,000
short integers to it so what you can see

00:18:13,410 --> 00:18:19,740
is that that's the code that's generated

00:18:15,000 --> 00:18:22,560
underneath so it's also optimizing the

00:18:19,740 --> 00:18:24,420
code for size so it's not a raw code so

00:18:22,560 --> 00:18:26,550
all the relevant optimizations are

00:18:24,420 --> 00:18:28,230
applied already but you can see that

00:18:26,550 --> 00:18:32,010
there is an extra instruction that it is

00:18:28,230 --> 00:18:35,580
generating which is basically doing the

00:18:32,010 --> 00:18:38,370
sign extension so it has to do the sign

00:18:35,580 --> 00:18:44,250
extension because what it sees is that

00:18:38,370 --> 00:18:47,150
we are using a short integer on to do

00:18:44,250 --> 00:18:50,310
the rithmatic strand here to ensure that

00:18:47,150 --> 00:18:52,730
you know the carry bits are calculated

00:18:50,310 --> 00:18:55,530
properly so that's why it's doing the

00:18:52,730 --> 00:18:58,980
sign extension so you can avoid you can

00:18:55,530 --> 00:19:02,990
avoid that if you know what data you are

00:18:58,980 --> 00:19:02,990
bringing in into the function ready yeah

00:19:06,230 --> 00:19:11,730
yes yes I'm going to talk about those I

00:19:09,270 --> 00:19:13,710
have a little slide on that good point

00:19:11,730 --> 00:19:17,670
the question was there a fast version of

00:19:13,710 --> 00:19:21,630
these integers and we'll cover that good

00:19:17,670 --> 00:19:24,450
point there you go so slow and fast

00:19:21,630 --> 00:19:28,700
integers did you have my slides by any

00:19:24,450 --> 00:19:31,560
chance okay so there are these

00:19:28,700 --> 00:19:35,550
extensions that are in new C standards

00:19:31,560 --> 00:19:38,850
called fast and least integer types so

00:19:35,550 --> 00:19:43,020
this is more portable way of writing non

00:19:38,850 --> 00:19:45,810
word length integers or data types if

00:19:43,020 --> 00:19:48,600
you want to so you have a choice there

00:19:45,810 --> 00:19:52,710
where you want to if your algorithm

00:19:48,600 --> 00:19:55,680
needs fast access or you can leave the

00:19:52,710 --> 00:19:58,540
slow axis so it provides you this

00:19:55,680 --> 00:20:03,160
extension with C

00:19:58,540 --> 00:20:05,050
eleven standard where it say you int and

00:20:03,160 --> 00:20:10,030
then you can you can have a you int

00:20:05,050 --> 00:20:12,130
eight underscore t you the least one

00:20:10,030 --> 00:20:13,360
would be you int underscore least eighty

00:20:12,130 --> 00:20:18,370
and theft

00:20:13,360 --> 00:20:19,900
eighty so this is again what I was

00:20:18,370 --> 00:20:23,370
mentioning earlier tell the compiler

00:20:19,900 --> 00:20:27,130
about your data tell the compiler about

00:20:23,370 --> 00:20:34,200
your execution your program and better

00:20:27,130 --> 00:20:38,470
he will do work for you yeah it is $3.99

00:20:34,200 --> 00:20:44,740
yeah so it is C 99 I think I I'll

00:20:38,470 --> 00:20:48,690
correct it before I upload so very good

00:20:44,740 --> 00:20:51,190
the way to optimize your use of integers

00:20:48,690 --> 00:20:54,340
you know look at them they're pretty

00:20:51,190 --> 00:20:56,580
pretty useful because many times you

00:20:54,340 --> 00:20:59,410
know you can afford one or another and

00:20:56,580 --> 00:21:01,630
these things come very handy for and

00:20:59,410 --> 00:21:03,670
they are in C standard so you know all

00:21:01,630 --> 00:21:07,870
compilers who claim to be seen item and

00:21:03,670 --> 00:21:10,470
compliant will have to implement it and

00:21:07,870 --> 00:21:14,440
[Music]

00:21:10,470 --> 00:21:16,300
sometimes lead sees are nosy so they

00:21:14,440 --> 00:21:19,930
provide their own understanding of these

00:21:16,300 --> 00:21:22,420
defines so if you are using something is

00:21:19,930 --> 00:21:24,940
let's see with your artists or and you

00:21:22,420 --> 00:21:26,800
know look into that they may be

00:21:24,940 --> 00:21:29,200
overriding what compiler is providing I

00:21:26,800 --> 00:21:31,690
at least saw that happening would suffer

00:21:29,200 --> 00:21:34,600
and so I just wanted to share my

00:21:31,690 --> 00:21:35,590
experience that I was struggling hard to

00:21:34,600 --> 00:21:37,750
see why

00:21:35,590 --> 00:21:40,810
you know the each types are coming out

00:21:37,750 --> 00:21:43,180
from and what I saw was you know the

00:21:40,810 --> 00:21:45,190
includes and all how they were lined up

00:21:43,180 --> 00:21:49,510
they were overriding what compiler was

00:21:45,190 --> 00:21:51,430
providing as is a standard int so look

00:21:49,510 --> 00:21:53,380
at that compiler might feel claimed to

00:21:51,430 --> 00:21:56,020
be C 99 but you might have a lip see

00:21:53,380 --> 00:22:03,280
with your program that is overriding

00:21:56,020 --> 00:22:05,830
that again portable data types so many

00:22:03,280 --> 00:22:08,290
compilers I know they provide extensions

00:22:05,830 --> 00:22:10,570
okay here is a way you can represent the

00:22:08,290 --> 00:22:11,770
data and over period of time C has

00:22:10,570 --> 00:22:14,140
included you know

00:22:11,770 --> 00:22:17,500
many of the data types that made sense

00:22:14,140 --> 00:22:22,330
into the standards so c99 for example

00:22:17,500 --> 00:22:25,420
has you int 8 16 32 64 t they are very

00:22:22,330 --> 00:22:27,070
portable representations so utilize them

00:22:25,420 --> 00:22:29,680
as much as you can just don't define

00:22:27,070 --> 00:22:32,080
your own because they will keep you

00:22:29,680 --> 00:22:33,670
compliant in the past you might have

00:22:32,080 --> 00:22:35,920
done it I know in microcontroller

00:22:33,670 --> 00:22:37,690
programming you have your own kind of a

00:22:35,920 --> 00:22:41,560
hosted file that you include in all your

00:22:37,690 --> 00:22:43,690
source code and then you know you define

00:22:41,560 --> 00:22:44,980
them based upon which compiler it is and

00:22:43,690 --> 00:22:47,320
all those things you don't need to do

00:22:44,980 --> 00:22:49,690
those if you just follow the standard

00:22:47,320 --> 00:22:58,810
and expect the compiler to provide all

00:22:49,690 --> 00:23:01,920
those defines for you yeah I think it is

00:22:58,810 --> 00:23:05,320
standard int is what you will include

00:23:01,920 --> 00:23:10,300
but they had err underneath that defines

00:23:05,320 --> 00:23:12,820
them is in touch so this is a sub

00:23:10,300 --> 00:23:16,620
inclusion that I think I dug too deep

00:23:12,820 --> 00:23:19,510
into it where it is actually coming from

00:23:16,620 --> 00:23:21,940
so I just wanted to give you like okay

00:23:19,510 --> 00:23:25,530
if you see this file in GCC that's where

00:23:21,940 --> 00:23:29,350
these definitions are but if you want to

00:23:25,530 --> 00:23:31,450
include it in a programming in a program

00:23:29,350 --> 00:23:33,810
you should include SPD in that's a very

00:23:31,450 --> 00:23:33,810
good point

00:23:34,950 --> 00:23:43,660
okay so that's about portability of your

00:23:38,680 --> 00:23:46,420
data types so the cons qualifier you

00:23:43,660 --> 00:23:48,660
know we'll have few examples but it's

00:23:46,420 --> 00:23:53,140
very interesting what you will see is

00:23:48,660 --> 00:23:54,940
it's again qualifying your variables and

00:23:53,140 --> 00:23:57,430
your functions you are providing an

00:23:54,940 --> 00:23:59,050
additional information to compiler on

00:23:57,430 --> 00:24:02,230
which compiler can act

00:23:59,050 --> 00:24:04,180
so when you say Const you are telling

00:24:02,230 --> 00:24:08,710
compiler that okay this data is not

00:24:04,180 --> 00:24:11,680
modified so this can act as a hint to

00:24:08,710 --> 00:24:17,290
the compiler where it can apply more

00:24:11,680 --> 00:24:19,600
aggressive optimizations and it can do a

00:24:17,290 --> 00:24:21,610
lot better job of assuming what your

00:24:19,600 --> 00:24:24,640
variable that you're passing as function

00:24:21,610 --> 00:24:29,350
is supposed to do in the quali

00:24:24,640 --> 00:24:31,780
so he in in cogeneration compiler is

00:24:29,350 --> 00:24:34,570
very pessimist so he has to generate

00:24:31,780 --> 00:24:37,420
code for all cases so it will always if

00:24:34,570 --> 00:24:39,429
there is one chance to go wrong he will

00:24:37,420 --> 00:24:42,870
not use that unless it's very sure that

00:24:39,429 --> 00:24:45,790
it will always work most of the time but

00:24:42,870 --> 00:24:53,290
by doing this you are giving him a more

00:24:45,790 --> 00:24:58,690
play in more room to play so if you use

00:24:53,290 --> 00:25:00,640
constant variables you can also let the

00:24:58,690 --> 00:25:03,340
compiler regenerate them for example if

00:25:00,640 --> 00:25:06,640
they are constant they are already

00:25:03,340 --> 00:25:08,830
predefined variables for example then it

00:25:06,640 --> 00:25:11,140
can regenerate those constants during

00:25:08,830 --> 00:25:19,360
execution so it doesn't have to incur a

00:25:11,140 --> 00:25:22,419
load cost from you know memory and if it

00:25:19,360 --> 00:25:25,240
is stored in a slower media like flash

00:25:22,419 --> 00:25:30,010
then you know accessing it will cause a

00:25:25,240 --> 00:25:33,580
lot more slowness so use Const when you

00:25:30,010 --> 00:25:36,580
can so here is an example where you can

00:25:33,580 --> 00:25:42,880
see that you know in the it's the same

00:25:36,580 --> 00:25:45,600
function pretty much and all I've done

00:25:42,880 --> 00:25:47,860
is I've defined the Global's to be

00:25:45,600 --> 00:25:51,520
constantly in one case and you can see

00:25:47,860 --> 00:25:53,530
that compiler has regenerated them in

00:25:51,520 --> 00:25:55,929
their source code he's not doing any

00:25:53,530 --> 00:25:58,390
load stores from flash even though your

00:25:55,929 --> 00:26:02,250
constants are predefined but it still

00:25:58,390 --> 00:26:06,760
has to go and load them from flash and

00:26:02,250 --> 00:26:09,179
such code if I loop you know you can you

00:26:06,760 --> 00:26:12,700
can see how much impact it can have on

00:26:09,179 --> 00:26:14,799
your execution path so you can see in

00:26:12,700 --> 00:26:17,440
the first phase in the first example it

00:26:14,799 --> 00:26:20,290
is loading it from a memory address

00:26:17,440 --> 00:26:24,460
right and then adding it multiplying it

00:26:20,290 --> 00:26:26,980
sign extending it and then and I'm going

00:26:24,460 --> 00:26:29,559
back but if you look in the second

00:26:26,980 --> 00:26:32,200
example he is reconstructing it sign

00:26:29,559 --> 00:26:35,280
extending it and then returning so it's

00:26:32,200 --> 00:26:35,280
a lot faster code

00:26:36,480 --> 00:26:42,190
so const then the volatile variables do

00:26:40,210 --> 00:26:44,460
you think such a thing can happen can we

00:26:42,190 --> 00:26:50,890
have a constant volatile variable

00:26:44,460 --> 00:26:54,720
anybody yes no okay so can we have a

00:26:50,890 --> 00:27:01,620
constant variable yes

00:26:54,720 --> 00:27:01,620
so any example someone can think of yeah

00:27:02,640 --> 00:27:09,580
there you go very good so so the example

00:27:07,300 --> 00:27:16,780
is a hardware straight register for

00:27:09,580 --> 00:27:21,700
example so global variables as we were

00:27:16,780 --> 00:27:25,900
also talking earlier as you can see here

00:27:21,700 --> 00:27:27,940
we defined a external integer X and when

00:27:25,900 --> 00:27:31,990
you see the code it is generating in the

00:27:27,940 --> 00:27:35,740
function below every time he is loading

00:27:31,990 --> 00:27:37,930
it from the memory then storing it back

00:27:35,740 --> 00:27:42,040
and then again loading it storing it

00:27:37,930 --> 00:27:43,930
back so this is the impact of Global's

00:27:42,040 --> 00:27:46,630
that you will generally see throughout

00:27:43,930 --> 00:27:48,310
your code it doesn't matter which

00:27:46,630 --> 00:27:54,730
architecture you are on these are

00:27:48,310 --> 00:27:56,890
general problems that you will see so

00:27:54,730 --> 00:27:59,830
this is just the illustrating a global

00:27:56,890 --> 00:28:02,410
versus local usage it's the same

00:27:59,830 --> 00:28:05,890
function as you can see in the first

00:28:02,410 --> 00:28:09,570
example it's global but there are these

00:28:05,890 --> 00:28:13,210
three loads and stores where it is

00:28:09,570 --> 00:28:17,920
before calling the print function but if

00:28:13,210 --> 00:28:20,130
you see on the local where you are

00:28:17,920 --> 00:28:23,770
basically transferring that into a local

00:28:20,130 --> 00:28:25,870
it just knows that you know it's a local

00:28:23,770 --> 00:28:29,710
variable I can just I don't have to

00:28:25,870 --> 00:28:32,830
worry about a changing state out of the

00:28:29,710 --> 00:28:37,620
function so it can just load it into a

00:28:32,830 --> 00:28:40,030
register pass on to call the function so

00:28:37,620 --> 00:28:44,080
keep in mind when you're designing your

00:28:40,030 --> 00:28:46,810
routines can you live with locals in

00:28:44,080 --> 00:28:49,210
many cases it also helps is when you are

00:28:46,810 --> 00:28:50,799
operating in a loop or so

00:28:49,210 --> 00:28:55,570
you really need a global you know you

00:28:50,799 --> 00:28:58,899
can you can maybe a transfer that local

00:28:55,570 --> 00:29:01,480
value you know if it is not modified

00:28:58,899 --> 00:29:03,039
elsewhere into a local and then operate

00:29:01,480 --> 00:29:05,500
on it and and store it back in the end

00:29:03,039 --> 00:29:08,649
essentially yourself and then while you

00:29:05,500 --> 00:29:10,510
are helping the compiler again that you

00:29:08,649 --> 00:29:15,789
know an optimization that you are

00:29:10,510 --> 00:29:22,440
providing and not the compiler static

00:29:15,789 --> 00:29:25,059
variables so static variables important

00:29:22,440 --> 00:29:26,590
what I see from static variables is

00:29:25,059 --> 00:29:30,120
again you are making a statement about

00:29:26,590 --> 00:29:31,720
the scope of the function so it's only

00:29:30,120 --> 00:29:36,730
available for that particular

00:29:31,720 --> 00:29:39,730
compilation unit what it can do is I've

00:29:36,730 --> 00:29:41,799
mentioned here spatial locality that's

00:29:39,730 --> 00:29:44,320
very important what happens is when

00:29:41,799 --> 00:29:47,130
you're linking a program linker knows

00:29:44,320 --> 00:29:50,140
these all variables are coming from same

00:29:47,130 --> 00:29:54,159
module so he puts them one after another

00:29:50,140 --> 00:29:56,200
or at least he knows the map so what

00:29:54,159 --> 00:29:59,020
happens is when they are placed one

00:29:56,200 --> 00:30:01,600
after another and most probably you're

00:29:59,020 --> 00:30:04,120
accessing them one after another two or

00:30:01,600 --> 00:30:06,100
maybe you are accessing them together in

00:30:04,120 --> 00:30:08,500
a way because you are in a the same

00:30:06,100 --> 00:30:12,100
function or something like that

00:30:08,500 --> 00:30:15,700
it can basically add in generate code

00:30:12,100 --> 00:30:17,440
where he uses a base function or a base

00:30:15,700 --> 00:30:19,870
address and then use an offset to

00:30:17,440 --> 00:30:22,600
address different static variables it

00:30:19,870 --> 00:30:24,340
can perform that optimizations if you

00:30:22,600 --> 00:30:27,100
are using static variables but if they

00:30:24,340 --> 00:30:30,340
are global then there is no way you know

00:30:27,100 --> 00:30:32,909
for it it has to assume that it can be

00:30:30,340 --> 00:30:38,200
anywhere in the memory so linker cannot

00:30:32,909 --> 00:30:40,450
perform these optimizations static

00:30:38,200 --> 00:30:43,990
functions so I know many times we use

00:30:40,450 --> 00:30:46,960
macros and static function you know it's

00:30:43,990 --> 00:30:51,789
a it's a debate many times people have

00:30:46,960 --> 00:30:55,539
it but one of the advantages that you

00:30:51,789 --> 00:30:58,419
get from static functions is you let

00:30:55,539 --> 00:31:00,700
compiler decide when to inline it many

00:30:58,419 --> 00:31:02,750
times compiler knows more than us you

00:31:00,700 --> 00:31:05,090
know many times

00:31:02,750 --> 00:31:07,400
it can do a better job of inlining than

00:31:05,090 --> 00:31:09,530
ourselves so we should give it a chance

00:31:07,400 --> 00:31:12,500
to do the inlining and then optimize

00:31:09,530 --> 00:31:15,680
rather than we deciding okay I know what

00:31:12,500 --> 00:31:20,900
to in mind what not to in line because

00:31:15,680 --> 00:31:22,850
it knows the instruction length it knows

00:31:20,900 --> 00:31:25,940
how many cycles it takes it knows all

00:31:22,850 --> 00:31:28,130
the delays so it can do a lot of

00:31:25,940 --> 00:31:30,920
calculations on total execution of

00:31:28,130 --> 00:31:32,300
functions that probably you know it will

00:31:30,920 --> 00:31:35,000
take us time if we are doing all those

00:31:32,300 --> 00:31:36,710
calculations ourselves so my

00:31:35,000 --> 00:31:39,890
recommendation is always give compiler a

00:31:36,710 --> 00:31:42,560
chance and then if it fails then you

00:31:39,890 --> 00:31:47,150
kick in and then you basically help the

00:31:42,560 --> 00:31:51,620
compiler another thing it gives you is

00:31:47,150 --> 00:31:54,790
debugging so when you know you are not

00:31:51,620 --> 00:31:57,470
writing macros but writing functions in

00:31:54,790 --> 00:32:00,230
inlining or sorry static functions then

00:31:57,470 --> 00:32:04,400
you can debug them better compilers have

00:32:00,230 --> 00:32:07,340
done even I think GCC also can do macro

00:32:04,400 --> 00:32:09,590
debugging if you enable like the extreme

00:32:07,340 --> 00:32:13,580
level of debugging but then you end up

00:32:09,590 --> 00:32:16,030
with a lot of bigger debugging data that

00:32:13,580 --> 00:32:22,160
you need to deal with in your debugger

00:32:16,030 --> 00:32:23,300
so this is a pretty lightweight on you

00:32:22,160 --> 00:32:25,940
don't have to like enable those

00:32:23,300 --> 00:32:29,030
extensive door free debugging

00:32:25,940 --> 00:32:35,600
information to get all your macro

00:32:29,030 --> 00:32:37,970
optimizations of macros so the other

00:32:35,600 --> 00:32:40,880
thing is that you know during

00:32:37,970 --> 00:32:42,560
compilation where your static function

00:32:40,880 --> 00:32:45,260
is going to be laid out compiler knows

00:32:42,560 --> 00:32:47,240
it already so unless you are using like

00:32:45,260 --> 00:32:50,990
whole program optimizations and stuff

00:32:47,240 --> 00:32:52,790
like that the location can be pinned so

00:32:50,990 --> 00:32:57,200
if you are calling and it's not in lined

00:32:52,790 --> 00:32:59,450
he can still optimize your jumps it can

00:32:57,200 --> 00:33:03,050
use a static small jump so it doesn't

00:32:59,450 --> 00:33:06,020
have to do a veneer or interact jump and

00:33:03,050 --> 00:33:09,790
stuff like that so even it helps in you

00:33:06,020 --> 00:33:09,790
know creating a better calling sequence

00:33:10,450 --> 00:33:17,899
so volatile

00:33:14,289 --> 00:33:19,849
volatile you are telling the compiler

00:33:17,899 --> 00:33:21,679
that hey you know please don't do

00:33:19,849 --> 00:33:29,619
anything to this variable I know this is

00:33:21,679 --> 00:33:32,209
special and you want this to define so

00:33:29,619 --> 00:33:35,529
what happens is the compiler doesn't

00:33:32,209 --> 00:33:38,989
unnecessarily optimize on your variable

00:33:35,529 --> 00:33:41,569
so what happens is many times compilers

00:33:38,989 --> 00:33:44,899
have these optimizations a a real-world

00:33:41,569 --> 00:33:48,169
example I can give you is you have a

00:33:44,899 --> 00:33:51,199
register you want to access as it's

00:33:48,169 --> 00:33:54,889
8-bit register or so you have defined it

00:33:51,199 --> 00:33:57,469
as a chart or a u entity and there are

00:33:54,889 --> 00:33:59,629
four of them in line so you have an

00:33:57,469 --> 00:34:02,799
access to them a read access to all four

00:33:59,629 --> 00:34:06,649
of them a compiler can basically

00:34:02,799 --> 00:34:09,710
decompose that into a integer or access

00:34:06,649 --> 00:34:12,559
wise we won't use LDR B which means load

00:34:09,710 --> 00:34:14,539
byte or store byte he will just say he

00:34:12,559 --> 00:34:15,980
will coalesce all the four because he

00:34:14,539 --> 00:34:18,349
sees they are one after another in

00:34:15,980 --> 00:34:22,039
address space I can just make a single

00:34:18,349 --> 00:34:24,440
four byte load right but that's wrong

00:34:22,039 --> 00:34:26,839
because these are registers you want to

00:34:24,440 --> 00:34:28,489
access them one after another so it's

00:34:26,839 --> 00:34:32,629
very important that you qualify that

00:34:28,489 --> 00:34:35,210
kind of data with you know volatile

00:34:32,629 --> 00:34:38,599
where you are telling compiler to stay

00:34:35,210 --> 00:34:48,169
away from from optimizing that in any

00:34:38,599 --> 00:34:48,379
mess so there are certain compilers I

00:34:48,169 --> 00:34:51,259
know

00:34:48,379 --> 00:34:54,950
proprietary ones who have some

00:34:51,259 --> 00:34:57,170
extensions to qualify volatile variables

00:34:54,950 --> 00:35:01,150
place it here you know place it there

00:34:57,170 --> 00:35:04,039
you know they kind of give those hints

00:35:01,150 --> 00:35:05,779
but this they are all non-standard so if

00:35:04,039 --> 00:35:09,710
you are using such a compiler and you

00:35:05,779 --> 00:35:11,359
might be using that be sure that that is

00:35:09,710 --> 00:35:14,749
only effective when that particular

00:35:11,359 --> 00:35:17,420
compiler is used so that makes you more

00:35:14,749 --> 00:35:19,640
portable to different compiler tool

00:35:17,420 --> 00:35:21,680
chains or even architectures because

00:35:19,640 --> 00:35:23,180
different architects you may provide a

00:35:21,680 --> 00:35:25,999
different tool chain and you will be in

00:35:23,180 --> 00:35:27,619
a fix so this helps you to port their

00:35:25,999 --> 00:35:29,140
applications quickly

00:35:27,619 --> 00:35:34,430
if you remain portable across

00:35:29,140 --> 00:35:36,440
architectures and across tubes so erase

00:35:34,430 --> 00:35:41,089
subscript versus pointer axis so again

00:35:36,440 --> 00:35:43,940
moving to you know how you can kind of

00:35:41,089 --> 00:35:45,710
represent your data so here's another

00:35:43,940 --> 00:35:50,720
another example I tried which is

00:35:45,710 --> 00:35:53,450
essentially same code in one case you

00:35:50,720 --> 00:35:57,200
know what I'm doing is I'm using

00:35:53,450 --> 00:35:59,950
pointers to access the data and in other

00:35:57,200 --> 00:36:03,730
case I'm just using the array as such

00:35:59,950 --> 00:36:06,769
and what you can see is the

00:36:03,730 --> 00:36:08,809
understanding that compiler has is

00:36:06,769 --> 00:36:13,249
different even though the code looks

00:36:08,809 --> 00:36:15,619
same you can see that compiler is able

00:36:13,249 --> 00:36:18,589
to understand the pointer accesses are

00:36:15,619 --> 00:36:20,599
much kind of because if it is operating

00:36:18,589 --> 00:36:24,680
on a global data he's loading the

00:36:20,599 --> 00:36:28,099
pointer storing the pointer and if it is

00:36:24,680 --> 00:36:31,249
doing just array subscripts he is just

00:36:28,099 --> 00:36:37,400
he doesn't have to do that

00:36:31,249 --> 00:36:39,519
extra point of conversion and so watch

00:36:37,400 --> 00:36:43,519
out for use of these cases the whole

00:36:39,519 --> 00:36:45,410
idea is to explain that watch out for

00:36:43,519 --> 00:36:48,619
such use cases look at it assembly that

00:36:45,410 --> 00:36:51,309
the compiler is generating and in many

00:36:48,619 --> 00:37:02,440
cases you would see that results are

00:36:51,309 --> 00:37:02,440
dependent on how you have used it yeah

00:37:09,519 --> 00:37:13,849
correct yes

00:37:11,420 --> 00:37:16,730
so that's what you know because many

00:37:13,849 --> 00:37:19,130
times what you do is you use a for

00:37:16,730 --> 00:37:22,269
example in the for we use optimized for

00:37:19,130 --> 00:37:25,190
size I was using as my default I'm level

00:37:22,269 --> 00:37:28,940
then if you're using a different

00:37:25,190 --> 00:37:31,730
compiler you know it may apply that that

00:37:28,940 --> 00:37:34,700
conversion of optimizations in other

00:37:31,730 --> 00:37:37,460
case it may not so so look out for that

00:37:34,700 --> 00:37:39,049
if it is not doing either enable that

00:37:37,460 --> 00:37:41,480
switch explicitly if you need it or

00:37:39,049 --> 00:37:44,450
understand that okay it's not doing the

00:37:41,480 --> 00:37:55,190
a subscript to pointer access

00:37:44,450 --> 00:37:57,680
conversions yeah I think in this case

00:37:55,190 --> 00:38:01,040
what you can see is that I'm defining a

00:37:57,680 --> 00:38:02,840
pointer and it is not able to Elia is to

00:38:01,040 --> 00:38:05,480
kind of associate that pointer that I

00:38:02,840 --> 00:38:06,950
can optimize it away so right now that

00:38:05,480 --> 00:38:09,170
is just the illustration from the

00:38:06,950 --> 00:38:11,300
compiler point of views if I had more

00:38:09,170 --> 00:38:17,270
aggressive optimization enabled it

00:38:11,300 --> 00:38:22,670
probably would have identified that yes

00:38:17,270 --> 00:38:25,150
point rail is correct you can do that

00:38:22,670 --> 00:38:27,380
yes you can use the restrict qualifiers

00:38:25,150 --> 00:38:29,570
but you have basically have to

00:38:27,380 --> 00:38:33,710
understand that okay this is something

00:38:29,570 --> 00:38:36,260
if I want it to work the way you know

00:38:33,710 --> 00:38:41,450
I'm accessing it he is important to

00:38:36,260 --> 00:38:47,030
understand what compiler generate that

00:38:41,450 --> 00:38:48,800
happens yes yes so it won't you know you

00:38:47,030 --> 00:38:50,900
might have to either let the compiler

00:38:48,800 --> 00:38:59,180
know that don't worry about aliasing I

00:38:50,900 --> 00:39:00,680
know that you know it doesn't alias you

00:38:59,180 --> 00:39:05,050
know you won't be saying the same issue

00:39:00,680 --> 00:39:07,940
but it will still have a single load

00:39:05,050 --> 00:39:14,330
from the parameter list for example or

00:39:07,940 --> 00:39:18,460
transfer but you won't see this issue so

00:39:14,330 --> 00:39:18,460
loop increment versus document this is

00:39:20,260 --> 00:39:27,619
this is actually applicable everywhere

00:39:22,760 --> 00:39:31,310
but what you see is when you are testing

00:39:27,619 --> 00:39:33,650
or you are increasing the loop with your

00:39:31,310 --> 00:39:38,330
counter then you have to test it against

00:39:33,650 --> 00:39:42,130
your value when you're documenting you

00:39:38,330 --> 00:39:44,750
know it's waiting for it to be zero so

00:39:42,130 --> 00:39:49,960
architectures provide instructions to

00:39:44,750 --> 00:39:53,030
test against zero you know and all those

00:39:49,960 --> 00:39:54,800
so what compiler can do is then you are

00:39:53,030 --> 00:39:56,360
decrementing your loop

00:39:54,800 --> 00:40:00,500
it can take advantage of those

00:39:56,360 --> 00:40:04,430
obstructions and what you will see is in

00:40:00,500 --> 00:40:08,660
here it's doing a sub s right and then

00:40:04,430 --> 00:40:11,900
that will set a flag and the instruction

00:40:08,660 --> 00:40:14,720
below is doing a branch if not equal to

00:40:11,900 --> 00:40:17,210
zero so you are able to combine fudge

00:40:14,720 --> 00:40:23,300
together the check and the branch into

00:40:17,210 --> 00:40:25,040
one but in the case on a increment side

00:40:23,300 --> 00:40:29,450
you will see that he has to explicitly

00:40:25,040 --> 00:40:31,850
make a check against value 100 and then

00:40:29,450 --> 00:40:36,250
that will set the flag up and then you

00:40:31,850 --> 00:40:43,550
will do a branch so it can save you

00:40:36,250 --> 00:40:46,220
instruction and there is also a post

00:40:43,550 --> 00:40:48,650
versus pre-decrement so whether you

00:40:46,220 --> 00:40:52,280
should use like minus minus X or you

00:40:48,650 --> 00:40:55,280
should use X minus minus so you can see

00:40:52,280 --> 00:40:56,930
that the both algorithms are actually

00:40:55,280 --> 00:41:03,260
doing same things you know it's going to

00:40:56,930 --> 00:41:05,060
print the value 10 times and but the

00:41:03,260 --> 00:41:09,290
algorithm if you look at the code that's

00:41:05,060 --> 00:41:12,980
generated the pre increment you can see

00:41:09,290 --> 00:41:19,370
that it's running in a it's able to

00:41:12,980 --> 00:41:24,350
generate better code because what it is

00:41:19,370 --> 00:41:26,750
doing there is it's able to first apply

00:41:24,350 --> 00:41:33,320
the operation the incremental and then

00:41:26,750 --> 00:41:36,500
use that value throughout the loop but

00:41:33,320 --> 00:41:43,210
in other case he has to also he has to

00:41:36,500 --> 00:41:48,470
apply the operation after the value so

00:41:43,210 --> 00:41:51,680
function parameters very important it

00:41:48,470 --> 00:41:55,760
depends upon the ABI really so if you

00:41:51,680 --> 00:41:59,360
look at say R maybe I you know that's

00:41:55,760 --> 00:42:01,910
what I was using here Kotex entry

00:41:59,360 --> 00:42:05,600
so the document they documented

00:42:01,910 --> 00:42:06,770
extensively and all architectures do if

00:42:05,600 --> 00:42:10,190
they have

00:42:06,770 --> 00:42:12,820
a common avi across all tools then you

00:42:10,190 --> 00:42:14,990
know this they tell you how many

00:42:12,820 --> 00:42:17,960
registers can be used for parameter

00:42:14,990 --> 00:42:19,460
passing and how they are passed so read

00:42:17,960 --> 00:42:21,800
through those for whatever

00:42:19,460 --> 00:42:24,440
microcontroller you are using and it may

00:42:21,800 --> 00:42:29,420
have a VI arm has a very strong API and

00:42:24,440 --> 00:42:33,320
all to follow that nowadays if it needs

00:42:29,420 --> 00:42:35,030
more parameters or more registers to

00:42:33,320 --> 00:42:36,260
represent the parameters then it's going

00:42:35,030 --> 00:42:42,560
to use stack which is going to be

00:42:36,260 --> 00:42:46,670
expensive so see how you can write your

00:42:42,560 --> 00:42:48,410
function signatures that you can max you

00:42:46,670 --> 00:42:51,590
can utilize the you know the given for

00:42:48,410 --> 00:42:54,410
register parameter passing in a very

00:42:51,590 --> 00:42:58,490
efficient way so one of the things is

00:42:54,410 --> 00:43:01,220
that when you have functions alignment

00:42:58,490 --> 00:43:05,750
also matters so I'll just show a little

00:43:01,220 --> 00:43:08,330
bit here so what you can see is in honor

00:43:05,750 --> 00:43:11,180
arm are 0 to R 3 those are the 4

00:43:08,330 --> 00:43:12,620
paragraph four registers you have but

00:43:11,180 --> 00:43:15,230
you see in the first function what I'm

00:43:12,620 --> 00:43:19,640
doing is I'm taking an int a long long

00:43:15,230 --> 00:43:21,710
and int right so and in the second

00:43:19,640 --> 00:43:25,840
function I'm doing an int int long long

00:43:21,710 --> 00:43:28,760
right so in effect you need four

00:43:25,840 --> 00:43:33,260
registers to pass them but the problem

00:43:28,760 --> 00:43:37,190
with the first example is that he will

00:43:33,260 --> 00:43:39,950
align them and they be the long long

00:43:37,190 --> 00:43:44,180
because it's 8 bytes long so he would be

00:43:39,950 --> 00:43:46,310
able to use two registers for that but

00:43:44,180 --> 00:43:50,390
then one of the registers will go empty

00:43:46,310 --> 00:43:52,100
because of the alignment so in the end

00:43:50,390 --> 00:43:54,280
what you will see is that you know he is

00:43:52,100 --> 00:43:59,870
spilling into the into the stack pointer

00:43:54,280 --> 00:44:03,260
your third parameter so so these things

00:43:59,870 --> 00:44:08,120
can help you a lot when you are you know

00:44:03,260 --> 00:44:13,510
using these parameters so in line

00:44:08,120 --> 00:44:13,510
assembly it can it's yeah

00:44:23,119 --> 00:44:33,450
that's likely yes

00:44:26,089 --> 00:44:36,510
okay so inline assembly is you know use

00:44:33,450 --> 00:44:38,579
it when you have to in many cases

00:44:36,510 --> 00:44:40,170
compiler may not be able to generate the

00:44:38,579 --> 00:44:42,210
instructions you want to use say you

00:44:40,170 --> 00:44:44,900
know you're you are accessing a

00:44:42,210 --> 00:44:47,579
particular coprocessor or something

00:44:44,900 --> 00:44:50,369
using inline assembly helps you to

00:44:47,579 --> 00:44:53,730
insert those into your normal c program

00:44:50,369 --> 00:44:55,650
and it helps GCC to take care of the

00:44:53,730 --> 00:45:00,180
data flow analysis so it will be able to

00:44:55,650 --> 00:45:06,150
you know take that code and assemble it

00:45:00,180 --> 00:45:10,680
into AC function so intrinsics is one

00:45:06,150 --> 00:45:13,619
good example and there are said special

00:45:10,680 --> 00:45:15,569
instructions if you have any so I've

00:45:13,619 --> 00:45:17,940
given a link here for GCC's inline

00:45:15,569 --> 00:45:20,369
assembly syntax it's quite cryptic and

00:45:17,940 --> 00:45:23,250
but it's well explained so you can read

00:45:20,369 --> 00:45:26,280
through it and see how you can use it

00:45:23,250 --> 00:45:28,530
efficiently so it has qualifiers that

00:45:26,280 --> 00:45:31,530
lets you define what is the different

00:45:28,530 --> 00:45:32,910
register of what are different inputs

00:45:31,530 --> 00:45:36,450
and outputs and what are the constraints

00:45:32,910 --> 00:45:39,869
on those and I've seen other compilers

00:45:36,450 --> 00:45:45,630
have them - their syntax is very so it

00:45:39,869 --> 00:45:46,980
it is actually one of the most it's most

00:45:45,630 --> 00:45:49,200
common case that you'll see when you're

00:45:46,980 --> 00:45:51,599
coding your program from one compiler to

00:45:49,200 --> 00:45:57,329
another that your inline assembly just

00:45:51,599 --> 00:46:00,210
doesn't work so I think optimizing for

00:45:57,329 --> 00:46:03,089
DRAM use smaller data types we talked

00:46:00,210 --> 00:46:05,940
about that but when you use smaller data

00:46:03,089 --> 00:46:09,030
types you're using less memory so it can

00:46:05,940 --> 00:46:12,630
help you if you're you know ionic on a

00:46:09,030 --> 00:46:15,809
ram contain constraint system use

00:46:12,630 --> 00:46:18,839
pattern use kind of compressed

00:46:15,809 --> 00:46:21,240
structures there are back trucks in I

00:46:18,839 --> 00:46:24,240
think all kind of compilers they support

00:46:21,240 --> 00:46:25,859
them so use that or reorganize your data

00:46:24,240 --> 00:46:26,640
structure so you don't have much padding

00:46:25,859 --> 00:46:29,550
in between

00:46:26,640 --> 00:46:31,410
if you can in any cases you can't

00:46:29,550 --> 00:46:33,810
because it's a network parameter or

00:46:31,410 --> 00:46:39,360
something or a IP header that you can't

00:46:33,810 --> 00:46:41,880
do much about it and I know about the

00:46:39,360 --> 00:46:45,890
local variables use them as much as you

00:46:41,880 --> 00:46:48,720
can and for example if you use L okay

00:46:45,890 --> 00:46:50,310
you know you would see in the code that

00:46:48,720 --> 00:46:52,290
it doesn't release that memory even

00:46:50,310 --> 00:46:54,300
though we think I'm using it locally it

00:46:52,290 --> 00:46:56,280
won't release it until you return from

00:46:54,300 --> 00:46:58,620
the function so be aware of those kind

00:46:56,280 --> 00:47:01,020
of details you are still using that

00:46:58,620 --> 00:47:03,540
memory allocated until the end of the

00:47:01,020 --> 00:47:07,020
function so if you want to release it

00:47:03,540 --> 00:47:11,280
you have to make calls for free in

00:47:07,020 --> 00:47:14,310
between merge constant come up today

00:47:11,280 --> 00:47:16,860
shion's you know in risk very important

00:47:14,310 --> 00:47:19,290
that it can reconstruct some constants

00:47:16,860 --> 00:47:21,510
as we saw one example where it was

00:47:19,290 --> 00:47:25,170
trying to do that and that helps quite a

00:47:21,510 --> 00:47:27,750
lot and then you can check your stack

00:47:25,170 --> 00:47:29,640
and heat usage and see if you are having

00:47:27,750 --> 00:47:31,950
an additional allocation there that you

00:47:29,640 --> 00:47:34,620
are not hitting a limit for example then

00:47:31,950 --> 00:47:38,430
you know you can limit how much stack of

00:47:34,620 --> 00:47:41,160
heat you decide to look at for your app

00:47:38,430 --> 00:47:49,230
so you can have them kind of more or

00:47:41,160 --> 00:47:51,420
less you can use less RAM for so how's

00:47:49,230 --> 00:47:54,090
the compiler out close this I've been

00:47:51,420 --> 00:47:56,430
mentioning that it doesn't have a magic

00:47:54,090 --> 00:48:01,260
crystal ball so you it operates on what

00:47:56,430 --> 00:48:03,270
you give it and it makes worst case

00:48:01,260 --> 00:48:05,460
assumptions as we talked about pointer

00:48:03,270 --> 00:48:08,070
aliasing is one good example that if it

00:48:05,460 --> 00:48:10,560
sees there is a chance for pointer to

00:48:08,070 --> 00:48:12,210
alias it will assume it will area so

00:48:10,560 --> 00:48:17,040
he's going to give you the worst case

00:48:12,210 --> 00:48:18,780
scenario and a bad code there and the

00:48:17,040 --> 00:48:20,850
global data if you use a lot of global

00:48:18,780 --> 00:48:23,700
data then it knows that it's not

00:48:20,850 --> 00:48:26,030
invertible so he has to every access we

00:48:23,700 --> 00:48:28,170
make he is going to load store and

00:48:26,030 --> 00:48:32,610
dowhile is better because you are

00:48:28,170 --> 00:48:34,950
decrementing then for loops one reason

00:48:32,610 --> 00:48:39,660
is that the termination check can be

00:48:34,950 --> 00:48:40,260
performed and you can use the compiler

00:48:39,660 --> 00:48:42,290
forward and

00:48:40,260 --> 00:48:44,850
rotations also to help the compiler

00:48:42,290 --> 00:48:47,610
function attribute variable attributes

00:48:44,850 --> 00:48:50,610
pragmas you can tell a lot about your

00:48:47,610 --> 00:48:52,740
code to the compiler to help them give

00:48:50,610 --> 00:48:55,310
you the best code and there are

00:48:52,740 --> 00:48:58,350
intrinsic functions you can use them for

00:48:55,310 --> 00:49:00,690
optimizing your code again intrinsic

00:48:58,350 --> 00:49:03,750
functions are compiler specific so watch

00:49:00,690 --> 00:49:05,820
out for those be mindful that you know a

00:49:03,750 --> 00:49:07,590
different compiler may have a different

00:49:05,820 --> 00:49:13,170
different calling convention or stuff

00:49:07,590 --> 00:49:16,920
like that so stay away from debug mode

00:49:13,170 --> 00:49:19,080
and release mode because you want to

00:49:16,920 --> 00:49:24,240
develop the code that you want to run in

00:49:19,080 --> 00:49:26,880
production period so if you want to be

00:49:24,240 --> 00:49:29,310
you know a consistence see whether you

00:49:26,880 --> 00:49:31,080
how much debugging you can afford and

00:49:29,310 --> 00:49:34,560
how much optimizations you can afford

00:49:31,080 --> 00:49:36,870
more period of time using the same code

00:49:34,560 --> 00:49:41,310
generation for debugging and production

00:49:36,870 --> 00:49:44,160
is the way to go fine details about your

00:49:41,310 --> 00:49:50,250
system architecture bus lengths memory

00:49:44,160 --> 00:49:54,510
types flash sizes and latencies and very

00:49:50,250 --> 00:49:57,570
important and profile your code before

00:49:54,510 --> 00:49:59,580
you optimize anything most of the times

00:49:57,570 --> 00:50:05,070
we jump on to a solution and it's wrong

00:49:59,580 --> 00:50:06,720
so use tools as much as we can that

00:50:05,070 --> 00:50:09,780
gives you a really good picture of what

00:50:06,720 --> 00:50:11,810
your app is doing and then utilize the

00:50:09,780 --> 00:50:13,830
tools don't fight them most of the time

00:50:11,810 --> 00:50:17,940
there is a reason why they are doing

00:50:13,830 --> 00:50:19,650
what they are doing so help them to help

00:50:17,940 --> 00:50:22,140
you if you have them they will help you

00:50:19,650 --> 00:50:25,350
back and the avoid assembly if you can

00:50:22,140 --> 00:50:29,730
write everything in C so that's pretty

00:50:25,350 --> 00:50:33,270
much I had any questions we are open

00:50:29,730 --> 00:50:38,870
right now so we are almost out of time

00:50:33,270 --> 00:50:38,870
so if there are a few questions yeah

00:50:52,000 --> 00:50:58,730
it is when you know that your data is

00:50:55,430 --> 00:50:59,870
not changing it's good to use it it's

00:50:58,730 --> 00:51:01,850
always good to use it because it's

00:50:59,870 --> 00:51:04,100
telling the compiler that yes this is

00:51:01,850 --> 00:51:06,890
constant data that I don't have to

00:51:04,100 --> 00:51:12,230
always reload from memory so if it can

00:51:06,890 --> 00:51:16,510
be reconstructed it will yeah there was

00:51:12,230 --> 00:51:16,510
there was another question in the I

00:51:22,390 --> 00:51:55,640
don't know yeah so yes so yes that's

00:51:43,940 --> 00:52:15,770
Odie yep so one more last question you

00:51:55,640 --> 00:52:18,140
had some yes yes yes yes I think it's

00:52:15,770 --> 00:52:20,180
always good in theory to present

00:52:18,140 --> 00:52:23,840
yourself in terms of aliasing come out

00:52:20,180 --> 00:52:26,110
clear so that is the best scenario I've

00:52:23,840 --> 00:52:28,700
seen where you don't really let compiler

00:52:26,110 --> 00:52:32,090
trigger and you tell them clearly that

00:52:28,700 --> 00:52:36,510
I'm not aliasing so thank you very much

00:52:32,090 --> 00:52:40,089
and pleasure

00:52:36,510 --> 00:52:40,089

YouTube URL: https://www.youtube.com/watch?v=GYAhbYnObLI


