Title: Groking the Linux SPI Subsystem - Matt Porter, Konsulko
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Groking the Linux SPI Subsystem - Matt Porter, Konsulko

The Serial Peripheral Interconnect (SPI) bus is a ubiquitous de facto standard found in many embedded systems produced today. The Linux kernel has long supported this bus via a comprehensive framework which supports both SPI master and slave devices. The session will explore the abstractions the framework provides to expose this hardware to both kernel and userspace clients. In addition, we will discuss subtle features of the SPI subsystem that may be used to satisfy hardware and performance requirements in an embedded Linux system.

About Matthew Porter
Matt Porter is the CTO of Konsulko Group, working on the design and development software for embedded Linux based systems. Matt specializes in the Linux kernel and associated FOSS middleware that provides the plumbing for applications. Outside of work he hacks on various random Linux kernel drivers and subsystems. Matt has spoken at numerous previous Embedded Linux Conferences on a broad range of topics.
Captions: 
	00:00:00,500 --> 00:00:09,059
okay looks like my mics working so

00:00:04,650 --> 00:00:12,179
that's always a good start thanks

00:00:09,059 --> 00:00:15,480
everybody for coming to rockin the Linux

00:00:12,179 --> 00:00:19,590
PI sub system my name is Matt Porter

00:00:15,480 --> 00:00:22,890
with console' go group and let's let's

00:00:19,590 --> 00:00:25,170
dive into it here because I broke my

00:00:22,890 --> 00:00:27,060
rule about how many slides to have in

00:00:25,170 --> 00:00:31,590
something because there's just too many

00:00:27,060 --> 00:00:34,320
visual aids needed in this little

00:00:31,590 --> 00:00:37,050
background on this if you're if you're

00:00:34,320 --> 00:00:38,790
somebody who works in the spy subsystem

00:00:37,050 --> 00:00:40,579
itself and the core code or you're

00:00:38,790 --> 00:00:42,540
already doing controller drivers

00:00:40,579 --> 00:00:45,690
probably not the content you're looking

00:00:42,540 --> 00:00:47,789
for here this is more from that person

00:00:45,690 --> 00:00:50,520
trying to use it right how do I actually

00:00:47,789 --> 00:00:57,620
make use of this stuff so let's get

00:00:50,520 --> 00:00:57,620
going Oh turns it off already

00:01:09,520 --> 00:01:12,420
all right

00:01:14,939 --> 00:01:19,189
of course my pointer quit working again

00:01:26,479 --> 00:01:32,420
all right so one of the things that try

00:01:29,869 --> 00:01:34,430
to do is that we get reminded a lot that

00:01:32,420 --> 00:01:38,570
we have a very diverse community these

00:01:34,430 --> 00:01:43,310
days and so I got a uh nopsi skate the

00:01:38,570 --> 00:01:45,829
title of the session so grok comes from

00:01:43,310 --> 00:01:48,319
stranger in a strange land are behind

00:01:45,829 --> 00:01:50,270
line so that's where the book comes from

00:01:48,319 --> 00:01:52,219
that's actually one of the cover art

00:01:50,270 --> 00:01:57,140
things so now you know if you didn't

00:01:52,219 --> 00:01:59,030
know where that word came from so we're

00:01:57,140 --> 00:02:02,539
going to go through today we're going to

00:01:59,030 --> 00:02:04,189
talk about what spy is we can't we can't

00:02:02,539 --> 00:02:05,780
really talk about how the sub system

00:02:04,189 --> 00:02:07,670
works and what the facilities are

00:02:05,780 --> 00:02:10,670
available to us as users whether we're

00:02:07,670 --> 00:02:12,650
kernel users or user space users until

00:02:10,670 --> 00:02:16,430
we actually understand it completely and

00:02:12,650 --> 00:02:19,670
so we'll go over spy fundamentals some

00:02:16,430 --> 00:02:22,069
Linux specific spy concepts and then

00:02:19,670 --> 00:02:24,440
we'll look at use cases these kind of

00:02:22,069 --> 00:02:26,660
use cases where at a device we want to

00:02:24,440 --> 00:02:28,370
do a protocol driver controller driver

00:02:26,660 --> 00:02:31,450
and we'll talk about what those mean in

00:02:28,370 --> 00:02:34,010
this context and then user space drivers

00:02:31,450 --> 00:02:36,200
okay and we'll talk a little bit about

00:02:34,010 --> 00:02:41,480
spy performance and then what's coming

00:02:36,200 --> 00:02:47,660
up in the future in the spy subsystem so

00:02:41,480 --> 00:02:50,600
what is spy yes not as many people in

00:02:47,660 --> 00:02:53,139
Europe get this reference I noticed that

00:02:50,600 --> 00:02:56,569
more people in the US will get that so

00:02:53,139 --> 00:03:00,440
serial peripheral interface okay

00:02:56,569 --> 00:03:02,870
the Motorola de-facto standard this

00:03:00,440 --> 00:03:05,090
comes back from eight co8

00:03:02,870 --> 00:03:06,799
microcontroller time frame they had

00:03:05,090 --> 00:03:08,840
introduced this writer right around

00:03:06,799 --> 00:03:11,329
there for any of you that started in

00:03:08,840 --> 00:03:15,109
university working on 8:05 HCO AIT's

00:03:11,329 --> 00:03:17,780
like me dating myself you might have

00:03:15,109 --> 00:03:20,750
seen this stuff back then so it's a

00:03:17,780 --> 00:03:24,560
master slave bus it's a four wire bus

00:03:20,750 --> 00:03:27,290
except when it's not so nothing is

00:03:24,560 --> 00:03:30,560
simple and there's no maximum clock

00:03:27,290 --> 00:03:34,280
speed right so we can go maximum

00:03:30,560 --> 00:03:37,939
ludicrous speed like a Tesla and one

00:03:34,280 --> 00:03:38,440
joking comment about the spy itself is

00:03:37,939 --> 00:03:41,620
that

00:03:38,440 --> 00:03:44,470
just a glorified shift register right or

00:03:41,620 --> 00:03:46,480
shift register with side effects so if

00:03:44,470 --> 00:03:49,120
you want to get into the more detail

00:03:46,480 --> 00:03:51,220
gory detail you can go to the usual

00:03:49,120 --> 00:03:54,850
source of knowledge there stack overflow

00:03:51,220 --> 00:04:00,910
of course and hope that people haven't

00:03:54,850 --> 00:04:04,920
Too Faced the page all right so let's

00:04:00,910 --> 00:04:07,810
talk a little common uses of spy work

00:04:04,920 --> 00:04:09,370
embedded Linux engineers or budding of

00:04:07,810 --> 00:04:10,840
ended Linux engineers in here you

00:04:09,370 --> 00:04:12,640
probably have seen some of these maybe

00:04:10,840 --> 00:04:14,050
you didn't know all of them but just to

00:04:12,640 --> 00:04:17,859
give you an idea the types of

00:04:14,050 --> 00:04:21,040
peripherals that have spy bus support

00:04:17,859 --> 00:04:23,770
flash memory is a big one okay

00:04:21,040 --> 00:04:28,530
a lot of spy flashes analog digital

00:04:23,770 --> 00:04:31,390
converters very popular a lot of sensors

00:04:28,530 --> 00:04:34,720
thermocouples in particular is one type

00:04:31,390 --> 00:04:38,050
LCD controllers the chromium embedded

00:04:34,720 --> 00:04:40,420
controller has a spy interface to name

00:04:38,050 --> 00:04:44,230
some one particular thing in a known

00:04:40,420 --> 00:04:47,050
product so a lot of different things and

00:04:44,230 --> 00:04:49,360
a lot of these have one characteristic

00:04:47,050 --> 00:04:52,810
in common they're actually relatively

00:04:49,360 --> 00:04:56,169
high data rate peripherals compared to I

00:04:52,810 --> 00:04:58,390
to see peripherals so that's just a

00:04:56,169 --> 00:04:59,919
little low idea the flavor of things we

00:04:58,390 --> 00:05:01,960
see with spy so let's talk about

00:04:59,919 --> 00:05:05,169
fundamentals we really need to

00:05:01,960 --> 00:05:09,460
understand first what the spy signals

00:05:05,169 --> 00:05:11,919
are that we use and so pretty simple the

00:05:09,460 --> 00:05:14,169
defective standard name and so we're all

00:05:11,919 --> 00:05:17,380
driven by the original Motorola naming

00:05:14,169 --> 00:05:19,210
for that so will tend to see mozi or

00:05:17,380 --> 00:05:22,840
however you pronounce it that's how I do

00:05:19,210 --> 00:05:24,820
it master output slave input but as I

00:05:22,840 --> 00:05:26,500
show here there's lots of other names

00:05:24,820 --> 00:05:29,260
for it when you start looking at data

00:05:26,500 --> 00:05:31,990
sheets and and and your user manual and

00:05:29,260 --> 00:05:35,590
so forth you'll see so me see SPI you'll

00:05:31,990 --> 00:05:38,020
even see i2c naming which is kind of a

00:05:35,590 --> 00:05:41,290
little bit of a problem sometimes on

00:05:38,020 --> 00:05:44,260
data sheets miso master input slave

00:05:41,290 --> 00:05:46,510
output okay and the name gives you a

00:05:44,260 --> 00:05:49,390
clue of what direction things are going

00:05:46,510 --> 00:05:50,950
that's the beauty of those right same

00:05:49,390 --> 00:05:52,900
naming issues

00:05:50,950 --> 00:05:55,510
okay because it's a de facto standard

00:05:52,900 --> 00:05:58,270
people will go and adjust things a bit

00:05:55,510 --> 00:06:01,510
in their version your shield serial

00:05:58,270 --> 00:06:03,580
clock which is a master output and your

00:06:01,510 --> 00:06:09,040
slaves select the master output so this

00:06:03,580 --> 00:06:11,890
is the simple basic original way that

00:06:09,040 --> 00:06:14,410
spy shows up the basic symbols okay and

00:06:11,890 --> 00:06:17,710
the slave select that's also known as

00:06:14,410 --> 00:06:19,930
chip select and we'll see that that's

00:06:17,710 --> 00:06:26,050
how it gets referred to later in the the

00:06:19,930 --> 00:06:28,690
kernel stuff as well okay so Wow

00:06:26,050 --> 00:06:31,390
I am excellent at drawing diagrams as

00:06:28,690 --> 00:06:33,400
you see so with the little help from

00:06:31,390 --> 00:06:36,160
tools so that's about as good as it gets

00:06:33,400 --> 00:06:37,930
so we like things simple so first we

00:06:36,160 --> 00:06:41,500
show the most simple thing possible

00:06:37,930 --> 00:06:43,330
right those four signals right exactly

00:06:41,500 --> 00:06:48,280
the directions I promised them and

00:06:43,330 --> 00:06:50,140
everything marvellous right so now now

00:06:48,280 --> 00:06:53,050
we want to look at timing diagrams

00:06:50,140 --> 00:06:56,440
because timing diagrams are important in

00:06:53,050 --> 00:07:01,120
understanding spy so the best thing to

00:06:56,440 --> 00:07:04,090
do is take a look at what a basic 8-bit

00:07:01,120 --> 00:07:07,630
read and write will look like on spy bus

00:07:04,090 --> 00:07:10,360
so here we see data is not stable to

00:07:07,630 --> 00:07:12,370
these spots okay so we've got our some

00:07:10,360 --> 00:07:15,010
bits notice that we're doing the most

00:07:12,370 --> 00:07:18,430
significant bit first on the wire here

00:07:15,010 --> 00:07:20,260
okay in it this was a write mode will

00:07:18,430 --> 00:07:22,150
talk about modes in a second that's a

00:07:20,260 --> 00:07:25,210
very important part concept to

00:07:22,150 --> 00:07:27,910
understand in spy we don't care about

00:07:25,210 --> 00:07:30,130
the master in write this is the right so

00:07:27,910 --> 00:07:34,420
we're only seeing data on this mozi line

00:07:30,130 --> 00:07:37,930
okay on the read converse happens here

00:07:34,420 --> 00:07:40,510
okay and so what you see is you see the

00:07:37,930 --> 00:07:43,000
chip select line okay

00:07:40,510 --> 00:07:45,670
being asserted Loeb in this basic thing

00:07:43,000 --> 00:07:47,560
through this whole transfer or we'll

00:07:45,670 --> 00:07:51,190
just call it a cycle for the moment okay

00:07:47,560 --> 00:07:55,540
and you'll see that the data here is

00:07:51,190 --> 00:07:59,440
latched okay on the rising edge okay and

00:07:55,540 --> 00:08:02,360
the same thing is true okay on a read

00:07:59,440 --> 00:08:04,250
and you'll see that the chip select

00:08:02,360 --> 00:08:06,909
low during that whole transferences so

00:08:04,250 --> 00:08:12,530
that's your basic transfer simple right

00:08:06,909 --> 00:08:15,080
so now we need to understand spy modes

00:08:12,530 --> 00:08:16,729
right I hit you with spy mode on there I

00:08:15,080 --> 00:08:18,139
don't tell you what it is now I'll tell

00:08:16,729 --> 00:08:21,349
you what it is

00:08:18,139 --> 00:08:23,840
so it's essentially clock polarity and

00:08:21,349 --> 00:08:25,789
face of the clock relative to where

00:08:23,840 --> 00:08:29,599
we're latching the data a very simple

00:08:25,789 --> 00:08:33,800
way to look at it is that when when you

00:08:29,599 --> 00:08:36,829
have clock polarity where the idle state

00:08:33,800 --> 00:08:41,000
of the clock is low then you see pole is

00:08:36,829 --> 00:08:44,060
0 ok and the idle state I then it's 1 ok

00:08:41,000 --> 00:08:47,120
and then o'clock phase it's simply data

00:08:44,060 --> 00:08:50,630
is latched falling and output on rising

00:08:47,120 --> 00:08:52,310
and one is data latched on rising output

00:08:50,630 --> 00:08:54,260
falling we're going to take a look at

00:08:52,310 --> 00:08:56,000
this visually because it doesn't always

00:08:54,260 --> 00:08:59,899
make sense just with a bunch of words

00:08:56,000 --> 00:09:02,450
right but if you understand the simple

00:08:59,899 --> 00:09:05,750
binary there then you'll see that mode

00:09:02,450 --> 00:09:08,420
numbers are simple mapping in this table

00:09:05,750 --> 00:09:09,050
so those mode numbers you're seeing 0 1

00:09:08,420 --> 00:09:11,959
2 3

00:09:09,050 --> 00:09:14,600
as you see references and spy this is

00:09:11,959 --> 00:09:18,529
what they mean and then we're going to

00:09:14,600 --> 00:09:22,190
show you what it looks like in the

00:09:18,529 --> 00:09:24,199
timing world so you can see why I'm

00:09:22,190 --> 00:09:28,220
using a lot of laser pointer now because

00:09:24,199 --> 00:09:30,529
it takes a bit to look at this so once

00:09:28,220 --> 00:09:32,360
again we're looking at one version of

00:09:30,529 --> 00:09:34,579
what I showed before and so we're just

00:09:32,360 --> 00:09:36,649
going to look at right in this case so

00:09:34,579 --> 00:09:39,350
in each case I just drop out the Mesa

00:09:36,649 --> 00:09:42,199
line we're just looking at output and so

00:09:39,350 --> 00:09:45,980
I've got data here ok

00:09:42,199 --> 00:09:48,740
my clock is i/o low as I promised ok and

00:09:45,980 --> 00:09:51,170
right mode 0 data lat is latched on the

00:09:48,740 --> 00:09:56,329
rising edge so that corresponds back to

00:09:51,170 --> 00:09:59,120
that mode 0 ok right mode 1 my clock is

00:09:56,329 --> 00:10:01,250
idle low all right and it clocks but the

00:09:59,120 --> 00:10:02,899
data is getting latched here on the

00:10:01,250 --> 00:10:05,209
falling edge and you see falling edge

00:10:02,899 --> 00:10:07,750
lines up with our data stable all the

00:10:05,209 --> 00:10:11,839
way down so that's right mode 0 and 1

00:10:07,750 --> 00:10:13,300
visually and then now when we when we go

00:10:11,839 --> 00:10:17,290
to

00:10:13,300 --> 00:10:19,540
and when we go to write mode - these are

00:10:17,290 --> 00:10:22,600
both where she polls one okay on the

00:10:19,540 --> 00:10:24,400
slide and so what you see is our clock

00:10:22,600 --> 00:10:26,890
is idle hi okay

00:10:24,400 --> 00:10:28,780
data is latched on the falling edge and

00:10:26,890 --> 00:10:31,660
so you see out lining up and the same

00:10:28,780 --> 00:10:34,030
thing our clocks is idle hi in this case

00:10:31,660 --> 00:10:36,460
and it's latched on the rising edge in

00:10:34,030 --> 00:10:38,530
write mode three that simple works the

00:10:36,460 --> 00:10:41,830
same way when you're doing a read but we

00:10:38,530 --> 00:10:44,050
just need to show you well the the the

00:10:41,830 --> 00:10:47,440
cases in just the right to simplify the

00:10:44,050 --> 00:10:50,320
timing diagram okay

00:10:47,440 --> 00:10:51,670
alright so great simple right we know

00:10:50,320 --> 00:10:54,670
everything we need to know about spy

00:10:51,670 --> 00:10:57,220
except it then gets more complicated in

00:10:54,670 --> 00:10:59,110
the real world we have lots of simple

00:10:57,220 --> 00:11:02,080
cases that work like that you might just

00:10:59,110 --> 00:11:03,580
have one device but the reality is

00:11:02,080 --> 00:11:05,890
you're going to have quite a few and

00:11:03,580 --> 00:11:08,530
that's where your chip select comes into

00:11:05,890 --> 00:11:10,990
play okay we showed on the timing

00:11:08,530 --> 00:11:14,760
diagram that chip select being asserted

00:11:10,990 --> 00:11:20,320
low typically when I was showing the the

00:11:14,760 --> 00:11:22,390
the mode 0 examples and each slave has a

00:11:20,320 --> 00:11:25,660
chip select okay so if you have multiple

00:11:22,390 --> 00:11:28,000
spy slaves you would have the chip

00:11:25,660 --> 00:11:31,210
select being independently asserted

00:11:28,000 --> 00:11:34,900
alright to handle so that it would

00:11:31,210 --> 00:11:37,750
handle that right okay the next thing

00:11:34,900 --> 00:11:39,160
that you see is there's daisy chaining

00:11:37,750 --> 00:11:41,230
and there's a common type of daisy

00:11:39,160 --> 00:11:45,040
chaining where it's the inputs to

00:11:41,230 --> 00:11:47,080
outputs okay so of of the devices

00:11:45,040 --> 00:11:51,220
there's another rarer one which is where

00:11:47,080 --> 00:11:53,020
chip selects get daisy chained and i see

00:11:51,220 --> 00:11:55,420
one person perplexed by that they've

00:11:53,020 --> 00:11:57,520
never seen it and but that's the beauty

00:11:55,420 --> 00:11:59,860
of de facto standard everybody can do

00:11:57,520 --> 00:12:02,200
whatever they want and i could tell you

00:11:59,860 --> 00:12:05,020
that the ana dime field programmable

00:12:02,200 --> 00:12:07,270
analog arrays actually do this chip

00:12:05,020 --> 00:12:11,320
select daisy chaining which is super

00:12:07,270 --> 00:12:13,930
ugly so lots of lots of ugliness then we

00:12:11,320 --> 00:12:17,680
get into some cool stuff we talked about

00:12:13,930 --> 00:12:20,260
flash right being a big use case right

00:12:17,680 --> 00:12:23,710
and it started rigidly as these single

00:12:20,260 --> 00:12:26,850
lane flashes and now okay

00:12:23,710 --> 00:12:29,800
instead of one me so you can have n

00:12:26,850 --> 00:12:31,570
mesos okay

00:12:29,800 --> 00:12:35,950
it's a little bit more complicated than

00:12:31,570 --> 00:12:40,060
that but on on a reed you can have dual

00:12:35,950 --> 00:12:42,340
or quad measles typically in those

00:12:40,060 --> 00:12:44,350
devices and of course now you have n

00:12:42,340 --> 00:12:46,270
times bandwidth when you're doing reeds

00:12:44,350 --> 00:12:49,090
which is that fast path that they're

00:12:46,270 --> 00:12:52,480
trying to optimize okay and then we have

00:12:49,090 --> 00:12:54,490
the micro wire three wire variants that

00:12:52,480 --> 00:12:59,950
one I promised except when it's not for

00:12:54,490 --> 00:13:03,070
wire and they handle half duplex okay

00:12:59,950 --> 00:13:05,560
well half duplex so me so on most of

00:13:03,070 --> 00:13:10,030
your combined on the same line so few

00:13:05,560 --> 00:13:12,010
different variants is that and again

00:13:10,030 --> 00:13:15,760
another one of my masterful drawings

00:13:12,010 --> 00:13:18,130
where you see how you hook up you know

00:13:15,760 --> 00:13:20,440
three different spice waves notice as

00:13:18,130 --> 00:13:22,140
promised that there's multiple chip

00:13:20,440 --> 00:13:26,320
selects I'm I'm using the original

00:13:22,140 --> 00:13:29,200
terminology slave select they're CCC

00:13:26,320 --> 00:13:31,390
slave select one two and three are only

00:13:29,200 --> 00:13:34,870
routed to each of those and all the

00:13:31,390 --> 00:13:38,200
signals go appropriately to all three

00:13:34,870 --> 00:13:42,250
devices okay so one master many

00:13:38,200 --> 00:13:46,150
peripherals are slaves so now if you can

00:13:42,250 --> 00:13:50,830
see this a chart and apologize I can't

00:13:46,150 --> 00:13:52,810
point to both sides but now we look at

00:13:50,830 --> 00:13:55,030
multiple slaves what does that timing

00:13:52,810 --> 00:13:57,730
diagram look like well it's exactly the

00:13:55,030 --> 00:14:00,160
same except we've got three chip selects

00:13:57,730 --> 00:14:02,860
so again I just have to pick one mode

00:14:00,160 --> 00:14:05,050
for illustration purposes and we're

00:14:02,860 --> 00:14:08,950
latching on that rising edge right and

00:14:05,050 --> 00:14:10,390
it's it's the clock was idle low right

00:14:08,950 --> 00:14:12,940
we're latching on the rising is but

00:14:10,390 --> 00:14:14,470
notice that the chip select right before

00:14:12,940 --> 00:14:17,800
that clock edge we're it's going to

00:14:14,470 --> 00:14:20,980
latch it's it goes low for that entire

00:14:17,800 --> 00:14:24,580
cycle then here this next set of data on

00:14:20,980 --> 00:14:26,440
slave select to okay and then slave

00:14:24,580 --> 00:14:29,650
select three so pretty straightforward

00:14:26,440 --> 00:14:31,840
there and those are the basics

00:14:29,650 --> 00:14:33,760
fundamentals so now we can talk about

00:14:31,840 --> 00:14:37,010
Linux stuff all right

00:14:33,760 --> 00:14:44,330
so conceptionally

00:14:37,010 --> 00:14:48,410
in get my here yeah

00:14:44,330 --> 00:14:50,870
so now conceptually with with Linux we

00:14:48,410 --> 00:14:53,990
have the concepts of controller and

00:14:50,870 --> 00:14:57,260
protocol drivers okay and controller

00:14:53,990 --> 00:14:59,090
drivers support a spymaster device so

00:14:57,260 --> 00:15:02,180
when we looked at that fundamental piece

00:14:59,090 --> 00:15:04,310
of hardware whatever houses that Pete

00:15:02,180 --> 00:15:07,610
that peripheral that IP block right

00:15:04,310 --> 00:15:10,820
normally in our SOC these days we're

00:15:07,610 --> 00:15:14,330
that's the driver that that runs that

00:15:10,820 --> 00:15:17,120
hardware okay and so things are

00:15:14,330 --> 00:15:20,660
carefully separated in the spy subsystem

00:15:17,120 --> 00:15:23,660
so that everything for the controller is

00:15:20,660 --> 00:15:26,630
just the basic pieces to do clock

00:15:23,660 --> 00:15:28,250
control chip select control think back

00:15:26,630 --> 00:15:31,160
to our signals right we're dealing with

00:15:28,250 --> 00:15:33,890
that zero clock signal right the chip

00:15:31,160 --> 00:15:36,080
selects right and then running that

00:15:33,890 --> 00:15:39,110
shift register that we talked about

00:15:36,080 --> 00:15:41,960
right and there's a lot of details

00:15:39,110 --> 00:15:43,670
involved in that but at a high level it

00:15:41,960 --> 00:15:47,810
doesn't know anything about your end

00:15:43,670 --> 00:15:51,200
peripheral right now so an example would

00:15:47,810 --> 00:15:54,680
be take take the Raspberry Pi series the

00:15:51,200 --> 00:15:57,050
BCM 2035 aux driver that the example of

00:15:54,680 --> 00:16:00,260
a spy controller driver you might use

00:15:57,050 --> 00:16:03,580
okay so now protocol drivers they

00:16:00,260 --> 00:16:06,410
support whatever's needed to drive the

00:16:03,580 --> 00:16:10,580
actual functionality of that spice wave

00:16:06,410 --> 00:16:12,500
in our block diagrams right and so this

00:16:10,580 --> 00:16:15,650
is completely based on a concept of

00:16:12,500 --> 00:16:18,410
messages and transfers which is Linux

00:16:15,650 --> 00:16:22,190
terminology okay and we'll talk a little

00:16:18,410 --> 00:16:24,830
bit more about that and the protocol

00:16:22,190 --> 00:16:28,520
driver doesn't know anything about your

00:16:24,830 --> 00:16:30,440
controller driver right so it relies

00:16:28,520 --> 00:16:32,810
completely on the controller driver to

00:16:30,440 --> 00:16:34,490
do all that chip select work right all

00:16:32,810 --> 00:16:35,600
the shifting and stuff so it's neatly

00:16:34,490 --> 00:16:37,820
separated

00:16:35,600 --> 00:16:40,050
alright so an example there would be

00:16:37,820 --> 00:16:44,670
let's say you were using a

00:16:40,050 --> 00:16:49,110
a DC in the iio subsystem like MC p300

00:16:44,670 --> 00:16:51,209
eight that's a protocol driver and if

00:16:49,110 --> 00:16:53,459
you're familiar with spy dev which we'll

00:16:51,209 --> 00:16:55,440
talk way later about and user space

00:16:53,459 --> 00:17:00,260
stuff that is an example of a protocol

00:16:55,440 --> 00:17:03,959
driver as well okay so how do we do

00:17:00,260 --> 00:17:06,689
communication in the Linux PI sub system

00:17:03,959 --> 00:17:08,809
and so fundamentally as I promised the

00:17:06,689 --> 00:17:14,699
communications are broken up into

00:17:08,809 --> 00:17:17,699
transfers and messages and and so a

00:17:14,699 --> 00:17:21,990
transfer is a single operation between a

00:17:17,699 --> 00:17:24,689
master and slave okay and so the the

00:17:21,990 --> 00:17:27,660
structures that are the the transfer

00:17:24,689 --> 00:17:30,210
structure has things like transmit and

00:17:27,660 --> 00:17:34,050
receive buffer pointers okay

00:17:30,210 --> 00:17:36,450
it has fields to control chip select

00:17:34,050 --> 00:17:38,460
behavior after operations what's what's

00:17:36,450 --> 00:17:41,160
the behavior of that chip select as as

00:17:38,460 --> 00:17:43,740
to whether it becomes D asserted in

00:17:41,160 --> 00:17:45,690
between transfers before the next one

00:17:43,740 --> 00:17:48,660
and we'll talk a little bit more about

00:17:45,690 --> 00:17:51,750
that later and and how tricky that can

00:17:48,660 --> 00:17:54,179
be and things like you may need a delay

00:17:51,750 --> 00:17:56,309
after your transfer so all this goes

00:17:54,179 --> 00:18:00,179
into when you're looking at that data

00:17:56,309 --> 00:18:02,850
sheet for your your peripheral it has

00:18:00,179 --> 00:18:04,800
timing requirements and it may need a

00:18:02,850 --> 00:18:06,750
certain span of time before you send

00:18:04,800 --> 00:18:09,330
that next transfer whatever it is it

00:18:06,750 --> 00:18:12,750
depends on the protocol it implements

00:18:09,330 --> 00:18:16,620
okay so you're able to define all those

00:18:12,750 --> 00:18:19,440
things in there in a transfer and then a

00:18:16,620 --> 00:18:22,890
message is just an atomic sequence of

00:18:19,440 --> 00:18:24,809
these transfers so and then a message is

00:18:22,890 --> 00:18:28,169
actually that fundamental argument to

00:18:24,809 --> 00:18:32,100
all the spy subsystem transfer api's all

00:18:28,169 --> 00:18:35,700
right so basically imagine a linked list

00:18:32,100 --> 00:18:39,900
of transfers right and another great

00:18:35,700 --> 00:18:42,600
diagram right so that's what a sly

00:18:39,900 --> 00:18:44,730
message looks like so now let's get into

00:18:42,600 --> 00:18:46,700
use cases and that'll take us into how

00:18:44,730 --> 00:18:50,540
we do these various things

00:18:46,700 --> 00:18:52,580
so if we explore some of these common

00:18:50,540 --> 00:18:54,680
use cases that people need to do the

00:18:52,580 --> 00:18:56,930
first thing people seem to want to do is

00:18:54,680 --> 00:19:00,080
I need to figure out how to hook up this

00:18:56,930 --> 00:19:02,690
device that's on my board I've got right

00:19:00,080 --> 00:19:05,840
and there's already a kernel driver for

00:19:02,690 --> 00:19:08,000
it right so that's one the next thing is

00:19:05,840 --> 00:19:11,450
I need to write a kernel protocol driver

00:19:08,000 --> 00:19:14,150
right and then the next big thing and

00:19:11,450 --> 00:19:15,710
less common right because most of them

00:19:14,150 --> 00:19:17,870
are written for us is I need to write a

00:19:15,710 --> 00:19:19,970
kernel controller driver and then

00:19:17,870 --> 00:19:22,190
finally one of the big ones and you see

00:19:19,970 --> 00:19:24,530
kind of especially from people doing

00:19:22,190 --> 00:19:27,560
testing and some of the maker type

00:19:24,530 --> 00:19:30,290
projects and user space is I want to do

00:19:27,560 --> 00:19:35,720
something in user space to drive my spy

00:19:30,290 --> 00:19:39,260
slave okay all right so let's jump into

00:19:35,720 --> 00:19:42,020
adding a spy device to your system so

00:19:39,260 --> 00:19:43,790
the first thing is we need to learn how

00:19:42,020 --> 00:19:46,370
to read data sheets because a lot of

00:19:43,790 --> 00:19:48,080
people can't seem to read data sheets so

00:19:46,370 --> 00:19:52,580
we're going to force you through reading

00:19:48,080 --> 00:19:54,350
a data sheet very quickly and show you

00:19:52,580 --> 00:19:56,630
what I mean by that and the type of

00:19:54,350 --> 00:19:58,730
things you need to pick out but there's

00:19:56,630 --> 00:20:01,100
three methods okay after we do go

00:19:58,730 --> 00:20:04,400
through that that we hook we hook up a

00:20:01,100 --> 00:20:06,680
protocol driver in our system and first

00:20:04,400 --> 00:20:10,040
is the ubiquitous device tree method

00:20:06,680 --> 00:20:12,980
that most of you will use then there's

00:20:10,040 --> 00:20:15,410
the board file method which some systems

00:20:12,980 --> 00:20:18,920
will still use especially old vendor

00:20:15,410 --> 00:20:21,380
trees if you're unlucky enough to be

00:20:18,920 --> 00:20:26,660
there sometimes some of the x86 stuff

00:20:21,380 --> 00:20:29,210
because a CPI is tough to use and so

00:20:26,660 --> 00:20:33,560
you'll see the ladder too mostly on x86

00:20:29,210 --> 00:20:36,920
and vendor kernels these days but we'll

00:20:33,560 --> 00:20:38,480
look at all of them so yeah so now we

00:20:36,920 --> 00:20:41,420
learn how to read a datasheet by me

00:20:38,480 --> 00:20:42,650
picking out a few things so you're

00:20:41,420 --> 00:20:44,900
looking at a datasheet and it's like

00:20:42,650 --> 00:20:46,760
what is this thing sometimes you will

00:20:44,900 --> 00:20:49,760
not always have the thing tell you oh

00:20:46,760 --> 00:20:53,330
this is a spi device and might just see

00:20:49,760 --> 00:20:55,460
say it's a three wire or two wire or

00:20:53,330 --> 00:20:57,299
something synchronous serial interface

00:20:55,460 --> 00:21:00,749
and so you might have to do

00:20:57,299 --> 00:21:02,340
detective work on that the next thing

00:21:00,749 --> 00:21:04,799
that's important is you're going to

00:21:02,340 --> 00:21:07,769
start remembering these timing diagrams

00:21:04,799 --> 00:21:10,080
and saying gosh it's a good thing it

00:21:07,769 --> 00:21:13,169
told me spy because it's showing me here

00:21:10,080 --> 00:21:15,299
I to see signal names so that's the

00:21:13,169 --> 00:21:18,749
proof that there's data sheets that show

00:21:15,299 --> 00:21:21,600
you this is really out of the st7 7:35

00:21:18,749 --> 00:21:25,169
and if you've used like that the FB TFT

00:21:21,600 --> 00:21:28,970
driver the this is one of the parts

00:21:25,169 --> 00:21:33,690
that's supported in that so real device

00:21:28,970 --> 00:21:36,359
and so the idea here is you need to

00:21:33,690 --> 00:21:40,070
remember things like I need to figure

00:21:36,359 --> 00:21:43,049
out what's the maximum clock rate that

00:21:40,070 --> 00:21:46,470
that my device can can support right

00:21:43,049 --> 00:21:48,359
because I need to tell the system what

00:21:46,470 --> 00:21:49,889
the max clock rate is when I'm hooking

00:21:48,359 --> 00:21:52,350
up a device it's one of those critical

00:21:49,889 --> 00:21:54,389
things right so you're going to have to

00:21:52,350 --> 00:21:57,359
be able to read this timing diagram well

00:21:54,389 --> 00:22:02,029
it Maps exactly to what I was showing

00:21:57,359 --> 00:22:05,159
you because and resolutions awful here

00:22:02,029 --> 00:22:08,389
so you look at these two values you look

00:22:05,159 --> 00:22:11,789
further down in the table and you find

00:22:08,389 --> 00:22:14,519
you find the the hold times on these

00:22:11,789 --> 00:22:17,039
right and so you can get with simple

00:22:14,519 --> 00:22:18,899
addition you get the period and if

00:22:17,039 --> 00:22:20,730
you're any good at math I hope you can

00:22:18,899 --> 00:22:25,499
do minimal math you get the frequency

00:22:20,730 --> 00:22:27,149
right and so you've got a with those

00:22:25,499 --> 00:22:30,899
minimums you now have a maximum

00:22:27,149 --> 00:22:32,869
frequency out of that right so those are

00:22:30,899 --> 00:22:36,090
the kind of things you're looking for

00:22:32,869 --> 00:22:37,889
don't always expect to see spy jumping

00:22:36,090 --> 00:22:40,259
out at you or it's saying hey your

00:22:37,889 --> 00:22:42,299
maximum clock rates this right you need

00:22:40,259 --> 00:22:44,909
to actually read the timing diagram and

00:22:42,299 --> 00:22:46,799
understand it same thing goes when you

00:22:44,909 --> 00:22:49,919
start getting into the protocol pieces

00:22:46,799 --> 00:22:52,080
and so as we get down here

00:22:49,919 --> 00:22:53,759
further down a data sheet it's one thing

00:22:52,080 --> 00:22:57,570
to have that timing diagram and what the

00:22:53,759 --> 00:23:00,090
clock looks like for the individual bit

00:22:57,570 --> 00:23:02,340
clocking right but then when you get

00:23:00,090 --> 00:23:05,639
into the specific protocol of this

00:23:02,340 --> 00:23:07,950
device now it's showing me what kind of

00:23:05,639 --> 00:23:12,660
what kind of delay I have to have

00:23:07,950 --> 00:23:15,630
between the transfers okay so there's a

00:23:12,660 --> 00:23:17,100
delay here minimum and so that goes into

00:23:15,630 --> 00:23:19,320
things where I showed you with the

00:23:17,100 --> 00:23:21,450
transfer thing you know optional delay

00:23:19,320 --> 00:23:24,060
between transfers you may need to set

00:23:21,450 --> 00:23:26,460
that depending on how efficient your

00:23:24,060 --> 00:23:28,470
your protocol driver is trying to be if

00:23:26,460 --> 00:23:30,960
it's trying to maximize bandwidth on

00:23:28,470 --> 00:23:33,060
there you're trying to optimize exactly

00:23:30,960 --> 00:23:35,700
against this timing diagram to get your

00:23:33,060 --> 00:23:39,300
best performance so important that you

00:23:35,700 --> 00:23:41,190
understand and can read those just

00:23:39,300 --> 00:23:42,600
another example here with the mCP

00:23:41,190 --> 00:23:44,940
through zero zero eight I'm going to use

00:23:42,600 --> 00:23:46,190
this a little bit more in this talk

00:23:44,940 --> 00:23:49,650
that's good to show you two examples

00:23:46,190 --> 00:23:51,420
here here they told you what modes it

00:23:49,650 --> 00:23:54,270
uses to okay

00:23:51,420 --> 00:23:56,550
gave you a little bit of information

00:23:54,270 --> 00:23:58,320
don't get confused about conversion

00:23:56,550 --> 00:24:01,770
rates has nothing to do with our our

00:23:58,320 --> 00:24:04,380
actual spy clock and again same kind of

00:24:01,770 --> 00:24:07,470
things here right key high to low we're

00:24:04,380 --> 00:24:09,840
able to jump into here and see okay you

00:24:07,470 --> 00:24:12,390
know my minimum if I didn't clip this

00:24:09,840 --> 00:24:14,400
off those are those are minimum high and

00:24:12,390 --> 00:24:16,620
low times right so we got a 250

00:24:14,400 --> 00:24:19,820
nanosecond period and we can get our

00:24:16,620 --> 00:24:24,270
frequency or max frequency out of that

00:24:19,820 --> 00:24:27,060
all right and again same thing holds

00:24:24,270 --> 00:24:29,460
true that's just the basic what can I do

00:24:27,060 --> 00:24:32,220
with a clock but I also have the special

00:24:29,460 --> 00:24:34,080
protocol right I gotta send it commands

00:24:32,220 --> 00:24:36,000
of when to do an actual analog to

00:24:34,080 --> 00:24:38,550
digital conversion and then it's going

00:24:36,000 --> 00:24:41,610
to send me data back and so there's

00:24:38,550 --> 00:24:42,810
start bits there's certain delays and so

00:24:41,610 --> 00:24:45,180
you're going to have this protocol

00:24:42,810 --> 00:24:47,010
specific stuff that you're going to have

00:24:45,180 --> 00:24:49,080
to figure that out for your peripheral

00:24:47,010 --> 00:24:52,110
if you're writing those if you're just

00:24:49,080 --> 00:24:53,730
using an existing driver you know you

00:24:52,110 --> 00:24:55,410
probably just need to know that hey I

00:24:53,730 --> 00:24:58,140
need to know what the max frequency is

00:24:55,410 --> 00:24:59,940
if I don't have another example right on

00:24:58,140 --> 00:25:02,820
the web somewhere or I have a variant

00:24:59,940 --> 00:25:04,530
because you'll have like a miss family

00:25:02,820 --> 00:25:06,030
you know there's like thirty of these

00:25:04,530 --> 00:25:09,060
chips right and they'll have different

00:25:06,030 --> 00:25:10,770
zero clock maxes right so if you want to

00:25:09,060 --> 00:25:13,430
get the maximum rate you want to go

00:25:10,770 --> 00:25:17,760
double check that before you hook it up

00:25:13,430 --> 00:25:20,430
alrighty so now we get into examples

00:25:17,760 --> 00:25:22,260
and I sure fix this from doing this at

00:25:20,430 --> 00:25:25,920
FOSDEM because i had a black background

00:25:22,260 --> 00:25:28,170
that was terrible so first thing you

00:25:25,920 --> 00:25:30,060
want to do is this is all about showing

00:25:28,170 --> 00:25:32,760
you where to get the information we're

00:25:30,060 --> 00:25:35,130
going to use this MC p300 8 all the way

00:25:32,760 --> 00:25:37,440
through for all these examples now okay

00:25:35,130 --> 00:25:41,850
so the first thing is you need to know

00:25:37,440 --> 00:25:44,460
where to find device tree bindings okay

00:25:41,850 --> 00:25:46,110
if we're doing a device tree wise so

00:25:44,460 --> 00:25:48,810
you're going to use your documentation

00:25:46,110 --> 00:25:50,700
source either you're hitting hitting

00:25:48,810 --> 00:25:53,070
Google and you're seeing the lxr tree

00:25:50,700 --> 00:25:54,780
and free electrons hosted kernel stuff

00:25:53,070 --> 00:25:56,910
to read the read it there or you're

00:25:54,780 --> 00:25:59,250
looking in your local tree and down in

00:25:56,910 --> 00:26:01,800
the documentation device tree bindings

00:25:59,250 --> 00:26:05,040
directory and you hung around in there

00:26:01,800 --> 00:26:07,650
awhile and you find out oh here's my NCP

00:26:05,040 --> 00:26:10,440
through 0:08 binding well it's one of

00:26:07,650 --> 00:26:11,820
many chips in this binding and this is

00:26:10,440 --> 00:26:15,740
kind of trimmed a little bit so you can

00:26:11,820 --> 00:26:18,000
see but they show you they show you here

00:26:15,740 --> 00:26:22,470
now I'm favoring this side of the room

00:26:18,000 --> 00:26:25,530
of course in that list right is a

00:26:22,470 --> 00:26:28,050
compatible string and and just just to

00:26:25,530 --> 00:26:29,940
point out this isn't this isn't rocking

00:26:28,050 --> 00:26:31,650
device tree so I expect you to know at

00:26:29,940 --> 00:26:34,320
least the basics of that first because

00:26:31,650 --> 00:26:36,060
there's not enough time to do it all but

00:26:34,320 --> 00:26:37,950
you need to know that compatible string

00:26:36,060 --> 00:26:39,270
and of course they give you the example

00:26:37,950 --> 00:26:42,030
this should be familiar to people

00:26:39,270 --> 00:26:45,480
working with device tree okay but what's

00:26:42,030 --> 00:26:48,960
important with spy is there's the reg

00:26:45,480 --> 00:26:52,110
here okay and spy max frequency all

00:26:48,960 --> 00:26:56,040
right so this is actually the chip

00:26:52,110 --> 00:26:58,890
select number okay so that's a unique

00:26:56,040 --> 00:27:01,170
address on the bus essentially is how

00:26:58,890 --> 00:27:03,690
how that works out in the in the driver

00:27:01,170 --> 00:27:05,370
model and then your spy max frequency

00:27:03,690 --> 00:27:07,050
that we're really talking a lot about

00:27:05,370 --> 00:27:09,930
here right so that's why we needed to

00:27:07,050 --> 00:27:16,290
know that okay and so that's an example

00:27:09,930 --> 00:27:18,570
shows you how to hook it up now one

00:27:16,290 --> 00:27:20,430
thing I improved here was that somebody

00:27:18,570 --> 00:27:22,440
somebody had a question of where do

00:27:20,430 --> 00:27:25,350
these IDs get picked up right well

00:27:22,440 --> 00:27:27,090
here's here's you can see I kind of

00:27:25,350 --> 00:27:30,240
trimmed some stuff out here just I could

00:27:27,090 --> 00:27:30,909
fit it on a slide okay so you have in

00:27:30,240 --> 00:27:38,229
your

00:27:30,909 --> 00:27:41,139
driver this MTP 3200x1800 man pattern

00:27:38,229 --> 00:27:43,960
you'll see this for other data

00:27:41,139 --> 00:27:46,029
structures like ACP IDs will show an

00:27:43,960 --> 00:27:48,700
example of that as well so you see this

00:27:46,029 --> 00:27:51,309
common pattern there colonel right so if

00:27:48,700 --> 00:27:53,859
you look at that driver you'll see that

00:27:51,309 --> 00:27:55,809
it handles this compatible string here

00:27:53,859 --> 00:27:57,729
all right and then that it's able to

00:27:55,809 --> 00:28:00,119
bring in some chip specific info for

00:27:57,729 --> 00:28:02,679
that that variant of the family okay

00:28:00,119 --> 00:28:05,229
this is how it all gets hooked up if

00:28:02,679 --> 00:28:06,999
you're wondering where where this comes

00:28:05,229 --> 00:28:09,070
into the place it's all part of that

00:28:06,999 --> 00:28:12,460
driver definition that's all part of

00:28:09,070 --> 00:28:14,859
driver model okay so nothing nothing

00:28:12,460 --> 00:28:16,539
surprising here but then today that's

00:28:14,859 --> 00:28:18,970
how that compatible string gets matched

00:28:16,539 --> 00:28:20,799
in right and if you have if you have any

00:28:18,970 --> 00:28:22,989
confusion of what it's using you always

00:28:20,799 --> 00:28:25,599
go to the source and look at this okay

00:28:22,989 --> 00:28:27,279
last thing is all right I showed you

00:28:25,599 --> 00:28:29,409
where the driver side was I showed you

00:28:27,279 --> 00:28:31,779
where to get the binding information now

00:28:29,409 --> 00:28:35,259
you actually have to use it I'll show

00:28:31,779 --> 00:28:38,440
you in this case and and the overlay the

00:28:35,259 --> 00:28:41,559
overlay fragment syntax is changing as

00:28:38,440 --> 00:28:46,559
we speak so that that's a whole nother

00:28:41,559 --> 00:28:52,869
topic but this is at least a old style

00:28:46,559 --> 00:28:54,669
version it is what it is right so what

00:28:52,869 --> 00:28:56,470
you see here is exactly like that

00:28:54,669 --> 00:28:59,590
example in the binding we hook it up

00:28:56,470 --> 00:29:01,929
right and that's that max frequency we

00:28:59,590 --> 00:29:04,690
got out of that period right that we got

00:29:01,929 --> 00:29:06,729
off the three zero zero eight things so

00:29:04,690 --> 00:29:09,549
you do something like that if you're

00:29:06,729 --> 00:29:11,409
doing a static DTS entry the syntax is a

00:29:09,549 --> 00:29:14,349
bit different but obviously the meat of

00:29:11,409 --> 00:29:18,759
it here is the same so we went in to end

00:29:14,349 --> 00:29:20,409
on that hooking up that via DT not much

00:29:18,759 --> 00:29:23,139
different with the board file right

00:29:20,409 --> 00:29:25,950
don't use board files though I'm just

00:29:23,139 --> 00:29:30,580
showing you don't don't do this okay but

00:29:25,950 --> 00:29:32,649
that's that's where you that's where you

00:29:30,580 --> 00:29:35,080
would hook up the same things you know

00:29:32,649 --> 00:29:37,330
this chip selects zero you have to

00:29:35,080 --> 00:29:41,049
mention the bus number for the actual

00:29:37,330 --> 00:29:44,559
master here but essentially the same

00:29:41,049 --> 00:29:50,049
info there and use mod mod a alias to

00:29:44,559 --> 00:29:52,529
hook it up to that module and it gets in

00:29:50,049 --> 00:29:55,239
there either either if it was a old

00:29:52,529 --> 00:29:58,419
board file in building the kernel or

00:29:55,239 --> 00:30:00,820
sometimes I saw people on the middle

00:29:58,419 --> 00:30:03,489
board project just writing a module and

00:30:00,820 --> 00:30:10,389
doing this because it's too hard to do

00:30:03,489 --> 00:30:14,529
by a CPI all right did I say it was too

00:30:10,389 --> 00:30:16,389
hard to do by a CPI it is possible but

00:30:14,529 --> 00:30:18,190
as you see it's not designed for humans

00:30:16,389 --> 00:30:21,720
to read or at least not for me to read

00:30:18,190 --> 00:30:25,299
but what you see is if you were to do

00:30:21,720 --> 00:30:27,009
instantiate a spy device by a CPA CPI

00:30:25,299 --> 00:30:30,159
you have the same things you're telling

00:30:27,009 --> 00:30:34,899
it polarity all these different specs

00:30:30,159 --> 00:30:36,879
but the most important thing is the you

00:30:34,899 --> 00:30:38,679
know the the max frequency which of

00:30:36,879 --> 00:30:40,440
course they have in hex so it's not

00:30:38,679 --> 00:30:47,369
readable

00:30:40,440 --> 00:30:50,619
well it's readable but that's the a CPI

00:30:47,369 --> 00:30:53,399
alright so that covers that hookup case

00:30:50,619 --> 00:30:53,399
right and

00:30:54,839 --> 00:31:01,690
yeah so protocol drivers okay same first

00:31:00,190 --> 00:31:03,639
thing is they follow the standard driver

00:31:01,690 --> 00:31:05,649
model just like everything and that's

00:31:03,639 --> 00:31:07,839
you know when I'm showing up hooking up

00:31:05,649 --> 00:31:09,609
a driver I show you the driver IDs and I

00:31:07,839 --> 00:31:12,489
show you all those pieces it's all

00:31:09,609 --> 00:31:14,889
standard driver model it's just by using

00:31:12,489 --> 00:31:16,089
that and so I want to do a protocol

00:31:14,889 --> 00:31:18,759
driver and the kernel

00:31:16,089 --> 00:31:22,479
I need to do some basic things and I

00:31:18,759 --> 00:31:23,549
don't show everything but you need to

00:31:22,479 --> 00:31:26,529
find that driver

00:31:23,549 --> 00:31:29,139
structure right here I've got my

00:31:26,529 --> 00:31:32,259
protocol I need to have some power

00:31:29,139 --> 00:31:35,409
management ops you know those are all

00:31:32,259 --> 00:31:36,849
implementation details for your part but

00:31:35,409 --> 00:31:39,009
you know I need to have an entry point

00:31:36,849 --> 00:31:42,849
program to remove all standard driver

00:31:39,009 --> 00:31:44,649
model stuff ok once once you enter the

00:31:42,849 --> 00:31:47,980
probe though you can immediately start

00:31:44,649 --> 00:31:50,710
using kernel api's and we'll talk about

00:31:47,980 --> 00:31:53,379
the kernel api's now so kind of diving

00:31:50,710 --> 00:31:55,630
in for that use case perspective so what

00:31:53,379 --> 00:31:58,510
are the kernel API is available

00:31:55,630 --> 00:32:02,590
on to these protocol drivers well pretty

00:31:58,510 --> 00:32:05,590
simple to two big categories async and

00:32:02,590 --> 00:32:07,930
synchronous surprisingly enough right so

00:32:05,590 --> 00:32:10,300
first you have spy a think okay

00:32:07,930 --> 00:32:12,910
and so it's an asynchronous message

00:32:10,300 --> 00:32:15,310
request surprisingly enough and you get

00:32:12,910 --> 00:32:18,580
a callback executed when it completes

00:32:15,310 --> 00:32:22,690
okay you can execute those in any

00:32:18,580 --> 00:32:25,660
context okay and what does that mean

00:32:22,690 --> 00:32:27,460
well will mention down here so if we go

00:32:25,660 --> 00:32:30,400
to the spy sink it's a synchronous

00:32:27,460 --> 00:32:33,190
message request and we can only execute

00:32:30,400 --> 00:32:36,040
in a context it doesn't sleep okay so in

00:32:33,190 --> 00:32:36,670
a common case don't do it in irq context

00:32:36,040 --> 00:32:39,790
all right

00:32:36,670 --> 00:32:42,700
all these later things are all wrappers

00:32:39,790 --> 00:32:44,440
around spy async so there's not any real

00:32:42,700 --> 00:32:46,720
magic going on it's just that things

00:32:44,440 --> 00:32:50,110
going to wait for the transfer to

00:32:46,720 --> 00:32:51,760
complete and then return to you okay and

00:32:50,110 --> 00:32:54,400
then there's some helper functions that

00:32:51,760 --> 00:32:57,400
again wrap around spy sink spy right and

00:32:54,400 --> 00:32:59,620
spy read recall that I said that the

00:32:57,400 --> 00:33:01,030
message is that fundamental argument to

00:32:59,620 --> 00:33:04,180
everything so when you're using these

00:33:01,030 --> 00:33:06,670
you're handing it a message was just a

00:33:04,180 --> 00:33:08,560
list of these transfers right and those

00:33:06,670 --> 00:33:11,500
you're going to define those transfers

00:33:08,560 --> 00:33:13,480
as whatever satisfies the protocol

00:33:11,500 --> 00:33:17,070
specific to that part that you've

00:33:13,480 --> 00:33:20,110
carefully studied the datasheet for

00:33:17,070 --> 00:33:23,440
there's some other ones for special use

00:33:20,110 --> 00:33:27,220
cases we mentioned how flash devices

00:33:23,440 --> 00:33:31,330
commonly now especially all right our

00:33:27,220 --> 00:33:33,730
dual well mostly quad now quad spy

00:33:31,330 --> 00:33:36,670
capable so there's optimized routines

00:33:33,730 --> 00:33:39,400
for those and also these are optimized

00:33:36,670 --> 00:33:42,430
because because of the quad spy things

00:33:39,400 --> 00:33:45,880
being such low pin count they're

00:33:42,430 --> 00:33:48,640
replacing nor flash pair of old-style

00:33:45,880 --> 00:33:51,370
parallel nor flash because speeds are

00:33:48,640 --> 00:33:55,600
very similar now and the reliability of

00:33:51,370 --> 00:33:58,300
those and so there's actually on think

00:33:55,600 --> 00:34:02,580
take for example the DR a 7x X stuff for

00:33:58,300 --> 00:34:04,960
P I they have n mmm IO

00:34:02,580 --> 00:34:08,440
controller that translates into flash

00:34:04,960 --> 00:34:13,950
commands okay and so it can actually xip

00:34:08,440 --> 00:34:19,510
out of these spy flashes that way then

00:34:13,950 --> 00:34:21,340
we have these other helper api's in that

00:34:19,510 --> 00:34:22,990
allow us to create and build up that

00:34:21,340 --> 00:34:25,810
message right it's that list of

00:34:22,990 --> 00:34:28,450
transfers so we need we need helpers to

00:34:25,810 --> 00:34:31,030
help us out here spy message Annette ad

00:34:28,450 --> 00:34:33,399
tail some of those patterns will look

00:34:31,030 --> 00:34:34,990
familiar to other subsystems and the

00:34:33,399 --> 00:34:37,990
colonel and how data structures are

00:34:34,990 --> 00:34:40,300
managed so you can build up your message

00:34:37,990 --> 00:34:44,010
as a bunch of transfers all with

00:34:40,300 --> 00:34:44,010
relatively unique characteristics

00:34:44,909 --> 00:34:51,460
alright so that covers protocol drivers

00:34:48,570 --> 00:34:55,360
controller drivers again standard linux

00:34:51,460 --> 00:34:59,170
module or model you first allocate a

00:34:55,360 --> 00:35:02,200
controller with spy alik master and then

00:34:59,170 --> 00:35:04,750
you set controller fields and methods we

00:35:02,200 --> 00:35:10,900
show just the basics okay

00:35:04,750 --> 00:35:12,760
common so mode bits for example all

00:35:10,900 --> 00:35:14,980
these flags you show what the

00:35:12,760 --> 00:35:17,410
capabilities are of the controller not

00:35:14,980 --> 00:35:20,250
every controller conduced by RX quad

00:35:17,410 --> 00:35:24,280
right that would apply to those those

00:35:20,250 --> 00:35:27,340
controllers that can handle the the four

00:35:24,280 --> 00:35:29,410
lanes miso lanes for example in that

00:35:27,340 --> 00:35:34,060
mode spy loop where it can do a loopback

00:35:29,410 --> 00:35:36,880
and hardware you have to implement set

00:35:34,060 --> 00:35:41,680
up and clean up and you need to do

00:35:36,880 --> 00:35:42,910
implement one of these okay and many of

00:35:41,680 --> 00:35:46,930
the masters they've moved to the

00:35:42,910 --> 00:35:50,380
transfer one model because that allows

00:35:46,930 --> 00:35:52,470
you to let the core support GPIO chip

00:35:50,380 --> 00:35:55,840
selects there's a lot of demand to

00:35:52,470 --> 00:35:57,310
expand out chip selects or because

00:35:55,840 --> 00:35:59,110
there's a lot of controllers that just

00:35:57,310 --> 00:36:02,020
don't even have a hardware chip select

00:35:59,110 --> 00:36:03,910
mechanism that's necessary as well so

00:36:02,020 --> 00:36:06,700
you'll see this implemented more

00:36:03,910 --> 00:36:08,470
commonly on some of them and then

00:36:06,700 --> 00:36:13,870
finally when you've got that all set up

00:36:08,470 --> 00:36:15,240
you just register master alright talk

00:36:13,870 --> 00:36:20,470
about

00:36:15,240 --> 00:36:22,180
userspace yeah well alright so user

00:36:20,470 --> 00:36:24,670
space driver probably many of you have

00:36:22,180 --> 00:36:27,490
heard of spy dev or used it and so forth

00:36:24,670 --> 00:36:31,090
so you know it's intended primarily for

00:36:27,490 --> 00:36:33,100
development and test in reality we know

00:36:31,090 --> 00:36:35,470
that everybody's got their Python and

00:36:33,100 --> 00:36:37,420
golang and Ruby and every other thing

00:36:35,470 --> 00:36:41,730
build on top of it right to do their

00:36:37,420 --> 00:36:44,830
their maker cases okay so very popular

00:36:41,730 --> 00:36:47,290
for people doing obvious projects and so

00:36:44,830 --> 00:36:52,060
forth but but you know in many test

00:36:47,290 --> 00:36:56,260
scenarios if you're using that common DT

00:36:52,060 --> 00:36:58,330
case okay well first first let me say

00:36:56,260 --> 00:36:59,590
and you know normally normally you're

00:36:58,330 --> 00:37:01,390
going to want to write a kernel driver

00:36:59,590 --> 00:37:04,660
you know you're not going to want to do

00:37:01,390 --> 00:37:07,090
a spy dev user space driver you're going

00:37:04,660 --> 00:37:08,740
to you're going to work hard you

00:37:07,090 --> 00:37:10,900
probably probably the reason that you

00:37:08,740 --> 00:37:13,090
were using spy in the first place is

00:37:10,900 --> 00:37:14,680
that it's a high-performance part you're

00:37:13,090 --> 00:37:16,510
better off doing a kernel driver and

00:37:14,680 --> 00:37:18,190
everything but there's obviously lots of

00:37:16,510 --> 00:37:20,530
cases where you just want to whack at

00:37:18,190 --> 00:37:22,690
something and have maybe a test case or

00:37:20,530 --> 00:37:25,330
so forth so I mean that's that's really

00:37:22,690 --> 00:37:27,180
the most common place we're of use where

00:37:25,330 --> 00:37:30,130
people are just hacking around with it

00:37:27,180 --> 00:37:35,740
so super useful but how do we hook it up

00:37:30,130 --> 00:37:38,170
right and so you can you can leverage in

00:37:35,740 --> 00:37:40,480
upstream one of these compatible strings

00:37:38,170 --> 00:37:41,950
because you just kind of you know doing

00:37:40,480 --> 00:37:44,410
some testing and stuff and then you

00:37:41,950 --> 00:37:46,660
don't have to to modify anything I mean

00:37:44,410 --> 00:37:49,300
if you needed to put something extra in

00:37:46,660 --> 00:37:52,540
there you could and I know it sometimes

00:37:49,300 --> 00:37:55,570
accept new compatible strings upstream

00:37:52,540 --> 00:37:58,080
where it's a legitimate device that's

00:37:55,570 --> 00:38:02,770
not going to ever have a kernel driver

00:37:58,080 --> 00:38:05,170
and then finally in the spy dead driver

00:38:02,770 --> 00:38:06,760
the other way you can hook it up well

00:38:05,170 --> 00:38:09,280
you can do the board file method

00:38:06,760 --> 00:38:10,830
exactly how we showed the other one but

00:38:09,280 --> 00:38:13,930
the ACPI

00:38:10,830 --> 00:38:17,770
IDs that are supported you can you can

00:38:13,930 --> 00:38:21,940
use those if you're doing a an override

00:38:17,770 --> 00:38:24,220
tune ACPI override loading so you can do

00:38:21,940 --> 00:38:26,599
that or you can modify your vendor

00:38:24,220 --> 00:38:32,069
kernel and add something else

00:38:26,599 --> 00:38:34,499
so that's how you hook that up all right

00:38:32,069 --> 00:38:38,029
so what happens once that driver binds

00:38:34,499 --> 00:38:41,630
okay we've hooked it up it binds the

00:38:38,029 --> 00:38:45,269
magic that happens is that we have this

00:38:41,630 --> 00:38:49,319
assist class pydev devices get created

00:38:45,269 --> 00:38:52,140
and so bus is your your master ID

00:38:49,319 --> 00:38:54,690
numerical ID is their allocated in the

00:38:52,140 --> 00:38:57,089
system and then there's a device for

00:38:54,690 --> 00:38:58,950
each chip select so if you had three

00:38:57,089 --> 00:39:01,529
chip selects you're going to have you

00:38:58,950 --> 00:39:06,900
know bus zero dot you know zero one two

00:39:01,529 --> 00:39:09,839
three okay and then you also get the dev

00:39:06,900 --> 00:39:13,170
spy dev same thing okay it's a simple

00:39:09,839 --> 00:39:16,710
character device open close read write I

00:39:13,170 --> 00:39:18,359
say rewrite half-duplex write the one

00:39:16,710 --> 00:39:20,910
thing the one thing I think and

00:39:18,359 --> 00:39:23,579
neglected earlier to say inherently if

00:39:20,910 --> 00:39:26,009
we go back to the beginning and look at

00:39:23,579 --> 00:39:29,309
that spy bus right it's inherently a

00:39:26,009 --> 00:39:31,319
full duplex bus right every time you

00:39:29,309 --> 00:39:33,719
talk in a bit out there's another one

00:39:31,319 --> 00:39:36,390
coming in however in your protocols

00:39:33,719 --> 00:39:39,390
right you'll find that you know some

00:39:36,390 --> 00:39:41,249
some parts like the ST 77035 you don't

00:39:39,390 --> 00:39:44,400
need to hook up me so it's a one-way

00:39:41,249 --> 00:39:46,019
path right so when you're actually if

00:39:44,400 --> 00:39:48,930
you think back to the transfers we

00:39:46,019 --> 00:39:51,719
looked at before there's TX and rx bus

00:39:48,930 --> 00:39:53,940
the trend you'll see you're you're

00:39:51,719 --> 00:39:55,950
delivering data in one direction so if

00:39:53,940 --> 00:39:59,160
I'm transmitting I've got an actual

00:39:55,950 --> 00:40:01,979
buffer and in that transfer so I've got

00:39:59,160 --> 00:40:06,420
a pointer to a buffer but if I'm doing a

00:40:01,979 --> 00:40:10,859
write only okay then my rx buffer just

00:40:06,420 --> 00:40:12,989
points to null okay and so that's what

00:40:10,859 --> 00:40:14,160
happens here if you were to just write

00:40:12,989 --> 00:40:18,119
write a byte

00:40:14,160 --> 00:40:20,430
okay with with the right call it would

00:40:18,119 --> 00:40:22,739
behind the scenes what would happen is

00:40:20,430 --> 00:40:25,999
it generates a transfer where that rx

00:40:22,739 --> 00:40:28,739
buff is pointing to null okay

00:40:25,999 --> 00:40:31,589
so many times you don't want to do a

00:40:28,739 --> 00:40:33,569
half-duplex transfer right a lot of

00:40:31,589 --> 00:40:36,029
devices you're you're reading something

00:40:33,569 --> 00:40:39,250
back simultaneously and so you're gonna

00:40:36,029 --> 00:40:42,250
have to go to the I octal interface

00:40:39,250 --> 00:40:45,640
and so the options you have there are

00:40:42,250 --> 00:40:48,940
the same map exactly the same to those

00:40:45,640 --> 00:40:51,670
colonel AP is right i want to send a

00:40:48,940 --> 00:40:54,520
wrong message it's full duplex in that

00:40:51,670 --> 00:40:56,980
interface you can define your your

00:40:54,520 --> 00:40:59,260
buffers right getting a filling the

00:40:56,980 --> 00:41:01,960
receive and having that transmitted

00:40:59,260 --> 00:41:05,130
buffered sent okay and you also define

00:41:01,960 --> 00:41:08,950
your chipset to control okay and that

00:41:05,130 --> 00:41:10,480
sorry chip select control so all of

00:41:08,950 --> 00:41:12,310
those options we showed a few of those

00:41:10,480 --> 00:41:14,740
how you could you could change the

00:41:12,310 --> 00:41:17,110
behavior or the delays after transfers

00:41:14,740 --> 00:41:21,670
you can do all of that through spy dev

00:41:17,110 --> 00:41:24,460
here finally there's a complete set of

00:41:21,670 --> 00:41:29,320
parameters here that you can set for

00:41:24,460 --> 00:41:33,790
both read and write cases alright so i

00:41:29,320 --> 00:41:36,670
have complete control over that and as

00:41:33,790 --> 00:41:38,830
you get into the details of this so

00:41:36,670 --> 00:41:41,050
showing this in slides and this much

00:41:38,830 --> 00:41:43,660
content that's not the whole deal what

00:41:41,050 --> 00:41:45,700
kind of you know so it broke it out so

00:41:43,660 --> 00:41:48,040
you know where to look but if you want

00:41:45,700 --> 00:41:51,720
the gory details on that as always the

00:41:48,040 --> 00:41:55,030
colonel docs are the way to go and

00:41:51,720 --> 00:41:57,220
what's really great is and sometimes

00:41:55,030 --> 00:42:00,010
people forget that the tools directory

00:41:57,220 --> 00:42:02,050
exists right except by references when

00:42:00,010 --> 00:42:04,150
people are talking about things on the

00:42:02,050 --> 00:42:07,180
mailing list don't forget that you have

00:42:04,150 --> 00:42:09,970
tools by these these two examples right

00:42:07,180 --> 00:42:11,740
so it's a full duplex example alright

00:42:09,970 --> 00:42:13,480
that's really great for getting started

00:42:11,740 --> 00:42:16,060
you want to write a test or something in

00:42:13,480 --> 00:42:18,160
there and then the spy def test that was

00:42:16,060 --> 00:42:20,230
written which is outstanding test all

00:42:18,160 --> 00:42:25,000
kinds of different cases exposed all

00:42:20,230 --> 00:42:29,620
kinds of problems and various controller

00:42:25,000 --> 00:42:32,080
drivers once you're past beating your

00:42:29,620 --> 00:42:33,490
head against the raw interface you might

00:42:32,080 --> 00:42:36,820
want to look at something like jack

00:42:33,490 --> 00:42:38,680
Mitchell's lid sock which puts a nice

00:42:36,820 --> 00:42:42,490
common interface across a lot of these

00:42:38,680 --> 00:42:44,860
user space things it's a I think a

00:42:42,490 --> 00:42:47,350
nicely written piece of C code very very

00:42:44,860 --> 00:42:49,560
easy to follow and everything and then

00:42:47,350 --> 00:42:51,810
what's also popular

00:42:49,560 --> 00:42:53,810
the maker community on top of that is

00:42:51,810 --> 00:42:57,330
the the Pythons pydev

00:42:53,810 --> 00:42:59,910
binding that particular one there's a

00:42:57,330 --> 00:43:04,740
couple that's the most popular that I

00:42:59,910 --> 00:43:07,650
see used most of the time all right

00:43:04,740 --> 00:43:13,200
let's talk a little bit about when

00:43:07,650 --> 00:43:15,420
expire performance one of the things you

00:43:13,200 --> 00:43:17,750
have to keep in mind we talked about all

00:43:15,420 --> 00:43:20,790
this nice abstraction right and

00:43:17,750 --> 00:43:22,380
abstraction is great except eventually

00:43:20,790 --> 00:43:24,720
sometimes you find these holes and

00:43:22,380 --> 00:43:26,850
things where you have to start knowing

00:43:24,720 --> 00:43:29,240
how the hardware works which is sort of

00:43:26,850 --> 00:43:31,890
like when you need that last 10%

00:43:29,240 --> 00:43:37,110
performance that takes 90% of the time

00:43:31,890 --> 00:43:39,510
right and so there are things like and I

00:43:37,110 --> 00:43:42,300
just give examples you need to be aware

00:43:39,510 --> 00:43:44,330
of what that controller driver does when

00:43:42,300 --> 00:43:48,500
you start thinking about performance

00:43:44,330 --> 00:43:51,900
because you may run a test case and in

00:43:48,500 --> 00:43:54,690
example this OMAP mix pie driver okay

00:43:51,900 --> 00:43:56,280
it has in the controller driver a fixed

00:43:54,690 --> 00:44:01,320
there are no heuristics of when it

00:43:56,280 --> 00:44:04,350
engages DMA it simply says if it's if

00:44:01,320 --> 00:44:06,690
it's greater than 160 bytes the transfer

00:44:04,350 --> 00:44:09,660
size I'll use DMA otherwise it's too

00:44:06,690 --> 00:44:12,870
much overhead right typical typical type

00:44:09,660 --> 00:44:15,540
thing but people have been and I saw it

00:44:12,870 --> 00:44:18,210
firsthand confused by the fact that hey

00:44:15,540 --> 00:44:20,880
DMA is not happening we don't understand

00:44:18,210 --> 00:44:23,460
why while they were doing 128 byte

00:44:20,880 --> 00:44:27,900
transfers on this driver so you need to

00:44:23,460 --> 00:44:30,300
be aware of that there are other cases

00:44:27,900 --> 00:44:32,430
very specific to various controller

00:44:30,300 --> 00:44:36,390
drivers when you start looking at the

00:44:32,430 --> 00:44:38,400
thing on your logic analyzer or whatever

00:44:36,390 --> 00:44:41,190
tool you're using on your scope and you

00:44:38,400 --> 00:44:43,260
start seeing that there's delays in it

00:44:41,190 --> 00:44:45,090
you need to start being aware of those

00:44:43,260 --> 00:44:47,550
types of things in the controller driver

00:44:45,090 --> 00:44:50,640
how they manage their chip selects would

00:44:47,550 --> 00:44:55,410
be other areas that may may not be

00:44:50,640 --> 00:44:57,330
optimized very well and then the next

00:44:55,410 --> 00:45:00,369
the next big area is you need to know

00:44:57,330 --> 00:45:03,220
when to use sync versus async

00:45:00,369 --> 00:45:08,130
okay you'll find most kernel drivers are

00:45:03,220 --> 00:45:11,140
using synchronous calls you'll find that

00:45:08,130 --> 00:45:14,200
there's some network drivers are the big

00:45:11,140 --> 00:45:16,359
users of async right and actually it's

00:45:14,200 --> 00:45:19,539
fairly rare but that's the big place and

00:45:16,359 --> 00:45:21,849
it's because they are optimizing for

00:45:19,539 --> 00:45:24,549
bandwidth rather than latency right and

00:45:21,849 --> 00:45:26,859
that makes perfect sense there whereas

00:45:24,549 --> 00:45:29,259
everybody else really wants to get that

00:45:26,859 --> 00:45:31,869
that little transfer out on the wire as

00:45:29,259 --> 00:45:35,140
fast as possible right so they're

00:45:31,869 --> 00:45:38,890
typically doing the sync one of the nice

00:45:35,140 --> 00:45:43,720
things that came in and for x-series was

00:45:38,890 --> 00:45:46,269
that sync will now attempt to execute in

00:45:43,720 --> 00:45:50,049
caller context and that's made a big

00:45:46,269 --> 00:45:52,720
difference so it will rather than rather

00:45:50,049 --> 00:45:55,509
than sleeping it will try to execute in

00:45:52,720 --> 00:45:58,119
that caller context so for the reduction

00:45:55,509 --> 00:46:06,910
in latency so aggressively tries to do

00:45:58,119 --> 00:46:08,589
that if possible and then this this big

00:46:06,910 --> 00:46:10,839
one okay

00:46:08,589 --> 00:46:13,119
talked a little bit about how you can

00:46:10,839 --> 00:46:15,609
set all these different options in your

00:46:13,119 --> 00:46:16,930
transfer structure right you're building

00:46:15,609 --> 00:46:20,470
up your message and you're creating

00:46:16,930 --> 00:46:22,960
transfers you understand that the

00:46:20,470 --> 00:46:26,049
characteristic again of that slave

00:46:22,960 --> 00:46:29,739
device right and what it wants to see

00:46:26,049 --> 00:46:34,539
optimally because for example if you

00:46:29,739 --> 00:46:37,529
have if you have a protocol okay and you

00:46:34,539 --> 00:46:41,589
allow the chip select to go back hi

00:46:37,529 --> 00:46:45,220
after each transfer you add extra timing

00:46:41,589 --> 00:46:47,190
delay in between the transfers your your

00:46:45,220 --> 00:46:50,289
particular chip it might require that

00:46:47,190 --> 00:46:52,239
okay it may not some of them can handle

00:46:50,289 --> 00:46:54,730
stringing together and just leaving the

00:46:52,239 --> 00:46:57,579
chip select asserted so as you can

00:46:54,730 --> 00:47:00,039
imagine if you don't have to have the

00:46:57,579 --> 00:47:01,930
controller driver D assert that chip

00:47:00,039 --> 00:47:03,849
select after each transfer and then

00:47:01,930 --> 00:47:06,549
reassert it and you're going to the same

00:47:03,849 --> 00:47:09,039
device you can improve performance in a

00:47:06,549 --> 00:47:11,200
way that you can quantify when you're

00:47:09,039 --> 00:47:13,030
looking on the logic analyzer

00:47:11,200 --> 00:47:15,099
and and seeing that all of a sudden okay

00:47:13,030 --> 00:47:17,770
now I can string these transfers

00:47:15,099 --> 00:47:20,290
together and hit that maximum timing

00:47:17,770 --> 00:47:25,720
diagram they showed me in the in the

00:47:20,290 --> 00:47:30,069
datasheet so this is the canonical good

00:47:25,720 --> 00:47:34,420
explanation of how that CS change field

00:47:30,069 --> 00:47:37,630
works and you know it's a it's a it's a

00:47:34,420 --> 00:47:40,059
pretty detailed one right but that's how

00:47:37,630 --> 00:47:43,000
you actually manage cases like that so

00:47:40,059 --> 00:47:47,770
if you've got a part right where you

00:47:43,000 --> 00:47:49,900
want to have where you want to control

00:47:47,770 --> 00:47:52,599
that that chip select in any of those

00:47:49,900 --> 00:47:57,160
different variants you do it here okay

00:47:52,599 --> 00:47:59,500
so the important thing there this is in

00:47:57,160 --> 00:48:01,599
the spy header right most the other

00:47:59,500 --> 00:48:04,450
important Doc's are in the actual

00:48:01,599 --> 00:48:07,119
documentation directory but this one I

00:48:04,450 --> 00:48:09,579
think is you know it's es changes

00:48:07,119 --> 00:48:12,460
mentioned but it's often confused and

00:48:09,579 --> 00:48:15,069
used it was actually implemented wrong

00:48:12,460 --> 00:48:15,910
in the iio subsystem for a long time in

00:48:15,069 --> 00:48:19,150
fact

00:48:15,910 --> 00:48:20,859
so yeah they fix that up I can't

00:48:19,150 --> 00:48:23,020
remember where I saw that coming in but

00:48:20,859 --> 00:48:24,970
they realized that was wrong for a while

00:48:23,020 --> 00:48:28,299
on that when someone was doing some

00:48:24,970 --> 00:48:32,790
performance analysis so keep this in

00:48:28,299 --> 00:48:36,010
mind as well and the other big thing is

00:48:32,790 --> 00:48:39,040
you know there's no excuse for not

00:48:36,010 --> 00:48:40,900
having good performance and debug tools

00:48:39,040 --> 00:48:43,030
these days right

00:48:40,900 --> 00:48:45,130
so you have to have it if you're trying

00:48:43,030 --> 00:48:48,609
to get decent performance because you

00:48:45,130 --> 00:48:50,740
can't fix what you can't see and so you

00:48:48,609 --> 00:48:53,920
know you can look at these resources

00:48:50,740 --> 00:48:56,410
here actually prefer Sig rocks source

00:48:53,920 --> 00:48:58,599
right because they have a great

00:48:56,410 --> 00:49:01,930
comparison of everything they support or

00:48:58,599 --> 00:49:04,510
don't support therefore logic analyzers

00:49:01,930 --> 00:49:07,390
so for things that are now well under

00:49:04,510 --> 00:49:09,730
$50 US and have been for a while there's

00:49:07,390 --> 00:49:13,869
really no excuse not to have even a

00:49:09,730 --> 00:49:18,520
simple one the other thing is you can

00:49:13,869 --> 00:49:21,309
use spy loopback test module the self

00:49:18,520 --> 00:49:22,700
test for some performance work and also

00:49:21,309 --> 00:49:25,369
debug of control

00:49:22,700 --> 00:49:27,700
drivers so forth that's a that's very

00:49:25,369 --> 00:49:31,190
useful it's exposed a lot of problems

00:49:27,700 --> 00:49:35,720
and then finally one of the newer things

00:49:31,190 --> 00:49:39,589
relatively new that it came in is this

00:49:35,720 --> 00:49:42,440
great set of statistics okay and so now

00:49:39,589 --> 00:49:46,190
you have under under sis classify master

00:49:42,440 --> 00:49:47,990
and now bb Dicey's adds bus chip

00:49:46,190 --> 00:49:50,359
select right same notation we're looking

00:49:47,990 --> 00:49:52,099
at kind of makes sense based on the

00:49:50,359 --> 00:49:54,530
allocation of the driver you have these

00:49:52,099 --> 00:49:57,800
statistics nodes and so you have

00:49:54,530 --> 00:49:59,720
statistics on messages transfers errors

00:49:57,800 --> 00:50:04,369
timeouts all those good things you want

00:49:59,720 --> 00:50:07,579
to see and also you know I talked about

00:50:04,369 --> 00:50:10,310
how it tries to optimize for executing a

00:50:07,579 --> 00:50:12,140
caller context right so you're writing

00:50:10,310 --> 00:50:14,210
the driver you're doing some in spite of

00:50:12,140 --> 00:50:16,700
you can go look and see how many times

00:50:14,210 --> 00:50:18,380
it did that transfer or spy sync and how

00:50:16,700 --> 00:50:20,180
many times it actually executes it in

00:50:18,380 --> 00:50:22,670
caller context which is what you really

00:50:20,180 --> 00:50:25,670
wanted right to avoid if you're going

00:50:22,670 --> 00:50:27,530
for reduction in latency so you can use

00:50:25,670 --> 00:50:28,430
that to start you know having that

00:50:27,530 --> 00:50:30,770
information

00:50:28,430 --> 00:50:32,900
the other cool thing is when you have

00:50:30,770 --> 00:50:36,260
something that's complex and maybe many

00:50:32,900 --> 00:50:39,099
devices I got a histogram on transfers

00:50:36,260 --> 00:50:42,230
so you can you can get that data out

00:50:39,099 --> 00:50:44,420
okay of what size buffers are getting

00:50:42,230 --> 00:50:46,490
transferred and stuff and that's

00:50:44,420 --> 00:50:50,390
actually interesting to see as you start

00:50:46,490 --> 00:50:52,310
debugging how different messages and

00:50:50,390 --> 00:50:55,670
transfers are occurring maybe you're

00:50:52,310 --> 00:50:59,030
looking at DMA efficiency and so forth

00:50:55,670 --> 00:51:00,680
having that kind of analysis of what

00:50:59,030 --> 00:51:02,930
your system is doing with multiple

00:51:00,680 --> 00:51:12,010
protocol drivers can be really useful in

00:51:02,930 --> 00:51:12,010
diagnosing things that thing is flaky

00:51:20,000 --> 00:51:29,840
alright ok and time check we're doing

00:51:26,180 --> 00:51:35,240
real quick on spy future so slave

00:51:29,840 --> 00:51:37,580
support is coming sure then look in the

00:51:35,240 --> 00:51:42,830
last couple weeks were where we're at

00:51:37,580 --> 00:51:46,580
been traveling but so so hard real time

00:51:42,830 --> 00:51:49,849
issues right on Linux and the the

00:51:46,580 --> 00:51:53,210
inability to have very tight time

00:51:49,849 --> 00:51:55,310
constraint ISM has made you know slave

00:51:53,210 --> 00:51:59,210
support kind of problematic in a generic

00:51:55,310 --> 00:52:00,980
way however their data hope and had

00:51:59,210 --> 00:52:02,690
noted that there's a lot of use cases

00:52:00,980 --> 00:52:05,210
that you can implement that are

00:52:02,690 --> 00:52:08,180
real-world use cases if you kind of

00:52:05,210 --> 00:52:11,869
limit what your scope is of this so he

00:52:08,180 --> 00:52:14,510
had mentioned pre-existing pre-existing

00:52:11,869 --> 00:52:19,099
responses so you have a slave driver

00:52:14,510 --> 00:52:20,660
and maybe it's you know time of day it's

00:52:19,099 --> 00:52:23,270
ready to return and it's got that

00:52:20,660 --> 00:52:25,250
transfer ready it can it can you can

00:52:23,270 --> 00:52:29,270
implement something that or commands are

00:52:25,250 --> 00:52:34,130
just one way right and so currently has

00:52:29,270 --> 00:52:37,339
a v2 RFC that series looks pretty good

00:52:34,130 --> 00:52:39,500
now there's a bit of work to do on it of

00:52:37,339 --> 00:52:43,730
course and they mention some bugs and so

00:52:39,500 --> 00:52:46,609
forth you know it works just analogously

00:52:43,730 --> 00:52:48,589
like registering a master with spy Alex

00:52:46,609 --> 00:52:52,880
slave when you're adding a controller

00:52:48,589 --> 00:52:55,339
driver and then the way it works is he

00:52:52,880 --> 00:52:59,210
has this type of node that gets exposed

00:52:55,339 --> 00:53:02,570
after a slave controller is instantiated

00:52:59,210 --> 00:53:05,810
and you can write slave protocol drivers

00:53:02,570 --> 00:53:08,330
that are then are bound by assist FS

00:53:05,810 --> 00:53:11,420
like this so if you have a slave

00:53:08,330 --> 00:53:14,869
protocol drivers echo that in okay and

00:53:11,420 --> 00:53:17,839
that binds and activates it and he

00:53:14,869 --> 00:53:20,060
provides in that RFC Pat series on the

00:53:17,839 --> 00:53:22,099
previous slide these two examples which

00:53:20,060 --> 00:53:26,420
actually map neatly to those two use

00:53:22,099 --> 00:53:29,420
cases it says where this spy slave time

00:53:26,420 --> 00:53:31,460
just sends the latest uptime back just

00:53:29,420 --> 00:53:33,560
an example of that type of use case and

00:53:31,460 --> 00:53:35,900
then spy slave system can

00:53:33,560 --> 00:53:40,810
roll which is power off reboot halt

00:53:35,900 --> 00:53:42,290
system right so it accomplishes those

00:53:40,810 --> 00:53:46,780
all right

00:53:42,290 --> 00:53:46,780
any I think we have questions

00:53:56,790 --> 00:54:05,610
I question I have is you have the the

00:54:02,910 --> 00:54:09,060
sink and the a sink and I have a

00:54:05,610 --> 00:54:12,540
protocol driver living as I understand

00:54:09,060 --> 00:54:13,260
it SPL excuse the message is up and then

00:54:12,540 --> 00:54:17,640
we first

00:54:13,260 --> 00:54:21,480
excu out to the slugs okay and we may or

00:54:17,640 --> 00:54:24,930
may not get an answer a reply during

00:54:21,480 --> 00:54:32,250
that time you know in the with the Becca

00:54:24,930 --> 00:54:34,920
send qmp also filling are you talking

00:54:32,250 --> 00:54:38,910
about actually on that slave device or

00:54:34,920 --> 00:54:41,790
in the sub system now this same source

00:54:38,910 --> 00:54:44,280
is the a thing okay when I feel this is

00:54:41,790 --> 00:54:47,520
Q and I call the same or I call a thing

00:54:44,280 --> 00:54:54,140
does it immediately empty the QA on

00:54:47,520 --> 00:54:58,730
through the hardware or DNA mechanism or

00:54:54,140 --> 00:55:11,250
the spy sink will try to execute that

00:54:58,730 --> 00:55:15,200
immediately it can sleep though it can

00:55:11,250 --> 00:55:15,200
it can sleep in and block

00:55:15,309 --> 00:55:21,699
well not block but sleep yeah you don't

00:55:19,630 --> 00:55:24,400
want it to sleep so you would use you

00:55:21,699 --> 00:55:30,519
could use spy async and just took a call

00:55:24,400 --> 00:55:33,640
back that's that's what forget which

00:55:30,519 --> 00:55:35,979
network drivers at the not the I didn't

00:55:33,640 --> 00:55:37,900
think it was the en see somebody might

00:55:35,979 --> 00:55:41,650
remember did you know

00:55:37,900 --> 00:55:43,839
mark but there's one that that does that

00:55:41,650 --> 00:55:50,159
does a great example of there's not many

00:55:43,839 --> 00:55:52,959
examples of it but that I know of yeah

00:55:50,159 --> 00:55:55,269
but it works in the network driver type

00:55:52,959 --> 00:55:55,890
thing sigh yeah it very limited use

00:55:55,269 --> 00:56:00,959
cases

00:55:55,890 --> 00:56:04,809
so speaking of interrupts right there

00:56:00,959 --> 00:56:06,819
let's say I have an SPI device that I

00:56:04,809 --> 00:56:10,719
mean SPI does inherently doesn't have a

00:56:06,819 --> 00:56:15,069
cue but if you have a GPIO it says hey I

00:56:10,719 --> 00:56:18,130
need service now can you talk to how how

00:56:15,069 --> 00:56:21,489
you would tie that in or is there a way

00:56:18,130 --> 00:56:24,459
to have SPI a hole in the background

00:56:21,489 --> 00:56:26,979
Sasebo now now so there's a separate

00:56:24,459 --> 00:56:29,799
subsystem for these things a GPIO so

00:56:26,979 --> 00:56:31,479
system offers all I get to say

00:56:29,799 --> 00:56:34,449
disclaimer that's how the scope for this

00:56:31,479 --> 00:56:37,059
talk now different talk right

00:56:34,449 --> 00:56:39,039
but the GPIO subsystem so so when you're

00:56:37,059 --> 00:56:40,959
building a protocol driver again this is

00:56:39,039 --> 00:56:43,390
all simplified that's that's like an

00:56:40,959 --> 00:56:46,299
everyday case right that you've got the

00:56:43,390 --> 00:56:48,640
irq that's out of out of the bounds of

00:56:46,299 --> 00:56:50,890
spy but in reality when you're writing

00:56:48,640 --> 00:56:53,919
that protocol driver one of the other

00:56:50,890 --> 00:56:57,069
resources you have to hook is that GPIO

00:56:53,919 --> 00:56:59,259
and you need to request the GPIO using

00:56:57,069 --> 00:57:09,369
the the GPIO framework and set it up as

00:56:59,259 --> 00:57:11,829
an interrupt okay right right when I say

00:57:09,369 --> 00:57:14,349
when I say get the resource talking

00:57:11,829 --> 00:57:16,749
about all that the same hookup you do

00:57:14,349 --> 00:57:20,049
you have to say in device tree you need

00:57:16,749 --> 00:57:21,579
to specify that here's the GPIO for this

00:57:20,049 --> 00:57:25,240
device when you're instantiate in the

00:57:21,579 --> 00:57:28,869
device right the subsystem

00:57:25,240 --> 00:57:31,880
that his specific question was about

00:57:28,869 --> 00:57:33,650
interrupts and how interrupts are

00:57:31,880 --> 00:57:35,869
handled and so yeah yeah the

00:57:33,650 --> 00:57:38,660
clarification is that that is not

00:57:35,869 --> 00:57:41,900
something that's part of spy just by the

00:57:38,660 --> 00:57:43,400
very nature that's not spy it's it's but

00:57:41,900 --> 00:57:47,260
it is that's that's where you're using

00:57:43,400 --> 00:57:49,849
the features of the interrupts

00:57:47,260 --> 00:57:52,010
capabilities in the kernel and the GPIO

00:57:49,849 --> 00:57:56,060
subsystem that implements all that for

00:57:52,010 --> 00:58:05,599
you in that protocol driver okay put

00:57:56,060 --> 00:58:07,310
those two together so I've seen in using

00:58:05,599 --> 00:58:09,349
spy devs that you weren't supposed to

00:58:07,310 --> 00:58:11,420
have it in a compatible string is that

00:58:09,349 --> 00:58:14,570
right because it's not a piece of

00:58:11,420 --> 00:58:16,880
hardware and was BeagleBone for example

00:58:14,570 --> 00:58:18,829
there was like a patch that then made it

00:58:16,880 --> 00:58:21,109
complain really loudly and I think we

00:58:18,829 --> 00:58:22,369
all right Welch that mark this is gonna

00:58:21,109 --> 00:58:24,170
be the last question because we're going

00:58:22,369 --> 00:58:25,250
to run it but mark mark should answer

00:58:24,170 --> 00:58:27,530
this because the maintainer of the

00:58:25,250 --> 00:58:36,770
subsystems here what was the cruel

00:58:27,530 --> 00:58:38,359
question tonight can I so you were

00:58:36,770 --> 00:58:39,800
showing that instead of having spy dab

00:58:38,359 --> 00:58:41,210
you're actually supposed to have actual

00:58:39,800 --> 00:58:42,740
compatible string for a piece of

00:58:41,210 --> 00:58:45,790
hardware in which case you're supposed

00:58:42,740 --> 00:58:48,349
to add it into some file somewhere yeah

00:58:45,790 --> 00:58:51,619
yeah the spy death has a list of

00:58:48,349 --> 00:58:56,720
compatible strings so get your boots put

00:58:51,619 --> 00:58:58,880
it in spy dev yeah yeah so yeah just say

00:58:56,720 --> 00:59:04,369
spiders how we handle on Linux or write

00:58:58,880 --> 00:59:05,660
a driver for it I was who I was

00:59:04,369 --> 00:59:10,280
spy dev removed from the compatible

00:59:05,660 --> 00:59:11,720
strings because like smart said spied

00:59:10,280 --> 00:59:13,609
evident describing the hardware it's

00:59:11,720 --> 00:59:16,569
describing how you want to drive on

00:59:13,609 --> 00:59:21,230
Linux right this very minute

00:59:16,569 --> 00:59:24,079
so we now complain loudly about it so to

00:59:21,230 --> 00:59:25,849
make you actually describe your hardware

00:59:24,079 --> 00:59:28,490
because somebody might come along later

00:59:25,849 --> 00:59:29,750
and write a driver for it and then you

00:59:28,490 --> 00:59:31,740
have no idea what it is

00:59:29,750 --> 00:59:34,350
an even when you're using

00:59:31,740 --> 00:59:38,780
Oh even when you were using when you're

00:59:34,350 --> 00:59:41,400
using Spyder it's not very helpful for

00:59:38,780 --> 00:59:44,520
userspace to work at which particular

00:59:41,400 --> 00:59:46,410
thing to do when that spider if we just

00:59:44,520 --> 00:59:50,369
say slide EV so you couldn't write a

00:59:46,410 --> 00:59:53,660
generic driver or you can apply dev

00:59:50,369 --> 00:59:53,660

YouTube URL: https://www.youtube.com/watch?v=MV8Sy6jGUIE


