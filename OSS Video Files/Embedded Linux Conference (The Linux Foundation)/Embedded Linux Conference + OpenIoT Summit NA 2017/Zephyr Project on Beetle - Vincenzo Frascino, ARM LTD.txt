Title: Zephyr Project on Beetle - Vincenzo Frascino, ARM LTD
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Zephyr Project on Beetle - Vincenzo Frascino, ARM LTD

The Zephyr Project is a small, scalable, real-time operating system for use on resource-constrained systems that support multiple architectures.

Zephyrâ€™s modularity allows it to run in as little as 8K of RAM and helps create an IoT solution that meets all of your device needs, regardless of architecture.

ARM Beetle is the test-chip implementation of the IoT subsystem for Cortex-M processors that allows design teams to create IoT endpoints faster and with lower risk.

In this session, I am going to give an overview of the current status of Zephyr OS running on Beetle and provide a deep dive on how to port a new platform into Zephyr with examples related to the ARM platform. The Demo session will contain a set of examples that demonstrate the capabilities of the chip.

About Vincenzo Frascino
I am a Senior Engineer at ARM Ltd. and Linaro assignee for LITE group working currently on the Zephyr project as a maintainer of the ARM V2M Beetle platform. In my 7 years of experience I worked on different projects related to Linux/Android. My main responsibility area has been Power Management.
Captions: 
	00:00:00,030 --> 00:00:05,040
good afternoon everybody if you are here

00:00:02,700 --> 00:00:07,589
today probably you know what the theory

00:00:05,040 --> 00:00:10,050
is probably weather within this

00:00:07,589 --> 00:00:12,389
conference or in other conferences for

00:00:10,050 --> 00:00:14,849
the ones who don't it is an open source

00:00:12,389 --> 00:00:17,220
project aimed at simplifying the

00:00:14,849 --> 00:00:18,210
development of new lightweight of IOT

00:00:17,220 --> 00:00:21,330
solutions

00:00:18,210 --> 00:00:23,789
my name is Vincenzo frisina and I am

00:00:21,330 --> 00:00:26,369
here today to present to you the results

00:00:23,789 --> 00:00:29,010
of the porting of Zephyr OS unarmed

00:00:26,369 --> 00:00:32,460
beetle and more in general to provide

00:00:29,010 --> 00:00:36,300
ins and tips for porting the u.s. to new

00:00:32,460 --> 00:00:39,300
platforms this presentation is not meant

00:00:36,300 --> 00:00:42,450
to be a fully comprehensive porting

00:00:39,300 --> 00:00:45,149
guide but a starting point for those of

00:00:42,450 --> 00:00:48,360
you who are interested in porting or in

00:00:45,149 --> 00:00:53,250
a new platform this operating system but

00:00:48,360 --> 00:00:56,760
let's begin into this presentation we

00:00:53,250 --> 00:00:59,699
will go through a brief overview we will

00:00:56,760 --> 00:01:03,030
analyze the effects architecture we will

00:00:59,699 --> 00:01:06,210
focus on the porting of Zephyr on beetle

00:01:03,030 --> 00:01:09,140
starting from the basic concepts up to

00:01:06,210 --> 00:01:11,520
the device model and the drivers and

00:01:09,140 --> 00:01:13,740
hoping that at that point I have

00:01:11,520 --> 00:01:16,350
inspired you a bit we will see how to

00:01:13,740 --> 00:01:18,119
contribute to the project and at the end

00:01:16,350 --> 00:01:23,990
we will have a little demo and some

00:01:18,119 --> 00:01:26,460
examples running on beetle what is safer

00:01:23,990 --> 00:01:28,829
as we've seen this morning from Anna's

00:01:26,460 --> 00:01:30,630
presentation basically Delhi is an

00:01:28,829 --> 00:01:33,060
operating system that runs on

00:01:30,630 --> 00:01:35,670
microcontroller units with a small small

00:01:33,060 --> 00:01:40,799
footprint it's code base was established

00:01:35,670 --> 00:01:42,810
in 2000 more than 15 years ago and it

00:01:40,799 --> 00:01:47,700
has been made open-source in February

00:01:42,810 --> 00:01:50,880
2016 almost a year ago it is licensed

00:01:47,700 --> 00:01:53,850
under Apache 2.0 it is modular and

00:01:50,880 --> 00:01:55,979
configurable it uses in particular K

00:01:53,850 --> 00:01:59,850
config and K build and now even the

00:01:55,979 --> 00:02:03,899
device tree to allow versatility and

00:01:59,850 --> 00:02:07,649
configuration it does not provide a user

00:02:03,899 --> 00:02:09,869
space and dynamic runtime it means that

00:02:07,649 --> 00:02:13,420
basically all the system is described at

00:02:09,869 --> 00:02:15,390
compile time it allocates memo

00:02:13,420 --> 00:02:18,880
and resources weren't possible

00:02:15,390 --> 00:02:21,670
statically and it is obviously

00:02:18,880 --> 00:02:26,500
cross-platform as we had e-tron's

00:02:21,670 --> 00:02:29,140
actually on our on x86 on arc and on

00:02:26,500 --> 00:02:35,590
many other platform write risk v or

00:02:29,140 --> 00:02:40,840
other systems but how

00:02:35,590 --> 00:02:44,380
Zephyr does that basically Zephyr OS can

00:02:40,840 --> 00:02:47,470
be divided in a BSP a set of kernel

00:02:44,380 --> 00:02:50,709
components an eye level API and an

00:02:47,470 --> 00:02:53,290
application this is basically a generic

00:02:50,709 --> 00:02:56,200
image the transformer Hardware like it

00:02:53,290 --> 00:02:58,930
doesn't Beto for example the deferred

00:02:56,200 --> 00:03:01,420
kernel offers single address space

00:02:58,930 --> 00:03:05,170
basically the application and your

00:03:01,420 --> 00:03:07,930
kernel is compiled into a single image

00:03:05,170 --> 00:03:12,220
it's all configurable as we have seen

00:03:07,930 --> 00:03:14,530
with K build and K config it has a

00:03:12,220 --> 00:03:16,239
compile time resource definition so you

00:03:14,530 --> 00:03:18,400
describe all your system at compile time

00:03:16,239 --> 00:03:21,010
when the image comes out it contains all

00:03:18,400 --> 00:03:24,310
the information already define it it has

00:03:21,010 --> 00:03:26,590
a minimal error checking to allow high

00:03:24,310 --> 00:03:28,989
performances and basically if you are in

00:03:26,590 --> 00:03:31,450
the buggy mode you can enable extra rows

00:03:28,989 --> 00:03:34,720
checking and it provides a suite of

00:03:31,450 --> 00:03:36,940
services the suite of services is for

00:03:34,720 --> 00:03:40,390
example multitrader queue management and

00:03:36,940 --> 00:03:42,489
and others today in this presentation we

00:03:40,390 --> 00:03:44,590
will focus on this part in particular on

00:03:42,489 --> 00:03:47,380
board support on the sock support on

00:03:44,590 --> 00:03:51,940
device drivers and a little bit on power

00:03:47,380 --> 00:03:55,000
management even if it requires what did

00:03:51,940 --> 00:03:59,769
it happen let's hope that this time it

00:03:55,000 --> 00:04:02,200
works ok but out deferred does that as

00:03:59,769 --> 00:04:05,170
we were as we were seeing it was a set

00:04:02,200 --> 00:04:09,340
of facilities in order to enable these

00:04:05,170 --> 00:04:13,540
operations and basically in today's

00:04:09,340 --> 00:04:16,299
presentation we will focus on the BSP on

00:04:13,540 --> 00:04:21,370
the BSP and on the kernel parts that

00:04:16,299 --> 00:04:23,590
have direct impact on it and in

00:04:21,370 --> 00:04:26,080
particular on the board support on the

00:04:23,590 --> 00:04:27,020
sock support on the device driver part

00:04:26,080 --> 00:04:31,550
and

00:04:27,020 --> 00:04:33,410
a little bit on the power management how

00:04:31,550 --> 00:04:36,800
can we take advantage of all of these

00:04:33,410 --> 00:04:40,009
let's start from some basics like the

00:04:36,800 --> 00:04:41,449
setup of the environment before setting

00:04:40,009 --> 00:04:44,659
up the environment of course we need to

00:04:41,449 --> 00:04:47,780
know what is our board and what we are

00:04:44,659 --> 00:04:50,539
compiling for so basically in our case

00:04:47,780 --> 00:04:53,419
we are using this device here that is a

00:04:50,539 --> 00:04:56,300
little bored a little bored is cortex

00:04:53,419 --> 00:04:58,490
entry based and it's a announced IOT

00:04:56,300 --> 00:05:02,659
evaluation platform that includes the

00:04:58,490 --> 00:05:07,940
IOT subsystem for cortex-m and the core

00:05:02,659 --> 00:05:10,550
do ble smart radio it has 256 kilobytes

00:05:07,940 --> 00:05:12,530
of flesh another 28 kilobytes of RAM and

00:05:10,550 --> 00:05:15,349
as an external flash of 2 megabytes

00:05:12,530 --> 00:05:22,159
offers some debug interfaces and it is

00:05:15,349 --> 00:05:25,099
compliant with the Arduino shield let's

00:05:22,159 --> 00:05:28,520
see how to compile for this platform a

00:05:25,099 --> 00:05:32,659
single application like it can be hello

00:05:28,520 --> 00:05:35,389
world so this example is tested on he

00:05:32,659 --> 00:05:37,669
boon to 14.4 and to set up your

00:05:35,389 --> 00:05:41,449
development environment basically what

00:05:37,669 --> 00:05:46,699
you need to do is install the SDK

00:05:41,449 --> 00:05:48,469
provided by the dev project and a set of

00:05:46,699 --> 00:05:52,340
other utilities that you can use

00:05:48,469 --> 00:05:56,090
together with your Ubuntu pre-installed

00:05:52,340 --> 00:06:00,409
and then cloned the the source code and

00:05:56,090 --> 00:06:03,409
provide to the Zephyr OS compilation

00:06:00,409 --> 00:06:06,529
system environment variables that

00:06:03,409 --> 00:06:10,659
provide to the compilation system the

00:06:06,529 --> 00:06:14,389
information in order to compile their

00:06:10,659 --> 00:06:17,120
supports even external SDKs and in

00:06:14,389 --> 00:06:21,289
particular as you can see from from here

00:06:17,120 --> 00:06:23,509
I provide another example with the GCC

00:06:21,289 --> 00:06:25,909
arm the only difference is that

00:06:23,509 --> 00:06:29,029
basically works you install it from an

00:06:25,909 --> 00:06:32,659
external repository and when you set up

00:06:29,029 --> 00:06:35,360
your environment variables you define

00:06:32,659 --> 00:06:38,870
the GCC arm as the main compiler that

00:06:35,360 --> 00:06:40,610
you want to use now that we have set up

00:06:38,870 --> 00:06:43,490
our environment

00:06:40,610 --> 00:06:45,620
we will use it to compile a single

00:06:43,490 --> 00:06:48,680
application and to verify that this is

00:06:45,620 --> 00:06:50,270
working the simplest application that we

00:06:48,680 --> 00:06:52,100
can compile and that is provided

00:06:50,270 --> 00:06:55,699
together with the deferred project is

00:06:52,100 --> 00:06:57,740
the hello world application the hello

00:06:55,699 --> 00:07:00,580
world application basically can be

00:06:57,740 --> 00:07:04,520
compiled using this set of commands it

00:07:00,580 --> 00:07:07,130
resides in sample cell award and after

00:07:04,520 --> 00:07:11,360
you have set up the environment with the

00:07:07,130 --> 00:07:13,580
Zephyr - m dot sh script you can compile

00:07:11,360 --> 00:07:16,669
it for a specific platform using the

00:07:13,580 --> 00:07:20,510
switchboard equal in our case board

00:07:16,669 --> 00:07:22,940
equal is v2 n beetle that is the name of

00:07:20,510 --> 00:07:25,039
the board that we are using once we have

00:07:22,940 --> 00:07:28,389
finished and we flush the binary and we

00:07:25,039 --> 00:07:31,490
can have an output like this one

00:07:28,389 --> 00:07:34,099
obviously this is the final result of a

00:07:31,490 --> 00:07:38,530
basic porting because a basic porting is

00:07:34,099 --> 00:07:41,060
a set of features plus a serial port and

00:07:38,530 --> 00:07:42,650
the rest we can figure it out going

00:07:41,060 --> 00:07:46,970
basically once we have the serial port

00:07:42,650 --> 00:07:50,210
but let's see what we have to do to get

00:07:46,970 --> 00:07:55,639
there and in particular let's see how do

00:07:50,210 --> 00:07:58,220
we pour the bsp to Zephyr two-parter BSP

00:07:55,639 --> 00:08:00,860
to Zephyr basically what we need to

00:07:58,220 --> 00:08:04,070
focus on is the Sauk porting that

00:08:00,860 --> 00:08:09,770
resides in arc arc that can be armed

00:08:04,070 --> 00:08:12,620
hey I 32 or x86 SOC and inside there we

00:08:09,770 --> 00:08:14,840
will have a directory called like the

00:08:12,620 --> 00:08:16,130
name of our associ in which we put all

00:08:14,840 --> 00:08:18,199
the files that we need to do the

00:08:16,130 --> 00:08:20,720
supporting same thing we will do for the

00:08:18,199 --> 00:08:23,150
board in particular with the board we

00:08:20,720 --> 00:08:25,159
will provide the def config file and the

00:08:23,150 --> 00:08:28,400
def config file will have the name board

00:08:25,159 --> 00:08:32,839
underscore def config like in linux this

00:08:28,400 --> 00:08:34,669
so after we did that we will start

00:08:32,839 --> 00:08:36,860
implementing a set of driver that are

00:08:34,669 --> 00:08:39,650
required by our platform like can be pin

00:08:36,860 --> 00:08:43,729
muxing GPIO h1 residing on different

00:08:39,650 --> 00:08:46,430
directories into drivers and once we

00:08:43,729 --> 00:08:49,910
finish it we will have to provide a set

00:08:46,430 --> 00:08:51,950
of documentation in order to cover the

00:08:49,910 --> 00:08:52,960
basic information that we are putting

00:08:51,950 --> 00:08:57,010
into

00:08:52,960 --> 00:08:59,470
or implementation let's see how this

00:08:57,010 --> 00:09:03,820
works all together and in particular

00:08:59,470 --> 00:09:08,050
let's see how on our platform Zephyr

00:09:03,820 --> 00:09:09,910
does the boot and on which moment of the

00:09:08,050 --> 00:09:13,120
boot our divers are called

00:09:09,910 --> 00:09:16,660
in order to understand how to plug our

00:09:13,120 --> 00:09:19,510
drivers in the big system so basically

00:09:16,660 --> 00:09:21,460
after the Reza Tendler what happens is

00:09:19,510 --> 00:09:23,560
that Zephyr set up some initial stock

00:09:21,460 --> 00:09:29,070
verifies if you are running and running

00:09:23,560 --> 00:09:31,840
and executing place system and this is

00:09:29,070 --> 00:09:35,680
true for almost all day on platform that

00:09:31,840 --> 00:09:39,130
I saw and if this is true it copies the

00:09:35,680 --> 00:09:41,230
initialized data from Rome to ROM once

00:09:39,130 --> 00:09:43,540
this is done locks the interrupt that

00:09:41,230 --> 00:09:47,320
will be unlocked once the main task was

00:09:43,540 --> 00:09:51,420
in execution if present initializes the

00:09:47,320 --> 00:09:54,340
platform watchdog and once this is done

00:09:51,420 --> 00:09:56,580
switches the stock from the main stack

00:09:54,340 --> 00:09:59,710
pointer to the program stack pointer

00:09:56,580 --> 00:10:03,310
once this operation is complete it jumps

00:09:59,710 --> 00:10:08,440
to the Pepsi Pepsi is an architecture

00:10:03,310 --> 00:10:12,400
specific feature that allows to set up a

00:10:08,440 --> 00:10:14,940
basic system to run C code so to do that

00:10:12,400 --> 00:10:18,280
basically what prep see does it

00:10:14,940 --> 00:10:22,120
relocates the vector table if the option

00:10:18,280 --> 00:10:25,000
is enabled it enables the FPU again if

00:10:22,120 --> 00:10:27,340
the option is enabled it zeros the BSS

00:10:25,000 --> 00:10:30,430
section and once this is finished it

00:10:27,340 --> 00:10:32,350
jumps to the manage initialization to

00:10:30,430 --> 00:10:35,800
the kernel that is done through the C

00:10:32,350 --> 00:10:42,510
start functionality that resides in

00:10:35,800 --> 00:10:46,300
kernel in it dot C the responsibility of

00:10:42,510 --> 00:10:48,640
C start is to contact switch from a fake

00:10:46,300 --> 00:10:53,080
context that is the one which we are

00:10:48,640 --> 00:10:57,150
running at reset in a startup context or

00:10:53,080 --> 00:11:00,490
or better said with the main thread

00:10:57,150 --> 00:11:02,470
now now at this point once this is done

00:11:00,490 --> 00:11:04,720
we are able to execute C code in

00:11:02,470 --> 00:11:06,610
particular the perspective on which

00:11:04,720 --> 00:11:08,680
system does this is

00:11:06,610 --> 00:11:11,290
initializing the kernel data structures

00:11:08,680 --> 00:11:14,970
and the interrupt subsystem and it

00:11:11,290 --> 00:11:18,190
performs the initial driver

00:11:14,970 --> 00:11:21,490
initialization in particular you can see

00:11:18,190 --> 00:11:24,430
here three levels kernel one kernel two

00:11:21,490 --> 00:11:26,110
and primary kernel one and kernel two

00:11:24,430 --> 00:11:28,990
are the one introduced by the new

00:11:26,110 --> 00:11:31,060
unified kernel the primary is a page

00:11:28,990 --> 00:11:35,829
from the past and it's actually going to

00:11:31,060 --> 00:11:39,250
be deprecated with 1.8 once this is done

00:11:35,829 --> 00:11:42,279
basically let me spend another couple of

00:11:39,250 --> 00:11:45,790
words on with service asian features

00:11:42,279 --> 00:11:47,860
basically when we plug award drivers we

00:11:45,790 --> 00:11:49,540
need to plug the basic system here for

00:11:47,860 --> 00:11:51,250
example if we want to do pin muxing

00:11:49,540 --> 00:11:55,630
the initial pin muxing of the board

00:11:51,250 --> 00:11:59,110
probably it will be a kernel one once

00:11:55,630 --> 00:12:03,190
this is done basically it initializes

00:11:59,110 --> 00:12:05,350
the canneries and if configured it

00:12:03,190 --> 00:12:09,100
prints the banner of the operating

00:12:05,350 --> 00:12:10,690
system finished with this basically goes

00:12:09,100 --> 00:12:13,480
to the real initialization of the

00:12:10,690 --> 00:12:18,610
multitasking so in particular initialize

00:12:13,480 --> 00:12:20,730
the main thread on our platforms the

00:12:18,610 --> 00:12:23,410
main thread is implemented by a

00:12:20,730 --> 00:12:26,440
dysfunction here and in particular what

00:12:23,410 --> 00:12:28,420
it does it moves the program stock

00:12:26,440 --> 00:12:32,470
pointer to the I address in the stack

00:12:28,420 --> 00:12:34,899
unlocks the interrupts and branches to

00:12:32,470 --> 00:12:37,120
the underscore main functionality that

00:12:34,899 --> 00:12:39,600
is the functionality that at the end

00:12:37,120 --> 00:12:41,649
will call the main of our application

00:12:39,600 --> 00:12:43,690
underscore main basically does the

00:12:41,649 --> 00:12:46,240
second part of the initialization of the

00:12:43,690 --> 00:12:50,680
kernel so basically if we have an eye

00:12:46,240 --> 00:12:55,899
level feature in our operating system we

00:12:50,680 --> 00:12:57,730
can initialize it here or if we have a

00:12:55,899 --> 00:13:00,310
functionality that takes advantage of

00:12:57,730 --> 00:13:02,140
what we have initialized in the kernel

00:13:00,310 --> 00:13:06,339
one kernel - initialization we will

00:13:02,140 --> 00:13:09,699
initialize it here in particular as you

00:13:06,339 --> 00:13:11,079
can notice even for the second part here

00:13:09,699 --> 00:13:12,760
there are some features that are

00:13:11,079 --> 00:13:15,430
deprecated because they are

00:13:12,760 --> 00:13:16,280
initialization features of the Nano

00:13:15,430 --> 00:13:21,200
Carol and Mike

00:13:16,280 --> 00:13:24,050
colonel that are in Raritan into the

00:13:21,200 --> 00:13:26,740
unified colonel it is the variant that

00:13:24,050 --> 00:13:29,870
we are using now in 2000

00:13:26,740 --> 00:13:32,180
once this initialization is complete

00:13:29,870 --> 00:13:34,670
basically the underscore main

00:13:32,180 --> 00:13:38,060
initialized the static threads like the

00:13:34,670 --> 00:13:40,670
idle for example and jumps to the main

00:13:38,060 --> 00:13:44,600
the main is the main of our application

00:13:40,670 --> 00:13:46,790
and at that point basically the the

00:13:44,600 --> 00:13:52,640
femur does what we have decided for it

00:13:46,790 --> 00:13:55,040
to do said that basically let's see how

00:13:52,640 --> 00:13:57,770
the supporting plugs in this

00:13:55,040 --> 00:14:00,830
infrastructure in order to have a

00:13:57,770 --> 00:14:04,970
complete supporting supporting we need

00:14:00,830 --> 00:14:08,090
the 4k config file in particular one

00:14:04,970 --> 00:14:10,700
that defines the sock one that defines

00:14:08,090 --> 00:14:12,710
the series on which we are working one

00:14:10,700 --> 00:14:15,560
that defined the def config of the

00:14:12,710 --> 00:14:18,200
series and one that defines the DEF

00:14:15,560 --> 00:14:21,710
config of the variant so the variant is

00:14:18,200 --> 00:14:24,140
the specific chip of the series that we

00:14:21,710 --> 00:14:26,900
are using for example the series is

00:14:24,140 --> 00:14:29,600
betul betul r0 that has specific

00:14:26,900 --> 00:14:35,990
features like a dimension of the ROM a

00:14:29,600 --> 00:14:38,450
dimension of the ROM is our variant K

00:14:35,990 --> 00:14:42,200
config series what does in particular it

00:14:38,450 --> 00:14:44,930
enables the family and the specification

00:14:42,200 --> 00:14:48,790
of the soul to which we have to rely in

00:14:44,930 --> 00:14:51,530
order to boot our system done that

00:14:48,790 --> 00:14:55,760
basically we have to start adding a set

00:14:51,530 --> 00:14:57,589
of source files and in particular the

00:14:55,760 --> 00:15:01,250
boot and record of our platform that is

00:14:57,589 --> 00:15:04,250
defined in sock dot C they I accuse

00:15:01,250 --> 00:15:07,160
definition that is defined in sock

00:15:04,250 --> 00:15:10,040
underscore I accuse dot H the pin

00:15:07,160 --> 00:15:13,190
definitions that is defined in pins dot

00:15:10,040 --> 00:15:16,100
H and underscore pins dot H the

00:15:13,190 --> 00:15:17,780
registers that are defined in sock

00:15:16,100 --> 00:15:20,540
underscore registers and the power

00:15:17,780 --> 00:15:22,730
management that is the final empowerment

00:15:20,540 --> 00:15:25,430
mental see some of these include

00:15:22,730 --> 00:15:28,610
probably will go away when the device 3

00:15:25,430 --> 00:15:32,750
will be there completely

00:15:28,610 --> 00:16:23,580
if we look at this implementation of

00:15:32,750 --> 00:16:26,370
basically what we do and once this is

00:16:23,580 --> 00:16:28,140
done basically we unlock the interrupts

00:16:26,370 --> 00:16:30,750
and the execution will continue

00:16:28,140 --> 00:16:34,620
obviously for what we have said in the

00:16:30,750 --> 00:16:36,990
initial configuration of our booster of

00:16:34,620 --> 00:16:39,800
the kernel on arm architectures this is

00:16:36,990 --> 00:16:39,800
executed in

00:17:21,169 --> 00:17:28,140
once this is executed basically our

00:17:23,819 --> 00:17:30,450
basic sort it is initialized let's see

00:17:28,140 --> 00:17:34,169
now how do we plug the board the board

00:17:30,450 --> 00:17:36,240
is responsible mainly for the

00:17:34,169 --> 00:17:39,419
definitions that are related to the

00:17:36,240 --> 00:17:41,909
board they initial pin muxing

00:17:39,419 --> 00:17:44,730
it's responsible for the configuration

00:17:41,909 --> 00:17:46,559
files that are board related for example

00:17:44,730 --> 00:17:48,419
if you have some sensors that have

00:17:46,559 --> 00:17:51,500
specific configuration on the board you

00:17:48,419 --> 00:17:53,760
put the configuration on this level it's

00:17:51,500 --> 00:17:55,740
responsible for the main platform make

00:17:53,760 --> 00:17:59,520
file that is the one that defines all

00:17:55,740 --> 00:18:01,950
the make configurations that you need in

00:17:59,520 --> 00:18:05,460
order to compile your board and of the

00:18:01,950 --> 00:18:08,880
board documentation so basically the

00:18:05,460 --> 00:18:11,909
documentation is very important and it

00:18:08,880 --> 00:18:13,679
it has to provide at least one example

00:18:11,909 --> 00:18:16,169
of application with which you have

00:18:13,679 --> 00:18:19,520
tested your board once you deliver it

00:18:16,169 --> 00:18:21,870
for acceptance into the deferred kernel

00:18:19,520 --> 00:18:26,059
another thing that is very important at

00:18:21,870 --> 00:18:26,059
this level we define our def config and

00:18:26,570 --> 00:18:31,289
once you are ready to submit your patch

00:18:29,070 --> 00:18:33,270
a tiered action that you have to take in

00:18:31,289 --> 00:18:35,309
order to have it accepted is add your

00:18:33,270 --> 00:18:36,899
board to the sanity check this is very

00:18:35,309 --> 00:18:38,549
important because scientific is an

00:18:36,899 --> 00:18:43,130
automated test environment that is

00:18:38,549 --> 00:18:47,610
inside that allows you to have static

00:18:43,130 --> 00:18:48,990
tests at Build time and let's say

00:18:47,610 --> 00:18:53,059
dynamic at run time

00:18:48,990 --> 00:18:53,059
you can set different options

00:18:54,000 --> 00:19:00,240
let's see now I with the final word of

00:18:56,879 --> 00:19:03,149
config and now this will take action on

00:19:00,240 --> 00:19:05,220
our work a config file so basically in

00:19:03,149 --> 00:19:07,679
our death config we define all the

00:19:05,220 --> 00:19:09,470
principal features of the ARM

00:19:07,679 --> 00:19:12,090
architecture and how it has to be

00:19:09,470 --> 00:19:13,529
invoked and defined and which are the

00:19:12,090 --> 00:19:17,070
features in the kernel that it has to

00:19:13,529 --> 00:19:20,279
enable and we define a set of IPS that

00:19:17,070 --> 00:19:22,529
needs to be initialized so for example

00:19:20,279 --> 00:19:25,460
in the case of beetle with the find here

00:19:22,529 --> 00:19:25,460
the config GPIO

00:19:40,830 --> 00:19:46,700
now that we have defined the socketed

00:19:43,290 --> 00:19:50,820
ball our attention goes to the drivers

00:19:46,700 --> 00:19:54,420
and in particular Zephyr OS supports

00:19:50,820 --> 00:19:56,700
different types of drivers it provides a

00:19:54,420 --> 00:19:59,250
consistent device model that is

00:19:56,700 --> 00:20:01,170
responsible for the configuration of the

00:19:59,250 --> 00:20:04,980
drivers that are part of the system and

00:20:01,170 --> 00:20:08,100
for initializing them at when the

00:20:04,980 --> 00:20:10,590
drivers are configured each type of

00:20:08,100 --> 00:20:14,300
driver is supported by a generic API and

00:20:10,590 --> 00:20:17,730
this API is defined in device dot H and

00:20:14,300 --> 00:20:19,830
basically this API is done in a way that

00:20:17,730 --> 00:20:21,660
is independent from the system let's in

00:20:19,830 --> 00:20:23,580
particular what this independence mean

00:20:21,660 --> 00:20:27,980
and to do that we have to reference at

00:20:23,580 --> 00:20:27,980
the device model in particular

00:20:59,600 --> 00:21:06,600
is done in a way that basically allows

00:21:03,330 --> 00:21:08,730
the system to be independent from the

00:21:06,600 --> 00:21:10,470
driver implementation and in particular

00:21:08,730 --> 00:21:12,420
defines a set of actions that are

00:21:10,470 --> 00:21:17,010
implemented as a function point by your

00:21:12,420 --> 00:21:21,140
drivers obviously if you have when you

00:21:17,010 --> 00:21:21,140
are writing your code you are just

00:21:27,530 --> 00:21:39,720
obviously when you are trying to access

00:21:30,210 --> 00:21:42,810
to the device the scenario is like let's

00:21:39,720 --> 00:21:45,570
see now this device model reflects from

00:21:42,810 --> 00:21:47,160
the drivers and in particular let's

00:21:45,570 --> 00:21:48,720
start from the pin muxing because it's

00:21:47,160 --> 00:21:51,500
the easier one what the pin muxing

00:21:48,720 --> 00:21:54,300
defines is the pin muxing a good time so

00:21:51,500 --> 00:21:56,220
we have two types of pin muxing we have

00:21:54,300 --> 00:21:58,580
static pin muxing that is this one and

00:21:56,220 --> 00:22:00,600
the runtime pin muxing that is a

00:21:58,580 --> 00:22:03,390
different driver that we will see later

00:22:00,600 --> 00:22:08,120
the static pin muxing is the file inside

00:22:03,390 --> 00:22:08,120
pin muxing dot c and basically

00:22:13,900 --> 00:22:17,160
for example

00:22:31,130 --> 00:22:38,130
and for obvious reason diseases executed

00:22:35,100 --> 00:22:42,360
again in Colonel won the run time pin

00:22:38,130 --> 00:22:44,220
muxing allows instead to have the

00:22:42,360 --> 00:22:49,830
opportunity to rotate the pins from your

00:22:44,220 --> 00:22:52,440
application this is a mainly prototyping

00:22:49,830 --> 00:22:56,299
feature in Zephyr because when it is

00:22:52,440 --> 00:22:59,399
possible things are done statically so

00:22:56,299 --> 00:23:01,440
suggestion is in order to not break

00:22:59,399 --> 00:23:05,250
shields that you plug on your system to

00:23:01,440 --> 00:23:07,620
check the trm and more than the world I

00:23:05,250 --> 00:23:11,460
shouldn't say this but it's something

00:23:07,620 --> 00:23:14,190
that I like to suggest and to encourage

00:23:11,460 --> 00:23:19,559
people to do before they they use the

00:23:14,190 --> 00:23:22,320
dynamic pin muxing and basically it is

00:23:19,559 --> 00:23:24,960
mainly used for early testing and

00:23:22,320 --> 00:23:26,520
prototyping a it can be used even for

00:23:24,960 --> 00:23:29,130
power management if you want to do

00:23:26,520 --> 00:23:31,730
particular operations in this case it

00:23:29,130 --> 00:23:31,730
provides an API

00:24:00,590 --> 00:24:05,720
and basically once this is done

00:24:08,000 --> 00:24:13,280
okay it's a it's pasta

00:24:20,880 --> 00:24:28,289
there are some IP some IPS in certain

00:24:25,350 --> 00:24:30,480
associates that manage both GPO Sam pin

00:24:28,289 --> 00:24:32,759
muxing in a single eyepiece but there

00:24:30,480 --> 00:24:34,889
are others that basically are splitted

00:24:32,759 --> 00:24:37,289
they split the functionality so that's

00:24:34,889 --> 00:24:39,269
the reason why in Zephyr you find a

00:24:37,289 --> 00:24:41,309
driver that is responsible for the GPS

00:24:39,269 --> 00:24:42,149
and the driver that is responsible for

00:24:41,309 --> 00:24:44,759
the pin muxing

00:24:42,149 --> 00:24:46,649
even if on beetle this differentiation

00:24:44,759 --> 00:24:48,509
could be avoided because we have a

00:24:46,649 --> 00:24:50,570
single IP that manages both the

00:24:48,509 --> 00:24:52,500
functionalities anyway

00:24:50,570 --> 00:24:56,159
following the implementation that is

00:24:52,500 --> 00:24:59,820
provided by the Fury's the API for the

00:24:56,159 --> 00:25:01,679
GPIOs is provided by GPIO dotage and it

00:24:59,820 --> 00:25:03,899
offered the standard functionalities to

00:25:01,679 --> 00:25:06,539
access to the Sun GPS like the

00:25:03,899 --> 00:25:09,269
configuration the read the right and the

00:25:06,539 --> 00:25:12,960
call back for their cue when the RQ is

00:25:09,269 --> 00:25:16,519
right erased so this is the way on which

00:25:12,960 --> 00:25:16,519
the GPIO

00:25:28,919 --> 00:25:35,940
and it uses the same logic of the

00:25:33,249 --> 00:25:35,940
devices

00:25:39,460 --> 00:25:47,320
that basically you will be able to

00:25:42,190 --> 00:25:49,480
access to your GPS implementation same

00:25:47,320 --> 00:25:52,299
logic and philosophy follows the Ewart

00:25:49,480 --> 00:25:55,899
but they are the differences that can be

00:25:52,299 --> 00:25:58,570
accessed both in interrupt mode and in

00:25:55,899 --> 00:26:01,779
polling so to do that as you can see

00:25:58,570 --> 00:26:04,270
from the feature set provides a couple

00:26:01,779 --> 00:26:06,159
of different options of configuration

00:26:04,270 --> 00:26:08,770
you have the default that is the polling

00:26:06,159 --> 00:26:10,419
you have pauline and pull out and you

00:26:08,770 --> 00:26:12,429
have all the features that you need to

00:26:10,419 --> 00:26:16,450
implement in order to have access

00:26:12,429 --> 00:26:19,330
interrupt-driven the API is provided by

00:26:16,450 --> 00:26:21,610
your voltage and the UART is initialized

00:26:19,330 --> 00:26:23,470
internal one because obviously for the

00:26:21,610 --> 00:26:26,590
bugging the most common way is using the

00:26:23,470 --> 00:26:30,970
print the print k so basically you wanna

00:26:26,590 --> 00:26:32,950
have access to it let's see the watchdog

00:26:30,970 --> 00:26:34,840
the watchdog on beetle I use this

00:26:32,950 --> 00:26:36,039
example because it's a bit particular so

00:26:34,840 --> 00:26:38,440
shares they interrupt with the

00:26:36,039 --> 00:26:40,149
non-maskable interrupt so basically what

00:26:38,440 --> 00:26:42,159
you need to do to enable the interrupt

00:26:40,149 --> 00:26:44,440
on a platform that isn't configured in

00:26:42,159 --> 00:26:46,809
this way you need to configure something

00:26:44,440 --> 00:26:49,710
called runtime MMI so runtime animai

00:26:46,809 --> 00:26:55,360
allows you to replace they interrupt

00:26:49,710 --> 00:26:57,820
into your into the interrupt associated

00:26:55,360 --> 00:26:59,830
to your IR to number with the new one

00:26:57,820 --> 00:27:02,350
that you are going to the file when you

00:26:59,830 --> 00:27:04,659
initialize your driver and in particular

00:27:02,350 --> 00:27:10,299
the functionality that allows you to do

00:27:04,659 --> 00:27:12,700
that is the nmi endler set so done that

00:27:10,299 --> 00:27:14,890
basically next time the interrupt

00:27:12,700 --> 00:27:18,010
handler is the interrupt

00:27:14,890 --> 00:27:20,529
then my interrupt a day instead of

00:27:18,010 --> 00:27:22,779
calling the initial routine that you set

00:27:20,529 --> 00:27:24,789
up when we define at the sock we are

00:27:22,779 --> 00:27:29,020
calling our routine obviously doing that

00:27:24,789 --> 00:27:32,740
we are going to take care of managing

00:27:29,020 --> 00:27:34,870
our reel and a my ring so basically if

00:27:32,740 --> 00:27:36,820
it we have to discriminate if it is

00:27:34,870 --> 00:27:43,539
coming from the watchdog or its real and

00:27:36,820 --> 00:27:47,020
am I so done that let's see now how we

00:27:43,539 --> 00:27:50,620
build a driver into our deferred system

00:27:47,020 --> 00:27:52,809
we saw few classes of drivers now we see

00:27:50,620 --> 00:27:55,179
how this can be built in

00:27:52,809 --> 00:27:57,549
particular the strategy that I like to

00:27:55,179 --> 00:28:01,259
follow when I do these things and maybe

00:27:57,549 --> 00:28:05,470
it can be useful for someone of you is

00:28:01,259 --> 00:28:07,870
before configure the driver where it

00:28:05,470 --> 00:28:11,019
sits so in the directory where it sits

00:28:07,870 --> 00:28:14,169
and after configure the platform to use

00:28:11,019 --> 00:28:17,470
the driver in particular what what I do

00:28:14,169 --> 00:28:20,710
is modifying the make file that endows

00:28:17,470 --> 00:28:23,110
the driver itself modifying the config

00:28:20,710 --> 00:28:24,340
that is local to the driver in order to

00:28:23,110 --> 00:28:26,980
enable the features and the

00:28:24,340 --> 00:28:32,710
functionalities and then enabling the

00:28:26,980 --> 00:28:35,350
def config of the platform and the and

00:28:32,710 --> 00:28:36,879
the DEF CON take a config of the

00:28:35,350 --> 00:28:39,360
platform and the def config of the

00:28:36,879 --> 00:28:42,700
platform as you can see here basically

00:28:39,360 --> 00:28:44,950
once this is done basically you can use

00:28:42,700 --> 00:28:47,669
one of the examples to compile this

00:28:44,950 --> 00:28:50,799
particular IP and compile it into your

00:28:47,669 --> 00:28:53,369
into your application and use it with

00:28:50,799 --> 00:28:58,830
the API I get device binding and

00:28:53,369 --> 00:29:01,090
providing a name basically this is

00:28:58,830 --> 00:29:03,549
mostly all what you need to do in order

00:29:01,090 --> 00:29:06,369
to port a new platform into there a

00:29:03,549 --> 00:29:07,779
basic platform obviously as I said at

00:29:06,369 --> 00:29:10,659
the beginning this is a starting point

00:29:07,779 --> 00:29:12,759
so there are more things that you you

00:29:10,659 --> 00:29:14,799
you need to do if you want to enhance it

00:29:12,759 --> 00:29:17,289
and provide new functionalities like for

00:29:14,799 --> 00:29:19,450
example the clock control or another

00:29:17,289 --> 00:29:24,820
functionalities can be the timer so and

00:29:19,450 --> 00:29:27,129
so far and so on in fact who to complete

00:29:24,820 --> 00:29:29,470
the porting of beatle we need to take

00:29:27,129 --> 00:29:31,450
some extra steps so let's see what are

00:29:29,470 --> 00:29:34,299
these next steps what we will need to do

00:29:31,450 --> 00:29:36,039
is basically to improve continue to

00:29:34,299 --> 00:29:38,259
continue improving the codebase to

00:29:36,039 --> 00:29:41,460
remain aligned with the new development

00:29:38,259 --> 00:29:45,879
of Zephyr enable the missing eyepiece

00:29:41,460 --> 00:29:48,249
the missing IP drivers and complete the

00:29:45,879 --> 00:29:51,429
power management our implementation

00:29:48,249 --> 00:29:53,679
still doesn't support deep sleep enable

00:29:51,429 --> 00:29:55,600
the connectivity our chip as I said has

00:29:53,679 --> 00:29:57,310
a really low power and

00:29:55,600 --> 00:29:59,740
we are planning to enable it in the

00:29:57,310 --> 00:30:02,160
coming months and announce the

00:29:59,740 --> 00:30:04,480
documentation that is something that

00:30:02,160 --> 00:30:10,390
it's very important for this project

00:30:04,480 --> 00:30:14,110
sorry if I stress a lot this now

00:30:10,390 --> 00:30:15,580
I hope apart the accident that we had

00:30:14,110 --> 00:30:17,710
with my laptop switching that I have

00:30:15,580 --> 00:30:19,450
inspired you a bit so let's see how to

00:30:17,710 --> 00:30:21,640
contribute to the project because it's

00:30:19,450 --> 00:30:24,610
very good to have new ends and new

00:30:21,640 --> 00:30:27,250
people that look at our code and provide

00:30:24,610 --> 00:30:29,710
new idea because I know the powerfulness

00:30:27,250 --> 00:30:32,230
of an open source project is getting in

00:30:29,710 --> 00:30:34,000
new ideas and get inspiration for new

00:30:32,230 --> 00:30:37,020
people that just start working on the

00:30:34,000 --> 00:30:39,730
project and provide their view on things

00:30:37,020 --> 00:30:42,160
to contribute to this project basically

00:30:39,730 --> 00:30:44,950
what you need to do is a pretty easy are

00:30:42,160 --> 00:30:47,110
five six steps you need to request an

00:30:44,950 --> 00:30:48,370
account to the Linux Foundation probably

00:30:47,110 --> 00:30:50,740
if you are here we already everyone

00:30:48,370 --> 00:30:54,490
because you had to subscribe to come

00:30:50,740 --> 00:30:56,950
here so this step we can cancel it you

00:30:54,490 --> 00:30:59,820
have to clone the Zephyr source code and

00:30:56,950 --> 00:31:04,300
start talking that is the funniest part

00:30:59,820 --> 00:31:06,220
create a patch on from the source line

00:31:04,300 --> 00:31:10,270
later source tree check the code style

00:31:06,220 --> 00:31:13,750
and some other things and submit the

00:31:10,270 --> 00:31:17,380
changes through the Gerrit once this is

00:31:13,750 --> 00:31:19,900
done the review will start and open

00:31:17,380 --> 00:31:22,780
everything is done well you will get

00:31:19,900 --> 00:31:26,410
your code in and you can continue the

00:31:22,780 --> 00:31:29,020
development to make something useful I

00:31:26,410 --> 00:31:30,550
want to provide to you the links to

00:31:29,020 --> 00:31:33,100
which you can do this operation so

00:31:30,550 --> 00:31:36,040
basically the Gerrit repository is the

00:31:33,100 --> 00:31:42,160
first one and basically this is the way

00:31:36,040 --> 00:31:44,080
to clone it by agate you can find a lot

00:31:42,160 --> 00:31:48,460
of information on the deferred project

00:31:44,080 --> 00:31:50,740
website but if you are not satisfied you

00:31:48,460 --> 00:31:52,480
want more you want to know details of

00:31:50,740 --> 00:31:54,700
something there are two very useful

00:31:52,480 --> 00:31:57,430
mailing lists to which you can subscribe

00:31:54,700 --> 00:31:59,020
and become part of the community and

00:31:57,430 --> 00:32:01,120
these are in particular the development

00:31:59,020 --> 00:32:02,980
mailing list and the users mailing lists

00:32:01,120 --> 00:32:05,710
development mailing list is more used

00:32:02,980 --> 00:32:06,260
for problems like the token encounter

00:32:05,710 --> 00:32:08,240
during the

00:32:06,260 --> 00:32:09,860
development and you wanna submit to the

00:32:08,240 --> 00:32:11,990
rest of the community and the users

00:32:09,860 --> 00:32:14,060
mailing list is mostly used if you have

00:32:11,990 --> 00:32:17,930
time to use the camel so making an

00:32:14,060 --> 00:32:21,560
application and other stuff and then we

00:32:17,930 --> 00:32:23,900
have an IRC channel that is for the

00:32:21,560 --> 00:32:26,000
project and one for the ble related

00:32:23,900 --> 00:32:33,160
topics not a list that I pointed out

00:32:26,000 --> 00:32:33,160
there now let's go to the demo

00:33:02,590 --> 00:33:07,890
it was already but I had to reserve my

00:33:04,990 --> 00:33:07,890
laptop or music

00:33:56,290 --> 00:34:02,510
so

00:33:58,130 --> 00:34:04,520
basically this is a beetle and let's say

00:34:02,510 --> 00:34:08,300
that you are trying to debug a new

00:34:04,520 --> 00:34:09,770
shield okay so you just created so that

00:34:08,300 --> 00:34:11,929
your shield because you are trying to

00:34:09,770 --> 00:34:14,570
prototype something and you want to know

00:34:11,929 --> 00:34:17,480
if all the things that you put on your

00:34:14,570 --> 00:34:22,750
shield are behaving correctly now awaken

00:34:17,480 --> 00:34:26,540
be write a lot of lines of code in C and

00:34:22,750 --> 00:34:28,580
discover later if this is true or use

00:34:26,540 --> 00:34:31,129
another open source project that is

00:34:28,580 --> 00:34:33,679
called micro Python and write simple

00:34:31,129 --> 00:34:36,320
scripts to do the same thing what I

00:34:33,679 --> 00:34:39,679
wanna show to you today is basically how

00:34:36,320 --> 00:34:42,770
I can leverage micro Python putting it

00:34:39,679 --> 00:34:47,600
on my dream plantation using the GPIOs

00:34:42,770 --> 00:34:51,200
in order to verify if my LED and my two

00:34:47,600 --> 00:34:54,320
sensors here are working and to do that

00:34:51,200 --> 00:34:56,649
I will use simple scripts but let's

00:34:54,320 --> 00:34:56,649
start

00:35:02,960 --> 00:35:06,430
Kristen you can see it

00:35:12,780 --> 00:35:21,089
okay so

00:35:16,380 --> 00:35:23,009
basically let's start with the lead

00:35:21,089 --> 00:35:25,440
let's see that let's say that you solved

00:35:23,009 --> 00:35:29,339
a talent and you wanna verify that the

00:35:25,440 --> 00:35:32,579
lady's working once you're obviously

00:35:29,339 --> 00:35:38,660
lead is connected through a GP to a GPIO

00:35:32,579 --> 00:35:43,410
so what is Easter and let's let's see

00:35:38,660 --> 00:35:47,339
how this can be blinked in order to

00:35:43,410 --> 00:35:49,559
verify that is working I'm going to copy

00:35:47,339 --> 00:35:53,210
and paste the script that we will

00:35:49,559 --> 00:35:53,210
comment together in a second

00:36:00,290 --> 00:36:03,010
yes

00:36:06,770 --> 00:36:24,060
okay

00:36:08,430 --> 00:36:26,910
so this is what what you need to do and

00:36:24,060 --> 00:36:30,690
the first time I wrote it I was

00:36:26,910 --> 00:36:34,470
surprised it was working seriously

00:36:30,690 --> 00:36:36,570
because you have to write at least three

00:36:34,470 --> 00:36:38,400
times C code in order to have similar

00:36:36,570 --> 00:36:40,950
functionality is considering maÃ®trise

00:36:38,400 --> 00:36:44,360
project files and everything to put it

00:36:40,950 --> 00:36:44,360
into into Zephyr

00:36:49,280 --> 00:36:56,660
can you see the LED blinking okay so now

00:36:54,260 --> 00:36:58,130
let's complicate it a bit let's say that

00:36:56,660 --> 00:37:00,980
you are in a scenario in which you want

00:36:58,130 --> 00:37:04,660
to debug one of the sensors that are

00:37:00,980 --> 00:37:10,070
here and in particular this one that is

00:37:04,660 --> 00:37:13,099
what is this is a sonar so basically

00:37:10,070 --> 00:37:15,470
this is sonar access you can access to

00:37:13,099 --> 00:37:18,290
it through the wired protocol so

00:37:15,470 --> 00:37:20,150
basically you define a time slice and it

00:37:18,290 --> 00:37:21,619
keep sending to you one and zero based

00:37:20,150 --> 00:37:24,670
on the value that you want to send and

00:37:21,619 --> 00:37:27,080
there is a combustion formula on the

00:37:24,670 --> 00:37:30,670
technical reference manual of the sensor

00:37:27,080 --> 00:37:32,390
so in order to in order to basically

00:37:30,670 --> 00:37:34,220
access to it

00:37:32,390 --> 00:37:36,430
this is the Python code that I need to

00:37:34,220 --> 00:37:36,430
write

00:37:42,619 --> 00:37:45,220
okay

00:38:00,390 --> 00:38:09,210
yeah it's all here again from the sensor

00:38:06,570 --> 00:38:14,210
I'm accessing people Jo and I'm very

00:38:09,210 --> 00:38:14,210
find them zeros one is coming back

00:38:20,760 --> 00:38:26,940
it's working

00:38:23,070 --> 00:38:29,130
so now let's complicate it a bit more

00:38:26,940 --> 00:38:31,680
let's say that for the third sensor I

00:38:29,130 --> 00:38:34,380
want to write a driver it's again using

00:38:31,680 --> 00:38:36,960
the Wyatt protocol but in this case I

00:38:34,380 --> 00:38:41,100
want to write a full full driver

00:38:36,960 --> 00:38:45,780
so the third sensor is max named nine

00:38:41,100 --> 00:38:51,750
eight nine eight one four and basically

00:38:45,780 --> 00:38:54,290
is this guy here so it measures the

00:38:51,750 --> 00:38:54,290
level of noise

00:39:22,800 --> 00:39:28,040
this is all what I need to do to read

00:39:24,870 --> 00:39:30,600
the noise level in the room so

00:39:28,040 --> 00:39:33,140
considering that you are very quiet it

00:39:30,600 --> 00:39:33,140
should be low

00:39:51,760 --> 00:39:59,320
yep it's very low if we wanna verify

00:39:55,840 --> 00:40:02,770
that it's it's working I can keep

00:39:59,320 --> 00:40:06,400
flipping on the sensor executing the

00:40:02,770 --> 00:40:08,700
same code and verify that the value was

00:40:06,400 --> 00:40:08,700
I

00:40:18,339 --> 00:40:23,800
yep

00:40:19,870 --> 00:40:26,280
so basically now we can go back to the

00:40:23,800 --> 00:40:26,280
presentation

00:40:31,940 --> 00:40:38,570
what we have seen here we have seen

00:40:36,350 --> 00:40:39,830
basically a micro Python and you can

00:40:38,570 --> 00:40:42,490
compile micro Python if you are

00:40:39,830 --> 00:40:44,900
interested on your platform using the

00:40:42,490 --> 00:40:47,180
easiest way is using the really narrow

00:40:44,900 --> 00:40:49,310
release but you can rely on the micro

00:40:47,180 --> 00:40:51,890
Python official repository in order to

00:40:49,310 --> 00:40:53,420
compile it this this example is based on

00:40:51,890 --> 00:40:56,330
the Leonardo release that's why I put it

00:40:53,420 --> 00:41:00,400
on these slides the source code can be

00:40:56,330 --> 00:41:03,230
accessed there what you need to do is a

00:41:00,400 --> 00:41:04,730
set of simple operations in order to get

00:41:03,230 --> 00:41:07,880
it again you are compiling for the

00:41:04,730 --> 00:41:10,790
bitter boar and what we have seen right

00:41:07,880 --> 00:41:14,030
now is basically something similar to

00:41:10,790 --> 00:41:16,580
this to verify that it was working said

00:41:14,030 --> 00:41:18,920
that I will I leave you with one example

00:41:16,580 --> 00:41:24,890
that I ran it here if you want to try it

00:41:18,920 --> 00:41:27,790
at home on a new board in conclusion so

00:41:24,890 --> 00:41:30,020
we have seen the fare architecture today

00:41:27,790 --> 00:41:33,230
we have seen the setup of the

00:41:30,020 --> 00:41:35,540
environment we have seen basic porting

00:41:33,230 --> 00:41:38,150
of the from beetle we've seen how to

00:41:35,540 --> 00:41:40,400
contribute to the project and we have

00:41:38,150 --> 00:41:43,280
seen mouth micro Python but before

00:41:40,400 --> 00:41:45,410
concluding let me say that hi join at

00:41:43,280 --> 00:41:48,230
the deferred project lens in less than

00:41:45,410 --> 00:41:50,770
six months ago and this forum is a

00:41:48,230 --> 00:41:53,930
tremendous moment of of being there I

00:41:50,770 --> 00:41:57,380
was too young in the early 90s so we are

00:41:53,930 --> 00:42:00,620
also by the ELC here and I was too young

00:41:57,380 --> 00:42:03,440
to leave the early days of Linux but

00:42:00,620 --> 00:42:07,970
reading from the books and mailing lists

00:42:03,440 --> 00:42:10,610
of that age basically I feel the similar

00:42:07,970 --> 00:42:12,500
sensation that my code can really change

00:42:10,610 --> 00:42:14,890
something in the project in this

00:42:12,500 --> 00:42:17,360
historical moment of the project so

00:42:14,890 --> 00:42:19,960
again please come and join us thank you

00:42:17,360 --> 00:42:19,960
for coming

00:42:21,900 --> 00:42:27,220
so if you have any questions these are

00:42:24,759 --> 00:42:35,249
my contacts if you want to refer to them

00:42:27,220 --> 00:42:35,249
take a picture I don't know yes please

00:42:39,440 --> 00:42:44,369
it provides a console you have a console

00:42:42,119 --> 00:42:48,510
shell that you can compile inside your

00:42:44,369 --> 00:42:50,910
application it's already it has already

00:42:48,510 --> 00:42:53,550
some comments for debugging purposes but

00:42:50,910 --> 00:42:55,700
you can extend it if you are interested

00:42:53,550 --> 00:42:55,700
in

00:43:00,259 --> 00:43:06,289
I started six months ago the porting and

00:43:03,729 --> 00:43:08,809
basically I am already at this stage I

00:43:06,289 --> 00:43:10,400
didn't even some work with nd for the

00:43:08,809 --> 00:43:12,799
device 3 as you have seen from his

00:43:10,400 --> 00:43:17,239
presentation this morning so basically

00:43:12,799 --> 00:43:19,460
it takes let's say a month to port the

00:43:17,239 --> 00:43:21,950
basic platform and to ramp up and then

00:43:19,460 --> 00:43:24,470
the easiest way the easiest thing that I

00:43:21,950 --> 00:43:28,489
found in the project is literally access

00:43:24,470 --> 00:43:31,160
to the channel and ask to people so it's

00:43:28,489 --> 00:43:34,279
it's daisies or just send an email or

00:43:31,160 --> 00:43:36,529
you have my reference on IRC you can ask

00:43:34,279 --> 00:43:38,599
to me directly and if I don't know I can

00:43:36,529 --> 00:43:40,160
point you to the right people that can

00:43:38,599 --> 00:43:42,400
provide to you the information that you

00:43:40,160 --> 00:43:42,400
want

00:43:48,580 --> 00:43:55,870
I am not sure what you mean with WebKit

00:43:53,200 --> 00:44:01,750
because WebKit is an engine for web

00:43:55,870 --> 00:44:05,830
browsing right so yeah because this is a

00:44:01,750 --> 00:44:09,010
this is a system that runs on as less as

00:44:05,830 --> 00:44:10,480
8 kilobytes so basically if you want to

00:44:09,010 --> 00:44:13,210
implement WebKit you would need

00:44:10,480 --> 00:44:14,560
megabytes I guess I am NOT expert of the

00:44:13,210 --> 00:44:17,070
technology but I guess you need

00:44:14,560 --> 00:44:17,070
megabytes

00:44:23,450 --> 00:44:32,930
a micro micro with micro Python is a bit

00:44:28,340 --> 00:44:36,320
bigger is like 100 but it's it's because

00:44:32,930 --> 00:44:38,570
it implements a lot of things so I can

00:44:36,320 --> 00:44:42,890
compile the same example with a little

00:44:38,570 --> 00:44:45,200
LED blinking in 9 to 10 kilobytes I am

00:44:42,890 --> 00:44:48,070
here three days I mean I can show it to

00:44:45,200 --> 00:44:48,070
you if you want

00:44:59,780 --> 00:45:06,740
I have the image here we can check how

00:45:02,570 --> 00:45:09,880
big it is yes you should I can provide

00:45:06,740 --> 00:45:09,880
to you the precise number

00:45:16,560 --> 00:45:20,570
it's 127 Ches

00:45:26,760 --> 00:45:29,420
yeah

00:45:31,270 --> 00:45:41,770
okay basically most of the pain points

00:45:37,590 --> 00:45:44,350
where because of of the way on which I

00:45:41,770 --> 00:45:47,020
approached the project so I'll give you

00:45:44,350 --> 00:45:49,900
an example if you go into the project

00:45:47,020 --> 00:45:54,400
and you push 10 patches 15 patches in

00:45:49,900 --> 00:45:56,170
one go for our Garrett is organized the

00:45:54,400 --> 00:46:00,310
chance that you get to have people

00:45:56,170 --> 00:46:04,180
looking at all 15 that patches it's not

00:46:00,310 --> 00:46:05,920
big okay so you something goes missing

00:46:04,180 --> 00:46:08,020
something remains left out and maybe

00:46:05,920 --> 00:46:10,060
it's crucial for you to get the change

00:46:08,020 --> 00:46:11,890
in especially if you are pushing a new

00:46:10,060 --> 00:46:14,410
platform is what I did at the beginning

00:46:11,890 --> 00:46:17,590
with Beto this is my experience then I

00:46:14,410 --> 00:46:20,110
learned and basically now I push maximum

00:46:17,590 --> 00:46:24,130
three four patches based on

00:46:20,110 --> 00:46:26,110
functionality and I use topic branches

00:46:24,130 --> 00:46:28,960
that is something very useful inside the

00:46:26,110 --> 00:46:32,680
project when you send to Garrett for

00:46:28,960 --> 00:46:35,170
review basically when you do refs for

00:46:32,680 --> 00:46:38,050
some branch then you can add another

00:46:35,170 --> 00:46:40,660
slash and at the topic for example v2

00:46:38,050 --> 00:46:42,820
and beetle in my case or a particular

00:46:40,660 --> 00:46:45,460
feature on Vito this helps the

00:46:42,820 --> 00:46:47,650
maintainer or who asked to review the

00:46:45,460 --> 00:46:51,700
patches to understand what you are going

00:46:47,650 --> 00:46:54,330
to target and makes easier for them to

00:46:51,700 --> 00:46:54,330
review the code

00:46:57,960 --> 00:47:01,040
and another question

00:47:04,920 --> 00:47:09,469
can you rise because I have this the fun

00:47:07,170 --> 00:47:09,469
here

00:47:12,790 --> 00:47:17,900
yeah there's a set of functions that are

00:47:15,619 --> 00:47:19,849
being implemented for whatever back-end

00:47:17,900 --> 00:47:22,550
you have for your board is it

00:47:19,849 --> 00:47:25,309
do they have support for other drivers

00:47:22,550 --> 00:47:28,430
than just GPIO or is it or is that all

00:47:25,309 --> 00:47:30,589
use for now thank you are what I was

00:47:28,430 --> 00:47:32,030
explaining during the presentation is

00:47:30,589 --> 00:47:34,130
that there is a full device model

00:47:32,030 --> 00:47:36,319
divided in classes so basically each

00:47:34,130 --> 00:47:39,589
class of drivers that is supported like

00:47:36,319 --> 00:47:42,589
the serial like the pin marks like it

00:47:39,589 --> 00:47:44,960
can be timers clock control everyone as

00:47:42,589 --> 00:47:47,660
this device model and basically you can

00:47:44,960 --> 00:47:49,970
rely on the device model file either

00:47:47,660 --> 00:47:51,980
file as part of the documentation in

00:47:49,970 --> 00:48:01,010
order to implement what you need to

00:47:51,980 --> 00:48:06,040
implement okay next question we have

00:48:01,010 --> 00:48:06,040
still eight minutes if you want I'm here

00:48:08,260 --> 00:48:14,329
okay I think we are done thanks again

00:48:11,300 --> 00:48:17,140
for coming and see you in the next day

00:48:14,329 --> 00:48:17,140
in the last few days

00:48:18,560 --> 00:48:22,020

YouTube URL: https://www.youtube.com/watch?v=DP9YAgDMRxw


