Title: The Aftermath of a Fuzz Run: What to do about those Crashes? - David Moore, Fuzz Stati0n
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	The Aftermath of a Fuzz Run: What to do about those Crashes? - David Moore, Fuzz Stati0n

Fuzzing is a highly effective means of finding security vulnerabilities - new, easy to use and highly effective Linux based fuzzers such as American Fuzzy Lop and libFuzzer have driven its increased popularity. Once a fuzz run has found cases that crash the target application, each must be reduced, triaged and the root cause found to enable a fix. In this presentation, David Moore will describe tools, tactics and techniques for performing post fuzz run analysis on the resulting crashes with the goal of fixing the vulnerabilities.

About David Moore
David Moore is founder and CEO of Fuzz Stati0n. He has been involved in software development and security for the past 20 years, working with NeXT, Apple, Weblogic and Azul Systems. David's trophy case includes public recognition from Google, Twitter, Netflix, Linux, Ruby, Python, and PHP. Fuzz Stati0n was founded to improve security for everyone. 

David has extensive speaking experience giving technical presentations and training to customers, partners and at conferences. He recently spoke at the Santa Cruz New Tech Meetup and will be presenting at BSides San Diego in 2017.
Captions: 
	00:00:00,000 --> 00:00:04,350
all right good morning my name is David

00:00:01,560 --> 00:00:05,850
Moore very happy to be here I just want

00:00:04,350 --> 00:00:07,620
to quickly say thank you for being here

00:00:05,850 --> 00:00:10,019
I really appreciate it and welcome to

00:00:07,620 --> 00:00:13,019
the embedded Linux conference and want

00:00:10,019 --> 00:00:14,400
to say thank you very much for the Linux

00:00:13,019 --> 00:00:18,210
Foundation for inviting me to speak

00:00:14,400 --> 00:00:21,510
today it's just a cute few quick details

00:00:18,210 --> 00:00:23,720
about my background I've been a

00:00:21,510 --> 00:00:26,340
professional software engineer since

00:00:23,720 --> 00:00:29,160
1994 had the opportunity to work with

00:00:26,340 --> 00:00:30,929
some great companies starting with next

00:00:29,160 --> 00:00:33,300
software I work for Steve Jobs back in

00:00:30,929 --> 00:00:36,809
the 90s doing web objects consulting one

00:00:33,300 --> 00:00:38,910
of the first web frameworks became Apple

00:00:36,809 --> 00:00:40,710
employee I went on until it works for

00:00:38,910 --> 00:00:42,320
some really really excellent companies

00:00:40,710 --> 00:00:45,300
and really great people in engineering

00:00:42,320 --> 00:00:48,120
sales consulting and business

00:00:45,300 --> 00:00:49,500
development roles but I was having a

00:00:48,120 --> 00:00:51,629
great time at that you know great career

00:00:49,500 --> 00:00:54,690
but I decided to kind of switch into

00:00:51,629 --> 00:00:56,640
consulting and so there I am consulting

00:00:54,690 --> 00:00:59,149
in Indonesia I was able to do that for a

00:00:56,640 --> 00:01:01,469
little while and that was really fun and

00:00:59,149 --> 00:01:04,019
and then I actually spent a couple of

00:01:01,469 --> 00:01:06,450
years as a semi-professional opera tenor

00:01:04,019 --> 00:01:09,180
I trained into opera I took a lot of

00:01:06,450 --> 00:01:11,549
voice lessons and I reached essentially

00:01:09,180 --> 00:01:14,220
a regional or semi-professional level so

00:01:11,549 --> 00:01:15,630
it's pretty exciting kind of got kicked

00:01:14,220 --> 00:01:17,939
out of opera though I wasn't loud enough

00:01:15,630 --> 00:01:18,990
you have to be very loud and and at the

00:01:17,939 --> 00:01:21,210
same time I was seeing some pretty

00:01:18,990 --> 00:01:23,909
amazing things going on in the security

00:01:21,210 --> 00:01:25,170
world even starting with Stuxnet and a

00:01:23,909 --> 00:01:28,200
lot of the big breaches that happen

00:01:25,170 --> 00:01:30,090
recently so or in you know 2012-2013 so

00:01:28,200 --> 00:01:31,619
I've really piqued my interest in I

00:01:30,090 --> 00:01:33,619
wanted to get back into tech so I

00:01:31,619 --> 00:01:36,090
decided to do that and focus

00:01:33,619 --> 00:01:40,020
specifically on security a really

00:01:36,090 --> 00:01:42,630
offensive security and to do that I into

00:01:40,020 --> 00:01:44,070
it I used different vulnerable web apps

00:01:42,630 --> 00:01:46,470
and things like that just did tons of

00:01:44,070 --> 00:01:48,630
reading and then I started doing bug

00:01:46,470 --> 00:01:50,700
bounty programs and these are where you

00:01:48,630 --> 00:01:53,220
can attack a website and the company

00:01:50,700 --> 00:01:55,009
gives you permission and if you find

00:01:53,220 --> 00:01:57,119
something and report it responsibly they

00:01:55,009 --> 00:01:58,560
either pay you a little usually a little

00:01:57,119 --> 00:02:00,090
bit of money and they certainly give you

00:01:58,560 --> 00:02:02,430
public recognition which i think is more

00:02:00,090 --> 00:02:03,899
valuable and it's also a very great way

00:02:02,430 --> 00:02:06,930
to learn hacking right you're going

00:02:03,899 --> 00:02:08,399
after live targets that are secured by

00:02:06,930 --> 00:02:09,600
professional security engineers so it's

00:02:08,399 --> 00:02:14,190
much harder than the

00:02:09,600 --> 00:02:16,500
the practice things we do and so that

00:02:14,190 --> 00:02:19,380
was great but I pivoted into fuzzing and

00:02:16,500 --> 00:02:20,580
memory corruption as well that's kind of

00:02:19,380 --> 00:02:22,860
what we're going to talk about mostly

00:02:20,580 --> 00:02:26,850
today and I found a few things in Ruby

00:02:22,860 --> 00:02:30,390
and PHP and other stuff one quick story

00:02:26,850 --> 00:02:33,000
I found a bug in the kernel and it was

00:02:30,390 --> 00:02:35,160
in ext4 and I wrote a script to

00:02:33,000 --> 00:02:37,980
highlight duplicate lines in source code

00:02:35,160 --> 00:02:41,100
anytime there's the same line twice flag

00:02:37,980 --> 00:02:42,720
that and I ran it over you know tens

00:02:41,100 --> 00:02:44,310
maybe hundreds of lines of open-source

00:02:42,720 --> 00:02:45,810
code and it was quite time-consuming

00:02:44,310 --> 00:02:47,430
because usually that's a legitimate

00:02:45,810 --> 00:02:48,720
thing or often it is but sometimes it's

00:02:47,430 --> 00:02:51,120
not I'm really looking for copy and

00:02:48,720 --> 00:02:53,340
paste errors so I found one when they

00:02:51,120 --> 00:02:56,100
were checking the mutex on inode one

00:02:53,340 --> 00:02:58,440
twice and there was also an inode too

00:02:56,100 --> 00:02:59,970
and so that was a bug it was like a copy

00:02:58,440 --> 00:03:02,400
and paste error they the programmer

00:02:59,970 --> 00:03:04,860
forgot to change the one to a two in

00:03:02,400 --> 00:03:07,230
that second line so I did I sent in a

00:03:04,860 --> 00:03:11,820
patch it got accepted so I have a one

00:03:07,230 --> 00:03:13,740
byte fix in the kernel and then last

00:03:11,820 --> 00:03:14,550
summer you know I really really got into

00:03:13,740 --> 00:03:15,870
fuzz testing I think it's really

00:03:14,550 --> 00:03:17,910
powerful thing to do so I started a

00:03:15,870 --> 00:03:23,160
company and we do fuzz testing at scale

00:03:17,910 --> 00:03:26,190
in the cloud as well as training okay so

00:03:23,160 --> 00:03:28,050
today we're going to talk about memory

00:03:26,190 --> 00:03:31,080
corruption handling memory corruption

00:03:28,050 --> 00:03:33,480
bugs that fuzzers find when I first

00:03:31,080 --> 00:03:34,620
started fuzzing I wondered to myself you

00:03:33,480 --> 00:03:36,030
know what I'm gonna do when I find a

00:03:34,620 --> 00:03:37,470
crash like I can do this fuzzing thing

00:03:36,030 --> 00:03:38,850
and it's good at finding crashes but I

00:03:37,470 --> 00:03:44,130
really wasn't even sure how to deal with

00:03:38,850 --> 00:03:45,420
that so I worked it out and in this talk

00:03:44,130 --> 00:03:47,790
is essentially the results of what I

00:03:45,420 --> 00:03:50,070
found by the end of this talk we'd like

00:03:47,790 --> 00:03:51,990
you to be able to triage crashes meaning

00:03:50,070 --> 00:03:54,630
determining the likelihood of exploit

00:03:51,990 --> 00:03:56,250
ability in some cases might be a bit of

00:03:54,630 --> 00:03:58,200
a review of secure coding as well

00:03:56,250 --> 00:04:01,230
hopefully and we are going to be

00:03:58,200 --> 00:04:03,870
addressing memory corruption issues in C

00:04:01,230 --> 00:04:08,160
and C++ Linux programs so this is

00:04:03,870 --> 00:04:09,960
unmanaged code fuzz testing at the

00:04:08,160 --> 00:04:13,920
moment really looks for crashes seg

00:04:09,960 --> 00:04:15,900
faults and so it's it's really focused

00:04:13,920 --> 00:04:17,910
on unmanaged code and C and C++ programs

00:04:15,900 --> 00:04:19,380
and so this talk is going to kind of be

00:04:17,910 --> 00:04:21,270
about the middle section of the process

00:04:19,380 --> 00:04:21,950
the first section is doing the fuzz run

00:04:21,270 --> 00:04:23,670
itself

00:04:21,950 --> 00:04:26,520
things like choosing a

00:04:23,670 --> 00:04:29,760
buzzer choosing the seed files how long

00:04:26,520 --> 00:04:31,380
to run the fuzz run for that's it's

00:04:29,760 --> 00:04:32,970
another talk and then we're not going to

00:04:31,380 --> 00:04:34,590
cover exploit development as well that's

00:04:32,970 --> 00:04:36,030
certainly another talk and so this is

00:04:34,590 --> 00:04:37,800
the middle section where you do the fuzz

00:04:36,030 --> 00:04:40,350
run you get crashes how do you process

00:04:37,800 --> 00:04:41,970
those with a goal of fixing the bug or

00:04:40,350 --> 00:04:45,510
possibly reporting it to the maintainer

00:04:41,970 --> 00:04:47,850
x' and so we're going to go through a

00:04:45,510 --> 00:04:49,740
quick interview or a review of memory

00:04:47,850 --> 00:04:51,270
corruption bugs we're going to go

00:04:49,740 --> 00:04:52,590
through my workflow to deal with them

00:04:51,270 --> 00:05:04,260
and then show a couple of real-world

00:04:52,590 --> 00:05:06,420
examples and so where we mean by memory

00:05:04,260 --> 00:05:08,550
corruption pretty much it's invalid

00:05:06,420 --> 00:05:11,700
reads and writes and so that's if the

00:05:08,550 --> 00:05:13,710
program can be tricked to allow an

00:05:11,700 --> 00:05:16,980
attacker to either read or write memory

00:05:13,710 --> 00:05:18,870
beyond the bounds of where ever buffer

00:05:16,980 --> 00:05:20,730
or variable has been assigned to that

00:05:18,870 --> 00:05:22,830
and so if you can write out-of-bounds

00:05:20,730 --> 00:05:24,210
read out-of-bounds that's fundamentally

00:05:22,830 --> 00:05:26,220
an invalid read or write most

00:05:24,210 --> 00:05:30,420
fundamental form of memory corruption

00:05:26,220 --> 00:05:34,200
bug these are also called out of bound

00:05:30,420 --> 00:05:38,250
reads and writes and often abbreviated

00:05:34,200 --> 00:05:39,930
Hobie reads and writes and just a quick

00:05:38,250 --> 00:05:41,880
review or the causes of this kind of

00:05:39,930 --> 00:05:44,700
memory corruption are very often

00:05:41,880 --> 00:05:47,670
off-by-one errors we see those so often

00:05:44,700 --> 00:05:50,460
still it's so hard to do so about and

00:05:47,670 --> 00:05:53,280
well over half of the crashes I find are

00:05:50,460 --> 00:05:54,660
really fundamentally off by one hours so

00:05:53,280 --> 00:05:57,330
it's good at finding those unvalidated

00:05:54,660 --> 00:05:58,980
input obviously is important one any

00:05:57,330 --> 00:06:02,040
untrusted input has to be carefully

00:05:58,980 --> 00:06:04,560
checked and then still some use of known

00:06:02,040 --> 00:06:09,840
unsafe functions such as stir copy and

00:06:04,560 --> 00:06:13,260
gets getstring and so there's two areas

00:06:09,840 --> 00:06:15,540
in memory that you store variables in in

00:06:13,260 --> 00:06:16,830
a process the stack and the heap local

00:06:15,540 --> 00:06:19,800
variables are stored on the stack you

00:06:16,830 --> 00:06:22,290
say int X equals 5 that's a stack

00:06:19,800 --> 00:06:24,690
variable a memory obtained using malloc

00:06:22,290 --> 00:06:26,790
like a string buffer that's in the heap

00:06:24,690 --> 00:06:29,480
so if you're allocating X number of

00:06:26,790 --> 00:06:33,390
bytes that's that's always a heap

00:06:29,480 --> 00:06:36,660
variable or heap buffer in the case of

00:06:33,390 --> 00:06:37,470
of heap memory you have to explicitly

00:06:36,660 --> 00:06:39,000
call free

00:06:37,470 --> 00:06:43,260
well the programmer has to free that

00:06:39,000 --> 00:06:44,820
memory both so we're talking outs buffer

00:06:43,260 --> 00:06:48,180
overflows as well it's another word for

00:06:44,820 --> 00:06:50,370
you know invalid read or write and you

00:06:48,180 --> 00:06:52,290
cannot buffer overflow is pretty

00:06:50,370 --> 00:06:56,190
commonly still in both the heap and the

00:06:52,290 --> 00:06:58,140
stack and one quick note you'll hear

00:06:56,190 --> 00:07:00,690
people talk about just strictly a stack

00:06:58,140 --> 00:07:02,310
overflow strictly speaking that's not a

00:07:00,690 --> 00:07:04,350
memory corruption error that's a stack

00:07:02,310 --> 00:07:06,210
overflow as opposed to a stack buffer

00:07:04,350 --> 00:07:08,790
overflow is different a standard stack

00:07:06,210 --> 00:07:10,290
overflow is when you have out-of-control

00:07:08,790 --> 00:07:11,340
recursion you're using recursion and

00:07:10,290 --> 00:07:12,930
you're not checking things and it's

00:07:11,340 --> 00:07:15,330
going essentially infinite until it runs

00:07:12,930 --> 00:07:16,770
out of memory or until something else

00:07:15,330 --> 00:07:18,660
you know determines that there's a

00:07:16,770 --> 00:07:19,710
problem and stops the program so so

00:07:18,660 --> 00:07:23,390
we're talking about stack buffer

00:07:19,710 --> 00:07:26,340
overflows today as among other things

00:07:23,390 --> 00:07:27,900
this is a quick example of a really

00:07:26,340 --> 00:07:32,280
basic stack overflow so you have a

00:07:27,900 --> 00:07:34,530
program that reads from standard in puts

00:07:32,280 --> 00:07:37,169
it into a character array of eight bytes

00:07:34,530 --> 00:07:41,490
and then uses a known unsafe function to

00:07:37,169 --> 00:07:42,900
copy it from the arc into the buff that

00:07:41,490 --> 00:07:45,090
could very easily be a stack buffer

00:07:42,900 --> 00:07:48,330
overflow in this case we're sending at

00:07:45,090 --> 00:07:54,660
12 bytes into the program and that's

00:07:48,330 --> 00:07:56,370
going to overflow by four bytes so what

00:07:54,660 --> 00:07:58,169
happens if next isn't called property

00:07:56,370 --> 00:08:01,020
I'm sorry if free isn't called properly

00:07:58,169 --> 00:08:03,840
that can easily be another class of bug

00:08:01,020 --> 00:08:05,490
called a use after free and he used

00:08:03,840 --> 00:08:07,890
after free is really just what it sounds

00:08:05,490 --> 00:08:10,620
like a program continues to use a freed

00:08:07,890 --> 00:08:12,240
pointer these have a pretty good

00:08:10,620 --> 00:08:13,680
likelihood of exploit ability still

00:08:12,240 --> 00:08:16,229
we're going to talk about mitigations in

00:08:13,680 --> 00:08:18,120
a minute here but use after freeze are

00:08:16,229 --> 00:08:22,050
still fairly likely to be exploitable

00:08:18,120 --> 00:08:24,510
especially in C++ code these often show

00:08:22,050 --> 00:08:27,450
up in error handling or other weird

00:08:24,510 --> 00:08:29,130
corner cases and especially when there's

00:08:27,450 --> 00:08:31,680
some confusion or it's not clearly laid

00:08:29,130 --> 00:08:34,580
out what part of the program is

00:08:31,680 --> 00:08:37,409
responsible for freeing allocated memory

00:08:34,580 --> 00:08:39,000
for instance and a function call who

00:08:37,409 --> 00:08:40,140
calls free the caller or the colleague

00:08:39,000 --> 00:08:41,940
so if you're not really careful with

00:08:40,140 --> 00:08:43,159
that you can easily get into use after

00:08:41,940 --> 00:08:45,959
free situation

00:08:43,159 --> 00:08:50,340
here's a quick pseudocode example of use

00:08:45,959 --> 00:08:54,000
after free so malloc for bites

00:08:50,340 --> 00:09:00,450
to character buffer do some amount of

00:08:54,000 --> 00:09:02,160
work with it free it some other stuff

00:09:00,450 --> 00:09:04,140
happens and then inadvertently it gets

00:09:02,160 --> 00:09:06,000
referenced again dereferenced again

00:09:04,140 --> 00:09:08,790
print FF or maybe you log it or whatever

00:09:06,000 --> 00:09:12,900
else you're doing that's a classic use

00:09:08,790 --> 00:09:14,640
after free and then there's other memory

00:09:12,900 --> 00:09:16,170
bugs too that are typically not as

00:09:14,640 --> 00:09:20,370
critical but are important to talk about

00:09:16,170 --> 00:09:23,070
a double or invalid free so that's if

00:09:20,370 --> 00:09:24,900
you free it twice you free the pointer

00:09:23,070 --> 00:09:26,400
once and then even later you free it

00:09:24,900 --> 00:09:28,980
again

00:09:26,400 --> 00:09:30,960
that is hard to exploit but it's

00:09:28,980 --> 00:09:34,880
potentially exploitable under race

00:09:30,960 --> 00:09:38,310
conditions in multi-threaded programs

00:09:34,880 --> 00:09:39,780
another kind of memory bug is when a

00:09:38,310 --> 00:09:41,970
conditional like an if statement our

00:09:39,780 --> 00:09:44,040
case statement depends on uninitialized

00:09:41,970 --> 00:09:45,720
memory so if you just say int X and

00:09:44,040 --> 00:09:50,070
don't assign anything to it and then you

00:09:45,720 --> 00:09:52,350
say if X do something that's a that's at

00:09:50,070 --> 00:09:56,070
least undefined behavior at best and

00:09:52,350 --> 00:09:58,170
possibly hacker could use a control flow

00:09:56,070 --> 00:10:01,380
attack and try to control the flow of

00:09:58,170 --> 00:10:02,940
the program and then finally when we're

00:10:01,380 --> 00:10:04,620
I'm sure all very familiar with is

00:10:02,940 --> 00:10:06,090
memory leaks and that's when the

00:10:04,620 --> 00:10:07,560
programmer forgets to call free free

00:10:06,090 --> 00:10:10,200
never gets called on allocated memory

00:10:07,560 --> 00:10:11,850
and in that case memory keeps getting

00:10:10,200 --> 00:10:13,910
allocated that could be denial of

00:10:11,850 --> 00:10:15,930
service attack if attacker keeps

00:10:13,910 --> 00:10:18,780
allocating memory finds a mechanism to

00:10:15,930 --> 00:10:20,250
do that where it's never freed you can

00:10:18,780 --> 00:10:22,850
exhaust the memory and bring the program

00:10:20,250 --> 00:10:22,850
to a halt

00:10:27,260 --> 00:10:32,970
so what does exploit ability I've talked

00:10:29,580 --> 00:10:35,280
about it a little bit already so far at

00:10:32,970 --> 00:10:38,400
a most basic level it's reprogramming

00:10:35,280 --> 00:10:42,030
the the program the application with

00:10:38,400 --> 00:10:43,950
input data and not code so if we can

00:10:42,030 --> 00:10:46,140
trick the program and executing attacker

00:10:43,950 --> 00:10:49,920
controlled input data as if it were code

00:10:46,140 --> 00:10:51,270
that's a code injection exploit another

00:10:49,920 --> 00:10:54,230
way to think about it is that input

00:10:51,270 --> 00:10:57,090
streams become instruction streams or

00:10:54,230 --> 00:11:00,600
from the attackers perspective can I

00:10:57,090 --> 00:11:02,070
make your program run my program in that

00:11:00,600 --> 00:11:04,530
case it's definitely exploitable and

00:11:02,070 --> 00:11:07,320
this typically involves controlling the

00:11:04,530 --> 00:11:10,710
instruction pointer IP and 32-bit or our

00:11:07,320 --> 00:11:11,940
IP and 64 but this kind of attacks

00:11:10,710 --> 00:11:13,620
getting really hard to do because it's

00:11:11,940 --> 00:11:15,870
the sum of the mitigations I'm about to

00:11:13,620 --> 00:11:17,610
talk about it's rare and rare that

00:11:15,870 --> 00:11:19,920
attackers can get their own code their

00:11:17,610 --> 00:11:23,550
own shell code often into an existing

00:11:19,920 --> 00:11:28,070
process now more and more attacks are

00:11:23,550 --> 00:11:30,540
about code reuse and that means

00:11:28,070 --> 00:11:31,890
reprogramming with existing code in it's

00:11:30,540 --> 00:11:34,680
already in the process so the attacker

00:11:31,890 --> 00:11:36,510
can't bring his or her own code in but

00:11:34,680 --> 00:11:38,850
they can leverage existing code both

00:11:36,510 --> 00:11:40,380
from the application itself or even more

00:11:38,850 --> 00:11:42,210
so from all the libraries that are

00:11:40,380 --> 00:11:44,910
linked with it and so there's enough

00:11:42,210 --> 00:11:46,940
code where that a person can string

00:11:44,910 --> 00:11:49,830
together existing functionality and

00:11:46,940 --> 00:11:52,440
reach an exploitable State and that's

00:11:49,830 --> 00:11:55,440
called return oriented programming or

00:11:52,440 --> 00:11:58,140
ROP because it relies on manipulating

00:11:55,440 --> 00:12:00,420
the return pointer and it's also called

00:11:58,140 --> 00:12:02,100
weird machine programming and so most

00:12:00,420 --> 00:12:06,690
hacks that we're seeing nowadays are

00:12:02,100 --> 00:12:08,430
some kind of ROP attack and then does

00:12:06,690 --> 00:12:11,130
exploitability matter like Y doesn't

00:12:08,430 --> 00:12:13,020
matter why do we really care and in a

00:12:11,130 --> 00:12:16,140
way it doesn't because if you can find a

00:12:13,020 --> 00:12:17,940
memory error it's good to fix it but

00:12:16,140 --> 00:12:20,010
certainly there are issues of

00:12:17,940 --> 00:12:21,570
prioritization right we all have lots of

00:12:20,010 --> 00:12:23,130
bugs to deal with and it's very

00:12:21,570 --> 00:12:25,400
important to know if there is one that

00:12:23,130 --> 00:12:27,480
is critical or that could be exploitable

00:12:25,400 --> 00:12:30,180
you obviously want to fix that one

00:12:27,480 --> 00:12:31,560
sooner and if it could be exploited in

00:12:30,180 --> 00:12:33,420
the wild if the code with the

00:12:31,560 --> 00:12:35,670
vulnerability already exists and users

00:12:33,420 --> 00:12:37,290
hands then it's also important to

00:12:35,670 --> 00:12:39,810
understand that it's exploitable so that

00:12:37,290 --> 00:12:42,540
you can arrange to push a fix out to the

00:12:39,810 --> 00:12:43,770
user base and then for what I do if

00:12:42,540 --> 00:12:45,060
you're doing security research it

00:12:43,770 --> 00:12:46,200
certainly matters too because you want

00:12:45,060 --> 00:12:47,490
to understand what you have when you

00:12:46,200 --> 00:12:49,380
report it you want to report it as a

00:12:47,490 --> 00:12:53,340
security bug if it is and not if it's

00:12:49,380 --> 00:12:55,290
not and so and it also is important to

00:12:53,340 --> 00:12:57,030
motivate the vendor or the maintainer to

00:12:55,290 --> 00:13:00,630
fix things if you can demonstrate some

00:12:57,030 --> 00:13:02,430
level of exploit ability but then it's

00:13:00,630 --> 00:13:04,380
like exploitable by whom there's a wide

00:13:02,430 --> 00:13:07,710
range of exploitable you know exploit

00:13:04,380 --> 00:13:09,840
dev skills out there and one being

00:13:07,710 --> 00:13:11,670
google has a group called project zero

00:13:09,840 --> 00:13:14,940
they're Google's internal white hat

00:13:11,670 --> 00:13:16,590
group and their job is to test any code

00:13:14,940 --> 00:13:18,600
that Google customers might use any

00:13:16,590 --> 00:13:20,490
application is their purview to find

00:13:18,600 --> 00:13:22,830
bugs in that and to demonstrate exploit

00:13:20,490 --> 00:13:24,750
ability and they have about 15 people

00:13:22,830 --> 00:13:26,910
very very top engineers working they're

00:13:24,750 --> 00:13:28,920
the top hackers on the world and they

00:13:26,910 --> 00:13:30,060
have quite a bit of compute power behind

00:13:28,920 --> 00:13:31,680
them of course too because they're

00:13:30,060 --> 00:13:33,690
Google and Google compute engine so they

00:13:31,680 --> 00:13:34,800
can make fuzz runs as much as they want

00:13:33,690 --> 00:13:37,950
they can you know have unlimited

00:13:34,800 --> 00:13:40,440
resources another group with really

00:13:37,950 --> 00:13:43,310
amazing resources is the NSA or any

00:13:40,440 --> 00:13:46,650
other nation state or intelligence

00:13:43,310 --> 00:13:48,360
agency and they obviously have even more

00:13:46,650 --> 00:13:51,870
people and even more resources than

00:13:48,360 --> 00:13:52,230
Google and then who knows who else is

00:13:51,870 --> 00:13:54,660
out there

00:13:52,230 --> 00:13:56,340
whatever who is trying to do who's

00:13:54,660 --> 00:13:58,110
trying to do the exploit what is their

00:13:56,340 --> 00:13:59,550
motivation to exploit how ha you know

00:13:58,110 --> 00:14:02,370
how important is the target how widely

00:13:59,550 --> 00:14:04,590
deployed is the application and this is

00:14:02,370 --> 00:14:06,390
a good time to just reiterate security

00:14:04,590 --> 00:14:08,070
is never a hundred percent what we're

00:14:06,390 --> 00:14:09,510
trying to do is raise the cost of the

00:14:08,070 --> 00:14:12,510
attack to the attacker we want the

00:14:09,510 --> 00:14:14,130
attack to be more expensive than the

00:14:12,510 --> 00:14:15,510
value of whatever data they're going to

00:14:14,130 --> 00:14:18,000
get out of it or whatever nefarious

00:14:15,510 --> 00:14:20,460
purpose they're they're trying to do so

00:14:18,000 --> 00:14:24,030
that's fundamentally what we're looking

00:14:20,460 --> 00:14:25,440
at in terms of securing applications and

00:14:24,030 --> 00:14:27,200
then another important point is that

00:14:25,440 --> 00:14:30,450
nowadays most

00:14:27,200 --> 00:14:32,520
exploits are not off just one bug

00:14:30,450 --> 00:14:33,510
there's been a lot of mitigation a lot

00:14:32,520 --> 00:14:35,460
of things have been fixed things are

00:14:33,510 --> 00:14:38,190
getting much better so to really get an

00:14:35,460 --> 00:14:39,840
exploit nowadays you're looking at a bug

00:14:38,190 --> 00:14:42,780
chain you have to chain together

00:14:39,840 --> 00:14:46,140
multiple bugs to reach a fully

00:14:42,780 --> 00:14:48,030
exploitable condition so given that it's

00:14:46,140 --> 00:14:50,840
a little bit moot to talk about whether

00:14:48,030 --> 00:14:52,700
or not any single bug is exploitable

00:14:50,840 --> 00:14:54,650
because even one that's definitely not

00:14:52,700 --> 00:15:00,470
exploitable could play a critical role

00:14:54,650 --> 00:15:01,580
in an exploit chain and then sometimes

00:15:00,470 --> 00:15:03,530
things are pretty surprisingly

00:15:01,580 --> 00:15:05,060
exploitable - there's there's bugs that

00:15:03,530 --> 00:15:07,400
you think would not be exploitable but

00:15:05,060 --> 00:15:09,800
very difficult and they are there was

00:15:07,400 --> 00:15:12,590
one disclosed recently and this is in a

00:15:09,800 --> 00:15:15,530
DNS library called Sierra's in the

00:15:12,590 --> 00:15:17,630
Chrome OS operating system and someone

00:15:15,530 --> 00:15:20,900
found full remote code execution a

00:15:17,630 --> 00:15:23,060
pretty serious bug when I say someone it

00:15:20,900 --> 00:15:25,150
was anonymously reported by some reach

00:15:23,060 --> 00:15:27,440
researcher or more likely a group and

00:15:25,150 --> 00:15:30,740
what's interesting about this is that he

00:15:27,440 --> 00:15:32,960
was a it was a buffer overflow of a

00:15:30,740 --> 00:15:35,330
right it was an invalid right but it was

00:15:32,960 --> 00:15:37,340
just a right of one bite it's only right

00:15:35,330 --> 00:15:40,400
a single bite past the buffer wherever

00:15:37,340 --> 00:15:42,200
supposed to not only that but the

00:15:40,400 --> 00:15:44,000
attacker could not control what was

00:15:42,200 --> 00:15:46,010
written into that bite a lot of times we

00:15:44,000 --> 00:15:47,990
can we we can control what gets written

00:15:46,010 --> 00:15:48,550
in bad writes and we'll see an example

00:15:47,990 --> 00:15:51,710
of that later

00:15:48,550 --> 00:15:54,020
but in this case it would only always be

00:15:51,710 --> 00:15:57,500
the digit one and that's all the

00:15:54,020 --> 00:15:59,120
attacker had but they were able to to

00:15:57,500 --> 00:16:00,920
chain this together or actually wasn't

00:15:59,120 --> 00:16:02,660
even training was Heep grooming where

00:16:00,920 --> 00:16:05,060
they make lots of calls to arrange the

00:16:02,660 --> 00:16:06,680
heap in a specific manner to make it

00:16:05,060 --> 00:16:08,210
exploitable or that's what I'm

00:16:06,680 --> 00:16:12,350
speculating but that's really what it is

00:16:08,210 --> 00:16:15,740
with 37 page report about this bug I did

00:16:12,350 --> 00:16:18,110
not read all 37 pages and it was

00:16:15,740 --> 00:16:19,700
reported to Red Hat as well and they

00:16:18,110 --> 00:16:22,280
rated it as moderate security impact

00:16:19,700 --> 00:16:23,990
this was before the the the exploit was

00:16:22,280 --> 00:16:25,130
disclosed and I would have to it seems

00:16:23,990 --> 00:16:27,140
pretty hard to exploit something like

00:16:25,130 --> 00:16:29,090
this and one final thing this is what

00:16:27,140 --> 00:16:31,070
triggered it if you had an escape dock

00:16:29,090 --> 00:16:32,690
at the end of the DNS name that's what

00:16:31,070 --> 00:16:34,040
would trigger this bug and this is the

00:16:32,690 --> 00:16:37,900
kind of thing that fuzz testing often

00:16:34,040 --> 00:16:37,900
finds its kind of weird corner case

00:16:43,449 --> 00:16:48,350
okay so then we've talked about memory

00:16:46,069 --> 00:16:49,970
corruption talked about exploitability

00:16:48,350 --> 00:16:52,669
here's a few of the mitigations that

00:16:49,970 --> 00:16:55,189
have made it harder the first one being

00:16:52,669 --> 00:16:56,720
stack Canaries and this is a random

00:16:55,189 --> 00:17:00,350
integer that gets pushed onto the stack

00:16:56,720 --> 00:17:02,389
in between stack frames so just like a

00:17:00,350 --> 00:17:03,889
canary in a coal mine if the canary is

00:17:02,389 --> 00:17:07,189
not looking good

00:17:03,889 --> 00:17:08,620
something's gone wrong and if these if

00:17:07,189 --> 00:17:10,850
these random integers

00:17:08,620 --> 00:17:16,549
these Canaries are actually random

00:17:10,850 --> 00:17:18,199
integers so if something goes wrong let

00:17:16,549 --> 00:17:20,689
me put it this way if the if the

00:17:18,199 --> 00:17:22,279
attacker can overflow the stack from one

00:17:20,689 --> 00:17:23,659
frame to the other and try to like work

00:17:22,279 --> 00:17:25,370
on their the return point or whatever

00:17:23,659 --> 00:17:28,130
they're doing they have to go through

00:17:25,370 --> 00:17:30,970
the stack canary there's a little bitter

00:17:28,130 --> 00:17:30,970
way to illustrate it

00:17:36,370 --> 00:17:40,660
sorry about that miss that slide and so

00:17:38,950 --> 00:17:44,170
there are there actually integers in

00:17:40,660 --> 00:17:45,460
between each stack frame and only the OS

00:17:44,170 --> 00:17:46,900
knows what those integers are they're

00:17:45,460 --> 00:17:49,540
random they're not available to the

00:17:46,900 --> 00:17:51,580
attacker and so if the attacker wants to

00:17:49,540 --> 00:17:53,080
buffer overflow from one frame to

00:17:51,580 --> 00:17:55,360
another and they typically need to to

00:17:53,080 --> 00:17:57,100
run an exploit they don't know that

00:17:55,360 --> 00:17:58,510
number and so they're going to change it

00:17:57,100 --> 00:17:59,770
and the operating system is going to

00:17:58,510 --> 00:18:01,840
realize that something changed

00:17:59,770 --> 00:18:06,190
something's gone wrong it's time to stop

00:18:01,840 --> 00:18:07,750
the program and then there's a SLR

00:18:06,190 --> 00:18:10,300
another really important mitigation

00:18:07,750 --> 00:18:12,960
address space layout randomization I'm

00:18:10,300 --> 00:18:17,250
sorry I skipped my apologies

00:18:12,960 --> 00:18:20,410
data execution prevention is another

00:18:17,250 --> 00:18:22,059
mitigation and this simply marks some

00:18:20,410 --> 00:18:24,940
region of memory as non-executable

00:18:22,059 --> 00:18:27,460
meaning if the instruction pointer has

00:18:24,940 --> 00:18:30,700
ever pointed into that it's time to stop

00:18:27,460 --> 00:18:33,730
the program this is supported at the

00:18:30,700 --> 00:18:36,250
hardware level by the NX bit in modern

00:18:33,730 --> 00:18:38,050
Intel CPUs now this is embedded Linux

00:18:36,250 --> 00:18:40,000
I'm sure there's people working on other

00:18:38,050 --> 00:18:42,520
kinds of hardware and so I'm not even

00:18:40,000 --> 00:18:44,620
sure if data execution prevention is

00:18:42,520 --> 00:18:47,650
available on different hardware

00:18:44,620 --> 00:18:50,800
platforms but it is in general anything

00:18:47,650 --> 00:18:52,450
in a laptop and the combination of stack

00:18:50,800 --> 00:18:54,670
Canaries and data execution prevention

00:18:52,450 --> 00:18:58,320
makes exploiting stack bugs especially

00:18:54,670 --> 00:18:58,320
pretty difficult at this point

00:18:58,360 --> 00:19:05,500
another important mitigation is address

00:19:01,929 --> 00:19:08,200
space layout randomization and this

00:19:05,500 --> 00:19:10,210
scrambles memory just like you buy a

00:19:08,200 --> 00:19:12,580
deck of cards it's in order by suit and

00:19:10,210 --> 00:19:15,160
number you shuffle it you no longer have

00:19:12,580 --> 00:19:18,460
that with a SLR it's sort of like the

00:19:15,160 --> 00:19:22,150
mapping is maintained and so just like

00:19:18,460 --> 00:19:24,100
we map virtual memory to physical a SLR

00:19:22,150 --> 00:19:26,500
adds an extra layer of scrambling and

00:19:24,100 --> 00:19:28,360
mapping over that and again the

00:19:26,500 --> 00:19:33,520
operating system knows that mapping but

00:19:28,360 --> 00:19:36,130
an attacker cannot so if you control the

00:19:33,520 --> 00:19:37,990
execution pointer you don't know where

00:19:36,130 --> 00:19:40,690
to jump to you're jumping to a random

00:19:37,990 --> 00:19:44,140
place and that's fundamentally how a SLR

00:19:40,690 --> 00:19:47,170
works now there one caveat about it it's

00:19:44,140 --> 00:19:49,090
only really effective on 64-bit systems

00:19:47,170 --> 00:19:50,000
because you have a very large memory

00:19:49,090 --> 00:19:52,340
space

00:19:50,000 --> 00:19:55,280
with 32-bit you're down to four gig heap

00:19:52,340 --> 00:19:57,770
size and there's actually a tax on a SLR

00:19:55,280 --> 00:19:59,870
where they use random heap spraying or

00:19:57,770 --> 00:20:01,610
brute-forcing and it takes obviously

00:19:59,870 --> 00:20:03,850
many many calls but they can keep trying

00:20:01,610 --> 00:20:05,960
stuff until they land where they want

00:20:03,850 --> 00:20:09,670
land the instruction pointer where in

00:20:05,960 --> 00:20:09,670
memory they want to run run the hack

00:20:15,570 --> 00:20:21,340
okay so we've talked about memory

00:20:17,350 --> 00:20:23,759
corruption bugs and mitigations so we're

00:20:21,340 --> 00:20:27,070
gonna talk about the workflow that I use

00:20:23,759 --> 00:20:29,889
to go through these things deal with

00:20:27,070 --> 00:20:32,619
crashes first step is to minimize the

00:20:29,889 --> 00:20:34,869
crash corpus and that means reduce it

00:20:32,619 --> 00:20:37,450
down to the important parts no

00:20:34,869 --> 00:20:39,070
extraneous information and then use

00:20:37,450 --> 00:20:41,350
memory corruption tools to gain

00:20:39,070 --> 00:20:43,169
information about those crashes and then

00:20:41,350 --> 00:20:45,489
finally you know get down to brass tacks

00:20:43,169 --> 00:20:48,789
determine exploit ability or find the

00:20:45,489 --> 00:20:51,009
root cause of the bug so minimization

00:20:48,789 --> 00:20:52,539
when you do a fuzz run it can it's

00:20:51,009 --> 00:20:54,009
trying stuff it's just making up crazy

00:20:52,539 --> 00:20:55,989
random files and running them through

00:20:54,009 --> 00:20:58,149
the program and so there can be a lot of

00:20:55,989 --> 00:21:00,070
extraneous information in each of the

00:20:58,149 --> 00:21:01,629
files as well as you can wind up with

00:21:00,070 --> 00:21:03,999
lots of crashes something's never been

00:21:01,629 --> 00:21:06,700
fuzz before you can easily see you know

00:21:03,999 --> 00:21:08,019
a couple of dozen crashes and the

00:21:06,700 --> 00:21:10,029
fuzzers do their best to make those

00:21:08,019 --> 00:21:12,489
crashes you need to make them represent

00:21:10,029 --> 00:21:14,019
unique bugs however that's pretty hard

00:21:12,489 --> 00:21:16,799
for the fuzzer to do while it's doing

00:21:14,019 --> 00:21:19,749
the fuzz run and so we need to minimize

00:21:16,799 --> 00:21:22,359
two things the first is the corpus of

00:21:19,749 --> 00:21:24,460
crashes so if you do a fuzz run and you

00:21:22,359 --> 00:21:27,309
have 20 crashes you want to make sure

00:21:24,460 --> 00:21:31,239
that those actually represent 20 bugs

00:21:27,309 --> 00:21:34,059
and not say 8 bugs and fuzzers have

00:21:31,239 --> 00:21:37,149
tools mentions yet but I use American

00:21:34,059 --> 00:21:39,220
fuzz elope is a fuzzer often called AFL

00:21:37,149 --> 00:21:42,340
and that was developed by Google it's an

00:21:39,220 --> 00:21:44,320
open-source fuzzer and it has a suite of

00:21:42,340 --> 00:21:47,710
tools and one of them does minimizing of

00:21:44,320 --> 00:21:52,509
crash corpuses it's called AFL seaman c

00:21:47,710 --> 00:21:54,970
IM r c mi n and so what it does is that

00:21:52,509 --> 00:21:57,580
it reduces the corpus of the crashes

00:21:54,970 --> 00:21:59,980
down to only those that represent actual

00:21:57,580 --> 00:22:02,289
bugs that's the idea so it can easily

00:21:59,980 --> 00:22:04,210
reduce 20 crashes down to eight or six

00:22:02,289 --> 00:22:08,109
or whatever it is and those are

00:22:04,210 --> 00:22:10,570
individual crash cases and to be really

00:22:08,109 --> 00:22:11,889
specific I mean a file a crash case as a

00:22:10,570 --> 00:22:13,179
file you run against the program it's

00:22:11,889 --> 00:22:18,100
going to make a crash that got found by

00:22:13,179 --> 00:22:19,749
the fuzz ER so once the corpus itself

00:22:18,100 --> 00:22:21,759
has been minimized then it's important

00:22:19,749 --> 00:22:23,080
to minimize each case individually so as

00:22:21,759 --> 00:22:24,909
I mentioned before you can have lots of

00:22:23,080 --> 00:22:28,519
extraneous bytes and that are not

00:22:24,909 --> 00:22:30,739
relevant to the crash and so there's

00:22:28,519 --> 00:22:34,629
there's case minimizer's - and AFL's is

00:22:30,739 --> 00:22:37,639
called AFL - teaming and it runs the

00:22:34,629 --> 00:22:39,320
file with the target program over and

00:22:37,639 --> 00:22:41,389
over again and it just experiments it

00:22:39,320 --> 00:22:42,919
tries removing a bite if the crash if

00:22:41,389 --> 00:22:45,469
the same crash still happens that bite

00:22:42,919 --> 00:22:46,999
never comes back if it removes the bite

00:22:45,469 --> 00:22:49,369
and the crash goes away or even

00:22:46,999 --> 00:22:52,009
different crash happens then

00:22:49,369 --> 00:22:54,139
then the minimizer knows that that bite

00:22:52,009 --> 00:22:55,849
is important to that crash and so doing

00:22:54,139 --> 00:22:57,649
that you can take you can just reduce

00:22:55,849 --> 00:22:59,089
the case down to only those bites that

00:22:57,649 --> 00:23:01,039
are relevant to the crash which makes it

00:22:59,089 --> 00:23:03,979
much easier to do the to do the

00:23:01,039 --> 00:23:05,539
debugging and then quickly there's one

00:23:03,979 --> 00:23:08,659
more tool called eff dupes

00:23:05,539 --> 00:23:10,579
and it's a hashed based system it simply

00:23:08,659 --> 00:23:11,839
takes all the files in any given

00:23:10,579 --> 00:23:14,570
directory and it's a work on any kind of

00:23:11,839 --> 00:23:16,940
file and it checks the md5 hash on them

00:23:14,570 --> 00:23:20,089
and compares them if two or more files

00:23:16,940 --> 00:23:22,009
are identical on a bite to bite basis F

00:23:20,089 --> 00:23:23,839
dupes will eliminate all but one of

00:23:22,009 --> 00:23:25,459
those files and I've definitely seen

00:23:23,839 --> 00:23:28,249
cases I mean these tools do their best

00:23:25,459 --> 00:23:30,139
but they're not perfect so I've run I've

00:23:28,249 --> 00:23:33,259
run the corpus minimizer I've run the

00:23:30,139 --> 00:23:35,450
test case minimizer and still found bite

00:23:33,259 --> 00:23:43,039
identical files and so F dupes is a nice

00:23:35,450 --> 00:23:45,709
quick way to get rid of those okay and

00:23:43,039 --> 00:23:46,909
then then it's time to start doing some

00:23:45,709 --> 00:23:49,789
analysis and there's some pretty useful

00:23:46,909 --> 00:23:53,139
tools to do that with before I go into

00:23:49,789 --> 00:23:55,249
those tools it's important to to remind

00:23:53,139 --> 00:23:57,829
everybody that all bets are off

00:23:55,249 --> 00:24:00,109
once things go south in a C program with

00:23:57,829 --> 00:24:01,519
memory you really don't know what's

00:24:00,109 --> 00:24:03,259
going on you have to be open to anything

00:24:01,519 --> 00:24:05,839
and it can affect the tools the tools

00:24:03,259 --> 00:24:07,399
through their best but it's important to

00:24:05,839 --> 00:24:11,209
not trust anything that comes out of a

00:24:07,399 --> 00:24:15,409
computer so the first tool is called

00:24:11,209 --> 00:24:19,450
address sanitizer and this is found in

00:24:15,409 --> 00:24:23,450
compilers GCC and clang both have it and

00:24:19,450 --> 00:24:24,799
that's the flag that you use to use it

00:24:23,450 --> 00:24:27,379
on the compiled line compiled with it

00:24:24,799 --> 00:24:30,440
and it operates at both compile-time and

00:24:27,379 --> 00:24:32,719
run-time to detect memory errors at

00:24:30,440 --> 00:24:35,059
compile time it adds instrumentation to

00:24:32,719 --> 00:24:38,210
to the output to the code to the binary

00:24:35,059 --> 00:24:40,700
itself and then at runtime a Rapace

00:24:38,210 --> 00:24:42,320
replaces malloc with its own runtime

00:24:40,700 --> 00:24:44,000
library for allocating memory

00:24:42,320 --> 00:24:46,690
so between the two of those mechanisms

00:24:44,000 --> 00:24:50,360
it can be very very accurate at

00:24:46,690 --> 00:24:52,820
detecting memory errors and this is an

00:24:50,360 --> 00:24:55,910
example of the output you can see it

00:24:52,820 --> 00:24:58,510
found a heap after free UAF found at UAF

00:24:55,910 --> 00:25:00,800
and the heap here's the address

00:24:58,510 --> 00:25:02,480
some other information here's a stack

00:25:00,800 --> 00:25:05,300
trace and I didn't compile this with the

00:25:02,480 --> 00:25:07,700
symbols in it so we're just getting kind

00:25:05,300 --> 00:25:08,600
of memory locations here but it gives

00:25:07,700 --> 00:25:11,210
you a lot of other pretty nice

00:25:08,600 --> 00:25:17,480
information we had a bad read read a

00:25:11,210 --> 00:25:19,760
size four and so it also finds invalid

00:25:17,480 --> 00:25:22,180
or it finds invalid reads and writes any

00:25:19,760 --> 00:25:25,310
kind of buffer overflow use after freeze

00:25:22,180 --> 00:25:28,880
double freeze and some other kinds of

00:25:25,310 --> 00:25:31,370
memory corruption bugs another really

00:25:28,880 --> 00:25:33,620
useful tool is called Val grind or mem

00:25:31,370 --> 00:25:35,810
check technically Val grind is a family

00:25:33,620 --> 00:25:37,640
of tools and mem Scheck is the one that

00:25:35,810 --> 00:25:40,090
that checks memory a lot of people kind

00:25:37,640 --> 00:25:43,070
of use both terms interchangeably and

00:25:40,090 --> 00:25:45,320
it's distinct from address sanitizer

00:25:43,070 --> 00:25:47,210
because there's no need to recompile you

00:25:45,320 --> 00:25:49,190
can simply take any binary and run it

00:25:47,210 --> 00:25:50,770
under Val grind and it will give you the

00:25:49,190 --> 00:25:53,870
information so that's that's pretty nice

00:25:50,770 --> 00:25:56,690
it does have a lot more output and it's

00:25:53,870 --> 00:25:58,310
not as clean as address sanitizer it

00:25:56,690 --> 00:25:59,720
doesn't just tell you hey this is a UAF

00:25:58,310 --> 00:26:02,600
or whatever you have to kind of

00:25:59,720 --> 00:26:05,420
interpret it a little bit more here's an

00:26:02,600 --> 00:26:08,570
example of the output from from Val

00:26:05,420 --> 00:26:10,910
grind and we have a bad right appear and

00:26:08,570 --> 00:26:13,280
a bad read here so anytime you have a

00:26:10,910 --> 00:26:15,410
bad right in the heap it's you have to

00:26:13,280 --> 00:26:18,320
consider it exploitable and in this case

00:26:15,410 --> 00:26:19,310
they're close in memory to these memory

00:26:18,320 --> 00:26:22,700
locations oops sorry

00:26:19,310 --> 00:26:23,900
the bad read is here and the bad write

00:26:22,700 --> 00:26:26,210
is here they're not that far away so

00:26:23,900 --> 00:26:28,610
that also suggests that maybe the

00:26:26,210 --> 00:26:30,170
attacker could could get something going

00:26:28,610 --> 00:26:31,310
in there like if you have a bad write

00:26:30,170 --> 00:26:35,330
you can write something and then if it

00:26:31,310 --> 00:26:37,640
later gets read all bets are off and

00:26:35,330 --> 00:26:40,160
then there's one more really useful tool

00:26:37,640 --> 00:26:43,310
and it's simply called exploitable and

00:26:40,160 --> 00:26:45,020
it was developed by cert and it's now

00:26:43,310 --> 00:26:48,560
been open-source it's available on

00:26:45,020 --> 00:26:51,380
github maintained by a person named

00:26:48,560 --> 00:26:53,840
Jonathan foot and it's an extension to

00:26:51,380 --> 00:26:56,470
gdb although you can run it as a

00:26:53,840 --> 00:26:58,519
standalone script as well

00:26:56,470 --> 00:27:02,059
and what's really nice about it is that

00:26:58,519 --> 00:27:03,799
it actually categorizes the crash into

00:27:02,059 --> 00:27:05,840
various levels of exploitability

00:27:03,799 --> 00:27:08,989
it has four categories exploitable

00:27:05,840 --> 00:27:11,570
probably exploitable probably not

00:27:08,989 --> 00:27:13,820
exploitable and unknown some cases it

00:27:11,570 --> 00:27:16,070
just can't tell and it gives you a

00:27:13,820 --> 00:27:19,100
really nice kind of layout of exactly

00:27:16,070 --> 00:27:21,379
what's going on in here so between the

00:27:19,100 --> 00:27:23,179
three of these tools you can get quite a

00:27:21,379 --> 00:27:24,590
bit of information in terms of

00:27:23,179 --> 00:27:29,629
understanding what what's really going

00:27:24,590 --> 00:27:31,399
on so then you have the next step which

00:27:29,629 --> 00:27:32,869
is actually figure out what's going on

00:27:31,399 --> 00:27:38,989
determine exploit ability or find the

00:27:32,869 --> 00:27:40,070
root cause so we're going to just you

00:27:38,989 --> 00:27:43,009
know just basically into hardcore

00:27:40,070 --> 00:27:45,559
debugging before you do that it's

00:27:43,009 --> 00:27:47,840
important to disable a SLR after talking

00:27:45,559 --> 00:27:50,239
about that it's a good tool to avoid

00:27:47,840 --> 00:27:51,679
hacks if you keep if you run the program

00:27:50,239 --> 00:27:52,519
over and over again or any time you're

00:27:51,679 --> 00:27:54,549
running you're going to all different

00:27:52,519 --> 00:27:56,359
memory locations for everything and so

00:27:54,549 --> 00:27:58,580
that's going to make it essentially

00:27:56,359 --> 00:28:02,179
impossible to do any kind of triage or

00:27:58,580 --> 00:28:04,220
debugging on it so so disable a SLR

00:28:02,179 --> 00:28:05,989
certainly do it behind a firewall or a

00:28:04,220 --> 00:28:07,669
NAT router or some other case where

00:28:05,989 --> 00:28:11,599
you're you're safe you're not exposed to

00:28:07,669 --> 00:28:14,119
the Internet this is the ANBU to file

00:28:11,599 --> 00:28:16,700
under proc that controls whether a SLR

00:28:14,119 --> 00:28:18,950
is on or not and you can you can't edit

00:28:16,700 --> 00:28:22,039
stuff under proc so this is the command

00:28:18,950 --> 00:28:23,869
to disable a SLR if you do it this way

00:28:22,039 --> 00:28:28,460
and reboot the Machine a SLR will be

00:28:23,869 --> 00:28:30,289
back in place and then the next step is

00:28:28,460 --> 00:28:31,609
to identify critical memory locations so

00:28:30,289 --> 00:28:33,590
it gets confusing when you're doing this

00:28:31,609 --> 00:28:35,450
sometimes it's sort of like you see lots

00:28:33,590 --> 00:28:36,950
of memory and there's the code and where

00:28:35,450 --> 00:28:39,799
it crashed and and all this other stuff

00:28:36,950 --> 00:28:43,909
it's a I like to essentially be very

00:28:39,799 --> 00:28:45,799
careful about understanding the critical

00:28:43,909 --> 00:28:47,599
memory locations and so that can vary in

00:28:45,799 --> 00:28:49,940
terms of the crash but certainly where

00:28:47,599 --> 00:28:51,529
the crash happened in the code what

00:28:49,940 --> 00:28:53,499
instruction was being executed when it

00:28:51,529 --> 00:28:56,599
crashed that's a very important point

00:28:53,499 --> 00:29:00,259
where the invalid read or write occurred

00:28:56,599 --> 00:29:03,559
in the data where in the memory in

00:29:00,259 --> 00:29:05,149
question was allocated and/or freed if

00:29:03,559 --> 00:29:06,590
not that's a code issue like where in

00:29:05,149 --> 00:29:06,840
the code the allocation happened or

00:29:06,590 --> 00:29:08,940
where

00:29:06,840 --> 00:29:12,480
was or was not free eat or free too many

00:29:08,940 --> 00:29:13,350
times and then whenever the data is

00:29:12,480 --> 00:29:14,580
reassigned

00:29:13,350 --> 00:29:16,470
you know perhaps it gets reassigned to a

00:29:14,580 --> 00:29:19,560
different variable or buffer or gets

00:29:16,470 --> 00:29:21,090
copied that can be important too and

00:29:19,560 --> 00:29:23,190
that can either be well that's actually

00:29:21,090 --> 00:29:24,210
in the code and/or the data so once

00:29:23,190 --> 00:29:25,320
you've kind of mapped this out and I

00:29:24,210 --> 00:29:27,540
like to actually write them down because

00:29:25,320 --> 00:29:29,970
it does get confusing after a while then

00:29:27,540 --> 00:29:33,480
it's time to just fire up gdb and and

00:29:29,970 --> 00:29:35,250
start digging into it and so this is

00:29:33,480 --> 00:29:37,110
uses of gdb is certainly outside the

00:29:35,250 --> 00:29:38,790
scope of today's talk but the basic idea

00:29:37,110 --> 00:29:40,890
is that you set a breakpoint where the

00:29:38,790 --> 00:29:43,440
crash happens and work backwards from

00:29:40,890 --> 00:29:45,810
there certainly you want to compile with

00:29:43,440 --> 00:29:47,850
- G to get the symbols and - oszi row

00:29:45,810 --> 00:29:49,650
zero level optimization that way you get

00:29:47,850 --> 00:29:51,210
as much information as possible in terms

00:29:49,650 --> 00:29:54,510
of variable names and things like that

00:29:51,210 --> 00:29:57,800
and so pretty much you run the target

00:29:54,510 --> 00:30:00,180
with canary values like capital A's and

00:29:57,800 --> 00:30:02,100
that way you can track those through

00:30:00,180 --> 00:30:05,160
memory it's easy when you dump memory to

00:30:02,100 --> 00:30:08,790
see a bunch of Oh X four ones so that's

00:30:05,160 --> 00:30:10,740
the hex number for a capital A it's 65

00:30:08,790 --> 00:30:12,840
and in decimal this is its ASCII number

00:30:10,740 --> 00:30:15,330
and so you know we're pretty happy when

00:30:12,840 --> 00:30:17,690
we see a bunch of forty ones where

00:30:15,330 --> 00:30:19,620
they're not supposed to be or four ones

00:30:17,690 --> 00:30:22,800
and so we kind of use that to track

00:30:19,620 --> 00:30:25,230
things - and but gdb is a little bit

00:30:22,800 --> 00:30:28,320
tricky because you have to work on it a

00:30:25,230 --> 00:30:30,090
lot and if you set a breakpoint where

00:30:28,320 --> 00:30:31,380
the crash happens kind of the idea is

00:30:30,090 --> 00:30:32,790
you run it over and over again and set

00:30:31,380 --> 00:30:34,830
breakpoints kind of early and earlier

00:30:32,790 --> 00:30:36,660
and earlier and dump memory and see

00:30:34,830 --> 00:30:38,580
what's kind of what's going on and that

00:30:36,660 --> 00:30:41,220
works and a lot of times that's what you

00:30:38,580 --> 00:30:43,260
have to do but it's kind of time

00:30:41,220 --> 00:30:45,720
consuming and cumbersome so I've been

00:30:43,260 --> 00:30:48,330
using another tool in addition to gdb

00:30:45,720 --> 00:30:52,160
it's actually a gdb plug-in and it's

00:30:48,330 --> 00:30:55,110
called RR and it does reverse debugging

00:30:52,160 --> 00:30:56,850
it allows you to actually step backwards

00:30:55,110 --> 00:31:00,090
through the control flow of the program

00:30:56,850 --> 00:31:02,850
so you have to run the program under RR

00:31:00,090 --> 00:31:03,950
and it records the execution once you've

00:31:02,850 --> 00:31:06,320
done that you can run the program

00:31:03,950 --> 00:31:08,730
normally with any input you want and

00:31:06,320 --> 00:31:09,870
then set a breakpoint but once you get

00:31:08,730 --> 00:31:12,210
to that breakpoint you can step

00:31:09,870 --> 00:31:14,370
backwards and just like you step

00:31:12,210 --> 00:31:16,440
forwards normally you can turn back time

00:31:14,370 --> 00:31:17,850
and that can be for a lot of bugs a very

00:31:16,440 --> 00:31:19,070
efficient way to figure out what's going

00:31:17,850 --> 00:31:21,990
on

00:31:19,070 --> 00:31:23,820
now a lot of bugs are pretty easy to

00:31:21,990 --> 00:31:26,040
figure out or certainly off-by-one

00:31:23,820 --> 00:31:29,250
errors are typically fairly easy to both

00:31:26,040 --> 00:31:32,010
find and identify and obviously fix but

00:31:29,250 --> 00:31:34,080
some of the stuff is not so it's

00:31:32,010 --> 00:31:36,270
important to kind of tape breaks be

00:31:34,080 --> 00:31:38,160
persistent you know this this kind of

00:31:36,270 --> 00:31:40,140
low-level debugging and memory dumping

00:31:38,160 --> 00:31:44,010
and all that kind of stuff you know it's

00:31:40,140 --> 00:31:46,950
hard work and then one more thing

00:31:44,010 --> 00:31:48,690
once bugs are fixed if a crash is fixed

00:31:46,950 --> 00:31:50,040
that crash might have been masking

00:31:48,690 --> 00:31:52,740
another crash it might have stopped

00:31:50,040 --> 00:31:54,200
execution before some other bug might

00:31:52,740 --> 00:31:57,420
have been discovered by the fuzz er and

00:31:54,200 --> 00:31:59,190
so it's important to fix those bugs and

00:31:57,420 --> 00:32:01,080
then rerun the fuzzer again on the

00:31:59,190 --> 00:32:04,670
target in the same manner to try to

00:32:01,080 --> 00:32:04,670
flush out a few more crashes

00:32:10,850 --> 00:32:14,790
okay so for the final section I'm just

00:32:13,380 --> 00:32:17,690
gonna go over a couple of real-world

00:32:14,790 --> 00:32:21,660
examples that I found in my own research

00:32:17,690 --> 00:32:24,450
the first one being PHP I was fuzzing

00:32:21,660 --> 00:32:26,910
PHP I found a low bad read low meaning

00:32:24,450 --> 00:32:29,370
low in the heap space it was actually

00:32:26,910 --> 00:32:32,600
very low it was a null pointer

00:32:29,370 --> 00:32:37,260
dereference essentially and so not

00:32:32,600 --> 00:32:41,220
exploitable really at all here's my he

00:32:37,260 --> 00:32:43,650
was my report and I was running it from

00:32:41,220 --> 00:32:45,360
the command line and I was using a

00:32:43,650 --> 00:32:46,950
dictionary in the fuzzers so I gave it

00:32:45,360 --> 00:32:48,960
you know all the standard commands is in

00:32:46,950 --> 00:32:51,390
the PHP any file which is typically not

00:32:48,960 --> 00:32:52,860
used at the command line which is part

00:32:51,390 --> 00:32:55,290
of how I flushed out the crash

00:32:52,860 --> 00:32:56,760
and so the fuzzer the fuzzer was always

00:32:55,290 --> 00:32:58,050
using these like I set up with a

00:32:56,760 --> 00:33:00,270
dictionary so the fuzzer didn't have to

00:32:58,050 --> 00:33:01,890
you know generate these parts of the any

00:33:00,270 --> 00:33:04,110
file but it just happened to put a one

00:33:01,890 --> 00:33:05,490
there and that made PHP think it was

00:33:04,110 --> 00:33:07,590
running in the context of a web server

00:33:05,490 --> 00:33:11,040
when it was not and that just triggered

00:33:07,590 --> 00:33:13,590
this no pointer dereference and you can

00:33:11,040 --> 00:33:18,420
see here the valgrind output of this bad

00:33:13,590 --> 00:33:21,780
read of size for address 0 x10 so that's

00:33:18,420 --> 00:33:25,200
16 and decimal is not stacked malloc tor

00:33:21,780 --> 00:33:27,720
freed so this is a standard null pointer

00:33:25,200 --> 00:33:29,300
dereference no longer exploitable in the

00:33:27,720 --> 00:33:33,270
old days used to be exploit these but

00:33:29,300 --> 00:33:35,100
those days are over and then this is the

00:33:33,270 --> 00:33:37,020
fix that the PHP devs put in there and

00:33:35,100 --> 00:33:38,970
they're simply just checking now that it

00:33:37,020 --> 00:33:41,160
is operating in the context of a web

00:33:38,970 --> 00:33:45,240
server and doing the right thing as

00:33:41,160 --> 00:33:49,890
appropriate so then I turned my

00:33:45,240 --> 00:33:52,200
attention to Ruby and started fuzzing

00:33:49,890 --> 00:33:54,990
the regular expression compilation in

00:33:52,200 --> 00:33:55,980
Ruby and I found actually a few bugs in

00:33:54,990 --> 00:33:59,880
that this is one of the more interesting

00:33:55,980 --> 00:34:03,000
ones and it was a pretty nice buffer

00:33:59,880 --> 00:34:05,160
overflow here and that's this is my

00:34:03,000 --> 00:34:06,720
report it's pretty weird I mean if you

00:34:05,160 --> 00:34:08,460
open a character class in a regular

00:34:06,720 --> 00:34:11,250
expression and you don't close it and

00:34:08,460 --> 00:34:13,680
you have an octal number in it after

00:34:11,250 --> 00:34:16,590
that that's the weird corner case that

00:34:13,680 --> 00:34:21,530
the fuzzer found here's the output of

00:34:16,590 --> 00:34:23,370
the a SAN have a heap buffer overflow

00:34:21,530 --> 00:34:25,230
but what's kind of interests

00:34:23,370 --> 00:34:27,720
here's that Val grind gives us even more

00:34:25,230 --> 00:34:29,640
information about this bug Val grinds

00:34:27,720 --> 00:34:31,620
saying there's an invalid right here of

00:34:29,640 --> 00:34:34,440
size four and then an invalid read later

00:34:31,620 --> 00:34:38,520
and they are again fairly close in

00:34:34,440 --> 00:34:39,930
memory and so as I mentioned before any

00:34:38,520 --> 00:34:41,220
time you have a bad write in the heap

00:34:39,930 --> 00:34:44,340
you really have to consider that

00:34:41,220 --> 00:34:47,510
exploitable so and I do so this bug was

00:34:44,340 --> 00:34:51,330
really an exploitable bug in Ruby

00:34:47,510 --> 00:34:53,790
however it the attack surface for it was

00:34:51,330 --> 00:34:56,040
very small because we're talking about a

00:34:53,790 --> 00:34:58,920
regular expression as the untrusted

00:34:56,040 --> 00:35:01,260
input and it's already not a good idea

00:34:58,920 --> 00:35:03,690
to accept untrusted regular expressions

00:35:01,260 --> 00:35:05,310
in any application because you're

00:35:03,690 --> 00:35:07,110
opening yourself up for minimally a

00:35:05,310 --> 00:35:08,520
denial-of-service attack like you can

00:35:07,110 --> 00:35:10,080
think of there are regular expressions

00:35:08,520 --> 00:35:12,030
that are regular expression bombs or

00:35:10,080 --> 00:35:14,040
whatever or they can really exhaust

00:35:12,030 --> 00:35:15,330
memory and so setting aside

00:35:14,040 --> 00:35:17,250
that's not memory corruption that's just

00:35:15,330 --> 00:35:20,040
a dos attack so but that's why you

00:35:17,250 --> 00:35:22,280
really shouldn't even expose yourself to

00:35:20,040 --> 00:35:25,020
untrusted regex reg X's to begin with

00:35:22,280 --> 00:35:26,850
here's another reason because this this

00:35:25,020 --> 00:35:28,440
this code who could have been you know

00:35:26,850 --> 00:35:31,140
attackable and Ruby as of eight months

00:35:28,440 --> 00:35:33,060
ago it's been fixed and so this is

00:35:31,140 --> 00:35:36,510
definitely exploitable but thankfully a

00:35:33,060 --> 00:35:39,570
pretty small attack surface and here's

00:35:36,510 --> 00:35:40,740
their fix this is the Ruby devs fix and

00:35:39,570 --> 00:35:44,430
they're talking about the octal and all

00:35:40,740 --> 00:35:47,070
that kind of stuff and then I found a

00:35:44,430 --> 00:35:49,380
bug in a in a system called dynomite and

00:35:47,070 --> 00:35:52,260
this is written by Netflix I found an

00:35:49,380 --> 00:35:55,440
invalid write in it and dynamite is a

00:35:52,260 --> 00:35:58,590
replicator charter for Redis and

00:35:55,440 --> 00:36:01,320
memcached key value storage systems is

00:35:58,590 --> 00:36:03,330
what Redis does and memcache does and so

00:36:01,320 --> 00:36:04,770
dynamite sits in these storage systems

00:36:03,330 --> 00:36:07,020
between these storage systems and the

00:36:04,770 --> 00:36:09,000
internet and it does either replicating

00:36:07,020 --> 00:36:10,650
in case these you know for reliability

00:36:09,000 --> 00:36:12,450
here or sharding if you're using

00:36:10,650 --> 00:36:14,970
different you know if you're dividing it

00:36:12,450 --> 00:36:17,490
up by last name first letter the last

00:36:14,970 --> 00:36:19,890
name that's sharding and so that's what

00:36:17,490 --> 00:36:22,280
netflix dynamite does and so it's on the

00:36:19,890 --> 00:36:24,360
open Internet and they are using it and

00:36:22,280 --> 00:36:27,960
lots of other people are using it too it

00:36:24,360 --> 00:36:31,500
is open source and I decided to fuzz it

00:36:27,960 --> 00:36:33,150
and see what happens now what I was

00:36:31,500 --> 00:36:34,800
fuzzing is kind of a weird thing to fuzz

00:36:33,150 --> 00:36:36,460
it was what I call an oblique attack I

00:36:34,800 --> 00:36:39,640
wasn't fuzzing it head-on

00:36:36,460 --> 00:36:43,150
I fuzz the admin file and it's a yamo

00:36:39,640 --> 00:36:44,710
based file in Netflix dynamite and I

00:36:43,150 --> 00:36:46,480
fuzz this file so I hit it with lots of

00:36:44,710 --> 00:36:49,210
weird versions of this file and I did

00:36:46,480 --> 00:36:51,190
get a pretty nice crash and now that's

00:36:49,210 --> 00:36:53,140
kind of a weird thing like okay so an

00:36:51,190 --> 00:36:54,670
admin can make a crash or a bad admin

00:36:53,140 --> 00:36:55,750
and that's still an important book it

00:36:54,670 --> 00:36:58,030
has to be fixed because you could have

00:36:55,750 --> 00:36:59,230
animilitia soar compromised admin but

00:36:58,030 --> 00:37:00,870
that's kind of what I thought I had but

00:36:59,230 --> 00:37:03,820
I'm like okay I'm going to file this

00:37:00,870 --> 00:37:06,040
this is this is the the case that I

00:37:03,820 --> 00:37:10,180
filed so this is the minimized case that

00:37:06,040 --> 00:37:14,410
I sent to it as a as a yeah mol file and

00:37:10,180 --> 00:37:16,000
so here you have six capital a's and to

00:37:14,410 --> 00:37:17,890
demonstrate this is what i filed with

00:37:16,000 --> 00:37:20,500
netflix just to demonstrate the issue

00:37:17,890 --> 00:37:21,760
and so i ran the program down here we

00:37:20,500 --> 00:37:23,620
got an error and this is actually from g

00:37:21,760 --> 00:37:25,510
live see sometimes G live C gives you a

00:37:23,620 --> 00:37:27,850
nice error as well and it goes to

00:37:25,510 --> 00:37:29,230
standard out you want to see on I mean

00:37:27,850 --> 00:37:32,040
sorry standard error you won't see it on

00:37:29,230 --> 00:37:36,790
standard out and we got the crash here

00:37:32,040 --> 00:37:41,200
here's the next invalid size and so in

00:37:36,790 --> 00:37:43,930
gdb I just dumped that address oops I'm

00:37:41,200 --> 00:37:45,700
sorry yes and here we have the capital

00:37:43,930 --> 00:37:47,530
ace here and I dumped the next address

00:37:45,700 --> 00:37:49,630
and there's more capital a's and it's

00:37:47,530 --> 00:37:51,460
intel so it's little endian little

00:37:49,630 --> 00:37:53,710
endian so these are actually six

00:37:51,460 --> 00:37:55,150
contiguous rights and this is attacker

00:37:53,710 --> 00:37:57,220
control like the attacker could put

00:37:55,150 --> 00:38:00,100
anything he or she wants to

00:37:57,220 --> 00:38:02,620
in lieu of those those a's you get six

00:38:00,100 --> 00:38:04,540
bytes to do whatever you want and so

00:38:02,620 --> 00:38:06,340
okay this is a cool bug but again it's

00:38:04,540 --> 00:38:10,420
like not that you know okay it's an

00:38:06,340 --> 00:38:12,070
admin file and so I filed it and to my

00:38:10,420 --> 00:38:13,330
surprise they didn't fix what I thought

00:38:12,070 --> 00:38:15,340
I thought okay maybe it's somewhere in

00:38:13,330 --> 00:38:16,960
the yamo code or somewhere else but it

00:38:15,340 --> 00:38:19,210
was actually in there string functions

00:38:16,960 --> 00:38:20,500
and there's string doop functions so

00:38:19,210 --> 00:38:22,660
this is actually something that gets run

00:38:20,500 --> 00:38:25,480
a lot especially in a something that

00:38:22,660 --> 00:38:27,760
handles key value storage like what all

00:38:25,480 --> 00:38:30,220
it does is handle strings and duplicate

00:38:27,760 --> 00:38:32,200
them in fact it's essentially you know

00:38:30,220 --> 00:38:33,670
dynomite sits in between and it does

00:38:32,200 --> 00:38:35,560
actually re you know it is

00:38:33,670 --> 00:38:37,120
man-in-the-middle itself so if it gets

00:38:35,560 --> 00:38:39,850
compromised that's a very serious thing

00:38:37,120 --> 00:38:42,250
and so I was pretty shocked when I saw

00:38:39,850 --> 00:38:43,560
this fix I had no I didn't think it

00:38:42,250 --> 00:38:45,640
would be down on the string code and

00:38:43,560 --> 00:38:47,200
essentially they were using string

00:38:45,640 --> 00:38:48,790
functions a string library but they were

00:38:47,200 --> 00:38:49,300
kind of a little bit writing their own

00:38:48,790 --> 00:38:50,680
code

00:38:49,300 --> 00:38:53,050
/ - they weren't using it really

00:38:50,680 --> 00:38:55,210
strictly and so here's their diff and

00:38:53,050 --> 00:38:57,550
you can see this is a standard off by

00:38:55,210 --> 00:39:01,210
one error and so that's how they fixed

00:38:57,550 --> 00:39:02,590
it and so this got fixed and so I I did

00:39:01,210 --> 00:39:05,980
get in the next flicks Hall of Fame

00:39:02,590 --> 00:39:08,140
which is a good place to be and they

00:39:05,980 --> 00:39:09,130
it's good to have it fixed and I was

00:39:08,140 --> 00:39:10,300
just you know really surprised about

00:39:09,130 --> 00:39:11,950
this this could have been you know

00:39:10,300 --> 00:39:13,510
theoretically a pretty critical bug if

00:39:11,950 --> 00:39:14,920
you have a hacker could have gotten

00:39:13,510 --> 00:39:15,940
man-in-the-middle between the internet

00:39:14,920 --> 00:39:19,750
and Netflix

00:39:15,940 --> 00:39:22,810
and or a lot of other people so pretty

00:39:19,750 --> 00:39:24,520
serious bug I would say and and so

00:39:22,810 --> 00:39:27,670
that's gonna do it for now I'd like to

00:39:24,520 --> 00:39:30,010
talk about some references Rensselaer

00:39:27,670 --> 00:39:32,620
Polytechnic Institute has a great course

00:39:30,010 --> 00:39:35,920
called modern binary exploitation and

00:39:32,620 --> 00:39:37,930
this is both on github and they also

00:39:35,920 --> 00:39:39,430
have materials as well on their site so

00:39:37,930 --> 00:39:41,950
it's good to search for this on github

00:39:39,430 --> 00:39:44,290
they have a bunch of vulnerable apps to

00:39:41,950 --> 00:39:45,990
practice against and then on their site

00:39:44,290 --> 00:39:48,910
they have really the full course

00:39:45,990 --> 00:39:50,350
materials so you can just take this

00:39:48,910 --> 00:39:52,870
course on your own and I did and I

00:39:50,350 --> 00:39:54,460
learned a great deal from it and they

00:39:52,870 --> 00:39:58,030
also cover reverse engineering in

00:39:54,460 --> 00:39:59,680
addition to binary exploitation and then

00:39:58,030 --> 00:40:01,660
the Bible of this kind of work is called

00:39:59,680 --> 00:40:04,600
hacking the art of exploitation by John

00:40:01,660 --> 00:40:07,570
Ericsson I got the first edition in 2005

00:40:04,600 --> 00:40:09,430
there's a second edition now and then

00:40:07,570 --> 00:40:12,430
project CRI was a great blog some other

00:40:09,430 --> 00:40:15,220
really nice references there more than I

00:40:12,430 --> 00:40:16,390
can list as well so and that's going to

00:40:15,220 --> 00:40:18,010
do it for now I really appreciate your

00:40:16,390 --> 00:40:21,450
attention and I think we have a little

00:40:18,010 --> 00:40:21,450
bit of time if there's any questions

00:40:25,300 --> 00:40:33,410
yeah so we're gonna we're gonna use the

00:40:28,400 --> 00:40:36,770
mic here for the questions see if I was

00:40:33,410 --> 00:40:40,190
a good talk I like it I wanted to ask

00:40:36,770 --> 00:40:42,770
have you had any experience with using

00:40:40,190 --> 00:40:46,849
like any kind of fuzzing tool or dynamic

00:40:42,770 --> 00:40:48,740
tool to try to exploit Java code or

00:40:46,849 --> 00:40:51,410
something that runs in Java yeah thank

00:40:48,740 --> 00:40:54,980
you yeah great question so the question

00:40:51,410 --> 00:40:57,530
yeah so do we use fuzzing to to break

00:40:54,980 --> 00:41:00,740
java or even other managed languages and

00:40:57,530 --> 00:41:02,030
that's the next step so i'm my company

00:41:00,740 --> 00:41:04,220
is actually researching that right now

00:41:02,030 --> 00:41:06,470
I'm working on that right now the idea

00:41:04,220 --> 00:41:08,630
is that fuzzers with with Manik with

00:41:06,470 --> 00:41:11,810
unmanaged memory well let me put it this

00:41:08,630 --> 00:41:14,630
way a fuzzer fundamentally throws random

00:41:11,810 --> 00:41:18,440
data at an application and it monitors

00:41:14,630 --> 00:41:20,359
in this case for crashes but a fuzzy

00:41:18,440 --> 00:41:22,760
could monitor for anything for any kind

00:41:20,359 --> 00:41:25,220
of condition the problem is or the hard

00:41:22,760 --> 00:41:28,250
work is specifying those conditions and

00:41:25,220 --> 00:41:31,130
so I'm trying to think of ways in Java I

00:41:28,250 --> 00:41:32,599
mean to do that and obviously you could

00:41:31,130 --> 00:41:34,460
do that by hand but that's sort of like

00:41:32,599 --> 00:41:35,990
writing unit tests so so I'm trying to

00:41:34,460 --> 00:41:37,460
work on ways to do that the answer for

00:41:35,990 --> 00:41:39,800
now there's really not a whole lot that

00:41:37,460 --> 00:41:41,690
fuzzers offer out-of-the-box as they

00:41:39,800 --> 00:41:42,920
stand for a managed code but we're

00:41:41,690 --> 00:41:50,150
working on it looking for ways to do

00:41:42,920 --> 00:41:51,050
that anybody else yeah okay cool it's

00:41:50,150 --> 00:41:53,359
like one of those talk shows or

00:41:51,050 --> 00:41:55,960
something yeah thank you does your

00:41:53,359 --> 00:41:58,579
workflow change any for multi-threaded

00:41:55,960 --> 00:41:59,990
applications oh yeah good question yes

00:41:58,579 --> 00:42:03,770
so does the workflow change for

00:41:59,990 --> 00:42:06,650
multi-threaded applications not mine or

00:42:03,770 --> 00:42:07,609
I I don't do that I actually like when

00:42:06,650 --> 00:42:10,190
I'm fuzzing stuff

00:42:07,609 --> 00:42:13,280
I'm usually or I am fuzzing it in a

00:42:10,190 --> 00:42:16,010
single-threaded context and I and I

00:42:13,280 --> 00:42:17,900
typically I really don't fuzz stuff

00:42:16,010 --> 00:42:18,319
that's multi-threaded at this point or I

00:42:17,900 --> 00:42:20,510
haven't

00:42:18,319 --> 00:42:21,950
now you could but it's certainly it's

00:42:20,510 --> 00:42:23,599
obviously harder for a lot of reasons

00:42:21,950 --> 00:42:26,510
and actually the fuzzer that I use

00:42:23,599 --> 00:42:27,680
itself is single threaded and so I mean

00:42:26,510 --> 00:42:31,160
you could certainly spin up multiple

00:42:27,680 --> 00:42:34,609
ones of them to do it at scale but in

00:42:31,160 --> 00:42:35,869
terms of specifically fuzzing maybe to

00:42:34,609 --> 00:42:37,490
try to find race conditions and things

00:42:35,869 --> 00:42:37,920
like that I've actually never done that

00:42:37,490 --> 00:42:46,200
that's

00:42:37,920 --> 00:42:47,369
interesting idea anybody else all right

00:42:46,200 --> 00:42:48,510
thank you guys very much really

00:42:47,369 --> 00:42:49,589
appreciate really appreciate your

00:42:48,510 --> 00:42:51,640
attention hope you have a great rest of

00:42:49,589 --> 00:42:56,949
your day

00:42:51,640 --> 00:42:56,949

YouTube URL: https://www.youtube.com/watch?v=I4LMhzDGhgE


