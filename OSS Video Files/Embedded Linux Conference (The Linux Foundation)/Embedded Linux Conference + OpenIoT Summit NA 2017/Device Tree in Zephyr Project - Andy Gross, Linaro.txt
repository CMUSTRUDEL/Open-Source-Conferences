Title: Device Tree in Zephyr Project - Andy Gross, Linaro
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Device Tree in Zephyr Project - Andy Gross, Linaro

SoC Vendors, board vendors, software middle layers, scripting languages, all need to have access to system configuration information (pin mixes, what sensors are on a system, what amount of memory, flash, and so forth). We need a means to convey this in a vendor neutral mechanism but also one that is friendly for Cortex-M/constrained footprint devices. In addition, many SoC vendors already have their own code generation tools that could generate device tree information. So why not leverage that to simplify the board configuration and device initialization.

This session will discuss the topic with regards to Zephyr, what changes have been made to integrate device tree into Zephyr, how this impacts the way system configuration is done, what additional changes we see needed for Zephyr, and the progress on a common definition format and tooling associated with it.

About Andy Gross
I work for Linaro as a kernel developer. My current project is IOT related , specifically to improve board configuration in Zephyr. I am the current Linux kernel maintainer for the Qualcomm SoC.
Captions: 
	00:00:00,030 --> 00:00:07,560
my name is Andy gross I work in Lennar

00:00:03,959 --> 00:00:10,200
Oh in the IOT group and today I'm going

00:00:07,560 --> 00:00:12,330
to present on the Zephyr OS

00:00:10,200 --> 00:00:18,570
configuration some of the device tree

00:00:12,330 --> 00:00:22,230
work that's been been in progress so I'm

00:00:18,570 --> 00:00:24,660
going to talk briefly about how Zephyr

00:00:22,230 --> 00:00:28,109
works today at least with regards to

00:00:24,660 --> 00:00:30,539
configuration if you have looked at the

00:00:28,109 --> 00:00:32,790
Zephyr source tree you'll notice that

00:00:30,539 --> 00:00:35,130
there's configuration information that

00:00:32,790 --> 00:00:37,500
is spread across a number of directories

00:00:35,130 --> 00:00:40,739
for any given board you have a board

00:00:37,500 --> 00:00:43,920
directory you have an arch directory

00:00:40,739 --> 00:00:45,629
which contains some information and the

00:00:43,920 --> 00:00:48,930
information is in a form of K config

00:00:45,629 --> 00:00:52,559
files def config files and there's also

00:00:48,930 --> 00:00:54,239
some auto auto configurated information

00:00:52,559 --> 00:00:56,489
so when you actually go through your

00:00:54,239 --> 00:01:03,090
build process all this is sucked in and

00:00:56,489 --> 00:01:05,430
the options are set and different pieces

00:01:03,090 --> 00:01:09,000
of the drivers are enabled or disabled

00:01:05,430 --> 00:01:10,680
based on those settings as such the

00:01:09,000 --> 00:01:12,240
configuration is kind of hard-coded so

00:01:10,680 --> 00:01:14,670
depending on how you have your cake and

00:01:12,240 --> 00:01:16,439
figs setup and your def configs it it

00:01:14,670 --> 00:01:17,700
just does it if you look at the code

00:01:16,439 --> 00:01:19,799
you'll notice places where there's

00:01:17,700 --> 00:01:22,320
multiple copies of things if def

00:01:19,799 --> 00:01:24,060
surround those which is which utilizes

00:01:22,320 --> 00:01:27,270
those options to decide whether or not

00:01:24,060 --> 00:01:30,180
something's compiled or used there's

00:01:27,270 --> 00:01:32,759
also multiple sources for the this

00:01:30,180 --> 00:01:34,470
information for the definitions whether

00:01:32,759 --> 00:01:36,920
it be the symphysis files which are

00:01:34,470 --> 00:01:41,040
generated are given from the vendors or

00:01:36,920 --> 00:01:42,990
other vendor specific include files and

00:01:41,040 --> 00:01:46,280
the thing is is across different boards

00:01:42,990 --> 00:01:49,259
even in the same family you'll have more

00:01:46,280 --> 00:01:51,840
almost identical directories with very

00:01:49,259 --> 00:01:53,100
similar information so it's not very

00:01:51,840 --> 00:01:54,450
extensible every time you had a board

00:01:53,100 --> 00:01:58,469
and a family it's almost the same

00:01:54,450 --> 00:02:00,390
information is included so the idea was

00:01:58,469 --> 00:02:02,189
well how do we how to get away from

00:02:00,390 --> 00:02:04,049
doing that and one of the ways that you

00:02:02,189 --> 00:02:05,909
could do that is to start using device

00:02:04,049 --> 00:02:07,770
tree to describe the hardware

00:02:05,909 --> 00:02:09,360
configuration and even some of the

00:02:07,770 --> 00:02:12,180
Zephyrs software configuration that you

00:02:09,360 --> 00:02:13,020
want the nice thing about device tree is

00:02:12,180 --> 00:02:15,930
it's arc

00:02:13,020 --> 00:02:18,000
actually neutral it works on XA it could

00:02:15,930 --> 00:02:19,260
work on x86 it works on arm it works on

00:02:18,000 --> 00:02:22,440
risk it works on a lot of different

00:02:19,260 --> 00:02:27,360
architectures it's very easy to to add

00:02:22,440 --> 00:02:28,830
new ones if you get your ticket

00:02:27,360 --> 00:02:30,270
information from the device tree you can

00:02:28,830 --> 00:02:33,450
actually remove a lot of the k config

00:02:30,270 --> 00:02:36,750
options that are hard-coded right now so

00:02:33,450 --> 00:02:38,820
on a given board if a specific device

00:02:36,750 --> 00:02:40,560
note is enabled that means you're using

00:02:38,820 --> 00:02:42,030
it whereas before you would actually

00:02:40,560 --> 00:02:44,160
have a keiki fig option that says okay

00:02:42,030 --> 00:02:47,180
I'm using yards here I'm using you are 1

00:02:44,160 --> 00:02:50,390
2 3 4 however many you arts you have

00:02:47,180 --> 00:02:53,490
device tree can describe any device node

00:02:50,390 --> 00:02:54,600
if you go to the device tree website

00:02:53,490 --> 00:02:57,000
which actually I don't have a link to

00:02:54,600 --> 00:02:59,880
here which I should have added there's a

00:02:57,000 --> 00:03:02,580
whole document that describes how the

00:02:59,880 --> 00:03:05,600
vise tree is used to describe nodes it

00:03:02,580 --> 00:03:08,070
talks about the format it's clear text

00:03:05,600 --> 00:03:10,950
there's specific fields that have to be

00:03:08,070 --> 00:03:12,210
done there's a specific syntax if you

00:03:10,950 --> 00:03:18,660
follow all that you can run it through

00:03:12,210 --> 00:03:19,950
the compiler and you can get output if

00:03:18,660 --> 00:03:21,300
you look at the different architectures

00:03:19,950 --> 00:03:24,030
that currently need the bot use device

00:03:21,300 --> 00:03:25,110
tree and you just grab any number of the

00:03:24,030 --> 00:03:27,510
files and just take a look at them

00:03:25,110 --> 00:03:28,800
there's lots of different pieces of

00:03:27,510 --> 00:03:31,740
hardware that people describe using

00:03:28,800 --> 00:03:33,540
device tree you can describe buses you

00:03:31,740 --> 00:03:35,880
can describe just about anything and if

00:03:33,540 --> 00:03:38,130
you need a property some some generic

00:03:35,880 --> 00:03:40,610
property you can add that property it's

00:03:38,130 --> 00:03:42,560
not that big of a deal

00:03:40,610 --> 00:03:46,800
[Music]

00:03:42,560 --> 00:03:48,690
so for Zephyr right now so if we look at

00:03:46,800 --> 00:03:51,209
how the Linux kernel uses device tree

00:03:48,690 --> 00:03:53,580
it's very much ok you describe the

00:03:51,209 --> 00:03:57,030
hardware you compile it you get a blob

00:03:53,580 --> 00:03:59,490
which is a binary form of this when the

00:03:57,030 --> 00:04:02,520
Linux boots up it uses that to create

00:03:59,490 --> 00:04:04,320
its device list and then that's how it

00:04:02,520 --> 00:04:06,450
goes through in probes and gets drivers

00:04:04,320 --> 00:04:08,670
loaded for Zephyr is very different so

00:04:06,450 --> 00:04:12,239
Zephyr you don't have a lot of room you

00:04:08,670 --> 00:04:16,290
don't have a lot of flash you can't keep

00:04:12,239 --> 00:04:18,510
the blob in in the image itself it's too

00:04:16,290 --> 00:04:21,299
big so if you actually take a device

00:04:18,510 --> 00:04:22,940
tree file and you compile it it's for a

00:04:21,299 --> 00:04:25,280
12 you know K

00:04:22,940 --> 00:04:26,870
if you look at some of the flash sizes

00:04:25,280 --> 00:04:29,030
on some of these parts that we run

00:04:26,870 --> 00:04:31,490
Zephyr on it's that's just not going to

00:04:29,030 --> 00:04:33,320
work so for Zephyr we're not going to be

00:04:31,490 --> 00:04:36,830
using the blob we're gonna only use the

00:04:33,320 --> 00:04:38,750
device tree to generate some include

00:04:36,830 --> 00:04:41,450
information and I'll get to that here in

00:04:38,750 --> 00:04:44,630
a little bit the nice thing about device

00:04:41,450 --> 00:04:47,240
tree as I said before if you add a board

00:04:44,630 --> 00:04:53,990
that's in a family that's already that's

00:04:47,240 --> 00:04:55,190
already supported it's really you're all

00:04:53,990 --> 00:04:56,840
you're describing is the difference in

00:04:55,190 --> 00:04:58,820
that board from another board that uses

00:04:56,840 --> 00:05:01,040
the same sock family so adding new

00:04:58,820 --> 00:05:03,890
boards is a whole lot easier which is

00:05:01,040 --> 00:05:06,050
pretty nice so I showed this slide in a

00:05:03,890 --> 00:05:08,770
previous couple of these slides in a

00:05:06,050 --> 00:05:08,770
previous discussion

00:05:09,020 --> 00:05:12,500
the thing about device tree is for

00:05:10,700 --> 00:05:14,390
Zephyr we have to be able to use the

00:05:12,500 --> 00:05:17,030
device tree to generate some of the

00:05:14,390 --> 00:05:19,040
include file information that we use for

00:05:17,030 --> 00:05:20,810
builds so so how would we do that so

00:05:19,040 --> 00:05:22,610
you're gonna start basically with

00:05:20,810 --> 00:05:24,110
collecting a lot of information you're

00:05:22,610 --> 00:05:26,330
gonna have a device tree source which

00:05:24,110 --> 00:05:28,910
may include some files that exist

00:05:26,330 --> 00:05:32,450
elsewhere whether it's the Simpson file

00:05:28,910 --> 00:05:35,630
or a vendor file you're gonna want to

00:05:32,450 --> 00:05:37,550
process that like the Linux does with

00:05:35,630 --> 00:05:41,060
the C preprocessor it's C preprocessor

00:05:37,550 --> 00:05:43,610
to replace a lot of the macros that you

00:05:41,060 --> 00:05:45,950
may use in device tree file and then

00:05:43,610 --> 00:05:47,570
lastly you're gonna get some output that

00:05:45,950 --> 00:05:49,520
you're gonna have to use to build your

00:05:47,570 --> 00:05:51,430
include information and/or device

00:05:49,520 --> 00:05:58,240
structures if that's what you want to do

00:05:51,430 --> 00:06:01,010
so here's how it actually came out in

00:05:58,240 --> 00:06:03,169
zephyr today with the one-seven-zero

00:06:01,010 --> 00:06:08,030
release we actually have device tree

00:06:03,169 --> 00:06:11,600
support for some of the some of the

00:06:08,030 --> 00:06:14,680
boards there's a TI board the CC 3200

00:06:11,600 --> 00:06:18,560
there's some kinetise boards from NXP

00:06:14,680 --> 00:06:23,440
there's the arm beetle and some of the

00:06:18,560 --> 00:06:26,480
st boards and how it works is you

00:06:23,440 --> 00:06:28,610
provide some DTS or DTS files that DTS

00:06:26,480 --> 00:06:31,490
files are include files that are used to

00:06:28,610 --> 00:06:33,830
build a device board file you may have

00:06:31,490 --> 00:06:34,520
other include files where you pull in

00:06:33,830 --> 00:06:39,229
information

00:06:34,520 --> 00:06:41,000
a good example on the TI board the UART

00:06:39,229 --> 00:06:44,210
address we actually pull from one of the

00:06:41,000 --> 00:06:45,229
include files you take those two you run

00:06:44,210 --> 00:06:46,940
it through the compiler and the C

00:06:45,229 --> 00:06:50,000
preprocessor and you get an output in

00:06:46,940 --> 00:06:54,110
our case we care about what we want is

00:06:50,000 --> 00:06:55,520
we want a DTS - DTS pass through when

00:06:54,110 --> 00:06:56,930
you run a dt c compiler you have a

00:06:55,520 --> 00:06:59,060
choice you have an input file that you

00:06:56,930 --> 00:07:01,520
can use and you have an output file the

00:06:59,060 --> 00:07:03,860
input file and output file can be of a

00:07:01,520 --> 00:07:05,599
couple of different formats in our case

00:07:03,860 --> 00:07:07,729
we want the input file to be a DTS file

00:07:05,599 --> 00:07:09,680
which is clear text and we want the

00:07:07,729 --> 00:07:11,990
output file to be clear text as well so

00:07:09,680 --> 00:07:13,940
we want it to be a DTS file that's

00:07:11,990 --> 00:07:16,880
important because we have a parser that

00:07:13,940 --> 00:07:18,319
only works on the DTS itself and we have

00:07:16,880 --> 00:07:20,060
to go through the compiler because we

00:07:18,319 --> 00:07:21,680
want a lot of the different things to be

00:07:20,060 --> 00:07:23,990
resolved when you're running through the

00:07:21,680 --> 00:07:25,460
compiler all the P handles are resolved

00:07:23,990 --> 00:07:27,530
which p handle is just a pointer to

00:07:25,460 --> 00:07:28,639
another device note when you have

00:07:27,530 --> 00:07:30,590
something like an interrupt controller

00:07:28,639 --> 00:07:31,880
or a GPI controller and you actually

00:07:30,590 --> 00:07:34,009
reference those in one of the device

00:07:31,880 --> 00:07:36,770
drivers like for instance let's say you

00:07:34,009 --> 00:07:38,690
have a spy device and it has some pins

00:07:36,770 --> 00:07:41,150
it wants to set you have to be able to

00:07:38,690 --> 00:07:43,610
resolve that back to the GPIO controller

00:07:41,150 --> 00:07:46,909
so that you can know how to reference

00:07:43,610 --> 00:07:49,130
that device and also tell it which pin

00:07:46,909 --> 00:07:51,800
and maybe some parameters up for that

00:07:49,130 --> 00:07:54,560
pin so when we run it through the

00:07:51,800 --> 00:07:57,349
compiler we get our compiled DTS file we

00:07:54,560 --> 00:07:59,539
still need to know how to extract

00:07:57,349 --> 00:08:01,130
information from that you may have a lot

00:07:59,539 --> 00:08:03,050
of information in the DTS file that you

00:08:01,130 --> 00:08:06,199
don't really care about you may be using

00:08:03,050 --> 00:08:08,300
a DTS file that is actually the same DTS

00:08:06,199 --> 00:08:09,529
file that's in Linux there's a lot of

00:08:08,300 --> 00:08:11,120
things that are described that we don't

00:08:09,529 --> 00:08:14,060
care about so how do we extract that

00:08:11,120 --> 00:08:16,750
information and the answer is we have

00:08:14,060 --> 00:08:19,849
another file that's in a llamo format

00:08:16,750 --> 00:08:22,490
that tells us ok here are the pieces of

00:08:19,849 --> 00:08:25,159
the file that we care about we can match

00:08:22,490 --> 00:08:28,460
the mo file that we have to the compiled

00:08:25,159 --> 00:08:30,889
DTS using the compatible and if you are

00:08:28,460 --> 00:08:31,819
familiar with the device tree well let

00:08:30,889 --> 00:08:33,890
me say if you're not familiar with

00:08:31,819 --> 00:08:36,349
device tree for every device node you

00:08:33,890 --> 00:08:38,779
have a compiled compatible field which

00:08:36,349 --> 00:08:40,579
is used to match so when you try to

00:08:38,779 --> 00:08:42,349
decide what driver works for a different

00:08:40,579 --> 00:08:43,229
device node you do it off that come out

00:08:42,349 --> 00:08:45,120
of compiled

00:08:43,229 --> 00:08:47,100
but we do the same thing here the

00:08:45,120 --> 00:08:49,950
difference is where we're matching the

00:08:47,100 --> 00:08:51,570
mo when we match those two then we can

00:08:49,950 --> 00:08:53,399
rip through the gamal look for the

00:08:51,570 --> 00:08:55,770
properties that we care about match

00:08:53,399 --> 00:08:57,209
those in the device tree extract that

00:08:55,770 --> 00:08:59,520
information and put it in a format that

00:08:57,209 --> 00:09:02,130
we can use in the include file so the

00:08:59,520 --> 00:09:06,779
output of the compiled ets and the mo is

00:09:02,130 --> 00:09:08,910
a generated include file and let me skip

00:09:06,779 --> 00:09:11,790
forward to what the generated output is

00:09:08,910 --> 00:09:15,360
going to look like for the arm Beatle

00:09:11,790 --> 00:09:18,060
board this is only a snippet the output

00:09:15,360 --> 00:09:20,790
is basically a bunch of pound defines if

00:09:18,060 --> 00:09:23,730
you look in the zephyr code before the

00:09:20,790 --> 00:09:25,830
device tree was added you're gonna see a

00:09:23,730 --> 00:09:29,010
lot of these pound defines that were kay

00:09:25,830 --> 00:09:31,649
config options the thing is is that for

00:09:29,010 --> 00:09:33,510
a given board you have a device note

00:09:31,649 --> 00:09:37,260
that sits at a certain address you still

00:09:33,510 --> 00:09:41,399
have to resolve ur0 is a specific node

00:09:37,260 --> 00:09:42,630
at a specific address we have had to

00:09:41,399 --> 00:09:46,290
work around that a little bit right now

00:09:42,630 --> 00:09:47,940
but that's gonna be going away but this

00:09:46,290 --> 00:09:50,970
is what you're gonna see from that

00:09:47,940 --> 00:09:53,220
output and this file is included in the

00:09:50,970 --> 00:09:57,600
driver files and other files in the

00:09:53,220 --> 00:10:01,050
system that required I'm gonna back back

00:09:57,600 --> 00:10:02,940
up to the ammo so in this slide I talked

00:10:01,050 --> 00:10:04,800
about how we have a compiled ets and we

00:10:02,940 --> 00:10:07,890
have a yama file that we used to extract

00:10:04,800 --> 00:10:11,520
the information now i'm going to talk

00:10:07,890 --> 00:10:14,640
about how we're using the mo in this

00:10:11,520 --> 00:10:17,190
effort so we have devices described in

00:10:14,640 --> 00:10:19,980
DT that's in a device tree format we

00:10:17,190 --> 00:10:21,810
have the device node described in Yama

00:10:19,980 --> 00:10:24,959
which tells us compatible properties

00:10:21,810 --> 00:10:27,660
that we care about cells what the cell

00:10:24,959 --> 00:10:29,279
names are gonna be this is important

00:10:27,660 --> 00:10:30,959
because on like like ice mentioned

00:10:29,279 --> 00:10:33,990
earlier interrupt controllers GPI can I

00:10:30,959 --> 00:10:35,700
Oh controllers when you have a device

00:10:33,990 --> 00:10:36,839
tree entry you're gonna have the

00:10:35,700 --> 00:10:38,490
handling you're gonna have some number

00:10:36,839 --> 00:10:41,100
of cells well what are those cells meet

00:10:38,490 --> 00:10:43,350
well for an interrupt controller the

00:10:41,100 --> 00:10:47,399
first cell could mean an i RQ the second

00:10:43,350 --> 00:10:52,140
cell could mean some flags for GPIO GPIO

00:10:47,399 --> 00:10:56,519
pin GPIO flags like you know

00:10:52,140 --> 00:10:58,380
the bias the drive strength things of

00:10:56,519 --> 00:11:00,360
that nature so we have to have a way of

00:10:58,380 --> 00:11:01,920
defining that and also using that in our

00:11:00,360 --> 00:11:04,709
extraction so that we can actually use

00:11:01,920 --> 00:11:08,040
the the include information that we that

00:11:04,709 --> 00:11:10,260
we generate so the animal gives us a

00:11:08,040 --> 00:11:12,899
description of the contents it gives us

00:11:10,260 --> 00:11:14,459
the definition the properties it tells

00:11:12,899 --> 00:11:16,709
us whether or not those properties are

00:11:14,459 --> 00:11:21,000
to be extracted it also tells us the

00:11:16,709 --> 00:11:23,279
format of the output we have two ideas

00:11:21,000 --> 00:11:26,640
for how we use the information coming

00:11:23,279 --> 00:11:32,130
out of this one we we care about include

00:11:26,640 --> 00:11:33,990
information which is what you saw on the

00:11:32,130 --> 00:11:36,120
output the other thing that we care

00:11:33,990 --> 00:11:38,670
about trying to create is data

00:11:36,120 --> 00:11:40,980
structures so if you look at the device

00:11:38,670 --> 00:11:43,560
driver api's right now you'll notice

00:11:40,980 --> 00:11:46,560
that there's platform data that's

00:11:43,560 --> 00:11:50,010
created and encased in these if def

00:11:46,560 --> 00:11:51,480
statements well one we want to get away

00:11:50,010 --> 00:11:55,230
from that we really want to have

00:11:51,480 --> 00:11:56,579
platform data generated and with this we

00:11:55,230 --> 00:11:58,170
can actually generate it because we know

00:11:56,579 --> 00:12:00,660
exactly how many nodes we have we have

00:11:58,170 --> 00:12:03,360
we know what we need to extract and we

00:12:00,660 --> 00:12:05,339
can also tell it okay well for let's say

00:12:03,360 --> 00:12:07,020
a node that requires some number of GPIO

00:12:05,339 --> 00:12:09,149
pins why don't we just build up a

00:12:07,020 --> 00:12:11,070
platform data if you look at the driver

00:12:09,149 --> 00:12:12,540
examples right now they actually do that

00:12:11,070 --> 00:12:14,399
they'll have some platform data

00:12:12,540 --> 00:12:15,510
structure that's created and they'll

00:12:14,399 --> 00:12:17,940
have some fields in there that actually

00:12:15,510 --> 00:12:20,910
say okay this is my clock gate this is

00:12:17,940 --> 00:12:23,899
my GPIO pin well we can actually create

00:12:20,910 --> 00:12:26,820
this and so all that code can go away

00:12:23,899 --> 00:12:28,800
the other important thing about the ml

00:12:26,820 --> 00:12:32,040
is is it allows us to validate the DT

00:12:28,800 --> 00:12:33,450
contents this is important because if

00:12:32,040 --> 00:12:35,100
you have a device tree file and you have

00:12:33,450 --> 00:12:37,800
a yam on the to don't necessarily match

00:12:35,100 --> 00:12:39,810
up you're gonna have some issues so we

00:12:37,800 --> 00:12:41,699
have to have a way of validating that so

00:12:39,810 --> 00:12:44,250
we're gonna have some helper scripts

00:12:41,699 --> 00:12:46,920
that when you create your DTS in your

00:12:44,250 --> 00:12:48,570
llamo files you can use those to

00:12:46,920 --> 00:12:51,209
validate one that you have a llamo file

00:12:48,570 --> 00:12:53,959
that's of the correct syntax and format

00:12:51,209 --> 00:12:57,839
and also that the mo file will actually

00:12:53,959 --> 00:13:02,730
appropriately work on that device tree

00:12:57,839 --> 00:13:03,959
itself we don't want when a developer is

00:13:02,730 --> 00:13:04,950
working on this we want them to be able

00:13:03,959 --> 00:13:06,780
to figure out ok this is

00:13:04,950 --> 00:13:08,010
this is the the issues that you're

00:13:06,780 --> 00:13:10,890
having before you get to the point of

00:13:08,010 --> 00:13:14,460
actually building Zephyr and when I say

00:13:10,890 --> 00:13:16,680
a user I kind of mean in a lot of these

00:13:14,460 --> 00:13:17,850
cases the vendor is gonna supply the

00:13:16,680 --> 00:13:19,110
device tree files and they're gonna

00:13:17,850 --> 00:13:20,790
supply the ammo because they're the

00:13:19,110 --> 00:13:23,910
people who know how the hardware works

00:13:20,790 --> 00:13:26,280
they have Hardware databases to generate

00:13:23,910 --> 00:13:27,900
this stuff so the intent for a lot of

00:13:26,280 --> 00:13:30,780
this stuff is not necessarily for the

00:13:27,900 --> 00:13:32,820
end user out there you know the hobbyist

00:13:30,780 --> 00:13:34,230
or whoever's using this to actually go

00:13:32,820 --> 00:13:35,940
out and write device tree and yam well I

00:13:34,230 --> 00:13:38,520
think that's that's a very high bar for

00:13:35,940 --> 00:13:40,140
people what we really want is we want

00:13:38,520 --> 00:13:42,030
the vendors to generate this they have

00:13:40,140 --> 00:13:44,310
all the information on hand they should

00:13:42,030 --> 00:13:45,930
be able to do it and in fact it's just a

00:13:44,310 --> 00:13:47,760
different format they already generated

00:13:45,930 --> 00:13:50,160
Simpsons files it's very easy for them

00:13:47,760 --> 00:13:51,480
to generate anything else and for some

00:13:50,160 --> 00:13:53,160
of these vendors they're already dealing

00:13:51,480 --> 00:13:55,260
with Linux they already generate a lot

00:13:53,160 --> 00:13:56,940
of this stuff for Linux there shouldn't

00:13:55,260 --> 00:13:58,110
be any there shouldn't be much tooling

00:13:56,940 --> 00:14:07,910
required for them to actually generate

00:13:58,110 --> 00:14:07,910
it for Zephyr as well so yes

00:14:11,819 --> 00:14:19,509
no you can actually use sims's as

00:14:14,589 --> 00:14:21,639
includes or a subset of the symphysis

00:14:19,509 --> 00:14:24,850
includes right now the symphysis files

00:14:21,639 --> 00:14:26,470
that are generated have not only pound

00:14:24,850 --> 00:14:28,300
to find information they also have

00:14:26,470 --> 00:14:32,170
structures and that's kind of a problem

00:14:28,300 --> 00:14:33,970
for the for the c preprocessor there are

00:14:32,170 --> 00:14:35,740
some vendors that actually have some of

00:14:33,970 --> 00:14:38,319
that information partition such that you

00:14:35,740 --> 00:14:41,410
can actually include it the idea is is

00:14:38,319 --> 00:14:42,880
that for let's say addresses it would

00:14:41,410 --> 00:14:44,500
make much more sense for us to be able

00:14:42,880 --> 00:14:46,509
to use the symphysis addresses for that

00:14:44,500 --> 00:14:49,089
stuff so that you don't have like a fat

00:14:46,509 --> 00:14:52,180
finger error where somebody has done

00:14:49,089 --> 00:14:54,990
something wrong for that to happen

00:14:52,180 --> 00:14:57,370
though we've got to be able to kind of

00:14:54,990 --> 00:14:58,630
figure out how to knock out the

00:14:57,370 --> 00:14:59,889
structures of the symphysis either the

00:14:58,630 --> 00:15:01,329
symphysis files need to include

00:14:59,889 --> 00:15:05,170
something that allows us to cut all that

00:15:01,329 --> 00:15:09,940
out and when we give it you know one of

00:15:05,170 --> 00:15:11,740
the compiled flag that would probably be

00:15:09,940 --> 00:15:13,329
the ideal thing or if they could just

00:15:11,740 --> 00:15:14,949
split it out I think it's more likely

00:15:13,329 --> 00:15:18,060
for them to encase it and something that

00:15:14,949 --> 00:15:20,829
allows us to cut out the structure stuff

00:15:18,060 --> 00:15:23,889
but the intent definitely is to leverage

00:15:20,829 --> 00:15:27,370
sims's where we can which at a minimum

00:15:23,889 --> 00:15:28,509
is going to be the addresses if you look

00:15:27,370 --> 00:15:31,290
at the simpsons files they actually

00:15:28,509 --> 00:15:31,290
include a lot more stuff

00:15:39,379 --> 00:15:44,959
yes and in fact if at the previous ELC

00:15:42,839 --> 00:15:48,239
or with the plumbers with the plumbers

00:15:44,959 --> 00:15:51,359
plumbers this this was exactly the

00:15:48,239 --> 00:15:52,919
subject make the documentation go away

00:15:51,359 --> 00:15:54,660
if people read these VMO files in a

00:15:52,919 --> 00:15:56,069
certain specific format that works you

00:15:54,660 --> 00:15:58,019
can actually use it to validate to DT

00:15:56,069 --> 00:15:59,759
that can be an extra step in the Linux

00:15:58,019 --> 00:16:01,230
compiled and so then all the

00:15:59,759 --> 00:16:02,639
documentation stuff goes away if you

00:16:01,230 --> 00:16:05,999
look at the documentation in the Linux

00:16:02,639 --> 00:16:07,949
kernel today you look at any one file

00:16:05,999 --> 00:16:11,189
and you compare it to any other one file

00:16:07,949 --> 00:16:12,540
and you have major differences because I

00:16:11,189 --> 00:16:14,699
know when I was writing documentation

00:16:12,540 --> 00:16:16,319
for that stuff I would look at a couple

00:16:14,699 --> 00:16:18,809
of examples and just kind of decide what

00:16:16,319 --> 00:16:20,730
I wanted to do with yamo you don't have

00:16:18,809 --> 00:16:24,839
that it's this is how it's gonna be

00:16:20,730 --> 00:16:27,660
and as long as you stick to that I think

00:16:24,839 --> 00:16:28,859
things will work pretty well and if you

00:16:27,660 --> 00:16:30,299
want to talk to somebody you can talk to

00:16:28,859 --> 00:16:32,910
Frank after afterwards about that

00:16:30,299 --> 00:16:41,699
because cuz he was looking at at doing

00:16:32,910 --> 00:16:45,029
that exact thing so here is just a small

00:16:41,699 --> 00:16:49,169
snippet of gamal and a dt example so

00:16:45,029 --> 00:16:52,860
this yamo file is describing the you are

00:16:49,169 --> 00:16:54,809
here for the beetle on the right you

00:16:52,860 --> 00:17:01,049
have the device tree snippet so you have

00:16:54,809 --> 00:17:04,399
the node name you have a label you have

00:17:01,049 --> 00:17:07,860
a compatible the reg is the register of

00:17:04,399 --> 00:17:09,539
register location plus size yeah what

00:17:07,860 --> 00:17:11,519
interrupt it is and then here's a zephyr

00:17:09,539 --> 00:17:14,339
specific property which is the ir keep

00:17:11,519 --> 00:17:16,829
rio which is the irq priority and then

00:17:14,339 --> 00:17:19,079
you have a baud rate the baud rate

00:17:16,829 --> 00:17:21,569
that's being specified is the baud rate

00:17:19,079 --> 00:17:23,339
that's gonna be set when the driver

00:17:21,569 --> 00:17:26,010
comes up initially that's not to say

00:17:23,339 --> 00:17:28,439
that it won't change later based off of

00:17:26,010 --> 00:17:30,570
whatever the user's doing on the left

00:17:28,439 --> 00:17:34,679
you have the yellow file which is

00:17:30,570 --> 00:17:38,610
describing this so at the top you have

00:17:34,679 --> 00:17:40,549
an inherits field which pulls in a york

00:17:38,610 --> 00:17:43,140
yellow which is actually generic across

00:17:40,549 --> 00:17:45,900
all the yards across

00:17:43,140 --> 00:17:47,400
platform this is important because

00:17:45,900 --> 00:17:49,380
they're just there's gonna be fuels in

00:17:47,400 --> 00:17:56,160
that you are mo file that you don't need

00:17:49,380 --> 00:17:58,050
to specify in the Sox specific one you

00:17:56,160 --> 00:18:00,480
also have the include Zephyr devices

00:17:58,050 --> 00:18:04,620
which is where the Zephyr IR keep Rio

00:18:00,480 --> 00:18:05,970
field comes from and then you have the

00:18:04,620 --> 00:18:08,760
properties that are specific to this

00:18:05,970 --> 00:18:10,680
binding you have a compatible which is

00:18:08,760 --> 00:18:12,510
probably to be actually be pulled into a

00:18:10,680 --> 00:18:14,780
generic file because everybody needs it

00:18:12,510 --> 00:18:17,810
compatible but it's going to be a string

00:18:14,780 --> 00:18:20,730
the constraint is what we use to match

00:18:17,810 --> 00:18:23,040
the device tree the constraint has to

00:18:20,730 --> 00:18:26,640
match for these for this yamo file to be

00:18:23,040 --> 00:18:28,530
used process against this node and then

00:18:26,640 --> 00:18:33,360
you have a reg field which tells us that

00:18:28,530 --> 00:18:34,950
ok this is this is an array the

00:18:33,360 --> 00:18:36,360
generation is defined meaning that we

00:18:34,950 --> 00:18:37,890
actually want to generate something out

00:18:36,360 --> 00:18:40,710
of this and that generated information

00:18:37,890 --> 00:18:44,490
will be a pound define so the output of

00:18:40,710 --> 00:18:46,760
this in the next file is the base

00:18:44,490 --> 00:18:46,760
address

00:18:47,240 --> 00:18:52,770
that's what decides that that needs to

00:18:49,800 --> 00:18:56,520
be generated and there's some aliases

00:18:52,770 --> 00:18:58,320
here that that for base address is 0 we

00:18:56,520 --> 00:18:59,970
always generate just a base address

00:18:58,320 --> 00:19:04,080
itself because that's usually the main

00:18:59,970 --> 00:19:06,930
one that people reference if you look at

00:19:04,080 --> 00:19:13,260
interrupts this node has one interrupt

00:19:06,930 --> 00:19:15,390
it is a required and actually there's a

00:19:13,260 --> 00:19:16,980
typo there and then we need want to

00:19:15,390 --> 00:19:19,770
generate define on that as well so if

00:19:16,980 --> 00:19:21,750
you look here you see irq 0 and the

00:19:19,770 --> 00:19:25,740
define is a 0 which matches the device

00:19:21,750 --> 00:19:28,280
tree itself so this is the kind of thing

00:19:25,740 --> 00:19:31,110
you're gonna see across all the you are

00:19:28,280 --> 00:19:32,880
right now the you arts are the things

00:19:31,110 --> 00:19:37,400
that are defined in the system and also

00:19:32,880 --> 00:19:39,630
the SRAM base address and flash address

00:19:37,400 --> 00:19:41,730
we're gonna start adding in other

00:19:39,630 --> 00:19:47,810
devices and also adding in capabilities

00:19:41,730 --> 00:19:47,810
like clock gating pin MUX GPIO

00:19:49,490 --> 00:19:53,400
so what I alluded to earlier if you look

00:19:52,050 --> 00:19:57,090
at the bottom in this file there is a

00:19:53,400 --> 00:20:00,690
fix up if you look in the Zephyr code

00:19:57,090 --> 00:20:03,030
itself there are pound defines there

00:20:00,690 --> 00:20:04,200
that have if you look at how it was done

00:20:03,030 --> 00:20:05,880
previously you have a que config and

00:20:04,200 --> 00:20:08,360
then it would match the this pound to

00:20:05,880 --> 00:20:11,730
fine in our case we need to match the

00:20:08,360 --> 00:20:14,580
the right side which is the you are four

00:20:11,730 --> 00:20:18,000
thousand four thousand irq 0 to the APB

00:20:14,580 --> 00:20:21,390
you are zero irq this was a stopgap

00:20:18,000 --> 00:20:23,070
measure for the 1 7 0 release this stuff

00:20:21,390 --> 00:20:24,960
is gonna go away and we're gonna do this

00:20:23,070 --> 00:20:27,810
by adding some fields into the ammo file

00:20:24,960 --> 00:20:30,500
I think to tell us how we want to

00:20:27,810 --> 00:20:30,500
generate that name

00:20:33,980 --> 00:20:40,830
so current state of development we have

00:20:37,500 --> 00:20:43,590
device tree support in 1 7 0 its base

00:20:40,830 --> 00:20:47,550
support the base address for the SRAM

00:20:43,590 --> 00:20:50,360
flash and UART the DTS Python parsing

00:20:47,550 --> 00:20:53,010
script library was a part of

00:20:50,360 --> 00:20:56,130
one-seven-zero well before the release

00:20:53,010 --> 00:20:57,360
was decided that script if you want to

00:20:56,130 --> 00:21:01,860
look at it it's in the scripts directory

00:20:57,360 --> 00:21:03,900
and it's the device tree parse Python

00:21:01,860 --> 00:21:06,060
script it's not that large but what it

00:21:03,900 --> 00:21:09,960
does it goes through the DTS file and

00:21:06,060 --> 00:21:12,810
actually will create a Python structure

00:21:09,960 --> 00:21:15,150
which is a dictionary and lists of all

00:21:12,810 --> 00:21:17,220
the device modes there's additional

00:21:15,150 --> 00:21:20,340
Python scripts on top of that which

00:21:17,220 --> 00:21:22,860
actually extract the information it goes

00:21:20,340 --> 00:21:24,990
through that device tree file knocks out

00:21:22,860 --> 00:21:27,030
some of the nodes that aren't enabled

00:21:24,990 --> 00:21:29,730
pulls in all the Emmel descriptions and

00:21:27,030 --> 00:21:32,070
then goes through every one of those and

00:21:29,730 --> 00:21:35,910
extracts the information and spits it

00:21:32,070 --> 00:21:37,170
out into standard out if you look into

00:21:35,910 --> 00:21:39,330
make files and make files actually

00:21:37,170 --> 00:21:40,920
redirect standard out into an output

00:21:39,330 --> 00:21:46,170
file and that's how this stuff get ends

00:21:40,920 --> 00:21:48,510
up in the in that output file we have

00:21:46,170 --> 00:21:54,300
the temporary fix up current support for

00:21:48,510 --> 00:21:56,029
arm Beatle CC 3200 from ti the stm32 l4

00:21:54,300 --> 00:22:00,469
76 RG and

00:21:56,029 --> 00:22:04,429
a number of the NXP kinetise parts so

00:22:00,469 --> 00:22:06,590
work for the near-term so as devices are

00:22:04,429 --> 00:22:07,580
added cleanup has to happen in the

00:22:06,590 --> 00:22:11,649
configuration directories for the

00:22:07,580 --> 00:22:15,139
board's cake config options go away and

00:22:11,649 --> 00:22:16,639
if you look in the driver directories

00:22:15,139 --> 00:22:18,109
themselves there's cake config files in

00:22:16,639 --> 00:22:20,200
there as well a lot of those options are

00:22:18,109 --> 00:22:22,759
gonna go away

00:22:20,200 --> 00:22:26,450
we the drivers need to leverage the

00:22:22,759 --> 00:22:29,169
generated files they need the driver to

00:22:26,450 --> 00:22:31,820
start to need to start using this for

00:22:29,169 --> 00:22:33,080
the initializations and what that means

00:22:31,820 --> 00:22:35,659
is is that we need to start generating

00:22:33,080 --> 00:22:39,889
some of the platform data that right now

00:22:35,659 --> 00:22:41,719
has done as part of the FDF stuff the

00:22:39,889 --> 00:22:43,489
other thing is is that because we know

00:22:41,719 --> 00:22:45,830
what devices are being used in the

00:22:43,489 --> 00:22:48,169
system what's enabled we also have the

00:22:45,830 --> 00:22:50,149
animal files to tell us ok what cake

00:22:48,169 --> 00:22:53,419
config option is this going to be we can

00:22:50,149 --> 00:22:56,659
actually generate the configurations for

00:22:53,419 --> 00:23:00,169
actually building drivers using the

00:22:56,659 --> 00:23:02,570
status of the DTE node and then lastly I

00:23:00,169 --> 00:23:06,109
kind of went out order the platform data

00:23:02,570 --> 00:23:08,769
instructor support and drivers I think

00:23:06,109 --> 00:23:11,089
that's where we're gonna get a lot of

00:23:08,769 --> 00:23:19,070
removal of some of the existing code

00:23:11,089 --> 00:23:20,389
that's in there and that's to the end we

00:23:19,070 --> 00:23:26,719
already had a few questions I'm sure we

00:23:20,389 --> 00:23:28,399
have some more does anybody have and I

00:23:26,719 --> 00:23:32,019
can back up to whatever slide we're

00:23:28,399 --> 00:23:32,019
talking about but any questions

00:23:34,990 --> 00:23:40,420
mothers this interact with the dynamic

00:23:37,920 --> 00:23:48,150
situation where you go well but you

00:23:40,420 --> 00:23:48,150
mentioned deciding

00:23:48,890 --> 00:23:55,950
right so with the platform didn't like

00:23:53,780 --> 00:23:58,440
the first use case I thought was well

00:23:55,950 --> 00:24:00,000
from a dynamic perspective just from if

00:23:58,440 --> 00:24:02,220
a drivers turned on you're gonna have

00:24:00,000 --> 00:24:03,510
cases where you want to go low-power

00:24:02,220 --> 00:24:06,030
mode so you're gonna have more than one

00:24:03,510 --> 00:24:07,260
pin configuration so that's one case you

00:24:06,030 --> 00:24:09,870
can actually define more than one pin

00:24:07,260 --> 00:24:13,500
case for a device the other thing is is

00:24:09,870 --> 00:24:15,810
that as you enable and disable devices

00:24:13,500 --> 00:24:21,540
if we describe all the devices in the

00:24:15,810 --> 00:24:23,640
device tree and it's built it has to be

00:24:21,540 --> 00:24:25,440
if you want to actually use a device

00:24:23,640 --> 00:24:26,580
that s be built into the image so all

00:24:25,440 --> 00:24:28,650
that information has to be there anyway

00:24:26,580 --> 00:24:30,390
now whether or not you have pins

00:24:28,650 --> 00:24:31,920
configured one way or another really

00:24:30,390 --> 00:24:33,810
depends on whether or not that drivers

00:24:31,920 --> 00:24:35,190
enabled or disabled as long as the

00:24:33,810 --> 00:24:37,440
driver has the information that

00:24:35,190 --> 00:24:39,030
describes those pins and reconfiguring

00:24:37,440 --> 00:24:43,110
them it should be able to go back and

00:24:39,030 --> 00:24:44,760
forth it will the key point is having

00:24:43,110 --> 00:24:47,130
that information on hand if you don't

00:24:44,760 --> 00:24:48,330
have it your I mean if you look in the

00:24:47,130 --> 00:24:51,540
Zephyr today there's a lot of static

00:24:48,330 --> 00:24:54,660
configurations for the pins and that's

00:24:51,540 --> 00:25:00,540
very limits you very much so we want to

00:24:54,660 --> 00:25:03,080
kind of get away from that I've got a

00:25:00,540 --> 00:25:03,080
question back

00:25:07,740 --> 00:25:18,670
yeah so if you so the question was the

00:25:14,890 --> 00:25:20,620
Python scripts and libraries that we

00:25:18,670 --> 00:25:23,080
wrote did that leverage stuff that

00:25:20,620 --> 00:25:25,570
exists currently today and the answer to

00:25:23,080 --> 00:25:27,520
that is no initially when I was doing

00:25:25,570 --> 00:25:31,060
this work I leveraged some of the work

00:25:27,520 --> 00:25:35,320
from Neil here in the room which was

00:25:31,060 --> 00:25:38,170
doing a Python parsing of the compiled

00:25:35,320 --> 00:25:40,750
blob the thing about that is is we don't

00:25:38,170 --> 00:25:43,240
care to compile it to a blob we'd rather

00:25:40,750 --> 00:25:44,830
leave it in clear text and there's not

00:25:43,240 --> 00:25:48,100
really any good solutions out there

00:25:44,830 --> 00:25:51,280
right now for just plain DTS parsing so

00:25:48,100 --> 00:25:53,340
I started writing a really kind of dumb

00:25:51,280 --> 00:25:55,510
because I'm I just know it's you know

00:25:53,340 --> 00:25:57,100
I've written tons of Perl I haven't

00:25:55,510 --> 00:26:00,370
written a ton of Python so I wrote a

00:25:57,100 --> 00:26:02,320
really stupid Python parser and then we

00:26:00,370 --> 00:26:04,540
had a sprint and one of the Intel guys

00:26:02,320 --> 00:26:06,460
just in one day ripped out like and

00:26:04,540 --> 00:26:08,740
wrote a whole thing to parse it which

00:26:06,460 --> 00:26:11,290
was awesome so I switched over to that

00:26:08,740 --> 00:26:13,750
and then the parts that I wrote were on

00:26:11,290 --> 00:26:16,510
top of that so the library that he wrote

00:26:13,750 --> 00:26:17,950
will parse DT right now and basically

00:26:16,510 --> 00:26:20,350
put it in a structured format which is

00:26:17,950 --> 00:26:21,640
dictionaries and lists if you're

00:26:20,350 --> 00:26:22,990
familiar with Python that's basically

00:26:21,640 --> 00:26:26,890
how you can build up like a hierarchy of

00:26:22,990 --> 00:26:29,380
information and what my scripts do do is

00:26:26,890 --> 00:26:32,370
it just kind of windows down that to a

00:26:29,380 --> 00:26:35,710
smaller set of nodes that I care about

00:26:32,370 --> 00:26:39,370
so to answer your question yes in the

00:26:35,710 --> 00:26:40,990
beginning and no not now and then the

00:26:39,370 --> 00:26:43,300
follow-up question is is how do we go

00:26:40,990 --> 00:26:44,740
back and give back to the community and

00:26:43,300 --> 00:26:47,040
actually I need to talk to Frank about

00:26:44,740 --> 00:26:47,040
that

00:26:49,340 --> 00:26:55,370
right right so so we need to figure that

00:26:52,759 --> 00:26:58,039
out and we definitely need that to be

00:26:55,370 --> 00:26:58,669
something that's fed back into out the

00:26:58,039 --> 00:27:01,190
outside

00:26:58,669 --> 00:27:03,499
I mean his effort is an open source

00:27:01,190 --> 00:27:05,720
project but that doesn't mean that we

00:27:03,499 --> 00:27:07,249
can't go back to the projects that where

00:27:05,720 --> 00:27:09,529
a lot of this stuff actually originated

00:27:07,249 --> 00:27:18,350
and give back so that's really where we

00:27:09,529 --> 00:27:21,619
need to go yeah you mean the end output

00:27:18,350 --> 00:27:23,899
yes so it basically comes down to your

00:27:21,619 --> 00:27:26,029
Yama file and your device tree file and

00:27:23,899 --> 00:27:27,889
whatever properties you add that's fine

00:27:26,029 --> 00:27:29,960
you you add a property in the mo file

00:27:27,889 --> 00:27:33,730
and you say yes I want to generate this

00:27:29,960 --> 00:27:37,749
information and it'll auto generate it

00:27:33,730 --> 00:27:37,749
deal me yeah good

00:27:41,850 --> 00:27:49,460
I haven't really thought about that

00:27:46,460 --> 00:27:49,460
frankly

00:27:51,550 --> 00:27:54,150
yes

00:28:01,820 --> 00:28:07,249
so the question was do we try to be

00:28:04,429 --> 00:28:10,729
compatible with the linux DTS I I'm

00:28:07,249 --> 00:28:12,979
guessing if a platform exists in both

00:28:10,729 --> 00:28:20,929
are they using the same DTS is that your

00:28:12,979 --> 00:28:21,950
question yeah so in some cases yes the

00:28:20,929 --> 00:28:23,570
vendor is going to have to decide

00:28:21,950 --> 00:28:25,129
whether or not those DTS files are going

00:28:23,570 --> 00:28:28,129
to be the same and if they are that's

00:28:25,129 --> 00:28:29,600
fine but I think that the the board DTS

00:28:28,129 --> 00:28:32,029
file itself is probably going to

00:28:29,600 --> 00:28:34,639
leverage some of the DTS file DTS I file

00:28:32,029 --> 00:28:38,720
the include files that are going to be

00:28:34,639 --> 00:28:41,029
common between Linux and Zephyr you know

00:28:38,720 --> 00:28:42,830
the board DTS file is very specific it

00:28:41,029 --> 00:28:45,859
says okay I care these nodes need to be

00:28:42,830 --> 00:28:49,519
enabled this board has these ports it's

00:28:45,859 --> 00:28:50,720
very specific to that board in a lot of

00:28:49,519 --> 00:28:53,539
cases I don't think you're going to see

00:28:50,720 --> 00:28:56,330
more DTS files in Zephir that you're

00:28:53,539 --> 00:28:58,700
gonna see in Lennox you may see the base

00:28:56,330 --> 00:29:02,139
architecture support for the family that

00:28:58,700 --> 00:29:02,139
you may not see the same boards

00:29:07,950 --> 00:29:13,679
we or just over coming to work going to

00:29:11,159 --> 00:29:19,220
be following the bindings that the Linux

00:29:13,679 --> 00:29:19,220
kernel has when you have for example

00:29:19,380 --> 00:29:28,530
right so yeah I mean I've I've looked at

00:29:26,610 --> 00:29:31,470
the Linux kernel to kind of get an idea

00:29:28,530 --> 00:29:33,840
of okay well for you are and spy and I

00:29:31,470 --> 00:29:35,309
squared see those are easy those are the

00:29:33,840 --> 00:29:36,929
like the easiest because they're all

00:29:35,309 --> 00:29:39,510
very similar everybody works the same

00:29:36,929 --> 00:29:42,299
way but when you get away from some of

00:29:39,510 --> 00:29:45,780
those very well-known devices it gets

00:29:42,299 --> 00:29:52,169
kind of gray so yeah we've got a look at

00:29:45,780 --> 00:29:54,270
that does this microphone yes actually

00:29:52,169 --> 00:29:57,720
using a microphone to ask a question and

00:29:54,270 --> 00:29:58,890
it's the it's I'd like you to elaborate

00:29:57,720 --> 00:30:02,640
on the question I asked earlier about

00:29:58,890 --> 00:30:05,760
licensing right because the reason the

00:30:02,640 --> 00:30:08,010
BSD dyes didn't use device didn't wind

00:30:05,760 --> 00:30:09,870
up using device tree there was a thread

00:30:08,010 --> 00:30:12,659
on Linux kernel a while ago about art

00:30:09,870 --> 00:30:14,760
the device tree files GPL and the answer

00:30:12,659 --> 00:30:17,190
was yes the ones in the Linux kernel

00:30:14,760 --> 00:30:19,409
you're talking about using DTI files

00:30:17,190 --> 00:30:21,090
from the Linux kernel that are GPL to

00:30:19,409 --> 00:30:25,770
produce binary output that goes in

00:30:21,090 --> 00:30:28,799
Zephyr so does that mean Zephyr is then

00:30:25,770 --> 00:30:31,200
you know going to be GPL on these on

00:30:28,799 --> 00:30:34,620
these targets and you are also talking

00:30:31,200 --> 00:30:37,580
about the the yamo files about moving

00:30:34,620 --> 00:30:42,120
the documentation to a parsable format

00:30:37,580 --> 00:30:44,549
if the Linux kernel guys do redo their

00:30:42,120 --> 00:30:47,669
documentation into the yamo format and

00:30:44,549 --> 00:30:53,070
you use that as part of your build does

00:30:47,669 --> 00:30:55,020
that also make your device trees GPL you

00:30:53,070 --> 00:30:59,360
know what are the licensing implications

00:30:55,020 --> 00:31:02,250
of importing Linux kernel code into

00:30:59,360 --> 00:31:04,169
Zephyr via the device tree buildable

00:31:02,250 --> 00:31:09,270
right and I'll give the same answer I

00:31:04,169 --> 00:31:13,080
gave you the file the origination of the

00:31:09,270 --> 00:31:15,840
file is from the same source so a vendor

00:31:13,080 --> 00:31:20,640
who generates a DTS file or DTS I file

00:31:15,840 --> 00:31:23,130
for Linux uses I very much doubt that

00:31:20,640 --> 00:31:24,720
they did it by hand they probably have

00:31:23,130 --> 00:31:27,990
some some database where they're

00:31:24,720 --> 00:31:29,940
generating this file if they generate

00:31:27,990 --> 00:31:31,530
some format that goes in the Linux and

00:31:29,940 --> 00:31:32,750
they generate from the same source some

00:31:31,530 --> 00:31:37,860
file that goes in

00:31:32,750 --> 00:32:06,450
that's yeah they can do whatever they

00:31:37,860 --> 00:32:10,470
like yeah no I got you and in this case

00:32:06,450 --> 00:32:13,950
we haven't done that the files that I've

00:32:10,470 --> 00:32:16,440
used I didn't do what Tom said which is

00:32:13,950 --> 00:32:18,180
lifting stuff what I did was I said okay

00:32:16,440 --> 00:32:19,500
you look all these device for each

00:32:18,180 --> 00:32:21,330
device you look and say okay what's

00:32:19,500 --> 00:32:22,770
common across all of them you generate

00:32:21,330 --> 00:32:24,150
whatever you gonna generate it just so

00:32:22,770 --> 00:32:25,500
happens and when you do that and you

00:32:24,150 --> 00:32:27,150
look at what Linux did with some of

00:32:25,500 --> 00:32:31,740
these things it's like oh hey look there

00:32:27,150 --> 00:32:33,990
they're very similar yeah as far as the

00:32:31,740 --> 00:32:36,960
yeah Mille is concerned I think we're

00:32:33,990 --> 00:32:40,500
kind of beating them to the punch a

00:32:36,960 --> 00:32:42,390
little bit on that I my gut feeling is

00:32:40,500 --> 00:32:44,960
is that whatever ends up in Linux is

00:32:42,390 --> 00:32:48,360
gonna be different than what we have it

00:32:44,960 --> 00:32:50,550
may be doing the same things and whether

00:32:48,360 --> 00:32:55,380
or not we converge over time I have no

00:32:50,550 --> 00:32:58,200
idea because that's to be determined but

00:32:55,380 --> 00:33:01,610
when that was when that information was

00:32:58,200 --> 00:33:04,500
given out in plumbers it was very much

00:33:01,610 --> 00:33:05,760
it was kind of like a ha moment for me

00:33:04,500 --> 00:33:07,740
because it's like okay that solves a

00:33:05,760 --> 00:33:08,940
couple of my problems for me but we

00:33:07,740 --> 00:33:12,720
definitely need to converge in the

00:33:08,940 --> 00:33:14,160
future because you know we're trying to

00:33:12,720 --> 00:33:15,380
do the same thing there's no reason to

00:33:14,160 --> 00:33:17,250
have two completely different

00:33:15,380 --> 00:33:21,110
implementations which do the same thing

00:33:17,250 --> 00:33:21,110
which are very similar I mean it's crazy

00:33:30,220 --> 00:33:36,280
so a lot of the dts files in the kernel

00:33:33,610 --> 00:33:39,430
are now dual licensed and we're very

00:33:36,280 --> 00:33:42,040
open to accepting more DTS as with the

00:33:39,430 --> 00:33:43,840
dual license so it's both GPL and more

00:33:42,040 --> 00:33:46,390
permissive for exactly the reason you

00:33:43,840 --> 00:33:48,820
pointed out Rob and the person driving

00:33:46,390 --> 00:33:50,350
the validation stuff and device tree

00:33:48,820 --> 00:33:52,570
whether several people but one of them

00:33:50,350 --> 00:33:54,550
is grant likely and he's very very

00:33:52,570 --> 00:33:56,680
sensitive to to be able to share his

00:33:54,550 --> 00:33:58,570
work across the different projects so

00:33:56,680 --> 00:34:00,190
he's he's dealing with those license

00:33:58,570 --> 00:34:08,590
issues and trying to make it available

00:34:00,190 --> 00:34:09,940
across projects and not about well

00:34:08,590 --> 00:34:12,070
that's that's a whole other point but

00:34:09,940 --> 00:34:14,530
his whole validation and things like the

00:34:12,070 --> 00:34:16,570
animal stuff he's he's very aware of

00:34:14,530 --> 00:34:20,610
licensing issues in not making it just

00:34:16,570 --> 00:34:20,610
GPL but shareable

00:34:24,110 --> 00:34:30,350
and that definitely is a better solution

00:34:26,600 --> 00:34:32,420
long-term my solution was I'm gonna let

00:34:30,350 --> 00:34:35,530
the vendor deal with it because that

00:34:32,420 --> 00:34:37,490
mean they actually own the information

00:34:35,530 --> 00:34:38,780
there's always gonna be people like me

00:34:37,490 --> 00:34:40,670
when I was doing these files that did

00:34:38,780 --> 00:34:41,240
them by hand but that's that's crazy no

00:34:40,670 --> 00:34:51,770
one's gonna do that

00:34:41,240 --> 00:34:53,510
long-term so any other questions so on

00:34:51,770 --> 00:34:56,890
the previous slide you you listed future

00:34:53,510 --> 00:34:59,060
work and leveraging that generated files

00:34:56,890 --> 00:35:02,380
that's what I would consider be kind of

00:34:59,060 --> 00:35:05,000
like scaffolding how do you see that

00:35:02,380 --> 00:35:07,240
going forward because there's kind of a

00:35:05,000 --> 00:35:09,560
chicken and egg thing that goes on there

00:35:07,240 --> 00:35:11,180
yeah and that's that's the real problem

00:35:09,560 --> 00:35:12,050
you have to get enough in place to be

00:35:11,180 --> 00:35:14,390
able to generate a lot of this

00:35:12,050 --> 00:35:15,890
information and then you also have to

00:35:14,390 --> 00:35:17,810
kind of look at how you're gonna use it

00:35:15,890 --> 00:35:22,130
beforehand anyway because those do go

00:35:17,810 --> 00:35:24,260
together so it's kind of messy so so the

00:35:22,130 --> 00:35:25,850
answer is is that we're at a point now

00:35:24,260 --> 00:35:27,800
where we can start dealing with the

00:35:25,850 --> 00:35:30,320
platform data aspects we have the

00:35:27,800 --> 00:35:31,850
parsing we have the extensibility built

00:35:30,320 --> 00:35:33,740
in I think to handle this type of thing

00:35:31,850 --> 00:35:34,940
it's just a matter of generating it and

00:35:33,740 --> 00:35:39,050
then actually consuming it in the end

00:35:34,940 --> 00:35:41,630
the drivers themselves our first step

00:35:39,050 --> 00:35:43,430
was very much a let's get our foot in

00:35:41,630 --> 00:35:46,220
the door let's get the board booted

00:35:43,430 --> 00:35:48,170
using device tree or the base addresses

00:35:46,220 --> 00:35:50,810
and all that and let's at least pick one

00:35:48,170 --> 00:35:54,020
standard device across all the divide

00:35:50,810 --> 00:35:55,280
the sock vendors and get it working and

00:35:54,020 --> 00:35:59,180
so that was you are it cuz that's like

00:35:55,280 --> 00:36:01,400
yeah it makes sense the next thing is is

00:35:59,180 --> 00:36:02,630
okay get the get the things you're gonna

00:36:01,400 --> 00:36:04,880
have to configure for each one of the

00:36:02,630 --> 00:36:08,420
devices the clock gating the pin MUX

00:36:04,880 --> 00:36:10,010
GPIO s and all that stuff at that point

00:36:08,420 --> 00:36:11,720
then it kind of all comes in at once

00:36:10,010 --> 00:36:12,980
because then you can generate all the

00:36:11,720 --> 00:36:15,590
platform data that you care about for a

00:36:12,980 --> 00:36:16,970
device if you look across all the

00:36:15,590 --> 00:36:19,460
devices really the only thing that they

00:36:16,970 --> 00:36:23,050
care about is base address irq maybe

00:36:19,460 --> 00:36:25,100
some pins and clock gate that's it

00:36:23,050 --> 00:36:28,190
generally

00:36:25,100 --> 00:36:30,110
I shouldn't be so absolutely so

00:36:28,190 --> 00:36:33,410
essentially that fix-up code is is where

00:36:30,110 --> 00:36:36,560
you're retrofitting yeah it's a stopgap

00:36:33,410 --> 00:36:38,750
measure four one seven zero that's going

00:36:36,560 --> 00:36:40,670
to go away that needs to be solved and

00:36:38,750 --> 00:36:44,540
this actually brings up a couple of

00:36:40,670 --> 00:36:48,500
things one how do you map the instance

00:36:44,540 --> 00:36:49,880
of a device and a device type to the

00:36:48,500 --> 00:36:53,330
generated information that's one thing

00:36:49,880 --> 00:36:54,980
and even inside Zephyr itself if you

00:36:53,330 --> 00:36:57,170
look at a board you look at the sock and

00:36:54,980 --> 00:36:59,840
the naming and all that stuff it can be

00:36:57,170 --> 00:37:03,890
very messy so so that's another problem

00:36:59,840 --> 00:37:05,630
and then the third one is for a given

00:37:03,890 --> 00:37:08,510
device since we already have a yama file

00:37:05,630 --> 00:37:10,330
we can pretty much generate we can we

00:37:08,510 --> 00:37:12,920
could embed it there to generate the

00:37:10,330 --> 00:37:14,540
pound defying that we have because we

00:37:12,920 --> 00:37:16,550
know what the prefix is supposed to be

00:37:14,540 --> 00:37:19,220
for an instance then the only question

00:37:16,550 --> 00:37:22,550
is okay well is four thousand four

00:37:19,220 --> 00:37:25,220
thousand instance zero or is it instance

00:37:22,550 --> 00:37:25,700
one because if you look at how some some

00:37:25,220 --> 00:37:27,590
socks

00:37:25,700 --> 00:37:28,820
they sometimes invert their addresses

00:37:27,590 --> 00:37:30,890
they aren't you can't just go from

00:37:28,820 --> 00:37:33,650
beginning to end they do some crazy

00:37:30,890 --> 00:37:36,400
things so so yeah we have to kind of

00:37:33,650 --> 00:37:36,400
work through that a little bit

00:37:39,390 --> 00:37:44,769
so one of the advantages of the device

00:37:42,880 --> 00:37:47,650
would be as I understood it was that you

00:37:44,769 --> 00:37:50,799
could have a common kernel and many

00:37:47,650 --> 00:37:52,299
different many different hardware

00:37:50,799 --> 00:37:56,170
configurations that goes on with that

00:37:52,299 --> 00:37:58,809
kernel it sums is if the system you're

00:37:56,170 --> 00:38:02,109
creating is going to be completely

00:37:58,809 --> 00:38:04,299
static so in your you're trying to

00:38:02,109 --> 00:38:08,710
reduce the number of aesthetically

00:38:04,299 --> 00:38:12,400
students why not instead seek to apply

00:38:08,710 --> 00:38:14,969
that same logic to the generated device

00:38:12,400 --> 00:38:14,969
reblog

00:38:18,400 --> 00:38:24,520
the thing is is that for for Zephyr

00:38:20,860 --> 00:38:26,020
everything is done upfront you know what

00:38:24,520 --> 00:38:27,730
nodes you're gonna turn on you know

00:38:26,020 --> 00:38:34,030
what's gonna be included in the system

00:38:27,730 --> 00:38:36,280
for size constraints and all that so the

00:38:34,030 --> 00:38:39,220
other thing is is that for a use case

00:38:36,280 --> 00:38:42,550
you may or may not turn on additional

00:38:39,220 --> 00:38:44,320
ports the base enablement for a board

00:38:42,550 --> 00:38:46,030
may be one thing but when you go and try

00:38:44,320 --> 00:38:50,110
to do let's say Bluetooth you may have

00:38:46,030 --> 00:38:51,310
to turn on UART 3 so there's some device

00:38:50,110 --> 00:38:56,400
tree information that's gonna have to be

00:38:51,310 --> 00:38:56,400
included for some of these use cases but

00:38:57,060 --> 00:39:02,020
yeah I don't know I mean it's the

00:39:00,310 --> 00:39:04,170
system's pretty static as it is right

00:39:02,020 --> 00:39:04,170
now

00:39:21,420 --> 00:39:33,989
you're not generalizing do you want to

00:39:23,130 --> 00:39:36,119
shrink yeah right and that's why we I

00:39:33,989 --> 00:39:39,239
don't I don't use the blob so we don't

00:39:36,119 --> 00:39:41,940
have if the blob was included we could

00:39:39,239 --> 00:39:44,730
basically query out the information

00:39:41,940 --> 00:39:46,920
runtime but we can't do that because the

00:39:44,730 --> 00:39:48,380
size of that blob is too big on some of

00:39:46,920 --> 00:40:01,079
these parts you could probably fit it on

00:39:48,380 --> 00:40:04,559
an mg ro part no way well to give you an

00:40:01,079 --> 00:40:07,440
idea I had one node one node and it was

00:40:04,559 --> 00:40:09,869
4k so so there's a there's a fairly

00:40:07,440 --> 00:40:14,190
large overhead to just the entry point

00:40:09,869 --> 00:40:15,569
of DT yeah yeah so then there's the

00:40:14,190 --> 00:40:18,890
library portion that has to be included

00:40:15,569 --> 00:40:22,170
in the software as well if I may offer

00:40:18,890 --> 00:40:22,819
since I have the mic hey you're talking

00:40:22,170 --> 00:40:26,039
about

00:40:22,819 --> 00:40:28,579
it's zephyr versus linux we we think of

00:40:26,039 --> 00:40:30,900
it in the linux world as being you know

00:40:28,579 --> 00:40:32,609
reconfigurable and and making use of

00:40:30,900 --> 00:40:34,230
that but how often are you going to take

00:40:32,609 --> 00:40:36,089
one of these small footprint devices and

00:40:34,230 --> 00:40:38,789
really truly reconfigure it completely

00:40:36,089 --> 00:40:40,650
radically without reloading it and

00:40:38,789 --> 00:40:43,220
that's that's what you're talking about

00:40:40,650 --> 00:40:43,220
and I

00:41:00,800 --> 00:41:08,670
so say you have a product line in which

00:41:05,220 --> 00:41:10,380
you have like very basic mid line

00:41:08,670 --> 00:41:15,990
advanced hardware they have different

00:41:10,380 --> 00:41:17,190
peripherals if you're using the Linux

00:41:15,990 --> 00:41:18,750
kernel approach then you could have

00:41:17,190 --> 00:41:28,380
different device trees on each of them

00:41:18,750 --> 00:41:31,320
in a common kernel actually um when we

00:41:28,380 --> 00:41:33,300
went from a dot out to elf elf was able

00:41:31,320 --> 00:41:34,860
to do much better dynamic linking that

00:41:33,300 --> 00:41:37,500
doesn't mean static linking went away

00:41:34,860 --> 00:41:40,260
this information has to live somewhere

00:41:37,500 --> 00:41:42,030
having it in device trees so that it's

00:41:40,260 --> 00:41:44,580
in the same format the Linux kernel is

00:41:42,030 --> 00:41:46,560
using moving towards a common standard

00:41:44,580 --> 00:41:48,810
for representing this information is

00:41:46,560 --> 00:42:00,390
good even if you are then going to

00:41:48,810 --> 00:42:01,620
statically link the result I think the

00:42:00,390 --> 00:42:03,480
goals of the project are different right

00:42:01,620 --> 00:42:05,580
I mean it's there's a goal in Linux to

00:42:03,480 --> 00:42:08,190
have a single image which can run on

00:42:05,580 --> 00:42:10,050
multiple machines and that's not a goal

00:42:08,190 --> 00:42:12,120
of Zephyr right you're just compiling an

00:42:10,050 --> 00:42:13,350
image to run on a single platform so

00:42:12,120 --> 00:42:16,430
it's just like an existentially

00:42:13,350 --> 00:42:16,430
different goal yeah

00:42:23,510 --> 00:42:29,020
any other questions pretty good

00:42:26,600 --> 00:42:29,020
discussion

00:42:33,430 --> 00:42:41,570
one time how how realistic so you're

00:42:37,580 --> 00:42:44,590
expecting or I interpreted and what you

00:42:41,570 --> 00:42:47,420
said as oh the vendor is going to supply

00:42:44,590 --> 00:42:51,170
the device tree or you know the guts of

00:42:47,420 --> 00:42:53,930
what it's needed and yet I think about

00:42:51,170 --> 00:42:57,590
the hundreds if not thousands of

00:42:53,930 --> 00:42:59,180
variations of him zero and m3 and m4 and

00:42:57,590 --> 00:43:02,390
that's just rather just talking about

00:42:59,180 --> 00:43:07,160
ARM Cortex yep not you know other

00:43:02,390 --> 00:43:09,140
architectures right I I have a hard time

00:43:07,160 --> 00:43:11,540
seeing that happening and I think

00:43:09,140 --> 00:43:14,060
there's gonna be more hacking of device

00:43:11,540 --> 00:43:16,790
to even it might expect

00:43:14,060 --> 00:43:19,880
yeah the insanity of hand doing it may

00:43:16,790 --> 00:43:22,430
go on for a little while but as I see it

00:43:19,880 --> 00:43:29,990
the vendor the sock vendors are already

00:43:22,430 --> 00:43:32,600
generating sims's yeah you did I that

00:43:29,990 --> 00:43:33,740
term to encompass all of them but when

00:43:32,600 --> 00:43:35,930
you're talking about an M zero you're

00:43:33,740 --> 00:43:40,220
right I mean it's like it's it's a

00:43:35,930 --> 00:43:43,250
microcontroller so yeah so let me I

00:43:40,220 --> 00:43:44,990
should just say microcontrollers the

00:43:43,250 --> 00:43:47,840
vendors already generating sims's and I

00:43:44,990 --> 00:43:51,880
think that's true across all vendors are

00:43:47,840 --> 00:43:56,030
there any vendors that don't yeah yeah

00:43:51,880 --> 00:43:59,120
yeah so to me it's like if there's

00:43:56,030 --> 00:44:01,280
already a database that they've pulled

00:43:59,120 --> 00:44:03,680
this information from it's very very

00:44:01,280 --> 00:44:06,530
easy to just regenerate that output in a

00:44:03,680 --> 00:44:07,760
slightly different format and if they

00:44:06,530 --> 00:44:11,600
can get their head around that it

00:44:07,760 --> 00:44:12,710
becomes very easy yes it's probably

00:44:11,600 --> 00:44:15,950
gonna be a little bit of a discussion

00:44:12,710 --> 00:44:18,680
with these companies but you know device

00:44:15,950 --> 00:44:21,010
trees new to Zephyr so people are gonna

00:44:18,680 --> 00:44:22,930
have to wrap their head around that

00:44:21,010 --> 00:44:24,940
a lot of people haven't had exposure to

00:44:22,930 --> 00:44:27,910
it they either have lived in the

00:44:24,940 --> 00:44:29,440
microcontroller world solely there are

00:44:27,910 --> 00:44:31,360
very few people out that I've actually

00:44:29,440 --> 00:44:33,340
found that I've actually encountered it

00:44:31,360 --> 00:44:35,560
before so it's been a learning curve for

00:44:33,340 --> 00:44:39,810
them it's also been a learning curve for

00:44:35,560 --> 00:44:42,370
me to try to explain device creaks so I

00:44:39,810 --> 00:44:46,800
think you had something Paul yeah okay

00:44:42,370 --> 00:44:50,110
so I'll say maintain there's other

00:44:46,800 --> 00:44:52,180
architectures in surfer besides our who

00:44:50,110 --> 00:44:54,700
expressed interest in useful device

00:44:52,180 --> 00:44:57,190
three already currently it seems to be

00:44:54,700 --> 00:44:58,960
our wallet yeah so x86 I think it's

00:44:57,190 --> 00:45:01,150
gonna be the next one so I need to we're

00:44:58,960 --> 00:45:03,280
actually talk to one of the Intel guys

00:45:01,150 --> 00:45:06,100
about that and kind of help facilitate

00:45:03,280 --> 00:45:11,160
that a little bit okay great in general

00:45:06,100 --> 00:45:16,120
our old met before for either one

00:45:11,160 --> 00:45:27,100
roadmap fulfills a book 1.7 was done

00:45:16,120 --> 00:45:29,770
because Samson right into one yeah so I

00:45:27,100 --> 00:45:31,150
think the next for the next point

00:45:29,770 --> 00:45:34,390
release we definitely need to get the

00:45:31,150 --> 00:45:37,930
clock gating pen control GPIO stuff

00:45:34,390 --> 00:45:40,000
built in it's also my view that we need

00:45:37,930 --> 00:45:42,520
to pull in like maybe the I squared C

00:45:40,000 --> 00:45:44,740
and spy some of the other serial

00:45:42,520 --> 00:45:47,020
interface stuff start to convert some of

00:45:44,740 --> 00:45:49,950
those drivers over and then it just kind

00:45:47,020 --> 00:45:51,760
of starts you know grows out from there

00:45:49,950 --> 00:45:53,710
there'll be some other interesting

00:45:51,760 --> 00:45:55,870
things like had someone talk to me a

00:45:53,710 --> 00:45:57,130
little bit about sensors so we might

00:45:55,870 --> 00:45:58,330
need to think about that because that's

00:45:57,130 --> 00:46:02,050
actually a pretty important piece if we

00:45:58,330 --> 00:46:05,620
can start to start to work off some of

00:46:02,050 --> 00:46:09,060
those definitely at least figure out a

00:46:05,620 --> 00:46:09,060
Almo format for them

00:46:15,190 --> 00:46:18,060
anyone else

00:46:21,400 --> 00:46:30,750
okay I guess that's it

00:46:24,400 --> 00:46:30,750

YouTube URL: https://www.youtube.com/watch?v=eOZ0_pNU5vg


