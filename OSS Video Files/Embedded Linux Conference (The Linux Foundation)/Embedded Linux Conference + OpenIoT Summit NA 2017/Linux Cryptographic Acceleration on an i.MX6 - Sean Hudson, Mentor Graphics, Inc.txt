Title: Linux Cryptographic Acceleration on an i.MX6 - Sean Hudson, Mentor Graphics, Inc
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Linux Cryptographic Acceleration on an i.MX6 - Sean Hudson, Mentor Graphics, Inc

The recent hack of internet connected cameras highlights the need to secure IoT devices. This effort will require robust encryption. Luckily, some SoC devices provide cryptographic accelerators that can help. This talk examines the process of enabling the cryptographic accelerator on the i.MX6, called the CAAM. During the talk, I will discuss ways to connect userspace to the CAAM. Further, I will talk about the relative performance of the different approaches.

About Sean Hudson
I am an embedded Linux architect at Mentor Graphics. I have worked on embedded devices since 1996 and with embedded Linux since 2006. Most notably, I have been involved with the Yocto Project since it's public announcement in 2010, have served on the YP Advisory Board for two different companies, and am currently a member of the OpenEmbedded Board. I am also part of the devicetree.org Technical Steering Committee.
Captions: 
	00:00:00,020 --> 00:00:04,230
applause for our technical support guys

00:00:02,879 --> 00:00:05,960
here

00:00:04,230 --> 00:00:07,859
[Applause]

00:00:05,960 --> 00:00:10,650
sorry we're getting started just a few

00:00:07,859 --> 00:00:14,730
minutes late but that's okay people are

00:00:10,650 --> 00:00:15,870
coming back from lunch anyway Linux

00:00:14,730 --> 00:00:19,010
cryptography or cryptographic

00:00:15,870 --> 00:00:21,869
acceleration on an imx6

00:00:19,010 --> 00:00:24,779
if you are not here for that session

00:00:21,869 --> 00:00:26,250
you're in the wrong room hi my name is

00:00:24,779 --> 00:00:31,170
Sean Hudson I'm an embedded Linux

00:00:26,250 --> 00:00:32,700
architect at Mentor Graphics my vanity

00:00:31,170 --> 00:00:35,300
slide here you know I've been working

00:00:32,700 --> 00:00:37,469
with embedded stuff for a while now a

00:00:35,300 --> 00:00:38,940
particular node is in the open source

00:00:37,469 --> 00:00:43,829
I've been involved with the octave

00:00:38,940 --> 00:00:46,530
project for about seven years and I've

00:00:43,829 --> 00:00:49,140
been involved with open embedded as a

00:00:46,530 --> 00:00:52,920
member of the board for how many years

00:00:49,140 --> 00:00:57,989
now before something like that something

00:00:52,920 --> 00:00:59,760
like that so one thing I have to make

00:00:57,989 --> 00:01:02,550
sure and do is I have to thank somebody

00:00:59,760 --> 00:01:05,610
who is not here co-worker of mine named

00:01:02,550 --> 00:01:07,710
Wade Farnsworth he actually did a lot of

00:01:05,610 --> 00:01:08,880
the grunt work related to this and the

00:01:07,710 --> 00:01:11,490
data gathering and this kind of stuff

00:01:08,880 --> 00:01:13,020
but since he wasn't unable to be here

00:01:11,490 --> 00:01:18,060
I'm gonna be the one that's presenting

00:01:13,020 --> 00:01:20,189
on it with that in mind my outline is a

00:01:18,060 --> 00:01:22,229
little bit messed up I had planned to

00:01:20,189 --> 00:01:23,729
redo it and I didn't I ran out of time

00:01:22,229 --> 00:01:24,710
so I'm gonna actually kind of blow

00:01:23,729 --> 00:01:29,310
through this real fast

00:01:24,710 --> 00:01:32,640
IMed well verbally I basically I'm gonna

00:01:29,310 --> 00:01:34,439
go through real quickly some basics of

00:01:32,640 --> 00:01:36,780
cryptography I'm going to talk about

00:01:34,439 --> 00:01:38,759
some of the ways that we get access to

00:01:36,780 --> 00:01:42,420
hardware acceleration through the kernel

00:01:38,759 --> 00:01:46,590
and specifically what we did with the

00:01:42,420 --> 00:01:48,420
imx6 to make that happen so some of

00:01:46,590 --> 00:01:51,140
these things are still applicable but

00:01:48,420 --> 00:01:51,140
they're a little out of order

00:01:52,490 --> 00:01:59,030
I know everybody's sleepy after lunch I

00:01:55,430 --> 00:02:00,799
tend to thrive best when I have people

00:01:59,030 --> 00:02:02,509
who are engaged in the presentation so I

00:02:00,799 --> 00:02:05,119
will pause frequently to make sure

00:02:02,509 --> 00:02:06,920
everybody's still awake and I will try

00:02:05,119 --> 00:02:09,319
and crack jokes but they're engineered

00:02:06,920 --> 00:02:13,760
jokes so you you take that for what it's

00:02:09,319 --> 00:02:16,280
worth so this the best kind so this

00:02:13,760 --> 00:02:18,260
presentation is basically geared towards

00:02:16,280 --> 00:02:21,140
some pretty specific things and I want

00:02:18,260 --> 00:02:24,650
to call them out it's about using

00:02:21,140 --> 00:02:26,299
cryptographic Hardware ok the

00:02:24,650 --> 00:02:28,760
acceleration that that provides from

00:02:26,299 --> 00:02:31,100
user space and the reason why that's

00:02:28,760 --> 00:02:33,049
important hopefully will become evident

00:02:31,100 --> 00:02:34,700
but it has to do with the fact that I'm

00:02:33,049 --> 00:02:36,920
not gonna spend a whole lot of time on

00:02:34,700 --> 00:02:38,900
kernel internals I'm not gonna spend a

00:02:36,920 --> 00:02:40,160
whole lot of time on drivers I'm going

00:02:38,900 --> 00:02:41,870
to talk about putting together this

00:02:40,160 --> 00:02:45,040
whole stack so that from user space you

00:02:41,870 --> 00:02:48,200
can actually make use of this hardware

00:02:45,040 --> 00:02:50,720
this focus really came from we were

00:02:48,200 --> 00:02:53,569
doing some pilot work to figure out if

00:02:50,720 --> 00:02:56,360
we could accelerate some cryptographic

00:02:53,569 --> 00:02:59,570
work on the imx6 so that's the genesis

00:02:56,360 --> 00:03:02,209
of this talk a lot of this is generally

00:02:59,570 --> 00:03:03,500
applicable because of the fact that

00:03:02,209 --> 00:03:06,620
we're trying to go from user space all

00:03:03,500 --> 00:03:08,150
the way down to hardware so I was asked

00:03:06,620 --> 00:03:11,150
to try and make sure that I cover this

00:03:08,150 --> 00:03:13,190
in a fairly general way but it does come

00:03:11,150 --> 00:03:18,170
primarily from the imx6 so I'm gonna try

00:03:13,190 --> 00:03:19,489
and walk that way so first off you know

00:03:18,170 --> 00:03:21,640
I don't know how much experience there

00:03:19,489 --> 00:03:25,100
is with cryptography in general here I

00:03:21,640 --> 00:03:28,549
wanted to make sure that we're clear on

00:03:25,100 --> 00:03:31,220
some basics cryptography is pretty

00:03:28,549 --> 00:03:32,959
simple at least in principle and this is

00:03:31,220 --> 00:03:35,299
my own wording here you're trying to

00:03:32,959 --> 00:03:37,100
take some piece of information a message

00:03:35,299 --> 00:03:39,139
you're trying to send it from one point

00:03:37,100 --> 00:03:41,389
to another and make sure that a guy in

00:03:39,139 --> 00:03:43,790
the middle can't understand what that

00:03:41,389 --> 00:03:47,239
message is or certainly can't understand

00:03:43,790 --> 00:03:49,400
it in a reasonable amount of time you

00:03:47,239 --> 00:03:51,620
define what reasonable is so there's a

00:03:49,400 --> 00:03:55,790
lot of fluidity in that definition but

00:03:51,620 --> 00:03:58,459
that's it in in simplistic terms moving

00:03:55,790 --> 00:04:01,040
beyond that just in general most

00:03:58,459 --> 00:04:03,680
cryptographic solutions and particularly

00:04:01,040 --> 00:04:06,590
most cryptographic algorithms rely on an

00:04:03,680 --> 00:04:11,930
asymmetry in terms of the complexity

00:04:06,590 --> 00:04:14,510
this is basically critical both in terms

00:04:11,930 --> 00:04:17,660
of the way that we we ensure that that

00:04:14,510 --> 00:04:20,799
reasonable time doesn't occur but also

00:04:17,660 --> 00:04:23,330
in terms of the the impact is for us so

00:04:20,799 --> 00:04:25,639
what this essentially means is that we

00:04:23,330 --> 00:04:26,870
have brute-force attacks brute force

00:04:25,639 --> 00:04:28,340
attacks or where you're basically trying

00:04:26,870 --> 00:04:33,980
everything in the key space in order to

00:04:28,340 --> 00:04:35,600
decrypt the message that was sent so it

00:04:33,980 --> 00:04:37,510
shouldn't be feasible to take a

00:04:35,600 --> 00:04:41,540
brute-force approach on any algorithm

00:04:37,510 --> 00:04:43,570
that again will result in a reasonable

00:04:41,540 --> 00:04:46,280
amount of time before you can find a

00:04:43,570 --> 00:04:48,320
specific solution now the reasonable

00:04:46,280 --> 00:04:50,360
also moves over time because of the

00:04:48,320 --> 00:04:55,030
capacity of our hardware to actually

00:04:50,360 --> 00:04:59,780
calculate keys and try them things out

00:04:55,030 --> 00:05:01,130
yeah and in fact and I talked about in

00:04:59,780 --> 00:05:03,800
terms of cheapness here encryption and

00:05:01,130 --> 00:05:07,870
decryption should be relatively cheap in

00:05:03,800 --> 00:05:07,870
terms of computation in terms of time

00:05:08,020 --> 00:05:14,360
right so basically you want to be you

00:05:11,870 --> 00:05:15,530
want to take when you pass this through

00:05:14,360 --> 00:05:17,419
a transform you want to have the

00:05:15,530 --> 00:05:20,060
information very difficult to actually

00:05:17,419 --> 00:05:22,220
rip apart the using brute force but you

00:05:20,060 --> 00:05:24,830
still want it to be reasonable to be

00:05:22,220 --> 00:05:27,289
able to produce that ciphertext if you

00:05:24,830 --> 00:05:30,380
take ten years to take to convert a

00:05:27,289 --> 00:05:32,419
document into ciphertext then it's

00:05:30,380 --> 00:05:33,760
useless to you because the applicability

00:05:32,419 --> 00:05:36,110
of the data is gone

00:05:33,760 --> 00:05:38,060
so and this goes back to what you're

00:05:36,110 --> 00:05:42,289
saying the I think you were saying that

00:05:38,060 --> 00:05:45,500
as this model continues to expand that

00:05:42,289 --> 00:05:47,169
means that the computational needs for

00:05:45,500 --> 00:05:50,270
for both the encryption and decryption

00:05:47,169 --> 00:05:51,889
also go up yeah we want to make sure

00:05:50,270 --> 00:05:53,930
that it's very difficult here but in

00:05:51,889 --> 00:05:56,120
order to make it reasonably difficult

00:05:53,930 --> 00:05:58,970
here we still have to put forth some

00:05:56,120 --> 00:06:01,850
effort in in terms of the encryption and

00:05:58,970 --> 00:06:03,650
decryption this is all pretty basic

00:06:01,850 --> 00:06:05,240
stuff again I just want to cover it real

00:06:03,650 --> 00:06:09,500
quick at a high level because it's going

00:06:05,240 --> 00:06:12,919
to inform what we do later a little bit

00:06:09,500 --> 00:06:14,539
more about this so the basics of

00:06:12,919 --> 00:06:16,220
cryptography as I said are pretty simple

00:06:14,539 --> 00:06:17,340
but what we begin to do with basic

00:06:16,220 --> 00:06:19,590
encryption

00:06:17,340 --> 00:06:24,389
is pretty cool at least in my opinion

00:06:19,590 --> 00:06:25,860
you've got two major pieces that most

00:06:24,389 --> 00:06:27,530
basic encryption requires you got a

00:06:25,860 --> 00:06:29,699
strong algorithm something like a EES

00:06:27,530 --> 00:06:32,160
and then you've got a strong key that

00:06:29,699 --> 00:06:35,490
comes out of a pretty large key space

00:06:32,160 --> 00:06:39,720
that goes to the whole brute force

00:06:35,490 --> 00:06:41,790
attack thing so if once we have those in

00:06:39,720 --> 00:06:43,260
place the basic encryption is going to

00:06:41,790 --> 00:06:46,139
enable us to do things like tamper

00:06:43,260 --> 00:06:48,240
detection it is very basic we're looking

00:06:46,139 --> 00:06:51,150
to see if somebody modified a message we

00:06:48,240 --> 00:06:52,919
will use this more for hashing than than

00:06:51,150 --> 00:06:54,620
anything else but it also is used in

00:06:52,919 --> 00:06:56,790
boot processes and things like that

00:06:54,620 --> 00:06:58,169
secure storage of course that's where

00:06:56,790 --> 00:07:00,450
you're just taking the information and

00:06:58,169 --> 00:07:03,120
keeping it secure this one's a fun one

00:07:00,450 --> 00:07:06,479
too now we can actually take keys

00:07:03,120 --> 00:07:09,389
initially ciphers were just passed you

00:07:06,479 --> 00:07:10,979
know I think this is the key and that

00:07:09,389 --> 00:07:13,110
limits its applicability but once you

00:07:10,979 --> 00:07:14,910
have some of these algorithm and

00:07:13,110 --> 00:07:17,639
algorithms in place now you can do some

00:07:14,910 --> 00:07:21,120
key exchange in a secure way knowing

00:07:17,639 --> 00:07:24,380
that somebody in the middle can accept

00:07:21,120 --> 00:07:27,000
them so all of these systems start being

00:07:24,380 --> 00:07:30,300
built up on top of just the basic core

00:07:27,000 --> 00:07:31,979
encryption secure identification

00:07:30,300 --> 00:07:34,080
authorization this becomes real

00:07:31,979 --> 00:07:36,120
important for IOT if you've got

00:07:34,080 --> 00:07:38,250
thousands of these little nodes floating

00:07:36,120 --> 00:07:41,220
around in your home you need to know

00:07:38,250 --> 00:07:42,270
that the actual endpoint that you're

00:07:41,220 --> 00:07:43,349
talking to gateway that you're talking

00:07:42,270 --> 00:07:45,479
to is the one that you're supposed to be

00:07:43,349 --> 00:07:46,860
talking to if you're receiving an update

00:07:45,479 --> 00:07:49,169
you want to make sure and that goes back

00:07:46,860 --> 00:07:50,669
to to tamper detection and some of the

00:07:49,169 --> 00:07:54,840
secure storage you want to make sure

00:07:50,669 --> 00:07:55,950
that you know for sure that you're

00:07:54,840 --> 00:07:58,260
talking to the right person and to the

00:07:55,950 --> 00:08:01,830
right end node I say person right

00:07:58,260 --> 00:08:06,180
computing device like many engineers I

00:08:01,830 --> 00:08:08,010
tend to confuse people and computers so

00:08:06,180 --> 00:08:11,330
also secure execution this goes back to

00:08:08,010 --> 00:08:15,360
what I was talking about as far as the

00:08:11,330 --> 00:08:17,310
having the the secure boot process where

00:08:15,360 --> 00:08:19,260
you know we're running an image that is

00:08:17,310 --> 00:08:22,380
what you think it was that goes back to

00:08:19,260 --> 00:08:23,010
also tamper detection so this is kind of

00:08:22,380 --> 00:08:25,350
the basics

00:08:23,010 --> 00:08:29,160
this one is one that

00:08:25,350 --> 00:08:30,810
I have to say over and over I I don't it

00:08:29,160 --> 00:08:33,000
surprises me how many people certainly

00:08:30,810 --> 00:08:34,349
laypeople don't get this but even a fair

00:08:33,000 --> 00:08:37,260
number of Engineers don't seem to get

00:08:34,349 --> 00:08:39,120
this you can take an absolutely strong

00:08:37,260 --> 00:08:42,660
algorithm apply it in the wrong way and

00:08:39,120 --> 00:08:45,810
have zero security so just because you

00:08:42,660 --> 00:08:47,880
have a strong cryptographic solution in

00:08:45,810 --> 00:08:50,760
terms of an algorithm which we tend to

00:08:47,880 --> 00:08:53,280
to overlay that it does not mean you

00:08:50,760 --> 00:08:55,290
have strong security so don't think that

00:08:53,280 --> 00:08:57,330
just because you applied a strong

00:08:55,290 --> 00:08:59,730
algorithm that you're safe we all know

00:08:57,330 --> 00:09:01,140
about how secure Wi-Fi is and some of

00:08:59,730 --> 00:09:04,230
the initial standards around that and

00:09:01,140 --> 00:09:07,080
WEP was a victim of not as strong and

00:09:04,230 --> 00:09:09,060
not a weak algorithm it actually had a

00:09:07,080 --> 00:09:11,910
pretty decent strong algorithm it was

00:09:09,060 --> 00:09:16,340
just miss applied and the key the key

00:09:11,910 --> 00:09:19,590
space was actually very poorly defined

00:09:16,340 --> 00:09:21,870
so moving on then so we were talking

00:09:19,590 --> 00:09:24,210
about cryptographic acceleration I said

00:09:21,870 --> 00:09:25,830
that computational complexity is driving

00:09:24,210 --> 00:09:27,090
us to look for hardware acceleration

00:09:25,830 --> 00:09:28,920
there's a couple of different

00:09:27,090 --> 00:09:30,000
classifications if you go out there and

00:09:28,920 --> 00:09:32,700
you look for these you're going to find

00:09:30,000 --> 00:09:33,870
a lot of there's different types of

00:09:32,700 --> 00:09:36,630
hardware to do cryptographic

00:09:33,870 --> 00:09:38,820
acceleration this one is one that's

00:09:36,630 --> 00:09:41,130
pretty easy I use the example of smart

00:09:38,820 --> 00:09:42,780
cards standalone device it takes some

00:09:41,130 --> 00:09:45,480
sort of information in does a

00:09:42,780 --> 00:09:48,210
transformation inside and then what it

00:09:45,480 --> 00:09:50,580
spits back out is is plaintext again so

00:09:48,210 --> 00:09:51,870
it usually is used in kind of like the

00:09:50,580 --> 00:09:54,030
smart card world where you're

00:09:51,870 --> 00:09:55,650
identifying a particular device or

00:09:54,030 --> 00:09:58,260
you're identifying a particular person

00:09:55,650 --> 00:10:01,560
in this case it's carrying it there's

00:09:58,260 --> 00:10:04,230
also this used just in in the middle of

00:10:01,560 --> 00:10:07,410
other systems it's not as interesting

00:10:04,230 --> 00:10:10,170
for us so but it's out there one of the

00:10:07,410 --> 00:10:12,210
more interesting ones that has been

00:10:10,170 --> 00:10:14,220
around for a while are these instruction

00:10:12,210 --> 00:10:18,300
set extensions so you take an existing

00:10:14,220 --> 00:10:21,660
CPU and you add some extensions to their

00:10:18,300 --> 00:10:23,340
instruction set and now built on top of

00:10:21,660 --> 00:10:27,750
that slightly CPU you suddenly have

00:10:23,340 --> 00:10:30,360
these cryptographic operations that can

00:10:27,750 --> 00:10:31,800
happen very fast because these are built

00:10:30,360 --> 00:10:33,270
in the CPU it's going to change the way

00:10:31,800 --> 00:10:35,240
that we access them I'll talk about that

00:10:33,270 --> 00:10:37,879
a little bit more in a minute

00:10:35,240 --> 00:10:39,819
the primary area for interest of this

00:10:37,879 --> 00:10:43,550
presentation though was in separate

00:10:39,819 --> 00:10:46,660
coprocessors there's a lot of different

00:10:43,550 --> 00:10:48,740
ways that these things can can connect

00:10:46,660 --> 00:10:50,660
you can actually have a completely

00:10:48,740 --> 00:10:52,670
separate processor it's got a different

00:10:50,660 --> 00:10:54,680
diet or a different package and it's

00:10:52,670 --> 00:10:56,120
connected via an external bus some

00:10:54,680 --> 00:10:59,420
examples of this could also be something

00:10:56,120 --> 00:11:02,899
like a PCI card that's sitting in your

00:10:59,420 --> 00:11:06,589
bus and a server just offloads some of

00:11:02,899 --> 00:11:08,149
these cryptographic operations an

00:11:06,589 --> 00:11:10,100
example of this type of module is

00:11:08,149 --> 00:11:13,850
something called a trusted computing

00:11:10,100 --> 00:11:17,480
module the trusted computing module is

00:11:13,850 --> 00:11:19,339
actually it's a standard it's not an

00:11:17,480 --> 00:11:21,529
actual implementation so when we talk

00:11:19,339 --> 00:11:23,389
about a TPM there's different

00:11:21,529 --> 00:11:25,309
implementations of this but it's a

00:11:23,389 --> 00:11:27,050
standard that defines a separate

00:11:25,309 --> 00:11:29,480
processor that does all of these types

00:11:27,050 --> 00:11:31,309
of things it goes well beyond just

00:11:29,480 --> 00:11:36,110
cryptographic acceleration so I'm going

00:11:31,309 --> 00:11:38,389
to gloss over that but the TCG actually

00:11:36,110 --> 00:11:42,050
manages that standard this is primarily

00:11:38,389 --> 00:11:45,199
found in x86 platforms I have heard that

00:11:42,050 --> 00:11:51,889
there are some TPM modules available in

00:11:45,199 --> 00:11:57,290
arm but I didn't yeah yeah and that's my

00:11:51,889 --> 00:11:59,499
general feedback that I've seen I'm

00:11:57,290 --> 00:11:59,499
sorry

00:11:59,950 --> 00:12:03,050
you know it I'm not going to talk about

00:12:02,030 --> 00:12:05,060
trust zone

00:12:03,050 --> 00:12:06,800
the question was am I gonna cover arm

00:12:05,060 --> 00:12:09,380
trust zone that's kind of a slightly

00:12:06,800 --> 00:12:11,630
different animal it does work well with

00:12:09,380 --> 00:12:13,760
this and the imx6 does actually have

00:12:11,630 --> 00:12:17,090
trust owned but it's beyond the scope of

00:12:13,760 --> 00:12:18,380
what I was covering here and this is the

00:12:17,090 --> 00:12:21,440
example I was talking about as far as

00:12:18,380 --> 00:12:24,290
offload this one's the one down here at

00:12:21,440 --> 00:12:27,080
the bottom that is the most interesting

00:12:24,290 --> 00:12:29,840
for me for this presentation because of

00:12:27,080 --> 00:12:31,670
the fact that the imx6 has a crypto

00:12:29,840 --> 00:12:33,620
block built into the SOC so it's on the

00:12:31,670 --> 00:12:35,060
diets inside the package yes it's

00:12:33,620 --> 00:12:36,920
technically got a little bus in there

00:12:35,060 --> 00:12:41,720
but for all practical purposes we

00:12:36,920 --> 00:12:46,790
consider it to be a single device so

00:12:41,720 --> 00:12:49,760
let's take a look at that so the NXP mx6

00:12:46,790 --> 00:12:51,320
it's a mouthful here the SOC has a

00:12:49,760 --> 00:12:54,110
cryptographic acceleration and

00:12:51,320 --> 00:12:57,560
disturbance module called a cam and it

00:12:54,110 --> 00:12:58,670
provides a few things it's going to give

00:12:57,560 --> 00:13:00,080
you a hardware implementation of

00:12:58,670 --> 00:13:01,760
cryptographic functions that's the one

00:13:00,080 --> 00:13:03,770
that we're most interested in for this

00:13:01,760 --> 00:13:05,210
it does include several ciphers I'm not

00:13:03,770 --> 00:13:07,310
gonna list them all you can go look at a

00:13:05,210 --> 00:13:09,350
at a technical reference manual if

00:13:07,310 --> 00:13:11,540
you're curious it also provides secure

00:13:09,350 --> 00:13:13,130
memory again these are functions

00:13:11,540 --> 00:13:16,250
including security module and

00:13:13,130 --> 00:13:18,290
cryptographic authentication I'm not

00:13:16,250 --> 00:13:20,150
really going to touch much on them

00:13:18,290 --> 00:13:21,770
they're important they're certainly part

00:13:20,150 --> 00:13:23,000
of your security system but it's not

00:13:21,770 --> 00:13:25,490
what I was focused on with this

00:13:23,000 --> 00:13:27,260
presentation I would encourage you to go

00:13:25,490 --> 00:13:31,010
and figure out what these things are if

00:13:27,260 --> 00:13:32,630
you don't know one last thing on that

00:13:31,010 --> 00:13:35,540
the random number generator

00:13:32,630 --> 00:13:37,160
the random number generator is kind of

00:13:35,540 --> 00:13:39,200
of interest because that also affects

00:13:37,160 --> 00:13:40,700
how you can generate keys and they're

00:13:39,200 --> 00:13:42,440
just found out something really cool

00:13:40,700 --> 00:13:45,350
which I'm gonna throw in here which is

00:13:42,440 --> 00:13:47,600
an external device do you remember what

00:13:45,350 --> 00:13:51,110
it was called was it you that was no it

00:13:47,600 --> 00:13:54,790
was being the chaos key so it's

00:13:51,110 --> 00:13:54,790
basically an external device for

00:13:56,949 --> 00:14:01,399
yeah it generates entropy that you can

00:13:59,509 --> 00:14:02,839
then use to generate random numbers and

00:14:01,399 --> 00:14:05,420
this becomes real important when you're

00:14:02,839 --> 00:14:07,850
trying to generate true random Keys that

00:14:05,420 --> 00:14:11,269
you can use especially for transactional

00:14:07,850 --> 00:14:12,290
exchange of other asymmetric keys so if

00:14:11,269 --> 00:14:14,060
you don't have a good source of

00:14:12,290 --> 00:14:17,600
randomness which that was the downfall

00:14:14,060 --> 00:14:19,490
of WEP then you're liable to be able to

00:14:17,600 --> 00:14:22,310
be brute force because you cut the key

00:14:19,490 --> 00:14:26,089
space down so small that you can attack

00:14:22,310 --> 00:14:28,279
it effectively and if I'm babbling we'll

00:14:26,089 --> 00:14:29,600
just move on you don't understand what

00:14:28,279 --> 00:14:31,790
I'm saying cuz it's not that important

00:14:29,600 --> 00:14:34,699
to this presentation so this is more

00:14:31,790 --> 00:14:36,860
important there's a basic enablement

00:14:34,699 --> 00:14:38,990
that you need to do this is pretty much

00:14:36,860 --> 00:14:40,699
just to show you and forget this is what

00:14:38,990 --> 00:14:43,730
you need to do to enable the cam on your

00:14:40,699 --> 00:14:45,230
kernel there's a lot of different

00:14:43,730 --> 00:14:47,149
options here some of these you can kind

00:14:45,230 --> 00:14:49,790
of pick out you know random number

00:14:47,149 --> 00:14:50,980
generator hashing functions and things

00:14:49,790 --> 00:14:53,389
like this

00:14:50,980 --> 00:14:54,860
essentially for our purposes this is

00:14:53,389 --> 00:14:57,399
just what you need to enable build your

00:14:54,860 --> 00:15:02,180
kernel and then you've got cam support

00:14:57,399 --> 00:15:05,089
yes and this is this was as of the for

00:15:02,180 --> 00:15:08,300
one kernel so this is already you know

00:15:05,089 --> 00:15:10,160
what nine kernels back I can't say with

00:15:08,300 --> 00:15:17,180
any certainty what is improved or

00:15:10,160 --> 00:15:19,399
regressed since then yeah well I mean

00:15:17,180 --> 00:15:22,160
basically enabling this is a building

00:15:19,399 --> 00:15:23,449
block that we we use this kernel and we

00:15:22,160 --> 00:15:29,990
use the cam function how I date to

00:15:23,449 --> 00:15:33,350
accelerate we didn't down to implement

00:15:29,990 --> 00:15:34,790
this this was done by freescale we may

00:15:33,350 --> 00:15:36,170
have helped them because mentor has a

00:15:34,790 --> 00:15:38,149
pretty deep relationship with with

00:15:36,170 --> 00:15:40,490
freescale but to my knowledge this was

00:15:38,149 --> 00:15:45,800
largely done internally it's at free

00:15:40,490 --> 00:15:47,629
scale so again the whole point this

00:15:45,800 --> 00:15:50,019
presentation is to how do we get

00:15:47,629 --> 00:15:52,519
cryptographic acceleration in user space

00:15:50,019 --> 00:15:54,290
so we now have at that bottom level

00:15:52,519 --> 00:15:57,290
we've got our hardware but how do we get

00:15:54,290 --> 00:15:58,879
to it so let's talk first about some of

00:15:57,290 --> 00:16:01,189
the different implementations there's a

00:15:58,879 --> 00:16:03,230
great presentation by by Marek out there

00:16:01,189 --> 00:16:04,850
a couple years ago that talks very

00:16:03,230 --> 00:16:06,740
similar this so I'm not gonna spend a

00:16:04,850 --> 00:16:09,050
lot of time on these but there's this is

00:16:06,740 --> 00:16:10,520
how you can get cryptography or

00:16:09,050 --> 00:16:13,100
cryptographic

00:16:10,520 --> 00:16:15,470
operations not really acceleration in

00:16:13,100 --> 00:16:17,360
your user space the first one is just a

00:16:15,470 --> 00:16:19,640
pure software implementation you

00:16:17,360 --> 00:16:21,530
literally just take CPU instructions you

00:16:19,640 --> 00:16:23,600
execute it like you would any other

00:16:21,530 --> 00:16:26,780
program there's some really good things

00:16:23,600 --> 00:16:27,830
to this it's very portable if you were

00:16:26,780 --> 00:16:30,260
especially if you're right in the sea

00:16:27,830 --> 00:16:31,910
and it supports an arbitrary set of our

00:16:30,260 --> 00:16:33,980
algorithms you can tweak it however you

00:16:31,910 --> 00:16:34,910
want very modifiable the usual stuff

00:16:33,980 --> 00:16:37,910
that comes with a software

00:16:34,910 --> 00:16:40,490
implementation unfortunately it does

00:16:37,910 --> 00:16:42,800
have a cost it's now I'm gonna contest

00:16:40,490 --> 00:16:45,550
on your CPU so you're gonna take a lot

00:16:42,800 --> 00:16:50,420
of cycles and I didn't put this up here

00:16:45,550 --> 00:16:51,920
but one sort of benefit to this is that

00:16:50,420 --> 00:16:53,420
it's all inside the CPU so you don't

00:16:51,920 --> 00:16:54,710
have a lot of bus traffic yes you're

00:16:53,420 --> 00:16:56,210
gonna have memory access and things like

00:16:54,710 --> 00:16:59,120
that but you're not going out across

00:16:56,210 --> 00:17:01,160
that external bus for instance one thing

00:16:59,120 --> 00:17:03,380
that is also drawback is a lot of times

00:17:01,160 --> 00:17:05,480
the CPUs general-purpose instruction set

00:17:03,380 --> 00:17:08,300
is not really optimized for this so it

00:17:05,480 --> 00:17:15,110
may not do this real efficiently or as

00:17:08,300 --> 00:17:17,570
efficiently as we would like so how

00:17:15,110 --> 00:17:19,130
about we talk about CPU instruction

00:17:17,570 --> 00:17:22,970
extensions so there's a little bit of a

00:17:19,130 --> 00:17:25,640
different a different look at it when

00:17:22,970 --> 00:17:27,160
you have a CPU that now actually does

00:17:25,640 --> 00:17:30,260
some of these Hardware things for you

00:17:27,160 --> 00:17:32,660
the thing about this though is while it

00:17:30,260 --> 00:17:33,920
makes use of hardware acceleration and

00:17:32,660 --> 00:17:37,850
it doesn't involve the kernel which is

00:17:33,920 --> 00:17:40,100
important you're limited to the set of

00:17:37,850 --> 00:17:44,000
algorithms that are supported so in the

00:17:40,100 --> 00:17:48,230
case of like the the Intel the Intel

00:17:44,000 --> 00:17:51,800
extensions I want to say yeah I think

00:17:48,230 --> 00:17:53,690
it's only right I think it's only 11

00:17:51,800 --> 00:17:56,900
instructions and then primarily it's a

00:17:53,690 --> 00:17:58,610
yes so you know it's like great for that

00:17:56,900 --> 00:18:00,290
but if you don't want to use AES you're

00:17:58,610 --> 00:18:02,800
kind of going back to software or

00:18:00,290 --> 00:18:02,800
something else

00:18:16,740 --> 00:18:21,010
yeah and that's and I don't even touch

00:18:19,420 --> 00:18:23,290
on that kind of thing because that blows

00:18:21,010 --> 00:18:24,730
all sorts of things out of the water one

00:18:23,290 --> 00:18:28,630
thing one thing just historically about

00:18:24,730 --> 00:18:31,780
AES yeah I mean when you have that kind

00:18:28,630 --> 00:18:34,420
of computing capability but AES was

00:18:31,780 --> 00:18:36,790
actually designed from the get-go in

00:18:34,420 --> 00:18:39,100
order to be Hardware efficient so it is

00:18:36,790 --> 00:18:40,179
a block cipher that from the from the

00:18:39,100 --> 00:18:42,580
start that was one of the requirements

00:18:40,179 --> 00:18:44,260
and so that's the reason why you see it

00:18:42,580 --> 00:18:49,720
as very popular as far as being

00:18:44,260 --> 00:18:52,059
implemented in hardware so these are

00:18:49,720 --> 00:18:54,640
great if you happen to have you know a

00:18:52,059 --> 00:18:55,929
CPU with these and you happen to need a

00:18:54,640 --> 00:18:56,410
particular algorithm that works great

00:18:55,929 --> 00:18:58,540
for you

00:18:56,410 --> 00:19:01,120
software as we as we've said you know

00:18:58,540 --> 00:19:03,190
has some great benefit to but also has

00:19:01,120 --> 00:19:04,270
some drawbacks but what do you do the

00:19:03,190 --> 00:19:06,100
rest of the time maybe you have a

00:19:04,270 --> 00:19:08,350
hardware accelerator like you have the

00:19:06,100 --> 00:19:10,840
cameras only imx6 and you want to make

00:19:08,350 --> 00:19:12,400
use of it but you also don't want to

00:19:10,840 --> 00:19:14,320
have to write everything yourself so

00:19:12,400 --> 00:19:17,350
that's where the kernel API is from user

00:19:14,320 --> 00:19:19,770
space and come in and I'm going to come

00:19:17,350 --> 00:19:19,770
back to that

00:19:33,419 --> 00:19:37,499
no I'm not I mean that is something that

00:19:35,969 --> 00:19:38,459
is very important the question was if I

00:19:37,499 --> 00:19:40,499
was going to be talking about key

00:19:38,459 --> 00:19:43,229
protection techniques and particularly

00:19:40,499 --> 00:19:46,259
in a software contact so sorry so in a

00:19:43,229 --> 00:19:48,269
software implementation there there's so

00:19:46,259 --> 00:19:49,320
much to security I was being very

00:19:48,269 --> 00:19:50,639
facetious when I said this is very

00:19:49,320 --> 00:19:51,839
simple yeah it's very simple in

00:19:50,639 --> 00:19:54,479
principle when you apply all these

00:19:51,839 --> 00:19:58,799
layers it becomes very complex key

00:19:54,479 --> 00:20:00,929
protection is incredibly important also

00:19:58,799 --> 00:20:02,190
from a human aspect so I mean there's a

00:20:00,929 --> 00:20:23,549
lot of this that I'm not going to touch

00:20:02,190 --> 00:20:25,259
on and touch on what I'm yeah and and

00:20:23,549 --> 00:20:27,359
how do you make sure that that's secure

00:20:25,259 --> 00:20:28,829
in transit and you know there's there's

00:20:27,359 --> 00:20:32,519
all sorts of different principles to

00:20:28,829 --> 00:20:35,039
this so I'm not a security expert and I

00:20:32,519 --> 00:20:37,559
don't pretend to be very few people can

00:20:35,039 --> 00:20:41,039
really claim that well he's probably one

00:20:37,559 --> 00:20:44,039
of them so my focus was really how do we

00:20:41,039 --> 00:20:46,589
actually make this work again from user

00:20:44,039 --> 00:20:48,379
space just a general program that wants

00:20:46,589 --> 00:20:52,589
to start accelerating some of these

00:20:48,379 --> 00:20:55,559
operations so let's dig in a little bit

00:20:52,589 --> 00:20:58,309
into the crypto API is in the kernel a

00:20:55,559 --> 00:21:01,549
little bit of history in to 545

00:20:58,309 --> 00:21:04,889
according to what I found the kernel

00:21:01,549 --> 00:21:07,950
basically had a cryptography a

00:21:04,889 --> 00:21:09,869
cryptographic framework internally this

00:21:07,950 --> 00:21:13,529
was in brought in in order to do things

00:21:09,869 --> 00:21:17,099
like accelerate IPSec and to do the

00:21:13,529 --> 00:21:18,899
calculation in a uniform way that's

00:21:17,099 --> 00:21:21,059
great but that's all inside the kernel

00:21:18,899 --> 00:21:23,609
we are wanting to get from user space

00:21:21,059 --> 00:21:25,609
down so this is where we start looking

00:21:23,609 --> 00:21:31,619
at user space ap is the kernel provides

00:21:25,609 --> 00:21:33,269
two AP is there's crypto dev 1 which

00:21:31,619 --> 00:21:39,209
I'll talk a little bit more about these

00:21:33,269 --> 00:21:40,889
individually and then there's AF al okay

00:21:39,209 --> 00:21:43,079
it's it you're right it's not internal

00:21:40,889 --> 00:21:43,750
to the kernel but I'll talk about that

00:21:43,079 --> 00:21:47,590
as well

00:21:43,750 --> 00:21:52,510
so I being a user space interface is

00:21:47,590 --> 00:21:57,640
technically not I heard it all right I

00:21:52,510 --> 00:21:58,750
owe you a mint as with all is user space

00:21:57,640 --> 00:22:01,539
api's these are going to provide

00:21:58,750 --> 00:22:03,940
hardware abstraction and they're gonna

00:22:01,539 --> 00:22:05,740
allow your your program to run

00:22:03,940 --> 00:22:09,460
independently of whatever the actual

00:22:05,740 --> 00:22:10,960
underlying hardware is so let's look at

00:22:09,460 --> 00:22:14,740
crypto dev that I've misspelled it there

00:22:10,960 --> 00:22:18,549
- no alright good so this is basically

00:22:14,740 --> 00:22:20,230
an implementation that's in Linux that

00:22:18,549 --> 00:22:24,549
is compatible with the OpenBSD

00:22:20,230 --> 00:22:26,679
cryptographic framework OCF it is not

00:22:24,549 --> 00:22:28,480
that it is not binary compatible it's

00:22:26,679 --> 00:22:32,880
not the same so it is a separate

00:22:28,480 --> 00:22:37,210
implementation but it does come it does

00:22:32,880 --> 00:22:40,330
make the effort to be compatible it

00:22:37,210 --> 00:22:41,919
creates this dev crypto device and then

00:22:40,330 --> 00:22:43,870
it's managed just like you would any

00:22:41,919 --> 00:22:46,330
other device so you use standard ieee

00:22:43,870 --> 00:22:48,159
octal x' to interface to it and this is

00:22:46,330 --> 00:22:50,140
still pretty basic stuff right it's it's

00:22:48,159 --> 00:22:51,159
pretty pretty low-level you're not

00:22:50,140 --> 00:22:55,120
getting a whole lot of high-level

00:22:51,159 --> 00:22:58,289
functionality here so I'm gonna walk

00:22:55,120 --> 00:22:58,289
through enabling this

00:23:17,760 --> 00:23:22,890
no no it's fine I'm it's it's a good

00:23:21,030 --> 00:23:24,540
point and I have a diagram that I that

00:23:22,890 --> 00:23:26,670
I'm going to show at the end the kind of

00:23:24,540 --> 00:23:28,830
demonstrates us but the the comment was

00:23:26,670 --> 00:23:32,580
that cryptid EV provides really a an

00:23:28,830 --> 00:23:34,710
abstraction another abstraction that but

00:23:32,580 --> 00:23:36,870
does not provide a an actual

00:23:34,710 --> 00:23:38,850
implementation so in the crypto dev lair

00:23:36,870 --> 00:23:41,400
you don't have a set of algorithms that

00:23:38,850 --> 00:23:43,980
are implemented it is an interface layer

00:23:41,400 --> 00:23:47,760
that gets you either to the kernel

00:23:43,980 --> 00:23:50,040
implementation or to hardware which is a

00:23:47,760 --> 00:23:51,360
good point and I it comes out a little

00:23:50,040 --> 00:23:58,830
bit more clearly in a diagram I got a

00:23:51,360 --> 00:24:02,910
little bit later so enabling this as as

00:23:58,830 --> 00:24:05,000
I said this is an out of kernel module

00:24:02,910 --> 00:24:08,490
I think that's should be out of tree

00:24:05,000 --> 00:24:11,550
kernel module and so it has to be

00:24:08,490 --> 00:24:13,320
compiled separately now for those of you

00:24:11,550 --> 00:24:15,990
that paid attention to my little bio

00:24:13,320 --> 00:24:18,240
thing up there I am a Yocto project guy

00:24:15,990 --> 00:24:20,130
I am an open embedded guy so I'm gonna

00:24:18,240 --> 00:24:23,610
do a little hand waving here because for

00:24:20,130 --> 00:24:27,180
us in Pocky this is as simple as adding

00:24:23,610 --> 00:24:29,310
adding this a little designator and your

00:24:27,180 --> 00:24:32,570
build now if you want to go and build

00:24:29,310 --> 00:24:34,680
this on your own that's gonna involve

00:24:32,570 --> 00:24:36,630
assembling a cross compile tool chain

00:24:34,680 --> 00:24:38,370
and making sure that you download the

00:24:36,630 --> 00:24:42,750
module everything else beyond the scope

00:24:38,370 --> 00:24:47,250
of what I'm going to talk about here you

00:24:42,750 --> 00:24:50,460
need the recipe for that yeah you're

00:24:47,250 --> 00:24:52,530
bragging in my presentation so Dennis

00:24:50,460 --> 00:24:54,930
did that did that implementation of the

00:24:52,530 --> 00:24:56,190
recipe anyhow so this enables it once

00:24:54,930 --> 00:25:01,140
you've done that you've got the module

00:24:56,190 --> 00:25:02,970
and we'll move on from there AFL let's

00:25:01,140 --> 00:25:05,640
talk a little bit about that one so it

00:25:02,970 --> 00:25:08,950
uses a socket interface to connect with

00:25:05,640 --> 00:25:10,700
a kernel so it's literally a socket type

00:25:08,950 --> 00:25:15,450
[Music]

00:25:10,700 --> 00:25:17,130
this is inside the mainline Linux so it

00:25:15,450 --> 00:25:19,830
doesn't actually require that external

00:25:17,130 --> 00:25:22,200
module compile but it does also require

00:25:19,830 --> 00:25:25,880
additional kernel configuration so

00:25:22,200 --> 00:25:25,880
what's the kernel configuration

00:25:26,880 --> 00:25:35,280
and these right here enable it you can

00:25:31,830 --> 00:25:37,560
actually enable both I haven't had any

00:25:35,280 --> 00:25:41,310
problem with doing that at least not on

00:25:37,560 --> 00:25:44,580
this kernel so if you want to play with

00:25:41,310 --> 00:25:47,340
both you can so let's talk a little bit

00:25:44,580 --> 00:25:48,720
again at this point we're still building

00:25:47,340 --> 00:25:49,860
up the stack right we've got the

00:25:48,720 --> 00:25:52,050
hardware at the bottom we've got the

00:25:49,860 --> 00:25:54,020
kernel and we've also now got a way to

00:25:52,050 --> 00:25:56,100
talk through the kernel to that hardware

00:25:54,020 --> 00:25:57,600
but we still are doing a lot of the

00:25:56,100 --> 00:25:59,670
heavy lifting ourselves at this point

00:25:57,600 --> 00:26:01,920
you can implement the algorithm directly

00:25:59,670 --> 00:26:04,110
or talk directly to the hardware to have

00:26:01,920 --> 00:26:05,250
it implement do some of the calculations

00:26:04,110 --> 00:26:12,020
but you're having to manage a lot of

00:26:05,250 --> 00:26:15,390
things instead we chose to use OpenSSL

00:26:12,020 --> 00:26:19,530
so you know this has a lot of benefit

00:26:15,390 --> 00:26:20,940
especially especially when you want to

00:26:19,530 --> 00:26:24,300
abstract yourself from potentially

00:26:20,940 --> 00:26:27,270
situations where you have the the a eni

00:26:24,300 --> 00:26:29,280
and or you have the the instructions

00:26:27,270 --> 00:26:32,280
that are are available to you to

00:26:29,280 --> 00:26:34,950
directly do the implementation or you

00:26:32,280 --> 00:26:36,120
have hardware in different cases so now

00:26:34,950 --> 00:26:37,950
you can write an application that

00:26:36,120 --> 00:26:41,940
doesn't really care it just wants to get

00:26:37,950 --> 00:26:44,400
to some form of hardware acceleration

00:26:41,940 --> 00:26:46,080
and SSL will failover to software and

00:26:44,400 --> 00:26:51,990
that becomes important when we do our

00:26:46,080 --> 00:26:54,420
comparison so as always there's a few

00:26:51,990 --> 00:26:58,770
steps and I'll cover that in a minute

00:26:54,420 --> 00:27:01,050
here's the pretty picture by the way I

00:26:58,770 --> 00:27:04,710
lifted this from somebody's presentation

00:27:01,050 --> 00:27:06,360
on SlideShare I thought this was exactly

00:27:04,710 --> 00:27:09,120
what I needed so I'm giving them

00:27:06,360 --> 00:27:11,010
attribution but this is essentially the

00:27:09,120 --> 00:27:12,600
pathways now it's a little bit blown up

00:27:11,010 --> 00:27:14,760
so it may not be completely clear but

00:27:12,600 --> 00:27:16,380
this is where your application is living

00:27:14,760 --> 00:27:18,690
and that's where we want to spend most

00:27:16,380 --> 00:27:21,720
of our time so we're using open an SSL

00:27:18,690 --> 00:27:23,940
either via crypto dev through the crypto

00:27:21,720 --> 00:27:26,130
dev linux down into the core and on

00:27:23,940 --> 00:27:29,460
either to the hardware or out to the

00:27:26,130 --> 00:27:31,230
kernel implementation or we go through

00:27:29,460 --> 00:27:33,060
AF alga and we're gonna do the same

00:27:31,230 --> 00:27:33,360
things we end up pretty much in the same

00:27:33,060 --> 00:27:35,580
place

00:27:33,360 --> 00:27:39,690
either way open SSL abstracts that

00:27:35,580 --> 00:27:40,620
forest in a nice way allows us to really

00:27:39,690 --> 00:27:44,279
focus in

00:27:40,620 --> 00:27:48,390
on our application so this goes to to

00:27:44,279 --> 00:27:51,630
your point earlier Dennis you know crypt

00:27:48,390 --> 00:27:55,409
of dev here is not a software algorithm

00:27:51,630 --> 00:27:58,620
it is just an interface and AF al is

00:27:55,409 --> 00:28:00,299
also not a set of algorithms it's just

00:27:58,620 --> 00:28:02,520
an interface to get the data into the

00:28:00,299 --> 00:28:05,370
kernel in a clean way and get access to

00:28:02,520 --> 00:28:08,640
the hardware have it put everybody to

00:28:05,370 --> 00:28:12,870
sleep yet still doing all right all

00:28:08,640 --> 00:28:16,020
right so since we decided we're gonna

00:28:12,870 --> 00:28:17,580
use open SSL what does it look like when

00:28:16,020 --> 00:28:20,460
we we add crypto

00:28:17,580 --> 00:28:22,710
well in order to add crypto dev support

00:28:20,460 --> 00:28:24,570
you have to enable a couple of options

00:28:22,710 --> 00:28:27,630
and open SSL this is what we were

00:28:24,570 --> 00:28:32,580
talking about last night Dennis you have

00:28:27,630 --> 00:28:35,370
to add this right here this is one point

00:28:32,580 --> 00:28:39,029
zero one I think or something I have to

00:28:35,370 --> 00:28:43,169
look at the version number you also have

00:28:39,029 --> 00:28:47,820
to add in this header once you have done

00:28:43,169 --> 00:28:49,740
that you're good and once again and I

00:28:47,820 --> 00:28:52,559
think this was your work when you enable

00:28:49,740 --> 00:28:55,320
this recipe it's gonna pull these pieces

00:28:52,559 --> 00:28:57,409
in for you and it'll be magic it'll just

00:28:55,320 --> 00:28:57,409
work

00:29:03,789 --> 00:29:06,450
No

00:29:06,480 --> 00:29:10,950
that's all I was saying I have to go and

00:29:09,090 --> 00:29:12,629
take a look I don't know if I actually

00:29:10,950 --> 00:29:15,960
pulled it down in here I think it may be

00:29:12,629 --> 00:29:17,279
one of the lungs so I got I got a go

00:29:15,960 --> 00:29:21,899
look and see which one way it actually

00:29:17,279 --> 00:29:23,070
selected you know it's very important as

00:29:21,899 --> 00:29:24,480
a module that you actually have it

00:29:23,070 --> 00:29:26,249
inserted first or else it's not going to

00:29:24,480 --> 00:29:29,190
do anything I think this is somewhat

00:29:26,249 --> 00:29:30,869
obvious but you should also be able to

00:29:29,190 --> 00:29:33,090
check that it's there because you'll see

00:29:30,869 --> 00:29:39,320
something like this and you knew an open

00:29:33,090 --> 00:29:39,320
SSL engine and it says crypto dev yes

00:29:48,440 --> 00:29:53,289
the question

00:29:50,620 --> 00:29:55,779
the question is whether or not crypto

00:29:53,289 --> 00:29:58,809
dev supports ITC devices for instance

00:29:55,779 --> 00:30:00,640
key management devices I don't know I

00:29:58,809 --> 00:30:01,419
don't see any reason why we it couldn't

00:30:00,640 --> 00:30:03,010
be added

00:30:01,419 --> 00:30:04,510
the fact is crypto dev is just that

00:30:03,010 --> 00:30:06,330
interface piece right so if you have a

00:30:04,510 --> 00:30:08,470
device driver down at the bottom level

00:30:06,330 --> 00:30:11,110
then you might have to write some glue

00:30:08,470 --> 00:30:15,850
in the kernel to get to it but I mean do

00:30:11,110 --> 00:30:18,100
you happen to know Mike yes okay so my

00:30:15,850 --> 00:30:20,880
answer is probably it can be done I

00:30:18,100 --> 00:30:20,880
don't know if it has been

00:30:28,220 --> 00:30:33,480
okay yeah I would say

00:30:31,070 --> 00:30:38,600
right well that that's exactly what

00:30:33,480 --> 00:30:38,600
OpenSSL and in the AF algún cryptid ever

00:30:42,440 --> 00:30:49,139
what time am i done

00:30:45,289 --> 00:30:52,529
how much time do i got okay so I should

00:30:49,139 --> 00:30:54,749
probably pick it I don't have to UM

00:30:52,529 --> 00:30:56,850
thank you for the question I don't think

00:30:54,749 --> 00:30:58,559
that's there yet but I don't think it

00:30:56,850 --> 00:31:03,419
would should be a heavy lift to add that

00:30:58,559 --> 00:31:07,559
support him so let's take a look at what

00:31:03,419 --> 00:31:08,639
would be required to add AFL so here's

00:31:07,559 --> 00:31:11,700
your here's the answer

00:31:08,639 --> 00:31:15,809
open us to sell 1.0 - it did not support

00:31:11,700 --> 00:31:17,700
it natively okay however there are

00:31:15,809 --> 00:31:19,379
plugins available that will provide the

00:31:17,700 --> 00:31:25,639
support open SSL is an extensible

00:31:19,379 --> 00:31:32,879
framework so we actually used a plugin

00:31:25,639 --> 00:31:35,100
that we found here basically it is been

00:31:32,879 --> 00:31:38,460
advertised that native support for AFL

00:31:35,100 --> 00:31:39,600
will be available with open SSL 1.10

00:31:38,460 --> 00:31:40,850
that was the number that stuck on my

00:31:39,600 --> 00:31:44,309
hand

00:31:40,850 --> 00:31:47,820
so hopefully this gets edged out pretty

00:31:44,309 --> 00:31:49,980
fast we always have a leading edge

00:31:47,820 --> 00:31:52,710
problem where we're chasing that so I

00:31:49,980 --> 00:31:59,070
don't know how far off we are from 1.10

00:31:52,710 --> 00:32:00,779
to tell you the truth so I'm gonna do a

00:31:59,070 --> 00:32:02,610
massive hand wave at this you can build

00:32:00,779 --> 00:32:04,409
a plugin basically follow the directions

00:32:02,610 --> 00:32:07,440
in there there's no point to me telling

00:32:04,409 --> 00:32:10,139
you exactly what to do there standard

00:32:07,440 --> 00:32:12,119
rules apply on that kind of thing you do

00:32:10,139 --> 00:32:13,980
want to place this into user live

00:32:12,119 --> 00:32:18,210
engines once you have that AF out

00:32:13,980 --> 00:32:21,330
plug-in library you also need to add to

00:32:18,210 --> 00:32:23,490
your configuration and open SSL these

00:32:21,330 --> 00:32:26,700
are the magic lines that do it a

00:32:23,490 --> 00:32:28,619
particular AFL gaethje engine and then

00:32:26,700 --> 00:32:31,730
you give some of the cipher choices here

00:32:28,619 --> 00:32:34,350
that AFL will support including digests

00:32:31,730 --> 00:32:35,909
most of this you know when you lay it up

00:32:34,350 --> 00:32:38,450
here kind of makes some intuitive sense

00:32:35,909 --> 00:32:38,450
I hope

00:32:38,470 --> 00:32:53,450
any questions on that vanilla opus

00:32:50,680 --> 00:32:56,000
vanilla the question is what does

00:32:53,450 --> 00:32:57,230
OpenSSL do if it doesn't have these by

00:32:56,000 --> 00:33:01,130
default it uses a software

00:32:57,230 --> 00:33:02,360
implementation and that like I said will

00:33:01,130 --> 00:33:05,650
become something that we will look at

00:33:02,360 --> 00:33:05,650
when we look at performance

00:33:16,760 --> 00:33:20,660
it's a good question I kind of avoided

00:33:19,070 --> 00:33:22,700
making a recommendation if you look at

00:33:20,660 --> 00:33:24,830
Marik's presentation he actually comes

00:33:22,700 --> 00:33:28,880
down very clearly on AF algas the way of

00:33:24,830 --> 00:33:30,230
the future I'll I'll tell you when we

00:33:28,880 --> 00:33:32,720
get to my data you'll see why I kind of

00:33:30,230 --> 00:33:36,590
hedge a little bit here because I

00:33:32,720 --> 00:33:37,790
suspect that the some of the your your

00:33:36,590 --> 00:33:39,980
particular performance is going to

00:33:37,790 --> 00:33:41,450
depend on your Hardware the specific

00:33:39,980 --> 00:33:43,700
kernel and things like that well we'll

00:33:41,450 --> 00:33:46,880
see why so let's take a look at the

00:33:43,700 --> 00:33:48,980
actual comparing of performance so we've

00:33:46,880 --> 00:33:51,380
got our stack now we've got our OpenSSL

00:33:48,980 --> 00:33:54,290
app at the top where I say app we got

00:33:51,380 --> 00:33:55,940
our OpenSSL at the top we've got the

00:33:54,290 --> 00:33:59,570
different layers below it we're gonna

00:33:55,940 --> 00:34:02,270
actually use the OpenSSL speed command

00:33:59,570 --> 00:34:04,250
to help us to measure but of course you

00:34:02,270 --> 00:34:07,700
can use your application sitting on top

00:34:04,250 --> 00:34:09,950
of OpenSSL very cleanly we use the

00:34:07,700 --> 00:34:11,840
elapsed argument you know so that we can

00:34:09,950 --> 00:34:14,929
get some idea against wall clock time

00:34:11,840 --> 00:34:17,480
rather than CPU time that was just a

00:34:14,929 --> 00:34:19,730
choice that we made now this goes to

00:34:17,480 --> 00:34:22,159
your question what happens if you don't

00:34:19,730 --> 00:34:23,919
have the crypto dev module inserted what

00:34:22,159 --> 00:34:26,270
happens if you don't have a fa OGG

00:34:23,919 --> 00:34:31,070
enabled it's going to default to a

00:34:26,270 --> 00:34:34,040
software implementation so this is the

00:34:31,070 --> 00:34:35,690
command we ran I couldn't fit everything

00:34:34,040 --> 00:34:38,570
in here so I cut a whole chunk out of

00:34:35,690 --> 00:34:41,270
the middle this is a lot of data to try

00:34:38,570 --> 00:34:47,230
and parse but what you see here is

00:34:41,270 --> 00:34:50,810
basically we ran an AES 128 cbc which

00:34:47,230 --> 00:34:54,830
thank you the joke was you could always

00:34:50,810 --> 00:34:56,149
just say blockchain anyhow so we ran for

00:34:54,830 --> 00:34:58,700
three seconds on each of these and these

00:34:56,149 --> 00:35:01,550
are the number of blocks that it

00:34:58,700 --> 00:35:05,630
actually managed to part or to encrypt

00:35:01,550 --> 00:35:08,000
using the cipher of this or the block of

00:35:05,630 --> 00:35:09,380
this size and using that cipher so you

00:35:08,000 --> 00:35:11,869
can see there's a whole string of these

00:35:09,380 --> 00:35:15,140
and then it talks about you know number

00:35:11,869 --> 00:35:16,580
hundred kilobytes per second it's a lot

00:35:15,140 --> 00:35:18,560
of data I have a little table at the end

00:35:16,580 --> 00:35:20,240
which hopefully I'll surprise you with

00:35:18,560 --> 00:35:24,619
so this is just the software

00:35:20,240 --> 00:35:26,570
implementation all right so let's try it

00:35:24,619 --> 00:35:30,170
again with crypto dev so again this is

00:35:26,570 --> 00:35:33,410
using open SSL in this case we passed

00:35:30,170 --> 00:35:36,530
the crypto dev engine on the command

00:35:33,410 --> 00:35:38,270
line to open SSL speed engine crypto dev

00:35:36,530 --> 00:35:40,490
this is our nice indicator that crypto

00:35:38,270 --> 00:35:43,609
dev is running once again we see these

00:35:40,490 --> 00:35:48,980
nice lines showing the different amount

00:35:43,609 --> 00:35:51,650
of blocks and I'll summarize these at

00:35:48,980 --> 00:35:53,270
the end we we decided that we really

00:35:51,650 --> 00:35:57,470
wanted to confirm that this was being

00:35:53,270 --> 00:35:59,480
used so this little looking at the the

00:35:57,470 --> 00:36:01,700
interrupts gives you an indication

00:35:59,480 --> 00:36:05,030
because you start seeing cam interrupts

00:36:01,700 --> 00:36:08,170
there that's just a sanity check make

00:36:05,030 --> 00:36:08,170
sure you do what you think you're doing

00:36:08,740 --> 00:36:15,619
so once again for the AF out case we

00:36:13,339 --> 00:36:20,020
just look at engine oh darn it that's a

00:36:15,619 --> 00:36:25,309
cut-and-paste er sorry

00:36:20,020 --> 00:36:27,470
it should say engine AF al which is what

00:36:25,309 --> 00:36:29,480
this command actually says so ignore

00:36:27,470 --> 00:36:32,420
that part two typos I guess I'm doing

00:36:29,480 --> 00:36:34,400
right and you get the confirmation here

00:36:32,420 --> 00:36:36,380
and then same kind of output there's a

00:36:34,400 --> 00:36:37,400
whole bunch of garbage in here that it's

00:36:36,380 --> 00:36:39,109
not garbage there's a whole bunch of

00:36:37,400 --> 00:36:40,880
information in there that includes

00:36:39,109 --> 00:36:42,470
things like your tool chain and some of

00:36:40,880 --> 00:36:45,579
the configuration options and stuff that

00:36:42,470 --> 00:36:53,530
wasn't really necessary for us so

00:36:45,579 --> 00:36:53,530
there's I'm gonna let this sit for a sec

00:36:57,680 --> 00:37:00,849
anybody knows anything

00:37:03,810 --> 00:37:10,350
so when we got this we we were really

00:37:07,140 --> 00:37:13,070
puzzled we're like okay we were

00:37:10,350 --> 00:37:16,070
searching for hardware acceleration and

00:37:13,070 --> 00:37:20,880
we got hardware acceleration and it was

00:37:16,070 --> 00:37:23,310
slower and it's not slower in one case

00:37:20,880 --> 00:37:24,510
it's slower in all cases there's only

00:37:23,310 --> 00:37:26,430
one that I highlighted here that was

00:37:24,510 --> 00:37:29,210
sort of anomalous because these two are

00:37:26,430 --> 00:37:31,800
very close together but as it turns out

00:37:29,210 --> 00:37:34,890
pretty much it's consistent regardless

00:37:31,800 --> 00:37:40,020
of the block size you end up with

00:37:34,890 --> 00:37:44,730
software being faster anyone want to

00:37:40,020 --> 00:37:46,620
hazard a guess the answer from the crowd

00:37:44,730 --> 00:37:50,880
was Colonel over colonel interface

00:37:46,620 --> 00:37:52,950
overhead and I'm sorry bus speed is

00:37:50,880 --> 00:37:54,180
another one what we found was that the

00:37:52,950 --> 00:37:56,090
number of interrupts that were occurring

00:37:54,180 --> 00:37:58,290
and context switches that were occurring

00:37:56,090 --> 00:38:01,530
skyrockets when you start using crypto

00:37:58,290 --> 00:38:03,960
dev or AFL and so colonel interface

00:38:01,530 --> 00:38:07,080
overhead basically you see so many

00:38:03,960 --> 00:38:12,540
contexts which is occurring that the

00:38:07,080 --> 00:38:15,270
performance actually goes down so this

00:38:12,540 --> 00:38:16,920
is a quad-core we did not due to

00:38:15,270 --> 00:38:19,530
extensive profiling of this and this is

00:38:16,920 --> 00:38:21,480
not my I didn't actually put in the

00:38:19,530 --> 00:38:23,160
disclaimer here but this was not in ten

00:38:21,480 --> 00:38:25,470
I have it at the end

00:38:23,160 --> 00:38:30,180
this was not an exhaustive search this

00:38:25,470 --> 00:38:36,800
is not a scientific search no this is

00:38:30,180 --> 00:38:36,800
and and so what we did yes sir

00:38:40,049 --> 00:38:44,209
I can't hear you I'm sorry

00:38:48,710 --> 00:38:52,080
so this is what this goes back to what I

00:38:50,970 --> 00:38:53,820
was saying we did not do an exhaustive

00:38:52,080 --> 00:38:56,700
profiling to see what was traversing

00:38:53,820 --> 00:38:58,050
buses or things like this this was just

00:38:56,700 --> 00:39:00,930
the block size that we fed into this

00:38:58,050 --> 00:39:02,670
loop this was the block size that we fit

00:39:00,930 --> 00:39:04,950
in and there was a question up front

00:39:02,670 --> 00:39:08,070
here from Dennis about larger block

00:39:04,950 --> 00:39:10,850
sizes we didn't go I don't think we

00:39:08,070 --> 00:39:17,190
collected the data but it was consistent

00:39:10,850 --> 00:39:18,360
up until I think 32k bikes and I think

00:39:17,190 --> 00:39:19,980
it's right around that point that it was

00:39:18,360 --> 00:39:24,150
inflection I kind of like this one

00:39:19,980 --> 00:39:26,490
because it was nice and tidy yeah it's

00:39:24,150 --> 00:39:29,340
going to depend on your hardware so the

00:39:26,490 --> 00:39:32,670
the the point here is that especially

00:39:29,340 --> 00:39:37,110
when you have smaller block sizes the

00:39:32,670 --> 00:39:39,570
transfer is very very expensive when you

00:39:37,110 --> 00:39:41,880
start getting up higher you notice that

00:39:39,570 --> 00:39:43,650
the Delta is dropping and I didn't

00:39:41,880 --> 00:39:45,840
really extend this table out we didn't

00:39:43,650 --> 00:39:51,960
do an exhaustive you know block search

00:39:45,840 --> 00:39:53,760
but right and that's what that's what my

00:39:51,960 --> 00:39:56,010
I recall and I should have I should have

00:39:53,760 --> 00:39:58,380
captured that but I didn't as you get

00:39:56,010 --> 00:40:01,140
larger and larger you're getting you

00:39:58,380 --> 00:40:02,670
know more more efficiencies in terms of

00:40:01,140 --> 00:40:05,580
transfer so the overhead and the kernel

00:40:02,670 --> 00:40:07,050
is less so you do begin to see it will

00:40:05,580 --> 00:40:09,630
some point in time usually there will

00:40:07,050 --> 00:40:12,180
there will occur a flip over where the

00:40:09,630 --> 00:40:13,500
hardware acceleration actually now does

00:40:12,180 --> 00:40:15,060
make anything different enough of a

00:40:13,500 --> 00:40:16,470
difference one of the other things

00:40:15,060 --> 00:40:18,900
innocent conclusion I want to get to and

00:40:16,470 --> 00:40:24,840
then we'll we'll continue with the

00:40:18,900 --> 00:40:27,240
heckling from up front is so we were

00:40:24,840 --> 00:40:31,020
very puzzled by this one of the other

00:40:27,240 --> 00:40:33,540
things that we found which was nice and

00:40:31,020 --> 00:40:37,020
you can't really see it in that data was

00:40:33,540 --> 00:40:39,780
that the CPU utilization did go down so

00:40:37,020 --> 00:40:41,670
the offload processing was occurring

00:40:39,780 --> 00:40:44,280
there was still however a lot of

00:40:41,670 --> 00:40:46,860
overhead involved with doing so it

00:40:44,280 --> 00:40:49,470
points to places for optimization if you

00:40:46,860 --> 00:40:50,360
can reduce the amount of overhead you're

00:40:49,470 --> 00:40:53,990
gonna get better

00:40:50,360 --> 00:40:58,970
CPU utilization you're also going to get

00:40:53,990 --> 00:40:58,970
faster operations but

00:41:04,170 --> 00:41:10,750
we didn't quantify that and we should we

00:41:08,230 --> 00:41:12,340
like I said we we just expected to see a

00:41:10,750 --> 00:41:14,170
set of operations that went the other

00:41:12,340 --> 00:41:15,670
way so when we discovered this we kind

00:41:14,170 --> 00:41:16,780
of fell on the floor and we scratched

00:41:15,670 --> 00:41:18,490
our heads for a little while and then

00:41:16,780 --> 00:41:38,980
that was part of the reason why I

00:41:18,490 --> 00:41:40,869
decided to I think it was worth alright

00:41:38,980 --> 00:41:44,380
and so for our for our purposes this was

00:41:40,869 --> 00:41:46,510
good enough but I think that one of the

00:41:44,380 --> 00:41:48,190
things that and this is sort of my

00:41:46,510 --> 00:41:49,930
blanket you know this was not intended

00:41:48,190 --> 00:41:51,460
as an exhaustive analysis this is really

00:41:49,930 --> 00:41:54,220
intended to kind of promote the idea

00:41:51,460 --> 00:41:55,810
that it's not a slam dunk you know just

00:41:54,220 --> 00:41:56,859
because you have Hardware down there you

00:41:55,810 --> 00:41:58,570
have enough things going on in the

00:41:56,859 --> 00:42:00,880
middle you need to make sure that you

00:41:58,570 --> 00:42:03,700
profile it and and understand what it is

00:42:00,880 --> 00:42:05,470
that your particular use case is so make

00:42:03,700 --> 00:42:08,890
sure and run your own tests if you can

00:42:05,470 --> 00:42:11,560
pass very large block sizes you may get

00:42:08,890 --> 00:42:12,850
enough benefit just as is to not have to

00:42:11,560 --> 00:42:15,250
worry about it but there's certainly

00:42:12,850 --> 00:42:18,550
opportunities for optimization that

00:42:15,250 --> 00:42:20,380
exist and also because of the fact that

00:42:18,550 --> 00:42:22,210
you are definitely freeing the CPU a

00:42:20,380 --> 00:42:23,500
little bit for offloading you may want

00:42:22,210 --> 00:42:25,930
to do this even though you know it's

00:42:23,500 --> 00:42:27,670
maybe a little bit slower because now

00:42:25,930 --> 00:42:31,570
you you're regaining some of your CPU

00:42:27,670 --> 00:42:34,210
budget for other operations so that was

00:42:31,570 --> 00:42:37,619
pretty much the some of it at this point

00:42:34,210 --> 00:42:37,619
and we have Kristin's

00:42:41,750 --> 00:42:52,190
I don't know um that's a good question

00:42:45,530 --> 00:42:55,820
I don't know yeah I think that's what he

00:42:52,190 --> 00:42:57,170
was referring to yeah I mean that would

00:42:55,820 --> 00:42:59,060
make a lot of sense so the question was

00:42:57,170 --> 00:43:00,800
if there's a way to configure open SSL

00:42:59,060 --> 00:43:03,320
so that it will use a different

00:43:00,800 --> 00:43:04,910
algorithm depending on the block size to

00:43:03,320 --> 00:43:27,680
my knowledge that doesn't exist but I

00:43:04,910 --> 00:43:31,190
don't think that would be difficult yeah

00:43:27,680 --> 00:43:33,520
it's hard to disentangle the specific

00:43:31,190 --> 00:43:36,500
hardware effect of multi-threading and

00:43:33,520 --> 00:43:38,500
the actual performance change so yeah

00:43:36,500 --> 00:43:40,520
cache misses is something that

00:43:38,500 --> 00:43:42,470
everything you read on this says make

00:43:40,520 --> 00:43:45,109
sure that you have page line the memory

00:43:42,470 --> 00:43:49,000
which is another big one all of these

00:43:45,109 --> 00:43:49,000
types of things are going to factor in

00:43:50,560 --> 00:44:02,810
it is a freescale kernel I'm sorry yeah

00:44:00,589 --> 00:44:05,720
this was this was not on a ul this was

00:44:02,810 --> 00:44:11,480
just on a stock imx6 I was actually a

00:44:05,720 --> 00:44:12,700
sabre light clone ultralight so yeah I

00:44:11,480 --> 00:44:14,690
know that there's been a lot of

00:44:12,700 --> 00:44:16,609
improvements and like I said this is a

00:44:14,690 --> 00:44:19,640
4-1 kernel that I ran against with a

00:44:16,609 --> 00:44:21,470
specific version of SSL things may have

00:44:19,640 --> 00:44:23,480
moved on quite quite significantly I

00:44:21,470 --> 00:44:27,589
know that they continue to to scrutinise

00:44:23,480 --> 00:44:30,650
oh yeah okay that's good to know I

00:44:27,589 --> 00:44:33,170
didn't know that it's real sensitive to

00:44:30,650 --> 00:44:35,180
quite a few different variables which is

00:44:33,170 --> 00:44:37,070
why I keep emphasizing make sure that

00:44:35,180 --> 00:44:39,890
you know your particular use case and

00:44:37,070 --> 00:44:43,130
try it out you may find that it performs

00:44:39,890 --> 00:44:46,540
just fine for what you need any other

00:44:43,130 --> 00:44:46,540
questions yes sir

00:44:59,360 --> 00:45:02,870
what I was gonna say it depends there's

00:45:01,620 --> 00:45:04,710
there's actually two different ones so

00:45:02,870 --> 00:45:06,480
yeah so there's there's a

00:45:04,710 --> 00:45:08,250
implementations of some algorithms

00:45:06,480 --> 00:45:12,330
inside the kernel itself inside they

00:45:08,250 --> 00:45:14,160
crypt a crypto a crypto framework and

00:45:12,330 --> 00:45:17,250
there's also an implementation just pure

00:45:14,160 --> 00:45:19,440
software inside open SSL open SSL if

00:45:17,250 --> 00:45:22,140
you're using it is I don't think there's

00:45:19,440 --> 00:45:24,000
any pathological case where it detects

00:45:22,140 --> 00:45:25,680
that it doesn't have crypto Devaraya

00:45:24,000 --> 00:45:29,340
THOG and it tries to pass it through the

00:45:25,680 --> 00:45:30,750
kernel anyway I'm just gonna say I don't

00:45:29,340 --> 00:45:34,920
think there's any way for it to do that

00:45:30,750 --> 00:45:37,320
so yeah I mean but there there are

00:45:34,920 --> 00:45:40,010
separate implementations in those two

00:45:37,320 --> 00:45:42,810
spaces the reason why they open SSL one

00:45:40,010 --> 00:45:44,790
in software seems to do so well I think

00:45:42,810 --> 00:45:46,440
is because it doesn't have that kernel

00:45:44,790 --> 00:45:48,270
overhead because it's all CPU

00:45:46,440 --> 00:45:50,190
instructions and everything else it has

00:45:48,270 --> 00:45:52,530
those nice things that I that I

00:45:50,190 --> 00:46:02,070
highlighted before about a software-only

00:45:52,530 --> 00:46:04,290
implementation right the comment from

00:46:02,070 --> 00:46:08,190
from the front here is you know if you

00:46:04,290 --> 00:46:10,200
do run this on a single core your cores

00:46:08,190 --> 00:46:11,970
go on right you probably consume the

00:46:10,200 --> 00:46:14,280
whole thing I didn't actually show some

00:46:11,970 --> 00:46:16,020
of the capture in terms of percentage of

00:46:14,280 --> 00:46:19,620
CPU utilization but it will try and rail

00:46:16,020 --> 00:46:23,360
it so it'll it'll consume however many

00:46:19,620 --> 00:46:23,360
cores you want to throw at it in general

00:46:26,439 --> 00:46:33,949
yeah yeah so the observation was that

00:46:32,479 --> 00:46:36,169
any time you're computationally bound

00:46:33,949 --> 00:46:41,199
you want to offload as much as possible

00:46:36,169 --> 00:46:41,199
and yeah I mean those are best practices

00:46:44,049 --> 00:47:03,109
yes right if he if you yeah if you need

00:47:01,369 --> 00:47:04,459
something that's on a hard real-time

00:47:03,109 --> 00:47:06,859
deadline that maybe it makes more sense

00:47:04,459 --> 00:47:09,439
to come the observation was you know

00:47:06,859 --> 00:47:14,089
jitter versus throughput and those two

00:47:09,439 --> 00:47:17,330
don't always line up I think I think we

00:47:14,089 --> 00:47:21,619
are done thank you very much

00:47:17,330 --> 00:47:21,619

YouTube URL: https://www.youtube.com/watch?v=mNwwAcK_HJM


