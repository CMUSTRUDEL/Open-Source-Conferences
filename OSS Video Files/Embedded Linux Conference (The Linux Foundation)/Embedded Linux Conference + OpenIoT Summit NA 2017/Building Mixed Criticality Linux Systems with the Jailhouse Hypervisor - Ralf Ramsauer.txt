Title: Building Mixed Criticality Linux Systems with the Jailhouse Hypervisor - Ralf Ramsauer
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	Building Mixed Criticality Linux Systems with the Jailhouse Hypervisor - Ralf Ramsauer, Technical University of Applied Sciences Regensburg & Jan Kiszka, Siemens AG

The partitioning hypervisor Jaihouse allows us to run safety critical and uncritical applications in parallel on a single SoC. We present our experiences when porting a safety and real-time critical existing application as a Jailhouse guest. It shows a novel and promising approach for implementing mixed-criticality applications with real-time requirement while not loosing the benefits of Linux. This is done by static partitioning of hardware resources; guests do not interfere.

We will present a multicopter platform running the real-time critical flight stack in an isolated Jailhouse guest. This proves the practicability of Jailhouse as well as the suitability for real-time safety critical systems by porting an existing application to a Jailhouse cell. We stress its concept and show up current hardware limitations, like undesired behaviour and present possible workarounds and solutions.

About Jan Kiszka
Jan Kiszka is working as consultant and senior software engineer in the Competence Center for Embedded Linux at Siemens Corporate Technology. He is supporting Siemens sectors with adapting and enhancing open source as platform for their products. For customer projects and whenever his spare time permits, he is contributing to open source projects, specifically in the area of real-time and virtualization.

About Ralf Ramsauer
Ralf Ramsauer is a PhD student at the University of Applied Sciences Regensburg where he works in a joint project together with Siemens Corporate Competence Center Embedded Linux. His academic research interests focus on finding successful long term maintenance strategies for Open Source Software in embedded industrial context. This covers the full software stack of embedded systems, from hardware-related low-level virtualisation technologies via kernel-space through to userland.
Captions: 
	00:00:00,030 --> 00:00:06,960
so welcome everyone so I'm just briefly

00:00:03,929 --> 00:00:10,260
here to warm up the stage basically both

00:00:06,960 --> 00:00:13,160
of the talk will be held by Ralph it's a

00:00:10,260 --> 00:00:16,230
good building a mixed critical Linux

00:00:13,160 --> 00:00:19,740
system with the Jade house hypervisor so

00:00:16,230 --> 00:00:21,330
I'm here because I kind of created the

00:00:19,740 --> 00:00:22,949
hypervisor and so I gives you a brief

00:00:21,330 --> 00:00:25,279
introduction to what is this about and

00:00:22,949 --> 00:00:35,100
then hold of a drive to show basically

00:00:25,279 --> 00:00:36,360
what he was building out of this so the

00:00:35,100 --> 00:00:38,100
introduction and the current status

00:00:36,360 --> 00:00:40,500
that's the part where are we going to

00:00:38,100 --> 00:00:44,370
begin and maybe look into the further

00:00:40,500 --> 00:00:47,129
details so the motivation to start this

00:00:44,370 --> 00:00:50,070
project is that well first of all we

00:00:47,129 --> 00:00:52,110
nowaday have SMP systems all about all

00:00:50,070 --> 00:00:55,469
around the world in a better devices

00:00:52,110 --> 00:00:58,199
specifically as well and that of course

00:00:55,469 --> 00:01:00,270
opens some chances in our domain where

00:00:58,199 --> 00:01:03,270
we used to have a lot of separate

00:01:00,270 --> 00:01:05,909
devices doing single toss on único

00:01:03,270 --> 00:01:07,740
processors now they can do these tasks

00:01:05,909 --> 00:01:13,080
causally data together on a bigger

00:01:07,740 --> 00:01:16,920
machine and many of these devices have

00:01:13,080 --> 00:01:19,740
Linux on it but not all of them and not

00:01:16,920 --> 00:01:21,450
all of our workloads are Linux based so

00:01:19,740 --> 00:01:23,549
there's a lot of legacy software sects

00:01:21,450 --> 00:01:27,450
around which expect well Signal Corps

00:01:23,549 --> 00:01:29,400
which expect bare metal maybe then there

00:01:27,450 --> 00:01:31,350
is the the area of safety critical

00:01:29,400 --> 00:01:34,020
systems you know about what more about

00:01:31,350 --> 00:01:35,579
it later on and yeah there's also

00:01:34,020 --> 00:01:37,470
workload which is basically running

00:01:35,579 --> 00:01:39,810
these P like so we really want to

00:01:37,470 --> 00:01:42,299
squeeze out the last cycles of your

00:01:39,810 --> 00:01:45,110
hardware and these days are of the

00:01:42,299 --> 00:01:48,560
multi-core high performance processors

00:01:45,110 --> 00:01:51,119
so this is a set up and in order to

00:01:48,560 --> 00:01:55,979
avoid that we are running like on the

00:01:51,119 --> 00:01:57,750
picture Linux bare metal blank site some

00:01:55,979 --> 00:01:59,460
other workload which is technically

00:01:57,750 --> 00:02:02,610
possible but not really cleanly

00:01:59,460 --> 00:02:05,850
isolating we created the hypervisor

00:02:02,610 --> 00:02:07,170
jános which is a little bit different

00:02:05,850 --> 00:02:10,229
from other hypervisors in the world out

00:02:07,170 --> 00:02:12,150
there so first of all it's really only

00:02:10,229 --> 00:02:13,750
about the part of the static

00:02:12,150 --> 00:02:17,290
partitioning of the system

00:02:13,750 --> 00:02:18,850
that's all moon purpose well we use how

00:02:17,290 --> 00:02:22,510
to visualization for this that's the

00:02:18,850 --> 00:02:24,010
technology but what we don't do in

00:02:22,510 --> 00:02:27,100
comparison to other hypotheses we don't

00:02:24,010 --> 00:02:29,590
schedule so there is no CPU cores

00:02:27,100 --> 00:02:33,490
camping at all and there's one to one

00:02:29,590 --> 00:02:37,470
assignment of devices of resources to

00:02:33,490 --> 00:02:37,470
what one user one guess so to say

00:02:37,620 --> 00:02:43,450
another major difference is that we are

00:02:40,560 --> 00:02:46,060
splitting up and already running Linux

00:02:43,450 --> 00:02:47,770
system and it's shown of the graphics

00:02:46,060 --> 00:02:50,380
basic a so we let Linux boot the system

00:02:47,770 --> 00:02:52,900
completely then we load the hypervisor

00:02:50,380 --> 00:02:55,420
underneath and let the hypervisor

00:02:52,900 --> 00:02:57,490
basically then split up the hardware

00:02:55,420 --> 00:02:58,480
into the pieces that we need for running

00:02:57,490 --> 00:03:01,180
additional work on it

00:02:58,480 --> 00:03:05,080
so basically shrink Linux and extend it

00:03:01,180 --> 00:03:09,040
for other use cases and that all in all

00:03:05,080 --> 00:03:14,650
it's emphasizing simplicity over the

00:03:09,040 --> 00:03:16,330
features so just a brief startup it but

00:03:14,650 --> 00:03:18,070
we are doing or what we are right now

00:03:16,330 --> 00:03:21,400
so in January we released the version

00:03:18,070 --> 00:03:24,580
over at 6 so it's not quite 1 or 0

00:03:21,400 --> 00:03:27,580
there's still some bit to go but we made

00:03:24,580 --> 00:03:30,400
major steps forward already so we merged

00:03:27,580 --> 00:03:33,489
reserved a Bambi 8 support by the time

00:03:30,400 --> 00:03:38,130
finally officially committed by huawei

00:03:33,489 --> 00:03:42,100
nicely along this we reworked v7 support

00:03:38,130 --> 00:03:44,530
we now have a nice way to communicate

00:03:42,100 --> 00:03:46,959
between the guests well obviously need

00:03:44,530 --> 00:03:49,090
this be a shared memory devices and on

00:03:46,959 --> 00:03:53,260
top of this we have virtual networks

00:03:49,090 --> 00:03:54,670
available we now also have support well

00:03:53,260 --> 00:03:56,080
I showed you the graphics basically we

00:03:54,670 --> 00:03:58,630
are running something else than the mix

00:03:56,080 --> 00:04:00,790
size Linux but of course we can also now

00:03:58,630 --> 00:04:02,739
run Linux our clinics so we can

00:04:00,790 --> 00:04:06,610
partition large Linux systems into

00:04:02,739 --> 00:04:10,480
smaller but many Linux systems why we

00:04:06,610 --> 00:04:13,290
see later on why this is useful yeah and

00:04:10,480 --> 00:04:14,980
we have integrated more support for

00:04:13,290 --> 00:04:16,959
interesting knowledge like the cache

00:04:14,980 --> 00:04:19,450
technology cache at the case technology

00:04:16,959 --> 00:04:21,549
of Intel which allows us to more

00:04:19,450 --> 00:04:23,950
fine-grained control which kind of

00:04:21,549 --> 00:04:26,620
latency is we can get from the hardware

00:04:23,950 --> 00:04:27,430
and more and more bots are also

00:04:26,620 --> 00:04:31,389
available list

00:04:27,430 --> 00:04:33,880
is what's coming next so along the

00:04:31,389 --> 00:04:37,720
future well we want to further advance

00:04:33,880 --> 00:04:39,759
on the shared memory device that's more

00:04:37,720 --> 00:04:42,009
a little technical requirement but it

00:04:39,759 --> 00:04:42,820
will help in the end one of the final

00:04:42,009 --> 00:04:46,960
golf of jailhouse

00:04:42,820 --> 00:04:49,000
certification furthermore we are

00:04:46,960 --> 00:04:50,860
participating google Summer of Code most

00:04:49,000 --> 00:04:54,520
likely well we have two projects running

00:04:50,860 --> 00:04:57,130
where we are hosted co-located one is

00:04:54,520 --> 00:04:59,259
qmo and the other one is slippered so

00:04:57,130 --> 00:05:01,090
there are the links to the ideas

00:04:59,259 --> 00:05:02,470
proposal up there and we already

00:05:01,090 --> 00:05:05,020
received some feedback on students

00:05:02,470 --> 00:05:06,820
interested in these topics and last but

00:05:05,020 --> 00:05:09,520
not least we are heading for safety

00:05:06,820 --> 00:05:11,680
certification of jailhouse well not of

00:05:09,520 --> 00:05:15,340
Genoa alone with it as it possible you

00:05:11,680 --> 00:05:17,410
have to certify a whole system but first

00:05:15,340 --> 00:05:19,960
of all we have to look into what is this

00:05:17,410 --> 00:05:23,440
cellos able to do this and that looks

00:05:19,960 --> 00:05:24,699
quite good so far now the question is

00:05:23,440 --> 00:05:26,169
what the heart record River trust

00:05:24,699 --> 00:05:28,630
because what we are building on hardware

00:05:26,169 --> 00:05:30,370
so we can't really say the problem is

00:05:28,630 --> 00:05:31,810
solve just by solving a trail house so

00:05:30,370 --> 00:05:34,180
we have to look at both parts and that's

00:05:31,810 --> 00:05:36,900
actually interesting partner so stay

00:05:34,180 --> 00:05:39,729
tuned maybe even more about this later

00:05:36,900 --> 00:05:41,949
so now I'm handing over to Ralph and

00:05:39,729 --> 00:05:43,570
it's interesting activities on this so

00:05:41,949 --> 00:05:46,090
thank you very much for the introduction

00:05:43,570 --> 00:05:49,240
and now I'm going to explain to you how

00:05:46,090 --> 00:05:52,539
on how we can use tiles to build mix

00:05:49,240 --> 00:05:54,639
criticality systems so mix criticality

00:05:52,539 --> 00:05:57,789
systems are usually systems where you

00:05:54,639 --> 00:06:01,449
run different payloads of different

00:05:57,789 --> 00:06:04,780
levels of criticality like critical and

00:06:01,449 --> 00:06:06,520
uncritical payloads a typical candidate

00:06:04,780 --> 00:06:10,810
for such mixed criticality systems is a

00:06:06,520 --> 00:06:12,909
car where for example the engine control

00:06:10,810 --> 00:06:14,729
has a higher criticality than the

00:06:12,909 --> 00:06:17,500
instrument control for instance and

00:06:14,729 --> 00:06:20,789
currently those control units of those

00:06:17,500 --> 00:06:23,169
devices or of those devices are

00:06:20,789 --> 00:06:25,509
currently located on separate physical

00:06:23,169 --> 00:06:27,820
systems and with the use of cellos

00:06:25,509 --> 00:06:29,289
we could think of consolidating them

00:06:27,820 --> 00:06:32,949
back together to one single hardware

00:06:29,289 --> 00:06:34,870
unit so and to demonstrate and to prove

00:06:32,949 --> 00:06:37,000
the suitability of chalice for mixed

00:06:34,870 --> 00:06:38,830
criticality systems we implemented a

00:06:37,000 --> 00:06:40,960
demonstration platform we call it the

00:06:38,830 --> 00:06:43,840
chapter the child house copter

00:06:40,960 --> 00:06:47,470
which is a typical mixed criticality

00:06:43,840 --> 00:06:49,180
environment so we have so we have a we

00:06:47,470 --> 00:06:51,880
have load time requirements they are it

00:06:49,180 --> 00:06:53,470
is a safety critical environment because

00:06:51,880 --> 00:06:57,550
the flight stack that is controlling

00:06:53,470 --> 00:06:59,440
this device is critical for us and we

00:06:57,550 --> 00:07:01,690
have typical requirements that we have

00:06:59,440 --> 00:07:05,050
in any industrial product like

00:07:01,690 --> 00:07:09,130
reliability robustness maintainability

00:07:05,050 --> 00:07:14,440
of the whole system yeah and we want to

00:07:09,130 --> 00:07:17,260
show that it is feasible with with

00:07:14,440 --> 00:07:19,449
reasonable effort to port an existing

00:07:17,260 --> 00:07:22,600
payload application to run as a child

00:07:19,449 --> 00:07:24,220
house guest so let's have a look at the

00:07:22,600 --> 00:07:26,199
classical approach on how those

00:07:24,220 --> 00:07:28,840
technologies are implemented at the

00:07:26,199 --> 00:07:32,199
moment so you usually have a Hardware

00:07:28,840 --> 00:07:34,180
control unit where you typically run a

00:07:32,199 --> 00:07:36,010
minimalistic real-time operating system

00:07:34,180 --> 00:07:37,419
so in this case this control unit runs

00:07:36,010 --> 00:07:41,860
the Nath X operate a real-time operating

00:07:37,419 --> 00:07:43,389
system and on top of it there are no

00:07:41,860 --> 00:07:47,860
pilot flight sec that's an open-source

00:07:43,389 --> 00:07:51,130
flight stack and this device acquires at

00:07:47,860 --> 00:07:53,470
a high sample rate sensor of a sense of

00:07:51,130 --> 00:07:57,460
values such as sensor values from puro

00:07:53,470 --> 00:08:00,099
scopes compasses accelerometers GPS or

00:07:57,460 --> 00:08:02,530
the remote control or the remote

00:08:00,099 --> 00:08:06,070
controller and it uses those values to

00:08:02,530 --> 00:08:10,210
calculate new values for for setting for

00:08:06,070 --> 00:08:12,159
setting the motors and this is the

00:08:10,210 --> 00:08:13,599
flight critical part of the system and

00:08:12,159 --> 00:08:15,789
then you have to mission critical part

00:08:13,599 --> 00:08:19,240
of the system where you use very

00:08:15,789 --> 00:08:21,669
typically use a bigger Hardware stronger

00:08:19,240 --> 00:08:23,199
hardware that is able to run Linux on

00:08:21,669 --> 00:08:25,330
top of it and then you can benefit from

00:08:23,199 --> 00:08:27,520
the whole Linux ecosystem so you have

00:08:25,330 --> 00:08:29,710
those millions of lines of codes or here

00:08:27,520 --> 00:08:32,890
for instance you want to run an open CV

00:08:29,710 --> 00:08:34,839
application where where you want to

00:08:32,890 --> 00:08:39,849
measure the landscape or where you want

00:08:34,839 --> 00:08:44,320
to follow some some waypoints and then

00:08:39,849 --> 00:08:46,390
you use some Python application to to to

00:08:44,320 --> 00:08:48,370
process those data and you in the end

00:08:46,390 --> 00:08:51,010
you presented using some web server

00:08:48,370 --> 00:08:52,850
application for example so we have the

00:08:51,010 --> 00:08:54,560
critical world and we have

00:08:52,850 --> 00:08:55,910
the uncritical work and there is some

00:08:54,560 --> 00:09:01,310
kind of communication channel between

00:08:55,910 --> 00:09:03,620
those two worlds to to to dump a logging

00:09:01,310 --> 00:09:07,490
data for example or to set new controls

00:09:03,620 --> 00:09:10,819
to to the flight control so now we want

00:09:07,490 --> 00:09:12,920
to consolidate those two worlds to

00:09:10,819 --> 00:09:15,829
isolate that separate domains running on

00:09:12,920 --> 00:09:17,839
one single hardware unit and we do this

00:09:15,829 --> 00:09:20,149
with child house and tell us is going to

00:09:17,839 --> 00:09:22,579
ensure that those two domains are not

00:09:20,149 --> 00:09:33,319
going to or will not interfere in in an

00:09:22,579 --> 00:09:35,120
unacceptable way so in the beginning we

00:09:33,319 --> 00:09:37,069
had to make some architectural decisions

00:09:35,120 --> 00:09:39,680
and we chose to use an octocopter an

00:09:37,069 --> 00:09:43,190
octave frame this is from the micro

00:09:39,680 --> 00:09:45,649
copter project it is originally driven

00:09:43,190 --> 00:09:49,040
by an aviary PI an AVR microcontroller

00:09:45,649 --> 00:09:50,600
but as you probably know they say an AVR

00:09:49,040 --> 00:09:52,910
is not a candidate to run Linux on top

00:09:50,600 --> 00:09:55,190
of it so we dropped away the original

00:09:52,910 --> 00:09:57,470
hardware and we put our own hardware on

00:09:55,190 --> 00:09:59,269
top of it that consists of an amulet

00:09:57,470 --> 00:10:01,790
Navy or two so this is just a sensor

00:09:59,269 --> 00:10:03,319
board we have a GPS we have

00:10:01,790 --> 00:10:05,060
accelerometers we have compasses all

00:10:03,319 --> 00:10:08,449
that we need is on top of that board and

00:10:05,060 --> 00:10:10,370
then we have this this is the core of

00:10:08,449 --> 00:10:15,589
the system there is a Nvidia Jetson CK

00:10:10,370 --> 00:10:19,069
one and this one is a quad-core arm v7

00:10:15,589 --> 00:10:20,750
32-bit CPUs it comes with 2 gigabytes of

00:10:19,069 --> 00:10:23,079
main memory it's not the latest model so

00:10:20,750 --> 00:10:25,610
it was released in the middle of 2014

00:10:23,079 --> 00:10:27,589
but it has a feature-rich expansion

00:10:25,610 --> 00:10:29,060
header so exposes everything that we

00:10:27,589 --> 00:10:32,149
that we need to do to the outer world

00:10:29,060 --> 00:10:34,850
such as SPI i-square CU art and many

00:10:32,149 --> 00:10:39,380
GPIO s and what is important especially

00:10:34,850 --> 00:10:42,290
for us is that it that it has the arm ve

00:10:39,380 --> 00:10:44,720
virtualization extensions that we need

00:10:42,290 --> 00:10:46,040
to run cellos on top of it so it's tell

00:10:44,720 --> 00:10:47,750
us enabled in what is pretty nice about

00:10:46,040 --> 00:10:52,189
this portal that you can run it on

00:10:47,750 --> 00:10:54,019
latest mainland the nodes so we want to

00:10:52,189 --> 00:10:56,240
split up our system in the following way

00:10:54,019 --> 00:11:00,170
on the left side you can see the

00:10:56,240 --> 00:11:02,269
critical world where we run cellos on so

00:11:00,170 --> 00:11:05,059
very divided our hardware in the middle

00:11:02,269 --> 00:11:06,480
so we assign two CPUs and all the

00:11:05,059 --> 00:11:09,630
critical devices that we

00:11:06,480 --> 00:11:11,190
so these are ice we need an ice Percy

00:11:09,630 --> 00:11:13,740
device for controlling the motors the

00:11:11,190 --> 00:11:16,800
parameter and the RC decoder we assign

00:11:13,740 --> 00:11:19,019
an SPI device to the political star to

00:11:16,800 --> 00:11:21,060
control the girls code to get values

00:11:19,019 --> 00:11:24,240
from the girls curves the accelerometers

00:11:21,060 --> 00:11:27,029
GPS and compasses and then we assign the

00:11:24,240 --> 00:11:29,360
GPIO device for indicating some LEDs

00:11:27,029 --> 00:11:33,180
that indicate the current flight status

00:11:29,360 --> 00:11:36,959
and then on top of it we run a preamp RT

00:11:33,180 --> 00:11:38,760
patched Linux kernel and on top of the

00:11:36,959 --> 00:11:40,560
Linux kernel as as the user space

00:11:38,760 --> 00:11:45,360
application we run the auto pilot flight

00:11:40,560 --> 00:11:47,850
stack yeah and the rest of their system

00:11:45,360 --> 00:11:49,620
you can run any payload and it is

00:11:47,850 --> 00:11:51,990
guaranteed that it will not interfere in

00:11:49,620 --> 00:11:55,649
an unacceptable way with the other with

00:11:51,990 --> 00:11:57,779
the critical world so our approach was

00:11:55,649 --> 00:12:01,980
as follows we first wanted to develop

00:11:57,779 --> 00:12:04,589
the application without child house on

00:12:01,980 --> 00:12:07,199
bare metal so we did everything that you

00:12:04,589 --> 00:12:08,730
would have to do in any case so we we

00:12:07,199 --> 00:12:10,560
had to patch our kernel so we first

00:12:08,730 --> 00:12:12,899
applied the supreme authority patch

00:12:10,560 --> 00:12:15,000
stack later we modified Tegra device

00:12:12,899 --> 00:12:17,430
drivers to meet to meet our requirements

00:12:15,000 --> 00:12:19,829
and then we ported the auto pilot flight

00:12:17,430 --> 00:12:22,430
stack so we had to implement some motor

00:12:19,829 --> 00:12:26,250
drivers that were not supported before

00:12:22,430 --> 00:12:28,560
we had to implement battery sensing

00:12:26,250 --> 00:12:32,610
because our our hardware was not

00:12:28,560 --> 00:12:34,139
supported at this point and this is the

00:12:32,610 --> 00:12:36,569
stuff that that you would have to do in

00:12:34,139 --> 00:12:38,310
any case and later on we enable

00:12:36,569 --> 00:12:41,130
jailhouse and moved the critical

00:12:38,310 --> 00:12:42,930
software to the critical cell and we

00:12:41,130 --> 00:12:47,569
added some uncritical payload running in

00:12:42,930 --> 00:12:50,160
in the rest in the rest of the system so

00:12:47,569 --> 00:12:52,560
what was given is that child house

00:12:50,160 --> 00:12:56,850
already supports to run unpatched

00:12:52,560 --> 00:12:58,199
mainland linux on arm we it runs a

00:12:56,850 --> 00:13:01,079
premium torti patch kernel as i already

00:12:58,199 --> 00:13:03,209
said and we provide tiny tailored device

00:13:01,079 --> 00:13:04,560
trees to describe the configuration of

00:13:03,209 --> 00:13:06,480
the hardware so if you think of a

00:13:04,560 --> 00:13:10,170
typical device tree of a platform which

00:13:06,480 --> 00:13:12,120
is pretty huge we really only only pro

00:13:10,170 --> 00:13:14,939
describe the parts that we are really

00:13:12,120 --> 00:13:17,519
actually using so we describe the CPUs

00:13:14,939 --> 00:13:18,990
the memory region some devices that are

00:13:17,519 --> 00:13:22,350
assigned so that's that's a

00:13:18,990 --> 00:13:24,360
all that we defined there the user lands

00:13:22,350 --> 00:13:26,580
so the autopilot application is provided

00:13:24,360 --> 00:13:28,380
as an initial run disk so we run

00:13:26,580 --> 00:13:33,480
everything in memory we have no

00:13:28,380 --> 00:13:36,390
solid-state devices there and Inter cell

00:13:33,480 --> 00:13:41,490
network driver implemented by my mom's I

00:13:36,390 --> 00:13:43,020
think he is here hello Monza act as a

00:13:41,490 --> 00:13:45,060
communication channel between the

00:13:43,020 --> 00:13:46,800
critical and the uncritical world so we

00:13:45,060 --> 00:13:48,420
can simply for development this is very

00:13:46,800 --> 00:13:51,690
useful because we can simply SSH into

00:13:48,420 --> 00:13:55,250
our critical cell and run our and we

00:13:51,690 --> 00:13:57,750
have to all our development stuff so

00:13:55,250 --> 00:13:59,910
this was already given and now we want

00:13:57,750 --> 00:14:01,500
to assign devices through the critical

00:13:59,910 --> 00:14:04,860
cell and this is the port at the part

00:14:01,500 --> 00:14:07,800
where it got interesting so if you look

00:14:04,860 --> 00:14:11,310
at a device tree of a device we see that

00:14:07,800 --> 00:14:13,860
it consists of some memory region like

00:14:11,310 --> 00:14:16,320
this one here jailhouse already supports

00:14:13,860 --> 00:14:20,910
to remap that memory region through the

00:14:16,320 --> 00:14:22,649
to our critical cell and if this memory

00:14:20,910 --> 00:14:24,570
region would be aligned to the page size

00:14:22,649 --> 00:14:26,550
then there would be then there would be

00:14:24,570 --> 00:14:32,130
no need of trapping trapping the

00:14:26,550 --> 00:14:34,200
hypervisor or to intercept otherwise we

00:14:32,130 --> 00:14:37,110
need to otherwise so in this case we

00:14:34,200 --> 00:14:39,000
need to intercept because this size here

00:14:37,110 --> 00:14:41,040
is not aligned to the to the page size

00:14:39,000 --> 00:14:43,140
cello's then supports to re-inject

00:14:41,040 --> 00:14:46,740
interrupts so this device uses the

00:14:43,140 --> 00:14:48,959
peripheral interrupts 38 and we can

00:14:46,740 --> 00:14:50,850
simply be a safe in the our channel or

00:14:48,959 --> 00:14:52,290
cell configuration okay please remap the

00:14:50,850 --> 00:14:54,779
interrupt this interrupt she'll arrive

00:14:52,290 --> 00:14:55,980
in in that cell and with a little of

00:14:54,779 --> 00:14:58,200
overhead

00:14:55,980 --> 00:15:02,579
yeah the interrupt will eventually

00:14:58,200 --> 00:15:05,910
arrive in that cell but then we have

00:15:02,579 --> 00:15:09,690
those three guys left so clocks resets

00:15:05,910 --> 00:15:13,020
and DMAs so let's talk about clocks and

00:15:09,690 --> 00:15:17,940
reset so clocks peripheral devices are

00:15:13,020 --> 00:15:20,250
typically driven by clocks so device

00:15:17,940 --> 00:15:22,620
drivers typically engage clocks if the

00:15:20,250 --> 00:15:24,420
device is not in use this is mainly done

00:15:22,620 --> 00:15:26,339
because of power saving reasons

00:15:24,420 --> 00:15:28,790
especially this is especially important

00:15:26,339 --> 00:15:31,829
for battery driven environments

00:15:28,790 --> 00:15:32,740
clock drivers also support to select

00:15:31,829 --> 00:15:35,170
different speeds or

00:15:32,740 --> 00:15:38,830
portraits of the device and the reset

00:15:35,170 --> 00:15:41,410
lines help us to D assert or assert

00:15:38,830 --> 00:15:44,050
resets to to the devices to bring them

00:15:41,410 --> 00:15:45,910
back to their initial state so this is

00:15:44,050 --> 00:15:47,709
what so this is what the driver code

00:15:45,910 --> 00:15:49,660
typically looks like so we first enable

00:15:47,709 --> 00:15:52,060
the clock then assert and the assert a

00:15:49,660 --> 00:15:53,740
reset line do all the driving stuff here

00:15:52,060 --> 00:15:56,970
and later on when we are finished with

00:15:53,740 --> 00:16:01,270
this side of the clock again so but in

00:15:56,970 --> 00:16:04,209
so and those clock and reset controllers

00:16:01,270 --> 00:16:07,540
are typically organized as memory mapped

00:16:04,209 --> 00:16:09,630
i/o memory memory regions and so this is

00:16:07,540 --> 00:16:12,790
one memory region and every bit there

00:16:09,630 --> 00:16:15,850
describes the gate of a different clock

00:16:12,790 --> 00:16:18,330
and the problem is that this memory

00:16:15,850 --> 00:16:20,920
region controls the whole platform of

00:16:18,330 --> 00:16:26,110
controls our home a whole platform so

00:16:20,920 --> 00:16:28,930
this is really hard to partition so in

00:16:26,110 --> 00:16:30,580
our context we we have real-time league

00:16:28,930 --> 00:16:33,190
requirements and no low power

00:16:30,580 --> 00:16:35,800
requirements so we first thought okay

00:16:33,190 --> 00:16:39,480
let's statically get our clock before

00:16:35,800 --> 00:16:42,130
before we before we start our cell and

00:16:39,480 --> 00:16:43,480
we do we do not want to dynamically

00:16:42,130 --> 00:16:45,880
change the speed or portrait of the

00:16:43,480 --> 00:16:49,540
device so there is actually no need for

00:16:45,880 --> 00:16:53,079
for for clocks at all so let's just not

00:16:49,540 --> 00:16:55,029
define clocks in our in our cell in our

00:16:53,079 --> 00:16:57,010
device tree but it turned out that we

00:16:55,029 --> 00:16:58,540
must not ignore clocks because device

00:16:57,010 --> 00:17:00,670
drivers make the strong assumptions that

00:16:58,540 --> 00:17:03,310
clocks are always available and they are

00:17:00,670 --> 00:17:05,650
aware of the state of the clock the same

00:17:03,310 --> 00:17:08,980
is for reset lines so we must not ignore

00:17:05,650 --> 00:17:11,260
reset lines the driver will complain if

00:17:08,980 --> 00:17:13,870
you are if you're not providing the

00:17:11,260 --> 00:17:16,390
reset line so there there is no way out

00:17:13,870 --> 00:17:19,329
we have to somehow paravirtualized

00:17:16,390 --> 00:17:23,020
our clock and reset controller and we

00:17:19,329 --> 00:17:25,750
did this by providing a a child house

00:17:23,020 --> 00:17:28,000
clock and reset controller to to the

00:17:25,750 --> 00:17:30,850
critical cell and the hypervisor would

00:17:28,000 --> 00:17:33,550
trap if we access if you access that

00:17:30,850 --> 00:17:35,920
memory region and decide if this cell is

00:17:33,550 --> 00:17:39,910
allowed to gate or an get that clock or

00:17:35,920 --> 00:17:42,040
not and the same is for the Linux that

00:17:39,910 --> 00:17:44,800
was existing before so the uncritical

00:17:42,040 --> 00:17:46,360
saw this one will also trap so that an

00:17:44,800 --> 00:17:48,850
uncritical cell can not

00:17:46,360 --> 00:17:52,960
o'clock or gate o'clock of the critical

00:17:48,850 --> 00:17:55,779
part and vice versa the problem here is

00:17:52,960 --> 00:17:58,179
that we must define access bitmaps on a

00:17:55,779 --> 00:18:01,299
pretty granular level and this is really

00:17:58,179 --> 00:18:02,830
tedious and exhaustive so we are we are

00:18:01,299 --> 00:18:08,440
still say thinking about better ways of

00:18:02,830 --> 00:18:10,360
how we could define that yeah so now we

00:18:08,440 --> 00:18:12,279
have the clocks and resets defined in

00:18:10,360 --> 00:18:15,909
our cell then there's one thing missing

00:18:12,279 --> 00:18:17,470
a DMA controllers and again in the

00:18:15,909 --> 00:18:19,750
context of real-time systems where

00:18:17,470 --> 00:18:24,159
latency usually matters more than high

00:18:19,750 --> 00:18:27,720
throughput we just do not need DMA so

00:18:24,159 --> 00:18:31,570
our idea was okay so let's let's simply

00:18:27,720 --> 00:18:33,789
not provide the DMA channels and try to

00:18:31,570 --> 00:18:35,710
get rid of them but the point is here

00:18:33,789 --> 00:18:37,029
again the drivers make the make the

00:18:35,710 --> 00:18:38,980
assumption that the DMA channel is

00:18:37,029 --> 00:18:40,450
available even if they do not use it so

00:18:38,980 --> 00:18:41,710
we would have to patch the driver and he

00:18:40,450 --> 00:18:45,760
didn't want to patch the driver so

00:18:41,710 --> 00:18:47,830
fortunately on this on this platform we

00:18:45,760 --> 00:18:50,500
were able to exclusively assign the DMA

00:18:47,830 --> 00:18:52,630
controller to our critical cell because

00:18:50,500 --> 00:18:54,039
there there was no other device that was

00:18:52,630 --> 00:18:58,539
using the DMA controller in the

00:18:54,039 --> 00:19:01,269
uncritical path yeah so now we have

00:18:58,539 --> 00:19:03,309
novia now we have a real-time operating

00:19:01,269 --> 00:19:07,059
system running inside shell house

00:19:03,309 --> 00:19:08,350
we have MMI outpaced devices assigned to

00:19:07,059 --> 00:19:10,899
the critical cell we have a virtual

00:19:08,350 --> 00:19:12,760
clock interface and we have a child at a

00:19:10,899 --> 00:19:14,850
loss independent executing environment

00:19:12,760 --> 00:19:16,779
so we can run the same application

00:19:14,850 --> 00:19:19,419
inside tell us that we were running

00:19:16,779 --> 00:19:21,460
before without jail house so this makes

00:19:19,419 --> 00:19:27,669
it easy for us to port existing legacy

00:19:21,460 --> 00:19:29,409
applications yeah yeah and while the

00:19:27,669 --> 00:19:30,029
grid the uncritical cell is under full

00:19:29,409 --> 00:19:32,950
load

00:19:30,029 --> 00:19:34,149
we start our platform and we are ready

00:19:32,950 --> 00:19:38,789
to fly and I would like to show you a

00:19:34,149 --> 00:19:38,789
short video yeah

00:19:45,700 --> 00:19:56,840
let me go pickle it slide so you're

00:19:53,990 --> 00:19:59,120
talking about this one so this is part

00:19:56,840 --> 00:20:01,040
of the critical cell so this is this is

00:19:59,120 --> 00:20:03,230
this is not really part of the

00:20:01,040 --> 00:20:04,880
hypervisor that is part of we have to

00:20:03,230 --> 00:20:07,429
provide it through Linux so before

00:20:04,880 --> 00:20:10,929
putting Linux we have Linux we have you

00:20:07,429 --> 00:20:10,929
have to put it to internal memory and

00:20:11,049 --> 00:20:17,270
yes and you have to define the same

00:20:15,380 --> 00:20:21,040
memory regions and interrupts in our

00:20:17,270 --> 00:20:21,040
configuration of child house

00:20:30,249 --> 00:20:40,179
yes sir this is not our platform

00:20:32,629 --> 00:20:42,289
starting if I still is a bit clumsy but

00:20:40,179 --> 00:20:45,580
that's not because of cellos that's

00:20:42,289 --> 00:20:45,580
because of my pet flying skills

00:20:48,430 --> 00:20:51,589
[Music]

00:21:14,280 --> 00:21:20,200
and it's my red flying skills so now we

00:21:18,580 --> 00:21:24,880
got it running but let's talk about the

00:21:20,200 --> 00:21:26,320
about the performance of of cellos when

00:21:24,880 --> 00:21:31,600
running a real-time application inside

00:21:26,320 --> 00:21:33,160
it so we so as I already said we are

00:21:31,600 --> 00:21:34,990
reinfecting interrupts so if an

00:21:33,160 --> 00:21:36,730
interrupt arrives it first arrives in

00:21:34,990 --> 00:21:41,380
hypervisor context and then we re

00:21:36,730 --> 00:21:43,030
injected to our to our cell and we

00:21:41,380 --> 00:21:46,440
wanted to know what's the latency that

00:21:43,030 --> 00:21:49,090
is introduced by child house so we so we

00:21:46,440 --> 00:21:51,610
made a measurement and we externally

00:21:49,090 --> 00:21:53,470
toggled on GPIO waited till the

00:21:51,610 --> 00:21:56,110
interrupts arrived and then just talking

00:21:53,470 --> 00:21:58,210
another GPIO and measure the Latin the

00:21:56,110 --> 00:22:02,380
latency between between those two events

00:21:58,210 --> 00:22:05,140
so the green line here is is our

00:22:02,380 --> 00:22:07,390
stimulus and the blue line is the answer

00:22:05,140 --> 00:22:09,250
and if we are not running child house

00:22:07,390 --> 00:22:11,890
and if you are running a pair metal

00:22:09,250 --> 00:22:15,010
application which only which only tasks

00:22:11,890 --> 00:22:17,170
is to answer to the GP at to do toggle

00:22:15,010 --> 00:22:20,230
the other GPIO then we get a pair metal

00:22:17,170 --> 00:22:24,010
latency of 420 nanoseconds and this is

00:22:20,230 --> 00:22:26,170
the bare minimum of the hardware so what

00:22:24,010 --> 00:22:28,210
happens if we now enable our hypervisor

00:22:26,170 --> 00:22:31,000
of course we get a we get a performance

00:22:28,210 --> 00:22:33,160
drop and we drop from about 440

00:22:31,000 --> 00:22:40,380
nanoseconds to 1.2 microseconds yes

00:22:33,160 --> 00:22:40,380
please say it again

00:22:43,770 --> 00:22:49,300
now this is a really a bare-metal

00:22:46,030 --> 00:22:51,400
application so we talking about GPIO in

00:22:49,300 --> 00:22:54,940
assembler code in in the inside the

00:22:51,400 --> 00:22:56,860
interrupt service routine so this is

00:22:54,940 --> 00:22:59,410
this is the pair met a minimum that we

00:22:56,860 --> 00:23:01,540
can that we can get in on this platform

00:22:59,410 --> 00:23:04,780
and we'd let the same application run

00:23:01,540 --> 00:23:07,300
inside shell house and then we get one

00:23:04,780 --> 00:23:09,850
point two microseconds sub shell house

00:23:07,300 --> 00:23:11,620
introduces an overhead of about eight

00:23:09,850 --> 00:23:13,840
hundred nano seconds on average on this

00:23:11,620 --> 00:23:15,450
platform and on maximum this is what

00:23:13,840 --> 00:23:18,400
counts we get two point eight

00:23:15,450 --> 00:23:21,190
microseconds which is fairly okay for

00:23:18,400 --> 00:23:23,500
four for our requirements now it gets

00:23:21,190 --> 00:23:26,860
interesting what happens if we if we

00:23:23,500 --> 00:23:29,680
stress the other CPUs in the uncritical

00:23:26,860 --> 00:23:32,230
context because the system bus of the of

00:23:29,680 --> 00:23:34,570
the system is still shared we get a

00:23:32,230 --> 00:23:36,820
performance drop and on average we drop

00:23:34,570 --> 00:23:39,850
to one point to about one point four

00:23:36,820 --> 00:23:42,100
microseconds on average and to seven

00:23:39,850 --> 00:23:44,140
point five microseconds in maximum so

00:23:42,100 --> 00:23:49,020
this measurement was was done at a

00:23:44,140 --> 00:23:49,020
frequency of 50 Hertz and for four hours

00:23:52,650 --> 00:23:59,920
this was a stress test where we stressed

00:23:55,600 --> 00:24:05,260
very stressed memory i/o and yeah and

00:23:59,920 --> 00:24:13,030
CPUs yeah just keeping the cab the bus

00:24:05,260 --> 00:24:16,510
unload and as well keeping IO unload and

00:24:13,030 --> 00:24:19,120
then as I already told you the page size

00:24:16,510 --> 00:24:22,120
is the minimum if we if you want to do

00:24:19,120 --> 00:24:24,490
paging so we have to dispatch if we if

00:24:22,120 --> 00:24:27,220
we if you go if we want to assign a

00:24:24,490 --> 00:24:30,550
memory region that is smaller than the

00:24:27,220 --> 00:24:31,810
page size and then we have to we have to

00:24:30,550 --> 00:24:34,810
we have to trip to the earthly

00:24:31,810 --> 00:24:37,150
hypervisor and decide if if this guest

00:24:34,810 --> 00:24:39,580
is allowed to access the memory region

00:24:37,150 --> 00:24:42,520
or not and we made a we made a simple

00:24:39,580 --> 00:24:45,310
measurement where we use the the arm

00:24:42,520 --> 00:24:48,280
performance monitor counter to to see

00:24:45,310 --> 00:24:50,370
you have what kind of overhead is

00:24:48,280 --> 00:24:53,680
introduced when when it when it comes to

00:24:50,370 --> 00:24:58,210
when we have to dispatch those pages

00:24:53,680 --> 00:25:00,970
and without and it doesn't matter if you

00:24:58,210 --> 00:25:02,920
use chalice or not if we assign a 4-page

00:25:00,970 --> 00:25:04,810
so if we don't use sub paging then

00:25:02,920 --> 00:25:09,970
including the measurement overhead we

00:25:04,810 --> 00:25:11,350
have eight cycles and now if we and if

00:25:09,970 --> 00:25:13,510
we put the rest on the load so the

00:25:11,350 --> 00:25:16,020
system passes shared then we have about

00:25:13,510 --> 00:25:18,970
two hundred and seventeen cycles four

00:25:16,020 --> 00:25:21,700
four four memory access so now it gets

00:25:18,970 --> 00:25:24,550
interesting when we when we enable sub

00:25:21,700 --> 00:25:28,960
paging then we get a performance drop

00:25:24,550 --> 00:25:33,130
from two up to about 136 cycles for

00:25:28,960 --> 00:25:35,850
except for forgetting that the response

00:25:33,130 --> 00:25:40,540
of the hypervisor and a maxi maximum of

00:25:35,850 --> 00:25:42,850
about 1,000 cycles so if we again put

00:25:40,540 --> 00:25:44,980
load on the rest of the CPUs let me get

00:25:42,850 --> 00:25:49,690
a I mean again we get a performance drop

00:25:44,980 --> 00:25:52,260
to about three thousand cycles which is

00:25:49,690 --> 00:25:54,130
still okay in our case but this is a

00:25:52,260 --> 00:25:57,610
performance drop that is actually

00:25:54,130 --> 00:26:01,060
preventable if hardware vendors would

00:25:57,610 --> 00:26:03,670
place their devices on would place every

00:26:01,060 --> 00:26:04,810
device on a separate page and this is

00:26:03,670 --> 00:26:08,530
what brings me to the next point the

00:26:04,810 --> 00:26:11,740
requirements on hardware for yeah for

00:26:08,530 --> 00:26:14,380
hardware partitioning so memory mapped

00:26:11,740 --> 00:26:16,630
i/o if we look at at the address space

00:26:14,380 --> 00:26:19,240
of the of the i/o address space of our

00:26:16,630 --> 00:26:21,670
TK one then we can see that there are

00:26:19,240 --> 00:26:24,340
several several different I Square C

00:26:21,670 --> 00:26:29,290
devices located on the same memory page

00:26:24,340 --> 00:26:30,850
and even worse we have different

00:26:29,290 --> 00:26:32,890
functionality different devices of

00:26:30,850 --> 00:26:36,130
different functionalities on the same

00:26:32,890 --> 00:26:38,470
page here so sub paging leads to

00:26:36,130 --> 00:26:41,620
performance impacts and actually this

00:26:38,470 --> 00:26:44,410
platform has two gigabytes of of memory

00:26:41,620 --> 00:26:47,650
so we have two other gigabytes left for

00:26:44,410 --> 00:26:51,280
placing devices on on the on the i/o

00:26:47,650 --> 00:26:53,290
address space so this would give us

00:26:51,280 --> 00:26:56,020
enough space for placing fifty two

00:26:53,290 --> 00:26:57,760
thousand devices if we may make the make

00:26:56,020 --> 00:27:01,330
the pessimistic assumption that we need

00:26:57,760 --> 00:27:03,430
10 pages per device so please it would

00:27:01,330 --> 00:27:06,430
be nice if every device would be located

00:27:03,430 --> 00:27:07,979
at a at a at a separate on a separate

00:27:06,430 --> 00:27:10,899
page

00:27:07,979 --> 00:27:16,029
the next point is the clock and reset

00:27:10,899 --> 00:27:18,669
controllers so if it is possible it

00:27:16,029 --> 00:27:21,759
would be nice if clock and reset lines

00:27:18,669 --> 00:27:24,099
of a device would be located at the

00:27:21,759 --> 00:27:27,070
devices physical memory space and not at

00:27:24,099 --> 00:27:29,349
a con and not wash together to once see

00:27:27,070 --> 00:27:31,749
a contiguous memory region where we are

00:27:29,349 --> 00:27:33,969
controlling the whole platform so this

00:27:31,749 --> 00:27:36,909
would really help us for partitioning

00:27:33,969 --> 00:27:38,349
the hardware and this makes the clock

00:27:36,909 --> 00:27:41,049
and reset controller partition able for

00:27:38,349 --> 00:27:46,049
us otherwise again we need we need cost

00:27:41,049 --> 00:27:49,269
full power a pair of virtualization and

00:27:46,049 --> 00:27:50,979
direct memory access as I already said

00:27:49,269 --> 00:27:54,639
latency matters more than this Rupert

00:27:50,979 --> 00:27:56,409
and we don't want to use the MA channel

00:27:54,639 --> 00:27:58,059
so if you develop a device drivers

00:27:56,409 --> 00:28:00,579
please keep in mind that someone might

00:27:58,059 --> 00:28:02,339
want to partition their Hardware so

00:28:00,579 --> 00:28:06,669
please allow the absence of DMA channels

00:28:02,339 --> 00:28:08,859
if they are not really necessary for the

00:28:06,669 --> 00:28:12,309
driver and again otherwise we need cost

00:28:08,859 --> 00:28:15,579
full para virtualization and then I

00:28:12,309 --> 00:28:19,200
stumbled over an interesting of an

00:28:15,579 --> 00:28:24,489
interesting part so hardware misbehaves

00:28:19,200 --> 00:28:29,519
when implementing when implementing our

00:28:24,489 --> 00:28:32,469
platform I realized that if you touch a

00:28:29,519 --> 00:28:35,320
physical IO memory region with its clock

00:28:32,469 --> 00:28:36,479
and gated then the whole architecture

00:28:35,320 --> 00:28:38,709
the whole block form will immediately

00:28:36,479 --> 00:28:44,099
immediately freeze and stand still no

00:28:38,709 --> 00:28:46,839
kernel panic nothing and I sent this

00:28:44,099 --> 00:28:49,329
this report to the Tegra mailing list

00:28:46,839 --> 00:28:51,039
and they said yeah well we were sorry

00:28:49,329 --> 00:28:56,229
but this is the way the hardware behaves

00:28:51,039 --> 00:28:58,209
and another developer of Nvidia added it

00:28:56,229 --> 00:29:00,279
does apply to the whole architecture pre

00:28:58,209 --> 00:29:02,259
something so in in the in the in the

00:29:00,279 --> 00:29:05,229
latest version it got fixed but this

00:29:02,259 --> 00:29:07,899
pack is known and we need to be aware of

00:29:05,229 --> 00:29:10,929
that because when someone engaged a

00:29:07,899 --> 00:29:13,269
clock we need to hide the physical

00:29:10,929 --> 00:29:15,190
memory pages from that from that guest

00:29:13,269 --> 00:29:18,459
so that we can prevent that the whole

00:29:15,190 --> 00:29:20,450
architecture will standstill because an

00:29:18,459 --> 00:29:23,290
uncritical cell

00:29:20,450 --> 00:29:26,360
muscle in fluid influence a critical one

00:29:23,290 --> 00:29:29,200
and this brings me to the conclusion in

00:29:26,360 --> 00:29:31,880
future we have to take more attention on

00:29:29,200 --> 00:29:33,710
on hardware software code design so in

00:29:31,880 --> 00:29:35,750
the end of the day it's the hardware

00:29:33,710 --> 00:29:38,110
where our software runs on and it's the

00:29:35,750 --> 00:29:41,090
software that runs on the hardware and

00:29:38,110 --> 00:29:43,580
every work and every software software

00:29:41,090 --> 00:29:45,910
based workaround leads to leads to

00:29:43,580 --> 00:29:48,860
latency impacts leads to more overhead

00:29:45,910 --> 00:29:51,380
but still we were able to show a solely

00:29:48,860 --> 00:29:53,600
testament for implementing real-time

00:29:51,380 --> 00:29:57,770
safety critical mix criticality

00:29:53,600 --> 00:30:07,040
applications with a chav hypervisor so

00:29:57,770 --> 00:30:09,070
thank you very much and and if you have

00:30:07,040 --> 00:30:12,640
any questions do not hesitate to

00:30:09,070 --> 00:30:12,640
question me now yes please

00:30:15,700 --> 00:30:20,270
it supports arbitrary partitioning but

00:30:18,290 --> 00:30:20,780
you have to assign at least one CPU to a

00:30:20,270 --> 00:30:23,060
cell

00:30:20,780 --> 00:30:25,610
so the minimum configuration of a cell

00:30:23,060 --> 00:30:35,870
is you have one CPU and the region of

00:30:25,610 --> 00:30:39,500
memory that's the bare minimum so there

00:30:35,870 --> 00:30:42,200
is no on the idea of conditions there is

00:30:39,500 --> 00:30:44,300
no influence between between those cells

00:30:42,200 --> 00:30:56,440
so you can actually run any criticality

00:30:44,300 --> 00:30:56,440
on top of it yep there is influence but

00:31:00,670 --> 00:31:04,970
well you have deadlines and if you know

00:31:02,990 --> 00:31:06,530
that you can meet and if you know that

00:31:04,970 --> 00:31:12,410
you can meet those deadlines that's

00:31:06,530 --> 00:31:15,920
that's that's ok yeah so and yes there

00:31:12,410 --> 00:31:17,600
there is there is some overhead but if

00:31:15,920 --> 00:31:19,640
you know that if you can keep it as

00:31:17,600 --> 00:31:23,020
minimal as possible and if you can keep

00:31:19,640 --> 00:31:23,020
it deterministically minimal

00:31:23,220 --> 00:31:31,380
the kind of low-level CPU memory issue

00:31:27,930 --> 00:31:34,170
is not that at the cash level of the

00:31:31,380 --> 00:31:36,230
system because you can easily partition

00:31:34,170 --> 00:31:36,230
it

00:31:44,390 --> 00:31:53,080
you still share class so cashews

00:31:59,600 --> 00:32:04,470
yeah so the question is where the

00:32:01,710 --> 00:32:06,509
influences interference come from yeah

00:32:04,470 --> 00:32:08,610
so cash is one reason and I mentioned

00:32:06,509 --> 00:32:10,980
before on on intro for example we have

00:32:08,610 --> 00:32:13,169
now the cash partitioning mechanism in

00:32:10,980 --> 00:32:14,639
hardware available that probably will

00:32:13,169 --> 00:32:17,519
spread to other architectures well in

00:32:14,639 --> 00:32:19,470
the future that's one one reason but

00:32:17,519 --> 00:32:21,870
there of course there is more going on

00:32:19,470 --> 00:32:24,960
inside the hardware some of them you see

00:32:21,870 --> 00:32:27,149
on the on the diagrams as blocks and

00:32:24,960 --> 00:32:29,129
okay understandable but they also

00:32:27,149 --> 00:32:31,350
challenge really don't see because they

00:32:29,129 --> 00:32:34,080
are well hidden behind and maybe not

00:32:31,350 --> 00:32:35,549
documented oh gosh this is very

00:32:34,080 --> 00:32:37,639
important what I said before if you

00:32:35,549 --> 00:32:41,070
really want to go for a critical system

00:32:37,639 --> 00:32:43,019
certified for a certain functionality

00:32:41,070 --> 00:32:44,929
for certain behavior you have to include

00:32:43,019 --> 00:32:47,610
this kind of channels in your in your

00:32:44,929 --> 00:32:49,529
consideration as well either you have to

00:32:47,610 --> 00:32:51,299
argue okay there is influence but

00:32:49,529 --> 00:32:52,620
there's always influence but it doesn't

00:32:51,299 --> 00:32:54,509
matter because the deadline is to

00:32:52,620 --> 00:32:57,419
fulfill even if that influence is

00:32:54,509 --> 00:32:59,940
maximum exposed but you have to know

00:32:57,419 --> 00:33:01,590
this you have to detect it either if

00:32:59,940 --> 00:33:04,529
something goes completely wrong or you

00:33:01,590 --> 00:33:05,940
have to argue okay we know because of

00:33:04,529 --> 00:33:08,490
the architecture this can't happen

00:33:05,940 --> 00:33:09,840
that's basically the whole story so you

00:33:08,490 --> 00:33:10,850
can't really do this in software you

00:33:09,840 --> 00:33:13,649
have to do it

00:33:10,850 --> 00:33:16,610
co-designed with the hardware for this

00:33:13,649 --> 00:33:16,610
kind of sub scenarios

00:33:45,180 --> 00:33:51,460
but yeah okay it's okay yeah we saw one

00:33:49,720 --> 00:33:53,740
case today that's about the clocks and

00:33:51,460 --> 00:33:56,350
indicates of this in the red headlines

00:33:53,740 --> 00:33:58,720
where well basically you have one one

00:33:56,350 --> 00:34:00,220
resource controlling the whole platform

00:33:58,720 --> 00:34:03,340
or at least multiple devices you mention

00:34:00,220 --> 00:34:04,900
others case power controls so you have

00:34:03,340 --> 00:34:06,430
this already under on the core level and

00:34:04,900 --> 00:34:08,380
on some devices and some architectures

00:34:06,430 --> 00:34:10,450
that mean if you go down with a the

00:34:08,380 --> 00:34:12,190
power level of one core the other one

00:34:10,450 --> 00:34:14,169
may also go down or at least have a

00:34:12,190 --> 00:34:15,790
higher latency so you have these kind of

00:34:14,169 --> 00:34:18,490
interference channels and you have to

00:34:15,790 --> 00:34:21,280
identify them well if the hardware is

00:34:18,490 --> 00:34:23,710
not capable of allowing some kind of

00:34:21,280 --> 00:34:25,990
control then you may have lost there's

00:34:23,710 --> 00:34:29,580
no general answer to this except that

00:34:25,990 --> 00:34:29,580
you have to look at the individual cases

00:34:44,250 --> 00:34:49,630
okay so this is the kind of scenario of

00:34:47,860 --> 00:34:54,899
a shared pass so you have multiple

00:34:49,630 --> 00:34:54,899
devices on the bus and and only one host

00:35:00,570 --> 00:35:05,620
there are always cases which where where

00:35:03,250 --> 00:35:07,780
this static partitioning doesn't work

00:35:05,620 --> 00:35:10,120
well you can always fall back to do

00:35:07,780 --> 00:35:12,190
something in software split up this kind

00:35:10,120 --> 00:35:14,770
of interrelationship in software

00:35:12,190 --> 00:35:16,480
but this is not our first step it's the

00:35:14,770 --> 00:35:18,490
last resort on a platform which is

00:35:16,480 --> 00:35:20,500
otherwise nice but maybe has some

00:35:18,490 --> 00:35:22,090
shortcoming in this regard then you may

00:35:20,500 --> 00:35:24,820
consider software solution but this is

00:35:22,090 --> 00:35:26,650
all the trade-off basically how much

00:35:24,820 --> 00:35:28,720
effort you spent on the software and how

00:35:26,650 --> 00:35:30,760
much effort this costs you basically for

00:35:28,720 --> 00:35:34,740
for certain certification as efforts or

00:35:30,760 --> 00:35:37,050
a symbol of maintenance efforts yet

00:35:34,740 --> 00:35:38,430
you can even clarify the hypervisor

00:35:37,050 --> 00:35:40,619
thank you guys there

00:35:38,430 --> 00:35:44,220
it happened what asked because it

00:35:40,619 --> 00:35:46,170
actually controls not in terms of this

00:35:44,220 --> 00:35:49,140
research I mean in a traditional server

00:35:46,170 --> 00:35:50,510
kind of assistant if the hypervisor is

00:35:49,140 --> 00:35:53,990
responsible

00:35:50,510 --> 00:35:56,570
the whole hardware yeah okay so this is

00:35:53,990 --> 00:35:58,430
not the model we have here wherever

00:35:56,570 --> 00:36:00,050
possible we hand out the hardware

00:35:58,430 --> 00:36:02,240
directly to the guests

00:36:00,050 --> 00:36:04,490
so the hypervisor is in charge of

00:36:02,240 --> 00:36:06,950
controlling the CPUs with respect to

00:36:04,490 --> 00:36:09,950
this privileges that you need to give to

00:36:06,950 --> 00:36:12,290
the guest or not give to them it's in

00:36:09,950 --> 00:36:14,510
charge of certain interrupt aspects

00:36:12,290 --> 00:36:17,119
because interrupts usually well in some

00:36:14,510 --> 00:36:19,369
case you can route them directly but in

00:36:17,119 --> 00:36:20,920
many cases today you basically aren't

00:36:19,369 --> 00:36:23,599
charged as a hypervisor off of

00:36:20,920 --> 00:36:26,810
redirecting them and that's another task

00:36:23,599 --> 00:36:29,000
for the for the hypervisor and the page

00:36:26,810 --> 00:36:32,150
tables you have to the memory accesses

00:36:29,000 --> 00:36:34,270
that the gas issue and also the memory

00:36:32,150 --> 00:36:36,530
accesses the DMA X is the devices issue

00:36:34,270 --> 00:36:39,170
these are also controlled by the

00:36:36,530 --> 00:36:41,390
hypervisors in this particular case 2 TK

00:36:39,170 --> 00:36:43,250
1 we don't have the SMU implemented yet

00:36:41,390 --> 00:36:45,829
but it would be possible we have it on

00:36:43,250 --> 00:36:47,630
x86 running so this was not a task for

00:36:45,829 --> 00:36:49,160
the hypervisor and then there are some

00:36:47,630 --> 00:36:50,900
minor details I would say as a

00:36:49,160 --> 00:36:53,089
specialties of your architects the

00:36:50,900 --> 00:36:54,530
specialties of your board where you have

00:36:53,089 --> 00:36:56,119
to add something

00:36:54,530 --> 00:36:59,300
but in general we want to keep it very

00:36:56,119 --> 00:37:00,950
simple so this is the major major

00:36:59,300 --> 00:37:03,170
aspects I mentioned already and these

00:37:00,950 --> 00:37:04,790
are really the even cross architecture

00:37:03,170 --> 00:37:06,800
so the concepts apply across

00:37:04,790 --> 00:37:10,630
architectures it doesn't make the code

00:37:06,800 --> 00:37:10,630
to narak but at least the concepts

00:37:30,390 --> 00:37:40,960
I'm pretty well this is not rocket

00:37:39,250 --> 00:37:42,960
science and so say well there are some

00:37:40,960 --> 00:37:48,610
some minor details which are new but

00:37:42,960 --> 00:37:51,670
yeah you mentioned one and there are

00:37:48,610 --> 00:37:54,280
dozens out there implementing this on an

00:37:51,670 --> 00:37:57,370
arm implemented on x86 maybe on both

00:37:54,280 --> 00:37:59,170
maybe on something yeah yeah even on a

00:37:57,370 --> 00:38:00,550
better you have dozens of them so I

00:37:59,170 --> 00:38:02,320
heard the stories from automotive

00:38:00,550 --> 00:38:04,390
hypervisors there are many of them and

00:38:02,320 --> 00:38:05,770
they have all their pros and cons but

00:38:04,390 --> 00:38:07,900
they are not that many of you talk about

00:38:05,770 --> 00:38:09,430
the open-source market for example they

00:38:07,900 --> 00:38:11,590
are not that many was a small codebase

00:38:09,430 --> 00:38:13,870
so in case of an arm I think we have

00:38:11,590 --> 00:38:16,030
some seven or eight thousand lines of

00:38:13,870 --> 00:38:18,910
code for this architecture to implement

00:38:16,030 --> 00:38:21,970
this logic right now it's not complete

00:38:18,910 --> 00:38:24,100
but pretty close on x86 same situation

00:38:21,970 --> 00:38:26,590
basically and as far as I know all of

00:38:24,100 --> 00:38:28,900
the commercial ones to scheduling and we

00:38:26,590 --> 00:38:32,320
do no scheduling at all most of them

00:38:28,900 --> 00:38:34,600
yeah so this is really it's really for

00:38:32,320 --> 00:38:37,270
this specific purpose designed and we

00:38:34,600 --> 00:38:38,950
don't want to go beyond that so there

00:38:37,270 --> 00:38:42,700
are other solutions which can do more

00:38:38,950 --> 00:38:45,210
and which are already existing so that's

00:38:42,700 --> 00:38:45,210
not our goal

00:38:54,000 --> 00:39:01,470
yes both yes of course

00:38:58,230 --> 00:39:05,849
so because we do not want that the

00:39:01,470 --> 00:39:08,040
critical cell can can can somehow

00:39:05,849 --> 00:39:09,540
interfere with beyond critical one and

00:39:08,040 --> 00:39:11,280
vice versa so we do not want the

00:39:09,540 --> 00:39:13,380
uncritical one to interfere with with

00:39:11,280 --> 00:39:16,500
the critical world the question was if

00:39:13,380 --> 00:39:18,690
you if everyone is intercepting every

00:39:16,500 --> 00:39:20,790
memory access on a on a shared page on

00:39:18,690 --> 00:39:49,740
both of ourselves just to repeat it for

00:39:20,790 --> 00:39:51,630
the recording so I so the question was

00:39:49,740 --> 00:39:55,940
what happens if the critical cell

00:39:51,630 --> 00:39:59,609
accesses somewhat outside its scope or

00:39:55,940 --> 00:40:01,589
well if we don't assume this we can

00:39:59,609 --> 00:40:04,260
actually enforce us so we can apply the

00:40:01,589 --> 00:40:05,940
same enforcement on the on the

00:40:04,260 --> 00:40:08,430
containment on the on the memory access

00:40:05,940 --> 00:40:09,990
on the CPU X or whatever you resources

00:40:08,430 --> 00:40:11,819
your hand out on the critical as well on

00:40:09,990 --> 00:40:14,579
critical cell so there's no privilege

00:40:11,819 --> 00:40:16,140
right now in this regard for the privet

00:40:14,579 --> 00:40:18,480
for the critical cells there are other

00:40:16,140 --> 00:40:19,950
privileges but this is not in the scope

00:40:18,480 --> 00:40:21,589
because they also scenarios where you

00:40:19,950 --> 00:40:24,119
think about you have two critical cells

00:40:21,589 --> 00:40:26,819
basically monitoring themselves and if

00:40:24,119 --> 00:40:28,890
you now start basically dropping the

00:40:26,819 --> 00:40:31,890
access control for these cells you can't

00:40:28,890 --> 00:40:33,660
no longer argue that these to each other

00:40:31,890 --> 00:40:35,400
monitoring cells are independent of each

00:40:33,660 --> 00:40:36,780
other they can actually override each

00:40:35,400 --> 00:40:42,599
other and then you basically lost your

00:40:36,780 --> 00:40:45,470
argument not trusted no no at least from

00:40:42,599 --> 00:40:45,470
the hypervisor ponder here

00:41:04,750 --> 00:41:08,650
sorry I didn't get the last one

00:41:12,520 --> 00:41:18,040
okay yeah so the question is what what

00:41:15,790 --> 00:41:20,080
mechanisms we do apply on the on the

00:41:18,040 --> 00:41:22,420
shared memory communication channel to

00:41:20,080 --> 00:41:25,300
ensure the isolation so so right now the

00:41:22,420 --> 00:41:27,160
the model which is in the release the

00:41:25,300 --> 00:41:30,250
ordered six release is basically a

00:41:27,160 --> 00:41:31,990
symmetrical readwrite memory region so

00:41:30,250 --> 00:41:34,300
both sides see the same memory region

00:41:31,990 --> 00:41:37,390
physically and can interfere with each

00:41:34,300 --> 00:41:38,890
other happily on this memory gene that's

00:41:37,390 --> 00:41:40,360
the current model implemented but we

00:41:38,890 --> 00:41:43,750
also have a staging tree where we

00:41:40,360 --> 00:41:46,480
implement two independent channels which

00:41:43,750 --> 00:41:48,250
is a unidirectional so one side can

00:41:46,480 --> 00:41:50,619
read/write on this channel the others I

00:41:48,250 --> 00:41:52,420
can only read from it that makes of

00:41:50,619 --> 00:41:54,970
course argumentation of a protocols

00:41:52,420 --> 00:41:56,200
built on top a bit easier that they are

00:41:54,970 --> 00:41:57,850
not really interfering which are of

00:41:56,200 --> 00:42:01,690
course it is interference channel

00:41:57,850 --> 00:42:04,090
logically but you have to you have to

00:42:01,690 --> 00:42:06,250
apply certain additional measures on the

00:42:04,090 --> 00:42:09,130
software being built on top that they

00:42:06,250 --> 00:42:11,080
don't violate the protocol you want to

00:42:09,130 --> 00:42:13,960
implement on top so that's basically

00:42:11,080 --> 00:42:16,600
model what but mons was now implementing

00:42:13,960 --> 00:42:19,960
on top of this device is basically a

00:42:16,600 --> 00:42:21,730
Linux driver doing a virtual network

00:42:19,960 --> 00:42:23,950
device on both ends and that's what we

00:42:21,730 --> 00:42:26,200
are applauding here and that works both

00:42:23,950 --> 00:42:27,580
for this unit area over the moat

00:42:26,200 --> 00:42:30,100
erection alloys as well as the

00:42:27,580 --> 00:42:31,900
unidirectional channel but you have the

00:42:30,100 --> 00:42:33,460
same you have the same problem if you

00:42:31,900 --> 00:42:35,380
have an if you have an architecture

00:42:33,460 --> 00:42:36,850
where you have separate devices so even

00:42:35,380 --> 00:42:39,609
then there is some communication channel

00:42:36,850 --> 00:42:42,330
between those two devices and yeah you

00:42:39,609 --> 00:42:42,330
have to be aware of that

00:42:45,110 --> 00:42:49,730
like how you would utilize this on a

00:42:47,630 --> 00:42:53,320
different platform like what is involved

00:42:49,730 --> 00:42:53,320
like I might say

00:42:58,750 --> 00:43:03,590
so in the question is how to to port it

00:43:01,790 --> 00:43:05,600
on a different architecture so yeah well

00:43:03,590 --> 00:43:07,580
so if you look at the readme we have

00:43:05,600 --> 00:43:10,010
some some architectural requirements on

00:43:07,580 --> 00:43:11,180
the Tartar platform so we require for

00:43:10,010 --> 00:43:14,120
example an armed which will add 8

00:43:11,180 --> 00:43:16,220
extensions on the intel vt-x and vtd on

00:43:14,120 --> 00:43:18,110
am be the corresponding features that

00:43:16,220 --> 00:43:20,480
spaces with the fundamental requirement

00:43:18,110 --> 00:43:23,000
so currently we are on the x86 on the

00:43:20,480 --> 00:43:25,040
arm world with reporting so if you go

00:43:23,000 --> 00:43:27,650
for a different SOC or a different board

00:43:25,040 --> 00:43:29,780
and these days on our Middle East it's

00:43:27,650 --> 00:43:33,230
it's pretty simple and that you buy

00:43:29,780 --> 00:43:35,330
basically an arm be 8 for example and

00:43:33,230 --> 00:43:37,190
you just have to describe the hardware

00:43:35,330 --> 00:43:38,810
and if you're unlucky you maybe also

00:43:37,190 --> 00:43:42,410
have to implement for debugging purposes

00:43:38,810 --> 00:43:44,540
mostly and a driver for the you are to

00:43:42,410 --> 00:43:47,090
the console of the hypervisor is dumped

00:43:44,540 --> 00:43:49,160
on the physical device and you see

00:43:47,090 --> 00:43:50,750
basically what's happening if something

00:43:49,160 --> 00:43:53,510
is not working initially it's a normal

00:43:50,750 --> 00:43:55,940
case that you bring up is not smooth and

00:43:53,510 --> 00:43:58,340
you have to tune a little bit but then

00:43:55,940 --> 00:44:00,290
the dependency is very very minimal so

00:43:58,340 --> 00:44:01,190
they are currently well this state right

00:44:00,290 --> 00:44:10,730
now

00:44:01,190 --> 00:44:12,350
no further hardware dependencies though

00:44:10,730 --> 00:44:14,510
we don't have we don't have drivers

00:44:12,350 --> 00:44:16,640
currently except for the the console

00:44:14,510 --> 00:44:19,610
drivers at this moment because we didn't

00:44:16,640 --> 00:44:22,340
solve properly the clock topic yet which

00:44:19,610 --> 00:44:24,550
may lead to drive us or mail it if you

00:44:22,340 --> 00:44:27,080
are lucky to a more generic pattern

00:44:24,550 --> 00:44:29,570
access control pattern but there might

00:44:27,080 --> 00:44:31,400
be some need so on XD 6 for example we

00:44:29,570 --> 00:44:33,200
have a driver so to say for the

00:44:31,400 --> 00:44:35,270
interrupt controller it interprets

00:44:33,200 --> 00:44:38,200
basically the access and then decides if

00:44:35,270 --> 00:44:38,200
an access is allowed or not allowed

00:44:42,600 --> 00:44:49,610
that's today handle bootloaders what

00:44:46,260 --> 00:44:49,610
your bare metal

00:44:55,050 --> 00:45:01,780
no we don't expect too much from the pre

00:45:00,250 --> 00:45:03,550
configuration of the heart we just

00:45:01,780 --> 00:45:05,530
expected the current user of the

00:45:03,550 --> 00:45:08,020
hardware Linux is not further

00:45:05,530 --> 00:45:09,310
configuring it so basically we take over

00:45:08,020 --> 00:45:13,240
control in the hypervisor of the

00:45:09,310 --> 00:45:16,180
hardware we freeze the state and we only

00:45:13,240 --> 00:45:18,070
interfere or in control the accesses

00:45:16,180 --> 00:45:20,829
which we really need to have keep

00:45:18,070 --> 00:45:22,720
dynamic during runtime so there's no

00:45:20,829 --> 00:45:24,910
further assumption basically on this but

00:45:22,720 --> 00:45:26,619
of course if we look for the details

00:45:24,910 --> 00:45:28,300
later on I suppose there will be fur

00:45:26,619 --> 00:45:30,970
that checks are required and further

00:45:28,300 --> 00:45:32,680
well validation needed of the platform

00:45:30,970 --> 00:45:36,490
state before really declaring it to be

00:45:32,680 --> 00:45:38,170
safely partitioned that's that's work in

00:45:36,490 --> 00:45:40,390
progress and that depends of course also

00:45:38,170 --> 00:45:41,770
and information that we just are

00:45:40,390 --> 00:45:51,119
starting to collect from the hardware

00:45:41,770 --> 00:45:51,119
vendors on this we've got the questions

00:45:51,390 --> 00:45:59,949
thank you

00:45:53,930 --> 00:45:59,949

YouTube URL: https://www.youtube.com/watch?v=pvs0fv-gnvw


