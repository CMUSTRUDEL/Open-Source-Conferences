Title: SCHED_DEADLINE: It's Alive! - Juri Lelli, ARM Ltd.
Publication date: 2017-02-27
Playlist: Embedded Linux Conference + OpenIoT Summit NA 2017
Description: 
	SCHED_DEADLINE: It's Alive! - Juri Lelli, ARM Ltd.

After deadline scheduling for processes (SCHED_DEADLINE scheduling policy) has been merged in the Linux kernel in Mar-2014 (version 3.14) a considerable effort has been put into actively maintaining it, but no further development really happened after that date - until now!

In this presentation, Juri Lelli, after giving a (very briefly) review of the current set of features, will deep dive into the details of all the new features currently under development: CPU capacity and clock frequency scaling, bandwidth reclaiming, coupling with clock frequency selection and cgroups support.

He will then conclude the presentation reviewing the list of open problems and (extremely cool) desired features - who knows if he can attract even more willing developers?! For the moment, credits go to the collaborative effort between ARM, Luca Abeni and Scuola Superiore Sant'Anna of Pisa.

About Juri Lelli
Juri Lelli received a BS and a MS in Computer Engineering at the University of Pisa (Italy). He then earned a PhD degree at the Scuola Superiore Santâ€™Anna of Pisa, Italy (ReTiS Lab). He is one of the original authors of the SCHED_DEADLINE scheduling policy in Linux, and he is actively helping maintaining it. He is currently working at ARM Ltd., where he continues contributing to the Linux scheduler development, with a special focus on energy aware scheduling and power management.
Captions: 
	00:00:00,060 --> 00:00:07,080
thanks for coming muta lately some of

00:00:03,959 --> 00:00:08,940
you already know working for forearm

00:00:07,080 --> 00:00:11,550
I've been working from for last three

00:00:08,940 --> 00:00:14,370
years being following the energyaware

00:00:11,550 --> 00:00:17,550
scheduler effort I'll talk about it a

00:00:14,370 --> 00:00:19,439
bit later but basically I'm here to say

00:00:17,550 --> 00:00:22,199
that I don't know if you actually know

00:00:19,439 --> 00:00:25,289
skedaddling but it's actually a life so

00:00:22,199 --> 00:00:27,410
that's basically the main news have here

00:00:25,289 --> 00:00:30,570
I think I mean that there is people

00:00:27,410 --> 00:00:32,430
sitting over there if you can come

00:00:30,570 --> 00:00:34,440
forward it's probably easy also for me I

00:00:32,430 --> 00:00:36,239
mean it's not a big deal

00:00:34,440 --> 00:00:38,790
and you actually see it like there are

00:00:36,239 --> 00:00:41,790
all these spaces here I want I mean

00:00:38,790 --> 00:00:45,079
would be pretty relaxed presentation or

00:00:41,790 --> 00:00:50,149
just thanks i won I mean that would be

00:00:45,079 --> 00:00:53,489
just won't make any question anything so

00:00:50,149 --> 00:00:55,399
hey thanks a lot well actually I'm lying

00:00:53,489 --> 00:00:59,219
so I'll actually make questions because

00:00:55,399 --> 00:01:01,350
the problem is that I had to assume in

00:00:59,219 --> 00:01:03,090
this presentation that you have a little

00:01:01,350 --> 00:01:06,330
background on what skedaddling is

00:01:03,090 --> 00:01:09,210
because I won't have time to cover the

00:01:06,330 --> 00:01:12,000
basics and I cover the new features so

00:01:09,210 --> 00:01:14,729
I'll be making questions and I also get

00:01:12,000 --> 00:01:19,080
prizes so let's see how he goes all

00:01:14,729 --> 00:01:22,170
right that's the intended agenda

00:01:19,080 --> 00:01:26,189
quickly covered there is one slight set

00:01:22,170 --> 00:01:29,850
in the background of skedaddling then

00:01:26,189 --> 00:01:32,610
basically there is a why so why all of a

00:01:29,850 --> 00:01:35,820
sudden we have this new set of features

00:01:32,610 --> 00:01:38,189
that we actually developing and then I

00:01:35,820 --> 00:01:40,229
will cover the the features that are

00:01:38,189 --> 00:01:42,299
actually been a development so there

00:01:40,229 --> 00:01:44,299
will be been reclaiming and a frequency

00:01:42,299 --> 00:01:48,210
and c2 scaling

00:01:44,299 --> 00:01:51,119
coupling and with the frequency

00:01:48,210 --> 00:01:54,979
selections or c2 fair governor and then

00:01:51,119 --> 00:02:02,189
group chattering okay let's get started

00:01:54,979 --> 00:02:05,399
so what am Y data initially so this

00:02:02,189 --> 00:02:06,090
thing has been around for something like

00:02:05,399 --> 00:02:11,370
three years

00:02:06,090 --> 00:02:13,110
it's being merged in 314 kernel and I'm

00:02:11,370 --> 00:02:13,920
saying that it's alive now because

00:02:13,110 --> 00:02:17,430
busily in Russ

00:02:13,920 --> 00:02:19,709
three years I basically had been

00:02:17,430 --> 00:02:23,130
maintaining it that there's been like

00:02:19,709 --> 00:02:26,340
several bucks to fix and other stuff to

00:02:23,130 --> 00:02:29,069
do but nothing major actually happened

00:02:26,340 --> 00:02:30,150
on this on this scale only shadow in

00:02:29,069 --> 00:02:31,800
class

00:02:30,150 --> 00:02:33,810
what's the schedule in schedule is

00:02:31,800 --> 00:02:37,020
basically another scheduling class in is

00:02:33,810 --> 00:02:41,280
an RT shadow in policy RT like for

00:02:37,020 --> 00:02:43,500
example scatter our schedule and the

00:02:41,280 --> 00:02:48,120
difference is that using schibetta you

00:02:43,500 --> 00:02:50,730
can actually recently give actually the

00:02:48,120 --> 00:02:52,830
the kernel pearl / tusk latency

00:02:50,730 --> 00:02:56,760
constraints so there is actually an API

00:02:52,830 --> 00:02:59,700
we which you can give this information

00:02:56,760 --> 00:03:01,980
to the kernel and it basically the

00:02:59,700 --> 00:03:05,010
algorithm itself by design avoid

00:03:01,980 --> 00:03:07,290
starvation in general it's basically

00:03:05,010 --> 00:03:09,930
reaching the general knowledge about the

00:03:07,290 --> 00:03:13,170
quality of service constraints that task

00:03:09,930 --> 00:03:15,959
might have it basically implements EDF

00:03:13,170 --> 00:03:19,560
and CBS and that's the first question

00:03:15,959 --> 00:03:26,150
so who's gonna tell me what EDF and CBS

00:03:19,560 --> 00:03:35,070
sends for okay okay

00:03:26,150 --> 00:03:37,769
CBS anybody yet so you actually get a

00:03:35,070 --> 00:03:40,739
price so this question was actually to

00:03:37,769 --> 00:03:44,100
paint I love one pan handed to you this

00:03:40,739 --> 00:03:45,810
is very our nice pan this is for you are

00:03:44,100 --> 00:03:47,850
putting here then you can collect up

00:03:45,810 --> 00:03:51,870
force I mean as you know I mean there

00:03:47,850 --> 00:03:54,540
are pretty cheap items but we do opt in

00:03:51,870 --> 00:03:58,140
expensive chips in arm so that's that's

00:03:54,540 --> 00:04:04,980
why right so CBS who's gonna tell me for

00:03:58,140 --> 00:04:06,989
another pen nobody really right so I get

00:04:04,980 --> 00:04:10,620
my pen and CBS stands for constant

00:04:06,989 --> 00:04:13,500
bandwidth server it's they're actually

00:04:10,620 --> 00:04:16,049
nice theory isn't a nice thing here

00:04:13,500 --> 00:04:18,750
because EDF is basically pretty dummy so

00:04:16,049 --> 00:04:20,940
you busy schedule the task with the

00:04:18,750 --> 00:04:23,580
early settling it's like a priority

00:04:20,940 --> 00:04:25,380
based algorithm based on deadlines but

00:04:23,580 --> 00:04:27,780
then I think is as the CBS it's an

00:04:25,380 --> 00:04:30,960
algorithm and this algorithm X

00:04:27,780 --> 00:04:33,420
the peaks the let's say the dynamic the

00:04:30,960 --> 00:04:35,760
dynamic deadlines of the the different

00:04:33,420 --> 00:04:37,560
tasks and actually is that algorithm

00:04:35,760 --> 00:04:41,120
that he makes

00:04:37,560 --> 00:04:44,990
for example temporal oscillation and

00:04:41,120 --> 00:04:49,200
starvation avoiding servation possible

00:04:44,990 --> 00:04:51,330
alright if you want to actually have

00:04:49,200 --> 00:04:54,330
more details I actually gave a

00:04:51,330 --> 00:04:58,139
presentation to last year ELC you find

00:04:54,330 --> 00:05:01,040
the link there and true through the

00:04:58,139 --> 00:05:04,710
slides also be referring to papers

00:05:01,040 --> 00:05:07,860
describing the algorithms so you can

00:05:04,710 --> 00:05:13,650
actually go and offline search more

00:05:07,860 --> 00:05:18,030
about this so but why this developing is

00:05:13,650 --> 00:05:20,520
now happening well why is that in arm we

00:05:18,030 --> 00:05:22,440
been working in the last four or five

00:05:20,520 --> 00:05:25,500
years on this finger we call the

00:05:22,440 --> 00:05:28,320
energyaware scheduling it's basically a

00:05:25,500 --> 00:05:30,660
serial set of extension to what the

00:05:28,320 --> 00:05:33,360
Linux kernel Scheidler and several

00:05:30,660 --> 00:05:36,900
subsystems for examples if you freak to

00:05:33,360 --> 00:05:40,650
actually make them power and performance

00:05:36,900 --> 00:05:43,380
aware so both like meeting the

00:05:40,650 --> 00:05:47,970
performance requirements of user space

00:05:43,380 --> 00:05:52,110
application while saving energy and the

00:05:47,970 --> 00:05:54,270
effort so far has only been basically

00:05:52,110 --> 00:05:58,880
modifying and taking care of modifying

00:05:54,270 --> 00:06:02,280
scan normal shadow wise then last year

00:05:58,880 --> 00:06:04,979
this set of changes got merged in the

00:06:02,280 --> 00:06:08,550
Android common kernel and is basically

00:06:04,979 --> 00:06:11,669
now used by Android and then in that

00:06:08,550 --> 00:06:15,150
particular case basically for Android

00:06:11,669 --> 00:06:18,960
performance for the workloads that we

00:06:15,150 --> 00:06:21,120
care most it's actually meaning meeting

00:06:18,960 --> 00:06:24,060
latency requirements more than actually

00:06:21,120 --> 00:06:25,979
performing more work so when you

00:06:24,060 --> 00:06:26,880
actually have strict latency

00:06:25,979 --> 00:06:29,970
requirements

00:06:26,880 --> 00:06:31,740
squared Norma can be maybe it's not like

00:06:29,970 --> 00:06:34,470
the best feed and what's actually

00:06:31,740 --> 00:06:37,409
happening currently is that scat five or

00:06:34,470 --> 00:06:40,320
so RT scheduling in class and policy are

00:06:37,409 --> 00:06:41,880
currently used to actually be able to

00:06:40,320 --> 00:06:44,810
meet this

00:06:41,880 --> 00:06:46,139
latency requirements for certain tasks

00:06:44,810 --> 00:06:49,830
now

00:06:46,139 --> 00:06:53,280
basically my point here is that for the

00:06:49,830 --> 00:06:56,099
same I actually believe I had to pull

00:06:53,280 --> 00:06:58,650
this because this is really experimental

00:06:56,099 --> 00:07:01,020
and work-in-progress stuff that I'm

00:06:58,650 --> 00:07:04,319
actually gonna talk about but I really

00:07:01,020 --> 00:07:06,690
believe that for the same use case is we

00:07:04,319 --> 00:07:08,880
can actually make better job using

00:07:06,690 --> 00:07:12,479
deadlines it should be is theoretically

00:07:08,880 --> 00:07:14,150
better feet and actually also they say

00:07:12,479 --> 00:07:17,520
that Android definitely already does

00:07:14,150 --> 00:07:20,070
make some modification to the main lines

00:07:17,520 --> 00:07:23,430
get FIFO and I'm not sure that those

00:07:20,070 --> 00:07:25,620
modification can ever get upstream just

00:07:23,430 --> 00:07:27,780
because I guess the feeling that I he

00:07:25,620 --> 00:07:30,930
goes from and penises that sched fifo

00:07:27,780 --> 00:07:33,240
it's probably not the best thing you

00:07:30,930 --> 00:07:35,310
want to modify its that you probably

00:07:33,240 --> 00:07:37,620
have to do to share data so what I'm

00:07:35,310 --> 00:07:40,860
saying is that if we know and we know

00:07:37,620 --> 00:07:42,960
that we are gonna make modification to

00:07:40,860 --> 00:07:45,080
scattering in those discussing those or

00:07:42,960 --> 00:07:50,370
many lives should be less contentious

00:07:45,080 --> 00:07:54,870
that's my personal feeling yeah actually

00:07:50,370 --> 00:07:56,669
I want to mention that the bees this

00:07:54,870 --> 00:07:58,380
work it's awfully arm doing this but we

00:07:56,669 --> 00:08:00,180
are basically collaborating currently

00:07:58,380 --> 00:08:02,870
with scholar superiores Santana of Pisa

00:08:00,180 --> 00:08:05,849
scores for Santana pieces basically the

00:08:02,870 --> 00:08:09,000
University have been studying before

00:08:05,849 --> 00:08:12,030
drawing arm and actually be the oldest

00:08:09,000 --> 00:08:14,580
Catalan project was born there so while

00:08:12,030 --> 00:08:16,110
I was there actually we got this thing

00:08:14,580 --> 00:08:18,509
melt so it's basically the same guys

00:08:16,110 --> 00:08:25,710
they continue work you know on the

00:08:18,509 --> 00:08:30,320
project all right okay so those that was

00:08:25,710 --> 00:08:35,370
basically a general introduction but

00:08:30,320 --> 00:08:38,990
let's yeah let's talk about what are the

00:08:35,370 --> 00:08:42,390
new features so when we're reclaiming

00:08:38,990 --> 00:08:44,880
what's the problem with the current ask

00:08:42,390 --> 00:08:47,010
a deadline implementation so I guess the

00:08:44,880 --> 00:08:49,920
main problem the main thing that we

00:08:47,010 --> 00:08:52,850
might be problematic while trying to use

00:08:49,920 --> 00:08:55,390
cadet lean for basically soft real-time

00:08:52,850 --> 00:08:58,149
type of application like program

00:08:55,390 --> 00:09:02,920
droid rendering pipeline is that the

00:08:58,149 --> 00:09:05,320
task bandits so the amount of CPU decay

00:09:02,920 --> 00:09:07,149
and actually associated to the task is

00:09:05,320 --> 00:09:10,899
fixed so basically you have this

00:09:07,149 --> 00:09:12,370
syscalls called ask etc you call it for

00:09:10,899 --> 00:09:15,700
your task and then you basically

00:09:12,370 --> 00:09:17,680
associate a runtime and a period to this

00:09:15,700 --> 00:09:20,290
task so it's better a fraction of CPU

00:09:17,680 --> 00:09:22,750
time and that it's actually enforced so

00:09:20,290 --> 00:09:25,390
if the task tries to execute for more

00:09:22,750 --> 00:09:27,790
then it's actually granted to him it

00:09:25,390 --> 00:09:29,320
will be stopped and that I mean it can

00:09:27,790 --> 00:09:31,540
be problematic because for example what

00:09:29,320 --> 00:09:33,910
happens if you work actually need more

00:09:31,540 --> 00:09:37,899
badly that what you actually ask for I

00:09:33,910 --> 00:09:40,870
don't know there may be plucked a

00:09:37,899 --> 00:09:43,899
showing the network traffic or for

00:09:40,870 --> 00:09:45,850
example if you are it's ask that belongs

00:09:43,899 --> 00:09:48,610
to a rendering pipeline there may be

00:09:45,850 --> 00:09:51,370
some certain heavy frames you actually

00:09:48,610 --> 00:09:53,589
have to render and just for one of those

00:09:51,370 --> 00:09:56,220
you need more bandwidth so you might be

00:09:53,589 --> 00:09:59,200
missing your deadlines just because the

00:09:56,220 --> 00:10:00,940
binary location is so strict so the

00:09:59,200 --> 00:10:03,250
proposed solution and it's proposed

00:10:00,940 --> 00:10:07,060
basically there are there been at least

00:10:03,250 --> 00:10:09,339
four sets under discussion on the new

00:10:07,060 --> 00:10:11,740
scary mini list that is going to be most

00:10:09,339 --> 00:10:15,100
probably a posting like next week or

00:10:11,740 --> 00:10:17,620
week after next it's something that we

00:10:15,100 --> 00:10:20,620
call bandwidth reclaiming the idea is

00:10:17,620 --> 00:10:22,930
that you would allow tasks to consume

00:10:20,620 --> 00:10:26,560
more than what they're being allocated

00:10:22,930 --> 00:10:33,940
at Cisco time at the admission control

00:10:26,560 --> 00:10:35,740
time of course to don't risk to dropper

00:10:33,940 --> 00:10:37,870
dies everything everybody else so

00:10:35,740 --> 00:10:41,170
because we have still scared others get

00:10:37,870 --> 00:10:43,300
FIFO tasks you can allow this

00:10:41,170 --> 00:10:46,480
recognition to happen up to a maximum of

00:10:43,300 --> 00:10:49,390
the CPU time and of course if if this

00:10:46,480 --> 00:10:50,589
doesn't break others sky deadlines

00:10:49,390 --> 00:10:54,870
guarantees so you don't want to

00:10:50,589 --> 00:10:54,870
jeopardize other scheduling tasks

00:10:57,209 --> 00:11:03,579
alright so the algorithm that we

00:11:00,370 --> 00:11:06,339
actually implement is called grab it

00:11:03,579 --> 00:11:07,410
stands for greedy reclamation of a news

00:11:06,339 --> 00:11:10,889
bandwidth

00:11:07,410 --> 00:11:14,609
and I guess I mean well it can be a bit

00:11:10,889 --> 00:11:16,139
tricky to understand the I mean the

00:11:14,609 --> 00:11:18,299
particularity of this algorithm but I

00:11:16,139 --> 00:11:22,410
guess the name is actually give you a

00:11:18,299 --> 00:11:26,549
big hint because basically the basic

00:11:22,410 --> 00:11:29,249
idea is that when I live so I will omit

00:11:26,549 --> 00:11:32,729
some some tasks to the system and I will

00:11:29,249 --> 00:11:35,159
have a fraction of the CPU time spare so

00:11:32,729 --> 00:11:39,269
nobody's using the time and the idea is

00:11:35,159 --> 00:11:42,899
that the task is currently running will

00:11:39,269 --> 00:11:44,909
greedily use the portion or bandwidth

00:11:42,899 --> 00:11:47,309
that is not currently used by the others

00:11:44,909 --> 00:11:50,369
so that's why greedy reclamation of a

00:11:47,309 --> 00:11:53,129
new spend and that makes the

00:11:50,369 --> 00:11:56,549
implementation algorithm more very

00:11:53,129 --> 00:11:59,609
simple it's really a minor modification

00:11:56,549 --> 00:12:03,029
that actually be made to implement this

00:11:59,609 --> 00:12:06,149
thing so it basically composed by three

00:12:03,029 --> 00:12:10,619
main components one is we had to track

00:12:06,149 --> 00:12:12,179
the utilization of the active tasks so

00:12:10,619 --> 00:12:14,429
the tasks that are currently active on

00:12:12,179 --> 00:12:19,350
the system because we want to reclaim

00:12:14,429 --> 00:12:21,600
the portion that is not active then we

00:12:19,350 --> 00:12:24,629
have we can use this information to

00:12:21,600 --> 00:12:26,879
modify the accounting rule it is

00:12:24,629 --> 00:12:30,600
basically how we keep track of the

00:12:26,879 --> 00:12:34,739
runtime that we actually are granting to

00:12:30,600 --> 00:12:37,139
tasks and then when I quickly go through

00:12:34,739 --> 00:12:39,629
one of the issues that we found out

00:12:37,139 --> 00:12:41,600
while implementing this thing and xn

00:12:39,629 --> 00:12:44,459
need the support to multiprocessor

00:12:41,600 --> 00:12:47,129
system so the original item was actually

00:12:44,459 --> 00:12:51,029
designed for uniprocessors so as soon as

00:12:47,129 --> 00:12:52,829
you try to support multiprocessor you

00:12:51,029 --> 00:12:55,649
fight Semmy issue cell and I'll detail

00:12:52,829 --> 00:12:59,159
about one of those just to give you an

00:12:55,649 --> 00:13:02,459
idea I said there are references to the

00:12:59,159 --> 00:13:07,889
papers and you can find way more details

00:13:02,459 --> 00:13:10,079
there okay so let's try to understand

00:13:07,889 --> 00:13:12,599
what tracking of the active duty

00:13:10,079 --> 00:13:15,659
relation means I guess this is basic

00:13:12,599 --> 00:13:18,179
this and the next one are conducted most

00:13:15,659 --> 00:13:20,230
Ricky slides of the whole presentation

00:13:18,179 --> 00:13:22,770
so please be

00:13:20,230 --> 00:13:26,880
let's see if we can get through this

00:13:22,770 --> 00:13:29,650
alright so I make an example to try to

00:13:26,880 --> 00:13:32,200
make this thing easier so let's say that

00:13:29,650 --> 00:13:35,230
you have a task that has a built into

00:13:32,200 --> 00:13:37,630
the system and of course this has a run

00:13:35,230 --> 00:13:41,740
time and a period the run time here is

00:13:37,630 --> 00:13:44,410
depicted by the capital Qi and the

00:13:41,740 --> 00:13:46,090
period is capital T I so those are the

00:13:44,410 --> 00:13:49,750
two parameters who actually specified

00:13:46,090 --> 00:13:52,900
when called in the schedule set at Cisco

00:13:49,750 --> 00:13:55,990
now this last let's say that was

00:13:52,900 --> 00:14:00,850
sleeping then it activates for a first

00:13:55,990 --> 00:14:04,780
time during during a period the the idea

00:14:00,850 --> 00:14:07,570
is that you will be tracking the sum or

00:14:04,780 --> 00:14:11,800
the act utilization of all the tasks per

00:14:07,570 --> 00:14:15,580
CPU so you have we basically added a

00:14:11,800 --> 00:14:16,990
pair run Q a variable called running

00:14:15,580 --> 00:14:19,630
bandwidth that actually keeps track

00:14:16,990 --> 00:14:21,400
could be some so when the task wakes up

00:14:19,630 --> 00:14:22,930
for first time is pretty easy so you

00:14:21,400 --> 00:14:25,750
know that its bandwidth issues

00:14:22,930 --> 00:14:30,400
realization is busy at runtime divided

00:14:25,750 --> 00:14:34,930
by period so Qi divided by T I and you

00:14:30,400 --> 00:14:37,630
can just increase you act by this amount

00:14:34,930 --> 00:14:41,290
of bandwidth as soon as it's ask wakes

00:14:37,630 --> 00:14:45,150
up so that you know that the other task

00:14:41,290 --> 00:14:49,810
cannot reclaim these stars batteries

00:14:45,150 --> 00:14:50,950
okay that's easy then the tricky bit is

00:14:49,810 --> 00:14:54,670
that what happens

00:14:50,950 --> 00:14:57,870
so the tricky bit is understanding when

00:14:54,670 --> 00:15:02,290
you can actually remove this task

00:14:57,870 --> 00:15:04,390
contribution from you act because the

00:15:02,290 --> 00:15:05,020
problem is that if for example the task

00:15:04,390 --> 00:15:08,740
goes to sleep

00:15:05,020 --> 00:15:10,990
and you remove isn't honestly is a

00:15:08,740 --> 00:15:13,000
contribution to the reclaiming so its

00:15:10,990 --> 00:15:15,060
contribution to the active utilization

00:15:13,000 --> 00:15:18,550
the other task can actually reclaim

00:15:15,060 --> 00:15:20,860
instantaneously his his bandwidth so if

00:15:18,550 --> 00:15:24,490
he then wakes up again in the same

00:15:20,860 --> 00:15:27,160
period he could actually found out that

00:15:24,490 --> 00:15:30,460
the others used his bandwidth so it will

00:15:27,160 --> 00:15:33,010
be basically potentially jeopardize so

00:15:30,460 --> 00:15:34,150
you don't want that let's say that there

00:15:33,010 --> 00:15:36,040
are basically two things

00:15:34,150 --> 00:15:38,470
take a nap and one is the simplest one

00:15:36,040 --> 00:15:41,200
the simplest one is the task executes

00:15:38,470 --> 00:15:44,740
for a bit I'm not a bit in this one what

00:15:41,200 --> 00:15:46,390
I'm using is the more tricky one but

00:15:44,740 --> 00:15:48,700
let's say that the the simplest one is

00:15:46,390 --> 00:15:52,750
just a sexy routine and then it consumes

00:15:48,700 --> 00:15:55,420
all its runtime in this period in that

00:15:52,750 --> 00:15:58,090
case it will be throttled because we

00:15:55,420 --> 00:15:59,650
implement basically throttling and at

00:15:58,090 --> 00:16:02,740
that point in time you can you actually

00:15:59,650 --> 00:16:04,420
know that you can remove is usually is

00:16:02,740 --> 00:16:06,910
contribution to Beatrice realization

00:16:04,420 --> 00:16:10,090
just because we already depleted all

00:16:06,910 --> 00:16:13,750
it's available runtime but what happens

00:16:10,090 --> 00:16:17,440
if the task actually goes to sleep and

00:16:13,750 --> 00:16:22,120
there's some left over runtime to

00:16:17,440 --> 00:16:24,610
consume now the tricky bit is that you

00:16:22,120 --> 00:16:27,130
have to remember what the constant

00:16:24,610 --> 00:16:29,980
bandwidth is server does when the task

00:16:27,130 --> 00:16:32,770
wakes up there is one of the rules

00:16:29,980 --> 00:16:39,640
implemented but algorithm that checks

00:16:32,770 --> 00:16:42,550
this inequality so second question we're

00:16:39,640 --> 00:16:45,910
gonna tell me what this what this

00:16:42,550 --> 00:16:50,590
inequality actually checks so why do we

00:16:45,910 --> 00:16:55,420
want to check use the remaining runtime

00:16:50,590 --> 00:16:57,100
divided by basically deadlines - this

00:16:55,420 --> 00:17:00,750
amount of time where the task wakes up

00:16:57,100 --> 00:17:12,280
and compare that with the theoretical

00:17:00,750 --> 00:17:17,670
worst case benefit any idea plea not so

00:17:12,280 --> 00:17:20,650
basically let's see if I can help you I

00:17:17,670 --> 00:17:24,630
said the task goes to sleep at this

00:17:20,650 --> 00:17:28,780
decision time it has some runtime

00:17:24,630 --> 00:17:32,910
leftover runtime then you want to know

00:17:28,780 --> 00:17:37,930
if it wakes up in the in the same period

00:17:32,910 --> 00:17:40,360
if he's gonna use its runtime as the

00:17:37,930 --> 00:17:41,950
leftover runtime no matter what the

00:17:40,360 --> 00:17:43,540
problem is that a fee weights up for

00:17:41,950 --> 00:17:46,410
example here pretty close to the

00:17:43,540 --> 00:17:47,660
deadline it will actually go and execute

00:17:46,410 --> 00:17:51,080
for

00:17:47,660 --> 00:17:53,960
I mean using more than what allocated

00:17:51,080 --> 00:17:55,190
just because it's basically free to

00:17:53,960 --> 00:17:57,590
execute because it's probably the

00:17:55,190 --> 00:17:59,600
highest priority task so if there is for

00:17:57,590 --> 00:18:02,330
example other tasks running concurrently

00:17:59,600 --> 00:18:07,100
we deem it will basically execute in

00:18:02,330 --> 00:18:10,490
this in the other task reservation so

00:18:07,100 --> 00:18:13,789
this this thing actually just check if

00:18:10,490 --> 00:18:20,330
we can recycle or not the current

00:18:13,789 --> 00:18:22,610
runtime so basically what we do in

00:18:20,330 --> 00:18:24,860
practice is that when the task goes to

00:18:22,610 --> 00:18:27,320
sleep we actually have to compute this

00:18:24,860 --> 00:18:30,740
point in that in the o time in the

00:18:27,320 --> 00:18:32,539
future called the zero lock time this is

00:18:30,740 --> 00:18:34,820
actually deriving from this inequality

00:18:32,539 --> 00:18:38,900
so basically you make this an equality

00:18:34,820 --> 00:18:40,970
and then you calculate T from this thing

00:18:38,900 --> 00:18:43,309
and T is actually your zero zero lock

00:18:40,970 --> 00:18:48,289
time so basically you know that after

00:18:43,309 --> 00:18:51,559
this is an enzyme the task cannot reuse

00:18:48,289 --> 00:18:53,990
the leftover because if he actually is

00:18:51,559 --> 00:18:59,480
gonna use the relate for let leftover is

00:18:53,990 --> 00:19:01,690
gonna cause troubles to other tasks more

00:18:59,480 --> 00:19:01,690
or less

00:19:04,580 --> 00:19:16,159
nore okay okay okay let's say that maybe

00:19:12,799 --> 00:19:18,679
you believe me so it's bitly what what's

00:19:16,159 --> 00:19:20,840
happening so you go to sleep you compute

00:19:18,679 --> 00:19:23,419
this thing and you actually set a timer

00:19:20,840 --> 00:19:28,760
to fire this instant in time that we

00:19:23,419 --> 00:19:30,730
remove the task man read from the you

00:19:28,760 --> 00:19:35,960
you act that's in practice how the

00:19:30,730 --> 00:19:37,340
implementation works okay so that that's

00:19:35,960 --> 00:19:40,190
for see that's the tracking of

00:19:37,340 --> 00:19:44,630
activities ation this thing happens on

00:19:40,190 --> 00:19:50,750
each CPU all right now that you have

00:19:44,630 --> 00:19:53,179
your active utilization thing you can

00:19:50,750 --> 00:19:59,630
actually use that to implement the

00:19:53,179 --> 00:20:03,110
reclaiming itself the current county

00:19:59,630 --> 00:20:05,210
rule it's pretty easy because basically

00:20:03,110 --> 00:20:08,360
task a task that wakes up and starts

00:20:05,210 --> 00:20:11,600
executing at each tick you actually call

00:20:08,360 --> 00:20:14,149
this function called update who deal at

00:20:11,600 --> 00:20:16,100
each tick also the last time when a task

00:20:14,149 --> 00:20:20,240
goes to sleep and this function

00:20:16,100 --> 00:20:23,149
basically uses the Delta X X so it's the

00:20:20,240 --> 00:20:26,000
basically the deltas between the last

00:20:23,149 --> 00:20:27,919
time and now it can be formally second

00:20:26,000 --> 00:20:30,860
one millisecond dependence on the hearth

00:20:27,919 --> 00:20:33,830
rate and then decrement that decrement

00:20:30,860 --> 00:20:36,169
the runtime of that value so that you

00:20:33,830 --> 00:20:38,269
know when the task will be depleting is

00:20:36,169 --> 00:20:42,320
run time because you then want to stop

00:20:38,269 --> 00:20:47,740
the task as soon as the run time becomes

00:20:42,320 --> 00:20:51,049
zero or negative to be able to actually

00:20:47,740 --> 00:20:54,799
reclaim the others bandit the idea is

00:20:51,049 --> 00:20:59,120
that you want to reclaim basically so

00:20:54,799 --> 00:21:01,610
you act is is a value that go that's

00:20:59,120 --> 00:21:06,230
between one and zero so it's a fraction

00:21:01,610 --> 00:21:08,809
of the hundred percent CPU time that is

00:21:06,230 --> 00:21:12,169
that you want to reclaim one minus the

00:21:08,809 --> 00:21:15,919
US and if you do the math you actually

00:21:12,169 --> 00:21:17,380
come up with this dissipation here so

00:21:15,919 --> 00:21:19,990
instead of removing

00:21:17,380 --> 00:21:22,960
the whole data except you actually move

00:21:19,990 --> 00:21:25,510
in a fraction of the depth of that delt

00:21:22,960 --> 00:21:30,460
except to make an example if the task

00:21:25,510 --> 00:21:33,430
it's 30 percent utilization tasks you

00:21:30,460 --> 00:21:37,690
will multiply in the Delta check by 0.3

00:21:33,430 --> 00:21:39,580
so if you execute for 9 millisecond you

00:21:37,690 --> 00:21:41,470
can actually you actually remove 3

00:21:39,580 --> 00:21:46,240
milliseconds so basically you have more

00:21:41,470 --> 00:21:49,510
time to complete but that I mean if you

00:21:46,240 --> 00:21:53,530
actually allow to these tasks to

00:21:49,510 --> 00:21:55,960
actually reclaim a hundred percent of

00:21:53,530 --> 00:21:58,260
CPU time that will be a problem for non

00:21:55,960 --> 00:22:04,870
deadlight tasks so you will end up

00:21:58,260 --> 00:22:06,970
starving other other guys simple example

00:22:04,870 --> 00:22:10,960
to try to understand better at this

00:22:06,970 --> 00:22:14,740
point is so let's say that you have five

00:22:10,960 --> 00:22:17,140
second over ten second task they can

00:22:14,740 --> 00:22:21,750
actually be cream so if you can reclaim

00:22:17,140 --> 00:22:24,130
100% recipe you what what does it happen

00:22:21,750 --> 00:22:28,270
anybody they can help me here

00:22:24,130 --> 00:22:29,800
because that's actually another quit so

00:22:28,270 --> 00:22:33,820
this is probably easier to to to

00:22:29,800 --> 00:22:36,250
computer let's say so what's the current

00:22:33,820 --> 00:22:39,400
UX so consider there is only these tasks

00:22:36,250 --> 00:22:43,830
on the rank you and as a runtime of of

00:22:39,400 --> 00:22:49,030
five second and a period of ten second

00:22:43,830 --> 00:22:53,880
sorry 0.5 so 0.5 is actually the current

00:22:49,030 --> 00:22:57,100
you act so let's say that this does is

00:22:53,880 --> 00:22:59,620
executing and busy at each is the mean

00:22:57,100 --> 00:23:02,530
time let's say that it executes for one

00:22:59,620 --> 00:23:05,530
millisecond but instead of removing one

00:23:02,530 --> 00:23:09,580
millisecond of runtime from each runtime

00:23:05,530 --> 00:23:12,820
how much you remove by using this

00:23:09,580 --> 00:23:15,130
formula here point five so better you

00:23:12,820 --> 00:23:19,290
remove 0.5 millisecond every one

00:23:15,130 --> 00:23:19,290
millisecond if you do this for

00:23:19,770 --> 00:23:23,980
considering that the runtime is a

00:23:21,460 --> 00:23:26,020
five-second basically you will lap in

00:23:23,980 --> 00:23:28,480
security for 10 seconds and that's

00:23:26,020 --> 00:23:30,790
basically all you'll be constantly

00:23:28,480 --> 00:23:33,580
executing over your period

00:23:30,790 --> 00:23:37,750
let's basically I give you a USB pen

00:23:33,580 --> 00:23:42,250
because anyway I have it here so that's

00:23:37,750 --> 00:23:45,070
basically what happens you multiply by

00:23:42,250 --> 00:23:46,270
0.5 and you will deplete in your runtime

00:23:45,070 --> 00:23:49,210
in ten seconds

00:23:46,270 --> 00:23:51,250
so that's that's basically if the task

00:23:49,210 --> 00:23:53,740
doesn't reclaim it gets stopped after

00:23:51,250 --> 00:23:56,620
five seconds and the other task can

00:23:53,740 --> 00:23:59,170
actually run and they're happy but then

00:23:56,620 --> 00:24:01,630
if you implement reclaiming and it's

00:23:59,170 --> 00:24:04,540
unbounded it asked we constantly execute

00:24:01,630 --> 00:24:07,060
over the 10-second and constantly do

00:24:04,540 --> 00:24:13,920
that so the others cannot execute

00:24:07,060 --> 00:24:19,630
anymore does it make sense okay so the

00:24:13,920 --> 00:24:21,610
the solution here and you well again you

00:24:19,630 --> 00:24:25,260
had a bit to believe me here but that's

00:24:21,610 --> 00:24:28,660
basically easy to compute is to actually

00:24:25,260 --> 00:24:33,790
have another variable called u max that

00:24:28,660 --> 00:24:36,040
you can actually set to be the limit or

00:24:33,790 --> 00:24:37,570
bender you can actually claim in this

00:24:36,040 --> 00:24:40,030
case for example in the same as there

00:24:37,570 --> 00:24:42,940
was if you said the the max to be 0.9

00:24:40,030 --> 00:24:45,760
the task will only reclaim up to 90

00:24:42,940 --> 00:24:48,370
percent of the available run time and so

00:24:45,760 --> 00:24:49,780
basically get to execute for maximum

00:24:48,370 --> 00:24:53,580
nine seconds and you will have one

00:24:49,780 --> 00:24:55,630
second of time for the others to execute

00:24:53,580 --> 00:24:58,770
that's basically a solution for this

00:24:55,630 --> 00:25:02,590
problem okay

00:24:58,770 --> 00:25:04,110
yeah multi-process or let's say that we

00:25:02,590 --> 00:25:06,790
actually discover did this problem

00:25:04,110 --> 00:25:08,920
address because they said like rhythm

00:25:06,790 --> 00:25:11,200
was actually designed for a single

00:25:08,920 --> 00:25:14,170
processor let's say that you have two

00:25:11,200 --> 00:25:16,720
CPUs and you have a task that goes to

00:25:14,170 --> 00:25:19,180
sleep a decision in time so you actually

00:25:16,720 --> 00:25:22,560
when you woke up the first time he is a

00:25:19,180 --> 00:25:26,860
contribution to the you act has been

00:25:22,560 --> 00:25:28,060
added to the U vector of CPU K then it

00:25:26,860 --> 00:25:33,240
goes to sleep

00:25:28,060 --> 00:25:35,950
you set the zero lag timer but then

00:25:33,240 --> 00:25:37,810
let's say that when he wakes up again so

00:25:35,950 --> 00:25:40,800
in this point in time it wakes up again

00:25:37,810 --> 00:25:43,270
you have another higher priority task

00:25:40,800 --> 00:25:43,780
executing on their own CPU K in this

00:25:43,270 --> 00:25:44,290
case

00:25:43,780 --> 00:25:46,380
so that

00:25:44,290 --> 00:25:49,510
is actually put to to run or another CPU

00:25:46,380 --> 00:25:52,390
since basically naughty happens if the

00:25:49,510 --> 00:25:57,250
task wakes up before the zero like time

00:25:52,390 --> 00:25:58,720
at the you act of the CPU the task force

00:25:57,250 --> 00:26:00,490
are in on what you do is best if you

00:25:58,720 --> 00:26:02,590
don't do anything to the you act you

00:26:00,490 --> 00:26:04,630
just remove the zero like time but then

00:26:02,590 --> 00:26:06,900
when the task actually for example

00:26:04,630 --> 00:26:11,530
depletes his run time you'll be

00:26:06,900 --> 00:26:15,130
subtracting his contribution to CPU j UF

00:26:11,530 --> 00:26:20,290
and that's gonna be a bug because it's

00:26:15,130 --> 00:26:23,500
basically it's gonna be negative so in

00:26:20,290 --> 00:26:26,350
this case the fix was pretty simple so

00:26:23,500 --> 00:26:30,760
basically what we do when the task it's

00:26:26,350 --> 00:26:35,560
actually migrating you both cancel the

00:26:30,760 --> 00:26:38,110
zero lifetime and also instantaneously

00:26:35,560 --> 00:26:41,290
migrate the task contribution between

00:26:38,110 --> 00:26:44,820
the two CPUs so that every t everything

00:26:41,290 --> 00:26:53,290
is fine where the task is blocked again

00:26:44,820 --> 00:27:01,840
all right okay some simple data and

00:26:53,290 --> 00:27:04,810
results form from from synthetics I said

00:27:01,840 --> 00:27:10,810
this is working progress basically my

00:27:04,810 --> 00:27:13,480
next step as I will tell you in a while

00:27:10,810 --> 00:27:15,550
is to try and start using this thing for

00:27:13,480 --> 00:27:17,910
example Android but I mean this thing is

00:27:15,550 --> 00:27:22,510
basically a simple example here I have

00:27:17,910 --> 00:27:25,350
one task that is executing inside a six

00:27:22,510 --> 00:27:28,510
minute second over 20 millisecond

00:27:25,350 --> 00:27:30,760
reservation it ask it actually has a

00:27:28,510 --> 00:27:32,770
constant execution time so every time is

00:27:30,760 --> 00:27:35,170
activated is a sickening four five

00:27:32,770 --> 00:27:38,320
millisecond you have another task on a

00:27:35,170 --> 00:27:40,210
single CPU here that actually has

00:27:38,320 --> 00:27:42,970
reservation of forty five millisecond

00:27:40,210 --> 00:27:44,890
over 260 milliseconds the problem with

00:27:42,970 --> 00:27:47,650
this task is that it experiences

00:27:44,890 --> 00:27:49,750
occasional variation in its actual

00:27:47,650 --> 00:27:52,150
runtime so it varies between 35

00:27:49,750 --> 00:27:55,210
millisecond and 52 millisecond so there

00:27:52,150 --> 00:27:57,470
will be ISA enzyme which I will try to

00:27:55,210 --> 00:28:01,600
execute for more than 40

00:27:57,470 --> 00:28:05,660
45 millisecond and you see here that

00:28:01,600 --> 00:28:08,390
basically this is task 2 without

00:28:05,660 --> 00:28:10,460
reclaiming here I'm basically depicting

00:28:08,390 --> 00:28:15,770
a cumulative distribution function of

00:28:10,460 --> 00:28:17,630
the major major a response time or a

00:28:15,770 --> 00:28:19,760
task at each activation so we actually

00:28:17,630 --> 00:28:22,280
measure how much time the task actually

00:28:19,760 --> 00:28:25,840
required to finish its current

00:28:22,280 --> 00:28:30,130
activation and basically this means that

00:28:25,840 --> 00:28:38,300
there are there is basically at least

00:28:30,130 --> 00:28:41,200
40% 35 40 % of the cases in which the 25

00:28:38,300 --> 00:28:43,790
may be a bit less money there is a known

00:28:41,200 --> 00:28:46,010
percentage of the degree of activation

00:28:43,790 --> 00:28:50,450
of tasks to in which the response time

00:28:46,010 --> 00:28:53,809
is actually higher than the then then

00:28:50,450 --> 00:28:56,000
what tasks to actually wanted the 260

00:28:53,809 --> 00:28:57,730
milliseconds so and that's why that was

00:28:56,000 --> 00:29:00,500
basically at the prom and I was telling

00:28:57,730 --> 00:29:05,420
right at the start that these mechanisms

00:29:00,500 --> 00:29:10,160
to restrict is to fixed using instead

00:29:05,420 --> 00:29:14,210
reclaiming so reclaiming basically the 1

00:29:10,160 --> 00:29:16,520
millisecond plus up to the U max that

00:29:14,210 --> 00:29:19,750
you set up in in the system you can

00:29:16,520 --> 00:29:24,760
actually attach to can actually always

00:29:19,750 --> 00:29:27,590
in this case finish before is a

00:29:24,760 --> 00:29:30,200
reservation period so that's basically

00:29:27,590 --> 00:29:32,179
meeting always is deadlines that's

00:29:30,200 --> 00:29:42,760
basically it depicts easily how the

00:29:32,179 --> 00:29:46,250
logarithm actually helps and works ok so

00:29:42,760 --> 00:29:50,390
once this is in what we need so the idea

00:29:46,250 --> 00:29:54,410
is that we since now we assume that the

00:29:50,390 --> 00:29:56,900
clock frequency was fixed and that's

00:29:54,410 --> 00:29:58,630
when the clock frequency is fixed it's

00:29:56,900 --> 00:30:02,480
easier because Ben's basically you can

00:29:58,630 --> 00:30:04,309
ignore the fact that the runtime of your

00:30:02,480 --> 00:30:07,280
task every scales with the clock

00:30:04,309 --> 00:30:08,870
frequency but what happens if the clock

00:30:07,280 --> 00:30:11,539
frequency varies

00:30:08,870 --> 00:30:15,650
it's pretty simple to actually deal with

00:30:11,539 --> 00:30:17,510
it we just have to scale the reservation

00:30:15,650 --> 00:30:20,210
runtime so the idea is that the scenes

00:30:17,510 --> 00:30:22,309
basically you can assume that the actual

00:30:20,210 --> 00:30:24,440
runtime scales linearly with the

00:30:22,309 --> 00:30:28,370
frequency you'll be skill scaling

00:30:24,440 --> 00:30:30,679
literally also the runtime it's a the

00:30:28,370 --> 00:30:32,150
best case runtime and that's the formula

00:30:30,679 --> 00:30:33,950
you have to apply you barely take the

00:30:32,150 --> 00:30:37,159
original runtime and then you multiply

00:30:33,950 --> 00:30:39,409
by the ratio between Max and current

00:30:37,159 --> 00:30:42,770
frequency and that basically allows your

00:30:39,409 --> 00:30:44,419
task to steal executors in inside the

00:30:42,770 --> 00:30:46,760
same reservation without modifying the

00:30:44,419 --> 00:30:49,010
reservation so you specify your

00:30:46,760 --> 00:30:52,429
parameters considering the highest OPP

00:30:49,010 --> 00:30:56,110
so let's say 10 millisecond over 100

00:30:52,429 --> 00:30:59,090
millisecond and then you let the runtime

00:30:56,110 --> 00:31:02,240
adapt to the current frequency using

00:30:59,090 --> 00:31:11,270
this formula that's basically the idea

00:31:02,240 --> 00:31:16,760
yes yes the basically that the algorithm

00:31:11,270 --> 00:31:20,720
works in the same way I actually have an

00:31:16,760 --> 00:31:24,590
example here probably answering your

00:31:20,720 --> 00:31:28,970
question so let's say I run these tests

00:31:24,590 --> 00:31:32,960
on a keyboard their keyboard has 5

00:31:28,970 --> 00:31:34,220
operating points in the a 53 CPUs those

00:31:32,960 --> 00:31:38,480
are the operating points so it goes

00:31:34,220 --> 00:31:43,360
between from 280 mega to 1.2 Biggers and

00:31:38,480 --> 00:31:46,970
their associated capacity in 1024 scale

00:31:43,360 --> 00:31:49,399
so the formula let's say that you have a

00:31:46,970 --> 00:31:52,460
nice task this actually has 12 milli

00:31:49,399 --> 00:31:56,120
second over 100 millisecond reservation

00:31:52,460 --> 00:31:58,250
at max frequency that translate for

00:31:56,120 --> 00:32:01,250
example if you then try to run the task

00:31:58,250 --> 00:32:03,230
at minimum frequency that roughly 269

00:32:01,250 --> 00:32:05,750
milliseconds so you'll let to extend the

00:32:03,230 --> 00:32:07,789
runtime the 12 millisecond up to 69

00:32:05,750 --> 00:32:09,740
millisecond and it's actually what

00:32:07,789 --> 00:32:12,020
what's happening so here basically in

00:32:09,740 --> 00:32:15,500
the force in the first plot I'm running

00:32:12,020 --> 00:32:17,390
the task so obviously running a 10

00:32:15,500 --> 00:32:20,510
millisecond over hundred millisecond

00:32:17,390 --> 00:32:22,400
task inside d12 millisecond a hundred

00:32:20,510 --> 00:32:25,910
millisecond reservation so I

00:32:22,400 --> 00:32:28,540
is fine the task computes and end up

00:32:25,910 --> 00:32:32,360
computing before it's actually trotted

00:32:28,540 --> 00:32:35,930
if I then run the same but the minimum

00:32:32,360 --> 00:32:39,440
frequency the extra run time is extended

00:32:35,930 --> 00:32:41,270
I mean it takes 60 milliseconds then to

00:32:39,440 --> 00:32:43,370
actually execute the same amount of work

00:32:41,270 --> 00:32:45,140
and that's still fine because I know

00:32:43,370 --> 00:32:47,360
that my reservation actually get

00:32:45,140 --> 00:32:49,430
extended to six in a millisecond so as

00:32:47,360 --> 00:32:52,040
soon at the task for example here I

00:32:49,430 --> 00:32:55,160
incremental of 10 millisecond the third

00:32:52,040 --> 00:32:57,200
one the actual runtime and tasks so as

00:32:55,160 --> 00:32:59,270
soon as stuff in this case tries to it

00:32:57,200 --> 00:33:01,880
executed for more than sixteen I mean

00:32:59,270 --> 00:33:04,720
it's exactly throttle so the algorithm

00:33:01,880 --> 00:33:12,260
is actually working hosted consistently

00:33:04,720 --> 00:33:14,470
yeah right so for the question is what

00:33:12,260 --> 00:33:17,860
about Basel II big little systems and

00:33:14,470 --> 00:33:21,260
basically it's the last point I had here

00:33:17,860 --> 00:33:24,410
you have to apply the very same formula

00:33:21,260 --> 00:33:28,280
but considering the max capacity of the

00:33:24,410 --> 00:33:29,930
two of the two CPUs type basically it

00:33:28,280 --> 00:33:32,180
will be you have to scale twice

00:33:29,930 --> 00:33:33,770
Yusuke one for the frequency and then

00:33:32,180 --> 00:33:36,710
you take the same as scale again

00:33:33,770 --> 00:33:39,590
comparing the max capacity of the CPUs

00:33:36,710 --> 00:33:42,290
of the system all over and the current

00:33:39,590 --> 00:33:44,510
so the the max capacity of the CPU you

00:33:42,290 --> 00:33:47,360
are executing is basely applying the

00:33:44,510 --> 00:33:50,210
same scaling twice and that's actually

00:33:47,360 --> 00:33:52,430
what for example the parental lot raking

00:33:50,210 --> 00:34:00,170
in the scale fare is actually doing so

00:33:52,430 --> 00:34:01,580
it's very the same solution all right so

00:34:00,170 --> 00:34:04,340
now we basically have all the

00:34:01,580 --> 00:34:08,390
ingredients to actually be able to scale

00:34:04,340 --> 00:34:10,490
I mean control the clock frequency from

00:34:08,390 --> 00:34:13,060
the shredder so you probably aware of

00:34:10,490 --> 00:34:16,070
the schedule till CPU for a governor

00:34:13,060 --> 00:34:20,720
this governor has been recently in the

00:34:16,070 --> 00:34:22,610
last year is basically a small a thin

00:34:20,720 --> 00:34:25,429
layer between the scattering CPU frac

00:34:22,610 --> 00:34:30,250
driver and with that you can actually

00:34:25,429 --> 00:34:33,590
drive clock frequency from the shredder

00:34:30,250 --> 00:34:36,240
currently he uses fourth grade normal

00:34:33,590 --> 00:34:38,280
force kid Norma so fare tasks

00:34:36,240 --> 00:34:41,610
the utilization average utilization

00:34:38,280 --> 00:34:45,090
signal and then uses that compared to

00:34:41,610 --> 00:34:48,270
the max capacity CPU to actually compute

00:34:45,090 --> 00:34:52,850
the frequency needed to meet the task

00:34:48,270 --> 00:34:56,639
requirements this basically running

00:34:52,850 --> 00:34:58,680
running average of the task it security

00:34:56,639 --> 00:35:01,380
on the system currently the promise that

00:34:58,680 --> 00:35:03,390
both k5 or scan normal as soon as you

00:35:01,380 --> 00:35:05,340
schedule esketh five Foursquare normal

00:35:03,390 --> 00:35:08,970
task you go to max because basically

00:35:05,340 --> 00:35:10,860
there is no idea of how much utilization

00:35:08,970 --> 00:35:12,750
bandwidth and clock frequency is

00:35:10,860 --> 00:35:16,970
actually required to meet those task

00:35:12,750 --> 00:35:20,250
requirements the idea is that the once

00:35:16,970 --> 00:35:23,460
bandwidth you're climbing will be in we

00:35:20,250 --> 00:35:26,880
can use the running beverage so it's our

00:35:23,460 --> 00:35:30,090
you act I was talking about to actually

00:35:26,880 --> 00:35:32,400
have a per CPU utilization contribution

00:35:30,090 --> 00:35:36,210
of skedaddling so the idea would be I

00:35:32,400 --> 00:35:40,140
have the UT leverage coming from fair I

00:35:36,210 --> 00:35:42,660
sum up these with the UX or running

00:35:40,140 --> 00:35:45,170
bandwidth of deadline and then I can

00:35:42,660 --> 00:35:49,230
translate this amount of utilization

00:35:45,170 --> 00:35:51,780
into a frequency a clock frequency so

00:35:49,230 --> 00:35:56,910
that's how I'll be driving frequency

00:35:51,780 --> 00:35:58,760
selection or so for for deadline another

00:35:56,910 --> 00:36:01,830
let's say that it's not the only

00:35:58,760 --> 00:36:04,230
modification needed the currently main

00:36:01,830 --> 00:36:06,720
line so one of the promise that the

00:36:04,230 --> 00:36:08,880
triggering points for actually driving

00:36:06,720 --> 00:36:11,730
frequency selection so when basically

00:36:08,880 --> 00:36:15,359
the points where the scheduler actually

00:36:11,730 --> 00:36:18,000
asks the governor and the driver to

00:36:15,359 --> 00:36:21,119
actually change frequency for both four

00:36:18,000 --> 00:36:25,350
five four and deadlines there resides in

00:36:21,119 --> 00:36:26,100
the base retic handling code which for

00:36:25,350 --> 00:36:28,320
deadlines

00:36:26,100 --> 00:36:29,970
I mean makes sense now because it's I

00:36:28,320 --> 00:36:33,000
mean commonplace you always call when

00:36:29,970 --> 00:36:35,780
you have something active but in the

00:36:33,000 --> 00:36:39,420
light of what I've been actually talking

00:36:35,780 --> 00:36:42,600
today we have to move those points where

00:36:39,420 --> 00:36:48,330
the running bandwidth is so where the

00:36:42,600 --> 00:36:49,830
you you active actually changes that's

00:36:48,330 --> 00:36:55,710
the special question actually

00:36:49,830 --> 00:36:57,600
so if you if you actually was able to

00:36:55,710 --> 00:37:01,580
follow so where do you think this

00:36:57,600 --> 00:37:01,580
running bandwidth actually changes

00:37:02,090 --> 00:37:08,030
anybody so well one point is probably

00:37:05,820 --> 00:37:10,500
easy so let's say you have a task and

00:37:08,030 --> 00:37:15,210
then when do you actually have to

00:37:10,500 --> 00:37:20,120
increment the you they you act for the

00:37:15,210 --> 00:37:20,120
CPU sorry

00:37:20,460 --> 00:37:24,990
that's basically the finishing so let's

00:37:23,730 --> 00:37:27,780
say the first thing you have to do is

00:37:24,990 --> 00:37:30,030
actually increment the variable when the

00:37:27,780 --> 00:37:31,650
task weights up the first time right so

00:37:30,030 --> 00:37:33,630
that's one of the points where you

00:37:31,650 --> 00:37:36,330
actually potentially want to trigger a

00:37:33,630 --> 00:37:38,550
frequency selection the other one is

00:37:36,330 --> 00:37:41,070
actually what you were saying basically

00:37:38,550 --> 00:37:45,020
when it does goes to sleep you

00:37:41,070 --> 00:37:47,670
potentially want to actually remove his

00:37:45,020 --> 00:37:49,680
contribution to the active utilization

00:37:47,670 --> 00:37:52,880
and that's where you potentially want to

00:37:49,680 --> 00:37:55,320
tree to trigger a frequency selection

00:37:52,880 --> 00:37:57,930
it's not instantaneously when it has

00:37:55,320 --> 00:38:00,330
goes to sleep is the famous zero lag

00:37:57,930 --> 00:38:02,340
time I was talking about before so you

00:38:00,330 --> 00:38:04,590
set up the timer and when it's time your

00:38:02,340 --> 00:38:07,350
fires and you actually decrement the you

00:38:04,590 --> 00:38:09,420
you act you can actually trigger the

00:38:07,350 --> 00:38:12,480
frequency selection and say ok this task

00:38:09,420 --> 00:38:17,090
is is gone so you might be slowing down

00:38:12,480 --> 00:38:19,650
your your frequency that's basically it

00:38:17,090 --> 00:38:23,550
yeah another modification there will be

00:38:19,650 --> 00:38:26,730
most probably I mean required is that on

00:38:23,550 --> 00:38:28,470
platform that actually needs a sleepable

00:38:26,730 --> 00:38:32,250
context to actually change frequency

00:38:28,470 --> 00:38:34,710
like our platform we need a K work at

00:38:32,250 --> 00:38:36,750
thread to actually do I'm going to

00:38:34,710 --> 00:38:41,000
actually call in the driver and actually

00:38:36,750 --> 00:38:43,800
perform the frequencies which and that

00:38:41,000 --> 00:38:46,110
the thread is currently asked at 5-4

00:38:43,800 --> 00:38:49,140
thread of course if you are if you want

00:38:46,110 --> 00:38:51,510
to change the frequency to for a

00:38:49,140 --> 00:38:53,610
deadline task we let to make also the

00:38:51,510 --> 00:38:56,130
trade deadline it may be treated like

00:38:53,610 --> 00:38:59,760
especially because you basically want to

00:38:56,130 --> 00:39:02,610
always that the guy always preempt any

00:38:59,760 --> 00:39:03,599
other deadlines tasks just to be able to

00:39:02,610 --> 00:39:06,660
change the frequency

00:39:03,599 --> 00:39:13,319
in a lot of those so those are basically

00:39:06,660 --> 00:39:15,779
really many modifications some results

00:39:13,319 --> 00:39:18,749
I probably scheme through this because I

00:39:15,779 --> 00:39:22,170
don't have much time left just saying

00:39:18,749 --> 00:39:25,259
that for example here the basic idea and

00:39:22,170 --> 00:39:26,940
then you can go offline and see better I

00:39:25,259 --> 00:39:31,079
have actually extensive results

00:39:26,940 --> 00:39:32,459
collected and you can there you can

00:39:31,079 --> 00:39:34,949
actually look at them basically the idea

00:39:32,459 --> 00:39:39,059
is that at least with the simple example

00:39:34,949 --> 00:39:41,309
you are meeting both tasks requirements

00:39:39,059 --> 00:39:43,469
or deadlines you don't have any let's

00:39:41,309 --> 00:39:45,809
say that what you actually want to see

00:39:43,469 --> 00:39:48,690
is that the redline doesn't go below

00:39:45,809 --> 00:39:50,969
zero and while you are not running at

00:39:48,690 --> 00:39:52,440
the maximum frequency so that's

00:39:50,969 --> 00:39:55,499
basically the trade off you actually

00:39:52,440 --> 00:39:57,839
want to achieve and it seems to be to be

00:39:55,499 --> 00:40:00,239
working I said I don't spend much time

00:39:57,839 --> 00:40:07,920
in this because I had to cover the next

00:40:00,239 --> 00:40:11,219
bit so group straddling why we want this

00:40:07,920 --> 00:40:13,170
so currently scheduling works one to one

00:40:11,219 --> 00:40:17,309
so you have one to one association

00:40:13,170 --> 00:40:20,459
between task and reservation the idea is

00:40:17,309 --> 00:40:23,309
that sometimes it's actually might be

00:40:20,459 --> 00:40:25,469
easier or better to be able to group a

00:40:23,309 --> 00:40:27,660
set of tasks inside the similar

00:40:25,469 --> 00:40:30,180
servation just because for example no

00:40:27,660 --> 00:40:32,339
you can post replication is like a

00:40:30,180 --> 00:40:34,920
rendering pipeline with where you don't

00:40:32,339 --> 00:40:36,690
actually know which beats and you can

00:40:34,920 --> 00:40:39,630
actually you can't actually come up with

00:40:36,690 --> 00:40:41,699
the run time period for each task that

00:40:39,630 --> 00:40:43,199
belongs to the pipeline or for example

00:40:41,699 --> 00:40:45,269
you just have a legacy application

00:40:43,199 --> 00:40:47,309
composed by different threads and you

00:40:45,269 --> 00:40:51,059
can can go and modify the application

00:40:47,309 --> 00:40:53,339
source code or for example you have to

00:40:51,059 --> 00:40:57,089
manage know for example KVM threads and

00:40:53,339 --> 00:41:02,059
one way would be to reserve a portion of

00:40:57,089 --> 00:41:04,759
the CPU bandwidth using group scheduling

00:41:02,059 --> 00:41:07,650
what we have to implement that there

00:41:04,759 --> 00:41:09,959
working program work-in-progress batch

00:41:07,650 --> 00:41:11,819
is also for this there not been yet

00:41:09,959 --> 00:41:14,390
discussed many lists so they're gonna be

00:41:11,819 --> 00:41:16,730
posted hopefully in the next month so

00:41:14,390 --> 00:41:20,090
it's what we call group or

00:41:16,730 --> 00:41:22,040
hierarchical shredding support again

00:41:20,090 --> 00:41:24,820
there are a lot of references on the

00:41:22,040 --> 00:41:28,060
slides so please go and check them up

00:41:24,820 --> 00:41:32,300
the idea is that you will then have

00:41:28,060 --> 00:41:35,810
temporal isolation but between groups

00:41:32,300 --> 00:41:37,880
that contains more than one task the

00:41:35,810 --> 00:41:40,790
approach would be hierarchical in the

00:41:37,880 --> 00:41:44,300
sense that at root level so the first

00:41:40,790 --> 00:41:47,590
level will be managed by EDF like

00:41:44,300 --> 00:41:50,210
deadline already does and inside the

00:41:47,590 --> 00:41:54,380
deadline reservation you'll be actually

00:41:50,210 --> 00:41:58,450
shredding considering FIFO basically you

00:41:54,380 --> 00:42:02,180
have in this case for example t1 t2 t3

00:41:58,450 --> 00:42:05,570
and for our FIFO task that actually are

00:42:02,180 --> 00:42:07,970
shredded inside dead reservation so the

00:42:05,570 --> 00:42:10,850
listener that the routes scheduler we

00:42:07,970 --> 00:42:13,400
pick a group of tasks considering their

00:42:10,850 --> 00:42:15,380
the deadlines and those things are

00:42:13,400 --> 00:42:18,710
managed by the constant memory server

00:42:15,380 --> 00:42:20,660
again like we simple one-to-one tasks

00:42:18,710 --> 00:42:24,140
and then you had to actually execute

00:42:20,660 --> 00:42:26,720
again the scheduler inside the drupada's

00:42:24,140 --> 00:42:33,410
to pick one of the tasks you actually

00:42:26,720 --> 00:42:35,270
shelving with FIFO the idea I think

00:42:33,410 --> 00:42:38,900
Peter actually mentioned this several

00:42:35,270 --> 00:42:40,880
time is actually to remove the RTE

00:42:38,900 --> 00:42:45,290
throttling and actually substitute that

00:42:40,880 --> 00:42:50,540
with this mechanism so what there are t

00:42:45,290 --> 00:42:52,730
throttling anybody mechanism right so

00:42:50,540 --> 00:42:55,790
it's basically it's mostly let's say the

00:42:52,730 --> 00:42:58,220
bag mechanism to actually prevent Phi

00:42:55,790 --> 00:43:01,220
for RT tasks to actually draw paradise

00:42:58,220 --> 00:43:03,710
hole the CPU and that's basically more I

00:43:01,220 --> 00:43:07,640
mean theoretically is the same thing

00:43:03,710 --> 00:43:10,550
because here I will reserve a portion of

00:43:07,640 --> 00:43:13,430
a CPU using deadlines and so that I can

00:43:10,550 --> 00:43:16,090
after i at least I can remove data that

00:43:13,430 --> 00:43:16,090
mechanism

00:43:30,080 --> 00:43:35,030
yes I mean the the API let's say the

00:43:33,290 --> 00:43:38,330
user space API won't change because you

00:43:35,030 --> 00:43:41,900
still have RT groups it Just's who

00:43:38,330 --> 00:43:44,960
manages those group will change it won't

00:43:41,900 --> 00:43:47,030
be RT anymore will be deadlines managing

00:43:44,960 --> 00:43:49,940
those groups while you still I mean from

00:43:47,030 --> 00:43:53,770
user space you still be creating groups

00:43:49,940 --> 00:43:56,990
and then put in inside tasks and then

00:43:53,770 --> 00:44:02,240
manage the RT runtime RT period of those

00:43:56,990 --> 00:44:05,830
groups so no change is required from an

00:44:02,240 --> 00:44:05,830
application point of view I'd say

00:44:11,120 --> 00:44:18,070
sorry yes

00:44:26,030 --> 00:44:30,630
yeah but that's the same thing you are

00:44:28,260 --> 00:44:32,790
doing today so you had to configure your

00:44:30,630 --> 00:44:35,780
groups if you want if you want to use

00:44:32,790 --> 00:44:38,670
our teeth rattling they say not the

00:44:35,780 --> 00:44:42,210
global one but the per group one you

00:44:38,670 --> 00:44:44,190
still have to create a group sign the RT

00:44:42,210 --> 00:44:46,800
runtime and period for the group and

00:44:44,190 --> 00:44:48,829
then put your FIFO task inside the group

00:44:46,800 --> 00:44:51,900
and that's basically it won't change

00:44:48,829 --> 00:44:58,190
it's only managed by a different guy

00:44:51,900 --> 00:45:00,900
we'll be deadly instead of five and

00:44:58,190 --> 00:45:01,890
basically on a multiprocessor sister how

00:45:00,900 --> 00:45:04,589
it will work

00:45:01,890 --> 00:45:07,170
basically you'll have so each group has

00:45:04,589 --> 00:45:10,020
only two parameters its runtime over

00:45:07,170 --> 00:45:12,359
period and that is basically you will

00:45:10,020 --> 00:45:15,569
replicate the same amount of reserved

00:45:12,359 --> 00:45:17,880
bandwidth across all CPUs so you will

00:45:15,569 --> 00:45:20,819
have ask a deadline entity on each of

00:45:17,880 --> 00:45:23,309
your CPU and then you'll basically those

00:45:20,819 --> 00:45:26,369
those guys the the FIFO guys will be

00:45:23,309 --> 00:45:28,410
executing inside those scheduling

00:45:26,369 --> 00:45:31,440
entities which basically represent like

00:45:28,410 --> 00:45:32,940
some kind of virtual processors because

00:45:31,440 --> 00:45:36,180
visitor processes because for example

00:45:32,940 --> 00:45:38,190
when you had to perform global sharing

00:45:36,180 --> 00:45:40,559
so the push/pull mechanism will actually

00:45:38,190 --> 00:45:43,109
pull and push tasks between the

00:45:40,559 --> 00:45:47,760
scheduling entities that you have on

00:45:43,109 --> 00:45:50,609
each CPU that's basically the the idea I

00:45:47,760 --> 00:45:52,410
don't have much more details about these

00:45:50,609 --> 00:45:54,359
just because it's really more work in

00:45:52,410 --> 00:45:57,119
progress than the other one but I mean

00:45:54,359 --> 00:46:00,930
if you have any more questions just ask

00:45:57,119 --> 00:46:05,460
me also offline of course and we are

00:46:00,930 --> 00:46:07,950
mostly done so future what I didn't

00:46:05,460 --> 00:46:11,640
cover and what's still me Missy and so I

00:46:07,950 --> 00:46:13,020
said that the real near thing it's

00:46:11,640 --> 00:46:15,660
happening right now for me it actually

00:46:13,020 --> 00:46:18,359
tried to start experimenting with all

00:46:15,660 --> 00:46:20,460
this new feature or Android see if we

00:46:18,359 --> 00:46:22,799
can convert like the current user

00:46:20,460 --> 00:46:25,819
dropped FIFO to actually start using

00:46:22,799 --> 00:46:28,440
deadly and see how it goes

00:46:25,819 --> 00:46:31,049
another idea that would be probably

00:46:28,440 --> 00:46:34,290
needed to implement is that in principle

00:46:31,049 --> 00:46:36,840
you can actually think to let the tasks

00:46:34,290 --> 00:46:39,060
run for more than

00:46:36,840 --> 00:46:41,880
we reserved at the Mission Control time

00:46:39,060 --> 00:46:44,670
by the mote in them towards lower

00:46:41,880 --> 00:46:48,030
priority tasks class sorry

00:46:44,670 --> 00:46:50,610
so when the task gets rotten instead of

00:46:48,030 --> 00:46:52,950
rotten the task I will demoted to run on

00:46:50,610 --> 00:46:55,650
FIFO or normal so you can actually

00:46:52,950 --> 00:47:00,390
continue executing but together with the

00:46:55,650 --> 00:47:04,050
other lower priority tasks on the other

00:47:00,390 --> 00:47:05,940
system and then of course the capacity

00:47:04,050 --> 00:47:08,040
and energy awareness so the fact that

00:47:05,940 --> 00:47:10,410
for example if you have a big little

00:47:08,040 --> 00:47:13,350
system now that we actually have a

00:47:10,410 --> 00:47:15,360
notion of how much capacity actually

00:47:13,350 --> 00:47:20,550
each task needs we'll have to make

00:47:15,360 --> 00:47:23,490
modification to actually know where I

00:47:20,550 --> 00:47:25,470
have to put a task considering the spare

00:47:23,490 --> 00:47:27,090
capacity or the different CPUs also

00:47:25,470 --> 00:47:29,850
considering that they they can have

00:47:27,090 --> 00:47:32,940
actually be from X capacities and then

00:47:29,850 --> 00:47:35,700
using this read information then we'll

00:47:32,940 --> 00:47:38,390
also have to consider energy in the

00:47:35,700 --> 00:47:42,960
picture so the energy of a shredder

00:47:38,390 --> 00:47:45,450
energyaware shredder actually adds an

00:47:42,960 --> 00:47:48,750
energy model of the platform and makes

00:47:45,450 --> 00:47:50,760
it available to the shredder so the idea

00:47:48,750 --> 00:47:53,490
is to start consuming that information

00:47:50,760 --> 00:47:57,600
also from deadlines to make energy

00:47:53,490 --> 00:48:00,750
better decisions nearish in the sense

00:47:57,600 --> 00:48:02,610
that nobody's currently working on this

00:48:00,750 --> 00:48:06,240
so there yeah I mean you're more than

00:48:02,610 --> 00:48:08,580
welcome to contribute is mostly it's the

00:48:06,240 --> 00:48:10,380
priority inheritance so currently

00:48:08,580 --> 00:48:12,330
protein irritants for deadly means

00:48:10,380 --> 00:48:15,240
deadlines inheritance what we want to

00:48:12,330 --> 00:48:18,000
actually have is to implement Brock's

00:48:15,240 --> 00:48:20,100
execution so I can actually execute

00:48:18,000 --> 00:48:22,650
inside someone else reservation and

00:48:20,100 --> 00:48:24,960
there may be some kind of dynamic

00:48:22,650 --> 00:48:30,510
feedback mechanism in which I can still

00:48:24,960 --> 00:48:35,400
adopt the tasks reservation and that's

00:48:30,510 --> 00:48:38,130
it so thanks again for coming if you

00:48:35,400 --> 00:48:40,770
have any question on just ask me abhi

00:48:38,130 --> 00:48:43,110
here for the whole week should be a meal

00:48:40,770 --> 00:48:46,140
just ask stuff on the news carry mini

00:48:43,110 --> 00:48:47,630
list only know 30 users there is also an

00:48:46,140 --> 00:48:48,840
energy aware shredder

00:48:47,630 --> 00:48:51,930
[Music]

00:48:48,840 --> 00:48:53,550
focus mini least called year Steph we

00:48:51,930 --> 00:48:54,210
are actually organizing this gonna be in

00:48:53,550 --> 00:48:57,030
Italy

00:48:54,210 --> 00:48:59,370
I'm from easily so we're gonna organize

00:48:57,030 --> 00:49:01,650
this some it around the scattering and

00:48:59,370 --> 00:49:04,460
power management you'll find more

00:49:01,650 --> 00:49:07,020
details at the link there so if you are

00:49:04,460 --> 00:49:09,930
it's gonna be in April so it's really

00:49:07,020 --> 00:49:12,270
happening like next month so I guess for

00:49:09,930 --> 00:49:14,910
the use us-based races can be tricky to

00:49:12,270 --> 00:49:17,070
to come because just because flights are

00:49:14,910 --> 00:49:18,900
exclaiming expensive I guess but if you

00:49:17,070 --> 00:49:23,610
are in Europe and you want to come

00:49:18,900 --> 00:49:26,730
you're more than welcome and oh yeah

00:49:23,610 --> 00:49:29,900
whoever got prizes please come and

00:49:26,730 --> 00:49:34,550
collect those Thanks

00:49:29,900 --> 00:49:34,550

YouTube URL: https://www.youtube.com/watch?v=wzrcWNIneWY


