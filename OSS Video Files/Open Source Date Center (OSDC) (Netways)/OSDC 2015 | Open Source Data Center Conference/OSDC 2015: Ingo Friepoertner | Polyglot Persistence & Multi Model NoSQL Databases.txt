Title: OSDC 2015: Ingo Friepoertner | Polyglot Persistence & Multi Model NoSQL Databases
Publication date: 2015-04-30
Playlist: OSDC 2015 | Open Source Data Center Conference
Description: 
	In many modern applications the database side is realized using polyglot persistence? Store each data format (graphs, documents, etc.) in an appropriate separate database.
This approach yields several benefits, databases are optimized for their specific duty, however there are also drawbacks:

    keep all databases in sync
    queries might require data from several databases
    experts needed for all used systems

A multi-model database is not restricted to one data format, but can cope with several of them.
In this talk I will present how a multi-model database can be used in a polyglot persistence setup and how it will reduce the effort drastically.
Captions: 
	00:00:06,880 --> 00:00:15,160
so in this retailer use case you

00:00:13,850 --> 00:00:20,090
mentioned six different database

00:00:15,160 --> 00:00:25,250
platforms that could be used in such an

00:00:20,090 --> 00:00:28,130
e-commerce system if you just ask what

00:00:25,250 --> 00:00:31,190
product might best fit not a

00:00:28,130 --> 00:00:35,360
recommendation how you should really

00:00:31,190 --> 00:00:38,629
build an ecosystem when you map this to

00:00:35,360 --> 00:00:46,269
the underlying data models then we see

00:00:38,629 --> 00:00:49,699
arm that we have key values data

00:00:46,269 --> 00:00:51,879
relational database we have a graph

00:00:49,699 --> 00:00:56,870
database we have documents stores and

00:00:51,879 --> 00:01:04,640
column stores that are used in this in

00:00:56,870 --> 00:01:08,600
this use case so if you don't agree the

00:01:04,640 --> 00:01:11,960
content of a document or of an object

00:01:08,600 --> 00:01:16,430
then you are right with the key value

00:01:11,960 --> 00:01:19,729
store so the session of course you don't

00:01:16,430 --> 00:01:22,250
want to query if someone has designed

00:01:19,729 --> 00:01:27,289
that intercession you just use a key

00:01:22,250 --> 00:01:31,009
value store and and get your session ID

00:01:27,289 --> 00:01:33,799
is a key and to use this to catch all

00:01:31,009 --> 00:01:38,570
the information on if you need

00:01:33,799 --> 00:01:43,369
transactions in white are still be in

00:01:38,570 --> 00:01:47,299
the relational world and of course if

00:01:43,369 --> 00:01:50,210
your data looks like a document then you

00:01:47,299 --> 00:01:53,630
should be allowed to store it in a

00:01:50,210 --> 00:01:56,479
document database if you have the fixed

00:01:53,630 --> 00:01:59,780
structures fixed structure data in our

00:01:56,479 --> 00:02:02,840
reporting then that's of course one of

00:01:59,780 --> 00:02:06,289
the best fit in a relational database

00:02:02,840 --> 00:02:09,740
there are lots of tools that assist you

00:02:06,289 --> 00:02:14,870
to do reporting's so to switch this into

00:02:09,740 --> 00:02:18,140
another data stores not that recommended

00:02:14,870 --> 00:02:19,830
and of course if you have links between

00:02:18,140 --> 00:02:23,370
entities

00:02:19,830 --> 00:02:29,340
and you need to query these entities and

00:02:23,370 --> 00:02:32,310
go along in our on a graph it's of

00:02:29,340 --> 00:02:42,150
course start in a graph database in a

00:02:32,310 --> 00:02:44,010
graph model in a no squirrel world we

00:02:42,150 --> 00:02:53,520
have the same setup of an e-commerce

00:02:44,010 --> 00:02:58,100
system but now the product catalog isn't

00:02:53,520 --> 00:03:01,410
a certain documents in our collection

00:02:58,100 --> 00:03:03,450
it's different attributes and you just

00:03:01,410 --> 00:03:06,440
care for the same attributes that are

00:03:03,450 --> 00:03:08,910
shared between the products like price

00:03:06,440 --> 00:03:12,840
product name and so on and of course

00:03:08,910 --> 00:03:15,600
these are the items where you would put

00:03:12,840 --> 00:03:21,660
an index on and that you might use to

00:03:15,600 --> 00:03:25,670
chart your product catalog the customer

00:03:21,660 --> 00:03:28,290
is stored in a document store as well

00:03:25,670 --> 00:03:32,930
shipping and payment address might be

00:03:28,290 --> 00:03:35,989
just a nested object in this document

00:03:32,930 --> 00:03:40,010
the state's history is nearly the same

00:03:35,989 --> 00:03:43,920
and the shopping cart we just need the

00:03:40,010 --> 00:03:49,650
session ID it could be probably stored

00:03:43,920 --> 00:03:52,110
in a key value database the

00:03:49,650 --> 00:03:54,090
recommendations based on connections

00:03:52,110 --> 00:03:57,890
between products and customers are a

00:03:54,090 --> 00:03:57,890
good fit in a craft database

00:04:01,840 --> 00:04:10,010
some popular examples of course you can

00:04:05,150 --> 00:04:14,060
use MongoDB for the document stores or

00:04:10,010 --> 00:04:17,299
couchbase couched be whatever their many

00:04:14,060 --> 00:04:21,739
vendors on the market and new for j is

00:04:17,299 --> 00:04:23,780
one of the famous graph database and the

00:04:21,739 --> 00:04:33,139
shopping cart would be a good fit in in

00:04:23,780 --> 00:04:35,539
Redis for example so let's look at the

00:04:33,139 --> 00:04:39,830
benefits in the overhead of a polygon

00:04:35,539 --> 00:04:43,490
persistence of approach first of all you

00:04:39,830 --> 00:04:46,190
have a natural mapping on of the data

00:04:43,490 --> 00:04:48,699
into your database you store your

00:04:46,190 --> 00:04:52,250
recommendation graph in a graph database

00:04:48,699 --> 00:04:53,740
and do product in a document database in

00:04:52,250 --> 00:04:57,229
your shopping cart in a key value base

00:04:53,740 --> 00:05:01,419
and you don't have to write code to

00:04:57,229 --> 00:05:04,280
transform those data into the database

00:05:01,419 --> 00:05:07,460
because the database is really built for

00:05:04,280 --> 00:05:10,240
those kind of data then you get queries

00:05:07,460 --> 00:05:12,620
that are tailored for your data formats

00:05:10,240 --> 00:05:16,490
you don't need to create huge and

00:05:12,620 --> 00:05:21,710
complex SQL queries to get your your

00:05:16,490 --> 00:05:24,289
data and create a recommendation but

00:05:21,710 --> 00:05:30,320
instead you get those out of the box

00:05:24,289 --> 00:05:32,539
from the graph database you can focus on

00:05:30,320 --> 00:05:34,720
your business logic and don't need to

00:05:32,539 --> 00:05:37,490
clear about the data transformation so I

00:05:34,720 --> 00:05:42,229
want to see overhead of that such an

00:05:37,490 --> 00:05:46,570
approach first you need to store your

00:05:42,229 --> 00:05:49,039
data redundantly and keep it in sync

00:05:46,570 --> 00:05:53,950
when we think about the recommendation

00:05:49,039 --> 00:05:57,520
example they are we have the graph query

00:05:53,950 --> 00:06:00,830
capabilities from the graph database and

00:05:57,520 --> 00:06:03,979
the actual content that is stored in the

00:06:00,830 --> 00:06:06,199
document database we want to recommend

00:06:03,979 --> 00:06:09,500
products and we have those already

00:06:06,199 --> 00:06:12,110
stored in the document database and but

00:06:09,500 --> 00:06:14,510
want to use them for the recommendation

00:06:12,110 --> 00:06:17,240
to graph database

00:06:14,510 --> 00:06:18,620
next you have to set up and maintain at

00:06:17,240 --> 00:06:24,020
least three different database

00:06:18,620 --> 00:06:32,810
technologies which makes a live / DBA

00:06:24,020 --> 00:06:36,920
not easier I just found a a study from

00:06:32,810 --> 00:06:38,390
Dell published last month um where the

00:06:36,920 --> 00:06:42,170
problem of different database platforms

00:06:38,390 --> 00:06:43,550
was part of the survey and there are

00:06:42,170 --> 00:06:46,430
roughly thirty eight percent of the

00:06:43,550 --> 00:06:49,910
respondents said they are dbas and their

00:06:46,430 --> 00:06:53,030
organization manage databases from at

00:06:49,910 --> 00:06:54,920
least three vendors while seven percent

00:06:53,030 --> 00:07:02,300
manage databases from five or more

00:06:54,920 --> 00:07:05,030
vendors the key challenge for dbas is of

00:07:02,300 --> 00:07:08,390
course learning new technologies but not

00:07:05,030 --> 00:07:10,520
only databases there's enough other

00:07:08,390 --> 00:07:15,680
technologies darker what we heard this

00:07:10,520 --> 00:07:20,600
morning and data center operating

00:07:15,680 --> 00:07:26,890
systems they also were asked and

00:07:20,600 --> 00:07:29,360
directly or on the question in terms of

00:07:26,890 --> 00:07:31,250
database administration itself over the

00:07:29,360 --> 00:07:34,610
next three years what do you think will

00:07:31,250 --> 00:07:36,740
be the top challenge facing DBAs that

00:07:34,610 --> 00:07:40,280
was of course the need to learn new

00:07:36,740 --> 00:07:43,610
technologies 53.5 percent shrinking IT

00:07:40,280 --> 00:07:47,780
budgets forty-nine percent and the need

00:07:43,610 --> 00:07:52,220
to manage more databases pure DBA it

00:07:47,780 --> 00:07:54,410
with forty six percent and the noise

00:07:52,220 --> 00:07:58,970
well at adoption and enterprises by far

00:07:54,410 --> 00:08:04,960
in the early beginning so that might get

00:07:58,970 --> 00:08:07,630
what worse um so if polygon positions

00:08:04,960 --> 00:08:10,640
will be the key for the next

00:08:07,630 --> 00:08:13,070
applications you build just choose the

00:08:10,640 --> 00:08:16,510
right technology the right tool for your

00:08:13,070 --> 00:08:21,050
job and you might end up with lots of

00:08:16,510 --> 00:08:25,449
databases and lots of vendors but

00:08:21,050 --> 00:08:28,879
shrieking IT budgets let's of course a

00:08:25,449 --> 00:08:31,669
point for free and open source no

00:08:28,879 --> 00:08:36,800
squared products I think they will place

00:08:31,669 --> 00:08:41,419
a role in the next years and how will

00:08:36,800 --> 00:08:43,729
the multi model fit in this so the

00:08:41,419 --> 00:08:50,000
alternative to a polygon persistence

00:08:43,729 --> 00:08:53,959
approach our multi-model databases the

00:08:50,000 --> 00:08:57,050
idea of a multi-model databases that you

00:08:53,959 --> 00:09:01,940
can store different data models in one

00:08:57,050 --> 00:09:04,100
database natively so it could be the

00:09:01,940 --> 00:09:10,579
combination of key value store of

00:09:04,100 --> 00:09:14,510
documents and graphs and the idea of the

00:09:10,579 --> 00:09:17,690
graphs that it can store is that you

00:09:14,510 --> 00:09:20,120
simply use your documents from your

00:09:17,690 --> 00:09:25,690
document store and connect them with in

00:09:20,120 --> 00:09:25,690
the graph and the edges to the outside

00:09:25,959 --> 00:09:32,029
also appears as documents they've also

00:09:28,730 --> 00:09:33,829
attributes so we can query the edges as

00:09:32,029 --> 00:09:36,980
documents which gives different

00:09:33,829 --> 00:09:40,850
opportunities and you can query the

00:09:36,980 --> 00:09:44,380
documents arm in Europe as well as

00:09:40,850 --> 00:09:47,380
graphic rain you don't need to write any

00:09:44,380 --> 00:09:52,910
application code to combine these ones

00:09:47,380 --> 00:09:56,720
and it develops you it delivers you all

00:09:52,910 --> 00:09:58,640
the gravy mechanisms for all the data

00:09:56,720 --> 00:10:00,920
models you get a Gris interface for

00:09:58,640 --> 00:10:10,160
graphs I create interface for documents

00:10:00,920 --> 00:10:12,529
and four key value pairs and if we use

00:10:10,160 --> 00:10:14,540
such a multi-model database and come

00:10:12,529 --> 00:10:18,170
back to the polygon persistence approach

00:10:14,540 --> 00:10:22,070
and just look at the at the data models

00:10:18,170 --> 00:10:25,070
which are used there then way we could

00:10:22,070 --> 00:10:31,779
use a multi-model database like a Rango

00:10:25,070 --> 00:10:35,059
DP or en-gb and data sticks a bore titan

00:10:31,779 --> 00:10:37,219
earlier this year who might be

00:10:35,059 --> 00:10:39,589
this as well then we can reduce the

00:10:37,219 --> 00:10:48,159
number of technologies from five to

00:10:39,589 --> 00:10:52,249
three you see that we have even replaced

00:10:48,159 --> 00:10:54,019
so this is a raggedy p we even replace

00:10:52,249 --> 00:10:57,349
the relational database with a wrangle

00:10:54,019 --> 00:11:01,069
to be because I rang going to be offers

00:10:57,349 --> 00:11:04,429
the needed acid guarantees for the

00:11:01,069 --> 00:11:12,439
financial later on as well so it might

00:11:04,429 --> 00:11:17,059
be a fit for those data as well so let's

00:11:12,439 --> 00:11:19,579
go back to the use case it's still the

00:11:17,059 --> 00:11:22,009
same setup we're using a document store

00:11:19,579 --> 00:11:27,559
graph store on key value store I just

00:11:22,009 --> 00:11:30,759
rely on one database vendor there are

00:11:27,559 --> 00:11:34,959
several multi-model databases as i said

00:11:30,759 --> 00:11:37,609
in the market so you can choose which

00:11:34,959 --> 00:11:44,449
offers the best fit for your application

00:11:37,609 --> 00:11:48,069
but you just are rely on on you can use

00:11:44,449 --> 00:11:55,969
one database vendor for several tasks

00:11:48,069 --> 00:11:59,049
and um if you see in DB engines and the

00:11:55,969 --> 00:12:02,089
DB engines ranking there are the

00:11:59,049 --> 00:12:05,929
category multi-model databases still

00:12:02,089 --> 00:12:09,589
really new we try to introduce it last

00:12:05,929 --> 00:12:12,039
year and then sometimes it gets

00:12:09,589 --> 00:12:22,369
introduced on a DB engines and nowadays

00:12:12,039 --> 00:12:25,789
it's already crowded so have a look so

00:12:22,369 --> 00:12:28,429
that leads me to a little bit of arango

00:12:25,789 --> 00:12:32,379
DB what are my favorite i want good to

00:12:28,429 --> 00:12:34,639
be features first of course it's

00:12:32,379 --> 00:12:38,539
multi-model and you can store all these

00:12:34,639 --> 00:12:42,469
different data models but second i run

00:12:38,539 --> 00:12:45,799
going to be delivers and offers a SQL

00:12:42,469 --> 00:12:48,410
query and sql-like query language which

00:12:45,799 --> 00:12:52,040
we call a ql

00:12:48,410 --> 00:12:55,610
and this also offers joints and

00:12:52,040 --> 00:12:59,149
traverses that means you can use this

00:12:55,610 --> 00:13:02,300
language to grow your graphs and join

00:12:59,149 --> 00:13:07,879
between documents even across multiple

00:13:02,300 --> 00:13:10,250
collections so users with products and

00:13:07,879 --> 00:13:13,660
that is something which is not offered

00:13:10,250 --> 00:13:17,720
by many documents dolls there you might

00:13:13,660 --> 00:13:23,899
just get these data in a single query

00:13:17,720 --> 00:13:28,389
and join it on the client side and third

00:13:23,899 --> 00:13:31,009
I rangu DB provides acid guarantees

00:13:28,389 --> 00:13:33,709
including multi collection transactions

00:13:31,009 --> 00:13:35,449
so you can actually store several

00:13:33,709 --> 00:13:37,819
documents you know in a different

00:13:35,449 --> 00:13:44,540
collection and update them all in one

00:13:37,819 --> 00:13:46,879
asset transaction and finally there's

00:13:44,540 --> 00:13:49,730
another feature you might not expect

00:13:46,879 --> 00:13:54,380
from a new SQL database or from a

00:13:49,730 --> 00:13:57,290
database that is called Fox and Fox is

00:13:54,380 --> 00:14:00,800
our JavaScript framework that is built

00:13:57,290 --> 00:14:06,560
in that has built in libraries and the

00:14:00,800 --> 00:14:10,160
JavaScript runtime Google v8 and you can

00:14:06,560 --> 00:14:13,399
use it to put JavaScript code on the

00:14:10,160 --> 00:14:18,310
database level and you can adapt your

00:14:13,399 --> 00:14:21,470
database API to what you actually nique

00:14:18,310 --> 00:14:25,009
so if you miss some functionality you

00:14:21,470 --> 00:14:29,540
can write your own API in JavaScript

00:14:25,009 --> 00:14:32,449
with direct access to the raw on objects

00:14:29,540 --> 00:14:35,300
of the database and so every time you

00:14:32,449 --> 00:14:37,579
query data from your database analyzes

00:14:35,300 --> 00:14:41,829
and send it back to the database well

00:14:37,579 --> 00:14:44,149
maybe without user interaction that

00:14:41,829 --> 00:14:46,759
would be your best would be a good fit

00:14:44,149 --> 00:14:50,120
if you do it in in fox directly in the

00:14:46,759 --> 00:14:55,370
database and that is of course much

00:14:50,120 --> 00:14:58,209
faster don't have to pull things back

00:14:55,370 --> 00:14:58,209
and forth

00:14:59,839 --> 00:15:07,110
let's have a look at an example query

00:15:04,110 --> 00:15:11,269
that uses the document model and a graph

00:15:07,110 --> 00:15:15,629
query on top so there's a similar simple

00:15:11,269 --> 00:15:19,350
recommendation query first we will go

00:15:15,629 --> 00:15:24,389
through all documents and we'll return

00:15:19,350 --> 00:15:26,339
them but we want just to filter on

00:15:24,389 --> 00:15:29,970
products that have the colored yellow

00:15:26,339 --> 00:15:32,519
and of course now we don't go through

00:15:29,970 --> 00:15:36,179
all the documents iterate through the

00:15:32,519 --> 00:15:38,879
documents but it's just the the filter

00:15:36,179 --> 00:15:41,999
box first so we just iterate through the

00:15:38,879 --> 00:15:48,809
documents that are that are products

00:15:41,999 --> 00:15:51,029
with a colored yellow of course along we

00:15:48,809 --> 00:15:56,639
want to limit the results we just want

00:15:51,029 --> 00:16:00,209
to recommend 10 products and then we do

00:15:56,639 --> 00:16:04,949
a graph clearly we use the graph

00:16:00,209 --> 00:16:06,899
function graph distance too that's an

00:16:04,949 --> 00:16:13,170
implementation based on the shortest

00:16:06,899 --> 00:16:16,230
path so and that just returns the

00:16:13,170 --> 00:16:19,709
distance between two vertices and not

00:16:16,230 --> 00:16:25,230
documents itself and just to explain

00:16:19,709 --> 00:16:32,129
what it does here is the vertex and the

00:16:25,230 --> 00:16:37,049
edge so the yellow t-shirt is directly

00:16:32,129 --> 00:16:41,100
connected to the customer Ellis so we

00:16:37,049 --> 00:16:46,860
just have a distance from one and we

00:16:41,100 --> 00:16:53,269
might have another another distance of

00:16:46,860 --> 00:16:56,639
two if we go from the shirt over Lena

00:16:53,269 --> 00:17:02,339
she bought the sir her shirt and she

00:16:56,639 --> 00:17:09,270
knows Ellis so that's what we do in this

00:17:02,339 --> 00:17:11,900
graft we we sort by distance so if if

00:17:09,270 --> 00:17:14,790
it's the distance from

00:17:11,900 --> 00:17:17,910
product to the customer is shorter then

00:17:14,790 --> 00:17:23,280
we will edit in the in the

00:17:17,910 --> 00:17:25,920
recommendation and we want to add

00:17:23,280 --> 00:17:29,760
another filter that the distance is

00:17:25,920 --> 00:17:33,960
greater than one because we don't want

00:17:29,760 --> 00:17:38,610
to suggest Ellis some product she

00:17:33,960 --> 00:17:44,420
already knew already bought so this is

00:17:38,610 --> 00:17:44,420
simplified you can add whatever you want

00:17:44,720 --> 00:17:58,410
and you can use this such queries to

00:17:50,160 --> 00:18:04,070
build your own API with Fox so we can

00:17:58,410 --> 00:18:07,830
now use this grave es is nearly and

00:18:04,070 --> 00:18:10,020
provide a new route where we can get the

00:18:07,830 --> 00:18:13,020
product recommendations for a given

00:18:10,020 --> 00:18:16,590
color so in this example we have a root

00:18:13,020 --> 00:18:25,530
red comelon recommend and a parameter

00:18:16,590 --> 00:18:28,620
color and you can use this route just be

00:18:25,530 --> 00:18:33,390
a rest from your application and you're

00:18:28,620 --> 00:18:38,010
almost done of course you can do a lot

00:18:33,390 --> 00:18:39,690
more with Fox you can add buildin

00:18:38,010 --> 00:18:44,130
functions and the building libraries you

00:18:39,690 --> 00:18:46,830
can add of our basic authentication you

00:18:44,130 --> 00:18:53,130
can add schema validation you can add

00:18:46,830 --> 00:18:55,830
security mechanisms so check on on

00:18:53,130 --> 00:19:01,130
document or even on attribute level the

00:18:55,830 --> 00:19:04,890
access rights and much more and my

00:19:01,130 --> 00:19:09,000
favorite Fox app which is which we

00:19:04,890 --> 00:19:12,330
recently build is the ready to use API

00:19:09,000 --> 00:19:14,010
key management so it's a little service

00:19:12,330 --> 00:19:15,930
that you can use in your own Fox

00:19:14,010 --> 00:19:19,950
application your own Fox applications

00:19:15,930 --> 00:19:23,930
and so you can restrict your roots for

00:19:19,950 --> 00:19:23,930
certain users have packets and

00:19:24,500 --> 00:19:30,680
you have no additional four to publish

00:19:27,950 --> 00:19:34,610
parts of your own IP API to the public

00:19:30,680 --> 00:19:44,750
and limit the excess per hour to a day

00:19:34,610 --> 00:19:47,800
or per month it's just Fox app let's

00:19:44,750 --> 00:19:51,050
come back to the benefits and over it um

00:19:47,800 --> 00:19:54,680
if we use a multi-modal approach instead

00:19:51,050 --> 00:19:58,970
of pulling up resistance so the benefits

00:19:54,680 --> 00:20:02,510
are still the same just look at the

00:19:58,970 --> 00:20:05,750
overhead as we use graphs on top of the

00:20:02,510 --> 00:20:09,200
already existing vertex documents we

00:20:05,750 --> 00:20:11,660
don't need to keep things in sync we

00:20:09,200 --> 00:20:14,840
have we just use the data we have in the

00:20:11,660 --> 00:20:18,560
database and just one technology is

00:20:14,840 --> 00:20:21,970
involved so you just need to learn one

00:20:18,560 --> 00:20:24,710
query language and deal with one vendor

00:20:21,970 --> 00:20:33,650
and of course that reduces the

00:20:24,710 --> 00:20:35,360
administration default as well so for

00:20:33,650 --> 00:20:39,200
this part of the view you can keep the

00:20:35,360 --> 00:20:42,290
benefit and you reduce the overhead but

00:20:39,200 --> 00:20:45,920
of course if you use a multi-model

00:20:42,290 --> 00:20:49,010
database you now might not have the best

00:20:45,920 --> 00:20:53,870
specialized number one top prologue of

00:20:49,010 --> 00:21:01,730
each category but the best package for

00:20:53,870 --> 00:21:04,970
building a complete application just a

00:21:01,730 --> 00:21:08,240
quick look on other features of a run

00:21:04,970 --> 00:21:10,850
Goodreads open source and free it can

00:21:08,240 --> 00:21:15,500
shout and support shouting replication

00:21:10,850 --> 00:21:18,890
it has javascript v8 buildin has drivers

00:21:15,500 --> 00:21:21,350
for our right range of languages a

00:21:18,890 --> 00:21:25,790
front-end for administration querying

00:21:21,350 --> 00:21:27,920
and cluster management good and complete

00:21:25,790 --> 00:21:33,490
documentation and professional as well

00:21:27,920 --> 00:21:38,270
as community support so that's all about

00:21:33,490 --> 00:21:38,509
polygon persistence and multimodal but

00:21:38,270 --> 00:21:40,579
as

00:21:38,509 --> 00:21:43,669
we are here in the open source data

00:21:40,579 --> 00:21:45,589
center conference I just want to show

00:21:43,669 --> 00:21:49,159
you another slide that might be of

00:21:45,589 --> 00:21:53,089
interest for you nothing to do with the

00:21:49,159 --> 00:21:56,119
polygraph resistance approach and that's

00:21:53,089 --> 00:21:59,629
a recent project we do under this data

00:21:56,119 --> 00:22:02,149
center rating system integration we are

00:21:59,629 --> 00:22:04,820
currently integrating with apache

00:22:02,149 --> 00:22:08,119
measles and want to use the mazes

00:22:04,820 --> 00:22:11,829
infrastructure for our own cluster

00:22:08,119 --> 00:22:15,769
administration and our own failover

00:22:11,829 --> 00:22:18,979
because we see huge potential to those

00:22:15,769 --> 00:22:22,089
geckos technologies these projects like

00:22:18,979 --> 00:22:25,940
mesosphere darkest warm that offer

00:22:22,089 --> 00:22:28,279
services to simplify and the design and

00:22:25,940 --> 00:22:34,659
implementation of distributed databases

00:22:28,279 --> 00:22:37,909
and we hope that we can announce some

00:22:34,659 --> 00:22:43,309
integrations and some work we did in the

00:22:37,909 --> 00:22:47,539
last week's soon so the whole thing is

00:22:43,309 --> 00:22:54,139
about persistent volumes integration so

00:22:47,539 --> 00:22:56,929
ever containers has gone away we still

00:22:54,139 --> 00:22:59,719
have the data and can start the next

00:22:56,929 --> 00:23:07,959
container and use the same data and

00:22:59,719 --> 00:23:10,190
continue so that's about arango DB and

00:23:07,959 --> 00:23:14,299
multimodal databases pulling up

00:23:10,190 --> 00:23:16,459
resistance RL goobie is a free and open

00:23:14,299 --> 00:23:19,489
source project with contributors from

00:23:16,459 --> 00:23:22,999
all over the world so join our community

00:23:19,489 --> 00:23:27,219
or give a Ranga to be a try and yeah

00:23:22,999 --> 00:23:27,219
thanks if you have any questions please

00:23:30,520 --> 00:23:37,650
any questions to Ingo please go ahead we

00:23:35,050 --> 00:23:37,650
have some time left

00:23:42,480 --> 00:23:47,330
okay Engel thank you very much yeah

00:23:44,760 --> 00:23:47,330

YouTube URL: https://www.youtube.com/watch?v=7Nqozqhb4cs


