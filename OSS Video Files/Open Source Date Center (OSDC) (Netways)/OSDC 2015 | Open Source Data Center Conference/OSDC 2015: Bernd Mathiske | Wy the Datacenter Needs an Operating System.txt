Title: OSDC 2015: Bernd Mathiske | Wy the Datacenter Needs an Operating System
Publication date: 2015-04-29
Playlist: OSDC 2015 | Open Source Data Center Conference
Description: 
	Developers are moving away from their host-based patterns and adopting a new mindset around the idea that the datacenter is the computer. It?s quickly becoming a mainstream model that you can view a warehouse full of servers as a single computer (with terabytes of memory and tens of thousands of cores). There is a key missing piece, which is an operating system for the datacenter (DCOS), which would provide the same OS functionality and core OS abstractions across thousands of machines that an OS provides on a single machine today. In this session, we will discuss:

How the abstraction of an OS has evolved over time and can cleanly scale to spand thousands of machines in a datacenter.
How key open source technologies like the Apache Mesos distributed systems kernel provide the key underpinnings for a DCOS.
How developers can layer core system services on top of a distributed systems kernel, including an init system (Marathon), cron (Chronos), service discovery (DNS), and storage (HDFS)
What would the interface to the DCOS look like? How would you use it?
How you would install and operate datacenter services, including Apache Spark, Apache Cassandra, Apache Kafka, Apache Hadoop, Apache YARN, Apache HDFS, and Google's Kubernetes.
How will developers build datacenter-scale apps, programmed against the datacenter OS like it?s a single machine?
Captions: 
	00:00:06,740 --> 00:00:13,710
hello everybody I suppose I'll stick to

00:00:09,390 --> 00:00:15,030
English um welcome I'm from the company

00:00:13,710 --> 00:00:17,250
mesosphere but i'm not going to

00:00:15,030 --> 00:00:19,140
emphasize that as we go forward because

00:00:17,250 --> 00:00:20,850
i know this is all about open source and

00:00:19,140 --> 00:00:23,130
i want to show you how you can make your

00:00:20,850 --> 00:00:26,220
data center run with open source only of

00:00:23,130 --> 00:00:28,439
course and then we can extrapolate from

00:00:26,220 --> 00:00:33,030
there after the talk maybe but not in

00:00:28,439 --> 00:00:35,610
the talk what's this all about in one

00:00:33,030 --> 00:00:37,110
sentence well this is the title so why

00:00:35,610 --> 00:00:38,820
would we need an operating system where

00:00:37,110 --> 00:00:42,180
other people before us have figured this

00:00:38,820 --> 00:00:44,340
out large company running very large

00:00:42,180 --> 00:00:45,719
clusters has more than a decade of

00:00:44,340 --> 00:00:49,199
experience and what I'm going to talk

00:00:45,719 --> 00:00:52,199
about and what we want to enable is that

00:00:49,199 --> 00:00:56,520
not just them but everybody else who has

00:00:52,199 --> 00:01:01,320
the means and time and effort put in can

00:00:56,520 --> 00:01:03,600
also run a very large scale and there

00:01:01,320 --> 00:01:07,440
has been a lot of beneficial side

00:01:03,600 --> 00:01:09,750
effects of the development that Google

00:01:07,440 --> 00:01:11,820
has been undertaking in tech

00:01:09,750 --> 00:01:13,619
transferring some of the things that

00:01:11,820 --> 00:01:16,159
they came up with and that they've

00:01:13,619 --> 00:01:18,689
leverage to get their enterprise running

00:01:16,159 --> 00:01:20,880
back into the open source pool and other

00:01:18,689 --> 00:01:25,140
people have picked it up and grown these

00:01:20,880 --> 00:01:26,640
efforts for example MapReduce got mold

00:01:25,140 --> 00:01:30,299
into Hadoop and has grown tremendously

00:01:26,640 --> 00:01:33,270
since there has been big table which

00:01:30,299 --> 00:01:36,329
became non SQL databases of for example

00:01:33,270 --> 00:01:38,759
more MongoDB now you can't always draw a

00:01:36,329 --> 00:01:41,759
direct line but there's some connection

00:01:38,759 --> 00:01:43,560
there see groups were donated to the

00:01:41,759 --> 00:01:45,000
open source and are now a really

00:01:43,560 --> 00:01:47,460
important ingredient and what I'm going

00:01:45,000 --> 00:01:49,229
to talk about and then eventually there

00:01:47,460 --> 00:01:51,360
was this really an influential book the

00:01:49,229 --> 00:01:54,899
data center as a computer which is the

00:01:51,360 --> 00:01:57,960
general idea here and our chief

00:01:54,899 --> 00:02:02,130
architect and a few folks around him in

00:01:57,960 --> 00:02:03,810
UC Berkeley formed the methyls operating

00:02:02,130 --> 00:02:06,060
system I don't know Nestle sorry

00:02:03,810 --> 00:02:07,890
distributed system operating system

00:02:06,060 --> 00:02:12,830
kernel you could say in the context i'm

00:02:07,890 --> 00:02:15,900
getting too around that time and that

00:02:12,830 --> 00:02:19,110
the history is that bend and draw on

00:02:15,900 --> 00:02:22,290
twitter and then they adopted this for

00:02:19,110 --> 00:02:24,690
running their clusters with it and they

00:02:22,290 --> 00:02:28,110
have since 2010 being pretty successful

00:02:24,690 --> 00:02:29,010
running on my sauce so that's going to

00:02:28,110 --> 00:02:32,730
be the focus of our

00:02:29,010 --> 00:02:34,260
talk and since then well there have been

00:02:32,730 --> 00:02:35,909
many more frameworks than just what

00:02:34,260 --> 00:02:41,900
Twitter runs on missiles and that will

00:02:35,909 --> 00:02:43,890
also be a topic but let's step back

00:02:41,900 --> 00:02:45,989
there are two things I need to talk

00:02:43,890 --> 00:02:47,700
about here one is data center the others

00:02:45,989 --> 00:02:49,530
OS and then how they're connected and

00:02:47,700 --> 00:02:52,230
how we're going to make it work so let's

00:02:49,530 --> 00:02:54,659
start at the end with OS what happened

00:02:52,230 --> 00:02:57,180
with OSS and where did we come from

00:02:54,659 --> 00:02:59,459
where you where do we want to go and how

00:02:57,180 --> 00:03:02,250
does this new way of doing things relate

00:02:59,459 --> 00:03:04,260
to older efforts where did we do a

00:03:02,250 --> 00:03:07,980
90-degree turn here that's what I want

00:03:04,260 --> 00:03:10,440
to get at so single system OS is for

00:03:07,980 --> 00:03:12,269
these things here and these things they

00:03:10,440 --> 00:03:14,220
went through a lot of development

00:03:12,269 --> 00:03:15,810
developmental stages that have been

00:03:14,220 --> 00:03:18,180
greatly beneficial to where we're at now

00:03:15,810 --> 00:03:19,409
so we went from single something to

00:03:18,180 --> 00:03:22,170
multi something I don't need to

00:03:19,409 --> 00:03:24,389
reiterate that many of you have lived

00:03:22,170 --> 00:03:26,819
through this some of them have

00:03:24,389 --> 00:03:28,170
definitely some recollection of that we

00:03:26,819 --> 00:03:31,079
have more bits more bandwidth more

00:03:28,170 --> 00:03:32,489
storage more everything and then a

00:03:31,079 --> 00:03:36,870
really important step was a

00:03:32,489 --> 00:03:39,090
virtualization alum but virtualization

00:03:36,870 --> 00:03:42,440
initially came for all the wrong reasons

00:03:39,090 --> 00:03:44,609
you wanted to have your Windows software

00:03:42,440 --> 00:03:46,889
resurrected quicker when it crashed

00:03:44,609 --> 00:03:49,199
things like that or you wanted it to be

00:03:46,889 --> 00:03:51,180
isolated you didn't really think about

00:03:49,199 --> 00:03:55,459
large cluster computing when you first

00:03:51,180 --> 00:03:58,230
in a used virtualization I bet right and

00:03:55,459 --> 00:04:01,139
then you wanted also a more lightweight

00:03:58,230 --> 00:04:02,639
way to do it eventually because it costs

00:04:01,139 --> 00:04:05,599
a lot of time and effort to bring up a

00:04:02,639 --> 00:04:08,129
virgin virtual machine or an image and

00:04:05,599 --> 00:04:09,900
then we use it and once you have one

00:04:08,129 --> 00:04:12,090
okay you can copy a few gigabytes and

00:04:09,900 --> 00:04:14,639
you're happy maybe but it would be

00:04:12,090 --> 00:04:18,359
better if it became spiffier so saw

00:04:14,639 --> 00:04:21,090
Along Came containers and they let you

00:04:18,359 --> 00:04:25,169
package things in much more smaller

00:04:21,090 --> 00:04:26,780
format and today we have talker as the

00:04:25,169 --> 00:04:29,669
predominant form it may be the most

00:04:26,780 --> 00:04:32,310
widespread pneus and a lot of talk of

00:04:29,669 --> 00:04:37,650
soccer fans in the room maybe raise your

00:04:32,310 --> 00:04:41,230
hand yay rocket let me container eyes

00:04:37,650 --> 00:04:45,520
this for you all of the above

00:04:41,230 --> 00:04:47,620
yep and well we've gone full circle and

00:04:45,520 --> 00:04:49,420
this for me is the irony we started out

00:04:47,620 --> 00:04:52,390
with static libraries because we didn't

00:04:49,420 --> 00:04:54,700
know any better and then in around two

00:04:52,390 --> 00:04:57,190
early 90s or something the whole craze

00:04:54,700 --> 00:04:59,290
or a little earlier was oh let's build

00:04:57,190 --> 00:05:01,690
dynamic libraries so we can save some

00:04:59,290 --> 00:05:04,000
space and reuse stuff and then then

00:05:01,690 --> 00:05:06,070
configuration became hell because once

00:05:04,000 --> 00:05:07,510
you wanted to reduce a dynamic library

00:05:06,070 --> 00:05:09,240
it might depend on another one because

00:05:07,510 --> 00:05:11,650
it's not baked into the application

00:05:09,240 --> 00:05:14,830
applications downstream might fail and

00:05:11,650 --> 00:05:16,300
so on so forth so but if you use static

00:05:14,830 --> 00:05:19,540
libraries you would run out of disk

00:05:16,300 --> 00:05:22,660
space or memory space or something now

00:05:19,540 --> 00:05:26,020
with ample space lots of available

00:05:22,660 --> 00:05:27,700
resources you can put stuff into static

00:05:26,020 --> 00:05:29,860
libraries guess what this thing is doing

00:05:27,700 --> 00:05:33,000
no dynamic libraries on here as far as I

00:05:29,860 --> 00:05:36,070
know in most apps at least and

00:05:33,000 --> 00:05:37,660
containers you can use dynamic libraries

00:05:36,070 --> 00:05:39,790
or static libraries doesn't matter very

00:05:37,660 --> 00:05:41,650
much they just get thrown into the

00:05:39,790 --> 00:05:42,940
container they sit there and not nicely

00:05:41,650 --> 00:05:44,590
isolate it from somebody else's

00:05:42,940 --> 00:05:46,240
container that uses completely different

00:05:44,590 --> 00:05:51,670
versions and that makes life a lot

00:05:46,240 --> 00:05:53,890
easier okay so moving on next stage so

00:05:51,670 --> 00:05:57,100
basic ways have grown nicely in some

00:05:53,890 --> 00:05:58,780
ways that we like now you have more than

00:05:57,100 --> 00:06:00,490
one computer because one computer by

00:05:58,780 --> 00:06:03,340
itself isn't large enough so what you do

00:06:00,490 --> 00:06:05,170
you put them together draw some wires

00:06:03,340 --> 00:06:08,590
and build some software and you have a

00:06:05,170 --> 00:06:11,200
cluster the first efforts there I don't

00:06:08,590 --> 00:06:13,330
know if a TS is doing a justice to my

00:06:11,200 --> 00:06:14,860
awareness maybe it was in the 70s maybe

00:06:13,330 --> 00:06:16,510
someone can beat me to the punch there

00:06:14,860 --> 00:06:19,150
with the earliest literature but that's

00:06:16,510 --> 00:06:20,710
when I became aware of it people will

00:06:19,150 --> 00:06:24,220
trying to build cluster operating

00:06:20,710 --> 00:06:26,290
systems and by the way asking me any

00:06:24,220 --> 00:06:30,640
questions at any time is totally ok just

00:06:26,290 --> 00:06:33,160
interrupt all right ok and these were

00:06:30,640 --> 00:06:36,070
aiming at high availability load

00:06:33,160 --> 00:06:38,650
balancing and they were very location

00:06:36,070 --> 00:06:40,420
transparent they always try to provide a

00:06:38,650 --> 00:06:42,910
single system image so what you can and

00:06:40,420 --> 00:06:44,980
that's why that's generally a trend in

00:06:42,910 --> 00:06:47,170
computering that you want to preserve

00:06:44,980 --> 00:06:49,000
legacy applications also run them in a

00:06:47,170 --> 00:06:51,730
context that has some new quality that

00:06:49,000 --> 00:06:55,060
same thing applied here and these things

00:06:51,730 --> 00:06:57,250
are still around but they top out

00:06:55,060 --> 00:07:00,060
it may be a few hundred nodes something

00:06:57,250 --> 00:07:06,700
like that anybody managing one of these

00:07:00,060 --> 00:07:08,680
still maybe some of you right compared

00:07:06,700 --> 00:07:10,960
to what we're going to talk about they

00:07:08,680 --> 00:07:12,820
provide a more clean interface to the

00:07:10,960 --> 00:07:15,460
developer maybe because it looks like a

00:07:12,820 --> 00:07:18,669
single system but for the operator

00:07:15,460 --> 00:07:20,830
they're relatively hard to manage and so

00:07:18,669 --> 00:07:23,350
people moved on a little bit but first

00:07:20,830 --> 00:07:25,480
they expand it from there and we went

00:07:23,350 --> 00:07:27,700
from these smaller clusters two grids

00:07:25,480 --> 00:07:31,300
that could span continents and all that

00:07:27,700 --> 00:07:34,330
mainly in the HPC world and there are

00:07:31,300 --> 00:07:35,860
what's known as job schedulers as the

00:07:34,330 --> 00:07:37,750
kind of the kernel of the activities

00:07:35,860 --> 00:07:39,550
there something that you would give a

00:07:37,750 --> 00:07:41,169
description and would run multiple

00:07:39,550 --> 00:07:43,570
programs on your behalf in a certain

00:07:41,169 --> 00:07:46,690
pattern with certain responses to the

00:07:43,570 --> 00:07:50,650
outcomes and so and so forth and these

00:07:46,690 --> 00:07:52,990
schedulers would be using some

00:07:50,650 --> 00:07:55,120
declarative descriptions of what needs

00:07:52,990 --> 00:07:58,500
to happen and would also be reactive to

00:07:55,120 --> 00:08:00,580
fault or faults and all kinds of firm

00:07:58,500 --> 00:08:02,350
self-preserving actions would be in

00:08:00,580 --> 00:08:05,860
there but they will still be relatively

00:08:02,350 --> 00:08:08,710
monolithic now all this was mainly in

00:08:05,860 --> 00:08:10,990
technical computing and maybe in the

00:08:08,710 --> 00:08:12,729
2000s people became where are we all so

00:08:10,990 --> 00:08:15,370
I was working at Sun at the moment so I

00:08:12,729 --> 00:08:18,039
I noticed that things like grid engine

00:08:15,370 --> 00:08:21,130
came up or n1 and things like that way

00:08:18,039 --> 00:08:23,260
back when and people were also at the

00:08:21,130 --> 00:08:25,780
same time a lot in Germany here also

00:08:23,260 --> 00:08:28,389
they went to these soas and all these

00:08:25,780 --> 00:08:30,130
things flow together and people made job

00:08:28,389 --> 00:08:32,770
schedulers a little bit amenable to

00:08:30,130 --> 00:08:36,370
enterprises and people want to run

00:08:32,770 --> 00:08:38,469
classes and enterprises as well so we

00:08:36,370 --> 00:08:39,849
went from grid computing then to grid

00:08:38,469 --> 00:08:41,979
middleware and I'm not going to mention

00:08:39,849 --> 00:08:44,410
Korver because I don't know how it fits

00:08:41,979 --> 00:08:47,980
in here and eventually we ended up with

00:08:44,410 --> 00:08:50,350
cloud stacks all right this is my own

00:08:47,980 --> 00:08:57,310
faked version of history you with me so

00:08:50,350 --> 00:08:59,020
far okay and this and in one aspect of

00:08:57,310 --> 00:09:01,839
this that i want to emphasize is again

00:08:59,020 --> 00:09:06,730
is in the early stages of virtualization

00:09:01,839 --> 00:09:08,560
what we had we had a a server and then

00:09:06,730 --> 00:09:11,200
we would have virtualization and that in

00:09:08,560 --> 00:09:14,260
abled us to run multiple in isolated

00:09:11,200 --> 00:09:15,880
apps there and the emphasis in

00:09:14,260 --> 00:09:20,140
virtualization was really on isolation

00:09:15,880 --> 00:09:22,060
in the beginning and then later so we

00:09:20,140 --> 00:09:23,620
had small apps and we build it bigger

00:09:22,060 --> 00:09:28,120
and bigger and bigger servers that could

00:09:23,620 --> 00:09:30,700
run more VMs and nowadays we're trying

00:09:28,120 --> 00:09:33,400
to build big apps but we make them from

00:09:30,700 --> 00:09:36,520
small things and we have lots of them

00:09:33,400 --> 00:09:37,900
swarms of them and we have many many

00:09:36,520 --> 00:09:39,910
many servers and we don't really care

00:09:37,900 --> 00:09:43,260
how capable the individual servers are

00:09:39,910 --> 00:09:46,750
unless we need something special like

00:09:43,260 --> 00:09:48,520
there is a lot of data in RAM that we

00:09:46,750 --> 00:09:50,320
need to hold for a certain task or we

00:09:48,520 --> 00:09:52,360
need a certain GPU or something but

00:09:50,320 --> 00:10:00,130
absent that you can chop chop chop chop

00:09:52,360 --> 00:10:03,070
chop and so and then you can come out a

00:10:00,130 --> 00:10:07,270
die commoditize horizontally and you end

00:10:03,070 --> 00:10:11,070
up with cloud computing and then you

00:10:07,270 --> 00:10:14,020
have all these keywords SAS pass is and

00:10:11,070 --> 00:10:17,500
the frontrunners historically speaking

00:10:14,020 --> 00:10:21,180
where Salesforce and maybe amazon with

00:10:17,500 --> 00:10:23,080
AWS that had the first big successes and

00:10:21,180 --> 00:10:24,790
established this and then everybody

00:10:23,080 --> 00:10:28,800
followed but it wasn't for the lack of

00:10:24,790 --> 00:10:31,060
trying of others before them and

00:10:28,800 --> 00:10:33,940
importantly there are these different

00:10:31,060 --> 00:10:36,010
system layers and the question is if we

00:10:33,940 --> 00:10:38,830
build an operating system for the data

00:10:36,010 --> 00:10:42,150
center what layer would it be at would

00:10:38,830 --> 00:10:45,610
it be like these original cluster os's

00:10:42,150 --> 00:10:48,430
trying to hack the colonel and expand it

00:10:45,610 --> 00:10:51,700
with distribution capabilities or would

00:10:48,430 --> 00:10:53,410
be above these OSS and if so would be at

00:10:51,700 --> 00:10:55,690
one of these three levels where would

00:10:53,410 --> 00:10:58,720
you suspect i would get up and get set

00:10:55,690 --> 00:11:00,910
up and meanwhile we can observe that

00:10:58,720 --> 00:11:02,950
people have been not only using public

00:11:00,910 --> 00:11:04,630
cloud but they've also built their

00:11:02,950 --> 00:11:06,700
private cloud stacks and that is may be

00:11:04,630 --> 00:11:10,330
informative where this might be heading

00:11:06,700 --> 00:11:13,120
and there are some older ones some newer

00:11:10,330 --> 00:11:15,250
ones and i suppose a lot of you have

00:11:13,120 --> 00:11:18,730
probably worked on OpenStack maybe

00:11:15,250 --> 00:11:20,390
someone yeah that seems common or

00:11:18,730 --> 00:11:24,460
cloudstack or

00:11:20,390 --> 00:11:31,760
okay not so many what's your preference

00:11:24,460 --> 00:11:33,830
anyone okay so these are the questions

00:11:31,760 --> 00:11:36,140
that tivity come up so a lot of the

00:11:33,830 --> 00:11:38,530
industry is kind of sitting at this in

00:11:36,140 --> 00:11:41,300
this area of discussion I'm I sense

00:11:38,530 --> 00:11:43,790
maybe not everybody in the room here but

00:11:41,300 --> 00:11:48,770
I hear that a lot I use this one no I

00:11:43,790 --> 00:11:51,200
should be using that one and okay what's

00:11:48,770 --> 00:11:53,270
this for anyway well you want to run a

00:11:51,200 --> 00:11:55,370
data center somehow what's a data center

00:11:53,270 --> 00:11:59,480
where I I looked up a website that

00:11:55,370 --> 00:12:04,550
starts with a W and it says a facility

00:11:59,480 --> 00:12:06,800
to house computer systems and associated

00:12:04,550 --> 00:12:11,780
components are could be networking

00:12:06,800 --> 00:12:13,910
storage cooling sensors whatever so most

00:12:11,780 --> 00:12:15,950
of the time a day nurse center doesn't

00:12:13,910 --> 00:12:18,620
only host one cluster it may have

00:12:15,950 --> 00:12:20,390
several and you may have one for your

00:12:18,620 --> 00:12:22,490
web services another one for your

00:12:20,390 --> 00:12:24,680
analytics another one for testing

00:12:22,490 --> 00:12:27,830
another one for development and so on so

00:12:24,680 --> 00:12:29,690
forth and what I'm trying to convince

00:12:27,830 --> 00:12:33,140
you off is that at least for production

00:12:29,690 --> 00:12:35,930
you don't need so many and that has

00:12:33,140 --> 00:12:38,180
certain advantages so that's what I want

00:12:35,930 --> 00:12:40,670
to focus on how we get end up with just

00:12:38,180 --> 00:12:43,400
one production class i well I personally

00:12:40,670 --> 00:12:44,960
would still run a test luster aside from

00:12:43,400 --> 00:12:46,850
it so that they don't influence each

00:12:44,960 --> 00:12:49,010
other because it can never be sure

00:12:46,850 --> 00:12:50,630
whatever you're using to run your class

00:12:49,010 --> 00:12:54,800
or that it has no interference

00:12:50,630 --> 00:12:56,840
whatsoever but for the purpose of

00:12:54,800 --> 00:13:00,410
running your business 11 should do the

00:12:56,840 --> 00:13:04,190
trick aside from geographic redundancy

00:13:00,410 --> 00:13:06,950
and all that kind of stuff um so talking

00:13:04,190 --> 00:13:09,290
about one location and these clusters

00:13:06,950 --> 00:13:11,210
that I'm usually concerned with their

00:13:09,290 --> 00:13:14,420
there in the tens to tens of thousands

00:13:11,210 --> 00:13:16,940
of nodes so it is a large large range

00:13:14,420 --> 00:13:19,070
and I'm going to get to why it should be

00:13:16,940 --> 00:13:21,710
such a large range but what we don't

00:13:19,070 --> 00:13:24,590
want to have is that you have a small

00:13:21,710 --> 00:13:26,390
little company you end up buying a few

00:13:24,590 --> 00:13:29,630
computers you hook them up to the

00:13:26,390 --> 00:13:31,850
network you deploy your app you grow and

00:13:29,630 --> 00:13:33,290
you have a million customers now you

00:13:31,850 --> 00:13:37,519
need a hundred servers so

00:13:33,290 --> 00:13:39,470
you move to some other cluster maybe go

00:13:37,519 --> 00:13:43,699
to rec space or something or you go to

00:13:39,470 --> 00:13:46,910
AWS or GCE and you migrate there then

00:13:43,699 --> 00:13:49,160
you run up the builds once you reach 500

00:13:46,910 --> 00:13:51,050
or 1000 nodes and you know the school

00:13:49,160 --> 00:13:53,120
that's getting kind of expensive maybe I

00:13:51,050 --> 00:13:54,860
should have my own on-prem solution and

00:13:53,120 --> 00:13:56,240
you want to move back and you buy a

00:13:54,860 --> 00:13:57,860
thousand computers and you put your

00:13:56,240 --> 00:14:02,149
stuff back there guess how long that

00:13:57,860 --> 00:14:06,829
takes any experience values I mean yeah

00:14:02,149 --> 00:14:09,769
so so it costs time and time is terrible

00:14:06,829 --> 00:14:12,380
is probably worse than money and it also

00:14:09,769 --> 00:14:14,180
costs a lot of money to move around so

00:14:12,380 --> 00:14:16,810
what can we do to mitigate that that's

00:14:14,180 --> 00:14:20,240
also something we're thinking about and

00:14:16,810 --> 00:14:22,220
yeah if you have several clusters then

00:14:20,240 --> 00:14:23,720
they have different requirements how you

00:14:22,220 --> 00:14:25,550
move them you're probably using

00:14:23,720 --> 00:14:26,990
different techniques to set them up so

00:14:25,550 --> 00:14:30,790
you also need to front techniques to

00:14:26,990 --> 00:14:33,259
move them and all gets very very complex

00:14:30,790 --> 00:14:36,649
what do you run a run on these things in

00:14:33,259 --> 00:14:38,839
the first place so this is the menu I

00:14:36,649 --> 00:14:41,500
brought what I was thinking people would

00:14:38,839 --> 00:14:46,089
want to run these days when they run

00:14:41,500 --> 00:14:48,589
internet-facing services for others on

00:14:46,089 --> 00:14:51,920
lamb stacks are pretty popular i guess

00:14:48,589 --> 00:14:53,839
anyone using one something similar i

00:14:51,920 --> 00:14:57,139
mean the general category not exactly

00:14:53,839 --> 00:15:00,769
linux apache mysql PHP sure right

00:14:57,139 --> 00:15:02,209
happens every day everybody has one you

00:15:00,769 --> 00:15:05,449
have a website you have something like

00:15:02,209 --> 00:15:07,790
that or you run a mean stack probably

00:15:05,449 --> 00:15:10,130
not quite as much but there are more and

00:15:07,790 --> 00:15:11,600
more things happening in jas that get

00:15:10,130 --> 00:15:13,870
more and more complex a lot of people

00:15:11,600 --> 00:15:16,160
also liked to use react or whatever and

00:15:13,870 --> 00:15:18,769
replace some of these pieces with others

00:15:16,160 --> 00:15:21,949
but the principle stays the same you you

00:15:18,769 --> 00:15:25,279
have these servers that are long running

00:15:21,949 --> 00:15:27,260
services that start and should never go

00:15:25,279 --> 00:15:28,790
down and that you want to upgrade while

00:15:27,260 --> 00:15:31,160
they're in flight you want to scale them

00:15:28,790 --> 00:15:33,560
horizontally and shrink them depending

00:15:31,160 --> 00:15:35,149
on how much demand there is and then you

00:15:33,560 --> 00:15:37,910
have these other things that run mostly

00:15:35,149 --> 00:15:39,709
as batch jobs where you try to find out

00:15:37,910 --> 00:15:42,380
what happened over the day probably run

00:15:39,709 --> 00:15:44,959
those at night and then you fill your

00:15:42,380 --> 00:15:46,910
databases with things from both of them

00:15:44,959 --> 00:15:47,270
then you want to do some data mining on

00:15:46,910 --> 00:15:49,280
that

00:15:47,270 --> 00:15:51,520
and so on so these are typical things

00:15:49,280 --> 00:15:56,750
right have I forgotten anything

00:15:51,520 --> 00:15:59,210
suggestions okay so I'm thinking with we

00:15:56,750 --> 00:16:01,580
call them frameworks with services or

00:15:59,210 --> 00:16:04,400
service infrastructure pieces like these

00:16:01,580 --> 00:16:06,440
you can go a long way and we have here

00:16:04,400 --> 00:16:10,070
search elasticsearch we have some

00:16:06,440 --> 00:16:11,570
database stuff we have for Jenkins for

00:16:10,070 --> 00:16:14,330
sure if you're in development and

00:16:11,570 --> 00:16:16,250
continuous integration you use that we

00:16:14,330 --> 00:16:19,160
use that we can run Jenkins on missiles

00:16:16,250 --> 00:16:24,230
and we can run missiles on Jenkins can

00:16:19,160 --> 00:16:27,470
so that's fun and spark and storm torque

00:16:24,230 --> 00:16:32,690
whatever and you may even decide to run

00:16:27,470 --> 00:16:35,320
to host your own private services and

00:16:32,690 --> 00:16:39,110
days is just one of the possible

00:16:35,320 --> 00:16:41,320
solutions there okay now what I wanted

00:16:39,110 --> 00:16:45,260
to list here were things that are

00:16:41,320 --> 00:16:46,490
ninety-nine percent sure open source so

00:16:45,260 --> 00:16:49,010
you can put your business together

00:16:46,490 --> 00:16:50,930
without actually buying too much and you

00:16:49,010 --> 00:16:52,670
can be sure that you have an insight and

00:16:50,930 --> 00:16:56,420
how things run and so on and all the

00:16:52,670 --> 00:17:01,670
other advantages you get now let's put

00:16:56,420 --> 00:17:05,360
this on on in reverse so you're up and

00:17:01,670 --> 00:17:06,950
running aren't you happy and how do you

00:17:05,360 --> 00:17:10,010
want to actually install these things

00:17:06,950 --> 00:17:11,839
and set them up and run them I said

00:17:10,010 --> 00:17:14,900
eventually we want to end up with the

00:17:11,839 --> 00:17:16,520
data center looking like this so turning

00:17:14,900 --> 00:17:17,959
this on its head what if this thing

00:17:16,520 --> 00:17:22,040
looked like a data center what would it

00:17:17,959 --> 00:17:25,310
look like or one of these in a former

00:17:22,040 --> 00:17:28,370
incarnation so you would start a program

00:17:25,310 --> 00:17:31,490
say in turn into a ie whatever that is

00:17:28,370 --> 00:17:33,580
and you would then be asked which cpu

00:17:31,490 --> 00:17:36,710
would you like to run this on sir or

00:17:33,580 --> 00:17:39,440
like way back when anyone used things

00:17:36,710 --> 00:17:41,240
like mac OS 6 I don't know that's maybe

00:17:39,440 --> 00:17:46,070
most of the audience too young for that

00:17:41,240 --> 00:17:47,840
um so you would be asked how much is the

00:17:46,070 --> 00:17:50,360
minimum of memory you want to give this

00:17:47,840 --> 00:17:52,610
app and how much the Mac maximum I'm i

00:17:50,360 --> 00:17:55,700
remember faintly that Dawson windows had

00:17:52,610 --> 00:17:57,670
similar things and other os's you don't

00:17:55,700 --> 00:17:59,720
want to do that right not if you're in a

00:17:57,670 --> 00:18:00,860
computer these days you just double

00:17:59,720 --> 00:18:03,140
click and the thing start

00:18:00,860 --> 00:18:05,630
up and why why do we go through this

00:18:03,140 --> 00:18:07,730
pain and the data center where we set up

00:18:05,630 --> 00:18:11,090
lists of nodes that participate in an

00:18:07,730 --> 00:18:12,890
application where we set up port numbers

00:18:11,090 --> 00:18:15,590
where they connect to each other and

00:18:12,890 --> 00:18:17,660
then if that fails that we set up

00:18:15,590 --> 00:18:20,570
complicated routines to find them again

00:18:17,660 --> 00:18:22,640
where we tell the developers if you open

00:18:20,570 --> 00:18:25,850
a socket connection make sure you have a

00:18:22,640 --> 00:18:28,790
strategy when it fails to regain control

00:18:25,850 --> 00:18:30,710
of that connection look at and we have

00:18:28,790 --> 00:18:33,400
different strategies for the head we

00:18:30,710 --> 00:18:37,730
have timeouts all over the place right

00:18:33,400 --> 00:18:39,350
so that's a lot like this and I'm not

00:18:37,730 --> 00:18:42,980
saying it's going to go away I'm just

00:18:39,350 --> 00:18:45,710
saying we can make it better another

00:18:42,980 --> 00:18:47,840
problem that we have is we have a lot of

00:18:45,710 --> 00:18:49,940
static partitioning which I said earlier

00:18:47,840 --> 00:18:52,309
is that you have these dedicated

00:18:49,940 --> 00:18:54,470
clusters that you know what they're

00:18:52,309 --> 00:18:56,630
doing you know that they're not failing

00:18:54,470 --> 00:18:59,450
in what they're doing so for example you

00:18:56,630 --> 00:19:02,780
run a big data cluster that runs a lot

00:18:59,450 --> 00:19:06,350
of parallel MapReduce jobs and you know

00:19:02,780 --> 00:19:09,260
approx that your database and your data

00:19:06,350 --> 00:19:10,790
in flux are this in that size you have

00:19:09,260 --> 00:19:12,950
so many customers on average they

00:19:10,790 --> 00:19:15,020
produce this many data so you need to

00:19:12,950 --> 00:19:17,690
run say fifteen thousand six hundred

00:19:15,020 --> 00:19:21,679
jobs on average maybe sometimes twenty

00:19:17,690 --> 00:19:23,630
thousand sometimes 13,000 and and then

00:19:21,679 --> 00:19:27,350
you sighs your cluster according to that

00:19:23,630 --> 00:19:29,809
and then if that changes you go into

00:19:27,350 --> 00:19:31,429
budget discussions with your bosses here

00:19:29,809 --> 00:19:33,169
I've he deep or administrators and

00:19:31,429 --> 00:19:36,230
everybody and that happens again and

00:19:33,169 --> 00:19:37,549
again and because of the static

00:19:36,230 --> 00:19:40,429
partitioning you have to do this not

00:19:37,549 --> 00:19:42,650
just for one cluster but for several so

00:19:40,429 --> 00:19:45,590
the general idea of grossly simplified I

00:19:42,650 --> 00:19:47,240
have to apologize for that is that you

00:19:45,590 --> 00:19:48,860
may sometimes have workloads that are

00:19:47,240 --> 00:19:50,450
complementary to each other like for

00:19:48,860 --> 00:19:54,020
example you're running a business within

00:19:50,450 --> 00:19:57,290
customer serving facing web servers then

00:19:54,020 --> 00:19:59,570
at least in some geo's will have this

00:19:57,290 --> 00:20:00,890
shape wear during the day people by in

00:19:59,570 --> 00:20:03,679
the morning they sleep in the evening

00:20:00,890 --> 00:20:05,270
they sleep right and then at night you

00:20:03,679 --> 00:20:07,669
analyze what they're doing with your

00:20:05,270 --> 00:20:10,160
Hadoop jobs and you have some memcache

00:20:07,669 --> 00:20:13,900
stuff that runs during the day or

00:20:10,160 --> 00:20:15,970
whatever for your analyst psyching away

00:20:13,900 --> 00:20:18,880
and if you put this together just these

00:20:15,970 --> 00:20:21,670
shapes here would fit into one cluster

00:20:18,880 --> 00:20:25,390
but if you keep them separate so that

00:20:21,670 --> 00:20:29,140
you can scale then days you may be

00:20:25,390 --> 00:20:31,030
wasting a lot of machines not everybody

00:20:29,140 --> 00:20:33,340
is very interested in this aspect I'm

00:20:31,030 --> 00:20:34,720
getting to that but that is but some

00:20:33,340 --> 00:20:36,490
people are and if they are they're

00:20:34,720 --> 00:20:39,610
really interested and there are two

00:20:36,490 --> 00:20:41,800
sides to this we know people who have a

00:20:39,610 --> 00:20:46,080
similar problem but slightly different

00:20:41,800 --> 00:20:48,370
they have a fixed amount of servers and

00:20:46,080 --> 00:20:50,680
they know how many they're going to have

00:20:48,370 --> 00:20:53,470
and it's going to be stable for say half

00:20:50,680 --> 00:20:55,360
a year to a year and all that matters is

00:20:53,470 --> 00:20:58,630
how much they can do it's not how much

00:20:55,360 --> 00:21:01,030
it costs so it's important then to drive

00:20:58,630 --> 00:21:02,950
resource utilization rates up so that

00:21:01,030 --> 00:21:05,080
they get more query served for example

00:21:02,950 --> 00:21:06,880
with the given hardware so you can see

00:21:05,080 --> 00:21:08,710
there's two ways or you can say what's

00:21:06,880 --> 00:21:12,760
the least amount of hardware I need to

00:21:08,710 --> 00:21:14,470
run my business alright so the proposed

00:21:12,760 --> 00:21:17,500
solution is instead of hardware class

00:21:14,470 --> 00:21:18,400
ring didn't leave that one as a mystery

00:21:17,500 --> 00:21:20,200
here we're going to do software

00:21:18,400 --> 00:21:24,400
clustering that's been around for a

00:21:20,200 --> 00:21:27,790
while so we put a layer between the OSS

00:21:24,400 --> 00:21:31,840
and here i mean linux variants for

00:21:27,790 --> 00:21:35,050
single notes and those application

00:21:31,840 --> 00:21:37,480
frameworks and this layer is supposed to

00:21:35,050 --> 00:21:40,390
provide us a scale not the tendency and

00:21:37,480 --> 00:21:46,360
high availability for tolerance all the

00:21:40,390 --> 00:21:48,460
good stuff so now that we talked about

00:21:46,360 --> 00:21:50,620
the stuff we want to run we need to talk

00:21:48,460 --> 00:21:53,020
about the stuff that enables us to run

00:21:50,620 --> 00:21:56,680
all that and that also comes from open

00:21:53,020 --> 00:21:59,260
source so the chord thing that I want to

00:21:56,680 --> 00:22:03,370
spend some time on on significant amount

00:21:59,260 --> 00:22:06,160
of time on is Apache mesos it's the as

00:22:03,370 --> 00:22:08,380
far as i know only full two-level

00:22:06,160 --> 00:22:09,790
scheduler and open source that i'm aware

00:22:08,380 --> 00:22:11,680
of right now maybe there are others

00:22:09,790 --> 00:22:14,200
please educate me if you know some I

00:22:11,680 --> 00:22:18,700
know some one and a half level 1 level

00:22:14,200 --> 00:22:23,860
schedulers but none of them work exactly

00:22:18,700 --> 00:22:25,390
this way yes yes I will that's on the

00:22:23,860 --> 00:22:27,140
subsequent slides but that's the key

00:22:25,390 --> 00:22:30,320
question exactly

00:22:27,140 --> 00:22:32,720
and then we have some meta frameworks

00:22:30,320 --> 00:22:35,690
those are frameworks a framework is

00:22:32,720 --> 00:22:38,710
something that works with the scheduler

00:22:35,690 --> 00:22:40,880
as an application and runs tasks and

00:22:38,710 --> 00:22:43,000
I'll get to that and then there are

00:22:40,880 --> 00:22:45,860
frameworks that run other frameworks or

00:22:43,000 --> 00:22:48,170
services that run other services think

00:22:45,860 --> 00:22:49,880
of it like the energy demon in your OS

00:22:48,170 --> 00:22:51,920
for example it you could say that's an

00:22:49,880 --> 00:22:54,440
application of the OS but really it's a

00:22:51,920 --> 00:22:56,120
service that enables your OS that

00:22:54,440 --> 00:22:58,370
happens to run on it and runs other

00:22:56,120 --> 00:23:01,100
things you need something like that also

00:22:58,370 --> 00:23:02,630
and we have that marathon is an example

00:23:01,100 --> 00:23:04,850
of that or you need something that runs

00:23:02,630 --> 00:23:06,850
cron jobs for you and so we have that or

00:23:04,850 --> 00:23:09,170
roll round Kronos can do that and

00:23:06,850 --> 00:23:12,920
communities does a lot of similar things

00:23:09,170 --> 00:23:15,350
and so does swarm granadas aggregates

00:23:12,920 --> 00:23:17,180
applications nicely into pods and you

00:23:15,350 --> 00:23:20,440
may have heard a talk about this at this

00:23:17,180 --> 00:23:22,940
conference so that's really cool and

00:23:20,440 --> 00:23:24,770
another problem you need to solve a

00:23:22,940 --> 00:23:26,570
service discovery so when you have

00:23:24,770 --> 00:23:28,310
multiple task running how they do they

00:23:26,570 --> 00:23:31,330
find and refined each other and there

00:23:28,310 --> 00:23:34,400
are some open source solutions to that

00:23:31,330 --> 00:23:37,460
console a chai proxy mezzos DNS and they

00:23:34,400 --> 00:23:39,830
all work differently and everybody and

00:23:37,460 --> 00:23:41,710
his buddy have a different solution for

00:23:39,830 --> 00:23:44,780
that and everybody uses a different one

00:23:41,710 --> 00:23:48,760
we don't have the solution yet that's a

00:23:44,780 --> 00:23:51,560
vexing point and we're working on it and

00:23:48,760 --> 00:23:55,940
you also need for failover securing

00:23:51,560 --> 00:23:59,500
scenarios some leader election stuff and

00:23:55,940 --> 00:24:02,560
some persistent key value store and

00:23:59,500 --> 00:24:05,510
zookeeper and Etsy d come to mind their

00:24:02,560 --> 00:24:07,010
as something else if you're an

00:24:05,510 --> 00:24:08,300
application developer and you viewed

00:24:07,010 --> 00:24:11,480
from that point of view you don't want

00:24:08,300 --> 00:24:14,810
to reinvent the wheel and build your own

00:24:11,480 --> 00:24:16,670
storage format and and storage bring

00:24:14,810 --> 00:24:19,370
your storage system to your service so

00:24:16,670 --> 00:24:22,010
it's often the case that you have a flat

00:24:19,370 --> 00:24:24,800
storage scenario with something

00:24:22,010 --> 00:24:27,740
pre-installed okay you use Linux

00:24:24,800 --> 00:24:30,770
obviously and then let's get to your

00:24:27,740 --> 00:24:33,830
question so among these components the

00:24:30,770 --> 00:24:36,620
key component is the scheduler two-level

00:24:33,830 --> 00:24:38,840
scheduling is following this principle

00:24:36,620 --> 00:24:40,780
here that the application specific

00:24:38,840 --> 00:24:43,930
functions should be in the hand of the

00:24:40,780 --> 00:24:45,820
application a monolithic scheduler will

00:24:43,930 --> 00:24:48,040
get a vague description more or less

00:24:45,820 --> 00:24:50,170
vague sometimes quite accurate but not

00:24:48,040 --> 00:24:52,210
in general quite accurate description of

00:24:50,170 --> 00:24:54,130
what the application wants in a

00:24:52,210 --> 00:24:57,400
two-level scheduler the application

00:24:54,130 --> 00:25:00,280
contains written program that spells out

00:24:57,400 --> 00:25:01,930
what in what situation at wants and I'm

00:25:00,280 --> 00:25:06,880
going to have a graphic how that works

00:25:01,930 --> 00:25:08,800
with missiles so the the scheduler asks

00:25:06,880 --> 00:25:10,570
the application here here are some

00:25:08,800 --> 00:25:12,430
resources what you want to do with them

00:25:10,570 --> 00:25:14,740
and that can be a turing-complete

00:25:12,430 --> 00:25:18,960
program making these decisions instead

00:25:14,740 --> 00:25:22,570
of just a matching of some attributes

00:25:18,960 --> 00:25:24,460
and I think that's a requirement for

00:25:22,570 --> 00:25:26,260
general multi-tenancy you get some

00:25:24,460 --> 00:25:28,120
multi-tenancy but not the complete

00:25:26,260 --> 00:25:32,740
general case solved if you don't go that

00:25:28,120 --> 00:25:34,390
extreme okay so here's how how mrs.

00:25:32,740 --> 00:25:37,960
works as an example of this as an

00:25:34,390 --> 00:25:40,300
instance of that you have the

00:25:37,960 --> 00:25:42,370
application there that let's say that's

00:25:40,300 --> 00:25:43,870
your Hadoop application that collects

00:25:42,370 --> 00:25:46,030
your customer data and pulls them down

00:25:43,870 --> 00:25:50,260
to who's who's buying the most shoes

00:25:46,030 --> 00:25:52,870
okay something like that and the

00:25:50,260 --> 00:25:55,660
framework is then Hadoop or or spark or

00:25:52,870 --> 00:25:57,550
something else and you use an adapted

00:25:55,660 --> 00:26:00,370
version that has a little piece of

00:25:57,550 --> 00:26:02,500
software in it that issues the task

00:26:00,370 --> 00:26:04,240
commands and that one will listen to the

00:26:02,500 --> 00:26:05,680
measles master the missiles master

00:26:04,240 --> 00:26:08,710
before and has listened to the Maysles

00:26:05,680 --> 00:26:12,700
slave the slave is a think of it as a

00:26:08,710 --> 00:26:14,650
node control demon analyzes what it's

00:26:12,700 --> 00:26:16,540
running on and reports to the master

00:26:14,650 --> 00:26:21,010
which you can think of as the cluster

00:26:16,540 --> 00:26:22,390
control demon here's what I got the

00:26:21,010 --> 00:26:25,300
master collects this from each slave

00:26:22,390 --> 00:26:27,370
could be a thousand slaves makes a list

00:26:25,300 --> 00:26:29,560
also knows all the applications that run

00:26:27,370 --> 00:26:30,760
against it matches them up in an

00:26:29,560 --> 00:26:33,070
algorithm finds out who's the most

00:26:30,760 --> 00:26:35,380
hungry the most starving app and gives

00:26:33,070 --> 00:26:37,120
gives them some resource offers and then

00:26:35,380 --> 00:26:39,190
the apps and this is the two-level part

00:26:37,120 --> 00:26:41,140
of it decide whether to take these

00:26:39,190 --> 00:26:43,180
offers reject them or take them

00:26:41,140 --> 00:26:45,730
partially and launch tasks against these

00:26:43,180 --> 00:26:47,950
available resources okay so it's a give

00:26:45,730 --> 00:26:50,590
and take and what we're solving here is

00:26:47,950 --> 00:26:54,000
a really hard problem is the knapsack

00:26:50,590 --> 00:26:54,000
orb impact problem and

00:26:54,130 --> 00:26:59,830
you have a monolithic algorithms they

00:26:57,910 --> 00:27:03,520
use a kind of a heuristic to solve it

00:26:59,830 --> 00:27:06,100
and this uses an emergent behavior so

00:27:03,520 --> 00:27:12,100
that tends to work a little better on

00:27:06,100 --> 00:27:13,960
average and of course master can die so

00:27:12,100 --> 00:27:16,170
if that guy dies then you can get a new

00:27:13,960 --> 00:27:18,550
one and you have someone stand by and

00:27:16,170 --> 00:27:21,310
same for slaves you can do a lot of that

00:27:18,550 --> 00:27:25,090
and the framework needs to provide two

00:27:21,310 --> 00:27:27,490
parts the schedulers one the executor is

00:27:25,090 --> 00:27:30,010
the other that's a you could say a task

00:27:27,490 --> 00:27:32,650
supervision demon something that the

00:27:30,010 --> 00:27:34,960
slave starts before it starts the task

00:27:32,650 --> 00:27:37,030
and that then decides how to run the

00:27:34,960 --> 00:27:38,620
task and finds out whether it's still

00:27:37,030 --> 00:27:40,180
running with its lost or killed or

00:27:38,620 --> 00:27:41,860
something and reports that back to the

00:27:40,180 --> 00:27:44,140
framework indirectly through the master

00:27:41,860 --> 00:27:46,450
and this is how you keep tally of what

00:27:44,140 --> 00:27:47,620
your tasks are doing you know when

00:27:46,450 --> 00:27:50,140
they're gone you know when they're

00:27:47,620 --> 00:27:53,320
successful and so in the framework you

00:27:50,140 --> 00:27:56,200
have to program something that basically

00:27:53,320 --> 00:27:58,270
does all the bookkeeping for that and so

00:27:56,200 --> 00:28:02,050
it's cooperative you can think of that

00:27:58,270 --> 00:28:04,540
as yeah a kind of cooperative behavior

00:28:02,050 --> 00:28:06,790
as in cooperative multitasking a lot can

00:28:04,540 --> 00:28:08,350
go wrong but if everybody does it right

00:28:06,790 --> 00:28:10,390
you have a very balanced view of the

00:28:08,350 --> 00:28:14,440
world now not everybody needs to

00:28:10,390 --> 00:28:16,420
implement a scheduler though um you can

00:28:14,440 --> 00:28:19,750
run your application in different ways

00:28:16,420 --> 00:28:21,640
you can run a vanilla job and if you

00:28:19,750 --> 00:28:23,950
want to do that so you have a monolithic

00:28:21,640 --> 00:28:25,330
app maybe I have an echo hello world

00:28:23,950 --> 00:28:26,970
lying somewhere and it's really

00:28:25,330 --> 00:28:30,160
important to me I just want to run that

00:28:26,970 --> 00:28:32,380
or something similar that has input run

00:28:30,160 --> 00:28:33,940
this output and I don't want to modify

00:28:32,380 --> 00:28:37,360
it I don't want to build a framework out

00:28:33,940 --> 00:28:40,840
of it it just needs to run at 1602 today

00:28:37,360 --> 00:28:42,970
and only if maybe the other app has

00:28:40,840 --> 00:28:45,610
produced the output you can program all

00:28:42,970 --> 00:28:48,120
this in a meta framework that Chronos

00:28:45,610 --> 00:28:51,670
for example that provides all the

00:28:48,120 --> 00:28:55,020
scheduling in it and then just uses

00:28:51,670 --> 00:28:58,480
linux to run that task and observe it

00:28:55,020 --> 00:29:01,510
okay and reports back to missiles so you

00:28:58,480 --> 00:29:02,920
can wrap a pre-existing legacy apps that

00:29:01,510 --> 00:29:05,350
are not too complex and distribution

00:29:02,920 --> 00:29:07,059
that way

00:29:05,350 --> 00:29:08,080
second step is where you do write your

00:29:07,059 --> 00:29:10,450
own software and I'm going to show you

00:29:08,080 --> 00:29:12,669
how to in to play with missiles that

00:29:10,450 --> 00:29:14,890
will be on subsequent slides I'm going

00:29:12,669 --> 00:29:17,020
to give you a gist of that that's not

00:29:14,890 --> 00:29:18,610
the regular case you can do that but

00:29:17,020 --> 00:29:21,270
typically someone will do that for you

00:29:18,610 --> 00:29:24,250
and then there will be a large amount of

00:29:21,270 --> 00:29:26,289
additional application logic that's kind

00:29:24,250 --> 00:29:28,179
of prefabricated and then you build your

00:29:26,289 --> 00:29:29,620
app on top of that Hadoop would be an

00:29:28,179 --> 00:29:31,179
example spark would be an example you

00:29:29,620 --> 00:29:34,480
wouldn't rebuild spark for your one

00:29:31,179 --> 00:29:36,720
analytics app okay you would use it it

00:29:34,480 --> 00:29:38,980
would already come with missiles and

00:29:36,720 --> 00:29:42,250
then you would build your app on top of

00:29:38,980 --> 00:29:44,230
that and this way we finally end up with

00:29:42,250 --> 00:29:48,130
something that resembles more or less

00:29:44,230 --> 00:29:50,350
than or s with services then is more

00:29:48,130 --> 00:29:53,429
than something that is just a kernel and

00:29:50,350 --> 00:29:59,230
then you write raw apps against that

00:29:53,429 --> 00:30:02,490
third way is you have services that are

00:29:59,230 --> 00:30:06,880
a lot like the vanilla jobs but they

00:30:02,490 --> 00:30:08,950
come in a special group format for

00:30:06,880 --> 00:30:10,419
example web servers you want to scale

00:30:08,950 --> 00:30:12,669
them out horizontally and they're all

00:30:10,419 --> 00:30:15,789
the same and they need to know where the

00:30:12,669 --> 00:30:17,860
load balancer is so that's a little bit

00:30:15,789 --> 00:30:20,320
more sophisticated than the pure vanilla

00:30:17,860 --> 00:30:21,850
app and then you use a what we call a

00:30:20,320 --> 00:30:24,309
meta framework is a framework that

00:30:21,850 --> 00:30:26,860
speaks to missiles on behalf of these it

00:30:24,309 --> 00:30:29,799
knows how to make new ones how to

00:30:26,860 --> 00:30:31,090
upgrade them in a rolling way knows a

00:30:29,799 --> 00:30:32,710
little bit about the composition

00:30:31,090 --> 00:30:34,600
coronaries knows a lot about the

00:30:32,710 --> 00:30:38,320
composition of the general app from

00:30:34,600 --> 00:30:39,970
these small ones and somehow for these

00:30:38,320 --> 00:30:43,870
apps you solve the service discovery

00:30:39,970 --> 00:30:46,150
problem several options you can play a

00:30:43,870 --> 00:30:47,350
lot with communities darker missus dns

00:30:46,150 --> 00:30:48,909
things like that there's always an

00:30:47,350 --> 00:30:52,960
option for you depending on what you're

00:30:48,909 --> 00:30:55,450
doing and the fourth option is well you

00:30:52,960 --> 00:30:58,570
program your own and i'm going to show

00:30:55,450 --> 00:31:01,809
you a little bit how that works so for

00:30:58,570 --> 00:31:06,280
that you use the missiles framework api

00:31:01,809 --> 00:31:09,640
and that's a protobuf messages over HTTP

00:31:06,280 --> 00:31:14,169
is really what's underneath it and what

00:31:09,640 --> 00:31:16,840
we've built is a lot of well we as in

00:31:14,169 --> 00:31:18,269
the apache me source open source project

00:31:16,840 --> 00:31:21,669
in the sense

00:31:18,269 --> 00:31:24,610
there's a lot of protobuf messages over

00:31:21,669 --> 00:31:26,259
HTTP wrapped in interfaces in different

00:31:24,610 --> 00:31:29,049
languages pretty much every language

00:31:26,259 --> 00:31:32,379
that you can generate protobuf source

00:31:29,049 --> 00:31:35,710
code for so starting with C++ this Java

00:31:32,379 --> 00:31:40,809
there's JavaScript there's Python let's

00:31:35,710 --> 00:31:44,710
go a lot of these and soon there will be

00:31:40,809 --> 00:31:46,360
a pure HTTP JSON interface then that

00:31:44,710 --> 00:31:47,740
will make it even easier to connect to

00:31:46,360 --> 00:31:50,679
me sauce but right now it's already

00:31:47,740 --> 00:31:53,379
available in like a dozen languages okay

00:31:50,679 --> 00:31:54,909
what's it look like well you need to

00:31:53,379 --> 00:31:58,090
implement these two pieces i talked

00:31:54,909 --> 00:32:00,759
about one half of two level scheduling

00:31:58,090 --> 00:32:03,909
there's the master and you provide this

00:32:00,759 --> 00:32:05,259
thing that responds to offers I need to

00:32:03,909 --> 00:32:07,840
be able to say something when you

00:32:05,259 --> 00:32:09,820
receive an offer and you need to be

00:32:07,840 --> 00:32:11,350
aware of what happens to your tasks

00:32:09,820 --> 00:32:13,539
after you start at them that's the

00:32:11,350 --> 00:32:15,009
minimum now there are a bunch of other

00:32:13,539 --> 00:32:17,049
callbacks that i'm going to show but

00:32:15,009 --> 00:32:19,750
they are not as important as d2 these

00:32:17,049 --> 00:32:22,120
two additionally you can build an

00:32:19,750 --> 00:32:25,450
executor interface implementation and

00:32:22,120 --> 00:32:28,149
that is for monitoring individual tasks

00:32:25,450 --> 00:32:30,809
finding out how they're doing you can

00:32:28,149 --> 00:32:33,220
use weight pit in Linux a lot for that

00:32:30,809 --> 00:32:35,799
for example and that's exactly what the

00:32:33,220 --> 00:32:39,370
command line executor does that comes

00:32:35,799 --> 00:32:41,169
included it basically runs a shell

00:32:39,370 --> 00:32:43,720
script does a weight pit on it and

00:32:41,169 --> 00:32:46,389
reports what the outcome is so that's

00:32:43,720 --> 00:32:48,100
the simple executor you can build your

00:32:46,389 --> 00:32:50,710
own though for example you could make

00:32:48,100 --> 00:32:53,379
one that injects a jar file into a

00:32:50,710 --> 00:32:57,129
running jvms start something in a new

00:32:53,379 --> 00:32:59,529
application class loader and without

00:32:57,129 --> 00:33:01,299
starting a new process and then and has

00:32:59,529 --> 00:33:03,370
a socket to it and then reports how this

00:33:01,299 --> 00:33:05,409
thing is doing you can go abbott really

00:33:03,370 --> 00:33:07,720
fancy with an executor it's totally free

00:33:05,409 --> 00:33:10,029
form or you can use the pre-formatted

00:33:07,720 --> 00:33:12,399
once another really important one that

00:33:10,029 --> 00:33:15,279
comes included is darker execution

00:33:12,399 --> 00:33:18,399
that's something where you specify a

00:33:15,279 --> 00:33:22,269
docker image or daca file it gets pulled

00:33:18,399 --> 00:33:26,049
down cached instantiated and the doc

00:33:22,269 --> 00:33:28,119
Urkel man gets run and that's really a

00:33:26,049 --> 00:33:30,060
crucial one because containerisation is

00:33:28,119 --> 00:33:33,420
is key at that scale

00:33:30,060 --> 00:33:35,820
okay what does the SPI why the API is

00:33:33,420 --> 00:33:38,880
actually an SPI that's how I see it you

00:33:35,820 --> 00:33:40,940
the framework implement this service

00:33:38,880 --> 00:33:43,560
interface and then you are a framework

00:33:40,940 --> 00:33:47,640
service provider interface and these are

00:33:43,560 --> 00:33:50,520
all the callbacks and the first two ones

00:33:47,640 --> 00:33:52,020
are about registering with a master then

00:33:50,520 --> 00:33:55,680
there's the all important resource

00:33:52,020 --> 00:33:57,600
offers and it has two parameters um the

00:33:55,680 --> 00:33:59,700
first one is like a remote control for

00:33:57,600 --> 00:34:01,410
the whole cluster the scheduler driver

00:33:59,700 --> 00:34:03,450
is a weird name just think of it this is

00:34:01,410 --> 00:34:05,670
my remote control I want to switch on

00:34:03,450 --> 00:34:08,940
something over there Ronnie task driver

00:34:05,670 --> 00:34:11,190
do that I want to kill this slave over

00:34:08,940 --> 00:34:14,250
there driver to do that something like

00:34:11,190 --> 00:34:17,790
that okay so he got power in your hands

00:34:14,250 --> 00:34:19,710
with this instance of a class that's

00:34:17,790 --> 00:34:22,800
connected to the master and can talk to

00:34:19,710 --> 00:34:26,160
it and the rest is information for you

00:34:22,800 --> 00:34:29,730
what kind of resources are available on

00:34:26,160 --> 00:34:33,450
what hosts that's what offers is so how

00:34:29,730 --> 00:34:35,630
many CPUs how much memory what storage

00:34:33,450 --> 00:34:38,010
what band with those kinds of things and

00:34:35,630 --> 00:34:40,320
if you see such an aggregate of

00:34:38,010 --> 00:34:42,420
resources then you react and say I want

00:34:40,320 --> 00:34:45,720
it I want half of it I want a quarter of

00:34:42,420 --> 00:34:47,490
it I don't want it once you have it you

00:34:45,720 --> 00:34:49,320
then issue a command and I'm going to

00:34:47,490 --> 00:34:54,300
get to that in the next slide here's an

00:34:49,320 --> 00:34:56,700
example so this I use Java for this

00:34:54,300 --> 00:34:57,930
because I hope everybody speaks Java or

00:34:56,700 --> 00:35:00,030
it could have used some other language

00:34:57,930 --> 00:35:01,970
maybe Python would have been nicer I

00:35:00,030 --> 00:35:10,470
don't know anybody doesn't speak java

00:35:01,970 --> 00:35:12,150
yeah okay so I don't explain what the

00:35:10,470 --> 00:35:16,110
test generator does that's your own

00:35:12,150 --> 00:35:19,680
internal let's say database of things

00:35:16,110 --> 00:35:22,140
you want to do a hash table or whatever

00:35:19,680 --> 00:35:25,260
all just a list something that you can

00:35:22,140 --> 00:35:27,780
take from or it could be a FIFO queue

00:35:25,260 --> 00:35:29,880
with some editing in it you can organize

00:35:27,780 --> 00:35:32,880
that any or you make the tasks up on the

00:35:29,880 --> 00:35:34,890
fly but as long as you have tasks you

00:35:32,880 --> 00:35:37,230
keep going if you're done creating tasks

00:35:34,890 --> 00:35:38,930
you find out in eventually well I had a

00:35:37,230 --> 00:35:41,430
thousand things to do there all done

00:35:38,930 --> 00:35:43,140
then you start declining offers that

00:35:41,430 --> 00:35:43,859
means you'd say I don't want this offer

00:35:43,140 --> 00:35:45,660
anymore and what

00:35:43,859 --> 00:35:49,589
happens the master takes the offer gives

00:35:45,660 --> 00:35:51,450
it to another slave okay so you're

00:35:49,589 --> 00:35:54,839
basically done then and when you get

00:35:51,450 --> 00:35:56,609
your last last status update on that the

00:35:54,839 --> 00:35:58,109
last task is done you can stop the

00:35:56,609 --> 00:36:00,839
driver which means this framework goes

00:35:58,109 --> 00:36:06,269
home it's done it is no longer connected

00:36:00,839 --> 00:36:07,680
to the cluster and yeah and once you

00:36:06,269 --> 00:36:10,200
have an offer and you find it

00:36:07,680 --> 00:36:11,880
interesting enough in this case you find

00:36:10,200 --> 00:36:13,559
all offers interesting but you could

00:36:11,880 --> 00:36:17,130
filter them I haven't put that in there

00:36:13,559 --> 00:36:19,529
it was the slight sighs you generate

00:36:17,130 --> 00:36:20,940
task infos for the offer task infos are

00:36:19,529 --> 00:36:23,339
descriptions I want to run on this

00:36:20,940 --> 00:36:25,859
hostname that you sent and here's the

00:36:23,339 --> 00:36:27,509
shell command and here is a URI where

00:36:25,859 --> 00:36:28,890
can download some software that needs to

00:36:27,509 --> 00:36:32,009
be installed there or here's the docker

00:36:28,890 --> 00:36:34,289
image and so and so forth very very

00:36:32,009 --> 00:36:36,569
flexible to organize that but

00:36:34,289 --> 00:36:39,269
essentially this program line there then

00:36:36,569 --> 00:36:40,619
we'll get your tasks running and the

00:36:39,269 --> 00:36:42,539
next thing you know you get status

00:36:40,619 --> 00:36:45,299
updates so you sit there as the

00:36:42,539 --> 00:36:48,029
framework and protobuf comes flying by

00:36:45,299 --> 00:36:50,489
goes into the event loop this callback

00:36:48,029 --> 00:36:52,019
happens status update and that's how you

00:36:50,489 --> 00:36:54,569
find out what happened to the tasks they

00:36:52,019 --> 00:36:57,859
have an ID and that's how you match what

00:36:54,569 --> 00:37:00,420
you started to what happened to them

00:36:57,859 --> 00:37:03,690
that's what that's it so from the

00:37:00,420 --> 00:37:05,339
developers perspective aside from this

00:37:03,690 --> 00:37:07,499
piece that i showed you focus on the

00:37:05,339 --> 00:37:09,660
application logic and you do not think

00:37:07,499 --> 00:37:12,869
about the data center structure because

00:37:09,660 --> 00:37:15,109
that's all in Miso's you care about what

00:37:12,869 --> 00:37:17,849
to run nasos cares about where to run

00:37:15,109 --> 00:37:21,630
that's labor division good old principal

00:37:17,849 --> 00:37:24,359
and the avoid network-related code

00:37:21,630 --> 00:37:25,890
except if your task communicate with

00:37:24,359 --> 00:37:27,660
each other then of course they contain

00:37:25,890 --> 00:37:29,970
some but just to get them out we're out

00:37:27,660 --> 00:37:31,410
there somewhere and report back you

00:37:29,970 --> 00:37:33,509
don't really need any network code you

00:37:31,410 --> 00:37:36,089
can send so called framework messages

00:37:33,509 --> 00:37:39,779
that will go through missiles and it

00:37:36,089 --> 00:37:41,369
will know how to write back yuri use the

00:37:39,779 --> 00:37:44,999
built-in fault tolerance and high

00:37:41,369 --> 00:37:47,190
availability you reuse infrastructure

00:37:44,999 --> 00:37:49,890
frameworks also for example you could

00:37:47,190 --> 00:37:52,980
first start HDFS as a missiles framework

00:37:49,890 --> 00:37:55,589
as a genuine framework and poof you have

00:37:52,980 --> 00:37:57,420
storage everywhere and then you AB can

00:37:55,589 --> 00:38:00,180
just use that storage

00:37:57,420 --> 00:38:03,569
or you could say i want dns and run mrs.

00:38:00,180 --> 00:38:06,349
T&S poof you have dns that knows the

00:38:03,569 --> 00:38:09,299
names of your tasks as host names and

00:38:06,349 --> 00:38:13,770
can reconnect those two IP addresses if

00:38:09,299 --> 00:38:15,089
they migrate things like that so that's

00:38:13,770 --> 00:38:16,770
what I would call an infrastructure

00:38:15,089 --> 00:38:19,980
framework that is kind of part of the

00:38:16,770 --> 00:38:23,099
ensemble that I would describe as an OS

00:38:19,980 --> 00:38:27,030
in this context above the linux OS that

00:38:23,099 --> 00:38:29,250
runs a single node and in total as a

00:38:27,030 --> 00:38:32,520
developer what you really want then is

00:38:29,250 --> 00:38:36,240
an api and also an sdk so that's under

00:38:32,520 --> 00:38:39,569
construction and from the operations

00:38:36,240 --> 00:38:41,520
engineer's perspective that's all

00:38:39,569 --> 00:38:43,619
hunky-dory but what you really care

00:38:41,520 --> 00:38:45,480
about is how easy is it actually to

00:38:43,619 --> 00:38:48,359
manage my data center to run my cluster

00:38:45,480 --> 00:38:51,059
and how uniform it is we hear this all

00:38:48,359 --> 00:38:52,829
the time oh I have the we we are a

00:38:51,059 --> 00:38:56,640
company I talk to a company that's

00:38:52,829 --> 00:38:58,380
growing like yeah double-digit

00:38:56,640 --> 00:39:01,200
percentages per year buying other

00:38:58,380 --> 00:39:04,760
companies and they have all their by

00:39:01,200 --> 00:39:07,079
like on average 15 companies a year and

00:39:04,760 --> 00:39:08,790
guess what they all have a different way

00:39:07,079 --> 00:39:12,990
of running that clusters it's hardly

00:39:08,790 --> 00:39:15,930
ever the same so they want that they can

00:39:12,990 --> 00:39:18,780
run across the company clusters the same

00:39:15,930 --> 00:39:20,970
way and they need to agree to one way

00:39:18,780 --> 00:39:22,290
and they want to train people once and

00:39:20,970 --> 00:39:24,150
they want them interchangeable between

00:39:22,290 --> 00:39:26,040
different divisions of the company and

00:39:24,150 --> 00:39:28,530
so on and so forth so uniformity is

00:39:26,040 --> 00:39:30,270
pretty much key or you can't really

00:39:28,530 --> 00:39:31,950
scale your business or you have a lot of

00:39:30,270 --> 00:39:34,339
islands and then you're smarter than me

00:39:31,950 --> 00:39:38,690
and how to manage that for sure um

00:39:34,339 --> 00:39:41,190
probably for other reasons also and

00:39:38,690 --> 00:39:42,930
hardware utilization rate is something

00:39:41,190 --> 00:39:45,079
that is also often managed but not

00:39:42,930 --> 00:39:47,280
necessarily always top of the list

00:39:45,079 --> 00:39:48,809
what's also very important I mentioned

00:39:47,280 --> 00:39:50,520
in the beginning you want to scale up as

00:39:48,809 --> 00:39:53,549
the business grows and you want to scale

00:39:50,520 --> 00:39:57,569
out sometimes and so on it's all about

00:39:53,549 --> 00:39:59,190
costs and time and what I'm not going to

00:39:57,569 --> 00:40:00,660
address a lot today I'm afraid is

00:39:59,190 --> 00:40:02,400
monitoring and troubleshooting but I

00:40:00,660 --> 00:40:04,020
heard there are some really I are great

00:40:02,400 --> 00:40:05,069
other talks in this conference about

00:40:04,020 --> 00:40:06,460
that so I'm going to leave that out a

00:40:05,069 --> 00:40:09,980
little bit

00:40:06,460 --> 00:40:11,960
okay so once you have all that you

00:40:09,980 --> 00:40:13,730
basically with a two-level scheduler and

00:40:11,960 --> 00:40:15,590
all these frameworks you're in good

00:40:13,730 --> 00:40:18,530
enough shape and that is kind of where

00:40:15,590 --> 00:40:20,330
we were two years ago and then this

00:40:18,530 --> 00:40:21,950
whole thing took took off and more and

00:40:20,330 --> 00:40:24,800
more companies are not using open source

00:40:21,950 --> 00:40:29,120
Apache missiles okay it went from like

00:40:24,800 --> 00:40:30,920
four to thousands but there's still a

00:40:29,120 --> 00:40:34,760
lot of work to do we're not done here

00:40:30,920 --> 00:40:37,150
yet this is still early days and we're

00:40:34,760 --> 00:40:39,920
still building it as we're using it and

00:40:37,150 --> 00:40:41,450
a lot of these features that I'm talking

00:40:39,920 --> 00:40:43,550
about here I have just come into

00:40:41,450 --> 00:40:47,300
fruition or still under development and

00:40:43,550 --> 00:40:51,340
getting some touch-ups on oops I was

00:40:47,300 --> 00:40:53,270
here so to have true multi-tenancy

00:40:51,340 --> 00:40:55,910
containerization is important okay so

00:40:53,270 --> 00:40:58,100
Dockers integrated can be integrated

00:40:55,910 --> 00:40:59,540
better we always need to make sure that

00:40:58,100 --> 00:41:01,700
works really well but there are also

00:40:59,540 --> 00:41:03,770
other container systems what about those

00:41:01,700 --> 00:41:07,310
have to think about that there's

00:41:03,770 --> 00:41:10,930
resource isolation not all the resources

00:41:07,310 --> 00:41:14,390
are isolated in the same way as as

00:41:10,930 --> 00:41:17,330
equally well and then there are more and

00:41:14,390 --> 00:41:20,420
more resources for for example what

00:41:17,330 --> 00:41:23,000
about sharing GPUs anybody have a clue

00:41:20,420 --> 00:41:24,440
how to do that or isolate them so only

00:41:23,000 --> 00:41:26,630
one task can have them and the other

00:41:24,440 --> 00:41:28,250
actually knows it's occupied right

00:41:26,630 --> 00:41:33,380
little things like that come up all the

00:41:28,250 --> 00:41:36,380
time resource and task attributes um I

00:41:33,380 --> 00:41:38,090
know that docker swarm for example has a

00:41:36,380 --> 00:41:41,960
relatively rich language to describe

00:41:38,090 --> 00:41:44,120
this from both ends okay and but it's

00:41:41,960 --> 00:41:45,680
not fully come it's not fully

00:41:44,120 --> 00:41:48,770
programmable but the question is what

00:41:45,680 --> 00:41:50,540
you how far do you need to go and what's

00:41:48,770 --> 00:41:52,160
enough maybe it's great the way it is

00:41:50,540 --> 00:41:55,270
and maybe you need to go a little bit

00:41:52,160 --> 00:41:58,000
further and need some extra attributes

00:41:55,270 --> 00:42:00,520
static and dynamic resource reservations

00:41:58,000 --> 00:42:03,430
that's a really important one suppose

00:42:00,520 --> 00:42:06,530
somebody wants to run a big spark job

00:42:03,430 --> 00:42:09,530
with 100,000 tasks and you have a

00:42:06,530 --> 00:42:11,570
cluster and now you have a second spark

00:42:09,530 --> 00:42:13,730
job maybe this one is analyzing some

00:42:11,570 --> 00:42:16,940
genetic material or something and you're

00:42:13,730 --> 00:42:19,100
running on gene 21 and the next one was

00:42:16,940 --> 00:42:20,690
to analyze gene 22 can you run them at

00:42:19,100 --> 00:42:24,869
the same time

00:42:20,690 --> 00:42:27,570
how do you know right well you could try

00:42:24,869 --> 00:42:29,609
and what happens is the first one

00:42:27,570 --> 00:42:32,540
occupies the cluster the second one runs

00:42:29,609 --> 00:42:35,490
a trickle speed or it it totally chokes

00:42:32,540 --> 00:42:37,530
so what you can do is you could make

00:42:35,490 --> 00:42:39,930
some static reservation and say among

00:42:37,530 --> 00:42:43,020
these thousand nodes give me at least a

00:42:39,930 --> 00:42:46,230
hundred and if I don't get them I don't

00:42:43,020 --> 00:42:47,820
start and this is a lot like OS is in

00:42:46,230 --> 00:42:50,130
the past for one computer where you set

00:42:47,820 --> 00:42:52,470
minimum memory maximum memory remember

00:42:50,130 --> 00:42:55,970
that so you can play this game now for

00:42:52,470 --> 00:42:58,140
all kinds of resources in a cluster and

00:42:55,970 --> 00:42:59,850
then you get the same effect you can

00:42:58,140 --> 00:43:01,770
double-click your application will say

00:42:59,850 --> 00:43:04,230
insufficient resources colon here is

00:43:01,770 --> 00:43:07,280
what you don't have or you can run two

00:43:04,230 --> 00:43:10,050
of them and they both say I want 100

00:43:07,280 --> 00:43:12,300
CPUs and then there are 100 extra CPUs

00:43:10,050 --> 00:43:17,310
how do you make sure each of those gets

00:43:12,300 --> 00:43:19,020
50 right and what does it mean if one of

00:43:17,310 --> 00:43:21,180
them already has three hundred and I

00:43:19,020 --> 00:43:23,820
want my 100 and there's only four on

00:43:21,180 --> 00:43:25,619
only three hundred you need to be able

00:43:23,820 --> 00:43:28,230
to cancel tasks and replace them with

00:43:25,619 --> 00:43:30,300
new ones but maybe nobody has programmed

00:43:28,230 --> 00:43:33,450
hey you can't take away that task then

00:43:30,300 --> 00:43:35,520
my application logic is broken so we

00:43:33,450 --> 00:43:37,380
need some sort of cooperation from

00:43:35,520 --> 00:43:39,119
frameworks to make that happen you

00:43:37,380 --> 00:43:41,369
cannot have zero information about the

00:43:39,119 --> 00:43:45,450
frameworks so the frameworks that say

00:43:41,369 --> 00:43:49,320
nothing to the OS get punished and kept

00:43:45,450 --> 00:43:52,470
in confinement of not too many resources

00:43:49,320 --> 00:43:55,230
and the ones that generals generously

00:43:52,470 --> 00:43:57,150
provide information hey I need this at a

00:43:55,230 --> 00:43:59,820
minimum but I'll take everything you got

00:43:57,150 --> 00:44:02,369
if you give me and in some specific

00:43:59,820 --> 00:44:05,010
terms they get a lot more resources as

00:44:02,369 --> 00:44:11,190
available okay so they benefit from

00:44:05,010 --> 00:44:13,980
restraint reservation levels oh forgot

00:44:11,190 --> 00:44:17,130
what I meant by that oh that was exactly

00:44:13,980 --> 00:44:20,400
what I just talked about you say what

00:44:17,130 --> 00:44:23,100
kind of certainty you want for getting

00:44:20,400 --> 00:44:25,680
these resources resources okay you need

00:44:23,100 --> 00:44:27,480
metaframe works because otherwise you

00:44:25,680 --> 00:44:30,510
will not have all the applications that

00:44:27,480 --> 00:44:33,060
are possible and thinkable on board some

00:44:30,510 --> 00:44:34,030
of them are just too hard to change a

00:44:33,060 --> 00:44:37,570
why change them

00:44:34,030 --> 00:44:40,390
something else can run them cheaply and

00:44:37,570 --> 00:44:42,010
you also want to update the system the

00:44:40,390 --> 00:44:43,660
apps the frameworks everything needs to

00:44:42,010 --> 00:44:45,060
be dynamically upgradeable you don't

00:44:43,660 --> 00:44:47,590
want to shut down your data center

00:44:45,060 --> 00:44:49,270
install something from scratch and so on

00:44:47,590 --> 00:44:50,770
you know that okay I'm not going to talk

00:44:49,270 --> 00:44:57,250
a lot about security any questions so

00:44:50,770 --> 00:44:59,080
far getting close okay there are other

00:44:57,250 --> 00:45:00,670
features that are not quite as necessary

00:44:59,080 --> 00:45:03,160
or you could argue are there also

00:45:00,670 --> 00:45:05,890
necessary there's one other great

00:45:03,160 --> 00:45:07,510
scheduler arm it's from google it's

00:45:05,890 --> 00:45:09,820
called Omega there are some recent

00:45:07,510 --> 00:45:11,760
publications on that and comparisons

00:45:09,820 --> 00:45:14,590
with mayo sauce it's quite similar but

00:45:11,760 --> 00:45:16,690
it has a few differences and one of the

00:45:14,590 --> 00:45:19,630
biggest differences it does optimistic

00:45:16,690 --> 00:45:22,660
offers so in a sauce an offer only ever

00:45:19,630 --> 00:45:25,330
gets sent to one framework and it has

00:45:22,660 --> 00:45:28,960
the first right of refusal for those

00:45:25,330 --> 00:45:30,490
before those offers and if it and it can

00:45:28,960 --> 00:45:33,070
sit on them for a while and hog them

00:45:30,490 --> 00:45:35,890
with optimistic offers you sent the same

00:45:33,070 --> 00:45:38,980
offer to multiple frameworks they could

00:45:35,890 --> 00:45:40,810
in theory simultaneously grab them and I

00:45:38,980 --> 00:45:42,280
can sort it out later with a conflict

00:45:40,810 --> 00:45:44,020
algorithm who actually gets it and the

00:45:42,280 --> 00:45:47,170
other gets revoked the offer again and

00:45:44,020 --> 00:45:52,030
gets balanced out optimistic because

00:45:47,170 --> 00:45:54,640
typically if you sent the offers out in

00:45:52,030 --> 00:45:57,880
a relatively widespread pattern that

00:45:54,640 --> 00:45:59,860
doesn't happen too often and you you're

00:45:57,880 --> 00:46:01,330
fine only when there's crunch then you

00:45:59,860 --> 00:46:04,540
can order then you can still switch off

00:46:01,330 --> 00:46:06,940
optimistic offers and the mitigation

00:46:04,540 --> 00:46:10,450
techniques are as described they're not

00:46:06,940 --> 00:46:13,480
so not so severe so the goal here is

00:46:10,450 --> 00:46:16,120
just to have more throughput okay and

00:46:13,480 --> 00:46:18,610
better utilization rate and less

00:46:16,120 --> 00:46:22,150
spinning okay oversubscription is

00:46:18,610 --> 00:46:24,070
another thing your tasks may be

00:46:22,150 --> 00:46:28,060
describing what kind of resources they

00:46:24,070 --> 00:46:30,760
need but they may be lying your

00:46:28,060 --> 00:46:33,940
programmers who program the frameworks

00:46:30,760 --> 00:46:35,890
may make mistakes or people aren't just

00:46:33,940 --> 00:46:40,060
that great at estimating and neither is

00:46:35,890 --> 00:46:41,890
software so this is not always an exact

00:46:40,060 --> 00:46:44,320
science you say I need this much memory

00:46:41,890 --> 00:46:46,450
maybe you don't maybe you say I want

00:46:44,320 --> 00:46:47,020
four gigs reserved for this task button

00:46:46,450 --> 00:46:49,390
only

00:46:47,020 --> 00:46:51,280
history so you do the same thing as

00:46:49,390 --> 00:46:53,500
airline carriers they book more tickets

00:46:51,280 --> 00:46:55,330
then they have passengers then they have

00:46:53,500 --> 00:46:57,910
seeds they book more passengers not

00:46:55,330 --> 00:47:00,250
everybody shows up we can do this here

00:46:57,910 --> 00:47:03,400
also and then correct it when it goes

00:47:00,250 --> 00:47:05,710
wrong by resizing tasks that are not so

00:47:03,400 --> 00:47:08,500
critical prioritizing which ones are

00:47:05,710 --> 00:47:10,950
more deserving of resources than others

00:47:08,500 --> 00:47:14,020
and so on and play all these games

00:47:10,950 --> 00:47:16,060
rate-limiting what you do when your

00:47:14,020 --> 00:47:19,090
clusters really really full and that

00:47:16,060 --> 00:47:21,730
feature is already in well you could let

00:47:19,090 --> 00:47:26,920
it fresh ultimately to the point where

00:47:21,730 --> 00:47:30,820
you have the TLB acting and everything

00:47:26,920 --> 00:47:32,770
goes really slow or you could just limit

00:47:30,820 --> 00:47:35,800
at the master how many tasks get issued

00:47:32,770 --> 00:47:38,290
per second and just turn that big knob

00:47:35,800 --> 00:47:40,300
and then the activity quiets down a

00:47:38,290 --> 00:47:42,160
little bit all the framework slow run

00:47:40,300 --> 00:47:44,470
slower because the task rates aren't as

00:47:42,160 --> 00:47:46,690
high but you don't get refreshing on the

00:47:44,470 --> 00:47:49,210
notes okay so you need mitigation

00:47:46,690 --> 00:47:51,730
techniques built in and then ultimately

00:47:49,210 --> 00:47:54,700
my favorite auto scaling into the

00:47:51,730 --> 00:47:56,530
hybrids cloud you own some of the

00:47:54,700 --> 00:48:01,000
hardware and you rent what you need

00:47:56,530 --> 00:48:03,240
extra on a as needed basis okay but a

00:48:01,000 --> 00:48:07,240
long topic not getting into this now

00:48:03,240 --> 00:48:09,400
infrastructure frameworks and so on one

00:48:07,240 --> 00:48:12,670
of these remember two slides back I said

00:48:09,400 --> 00:48:14,680
task containerization is stalker here's

00:48:12,670 --> 00:48:16,540
how the docker integration works in like

00:48:14,680 --> 00:48:18,280
eight simple steps what happens when a

00:48:16,540 --> 00:48:19,480
task gets launched but I want to get

00:48:18,280 --> 00:48:21,160
through the slides and allow you some

00:48:19,480 --> 00:48:23,820
questions so I'm going to cut that a

00:48:21,160 --> 00:48:26,740
little short essentially what happens is

00:48:23,820 --> 00:48:31,030
the Dockers get drawn directly from the

00:48:26,740 --> 00:48:33,160
docker registry which is driven by the

00:48:31,030 --> 00:48:34,510
number 3 aero where the description

00:48:33,160 --> 00:48:36,520
comes down through the slave and the

00:48:34,510 --> 00:48:39,370
executor then knows how to run a docker

00:48:36,520 --> 00:48:41,380
that comes from there and it's built in

00:48:39,370 --> 00:48:45,160
that the Dockers wanted in Alexei and

00:48:41,380 --> 00:48:48,010
then you have lots and lots of little

00:48:45,160 --> 00:48:49,450
darker tasks orchestrated in places

00:48:48,010 --> 00:48:53,230
where you never knew before where they

00:48:49,450 --> 00:48:57,010
would land in the cluster other

00:48:53,230 --> 00:48:59,800
schedulers that also run on a two-level

00:48:57,010 --> 00:49:00,849
scheduler yarn communities and we're

00:48:59,800 --> 00:49:04,809
working on swarm

00:49:00,849 --> 00:49:08,589
but not there yet it's kind of new and

00:49:04,809 --> 00:49:11,109
you can basically build multiple yarn

00:49:08,589 --> 00:49:12,849
clusters inside a missiles cluster or

00:49:11,109 --> 00:49:14,829
you could build multiple coordinate

00:49:12,849 --> 00:49:17,799
these clusters inside an asus cluster

00:49:14,829 --> 00:49:19,869
virtual clusters so to speak and that's

00:49:17,799 --> 00:49:21,759
one way of looking at it another way of

00:49:19,869 --> 00:49:24,190
looking at it is these are just meta

00:49:21,759 --> 00:49:27,309
schedulers or meta framework story meta

00:49:24,190 --> 00:49:29,499
frameworks that are little richer and

00:49:27,309 --> 00:49:32,769
structure than the ordinary pretty flat

00:49:29,499 --> 00:49:35,049
meta frameworks like Chronos for example

00:49:32,769 --> 00:49:37,359
or they even richer then in some

00:49:35,049 --> 00:49:39,609
respects than then marathon which mostly

00:49:37,359 --> 00:49:44,460
is horizontal scaling can do few other

00:49:39,609 --> 00:49:48,249
tricks but that's its main game and so

00:49:44,460 --> 00:49:50,499
myriad is for big MapReduce things for

00:49:48,249 --> 00:49:53,829
example is really great so if you want

00:49:50,499 --> 00:49:55,660
to make really really sure you can

00:49:53,829 --> 00:49:57,579
exchange that with static reservations a

00:49:55,660 --> 00:49:58,930
little bit you there are always multiple

00:49:57,579 --> 00:50:00,700
ways of doing things I would say if

00:49:58,930 --> 00:50:02,349
static of reservations works great maybe

00:50:00,700 --> 00:50:03,609
you don't need this but maybe it's never

00:50:02,349 --> 00:50:06,039
going to be that great that's a lot of

00:50:03,609 --> 00:50:08,729
discussion going on but if you want to

00:50:06,039 --> 00:50:12,729
make for sure today you can do this and

00:50:08,729 --> 00:50:16,170
build a yawn cluster inside a measles

00:50:12,729 --> 00:50:21,519
cluster by requesting resources for

00:50:16,170 --> 00:50:23,890
these yarn end nodes that execute the

00:50:21,519 --> 00:50:25,420
task c1 and c2 you can have multiple of

00:50:23,890 --> 00:50:28,589
those and have these resources are

00:50:25,420 --> 00:50:33,430
reserved and then scheduled among them

00:50:28,589 --> 00:50:37,960
okay note managers that's what i call

00:50:33,430 --> 00:50:41,410
them and likewise this is already a

00:50:37,960 --> 00:50:45,579
slightly older project it's coming into

00:50:41,410 --> 00:50:47,979
fruition now and yeah you can't talk

00:50:45,579 --> 00:50:51,190
about it too much but i want to show you

00:50:47,979 --> 00:50:53,499
roughly just look at the colors the red

00:50:51,190 --> 00:50:56,170
stuff is the genuine kuba native

00:50:53,499 --> 00:50:59,069
software and the green stuff is the

00:50:56,170 --> 00:51:03,729
mezzo software and the this color here

00:50:59,069 --> 00:51:07,119
lavender or something that is where the

00:51:03,729 --> 00:51:09,849
tasks run and you can the important

00:51:07,119 --> 00:51:11,799
outcome is you can co inhabit cohen

00:51:09,849 --> 00:51:14,130
eighties tasks long-running services

00:51:11,799 --> 00:51:18,509
with batch jobs in the same

00:51:14,130 --> 00:51:21,599
Master and the rest is just how you are

00:51:18,509 --> 00:51:23,369
castrates that how you replicate what

00:51:21,599 --> 00:51:25,470
kind of container arrangements you have

00:51:23,369 --> 00:51:29,490
with pods and so on so forth somebody's

00:51:25,470 --> 00:51:32,279
thinking about that okay the end result

00:51:29,490 --> 00:51:34,769
of this is that you get more probability

00:51:32,279 --> 00:51:36,960
that i would then i would claim in any

00:51:34,769 --> 00:51:39,900
other way but there are so many ways to

00:51:36,960 --> 00:51:42,509
skin that cat so don't take my word for

00:51:39,900 --> 00:51:45,240
it try it but that's the general

00:51:42,509 --> 00:51:47,690
overview you can be in the public cloud

00:51:45,240 --> 00:51:50,369
you can be in your own managed cloud

00:51:47,690 --> 00:51:52,829
helped by somebody or you can be on your

00:51:50,369 --> 00:51:54,869
own data center you have this

00:51:52,829 --> 00:51:56,099
abstraction layer and every problem in

00:51:54,869 --> 00:51:58,259
computer science is solved by

00:51:56,099 --> 00:52:01,140
abstraction by one level of indirection

00:51:58,259 --> 00:52:03,150
right and on top of that you have your

00:52:01,140 --> 00:52:04,589
meta frameworks to help you run apps you

00:52:03,150 --> 00:52:06,420
have your infrastructure frameworks to

00:52:04,589 --> 00:52:08,069
shape them you can run your own

00:52:06,420 --> 00:52:11,759
frameworks but you can also run some

00:52:08,069 --> 00:52:14,819
vanilla apps and hopefully that solves

00:52:11,759 --> 00:52:18,059
in the 90 10 rule almost all the cases

00:52:14,819 --> 00:52:19,650
that matter and then maybe there are

00:52:18,059 --> 00:52:21,480
some strange cases where it's a little

00:52:19,650 --> 00:52:23,220
bit difficult to adjust and it takes

00:52:21,480 --> 00:52:25,859
some extra effort but it should be rare

00:52:23,220 --> 00:52:29,339
and for most of your stuff you should be

00:52:25,859 --> 00:52:33,750
quite portable and that gives you the

00:52:29,339 --> 00:52:35,789
user perspective with you run everything

00:52:33,750 --> 00:52:37,829
you need hopefully and you have return

00:52:35,789 --> 00:52:41,880
on investment and safety of investment

00:52:37,829 --> 00:52:43,500
hopefully and you really focus on

00:52:41,880 --> 00:52:47,670
running your apps and not so much on

00:52:43,500 --> 00:52:50,099
what your data center looks like so I

00:52:47,670 --> 00:52:51,599
claim the data center is the new form

00:52:50,099 --> 00:52:55,529
factor if we get all this off the ground

00:52:51,599 --> 00:52:58,220
and as a developer it looks like it as a

00:52:55,529 --> 00:53:02,609
user it looks like it and as an operator

00:52:58,220 --> 00:53:06,150
hopefully increasingly also so not quite

00:53:02,609 --> 00:53:09,390
as much there will be always always be

00:53:06,150 --> 00:53:11,670
some operators so but hopefully it will

00:53:09,390 --> 00:53:14,250
get easier and more uniform and these

00:53:11,670 --> 00:53:16,289
are the main ingredients and the talk

00:53:14,250 --> 00:53:18,750
that we went over the importance of the

00:53:16,289 --> 00:53:21,119
two-level scheduler which i think is the

00:53:18,750 --> 00:53:23,910
necessity to get to a really single

00:53:21,119 --> 00:53:27,470
production cluster we talked about

00:53:23,910 --> 00:53:27,470
scalability and portability and

00:53:27,930 --> 00:53:32,610
containerization I we should have a

00:53:29,550 --> 00:53:35,700
separate talk about that alone it's all

00:53:32,610 --> 00:53:44,280
about autumn ization and that's it I

00:53:35,700 --> 00:53:46,080
think so that was from a very high level

00:53:44,280 --> 00:54:14,430
perspective and that's why we have five

00:53:46,080 --> 00:54:16,590
minutes off question yeah not quite yet

00:54:14,430 --> 00:54:18,870
but in the next few months yeah we

00:54:16,590 --> 00:54:21,480
should have all of that right now if you

00:54:18,870 --> 00:54:26,280
have a task what it will do it will use

00:54:21,480 --> 00:54:28,650
the resources not give them back yeah so

00:54:26,280 --> 00:54:32,400
if it doesn't stop then it still has the

00:54:28,650 --> 00:54:39,690
resources yeah yeah you just use that

00:54:32,400 --> 00:54:41,550
machine at all it falls over what

00:54:39,690 --> 00:54:43,980
missiles knows how much memory there was

00:54:41,550 --> 00:54:46,530
in the first place you dedicated that

00:54:43,980 --> 00:54:48,240
memory to this task if the task uses

00:54:46,530 --> 00:54:52,260
more and then falls over that's not

00:54:48,240 --> 00:54:53,850
missiles fault yeah the app would fall

00:54:52,260 --> 00:54:57,540
over and missiles would take notice

00:54:53,850 --> 00:54:59,520
there would be a task failed status

00:54:57,540 --> 00:55:01,440
report going to the slave which with

00:54:59,520 --> 00:55:03,120
them to the executor or the executive

00:55:01,440 --> 00:55:05,100
would find out the task failed wouldn't

00:55:03,120 --> 00:55:07,110
tell the slave this failed the master

00:55:05,100 --> 00:55:09,240
will tell the framework you and your

00:55:07,110 --> 00:55:10,830
framework will have programmed maybe in

00:55:09,240 --> 00:55:12,930
marathon for example that's a typical

00:55:10,830 --> 00:55:15,750
case we run your web server or my web

00:55:12,930 --> 00:55:17,340
server fell over because the CGI command

00:55:15,750 --> 00:55:20,550
used more memory than I had configured

00:55:17,340 --> 00:55:21,960
it for I don't know or no CGI would be a

00:55:20,550 --> 00:55:26,910
bad example because that's a different

00:55:21,960 --> 00:55:30,570
process but something else and and web

00:55:26,910 --> 00:55:32,700
server falls over and you notice and

00:55:30,570 --> 00:55:34,800
then guess what the meta framework does

00:55:32,700 --> 00:55:36,900
it knows the template how to run the

00:55:34,800 --> 00:55:38,340
thing it knows how to connect it to the

00:55:36,900 --> 00:55:40,010
load balancer and to the other web

00:55:38,340 --> 00:55:41,790
servers and we'll just start another one

00:55:40,010 --> 00:55:52,250
but it may not

00:55:41,790 --> 00:55:52,250
be on the same node hmm yes

00:55:55,380 --> 00:56:00,880
yeah I don't know the current status of

00:55:57,760 --> 00:56:02,590
console you refer to console not just

00:56:00,880 --> 00:56:07,510
for the service discovery problem here

00:56:02,590 --> 00:56:10,090
but for the other yeah so I can tell you

00:56:07,510 --> 00:56:13,390
where missiles is headed that you don't

00:56:10,090 --> 00:56:15,640
need either the we have our own

00:56:13,390 --> 00:56:17,500
replicated log inside messes already and

00:56:15,640 --> 00:56:20,740
we want to dedicate that also to the

00:56:17,500 --> 00:56:22,090
purpose of Master either election and

00:56:20,740 --> 00:56:26,050
once we have that we don't need either

00:56:22,090 --> 00:56:28,060
zookeeper or at CD marathon is just

00:56:26,050 --> 00:56:31,570
going to use the nasals itself then for

00:56:28,060 --> 00:56:33,730
that purpose hmm that's coming up in a

00:56:31,570 --> 00:56:41,200
few months or maybe is already almost

00:56:33,730 --> 00:56:46,150
done I have to check yeah who's using

00:56:41,200 --> 00:56:50,680
mezzos already not so many who's heard

00:56:46,150 --> 00:56:53,140
of yeah how many just one more question

00:56:50,680 --> 00:56:55,840
then it's you how many of you have heard

00:56:53,140 --> 00:56:58,170
about it before this talk oh yeah that's

00:56:55,840 --> 00:57:01,740
wonderful last year that was a lot less

00:56:58,170 --> 00:57:01,740
okay here on

00:57:38,550 --> 00:57:45,900
yeah let me go back to that slide um so

00:57:42,510 --> 00:57:49,200
there were these four ways to run things

00:57:45,900 --> 00:57:50,610
and the number four is the exception

00:57:49,200 --> 00:57:57,030
that you have to build your own

00:57:50,610 --> 00:57:58,890
framework and if you do we help and we

00:57:57,030 --> 00:58:00,570
don't usually charge and there are other

00:57:58,890 --> 00:58:02,700
people in the mezzos community who do

00:58:00,570 --> 00:58:05,970
the same we're just a big community who

00:58:02,700 --> 00:58:08,670
want to make stuff work and there are a

00:58:05,970 --> 00:58:10,620
lot of other organizations many of them

00:58:08,670 --> 00:58:12,450
companies who have frameworks or who

00:58:10,620 --> 00:58:14,190
back framework so we try to help

00:58:12,450 --> 00:58:15,660
missiles along as much as we can and

00:58:14,190 --> 00:58:17,040
there's also Twitter helping missiles

00:58:15,660 --> 00:58:19,590
along as much as they can and other

00:58:17,040 --> 00:58:21,810
companies who do the same in a community

00:58:19,590 --> 00:58:25,020
and their community efforts behind each

00:58:21,810 --> 00:58:30,200
one of these things here where are they

00:58:25,020 --> 00:58:32,640
these ones so there is a big ecosystem

00:58:30,200 --> 00:58:34,200
coming into existence with all the

00:58:32,640 --> 00:58:36,450
frameworks that you hopefully that you

00:58:34,200 --> 00:58:38,550
need and then it should not be too

00:58:36,450 --> 00:58:41,160
frequent or shouldn't be the common case

00:58:38,550 --> 00:58:42,810
that most of the frameworks or maybe

00:58:41,160 --> 00:58:45,540
even just one that you need you have to

00:58:42,810 --> 00:58:47,310
program yourself now that said if you

00:58:45,540 --> 00:58:48,660
come into the situation where you still

00:58:47,310 --> 00:58:52,890
have to program your own framework it's

00:58:48,660 --> 00:58:54,360
not really hard we run hack weeks with

00:58:52,890 --> 00:58:56,160
some people who are interested in that

00:58:54,360 --> 00:58:59,940
sometimes in the u.s. unfortunately at

00:58:56,160 --> 00:59:01,080
the moment and within days people get

00:58:59,940 --> 00:59:03,450
their frameworks up and running

00:59:01,080 --> 00:59:05,160
typically now it can sometimes take

00:59:03,450 --> 00:59:07,530
longer now there are complicated

00:59:05,160 --> 00:59:09,000
engagements for example kubin a DS is a

00:59:07,530 --> 00:59:11,160
little complicated you wouldn't get that

00:59:09,000 --> 00:59:12,750
up and running in two days and then you

00:59:11,160 --> 00:59:15,750
have to work a little bit harder on that

00:59:12,750 --> 00:59:18,090
but it also does a lot it that has to do

00:59:15,750 --> 00:59:21,240
with the system rather than just being a

00:59:18,090 --> 00:59:22,800
nap so the more involved in the system

00:59:21,240 --> 00:59:25,470
itself it is the more complicated it

00:59:22,800 --> 00:59:28,020
gets the more it's just at the app level

00:59:25,470 --> 00:59:30,560
the easier it is I wrote a little

00:59:28,020 --> 00:59:33,450
framework myself in a couple days

00:59:30,560 --> 00:59:35,010
another and and the weirdest thing runs

00:59:33,450 --> 00:59:37,440
on me so say you take for example the

00:59:35,010 --> 00:59:39,390
MPI framework that's also something i

00:59:37,440 --> 00:59:41,250
wanted to point out it doesn't run any

00:59:39,390 --> 00:59:43,470
damn better on missiles than it would

00:59:41,250 --> 00:59:44,940
without that's not what this is about

00:59:43,470 --> 00:59:47,910
that's also an important point I wanted

00:59:44,940 --> 00:59:50,580
to make you get the same performance the

00:59:47,910 --> 00:59:52,240
same start up speed pretty much no

00:59:50,580 --> 00:59:54,850
benefit whatsoever

00:59:52,240 --> 00:59:56,710
respect that compared to running it

00:59:54,850 --> 00:59:59,800
outside missiles but guess what else you

00:59:56,710 --> 01:00:02,170
get you can run mpi and other stuff on

00:59:59,800 --> 01:00:04,510
the same cluster and there will be an

01:00:02,170 --> 01:00:06,070
overall resource management and you

01:00:04,510 --> 01:00:11,110
don't need to have your separate MPI

01:00:06,070 --> 01:00:17,560
cluster anymore that's really what it's

01:00:11,110 --> 01:00:20,080
about but the framework itself up it's

01:00:17,560 --> 01:00:22,090
really tiny basically it just starts

01:00:20,080 --> 01:00:23,920
these MP I know it's there there are two

01:00:22,090 --> 01:00:26,130
versions of doing it these these ms

01:00:23,920 --> 01:00:28,510
something forgot the name nodes and then

01:00:26,130 --> 01:00:30,070
there's some some demons that need to be

01:00:28,510 --> 01:00:32,490
started and when they're all up and

01:00:30,070 --> 01:00:34,780
running then you can start your job and

01:00:32,490 --> 01:00:39,060
these two phases there you can program

01:00:34,780 --> 01:00:41,770
that in hours just to give an example

01:00:39,060 --> 01:00:46,210
also spark and Hadoop are relatively

01:00:41,770 --> 01:00:53,020
simple Jenkins is relatively simple you

01:00:46,210 --> 01:00:55,360
just scale out yeah that but that

01:00:53,020 --> 01:00:57,610
everything is a little different so

01:00:55,360 --> 01:00:59,560
that's why we think there isn't a one

01:00:57,610 --> 01:01:01,300
size fits all and there isn't even the

01:00:59,560 --> 01:01:03,190
description language that's good enough

01:01:01,300 --> 01:01:16,240
but you want all flexibility and that's

01:01:03,190 --> 01:01:18,580
why this is programmable yep yeah think

01:01:16,240 --> 01:01:21,970
of it as a distribution of useful things

01:01:18,580 --> 01:01:24,370
that right now aren't may be as rich as

01:01:21,970 --> 01:01:26,020
you're used to from linux distributions

01:01:24,370 --> 01:01:27,790
when it comes to single computers it's

01:01:26,020 --> 01:01:30,720
nowhere near that but if you think at

01:01:27,790 --> 01:01:33,490
very early Linux then it's kind of

01:01:30,720 --> 01:01:35,260
closer to that not even that much but

01:01:33,490 --> 01:01:36,850
there's much more to come but that's

01:01:35,260 --> 01:01:39,010
clearly headed in that direction that

01:01:36,850 --> 01:01:41,230
you get a more complete picture of what

01:01:39,010 --> 01:01:46,210
you i had another slide what you want

01:01:41,230 --> 01:01:49,530
from an OS should all be in there no not

01:01:46,210 --> 01:01:52,840
no longer there sorry about that but

01:01:49,530 --> 01:01:55,240
essentially you want an API an SDK you

01:01:52,840 --> 01:01:58,330
want deep system demons that run stuff

01:01:55,240 --> 01:01:59,890
for you in an easy way and you want

01:01:58,330 --> 01:02:02,890
security you want some user management

01:01:59,890 --> 01:02:04,360
you want a GUI you want to see a lie so

01:02:02,890 --> 01:02:05,890
one thing I didn't mention this we have

01:02:04,360 --> 01:02:08,440
for example command-line

01:02:05,890 --> 01:02:10,720
that lets you say whoa wherever this

01:02:08,440 --> 01:02:13,780
task is running I want to SSH into that

01:02:10,720 --> 01:02:16,510
box and read the log or or manipulate

01:02:13,780 --> 01:02:18,400
that box or whatever I didn't talk about

01:02:16,510 --> 01:02:20,320
logging that comes with it also you want

01:02:18,400 --> 01:02:23,950
to hook this up to say splunk or

01:02:20,320 --> 01:02:26,110
something like that or all these things

01:02:23,950 --> 01:02:28,180
need to be all these struts need to be

01:02:26,110 --> 01:02:30,370
made and connected and then we have

01:02:28,180 --> 01:02:33,250
something that amounts to the look and

01:02:30,370 --> 01:02:34,990
feel and usefulness of an operating

01:02:33,250 --> 01:02:37,480
system on top of a data center and I

01:02:34,990 --> 01:02:39,280
don't say cluster here only for the

01:02:37,480 --> 01:02:40,960
reason that we only really need one

01:02:39,280 --> 01:02:53,230
production cluster once we achieve that

01:02:40,960 --> 01:02:56,350
and that is your data center then yeah

01:02:53,230 --> 01:02:57,460
that would be another layer as I

01:02:56,350 --> 01:02:59,380
understand it now there are some

01:02:57,460 --> 01:03:00,880
companies that kind of conflate these

01:02:59,380 --> 01:03:04,780
two layers I know that there's a system

01:03:00,880 --> 01:03:07,180
from facebook tupperware that does a lot

01:03:04,780 --> 01:03:10,660
of that I know that Microsoft has

01:03:07,180 --> 01:03:13,330
something called the autopilot i'm not

01:03:10,660 --> 01:03:16,540
sure i'm guessing that addresses both

01:03:13,330 --> 01:03:26,380
aspects we're trying to do one thing

01:03:16,540 --> 01:03:29,920
right and then go from there yes it is

01:03:26,380 --> 01:03:32,380
it's not just mesosphere it's the whole

01:03:29,920 --> 01:03:33,970
ecosystem here and of course that the

01:03:32,380 --> 01:03:38,620
center of that is the apache measles

01:03:33,970 --> 01:03:41,470
open source project yeah we're just part

01:03:38,620 --> 01:03:43,810
of the community there so I think you

01:03:41,470 --> 01:03:46,140
we're done yep thank you very much

01:03:43,810 --> 01:03:46,140

YouTube URL: https://www.youtube.com/watch?v=OigmF7S1oHs


