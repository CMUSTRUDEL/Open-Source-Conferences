Title: OSDC 2018 | Apache Ignite: the in-memory hammer in your data science toolkit by Akmal Chaudhri
Publication date: 2018-06-22
Playlist: OSDC 2018 | Open Source Data Center Conference
Description: 
	Machine learning is a method of data analysis that automates the building of analytical models. By using algorithms that iteratively learn from data, computers are able to find hidden insights without the help of explicit programming. These insights bring tremendous benefits into many different domains. For business users, in particular, these insights help organizations improve customer experience, become more competitive, and respond much faster to opportunities or threats. The availability of very powerful in-memory computing platforms, such as Apache Ignite, means that more organizations can benefit from machine learning today. In this presentation we will look at some of the main components of Apache Ignite, such as the Compute Grid, Data Grid and the Machine Learning Grid. Through examples, attendees will learn how Apache Ignite can be used for data analysis.

NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de
Blog: http://blog.netways.de
Webinare: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Google+: https://plus.google.com/+netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh

https://www.frametraxx.de/
Captions: 
	00:00:00,540 --> 00:00:03,380
[Music]

00:00:01,320 --> 00:00:03,380
you

00:00:11,750 --> 00:00:16,970
[Music]

00:00:13,330 --> 00:00:18,950
great well thank you very much this is

00:00:16,970 --> 00:00:21,140
the second day of the conference and

00:00:18,950 --> 00:00:23,060
it's almost over so those of you have

00:00:21,140 --> 00:00:25,130
made it this far congratulations you

00:00:23,060 --> 00:00:27,320
know you're by now your brains are full

00:00:25,130 --> 00:00:31,640
and you're keen to go home you've got

00:00:27,320 --> 00:00:36,080
things to do not stay here so I'll do my

00:00:31,640 --> 00:00:40,220
best to try and get through the material

00:00:36,080 --> 00:00:42,979
as quickly as possible so just a few

00:00:40,220 --> 00:00:47,300
slides about me so just to say Who I am

00:00:42,979 --> 00:00:50,239
and what I do so that's me

00:00:47,300 --> 00:00:53,030
so my background I've out guy you know

00:00:50,239 --> 00:00:56,839
gray hair white hair no hair you know

00:00:53,030 --> 00:01:00,350
it's it's like that I've seen seen it

00:00:56,839 --> 00:01:02,479
done it got the t-shirt in my IT career

00:01:00,350 --> 00:01:04,670
pretty much everything so I started life

00:01:02,479 --> 00:01:06,670
as a developer long time ago working for

00:01:04,670 --> 00:01:09,080
Reuters in London real-time systems

00:01:06,670 --> 00:01:12,440
relational databases and then

00:01:09,080 --> 00:01:14,920
subsequently was an academic consultant

00:01:12,440 --> 00:01:19,460
and then worked for a few other vendors

00:01:14,920 --> 00:01:22,460
I had the great privilege at Informix to

00:01:19,460 --> 00:01:24,890
work for Mike Stonebreaker mike is a

00:01:22,460 --> 00:01:26,780
name if you know anything about database

00:01:24,890 --> 00:01:28,430
systems his name will be very familiar

00:01:26,780 --> 00:01:33,430
to you so he's the guy who invented

00:01:28,430 --> 00:01:36,830
ingress Postgres side DB vault DB tamer

00:01:33,430 --> 00:01:38,720
Vertica dot dot dot the list goes on you

00:01:36,830 --> 00:01:41,180
know fabulous gentleman so great

00:01:38,720 --> 00:01:44,570
academic based it's Berkeley for a long

00:01:41,180 --> 00:01:46,280
time these days he's at MIT not quite so

00:01:44,570 --> 00:01:48,470
active because he's quite quite an

00:01:46,280 --> 00:01:50,900
elderly statesman these days but still

00:01:48,470 --> 00:01:52,720
you know he he publishes from time to

00:01:50,900 --> 00:01:56,659
time

00:01:52,720 --> 00:01:59,080
what for IBM for a long time and I was

00:01:56,659 --> 00:02:03,680
involved in developer relations and

00:01:59,080 --> 00:02:05,360
academic initiatives subsequently got

00:02:03,680 --> 00:02:09,110
into the Big Data space a few years ago

00:02:05,360 --> 00:02:11,870
so I worked for Hortonworks Hadoop for

00:02:09,110 --> 00:02:13,220
data stacks on Cassandra and then I was

00:02:11,870 --> 00:02:14,930
an independent consultant so I worked

00:02:13,220 --> 00:02:17,299
for a couple of companies vault DB

00:02:14,930 --> 00:02:21,319
MongoDB and did some consulting with

00:02:17,299 --> 00:02:23,080
them about a year ago grid gain came to

00:02:21,319 --> 00:02:26,560
me and they said we have

00:02:23,080 --> 00:02:30,730
job we would like to offer it to you

00:02:26,560 --> 00:02:33,220
okay so we need someone to help raise

00:02:30,730 --> 00:02:37,090
awareness of technology called Apache

00:02:33,220 --> 00:02:39,100
ignite um nice I know I was a little bit

00:02:37,090 --> 00:02:42,310
surprised so I knew nothing about ignite

00:02:39,100 --> 00:02:44,050
I knew nothing about grid gain and so I

00:02:42,310 --> 00:02:46,300
was kind of pleasantly surprised that

00:02:44,050 --> 00:02:49,480
someone wants to pay me money to talk

00:02:46,300 --> 00:02:51,340
about open source and so I feel I've got

00:02:49,480 --> 00:02:53,650
the best job in the world now you know I

00:02:51,340 --> 00:02:57,550
actually get paid for speaking about

00:02:53,650 --> 00:03:00,550
open source not bad and so in the early

00:02:57,550 --> 00:03:04,120
days when I was learning about ignite

00:03:00,550 --> 00:03:05,709
you know it's kind of evolved even the

00:03:04,120 --> 00:03:09,580
short space of time that I've been there

00:03:05,709 --> 00:03:11,350
and so originally it started life as an

00:03:09,580 --> 00:03:13,090
in-memory data grid and you may be

00:03:11,350 --> 00:03:14,530
familiar with some other commercial

00:03:13,090 --> 00:03:18,040
technologies such as oracle coherence

00:03:14,530 --> 00:03:19,840
for example hazel caste there's a few

00:03:18,040 --> 00:03:22,540
others as well that you may be aware of

00:03:19,840 --> 00:03:25,270
well ignites comes from that kind of

00:03:22,540 --> 00:03:28,110
space if you like but during this past

00:03:25,270 --> 00:03:30,459
year it's evolved significantly so now

00:03:28,110 --> 00:03:32,440
it supports equal ninety-nine for

00:03:30,459 --> 00:03:35,350
example and you can treat it as a

00:03:32,440 --> 00:03:38,739
distributed SQL database if you want

00:03:35,350 --> 00:03:41,200
it's got native persistence so rather

00:03:38,739 --> 00:03:43,209
than just working with an external

00:03:41,200 --> 00:03:45,700
third-party database system be it

00:03:43,209 --> 00:03:47,860
relational or non-relational you can

00:03:45,700 --> 00:03:51,580
actually persist data directly within

00:03:47,860 --> 00:03:54,040
ignite it does machine learning okay

00:03:51,580 --> 00:03:55,570
which is the presentation we're going to

00:03:54,040 --> 00:03:57,130
focus on today and we'll talk a little

00:03:55,570 --> 00:04:01,840
bit about some of its capabilities in

00:03:57,130 --> 00:04:03,700
that space okay so um broadly speaking

00:04:01,840 --> 00:04:05,350
then as I said before you know been

00:04:03,700 --> 00:04:06,930
there done that got the t-shirt lots of

00:04:05,350 --> 00:04:09,790
things that I've done through my career

00:04:06,930 --> 00:04:11,380
very fortunate to have had the

00:04:09,790 --> 00:04:14,170
opportunity to publish a number of books

00:04:11,380 --> 00:04:17,489
as well so these make wonderful gifts

00:04:14,170 --> 00:04:19,720
for family friends loved ones if you're

00:04:17,489 --> 00:04:22,330
looking for anything to give to people

00:04:19,720 --> 00:04:24,790
at Christmas Hannukah any time of year

00:04:22,330 --> 00:04:27,040
you know birthdays seriously though

00:04:24,790 --> 00:04:29,770
don't buy these okay look at the titles

00:04:27,040 --> 00:04:33,280
you know object-oriented databases who

00:04:29,770 --> 00:04:36,639
uses them nobody you know XML databases

00:04:33,280 --> 00:04:38,289
who uses them nobody alright so

00:04:36,639 --> 00:04:41,590
it's the nature of technology you know

00:04:38,289 --> 00:04:43,749
things come they are around for a while

00:04:41,590 --> 00:04:46,029
and then they go you know something else

00:04:43,749 --> 00:04:47,319
comes along so the hot technologies the

00:04:46,029 --> 00:04:49,689
hot things people are talking about

00:04:47,319 --> 00:04:51,580
today no sequel MongoDB yeah you're

00:04:49,689 --> 00:04:54,310
probably you know you guys are probably

00:04:51,580 --> 00:04:58,150
using some of those tools today but you

00:04:54,310 --> 00:05:02,050
know that's life one of the things that

00:04:58,150 --> 00:05:04,990
my boss got me to do Dennis magda so

00:05:02,050 --> 00:05:07,150
Dennis is the PMC for ignite at the

00:05:04,990 --> 00:05:10,240
Apache Software Foundation he's the guy

00:05:07,150 --> 00:05:13,750
who runs the program effectively and so

00:05:10,240 --> 00:05:15,879
he got me to write some articles and so

00:05:13,750 --> 00:05:18,990
if you have the opportunity you know

00:05:15,879 --> 00:05:21,639
just pop along the d-zone this about I

00:05:18,990 --> 00:05:23,139
think nineteen articles have been

00:05:21,639 --> 00:05:25,750
published during this past year so

00:05:23,139 --> 00:05:27,520
initially as I was learning I was just

00:05:25,750 --> 00:05:29,770
writing about what I was learning okay

00:05:27,520 --> 00:05:32,469
so sharing what I had learned with

00:05:29,770 --> 00:05:34,029
others especially this year it's got a

00:05:32,469 --> 00:05:37,779
little bit more technical so we talked

00:05:34,029 --> 00:05:40,270
about sings like recovery failure you

00:05:37,779 --> 00:05:42,759
know what happens to a primary a

00:05:40,270 --> 00:05:45,099
secondary you know what happens if the

00:05:42,759 --> 00:05:47,949
the client fails you know and you've got

00:05:45,099 --> 00:05:49,479
jobs submitted you've got and as you

00:05:47,949 --> 00:05:52,240
know I mean distributed systems are hard

00:05:49,479 --> 00:05:54,430
to build and they are hard to recover

00:05:52,240 --> 00:05:57,099
but if you use things like two-phase

00:05:54,430 --> 00:05:59,830
commit which is very well understood and

00:05:57,099 --> 00:06:02,050
very popular and you know it's a

00:05:59,830 --> 00:06:03,430
technology that's very widely used then

00:06:02,050 --> 00:06:07,719
things become a little bit more easier

00:06:03,430 --> 00:06:10,060
so some stuff there and more recently

00:06:07,719 --> 00:06:13,360
then so let me just end this one and

00:06:10,060 --> 00:06:14,800
just quickly switch to the web browser

00:06:13,360 --> 00:06:17,949
just for a moment okay and then we'll

00:06:14,800 --> 00:06:21,069
get into the main presentations so over

00:06:17,949 --> 00:06:23,319
the last couple of weeks then there's an

00:06:21,069 --> 00:06:24,250
article on genetic algorithms I'll show

00:06:23,319 --> 00:06:28,419
you a demo of that today

00:06:24,250 --> 00:06:30,219
okay so ignite now supports some genetic

00:06:28,419 --> 00:06:31,719
algorithm capability as part of the

00:06:30,219 --> 00:06:35,889
machine learning effort

00:06:31,719 --> 00:06:36,969
I just wrote an article on introduction

00:06:35,889 --> 00:06:39,669
to machine learning this was published

00:06:36,969 --> 00:06:41,589
on d-zone very recently and then there's

00:06:39,669 --> 00:06:43,419
another one I've just written on linear

00:06:41,589 --> 00:06:45,099
regression okay which is available on

00:06:43,419 --> 00:06:47,050
grid gain it hasn't been published on

00:06:45,099 --> 00:06:51,180
d-zone yet it's going to be hopefully

00:06:47,050 --> 00:06:53,970
very soon other

00:06:51,180 --> 00:06:57,960
let me just point this page okay so this

00:06:53,970 --> 00:07:00,840
is the landing page for ignite at the

00:06:57,960 --> 00:07:04,710
Apache Software Foundation now notice it

00:07:00,840 --> 00:07:09,210
says here database and caching platform

00:07:04,710 --> 00:07:11,820
so in memory data grids I mdgs tend to

00:07:09,210 --> 00:07:13,050
have a kind of you know the flavor is

00:07:11,820 --> 00:07:15,600
kind of caching so if you're familiar

00:07:13,050 --> 00:07:17,729
with cache technologies such as product

00:07:15,600 --> 00:07:21,090
such as Redis for example or others you

00:07:17,729 --> 00:07:23,010
know what they are capable of doing the

00:07:21,090 --> 00:07:24,660
thing is what you need to remember is

00:07:23,010 --> 00:07:27,060
that an in-memory data grid there's far

00:07:24,660 --> 00:07:31,020
more than just caching so for example

00:07:27,060 --> 00:07:33,210
ignite supports transactions okay and it

00:07:31,020 --> 00:07:35,789
can do optimistic transactions it can do

00:07:33,210 --> 00:07:38,760
pessimistic transactions depends on your

00:07:35,789 --> 00:07:40,620
use case and if you work in the

00:07:38,760 --> 00:07:42,810
financial world for example you will

00:07:40,620 --> 00:07:46,349
know that pessimistic transactions

00:07:42,810 --> 00:07:48,120
locking the need for a system to move

00:07:46,349 --> 00:07:50,070
from one consistent state to another

00:07:48,120 --> 00:07:51,780
consistent state is very very important

00:07:50,070 --> 00:07:53,310
okay because these guys they deal with

00:07:51,780 --> 00:07:56,360
you know literally trillions of dollars

00:07:53,310 --> 00:07:59,669
every day in terms of work that gets

00:07:56,360 --> 00:08:02,310
shuffled around the world and just to

00:07:59,669 --> 00:08:04,919
give you an idea of why it's important

00:08:02,310 --> 00:08:07,320
just from my own personal experience

00:08:04,919 --> 00:08:07,919
earlier this year so I'm a great fan of

00:08:07,320 --> 00:08:10,500
MOOCs

00:08:07,919 --> 00:08:13,020
I like these massive open online courses

00:08:10,500 --> 00:08:15,900
Coursera EDX you know there's a whole

00:08:13,020 --> 00:08:18,030
load of them earlier this year I was on

00:08:15,900 --> 00:08:19,590
the Coursera website and there was a

00:08:18,030 --> 00:08:21,599
particular course that I happen to like

00:08:19,590 --> 00:08:23,729
and I was keen to get the certificate

00:08:21,599 --> 00:08:26,610
for this and I got my credit card out

00:08:23,729 --> 00:08:29,430
filled in the details I hit the submit

00:08:26,610 --> 00:08:32,300
button and it comes up with an error it

00:08:29,430 --> 00:08:34,800
says there is an error contact Coursera

00:08:32,300 --> 00:08:37,260
okay I didn't think anything of it you

00:08:34,800 --> 00:08:39,510
know it's it's an error the transaction

00:08:37,260 --> 00:08:42,180
didn't complete no problem all right

00:08:39,510 --> 00:08:44,070
sometime later I check on my bank

00:08:42,180 --> 00:08:48,900
statement I noticed that I've actually

00:08:44,070 --> 00:08:51,060
been billed so contact Coursera they say

00:08:48,900 --> 00:08:53,160
we haven't received the money the bank

00:08:51,060 --> 00:08:56,160
has charged me you know where's the

00:08:53,160 --> 00:08:58,860
money you know there is a case of a

00:08:56,160 --> 00:09:00,540
poorly designed system and I and I feel

00:08:58,860 --> 00:09:02,820
you know that Coursera could do better

00:09:00,540 --> 00:09:04,200
so in this type of scenario you know

00:09:02,820 --> 00:09:06,300
either the transaction

00:09:04,200 --> 00:09:08,160
completes they take my money and I get

00:09:06,300 --> 00:09:11,700
correctly billed or it doesn't complete

00:09:08,160 --> 00:09:13,290
I don't get charged it's kind of a you

00:09:11,700 --> 00:09:15,030
know it's stuck in the middle there and

00:09:13,290 --> 00:09:17,040
so it's my responsibility now to sort

00:09:15,030 --> 00:09:19,190
this out okay that shouldn't happen and

00:09:17,040 --> 00:09:21,840
again if you look at things like

00:09:19,190 --> 00:09:25,170
transferring money between bank accounts

00:09:21,840 --> 00:09:28,620
so I want to send my wife say you know

00:09:25,170 --> 00:09:30,420
100 euros or a thousand euros it should

00:09:28,620 --> 00:09:32,070
be the case that my account is correctly

00:09:30,420 --> 00:09:33,600
debited her account is correctly

00:09:32,070 --> 00:09:35,970
credited we can't have the situation

00:09:33,600 --> 00:09:37,440
where the money leaves my account but

00:09:35,970 --> 00:09:40,290
doesn't reach her account you know this

00:09:37,440 --> 00:09:43,290
is an inconsistent state not good okay

00:09:40,290 --> 00:09:44,610
this needs resolution then subsequently

00:09:43,290 --> 00:09:46,650
you have to figure out what you're going

00:09:44,610 --> 00:09:49,680
to do in these scenarios and so it's an

00:09:46,650 --> 00:09:51,690
atomic unit of work so ignite can do

00:09:49,680 --> 00:09:54,180
these type of transactions and it can do

00:09:51,690 --> 00:09:56,760
them in memory the other thing is and

00:09:54,180 --> 00:09:59,580
we'll get to this a little bit later on

00:09:56,760 --> 00:10:01,560
is that because of these additional

00:09:59,580 --> 00:10:03,210
capabilities that they've added this

00:10:01,560 --> 00:10:05,760
last year especially is support for

00:10:03,210 --> 00:10:08,220
sequel 99 so if you're familiar with

00:10:05,760 --> 00:10:10,860
some of Google's technologies Google

00:10:08,220 --> 00:10:13,560
spanner for example ignite is kind of

00:10:10,860 --> 00:10:14,970
similar to that cockroach TB is another

00:10:13,560 --> 00:10:18,030
one you might be familiar with okay so

00:10:14,970 --> 00:10:20,400
these are sequel based products that can

00:10:18,030 --> 00:10:23,910
work in the distributed environment and

00:10:20,400 --> 00:10:27,240
you know this is the kind of thing that

00:10:23,910 --> 00:10:31,350
ignite can do today okay so a little bit

00:10:27,240 --> 00:10:34,740
more about that later all right so let

00:10:31,350 --> 00:10:37,500
me drill down now and we'll do the main

00:10:34,740 --> 00:10:39,240
kind of presentations kay so I've talked

00:10:37,500 --> 00:10:42,420
for about 10 minutes there so just keep

00:10:39,240 --> 00:10:43,680
an eye on the time hopefully you'll be

00:10:42,420 --> 00:10:46,350
able to see that without too much

00:10:43,680 --> 00:10:47,910
difficulty sorry it's you know the fonts

00:10:46,350 --> 00:10:49,890
may be a little bit small but it says in

00:10:47,910 --> 00:10:51,570
memory performance durability of disk

00:10:49,890 --> 00:10:53,910
and I'll explain that in a moment

00:10:51,570 --> 00:10:56,010
now obviously the focus very much today

00:10:53,910 --> 00:10:58,530
is talking about some of the machine

00:10:56,010 --> 00:11:03,480
learning capabilities that ignite can do

00:10:58,530 --> 00:11:04,980
and then in terms of agenda so I'll give

00:11:03,480 --> 00:11:06,510
you a little bit more of an overview and

00:11:04,980 --> 00:11:09,410
look at some of the components that

00:11:06,510 --> 00:11:11,460
ignite supports and then if you're

00:11:09,410 --> 00:11:13,410
interested in sort of machine learning

00:11:11,460 --> 00:11:15,160
or as a data scientist some of the

00:11:13,410 --> 00:11:17,040
capabilities

00:11:15,160 --> 00:11:20,410
we'll look at the memory centric storage

00:11:17,040 --> 00:11:23,230
the compute grid machine learning

00:11:20,410 --> 00:11:24,850
genetic algorithms and I've got a couple

00:11:23,230 --> 00:11:26,259
of very simple demos to show you as well

00:11:24,850 --> 00:11:29,019
I mean this is code that you can

00:11:26,259 --> 00:11:32,680
download and build yourselves you can

00:11:29,019 --> 00:11:34,389
try out yourselves as well and as part

00:11:32,680 --> 00:11:36,220
of the articles that I'm writing around

00:11:34,389 --> 00:11:37,569
this whole machine learning thing and

00:11:36,220 --> 00:11:38,620
some of my colleagues at Green are

00:11:37,569 --> 00:11:40,600
contributing as well

00:11:38,620 --> 00:11:42,220
these things are hosted on github very

00:11:40,600 --> 00:11:46,930
easy to download and if you're familiar

00:11:42,220 --> 00:11:49,329
with Java then it's very easy okay all

00:11:46,930 --> 00:11:52,870
right then so the high-level picture is

00:11:49,329 --> 00:11:55,509
kind of like this okay so notice that

00:11:52,870 --> 00:11:57,550
we've got here this memory centric

00:11:55,509 --> 00:12:00,209
storage of hey so this is really at the

00:11:57,550 --> 00:12:02,529
heart of what ignite is all about and

00:12:00,209 --> 00:12:05,110
historically where it came from

00:12:02,529 --> 00:12:07,240
as an in-memory data grid very much the

00:12:05,110 --> 00:12:11,500
focus was on trying to achieve two

00:12:07,240 --> 00:12:14,019
things scale and performance okay so the

00:12:11,500 --> 00:12:17,050
ability to use cluster computing to

00:12:14,019 --> 00:12:19,360
scale up okay use parallelism use the

00:12:17,050 --> 00:12:21,850
power of the cluster to be able to work

00:12:19,360 --> 00:12:24,819
across large amounts of data and be able

00:12:21,850 --> 00:12:27,550
to cache that data as well

00:12:24,819 --> 00:12:30,130
more recently the persistence

00:12:27,550 --> 00:12:33,550
capabilities have been added so it can

00:12:30,130 --> 00:12:36,420
natively persist data now as well so in

00:12:33,550 --> 00:12:38,529
the event that you've got some type of

00:12:36,420 --> 00:12:41,050
catastrophic event that happens let's

00:12:38,529 --> 00:12:43,540
say your entire cluster goes down the

00:12:41,050 --> 00:12:44,800
state can be saved and the things can be

00:12:43,540 --> 00:12:47,079
brought back up again very quickly

00:12:44,800 --> 00:12:49,750
that's a key what are the key advantages

00:12:47,079 --> 00:12:52,389
there and in this mode you can treat

00:12:49,750 --> 00:12:55,630
again ignite as a distributed database

00:12:52,389 --> 00:12:58,269
system okay it will work with third

00:12:55,630 --> 00:13:01,449
party stores as well if you have a

00:12:58,269 --> 00:13:04,660
transactional product typically that

00:13:01,449 --> 00:13:07,120
means relational then what ignite can do

00:13:04,660 --> 00:13:10,930
then is act as a cache for that

00:13:07,120 --> 00:13:12,100
relational system so and it will keep

00:13:10,930 --> 00:13:14,740
its cache

00:13:12,100 --> 00:13:17,079
whatever it has in memory plus the

00:13:14,740 --> 00:13:20,649
back-end database in sync okay

00:13:17,079 --> 00:13:22,629
cache consistency so it can read data

00:13:20,649 --> 00:13:25,029
from the relational system okay and you

00:13:22,629 --> 00:13:28,329
can define which tables you want it to

00:13:25,029 --> 00:13:29,060
manage and so on and as transactions are

00:13:28,329 --> 00:13:31,040
completed

00:13:29,060 --> 00:13:33,290
it will ensure that the backends

00:13:31,040 --> 00:13:34,760
relational system is updated and if

00:13:33,290 --> 00:13:36,680
there are changes within the relational

00:13:34,760 --> 00:13:38,300
system these are propagated to the cache

00:13:36,680 --> 00:13:41,270
as well so the two are always kept in

00:13:38,300 --> 00:13:43,460
sync and if you'd like to have a sort of

00:13:41,270 --> 00:13:44,930
quick look 10 minutes of your time the

00:13:43,460 --> 00:13:46,660
webpage the landing page that I showed

00:13:44,930 --> 00:13:49,150
you at the Apache Software Foundation

00:13:46,660 --> 00:13:51,590
top right hand corner it says

00:13:49,150 --> 00:13:54,320
screencasts okay so just drill down and

00:13:51,590 --> 00:13:56,150
there are three short three minutes

00:13:54,320 --> 00:13:57,680
three and a half minute videos three of

00:13:56,150 --> 00:13:59,810
them together at about ten minutes in

00:13:57,680 --> 00:14:01,850
duration it shows you exactly how to do

00:13:59,810 --> 00:14:03,800
this using my sequel okay so you just

00:14:01,850 --> 00:14:06,320
walk through a series of steps it

00:14:03,800 --> 00:14:09,290
creates a project for you and then it

00:14:06,320 --> 00:14:12,620
will maintain the consistency of the

00:14:09,290 --> 00:14:15,770
data that has in memory and also with

00:14:12,620 --> 00:14:17,540
the backend relational system this can

00:14:15,770 --> 00:14:20,270
work quite well in certain scenarios so

00:14:17,540 --> 00:14:22,880
the situation is that very rarely today

00:14:20,270 --> 00:14:25,430
do we have the sort of freedom and the

00:14:22,880 --> 00:14:28,550
option if you like to just throw away an

00:14:25,430 --> 00:14:30,680
existing system business systems have

00:14:28,550 --> 00:14:32,060
value we have to care for them we have

00:14:30,680 --> 00:14:34,130
to love them you know they have to be

00:14:32,060 --> 00:14:36,950
maintained there is information there

00:14:34,130 --> 00:14:39,500
that we need to access so in this kind

00:14:36,950 --> 00:14:41,990
of mode what Ignite allows you to do is

00:14:39,500 --> 00:14:45,470
to be able to work with transactional

00:14:41,990 --> 00:14:47,030
systems scale up improve performance and

00:14:45,470 --> 00:14:49,700
just to give you a quick example so

00:14:47,030 --> 00:14:51,980
earlier this year I was in Brussels in

00:14:49,700 --> 00:14:54,410
Belgium and I did a sort of general

00:14:51,980 --> 00:14:55,670
presentation about ignite and there was

00:14:54,410 --> 00:14:57,380
a gentleman in the audience he came to

00:14:55,670 --> 00:14:59,839
me at the end he said we're very

00:14:57,380 --> 00:15:02,839
interested in this because we we are a

00:14:59,839 --> 00:15:04,310
big Postgres user and we like Postgres

00:15:02,839 --> 00:15:06,830
very much so we're not going to get rid

00:15:04,310 --> 00:15:09,050
of it for the vast majority of our use

00:15:06,830 --> 00:15:11,030
cases it works well there are some

00:15:09,050 --> 00:15:13,100
queries though where it's very very slow

00:15:11,030 --> 00:15:15,170
and so something like this can really

00:15:13,100 --> 00:15:18,110
help because then ignite can scale out

00:15:15,170 --> 00:15:21,260
that query it can run that query at

00:15:18,110 --> 00:15:23,510
memory speeds it can do parallelism you

00:15:21,260 --> 00:15:26,180
know there's some tricks and neat things

00:15:23,510 --> 00:15:28,430
they can do to really be able to push

00:15:26,180 --> 00:15:31,250
that performance level up okay so in

00:15:28,430 --> 00:15:34,339
that situation an existing system can be

00:15:31,250 --> 00:15:37,280
augmented and we can use ignite to

00:15:34,339 --> 00:15:40,520
improve that you'll notice that it also

00:15:37,280 --> 00:15:41,840
says HDFS and no sequel yes it will work

00:15:40,520 --> 00:15:45,020
with these

00:15:41,840 --> 00:15:48,500
technologies these you know Cassandra

00:15:45,020 --> 00:15:50,330
MongoDB technologies like that bear in

00:15:48,500 --> 00:15:52,100
mind though that the vast majority of

00:15:50,330 --> 00:15:53,810
these no sequel products are not

00:15:52,100 --> 00:15:55,490
transactional you know they use things

00:15:53,810 --> 00:15:58,130
like eventual consistency

00:15:55,490 --> 00:15:59,900
although MongoDB have announced version

00:15:58,130 --> 00:16:02,630
four of their technology which is going

00:15:59,900 --> 00:16:04,130
to support you know the kind of

00:16:02,630 --> 00:16:09,410
capabilities that you're used to working

00:16:04,130 --> 00:16:12,290
with with relational systems ok so I'm

00:16:09,410 --> 00:16:14,330
slightly higher than from left to right

00:16:12,290 --> 00:16:16,550
then some sequel sequel 99 so it's

00:16:14,330 --> 00:16:19,310
always had some level of sequel support

00:16:16,550 --> 00:16:21,590
now the thing is why go for sequel well

00:16:19,310 --> 00:16:23,990
the thing is that you know whether you

00:16:21,590 --> 00:16:26,780
like it or you hate it possibly some of

00:16:23,990 --> 00:16:29,660
you hate it but sequel is intergalactic

00:16:26,780 --> 00:16:31,850
data speak you know it's used by lots of

00:16:29,660 --> 00:16:35,570
business intelligence tools there is a

00:16:31,850 --> 00:16:37,280
wide range of skilled people available

00:16:35,570 --> 00:16:39,380
today you know both in terms of DBAs and

00:16:37,280 --> 00:16:41,660
developers who are familiar with the

00:16:39,380 --> 00:16:43,160
language therefore it's easy to find

00:16:41,660 --> 00:16:45,200
people with the relevant skills to be

00:16:43,160 --> 00:16:45,980
able to use it it's actually very very

00:16:45,200 --> 00:16:49,010
powerful as well

00:16:45,980 --> 00:16:51,110
I mean it's declarative language um you

00:16:49,010 --> 00:16:52,760
know you say what you want not how to

00:16:51,110 --> 00:16:54,470
get it the system figures out the best

00:16:52,760 --> 00:16:56,870
way to be able to retrieve the data for

00:16:54,470 --> 00:17:00,080
you and using this in the distributed

00:16:56,870 --> 00:17:02,420
environment of course has you know there

00:17:00,080 --> 00:17:04,790
are some issues to think about so for

00:17:02,420 --> 00:17:07,270
example one of the things that ignite

00:17:04,790 --> 00:17:10,940
can do is this notion of colocation

00:17:07,270 --> 00:17:13,520
affinity keys okay so data that kind of

00:17:10,940 --> 00:17:15,110
is used together can be co-located

00:17:13,520 --> 00:17:17,600
together on a particular node and

00:17:15,110 --> 00:17:19,280
therefore that saves the overhead of

00:17:17,600 --> 00:17:21,620
searching your entire cluster when you

00:17:19,280 --> 00:17:24,200
want to do joins or queries across a

00:17:21,620 --> 00:17:25,610
large range of data if you've taken some

00:17:24,200 --> 00:17:28,100
intelligent decisions about how that

00:17:25,610 --> 00:17:30,590
data is located with other data then

00:17:28,100 --> 00:17:34,400
those queries can be really sort of

00:17:30,590 --> 00:17:36,770
significantly speeded up um he value so

00:17:34,400 --> 00:17:38,240
and it's hard it is a key value store so

00:17:36,770 --> 00:17:40,580
if you've worked with things like Redax

00:17:38,240 --> 00:17:43,670
for example it's a very same sort of

00:17:40,580 --> 00:17:45,500
approach the key thing to note here

00:17:43,670 --> 00:17:47,810
though is that the value can be anything

00:17:45,500 --> 00:17:50,180
okay these simple types can be

00:17:47,810 --> 00:17:52,100
user-defined types so you could have for

00:17:50,180 --> 00:17:54,020
example financial instruments or

00:17:52,100 --> 00:17:55,000
healthcare records or anything you want

00:17:54,020 --> 00:17:57,640
as long as

00:17:55,000 --> 00:18:02,380
it's definable now ignite is written in

00:17:57,640 --> 00:18:04,990
Java but it supports C++ and.net as sort

00:18:02,380 --> 00:18:06,760
of first tier languages as well other

00:18:04,990 --> 00:18:09,280
languages are supported as well but

00:18:06,760 --> 00:18:12,490
typically through JDBC at ODBC right

00:18:09,280 --> 00:18:14,620
there are some there is work underway to

00:18:12,490 --> 00:18:18,970
provide better support for languages

00:18:14,620 --> 00:18:22,300
such as Python and Ruby and so on using

00:18:18,970 --> 00:18:23,860
some this thin protocol that they call

00:18:22,300 --> 00:18:25,330
it so if you're familiar with how

00:18:23,860 --> 00:18:28,030
MongoDB have done this you know they

00:18:25,330 --> 00:18:30,490
have a great plethora of community

00:18:28,030 --> 00:18:31,960
drivers for their products that's a

00:18:30,490 --> 00:18:34,030
great way that they've done this because

00:18:31,960 --> 00:18:36,040
they've defined this protocol and then

00:18:34,030 --> 00:18:38,110
people just write the code to the api's

00:18:36,040 --> 00:18:40,990
to the protocol they're taking a similar

00:18:38,110 --> 00:18:42,880
approach now with ignite we mentioned

00:18:40,990 --> 00:18:45,580
transactions okay so again very very

00:18:42,880 --> 00:18:47,800
useful so optimistic and pessimistic

00:18:45,580 --> 00:18:50,290
okay so optimistic and then of course

00:18:47,800 --> 00:18:55,090
things like how do you deal with

00:18:50,290 --> 00:18:57,610
situations where similar you know the

00:18:55,090 --> 00:18:59,800
same resource is being requested in a

00:18:57,610 --> 00:19:02,320
transaction in one transaction and

00:18:59,800 --> 00:19:05,920
another transaction okay so dealing with

00:19:02,320 --> 00:19:09,820
deadlocks there's again code examples to

00:19:05,920 --> 00:19:11,380
show you how to do this okay so compute

00:19:09,820 --> 00:19:14,530
services we won't say too much about

00:19:11,380 --> 00:19:17,080
streaming so it's not a streaming engine

00:19:14,530 --> 00:19:18,880
per se okay but it will work with

00:19:17,080 --> 00:19:21,090
streaming technology so if you're using

00:19:18,880 --> 00:19:24,580
things like spark streaming for example

00:19:21,090 --> 00:19:26,080
flink these type of products ignite will

00:19:24,580 --> 00:19:27,820
happily work with these okay so there

00:19:26,080 --> 00:19:30,730
are adapters and connectors for these

00:19:27,820 --> 00:19:35,500
technologies so ignite can act as a sink

00:19:30,730 --> 00:19:39,730
for stream data okay and being you know

00:19:35,500 --> 00:19:41,140
if you use it purely as a cache there's

00:19:39,730 --> 00:19:43,480
a lot of things that you can do okay so

00:19:41,140 --> 00:19:45,820
as data are being streamed in you could

00:19:43,480 --> 00:19:47,860
run sequel across that data you can

00:19:45,820 --> 00:19:50,170
define Windows you know you might say

00:19:47,860 --> 00:19:52,480
okay I'm interested in the last kind of

00:19:50,170 --> 00:19:54,310
five events or I'm interested in the

00:19:52,480 --> 00:19:56,920
last three minutes worth of data you

00:19:54,310 --> 00:19:58,810
process that quickly so IOT type

00:19:56,920 --> 00:20:01,000
applications for example you know maybe

00:19:58,810 --> 00:20:03,220
sending in lots of stream data you

00:20:01,000 --> 00:20:05,350
process that quickly and again the other

00:20:03,220 --> 00:20:06,960
thing to note here is that you can apply

00:20:05,350 --> 00:20:09,720
machine learning as well

00:20:06,960 --> 00:20:13,050
okay one of the benefits of all of this

00:20:09,720 --> 00:20:14,490
is that you know they say in English you

00:20:13,050 --> 00:20:16,020
know the whole is greater than the sum

00:20:14,490 --> 00:20:17,640
of the parts so you have these various

00:20:16,020 --> 00:20:20,700
components but they're integrated they

00:20:17,640 --> 00:20:22,050
work well together and therefore if for

00:20:20,700 --> 00:20:24,210
example you're using the streaming

00:20:22,050 --> 00:20:26,130
capability you might want to run some

00:20:24,210 --> 00:20:28,140
machine learning on that stream data as

00:20:26,130 --> 00:20:29,640
it arrives or you might want to do some

00:20:28,140 --> 00:20:33,900
sequel queries on it as it arrives

00:20:29,640 --> 00:20:36,000
entirely possible and then the machine

00:20:33,900 --> 00:20:39,120
learning at the end okay so that's what

00:20:36,000 --> 00:20:41,930
we'll focus on moving forward now

00:20:39,120 --> 00:20:44,460
lots of verticals to look at okay so

00:20:41,930 --> 00:20:48,420
plenty of examples both on the Ignite

00:20:44,460 --> 00:20:51,000
website and good gain I ought to make

00:20:48,420 --> 00:20:52,740
clear that my role is that I focus

00:20:51,000 --> 00:20:55,860
purely on the open source okay so I

00:20:52,740 --> 00:20:57,690
don't talk about grid gain very much we

00:20:55,860 --> 00:21:00,780
see they pay my salary you know that's

00:20:57,690 --> 00:21:03,270
good and so if you're interested in any

00:21:00,780 --> 00:21:04,980
of the commercial aspects of this drop

00:21:03,270 --> 00:21:07,620
me an email okay so it's just first name

00:21:04,980 --> 00:21:09,900
dot last name at grid gain calm so Ahmed

00:21:07,620 --> 00:21:11,220
Chaudhry at grid gain calm happy very

00:21:09,900 --> 00:21:18,060
happy to put you in contact with the

00:21:11,220 --> 00:21:20,010
relevant people okay so um why go for

00:21:18,060 --> 00:21:21,990
this kind of machine learning approach

00:21:20,010 --> 00:21:23,940
what's the business case for adding this

00:21:21,990 --> 00:21:25,350
capability because today pretty much

00:21:23,940 --> 00:21:37,800
every vendor is adding machine learning

00:21:25,350 --> 00:21:39,300
to their products but not in

00:21:37,800 --> 00:21:41,280
enough you know I mean what's the

00:21:39,300 --> 00:21:43,460
benefit that I get working with this

00:21:41,280 --> 00:21:47,700
well the key thing is that in the past

00:21:43,460 --> 00:21:50,730
customers users of ignite what they've

00:21:47,700 --> 00:21:53,490
had to do is that it's been an expensive

00:21:50,730 --> 00:21:57,120
process you know ETL you have to extract

00:21:53,490 --> 00:22:00,000
the data out of ignite use some other

00:21:57,120 --> 00:22:02,520
technology or tools to be able to you

00:22:00,000 --> 00:22:04,590
know create training models and then you

00:22:02,520 --> 00:22:05,970
deploy that into production and if

00:22:04,590 --> 00:22:07,860
you're working with large quantities of

00:22:05,970 --> 00:22:11,130
data it's an expensive process you know

00:22:07,860 --> 00:22:12,750
not great so part of the reason for

00:22:11,130 --> 00:22:15,150
adding this machine learning capability

00:22:12,750 --> 00:22:17,370
is really to support the the needs of

00:22:15,150 --> 00:22:19,920
users so that everything is in place

00:22:17,370 --> 00:22:21,780
basically ignite can manage it for you

00:22:19,920 --> 00:22:24,120
it's already managing the data for you

00:22:21,780 --> 00:22:26,070
why do you need to extract it out and

00:22:24,120 --> 00:22:27,990
run other tools and technologies on that

00:22:26,070 --> 00:22:30,900
data to be able to achieve what you want

00:22:27,990 --> 00:22:33,600
to do so no need to move the data out

00:22:30,900 --> 00:22:35,640
now for training purposes no needs to

00:22:33,600 --> 00:22:37,650
wait for that training to complete again

00:22:35,640 --> 00:22:40,140
can be done entirely within ignite and

00:22:37,650 --> 00:22:42,210
again whatever models you create you can

00:22:40,140 --> 00:22:44,850
deploy them straight away and you

00:22:42,210 --> 00:22:47,490
utilize them straightaway and again some

00:22:44,850 --> 00:22:50,520
of the Articles that I'm working on show

00:22:47,490 --> 00:22:53,070
these kind of capabilities the other

00:22:50,520 --> 00:22:56,700
thing is scalability so I touched upon

00:22:53,070 --> 00:22:58,620
that little bit earlier on so today you

00:22:56,700 --> 00:23:01,740
know big data you know people talk about

00:22:58,620 --> 00:23:04,230
the vast volumes of data that

00:23:01,740 --> 00:23:06,000
organizations collect interestingly I

00:23:04,230 --> 00:23:07,710
kind of wonder what people are actually

00:23:06,000 --> 00:23:09,420
doing with this data because I think

00:23:07,710 --> 00:23:11,010
there was a article either in the

00:23:09,420 --> 00:23:13,110
Harvard Business Review or I think MIT

00:23:11,010 --> 00:23:16,020
review or something a few years ago I

00:23:13,110 --> 00:23:18,390
said that only something like 1/2 of 1%

00:23:16,020 --> 00:23:20,790
of all data that organizations ever

00:23:18,390 --> 00:23:22,650
collect is ever analyzed you know the

00:23:20,790 --> 00:23:25,080
remaining ninety-nine point whatever it

00:23:22,650 --> 00:23:27,150
is just sits there you know it's kind of

00:23:25,080 --> 00:23:28,770
rather astonishing because there must be

00:23:27,150 --> 00:23:32,280
an enormous amount of business value

00:23:28,770 --> 00:23:34,200
there and therefore with this huge

00:23:32,280 --> 00:23:36,660
amount of data that sits there you know

00:23:34,200 --> 00:23:39,660
it's typically exceeds the capacity of

00:23:36,660 --> 00:23:42,780
what a single server can do and so using

00:23:39,660 --> 00:23:45,000
cluster computing cheap off-the-shelf

00:23:42,780 --> 00:23:50,310
hardware you can just create a cluster

00:23:45,000 --> 00:23:51,120
very very quickly you can let ignite

00:23:50,310 --> 00:23:52,740
manage

00:23:51,120 --> 00:23:54,630
the complexity of the cluster cluster

00:23:52,740 --> 00:23:56,010
computing for you okay it is something

00:23:54,630 --> 00:23:58,620
that you as a developer don't have to

00:23:56,010 --> 00:24:00,330
worry about less for you to worry about

00:23:58,620 --> 00:24:02,760
okay the burden is kind of removed or

00:24:00,330 --> 00:24:04,380
lessened okay I won't say it's 100%

00:24:02,760 --> 00:24:06,720
removed okay that's not going to happen

00:24:04,380 --> 00:24:09,860
anytime soon but still things that you

00:24:06,720 --> 00:24:14,100
have to think about are going to be

00:24:09,860 --> 00:24:15,600
important but if the system can do far

00:24:14,100 --> 00:24:19,350
more for you that's going to really help

00:24:15,600 --> 00:24:21,110
you and I think typically today then you

00:24:19,350 --> 00:24:23,070
know it's about the business problem

00:24:21,110 --> 00:24:24,900
technology kind of takes second place

00:24:23,070 --> 00:24:27,210
you know it's just an enabler it just

00:24:24,900 --> 00:24:28,710
lets you do things okay but there are

00:24:27,210 --> 00:24:30,090
things that you have to worry about you

00:24:28,710 --> 00:24:31,230
know what is your organization trying to

00:24:30,090 --> 00:24:32,700
do are they trying to make more money

00:24:31,230 --> 00:24:35,040
are they trying to be more competitive

00:24:32,700 --> 00:24:36,450
are they trying to identify new percent

00:24:35,040 --> 00:24:38,340
you know look at threats and

00:24:36,450 --> 00:24:39,809
opportunities what is it that's the

00:24:38,340 --> 00:24:41,309
business case that they're looking for

00:24:39,809 --> 00:24:43,170
and these are the things that we should

00:24:41,309 --> 00:24:44,760
be focusing on at a higher level rather

00:24:43,170 --> 00:24:46,380
than one weren't worrying about the

00:24:44,760 --> 00:24:53,040
underlying tools and technologies that

00:24:46,380 --> 00:24:55,559
that we use okay so so what are the

00:24:53,040 --> 00:24:58,290
things that they've done with ignite and

00:24:55,559 --> 00:25:01,230
again if you're familiar with Java you

00:24:58,290 --> 00:25:03,360
know that garbage collection can be a

00:25:01,230 --> 00:25:05,190
big problem specifically when you're

00:25:03,360 --> 00:25:07,740
dealing with large quantities of data a

00:25:05,190 --> 00:25:10,230
large amount of memory so with ignite

00:25:07,740 --> 00:25:12,090
what they've done is essentially it's

00:25:10,230 --> 00:25:14,460
got its own memory management system

00:25:12,090 --> 00:25:18,300
okay so they've offloaded as much as

00:25:14,460 --> 00:25:20,280
they can so the Java cut has to do you

00:25:18,300 --> 00:25:22,290
know the the garbage collector has to do

00:25:20,280 --> 00:25:27,480
the least amount that is required okay

00:25:22,290 --> 00:25:30,809
and that really helps because of this

00:25:27,480 --> 00:25:32,760
approach of providing persistence

00:25:30,809 --> 00:25:35,190
capability I mean it says their store

00:25:32,760 --> 00:25:37,050
super set of data super set maybe is not

00:25:35,190 --> 00:25:40,410
the correct phrase so essentially all of

00:25:37,050 --> 00:25:42,780
the data can be stored on disk some of

00:25:40,410 --> 00:25:45,360
the data can be cached okay so for

00:25:42,780 --> 00:25:48,390
example you might have terabytes or

00:25:45,360 --> 00:25:51,690
petabytes of data probably you're not

00:25:48,390 --> 00:25:54,030
going to have petabytes of RAM RAM is

00:25:51,690 --> 00:25:56,070
going to be much smaller okay but you

00:25:54,030 --> 00:25:59,070
want to be able to page in some of that

00:25:56,070 --> 00:26:00,840
data to be able to process it and so

00:25:59,070 --> 00:26:03,330
that kind of makes sense okay so you're

00:26:00,840 --> 00:26:04,500
storing all your data on disk you use

00:26:03,330 --> 00:26:07,380
what you need

00:26:04,500 --> 00:26:09,330
in in RAM to be able to get the benefit

00:26:07,380 --> 00:26:12,330
so this durable memory as they call it

00:26:09,330 --> 00:26:14,250
okay the ability to store data persisted

00:26:12,330 --> 00:26:19,440
beyond the lifetime of the process that

00:26:14,250 --> 00:26:22,320
created it other things because it's got

00:26:19,440 --> 00:26:24,210
its own memory management system now and

00:26:22,320 --> 00:26:25,590
by the way this is all open source okay

00:26:24,210 --> 00:26:27,630
so if you want to know how this works

00:26:25,590 --> 00:26:29,909
and you're really interested you can get

00:26:27,630 --> 00:26:31,320
all the code you can poke around in it

00:26:29,909 --> 00:26:34,289
and see how they've actually implemented

00:26:31,320 --> 00:26:35,789
it okay I'm not that smart okay you guys

00:26:34,289 --> 00:26:38,990
are probably much smarter than that and

00:26:35,789 --> 00:26:42,169
you can do that if you want so

00:26:38,990 --> 00:26:44,580
predictable memory consumption um

00:26:42,169 --> 00:26:46,289
transactional right ahead logs case of

00:26:44,580 --> 00:26:48,330
you familiar with how database systems

00:26:46,289 --> 00:26:50,159
tend to work and maybe you've worked

00:26:48,330 --> 00:26:52,740
with things like Cassandra for example

00:26:50,159 --> 00:26:55,530
these type of technologies use this kind

00:26:52,740 --> 00:26:58,679
of logging mechanism so in-place updates

00:26:55,530 --> 00:27:02,240
can be expensive all right so what you

00:26:58,679 --> 00:27:06,330
typically do is you append data to a log

00:27:02,240 --> 00:27:08,419
periodically you flush that as they call

00:27:06,330 --> 00:27:12,000
dirty pages you know they are persisted

00:27:08,419 --> 00:27:14,610
you free up log space okay and then

00:27:12,000 --> 00:27:17,010
you've got the ability to continue doing

00:27:14,610 --> 00:27:17,970
some additional processing one of the

00:27:17,010 --> 00:27:19,590
other benefits that provides

00:27:17,970 --> 00:27:21,120
instantaneous we thought well it

00:27:19,590 --> 00:27:23,669
probably defeats the laws of physics but

00:27:21,120 --> 00:27:25,650
it's very fast okay so because of this

00:27:23,669 --> 00:27:27,150
logging and other capabilities in the

00:27:25,650 --> 00:27:30,210
event that the cluster crashes for some

00:27:27,150 --> 00:27:31,559
reason or say part of it goes down it's

00:27:30,210 --> 00:27:34,169
very easy to bring it back up again

00:27:31,559 --> 00:27:36,539
because of these you know logging

00:27:34,169 --> 00:27:43,200
capabilities and other features that

00:27:36,539 --> 00:27:44,940
they've added okay

00:27:43,200 --> 00:27:49,309
compute great so this is one of the

00:27:44,940 --> 00:27:53,730
oldest components of ignite and

00:27:49,309 --> 00:27:56,220
typically then this type of approach if

00:27:53,730 --> 00:27:58,559
if you're familiar with fork/join you

00:27:56,220 --> 00:28:02,429
know MapReduce this is very very similar

00:27:58,559 --> 00:28:03,990
okay and again the capabilities here are

00:28:02,429 --> 00:28:05,549
very very important to the machine

00:28:03,990 --> 00:28:09,150
learning which we'll talk about very

00:28:05,549 --> 00:28:12,210
very shortly so here I mean all that's

00:28:09,150 --> 00:28:13,289
happening is all the standard things

00:28:12,210 --> 00:28:14,850
that you would expect in cluster

00:28:13,289 --> 00:28:16,260
computing such as load balancing

00:28:14,850 --> 00:28:18,330
automatic failure over all those

00:28:16,260 --> 00:28:20,490
guarantees are provided for you

00:28:18,330 --> 00:28:22,740
as jobs come in they're just broken down

00:28:20,490 --> 00:28:24,480
paralyzed based upon the resources that

00:28:22,740 --> 00:28:26,700
are available in the cluster in this

00:28:24,480 --> 00:28:28,919
case we happen to have two two servers

00:28:26,700 --> 00:28:32,250
of equal capability and equal processing

00:28:28,919 --> 00:28:34,289
power so this job is completed you know

00:28:32,250 --> 00:28:37,649
in time T divided by two okay because

00:28:34,289 --> 00:28:41,070
we're just parallelizing and then using

00:28:37,649 --> 00:28:43,289
those resources equally one very useful

00:28:41,070 --> 00:28:45,090
feature if you're a Java developer up

00:28:43,289 --> 00:28:48,269
there says zero deployment okay so

00:28:45,090 --> 00:28:51,389
ignite provides this ability it's called

00:28:48,269 --> 00:28:53,010
peer cross loading ok very useful be

00:28:51,389 --> 00:28:54,899
careful though you know with great power

00:28:53,010 --> 00:28:58,740
comes great responsibility

00:28:54,899 --> 00:29:01,799
so use it in testing systems by all

00:28:58,740 --> 00:29:04,580
means ok be careful in production

00:29:01,799 --> 00:29:07,289
systems ok so essentially what it is as

00:29:04,580 --> 00:29:09,779
you're modifying your java code rather

00:29:07,289 --> 00:29:11,370
than having to shut down the cluster and

00:29:09,779 --> 00:29:13,889
bring it back up again because your code

00:29:11,370 --> 00:29:15,899
has changed that code is automatically

00:29:13,889 --> 00:29:18,120
deployed for you it's automatically

00:29:15,899 --> 00:29:21,600
propagated to the servers they know what

00:29:18,120 --> 00:29:23,010
your new code does alright and in some

00:29:21,600 --> 00:29:24,840
situations you know in testing

00:29:23,010 --> 00:29:27,510
environments that's great because you

00:29:24,840 --> 00:29:28,950
may have sort of limited resources

00:29:27,510 --> 00:29:30,600
limited times you'll be able to achieve

00:29:28,950 --> 00:29:32,880
what what you need to achieve in

00:29:30,600 --> 00:29:34,649
production environments you don't want

00:29:32,880 --> 00:29:37,289
this necessarily to happen you know a

00:29:34,649 --> 00:29:40,139
simple mistake for example can have dire

00:29:37,289 --> 00:29:42,510
consequences for your cluster and just

00:29:40,139 --> 00:29:44,580
to give you a slight sort of tangential

00:29:42,510 --> 00:29:47,940
example not related to P R twice loading

00:29:44,580 --> 00:29:53,159
but an example from real life there is a

00:29:47,940 --> 00:29:57,450
customer using apache ignite a developer

00:29:53,159 --> 00:29:59,760
wrote some sequel code it set the

00:29:57,450 --> 00:30:02,100
balance of all customers to zero okay so

00:29:59,760 --> 00:30:04,529
their bank accounts you know that and

00:30:02,100 --> 00:30:06,659
that's a programming error now ignite

00:30:04,529 --> 00:30:09,149
can't won't stop you from doing that ok

00:30:06,659 --> 00:30:10,980
but there are checks and balances in

00:30:09,149 --> 00:30:12,600
development environments they will not

00:30:10,980 --> 00:30:14,549
follow the correct processes were not

00:30:12,600 --> 00:30:17,370
followed and unfortunately the live

00:30:14,549 --> 00:30:19,380
system someone wrote some sequel code to

00:30:17,370 --> 00:30:23,549
do this terrible thing ok

00:30:19,380 --> 00:30:25,860
customers not very happy ok so there are

00:30:23,549 --> 00:30:27,330
things like snapshots and disaster

00:30:25,860 --> 00:30:29,730
recovery which are kind of enterprise

00:30:27,330 --> 00:30:32,160
features okay so those are offered by

00:30:29,730 --> 00:30:34,350
grid gain so the the client happen

00:30:32,160 --> 00:30:35,520
to be using those capabilities so very

00:30:34,350 --> 00:30:37,530
quickly they realized what the problem

00:30:35,520 --> 00:30:39,960
was they were able to restore the system

00:30:37,530 --> 00:30:41,190
to a working state again okay so these

00:30:39,960 --> 00:30:42,720
things happen in real life you know

00:30:41,190 --> 00:30:44,580
we're human we make mistakes we are

00:30:42,720 --> 00:30:47,340
developers we don't always get

00:30:44,580 --> 00:30:50,240
everything right so something to beware

00:30:47,340 --> 00:30:53,640
of very useful but just beware of that

00:30:50,240 --> 00:30:55,350
okay so in terms of the actual machine

00:30:53,640 --> 00:30:59,180
learning grid then so last year this was

00:30:55,350 --> 00:31:02,640
in beta in released 2.4 it went GA and

00:30:59,180 --> 00:31:03,720
so what they provide is distributed core

00:31:02,640 --> 00:31:06,540
algebra ok

00:31:03,720 --> 00:31:09,330
Denson sparse algebra linear regression

00:31:06,540 --> 00:31:13,470
classification they will look at some of

00:31:09,330 --> 00:31:16,350
the examples very shortly at the moment

00:31:13,470 --> 00:31:19,580
there is obviously support for Java C++

00:31:16,350 --> 00:31:23,580
net there's a rest interface as well

00:31:19,580 --> 00:31:25,530
support for R and Python it's on the

00:31:23,580 --> 00:31:27,450
roadmap ok is Python is kind of moving

00:31:25,530 --> 00:31:29,640
along faster than our at the moment and

00:31:27,450 --> 00:31:32,280
if you were using things like tensorflow

00:31:29,640 --> 00:31:34,980
for example watch out for that hopefully

00:31:32,280 --> 00:31:37,500
coming in 2.6 okay that's a few months

00:31:34,980 --> 00:31:42,930
down the road but that integration will

00:31:37,500 --> 00:31:45,600
will come along all of the capabilities

00:31:42,930 --> 00:31:48,210
that Ignite provides for example using

00:31:45,600 --> 00:31:50,850
collocation using this kind of extra

00:31:48,210 --> 00:31:54,660
information that it has to help improve

00:31:50,850 --> 00:31:56,250
performance these distributed machine

00:31:54,660 --> 00:32:01,440
learning library can utilize that

00:31:56,250 --> 00:32:03,660
knowledge as well key thing to notice is

00:32:01,440 --> 00:32:05,400
that these algorithms have been written

00:32:03,660 --> 00:32:08,310
from the ground up to make use of

00:32:05,400 --> 00:32:09,750
ignites distributed capabilities there's

00:32:08,310 --> 00:32:12,450
nothing to stop you from using

00:32:09,750 --> 00:32:15,030
third-party libraries if you want you

00:32:12,450 --> 00:32:16,770
can do that but because ignite you know

00:32:15,030 --> 00:32:18,180
it sees them as a black box it cannot

00:32:16,770 --> 00:32:20,640
look inside to see the implementation

00:32:18,180 --> 00:32:23,430
they will just work on a single node

00:32:20,640 --> 00:32:25,530
okay with these machine learning library

00:32:23,430 --> 00:32:27,810
you have the option either you can run

00:32:25,530 --> 00:32:30,300
it locally or you can run it distributed

00:32:27,810 --> 00:32:32,760
entirely up to you okay the the choice

00:32:30,300 --> 00:32:34,260
is there based upon your needs based

00:32:32,760 --> 00:32:37,770
upon the use case whatever is the

00:32:34,260 --> 00:32:41,040
business case for doing so that's you

00:32:37,770 --> 00:32:43,140
know your choice and I he benefit no ETL

00:32:41,040 --> 00:32:45,060
now we don't have to extract the data

00:32:43,140 --> 00:32:45,710
out of the system to be able to use

00:32:45,060 --> 00:32:49,520
other to

00:32:45,710 --> 00:32:52,040
- enough train the data create models

00:32:49,520 --> 00:32:53,720
all of this can be done in place inside

00:32:52,040 --> 00:32:56,150
the system so all of the data that

00:32:53,720 --> 00:32:58,160
you're storing in there again creating

00:32:56,150 --> 00:33:01,370
these models and training the data that

00:32:58,160 --> 00:33:04,250
capability is built in all right now

00:33:01,370 --> 00:33:06,530
let's just take a step back and I'll

00:33:04,250 --> 00:33:09,340
show you some there's a couple of

00:33:06,530 --> 00:33:12,460
important things that they've added to

00:33:09,340 --> 00:33:15,560
how this machine learning works okay so

00:33:12,460 --> 00:33:17,600
we talked about key value okay so

00:33:15,560 --> 00:33:18,740
typically the way it stores it's an

00:33:17,600 --> 00:33:20,240
again if you're familiar with things

00:33:18,740 --> 00:33:21,920
like Redis or other key value type

00:33:20,240 --> 00:33:25,160
stores this should look very familiar so

00:33:21,920 --> 00:33:27,530
the idea is that with a key value you

00:33:25,160 --> 00:33:29,930
take the key you apply some hashing

00:33:27,530 --> 00:33:33,410
algorithm to it and then that gives you

00:33:29,930 --> 00:33:36,260
an address you know you have a space to

00:33:33,410 --> 00:33:38,960
be able to allocate you know which

00:33:36,260 --> 00:33:43,010
particular node that bit of data is

00:33:38,960 --> 00:33:45,050
stored on ignite obviously uses this

00:33:43,010 --> 00:33:47,180
notion of caches I may have mentioned

00:33:45,050 --> 00:33:49,670
that a few times already okay but think

00:33:47,180 --> 00:33:52,040
of a cache just like an aggregate a

00:33:49,670 --> 00:33:54,920
collection like perhaps the equivalent

00:33:52,040 --> 00:33:56,630
of a relational table for example the

00:33:54,920 --> 00:34:00,530
actual unit of storage there is a

00:33:56,630 --> 00:34:02,960
partition partitions are atomic okay

00:34:00,530 --> 00:34:05,240
they can't be broken down and then this

00:34:02,960 --> 00:34:08,300
is what actually gets stored on a server

00:34:05,240 --> 00:34:09,950
node alright and then typically then if

00:34:08,300 --> 00:34:11,900
we look at the big picture it's kind of

00:34:09,950 --> 00:34:14,300
like this okay so think of the cache as

00:34:11,900 --> 00:34:16,520
the outer container and then within that

00:34:14,300 --> 00:34:19,730
we have partitions and then we're

00:34:16,520 --> 00:34:21,620
actually storing you know the based upon

00:34:19,730 --> 00:34:23,420
the hashing algorithm that we applied to

00:34:21,620 --> 00:34:26,210
the key the values are actually going in

00:34:23,420 --> 00:34:29,510
a particular partition here we happen to

00:34:26,210 --> 00:34:31,730
have two of them okay stored and we

00:34:29,510 --> 00:34:33,410
might split this so that might be on one

00:34:31,730 --> 00:34:35,450
node that might be on another no it

00:34:33,410 --> 00:34:37,940
depends okay what sort of topology we've

00:34:35,450 --> 00:34:41,840
decided upon and how much data

00:34:37,940 --> 00:34:44,090
replication we want hey often I think

00:34:41,840 --> 00:34:45,950
within distributed environment it's not

00:34:44,090 --> 00:34:47,720
uncommon that you have like a primary

00:34:45,950 --> 00:34:50,570
copy of your data somewhere and then you

00:34:47,720 --> 00:34:52,070
have a backup copy in a separate part of

00:34:50,570 --> 00:34:54,710
the cluster so in the event that the

00:34:52,070 --> 00:34:56,930
primary goes down you know the backup is

00:34:54,710 --> 00:34:58,340
available it can help answer the kind of

00:34:56,930 --> 00:34:59,070
questions and queries that you want to

00:34:58,340 --> 00:35:01,050
do and

00:34:59,070 --> 00:35:06,060
that primary that went down can be

00:35:01,050 --> 00:35:07,710
replaced okay okay so backup copies so

00:35:06,060 --> 00:35:10,560
here we've got sort of four partitions

00:35:07,710 --> 00:35:13,170
very neatly organized on a four node

00:35:10,560 --> 00:35:15,480
cluster okay zero one two three and in

00:35:13,170 --> 00:35:18,480
this scenario then suppose we lose a

00:35:15,480 --> 00:35:21,440
node okay then all of that data is gone

00:35:18,480 --> 00:35:25,490
okay it's no longer available to us and

00:35:21,440 --> 00:35:30,150
therefore just creating these backups

00:35:25,490 --> 00:35:32,400
here we go okay other things so there is

00:35:30,150 --> 00:35:34,350
wrack awareness as well okay and some

00:35:32,400 --> 00:35:36,120
other sort of interesting things that

00:35:34,350 --> 00:35:38,400
you can do to ensure that you are not

00:35:36,120 --> 00:35:40,050
storing your backups in the same rack if

00:35:38,400 --> 00:35:42,870
the rack goes down you lose your backups

00:35:40,050 --> 00:35:44,910
as well um there's nothing to stop you

00:35:42,870 --> 00:35:47,370
making a backup of all your data on

00:35:44,910 --> 00:35:48,720
every node not very sensible

00:35:47,370 --> 00:35:51,000
particularly we've got large amounts of

00:35:48,720 --> 00:35:53,010
data but as I said typically in

00:35:51,000 --> 00:35:55,470
distributed environments it's fairly

00:35:53,010 --> 00:35:58,320
common I think you have a primary and a

00:35:55,470 --> 00:36:01,920
backup copy somewhere and with ignite

00:35:58,320 --> 00:36:03,450
there is no master okay in the sense of

00:36:01,920 --> 00:36:06,900
a master node or anything like that

00:36:03,450 --> 00:36:09,300
it's a peer-to-peer system okay yes

00:36:06,900 --> 00:36:11,640
there is a primary primary copy of the

00:36:09,300 --> 00:36:13,650
data okay there is a node that is

00:36:11,640 --> 00:36:15,840
responsible for that but they keep a

00:36:13,650 --> 00:36:17,810
backup copy somewhere else and then for

00:36:15,840 --> 00:36:20,280
example here in this scenario we've got

00:36:17,810 --> 00:36:22,950
primary and we've got backup copies in

00:36:20,280 --> 00:36:25,980
gray of these partitions in the event we

00:36:22,950 --> 00:36:28,680
lose one of these nodes then here we can

00:36:25,980 --> 00:36:32,400
see that we still have the data

00:36:28,680 --> 00:36:36,000
available that we've lost okay so quite

00:36:32,400 --> 00:36:38,600
a useful feature now the reason that I

00:36:36,000 --> 00:36:43,350
covered this specifically is because

00:36:38,600 --> 00:36:45,870
with this latest release of apache

00:36:43,350 --> 00:36:49,200
ignite they now provide this capability

00:36:45,870 --> 00:36:51,180
called partition based data sets okay

00:36:49,200 --> 00:36:53,430
it's quite a clever thing so it's it's

00:36:51,180 --> 00:36:56,520
like an abstraction layer that sits over

00:36:53,430 --> 00:36:58,380
the storage and computation and under

00:36:56,520 --> 00:37:00,180
the actual machine learning algorithm

00:36:58,380 --> 00:37:04,140
that you're trying to run so the

00:37:00,180 --> 00:37:05,880
thinking here is that often you know

00:37:04,140 --> 00:37:08,880
when you're working with machine

00:37:05,880 --> 00:37:12,090
learning algorithms many of them are

00:37:08,880 --> 00:37:14,340
kind of iterative okay and as

00:37:12,090 --> 00:37:17,460
it's iterative the context of what is

00:37:14,340 --> 00:37:19,590
actually working on changes alright so

00:37:17,460 --> 00:37:25,110
what this partition based dataset can do

00:37:19,590 --> 00:37:27,330
it can preserve that context if some

00:37:25,110 --> 00:37:29,580
part of your cluster goes down it

00:37:27,330 --> 00:37:33,290
doesn't mean that that job has to be

00:37:29,580 --> 00:37:35,220
abandoned okay it can recover based upon

00:37:33,290 --> 00:37:36,570
copies of the partitions that have been

00:37:35,220 --> 00:37:40,890
stored elsewhere there have been cached

00:37:36,570 --> 00:37:42,660
elsewhere okay so graphically we can

00:37:40,890 --> 00:37:44,490
kind of visualize it like this okay so

00:37:42,660 --> 00:37:47,100
these contexts and data so here we've

00:37:44,490 --> 00:37:49,410
got two nodes a node one has p1

00:37:47,100 --> 00:37:52,440
partition 1 and node 2 has got partition

00:37:49,410 --> 00:37:54,870
2 each of them have got context and data

00:37:52,440 --> 00:37:58,770
okay so as we may be doing some training

00:37:54,870 --> 00:38:02,910
ok it you yeah it says they reduce so

00:37:58,770 --> 00:38:05,970
it's it's MapReduce like okay it uses

00:38:02,910 --> 00:38:09,510
that kind of technology

00:38:05,970 --> 00:38:11,730
it isn't MapReduce per se ok so we can

00:38:09,510 --> 00:38:14,010
then apply this and then again because

00:38:11,730 --> 00:38:15,930
it's an iterative thing and things in

00:38:14,010 --> 00:38:17,910
machine learning will tend to work a

00:38:15,930 --> 00:38:19,680
little bit like this ok so in the event

00:38:17,910 --> 00:38:24,030
that there is a failure

00:38:19,680 --> 00:38:26,490
suppose that we lose mmm a partition on

00:38:24,030 --> 00:38:30,030
one of these nodes it can recover both

00:38:26,490 --> 00:38:32,930
the context and the data ok so very very

00:38:30,030 --> 00:38:37,320
useful and then I think particularly in

00:38:32,930 --> 00:38:39,060
distributed computing sometimes things

00:38:37,320 --> 00:38:43,500
are a little bit unpredictable ok there

00:38:39,060 --> 00:38:46,080
can be delays network outages hardware

00:38:43,500 --> 00:38:48,330
can fail and I think particularly if

00:38:46,080 --> 00:38:51,120
you're running these kind of algorithms

00:38:48,330 --> 00:38:54,210
over perhaps larger sets of data for

00:38:51,120 --> 00:38:56,310
which a parallelization and cluster

00:38:54,210 --> 00:38:57,780
computing makes sense then obviously if

00:38:56,310 --> 00:39:01,230
you've been running a job for say half

00:38:57,780 --> 00:39:02,730
an hour 45 minutes an hour and then you

00:39:01,230 --> 00:39:05,820
know something catastrophic happens

00:39:02,730 --> 00:39:07,410
you've lost your work ok so what this is

00:39:05,820 --> 00:39:10,860
trying to do is to really mitigate this

00:39:07,410 --> 00:39:12,780
and help the system to continue working

00:39:10,860 --> 00:39:14,160
despite the fact that some parts of your

00:39:12,780 --> 00:39:17,370
system have gone down because it

00:39:14,160 --> 00:39:21,630
preserves context and data ok it's very

00:39:17,370 --> 00:39:23,130
useful feature ok so in terms of what

00:39:21,630 --> 00:39:25,020
does it support then in terms of

00:39:23,130 --> 00:39:26,030
algorithms so I've just basically

00:39:25,020 --> 00:39:28,250
summarized

00:39:26,030 --> 00:39:30,230
so classification nearest-neighbor

00:39:28,250 --> 00:39:33,079
decision tree classification neural

00:39:30,230 --> 00:39:34,520
network regression linear regression

00:39:33,079 --> 00:39:37,280
decision tree regression nearest

00:39:34,520 --> 00:39:40,280
neighbor a neural network again for

00:39:37,280 --> 00:39:42,530
clustering k-means and there's some

00:39:40,280 --> 00:39:44,569
pre-processing normalization as well so

00:39:42,530 --> 00:39:48,260
the approach that they've taken with

00:39:44,569 --> 00:39:50,240
this is not to support hundreds of

00:39:48,260 --> 00:39:51,710
different types of algorithms so you've

00:39:50,240 --> 00:39:53,990
got a practical approach very much

00:39:51,710 --> 00:39:56,720
driven by the kind of problems that

00:39:53,990 --> 00:40:00,020
users see for real-world applications

00:39:56,720 --> 00:40:01,819
and I'm sure others will be added in

00:40:00,020 --> 00:40:04,510
time as there is enough demand and again

00:40:01,819 --> 00:40:07,579
remember because it's a community driven

00:40:04,510 --> 00:40:09,109
project it really depends on where the

00:40:07,579 --> 00:40:11,420
community feels the effort should go

00:40:09,109 --> 00:40:12,560
because even community driven projects

00:40:11,420 --> 00:40:14,089
resources are finite

00:40:12,560 --> 00:40:16,099
ok there's only a certain number of

00:40:14,089 --> 00:40:18,260
people that can work on the project and

00:40:16,099 --> 00:40:19,849
therefore things you have to take a

00:40:18,260 --> 00:40:21,140
decision to say what are the priorities

00:40:19,849 --> 00:40:24,710
what are the things that we really want

00:40:21,140 --> 00:40:28,819
to work on what the users really want ok

00:40:24,710 --> 00:40:31,430
so there is some level of support it's a

00:40:28,819 --> 00:40:32,990
very practical very pragmatic type of

00:40:31,430 --> 00:40:35,089
approach in terms of what they were

00:40:32,990 --> 00:40:36,619
offering today as I mentioned other

00:40:35,089 --> 00:40:38,960
things will come along as well you know

00:40:36,619 --> 00:40:40,940
better support for these type of data

00:40:38,960 --> 00:40:43,220
science type languages python and are in

00:40:40,940 --> 00:40:47,589
particular intensive flow as well which

00:40:43,220 --> 00:40:52,670
is coming along as well hopefully in 2.6

00:40:47,589 --> 00:40:54,950
ok so very quickly just show you a quick

00:40:52,670 --> 00:40:56,359
demo and then we'll just cover genetic

00:40:54,950 --> 00:40:58,130
algorithms very quickly a couple of

00:40:56,359 --> 00:41:00,140
slides on that and then we'll just wrap

00:40:58,130 --> 00:41:05,119
it up there so all I've done here is

00:41:00,140 --> 00:41:06,710
I've just downloaded the source there

00:41:05,119 --> 00:41:08,990
are binary versions of ignite as well

00:41:06,710 --> 00:41:11,900
but I happen to like getting the source

00:41:08,990 --> 00:41:17,030
I've loaded into into my IDE

00:41:11,900 --> 00:41:18,950
I built the project and with ignite they

00:41:17,030 --> 00:41:23,180
get they provide quite extensive

00:41:18,950 --> 00:41:24,920
examples of you know not just on the

00:41:23,180 --> 00:41:27,109
machine learning part but you know how

00:41:24,920 --> 00:41:29,569
to use the computed key value you know

00:41:27,109 --> 00:41:32,240
do put get operations how to create

00:41:29,569 --> 00:41:34,339
caches for example SQL examples okay so

00:41:32,240 --> 00:41:36,619
all of these are provided you can have a

00:41:34,339 --> 00:41:38,599
look at them in your own time and so for

00:41:36,619 --> 00:41:39,680
this particular one if we just zoom in a

00:41:38,599 --> 00:41:41,420
little bit here you see

00:41:39,680 --> 00:41:43,270
I'm working on a little bit of code here

00:41:41,420 --> 00:41:47,119
for the iris okay this is the

00:41:43,270 --> 00:41:48,650
classification problem but if we just go

00:41:47,119 --> 00:41:51,140
down over here and then I can just

00:41:48,650 --> 00:41:53,240
quickly show you some of the examples so

00:41:51,140 --> 00:41:56,240
here we can see you know they provide

00:41:53,240 --> 00:41:58,250
k-means clustering example now all of

00:41:56,240 --> 00:42:01,520
these in Java okay

00:41:58,250 --> 00:42:04,910
there's some Scala code as well in here

00:42:01,520 --> 00:42:06,200
but I don't think the c-plus puzzle

00:42:04,910 --> 00:42:09,760
donate comes as part of this

00:42:06,200 --> 00:42:13,430
distribution there are I think separate

00:42:09,760 --> 00:42:15,230
libraries available which again just

00:42:13,430 --> 00:42:17,089
ping me and I'll be able to trace those

00:42:15,230 --> 00:42:18,680
down for you okay

00:42:17,089 --> 00:42:20,270
notice here as well things like

00:42:18,680 --> 00:42:22,309
persistence stores service grade

00:42:20,270 --> 00:42:23,569
streaming okay so the examples that

00:42:22,309 --> 00:42:30,380
cover everything that we talked about

00:42:23,569 --> 00:42:31,880
today and as far as the particular

00:42:30,380 --> 00:42:34,309
algorithms here again you can have a

00:42:31,880 --> 00:42:36,829
looksie linear regression number of

00:42:34,309 --> 00:42:38,960
different types of trainers with

00:42:36,829 --> 00:42:40,520
normalization there you can see Titanic

00:42:38,960 --> 00:42:43,460
example something arriving just sort of

00:42:40,520 --> 00:42:48,650
working on in my time of the last couple

00:42:43,460 --> 00:42:53,720
of weeks as well so all of these bundled

00:42:48,650 --> 00:42:55,040
with the project it's nothing

00:42:53,720 --> 00:42:58,490
particularly exciting that I can show

00:42:55,040 --> 00:42:59,869
you that would although maybe we could

00:42:58,490 --> 00:43:03,020
we could do something like this for

00:42:59,869 --> 00:43:04,609
example so let's have a look one of the

00:43:03,020 --> 00:43:06,290
nice things about this is that

00:43:04,609 --> 00:43:07,869
particularly the mission machine

00:43:06,290 --> 00:43:11,240
learning the examples are standalone

00:43:07,869 --> 00:43:14,299
basically they will work without the

00:43:11,240 --> 00:43:16,369
need to fire up a cluster you can do

00:43:14,299 --> 00:43:18,859
that okay you can fire up a cluster

00:43:16,369 --> 00:43:20,359
directly within the IDE all right and

00:43:18,859 --> 00:43:23,000
then the way that the defaults are set

00:43:20,359 --> 00:43:24,859
up you can have a number of nodes up and

00:43:23,000 --> 00:43:27,680
running just depends on the resources of

00:43:24,859 --> 00:43:29,510
your machine how its configured and

00:43:27,680 --> 00:43:32,030
again you can run these examples if you

00:43:29,510 --> 00:43:34,250
want but for this particular one I can

00:43:32,030 --> 00:43:37,099
just run it straight from here and it's

00:43:34,250 --> 00:43:42,430
like a client application ok just fires

00:43:37,099 --> 00:43:47,349
up creates a cache load CSV data in

00:43:42,430 --> 00:43:50,540
stores that in the cache creates a model

00:43:47,349 --> 00:43:51,799
and then we could actually do some

00:43:50,540 --> 00:43:53,329
additional work with that multi-agency

00:43:51,799 --> 00:43:55,700
is pretty fast because it's

00:43:53,329 --> 00:44:00,559
not really taxing this particular system

00:43:55,700 --> 00:44:03,829
so in this case it's just giving me the

00:44:00,559 --> 00:44:06,650
ground truth predicted to sort of

00:44:03,829 --> 00:44:09,739
plaster versus what is the actual label

00:44:06,650 --> 00:44:13,219
for that classification example very

00:44:09,739 --> 00:44:14,630
straightforward alright so as I said

00:44:13,219 --> 00:44:16,640
before nothing particularly exciting I

00:44:14,630 --> 00:44:17,900
mean you know generally with this type

00:44:16,640 --> 00:44:20,209
of thing now you're probably wondering

00:44:17,900 --> 00:44:22,369
about things like visualization and you

00:44:20,209 --> 00:44:24,349
know if you work with things like Python

00:44:22,369 --> 00:44:26,269
matplotlib all these great libraries

00:44:24,349 --> 00:44:28,219
that you have available you can plot

00:44:26,269 --> 00:44:30,440
things they show you things in a visual

00:44:28,219 --> 00:44:33,890
way which is far more useful than just

00:44:30,440 --> 00:44:35,809
looking at code again adding these

00:44:33,890 --> 00:44:38,390
capabilities over time so what they've

00:44:35,809 --> 00:44:40,729
done this level is created the

00:44:38,390 --> 00:44:44,420
foundation if you like support for the

00:44:40,729 --> 00:44:46,519
algorithms next stages is to enhance

00:44:44,420 --> 00:44:48,950
those improve those add additional

00:44:46,519 --> 00:44:51,019
capabilities tensorflow is one of them

00:44:48,950 --> 00:44:52,969
but you know again give you the

00:44:51,019 --> 00:44:55,190
opportunities you're able to do far more

00:44:52,969 --> 00:44:57,410
useful things be able to create

00:44:55,190 --> 00:44:58,849
visualizations if you like and if again

00:44:57,410 --> 00:45:00,769
if you're thinking about GPU support as

00:44:58,849 --> 00:45:04,880
well again it's on the roadmap ok so

00:45:00,769 --> 00:45:09,650
these are things that are planned all

00:45:04,880 --> 00:45:12,019
right now couple of slides to go and

00:45:09,650 --> 00:45:14,420
then we and then we're done ok so let's

00:45:12,019 --> 00:45:16,609
have a look at genetic algorithms so

00:45:14,420 --> 00:45:17,749
when I started looking at this I didn't

00:45:16,609 --> 00:45:20,119
know anything about this so it's quite a

00:45:17,749 --> 00:45:22,369
kind of interesting thing so you know

00:45:20,119 --> 00:45:23,779
you have this notion of a population so

00:45:22,369 --> 00:45:26,119
what it's trying to do is just simulate

00:45:23,779 --> 00:45:28,849
biological evolution you have

00:45:26,119 --> 00:45:30,650
chromosomes chromosomes consist of genes

00:45:28,849 --> 00:45:32,900
ok and then you have a solution that

00:45:30,650 --> 00:45:34,430
you're trying to get to and then there's

00:45:32,900 --> 00:45:39,559
a kind of an evolution process you're

00:45:34,430 --> 00:45:44,479
modifying these genes to create new

00:45:39,559 --> 00:45:47,150
chromosomes very very interesting we

00:45:44,479 --> 00:45:49,279
need to kind of assess how good our

00:45:47,150 --> 00:45:52,539
model is all right so we there's this

00:45:49,279 --> 00:45:55,190
notion of a fitness calculation that we

00:45:52,539 --> 00:45:57,859
trying to there's some target that are

00:45:55,190 --> 00:46:00,199
trying to reach we do a calculation try

00:45:57,859 --> 00:46:02,089
to compare what we have currently with

00:46:00,199 --> 00:46:03,949
the target we're trying to get to have

00:46:02,089 --> 00:46:07,010
we reach the target now then we need to

00:46:03,949 --> 00:46:09,080
iterate again again iterative process ok

00:46:07,010 --> 00:46:13,520
crossover in mutation again these are

00:46:09,080 --> 00:46:15,350
covered in the documentation notice this

00:46:13,520 --> 00:46:18,260
example very similar to the compute

00:46:15,350 --> 00:46:19,850
example the computer that I showed you

00:46:18,260 --> 00:46:21,260
lived it early on very very similar sort

00:46:19,850 --> 00:46:22,850
of principle in terms of how this is

00:46:21,260 --> 00:46:24,859
actually working again same kind of

00:46:22,850 --> 00:46:27,609
notion using the parallel capabilities

00:46:24,859 --> 00:46:31,460
wherever possible co-located computation

00:46:27,609 --> 00:46:35,480
to good effects so where data are

00:46:31,460 --> 00:46:37,160
located and stored together ignite and

00:46:35,480 --> 00:46:38,920
utilize that knowledge to improve the

00:46:37,160 --> 00:46:41,780
performance and run things much faster

00:46:38,920 --> 00:46:44,060
and then typically the kind of the

00:46:41,780 --> 00:46:45,710
workflow that you use for something like

00:46:44,060 --> 00:46:48,770
this you know you start off with an

00:46:45,710 --> 00:46:50,840
initial kind of situation do some type

00:46:48,770 --> 00:46:54,710
of calculation you know have we reached

00:46:50,840 --> 00:46:57,020
our goal now if not select cross over

00:46:54,710 --> 00:46:59,930
mutate my apologies is just a little bit

00:46:57,020 --> 00:47:02,560
off the bottom there and if I maybe try

00:46:59,930 --> 00:47:04,910
and do this that might help there we go

00:47:02,560 --> 00:47:09,140
so there has to be some termination

00:47:04,910 --> 00:47:10,460
condition to be able to specify when we

00:47:09,140 --> 00:47:12,560
need to stop all right

00:47:10,460 --> 00:47:14,480
so there's about three or four examples

00:47:12,560 --> 00:47:16,010
that come with the machine learning

00:47:14,480 --> 00:47:18,590
libraries specifically on genetic

00:47:16,010 --> 00:47:20,060
algorithms useful for some types of

00:47:18,590 --> 00:47:22,340
complex problems again not all

00:47:20,060 --> 00:47:24,680
situations but could be very useful in

00:47:22,340 --> 00:47:28,130
certain scenarios and again that's

00:47:24,680 --> 00:47:31,000
something that you can have a look at so

00:47:28,130 --> 00:47:35,359
let me just switch back to the code here

00:47:31,000 --> 00:47:40,790
okay so as part of this sink let me have

00:47:35,359 --> 00:47:47,210
a look where are we here we go genetic

00:47:40,790 --> 00:47:48,800
okay just so there is the classic hello

00:47:47,210 --> 00:47:50,690
world example which is one of the

00:47:48,800 --> 00:47:52,910
articles that I actually took time to

00:47:50,690 --> 00:47:56,210
write on there's a couple of others here

00:47:52,910 --> 00:48:04,010
is it you can have a look at coin change

00:47:56,210 --> 00:48:09,400
movies so with this code I think we

00:48:04,010 --> 00:48:09,400
don't need a cluster running we can just

00:48:10,540 --> 00:48:15,460
yep just let me just shrink this down

00:48:17,270 --> 00:48:31,760
okay this one I just run it you see if

00:48:28,040 --> 00:48:33,860
that will work now the output I think is

00:48:31,760 --> 00:48:35,570
going to be a little bit crowded it's

00:48:33,860 --> 00:48:38,360
printing a lot of information messages

00:48:35,570 --> 00:48:42,320
okay so here it's literally doing the

00:48:38,360 --> 00:48:43,880
mutation calculating a fitness score and

00:48:42,320 --> 00:48:46,970
then just keep going keep going keep

00:48:43,880 --> 00:48:48,619
going keep going until it achieves the

00:48:46,970 --> 00:48:50,780
termination condition then just stops

00:48:48,619 --> 00:48:52,100
okay so this will keep going for a

00:48:50,780 --> 00:48:56,420
little while I think we're almost there

00:48:52,100 --> 00:48:59,630
it's two hundred and fifty seventy there

00:48:56,420 --> 00:49:01,580
we are so the last generation is 279

00:48:59,630 --> 00:49:03,950
where it's printed out some information

00:49:01,580 --> 00:49:06,230
to tell us that yep you know it's

00:49:03,950 --> 00:49:09,860
achieved its goal of hello world

00:49:06,230 --> 00:49:11,510
okay so again encourage you to have a

00:49:09,860 --> 00:49:13,520
look at that in your own time and one of

00:49:11,510 --> 00:49:16,070
the things that ignite provides as well

00:49:13,520 --> 00:49:19,310
is this web console okay so it's a very

00:49:16,070 --> 00:49:20,750
useful tool that allows you to look at

00:49:19,310 --> 00:49:22,910
the state of your cluster you know how

00:49:20,750 --> 00:49:25,250
much CPU usage what caches are there

00:49:22,910 --> 00:49:28,670
what resources are being utilized and

00:49:25,250 --> 00:49:30,440
you can actually execute SQL queries as

00:49:28,670 --> 00:49:32,240
well directly from that environment too

00:49:30,440 --> 00:49:34,880
and again one of the blog posts that

00:49:32,240 --> 00:49:37,250
I've I've written on the genetic

00:49:34,880 --> 00:49:39,140
algorithm which is on the grid gain

00:49:37,250 --> 00:49:40,730
website and on these own it shows you

00:49:39,140 --> 00:49:43,810
how to how to fire that up and and

00:49:40,730 --> 00:49:46,880
launch that can do that very very simply

00:49:43,810 --> 00:49:48,920
okay so I think I'm almost out of time

00:49:46,880 --> 00:49:53,359
I'm going to leave a couple of minutes

00:49:48,920 --> 00:49:56,540
for questions so we've done that all

00:49:53,359 --> 00:50:00,380
right so the key things here what ignite

00:49:56,540 --> 00:50:02,690
is trying to offer is the distributed

00:50:00,380 --> 00:50:04,460
machine learning deep learning when data

00:50:02,690 --> 00:50:06,830
do not fit within a single server unit

00:50:04,460 --> 00:50:09,230
so he gives you the benefit of utilizing

00:50:06,830 --> 00:50:13,030
cluster computing utilizing the

00:50:09,230 --> 00:50:17,450
resources available paralyze the work

00:50:13,030 --> 00:50:18,440
make things run faster zero ETL that was

00:50:17,450 --> 00:50:20,930
a problem in the past

00:50:18,440 --> 00:50:23,770
today everything can be done within

00:50:20,930 --> 00:50:26,720
ignite itself which is useful okay

00:50:23,770 --> 00:50:29,570
massive scalability so I think some of

00:50:26,720 --> 00:50:31,700
the largest ignite clusters out there

00:50:29,570 --> 00:50:35,390
Bank is a good example they've got lots

00:50:31,700 --> 00:50:39,500
and lots of clusters terabytes of RAM

00:50:35,390 --> 00:50:41,180
for each node and they've got some of

00:50:39,500 --> 00:50:43,880
the kind of commercial features that

00:50:41,180 --> 00:50:45,950
grid game provides well things like data

00:50:43,880 --> 00:50:47,480
center replication disaster recovery all

00:50:45,950 --> 00:50:49,760
these kind of capabilities as well so

00:50:47,480 --> 00:50:51,350
they've got a few of these around the

00:50:49,760 --> 00:50:53,420
world in the event that one of them gets

00:50:51,350 --> 00:50:55,790
knocked out it's okay you know the

00:50:53,420 --> 00:50:58,570
system will still work so the huge

00:50:55,790 --> 00:51:02,650
amounts of data being stored now with

00:50:58,570 --> 00:51:05,420
zookeeper added capability recently

00:51:02,650 --> 00:51:08,030
potentially your your clusters can scale

00:51:05,420 --> 00:51:09,980
to thousands of nodes if if that's what

00:51:08,030 --> 00:51:12,770
you want okay so massive scalability

00:51:09,980 --> 00:51:15,560
horizontal and vertical Ram plus disk

00:51:12,770 --> 00:51:20,990
okay so the ability to persist data okay

00:51:15,560 --> 00:51:23,810
which again can save state it can save a

00:51:20,990 --> 00:51:25,640
lot of time having to recover your

00:51:23,810 --> 00:51:27,700
system again because as you know you

00:51:25,640 --> 00:51:30,860
know when things are held in memory

00:51:27,700 --> 00:51:32,770
unless you have some kind of backup

00:51:30,860 --> 00:51:35,660
power supply or there is some other

00:51:32,770 --> 00:51:36,800
contingency that you've made if there is

00:51:35,660 --> 00:51:38,840
a catastrophic failure

00:51:36,800 --> 00:51:40,520
you know the cluster will collapse and

00:51:38,840 --> 00:51:42,860
it will go you know you have to provide

00:51:40,520 --> 00:51:45,650
some additional backup in these

00:51:42,860 --> 00:51:47,630
situations fault tolerance continuous

00:51:45,650 --> 00:51:49,370
learning partition based data said this

00:51:47,630 --> 00:51:52,340
is a kind of a new feature and very

00:51:49,370 --> 00:51:53,930
useful again because context changes a

00:51:52,340 --> 00:51:57,140
lot of machine algorithms are iterative

00:51:53,930 --> 00:51:59,840
we don't want to lose the work and even

00:51:57,140 --> 00:52:01,130
I think using modern technologies it can

00:51:59,840 --> 00:52:02,570
still take time you know if you're

00:52:01,130 --> 00:52:05,450
looking for things like conversions for

00:52:02,570 --> 00:52:08,900
example it can take a while you know

00:52:05,450 --> 00:52:11,270
even using parallel parallelism the

00:52:08,900 --> 00:52:13,640
resources of cluster computing you may

00:52:11,270 --> 00:52:17,480
have committed yourself to you know 15

00:52:13,640 --> 00:52:19,490
20 25 30 minutes of time that could be

00:52:17,480 --> 00:52:20,780
very valuable and I think particularly

00:52:19,490 --> 00:52:23,060
in the world that we live in today

00:52:20,780 --> 00:52:24,620
where business decisions have to be made

00:52:23,060 --> 00:52:27,890
very quickly people are looking for

00:52:24,620 --> 00:52:31,220
answers you know in in minutes and hours

00:52:27,890 --> 00:52:33,320
rather than weeks and in days as they

00:52:31,220 --> 00:52:36,730
did in the past because opportunities

00:52:33,320 --> 00:52:38,900
threats it's a very changed world so

00:52:36,730 --> 00:52:42,050
providing these capabilities I think

00:52:38,900 --> 00:52:43,520
really helps a lot of businesses okay

00:52:42,050 --> 00:52:45,680
great so I think we've got some

00:52:43,520 --> 00:52:47,900
time for some questions happy to answer

00:52:45,680 --> 00:52:49,670
I needed I can't if I can't answer

00:52:47,900 --> 00:52:52,280
anything I will be happy to follow up

00:52:49,670 --> 00:52:54,440
and provide you with the relevant

00:52:52,280 --> 00:52:57,650
information so I hope that was useful

00:52:54,440 --> 00:52:59,390
for you maybe you've learned a few

00:52:57,650 --> 00:53:01,460
things and if you're not familiar with

00:52:59,390 --> 00:53:03,680
Inc ignite you know even just knowing

00:53:01,460 --> 00:53:05,830
about it I've done my job okay so that's

00:53:03,680 --> 00:53:09,350
great I can tell my boss that you know

00:53:05,830 --> 00:53:10,730
20 people know that ignite that didn't

00:53:09,350 --> 00:53:14,030
know about it before so that's the key

00:53:10,730 --> 00:53:16,640
thing it's a fabulous project I think at

00:53:14,030 --> 00:53:18,590
Apache it amongst the top five most

00:53:16,640 --> 00:53:21,380
active projects both in terms of

00:53:18,590 --> 00:53:23,330
contribution and you know the activity

00:53:21,380 --> 00:53:25,550
on the user and dev lists which you can

00:53:23,330 --> 00:53:26,960
sign up to and they've got fabulous

00:53:25,550 --> 00:53:28,460
resources on there so people come along

00:53:26,960 --> 00:53:30,260
and I think there's actually people

00:53:28,460 --> 00:53:31,730
complaining inside goodgame saying why

00:53:30,260 --> 00:53:34,490
are you surprised providing such good

00:53:31,730 --> 00:53:36,080
support on the user in devils if

00:53:34,490 --> 00:53:38,990
customers should be paying us money for

00:53:36,080 --> 00:53:40,190
this but you know that's that's the

00:53:38,990 --> 00:53:44,150
quality of support that you're getting

00:53:40,190 --> 00:53:47,080
for this open source project okay great

00:53:44,150 --> 00:53:47,080
all right

00:53:48,000 --> 00:54:03,670
[Music]

00:54:03,099 --> 00:54:08,590
you

00:54:03,670 --> 00:54:08,590

YouTube URL: https://www.youtube.com/watch?v=tsxniR6BjIw


