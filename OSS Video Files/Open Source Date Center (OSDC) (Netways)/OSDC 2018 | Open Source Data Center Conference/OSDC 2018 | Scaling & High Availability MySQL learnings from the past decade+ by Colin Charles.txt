Title: OSDC 2018 | Scaling & High Availability MySQL learnings from the past decade+ by Colin Charles
Publication date: 2018-06-22
Playlist: OSDC 2018 | Open Source Data Center Conference
Description: 
	The MySQL world is full of tradeoffs and choosing a High Availability (HA) solution is no exception. This session aims to look at all of the alternatives in an unbiased nature. While the landscape will be covered, including but not limited to MySQL replication, MHA, DRBD, Galera Cluster, etc. the focus of the talk will be what is recommended for today, and what to look out for. Thus, this will include extensive deep-dive coverage of ProxySQL, semi-sync replication, Orchestrator, MySQL Router, and Galera Cluster variants like Percona XtraDB Cluster and MariaDB Galera Cluster. I will also touch on group replication.
Learn how we do this for our nearly 4000+ customers!

NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de
Blog: http://blog.netways.de
Webinare: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Google+: https://plus.google.com/+netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh

https://www.frametraxx.de/
Captions: 
	00:00:00,540 --> 00:00:03,369
[Music]

00:00:01,310 --> 00:00:03,369
you

00:00:11,750 --> 00:00:16,049
[Music]

00:00:13,099 --> 00:00:19,199
thank you good morning good afternoon

00:00:16,049 --> 00:00:23,789
now I'm here to talk to you about

00:00:19,199 --> 00:00:28,200
scaling and H a MySQL earnings MySQL is

00:00:23,789 --> 00:00:30,149
now just over 23 years old I presume all

00:00:28,200 --> 00:00:34,289
of you - some have used MySQL to some

00:00:30,149 --> 00:00:35,700
extent maybe an older version MySQL just

00:00:34,289 --> 00:00:39,809
released 8.0

00:00:35,700 --> 00:00:46,260
in April late April and Maria DB just

00:00:39,809 --> 00:00:49,430
released 10.3 in late May so 23 years of

00:00:46,260 --> 00:00:52,980
MySQL there's lots of things one can

00:00:49,430 --> 00:00:56,190
learn about do and I think it does one

00:00:52,980 --> 00:00:58,910
good takeaway from today is that the

00:00:56,190 --> 00:01:01,500
Internet may not always be accurate

00:00:58,910 --> 00:01:04,860
things change over time and there are

00:01:01,500 --> 00:01:09,299
always new best practices that come that

00:01:04,860 --> 00:01:09,810
evolve as as we move along so I work at

00:01:09,299 --> 00:01:14,219
percona

00:01:09,810 --> 00:01:16,289
and we make MySQL a percona server mysql

00:01:14,219 --> 00:01:19,280
as well as we make percona server

00:01:16,289 --> 00:01:22,619
MongoDB we do lots of support around

00:01:19,280 --> 00:01:25,439
marae DB server percona server mysql we

00:01:22,619 --> 00:01:28,170
make lots of open source tools and we

00:01:25,439 --> 00:01:32,340
just announced that as of June we will

00:01:28,170 --> 00:01:34,829
start also doing Postgres support we're

00:01:32,340 --> 00:01:36,840
not going to do a Postgres server but we

00:01:34,829 --> 00:01:38,909
are definitely going to make tools

00:01:36,840 --> 00:01:41,069
around it like we've always done

00:01:38,909 --> 00:01:43,920
and before that I was on the founding

00:01:41,069 --> 00:01:47,249
team of Murray a DB server and before

00:01:43,920 --> 00:01:48,689
that MySQL these slides are fully under

00:01:47,249 --> 00:01:50,399
the Creative Commons so you could

00:01:48,689 --> 00:01:56,669
totally make use of them they'll be

00:01:50,399 --> 00:02:02,609
available online later as well so MySQL

00:01:56,669 --> 00:02:05,819
55 spawned two variants Percona server 5

00:02:02,609 --> 00:02:09,630
5 as well as Murray DB 5 5 and then

00:02:05,819 --> 00:02:12,330
following that MySQL's 5 6 and 5 7 as

00:02:09,630 --> 00:02:14,670
well as 8 0 and only spawned picanha

00:02:12,330 --> 00:02:16,800
server variant which is meant to be a

00:02:14,670 --> 00:02:20,800
branch that's better for observability

00:02:16,800 --> 00:02:25,540
manageability and higher performance

00:02:20,800 --> 00:02:29,380
now for completeness Maria DB 10 0 10

00:02:25,540 --> 00:02:33,430
110 - as well as 10 3 are based on a my

00:02:29,380 --> 00:02:35,050
on the Maria DB 5 5 base but it adds

00:02:33,430 --> 00:02:37,900
other features so it cherry-picks

00:02:35,050 --> 00:02:40,260
features from my SQL so for all intents

00:02:37,900 --> 00:02:43,780
and purposes Maria DB is supposed to be

00:02:40,260 --> 00:02:46,780
kind of compatible to MySQL but not

00:02:43,780 --> 00:02:49,990
necessarily fully so good examples would

00:02:46,780 --> 00:02:52,000
be MySQL 5 6 introduced something called

00:02:49,990 --> 00:02:54,160
time delayed replication which means

00:02:52,000 --> 00:02:57,760
that you could have a replica that is

00:02:54,160 --> 00:02:59,500
delayed maybe by 2 hours 4 hours so if

00:02:57,760 --> 00:03:02,020
you're doing life pushes this this kind

00:02:59,500 --> 00:03:03,700
of thing it makes sense so in case

00:03:02,020 --> 00:03:05,290
someone makes a mistake to the schema

00:03:03,700 --> 00:03:06,820
you can always roll back without having

00:03:05,290 --> 00:03:09,040
to roll back the entire database just

00:03:06,820 --> 00:03:11,740
point to a new point to a delayed

00:03:09,040 --> 00:03:15,010
replica however that's all the feature

00:03:11,740 --> 00:03:17,530
only came to Moorea DB server 10.2 and

00:03:15,010 --> 00:03:20,250
that was quite a big gap in terms of

00:03:17,530 --> 00:03:24,940
timing so one was released in 2013 and

00:03:20,250 --> 00:03:27,910
10.2 was released in 2017 also things

00:03:24,940 --> 00:03:29,830
like streaming binary log backups when

00:03:27,910 --> 00:03:34,450
you want to do automatic failover so

00:03:29,830 --> 00:03:36,910
provisioning new machine new slaves that

00:03:34,450 --> 00:03:40,709
also basically only came to marae db10 -

00:03:36,910 --> 00:03:43,450
but was present in mysql 5 6 so it's

00:03:40,709 --> 00:03:46,840
probably important note what mysql or

00:03:43,450 --> 00:03:48,820
mariadb you end up using because many

00:03:46,840 --> 00:03:52,780
linux distributions with the exception

00:03:48,820 --> 00:03:55,390
of Ubuntu is shipping Maria DB as your

00:03:52,780 --> 00:03:58,720
default MySQL so typically if you use

00:03:55,390 --> 00:04:02,950
Santo a7 or l7 you've got Maria DB 5 5

00:03:58,720 --> 00:04:08,020
and MySQL and MariaDB are quite

00:04:02,950 --> 00:04:09,600
different nowadays so what is high

00:04:08,020 --> 00:04:14,140
availability

00:04:09,600 --> 00:04:16,540
largely it has a lot to do with gaining

00:04:14,140 --> 00:04:19,570
good performance but at the same time

00:04:16,540 --> 00:04:22,540
also being scalable and we tend to

00:04:19,570 --> 00:04:25,330
measure scalability in the mysql world

00:04:22,540 --> 00:04:27,669
by a throughput we do that via

00:04:25,330 --> 00:04:30,310
transactions per second if you come from

00:04:27,669 --> 00:04:32,710
a more commercial database world you may

00:04:30,310 --> 00:04:34,639
think of transactions per minute but we

00:04:32,710 --> 00:04:38,120
we go down to size

00:04:34,639 --> 00:04:39,560
typically latency is something else that

00:04:38,120 --> 00:04:41,570
is well worth looking at and this is

00:04:39,560 --> 00:04:46,639
response time and we measure this in

00:04:41,570 --> 00:04:49,700
percentiles MySQL if you use in ODB is

00:04:46,639 --> 00:04:54,320
an acid compliant database how many of

00:04:49,700 --> 00:04:58,310
you here do not use in ODB okay so you

00:04:54,320 --> 00:05:00,350
don't what do you use oh but you extra

00:04:58,310 --> 00:05:03,050
DV okay yeah actually V is a drop-in

00:05:00,350 --> 00:05:07,220
replacement for in a DV okay excellent

00:05:03,050 --> 00:05:10,790
so you know Sims 5.5 in ODB has been the

00:05:07,220 --> 00:05:13,610
default default storage engine for MySQL

00:05:10,790 --> 00:05:17,360
so it is such that you have acid

00:05:13,610 --> 00:05:19,940
compliance as a default the D in acid is

00:05:17,360 --> 00:05:22,820
durability and this basically means you

00:05:19,940 --> 00:05:24,860
never ever lose comma data so the other

00:05:22,820 --> 00:05:25,940
ways to also ensure you are durable when

00:05:24,860 --> 00:05:28,190
you're thinking about a high

00:05:25,940 --> 00:05:31,570
availability stack is that you may also

00:05:28,190 --> 00:05:34,639
think of replicas so you don't only have

00:05:31,570 --> 00:05:37,490
one slave you have multiple slaves or

00:05:34,639 --> 00:05:39,530
replicas emails think of snapshots so

00:05:37,490 --> 00:05:42,080
maybe you make snapshots of said

00:05:39,530 --> 00:05:44,750
replicas maybe vide the MySQL bin log

00:05:42,080 --> 00:05:47,210
utility maybe you also think about point

00:05:44,750 --> 00:05:49,280
in time recovery as well as backups via

00:05:47,210 --> 00:05:51,229
something like Percona extra backup so

00:05:49,280 --> 00:05:53,120
you can get backups

00:05:51,229 --> 00:05:55,760
whereas MySQL dump will give you more

00:05:53,120 --> 00:06:00,140
logical backup you can get point in time

00:05:55,760 --> 00:06:01,610
backups with Percona extra backup and

00:06:00,140 --> 00:06:03,200
then you also think about it from a

00:06:01,610 --> 00:06:06,260
replication standpoint to ensure that

00:06:03,200 --> 00:06:08,030
you have redundancy and then from a

00:06:06,260 --> 00:06:10,760
clustering standpoint and not to be

00:06:08,030 --> 00:06:13,460
confused with mysql NDB cluster you also

00:06:10,760 --> 00:06:16,220
think about monitoring as well as

00:06:13,460 --> 00:06:18,650
recovery and failover time failover time

00:06:16,220 --> 00:06:20,750
is definitely something that's extremely

00:06:18,650 --> 00:06:24,770
important and the whole purpose of

00:06:20,750 --> 00:06:26,930
having a high availability stack is to

00:06:24,770 --> 00:06:31,400
ensure that you have no single point of

00:06:26,930 --> 00:06:34,340
failure being 23 years old we have many

00:06:31,400 --> 00:06:37,610
many solutions out there so of course

00:06:34,340 --> 00:06:40,160
you've got stock mysql which with the

00:06:37,610 --> 00:06:42,919
8-0 release has created something called

00:06:40,160 --> 00:06:45,470
mysql in a DV cluster that comes with a

00:06:42,919 --> 00:06:48,169
group replication and a few a few other

00:06:45,470 --> 00:06:51,319
fancy bells and whistles you've got

00:06:48,169 --> 00:06:53,240
on a server which has extra DB and a

00:06:51,319 --> 00:06:55,430
whole bunch of other things you've got

00:06:53,240 --> 00:06:58,849
Maria DB which comes now built in with

00:06:55,430 --> 00:07:01,249
Galera cluster as well then you've got

00:06:58,849 --> 00:07:04,909
percona X DB cluster with with tons of

00:07:01,249 --> 00:07:07,189
engineering going behind it to make it a

00:07:04,909 --> 00:07:09,800
better Galera a more stable Galera

00:07:07,189 --> 00:07:12,289
you've got things like dr BD which

00:07:09,800 --> 00:07:15,229
allows you to have synchronous

00:07:12,289 --> 00:07:19,069
replication on the block layer itself as

00:07:15,229 --> 00:07:21,589
opposed to using MySQL replication use

00:07:19,069 --> 00:07:23,659
block layer application on on the Nexus

00:07:21,589 --> 00:07:25,729
side you've got things like tungsten

00:07:23,659 --> 00:07:27,610
replicate several lines is something

00:07:25,729 --> 00:07:30,289
called cluster control we will talk a

00:07:27,610 --> 00:07:32,749
bit about the piccola toolkit tools that

00:07:30,289 --> 00:07:35,330
could be handy DV deployer

00:07:32,749 --> 00:07:37,129
which previously was MySQL sandbox and

00:07:35,330 --> 00:07:41,240
despite a storage engine which allows

00:07:37,129 --> 00:07:43,999
you to shard your data using SQL now

00:07:41,240 --> 00:07:46,129
included as part of Maria DB 10.3 so you

00:07:43,999 --> 00:07:47,900
can shot and recharge your data with the

00:07:46,129 --> 00:07:50,569
vertical partitioning storage engine and

00:07:47,900 --> 00:07:54,050
sharding your data is part of how you

00:07:50,569 --> 00:07:56,839
become scalable in the mysql world you

00:07:54,050 --> 00:08:00,169
can't store all your data effectively on

00:07:56,839 --> 00:08:02,719
just one instance you'll probably have

00:08:00,169 --> 00:08:06,169
to shut your data either via users and

00:08:02,719 --> 00:08:09,620
number of users maybe 400 users Prashad

00:08:06,169 --> 00:08:11,810
or you will shard them based on locality

00:08:09,620 --> 00:08:14,240
and so forth and and the other caveat of

00:08:11,810 --> 00:08:16,789
sharding the sharding part is easy the

00:08:14,240 --> 00:08:18,710
recharging part is the hard part where

00:08:16,789 --> 00:08:21,889
you need to actually rebalance users

00:08:18,710 --> 00:08:25,009
maybe there's five percent of users on

00:08:21,889 --> 00:08:26,629
one shard are extremely active and they

00:08:25,009 --> 00:08:29,899
need to be rebalanced to another to

00:08:26,629 --> 00:08:32,890
another shot and rishaad is something

00:08:29,899 --> 00:08:37,640
that we need to think a lot more about

00:08:32,890 --> 00:08:40,669
so when it comes to uptime you know

00:08:37,640 --> 00:08:42,529
everyone wants five nines up times so

00:08:40,669 --> 00:08:45,260
they believe that you should never be

00:08:42,529 --> 00:08:47,240
done any longer than five minutes in a

00:08:45,260 --> 00:08:52,089
whole year now how many of you actually

00:08:47,240 --> 00:08:59,839
achieve five nines uptime for sure

00:08:52,089 --> 00:09:01,939
yep measured okay so so a lot of people

00:08:59,839 --> 00:09:04,059
believe that yes five nines I

00:09:01,939 --> 00:09:07,429
excellent but uh you know Pingdom

00:09:04,059 --> 00:09:09,229
anybody here used Pingdom okay so

00:09:07,429 --> 00:09:10,819
Pingdom releases statistics from time to

00:09:09,229 --> 00:09:12,649
time because lots of people tend to use

00:09:10,819 --> 00:09:14,749
them and even here there are fraction of

00:09:12,649 --> 00:09:17,889
people that do use them and Pingdom

00:09:14,749 --> 00:09:21,220
actually says that generally speaking

00:09:17,889 --> 00:09:23,629
only a fraction get past three nines a

00:09:21,220 --> 00:09:26,769
lot a lot of people tend to have a lot

00:09:23,629 --> 00:09:30,349
of downtime not a lot of downtime a

00:09:26,769 --> 00:09:33,079
reasonable amount three nines is to just

00:09:30,349 --> 00:09:34,999
eight hours of downtime per year which

00:09:33,079 --> 00:09:39,949
is not even an hour of downtime per

00:09:34,999 --> 00:09:41,629
month when you do a downtime at scale

00:09:39,949 --> 00:09:44,239
you measure in the thousands of hours

00:09:41,629 --> 00:09:45,949
because a simple failure does not

00:09:44,239 --> 00:09:47,509
trigger ops to come back because there

00:09:45,949 --> 00:09:49,309
should be a replicated copy of the data

00:09:47,509 --> 00:09:51,979
serving just fine and you may already

00:09:49,309 --> 00:09:54,859
have an automated solution to promote a

00:09:51,979 --> 00:09:57,399
failed master have us have a new slave

00:09:54,859 --> 00:10:01,609
being promoted to the new master state

00:09:57,399 --> 00:10:05,479
so simple replication be it asynchronous

00:10:01,609 --> 00:10:10,369
or should be giving you anywhere between

00:10:05,479 --> 00:10:12,229
98 to three nines uptime using a

00:10:10,369 --> 00:10:14,599
sand-witch is definitely not a

00:10:12,229 --> 00:10:16,009
recommended solution for MySQL should

00:10:14,599 --> 00:10:17,959
also give you about three nines about

00:10:16,009 --> 00:10:20,449
time not recommended because you don't

00:10:17,959 --> 00:10:24,589
gain much in terms of uptime and you

00:10:20,449 --> 00:10:27,499
lose a lot in terms of of cost using

00:10:24,589 --> 00:10:29,959
something like dr BD or MHA should give

00:10:27,499 --> 00:10:31,729
you also about three nines uptime give

00:10:29,959 --> 00:10:34,609
or take but with something like

00:10:31,729 --> 00:10:36,109
MHA and semi synchronous replication you

00:10:34,609 --> 00:10:39,049
should be able to go up to five lines

00:10:36,109 --> 00:10:41,209
uptime and using something like NDB

00:10:39,049 --> 00:10:43,669
cluster of commonly known as MySQL

00:10:41,209 --> 00:10:46,129
cluster which is in the seven-point X

00:10:43,669 --> 00:10:48,079
release phase or Galera cluster or MySQL

00:10:46,129 --> 00:10:51,799
InnoDB cluster I should also be able to

00:10:48,079 --> 00:10:54,109
give you five nines uptime we won't talk

00:10:51,799 --> 00:10:57,019
much about NDB cluster today because it

00:10:54,109 --> 00:11:00,019
is called a very nice use case typically

00:10:57,019 --> 00:11:01,669
in the telco spaces and I'm willing to

00:11:00,019 --> 00:11:06,979
guess nobody here uses NDB cluster

00:11:01,669 --> 00:11:10,009
generally speaking anyway a che is a lot

00:11:06,979 --> 00:11:12,079
about redundancy mmm you you already

00:11:10,009 --> 00:11:13,429
thinking in a che from any other parts

00:11:12,079 --> 00:11:16,460
of your system as well

00:11:13,429 --> 00:11:18,500
you have raid four disks

00:11:16,460 --> 00:11:21,080
as you want to ensure that even if a

00:11:18,500 --> 00:11:23,660
discos you always got something else you

00:11:21,080 --> 00:11:30,140
have clustering for your servers because

00:11:23,660 --> 00:11:33,620
servers do go down many many data center

00:11:30,140 --> 00:11:35,510
like hardware you can buy today will

00:11:33,620 --> 00:11:38,510
have multiple redundant power supplies

00:11:35,510 --> 00:11:41,870
he doesn't only come with just one in

00:11:38,510 --> 00:11:45,640
fact most 1u servers even come with more

00:11:41,870 --> 00:11:48,410
than one network interface card and

00:11:45,640 --> 00:11:51,380
generally speaking from a geographical

00:11:48,410 --> 00:11:53,030
standpoint you can get a situation where

00:11:51,380 --> 00:11:54,860
your data center goes offline always

00:11:53,030 --> 00:11:58,280
destroyed and then you send computation

00:11:54,860 --> 00:12:03,350
to another data center now typically

00:11:58,280 --> 00:12:06,320
this translates to natural disasters

00:12:03,350 --> 00:12:08,210
right so a couple of years ago downtown

00:12:06,320 --> 00:12:10,760
Manhattan in New York got flooded

00:12:08,210 --> 00:12:12,620
because of a massive hurricane that

00:12:10,760 --> 00:12:14,630
passed by and that would mean that a

00:12:12,620 --> 00:12:16,700
bunch of services in New York stopped

00:12:14,630 --> 00:12:18,860
working but that doesn't mean your

00:12:16,700 --> 00:12:21,130
services can stop working because you're

00:12:18,860 --> 00:12:24,980
probably losing money

00:12:21,130 --> 00:12:26,720
another personal example would be I like

00:12:24,980 --> 00:12:28,670
to use an American Express card and I

00:12:26,720 --> 00:12:31,010
landed in Seoul once and it just

00:12:28,670 --> 00:12:33,260
wouldn't work and it was thought my

00:12:31,010 --> 00:12:35,420
cards fault it was the fault of the fact

00:12:33,260 --> 00:12:38,870
that Samsung had a data center go up in

00:12:35,420 --> 00:12:42,740
flames so for one whole week the AMAC

00:12:38,870 --> 00:12:45,260
services in South Korea were down and it

00:12:42,740 --> 00:12:47,060
had nothing to do with Amex not being

00:12:45,260 --> 00:12:50,690
working but it was to do with a data

00:12:47,060 --> 00:12:52,670
center going up in flames and externally

00:12:50,690 --> 00:12:55,280
that affected people who had a Samsung

00:12:52,670 --> 00:12:58,550
Smart TV your TVs were maybe a little

00:12:55,280 --> 00:13:00,800
Dumber that day and if you had the

00:12:58,550 --> 00:13:04,510
Samsung phones with the S chat service

00:13:00,800 --> 00:13:07,280
the S chat service also stopped working

00:13:04,510 --> 00:13:10,400
so as I mentioned earlier durability is

00:13:07,280 --> 00:13:12,070
extremely important not only should you

00:13:10,400 --> 00:13:14,540
care about the data being stored on disk

00:13:12,070 --> 00:13:16,850
you also need to care that the data is

00:13:14,540 --> 00:13:18,500
actually being written to disk that

00:13:16,850 --> 00:13:21,410
means you actually call as saying each

00:13:18,500 --> 00:13:25,250
and every time a comment is made now a

00:13:21,410 --> 00:13:27,680
lot of people try to make benchmarks by

00:13:25,250 --> 00:13:29,680
turning off F sync this means your

00:13:27,680 --> 00:13:32,709
database is extremely fast

00:13:29,680 --> 00:13:34,779
but it's also extremely unreliable so

00:13:32,709 --> 00:13:37,689
making making benchmarks by turning off

00:13:34,779 --> 00:13:40,119
F sync is definitely great for marketing

00:13:37,689 --> 00:13:42,490
so bench marketing but it's not good for

00:13:40,119 --> 00:13:44,769
actual benchmarking now if you ever

00:13:42,490 --> 00:13:46,540
wanted to turn off F sing I don't know

00:13:44,769 --> 00:13:50,439
how many of you have ever heard of a

00:13:46,540 --> 00:13:52,509
library called live eat my data so live

00:13:50,439 --> 00:13:54,910
eating my data is a great way for you to

00:13:52,509 --> 00:13:56,529
run say the MySQL test suite for example

00:13:54,910 --> 00:13:59,649
because the MySQL tests we can take an

00:13:56,529 --> 00:14:03,100
hour to run and also is is very harsh on

00:13:59,649 --> 00:14:05,170
you SSDs but if you run leave in my data

00:14:03,100 --> 00:14:07,449
it doesn't call a sink and speeds up

00:14:05,170 --> 00:14:09,910
everything maybe by even 10 X to some

00:14:07,449 --> 00:14:12,160
extent so of course you don't run

00:14:09,910 --> 00:14:14,740
production environments only beat my

00:14:12,160 --> 00:14:18,009
data but on Linux this is packaged in

00:14:14,740 --> 00:14:20,379
most distributions and highly useful for

00:14:18,009 --> 00:14:22,329
you if you wanted to have a test what

00:14:20,379 --> 00:14:26,980
it's like to run without I've sync any

00:14:22,329 --> 00:14:29,709
application really without a sink so we

00:14:26,980 --> 00:14:31,209
also need to ensure as part of acid that

00:14:29,709 --> 00:14:33,160
it must be returned in a transactional

00:14:31,209 --> 00:14:34,740
way to guarantee the atomicity the crash

00:14:33,160 --> 00:14:38,139
safety as well as the integrity of data

00:14:34,740 --> 00:14:40,269
now calling I've seen each and every

00:14:38,139 --> 00:14:43,709
time you make a you make a commute is

00:14:40,269 --> 00:14:48,480
extremely expensive this is why

00:14:43,709 --> 00:14:50,800
databases since Marini v53 and mysql 5.6

00:14:48,480 --> 00:14:53,529
have something known as a group comment

00:14:50,800 --> 00:14:55,300
in the binary log this basically means

00:14:53,529 --> 00:14:57,639
and you don't have to turn this on this

00:14:55,300 --> 00:14:59,139
just works by default this basically

00:14:57,639 --> 00:15:02,620
means that you can turn on this option

00:14:59,139 --> 00:15:05,769
sync bin log equals 1 in Ruby flash log

00:15:02,620 --> 00:15:08,170
a transaction commit equals 1 and if you

00:15:05,769 --> 00:15:10,089
have multiple parallel queries so

00:15:08,170 --> 00:15:12,790
typically more than three three running

00:15:10,089 --> 00:15:14,589
queries you'll benefit from root comma

00:15:12,790 --> 00:15:18,970
in the binary log automatically because

00:15:14,589 --> 00:15:26,379
it actually commits it as one group one

00:15:18,970 --> 00:15:28,540
F sync as opposed to say 3 F syncs H is

00:15:26,379 --> 00:15:30,399
definitely harder for databases largely

00:15:28,540 --> 00:15:32,529
because you need to make sure that not

00:15:30,399 --> 00:15:35,170
only your harder resources are redundant

00:15:32,529 --> 00:15:37,689
but your data is redundant as well and

00:15:35,170 --> 00:15:39,040
you also want to ensure that you your

00:15:37,689 --> 00:15:43,630
operations was continued uninterrupted

00:15:39,040 --> 00:15:46,149
and H a is definitely not oh my services

00:15:43,630 --> 00:15:47,529
I'd like to restore from a backup that's

00:15:46,149 --> 00:15:49,810
not highly that's not being highly

00:15:47,529 --> 00:15:51,399
available you want to be offering

00:15:49,810 --> 00:15:52,870
uninterrupted services that I've

00:15:51,399 --> 00:15:54,819
measured in percentiles that we talked

00:15:52,870 --> 00:15:56,500
about earlier you never want to say oh

00:15:54,819 --> 00:15:58,600
I'll be down for the next few hours

00:15:56,500 --> 00:16:04,209
that's that's insane you lose money

00:15:58,600 --> 00:16:08,949
every second possibly now all that many

00:16:04,209 --> 00:16:16,180
Java developers in the room know wow I'm

00:16:08,949 --> 00:16:17,889
impressed so the Java people came up

00:16:16,180 --> 00:16:20,560
with this idea called client-side X a

00:16:17,889 --> 00:16:22,209
transactions largely because Java DB in

00:16:20,560 --> 00:16:25,120
the early days probably did not do

00:16:22,209 --> 00:16:27,250
replication now this is a is a nice idea

00:16:25,120 --> 00:16:30,220
in theory where your client writes a two

00:16:27,250 --> 00:16:32,980
independent but identical databases but

00:16:30,220 --> 00:16:34,120
it's a extremely bad idea in production

00:16:32,980 --> 00:16:38,170
because you can get out of sync

00:16:34,120 --> 00:16:40,060
databases extremely quickly so nice idea

00:16:38,170 --> 00:16:42,160
but not something you should totally do

00:16:40,060 --> 00:16:43,870
this is of course not to be confused

00:16:42,160 --> 00:16:45,399
with server-side Aksai transactions

00:16:43,870 --> 00:16:47,560
which are okay unless you're using

00:16:45,399 --> 00:16:49,089
something like Galera cluster service I

00:16:47,560 --> 00:16:51,910
excite transactions are extremely

00:16:49,089 --> 00:16:54,910
important so this is a this is something

00:16:51,910 --> 00:17:00,699
you never should do even even today even

00:16:54,910 --> 00:17:02,290
though they have libraries for void so

00:17:00,699 --> 00:17:05,740
remember earlier what I said about how

00:17:02,290 --> 00:17:08,799
paradigms change I think that's really

00:17:05,740 --> 00:17:09,970
the takeaway from from today I don't

00:17:08,799 --> 00:17:12,459
know how many of you are running say

00:17:09,970 --> 00:17:16,000
MySQL five five over corner server 5 5

00:17:12,459 --> 00:17:18,699
is anybody still running 5 5 ok quite a

00:17:16,000 --> 00:17:22,059
handful of you but paradigms have have

00:17:18,699 --> 00:17:23,919
totally changed right so the you know TV

00:17:22,059 --> 00:17:25,799
log file size you set this the larger

00:17:23,919 --> 00:17:28,209
you set it the longer your recovery time

00:17:25,799 --> 00:17:30,789
more than 10 years ago Wikipedia

00:17:28,209 --> 00:17:33,429
themselves reported with a small amount

00:17:30,789 --> 00:17:35,799
of log files 756 Meg's of logs you take

00:17:33,429 --> 00:17:37,299
them 40 minutes but sometimes you take 5

00:17:35,799 --> 00:17:39,940
to 10 minutes now that's

00:17:37,299 --> 00:17:41,740
non-deterministic right how do you go

00:17:39,940 --> 00:17:43,870
from 5 to 10 minutes the 40 minutes to

00:17:41,740 --> 00:17:47,530
sometimes hours that's because log

00:17:43,870 --> 00:17:49,510
recovery involves involves the ability

00:17:47,530 --> 00:17:51,220
for you to actually need to find the

00:17:49,510 --> 00:17:52,540
Check Point time because it has fuzzy

00:17:51,220 --> 00:17:54,730
checkpointing when you need to find a

00:17:52,540 --> 00:17:56,919
log sequence number when you go to scan

00:17:54,730 --> 00:17:57,580
the log files basically from the last

00:17:56,919 --> 00:17:59,350
checkpoint

00:17:57,580 --> 00:18:00,850
and then you're good to see it has

00:17:59,350 --> 00:18:02,530
already been applied to those pages or

00:18:00,850 --> 00:18:05,140
not I'm not you have to perform

00:18:02,530 --> 00:18:07,930
operations in terms of applying changes

00:18:05,140 --> 00:18:09,820
to the buffer pool so basically your

00:18:07,930 --> 00:18:12,610
data locality your size of logs your

00:18:09,820 --> 00:18:15,280
buffer pool size your dirty buffers

00:18:12,610 --> 00:18:18,460
during the crash of InnoDB all will play

00:18:15,280 --> 00:18:21,220
a role in terms of recovery time this is

00:18:18,460 --> 00:18:23,860
just kind of awful because you you want

00:18:21,220 --> 00:18:25,990
more predictability in your services so

00:18:23,860 --> 00:18:27,130
Percona server five five actually did

00:18:25,990 --> 00:18:28,750
include something called literally be

00:18:27,130 --> 00:18:31,420
recovery stat so you actually tells you

00:18:28,750 --> 00:18:34,600
what it's been doing and you know gives

00:18:31,420 --> 00:18:36,370
you some sort of a progress report but

00:18:34,600 --> 00:18:39,040
today I'd say paradigms have totally

00:18:36,370 --> 00:18:39,430
changed because you don't do this any

00:18:39,040 --> 00:18:41,440
longer

00:18:39,430 --> 00:18:44,830
nowadays you have plenty of replicas

00:18:41,440 --> 00:18:46,540
lying around but even if you end up

00:18:44,830 --> 00:18:48,190
having a crash it probably makes no

00:18:46,540 --> 00:18:50,410
difference because when the machine is

00:18:48,190 --> 00:18:52,150
crashed you've taken it out out of the

00:18:50,410 --> 00:18:54,070
cluster so to speak and there's

00:18:52,150 --> 00:18:55,240
something else has taken over for you so

00:18:54,070 --> 00:18:57,940
you don't have to worry about any of you

00:18:55,240 --> 00:19:01,440
recovery time any longer but this is a

00:18:57,940 --> 00:19:03,730
big deal when five five came out and

00:19:01,440 --> 00:19:05,680
probably still a big deal during the

00:19:03,730 --> 00:19:07,450
five six times but nowadays with the

00:19:05,680 --> 00:19:08,980
ability for you to provision in the

00:19:07,450 --> 00:19:11,530
cloud the ability for you to have

00:19:08,980 --> 00:19:14,230
multiple redundant redundant machines

00:19:11,530 --> 00:19:20,950
nobody cares so much about recovery time

00:19:14,230 --> 00:19:22,390
anymore so as I mentioned earlier

00:19:20,950 --> 00:19:24,070
there's the ability for you to have

00:19:22,390 --> 00:19:26,530
redundancy through shared storage and

00:19:24,070 --> 00:19:29,470
the sands are extremely complex to

00:19:26,530 --> 00:19:32,110
operate they extremely expensive this

00:19:29,470 --> 00:19:33,970
isn't the scale out solution that we

00:19:32,110 --> 00:19:36,220
like to talk about in the MySQL roll

00:19:33,970 --> 00:19:40,090
this is a scale-up solution so don't do

00:19:36,220 --> 00:19:43,210
this there's also redundancy to disk

00:19:40,090 --> 00:19:46,900
replication dr BD is described as raid

00:19:43,210 --> 00:19:48,940
over ethernet and probably the only good

00:19:46,900 --> 00:19:52,060
reason for you to use dr BD today for

00:19:48,940 --> 00:19:55,330
mysql and not trust mysql application is

00:19:52,060 --> 00:19:56,880
because you were used to a san di b t--

00:19:55,330 --> 00:19:59,260
could probably be so useful to you

00:19:56,880 --> 00:20:01,210
however if you think you cannot lose a

00:19:59,260 --> 00:20:03,280
transaction and semi synchronous

00:20:01,210 --> 00:20:05,910
replication or even fully synchronous

00:20:03,280 --> 00:20:09,690
replication would not suffice for you

00:20:05,910 --> 00:20:10,820
then maybe you could use the RVD still

00:20:09,690 --> 00:20:14,000
but

00:20:10,820 --> 00:20:16,700
speaking you have reduced single-mode

00:20:14,000 --> 00:20:18,919
performance when you are using dr BD it

00:20:16,700 --> 00:20:23,210
is so days days a day is a trade-off you

00:20:18,919 --> 00:20:26,809
have higher average latencies and there

00:20:23,210 --> 00:20:33,679
is one service out that uses this how

00:20:26,809 --> 00:20:36,620
many of you use AWS RDS okay so no not

00:20:33,679 --> 00:20:38,409
as many as I was expecting nobody likes

00:20:36,620 --> 00:20:42,590
the cloud here

00:20:38,409 --> 00:20:44,899
okay so AWS RDS has this thing called a

00:20:42,590 --> 00:20:47,750
multi AC option and they do make use of

00:20:44,899 --> 00:20:50,690
dr BD but they don't give you a live

00:20:47,750 --> 00:20:53,120
replica but they but because of dr BD

00:20:50,690 --> 00:20:56,210
you actually pay 50% extra costs but you

00:20:53,120 --> 00:20:57,980
have it's highly available but it's not

00:20:56,210 --> 00:21:00,500
necessarily something that would

00:20:57,980 --> 00:21:02,090
actually be useful in terms of a reed

00:21:00,500 --> 00:21:04,429
replica and they're about the only

00:21:02,090 --> 00:21:07,850
people today that still use dr BD for

00:21:04,429 --> 00:21:09,799
MySQL MySQL by itself has got good

00:21:07,850 --> 00:21:11,690
replication nowadays robust replication

00:21:09,799 --> 00:21:13,340
is excellent and then don't forget the

00:21:11,690 --> 00:21:18,950
semi synchronous as well as fully

00:21:13,340 --> 00:21:20,360
synchronous replication so redundancy

00:21:18,950 --> 00:21:22,610
through MySQL replication

00:21:20,360 --> 00:21:24,620
we've got standard MySQL replication

00:21:22,610 --> 00:21:26,809
which we'll talk about probably in the

00:21:24,620 --> 00:21:28,399
next slide or two we've got something

00:21:26,809 --> 00:21:30,980
called tungsten replicator this is an

00:21:28,399 --> 00:21:33,139
interesting piece of software that was

00:21:30,980 --> 00:21:35,539
once owned by a company called continued

00:21:33,139 --> 00:21:38,720
and purchased by VMware spun out from

00:21:35,539 --> 00:21:42,429
vmware continuent and is still around

00:21:38,720 --> 00:21:44,929
not sure how they keep on surviving the

00:21:42,429 --> 00:21:47,720
technology was extremely useful back in

00:21:44,929 --> 00:21:49,820
the day today it's it's probably the

00:21:47,720 --> 00:21:52,639
best use case is for you to do

00:21:49,820 --> 00:21:54,080
heterogeneous environment replication so

00:21:52,639 --> 00:21:56,629
if you want to replicate between say

00:21:54,080 --> 00:21:58,700
MySQL and Oracle and you don't want to

00:21:56,629 --> 00:22:01,220
pay for golden gate tungsten probably

00:21:58,700 --> 00:22:03,409
make sense for you and and the version

00:22:01,220 --> 00:22:07,039
that you you could use is apache license

00:22:03,409 --> 00:22:08,539
as well so they have open source version

00:22:07,039 --> 00:22:11,029
apache license and an Enterprise version

00:22:08,539 --> 00:22:13,460
the Enterprise version helps you put

00:22:11,029 --> 00:22:16,190
stuff across multiple data centers you

00:22:13,460 --> 00:22:18,830
probably don't need that but generally

00:22:16,190 --> 00:22:20,269
speaking tungsten heterogeneous

00:22:18,830 --> 00:22:22,760
applications probably it's only good use

00:22:20,269 --> 00:22:24,530
case now and this Galera cluster and

00:22:22,760 --> 00:22:25,850
MySQL in a DB cluster both

00:22:24,530 --> 00:22:28,550
which will probably have plenty of

00:22:25,850 --> 00:22:31,550
slides for and these are both based on a

00:22:28,550 --> 00:22:34,700
similar paper written out of a

00:22:31,550 --> 00:22:36,140
university in Portugal about how one

00:22:34,700 --> 00:22:40,000
could do fully synchronous replication

00:22:36,140 --> 00:22:44,540
with optimistic concurrency control and

00:22:40,000 --> 00:22:46,670
writing to basically in ODB and also

00:22:44,540 --> 00:22:48,590
MySQL cluster NDB cluster as I said

00:22:46,670 --> 00:22:51,160
again not something we will be focusing

00:22:48,590 --> 00:22:54,620
on because it's really a telco thing

00:22:51,160 --> 00:22:56,660
naturally speaking with replication your

00:22:54,620 --> 00:23:00,430
Sarge requirements are multiplied but

00:22:56,660 --> 00:23:00,430
you have huge potential for scaling out

00:23:01,660 --> 00:23:06,740
MySQL replication for the longest time

00:23:04,970 --> 00:23:10,370
has been statement based generally

00:23:06,740 --> 00:23:13,070
however row base became the default in

00:23:10,370 --> 00:23:15,260
five seven and going forward we expect

00:23:13,070 --> 00:23:17,030
more and more people to only be

00:23:15,260 --> 00:23:18,670
interested in row based replication as

00:23:17,030 --> 00:23:22,850
opposed to statement based replication

00:23:18,670 --> 00:23:24,710
now saving based replication basically

00:23:22,850 --> 00:23:26,540
takes the state when you enter onto the

00:23:24,710 --> 00:23:29,690
master and then apply sense statement

00:23:26,540 --> 00:23:32,420
again onto the slave or all sets of

00:23:29,690 --> 00:23:35,590
slaves and this could occasionally lead

00:23:32,420 --> 00:23:37,790
to inconsistencies especially if you

00:23:35,590 --> 00:23:41,030
basically use things like the current

00:23:37,790 --> 00:23:44,300
user or user function or you used UDF

00:23:41,030 --> 00:23:46,760
and so forth now for some reason

00:23:44,300 --> 00:23:49,310
Mariya DB has chosen to focus on using

00:23:46,760 --> 00:23:52,250
mix mode replication by default so yes

00:23:49,310 --> 00:23:55,820
MySQL and MariaDB support statement row

00:23:52,250 --> 00:23:57,260
and mix mode so the default in Moorea DB

00:23:55,820 --> 00:23:58,430
is mixed mode and probably something you

00:23:57,260 --> 00:24:00,710
should change the moment you've

00:23:58,430 --> 00:24:03,080
configured Maria DB switch it to row

00:24:00,710 --> 00:24:08,150
based application because it's generally

00:24:03,080 --> 00:24:10,790
much better overall high score

00:24:08,150 --> 00:24:14,750
application is fully asynchronous by

00:24:10,790 --> 00:24:18,230
default that means a master will get a

00:24:14,750 --> 00:24:20,780
commit and then it will continue saying

00:24:18,230 --> 00:24:22,850
okay to receiving more comments and

00:24:20,780 --> 00:24:25,460
telling the application you could send

00:24:22,850 --> 00:24:27,800
more stuff over without guaranteeing

00:24:25,460 --> 00:24:30,380
that any slave has received this now

00:24:27,800 --> 00:24:32,780
this is great because it's fast it's

00:24:30,380 --> 00:24:34,850
easy to set up but it's also bad because

00:24:32,780 --> 00:24:37,740
if the mast happens to crash you've lost

00:24:34,850 --> 00:24:39,779
data till the master comes back up again

00:24:37,740 --> 00:24:45,059
so this is so this means you're

00:24:39,779 --> 00:24:47,460
extremely reliant on said master so you

00:24:45,059 --> 00:24:50,429
always want to ensure that the master

00:24:47,460 --> 00:24:54,000
basically ensures a slave has also

00:24:50,429 --> 00:24:55,980
received and processed it this is where

00:24:54,000 --> 00:24:57,929
a semi synchronous comes into play it's

00:24:55,980 --> 00:25:00,750
a semi synchronous replication came in

00:24:57,929 --> 00:25:03,390
in five five as a plugin it's gotten

00:25:00,750 --> 00:25:07,559
better in five seven because of a way

00:25:03,390 --> 00:25:10,260
you basically write commit data to the

00:25:07,559 --> 00:25:12,360
storage engine and then you've also got

00:25:10,260 --> 00:25:15,570
Sammy sink again in eight zero

00:25:12,360 --> 00:25:17,429
Maria db10 two and ten three have more

00:25:15,570 --> 00:25:19,380
modern Sam using replication that

00:25:17,429 --> 00:25:20,490
matches what you find in five seven and

00:25:19,380 --> 00:25:23,570
eight zero as well

00:25:20,490 --> 00:25:26,309
so Sammy synchronous replication is

00:25:23,570 --> 00:25:29,909
basically what polish the whole Internet

00:25:26,309 --> 00:25:33,210
today if you look at top 20 website

00:25:29,909 --> 00:25:36,659
listing and if you look at them that run

00:25:33,210 --> 00:25:38,220
basically MySQL you will be remissed to

00:25:36,659 --> 00:25:41,159
find out that pretty much all of them

00:25:38,220 --> 00:25:43,620
run MySQL with Sam using replications

00:25:41,159 --> 00:25:47,789
are done this includes the Google's the

00:25:43,620 --> 00:25:49,529
YouTube's to Facebook's Wikipedia you

00:25:47,789 --> 00:25:51,720
can actually go and take a look see as

00:25:49,529 --> 00:25:53,669
they are infrastructure because

00:25:51,720 --> 00:25:56,460
Wikipedia tends to open up the data yeah

00:25:53,669 --> 00:25:58,830
data structure for anybody to see and so

00:25:56,460 --> 00:26:03,240
forth so large websites are powered by

00:25:58,830 --> 00:26:05,480
semi sink overall and of course a lot of

00:26:03,240 --> 00:26:08,760
people like this idea that you can get

00:26:05,480 --> 00:26:10,620
fully synchronous replication and fully

00:26:08,760 --> 00:26:14,399
synchronous replication is something

00:26:10,620 --> 00:26:18,720
that definitely is available via cholera

00:26:14,399 --> 00:26:20,730
cluster or Percona xdb cluster and it's

00:26:18,720 --> 00:26:24,059
also available via something new called

00:26:20,730 --> 00:26:25,860
MySQL in a DV cluster which alongside 8

00:26:24,059 --> 00:26:29,669
that 0 will combine the like sub group

00:26:25,860 --> 00:26:31,080
replication in a DB and a star storage

00:26:29,669 --> 00:26:33,929
back-end and then using something called

00:26:31,080 --> 00:26:36,440
MySQL SH for maintaining it and then the

00:26:33,929 --> 00:26:39,830
MySQL router for load balancing purposes

00:26:36,440 --> 00:26:41,730
so this is also a fairly interesting

00:26:39,830 --> 00:26:43,980
tangent when it comes to high

00:26:41,730 --> 00:26:45,570
availability because you've got Oracle

00:26:43,980 --> 00:26:48,179
backing this thing called group

00:26:45,570 --> 00:26:51,179
replication and in DV cluster you've got

00:26:48,179 --> 00:26:55,139
Maria DB backing Galera cluster

00:26:51,179 --> 00:26:58,979
and group replication will not work with

00:26:55,139 --> 00:27:01,830
Maria DB at all but Galera cluster does

00:26:58,979 --> 00:27:03,899
work with MySQL so this leaves percona

00:27:01,830 --> 00:27:05,339
server for mysql five seven and eight

00:27:03,899 --> 00:27:08,729
zero in a very interesting position

00:27:05,339 --> 00:27:10,440
because Percona is putting lots of money

00:27:08,729 --> 00:27:13,619
behind actually be cluster which is

00:27:10,440 --> 00:27:16,139
Galera cluster but you can also continue

00:27:13,619 --> 00:27:18,629
using the group replication plug-in with

00:27:16,139 --> 00:27:20,369
percona service so this is the picanha

00:27:18,629 --> 00:27:24,409
server sitting sitting in the middle

00:27:20,369 --> 00:27:27,029
that allows you to either use Galera or

00:27:24,409 --> 00:27:32,549
group replication and it can also help

00:27:27,029 --> 00:27:35,339
you maybe migrate between the two so as

00:27:32,549 --> 00:27:37,049
I mentioned earlier semi synchronous

00:27:35,339 --> 00:27:37,529
replication is really what Paul is the

00:27:37,049 --> 00:27:39,809
Internet

00:27:37,529 --> 00:27:41,700
and you realize that the enhanced I'm

00:27:39,809 --> 00:27:43,229
using replication basically is a thread

00:27:41,700 --> 00:27:44,969
that performs the transaction commute on

00:27:43,229 --> 00:27:47,219
the master it'll block after the commute

00:27:44,969 --> 00:27:49,559
is done and then wait until at least

00:27:47,219 --> 00:27:51,599
once I'm using slave acknowledges they

00:27:49,559 --> 00:27:56,099
received all events of the transaction

00:27:51,599 --> 00:27:58,049
or until a time odd does occur and if

00:27:56,099 --> 00:28:00,450
you are finding that there are too many

00:27:58,049 --> 00:28:02,879
timeouts occurring the master can revert

00:28:00,450 --> 00:28:04,859
to asynchronous replication as well and

00:28:02,879 --> 00:28:09,389
then resume when the slaves catch up and

00:28:04,859 --> 00:28:12,929
at scale back in 2014 already Yoshinori

00:28:09,389 --> 00:28:15,570
much suitable who is a DBA at Facebook

00:28:12,929 --> 00:28:19,889
wrote how they use semi sync in

00:28:15,570 --> 00:28:21,659
production and again it's no secret that

00:28:19,889 --> 00:28:23,239
Google around semi sync in production

00:28:21,659 --> 00:28:25,379
because they were actually the

00:28:23,239 --> 00:28:28,799
originators of the semi synchronous

00:28:25,379 --> 00:28:30,299
patch to MySQL back in the 5.0 days so

00:28:28,799 --> 00:28:35,429
if you look at the MySQL patches for

00:28:30,299 --> 00:28:39,710
Google you'll find them so replication

00:28:35,429 --> 00:28:41,809
in five six and this is when I think

00:28:39,710 --> 00:28:45,269
replication started becoming extremely

00:28:41,809 --> 00:28:47,339
interesting and different and and the

00:28:45,269 --> 00:28:50,190
reason why I've included five six is

00:28:47,339 --> 00:28:52,169
because there are some things here that

00:28:50,190 --> 00:28:57,539
maybe Maria D we did not quite inherit

00:28:52,169 --> 00:28:59,669
as well global transaction IDs extremely

00:28:57,539 --> 00:29:01,889
useful because it means that throughout

00:28:59,669 --> 00:29:04,139
your entire application topology each

00:29:01,889 --> 00:29:05,389
and every transaction is assigned a

00:29:04,139 --> 00:29:09,709
unique identifier

00:29:05,389 --> 00:29:11,029
for it this would make automatic failure

00:29:09,709 --> 00:29:13,729
was very quick because you can just

00:29:11,029 --> 00:29:15,529
compare global transaction ID numbers

00:29:13,729 --> 00:29:20,089
and then just say I'd like to replicate

00:29:15,529 --> 00:29:21,919
from this GT ID number in MySQL but not

00:29:20,089 --> 00:29:25,459
Maria Divi you have this concept of a

00:29:21,919 --> 00:29:29,239
server UUID unique use identifier every

00:29:25,459 --> 00:29:31,879
server in MySQL has this as well the

00:29:29,239 --> 00:29:34,429
ability for you to do filtering so you

00:29:31,879 --> 00:29:38,259
can ignore cell IDs and do have

00:29:34,429 --> 00:29:40,309
replication filters exist as well

00:29:38,259 --> 00:29:42,919
multi-threaded slaves are in a per

00:29:40,309 --> 00:29:44,809
schema basis up our database basis

00:29:42,919 --> 00:29:46,339
Murray divvy does this a little

00:29:44,809 --> 00:29:48,229
differently in the sense that they'll

00:29:46,339 --> 00:29:51,199
allow you on a per table basis

00:29:48,229 --> 00:29:53,989
so a bit more granular group coming in

00:29:51,199 --> 00:29:58,549
the binary log is basically what allows

00:29:53,989 --> 00:30:01,969
MySQL to run in acid durable fashion

00:29:58,549 --> 00:30:05,529
today having binary log checksums event

00:30:01,969 --> 00:30:05,529
checksum is extremely useful because

00:30:05,709 --> 00:30:10,429
imagine if you were just replicating

00:30:07,879 --> 00:30:12,079
from master to slave but you never

00:30:10,429 --> 00:30:13,639
actually check to see if what you

00:30:12,079 --> 00:30:16,369
received from the master was correct

00:30:13,639 --> 00:30:17,989
maybe you had corruption via network via

00:30:16,369 --> 00:30:21,079
the network card and so forth

00:30:17,989 --> 00:30:23,119
if the checksum fails this is a great

00:30:21,079 --> 00:30:25,189
reason why replication should stop

00:30:23,119 --> 00:30:27,619
because you should not be replicating

00:30:25,189 --> 00:30:29,449
garbage because if you replicate garbage

00:30:27,619 --> 00:30:32,599
and you need to do a failover

00:30:29,449 --> 00:30:36,229
well you've you failed over to basically

00:30:32,599 --> 00:30:37,999
garbage and that's not good this is also

00:30:36,229 --> 00:30:39,979
very similar to you know people doing

00:30:37,999 --> 00:30:42,079
backups so I don't know how many of you

00:30:39,979 --> 00:30:43,599
around when a service called Magnolia I

00:30:42,079 --> 00:30:46,309
used to exist

00:30:43,599 --> 00:30:47,349
Magnolia was was the competitor to

00:30:46,309 --> 00:30:49,489
delicious

00:30:47,349 --> 00:30:51,289
now delicious is something you probably

00:30:49,489 --> 00:30:53,419
don't even remember because you know

00:30:51,289 --> 00:30:55,429
Yahoo bought them and then Yahoo sold

00:30:53,419 --> 00:31:02,179
them anything that goes through Yahoo

00:30:55,429 --> 00:31:04,039
kind of so maybe pinboard is is now the

00:31:02,179 --> 00:31:07,069
social bookmarking platform of choice

00:31:04,039 --> 00:31:09,349
but Magnolia actually died largely

00:31:07,069 --> 00:31:11,179
because they were doing backups

00:31:09,349 --> 00:31:14,359
they were running replication you're

00:31:11,179 --> 00:31:17,599
running backups not via MySQL dump or

00:31:14,359 --> 00:31:18,950
extra backup they're running backups via

00:31:17,599 --> 00:31:22,630
our syncing the data

00:31:18,950 --> 00:31:29,690
directory for MySQL - another machine

00:31:22,630 --> 00:31:32,750
they thought they had a backup but but

00:31:29,690 --> 00:31:35,330
little do they know that they were well

00:31:32,750 --> 00:31:36,760
their backup was garbage so it didn't

00:31:35,330 --> 00:31:41,440
work for them

00:31:36,760 --> 00:31:41,440
so yeah don't rsync your data directory

00:31:43,480 --> 00:31:48,200
also the binary log is not crash safe I

00:31:46,639 --> 00:31:50,059
think this is extremely important

00:31:48,200 --> 00:31:51,440
because previously would be started in

00:31:50,059 --> 00:31:53,779
the data directory now it's part of it

00:31:51,440 --> 00:31:55,610
it's a part of an inner DB table time

00:31:53,779 --> 00:31:57,860
delayed replication again very useful

00:31:55,610 --> 00:32:03,799
for everyone doing all these life pushes

00:31:57,860 --> 00:32:05,210
nowadays and also peril replication so

00:32:03,799 --> 00:32:06,529
replication starts transaction with

00:32:05,210 --> 00:32:09,380
consistent snapshot now this is

00:32:06,529 --> 00:32:14,919
available in mysql 5-7 percona server 5

00:32:09,380 --> 00:32:18,380
6 & 7 & maria DB 5 3 and greater and

00:32:14,919 --> 00:32:20,840
basically the announcement allows you to

00:32:18,380 --> 00:32:24,110
make binary log positions consistent

00:32:20,840 --> 00:32:25,760
within ODB transaction snapshots this

00:32:24,110 --> 00:32:27,649
feature is definitely useful if you're

00:32:25,760 --> 00:32:29,510
trying to obtain a logical back up with

00:32:27,649 --> 00:32:32,510
correct positions without having to run

00:32:29,510 --> 00:32:36,130
a flash tables with read lock the binary

00:32:32,510 --> 00:32:38,690
log position can then we obtained via

00:32:36,130 --> 00:32:40,909
several newly implemented status

00:32:38,690 --> 00:32:43,220
variables typically they are bin log

00:32:40,909 --> 00:32:45,620
snapshot file and bin log snapshot

00:32:43,220 --> 00:32:47,210
position so basically after you saw a

00:32:45,620 --> 00:32:49,639
transaction with start transaction with

00:32:47,210 --> 00:32:52,220
consistent snapshot these two variables

00:32:49,639 --> 00:32:54,080
will now provide you the binary log

00:32:52,220 --> 00:32:56,510
position that was corresponding to the

00:32:54,080 --> 00:32:59,000
state of the database for the consistent

00:32:56,510 --> 00:33:01,190
snapshot to be taken irrespective of

00:32:59,000 --> 00:33:03,559
which or any other transactions that

00:33:01,190 --> 00:33:07,130
have been committed to it after the

00:33:03,559 --> 00:33:08,990
snapshot was taken and this actually is

00:33:07,130 --> 00:33:11,539
become a by-product of proof commit in

00:33:08,990 --> 00:33:14,480
the binary log this also enables you to

00:33:11,539 --> 00:33:18,580
do MySQL dump signal transaction master

00:33:14,480 --> 00:33:22,220
data and you get a full non-blocking

00:33:18,580 --> 00:33:24,019
logical backup and of course this also

00:33:22,220 --> 00:33:25,880
works consistently between transactions

00:33:24,019 --> 00:33:28,429
involving more than one storage engine

00:33:25,880 --> 00:33:30,019
though typically this is not something

00:33:28,429 --> 00:33:32,899
most people do because you tend to just

00:33:30,019 --> 00:33:35,059
run in a DV though this is import

00:33:32,899 --> 00:33:37,519
because going forward there are there

00:33:35,059 --> 00:33:39,619
are other storage engines some Maria DB

00:33:37,519 --> 00:33:42,109
of course has the arias are ejected for

00:33:39,619 --> 00:33:43,879
temporary tables now it's the my rock

00:33:42,109 --> 00:33:46,609
storage engine generally available in

00:33:43,879 --> 00:33:49,909
10.3 / kadhai server has also got you

00:33:46,609 --> 00:33:51,440
know taki DB like maria DB has as well

00:33:49,909 --> 00:33:53,089
as my rock

00:33:51,440 --> 00:33:55,609
so my rocks is probably a very hot

00:33:53,089 --> 00:33:58,339
engine because it's based on rocks DB

00:33:55,609 --> 00:34:01,789
it's got its it's a log structured merge

00:33:58,339 --> 00:34:04,879
tree and it allows you to you know do

00:34:01,789 --> 00:34:06,889
fast inserts and has a great compression

00:34:04,879 --> 00:34:08,510
and the reason why it probably be very

00:34:06,889 --> 00:34:11,329
hot is because pretty much all of

00:34:08,510 --> 00:34:15,980
facebook runs on it now as opposed to in

00:34:11,329 --> 00:34:18,260
ODB and that's where the ability to do

00:34:15,980 --> 00:34:20,750
work consistently between more than one

00:34:18,260 --> 00:34:22,339
storage it might make sense for Coronas

00:34:20,750 --> 00:34:26,539
server has one additional improvement

00:34:22,339 --> 00:34:29,659
such that you can also see session IDs

00:34:26,539 --> 00:34:32,119
and then so you can actually just take a

00:34:29,659 --> 00:34:33,649
backup based on session IDs and then you

00:34:32,119 --> 00:34:36,679
can also has backup locks which is

00:34:33,649 --> 00:34:39,109
something that extra DBS had by extra DB

00:34:36,679 --> 00:34:40,970
and extra backup can make yourself so

00:34:39,109 --> 00:34:46,730
you don't have to make a large amount of

00:34:40,970 --> 00:34:49,399
backup you just backup lock so multi

00:34:46,730 --> 00:34:51,529
social application this actually first

00:34:49,399 --> 00:34:53,899
came from tungsten replicator then it

00:34:51,529 --> 00:34:57,859
came to maria luisa was contributed by

00:34:53,899 --> 00:35:01,880
Taba Alibaba and then it also came to

00:34:57,859 --> 00:35:04,010
MySQL five seven and of course the

00:35:01,880 --> 00:35:06,829
syntax differences between the MySQL and

00:35:04,010 --> 00:35:08,630
MariaDB variant and again you need to

00:35:06,829 --> 00:35:12,470
generally think about using global

00:35:08,630 --> 00:35:17,710
transaction ID based master to multi

00:35:12,470 --> 00:35:17,710
sources and binary log master is a slave

00:35:18,789 --> 00:35:23,950
this is typically extremely useful if

00:35:21,619 --> 00:35:26,779
you wants to run real-time statistics

00:35:23,950 --> 00:35:28,549
across all your shards you get multiple

00:35:26,779 --> 00:35:30,859
master shards writing to maybe one

00:35:28,549 --> 00:35:34,789
single instance maybe you want to make a

00:35:30,859 --> 00:35:38,869
complete backup multiple reasons why

00:35:34,789 --> 00:35:42,349
this might make sense so global

00:35:38,869 --> 00:35:43,730
transaction IDs of course support multi

00:35:42,349 --> 00:35:46,080
seller application that's that's an

00:35:43,730 --> 00:35:48,210
important thing to have

00:35:46,080 --> 00:35:51,300
vivisection ideas can be enabled or

00:35:48,210 --> 00:35:53,010
disabled independently in Moorea DB it's

00:35:51,300 --> 00:35:54,780
actually turned on by default so you

00:35:53,010 --> 00:36:00,690
don't actually disable it it's just

00:35:54,780 --> 00:36:02,550
appended to the packet slaves using

00:36:00,690 --> 00:36:04,620
global transaction IDs obviously you

00:36:02,550 --> 00:36:06,690
don't have to have been logging enabled

00:36:04,620 --> 00:36:09,440
though going forward bin logging is

00:36:06,690 --> 00:36:11,850
something that everyone seems to turn on

00:36:09,440 --> 00:36:14,490
and it's also worth noting that in five

00:36:11,850 --> 00:36:15,990
six of MySQL but not per criminal server

00:36:14,490 --> 00:36:18,270
five six you actually had to shut down

00:36:15,990 --> 00:36:20,550
all your servers and restart them all at

00:36:18,270 --> 00:36:23,640
once to get global transaction IDs

00:36:20,550 --> 00:36:25,620
turned on but for criminals number five

00:36:23,640 --> 00:36:27,420
six is something called a step mode so

00:36:25,620 --> 00:36:30,690
allow you to turn on global transaction

00:36:27,420 --> 00:36:32,820
IDs while everything is turned on my

00:36:30,690 --> 00:36:34,080
skull five seven and eight zero allow

00:36:32,820 --> 00:36:36,210
you to turn on global transaction IDs

00:36:34,080 --> 00:36:38,340
automatically you don't have to restart

00:36:36,210 --> 00:36:42,000
your entire topology and this is one the

00:36:38,340 --> 00:36:44,960
reasons why Maria DVS global transaction

00:36:42,000 --> 00:36:49,170
ID difference from MySQL's

00:36:44,960 --> 00:36:50,850
so in MySQL five six global transaction

00:36:49,170 --> 00:36:53,310
ID the implementation did not support

00:36:50,850 --> 00:36:55,980
multi sauce replication but five seven

00:36:53,310 --> 00:36:58,110
and greater does the ability to turn

00:36:55,980 --> 00:36:59,850
have log slave updates equals zero for

00:36:58,110 --> 00:37:02,550
space efficiency so you didn't actually

00:36:59,850 --> 00:37:05,040
want to use more disk space also

00:37:02,550 --> 00:37:08,370
available now in five seven but Mirae DB

00:37:05,040 --> 00:37:10,050
had to go its own way and then of course

00:37:08,370 --> 00:37:12,630
to turn it on without having to restart

00:37:10,050 --> 00:37:15,000
the entire topology also like five seven

00:37:12,630 --> 00:37:16,830
and greater so what Maria DB introduced

00:37:15,000 --> 00:37:19,350
global transaction IDs five seven was

00:37:16,830 --> 00:37:21,270
not out yet Mirae DB was looking at what

00:37:19,350 --> 00:37:23,400
was available inside of five six and

00:37:21,270 --> 00:37:27,390
realized that it would make a lot of

00:37:23,400 --> 00:37:29,340
sense to make to make a fork so to speak

00:37:27,390 --> 00:37:32,100
of global transaction IDs design it

00:37:29,340 --> 00:37:33,870
differently now the caveat to designing

00:37:32,100 --> 00:37:35,430
it differently is that now you have to

00:37:33,870 --> 00:37:37,800
completing global transaction ID

00:37:35,430 --> 00:37:40,830
standards and if you're using software

00:37:37,800 --> 00:37:44,520
so software like MySQL router the modern

00:37:40,830 --> 00:37:48,480
MySQL connectors they all tend to rely

00:37:44,520 --> 00:37:51,600
on needing the MySQL global transaction

00:37:48,480 --> 00:37:53,970
ID they will not work with Maria DB

00:37:51,600 --> 00:37:56,190
civil transaction ID so even tools that

00:37:53,970 --> 00:37:59,010
I'll talk about later like MHA we should

00:37:56,190 --> 00:37:59,920
do automatic failover via two methods

00:37:59,010 --> 00:38:03,460
one via

00:37:59,920 --> 00:38:04,690
doing a binary log thief or or the

00:38:03,460 --> 00:38:08,260
second method which is the much quicker

00:38:04,690 --> 00:38:10,510
method by global transaction IDs mhar

00:38:08,260 --> 00:38:14,350
only supports GT ID based failover on

00:38:10,510 --> 00:38:17,230
MySQL but not Maria DB so this is one of

00:38:14,350 --> 00:38:20,560
those caveats when you decide to diverge

00:38:17,230 --> 00:38:22,660
with global transaction IDs and having

00:38:20,560 --> 00:38:24,580
the abilities have the GT ID in the okay

00:38:22,660 --> 00:38:26,830
packet is something that MySQL has but

00:38:24,580 --> 00:38:29,710
Maria DB does not have yet and it isn't

00:38:26,830 --> 00:38:32,290
a plan for 10.4 is important because

00:38:29,710 --> 00:38:35,530
proxy SQL a proxy which we'll talk about

00:38:32,290 --> 00:38:41,980
soon also makes use of the GT ID in the

00:38:35,530 --> 00:38:43,750
okay packet for various things so this

00:38:41,980 --> 00:38:47,560
is one of those reasons why it becomes

00:38:43,750 --> 00:38:49,030
important to start making sure you know

00:38:47,560 --> 00:38:50,830
what you're using as a base and then

00:38:49,030 --> 00:38:58,360
planning ahead based on the tools you're

00:38:50,830 --> 00:39:00,970
going to use parallel replication in in

00:38:58,360 --> 00:39:04,750
the Murray TV world is run by table not

00:39:00,970 --> 00:39:06,640
per database basically if you if you

00:39:04,750 --> 00:39:09,700
have power application turned on in in

00:39:06,640 --> 00:39:11,620
theory your slave can be as fast as your

00:39:09,700 --> 00:39:13,510
master it should be able to

00:39:11,620 --> 00:39:15,370
automatically detect non-conflicting row

00:39:13,510 --> 00:39:16,960
based events by comparing primary keys

00:39:15,370 --> 00:39:17,820
and then executing them in parallel for

00:39:16,960 --> 00:39:19,540
you nowadays

00:39:17,820 --> 00:39:21,700
Morini B is something known as

00:39:19,540 --> 00:39:23,680
optimistic power applications so if your

00:39:21,700 --> 00:39:25,630
master is running 10:1 and greater and

00:39:23,680 --> 00:39:29,500
your slave is also 10 1 and greater it

00:39:25,630 --> 00:39:32,320
makes them it basically makes the slave

00:39:29,500 --> 00:39:34,330
as fast as the master again because it

00:39:32,320 --> 00:39:38,350
can apply stuff sequentially to the

00:39:34,330 --> 00:39:42,190
master so power application is extremely

00:39:38,350 --> 00:39:43,510
useful very good talks by Jean Francois

00:39:42,190 --> 00:39:46,660
Gagne from booking.com

00:39:43,510 --> 00:39:49,330
on comparing both implementations of

00:39:46,660 --> 00:39:55,330
parallel application on his blog

00:39:49,330 --> 00:39:58,090
typically so sometimes these the stuff

00:39:55,330 --> 00:40:01,660
gets out of sync right because sometimes

00:39:58,090 --> 00:40:02,860
people write to the slave directly so

00:40:01,660 --> 00:40:05,710
maybe you should always set read-only

00:40:02,860 --> 00:40:08,320
equals one sometimes people use

00:40:05,710 --> 00:40:09,910
statement based replication and it turns

00:40:08,320 --> 00:40:11,320
out that statement based replication is

00:40:09,910 --> 00:40:13,680
terrible if you use triggers and stored

00:40:11,320 --> 00:40:16,440
procedures or have not determined

00:40:13,680 --> 00:40:18,750
like SQL sometimes people do crazy

00:40:16,440 --> 00:40:20,760
things like have their master in my eyes

00:40:18,750 --> 00:40:22,320
em and the slave in ODB I don't know why

00:40:20,760 --> 00:40:24,810
you do this but we've seen productions

00:40:22,320 --> 00:40:27,570
as how people do this and it's insane

00:40:24,810 --> 00:40:33,450
this will cause deadlocks for you never

00:40:27,570 --> 00:40:36,050
do this sometimes people basically make

00:40:33,450 --> 00:40:37,680
their application filters incorrectly

00:40:36,050 --> 00:40:39,270
sometimes you've got Barry log

00:40:37,680 --> 00:40:43,250
corruption on the master for whatever

00:40:39,270 --> 00:40:45,990
reason bad disk bad memory on the master

00:40:43,250 --> 00:40:47,670
Reed buffer size is larger than maximum

00:40:45,990 --> 00:40:51,930
packet and then sometimes you know what

00:40:47,670 --> 00:40:53,390
you can cause a replication bug so you

00:40:51,930 --> 00:40:56,310
wanna ensure your applicants are not

00:40:53,390 --> 00:40:57,780
basically garbage make sure you have

00:40:56,310 --> 00:40:58,230
some kind of replication monitoring in

00:40:57,780 --> 00:41:02,640
place

00:40:58,230 --> 00:41:04,500
I think universally everyone who uses

00:41:02,640 --> 00:41:07,500
MySQL in any serious fashion ends up

00:41:04,500 --> 00:41:09,360
using percona toolkit and it has maybe

00:41:07,500 --> 00:41:11,760
like 20 tools but from our application

00:41:09,360 --> 00:41:13,440
standpoint the relevant ones are PT

00:41:11,760 --> 00:41:15,030
slave find which will allow you to find

00:41:13,440 --> 00:41:16,740
your slave information from the master

00:41:15,030 --> 00:41:20,370
scheme out build up your application

00:41:16,740 --> 00:41:23,280
topology PDF will checksum which is a

00:41:20,370 --> 00:41:25,050
replication consistency check like

00:41:23,280 --> 00:41:29,790
execute checksum queries on the master

00:41:25,050 --> 00:41:31,980
and then if it finds issues you can then

00:41:29,790 --> 00:41:34,380
run PG table sync which will synchronize

00:41:31,980 --> 00:41:36,270
a table data efficiently but this

00:41:34,380 --> 00:41:37,950
actually changes your live data so if

00:41:36,270 --> 00:41:40,050
you don't have reliable backups that

00:41:37,950 --> 00:41:42,240
you've tested can actually restore I

00:41:40,050 --> 00:41:43,770
will not run PT tables sick in fact it

00:41:42,240 --> 00:41:45,210
warns you that it's going to make

00:41:43,770 --> 00:41:55,950
changes to your live data so make sure

00:41:45,210 --> 00:41:58,220
you have backups that can restore we

00:41:55,950 --> 00:42:01,020
also realized that many people would

00:41:58,220 --> 00:42:05,160
don't like command lines that often so

00:42:01,020 --> 00:42:07,410
we made a GUI available for you so GUI

00:42:05,160 --> 00:42:09,870
is based on you know Prometheus graph

00:42:07,410 --> 00:42:12,720
fauna and a whole slew of other

00:42:09,870 --> 00:42:14,390
open-source tools cobbled together to

00:42:12,720 --> 00:42:17,130
make our own monitoring and management

00:42:14,390 --> 00:42:18,900
and it comes to things like beyond just

00:42:17,130 --> 00:42:21,780
replication monitoring it also has query

00:42:18,900 --> 00:42:24,600
and Alex with sparklines metrics

00:42:21,780 --> 00:42:26,940
monitors and it's fully built on open

00:42:24,600 --> 00:42:27,569
source software so because of the open

00:42:26,940 --> 00:42:28,949
source software

00:42:27,569 --> 00:42:33,269
then we had to inherit I think it's

00:42:28,949 --> 00:42:35,729
license a gplv3 and we highly recommend

00:42:33,269 --> 00:42:37,709
you to try it because it also comes

00:42:35,729 --> 00:42:41,989
bundled with Orchestrator which we'll

00:42:37,709 --> 00:42:41,989
talk about soon hmm

00:42:43,219 --> 00:42:48,930
you mean if you're running MySQL bin log

00:42:46,199 --> 00:42:51,150
oh yeah before I forget there's also

00:42:48,930 --> 00:42:53,459
like a demo you can totally test test

00:42:51,150 --> 00:42:55,680
this out in your spare time like

00:42:53,459 --> 00:42:57,930
actually we have a live running cluster

00:42:55,680 --> 00:43:04,229
of maybe 15 machines or something you

00:42:57,930 --> 00:43:07,849
can play with so you may see errors like

00:43:04,229 --> 00:43:10,559
this like error in log event read log

00:43:07,849 --> 00:43:14,190
spawned invalid event in binary log data

00:43:10,559 --> 00:43:16,289
and this is largely because it's likely

00:43:14,190 --> 00:43:19,949
your MySQL client does not agree with

00:43:16,289 --> 00:43:22,529
the MySQL that you have installed so if

00:43:19,949 --> 00:43:25,319
you using MySQL client from Murray a DB

00:43:22,529 --> 00:43:28,380
which also calls it my schedule and you

00:43:25,319 --> 00:43:30,420
may suddenly realize you can't use use

00:43:28,380 --> 00:43:34,499
it against MySQL server which you get

00:43:30,420 --> 00:43:36,479
say from Oracle itself it's largely

00:43:34,499 --> 00:43:38,549
because global transaction ID varies and

00:43:36,479 --> 00:43:42,769
some features like streaming backup

00:43:38,549 --> 00:43:46,410
server did not exist previously as well

00:43:42,769 --> 00:43:48,779
slave prefetching everybody likes to

00:43:46,410 --> 00:43:51,299
ensure that when you create a new slave

00:43:48,779 --> 00:43:54,150
of some sort you'd like to make sure

00:43:51,299 --> 00:43:58,529
that that slave is warm such that it can

00:43:54,150 --> 00:44:00,539
serve queries easily and pakoda server

00:43:58,529 --> 00:44:02,339
right up till five six as well as really

00:44:00,539 --> 00:44:04,920
be right up till ten one has something

00:44:02,339 --> 00:44:06,690
called in the DB fake changes and this

00:44:04,920 --> 00:44:08,880
basically prefetches threads to warm up

00:44:06,690 --> 00:44:10,979
the server it replays statements and

00:44:08,880 --> 00:44:12,900
then it rolls it back and commits hence

00:44:10,979 --> 00:44:14,789
why it's called phase changes so it

00:44:12,900 --> 00:44:17,309
reads throws for inserts updates and

00:44:14,789 --> 00:44:19,559
deletes but it doesn't update them and

00:44:17,309 --> 00:44:22,049
they're all back extremely fast because

00:44:19,559 --> 00:44:24,539
there's nothing to do and this ensures

00:44:22,049 --> 00:44:27,150
that if you have a 64 gigabyte slave to

00:44:24,539 --> 00:44:29,369
start off cold it'll actually be fairly

00:44:27,150 --> 00:44:31,559
warm fairly quickly so that it can start

00:44:29,369 --> 00:44:34,019
actually serving queries as opposed to

00:44:31,559 --> 00:44:37,170
having to do it each and every time

00:44:34,019 --> 00:44:39,599
someone makes a query but paradigms have

00:44:37,170 --> 00:44:41,250
changed you don't need to have slave

00:44:39,599 --> 00:44:43,410
prefetching any longer

00:44:41,250 --> 00:44:45,150
so Procol Harum Pecola likes to remove

00:44:43,410 --> 00:44:46,700
features if if possible if I can't go

00:44:45,150 --> 00:44:49,770
upstream or there's a better solution

00:44:46,700 --> 00:44:51,390
features will get removed so now you can

00:44:49,770 --> 00:44:53,670
do interest give up peril replication

00:44:51,390 --> 00:44:57,300
and that's a great way to warm up your

00:44:53,670 --> 00:44:58,920
slaves and Marie do we serve of course

00:44:57,300 --> 00:45:01,380
also removed it because they switch to

00:44:58,920 --> 00:45:04,070
switch back to nodb they decide to fork

00:45:01,380 --> 00:45:04,070
InnoDB further

00:45:04,550 --> 00:45:09,320
Galera cluster only works for the

00:45:07,290 --> 00:45:12,060
transactional storage engine like in ODB

00:45:09,320 --> 00:45:14,790
it does not work with my rocks which is

00:45:12,060 --> 00:45:17,220
also transactional or taki DB it

00:45:14,790 --> 00:45:19,500
replaces the MySQL replication layer but

00:45:17,220 --> 00:45:21,359
can also work alongside it because it

00:45:19,500 --> 00:45:23,940
has something called the right set

00:45:21,359 --> 00:45:26,130
replication layer it is generally what

00:45:23,940 --> 00:45:30,450
I'd call a true multi master active

00:45:26,130 --> 00:45:31,890
active solution I call return the call

00:45:30,450 --> 00:45:33,750
it virtually singular application

00:45:31,890 --> 00:45:35,790
because it while it is logically

00:45:33,750 --> 00:45:38,670
synchronous and the actual writing and

00:45:35,790 --> 00:45:41,690
committing to the tablespace happens

00:45:38,670 --> 00:45:44,160
independently this is this also does

00:45:41,690 --> 00:45:47,460
naturally happen asynchronously on each

00:45:44,160 --> 00:45:49,859
node it follows a quorum algorithm so it

00:45:47,460 --> 00:45:51,980
needs a minimum of three nodes because

00:45:49,859 --> 00:45:56,790
if one node goes away and you have to

00:45:51,980 --> 00:45:59,460
50% does not make a majority it's when

00:45:56,790 --> 00:46:01,200
performance compared to a sink or semi

00:45:59,460 --> 00:46:03,720
sink replication is maybe a little

00:46:01,200 --> 00:46:06,330
slower when I say when performance I

00:46:03,720 --> 00:46:09,930
this this is this is basically your

00:46:06,330 --> 00:46:11,849
local area network it is not something

00:46:09,930 --> 00:46:14,369
that we'd recommend you to run across

00:46:11,849 --> 00:46:16,740
data centers you can run clusters of

00:46:14,369 --> 00:46:20,660
gallery across data centers but not have

00:46:16,740 --> 00:46:23,369
your nodes separate into data centers

00:46:20,660 --> 00:46:25,260
you of course again have no slave lag or

00:46:23,369 --> 00:46:27,030
integrity issues node provisioning is

00:46:25,260 --> 00:46:31,320
fairly automatic you can actually do

00:46:27,030 --> 00:46:33,240
self discovery and it does use

00:46:31,320 --> 00:46:35,099
optimistic concurrency control so as I

00:46:33,240 --> 00:46:36,780
said earlier transaction is done locally

00:46:35,099 --> 00:46:39,750
until commit time then apply it across

00:46:36,780 --> 00:46:44,460
all nodes in an basically asynchronous

00:46:39,750 --> 00:46:48,930
fashion coda ship has been around for

00:46:44,460 --> 00:46:50,310
maybe seven or eight years now and they

00:46:48,930 --> 00:46:51,510
were generally doing about three

00:46:50,310 --> 00:46:53,160
releases per year but they've slowed

00:46:51,510 --> 00:46:55,020
down a lot and we've been waiting for

00:46:53,160 --> 00:46:58,500
gallery cluster 4.0 for

00:46:55,020 --> 00:47:03,360
three years now Maria DB is integrated

00:46:58,500 --> 00:47:04,830
Galleria cluster into Maria DB so the

00:47:03,360 --> 00:47:07,320
right side replication option is

00:47:04,830 --> 00:47:10,710
available for you inside of stock Maria

00:47:07,320 --> 00:47:12,360
DB percona is also piccata has

00:47:10,710 --> 00:47:15,090
integrated into percolo server five

00:47:12,360 --> 00:47:17,580
seven it still a separate download but

00:47:15,090 --> 00:47:20,970
has other integrations and there plenty

00:47:17,580 --> 00:47:23,130
of users for Galera cluster

00:47:20,970 --> 00:47:25,920
we've had people migrate from Oracle RAC

00:47:23,130 --> 00:47:29,660
to Galarraga cluster we've had the DNS

00:47:25,920 --> 00:47:32,070
service for HP OpenStack recommends it

00:47:29,660 --> 00:47:35,010
people like page a duty AVG they all

00:47:32,070 --> 00:47:37,580
tend to use this so it does have its

00:47:35,010 --> 00:47:40,080
users out there

00:47:37,580 --> 00:47:42,210
procore actually we cluster is basically

00:47:40,080 --> 00:47:46,590
gallery cluster with engineering done

00:47:42,210 --> 00:47:48,930
within percona we bundle proxy SQL we

00:47:46,590 --> 00:47:50,460
integrate we have pmm exporters ready

00:47:48,930 --> 00:47:52,190
for you so you can integrate well with

00:47:50,460 --> 00:47:54,450
per criminal monitoring and management

00:47:52,190 --> 00:47:56,880
you of course benefit from the full

00:47:54,450 --> 00:47:59,400
mysql five seven feature set also comes

00:47:56,880 --> 00:48:02,610
with a proxy SQL administrator to so you

00:47:59,400 --> 00:48:04,410
could add and mr. proxy SQL and it has

00:48:02,610 --> 00:48:06,110
some safety features enable like you

00:48:04,410 --> 00:48:09,450
know we won't allow you to accidentally

00:48:06,110 --> 00:48:11,010
have a table type as my eyes am for

00:48:09,450 --> 00:48:13,860
example because that would just break

00:48:11,010 --> 00:48:15,870
and it'll break silently and we don't

00:48:13,860 --> 00:48:16,320
like that because then when you've lost

00:48:15,870 --> 00:48:21,600
data

00:48:16,320 --> 00:48:24,480
you'll be screaming well we're checking

00:48:21,600 --> 00:48:26,400
this out as well and the reason why

00:48:24,480 --> 00:48:28,470
proxy SQL has to be embedded is because

00:48:26,400 --> 00:48:30,420
you need a minimum of three nodes and

00:48:28,470 --> 00:48:32,100
having proxy SQL on the front is

00:48:30,420 --> 00:48:35,730
important so that you can do load

00:48:32,100 --> 00:48:37,620
balancing for example and/or if you

00:48:35,730 --> 00:48:39,150
start expanding the nodes behind it you

00:48:37,620 --> 00:48:42,540
might want to only send a certain set of

00:48:39,150 --> 00:48:45,450
nodes to read and a small set to write

00:48:42,540 --> 00:48:47,160
and a large set to read because you

00:48:45,450 --> 00:48:52,290
don't want to be you know having this

00:48:47,160 --> 00:48:53,970
hot row problem group replication is as

00:48:52,290 --> 00:48:55,110
I said like very very much like Galera

00:48:53,970 --> 00:48:57,870
it's also got fully synchronous

00:48:55,110 --> 00:48:58,620
replication basically update anywhere

00:48:57,870 --> 00:49:02,430
self-healing

00:48:58,620 --> 00:49:05,280
has elasticity redundancy by default now

00:49:02,430 --> 00:49:06,810
it's single primary primary mode but you

00:49:05,280 --> 00:49:08,130
can of course configure this to have

00:49:06,810 --> 00:49:12,990
multiple

00:49:08,130 --> 00:49:15,330
and of course it does use as a cell it's

00:49:12,990 --> 00:49:17,040
much newer than Galera clusters so we

00:49:15,330 --> 00:49:19,770
don't see much production use cases of

00:49:17,040 --> 00:49:21,780
this yet but I fully expect that in the

00:49:19,770 --> 00:49:23,730
next 12 to 18 months group application

00:49:21,780 --> 00:49:25,080
is going to be very famous because it's

00:49:23,730 --> 00:49:27,720
clear that Oracle's putting lots of

00:49:25,080 --> 00:49:29,010
resources behind it and within TV

00:49:27,720 --> 00:49:30,770
cluster you can actually have

00:49:29,010 --> 00:49:35,550
combination of group replication router

00:49:30,770 --> 00:49:38,340
MySQL SH and you literally have it takes

00:49:35,550 --> 00:49:40,650
less than five minutes to get your inner

00:49:38,340 --> 00:49:42,330
B cluster set up and there is a video on

00:49:40,650 --> 00:49:44,340
youtube if you type MySQL and every

00:49:42,330 --> 00:49:46,470
cluster on YouTube you'll see Frederick

00:49:44,340 --> 00:49:48,680
the scamp's give you a five-minute video

00:49:46,470 --> 00:49:54,990
intro on how you can get this set up

00:49:48,680 --> 00:49:57,540
in five minutes so yeah quick summaries

00:49:54,990 --> 00:49:58,470
generally speaking replication is the

00:49:57,540 --> 00:50:01,260
way to go

00:49:58,470 --> 00:50:03,690
I think Sammis sync is of course a good

00:50:01,260 --> 00:50:06,300
option for most people however if you

00:50:03,690 --> 00:50:08,460
need the ability to never ever lose a

00:50:06,300 --> 00:50:11,250
transaction then Galera and soon in the

00:50:08,460 --> 00:50:12,930
DB cluster might make sense as well when

00:50:11,250 --> 00:50:14,520
it comes to handling failure you you

00:50:12,930 --> 00:50:19,500
know possibly do things like polling

00:50:14,520 --> 00:50:21,060
monitoring alerts also you need to know

00:50:19,500 --> 00:50:22,500
after you've figured out what has

00:50:21,060 --> 00:50:24,540
happened to failure what do you do about

00:50:22,500 --> 00:50:27,060
it and then you have to make sure you've

00:50:24,540 --> 00:50:28,830
protected data integrity as well and you

00:50:27,060 --> 00:50:31,860
want to ensure that you never have a

00:50:28,830 --> 00:50:33,450
situation with a split brain right so

00:50:31,860 --> 00:50:36,300
there plenty of frameworks to handle

00:50:33,450 --> 00:50:38,070
failure and I obviously won't talk to

00:50:36,300 --> 00:50:40,200
you about all of them but again your

00:50:38,070 --> 00:50:45,740
choice of database server is important

00:50:40,200 --> 00:50:45,740
for one this will not work with Maria DB

00:50:46,280 --> 00:50:52,340
MySQL mhm a global transaction ID

00:50:49,170 --> 00:50:56,100
failover will only work with MySQL and

00:50:52,340 --> 00:50:58,380
and so forth and replication manager so

00:50:56,100 --> 00:51:00,060
again well I don't have a slide for that

00:50:58,380 --> 00:51:02,250
there are dedicated to it

00:51:00,060 --> 00:51:06,210
replication manager is basically a

00:51:02,250 --> 00:51:08,250
rewrite of MHA but written in Co MH is

00:51:06,210 --> 00:51:10,020
written in Perl now there's nothing

00:51:08,250 --> 00:51:12,540
wrong with MHA being written in Perl and

00:51:10,020 --> 00:51:14,460
and one could configure it but someone

00:51:12,540 --> 00:51:17,790
decided maybe you would like one one go

00:51:14,460 --> 00:51:20,940
binary and maybe throw on a little user

00:51:17,790 --> 00:51:23,850
interface but there's no no real gain

00:51:20,940 --> 00:51:28,200
/ having said user interface beyond the

00:51:23,850 --> 00:51:29,700
fact that it's not purl now I have no

00:51:28,200 --> 00:51:31,470
problem with purl and most people that

00:51:29,700 --> 00:51:34,290
the MySQL will have no problem with purl

00:51:31,470 --> 00:51:36,450
so that's one of the reasons why MHA is

00:51:34,290 --> 00:51:40,890
probably a lot more utilized and say

00:51:36,450 --> 00:51:42,480
replication manager Orchestrator is

00:51:40,890 --> 00:51:43,710
something that I highly recommend you to

00:51:42,480 --> 00:51:45,810
take a look at because it reads

00:51:43,710 --> 00:51:47,760
replication topologies keep state

00:51:45,810 --> 00:51:50,070
continuously poles it's a packet of

00:51:47,760 --> 00:51:52,500
licensed extremely well documented

00:51:50,070 --> 00:51:54,540
it's a github project it's on its life

00:51:52,500 --> 00:51:56,220
and Outbrain tend to booking.com and

00:51:54,540 --> 00:51:58,620
then became a github project it's also

00:51:56,220 --> 00:52:01,320
written in go allows you to like kill

00:51:58,620 --> 00:52:02,550
long-running queries modify a topology

00:52:01,320 --> 00:52:05,310
stick and move slaves around

00:52:02,550 --> 00:52:07,260
it's excellent piece of software highly

00:52:05,310 --> 00:52:08,700
recommended for you to try this if you

00:52:07,260 --> 00:52:10,680
care about replication and high

00:52:08,700 --> 00:52:12,420
availability and soon it'll also have

00:52:10,680 --> 00:52:15,090
built-in automatic failover and it's

00:52:12,420 --> 00:52:17,730
learning a lot from MHA so this is

00:52:15,090 --> 00:52:21,690
probably the two that one would use in

00:52:17,730 --> 00:52:26,040
the next twelve months for automatic

00:52:21,690 --> 00:52:27,630
failover as well MHA that's automated as

00:52:26,040 --> 00:52:29,400
well as manual failover and why would

00:52:27,630 --> 00:52:31,980
you do a manual failover maybe you want

00:52:29,400 --> 00:52:33,690
to do a schema change that would make a

00:52:31,980 --> 00:52:36,450
good reason to make a manual failover

00:52:33,690 --> 00:52:38,070
and again it can choose new masters by

00:52:36,450 --> 00:52:40,200
comparing slave binary log positions

00:52:38,070 --> 00:52:42,540
this works for both Maria DB and MySQL

00:52:40,200 --> 00:52:49,470
but as I said GT ID based failover

00:52:42,540 --> 00:52:51,360
just on my SQL pacemaker comes with

00:52:49,470 --> 00:52:53,010
resource agents right so you can its per

00:52:51,360 --> 00:52:54,810
color application manager is now inside

00:52:53,010 --> 00:52:57,000
of the pacemaker resource resource

00:52:54,810 --> 00:52:59,300
agents and again you can use things like

00:52:57,000 --> 00:53:02,010
heartbeat core sync

00:52:59,300 --> 00:53:04,250
I'd say it's extremely specialized and

00:53:02,010 --> 00:53:08,460
you know we've seen instances where

00:53:04,250 --> 00:53:10,620
pacemaker can also seg fault so while

00:53:08,460 --> 00:53:12,510
this is a great way from a Linux

00:53:10,620 --> 00:53:14,400
standpoint it's probably not something

00:53:12,510 --> 00:53:17,510
that we recommend unless you have good

00:53:14,400 --> 00:53:20,610
Linux chops so to speak

00:53:17,510 --> 00:53:22,140
you also definitely a load balancer and

00:53:20,610 --> 00:53:23,850
your load balancer probably also needs

00:53:22,140 --> 00:53:26,340
to ensure it's not just one little

00:53:23,850 --> 00:53:29,040
balance about a year several HF proxy is

00:53:26,340 --> 00:53:31,080
great if your if your database server

00:53:29,040 --> 00:53:33,180
supports the proxy protocol and so far

00:53:31,080 --> 00:53:34,840
only Percona server five six and five

00:53:33,180 --> 00:53:38,500
seven supports a proxy protocol

00:53:34,840 --> 00:53:39,850
and Maria db10 three you could use a

00:53:38,500 --> 00:53:44,500
cheap Roxy but a cheap Roxy does not

00:53:39,850 --> 00:53:48,280
understand SQL Mac skill and proxy SQL

00:53:44,500 --> 00:53:50,380
definitely do as does my skill router my

00:53:48,280 --> 00:53:52,030
skill router is basically the

00:53:50,380 --> 00:53:53,500
application connections that will be

00:53:52,030 --> 00:53:54,730
transparently routed based on load

00:53:53,500 --> 00:53:56,410
balancing policy without ever

00:53:54,730 --> 00:53:58,960
implementing custom application code

00:53:56,410 --> 00:54:01,540
this is part of that you know DB cluster

00:53:58,960 --> 00:54:03,400
that I was talking about anything also

00:54:01,540 --> 00:54:05,800
distributes application connections in a

00:54:03,400 --> 00:54:07,450
round robin fashion I expect again in

00:54:05,800 --> 00:54:10,140
the next 12 to 18 months this will be

00:54:07,450 --> 00:54:13,870
extremely popular but maybe not today

00:54:10,140 --> 00:54:17,440
Mac scale Mexico was was the was the you

00:54:13,870 --> 00:54:19,390
know golden child in terms of routers

00:54:17,440 --> 00:54:21,580
because it was it was the first when GA

00:54:19,390 --> 00:54:24,370
was level 7 proxy router understands the

00:54:21,580 --> 00:54:25,900
MySQL protocol it's basically a Swiss

00:54:24,370 --> 00:54:27,550
Army knife right because it's got a

00:54:25,900 --> 00:54:29,620
pluggable architecture so you could do

00:54:27,550 --> 00:54:32,200
query level analysis schema based

00:54:29,620 --> 00:54:34,090
sharding had a Kafka back-end and so

00:54:32,200 --> 00:54:36,160
forth there's excellent piece of kit

00:54:34,090 --> 00:54:39,520
until this this licensing thing came

00:54:36,160 --> 00:54:41,620
about in way you stopped becoming free

00:54:39,520 --> 00:54:43,360
software but became licensed under the

00:54:41,620 --> 00:54:45,460
business source license which basically

00:54:43,360 --> 00:54:47,380
says you may use the license work with

00:54:45,460 --> 00:54:48,670
the application uses license work with a

00:54:47,380 --> 00:54:52,030
total of less than three server

00:54:48,670 --> 00:54:54,010
instances for any purposes so to start a

00:54:52,030 --> 00:54:56,260
useful cluster you need three server

00:54:54,010 --> 00:54:58,990
instances so you'd have to pay a license

00:54:56,260 --> 00:55:01,360
fee which seems ridiculous so this is

00:54:58,990 --> 00:55:04,450
now not the golden child anymore

00:55:01,360 --> 00:55:07,150
the golden child probably is this proxy

00:55:04,450 --> 00:55:09,190
SQL largest deployments spends several

00:55:07,150 --> 00:55:11,410
hundred proxies it's extremely high

00:55:09,190 --> 00:55:14,020
performance it's written by DBAs for

00:55:11,410 --> 00:55:15,880
DBAs so it was written by rene canal

00:55:14,020 --> 00:55:18,070
during his time at dropbox he's not

00:55:15,880 --> 00:55:20,650
there anymore but dropbox is a whole

00:55:18,070 --> 00:55:22,780
bunch of other people does query writing

00:55:20,650 --> 00:55:25,240
you can do shot by how schema you can

00:55:22,780 --> 00:55:27,420
change rules and modify SQL without

00:55:25,240 --> 00:55:30,460
having to restart proxy SQL so again

00:55:27,420 --> 00:55:32,670
written by DVS for DBAs definitely

00:55:30,460 --> 00:55:35,260
highly recommend you to check this out

00:55:32,670 --> 00:55:38,230
you can also do high availability inside

00:55:35,260 --> 00:55:40,360
of the drivers so most drivers nowadays

00:55:38,230 --> 00:55:42,550
like JDBC PHP and stuff can do

00:55:40,360 --> 00:55:44,830
read/write splitting round-robin

00:55:42,550 --> 00:55:46,120
random below selection again no single

00:55:44,830 --> 00:55:48,160
point of failure

00:55:46,120 --> 00:55:48,539
fully aware of my Skelton's I can state

00:55:48,160 --> 00:55:51,449
an error

00:55:48,539 --> 00:55:52,949
this is this is definitely an option not

00:55:51,449 --> 00:55:56,579
an option that not many people end up

00:55:52,949 --> 00:55:58,140
using is clustering a solution or part

00:55:56,579 --> 00:55:59,789
of the problem so there's a white paper

00:55:58,140 --> 00:56:02,160
written called causes of downtime in

00:55:59,789 --> 00:56:04,709
production MySQL service number one

00:56:02,160 --> 00:56:07,619
cause of downtime human error okay

00:56:04,709 --> 00:56:11,459
probably between the keyboard number two

00:56:07,619 --> 00:56:12,599
cause of downtime using a SAN so then

00:56:11,459 --> 00:56:14,339
some people think why not do a

00:56:12,599 --> 00:56:15,719
clustering favor plus an it turns out

00:56:14,339 --> 00:56:20,819
that will give you even more problems so

00:56:15,719 --> 00:56:24,239
avoid that so in terms of replication

00:56:20,819 --> 00:56:26,130
types I guess you know you think a lot

00:56:24,239 --> 00:56:28,140
about your competencies like I you are

00:56:26,130 --> 00:56:30,059
you a competent DBA I a competent Linux

00:56:28,140 --> 00:56:31,890
is admin and so forth

00:56:30,059 --> 00:56:34,829
those are definitely important thoughts

00:56:31,890 --> 00:56:37,769
to think about if you are a competent

00:56:34,829 --> 00:56:43,829
Linux person dr VD probably can make

00:56:37,769 --> 00:56:45,569
some sense to some extent statement

00:56:43,829 --> 00:56:47,099
based versus rho based application so

00:56:45,569 --> 00:56:49,499
rho based application is definitely

00:56:47,099 --> 00:56:51,059
deterministic segment based in my

00:56:49,499 --> 00:56:53,279
opinion is extremely dangerous it should

00:56:51,059 --> 00:56:55,049
probably stop using it global production

00:56:53,279 --> 00:56:56,939
IDs are definitely easier to set up and

00:56:55,049 --> 00:57:00,179
failover and they had and make it can

00:56:56,939 --> 00:57:02,339
handle complex topologies today async is

00:57:00,179 --> 00:57:05,039
is fast but you have data loss in

00:57:02,339 --> 00:57:07,199
failover fully sync is is the best but

00:57:05,039 --> 00:57:09,419
it's also the slowest so Sammis think is

00:57:07,199 --> 00:57:11,400
a good middle ground and then

00:57:09,419 --> 00:57:12,719
multi-threaded slaves is something

00:57:11,400 --> 00:57:16,319
that's been around since five six

00:57:12,719 --> 00:57:18,539
integrator as well so I don't know if

00:57:16,319 --> 00:57:20,669
since earlier no one not many people

00:57:18,539 --> 00:57:22,890
said they use the Amazon RDS I don't

00:57:20,669 --> 00:57:27,259
know how many maybe use Google Cloud SQL

00:57:22,890 --> 00:57:29,789
or not but it's worth noting that

00:57:27,259 --> 00:57:33,509
scalability and H a tends to be built in

00:57:29,789 --> 00:57:35,339
via their gooeys RDS testings like multi

00:57:33,509 --> 00:57:37,799
a-z but you don't get a read replicas

00:57:35,339 --> 00:57:40,229
Cecil need to pay for that separately

00:57:37,799 --> 00:57:42,119
Google Cloud SQL is actually the first

00:57:40,229 --> 00:57:43,709
of all the cloud providers to actually

00:57:42,119 --> 00:57:45,869
semi synchronous replication in

00:57:43,709 --> 00:57:48,329
production so you actually get very very

00:57:45,869 --> 00:57:50,249
fast failovers you want to watch out for

00:57:48,329 --> 00:57:53,189
the SLA s because they also do automatic

00:57:50,249 --> 00:57:55,709
upgrades automatic upgrades backups and

00:57:53,189 --> 00:57:58,499
stuff are not included as part of the

00:57:55,709 --> 00:58:00,380
SLA time you want to monitor via

00:57:58,499 --> 00:58:02,280
performance schema tremendously

00:58:00,380 --> 00:58:04,500
also in the cloud bad

00:58:02,280 --> 00:58:07,710
exist so have a certain set of queries

00:58:04,500 --> 00:58:11,250
you'd run if you hit a bad node kill the

00:58:07,710 --> 00:58:13,560
node get another one now I did not even

00:58:11,250 --> 00:58:16,470
get much time to talk to you about Vitas

00:58:13,560 --> 00:58:18,000
which is another framework sharding

00:58:16,470 --> 00:58:20,940
framework that allows you to shard

00:58:18,000 --> 00:58:23,730
rishaad and the same time act as a proxy

00:58:20,940 --> 00:58:25,440
and retest is now governed by the cloud

00:58:23,730 --> 00:58:28,680
native compute foundation and it's added

00:58:25,440 --> 00:58:30,860
life at Google actually it's it is what

00:58:28,680 --> 00:58:33,810
powers YouTube so if you look at YouTube

00:58:30,860 --> 00:58:35,310
it is it is a it is power every time you

00:58:33,810 --> 00:58:36,870
go to youtube it is powered by a test

00:58:35,310 --> 00:58:39,390
and retest makes use of lightweight

00:58:36,870 --> 00:58:41,480
binary beasts on connections so every

00:58:39,390 --> 00:58:46,800
connection is only 32 kilobytes in size

00:58:41,480 --> 00:58:49,230
versus up to 3 megabytes with MySQL why

00:58:46,800 --> 00:58:51,450
why did I not give a dedicated slide to

00:58:49,230 --> 00:58:54,380
meet s largely because it's so con

00:58:51,450 --> 00:58:57,330
limited SQL so it's on it's not full

00:58:54,380 --> 00:58:59,580
MySQL full MySQL Pazza

00:58:57,330 --> 00:59:02,270
but because it's a CNC F project it's

00:58:59,580 --> 00:59:04,560
being used at places like slack and and

00:59:02,270 --> 00:59:07,350
JD calm and a whole bunch of other

00:59:04,560 --> 00:59:10,320
places I expect it as a very very bright

00:59:07,350 --> 00:59:12,240
future as well replication is extremely

00:59:10,320 --> 00:59:14,070
amazing if you know how to use it and

00:59:12,240 --> 00:59:17,730
monitor it well with global transaction

00:59:14,070 --> 00:59:19,470
idea great operational usability large

00:59:17,730 --> 00:59:21,660
sites just run fine with semi

00:59:19,470 --> 00:59:23,610
synchronous replication

00:59:21,660 --> 00:59:25,890
don't forget the need for a load balance

00:59:23,610 --> 00:59:30,480
like proxy SQL and when you're thinking

00:59:25,890 --> 00:59:33,390
scaling things scale out not scale up so

00:59:30,480 --> 00:59:37,920
you know with that I am pretty much out

00:59:33,390 --> 00:59:39,960
of time so thank you for listening if

00:59:37,920 --> 00:59:43,680
you have any questions I'll be here for

00:59:39,960 --> 00:59:46,320
the next couple days and if you have a

00:59:43,680 --> 00:59:48,240
question now I do have time for like one

00:59:46,320 --> 00:59:50,040
question maybe I think for one question

00:59:48,240 --> 00:59:52,460
we have time okay anybody have a

00:59:50,040 --> 00:59:52,460
question

00:59:56,850 --> 01:00:03,630
oh yeah thank you for your talk I'm just

01:00:01,140 --> 01:00:06,120
curious about running the PT table take

01:00:03,630 --> 01:00:08,430
some to lure the pakora toolkit on a

01:00:06,120 --> 01:00:12,060
production database is there any

01:00:08,430 --> 01:00:14,310
pitfalls doing that so in terms of table

01:00:12,060 --> 01:00:16,230
locking more stuff PTT I will check some

01:00:14,310 --> 01:00:18,300
running in production will there be any

01:00:16,230 --> 01:00:21,750
pitfalls for any table locking so no not

01:00:18,300 --> 01:00:24,180
for PT table check some pjo checksum is

01:00:21,750 --> 01:00:25,680
not destructive it is just basically

01:00:24,180 --> 01:00:27,510
that I'm sure that there are check sums

01:00:25,680 --> 01:00:30,000
being around in a new separate table

01:00:27,510 --> 01:00:33,570
that it gets that creates peace table

01:00:30,000 --> 01:00:36,420
sync can be destructive so if you find

01:00:33,570 --> 01:00:38,340
the check sums are not matching then you

01:00:36,420 --> 01:00:40,230
need to sync it that's that's when you

01:00:38,340 --> 01:00:41,460
need to worry but really table checksum

01:00:40,230 --> 01:00:43,590
is something a lot of people tend to

01:00:41,460 --> 01:00:48,420
just run without worrying about they

01:00:43,590 --> 01:00:50,000
were locking okay thank you very much

01:00:48,420 --> 01:00:55,460
thank you

01:00:50,000 --> 01:01:14,620
[Applause]

01:00:55,460 --> 01:01:14,620

YouTube URL: https://www.youtube.com/watch?v=nG0nr-IVDVQ


