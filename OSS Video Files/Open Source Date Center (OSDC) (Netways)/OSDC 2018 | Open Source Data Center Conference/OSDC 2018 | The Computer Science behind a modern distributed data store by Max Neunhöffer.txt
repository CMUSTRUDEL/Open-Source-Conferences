Title: OSDC 2018 | The Computer Science behind a modern distributed data store by Max Neunhöffer
Publication date: 2018-06-22
Playlist: OSDC 2018 | Open Source Data Center Conference
Description: 
	What we see in the modern data store world is a race between different approaches to achieve a distributed and resilient storage of data. Most applications need a stateful layer which holds the data. There are at least three necessary ingredients which are everything else than trivial to combine and of course even more challenging when heading for an acceptable performance. Over the past years there has been significant progress in respect in both the science and practical implementations of such data stores. In his talk Max Neunhoeffer will introduce the audience to some of the needed ingredients, address the difficulties of their interplay and show four modern approaches of distributed open-source data stores.
Topics are:
– Challenges in developing a distributed, resilient data store
– Consensus, distributed transactions, distributed query optimization and execution
– The inner workings of ArangoDB, Cassandra, Cockroach and RethinkDB
The talk will touch complex and difficult computer science, but will at the same time be accessible to and enjoyable by a wide range of developers.

NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de
Blog: http://blog.netways.de
Webinare: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Google+: https://plus.google.com/+netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh

https://www.frametraxx.de/
Captions: 
	00:00:00,540 --> 00:00:03,369
[Music]

00:00:01,310 --> 00:00:03,369
you

00:00:11,750 --> 00:00:16,830
[Music]

00:00:13,369 --> 00:00:19,640
yes this sounds a bit theoretical and it

00:00:16,830 --> 00:00:22,410
is so it's probably a bit more

00:00:19,640 --> 00:00:24,150
theoretical than most other talks here

00:00:22,410 --> 00:00:27,629
but never mind what do you expect from a

00:00:24,150 --> 00:00:30,329
mathematician so obviously this is a

00:00:27,629 --> 00:00:34,800
vast topic and so therefore I shall

00:00:30,329 --> 00:00:37,289
concentrate on five subtopics since I

00:00:34,800 --> 00:00:40,140
have 45 minutes that's 9 minutes per

00:00:37,289 --> 00:00:41,850
topic so we have to rush even then

00:00:40,140 --> 00:00:44,030
anyway if there's any questions please

00:00:41,850 --> 00:00:46,440
let me know so I will talk about

00:00:44,030 --> 00:00:48,960
resilience and consensus I'll talk about

00:00:46,440 --> 00:00:51,570
sorting I'll talk about lock structured

00:00:48,960 --> 00:00:53,750
merge trees I'll talk about hybrid to

00:00:51,570 --> 00:00:57,690
logical clocks and about distributed

00:00:53,750 --> 00:00:59,430
transactions obviously it is lunatic to

00:00:57,690 --> 00:01:02,850
try all this in one talk so therefore I

00:00:59,430 --> 00:01:04,739
shall be content to just give you the

00:01:02,850 --> 00:01:07,500
idea of what the problem is with this

00:01:04,739 --> 00:01:11,100
ease and maybe how it is solved well

00:01:07,500 --> 00:01:13,469
besides the last one so we have 9 min

00:01:11,100 --> 00:01:18,119
per topic V so we get a bit better get

00:01:13,469 --> 00:01:20,999
started let me tell you about the first

00:01:18,119 --> 00:01:23,880
one obviously the the bottom line is to

00:01:20,999 --> 00:01:26,689
have a to implement distributed modern

00:01:23,880 --> 00:01:31,350
data store you need computer science

00:01:26,689 --> 00:01:33,270
now consensus a modern data store or

00:01:31,350 --> 00:01:36,659
indeed modern applications are

00:01:33,270 --> 00:01:39,659
distributed so you have different parts

00:01:36,659 --> 00:01:42,389
and there's various reasons for that one

00:01:39,659 --> 00:01:44,609
is scale out obviously but another

00:01:42,389 --> 00:01:48,420
reason is to be resilient computers

00:01:44,609 --> 00:01:50,009
break they break every night and so

00:01:48,420 --> 00:01:52,799
therefore you have to be have to have a

00:01:50,009 --> 00:01:54,450
resilient application now if it's

00:01:52,799 --> 00:01:57,299
distributed then the different parts

00:01:54,450 --> 00:01:59,369
somehow have to agree on things like for

00:01:57,299 --> 00:02:01,529
example copies of data or the state of

00:01:59,369 --> 00:02:04,020
the system or whatever and that is the

00:02:01,529 --> 00:02:06,450
problem with consensus so consensus in

00:02:04,020 --> 00:02:08,759
computer science is the art to achieve

00:02:06,450 --> 00:02:13,140
that different parts of the system agree

00:02:08,759 --> 00:02:14,580
on whatever as well as possible well you

00:02:13,140 --> 00:02:16,370
would think that this is easy you just

00:02:14,580 --> 00:02:19,590
send a network message over there and

00:02:16,370 --> 00:02:22,770
you say well they agree because you just

00:02:19,590 --> 00:02:27,260
copy over data well that is true

00:02:22,770 --> 00:02:33,780
in the case that things are good however

00:02:27,260 --> 00:02:38,040
if your network has outages your servers

00:02:33,780 --> 00:02:43,830
fail your disks fail and maybe come back

00:02:38,040 --> 00:02:47,280
in a corrupt way bits flip machines fail

00:02:43,830 --> 00:02:49,410
racks fail network splits happened and

00:02:47,280 --> 00:02:53,070
you all know this is not a theoretical

00:02:49,410 --> 00:02:56,760
thing this happens yeah

00:02:53,070 --> 00:02:59,340
and in these under these conditions

00:02:56,760 --> 00:03:01,260
consensus is a much harder problem how

00:02:59,340 --> 00:03:05,100
can you keep consensus if your network

00:03:01,260 --> 00:03:08,510
is split in half well you can't that's

00:03:05,100 --> 00:03:11,540
what I mean by as well as possible so

00:03:08,510 --> 00:03:13,470
what what can we do about this at all

00:03:11,540 --> 00:03:16,350
well I haven't even talked about

00:03:13,470 --> 00:03:19,830
malicious attacks this is just bad

00:03:16,350 --> 00:03:21,510
things happening on its own the

00:03:19,830 --> 00:03:25,200
traditional approach to this is the

00:03:21,510 --> 00:03:28,200
Paxos consensus protocol from 1989 to 98

00:03:25,200 --> 00:03:29,910
or you might have heard already but

00:03:28,200 --> 00:03:36,209
there's also something newer which is

00:03:29,910 --> 00:03:38,490
called raft from 2013 taxes is a

00:03:36,209 --> 00:03:43,110
challenge to understand not let alone

00:03:38,490 --> 00:03:44,130
implement because it's somehow

00:03:43,110 --> 00:03:46,110
complicated

00:03:44,130 --> 00:03:48,360
well the inventor of parks was Leslie

00:03:46,110 --> 00:03:50,580
Lamport argues that if you think about

00:03:48,360 --> 00:03:52,650
it you cannot come up with anything else

00:03:50,580 --> 00:03:54,390
that is to some extent true but

00:03:52,650 --> 00:03:57,570
nevertheless it's complicated it's hard

00:03:54,390 --> 00:04:00,170
to swallow and it's even harder to

00:03:57,570 --> 00:04:02,310
implement there's a lots of variants

00:04:00,170 --> 00:04:03,990
putting emphasis on this or that

00:04:02,310 --> 00:04:05,610
performance tuning this or that

00:04:03,990 --> 00:04:08,820
extending and this or that it's it's

00:04:05,610 --> 00:04:13,230
really a big mess raft on the contrary

00:04:08,820 --> 00:04:16,140
is designed to be understandable it's

00:04:13,230 --> 00:04:18,510
not a lot better in every way but it's a

00:04:16,140 --> 00:04:22,290
lot better in the way that it can be

00:04:18,510 --> 00:04:23,610
understood so therefore my advice in

00:04:22,290 --> 00:04:25,650
this business if you have to solve

00:04:23,610 --> 00:04:27,270
consensus or you start with consensus

00:04:25,650 --> 00:04:29,900
you should do the following

00:04:27,270 --> 00:04:32,340
try to understand paxos for a while

00:04:29,900 --> 00:04:34,470
because the papers are well written they

00:04:32,340 --> 00:04:36,830
are fun to read and it's a good

00:04:34,470 --> 00:04:42,000
challenge and it's fun

00:04:36,830 --> 00:04:44,280
don't implement it then if you have

00:04:42,000 --> 00:04:47,250
prepared your mind with this complicated

00:04:44,280 --> 00:04:50,280
praxis then go away and read a rough

00:04:47,250 --> 00:04:52,949
paper which is a beauty because it's

00:04:50,280 --> 00:04:54,930
written to be understood and also the

00:04:52,949 --> 00:04:59,190
protocol is really really beautiful and

00:04:54,930 --> 00:05:03,449
in comparison rather simple but don't

00:04:59,190 --> 00:05:05,389
implement it either rather use some

00:05:03,449 --> 00:05:08,520
battle-tested implementation you trust

00:05:05,389 --> 00:05:11,960
so use something which implements raft

00:05:08,520 --> 00:05:16,020
or indeed praxis if that is working and

00:05:11,960 --> 00:05:19,130
use that for consensus but there's one

00:05:16,020 --> 00:05:23,940
more advice which is even more important

00:05:19,130 --> 00:05:27,229
do not try to invent your own I can tell

00:05:23,940 --> 00:05:29,729
you I have tried and of course failed

00:05:27,229 --> 00:05:31,680
many people believe consensus is

00:05:29,729 --> 00:05:36,810
something simple why don't we do it like

00:05:31,680 --> 00:05:39,750
this don't you see this raft paper is

00:05:36,810 --> 00:05:43,020
actually the result of a PhD thesis in

00:05:39,750 --> 00:05:44,789
computer science with 250 pages and the

00:05:43,020 --> 00:05:47,310
protocol in there has not only described

00:05:44,789 --> 00:05:49,979
well it is proven to work there's a

00:05:47,310 --> 00:05:53,460
machine checked proof that this protocol

00:05:49,979 --> 00:05:55,770
works as a mathematician this is what

00:05:53,460 --> 00:05:59,159
you want to use and then should you

00:05:55,770 --> 00:06:02,880
implement it and I said don't follow

00:05:59,159 --> 00:06:04,919
this paper and the PhD thesis to the

00:06:02,880 --> 00:06:07,560
letter that is your Bible

00:06:04,919 --> 00:06:09,900
you shall not deviate from it because if

00:06:07,560 --> 00:06:12,330
you deviate the slightest step then the

00:06:09,900 --> 00:06:15,780
proof is void and you don't want to do

00:06:12,330 --> 00:06:17,849
that ok so that's the problem that is

00:06:15,780 --> 00:06:20,880
the solution and now I try something

00:06:17,849 --> 00:06:23,009
even more crazy I try to explain to you

00:06:20,880 --> 00:06:28,110
what raft is and how it works in one

00:06:23,009 --> 00:06:29,729
slide cannot work but here we go what

00:06:28,110 --> 00:06:33,449
you do is you take an odd number of

00:06:29,729 --> 00:06:36,060
servers and let them play democracy so

00:06:33,449 --> 00:06:39,330
the typical thing is 3 or 5 so let's

00:06:36,060 --> 00:06:40,710
think 3 you take 3 servers you want them

00:06:39,330 --> 00:06:43,919
to agree on something

00:06:40,710 --> 00:06:45,960
and keep things simple what they want to

00:06:43,919 --> 00:06:49,229
agree is just a log of events

00:06:45,960 --> 00:06:50,430
it's an append-only data structure you

00:06:49,229 --> 00:06:54,229
just want to agree

00:06:50,430 --> 00:06:56,880
on these lock of it events that's all

00:06:54,229 --> 00:06:58,530
now everything is replicated to

00:06:56,880 --> 00:07:02,850
everybody because we want to agree we

00:06:58,530 --> 00:07:05,729
want to copy and what they do is they

00:07:02,850 --> 00:07:07,380
elect a leader so essentially one of

00:07:05,729 --> 00:07:09,660
them says please elect me and the other

00:07:07,380 --> 00:07:12,000
says as long as network is good okay we

00:07:09,660 --> 00:07:14,639
like to fine you are the leader this is

00:07:12,000 --> 00:07:16,620
now the leader and if you want to append

00:07:14,639 --> 00:07:19,800
something to replicate that lock only

00:07:16,620 --> 00:07:22,350
the leader may append so the leader pens

00:07:19,800 --> 00:07:25,410
to each lock and it replicates

00:07:22,350 --> 00:07:28,320
everything to the others they confirm I

00:07:25,410 --> 00:07:30,169
have it and then it's committed simple

00:07:28,320 --> 00:07:34,380
as that

00:07:30,169 --> 00:07:36,510
now the append doesn't count when the

00:07:34,380 --> 00:07:37,889
leader has said it's appended to my lock

00:07:36,510 --> 00:07:42,300
after all the leader could fail in the

00:07:37,889 --> 00:07:47,039
next second the consensus is reached if

00:07:42,300 --> 00:07:50,220
a majority of the servers have appended

00:07:47,039 --> 00:07:52,289
it to their lock so in case of three the

00:07:50,220 --> 00:07:55,130
commit has happened if two of them have

00:07:52,289 --> 00:07:58,169
appended it then there is no way back

00:07:55,130 --> 00:08:00,750
notice that the leader pens it to its

00:07:58,169 --> 00:08:03,990
lag first there's one replica which

00:08:00,750 --> 00:08:05,880
manages first to replicate and at that

00:08:03,990 --> 00:08:08,700
point of time nobody knows that it's

00:08:05,880 --> 00:08:10,560
committed because the leader doesn't

00:08:08,700 --> 00:08:12,630
know that the other guy has committed

00:08:10,560 --> 00:08:15,870
and the other guy doesn't know whether

00:08:12,630 --> 00:08:18,300
the leader has died in the meantime so

00:08:15,870 --> 00:08:20,460
nobody knows that it's committed but yet

00:08:18,300 --> 00:08:21,900
the condition has come that is what

00:08:20,460 --> 00:08:24,479
makes these things difficult

00:08:21,900 --> 00:08:26,729
anyway if a majority has persisted

00:08:24,479 --> 00:08:30,060
persistently to persistent storage that

00:08:26,729 --> 00:08:31,919
is the point of no return now there's

00:08:30,060 --> 00:08:34,080
very smart logic which I cannot explain

00:08:31,919 --> 00:08:37,279
in one slide to ensure that there is a

00:08:34,080 --> 00:08:40,800
unique leader and that thing recovers

00:08:37,279 --> 00:08:43,349
for example there are terms so a leader

00:08:40,800 --> 00:08:45,720
is always elected for term and whenever

00:08:43,349 --> 00:08:48,120
somebody thinks or who the leader isn't

00:08:45,720 --> 00:08:50,010
there there hasn't been something from

00:08:48,120 --> 00:08:52,140
the leader for a long time and they can

00:08:50,010 --> 00:08:55,589
have a new election but only for a

00:08:52,140 --> 00:08:56,850
higher term and it's it's in one sense

00:08:55,589 --> 00:08:59,160
it's quite straight forward on the other

00:08:56,850 --> 00:09:02,579
hand it's extremely clever such that the

00:08:59,160 --> 00:09:04,449
proof actually works it's a lot of fun

00:09:02,579 --> 00:09:06,730
it's a lot of fun to implement

00:09:04,449 --> 00:09:09,639
it's a lot of fun to follow this proof

00:09:06,730 --> 00:09:11,529
and it is proven to work so as long as

00:09:09,639 --> 00:09:14,980
you don't deviate from that protocol

00:09:11,529 --> 00:09:18,040
it's going to work provided the

00:09:14,980 --> 00:09:19,540
assumptions of the prove are given now

00:09:18,040 --> 00:09:22,179
what one usually does one takes this

00:09:19,540 --> 00:09:24,249
lock of events as the changes of a key

00:09:22,179 --> 00:09:26,619
value store so you implant implement a

00:09:24,249 --> 00:09:28,389
key value store on top of that and every

00:09:26,619 --> 00:09:30,369
change has to go through this lock and

00:09:28,389 --> 00:09:31,899
as soon as everybody has applied it the

00:09:30,369 --> 00:09:34,329
leader says okay this now accounts this

00:09:31,899 --> 00:09:38,040
transaction and the new values of the

00:09:34,329 --> 00:09:41,139
keys are like this transaction says

00:09:38,040 --> 00:09:43,179
right the person who invented this it's

00:09:41,139 --> 00:09:50,290
the author of the PhD thesis Diego and

00:09:43,179 --> 00:09:52,899
coral has yeah that the idea was that I

00:09:50,290 --> 00:09:54,369
can click on it and have it but I have

00:09:52,899 --> 00:09:57,699
done it even easier I've already opened

00:09:54,369 --> 00:10:00,660
it so this is running a little applet I

00:09:57,699 --> 00:10:03,189
have not written it was Diego's work and

00:10:00,660 --> 00:10:04,990
this is something you can play with so

00:10:03,189 --> 00:10:08,799
for example here you have four servers

00:10:04,990 --> 00:10:11,259
nobody is a leader yet this one runs out

00:10:08,799 --> 00:10:13,809
of patience and says okay I might as

00:10:11,259 --> 00:10:16,179
well become the leader so what it does

00:10:13,809 --> 00:10:18,759
it says I want to be a leader it sends

00:10:16,179 --> 00:10:22,540
out messages saying please elect me for

00:10:18,759 --> 00:10:24,189
term 1 and so it goes the others say ok

00:10:22,540 --> 00:10:27,490
you might be a good leader for someone

00:10:24,189 --> 00:10:29,619
here we go now they work and I think I

00:10:27,490 --> 00:10:32,619
can even do things like append to the

00:10:29,619 --> 00:10:35,709
lock I have to tell the leader can send

00:10:32,619 --> 00:10:38,980
a request now you see this is appended

00:10:35,709 --> 00:10:41,079
to the lock of server 3 as 3 and it's

00:10:38,980 --> 00:10:44,290
quickly replicated to the others if I do

00:10:41,079 --> 00:10:47,829
this a few times you see eventually it

00:10:44,290 --> 00:10:51,819
catches up now obviously I can do things

00:10:47,829 --> 00:10:54,639
like stop a machine if I do a request

00:10:51,819 --> 00:10:56,499
well it's still fine it's replicated to

00:10:54,639 --> 00:11:00,730
the living ones as long as we have a

00:10:56,499 --> 00:11:03,899
majority we can make progress but if I

00:11:00,730 --> 00:11:06,339
kill the leader or stop the leader

00:11:03,899 --> 00:11:08,980
others run out of patience you can see

00:11:06,339 --> 00:11:11,470
that these bars are vanishing it's a

00:11:08,980 --> 00:11:13,120
random time out they have and as soon as

00:11:11,470 --> 00:11:14,290
somebody loses patience like this one

00:11:13,120 --> 00:11:17,480
here it says oh we haven't heard from

00:11:14,290 --> 00:11:22,490
the leader elect me

00:11:17,480 --> 00:11:25,070
and now he's a new leader and I can only

00:11:22,490 --> 00:11:29,960
append stuff here and this is not done

00:11:25,070 --> 00:11:32,180
in term 3 yeah so I think I have passed

00:11:29,960 --> 00:11:33,920
the 9 minutes so therefore we have to

00:11:32,180 --> 00:11:35,500
move on to the next topic but this is a

00:11:33,920 --> 00:11:38,180
nice thing to play with and to

00:11:35,500 --> 00:11:40,220
understand what's going on after you

00:11:38,180 --> 00:11:47,450
have read the rough paper or just play

00:11:40,220 --> 00:11:51,320
with it like this ok consensus is nice

00:11:47,450 --> 00:11:52,970
raft seems to be the answer but

00:11:51,320 --> 00:11:55,370
obviously it's not a solution to every

00:11:52,970 --> 00:11:57,950
problem if you have a machine system of

00:11:55,370 --> 00:12:00,620
a hundred machines you want to agree

00:11:57,950 --> 00:12:01,940
them on the commit of a transaction or

00:12:00,620 --> 00:12:03,320
on the order of transactions you

00:12:01,940 --> 00:12:05,090
certainly don't want to run it through a

00:12:03,320 --> 00:12:08,090
single raft instance because this would

00:12:05,090 --> 00:12:10,730
not never scale so it's very good raft

00:12:08,090 --> 00:12:13,460
but it's not not the solution for all

00:12:10,730 --> 00:12:16,520
purposes anyway it is used in in

00:12:13,460 --> 00:12:18,230
practical systems ok

00:12:16,520 --> 00:12:19,580
completely different topic just let's

00:12:18,230 --> 00:12:22,280
jump to something else which is also

00:12:19,580 --> 00:12:23,900
needed in such a data start sorting you

00:12:22,280 --> 00:12:25,550
would believe that you can read

00:12:23,900 --> 00:12:28,150
everything about sorting in the art of

00:12:25,550 --> 00:12:34,850
computer programming from the 70s and

00:12:28,150 --> 00:12:38,390
that is true our of unfortunately nearly

00:12:34,850 --> 00:12:40,270
all published algorithms including the

00:12:38,390 --> 00:12:42,590
ones in the art of computer programming

00:12:40,270 --> 00:12:45,910
are completely rubbish on modern

00:12:42,590 --> 00:12:48,590
hardware why is that

00:12:45,910 --> 00:12:50,360
well what did people do when they

00:12:48,590 --> 00:12:53,420
analyzed these algorithms they counted

00:12:50,360 --> 00:12:55,220
comparisons they said how many times do

00:12:53,420 --> 00:12:57,850
you have to compare two things and maybe

00:12:55,220 --> 00:13:00,230
swap them to get the whole thing sorted

00:12:57,850 --> 00:13:01,850
that was interesting at the time when

00:13:00,230 --> 00:13:04,660
comparisons were the most expensive

00:13:01,850 --> 00:13:07,160
thing in sorting nowadays it isn't

00:13:04,660 --> 00:13:10,190
because nowadays the expensive thing is

00:13:07,160 --> 00:13:12,620
data movement let me give you an example

00:13:10,190 --> 00:13:17,740
when I was a kid I played with an apple

00:13:12,620 --> 00:13:20,510
2e yes I was an Apple fan at some time

00:13:17,740 --> 00:13:25,520
however if I compare the performance of

00:13:20,510 --> 00:13:27,980
that machine to my laptop today then the

00:13:25,520 --> 00:13:30,860
compute power in one core has actually

00:13:27,980 --> 00:13:31,279
increased by a factor of 20,000 to

00:13:30,860 --> 00:13:33,860
execute

00:13:31,279 --> 00:13:37,339
instructions 20,000 times as fast as at

00:13:33,860 --> 00:13:39,560
the time then if you look at the time

00:13:37,339 --> 00:13:41,420
needed for a single memory access yes I

00:13:39,560 --> 00:13:44,329
know at the time it was a byte

00:13:41,420 --> 00:13:47,629
now it's 64 by it yes you're right but

00:13:44,329 --> 00:13:49,999
the latency for a single access has only

00:13:47,629 --> 00:13:54,670
been fast become faster by a factor of

00:13:49,999 --> 00:13:58,579
40 that is a certain mismatch and

00:13:54,670 --> 00:14:02,319
certainly these days here this water has

00:13:58,579 --> 00:14:05,449
had one little car with one megahertz

00:14:02,319 --> 00:14:08,509
but machines today have 32 cores maybe

00:14:05,449 --> 00:14:12,920
not this laptop but others have and they

00:14:08,509 --> 00:14:15,290
share this the access to the memory so

00:14:12,920 --> 00:14:17,420
therefore if you count this together and

00:14:15,290 --> 00:14:19,579
take the quotient you notice that there

00:14:17,420 --> 00:14:22,999
is a mismatch by a factor of twelve

00:14:19,579 --> 00:14:24,379
hundred and eighty so getting the data

00:14:22,999 --> 00:14:27,139
into the processor is actually the

00:14:24,379 --> 00:14:29,509
problem in sorting now and if you want

00:14:27,139 --> 00:14:32,779
to write an algorithm which keeps 32

00:14:29,509 --> 00:14:35,240
cores completely busy you will struggle

00:14:32,779 --> 00:14:37,220
a bit and you cannot use nearly any of

00:14:35,240 --> 00:14:40,089
the published algorithms so let me how

00:14:37,220 --> 00:14:43,360
tell you how to solve this problem

00:14:40,089 --> 00:14:47,329
the answer is merge sort actually works

00:14:43,360 --> 00:14:49,129
if you do it right now what is the idea

00:14:47,329 --> 00:14:51,410
behind merge sort behind merge sort is

00:14:49,129 --> 00:14:53,839
the idea of a huge array to sort yeah

00:14:51,410 --> 00:14:57,620
you cut it in peat into pieces you sort

00:14:53,839 --> 00:14:59,480
the small pieces first this can be done

00:14:57,620 --> 00:15:01,790
in parallel except if they share the

00:14:59,480 --> 00:15:04,519
memory anyway you saw the small pieces

00:15:01,790 --> 00:15:06,559
first and then you merge these by taking

00:15:04,519 --> 00:15:08,509
well you take two or more you take the

00:15:06,559 --> 00:15:10,250
smallest first into the result and then

00:15:08,509 --> 00:15:12,430
the next smallest and so on you just

00:15:10,250 --> 00:15:14,929
follow all these sorted areas arrays

00:15:12,430 --> 00:15:18,050
from left to right and you always put

00:15:14,929 --> 00:15:21,679
the smallest in here now if you do this

00:15:18,050 --> 00:15:25,790
naively this very step here of sorting

00:15:21,679 --> 00:15:28,309
stuff will be memory bound it's not the

00:15:25,790 --> 00:15:31,189
comparisons it is getting the memory

00:15:28,309 --> 00:15:34,399
into the CPU which which stops you from

00:15:31,189 --> 00:15:36,499
using all 32 cores that is the problem

00:15:34,399 --> 00:15:39,529
so now what you can you do you use

00:15:36,499 --> 00:15:40,910
something like a min heap a min heap is

00:15:39,529 --> 00:15:42,410
a data structure you don't know that

00:15:40,910 --> 00:15:44,930
they have to know the details it's a

00:15:42,410 --> 00:15:46,940
balanced binary tree

00:15:44,930 --> 00:15:48,770
and the only condition you need is that

00:15:46,940 --> 00:15:51,320
the things you stick in these little

00:15:48,770 --> 00:15:53,480
balls have the property that whenever

00:15:51,320 --> 00:15:56,540
you have a situation where one is the

00:15:53,480 --> 00:15:58,750
parent of two others then the thing you

00:15:56,540 --> 00:16:02,089
put here is smaller than the other two

00:15:58,750 --> 00:16:03,980
that's all you need and in particular it

00:16:02,089 --> 00:16:07,279
follows that the top guy here is always

00:16:03,980 --> 00:16:09,800
the smallest in the whole heap now it

00:16:07,279 --> 00:16:12,860
turns out that you can insert a new

00:16:09,800 --> 00:16:17,180
point into such a heap in logarithmic

00:16:12,860 --> 00:16:19,490
time so it only takes the number of

00:16:17,180 --> 00:16:22,940
steps of the height of this tree not the

00:16:19,490 --> 00:16:25,640
number of things in the tree to insert

00:16:22,940 --> 00:16:28,910
and also if you take away the smallest

00:16:25,640 --> 00:16:30,800
up here to repair the damage and create

00:16:28,910 --> 00:16:35,180
a good heap again also is logarithmic

00:16:30,800 --> 00:16:37,520
time now that's good so what you do is

00:16:35,180 --> 00:16:40,760
you essentially take these sorted ranges

00:16:37,520 --> 00:16:43,220
here and insert them into the heap such

00:16:40,760 --> 00:16:47,029
that you can be sure that the top guy is

00:16:43,220 --> 00:16:48,410
the next one of the result and then you

00:16:47,029 --> 00:16:51,410
take them off here

00:16:48,410 --> 00:16:54,110
so what is the secret sauce here since

00:16:51,410 --> 00:16:56,930
this heap structure doesn't have to be

00:16:54,110 --> 00:17:00,650
really really large it can fit

00:16:56,930 --> 00:17:02,810
completely into second level cache that

00:17:00,650 --> 00:17:07,189
means if you come with a new guy up here

00:17:02,810 --> 00:17:09,620
and insert all the comparisons except

00:17:07,189 --> 00:17:13,520
maybe the first one will be cache to

00:17:09,620 --> 00:17:14,900
cache yeah this means that you take a

00:17:13,520 --> 00:17:16,490
new one yes you have to load a cache

00:17:14,900 --> 00:17:19,579
line but maybe you have already loaded

00:17:16,490 --> 00:17:22,490
one up here but everything here is in

00:17:19,579 --> 00:17:24,800
cache so you can quickly insert and it's

00:17:22,490 --> 00:17:27,160
actually fast because the CPU can get

00:17:24,800 --> 00:17:29,510
the data quickly from second level cache

00:17:27,160 --> 00:17:32,120
and likewise if you remove something

00:17:29,510 --> 00:17:35,630
here yes you have to write here once

00:17:32,120 --> 00:17:39,679
okay but obviously this was also just

00:17:35,630 --> 00:17:41,570
one access special pepper hash line to

00:17:39,679 --> 00:17:43,880
repair the damage you also only compare

00:17:41,570 --> 00:17:46,850
stuff in here everything is in second

00:17:43,880 --> 00:17:48,850
level cache I know if you go that means

00:17:46,850 --> 00:17:50,960
if you organize this diligently

00:17:48,850 --> 00:17:52,700
obviously starting with very small

00:17:50,960 --> 00:17:54,140
things which we do in our in another way

00:17:52,700 --> 00:17:56,300
which fit into a second application

00:17:54,140 --> 00:17:58,820
already to bootstrap the whole procedure

00:17:56,300 --> 00:18:01,639
and then use your multiple cost

00:17:58,820 --> 00:18:04,100
make ever large assorted segments using

00:18:01,639 --> 00:18:05,779
this technology essentially everything

00:18:04,100 --> 00:18:10,490
happens in the second level cache of

00:18:05,779 --> 00:18:12,320
your CPUs and you are fine now towards

00:18:10,490 --> 00:18:15,350
the end you obviously have to have some

00:18:12,320 --> 00:18:18,289
kind of single threaded work so the last

00:18:15,350 --> 00:18:20,480
step has to be carefully done such that

00:18:18,289 --> 00:18:24,110
it works but essentially this is with

00:18:20,480 --> 00:18:27,110
this technique you can sort a huge array

00:18:24,110 --> 00:18:30,649
which fits in a memory in a way such

00:18:27,110 --> 00:18:34,279
that all 32 cores are 100% CPU on top

00:18:30,649 --> 00:18:37,070
it's possible it can be done and that's

00:18:34,279 --> 00:18:39,110
the end of this story so if people say

00:18:37,070 --> 00:18:46,700
they know all about sorting ask them

00:18:39,110 --> 00:18:48,889
whether they know this next topic again

00:18:46,700 --> 00:18:50,809
something completely different which is

00:18:48,889 --> 00:18:54,830
just in the mixture because it's also

00:18:50,809 --> 00:19:00,200
used in data stores log structured merge

00:18:54,830 --> 00:19:01,940
trees now if people have say a data

00:19:00,200 --> 00:19:04,149
store or say on a single machine first

00:19:01,940 --> 00:19:07,940
we are getting to distribute it later

00:19:04,149 --> 00:19:12,320
what do they expect well in particular

00:19:07,940 --> 00:19:14,840
if you have SSDs then you probably

00:19:12,320 --> 00:19:18,289
expect that you can store more data than

00:19:14,840 --> 00:19:21,399
fits in RAM well it's it's a data store

00:19:18,289 --> 00:19:23,419
so it should probably use your SSD you

00:19:21,399 --> 00:19:28,309
would expect that it works well with

00:19:23,419 --> 00:19:32,539
SSDs and hard disks you expect that if

00:19:28,309 --> 00:19:35,570
you do bulk inserts it's fast and you

00:19:32,539 --> 00:19:38,000
probably want to be nearly as fast as

00:19:35,570 --> 00:19:41,659
you can write data you as a to your SS

00:19:38,000 --> 00:19:45,710
team and you expect that if you do reads

00:19:41,659 --> 00:19:48,679
and you just hit a set as a hot set

00:19:45,710 --> 00:19:50,360
which does fit in memory then you expect

00:19:48,679 --> 00:19:53,990
that the data store keeps it in memory

00:19:50,360 --> 00:19:56,120
and serves it from memory so that's all

00:19:53,990 --> 00:19:58,009
reasonable things but if you look at

00:19:56,120 --> 00:20:02,629
classical database technology like B

00:19:58,009 --> 00:20:05,029
trees they usually fail on at least one

00:20:02,629 --> 00:20:07,100
of these two things here now they are

00:20:05,029 --> 00:20:09,980
not so bad with respect to reeds and hot

00:20:07,100 --> 00:20:12,710
sets and so on but in particular for bus

00:20:09,980 --> 00:20:16,519
fast rybalko inserts

00:20:12,710 --> 00:20:18,409
they usually fail your expectations now

00:20:16,519 --> 00:20:22,879
log structured marks tree is a data

00:20:18,409 --> 00:20:28,009
structure for on disk on SSD which well

00:20:22,879 --> 00:20:30,830
helps with these problems again I can

00:20:28,009 --> 00:20:32,509
just give you the idea and again other

00:20:30,830 --> 00:20:34,340
people have worked before me there's a

00:20:32,509 --> 00:20:36,679
very nice description in this link and

00:20:34,340 --> 00:20:42,169
the link is actually in the slides which

00:20:36,679 --> 00:20:43,879
are published now that's another one of

00:20:42,169 --> 00:20:45,950
these things three minutes for a

00:20:43,879 --> 00:20:48,289
completely educated data structure let's

00:20:45,950 --> 00:20:51,950
add let's look at what we have here we

00:20:48,289 --> 00:20:54,619
have multiple levels and you somehow

00:20:51,950 --> 00:20:58,519
should think of level noodle 2 in this

00:20:54,619 --> 00:21:01,669
level zero to be in memory everything

00:20:58,519 --> 00:21:04,220
your right to the data store and we are

00:21:01,669 --> 00:21:07,570
thinking a sorted key value store here

00:21:04,220 --> 00:21:09,499
so we think that the keys are sorted

00:21:07,570 --> 00:21:11,480
lexicographically or by whatever sort

00:21:09,499 --> 00:21:13,580
order and what you want to do is you

00:21:11,480 --> 00:21:16,369
want to look up ranges and look up key

00:21:13,580 --> 00:21:18,649
value pairs and you want to write and

00:21:16,369 --> 00:21:22,399
delete them obviously so everything that

00:21:18,649 --> 00:21:28,220
is changed is changed in level 0 these

00:21:22,399 --> 00:21:30,379
arrays here are all sorted such that you

00:21:28,220 --> 00:21:32,779
can use binary search to find something

00:21:30,379 --> 00:21:36,049
in them so they are built up with some

00:21:32,779 --> 00:21:38,659
tree structure in memory so that's fast

00:21:36,049 --> 00:21:40,940
you can quickly write you can quickly

00:21:38,659 --> 00:21:43,869
take in data and obviously you do

00:21:40,940 --> 00:21:48,649
something like write a head lock for

00:21:43,869 --> 00:21:52,129
durability that's solved notice that

00:21:48,649 --> 00:21:55,369
although all of these are sorted they

00:21:52,129 --> 00:21:58,009
can overlap so they cover the whole key

00:21:55,369 --> 00:22:02,169
range essentially now in the other

00:21:58,009 --> 00:22:04,610
levels you should think disk or SSD you

00:22:02,169 --> 00:22:08,330
should think that these guys are also

00:22:04,610 --> 00:22:10,730
sorted but that they are larger so every

00:22:08,330 --> 00:22:13,159
level from one to the next is something

00:22:10,730 --> 00:22:18,889
like 10 times as much data as the one

00:22:13,159 --> 00:22:21,259
before yeah and what you do and any

00:22:18,889 --> 00:22:25,279
other difference is that down here these

00:22:21,259 --> 00:22:26,480
do not overlap so all of the keys in

00:22:25,279 --> 00:22:29,419
here are smaller than

00:22:26,480 --> 00:22:31,940
all of the keys here that is if you look

00:22:29,419 --> 00:22:34,910
for something in level one you only have

00:22:31,940 --> 00:22:36,460
to look in one of these ranges likewise

00:22:34,910 --> 00:22:39,530
with two and so on

00:22:36,460 --> 00:22:41,980
now I've already said you always insert

00:22:39,530 --> 00:22:44,660
into one of these things in level zero

00:22:41,980 --> 00:22:48,710
and if you have enough of these

00:22:44,660 --> 00:22:51,049
overlapping areas you do the following

00:22:48,710 --> 00:22:54,230
thing you merge them down to the next

00:22:51,049 --> 00:22:56,090
level so what do you see what you do is

00:22:54,230 --> 00:22:58,760
you say you take this one and the key

00:22:56,090 --> 00:23:02,360
range and you take all the beginnings of

00:22:58,760 --> 00:23:04,970
these guys here do a merge sort which we

00:23:02,360 --> 00:23:07,940
have explained just now do a merge sort

00:23:04,970 --> 00:23:09,770
and write out a new version of this

00:23:07,940 --> 00:23:13,130
incorporating the beginnings of all

00:23:09,770 --> 00:23:17,960
these guys notice that everything on

00:23:13,130 --> 00:23:21,020
disk is always written linearly because

00:23:17,960 --> 00:23:24,110
that is what hard disks and SSDs can do

00:23:21,020 --> 00:23:25,850
quickly in particular hard disks but

00:23:24,110 --> 00:23:27,080
also as I sees what they don't like to

00:23:25,850 --> 00:23:28,790
write something here and here and then

00:23:27,080 --> 00:23:31,790
here and then here then there right

00:23:28,790 --> 00:23:35,600
performance is very bad but if you write

00:23:31,790 --> 00:23:39,110
linearly then they are fast because they

00:23:35,600 --> 00:23:40,460
can use big block sizes and so on the

00:23:39,110 --> 00:23:42,020
hard disks don't have to move their

00:23:40,460 --> 00:23:44,150
heads too much and so on so therefore

00:23:42,020 --> 00:23:47,150
every such merge sort operation pulls

00:23:44,150 --> 00:23:49,549
this stuff here into memory maybe in

00:23:47,150 --> 00:23:51,980
blocks it does a merge sort operation

00:23:49,549 --> 00:23:55,820
writes a new version of this one here

00:23:51,980 --> 00:23:57,980
and then discards this one and in the

00:23:55,820 --> 00:24:00,730
lower levels it works the same way you

00:23:57,980 --> 00:24:03,950
always merge down to the next level now

00:24:00,730 --> 00:24:07,160
if you want to overwrite a kiemce you

00:24:03,950 --> 00:24:08,990
again just write in the top and the

00:24:07,160 --> 00:24:11,929
convention is just if a key is found

00:24:08,990 --> 00:24:14,570
higher up in this structure then it's

00:24:11,929 --> 00:24:16,040
more recent and therefore it counts if

00:24:14,570 --> 00:24:18,440
you want to delete something you write a

00:24:16,040 --> 00:24:19,990
so-called tombstone you write this key

00:24:18,440 --> 00:24:22,340
does no longer exist

00:24:19,990 --> 00:24:26,210
so therefore reading is also quite

00:24:22,340 --> 00:24:28,640
simple to read a key in here what you

00:24:26,210 --> 00:24:30,500
have to do is you have to look through

00:24:28,640 --> 00:24:33,710
these things in level 0 if you find it

00:24:30,500 --> 00:24:36,549
fine if you don't find it you have to go

00:24:33,710 --> 00:24:40,640
further down look here in the right area

00:24:36,549 --> 00:24:42,260
if you find it fine if you don't find it

00:24:40,640 --> 00:24:44,090
go further down if you have fallen

00:24:42,260 --> 00:24:47,590
through and have not found it it doesn't

00:24:44,090 --> 00:24:50,840
exist so that's nice

00:24:47,590 --> 00:24:52,190
cannot spend more details on writing but

00:24:50,840 --> 00:24:55,309
what happens is that everything is

00:24:52,190 --> 00:24:57,830
written linearly all files are immutable

00:24:55,309 --> 00:25:02,840
one's written so therefore rights are

00:24:57,830 --> 00:25:05,360
fast now unfortunately you don't do any

00:25:02,840 --> 00:25:09,080
more tricks then reading is now

00:25:05,360 --> 00:25:10,820
seriously impeded because it has to look

00:25:09,080 --> 00:25:13,340
here and look there and look at the

00:25:10,820 --> 00:25:14,929
other place and that pretty much sounds

00:25:13,340 --> 00:25:19,429
like hopping around and you have a

00:25:14,929 --> 00:25:21,740
random read load then things go badly so

00:25:19,429 --> 00:25:24,290
therefore we need more tricks let me

00:25:21,740 --> 00:25:27,530
quickly summarize what we have before we

00:25:24,290 --> 00:25:31,760
get to reading everything first goes to

00:25:27,530 --> 00:25:36,440
level 0 mem tables all files on disk are

00:25:31,760 --> 00:25:39,049
sorted immutable we always merge thought

00:25:36,440 --> 00:25:41,990
to get from upper levels further down

00:25:39,049 --> 00:25:43,700
and obviously we do compaction if we

00:25:41,990 --> 00:25:45,260
notice further down that there was a key

00:25:43,700 --> 00:25:47,990
and if there's another copy of that

00:25:45,260 --> 00:25:49,730
further up then the upper upper one

00:25:47,990 --> 00:25:53,330
counts so we can discard the lower one

00:25:49,730 --> 00:25:58,730
that's called compaction all these use

00:25:53,330 --> 00:26:01,070
sequential i/o that's fine now let's

00:25:58,730 --> 00:26:02,360
talk about reading the problem with the

00:26:01,070 --> 00:26:04,490
reading is that you have to read in

00:26:02,360 --> 00:26:07,490
various places in particular if if the

00:26:04,490 --> 00:26:09,730
key isn't there you have to look in many

00:26:07,490 --> 00:26:11,900
places to find out it's not there

00:26:09,730 --> 00:26:14,600
therefore one uses something called

00:26:11,900 --> 00:26:16,669
bloom filters or cuckoo filters which is

00:26:14,600 --> 00:26:20,900
again a very nice computer science data

00:26:16,669 --> 00:26:24,260
structure and it can do the following it

00:26:20,900 --> 00:26:27,020
doesn't use a lot of memory but it can

00:26:24,260 --> 00:26:30,590
answer the question is a certain key in

00:26:27,020 --> 00:26:35,990
this set or is it not in this set it's

00:26:30,590 --> 00:26:40,520
allowed to lie so if it says yes then it

00:26:35,990 --> 00:26:43,190
can lie but if it says no this key isn't

00:26:40,520 --> 00:26:48,530
in the set then your guarantee that it's

00:26:43,190 --> 00:26:51,530
right so doesn't use much memory it can

00:26:48,530 --> 00:26:53,360
lie but only in one direction and that's

00:26:51,530 --> 00:26:54,600
exactly what we need here imagining

00:26:53,360 --> 00:26:56,640
ourselves looking source

00:26:54,600 --> 00:27:00,929
thing here well it's like it's okay in

00:26:56,640 --> 00:27:03,419
memory we don't find it we know if it's

00:27:00,929 --> 00:27:06,270
in there it's in here but that's already

00:27:03,419 --> 00:27:09,179
too large to keep in memory so therefore

00:27:06,270 --> 00:27:13,200
we add we put to for this immutable file

00:27:09,179 --> 00:27:16,640
we compute a bloom filter which is much

00:27:13,200 --> 00:27:19,110
smaller and which we can keep in memory

00:27:16,640 --> 00:27:20,789
so therefore we first ask the bloom

00:27:19,110 --> 00:27:23,700
filter is the key in here

00:27:20,789 --> 00:27:26,100
if the bloom filter says no we don't

00:27:23,700 --> 00:27:29,640
have to touch the disk because it's

00:27:26,100 --> 00:27:31,919
guaranteed not to be there if the room

00:27:29,640 --> 00:27:33,809
filter says yes well first of all with

00:27:31,919 --> 00:27:36,059
very high probability the key is

00:27:33,809 --> 00:27:39,539
actually in there so we actually go

00:27:36,059 --> 00:27:42,870
ahead look for the disk do do the seek

00:27:39,539 --> 00:27:45,150
and can't get it and well if it wasn't

00:27:42,870 --> 00:27:47,610
there okay mistakes happen it doesn't

00:27:45,150 --> 00:27:51,000
matter we have spent a bit time but

00:27:47,610 --> 00:27:52,650
there's no mistake so it's only bloom

00:27:51,000 --> 00:27:54,990
filters or cuckoo filters the more

00:27:52,650 --> 00:27:59,070
modern approach which make this whole

00:27:54,990 --> 00:28:01,250
thing a bearable for random reads and if

00:27:59,070 --> 00:28:03,539
you then put the usual block pass block

00:28:01,250 --> 00:28:06,750
buffering which basically the operating

00:28:03,539 --> 00:28:08,970
system already does for you you get good

00:28:06,750 --> 00:28:12,659
write throughput and reasonable read

00:28:08,970 --> 00:28:15,059
performance that's the story about lock

00:28:12,659 --> 00:28:17,760
structured NOx trees I can tell here

00:28:15,059 --> 00:28:20,549
it's used all over the place we in a

00:28:17,760 --> 00:28:25,350
Rango DB use it so I should admit that I

00:28:20,549 --> 00:28:26,730
work for a company making Rango DB in

00:28:25,350 --> 00:28:30,620
particular we use it because we use

00:28:26,730 --> 00:28:34,230
rocks TV rocks TV the storage engine

00:28:30,620 --> 00:28:35,789
which was developed at Facebook uses it

00:28:34,230 --> 00:28:39,020
but also why our Tiger has a mode for

00:28:35,789 --> 00:28:42,210
that so MongoDB is using it and all

00:28:39,020 --> 00:28:44,400
these big players all use some kind of

00:28:42,210 --> 00:28:47,820
log structured merge tree it's used all

00:28:44,400 --> 00:28:51,750
over the place so it's good

00:28:47,820 --> 00:28:55,679
I haven't said it's perfect we'll see

00:28:51,750 --> 00:29:00,240
what the future brings and on to the

00:28:55,679 --> 00:29:02,669
next one again completely different

00:29:00,240 --> 00:29:04,850
topic but it's also used in distributed

00:29:02,669 --> 00:29:07,890
system this is about clocks

00:29:04,850 --> 00:29:10,580
well you know systems

00:29:07,890 --> 00:29:13,080
you know that clocks are out of sync

00:29:10,580 --> 00:29:16,830
well it's not a big deal if you know how

00:29:13,080 --> 00:29:18,780
to deal with that but why is that first

00:29:16,830 --> 00:29:20,460
of all there is general relativity and

00:29:18,780 --> 00:29:21,690
fundamental problems with shrinking

00:29:20,460 --> 00:29:24,660
clocks but that's not what we are

00:29:21,690 --> 00:29:26,550
talking here usually that's probably a

00:29:24,660 --> 00:29:27,860
problem for Google with atomic clocks

00:29:26,550 --> 00:29:30,270
but but not for us

00:29:27,860 --> 00:29:32,670
but in practice clocks who happens

00:29:30,270 --> 00:29:36,600
because we don't have access to atomic

00:29:32,670 --> 00:29:38,250
clocks and even if you use network time

00:29:36,600 --> 00:29:40,550
protocol we have to live with something

00:29:38,250 --> 00:29:42,780
like 20 milliseconds or so between

00:29:40,550 --> 00:29:46,560
computers in the same rack or same data

00:29:42,780 --> 00:29:48,240
center so why is this a problem the

00:29:46,560 --> 00:29:49,620
problem is if we take time stamps on

00:29:48,240 --> 00:29:52,410
different machines we cannot compare

00:29:49,620 --> 00:29:54,870
them if this time stamp is smaller than

00:29:52,410 --> 00:29:57,330
that or the other machine it seems that

00:29:54,870 --> 00:29:59,670
this event has happened before that but

00:29:57,330 --> 00:30:02,370
that might not be true it's might just

00:29:59,670 --> 00:30:04,590
be a clock running late so therefore for

00:30:02,370 --> 00:30:07,500
all sorts of problems whenever you want

00:30:04,590 --> 00:30:10,110
to understand happens after we are in

00:30:07,500 --> 00:30:12,030
some kind of series do do imagine we

00:30:10,110 --> 00:30:14,220
want to study locks of different servers

00:30:12,030 --> 00:30:16,350
we want to compare the time stamps to

00:30:14,220 --> 00:30:18,600
understand what happened when and well

00:30:16,350 --> 00:30:20,700
the time sins aren't correct that's a

00:30:18,600 --> 00:30:24,570
bit of a problem we want to measure

00:30:20,700 --> 00:30:26,580
network delays we want to maybe sort out

00:30:24,570 --> 00:30:28,800
conflicts arising when we write in

00:30:26,580 --> 00:30:30,090
different machines so the problems are

00:30:28,800 --> 00:30:34,410
all over the place what can you do about

00:30:30,090 --> 00:30:37,830
it we want to implement time to live or

00:30:34,410 --> 00:30:41,220
whatever it's it's a problem so here

00:30:37,830 --> 00:30:47,730
again it's just a very nice idea what to

00:30:41,220 --> 00:30:49,980
do if I say logical clocks then this is

00:30:47,730 --> 00:30:53,070
some kind of idea where you say okay

00:30:49,980 --> 00:30:54,690
a clock might just be an clock value

00:30:53,070 --> 00:30:57,150
might just be a number but and I don't

00:30:54,690 --> 00:30:59,430
care if it doesn't have to do much with

00:30:57,150 --> 00:31:02,270
reality that's another concept this is a

00:30:59,430 --> 00:31:06,930
mixture between locks logical clocks and

00:31:02,270 --> 00:31:09,660
proper clocks so here's what you do what

00:31:06,930 --> 00:31:12,120
you want is that if two events on

00:31:09,660 --> 00:31:15,660
different machines are somehow linked by

00:31:12,120 --> 00:31:18,510
causality so if something happens first

00:31:15,660 --> 00:31:21,660
and causes something else to happen on

00:31:18,510 --> 00:31:23,880
the other machine that is where it is

00:31:21,660 --> 00:31:26,640
important that the first time stamp is

00:31:23,880 --> 00:31:28,800
smaller than the second that's

00:31:26,640 --> 00:31:31,290
essentially all you care if you have

00:31:28,800 --> 00:31:32,940
completely unrelated events it doesn't

00:31:31,290 --> 00:31:37,460
really matter what the lock or the time

00:31:32,940 --> 00:31:42,450
stamp it says so therefore you I

00:31:37,460 --> 00:31:44,400
identify causality with a message has

00:31:42,450 --> 00:31:47,090
been sent because in a distributed

00:31:44,400 --> 00:31:49,290
computer system the only way where

00:31:47,090 --> 00:31:51,390
something can cause something else on

00:31:49,290 --> 00:31:54,330
another machine is if there was a

00:31:51,390 --> 00:31:55,350
network message between them so

00:31:54,330 --> 00:31:57,090
therefore for the moment we say

00:31:55,350 --> 00:31:59,250
causality is the same as message and

00:31:57,090 --> 00:32:05,520
here's what you do every computer has a

00:31:59,250 --> 00:32:08,610
local clock and we send a timestamp with

00:32:05,520 --> 00:32:10,260
every single message sent from server to

00:32:08,610 --> 00:32:14,940
server P that's not about a lot of

00:32:10,260 --> 00:32:20,040
traffic and whenever we receive a

00:32:14,940 --> 00:32:24,000
message we take notice of the largest

00:32:20,040 --> 00:32:27,240
timestamp we have ever seen and when a

00:32:24,000 --> 00:32:30,870
machine wants to read a timestamp of the

00:32:27,240 --> 00:32:35,280
hybrid logical clock it simply returns

00:32:30,870 --> 00:32:39,170
the maximum of its local clock and the

00:32:35,280 --> 00:32:43,350
largest x temperature it has ever seen

00:32:39,170 --> 00:32:46,440
so if a message is sent from A to B so

00:32:43,350 --> 00:32:49,740
imagine somebody went on server a it was

00:32:46,440 --> 00:32:52,110
assigned a time stamp then you send a

00:32:49,740 --> 00:32:56,220
message with every message we take a

00:32:52,110 --> 00:32:59,850
time stamp send it over and take notice

00:32:56,220 --> 00:33:02,370
of it in server P if this now causes

00:32:59,850 --> 00:33:05,730
some other event on server B and we take

00:33:02,370 --> 00:33:08,280
a timestamp of that as well then the

00:33:05,730 --> 00:33:12,300
following happens the clock on the

00:33:08,280 --> 00:33:14,930
second system might be late but since we

00:33:12,300 --> 00:33:18,020
take the maximum of the local clock and

00:33:14,930 --> 00:33:20,730
the largest times that we have ever seen

00:33:18,020 --> 00:33:22,410
we have in particular seen a timestamp

00:33:20,730 --> 00:33:26,040
which is higher than the timestamp of

00:33:22,410 --> 00:33:27,990
the event on a therefore the timestamp

00:33:26,040 --> 00:33:31,850
we take for the second event is larger

00:33:27,990 --> 00:33:34,920
and causality is preserved and the

00:33:31,850 --> 00:33:35,600
additional benefit is that if there's no

00:33:34,920 --> 00:33:37,880
events

00:33:35,600 --> 00:33:41,150
then eventually obviously and no

00:33:37,880 --> 00:33:44,000
messages then eventually the local club

00:33:41,150 --> 00:33:46,070
clock will catch up with these largest

00:33:44,000 --> 00:33:50,150
times I've ever seen and we are back to

00:33:46,070 --> 00:33:53,299
real time so that's the good compromise

00:33:50,150 --> 00:33:55,010
so therefore causality is preserved time

00:33:53,299 --> 00:33:56,990
can catch up with logical time

00:33:55,010 --> 00:34:00,350
eventually and therefore it's a good

00:33:56,990 --> 00:34:01,880
concept so in a distributed system you

00:34:00,350 --> 00:34:04,070
might do something like this you want to

00:34:01,880 --> 00:34:06,260
organize transactions or resolve

00:34:04,070 --> 00:34:08,810
conflicts or whatever you take these

00:34:06,260 --> 00:34:11,570
times terms of hybrid logical clocks all

00:34:08,810 --> 00:34:13,760
you have to do is take along with every

00:34:11,570 --> 00:34:17,119
message take a time stamp send it along

00:34:13,760 --> 00:34:20,149
and take notice of it at the target so

00:34:17,119 --> 00:34:22,790
it's very very easy to implement and it

00:34:20,149 --> 00:34:28,790
gives you a good approximation to this

00:34:22,790 --> 00:34:30,169
kind of causality you want okay next

00:34:28,790 --> 00:34:34,369
topic ten minutes left

00:34:30,169 --> 00:34:36,379
great again this link has a nice

00:34:34,369 --> 00:34:38,659
description of what's going on on some

00:34:36,379 --> 00:34:40,070
proofs and so on and hints for

00:34:38,659 --> 00:34:43,129
implementation that is actually for

00:34:40,070 --> 00:34:49,399
change not difficult to implement so

00:34:43,129 --> 00:34:51,740
that's one of the benefits here now this

00:34:49,399 --> 00:34:55,580
is the topic I cannot tell you very much

00:34:51,740 --> 00:34:58,190
about because it's really the hardest

00:34:55,580 --> 00:35:01,460
and it essentially will use all of this

00:34:58,190 --> 00:35:04,100
stuff I've already talked to you now

00:35:01,460 --> 00:35:06,170
what is the problem from a traditional

00:35:04,100 --> 00:35:09,800
data store on one machine say a

00:35:06,170 --> 00:35:12,650
relational database you are used to have

00:35:09,800 --> 00:35:15,230
asset guarantees so you are used that if

00:35:12,650 --> 00:35:17,600
you do a transaction then it happens

00:35:15,230 --> 00:35:19,780
atomically so it either happens in its

00:35:17,600 --> 00:35:23,090
entirety or it doesn't have them at all

00:35:19,780 --> 00:35:24,710
you don't have to get a result saying oh

00:35:23,090 --> 00:35:26,900
I've maybe done half of this transaction

00:35:24,710 --> 00:35:30,700
but I don't know what I did yeah this is

00:35:26,900 --> 00:35:30,700
doesn't doesn't happen very good

00:35:31,000 --> 00:35:37,490
therefore the data store you see is in a

00:35:34,250 --> 00:35:40,760
consistent state every transaction might

00:35:37,490 --> 00:35:42,440
have happened or not so you always see a

00:35:40,760 --> 00:35:45,470
consistent state of the data which is

00:35:42,440 --> 00:35:46,850
good there's another concept of

00:35:45,470 --> 00:35:50,330
consistency having to do with

00:35:46,850 --> 00:35:52,800
replication that is something else here

00:35:50,330 --> 00:35:55,710
transactions are isolated so different

00:35:52,800 --> 00:35:58,650
transactions which run concurrently by

00:35:55,710 --> 00:36:02,640
which I mean one starts before the other

00:35:58,650 --> 00:36:04,350
has finished and vice-versa if they run

00:36:02,640 --> 00:36:07,500
concurrently they cannot see each other

00:36:04,350 --> 00:36:09,360
and there's various isolation levels you

00:36:07,500 --> 00:36:11,610
probably know the sequel standard and

00:36:09,360 --> 00:36:13,770
stuff essentially the message is

00:36:11,610 --> 00:36:15,600
concurrent transactions don't see each

00:36:13,770 --> 00:36:19,440
other and in particular you don't see

00:36:15,600 --> 00:36:21,090
half a transaction being executed and of

00:36:19,440 --> 00:36:24,240
course you want durable that if the

00:36:21,090 --> 00:36:27,210
database says yes I've written it you

00:36:24,240 --> 00:36:29,040
want that it has been written and if you

00:36:27,210 --> 00:36:31,200
go back to see you if the data is there

00:36:29,040 --> 00:36:32,960
the answer is yes it's there that is

00:36:31,200 --> 00:36:36,390
what you want it's rather obvious

00:36:32,960 --> 00:36:38,970
however in a distributed sitting it's

00:36:36,390 --> 00:36:46,230
much harder to achieve all this then on

00:36:38,970 --> 00:36:49,020
a single server why is that first of all

00:36:46,230 --> 00:36:51,540
if you have replication if you have

00:36:49,020 --> 00:36:54,120
different servers or even if you just

00:36:51,540 --> 00:36:56,850
have multiple servers being in the same

00:36:54,120 --> 00:36:59,670
transactional system you probably want

00:36:56,850 --> 00:37:02,460
that they agree on the fact whether this

00:36:59,670 --> 00:37:04,890
transaction has committed or not yet

00:37:02,460 --> 00:37:06,690
committed or was aborted there's no

00:37:04,890 --> 00:37:08,370
point in having one server believing the

00:37:06,690 --> 00:37:11,610
transaction is committed and the other

00:37:08,370 --> 00:37:12,720
not that would be rather bad so

00:37:11,610 --> 00:37:21,450
therefore you have a problem with

00:37:12,720 --> 00:37:22,950
atomicity if your data is distributed so

00:37:21,450 --> 00:37:24,660
not everything is thought on every

00:37:22,950 --> 00:37:27,150
machine and they run raft or whatever to

00:37:24,660 --> 00:37:29,520
replicate you probably want to see a

00:37:27,150 --> 00:37:32,490
consistent state so you want to ask

00:37:29,520 --> 00:37:34,530
various machines for the data and what

00:37:32,490 --> 00:37:36,360
you expect is that you will see the

00:37:34,530 --> 00:37:39,090
result of a certain set of transactions

00:37:36,360 --> 00:37:40,980
which have committed and not see

00:37:39,090 --> 00:37:43,950
anything which happened afterwards that

00:37:40,980 --> 00:37:46,190
is what I mean by consistent state well

00:37:43,950 --> 00:37:49,940
if they can't really agree on things

00:37:46,190 --> 00:37:54,000
it's kind of difficult to organize that

00:37:49,940 --> 00:37:55,980
now isolation is a problem as well if

00:37:54,000 --> 00:37:57,720
you have a distributed datastore and you

00:37:55,980 --> 00:37:59,220
have to do for some transaction you have

00:37:57,720 --> 00:38:02,220
to do some changes here some changes

00:37:59,220 --> 00:38:03,150
here some changes there and you have to

00:38:02,220 --> 00:38:04,740
make sure

00:38:03,150 --> 00:38:06,240
that there you cannot you cannot make

00:38:04,740 --> 00:38:08,220
sure that they happen at the same time

00:38:06,240 --> 00:38:11,130
so therefore they happen one after

00:38:08,220 --> 00:38:14,910
another with these time stem problems

00:38:11,130 --> 00:38:16,440
you probably don't even know when but

00:38:14,910 --> 00:38:19,560
still people expect that the all

00:38:16,440 --> 00:38:23,400
transaction is invisible until somebody

00:38:19,560 --> 00:38:26,240
has decided that it's now committed so

00:38:23,400 --> 00:38:28,500
isolation is a problem as well and

00:38:26,240 --> 00:38:30,180
durability is a problem because in a

00:38:28,500 --> 00:38:33,900
distributed system you'll live with the

00:38:30,180 --> 00:38:36,360
fact that a machine can just go now what

00:38:33,900 --> 00:38:40,050
is your durability worth if some of the

00:38:36,360 --> 00:38:42,870
data can just go nothing so therefore

00:38:40,050 --> 00:38:45,030
you need replication yeah you need to

00:38:42,870 --> 00:38:46,710
have redundant copies of your data

00:38:45,030 --> 00:38:48,780
something which everybody tells you in

00:38:46,710 --> 00:38:52,380
the first class of data stores and

00:38:48,780 --> 00:38:55,110
databases don't yeah you have to do it

00:38:52,380 --> 00:38:56,970
for the simple reason of durability then

00:38:55,110 --> 00:38:59,100
of course now you have copies of data

00:38:56,970 --> 00:39:00,750
now the other consistency comes into

00:38:59,100 --> 00:39:05,100
play you have to make sure that these

00:39:00,750 --> 00:39:06,840
copies of your data agree even if they

00:39:05,100 --> 00:39:09,300
are written on at different times and

00:39:06,840 --> 00:39:10,530
isolation is a problem and then if

00:39:09,300 --> 00:39:12,570
something goes wrong you have to

00:39:10,530 --> 00:39:15,510
organise failover you have to make sure

00:39:12,570 --> 00:39:17,010
that the right copy is now read maybe

00:39:15,510 --> 00:39:19,950
you have three copies how do you decide

00:39:17,010 --> 00:39:21,180
which one is the right one anyway if you

00:39:19,950 --> 00:39:25,560
think about all these things then you

00:39:21,180 --> 00:39:28,140
notice it's actually quite hard and you

00:39:25,560 --> 00:39:31,170
get you solely get desperate you see you

00:39:28,140 --> 00:39:33,930
what to do can we do this at all and if

00:39:31,170 --> 00:39:36,030
you look at what data stores do hang on

00:39:33,930 --> 00:39:38,970
do something is wrong here if you look

00:39:36,030 --> 00:39:41,360
at what data's there's two very few

00:39:38,970 --> 00:39:44,370
actually give you proper asset

00:39:41,360 --> 00:39:46,320
distributed transactions if you look at

00:39:44,370 --> 00:39:48,060
this list here and I've put a wrangle DB

00:39:46,320 --> 00:39:50,550
here because we don't offer it at this

00:39:48,060 --> 00:39:58,410
stage is there something wrong here oh

00:39:50,550 --> 00:40:01,260
yes thank you very much so very few

00:39:58,410 --> 00:40:03,090
actually pull this trick off maybe the

00:40:01,260 --> 00:40:06,900
traditional the most traditional one is

00:40:03,090 --> 00:40:09,300
spanner Google spanner famous paper they

00:40:06,900 --> 00:40:11,940
actually pull off distributed

00:40:09,300 --> 00:40:14,610
transactions with atomic clocks and very

00:40:11,940 --> 00:40:15,990
tricky things with consensus and time

00:40:14,610 --> 00:40:18,510
stamps and so on

00:40:15,990 --> 00:40:20,790
and more recently players like cockroach

00:40:18,510 --> 00:40:24,810
TBH they replicate in an open source way

00:40:20,790 --> 00:40:27,300
what spanner did and foundation BB which

00:40:24,810 --> 00:40:29,520
was vanished for some time but has

00:40:27,300 --> 00:40:33,750
reappeared now because Apple has first

00:40:29,520 --> 00:40:37,530
bought it and then open sourced it and

00:40:33,750 --> 00:40:40,859
also we have a plan to get there but

00:40:37,530 --> 00:40:43,500
it's all a big big problem however I

00:40:40,859 --> 00:40:45,109
would say five years ago people would

00:40:43,500 --> 00:40:48,750
essentially say well it's too difficult

00:40:45,109 --> 00:40:51,270
don't yeah I'll live with the fact that

00:40:48,750 --> 00:40:54,240
you don't have acid in distributed

00:40:51,270 --> 00:40:57,839
systems use no sequel databases which

00:40:54,240 --> 00:41:01,530
don't give you acid and but but the mood

00:40:57,839 --> 00:41:03,570
is changing open source players are

00:41:01,530 --> 00:41:05,099
offering distributed transactions maybe

00:41:03,570 --> 00:41:08,070
not yet with the performance you would

00:41:05,099 --> 00:41:11,820
like to there are compromises beings

00:41:08,070 --> 00:41:14,550
Rises being made MongoDB has announced

00:41:11,820 --> 00:41:16,380
transactions which is a big change for

00:41:14,550 --> 00:41:18,330
them I think they have announced

00:41:16,380 --> 00:41:20,849
distributed transactions for next year

00:41:18,330 --> 00:41:22,050
so slowly people are getting round and

00:41:20,849 --> 00:41:25,740
saying well it's maybe it's not

00:41:22,050 --> 00:41:30,410
impossible after all and I believe it is

00:41:25,740 --> 00:41:33,510
not impossible it's just very hard

00:41:30,410 --> 00:41:39,390
anyway we have a plan to do it we

00:41:33,510 --> 00:41:42,380
hopefully get it out before MongoDB but

00:41:39,390 --> 00:41:45,030
stay tuned this will be interesting now

00:41:42,380 --> 00:41:46,740
it's only three minutes I have left and

00:41:45,030 --> 00:41:48,960
therefore I definitely won't tell you

00:41:46,740 --> 00:41:51,240
how to do that just to give you an idea

00:41:48,960 --> 00:41:54,630
also to somehow put together some of the

00:41:51,240 --> 00:41:57,780
things we did one thing which is to my

00:41:54,630 --> 00:42:01,020
mind pretty clear is that a database any

00:41:57,780 --> 00:42:02,970
database giving transactions has to keep

00:42:01,020 --> 00:42:05,640
multiple copies of your keys of your

00:42:02,970 --> 00:42:07,859
data why is that well you might have

00:42:05,640 --> 00:42:10,619
concurrent transactions where one of

00:42:07,859 --> 00:42:13,650
them has started very early so it needs

00:42:10,619 --> 00:42:15,630
to see the old version but if it's

00:42:13,650 --> 00:42:17,040
already committed by now it wasn't

00:42:15,630 --> 00:42:19,470
committed to in the when the transaction

00:42:17,040 --> 00:42:22,500
started but it was committed when

00:42:19,470 --> 00:42:24,540
another transaction now has started so

00:42:22,500 --> 00:42:26,960
rather obviously you need multiple

00:42:24,540 --> 00:42:29,090
versions so that's what's called

00:42:26,960 --> 00:42:31,520
multiple version concurrent

00:42:29,090 --> 00:42:34,400
they control so I believe some kind of

00:42:31,520 --> 00:42:36,680
this you need you have to keep multiple

00:42:34,400 --> 00:42:41,120
revisions of your documents or key value

00:42:36,680 --> 00:42:44,420
pairs now you will have to do rights and

00:42:41,120 --> 00:42:46,340
replications D centrally because you

00:42:44,420 --> 00:42:48,860
want to scale out you want to have

00:42:46,340 --> 00:42:52,940
multiple machines available you have to

00:42:48,860 --> 00:42:54,710
do replication for durability but you

00:42:52,940 --> 00:42:58,700
have to do it in a way such that they

00:42:54,710 --> 00:43:01,340
are not yet visible and then when the

00:42:58,700 --> 00:43:04,490
crime time comes for commit you have to

00:43:01,340 --> 00:43:07,310
have someplace and maybe that's a raft

00:43:04,490 --> 00:43:10,670
ensemble or maybe multiple ones there

00:43:07,310 --> 00:43:14,530
has to be some place some switch which

00:43:10,670 --> 00:43:17,510
really is the truth in your system of

00:43:14,530 --> 00:43:20,210
this this transaction has committed or

00:43:17,510 --> 00:43:23,120
has not yet committed or was aborted so

00:43:20,210 --> 00:43:25,160
one single point of truth you need maybe

00:43:23,120 --> 00:43:27,530
not a single point again it has to be

00:43:25,160 --> 00:43:29,540
replicated as well so it has to be

00:43:27,530 --> 00:43:32,060
persisted it has to scale out it cannot

00:43:29,540 --> 00:43:33,920
be a single raft instance it has to be

00:43:32,060 --> 00:43:36,110
replicated because you definitely don't

00:43:33,920 --> 00:43:39,530
want to lose the information that a

00:43:36,110 --> 00:43:42,500
transaction was committed and it has to

00:43:39,530 --> 00:43:45,280
be resilient for fall two runs and so

00:43:42,500 --> 00:43:47,270
you have to run all these things and

00:43:45,280 --> 00:43:49,910
then of course you have to implement

00:43:47,270 --> 00:43:51,890
transaction visibility based on these

00:43:49,910 --> 00:43:53,240
switches so whenever you want to see a

00:43:51,890 --> 00:43:55,340
piece of data well there's different

00:43:53,240 --> 00:43:58,070
versions available you have to consider

00:43:55,340 --> 00:44:00,140
all the switches associated with the

00:43:58,070 --> 00:44:02,240
transactions which wrote these pieces of

00:44:00,140 --> 00:44:04,220
data and you have to decide which

00:44:02,240 --> 00:44:07,820
particular version actually is visible

00:44:04,220 --> 00:44:09,890
on the other hand I believe it can be

00:44:07,820 --> 00:44:12,170
done it will come at some performance

00:44:09,890 --> 00:44:14,660
cost hopefully we can pull it off in a

00:44:12,170 --> 00:44:16,730
way such that single document operations

00:44:14,660 --> 00:44:19,580
are still the same speed we'll see

00:44:16,730 --> 00:44:22,700
anyway it's a very interesting topic but

00:44:19,580 --> 00:44:25,010
I don't have any more time to talk about

00:44:22,700 --> 00:44:26,930
it so I stop here thank you very much I

00:44:25,010 --> 00:44:28,790
don't know whether we have much time for

00:44:26,930 --> 00:44:30,550
questions but I will be around to answer

00:44:28,790 --> 00:44:33,699
questions afterwards Thanks

00:44:30,550 --> 00:44:33,699
[Applause]

00:44:33,970 --> 00:44:40,819
and two more comments obviously we are

00:44:38,809 --> 00:44:43,730
hiring too and I've put a few t-shirts

00:44:40,819 --> 00:44:47,230
here please help yourself they are

00:44:43,730 --> 00:44:50,960
color-coded with a size now I'm finished

00:44:47,230 --> 00:45:00,530
okay thank you I think we have time for

00:44:50,960 --> 00:45:03,170
one question so question alright yes if

00:45:00,530 --> 00:45:06,410
in the rough protocol only a leader is

00:45:03,170 --> 00:45:08,420
allowed to append doesn't that in some

00:45:06,410 --> 00:45:13,990
ways over the resolve the drifts and

00:45:08,420 --> 00:45:17,510
collection of different machines so you

00:45:13,990 --> 00:45:20,270
well the thing is the the replicas will

00:45:17,510 --> 00:45:23,000
simply say I'm not the leader go away to

00:45:20,270 --> 00:45:26,569
the leader or they forward the request

00:45:23,000 --> 00:45:29,180
to the leader the leader will write and

00:45:26,569 --> 00:45:30,980
then replicate and if you want to have

00:45:29,180 --> 00:45:34,250
time stamps you would take the time

00:45:30,980 --> 00:45:37,670
stamp of the leader now obviously if the

00:45:34,250 --> 00:45:41,569
leader changes you run the risk of the

00:45:37,670 --> 00:45:43,460
time running backwards and that is

00:45:41,569 --> 00:45:45,940
something not even hybrid logical clocks

00:45:43,460 --> 00:45:48,079
fix for you because if the leader goes

00:45:45,940 --> 00:45:51,740
then you don't know what times them to

00:45:48,079 --> 00:45:53,210
take yes this is a problem but usually

00:45:51,740 --> 00:45:55,579
with a replicated lock you are less

00:45:53,210 --> 00:45:57,260
interested in time stamps and you are

00:45:55,579 --> 00:46:06,849
more interest in the sequence of events

00:45:57,260 --> 00:46:06,849
in the lock alright so thanks again max

00:46:07,030 --> 00:46:10,030
okay

00:46:10,150 --> 00:46:32,159
[Applause]

00:46:11,630 --> 00:46:32,159

YouTube URL: https://www.youtube.com/watch?v=GOeQykU1iN8


