Title: OSDC 2016 - NoSQL is a Lie by Mike Elsmore
Publication date: 2016-05-02
Playlist: OSDC 2016 | Open Source Data Center Conference
Description: 
	NoSQL is a term on the rise, and it's a lie. NoSQL is a catch-all term and I will point out why a catch all means missing tools that may help solve your problems. Going through a few popular DB's we will walk through the use cases and why they're good at what they do.
Captions: 
	00:00:11,539 --> 00:00:18,419
okay good morning everyone we're

00:00:14,969 --> 00:00:22,110
starting the first talk on this Trek for

00:00:18,419 --> 00:00:25,289
today it's about the lie of no no sequel

00:00:22,110 --> 00:00:32,040
presented to you by mike s more so

00:00:25,289 --> 00:00:34,050
please give him a warm welcome just

00:00:32,040 --> 00:00:36,989
chatting okay I works right morning

00:00:34,050 --> 00:00:40,350
everybody there's a title as the

00:00:36,989 --> 00:00:41,730
obligatory slide for me being here this

00:00:40,350 --> 00:00:43,469
is legal disclaimer because I have to

00:00:41,730 --> 00:00:45,239
work at a massive corporation I have to

00:00:43,469 --> 00:00:46,530
say that this allows me to talk about

00:00:45,239 --> 00:00:50,280
anything I want without have to worry

00:00:46,530 --> 00:00:52,590
about somebody suing me so Who am I i am

00:00:50,280 --> 00:00:55,800
mike elsmore i am developer advocate I

00:00:52,590 --> 00:01:00,149
be mcds there's my email if you wish to

00:00:55,800 --> 00:01:01,500
send me hate mail afterwards and so I've

00:01:00,149 --> 00:01:04,979
just remembered I have my clicker in my

00:01:01,500 --> 00:01:09,570
pocket I be mcds anyone ever heard of

00:01:04,979 --> 00:01:13,979
that thing stony silence I'll tell

00:01:09,570 --> 00:01:16,499
doesn't know right we are a SAS part of

00:01:13,979 --> 00:01:18,630
IBM so all we do is we take all this

00:01:16,499 --> 00:01:22,679
stuff majority of it is open source

00:01:18,630 --> 00:01:24,179
except for that one no actually that's

00:01:22,679 --> 00:01:25,979
the open source one though we had that

00:01:24,179 --> 00:01:28,409
one and that one aren't open source

00:01:25,979 --> 00:01:30,810
otherwise all we do is take open source

00:01:28,409 --> 00:01:33,060
software and operationalize it it's like

00:01:30,810 --> 00:01:34,670
you most of my day is spent hammering

00:01:33,060 --> 00:01:36,840
away at keyboard seeing what happens

00:01:34,670 --> 00:01:38,039
sometime around lunch I will end up

00:01:36,840 --> 00:01:39,749
scratching my beard trying to get well

00:01:38,039 --> 00:01:41,639
the attempt at bit i have right now

00:01:39,749 --> 00:01:43,770
going what the hell is happened today

00:01:41,639 --> 00:01:45,420
and usually by the end of my day I look

00:01:43,770 --> 00:01:46,679
like this because my prototypes are not

00:01:45,420 --> 00:01:49,499
working and I can't work out when

00:01:46,679 --> 00:01:51,389
nothing is going right and I'm going to

00:01:49,499 --> 00:01:53,340
apologize now i am not a morning person

00:01:51,389 --> 00:01:55,859
i am not caffeinated enough to give this

00:01:53,340 --> 00:01:59,479
talk so if there's any mistakes I do

00:01:55,859 --> 00:02:03,719
apologize it's one I'm British into I

00:01:59,479 --> 00:02:05,369
really tired so I've got to admit I am

00:02:03,719 --> 00:02:08,009
NOT an expert in any of these things I

00:02:05,369 --> 00:02:10,319
am NOT a DBA i'm a developer i just have

00:02:08,009 --> 00:02:12,020
to play with a lot of things and have

00:02:10,319 --> 00:02:14,910
may have worked out some of the

00:02:12,020 --> 00:02:17,910
fallacies around this whilst doing so

00:02:14,910 --> 00:02:20,250
and even more importantly when it comes

00:02:17,910 --> 00:02:22,950
to some of it it's very much my opinion

00:02:20,250 --> 00:02:25,500
it is not fact if it's in fact it's

00:02:22,950 --> 00:02:29,530
probably off Wikipedia

00:02:25,500 --> 00:02:31,840
right now I have a mildly inflammatory

00:02:29,530 --> 00:02:36,129
title no SQL is a lie who here believes

00:02:31,840 --> 00:02:37,360
in that title two people I'm hoping to

00:02:36,129 --> 00:02:39,549
convince the rest of you by the end of

00:02:37,360 --> 00:02:43,599
this talk who here is aware of no SQL

00:02:39,549 --> 00:02:48,579
technologies and uses them right so most

00:02:43,599 --> 00:02:51,040
of you believe in the lie so first we

00:02:48,579 --> 00:02:55,480
have to begin with the rant and this bit

00:02:51,040 --> 00:02:59,170
really does get me quite angry the whole

00:02:55,480 --> 00:03:01,510
terminology around it no SQL and it was

00:02:59,170 --> 00:03:04,900
originally coined by Carlos trasi in

00:03:01,510 --> 00:03:07,930
1998 for his straw zeno SQL database

00:03:04,900 --> 00:03:12,010
which i may add was relational it just

00:03:07,930 --> 00:03:14,409
didn't have an SQL interface so the

00:03:12,010 --> 00:03:18,700
whole ah no SQL stands for everything

00:03:14,409 --> 00:03:20,019
that isn't relational is a lie and then

00:03:18,700 --> 00:03:22,870
there's this horrible horrible thought

00:03:20,019 --> 00:03:27,220
that if it isn't SQL it's no SQL who

00:03:22,870 --> 00:03:29,470
believes in that Oh nobody's going to

00:03:27,220 --> 00:03:31,930
admit to that because the horrible thing

00:03:29,470 --> 00:03:35,169
is with postgres is last two releases

00:03:31,930 --> 00:03:37,269
they've had baked in a JSON instance for

00:03:35,169 --> 00:03:39,310
you to actually post things too oh well

00:03:37,269 --> 00:03:43,090
isn't that what every no SQL database

00:03:39,310 --> 00:03:45,400
does and this is horrible thing that was

00:03:43,090 --> 00:03:49,269
started by kanaeva pronounce his name

00:03:45,400 --> 00:03:52,810
correctly on Johanna ass Kison in 2009

00:03:49,269 --> 00:03:54,730
when he started a event he wanted to

00:03:52,810 --> 00:03:56,739
describe them all so instead of like

00:03:54,730 --> 00:03:58,449
picking all the correct names and

00:03:56,739 --> 00:04:00,370
working everything out individually he

00:03:58,449 --> 00:04:03,069
just picked everything and when he's a

00:04:00,370 --> 00:04:05,139
no SQL stuff so it became this horrible

00:04:03,069 --> 00:04:07,359
backronym which went web two point O

00:04:05,139 --> 00:04:13,419
technologist two point O technologies

00:04:07,359 --> 00:04:16,630
are no SQL they're really not so no SQL

00:04:13,419 --> 00:04:19,150
no SQL has SQL who here's how to play

00:04:16,630 --> 00:04:22,539
with Cassandra sparkle or even couch

00:04:19,150 --> 00:04:24,310
bases SQL technologies recently right

00:04:22,539 --> 00:04:27,870
just like curiously does that mean there

00:04:24,310 --> 00:04:27,870
is SQL on no SQL

00:04:28,080 --> 00:04:35,039
is it an sqlite language do you read in

00:04:30,750 --> 00:04:37,530
for it okay they're ignoring that but

00:04:35,039 --> 00:04:40,469
more importantly Sparkle and c ql both

00:04:37,530 --> 00:04:42,330
of them are SQL interpretive languages

00:04:40,469 --> 00:04:46,770
that yes they don't contain joins but

00:04:42,330 --> 00:04:51,180
they still work like SQL to me that

00:04:46,770 --> 00:04:54,080
means there is SQL on no SQL agreed yeah

00:04:51,180 --> 00:04:56,610
okay so the whole no SQL is a lie

00:04:54,080 --> 00:04:59,719
there's a lot of the it's a lie bit

00:04:56,610 --> 00:05:03,300
coming along because it annoys me a lot

00:04:59,719 --> 00:05:05,520
so as this great fallacy with them as

00:05:03,300 --> 00:05:07,680
well which is no SQL database is a

00:05:05,520 --> 00:05:14,159
scheme loss who would admit to know SQL

00:05:07,680 --> 00:05:16,500
database as a scheme Alice Oh nobody

00:05:14,159 --> 00:05:25,680
else going to bite that bullet you think

00:05:16,500 --> 00:05:27,750
that don't you it is very much depending

00:05:25,680 --> 00:05:30,330
on the technology but still the most

00:05:27,750 --> 00:05:34,379
common kind of narrow skill databases

00:05:30,330 --> 00:05:36,900
being go CouchDB and Cassandra

00:05:34,379 --> 00:05:38,460
they all are ski Milus you can throw in

00:05:36,900 --> 00:05:41,250
different shaped objects and it will

00:05:38,460 --> 00:05:44,370
adapt to it that is a complete not a lie

00:05:41,250 --> 00:05:45,900
as developers you implement a schema

00:05:44,370 --> 00:05:47,430
because you don't know what's going into

00:05:45,900 --> 00:05:49,949
the database you have no idea what

00:05:47,430 --> 00:05:51,659
you're getting out so by nature it has a

00:05:49,949 --> 00:05:53,969
schema it's just been set by the

00:05:51,659 --> 00:05:56,819
developer in the application not to buy

00:05:53,969 --> 00:06:01,279
a goddamn schema list inside of the

00:05:56,819 --> 00:06:01,279
guard down tables anyone agree with this

00:06:02,360 --> 00:06:06,960
nobody's got a couple of knots ok i'll

00:06:05,610 --> 00:06:09,449
take that as people agree that you are

00:06:06,960 --> 00:06:12,740
implementing a schema on top of a scheme

00:06:09,449 --> 00:06:15,810
alert system thus you have a schema

00:06:12,740 --> 00:06:22,879
there's also this one who believes they

00:06:15,810 --> 00:06:25,919
are now SQL expert you you admit that

00:06:22,879 --> 00:06:27,569
there are too many types of may s no SQL

00:06:25,919 --> 00:06:30,360
expert for you to be a database expert

00:06:27,569 --> 00:06:35,310
in that there are just too many distinct

00:06:30,360 --> 00:06:36,959
types so please follow the slovak if you

00:06:35,310 --> 00:06:42,560
can be an expert in the specific ecology

00:06:36,959 --> 00:06:42,560
are you at to use or Cassandra

00:06:43,370 --> 00:06:52,890
that's not a no SQL Oh carries it you

00:06:50,730 --> 00:06:54,810
can't be an expert because the way each

00:06:52,890 --> 00:06:57,150
different type works it completely

00:06:54,810 --> 00:07:00,450
different you wouldn't treat a key value

00:06:57,150 --> 00:07:02,540
store like a graph database you wouldn't

00:07:00,450 --> 00:07:05,040
use a document store as a time series

00:07:02,540 --> 00:07:06,750
they are very much different things you

00:07:05,040 --> 00:07:08,700
can be an expert in implementing and

00:07:06,750 --> 00:07:10,320
running with the type the specific

00:07:08,700 --> 00:07:13,110
technology but you can't be an ex pain

00:07:10,320 --> 00:07:17,130
although SQL at once as far as I know

00:07:13,110 --> 00:07:20,190
currently there is over 90 different no

00:07:17,130 --> 00:07:21,480
SQL technologies if you're an expert all

00:07:20,190 --> 00:07:23,850
of them I need to get on my knees and

00:07:21,480 --> 00:07:25,680
bow down to you right now if you're an

00:07:23,850 --> 00:07:27,150
expert in fifty percent of them I need

00:07:25,680 --> 00:07:28,860
to bow down to you because you know a

00:07:27,150 --> 00:07:32,970
hell of a lot more than anybody on the

00:07:28,860 --> 00:07:36,660
planet I know so that's the end of my

00:07:32,970 --> 00:07:40,470
rant does everybody agree with that ran

00:07:36,660 --> 00:07:42,060
so far am I factually incorrect I have

00:07:40,470 --> 00:07:43,770
an open heckle policy so if you believe

00:07:42,060 --> 00:07:45,390
I am wrong the only way I'm going to

00:07:43,770 --> 00:07:47,430
learn and fix this is by you telling me

00:07:45,390 --> 00:07:52,080
who here disagrees with me on those

00:07:47,430 --> 00:07:53,460
statements am I being coming across way

00:07:52,080 --> 00:07:57,030
too aggressive for you to say anything

00:07:53,460 --> 00:07:59,820
to me right I take that as a yes right

00:07:57,030 --> 00:08:03,450
so I need to calm down i need to be cool

00:07:59,820 --> 00:08:07,320
I need to slow things down a bit I do

00:08:03,450 --> 00:08:08,280
like my gifts can you tell all right now

00:08:07,320 --> 00:08:09,960
I'm going to have to drop some science

00:08:08,280 --> 00:08:14,070
on you for all of the rent next bit to

00:08:09,960 --> 00:08:15,750
make sense I do apologize if I start

00:08:14,070 --> 00:08:17,340
talking really really fast it's because

00:08:15,750 --> 00:08:19,230
I get a little bit animated about this

00:08:17,340 --> 00:08:22,610
stuff and I like it so if I'm talking

00:08:19,230 --> 00:08:26,850
too fast just ask me to slow down ok

00:08:22,610 --> 00:08:29,910
that was the yes/no answer there we go

00:08:26,850 --> 00:08:34,140
thank you right so enter cap theorem or

00:08:29,910 --> 00:08:35,910
bow cos law who knows about this right

00:08:34,140 --> 00:08:38,849
so you're all aware of how it integrates

00:08:35,910 --> 00:08:40,530
with distributed systems etc so what

00:08:38,849 --> 00:08:42,930
Barbara's law breaks down into is

00:08:40,530 --> 00:08:45,270
consistency availability and partition

00:08:42,930 --> 00:08:48,330
tolerance they're the three cardinal

00:08:45,270 --> 00:08:50,070
pieces of it so we're consistency it

00:08:48,330 --> 00:08:51,720
means what you put in is what you get

00:08:50,070 --> 00:08:54,080
out so if you put a record with one

00:08:51,720 --> 00:08:56,220
object in and it is one

00:08:54,080 --> 00:08:59,040
containing string a you will get the

00:08:56,220 --> 00:09:01,380
stringy out as part of that object it's

00:08:59,040 --> 00:09:04,680
quite simple then iterate something XO

00:09:01,380 --> 00:09:07,020
rach you that have availability so is a

00:09:04,680 --> 00:09:09,090
system always available or will it fall

00:09:07,020 --> 00:09:11,640
on over for god knows what reason at

00:09:09,090 --> 00:09:13,620
some point in the day and then there's

00:09:11,640 --> 00:09:16,890
partition tolerance well that actually

00:09:13,620 --> 00:09:19,950
means is the system can actually take

00:09:16,890 --> 00:09:21,660
network faults but in my mind it

00:09:19,950 --> 00:09:23,250
actually means it knows where the data

00:09:21,660 --> 00:09:24,630
is it knows which char doubt the

00:09:23,250 --> 00:09:26,790
triplicates it's usually written into

00:09:24,630 --> 00:09:32,550
its point to that so it knows where to

00:09:26,790 --> 00:09:34,230
look for things in theory so in cap that

00:09:32,550 --> 00:09:35,670
little thing there I love it the fact

00:09:34,230 --> 00:09:37,440
they still in the Venn diagrams I think

00:09:35,670 --> 00:09:39,570
it should be a white space rather than

00:09:37,440 --> 00:09:41,190
the colored space we're trying to

00:09:39,570 --> 00:09:43,590
explain that to the designer person is

00:09:41,190 --> 00:09:44,790
really quite hard because I can't draw

00:09:43,590 --> 00:09:46,410
diagrams or anything I can't use

00:09:44,790 --> 00:09:51,600
photoshop so I didn't even attempt to

00:09:46,410 --> 00:09:55,400
make this so you can be ca AP CP but you

00:09:51,600 --> 00:09:59,580
can't bc AP okay okay with everybody

00:09:55,400 --> 00:10:00,660
it's a completely pic to scenario so

00:09:59,580 --> 00:10:03,330
it's kind of like Heisenberg's

00:10:00,660 --> 00:10:04,650
uncertainty principle you can know where

00:10:03,330 --> 00:10:06,420
something is or how fast it's going

00:10:04,650 --> 00:10:11,510
button off both the same times it's not

00:10:06,420 --> 00:10:13,440
make sense so why is this important

00:10:11,510 --> 00:10:14,850
there's a little bit of history behind

00:10:13,440 --> 00:10:16,980
this and some of this will be a lot of

00:10:14,850 --> 00:10:22,650
pain that who here has been developing

00:10:16,980 --> 00:10:24,330
for more than say eight years right so

00:10:22,650 --> 00:10:25,620
the things I'm going to go through now

00:10:24,330 --> 00:10:28,140
are all things that we're going to have

00:10:25,620 --> 00:10:32,070
cried about in the last well in that

00:10:28,140 --> 00:10:38,580
eight to six year block with the turn of

00:10:32,070 --> 00:10:41,340
commodity Hardware on the internet now

00:10:38,580 --> 00:10:44,940
about to explain it it's all about

00:10:41,340 --> 00:10:47,040
distributed computing so you can be

00:10:44,940 --> 00:10:48,450
consistent or available because in a

00:10:47,040 --> 00:10:49,920
distributed system you have to know

00:10:48,450 --> 00:10:52,500
where everything is so you have to be

00:10:49,920 --> 00:10:53,640
partitioned tolerant so you have to be

00:10:52,500 --> 00:10:56,730
partitioned tolerant so you can only

00:10:53,640 --> 00:10:59,340
select one of the other two so how they

00:10:56,730 --> 00:11:02,970
got around this was in distributed

00:10:59,340 --> 00:11:05,070
systems oh sorry next slide distributed

00:11:02,970 --> 00:11:07,410
systems need to know what we're all the

00:11:05,070 --> 00:11:09,959
data is because

00:11:07,410 --> 00:11:11,360
everything is in specific location so

00:11:09,959 --> 00:11:13,649
that means your partition tolerant and

00:11:11,360 --> 00:11:15,120
consistent or available I've

00:11:13,649 --> 00:11:16,709
double-checked the number of spaces that

00:11:15,120 --> 00:11:19,740
does represent consistent and available

00:11:16,709 --> 00:11:23,750
exactly I counted them so there was this

00:11:19,740 --> 00:11:27,779
major design decision with most of the

00:11:23,750 --> 00:11:29,370
no SQL technology as a time so i can t

00:11:27,779 --> 00:11:31,319
be being my favorite at the moment well

00:11:29,370 --> 00:11:34,290
favorite of all time at the motive to be

00:11:31,319 --> 00:11:36,990
honest with it going for an AP approach

00:11:34,290 --> 00:11:38,670
and so they decide to pick where

00:11:36,990 --> 00:11:41,009
everything was on the machines but then

00:11:38,670 --> 00:11:42,480
they decide to drop consistency so you

00:11:41,009 --> 00:11:44,220
have this eventual consistency model

00:11:42,480 --> 00:11:46,079
which trust me when you try explaining

00:11:44,220 --> 00:11:48,089
it to people who've been doing db2 for

00:11:46,079 --> 00:11:51,480
10 years or more it's a real pain in the

00:11:48,089 --> 00:11:53,639
backside to explain so with these things

00:11:51,480 --> 00:11:56,220
everything because aren't distributed

00:11:53,639 --> 00:11:59,250
machines if a machine drops down if

00:11:56,220 --> 00:12:00,540
you're going for availability if that

00:11:59,250 --> 00:12:04,829
machine's gone your service isn't

00:12:00,540 --> 00:12:06,750
available so you have multiple machines

00:12:04,829 --> 00:12:07,920
and that means if one machine goes down

00:12:06,750 --> 00:12:10,620
there's a couple of machines up straight

00:12:07,920 --> 00:12:11,670
okay take it down the problem is there

00:12:10,620 --> 00:12:13,800
if you want to be consistent across

00:12:11,670 --> 00:12:15,839
those three machines if you're on a high

00:12:13,800 --> 00:12:19,560
traffic system and you're receiving

00:12:15,839 --> 00:12:21,930
millions of requests per second it is

00:12:19,560 --> 00:12:25,319
going to be impossible due to network

00:12:21,930 --> 00:12:27,000
lag and anything to do with iol on the

00:12:25,319 --> 00:12:29,370
machines to make sure each of the three

00:12:27,000 --> 00:12:31,560
machines is that in the identical step

00:12:29,370 --> 00:12:33,269
at that point so if you want to be

00:12:31,560 --> 00:12:34,470
available you cannot be consistent if

00:12:33,269 --> 00:12:38,069
you want to be consistent you cannot be

00:12:34,470 --> 00:12:39,389
available does that make sense how much

00:12:38,069 --> 00:12:54,930
you remember your distributed their

00:12:39,389 --> 00:12:57,569
theorem that is correct it is impossible

00:12:54,930 --> 00:13:00,259
at any production level on any large

00:12:57,569 --> 00:13:03,000
system to maintain a complete cap set

00:13:00,259 --> 00:13:04,889
just due to the fact that each machine

00:13:03,000 --> 00:13:07,019
is running independently there is a

00:13:04,889 --> 00:13:08,459
network and I on the machine so they

00:13:07,019 --> 00:13:10,529
could be running on different hardware

00:13:08,459 --> 00:13:12,149
setups one could be running on an AWS

00:13:10,529 --> 00:13:14,189
system so using virtual hardware another

00:13:12,149 --> 00:13:16,410
could be running on bare metal using

00:13:14,189 --> 00:13:17,639
SSDs because the fact that completely

00:13:16,410 --> 00:13:19,559
different you cannot maintain

00:13:17,639 --> 00:13:21,550
consistency across all machines if

00:13:19,559 --> 00:13:22,839
you're available aiming for availability

00:13:21,550 --> 00:13:24,220
if you aim for consistency and drop

00:13:22,839 --> 00:13:26,380
availability all you do is you start

00:13:24,220 --> 00:13:28,240
right locking and you consist you make

00:13:26,380 --> 00:13:29,410
it consists across all the machines but

00:13:28,240 --> 00:13:30,570
then you can't read it because you've

00:13:29,410 --> 00:13:38,320
locked the system to be able to write

00:13:30,570 --> 00:13:40,720
does that make sense thank you right

00:13:38,320 --> 00:13:42,459
however just to be completely fair there

00:13:40,720 --> 00:13:44,290
is this thing called new SQL who's heard

00:13:42,459 --> 00:13:47,950
of this I only discovered it about three

00:13:44,290 --> 00:13:50,440
months ago right new SQL comes out

00:13:47,950 --> 00:13:54,579
primarily google and the project Google

00:13:50,440 --> 00:13:56,380
spanner which is a further iteration on

00:13:54,579 --> 00:13:58,630
BigTable big table being you know

00:13:56,380 --> 00:14:00,310
they're big no SQL infrastructure that

00:13:58,630 --> 00:14:03,730
everybody can get onto as part of the

00:14:00,310 --> 00:14:05,829
app cloud spanner is an attempt well

00:14:03,730 --> 00:14:09,730
it's a quite successful attempt to

00:14:05,829 --> 00:14:12,370
create a SQL system which is consistent

00:14:09,730 --> 00:14:14,769
and available across machines a contra

00:14:12,370 --> 00:14:17,380
it there are nuts there's a specific

00:14:14,769 --> 00:14:20,019
algorithm it's using to maintain this

00:14:17,380 --> 00:14:21,279
state across all machines and I really

00:14:20,019 --> 00:14:22,690
should have written that down here on my

00:14:21,279 --> 00:14:26,260
speaker notes so i could run to tell you

00:14:22,690 --> 00:14:27,700
what it is we shall help maintain it at

00:14:26,260 --> 00:14:29,730
the moment this is still quite expensive

00:14:27,700 --> 00:14:31,570
because it does rely on a lot of

00:14:29,730 --> 00:14:35,980
hardware to just maintain the

00:14:31,570 --> 00:14:38,140
consistency for example each machine has

00:14:35,980 --> 00:14:40,180
to have a connection to a gps an atomic

00:14:38,140 --> 00:14:42,160
clock to contain state to make sure it

00:14:40,180 --> 00:14:44,709
keeps state between everything so that's

00:14:42,160 --> 00:14:46,420
kind of bulky however google spanic is

00:14:44,709 --> 00:14:48,130
being used across the entirety of google

00:14:46,420 --> 00:14:49,839
and consider we all know how big their

00:14:48,130 --> 00:14:52,390
infrastructure and how big they do their

00:14:49,839 --> 00:14:55,300
things you got although it's kind of

00:14:52,390 --> 00:14:56,560
resilient and kind of works the only

00:14:55,300 --> 00:14:58,270
reason I found out about this was

00:14:56,560 --> 00:15:01,390
because of something called cockroach DB

00:14:58,270 --> 00:15:03,730
who's out of this turns out some guys

00:15:01,390 --> 00:15:04,930
from google decided they wanted to make

00:15:03,730 --> 00:15:06,490
an open-source version of it for

00:15:04,930 --> 00:15:09,130
everybody they're in the process of

00:15:06,490 --> 00:15:10,420
producing get is cap cockroach DB it's

00:15:09,130 --> 00:15:12,579
really quite good but it's still quite

00:15:10,420 --> 00:15:14,829
early stages but this solves the whole

00:15:12,579 --> 00:15:17,560
consistency and availability thing by

00:15:14,829 --> 00:15:20,949
completely changing how it actually

00:15:17,560 --> 00:15:25,690
interprets I oh and reads for it you can

00:15:20,949 --> 00:15:27,279
have cap but not with no SQL right so

00:15:25,690 --> 00:15:31,870
the types we're going to cover today are

00:15:27,279 --> 00:15:34,420
key value document column and graph I'm

00:15:31,870 --> 00:15:35,470
going to go through just roughly what

00:15:34,420 --> 00:15:36,490
they are so that p

00:15:35,470 --> 00:15:38,050
you aren't aware of the different types

00:15:36,490 --> 00:15:39,310
now they are in some use cases for them

00:15:38,050 --> 00:15:42,790
so now we know that we can get the right

00:15:39,310 --> 00:15:45,280
tool for the job there are hundreds of

00:15:42,790 --> 00:15:48,400
other different types one two three four

00:15:45,280 --> 00:15:50,590
five and there's a bunch of others we're

00:15:48,400 --> 00:15:51,970
completely skipping multi-model because

00:15:50,590 --> 00:15:53,770
it's where they've designed the system

00:15:51,970 --> 00:15:55,420
to be in memory and have multiple index

00:15:53,770 --> 00:15:57,340
types so you can interpret it as

00:15:55,420 --> 00:15:59,050
different kinds of databases it's kind

00:15:57,340 --> 00:16:00,730
of hard to talk about different types

00:15:59,050 --> 00:16:02,350
when one of them kind of does it all

00:16:00,730 --> 00:16:04,060
it's like saying I'm going to bring a

00:16:02,350 --> 00:16:06,970
knife to a fight now I'm just going to

00:16:04,060 --> 00:16:10,780
bring the army right so we're going to

00:16:06,970 --> 00:16:15,010
completely skip across multi-model is

00:16:10,780 --> 00:16:16,780
that ok cool this bit as you've made a

00:16:15,010 --> 00:16:22,360
toll is going to contain some audience

00:16:16,780 --> 00:16:25,960
participation who's up for that there we

00:16:22,360 --> 00:16:29,980
go happy smiling people you are right so

00:16:25,960 --> 00:16:31,720
we've got key value data stores you know

00:16:29,980 --> 00:16:33,520
they're these things that are

00:16:31,720 --> 00:16:35,290
essentially hashes dictionaries arrays

00:16:33,520 --> 00:16:37,090
whatever you want to call them so you

00:16:35,290 --> 00:16:40,300
look up on the key you get the value

00:16:37,090 --> 00:16:49,210
it's kind of self-explanatory who can

00:16:40,300 --> 00:16:50,470
name some fun berkeley DB yes bun yes I

00:16:49,210 --> 00:16:51,760
didn't realize that was actually a key

00:16:50,470 --> 00:17:00,970
value store until relatively recently

00:16:51,760 --> 00:17:04,960
it's amazing yeah anymore technically

00:17:00,970 --> 00:17:06,640
but they're not at no SQL we stick it

00:17:04,960 --> 00:17:09,820
into SQL here I'm trying to prove the

00:17:06,640 --> 00:17:10,990
live now SQL first all right so I'll

00:17:09,820 --> 00:17:16,170
skip that slide because I didn't finish

00:17:10,990 --> 00:17:18,970
it but here is a lot of key value stores

00:17:16,170 --> 00:17:20,590
yet it's their open source and closed

00:17:18,970 --> 00:17:22,120
source by fought the only way to point

00:17:20,590 --> 00:17:25,320
out completeness would be to give you a

00:17:22,120 --> 00:17:27,550
complete list of everything I could find

00:17:25,320 --> 00:17:29,800
I've only actually experimented with

00:17:27,550 --> 00:17:30,790
about eight of these so when I was

00:17:29,800 --> 00:17:32,200
saying you can't be an expert in

00:17:30,790 --> 00:17:33,700
everything if you could be an expert all

00:17:32,200 --> 00:17:36,280
these key value stores and all the reg

00:17:33,700 --> 00:17:40,270
cases you're a genius and utter God

00:17:36,280 --> 00:17:42,280
among developers but yeah has anyone

00:17:40,270 --> 00:17:43,870
played with any of those that are all

00:17:42,280 --> 00:17:46,900
slightly more obscure and haven't been

00:17:43,870 --> 00:17:50,000
listed off because I really want to find

00:17:46,900 --> 00:17:51,990
a reason to play with some more of them

00:17:50,000 --> 00:17:54,630
okay i'll just have to invent another

00:17:51,990 --> 00:17:56,820
reason for myself so what is the key

00:17:54,630 --> 00:17:59,669
value store it's kind of simple it's a

00:17:56,820 --> 00:18:02,279
key and a value you pull it out these

00:17:59,669 --> 00:18:04,740
usually are complete available system so

00:18:02,279 --> 00:18:05,669
that ap based so they rely on the fact

00:18:04,740 --> 00:18:07,169
that everything is going to be the

00:18:05,669 --> 00:18:09,299
lightning quick on the index is so that

00:18:07,169 --> 00:18:10,919
they don't lock up the system it does

00:18:09,299 --> 00:18:14,100
mean a lot of them relying on memory or

00:18:10,919 --> 00:18:15,870
SSDs to run quickly so it's usually nice

00:18:14,100 --> 00:18:17,399
to have a cluster of big fat memory

00:18:15,870 --> 00:18:20,340
filled machines without language discs

00:18:17,399 --> 00:18:23,549
to do the job it seems quite reasonable

00:18:20,340 --> 00:18:24,690
and they're just as I was saying hashes

00:18:23,549 --> 00:18:27,360
dictionaries of rain whatever you want

00:18:24,690 --> 00:18:28,919
to call them that's just what they are

00:18:27,360 --> 00:18:33,299
you just call it as if you wouldn't any

00:18:28,919 --> 00:18:35,340
code why would you use key value stores

00:18:33,299 --> 00:18:37,500
right anything you want really really

00:18:35,340 --> 00:18:39,299
quick without any form of complex query

00:18:37,500 --> 00:18:42,210
ink that is what you want an index for

00:18:39,299 --> 00:18:45,899
most common use cases I've seen our and

00:18:42,210 --> 00:18:47,840
I've used myself is for q's sessions and

00:18:45,899 --> 00:18:49,529
just ridiculously fast lockups I

00:18:47,840 --> 00:18:51,950
shouldn't press the button while some

00:18:49,529 --> 00:18:54,149
halfway through stuck in my own hand and

00:18:51,950 --> 00:18:55,590
it's really really simple model but

00:18:54,149 --> 00:18:59,940
really really powerful when you're doing

00:18:55,590 --> 00:19:04,830
the correct thing with it now we have

00:18:59,940 --> 00:19:10,440
document databases yes my favorite bit

00:19:04,830 --> 00:19:12,149
who can name some of these said

00:19:10,440 --> 00:19:14,759
couchbase yeah that's it there's a

00:19:12,149 --> 00:19:18,019
document database technically it's what

00:19:14,759 --> 00:19:20,940
happened when members and can't you be

00:19:18,019 --> 00:19:23,269
smooshed together it's like the love

00:19:20,940 --> 00:19:25,919
child of them the proprietary technology

00:19:23,269 --> 00:19:27,629
anyone for anything else I shall just

00:19:25,919 --> 00:19:31,320
skip to the next slide with a big list

00:19:27,629 --> 00:19:33,690
of them MongoDB yes the most popular one

00:19:31,320 --> 00:19:35,519
in the world without a fact it's just so

00:19:33,690 --> 00:19:37,679
easy to run with it's just that popular

00:19:35,519 --> 00:19:41,220
and the query language is really simple

00:19:37,679 --> 00:19:42,600
to get right your head round so Cloudant

00:19:41,220 --> 00:19:46,559
because they paid me to come here so I

00:19:42,600 --> 00:19:49,230
put their name first of course and then

00:19:46,559 --> 00:19:51,210
there's CouchDB couchbase rethink

00:19:49,230 --> 00:19:52,470
DB which is essentially MongoDB but when

00:19:51,210 --> 00:19:54,960
somebody went out the engine is not good

00:19:52,470 --> 00:19:56,510
enough or rewrite our own and then oh my

00:19:54,960 --> 00:19:58,710
favorite one is well there couchdb

00:19:56,510 --> 00:20:01,500
technically an in-memory database for

00:19:58,710 --> 00:20:02,340
browsers also a node library also

00:20:01,500 --> 00:20:07,919
something done

00:20:02,340 --> 00:20:10,710
leveldb I like it a lot anyone heard of

00:20:07,919 --> 00:20:13,980
any of those that anyone played with any

00:20:10,710 --> 00:20:16,140
of these I haven't seen before so like

00:20:13,980 --> 00:20:19,580
Tara still only found that two days ago

00:20:16,140 --> 00:20:24,299
when I was researching my slides again

00:20:19,580 --> 00:20:25,890
nope ok so what a document store it's

00:20:24,299 --> 00:20:27,570
usually considered to be a subclass of

00:20:25,890 --> 00:20:30,120
key value store because of the way the

00:20:27,570 --> 00:20:32,220
primaries look up system works but most

00:20:30,120 --> 00:20:34,730
document databases have a secondary

00:20:32,220 --> 00:20:37,860
lookup system so a query language or

00:20:34,730 --> 00:20:40,500
MapReduce like CouchDB or different

00:20:37,860 --> 00:20:44,370
implementations of them you can find

00:20:40,500 --> 00:20:46,260
some old CouchDB that have a plug-in

00:20:44,370 --> 00:20:47,760
which allows you to just roll leucine

00:20:46,260 --> 00:20:49,770
inside of its architecture so you can

00:20:47,760 --> 00:20:51,590
have a leucine so that on top of that we

00:20:49,770 --> 00:20:54,059
also then implement to that in Cloudant

00:20:51,590 --> 00:20:56,940
but there are you know different ways of

00:20:54,059 --> 00:20:58,409
doing it so it's quite resilient to

00:20:56,940 --> 00:20:59,399
different kinds of queries and different

00:20:58,409 --> 00:21:02,789
kinds of lookups different things you

00:20:59,399 --> 00:21:06,120
need to do to it and what would you use

00:21:02,789 --> 00:21:08,850
them for these are operational databases

00:21:06,120 --> 00:21:10,529
so they are the thing you would do your

00:21:08,850 --> 00:21:13,200
normal day-to-day work in they store

00:21:10,529 --> 00:21:16,919
your users your products your individual

00:21:13,200 --> 00:21:19,080
records you and because they are no SQL

00:21:16,919 --> 00:21:20,700
schema-less you can just iterate and

00:21:19,080 --> 00:21:22,350
make the documents larger or smaller is

00:21:20,700 --> 00:21:24,299
necessary you can have nested records

00:21:22,350 --> 00:21:27,690
within them to have a normalized ish

00:21:24,299 --> 00:21:29,549
sort of system but the documents since

00:21:27,690 --> 00:21:30,570
out and the metadata now provides you

00:21:29,549 --> 00:21:32,789
with everything you need to do the

00:21:30,570 --> 00:21:34,440
querying so the individual keys then

00:21:32,789 --> 00:21:39,330
become things you can look upon if you

00:21:34,440 --> 00:21:42,360
write the correct indexes on them most

00:21:39,330 --> 00:21:44,850
of these systems and do follow the

00:21:42,360 --> 00:21:46,799
eventual consistency model so couchbase

00:21:44,850 --> 00:21:48,149
does but it because it does a lot of its

00:21:46,799 --> 00:21:51,750
work in memory its eventual consistency

00:21:48,149 --> 00:21:53,700
is freaking tiny Cloudant because it

00:21:51,750 --> 00:21:56,309
writes the disk slightly larger CouchDB

00:21:53,700 --> 00:22:01,169
same bag essentially anything that

00:21:56,309 --> 00:22:03,149
follows the DynamoDB sort of white paper

00:22:01,169 --> 00:22:04,860
approach to distributed systems has this

00:22:03,149 --> 00:22:06,480
eventual consistency model just because

00:22:04,860 --> 00:22:09,899
of the way it has to maintain step

00:22:06,480 --> 00:22:12,990
between all machines but this does mean

00:22:09,899 --> 00:22:14,399
you still have the flexibility of

00:22:12,990 --> 00:22:17,250
changing your schema as you would with

00:22:14,399 --> 00:22:21,760
any other scheme Alice

00:22:17,250 --> 00:22:25,810
yeah well right next up column data

00:22:21,760 --> 00:22:28,210
stores he wants to take a shot and

00:22:25,810 --> 00:22:31,630
naming some of these there aren't that

00:22:28,210 --> 00:22:33,100
many yes that's my favorite at the

00:22:31,630 --> 00:22:35,110
moment even though trying to implement

00:22:33,100 --> 00:22:37,960
something that forces gossip to behave

00:22:35,110 --> 00:22:41,140
is painful if you like gossip just do

00:22:37,960 --> 00:22:46,120
its thing it's amazing but if anyone

00:22:41,140 --> 00:22:48,300
want to try and name any others okay but

00:22:46,120 --> 00:22:51,700
there aren't that many this time

00:22:48,300 --> 00:22:52,720
Cassandra HBase and the Coomer lower the

00:22:51,700 --> 00:22:54,400
only ones i've really played with

00:22:52,720 --> 00:22:56,380
nobody'll give me credit to play with

00:22:54,400 --> 00:22:58,450
google clouds big table so i haven't had

00:22:56,380 --> 00:23:02,650
chance to play later anyone who played

00:22:58,450 --> 00:23:05,830
with big table i really need to find a

00:23:02,650 --> 00:23:09,400
good reason to play with it but these

00:23:05,830 --> 00:23:12,270
are once again used as operational data

00:23:09,400 --> 00:23:14,650
stores for a lot of things it does

00:23:12,270 --> 00:23:16,720
internally actually hold things in a

00:23:14,650 --> 00:23:18,880
table like structure when you look at a

00:23:16,720 --> 00:23:21,130
table in Cassandra internally it kind of

00:23:18,880 --> 00:23:24,150
looks like an Excel spreadsheet where

00:23:21,130 --> 00:23:26,350
there instead of having null values the

00:23:24,150 --> 00:23:27,730
field just won't exist if you haven't

00:23:26,350 --> 00:23:31,660
posted in but it will still be stored

00:23:27,730 --> 00:23:33,130
roughly as a table purely because that's

00:23:31,660 --> 00:23:35,230
how it builds its indexes so it just

00:23:33,130 --> 00:23:37,360
goes yeah as an index it's an index it's

00:23:35,230 --> 00:23:39,190
an index makes it quite fast to look up

00:23:37,360 --> 00:23:41,560
it makes it quite useful especially

00:23:39,190 --> 00:23:42,850
things like Sandra where it doesn't hurt

00:23:41,560 --> 00:23:44,530
it doesn't worry too much about the

00:23:42,850 --> 00:23:47,200
eventual consistency model because for

00:23:44,530 --> 00:23:49,210
low-level merging of information it has

00:23:47,200 --> 00:23:50,680
a vector timestamp which allows it to

00:23:49,210 --> 00:23:52,570
tell well this one's newer than that one

00:23:50,680 --> 00:23:54,550
so that must be the same and all provide

00:23:52,570 --> 00:23:57,340
you with a winning revision that is a

00:23:54,550 --> 00:23:59,350
lot more accurate they are kind of

00:23:57,340 --> 00:24:00,640
relational in that way so you do look at

00:23:59,350 --> 00:24:02,560
one table you do pull in and out of

00:24:00,640 --> 00:24:04,030
there it's the reason why I cql works

00:24:02,560 --> 00:24:07,950
brilliantly is because it gives you this

00:24:04,030 --> 00:24:13,000
flat sql-like implementation on top of a

00:24:07,950 --> 00:24:14,290
relational ish system and the brilliant

00:24:13,000 --> 00:24:16,690
thing is because of the fact you can

00:24:14,290 --> 00:24:18,940
just post and pull out their changes

00:24:16,690 --> 00:24:20,380
schemers you want the table fields kind

00:24:18,940 --> 00:24:22,930
of just expand and contract with each

00:24:20,380 --> 00:24:24,730
row as necessary that's how it kind of

00:24:22,930 --> 00:24:26,170
works internally for Cassandra can't

00:24:24,730 --> 00:24:28,420
remember how it works for HBase but I

00:24:26,170 --> 00:24:28,930
can't imagine it being classified as a

00:24:28,420 --> 00:24:32,850
white

00:24:28,930 --> 00:24:34,930
and not following the same sort of model

00:24:32,850 --> 00:24:36,730
so why would you use them once again

00:24:34,930 --> 00:24:38,020
there are operational store kind of

00:24:36,730 --> 00:24:40,480
relational and these things are

00:24:38,020 --> 00:24:42,520
massively distributed they are designed

00:24:40,480 --> 00:24:43,840
for massive network failure who here has

00:24:42,520 --> 00:24:49,090
read the stuff about chaos monkey at

00:24:43,840 --> 00:24:50,920
Netflix everybody here should read the

00:24:49,090 --> 00:24:52,660
paper on chaos monkey at Netflix one it

00:24:50,920 --> 00:24:54,340
will make you hate what they do because

00:24:52,660 --> 00:24:57,490
they just seem to do it all so much

00:24:54,340 --> 00:24:59,050
better than you let's just turn off an

00:24:57,490 --> 00:25:02,440
entire region to see what happens to our

00:24:59,050 --> 00:25:04,240
system in production I could I would

00:25:02,440 --> 00:25:05,620
spend a decade trying to convince my

00:25:04,240 --> 00:25:07,840
boss that we should try this and I'll

00:25:05,620 --> 00:25:09,730
still never work and you know what they

00:25:07,840 --> 00:25:12,730
do this on a regular basis the chaos

00:25:09,730 --> 00:25:14,410
monkey system and I think it's khong the

00:25:12,730 --> 00:25:16,600
one that just knocks out regions and

00:25:14,410 --> 00:25:19,150
chaos monkey which knocks out individual

00:25:16,600 --> 00:25:20,800
machines these things are designed to be

00:25:19,150 --> 00:25:22,120
resilient machines just dropping off the

00:25:20,800 --> 00:25:24,310
network so it's redistributing

00:25:22,120 --> 00:25:27,040
information internally quite naturally

00:25:24,310 --> 00:25:28,810
so if you want it they're great you can

00:25:27,040 --> 00:25:30,700
also use them for time series there is

00:25:28,810 --> 00:25:32,320
actually a specific type of database for

00:25:30,700 --> 00:25:34,690
time series which contains databases

00:25:32,320 --> 00:25:37,000
like druid but Cassandra because of its

00:25:34,690 --> 00:25:39,220
hull vector time stamp stuff does mean

00:25:37,000 --> 00:25:40,690
it does times a time series quite well

00:25:39,220 --> 00:25:42,250
because the way it just keeps iterating

00:25:40,690 --> 00:25:46,240
on the time stamp giving you an index on

00:25:42,250 --> 00:25:48,550
it this is my favorite one at the moment

00:25:46,240 --> 00:25:50,320
graph data stores these things are

00:25:48,550 --> 00:25:52,600
insane when you look at the architecture

00:25:50,320 --> 00:25:54,370
for then you cry the genius of these

00:25:52,600 --> 00:25:55,750
people and then worry about where

00:25:54,370 --> 00:26:00,720
they're going to go rampaging through

00:25:55,750 --> 00:26:00,720
next I don't want to try naming some

00:26:02,010 --> 00:26:07,630
that's technically a multi-model which

00:26:05,470 --> 00:26:09,400
is painful because everybody can say it

00:26:07,630 --> 00:26:13,950
except it's a multi-model worse off at

00:26:09,400 --> 00:26:16,720
the skipper off my slides any others

00:26:13,950 --> 00:26:18,220
near Forge yeah that's right that's the

00:26:16,720 --> 00:26:20,770
most popular most well-known one

00:26:18,220 --> 00:26:22,330
technically not open source open cipher

00:26:20,770 --> 00:26:25,650
isn't even open source because everybody

00:26:22,330 --> 00:26:27,580
on their commit board is from the foj

00:26:25,650 --> 00:26:31,330
will make it open source and then

00:26:27,580 --> 00:26:37,590
control everything defeats the point

00:26:31,330 --> 00:26:40,360
people right so these ones near forge a

00:26:37,590 --> 00:26:41,920
giraffe Titan Titans my favorite because

00:26:40,360 --> 00:26:42,730
we've been rolling that internally for a

00:26:41,920 --> 00:26:44,710
new product

00:26:42,730 --> 00:26:46,540
as part of a tinker pop stack it's

00:26:44,710 --> 00:26:49,330
insane because it then just goes mirror

00:26:46,540 --> 00:26:50,260
and lows deep also tightens EV doesn't

00:26:49,330 --> 00:26:52,900
actually store any of its own

00:26:50,260 --> 00:26:54,760
information just as an FYI title UV is

00:26:52,900 --> 00:26:58,720
weird it stores it in another type of

00:26:54,760 --> 00:27:01,419
database mostly Berkeley DB Cassandra or

00:26:58,720 --> 00:27:02,679
HBase you plug that underneath it and

00:27:01,419 --> 00:27:05,049
that's where it stores your information

00:27:02,679 --> 00:27:06,549
but it's still a graph database because

00:27:05,049 --> 00:27:08,799
it does everything in memory it grabs it

00:27:06,549 --> 00:27:11,470
often these reserved datasets drums

00:27:08,799 --> 00:27:13,720
grabs it together data munches it and

00:27:11,470 --> 00:27:18,010
then pass it back out at you is a graph

00:27:13,720 --> 00:27:20,290
which is great so what are graphs data

00:27:18,010 --> 00:27:24,130
stores sim who here remembers any other

00:27:20,290 --> 00:27:26,470
graph theorem ok I'll go through the

00:27:24,130 --> 00:27:28,630
basics of it and it's where you take

00:27:26,470 --> 00:27:30,790
distinct records nodes and the

00:27:28,630 --> 00:27:32,559
relationships between them edges are

00:27:30,790 --> 00:27:35,919
what are important so you have

00:27:32,559 --> 00:27:37,780
individual people so Dave Garrett Fred

00:27:35,919 --> 00:27:41,549
and the relationships between them of

00:27:37,780 --> 00:27:44,710
friends or family or spousal are the

00:27:41,549 --> 00:27:46,630
edges so you can hop along from Dave

00:27:44,710 --> 00:27:49,510
Derek afraid by going Dave as a friend

00:27:46,630 --> 00:27:50,950
of Derek who is the son of fred then

00:27:49,510 --> 00:27:53,169
these relationships provide you a very

00:27:50,950 --> 00:27:56,530
powerful means of categorizing and

00:27:53,169 --> 00:27:58,210
hopping around and it's really really

00:27:56,530 --> 00:27:59,770
quite powerful stuff because these are

00:27:58,210 --> 00:28:02,020
designed to run it in the million plus

00:27:59,770 --> 00:28:04,150
records all in memory so that it's just

00:28:02,020 --> 00:28:06,760
hopping around doing yes you can very

00:28:04,150 --> 00:28:08,679
easily cause cyclical path errors bike

00:28:06,760 --> 00:28:10,540
just going around in the circle millions

00:28:08,679 --> 00:28:12,429
of times if you write your query well

00:28:10,540 --> 00:28:13,840
enough you'll skip that if you give put

00:28:12,429 --> 00:28:15,940
a loop counter on there and you'll just

00:28:13,840 --> 00:28:17,470
have this wonderful path set where you

00:28:15,940 --> 00:28:20,590
can get some really really magical

00:28:17,470 --> 00:28:23,410
things who here remembers six degrees of

00:28:20,590 --> 00:28:25,210
Kevin Bacon the connection between Kevin

00:28:23,410 --> 00:28:27,640
Bacon than anyone else in the movie

00:28:25,210 --> 00:28:32,080
industry otherwise known as the Erdos

00:28:27,640 --> 00:28:33,549
number right after this session you

00:28:32,080 --> 00:28:35,320
should sit down Google six degrees of

00:28:33,549 --> 00:28:37,720
Kevin Bacon you will a laugh yourself

00:28:35,320 --> 00:28:40,090
senseless and be this whole hopping

00:28:37,720 --> 00:28:43,500
around between actor film actor film

00:28:40,090 --> 00:28:47,530
actor film at infinitum will make sense

00:28:43,500 --> 00:28:48,880
so why would you use a graft system you

00:28:47,530 --> 00:28:50,980
can do pretty much the same thing in

00:28:48,880 --> 00:28:53,110
graph as you can in SQL because in SQL

00:28:50,980 --> 00:28:55,240
and you can just think of a graph

00:28:53,110 --> 00:28:56,110
connection as a join so two datasets

00:28:55,240 --> 00:28:58,480
join

00:28:56,110 --> 00:29:00,610
data set join differences graphs are

00:28:58,480 --> 00:29:03,070
designed to do these joins at thousand

00:29:00,610 --> 00:29:05,260
levels deep whereas if you tried doing

00:29:03,070 --> 00:29:06,670
that in an SQL service i'm pretty sure

00:29:05,260 --> 00:29:08,950
you'd a run out of memory for the temp

00:29:06,670 --> 00:29:12,400
tables and be it would be the ugliest

00:29:08,950 --> 00:29:13,870
crew to debug ever so you would never

00:29:12,400 --> 00:29:16,090
run this an SQL because you would write

00:29:13,870 --> 00:29:18,160
lock you'd run out of memory well sorry

00:29:16,090 --> 00:29:21,130
read lock run out of memory and it just

00:29:18,160 --> 00:29:24,100
looks god-awful and really painful to go

00:29:21,130 --> 00:29:26,500
through so some of the best uses for

00:29:24,100 --> 00:29:28,960
this is social graphs das number Kevin

00:29:26,500 --> 00:29:31,150
Bacon and recommendation engines are

00:29:28,960 --> 00:29:33,340
traditionally a graph sort of solution

00:29:31,150 --> 00:29:35,620
so being able to look through thousands

00:29:33,340 --> 00:29:37,809
of product purchases by people matching

00:29:35,620 --> 00:29:39,370
them against different products and sort

00:29:37,809 --> 00:29:42,700
of smashing it together to give you a

00:29:39,370 --> 00:29:44,620
relevant list these are really good so

00:29:42,700 --> 00:29:46,330
this is finding patterns in data to give

00:29:44,620 --> 00:29:47,950
you a recommendation there is then the

00:29:46,330 --> 00:29:49,809
anti pattern which I keep forgetting

00:29:47,950 --> 00:29:51,640
about which is fraud detection where you

00:29:49,809 --> 00:29:53,230
take all these millions of transactions

00:29:51,640 --> 00:29:55,450
find the wise considered to be the

00:29:53,230 --> 00:29:57,450
general same pattern and then go oh

00:29:55,450 --> 00:30:01,660
there's a random payment from Saigon

00:29:57,450 --> 00:30:04,299
that's probably not real so you can find

00:30:01,660 --> 00:30:05,770
matches and things that do not match a

00:30:04,299 --> 00:30:07,540
given path in the side of a graph system

00:30:05,770 --> 00:30:09,429
which are really really good and as I

00:30:07,540 --> 00:30:12,190
said before you can offload those

00:30:09,429 --> 00:30:13,600
massive memory hungry queries on to a

00:30:12,190 --> 00:30:18,370
graph that you would normally run inside

00:30:13,600 --> 00:30:20,640
of an SQL service so that was me talking

00:30:18,370 --> 00:30:24,669
quite fast for quite a long time I'm

00:30:20,640 --> 00:30:29,790
really sorry thank you for the heckling

00:30:24,669 --> 00:30:33,370
I appreciate it appreciated it coffee so

00:30:29,790 --> 00:30:38,770
rejoice it's almost over I'm about ten

00:30:33,370 --> 00:30:42,640
minutes early as well nuts so what we've

00:30:38,770 --> 00:30:44,169
learnt no SQL is a lie who would agree

00:30:42,640 --> 00:30:46,150
with me on this statement hands are four

00:30:44,169 --> 00:30:48,460
hands down hands down means you believe

00:30:46,150 --> 00:30:54,120
us no SQL is a generic term that covers

00:30:48,460 --> 00:31:00,960
all databases wow you still believe that

00:30:54,120 --> 00:31:04,210
nobody believes me now SQL is a lie okay

00:31:00,960 --> 00:31:05,679
so we now understand why no SQL grow up

00:31:04,210 --> 00:31:07,840
it grew up from the age of commodity

00:31:05,679 --> 00:31:09,430
hardware increasing distributed systems

00:31:07,840 --> 00:31:13,650
making them affordable and a half anime

00:31:09,430 --> 00:31:13,650
tained stay across thousands of machines

00:31:13,770 --> 00:31:19,360
we now know it's a bit of the right

00:31:16,720 --> 00:31:20,860
database of the right job postgres is

00:31:19,360 --> 00:31:23,710
not the answer to all things neither is

00:31:20,860 --> 00:31:25,630
MongoDB neither is MySQL in some cases

00:31:23,710 --> 00:31:26,770
as well but you can just pick the right

00:31:25,630 --> 00:31:28,300
tool for the right job you've got a

00:31:26,770 --> 00:31:30,580
graph problem bigger graphs database

00:31:28,300 --> 00:31:31,750
you've got simple lookups you need to do

00:31:30,580 --> 00:31:33,880
why would you bother throwing that an

00:31:31,750 --> 00:31:38,320
SQL service and clogging it up throw at

00:31:33,880 --> 00:31:40,030
Redis right tool for the right job some

00:31:38,320 --> 00:31:42,910
different uses for these different

00:31:40,030 --> 00:31:45,700
databases did the use cases i gave you

00:31:42,910 --> 00:31:51,910
made sense would you agree with them

00:31:45,700 --> 00:31:53,860
roughly cool so yeah right tool for the

00:31:51,910 --> 00:31:57,730
right job I still use PHP and I love

00:31:53,860 --> 00:32:00,760
this picture respect the double claw so

00:31:57,730 --> 00:32:02,590
right tool for the right job makes life

00:32:00,760 --> 00:32:04,750
so much easier if you're using the right

00:32:02,590 --> 00:32:06,970
thing to get the job done as I said if

00:32:04,750 --> 00:32:08,200
you want to quick lookup use Redis if

00:32:06,970 --> 00:32:10,690
you want to be doing a really complex

00:32:08,200 --> 00:32:12,100
query use graph or SQL if you just want

00:32:10,690 --> 00:32:13,690
to have something small and portable

00:32:12,100 --> 00:32:15,070
which can be thrown into a mobile app

00:32:13,690 --> 00:32:17,470
which probably you want to go with

00:32:15,070 --> 00:32:20,530
CouchDB couchbase something really

00:32:17,470 --> 00:32:21,460
lightweight hit the wrong tool chances

00:32:20,530 --> 00:32:22,930
are you've all been in the same spot

00:32:21,460 --> 00:32:24,220
where the tool just doesn't fit the job

00:32:22,930 --> 00:32:26,680
you spend months and months ago around

00:32:24,220 --> 00:32:30,460
in circles trying to make it fit who's

00:32:26,680 --> 00:32:31,750
been in that situation yeah I'm pretty

00:32:30,460 --> 00:32:33,130
sure everybody who's a developer in this

00:32:31,750 --> 00:32:35,170
room should agree with me they've spent

00:32:33,130 --> 00:32:36,640
weeks and months just going this doesn't

00:32:35,170 --> 00:32:39,630
work like this I should find a better

00:32:36,640 --> 00:32:42,070
tool otherwise I'm wasting my time

00:32:39,630 --> 00:32:46,000
that's expecting more nods but ok I'll

00:32:42,070 --> 00:32:48,160
take that but if you do it right it's a

00:32:46,000 --> 00:32:49,810
thumbs up things can go in the right

00:32:48,160 --> 00:32:51,520
direction you can make things work the

00:32:49,810 --> 00:32:56,710
way you want them to work and it's all

00:32:51,520 --> 00:32:58,600
good so I'm Mike Hales more those are

00:32:56,710 --> 00:32:59,950
the details of my talk if you want to

00:32:58,600 --> 00:33:01,480
take a photo of that so you can steal

00:32:59,950 --> 00:33:04,020
any of the URLs and names of things I do

00:33:01,480 --> 00:33:04,020
so now

00:33:09,620 --> 00:33:29,060
right I need more coffee yah right there

00:33:19,200 --> 00:33:32,670
we go all right I need more coffee

00:33:29,060 --> 00:33:36,450
really need more coffee but what the

00:33:32,670 --> 00:33:48,690
questions oh is that a question or

00:33:36,450 --> 00:33:51,500
stretching bun olap right so the

00:33:48,690 --> 00:33:56,240
different can I compare now SQL for OLAP

00:33:51,500 --> 00:33:59,490
well now SQL services can be oltp or

00:33:56,240 --> 00:34:01,500
olap things like tink pop they actually

00:33:59,490 --> 00:34:04,110
can be both by having a batch processing

00:34:01,500 --> 00:34:06,210
back-end to do overlap queries so it

00:34:04,110 --> 00:34:10,260
kind of in the same way that spark

00:34:06,210 --> 00:34:14,550
submit works but they can also be oltp

00:34:10,260 --> 00:34:17,840
so the you can have in small clusters

00:34:14,550 --> 00:34:20,250
and an acid system so a single node of

00:34:17,840 --> 00:34:21,320
CouchDB is acid because what you're

00:34:20,250 --> 00:34:23,490
putting in is what you're getting out

00:34:21,320 --> 00:34:24,840
it's when you start getting into larger

00:34:23,490 --> 00:34:27,210
machines the moment you have to have

00:34:24,840 --> 00:34:31,440
that eventual consistency model for the

00:34:27,210 --> 00:34:34,649
AP machines you just lose acid it's you

00:34:31,440 --> 00:34:36,030
just can't be oltp at that point but you

00:34:34,649 --> 00:34:37,800
can be a lot because you can throw

00:34:36,030 --> 00:34:40,350
larger batch queries and just leave them

00:34:37,800 --> 00:34:45,560
to run process the back end as far as I

00:34:40,350 --> 00:34:45,560
know the best ones for this our Titan

00:34:46,010 --> 00:34:55,020
accumulo and neo4j does have large back

00:34:52,560 --> 00:34:57,660
batch processing so they work in the

00:34:55,020 --> 00:35:00,690
same way as a traditional OLAP based

00:34:57,660 --> 00:35:03,270
process but most of them try and follow

00:35:00,690 --> 00:35:06,300
a more oltp process purely because

00:35:03,270 --> 00:35:09,060
they're all designed for web 2.0 fast

00:35:06,300 --> 00:35:13,950
querying much of the quote marks for

00:35:09,060 --> 00:35:17,370
that one there aren't you a question now

00:35:13,950 --> 00:35:20,030
worries anything else come on I'm not

00:35:17,370 --> 00:35:20,030
that scary

00:35:36,680 --> 00:35:45,799
Yeah right so two most common databases

00:35:41,729 --> 00:35:45,799
on the planet mysql and postgresql

00:35:52,549 --> 00:35:58,349
ibrary is that I owed at the scan of

00:35:54,930 --> 00:36:02,299
projects on github and compared them for

00:35:58,349 --> 00:36:05,130
what d database drivers that were using

00:36:02,299 --> 00:36:07,709
it's not so much there is a growth and

00:36:05,130 --> 00:36:11,640
there has been a growth for the last six

00:36:07,709 --> 00:36:16,880
years seven years from moving from SQL

00:36:11,640 --> 00:36:20,430
to know SQL for prototype small systems

00:36:16,880 --> 00:36:23,279
just the web hackery and student sort of

00:36:20,430 --> 00:36:26,939
events and also for things like mobile

00:36:23,279 --> 00:36:29,279
dev with the advancements in the fact

00:36:26,939 --> 00:36:31,739
that of mobile apps but they still all

00:36:29,279 --> 00:36:35,969
need somewhere to store things things

00:36:31,739 --> 00:36:38,249
like CouchDB and catch bass

00:36:35,969 --> 00:36:40,259
Cassandra of all become more prevalent

00:36:38,249 --> 00:36:42,299
because they're just faster at taking in

00:36:40,259 --> 00:36:44,429
large amounts of rights just dumping

00:36:42,299 --> 00:36:46,380
them in so the idea being if you have a

00:36:44,429 --> 00:36:47,819
mobile app or you don't need it to read

00:36:46,380 --> 00:36:49,319
that often because it's got a local copy

00:36:47,819 --> 00:36:50,789
you just need to have a remote version

00:36:49,319 --> 00:36:53,519
of it to compare against everybody else

00:36:50,789 --> 00:36:56,009
so it just needs to receive thousands of

00:36:53,519 --> 00:36:58,319
rights an SQL service traditionally

00:36:56,009 --> 00:37:00,029
doesn't have that sort of massive right

00:36:58,319 --> 00:37:01,199
amount because of the fact that when

00:37:00,029 --> 00:37:02,880
you're running large assistance you've

00:37:01,199 --> 00:37:04,829
got a master slave set up and there's

00:37:02,880 --> 00:37:08,339
one machine which is doing everything it

00:37:04,829 --> 00:37:09,929
is Frank bleeds out but SQL is never

00:37:08,339 --> 00:37:13,709
going away now SQL is not a replacement

00:37:09,929 --> 00:37:14,910
adds the lots of complete fallacy as I

00:37:13,709 --> 00:37:16,890
was saying before it's the right tool

00:37:14,910 --> 00:37:20,130
for the right job it finds the financial

00:37:16,890 --> 00:37:23,640
institute you wouldn't roll for

00:37:20,130 --> 00:37:24,929
your bank data that's a bad idea you'd

00:37:23,640 --> 00:37:26,939
be having three different machines on

00:37:24,929 --> 00:37:28,469
the planet having $5,000 removed all at

00:37:26,939 --> 00:37:31,769
once that's a bad thing for somebody

00:37:28,469 --> 00:37:33,930
who's got 20 bucks in the bank so ya

00:37:31,769 --> 00:37:35,819
know SQL and Tran

00:37:33,930 --> 00:37:37,829
tional systems are going to be around

00:37:35,819 --> 00:37:40,050
forever because they have their place

00:37:37,829 --> 00:37:42,270
it's the same with no SQL there is a

00:37:40,050 --> 00:37:45,780
place for them and then I'll go away the

00:37:42,270 --> 00:37:50,609
growth I believe on average is last time

00:37:45,780 --> 00:37:54,089
we checked something like one point

00:37:50,609 --> 00:37:57,750
eight percent of projects on github or

00:37:54,089 --> 00:38:00,180
including more no SQL in the roof

00:37:57,750 --> 00:38:03,569
brought us two terms technologies inside

00:38:00,180 --> 00:38:05,040
of their systems for their repos but how

00:38:03,569 --> 00:38:07,950
much that actually counts in the

00:38:05,040 --> 00:38:09,359
proprietary world I have no idea not

00:38:07,950 --> 00:38:13,440
sure most I'm gonna let me sniff around

00:38:09,359 --> 00:38:17,790
their code to do a check design answer

00:38:13,440 --> 00:38:18,900
your question sort of there is no answer

00:38:17,790 --> 00:38:19,980
because there's no way of knowing what

00:38:18,900 --> 00:38:41,000
every developer on the planet is

00:38:19,980 --> 00:38:41,000
building yes yes we do yes we do

00:38:48,310 --> 00:38:52,660
yes they do because we've been stealing

00:38:50,600 --> 00:38:55,610
their work for the last two years

00:38:52,660 --> 00:38:57,980
however just a point of fact on that and

00:38:55,610 --> 00:39:00,380
the transition within most businesses

00:38:57,980 --> 00:39:03,320
that do databases it isn't from the fact

00:39:00,380 --> 00:39:07,190
that SQL is getting their work poached

00:39:03,320 --> 00:39:08,450
by no SQL its by the fact that people

00:39:07,190 --> 00:39:11,210
are moving more and more on to SAS

00:39:08,450 --> 00:39:14,240
products so databases that can run as a

00:39:11,210 --> 00:39:15,950
SAS system approaching more so a SAS no

00:39:14,240 --> 00:39:17,780
SQL service is more like to poach an

00:39:15,950 --> 00:39:20,900
on-premise run it yourself database

00:39:17,780 --> 00:39:22,520
there's the difference when IBM and the

00:39:20,900 --> 00:39:24,260
other large companies get the rescue L

00:39:22,520 --> 00:39:26,660
services into the cloud in a way that

00:39:24,260 --> 00:39:29,270
developers can consume easily then it

00:39:26,660 --> 00:39:34,070
will start leveling out again is that a

00:39:29,270 --> 00:39:37,010
better answer sorry my dad anything else

00:39:34,070 --> 00:39:41,210
cuz it's really quiet here and I'm

00:39:37,010 --> 00:39:44,920
really loud indeed people to talk to Wow

00:39:41,210 --> 00:39:44,920
there we go one more in the corner

00:39:59,630 --> 00:40:06,420
but I have been I spying on specific

00:40:04,410 --> 00:40:08,549
projects which are linking systems

00:40:06,420 --> 00:40:10,019
together for example I've been looking

00:40:08,549 --> 00:40:12,839
at project recently which connects

00:40:10,019 --> 00:40:15,630
Cassandra to redshift which is

00:40:12,839 --> 00:40:17,339
essentially a Kafka based sync tool for

00:40:15,630 --> 00:40:22,259
passing the information through based on

00:40:17,339 --> 00:40:27,779
the Cassandra Delta's feed so there are

00:40:22,259 --> 00:40:29,009
tools they're all homegrown baked on by

00:40:27,779 --> 00:40:31,529
somebody who's building it for their

00:40:29,009 --> 00:40:33,900
need as far as I know none of the Apache

00:40:31,529 --> 00:40:36,119
projects of running tooling for

00:40:33,900 --> 00:40:38,279
migration between the systems themselves

00:40:36,119 --> 00:40:41,910
but there are plenty of people building

00:40:38,279 --> 00:40:43,469
tools around that for it especially when

00:40:41,910 --> 00:40:45,630
it comes to moving between data

00:40:43,469 --> 00:40:48,420
warehousing and bi systems and their

00:40:45,630 --> 00:40:50,969
operational stores it's a lot of bi and

00:40:48,420 --> 00:40:52,769
data warehouses are still very much

00:40:50,969 --> 00:40:55,829
sql-based because that's what you want

00:40:52,769 --> 00:40:58,979
to do those kind of deep strange queries

00:40:55,829 --> 00:41:00,749
to find out random information which you

00:40:58,979 --> 00:41:03,479
can't do in an SQL Server so there are

00:41:00,749 --> 00:41:06,989
definitely systems which are piping from

00:41:03,479 --> 00:41:09,599
operational no SQL services into SQL

00:41:06,989 --> 00:41:11,759
systems however there are very few

00:41:09,599 --> 00:41:13,799
systems doing it the inverse because

00:41:11,759 --> 00:41:15,779
it's just so hard to write MapReduce

00:41:13,799 --> 00:41:18,299
queries on top of SQL easily that

00:41:15,779 --> 00:41:19,619
actually work everywhere that's very

00:41:18,299 --> 00:41:20,699
much down for the developer of the

00:41:19,619 --> 00:41:25,920
individual system they're building

00:41:20,699 --> 00:41:29,239
unfortunately Zatch the answer your

00:41:25,920 --> 00:41:29,239
question sweet

00:41:31,150 --> 00:41:39,850
can I get coffee now thank you very much

00:41:37,430 --> 00:41:39,850

YouTube URL: https://www.youtube.com/watch?v=XlvjCU0iXck


