Title: OSDC 2017 | Modern Secrets Management with Vault by Seth Vargo
Publication date: 2017-06-03
Playlist: OSDC 2017 | Open Source Data Center Conference
Description: 
	Creating secrets is easy, but effectively managing them is much more complex. Vault, which is a free and open source tool by HashiCorp, is a popular tool for managing organizational secrets.
Captions: 
	00:00:09,540 --> 00:00:17,580
so next up we have sis Varro telling us

00:00:15,030 --> 00:00:25,140
a bit about modern secrets management

00:00:17,580 --> 00:00:27,650
with Walt enjoy hi everyone again how's

00:00:25,140 --> 00:00:30,150
everyone doing this afternoon morning

00:00:27,650 --> 00:00:33,870
all right I know I am standing between

00:00:30,150 --> 00:00:36,120
you and the restaurant so as you can

00:00:33,870 --> 00:00:41,580
tell by my body type I'm not one to miss

00:00:36,120 --> 00:00:43,739
a meal yesterday you saw a talk about

00:00:41,580 --> 00:00:47,040
the modern data center and it was mostly

00:00:43,739 --> 00:00:49,970
slides it was actually to be exact 164

00:00:47,040 --> 00:00:51,780
slides today I have 18 slides for you

00:00:49,970 --> 00:00:54,420
that means you don't get to go to lunch

00:00:51,780 --> 00:00:57,420
early right well no today's talk is

00:00:54,420 --> 00:00:59,100
primarily live demo based so please all

00:00:57,420 --> 00:01:01,409
say a quick prayer to the demo gods

00:00:59,100 --> 00:01:02,839
because after these 18 slides I'm going

00:01:01,409 --> 00:01:05,280
to be jumping into a terminal and

00:01:02,839 --> 00:01:07,380
everything here is off the cusp on the

00:01:05,280 --> 00:01:09,420
fly with a little bit of script in the

00:01:07,380 --> 00:01:11,610
background but with that let's go ahead

00:01:09,420 --> 00:01:13,350
and get started I'm still Seth from

00:01:11,610 --> 00:01:17,910
yesterday I still work at Hoshi Corp to

00:01:13,350 --> 00:01:19,770
the best of my knowledge if you recall

00:01:17,910 --> 00:01:21,780
yesterday we build tools that automate

00:01:19,770 --> 00:01:23,940
the modern data center so you can

00:01:21,780 --> 00:01:25,530
provision secure and run any

00:01:23,940 --> 00:01:26,820
infrastructure for any application and

00:01:25,530 --> 00:01:30,210
today I will really want to focus on

00:01:26,820 --> 00:01:32,250
that secure component in order to talk

00:01:30,210 --> 00:01:33,630
about that just like yesterday how I

00:01:32,250 --> 00:01:34,980
took us you know kind of through a

00:01:33,630 --> 00:01:36,630
journey of the past I want to do the

00:01:34,980 --> 00:01:38,520
same thing with security and I want us

00:01:36,630 --> 00:01:41,640
to talk a little bit about a monolithic

00:01:38,520 --> 00:01:44,810
application a traditional monolith say

00:01:41,640 --> 00:01:48,150
1995 early 2000s monolith application

00:01:44,810 --> 00:01:51,390
you have all your code in one repository

00:01:48,150 --> 00:01:53,040
it's probably Java let's be honest all

00:01:51,390 --> 00:01:55,590
your code is in one repository

00:01:53,040 --> 00:01:57,690
it runs on a physical machine that's

00:01:55,590 --> 00:01:59,820
physically connected to the network with

00:01:57,690 --> 00:02:03,180
a you know a network cable or a serial

00:01:59,820 --> 00:02:05,670
cable and you do you know your TLS

00:02:03,180 --> 00:02:08,099
termination happens at the f5 because

00:02:05,670 --> 00:02:09,209
someone convinced you to buy that so

00:02:08,099 --> 00:02:11,819
your application doesn't really have to

00:02:09,209 --> 00:02:13,920
worry about TLS and even more so all the

00:02:11,819 --> 00:02:15,330
communication happens internally so

00:02:13,920 --> 00:02:17,639
let's say this is like an online

00:02:15,330 --> 00:02:20,400
shopping cart in a monolithic

00:02:17,639 --> 00:02:22,920
application that app does the rendering

00:02:20,400 --> 00:02:23,170
of the webpage it handles every click

00:02:22,920 --> 00:02:24,700
the

00:02:23,170 --> 00:02:26,950
user makes via the client-server

00:02:24,700 --> 00:02:28,930
relationship it handles the order

00:02:26,950 --> 00:02:31,270
processing it handles the credit card

00:02:28,930 --> 00:02:33,010
processing it doesn't everything is

00:02:31,270 --> 00:02:35,709
self-contained everything lives within

00:02:33,010 --> 00:02:37,750
that monolithic application there are no

00:02:35,709 --> 00:02:39,850
other services to talk to the the

00:02:37,750 --> 00:02:43,950
riskiest external connection you have

00:02:39,850 --> 00:02:46,420
might be resolving DNS and additionally

00:02:43,950 --> 00:02:48,400
it's in a physical data center most

00:02:46,420 --> 00:02:51,040
likely again we're talking you know mid

00:02:48,400 --> 00:02:52,840
90s early 2000s so we're not running in

00:02:51,040 --> 00:02:54,340
a cloud environment so we actually trust

00:02:52,840 --> 00:02:57,190
our data center maybe we're running in

00:02:54,340 --> 00:02:59,500
our own physical data center or a retail

00:02:57,190 --> 00:03:01,780
Colo but it's secure there's physical

00:02:59,500 --> 00:03:03,640
security and I have physical access to

00:03:01,780 --> 00:03:06,840
that box I can walk into that box and

00:03:03,640 --> 00:03:10,810
put a padlock on the rack if I want to

00:03:06,840 --> 00:03:13,900
and in this environment security wasn't

00:03:10,810 --> 00:03:15,880
easy it was just different we had to

00:03:13,900 --> 00:03:17,470
think about physical security we had to

00:03:15,880 --> 00:03:19,750
think about memory we had to think about

00:03:17,470 --> 00:03:21,459
application vulnerabilities you know it

00:03:19,750 --> 00:03:23,380
should an attacker be able to exploit

00:03:21,459 --> 00:03:26,110
code on our website and gain root access

00:03:23,380 --> 00:03:28,630
to the machine and those vulnerabilities

00:03:26,110 --> 00:03:30,519
still exist today but let's compare the

00:03:28,630 --> 00:03:33,489
monolithic architecture to a

00:03:30,519 --> 00:03:35,079
service-oriented architecture so looks

00:03:33,489 --> 00:03:36,250
very similar you still have a load

00:03:35,079 --> 00:03:39,040
balancer and you still have some

00:03:36,250 --> 00:03:40,900
security rules instead of a firewall but

00:03:39,040 --> 00:03:44,440
then you have multiple applications that

00:03:40,900 --> 00:03:46,750
have one very specific responsibility so

00:03:44,440 --> 00:03:48,640
what problems does this introduce well

00:03:46,750 --> 00:03:51,880
first of all you're likely running on

00:03:48,640 --> 00:03:53,560
shared infrastructure cloud provider or

00:03:51,880 --> 00:03:55,230
at least some type of virtualized

00:03:53,560 --> 00:03:58,150
infrastructure in your own data center

00:03:55,230 --> 00:04:00,870
so you don't necessarily own the

00:03:58,150 --> 00:04:03,310
hardware that your code is executing on

00:04:00,870 --> 00:04:04,870
you're relying on the cloud providers

00:04:03,310 --> 00:04:06,430
load balancing which might be at a

00:04:04,870 --> 00:04:10,120
software-defined layer instead of a

00:04:06,430 --> 00:04:13,390
hardware defined layer internal and

00:04:10,120 --> 00:04:15,670
external requests exist not only are we

00:04:13,390 --> 00:04:17,350
routing traffic between our different

00:04:15,670 --> 00:04:19,299
micro services between our different

00:04:17,350 --> 00:04:21,160
applications but we also are

00:04:19,299 --> 00:04:24,240
communicating with third party services

00:04:21,160 --> 00:04:30,039
like hosted databases or external DNS or

00:04:24,240 --> 00:04:32,200
whatever as a service the the root is

00:04:30,039 --> 00:04:34,360
that everything boils down to nothing is

00:04:32,200 --> 00:04:36,099
trusted you don't trust the metal that

00:04:34,360 --> 00:04:36,639
you're running on you don't trust the

00:04:36,099 --> 00:04:39,069
provide

00:04:36,639 --> 00:04:42,280
that you're running on you don't trust

00:04:39,069 --> 00:04:44,139
the isolation layer you're running on

00:04:42,280 --> 00:04:45,639
whether that's VMs or containers you

00:04:44,139 --> 00:04:47,580
don't trust the traffic you're receiving

00:04:45,639 --> 00:04:50,469
you don't trust the traffic you're

00:04:47,580 --> 00:04:54,460
sending the only thing you trust is the

00:04:50,469 --> 00:04:56,500
code you wrote yourself and because of

00:04:54,460 --> 00:04:58,930
that every request requires

00:04:56,500 --> 00:05:01,629
authentication we have to verify that

00:04:58,930 --> 00:05:04,479
incoming requests are actually valid is

00:05:01,629 --> 00:05:06,400
the person making this request able are

00:05:04,479 --> 00:05:08,550
they authorized and authenticated to

00:05:06,400 --> 00:05:11,379
make this request and receive this data

00:05:08,550 --> 00:05:12,879
okay I'm going to send a response am i

00:05:11,379 --> 00:05:16,360
sending the response to the correct

00:05:12,879 --> 00:05:19,000
person to the correct machine and most

00:05:16,360 --> 00:05:20,349
importantly because there's so many of

00:05:19,000 --> 00:05:22,060
these applications and so many

00:05:20,349 --> 00:05:25,360
microservices and so many different

00:05:22,060 --> 00:05:27,939
components there's a lack of a break

00:05:25,360 --> 00:05:30,550
glass procedure or expiration and what

00:05:27,939 --> 00:05:31,900
do I mean by that well if you imagine

00:05:30,550 --> 00:05:34,060
and you think about some of the high

00:05:31,900 --> 00:05:35,379
profile security vulnerabilities and

00:05:34,060 --> 00:05:37,719
security leaks that have happened over

00:05:35,379 --> 00:05:40,389
the past couple of years one of the

00:05:37,719 --> 00:05:41,770
biggest ones is probably a company by

00:05:40,389 --> 00:05:44,409
the name of Ashley Madison how many

00:05:41,770 --> 00:05:47,500
people have heard of Ashley Madison okay

00:05:44,409 --> 00:05:50,229
so they they created an arguably

00:05:47,500 --> 00:05:53,319
unethical service and they were breached

00:05:50,229 --> 00:05:54,400
and the challenge if you read any of the

00:05:53,319 --> 00:05:56,889
white papers about the Ashley Madison

00:05:54,400 --> 00:05:59,529
story is that they knew they were

00:05:56,889 --> 00:06:02,740
breached and couldn't stop it because

00:05:59,529 --> 00:06:05,080
they didn't have a safe and sane way to

00:06:02,740 --> 00:06:06,639
be able to revoke credentials they

00:06:05,080 --> 00:06:09,460
didn't have a safe and sane way they

00:06:06,639 --> 00:06:11,889
couldn't visualize the rollout effect of

00:06:09,460 --> 00:06:14,800
revoking a database credential or taking

00:06:11,889 --> 00:06:17,169
a server offline and this is really

00:06:14,800 --> 00:06:18,639
important that as your organization

00:06:17,169 --> 00:06:20,409
moves to Cloud and moves to micro

00:06:18,639 --> 00:06:23,199
service-oriented architectures that you

00:06:20,409 --> 00:06:25,240
identify these procedures can I take the

00:06:23,199 --> 00:06:29,139
server offline what is the customer

00:06:25,240 --> 00:06:31,810
impact if I take my front-end offline I

00:06:29,139 --> 00:06:33,939
can no longer process orders if I take

00:06:31,810 --> 00:06:35,860
my back-end offline maybe I can continue

00:06:33,939 --> 00:06:37,180
queueing orders and then bring it back

00:06:35,860 --> 00:06:39,639
online and it will continue processing

00:06:37,180 --> 00:06:41,740
with a slight delay these are the types

00:06:39,639 --> 00:06:43,810
of questions you have to ask yourself as

00:06:41,740 --> 00:06:46,599
an architect as a DevOps engineer is

00:06:43,810 --> 00:06:49,060
what are the critical services and how

00:06:46,599 --> 00:06:49,969
can I resolve or return from failure and

00:06:49,060 --> 00:06:52,339
what

00:06:49,969 --> 00:06:54,079
is a break glass procedure if I get

00:06:52,339 --> 00:06:55,699
paged because there's some anomaly

00:06:54,079 --> 00:06:56,719
detection software that says hey we

00:06:55,699 --> 00:06:58,639
think there's an intruder in your

00:06:56,719 --> 00:07:00,110
network they've gained SSH access into

00:06:58,639 --> 00:07:03,709
the bastion host because someone leaked

00:07:00,110 --> 00:07:06,589
their SSH keys what do you do and how

00:07:03,709 --> 00:07:09,379
quickly can you resolve that and the

00:07:06,589 --> 00:07:10,669
answer is not three seconds because I

00:07:09,379 --> 00:07:14,209
just pick up the phone and call the ops

00:07:10,669 --> 00:07:17,929
team you have to actually think about

00:07:14,209 --> 00:07:20,629
these problems and honestly that's why

00:07:17,929 --> 00:07:23,029
we built vault it's because it's really

00:07:20,629 --> 00:07:25,669
freaking hard it's really hard

00:07:23,029 --> 00:07:29,209
especially in large organizations to try

00:07:25,669 --> 00:07:31,699
to understand the surface area and it's

00:07:29,209 --> 00:07:33,759
really hard to generate credentials to

00:07:31,699 --> 00:07:37,009
revoke them and to give them expirations

00:07:33,759 --> 00:07:41,239
because traditional applications aren't

00:07:37,009 --> 00:07:43,639
built for passwords that expire and I'll

00:07:41,239 --> 00:07:45,049
talk about that in a little bit if you

00:07:43,639 --> 00:07:46,369
remember yesterday we make a bunch of

00:07:45,049 --> 00:07:49,759
other tools I already talked about them

00:07:46,369 --> 00:07:52,399
but this is an obligatory slide so what

00:07:49,759 --> 00:07:56,839
is volt well it's actually really

00:07:52,399 --> 00:07:59,149
complex to explain volt started as a not

00:07:56,839 --> 00:08:00,829
open-source never was going to be

00:07:59,149 --> 00:08:03,619
open-source project internally at Hashi

00:08:00,829 --> 00:08:06,259
Corp we just crossed 100 employees and

00:08:03,619 --> 00:08:08,300
our co-founder and CTO Mitchell sent an

00:08:06,259 --> 00:08:12,860
email out reminding everyone of how volt

00:08:08,300 --> 00:08:14,269
came to be and I had forgotten we were a

00:08:12,860 --> 00:08:15,919
company of like five or six employees

00:08:14,269 --> 00:08:18,349
and we had gotten together for kind of a

00:08:15,919 --> 00:08:19,759
hackathon and at the time we were

00:08:18,349 --> 00:08:21,349
working on a commercial product called

00:08:19,759 --> 00:08:24,799
Atlas for like a DevOps delivery

00:08:21,349 --> 00:08:26,599
workflow and because of that tool in

00:08:24,799 --> 00:08:28,009
order for it to work the users would

00:08:26,599 --> 00:08:30,019
have to give us their cloud credentials

00:08:28,009 --> 00:08:31,849
you would have to give us your AWS

00:08:30,019 --> 00:08:34,370
access keys your Google Account JSON

00:08:31,849 --> 00:08:37,399
your you know API keys and we needed a

00:08:34,370 --> 00:08:39,649
way to academically be able to say that

00:08:37,399 --> 00:08:41,120
those keys were secure and yeah we could

00:08:39,649 --> 00:08:44,000
use latest encryption algorithms but we

00:08:41,120 --> 00:08:46,009
needed a way to prove to big enterprises

00:08:44,000 --> 00:08:47,750
that their data was safe that other

00:08:46,009 --> 00:08:51,199
people couldn't read it and that we had

00:08:47,750 --> 00:08:53,750
a very clear mitigation path and it was

00:08:51,199 --> 00:08:55,040
literally impossible the only way to do

00:08:53,750 --> 00:08:56,839
that is like spreadsheets on

00:08:55,040 --> 00:08:59,509
spreadsheets or you build your own

00:08:56,839 --> 00:09:02,929
custom tooling so we started designing a

00:08:59,509 --> 00:09:03,970
tool and I of all people was like this

00:09:02,929 --> 00:09:06,069
should be open source

00:09:03,970 --> 00:09:07,509
and that was the inception of vault back

00:09:06,069 --> 00:09:09,399
in 2014

00:09:07,509 --> 00:09:11,109
now you might know a little bit about

00:09:09,399 --> 00:09:13,989
both history and that it didn't become

00:09:11,109 --> 00:09:15,129
an open-source project until 2015 and if

00:09:13,989 --> 00:09:18,189
you remember yesterday I talked about

00:09:15,129 --> 00:09:21,009
dogfooding we ran vault internally for

00:09:18,189 --> 00:09:22,089
over a year building features making

00:09:21,009 --> 00:09:23,829
sure it was perfect

00:09:22,089 --> 00:09:25,569
getting it audited by the NCC group

00:09:23,829 --> 00:09:27,549
which is an independent auditing firm

00:09:25,569 --> 00:09:31,149
security auditing firm before we ever

00:09:27,549 --> 00:09:34,989
open sourced it and since then it's

00:09:31,149 --> 00:09:38,169
scope has grown volt is a number of

00:09:34,989 --> 00:09:40,779
things at its basis it's an encrypted

00:09:38,169 --> 00:09:42,970
key value store a distributed highly

00:09:40,779 --> 00:09:44,439
available encrypted key value store the

00:09:42,970 --> 00:09:46,779
easiest way to think about this is

00:09:44,439 --> 00:09:49,299
encrypted Redis or encrypted memcache

00:09:46,779 --> 00:09:54,189
highly available but encrypted in

00:09:49,299 --> 00:09:56,589
transit and at rest but it's more than

00:09:54,189 --> 00:09:59,139
that because instead of storing the data

00:09:56,589 --> 00:10:02,379
volt can encrypt the data and send it

00:09:59,139 --> 00:10:04,059
back to you it doesn't store it in this

00:10:02,379 --> 00:10:06,189
way vault acts as encryption as a

00:10:04,059 --> 00:10:07,829
service so how is this any different

00:10:06,189 --> 00:10:10,209
than your application doing encryption

00:10:07,829 --> 00:10:11,739
well your application in order to do

00:10:10,209 --> 00:10:14,679
encryption first of all has to implement

00:10:11,739 --> 00:10:16,569
modern best security practices you have

00:10:14,679 --> 00:10:17,619
to know all the different algorithms and

00:10:16,569 --> 00:10:20,409
all the different trade-offs between

00:10:17,619 --> 00:10:22,119
them you're out your application also

00:10:20,409 --> 00:10:23,739
has to be aware of the encryption key

00:10:22,119 --> 00:10:26,259
the symmetric encryption and decryption

00:10:23,739 --> 00:10:27,909
key which means that if attacker can

00:10:26,259 --> 00:10:29,229
gain access to your application they

00:10:27,909 --> 00:10:30,699
could potentially read the memory of

00:10:29,229 --> 00:10:33,789
that application and get the encryption

00:10:30,699 --> 00:10:36,009
key out by using vault with encryption

00:10:33,789 --> 00:10:37,509
as a service no applications have to

00:10:36,009 --> 00:10:41,739
understand any of the modern encryption

00:10:37,509 --> 00:10:43,089
they make an HTTP or HTTPS call with the

00:10:41,739 --> 00:10:45,939
data they want and they get back the

00:10:43,089 --> 00:10:47,679
encrypted data that they store they then

00:10:45,939 --> 00:10:49,119
do the opposite of that to get back the

00:10:47,679 --> 00:10:52,209
plaintext data should they ever need it

00:10:49,119 --> 00:10:53,829
and this is advantageous because if an

00:10:52,209 --> 00:10:55,599
attacker was able to somehow gain root

00:10:53,829 --> 00:10:57,789
access of the application and download

00:10:55,599 --> 00:10:59,679
the entire database they would still

00:10:57,789 --> 00:11:02,019
have to gain root access to a vault and

00:10:59,679 --> 00:11:03,669
somehow extract the key from memory

00:11:02,019 --> 00:11:04,869
because it's never actually persisted to

00:11:03,669 --> 00:11:09,189
disk in plaintext

00:11:04,869 --> 00:11:11,409
to decrypt all of that data so that's

00:11:09,189 --> 00:11:13,419
two things well it does it can both act

00:11:11,409 --> 00:11:16,359
as an encrypted secret store or can act

00:11:13,419 --> 00:11:18,300
as a pass-through or transit of secret

00:11:16,359 --> 00:11:20,260
data

00:11:18,300 --> 00:11:21,940
but there are other tools that do that

00:11:20,260 --> 00:11:23,380
that's not really exciting and it

00:11:21,940 --> 00:11:25,270
doesn't actually solve the problem of

00:11:23,380 --> 00:11:27,130
what do I do when I've been breached

00:11:25,270 --> 00:11:29,230
this helps with security it helps make

00:11:27,130 --> 00:11:31,450
application developers adopt better

00:11:29,230 --> 00:11:33,310
security practices because it's easy we

00:11:31,450 --> 00:11:35,650
lower the barrier to entry to encrypt

00:11:33,310 --> 00:11:38,110
data but we haven't solved a problem yet

00:11:35,650 --> 00:11:39,370
and this is revolt separates itself from

00:11:38,110 --> 00:11:42,010
other tools on the market both

00:11:39,370 --> 00:11:43,930
commercial and open source is the vault

00:11:42,010 --> 00:11:46,630
actually acts as a secret acquisition

00:11:43,930 --> 00:11:49,660
engine in addition to storing

00:11:46,630 --> 00:11:52,150
credentials vault can communicate with a

00:11:49,660 --> 00:11:53,520
number of third party providers to

00:11:52,150 --> 00:11:56,350
generate credentials

00:11:53,520 --> 00:11:58,900
one of those is databases vault can

00:11:56,350 --> 00:12:04,750
communicate with Microsoft SQL my sequel

00:11:58,900 --> 00:12:06,970
Maria DB Postgres Cassandra rabbit a

00:12:04,750 --> 00:12:09,790
number of databases or database like

00:12:06,970 --> 00:12:12,100
services vault actually establishes a

00:12:09,790 --> 00:12:14,380
connection to those services runs the

00:12:12,100 --> 00:12:18,790
command to generate users and passwords

00:12:14,380 --> 00:12:22,030
and returns them to you but unlike

00:12:18,790 --> 00:12:26,020
someone doing that on the console they

00:12:22,030 --> 00:12:27,160
have a TTL or a lifetime involved so how

00:12:26,020 --> 00:12:31,810
many people here are familiar with the

00:12:27,160 --> 00:12:35,050
way DHCP works so when you connect to an

00:12:31,810 --> 00:12:37,300
Access Point or a network your machine

00:12:35,050 --> 00:12:39,100
advertises its MAC address to a DHCP

00:12:37,300 --> 00:12:42,070
server and the DHCP server looks at a

00:12:39,100 --> 00:12:46,300
pool of IP addresses and says here you

00:12:42,070 --> 00:12:49,330
can have this one 192.168.0 3:3 it's

00:12:46,300 --> 00:12:51,430
good for 8 hours at the end of 8 hours

00:12:49,330 --> 00:12:53,260
it's your clients responsibility your

00:12:51,430 --> 00:12:56,530
local laptop your MacBook Pro your Dell

00:12:53,260 --> 00:12:58,030
your surface to then go back to the DHCP

00:12:56,530 --> 00:12:59,560
server and say hey I'm still using that

00:12:58,030 --> 00:13:01,690
IP address could I please have it for

00:12:59,560 --> 00:13:03,880
another 8 hours and the DHCP server

00:13:01,690 --> 00:13:06,300
might say sure and then it just extends

00:13:03,880 --> 00:13:09,640
the lease and it knows not to assign

00:13:06,300 --> 00:13:10,930
5:33 to anyone else if for some reason

00:13:09,640 --> 00:13:13,690
though you close your laptop you go on

00:13:10,930 --> 00:13:15,970
vacation you come back that TTL has

00:13:13,690 --> 00:13:18,820
expired and maybe the DHCP server has

00:13:15,970 --> 00:13:20,410
allocated that to someone else so you'll

00:13:18,820 --> 00:13:22,720
go to the DHCP server and say hey can I

00:13:20,410 --> 00:13:24,580
have 533 and the DHCP server says no

00:13:22,720 --> 00:13:27,400
that's a Joe's laptop but you can have

00:13:24,580 --> 00:13:29,950
547 and all of that happens

00:13:27,400 --> 00:13:30,940
transparently to you as the user how

00:13:29,950 --> 00:13:31,330
many people knew that that's what

00:13:30,940 --> 00:13:35,320
happened

00:13:31,330 --> 00:13:37,750
whenever you open your laptop cool vault

00:13:35,320 --> 00:13:40,390
does the exact same thing but instead of

00:13:37,750 --> 00:13:42,040
IP addresses its credentials and instead

00:13:40,390 --> 00:13:45,730
of opening and closing your laptop its

00:13:42,040 --> 00:13:48,130
TTLs that are long-lived or short-lived

00:13:45,730 --> 00:13:49,480
depending on your configuration we'll

00:13:48,130 --> 00:13:50,980
look at it some examples in this but

00:13:49,480 --> 00:13:54,190
this is a really different way about

00:13:50,980 --> 00:13:56,860
thinking of credentials right now in

00:13:54,190 --> 00:13:58,420
your organization how do you create say

00:13:56,860 --> 00:14:01,209
a post grass or a my sequel credential

00:13:58,420 --> 00:14:02,560
well if you're a startup you probably

00:14:01,209 --> 00:14:05,260
Google how to create post curse

00:14:02,560 --> 00:14:07,810
credential you go to stack overflow and

00:14:05,260 --> 00:14:09,399
you copy some things into a terminal and

00:14:07,810 --> 00:14:12,700
then you copy some things into a text

00:14:09,399 --> 00:14:14,079
file and you're done perfect and then

00:14:12,700 --> 00:14:17,019
you probably store that and you know

00:14:14,079 --> 00:14:19,480
you're your chef server data or Huayra

00:14:17,019 --> 00:14:21,399
data or whatever your your data store is

00:14:19,480 --> 00:14:22,990
and you might encrypt it and you walk

00:14:21,399 --> 00:14:25,000
away from it and then 6 years from now

00:14:22,990 --> 00:14:26,170
when you're breached you have no idea

00:14:25,000 --> 00:14:28,870
why because you haven't changed your

00:14:26,170 --> 00:14:31,209
database password in six years on the

00:14:28,870 --> 00:14:32,740
flip side though if you're an enterprise

00:14:31,209 --> 00:14:35,770
you probably file this thing called a

00:14:32,740 --> 00:14:39,940
JIRA ticket and wait six to eight weeks

00:14:35,770 --> 00:14:42,640
for someone called a DBA to email you

00:14:39,940 --> 00:14:44,020
the password in plain text which you

00:14:42,640 --> 00:14:47,290
then put in the text file of the

00:14:44,020 --> 00:14:48,820
application but you might keep a copy

00:14:47,290 --> 00:14:50,230
locally because I was so painful like

00:14:48,820 --> 00:14:51,339
you want to go through that every time

00:14:50,230 --> 00:14:52,990
you need to connect to the database so

00:14:51,339 --> 00:14:56,110
we'll just put that in the home

00:14:52,990 --> 00:14:58,740
directory no one will notice right how

00:14:56,110 --> 00:15:00,250
many people have done that before yeah

00:14:58,740 --> 00:15:02,589
exactly

00:15:00,250 --> 00:15:05,290
vault solves that problem and I'll show

00:15:02,589 --> 00:15:07,480
you how what about things that aren't

00:15:05,290 --> 00:15:09,070
databases we a lot of people here are

00:15:07,480 --> 00:15:10,870
moving to cloud technologies and I think

00:15:09,070 --> 00:15:12,970
it's very clear that our industry is

00:15:10,870 --> 00:15:14,589
moving in that direction so I can't say

00:15:12,970 --> 00:15:16,329
definitively whether all applications

00:15:14,589 --> 00:15:19,270
will eventually run on a cloud but I can

00:15:16,329 --> 00:15:21,399
say that most of them will how do you

00:15:19,270 --> 00:15:23,560
generate cloud credentials like Google

00:15:21,399 --> 00:15:26,440
account credentials or Amazon iam access

00:15:23,560 --> 00:15:27,880
keys you might use the CLI but I think

00:15:26,440 --> 00:15:30,550
the majority of people go into the UI

00:15:27,880 --> 00:15:32,260
click buttons assign policy and then

00:15:30,550 --> 00:15:34,329
they copy and paste things and email

00:15:32,260 --> 00:15:36,940
them to people so let me ask you a

00:15:34,329 --> 00:15:38,740
question if a new developer joins your

00:15:36,940 --> 00:15:41,350
team right now and they need access to

00:15:38,740 --> 00:15:44,020
the AWS console how do you get them that

00:15:41,350 --> 00:15:45,160
access someone probably logs into the

00:15:44,020 --> 00:15:48,220
console and clicks buttons

00:15:45,160 --> 00:15:51,250
with vault we've solved that developers

00:15:48,220 --> 00:15:53,949
can access their own iam credentials via

00:15:51,250 --> 00:15:56,470
the API by logging in with github or

00:15:53,949 --> 00:15:58,110
LDAP or their own username and password

00:15:56,470 --> 00:16:00,819
locally

00:15:58,110 --> 00:16:03,519
unlike Amazon though these iam

00:16:00,819 --> 00:16:04,930
credentials have a lifetime so you can

00:16:03,519 --> 00:16:06,639
say that I am credentials that

00:16:04,930 --> 00:16:08,199
developers generate are valid for five

00:16:06,639 --> 00:16:09,670
minutes that's enough time to run some

00:16:08,199 --> 00:16:11,829
commands locally maybe spin up an

00:16:09,670 --> 00:16:13,420
instance but if those get leaked out you

00:16:11,829 --> 00:16:15,490
can't spin up enough Bitcoin mining

00:16:13,420 --> 00:16:19,540
servers in five minutes to actually do

00:16:15,490 --> 00:16:22,089
anything reasonable so what else consult

00:16:19,540 --> 00:16:23,980
do well more recently we've been pushing

00:16:22,089 --> 00:16:26,319
the boundaries of alt and vault can

00:16:23,980 --> 00:16:28,720
actually act as a full PKI internal

00:16:26,319 --> 00:16:31,870
replacement vault can act as a

00:16:28,720 --> 00:16:33,339
certificate authority why is this useful

00:16:31,870 --> 00:16:35,379
well in micro service-oriented

00:16:33,339 --> 00:16:38,050
architectures where you trust nothing

00:16:35,379 --> 00:16:40,060
how do you know that the application

00:16:38,050 --> 00:16:42,839
you're communicating with is authorized

00:16:40,060 --> 00:16:45,100
and authenticated to receive the data if

00:16:42,839 --> 00:16:47,230
we're in a situation where someone is

00:16:45,100 --> 00:16:49,959
able to launch an instance inside your

00:16:47,230 --> 00:16:51,519
virtual network in Amazon how many

00:16:49,959 --> 00:16:53,980
people here are authenticating those

00:16:51,519 --> 00:16:55,449
requests if an attacker is able to make

00:16:53,980 --> 00:16:58,420
their way into your network can they see

00:16:55,449 --> 00:17:00,910
the traffic between your services so

00:16:58,420 --> 00:17:04,059
it's not just about authentication but

00:17:00,910 --> 00:17:05,409
it's also about encryption if someone

00:17:04,059 --> 00:17:06,880
can gain access to your network and they

00:17:05,409 --> 00:17:08,319
can see that all your communication

00:17:06,880 --> 00:17:12,010
between your micro services has done

00:17:08,319 --> 00:17:14,650
over you know non TLS basic HTTP you're

00:17:12,010 --> 00:17:17,679
not really protecting anything so by

00:17:14,650 --> 00:17:20,140
adding TLS we can protect external

00:17:17,679 --> 00:17:21,819
people from snooping on the traffic but

00:17:20,140 --> 00:17:24,130
we can also apply client-side and

00:17:21,819 --> 00:17:26,860
server-side certificate verification to

00:17:24,130 --> 00:17:28,329
ensure that the clients talking to each

00:17:26,860 --> 00:17:31,000
other the micro services talking to each

00:17:28,329 --> 00:17:33,250
other are actually verified or signed by

00:17:31,000 --> 00:17:36,159
the same certificate authority and if

00:17:33,250 --> 00:17:39,580
anyone is a here's ever generated a like

00:17:36,159 --> 00:17:41,260
a PEM file for open SSL you know that

00:17:39,580 --> 00:17:43,690
it's like this magical incantation of

00:17:41,260 --> 00:17:47,049
commands that to be honest I have never

00:17:43,690 --> 00:17:49,390
not copied from Stack Overflow and like

00:17:47,049 --> 00:17:51,070
if you ever generated x.509 certificates

00:17:49,390 --> 00:17:52,870
it's even harder and then you just like

00:17:51,070 --> 00:17:54,760
shove them on disk somewhere and hope

00:17:52,870 --> 00:17:56,320
that they never expire and because of

00:17:54,760 --> 00:17:58,810
that process is so convoluted we

00:17:56,320 --> 00:18:01,180
typically give really long krill

00:17:58,810 --> 00:18:03,550
and really long expiration dates like a

00:18:01,180 --> 00:18:04,780
year or two years or five years to these

00:18:03,550 --> 00:18:07,090
certificates because we don't want to

00:18:04,780 --> 00:18:10,090
deal with it with a vault it's one API

00:18:07,090 --> 00:18:14,050
call so internally and a number of our

00:18:10,090 --> 00:18:17,170
customers and users we have certificates

00:18:14,050 --> 00:18:19,690
TLS certificates that have T TLS of 30

00:18:17,170 --> 00:18:23,770
minutes or five minutes and krills as

00:18:19,690 --> 00:18:25,500
low as 30 seconds and then we continue

00:18:23,770 --> 00:18:28,840
to push the boundary

00:18:25,500 --> 00:18:31,540
because in addition to being able to

00:18:28,840 --> 00:18:32,830
secure communication between services we

00:18:31,540 --> 00:18:34,360
want to provide developers a way to

00:18:32,830 --> 00:18:36,430
actually gain access to running

00:18:34,360 --> 00:18:37,780
instances so we know that if you're

00:18:36,430 --> 00:18:39,610
running a mutable infrastructure you

00:18:37,780 --> 00:18:41,260
should never do this developers or

00:18:39,610 --> 00:18:43,660
operators should never SSH into an

00:18:41,260 --> 00:18:44,890
instance it's tainted it's on it's not a

00:18:43,660 --> 00:18:47,710
good practice it's not a good security

00:18:44,890 --> 00:18:49,840
practice however sometimes it's a

00:18:47,710 --> 00:18:52,350
necessary evil you have a service you

00:18:49,840 --> 00:18:55,270
need to do some debugging whatever

00:18:52,350 --> 00:18:57,130
traditionally you use like chef or

00:18:55,270 --> 00:18:58,960
puppet or ansible or salt to write out

00:18:57,130 --> 00:19:02,560
an authorized keys file with everyone's

00:18:58,960 --> 00:19:04,930
public key so that they can SSH in or

00:19:02,560 --> 00:19:07,240
you use a configuration management tool

00:19:04,930 --> 00:19:09,850
to manually create all of these users in

00:19:07,240 --> 00:19:12,310
the system and then the challenge is

00:19:09,850 --> 00:19:14,200
when someone leaves the company do you

00:19:12,310 --> 00:19:16,950
remove their SSH key from the authorized

00:19:14,200 --> 00:19:22,660
keys file and the answer is usually no

00:19:16,950 --> 00:19:26,860
or usually like within three months with

00:19:22,660 --> 00:19:30,970
vault we can authenticate users via like

00:19:26,860 --> 00:19:33,100
LDAP Active Directory or even github so

00:19:30,970 --> 00:19:35,110
the moment that you remove someone from

00:19:33,100 --> 00:19:36,460
the company LDAP server or the moment

00:19:35,110 --> 00:19:39,690
you remove someone from a particular

00:19:36,460 --> 00:19:42,700
team on github they lose SSH access

00:19:39,690 --> 00:19:44,650
what's really advantageous though is

00:19:42,700 --> 00:19:46,840
that they're using their same private

00:19:44,650 --> 00:19:48,970
key and same public key that they use

00:19:46,840 --> 00:19:51,790
for get pushes and connecting to their

00:19:48,970 --> 00:19:53,350
own personal servers the way vaults SSH

00:19:51,790 --> 00:19:55,960
CA Authority works is they make a

00:19:53,350 --> 00:19:57,280
request to vault to sign their public

00:19:55,960 --> 00:20:00,250
key and private key with vault

00:19:57,280 --> 00:20:02,200
certificate authority and then the

00:20:00,250 --> 00:20:04,420
servers that they want to SSH into check

00:20:02,200 --> 00:20:06,280
against vault to make sure that the

00:20:04,420 --> 00:20:07,960
certificate the SSH key that they're

00:20:06,280 --> 00:20:10,030
trying to access with has been signed by

00:20:07,960 --> 00:20:11,380
the CA so we don't have to generate keys

00:20:10,030 --> 00:20:12,730
we don't have to run any open SSL

00:20:11,380 --> 00:20:16,840
commands it's just two API

00:20:12,730 --> 00:20:18,160
calls and again we continue to push the

00:20:16,840 --> 00:20:19,660
boundaries of what we think of secret

00:20:18,160 --> 00:20:23,260
management how many people here know

00:20:19,660 --> 00:20:24,760
what TOTP is okay so for those of you

00:20:23,260 --> 00:20:26,110
that don't know at TOTP is I promise

00:20:24,760 --> 00:20:29,679
that you do you've just never heard it

00:20:26,110 --> 00:20:31,510
called TOTP TOTP is an algorithm for

00:20:29,679 --> 00:20:32,950
generating one-time passwords based on

00:20:31,510 --> 00:20:35,200
time so it's time-based one-time

00:20:32,950 --> 00:20:41,200
passwords so if you've ever used two FA

00:20:35,200 --> 00:20:45,549
or MFA you've seen totp vault can act as

00:20:41,200 --> 00:20:47,080
a TOTP generator so it can replace

00:20:45,549 --> 00:20:51,340
something like Google Authenticator or

00:20:47,080 --> 00:20:52,929
offi or duo but then again and I promise

00:20:51,340 --> 00:20:55,600
we almost done with slides we can push

00:20:52,929 --> 00:20:57,100
the boundary even further how many

00:20:55,600 --> 00:20:59,049
people have ever tried to implement

00:20:57,100 --> 00:21:01,890
two-factor authentication in their own

00:20:59,049 --> 00:21:05,919
application is it easy

00:21:01,890 --> 00:21:08,650
no is it easy to get it correct even

00:21:05,919 --> 00:21:10,090
harder there are open source algorithms

00:21:08,650 --> 00:21:11,650
out there and there are even client

00:21:10,090 --> 00:21:13,690
libraries that exist like there's a

00:21:11,650 --> 00:21:15,460
really popular library for rails that'll

00:21:13,690 --> 00:21:18,220
do the whole thing for you and it's

00:21:15,460 --> 00:21:21,610
still really hard so wouldn't it be

00:21:18,220 --> 00:21:24,700
great if something did TOTP for you you

00:21:21,610 --> 00:21:26,740
can delegate TOTP authentication to volt

00:21:24,700 --> 00:21:27,880
so in addition to vault being able to

00:21:26,740 --> 00:21:30,610
replace something like Google

00:21:27,880 --> 00:21:33,070
Authenticator or offi it can also be the

00:21:30,610 --> 00:21:36,070
provider for those tokens and the

00:21:33,070 --> 00:21:37,480
validator on the other end so you don't

00:21:36,070 --> 00:21:39,760
have to write a whole bunch of Ruby code

00:21:37,480 --> 00:21:41,679
or Python code or note or go to be able

00:21:39,760 --> 00:21:44,850
to do two-factor authentication in your

00:21:41,679 --> 00:21:47,860
application you just make an API call

00:21:44,850 --> 00:21:51,460
everything involved is just an API call

00:21:47,860 --> 00:21:57,600
away and I want to show you that now so

00:21:51,460 --> 00:22:02,169
I have 38 minutes of demo here we go

00:21:57,600 --> 00:22:04,120
who's ready for this all right so we're

00:22:02,169 --> 00:22:04,750
going to go ahead and pray to the demo

00:22:04,120 --> 00:22:06,610
gods

00:22:04,750 --> 00:22:09,490
okay we're start out good type the

00:22:06,610 --> 00:22:11,910
password right so this is a vault

00:22:09,490 --> 00:22:14,200
cluster that I have set up in advance

00:22:11,910 --> 00:22:15,640
it's really easy to install vault though

00:22:14,200 --> 00:22:17,169
you download the binary move it into

00:22:15,640 --> 00:22:20,260
path and start the server three steps

00:22:17,169 --> 00:22:23,460
really challenging so what I mean is

00:22:20,260 --> 00:22:23,460
this a good font size for everyone

00:22:25,989 --> 00:22:31,789
Wow it's really quiet is this a good

00:22:29,179 --> 00:22:34,070
font size for everyone perfect alright

00:22:31,789 --> 00:22:35,809
so what I'm going to do here is I'm

00:22:34,070 --> 00:22:37,389
going to check the status or status of

00:22:35,809 --> 00:22:39,799
alt depending on where you come from so

00:22:37,389 --> 00:22:40,999
I'm going to run the vault status and

00:22:39,799 --> 00:22:42,710
this is going to tell me a little bit

00:22:40,999 --> 00:22:45,109
about the vault server this is an

00:22:42,710 --> 00:22:46,909
unauthenticated API endpoint so your

00:22:45,109 --> 00:22:48,259
load balancer or your health checking

00:22:46,909 --> 00:22:49,820
servers can hit this without being

00:22:48,259 --> 00:22:52,249
authenticated to vault there's no

00:22:49,820 --> 00:22:53,659
sensitive information in here except

00:22:52,249 --> 00:22:55,789
maybe like the version of vault that

00:22:53,659 --> 00:22:57,679
you're running so this tells me that I'm

00:22:55,789 --> 00:22:59,359
running vault zero point seven point two

00:22:57,679 --> 00:23:01,759
I happen to be running the enterprise

00:22:59,359 --> 00:23:03,710
build here but that's irrelevant I have

00:23:01,759 --> 00:23:05,989
a cluster name a cluster ID which is a u

00:23:03,710 --> 00:23:07,159
UID and some things called key shares

00:23:05,989 --> 00:23:07,899
and key thresholds we'll talk about

00:23:07,159 --> 00:23:10,639
those later

00:23:07,899 --> 00:23:12,470
like most often most applications though

00:23:10,639 --> 00:23:14,179
I have to authenticate before I can do

00:23:12,470 --> 00:23:15,379
pretty much anything so I'm going to go

00:23:14,179 --> 00:23:17,239
ahead and authenticate the vault and I'm

00:23:15,379 --> 00:23:19,029
going to authenticate as this user that

00:23:17,239 --> 00:23:20,989
I created in advance called route

00:23:19,029 --> 00:23:23,059
normally when you authenticate the vault

00:23:20,989 --> 00:23:24,619
you have like really long uu IDs but I

00:23:23,059 --> 00:23:26,479
didn't feel like copying and pasting and

00:23:24,619 --> 00:23:28,249
I wrote a lot of vaults so I cheated by

00:23:26,479 --> 00:23:30,289
using something called development mode

00:23:28,249 --> 00:23:31,909
which allows me to very quickly spin up

00:23:30,289 --> 00:23:32,559
a vault server let me show you what that

00:23:31,909 --> 00:23:34,970
looks like

00:23:32,559 --> 00:23:36,559
so this is back on my local laptop here

00:23:34,970 --> 00:23:41,210
I would like a vault server to test

00:23:36,559 --> 00:23:44,090
something vault server - dev I have a

00:23:41,210 --> 00:23:45,349
vault server pretty crazy how many

00:23:44,090 --> 00:23:48,259
people have ever tried to run a service

00:23:45,349 --> 00:23:51,099
locally and you're like config file and

00:23:48,259 --> 00:23:53,899
this other thing and then this flag nope

00:23:51,099 --> 00:23:55,700
across all the hydro tools were adopting

00:23:53,899 --> 00:23:57,799
the dev mode and what dev mode is as

00:23:55,700 --> 00:23:59,090
best practices ready to go hit the

00:23:57,799 --> 00:24:01,700
ground running to play around with the

00:23:59,090 --> 00:24:04,279
servers so this is a vault server on in

00:24:01,700 --> 00:24:05,809
my local laptop with one command I'll

00:24:04,279 --> 00:24:07,700
quit that so that's what I'm doing on

00:24:05,809 --> 00:24:09,109
this server here and I've configured

00:24:07,700 --> 00:24:12,889
that server in advance to cheat a little

00:24:09,109 --> 00:24:14,419
bit with this demo I'm also trying to

00:24:12,889 --> 00:24:18,019
prove to you that I'm a real engineer so

00:24:14,419 --> 00:24:18,499
a little bit of ego my ego and posture

00:24:18,019 --> 00:24:20,359
syndrome

00:24:18,499 --> 00:24:22,279
so I've authenticated to vault and

00:24:20,359 --> 00:24:23,479
that's cool but now what do I do

00:24:22,279 --> 00:24:24,919
well I'm going to kind of go with the

00:24:23,479 --> 00:24:26,599
same order that I introduced some of the

00:24:24,919 --> 00:24:28,340
features to you and the first feature I

00:24:26,599 --> 00:24:29,899
talked about was the static key value

00:24:28,340 --> 00:24:32,059
store again think of this is like

00:24:29,899 --> 00:24:33,289
encrypted Redis encrypted memcache but

00:24:32,059 --> 00:24:34,820
it's highly available globally

00:24:33,289 --> 00:24:37,099
distributed just like consul of key

00:24:34,820 --> 00:24:38,600
value store and I can do that by just

00:24:37,099 --> 00:24:40,970
writing data

00:24:38,600 --> 00:24:43,070
and before I do this it's not going to

00:24:40,970 --> 00:24:44,690
feel secure you're not going to feel

00:24:43,070 --> 00:24:46,549
insecure unless you already do feel

00:24:44,690 --> 00:24:47,840
insecure but you're you're not going to

00:24:46,549 --> 00:24:50,330
feel secure so I'm going to run this

00:24:47,840 --> 00:24:53,360
command vault right secret foo a equals

00:24:50,330 --> 00:24:55,429
B and the data was written and I'm going

00:24:53,360 --> 00:24:58,820
to read that data back out won't read

00:24:55,429 --> 00:25:00,049
secret sue and I get the data back out a

00:24:58,820 --> 00:25:01,370
equals B along with this other thing

00:25:00,049 --> 00:25:03,110
called a refresh interval which I'll

00:25:01,370 --> 00:25:05,840
talk about in a second how many people

00:25:03,110 --> 00:25:08,270
feel more secure now yeah it doesn't

00:25:05,840 --> 00:25:10,520
feel secure and that's because as an

00:25:08,270 --> 00:25:14,480
industry we have been conditioned to

00:25:10,520 --> 00:25:16,010
believe that security has to be hard yes

00:25:14,480 --> 00:25:18,169
I will say that again you have been

00:25:16,010 --> 00:25:20,090
brainwashed into believing that security

00:25:18,169 --> 00:25:22,309
has to be hard and I will tell you what

00:25:20,090 --> 00:25:24,140
I mean when we were looking at vault

00:25:22,309 --> 00:25:25,549
before we build our own we evaluated a

00:25:24,140 --> 00:25:27,049
number of popular open source and

00:25:25,549 --> 00:25:28,970
commercial solutions on one of those

00:25:27,049 --> 00:25:31,220
solutions which I will not name is a

00:25:28,970 --> 00:25:32,870
really nice web UI with clicky clicky

00:25:31,220 --> 00:25:35,360
button buttons I think it's like ember

00:25:32,870 --> 00:25:37,760
react so it's really cool server client

00:25:35,360 --> 00:25:43,370
model has really great ACLs policies

00:25:37,760 --> 00:25:46,460
permissions really cool it is so hard to

00:25:43,370 --> 00:25:48,470
use that the web UI never actually

00:25:46,460 --> 00:25:50,780
displays the plain text value you copy

00:25:48,470 --> 00:25:53,929
and paste this like encoded value and

00:25:50,780 --> 00:25:56,840
then you run their CLI locally to decode

00:25:53,929 --> 00:25:58,010
that value into plain text which is not

00:25:56,840 --> 00:26:00,740
really friendly to someone who's

00:25:58,010 --> 00:26:01,730
non-technical so we're looking we're

00:26:00,740 --> 00:26:03,140
looking we're digging we're like how

00:26:01,730 --> 00:26:05,570
does this work what is the encoding and

00:26:03,140 --> 00:26:08,360
it turns out very long story short that

00:26:05,570 --> 00:26:11,780
that process that service that

00:26:08,360 --> 00:26:14,330
application again I will not name stores

00:26:11,780 --> 00:26:18,409
all of the data in one file on disk it

00:26:14,330 --> 00:26:20,419
is not encrypted and it's in JSON so all

00:26:18,409 --> 00:26:22,610
policy and enforcement happens

00:26:20,419 --> 00:26:24,230
client-side in the reactor ember or

00:26:22,610 --> 00:26:26,990
whatever front-end JavaScript framework

00:26:24,230 --> 00:26:28,850
they were using additionally that off

00:26:26,990 --> 00:26:30,440
Yusuke ssin not even encryption it was

00:26:28,850 --> 00:26:33,020
just off Yusuke ssin upon further

00:26:30,440 --> 00:26:35,860
investigation all happens on the client

00:26:33,020 --> 00:26:38,960
side and then here's the real kicker

00:26:35,860 --> 00:26:40,940
anyone with half a brain can open up

00:26:38,960 --> 00:26:44,600
like the web inspector in chrome or

00:26:40,940 --> 00:26:46,549
firefox see the ajax request to the raw

00:26:44,600 --> 00:26:48,740
JSON file which is just served directly

00:26:46,549 --> 00:26:51,510
by the server and get all passwords and

00:26:48,740 --> 00:26:53,370
usernames and credentials in plaintext

00:26:51,510 --> 00:26:54,780
and we actually talked to a company who

00:26:53,370 --> 00:26:56,130
was using this we talked to the

00:26:54,780 --> 00:26:59,070
developers were like you know this

00:26:56,130 --> 00:27:00,780
happens yes and they said don't tell the

00:26:59,070 --> 00:27:05,880
security team it's how we get access to

00:27:00,780 --> 00:27:09,330
things I kid you not but the tool felt

00:27:05,880 --> 00:27:11,940
so secure because you had to run some

00:27:09,330 --> 00:27:13,200
commands and do the it felt secure but

00:27:11,940 --> 00:27:15,000
as an industry we've been brainwashed

00:27:13,200 --> 00:27:16,470
we've been brainwashed to believe that

00:27:15,000 --> 00:27:19,560
security has to be hard and it doesn't

00:27:16,470 --> 00:27:22,110
and volt proves that vault has been

00:27:19,560 --> 00:27:23,250
audited by the NCC group over five times

00:27:22,110 --> 00:27:26,550
now which is a very reputable

00:27:23,250 --> 00:27:27,690
independent security consulting firm the

00:27:26,550 --> 00:27:29,910
first time they found a few

00:27:27,690 --> 00:27:32,790
vulnerabilities we fixed it the second

00:27:29,910 --> 00:27:34,020
time no vulnerabilities since then the

00:27:32,790 --> 00:27:36,360
only vulnerabilities that have been

00:27:34,020 --> 00:27:38,610
found involved has been very very minut

00:27:36,360 --> 00:27:40,560
they register low on the severity scale

00:27:38,610 --> 00:27:42,540
and there are things like timing attacks

00:27:40,560 --> 00:27:44,400
where we're not using a constant string

00:27:42,540 --> 00:27:45,900
comparison so a very skilled attacker

00:27:44,400 --> 00:27:48,300
might be able to guess the length of a

00:27:45,900 --> 00:27:50,490
password and we always fix them in a

00:27:48,300 --> 00:27:52,170
very timely manner vault is also open

00:27:50,490 --> 00:27:56,430
source so you're free to audit it on

00:27:52,170 --> 00:27:58,650
your own back to the demo so I wrote

00:27:56,430 --> 00:28:02,030
some static secrets I can also list some

00:27:58,650 --> 00:28:05,490
static secrets if I can type well list

00:28:02,030 --> 00:28:07,830
secret we can see that I have a key foo

00:28:05,490 --> 00:28:11,400
in there so this is your basic create

00:28:07,830 --> 00:28:14,550
read update delete list key value store

00:28:11,400 --> 00:28:15,390
again very similar to Redis very similar

00:28:14,550 --> 00:28:17,400
to memcache

00:28:15,390 --> 00:28:19,590
the data is stored but it's encrypted in

00:28:17,400 --> 00:28:22,710
transit and at rest so I'm going to go

00:28:19,590 --> 00:28:25,400
ahead and delete this key and now you

00:28:22,710 --> 00:28:28,020
can see that I have no keys in secret

00:28:25,400 --> 00:28:30,360
again probably don't feel secure but I

00:28:28,020 --> 00:28:31,770
promise it is this one's actually extra

00:28:30,360 --> 00:28:35,180
secure because there's no data ever

00:28:31,770 --> 00:28:39,120
persisted it's all running in memory but

00:28:35,180 --> 00:28:40,380
vault has multiple storage backends so

00:28:39,120 --> 00:28:42,120
now I want to talk about semi static

00:28:40,380 --> 00:28:44,540
secrets or where vault acts as the

00:28:42,120 --> 00:28:47,850
encryption as a service and with vault

00:28:44,540 --> 00:28:50,460
everything is based off of kind of like

00:28:47,850 --> 00:28:52,440
filesystem mounts in a way so here are

00:28:50,460 --> 00:28:54,030
the default mounts we were already

00:28:52,440 --> 00:28:56,250
looking at secret slash that's where

00:28:54,030 --> 00:28:56,760
data is just stored in transit and at

00:28:56,250 --> 00:28:58,440
rest

00:28:56,760 --> 00:29:00,030
there's cubbyhole which we won't talk

00:28:58,440 --> 00:29:01,710
about here today and then there's cysts

00:29:00,030 --> 00:29:04,440
which is like internal config like an

00:29:01,710 --> 00:29:05,340
actual cyst now so in order to do the

00:29:04,440 --> 00:29:07,890
encryption as a server

00:29:05,340 --> 00:29:09,180
I have to mount the vault back end and I

00:29:07,890 --> 00:29:10,860
do that by issuing the vault mount

00:29:09,180 --> 00:29:13,140
command so I'm going to go ahead and

00:29:10,860 --> 00:29:14,580
mount the transit back end and this is

00:29:13,140 --> 00:29:16,710
now available at the track the path

00:29:14,580 --> 00:29:19,320
transit everything involved is path

00:29:16,710 --> 00:29:22,170
based vault is an HTTP API server so

00:29:19,320 --> 00:29:23,790
when I write to secret slash star that

00:29:22,170 --> 00:29:27,240
gets delegated to the secret back-end

00:29:23,790 --> 00:29:29,090
when I write to transit slash star that

00:29:27,240 --> 00:29:31,830
gets delegated to the transit backend

00:29:29,090 --> 00:29:33,450
when I write to you know sis slash star

00:29:31,830 --> 00:29:34,860
that gets delegated to the Syst back-end

00:29:33,450 --> 00:29:37,680
and when I write to banana

00:29:34,860 --> 00:29:41,310
slash bar that gets routed to oh no

00:29:37,680 --> 00:29:43,080
back-end 404 back-end doesn't exist so

00:29:41,310 --> 00:29:44,640
we can go ahead and run vault mount's

00:29:43,080 --> 00:29:49,050
again and you'll see that the transit

00:29:44,640 --> 00:29:51,720
back-end is now mounted most backends

00:29:49,050 --> 00:29:53,100
have to be configured before use and

00:29:51,720 --> 00:29:54,210
that makes sense especially when you

00:29:53,100 --> 00:29:57,540
start talking about communicating with

00:29:54,210 --> 00:29:58,950
databases so the transit back-end is you

00:29:57,540 --> 00:30:00,890
can think of it as a like a collection

00:29:58,950 --> 00:30:03,300
of encryption keys and decryption keys

00:30:00,890 --> 00:30:05,880
so in order to use it I have to first

00:30:03,300 --> 00:30:08,310
make a key but I don't have to run any

00:30:05,880 --> 00:30:10,800
like special commands I can just create

00:30:08,310 --> 00:30:13,140
a key so I'm going to write to transit

00:30:10,800 --> 00:30:15,360
key as my key and I have now created an

00:30:13,140 --> 00:30:16,860
encryption key it was that easy I didn't

00:30:15,360 --> 00:30:18,510
have to run any special command or copy

00:30:16,860 --> 00:30:20,340
and paste anything from Stack Overflow I

00:30:18,510 --> 00:30:22,530
just made a key and I don't actually

00:30:20,340 --> 00:30:25,380
know what that key is because unless I

00:30:22,530 --> 00:30:26,880
explicitly allow vault to return the

00:30:25,380 --> 00:30:28,470
encryption key to me vote will never

00:30:26,880 --> 00:30:33,390
divulge it there's no way to get it back

00:30:28,470 --> 00:30:35,970
it's only stored internally so now let

00:30:33,390 --> 00:30:41,400
me encrypt some data so I'm going to

00:30:35,970 --> 00:30:42,990
write to transit transit keys my key

00:30:41,400 --> 00:30:45,480
because remember I just created a key

00:30:42,990 --> 00:30:47,220
named my key the name of the key is just

00:30:45,480 --> 00:30:49,590
like a human friendly pointer almost

00:30:47,220 --> 00:30:50,760
like a sim linked to the key as we'll

00:30:49,590 --> 00:30:52,920
talk about a little bit it's actually a

00:30:50,760 --> 00:30:54,780
sim linked to a ring of keys because

00:30:52,920 --> 00:30:57,540
what we'll do encryption and upgraded

00:30:54,780 --> 00:30:58,560
encryption on those keys now one of the

00:30:57,540 --> 00:31:00,330
things that's a little bit weird about

00:30:58,560 --> 00:31:03,060
the transit back-end is that the data we

00:31:00,330 --> 00:31:05,220
pass in has to be based 64 encoded does

00:31:03,060 --> 00:31:07,410
anyone have an idea of why we might

00:31:05,220 --> 00:31:14,130
require people implementing this to

00:31:07,410 --> 00:31:16,790
encode their data in base 64 anyone you

00:31:14,130 --> 00:31:16,790
have three seconds

00:31:18,040 --> 00:31:25,070
close very close it's not the URL it's

00:31:22,850 --> 00:31:26,990
the payload everything involved is a

00:31:25,070 --> 00:31:29,350
JSON API so we're going to be sending a

00:31:26,990 --> 00:31:31,790
JSON payload up to this vault server and

00:31:29,350 --> 00:31:33,350
there's no guarantee that the data

00:31:31,790 --> 00:31:35,750
you're encrypting is representable to

00:31:33,350 --> 00:31:37,640
ASCII characters for example I could be

00:31:35,750 --> 00:31:39,950
encrypting a PDF or an image or a binary

00:31:37,640 --> 00:31:42,950
file right now so in order to safely

00:31:39,950 --> 00:31:45,200
transport that as text we have to pay 64

00:31:42,950 --> 00:31:46,790
encoded so I'm just going to cheat and

00:31:45,200 --> 00:31:47,960
I'm going to use the coolest thing that

00:31:46,790 --> 00:31:49,280
every time I show people this they're

00:31:47,960 --> 00:31:50,720
really excited did you know that you

00:31:49,280 --> 00:31:54,110
don't have to pipe echo something you

00:31:50,720 --> 00:31:57,980
can just use three three less fans it's

00:31:54,110 --> 00:31:59,450
my favorite bash syntax hack ever so

00:31:57,980 --> 00:32:02,840
what this does is I spawned a sub shell

00:31:59,450 --> 00:32:07,550
to basics T for encode foo which is the

00:32:02,840 --> 00:32:11,380
same as echo foo pipe pipe base64 so

00:32:07,550 --> 00:32:11,380
that's what I passed in is the plaintext

00:32:12,400 --> 00:32:25,400
that data that data was returned to us

00:32:19,970 --> 00:32:25,970
maybe turns it oh I wrote to the wrong

00:32:25,400 --> 00:32:30,080
endpoint

00:32:25,970 --> 00:32:34,760
whoops transit encrypt plaintext equals

00:32:30,080 --> 00:32:37,480
this is why bass demos are hard there we

00:32:34,760 --> 00:32:41,150
go that data is returned to us as

00:32:37,480 --> 00:32:44,810
ciphertext so this is the encrypted data

00:32:41,150 --> 00:32:48,230
vault did not store any of this it is a

00:32:44,810 --> 00:32:50,180
pass through it happens in transit it is

00:32:48,230 --> 00:32:51,740
now my applications responsibility to

00:32:50,180 --> 00:32:53,240
store this data somewhere maybe in a

00:32:51,740 --> 00:32:55,550
database or in the file system but

00:32:53,240 --> 00:32:57,020
what's important is that my Asian

00:32:55,550 --> 00:32:59,630
doesn't have the encryption key or the

00:32:57,020 --> 00:33:01,520
decryption key vault does so in order to

00:32:59,630 --> 00:33:04,160
get this plaintext value back in order

00:33:01,520 --> 00:33:06,680
to get food back we have to pass this

00:33:04,160 --> 00:33:09,500
ciphertext along with our vault token

00:33:06,680 --> 00:33:11,300
our authentication back to vault so let

00:33:09,500 --> 00:33:15,050
me show you where that works is that we

00:33:11,300 --> 00:33:16,940
have to write to transit decrypt so

00:33:15,050 --> 00:33:19,490
previously we wrote to encrypt now we're

00:33:16,940 --> 00:33:23,870
writing to decrypt with the name of the

00:33:19,490 --> 00:33:25,490
key and we pass in the cipher text since

00:33:23,870 --> 00:33:28,640
this is already basically four encoded

00:33:25,490 --> 00:33:29,870
we won't have to encode it again so I'm

00:33:28,640 --> 00:33:32,480
just going to go ahead and copy

00:33:29,870 --> 00:33:36,200
paste that and now I'm going to get back

00:33:32,480 --> 00:33:39,830
a 64 encoded plaintext what you can

00:33:36,200 --> 00:33:44,000
already see is very similar to what we

00:33:39,830 --> 00:33:44,900
had up here but I'll go ahead and just

00:33:44,000 --> 00:33:49,580
prove it to you

00:33:44,900 --> 00:33:53,780
so echo pipe base64 - gesture code and

00:33:49,580 --> 00:33:56,809
it's su so again probably not feeling

00:33:53,780 --> 00:33:58,640
super secure now but we have an

00:33:56,809 --> 00:34:00,680
encryption service we have a thing we

00:33:58,640 --> 00:34:01,940
can use for encryption as a service and

00:34:00,680 --> 00:34:06,710
our applications don't have to implement

00:34:01,940 --> 00:34:08,659
AES or GCM or CBC it's just there now if

00:34:06,710 --> 00:34:09,980
you're familiar with those different

00:34:08,659 --> 00:34:11,810
cryptography suites and the different

00:34:09,980 --> 00:34:13,550
algorithms you can configure vault to

00:34:11,810 --> 00:34:14,929
use them those are options you can pass

00:34:13,550 --> 00:34:18,139
in when you say create this key or

00:34:14,929 --> 00:34:19,639
create this keyring but one of the cool

00:34:18,139 --> 00:34:21,800
things about vault is that we can

00:34:19,639 --> 00:34:23,450
upgrade to this keyring at any time

00:34:21,800 --> 00:34:25,310
and when we upgrade that key we get a

00:34:23,450 --> 00:34:27,620
new encryption key again the application

00:34:25,310 --> 00:34:29,270
doesn't know about that but we have old

00:34:27,620 --> 00:34:32,090
data and that old data is encrypted with

00:34:29,270 --> 00:34:35,570
that old key so it's lost forever right

00:34:32,090 --> 00:34:37,790
no vault actually keeps a keyring of all

00:34:35,570 --> 00:34:39,679
of the previous existing encryption and

00:34:37,790 --> 00:34:41,149
decryption keys so whenever your

00:34:39,679 --> 00:34:42,470
application goes back to vault and says

00:34:41,149 --> 00:34:44,270
hey I have this ciphertext please

00:34:42,470 --> 00:34:46,220
decrypt it but we'll say hey sure here's

00:34:44,270 --> 00:34:48,409
the plaintext back but then in the

00:34:46,220 --> 00:34:50,419
background it'll upgrade that encryption

00:34:48,409 --> 00:34:51,620
key to the newest version and you can

00:34:50,419 --> 00:34:53,690
actually get analytics data back from

00:34:51,620 --> 00:34:56,030
vault for your compliance officers to be

00:34:53,690 --> 00:34:58,430
able to say yes all of our data is

00:34:56,030 --> 00:35:01,000
encrypted with a key that is at most no

00:34:58,430 --> 00:35:05,300
more than two weeks old

00:35:01,000 --> 00:35:07,760
pretty cool stuff let's talk about

00:35:05,300 --> 00:35:10,010
dynamic secrets now so this is all

00:35:07,760 --> 00:35:11,660
static data right I typed in plaintext

00:35:10,010 --> 00:35:14,270
data but what if I want to do something

00:35:11,660 --> 00:35:17,360
more dynamic well I'm going to go ahead

00:35:14,270 --> 00:35:19,970
and mount the new unified database

00:35:17,360 --> 00:35:21,500
back-end involved previous versions of

00:35:19,970 --> 00:35:23,720
vault prior to zero point seven point

00:35:21,500 --> 00:35:25,460
two had individual backends there was a

00:35:23,720 --> 00:35:27,260
Postgres back-end and a my sequel

00:35:25,460 --> 00:35:29,210
back-end and i'm Microsoft s2l back-end

00:35:27,260 --> 00:35:31,450
and we've unified those into what we're

00:35:29,210 --> 00:35:34,400
calling the unified database back-end

00:35:31,450 --> 00:35:35,810
this helps because you can just think

00:35:34,400 --> 00:35:37,070
about it as a database you don't have to

00:35:35,810 --> 00:35:40,100
think about the implementation details

00:35:37,070 --> 00:35:41,960
of Postgres for example and now because

00:35:40,100 --> 00:35:43,970
I'm terrible at typing I've cheated and

00:35:41,960 --> 00:35:45,560
created these

00:35:43,970 --> 00:35:47,900
scripts ahead of time but I'm going to

00:35:45,560 --> 00:35:50,810
show them to you so the first one here

00:35:47,900 --> 00:35:52,660
is a vault command that is going to set

00:35:50,810 --> 00:35:55,040
up the connection to a Postgres database

00:35:52,660 --> 00:35:56,480
this Postgres database happens to be

00:35:55,040 --> 00:35:59,000
running on localhost but that could have

00:35:56,480 --> 00:36:00,740
been like an RDS URL or you know a

00:35:59,000 --> 00:36:03,920
pointer to database service to our

00:36:00,740 --> 00:36:06,290
console or something so I'm telling the

00:36:03,920 --> 00:36:09,080
database back-end to use the PostgreSQL

00:36:06,290 --> 00:36:11,360
plug-in I'm telling it to connect using

00:36:09,080 --> 00:36:14,210
my local connection and connect to the

00:36:11,360 --> 00:36:16,400
database named my app and I'm telling it

00:36:14,210 --> 00:36:18,320
that the only roles we'll talk about

00:36:16,400 --> 00:36:19,850
roles in a second the only roles that

00:36:18,320 --> 00:36:24,410
this back-end responds to are read-only

00:36:19,850 --> 00:36:26,810
and a role is just a named basically

00:36:24,410 --> 00:36:31,060
sequel query so I'm going to go ahead

00:36:26,810 --> 00:36:34,130
and run this set a PG connection and

00:36:31,060 --> 00:36:35,690
perfect so now I have configured vault

00:36:34,130 --> 00:36:39,350
to be able to talk to my local Postgres

00:36:35,690 --> 00:36:41,810
cluster now I have to tell volt how to

00:36:39,350 --> 00:36:43,940
create users so won't have some really

00:36:41,810 --> 00:36:45,740
basic understanding of you know how to

00:36:43,940 --> 00:36:47,060
create a user but it doesn't know what

00:36:45,740 --> 00:36:49,130
permissions you'd want to grant to that

00:36:47,060 --> 00:36:51,740
user perhaps you want to grant read-only

00:36:49,130 --> 00:36:55,400
perhaps you want to grant read select

00:36:51,740 --> 00:36:57,830
select update but not delete or perhaps

00:36:55,400 --> 00:36:59,570
you want to grant delete only so vote

00:36:57,830 --> 00:37:01,580
has no idea how you'd want to generate

00:36:59,570 --> 00:37:04,550
those permissions so what we do is we

00:37:01,580 --> 00:37:06,800
give you the ability to give us that SQL

00:37:04,550 --> 00:37:09,890
that you want to run so you can still

00:37:06,800 --> 00:37:12,200
copy and paste from Stack Overflow don't

00:37:09,890 --> 00:37:18,260
worry let me show you what that looks

00:37:12,200 --> 00:37:19,460
like so cat set up PG role so here this

00:37:18,260 --> 00:37:22,340
is really the one I didn't want to type

00:37:19,460 --> 00:37:25,550
out here we create a roll named

00:37:22,340 --> 00:37:28,100
read-only so this part of the URL up

00:37:25,550 --> 00:37:30,740
here this read-only part is the name of

00:37:28,100 --> 00:37:32,960
the role I'm telling it that it belongs

00:37:30,740 --> 00:37:35,150
to the database name PostgreSQL and I'm

00:37:32,960 --> 00:37:37,880
giving it a creation statement that

00:37:35,150 --> 00:37:39,770
creation statement is to create a thing

00:37:37,880 --> 00:37:42,650
with a password that's valid until an

00:37:39,770 --> 00:37:45,140
expiration and then give select which is

00:37:42,650 --> 00:37:47,990
read-only on all of the tables in this

00:37:45,140 --> 00:37:50,720
database so what are those curly braces

00:37:47,990 --> 00:37:52,400
in there well name password and

00:37:50,720 --> 00:37:54,800
expiration are actually filled in by

00:37:52,400 --> 00:37:57,280
full dynamically at runtime so those are

00:37:54,800 --> 00:37:59,260
interpolated

00:37:57,280 --> 00:38:01,330
vaults gonna generate a high entropy

00:37:59,260 --> 00:38:03,730
UUID for both the name and the password

00:38:01,330 --> 00:38:06,160
and then as I said before these

00:38:03,730 --> 00:38:08,500
credentials have a lifetime so volt uses

00:38:06,160 --> 00:38:10,390
Postgres is valid until clause to make

00:38:08,500 --> 00:38:13,840
sure that these credentials expire after

00:38:10,390 --> 00:38:17,560
their lifetime so I'm going to go ahead

00:38:13,840 --> 00:38:20,320
and run this set of PT role cool

00:38:17,560 --> 00:38:22,420
now that role is written and now to

00:38:20,320 --> 00:38:23,560
generate a database credential so all of

00:38:22,420 --> 00:38:25,710
these steps would have been done by like

00:38:23,560 --> 00:38:28,120
an operator or DBA in advance as a

00:38:25,710 --> 00:38:30,070
developer I'll put on my developer hat I

00:38:28,120 --> 00:38:34,390
need a Postgres credential so my app can

00:38:30,070 --> 00:38:39,970
talk I just read all read from database

00:38:34,390 --> 00:38:42,400
creds read-only so I can type and I get

00:38:39,970 --> 00:38:43,990
back credentials and this is a real

00:38:42,400 --> 00:38:45,640
username and password that can connect

00:38:43,990 --> 00:38:47,020
to this database that is assigned to

00:38:45,640 --> 00:38:49,030
those permissions and let me prove it to

00:38:47,020 --> 00:38:53,200
you so I'm going to go ahead and login

00:38:49,030 --> 00:38:56,800
to the Postgres database here and when I

00:38:53,200 --> 00:38:58,000
list the users you can see that of

00:38:56,800 --> 00:39:00,880
course it's down on the bottom of the

00:38:58,000 --> 00:39:03,010
screen you can see that there's a V

00:39:00,880 --> 00:39:06,220
token which is the username that was

00:39:03,010 --> 00:39:09,340
created in my database as a user and

00:39:06,220 --> 00:39:15,280
that that password is valid until May

00:39:09,340 --> 00:39:18,700
18th at 10:30 3844 hmm that's 2 hours

00:39:15,280 --> 00:39:22,450
ago or 10 hours from now what's going on

00:39:18,700 --> 00:39:25,420
there starts with a u n ends and T C

00:39:22,450 --> 00:39:28,480
right so this database is configured for

00:39:25,420 --> 00:39:35,230
UTC times so that's that is whatever

00:39:28,480 --> 00:39:38,380
time from now and UTC cool questions

00:39:35,230 --> 00:39:42,070
about that what's great is that each

00:39:38,380 --> 00:39:43,810
time I should leave Postgres each time I

00:39:42,070 --> 00:39:46,180
run this command I'm going to get a

00:39:43,810 --> 00:39:47,800
different username and password so each

00:39:46,180 --> 00:39:50,500
time I run this command volt is

00:39:47,800 --> 00:39:52,810
connecting to Postgres running that SQL

00:39:50,500 --> 00:39:54,760
interpolating those values we're turning

00:39:52,810 --> 00:39:56,230
back the username and password to me and

00:39:54,760 --> 00:39:58,710
you'll notice that these values do have

00:39:56,230 --> 00:39:58,710
a lifetime

00:40:03,930 --> 00:40:07,750
I'm running the volt CLI but like you

00:40:06,700 --> 00:40:10,630
probably don't want to install the volt

00:40:07,750 --> 00:40:12,130
CLI on every tool how many people here

00:40:10,630 --> 00:40:15,609
write in a programming language that can

00:40:12,130 --> 00:40:17,980
make an HTTP call you can interact with

00:40:15,609 --> 00:40:19,420
the vault and let me show you I'm going

00:40:17,980 --> 00:40:23,800
to use everyone's favorite tool which is

00:40:19,420 --> 00:40:26,950
curl telling you it's the best thing

00:40:23,800 --> 00:40:28,300
ever I am going to curl and unlike the

00:40:26,950 --> 00:40:30,250
vault CLI I have to pass my

00:40:28,300 --> 00:40:31,720
authentication in as a header we use a

00:40:30,250 --> 00:40:37,480
header for security so that it doesn't

00:40:31,720 --> 00:40:39,910
get logged in the access logs so I'm

00:40:37,480 --> 00:40:41,380
going to pass in my ex vault token which

00:40:39,910 --> 00:40:44,050
is route if you remember earlier I did

00:40:41,380 --> 00:40:45,670
default off route and then this vault

00:40:44,050 --> 00:40:51,820
server happens to be running a localhost

00:40:45,670 --> 00:40:54,850
so 0 0 why can't I type 0 0 180 200 the

00:40:51,820 --> 00:40:56,740
API lives at v1 and then everything else

00:40:54,850 --> 00:40:59,740
is just what we type database Krebs

00:40:56,740 --> 00:41:03,040
read-only and I don't know if I

00:40:59,740 --> 00:41:05,170
installed JQ or not I did look at that I

00:41:03,040 --> 00:41:06,580
typed that right there first how people

00:41:05,170 --> 00:41:10,030
ever got a curl command right the first

00:41:06,580 --> 00:41:13,570
time they typed it man I'm on our roll

00:41:10,030 --> 00:41:15,130
all right here we get back the whole

00:41:13,570 --> 00:41:17,080
JSON payload and this is actually what

00:41:15,130 --> 00:41:19,330
the CLI is getting back to CLI is just

00:41:17,080 --> 00:41:22,030
an HTTP API wrapper with a little bit of

00:41:19,330 --> 00:41:24,280
caching for us locally for like the

00:41:22,030 --> 00:41:26,260
credentials notice that that's a real

00:41:24,280 --> 00:41:28,960
username and password so if your data if

00:41:26,260 --> 00:41:31,570
your application can speak HTTP and

00:41:28,960 --> 00:41:33,340
parse JSON you can interact with vault

00:41:31,570 --> 00:41:35,410
if you write in a programming language

00:41:33,340 --> 00:41:44,700
that cannot make HTTP requests and

00:41:35,410 --> 00:41:49,080
cannot parse JSON we're hiring questions

00:41:44,700 --> 00:41:52,420
cool let's talk about non databases now

00:41:49,080 --> 00:41:58,900
I'm going to go ahead and mount the AWS

00:41:52,420 --> 00:42:01,720
back-end in order for volt to generate I

00:41:58,900 --> 00:42:05,830
am credentials it has to be given a user

00:42:01,720 --> 00:42:07,720
and I am user that has enough permission

00:42:05,830 --> 00:42:09,550
that is the superset of the permissions

00:42:07,720 --> 00:42:10,720
that could ever grant so what does that

00:42:09,550 --> 00:42:12,790
mean well that means you're going to

00:42:10,720 --> 00:42:16,030
have to give vault a privileged I am

00:42:12,790 --> 00:42:17,560
user probably not a root user but it has

00:42:16,030 --> 00:42:19,420
to have the ability to create other use

00:42:17,560 --> 00:42:20,470
years and it has to have the permissions

00:42:19,420 --> 00:42:22,420
that you're going to grant to any of

00:42:20,470 --> 00:42:24,670
those other users because Amazon's

00:42:22,420 --> 00:42:26,920
permission bottle rightfully so won't

00:42:24,670 --> 00:42:28,630
let you grant permissions to a sub user

00:42:26,920 --> 00:42:30,700
that you don't have that would be a

00:42:28,630 --> 00:42:32,620
privilege escalation right if I create a

00:42:30,700 --> 00:42:33,460
user that can create other users but I

00:42:32,620 --> 00:42:35,050
don't have permission to launch

00:42:33,460 --> 00:42:38,320
instances why should I be able to give

00:42:35,050 --> 00:42:40,210
them permission to launch instances so a

00:42:38,320 --> 00:42:41,290
lot of times this is off-putting to

00:42:40,210 --> 00:42:42,760
people who are getting started with the

00:42:41,290 --> 00:42:45,580
vault they're like I don't want to give

00:42:42,760 --> 00:42:47,320
that credential that's not one no it's

00:42:45,580 --> 00:42:49,540
actually better because every request

00:42:47,320 --> 00:42:51,160
and response in vault is audited so

00:42:49,540 --> 00:42:52,480
instead of giving this to a human who

00:42:51,160 --> 00:42:54,760
you're going to rely on clicking buttons

00:42:52,480 --> 00:42:56,380
in the UI you have a full audit log that

00:42:54,760 --> 00:42:57,700
shows you every request in response that

00:42:56,380 --> 00:43:00,700
happened involved so you have an entire

00:42:57,700 --> 00:43:02,440
history so let's go ahead and configure

00:43:00,700 --> 00:43:05,920
vault there's a setup

00:43:02,440 --> 00:43:09,370
AWS connection thing here and I've

00:43:05,920 --> 00:43:10,960
cheated because I have these in

00:43:09,370 --> 00:43:13,240
environment variables already so that

00:43:10,960 --> 00:43:15,160
you don't get to see them but my access

00:43:13,240 --> 00:43:17,820
key my secret key in my region are all

00:43:15,160 --> 00:43:20,380
configured in an environment variable

00:43:17,820 --> 00:43:22,060
all I'm doing is I'm giving these to

00:43:20,380 --> 00:43:25,540
vault and vaults going to ink restore

00:43:22,060 --> 00:43:29,320
them encrypted in its configuration so

00:43:25,540 --> 00:43:31,870
let me go ahead and run that boom I'm

00:43:29,320 --> 00:43:33,340
now configured to talk to AWS and vault

00:43:31,870 --> 00:43:34,630
actually validates that connection the

00:43:33,340 --> 00:43:36,430
same way it did with the database so

00:43:34,630 --> 00:43:37,570
when I ran that query it actually tried

00:43:36,430 --> 00:43:39,640
to make a dummy connection to the

00:43:37,570 --> 00:43:42,090
database to validate my credentials so I

00:43:39,640 --> 00:43:44,650
know my AWS credentials are valid

00:43:42,090 --> 00:43:46,810
similar to the database back-end we have

00:43:44,650 --> 00:43:49,720
to tell vault how we want it to might

00:43:46,810 --> 00:43:51,370
make I am users which permissions should

00:43:49,720 --> 00:43:53,800
these I am users have should they be

00:43:51,370 --> 00:43:56,020
root users probably not should they have

00:43:53,800 --> 00:43:59,260
the ability to launch c43 excels in all

00:43:56,020 --> 00:44:00,700
regions probably not well instead of

00:43:59,260 --> 00:44:03,580
vault building its own really complex

00:44:00,700 --> 00:44:06,190
policy engine amazon ernie has one it's

00:44:03,580 --> 00:44:09,960
called I am policies and we have one

00:44:06,190 --> 00:44:11,260
here and apparently I'm not able to open

00:44:09,960 --> 00:44:12,880
there we go

00:44:11,260 --> 00:44:15,370
we have one here so this is a really

00:44:12,880 --> 00:44:17,710
basic Amazon iam policy that gives

00:44:15,370 --> 00:44:20,530
whatever user I create the ability to

00:44:17,710 --> 00:44:24,160
manage all iam resources pretty

00:44:20,530 --> 00:44:26,950
straightforward let me go ahead and

00:44:24,160 --> 00:44:29,020
upload this now so I'm going to make to

00:44:26,950 --> 00:44:31,030
create a role in vault that role is

00:44:29,020 --> 00:44:32,230
going to be called user and

00:44:31,030 --> 00:44:35,170
user is going to be attached to that

00:44:32,230 --> 00:44:37,480
policy each time I generate one so let

00:44:35,170 --> 00:44:39,550
me show you how to do that alright AWS

00:44:37,480 --> 00:44:42,070
roles user so I'm creating a role named

00:44:39,550 --> 00:44:44,350
user and I'm passing in the policy and

00:44:42,070 --> 00:44:47,080
that policy is that file on disk and

00:44:44,350 --> 00:44:49,450
volt actually reads from disk if you

00:44:47,080 --> 00:44:53,650
pass in the @ sign so that reads a local

00:44:49,450 --> 00:44:54,850
file from disk by using the @ sign so

00:44:53,650 --> 00:44:57,700
now what we've done is we've connected

00:44:54,850 --> 00:45:00,370
to AWS we've told well that whenever a

00:44:57,700 --> 00:45:02,980
user asks you to create a roll named

00:45:00,370 --> 00:45:05,950
user to assign to this policy to that

00:45:02,980 --> 00:45:07,510
iam user so just like the aw are just

00:45:05,950 --> 00:45:11,890
like the database back-end now all we

00:45:07,510 --> 00:45:14,200
have to do is read from AWS creds user

00:45:11,890 --> 00:45:15,340
and this will take a second longer you

00:45:14,200 --> 00:45:17,200
notice that wasn't as fast with the

00:45:15,340 --> 00:45:19,810
database connection and that's because

00:45:17,200 --> 00:45:22,690
it actually had to go from my instance

00:45:19,810 --> 00:45:24,430
talk to Amazon run a query get the run

00:45:22,690 --> 00:45:26,290
out request get the request back parse

00:45:24,430 --> 00:45:27,970
it and put it in the thing here and

00:45:26,290 --> 00:45:29,770
you'll notice that if again if I run it

00:45:27,970 --> 00:45:31,030
again it'll take a second or two but

00:45:29,770 --> 00:45:34,650
notice that I'm getting back a different

00:45:31,030 --> 00:45:34,650
access key and a different secret key

00:45:35,670 --> 00:45:40,600
these are valid for a really long time

00:45:38,110 --> 00:45:44,290
how long is 768 hours without googling

00:45:40,600 --> 00:45:46,810
it perfect 32 days so 32 days is a

00:45:44,290 --> 00:45:48,130
really long time I think 30 seconds is

00:45:46,810 --> 00:45:51,370
better so I'm going to go ahead and

00:45:48,130 --> 00:45:53,140
write AWS config lease and I'm going to

00:45:51,370 --> 00:45:55,840
say that this lease is 30 seconds and

00:45:53,140 --> 00:45:59,320
that the lease max is will do 5 minutes

00:45:55,840 --> 00:46:00,780
what does this mean well involve vault

00:45:59,320 --> 00:46:03,040
has this really cool leasing model

00:46:00,780 --> 00:46:04,990
meaning when you generate or credential

00:46:03,040 --> 00:46:06,370
that credentials valid for the minimum

00:46:04,990 --> 00:46:10,780
amount of time in the lease in this case

00:46:06,370 --> 00:46:12,490
30 seconds that credential can hit a TTL

00:46:10,780 --> 00:46:13,900
it can go back to vault and say hand

00:46:12,490 --> 00:46:15,550
still using the credential hands still

00:46:13,900 --> 00:46:18,190
using the credential within that 30

00:46:15,550 --> 00:46:19,990
seconds and it resets the timer however

00:46:18,190 --> 00:46:21,610
at the end of 5 minutes whatever that

00:46:19,990 --> 00:46:22,060
leased maximum is that credentials

00:46:21,610 --> 00:46:23,650
revoked

00:46:22,060 --> 00:46:24,910
doesn't matter if it's still in use

00:46:23,650 --> 00:46:27,250
doesn't matter how many times it's been

00:46:24,910 --> 00:46:28,390
renewed what this allows you to do is

00:46:27,250 --> 00:46:32,110
this allows you to tell your compliance

00:46:28,390 --> 00:46:34,450
officer is that I guarantee any AWS

00:46:32,110 --> 00:46:36,670
credential that is unused is only valid

00:46:34,450 --> 00:46:38,860
for 30 seconds and anyone that is

00:46:36,670 --> 00:46:40,900
currently in use will live for at most 5

00:46:38,860 --> 00:46:43,530
minutes how many people can say that

00:46:40,900 --> 00:46:44,910
right now to their compliance officer

00:46:43,530 --> 00:46:46,559
exactly

00:46:44,910 --> 00:46:50,339
so I'm going to go ahead and write this

00:46:46,559 --> 00:46:52,410
but this is not proactive so it sorry

00:46:50,339 --> 00:46:54,240
this is not retroactive this does not go

00:46:52,410 --> 00:46:55,710
back and change those ones so those ones

00:46:54,240 --> 00:46:57,809
that were valid for 30 days are still

00:46:55,710 --> 00:46:59,309
valid for 30 days and those were on the

00:46:57,809 --> 00:47:00,599
screen and I'm sure someone tried to

00:46:59,309 --> 00:47:03,569
write it down because you're all

00:47:00,599 --> 00:47:05,970
dishonest people right I need to revoke

00:47:03,569 --> 00:47:07,289
those what do I do they were on the

00:47:05,970 --> 00:47:09,599
screen I shouldn't have done that it was

00:47:07,289 --> 00:47:15,539
in my notes all right I'm just going to

00:47:09,599 --> 00:47:17,549
go ahead and revoke everything under the

00:47:15,539 --> 00:47:18,900
AWS prefix and what this was going to do

00:47:17,549 --> 00:47:20,730
is this is going to iterate over vault

00:47:18,900 --> 00:47:22,380
internal database and make an API call

00:47:20,730 --> 00:47:23,579
to revoke those credentials you'll

00:47:22,380 --> 00:47:25,410
notice I took a couple seconds because

00:47:23,579 --> 00:47:26,759
we generated a few credentials but that

00:47:25,410 --> 00:47:29,640
just revoked all those credentials I

00:47:26,759 --> 00:47:31,049
created so if someone did write it down

00:47:29,640 --> 00:47:34,319
and you tried to access AWS right now

00:47:31,049 --> 00:47:36,059
you would not be able to do so we can do

00:47:34,319 --> 00:47:38,430
the same thing with Postgres so let me

00:47:36,059 --> 00:47:42,809
just show you real quick Postgres - you

00:47:38,430 --> 00:47:44,369
PostgreSQL or post ghosts so we have a

00:47:42,809 --> 00:47:45,630
user in here or a couple users in here

00:47:44,369 --> 00:47:47,789
right because I ran that command a few

00:47:45,630 --> 00:47:53,400
times it's time that they go away

00:47:47,789 --> 00:47:55,079
so vault revoked - prefix database all

00:47:53,400 --> 00:47:57,450
they're gone and I could I can actually

00:47:55,079 --> 00:47:59,460
restrict this to like just the read-only

00:47:57,450 --> 00:48:02,130
creds if I wanted to so it's a prefix

00:47:59,460 --> 00:48:06,390
match but let me run that same command

00:48:02,130 --> 00:48:09,539
again Postgres do you all gone that

00:48:06,390 --> 00:48:12,059
simple no Postgres commands no fancy

00:48:09,539 --> 00:48:14,220
things and again that command I ran it's

00:48:12,059 --> 00:48:16,019
an API call so you could have a service

00:48:14,220 --> 00:48:18,750
do that for you you could literally

00:48:16,019 --> 00:48:20,460
create a button that says oh and

00:48:18,750 --> 00:48:24,230
someone could click it and it would

00:48:20,460 --> 00:48:28,019
revoke everything how cool would that be

00:48:24,230 --> 00:48:30,569
I'm sorry for swearing I think it was

00:48:28,019 --> 00:48:32,130
funny though alright one of the last

00:48:30,569 --> 00:48:34,500
things I want to show you is vault

00:48:32,130 --> 00:48:38,519
acting as a certificate authority now

00:48:34,500 --> 00:48:40,230
this is complex vault masks as much of

00:48:38,519 --> 00:48:42,089
it as possible but there's a lot of

00:48:40,230 --> 00:48:43,410
complexity in setting up a CA you do

00:48:42,089 --> 00:48:45,599
have to have an understanding of like

00:48:43,410 --> 00:48:48,539
x5o and I and TLS and basic

00:48:45,599 --> 00:48:50,400
understanding so I have decided that you

00:48:48,539 --> 00:48:52,710
don't need to know that because I wrote

00:48:50,400 --> 00:48:55,619
it all in advance in this magical setup

00:48:52,710 --> 00:48:56,940
PKI script but what this is doing is

00:48:55,619 --> 00:48:58,740
this is configuring vault with a bunch

00:48:56,940 --> 00:49:00,330
of stuff it uses an internal sea

00:48:58,740 --> 00:49:02,190
a but we could use an intermediate CA or

00:49:00,330 --> 00:49:03,600
on root certificate it configures the

00:49:02,190 --> 00:49:05,369
krills and you are on planes

00:49:03,600 --> 00:49:07,830
sorry it's a bunch of stuff that is

00:49:05,369 --> 00:49:09,150
right now I'm throwing away and all this

00:49:07,830 --> 00:49:10,500
code will be open source on github at

00:49:09,150 --> 00:49:12,330
the end of the talk is could soon as I

00:49:10,500 --> 00:49:13,619
switch it from private to public so

00:49:12,330 --> 00:49:14,880
you'll be able to look at this don't

00:49:13,619 --> 00:49:16,380
want you to get bogged down in that too

00:49:14,880 --> 00:49:19,140
much because the nice thing about vault

00:49:16,380 --> 00:49:20,850
is that it's a one-time config so I run

00:49:19,140 --> 00:49:24,630
this command for setup PKI

00:49:20,850 --> 00:49:27,540
and it's done I don't ever have to think

00:49:24,630 --> 00:49:29,760
about it again and I've written a number

00:49:27,540 --> 00:49:30,930
of blog posts on how you can codify your

00:49:29,760 --> 00:49:33,300
vault policy so how you can integrate

00:49:30,930 --> 00:49:34,950
this with like CI or CD so that you can

00:49:33,300 --> 00:49:36,360
use source control to manage these vault

00:49:34,950 --> 00:49:38,700
policies instead of running commands

00:49:36,360 --> 00:49:40,770
locally so now I've set out my PKI

00:49:38,700 --> 00:49:42,750
infrastructure and I'm going to issue a

00:49:40,770 --> 00:49:47,220
certificate well how do I do that well I

00:49:42,750 --> 00:49:50,070
write to PK I issue against the role

00:49:47,220 --> 00:49:54,660
named my website and I give it my TLD or

00:49:50,070 --> 00:49:59,280
my common name so this could be like you

00:49:54,660 --> 00:50:02,130
know my app my app one dot node internal

00:49:59,280 --> 00:50:04,230
or you know dot company dot rocks or

00:50:02,130 --> 00:50:07,200
whatever your internal TLD TLD is but in

00:50:04,230 --> 00:50:11,400
this case I've configured it for example

00:50:07,200 --> 00:50:15,380
calm because cool and we get back a

00:50:11,400 --> 00:50:17,940
certificate this is a certificate and

00:50:15,380 --> 00:50:20,460
then there's the issuing CA and then

00:50:17,940 --> 00:50:22,830
there's the private key starting right

00:50:20,460 --> 00:50:25,950
there and we get back a serial number

00:50:22,830 --> 00:50:30,420
and stuff as well once again so all of

00:50:25,950 --> 00:50:32,880
this is an API request away so you don't

00:50:30,420 --> 00:50:35,490
have to write your certificates to disk

00:50:32,880 --> 00:50:36,930
you can actually load them in memory so

00:50:35,490 --> 00:50:38,670
that even if the attacker gains access

00:50:36,930 --> 00:50:41,400
to your file system they would not be

00:50:38,670 --> 00:50:43,890
able to read these files they would have

00:50:41,400 --> 00:50:46,530
to dump your core process in order to

00:50:43,890 --> 00:50:48,930
get these credentials out and again this

00:50:46,530 --> 00:50:50,369
is all an API call away so you don't

00:50:48,930 --> 00:50:54,260
have to use the vault CLI you can use

00:50:50,369 --> 00:50:54,260
the JSON parsing question

00:51:14,930 --> 00:51:19,620
sure alternative name is another option

00:51:17,490 --> 00:51:21,240
so it's sni there's a bunch of I mean

00:51:19,620 --> 00:51:23,010
the PKI back and it's very configurable

00:51:21,240 --> 00:51:25,260
so I'm just using the most basic example

00:51:23,010 --> 00:51:28,380
here but if that's outdated I will

00:51:25,260 --> 00:51:31,710
research that and update my demo that I

00:51:28,380 --> 00:51:35,610
wrote last night all right

00:51:31,710 --> 00:51:37,650
how much time do I have time yeah how

00:51:35,610 --> 00:51:39,630
much time do I have nine minutes okay

00:51:37,650 --> 00:51:42,360
I'm going to do one more this is a bonus

00:51:39,630 --> 00:51:44,010
all right I'm going to mount the totp

00:51:42,360 --> 00:51:45,930
back end again this is the one that's

00:51:44,010 --> 00:51:51,150
going to drain generate MFA or two essay

00:51:45,930 --> 00:51:54,060
codes and there's a I'm going to just

00:51:51,150 --> 00:51:57,420
cat I built this in advance to save some

00:51:54,060 --> 00:51:58,860
time so this is an OTP off URL if you've

00:51:57,420 --> 00:52:00,870
ever scanned a barcode with Google

00:51:58,860 --> 00:52:02,730
Authenticator this is actually what that

00:52:00,870 --> 00:52:04,860
looks like that barcode is not some

00:52:02,730 --> 00:52:06,990
fancy magical thing it's actually just

00:52:04,860 --> 00:52:08,790
an encoded URL with like a secret and

00:52:06,990 --> 00:52:09,780
some metadata so this is what one of

00:52:08,790 --> 00:52:13,230
those looks like

00:52:09,780 --> 00:52:15,990
so obviously vault is a CLI tool you

00:52:13,230 --> 00:52:18,330
can't exactly scan a barcode easily but

00:52:15,990 --> 00:52:20,670
you can usually get these totp URLs if

00:52:18,330 --> 00:52:23,190
you click like I can't scan this or this

00:52:20,670 --> 00:52:26,000
is not available to me what I'm going to

00:52:23,190 --> 00:52:30,630
do is I'm going to write this o TP URL

00:52:26,000 --> 00:52:35,910
to TP keys so this is my demo key I'm

00:52:30,630 --> 00:52:37,230
going to write TP karela txt I'm going

00:52:35,910 --> 00:52:40,520
to write that key so what that did is a

00:52:37,230 --> 00:52:44,400
total whenever I read from the key demo

00:52:40,520 --> 00:52:46,740
execute that TOTP authentication URL so

00:52:44,400 --> 00:52:50,640
I'm going to just read from totp code

00:52:46,740 --> 00:52:54,300
demo that will get me the code and I get

00:52:50,640 --> 00:52:57,330
back a six-digit standard totp code and

00:52:54,300 --> 00:52:59,280
I don't know where the timer is so there

00:52:57,330 --> 00:53:03,480
we go hey perfect timing I get back

00:52:59,280 --> 00:53:05,310
another six digit to your TP code each

00:53:03,480 --> 00:53:06,840
time I read from this but notice that

00:53:05,310 --> 00:53:09,360
there's probably like a 30 second TTL

00:53:06,840 --> 00:53:10,410
it's usually the default so it's going

00:53:09,360 --> 00:53:11,580
to keep it it's going to keep it it's

00:53:10,410 --> 00:53:13,380
going to keep it and then if I keep

00:53:11,580 --> 00:53:16,050
talking for like another 15 seconds

00:53:13,380 --> 00:53:18,810
eventually I'll get another code but

00:53:16,050 --> 00:53:19,980
again this is basically replacing

00:53:18,810 --> 00:53:22,890
something like Google Authenticator or

00:53:19,980 --> 00:53:24,930
offi and yes this is not a pretty UI

00:53:22,890 --> 00:53:26,799
it's not a mobile app so it's probably

00:53:24,930 --> 00:53:30,039
not the best to replace for a non tech

00:53:26,799 --> 00:53:34,109
user this is best for I don't know maybe

00:53:30,039 --> 00:53:36,459
enabling nfa on your route AWS user

00:53:34,109 --> 00:53:38,469
because you don't want to store that in

00:53:36,459 --> 00:53:40,150
my coffee because you might have

00:53:38,469 --> 00:53:41,739
multiple operators who need access to

00:53:40,150 --> 00:53:44,469
those credentials in the event of an

00:53:41,739 --> 00:53:46,150
emergency but if you put them in volt

00:53:44,469 --> 00:53:47,499
you can grant access based on the

00:53:46,150 --> 00:53:49,439
permission model but you also have a

00:53:47,499 --> 00:53:52,660
full audit trail so you know whenever

00:53:49,439 --> 00:53:56,739
Jaime accessed third account credentials

00:53:52,660 --> 00:53:58,269
because she made a request to fault slip

00:53:56,739 --> 00:54:01,269
it around the vault can actually act as

00:53:58,269 --> 00:54:04,150
an Authenticator so I can write to a key

00:54:01,269 --> 00:54:07,809
so instead of writing a URL I can write

00:54:04,150 --> 00:54:09,579
to a key and I'll name it my app and I'm

00:54:07,809 --> 00:54:10,989
going to pass in the generate flag so

00:54:09,579 --> 00:54:16,029
this tells vault that I actually want it

00:54:10,989 --> 00:54:19,719
to generate a totp URL for me the issuer

00:54:16,029 --> 00:54:23,170
is required by the spec so this is going

00:54:19,719 --> 00:54:25,539
to be vault and the account name is

00:54:23,170 --> 00:54:26,109
going to be my email Seth attached

00:54:25,539 --> 00:54:28,630
agribe.com

00:54:26,109 --> 00:54:31,119
cool we got back a bunch of stuff so we

00:54:28,630 --> 00:54:34,359
got back what looks like the standard

00:54:31,119 --> 00:54:36,579
OTP URL but then we also got back a bar

00:54:34,359 --> 00:54:38,979
code doesn't look like a bar code to me

00:54:36,579 --> 00:54:40,179
well that's actually add a 64 encoded

00:54:38,979 --> 00:54:42,189
bar codes let me show you what this

00:54:40,179 --> 00:54:43,929
looks like so I'm going to copy this to

00:54:42,189 --> 00:54:47,259
my clipboard and I'm going to jump down

00:54:43,929 --> 00:54:50,799
here onto my local laptop shove that up

00:54:47,259 --> 00:54:53,559
there so I'm going to decode that thing

00:54:50,799 --> 00:54:56,229
that I just typed and then I'm going to

00:54:53,559 --> 00:54:57,359
pipe it to a file so this will be Q R

00:54:56,229 --> 00:55:04,269
it's a ping

00:54:57,359 --> 00:55:07,989
damn it base64 okay and now I can

00:55:04,269 --> 00:55:10,689
actually open this URL and look at that

00:55:07,989 --> 00:55:11,799
there's a barcode so I'm going to just

00:55:10,689 --> 00:55:13,329
make this a little bit bigger and I'm

00:55:11,799 --> 00:55:14,549
going to open up one password how many

00:55:13,329 --> 00:55:16,719
people here have ever used one password

00:55:14,549 --> 00:55:18,309
this is not an endorsement for one

00:55:16,719 --> 00:55:21,249
password it just provides a really cool

00:55:18,309 --> 00:55:22,660
visual so I have this vault here and one

00:55:21,249 --> 00:55:25,839
password actually has the ability to

00:55:22,660 --> 00:55:28,569
generate what are called 2fa codes it's

00:55:25,839 --> 00:55:30,670
not MFA codes because MFA requires a

00:55:28,569 --> 00:55:33,369
second factor like another phone

00:55:30,670 --> 00:55:35,019
whereas 2fa just require or MFA just

00:55:33,369 --> 00:55:37,119
requires like multi-factor meaning more

00:55:35,019 --> 00:55:39,160
than one password or in this case more

00:55:37,119 --> 00:55:40,539
than one login token so I'm going to go

00:55:39,160 --> 00:55:44,499
ahead and make a login in here and I

00:55:40,539 --> 00:55:47,650
call it volt demo at OSD see my username

00:55:44,499 --> 00:55:50,289
was set at so there was that Hoshi Corp

00:55:47,650 --> 00:55:52,809
comm and then down here I'll create an

00:55:50,289 --> 00:55:53,289
MSA section and this is a one time

00:55:52,809 --> 00:55:55,419
password

00:55:53,289 --> 00:55:56,679
and this one time password brings up

00:55:55,419 --> 00:56:03,009
this really cool code scanner y'all

00:55:56,679 --> 00:56:04,689
ready for this OOP and you'll notice

00:56:03,009 --> 00:56:06,489
that that looks very similar again I

00:56:04,689 --> 00:56:08,410
told you the URL is just encoded I'll

00:56:06,489 --> 00:56:09,459
click Save and that's an mfa code I

00:56:08,410 --> 00:56:12,699
don't know why it's there twice

00:56:09,459 --> 00:56:14,229
that's an MSA code just like you would

00:56:12,699 --> 00:56:16,419
use with like Google Authenticator and

00:56:14,229 --> 00:56:17,499
it's going to expire every 30 seconds so

00:56:16,419 --> 00:56:19,390
I'm going to grab this to my clipboard

00:56:17,499 --> 00:56:23,079
real quick I'm going to run back over to

00:56:19,390 --> 00:56:29,469
vault and I'm going to write cute totp

00:56:23,079 --> 00:56:34,630
code my app code equals that I'm on the

00:56:29,469 --> 00:56:37,059
wrong thing okay cool I'm valid it's

00:56:34,630 --> 00:56:41,189
true it was valid for 30 seconds but if

00:56:37,059 --> 00:56:43,449
I run back over here I'm about to expire

00:56:41,189 --> 00:56:46,719
cam expired I don't know what the actual

00:56:43,449 --> 00:56:49,449
drift is on this but eventually this

00:56:46,719 --> 00:56:51,400
will be untrue it's probably like a 60

00:56:49,449 --> 00:56:55,299
second drift but if you're familiar with

00:56:51,400 --> 00:56:57,179
the TOTP algorithm so here you can build

00:56:55,299 --> 00:56:59,829
your own two-factor authentication

00:56:57,179 --> 00:57:02,589
without writing any code you just write

00:56:59,829 --> 00:57:03,999
some curl requests okay now I have three

00:57:02,589 --> 00:57:06,159
minutes for questions that's the end of

00:57:03,999 --> 00:57:08,939
my demo I hope it was worth it

00:57:06,159 --> 00:57:08,939
thank you

00:57:09,370 --> 00:57:26,050
[Applause]

00:57:14,790 --> 00:57:30,490
so how about some crisps all right that

00:57:26,050 --> 00:57:32,860
was super cool thanks um how how easy or

00:57:30,490 --> 00:57:36,460
difficult would it be to make it so that

00:57:32,860 --> 00:57:38,620
it's that the user needs to pass two

00:57:36,460 --> 00:57:41,710
factor authentication before they can

00:57:38,620 --> 00:57:42,940
use the vault CLI or whatever yeah so

00:57:41,710 --> 00:57:44,770
the question is how do we enable

00:57:42,940 --> 00:57:46,840
two-factor off on the vault CLI

00:57:44,770 --> 00:57:48,160
authenticating to vault itself so well

00:57:46,840 --> 00:57:51,040
authentication isn't something I really

00:57:48,160 --> 00:57:53,710
covered here I just off this route if

00:57:51,040 --> 00:57:55,630
you're enabling like LDAP or something

00:57:53,710 --> 00:57:56,920
login the user would actually log in

00:57:55,630 --> 00:58:01,540
with their credentials so let me show

00:57:56,920 --> 00:58:03,460
you real quick fall off enable like user

00:58:01,540 --> 00:58:08,590
paths this is just basic username and

00:58:03,460 --> 00:58:11,680
password so that I can vote right user

00:58:08,590 --> 00:58:13,960
pass users set fargo password equals

00:58:11,680 --> 00:58:18,610
banana this is like volts internal

00:58:13,960 --> 00:58:21,160
secret store and then what happens is I

00:58:18,610 --> 00:58:24,160
can office that users so volt off -

00:58:21,160 --> 00:58:26,320
method equals user paths it'll prompt me

00:58:24,160 --> 00:58:28,660
for the username and then it will prompt

00:58:26,320 --> 00:58:31,630
me for the password which I didn't type

00:58:28,660 --> 00:58:33,490
right and now I'm logged in as that user

00:58:31,630 --> 00:58:35,050
and I actually can't do anything I've

00:58:33,490 --> 00:58:37,780
just assigned the default policy so if I

00:58:35,050 --> 00:58:41,920
try to like write to secret foo again

00:58:37,780 --> 00:58:43,720
I'll get an error now adding to a fate

00:58:41,920 --> 00:58:46,420
of that would be easy we can probably do

00:58:43,720 --> 00:58:49,150
that because the vault internals adding

00:58:46,420 --> 00:58:50,440
to a PHA to something like the github

00:58:49,150 --> 00:58:52,750
authentication the way the github

00:58:50,440 --> 00:58:54,280
authentication works is we map your

00:58:52,750 --> 00:58:55,450
policy to your team's which is really

00:58:54,280 --> 00:58:57,760
great because github becomes your source

00:58:55,450 --> 00:58:59,050
of truth but in order for you to log in

00:58:57,760 --> 00:59:00,790
you actually provide your going of API

00:58:59,050 --> 00:59:05,100
token not your username and password so

00:59:00,790 --> 00:59:05,100
there's no like 2fa mechanism there

00:59:05,280 --> 00:59:08,670
other questions

00:59:11,660 --> 00:59:25,030
come on so what happens after a silver

00:59:21,740 --> 00:59:28,700
reboot how did I get walls to start up

00:59:25,030 --> 00:59:30,530
great so one of the things like papered

00:59:28,700 --> 00:59:33,559
over in this talk was something called

00:59:30,530 --> 00:59:36,530
the unsealing process involved so vault

00:59:33,559 --> 00:59:39,049
really obeys this principle called like

00:59:36,530 --> 00:59:40,760
no man which means no one person should

00:59:39,049 --> 00:59:42,890
have complete access of the system and

00:59:40,760 --> 00:59:44,859
the way we do that is by generating

00:59:42,890 --> 00:59:48,289
these things called unseal keys and

00:59:44,859 --> 00:59:50,839
unseal keys are shards of a master key

00:59:48,289 --> 00:59:52,609
that are decomposed and given to a

00:59:50,839 --> 00:59:54,920
number of trusted users such that a

00:59:52,609 --> 00:59:56,510
subset of those users can come together

00:59:54,920 --> 00:59:58,039
to regenerate the key uses something

00:59:56,510 --> 01:00:01,039
called Shamir secret sharing algorithm

00:59:58,039 --> 01:00:03,530
so when the vault reboots or when it

01:00:01,039 --> 01:00:05,030
first starts up a quorum of those

01:00:03,530 --> 01:00:07,089
unsealed key holders have to enter their

01:00:05,030 --> 01:00:09,440
key in order to make the vault active I

01:00:07,089 --> 01:00:12,890
did that in advance for this talk

01:00:09,440 --> 01:00:14,630
because I didn't feel like typing one of

01:00:12,890 --> 01:00:16,609
our enterprise features one of our paid

01:00:14,630 --> 01:00:17,660
features is auto unsealing upper vault

01:00:16,609 --> 01:00:20,690
where you can use a hardware security

01:00:17,660 --> 01:00:21,260
module to actually do auto unsealing of

01:00:20,690 --> 01:00:23,240
the vault

01:00:21,260 --> 01:00:24,980
so that again no one person but a

01:00:23,240 --> 01:00:28,099
machine can actually auto unseal the

01:00:24,980 --> 01:00:29,630
vault but normally Iran vault and high

01:00:28,099 --> 01:00:31,549
availability mode so that even if you

01:00:29,630 --> 01:00:40,420
lose a server the rest of the servers

01:00:31,549 --> 01:00:40,420
can pick up so this is another question

01:00:42,430 --> 01:00:50,119
are there any a CL implemented in

01:00:48,109 --> 01:00:52,460
involved so can I can have multiple

01:00:50,119 --> 01:00:55,369
users with different read and write

01:00:52,460 --> 01:00:58,789
access to different credentials yes

01:00:55,369 --> 01:01:00,650
everything involved is ACLs in this demo

01:00:58,789 --> 01:01:04,309
I just used a root ACL which is

01:01:00,650 --> 01:01:06,500
everything permission the I could give

01:01:04,309 --> 01:01:08,630
it to our talk on vaults policies and I

01:01:06,500 --> 01:01:10,220
didn't want that to confuse people but

01:01:08,630 --> 01:01:12,020
there's a really really really good

01:01:10,220 --> 01:01:14,150
policy engine involved that lets you

01:01:12,020 --> 01:01:16,400
explicitly give or deny access to

01:01:14,150 --> 01:01:20,029
different paths everything involved is

01:01:16,400 --> 01:01:21,200
path based so you can say they for one

01:01:20,029 --> 01:01:25,160
of the things that we do internally is

01:01:21,200 --> 01:01:28,339
anyone in the developers team on github

01:01:25,160 --> 01:01:30,289
the ability to generate I am credentials

01:01:28,339 --> 01:01:34,730
in staging you can actually build those

01:01:30,289 --> 01:01:36,349
really complex policy workflows I forgot

01:01:34,730 --> 01:01:37,759
to show this this is a real thing this

01:01:36,349 --> 01:01:40,670
is volt on how to crop out rocks you can

01:01:37,759 --> 01:01:43,759
hit this on your URL this is not open

01:01:40,670 --> 01:01:45,200
source this is our enterprise UI but

01:01:43,759 --> 01:01:47,210
there one of the questions that I always

01:01:45,200 --> 01:01:49,130
get asked i'll preempt it is is there a

01:01:47,210 --> 01:01:54,140
UI and there is and that's one of our

01:01:49,130 --> 01:01:55,940
paid features the this allows you to do

01:01:54,140 --> 01:01:57,380
replication which is our another

01:01:55,940 --> 01:02:00,859
enterprise feature between multiple data

01:01:57,380 --> 01:02:02,210
centers the policy managers in here and

01:02:00,859 --> 01:02:03,500
then there's also like a bunch of stuff

01:02:02,210 --> 01:02:09,880
with response wrapping which you haven't

01:02:03,500 --> 01:02:09,880
talked about okay not a Christian

01:02:12,309 --> 01:02:18,980
are there any cool reposeful programming

01:02:16,759 --> 01:02:22,190
languages like goaling are there any

01:02:18,980 --> 01:02:25,640
cool red buses to to client libraries to

01:02:22,190 --> 01:02:27,890
hide the REST API sure

01:02:25,640 --> 01:02:29,839
so in - Corp we maintain three we

01:02:27,890 --> 01:02:31,339
maintain the official go on the official

01:02:29,839 --> 01:02:34,519
Ruby Wanda and the official Rails one

01:02:31,339 --> 01:02:37,730
the go library is actually inside the

01:02:34,519 --> 01:02:40,160
repository because and this is I always

01:02:37,730 --> 01:02:42,529
thought this was really cool the CLI

01:02:40,160 --> 01:02:44,480
those vault commands consumes the

01:02:42,529 --> 01:02:46,880
Goulding api that we publish to people

01:02:44,480 --> 01:02:49,420
so inside here there is an api package

01:02:46,880 --> 01:02:52,009
it's right at the top this is the api

01:02:49,420 --> 01:02:57,410
however if we take a look at the CLI

01:02:52,009 --> 01:03:00,440
which is under command that's a good one

01:02:57,410 --> 01:03:03,740
off you'll notice that it imports the

01:03:00,440 --> 01:03:05,930
api package so we actually super dogfood

01:03:03,740 --> 01:03:08,150
the api the golang API that we're giving

01:03:05,930 --> 01:03:10,609
to you is the api that we packaged with

01:03:08,150 --> 01:03:13,039
the CLI to issue those commands for the

01:03:10,609 --> 01:03:17,990
ruby library it's just a volte ruby so

01:03:13,039 --> 01:03:19,460
vault - ruby and then there's a vault

01:03:17,990 --> 01:03:21,410
rails one which integrates with active

01:03:19,460 --> 01:03:22,609
record if you're looking for client

01:03:21,410 --> 01:03:25,309
libraries though you can head on over to

01:03:22,609 --> 01:03:26,930
vault project do on the API tab there's

01:03:25,309 --> 01:03:28,700
a whole section of client libraries so

01:03:26,930 --> 01:03:30,109
we have you know the official ones which

01:03:28,700 --> 01:03:32,690
I mentioned the go Ruby and rails one

01:03:30,109 --> 01:03:34,609
and then there's ansible c-sharp closure

01:03:32,690 --> 01:03:36,559
elixir a third-party go on a Haskell

01:03:34,609 --> 01:03:38,880
Java Kotlin node which is official on

01:03:36,559 --> 01:03:44,820
Android no PHP Python Rustin Scott

01:03:38,880 --> 01:03:51,120
really good stuff thank you so further

01:03:44,820 --> 01:03:55,230
questions okay so really great stuff

01:03:51,120 --> 01:03:57,030
stuff cool demo thank you very much for

01:03:55,230 --> 01:03:58,920
those of you that didn't hear there are

01:03:57,030 --> 01:04:00,330
stickers up here they are all free rein

01:03:58,920 --> 01:04:02,640
I have vigor and Packer console

01:04:00,330 --> 01:04:05,370
terraform terraform vault Nomad - court

01:04:02,640 --> 01:04:06,540
Brando and Hoshi Corp so if you want

01:04:05,370 --> 01:04:07,800
stickers please come up and take them

01:04:06,540 --> 01:04:09,980
otherwise I have to take them back with

01:04:07,800 --> 01:04:15,340
me thank you

01:04:09,980 --> 01:04:15,340

YouTube URL: https://www.youtube.com/watch?v=pK-0Vk34g-o


