Title: OSDC 2017 | Linux Performance Profiling and Monitoring  by Werner Fischer
Publication date: 2017-06-02
Playlist: OSDC 2017 | Open Source Data Center Conference
Description: 
	Nowadays system administrators have great choices when it comes down to Linux performance profiling and monitoring. The challenge is to pick the appropriate tools and interpret their results correctly.
This talk is a chance to take a tour through various performance profiling and benchmarking tools, focusing on their benefit for every sysadmin.
More than 25 different tools are presented. Ranging from well known tools like strace, iostat, tcpdump or vmstat to new features like Linux tracepoints or perf_events. You will also learn which tools can be monitored by Icinga and which monitoring plugins are already available for that.
At the end the goal is to gather reference points to look at, whenever you are faced with performance problems.
Take the chance to close your knowledge gaps and learn how to get the most out of your system.
Captions: 
	00:00:09,680 --> 00:00:14,610
hello ladies and gentlemen I hope you

00:00:12,590 --> 00:00:15,990
enjoyed your meal

00:00:14,610 --> 00:00:20,130
[Music]

00:00:15,990 --> 00:00:27,000
from Thomas crane has now the well owner

00:00:20,130 --> 00:00:32,820
and the also drew English thank a

00:00:27,000 --> 00:00:34,710
challenge to you guys please come in

00:00:32,820 --> 00:00:36,600
have a seat

00:00:34,710 --> 00:00:39,720
just to wake you up

00:00:36,600 --> 00:00:42,350
after the meal again and he will do it

00:00:39,720 --> 00:00:46,520
with his talk about Leos performance

00:00:42,350 --> 00:00:50,670
profiling and monitoring fun

00:00:46,520 --> 00:00:54,660
thank you for interaction good afternoon

00:00:50,670 --> 00:00:56,579
welcome I do is to see I'm happy to have

00:00:54,660 --> 00:00:58,550
the opportunity to give two dogs at this

00:00:56,579 --> 00:01:02,219
conference because my regular talk is

00:00:58,550 --> 00:01:05,250
Kara is tomorrow and today I am pitching

00:01:02,219 --> 00:01:08,640
in for shop humans were unfortunately

00:01:05,250 --> 00:01:11,850
had to cancel his talk today so maybe

00:01:08,640 --> 00:01:14,070
some of you have read my my tweet which

00:01:11,850 --> 00:01:19,470
I replied to Mitchell pretty who said he

00:01:14,070 --> 00:01:20,909
enjoyed the lunch and I answered I'm the

00:01:19,470 --> 00:01:24,360
lounge in the speaker's lounge

00:01:20,909 --> 00:01:27,810
so I finalized the slides right now and

00:01:24,360 --> 00:01:29,430
I all asked you to keep your fingers

00:01:27,810 --> 00:01:31,799
crossed that all the four demos will

00:01:29,430 --> 00:01:34,229
work and at least that my DVDs won't

00:01:31,799 --> 00:01:40,320
overwrite my hard drive so I can finish

00:01:34,229 --> 00:01:43,680
the talk here so the next about 45 to 50

00:01:40,320 --> 00:01:45,719
minutes I will guide you to the topic

00:01:43,680 --> 00:01:48,329
Linux performance profiling and

00:01:45,719 --> 00:01:50,210
monitoring a topic which is we are

00:01:48,329 --> 00:01:53,670
percent for every Linux administrator

00:01:50,210 --> 00:01:55,619
nearly everyday and to give you a little

00:01:53,670 --> 00:01:59,700
bit of background why I'm talking about

00:01:55,619 --> 00:02:03,780
this topic I'm working at Thomas grant

00:01:59,700 --> 00:02:06,810
for by now which is 2017 twelve years

00:02:03,780 --> 00:02:08,940
roughly and we are a servant

00:02:06,810 --> 00:02:12,330
manufacturer from Bavarian and I'm at

00:02:08,940 --> 00:02:15,630
the knowledge transfer department where

00:02:12,330 --> 00:02:17,780
we do also much of our research and

00:02:15,630 --> 00:02:24,890
provide information on the Thomas cone

00:02:17,780 --> 00:02:26,830
Joaquin yeah what's the agenda for this

00:02:24,890 --> 00:02:29,830
afternoon

00:02:26,830 --> 00:02:34,180
is a three or let's say four main areas

00:02:29,830 --> 00:02:36,450
in my talk first part will cover how to

00:02:34,180 --> 00:02:40,630
collect statistics with different tools

00:02:36,450 --> 00:02:44,230
starting with a sister package using MP

00:02:40,630 --> 00:02:47,590
stat VMs that fits that and IO said then

00:02:44,230 --> 00:02:49,630
going further on showing how these data

00:02:47,590 --> 00:02:53,620
and mix that are working how it's

00:02:49,630 --> 00:02:57,160
possible to use the system archiver to

00:02:53,620 --> 00:03:00,430
get the numbers also a little later on

00:02:57,160 --> 00:03:01,930
and showing some Peconic active

00:03:00,430 --> 00:03:05,890
templates and some monitoring buttons

00:03:01,930 --> 00:03:08,560
for senior one I guess the second part

00:03:05,890 --> 00:03:11,290
will cover tools which can be used

00:03:08,560 --> 00:03:12,670
online so when you are focusing some

00:03:11,290 --> 00:03:14,500
performance issues and you want to

00:03:12,670 --> 00:03:18,160
figure out okay what can I do right now

00:03:14,500 --> 00:03:20,290
things like top IO total lift up going

00:03:18,160 --> 00:03:22,600
further on when it gets really deeper to

00:03:20,290 --> 00:03:25,510
optimize your system how you can use

00:03:22,600 --> 00:03:28,600
tracing utilities like the preference

00:03:25,510 --> 00:03:34,720
earthquakes or the perf tools or using

00:03:28,600 --> 00:03:37,690
flame us to visualize the functions that

00:03:34,720 --> 00:03:41,260
you are doing when running a specific

00:03:37,690 --> 00:03:44,860
task and at the end summary up-to-date

00:03:41,260 --> 00:03:48,580
information about a performance metric

00:03:44,860 --> 00:03:51,489
about the CPU utilization and some hints

00:03:48,580 --> 00:03:54,030
wide may be wrong to use this number

00:03:51,489 --> 00:03:56,709
without deeper thinking about this

00:03:54,030 --> 00:04:00,580
wenton greg has written a blog posting a

00:03:56,709 --> 00:04:03,910
few days ago which led to year I could

00:04:00,580 --> 00:04:06,430
say many discussions on the internet he

00:04:03,910 --> 00:04:08,980
updated the article also and I can give

00:04:06,430 --> 00:04:11,820
a little bit of overview there what

00:04:08,980 --> 00:04:16,810
you're all about

00:04:11,820 --> 00:04:20,290
okay let's start how can we collect some

00:04:16,810 --> 00:04:22,900
statistics for our system who of you has

00:04:20,290 --> 00:04:31,120
the assisted package installed on a on

00:04:22,900 --> 00:04:34,240
the system okay about 50 percent so the

00:04:31,120 --> 00:04:36,220
tools we are covering in this talk will

00:04:34,240 --> 00:04:39,100
be tools from a sister package and some

00:04:36,220 --> 00:04:40,670
other tools I've brought this slide also

00:04:39,100 --> 00:04:42,260
from Brendan Gregg

00:04:40,670 --> 00:04:44,570
who is the performance analyst at

00:04:42,260 --> 00:04:47,810
Netflix optimizing the Linux systems

00:04:44,570 --> 00:04:49,460
every day yeah to guarantee that your

00:04:47,810 --> 00:04:52,670
videos can be watched without any

00:04:49,460 --> 00:04:55,250
latency in movies and yeah I'm hoping

00:04:52,670 --> 00:04:58,010
that you don't use his services right

00:04:55,250 --> 00:05:02,840
now in case you have a laptop open but

00:04:58,010 --> 00:05:05,960
you can use the little unit awk so when

00:05:02,840 --> 00:05:07,790
we take a look at the talk now this is

00:05:05,960 --> 00:05:09,470
not the number of minutes I will over

00:05:07,790 --> 00:05:13,550
under stock this is the number of tools

00:05:09,470 --> 00:05:15,530
that we will cover in this talk and yeah

00:05:13,550 --> 00:05:17,360
every time you see where well currently

00:05:15,530 --> 00:05:20,630
now you can take a deep breath and hope

00:05:17,360 --> 00:05:26,630
that they'll still be in time and finish

00:05:20,630 --> 00:05:32,650
without any overtime here so let's dig

00:05:26,630 --> 00:05:35,060
into it let's start with MP step it's

00:05:32,650 --> 00:05:39,080
yeah one of the tools which are coming

00:05:35,060 --> 00:05:42,020
with a sister package we are seeing that

00:05:39,080 --> 00:05:44,210
it reports the CPU related statistics

00:05:42,020 --> 00:05:47,390
using information from the proc file

00:05:44,210 --> 00:05:49,400
system so many of these tools that we

00:05:47,390 --> 00:05:52,210
are seeing here especially from the

00:05:49,400 --> 00:05:54,470
sister package are indeed using

00:05:52,210 --> 00:05:57,200
information which is directly available

00:05:54,470 --> 00:05:59,930
in the proc file system so you could

00:05:57,200 --> 00:06:02,990
also go to the Box file system queer

00:05:59,930 --> 00:06:06,410
that information there but these tools

00:06:02,990 --> 00:06:10,600
try to give it to you in a good readable

00:06:06,410 --> 00:06:15,680
manner so you can interpret the numbers

00:06:10,600 --> 00:06:17,360
they are a little bit more easily when

00:06:15,680 --> 00:06:18,980
you don't provide any interval account

00:06:17,360 --> 00:06:21,260
you get the numbers since the last

00:06:18,980 --> 00:06:23,330
system start up so you get average

00:06:21,260 --> 00:06:28,340
number since the last system start up

00:06:23,330 --> 00:06:30,560
and you see us abuse usages per core

00:06:28,340 --> 00:06:32,030
inclusive including hyper threading so

00:06:30,560 --> 00:06:34,760
in this case when you're having a system

00:06:32,030 --> 00:06:38,660
with two cores and hyper threading

00:06:34,760 --> 00:06:43,090
activated you're getting data like here

00:06:38,660 --> 00:06:46,280
where C okay and then for CPUs two CPUs

00:06:43,090 --> 00:06:48,980
but the number four because we're having

00:06:46,280 --> 00:06:51,560
hyper threading here you can get this

00:06:48,980 --> 00:06:53,830
information from the LS CPU command and

00:06:51,560 --> 00:06:59,990
this the reason why we are

00:06:53,830 --> 00:07:02,030
for scipios here let's take a look at

00:06:59,990 --> 00:07:05,660
the different columns we have columns

00:07:02,030 --> 00:07:09,460
for user CPU time for system CPU time so

00:07:05,660 --> 00:07:13,160
depending whether the core is executing

00:07:09,460 --> 00:07:16,580
use occur or or kernel level call it

00:07:13,160 --> 00:07:19,160
comes to this or this column and on the

00:07:16,580 --> 00:07:22,039
other side we are seeing the idle time

00:07:19,160 --> 00:07:24,940
so the time where the CPU is doing

00:07:22,039 --> 00:07:31,280
nothing waiting for something to be

00:07:24,940 --> 00:07:35,900
executed since some years you also have

00:07:31,280 --> 00:07:37,729
a column for for a guest or CPU usage so

00:07:35,900 --> 00:07:40,190
when you're using for example KVM

00:07:37,729 --> 00:07:53,349
utilization you can get information

00:07:40,190 --> 00:07:53,349
about utilized CPU code in here too okay

00:07:53,500 --> 00:08:01,669
so let's get one step further when we

00:07:58,849 --> 00:08:03,919
doing MP start in this example with the

00:08:01,669 --> 00:08:06,349
parameter two at the end to get for

00:08:03,919 --> 00:08:10,490
example here the output over two seconds

00:08:06,349 --> 00:08:14,360
we see the output be up to you and in

00:08:10,490 --> 00:08:18,259
this case we're seeing that the co one

00:08:14,360 --> 00:08:23,330
is not idle and it deals with i/o wait

00:08:18,259 --> 00:08:27,770
so we're seeing ok the CPU would like to

00:08:23,330 --> 00:08:30,979
run a code here but yet has to wait for

00:08:27,770 --> 00:08:36,039
Oh in this example we're running a few

00:08:30,979 --> 00:08:42,229
tests so a nano pound test leading to

00:08:36,039 --> 00:08:45,170
yeah to wait in the IO column here let's

00:08:42,229 --> 00:08:48,589
take one step further to vmstat

00:08:45,170 --> 00:08:51,589
here we see some more high-level

00:08:48,589 --> 00:08:54,260
statistics about different topics about

00:08:51,589 --> 00:08:57,230
virtual memory about swap and paging

00:08:54,260 --> 00:08:59,510
also about i/o statistics and also about

00:08:57,230 --> 00:09:03,230
system interrupts and context switches

00:08:59,510 --> 00:09:05,300
and yeah also again information about

00:09:03,230 --> 00:09:06,590
the CPU so you have any information

00:09:05,300 --> 00:09:09,380
about

00:09:06,590 --> 00:09:16,370
user CPU time system signal time idle

00:09:09,380 --> 00:09:19,760
time and so on in case you're thinking

00:09:16,370 --> 00:09:21,980
about what might be st st c so called

00:09:19,760 --> 00:09:23,960
still time this is stolen from a virtual

00:09:21,980 --> 00:09:28,880
machine we have nowhere to relation here

00:09:23,960 --> 00:09:43,880
so we don't see ya any any output in

00:09:28,880 --> 00:09:47,779
this example here when it comes to

00:09:43,880 --> 00:09:51,770
memory statistics who use using the free

00:09:47,779 --> 00:09:54,320
commands okay nearly i we want to expect

00:09:51,770 --> 00:09:57,740
it let and hope to that we're seeing all

00:09:54,320 --> 00:09:59,390
the output in here and you can compare

00:09:57,740 --> 00:10:01,670
we m stat and the output of the free

00:09:59,390 --> 00:10:04,570
command and we see that the numbers here

00:10:01,670 --> 00:10:07,250
okay they are the same so we are getting

00:10:04,570 --> 00:10:10,250
the same information which we could also

00:10:07,250 --> 00:10:13,100
get from the food command and it's very

00:10:10,250 --> 00:10:14,930
important when you look at the freedom

00:10:13,100 --> 00:10:17,450
and to interpret this data correctly

00:10:14,930 --> 00:10:22,280
what is happening here is that we have

00:10:17,450 --> 00:10:26,180
indeed many data cached in memory this

00:10:22,280 --> 00:10:28,250
is from the buffer cache so when you're

00:10:26,180 --> 00:10:31,640
doing I oh you're reading for example a

00:10:28,250 --> 00:10:33,410
file or your whiting a file what is

00:10:31,640 --> 00:10:35,270
happening in the background is that the

00:10:33,410 --> 00:10:38,060
kernel reads the data from the device

00:10:35,270 --> 00:10:41,450
while the device driver and put the data

00:10:38,060 --> 00:10:44,150
into the memory and provides the block

00:10:41,450 --> 00:10:47,780
data to the process who requested the

00:10:44,150 --> 00:10:49,760
data but also when the process has

00:10:47,780 --> 00:10:50,780
finishes work and doesn't want to have

00:10:49,760 --> 00:10:54,350
the data anymore

00:10:50,780 --> 00:10:57,110
the data is still kept in the page cache

00:10:54,350 --> 00:10:59,390
here this has the advantage that when

00:10:57,110 --> 00:11:02,209
you need the data again here

00:10:59,390 --> 00:11:06,500
you can grab it from the memory and you

00:11:02,209 --> 00:11:09,560
don't have to go to the tree block

00:11:06,500 --> 00:11:13,580
device itself so when you see for

00:11:09,560 --> 00:11:16,520
example with a free commander what

00:11:13,580 --> 00:11:19,160
amount of memory you're really using for

00:11:16,520 --> 00:11:25,100
your applications you have

00:11:19,160 --> 00:11:29,509
to take into account that you yeah add

00:11:25,100 --> 00:11:32,209
or subtract the numbers from the bath

00:11:29,509 --> 00:11:35,360
Akash seeing okay impede them having

00:11:32,209 --> 00:11:38,829
nearly all of memory free I'm using my

00:11:35,360 --> 00:11:41,839
memory indeed for the page cache and

00:11:38,829 --> 00:11:44,420
this is really an important topic

00:11:41,839 --> 00:11:47,870
because when you're having for example

00:11:44,420 --> 00:11:52,970
experience that your RO system seems to

00:11:47,870 --> 00:11:55,129
be a little bit too slow and you I think

00:11:52,970 --> 00:11:57,079
okay I'm having a nice memory it might

00:11:55,129 --> 00:11:59,180
be a good idea to add some more memory

00:11:57,079 --> 00:12:03,939
although your processes don't need it

00:11:59,180 --> 00:12:03,939
but you can use it as page cache here

00:12:17,060 --> 00:12:21,990
what other causes related fields we see

00:12:20,160 --> 00:12:24,150
other we're beginning the our column and

00:12:21,990 --> 00:12:27,240
the B column the our column is the

00:12:24,150 --> 00:12:29,670
number of processes that could be

00:12:27,240 --> 00:12:32,010
running or which are waiting for one

00:12:29,670 --> 00:12:35,550
time in this case we have a number of Co

00:12:32,010 --> 00:12:37,560
here so we are having not CPU power at

00:12:35,550 --> 00:12:39,450
this in this case if you have n high

00:12:37,560 --> 00:12:42,029
number here in the first column of VMs

00:12:39,450 --> 00:12:44,670
that it's an indicator for CPU

00:12:42,029 --> 00:12:47,390
saturation so it might be a good idea

00:12:44,670 --> 00:12:50,670
maybe depending on your work looked at

00:12:47,390 --> 00:12:54,750
additional course or or just to see how

00:12:50,670 --> 00:12:56,130
you could optimize your code in the

00:12:54,750 --> 00:12:58,880
second column we have the number of

00:12:56,130 --> 00:13:02,310
processes in an uninterruptible sleep

00:12:58,880 --> 00:13:05,370
mostly this is time waiting for i/o and

00:13:02,310 --> 00:13:06,690
we can see here for example that when

00:13:05,370 --> 00:13:10,020
you are looking at the kernel functions

00:13:06,690 --> 00:13:13,440
using the PS command oh we see yeah that

00:13:10,020 --> 00:13:17,730
they are always asked for fire white

00:13:13,440 --> 00:13:26,250
which is expected to run here but young

00:13:17,730 --> 00:13:27,690
simply needs some some time when you

00:13:26,250 --> 00:13:29,940
want to graph these numbers there are

00:13:27,690 --> 00:13:31,620
tools like glue board for example I've

00:13:29,940 --> 00:13:33,690
added a link here in the presentation

00:13:31,620 --> 00:13:37,170
you can find it in the PDF that will be

00:13:33,690 --> 00:13:38,640
available on the conference website to

00:13:37,170 --> 00:13:41,640
get to know how to use new root for

00:13:38,640 --> 00:13:46,770
example but according to my timer has to

00:13:41,640 --> 00:13:50,460
go on as we are mostly not a satisfied

00:13:46,770 --> 00:13:53,430
with summaries and overviews we want to

00:13:50,460 --> 00:13:57,209
dive a little bit deeper and for example

00:13:53,430 --> 00:14:01,709
we want to know what is pit number 90 59

00:13:57,209 --> 00:14:06,000
doing for this there's a tool called pit

00:14:01,709 --> 00:14:09,360
stat it reports statistics for tasks

00:14:06,000 --> 00:14:12,000
being managed by the kernel for example

00:14:09,360 --> 00:14:14,370
when you are looking at this example

00:14:12,000 --> 00:14:17,700
here with a top commander you see okay

00:14:14,370 --> 00:14:19,740
my command which has been executed is

00:14:17,700 --> 00:14:23,610
piping where for your information it

00:14:19,740 --> 00:14:25,320
gives us 96.9% of my CPU

00:14:23,610 --> 00:14:29,010
we do not know the AG events for example

00:14:25,320 --> 00:14:32,760
we can use pizza to get more information

00:14:29,010 --> 00:14:41,730
and see ok we are doing some matrix

00:14:32,760 --> 00:14:43,830
calculation here there are also other

00:14:41,730 --> 00:14:46,950
reports for pits that for example we

00:14:43,830 --> 00:14:50,160
have the possibility to use device we

00:14:46,950 --> 00:14:53,270
put with a minus D command this on

00:14:50,160 --> 00:14:57,300
wheels which command is for example

00:14:53,270 --> 00:15:00,090
executing or causing this IO it that we

00:14:57,300 --> 00:15:01,820
are using a thing here with the amp if

00:15:00,090 --> 00:15:05,520
that commander so they are different

00:15:01,820 --> 00:15:13,520
reports one of them is the device report

00:15:05,520 --> 00:15:15,510
which can be used for this case other

00:15:13,520 --> 00:15:18,860
possibilities how to use pitch that is

00:15:15,510 --> 00:15:22,800
how much memory is the pit using and

00:15:18,860 --> 00:15:26,100
here are multiple numbers interesting

00:15:22,800 --> 00:15:29,420
for us to indicate for example if we

00:15:26,100 --> 00:15:32,460
need more RAM a more memory or or not

00:15:29,420 --> 00:15:35,580
for example in the column for a major

00:15:32,460 --> 00:15:40,320
fault this numbers here

00:15:35,580 --> 00:15:42,750
I'm indicator that we need to load

00:15:40,320 --> 00:15:45,450
memory pages from disk means that data

00:15:42,750 --> 00:15:48,870
has been swapped out indicating that it

00:15:45,450 --> 00:15:51,930
yeah a good idea to add more memory into

00:15:48,870 --> 00:15:54,870
the system and here in the last common

00:15:51,930 --> 00:16:00,380
we city currently used here or physical

00:15:54,870 --> 00:16:00,380
memory by by this process

00:16:07,940 --> 00:16:13,290
next tool io start this is showing I own

00:16:11,760 --> 00:16:16,470
substance statistics

00:16:13,290 --> 00:16:20,250
it has also multiple reports for example

00:16:16,470 --> 00:16:23,010
a CPU report or otherwise utilization we

00:16:20,250 --> 00:16:25,530
bought again when you're executed

00:16:23,010 --> 00:16:28,560
without any arguments it shows you the

00:16:25,530 --> 00:16:30,600
average number since the last we boot

00:16:28,560 --> 00:16:34,880
you can skip through the wire on

00:16:30,600 --> 00:16:40,170
together the data witches are currently

00:16:34,880 --> 00:16:47,640
used and for this I will dive into demo

00:16:40,170 --> 00:16:49,730
number one okay works I only have to

00:16:47,640 --> 00:16:52,880
switch a little bit because I haven't

00:16:49,730 --> 00:17:09,089
display mirrored my display here but

00:16:52,880 --> 00:17:22,319
this seems fine okay so just to show you

00:17:09,089 --> 00:17:24,839
what I'm doing here okay so this demo

00:17:22,319 --> 00:17:26,850
has four scripts which I'm using the

00:17:24,839 --> 00:17:29,220
first script we see okay I simply

00:17:26,850 --> 00:17:34,410
execute I all set and executed four

00:17:29,220 --> 00:17:36,780
times in the second script we see we are

00:17:34,410 --> 00:17:40,380
running a few tests and we are executing

00:17:36,780 --> 00:17:44,580
it using task set so we want two tasks

00:17:40,380 --> 00:17:49,680
to be one encore number one and the

00:17:44,580 --> 00:17:51,630
Cirque output wheel using the output of

00:17:49,680 --> 00:17:55,370
the MP step commando and in the fourth

00:17:51,630 --> 00:18:01,310
example we are again doing another

00:17:55,370 --> 00:18:01,310
cpu-bound action on the same call

00:18:11,279 --> 00:18:26,590
okay we're seeing them mostly idling

00:18:13,960 --> 00:18:28,659
here so I'm doing okay this changes as

00:18:26,590 --> 00:18:32,369
you can see here I'm wearing the field

00:18:28,659 --> 00:18:36,279
test here Eiling is going going down and

00:18:32,369 --> 00:18:38,469
here we are having aya wait here in this

00:18:36,279 --> 00:18:49,450
in this case so the test is still

00:18:38,469 --> 00:18:52,330
running that's fine yeah and here we see

00:18:49,450 --> 00:18:54,879
that we running in this case on the

00:18:52,330 --> 00:18:58,299
first Accord is this kore number zero

00:18:54,879 --> 00:19:01,539
and yeah we are doing the work here and

00:18:58,299 --> 00:19:07,299
this in this code we won't have this

00:19:01,539 --> 00:19:09,219
output in this case when we are using a

00:19:07,299 --> 00:19:10,499
doubt that we see we're seeing here we

00:19:09,219 --> 00:19:14,830
have in there

00:19:10,499 --> 00:19:17,769
average from of four CPUs in this case

00:19:14,830 --> 00:19:26,799
we see individual ones so now in the

00:19:17,769 --> 00:19:29,940
fourth column I'll demo 106 for just

00:19:26,799 --> 00:19:29,940
start this again

00:19:30,629 --> 00:19:39,009
okay when using some CPU bound our work

00:19:36,159 --> 00:19:45,969
here okay I'll have to execute this

00:19:39,009 --> 00:19:51,429
again okay and what we're seeing now is

00:19:45,969 --> 00:19:54,999
that the idle time here is going down to

00:19:51,429 --> 00:19:57,129
zero and also the arrow wait time is

00:19:54,999 --> 00:19:59,769
going down to zero although we're doing

00:19:57,129 --> 00:20:02,349
the Pheo test and the background which

00:19:59,769 --> 00:20:04,299
is causing a lot of i/o so this is a

00:20:02,349 --> 00:20:06,369
thing which is really really misleading

00:20:04,299 --> 00:20:11,799
and you have to watch out that they

00:20:06,369 --> 00:20:13,779
don't yeah tap into it because you're

00:20:11,799 --> 00:20:17,289
saying okay I already zero everything is

00:20:13,779 --> 00:20:21,070
fine with my oh subsystem but as you've

00:20:17,289 --> 00:20:24,049
seen before when we don't have this

00:20:21,070 --> 00:20:32,690
Sibiu bound test running at the same

00:20:24,049 --> 00:20:37,279
time okay Matthew test finished Murphy's

00:20:32,690 --> 00:20:40,159
Law a little bit okay fine we're seeing

00:20:37,279 --> 00:20:42,409
that we having a oh wait here again so

00:20:40,159 --> 00:20:45,769
this is really important a thing and

00:20:42,409 --> 00:20:52,809
yeah I think I overlooked also for for

00:20:45,769 --> 00:20:52,809
many many years so don't don't miss this

00:20:53,080 --> 00:21:17,409
okay I'm about yeah so who sourced in

00:21:11,629 --> 00:21:17,409
worked and didn't to avoid my laptop

00:21:20,169 --> 00:21:26,120
okay

00:21:21,639 --> 00:21:28,490
so I've also written this into the slide

00:21:26,120 --> 00:21:31,789
so when you watch the slides without

00:21:28,490 --> 00:21:33,590
watching the video I oh wait is some

00:21:31,789 --> 00:21:34,879
kind of idle time but do you have to be

00:21:33,590 --> 00:21:38,120
really really careful when you have a

00:21:34,879 --> 00:21:40,759
CPU bound test running at the same time

00:21:38,120 --> 00:21:51,850
yeah sure doesn't mean everything is

00:21:40,759 --> 00:21:54,559
time so let's go on with I oath that you

00:21:51,850 --> 00:21:57,590
are getting an extended device will put

00:21:54,559 --> 00:22:00,379
when you're using the - X parameter

00:21:57,590 --> 00:22:04,070
you're getting a utilization in percent

00:22:00,379 --> 00:22:05,809
and when you're using this it's always a

00:22:04,070 --> 00:22:07,399
good idea to read the man page like

00:22:05,809 --> 00:22:10,580
every administrator is doing before

00:22:07,399 --> 00:22:14,059
using the tools within the mantich for

00:22:10,580 --> 00:22:17,779
the wives is serving whicker's you early

00:22:14,059 --> 00:22:20,240
it's fine but for parallel processing

00:22:17,779 --> 00:22:21,889
like for weight aeration SSDs this

00:22:20,240 --> 00:22:26,360
number doesn't reflect the performance

00:22:21,889 --> 00:22:28,759
limits so in the good old days when you

00:22:26,360 --> 00:22:31,220
have you have used one hard drive and

00:22:28,759 --> 00:22:33,890
you wanted to analyze it it's a good

00:22:31,220 --> 00:22:37,400
idea to use this when I using an S

00:22:33,890 --> 00:22:40,880
speed or weight device its it might be

00:22:37,400 --> 00:22:45,290
not that good idea because these tools

00:22:40,880 --> 00:22:48,950
are these devices have the possibility

00:22:45,290 --> 00:22:52,460
to to serve with rest in parallel so

00:22:48,950 --> 00:22:54,020
what does this number mean for example

00:22:52,460 --> 00:22:58,990
in theory when we're using this SSD

00:22:54,020 --> 00:23:02,900
we're having 94.4% utilization about

00:22:58,990 --> 00:23:05,090
23,000 Alps if you would calculate it we

00:23:02,900 --> 00:23:09,220
would expect with ninety nine point six

00:23:05,090 --> 00:23:12,800
to get 24,000 but that's not the case

00:23:09,220 --> 00:23:19,370
in fact it nearly doubled in this case

00:23:12,800 --> 00:23:22,340
so reason behind that is when I all said

00:23:19,370 --> 00:23:25,760
is calculating this number it takes into

00:23:22,340 --> 00:23:29,360
account okay what do I get back in this

00:23:25,760 --> 00:23:34,070
amount of time but as an SSD controller

00:23:29,360 --> 00:23:39,560
can do multiple iOS in parallel serving

00:23:34,070 --> 00:23:43,370
a bigger request of size this number

00:23:39,560 --> 00:23:45,230
doesn't reflect this so it's good for

00:23:43,370 --> 00:23:48,380
how to have to use this number but for

00:23:45,230 --> 00:23:50,810
devices which are servicing requests in

00:23:48,380 --> 00:23:55,490
parallel like so SSDs this is not so a

00:23:50,810 --> 00:23:57,620
good performance indicator so the

00:23:55,490 --> 00:24:01,160
question is what what could be better a

00:23:57,620 --> 00:24:04,480
better indicator for that we will look

00:24:01,160 --> 00:24:10,090
at the Linux storage like diagram

00:24:04,480 --> 00:24:13,660
anybody of you knows this diagram okay

00:24:10,090 --> 00:24:16,010
unfortunately no one knows this diagram

00:24:13,660 --> 00:24:17,990
we are having this on the under which we

00:24:16,010 --> 00:24:20,900
are also having printed versions of of

00:24:17,990 --> 00:24:24,620
the diagram at our at our booth and it

00:24:20,900 --> 00:24:26,930
simply shows yeah how IO goes to the

00:24:24,620 --> 00:24:29,600
Linux kernel stack when you're wiping

00:24:26,930 --> 00:24:33,980
for example up the other would be the

00:24:29,600 --> 00:24:38,180
filesystem then it comes to optional a

00:24:33,980 --> 00:24:41,510
spectator ion modules for example like

00:24:38,180 --> 00:24:43,280
LVN modules or software 8g opt and stuff

00:24:41,510 --> 00:24:46,280
like that and then it comes down with

00:24:43,280 --> 00:24:47,779
the block layer it could be ready to go

00:24:46,280 --> 00:24:51,229
through the normal Oh

00:24:47,779 --> 00:24:58,009
school io schedule or in newer block MQ

00:24:51,229 --> 00:25:01,539
scheduler and then execute the request

00:24:58,009 --> 00:25:04,539
based commands to reroute the space

00:25:01,539 --> 00:25:10,999
drivers below

00:25:04,539 --> 00:25:13,489
so as you've seen what is not a good way

00:25:10,999 --> 00:25:16,340
we can think about what could be a good

00:25:13,489 --> 00:25:18,889
a good thing when you're using IO that

00:25:16,340 --> 00:25:22,129
with these options you get information

00:25:18,889 --> 00:25:24,379
about the average queue length of a

00:25:22,129 --> 00:25:27,580
request that's being issued and the

00:25:24,379 --> 00:25:30,649
average time which was being served so

00:25:27,580 --> 00:25:33,080
the thing is here when you can serve

00:25:30,649 --> 00:25:35,629
more requests in parallel while the

00:25:33,080 --> 00:25:37,669
waiting time is not increasing this is a

00:25:35,629 --> 00:25:39,679
good performance indicator so for

00:25:37,669 --> 00:25:42,759
example when you're using an SSD and we

00:25:39,679 --> 00:25:47,149
have the possibility to for example a

00:25:42,759 --> 00:25:51,710
issue 8 io commands in parallel on the

00:25:47,149 --> 00:25:53,570
SSD instead of issuing only one and you

00:25:51,710 --> 00:25:55,700
have to wait nearly the same amount of

00:25:53,570 --> 00:25:58,969
time it's yeah it's a good good

00:25:55,700 --> 00:26:01,070
indicator but this is always also a

00:25:58,969 --> 00:26:03,979
thing where you have to balance ok do I

00:26:01,070 --> 00:26:08,179
want to get the highest possible number

00:26:03,979 --> 00:26:12,080
of i/os or do we want not so many I

00:26:08,179 --> 00:26:14,389
hopes but these I hope should have very

00:26:12,080 --> 00:26:16,999
low latency because what happens in the

00:26:14,389 --> 00:26:19,609
SSD or in the kernel might be that for

00:26:16,999 --> 00:26:20,899
example issuing 16 hours in parallel the

00:26:19,609 --> 00:26:24,649
kernel weights a little bit of time to

00:26:20,899 --> 00:26:26,509
get the 16 iOS or 616 request and then

00:26:24,649 --> 00:26:31,460
points the data back but for a single

00:26:26,509 --> 00:26:34,519
for one single IO the latency is longer

00:26:31,460 --> 00:26:37,339
so although the number of apps increases

00:26:34,519 --> 00:26:39,739
maybe your latency increases too so you

00:26:37,339 --> 00:26:48,169
have to watch out what you want at this

00:26:39,739 --> 00:26:51,409
time so I've showed a diagram we are now

00:26:48,169 --> 00:26:55,070
at point four we have about half of the

00:26:51,409 --> 00:26:59,980
talk time but I can say that the other

00:26:55,070 --> 00:27:03,130
tools won't take that much long time

00:26:59,980 --> 00:27:05,080
so let's get on with the articles these

00:27:03,130 --> 00:27:08,799
dead for example these that combines

00:27:05,080 --> 00:27:10,780
several classical ATO's it's a

00:27:08,799 --> 00:27:14,860
replacement for example for EMS that I

00:27:10,780 --> 00:27:16,870
also listed and for everybody who likes

00:27:14,860 --> 00:27:21,610
colors it's a good idea to use that tool

00:27:16,870 --> 00:27:23,950
it has a plug-in concept and yeah can be

00:27:21,610 --> 00:27:30,070
used as a replacement for this kind of

00:27:23,950 --> 00:27:34,630
tools mix that as you could expect mix

00:27:30,070 --> 00:27:38,799
it is a tool for monitoring network

00:27:34,630 --> 00:27:40,530
devices you have a utilization in here

00:27:38,799 --> 00:27:44,919
this depends on the speed and duplex

00:27:40,530 --> 00:27:47,470
mode of unique and the saturation for

00:27:44,919 --> 00:27:50,770
example also takes errors into the count

00:27:47,470 --> 00:27:54,490
into account so when you network is

00:27:50,770 --> 00:27:59,820
saturated drops can also be an indicator

00:27:54,490 --> 00:28:10,150
and you could use these tools to to get

00:27:59,820 --> 00:28:12,730
ya theta4 for that okay so what

00:28:10,150 --> 00:28:15,040
questions are you who of you are having

00:28:12,730 --> 00:28:20,620
a history of performance data collecting

00:28:15,040 --> 00:28:25,690
data of you okay about 60 70 % which

00:28:20,620 --> 00:28:34,240
tools are using for that sister yeah

00:28:25,690 --> 00:28:36,690
okay girls fun Nagios yeah nagas the

00:28:34,240 --> 00:28:40,000
many plugins for that oh I see Mike

00:28:36,690 --> 00:28:41,590
Patton morning yeah my name is also a

00:28:40,000 --> 00:28:43,419
good thing written they also

00:28:41,590 --> 00:28:45,850
possibilities use for example tools like

00:28:43,419 --> 00:28:49,120
graphite or something like that in case

00:28:45,850 --> 00:28:51,820
you are one of those who don't collect

00:28:49,120 --> 00:28:55,720
data right now there's also a simple

00:28:51,820 --> 00:28:59,890
tool which can be Mia easily used in a

00:28:55,720 --> 00:29:03,190
hacked kind of way it's part of cyst

00:28:59,890 --> 00:29:07,270
start it's the system activity reporter

00:29:03,190 --> 00:29:10,270
again a slide board from Brandon Greg it

00:29:07,270 --> 00:29:13,210
has multiple tools one of them collects

00:29:10,270 --> 00:29:16,210
the data and other tools are

00:29:13,210 --> 00:29:20,320
used to to output or to query data later

00:29:16,210 --> 00:29:23,950
on and as it says system activity

00:29:20,320 --> 00:29:26,380
reporter collects data from multiple

00:29:23,950 --> 00:29:28,409
points on the proc file system so you

00:29:26,380 --> 00:29:31,419
have the advantage that you can use

00:29:28,409 --> 00:29:33,820
tools to monitor data later on for

00:29:31,419 --> 00:29:37,630
example you could use Gaza or things

00:29:33,820 --> 00:29:40,419
like that to get the possibility to yeah

00:29:37,630 --> 00:29:43,510
few historical data here of your saw

00:29:40,419 --> 00:29:47,950
data and that's very easy to use and

00:29:43,510 --> 00:29:50,320
doesn't need a deeper knowledge for for

00:29:47,950 --> 00:29:52,659
that other possibilities are for example

00:29:50,320 --> 00:29:54,789
a templates like here from the corner

00:29:52,659 --> 00:29:56,740
folk ACTA to have numbers like these

00:29:54,789 --> 00:30:00,010
ones here and you also mentioned that

00:29:56,740 --> 00:30:03,789
there are tool arounds tools around and

00:30:00,010 --> 00:30:06,340
plugins around for monitoring tools like

00:30:03,789 --> 00:30:12,630
Mario's singer morning and just like

00:30:06,340 --> 00:30:16,090
that where I could can monitor this data

00:30:12,630 --> 00:30:20,200
there would also be still the work to be

00:30:16,090 --> 00:30:22,510
done like for every plug-in area there's

00:30:20,200 --> 00:30:24,580
always the possibility to enhance the

00:30:22,510 --> 00:30:28,510
possibilities of the plugins right now

00:30:24,580 --> 00:30:30,390
we are having our main focus on

00:30:28,510 --> 00:30:32,799
developing harder plugins so

00:30:30,390 --> 00:30:38,409
unfortunately I haven't had a chance yet

00:30:32,799 --> 00:30:40,809
to do something in this case so that's

00:30:38,409 --> 00:30:44,169
it for the first area for collecting

00:30:40,809 --> 00:30:48,539
statistics will now carry on watching

00:30:44,169 --> 00:30:48,539
data online without biotope and if

00:30:54,120 --> 00:31:02,049
top-top also present on a we our system

00:30:59,130 --> 00:31:04,779
shows a system summary at the beginning

00:31:02,049 --> 00:31:08,350
and then per process metrics afterwards

00:31:04,779 --> 00:31:10,000
in the first line you see the one five

00:31:08,350 --> 00:31:13,440
and fifteen minute slow diverges and

00:31:10,000 --> 00:31:17,020
then yeah the output the currently

00:31:13,440 --> 00:31:20,169
updated output our second of processes

00:31:17,020 --> 00:31:22,800
that are running on your system when you

00:31:20,169 --> 00:31:25,920
want to use some

00:31:22,800 --> 00:31:28,320
sort of functions of off top I can

00:31:25,920 --> 00:31:30,120
recommend the H button to get the help

00:31:28,320 --> 00:31:34,050
you can see online okay which

00:31:30,120 --> 00:31:37,110
possibilities I can use for four

00:31:34,050 --> 00:31:40,170
different things I want to to monitor

00:31:37,110 --> 00:31:42,660
one thing that you have to remember is

00:31:40,170 --> 00:31:45,060
when you're using top it's updated every

00:31:42,660 --> 00:31:49,550
second and when we're having processes

00:31:45,060 --> 00:31:52,790
that only around 4 yeah

00:31:49,550 --> 00:31:55,170
only a few microseconds for example you

00:31:52,790 --> 00:31:57,720
could run into the issue that you don't

00:31:55,170 --> 00:32:01,110
see the the processing on top so keep in

00:31:57,720 --> 00:32:04,740
mind the update that output is updated

00:32:01,110 --> 00:32:10,230
every second but you can't miss single

00:32:04,740 --> 00:32:13,410
processes there yeah what you're seeing

00:32:10,230 --> 00:32:16,740
here using memory usage for example the

00:32:13,410 --> 00:32:18,930
total size of the wittle memory how many

00:32:16,740 --> 00:32:20,820
blocks are really really allocated in

00:32:18,930 --> 00:32:22,980
map to address space which are resident

00:32:20,820 --> 00:32:25,800
and how much of the britons has a

00:32:22,980 --> 00:32:30,380
shareable has also added yeah some other

00:32:25,800 --> 00:32:33,420
links on here for details on on that and

00:32:30,380 --> 00:32:35,550
yeah what you have to keep also in mind

00:32:33,420 --> 00:32:38,160
is that it can consume resources on its

00:32:35,550 --> 00:32:41,580
own so it's running so it needs some CPU

00:32:38,160 --> 00:32:43,620
to be one as mentioned you could use the

00:32:41,580 --> 00:32:46,980
H button to get information about

00:32:43,620 --> 00:32:49,620
further possibilities like using the s

00:32:46,980 --> 00:32:54,210
button to toggle and select fields for

00:32:49,620 --> 00:32:56,540
example for swap when you execute it - -

00:32:54,210 --> 00:32:59,700
you option to see process from a user

00:32:56,540 --> 00:33:01,110
you can also use K that's very important

00:32:59,700 --> 00:33:04,590
on the killer pit when you're having

00:33:01,110 --> 00:33:07,680
some issue here just use use that or to

00:33:04,590 --> 00:33:11,880
realize it but it can miss short limbing

00:33:07,680 --> 00:33:14,430
processes again for those of you who

00:33:11,880 --> 00:33:19,590
like callisters another tool like h top

00:33:14,430 --> 00:33:23,220
a little bit sophisticated fuse can be

00:33:19,590 --> 00:33:26,070
customized and here at the end of my

00:33:23,220 --> 00:33:29,310
talk has also show another top like tool

00:33:26,070 --> 00:33:31,800
it's called tip top which i got some new

00:33:29,310 --> 00:33:34,560
a few days ago from Brent works posting

00:33:31,800 --> 00:33:37,340
but I have it on the in the end of the

00:33:34,560 --> 00:33:37,340
of the slides

00:33:39,590 --> 00:33:48,510
good what can you do when you want to

00:33:45,690 --> 00:33:52,290
get information for AI all are things

00:33:48,510 --> 00:33:55,320
that I owed up to use and top style tool

00:33:52,290 --> 00:33:59,220
for IO you can see which processes are

00:33:55,320 --> 00:34:02,429
causing IO signing a specific process ID

00:33:59,220 --> 00:34:06,570
and then look okay what's the command

00:34:02,429 --> 00:34:11,040
behind for example we're seeing here

00:34:06,570 --> 00:34:12,480
that ya feel is is using that what's

00:34:11,040 --> 00:34:15,000
nice about the tool is that it shows

00:34:12,480 --> 00:34:17,790
white sweets and the comment in real

00:34:15,000 --> 00:34:22,609
time so you can monitor your IO with

00:34:17,790 --> 00:34:25,800
this yeah when it comes to metrics

00:34:22,609 --> 00:34:29,190
bandwidth light usage you could use if

00:34:25,800 --> 00:34:31,700
top 4 per interface usage on networks to

00:34:29,190 --> 00:34:35,520
get the information to process to see ok

00:34:31,700 --> 00:34:41,369
which of my process is causing which

00:34:35,520 --> 00:34:45,450
amount of network i/o so we stepped a

00:34:41,369 --> 00:34:48,710
little bit flora about 60 70 percent so

00:34:45,450 --> 00:35:00,270
time is getting better by now and we can

00:34:48,710 --> 00:35:05,280
focus on them on the tracing pot so

00:35:00,270 --> 00:35:07,109
what's tracing and profiling about what

00:35:05,280 --> 00:35:09,359
you can do with the tracing and

00:35:07,109 --> 00:35:12,210
profiling a tools you can count for

00:35:09,359 --> 00:35:16,200
example specific samples or events you

00:35:12,210 --> 00:35:20,700
can count object and you can collect the

00:35:16,200 --> 00:35:21,900
statistics for that with what what

00:35:20,700 --> 00:35:24,540
happens within there at the kernel code

00:35:21,900 --> 00:35:27,540
the next slides focus on system

00:35:24,540 --> 00:35:32,580
profiling using sqs performance and

00:35:27,540 --> 00:35:34,530
proof F choice is already around in the

00:35:32,580 --> 00:35:35,460
Linux kernel for quite some years so for

00:35:34,530 --> 00:35:40,380
about nine years

00:35:35,460 --> 00:35:42,930
it's around it's good for to see what is

00:35:40,380 --> 00:35:46,770
going on inside a kernel and yeah a

00:35:42,930 --> 00:35:49,200
common task is to trace events and you

00:35:46,770 --> 00:35:51,700
need debug APIs

00:35:49,200 --> 00:35:55,150
mounted that it can be won

00:35:51,700 --> 00:36:11,470
so at this point in time I'll go to live

00:35:55,150 --> 00:36:13,030
demo number two okay just a trick

00:36:11,470 --> 00:36:15,240
nothing is running anymore okay that's

00:36:13,030 --> 00:36:15,240
fine

00:36:31,609 --> 00:36:40,310
so for this one I'm taking what are the

00:36:36,810 --> 00:36:43,290
bigger this is is okay and I'm gonna

00:36:40,310 --> 00:36:43,950
activate tracing execute the date

00:36:43,290 --> 00:36:46,770
command

00:36:43,950 --> 00:36:48,840
yeah and switch tracing off again and

00:36:46,770 --> 00:36:50,910
then the next step we will take a look

00:36:48,840 --> 00:36:59,310
at the trace and see okay what is going

00:36:50,910 --> 00:37:03,720
on here so late command execute very

00:36:59,310 --> 00:37:13,050
fast it doesn't do many things in this

00:37:03,720 --> 00:37:17,100
case we are curing date and time so and

00:37:13,050 --> 00:37:23,190
I've executed less with the minus M

00:37:17,100 --> 00:37:24,570
option with a capital M so we can see

00:37:23,190 --> 00:37:26,430
the line numbers on here

00:37:24,570 --> 00:37:29,340
in fact you having the beginning of the

00:37:26,430 --> 00:37:31,920
file we're seeing okay the functions

00:37:29,340 --> 00:37:35,160
which has been called while as executed

00:37:31,920 --> 00:37:37,380
the date command and now I'd like to ask

00:37:35,160 --> 00:37:38,220
you what do you think command while a

00:37:37,380 --> 00:37:40,380
simple command

00:37:38,220 --> 00:37:42,450
how many functions are being executed in

00:37:40,380 --> 00:37:57,180
the background well I execute this

00:37:42,450 --> 00:37:59,310
command any ideas how many 2230 okay it

00:37:57,180 --> 00:38:02,430
would mean it would be nice if it were

00:37:59,310 --> 00:38:05,160
200 or seven it would be a little bit

00:38:02,430 --> 00:38:07,190
easier to interpret this data let's go

00:38:05,160 --> 00:38:10,260
to the end of the file

00:38:07,190 --> 00:38:13,050
let meet sometime the less command oh

00:38:10,260 --> 00:38:16,230
okay we see just a little bit more

00:38:13,050 --> 00:38:18,840
what's happening background here so yeah

00:38:16,230 --> 00:38:21,420
it's a nice thing to use this

00:38:18,840 --> 00:38:26,040
functionality and to optimize really

00:38:21,420 --> 00:38:28,380
code when you're yeah and some company

00:38:26,040 --> 00:38:30,390
weather the last microsecond is really

00:38:28,380 --> 00:38:33,270
important but it's not that easy for

00:38:30,390 --> 00:38:40,500
everyday system and so for me it's it

00:38:33,270 --> 00:38:47,760
wouldn't be that that easy to to use

00:38:40,500 --> 00:38:53,760
so this one worked out - again so time

00:38:47,760 --> 00:38:56,610
is spine again so as mentioned - right

00:38:53,760 --> 00:39:03,120
now okay here's example for that again

00:38:56,610 --> 00:39:05,220
and how to to use the trace we will see

00:39:03,120 --> 00:39:06,870
them some graphical improvements for

00:39:05,220 --> 00:39:09,060
this how to interpret this data with

00:39:06,870 --> 00:39:10,500
flame graphs later on so if seen okay

00:39:09,060 --> 00:39:12,180
there's much stuff going on in the

00:39:10,500 --> 00:39:15,020
background but how can we read this we

00:39:12,180 --> 00:39:19,800
won't see what flame perhaps later on

00:39:15,020 --> 00:39:21,990
I'll came for the perfect and purse it

00:39:19,800 --> 00:39:24,360
used to be called performance counters

00:39:21,990 --> 00:39:27,780
for Linux there's been a lot of updates

00:39:24,360 --> 00:39:31,310
with a kernel version forward but one

00:39:27,780 --> 00:39:35,790
for example - most of the current

00:39:31,310 --> 00:39:38,460
distributions of their updates here yes

00:39:35,790 --> 00:39:41,010
performance counters to a splines probes

00:39:38,460 --> 00:39:50,520
you PIOs and you get the package with

00:39:41,010 --> 00:39:52,620
the Linux tools comments package for the

00:39:50,520 --> 00:39:56,790
k-pops disapprove points in the kernel

00:39:52,620 --> 00:39:59,490
code for for static a tracing from from

00:39:56,790 --> 00:40:06,540
curve and you probes are pro point in

00:39:59,490 --> 00:40:08,940
user application code when you are doing

00:40:06,540 --> 00:40:11,310
a persist you will see about are 20,000

00:40:08,940 --> 00:40:14,910
supported events which we can use there

00:40:11,310 --> 00:40:17,190
there also for example events for CPU

00:40:14,910 --> 00:40:19,140
architectures and stuff like that so

00:40:17,190 --> 00:40:23,160
when it comes down to roll CPU counters

00:40:19,140 --> 00:40:27,570
you can for example go and grab

00:40:23,160 --> 00:40:30,120
documentation which code is necessary

00:40:27,570 --> 00:40:33,180
here and yeah everything for example

00:40:30,120 --> 00:40:35,790
collect last level cache misses with

00:40:33,180 --> 00:40:39,630
this row mask so depending on the things

00:40:35,790 --> 00:40:46,520
that you can we want to to analyze you

00:40:39,630 --> 00:40:48,800
have possibilities here twist

00:40:46,520 --> 00:40:51,230
a point Perth has also a trace

00:40:48,800 --> 00:40:52,760
functionality so a lot of possibilities

00:40:51,230 --> 00:40:56,210
for tracing here for five stand block

00:40:52,760 --> 00:40:59,300
layer and insist called for example yeah

00:40:56,210 --> 00:41:01,940
so you can go and work for example okay

00:40:59,300 --> 00:41:09,400
how many Cisco's are executed here and

00:41:01,940 --> 00:41:11,630
use this this data you can use then

00:41:09,400 --> 00:41:14,780
static at the counter summer when you're

00:41:11,630 --> 00:41:16,940
executing a stuff like disks using how

00:41:14,780 --> 00:41:18,680
many contexts which is undoing how many

00:41:16,940 --> 00:41:21,260
instructions how many instructions per

00:41:18,680 --> 00:41:24,350
cycle this is a number which we will

00:41:21,260 --> 00:41:27,380
also cover later on again when it comes

00:41:24,350 --> 00:41:33,110
to the details for the CPU but I think

00:41:27,380 --> 00:41:35,300
you have to carry on a little bit yeah

00:41:33,110 --> 00:41:41,090
you can also record sample pathologist

00:41:35,300 --> 00:41:48,350
advantage that you can analyze the stuff

00:41:41,090 --> 00:41:52,670
later later on yeah and we put it them

00:41:48,350 --> 00:41:54,500
later on as mentioned yeah so you can

00:41:52,670 --> 00:41:58,550
see here for example for for this

00:41:54,500 --> 00:42:01,880
example where we've written some some

00:41:58,550 --> 00:42:05,300
data on on the tie system as you can see

00:42:01,880 --> 00:42:07,340
here's equipped assess and use were

00:42:05,300 --> 00:42:12,040
doing some encryption here when we also

00:42:07,340 --> 00:42:19,220
whiten the data through device and it's

00:42:12,040 --> 00:42:22,820
and it seems that the EQ device code at

00:42:19,220 --> 00:42:26,450
least yeah needs some system CPU time so

00:42:22,820 --> 00:42:29,180
I would expect that indeed for this

00:42:26,450 --> 00:42:31,880
today for one megabyte from the

00:42:29,180 --> 00:42:37,520
spiritual block device the data is

00:42:31,880 --> 00:42:39,230
really also encrypted here yeah for the

00:42:37,520 --> 00:42:42,500
past tools the about program can crack

00:42:39,230 --> 00:42:44,570
you can get them from from pit up he

00:42:42,500 --> 00:42:49,130
mentions that most of them are quick

00:42:44,570 --> 00:42:53,720
hacks and want to do it warnings and

00:42:49,130 --> 00:42:56,630
here's some some more examples what can

00:42:53,720 --> 00:42:59,780
be used from the proof tools and cache

00:42:56,630 --> 00:43:04,390
that for example we will take a look

00:42:59,780 --> 00:43:04,390
at this in the third demo now

00:43:30,960 --> 00:43:36,310
okay what we are doing now is I'll

00:43:33,820 --> 00:43:39,040
execute the perfect tools the cash stat

00:43:36,310 --> 00:43:42,160
at all then I'll do some IO

00:43:39,040 --> 00:43:45,220
I'm using an item which others needed to

00:43:42,160 --> 00:43:47,800
to use some some days ago when the Intel

00:43:45,220 --> 00:43:51,790
AMT security thing has been published

00:43:47,800 --> 00:43:54,100
you needed Windows for that to query

00:43:51,790 --> 00:43:55,870
system so without windows you weren't

00:43:54,100 --> 00:43:57,190
able to really get the knowledge is your

00:43:55,870 --> 00:43:59,920
system affected or not so that's the

00:43:57,190 --> 00:44:04,000
reason why having this ISO image on here

00:43:59,920 --> 00:44:07,930
my Linux laptop unfortunately this does

00:44:04,000 --> 00:44:09,970
not cover the requirements for the

00:44:07,930 --> 00:44:11,380
speaker that which of them must be GPL

00:44:09,970 --> 00:44:14,710
but this is only the eyes imager won't

00:44:11,380 --> 00:44:18,630
use with you so yeah and then we see

00:44:14,710 --> 00:44:18,630
what can be done when we drop the caches

00:44:23,670 --> 00:44:30,490
okay need some time to get to get up but

00:44:27,280 --> 00:44:32,500
I think you can see it well here in this

00:44:30,490 --> 00:44:34,720
case we are using the path tool for the

00:44:32,500 --> 00:44:37,240
predication output and we see their

00:44:34,720 --> 00:44:39,970
cache hits the case cache misses so

00:44:37,240 --> 00:44:42,010
these are the most important columns

00:44:39,970 --> 00:44:45,420
hits in the first one misses in the

00:44:42,010 --> 00:44:45,420
second one remember

00:45:00,820 --> 00:45:08,410
so now the DD is running I'm moving the

00:45:04,660 --> 00:45:14,010
file the ISO image for Windows 10 so

00:45:08,410 --> 00:45:18,180
it's big one reading it from my device

00:45:14,010 --> 00:45:18,180
do you remember what's the first column

00:45:18,450 --> 00:45:22,830
hits yeah and the second one misses yeah

00:45:22,120 --> 00:45:27,390
great

00:45:22,830 --> 00:45:29,770
so we've seen okay we have a lot of

00:45:27,390 --> 00:45:31,480
misses in here what would you expect

00:45:29,770 --> 00:45:32,590
when I execute the command the second

00:45:31,480 --> 00:45:38,020
time you read the data

00:45:32,590 --> 00:45:38,380
what should happen button what should

00:45:38,020 --> 00:45:41,950
happen

00:45:38,380 --> 00:45:47,950
no no missus no let's see if this is

00:45:41,950 --> 00:45:51,100
true do it a second time okay we have

00:45:47,950 --> 00:45:54,700
lots of hits here it's fine and oh it

00:45:51,100 --> 00:45:58,030
takes not that long in this case it's

00:45:54,700 --> 00:46:02,710
not that long so we've seen okay the

00:45:58,030 --> 00:46:06,520
first case my device my assistant laptop

00:46:02,710 --> 00:46:09,010
had about 280 megabytes per second in

00:46:06,520 --> 00:46:11,530
the second case it's been 1.3 but the

00:46:09,010 --> 00:46:15,960
second one it's a good SSD oh it's a

00:46:11,530 --> 00:46:19,660
fast no no we so we sing ok in this case

00:46:15,960 --> 00:46:22,720
we see now we have all the ISO in the

00:46:19,660 --> 00:46:26,290
page cache so it's good that I have 12

00:46:22,720 --> 00:46:28,180
keypad memo in my laptop to have a some

00:46:26,290 --> 00:46:36,340
gigabyte of ISO image for Windows in

00:46:28,180 --> 00:46:42,700
here but as I don't want to stay to any

00:46:36,340 --> 00:46:45,340
more in my memory I can purge it you can

00:46:42,700 --> 00:46:48,400
do this simply with the echo 3 - proxies

00:46:45,340 --> 00:46:56,170
VM drop caches and the Linux kernel is

00:46:48,400 --> 00:46:58,840
told to drop its page cache so when we

00:46:56,170 --> 00:47:00,280
see now again ok I am the presentation

00:46:58,840 --> 00:47:03,270
running and stuff like that but we have

00:47:00,280 --> 00:47:11,089
about 5 key but less of data here so

00:47:03,270 --> 00:47:19,859
when I read it again searches route

00:47:11,089 --> 00:47:27,569
when I weighed the data again ah second

00:47:19,859 --> 00:47:33,299
one still to the time yeah we sing now

00:47:27,569 --> 00:47:36,150
after I've searched data it again the

00:47:33,299 --> 00:47:40,470
thing that I have misses here

00:47:36,150 --> 00:47:43,140
so this is one example of the purples as

00:47:40,470 --> 00:47:44,760
mentioned these are small scripts for

00:47:43,140 --> 00:47:48,809
brands and Greg and you can grab them

00:47:44,760 --> 00:48:01,769
via github and I have to stop my

00:47:48,809 --> 00:48:02,400
abilities it's done so that's been Simon

00:48:01,769 --> 00:48:06,559
humble sweet

00:48:02,400 --> 00:48:10,529
twelve minutes left to clear all the pot

00:48:06,559 --> 00:48:14,190
it will work out for both of you of you

00:48:10,529 --> 00:48:17,819
and me so I've mentioned it's not that

00:48:14,190 --> 00:48:20,880
easy to - it is 22,000 functions of a

00:48:17,819 --> 00:48:24,809
date call what a good idea

00:48:20,880 --> 00:48:27,990
a good idea is to use a little bit more

00:48:24,809 --> 00:48:30,390
readable output so playing grass a good

00:48:27,990 --> 00:48:32,549
idea for that link of a visualization

00:48:30,390 --> 00:48:36,299
how resources are being distributed

00:48:32,549 --> 00:48:39,450
among code I'm going to take a simpler

00:48:36,299 --> 00:48:41,250
example for example my day a normal work

00:48:39,450 --> 00:48:43,230
day for example is and okay I'm

00:48:41,250 --> 00:48:45,420
processing units for some time then I'm

00:48:43,230 --> 00:48:48,720
getting email data back in here okay

00:48:45,420 --> 00:48:53,730
then I'm doing the back six and yeah

00:48:48,720 --> 00:48:55,859
processed us then I'll hurry on with

00:48:53,730 --> 00:48:57,930
some hacking into some testing and in

00:48:55,859 --> 00:49:01,069
the evening I want to have some dinner

00:48:57,930 --> 00:49:03,660
so something to eat I have to to cook

00:49:01,069 --> 00:49:06,240
today I don't have to cook I can go to a

00:49:03,660 --> 00:49:08,490
evening event in case that I don't have

00:49:06,240 --> 00:49:14,009
to prepare to talk for tomorrow but ok

00:49:08,490 --> 00:49:19,019
we will see Mercedes and here in case

00:49:14,009 --> 00:49:22,500
lunch was lounge for me today but I

00:49:19,019 --> 00:49:24,239
haven't updated this one so the last

00:49:22,500 --> 00:49:48,139
demo for for

00:49:24,239 --> 00:49:50,969
this so we're doing some records uh

00:49:48,139 --> 00:49:53,429
recording when issuing and DD command

00:49:50,969 --> 00:49:56,519
from the steerer to an test file which

00:49:53,429 --> 00:50:00,089
I'm writing to the file system here and

00:49:56,519 --> 00:50:04,049
then we will try to view the data which

00:50:00,089 --> 00:50:12,539
comes out so DD not go into the test SDA

00:50:04,049 --> 00:50:14,489
that's good okay we have two test data

00:50:12,539 --> 00:50:18,719
in here and we have also updated here

00:50:14,489 --> 00:50:23,269
and as you can see ten minutes left okay

00:50:18,719 --> 00:50:23,269
ah this one ten minutes left here

00:50:25,669 --> 00:50:36,449
spunked formative even this PG go to

00:50:30,839 --> 00:50:37,289
background and short on my screen I want

00:50:36,449 --> 00:50:49,049
it on your screen

00:50:37,289 --> 00:50:53,309
oops uh yeah okay yeah so in this case

00:50:49,049 --> 00:50:55,409
we're seeing again the amount of

00:50:53,309 --> 00:50:58,679
functions but in this case we're seeing

00:50:55,409 --> 00:51:01,169
okay we have it a little bit yeah and in

00:50:58,679 --> 00:51:04,649
a better way to to read we can see okay

00:51:01,169 --> 00:51:06,809
this is my my whole comments being

00:51:04,649 --> 00:51:09,989
executed I'm having a file system right

00:51:06,809 --> 00:51:11,399
for example and we're seeing okay to

00:51:09,989 --> 00:51:13,709
have the possibility to write the data

00:51:11,399 --> 00:51:18,799
it has to be encrypted they are using

00:51:13,709 --> 00:51:22,199
for example the AIS new instruction

00:51:18,799 --> 00:51:23,939
function for of the CPU so we can see

00:51:22,199 --> 00:51:26,129
okay we are doing this kind of stuff

00:51:23,939 --> 00:51:28,889
here you can also click into it to get

00:51:26,129 --> 00:51:32,249
details on here so it's yeah a little

00:51:28,889 --> 00:51:35,699
bit easier to to to read in this in this

00:51:32,249 --> 00:51:38,370
case so we can switch back he ever comes

00:51:35,699 --> 00:51:42,290
read DD or heater to the always single

00:51:38,370 --> 00:51:48,530
a what's happening here during this

00:51:42,290 --> 00:51:48,530
whole thing okay eight minutes left

00:52:05,030 --> 00:52:17,520
okay so again here we can see what is

00:52:08,730 --> 00:52:20,370
happening during this thing so the last

00:52:17,520 --> 00:52:23,250
ten minutes is our four I up it off of

00:52:20,370 --> 00:52:25,740
my talk why is the CPU utilization one

00:52:23,250 --> 00:52:29,520
and for this I want that if forgive me I

00:52:25,740 --> 00:52:32,460
have put into this information from here

00:52:29,520 --> 00:52:34,530
about 2:00 p.m. to 2:15 p.m. so it

00:52:32,460 --> 00:52:38,480
hasn't had much that much time for this

00:52:34,530 --> 00:52:43,290
button at least I started a talking time

00:52:38,480 --> 00:52:45,420
so I've used the information from a blog

00:52:43,290 --> 00:52:48,750
posting of Brandon Gregg he's written it

00:52:45,420 --> 00:52:51,690
some basic on 9th of May and updated it

00:52:48,750 --> 00:52:55,680
one or two days ago and the thing is

00:52:51,690 --> 00:52:57,920
what has what do you have to to care for

00:52:55,680 --> 00:53:03,180
when you are using the CPU utilization

00:52:57,920 --> 00:53:06,630
number and the thing is that the CPU

00:53:03,180 --> 00:53:09,450
utilization is misleading maladies and

00:53:06,630 --> 00:53:10,470
also for a long time and it gets it's

00:53:09,450 --> 00:53:12,540
getting worse every year

00:53:10,470 --> 00:53:17,070
so the question is what is CPU

00:53:12,540 --> 00:53:18,810
utilization how busy I processes how

00:53:17,070 --> 00:53:22,530
busy your processes aren't that's not

00:53:18,810 --> 00:53:25,320
what it measures and it means person CPU

00:53:22,530 --> 00:53:27,390
used everywhere for everyone forever to

00:53:25,320 --> 00:53:28,950
also like top and stuff like that the

00:53:27,390 --> 00:53:30,420
Costas is also the data which goes in

00:53:28,950 --> 00:53:30,720
the proc file system and we've learned

00:53:30,420 --> 00:53:32,280
ok

00:53:30,720 --> 00:53:35,310
most of the data station of the proc

00:53:32,280 --> 00:53:38,580
file system so when we think ok we have

00:53:35,310 --> 00:53:45,360
90% CPU utilization it really means okay

00:53:38,580 --> 00:53:48,450
we have something lower than 90% we are

00:53:45,360 --> 00:53:52,080
having many cases when we are indeed

00:53:48,450 --> 00:53:56,280
waiting installed in some kind of thing

00:53:52,080 --> 00:53:59,130
the waiting like IO 8 or some other idle

00:53:56,280 --> 00:54:02,880
time is the blue one here and the gray

00:53:59,130 --> 00:54:05,550
one is mostly waiting on memory IO and

00:54:02,880 --> 00:54:08,370
the reason here is that the CPU

00:54:05,550 --> 00:54:11,020
performance or the performance within

00:54:08,370 --> 00:54:14,380
the CPU cut

00:54:11,020 --> 00:54:17,620
by far compared to the performance of

00:54:14,380 --> 00:54:20,590
the memory so when you are seeing the

00:54:17,620 --> 00:54:22,390
information okay I'm having 90% CPU

00:54:20,590 --> 00:54:25,750
utilization it also could mean that my

00:54:22,390 --> 00:54:28,780
CPU is only doing for 10 or 15% stuff

00:54:25,750 --> 00:54:32,260
and the other 70% for example it's

00:54:28,780 --> 00:54:35,610
waiting on memory and I own and I will

00:54:32,260 --> 00:54:38,170
recommend to read this blog posting here

00:54:35,610 --> 00:54:40,390
what can do for example you could use

00:54:38,170 --> 00:54:42,670
these performance monitoring counters

00:54:40,390 --> 00:54:43,930
the instructions per cycle between the

00:54:42,670 --> 00:54:45,430
number which I've mentioned before that

00:54:43,930 --> 00:54:48,490
we'll come to it

00:54:45,430 --> 00:54:52,150
again this is the key metric here we're

00:54:48,490 --> 00:54:55,180
seeing for example 0.78 instructions per

00:54:52,150 --> 00:54:57,310
cycle the sounds good but we have to

00:54:55,180 --> 00:55:02,740
take into account this architectures and

00:54:57,310 --> 00:55:06,310
IP C performance of four so newer

00:55:02,740 --> 00:55:08,850
skylake processor safai has a maximum

00:55:06,310 --> 00:55:13,600
performance of five so it's not that

00:55:08,850 --> 00:55:16,240
good in this case here how can you

00:55:13,600 --> 00:55:18,850
interpret this values whether it's lower

00:55:16,240 --> 00:55:20,680
than 1 or higher than one when it's

00:55:18,850 --> 00:55:23,620
lower than one it's most likely that

00:55:20,680 --> 00:55:24,790
your memory is stalled when it's higher

00:55:23,620 --> 00:55:28,060
than one it's most likely at your

00:55:24,790 --> 00:55:31,390
instruction sound more details you can

00:55:28,060 --> 00:55:33,390
can find the blog posting and the thing

00:55:31,390 --> 00:55:38,910
with I want and wanted to mention here's

00:55:33,390 --> 00:55:42,220
the third or fourth top tool tip top

00:55:38,910 --> 00:55:45,010
which sounds even better than H top it

00:55:42,220 --> 00:55:47,350
has this information within here can be

00:55:45,010 --> 00:55:50,050
easily used just install it it's a

00:55:47,350 --> 00:55:51,400
variable on all new distributions so if

00:55:50,050 --> 00:55:53,380
you won't take this one to take

00:55:51,400 --> 00:55:56,830
something with you and take tip top with

00:55:53,380 --> 00:55:58,150
you and and the blog posting here what

00:55:56,830 --> 00:56:01,300
other reasons why the CPU utilization

00:55:58,150 --> 00:56:03,250
can be misleading it could be that your

00:56:01,300 --> 00:56:04,900
system is running in the temperature

00:56:03,250 --> 00:56:09,010
trips when the cooling is not that

00:56:04,900 --> 00:56:12,940
optimal the hardware tries to avoid that

00:56:09,010 --> 00:56:14,790
you burn your CPU so it's going it it

00:56:12,940 --> 00:56:17,530
down

00:56:14,790 --> 00:56:20,530
for example using turbo boost on new

00:56:17,530 --> 00:56:23,739
architectures for one core is getting

00:56:20,530 --> 00:56:26,919
faster when you only has a

00:56:23,739 --> 00:56:31,689
utilization for one core or using

00:56:26,919 --> 00:56:35,739
speedstep important for laptops when you

00:56:31,689 --> 00:56:39,429
when you want to get long running time

00:56:35,739 --> 00:56:40,989
and yeah also the program with our kids

00:56:39,429 --> 00:56:43,689
when you have eighty percent average

00:56:40,989 --> 00:56:45,939
over one minute this height bursts of

00:56:43,689 --> 00:56:47,829
100 percent so you have to really be

00:56:45,939 --> 00:56:50,409
careful with the CPU utilization

00:56:47,829 --> 00:56:54,969
I recommend really to to which random

00:56:50,409 --> 00:57:00,459
Gregg's blog posting and yeah take this

00:56:54,969 --> 00:57:03,159
with you so the speaker agreement says

00:57:00,459 --> 00:57:05,349
you have should have maximum fifty-five

00:57:03,159 --> 00:57:09,939
minutes some minutes for questions I've

00:57:05,349 --> 00:57:14,219
fifty seven but I think hopefully made

00:57:09,939 --> 00:57:14,219
it and yeah are there any questions

00:57:23,780 --> 00:57:44,640
it's switched off the question is other

00:57:42,410 --> 00:57:52,290
optimizations for numerous system this

00:57:44,640 --> 00:57:55,470
is correct yeah that's a that's a really

00:57:52,290 --> 00:57:56,940
good question the question sounds done

00:57:55,470 --> 00:57:59,730
correctly when we have a numerous system

00:57:56,940 --> 00:58:02,190
yes yeah in the memory bound to one CPU

00:57:59,730 --> 00:58:05,369
and you want to catch the data which are

00:58:02,190 --> 00:58:06,780
using the CPU in your nearest memory and

00:58:05,369 --> 00:58:08,940
modern in memory which is behind the

00:58:06,780 --> 00:58:11,250
second processor or third or fourth

00:58:08,940 --> 00:58:12,930
process and and for that kind of stuff

00:58:11,250 --> 00:58:14,700
it really depends on a new architecture

00:58:12,930 --> 00:58:18,210
there different architecture like not

00:58:14,700 --> 00:58:21,060
only the x86 architecture also the power

00:58:18,210 --> 00:58:23,760
architecture of some further information

00:58:21,060 --> 00:58:26,250
on tomorrow and I would recommend when

00:58:23,760 --> 00:58:29,400
you're using Numa system watch out which

00:58:26,250 --> 00:58:31,350
architecture you're using and then

00:58:29,400 --> 00:58:34,170
search for for possible optimizations

00:58:31,350 --> 00:58:36,960
there are indeed some junipers you could

00:58:34,170 --> 00:58:38,700
you could use there especially for the

00:58:36,960 --> 00:58:42,030
for the power architecture and I know

00:58:38,700 --> 00:58:44,040
some of some of them and we can talk

00:58:42,030 --> 00:58:51,330
also in there in a break later on for

00:58:44,040 --> 00:58:56,880
that yeah okay are there any other

00:58:51,330 --> 00:59:00,140
questions okay it's not the case I see

00:58:56,880 --> 00:59:02,690
we're just in time

00:59:00,140 --> 00:59:04,200
excellent talk thank you very very much

00:59:02,690 --> 00:59:07,569
the neck

00:59:04,200 --> 00:59:10,569
[Applause]

00:59:07,569 --> 00:59:10,569

YouTube URL: https://www.youtube.com/watch?v=ViTctbyH-k4


