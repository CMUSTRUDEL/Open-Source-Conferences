Title: OSDC 2014: Fabrizio Manfredi - Data replication
Publication date: 2015-01-05
Playlist: OSDC 2014 | Open Source Data Center Conference
Description: 
	Data replication is a crucial component for distributed services deployed in a multi-Data Center environment. The replication schema needs to be carefully evaluated before its implementation, wrong design or the misuse in most of the case end with a big service outages.
To understand the replication it is needed to understand the algorithms behind it, for this reason the session will start to explaining the most used algorithms to solve the CAP theorem (Consistency , Availability and Partitioning Tolerance) like Consistent Hash, Vector clock, Gossip protocol, Paxos and Raft.
The second part of the talk will be focused to analyze how the products on the market do the replication (replication in action) with advantages and disadvantages, the talk will cover the distributed filesystem (cephs, tahoe, extreemfs..), distributed databases (db replication primitieves and external tool like Tungsten), Nosql (riak, cassandra, mongodb, couchdb) and Frameworks for in house solution (beardb, open replication,..). The talk will also show the evaluation methods and testing process for identify the best solution for your environment. 

Find the full program and all slides here: 
http://www.netways.de/osdc/osdc2014/programm
Captions: 
	00:00:14,950 --> 00:00:20,420
okay then welcome to the next dog adjust

00:00:18,920 --> 00:00:22,759
if the shortening meal for bitumen free

00:00:20,420 --> 00:00:25,640
but there is a furrow home in yeah that

00:00:22,759 --> 00:00:27,110
my last name okay so we don't have it

00:00:25,640 --> 00:00:31,279
until now but now we know it for the

00:00:27,110 --> 00:00:32,989
next time so thanks for coming the the

00:00:31,279 --> 00:00:35,899
yeah you're talking about data

00:00:32,989 --> 00:00:40,489
replication I'm I'm really happy because

00:00:35,899 --> 00:00:42,980
it's it sounds a big field yeah it's a

00:00:40,489 --> 00:00:45,410
big field and and a little bit worried

00:00:42,980 --> 00:00:48,620
because no could be good for someone

00:00:45,410 --> 00:00:51,380
probably not good for other then I see

00:00:48,620 --> 00:00:55,700
not many people please stop me ask me

00:00:51,380 --> 00:00:58,670
question no this is not enough deep or

00:00:55,700 --> 00:01:00,920
is Susie for anyway so we think we can

00:00:58,670 --> 00:01:02,600
make a more interaction section okay

00:01:00,920 --> 00:01:08,030
perfect we look forward to it then it's

00:01:02,600 --> 00:01:10,340
your stage thank you oh okay can I ask

00:01:08,030 --> 00:01:14,000
you why you are interesting data

00:01:10,340 --> 00:01:16,219
replication in this session quite to

00:01:14,000 --> 00:01:20,780
have any idea what is the topic that you

00:01:16,219 --> 00:01:22,609
want to know just for fun yeah that is

00:01:20,780 --> 00:01:34,130
fun that's I have to say that is fun

00:01:22,609 --> 00:01:36,229
yeah there are many situation with more

00:01:34,130 --> 00:01:37,700
than one node then you need to replicate

00:01:36,229 --> 00:01:41,779
the data across all they know that I

00:01:37,700 --> 00:01:46,909
believe yeah well this session is

00:01:41,779 --> 00:01:49,009
divided mainly in two big part the first

00:01:46,909 --> 00:01:52,310
part is an introduction and probably a

00:01:49,009 --> 00:01:56,060
little bit boring with some theorems

00:01:52,310 --> 00:01:58,990
some common patterns some algorithm and

00:01:56,060 --> 00:02:01,729
so on and after that when we will know

00:01:58,990 --> 00:02:04,279
the algorithm we will try to understand

00:02:01,729 --> 00:02:07,159
how it works in different implementation

00:02:04,279 --> 00:02:11,330
like file system database is no SQL and

00:02:07,159 --> 00:02:16,880
some common tools data replication we

00:02:11,330 --> 00:02:19,430
already a little bit anticipate is a big

00:02:16,880 --> 00:02:24,190
topic in the past was my only connected

00:02:19,430 --> 00:02:26,790
to snapshot or backup disaster recovery

00:02:24,190 --> 00:02:28,969
but today

00:02:26,790 --> 00:02:33,019
is more connected to cloud computing

00:02:28,969 --> 00:02:35,400
scalability I ability height performance

00:02:33,019 --> 00:02:38,370
distribution around the world because

00:02:35,400 --> 00:02:41,400
today you can have one data center

00:02:38,370 --> 00:02:45,299
everywhere you can buy is quite a low

00:02:41,400 --> 00:02:49,319
price some vm somewhere first example is

00:02:45,299 --> 00:02:53,040
amazon and you can have one that one vm

00:02:49,319 --> 00:02:57,930
in ca1 vm in singapore one in San Paulo

00:02:53,040 --> 00:03:01,260
or knows Santa Clara and so on but well

00:02:57,930 --> 00:03:06,780
the world is quite well connected if you

00:03:01,260 --> 00:03:08,939
check the the wire or undersea wire and

00:03:06,780 --> 00:03:13,019
so on there are a lot of connection

00:03:08,939 --> 00:03:17,180
around the world but probably not many

00:03:13,019 --> 00:03:19,560
people know that you need at least 200

00:03:17,180 --> 00:03:25,069
milliseconds between Sydney and Santa

00:03:19,560 --> 00:03:28,379
Clara or 250 milliseconds from London to

00:03:25,069 --> 00:03:31,409
Singapore or and so on and so on that

00:03:28,379 --> 00:03:35,940
seems very small amount of time with

00:03:31,409 --> 00:03:39,299
talking about milliseconds but probably

00:03:35,940 --> 00:03:43,049
you already know much better than me the

00:03:39,299 --> 00:03:45,479
latency on a single packet is a really

00:03:43,049 --> 00:03:48,180
killer application or kill your

00:03:45,479 --> 00:03:51,269
application because we can see when you

00:03:48,180 --> 00:03:55,620
arrive to 200 milliseconds your response

00:03:51,269 --> 00:03:58,919
time is closed out to one two three

00:03:55,620 --> 00:04:01,290
second depend of the size that means the

00:03:58,919 --> 00:04:03,419
bandwidth is not enough the bandwidth is

00:04:01,290 --> 00:04:05,549
important the bank is very important in

00:04:03,419 --> 00:04:08,040
the local data center but when you have

00:04:05,549 --> 00:04:12,810
more than one at the center you have to

00:04:08,040 --> 00:04:15,299
fight with the latency some other

00:04:12,810 --> 00:04:17,359
measure to know understand the

00:04:15,299 --> 00:04:21,389
difference that you have in memory and

00:04:17,359 --> 00:04:25,860
network know that a memory you talk

00:04:21,389 --> 00:04:29,070
about microsecond in network you talk

00:04:25,860 --> 00:04:32,849
about milliseconds then any operation

00:04:29,070 --> 00:04:37,289
any transaction in memory is not 1,000

00:04:32,849 --> 00:04:39,969
faster than any other solution and for

00:04:37,289 --> 00:04:44,169
the latest thing in two thousand and

00:04:39,969 --> 00:04:47,589
nine I believe viewers define a cap

00:04:44,169 --> 00:04:51,069
theorem define three main area of

00:04:47,589 --> 00:04:53,829
interest not everyone want no I've

00:04:51,069 --> 00:04:57,610
ability partition tolerance and

00:04:53,829 --> 00:05:02,259
consistence and they said is not

00:04:57,610 --> 00:05:04,539
possible to have all together if you if

00:05:02,259 --> 00:05:06,309
you use a network mainly if you don't

00:05:04,539 --> 00:05:09,009
use a network and you have a single

00:05:06,309 --> 00:05:11,259
installation while in the past 20 years

00:05:09,009 --> 00:05:13,329
ago that was quite famous the tandem

00:05:11,259 --> 00:05:16,059
system with double are what or three

00:05:13,329 --> 00:05:19,059
Pollard were no that's that's high of

00:05:16,059 --> 00:05:21,039
ability inside of the artwork but if you

00:05:19,059 --> 00:05:22,989
don't have more than hardware you don't

00:05:21,039 --> 00:05:25,360
have a viability but if you want have

00:05:22,989 --> 00:05:27,939
ability you need some connection that

00:05:25,360 --> 00:05:33,099
means you need some you introduce some

00:05:27,939 --> 00:05:35,949
latency then 2012 this Turing was a

00:05:33,099 --> 00:05:38,799
little bit review but the concept

00:05:35,949 --> 00:05:40,779
remains the same so now today we talk

00:05:38,799 --> 00:05:44,619
that you can have the three elements

00:05:40,779 --> 00:05:48,249
together in the same time you can decide

00:05:44,619 --> 00:05:52,679
time by time no time time by time what

00:05:48,249 --> 00:05:58,360
you want to break a little bit the

00:05:52,679 --> 00:06:01,779
paradigm of acid no the database no to

00:05:58,360 --> 00:06:06,579
have the consistent and so on we have

00:06:01,779 --> 00:06:10,779
seen the no SQL generated a new topic

00:06:06,579 --> 00:06:15,579
the base no base I've ability soft state

00:06:10,779 --> 00:06:17,409
it eventual consistency but mainly the

00:06:15,579 --> 00:06:21,339
main problem that you have today that

00:06:17,409 --> 00:06:24,669
client can see different stuff in the

00:06:21,339 --> 00:06:28,089
same time and it's quite funny they

00:06:24,669 --> 00:06:30,129
decide is acid and base now like in the

00:06:28,089 --> 00:06:33,759
chemistry know that you have complete

00:06:30,129 --> 00:06:38,469
two opposite view or also two opposite

00:06:33,759 --> 00:06:41,739
reaction the cap theorem what you want

00:06:38,469 --> 00:06:45,399
to use now if you want to have more of

00:06:41,739 --> 00:06:48,759
ability or consistently or partition

00:06:45,399 --> 00:06:51,429
resistant is not a technical problem is

00:06:48,759 --> 00:06:53,730
a mainly a business decision you have to

00:06:51,429 --> 00:06:56,640
decide and to know

00:06:53,730 --> 00:06:59,610
talk with your business or your

00:06:56,640 --> 00:07:05,590
stakeholder to be agree because it's a

00:06:59,610 --> 00:07:06,910
has a big impact on the business now we

00:07:05,590 --> 00:07:11,590
will start a little bit with some

00:07:06,910 --> 00:07:14,920
formula and but yeah don't worry we have

00:07:11,590 --> 00:07:17,740
seen we can divide the program in more

00:07:14,920 --> 00:07:20,860
or less four elements data placement

00:07:17,740 --> 00:07:23,080
data consistency system coordination and

00:07:20,860 --> 00:07:25,180
data and data transmission this is more

00:07:23,080 --> 00:07:28,870
or less than the four main topics in

00:07:25,180 --> 00:07:31,290
data replication first of all we have

00:07:28,870 --> 00:07:35,410
seen latency if you want to transfer

00:07:31,290 --> 00:07:37,900
with a single piece in a long distance

00:07:35,410 --> 00:07:41,470
but also in the local network we take a

00:07:37,900 --> 00:07:45,220
lot of time because TCP and so on and so

00:07:41,470 --> 00:07:48,450
on that the first topic is to divide

00:07:45,220 --> 00:07:51,850
your content your block your data

00:07:48,450 --> 00:07:55,120
depends or know that you can base on the

00:07:51,850 --> 00:07:58,630
bite can based on the future can based

00:07:55,120 --> 00:08:01,240
on on the topics you can up to you but

00:07:58,630 --> 00:08:03,610
you have to divide if you divide you can

00:08:01,240 --> 00:08:06,060
use multi stream that means parallel

00:08:03,610 --> 00:08:08,550
operation and also the multi-core

00:08:06,060 --> 00:08:12,580
otherwise you have only a single

00:08:08,550 --> 00:08:14,710
operation when you have divided your

00:08:12,580 --> 00:08:17,290
head your your component or your

00:08:14,710 --> 00:08:20,470
information in small elements you have

00:08:17,290 --> 00:08:23,650
to decide how you want to deploy how you

00:08:20,470 --> 00:08:26,560
want to place mainly there are three

00:08:23,650 --> 00:08:29,050
topics today one is centralized that you

00:08:26,560 --> 00:08:33,580
have someone that knows where is all the

00:08:29,050 --> 00:08:36,700
pieces of your information or completely

00:08:33,580 --> 00:08:39,370
then decentralize that you have some

00:08:36,700 --> 00:08:41,680
mathematical formula that is able to

00:08:39,370 --> 00:08:43,540
look up for you or give you the

00:08:41,680 --> 00:08:45,340
information where to pick up the info

00:08:43,540 --> 00:08:48,690
where is the information based on the

00:08:45,340 --> 00:08:52,120
content we will see there is also today

00:08:48,690 --> 00:08:56,380
across on the two that is more

00:08:52,120 --> 00:08:59,290
distributed no that's not not try to

00:08:56,380 --> 00:09:02,480
make more advantage on the to the

00:08:59,290 --> 00:09:07,589
previous two elements

00:09:02,480 --> 00:09:11,180
today the more use it or more you can

00:09:07,589 --> 00:09:15,390
find everywhere I have to say is a

00:09:11,180 --> 00:09:19,529
placement debate by hash made hashing

00:09:15,390 --> 00:09:22,470
that seems complicated no that's if you

00:09:19,529 --> 00:09:24,960
see that seems that is written by in

00:09:22,470 --> 00:09:29,910
another language but the comp that is

00:09:24,960 --> 00:09:33,120
extremely simple you have your data you

00:09:29,910 --> 00:09:36,060
divide your data you made the hash in

00:09:33,120 --> 00:09:38,700
the hash that you want and after that

00:09:36,060 --> 00:09:41,490
you have to define most of the case

00:09:38,700 --> 00:09:44,880
virtual node the virtual node is a range

00:09:41,490 --> 00:09:51,330
of the key though if you use for example

00:09:44,880 --> 00:09:54,300
SSH one you have 161 I believe bit that

00:09:51,330 --> 00:09:57,870
you can create a range of key you divide

00:09:54,300 --> 00:10:01,740
the space in element you can call this

00:09:57,870 --> 00:10:04,770
element V node or as you want and assign

00:10:01,740 --> 00:10:07,740
these know this vinodh to a real note a

00:10:04,770 --> 00:10:13,020
real server and immediately you have

00:10:07,740 --> 00:10:15,990
distributed your data another important

00:10:13,020 --> 00:10:20,220
that to visualize you can put the key in

00:10:15,990 --> 00:10:24,510
a ring and then you can understand how

00:10:20,220 --> 00:10:27,810
it works that's quite simple and this

00:10:24,510 --> 00:10:31,730
approach is using mailing all know SQL

00:10:27,810 --> 00:10:34,470
but also in the cluster and replication

00:10:31,730 --> 00:10:37,400
there are some theories some some other

00:10:34,470 --> 00:10:40,890
algorithm that are based on the space

00:10:37,400 --> 00:10:43,680
evaluation are multi-dimensional but at

00:10:40,890 --> 00:10:47,459
the moment is not so use it but this is

00:10:43,680 --> 00:10:50,790
quite interesting ok now we have found

00:10:47,459 --> 00:10:53,580
how to distribute the element the second

00:10:50,790 --> 00:10:56,160
point is how to make the replication now

00:10:53,580 --> 00:10:58,620
we found that to send one piece in one

00:10:56,160 --> 00:11:02,279
node that is not replication this is

00:10:58,620 --> 00:11:06,029
only placement I can do quite easily and

00:11:02,279 --> 00:11:09,089
without problem mainly today we use to

00:11:06,029 --> 00:11:11,500
you can find to approach one approach

00:11:09,089 --> 00:11:15,850
very simple to San

00:11:11,500 --> 00:11:19,300
the key that is in your range two other

00:11:15,850 --> 00:11:22,120
two element at a to note that are close

00:11:19,300 --> 00:11:24,790
to you that's very simple you receive

00:11:22,120 --> 00:11:26,650
the key you send this you receive the

00:11:24,790 --> 00:11:29,740
piece of data and you sent to the

00:11:26,650 --> 00:11:33,550
element the next to the previews and the

00:11:29,740 --> 00:11:35,590
next as you want that means you have and

00:11:33,550 --> 00:11:37,780
for this reason most of the time you see

00:11:35,590 --> 00:11:40,750
the replication is based by three well

00:11:37,780 --> 00:11:46,030
also for other reason the second

00:11:40,750 --> 00:11:49,090
approach is to create on the node level

00:11:46,030 --> 00:11:51,820
a small cluster of three element that in

00:11:49,090 --> 00:11:55,570
this case means you need a coordination

00:11:51,820 --> 00:11:57,640
election and many other stuff the first

00:11:55,570 --> 00:12:00,250
one that I said is quite simple the

00:11:57,640 --> 00:12:04,290
second is a little bit more complicated

00:12:00,250 --> 00:12:13,120
but is faster to detect the failure any

00:12:04,290 --> 00:12:16,660
question simple I believe no yes no that

00:12:13,120 --> 00:12:19,300
that is more simple and we have seen in

00:12:16,660 --> 00:12:23,110
no SQL or any way the new approach is to

00:12:19,300 --> 00:12:25,000
reduce the consistency to avoid the

00:12:23,110 --> 00:12:28,839
consists of all to introduce the

00:12:25,000 --> 00:12:33,610
consistency when you need today we are

00:12:28,839 --> 00:12:37,420
more or less six way to mail something

00:12:33,610 --> 00:12:39,970
similar to taxes or anyway the commit

00:12:37,420 --> 00:12:42,520
that we have in the database this is the

00:12:39,970 --> 00:12:44,200
last one is more or less what happened

00:12:42,520 --> 00:12:46,800
in the database no you lock everything

00:12:44,200 --> 00:12:50,950
you've write everything and you unlock

00:12:46,800 --> 00:12:54,190
how you can reproduce this situation if

00:12:50,950 --> 00:12:59,080
you don't have any locking system you

00:12:54,190 --> 00:13:04,690
can write and read more than one what

00:12:59,080 --> 00:13:08,650
that means a simple example is read all

00:13:04,690 --> 00:13:14,470
right forum if you have a four nodes and

00:13:08,650 --> 00:13:16,150
you've right and you write you start to

00:13:14,470 --> 00:13:19,360
write that you have to write on all the

00:13:16,150 --> 00:13:22,660
nodes but you read always three times

00:13:19,360 --> 00:13:24,310
you are you know that if it's the data

00:13:22,660 --> 00:13:27,160
is there or not

00:13:24,310 --> 00:13:31,120
that is a simple approach that is used

00:13:27,160 --> 00:13:34,029
to create a kind of guarantee or

00:13:31,120 --> 00:13:36,990
otherwise you can create a quorum and

00:13:34,029 --> 00:13:39,520
there are some some other approach

00:13:36,990 --> 00:13:42,040
basically you start from the first

00:13:39,520 --> 00:13:44,410
picture on the top that you can

00:13:42,040 --> 00:13:46,750
recognize immediately that is more or

00:13:44,410 --> 00:13:49,000
less what happened like in the MySQL

00:13:46,750 --> 00:13:51,220
master-slave that you start to write but

00:13:49,000 --> 00:13:55,060
the information problem is still not on

00:13:51,220 --> 00:13:57,580
on the slave if you increase the number

00:13:55,060 --> 00:14:01,960
of the read on this layer level you can

00:13:57,580 --> 00:14:05,020
create like a read all right ones all

00:14:01,960 --> 00:14:07,570
right all depends but what I want to say

00:14:05,020 --> 00:14:11,560
that there are some technique that you

00:14:07,570 --> 00:14:13,660
can use to make a simulation of the

00:14:11,560 --> 00:14:15,430
commit when you strictly need when is

00:14:13,660 --> 00:14:19,660
strictly need when you want to be

00:14:15,430 --> 00:14:24,000
completely sure that the data is is

00:14:19,660 --> 00:14:24,000
committed and a store on the device

00:14:24,810 --> 00:14:31,690
that's any question I have to explain a

00:14:27,550 --> 00:14:38,790
little bit more now for this reason was

00:14:31,690 --> 00:14:42,570
not to the y por fin we have said no arm

00:14:38,790 --> 00:14:46,720
we have in some cases more cluster and

00:14:42,570 --> 00:14:49,089
we need a coordination today we can see

00:14:46,720 --> 00:14:51,220
two main protocol one is the taxes

00:14:49,089 --> 00:14:55,270
that's you can find implementation

00:14:51,220 --> 00:14:58,990
everywhere and is an election system is

00:14:55,270 --> 00:15:01,330
a consensus and election system quite I

00:14:58,990 --> 00:15:03,720
don't want to say quite simple because

00:15:01,330 --> 00:15:07,540
it's not so simple but it's quite clear

00:15:03,720 --> 00:15:10,000
today also from from no SQL or no

00:15:07,540 --> 00:15:12,760
emerging technology we have epidemic

00:15:10,000 --> 00:15:16,870
while sometimes you can find gossip the

00:15:12,760 --> 00:15:20,260
epidemic protocol is an idea like the

00:15:16,870 --> 00:15:23,920
virus know to contact 11 other node and

00:15:20,260 --> 00:15:25,900
exchange information is a kind of build

00:15:23,920 --> 00:15:27,820
a routing table note you exchange

00:15:25,900 --> 00:15:30,790
information with another road and you

00:15:27,820 --> 00:15:33,280
after a couple of interaction all the

00:15:30,790 --> 00:15:35,770
node in the in the in the cluster has

00:15:33,280 --> 00:15:38,000
the same information you can see that

00:15:35,770 --> 00:15:40,970
well it's based on log

00:15:38,000 --> 00:15:42,890
and and you can see no after a couple of

00:15:40,970 --> 00:15:45,470
interaction all the elements in the

00:15:42,890 --> 00:15:49,060
cluster have the same information also

00:15:45,470 --> 00:15:51,320
in this case you can find many types of

00:15:49,060 --> 00:15:55,340
implementation but yeah in the beginning

00:15:51,320 --> 00:15:57,380
seem strange but it works and most of

00:15:55,340 --> 00:16:01,210
the case is more more faster than

00:15:57,380 --> 00:16:04,670
consensus that need all the part our art

00:16:01,210 --> 00:16:07,850
agree with a specific value and collect

00:16:04,670 --> 00:16:12,890
information prop know and elect a new

00:16:07,850 --> 00:16:16,460
master the consensus protocol is used

00:16:12,890 --> 00:16:19,370
mainly in the database for commit two

00:16:16,460 --> 00:16:26,060
phase commit the epidemic protocol is

00:16:19,370 --> 00:16:29,990
more used for failure detection on the

00:16:26,060 --> 00:16:32,510
transmission protocol like well if you

00:16:29,990 --> 00:16:34,790
know how the cell is the right itself or

00:16:32,510 --> 00:16:37,190
reproduces cell you can know there is

00:16:34,790 --> 00:16:40,820
some phases and one of the first phase

00:16:37,190 --> 00:16:44,000
is to put some order inside also the

00:16:40,820 --> 00:16:46,940
replication is quite good too first of

00:16:44,000 --> 00:16:50,510
all reorder because sometimes the data

00:16:46,940 --> 00:16:52,640
is you have to operation on the same

00:16:50,510 --> 00:16:54,260
block or two operations and eight data

00:16:52,640 --> 00:16:56,450
information that doesn't make sense to

00:16:54,260 --> 00:16:59,600
transmit if you have a buffer but that

00:16:56,450 --> 00:17:03,410
means you are not synchronized you have

00:16:59,600 --> 00:17:07,640
also compress and more data that means a

00:17:03,410 --> 00:17:09,680
better compression and you have also

00:17:07,640 --> 00:17:12,470
transmitted you can transmit by

00:17:09,680 --> 00:17:15,079
difference that doesn't if you have the

00:17:12,470 --> 00:17:17,480
day type and and only a small part is

00:17:15,079 --> 00:17:19,819
changed you don't have to transmit all

00:17:17,480 --> 00:17:23,390
the data but that means you have to keep

00:17:19,819 --> 00:17:25,550
the hash of each single element but the

00:17:23,390 --> 00:17:28,730
hash of each single element in most of

00:17:25,550 --> 00:17:30,800
the case if you use a hash placement you

00:17:28,730 --> 00:17:32,720
have because it's a hash base and the

00:17:30,800 --> 00:17:35,000
hair should be the content that of your

00:17:32,720 --> 00:17:37,070
element that you have all the hash you

00:17:35,000 --> 00:17:39,680
can compare the hash and transmit on the

00:17:37,070 --> 00:17:43,370
block that this change it that is quite

00:17:39,680 --> 00:17:46,280
simple and obviously quite fast there is

00:17:43,370 --> 00:17:48,830
also some other optimization like Markel

00:17:46,280 --> 00:17:54,320
three merkel three is an

00:17:48,830 --> 00:17:58,010
way to rebuild a copy that is broken or

00:17:54,320 --> 00:18:00,710
went offline is always based on the hash

00:17:58,010 --> 00:18:04,580
with the hash you can save a lot of time

00:18:00,710 --> 00:18:07,220
and as we know the Latin seen kill know

00:18:04,580 --> 00:18:10,700
the transmission that less data less

00:18:07,220 --> 00:18:13,250
latency mainly on a real date there are

00:18:10,700 --> 00:18:15,230
many other things like locking with

00:18:13,250 --> 00:18:19,190
distributing locking multi versioning

00:18:15,230 --> 00:18:24,500
and so on but I decide to skip skip this

00:18:19,190 --> 00:18:27,350
part okay now we have we know more or

00:18:24,500 --> 00:18:30,080
less how to work the replication we can

00:18:27,350 --> 00:18:32,600
see the three halaman the cap theorem

00:18:30,080 --> 00:18:36,320
and we can see the I've ability

00:18:32,600 --> 00:18:39,620
consistency is mainly based on RM dbms

00:18:36,320 --> 00:18:41,899
by database relation database we have

00:18:39,620 --> 00:18:46,220
consistency and partitioning tolerance

00:18:41,899 --> 00:18:48,440
we can have MongoDB HBS and through I've

00:18:46,220 --> 00:18:51,320
ability and partition tolerance we have

00:18:48,440 --> 00:18:53,570
rear cassandra and so on this is mainly

00:18:51,320 --> 00:19:00,500
the implementation based on the

00:18:53,570 --> 00:19:02,750
algorithm that we have seen sorry we can

00:19:00,500 --> 00:19:05,450
also divide know the content that's

00:19:02,750 --> 00:19:07,850
another important topic I want to say

00:19:05,450 --> 00:19:10,340
doesn't exist the perfect replication

00:19:07,850 --> 00:19:13,179
system the replication system is made

00:19:10,340 --> 00:19:16,340
based on the content that you have and

00:19:13,179 --> 00:19:19,720
obviously if you have to replicate block

00:19:16,340 --> 00:19:21,980
or five probably the best solution is a

00:19:19,720 --> 00:19:24,679
distributed file system because probably

00:19:21,980 --> 00:19:27,470
you don't want to lose data or you don't

00:19:24,679 --> 00:19:32,380
want the user see different data and so

00:19:27,470 --> 00:19:35,000
on or you don't want yeah overlapping or

00:19:32,380 --> 00:19:37,730
inconsistent state if you have

00:19:35,000 --> 00:19:40,250
information but that you can well

00:19:37,730 --> 00:19:43,549
structure probably you want a database

00:19:40,250 --> 00:19:46,700
for most of the other things document

00:19:43,549 --> 00:19:50,120
blog section properties or content that

00:19:46,700 --> 00:19:56,330
doesn't change very well you can

00:19:50,120 --> 00:19:58,220
probably want to move to know SQL and

00:19:56,330 --> 00:20:01,039
now we'll start to see a little bit the

00:19:58,220 --> 00:20:02,179
implementation the first is distributed

00:20:01,039 --> 00:20:05,259
file system

00:20:02,179 --> 00:20:09,529
that is a strange is a strange animal

00:20:05,259 --> 00:20:12,350
because sim all but at the same time we

00:20:09,529 --> 00:20:14,990
have a file system everywhere there are

00:20:12,350 --> 00:20:17,899
tones or file system distributed file

00:20:14,990 --> 00:20:20,990
system there are some someone are more

00:20:17,899 --> 00:20:24,289
famous while so much CT DB is not really

00:20:20,990 --> 00:20:26,570
a file system and also dr DB is not a

00:20:24,289 --> 00:20:28,879
real file system but you can find an

00:20:26,570 --> 00:20:31,639
internet a lot of solution open source

00:20:28,879 --> 00:20:35,929
base and many other solution proprietary

00:20:31,639 --> 00:20:37,999
base and quite expensive the main

00:20:35,929 --> 00:20:39,769
advantage of file system is a file

00:20:37,999 --> 00:20:42,529
system that everyone read them right

00:20:39,769 --> 00:20:45,440
file then you can automate operation

00:20:42,529 --> 00:20:47,929
threw a bash to java and whatever you

00:20:45,440 --> 00:20:50,269
want then you don't have to care about

00:20:47,929 --> 00:20:52,789
the localization of your data you read

00:20:50,269 --> 00:20:56,509
and write most of these file system has

00:20:52,789 --> 00:21:01,429
a single unit path then the path is the

00:20:56,509 --> 00:21:04,580
same on all nodes the disadvantage is

00:21:01,429 --> 00:21:07,369
most of the keys they have program on

00:21:04,580 --> 00:21:09,740
scalability or higher ability depends of

00:21:07,369 --> 00:21:12,590
the implementation are also partitioned

00:21:09,740 --> 00:21:15,169
tolerance that depends if the file

00:21:12,590 --> 00:21:19,460
system was designed to be fast or to be

00:21:15,169 --> 00:21:22,549
more consistent and so on the first and

00:21:19,460 --> 00:21:25,279
probably know very well is dear DVD r DB

00:21:22,549 --> 00:21:27,889
is a block replication doesn't have a

00:21:25,279 --> 00:21:32,570
high scalability it's very good very

00:21:27,889 --> 00:21:34,879
fast but you is more oriented on a

00:21:32,570 --> 00:21:38,299
single service or no to help the

00:21:34,879 --> 00:21:41,450
database to scale and high ability the

00:21:38,299 --> 00:21:44,690
other big advantage of dr DB is to make

00:21:41,450 --> 00:21:49,419
a remote copy and that probably is a

00:21:44,690 --> 00:21:52,759
good solution for disaster recovery site

00:21:49,419 --> 00:21:55,820
but no scalability you make a

00:21:52,759 --> 00:21:58,789
replication of single disc is like to

00:21:55,820 --> 00:22:03,230
have an artwork that may is able to made

00:21:58,789 --> 00:22:05,450
a raid one more interesting i think this

00:22:03,230 --> 00:22:09,559
morning you have seen the saff to data

00:22:05,450 --> 00:22:13,270
set is the factor the storage for cloud

00:22:09,559 --> 00:22:18,730
for visualization system

00:22:13,270 --> 00:22:20,890
is very well designed is a yeah use some

00:22:18,730 --> 00:22:24,070
technique placement light based on hash

00:22:20,890 --> 00:22:26,620
is consistent has a strong consistent

00:22:24,070 --> 00:22:30,280
but also now start to move and we

00:22:26,620 --> 00:22:32,890
consist them to to afford problem on Jo

00:22:30,280 --> 00:22:37,600
replication or long distant connection

00:22:32,890 --> 00:22:41,140
and so on and we can see the head as i

00:22:37,600 --> 00:22:44,440
said hash base has a ruff-ruff is a

00:22:41,140 --> 00:22:48,150
simplified paxus protocol to make an

00:22:44,440 --> 00:22:51,190
election and coordination commit and

00:22:48,150 --> 00:22:53,250
yeah probably you you know better

00:22:51,190 --> 00:22:56,560
because you have seen this morning and

00:22:53,250 --> 00:23:01,080
they start to deploy like concern was

00:22:56,560 --> 00:23:04,120
deployed with three petabyte of data and

00:23:01,080 --> 00:23:08,680
if i remember there are close to eight

00:23:04,120 --> 00:23:11,850
thousand bien running there they start

00:23:08,680 --> 00:23:14,380
to think to replace completely also for

00:23:11,850 --> 00:23:16,660
collect the data of the experiment

00:23:14,380 --> 00:23:19,560
because now is the back end as i said is

00:23:16,660 --> 00:23:22,600
de facto is the back end of the

00:23:19,560 --> 00:23:25,600
openstack and so on but they start to

00:23:22,600 --> 00:23:28,720
thinking to me great also other at the

00:23:25,600 --> 00:23:31,210
project that are more and more has more

00:23:28,720 --> 00:23:36,820
more data i've lived 30 or more petabyte

00:23:31,210 --> 00:23:38,800
of data one of the the implementation

00:23:36,820 --> 00:23:42,310
that is quite know you can understand

00:23:38,800 --> 00:23:45,370
that you can use Seth as a replication

00:23:42,310 --> 00:23:51,180
system to work directly to rat us on OSD

00:23:45,370 --> 00:23:54,340
level is is done by Okeanos is an open

00:23:51,180 --> 00:23:59,560
visualization provider they have set up

00:23:54,340 --> 00:24:02,380
a solution and they use or Seth or

00:23:59,560 --> 00:24:05,130
mainly OSD to make the snapshot

00:24:02,380 --> 00:24:08,140
replication of the mi and start top and

00:24:05,130 --> 00:24:10,720
they at the moment has a good success

00:24:08,140 --> 00:24:15,670
you can see they have more than 5,000

00:24:10,720 --> 00:24:20,470
user and they started more than 250,000

00:24:15,670 --> 00:24:23,380
vm any question on the file system you

00:24:20,470 --> 00:24:25,930
want another another solution that is

00:24:23,380 --> 00:24:27,220
not in the slide is an open FS that is

00:24:25,930 --> 00:24:30,549
more related

00:24:27,220 --> 00:24:33,070
non-content base and cash cash on the

00:24:30,549 --> 00:24:35,309
client side now is they restarted to

00:24:33,070 --> 00:24:40,120
develop they are quite interesting

00:24:35,309 --> 00:24:42,820
development and the big advantage is the

00:24:40,120 --> 00:24:45,549
cash side on the client then reduce the

00:24:42,820 --> 00:24:48,789
transmission based on the persistent

00:24:45,549 --> 00:24:51,280
cash that you have and the notification

00:24:48,789 --> 00:24:54,549
the code back you work on your local

00:24:51,280 --> 00:24:57,250
data and if someone make the change you

00:24:54,549 --> 00:25:00,700
receive a notification that's to avoid

00:24:57,250 --> 00:25:03,370
no data transfer or pulling and so on

00:25:00,700 --> 00:25:06,429
but keep the consistent of the data

00:25:03,370 --> 00:25:08,860
that's quite interesting they have also

00:25:06,429 --> 00:25:11,799
are read-only copy this is more a

00:25:08,860 --> 00:25:16,210
snapshot that you can duplicate volume

00:25:11,799 --> 00:25:24,059
on on on the fly or reelect one volume

00:25:16,210 --> 00:25:27,880
master to to another vm no question ok

00:25:24,059 --> 00:25:31,179
well probably today one of the things

00:25:27,880 --> 00:25:34,870
that doesn't skate at all is the

00:25:31,179 --> 00:25:37,090
database well the database have a big

00:25:34,870 --> 00:25:40,570
constrain have to be consistent then

00:25:37,090 --> 00:25:44,409
it's quite difficult to scale if you

00:25:40,570 --> 00:25:48,490
have done some simulation on for example

00:25:44,409 --> 00:25:50,830
postgres to sync replication with the

00:25:48,490 --> 00:25:54,549
hot standby probably you have seen that

00:25:50,830 --> 00:25:57,730
the performance immediately is cut by

00:25:54,549 --> 00:26:00,250
fifty percent or more for the network

00:25:57,730 --> 00:26:03,250
latency for receive their knowledge on

00:26:00,250 --> 00:26:05,919
the other side then if you want to be

00:26:03,250 --> 00:26:09,159
consistent you don't have solution at

00:26:05,919 --> 00:26:10,929
the moment it is not possible or you or

00:26:09,159 --> 00:26:13,720
better is not possible to have a good

00:26:10,929 --> 00:26:19,900
scalability and to read the same data

00:26:13,720 --> 00:26:21,789
everywhere what thats that means you can

00:26:19,900 --> 00:26:25,360
use in most of the case many node on the

00:26:21,789 --> 00:26:28,150
master level that means you can scale if

00:26:25,360 --> 00:26:30,010
you want to keep you don't scale very

00:26:28,150 --> 00:26:32,210
well if you want to keep the consistent

00:26:30,010 --> 00:26:34,640
of the data

00:26:32,210 --> 00:26:38,030
and mainly the hive abilities based on

00:26:34,640 --> 00:26:39,920
two node because you have problem the

00:26:38,030 --> 00:26:43,220
two main software were the two main

00:26:39,920 --> 00:26:46,760
database that you have today on the

00:26:43,220 --> 00:26:48,170
marker are ya MySQL or MariaDB that

00:26:46,760 --> 00:26:51,530
probably in the future will be more

00:26:48,170 --> 00:26:54,350
mario TBH and an postgres they use two

00:26:51,530 --> 00:26:56,300
different approach because mysql is more

00:26:54,350 --> 00:26:59,600
synchronous on the replication that you

00:26:56,300 --> 00:27:02,390
can connect a lot of slave and this is a

00:26:59,600 --> 00:27:04,610
big advantage because you scale but as i

00:27:02,390 --> 00:27:07,310
said you don't have any insurance you

00:27:04,610 --> 00:27:11,210
don't have any guarantee that this leave

00:27:07,310 --> 00:27:14,230
is up to date in the in the finger kappa

00:27:11,210 --> 00:27:17,720
so you go they introduce a sink

00:27:14,230 --> 00:27:21,650
replication but pay attention a sink

00:27:17,720 --> 00:27:25,850
means that one of the slave send a

00:27:21,650 --> 00:27:28,250
knowledge not all the slave complete

00:27:25,850 --> 00:27:30,470
different story for postgres you can use

00:27:28,250 --> 00:27:35,660
the synchronous but they said you kill

00:27:30,470 --> 00:27:39,020
completed in the performance that seems

00:27:35,660 --> 00:27:41,630
no solution while you can use some

00:27:39,020 --> 00:27:43,700
external tool that tombstone to make the

00:27:41,630 --> 00:27:47,030
replication that increased a lot in the

00:27:43,700 --> 00:27:51,710
condition or I didn't see many

00:27:47,030 --> 00:27:53,540
installation mysql cluster that is main

00:27:51,710 --> 00:27:56,020
memory based know you have a lot of

00:27:53,540 --> 00:27:59,060
limitation but it's multi master and

00:27:56,020 --> 00:28:03,440
I've seen some installation with more

00:27:59,060 --> 00:28:06,980
than one cluster connecting in a ring in

00:28:03,440 --> 00:28:09,890
a different data center the main topic

00:28:06,980 --> 00:28:12,590
is you can write some content and read

00:28:09,890 --> 00:28:14,270
to another one we know you use the micro

00:28:12,590 --> 00:28:16,670
I've seen someone that tried to use the

00:28:14,270 --> 00:28:18,830
database as a bass of communication to

00:28:16,670 --> 00:28:24,350
propagate the information across the

00:28:18,830 --> 00:28:27,530
data center for all this problem no they

00:28:24,350 --> 00:28:31,280
started the most of the people try to

00:28:27,530 --> 00:28:34,220
start how to try to find on alternatives

00:28:31,280 --> 00:28:38,120
and mainly we know these alternatives I

00:28:34,220 --> 00:28:42,200
know SQL but yeah each alternative has a

00:28:38,120 --> 00:28:44,900
specific range a specific topic 22 to

00:28:42,200 --> 00:28:47,740
solve and while probably you can find

00:28:44,900 --> 00:28:51,050
everywhere no you have key babies or

00:28:47,740 --> 00:28:53,630
column store or document-oriented or

00:28:51,050 --> 00:28:55,880
graphically ented because if you do one

00:28:53,630 --> 00:29:00,200
single thing you can do these things

00:28:55,880 --> 00:29:02,090
very very well and in the pond the

00:29:00,200 --> 00:29:05,720
performance i we have seen quite

00:29:02,090 --> 00:29:09,590
incredible things for example the couple

00:29:05,720 --> 00:29:12,590
of i think last year the vault be was

00:29:09,590 --> 00:29:16,040
able to reach 1 million transaction per

00:29:12,590 --> 00:29:17,690
second but obviously that is simple if

00:29:16,040 --> 00:29:21,380
you keep in memory we have seen the

00:29:17,690 --> 00:29:24,410
memories 1 microsecond but anyway that

00:29:21,380 --> 00:29:27,620
that's a grid number also readies and

00:29:24,410 --> 00:29:31,160
that today reduce has a multi master and

00:29:27,620 --> 00:29:38,050
limitation is still beta but also radius

00:29:31,160 --> 00:29:42,800
is able to handle 1 1020 hundred

00:29:38,050 --> 00:29:45,590
transaction with 60,000 client that's

00:29:42,800 --> 00:29:47,390
you can understand immediately why most

00:29:45,590 --> 00:29:49,610
of the people start to use no SQL

00:29:47,390 --> 00:29:52,190
because this number probably you are not

00:29:49,610 --> 00:29:54,950
able to handle in the database but

00:29:52,190 --> 00:29:59,990
obviously is a simple operation get put

00:29:54,950 --> 00:30:04,280
a single data and yet that there is a

00:29:59,990 --> 00:30:07,040
Cassandra react and so on I will talk a

00:30:04,280 --> 00:30:10,490
little bit on react because while I like

00:30:07,040 --> 00:30:15,200
I'm but I think isn't more example for

00:30:10,490 --> 00:30:20,030
what we have seen react like Cassandra

00:30:15,200 --> 00:30:25,010
is more is inspired by dynamodb and is

00:30:20,030 --> 00:30:27,830
based on hash with the ring and has a

00:30:25,010 --> 00:30:31,550
Jew replication that's quite interesting

00:30:27,830 --> 00:30:33,910
and as I said you can define when you

00:30:31,550 --> 00:30:36,620
write the data the consistent

00:30:33,910 --> 00:30:39,920
inconsistent model that you want if you

00:30:36,620 --> 00:30:42,350
want to write three replication and want

00:30:39,920 --> 00:30:46,760
that the know that wrote the proxy that

00:30:42,350 --> 00:30:51,110
wrote for you return only when three was

00:30:46,760 --> 00:30:53,180
frightened and two is ready to no clean

00:30:51,110 --> 00:30:55,929
clothes the connection or the commit

00:30:53,180 --> 00:30:59,409
then for example in this way you can

00:30:55,929 --> 00:31:03,460
for a session to use one read and one

00:30:59,409 --> 00:31:06,340
right but for building data you can use

00:31:03,460 --> 00:31:09,070
three right and three read not to want

00:31:06,340 --> 00:31:12,999
to be completely sure that the data is

00:31:09,070 --> 00:31:16,450
there are or otherwise you make the fall

00:31:12,999 --> 00:31:19,450
that is nice because you can define your

00:31:16,450 --> 00:31:22,919
no level of security that you want from

00:31:19,450 --> 00:31:38,559
the data for the persistent of the data

00:31:22,919 --> 00:31:44,110
yes you can't assign a specified for

00:31:38,559 --> 00:31:46,840
single key this nuttin is not a session

00:31:44,110 --> 00:31:48,940
level or no you can say okay put this

00:31:46,840 --> 00:31:54,249
value but I want the security of three

00:31:48,940 --> 00:31:57,009
element and I have yeah that's me only

00:31:54,249 --> 00:31:59,409
and that yes this is something no that's

00:31:57,009 --> 00:32:01,480
both know we can see in both direction

00:31:59,409 --> 00:32:04,840
the database now try to use as a

00:32:01,480 --> 00:32:08,110
back-end no SQL for some operation but

00:32:04,840 --> 00:32:10,480
we see also know SQL try to be a little

00:32:08,110 --> 00:32:13,139
bit more consistent and as I said now

00:32:10,480 --> 00:32:16,659
the model of the cap okay you can have

00:32:13,139 --> 00:32:19,149
the three element together but I can

00:32:16,659 --> 00:32:21,460
design time by time well when I made

00:32:19,149 --> 00:32:23,559
operation which I want to use what I

00:32:21,460 --> 00:32:28,269
want to be more consistent that I can be

00:32:23,559 --> 00:32:30,970
slower I want to be faster and yeah

00:32:28,269 --> 00:32:34,450
today there is also another trend but

00:32:30,970 --> 00:32:37,090
without many success probably I don't

00:32:34,450 --> 00:32:41,049
know make sense build a file system on

00:32:37,090 --> 00:32:44,409
the top on NoSQL there is yes two men

00:32:41,049 --> 00:32:46,980
approached one fuser that is low and in

00:32:44,409 --> 00:32:50,110
most of the case not well maintained and

00:32:46,980 --> 00:32:51,999
on the other hand export the s3

00:32:50,110 --> 00:32:55,090
interfaced comfortable interface like

00:32:51,999 --> 00:32:57,759
Amazon s3 and this because also in this

00:32:55,090 --> 00:33:00,129
case s3 is more or less de facto the

00:32:57,759 --> 00:33:03,879
interface of the storage or the object

00:33:00,129 --> 00:33:08,250
storage I've seen on on on really has a

00:33:03,879 --> 00:33:11,700
specific application called CS

00:33:08,250 --> 00:33:15,480
we three node you are able to run close

00:33:11,700 --> 00:33:17,310
to 100 megabyte per second and yeah the

00:33:15,480 --> 00:33:19,220
advantage you can know store the node

00:33:17,310 --> 00:33:21,750
where you want in different data center

00:33:19,220 --> 00:33:24,690
not in different regions different

00:33:21,750 --> 00:33:29,940
regions is always a little bit a pain

00:33:24,690 --> 00:33:32,730
also soft sometimes no yeah in case of

00:33:29,940 --> 00:33:35,760
self sometime is nice to use the pool

00:33:32,730 --> 00:33:41,700
cash no and use the week consistent

00:33:35,760 --> 00:33:44,670
otherwise is too slow yes some some you

00:33:41,700 --> 00:33:49,380
can find a lot of implementation example

00:33:44,670 --> 00:33:56,070
I pick up one of volga and they have 50

00:33:49,380 --> 00:33:59,220
million keys they have yeah 50 kilo 13

00:33:56,070 --> 00:34:02,760
50,000 new per day and we have 10

00:33:59,220 --> 00:34:04,680
million per day of update and yes they

00:34:02,760 --> 00:34:07,790
don't have so much but they have two

00:34:04,680 --> 00:34:11,970
hundred thousand requests per minute

00:34:07,790 --> 00:34:14,310
something similar is I was made by New

00:34:11,970 --> 00:34:17,220
York Times they decide to use Cassandra

00:34:14,310 --> 00:34:19,980
mainly they decide because the support

00:34:17,220 --> 00:34:23,520
of multi region is free in the reactor

00:34:19,980 --> 00:34:26,850
multi-region you have to pay and they

00:34:23,520 --> 00:34:30,270
use the Cassandra a kind of a pass to

00:34:26,850 --> 00:34:32,940
push the information to mobile customer

00:34:30,270 --> 00:34:36,510
if there is no new news and so on and

00:34:32,940 --> 00:34:41,159
they have two main installation one

00:34:36,510 --> 00:34:43,379
Europe and one in US based on amazon

00:34:41,159 --> 00:34:46,800
region and you can find some other

00:34:43,379 --> 00:34:50,879
details on the force name of februari of

00:34:46,800 --> 00:34:53,490
this year well what i want to say ok

00:34:50,879 --> 00:34:56,460
sometimes we have seen that you have

00:34:53,490 --> 00:34:59,490
specialized specialized topic drive by

00:34:56,460 --> 00:35:02,220
specialized software then in many case

00:34:59,490 --> 00:35:03,570
you have more than one solution or

00:35:02,220 --> 00:35:06,780
whether you have to put more than one

00:35:03,570 --> 00:35:09,240
solution solution together and that

00:35:06,780 --> 00:35:11,160
means layer well you have to pay

00:35:09,240 --> 00:35:13,200
attention about that because yes you

00:35:11,160 --> 00:35:15,810
reduce a lot of number of their request

00:35:13,200 --> 00:35:17,610
then probably you can use less vm

00:35:15,810 --> 00:35:19,170
because you enters on each layer

00:35:17,610 --> 00:35:22,859
intercept

00:35:19,170 --> 00:35:25,049
and has a hit radio and so on but on the

00:35:22,859 --> 00:35:28,920
other hand you increase the latency if

00:35:25,049 --> 00:35:32,160
you are a web oriented application no

00:35:28,920 --> 00:35:35,160
that's quite good if you are more

00:35:32,160 --> 00:35:37,319
read-only is quite good if you are read

00:35:35,160 --> 00:35:39,390
right you have probably to find some

00:35:37,319 --> 00:35:43,020
shortcut to go directly to the region

00:35:39,390 --> 00:35:46,230
and so on or yeah let's know some

00:35:43,020 --> 00:35:50,400
example is I I don't know if you see

00:35:46,230 --> 00:35:53,430
ebay no that's ebay I'm I don't remember

00:35:50,400 --> 00:35:56,069
if until five minutes you have kind of

00:35:53,430 --> 00:35:58,470
static page or is a refresh every 30

00:35:56,069 --> 00:36:03,210
seconds or every minute but when you are

00:35:58,470 --> 00:36:05,880
close below 25 minutes is updated and

00:36:03,210 --> 00:36:08,220
and the Refresh of the page you are

00:36:05,880 --> 00:36:10,829
redirect probably on the note that has

00:36:08,220 --> 00:36:15,349
the master of the information that's the

00:36:10,829 --> 00:36:18,510
main topic is you have to be close to

00:36:15,349 --> 00:36:23,910
computation and computation completion

00:36:18,510 --> 00:36:26,790
of calculation and yeah try to move the

00:36:23,910 --> 00:36:29,790
master more clothes word activity right

00:36:26,790 --> 00:36:31,859
activity happen because what could be

00:36:29,790 --> 00:36:34,530
the reed is not important but the bright

00:36:31,859 --> 00:36:36,809
and we ya know right could be more

00:36:34,530 --> 00:36:39,240
important there is some algorithm on on

00:36:36,809 --> 00:36:44,780
the locking and an election that can

00:36:39,240 --> 00:36:49,559
move the master of the information if

00:36:44,780 --> 00:36:54,720
you want you can build your replication

00:36:49,559 --> 00:36:58,020
system it's not complicated but well I'm

00:36:54,720 --> 00:37:02,339
not sure is is really needed and we have

00:36:58,020 --> 00:37:04,380
seen though you can use a no SQL to do

00:37:02,339 --> 00:37:07,950
that to replicate some information

00:37:04,380 --> 00:37:14,010
across the data center you can use file

00:37:07,950 --> 00:37:16,349
system and yes everything works quite

00:37:14,010 --> 00:37:18,119
well that I've seen most of the people

00:37:16,349 --> 00:37:21,750
use that you will really need a

00:37:18,119 --> 00:37:24,030
real-time data if you don't probably are

00:37:21,750 --> 00:37:25,710
seeing there is some improvement I've

00:37:24,030 --> 00:37:27,720
seen some improving around that is they

00:37:25,710 --> 00:37:31,710
are able to increase the number of the

00:37:27,720 --> 00:37:35,200
thread use more chords and so on

00:37:31,710 --> 00:37:38,910
sometimes it's difficult to understand

00:37:35,200 --> 00:37:41,830
what is replication what is caching and

00:37:38,910 --> 00:37:43,750
sometimes you need the cash and there

00:37:41,830 --> 00:37:46,480
are some specific product for that we

00:37:43,750 --> 00:37:50,080
didn't talk about varnish but what could

00:37:46,480 --> 00:37:52,960
be a perfect solution you have to

00:37:50,080 --> 00:37:56,440
analyze the life of your data your TTL

00:37:52,960 --> 00:38:00,220
I've seen in the past I we I have a

00:37:56,440 --> 00:38:02,920
million of requests per day and also for

00:38:00,220 --> 00:38:07,090
the content that I have to keep alive

00:38:02,920 --> 00:38:09,940
for one minute with million of requests

00:38:07,090 --> 00:38:13,660
you save a lot of time you save at least

00:38:09,940 --> 00:38:18,940
twenty percent of the request across the

00:38:13,660 --> 00:38:21,970
world but okay if you want what I can

00:38:18,940 --> 00:38:26,170
tell you are okay split in pieces I

00:38:21,970 --> 00:38:28,870
think this is quite simple and track the

00:38:26,170 --> 00:38:31,690
version in this way you can't transfer

00:38:28,870 --> 00:38:35,050
only what you need on what is changed

00:38:31,690 --> 00:38:37,360
and transfer only when you need

00:38:35,050 --> 00:38:40,060
sometimes well sometimes it's good to

00:38:37,360 --> 00:38:42,490
prefetch depends of the load that you

00:38:40,060 --> 00:38:45,070
have if you have a spike load that

00:38:42,490 --> 00:38:46,960
retrieve most of the time dessert the

00:38:45,070 --> 00:38:50,080
same region of data probably is much

00:38:46,960 --> 00:38:54,540
better to made a brief a prefetch or pre

00:38:50,080 --> 00:38:57,970
warming but otherwise wait the request

00:38:54,540 --> 00:39:00,040
if you are able to use notification for

00:38:57,970 --> 00:39:02,830
sures much better to invalidate the cash

00:39:00,040 --> 00:39:08,430
or to notify the change on the data that

00:39:02,830 --> 00:39:08,430
is replicated somewhere move the data

00:39:08,670 --> 00:39:14,800
close as possible to computation no that

00:39:11,950 --> 00:39:18,160
means you reduce the latency to retreat

00:39:14,800 --> 00:39:21,400
the data for computation purpose move

00:39:18,160 --> 00:39:24,160
also the master more clothes on on the

00:39:21,400 --> 00:39:30,280
user or the who start to use the

00:39:24,160 --> 00:39:33,400
information a small trick sometimes is

00:39:30,280 --> 00:39:36,340
to split the counter or did all the data

00:39:33,400 --> 00:39:39,280
for example in in some cases if you have

00:39:36,340 --> 00:39:42,070
some counter and you can split the

00:39:39,280 --> 00:39:43,750
counter that speed up the right because

00:39:42,070 --> 00:39:45,750
the application can choose

00:39:43,750 --> 00:39:49,060
one of the counter that you reduce the

00:39:45,750 --> 00:39:51,730
deadlock or any way that the mood text

00:39:49,060 --> 00:39:54,370
for this information will be you will

00:39:51,730 --> 00:39:58,120
have as low read because you have to

00:39:54,370 --> 00:40:00,390
read all all the counters but in if you

00:39:58,120 --> 00:40:04,300
have application that are more right

00:40:00,390 --> 00:40:08,890
oriented let's give you a very high big

00:40:04,300 --> 00:40:11,320
advantage if you are working the HTTP

00:40:08,890 --> 00:40:14,620
don't forget the e-tag and last modified

00:40:11,320 --> 00:40:18,700
that's if you use Akamai and so on they

00:40:14,620 --> 00:40:21,880
use a lot and you can make some some

00:40:18,700 --> 00:40:24,160
other tricks some prediction for example

00:40:21,880 --> 00:40:27,010
if you have a Content that have one

00:40:24,160 --> 00:40:31,180
minute of TTL and you receive in the

00:40:27,010 --> 00:40:34,270
last ten second of the TTR a request for

00:40:31,180 --> 00:40:36,910
this content probably you can ask to the

00:40:34,270 --> 00:40:40,660
back end through the Otago last modify

00:40:36,910 --> 00:40:43,150
if is change it and make a ring and put

00:40:40,660 --> 00:40:46,060
for another minute because you are so

00:40:43,150 --> 00:40:48,630
close that perhaps in the next minute

00:40:46,060 --> 00:40:53,260
some other we will require this content

00:40:48,630 --> 00:40:57,210
also there are yeah that that that is um

00:40:53,260 --> 00:41:01,630
a small tweak to reduce the traffic and

00:40:57,210 --> 00:41:06,430
try to predict if the content is useful

00:41:01,630 --> 00:41:10,150
or not and if you have to keep in in the

00:41:06,430 --> 00:41:14,080
cash well as I said if you want to write

00:41:10,150 --> 00:41:17,140
I've wrote a small file system based on

00:41:14,080 --> 00:41:19,690
most of the things that I said and it's

00:41:17,140 --> 00:41:22,000
funny no I have to say that is very

00:41:19,690 --> 00:41:24,130
funny and very nice you challenge with a

00:41:22,000 --> 00:41:26,620
lot of problem especially when you have

00:41:24,130 --> 00:41:30,070
to remain replication between the two

00:41:26,620 --> 00:41:34,720
side of the world i divided the problem

00:41:30,070 --> 00:41:39,490
and while most of the the topics are was

00:41:34,720 --> 00:41:43,000
were covered by the distort in five

00:41:39,490 --> 00:41:46,480
element divide the data from the

00:41:43,000 --> 00:41:48,850
metadata try to keep in separate element

00:41:46,480 --> 00:41:52,240
separate connection parallel operation

00:41:48,850 --> 00:41:55,750
keep track of everything make

00:41:52,240 --> 00:41:56,310
compression reduce the the transmission

00:41:55,750 --> 00:41:59,100
and

00:41:56,310 --> 00:42:02,730
and so on that you can download

00:41:59,100 --> 00:42:06,090
somewhere and part of the rest of s I

00:42:02,730 --> 00:42:10,410
probably in a couple of month I have

00:42:06,090 --> 00:42:13,770
also a small block data replication

00:42:10,410 --> 00:42:16,110
multiple node because yes there are a

00:42:13,770 --> 00:42:18,660
lot of tool but as simple a simple to

00:42:16,110 --> 00:42:22,350
that you put a block of data and this is

00:42:18,660 --> 00:42:26,040
spread around doesn't exist for me was

00:42:22,350 --> 00:42:29,100
useful then I've wrote that and we be

00:42:26,040 --> 00:42:33,030
open source quite soon but you can do

00:42:29,100 --> 00:42:37,710
the same things the main concept was

00:42:33,030 --> 00:42:41,370
okay hash content hash base the the

00:42:37,710 --> 00:42:43,590
placement I use zeromq for the

00:42:41,370 --> 00:42:45,990
transmission protocol that means you

00:42:43,590 --> 00:42:49,260
have to you reduce the effort to write

00:42:45,990 --> 00:42:52,200
your protocol and the handle all the

00:42:49,260 --> 00:42:54,810
connection i use the gossip protocol to

00:42:52,200 --> 00:42:58,170
make the election of the node for the

00:42:54,810 --> 00:43:00,660
replication and orbital to detect the

00:42:58,170 --> 00:43:03,090
node and also in this case you can

00:43:00,660 --> 00:43:09,170
decide how many element you want to

00:43:03,090 --> 00:43:11,910
write or read that's this is the last

00:43:09,170 --> 00:43:15,770
position of mine but i believe is quite

00:43:11,910 --> 00:43:15,770
true and any question

00:43:24,300 --> 00:43:32,500
just one regarding this no SQL databases

00:43:28,420 --> 00:43:35,200
I was wondering how how do you backup

00:43:32,500 --> 00:43:38,560
and restore such distributed systems

00:43:35,200 --> 00:43:41,200
consider in a consistent manner yeah

00:43:38,560 --> 00:43:46,480
this is one of the the problem and for

00:43:41,200 --> 00:43:50,380
example in react you have the the region

00:43:46,480 --> 00:43:54,010
has to to wait where one is continuously

00:43:50,380 --> 00:43:58,180
and one in a certain way is create a

00:43:54,010 --> 00:44:01,570
snapshot but yes sometimes it's a

00:43:58,180 --> 00:44:04,900
problem to create as some SQL has a

00:44:01,570 --> 00:44:06,670
versioning then you can freeze to the

00:44:04,900 --> 00:44:10,030
versioning know you have a version of

00:44:06,670 --> 00:44:13,810
the object but yeah that's that's mainly

00:44:10,030 --> 00:44:17,980
one of the topics that's one on long

00:44:13,810 --> 00:44:20,320
storage retention program but yet

00:44:17,980 --> 00:44:23,160
depends of also in this case depend of

00:44:20,320 --> 00:44:27,390
the solution each element has different

00:44:23,160 --> 00:44:30,400
solution and if you have a versioning

00:44:27,390 --> 00:44:34,090
know you will chef's you create snapshot

00:44:30,400 --> 00:44:39,240
and so on others create the snapshot of

00:44:34,090 --> 00:44:42,370
the metadata where you have the hash

00:44:39,240 --> 00:44:44,200
that's that's in some cases important to

00:44:42,370 --> 00:44:47,290
have the metadata database dump it

00:44:44,200 --> 00:44:51,070
because the data is on the node and stay

00:44:47,290 --> 00:44:52,720
for quite a while and from the data and

00:44:51,070 --> 00:44:55,840
metadata information you can retrieve

00:44:52,720 --> 00:44:58,780
and create the damn others yes made them

00:44:55,840 --> 00:45:02,440
for each node but yet the consistent of

00:44:58,780 --> 00:45:07,180
the data is a problem yet the version is

00:45:02,440 --> 00:45:09,640
mainly is multi version and so on should

00:45:07,180 --> 00:45:13,660
be the best solution but depends depends

00:45:09,640 --> 00:45:17,100
on the of the database of no SQL someone

00:45:13,660 --> 00:45:17,100
someone doesn't have any solution

00:45:17,349 --> 00:45:19,410
you

00:45:28,520 --> 00:45:30,580

YouTube URL: https://www.youtube.com/watch?v=ci1m9fRHfHw


