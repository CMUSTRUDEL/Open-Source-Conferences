Title: OSDC 2019: Feature Branching considered Evil by Thierry de Pauw
Publication date: 2019-05-21
Playlist: OSDC 2019 | Open Source Data Center Conference
Description: 
	With DVCSs, branch creation became very easy, but it comes at a certain cost. Long living branches break the flow of the software delivery process, impacting stability and throughput. The session explores why teams are using feature branches, what problems are introduced by using them and what techniques exist to avoid them altogether. It explores exactly what’s evil about feature branches, which is not necessarily the problems they introduce – but rather, the real reasons why teams are using them. After the session, you’ll understand a different branching strategy and how it relates to CI/CD.

NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de
Blog: http://blog.netways.de
Webinare: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh

https://www.frametraxx.de/
Captions: 
	00:00:01,140 --> 00:00:10,550
[Music]

00:00:14,040 --> 00:00:20,640
[Applause]

00:00:15,859 --> 00:00:24,689
all right thank you for being here so my

00:00:20,640 --> 00:00:27,630
name is chicky I have a software

00:00:24,689 --> 00:00:29,760
engineering background so being at this

00:00:27,630 --> 00:00:35,399
conference is completely out of my

00:00:29,760 --> 00:00:37,380
comfort zone but while around 2012 I

00:00:35,399 --> 00:00:40,800
stumbled into continuous delivery and

00:00:37,380 --> 00:00:46,770
ever since then I've became a CI and CD

00:00:40,800 --> 00:00:48,780
advocate and that will be what I'm going

00:00:46,770 --> 00:00:50,550
to say about myself because I don't like

00:00:48,780 --> 00:00:52,800
to speak about myself and at the end

00:00:50,550 --> 00:00:59,640
there will be a slight presenting myself

00:00:52,800 --> 00:01:02,489
so let's move on so somewhere in 2012 I

00:00:59,640 --> 00:01:05,339
had the opportunity to start a coaching

00:01:02,489 --> 00:01:09,060
mission technical coaching mission to AB

00:01:05,339 --> 00:01:11,850
skill the engineering skills of a Rawdon

00:01:09,060 --> 00:01:16,170
office team inside of a very waterfall

00:01:11,850 --> 00:01:18,720
organization now when I say novice it's

00:01:16,170 --> 00:01:20,790
really from an engineering point of view

00:01:18,720 --> 00:01:22,830
from a skills perspective not really

00:01:20,790 --> 00:01:25,470
from a working experience perspective

00:01:22,830 --> 00:01:28,020
because the team had working experience

00:01:25,470 --> 00:01:29,700
ranging from 10 years to 20 years they

00:01:28,020 --> 00:01:31,590
just didn't have the luxury to go to

00:01:29,700 --> 00:01:33,720
conferences like this one or to work

00:01:31,590 --> 00:01:35,670
with people that showed them different

00:01:33,720 --> 00:01:38,759
ways of working and luckily I wasn't

00:01:35,670 --> 00:01:42,570
alone doing this coaching which is very

00:01:38,759 --> 00:01:44,579
reassuring we were the two of us and it

00:01:42,570 --> 00:01:46,649
really helps especially when you have to

00:01:44,579 --> 00:01:48,600
introduce lots of change in front of

00:01:46,649 --> 00:01:51,950
people that have lots of working

00:01:48,600 --> 00:01:55,470
experience and that our rod is skeptical

00:01:51,950 --> 00:01:57,210
so when I arrived there well we

00:01:55,470 --> 00:01:59,159
discovered the situation we weren't

00:01:57,210 --> 00:02:02,430
quite expecting to still discover in

00:01:59,159 --> 00:02:04,290
2012 so no one in the team except for

00:02:02,430 --> 00:02:06,299
one person was using any version control

00:02:04,290 --> 00:02:10,229
system Yeah right

00:02:06,299 --> 00:02:11,700
2012 now recently in 2018 I discovered

00:02:10,229 --> 00:02:13,620
that they are still teams not using

00:02:11,700 --> 00:02:17,519
version control systems so

00:02:13,620 --> 00:02:19,019
yeah so first thing that we did was well

00:02:17,519 --> 00:02:22,349
introduce version control system

00:02:19,019 --> 00:02:24,209
obviously and because the team was

00:02:22,349 --> 00:02:25,860
nervous had no experience using any

00:02:24,209 --> 00:02:28,410
version control systems while we thought

00:02:25,860 --> 00:02:30,780
that using it would be a bridge too far

00:02:28,410 --> 00:02:33,180
it's just too many concepts you have to

00:02:30,780 --> 00:02:36,180
grasp and so we went for the safer

00:02:33,180 --> 00:02:38,340
solution and we went for subversion it's

00:02:36,180 --> 00:02:40,500
more easy to understand you only have

00:02:38,340 --> 00:02:44,160
three concepts you check out code modify

00:02:40,500 --> 00:02:46,049
it check it in it's fairly easy now

00:02:44,160 --> 00:02:48,900
because it was also said at the time

00:02:46,049 --> 00:02:49,739
that branching was rather painful with

00:02:48,900 --> 00:02:53,880
subversion

00:02:49,739 --> 00:02:56,340
although easier than with CVS but still

00:02:53,880 --> 00:02:59,129
more painful than we get we also decided

00:02:56,340 --> 00:03:01,610
to use no branching at all everyone was

00:02:59,129 --> 00:03:04,049
going to commit immediately into tranq

00:03:01,610 --> 00:03:05,549
and that worked pretty well

00:03:04,049 --> 00:03:07,049
because what was a second thing we

00:03:05,549 --> 00:03:08,610
introduced right from the start and the

00:03:07,049 --> 00:03:15,420
toast continuous integration together

00:03:08,610 --> 00:03:19,819
with the team commitment that any change

00:03:15,420 --> 00:03:23,609
had to be covered by automated tests now

00:03:19,819 --> 00:03:25,739
at the time I absolutely didn't know

00:03:23,609 --> 00:03:27,840
that this was a valid branching strategy

00:03:25,739 --> 00:03:29,280
and that this thing actually had a name

00:03:27,840 --> 00:03:31,139
and that it was called training base

00:03:29,280 --> 00:03:34,980
development it's only years later that I

00:03:31,139 --> 00:03:38,010
discovered that now didn't mean that

00:03:34,980 --> 00:03:39,900
drink was never broken well look it was

00:03:38,010 --> 00:03:42,959
a novice team and in the beginning drink

00:03:39,900 --> 00:03:44,549
was often broken but it wasn't really a

00:03:42,959 --> 00:03:46,349
problem because we had this continuous

00:03:44,549 --> 00:03:48,569
integration in place we had enough

00:03:46,349 --> 00:03:51,000
automated tests that allowed us to

00:03:48,569 --> 00:03:53,459
discover problems early and to fix them

00:03:51,000 --> 00:03:58,139
while the world is still small and easy

00:03:53,459 --> 00:04:00,870
to fix now after a year or two went in

00:03:58,139 --> 00:04:02,940
team had more maturity and more

00:04:00,870 --> 00:04:04,980
experience using version control system

00:04:02,940 --> 00:04:08,040
so we taught it as a time to migrate to

00:04:04,980 --> 00:04:10,260
get and the main reason for that was

00:04:08,040 --> 00:04:12,060
well dressed more tooling available to

00:04:10,260 --> 00:04:16,139
manage get repos and the team had to

00:04:12,060 --> 00:04:17,489
manage quite some git repos and and we

00:04:16,139 --> 00:04:19,829
wanted to introduce the full request

00:04:17,489 --> 00:04:21,719
model for code reviews and obviously for

00:04:19,829 --> 00:04:23,700
pull requests while you need branches

00:04:21,719 --> 00:04:25,060
and we want to be able to create

00:04:23,700 --> 00:04:30,080
branches easily

00:04:25,060 --> 00:04:31,970
now like with all powerful tools there

00:04:30,080 --> 00:04:35,840
are many ways you can use them and not

00:04:31,970 --> 00:04:38,360
all of them are right and here Jess

00:04:35,840 --> 00:04:40,030
refers to the use of feature branching

00:04:38,360 --> 00:04:42,640
and the fact that proponents of

00:04:40,030 --> 00:04:44,750
distributed version control systems and

00:04:42,640 --> 00:04:46,790
use feature branching to sell

00:04:44,750 --> 00:04:48,200
distributed version control systems and

00:04:46,790 --> 00:04:50,420
together with all the tooling that

00:04:48,200 --> 00:04:52,910
exists around distributed version

00:04:50,420 --> 00:04:55,850
control systems and that push to the use

00:04:52,910 --> 00:04:58,190
of branching well it makes everyone

00:04:55,850 --> 00:05:00,170
blind for the problems that arise from

00:04:58,190 --> 00:05:01,790
the use of feature branching and and

00:05:00,170 --> 00:05:05,720
with that team we've had those problems

00:05:01,790 --> 00:05:07,940
quite hard and we try to find solutions

00:05:05,720 --> 00:05:09,860
by introducing even more complex

00:05:07,940 --> 00:05:11,780
technology and having more complex

00:05:09,860 --> 00:05:14,780
processes but in the end it doesn't

00:05:11,780 --> 00:05:17,210
really solve our problems except that it

00:05:14,780 --> 00:05:19,820
introduced more complexity and so we

00:05:17,210 --> 00:05:21,650
said together and we just decided to let

00:05:19,820 --> 00:05:23,150
go on the branches and we went back to

00:05:21,650 --> 00:05:24,650
what worked for us and it was during

00:05:23,150 --> 00:05:29,180
this development and we never looked

00:05:24,650 --> 00:05:31,700
back after that mission I had the

00:05:29,180 --> 00:05:33,680
opportunity to start a new mission in a

00:05:31,700 --> 00:05:36,080
totally different organization quite

00:05:33,680 --> 00:05:37,970
agile working with highly skilled

00:05:36,080 --> 00:05:41,300
software engineers with lots of

00:05:37,970 --> 00:05:44,240
experience but they decided to use git

00:05:41,300 --> 00:05:45,820
flow as a branching strategy and when I

00:05:44,240 --> 00:05:50,930
arrived there

00:05:45,820 --> 00:05:53,510
well Rangers were living between five to

00:05:50,930 --> 00:05:55,610
ten days we even had branches that left

00:05:53,510 --> 00:05:56,570
for 40 days with all the problems that

00:05:55,610 --> 00:05:58,760
came with that

00:05:56,570 --> 00:06:01,750
having to rebase all the time every day

00:05:58,760 --> 00:06:04,010
having to fix merge conflicts every day

00:06:01,750 --> 00:06:07,100
making sure that you only started

00:06:04,010 --> 00:06:09,440
working on valuable work at noon so well

00:06:07,100 --> 00:06:13,610
lots of time was lost and so when I saw

00:06:09,440 --> 00:06:15,950
that well I suggested look shouldn't we

00:06:13,610 --> 00:06:19,220
try out trim base development I had a

00:06:15,950 --> 00:06:21,770
quite good experience now trying to

00:06:19,220 --> 00:06:23,780
convince people of the benefits of

00:06:21,770 --> 00:06:25,610
training base development is really not

00:06:23,780 --> 00:06:27,740
an overnight task every time I suggest

00:06:25,610 --> 00:06:30,290
this and especially in front of very

00:06:27,740 --> 00:06:33,560
experienced people I always get the same

00:06:30,290 --> 00:06:37,610
reaction it's like people stare at me

00:06:33,560 --> 00:06:38,990
like I'm a stupid person morin like well

00:06:37,610 --> 00:06:41,509
why should we do that

00:06:38,990 --> 00:06:43,039
are you insane are you suggesting that

00:06:41,509 --> 00:06:45,289
everyone is going to commit on own

00:06:43,039 --> 00:06:46,850
master it's going to be a mess we'll

00:06:45,289 --> 00:06:48,889
have merge conflicts all over the place

00:06:46,850 --> 00:06:50,720
and and and and the whole industry is

00:06:48,889 --> 00:06:51,910
using some sort of branching strategy so

00:06:50,720 --> 00:06:57,319
so so why change

00:06:51,910 --> 00:06:59,990
so although trying base development as

00:06:57,319 --> 00:07:02,389
implied by the use of continuous

00:06:59,990 --> 00:07:06,250
integration and although the state of

00:07:02,389 --> 00:07:08,300
DevOps reports report since 2015 that

00:07:06,250 --> 00:07:10,250
organizations that adopt ring based

00:07:08,300 --> 00:07:14,349
development are high-performing IT

00:07:10,250 --> 00:07:17,509
organizations and although we we have

00:07:14,349 --> 00:07:21,259
companies like Google and Facebook and

00:07:17,509 --> 00:07:23,479
Netflix and Microsoft that are doing

00:07:21,259 --> 00:07:26,780
train based development at very very

00:07:23,479 --> 00:07:30,229
large scale it is still one of demos

00:07:26,780 --> 00:07:33,800
confer the most controversial practices

00:07:30,229 --> 00:07:36,229
in the agile community and so I failed I

00:07:33,800 --> 00:07:38,330
miserably failed and trying to get that

00:07:36,229 --> 00:07:42,020
organization just to run an experiment

00:07:38,330 --> 00:07:46,550
to try out ring base development and so

00:07:42,020 --> 00:07:48,099
while I decided to well let's see let's

00:07:46,550 --> 00:07:50,630
see what happens when an organization

00:07:48,099 --> 00:07:55,580
uses a branching strategy and and this

00:07:50,630 --> 00:07:58,250
resulted in this presentation now before

00:07:55,580 --> 00:08:00,229
we move on I want to reintroduce some

00:07:58,250 --> 00:08:02,180
definitions and I'm sure you know know

00:08:00,229 --> 00:08:05,030
this but well like with everything in

00:08:02,180 --> 00:08:08,360
our in our industry well people tend to

00:08:05,030 --> 00:08:11,270
modify definitions so that they they

00:08:08,360 --> 00:08:12,440
adapt to their context so to make sure

00:08:11,270 --> 00:08:15,949
we are all aligned

00:08:12,440 --> 00:08:17,870
I'm reintroducing these the first one is

00:08:15,949 --> 00:08:21,650
well what is the main line so Main Line

00:08:17,870 --> 00:08:24,139
is the line of development that acts as

00:08:21,650 --> 00:08:26,270
your reference from where bills are

00:08:24,139 --> 00:08:29,330
created and that are fed into your

00:08:26,270 --> 00:08:31,280
deployment pipeline so forget this is

00:08:29,330 --> 00:08:34,490
master for mercurial this is a default

00:08:31,280 --> 00:08:38,599
branch and for subversion and CVS this

00:08:34,490 --> 00:08:40,310
is trick what is a feature branch or

00:08:38,599 --> 00:08:42,260
what is feature branching well it's a

00:08:40,310 --> 00:08:44,510
practice where people do not merge their

00:08:42,260 --> 00:08:47,420
work back into mainline until the

00:08:44,510 --> 00:08:50,510
feature they are working on is done but

00:08:47,420 --> 00:08:52,339
not yet done done so it's done means

00:08:50,510 --> 00:08:52,850
it's def complete but there is still a

00:08:52,339 --> 00:08:55,190
lot of

00:08:52,850 --> 00:08:56,930
to be done before it gets deployed into

00:08:55,190 --> 00:08:58,850
production and release to the end-users

00:08:56,930 --> 00:09:01,250
so you have to create a new belt you

00:08:58,850 --> 00:09:02,709
have to reload all the automated tests

00:09:01,250 --> 00:09:05,480
again you have to run all the

00:09:02,709 --> 00:09:07,910
performance tests all the security tests

00:09:05,480 --> 00:09:09,350
you have to perform manual exploratory

00:09:07,910 --> 00:09:11,060
tests then you can deploy into

00:09:09,350 --> 00:09:12,829
production you have to perform your

00:09:11,060 --> 00:09:16,519
smoke smoke test and then you can

00:09:12,829 --> 00:09:17,930
release to your end-users so when we

00:09:16,519 --> 00:09:19,699
speak about feature branching we are

00:09:17,930 --> 00:09:21,410
really speaking about long-running

00:09:19,699 --> 00:09:26,779
branches so branches that live for

00:09:21,410 --> 00:09:28,819
longer than a day what is continuous

00:09:26,779 --> 00:09:31,670
integration well it's a practice where

00:09:28,819 --> 00:09:34,670
everyone in the team and integrates

00:09:31,670 --> 00:09:37,459
their work at least once a day leading

00:09:34,670 --> 00:09:39,730
to multiple integrations per day for the

00:09:37,459 --> 00:09:43,009
whole team and every integration is

00:09:39,730 --> 00:09:45,680
validated by an automated build that

00:09:43,009 --> 00:09:48,620
executes all your automated tests so

00:09:45,680 --> 00:09:50,750
it's a practice that ensures that you

00:09:48,620 --> 00:09:52,339
always have working software on main

00:09:50,750 --> 00:09:54,410
line and that gives you feedback within

00:09:52,339 --> 00:09:56,930
minutes whether a change broke the

00:09:54,410 --> 00:09:59,089
application or not so this means

00:09:56,930 --> 00:10:01,730
everyone on the team commits at least

00:09:59,089 --> 00:10:03,819
once a day in to master that every

00:10:01,730 --> 00:10:06,079
commit triggers an automated build and

00:10:03,819 --> 00:10:07,850
execution of your automated tests and

00:10:06,079 --> 00:10:10,970
that whenever that the build fails it

00:10:07,850 --> 00:10:13,610
gets fixed within 10 minutes and easiest

00:10:10,970 --> 00:10:16,699
way to fix a broken build is just to

00:10:13,610 --> 00:10:19,459
revert back to the last known good state

00:10:16,699 --> 00:10:24,019
so you just remove the commit that broke

00:10:19,459 --> 00:10:28,579
the belt it's harsh well you don't want

00:10:24,019 --> 00:10:30,500
to block a whole team now continuous

00:10:28,579 --> 00:10:32,870
integration is really a practice you

00:10:30,500 --> 00:10:34,790
don't need a lot of tooling for this so

00:10:32,870 --> 00:10:37,370
the only thing you need is a version

00:10:34,790 --> 00:10:39,130
control system and an automated build

00:10:37,370 --> 00:10:41,630
and that's it

00:10:39,130 --> 00:10:43,490
James Shaw wrote a very good article

00:10:41,630 --> 00:10:45,829
about that it's called continuous

00:10:43,490 --> 00:10:49,449
integration on a dollar a day and it's

00:10:45,829 --> 00:10:51,769
very funny it's a it's fun to read and

00:10:49,449 --> 00:10:53,420
lastly well what is the goal of an

00:10:51,769 --> 00:10:56,350
organization well the goal of an

00:10:53,420 --> 00:10:59,810
organization is well is to make money or

00:10:56,350 --> 00:11:01,970
they're definitely to sustainably reduce

00:10:59,810 --> 00:11:04,339
your your lead time in order to create

00:11:01,970 --> 00:11:06,770
to create positive business impact and

00:11:04,339 --> 00:11:09,230
positive business impact as well

00:11:06,770 --> 00:11:12,200
either you generate money this is your

00:11:09,230 --> 00:11:14,090
turnover or you protect your money this

00:11:12,200 --> 00:11:17,240
is being ahead of your competition or

00:11:14,090 --> 00:11:19,340
you save money this is your cost savings

00:11:17,240 --> 00:11:21,080
now you want to reduce this lead time

00:11:19,340 --> 00:11:23,000
because you want to have feedback as

00:11:21,080 --> 00:11:25,460
soon as possible you want to know as

00:11:23,000 --> 00:11:27,200
soon as possible if the thing you have

00:11:25,460 --> 00:11:29,900
deployed into production is actually

00:11:27,200 --> 00:11:32,510
being used by your users and how it is

00:11:29,900 --> 00:11:34,640
being used by your users and well based

00:11:32,510 --> 00:11:37,640
on this information while you can decide

00:11:34,640 --> 00:11:39,800
to renew experiments to find new ways on

00:11:37,640 --> 00:11:44,330
how to delight your customers which is a

00:11:39,800 --> 00:11:46,400
huge competitive advantage now before I

00:11:44,330 --> 00:11:50,270
could I'm suggesting base development

00:11:46,400 --> 00:11:52,370
again I had to understand why teams are

00:11:50,270 --> 00:11:54,080
using feature branches what problems are

00:11:52,370 --> 00:11:56,780
they trying to solve with this and so I

00:11:54,080 --> 00:11:58,670
asked around and especially I've asked

00:11:56,780 --> 00:12:01,130
proponents of feature branching why they

00:11:58,670 --> 00:12:04,280
are using them and I got several reasons

00:12:01,130 --> 00:12:07,490
and I want to share fortune with you the

00:12:04,280 --> 00:12:10,130
first one was well it allows us to work

00:12:07,490 --> 00:12:13,430
in isolation and therefore we are more

00:12:10,130 --> 00:12:16,220
productive and this seems very fair and

00:12:13,430 --> 00:12:19,040
very obvious but what we are in fact

00:12:16,220 --> 00:12:21,590
doing here is optimizing for individual

00:12:19,040 --> 00:12:24,260
developer productivity now we all know

00:12:21,590 --> 00:12:27,260
that software products are rarely the

00:12:24,260 --> 00:12:28,820
result of the work of one person it's

00:12:27,260 --> 00:12:31,040
most of the time it's the result of the

00:12:28,820 --> 00:12:34,310
work of a whole team and so your team

00:12:31,040 --> 00:12:36,320
will only go as fast as your slowest

00:12:34,310 --> 00:12:38,450
merge so as long as you haven't merged

00:12:36,320 --> 00:12:41,840
back into mainline why you simply don't

00:12:38,450 --> 00:12:44,390
know how much work is left to do because

00:12:41,840 --> 00:12:46,790
of potential merge conflicts potential

00:12:44,390 --> 00:12:49,160
rework at merge time and so this makes

00:12:46,790 --> 00:12:51,110
integrating changes into mainline very

00:12:49,160 --> 00:12:53,420
time-consuming and very unpredictable

00:12:51,110 --> 00:12:56,060
which makes your whole software delivery

00:12:53,420 --> 00:12:58,700
process very unpredictable which will

00:12:56,060 --> 00:13:00,530
obviously impact your lead time and your

00:12:58,700 --> 00:13:02,540
time to market and remember the goal of

00:13:00,530 --> 00:13:04,970
your organization is to sustainably

00:13:02,540 --> 00:13:06,620
reduce the lead time and to create

00:13:04,970 --> 00:13:09,320
positive business impact and here we are

00:13:06,620 --> 00:13:11,270
doing quite the opposite so instead of

00:13:09,320 --> 00:13:13,190
optimizing for NVIDIA developer

00:13:11,270 --> 00:13:15,740
productivity you should optimize for

00:13:13,190 --> 00:13:18,470
team productivity and choose a team

00:13:15,740 --> 00:13:23,570
oriented ranging strategy

00:13:18,470 --> 00:13:26,180
like during this development second

00:13:23,570 --> 00:13:28,640
reason I got was well if you have a

00:13:26,180 --> 00:13:30,380
refactoring that is going nowhere while

00:13:28,640 --> 00:13:32,870
we can just delete it by deleting the

00:13:30,380 --> 00:13:36,320
remove branch and again this seems very

00:13:32,870 --> 00:13:38,530
obvious but what I think they are trying

00:13:36,320 --> 00:13:40,850
to say is look we have this problem

00:13:38,530 --> 00:13:43,330
where we don't know the solution right

00:13:40,850 --> 00:13:49,160
away and so we are just trying something

00:13:43,330 --> 00:13:51,650
hoping that after a series of commits we

00:13:49,160 --> 00:13:54,290
get to a solution somewhere and if we

00:13:51,650 --> 00:13:55,880
don't well we can just remove it now if

00:13:54,290 --> 00:13:58,250
you don't know the solution to a problem

00:13:55,880 --> 00:14:00,650
right away why not spotting some ideas

00:13:58,250 --> 00:14:04,250
and this is the purpose of a spike it's

00:14:00,650 --> 00:14:07,610
to write throw away code to test an idea

00:14:04,250 --> 00:14:10,130
and the output of a spike is not

00:14:07,610 --> 00:14:13,820
production code the output of spike is

00:14:10,130 --> 00:14:16,160
really knowledge creation and so after a

00:14:13,820 --> 00:14:18,980
couple of hours you should know if an

00:14:16,160 --> 00:14:21,680
idea worked out or not if it didn't work

00:14:18,980 --> 00:14:25,090
out or no problem throw away your code

00:14:21,680 --> 00:14:27,470
and try another idea if it did work out

00:14:25,090 --> 00:14:30,200
fantastic you found the solution to your

00:14:27,470 --> 00:14:33,860
problem again you can throw away your

00:14:30,200 --> 00:14:36,170
code why we just had the solution well

00:14:33,860 --> 00:14:38,720
yeah but you didn't write it with

00:14:36,170 --> 00:14:41,180
production in mind so throw it away

00:14:38,720 --> 00:14:43,580
start over again use the knowledge that

00:14:41,180 --> 00:14:48,980
you have created but this time implement

00:14:43,580 --> 00:14:51,170
it in small incremental steps third

00:14:48,980 --> 00:14:52,490
reason I got was well it allows us to

00:14:51,170 --> 00:14:57,440
control the quality of what goes into

00:14:52,490 --> 00:14:59,690
production meaning only features that

00:14:57,440 --> 00:15:03,290
went successfully through a gating

00:14:59,690 --> 00:15:05,770
process called a code review get into

00:15:03,290 --> 00:15:10,160
master and a search get into production

00:15:05,770 --> 00:15:11,960
now in my opinion well that's why we

00:15:10,160 --> 00:15:15,410
have continuous integration and

00:15:11,960 --> 00:15:17,900
continuous delivery in place the purpose

00:15:15,410 --> 00:15:20,120
is to eliminate bad release candidates

00:15:17,900 --> 00:15:22,040
as soon as possible and only changes

00:15:20,120 --> 00:15:24,320
that when successfully through all

00:15:22,040 --> 00:15:25,880
stages of your pipeline get deployed

00:15:24,320 --> 00:15:27,710
into production and release to you

00:15:25,880 --> 00:15:30,080
end-users so in my opinion this is the

00:15:27,710 --> 00:15:32,120
most effective way to control the

00:15:30,080 --> 00:15:37,410
quality of what goes into production

00:15:32,120 --> 00:15:39,690
and lastly it allows us to control which

00:15:37,410 --> 00:15:41,550
features get into production or more

00:15:39,690 --> 00:15:43,800
specifically it allows us to prevent

00:15:41,550 --> 00:15:45,300
that unfinished functionality gets into

00:15:43,800 --> 00:15:46,589
protection because unfinished

00:15:45,300 --> 00:15:48,509
functionality are sitting on the

00:15:46,589 --> 00:15:50,519
branches and as long as they are not

00:15:48,509 --> 00:15:53,550
merged into mainline while they don't

00:15:50,519 --> 00:15:56,790
get deployed into production now what we

00:15:53,550 --> 00:15:59,759
are in fact doing here is using our

00:15:56,790 --> 00:16:02,430
version control system to turn features

00:15:59,759 --> 00:16:04,589
on and off and through manual merging

00:16:02,430 --> 00:16:08,009
which is just a poor-man's modular

00:16:04,589 --> 00:16:09,959
architecture instead of using our

00:16:08,009 --> 00:16:11,790
version control system as a toggling

00:16:09,959 --> 00:16:14,009
mechanism while we should design our

00:16:11,790 --> 00:16:16,290
systems in such a way that we can

00:16:14,009 --> 00:16:21,110
actually turn features on and off very

00:16:16,290 --> 00:16:21,110
easily at runtime or at deploy time

00:16:29,660 --> 00:16:35,240
now why is this a problem why is using

00:16:32,240 --> 00:16:38,180
feature branches a problem well first of

00:16:35,240 --> 00:16:40,040
all it delays feedback as long as you

00:16:38,180 --> 00:16:43,610
haven't integrated your work into

00:16:40,040 --> 00:16:45,050
mainline you don't get any feedback on

00:16:43,610 --> 00:16:48,580
whether your changes broke the

00:16:45,050 --> 00:16:52,100
application or not it's just the minute

00:16:48,580 --> 00:16:54,880
when you integrate that your CI process

00:16:52,100 --> 00:16:56,810
gets triggered and the delay in feedback

00:16:54,880 --> 00:16:58,730
increases with the duration of your

00:16:56,810 --> 00:16:59,990
branch so if your branch lives for

00:16:58,730 --> 00:17:01,700
couple of hours you are delaying

00:16:59,990 --> 00:17:03,230
feedback for a couple of hours if it

00:17:01,700 --> 00:17:04,910
lives for a couple of days you are

00:17:03,230 --> 00:17:08,510
delaying feedback for a couple of days

00:17:04,910 --> 00:17:11,480
now many teams are redefining continuous

00:17:08,510 --> 00:17:13,730
integration by saying well look we have

00:17:11,480 --> 00:17:18,920
our Jenkins running against all of our

00:17:13,730 --> 00:17:21,380
branches Wow that's very good having you

00:17:18,920 --> 00:17:23,270
know automated build running against all

00:17:21,380 --> 00:17:26,540
your branches is actually very very good

00:17:23,270 --> 00:17:28,670
but it isn't continuous integration the

00:17:26,540 --> 00:17:32,900
only feedback that you get is whether

00:17:28,670 --> 00:17:34,760
your changes well broke the code that

00:17:32,900 --> 00:17:37,070
exists in the isolated branch and

00:17:34,760 --> 00:17:39,500
whether you introduce any regressions

00:17:37,070 --> 00:17:41,270
against the tests that exist inside this

00:17:39,500 --> 00:17:43,970
isolated branch you don't get any

00:17:41,270 --> 00:17:45,950
feedback on how these changes integrate

00:17:43,970 --> 00:17:48,590
with all the changes that exist in all

00:17:45,950 --> 00:17:51,920
the other branches so from this moment

00:17:48,590 --> 00:17:53,360
on ci doesn't stand for continuous

00:17:51,920 --> 00:17:56,030
integration that stands for continuous

00:17:53,360 --> 00:17:57,650
isolation so you aren't integrating

00:17:56,030 --> 00:17:59,870
external changes and the rest of your

00:17:57,650 --> 00:18:04,970
team simply don't know how your changes

00:17:59,870 --> 00:18:06,980
will affect their work if you are

00:18:04,970 --> 00:18:09,980
developing multiple features at the same

00:18:06,980 --> 00:18:11,770
time in parallel each in their branch

00:18:09,980 --> 00:18:14,540
integrating these features together

00:18:11,770 --> 00:18:16,610
becomes exponentially harder with the

00:18:14,540 --> 00:18:17,960
number of features being developed in

00:18:16,610 --> 00:18:19,940
parallel and the number of changes

00:18:17,960 --> 00:18:25,070
required to implement those those

00:18:19,940 --> 00:18:26,840
features now one way to reduce this

00:18:25,070 --> 00:18:28,730
integration problem is to adopt

00:18:26,840 --> 00:18:32,080
something that Martin Fowler calls

00:18:28,730 --> 00:18:34,760
promiscuous integration now be aware

00:18:32,080 --> 00:18:37,670
Martin doesn't advise as promiscuous

00:18:34,760 --> 00:18:40,250
integration he just named the pattern or

00:18:37,670 --> 00:18:43,010
should we call it an anti-pattern so if

00:18:40,250 --> 00:18:44,570
you want to use a change that exists in

00:18:43,010 --> 00:18:46,610
side of another feature that is being

00:18:44,570 --> 00:18:48,200
developed and so exists insight on all

00:18:46,610 --> 00:18:50,960
another branch well you could cherry

00:18:48,200 --> 00:18:54,010
pick a comment from that branch into

00:18:50,960 --> 00:18:56,810
your branch and so you are effectively

00:18:54,010 --> 00:18:59,870
communicating changes between ranges now

00:18:56,810 --> 00:19:02,450
the biggest concern Mountain has about

00:18:59,870 --> 00:19:04,070
promiscuous integration is that apart

00:19:02,450 --> 00:19:05,810
from the fact that it introduces lots of

00:19:04,070 --> 00:19:10,040
process complexities that you lose track

00:19:05,810 --> 00:19:12,110
on who has what on which branch and so

00:19:10,040 --> 00:19:13,700
compare this complexity with the

00:19:12,110 --> 00:19:15,890
simplicity of having everyone in the

00:19:13,700 --> 00:19:18,050
team committing directly into mainline

00:19:15,890 --> 00:19:20,120
regularly several times a day and as

00:19:18,050 --> 00:19:27,080
such communicating their changes with

00:19:20,120 --> 00:19:29,390
the rest of the team as long as we

00:19:27,080 --> 00:19:31,760
haven't integrated the work that exists

00:19:29,390 --> 00:19:34,220
on your branch into mainline well the

00:19:31,760 --> 00:19:36,140
rest of your team simply do not know in

00:19:34,220 --> 00:19:39,410
which direction you are taking the code

00:19:36,140 --> 00:19:41,540
in order to implement that feature now

00:19:39,410 --> 00:19:43,850
this is okay as long as everyone in the

00:19:41,540 --> 00:19:46,070
team is working on different areas of

00:19:43,850 --> 00:19:49,040
the code base but a minute you have two

00:19:46,070 --> 00:19:50,900
team members working on the same area of

00:19:49,040 --> 00:19:54,040
the codebase while they are each blind

00:19:50,900 --> 00:19:56,300
on how their changes affect the other

00:19:54,040 --> 00:19:58,640
now if on the other hand you are

00:19:56,300 --> 00:20:00,500
committing regularly into mainline while

00:19:58,640 --> 00:20:02,840
you are communicating with the rest of

00:20:00,500 --> 00:20:04,520
your team the direction you take to

00:20:02,840 --> 00:20:06,380
implement the feature so for instance

00:20:04,520 --> 00:20:10,040
you could introduce a conditional and

00:20:06,380 --> 00:20:12,140
the code indicate whether this

00:20:10,040 --> 00:20:14,300
conditional turned off by default but

00:20:12,140 --> 00:20:16,550
indicating to the rest of the team well

00:20:14,300 --> 00:20:18,920
Luke here starts this new feature I am

00:20:16,550 --> 00:20:20,690
working on now you could argue that

00:20:18,920 --> 00:20:23,060
introducing a conditional in the

00:20:20,690 --> 00:20:24,770
codebase introduces complexity because

00:20:23,060 --> 00:20:27,350
while conditionals means branching logic

00:20:24,770 --> 00:20:29,750
branching logic means while more

00:20:27,350 --> 00:20:32,390
problems to maintain or to reason about

00:20:29,750 --> 00:20:34,730
the code now not introducing the

00:20:32,390 --> 00:20:36,230
conditional and working with a branch

00:20:34,730 --> 00:20:37,910
well doesn't really remove the

00:20:36,230 --> 00:20:39,950
conditional the conditional is still

00:20:37,910 --> 00:20:41,600
there but it's not visible and it's

00:20:39,950 --> 00:20:43,940
absolutely not obvious because your

00:20:41,600 --> 00:20:45,920
conditional from this moment on is your

00:20:43,940 --> 00:20:48,080
version control system range and from

00:20:45,920 --> 00:20:51,880
this moment on all your changes are

00:20:48,080 --> 00:20:51,880
hidden for the rest of your team

00:20:52,539 --> 00:20:57,080
because you are hiding work for the rest

00:20:55,039 --> 00:21:00,320
of the team it also makes refactoring

00:20:57,080 --> 00:21:02,210
very difficult inside of a team now as

00:21:00,320 --> 00:21:04,460
long as you are just adding new code to

00:21:02,210 --> 00:21:07,220
your codebase integrating this code is

00:21:04,460 --> 00:21:09,080
fairly easy but the minute you start to

00:21:07,220 --> 00:21:10,720
refactor you are introducing new

00:21:09,080 --> 00:21:13,370
concepts you are introducing new

00:21:10,720 --> 00:21:15,950
abstractions and version control systems

00:21:13,370 --> 00:21:20,120
are very bad at versioning semantic

00:21:15,950 --> 00:21:22,850
changes so imagine you have two team

00:21:20,120 --> 00:21:25,909
members working each on their feature in

00:21:22,850 --> 00:21:28,130
parallel each on their branch and first

00:21:25,909 --> 00:21:30,980
team member performs a refactoring and

00:21:28,130 --> 00:21:33,230
merges back into mainline early and the

00:21:30,980 --> 00:21:36,409
second team member has a significant

00:21:33,230 --> 00:21:38,750
amount of of changes on his branch and

00:21:36,409 --> 00:21:41,570
wants to merge back into mainline after

00:21:38,750 --> 00:21:45,020
that refactoring well obviously this

00:21:41,570 --> 00:21:48,230
will be painful and probably that person

00:21:45,020 --> 00:21:49,880
will be pissed off so the longer your

00:21:48,230 --> 00:21:51,470
branch lives the more refactoring you

00:21:49,880 --> 00:21:53,659
perform on that branch the harder it

00:21:51,470 --> 00:21:56,690
becomes to integrate that with mainline

00:21:53,659 --> 00:21:58,279
and so the more time-consuming this

00:21:56,690 --> 00:22:00,200
integration will become and the more

00:21:58,279 --> 00:22:02,299
unpredictable this integration will

00:22:00,200 --> 00:22:03,950
become because of merge conflicts and

00:22:02,299 --> 00:22:06,350
potential rework and this will

00:22:03,950 --> 00:22:09,169
inevitably slow down your team and the

00:22:06,350 --> 00:22:12,169
slowdown of the team is a strong force

00:22:09,169 --> 00:22:14,029
to not adopt refactoring inside the team

00:22:12,169 --> 00:22:16,330
and we all know that if we don't adopt

00:22:14,029 --> 00:22:18,470
refactoring well we don't paying back

00:22:16,330 --> 00:22:20,059
technical debt and if you are not paying

00:22:18,470 --> 00:22:21,860
back technical depth adding new

00:22:20,059 --> 00:22:24,110
functionality to the codebase becomes

00:22:21,860 --> 00:22:25,970
harder and harder over time and so this

00:22:24,110 --> 00:22:27,649
will again slow down your team and so

00:22:25,970 --> 00:22:31,039
you end up in this vicious circle where

00:22:27,649 --> 00:22:33,500
your team will slow down over time and

00:22:31,039 --> 00:22:35,630
eventually come to a halt and nobody

00:22:33,500 --> 00:22:39,130
really understanding why this happened

00:22:35,630 --> 00:22:39,130
and how this happened

00:22:39,850 --> 00:22:47,090
when when using branches you are in fact

00:22:43,309 --> 00:22:48,590
introducing batch work so the longer the

00:22:47,090 --> 00:22:50,630
branch lives the more changes are

00:22:48,590 --> 00:22:52,370
accumulated on that branch and so the

00:22:50,630 --> 00:22:54,049
bigger the batch size becomes and the

00:22:52,370 --> 00:22:56,120
batch size being the number of commits

00:22:54,049 --> 00:22:59,240
that exists since the creation of the

00:22:56,120 --> 00:23:01,940
branch now all these changes are just

00:22:59,240 --> 00:23:05,090
work in progress and work in progress is

00:23:01,940 --> 00:23:06,140
just inventory and inventory is money

00:23:05,090 --> 00:23:08,570
that

00:23:06,140 --> 00:23:10,520
stick into the system it's stuck into

00:23:08,570 --> 00:23:13,910
the system because your organization

00:23:10,520 --> 00:23:16,310
invested quite a lot of money to create

00:23:13,910 --> 00:23:18,860
all these changes but it doesn't

00:23:16,310 --> 00:23:20,900
generate any value for for your

00:23:18,860 --> 00:23:22,760
organization because while all these

00:23:20,900 --> 00:23:24,410
changes are just lying around on the

00:23:22,760 --> 00:23:26,390
branches and as long as these are not

00:23:24,410 --> 00:23:28,820
integrated with mainline while you don't

00:23:26,390 --> 00:23:32,810
get any feedback on how these changes

00:23:28,820 --> 00:23:35,120
behave in production so in order to

00:23:32,810 --> 00:23:37,790
reduce this inventory while we know from

00:23:35,120 --> 00:23:40,130
lean manufacturing that while we have to

00:23:37,790 --> 00:23:42,590
reduce the work-in-progress and this

00:23:40,130 --> 00:23:44,360
this means we have to reduce the batch

00:23:42,590 --> 00:23:46,730
size and this means we need to commit

00:23:44,360 --> 00:23:49,670
more frequently into mainline getting

00:23:46,730 --> 00:23:51,350
closer to continuous integration and

00:23:49,670 --> 00:23:53,420
getting closer to a single piece flow

00:23:51,350 --> 00:23:55,550
and so we know also from lean

00:23:53,420 --> 00:23:58,430
manufacturing that a single piece flow

00:23:55,550 --> 00:24:00,920
it has a positive impact on throughput

00:23:58,430 --> 00:24:02,960
on lead time and on time to market and

00:24:00,920 --> 00:24:07,250
also on the quality of your software

00:24:02,960 --> 00:24:08,990
products because you are introducing

00:24:07,250 --> 00:24:11,000
batch work while you also introduce

00:24:08,990 --> 00:24:13,640
bigger change sets and bigger change

00:24:11,000 --> 00:24:15,230
sets means bigger risks so if you are

00:24:13,640 --> 00:24:18,290
committing frequently on to mainline

00:24:15,230 --> 00:24:20,780
your build process only has to process a

00:24:18,290 --> 00:24:23,660
small change set so if the build happens

00:24:20,780 --> 00:24:25,460
to break fixing that belt will be fairly

00:24:23,660 --> 00:24:27,260
easy because the change set is so small

00:24:25,460 --> 00:24:28,580
and also because well probably you

00:24:27,260 --> 00:24:31,070
introduce the change in the failing

00:24:28,580 --> 00:24:32,900
change a couple of minutes ago and so

00:24:31,070 --> 00:24:35,990
you still have this context in your head

00:24:32,900 --> 00:24:37,970
to easily fix that problem if on the

00:24:35,990 --> 00:24:40,550
other hand you are using a feature

00:24:37,970 --> 00:24:44,030
branch well the minute you integrate

00:24:40,550 --> 00:24:45,950
your build process has to process a

00:24:44,030 --> 00:24:48,440
bigger change set so if the build

00:24:45,950 --> 00:24:50,300
happens to break fixing that build will

00:24:48,440 --> 00:24:52,250
be far more difficult because the change

00:24:50,300 --> 00:24:54,770
set is so big so finding the root cause

00:24:52,250 --> 00:24:56,780
will be problematic and also well

00:24:54,770 --> 00:24:59,000
chances are you introduced the failing

00:24:56,780 --> 00:25:01,160
change a couple of hours ago or worse a

00:24:59,000 --> 00:25:03,230
couple of days ago and so you don't have

00:25:01,160 --> 00:25:05,540
this context anymore to easily fix that

00:25:03,230 --> 00:25:07,640
build and so you run the risk of having

00:25:05,540 --> 00:25:10,190
a broken build for a long period of time

00:25:07,640 --> 00:25:12,170
and so you lost the monitoring of the

00:25:10,190 --> 00:25:14,570
health of your application and so you

00:25:12,170 --> 00:25:16,700
lost the ability to perform on-demand

00:25:14,570 --> 00:25:19,940
production releases at any given moment

00:25:16,700 --> 00:25:24,710
in time which will inevitably impact you

00:25:19,940 --> 00:25:27,379
time to market and lastly while it

00:25:24,710 --> 00:25:30,620
creates lots of cognitive overhead well

00:25:27,379 --> 00:25:33,080
look at the map well I never could fit

00:25:30,620 --> 00:25:34,940
that in my in my head so in order to

00:25:33,080 --> 00:25:37,460
start a feature well you have to create

00:25:34,940 --> 00:25:39,110
a branch in order to communicate changes

00:25:37,460 --> 00:25:42,169
between features you have to cherry-pick

00:25:39,110 --> 00:25:43,879
and if you have to perform a hotfix in

00:25:42,169 --> 00:25:45,470
production well you have to create a new

00:25:43,879 --> 00:25:47,629
branch and switch switch between

00:25:45,470 --> 00:25:49,700
branches and when the feature is

00:25:47,629 --> 00:25:51,649
finished you may not forget to delete

00:25:49,700 --> 00:25:53,690
that branch so these are lots and lots

00:25:51,649 --> 00:25:55,850
of operations that you have to do on a

00:25:53,690 --> 00:25:57,860
day to day basis which creates cognitive

00:25:55,850 --> 00:25:59,899
over overload for your team members

00:25:57,860 --> 00:26:02,149
which will inevitably slow down your

00:25:59,899 --> 00:26:04,909
team so compare this with the simplicity

00:26:02,149 --> 00:26:07,039
of having everyone committing into

00:26:04,909 --> 00:26:08,570
mainline and having to puff and the only

00:26:07,039 --> 00:26:10,639
operations they have to perform is

00:26:08,570 --> 00:26:12,980
pulling the latest changes adding the

00:26:10,639 --> 00:26:18,320
local changes committing and pushing and

00:26:12,980 --> 00:26:22,070
you're done it's fairly easy now how can

00:26:18,320 --> 00:26:24,590
we avoid all of this well by adopting

00:26:22,070 --> 00:26:26,360
continuous integration as it was meant

00:26:24,590 --> 00:26:29,259
when introduced by the extreme

00:26:26,360 --> 00:26:31,940
programming community in the late 90s

00:26:29,259 --> 00:26:34,580
ensuring always working software on

00:26:31,940 --> 00:26:36,139
mainline getting feedback within minutes

00:26:34,580 --> 00:26:37,700
whether it change broke the application

00:26:36,139 --> 00:26:40,009
or not and being able to perform

00:26:37,700 --> 00:26:43,330
on-demand production releases at any

00:26:40,009 --> 00:26:46,549
given moment in time and adopting

00:26:43,330 --> 00:26:48,740
continuous integration is well is the

00:26:46,549 --> 00:26:50,990
most important practice to adopt to get

00:26:48,740 --> 00:26:54,110
to a single piece flow and so to

00:26:50,990 --> 00:26:55,850
increase your throughput and to decrease

00:26:54,110 --> 00:26:58,279
your lead time in your time to market

00:26:55,850 --> 00:27:00,230
and this implies the adoption of

00:26:58,279 --> 00:27:02,000
training base development which is a

00:27:00,230 --> 00:27:04,220
branching strategy where everyone in the

00:27:02,000 --> 00:27:06,649
team commits at least once a day into

00:27:04,220 --> 00:27:09,559
mainline change sets are small and

00:27:06,649 --> 00:27:12,879
therefore merge conflicts are very

00:27:09,559 --> 00:27:15,980
unlikely testing happens on mainline and

00:27:12,879 --> 00:27:18,440
releasing ideally happens from mainline

00:27:15,980 --> 00:27:20,840
if you need some stabilization you could

00:27:18,440 --> 00:27:23,059
opt for a short left release branch

00:27:20,840 --> 00:27:25,460
where fixes happen on mainline and are

00:27:23,059 --> 00:27:26,929
cherry packed into the release branch so

00:27:25,460 --> 00:27:29,059
that when you release you can just

00:27:26,929 --> 00:27:33,680
delete the release branch you don't have

00:27:29,059 --> 00:27:37,220
to merge back now crank base development

00:27:33,680 --> 00:27:40,520
is not a recent new hype as I sometimes

00:27:37,220 --> 00:27:42,650
read on Twitter it's in fact there since

00:27:40,520 --> 00:27:46,070
a very very long time it's there from

00:27:42,650 --> 00:27:48,440
the early 80s when RCS was introduced as

00:27:46,070 --> 00:27:51,920
one of the first version control systems

00:27:48,440 --> 00:27:54,020
it had support for branches but teams

00:27:51,920 --> 00:27:57,800
were very cautious and so they stuck to

00:27:54,020 --> 00:28:01,850
triangle but how do we get to continue

00:27:57,800 --> 00:28:03,470
this integration how do we make sure it

00:28:01,850 --> 00:28:07,160
doesn't become a mess when everyone

00:28:03,470 --> 00:28:09,170
starts to commit regularly into mainline

00:28:07,160 --> 00:28:11,240
something most teams are most afraid of

00:28:09,170 --> 00:28:14,090
well we have several techniques at our

00:28:11,240 --> 00:28:16,450
disposal and now you don't need

00:28:14,090 --> 00:28:20,600
immediately to adopt feature toggles as

00:28:16,450 --> 00:28:24,620
lots of people think so the first

00:28:20,600 --> 00:28:26,900
technique and this is one I think is the

00:28:24,620 --> 00:28:28,760
most important one to adopt but also the

00:28:26,900 --> 00:28:31,000
hardest one to adopt from what I see

00:28:28,760 --> 00:28:33,860
when I help organizations is an

00:28:31,000 --> 00:28:36,710
incremental software development it's

00:28:33,860 --> 00:28:39,470
breaking up large changes into a series

00:28:36,710 --> 00:28:42,250
of small incremental changes ensuring

00:28:39,470 --> 00:28:46,250
always working software on mainline

00:28:42,250 --> 00:28:48,560
Steve Freeman and that price makes this

00:28:46,250 --> 00:28:51,770
analogy with surgery in their book

00:28:48,560 --> 00:28:54,680
growing object-oriented software guided

00:28:51,770 --> 00:28:57,530
by tests where they say that surgeons

00:28:54,680 --> 00:28:59,780
prefer to work to do keyhole surgery

00:28:57,530 --> 00:29:01,940
instead of opening the whole patient's

00:28:59,780 --> 00:29:04,640
body because it's cheaper it's less

00:29:01,940 --> 00:29:07,190
invasive and therefore cheaper for the

00:29:04,640 --> 00:29:09,050
same reason well we prefer to work in

00:29:07,190 --> 00:29:11,030
small incremental steps because it's

00:29:09,050 --> 00:29:13,370
less invasive we are not ripping apart

00:29:11,030 --> 00:29:15,560
the application we keep it working all

00:29:13,370 --> 00:29:17,300
the time and therefore it is cheaper

00:29:15,560 --> 00:29:19,730
because we can perform on-demand

00:29:17,300 --> 00:29:23,690
production releases at any given moment

00:29:19,730 --> 00:29:25,820
in time but this means several things

00:29:23,690 --> 00:29:28,760
and first of all it means that you only

00:29:25,820 --> 00:29:30,350
commit on green and this is where that's

00:29:28,760 --> 00:29:33,050
driven development supports continuous

00:29:30,350 --> 00:29:35,540
integration you starts with with wanting

00:29:33,050 --> 00:29:37,520
a feeling test you add just enough

00:29:35,540 --> 00:29:40,780
production code to get that test passing

00:29:37,520 --> 00:29:43,340
when it is green you commit and you push

00:29:40,780 --> 00:29:45,530
after that you start refactoring

00:29:43,340 --> 00:29:47,540
if after refactoring the test is red

00:29:45,530 --> 00:29:49,520
well you revert and you start over

00:29:47,540 --> 00:29:52,010
again when it is green while you commit

00:29:49,520 --> 00:29:54,170
again and you push and this is where as

00:29:52,010 --> 00:29:57,080
driven development creates this commit

00:29:54,170 --> 00:30:00,530
cadence that you need to get to

00:29:57,080 --> 00:30:03,230
continuous integration second thing is

00:30:00,530 --> 00:30:05,450
you absolutely need a decoupled code

00:30:03,230 --> 00:30:08,120
base when your code base is two coupled

00:30:05,450 --> 00:30:10,430
any change will rip apart your

00:30:08,120 --> 00:30:12,890
application any change will ripple

00:30:10,430 --> 00:30:15,140
through all layers of your application

00:30:12,890 --> 00:30:17,930
making sure your application is not

00:30:15,140 --> 00:30:21,260
working for a long period of time and as

00:30:17,930 --> 00:30:24,080
such disabling on-demand production

00:30:21,260 --> 00:30:27,140
releases and as such impacting your

00:30:24,080 --> 00:30:30,080
throughput and your time to market so

00:30:27,140 --> 00:30:33,530
this is why adopting principles like

00:30:30,080 --> 00:30:36,800
solid and like hexagonal architectures

00:30:33,530 --> 00:30:38,930
and ports and adapters are so important

00:30:36,800 --> 00:30:41,030
apart from the fact that they will help

00:30:38,930 --> 00:30:43,460
to increase the quality of your code

00:30:41,030 --> 00:30:45,620
base they also will help in improving

00:30:43,460 --> 00:30:48,620
the throughput of your software delivery

00:30:45,620 --> 00:30:51,230
process and lastly while you need lots

00:30:48,620 --> 00:30:56,090
and lots and lots of very very very fast

00:30:51,230 --> 00:30:58,940
tests to gain enough confidence to not

00:30:56,090 --> 00:31:01,340
introduce any regressions when you are

00:30:58,940 --> 00:31:03,680
committing regularly into mainline when

00:31:01,340 --> 00:31:06,770
tests are too slow while two things can

00:31:03,680 --> 00:31:08,630
happen either teams don't run them and

00:31:06,770 --> 00:31:11,060
so you run the risk of introducing

00:31:08,630 --> 00:31:13,190
regressions or they tend to run them

00:31:11,060 --> 00:31:16,240
less frequently and so they introduce

00:31:13,190 --> 00:31:20,600
batch work again and batch work well

00:31:16,240 --> 00:31:22,820
will have impact on on your throughput

00:31:20,600 --> 00:31:26,810
and we'll also have impact on your

00:31:22,820 --> 00:31:28,970
quality the second technique we have at

00:31:26,810 --> 00:31:32,300
our disposal is the most easy one to

00:31:28,970 --> 00:31:35,360
adopt just hide unfinished functionality

00:31:32,300 --> 00:31:37,580
it's very easy don't need fancy feature

00:31:35,360 --> 00:31:39,050
toggling for this it's perfectly

00:31:37,580 --> 00:31:41,690
acceptable to have unfinished

00:31:39,050 --> 00:31:44,750
functionality setting in production even

00:31:41,690 --> 00:31:47,900
behind a publicly accessible URL as long

00:31:44,750 --> 00:31:50,270
as it is not discoverable by the user so

00:31:47,900 --> 00:31:52,520
if you are adding a new screen to your

00:31:50,270 --> 00:31:55,910
user interface well as long as the

00:31:52,520 --> 00:31:58,790
screen is not finished just don't add a

00:31:55,910 --> 00:32:00,710
menu item to access that screen only do

00:31:58,790 --> 00:32:03,710
that when the screen

00:32:00,710 --> 00:32:06,980
is finished as a last step you can also

00:32:03,710 --> 00:32:09,200
do that for API endpoints and for all

00:32:06,980 --> 00:32:13,580
the backend systems that are used by

00:32:09,200 --> 00:32:19,130
your front-end if you have to perform

00:32:13,580 --> 00:32:22,309
large-scale refactoring well like I want

00:32:19,130 --> 00:32:25,880
to replace a library by another library

00:32:22,309 --> 00:32:28,520
like you're logging library or your

00:32:25,880 --> 00:32:30,860
object relational mapping library or or

00:32:28,520 --> 00:32:32,480
you want to go to plain plain old SQL

00:32:30,860 --> 00:32:34,730
again or something like that all you

00:32:32,480 --> 00:32:36,980
have an algorithm that you want to

00:32:34,730 --> 00:32:39,409
replace by a more performant algorithm

00:32:36,980 --> 00:32:41,840
well instead of using branch by version

00:32:39,409 --> 00:32:43,309
control values branch by abstraction so

00:32:41,840 --> 00:32:44,500
branch my abstraction is a technique

00:32:43,309 --> 00:32:47,419
that allows you to perform large-scale

00:32:44,500 --> 00:32:49,940
refactorings in small incremental steps

00:32:47,419 --> 00:32:51,610
keeping your code base always working

00:32:49,940 --> 00:32:55,279
and being able to add new functionality

00:32:51,610 --> 00:32:58,429
while performing this there's this

00:32:55,279 --> 00:33:00,230
refactoring so how it works you start

00:32:58,429 --> 00:33:03,470
from a situation where you have various

00:33:00,230 --> 00:33:05,600
parts of your code base that is calling

00:33:03,470 --> 00:33:07,700
some provider code this could be this

00:33:05,600 --> 00:33:09,500
library you want to replace this can be

00:33:07,700 --> 00:33:11,809
this this algorithm you want to replace

00:33:09,500 --> 00:33:16,309
the first thing you do you introduce an

00:33:11,809 --> 00:33:18,320
abstraction layer so in most languages

00:33:16,309 --> 00:33:22,340
this would be an interface or a delegate

00:33:18,320 --> 00:33:26,360
class that abstracts away the supplier

00:33:22,340 --> 00:33:28,730
code and then you start by moving those

00:33:26,360 --> 00:33:31,179
direct calls to the supplier code to

00:33:28,730 --> 00:33:34,250
calls through this abstraction layer and

00:33:31,179 --> 00:33:35,870
at the same time you start by providing

00:33:34,250 --> 00:33:38,210
a second implementation for this

00:33:35,870 --> 00:33:40,159
abstraction layer that is using this new

00:33:38,210 --> 00:33:42,529
library or this new algorithm that you

00:33:40,159 --> 00:33:44,539
want to introduce and lastly you start

00:33:42,529 --> 00:33:48,289
to gradually swap out the old supplier

00:33:44,539 --> 00:33:51,350
code until it's gone everywhere in your

00:33:48,289 --> 00:33:53,510
codebase now I have to say that this

00:33:51,350 --> 00:33:56,750
adds quite some complexity into your

00:33:53,510 --> 00:33:59,149
code base and that you will move slower

00:33:56,750 --> 00:34:01,909
and that you will have to think harder

00:33:59,149 --> 00:34:03,799
but it has a huge advantage of navin

00:34:01,909 --> 00:34:06,230
blocking the flow of delivering new

00:34:03,799 --> 00:34:08,419
functionality while performing this

00:34:06,230 --> 00:34:10,550
large scale refactoring so you are still

00:34:08,419 --> 00:34:12,470
able to add new functionality while

00:34:10,550 --> 00:34:14,370
performing this and you are still able

00:34:12,470 --> 00:34:16,890
to perform on demand for the

00:34:14,370 --> 00:34:19,620
releases now branch by abstraction is

00:34:16,890 --> 00:34:21,420
one implementation of a bigger pattern

00:34:19,620 --> 00:34:24,660
that is called parallel changes or

00:34:21,420 --> 00:34:26,550
expand contract so expand contract

00:34:24,660 --> 00:34:29,250
because while you are first expanding

00:34:26,550 --> 00:34:31,920
you are adding new code to then later

00:34:29,250 --> 00:34:34,710
remove old code and this is contracting

00:34:31,920 --> 00:34:37,590
so all the examples of expand contract

00:34:34,710 --> 00:34:38,750
is green is Bluegreen deployments

00:34:37,590 --> 00:34:42,240
[Music]

00:34:38,750 --> 00:34:44,700
database refactorings and evolutions of

00:34:42,240 --> 00:34:47,850
remote API is that follow that follow

00:34:44,700 --> 00:34:49,830
postal slow so be conservative in what

00:34:47,850 --> 00:34:55,560
you accept but be liberal in what you

00:34:49,830 --> 00:34:57,210
sent now it's the other way around

00:34:55,560 --> 00:35:01,520
be liberal in what you accept and be

00:34:57,210 --> 00:35:04,470
conservative in what you send and lastly

00:35:01,520 --> 00:35:07,830
we have feature toggles as a last resort

00:35:04,470 --> 00:35:10,650
to decouple code deployments from

00:35:07,830 --> 00:35:14,280
feature release allowing you to adopt

00:35:10,650 --> 00:35:16,590
dark launching and canary releases so

00:35:14,280 --> 00:35:19,440
with dark launching code is setting days

00:35:16,590 --> 00:35:21,300
or weeks in advance in production before

00:35:19,440 --> 00:35:23,250
being released to your end-users

00:35:21,300 --> 00:35:25,740
allowing you to perform testing and

00:35:23,250 --> 00:35:28,380
production and even allowing you to

00:35:25,740 --> 00:35:31,560
simulate production load by having user

00:35:28,380 --> 00:35:35,550
sessions perform invisible calls to your

00:35:31,560 --> 00:35:38,130
new feature that is in production so in

00:35:35,550 --> 00:35:40,800
a sense it also removes the need of

00:35:38,130 --> 00:35:42,600
having a very expensive acceptance or

00:35:40,800 --> 00:35:45,000
staging environment that should resemble

00:35:42,600 --> 00:35:47,610
your production and never really does

00:35:45,000 --> 00:35:48,990
resemble your production and so you have

00:35:47,610 --> 00:35:52,710
bugs in production that you don't

00:35:48,990 --> 00:35:55,230
discover in your staging environment and

00:35:52,710 --> 00:35:57,150
and with canary release as well you are

00:35:55,230 --> 00:36:00,710
able to gradually release to your

00:35:57,150 --> 00:36:03,990
end-users so you start by when you are

00:36:00,710 --> 00:36:05,940
done testing you say well let's let's

00:36:03,990 --> 00:36:07,980
release to the user and we are going to

00:36:05,940 --> 00:36:10,740
first release to a small subset of users

00:36:07,980 --> 00:36:12,840
and then we see how it behaves when when

00:36:10,740 --> 00:36:15,600
used by real users evidence if this is

00:36:12,840 --> 00:36:18,000
ok we can then extend with more users if

00:36:15,600 --> 00:36:20,190
it is not ok we can just roll back at

00:36:18,000 --> 00:36:21,960
runtime without needing to redeploy a

00:36:20,190 --> 00:36:26,820
new version of the application we just

00:36:21,960 --> 00:36:27,930
switch off the the feature which is far

00:36:26,820 --> 00:36:32,339
more

00:36:27,930 --> 00:36:34,319
risky then then then redeploy so feature

00:36:32,339 --> 00:36:37,470
toggles gives you lots of flexibility

00:36:34,319 --> 00:36:40,020
but there is a downside it can be very

00:36:37,470 --> 00:36:43,799
evil too it's it's very easy to shoot

00:36:40,020 --> 00:36:46,440
yourself in the foot when done wrong one

00:36:43,799 --> 00:36:48,839
example of this is night capital

00:36:46,440 --> 00:36:51,690
services which was a financial services

00:36:48,839 --> 00:36:54,180
company that managed to lose four

00:36:51,690 --> 00:36:56,640
hundred sixty million dollars in 45

00:36:54,180 --> 00:36:59,039
minutes because of combination of two

00:36:56,640 --> 00:37:00,990
events manual deployments and forgetting

00:36:59,039 --> 00:37:04,670
to deploy on one of eight servers and

00:37:00,990 --> 00:37:07,289
reusing a feature toggle between two

00:37:04,670 --> 00:37:09,089
releases and so this feature toggle had

00:37:07,289 --> 00:37:10,589
a different meaning between those two

00:37:09,089 --> 00:37:14,010
releases and so you had this whole

00:37:10,589 --> 00:37:17,420
system going crazy and sending orders on

00:37:14,010 --> 00:37:20,279
the public market so to avoid this well

00:37:17,420 --> 00:37:22,650
first of all limit the number of active

00:37:20,279 --> 00:37:24,450
toggles and whenever a toggle is not

00:37:22,650 --> 00:37:26,670
needed anymore just remove it from your

00:37:24,450 --> 00:37:28,680
codebase and avoiding that you have a

00:37:26,670 --> 00:37:30,510
code base with lots and lots and lots of

00:37:28,680 --> 00:37:33,480
toggles and no one really understanding

00:37:30,510 --> 00:37:36,750
why these are there and no one daring to

00:37:33,480 --> 00:37:38,940
remove them also keep your toggles

00:37:36,750 --> 00:37:40,799
independent from each other so don't

00:37:38,940 --> 00:37:44,339
have the situation that to turn on the

00:37:40,799 --> 00:37:46,650
feature you have to turn on toggle X and

00:37:44,339 --> 00:37:49,619
then turn off toggle Y and turn on

00:37:46,650 --> 00:37:52,859
toggle Z it creates a Cartesian product

00:37:49,619 --> 00:37:55,950
of of test cases that you have to test

00:37:52,859 --> 00:38:00,200
and as well it's just insane and it has

00:37:55,950 --> 00:38:00,200
also an impact on your testing lead time

00:38:01,099 --> 00:38:05,220
now that we are speaking about testing

00:38:03,510 --> 00:38:07,020
while you're talking toggles also need

00:38:05,220 --> 00:38:09,299
to be tested so you have to run your

00:38:07,020 --> 00:38:11,819
automated tests against your application

00:38:09,299 --> 00:38:13,619
with both toggle on and off on the other

00:38:11,819 --> 00:38:15,390
hand your manual exploratory testing

00:38:13,619 --> 00:38:16,829
should only happen against the next

00:38:15,390 --> 00:38:19,380
situation that will happen into

00:38:16,829 --> 00:38:21,270
production so if production will have

00:38:19,380 --> 00:38:23,970
the toggle on you do your manual testing

00:38:21,270 --> 00:38:26,220
with the toggle own and lastly well

00:38:23,970 --> 00:38:28,680
there are several ways on how to

00:38:26,220 --> 00:38:31,079
implement toggles and not all of them

00:38:28,680 --> 00:38:33,170
are right Pete Hodgson wrote a very good

00:38:31,079 --> 00:38:35,609
article where he explains different

00:38:33,170 --> 00:38:37,260
techniques of implementing toggles and

00:38:35,609 --> 00:38:40,970
it's called feature toggles and it's

00:38:37,260 --> 00:38:40,970
published on martin fowler's blinky

00:38:41,200 --> 00:38:47,470
now whenever I suggest during the

00:38:44,050 --> 00:38:51,100
development I always get this same

00:38:47,470 --> 00:38:53,440
question asked what about code reviews

00:38:51,100 --> 00:38:57,160
how do you do code reviews when we don't

00:38:53,440 --> 00:38:58,870
have wrenches anymore well first of all

00:38:57,160 --> 00:39:02,350
if you do pair programming or more

00:38:58,870 --> 00:39:05,830
programming well you have a pre-commit

00:39:02,350 --> 00:39:08,320
code review for free your code is being

00:39:05,830 --> 00:39:10,510
continuously reviewed while it is being

00:39:08,320 --> 00:39:12,820
written you have several pairs of eyes

00:39:10,510 --> 00:39:15,100
looking at the code while it is written

00:39:12,820 --> 00:39:17,140
and from many XP shops this is good

00:39:15,100 --> 00:39:20,290
enough as a code review and they fail

00:39:17,140 --> 00:39:22,510
they even reported that even in high

00:39:20,290 --> 00:39:25,330
compliance industries this was good

00:39:22,510 --> 00:39:27,340
enough for code review so he has the

00:39:25,330 --> 00:39:29,260
example of a high frequency trading

00:39:27,340 --> 00:39:31,440
platform where they did pair programming

00:39:29,260 --> 00:39:33,940
and this was good enough as code written

00:39:31,440 --> 00:39:36,450
now if you don't do pair programming or

00:39:33,940 --> 00:39:38,980
you do pair programming but still want a

00:39:36,450 --> 00:39:41,290
formal code review for whatever reason

00:39:38,980 --> 00:39:43,300
you still have two options as a post

00:39:41,290 --> 00:39:45,070
commit review and the first one is the

00:39:43,300 --> 00:39:46,600
most obvious one this is well the pull

00:39:45,070 --> 00:39:48,640
request model but this time with

00:39:46,600 --> 00:39:51,340
short-lived branches branches that only

00:39:48,640 --> 00:39:53,890
live for a couple of hours the rest of

00:39:51,340 --> 00:39:55,750
however while a risk in there that the

00:39:53,890 --> 00:39:57,850
short-lived branch isn't that

00:39:55,750 --> 00:40:00,370
short-lived and lives for longer than

00:39:57,850 --> 00:40:02,620
expected like well you know let's do

00:40:00,370 --> 00:40:05,170
this more refactoring and before you

00:40:02,620 --> 00:40:07,360
know it you are they further or the ping

00:40:05,170 --> 00:40:10,810
pong that happens between review we

00:40:07,360 --> 00:40:13,690
reviewer reviewer is not available then

00:40:10,810 --> 00:40:18,460
the review is not available etc etc and

00:40:13,690 --> 00:40:20,590
you're again a couple of days later the

00:40:18,460 --> 00:40:23,140
last option and this is one I had a very

00:40:20,590 --> 00:40:24,520
good experience with use with this very

00:40:23,140 --> 00:40:27,010
novice team as well

00:40:24,520 --> 00:40:29,680
post comment reviews on mainline after

00:40:27,010 --> 00:40:31,660
the fact so the comments are already on

00:40:29,680 --> 00:40:35,740
mainline and gets reviewed when they are

00:40:31,660 --> 00:40:37,990
there now you could argue that there is

00:40:35,740 --> 00:40:40,180
a risk that bad quality gets deployed

00:40:37,990 --> 00:40:44,110
into production and yes this will happen

00:40:40,180 --> 00:40:46,090
for sure and and we had that we dead

00:40:44,110 --> 00:40:48,130
code reviews on code that was already

00:40:46,090 --> 00:40:50,500
deployed into protection now personally

00:40:48,130 --> 00:40:52,450
I don't see a problem over there well

00:40:50,500 --> 00:40:54,970
because bad quality doesn't mean a bug

00:40:52,450 --> 00:40:56,860
so code reviews are in there too

00:40:54,970 --> 00:40:58,990
Feinberg's for this we have our

00:40:56,860 --> 00:41:01,350
automated tests they are there to catch

00:40:58,990 --> 00:41:03,970
bugs code reviews is really to improve

00:41:01,350 --> 00:41:06,100
the maintainability of your codebase and

00:41:03,970 --> 00:41:07,420
also to share knowledge between team

00:41:06,100 --> 00:41:09,850
members and get a shared understanding

00:41:07,420 --> 00:41:13,720
of your codebase it's also very good

00:41:09,850 --> 00:41:16,120
training for juniors but it requires

00:41:13,720 --> 00:41:18,760
team commitment that every comet is

00:41:16,120 --> 00:41:20,740
going to be reviewed and that every

00:41:18,760 --> 00:41:22,900
issue that is reported from a code

00:41:20,740 --> 00:41:25,330
review is handled with the highest

00:41:22,900 --> 00:41:27,190
priority so that this bad code gets

00:41:25,330 --> 00:41:31,390
removed from production as soon as

00:41:27,190 --> 00:41:35,470
possible with the next deployment now if

00:41:31,390 --> 00:41:37,420
your team is very mature well you could

00:41:35,470 --> 00:41:39,480
assume that they will do the right thing

00:41:37,420 --> 00:41:42,040
and that you don't need this extra

00:41:39,480 --> 00:41:45,760
approval step and so you could get rid

00:41:42,040 --> 00:41:47,530
of this code review instead of instead

00:41:45,760 --> 00:41:49,930
of thinking that they are stupid and

00:41:47,530 --> 00:41:53,380
that you need a process to fix for that

00:41:49,930 --> 00:41:55,660
and the state of DevOps now and the book

00:41:53,380 --> 00:41:58,480
accelerate well reported that both teams

00:41:55,660 --> 00:42:01,240
that do code reviews and teams that

00:41:58,480 --> 00:42:04,860
don't do code reviews both achieve a

00:42:01,240 --> 00:42:07,780
highest software delivery performance

00:42:04,860 --> 00:42:10,870
now what are the benefits of trying base

00:42:07,780 --> 00:42:12,940
development well if you are committing

00:42:10,870 --> 00:42:15,010
frequently into mainline you are

00:42:12,940 --> 00:42:16,810
creating freaking builds and if you are

00:42:15,010 --> 00:42:19,750
creating freaking build you can deploy

00:42:16,810 --> 00:42:22,450
more frequently into production and

00:42:19,750 --> 00:42:26,530
therefore you are reducing your time to

00:42:22,450 --> 00:42:28,900
market and so you get so because you get

00:42:26,530 --> 00:42:31,000
closer to a single-piece flow and and

00:42:28,900 --> 00:42:34,750
and I search well you increase your

00:42:31,000 --> 00:42:36,940
throughput because you are deploying

00:42:34,750 --> 00:42:38,550
more frequently into production while

00:42:36,940 --> 00:42:41,770
you can also run more experiments

00:42:38,550 --> 00:42:44,680
allowing you to uncover more and met

00:42:41,770 --> 00:42:47,350
needs of your customers and finding new

00:42:44,680 --> 00:42:50,800
ways to delight them which is a huge

00:42:47,350 --> 00:42:53,140
competitive advantage and will also

00:42:50,800 --> 00:42:57,400
increase the customer satisfaction

00:42:53,140 --> 00:42:58,960
exponentially because you are creating

00:42:57,400 --> 00:43:02,290
more freaking bills while you will

00:42:58,960 --> 00:43:04,330
uncover more problems earlier allowing

00:43:02,290 --> 00:43:06,640
you to fix them immediately while they

00:43:04,330 --> 00:43:08,800
are still small and easy to fix and as

00:43:06,640 --> 00:43:11,500
such your building quality and

00:43:08,800 --> 00:43:13,960
to your product which will lead to a

00:43:11,500 --> 00:43:17,560
better stability and better quality so

00:43:13,960 --> 00:43:19,840
Trang miss development predicts higher

00:43:17,560 --> 00:43:21,280
throughput and better stability and

00:43:19,840 --> 00:43:27,240
better quality and this has been

00:43:21,280 --> 00:43:31,390
confirmed by the 2016 academic paper

00:43:27,240 --> 00:43:33,760
from Nicole Falls grand and jazz humble

00:43:31,390 --> 00:43:36,040
called the role of continuous delivery

00:43:33,760 --> 00:43:39,010
and IT and organizational performance

00:43:36,040 --> 00:43:41,200
and also recently by the book accelerate

00:43:39,010 --> 00:43:42,940
that both continuous integration

00:43:41,200 --> 00:43:45,640
together with twin base development

00:43:42,940 --> 00:43:47,500
predict the adoption of continuous

00:43:45,640 --> 00:43:49,810
delivery and the adoption of continuous

00:43:47,500 --> 00:43:52,290
delivery predicts higher software

00:43:49,810 --> 00:43:56,620
delivery performance and higher

00:43:52,290 --> 00:44:00,070
organizational performance now where is

00:43:56,620 --> 00:44:02,500
the evilness you're speaking for 45

00:44:00,070 --> 00:44:03,210
minutes and you never mentioned the

00:44:02,500 --> 00:44:06,580
evilness

00:44:03,210 --> 00:44:08,980
well the evilness is not so much the

00:44:06,580 --> 00:44:11,290
problems that arise from the use of

00:44:08,980 --> 00:44:14,290
feature branch the evilness really hides

00:44:11,290 --> 00:44:16,390
behind the use of feature ranges meaning

00:44:14,290 --> 00:44:18,940
what are the real reasons teams are

00:44:16,390 --> 00:44:20,830
using them for which is not necessarily

00:44:18,940 --> 00:44:22,930
the reasons that proponents of feature

00:44:20,830 --> 00:44:25,360
branching told me in the beginning of

00:44:22,930 --> 00:44:28,300
this this this presentation in my

00:44:25,360 --> 00:44:30,430
opinion the real reasons are there is a

00:44:28,300 --> 00:44:34,030
lack of soft of incremental software

00:44:30,430 --> 00:44:36,850
development skills which prevents them

00:44:34,030 --> 00:44:39,220
to work in small increments and and so

00:44:36,850 --> 00:44:42,790
prevent them to not rip apart the

00:44:39,220 --> 00:44:44,920
application there is a two coupled code

00:44:42,790 --> 00:44:46,990
base which prevents them to work in

00:44:44,920 --> 00:44:50,440
small increments

00:44:46,990 --> 00:44:52,330
there is a lack of automated tests and

00:44:50,440 --> 00:44:54,850
so they don't have the confidence that

00:44:52,330 --> 00:44:57,870
they aren't introducing new regressions

00:44:54,850 --> 00:45:00,640
all the build is just too slow

00:44:57,870 --> 00:45:03,580
preventing them to commit frequently

00:45:00,640 --> 00:45:06,190
into mainline so if your build takes 45

00:45:03,580 --> 00:45:09,580
minutes while you can only commit every

00:45:06,190 --> 00:45:13,720
45 minutes on to mainline in the end you

00:45:09,580 --> 00:45:18,970
only have seven bills per day which is

00:45:13,720 --> 00:45:21,460
not that that much now so feature

00:45:18,970 --> 00:45:22,480
branching tends to hide all these

00:45:21,460 --> 00:45:24,550
problems

00:45:22,480 --> 00:45:27,430
and so therefore feature branching is

00:45:24,550 --> 00:45:29,859
not really a solution to route codes but

00:45:27,430 --> 00:45:31,329
it's more like a symptom treatment we're

00:45:29,859 --> 00:45:34,240
trying base development we'll uncover

00:45:31,329 --> 00:45:36,339
all those problems and and we'll allow

00:45:34,240 --> 00:45:38,290
you to do something about it but at

00:45:36,339 --> 00:45:39,910
least you will see your problems where

00:45:38,290 --> 00:45:43,900
we feature branching you you won't see

00:45:39,910 --> 00:45:46,720
them does this mean that string bass

00:45:43,900 --> 00:45:49,000
development is easy no it is not it's

00:45:46,720 --> 00:45:51,070
quite hard and we tend to forget how

00:45:49,000 --> 00:45:54,730
difficult it was to adopt like with

00:45:51,070 --> 00:45:57,849
everything and many engineers also think

00:45:54,730 --> 00:46:00,280
it will not work and their context but

00:45:57,849 --> 00:46:03,369
well once you get them to try out an

00:46:00,280 --> 00:46:06,040
experiment or to just try it out well

00:46:03,369 --> 00:46:08,320
most of them are see the benefits from

00:46:06,040 --> 00:46:10,990
it and they see how much faster they get

00:46:08,320 --> 00:46:13,450
feedback and and and and and how much

00:46:10,990 --> 00:46:15,820
easier the workflow is and as such and

00:46:13,450 --> 00:46:17,560
and and therefore also well the the case

00:46:15,820 --> 00:46:19,630
of the hush HP LaserJet firmware

00:46:17,560 --> 00:46:21,790
division is also very interesting

00:46:19,630 --> 00:46:24,339
because they managed to introduce string

00:46:21,790 --> 00:46:27,310
based development on one product which

00:46:24,339 --> 00:46:30,210
was an embedded software where 450

00:46:27,310 --> 00:46:33,040
engineers were working on and

00:46:30,210 --> 00:46:36,069
distributed over three continents so if

00:46:33,040 --> 00:46:42,099
it works for them it can probably also

00:46:36,069 --> 00:46:44,950
work for us so whenever I get engineers

00:46:42,099 --> 00:46:47,829
to try out ring base development well I

00:46:44,950 --> 00:46:50,230
always get the feedback like oh this is

00:46:47,829 --> 00:46:51,520
this is easier and and and cannot

00:46:50,230 --> 00:46:56,800
imagine and all the world

00:46:51,520 --> 00:46:57,520
again using wrenches again so thank you

00:46:56,800 --> 00:47:00,970
for your time

00:46:57,520 --> 00:47:02,910
my name is Gerry I'm a founder of

00:47:00,970 --> 00:47:08,290
thinking labs which is just me a

00:47:02,910 --> 00:47:10,329
consulting firm in CI NCD and on the

00:47:08,290 --> 00:47:12,970
side I'm also engineering lead at the

00:47:10,329 --> 00:47:17,589
FinTech started Beck's familia where I'm

00:47:12,970 --> 00:47:18,940
trying to reduce risks if you have any

00:47:17,589 --> 00:47:25,290
questions

00:47:18,940 --> 00:47:25,290
[Applause]

00:47:26,420 --> 00:47:34,369
so are there any questions all right

00:47:35,250 --> 00:47:38,300
[Music]

00:47:39,920 --> 00:47:45,020
hi how do you enable new team members

00:47:43,230 --> 00:47:48,240
when doing trunk based development

00:47:45,020 --> 00:47:50,490
preventing that they commit broken code

00:47:48,240 --> 00:47:55,760
so nobody else has afterwards to revert

00:47:50,490 --> 00:47:55,760
and rebase their programming

00:47:55,880 --> 00:48:02,510
yeah setting Nexus next to the person

00:47:59,220 --> 00:48:05,369
and in coaching

00:48:02,510 --> 00:48:08,430
whenever well especially with juniors I

00:48:05,369 --> 00:48:11,490
always say well you have to count six

00:48:08,430 --> 00:48:14,609
months of a senior to train to train a

00:48:11,490 --> 00:48:18,270
junior and after that well they know how

00:48:14,609 --> 00:48:20,400
to work but it's it's an investment that

00:48:18,270 --> 00:48:21,599
you get back and it's really an

00:48:20,400 --> 00:48:24,539
investment because your throughput

00:48:21,599 --> 00:48:26,520
increases you get really value back for

00:48:24,539 --> 00:48:29,940
that but that's you know that that's the

00:48:26,520 --> 00:48:32,430
only way of working it's showing them

00:48:29,940 --> 00:48:35,309
how they can do things differently and

00:48:32,430 --> 00:48:38,460
many times from what I also see is that

00:48:35,309 --> 00:48:41,460
and many engineers simply don't know how

00:48:38,460 --> 00:48:44,750
to have to do well test-driven

00:48:41,460 --> 00:48:47,460
development but once you show them look

00:48:44,750 --> 00:48:51,150
we stand by doing something stupid and

00:48:47,460 --> 00:48:55,319
then we often then they have this aha

00:48:51,150 --> 00:49:00,809
moment but that's it's really rewarding

00:48:55,319 --> 00:49:07,099
when you see this working does this

00:49:00,809 --> 00:49:07,099
answer your question thank you oh well

00:49:07,940 --> 00:49:16,690
some more presents all right thank you

00:49:14,760 --> 00:49:22,409
again yeah thank you

00:49:16,690 --> 00:49:22,409
[Applause]

00:49:23,890 --> 00:49:27,989

YouTube URL: https://www.youtube.com/watch?v=9UkQfh6Rk1g


