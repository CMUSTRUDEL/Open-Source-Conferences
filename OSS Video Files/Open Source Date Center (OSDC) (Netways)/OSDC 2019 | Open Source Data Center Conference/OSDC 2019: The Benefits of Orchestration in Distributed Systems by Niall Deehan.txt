Title: OSDC 2019: The Benefits of Orchestration in Distributed Systems by Niall Deehan
Publication date: 2019-05-21
Playlist: OSDC 2019 | Open Source Data Center Conference
Description: 
	Integrating microservices and taming distributed systems is hard. In this talk I will present three challenges we observed in real-life projects and discuss how to avoid them using Open Source orchestration. Communication is complex. With everything being distributed failures are normal, so you need sophisticated failure handling strategies (e.g. stateful retry). A synchronicity requires you to handle timeouts. This is not only about milliseconds, systems get much more resilient when you can wait for minutes, hours or even longer. Distributed transactions cannot simply be delegated to protocols like XA. So, you need to solve the requirement to retain consistency in case of failures. I will not only use slides but demonstrate concrete source code examples available on GitHub.

NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de
Blog: http://blog.netways.de
Webinare: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh

https://www.frametraxx.de/
Captions: 
	00:00:01,140 --> 00:00:10,550
[Music]

00:00:16,460 --> 00:00:20,880
yeah howdy folks

00:00:18,150 --> 00:00:22,760
so yeah that's but the title is accurate

00:00:20,880 --> 00:00:25,800
I'm basically going to talk about

00:00:22,760 --> 00:00:27,210
disputed systems more specifically how

00:00:25,800 --> 00:00:28,680
we can actually add an Orchestrator

00:00:27,210 --> 00:00:30,590
where the benefits are one of the

00:00:28,680 --> 00:00:32,700
reasons I'm talking about it is because

00:00:30,590 --> 00:00:34,260
well there's a lot of really good

00:00:32,700 --> 00:00:36,570
benefits orchestration I'm not saying

00:00:34,260 --> 00:00:37,829
it's a great solution to add because I

00:00:36,570 --> 00:00:39,510
know that micro service people tend to

00:00:37,829 --> 00:00:40,200
get super angry when I say orchestration

00:00:39,510 --> 00:00:42,000
is the right answer

00:00:40,200 --> 00:00:43,469
but there are some really good benefits

00:00:42,000 --> 00:00:46,320
so it's worth talking about it

00:00:43,469 --> 00:00:48,710
Who I am is I am nyle daehan this is the

00:00:46,320 --> 00:00:52,610
coolest picture that exists of me and

00:00:48,710 --> 00:00:54,570
i'm a i'm i work as a sort of a

00:00:52,610 --> 00:00:56,160
developer advocate for an open source

00:00:54,570 --> 00:00:58,829
software called command base here in

00:00:56,160 --> 00:01:01,980
berlin i'm that one i just in case

00:00:58,829 --> 00:01:03,480
you're wondering okay so the three

00:01:01,980 --> 00:01:05,670
things that i'm gonna basically focus on

00:01:03,480 --> 00:01:08,189
with distributed systems and the pro

00:01:05,670 --> 00:01:09,299
challenges that we face is commute as of

00:01:08,189 --> 00:01:12,229
course communication between

00:01:09,299 --> 00:01:15,990
microservices challenges of asynchronous

00:01:12,229 --> 00:01:17,400
communication or gay synchronous work

00:01:15,990 --> 00:01:19,110
that needs to be done specifically and

00:01:17,400 --> 00:01:21,360
then finally distributed transactions

00:01:19,110 --> 00:01:23,640
you know how do you deal with the fact

00:01:21,360 --> 00:01:25,770
that in a distributed system you're

00:01:23,640 --> 00:01:27,090
gonna have a lot of different systems

00:01:25,770 --> 00:01:30,150
that do some stuff and you're going to

00:01:27,090 --> 00:01:31,500
need to in some cases have proper

00:01:30,150 --> 00:01:33,270
failover and be able to actually undo

00:01:31,500 --> 00:01:38,280
those things so let's start with a

00:01:33,270 --> 00:01:40,170
really simple diagram here the the old

00:01:38,280 --> 00:01:42,750
days the good old days the how we have

00:01:40,170 --> 00:01:44,520
two systems we had to them all once upon

00:01:42,750 --> 00:01:46,710
a time it was really really easy you

00:01:44,520 --> 00:01:49,110
simply had a transaction you did the two

00:01:46,710 --> 00:01:51,060
things if they were both successful we

00:01:49,110 --> 00:01:52,860
continued if any of them failed we

00:01:51,060 --> 00:01:55,649
rolled it back and it's even easier

00:01:52,860 --> 00:01:57,960
these days with with all sorts of other

00:01:55,649 --> 00:02:00,479
stuff and that is of course classic

00:01:57,960 --> 00:02:03,899
asset transactions nothing too

00:02:00,479 --> 00:02:06,479
complicated we need sort of we need to

00:02:03,899 --> 00:02:08,009
be atomic we need to have consistency of

00:02:06,479 --> 00:02:10,349
course between them we have to have

00:02:08,009 --> 00:02:13,200
isolation and durability this is not new

00:02:10,349 --> 00:02:13,800
this is basically what any sort of

00:02:13,200 --> 00:02:15,410
individuals

00:02:13,800 --> 00:02:18,240
system is going to have these kind of

00:02:15,410 --> 00:02:20,370
transactional safeguards the problem is

00:02:18,240 --> 00:02:21,930
of course that as soon as you start

00:02:20,370 --> 00:02:24,930
working with a disputed system you

00:02:21,930 --> 00:02:27,300
essentially have this very interesting a

00:02:24,930 --> 00:02:31,080
scenario in which those little houses

00:02:27,300 --> 00:02:32,730
they're the lovely lighthouse and little

00:02:31,080 --> 00:02:34,290
house there they would be our little

00:02:32,730 --> 00:02:36,090
micro services and we're very very happy

00:02:34,290 --> 00:02:38,130
in there there's where we have our asset

00:02:36,090 --> 00:02:39,900
transactions and actually outside once

00:02:38,130 --> 00:02:42,060
we leave that door that is when we enter

00:02:39,900 --> 00:02:43,860
essentially the the horror show that is

00:02:42,060 --> 00:02:45,810
the network and that's when things get

00:02:43,860 --> 00:02:47,580
way more complicated and we can't we

00:02:45,810 --> 00:02:49,470
have to actually deal with that in a big

00:02:47,580 --> 00:02:50,760
way if there's a really great wiki page

00:02:49,470 --> 00:02:53,340
on this called the fallacies of

00:02:50,760 --> 00:02:55,470
distributed computing number one the

00:02:53,340 --> 00:02:59,130
network is reliable that's a huge

00:02:55,470 --> 00:03:01,890
fallacy so just to remember that so what

00:02:59,130 --> 00:03:04,350
this means in practice is that if you

00:03:01,890 --> 00:03:07,140
have a bunch of micro services the first

00:03:04,350 --> 00:03:09,000
thing you have to realize is that when

00:03:07,140 --> 00:03:11,160
they break failure will happen and you

00:03:09,000 --> 00:03:12,870
have to accept it if everything is

00:03:11,160 --> 00:03:14,640
distributed you're gonna have some

00:03:12,870 --> 00:03:16,920
little guys or fall apart so if you

00:03:14,640 --> 00:03:18,959
accept failure the next thing you need

00:03:16,920 --> 00:03:20,970
to be aware of is you accept failure in

00:03:18,959 --> 00:03:23,130
one service but this does not mean that

00:03:20,970 --> 00:03:25,050
that one failures gonna bring everything

00:03:23,130 --> 00:03:26,700
down okay that's something you might

00:03:25,050 --> 00:03:30,150
want to avoid so we need to actually

00:03:26,700 --> 00:03:32,580
keep the services resilient even if one

00:03:30,150 --> 00:03:34,890
happens to fail and that means that we

00:03:32,580 --> 00:03:36,630
need to deal with us how does

00:03:34,890 --> 00:03:38,430
communication work when we have a

00:03:36,630 --> 00:03:40,170
problem when that we need to communicate

00:03:38,430 --> 00:03:43,260
with something that's broken and how

00:03:40,170 --> 00:03:44,489
does the client deal with that and how

00:03:43,260 --> 00:03:48,000
does the service deal with that one it's

00:03:44,489 --> 00:03:50,310
broken so I just created a really simple

00:03:48,000 --> 00:03:53,370
example that we look at I've created two

00:03:50,310 --> 00:03:56,400
little Java spring boot applications one

00:03:53,370 --> 00:03:58,500
is a payment system that makes you send

00:03:56,400 --> 00:04:00,630
a rest call to and it subsequently

00:03:58,500 --> 00:04:03,180
forwards that to a credit card system to

00:04:00,630 --> 00:04:10,040
do the charging okay so let me show you

00:04:03,180 --> 00:04:10,040
that for a moment so let's do this

00:04:11,959 --> 00:04:17,280
beautiful okay so this is available on

00:04:15,810 --> 00:04:19,049
github oh I'll show you the link later

00:04:17,280 --> 00:04:22,080
on but this is really really simple this

00:04:19,049 --> 00:04:26,160
is just a Springfield allocation it's

00:04:22,080 --> 00:04:27,630
got it's got a host there it's got a

00:04:26,160 --> 00:04:29,880
rest endpoint

00:04:27,630 --> 00:04:33,630
simply takes a call it runs this

00:04:29,880 --> 00:04:35,790
credit-card check on this Benz forwards

00:04:33,630 --> 00:04:39,470
that to another service really really

00:04:35,790 --> 00:04:44,760
simple and they're both running here

00:04:39,470 --> 00:04:49,200
this guy and the other one is here okay

00:04:44,760 --> 00:04:53,910
so this means that if I send a rest call

00:04:49,200 --> 00:04:54,930
to my service okay hey it works who'd

00:04:53,910 --> 00:04:57,810
have thought okay great

00:04:54,930 --> 00:05:00,690
we got a 200 ok that's fantastic now if

00:04:57,810 --> 00:05:02,670
the other service was down it would just

00:05:00,690 --> 00:05:04,470
break that's not unusual but there's

00:05:02,670 --> 00:05:07,230
actually more interesting thing to think

00:05:04,470 --> 00:05:09,210
about which is my credit card service so

00:05:07,230 --> 00:05:10,920
the thing I'm forwarding to let's

00:05:09,210 --> 00:05:15,810
imagine it's knock down let's say it's

00:05:10,920 --> 00:05:21,570
just slow okay so just a slow service so

00:05:15,810 --> 00:05:22,890
what's gonna happen any guesses let's

00:05:21,570 --> 00:05:23,520
see yeah that's like it's not about gas

00:05:22,890 --> 00:05:28,230
there we go

00:05:23,520 --> 00:05:31,110
okay okay loading great okay it's the

00:05:28,230 --> 00:05:32,790
forty minute talk I think right no so

00:05:31,110 --> 00:05:34,530
yes eventually this is loading loading

00:05:32,790 --> 00:05:36,210
loading and eventually of course the

00:05:34,530 --> 00:05:38,700
service is slow we don't have a problem

00:05:36,210 --> 00:05:39,930
necessarily the service is up but it's

00:05:38,700 --> 00:05:41,970
just taking a really really long time to

00:05:39,930 --> 00:05:44,070
actually take it eventually it'll find

00:05:41,970 --> 00:05:45,660
it and it'll eventually respond I assume

00:05:44,070 --> 00:05:48,510
I don't have that much time so nothing

00:05:45,660 --> 00:05:50,930
to bother waiting for it so what the

00:05:48,510 --> 00:05:50,930
issue is

00:05:57,890 --> 00:06:02,550
so the issue of course is that we are

00:06:00,840 --> 00:06:04,500
sending a blocking request that's

00:06:02,550 --> 00:06:05,730
actually the main problem here I have a

00:06:04,500 --> 00:06:07,410
service and I'm sending a request

00:06:05,730 --> 00:06:09,510
somewhere the fact that is slow is an

00:06:07,410 --> 00:06:12,120
issue entirely because it's a resource

00:06:09,510 --> 00:06:14,340
problem I can no long I'm now using up

00:06:12,120 --> 00:06:16,290
time because this request is being sent

00:06:14,340 --> 00:06:17,520
and I can't actually do anything we're

00:06:16,290 --> 00:06:19,050
blocking up the network and if you have

00:06:17,520 --> 00:06:20,400
a disputed system with any kind of

00:06:19,050 --> 00:06:22,860
throughput this is a really big problem

00:06:20,400 --> 00:06:24,060
and so this is kind of one of the

00:06:22,860 --> 00:06:25,590
problems and doesn't scale of course

00:06:24,060 --> 00:06:27,960
which is the main issue and this is one

00:06:25,590 --> 00:06:30,150
of the problems with two-phase commit

00:06:27,960 --> 00:06:32,220
because if we want to do that we are

00:06:30,150 --> 00:06:33,270
just using so much resources that were

00:06:32,220 --> 00:06:35,669
actually going not gonna be able to

00:06:33,270 --> 00:06:37,080
scale that properly now the best

00:06:35,669 --> 00:06:39,390
description I've heard from this is

00:06:37,080 --> 00:06:41,639
actually from Gregor Hobart who wrote a

00:06:39,390 --> 00:06:43,530
fantastic blog post

00:06:41,639 --> 00:06:45,060
called Starbucks does not use two-phase

00:06:43,530 --> 00:06:45,960
commit if you guys have heard of its

00:06:45,060 --> 00:06:47,999
fantastic

00:06:45,960 --> 00:06:50,099
very very simple idea when you go to

00:06:47,999 --> 00:06:52,349
Starbucks you give them your money they

00:06:50,099 --> 00:06:54,629
say great stuff I'll write your name

00:06:52,349 --> 00:06:56,249
down and then they pass the cup on to

00:06:54,629 --> 00:06:59,370
someone else and then they take the next

00:06:56,249 --> 00:07:01,279
order that next person will then get

00:06:59,370 --> 00:07:03,060
your coffee for you and give it to you

00:07:01,279 --> 00:07:04,499
fantastic alright they even have a

00:07:03,060 --> 00:07:07,409
correlation key they take your name

00:07:04,499 --> 00:07:09,180
that's great okay so in that they

00:07:07,409 --> 00:07:11,460
basically do not have a scenario where

00:07:09,180 --> 00:07:13,289
the in smaller coffee shops someone will

00:07:11,460 --> 00:07:14,759
take your order they will actually go

00:07:13,289 --> 00:07:16,469
over they will make your coffee for you

00:07:14,759 --> 00:07:19,740
and then they will go bring it over to

00:07:16,469 --> 00:07:21,569
you okay now that is fine except if a

00:07:19,740 --> 00:07:23,460
queue starts forming and the person in

00:07:21,569 --> 00:07:25,080
front of you orders 10 coffees that's

00:07:23,460 --> 00:07:27,599
gonna be an issue you're never gonna get

00:07:25,080 --> 00:07:29,129
your order and so the only problem of

00:07:27,599 --> 00:07:31,110
course with this with a problem but the

00:07:29,129 --> 00:07:33,000
thing we need to rely on is we have a

00:07:31,110 --> 00:07:35,729
scenario where we have given them our

00:07:33,000 --> 00:07:37,349
money and we do not have coffee that

00:07:35,729 --> 00:07:40,080
happens for a certain period of time

00:07:37,349 --> 00:07:43,169
okay and in this of course we call this

00:07:40,080 --> 00:07:44,849
an a temporary inconsistency for a

00:07:43,169 --> 00:07:46,050
little while we're gonna say okay here's

00:07:44,849 --> 00:07:47,879
what you need and I'm gonna trust you

00:07:46,050 --> 00:07:49,680
guys to sort that out and I know at the

00:07:47,879 --> 00:07:49,949
end of this I will actually have what I

00:07:49,680 --> 00:07:51,900
need

00:07:49,949 --> 00:07:53,400
okay that's what I need to trust and

00:07:51,900 --> 00:07:54,750
this is actually something as part of my

00:07:53,400 --> 00:07:57,990
gur service that people tend to sort of

00:07:54,750 --> 00:07:59,279
fear a little bit because if I want to

00:07:57,990 --> 00:08:00,839
tell you to do something and you tell me

00:07:59,279 --> 00:08:03,000
no problem I'll sort that out down the

00:08:00,839 --> 00:08:04,889
line but you just wait right there you

00:08:03,000 --> 00:08:09,180
may not be totally happy with that idea

00:08:04,889 --> 00:08:10,259
but of course you do you should be aware

00:08:09,180 --> 00:08:13,949
that you've been doing this forever

00:08:10,259 --> 00:08:15,569
anyone who uses bank transfers you may

00:08:13,949 --> 00:08:17,159
know this is the same idea if you

00:08:15,569 --> 00:08:18,960
actually transfer money there will be a

00:08:17,159 --> 00:08:20,580
period of time where that money is out

00:08:18,960 --> 00:08:23,250
of your account and it is not where you

00:08:20,580 --> 00:08:25,919
wanted to send it you have temporary and

00:08:23,250 --> 00:08:27,479
consistency all the time the reason that

00:08:25,919 --> 00:08:30,839
we've a problem with it is because of

00:08:27,479 --> 00:08:32,579
the possibilities of failure so because

00:08:30,839 --> 00:08:35,550
when a client sends something to a

00:08:32,579 --> 00:08:37,800
service we can fail at so many points we

00:08:35,550 --> 00:08:38,940
have here maybe the client can end up

00:08:37,800 --> 00:08:41,490
failing to send it

00:08:38,940 --> 00:08:42,930
maybe the service provider blows up or

00:08:41,490 --> 00:08:45,390
something or maybe we get a response

00:08:42,930 --> 00:08:48,810
from that either way we have to deal

00:08:45,390 --> 00:08:51,360
with network problems so in our first

00:08:48,810 --> 00:08:53,459
solution in our first scenario we have

00:08:51,360 --> 00:08:55,500
our lovely example and we have the issue

00:08:53,459 --> 00:08:59,280
that we might have this blocking call

00:08:55,500 --> 00:09:00,900
okay now this isn't a massive surprise

00:08:59,280 --> 00:09:03,810
to say the general solution to this is

00:09:00,900 --> 00:09:05,220
if you want to keep those that working

00:09:03,810 --> 00:09:07,440
you could use some kind of circuit

00:09:05,220 --> 00:09:09,960
breaker okay do you guys have uses

00:09:07,440 --> 00:09:12,360
before it's not massively unusual but if

00:09:09,960 --> 00:09:15,450
I run number two here my service is

00:09:12,360 --> 00:09:17,520
still slow I've returned eventually one

00:09:15,450 --> 00:09:22,200
second this keeps switching back to

00:09:17,520 --> 00:09:26,820
weird stuff that's I mean yeah okay it

00:09:22,200 --> 00:09:28,860
is Windows that is my problem but uh

00:09:26,820 --> 00:09:32,190
yeah I mean it's got other benefits it's

00:09:28,860 --> 00:09:34,320
got a good name okay so if I send this

00:09:32,190 --> 00:09:36,150
we get this little thing here we get

00:09:34,320 --> 00:09:38,010
immediately a time out the service is

00:09:36,150 --> 00:09:42,690
slow so we are going to try and do this

00:09:38,010 --> 00:09:43,920
so those of you who might be aware of

00:09:42,690 --> 00:09:46,380
this probably know what I'm actually

00:09:43,920 --> 00:09:49,200
using to implement this it's exactly the

00:09:46,380 --> 00:09:52,290
same it actually does have that endpoint

00:09:49,200 --> 00:09:54,570
is number two it still does this charge

00:09:52,290 --> 00:09:59,130
credit card call the difference now is

00:09:54,570 --> 00:10:01,800
that I'm adding history as a which is a

00:09:59,130 --> 00:10:03,570
Netflix thingy who people might have

00:10:01,800 --> 00:10:06,000
heard of it it basically says I'm gonna

00:10:03,570 --> 00:10:07,560
make this call but I'm gonna yeah I want

00:10:06,000 --> 00:10:09,240
you to give me a specific timeout if

00:10:07,560 --> 00:10:11,190
this thing doesn't actually respond I'm

00:10:09,240 --> 00:10:12,980
gonna kill this connection and this

00:10:11,190 --> 00:10:15,870
actually solves a problem a little bit

00:10:12,980 --> 00:10:17,610
and it basically allows to say not

00:10:15,870 --> 00:10:19,650
really change too much for code at all

00:10:17,610 --> 00:10:22,800
but be able to prevent problems like

00:10:19,650 --> 00:10:26,370
this long requesting that's going to be

00:10:22,800 --> 00:10:38,580
blocking so let's see if I can return

00:10:26,370 --> 00:10:40,770
here again yeah so so failing fast is

00:10:38,580 --> 00:10:42,510
important because if we didn't have the

00:10:40,770 --> 00:10:44,610
circuit breaker it would of course mean

00:10:42,510 --> 00:10:46,320
that we would have this horrible network

00:10:44,610 --> 00:10:49,700
that is very very slow that we don't

00:10:46,320 --> 00:10:51,930
renewing on but it's not enough okay

00:10:49,700 --> 00:10:54,630
we actually should think beyond this a

00:10:51,930 --> 00:10:57,600
bit and for that I'm actually going to

00:10:54,630 --> 00:10:58,860
bring in an example of my buddy and

00:10:57,600 --> 00:11:00,630
co-founder of the company I work for

00:10:58,860 --> 00:11:04,440
called burned he is based here in Berlin

00:11:00,630 --> 00:11:06,630
and burned does a lot of talks around

00:11:04,440 --> 00:11:09,540
the world and he tends to use these

00:11:06,630 --> 00:11:09,970
things these are airplanes and they are

00:11:09,540 --> 00:11:11,680
there

00:11:09,970 --> 00:11:14,199
very common especially for transport and

00:11:11,680 --> 00:11:15,670
generally speaking he gets these older

00:11:14,199 --> 00:11:16,930
conferences around the place and he

00:11:15,670 --> 00:11:20,410
comes across this problem quite

00:11:16,930 --> 00:11:23,139
frequently where he went trying to Gemma

00:11:20,410 --> 00:11:24,730
wings he went to try and book a flight

00:11:23,139 --> 00:11:26,829
and he went to her imprinted boarding

00:11:24,730 --> 00:11:30,250
pass and they said sorry it's broken

00:11:26,829 --> 00:11:31,569
it's just not gonna work so he thought

00:11:30,250 --> 00:11:33,790
well what is actually happening that

00:11:31,569 --> 00:11:37,120
that got me to this point well clearly

00:11:33,790 --> 00:11:39,129
burned he made some kind of call through

00:11:37,120 --> 00:11:42,160
web UI which subsequently called a

00:11:39,129 --> 00:11:44,500
check-in great it then probably did

00:11:42,160 --> 00:11:46,860
something down the line a bit this is

00:11:44,500 --> 00:11:50,800
all synchronous and then at some point

00:11:46,860 --> 00:11:52,660
in all likelihood something broke okay

00:11:50,800 --> 00:11:54,220
some service broke down the line when

00:11:52,660 --> 00:11:57,550
you print his boarding pass and what we

00:11:54,220 --> 00:12:00,579
had was we had a circuit breaker that

00:11:57,550 --> 00:12:02,290
then caught that now why do we know yet

00:12:00,579 --> 00:12:04,029
lose a circuit breaker there because

00:12:02,290 --> 00:12:05,620
this same thing happened to burned on a

00:12:04,029 --> 00:12:09,759
different airline and if you don't have

00:12:05,620 --> 00:12:10,389
a circuit breaker United Airlines has

00:12:09,759 --> 00:12:11,949
the answer

00:12:10,389 --> 00:12:13,449
so this is what would happen okay so

00:12:11,949 --> 00:12:15,939
we've prepared for this failure and

00:12:13,449 --> 00:12:18,550
that's great now what has the designer

00:12:15,939 --> 00:12:21,100
of this orchestration actually decided

00:12:18,550 --> 00:12:23,649
so they've decided that if I get an

00:12:21,100 --> 00:12:26,139
error down here at my bar code generator

00:12:23,649 --> 00:12:29,139
I would really like to make sure that

00:12:26,139 --> 00:12:30,399
the user gets that error okay that's

00:12:29,139 --> 00:12:32,949
what we're doing we're basically saying

00:12:30,399 --> 00:12:34,569
the users gonna get this error and why

00:12:32,949 --> 00:12:36,790
is that because the user is really

00:12:34,569 --> 00:12:39,100
really good at doing something called a

00:12:36,790 --> 00:12:41,290
stateful retry so this is a very very

00:12:39,100 --> 00:12:42,939
nice system it's hard to implement but

00:12:41,290 --> 00:12:45,250
don't worry because users are really

00:12:42,939 --> 00:12:47,230
good at it so burned of course is now

00:12:45,250 --> 00:12:49,300
his responsibility is to click refresh

00:12:47,230 --> 00:12:52,360
in the page until eventually maybe it

00:12:49,300 --> 00:12:55,180
works because he owns the state okay and

00:12:52,360 --> 00:12:57,430
not the best solution um interestingly

00:12:55,180 --> 00:13:00,160
it actually happened on the way back

00:12:57,430 --> 00:13:01,720
actually via easyJet so this one's

00:13:00,160 --> 00:13:05,259
actually better okay I'll tell you why

00:13:01,720 --> 00:13:06,339
because with easyJet they say okay we're

00:13:05,259 --> 00:13:08,920
having some technical difficulties

00:13:06,339 --> 00:13:10,569
please log again if it doesn't work try

00:13:08,920 --> 00:13:12,790
again five minutes they actually tell

00:13:10,569 --> 00:13:15,250
you how to do the retry works it's

00:13:12,790 --> 00:13:17,500
amazing they also say we do actively

00:13:15,250 --> 00:13:18,970
monitor our site and we resolve so it's

00:13:17,500 --> 00:13:21,459
knowing to call this is not our problem

00:13:18,970 --> 00:13:23,800
anymore this is now your problem you

00:13:21,459 --> 00:13:26,589
need to retry and don't bother

00:13:23,800 --> 00:13:29,170
about it so yeah this is what that

00:13:26,589 --> 00:13:31,959
message says so Oh

00:13:29,170 --> 00:13:34,089
be a little nicer is if we actually had

00:13:31,959 --> 00:13:36,430
something that it was like this we're

00:13:34,089 --> 00:13:37,750
having some technical difficulties we

00:13:36,430 --> 00:13:39,700
can't printer right now but don't worry

00:13:37,750 --> 00:13:41,290
we do the retry ourselves because we

00:13:39,700 --> 00:13:43,420
have your information we have your email

00:13:41,290 --> 00:13:44,529
address we know exactly who you are we

00:13:43,420 --> 00:13:46,450
know what you're trying to accomplish

00:13:44,529 --> 00:13:47,940
why do we need to tell you to click a

00:13:46,450 --> 00:13:51,130
retry button it doesn't make much sense

00:13:47,940 --> 00:13:53,920
so in this particular scenario what we

00:13:51,130 --> 00:13:56,380
would like to do is why not let burn do

00:13:53,920 --> 00:13:58,750
is click you thing will move the state

00:13:56,380 --> 00:14:01,209
will retry slightly downstream to here

00:13:58,750 --> 00:14:02,829
and basically keep it there if there's a

00:14:01,209 --> 00:14:03,160
failure don't worry we know what's going

00:14:02,829 --> 00:14:04,810
on

00:14:03,160 --> 00:14:07,600
we just don't let it leave that scope

00:14:04,810 --> 00:14:09,459
and that's a very very simple principle

00:14:07,600 --> 00:14:11,079
and generally speaking people tend to

00:14:09,459 --> 00:14:12,700
agree that is a very good user

00:14:11,079 --> 00:14:15,160
experience it makes perfect sense and

00:14:12,700 --> 00:14:16,690
then people immediately say yeah that's

00:14:15,160 --> 00:14:19,329
great but then I've got a one massive

00:14:16,690 --> 00:14:22,120
problem and it's this because as soon as

00:14:19,329 --> 00:14:23,920
I actually decide to remove the user

00:14:22,120 --> 00:14:25,810
stateful retry I need to try and

00:14:23,920 --> 00:14:27,700
implement that user somewhere else in my

00:14:25,810 --> 00:14:30,550
system ok and this is where people get

00:14:27,700 --> 00:14:33,250
kind of kind of a bit scared so this is

00:14:30,550 --> 00:14:36,700
kind of where I want to talk about when

00:14:33,250 --> 00:14:38,620
we handle a persistent thing in our in

00:14:36,700 --> 00:14:41,260
this in this orchestration we need to

00:14:38,620 --> 00:14:43,329
then be aware of the fact that it is

00:14:41,260 --> 00:14:45,579
difficult it's actually things get more

00:14:43,329 --> 00:14:47,350
complicated for instance we need to talk

00:14:45,579 --> 00:14:49,270
about scheduling because now we're

00:14:47,350 --> 00:14:51,279
holding state we need to be able to shed

00:14:49,270 --> 00:14:52,810
you'll how retries work we need to deal

00:14:51,279 --> 00:14:53,950
with versioning if we're holding state

00:14:52,810 --> 00:14:56,290
it means that we need to be able to

00:14:53,950 --> 00:14:58,000
version if we change a microservice or

00:14:56,290 --> 00:14:59,680
something is that we we have to make

00:14:58,000 --> 00:15:02,070
sure that everything in transit is still

00:14:59,680 --> 00:15:04,600
going to work and we can in that

00:15:02,070 --> 00:15:06,339
operating visibility scalability all

00:15:04,600 --> 00:15:08,829
these things are actual things that have

00:15:06,339 --> 00:15:11,560
to be thrown into the mix as soon as you

00:15:08,829 --> 00:15:12,880
want to handle stage now one of the

00:15:11,560 --> 00:15:15,250
reasons I'm here is to talk about

00:15:12,880 --> 00:15:17,560
essentially the idea of throwing a state

00:15:15,250 --> 00:15:20,290
machine or a workflow engine to solve

00:15:17,560 --> 00:15:23,320
this problem and how relatively easy

00:15:20,290 --> 00:15:24,550
that is now first of all the problem

00:15:23,320 --> 00:15:28,120
with state machines the workflows is

00:15:24,550 --> 00:15:30,730
that they tend to have this idea that

00:15:28,120 --> 00:15:32,589
they are somehow proprietary big

00:15:30,730 --> 00:15:34,510
heavyweight things slow they don't scale

00:15:32,589 --> 00:15:37,100
and the developer reverse but actually

00:15:34,510 --> 00:15:38,930
there's a whole bunch of

00:15:37,100 --> 00:15:40,820
really nice open-source solutions out

00:15:38,930 --> 00:15:42,410
there that can help us do this and they

00:15:40,820 --> 00:15:44,029
are very lightweight and their developer

00:15:42,410 --> 00:15:45,829
orientating developer friendly and

00:15:44,029 --> 00:15:49,279
therefore before I go further I should

00:15:45,829 --> 00:15:50,510
show you this slide from here on in I'm

00:15:49,279 --> 00:15:52,910
gonna just throw some opinions out there

00:15:50,510 --> 00:15:54,529
just be aware come to being disagree

00:15:52,910 --> 00:15:55,040
after the show I'm very happy to talk

00:15:54,529 --> 00:15:57,050
about it

00:15:55,040 --> 00:15:59,120
so let's talk about the workflow engines

00:15:57,050 --> 00:16:00,199
that exist in general and if you've

00:15:59,120 --> 00:16:01,699
actually tried to orchestrate

00:16:00,199 --> 00:16:03,949
micro-services you've probably come

00:16:01,699 --> 00:16:05,720
across something like step functions or

00:16:03,949 --> 00:16:07,010
something like that so this is actually

00:16:05,720 --> 00:16:09,380
something that is going to help progress

00:16:07,010 --> 00:16:11,990
the state and it is used quite a lot

00:16:09,380 --> 00:16:13,310
here for AWS stuff but I mean it's

00:16:11,990 --> 00:16:15,470
really expensive

00:16:13,310 --> 00:16:18,260
so let's actually look at stuff that is

00:16:15,470 --> 00:16:20,269
a little less annoying so interestingly

00:16:18,260 --> 00:16:21,860
this is a problem that obviously Amazon

00:16:20,269 --> 00:16:23,480
tried to solve but they're not the only

00:16:21,860 --> 00:16:26,810
really big company to try and do it

00:16:23,480 --> 00:16:28,600
because uber has a thing called uber

00:16:26,810 --> 00:16:30,500
cadence which is an open-source

00:16:28,600 --> 00:16:33,410
Orchestrator that they actually have

00:16:30,500 --> 00:16:36,290
open sourced as part of who knows why

00:16:33,410 --> 00:16:40,579
and that actually uses - it's written go

00:16:36,290 --> 00:16:42,050
I think and it's intended for and for

00:16:40,579 --> 00:16:44,720
orchestrating micro services and the

00:16:42,050 --> 00:16:46,730
netflix has conductor which is again

00:16:44,720 --> 00:16:47,959
their version of this and this is great

00:16:46,730 --> 00:16:50,000
they've open source that stuff it's very

00:16:47,959 --> 00:16:52,339
very purpose-built for their particular

00:16:50,000 --> 00:16:54,079
scenario and it's not actually a product

00:16:52,339 --> 00:16:56,810
they don't have support for it they

00:16:54,079 --> 00:16:59,480
don't really have much of a it's more of

00:16:56,810 --> 00:17:00,740
a byproduct than a product so luckily we

00:16:59,480 --> 00:17:02,209
through our Houston purpose-built

00:17:00,740 --> 00:17:03,860
open-source engines that are quite

00:17:02,209 --> 00:17:05,630
useful and again I'm specifically

00:17:03,860 --> 00:17:08,000
talking about ones that I want to be

00:17:05,630 --> 00:17:09,589
able to embed I wanted them to be

00:17:08,000 --> 00:17:12,309
lightweight and scalable and we have a

00:17:09,589 --> 00:17:14,720
whole bunch of them here there's

00:17:12,309 --> 00:17:17,569
activity jbpm commander and zeebee

00:17:14,720 --> 00:17:19,939
zeebee is if you want to do it at scale

00:17:17,569 --> 00:17:22,880
commander is what I'm gonna be using

00:17:19,939 --> 00:17:25,429
just now in a few seconds which is an

00:17:22,880 --> 00:17:26,990
open-source process engine ok but

00:17:25,429 --> 00:17:29,360
basically that the concepts the same

00:17:26,990 --> 00:17:30,350
kind of irrelevant of what you use so I

00:17:29,360 --> 00:17:32,419
want to just talk about what the

00:17:30,350 --> 00:17:35,330
difference between our our new system

00:17:32,419 --> 00:17:36,919
now if we add this new component so

00:17:35,330 --> 00:17:39,440
we're adding a huge big component now I

00:17:36,919 --> 00:17:43,880
am adding my next demo I'm going to be

00:17:39,440 --> 00:17:46,010
adding state retry mechanisms versioning

00:17:43,880 --> 00:17:49,340
and all that sort of fun stuff so let's

00:17:46,010 --> 00:17:50,690
see if Windows and that wasn't so far

00:17:49,340 --> 00:17:55,370
about future Windows

00:17:50,690 --> 00:17:56,899
okay so so that's a good table of our

00:17:55,370 --> 00:17:59,559
code now so the thing I'm actually

00:17:56,899 --> 00:18:02,720
changing in the code is I am first

00:17:59,559 --> 00:18:04,789
describing the flow you can do this

00:18:02,720 --> 00:18:06,950
graphically but I happen to do it in

00:18:04,789 --> 00:18:08,509
Java so this is basically saying I want

00:18:06,950 --> 00:18:10,820
to start event I don't want to I want a

00:18:08,509 --> 00:18:14,059
service task I want to be able to call

00:18:10,820 --> 00:18:16,669
this bean and I also want to give it a

00:18:14,059 --> 00:18:18,860
specific retry this says retry three

00:18:16,669 --> 00:18:21,049
times every one minute okay

00:18:18,860 --> 00:18:22,730
that's describing what the what I want

00:18:21,049 --> 00:18:24,830
the flow to look like and then I wanted

00:18:22,730 --> 00:18:26,509
to end so there's my flow the next thing

00:18:24,830 --> 00:18:28,370
I want to do is I just need to say

00:18:26,509 --> 00:18:31,070
there's the engine itself the engine is

00:18:28,370 --> 00:18:33,169
just Auto wired into the service I'm

00:18:31,070 --> 00:18:35,929
just saying the engine I want you just

00:18:33,169 --> 00:18:39,289
to create a add this model that I just

00:18:35,929 --> 00:18:42,799
created and then not much changes after

00:18:39,289 --> 00:18:44,330
that we we add this as a component okay

00:18:42,799 --> 00:18:47,450
that's the same thing as before that's

00:18:44,330 --> 00:18:49,159
the same charging mechanism it still has

00:18:47,450 --> 00:18:52,100
our history thing involved in there and

00:18:49,159 --> 00:18:54,100
the only difference is that we're

00:18:52,100 --> 00:18:58,149
actually calling a process to start

00:18:54,100 --> 00:18:59,330
rather than calling the service directly

00:18:58,149 --> 00:19:01,279
okay

00:18:59,330 --> 00:19:04,639
so we're saying start this process now

00:19:01,279 --> 00:19:08,059
why that's different is because this

00:19:04,639 --> 00:19:11,840
thing is still slow I think okay and so

00:19:08,059 --> 00:19:15,110
if it was normal this way if it's still

00:19:11,840 --> 00:19:20,539
slow I'm going to run version three and

00:19:15,110 --> 00:19:22,850
send it okay we get a 202 accepted great

00:19:20,539 --> 00:19:24,350
relatively rare to see those around but

00:19:22,850 --> 00:19:25,610
this basically says that we've gotten

00:19:24,350 --> 00:19:27,950
your request thank you very much and

00:19:25,610 --> 00:19:29,840
we'll deal with that now you can go go

00:19:27,950 --> 00:19:33,350
go ahead your business so we can send

00:19:29,840 --> 00:19:35,539
this in and we actually know now that

00:19:33,350 --> 00:19:38,059
what's happened is the service is slow

00:19:35,539 --> 00:19:40,129
so we took that we committed our stage

00:19:38,059 --> 00:19:42,470
and now something else in the ether is

00:19:40,129 --> 00:19:44,330
somehow retrying this so one of the key

00:19:42,470 --> 00:19:45,649
things about using the state machines is

00:19:44,330 --> 00:19:47,870
that they tend to give you some

00:19:45,649 --> 00:19:50,539
visibility so for instance right now if

00:19:47,870 --> 00:19:52,279
I wanted to see what's going on this is

00:19:50,539 --> 00:19:53,629
a front-end application that you can log

00:19:52,279 --> 00:19:55,279
in to see what's going on the engine

00:19:53,629 --> 00:19:57,049
it's really simple it hasn't this is the

00:19:55,279 --> 00:19:59,029
thing I built that with the code it's

00:19:57,049 --> 00:20:00,619
just a little diagram that shows there

00:19:59,029 --> 00:20:03,169
are two instances that are waiting right

00:20:00,619 --> 00:20:04,690
here and that they're going to run okay

00:20:03,169 --> 00:20:06,669
so eventually there

00:20:04,690 --> 00:20:09,419
holding stays here until eventually this

00:20:06,669 --> 00:20:16,869
thing is up and then it'll eventually

00:20:09,419 --> 00:20:18,039
move along yeah at some point so we now

00:20:16,869 --> 00:20:19,840
have a thing that's holding our state

00:20:18,039 --> 00:20:23,249
and we're able to actually progress the

00:20:19,840 --> 00:20:27,129
state from there and deal with that okay

00:20:23,249 --> 00:20:36,609
so let's lower that for a second I'll

00:20:27,129 --> 00:20:38,679
come back to that just now when it comes

00:20:36,609 --> 00:20:40,779
to asynchronous communication that's a

00:20:38,679 --> 00:20:42,369
bigger problem right now we've basically

00:20:40,779 --> 00:20:44,289
managed to create a really simple

00:20:42,369 --> 00:20:45,820
holding state holding status on the big

00:20:44,289 --> 00:20:47,889
problem holding states relatively easy

00:20:45,820 --> 00:20:50,169
it's the next problems that are actually

00:20:47,889 --> 00:20:51,909
more interesting which is once we hold

00:20:50,169 --> 00:20:53,440
that state we need to remember that this

00:20:51,909 --> 00:20:55,119
served the services we're talking to

00:20:53,440 --> 00:20:56,830
need to be aware that things are now

00:20:55,119 --> 00:20:59,019
asynchronous and therefore similar

00:20:56,830 --> 00:21:01,539
things we do with like right here is

00:20:59,019 --> 00:21:04,269
that if this guy now has a retry

00:21:01,539 --> 00:21:07,899
mechanism we now are holding stay here

00:21:04,269 --> 00:21:09,879
great okay fantastic and this means that

00:21:07,899 --> 00:21:11,769
if this thing is holding stage and doing

00:21:09,879 --> 00:21:14,320
retries against the credit card system

00:21:11,769 --> 00:21:16,450
we have a scenario we have a credit card

00:21:14,320 --> 00:21:19,210
system that it can implement retry is

00:21:16,450 --> 00:21:21,039
very very easily which means we need to

00:21:19,210 --> 00:21:23,559
make sure that the service provider is

00:21:21,039 --> 00:21:25,179
idempotent obviously this is a really

00:21:23,559 --> 00:21:26,499
big thing we didn't really need to so

00:21:25,179 --> 00:21:27,700
much we might not view this so much in

00:21:26,499 --> 00:21:30,070
the previous example with this means

00:21:27,700 --> 00:21:32,830
that I need to make sure that if I send

00:21:30,070 --> 00:21:34,239
the same request multiple times it's not

00:21:32,830 --> 00:21:35,470
going to run that multiple times it's

00:21:34,239 --> 00:21:37,960
going to know what's the same request

00:21:35,470 --> 00:21:40,659
the best example of this is this lovely

00:21:37,960 --> 00:21:44,470
thing here if you ever tried to send a

00:21:40,659 --> 00:21:46,570
send money online in maybe 10 years ago

00:21:44,470 --> 00:21:48,009
you may remember we are processing your

00:21:46,570 --> 00:21:49,599
payment don't leave this page in for

00:21:48,009 --> 00:21:51,759
God's sake don't reload you will end up

00:21:49,599 --> 00:21:54,099
being charged twice we do not have item

00:21:51,759 --> 00:21:55,509
potencies what this thing says now in a

00:21:54,099 --> 00:21:56,710
better in a better world we basically

00:21:55,509 --> 00:21:58,539
have something with this we're currently

00:21:56,710 --> 00:21:59,950
processing requests don't worry it will

00:21:58,539 --> 00:22:01,929
happen safely if you lose connection

00:21:59,950 --> 00:22:03,999
free feel free to lose time again that's

00:22:01,929 --> 00:22:05,679
because we could hold state we need to

00:22:03,999 --> 00:22:08,349
be aware of item potency I will need to

00:22:05,679 --> 00:22:10,149
make sure that a service can do that now

00:22:08,349 --> 00:22:12,609
another thing is that it's possible that

00:22:10,149 --> 00:22:14,259
our service could actually fail so one

00:22:12,609 --> 00:22:17,229
of the things I showed was the idea that

00:22:14,259 --> 00:22:18,370
I could charge the card and when it was

00:22:17,229 --> 00:22:19,690
successful move on

00:22:18,370 --> 00:22:21,610
that's great but things are not always

00:22:19,690 --> 00:22:23,559
successful so what if things have

00:22:21,610 --> 00:22:25,360
actually failed well if things fail we

00:22:23,559 --> 00:22:27,340
can actually catch them say we've done

00:22:25,360 --> 00:22:28,990
enough retries I'm just gonna give up on

00:22:27,340 --> 00:22:31,120
this one and then I'm going to just

00:22:28,990 --> 00:22:32,500
actually send a fail payment message and

00:22:31,120 --> 00:22:35,320
say we're just that's just not gonna

00:22:32,500 --> 00:22:36,670
happen because as we know the reason we

00:22:35,320 --> 00:22:38,800
did that original request was in order

00:22:36,670 --> 00:22:40,900
to do that because again we have that

00:22:38,800 --> 00:22:43,300
problem of a disputed system where a

00:22:40,900 --> 00:22:44,730
whole bunch of stuff could go wrong and

00:22:43,300 --> 00:22:49,780
we need to repair for that

00:22:44,730 --> 00:22:51,429
so in our payment case when we start and

00:22:49,780 --> 00:22:53,080
we charge our credit card our payment

00:22:51,429 --> 00:22:54,910
will treat no you guys left we can then

00:22:53,080 --> 00:22:57,400
also do something like this where we can

00:22:54,910 --> 00:22:59,290
actually say okay well we need to

00:22:57,400 --> 00:23:02,410
actually refund because it's possible

00:22:59,290 --> 00:23:05,290
because this thing did send the request

00:23:02,410 --> 00:23:08,260
it's possible the request broke here

00:23:05,290 --> 00:23:10,750
here or in the worst case scenario the

00:23:08,260 --> 00:23:13,120
request broke here so actually it's been

00:23:10,750 --> 00:23:15,580
successful we just don't know about it

00:23:13,120 --> 00:23:17,860
so in that case what we can we can deal

00:23:15,580 --> 00:23:19,450
with it really easily by saying okay if

00:23:17,860 --> 00:23:21,429
we have no retries left

00:23:19,450 --> 00:23:22,870
we'll give up we'll send a fail payment

00:23:21,429 --> 00:23:24,520
but then we need to actually run this

00:23:22,870 --> 00:23:27,160
retry I'll talk more with that little

00:23:24,520 --> 00:23:29,950
later on but we can do it reliably it

00:23:27,160 --> 00:23:33,100
means that this is also holding stage I

00:23:29,950 --> 00:23:34,690
will I will be able to say this refund

00:23:33,100 --> 00:23:36,340
will happen because if it fails the

00:23:34,690 --> 00:23:37,960
first time I'll just eventually wait

00:23:36,340 --> 00:23:41,650
until it's back up and it will happen

00:23:37,960 --> 00:23:43,030
so if burned had a little check-in

00:23:41,650 --> 00:23:45,730
process there what generates the bar

00:23:43,030 --> 00:23:48,090
code and that sort of thing the first

00:23:45,730 --> 00:23:50,830
thing that people tend to talk about is

00:23:48,090 --> 00:23:53,860
when we suggest this idea is that the

00:23:50,830 --> 00:23:56,580
customer wants synchronous responses

00:23:53,860 --> 00:23:59,590
that's just what they expect okay and

00:23:56,580 --> 00:24:03,400
the interesting thing is they don't ask

00:23:59,590 --> 00:24:05,170
well if the customer doesn't get a

00:24:03,400 --> 00:24:08,130
synchronous response what would they

00:24:05,170 --> 00:24:10,780
like what they like just an error page

00:24:08,130 --> 00:24:13,270
well that's not really a very good idea

00:24:10,780 --> 00:24:16,510
because luckily HTTP has a very very

00:24:13,270 --> 00:24:19,090
nice idea which is really simple in some

00:24:16,510 --> 00:24:21,520
cases the services will be up and we can

00:24:19,090 --> 00:24:23,350
get back at 200 okay and in other cases

00:24:21,520 --> 00:24:25,600
we should just say instead of breaking

00:24:23,350 --> 00:24:26,980
everything say okay we couldn't do your

00:24:25,600 --> 00:24:29,470
thing right now so you will get a

00:24:26,980 --> 00:24:32,770
synchronous response or potentially not

00:24:29,470 --> 00:24:37,280
so let's head back over here

00:24:32,770 --> 00:24:39,290
okay so in that next example if I speak

00:24:37,280 --> 00:24:43,540
if I turn my service back to normal

00:24:39,290 --> 00:24:44,690
good stuff if I send version for now

00:24:43,540 --> 00:24:47,810
okay

00:24:44,690 --> 00:24:49,490
I guess 200 okay this was able to to

00:24:47,810 --> 00:24:51,380
process this the service is doing fine

00:24:49,490 --> 00:24:53,870
we didn't need to worry about it

00:24:51,380 --> 00:24:59,990
and then if suddenly the service goes

00:24:53,870 --> 00:25:01,520
slow we got our 200 200 to accept it so

00:24:59,990 --> 00:25:03,170
now we need to hold stage because now

00:25:01,520 --> 00:25:04,460
we're saying okay well we're not going

00:25:03,170 --> 00:25:05,870
to break everything we're going to tell

00:25:04,460 --> 00:25:07,730
them well we're working on it don't

00:25:05,870 --> 00:25:10,910
worry about it and you will eventually

00:25:07,730 --> 00:25:12,320
guess I get that request we'll take care

00:25:10,910 --> 00:25:13,730
of it okay

00:25:12,320 --> 00:25:16,280
this is a much much better way of

00:25:13,730 --> 00:25:23,180
actually dealing with these kind of

00:25:16,280 --> 00:25:24,860
responses so so this is of course a much

00:25:23,180 --> 00:25:26,480
better idea than saying either it's

00:25:24,860 --> 00:25:33,110
synchronous or everything breaks we have

00:25:26,480 --> 00:25:35,240
a we have other options okay so another

00:25:33,110 --> 00:25:37,430
a challenge of course is this really

00:25:35,240 --> 00:25:40,610
simple one which is if I send a message

00:25:37,430 --> 00:25:42,710
and I don't get a response back if we

00:25:40,610 --> 00:25:45,620
have idempotency we generally don't want

00:25:42,710 --> 00:25:47,570
to have to we'd only want to wait for a

00:25:45,620 --> 00:25:49,370
certain amount of time and that's a

00:25:47,570 --> 00:25:51,590
really important one because timeouts

00:25:49,370 --> 00:25:53,270
are just as important as catching errors

00:25:51,590 --> 00:25:54,860
if we send something and we don't get a

00:25:53,270 --> 00:25:58,250
response in time need to actually be

00:25:54,860 --> 00:26:01,040
able to deal with a scheduled time out

00:25:58,250 --> 00:26:02,780
that can make sure that in this time the

00:26:01,040 --> 00:26:04,820
Phillie never leaves the scope so we can

00:26:02,780 --> 00:26:06,410
say we send this message we know how

00:26:04,820 --> 00:26:08,630
long to wait and that's actually quite

00:26:06,410 --> 00:26:10,780
easy as well you can draw that it looks

00:26:08,630 --> 00:26:13,430
something like this where you would have

00:26:10,780 --> 00:26:15,050
we send our generate a barcode we then

00:26:13,430 --> 00:26:18,050
we wait for our process and we then have

00:26:15,050 --> 00:26:19,760
here a little timer event and this thing

00:26:18,050 --> 00:26:22,460
basically says okay

00:26:19,760 --> 00:26:23,900
all of this is in state so that means we

00:26:22,460 --> 00:26:25,910
have we know exactly how long we're

00:26:23,900 --> 00:26:28,280
waiting for and we can have these guys

00:26:25,910 --> 00:26:30,620
just handle the time they can say ok if

00:26:28,280 --> 00:26:33,380
an hour has passed we will actually just

00:26:30,620 --> 00:26:36,500
resend a request again because we can do

00:26:33,380 --> 00:26:40,010
that cuz we own the state and even and

00:26:36,500 --> 00:26:42,260
these are actually for individual tasks

00:26:40,010 --> 00:26:45,290
so we generate the barcode wait for the

00:26:42,260 --> 00:26:46,160
barcode and in the this that timers are

00:26:45,290 --> 00:26:48,410
scoped

00:26:46,160 --> 00:26:51,140
saying that timer will only exist if

00:26:48,410 --> 00:26:52,610
we're on that state okay so once we

00:26:51,140 --> 00:26:55,580
leave that safe the timer doesn't matter

00:26:52,610 --> 00:26:57,590
anymore which is quite hard to do but

00:26:55,580 --> 00:26:58,850
it's it's quite easy here but also

00:26:57,590 --> 00:27:00,530
another thing we can do is we can

00:26:58,850 --> 00:27:03,620
increase the scope but we can say okay

00:27:00,530 --> 00:27:06,680
well this is a timer on the entire

00:27:03,620 --> 00:27:09,320
process we're saying we were waiting for

00:27:06,680 --> 00:27:11,330
hours if four hours elapses during the

00:27:09,320 --> 00:27:13,430
life cycle of this process matter what's

00:27:11,330 --> 00:27:16,910
happening I want you to stop it and just

00:27:13,430 --> 00:27:19,550
make sure things are are able to to

00:27:16,910 --> 00:27:22,370
progress independently now this notation

00:27:19,550 --> 00:27:23,930
is called beefy man business process

00:27:22,370 --> 00:27:27,350
modeling notation who actually here

00:27:23,930 --> 00:27:29,420
knows BPMN hey awesome popular stuff

00:27:27,350 --> 00:27:31,490
it's an open standard it's been an ISO

00:27:29,420 --> 00:27:36,440
standard since around 2012 the point of

00:27:31,490 --> 00:27:39,980
it is to be able to visually create a

00:27:36,440 --> 00:27:43,160
sequence of workflow events and an

00:27:39,980 --> 00:27:46,310
activities and be able to maintain that

00:27:43,160 --> 00:27:48,770
in an executable model because the thing

00:27:46,310 --> 00:27:51,110
you draw and BPMN is directly executable

00:27:48,770 --> 00:27:53,090
that's the key so if I were to draw it

00:27:51,110 --> 00:27:54,800
with an analyst and say here's what how

00:27:53,090 --> 00:27:59,960
things should work if I then deploy it's

00:27:54,800 --> 00:28:02,000
exactly what you see as the Thea as an

00:27:59,960 --> 00:28:03,680
admin as well so it's pretty easy

00:28:02,000 --> 00:28:06,050
understand it's executable mature

00:28:03,680 --> 00:28:08,240
there's lots of tooling for it a bunch

00:28:06,050 --> 00:28:10,040
of those open-source engines I showed

00:28:08,240 --> 00:28:14,690
you earlier I think they almost all use

00:28:10,040 --> 00:28:16,160
bpmn as a notation and it's and there's

00:28:14,690 --> 00:28:20,650
loads of modeling Tilian engine tooling

00:28:16,160 --> 00:28:20,650
as well it's a really good standard yes

00:28:28,160 --> 00:28:32,120
we can de the graphical tool is

00:28:30,110 --> 00:28:34,220
represented in an executable XML model

00:28:32,120 --> 00:28:35,780
it's not a it's not it's actually not a

00:28:34,220 --> 00:28:37,190
graphical tool I'm actually glad you

00:28:35,780 --> 00:28:40,870
mentioned that I do it that slide here

00:28:37,190 --> 00:28:43,850
cuz I I predicted that question yeah so

00:28:40,870 --> 00:28:46,310
now let me actually before I will answer

00:28:43,850 --> 00:28:48,530
that a moment because you're right it

00:28:46,310 --> 00:28:50,300
actually is a bit of an issue graphical

00:28:48,530 --> 00:28:52,130
tooling puts people off quite a lot

00:28:50,300 --> 00:28:54,290
because the only thing it's good at and

00:28:52,130 --> 00:28:56,570
actually I have a good example of that

00:28:54,290 --> 00:28:58,640
is this is a Clemens Master's article

00:28:56,570 --> 00:29:00,980
from a while ago this is discussing saga

00:28:58,640 --> 00:29:02,480
pattern okay and the really cool thing

00:29:00,980 --> 00:29:06,050
is that he has a little picture up here

00:29:02,480 --> 00:29:07,460
that shows how saga works okay we want a

00:29:06,050 --> 00:29:09,800
book hotel we want to do this this this

00:29:07,460 --> 00:29:11,210
if that works we need to undo that I'll

00:29:09,800 --> 00:29:13,970
actually talk more of that later on but

00:29:11,210 --> 00:29:16,880
the key thing is that he basically has a

00:29:13,970 --> 00:29:18,950
whole bunch of code all over this okay

00:29:16,880 --> 00:29:20,570
that's of course he does it's an article

00:29:18,950 --> 00:29:23,930
and he's talking about how we actually

00:29:20,570 --> 00:29:25,610
code this but the key thing is that this

00:29:23,930 --> 00:29:27,470
is the thing he leads with because

00:29:25,610 --> 00:29:29,570
before I need to read the code a

00:29:27,470 --> 00:29:31,580
graphical understanding of what happens

00:29:29,570 --> 00:29:33,200
is fundamental before you start reading

00:29:31,580 --> 00:29:35,150
this stuff it's really useful the

00:29:33,200 --> 00:29:37,280
problem with the graphical notation is

00:29:35,150 --> 00:29:38,810
it's just a picture okay it doesn't

00:29:37,280 --> 00:29:40,370
actually do anything it's a

00:29:38,810 --> 00:29:41,840
representation of the code you made the

00:29:40,370 --> 00:29:43,670
code first then you made the picture

00:29:41,840 --> 00:29:45,970
with bpmn it's actually living

00:29:43,670 --> 00:29:47,750
documentation so BP man is actually

00:29:45,970 --> 00:29:50,480
executable if you draw it

00:29:47,750 --> 00:29:52,250
it's what actually happens so it's never

00:29:50,480 --> 00:29:54,830
out of synch with the code it is the

00:29:52,250 --> 00:29:56,810
code and you can actually be used in

00:29:54,830 --> 00:29:59,690
lots and lots of different ways one of

00:29:56,810 --> 00:30:02,210
the ways is that this is a visual report

00:29:59,690 --> 00:30:04,400
on a test case so this is showing I ran

00:30:02,210 --> 00:30:06,350
a j-unit test that tested a certain flow

00:30:04,400 --> 00:30:09,770
my process and this shows me how much

00:30:06,350 --> 00:30:12,290
was tested then if we go into operations

00:30:09,770 --> 00:30:13,970
we could actually then see okay here's

00:30:12,290 --> 00:30:17,570
what's actually happening in my process

00:30:13,970 --> 00:30:19,310
I can see exactly how many instances or

00:30:17,570 --> 00:30:21,680
how many states were representing here

00:30:19,310 --> 00:30:23,960
we have about almost 5,000 in the first

00:30:21,680 --> 00:30:25,790
one the 2,000 and also importantly we

00:30:23,960 --> 00:30:28,130
can see where errors are which is around

00:30:25,790 --> 00:30:29,810
the 200 and something 300 mark there so

00:30:28,130 --> 00:30:31,490
we actually have a visual representation

00:30:29,810 --> 00:30:33,350
of exactly what's actually happening and

00:30:31,490 --> 00:30:37,910
this is executing this is not a picture

00:30:33,350 --> 00:30:40,610
of code it is the code we also have this

00:30:37,910 --> 00:30:41,750
guy here this is actually taking that

00:30:40,610 --> 00:30:44,510
data

00:30:41,750 --> 00:30:46,760
we saw that's produced by moving tokens

00:30:44,510 --> 00:30:48,530
around and just creating simple reports

00:30:46,760 --> 00:30:50,930
saying where is the most common path

00:30:48,530 --> 00:30:53,270
that we go where do we actually end up

00:30:50,930 --> 00:30:55,190
in our process so you can actually M as

00:30:53,270 --> 00:30:57,290
well as using it as an administrative

00:30:55,190 --> 00:30:59,570
tool to actually see what's happening on

00:30:57,290 --> 00:31:01,490
where you are across your your

00:30:59,570 --> 00:31:03,020
distributed system and what has happened

00:31:01,490 --> 00:31:05,210
because you're asking history of it you

00:31:03,020 --> 00:31:06,710
also get to see well I want to try and

00:31:05,210 --> 00:31:08,630
get some nuance understanding of what's

00:31:06,710 --> 00:31:10,670
going on with my district system what

00:31:08,630 --> 00:31:13,730
paths do we take the most and how can we

00:31:10,670 --> 00:31:17,210
improve in future as it happens this

00:31:13,730 --> 00:31:18,830
isn't the only visual indicator step

00:31:17,210 --> 00:31:22,780
functions has its own one as well a

00:31:18,830 --> 00:31:25,310
visual indicator of what's happening in

00:31:22,780 --> 00:31:29,210
disputed system is really really

00:31:25,310 --> 00:31:30,590
important it's also something that lots

00:31:29,210 --> 00:31:32,150
of different people have actually tried

00:31:30,590 --> 00:31:34,790
to implement as well the reason I prefer

00:31:32,150 --> 00:31:37,340
BPMN is simply because it's a much it's

00:31:34,790 --> 00:31:38,720
a agreed upon iso standard and it's a

00:31:37,340 --> 00:31:41,540
ghost go they're very very well and it

00:31:38,720 --> 00:31:45,710
is directly intended to be a notation

00:31:41,540 --> 00:31:48,020
that is executable you can do really

00:31:45,710 --> 00:31:49,220
complex stuff with the two and I'll talk

00:31:48,020 --> 00:31:52,670
more about that a little later on so

00:31:49,220 --> 00:31:54,860
let's um let's recap to where we're at

00:31:52,670 --> 00:31:56,930
this point we have a client great stuff

00:31:54,860 --> 00:31:58,340
which does retries in timeouts and we

00:31:56,930 --> 00:32:00,590
also have a service provider that can

00:31:58,340 --> 00:32:02,810
actually do idempotency which is fine so

00:32:00,590 --> 00:32:05,630
right now we have a scenario where our

00:32:02,810 --> 00:32:08,720
service that has the engine is making a

00:32:05,630 --> 00:32:11,030
rest call to the service there which is

00:32:08,720 --> 00:32:12,860
great okay so we are just making those

00:32:11,030 --> 00:32:16,430
calls we could also be doing something

00:32:12,860 --> 00:32:17,810
like this where we have some kind of bus

00:32:16,430 --> 00:32:20,210
like maybe Kafka maybe

00:32:17,810 --> 00:32:21,710
rabbitmq some queueing system and this

00:32:20,210 --> 00:32:23,300
thing eventually says instead of a rest

00:32:21,710 --> 00:32:26,810
call we'll put that there and then we'll

00:32:23,300 --> 00:32:28,880
get picked up okay now this is actually

00:32:26,810 --> 00:32:32,000
quite good but I actually prefer if we

00:32:28,880 --> 00:32:33,890
think about inverting this a bit so

00:32:32,000 --> 00:32:35,810
there's a fundamental issue with

00:32:33,890 --> 00:32:38,390
actually trying to poke another service

00:32:35,810 --> 00:32:40,760
to tell it to do something and that is

00:32:38,390 --> 00:32:43,490
and instead it's actually much nicer if

00:32:40,760 --> 00:32:45,860
we can say this service when it's alive

00:32:43,490 --> 00:32:48,680
simply should just get work when that

00:32:45,860 --> 00:32:50,090
work exists I could say it registers for

00:32:48,680 --> 00:32:52,460
a topic or something and then picks it

00:32:50,090 --> 00:32:54,440
up and then does it okay rather than

00:32:52,460 --> 00:32:55,500
make them then the client making a rest

00:32:54,440 --> 00:32:57,059
call to it

00:32:55,500 --> 00:32:59,340
one of the reasons why it's a good idea

00:32:57,059 --> 00:33:02,010
is because it avoids this little problem

00:32:59,340 --> 00:33:03,450
thundering herd's so if you guys have

00:33:02,010 --> 00:33:05,250
come across this before this is a

00:33:03,450 --> 00:33:07,620
fascinating problem where you were if

00:33:05,250 --> 00:33:09,780
you have a system that is making a call

00:33:07,620 --> 00:33:11,070
to another system and you have a whole

00:33:09,780 --> 00:33:13,440
micro service and everyone's making

00:33:11,070 --> 00:33:16,200
calls to other micro services that's all

00:33:13,440 --> 00:33:16,770
great except that I think a couple of

00:33:16,200 --> 00:33:21,539
years ago

00:33:16,770 --> 00:33:22,950
AWS had a five hour outage and this was

00:33:21,539 --> 00:33:25,650
a thundering herd problem what had

00:33:22,950 --> 00:33:28,380
happened was a very small component in

00:33:25,650 --> 00:33:31,650
their dead in their dispute system

00:33:28,380 --> 00:33:34,940
failed for a thing about 15 minutes okay

00:33:31,650 --> 00:33:39,030
and it was it was small but important

00:33:34,940 --> 00:33:41,669
like me and eventually it when it came

00:33:39,030 --> 00:33:43,620
back up lots of other systems just

00:33:41,669 --> 00:33:46,200
blitzed it because they were they had

00:33:43,620 --> 00:33:47,460
this retry mechanism okay they were out

00:33:46,200 --> 00:33:49,230
of state and they were waiting to just

00:33:47,460 --> 00:33:51,929
retry it again because they know is down

00:33:49,230 --> 00:33:54,419
and when you have such high throughput

00:33:51,929 --> 00:33:56,220
you get all of these things hitting it

00:33:54,419 --> 00:33:58,950
as soon as it comes back alive it just

00:33:56,220 --> 00:34:00,480
crashed again so thundering herd happens

00:33:58,950 --> 00:34:04,309
quite a lot when you actually implement

00:34:00,480 --> 00:34:07,429
these retry patterns and stayed handling

00:34:04,309 --> 00:34:12,389
which is why can some fun picture of oh

00:34:07,429 --> 00:34:14,070
there is no glory okay yep so which

00:34:12,389 --> 00:34:16,440
means there's a lot of other ways of

00:34:14,070 --> 00:34:19,830
using the engine so the engine could

00:34:16,440 --> 00:34:21,149
actually be let's say deploy to the

00:34:19,830 --> 00:34:23,070
service it could actually be an

00:34:21,149 --> 00:34:25,409
independent component another micro

00:34:23,070 --> 00:34:27,330
service so the micro services would

00:34:25,409 --> 00:34:29,310
essentially subscribe to a queue of

00:34:27,330 --> 00:34:30,629
stuff that need to do and then pick that

00:34:29,310 --> 00:34:32,310
up and then they could actually write

00:34:30,629 --> 00:34:35,250
back when they're done or you could have

00:34:32,310 --> 00:34:36,990
a worker that fetches the from the

00:34:35,250 --> 00:34:38,849
service in either way it's a little

00:34:36,990 --> 00:34:43,050
nicer if you have a nice centralized bus

00:34:38,849 --> 00:34:44,429
anyway so now onto this lovely topic

00:34:43,050 --> 00:34:46,679
here this is actually my favorites this

00:34:44,429 --> 00:34:48,810
is distributed transactions because this

00:34:46,679 --> 00:34:50,790
always causes issues when you actually

00:34:48,810 --> 00:34:54,540
have lots of things that like to happen

00:34:50,790 --> 00:34:56,190
one after another and as I said failure

00:34:54,540 --> 00:34:58,380
is something to deal with and I'm going

00:34:56,190 --> 00:35:01,500
to use the usual example which is I'm

00:34:58,380 --> 00:35:03,990
gonna use the classic booking stuff

00:35:01,500 --> 00:35:06,119
which we saw earlier so in this scenario

00:35:03,990 --> 00:35:07,980
we book our hotel we book our car we

00:35:06,119 --> 00:35:09,390
book our flight it's all make sense and

00:35:07,980 --> 00:35:12,240
then of course the

00:35:09,390 --> 00:35:13,440
life fails and we know lot we because

00:35:12,240 --> 00:35:14,849
for whatever reason we couldn't book

00:35:13,440 --> 00:35:17,519
that flight and therefore we need to

00:35:14,849 --> 00:35:19,319
cancel the car in the hotel okay so this

00:35:17,519 --> 00:35:21,720
is saga so this is a really simple way

00:35:19,319 --> 00:35:24,059
of undoing stuff across microservices

00:35:21,720 --> 00:35:26,250
and there are usually two alternative

00:35:24,059 --> 00:35:28,019
approaches we actually have choreography

00:35:26,250 --> 00:35:30,109
and orchestration or the two ways in

00:35:28,019 --> 00:35:34,500
which people try to solve this problem

00:35:30,109 --> 00:35:36,750
with choreography every set every

00:35:34,500 --> 00:35:38,849
service knows the one before it and the

00:35:36,750 --> 00:35:41,069
one after it and to undo something you

00:35:38,849 --> 00:35:43,230
simply follow the trail back so it looks

00:35:41,069 --> 00:35:45,690
like this if this was a choreography

00:35:43,230 --> 00:35:49,440
driven one I would send my request in I

00:35:45,690 --> 00:35:49,980
would then do my hotel thing do my car

00:35:49,440 --> 00:35:52,380
thing

00:35:49,980 --> 00:35:53,309
get my flight thing and then great

00:35:52,380 --> 00:35:55,950
flight fails

00:35:53,309 --> 00:35:59,190
oh sorry flight successful great and now

00:35:55,950 --> 00:36:00,569
the trip is booked okay so that means

00:35:59,190 --> 00:36:02,789
that we just go all this thing every

00:36:00,569 --> 00:36:06,450
single service knows where to expect the

00:36:02,789 --> 00:36:09,690
request and where to put the result if

00:36:06,450 --> 00:36:11,220
of course this fails then it needs to

00:36:09,690 --> 00:36:13,230
follow the saga backwards which means

00:36:11,220 --> 00:36:16,740
the flight needs to tell the Cardon

00:36:13,230 --> 00:36:17,910
which needs to tell the hotel and so on

00:36:16,740 --> 00:36:22,559
so forth and then we know we're failed

00:36:17,910 --> 00:36:23,789
okay it's actually the diagram they

00:36:22,559 --> 00:36:25,049
could actually be using a bus as well

00:36:23,789 --> 00:36:27,210
but the same principles are true they

00:36:25,049 --> 00:36:28,980
would still be actually sending some

00:36:27,210 --> 00:36:32,420
message to something that eventually

00:36:28,980 --> 00:36:32,420
gets to the next service

00:36:38,380 --> 00:36:44,440
I'm getting there don't worry yeah okay

00:36:40,930 --> 00:36:46,780
so in this scenario we basically have

00:36:44,440 --> 00:36:48,700
this lovely thing where we have a basic

00:36:46,780 --> 00:36:50,290
agreement with the cut we change we have

00:36:48,700 --> 00:36:51,850
a we change this process slightly

00:36:50,290 --> 00:36:54,520
because now we've agreed the car-rental

00:36:51,850 --> 00:36:56,140
one we're gonna swap sides usually the

00:36:54,520 --> 00:36:59,800
flight has last because it's the one

00:36:56,140 --> 00:37:01,690
that costs money to cancel usually can't

00:36:59,800 --> 00:37:03,310
see hotels you can use do for free

00:37:01,690 --> 00:37:05,080
sometimes car companies we don't really

00:37:03,310 --> 00:37:08,950
know but if we wanted to change the

00:37:05,080 --> 00:37:10,710
order one to flip hotel from car we

00:37:08,950 --> 00:37:12,940
basically change absolutely everything

00:37:10,710 --> 00:37:15,370
because everything then needs to change

00:37:12,940 --> 00:37:18,130
the order in which it actually sends a

00:37:15,370 --> 00:37:19,600
message okay because the I need change

00:37:18,130 --> 00:37:23,590
is going to affect what happens before

00:37:19,600 --> 00:37:25,750
and after it so I think basically we

00:37:23,590 --> 00:37:27,430
have a what we tend to expect is

00:37:25,750 --> 00:37:31,210
something like this and it sometimes

00:37:27,430 --> 00:37:32,860
gets a little bit crazy so the

00:37:31,210 --> 00:37:35,350
alternative will be orchestration in

00:37:32,860 --> 00:37:37,210
orchestration as you described we

00:37:35,350 --> 00:37:40,390
basically have the simple way of saying

00:37:37,210 --> 00:37:42,790
we're sending a book hotel and then we

00:37:40,390 --> 00:37:44,260
will get a response once we get that

00:37:42,790 --> 00:37:45,790
response we'll go ahead and get the next

00:37:44,260 --> 00:37:48,400
one and so on and so forth

00:37:45,790 --> 00:37:51,070
what we have here in Tripp is a single

00:37:48,400 --> 00:37:53,110
point that is deciding what to do next

00:37:51,070 --> 00:37:55,930
based on whatever results in the

00:37:53,110 --> 00:37:57,490
previous micro service and eventually

00:37:55,930 --> 00:37:59,740
Tripp is booked if we wanted to change

00:37:57,490 --> 00:38:02,230
the order of anything it all changes

00:37:59,740 --> 00:38:04,510
here not only this does this own the

00:38:02,230 --> 00:38:07,180
order in which things happen it also has

00:38:04,510 --> 00:38:09,520
the state of what has happened and what

00:38:07,180 --> 00:38:12,280
will happen everything is dictated here

00:38:09,520 --> 00:38:14,620
and so in BPMN you would just write

00:38:12,280 --> 00:38:16,510
something like this so in BPMN we have

00:38:14,620 --> 00:38:18,040
our reserve card book hotel book flight

00:38:16,510 --> 00:38:21,130
and right below it there is the

00:38:18,040 --> 00:38:23,230
compensation tasks that we can then

00:38:21,130 --> 00:38:31,620
execute if an error were to happen and

00:38:23,230 --> 00:38:33,850
again this is all done stateful e ok so

00:38:31,620 --> 00:38:35,320
yeah so you can also of course have a

00:38:33,850 --> 00:38:37,240
workflow as part of a service in my

00:38:35,320 --> 00:38:38,950
example I had trip as a service so the

00:38:37,240 --> 00:38:40,330
workflow is just embedded in there

00:38:38,950 --> 00:38:42,340
it's another service another micro

00:38:40,330 --> 00:38:43,840
service that just actually controls what

00:38:42,340 --> 00:38:45,610
the state's going to do and you can also

00:38:43,840 --> 00:38:47,980
have those other services as well every

00:38:45,610 --> 00:38:50,380
service can have its own little little

00:38:47,980 --> 00:38:51,710
micro service and so what I want to show

00:38:50,380 --> 00:38:54,050
now is some

00:38:51,710 --> 00:39:02,980
compensation stuff I think I have time

00:38:54,050 --> 00:39:02,980
for it hello my place actually not bad

00:39:03,380 --> 00:39:10,760
okay so if I send this request

00:39:07,010 --> 00:39:12,920
I guess my lovely 200 ok now version six

00:39:10,760 --> 00:39:20,780
different because version six if I take

00:39:12,920 --> 00:39:24,200
a look at my processes here bring six

00:39:20,780 --> 00:39:26,540
looks like this which is it's a we do

00:39:24,200 --> 00:39:28,819
our we do our process we deduct some

00:39:26,540 --> 00:39:31,609
some credit in some cases we charge the

00:39:28,819 --> 00:39:33,829
card if the charge is unsuccessful we

00:39:31,609 --> 00:39:36,050
throw this event this is important this

00:39:33,829 --> 00:39:37,490
event basically says if we get to this

00:39:36,050 --> 00:39:39,800
event I want you to look at where we

00:39:37,490 --> 00:39:41,750
have been the process and find the

00:39:39,800 --> 00:39:43,190
corresponding tasks that were

00:39:41,750 --> 00:39:45,230
successfully completed with this

00:39:43,190 --> 00:39:47,420
corresponding symbol and basically run

00:39:45,230 --> 00:39:50,599
this now the engine is in charge of

00:39:47,420 --> 00:39:52,099
actually doing all that logic let's take

00:39:50,599 --> 00:39:54,380
a look at what's going on so we have

00:39:52,099 --> 00:40:01,730
some historic instances here if I send a

00:39:54,380 --> 00:40:07,549
few of these guys see and let's see what

00:40:01,730 --> 00:40:09,530
happens so you tend started we now have

00:40:07,549 --> 00:40:11,900
thirteen and we see that nine arrived

00:40:09,530 --> 00:40:13,369
here and three arrived at this point so

00:40:11,900 --> 00:40:15,230
if we wanted to find out we see that the

00:40:13,369 --> 00:40:17,839
corresponding three of these and three

00:40:15,230 --> 00:40:21,140
undos so if I select this guy here let's

00:40:17,839 --> 00:40:22,040
pick one of them so this is the specific

00:40:21,140 --> 00:40:23,750
instance

00:40:22,040 --> 00:40:26,390
so we now actually a visualization of

00:40:23,750 --> 00:40:28,339
what actually has happened of course a

00:40:26,390 --> 00:40:30,290
certain orchestration of other of a

00:40:28,339 --> 00:40:32,089
service we have here that this thing

00:40:30,290 --> 00:40:34,010
obviously failed the orange little one

00:40:32,089 --> 00:40:35,990
there indicates that this task was not

00:40:34,010 --> 00:40:38,540
successfully completed but we got to

00:40:35,990 --> 00:40:41,089
that state and this shows that we

00:40:38,540 --> 00:40:45,710
actually ran down here we then triggered

00:40:41,089 --> 00:40:47,869
this and we're able to undo that call

00:40:45,710 --> 00:40:49,670
and again all of that was done stateful

00:40:47,869 --> 00:40:53,270
II the model itself is kind of

00:40:49,670 --> 00:40:54,920
interesting because I think and this one

00:40:53,270 --> 00:40:58,250
I think I might have actually built it

00:40:54,920 --> 00:40:59,510
let's open it up so the model that I

00:40:58,250 --> 00:41:01,160
actually built for this I didn't build

00:40:59,510 --> 00:41:03,950
in code like the first one this was

00:41:01,160 --> 00:41:05,100
actually built in a modeling tool like

00:41:03,950 --> 00:41:09,180
this one here so

00:41:05,100 --> 00:41:11,430
is able to just essentially you know put

00:41:09,180 --> 00:41:13,200
some stuff together and click some

00:41:11,430 --> 00:41:18,620
things and then eventually you'll see

00:41:13,200 --> 00:41:20,940
that I have to do I have various

00:41:18,620 --> 00:41:22,620
implementations here on these this is

00:41:20,940 --> 00:41:24,030
saying that an external task is doing

00:41:22,620 --> 00:41:27,150
this and this one here is saying that

00:41:24,030 --> 00:41:28,770
some delegate code is running here the

00:41:27,150 --> 00:41:31,080
difference here is that the delegate

00:41:28,770 --> 00:41:32,910
code charge card is the thing that I had

00:41:31,080 --> 00:41:39,750
locally it's actually the thing that's

00:41:32,910 --> 00:41:47,760
part of my project here it's due it's

00:41:39,750 --> 00:41:50,240
right here it's a component it's a

00:41:47,760 --> 00:41:52,530
specific component and the other one is

00:41:50,240 --> 00:41:55,470
called external and it just has this

00:41:52,530 --> 00:41:56,910
thing here that says customer credit now

00:41:55,470 --> 00:41:59,310
that's actually what I described earlier

00:41:56,910 --> 00:42:01,410
as being the fetching mechanism the

00:41:59,310 --> 00:42:03,750
engine itself doesn't need to be sending

00:42:01,410 --> 00:42:05,910
out stuff it can simply hold the current

00:42:03,750 --> 00:42:08,580
state and right now what I have is I

00:42:05,910 --> 00:42:10,230
have this little guy running and this

00:42:08,580 --> 00:42:15,360
little guy is a little service that

00:42:10,230 --> 00:42:15,810
subscribes to this topic called credit

00:42:15,360 --> 00:42:17,670
card

00:42:15,810 --> 00:42:22,650
it just says I will do that work when it

00:42:17,670 --> 00:42:27,560
shows up so if I kill this which I hope

00:42:22,650 --> 00:42:31,500
I can there we go and then I decide to

00:42:27,560 --> 00:42:35,040
start some of these they will all start

00:42:31,500 --> 00:42:37,470
that's not a problem okay the difference

00:42:35,040 --> 00:42:40,280
would be that now we should see that the

00:42:37,470 --> 00:42:42,840
engine itself is holding the state here

00:42:40,280 --> 00:42:44,310
so the engine says ok I'm just holding

00:42:42,840 --> 00:42:46,080
this there's another service that is

00:42:44,310 --> 00:42:47,790
essentially going to pick this up and do

00:42:46,080 --> 00:42:49,560
it but the engine is not going to tell

00:42:47,790 --> 00:42:52,050
that service what to do it doesn't know

00:42:49,560 --> 00:42:55,460
where it is or how it exists instead

00:42:52,050 --> 00:42:58,320
this service here once I start it up

00:42:55,460 --> 00:43:00,660
well it's a little no js' thing it

00:42:58,320 --> 00:43:02,460
simply subscribes to that topic and then

00:43:00,660 --> 00:43:05,010
picks that work up whenever it gets up

00:43:02,460 --> 00:43:07,320
there we go it picked up those things

00:43:05,010 --> 00:43:10,370
and then continue the process so this is

00:43:07,320 --> 00:43:10,370
a lot more decoupling

00:43:22,319 --> 00:43:28,380
all right so we have the declined now

00:43:26,519 --> 00:43:30,989
that can implement timeouts retries and

00:43:28,380 --> 00:43:32,609
compensation and the service service

00:43:30,989 --> 00:43:34,380
writer also has compensation and

00:43:32,609 --> 00:43:36,569
idempotence generally speaking if you

00:43:34,380 --> 00:43:38,369
combine those things you can kind of

00:43:36,569 --> 00:43:40,019
solve a lot of these problems and the

00:43:38,369 --> 00:43:41,880
important thing about that is we can all

00:43:40,019 --> 00:43:45,839
do it reliably because we always have

00:43:41,880 --> 00:43:47,549
the state controlled by us so the final

00:43:45,839 --> 00:43:49,679
points I want to leave with you guys is

00:43:47,549 --> 00:43:51,089
be aware the complexity disputed systems

00:43:49,679 --> 00:43:52,709
because they're way more complicated

00:43:51,089 --> 00:43:54,179
than people tend to think no your

00:43:52,709 --> 00:43:57,089
strategies and tools and how to handle

00:43:54,179 --> 00:43:59,849
those ok like retries like compensation

00:43:57,089 --> 00:44:01,140
like item potency and also take into

00:43:59,849 --> 00:44:03,269
account that it's actually not that

00:44:01,140 --> 00:44:06,599
complicated and quite like way to add

00:44:03,269 --> 00:44:08,579
things like circuit breakers hysterics

00:44:06,599 --> 00:44:11,309
and commanda as stay for retries or

00:44:08,579 --> 00:44:13,260
other overflow engines ok so thank you

00:44:11,309 --> 00:44:18,270
very much

00:44:13,260 --> 00:44:26,380
[Applause]

00:44:18,270 --> 00:44:29,590
thank you so some questions please I'm

00:44:26,380 --> 00:44:34,930
surprised your hand didn't go faster hi

00:44:29,590 --> 00:44:37,600
hey thank you suppose that a given

00:44:34,930 --> 00:44:40,270
company has many applications plugged in

00:44:37,600 --> 00:44:43,630
with queuing systems and they have

00:44:40,270 --> 00:44:46,300
implemented almost very similar logic to

00:44:43,630 --> 00:44:49,090
this but they are not using the state

00:44:46,300 --> 00:44:51,010
engine so they have the logic

00:44:49,090 --> 00:44:54,820
distributed in the code of all the

00:44:51,010 --> 00:44:57,010
applications is there any easy way any

00:44:54,820 --> 00:44:59,020
recommendations on how to port it in so

00:44:57,010 --> 00:45:01,270
it's actually bringing control yeah

00:44:59,020 --> 00:45:03,250
before I've actually done I've gone to

00:45:01,270 --> 00:45:05,619
to do little workshops where I've helped

00:45:03,250 --> 00:45:07,030
it it's normally around services that

00:45:05,619 --> 00:45:10,660
have the choreography problem where

00:45:07,030 --> 00:45:12,520
every service or or user interface knows

00:45:10,660 --> 00:45:13,869
what happens next and it's actually easy

00:45:12,520 --> 00:45:16,030
you think it's mostly about deleting

00:45:13,869 --> 00:45:18,250
code because the core thing you want to

00:45:16,030 --> 00:45:20,170
keep is just the business logic the

00:45:18,250 --> 00:45:22,390
thing you used to be to strip out is you

00:45:20,170 --> 00:45:25,720
need to strip out the subscription to

00:45:22,390 --> 00:45:27,670
the previous task or producing the event

00:45:25,720 --> 00:45:31,210
to the next thing and you used to remove

00:45:27,670 --> 00:45:33,790
that and make that way more generic so

00:45:31,210 --> 00:45:36,460
instead of having let's say I'm waiting

00:45:33,790 --> 00:45:39,520
for something on this port or whatever

00:45:36,460 --> 00:45:42,490
you could simply say I will read this

00:45:39,520 --> 00:45:44,770
service will now register for this topic

00:45:42,490 --> 00:45:46,480
instead for instance and then instead of

00:45:44,770 --> 00:45:48,400
actually knowing what happens next at

00:45:46,480 --> 00:45:50,170
all like instead of having to write

00:45:48,400 --> 00:45:51,670
something that needs to send a rest call

00:45:50,170 --> 00:45:53,230
to the next service you used to delete

00:45:51,670 --> 00:45:55,750
that and instead you just write a thing

00:45:53,230 --> 00:45:57,880
where I'm going to send some either an

00:45:55,750 --> 00:46:00,250
event to a queue or I'm gonna send a

00:45:57,880 --> 00:46:01,540
call to the engine or something so it's

00:46:00,250 --> 00:46:02,770
actually less complicated you would

00:46:01,540 --> 00:46:04,480
think because it's not about adding

00:46:02,770 --> 00:46:12,940
anything it's really about taking stuff

00:46:04,480 --> 00:46:28,790
away from your services you had a nice

00:46:12,940 --> 00:46:30,800
slide yeah my understanding was you're

00:46:28,790 --> 00:46:32,600
on the orchestration 1 you were sort of

00:46:30,800 --> 00:46:34,040
trying to convince us that you felt the

00:46:32,600 --> 00:46:36,290
orchestration approach was superior

00:46:34,040 --> 00:46:38,960
yes ok so I agreed with you that the

00:46:36,290 --> 00:46:40,310
diagram was superior but I don't agree

00:46:38,960 --> 00:46:41,840
with the fact that it has to be

00:46:40,310 --> 00:46:44,750
orchestration I think that you could do

00:46:41,840 --> 00:46:48,530
that second diagram in an choreographed

00:46:44,750 --> 00:46:50,180
way where you simply have you push the

00:46:48,530 --> 00:46:52,640
algorithm to initiate to everyone and

00:46:50,180 --> 00:46:54,440
any time any one of them fails they put

00:46:52,640 --> 00:46:56,150
a flag in a standardized place and

00:46:54,440 --> 00:46:57,380
everyone is watching that flag and if

00:46:56,150 --> 00:47:00,500
anyone sees the flag then they all

00:46:57,380 --> 00:47:02,390
independently know to roll back yeah so

00:47:00,500 --> 00:47:05,060
the only problem with that is that again

00:47:02,390 --> 00:47:06,560
it's I think I might've mentioned before

00:47:05,060 --> 00:47:08,320
but the issue with that is sort of

00:47:06,560 --> 00:47:11,120
violates some principles of the

00:47:08,320 --> 00:47:13,460
micro-service architecture in general so

00:47:11,120 --> 00:47:15,230
the idea that every micro-service should

00:47:13,460 --> 00:47:17,210
be independent of any other now in every

00:47:15,230 --> 00:47:19,010
single micro-service must have a

00:47:17,210 --> 00:47:20,870
component that must know the

00:47:19,010 --> 00:47:22,190
choreography you're basically limiting

00:47:20,870 --> 00:47:24,050
every micro-service to a specific

00:47:22,190 --> 00:47:25,760
language perhaps or a specific data

00:47:24,050 --> 00:47:27,920
source perhaps and this might actually

00:47:25,760 --> 00:47:29,870
be a little bit of a people quite like

00:47:27,920 --> 00:47:31,460
domain-specific microservices and the

00:47:29,870 --> 00:47:33,380
ability to be able to choose that in my

00:47:31,460 --> 00:47:35,450
domain this particular technology is

00:47:33,380 --> 00:47:36,830
better I think as soon as you start like

00:47:35,450 --> 00:47:38,900
doing something like saying ok your

00:47:36,830 --> 00:47:40,280
microservice before you even start needs

00:47:38,900 --> 00:47:41,870
to implement these particular things

00:47:40,280 --> 00:47:43,850
then you can write whatever you want

00:47:41,870 --> 00:47:45,590
people tend to dislike them now I don't

00:47:43,850 --> 00:47:47,090
disagree with you I think it's I don't

00:47:45,590 --> 00:47:49,220
love all the principles of microservices

00:47:47,090 --> 00:47:50,570
but I do think that people tend to push

00:47:49,220 --> 00:47:51,920
back on that when you start to say I

00:47:50,570 --> 00:47:53,090
have a great idea if you're my grosser

00:47:51,920 --> 00:47:59,450
verse and it starts with you installing

00:47:53,090 --> 00:48:00,860
this thing onto it that's partly ok

00:47:59,450 --> 00:48:03,650
can't you just provide a standard API

00:48:00,860 --> 00:48:05,000
that gives a few of these primitives in

00:48:03,650 --> 00:48:07,280
addition you would hang on the other

00:48:05,000 --> 00:48:10,670
primitives yeah but then you wouldn't

00:48:07,280 --> 00:48:13,250
actually need to have the orchestration

00:48:10,670 --> 00:48:15,080
on the micro service at all so you would

00:48:13,250 --> 00:48:16,790
have a single micro service that simply

00:48:15,080 --> 00:48:18,590
controls like an engine that controls

00:48:16,790 --> 00:48:20,570
the stage and then every other micro

00:48:18,590 --> 00:48:22,790
service is irrelevant so then when the

00:48:20,570 --> 00:48:25,580
state changes no other micro service

00:48:22,790 --> 00:48:27,440
needs to care about this flag or about

00:48:25,580 --> 00:48:29,900
loading anything up and also they have

00:48:27,440 --> 00:48:31,190
versioning as well and embedded in there

00:48:29,900 --> 00:48:32,600
because that service takes care of

00:48:31,190 --> 00:48:34,790
versioning it takes care of the retries

00:48:32,600 --> 00:48:37,550
every single service then is completely

00:48:34,790 --> 00:48:40,640
independent of needing to know about any

00:48:37,550 --> 00:48:42,080
state transitions so I think it's the it

00:48:40,640 --> 00:48:42,650
would work the same but it would just

00:48:42,080 --> 00:48:51,950
have the engine

00:48:42,650 --> 00:48:52,450
in a different place more questions all

00:48:51,950 --> 00:48:55,430
right

00:48:52,450 --> 00:49:02,589
yeah great talk thank you thanks so much

00:48:55,430 --> 00:49:02,589
[Applause]

00:49:03,860 --> 00:49:07,949

YouTube URL: https://www.youtube.com/watch?v=7B6Sq1_boyo


