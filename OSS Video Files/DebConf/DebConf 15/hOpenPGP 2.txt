Title: hOpenPGP 2
Publication date: 2017-12-03
Playlist: DebConf 15
Description: 
	by Clint Adams

At: DebConf15
https://summit.debconf.org/debconf15/meeting/234/hopenpgp-2/
https://debconf15.debconf.org/

Since the hOpenPGP talk at DC14, a few things have changed.  This will briefly summarize what's new with hOpenPGP and hopenpgp-tools.

Room: Heidelberg
Scheduled start: 2015-08-16 17:30:00
Captions: 
	00:00:00,979 --> 00:00:06,450
silence please everyone Adams was going

00:00:04,110 --> 00:00:12,509
to be speaking about H openpgp a Haskell

00:00:06,450 --> 00:00:14,700
open PGP implementation so I'm a little

00:00:12,509 --> 00:00:16,529
bit sick so I apologize in advance if I

00:00:14,700 --> 00:00:21,810
collapse in a coughing fit or something

00:00:16,529 --> 00:00:24,539
worse I I assume all of you have seen my

00:00:21,810 --> 00:00:27,779
talk from last year so this is this is

00:00:24,539 --> 00:00:30,840
gonna be a little redundant but H open

00:00:27,779 --> 00:00:34,860
PGP is an implementation of open PGP and

00:00:30,840 --> 00:00:38,820
Haskell it's its primary consumers far

00:00:34,860 --> 00:00:41,969
as I know is H open PGP tools which is

00:00:38,820 --> 00:00:45,420
referred to by Rhys ups open PGP best

00:00:41,969 --> 00:00:49,590
practices and also now the the key

00:00:45,420 --> 00:00:55,739
signing party instructions at Def Con

00:00:49,590 --> 00:00:58,350
this year so the intent of this talk is

00:00:55,739 --> 00:01:05,519
to explain what's changed since last

00:00:58,350 --> 00:01:09,590
year's dub Kampf which is some some bug

00:01:05,519 --> 00:01:14,220
fixes some incompatible API changes

00:01:09,590 --> 00:01:18,439
dependencies and I'm I'll go into a

00:01:14,220 --> 00:01:21,150
little more detail on some of these so

00:01:18,439 --> 00:01:27,210
the API changes have mostly been for

00:01:21,150 --> 00:01:33,090
type safety so for example in in the

00:01:27,210 --> 00:01:37,729
olden days of 2013 we used a type

00:01:33,090 --> 00:01:41,610
synonym timestamp for word 32 because

00:01:37,729 --> 00:01:47,479
most of time expressions in the open PGP

00:01:41,610 --> 00:01:53,570
standard are 32-bit unsigned integers

00:01:47,479 --> 00:01:56,700
but some of them are expressed as

00:01:53,570 --> 00:01:58,969
seconds since the epoch and are not

00:01:56,700 --> 00:02:01,950
actually not the epoch some of them are

00:01:58,969 --> 00:02:05,159
absolute values of time and some of them

00:02:01,950 --> 00:02:08,700
are durations so even though the

00:02:05,159 --> 00:02:11,849
standard calls the key expiration time

00:02:08,700 --> 00:02:14,800
the key expiration time it is

00:02:11,849 --> 00:02:23,340
number of seconds since the creation

00:02:14,800 --> 00:02:28,420
time so I wanted to help the user

00:02:23,340 --> 00:02:32,049
understand which type is which so to

00:02:28,420 --> 00:02:35,019
reduce confusion so now we have two new

00:02:32,049 --> 00:02:39,790
type wrappers one for iteration and one

00:02:35,019 --> 00:02:42,280
for time too so now you'll get a compile

00:02:39,790 --> 00:02:47,739
time error if you try to do the wrong

00:02:42,280 --> 00:02:51,519
thing and I think I talked about this

00:02:47,739 --> 00:02:56,349
last year at all instead of allowing you

00:02:51,519 --> 00:02:59,349
to have a list of MPI's Berkey it

00:02:56,349 --> 00:03:01,870
doesn't make any sense to have no MPI's

00:02:59,349 --> 00:03:04,510
at all so we're gonna enforce at the

00:03:01,870 --> 00:03:09,370
type level that this list has to be

00:03:04,510 --> 00:03:13,629
non-empty and since I was breaking

00:03:09,370 --> 00:03:16,569
things I decided to change the type of

00:03:13,629 --> 00:03:19,569
these er IDs to from strings to text

00:03:16,569 --> 00:03:21,220
which theoretically will give us a

00:03:19,569 --> 00:03:26,650
performance boost but probably doesn't

00:03:21,220 --> 00:03:29,019
matter at all so a lot of the

00:03:26,650 --> 00:03:31,750
dependencies have changed out from

00:03:29,019 --> 00:03:33,940
underneath including switching from

00:03:31,750 --> 00:03:39,700
serial in serial conduit to binary and

00:03:33,940 --> 00:03:43,780
binary conduit NC wlp print to WP wlp

00:03:39,700 --> 00:03:47,799
print extras and I accept - I accept

00:03:43,780 --> 00:03:50,919
typed which is primarily because the

00:03:47,799 --> 00:03:54,340
former doesn't work with jesusÃ­ 7.10

00:03:50,919 --> 00:03:55,480
which will be in the WN archive pretty

00:03:54,340 --> 00:03:57,669
soon well it's already in an

00:03:55,480 --> 00:04:02,040
experimental but it'll be and sit pretty

00:03:57,669 --> 00:04:02,040
soon so I want to be prepared for that

00:04:02,079 --> 00:04:12,190
I was also abusing the show instances

00:04:07,000 --> 00:04:16,030
for fingerprints so in order to not

00:04:12,190 --> 00:04:21,099
violate the principle of reading show

00:04:16,030 --> 00:04:24,400
round-tripping the show instance now

00:04:21,099 --> 00:04:24,910
contains no spaces if you want spaces in

00:04:24,400 --> 00:04:27,960
your finger

00:04:24,910 --> 00:04:31,660
but you need to use the pretty instance

00:04:27,960 --> 00:04:33,760
and there's more test coverage and which

00:04:31,660 --> 00:04:35,860
is still not complete so if you feel

00:04:33,760 --> 00:04:37,200
like contributing test cases that would

00:04:35,860 --> 00:04:41,790
be great

00:04:37,200 --> 00:04:47,350
now more interestingly there are now

00:04:41,790 --> 00:04:50,460
JSON instances for transferable keys and

00:04:47,350 --> 00:04:55,330
all the types used by transferable keys

00:04:50,460 --> 00:04:58,990
so this means you can if you can parse a

00:04:55,330 --> 00:05:02,170
a transferable open PGP key with a CH

00:04:58,990 --> 00:05:10,140
open PGP you can output it as Jason or

00:05:02,170 --> 00:05:16,090
yamo so this is somebody's key and

00:05:10,140 --> 00:05:23,740
hopefully you can read that so at the

00:05:16,090 --> 00:05:26,920
top you'll see the the RSA MPI's and the

00:05:23,740 --> 00:05:28,140
timestamps the the schema of this is

00:05:26,920 --> 00:05:32,410
clearly suboptimal

00:05:28,140 --> 00:05:34,870
so if somebody has strong opinions on

00:05:32,410 --> 00:05:41,020
how this should actually look and I see

00:05:34,870 --> 00:05:44,800
Paul tag is volunteering if you feel

00:05:41,020 --> 00:05:51,419
free to help get this into a same format

00:05:44,800 --> 00:05:51,419
because it is definitely not ideal so

00:05:51,480 --> 00:06:00,990
because we're using Ehsan for for the

00:05:55,810 --> 00:06:03,130
JSON we get gamo output for free so

00:06:00,990 --> 00:06:07,120
depending on which you prefer you can

00:06:03,130 --> 00:06:09,550
just swap that out and every every bit

00:06:07,120 --> 00:06:14,590
of data is going to be the same just in

00:06:09,550 --> 00:06:18,190
the different format and so there's some

00:06:14,590 --> 00:06:20,050
more gamal this is this is either paul

00:06:18,190 --> 00:06:23,110
tags key or Francesca's I can't tell

00:06:20,050 --> 00:06:27,520
them apart anymore and as you can see

00:06:23,110 --> 00:06:31,600
the V jpg is an array of byte values

00:06:27,520 --> 00:06:33,370
which I really don't know what the

00:06:31,600 --> 00:06:34,510
correct way to handle this is so if

00:06:33,370 --> 00:06:37,740
anyone else does

00:06:34,510 --> 00:06:37,740
I'd be good to know

00:06:38,230 --> 00:06:48,460
and the serialization is a bit better it

00:06:44,900 --> 00:06:52,900
used to choke on unknown s2k types and

00:06:48,460 --> 00:06:59,210
canoe PG has some sort of proprietary

00:06:52,900 --> 00:07:02,720
s2k type called 101 and so I ran into

00:06:59,210 --> 00:07:16,460
this in the wild and and now it can cope

00:07:02,720 --> 00:07:19,670
with that so the the open PGP tools can

00:07:16,460 --> 00:07:23,090
do filtering either on transferable keys

00:07:19,670 --> 00:07:28,550
or individual packets and that code is

00:07:23,090 --> 00:07:31,310
in the library itself used to be split

00:07:28,550 --> 00:07:35,180
between more evenly and now it's mostly

00:07:31,310 --> 00:07:38,120
in the library and it used to be more

00:07:35,180 --> 00:07:44,450
poorly designed so there were separate

00:07:38,120 --> 00:07:48,430
filtering languages for public keys and

00:07:44,450 --> 00:07:52,090
signatures and other and you could not

00:07:48,430 --> 00:07:55,820
construct a complex query in a sane way

00:07:52,090 --> 00:07:59,200
if you wanted to do that so the if you

00:07:55,820 --> 00:08:03,440
were operating on a packet stream the

00:07:59,200 --> 00:08:06,490
filters would only apply to the packets

00:08:03,440 --> 00:08:10,670
of their type and so you could get

00:08:06,490 --> 00:08:15,530
surprising results and that was using a

00:08:10,670 --> 00:08:18,740
doe parsec for the parsing and someone

00:08:15,530 --> 00:08:20,980
convinced me to rewrite it using Alex

00:08:18,740 --> 00:08:24,980
and happy which are the Haskell

00:08:20,980 --> 00:08:30,440
equivalents of flex and bison or Alexa

00:08:24,980 --> 00:08:35,270
yak and the parser is completely redone

00:08:30,440 --> 00:08:39,740
and so now you can do queries like so

00:08:35,270 --> 00:08:43,400
the first two here are things you could

00:08:39,740 --> 00:08:49,610
do before but this is you can do them

00:08:43,400 --> 00:08:51,620
with this in text now and the the last

00:08:49,610 --> 00:08:56,060
ones are more interesting but

00:08:51,620 --> 00:09:00,230
is now of theirs this is using higher

00:08:56,060 --> 00:09:04,670
order functions so you can do matching

00:09:00,230 --> 00:09:09,860
on sub structures of the transferable

00:09:04,670 --> 00:09:15,710
key so like you can search on all the

00:09:09,860 --> 00:09:17,960
you IDs or sum of any of the u IDs not

00:09:15,710 --> 00:09:19,700
every one of you IDs contains that sign

00:09:17,960 --> 00:09:24,740
if you want to look for people that have

00:09:19,700 --> 00:09:28,670
u IDs that are not obviously email

00:09:24,740 --> 00:09:34,750
addresses like weasel hat just has his

00:09:28,670 --> 00:09:39,170
name or a couple other people do this or

00:09:34,750 --> 00:09:42,970
if and find any key where the public key

00:09:39,170 --> 00:09:42,970
algorithm is ECDSA

00:09:43,600 --> 00:09:52,250
or where the primary key is less than

00:09:48,670 --> 00:09:55,330
2048 bits in size but you have a sub key

00:09:52,250 --> 00:10:01,910
larger than that which is pretty common

00:09:55,330 --> 00:10:09,230
so that's probably the thing I'm most

00:10:01,910 --> 00:10:14,270
excited about and then apropos of

00:10:09,230 --> 00:10:19,930
nothing on e ball asked me to do an

00:10:14,270 --> 00:10:24,170
analysis on the DC 15 key signing party

00:10:19,930 --> 00:10:33,560
keyring so I'm just going to segue into

00:10:24,170 --> 00:10:36,820
that so this says sort of because there

00:10:33,560 --> 00:10:42,200
is one defective key in the keyring and

00:10:36,820 --> 00:10:46,220
H open PGP choked on it so I got to I

00:10:42,200 --> 00:10:48,110
got to discover a fun bug Canoe PG also

00:10:46,220 --> 00:10:52,610
does buggy things with this key so

00:10:48,110 --> 00:10:57,040
that's exciting and hopefully someone

00:10:52,610 --> 00:10:57,040
talks to Verner about that pretty soon

00:10:57,190 --> 00:11:01,220
so there are actually two hundred eighty

00:10:59,420 --> 00:11:04,390
three keys in the keyring so this does

00:11:01,220 --> 00:11:04,390
not reflect any of that

00:11:04,550 --> 00:11:14,250
and the five unknown or the you'll see

00:11:11,610 --> 00:11:18,449
five other pub key algorithms and five

00:11:14,250 --> 00:11:28,620
unknown sizes those are type 22 which I

00:11:18,449 --> 00:11:39,300
believe is Edie 255 nineteen no okay yes

00:11:28,620 --> 00:11:41,699
okay so okay so that is not yet

00:11:39,300 --> 00:11:46,829
supported so if somebody wants to do

00:11:41,699 --> 00:11:54,750
some development eventually we probably

00:11:46,829 --> 00:11:58,350
want to support that and people are

00:11:54,750 --> 00:12:06,779
still using ripe MD 164 self six and a

00:11:58,350 --> 00:12:11,279
fair amount are using sha-1 the longest

00:12:06,779 --> 00:12:13,769
paths in the self-contained set are six

00:12:11,279 --> 00:12:15,480
hops long and here they are and if you

00:12:13,769 --> 00:12:18,949
want to know who these people are you're

00:12:15,480 --> 00:12:18,949
gonna have to do the analysis yourself

00:12:20,750 --> 00:12:31,350
and the strong connectivity analysis

00:12:26,160 --> 00:12:36,980
shows there's 193 keys in the strong set

00:12:31,350 --> 00:12:42,569
and a couple of islands and then all but

00:12:36,980 --> 00:12:48,290
215 keys are Singleton's so hopefully

00:12:42,569 --> 00:12:56,420
after the rolling key signing of this

00:12:48,290 --> 00:12:56,420
conference those get a lot better so

00:12:59,940 --> 00:13:02,900
right

00:13:03,390 --> 00:13:11,460
um okay so I guess now would be a good

00:13:09,630 --> 00:13:13,520
time for questions if anyone has

00:13:11,460 --> 00:13:13,520
questions

00:13:29,070 --> 00:13:32,169
[Music]

00:13:37,610 --> 00:13:45,420
hello right you've mentioned a lot of

00:13:41,610 --> 00:13:49,230
analysis functionality yes hmm PGP is

00:13:45,420 --> 00:13:52,040
there also mechanisms for creating and

00:13:49,230 --> 00:14:03,740
manipulating signatures and key material

00:13:52,040 --> 00:14:08,700
sort of the the principle I've been

00:14:03,740 --> 00:14:14,850
going with thus far is to not implement

00:14:08,700 --> 00:14:18,200
anything destructive so there's if today

00:14:14,850 --> 00:14:22,740
you want to use a function that will

00:14:18,200 --> 00:14:27,020
output a signature you're gonna have to

00:14:22,740 --> 00:14:27,020
do a little bit of work the the

00:14:27,980 --> 00:14:32,580
cryptographic support is there for for

00:14:31,260 --> 00:14:37,050
the algorithms that are supported

00:14:32,580 --> 00:14:38,580
there's there's a tiny bit of there's

00:14:37,050 --> 00:14:42,450
there's basically no elliptic curve

00:14:38,580 --> 00:14:45,780
there's there's a tiny stub for it but

00:14:42,450 --> 00:14:50,880
that's about it we can do RSA and DSA we

00:14:45,780 --> 00:14:54,030
can't do al Kamal and that's pretty much

00:14:50,880 --> 00:14:56,100
the situation so that needs a little bit

00:14:54,030 --> 00:14:58,430
of work but you could you could do

00:14:56,100 --> 00:14:58,430
something

00:15:03,040 --> 00:15:06,590
any more questions anyone we have five

00:15:05,840 --> 00:15:15,080
minutes remaining

00:15:06,590 --> 00:15:19,700
there's still chance questions was this

00:15:15,080 --> 00:15:21,320
problematic key you may so the rotted

00:15:19,700 --> 00:15:23,470
about the back report you you sent to

00:15:21,320 --> 00:15:26,240
the package me list

00:15:23,470 --> 00:15:26,870
did you send back report was not yet

00:15:26,240 --> 00:15:30,220
been on yet

00:15:26,870 --> 00:15:38,440
okay so there was nothing okay yeah so

00:15:30,220 --> 00:15:42,140
the the key has a some key packet a

00:15:38,440 --> 00:15:44,870
public subkey packet followed by a user

00:15:42,140 --> 00:15:47,840
ID packet followed by a sub key binding

00:15:44,870 --> 00:15:51,500
sig yeah okay so that sometimes happens

00:15:47,840 --> 00:15:53,450
and GPG sure to reorder it so there's

00:15:51,500 --> 00:15:55,730
very very old code it does reorder it

00:15:53,450 --> 00:15:58,100
but not in the right way so yeah it's

00:15:55,730 --> 00:16:00,890
not always possible to do this so it's

00:15:58,100 --> 00:16:03,980
very limited to a depositor our back fix

00:16:00,890 --> 00:16:06,500
for a key serve I am 15 years ago as

00:16:03,980 --> 00:16:13,100
yeah yeah so it doesn't work perfectly

00:16:06,500 --> 00:16:15,890
so and so I don't know whether it's it's

00:16:13,100 --> 00:16:17,570
Verta time to to a visa rare cases to do

00:16:15,890 --> 00:16:19,640
something about it something yeah I

00:16:17,570 --> 00:16:23,270
don't know what the right thing to do is

00:16:19,640 --> 00:16:26,630
but yeah yeah of course we could do you

00:16:23,270 --> 00:16:28,870
could just did but if you find someone

00:16:26,630 --> 00:16:33,100
who would want to fix this okay so I'm

00:16:28,870 --> 00:16:33,100
expected I'll talk to be cagey

00:16:33,630 --> 00:16:38,339
now it's a lot of work to test this yeah

00:16:36,449 --> 00:16:41,220
that lots of things it's it's not it's

00:16:38,339 --> 00:16:42,779
just possible but we have to receive

00:16:41,220 --> 00:16:52,290
from where to take the time to fix all

00:16:42,779 --> 00:16:57,959
the bugs the router is are we done

00:16:52,290 --> 00:16:59,910
oh one more I should being massively

00:16:57,959 --> 00:17:02,910
self-serving now can you show us an

00:16:59,910 --> 00:17:05,819
example of using H OpenPGP to do

00:17:02,910 --> 00:17:09,120
something trivial something trivial I

00:17:05,819 --> 00:17:18,020
know to input a public key ring and just

00:17:09,120 --> 00:17:18,020
list the keys live demo

00:17:48,520 --> 00:17:58,080
okay the fun's two small islets that was

00:17:55,720 --> 00:17:58,080
about right

00:17:59,900 --> 00:18:03,009
[Music]

00:18:12,950 --> 00:18:23,900
and I can't take

00:18:16,130 --> 00:18:31,250
so it's lists of the keyring with new PG

00:18:23,900 --> 00:18:49,840
like output we can also dump the the

00:18:31,250 --> 00:18:53,620
packets to do to do graphing or

00:18:49,840 --> 00:18:56,570
pathfinding that'll take a few minutes

00:18:53,620 --> 00:18:59,510
so I was actually thinking of the DHS

00:18:56,570 --> 00:19:03,340
file that you could show us oh oh that

00:18:59,510 --> 00:19:03,340
I'm not prepared to do that on the spot

00:19:04,570 --> 00:19:22,010
but you you can you can look at the open

00:19:09,169 --> 00:19:25,309
PGP tools sources or the test suite I I

00:19:22,010 --> 00:19:27,620
would like people to to help out so if

00:19:25,309 --> 00:19:34,000
there's things I can do to make that

00:19:27,620 --> 00:19:40,669
easier please let me know I think I

00:19:34,000 --> 00:19:43,549
certainly would like to have a a better

00:19:40,669 --> 00:19:50,030
library for for Haskell use and

00:19:43,549 --> 00:19:53,900
eventually for use by by other languages

00:19:50,030 --> 00:19:58,309
through the FFI so if if you're

00:19:53,900 --> 00:20:02,659
interested but overwhelmed or confused

00:19:58,309 --> 00:20:09,200
by some of the crazy things please feel

00:20:02,659 --> 00:20:11,360
free to approach me and there are no

00:20:09,200 --> 00:20:13,639
other questions thank you for your time

00:20:11,360 --> 00:20:15,700
thank you very much Kim

00:20:13,639 --> 00:20:15,700

YouTube URL: https://www.youtube.com/watch?v=85eHcqqZF_M


