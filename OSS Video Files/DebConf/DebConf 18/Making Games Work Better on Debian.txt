Title: Making Games Work Better on Debian
Publication date: 2018-07-31
Playlist: DebConf 18
Description: 
	by Keith Packard

At: DebConf18
https://debconf18.debconf.org/talks/15-making-games-work-better-on-debian/

Running games on Debian often means compromising the integrity of our
systems by dual-booting non-free operating systems or installing
non-free drivers on our Debian systems. This presentation will describe
some work sponsored by the Valve Corporation aimed at helping make
this situation better.

We're working on improving the free Mesa implementation of the
Vulkan API for AMD hardware, fixing support for Head Mounted Displays,
and improving X support for animated applications. All of this work is
(naturally) being done in the open within the context of the relevant
free software projects.

Room: Yushan (玉山)
Scheduled start: 2018-07-30 11:00:00
Captions: 
	00:00:04,540 --> 00:00:11,500
yeah good morning welcome to Taiwan this

00:00:10,090 --> 00:00:13,330
is awesome I've been to Taiwan for a

00:00:11,500 --> 00:00:14,920
couple years it's glorious free back the

00:00:13,330 --> 00:00:17,890
food of course is amazing that people

00:00:14,920 --> 00:00:21,610
are friendly the climate is warm and

00:00:17,890 --> 00:00:23,110
inviting maybe a little more than warm

00:00:21,610 --> 00:00:25,150
inviting am I gonna be talking about

00:00:23,110 --> 00:00:27,580
some work that valves been paying me to

00:00:25,150 --> 00:00:29,770
do as a contractor on making gaming

00:00:27,580 --> 00:00:31,649
better in the Debian environment and

00:00:29,770 --> 00:00:34,359
other Linux environments valve has a

00:00:31,649 --> 00:00:36,719
kind of a reasonably long history now

00:00:34,359 --> 00:00:38,979
with working with the Linux community

00:00:36,719 --> 00:00:40,329
they of course are a commercial software

00:00:38,979 --> 00:00:42,309
company and they do a lot of close

00:00:40,329 --> 00:00:44,079
source software but they've realized

00:00:42,309 --> 00:00:46,089
that there's a significant market and a

00:00:44,079 --> 00:00:47,949
profitable market to be made in selling

00:00:46,089 --> 00:00:50,469
their their proprietary software on top

00:00:47,949 --> 00:00:52,239
of free software stacks so there's a

00:00:50,469 --> 00:00:54,069
boundary between what they what they

00:00:52,239 --> 00:00:55,929
what they hold dear and keep private and

00:00:54,069 --> 00:00:57,969
sells commercial close source software

00:00:55,929 --> 00:00:59,499
and what they rapidly and actively

00:00:57,969 --> 00:01:00,969
support the free software community and

00:00:59,499 --> 00:01:03,039
I'm on I'm in the under side of that

00:01:00,969 --> 00:01:06,040
boundary trying to make the Linux

00:01:03,039 --> 00:01:07,630
desktop environment better and to

00:01:06,040 --> 00:01:09,940
support games of all kinds including

00:01:07,630 --> 00:01:12,370
including Valve's games and that's what

00:01:09,940 --> 00:01:13,840
I want to talk about today some of the

00:01:12,370 --> 00:01:16,240
work that I've been doing see if I can

00:01:13,840 --> 00:01:19,330
get this to work so this is about making

00:01:16,240 --> 00:01:21,100
games work better in Debian this is not

00:01:19,330 --> 00:01:22,810
about games in Debian there was an

00:01:21,100 --> 00:01:25,060
awesome talk by Markus yesterday if you

00:01:22,810 --> 00:01:28,420
want to learn about the status of free

00:01:25,060 --> 00:01:30,490
games in in Debian I should go go listen

00:01:28,420 --> 00:01:32,650
to that talk from yesterday this is all

00:01:30,490 --> 00:01:34,330
about hardware support getting the

00:01:32,650 --> 00:01:38,920
operating system and the hardware

00:01:34,330 --> 00:01:42,850
drivers and and kind of the ecosystem

00:01:38,920 --> 00:01:45,670
the 3d driving the 3d graphics ecosystem

00:01:42,850 --> 00:01:47,770
working better for Debian and getting

00:01:45,670 --> 00:01:49,300
games working better there I'm going to

00:01:47,770 --> 00:01:51,310
talk a bit about the current gaming

00:01:49,300 --> 00:01:52,780
environment hardware support and API

00:01:51,310 --> 00:01:55,180
support there's kind of a transition

00:01:52,780 --> 00:01:56,830
going on in the world an API support um

00:01:55,180 --> 00:01:57,820
and then and then later on I'm going to

00:01:56,830 --> 00:01:59,380
talk about the work that I've been

00:01:57,820 --> 00:02:01,240
working on in particular and some other

00:01:59,380 --> 00:02:03,070
work that other people in working on to

00:02:01,240 --> 00:02:05,860
try to make to try to improve the status

00:02:03,070 --> 00:02:08,349
of the world and those are all system

00:02:05,860 --> 00:02:09,909
software stuff I'm I apparently am a

00:02:08,349 --> 00:02:12,069
system software engineer because I've

00:02:09,909 --> 00:02:12,849
been working in system software now for

00:02:12,069 --> 00:02:14,620
about 40 years

00:02:12,849 --> 00:02:16,930
so apparently that's what I do and so

00:02:14,620 --> 00:02:18,370
I'm going to be talking under the

00:02:16,930 --> 00:02:20,930
application

00:02:18,370 --> 00:02:22,130
also playing game games on Linux today

00:02:20,930 --> 00:02:26,870
how many of you play games on your

00:02:22,130 --> 00:02:29,300
Debian desktop a couple yeah I'm not

00:02:26,870 --> 00:02:31,040
among that set I don't really play video

00:02:29,300 --> 00:02:33,680
games kind of the best video game ever

00:02:31,040 --> 00:02:36,380
is is the program called Emacs and

00:02:33,680 --> 00:02:38,120
that's where you write that's that's

00:02:36,380 --> 00:02:39,890
where you get to change how the computer

00:02:38,120 --> 00:02:43,220
works and it's like wow that's a pretty

00:02:39,890 --> 00:02:45,920
cool video kay so other people enjoy

00:02:43,220 --> 00:02:47,930
enjoy enjoy a different kind of video

00:02:45,920 --> 00:02:51,410
gaming and it's fun to watch them play

00:02:47,930 --> 00:02:52,850
I'm kind of of a generation where we

00:02:51,410 --> 00:02:54,140
didn't really have twitch games when I

00:02:52,850 --> 00:02:55,850
was a child and so I really never

00:02:54,140 --> 00:02:59,660
learned how to do that so my skills are

00:02:55,850 --> 00:03:01,610
kind of lacking it is it is fun to watch

00:02:59,660 --> 00:03:03,410
and fun to participate and fun to think

00:03:01,610 --> 00:03:05,300
about the problems that these that these

00:03:03,410 --> 00:03:06,920
interesting interactive graphical

00:03:05,300 --> 00:03:08,540
applications bring to the system so

00:03:06,920 --> 00:03:11,330
that's where that's where I find my

00:03:08,540 --> 00:03:13,190
delight is in solving the problems of

00:03:11,330 --> 00:03:14,930
making these things work because they

00:03:13,190 --> 00:03:16,250
are highly interactive applications I

00:03:14,930 --> 00:03:17,990
mean it used to be the only highly

00:03:16,250 --> 00:03:19,760
interactive graphics applications we had

00:03:17,990 --> 00:03:21,980
where things like flight simulators

00:03:19,760 --> 00:03:23,660
right and it turns out that you can

00:03:21,980 --> 00:03:24,950
apply all the same technologies that we

00:03:23,660 --> 00:03:27,820
use for flight simulators and other

00:03:24,950 --> 00:03:31,460
things and bring that into gaming the

00:03:27,820 --> 00:03:32,870
goals are very similar some of the some

00:03:31,460 --> 00:03:35,840
of the thought processes are very

00:03:32,870 --> 00:03:37,850
different of course there are lots of

00:03:35,840 --> 00:03:39,290
free games available on Debian Marcus

00:03:37,850 --> 00:03:40,820
gave a really good overview of what's

00:03:39,290 --> 00:03:43,340
going on that there's a whole group

00:03:40,820 --> 00:03:45,470
within Debian the Debian games group

00:03:43,340 --> 00:03:47,240
which works on bringing more games into

00:03:45,470 --> 00:03:48,800
the Debian environment there are lots of

00:03:47,240 --> 00:03:51,230
non free games including all those

00:03:48,800 --> 00:03:54,440
available from my from my customer valve

00:03:51,230 --> 00:03:57,020
a valve has supported the steam their

00:03:54,440 --> 00:03:58,670
esteemed platform on on Linux for quite

00:03:57,020 --> 00:04:00,470
a while and I think was 2012 when they

00:03:58,670 --> 00:04:02,030
started doing that and that means you

00:04:00,470 --> 00:04:03,709
can get I think there's like three or

00:04:02,030 --> 00:04:05,420
four thousand games I don't know the

00:04:03,709 --> 00:04:07,010
exact number that are available through

00:04:05,420 --> 00:04:09,200
the steam store that will play on play

00:04:07,010 --> 00:04:11,600
on your Debian system without requiring

00:04:09,200 --> 00:04:13,250
any any other proprietary software other

00:04:11,600 --> 00:04:15,770
than the games on the Steam environment

00:04:13,250 --> 00:04:18,770
and there's also a number of games you

00:04:15,770 --> 00:04:22,070
can play today window a legacy windows

00:04:18,770 --> 00:04:23,360
games things like EVE Online you can

00:04:22,070 --> 00:04:24,680
actually play that through wine today

00:04:23,360 --> 00:04:27,410
and those work surprisingly well and

00:04:24,680 --> 00:04:29,570
that supports improving over time as the

00:04:27,410 --> 00:04:31,490
wine environment gets better and better

00:04:29,570 --> 00:04:33,140
graphic support so there's no real

00:04:31,490 --> 00:04:34,220
fundamental reason why a Windows game

00:04:33,140 --> 00:04:35,630
running through why and wouldn't

00:04:34,220 --> 00:04:38,210
wouldn't be able to offer the same

00:04:35,630 --> 00:04:40,370
performance on Debian as it does on on a

00:04:38,210 --> 00:04:41,900
Microsoft platform so that's that's

00:04:40,370 --> 00:04:44,090
something that some of you can play with

00:04:41,900 --> 00:04:45,590
as well um and the reason the one of the

00:04:44,090 --> 00:04:46,700
important reasons for thinking about

00:04:45,590 --> 00:04:48,680
that is that there are some really old

00:04:46,700 --> 00:04:50,920
games that are really awesome right

00:04:48,680 --> 00:04:53,390
there's some old Windows games you can't

00:04:50,920 --> 00:04:54,800
get the source code to anymore nobody

00:04:53,390 --> 00:04:56,720
has it anymore nobody's gonna be able to

00:04:54,800 --> 00:04:58,670
recompile it and whine offers were

00:04:56,720 --> 00:05:02,330
remarkably but could a remarkably good

00:04:58,670 --> 00:05:05,690
platform for running those and we

00:05:02,330 --> 00:05:07,310
support that of course so the first API

00:05:05,690 --> 00:05:10,640
I want to talk about is OpenGL this is

00:05:07,310 --> 00:05:11,180
really popular 3d API in developed by

00:05:10,640 --> 00:05:15,430
SGI

00:05:11,180 --> 00:05:18,440
as the graphics library back in 1989

00:05:15,430 --> 00:05:21,740
1990 I'm not sure the exact years long

00:05:18,440 --> 00:05:23,600
long long ago eventually became released

00:05:21,740 --> 00:05:28,220
from SGI hardware and kind of generally

00:05:23,600 --> 00:05:30,290
available and then and shortly after SGI

00:05:28,220 --> 00:05:33,080
released the initial specification for

00:05:30,290 --> 00:05:35,750
opengl there was a free software

00:05:33,080 --> 00:05:38,450
implementation by some by some people

00:05:35,750 --> 00:05:40,310
called Mesa and so we've actually had a

00:05:38,450 --> 00:05:43,460
freely available implementation of this

00:05:40,310 --> 00:05:46,310
industry standard API for probably 25

00:05:43,460 --> 00:05:48,530
years now and at first of course it was

00:05:46,310 --> 00:05:50,060
as many free software projects you know

00:05:48,530 --> 00:05:51,290
just just something to be done in the

00:05:50,060 --> 00:05:53,780
spare time and kind of a toy to play

00:05:51,290 --> 00:05:55,010
with I did software rasterization it

00:05:53,780 --> 00:05:57,590
didn't take advantage of the hardware

00:05:55,010 --> 00:05:59,510
and so it wasn't very fast but it proved

00:05:57,590 --> 00:06:02,920
that we could actually come up with a

00:05:59,510 --> 00:06:05,240
completely compliant and and extensible

00:06:02,920 --> 00:06:08,990
implementation of a very sophisticated

00:06:05,240 --> 00:06:11,840
3d rendering API in our environment and

00:06:08,990 --> 00:06:13,670
today actually Mesa is a is one of the

00:06:11,840 --> 00:06:15,800
leading OpenGL implementations in the

00:06:13,670 --> 00:06:17,530
world it really it really is there

00:06:15,800 --> 00:06:19,850
really is at this point Mesa and

00:06:17,530 --> 00:06:22,190
invidious proprietary stuff and those

00:06:19,850 --> 00:06:25,190
are the two kind of kind of premier

00:06:22,190 --> 00:06:28,010
OpenGL implementations on AMD and Intel

00:06:25,190 --> 00:06:30,230
hardware we're at opengl 4.5 it's nearly

00:06:28,010 --> 00:06:32,960
4.6 I think is one more extension to be

00:06:30,230 --> 00:06:35,600
done for OpenGL 4.6 and so we're

00:06:32,960 --> 00:06:37,280
basically at this point we are at the at

00:06:35,600 --> 00:06:40,730
you know we're no longer lagging the

00:06:37,280 --> 00:06:43,240
OpenGL world so Debian provides support

00:06:40,730 --> 00:06:44,800
for current OpenGL

00:06:43,240 --> 00:06:46,750
applications is no more that you no

00:06:44,800 --> 00:06:48,699
longer that you have to say oh I can

00:06:46,750 --> 00:06:51,280
only play older games because Debian

00:06:48,699 --> 00:06:54,130
doesn't support the API is necessary for

00:06:51,280 --> 00:06:56,139
modern games in reality today Debian has

00:06:54,130 --> 00:06:58,720
full support for pretty much every API

00:06:56,139 --> 00:07:00,699
that an applications going to need we

00:06:58,720 --> 00:07:02,919
also have support for embedded the

00:07:00,699 --> 00:07:04,479
embedded version of OpenGL at 3.2 which

00:07:02,919 --> 00:07:07,990
is I think the current the current

00:07:04,479 --> 00:07:09,729
version of that standard and that's

00:07:07,990 --> 00:07:11,550
available on Intel and AMD platforms

00:07:09,729 --> 00:07:13,360
because Mesa has this tremendous

00:07:11,550 --> 00:07:15,099
advantage because it's a free

00:07:13,360 --> 00:07:18,849
implementation that people can play with

00:07:15,099 --> 00:07:21,759
we actually have OpenGL ES and OpenGL

00:07:18,849 --> 00:07:23,110
API implementations in the same library

00:07:21,759 --> 00:07:25,389
that we don't have two implementations

00:07:23,110 --> 00:07:27,880
they don't have an es library and a GL

00:07:25,389 --> 00:07:30,370
library we share the same implementation

00:07:27,880 --> 00:07:33,069
so any place you see OpenGL you will

00:07:30,370 --> 00:07:35,530
also see OpenGL ES which is pretty cool

00:07:33,069 --> 00:07:37,360
they are different they have some you

00:07:35,530 --> 00:07:39,220
know stupid little semantic differences

00:07:37,360 --> 00:07:41,590
between the libraries but because of the

00:07:39,220 --> 00:07:43,590
common code base we actually keep track

00:07:41,590 --> 00:07:45,880
of both of them quite quite actively

00:07:43,590 --> 00:07:47,380
another another really good platform

00:07:45,880 --> 00:07:49,719
that we support quite well in mesas is

00:07:47,380 --> 00:07:52,900
the the Raspberry Pi we using the

00:07:49,719 --> 00:07:55,000
Broadcom chipsets my my close friend

00:07:52,900 --> 00:07:57,669
Erik and Holt actually works for

00:07:55,000 --> 00:07:59,139
Broadcom and supports his entire job is

00:07:57,669 --> 00:08:01,900
supporting free software drivers for

00:07:59,139 --> 00:08:04,000
Mesa for the Broadcom platform so if you

00:08:01,900 --> 00:08:06,130
have a Raspberry Pi you it can actually

00:08:04,000 --> 00:08:07,659
get a free software stack for all the

00:08:06,130 --> 00:08:09,430
rendering there's still some firmware

00:08:07,659 --> 00:08:11,409
requirements for mode setting and he's

00:08:09,430 --> 00:08:14,080
working on that but it's that

00:08:11,409 --> 00:08:15,880
environment is a challenge but it's kind

00:08:14,080 --> 00:08:17,530
of certainly a interesting challenge to

00:08:15,880 --> 00:08:20,710
work on so we actually have competent

00:08:17,530 --> 00:08:25,630
support for OpenGL s GL es on that

00:08:20,710 --> 00:08:27,819
platform and a lot of OpenGL but if the

00:08:25,630 --> 00:08:29,469
the existing Raspberry Pi hardware is

00:08:27,819 --> 00:08:32,229
limited in some fundamental ways and you

00:08:29,469 --> 00:08:34,450
can't actually do opengl 4.5 on that

00:08:32,229 --> 00:08:36,219
hardware but it's actually surprisingly

00:08:34,450 --> 00:08:38,020
close and there's a lot of good a lot of

00:08:36,219 --> 00:08:40,539
cool work that's been done there there's

00:08:38,020 --> 00:08:42,820
also a reverse-engineered Nvidia driver

00:08:40,539 --> 00:08:47,050
called Nouveau and that actually

00:08:42,820 --> 00:08:49,149
supports opengl 4.5 4.2 4.3 maybe higher

00:08:47,050 --> 00:08:50,980
than that the fundamental problem with

00:08:49,149 --> 00:08:53,920
new Vosges because there's no support

00:08:50,980 --> 00:08:56,710
from nvidia for this at all it's it

00:08:53,920 --> 00:08:58,630
offers very limited performance

00:08:56,710 --> 00:09:01,060
and hardware compatibility so it's it's

00:08:58,630 --> 00:09:02,320
usually only supports older hardware it

00:09:01,060 --> 00:09:06,400
doesn't support it at full performance

00:09:02,320 --> 00:09:08,320
in particular it has severe limits and

00:09:06,400 --> 00:09:10,960
how it can how it could do thermal

00:09:08,320 --> 00:09:13,450
management and and memory memory timing

00:09:10,960 --> 00:09:16,060
modifications so while I love the

00:09:13,450 --> 00:09:17,620
nouveau project because NVIDIA doesn't

00:09:16,060 --> 00:09:19,330
support it it really has some

00:09:17,620 --> 00:09:20,800
fundamental limitations which makes it

00:09:19,330 --> 00:09:23,260
very difficult to use in a gaming

00:09:20,800 --> 00:09:25,240
environment especially so if you want to

00:09:23,260 --> 00:09:26,740
do gaming in Debian you really have to

00:09:25,240 --> 00:09:28,240
strong choices both of which are

00:09:26,740 --> 00:09:29,770
supported by the hardware manufacturers

00:09:28,240 --> 00:09:31,840
in free software and that's the Intel

00:09:29,770 --> 00:09:33,520
and AMD so I recommend you purchase that

00:09:31,840 --> 00:09:34,930
hardware if you have a Raspberry Pi you

00:09:33,520 --> 00:09:37,450
can play there too it's a little more

00:09:34,930 --> 00:09:38,830
difficult some of the getting the free

00:09:37,450 --> 00:09:42,250
software drivers running at a Raspberry

00:09:38,830 --> 00:09:44,110
Pi takes a bit of work right now there

00:09:42,250 --> 00:09:46,240
are some other some other things reverse

00:09:44,110 --> 00:09:48,940
engineering mostly going on of Avanti

00:09:46,240 --> 00:09:50,200
Adreno and the Tegra x1 these are all

00:09:48,940 --> 00:09:53,170
being reverse engineered and they have

00:09:50,200 --> 00:09:54,910
various levels of OpenGL support if you

00:09:53,170 --> 00:09:56,980
wanted play with these it's fun to play

00:09:54,910 --> 00:09:58,030
with again these are reverse-engineered

00:09:56,980 --> 00:10:00,730
they're not supported by the hardware

00:09:58,030 --> 00:10:02,650
vendors so unless that's what you want

00:10:00,730 --> 00:10:04,120
to do which is to say you really want to

00:10:02,650 --> 00:10:06,130
do reverse engineering and that's an

00:10:04,120 --> 00:10:07,840
interesting thing to play with

00:10:06,130 --> 00:10:09,670
I wouldn't recommend trying to use these

00:10:07,840 --> 00:10:12,660
for gaming because they just aren't well

00:10:09,670 --> 00:10:15,160
supported but they are it is an awesome

00:10:12,660 --> 00:10:17,320
task to go in and like figure out what

00:10:15,160 --> 00:10:18,280
the opcodes mean and and figure out what

00:10:17,320 --> 00:10:20,380
the various bits and the rendering

00:10:18,280 --> 00:10:21,850
engine do so if that's the kind of video

00:10:20,380 --> 00:10:24,760
game you like here's some awesome

00:10:21,850 --> 00:10:26,230
platforms to play that game on I think

00:10:24,760 --> 00:10:28,810
that's a fun thing to play with there's

00:10:26,230 --> 00:10:29,980
a new API coming into town it's called

00:10:28,810 --> 00:10:33,460
Vulcan how many of you have heard of the

00:10:29,980 --> 00:10:36,700
Vulcan rendering API okay awesome

00:10:33,460 --> 00:10:39,040
so it's very different from OpenGL in

00:10:36,700 --> 00:10:40,990
some ways and very similar to OpenGL in

00:10:39,040 --> 00:10:43,390
other ways it's much closer to the

00:10:40,990 --> 00:10:46,150
hardware it exposes a lot more of the

00:10:43,390 --> 00:10:48,820
hardware vagaries and variances to the

00:10:46,150 --> 00:10:50,470
application and of course game

00:10:48,820 --> 00:10:52,360
developers think this is awesome because

00:10:50,470 --> 00:10:54,880
then they can tweak their games for the

00:10:52,360 --> 00:10:57,850
underlying platform um it actually has

00:10:54,880 --> 00:10:59,740
some advantages over OpenGL and that the

00:10:57,850 --> 00:11:01,360
behavior is much more tightly specified

00:10:59,740 --> 00:11:03,400
and there's a test suite for it that is

00:11:01,360 --> 00:11:05,560
required for to get branding and that

00:11:03,400 --> 00:11:08,650
means that the variants of volcán

00:11:05,560 --> 00:11:10,230
behavior between vendors is exposed in

00:11:08,650 --> 00:11:12,720
the API and small

00:11:10,230 --> 00:11:15,030
than you see in OpenGL so with with in

00:11:12,720 --> 00:11:16,950
OpenGL many games are designed to only

00:11:15,030 --> 00:11:18,540
work or design primarily to work with

00:11:16,950 --> 00:11:21,420
NVIDIA hardware or potentially with the

00:11:18,540 --> 00:11:22,650
AMD closed-source drivers and as a

00:11:21,420 --> 00:11:24,120
result when you run them against Mesa

00:11:22,650 --> 00:11:25,530
Mesa it's like hey you're not following

00:11:24,120 --> 00:11:27,210
this Beck here I'm gonna throw an error

00:11:25,530 --> 00:11:30,570
and and your applications not going to

00:11:27,210 --> 00:11:31,620
work developers of course think think

00:11:30,570 --> 00:11:34,020
that's awesome because our

00:11:31,620 --> 00:11:36,210
implementation is much more much more

00:11:34,020 --> 00:11:38,160
rigorously applies to these standards

00:11:36,210 --> 00:11:40,170
than the Nvidia implementation game

00:11:38,160 --> 00:11:41,010
players on the other hand aren't very

00:11:40,170 --> 00:11:43,290
excited by that

00:11:41,010 --> 00:11:44,970
because then their games just don't work

00:11:43,290 --> 00:11:47,190
because they're their games are

00:11:44,970 --> 00:11:48,720
expecting the the looseness of the

00:11:47,190 --> 00:11:49,770
Nvidia implementation Volken on the

00:11:48,720 --> 00:11:52,020
other hand is much more tightly

00:11:49,770 --> 00:11:54,380
specified so the variance between the

00:11:52,020 --> 00:11:56,730
various implementations are smaller

00:11:54,380 --> 00:11:58,170
Intel and AMD are the two supported

00:11:56,730 --> 00:12:00,240
Vulcan platforms right now so if you

00:11:58,170 --> 00:12:02,640
have a modern Intel chip I think it's

00:12:00,240 --> 00:12:04,410
passed skylake I think I have a I think

00:12:02,640 --> 00:12:06,420
you have the implementation pass sky

00:12:04,410 --> 00:12:08,790
like so it's not older Intel chips it's

00:12:06,420 --> 00:12:10,920
modern Intel chips and modern AMD chips

00:12:08,790 --> 00:12:12,600
and that's largely because of the

00:12:10,920 --> 00:12:14,580
requirements that Vulcan places on the

00:12:12,600 --> 00:12:17,280
chip in terms of what it does and how it

00:12:14,580 --> 00:12:18,990
operates and so it's not likely that

00:12:17,280 --> 00:12:20,940
we're gonna get support for older chips

00:12:18,990 --> 00:12:24,300
at any time just because the hardware

00:12:20,940 --> 00:12:26,160
can't do that it is a lower level API it

00:12:24,300 --> 00:12:27,660
offers significant advantages for the

00:12:26,160 --> 00:12:29,220
applications in terms of being able to

00:12:27,660 --> 00:12:31,650
manage the hardware and being able to

00:12:29,220 --> 00:12:33,780
squeeze out every bit of performance so

00:12:31,650 --> 00:12:35,310
as games migrate from OpenGL to Vulcan

00:12:33,780 --> 00:12:37,050
you can see them and you can you can

00:12:35,310 --> 00:12:39,450
watch them improve in performance in

00:12:37,050 --> 00:12:42,300
particular they take much less of the

00:12:39,450 --> 00:12:44,280
CPU inside the library in an OpenGL

00:12:42,300 --> 00:12:46,350
implementation there's this vast

00:12:44,280 --> 00:12:48,120
semantic gap between what the API

00:12:46,350 --> 00:12:50,430
provides and what the hardware does and

00:12:48,120 --> 00:12:51,960
so that library has to sit there and try

00:12:50,430 --> 00:12:53,610
to effectively figure out what the

00:12:51,960 --> 00:12:56,010
application wanted the hardware to do

00:12:53,610 --> 00:12:57,960
through the API and then you know stand

00:12:56,010 --> 00:13:00,120
on its head and turn around three times

00:12:57,960 --> 00:13:02,160
in order to get that the hardware to do

00:13:00,120 --> 00:13:03,930
what the application wanted and Vulcan

00:13:02,160 --> 00:13:06,480
narrows the semantic gap between the

00:13:03,930 --> 00:13:08,310
application and the hardware and reduces

00:13:06,480 --> 00:13:10,710
the CPU overhead everywhere so it's a

00:13:08,310 --> 00:13:13,260
pretty nice API I've been doing a bunch

00:13:10,710 --> 00:13:15,150
of work in Vulcan because one of the

00:13:13,260 --> 00:13:16,650
things is that valve is doing is

00:13:15,150 --> 00:13:18,330
aggressively moving a lot of their code

00:13:16,650 --> 00:13:22,559
to Vulcan because of these performance

00:13:18,330 --> 00:13:24,720
and functionality advantages

00:13:22,559 --> 00:13:26,729
let's see non-free API about NVIDIA

00:13:24,720 --> 00:13:28,290
ships binary-only drivers whoo-hoo I'm

00:13:26,729 --> 00:13:29,850
not gonna ask it's just too embarrassing

00:13:28,290 --> 00:13:32,040
I don't wanna know who uses the binary

00:13:29,850 --> 00:13:33,569
drivers there is not very much

00:13:32,040 --> 00:13:35,249
collaboration with the Debian community

00:13:33,569 --> 00:13:38,279
and if you install these drivers on your

00:13:35,249 --> 00:13:40,319
system you will get you will get a lack

00:13:38,279 --> 00:13:41,669
of support from like Red Hat if you

00:13:40,319 --> 00:13:43,529
install these drivers on a Red Hat

00:13:41,669 --> 00:13:44,999
system oh sorry you installed in video

00:13:43,529 --> 00:13:47,069
binders we will offer you no support for

00:13:44,999 --> 00:13:49,169
that so you can understand what people

00:13:47,069 --> 00:13:50,459
think about these one of the big things

00:13:49,169 --> 00:13:53,429
that I started doing it valve was

00:13:50,459 --> 00:13:56,759
working with please head mounted

00:13:53,429 --> 00:13:58,619
displays are fun you put them on and the

00:13:56,759 --> 00:14:00,179
real world disappears and you can

00:13:58,619 --> 00:14:02,100
construct whatever virtual world you

00:14:00,179 --> 00:14:04,109
like obviously the use for a virtual

00:14:02,100 --> 00:14:05,669
reality inside the head-mounted display

00:14:04,109 --> 00:14:08,489
there's an IMU a little inertial

00:14:05,669 --> 00:14:09,989
measurement unit that figures out where

00:14:08,489 --> 00:14:12,989
you are in space what and what direction

00:14:09,989 --> 00:14:16,679
you're pointing they use these little

00:14:12,989 --> 00:14:18,359
these little they're called lighthouses

00:14:16,679 --> 00:14:20,639
these little rectangular these little

00:14:18,359 --> 00:14:23,879
cubes set up on the wall or on a shelf

00:14:20,639 --> 00:14:27,449
to actually orient the device absolutely

00:14:23,879 --> 00:14:29,730
and in space and it's pretty cool valve

00:14:27,449 --> 00:14:31,169
did almost all the implementation or all

00:14:29,730 --> 00:14:33,089
the almost all the design of this

00:14:31,169 --> 00:14:34,769
hardware it's a pretty it's a pretty

00:14:33,089 --> 00:14:36,959
cool design I don't know what the what

00:14:34,769 --> 00:14:38,850
they've published on it but I got to go

00:14:36,959 --> 00:14:40,139
and play with the hardware designers who

00:14:38,850 --> 00:14:42,269
were showing me how this thing worked it

00:14:40,139 --> 00:14:44,639
was like wow there's nothing inside this

00:14:42,269 --> 00:14:46,829
box and it provides you sub centimeter

00:14:44,639 --> 00:14:50,279
resolution in position with basically no

00:14:46,829 --> 00:14:54,629
hardware which is always cool inside the

00:14:50,279 --> 00:14:59,339
display there's a there is a single

00:14:54,629 --> 00:15:00,509
panel I think it's a 1k or two I don't

00:14:59,339 --> 00:15:02,189
remember the resolution the panel is

00:15:00,509 --> 00:15:04,859
like 2 K by 1k or something it's a

00:15:02,189 --> 00:15:06,749
strange resolution there are a bunch of

00:15:04,859 --> 00:15:08,579
optics in there because the panel is

00:15:06,749 --> 00:15:11,039
about you know 4 centimeters from your

00:15:08,579 --> 00:15:13,199
eyeballs and I don't know about you but

00:15:11,039 --> 00:15:15,029
I can't for focus that close anymore so

00:15:13,199 --> 00:15:16,679
they put some optics in there to make

00:15:15,029 --> 00:15:19,109
the panel appear further away from you

00:15:16,679 --> 00:15:20,879
and to make the make they make the

00:15:19,109 --> 00:15:24,029
fusion of your vision work correctly

00:15:20,879 --> 00:15:25,739
with two separate views the result of

00:15:24,029 --> 00:15:28,859
that is that there is a bunch of

00:15:25,739 --> 00:15:31,079
distortion of the image coming into your

00:15:28,859 --> 00:15:32,999
eyeball from the panel's so you're not

00:15:31,079 --> 00:15:34,499
seeing the pant the panels don't just

00:15:32,999 --> 00:15:35,580
get translated right into your eyeball

00:15:34,499 --> 00:15:38,610
there's a bunch of optical too

00:15:35,580 --> 00:15:40,680
tortion they could have spent a pile of

00:15:38,610 --> 00:15:43,530
money and put put a nice thick and heavy

00:15:40,680 --> 00:15:45,650
lens stack inside the optics inside the

00:15:43,530 --> 00:15:49,110
inside the head 9 and unit to make that

00:15:45,650 --> 00:15:52,170
to make the the optics nice and nice and

00:15:49,110 --> 00:15:54,660
non distorted but they decided as is

00:15:52,170 --> 00:15:56,580
often the case in our world that it was

00:15:54,660 --> 00:16:01,290
cheaper and better to do that in

00:15:56,580 --> 00:16:03,240
software so yeah thanks guys so as a

00:16:01,290 --> 00:16:04,710
result there's actually a steaming pile

00:16:03,240 --> 00:16:06,990
of software that gets between the

00:16:04,710 --> 00:16:09,120
application which is constructing these

00:16:06,990 --> 00:16:11,010
2i views between the application and the

00:16:09,120 --> 00:16:12,690
actual presentation of the image to the

00:16:11,010 --> 00:16:15,540
user and that's called the the VR

00:16:12,690 --> 00:16:18,120
compositor so the application if the

00:16:15,540 --> 00:16:20,220
application generates a view for each

00:16:18,120 --> 00:16:22,620
eye and then the VR compositor takes

00:16:20,220 --> 00:16:25,020
those images and actually gets them into

00:16:22,620 --> 00:16:26,520
the into the display so you see this you

00:16:25,020 --> 00:16:30,330
we've interposed another piece of

00:16:26,520 --> 00:16:31,770
software here so now that we kind of

00:16:30,330 --> 00:16:33,960
introduced the current state of the

00:16:31,770 --> 00:16:36,000
world there's a couple of things in my

00:16:33,960 --> 00:16:37,350
world that are kind of the big issues

00:16:36,000 --> 00:16:39,660
for us that we're working on right now

00:16:37,350 --> 00:16:42,690
obviously we're doing a pile of software

00:16:39,660 --> 00:16:45,990
to do virtual reality support and then

00:16:42,690 --> 00:16:48,240
there's also this broader issue that

00:16:45,990 --> 00:16:50,490
occurs across all gaming about Studdard

00:16:48,240 --> 00:16:54,360
how many of you have played a game and

00:16:50,490 --> 00:16:56,520
as you pan across the scene or move

00:16:54,360 --> 00:16:58,320
forward you see the the scene kind of

00:16:56,520 --> 00:16:59,970
jerking occasionally and stopping and

00:16:58,320 --> 00:17:01,680
moving in weird ways how many of how

00:16:59,970 --> 00:17:03,540
many have seen that when they're playing

00:17:01,680 --> 00:17:07,650
a video game yeah pretty reasonably

00:17:03,540 --> 00:17:09,720
common one of one of my friends from

00:17:07,650 --> 00:17:11,640
Croteam actually put out a post on that

00:17:09,720 --> 00:17:13,199
and I thought I had a link in the

00:17:11,640 --> 00:17:15,780
presentation I'll see if I can find that

00:17:13,199 --> 00:17:18,540
that describes what the problem is and

00:17:15,780 --> 00:17:21,060
why why it's actually becoming why it's

00:17:18,540 --> 00:17:23,220
not getting fixed anytime soon or hasn't

00:17:21,060 --> 00:17:24,720
been fixed recently and what that

00:17:23,220 --> 00:17:26,100
problem stems from and I'm gonna I'm

00:17:24,720 --> 00:17:28,170
going to talk about that a minute and

00:17:26,100 --> 00:17:29,730
the other change that's happened in the

00:17:28,170 --> 00:17:31,890
last 10 years or so is that people have

00:17:29,730 --> 00:17:33,900
moved from direct display window systems

00:17:31,890 --> 00:17:36,360
or clipped window systems to composited

00:17:33,900 --> 00:17:37,950
window systems that makes it possible to

00:17:36,360 --> 00:17:39,930
do all kinds of shiny eye candy in your

00:17:37,950 --> 00:17:41,910
desktop and it makes gaming really hard

00:17:39,930 --> 00:17:44,670
and I'll talk about why that's such a

00:17:41,910 --> 00:17:46,080
pain so virtual reality Debian there's

00:17:44,670 --> 00:17:49,480
kind of three main virtual reality

00:17:46,080 --> 00:17:51,669
systems open HMD this is free software

00:17:49,480 --> 00:17:54,039
head-mounted displays um it doesn't have

00:17:51,669 --> 00:17:55,690
great support for current hardware there

00:17:54,039 --> 00:17:58,480
are some reverse engineering efforts

00:17:55,690 --> 00:18:00,760
going under being undertaken I think the

00:17:58,480 --> 00:18:03,130
data that's in the HTC vive is pretty

00:18:00,760 --> 00:18:05,820
easy to parse it's got like JSON or XML

00:18:03,130 --> 00:18:08,049
description of the of the of the display

00:18:05,820 --> 00:18:10,090
figuring out how the lighthouses work

00:18:08,049 --> 00:18:12,309
and how that data is is transmitted is a

00:18:10,090 --> 00:18:15,010
bunch of work and I I would love to see

00:18:12,309 --> 00:18:17,019
more more support for that in open hmd

00:18:15,010 --> 00:18:19,029
but it's not quite there yet there's

00:18:17,019 --> 00:18:21,279
another software stack called the OS vr

00:18:19,029 --> 00:18:23,470
the open source virtual reality it's

00:18:21,279 --> 00:18:27,159
somewhat open and what they're trying to

00:18:23,470 --> 00:18:28,600
do is is take take more of the of the

00:18:27,159 --> 00:18:30,399
the stuff that's in the steamvr

00:18:28,600 --> 00:18:32,889
environment and kind of somehow

00:18:30,399 --> 00:18:34,990
interpose a different software stack I

00:18:32,889 --> 00:18:36,190
really haven't looked at open OS VR I

00:18:34,990 --> 00:18:38,409
just kind of found out about it last

00:18:36,190 --> 00:18:40,090
week and started poking around but open

00:18:38,409 --> 00:18:42,460
8h MD is actually pretty well documented

00:18:40,090 --> 00:18:44,559
and you can actually use open hmd with

00:18:42,460 --> 00:18:45,630
existing hit head-mounted displays and

00:18:44,559 --> 00:18:47,620
start playing with virtual reality

00:18:45,630 --> 00:18:49,960
totally in free software which of course

00:18:47,620 --> 00:18:52,299
is awesome the one that I've been

00:18:49,960 --> 00:18:55,299
helping but not really working on is

00:18:52,299 --> 00:18:57,279
steamvr it's it's closed source it has

00:18:55,299 --> 00:18:59,110
but it does have full support for the

00:18:57,279 --> 00:19:01,090
HTC vive headset so if you're if you're

00:18:59,110 --> 00:19:02,710
playing in Debian and you don't mind

00:19:01,090 --> 00:19:04,419
using a little bit of closed source user

00:19:02,710 --> 00:19:06,490
space software you can actually do you

00:19:04,419 --> 00:19:08,950
can actually play with the the HTC vive

00:19:06,490 --> 00:19:11,500
headset using the steam stuff which is

00:19:08,950 --> 00:19:12,940
pretty cool and so that does all the

00:19:11,500 --> 00:19:17,740
lighthouse supports you have absolute

00:19:12,940 --> 00:19:19,960
position and orientation ok so last year

00:19:17,740 --> 00:19:21,370
I don't know if I presented it I don't

00:19:19,960 --> 00:19:22,929
think I presented this at Deb comp I

00:19:21,370 --> 00:19:25,899
presented at a bunch of places about

00:19:22,929 --> 00:19:27,669
this display leasing and the goal for

00:19:25,899 --> 00:19:29,470
this was to it was to solve that

00:19:27,669 --> 00:19:31,870
composited window system problem and

00:19:29,470 --> 00:19:33,250
more by getting the window system out of

00:19:31,870 --> 00:19:34,720
the way for head-mounted displays and

00:19:33,250 --> 00:19:37,059
we've actually got that all implemented

00:19:34,720 --> 00:19:38,529
now it's an available in the upstream

00:19:37,059 --> 00:19:40,750
Linux kernel it's available in the

00:19:38,529 --> 00:19:43,000
kernel that's in Debian and stable it's

00:19:40,750 --> 00:19:46,299
in the X Window System sources that are

00:19:43,000 --> 00:19:48,039
in Debian unstable and it's most of the

00:19:46,299 --> 00:19:49,690
work is in I think I think it's yeah

00:19:48,039 --> 00:19:52,600
most of the work is available in Mesa as

00:19:49,690 --> 00:19:55,899
well so this parts all done so this this

00:19:52,600 --> 00:19:57,309
adds support for taking a monitor that's

00:19:55,899 --> 00:19:59,019
in your environment and saying hey

00:19:57,309 --> 00:20:00,720
Window System yeah that's not yours

00:19:59,019 --> 00:20:02,850
anymore let go of that let me borrow

00:20:00,720 --> 00:20:05,460
and communicate directly with a kernel

00:20:02,850 --> 00:20:07,289
and this this means that the the virtual

00:20:05,460 --> 00:20:09,630
reality environment can can manipulate

00:20:07,289 --> 00:20:11,400
that display directly and gets rid of a

00:20:09,630 --> 00:20:13,860
lot of latency and a lot of uncertainty

00:20:11,400 --> 00:20:16,440
in the environment that's been

00:20:13,860 --> 00:20:18,470
surprisingly successful we actually have

00:20:16,440 --> 00:20:21,659
it up and running now and the steam VR

00:20:18,470 --> 00:20:23,010
application support set open HMV should

00:20:21,659 --> 00:20:25,860
be able to support that without too much

00:20:23,010 --> 00:20:27,780
work it's really not that big a deal and

00:20:25,860 --> 00:20:29,730
so I'm hoping that it's gonna become

00:20:27,780 --> 00:20:32,549
more prevalent I would like to figure

00:20:29,730 --> 00:20:34,380
out if we can use this for non hmd gains

00:20:32,549 --> 00:20:36,960
as well because of the because of the

00:20:34,380 --> 00:20:39,090
performance advantages that offers when

00:20:36,960 --> 00:20:41,039
Microsoft Windows has a similar system

00:20:39,090 --> 00:20:43,080
where you get to do something similar in

00:20:41,039 --> 00:20:45,090
their environment I would love to just

00:20:43,080 --> 00:20:47,250
be able to adopt a lot of the same API s

00:20:45,090 --> 00:20:49,260
and functionality from their world and C

00:20:47,250 --> 00:20:51,900
games using this directly because it's

00:20:49,260 --> 00:20:54,480
you know it's you save a millisecond or

00:20:51,900 --> 00:20:57,090
two per frame and for those of us who

00:20:54,480 --> 00:20:59,610
work in in interactive graphics that's

00:20:57,090 --> 00:21:01,500
kind of a lot of GPU time that you that

00:20:59,610 --> 00:21:05,220
you that you get back so you can do a

00:21:01,500 --> 00:21:08,520
lot of cool stuff in that so that's all

00:21:05,220 --> 00:21:12,120
available now so what we did for what I

00:21:08,520 --> 00:21:14,010
did to support steamvr was just all that

00:21:12,120 --> 00:21:17,789
I really needed to do was implement like

00:21:14,010 --> 00:21:19,710
half a dozen Vulcan extensions and but

00:21:17,789 --> 00:21:22,289
of course when you implement a extension

00:21:19,710 --> 00:21:24,240
in an API you have to implement all the

00:21:22,289 --> 00:21:26,549
all the framework and scaffolding

00:21:24,240 --> 00:21:27,960
underneath that API in order to make it

00:21:26,549 --> 00:21:30,090
work so I started down in the Linux

00:21:27,960 --> 00:21:32,070
kernel we added some stuff to that we

00:21:30,090 --> 00:21:33,480
had the stuff to the X Window System and

00:21:32,070 --> 00:21:35,549
now we've added stuff into the end of

00:21:33,480 --> 00:21:37,289
the Mesa volcán implementation there's a

00:21:35,549 --> 00:21:39,539
little more work that I need to do here

00:21:37,289 --> 00:21:41,159
there's a new extension that's called

00:21:39,539 --> 00:21:42,980
the google display timing extension that

00:21:41,159 --> 00:21:44,669
lets us get some information about

00:21:42,980 --> 00:21:46,530
presentation that we need to work

00:21:44,669 --> 00:21:48,419
there's Chronos who's working on a

00:21:46,530 --> 00:21:50,909
similar extension I don't think that's

00:21:48,419 --> 00:21:52,740
and so eventually that will come out and

00:21:50,909 --> 00:21:56,010
we'll get that integrated into into into

00:21:52,740 --> 00:21:59,669
into Mesa and that will help help with

00:21:56,010 --> 00:22:01,140
help finish off that work and then

00:21:59,669 --> 00:22:02,730
there's another mechanism by working on

00:22:01,140 --> 00:22:06,330
within Chronos it's gonna that's going

00:22:02,730 --> 00:22:06,929
to help help the VR system not get too

00:22:06,330 --> 00:22:08,789
far ahead

00:22:06,929 --> 00:22:11,340
right now the VR system just starts

00:22:08,789 --> 00:22:12,870
presenting frames and it hopes that the

00:22:11,340 --> 00:22:14,580
each frame is going to take less than

00:22:12,870 --> 00:22:16,289
less than one frame time to

00:22:14,580 --> 00:22:18,840
compute and display but it has no way of

00:22:16,289 --> 00:22:20,490
knowing if that's true because the

00:22:18,840 --> 00:22:22,649
Vulkan API is are like they have this

00:22:20,490 --> 00:22:25,169
gap it's like yeah asked us to present a

00:22:22,649 --> 00:22:26,610
frame and we'll present it sometime and

00:22:25,169 --> 00:22:28,260
then sometime later will appear to the

00:22:26,610 --> 00:22:29,970
user and you can't find out when that

00:22:28,260 --> 00:22:32,789
happened so there's a bunch of stuff

00:22:29,970 --> 00:22:36,510
actually working on getting that support

00:22:32,789 --> 00:22:38,789
into into volcán okay I want to talk a

00:22:36,510 --> 00:22:41,640
bit about stutter so it's a jumping or

00:22:38,789 --> 00:22:44,429
jerking in animation and it's there's

00:22:41,640 --> 00:22:46,350
really two fundamental causes of this um

00:22:44,429 --> 00:22:48,269
and one of these really surprised me and

00:22:46,350 --> 00:22:50,700
that's the one that's the one we're

00:22:48,269 --> 00:22:52,710
working on fixing so you can either draw

00:22:50,700 --> 00:22:55,350
the wrong thing at the right time so

00:22:52,710 --> 00:22:59,039
what in an animation what you're trying

00:22:55,350 --> 00:23:01,740
to do is present the correct a the

00:22:59,039 --> 00:23:03,059
correct motion on the screen and you get

00:23:01,740 --> 00:23:04,740
you know you present a frame and you

00:23:03,059 --> 00:23:07,889
wait 16 milliseconds you present another

00:23:04,740 --> 00:23:10,289
frame you have to predict what what you

00:23:07,889 --> 00:23:12,210
need to present in each frame so that

00:23:10,289 --> 00:23:13,889
you draw the correct thing there so you

00:23:12,210 --> 00:23:15,450
can either draw the wrong thing at the

00:23:13,889 --> 00:23:17,760
right time or you can draw the right

00:23:15,450 --> 00:23:20,639
thing at the wrong time and that usually

00:23:17,760 --> 00:23:23,399
that usually comes from drawing too much

00:23:20,639 --> 00:23:25,590
in a frame and missing a frame but it

00:23:23,399 --> 00:23:27,750
actually can come from from not having

00:23:25,590 --> 00:23:29,880
enough control over win frames are

00:23:27,750 --> 00:23:33,389
presented and ending at presenting a

00:23:29,880 --> 00:23:34,830
frame early so that happens as well so

00:23:33,389 --> 00:23:37,649
this is what happens when you're when

00:23:34,830 --> 00:23:40,110
you when you miss estimate when you draw

00:23:37,649 --> 00:23:41,399
the right thing at the wrong time so you

00:23:40,110 --> 00:23:42,990
can see in this little little

00:23:41,399 --> 00:23:45,000
demonstration on the top you can see the

00:23:42,990 --> 00:23:47,370
the system is estimating the time

00:23:45,000 --> 00:23:49,440
between frames exactly 16 milliseconds

00:23:47,370 --> 00:23:51,480
apart and so it's drawing us it's

00:23:49,440 --> 00:23:53,760
smoothly drawing the objects of the

00:23:51,480 --> 00:23:55,500
correct location in every frame and the

00:23:53,760 --> 00:23:58,409
wrong frame it's actually s miss

00:23:55,500 --> 00:24:00,269
estimating the interval the display time

00:23:58,409 --> 00:24:02,789
interval and it's saying oh this object

00:24:00,269 --> 00:24:04,830
the the frame time between these two

00:24:02,789 --> 00:24:06,899
frames is 20 milliseconds so I need to

00:24:04,830 --> 00:24:08,309
draw this thing you know further to the

00:24:06,899 --> 00:24:10,909
right because the animation is further

00:24:08,309 --> 00:24:13,049
to the right and so you see this this

00:24:10,909 --> 00:24:15,899
discontinuity between the location of

00:24:13,049 --> 00:24:17,309
the object the the time that the user is

00:24:15,899 --> 00:24:19,200
presented the object and the time the

00:24:17,309 --> 00:24:21,720
system thought the user was going to be

00:24:19,200 --> 00:24:25,010
presented this object and this this is

00:24:21,720 --> 00:24:28,530
this is just a gap in the API support

00:24:25,010 --> 00:24:30,450
for display timing the applications have

00:24:28,530 --> 00:24:32,820
way of knowing when displays are going

00:24:30,450 --> 00:24:34,290
to be presented and they often miss

00:24:32,820 --> 00:24:35,730
estimate when that's gonna happen and

00:24:34,290 --> 00:24:37,770
see these you see these little tears

00:24:35,730 --> 00:24:39,900
even though the application is drawing

00:24:37,770 --> 00:24:44,010
60 frames per second it drew the wrong

00:24:39,900 --> 00:24:45,240
thing and it looks terrible the other

00:24:44,010 --> 00:24:46,890
thing that happens is you get a

00:24:45,240 --> 00:24:49,560
rendering under run which is to say you

00:24:46,890 --> 00:24:51,390
queue too much drawing to happen before

00:24:49,560 --> 00:24:53,970
the before the frame needs to be

00:24:51,390 --> 00:24:56,430
displayed and because we can only start

00:24:53,970 --> 00:24:58,410
displaying frame at the top of the top

00:24:56,430 --> 00:25:00,360
of the interval we can't typically these

00:24:58,410 --> 00:25:02,880
days we can't start displaying a frame

00:25:00,360 --> 00:25:05,280
in the middle of a V blank in the middle

00:25:02,880 --> 00:25:07,290
of a refresh cycle so we have to wait

00:25:05,280 --> 00:25:09,240
for the next refresh cycle and so now

00:25:07,290 --> 00:25:11,850
we've computed a frame and we have and

00:25:09,240 --> 00:25:14,130
we can either not display it at all or

00:25:11,850 --> 00:25:17,430
we can wait for a frame and display it

00:25:14,130 --> 00:25:20,130
late and those are your two choices so

00:25:17,430 --> 00:25:21,420
so this happens in for several different

00:25:20,130 --> 00:25:23,490
reasons one of the ways it happens

00:25:21,420 --> 00:25:26,130
obviously if the scene complexity

00:25:23,490 --> 00:25:28,200
increases dramatically like you fire a

00:25:26,130 --> 00:25:29,790
bunch of bullets and you have lots of

00:25:28,200 --> 00:25:31,260
explosions on the screen and the GPU

00:25:29,790 --> 00:25:33,420
sitting there computing lots of fire

00:25:31,260 --> 00:25:34,800
that's a really common thing you know

00:25:33,420 --> 00:25:36,000
and and some people actually think

00:25:34,800 --> 00:25:38,160
that's kind of amusing you know you get

00:25:36,000 --> 00:25:41,280
a lot of explosions and all sudden that

00:25:38,160 --> 00:25:42,870
the the scene goes dirt dirt and it's

00:25:41,280 --> 00:25:44,400
like wow exciting things are happening

00:25:42,870 --> 00:25:46,980
because we can barely see what's going

00:25:44,400 --> 00:25:49,350
on so that's that's kind of the classic

00:25:46,980 --> 00:25:50,940
mechanism the other another mechanism

00:25:49,350 --> 00:25:52,170
these days of course is when you're

00:25:50,940 --> 00:25:54,450
sitting there playing your game on a

00:25:52,170 --> 00:25:56,790
laptop and all of a sudden the CPU and

00:25:54,450 --> 00:25:58,560
GPU are getting too hot and so the

00:25:56,790 --> 00:26:00,630
system is like hey things are getting

00:25:58,560 --> 00:26:03,240
warm here let me throttle down the the

00:26:00,630 --> 00:26:05,010
computational resources available so

00:26:03,240 --> 00:26:06,630
that we get rid of some thermal heat so

00:26:05,010 --> 00:26:08,100
this is something that the game cannot

00:26:06,630 --> 00:26:10,140
even predict is going to happen very

00:26:08,100 --> 00:26:12,270
easily it's like things are getting warm

00:26:10,140 --> 00:26:14,070
all of a sudden the operating system is

00:26:12,270 --> 00:26:15,510
throttling down my resources and so all

00:26:14,070 --> 00:26:18,000
of a sudden I'm starting to miss frames

00:26:15,510 --> 00:26:20,010
so this is this is kind of a new thing

00:26:18,000 --> 00:26:22,230
for game developers who are used to

00:26:20,010 --> 00:26:23,730
having 300 watt GPUs that never slow

00:26:22,230 --> 00:26:25,080
down and all of a sudden this is

00:26:23,730 --> 00:26:27,180
actually becoming very common this

00:26:25,080 --> 00:26:29,490
happens really a lot in mobile gaming

00:26:27,180 --> 00:26:31,620
especially on your phone if your phone

00:26:29,490 --> 00:26:33,330
starts you know roasting your hand you

00:26:31,620 --> 00:26:34,950
might notice you might notice it's

00:26:33,330 --> 00:26:36,810
slowing down the other thing that

00:26:34,950 --> 00:26:38,160
happens in composited environments is

00:26:36,810 --> 00:26:40,410
all of a sudden the window system

00:26:38,160 --> 00:26:42,119
presentation mode changes something

00:26:40,410 --> 00:26:44,459
happens on the screen you go from full

00:26:42,119 --> 00:26:49,229
Green to windowed some window pops up

00:26:44,459 --> 00:26:50,699
over the top of your your system and and

00:26:49,229 --> 00:26:52,319
all of a sudden the window system is

00:26:50,699 --> 00:26:54,329
like well instead of just putting you

00:26:52,319 --> 00:26:55,859
into the overlay I'm gonna have to

00:26:54,329 --> 00:26:57,479
composite a bunch of stuff and I'm gonna

00:26:55,859 --> 00:26:59,369
steal about four milliseconds worth of

00:26:57,479 --> 00:27:01,379
your GPU time this frame to display

00:26:59,369 --> 00:27:03,479
information and so all of a sudden you

00:27:01,379 --> 00:27:05,189
only get 12 milliseconds instead of 16

00:27:03,479 --> 00:27:07,969
milliseconds to compute your frame and

00:27:05,189 --> 00:27:11,729
you drop a frame and that really sucks

00:27:07,969 --> 00:27:13,379
and so we need to find some ways to fix

00:27:11,729 --> 00:27:16,559
this problem because smooth animation

00:27:13,379 --> 00:27:18,449
really is it's useful in a regular

00:27:16,559 --> 00:27:20,209
desktop gaming environment but when you

00:27:18,449 --> 00:27:23,969
think about a VR environment it's really

00:27:20,209 --> 00:27:25,559
critical VR environments if you put the

00:27:23,969 --> 00:27:27,029
when you put the headset on that the

00:27:25,559 --> 00:27:29,129
real world disappears and you're

00:27:27,029 --> 00:27:30,959
counting on the computer to keep the

00:27:29,129 --> 00:27:33,239
image in front of your in in front of

00:27:30,959 --> 00:27:35,909
your eyeballs looking stable so that you

00:27:33,239 --> 00:27:38,189
don't fall over or other bad things

00:27:35,909 --> 00:27:39,959
happen so when we talk about fixing

00:27:38,189 --> 00:27:42,869
stutter it's useful in the desktop it's

00:27:39,959 --> 00:27:44,399
critical for VR so obviously obviously I

00:27:42,869 --> 00:27:46,439
have a big interest in making this work

00:27:44,399 --> 00:27:48,929
for my VR work but it's also really

00:27:46,439 --> 00:27:51,419
important for a smoothness and and

00:27:48,929 --> 00:27:53,999
fluidity in desk and regular desktop

00:27:51,419 --> 00:27:55,589
gaming so we obviously need a couple of

00:27:53,999 --> 00:27:58,169
things in order to help the application

00:27:55,589 --> 00:27:59,729
get some idea of whether they're about

00:27:58,169 --> 00:28:00,899
to start under running on the GPU

00:27:59,729 --> 00:28:03,149
whether they're trying to do too much

00:28:00,899 --> 00:28:05,279
computation with the GPU we need better

00:28:03,149 --> 00:28:07,619
measurements or how much GPU time frames

00:28:05,279 --> 00:28:10,049
using those extensions are becoming

00:28:07,619 --> 00:28:11,969
available we've had we had that ability

00:28:10,049 --> 00:28:13,679
for a while one of the things that's

00:28:11,969 --> 00:28:15,809
missing from the just you know how much

00:28:13,679 --> 00:28:17,039
CPU time am i consuming one of the

00:28:15,809 --> 00:28:19,379
things that's missing there is the

00:28:17,039 --> 00:28:21,719
ability to relate when the GPU rendering

00:28:19,379 --> 00:28:23,939
finished to when the display cycle

00:28:21,719 --> 00:28:26,519
happened to start and there's no real

00:28:23,939 --> 00:28:28,559
folk and OpenGL don't really provide any

00:28:26,519 --> 00:28:30,479
relationship in those two times so you

00:28:28,559 --> 00:28:35,039
have no idea how much spare time you

00:28:30,479 --> 00:28:36,719
have and so we're adding some extensions

00:28:35,039 --> 00:28:38,339
to volcán to report when V blank

00:28:36,719 --> 00:28:39,179
happened before and when it's likely to

00:28:38,339 --> 00:28:42,079
happen in the future

00:28:39,179 --> 00:28:44,789
and also provide some information about

00:28:42,079 --> 00:28:46,799
when presentations happen it's like if I

00:28:44,789 --> 00:28:49,199
asked for us image to be shown to the

00:28:46,799 --> 00:28:50,399
user I really want to know hey did you

00:28:49,199 --> 00:28:52,109
actually manage to get that on the

00:28:50,399 --> 00:28:54,149
screen at the time I asked for or was

00:28:52,109 --> 00:28:55,540
that late and should I start trying to

00:28:54,149 --> 00:28:57,100
scale back the number of

00:28:55,540 --> 00:29:00,580
in the scene so that I can try to hit

00:28:57,100 --> 00:29:01,870
hit my V blank targets more often so

00:29:00,580 --> 00:29:03,970
we're doing a bunch of work in Vulcan to

00:29:01,870 --> 00:29:06,400
try to fix the stuff there's a bunch

00:29:03,970 --> 00:29:10,260
more work in the in the window systems

00:29:06,400 --> 00:29:12,820
so when you're trying to accurately

00:29:10,260 --> 00:29:14,710
present something in an accurately

00:29:12,820 --> 00:29:17,560
present something at it at to the user

00:29:14,710 --> 00:29:19,900
the the data that you want is not when

00:29:17,560 --> 00:29:22,030
you know some random operation happened

00:29:19,900 --> 00:29:23,800
within the GPU oh I managed to copy this

00:29:22,030 --> 00:29:25,690
image into the frame buffer awesome I

00:29:23,800 --> 00:29:27,370
don't really care when that happened the

00:29:25,690 --> 00:29:29,620
time that I'm interested in knowing is

00:29:27,370 --> 00:29:31,570
when the photons started going from the

00:29:29,620 --> 00:29:33,280
monitor to the user's eyeball right

00:29:31,570 --> 00:29:35,890
that's the that's the relevant time here

00:29:33,280 --> 00:29:37,960
because that's the time the user sees I

00:29:35,890 --> 00:29:40,000
don't really care when I pass the image

00:29:37,960 --> 00:29:42,100
to the window system which means that in

00:29:40,000 --> 00:29:44,080
any of this computation of accurate

00:29:42,100 --> 00:29:45,760
presentation time it's not something we

00:29:44,080 --> 00:29:47,590
can do up in the up in the rendering

00:29:45,760 --> 00:29:49,390
library it's something that we have to

00:29:47,590 --> 00:29:50,860
engage the rendering library and the

00:29:49,390 --> 00:29:52,720
window system and the kernel to make

00:29:50,860 --> 00:29:55,120
sure that everybody is working together

00:29:52,720 --> 00:29:58,150
to get this information sent back to the

00:29:55,120 --> 00:30:01,450
user applications have to be able to

00:29:58,150 --> 00:30:03,250
control when their frame is is is to be

00:30:01,450 --> 00:30:05,200
displayed they need to be able to say oh

00:30:03,250 --> 00:30:07,240
well you know I need this seen

00:30:05,200 --> 00:30:09,400
complexity in order to show all the cool

00:30:07,240 --> 00:30:11,260
art that my I paid a lot of money for so

00:30:09,400 --> 00:30:14,050
I'm going to instead of reducing scene

00:30:11,260 --> 00:30:16,030
complexity I'm gonna go from 60 frames

00:30:14,050 --> 00:30:17,710
per second to 30 frames per second and

00:30:16,030 --> 00:30:19,810
as long as I know that I'm going to

00:30:17,710 --> 00:30:21,880
displaying every other refresh cycle and

00:30:19,810 --> 00:30:24,520
display every frame for two cycles then

00:30:21,880 --> 00:30:26,860
I can at least offer an accurate if not

00:30:24,520 --> 00:30:28,630
as smooth an experience but that means

00:30:26,860 --> 00:30:30,760
the application has to be able to to

00:30:28,630 --> 00:30:33,100
know that it can trust the window system

00:30:30,760 --> 00:30:34,720
to delay a frame by a certain amount so

00:30:33,100 --> 00:30:37,960
that the frame is presented at the

00:30:34,720 --> 00:30:39,850
correct time and when a twinned frames

00:30:37,960 --> 00:30:41,560
are display the application needs to be

00:30:39,850 --> 00:30:43,750
able to get feedback from that did it

00:30:41,560 --> 00:30:45,040
work right did I actually manage to tell

00:30:43,750 --> 00:30:46,810
the window system and that information

00:30:45,040 --> 00:30:48,280
come back to me telling me that my frame

00:30:46,810 --> 00:30:50,260
was displayed at the correct time

00:30:48,280 --> 00:30:52,570
so those are the two critical pieces of

00:30:50,260 --> 00:30:55,240
information we're getting pretty good at

00:30:52,570 --> 00:30:57,940
there first of these there are api's and

00:30:55,240 --> 00:30:59,710
Vulcan and OpenGL and and the X Window

00:30:57,940 --> 00:31:02,140
System it lets you tell the system when

00:30:59,710 --> 00:31:04,650
to present a frame and that control is

00:31:02,140 --> 00:31:07,480
starting to work pretty well except for

00:31:04,650 --> 00:31:09,280
composited window systems so at a

00:31:07,480 --> 00:31:11,140
composited window system the app

00:31:09,280 --> 00:31:13,030
location provides an image the window

00:31:11,140 --> 00:31:15,130
system and then the window system does a

00:31:13,030 --> 00:31:17,590
bunch of computation with that it'll put

00:31:15,130 --> 00:31:19,570
overlays on it you know it'll you know

00:31:17,590 --> 00:31:21,610
merge that with other other images on

00:31:19,570 --> 00:31:23,020
the screen to construct the scene for

00:31:21,610 --> 00:31:25,450
the user that includes all the

00:31:23,020 --> 00:31:27,790
applications in the environment so there

00:31:25,450 --> 00:31:29,170
are two obvious common composited

00:31:27,790 --> 00:31:30,790
environments in our world and those are

00:31:29,170 --> 00:31:34,120
the X composite extension the X Window

00:31:30,790 --> 00:31:36,970
System and whalen the X composite

00:31:34,120 --> 00:31:38,200
extension is it seems more complicated

00:31:36,970 --> 00:31:39,490
because it involves an external

00:31:38,200 --> 00:31:41,680
compositing manager which may do

00:31:39,490 --> 00:31:43,480
arbitrary computations but wayland is

00:31:41,680 --> 00:31:45,910
just as complicated it just integrates

00:31:43,480 --> 00:31:47,800
all that complexity into the Window

00:31:45,910 --> 00:31:49,390
System server instead of putting it at a

00:31:47,800 --> 00:31:50,830
separate process so these two

00:31:49,390 --> 00:31:52,570
environments are very similar from this

00:31:50,830 --> 00:31:54,760
problem because all of a sudden the

00:31:52,570 --> 00:31:56,770
applications images come in and now the

00:31:54,760 --> 00:32:00,550
compositing system is going to take that

00:31:56,770 --> 00:32:02,140
image and do stuff and I can do it a lot

00:32:00,550 --> 00:32:03,730
of computation of that environment and

00:32:02,140 --> 00:32:05,560
that means that the amount of time

00:32:03,730 --> 00:32:08,320
available for the application to render

00:32:05,560 --> 00:32:11,890
using the GPU is reduced how much is it

00:32:08,320 --> 00:32:13,660
reduced by well it depends if it's if

00:32:11,890 --> 00:32:15,340
the application is running fullscreen

00:32:13,660 --> 00:32:17,110
they're being there the composited

00:32:15,340 --> 00:32:18,670
Window System may do nothing at all it

00:32:17,110 --> 00:32:20,620
may just hand that image right off to

00:32:18,670 --> 00:32:24,100
the kernel so it may have all 16

00:32:20,620 --> 00:32:26,500
milliseconds to to of GPU time if the if

00:32:24,100 --> 00:32:28,390
the if the user pops up a little a

00:32:26,500 --> 00:32:30,430
little dialog box over the application

00:32:28,390 --> 00:32:31,600
down in the corner and the compositing

00:32:30,430 --> 00:32:33,340
system says wait a minute

00:32:31,600 --> 00:32:35,230
I have to take the applications image

00:32:33,340 --> 00:32:36,550
and this little and this little text

00:32:35,230 --> 00:32:38,440
chat window and paste them together

00:32:36,550 --> 00:32:40,210
before I hand them off to the window

00:32:38,440 --> 00:32:41,950
system server now all of a sudden we're

00:32:40,210 --> 00:32:44,260
talking about copying the applications

00:32:41,950 --> 00:32:47,050
image into another buffer blending the

00:32:44,260 --> 00:32:48,700
talk the chat window over the top of

00:32:47,050 --> 00:32:50,890
that and then handing the resulting

00:32:48,700 --> 00:32:52,810
image to the window system to the to the

00:32:50,890 --> 00:32:54,160
operating system and that can take a lot

00:32:52,810 --> 00:32:56,110
of extra time a lot of extra

00:32:54,160 --> 00:32:57,940
synchronization so all of a sudden the

00:32:56,110 --> 00:32:59,830
applications amount of rendering time

00:32:57,940 --> 00:33:01,720
gets reduced by a lot

00:32:59,830 --> 00:33:03,610
we can't Rast that with a kind of a

00:33:01,720 --> 00:33:05,500
classic clip windows clipped window

00:33:03,610 --> 00:33:07,750
system where every application is just

00:33:05,500 --> 00:33:10,240
gets gets a set of pixels on the screen

00:33:07,750 --> 00:33:11,740
so that when you want to present a scene

00:33:10,240 --> 00:33:14,260
from an application you know that all

00:33:11,740 --> 00:33:16,150
you have to do is copy those image those

00:33:14,260 --> 00:33:18,220
bits into a frame buffer there's no

00:33:16,150 --> 00:33:20,200
arbitrary complexity of computation

00:33:18,220 --> 00:33:22,810
every application has a pretty much

00:33:20,200 --> 00:33:24,970
fixed overhead

00:33:22,810 --> 00:33:26,710
and the real problem is not the overhead

00:33:24,970 --> 00:33:30,130
but the variance the applications have

00:33:26,710 --> 00:33:31,450
no way of knowing that so one of the one

00:33:30,130 --> 00:33:33,130
of the bugs that I'm trying to fix this

00:33:31,450 --> 00:33:36,730
year is actually a bug in the X

00:33:33,130 --> 00:33:39,040
composite extension for dealing with

00:33:36,730 --> 00:33:40,000
this frame timing stuff when you when

00:33:39,040 --> 00:33:41,770
you when you have the composite

00:33:40,000 --> 00:33:44,500
extension running and you're presenting

00:33:41,770 --> 00:33:46,570
an image from an application the time

00:33:44,500 --> 00:33:48,580
that the that the window system does the

00:33:46,570 --> 00:33:51,850
copy which is to say the tie it's going

00:33:48,580 --> 00:33:53,620
to delay the copy until the time that

00:33:51,850 --> 00:33:57,040
the application one of that image to be

00:33:53,620 --> 00:33:58,450
on the screen and you think awesome it's

00:33:57,040 --> 00:34:00,430
going to delay it so it gets displayed

00:33:58,450 --> 00:34:01,750
at the right time well no because it

00:34:00,430 --> 00:34:05,200
doesn't display to the screen at that

00:34:01,750 --> 00:34:07,450
point it copies it into into the thank

00:34:05,200 --> 00:34:09,129
you off screen buffer and then tells the

00:34:07,450 --> 00:34:10,870
compositing manager hey there's new

00:34:09,129 --> 00:34:13,210
contents over here and so now the

00:34:10,870 --> 00:34:15,370
compositing manager has to say oh let me

00:34:13,210 --> 00:34:17,500
construct my scene image from that so it

00:34:15,370 --> 00:34:19,510
takes the applications image which was

00:34:17,500 --> 00:34:21,310
handed to it when the application wanted

00:34:19,510 --> 00:34:23,440
to have it shown to the user and then

00:34:21,310 --> 00:34:25,060
they then the compositing manager has to

00:34:23,440 --> 00:34:27,040
do a blending or whatever wants to do

00:34:25,060 --> 00:34:29,050
construct a final image and hand that

00:34:27,040 --> 00:34:30,879
back to the X server which then means

00:34:29,050 --> 00:34:32,770
that that image isn't going to get is

00:34:30,879 --> 00:34:34,659
not going to be displayed until at least

00:34:32,770 --> 00:34:36,520
the next frame so when you run the

00:34:34,659 --> 00:34:38,470
composite extension with the 3d

00:34:36,520 --> 00:34:41,260
application today you are guaranteed to

00:34:38,470 --> 00:34:44,350
get at least one frame of inaccuracy in

00:34:41,260 --> 00:34:47,889
your frame timing requests so that's

00:34:44,350 --> 00:34:49,870
kind of bad and of course the

00:34:47,889 --> 00:34:52,270
application gets told they did see that

00:34:49,870 --> 00:34:54,040
it's image was presented when that copy

00:34:52,270 --> 00:34:56,530
occurred the initial copy occurred so

00:34:54,040 --> 00:34:58,930
the application always gets it displayed

00:34:56,530 --> 00:35:00,550
at the wrong time and is always reliably

00:34:58,930 --> 00:35:02,230
lied to about the time that it was

00:35:00,550 --> 00:35:04,870
presented so these are these are errors

00:35:02,230 --> 00:35:08,050
in both on both halves of this so I'm

00:35:04,870 --> 00:35:12,280
working to fix that this year I'm also

00:35:08,050 --> 00:35:13,720
working on I'm so the way that I'm going

00:35:12,280 --> 00:35:16,060
to try to fix this is I'm actually gonna

00:35:13,720 --> 00:35:17,860
try to I'm actually gonna copy the image

00:35:16,060 --> 00:35:20,620
immediately tell the compositing manager

00:35:17,860 --> 00:35:23,020
and then somehow associate the

00:35:20,620 --> 00:35:24,640
compositing manager's presentation with

00:35:23,020 --> 00:35:26,470
that copy and I've got a couple of ideas

00:35:24,640 --> 00:35:27,730
I think I'll do something ad hoc e at

00:35:26,470 --> 00:35:29,590
first and then come up with something a

00:35:27,730 --> 00:35:31,240
little more principled later but so I

00:35:29,590 --> 00:35:32,830
want to associate the compositing

00:35:31,240 --> 00:35:35,500
manager's presentation of the entire

00:35:32,830 --> 00:35:36,430
scene with the applications requests to

00:35:35,500 --> 00:35:38,559
present its

00:35:36,430 --> 00:35:40,329
it's application image so tie those

00:35:38,559 --> 00:35:42,190
together so that when the compositing

00:35:40,329 --> 00:35:44,650
manager so that the compositing managers

00:35:42,190 --> 00:35:46,720
presentation is deal is done when the

00:35:44,650 --> 00:35:48,790
application wants its image presented

00:35:46,720 --> 00:35:51,069
and the application gets told that the

00:35:48,790 --> 00:35:52,990
stuff was presented when the compositing

00:35:51,069 --> 00:35:54,910
manager presentation occurs so I'm

00:35:52,990 --> 00:35:58,109
hoping that's going to kind of resolve

00:35:54,910 --> 00:36:02,440
these resolve those issues fairly nicely

00:35:58,109 --> 00:36:05,349
though I have a further goal beyond that

00:36:02,440 --> 00:36:07,089
is to actually separate out the the kind

00:36:05,349 --> 00:36:09,190
of the primitive simple compositing

00:36:07,089 --> 00:36:10,450
environments from the construction of

00:36:09,190 --> 00:36:12,069
the content on the screen so you have

00:36:10,450 --> 00:36:14,260
the compositing manager doing all kinds

00:36:12,069 --> 00:36:15,940
of crazy decorations everywhere and then

00:36:14,260 --> 00:36:17,440
you have this really simple operation

00:36:15,940 --> 00:36:18,940
it's like I've got these applications

00:36:17,440 --> 00:36:20,230
they're stacked on the screen I want to

00:36:18,940 --> 00:36:21,970
blend them together and send into the

00:36:20,230 --> 00:36:23,980
video hardware so I want to pull that

00:36:21,970 --> 00:36:26,500
the construction of that compositing

00:36:23,980 --> 00:36:29,170
stuff into the X server so that the X

00:36:26,500 --> 00:36:31,359
server has tighter control over that and

00:36:29,170 --> 00:36:33,460
the advantage of that is we're going to

00:36:31,359 --> 00:36:35,619
be able to do better timing predictions

00:36:33,460 --> 00:36:37,930
when we have to use the hardware the

00:36:35,619 --> 00:36:39,940
second advantage is is if your hardware

00:36:37,930 --> 00:36:42,069
has multiple video planes that it can

00:36:39,940 --> 00:36:44,109
scan out from I'll be able to use those

00:36:42,069 --> 00:36:46,119
for your for your games as well and that

00:36:44,109 --> 00:36:47,770
means that I'm going to get to get to

00:36:46,119 --> 00:36:49,900
basically not interacting with the

00:36:47,770 --> 00:36:52,119
compositing manager at all what I want

00:36:49,900 --> 00:36:54,430
to redisplay an applications image which

00:36:52,119 --> 00:36:56,200
means that the jitter this this variance

00:36:54,430 --> 00:36:59,020
in display time is going to go down a

00:36:56,200 --> 00:37:00,579
lot and that's the that's my longer term

00:36:59,020 --> 00:37:03,910
goal and I'm trying to get that done

00:37:00,579 --> 00:37:05,980
this year is for it so in summary

00:37:03,910 --> 00:37:07,540
support for Debian gaming is obviously

00:37:05,980 --> 00:37:09,250
improving there's a bunch of companies

00:37:07,540 --> 00:37:11,020
that are working really hard to make

00:37:09,250 --> 00:37:13,390
sure that we have competent gaming

00:37:11,020 --> 00:37:16,690
support in free software the free

00:37:13,390 --> 00:37:19,900
software implementations of the OpenGL

00:37:16,690 --> 00:37:23,530
and Vulkan API czar are very well

00:37:19,900 --> 00:37:24,940
supported by AMD and Intel and so and

00:37:23,530 --> 00:37:27,369
that's getting better all the time we've

00:37:24,940 --> 00:37:29,200
now as I say we've now caught up we're

00:37:27,369 --> 00:37:30,910
kind of at the leading edge of API

00:37:29,200 --> 00:37:32,319
development now instead of trailing by

00:37:30,910 --> 00:37:34,690
years and years and years which we used

00:37:32,319 --> 00:37:37,030
to do the VR stuff is coming along I'd

00:37:34,690 --> 00:37:40,770
love to see more work in open hmd to get

00:37:37,030 --> 00:37:43,390
free software HMV stuff really available

00:37:40,770 --> 00:37:45,130
it's time at this point to solve this

00:37:43,390 --> 00:37:46,599
this long term stuttering problem and

00:37:45,130 --> 00:37:49,240
that's really what I'm focusing on for

00:37:46,599 --> 00:37:50,289
the next six months or so we used to

00:37:49,240 --> 00:37:52,509
solve this by just buying

00:37:50,289 --> 00:37:55,059
faster computers but gain requirements

00:37:52,509 --> 00:37:57,489
are now getting fast are getting heavier

00:37:55,059 --> 00:37:58,449
faster than hardware is improving and so

00:37:57,489 --> 00:38:00,429
we need to actually come up with

00:37:58,449 --> 00:38:01,689
principled mechanisms to make sure that

00:38:00,429 --> 00:38:03,130
the games can actually do the right

00:38:01,689 --> 00:38:05,650
thing even when their resource

00:38:03,130 --> 00:38:07,509
constrained so thank you very much today

00:38:05,650 --> 00:38:09,099
I really appreciate the opportunity to

00:38:07,509 --> 00:38:11,199
speak at Deb cough I love coming to this

00:38:09,099 --> 00:38:12,999
conference of course it's it's my people

00:38:11,199 --> 00:38:24,819
and thank you again and have a great

00:38:12,999 --> 00:38:26,259
time for the rest of the week good about

00:38:24,819 --> 00:38:29,279
five minutes for questions anybody has a

00:38:26,259 --> 00:38:29,279
question come on down to the mic

00:38:30,299 --> 00:38:43,929
yeah come my dad of the microphone down

00:38:32,410 --> 00:38:46,269
here okay sorry I did I didn't very

00:38:43,929 --> 00:38:51,189
close to a presentation but my question

00:38:46,269 --> 00:38:53,939
is that is that they sync issue in free

00:38:51,189 --> 00:38:56,319
driver or non free driver have any

00:38:53,939 --> 00:39:00,119
result I will help bring Bruce out

00:38:56,319 --> 00:39:05,559
before especially Marty squeeze that up

00:39:00,119 --> 00:39:07,209
in multi-screen vsync yeah so we have

00:39:05,559 --> 00:39:08,919
the advantage right now that the system

00:39:07,209 --> 00:39:11,799
knows which monitor the application

00:39:08,919 --> 00:39:13,539
wants to be presented to so we have all

00:39:11,799 --> 00:39:15,219
the tools that we need in order to

00:39:13,539 --> 00:39:17,079
present your when your application is

00:39:15,219 --> 00:39:19,479
presented on a particular screen we have

00:39:17,079 --> 00:39:21,459
the tools necessary and the API is

00:39:19,479 --> 00:39:23,769
necessary to make sure the vsync happens

00:39:21,459 --> 00:39:25,359
on the presented monitor we just need to

00:39:23,769 --> 00:39:27,489
solve some of the stuttering problems to

00:39:25,359 --> 00:39:29,349
actually get the timing accurate so yeah

00:39:27,489 --> 00:39:31,059
the the we have the infrastructure

00:39:29,349 --> 00:39:32,979
available for and the applications don't

00:39:31,059 --> 00:39:34,689
have to change we just have to fix the

00:39:32,979 --> 00:39:37,979
underlying implementations to fix that

00:39:34,689 --> 00:39:37,979
okay thank you yep

00:39:40,620 --> 00:39:46,710
I suspect like like everybody else that

00:39:44,850 --> 00:39:48,840
we're all ready for lunch and thank you

00:39:46,710 --> 00:39:50,190
again for coming and I'm a brown the

00:39:48,840 --> 00:39:51,450
rest of the week if anybody wants to ask

00:39:50,190 --> 00:39:54,390
me questions about what I've been up to

00:39:51,450 --> 00:39:56,250
or or anything else I'd be love to talk

00:39:54,390 --> 00:39:58,970
to everybody here thank you very much

00:39:56,250 --> 00:39:58,970

YouTube URL: https://www.youtube.com/watch?v=xtIMjqXqS6g


