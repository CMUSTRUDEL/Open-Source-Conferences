Title: Analysing Debian packages with Neo4j
Publication date: 2018-07-30
Playlist: DebConf 18
Description: 
	by Norbert Preining

At: DebConf18
https://debconf18.debconf.org/talks/20-analysing-debian-packages-with-neo4j/

We present our work towards representing Debian's packages, including history and releases, as well as other components of the Debian environment, in a Graph Database.

The Ultimate Debian Database [UDD](https://wiki.debian.org/UltimateDebianDatabase/) collects a variety of data around Debian and Ubuntu: Packages and sources, bugs, history of uploads, just to name a few. The database scheme reveals a highly de-normalized [RDB](https://udd.debian.org/schema/). In this on-going work we extract (some) data from UDD and represent it as a graph database.

The presentation will give a short introduction on the life time and structure of Debian packages, followed with the graph database scheme (nodes and relations). After going through some of the queries used on the UDD web pages we will show how they can be translated to Cypher.

We close with an outlook of our future plans and open problems.

Room: Yushan (玉山)
Scheduled start: 2018-07-29 15:00:00
Captions: 
	00:00:04,559 --> 00:00:10,180
thanks everyone for joining here I have

00:00:07,389 --> 00:00:14,529
to excuse myself my pathetic Wayne is

00:00:10,180 --> 00:00:17,350
not so greatly developed like the

00:00:14,529 --> 00:00:20,770
previous my SDC so we have to be more

00:00:17,350 --> 00:00:23,230
practically here so it's about analyzing

00:00:20,770 --> 00:00:26,320
tipping packages I actually don't like

00:00:23,230 --> 00:00:32,129
this analyzing deviant packages with

00:00:26,320 --> 00:00:34,989
with a graph database why for me it's

00:00:32,129 --> 00:00:37,089
about twelve years that I became given

00:00:34,989 --> 00:00:39,159
developer but it's the first deepen

00:00:37,089 --> 00:00:44,319
conference I'm participating so I

00:00:39,159 --> 00:00:45,879
thought because sorry yeah that's for me

00:00:44,319 --> 00:00:47,620
it was a reason to get to know people

00:00:45,879 --> 00:00:49,539
because it's much better to see them in

00:00:47,620 --> 00:00:51,370
face and talk to them I think everyone

00:00:49,539 --> 00:00:56,350
knows this so it's other but maybe this

00:00:51,370 --> 00:00:58,870
a bit of self introduction here so by

00:00:56,350 --> 00:01:00,999
education I'm a mathematician I'm doing

00:00:58,870 --> 00:01:03,180
this kind of stuff this is called

00:01:00,999 --> 00:01:05,860
mathematical logic proof theory

00:01:03,180 --> 00:01:07,659
intermediate logic well whatever you

00:01:05,860 --> 00:01:12,580
will not hear about it because a

00:01:07,659 --> 00:01:14,680
probably case you will run away I'm also

00:01:12,580 --> 00:01:18,310
tipping developer yeah you know mace my

00:01:14,680 --> 00:01:21,990
only about take take and font packages

00:01:18,310 --> 00:01:21,990
and a few other things that I use around

00:01:22,290 --> 00:01:28,450
what's the main part of my development

00:01:25,930 --> 00:01:30,520
stuff is his central page life so I'm

00:01:28,450 --> 00:01:32,860
the the maintain and develop out of the

00:01:30,520 --> 00:01:35,710
whole Tefft life infrastructure just to

00:01:32,860 --> 00:01:38,200
give you an idea deben is quite happy

00:01:35,710 --> 00:01:41,710
because they own we only have Linux as

00:01:38,200 --> 00:01:43,720
basis we provide binaries and twister

00:01:41,710 --> 00:01:46,020
bution methods including installer

00:01:43,720 --> 00:01:48,250
updates for about 15 different

00:01:46,020 --> 00:01:51,880
architecture operating system

00:01:48,250 --> 00:01:55,930
combinations including some strange PhDs

00:01:51,880 --> 00:01:58,990
ie hilarious windows and that all should

00:01:55,930 --> 00:02:00,970
work well in the same way somehow so

00:01:58,990 --> 00:02:03,940
that's a bit challenging I have to say

00:02:00,970 --> 00:02:05,890
especially the windows part since my

00:02:03,940 --> 00:02:08,979
move to Japan nine years ago I have not

00:02:05,890 --> 00:02:12,250
been now also very involved into the

00:02:08,979 --> 00:02:14,260
Japanese tech development community I

00:02:12,250 --> 00:02:17,230
will give a talk in two days I think

00:02:14,260 --> 00:02:18,350
about a bit about this and yeah besides

00:02:17,230 --> 00:02:22,820
this if I'm bored

00:02:18,350 --> 00:02:26,720
a mountain guide so I like to carry pull

00:02:22,820 --> 00:02:29,090
up and push up and and get people into

00:02:26,720 --> 00:02:30,530
the mountains here in Taiwan and

00:02:29,090 --> 00:02:32,090
unfortunately I don't have more time

00:02:30,530 --> 00:02:33,380
because there's so many nice mountains

00:02:32,090 --> 00:02:35,480
here too kind

00:02:33,380 --> 00:02:37,330
so I will I will have to come back

00:02:35,480 --> 00:02:41,540
anyway it's my third time I think right

00:02:37,330 --> 00:02:44,420
okay yeah I forgot my job yes I'm

00:02:41,540 --> 00:02:47,390
working at accelya I also grateful to my

00:02:44,420 --> 00:02:49,160
company who allowed me to come here it's

00:02:47,390 --> 00:02:50,900
not related to Debian what I do there

00:02:49,160 --> 00:02:53,750
I'm research and development the company

00:02:50,900 --> 00:02:57,590
is one of the world small company but

00:02:53,750 --> 00:03:01,010
the CDN and Internet services security

00:02:57,590 --> 00:03:02,930
in Japan I do well security machine

00:03:01,010 --> 00:03:04,760
learning some kind of formal

00:03:02,930 --> 00:03:07,100
verification which I carried over from

00:03:04,760 --> 00:03:10,760
my previous work so this is what I do

00:03:07,100 --> 00:03:14,750
for a living let's put it this way a bit

00:03:10,760 --> 00:03:17,240
of an overview what I want hope to carry

00:03:14,750 --> 00:03:19,760
through today a quick introduction to

00:03:17,240 --> 00:03:21,200
graph databases because I mean I'm not

00:03:19,760 --> 00:03:23,360
sure how many people have heard about

00:03:21,200 --> 00:03:25,430
this and what it is but only very

00:03:23,360 --> 00:03:27,650
quickly because otherwise we cannot then

00:03:25,430 --> 00:03:29,960
okay packages in DB and this will

00:03:27,650 --> 00:03:31,760
probably boring for most of you but I

00:03:29,960 --> 00:03:34,190
mean just to be sure what we are talking

00:03:31,760 --> 00:03:38,440
about the few things about packages in

00:03:34,190 --> 00:03:41,240
Debian then the ultimate Debian database

00:03:38,440 --> 00:03:44,980
well I will introduce it and discuss and

00:03:41,240 --> 00:03:47,540
then I will look at to how to represent

00:03:44,980 --> 00:03:50,870
parts of this information not all of it

00:03:47,540 --> 00:03:53,450
parts of it in a graph database and what

00:03:50,870 --> 00:03:55,400
would be the advantages of all this and

00:03:53,450 --> 00:03:58,430
discuss the technical parts a bit how to

00:03:55,400 --> 00:04:00,650
convert from well from the UDT how to

00:03:58,430 --> 00:04:02,750
get the information from the UDT into a

00:04:00,650 --> 00:04:05,360
format and then into a craft database in

00:04:02,750 --> 00:04:08,210
this case knee of OG and then finally it

00:04:05,360 --> 00:04:11,990
will show some example here is and

00:04:08,210 --> 00:04:14,120
visualizations okay so what I graph

00:04:11,990 --> 00:04:16,220
database is graph databases are just

00:04:14,120 --> 00:04:19,520
started like I don't know like 15 years

00:04:16,220 --> 00:04:22,850
ago something the idea was that tables

00:04:19,520 --> 00:04:24,770
like relational databases well they are

00:04:22,850 --> 00:04:26,690
nice they are efficient for some things

00:04:24,770 --> 00:04:30,110
but not for everything many things in

00:04:26,690 --> 00:04:32,060
our daily life are well are based on

00:04:30,110 --> 00:04:34,100
releasing space from

00:04:32,060 --> 00:04:36,380
of relations it's often easier to

00:04:34,100 --> 00:04:38,120
represents if so what is the graph we

00:04:36,380 --> 00:04:41,360
don't go into mathematically stops think

00:04:38,120 --> 00:04:45,100
about nodes and edges so nodes and

00:04:41,360 --> 00:04:49,910
relations between them

00:04:45,100 --> 00:04:52,550
so this graph databases they try to fix

00:04:49,910 --> 00:04:56,150
well fix or improve a few things about

00:04:52,550 --> 00:04:59,300
above relational databases the one is

00:04:56,150 --> 00:05:01,700
the duplication versus join so if you if

00:04:59,300 --> 00:05:05,150
you try to represent a certain amount of

00:05:01,700 --> 00:05:07,070
data in in a relational database you

00:05:05,150 --> 00:05:09,169
have more or less two options you

00:05:07,070 --> 00:05:11,240
completely normalize the database which

00:05:09,169 --> 00:05:12,950
from the theoretical part side is very

00:05:11,240 --> 00:05:15,320
good because it's nice there's no

00:05:12,950 --> 00:05:17,419
duplication of data whatever but you

00:05:15,320 --> 00:05:19,880
come into that hell of joins because for

00:05:17,419 --> 00:05:22,520
every lookup you have to join several

00:05:19,880 --> 00:05:24,650
tables and if the tables getting long

00:05:22,520 --> 00:05:28,310
like I mean seven millions of entries

00:05:24,650 --> 00:05:30,740
then lookups can be scan slow down well

00:05:28,310 --> 00:05:33,620
we have images whatever technique in our

00:05:30,740 --> 00:05:35,960
DPS have evolved to go around this but

00:05:33,620 --> 00:05:38,090
it's still the problem and on the other

00:05:35,960 --> 00:05:40,400
hand to make lookups fast what you can

00:05:38,090 --> 00:05:42,200
do you can denormalize you copy all the

00:05:40,400 --> 00:05:45,110
data that you have it all in one

00:05:42,200 --> 00:05:47,419
database then it's fast and very easy

00:05:45,110 --> 00:05:48,800
and also programming wise nice but well

00:05:47,419 --> 00:05:52,970
you have the application of data which

00:05:48,800 --> 00:05:55,070
is generally not very advisable another

00:05:52,970 --> 00:05:57,979
thing is the rigidness of the database

00:05:55,070 --> 00:06:01,340
schema that is a scimitar it's very well

00:05:57,979 --> 00:06:02,960
easy to set up an RDP but if you want to

00:06:01,340 --> 00:06:06,470
change something in the representation

00:06:02,960 --> 00:06:08,539
and anyone who has done this it's really

00:06:06,470 --> 00:06:11,240
a pain to convert to a new database

00:06:08,539 --> 00:06:13,669
scheme it it takes energy server

00:06:11,240 --> 00:06:17,539
downtime whatever because you have to

00:06:13,669 --> 00:06:21,020
get everything out and this is a graph

00:06:17,539 --> 00:06:22,639
database much easier and well finally

00:06:21,020 --> 00:06:25,280
also for the for the lookup this is

00:06:22,639 --> 00:06:27,590
related to this index and also to this

00:06:25,280 --> 00:06:31,300
application of that and joins is like

00:06:27,590 --> 00:06:33,979
the locality of data so when you have

00:06:31,300 --> 00:06:37,430
well stuff that is related to each other

00:06:33,979 --> 00:06:40,159
is also easily look so it's easily to be

00:06:37,430 --> 00:06:42,229
looked up in the database I mean by easy

00:06:40,159 --> 00:06:45,860
point operation or something then things

00:06:42,229 --> 00:06:47,810
get very fast and so if you look up

00:06:45,860 --> 00:06:51,229
you know RDB if you think about this is

00:06:47,810 --> 00:06:53,150
a huge matrix you have blobs of data and

00:06:51,229 --> 00:06:55,370
the rest is more or less the sparse

00:06:53,150 --> 00:06:57,050
matrix and well there's not really the

00:06:55,370 --> 00:06:59,569
optimal representation a sparse matrix

00:06:57,050 --> 00:07:03,939
with a huge matrix because it's not very

00:06:59,569 --> 00:07:06,860
fast so very simple example think about

00:07:03,939 --> 00:07:09,050
your favorite social network system and

00:07:06,860 --> 00:07:13,009
who is friends with whom who follows

00:07:09,050 --> 00:07:15,590
whom or whatever and then ask for who

00:07:13,009 --> 00:07:18,620
follows or who is friends with someone

00:07:15,590 --> 00:07:23,719
who is friends with this guy this is

00:07:18,620 --> 00:07:25,520
very easy a very nasty we say RDP or if

00:07:23,719 --> 00:07:27,500
you if you don't make it very nice then

00:07:25,520 --> 00:07:29,810
it's very bad because you have a double

00:07:27,500 --> 00:07:33,020
lookup through all the members in the

00:07:29,810 --> 00:07:35,569
database which can be a lot and that's

00:07:33,020 --> 00:07:38,210
not optimal while we said graph database

00:07:35,569 --> 00:07:40,580
is just following edges very fastly very

00:07:38,210 --> 00:07:41,569
fast and that's that's nice so double

00:07:40,580 --> 00:07:44,419
join a long crease

00:07:41,569 --> 00:07:46,520
so graph databases the basic idea is

00:07:44,419 --> 00:07:49,340
that you represent graphs and have

00:07:46,520 --> 00:07:51,020
relations as first-class objects it's

00:07:49,340 --> 00:07:52,550
like well if you go to function

00:07:51,020 --> 00:07:54,289
programming a function is first class

00:07:52,550 --> 00:07:57,440
object if you go to graph database you

00:07:54,289 --> 00:08:00,560
of relations at fast class object in the

00:07:57,440 --> 00:08:02,180
RDP s have our the relation in there but

00:08:00,560 --> 00:08:04,849
actually the relation is not the first

00:08:02,180 --> 00:08:07,190
class object it's just the table the

00:08:04,849 --> 00:08:09,050
structure it's not first class object

00:08:07,190 --> 00:08:11,349
this describes and this is different in

00:08:09,050 --> 00:08:14,150
a graph database so there are barriers

00:08:11,349 --> 00:08:16,580
after the busines this the most common

00:08:14,150 --> 00:08:20,930
is well you have a labelled property

00:08:16,580 --> 00:08:23,900
graph so you you can attach to each node

00:08:20,930 --> 00:08:26,960
and each relation a set of key value

00:08:23,900 --> 00:08:34,010
pairs and types and so that is very

00:08:26,960 --> 00:08:35,870
common it is its usual crud system so

00:08:34,010 --> 00:08:37,579
you can create read update and delete

00:08:35,870 --> 00:08:39,349
methods very standard and

00:08:37,579 --> 00:08:40,729
transactionality so you have everything

00:08:39,349 --> 00:08:44,329
you would expect from a normal database

00:08:40,729 --> 00:08:47,120
if you in this ok near 4g this is not

00:08:44,329 --> 00:08:51,470
the only one it's the one I used for

00:08:47,120 --> 00:08:54,589
used for this project there are several

00:08:51,470 --> 00:08:56,839
others data pieces read nothing I

00:08:54,589 --> 00:08:59,660
present here is really fixed to near 4G

00:08:56,839 --> 00:09:01,580
so near Fiji was one of the first it has

00:08:59,660 --> 00:09:04,340
native craft storage what does it mean

00:09:01,580 --> 00:09:06,980
you can of course take so there are two

00:09:04,340 --> 00:09:08,630
parts to graph therefore the one is the

00:09:06,980 --> 00:09:11,360
storage and the other is the computing

00:09:08,630 --> 00:09:14,720
engine you cure the database and I mean

00:09:11,360 --> 00:09:16,490
the storage can still be RDB but well it

00:09:14,720 --> 00:09:19,130
is not very efficient so the best thing

00:09:16,490 --> 00:09:22,460
is to have a native graph database where

00:09:19,130 --> 00:09:24,890
since relations and nodes are saved and

00:09:22,460 --> 00:09:27,380
notion knows nodes that are close to

00:09:24,890 --> 00:09:31,970
each other or directly related that

00:09:27,380 --> 00:09:33,830
immediately referential so this is you

00:09:31,970 --> 00:09:37,280
are not native craft storage there are a

00:09:33,830 --> 00:09:39,980
few others well in all kind of languages

00:09:37,280 --> 00:09:42,130
and well and maybe see this index 3 a

00:09:39,980 --> 00:09:44,510
Jason C that means that if you're really

00:09:42,130 --> 00:09:46,190
really in a dialect relation and you

00:09:44,510 --> 00:09:48,110
immediately can pick up your knee but

00:09:46,190 --> 00:09:50,090
you don't have to search anywhere so

00:09:48,110 --> 00:09:52,790
that makes it very easy to pull up notes

00:09:50,090 --> 00:09:55,130
and these questions like who is the

00:09:52,790 --> 00:09:57,770
friend of a friend of this guy that is

00:09:55,130 --> 00:10:02,270
just jumping over to relations which is

00:09:57,770 --> 00:10:04,340
very fast how to curate this language so

00:10:02,270 --> 00:10:06,590
there are many that is currently a big

00:10:04,340 --> 00:10:09,710
activity to standardize on this crafts

00:10:06,590 --> 00:10:11,480
creole language one of these craft

00:10:09,710 --> 00:10:13,040
Creole languages which are used here is

00:10:11,480 --> 00:10:16,070
cipher which was developed in together

00:10:13,040 --> 00:10:18,110
with neo for G it is the basic construe

00:10:16,070 --> 00:10:21,170
well it's just well you want to question

00:10:18,110 --> 00:10:24,200
ask you're like SQL you want to ask the

00:10:21,170 --> 00:10:25,850
database for some data and that well the

00:10:24,200 --> 00:10:29,030
basic construct is something like this

00:10:25,850 --> 00:10:32,240
you have a node and well two nodes in

00:10:29,030 --> 00:10:34,550
relation and well what you see here for

00:10:32,240 --> 00:10:37,820
example is a typical example where but

00:10:34,550 --> 00:10:39,530
here node 1 and node 2 and RL are just

00:10:37,820 --> 00:10:42,140
variables they don't have any meaning

00:10:39,530 --> 00:10:45,860
that just captured a specific node

00:10:42,140 --> 00:10:49,370
there's nothing more about this you

00:10:45,860 --> 00:10:53,360
typically Curie would be match note 1

00:10:49,370 --> 00:10:56,830
relation node 2 Rito well that's that's

00:10:53,360 --> 00:10:56,830
very bad I'm sorry

00:11:04,990 --> 00:11:10,630
so match it

00:11:16,580 --> 00:11:19,120
and

00:11:30,970 --> 00:11:39,610
well I did see if this is type 1 so this

00:11:36,580 --> 00:11:42,490
would be I give a and P here are the

00:11:39,610 --> 00:11:45,400
variables and then I say it should be of

00:11:42,490 --> 00:11:49,120
a certain type and this should be

00:11:45,400 --> 00:11:54,820
relation yeah and then what what should

00:11:49,120 --> 00:11:57,040
be returned is like return a a P so what

00:11:54,820 --> 00:11:58,870
what comes out here are two nodes and

00:11:57,040 --> 00:12:08,920
they have a relation that's that's all

00:11:58,870 --> 00:12:11,320
well easy to type so you can the the

00:12:08,920 --> 00:12:12,880
basic Kure well one of the best curious

00:12:11,320 --> 00:12:16,210
is matching searching for example you

00:12:12,880 --> 00:12:18,340
match you align you search somewhere and

00:12:16,210 --> 00:12:20,710
then well from there you define

00:12:18,340 --> 00:12:22,720
relations and return a certain set of

00:12:20,710 --> 00:12:25,900
nodes and then you get all this stuff

00:12:22,720 --> 00:12:27,940
back we will see this later in several

00:12:25,900 --> 00:12:30,310
other instances with the Debian packages

00:12:27,940 --> 00:12:32,230
so how do you create stuff it's in the

00:12:30,310 --> 00:12:34,990
same way like for example create and

00:12:32,230 --> 00:12:37,990
then I say what the type of the node I

00:12:34,990 --> 00:12:40,950
can attach arbitrary tags I told you for

00:12:37,990 --> 00:12:43,540
example name hello what hello or

00:12:40,950 --> 00:12:47,590
relation has no text so we can attach

00:12:43,540 --> 00:12:50,380
arbitrary text to these nodes and also

00:12:47,590 --> 00:12:53,260
to relations and that that creates that

00:12:50,380 --> 00:12:56,800
actually creates two type two nodes of

00:12:53,260 --> 00:13:00,670
type one and one relation we can select

00:12:56,800 --> 00:13:02,700
all all nodes of a certain type or we

00:13:00,670 --> 00:13:05,530
can select all nodes that are in

00:13:02,700 --> 00:13:07,660
relation one in a certain relation so

00:13:05,530 --> 00:13:10,270
you have a very expressive language to

00:13:07,660 --> 00:13:12,760
search about you can type this into each

00:13:10,270 --> 00:13:16,600
other so like like iterated searches

00:13:12,760 --> 00:13:19,450
it's a very powerful language I don't go

00:13:16,600 --> 00:13:22,360
into more details in this because wells

00:13:19,450 --> 00:13:25,200
well that would feel a whole talk here

00:13:22,360 --> 00:13:27,730
so next a bit about Debian I mean

00:13:25,200 --> 00:13:30,700
everyone knows here because it's deep in

00:13:27,730 --> 00:13:33,670
conference just to remind so you upload

00:13:30,700 --> 00:13:35,410
too unstable then it goes to testing and

00:13:33,670 --> 00:13:38,200
then then stable and then there are some

00:13:35,410 --> 00:13:42,610
other suits like experimental and

00:13:38,200 --> 00:13:44,170
whatever and all these packages or this

00:13:42,610 --> 00:13:44,889
information in these packages are

00:13:44,170 --> 00:13:48,569
recorded

00:13:44,889 --> 00:13:52,209
in the UDT we will see later and

00:13:48,569 --> 00:13:54,040
packagers have a lot of well we have

00:13:52,209 --> 00:13:56,350
source packages in binary packages

00:13:54,040 --> 00:13:58,600
everyone knows the developer upload

00:13:56,350 --> 00:14:02,439
source packages and well also binary

00:13:58,600 --> 00:14:04,359
packages and binary architectures other

00:14:02,439 --> 00:14:06,999
pioneer after sappy but how to build us

00:14:04,359 --> 00:14:09,939
and while all this is going to unstable

00:14:06,999 --> 00:14:12,339
I think we know about this this is from

00:14:09,939 --> 00:14:14,619
the handbook just a nice example this

00:14:12,339 --> 00:14:18,970
for people not know a bit about versions

00:14:14,619 --> 00:14:21,220
because this actually quite nasty if you

00:14:18,970 --> 00:14:24,369
come down to represent it so we have

00:14:21,220 --> 00:14:26,350
different versions in C testing stable

00:14:24,369 --> 00:14:28,540
unstable experimental security whatever

00:14:26,350 --> 00:14:30,790
quite a lot of versions the additional

00:14:28,540 --> 00:14:33,489
this intermediate that never made it

00:14:30,790 --> 00:14:35,529
into a release for example in asymptotes

00:14:33,489 --> 00:14:38,319
the package I maintained as the old old

00:14:35,529 --> 00:14:40,269
stable is they are to that one with the

00:14:38,319 --> 00:14:43,239
tip in extension and so on and there are

00:14:40,269 --> 00:14:44,829
many other in-between versions the full

00:14:43,239 --> 00:14:47,410
version string looks a bit has an

00:14:44,829 --> 00:14:49,029
addition the airport which is now please

00:14:47,410 --> 00:14:51,819
don't use it whatever but there are

00:14:49,029 --> 00:14:54,009
enough packages is still have it and up

00:14:51,819 --> 00:14:55,839
streamers nante been release we have a

00:14:54,009 --> 00:14:58,509
bit more complicated example here music

00:14:55,839 --> 00:15:02,619
stage which actually doesn't exist

00:14:58,509 --> 00:15:04,480
anymore which has an a poor version date

00:15:02,619 --> 00:15:06,879
drink when it was uploaded and the

00:15:04,480 --> 00:15:10,929
t-beam release so all this information

00:15:06,879 --> 00:15:13,209
is recorded somehow the components of a

00:15:10,929 --> 00:15:15,970
package I'm interested now here there

00:15:13,209 --> 00:15:18,069
many more but these are the ones I'm

00:15:15,970 --> 00:15:20,110
interested in this this representing in

00:15:18,069 --> 00:15:23,169
a graph is the maintainer well who is

00:15:20,110 --> 00:15:26,559
responsible for this upload us section

00:15:23,169 --> 00:15:29,350
priority versioning and dependency

00:15:26,559 --> 00:15:34,059
decorations there a lot more but I will

00:15:29,350 --> 00:15:36,850
not discuss them some caveats that you

00:15:34,059 --> 00:15:39,309
just realized only when you rewrite this

00:15:36,850 --> 00:15:41,949
this this package database in the graph

00:15:39,309 --> 00:15:43,509
databases as well one sauce package can

00:15:41,949 --> 00:15:46,209
build many different panel well we all

00:15:43,509 --> 00:15:48,519
know this but the source package and the

00:15:46,209 --> 00:15:50,259
binary and package name can be very

00:15:48,519 --> 00:15:52,539
different and can also come from

00:15:50,259 --> 00:15:55,239
different binary package can come from

00:15:52,539 --> 00:15:57,639
different source packages in different

00:15:55,239 --> 00:15:58,730
versions yeah like what I do is to take

00:15:57,639 --> 00:16:01,100
life we offer

00:15:58,730 --> 00:16:03,649
operate other packages that were

00:16:01,100 --> 00:16:06,560
packaged separately before and then you

00:16:03,649 --> 00:16:09,470
have some some temporary package for the

00:16:06,560 --> 00:16:12,440
upgrade so source package and primary

00:16:09,470 --> 00:16:14,449
package are quite different beasts here

00:16:12,440 --> 00:16:16,940
in the sense and if we want to represent

00:16:14,449 --> 00:16:19,130
this in the database we have to really

00:16:16,940 --> 00:16:22,430
present is face fully in some way you're

00:16:19,130 --> 00:16:25,910
not just package but well dependencies

00:16:22,430 --> 00:16:27,889
are also quite complicated we need the

00:16:25,910 --> 00:16:29,930
list is actually extending as far as I

00:16:27,889 --> 00:16:31,970
see always I mean for source packages

00:16:29,930 --> 00:16:33,589
for the built stuff for the binary

00:16:31,970 --> 00:16:37,010
package we have this and then we have

00:16:33,589 --> 00:16:39,649
various forms of dependencies it's like

00:16:37,010 --> 00:16:41,750
package just a normal package stand with

00:16:39,649 --> 00:16:43,459
a version version packages and a

00:16:41,750 --> 00:16:47,029
tentative packages and restrict it to

00:16:43,459 --> 00:16:49,130
some architectures all these can be also

00:16:47,029 --> 00:16:53,060
combined to mix together in some cases

00:16:49,130 --> 00:16:56,660
which makes it quite complicated ok the

00:16:53,060 --> 00:17:02,540
u DD the ultimate database is a very

00:16:56,660 --> 00:17:04,549
nice database which collects well if you

00:17:02,540 --> 00:17:07,130
have same purse in Brazil it's like the

00:17:04,549 --> 00:17:09,380
Ministry of Information there it's like

00:17:07,130 --> 00:17:12,049
everything from all sources is pulled

00:17:09,380 --> 00:17:13,910
into a huge process database admins take

00:17:12,049 --> 00:17:16,069
it source files packs from deep in from

00:17:13,910 --> 00:17:19,600
Ubuntu or the absolute the complete

00:17:16,069 --> 00:17:21,829
history it's impressive

00:17:19,600 --> 00:17:23,839
popular contest the whole history

00:17:21,829 --> 00:17:27,230
Olympian checks orphan package whatever

00:17:23,839 --> 00:17:29,570
so it's quite impressive the database

00:17:27,230 --> 00:17:34,429
scheme if anyone of you has checked is

00:17:29,570 --> 00:17:42,470
ever before it it is this well ok this

00:17:34,429 --> 00:17:46,730
is not very let me swim in yeah here the

00:17:42,470 --> 00:17:51,049
tables can make it a bit bigger so you

00:17:46,730 --> 00:17:53,270
have for wanna build all the tables here

00:17:51,049 --> 00:17:56,360
and then a few a few connection between

00:17:53,270 --> 00:18:00,919
the between the tables but generally

00:17:56,360 --> 00:18:03,799
it's yeah information about maintain us

00:18:00,919 --> 00:18:06,020
and package names and dependencies is

00:18:03,799 --> 00:18:07,940
repeated all over many many times

00:18:06,020 --> 00:18:10,790
who aches for example Ubuntu package

00:18:07,940 --> 00:18:13,210
summary and punto package the same

00:18:10,790 --> 00:18:19,220
information included several

00:18:13,210 --> 00:18:21,710
ubuntu box security issues where's the

00:18:19,220 --> 00:18:23,930
normal package yeah public packages so

00:18:21,710 --> 00:18:28,070
here is the typically binary package

00:18:23,930 --> 00:18:31,910
with version and well thousands of in

00:18:28,070 --> 00:18:33,800
stuff and well here summary again we see

00:18:31,910 --> 00:18:36,950
here for example maintain and name email

00:18:33,800 --> 00:18:39,950
is all of this is supplicated as i zoom

00:18:36,950 --> 00:18:42,590
out for just for the fun of it I think

00:18:39,950 --> 00:18:45,140
that's the complete you never want to

00:18:42,590 --> 00:18:48,250
read through all of it so if you look at

00:18:45,140 --> 00:18:51,220
this it's highly T normalized so I think

00:18:48,250 --> 00:18:53,840
every piece of data appears about like

00:18:51,220 --> 00:18:57,320
50 times in different places in this

00:18:53,840 --> 00:18:59,450
database which means also like I don't

00:18:57,320 --> 00:19:02,360
know actually how this is managed but

00:18:59,450 --> 00:19:03,260
updating one single field must be a real

00:19:02,360 --> 00:19:05,660
horrible thing

00:19:03,260 --> 00:19:08,450
it's a typical example drawn over the

00:19:05,660 --> 00:19:10,010
time I believe I mean I don't know but

00:19:08,450 --> 00:19:11,750
it looks like well which was pulling

00:19:10,010 --> 00:19:14,120
this and then we pull in data and pull

00:19:11,750 --> 00:19:16,700
in mortis and just stack everything on

00:19:14,120 --> 00:19:19,220
top and lots of the application without

00:19:16,700 --> 00:19:24,770
connection so there it's it was for me

00:19:19,220 --> 00:19:28,880
like okay if this we want to be actually

00:19:24,770 --> 00:19:31,370
used and well well if you want to de

00:19:28,880 --> 00:19:33,320
normally this you get into a huge hell

00:19:31,370 --> 00:19:35,450
of joins because you have to get all

00:19:33,320 --> 00:19:37,850
this information and so as it is now you

00:19:35,450 --> 00:19:39,590
have a huge application of data so both

00:19:37,850 --> 00:19:41,120
of this these options were not really

00:19:39,590 --> 00:19:43,940
like interesting from you so I thought

00:19:41,120 --> 00:19:45,770
that that is an interesting example of

00:19:43,940 --> 00:19:48,470
what one can do this graph databases

00:19:45,770 --> 00:19:51,260
comes back why do I do this it's like

00:19:48,470 --> 00:19:54,050
for me for our company we're for some

00:19:51,260 --> 00:19:56,390
clients we we use are we planning to use

00:19:54,050 --> 00:19:59,360
graphic databases and so that was one

00:19:56,390 --> 00:20:01,760
sort of like finger training to see what

00:19:59,360 --> 00:20:04,460
is possible and how you can what you can

00:20:01,760 --> 00:20:08,390
do is craft databases yeah I forgot it's

00:20:04,460 --> 00:20:10,400
a pleasure for SQL features if you look

00:20:08,390 --> 00:20:12,440
at some of the examples that pulls out

00:20:10,400 --> 00:20:15,590
data from the database is very

00:20:12,440 --> 00:20:17,060
impressive okay now so as I said I was

00:20:15,590 --> 00:20:21,350
interested in seeing what can be done

00:20:17,060 --> 00:20:23,650
can we put this into a well-crafted the

00:20:21,350 --> 00:20:26,270
piece that tries to represent the actual

00:20:23,650 --> 00:20:26,600
instances of objects in the sense for

00:20:26,270 --> 00:20:30,240
this

00:20:26,600 --> 00:20:32,610
maintainer into into different entities

00:20:30,240 --> 00:20:36,390
of the graph and well-paid connections

00:20:32,610 --> 00:20:38,790
between them and I will go through so to

00:20:36,390 --> 00:20:41,370
say that generation of the database

00:20:38,790 --> 00:20:43,440
schema the graph database scheme that

00:20:41,370 --> 00:20:44,960
means which type of nodes and which type

00:20:43,440 --> 00:20:47,340
of relations where I have developed

00:20:44,960 --> 00:20:49,590
step-by-step so that one sees also how

00:20:47,340 --> 00:20:51,690
one develops the graph database that her

00:20:49,590 --> 00:20:53,910
comes up with a graph database so that

00:20:51,690 --> 00:20:57,870
one can use it in in different occasions

00:20:53,910 --> 00:21:00,630
so the first is well a source package

00:20:57,870 --> 00:21:03,380
builds a binary right I mean yes that's

00:21:00,630 --> 00:21:06,180
one of the most please extinct

00:21:03,380 --> 00:21:08,190
already a seed source and binary are

00:21:06,180 --> 00:21:10,350
quite different pieces because well we

00:21:08,190 --> 00:21:13,440
know they're I have well the one binary

00:21:10,350 --> 00:21:15,840
can be built from different packages in

00:21:13,440 --> 00:21:20,040
different levels of different versions

00:21:15,840 --> 00:21:22,590
so this what we first do is something

00:21:20,040 --> 00:21:24,900
like have an inversion sauce package

00:21:22,590 --> 00:21:26,850
that represents so the name in the

00:21:24,900 --> 00:21:29,040
database but if you look up for example

00:21:26,850 --> 00:21:30,930
in packages deviant or a con the website

00:21:29,040 --> 00:21:34,290
you can put in a name or a source

00:21:30,930 --> 00:21:36,840
package name and well this is the most

00:21:34,290 --> 00:21:40,860
general that catch or fuss and we have

00:21:36,840 --> 00:21:42,540
also versions also versions source

00:21:40,860 --> 00:21:43,770
packages and worse and binaries these

00:21:42,540 --> 00:21:46,530
are then they actually if you go on

00:21:43,770 --> 00:21:47,640
packages in you click in DB in unstable

00:21:46,530 --> 00:21:50,280
you have diversion three point nine

00:21:47,640 --> 00:21:52,200
point seven whatever so what you come up

00:21:50,280 --> 00:21:56,310
what I came up here that this doesn't

00:21:52,200 --> 00:21:58,590
work of course is SP as what it now

00:21:56,310 --> 00:22:01,800
introduced that types of nodes and

00:21:58,590 --> 00:22:05,610
relations so names for specialty nodes

00:22:01,800 --> 00:22:08,550
well SP is a source package and VSP is a

00:22:05,610 --> 00:22:10,380
version sauce package and BP binary

00:22:08,550 --> 00:22:12,870
package in version binary package and

00:22:10,380 --> 00:22:15,330
then you have relation between them

00:22:12,870 --> 00:22:17,340
somehow naturally a versions source

00:22:15,330 --> 00:22:19,470
package is an instance of a sauce

00:22:17,340 --> 00:22:21,300
package well every source package this

00:22:19,470 --> 00:22:24,540
is a channel concept we need this later

00:22:21,300 --> 00:22:28,230
for relations but version stratum is an

00:22:24,540 --> 00:22:30,990
instance somehow the versions 3.9 - one

00:22:28,230 --> 00:22:32,520
for of the sauce package and the same

00:22:30,990 --> 00:22:34,860
with a version binary package is an

00:22:32,520 --> 00:22:36,420
instance of a binary package then we

00:22:34,860 --> 00:22:40,440
have the connection a source package

00:22:36,420 --> 00:22:43,380
built a binary package and we have

00:22:40,440 --> 00:22:45,690
next I introduced some next that we have

00:22:43,380 --> 00:22:48,000
so increasing relation where actually

00:22:45,690 --> 00:22:50,250
it's a three would be better to

00:22:48,000 --> 00:22:52,170
represent in some nice way but at the

00:22:50,250 --> 00:22:54,150
moment I only pull it in the information

00:22:52,170 --> 00:22:56,880
from from the released version it's no

00:22:54,150 --> 00:23:00,720
intermediate so what you get then in

00:22:56,880 --> 00:23:02,880
this case if you if you throw in all the

00:23:00,720 --> 00:23:04,410
nodes here it's like for example I

00:23:02,880 --> 00:23:09,770
search to think we have on the right

00:23:04,410 --> 00:23:09,770
side we have Louella sake this is a

00:23:13,520 --> 00:23:18,960
instead of this is a binary package yeah

00:23:16,800 --> 00:23:20,580
Louet sect is a binary package then on

00:23:18,960 --> 00:23:22,980
the right side the blue ones these are

00:23:20,580 --> 00:23:25,020
the version binary so if we have four

00:23:22,980 --> 00:23:26,610
versions at that time we're not to

00:23:25,020 --> 00:23:29,970
create it there were four versions of

00:23:26,610 --> 00:23:32,820
lewis ik in version primaries on the

00:23:29,970 --> 00:23:35,100
left side is the source part so you see

00:23:32,820 --> 00:23:38,130
here already that the first two source

00:23:35,100 --> 00:23:41,100
source packages were built from a source

00:23:38,130 --> 00:23:44,010
as this version source packages we are

00:23:41,100 --> 00:23:47,520
built from so these these two so as

00:23:44,010 --> 00:23:50,820
persians two aspects packages were built

00:23:47,520 --> 00:23:53,040
from a source package lua sec and later

00:23:50,820 --> 00:23:55,650
on we incorporated it into take life

00:23:53,040 --> 00:23:58,470
piece i guess i cannot read this now

00:23:55,650 --> 00:24:00,780
take life piece so then the source

00:23:58,470 --> 00:24:02,550
package name changed here version source

00:24:00,780 --> 00:24:04,050
package name but the binary package we

00:24:02,550 --> 00:24:06,000
build remained the same and these are

00:24:04,050 --> 00:24:08,430
just the built relations and here we

00:24:06,000 --> 00:24:11,190
have some next relations to get the next

00:24:08,430 --> 00:24:13,440
relation so these are so the basic steps

00:24:11,190 --> 00:24:15,030
were source package were sent to us

00:24:13,440 --> 00:24:18,210
packet binary package and whereas in

00:24:15,030 --> 00:24:23,970
final package next we want to introduce

00:24:18,210 --> 00:24:26,730
is suit like stable avoid stable stable

00:24:23,970 --> 00:24:29,190
testing unstable or experimental it's

00:24:26,730 --> 00:24:32,640
very easy diffuse contain a version

00:24:29,190 --> 00:24:35,370
binary package and that is just well

00:24:32,640 --> 00:24:37,770
contains is not very surprisingly named

00:24:35,370 --> 00:24:41,010
after this well if you put this in then

00:24:37,770 --> 00:24:43,080
you get here some simulations like seeds

00:24:41,010 --> 00:24:47,190
pasta stretch chassis and we see

00:24:43,080 --> 00:24:49,230
contains well all these versions here I

00:24:47,190 --> 00:24:50,940
of course I don't show all the other

00:24:49,230 --> 00:24:53,800
relations because they are they are

00:24:50,940 --> 00:24:56,440
quite a lot just if the view here

00:24:53,800 --> 00:24:58,540
we are using then for the next like

00:24:56,440 --> 00:25:02,380
maintenance what we do with maintain as

00:24:58,540 --> 00:25:04,420
well maintain us well a note will be a

00:25:02,380 --> 00:25:07,090
maintainer this will be we will see

00:25:04,420 --> 00:25:10,810
later like a name and an email address

00:25:07,090 --> 00:25:13,990
and maintains a virtual sauce package

00:25:10,810 --> 00:25:17,650
our virtual binary package if we do this

00:25:13,990 --> 00:25:19,930
here we add in the graph before for

00:25:17,650 --> 00:25:22,240
example here before before the

00:25:19,930 --> 00:25:24,550
incorporation of this package in to take

00:25:22,240 --> 00:25:27,700
life this package was maintained by the

00:25:24,550 --> 00:25:29,710
TV and science team and later on it

00:25:27,700 --> 00:25:31,720
moved into that life piece which was

00:25:29,710 --> 00:25:35,050
maintained by the Debian take maintain

00:25:31,720 --> 00:25:36,760
and team yeah and so we well there's the

00:25:35,050 --> 00:25:41,940
maintenance for the version sauce and

00:25:36,760 --> 00:25:41,940
binary package for these four packages

00:25:42,270 --> 00:25:48,150
well up to now it was easy

00:25:45,490 --> 00:25:50,140
now comes the nasty part and that's

00:25:48,150 --> 00:25:52,870
dependencies dependencies are very

00:25:50,140 --> 00:25:54,310
complicated to represent because as you

00:25:52,870 --> 00:25:57,060
have seen before we have very

00:25:54,310 --> 00:25:59,620
complicated expressions in dependency

00:25:57,060 --> 00:26:01,750
the first is a normal dependence it

00:25:59,620 --> 00:26:04,900
depends without aversion so I have to

00:26:01,750 --> 00:26:06,490
somehow point to a package without the

00:26:04,900 --> 00:26:08,920
version and so this is something I can

00:26:06,490 --> 00:26:13,450
do I can depend on simply a binary

00:26:08,920 --> 00:26:16,420
package and there is also in this

00:26:13,450 --> 00:26:18,730
relation I can put in a relation type

00:26:16,420 --> 00:26:22,450
which means less less as a strictly less

00:26:18,730 --> 00:26:24,010
less or equal exactly greater equal or

00:26:22,450 --> 00:26:26,530
strictly greater so there normal

00:26:24,010 --> 00:26:28,570
relation and the relation version so

00:26:26,530 --> 00:26:32,680
this information has to be recorded and

00:26:28,570 --> 00:26:35,560
here we used the the fact that we can

00:26:32,680 --> 00:26:37,510
add key value pairs to each node and

00:26:35,560 --> 00:26:42,400
relation here we add it to a relation

00:26:37,510 --> 00:26:44,380
and so on versioned dependencies are

00:26:42,400 --> 00:26:46,660
recorded with a relation type of norm

00:26:44,380 --> 00:26:50,230
just because something has to be in

00:26:46,660 --> 00:26:52,780
there yeah if we do this here we get a

00:26:50,230 --> 00:26:56,200
bit more complicated stuff so here we

00:26:52,780 --> 00:26:58,900
have have what we have for example down

00:26:56,200 --> 00:27:01,390
there we have built dependencies from

00:26:58,900 --> 00:27:04,180
the louisette package onto all kind of

00:27:01,390 --> 00:27:07,120
packages and lewis egg itself depends

00:27:04,180 --> 00:27:09,760
also on all kind of other packages so

00:27:07,120 --> 00:27:12,430
actually I think I did I think I showed

00:27:09,760 --> 00:27:17,380
all of them but that makes the graph

00:27:12,430 --> 00:27:19,570
already quite full there's a problem how

00:27:17,380 --> 00:27:21,160
to deal with I turn atif dependencies of

00:27:19,570 --> 00:27:23,710
course I mean how I do here we introduce

00:27:21,160 --> 00:27:26,230
a new type and your object and here you

00:27:23,710 --> 00:27:28,450
see also why it's so nice with the graph

00:27:26,230 --> 00:27:30,940
database because you can introduce a new

00:27:28,450 --> 00:27:33,010
subtract a new type of nodes without

00:27:30,940 --> 00:27:35,260
disturbing all the other relations

00:27:33,010 --> 00:27:37,630
nothing changes in the rest of the part

00:27:35,260 --> 00:27:39,940
you introduce a new new type of node and

00:27:37,630 --> 00:27:42,580
new relations but you don't have to

00:27:39,940 --> 00:27:44,680
record anything in it in the in some

00:27:42,580 --> 00:27:47,350
tables anywhere you just add these

00:27:44,680 --> 00:27:50,050
relations and nodes so what I said I

00:27:47,350 --> 00:27:52,990
just add a node it--it if dependencies

00:27:50,050 --> 00:27:55,360
that records the artin if dependencies

00:27:52,990 --> 00:27:57,670
as is and add something that is called

00:27:55,360 --> 00:27:59,410
is satisfied by an item if they fail

00:27:57,670 --> 00:28:01,540
dependency can be satisfied by either

00:27:59,410 --> 00:28:04,540
this or the other package that depends

00:28:01,540 --> 00:28:06,940
on a real binary package that allow us

00:28:04,540 --> 00:28:08,800
to represent it even it's it's necessary

00:28:06,940 --> 00:28:10,060
item if dependencies are structurally

00:28:08,800 --> 00:28:12,430
something different than a normal

00:28:10,060 --> 00:28:16,390
dependency because it can be satisfied

00:28:12,430 --> 00:28:20,200
by several packages ok so what up of the

00:28:16,390 --> 00:28:23,800
cemani summary of nodes and relations so

00:28:20,200 --> 00:28:25,870
on the nodes we have maintainer for the

00:28:23,800 --> 00:28:28,720
maintainer we record just the name and

00:28:25,870 --> 00:28:30,850
the email this is different to the 3d

00:28:28,720 --> 00:28:33,760
UDT or something in the UDP there is a

00:28:30,850 --> 00:28:36,400
complete the email is correct but the

00:28:33,760 --> 00:28:39,010
names of changes so there are many

00:28:36,400 --> 00:28:42,400
different names for the same mail email

00:28:39,010 --> 00:28:44,380
address in the in the u DD so it seems

00:28:42,400 --> 00:28:47,560
that uploader sometimes changed the name

00:28:44,380 --> 00:28:49,990
or the name of especially of groups then

00:28:47,560 --> 00:28:51,700
for a binary package sauce package suit

00:28:49,990 --> 00:28:54,070
and alternative dependencies there's

00:28:51,700 --> 00:28:56,650
nothing more than just the name but we

00:28:54,070 --> 00:28:59,500
want to how is this package called right

00:28:56,650 --> 00:29:01,480
and for versioned binary package and

00:28:59,500 --> 00:29:03,580
worse in two aspects we just add a name

00:29:01,480 --> 00:29:06,460
and diversion well since its version we

00:29:03,580 --> 00:29:07,810
want to note for the relations and there

00:29:06,460 --> 00:29:09,670
are attributes well for all these

00:29:07,810 --> 00:29:11,830
relations there are a lot of them they

00:29:09,670 --> 00:29:13,860
have just two as explained before they

00:29:11,830 --> 00:29:16,360
have the relation type whether it's

00:29:13,860 --> 00:29:20,260
unburdened or strictly less whatever

00:29:16,360 --> 00:29:23,529
these must enter the respective version

00:29:20,260 --> 00:29:24,820
and for built contains is instant off

00:29:23,529 --> 00:29:27,039
maintains and next there are no

00:29:24,820 --> 00:29:29,080
attributes it's just between the two

00:29:27,039 --> 00:29:30,850
entities this is the relation is read

00:29:29,080 --> 00:29:33,100
contains the following information a

00:29:30,850 --> 00:29:38,380
builds B tells you already everything

00:29:33,100 --> 00:29:41,620
you want to need okay summary of when I

00:29:38,380 --> 00:29:44,649
pull this down the last time we have 28

00:29:41,620 --> 00:29:47,110
suits which is quite a lot this is not

00:29:44,649 --> 00:29:50,740
only stable unstable of all the security

00:29:47,110 --> 00:29:54,220
or whatever we have maintained as 3510

00:29:50,740 --> 00:29:56,380
at this time so unique maintainer email

00:29:54,220 --> 00:29:59,260
addresses we have alternative

00:29:56,380 --> 00:30:01,870
dependencies appear in about 8,000 9,000

00:29:59,260 --> 00:30:04,419
cases sauce packages at that time well

00:30:01,870 --> 00:30:07,120
as well 32 or something thousand well

00:30:04,419 --> 00:30:10,720
binary package I don't come well anyway

00:30:07,120 --> 00:30:13,120
so you see quite a lot in total nodes in

00:30:10,720 --> 00:30:17,429
total of this graph and developed about

00:30:13,120 --> 00:30:20,260
half a million and relations well I

00:30:17,429 --> 00:30:23,080
don't count there are too many in total

00:30:20,260 --> 00:30:26,409
it's like 4.5 million relation entries

00:30:23,080 --> 00:30:30,220
in the graph database and this is only

00:30:26,409 --> 00:30:32,169
the data the information I've extracted

00:30:30,220 --> 00:30:34,630
by now this does not contain any

00:30:32,169 --> 00:30:36,429
information of packs the whole pack

00:30:34,630 --> 00:30:38,940
database is something I want to do later

00:30:36,429 --> 00:30:43,419
on okay

00:30:38,940 --> 00:30:45,870
how to get this whole stuff from the u

00:30:43,419 --> 00:30:48,490
DD into neo geo into a graph database

00:30:45,870 --> 00:30:50,860
well there is a public mirror for you DD

00:30:48,490 --> 00:30:53,230
it's a PostgreSQL post SQL server

00:30:50,860 --> 00:30:55,450
everyone can access it the information

00:30:53,230 --> 00:30:57,429
on the on the website gives you the

00:30:55,450 --> 00:31:00,240
username and password

00:30:57,429 --> 00:31:02,620
I use the perl script to access this is

00:31:00,240 --> 00:31:05,200
completely standard of course I pulled

00:31:02,620 --> 00:31:06,789
once only the whole data in to see if I

00:31:05,200 --> 00:31:10,600
love whatever and then and worked on

00:31:06,789 --> 00:31:12,490
this my first try this is now for a

00:31:10,600 --> 00:31:14,320
forbid people with witchcraft in my

00:31:12,490 --> 00:31:15,700
first tried to generate a lot of cypher

00:31:14,320 --> 00:31:18,610
statements because that was quite easy

00:31:15,700 --> 00:31:22,120
and just feed the cypher statements into

00:31:18,610 --> 00:31:25,990
the graph database that was not really a

00:31:22,120 --> 00:31:29,919
good idea I just say that I think after

00:31:25,990 --> 00:31:32,230
a few hours I stopped and I think we

00:31:29,919 --> 00:31:33,680
wear like a one-parameter ooh the data

00:31:32,230 --> 00:31:35,510
of lines

00:31:33,680 --> 00:31:37,910
the problem is with the cipher statement

00:31:35,510 --> 00:31:39,920
you have to lock the whole database make

00:31:37,910 --> 00:31:41,960
the transaction and then do it out so

00:31:39,920 --> 00:31:44,510
that's completely impossible to actually

00:31:41,960 --> 00:31:47,390
carry out so there's an e of a G import

00:31:44,510 --> 00:31:50,630
tool that where you create for each node

00:31:47,390 --> 00:31:55,190
and note type and each relation type a

00:31:50,630 --> 00:31:59,090
CSV file and then you feed this in yes

00:31:55,190 --> 00:32:01,100
ten seconds for this five million data

00:31:59,090 --> 00:32:05,030
points I mentioned before so that was

00:32:01,100 --> 00:32:08,060
quite easy I recommend to not even think

00:32:05,030 --> 00:32:12,650
about using cipher for for anything for

00:32:08,060 --> 00:32:15,110
any import of huge data that's good

00:32:12,650 --> 00:32:16,910
how do I do this just for those the Perl

00:32:15,110 --> 00:32:18,800
program that pulls the data from the

00:32:16,910 --> 00:32:21,440
from the UDT is a Perl program that

00:32:18,800 --> 00:32:24,530
saves the whole stuff in CSV generates a

00:32:21,440 --> 00:32:27,260
huge hash reorders all the staff deals

00:32:24,530 --> 00:32:29,780
with inconsistencies in the whole

00:32:27,260 --> 00:32:33,200
database like different maintenance with

00:32:29,780 --> 00:32:35,960
the same email you type packages are not

00:32:33,200 --> 00:32:38,890
treated with all this kind of stuff then

00:32:35,960 --> 00:32:41,510
generates for each item a unique UI ID

00:32:38,890 --> 00:32:43,370
there's necessary for the CSV and for

00:32:41,510 --> 00:32:46,220
the linking and then generate the

00:32:43,370 --> 00:32:49,730
necessary CSV files it's a bit

00:32:46,220 --> 00:32:52,040
convoluted Perl script but it's not so

00:32:49,730 --> 00:32:53,840
bad some sample Curie's since we are

00:32:52,040 --> 00:32:56,120
running out of time okay this is a

00:32:53,840 --> 00:32:58,790
complex query you have seen only bit off

00:32:56,120 --> 00:33:00,950
of cypher but I want to see but it's

00:32:58,790 --> 00:33:03,050
actually readable so what do you say if

00:33:00,950 --> 00:33:06,890
you remember what PP and all this is

00:33:03,050 --> 00:33:09,500
well what we search for find our

00:33:06,890 --> 00:33:13,190
packages in chassis that peel depends on

00:33:09,500 --> 00:33:16,460
some version of tej common well all at

00:33:13,190 --> 00:33:18,710
the end is a stop name is Jessie so suit

00:33:16,460 --> 00:33:21,080
is when if you start on the right pair

00:33:18,710 --> 00:33:23,840
right on the back here there's this you

00:33:21,080 --> 00:33:27,140
chassis and chassis should contain a

00:33:23,840 --> 00:33:30,940
binary package write the binary package

00:33:27,140 --> 00:33:34,310
is captured in this VPP in this variable

00:33:30,940 --> 00:33:37,040
variable and well then we need a source

00:33:34,310 --> 00:33:40,190
package that builds this binary package

00:33:37,040 --> 00:33:41,810
and you seek on when you curie the stuff

00:33:40,190 --> 00:33:44,990
you can have relations in all directions

00:33:41,810 --> 00:33:47,030
you want and then

00:33:44,990 --> 00:33:48,710
anti source package built upon

00:33:47,030 --> 00:33:50,660
from the binary package and the binary

00:33:48,710 --> 00:33:52,970
package in a mistake common what you get

00:33:50,660 --> 00:34:07,250
is what you see down there so this on

00:33:52,970 --> 00:34:08,870
the on the left is so here no that was

00:34:07,250 --> 00:34:11,750
the wrong one that is the right one

00:34:08,870 --> 00:34:13,880
so here you have taken common and here

00:34:11,750 --> 00:34:16,310
you have chassis and well they are all

00:34:13,880 --> 00:34:19,220
the packages in between so what I'm

00:34:16,310 --> 00:34:23,870
using here is the Neo 4G browser you can

00:34:19,220 --> 00:34:29,050
use normal web browser also for this

00:34:23,870 --> 00:34:29,050
kind of stuff so to give you an idea

00:34:42,740 --> 00:34:49,879
okay yeah that looks a bit like yeah

00:34:47,960 --> 00:34:51,710
it's JavaScript doing all this kind of

00:34:49,879 --> 00:34:55,460
stuff after this you can reorder this

00:34:51,710 --> 00:34:56,869
and then the location is fixed and after

00:34:55,460 --> 00:35:00,680
some time they've really really really

00:34:56,869 --> 00:35:02,570
stops until you kick it again so well if

00:35:00,680 --> 00:35:05,210
you click on one of these nodes you see

00:35:02,570 --> 00:35:07,940
Bella although the name or the package

00:35:05,210 --> 00:35:09,980
and diversion or the relation between

00:35:07,940 --> 00:35:12,770
this kind of stuff is there built

00:35:09,980 --> 00:35:14,570
depends there's for example a relation

00:35:12,770 --> 00:35:17,650
type and a relation on the lower part

00:35:14,570 --> 00:35:25,630
here so all this here information is

00:35:17,650 --> 00:35:28,339
Tali we recorded in the database

00:35:25,630 --> 00:35:31,490
another question is like the number of

00:35:28,339 --> 00:35:33,890
packages in seats that bill depends on X

00:35:31,490 --> 00:35:36,470
whatever package and order by the number

00:35:33,890 --> 00:35:38,690
of depending packages well but it's a

00:35:36,470 --> 00:35:43,010
bit more complicated curie but actually

00:35:38,690 --> 00:35:45,710
not it's just duties against it and we

00:35:43,010 --> 00:35:47,990
want dependable dependency on something

00:35:45,710 --> 00:35:52,450
and then you see also that you can add

00:35:47,990 --> 00:35:54,830
something like well like in SQL some

00:35:52,450 --> 00:35:56,540
allocation function like counting on

00:35:54,830 --> 00:35:59,119
this kind of stuff or something and then

00:35:56,540 --> 00:36:02,119
return and order by so it's for if you

00:35:59,119 --> 00:36:04,580
know SQL it's it's besides this match

00:36:02,119 --> 00:36:06,500
statement it's very similar so what you

00:36:04,580 --> 00:36:10,220
get is there paper is not surprisingly

00:36:06,500 --> 00:36:12,470
the the biggest use used and th

00:36:10,220 --> 00:36:17,060
tightness the second one which was quite

00:36:12,470 --> 00:36:20,660
surprising I have no I think that's

00:36:17,060 --> 00:36:24,730
that's the second well I have many more

00:36:20,660 --> 00:36:27,589
but then one short some conclusions and

00:36:24,730 --> 00:36:29,060
so finding a good representation in the

00:36:27,589 --> 00:36:33,349
graph is not easy it's not

00:36:29,060 --> 00:36:35,900
straightforward actually it's converting

00:36:33,349 --> 00:36:37,339
a traditional RDB and a system of RDP

00:36:35,900 --> 00:36:40,010
into a graph database is actually

00:36:37,339 --> 00:36:42,410
somehow a pain because you have all this

00:36:40,010 --> 00:36:45,170
old material it's a very nice technique

00:36:42,410 --> 00:36:47,480
if you start from fresh if you want to

00:36:45,170 --> 00:36:50,839
represent some customer data whatever

00:36:47,480 --> 00:36:54,560
then graph it that has some resemblance

00:36:50,839 --> 00:36:56,119
to graph then graph database is probably

00:36:54,560 --> 00:36:59,569
better with and then

00:36:56,119 --> 00:37:01,309
our DP nowadays well don't use cypher

00:36:59,569 --> 00:37:05,509
for importing any reasonable amount of

00:37:01,309 --> 00:37:08,890
data well as it grown old grown our DPS

00:37:05,509 --> 00:37:11,930
or recipe and it's also a bit

00:37:08,890 --> 00:37:13,969
visualization is a bit of a problem it

00:37:11,930 --> 00:37:16,670
depends on which version of Chrome and

00:37:13,969 --> 00:37:20,059
Firefox and sometimes as fast times it

00:37:16,670 --> 00:37:23,559
slow I think there's it has to be with

00:37:20,059 --> 00:37:25,699
the Blood Moon or something anyway

00:37:23,559 --> 00:37:27,859
visualization works they have to shift

00:37:25,699 --> 00:37:30,380
out recently a new to near 40 it's

00:37:27,859 --> 00:37:33,170
called bloom it's only forecast clean

00:37:30,380 --> 00:37:36,559
customers unfortunately that should help

00:37:33,170 --> 00:37:38,930
in visualization but actually there are

00:37:36,559 --> 00:37:40,849
some other libraries based on just the

00:37:38,930 --> 00:37:45,609
interfaces open the specification is

00:37:40,849 --> 00:37:49,039
open it's all going into the Open Graph

00:37:45,609 --> 00:37:50,599
graph specification language I don't

00:37:49,039 --> 00:37:52,249
know what's the official name was so

00:37:50,599 --> 00:37:53,930
this will be all standard I is in the

00:37:52,249 --> 00:37:55,880
process of being standardized so there

00:37:53,930 --> 00:37:58,759
will be for sure better tools in the in

00:37:55,880 --> 00:38:02,660
the near future there are some things I

00:37:58,759 --> 00:38:04,579
want to do allowing time the biggest one

00:38:02,660 --> 00:38:08,660
is the packet database that would

00:38:04,579 --> 00:38:11,479
probably make the database the graph

00:38:08,660 --> 00:38:14,109
quite huge but it's on the Harahan quite

00:38:11,479 --> 00:38:17,029
nice because things like well in which

00:38:14,109 --> 00:38:18,949
package version a packet it appear and

00:38:17,029 --> 00:38:21,229
when it was fixed and all this

00:38:18,949 --> 00:38:24,410
information is quite easy to represent

00:38:21,229 --> 00:38:26,140
in this graph it would be also possible

00:38:24,410 --> 00:38:28,369
to get all the information of

00:38:26,140 --> 00:38:30,229
intermediate uploads from the

00:38:28,369 --> 00:38:33,769
yudhishtira is a table somewhere hidden

00:38:30,229 --> 00:38:35,929
this is is the the upload table so all

00:38:33,769 --> 00:38:38,569
this information is somehow table they

00:38:35,929 --> 00:38:40,939
are but it needs somehow parsing the

00:38:38,569 --> 00:38:43,459
dependency management could be rewritten

00:38:40,939 --> 00:38:46,999
I'm not sure if this is the optimal

00:38:43,459 --> 00:38:49,789
representation of it what would be nice

00:38:46,999 --> 00:38:51,859
to represent some then I mean if you

00:38:49,789 --> 00:38:54,920
have done all this but this well it's

00:38:51,859 --> 00:38:57,319
not a one-man show it's just represent

00:38:54,920 --> 00:39:01,249
some of the UDT dashboard or some of the

00:38:57,319 --> 00:39:03,109
services within TBN by interfacing to

00:39:01,249 --> 00:39:05,299
the graph database instead of this UDT

00:39:03,109 --> 00:39:07,759
just in the hope that it well

00:39:05,299 --> 00:39:09,930
speeds makes code more interesting or

00:39:07,759 --> 00:39:11,460
alpha more graph theory the

00:39:09,930 --> 00:39:15,290
other things I'm interested more crafts

00:39:11,460 --> 00:39:17,970
heretics is like cycle dependencies like

00:39:15,290 --> 00:39:20,040
connected components things that group

00:39:17,970 --> 00:39:22,710
how how stronger connections between

00:39:20,040 --> 00:39:25,830
certain packages so that's more on the

00:39:22,710 --> 00:39:27,420
graph theoretic side ok the sources and

00:39:25,830 --> 00:39:30,210
everything is on github

00:39:27,420 --> 00:39:32,010
there are also some slides and thanks

00:39:30,210 --> 00:39:34,800
for mentioning I should do this yes I

00:39:32,010 --> 00:39:37,500
will put also put some rap words on my

00:39:34,800 --> 00:39:40,620
block on this I will link it here and

00:39:37,500 --> 00:39:44,490
put it also in github or at least some

00:39:40,620 --> 00:39:46,470
part so a markdown version of it into

00:39:44,490 --> 00:39:49,050
github that the blocks are readily

00:39:46,470 --> 00:39:51,060
available ok

00:39:49,050 --> 00:39:53,880
thanks for the attention and well if

00:39:51,060 --> 00:40:01,389
there are questions I'm open to everyone

00:39:53,880 --> 00:40:01,389
[Applause]

00:40:13,240 --> 00:40:23,950
good coffee break

00:40:16,470 --> 00:40:23,950

YouTube URL: https://www.youtube.com/watch?v=QR4T7xSXrcE


