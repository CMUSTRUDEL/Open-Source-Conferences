Title: Building a Debian Derivative: Lessons Learned and Solutions Found
Publication date: 2018-07-31
Playlist: DebConf 18
Description: 
	by Alex Doyle

At: DebConf18
https://debconf18.debconf.org/talks/82-building-a-debian-derivative-lessons-learned-and-solutions-found/

This introductory level talk will provide an overview of the build workflow for a Debian derivative by discussing the challenges inherent in being the sole manager of everything from source code commits to published packages. Real world examples will be provided from Cumulus Linux: a Debian derivative for white box network switches.  Topics covered will include:

- Incorporating Debian as the upstream.
- Choosing software to meet build requirements.
- Lessons learned after the aforementioned software was chosen.
- Where some distribution specific customization will be required.
- Difficulties in supporting multiple architectures.
- The role of human factors in making the build system invisible.
- And why a good dynamic package versioning scheme is very, very important.

The intended audience would be anyone setting up a Debian Derivative, or anyone seeking a greater awareness of what commonly used Debian build tools are available, and what roles they perform.

Room: Xueshan (雪山)
Scheduled start: 2018-07-30 15:00:00
Captions: 
	00:00:07,850 --> 00:00:14,699
hello everyone today we will be having a

00:00:10,770 --> 00:00:20,420
talk on building a debian derivative by

00:00:14,699 --> 00:00:20,420
Alex Doyle also please enjoy thank you

00:00:21,199 --> 00:00:26,339
hi so let me just say straight up that I

00:00:25,109 --> 00:00:28,499
had a lot of twenty minutes for this

00:00:26,339 --> 00:00:30,089
talk and then some 10 minutes for

00:00:28,499 --> 00:00:32,520
questions and I've got 20 totals so I

00:00:30,089 --> 00:00:34,079
will be blowing through a few things so

00:00:32,520 --> 00:00:36,000
some of the slides they will be posted

00:00:34,079 --> 00:00:38,340
up wherever we get the slides posted

00:00:36,000 --> 00:00:40,350
I'll figure that out later but let me

00:00:38,340 --> 00:00:42,060
introduce myself I'm Alex Doyle I'm a

00:00:40,350 --> 00:00:42,600
building release engineer at cumulus

00:00:42,060 --> 00:00:44,730
networks

00:00:42,600 --> 00:00:46,020
I hope Debian is our build system about

00:00:44,730 --> 00:00:47,820
three years ago it went from a

00:00:46,020 --> 00:00:49,320
monolithic image build to a bill that

00:00:47,820 --> 00:00:51,270
actually built packages and could be

00:00:49,320 --> 00:00:54,750
upgraded a little more dynamically than

00:00:51,270 --> 00:00:56,220
it was and it's because it's Debian it's

00:00:54,750 --> 00:00:57,630
a much more sustainable development

00:00:56,220 --> 00:00:59,850
model with being able to turn out bug

00:00:57,630 --> 00:01:01,380
fixes and stuff so I've got some

00:00:59,850 --> 00:01:04,500
familiarity with how cumulus Linux

00:01:01,380 --> 00:01:06,180
builds in today's talk I'll be talking

00:01:04,500 --> 00:01:08,520
about what makes Debian derivative

00:01:06,180 --> 00:01:10,560
different from Debian the components of

00:01:08,520 --> 00:01:12,869
a derivative build system using cumulus

00:01:10,560 --> 00:01:14,999
Linux as an example and I won't be doing

00:01:12,869 --> 00:01:16,140
a comparison with existing build systems

00:01:14,999 --> 00:01:17,399
I think with derivatives the

00:01:16,140 --> 00:01:18,840
requirements of what they're supposed to

00:01:17,399 --> 00:01:19,740
achieve different off that you can't

00:01:18,840 --> 00:01:23,729
really get a good one to one

00:01:19,740 --> 00:01:25,350
corresponding there and I'll conclude

00:01:23,729 --> 00:01:26,460
the talk with problems to expect if

00:01:25,350 --> 00:01:29,100
you're dealing with a derivative and

00:01:26,460 --> 00:01:30,780
lessons to be learned from that this

00:01:29,100 --> 00:01:32,249
talk is an introductory level talk I

00:01:30,780 --> 00:01:34,170
wanted to try and broaden the audience

00:01:32,249 --> 00:01:36,299
so I won't be delving too deeply into

00:01:34,170 --> 00:01:37,619
build system details until the very end

00:01:36,299 --> 00:01:39,030
there's gonna be a lot of introduction

00:01:37,619 --> 00:01:40,950
at the beginning so if you're familiar

00:01:39,030 --> 00:01:43,729
with how to build systems work the first

00:01:40,950 --> 00:01:46,109
five minutes this may be a little boring

00:01:43,729 --> 00:01:47,759
so the example I'll be using is cumulus

00:01:46,109 --> 00:01:50,280
Linux it's an operating system from

00:01:47,759 --> 00:01:51,749
white box network switches the logical

00:01:50,280 --> 00:01:53,579
question is what's a white box network

00:01:51,749 --> 00:01:55,229
switch and it's a switch where the owner

00:01:53,579 --> 00:01:57,149
install their choice of operating system

00:01:55,229 --> 00:01:58,679
they're usually less expensive than

00:01:57,149 --> 00:02:00,149
switches with proprietary operating

00:01:58,679 --> 00:02:02,880
systems you can think of it as embedded

00:02:00,149 --> 00:02:04,499
PC where the network controller has a

00:02:02,880 --> 00:02:07,560
dedicated switching ASIC and a whole lot

00:02:04,499 --> 00:02:09,270
of network ports on it so as a debian

00:02:07,560 --> 00:02:11,610
derivative cumulus linux pretty much

00:02:09,270 --> 00:02:13,830
looks like debian plus switch ASIC code

00:02:11,610 --> 00:02:16,140
from vendors like Broadcom or mela Doc's

00:02:13,830 --> 00:02:17,250
adding cumulus specific software to help

00:02:16,140 --> 00:02:18,330
interface to the chip and make

00:02:17,250 --> 00:02:21,540
everything manageable

00:02:18,330 --> 00:02:23,370
and then you've got cumulus Linux so why

00:02:21,540 --> 00:02:25,170
would anybody create a derivative well

00:02:23,370 --> 00:02:26,910
basically a derivative is Debian plus

00:02:25,170 --> 00:02:29,250
other stuff and the reasons for other

00:02:26,910 --> 00:02:31,350
stuff may include software that can't be

00:02:29,250 --> 00:02:33,780
added to Debian like I said the ASIC

00:02:31,350 --> 00:02:36,000
code is proprietary there may be strict

00:02:33,780 --> 00:02:37,680
package interdependencies cumulus uses

00:02:36,000 --> 00:02:39,330
its own version of the kernel and the

00:02:37,680 --> 00:02:40,940
ASIC code is tied very hard into that

00:02:39,330 --> 00:02:43,050
I'll talk a little bit about that later

00:02:40,940 --> 00:02:44,700
you might need a custom installer for

00:02:43,050 --> 00:02:45,960
your target hardware in which case you

00:02:44,700 --> 00:02:48,510
know we're installing on switches or a

00:02:45,960 --> 00:02:50,070
little different than pcs and you may

00:02:48,510 --> 00:02:51,750
need to deliver bug fixes faster than

00:02:50,070 --> 00:02:53,910
upstreaming allows which is not to say

00:02:51,750 --> 00:02:55,500
that cumulus doesn't upstream fixes we

00:02:53,910 --> 00:02:56,880
do it just takes a little longer than

00:02:55,500 --> 00:02:59,340
then them getting out into the field

00:02:56,880 --> 00:03:01,260
with a regular release but the Linux

00:02:59,340 --> 00:03:02,580
kernel kernel networking and free range

00:03:01,260 --> 00:03:05,610
routing projects are just two examples

00:03:02,580 --> 00:03:06,990
where we've contributed a lot of code so

00:03:05,610 --> 00:03:08,670
common requirements for derivative

00:03:06,990 --> 00:03:10,320
generally to produce it you have to

00:03:08,670 --> 00:03:12,480
build custom packages you have to

00:03:10,320 --> 00:03:14,160
include Debian packages you'll need an

00:03:12,480 --> 00:03:15,720
installer to deploy it sometimes and

00:03:14,160 --> 00:03:19,350
then you need to make repositories and

00:03:15,720 --> 00:03:21,360
the installer available so components

00:03:19,350 --> 00:03:23,700
you're really probably gonna need build

00:03:21,360 --> 00:03:26,100
hardware obviously a cumulus we use

00:03:23,700 --> 00:03:27,450
shared build systems we find it's easier

00:03:26,100 --> 00:03:28,950
to support and maintain a couple of

00:03:27,450 --> 00:03:31,560
identically configured build systems

00:03:28,950 --> 00:03:32,970
rather than everybody's laptop you'll

00:03:31,560 --> 00:03:34,620
need something for source control use

00:03:32,970 --> 00:03:36,270
get because it's well supported it works

00:03:34,620 --> 00:03:39,239
and most people kind of at least a

00:03:36,270 --> 00:03:40,739
little bit understand it if you have

00:03:39,239 --> 00:03:42,480
multiple users using the same build

00:03:40,739 --> 00:03:43,860
system you'll need some way of isolating

00:03:42,480 --> 00:03:45,209
them because as they do build

00:03:43,860 --> 00:03:46,800
dependencies will come in that will

00:03:45,209 --> 00:03:50,070
change the configuration of a system and

00:03:46,800 --> 00:03:52,110
hilarity will ensue so we used schrutes

00:03:50,070 --> 00:03:58,950
on everybody's got the pronunciation on

00:03:52,110 --> 00:04:01,739
that is it's s true tort root okay good

00:03:58,950 --> 00:04:03,680
I didn't lose a bet there and it creates

00:04:01,739 --> 00:04:06,000
a virtual file system to isolate builds

00:04:03,680 --> 00:04:08,489
so when the dependencies install they

00:04:06,000 --> 00:04:09,840
don't interrupt anybody else then once

00:04:08,489 --> 00:04:12,209
you've had that environment something to

00:04:09,840 --> 00:04:13,860
help build with it we use s build which

00:04:12,209 --> 00:04:15,480
is also used by the Debian build systems

00:04:13,860 --> 00:04:17,310
which sets up the Schrute build

00:04:15,480 --> 00:04:19,019
environment installs dependencies build

00:04:17,310 --> 00:04:20,459
packages run sanity checks on the

00:04:19,019 --> 00:04:22,950
packaging and cleans up after itself

00:04:20,459 --> 00:04:25,110
once you've got a package it needs to be

00:04:22,950 --> 00:04:28,620
uploaded to your local mirror so we use

00:04:25,110 --> 00:04:30,300
a DEP load to do that and then once it's

00:04:28,620 --> 00:04:31,889
in the repository you need something to

00:04:30,300 --> 00:04:34,770
actually be the repository

00:04:31,889 --> 00:04:37,080
software we use rebury bro which has

00:04:34,770 --> 00:04:39,030
nice advantages of being able to sync it

00:04:37,080 --> 00:04:41,939
some packages from upstream and then

00:04:39,030 --> 00:04:43,349
handle adding our own things I found

00:04:41,939 --> 00:04:45,689
that we're nice to have when we started

00:04:43,349 --> 00:04:47,430
developing things server configuration

00:04:45,689 --> 00:04:49,770
build scripts you can use bash ansible

00:04:47,430 --> 00:04:51,689
whatever works basically the idea is to

00:04:49,770 --> 00:04:53,279
get a reproducible build server setup

00:04:51,689 --> 00:04:54,689
you don't want magic machines where your

00:04:53,279 --> 00:04:58,050
code only builds on this one particular

00:04:54,689 --> 00:04:59,999
system because reasons it's super

00:04:58,050 --> 00:05:01,439
irritating to deal with and if you have

00:04:59,999 --> 00:05:03,180
the scripts you know what the standard

00:05:01,439 --> 00:05:06,090
is and you can apply them to virtual

00:05:03,180 --> 00:05:07,529
machines and run experiments so that

00:05:06,090 --> 00:05:09,330
when you're trying to introduce new

00:05:07,529 --> 00:05:10,529
features it's easy enough to check you

00:05:09,330 --> 00:05:12,110
know hide your mistakes from everybody

00:05:10,529 --> 00:05:14,219
else and then publish stuff that works

00:05:12,110 --> 00:05:17,099
you may need build and test automation

00:05:14,219 --> 00:05:18,930
so we've got Jenkins to run builds when

00:05:17,099 --> 00:05:21,990
code gets checked in and to run tests on

00:05:18,930 --> 00:05:22,979
new builds because we're a distribution

00:05:21,990 --> 00:05:24,300
we'll be shipping a collection of

00:05:22,979 --> 00:05:26,879
packages and we need to track that

00:05:24,300 --> 00:05:28,229
somewhere so we have a release manifest

00:05:26,879 --> 00:05:30,719
file it's basically a collection of

00:05:28,229 --> 00:05:32,550
packages and versions it gets used by

00:05:30,719 --> 00:05:34,650
our installer package to know our

00:05:32,550 --> 00:05:36,120
installer code rather to use when

00:05:34,650 --> 00:05:37,949
installing a switch so it basically

00:05:36,120 --> 00:05:40,650
bundles up all the libraries and takes

00:05:37,949 --> 00:05:42,659
them with them and it's also handy for

00:05:40,650 --> 00:05:44,789
creating previous releases for bug

00:05:42,659 --> 00:05:47,399
tracking purposes there's our installer

00:05:44,789 --> 00:05:48,930
program which I just mentioned which

00:05:47,399 --> 00:05:50,669
puts our code on the target and it will

00:05:48,930 --> 00:05:53,370
handle any hardware quirks of the target

00:05:50,669 --> 00:05:54,629
you know hardware it tends to have a

00:05:53,370 --> 00:05:55,979
number of differences especially when

00:05:54,629 --> 00:05:57,270
you're dealing with switches so being

00:05:55,979 --> 00:05:58,589
able to understand this is slightly

00:05:57,270 --> 00:06:02,610
different at that or this is a different

00:05:58,589 --> 00:06:04,349
model super helpful in the development

00:06:02,610 --> 00:06:05,909
of this I found I really needed one tool

00:06:04,349 --> 00:06:06,960
that would build any package I'd

00:06:05,909 --> 00:06:09,839
originally thought I could do this with

00:06:06,960 --> 00:06:11,370
Jenkins but I ended up using a writing a

00:06:09,839 --> 00:06:13,919
cumulus master build tool other

00:06:11,370 --> 00:06:14,990
distributions may have different tools

00:06:13,919 --> 00:06:18,389
for this I believe

00:06:14,990 --> 00:06:19,439
Calabro uses auto builder but I need

00:06:18,389 --> 00:06:21,270
something that would put all the package

00:06:19,439 --> 00:06:22,649
build quirks in one place and it's a

00:06:21,270 --> 00:06:26,069
good interface for the automation to

00:06:22,649 --> 00:06:27,930
connect to it it's like Jenkins and then

00:06:26,069 --> 00:06:29,550
I also found out that it with doing a

00:06:27,930 --> 00:06:31,589
derivative it was really helpful to have

00:06:29,550 --> 00:06:33,689
a build tool wrapper which would help

00:06:31,589 --> 00:06:35,069
enforce conventions when doing builds

00:06:33,689 --> 00:06:36,899
and could also simplify the user

00:06:35,069 --> 00:06:38,370
learning curve by setting defaults I'll

00:06:36,899 --> 00:06:41,300
talk a little bit about more this and a

00:06:38,370 --> 00:06:43,100
little bit more about this in a minute

00:06:41,300 --> 00:06:44,570
so the general workflow at this point if

00:06:43,100 --> 00:06:46,040
you're a developer you log into the

00:06:44,570 --> 00:06:48,230
build system you check out your code

00:06:46,040 --> 00:06:50,120
with git you build using s build and a

00:06:48,230 --> 00:06:51,380
Schrute you theoretically test your

00:06:50,120 --> 00:06:54,220
deaths before you commit your code

00:06:51,380 --> 00:06:57,020
changes once the code is committed

00:06:54,220 --> 00:06:58,940
Jenkins takes over because I it triggers

00:06:57,020 --> 00:07:00,620
on a code commit checks out the code

00:06:58,940 --> 00:07:02,870
from get build to the package using the

00:07:00,620 --> 00:07:04,430
masterbuilt build tool wrapper it

00:07:02,870 --> 00:07:06,890
uploads the built package into the local

00:07:04,430 --> 00:07:10,990
repository rebury pro updates at in zyk

00:07:06,890 --> 00:07:10,990
its index of repository packages

00:07:12,650 --> 00:07:16,910
is updated because the new package is

00:07:14,630 --> 00:07:19,460
now available but these are general

00:07:16,910 --> 00:07:21,620
workflows that theoretically work in

00:07:19,460 --> 00:07:23,690
theory obviously but in the real world

00:07:21,620 --> 00:07:25,400
there's some a couple of obnoxious

00:07:23,690 --> 00:07:28,400
details to take a look at and I've

00:07:25,400 --> 00:07:30,230
picked out three of them one there's a

00:07:28,400 --> 00:07:31,520
management problem with understanding

00:07:30,230 --> 00:07:33,800
where packages come from and what your

00:07:31,520 --> 00:07:35,510
based off of and in cumulus we have

00:07:33,800 --> 00:07:36,820
three different types of packages sort

00:07:35,510 --> 00:07:38,960
of defined by where they're sourced

00:07:36,820 --> 00:07:40,400
first there's unmodified Debbie and

00:07:38,960 --> 00:07:42,740
upstream packages where we pull them

00:07:40,400 --> 00:07:44,990
from our upstream repo and just put them

00:07:42,740 --> 00:07:47,120
into our local repository mirror because

00:07:44,990 --> 00:07:48,500
we don't modify them at all and I just

00:07:47,120 --> 00:07:49,910
like to take a minute here to say a big

00:07:48,500 --> 00:07:51,620
thank you to the Debian security team

00:07:49,910 --> 00:07:53,180
for those security patches because every

00:07:51,620 --> 00:07:54,320
time one comes down and I don't have to

00:07:53,180 --> 00:07:55,040
deal with it apart from putting it in my

00:07:54,320 --> 00:07:58,730
repository

00:07:55,040 --> 00:08:01,460
I am super happy then there's patched

00:07:58,730 --> 00:08:03,500
packages so we take upstream source put

00:08:01,460 --> 00:08:05,780
cumulus patches on it build it and then

00:08:03,500 --> 00:08:07,100
upload it to our local mirror the kernel

00:08:05,780 --> 00:08:08,660
and free range routing as I've mentioned

00:08:07,100 --> 00:08:10,610
previously or two examples of that and

00:08:08,660 --> 00:08:12,710
then there's cumulus own packages where

00:08:10,610 --> 00:08:14,420
we are effective with the upstream where

00:08:12,710 --> 00:08:16,190
we just build and upload and examples of

00:08:14,420 --> 00:08:17,660
that would be the proprietary ASIC code

00:08:16,190 --> 00:08:21,410
from vendors that we have to manage and

00:08:17,660 --> 00:08:23,720
interface code the second thing to

00:08:21,410 --> 00:08:26,540
consider is software release tracks at

00:08:23,720 --> 00:08:28,130
cumulus we've got two software tracks

00:08:26,540 --> 00:08:30,350
one is dev which is the initial

00:08:28,130 --> 00:08:32,660
developer commit should work code their

00:08:30,350 --> 00:08:34,370
needs test and released where the code

00:08:32,660 --> 00:08:35,480
has been tested from death in dev and

00:08:34,370 --> 00:08:38,720
it's promoted by the package maintainer

00:08:35,480 --> 00:08:40,220
and it's good to ship so because we have

00:08:38,720 --> 00:08:42,080
to release tracks we need to double

00:08:40,220 --> 00:08:44,270
everything else so we need Devon release

00:08:42,080 --> 00:08:46,760
versions of obviously git has to you

00:08:44,270 --> 00:08:48,650
promote from dev to release we need to

00:08:46,760 --> 00:08:50,370
package report repositories one to hold

00:08:48,650 --> 00:08:52,470
code for the development code and

00:08:50,370 --> 00:08:53,670
code for the release and then we need

00:08:52,470 --> 00:08:55,050
build Schrute environments that will

00:08:53,670 --> 00:08:56,460
reference either one of them depending

00:08:55,050 --> 00:08:59,730
on what we're building so it's an

00:08:56,460 --> 00:09:01,830
additional complication the third thing

00:08:59,730 --> 00:09:03,450
was reasonable version numbering so one

00:09:01,830 --> 00:09:04,710
of the things I had to struggle with

00:09:03,450 --> 00:09:06,839
coming in was thinking well if we're

00:09:04,710 --> 00:09:08,400
building our packages to three times a

00:09:06,839 --> 00:09:10,520
day aren't we going to have ridiculous

00:09:08,400 --> 00:09:12,690
version numbers by the time we release

00:09:10,520 --> 00:09:14,339
unfortunately a Debian version of

00:09:12,690 --> 00:09:15,600
versioning is thought of this that if

00:09:14,339 --> 00:09:17,580
you have a Tildy in the version number

00:09:15,600 --> 00:09:18,900
it creates a pre-release package where

00:09:17,580 --> 00:09:21,180
it's version is lower than the package

00:09:18,900 --> 00:09:23,339
without the tilde so for example

00:09:21,180 --> 00:09:26,430
packaged food 1.2 is a higher version

00:09:23,339 --> 00:09:28,320
number than food 1.2 till d7 and food

00:09:26,430 --> 00:09:30,900
1.2 till the 8th is a higher version

00:09:28,320 --> 00:09:32,460
than food 1.2 till d7 when we want to

00:09:30,900 --> 00:09:34,860
release we build without the tilde in

00:09:32,460 --> 00:09:37,589
the name in the version string and it

00:09:34,860 --> 00:09:39,990
won't stall over the dev builds so this

00:09:37,589 --> 00:09:41,279
has a couple of advantages but since

00:09:39,990 --> 00:09:43,890
we're doing you know messing around with

00:09:41,279 --> 00:09:45,180
versions anyway if we put a timestamp in

00:09:43,890 --> 00:09:46,620
there then that guarantee does new

00:09:45,180 --> 00:09:48,690
builds have higher priority than old

00:09:46,620 --> 00:09:50,310
ones and we have an idea when the

00:09:48,690 --> 00:09:51,690
package was built and while we're

00:09:50,310 --> 00:09:54,210
messing around there anyway we can put a

00:09:51,690 --> 00:09:55,740
get hash in so QA people can immediately

00:09:54,210 --> 00:09:57,120
correlate with a developer to say hey

00:09:55,740 --> 00:09:58,970
this version of code looks like it's

00:09:57,120 --> 00:10:01,260
causing the problem take a look at it

00:09:58,970 --> 00:10:02,970
and so what this looks like in practice

00:10:01,260 --> 00:10:04,890
this is a dev build with a free range

00:10:02,970 --> 00:10:06,990
routing package and just to break this

00:10:04,890 --> 00:10:08,580
down really quickly the the fr r4o

00:10:06,990 --> 00:10:12,029
that's the upstream version that's based

00:10:08,580 --> 00:10:13,170
off of the plus CL 3 u 1 is the cumulus

00:10:12,029 --> 00:10:15,150
patch version that's been applied to

00:10:13,170 --> 00:10:17,010
that then after the till D we have the

00:10:15,150 --> 00:10:19,709
timestamp starting with 15 and the get

00:10:17,010 --> 00:10:23,070
hash starting with a dot 9f and then amp

00:10:19,709 --> 00:10:24,839
t54 dev means it's a AMD 64 binary when

00:10:23,070 --> 00:10:28,430
you release all that stuff with a

00:10:24,839 --> 00:10:28,430
timestamp and get hash and tilde is gone

00:10:28,670 --> 00:10:34,350
so lessons learned or I didn't see that

00:10:31,320 --> 00:10:35,820
coming so for things that turned out to

00:10:34,350 --> 00:10:40,110
be more complicated than I initially

00:10:35,820 --> 00:10:42,600
expected the first thing was the master

00:10:40,110 --> 00:10:44,040
build tool so getting back to this there

00:10:42,600 --> 00:10:45,570
were a surprising number of build quirks

00:10:44,040 --> 00:10:47,010
that I hadn't expected I thought I could

00:10:45,570 --> 00:10:49,200
just have Jenkins were an ass build and

00:10:47,010 --> 00:10:51,690
that would be it but there are things

00:10:49,200 --> 00:10:53,220
like the kernel where it has to run make

00:10:51,690 --> 00:10:55,170
to be able to generate its Debian

00:10:53,220 --> 00:10:57,450
control file so that s build has

00:10:55,170 --> 00:10:59,130
something to work off of there's things

00:10:57,450 --> 00:11:00,570
like putting the pre-release package

00:10:59,130 --> 00:11:01,410
version in with the timestamp and get

00:11:00,570 --> 00:11:02,700
hash

00:11:01,410 --> 00:11:05,250
the release track that you're trying to

00:11:02,700 --> 00:11:07,080
build for what get branch do you want to

00:11:05,250 --> 00:11:08,490
use being able to set that to head or

00:11:07,080 --> 00:11:09,600
roll it back one version if there's

00:11:08,490 --> 00:11:12,480
something in there that's breaking the

00:11:09,600 --> 00:11:14,250
build for the time being is really handy

00:11:12,480 --> 00:11:16,490
determining what repository you're

00:11:14,250 --> 00:11:18,810
uploading to is it dev is it release

00:11:16,490 --> 00:11:20,940
updating the Installer manifest which

00:11:18,810 --> 00:11:22,560
has to happen after the build and then

00:11:20,940 --> 00:11:24,390
it's also a good point for Jenkins

00:11:22,560 --> 00:11:26,570
automation so our Jenkins master doesn't

00:11:24,390 --> 00:11:28,710
have to be an expert on package building

00:11:26,570 --> 00:11:30,990
and I don't have to know a whole lot

00:11:28,710 --> 00:11:32,220
about Jenkins and it also provides the

00:11:30,990 --> 00:11:33,630
option for me to debug a build without

00:11:32,220 --> 00:11:34,890
using Jenkins which makes a little more

00:11:33,630 --> 00:11:38,970
portable if you happen to be building on

00:11:34,890 --> 00:11:41,790
a laptop then there was a surprising

00:11:38,970 --> 00:11:43,500
amount of social engineering involved in

00:11:41,790 --> 00:11:46,230
rolling out build tools and getting

00:11:43,500 --> 00:11:47,760
people to use them so things to keep in

00:11:46,230 --> 00:11:49,590
mind about some developers and I

00:11:47,760 --> 00:11:50,850
certainly fall into this category so I'm

00:11:49,590 --> 00:11:54,060
kind of comfortable propagating the

00:11:50,850 --> 00:11:55,770
stereotype but they want to build fast

00:11:54,060 --> 00:11:57,060
which builds clean nobody's rebuilding

00:11:55,770 --> 00:11:58,650
from scratch every time you want to

00:11:57,060 --> 00:12:00,240
iterate as fast as possible and get

00:11:58,650 --> 00:12:02,070
reasonable results every time because

00:12:00,240 --> 00:12:05,550
you're there to write code and run code

00:12:02,070 --> 00:12:07,020
and build time is down time and with

00:12:05,550 --> 00:12:08,670
this mindset the build tools can

00:12:07,020 --> 00:12:11,670
sometimes be seen as restraints rather

00:12:08,670 --> 00:12:13,620
than supports the corollary to that is

00:12:11,670 --> 00:12:17,160
any build system that sucks will be

00:12:13,620 --> 00:12:18,210
worked around and this will cause data

00:12:17,160 --> 00:12:20,550
out of quote Thomas the Tank Engine

00:12:18,210 --> 00:12:21,630
confusion and delay as things are

00:12:20,550 --> 00:12:24,480
slightly different for reasons that

00:12:21,630 --> 00:12:25,830
aren't immediately obvious and I think

00:12:24,480 --> 00:12:27,690
there's maybe a bit more of this mindset

00:12:25,830 --> 00:12:29,700
with a derivative where the end product

00:12:27,690 --> 00:12:31,410
focus isn't Debian you know not all

00:12:29,700 --> 00:12:33,120
developers want to have to understand

00:12:31,410 --> 00:12:34,620
things like packaging because they're

00:12:33,120 --> 00:12:35,640
here for the other stuff that's why they

00:12:34,620 --> 00:12:40,140
were hired that's what they're working

00:12:35,640 --> 00:12:41,730
on it's not their area of expertise so

00:12:40,140 --> 00:12:45,390
sort of given this you know how do we

00:12:41,730 --> 00:12:47,070
work with it first thing I found is the

00:12:45,390 --> 00:12:48,810
developers our customers you know you

00:12:47,070 --> 00:12:50,550
incorporate their feedback wherever you

00:12:48,810 --> 00:12:51,810
can don't give them a reason to work

00:12:50,550 --> 00:12:52,800
around the build system if there are

00:12:51,810 --> 00:12:56,630
features that will make their lives

00:12:52,800 --> 00:12:59,070
easier and you can't implement them do

00:12:56,630 --> 00:13:01,320
when you can have the developer in the

00:12:59,070 --> 00:13:03,180
build environments match when developers

00:13:01,320 --> 00:13:05,550
start debugging something they can use a

00:13:03,180 --> 00:13:07,530
copy of the built routes that the build

00:13:05,550 --> 00:13:09,840
system uses so their carts starting from

00:13:07,530 --> 00:13:11,310
a common base of common build

00:13:09,840 --> 00:13:13,860
environment and that helps keep the

00:13:11,310 --> 00:13:15,030
build from breaking I think maybe once

00:13:13,860 --> 00:13:16,260
every three four months somebody

00:13:15,030 --> 00:13:18,000
checks in something that breaks a build

00:13:16,260 --> 00:13:21,030
that built in their environment that

00:13:18,000 --> 00:13:23,880
didn't on the build tools so that's been

00:13:21,030 --> 00:13:25,710
really helpful and I found it was really

00:13:23,880 --> 00:13:28,470
useful to simplify common build tasks

00:13:25,710 --> 00:13:30,330
with a wrapper script I found it helped

00:13:28,470 --> 00:13:32,640
enforce consistency as default values

00:13:30,330 --> 00:13:33,960
were automatically applied it reduced

00:13:32,640 --> 00:13:35,280
steps because there'd be a series of

00:13:33,960 --> 00:13:36,630
defaults that would have to be set and

00:13:35,280 --> 00:13:38,550
by wrapping it it would just apply these

00:13:36,630 --> 00:13:40,890
things so that cut down on the

00:13:38,550 --> 00:13:42,270
opportunities for mistakes for me it

00:13:40,890 --> 00:13:43,650
just made support easier because I had

00:13:42,270 --> 00:13:46,140
less to tell them on the other end as to

00:13:43,650 --> 00:13:48,090
what to do and by wrapping it also gave

00:13:46,140 --> 00:13:49,920
me the opportunity to upgrade tools and

00:13:48,090 --> 00:13:51,510
without changing the developer workflows

00:13:49,920 --> 00:13:52,980
if the default routes somebody is

00:13:51,510 --> 00:13:54,150
supposed to be using has been upgraded I

00:13:52,980 --> 00:13:56,580
changed the version number that I'm

00:13:54,150 --> 00:13:58,620
using with it and nobody knows and stuff

00:13:56,580 --> 00:13:59,640
still works or it doesn't and I can

00:13:58,620 --> 00:14:01,230
immediately roll it back without

00:13:59,640 --> 00:14:05,520
disrupting people you know provided

00:14:01,230 --> 00:14:08,040
nobody caught me and one of the things

00:14:05,520 --> 00:14:10,260
that comes up unusually frequently when

00:14:08,040 --> 00:14:12,330
somebody means mentions the repo you

00:14:10,260 --> 00:14:13,470
need to get clarification on that are

00:14:12,330 --> 00:14:17,130
they talking about the debian package

00:14:13,470 --> 00:14:19,080
repo is it get repo Python repo did they

00:14:17,130 --> 00:14:20,550
really mean docker registry is my car

00:14:19,080 --> 00:14:22,800
being repossessed do I need a ride home

00:14:20,550 --> 00:14:25,650
I mean any of this stuff

00:14:22,800 --> 00:14:27,600
it comes up shockingly frequently and

00:14:25,650 --> 00:14:29,760
because of the semantic overlap with you

00:14:27,600 --> 00:14:31,440
know source code repository and Debian

00:14:29,760 --> 00:14:32,820
package repository you can be talking

00:14:31,440 --> 00:14:34,200
that cross-purposes for about two

00:14:32,820 --> 00:14:38,450
minutes before somebody goes wait a

00:14:34,200 --> 00:14:38,450
minute you meant the other thing okay

00:14:38,810 --> 00:14:42,770
they're supporting multiple

00:14:40,440 --> 00:14:45,510
architectures got a little bit tricky

00:14:42,770 --> 00:14:47,190
cumulant except orts amd64 and our milk

00:14:45,510 --> 00:14:49,080
based switches and it's been

00:14:47,190 --> 00:14:50,400
surprisingly difficult to find our ml

00:14:49,080 --> 00:14:51,630
build systems I would have thought I

00:14:50,400 --> 00:14:53,100
could have just found an r ml based

00:14:51,630 --> 00:14:57,330
server somewhere and built off of that

00:14:53,100 --> 00:14:58,800
and that just hasn't been the case so we

00:14:57,330 --> 00:15:00,630
tried a number of workarounds which I'll

00:14:58,800 --> 00:15:02,310
skip over here for time but we ended up

00:15:00,630 --> 00:15:03,870
one of our engineers figured out had run

00:15:02,310 --> 00:15:05,610
Jessie on a Chromebook and we built off

00:15:03,870 --> 00:15:07,710
of that which I believe makes us an

00:15:05,610 --> 00:15:09,950
official Silicon Valley startup because

00:15:07,710 --> 00:15:13,080
we built on hardware we bought it fries

00:15:09,950 --> 00:15:15,830
we did eventually find arm-based servers

00:15:13,080 --> 00:15:18,090
but this was three years after the fact

00:15:15,830 --> 00:15:21,150
another interesting thing with type all

00:15:18,090 --> 00:15:24,480
packages that because they run on

00:15:21,150 --> 00:15:26,280
anything they're not architecture

00:15:24,480 --> 00:15:28,990
architecture specific if you think of

00:15:26,280 --> 00:15:31,010
things like bash scripts or Python

00:15:28,990 --> 00:15:32,180
they can be as basically being run

00:15:31,010 --> 00:15:34,010
anywhere and when you're building for

00:15:32,180 --> 00:15:35,990
multiple architectures you don't want to

00:15:34,010 --> 00:15:37,399
build type all packages for multiple

00:15:35,990 --> 00:15:38,990
architectures you want to pick one

00:15:37,399 --> 00:15:41,930
architecture and go with it

00:15:38,990 --> 00:15:43,430
and the problem is that if a packaged

00:15:41,930 --> 00:15:47,630
build an architecture architecture

00:15:43,430 --> 00:15:50,480
specific type and a type all the binary

00:15:47,630 --> 00:15:52,850
from amd64 and the all from amd64 will

00:15:50,480 --> 00:15:55,760
upload and then the binary from rml and

00:15:52,850 --> 00:15:57,500
the type all from upload will type all

00:15:55,760 --> 00:16:00,529
from the rml will upload and displace

00:15:57,500 --> 00:16:02,149
the amd64 one which leads to check some

00:16:00,529 --> 00:16:04,520
errors when you try to download amd64

00:16:02,149 --> 00:16:06,320
because there's a mismatch in the

00:16:04,520 --> 00:16:09,680
repository it's the same package same

00:16:06,320 --> 00:16:11,540
version different checksum so we just

00:16:09,680 --> 00:16:14,089
let amd64 do the builds because it's a

00:16:11,540 --> 00:16:16,399
faster architecture and prohibit rml

00:16:14,089 --> 00:16:19,190
from building type all and that seems to

00:16:16,399 --> 00:16:20,510
work pretty well and lastly I wanted to

00:16:19,190 --> 00:16:21,890
cover building things that depend on

00:16:20,510 --> 00:16:24,649
other things that you build this was a

00:16:21,890 --> 00:16:28,310
question that had come up I think in

00:16:24,649 --> 00:16:30,200
Montreal somebody had asked it off

00:16:28,310 --> 00:16:31,850
so in cumulus Linux there's a lot of

00:16:30,200 --> 00:16:34,160
packages to turn depend on the kernel

00:16:31,850 --> 00:16:36,440
the build chain is kernel headers and

00:16:34,160 --> 00:16:38,150
the ASIC SDKs depend on those the stuff

00:16:36,440 --> 00:16:41,000
the SDK builds depend on the eight of

00:16:38,150 --> 00:16:44,120
the SDKs cumulus code has to sync up

00:16:41,000 --> 00:16:45,260
with the stuff that the SDK built so

00:16:44,120 --> 00:16:46,850
kernel changes have to propagate

00:16:45,260 --> 00:16:48,850
downward and build all of this stuff at

00:16:46,850 --> 00:16:51,260
once and I'm sure there's a good

00:16:48,850 --> 00:16:52,640
algorithm someplace for doing this but

00:16:51,260 --> 00:16:54,680
the number of packages affected by this

00:16:52,640 --> 00:16:56,959
was small enough that I just mapped it

00:16:54,680 --> 00:16:58,430
in the master build tool to say hey if

00:16:56,959 --> 00:17:01,640
anything in this chain builds build

00:16:58,430 --> 00:17:02,839
everything below it and there's also a

00:17:01,640 --> 00:17:04,250
question though of when you're doing

00:17:02,839 --> 00:17:05,809
this the mechanics of getting the

00:17:04,250 --> 00:17:07,610
dependencies to the next package in the

00:17:05,809 --> 00:17:09,350
chain so initially I thought well this

00:17:07,610 --> 00:17:11,990
is great the kernel will build it will

00:17:09,350 --> 00:17:13,189
upload its its build products the ASIC

00:17:11,990 --> 00:17:14,660
code needs to build it downloads the

00:17:13,189 --> 00:17:16,040
kernel stuff then it puts this stuff up

00:17:14,660 --> 00:17:18,170
and it keeps going back and forth until

00:17:16,040 --> 00:17:19,939
finally everything is built which does

00:17:18,170 --> 00:17:21,589
work the problem is this takes a while

00:17:19,939 --> 00:17:23,209
and it leaves the repository in

00:17:21,589 --> 00:17:25,760
inconsistent state where you're getting

00:17:23,209 --> 00:17:27,170
future code in present code and when

00:17:25,760 --> 00:17:29,650
somebody downloads them they don't work

00:17:27,170 --> 00:17:33,620
and so the solution for this which is

00:17:29,650 --> 00:17:34,910
not a incredibly general solution but

00:17:33,620 --> 00:17:36,320
something specific that took us a while

00:17:34,910 --> 00:17:38,570
to find and I just want to share it with

00:17:36,320 --> 00:17:39,919
everybody if you're using s build

00:17:38,570 --> 00:17:41,960
there's the additional packages flag

00:17:39,919 --> 00:17:43,100
that will take locally built Deb's

00:17:41,960 --> 00:17:46,909
bring them into your build environment

00:17:43,100 --> 00:17:48,559
so in building the building the locally

00:17:46,909 --> 00:17:50,270
built Deb's are kept around and then

00:17:48,559 --> 00:17:51,350
they're added to the next build and so

00:17:50,270 --> 00:17:52,940
on and so forth and at the end

00:17:51,350 --> 00:17:58,100
everything's built and then we push that

00:17:52,940 --> 00:17:59,570
all over the repository at once so in

00:17:58,100 --> 00:18:01,760
conclusion this should be enough to get

00:17:59,570 --> 00:18:02,929
somebody started on a derivative I'd

00:18:01,760 --> 00:18:04,190
certainly roadmap I would have liked to

00:18:02,929 --> 00:18:06,559
have had three years ago when I was

00:18:04,190 --> 00:18:08,450
doing the build system hopefully it's

00:18:06,559 --> 00:18:10,730
provided some insight into derivative

00:18:08,450 --> 00:18:13,130
requirements ways to use existing build

00:18:10,730 --> 00:18:14,659
tools deployment issues one's likely to

00:18:13,130 --> 00:18:17,390
encounter and how to create a build

00:18:14,659 --> 00:18:18,950
system that keeps everybody happy are

00:18:17,390 --> 00:18:21,260
there questions I think we got two or

00:18:18,950 --> 00:18:27,730
three minutes left

00:18:21,260 --> 00:18:27,730
[Applause]

00:18:29,679 --> 00:18:36,200
hi my name is Rikuo I peer and I've also

00:18:32,899 --> 00:18:38,510
worked on derivate builds and very much

00:18:36,200 --> 00:18:41,270
similar stuff that has come in front of

00:18:38,510 --> 00:18:44,169
my job we also started with Jenkinson

00:18:41,270 --> 00:18:46,549
building our own stuff up around it and

00:18:44,169 --> 00:18:49,100
eventually we ended up replacing all of

00:18:46,549 --> 00:18:53,179
that with open build service okay that

00:18:49,100 --> 00:18:57,919
is - created by openSUSE but it can also

00:18:53,179 --> 00:19:00,409
build DEP packages cool so one of the it

00:18:57,919 --> 00:19:02,840
has its own idiosyncrasies but it can

00:19:00,409 --> 00:19:05,720
handle all these things like having all

00:19:02,840 --> 00:19:07,549
and amd64 and harm sixty-four packages

00:19:05,720 --> 00:19:11,630
coming out from the same package and not

00:19:07,549 --> 00:19:12,740
over write each other's excellent if

00:19:11,630 --> 00:19:14,090
you're free I'd like to touch base with

00:19:12,740 --> 00:19:14,809
anybody that's dealt with any of this or

00:19:14,090 --> 00:19:17,049
any of these issues

00:19:14,809 --> 00:19:19,130
I'll be at the conference all week but

00:19:17,049 --> 00:19:20,360
being able to share similar points of

00:19:19,130 --> 00:19:22,070
view and run in two different ways we've

00:19:20,360 --> 00:19:24,500
solved problems is one of the things I

00:19:22,070 --> 00:19:26,350
love about these conferences so if

00:19:24,500 --> 00:19:29,830
anybody wants to look me up please do

00:19:26,350 --> 00:19:29,830
any other questions

00:19:31,570 --> 00:19:34,520
all right I think we're good thank you

00:19:33,950 --> 00:19:40,950
very much

00:19:34,520 --> 00:19:40,950

YouTube URL: https://www.youtube.com/watch?v=OPsfX5_YCiQ


