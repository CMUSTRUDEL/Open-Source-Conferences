Title: Software transparency: package security beyond signatures and reproducible builds
Publication date: 2018-07-31
Playlist: DebConf 18
Description: 
	by Benjamin Hof

At: DebConf18
https://debconf18.debconf.org/talks/104-software-transparency-package-security-beyond-signatures-and-reproducible-builds/

Current package distribution security is based on cryptographic
signatures.  We propose to extend the current release file
signature mechanism with an architecture offering protection against
targeted backdoors by a compromised archive.

This project introduces a Merkle tree-based transparency log for package meta data
and source code, similar to certificate transparency.  In our system,
the APT client verifies that it installs the same binary package as
everybody else.  Utilising reproducible builds, we further ensure
that the source code and buildinfo corresponding to that binary can
be retrieved.

We explain parts of our prototype and show the results of replaying two years of Debian updates.

Room: Yushan (玉山)
Scheduled start: 2018-07-29 11:00:00
Captions: 
	00:00:04,680 --> 00:00:09,990
welcome to my talk a softer transparency

00:00:07,840 --> 00:00:14,800
package security beyond signatures and

00:00:09,990 --> 00:00:17,439
reproducible builds in this presentation

00:00:14,800 --> 00:00:20,380
I would like we are going to talk about

00:00:17,439 --> 00:00:22,750
the security of software distribution so

00:00:20,380 --> 00:00:25,270
how can we make sure that the software

00:00:22,750 --> 00:00:28,029
that lands on the machines of the users

00:00:25,270 --> 00:00:33,280
is actually the software they intend to

00:00:28,029 --> 00:00:36,430
run and mmm for this we propose to add a

00:00:33,280 --> 00:00:40,000
new security feature on top of the

00:00:36,430 --> 00:00:43,300
existing systems like a secure apt and

00:00:40,000 --> 00:00:47,800
the reproducible builds will also play a

00:00:43,300 --> 00:00:50,350
big role in this of course it doesn't

00:00:47,800 --> 00:00:52,600
the introduction of new features doesn't

00:00:50,350 --> 00:00:54,790
work without changing a little bit of

00:00:52,600 --> 00:00:57,220
the existing infrastructure so we are

00:00:54,790 --> 00:01:00,100
also going to take a look at how we can

00:00:57,220 --> 00:01:04,449
approach that and then I'm of course

00:01:00,100 --> 00:01:08,290
very interested in feedback your ideas

00:01:04,449 --> 00:01:13,659
what do you think might be a bit of a

00:01:08,290 --> 00:01:17,320
hurdle things like that so let's start

00:01:13,659 --> 00:01:20,290
off with some examples where there were

00:01:17,320 --> 00:01:23,110
problems in soft and the security of

00:01:20,290 --> 00:01:27,880
software distribution in the area of

00:01:23,110 --> 00:01:29,740
free software there were problems with a

00:01:27,880 --> 00:01:33,220
Chrome extensions where developers were

00:01:29,740 --> 00:01:36,159
fished their credentials basically got

00:01:33,220 --> 00:01:40,290
lost and malicious extensions were

00:01:36,159 --> 00:01:45,490
uploaded malicious images on docker hub

00:01:40,290 --> 00:01:48,640
were compromised NPM packages began to

00:01:45,490 --> 00:01:51,460
get up quite recently and also quite

00:01:48,640 --> 00:01:54,490
recently the problem with the arch user

00:01:51,460 --> 00:01:59,200
repository where a malicious packages

00:01:54,490 --> 00:02:02,040
were uploaded the mature social and

00:01:59,200 --> 00:02:05,590
organizational structures in Debian

00:02:02,040 --> 00:02:07,510
quite a strength in this regard but

00:02:05,590 --> 00:02:10,900
nevertheless we

00:02:07,510 --> 00:02:16,660
should prepare for things going wrong I

00:02:10,900 --> 00:02:19,480
think let's take a look at the way the

00:02:16,660 --> 00:02:22,930
existing software distribution works in

00:02:19,480 --> 00:02:26,320
Debian we have a person who uploads a

00:02:22,930 --> 00:02:29,560
package the all the packages together

00:02:26,320 --> 00:02:32,020
then distributed by the archive they are

00:02:29,560 --> 00:02:35,350
signed by the archive with signing keys

00:02:32,020 --> 00:02:37,200
and then they are shipped off to the

00:02:35,350 --> 00:02:41,080
mirror network our content distribution

00:02:37,200 --> 00:02:43,960
network where all the packages and

00:02:41,080 --> 00:02:47,280
metadata meaning dependencies which

00:02:43,960 --> 00:02:50,410
versions are available and so on

00:02:47,280 --> 00:02:54,420
when distributed to the clients which

00:02:50,410 --> 00:02:57,610
can download them over HTTP or HTTPS

00:02:54,420 --> 00:03:01,360
this architecture is quite nice because

00:02:57,610 --> 00:03:05,650
it allows the part of the architecture

00:03:01,360 --> 00:03:07,240
that has to scale well in particular the

00:03:05,650 --> 00:03:10,150
content distribution network to be

00:03:07,240 --> 00:03:14,400
untrusted so it doesn't mean it doesn't

00:03:10,150 --> 00:03:19,890
matter who runs a packaged mirror for us

00:03:14,400 --> 00:03:23,190
they can't inject packages for the

00:03:19,890 --> 00:03:26,140
visible in a visible way for the users

00:03:23,190 --> 00:03:29,459
that's achieved by the archived

00:03:26,140 --> 00:03:33,280
signatures it does however have

00:03:29,459 --> 00:03:36,010
drawbacks the archive signing key on the

00:03:33,280 --> 00:03:38,380
other hand is all powerful so if

00:03:36,010 --> 00:03:42,160
anything should happen through this

00:03:38,380 --> 00:03:47,670
signing key that would be a big trouble

00:03:42,160 --> 00:03:52,870
and of course we also trust uploaders

00:03:47,670 --> 00:03:58,209
that they only upload the appropriate

00:03:52,870 --> 00:04:02,020
software so how can we improve the

00:03:58,209 --> 00:04:05,560
situation well we are going to approach

00:04:02,020 --> 00:04:09,120
this with two goals in mind the first is

00:04:05,560 --> 00:04:13,360
to reduce the or relax the trust in the

00:04:09,120 --> 00:04:17,200
archive what we would like to achieve is

00:04:13,360 --> 00:04:19,700
that it's impossible even if the archive

00:04:17,200 --> 00:04:22,040
is compromised to deliver

00:04:19,700 --> 00:04:25,400
to deliver malicious packages to

00:04:22,040 --> 00:04:27,560
specific users we we can't avoid

00:04:25,400 --> 00:04:30,260
malicious packages being delivered to

00:04:27,560 --> 00:04:33,080
all the users but we can avoid it

00:04:30,260 --> 00:04:36,710
and want to avoid malicious packages

00:04:33,080 --> 00:04:40,760
being delivered to specific users and

00:04:36,710 --> 00:04:44,960
the second goal is that we improve the

00:04:40,760 --> 00:04:49,060
audit ability we have a that we have a

00:04:44,960 --> 00:04:52,750
secondary audit structure in place where

00:04:49,060 --> 00:04:55,280
lots of important properties can be

00:04:52,750 --> 00:04:58,690
independently verified independently of

00:04:55,280 --> 00:05:02,060
the existing infrastructure for example

00:04:58,690 --> 00:05:05,240
we would like to make sure that there is

00:05:02,060 --> 00:05:08,000
inspectable source code for every binary

00:05:05,240 --> 00:05:11,900
that we have a verified mapping between

00:05:08,000 --> 00:05:14,500
the source and the binary that we can

00:05:11,900 --> 00:05:17,120
reliably identify the maintainer

00:05:14,500 --> 00:05:20,570
responsible for the distribution of this

00:05:17,120 --> 00:05:21,230
package and we in case something goes

00:05:20,570 --> 00:05:23,300
wrong

00:05:21,230 --> 00:05:25,930
we would also like to have a strong

00:05:23,300 --> 00:05:32,870
indication of where the problem

00:05:25,930 --> 00:05:35,810
originated from and this work this

00:05:32,870 --> 00:05:39,140
proposal works on these specific goals

00:05:35,810 --> 00:05:42,560
so the approach we are going to take in

00:05:39,140 --> 00:05:45,620
order to achieve this is that we want to

00:05:42,560 --> 00:05:48,860
make sure that everybody runs the same

00:05:45,620 --> 00:05:51,200
the exact same software this is the main

00:05:48,860 --> 00:05:53,960
idea we are going to follow and we can

00:05:51,200 --> 00:05:57,710
immediately see if we can achieve this

00:05:53,960 --> 00:06:00,170
when we can't have targeted back those

00:05:57,710 --> 00:06:02,930
malicious packages only deal being

00:06:00,170 --> 00:06:05,450
delivered to specific users anymore

00:06:02,930 --> 00:06:07,970
right and this is a huge advantage

00:06:05,450 --> 00:06:11,090
because then any malicious package has

00:06:07,970 --> 00:06:13,790
to be delivered to everybody which also

00:06:11,090 --> 00:06:16,250
greatly increases the risk of detection

00:06:13,790 --> 00:06:18,700
and therefore makes the attack more

00:06:16,250 --> 00:06:22,010
unattractive to the attacker

00:06:18,700 --> 00:06:24,890
so if we have the situation that

00:06:22,010 --> 00:06:27,320
everybody runs the exact same software I

00:06:24,890 --> 00:06:30,080
can go ahead and order it or analyze a

00:06:27,320 --> 00:06:31,190
particular package and the result of

00:06:30,080 --> 00:06:33,110
this analysis

00:06:31,190 --> 00:06:35,750
is immediately applicable to all

00:06:33,110 --> 00:06:37,940
installations of this package because we

00:06:35,750 --> 00:06:40,430
can be sure that we actually run the

00:06:37,940 --> 00:06:44,180
exact same software there are no

00:06:40,430 --> 00:06:48,290
targeted pectus possible anymore and we

00:06:44,180 --> 00:06:53,000
can also pinpoint where things go wrong

00:06:48,290 --> 00:06:56,450
if they do so now let's take a look at

00:06:53,000 --> 00:06:59,540
the design we propose to achieve that

00:06:56,450 --> 00:07:01,430
the main idea is that we add an

00:06:59,540 --> 00:07:05,780
additional component called

00:07:01,430 --> 00:07:07,520
a lock server that serves to make sure

00:07:05,780 --> 00:07:10,220
that everybody runs the same software

00:07:07,520 --> 00:07:13,310
and will also facilitate the auditing

00:07:10,220 --> 00:07:16,010
goals and it's important that we don't

00:07:13,310 --> 00:07:18,980
add an additional component as another

00:07:16,010 --> 00:07:26,420
trusted third party but we really really

00:07:18,980 --> 00:07:28,910
want anything we add to be to be in such

00:07:26,420 --> 00:07:32,180
a way that we don't have to trust it but

00:07:28,910 --> 00:07:34,880
rather we can verify from the outside so

00:07:32,180 --> 00:07:37,220
for example all the clients can verify a

00:07:34,880 --> 00:07:40,760
certain properties of the behavior of

00:07:37,220 --> 00:07:42,770
this lock server and we are going to

00:07:40,760 --> 00:07:45,500
keep all the existing infrastructure in

00:07:42,770 --> 00:07:47,690
place as the archive with the mirror

00:07:45,500 --> 00:07:52,300
network delivering software packages to

00:07:47,690 --> 00:07:55,900
the apt clients and now the archive also

00:07:52,300 --> 00:07:59,060
publishes its metadata meaning

00:07:55,900 --> 00:08:03,350
dependencies version numbers and so on

00:07:59,060 --> 00:08:06,500
and the source packages to the lock

00:08:03,350 --> 00:08:10,790
server where and the lock server will

00:08:06,500 --> 00:08:13,669
also have to be contacted by the clients

00:08:10,790 --> 00:08:16,460
we are going to look at it in a bit more

00:08:13,669 --> 00:08:19,280
detail later for now let's take a look

00:08:16,460 --> 00:08:24,320
at how the lock server has to look and

00:08:19,280 --> 00:08:29,210
in order to facilitate the goals that we

00:08:24,320 --> 00:08:33,200
want to achieve the lock server operates

00:08:29,210 --> 00:08:37,159
a data structure called a hash tree over

00:08:33,200 --> 00:08:39,019
a list of elements and I'm just going to

00:08:37,159 --> 00:08:42,630
show

00:08:39,019 --> 00:08:44,670
the basic data structure in one example

00:08:42,630 --> 00:08:46,709
of what we can do with this data

00:08:44,670 --> 00:08:49,889
structure we're not going to through all

00:08:46,709 --> 00:08:52,829
the properties so let's start off the

00:08:49,889 --> 00:08:56,240
with the list of elements which are the

00:08:52,829 --> 00:08:59,010
squares at the bottom of the graph and

00:08:56,240 --> 00:09:01,500
these list elements are things like

00:08:59,010 --> 00:09:05,010
sauce packages and the package metadata

00:09:01,500 --> 00:09:07,829
so the packages that G's at file the in

00:09:05,010 --> 00:09:10,949
release file these kinds of things

00:09:07,829 --> 00:09:14,100
containing the dependencies and edge

00:09:10,949 --> 00:09:17,490
sums of the packages so each of these

00:09:14,100 --> 00:09:22,350
things is one one little square here and

00:09:17,490 --> 00:09:24,930
over the these lists of squares we are

00:09:22,350 --> 00:09:28,410
going to compute a hash tree where the

00:09:24,930 --> 00:09:32,190
parent of each node so going upwards in

00:09:28,410 --> 00:09:35,160
the graph is the hash of its children

00:09:32,190 --> 00:09:39,180
and if we do this we have an interesting

00:09:35,160 --> 00:09:42,209
a property namely the tree root topmost

00:09:39,180 --> 00:09:45,660
node in the graph reliably identifies

00:09:42,209 --> 00:09:48,060
all the list elements right so we can't

00:09:45,660 --> 00:09:51,920
change anything in the list without the

00:09:48,060 --> 00:09:55,170
top node also changing due to the

00:09:51,920 --> 00:10:01,610
chained hash construction in the hash

00:09:55,170 --> 00:10:05,850
tree so this tree is operated by the

00:10:01,610 --> 00:10:08,250
lock server and we are now going to take

00:10:05,850 --> 00:10:13,980
a quick look at one thing we can achieve

00:10:08,250 --> 00:10:16,319
using this data structure so if we are

00:10:13,980 --> 00:10:19,560
in the situation that we know the tree

00:10:16,319 --> 00:10:22,470
root and we would like to have assurance

00:10:19,560 --> 00:10:24,870
that the square marked with X is

00:10:22,470 --> 00:10:27,029
actually covered by the tree remember

00:10:24,870 --> 00:10:32,519
the tree can be very very large

00:10:27,029 --> 00:10:34,589
and the client might have for example

00:10:32,519 --> 00:10:35,910
this in release file and they want to

00:10:34,589 --> 00:10:40,500
make sure that it is covered by this

00:10:35,910 --> 00:10:43,019
tree root so what we can do now is we

00:10:40,500 --> 00:10:46,319
can ask the lock server hey please send

00:10:43,019 --> 00:10:49,829
me the proof that the third element is

00:10:46,319 --> 00:10:51,769
actually contained within this tree root

00:10:49,829 --> 00:10:54,920
and the lock server would arrest

00:10:51,769 --> 00:10:58,429
with nodes marked in gray here and with

00:10:54,920 --> 00:11:02,119
these gray mark nodes we can recompute

00:10:58,429 --> 00:11:05,389
the tree route and actually convince

00:11:02,119 --> 00:11:09,949
ourselves that the tree route covers

00:11:05,389 --> 00:11:14,389
this element in question the lock

00:11:09,949 --> 00:11:16,759
supports two operations efficiently and

00:11:14,389 --> 00:11:19,850
a cryptographically secure namely

00:11:16,759 --> 00:11:22,129
proving that a given element is included

00:11:19,850 --> 00:11:25,309
in the list covered by the tree route

00:11:22,129 --> 00:11:28,309
and also that the list was always

00:11:25,309 --> 00:11:30,079
operated in append only manner so there

00:11:28,309 --> 00:11:34,160
are no other changes to the list other

00:11:30,079 --> 00:11:37,100
than adding a new elements to it and if

00:11:34,160 --> 00:11:39,410
we only rely on these properties there's

00:11:37,100 --> 00:11:43,220
no need to trust the lock server rather

00:11:39,410 --> 00:11:46,189
we can we can verify all the important

00:11:43,220 --> 00:11:50,089
properties from the outside of the lock

00:11:46,189 --> 00:11:53,749
server and this will be the main method

00:11:50,089 --> 00:11:56,360
we use to achieve our goal of ensuring

00:11:53,749 --> 00:12:00,319
that everybody runs the exact same

00:11:56,360 --> 00:12:04,490
software now let's take a look at the

00:12:00,319 --> 00:12:08,990
whole architecture in a bit more detail

00:12:04,490 --> 00:12:11,179
so you'll recall we have the archive if

00:12:08,990 --> 00:12:13,759
the content distribution network the

00:12:11,179 --> 00:12:17,389
mirror network and our app clients who

00:12:13,759 --> 00:12:20,420
install the software from the CDN we

00:12:17,389 --> 00:12:23,299
have added a lock server operating a

00:12:20,420 --> 00:12:25,730
tree data structure and the archive

00:12:23,299 --> 00:12:29,299
submits the package meta data

00:12:25,730 --> 00:12:32,299
dependencies hashes and so on packaged

00:12:29,299 --> 00:12:34,339
versions into this lock server and it

00:12:32,299 --> 00:12:39,429
also submits the sauce packages into

00:12:34,339 --> 00:12:42,410
this lock server the app client is

00:12:39,429 --> 00:12:44,929
augmented with an auditor a component

00:12:42,410 --> 00:12:48,529
which serves to verify the lock

00:12:44,929 --> 00:12:53,299
operation for example we can verify that

00:12:48,529 --> 00:12:56,029
a new tree root is an append-only

00:12:53,299 --> 00:12:59,149
version of an older tree root and we can

00:12:56,029 --> 00:13:02,779
also query the lock for proof at a

00:12:59,149 --> 00:13:05,570
particular metadata file for example an

00:13:02,779 --> 00:13:08,960
in release file is covered by

00:13:05,570 --> 00:13:12,290
this tree root okay

00:13:08,960 --> 00:13:15,800
hmm there's also an additional component

00:13:12,290 --> 00:13:19,160
that we need called a monitor and of

00:13:15,800 --> 00:13:23,840
these monitors there are a few and a few

00:13:19,160 --> 00:13:26,570
people and some people should be

00:13:23,840 --> 00:13:29,720
interested to run these monitors because

00:13:26,570 --> 00:13:32,740
they fulfill important analysis

00:13:29,720 --> 00:13:35,720
functions for different groups of people

00:13:32,740 --> 00:13:39,170
in general what the money toward us is

00:13:35,720 --> 00:13:42,740
it verifies the operation similar to the

00:13:39,170 --> 00:13:47,900
auditor and but it also does additional

00:13:42,740 --> 00:13:51,950
checks and it may require to keep a copy

00:13:47,900 --> 00:13:54,020
of the of the three data structure or

00:13:51,950 --> 00:13:56,630
the all the elements used to construct

00:13:54,020 --> 00:14:02,150
the tree data structure or at least they

00:13:56,630 --> 00:14:07,250
receive all new or new elements and this

00:14:02,150 --> 00:14:09,950
monitor makes a certain of many security

00:14:07,250 --> 00:14:12,530
properties so if you are unsure how we

00:14:09,950 --> 00:14:14,840
can achieve certain a property or defend

00:14:12,530 --> 00:14:17,390
against a certain attack the answer will

00:14:14,840 --> 00:14:22,060
usually be that there's a monitor

00:14:17,390 --> 00:14:27,350
function that serves to achieve this and

00:14:22,060 --> 00:14:29,660
we keep in mind that it's enough if one

00:14:27,350 --> 00:14:33,020
party detects a problem because we have

00:14:29,660 --> 00:14:35,210
a strong indication of where that where

00:14:33,020 --> 00:14:37,760
something went wrong right so if there's

00:14:35,210 --> 00:14:40,580
a one monitor who detects a misbehavior

00:14:37,760 --> 00:14:42,440
that monitor should be in the have all

00:14:40,580 --> 00:14:44,630
the necessary data to prove to the

00:14:42,440 --> 00:14:47,450
outside world to the wider community

00:14:44,630 --> 00:14:53,330
that yes there was a problem and the

00:14:47,450 --> 00:14:59,090
problem was this and that okay

00:14:53,330 --> 00:15:00,680
yeah so let's quickly recap the Lok

00:14:59,090 --> 00:15:03,410
Sabha can efficiently and

00:15:00,680 --> 00:15:07,040
cryptographically proof that a given

00:15:03,410 --> 00:15:09,790
element was included in the list covered

00:15:07,040 --> 00:15:12,950
by the tree data structure it can

00:15:09,790 --> 00:15:14,310
efficiently prove that the list was

00:15:12,950 --> 00:15:18,660
operated in a pen

00:15:14,310 --> 00:15:22,560
only fashion the new the other new

00:15:18,660 --> 00:15:25,230
components the auditor which is resides

00:15:22,560 --> 00:15:29,340
with the apt client and the monitor

00:15:25,230 --> 00:15:32,420
which is an additional component these

00:15:29,340 --> 00:15:36,540
to verify the lock inclusion of

00:15:32,420 --> 00:15:39,180
important metadata files they verify the

00:15:36,540 --> 00:15:43,279
consistent operation of the Lok Sabha

00:15:39,180 --> 00:15:46,770
and the monitor additionally has

00:15:43,279 --> 00:15:54,380
investigating functions that analyze the

00:15:46,770 --> 00:15:58,410
data present now so far the architecture

00:15:54,380 --> 00:16:01,770
what are the things that we need to

00:15:58,410 --> 00:16:06,990
assume in order to make this changes in

00:16:01,770 --> 00:16:09,720
the existing system assumed in order to

00:16:06,990 --> 00:16:12,240
achieve all these things well the

00:16:09,720 --> 00:16:16,200
starting off with the archive these are

00:16:12,240 --> 00:16:19,710
assumptions the archive can submit files

00:16:16,200 --> 00:16:22,620
into the lock server and on submission

00:16:19,710 --> 00:16:25,860
the locks of returns and in inclusion

00:16:22,620 --> 00:16:29,010
promise and these inclusion promises

00:16:25,860 --> 00:16:33,420
which are essentially signatures over

00:16:29,010 --> 00:16:35,490
small items need to be distributed by

00:16:33,420 --> 00:16:39,420
the archive in order to who with lock

00:16:35,490 --> 00:16:41,880
server accountable to its promises we

00:16:39,420 --> 00:16:46,350
assume that the release frequency is

00:16:41,880 --> 00:16:48,140
rather consistent the archive in our

00:16:46,350 --> 00:16:50,760
architecture is responsible for

00:16:48,140 --> 00:16:53,640
distributing reproducible builds of

00:16:50,760 --> 00:16:55,710
course it's possible to have black lists

00:16:53,640 --> 00:17:00,480
if you know ok this package won't be

00:16:55,710 --> 00:17:03,030
reproducible for example we also assumed

00:17:00,480 --> 00:17:06,120
that the build info file that required

00:17:03,030 --> 00:17:09,030
to build a reproducible is covered by

00:17:06,120 --> 00:17:13,260
the release file so at the moment we

00:17:09,030 --> 00:17:18,420
treated as sauce package metadata we

00:17:13,260 --> 00:17:21,929
also assumed source only uploads and we

00:17:18,420 --> 00:17:25,580
assume that there's a keyring package

00:17:21,929 --> 00:17:29,660
there is an authoritative copy of

00:17:25,580 --> 00:17:32,210
the keyring so this a keyring a sauce

00:17:29,660 --> 00:17:39,200
package would then be respected by the

00:17:32,210 --> 00:17:41,150
archive on uploads okay so so much for

00:17:39,200 --> 00:17:43,340
the archive the locks well well let's

00:17:41,150 --> 00:17:46,610
stand alone server one would probably

00:17:43,340 --> 00:17:49,040
want to have more than one of these you

00:17:46,610 --> 00:17:51,980
can have read-only front ends to these

00:17:49,040 --> 00:17:54,980
because only the archive is going to

00:17:51,980 --> 00:17:57,140
submit to it and I think we are also

00:17:54,980 --> 00:17:59,600
going to have a much easier time

00:17:57,140 --> 00:18:01,520
operating these locks servers compared

00:17:59,600 --> 00:18:04,010
to a certificate transparency for

00:18:01,520 --> 00:18:09,140
example where anybody can upload

00:18:04,010 --> 00:18:12,950
certificates usually mmm the audit or a

00:18:09,140 --> 00:18:16,730
component should be integrated into up

00:18:12,950 --> 00:18:21,170
somehow and the important parts here are

00:18:16,730 --> 00:18:23,900
some cryptographic verifications a few

00:18:21,170 --> 00:18:30,650
file formats that need to be understood

00:18:23,900 --> 00:18:34,130
and some network access some of these

00:18:30,650 --> 00:18:36,410
things we can also distribute over the

00:18:34,130 --> 00:18:39,200
mirrors pack them into together into

00:18:36,410 --> 00:18:42,590
into files such that they are usable for

00:18:39,200 --> 00:18:45,530
most clients and then ship it off as

00:18:42,590 --> 00:18:51,230
additional metadata much like we do with

00:18:45,530 --> 00:18:54,410
other metadata right now okay so the

00:18:51,230 --> 00:18:59,510
lock server and the auditor now for the

00:18:54,410 --> 00:19:01,940
monitor the monitor tasks include the

00:18:59,510 --> 00:19:06,050
verifying the append only operation of

00:19:01,940 --> 00:19:08,570
the lock the monitor will probably want

00:19:06,050 --> 00:19:14,600
to exchange three routes with monitors

00:19:08,570 --> 00:19:18,140
and auditors the verification functions

00:19:14,600 --> 00:19:21,940
of the monitor also include checks of

00:19:18,140 --> 00:19:26,000
the package metadata for example is the

00:19:21,940 --> 00:19:27,680
metadata complete all the parts that as

00:19:26,000 --> 00:19:31,430
opposed to be there are they actually

00:19:27,680 --> 00:19:35,200
there do we have the source available

00:19:31,430 --> 00:19:38,630
for every package are the version

00:19:35,200 --> 00:19:42,620
increments correct for

00:19:38,630 --> 00:19:44,750
package change or dependency change or

00:19:42,620 --> 00:19:47,570
something like that there should be a

00:19:44,750 --> 00:19:53,290
version change such that clients are

00:19:47,570 --> 00:19:55,820
actually updating correctly yeah I

00:19:53,290 --> 00:20:00,730
talked about the release frequency that

00:19:55,820 --> 00:20:05,240
needs to be consistent we can verify the

00:20:00,730 --> 00:20:09,470
upload access control lists using saw

00:20:05,240 --> 00:20:13,340
signatures and the authoritative keyring

00:20:09,470 --> 00:20:16,750
and the monitor of course can also

00:20:13,340 --> 00:20:20,240
verify reproducible builds to verify the

00:20:16,750 --> 00:20:24,250
mapping between source and binary

00:20:20,240 --> 00:20:30,290
package using the built in full file

00:20:24,250 --> 00:20:34,460
okay so that's the things that are new

00:20:30,290 --> 00:20:37,130
in this architecture now I'd like to

00:20:34,460 --> 00:20:39,920
discuss a little bit what useful

00:20:37,130 --> 00:20:43,340
features they are for different groups

00:20:39,920 --> 00:20:48,440
aside from of course the security and

00:20:43,340 --> 00:20:53,750
new security properties the these

00:20:48,440 --> 00:20:56,060
reasons should in my opinion also serve

00:20:53,750 --> 00:20:58,370
as a motivation for different people to

00:20:56,060 --> 00:21:01,550
run one of these monitors because the

00:20:58,370 --> 00:21:05,660
monitors can alert them if things go

00:21:01,550 --> 00:21:09,830
wrong in in some way so maintain us get

00:21:05,660 --> 00:21:13,760
assurance of reproduce at the binary

00:21:09,830 --> 00:21:17,080
they can have a notification of all

00:21:13,760 --> 00:21:22,250
uploads that were done using their key

00:21:17,080 --> 00:21:27,320
they can have notifications of who did

00:21:22,250 --> 00:21:29,840
changes on their packages and all these

00:21:27,320 --> 00:21:32,660
things are independent of the existing

00:21:29,840 --> 00:21:35,660
infrastructure so no matter what is

00:21:32,660 --> 00:21:39,020
compromised in the existing

00:21:35,660 --> 00:21:43,790
infrastructure the these would also be a

00:21:39,020 --> 00:21:48,650
verifiable the account managers and a

00:21:43,790 --> 00:21:51,800
keyring maintain us have a have a way to

00:21:48,650 --> 00:21:57,110
ensure that the keyring is

00:21:51,800 --> 00:22:00,070
respected for uploads the reproducible

00:21:57,110 --> 00:22:03,590
builds people can have assurances of

00:22:00,070 --> 00:22:08,030
reproducible binary packages and the

00:22:03,590 --> 00:22:11,840
archive operators and FTP masses can

00:22:08,030 --> 00:22:15,080
have assurance of correct metadata they

00:22:11,840 --> 00:22:19,280
can have assurance of reproducibly

00:22:15,080 --> 00:22:22,670
building binary packages and also that

00:22:19,280 --> 00:22:29,960
the machines are correctly observing the

00:22:22,670 --> 00:22:36,740
upload ACLs ok so these are the features

00:22:29,960 --> 00:22:39,940
that are added into the system we now

00:22:36,740 --> 00:22:44,140
talk a little bit about what actually

00:22:39,940 --> 00:22:46,760
exists well it does exist in prototype

00:22:44,140 --> 00:22:50,150
fashion so for all the components

00:22:46,760 --> 00:22:52,280
there's a sa prototype

00:22:50,150 --> 00:22:54,920
these prototypes contain the

00:22:52,280 --> 00:22:57,800
cryptographic verification functions and

00:22:54,920 --> 00:23:01,640
so on but they are not in not yet in

00:22:57,800 --> 00:23:03,440
form of patches to the actual Debian

00:23:01,640 --> 00:23:07,390
software and to the up client for

00:23:03,440 --> 00:23:12,770
example what we did in order to evaluate

00:23:07,390 --> 00:23:15,950
this prototype we used the last two

00:23:12,770 --> 00:23:19,880
years of the stretch development phase

00:23:15,950 --> 00:23:22,460
so two years before stretch became

00:23:19,880 --> 00:23:25,100
stable until the stretch became a stable

00:23:22,460 --> 00:23:27,980
basically so that's two years of Debian

00:23:25,100 --> 00:23:31,210
testing we fed it into the system this

00:23:27,980 --> 00:23:35,960
results in two hundred seventy thousand

00:23:31,210 --> 00:23:39,290
three elements and the lock server needs

00:23:35,960 --> 00:23:41,300
a storage of about 400 gigabytes which

00:23:39,290 --> 00:23:45,740
is of course heavily dominated by the

00:23:41,300 --> 00:23:51,440
source packages the cost of the monitor

00:23:45,740 --> 00:23:54,200
is dominated heavily by the verification

00:23:51,440 --> 00:24:00,450
of reproducible builds because compiling

00:23:54,200 --> 00:24:03,149
takes time and CPU time and we also

00:24:00,450 --> 00:24:06,059
notice that maybe some inconsistencies

00:24:03,149 --> 00:24:10,169
in ammeter data at some point in time so

00:24:06,059 --> 00:24:12,539
for example that the source is missing

00:24:10,169 --> 00:24:16,279
or that the version wasn't incremented

00:24:12,539 --> 00:24:21,720
when I thought there would be a version

00:24:16,279 --> 00:24:25,379
increment okay mmm

00:24:21,720 --> 00:24:27,739
if you are interested in this topic here

00:24:25,379 --> 00:24:31,220
are some pointers that may also be

00:24:27,739 --> 00:24:35,249
interesting to you the first one is a

00:24:31,220 --> 00:24:37,080
theoretical work the second one is

00:24:35,249 --> 00:24:39,539
another interesting a software

00:24:37,080 --> 00:24:41,940
distribution security system I believe

00:24:39,539 --> 00:24:46,230
there will be a presentation later in

00:24:41,940 --> 00:24:50,730
the conference the third one is an idea

00:24:46,230 --> 00:24:55,679
by the Firefox people to have a similar

00:24:50,730 --> 00:25:03,590
feature for Firefox and the fourth one

00:24:55,679 --> 00:25:08,450
is a new proposal okay

00:25:03,590 --> 00:25:11,580
let's quickly recap so we can achieve

00:25:08,450 --> 00:25:14,909
under this architecture the detection of

00:25:11,580 --> 00:25:19,409
targeted vectors we get lots of

00:25:14,909 --> 00:25:23,340
auditability features for example we can

00:25:19,409 --> 00:25:26,399
we will be assure that for every binary

00:25:23,340 --> 00:25:29,629
we can point to the appropriate source

00:25:26,399 --> 00:25:34,710
code and the source code is downloadable

00:25:29,629 --> 00:25:37,649
for each binary we can also be sure that

00:25:34,710 --> 00:25:42,869
this is the exact source code that was

00:25:37,649 --> 00:25:46,739
used to compile it we can identify which

00:25:42,869 --> 00:25:49,429
maintain authorized the upload and we

00:25:46,739 --> 00:25:53,340
have in case anything goes wrong we

00:25:49,429 --> 00:25:55,080
should have strong evidence or the party

00:25:53,340 --> 00:25:57,899
detecting that something goes wrong

00:25:55,080 --> 00:25:59,850
we'll have strong evidence to convince

00:25:57,899 --> 00:26:02,039
the public that yes

00:25:59,850 --> 00:26:06,300
there was a problem and the problem was

00:26:02,039 --> 00:26:09,270
this in that there's

00:26:06,300 --> 00:26:13,590
class of attacks I didn't really discuss

00:26:09,270 --> 00:26:19,200
in detail today so just so you're aware

00:26:13,590 --> 00:26:24,120
that there's more more out there yep

00:26:19,200 --> 00:26:27,660
so that would be it from my side and now

00:26:24,120 --> 00:26:30,600
I'm interested in your questions and

00:26:27,660 --> 00:26:43,800
ideas and any other feedback you might

00:26:30,600 --> 00:26:45,840
have hi so you mentioned multiple times

00:26:43,800 --> 00:26:49,860
about append-only

00:26:45,840 --> 00:26:53,160
feature of these trees so over the

00:26:49,860 --> 00:26:57,210
decades of running this when this whole

00:26:53,160 --> 00:26:59,970
system is growing rapidly how do you

00:26:57,210 --> 00:27:02,970
propose to do like rollovers of those

00:26:59,970 --> 00:27:05,210
hash trees or what are your ideas and on

00:27:02,970 --> 00:27:09,090
that front do you have any proposals I

00:27:05,210 --> 00:27:11,610
don't have a specific proposal and a

00:27:09,090 --> 00:27:13,920
certificate transparency is ahead of us

00:27:11,610 --> 00:27:17,100
and they are dealing with this problem

00:27:13,920 --> 00:27:20,010
right now basically and the main idea

00:27:17,100 --> 00:27:22,500
they seem to be using is having

00:27:20,010 --> 00:27:27,060
different lock service for different

00:27:22,500 --> 00:27:29,090
years and well that's one one way to do

00:27:27,060 --> 00:27:29,090
it

00:27:35,790 --> 00:27:40,600
someone on the internet asked that does

00:27:38,710 --> 00:27:43,620
that scheme do anything to prevent

00:27:40,600 --> 00:27:43,620
repair texts

00:27:44,170 --> 00:27:52,110
you mean like avoiding that I'm showing

00:27:49,690 --> 00:27:55,510
the an old version of a package again

00:27:52,110 --> 00:27:59,650
yeah okay yeah so in the literature

00:27:55,510 --> 00:28:02,050
that's most most of the time called a

00:27:59,650 --> 00:28:05,890
freeze attack so if you look at that and

00:28:02,050 --> 00:28:09,520
up already has a defense feature built

00:28:05,890 --> 00:28:13,780
in to defend against that so the release

00:28:09,520 --> 00:28:17,850
files which cover all the packages they

00:28:13,780 --> 00:28:21,100
have they have a wall clock time until

00:28:17,850 --> 00:28:23,020
which they are welded so I think it's

00:28:21,100 --> 00:28:28,620
probably seven days or something like

00:28:23,020 --> 00:28:28,620
that for which the release file is valid

00:29:17,940 --> 00:29:23,320
what's the status of this proposal who

00:29:21,580 --> 00:29:26,169
is working on this who will operate

00:29:23,320 --> 00:29:27,970
these servers and what do you plan to do

00:29:26,169 --> 00:29:32,070
against compromise of this service

00:29:27,970 --> 00:29:36,760
because then you can route everybody yes

00:29:32,070 --> 00:29:40,779
so the status is that I'm working on it

00:29:36,760 --> 00:29:42,610
and everybody is invited to also work on

00:29:40,779 --> 00:29:45,100
it and any work for example and

00:29:42,610 --> 00:29:47,919
reproducible boots it's also helpful of

00:29:45,100 --> 00:29:56,799
course because that work is important

00:29:47,919 --> 00:30:00,820
and needs to be done so if the the lock

00:29:56,799 --> 00:30:04,980
server is compromised that should be

00:30:00,820 --> 00:30:10,059
something that's possible to detect if

00:30:04,980 --> 00:30:12,490
malicious operation is done so I mean

00:30:10,059 --> 00:30:15,669
the exact details depend on what the

00:30:12,490 --> 00:30:17,230
what the attacker would would do and I

00:30:15,669 --> 00:30:26,529
think there was another part to your

00:30:17,230 --> 00:30:29,740
question right oh yeah of course of

00:30:26,529 --> 00:30:33,220
course of us okay so it was important to

00:30:29,740 --> 00:30:36,669
me because lots of academic work as well

00:30:33,220 --> 00:30:39,399
we need this cool we need this cool

00:30:36,669 --> 00:30:42,580
system and we will have independent

00:30:39,399 --> 00:30:46,210
parties operated so I think that's a

00:30:42,580 --> 00:30:50,799
very important question the lock server

00:30:46,210 --> 00:30:54,429
itself would in my imagination would be

00:30:50,799 --> 00:30:59,799
that it's operated by the project like

00:30:54,429 --> 00:31:01,960
other central infrastructure the auditor

00:30:59,799 --> 00:31:04,480
component is integrated with the up

00:31:01,960 --> 00:31:07,539
client so everybody can have it and turn

00:31:04,480 --> 00:31:11,200
it off or on or something and the

00:31:07,539 --> 00:31:15,429
monitor functions these need to be run

00:31:11,200 --> 00:31:19,539
independently as well so that that's one

00:31:15,429 --> 00:31:22,460
reason why I came up with the different

00:31:19,539 --> 00:31:26,240
verification functions because

00:31:22,460 --> 00:31:29,389
different different people can get

00:31:26,240 --> 00:31:30,850
different advantages can get interests

00:31:29,389 --> 00:31:34,580
might be interests in different

00:31:30,850 --> 00:31:39,559
currencies so for example the account

00:31:34,580 --> 00:31:43,519
manager team and the Q key ring team

00:31:39,559 --> 00:31:45,470
might want to run a monitor that only

00:31:43,519 --> 00:31:46,999
does the lightweight verification

00:31:45,470 --> 00:31:49,879
functions and in particular all

00:31:46,999 --> 00:31:52,850
functions verification functions related

00:31:49,879 --> 00:31:55,429
to keys and they might not run record

00:31:52,850 --> 00:32:03,080
fully reproducible bits verification

00:31:55,429 --> 00:32:05,090
which of course is costly hello

00:32:03,080 --> 00:32:08,389
you said there were some unexpected

00:32:05,090 --> 00:32:12,110
events could you tell a little bit more

00:32:08,389 --> 00:32:14,240
about that I investigate and so on yes I

00:32:12,110 --> 00:32:17,779
plan to do so but I need to improve my

00:32:14,240 --> 00:32:21,409
tooling because I have tons of meta data

00:32:17,779 --> 00:32:24,110
files and navigating through them is a

00:32:21,409 --> 00:32:27,619
bit painful at the moment but it's work

00:32:24,110 --> 00:32:29,629
that needs to be done yeah and also have

00:32:27,619 --> 00:32:36,919
you run the same set of checks against

00:32:29,629 --> 00:32:38,570
Buster yes that means you have code for

00:32:36,919 --> 00:32:41,629
this already I do

00:32:38,570 --> 00:32:43,940
do you have code for this already yes

00:32:41,629 --> 00:32:50,299
prototype code so the verification

00:32:43,940 --> 00:32:54,559
functions are implemented almost most of

00:32:50,299 --> 00:32:56,509
Emily's and I but I don't have patches

00:32:54,559 --> 00:32:58,369
for up for example right so it's an

00:32:56,509 --> 00:33:00,350
in-the-moment it's an independent

00:32:58,369 --> 00:33:02,149
component that that's the verification

00:33:00,350 --> 00:33:06,110
but I don't have pictures for up so

00:33:02,149 --> 00:33:08,960
that's C and where is the code I mean

00:33:06,110 --> 00:33:12,100
the URL it's in it's in get I can put up

00:33:08,960 --> 00:33:12,100
here here

00:33:31,060 --> 00:33:36,940
hello you said that testing

00:33:34,300 --> 00:33:39,220
reproducibility of the belt is very

00:33:36,940 --> 00:33:39,670
costly does that mean you're doing that

00:33:39,220 --> 00:33:45,190
already

00:33:39,670 --> 00:33:46,840
no okay okay I was going to ask you how

00:33:45,190 --> 00:33:51,640
you're doing that yeah

00:33:46,840 --> 00:33:55,710
I think it should be the only thing

00:33:51,640 --> 00:33:55,710
that's missing I think

00:34:06,119 --> 00:34:14,519
is this integration with optim-ox

00:34:08,460 --> 00:34:17,549
exactly not yet so our very idea how it

00:34:14,519 --> 00:34:22,409
would work with for instance a contact

00:34:17,549 --> 00:34:26,249
log server directly okay yeah yes

00:34:22,409 --> 00:34:28,649
so there are multiple possibilities to

00:34:26,249 --> 00:34:33,769
do that for example to ship the proofs

00:34:28,649 --> 00:34:38,819
to the clients we we could decide to

00:34:33,769 --> 00:34:41,309
have the proofs that are likely to be

00:34:38,819 --> 00:34:43,559
relevant to most clients to have them

00:34:41,309 --> 00:34:45,960
distributed over the amira network in

00:34:43,559 --> 00:34:49,200
order to say if the clients contacting

00:34:45,960 --> 00:34:53,869
the locks of separately or one could

00:34:49,200 --> 00:34:56,579
have the client always contact the locks

00:34:53,869 --> 00:35:00,569
yeah so they are different trade-offs

00:34:56,579 --> 00:35:03,630
possible and we would then need to

00:35:00,569 --> 00:35:06,650
decide which way to go all right yeah

00:35:03,630 --> 00:35:06,650
multiple possibilities

00:35:09,450 --> 00:35:14,400
like I'd like to thank you for your work

00:35:12,869 --> 00:35:16,500
because we've been in reputable birds

00:35:14,400 --> 00:35:19,170
we've been discussing these ideas since

00:35:16,500 --> 00:35:21,480
2014 but never wrote them down this

00:35:19,170 --> 00:35:31,980
consistently so thank you for that work

00:35:21,480 --> 00:35:35,930
great yeah I'm the same you you

00:35:31,980 --> 00:35:40,650
mentioned apps doing some kind of online

00:35:35,930 --> 00:35:42,540
query into the log server for the the

00:35:40,650 --> 00:35:46,799
pieces necessary to verify that a

00:35:42,540 --> 00:35:51,089
package can be trusted but a lot of the

00:35:46,799 --> 00:35:53,609
time app could be used offline as well

00:35:51,089 --> 00:35:56,130
and so that the package in indices

00:35:53,609 --> 00:35:58,020
contain signatures that allow offline

00:35:56,130 --> 00:35:59,849
verification before installing a package

00:35:58,020 --> 00:36:04,200
from a package if it's been already

00:35:59,849 --> 00:36:06,930
downloaded and a install time for

00:36:04,200 --> 00:36:11,869
example packages could be coming from

00:36:06,930 --> 00:36:14,880
offline media do you have ideas how

00:36:11,869 --> 00:36:17,730
offline verification could be done is it

00:36:14,880 --> 00:36:23,130
possible to along with the DEP to

00:36:17,730 --> 00:36:27,440
distribute proofs that the package is

00:36:23,130 --> 00:36:32,490
just worthy yes it's certainly possible

00:36:27,440 --> 00:36:35,609
if we decide to ship proofs over the

00:36:32,490 --> 00:36:37,530
mirror network we have to decide for

00:36:35,609 --> 00:36:39,599
example for the consistency approved

00:36:37,530 --> 00:36:43,619
between different three hats meaning

00:36:39,599 --> 00:36:46,920
different three sizes there have to be

00:36:43,619 --> 00:36:48,869
consistent sea proofs and one I mean

00:36:46,920 --> 00:36:52,680
this proofs aren't large they're quite

00:36:48,869 --> 00:36:55,349
small so we would need to pick a bunch

00:36:52,680 --> 00:36:58,079
of generations basically into one file

00:36:55,349 --> 00:37:00,720
ship it off and if the client is

00:36:58,079 --> 00:37:02,849
basically within range of the tree size

00:37:00,720 --> 00:37:09,390
and it would work and otherwise an

00:37:02,849 --> 00:37:10,799
online operation would be required but I

00:37:09,390 --> 00:37:15,319
haven't thought a lot about the

00:37:10,799 --> 00:37:15,319
installation phase I have to admit

00:37:22,090 --> 00:37:28,140
okay so the would be a bit more time if

00:37:25,240 --> 00:37:28,140
there are any questions

00:37:34,140 --> 00:37:43,169
okay

00:37:36,260 --> 00:37:43,169

YouTube URL: https://www.youtube.com/watch?v=W89ecLNcKT8


