Title: Software transparency: improving package manager security
Publication date: 2019-08-04
Playlist: DebConf 19
Description: 
	by Benjamin

At: DebConf19
https://debconf19.debconf.org/talks/66-software-transparency-improving-package-manager-security/

Software transparency is an effort to improve on the cryptographic signatures of the APT package manager by introducing a Merkle tree transparency log for package meta data and source code, similar to certificate transparency. This allows us to provide two security properties: The detection of targeted backdoors introduced by a malicious archive and the validation of the reproducible builds property.

We present an overview of the architecture and report on the progress made since DebConf18, which includes:

- (almost) removing online operations for the client
- secured mirror available
- compatibility to Certificate Transparency gossip hub to defend against equivocation attacks

There are also lots of things that still need to be done, and we will talk about that as well!

Room: Auditório
Scheduled start: 2019-07-21 14:30:00
Captions: 
	00:00:04,770 --> 00:00:09,309
thank you everybody for coming I would

00:00:06,970 --> 00:00:11,500
like to introduce enamine hall from

00:00:09,309 --> 00:00:14,200
tecnica technisches universität münchen

00:00:11,500 --> 00:00:16,509
and he will speak us about software

00:00:14,200 --> 00:00:18,910
transparency package security beyond

00:00:16,509 --> 00:00:20,070
signatures and reproducible builds Thank

00:00:18,910 --> 00:00:22,509
You Benjamin

00:00:20,070 --> 00:00:25,660
Akash good afternoon everybody and

00:00:22,509 --> 00:00:28,930
welcome to this presentation we are now

00:00:25,660 --> 00:00:31,779
going to talk about how we can improve

00:00:28,930 --> 00:00:35,800
on the existing security system that we

00:00:31,779 --> 00:00:39,550
have in up and the deputy f and also how

00:00:35,800 --> 00:00:41,320
we can combine this with other ideas

00:00:39,550 --> 00:00:45,250
such as reproducible builds in order to

00:00:41,320 --> 00:00:48,640
get the best properties possible out of

00:00:45,250 --> 00:00:51,730
it so first of all I want to give a

00:00:48,640 --> 00:00:53,500
little introduction into the subject

00:00:51,730 --> 00:00:57,370
area and then we are going to talk about

00:00:53,500 --> 00:01:00,850
the proposed design so why should we

00:00:57,370 --> 00:01:03,610
care about this topic we well we have

00:01:00,850 --> 00:01:07,270
opted which is working very nicely it

00:01:03,610 --> 00:01:12,450
has cryptographic signatures has had it

00:01:07,270 --> 00:01:16,330
for quite a while so there's lots of

00:01:12,450 --> 00:01:19,150
reports on security problems introduced

00:01:16,330 --> 00:01:21,970
to update systems themselves so up

00:01:19,150 --> 00:01:24,010
compromised update systems distributing

00:01:21,970 --> 00:01:27,040
and malicious software software

00:01:24,010 --> 00:01:30,159
hijacking update systems so it's a

00:01:27,040 --> 00:01:33,549
general point of attention and in the

00:01:30,159 --> 00:01:36,159
last a few years very famous the attack

00:01:33,549 --> 00:01:38,049
on the ADO's update system where

00:01:36,159 --> 00:01:40,390
malicious software was distributed by

00:01:38,049 --> 00:01:43,060
the update system signed correctly with

00:01:40,390 --> 00:01:45,970
the correct others keys and then 500

00:01:43,060 --> 00:01:52,420
users were specifically targeted by a

00:01:45,970 --> 00:01:55,030
MEK addresses so well why that we have

00:01:52,420 --> 00:01:57,460
is working very nicely I would argue

00:01:55,030 --> 00:02:00,869
that we should prepare about the rainy

00:01:57,460 --> 00:02:03,909
days as well as nothing is infallible

00:02:00,869 --> 00:02:07,540
you'll find another great motivation if

00:02:03,909 --> 00:02:10,689
you have seen one of Chris lambs talks a

00:02:07,540 --> 00:02:12,849
tale of three developers where he speaks

00:02:10,689 --> 00:02:15,189
about the motivation for i reproduce of

00:02:12,849 --> 00:02:16,450
the birds which also ties in very

00:02:15,189 --> 00:02:21,420
closely with

00:02:16,450 --> 00:02:24,150
we're going to talk about now so we now

00:02:21,420 --> 00:02:27,129
take a look at the existing architecture

00:02:24,150 --> 00:02:29,590
afterwards at the proposed additional

00:02:27,129 --> 00:02:32,200
architecture element and then at the end

00:02:29,590 --> 00:02:36,790
I'll report some progress that we've

00:02:32,200 --> 00:02:37,330
made since the last time we talked about

00:02:36,790 --> 00:02:42,190
this

00:02:37,330 --> 00:02:46,150
so in up the software distribution looks

00:02:42,190 --> 00:02:48,250
like this we have the uploader signing

00:02:46,150 --> 00:02:51,160
source package uploading it to the

00:02:48,250 --> 00:02:54,519
archive the archive takes care that the

00:02:51,160 --> 00:02:56,560
binary packages are built and then uses

00:02:54,519 --> 00:03:01,060
its own assigning key in order to sign

00:02:56,560 --> 00:03:03,819
the metadata that envelopes all of the

00:03:01,060 --> 00:03:06,849
source and binary packages that's called

00:03:03,819 --> 00:03:09,730
the release file and then the release

00:03:06,849 --> 00:03:11,709
file once it is finished is pushed out

00:03:09,730 --> 00:03:15,720
onto the mirror network our container

00:03:11,709 --> 00:03:18,730
solution network and from there the

00:03:15,720 --> 00:03:21,910
clients the apt clients can receive all

00:03:18,730 --> 00:03:26,139
the packages and/or the metadata in

00:03:21,910 --> 00:03:29,530
order to well install packages and the

00:03:26,139 --> 00:03:32,590
critical thing here is now that we have

00:03:29,530 --> 00:03:36,340
the uploader signing the source package

00:03:32,590 --> 00:03:39,670
meaning this the archive can verify who

00:03:36,340 --> 00:03:42,790
uploaded a package and the archive

00:03:39,670 --> 00:03:45,850
assigns the metadata and thereby the

00:03:42,790 --> 00:03:48,489
packages meaning that the apt clients

00:03:45,850 --> 00:03:50,650
can verify that the release was

00:03:48,489 --> 00:03:52,480
published by the archive and it's an

00:03:50,650 --> 00:03:55,180
authentic release however all the

00:03:52,480 --> 00:03:58,450
security rests in the signing key of the

00:03:55,180 --> 00:04:01,209
archive and once that is compromised

00:03:58,450 --> 00:04:04,299
well right now all is lost and in the

00:04:01,209 --> 00:04:06,940
following I'm try to show you how we can

00:04:04,299 --> 00:04:10,989
improve on that and argue the case that

00:04:06,940 --> 00:04:13,989
it need not necessarily be that all

00:04:10,989 --> 00:04:16,269
security rests on a single key and that

00:04:13,989 --> 00:04:21,780
we can in the case of e compromised to

00:04:16,269 --> 00:04:23,510
retain some security properties so

00:04:21,780 --> 00:04:26,870
coming

00:04:23,510 --> 00:04:29,750
the design there's a bunch of things

00:04:26,870 --> 00:04:32,630
that we want to achieve in this system

00:04:29,750 --> 00:04:35,090
so the core idea that we are going to

00:04:32,630 --> 00:04:38,780
follow is that we want to make sure that

00:04:35,090 --> 00:04:41,090
all installations observe the same in

00:04:38,780 --> 00:04:43,820
release file so all installations see

00:04:41,090 --> 00:04:45,860
the same releases and if you think about

00:04:43,820 --> 00:04:48,680
it a bit that's a property that we don't

00:04:45,860 --> 00:04:50,960
necessarily have with the archive

00:04:48,680 --> 00:04:53,240
signing release files right because a

00:04:50,960 --> 00:04:55,520
compromised archives could assign

00:04:53,240 --> 00:04:59,090
different versions of the release file

00:04:55,520 --> 00:05:01,820
and present one release file including

00:04:59,090 --> 00:05:05,990
malicious software only to a targeted

00:05:01,820 --> 00:05:08,240
subset of the population so we want to

00:05:05,990 --> 00:05:10,480
ensure that everybody sees the same

00:05:08,240 --> 00:05:16,730
software and installs exactly the same

00:05:10,480 --> 00:05:19,520
binaries if we can achieve this they can

00:05:16,730 --> 00:05:22,190
we can detect the targeted back toes and

00:05:19,520 --> 00:05:24,920
any attacker now must attack the whole

00:05:22,190 --> 00:05:28,390
population of Debian users and is no

00:05:24,920 --> 00:05:39,140
longer able to attack a targeted a

00:05:28,390 --> 00:05:42,860
subset of Debian users and from this we

00:05:39,140 --> 00:05:45,920
also get a different property because

00:05:42,860 --> 00:05:48,380
and now once we analyze the security as

00:05:45,920 --> 00:05:50,960
the software included in in Debian the

00:05:48,380 --> 00:05:55,160
results are directly applicable to every

00:05:50,960 --> 00:05:57,560
Debian user now if we take the property

00:05:55,160 --> 00:05:59,360
of reputable builds for example once we

00:05:57,560 --> 00:06:02,690
verify the reproduce of the built

00:05:59,360 --> 00:06:06,290
property we can now be sure that every

00:06:02,690 --> 00:06:09,140
Debian user has these binaries that were

00:06:06,290 --> 00:06:13,010
built reproducibly or are possible to

00:06:09,140 --> 00:06:15,250
build reproducibly and in case things go

00:06:13,010 --> 00:06:18,740
wrong we want to have a cryptographic

00:06:15,250 --> 00:06:21,730
proof or an indication of where things

00:06:18,740 --> 00:06:23,889
went wrong so that we can guide our

00:06:21,730 --> 00:06:26,139
investigation into

00:06:23,889 --> 00:06:28,150
problems and there's a bunch of other

00:06:26,139 --> 00:06:32,560
analysis that are possible so for

00:06:28,150 --> 00:06:35,050
example it's possible to for individual

00:06:32,560 --> 00:06:37,330
developers to have an audit trail an

00:06:35,050 --> 00:06:39,909
authenticated audit trail of which

00:06:37,330 --> 00:06:44,319
uploads were done using Mikey and other

00:06:39,909 --> 00:06:47,289
uploads in it I did not intend to do the

00:06:44,319 --> 00:06:49,060
hearing maintenance could check that the

00:06:47,289 --> 00:06:49,719
archive respected the keyring at all

00:06:49,060 --> 00:06:54,240
times

00:06:49,719 --> 00:06:57,069
and so on so how does this work from

00:06:54,240 --> 00:07:00,490
architecture or software perspective so

00:06:57,069 --> 00:07:02,740
what we have right now is the archive

00:07:00,490 --> 00:07:05,199
pushing software over-the-air content or

00:07:02,740 --> 00:07:08,199
offering a software on the mirror

00:07:05,199 --> 00:07:10,990
network to the clients and we now add a

00:07:08,199 --> 00:07:16,150
lock server which is a separate server

00:07:10,990 --> 00:07:19,650
that operates a history which is used to

00:07:16,150 --> 00:07:22,990
construct an append-only list basically

00:07:19,650 --> 00:07:26,050
and the archive will now submit all the

00:07:22,990 --> 00:07:27,789
metadata that is the release file the

00:07:26,050 --> 00:07:30,639
signature on the release file the

00:07:27,789 --> 00:07:33,129
packages that exit file and so on and

00:07:30,639 --> 00:07:35,830
all the source packages into this lock

00:07:33,129 --> 00:07:39,159
server and the uptick client will be

00:07:35,830 --> 00:07:41,819
augmented with a small cryptographic

00:07:39,159 --> 00:07:45,339
component with us additional

00:07:41,819 --> 00:07:48,610
verifications on the information I

00:07:45,339 --> 00:07:51,520
provided by the lock so so we need the

00:07:48,610 --> 00:07:55,419
lock server to provide some information

00:07:51,520 --> 00:07:57,939
to the ignorant as well and we can

00:07:55,419 --> 00:08:00,819
achieve this by two ways the up the

00:07:57,939 --> 00:08:03,009
client can either directly talk to the

00:08:00,819 --> 00:08:06,009
lock server or the lock server can

00:08:03,009 --> 00:08:08,529
prepare the necessary information for

00:08:06,009 --> 00:08:11,169
the client and put it onto the mirror

00:08:08,529 --> 00:08:13,360
network so the way that it would work in

00:08:11,169 --> 00:08:17,819
practice or works in the implementation

00:08:13,360 --> 00:08:20,229
is that when the archive submits the

00:08:17,819 --> 00:08:25,360
metadata and source code into the lock

00:08:20,229 --> 00:08:29,139
server it will then also retrieve all

00:08:25,360 --> 00:08:32,319
the required proofs from the lock server

00:08:29,139 --> 00:08:35,900
put it onto the mirror network and from

00:08:32,319 --> 00:08:40,400
there the clients can download

00:08:35,900 --> 00:08:44,090
yeah so the client will check in

00:08:40,400 --> 00:08:46,580
particular to properties and making use

00:08:44,090 --> 00:08:48,890
of the locks oven in two ways first of

00:08:46,580 --> 00:08:51,890
all it will check that the release file

00:08:48,890 --> 00:08:54,230
that is downloaded is included in the

00:08:51,890 --> 00:08:57,740
lock server and the second property it

00:08:54,230 --> 00:09:00,020
will check is that the lock server did

00:08:57,740 --> 00:09:02,600
not manipulate the history so we have a

00:09:00,020 --> 00:09:04,310
consistent history a meaning the lock

00:09:02,600 --> 00:09:09,230
server has maintained a list in an

00:09:04,310 --> 00:09:11,870
append-only men are so I hope you can

00:09:09,230 --> 00:09:14,270
see a little bit where this is going

00:09:11,870 --> 00:09:16,550
keep in mind our goal is to make sure

00:09:14,270 --> 00:09:19,460
that every apt installation

00:09:16,550 --> 00:09:22,040
these the same release files and there

00:09:19,460 --> 00:09:26,960
can be no release fires presented only

00:09:22,040 --> 00:09:30,890
to a subset of the population in order

00:09:26,960 --> 00:09:34,100
for the for this system to work however

00:09:30,890 --> 00:09:36,350
we also need an additional component and

00:09:34,100 --> 00:09:39,800
these are called monitors and the

00:09:36,350 --> 00:09:43,040
monitors are basically observed a lock

00:09:39,800 --> 00:09:46,070
server and analyze what the archive and

00:09:43,040 --> 00:09:49,640
the locks are doing so the monitory

00:09:46,070 --> 00:09:52,250
verifies that the lock server behaves

00:09:49,640 --> 00:09:55,610
cryptographically in an appropriate

00:09:52,250 --> 00:09:56,840
manner so it doesn't maintain the list

00:09:55,610 --> 00:10:00,530
in an append-only

00:09:56,840 --> 00:10:06,260
way and so on and the lock server also

00:10:00,530 --> 00:10:09,260
will analyze the meter package metadata

00:10:06,260 --> 00:10:12,410
the release file the source packages and

00:10:09,260 --> 00:10:15,650
so on and these different analysis would

00:10:12,410 --> 00:10:18,860
include for example the reproduce its

00:10:15,650 --> 00:10:22,910
property it will also check that there

00:10:18,860 --> 00:10:24,800
are no suspicious duplicate releases for

00:10:22,910 --> 00:10:27,760
example happening which would indicate

00:10:24,800 --> 00:10:32,420
that the archive has done something

00:10:27,760 --> 00:10:34,430
unexpected or strange the interesting

00:10:32,420 --> 00:10:37,820
thing about this architecture is that

00:10:34,430 --> 00:10:40,370
one honest monitor is enough so even if

00:10:37,820 --> 00:10:43,490
we don't have a huge amount of money to

00:10:40,370 --> 00:10:46,550
us that's quite quite alright because

00:10:43,490 --> 00:10:47,699
it's enough that there exists one honest

00:10:46,550 --> 00:10:50,069
monitor

00:10:47,699 --> 00:10:53,309
that detects a problem because it once

00:10:50,069 --> 00:10:56,970
the monitor detects a problem we wanted

00:10:53,309 --> 00:10:58,470
to have or we we want to design to be in

00:10:56,970 --> 00:11:01,019
such a way that the monitor has a

00:10:58,470 --> 00:11:04,439
cryptographic proof of where things went

00:11:01,019 --> 00:11:08,220
wrong so that the archive for example

00:11:04,439 --> 00:11:11,009
misbehave this should be a possibility

00:11:08,220 --> 00:11:15,859
investigation into the archive operation

00:11:11,009 --> 00:11:19,079
that the locks of violate some of its

00:11:15,859 --> 00:11:22,410
properties then we need to investigate

00:11:19,079 --> 00:11:23,910
the lock server and so on for all the

00:11:22,410 --> 00:11:28,919
properties that we want to provide the

00:11:23,910 --> 00:11:34,679
monitors we'll need to verify them ok

00:11:28,919 --> 00:11:37,709
yeah so to give you a some idea on how

00:11:34,679 --> 00:11:40,619
the locks of works I'm I'm not going to

00:11:37,709 --> 00:11:45,149
go into too much detail just to give you

00:11:40,619 --> 00:11:48,059
a rough idea the lock server maintains

00:11:45,149 --> 00:11:51,029
an append-only list of elements and the

00:11:48,059 --> 00:11:53,519
elements here are the things like the

00:11:51,029 --> 00:11:56,399
release file other metadata files such

00:11:53,519 --> 00:11:58,919
as the packages file and also the files

00:11:56,399 --> 00:12:01,589
that make up the source packages and

00:11:58,919 --> 00:12:05,399
each of these files is one of the

00:12:01,589 --> 00:12:09,660
squares on my three data structure here

00:12:05,399 --> 00:12:10,980
and the values of all the labels of all

00:12:09,660 --> 00:12:16,019
the inner nodes are the cryptographic

00:12:10,980 --> 00:12:21,089
hash of its children so we construct a

00:12:16,019 --> 00:12:23,669
hash tree computing the hashes of the

00:12:21,089 --> 00:12:26,549
children from the lowest levels of the

00:12:23,669 --> 00:12:29,399
tree up to the very root of the tree and

00:12:26,549 --> 00:12:31,559
you will now realize that if we know the

00:12:29,399 --> 00:12:35,369
the root of the tree the hash of the

00:12:31,559 --> 00:12:39,269
tree root and put a signature on it so

00:12:35,369 --> 00:12:42,539
they lock signs the tree root then we

00:12:39,269 --> 00:12:45,989
can identify securely identify all the

00:12:42,539 --> 00:12:48,329
elements that make up the list that the

00:12:45,989 --> 00:12:51,119
hash tree was constructed over and we

00:12:48,329 --> 00:12:53,249
can do things such as the following we

00:12:51,119 --> 00:12:55,679
can ask the lock server to prove to us

00:12:53,249 --> 00:12:58,139
that for example a given a release file

00:12:55,679 --> 00:12:59,070
was included in the tree and therefore

00:12:58,139 --> 00:13:02,670
that it

00:12:59,070 --> 00:13:05,610
we can ensure that it is visible to all

00:13:02,670 --> 00:13:09,270
the clients and this would work in the

00:13:05,610 --> 00:13:12,410
following way if we want to include if

00:13:09,270 --> 00:13:15,930
we want to verify the inclusion of the

00:13:12,410 --> 00:13:18,930
third element here assuming that we know

00:13:15,930 --> 00:13:20,940
the root of the tree we we ask the Lok

00:13:18,930 --> 00:13:23,370
Sabha please prove to us that under this

00:13:20,940 --> 00:13:25,620
tree root and the following element was

00:13:23,370 --> 00:13:28,460
included in the tree and the response of

00:13:25,620 --> 00:13:31,380
the LOC server would contain the three

00:13:28,460 --> 00:13:34,980
nodes that are marked in gray on the

00:13:31,380 --> 00:13:38,250
tree here and if you look through the

00:13:34,980 --> 00:13:42,240
three starting from the X at the very

00:13:38,250 --> 00:13:44,670
bottom of the tree and you re compute

00:13:42,240 --> 00:13:48,030
all the hashes you'll realize that the

00:13:44,670 --> 00:13:51,270
knowledge of the three nodes marked in

00:13:48,030 --> 00:13:54,060
gray will enable you to recompute the

00:13:51,270 --> 00:13:58,650
root and therefore enable you to verify

00:13:54,060 --> 00:14:02,550
that yes indeed using only these three

00:13:58,650 --> 00:14:06,150
hashes I'm able to convince myself that

00:14:02,550 --> 00:14:11,370
the given element was included in the

00:14:06,150 --> 00:14:14,970
log server so this is one of the checks

00:14:11,370 --> 00:14:18,090
that can be done efficiently on the log

00:14:14,970 --> 00:14:19,470
server which and the fact that we can do

00:14:18,090 --> 00:14:20,910
these checks means we don't have to

00:14:19,470 --> 00:14:22,890
trust the log server because we can

00:14:20,910 --> 00:14:25,080
verify its correct operation from the

00:14:22,890 --> 00:14:27,390
outside we ask it please prove to us

00:14:25,080 --> 00:14:30,240
that this is the case and the lock

00:14:27,390 --> 00:14:31,470
server is able to provide the answer in

00:14:30,240 --> 00:14:34,200
a way that convinces us

00:14:31,470 --> 00:14:39,030
cryptographically another check that we

00:14:34,200 --> 00:14:41,640
can do is that the list was maintained

00:14:39,030 --> 00:14:44,010
in an append-only manner meaning if we

00:14:41,640 --> 00:14:46,920
know I passed three root over a smaller

00:14:44,010 --> 00:14:49,530
tree size for example only four elements

00:14:46,920 --> 00:14:51,810
and we now learn that there's a new tree

00:14:49,530 --> 00:14:54,030
root covering a list of size eight we

00:14:51,810 --> 00:14:56,130
can ask the loc server for a proof that

00:14:54,030 --> 00:14:58,560
these two versions are consistent

00:14:56,130 --> 00:15:00,960
meaning we have only appended new

00:14:58,560 --> 00:15:03,330
elements on the lists and in the loc

00:15:00,960 --> 00:15:07,040
server and not remove the old ones

00:15:03,330 --> 00:15:07,040
perhaps or manipulated

00:15:10,560 --> 00:15:17,320
okay so these are the kinds of checks

00:15:14,020 --> 00:15:19,779
that the a blind would do in our system

00:15:17,320 --> 00:15:22,380
and keep in mind we also have the

00:15:19,779 --> 00:15:25,720
monitor that does additional

00:15:22,380 --> 00:15:30,580
investigation on the elements that make

00:15:25,720 --> 00:15:33,700
up the log now what has happening since

00:15:30,580 --> 00:15:37,510
last that constants we first talked

00:15:33,700 --> 00:15:42,190
about this proposal we now have an

00:15:37,510 --> 00:15:45,360
engine a repository that from which all

00:15:42,190 --> 00:15:48,760
the test installations are installed

00:15:45,360 --> 00:15:51,220
there is a new implementation of the

00:15:48,760 --> 00:15:54,670
lock server the proofs can now be

00:15:51,220 --> 00:15:55,990
distributed over the mirror network the

00:15:54,670 --> 00:15:59,080
new design

00:15:55,990 --> 00:16:01,089
hopefully enables us to implement

00:15:59,080 --> 00:16:04,450
certain defenses against the

00:16:01,089 --> 00:16:07,750
equivocation attacks we have introduced

00:16:04,450 --> 00:16:10,740
versioned data structures I've been

00:16:07,750 --> 00:16:12,760
working on dark patches which are not

00:16:10,740 --> 00:16:19,480
quite finished yet

00:16:12,760 --> 00:16:24,310
but I hope that they are finished soon

00:16:19,480 --> 00:16:28,060
and we operate a secured a mirror which

00:16:24,310 --> 00:16:32,200
is fed from just from another Debian

00:16:28,060 --> 00:16:35,200
Amuro but is augmented with the required

00:16:32,200 --> 00:16:38,230
information for our system so it

00:16:35,200 --> 00:16:40,899
contains the security proofs the

00:16:38,230 --> 00:16:43,540
cryptographic proofs that an apt client

00:16:40,899 --> 00:16:48,240
would need in order to verify the

00:16:43,540 --> 00:16:53,529
properties what's the missing is

00:16:48,240 --> 00:16:58,300
integration into itself so we would need

00:16:53,529 --> 00:17:01,510
to we need to teach up to verify these a

00:16:58,300 --> 00:17:04,150
cryptographic proofs probably by

00:17:01,510 --> 00:17:06,819
extending the JSON RPC interface and up

00:17:04,150 --> 00:17:09,579
and we also need to teach up to download

00:17:06,819 --> 00:17:13,829
the proof files from the mirror isn't

00:17:09,579 --> 00:17:18,520
done yet and also the monitor component

00:17:13,829 --> 00:17:21,610
only exists as a prototype so I we've

00:17:18,520 --> 00:17:25,120
had prototypes for all the software

00:17:21,610 --> 00:17:28,449
ponents and previously we also had two

00:17:25,120 --> 00:17:30,670
years of Debian testing into the lock

00:17:28,449 --> 00:17:34,750
server to make sure to show that

00:17:30,670 --> 00:17:39,670
everything works if you want to play

00:17:34,750 --> 00:17:42,400
around with it you can just use the lock

00:17:39,670 --> 00:17:44,740
server or the mirror if you want to

00:17:42,400 --> 00:17:47,590
submit stuff into the lock server you

00:17:44,740 --> 00:17:55,030
need to send me your IP address because

00:17:47,590 --> 00:17:59,860
the lock doesn't accept just any yeah so

00:17:55,030 --> 00:18:03,820
that's the current state there is a buff

00:17:59,860 --> 00:18:09,130
tomorrow at 2:30 so if you're at all

00:18:03,820 --> 00:18:12,070
interested in this stuff I interest in

00:18:09,130 --> 00:18:14,650
learning a bit more or have some ideas

00:18:12,070 --> 00:18:19,090
on how something could be done or be

00:18:14,650 --> 00:18:20,770
done differently please do join us you

00:18:19,090 --> 00:18:23,200
can also send mace to the

00:18:20,770 --> 00:18:26,350
reprehensibility bits mailing list and

00:18:23,200 --> 00:18:28,360
the code repositories are currently

00:18:26,350 --> 00:18:33,100
being moved on to size'

00:18:28,360 --> 00:18:36,370
so I put the your current URLs up in

00:18:33,100 --> 00:18:40,299
these slides that I will upload yeah so

00:18:36,370 --> 00:18:44,919
I think thank you very much we have time

00:18:40,299 --> 00:18:46,480
for a few questions maybe yeah right

00:18:44,919 --> 00:18:48,429
okay great

00:18:46,480 --> 00:18:52,740
so yeah these are just the list of

00:18:48,429 --> 00:18:52,740
properties that we want to achieve

00:19:21,629 --> 00:19:24,720
right now

00:19:25,890 --> 00:19:31,400
it right Vic I know maybe

00:19:36,630 --> 00:19:44,850
thank you could you please give a quick

00:19:39,870 --> 00:19:51,150
example of a scenario which this system

00:19:44,850 --> 00:19:56,610
is designed to prevent or together yeah

00:19:51,150 --> 00:20:01,560
so two of the main ideas would be one

00:19:56,610 --> 00:20:03,390
the archive is compromised I think that

00:20:01,560 --> 00:20:08,130
would be the big one

00:20:03,390 --> 00:20:12,720
and then we can first of all a force the

00:20:08,130 --> 00:20:15,180
attacker to not target a specific subset

00:20:12,720 --> 00:20:17,610
of the Debian installations but they

00:20:15,180 --> 00:20:21,180
have to distribute the malicious code to

00:20:17,610 --> 00:20:23,130
everybody thereby hopefully discouraging

00:20:21,180 --> 00:20:26,130
the attacker from doing so

00:20:23,130 --> 00:20:30,000
so because the risk of detection is

00:20:26,130 --> 00:20:34,530
higher and another important application

00:20:30,000 --> 00:20:37,440
is that all the code that's distributed

00:20:34,530 --> 00:20:41,240
by Debian is put into the lock server

00:20:37,440 --> 00:20:47,550
and we can ensure that no code is

00:20:41,240 --> 00:20:51,440
distributed that we can't see or

00:20:47,550 --> 00:20:54,720
retrieve so for example if we have a

00:20:51,440 --> 00:20:57,500
reproduce Little Boots verifier we can

00:20:54,720 --> 00:21:02,310
use this system to make sure every code

00:20:57,500 --> 00:21:06,560
distributed by Debian is reproducible so

00:21:02,310 --> 00:21:06,560
does this answer your question

00:21:14,920 --> 00:21:22,510
not exactly yeah so I see the point of

00:21:19,130 --> 00:21:29,150
it I just wanted to I just wanted to

00:21:22,510 --> 00:21:33,890
hear so how would I make use of it would

00:21:29,150 --> 00:21:36,950
I at the user as an apt user would but

00:21:33,890 --> 00:21:41,240
what would happen if if I try to

00:21:36,950 --> 00:21:46,610
download compromised the package or how

00:21:41,240 --> 00:21:49,100
does it appear for me as an end user you

00:21:46,610 --> 00:21:51,400
shouldn't really notice anything about

00:21:49,100 --> 00:21:55,160
the system so if a security verification

00:21:51,400 --> 00:21:56,900
phase it's the same as if you download

00:21:55,160 --> 00:21:59,390
an old release file and up complains

00:21:56,900 --> 00:22:02,450
with a with an error saying we can't

00:21:59,390 --> 00:22:05,980
proceed here because the release file is

00:22:02,450 --> 00:22:09,440
outdated or the signature is wrong and

00:22:05,980 --> 00:22:14,000
how do I know that what I see is what

00:22:09,440 --> 00:22:17,120
everybody else can see we verify that

00:22:14,000 --> 00:22:20,540
the release file we downloaded is

00:22:17,120 --> 00:22:24,740
included in the lock server and the

00:22:20,540 --> 00:22:28,040
monitors then go ahead and investigate

00:22:24,740 --> 00:22:32,000
the lock server checking that the

00:22:28,040 --> 00:22:35,300
release files in there are coming in at

00:22:32,000 --> 00:22:39,350
the expected frequency and there are not

00:22:35,300 --> 00:22:43,430
any release fires for the same date but

00:22:39,350 --> 00:22:46,130
with different contents so it's not

00:22:43,430 --> 00:22:49,400
possible for a compromised archive to

00:22:46,130 --> 00:22:52,700
hide a release from the rest of the

00:22:49,400 --> 00:22:56,180
world and do the monitor write an email

00:22:52,700 --> 00:22:59,390
to Debian devil or how does it happen so

00:22:56,180 --> 00:23:02,840
what happens once this kind of event

00:22:59,390 --> 00:23:05,840
which is hopefully rare is detected

00:23:02,840 --> 00:23:09,040
that's manual intervention the point is

00:23:05,840 --> 00:23:11,960
that the monitor has enough

00:23:09,040 --> 00:23:15,860
cryptographic information from the lock

00:23:11,960 --> 00:23:17,510
because the the information published by

00:23:15,860 --> 00:23:19,880
the archives is signed so the archive

00:23:17,510 --> 00:23:21,410
can't yeah it's signed by the archive

00:23:19,880 --> 00:23:27,460
key so we know the archive he was

00:23:21,410 --> 00:23:27,460
involved and depending on which type of

00:23:28,000 --> 00:23:34,100
tech happened or which type of

00:23:30,460 --> 00:23:36,890
unexpected behavior happy we see either

00:23:34,100 --> 00:23:39,190
something signed by the archive went

00:23:36,890 --> 00:23:43,990
wrong or something signed by the box of

00:23:39,190 --> 00:23:45,920
went wrong and thereby we can guide our

00:23:43,990 --> 00:23:48,260
investigation so if the archive for

00:23:45,920 --> 00:23:50,560
example says this was built reproducibly

00:23:48,260 --> 00:23:56,090
and we sign it with our a release file

00:23:50,560 --> 00:23:59,330
we sign the accordingly and we now

00:23:56,090 --> 00:24:03,080
observe that it doesn't reproduce ibly

00:23:59,330 --> 00:24:10,120
we have the sign signed by the archive

00:24:03,080 --> 00:24:14,020
and can say I think we have to close so

00:24:10,120 --> 00:24:16,520
maybe there is the buff that was

00:24:14,020 --> 00:24:18,080
announced it for further discussion

00:24:16,520 --> 00:24:20,450
thank you everybody for coming Thank You

00:24:18,080 --> 00:24:27,829
Vinny Amin for presenting

00:24:20,450 --> 00:24:27,829

YouTube URL: https://www.youtube.com/watch?v=vA0Krd5UyWM


