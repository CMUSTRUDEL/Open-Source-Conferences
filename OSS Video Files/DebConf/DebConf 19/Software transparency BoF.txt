Title: Software transparency BoF
Publication date: 2019-08-13
Playlist: DebConf 19
Description: 
	by Benjamin

At: DebConf19
https://debconf19.debconf.org/talks/116-software-transparency-bof/

Software transparency is a proposal to make some attacks by a compromised archive detectable. In this session, we will do a quick recap of the current software transparency architecture proposal and then discuss how to proceed.

The possible areas of idea collection and discussion include:

- the current state of the implementation, what works, what doesn't
- being helpful for reproducible builds
- integration within libapt
- interface to dak

Room: Sala de Videoconferencia
Scheduled start: 2019-07-22 14:30:00
Captions: 
	00:00:05,080 --> 00:00:13,910
okay so welcome to the transparency buff

00:00:09,260 --> 00:00:17,270
I would suggest that we first go through

00:00:13,910 --> 00:00:18,910
and you quickly state what you're

00:00:17,270 --> 00:00:21,260
interested in or what you personally

00:00:18,910 --> 00:00:25,460
would like to talk about and then we'll

00:00:21,260 --> 00:00:28,640
try to form an agenda out of it so Mia

00:00:25,460 --> 00:00:32,559
please can we start at can we use the

00:00:28,640 --> 00:00:35,390
portable mic for people to say that okay

00:00:32,559 --> 00:00:40,820
can you just give it to some person and

00:00:35,390 --> 00:00:42,739
that person has to start oh and before I

00:00:40,820 --> 00:00:47,120
thought I could I ask somebody to go

00:00:42,739 --> 00:00:51,079
into the IRC for this room so if there

00:00:47,120 --> 00:00:54,440
are any remote questions or topics we

00:00:51,079 --> 00:01:08,240
could hear those is anybody there's

00:00:54,440 --> 00:01:15,219
anybody on IRC I think the that's great

00:01:08,240 --> 00:01:25,639
awesome thank you very much yeah okay

00:01:15,219 --> 00:01:30,439
yeah so I to tell if there's something

00:01:25,639 --> 00:01:35,240
you'd like to talk about why you're here

00:01:30,439 --> 00:01:44,779
just very briefly I just curious about a

00:01:35,240 --> 00:01:54,709
productive builds and that's it give the

00:01:44,779 --> 00:01:58,149
next person I'd say I'd like I'm curious

00:01:54,709 --> 00:02:04,340
about things other than reproducing

00:01:58,149 --> 00:02:07,489
reproducible builds so about what is

00:02:04,340 --> 00:02:10,700
irreducible built we do know something

00:02:07,489 --> 00:02:13,690
about other techniques with software

00:02:10,700 --> 00:02:17,460
transparency we still don't know

00:02:13,690 --> 00:02:17,460
that's it thank you

00:02:26,790 --> 00:02:34,079
I'm here just for them just to forget

00:02:31,860 --> 00:02:39,620
you know about the about the the talking

00:02:34,079 --> 00:02:39,620
and stuff so I'm just just curious

00:02:46,470 --> 00:02:57,520
okay so then perhaps my question would

00:02:53,650 --> 00:03:01,930
be are people interested in doing a

00:02:57,520 --> 00:03:05,950
short architecture recap so we go over

00:03:01,930 --> 00:03:10,120
the architecture once again and clear up

00:03:05,950 --> 00:03:14,700
a question or any peps you have some

00:03:10,120 --> 00:03:14,700
ideas you would like to bring forward

00:03:30,270 --> 00:03:39,840
okay so this is the way that the archive

00:03:36,470 --> 00:03:44,250
works right now so we have the uploader

00:03:39,840 --> 00:03:49,140
signing source package the archive takes

00:03:44,250 --> 00:03:52,740
care of it being built and signs all the

00:03:49,140 --> 00:03:56,730
packages that should be included the

00:03:52,740 --> 00:04:01,170
mechanism is that we have a file called

00:03:56,730 --> 00:04:02,880
the release file which essentially

00:04:01,170 --> 00:04:05,550
contains all the hashes of all the

00:04:02,880 --> 00:04:08,850
packages and this file is then signed by

00:04:05,550 --> 00:04:12,150
the archive signing key and afterwards

00:04:08,850 --> 00:04:15,900
these this release file or the metadata

00:04:12,150 --> 00:04:18,090
and the packages are put onto the mirror

00:04:15,900 --> 00:04:21,780
Network the content distribution network

00:04:18,090 --> 00:04:26,340
and the clients can install it from

00:04:21,780 --> 00:04:28,710
there so this is really because it

00:04:26,340 --> 00:04:32,960
authenticates all the packages however

00:04:28,710 --> 00:04:35,460
the security depends on the single

00:04:32,960 --> 00:04:36,570
archive signing key so when that's

00:04:35,460 --> 00:04:40,530
compromised

00:04:36,570 --> 00:04:44,490
all is lost and we don't have in any

00:04:40,530 --> 00:04:48,290
other security mechanisms so the

00:04:44,490 --> 00:04:52,590
proposal here is to add an additional

00:04:48,290 --> 00:04:56,160
component called a lock server and the

00:04:52,590 --> 00:04:59,400
function of this lock server is that it

00:04:56,160 --> 00:05:03,360
provides append-only

00:04:59,400 --> 00:05:08,430
data structure and the reason why we do

00:05:03,360 --> 00:05:12,300
that is we try to create one globally

00:05:08,430 --> 00:05:16,260
unique view on the archive so there is

00:05:12,300 --> 00:05:18,900
such that can not be possible that a

00:05:16,260 --> 00:05:20,730
compromised archive presents two

00:05:18,900 --> 00:05:23,760
different versions of the release file

00:05:20,730 --> 00:05:29,580
to two different people right so we want

00:05:23,760 --> 00:05:32,910
the one globally unique view and once we

00:05:29,580 --> 00:05:36,200
if we can achieve this we can exploit

00:05:32,910 --> 00:05:39,330
this globally a unique view for other

00:05:36,200 --> 00:05:42,960
purposes so for example we could check

00:05:39,330 --> 00:05:44,070
that the archive has only included

00:05:42,960 --> 00:05:47,150
packages that

00:05:44,070 --> 00:05:50,940
reproducibly and hold it accountable

00:05:47,150 --> 00:05:55,410
accordingly okay so this is the core

00:05:50,940 --> 00:05:57,870
idea we want this unique view for this

00:05:55,410 --> 00:06:02,430
we have a lock server which maintains a

00:05:57,870 --> 00:06:05,400
hash tree over all the metadata and

00:06:02,430 --> 00:06:08,460
source code that the archive ever issued

00:06:05,400 --> 00:06:10,560
so if anything's angry please just feel

00:06:08,460 --> 00:06:11,970
free to interrupt it and we just have to

00:06:10,560 --> 00:06:13,950
say I have to take care of the

00:06:11,970 --> 00:06:17,490
microphone and who has the microphone

00:06:13,950 --> 00:06:25,940
right now you have it okay so just raise

00:06:17,490 --> 00:06:30,100
a hand please all right yeah what if the

00:06:25,940 --> 00:06:33,189
compromised archive presents korean

00:06:30,100 --> 00:06:33,189
[Music]

00:06:34,130 --> 00:06:42,810
other file yeah so the way that we

00:06:38,010 --> 00:06:47,910
detect this is the following the locks

00:06:42,810 --> 00:06:52,410
server provides proofs to the client so

00:06:47,910 --> 00:06:55,320
the client in our case apt needs to do

00:06:52,410 --> 00:06:58,380
some additional checks and one of the

00:06:55,320 --> 00:07:01,140
checks that it does is the first one

00:06:58,380 --> 00:07:05,370
here it checks that the release file is

00:07:01,140 --> 00:07:11,580
included in the lock this address you a

00:07:05,370 --> 00:07:14,940
question yep okay so so the lock server

00:07:11,580 --> 00:07:18,000
and the client need to communicate but

00:07:14,940 --> 00:07:21,300
the good thing is the content of this

00:07:18,000 --> 00:07:23,490
communication is known so we can have

00:07:21,300 --> 00:07:27,030
the lock server prepare it basically in

00:07:23,490 --> 00:07:31,980
advance and put it onto the mirror

00:07:27,030 --> 00:07:36,360
network as well so right right now the

00:07:31,980 --> 00:07:38,670
idea is that we can for example for one

00:07:36,360 --> 00:07:41,730
for the time span of one year put all

00:07:38,670 --> 00:07:43,680
the required proofs on the mirror

00:07:41,730 --> 00:07:47,070
network it's not too large it's not too

00:07:43,680 --> 00:07:50,180
many files and then only if I haven't

00:07:47,070 --> 00:07:52,639
updated my computer in say over

00:07:50,180 --> 00:07:56,139
yeah I actually need to have additional

00:07:52,639 --> 00:07:59,600
network traffic and contact the locks of

00:07:56,139 --> 00:08:06,139
directly to retrieve those kinds of

00:07:59,600 --> 00:08:11,300
proofs such as the inclusion in of the

00:08:06,139 --> 00:08:14,300
release file okay a second check of it

00:08:11,300 --> 00:08:17,600
we can let the client thus against the

00:08:14,300 --> 00:08:20,539
lock is to check that the lock provides

00:08:17,600 --> 00:08:25,820
us with a consistent history so the

00:08:20,539 --> 00:08:27,860
locks of maintains its list of release

00:08:25,820 --> 00:08:31,699
files metadata and the source packages

00:08:27,860 --> 00:08:35,690
append only so there is no manipulation

00:08:31,699 --> 00:08:40,279
of the history going on ok so that

00:08:35,690 --> 00:08:46,610
satisfies the needs of the apt client

00:08:40,279 --> 00:08:49,760
and then we are not quite done yet

00:08:46,610 --> 00:08:53,540
because all we have done so far is we

00:08:49,760 --> 00:08:55,339
have checked that the that the release

00:08:53,540 --> 00:08:57,650
file from which we determine the

00:08:55,339 --> 00:09:00,170
packages we can install is actually

00:08:57,650 --> 00:09:05,930
available in the locks we haven't

00:09:00,170 --> 00:09:08,420
checked yet that other suspicious things

00:09:05,930 --> 00:09:09,890
aren't going on so for example we

00:09:08,420 --> 00:09:12,920
haven't checked anything about the

00:09:09,890 --> 00:09:18,830
reproducibility property but now that we

00:09:12,920 --> 00:09:21,380
demand that all the package hashes and

00:09:18,830 --> 00:09:23,959
the source packages are included in this

00:09:21,380 --> 00:09:26,420
lock server we can go through this lock

00:09:23,959 --> 00:09:28,459
server which is what the monitor does it

00:09:26,420 --> 00:09:32,630
goes through the list maintained by the

00:09:28,459 --> 00:09:35,120
lock server and it will check a number

00:09:32,630 --> 00:09:36,950
of things for example it can verify the

00:09:35,120 --> 00:09:42,070
rapid usable applets

00:09:36,950 --> 00:09:47,000
property and the great thing is once we

00:09:42,070 --> 00:09:51,320
can do that we can provide an additional

00:09:47,000 --> 00:09:56,270
assurance to the users namely and we not

00:09:51,320 --> 00:09:58,900
only promise that the archive provides

00:09:56,270 --> 00:10:00,470
reproducible boots we also have a

00:09:58,900 --> 00:10:03,620
additional

00:10:00,470 --> 00:10:08,060
we have a additional check that is able

00:10:03,620 --> 00:10:12,730
to by going through the Lok Sabha is

00:10:08,060 --> 00:10:15,379
able to actually inspect all the

00:10:12,730 --> 00:10:18,649
packages and all the package versions

00:10:15,379 --> 00:10:21,800
that were ever or are published by the

00:10:18,649 --> 00:10:25,100
archive right so we don't just a query a

00:10:21,800 --> 00:10:27,290
mirror retrieve the packages from there

00:10:25,100 --> 00:10:32,110
and check reproducibility we rather

00:10:27,290 --> 00:10:35,629
check that we rather go to the auditable

00:10:32,110 --> 00:10:37,569
a list of all packages which is

00:10:35,629 --> 00:10:42,230
contained in the lock server and check

00:10:37,569 --> 00:10:46,970
there that we can reproduce it build all

00:10:42,230 --> 00:10:52,459
the packages okay so the monitor is

00:10:46,970 --> 00:10:54,769
pretty important here to do these kinds

00:10:52,459 --> 00:10:57,500
of checks the monitor also has to do

00:10:54,769 --> 00:10:59,930
other checks so for example it also

00:10:57,500 --> 00:11:02,360
maintained checks that the lock server

00:10:59,930 --> 00:11:07,220
maintains the cryptographic invariants

00:11:02,360 --> 00:11:09,500
such as maintaining the list of release

00:11:07,220 --> 00:11:10,519
files and source packages and so on in

00:11:09,500 --> 00:11:16,819
an append-only

00:11:10,519 --> 00:11:22,149
manner okay so what questions do you

00:11:16,819 --> 00:11:22,149
have so far regarding the architecture

00:11:27,610 --> 00:11:32,570
[Laughter]

00:11:35,709 --> 00:11:41,089
so I didn't quite understand what

00:11:38,209 --> 00:11:43,339
problem this design tries to solve is it

00:11:41,089 --> 00:11:45,889
that you don't you are afraid that the

00:11:43,339 --> 00:11:49,399
archive signing key might leak and you

00:11:45,889 --> 00:11:51,230
have two different binaries that are

00:11:49,399 --> 00:11:55,579
signed with the correct key yes so

00:11:51,230 --> 00:12:02,540
compromise the archive is certainly one

00:11:55,579 --> 00:12:06,170
of the concerns that we have so first of

00:12:02,540 --> 00:12:09,439
all what we want to do is we want to

00:12:06,170 --> 00:12:12,259
make sure that everybody has the same

00:12:09,439 --> 00:12:13,139
view on the archive because that takes

00:12:12,259 --> 00:12:15,149
care of an

00:12:13,139 --> 00:12:19,139
Tech or then we can detect an attack

00:12:15,149 --> 00:12:24,980
where a compromised archive tries to

00:12:19,139 --> 00:12:29,069
attack a certain subset of Debian users

00:12:24,980 --> 00:12:30,809
okay does it make sense in my idea the

00:12:29,069 --> 00:12:33,689
solution should be something on the

00:12:30,809 --> 00:12:35,970
client side that the clients can in a

00:12:33,689 --> 00:12:36,829
peer-to-peer fashion share what they are

00:12:35,970 --> 00:12:41,329
seeing

00:12:36,829 --> 00:12:43,619
that's certainly also a possible design

00:12:41,329 --> 00:12:46,559
approach but it brings other

00:12:43,619 --> 00:12:49,799
difficulties with it so now you are

00:12:46,559 --> 00:12:52,259
trying to add to prices have trashed the

00:12:49,799 --> 00:12:54,779
archive and a separate log server and

00:12:52,259 --> 00:12:56,669
then assume I let those people who have

00:12:54,779 --> 00:12:59,489
access to compromised the archive key

00:12:56,669 --> 00:13:01,470
would not be able to compromise the

00:12:59,489 --> 00:13:04,980
yamlok sure yes

00:13:01,470 --> 00:13:07,619
so the that's a very good point the good

00:13:04,980 --> 00:13:10,169
thing about the lock service that we

00:13:07,619 --> 00:13:13,319
need not trust that it operates

00:13:10,169 --> 00:13:16,139
correctly because we can verify the

00:13:13,319 --> 00:13:19,769
correct operation from the outside and

00:13:16,139 --> 00:13:23,149
the mechanism that's used to do that is

00:13:19,769 --> 00:13:28,110
the hash tree that the locks of

00:13:23,149 --> 00:13:31,439
maintains because then it can it can

00:13:28,110 --> 00:13:34,649
provide a proofs to the client so for

00:13:31,439 --> 00:13:37,619
example if a client wants to ensure that

00:13:34,649 --> 00:13:41,610
the release file it observed on the

00:13:37,619 --> 00:13:45,839
mirror is actually a contained in the

00:13:41,610 --> 00:13:48,360
Lok Sabha the Lok Sabha can provide a an

00:13:45,839 --> 00:13:51,179
efficient cryptographic proof of that

00:13:48,360 --> 00:13:55,799
effect so we needn't trust that what the

00:13:51,179 --> 00:13:57,749
lock server does is correct we can check

00:13:55,799 --> 00:14:03,329
it from the outside or ask we lock

00:13:57,749 --> 00:14:05,899
server to prove it to us so the Lok

00:14:03,329 --> 00:14:09,139
Sabha is generally assumed to be

00:14:05,899 --> 00:14:14,999
benevolent in the sense that we think it

00:14:09,139 --> 00:14:18,649
tries to cooperate but we don't trust it

00:14:14,999 --> 00:14:22,110
from a security standpoint that it is

00:14:18,649 --> 00:14:24,090
always benevolent so if it acts in a

00:14:22,110 --> 00:14:30,480
malicious way we would

00:14:24,090 --> 00:14:32,310
need to detect that does that help

00:14:30,480 --> 00:14:38,490
address your concern

00:14:32,310 --> 00:14:41,390
yes thanks okay

00:14:38,490 --> 00:14:42,570
what other questions regarding the

00:14:41,390 --> 00:14:46,110
architecture

00:14:42,570 --> 00:14:49,790
do you have yes so could you could we

00:14:46,110 --> 00:14:49,790
get the microphone over here please

00:14:51,950 --> 00:15:03,270
thank you check in this picture the

00:14:59,130 --> 00:15:04,980
metadata will only go to the log server

00:15:03,270 --> 00:15:06,960
or the client side

00:15:04,980 --> 00:15:12,780
we'll take this metadata to check the

00:15:06,960 --> 00:15:16,200
the how can I say the consistence of the

00:15:12,780 --> 00:15:18,240
archive on the empty server did this

00:15:16,200 --> 00:15:22,170
metal go to the only two deluged server

00:15:18,240 --> 00:15:25,710
go to the client to the metadata here is

00:15:22,170 --> 00:15:28,860
the existing metadata this means the in

00:15:25,710 --> 00:15:32,190
release file the packages that accept

00:15:28,860 --> 00:15:36,060
file and so so on all the stuff that you

00:15:32,190 --> 00:15:38,250
find on the mirror these are the

00:15:36,060 --> 00:15:41,280
metadata files I'm referring to here and

00:15:38,250 --> 00:15:44,339
these are also downloaded by the client

00:15:41,280 --> 00:15:46,170
of course if you do an update you

00:15:44,339 --> 00:15:47,700
download these metadata files and then

00:15:46,170 --> 00:15:51,150
up to we will tell you I have these

00:15:47,700 --> 00:15:53,220
packages available and so these are the

00:15:51,150 --> 00:15:56,160
files that are submitted into the lock

00:15:53,220 --> 00:16:00,540
server and the client will now check

00:15:56,160 --> 00:16:04,490
that the release file here is included

00:16:00,540 --> 00:16:04,490
in the lock server

00:16:11,399 --> 00:16:20,950
just another question about software

00:16:17,399 --> 00:16:25,139
transparency it's about how we can

00:16:20,950 --> 00:16:29,440
detect the situation when mantener

00:16:25,139 --> 00:16:32,709
decided to become a bad guy when decided

00:16:29,440 --> 00:16:36,730
to become sorry a bad guy yeah he

00:16:32,709 --> 00:16:43,750
decided to inject to the source package

00:16:36,730 --> 00:16:49,769
any application code which doing

00:16:43,750 --> 00:16:54,990
something for what he received the money

00:16:49,769 --> 00:16:57,790
okay so if the if a malicious maintainer

00:16:54,990 --> 00:17:01,149
submits this malicious code in source

00:16:57,790 --> 00:17:04,839
code and we just compiled a binary from

00:17:01,149 --> 00:17:08,140
it there's nothing we can detect what we

00:17:04,839 --> 00:17:11,439
can do is attacks where the source

00:17:08,140 --> 00:17:14,110
package and the binary package don't fit

00:17:11,439 --> 00:17:17,049
together because reproducibility doesn't

00:17:14,110 --> 00:17:21,730
work for example or because the binary

00:17:17,049 --> 00:17:24,429
package was manipulated in some way this

00:17:21,730 --> 00:17:28,000
would be something we can detect in this

00:17:24,429 --> 00:17:32,830
design so we don't have any many

00:17:28,000 --> 00:17:34,690
tourists or detectors which can detect

00:17:32,830 --> 00:17:38,530
this situation well the fact that

00:17:34,690 --> 00:17:40,630
software is malicious is nothing that we

00:17:38,530 --> 00:17:44,650
can detect we can only detect

00:17:40,630 --> 00:17:48,370
misbehavior in the updating or in the

00:17:44,650 --> 00:17:52,090
release infrastructure my question not

00:17:48,370 --> 00:17:56,140
for maintaining a base project but for

00:17:52,090 --> 00:18:01,169
the maintainer of the package so we

00:17:56,140 --> 00:18:04,799
don't have any detectors which can base

00:18:01,169 --> 00:18:10,630
mainline project in open source and

00:18:04,799 --> 00:18:15,460
which changes Montanaro done in this

00:18:10,630 --> 00:18:17,910
package I'm sorry I'm afraid I don't

00:18:15,460 --> 00:18:17,910
think I have

00:18:17,950 --> 00:18:22,510
for example we have a gene project

00:18:20,560 --> 00:18:24,520
open-source project and we have

00:18:22,510 --> 00:18:28,210
maintainer a Debian maintainer each

00:18:24,520 --> 00:18:32,290
supported this project can we detect

00:18:28,210 --> 00:18:35,340
situation when Debian maintainer does

00:18:32,290 --> 00:18:39,160
changes in the source code which are not

00:18:35,340 --> 00:18:42,580
fit to the mainline open-source program

00:18:39,160 --> 00:18:44,410
so let me rephrase the question to make

00:18:42,580 --> 00:18:46,690
sure I understood so your question is as

00:18:44,410 --> 00:18:49,330
an upstream can I check that the Debian

00:18:46,690 --> 00:18:52,840
maintainer hasn't done any modifications

00:18:49,330 --> 00:18:56,110
yes yeah okay so in this model the way

00:18:52,840 --> 00:18:59,890
that it would work is the following you

00:18:56,110 --> 00:19:02,230
run one of these monitors that retrieves

00:18:59,890 --> 00:19:05,410
all incoming releases and incoming

00:19:02,230 --> 00:19:08,560
source packages and you have it watch

00:19:05,410 --> 00:19:13,000
for your package specifically and check

00:19:08,560 --> 00:19:17,770
that the source code matches what you

00:19:13,000 --> 00:19:21,130
expect it to be however in a debian

00:19:17,770 --> 00:19:24,520
package you the maintainer can also add

00:19:21,130 --> 00:19:28,620
patches for example or there can be

00:19:24,520 --> 00:19:31,210
maintainer scripts which do some

00:19:28,620 --> 00:19:35,380
manipulation of something they can do

00:19:31,210 --> 00:19:38,260
anything so if these are present and we

00:19:35,380 --> 00:19:41,890
you would need to check them by hand but

00:19:38,260 --> 00:19:45,340
you can the fact that the source code

00:19:41,890 --> 00:19:46,690
itself looks different than your your

00:19:45,340 --> 00:19:47,680
upstream release that's something you

00:19:46,690 --> 00:19:53,320
could verify

00:19:47,680 --> 00:19:56,830
oh it's manual operation yeah no

00:19:53,320 --> 00:20:00,820
optimization detection it depends if the

00:19:56,830 --> 00:20:05,850
package is very simple and there are no

00:20:00,820 --> 00:20:08,790
Debian maintainer patches and no no

00:20:05,850 --> 00:20:11,410
scripts that can manipulate anything I

00:20:08,790 --> 00:20:13,570
it can be done automatically and if

00:20:11,410 --> 00:20:16,050
that's not the case then you have some

00:20:13,570 --> 00:20:19,270
code that does something and this will

00:20:16,050 --> 00:20:21,520
always need manual inspection but you

00:20:19,270 --> 00:20:25,180
could for example be alerted once this

00:20:21,520 --> 00:20:27,040
is the case and acknowledge the check

00:20:25,180 --> 00:20:30,430
yeah so that's something you could

00:20:27,040 --> 00:20:32,110
realize with this system but it might

00:20:30,430 --> 00:20:41,150
not be a

00:20:32,110 --> 00:20:47,540
functionality or go away can you hand

00:20:41,150 --> 00:20:49,130
over the microphone please sir related

00:20:47,540 --> 00:20:52,790
to this there's one check that we don't

00:20:49,130 --> 00:20:56,450
currently have so that if source code so

00:20:52,790 --> 00:20:59,240
if the Debian package does use git or

00:20:56,450 --> 00:21:01,790
some other source control and then

00:20:59,240 --> 00:21:04,250
something is uploaded but that was not

00:21:01,790 --> 00:21:05,990
committed to the source control then

00:21:04,250 --> 00:21:09,110
there's currently no check on that

00:21:05,990 --> 00:21:11,210
there's there's a check on tracker that

00:21:09,110 --> 00:21:13,490
if you have comets that have not been

00:21:11,210 --> 00:21:20,330
uploaded but the other way around

00:21:13,490 --> 00:21:22,430
there's no check currently this is a

00:21:20,330 --> 00:21:25,690
security issue and it's also a quality

00:21:22,430 --> 00:21:30,320
issue that it's packages that have

00:21:25,690 --> 00:21:32,810
source control still might get manual

00:21:30,320 --> 00:21:37,600
uploads by somebody mm-hmm that's not

00:21:32,810 --> 00:21:39,530
stored in the repository might not be

00:21:37,600 --> 00:21:40,640
reflecting what's currently in the

00:21:39,530 --> 00:21:44,150
archive is that correct

00:21:40,640 --> 00:21:49,730
yeah there bein packaging repository for

00:21:44,150 --> 00:21:51,440
a single package might not have

00:21:49,730 --> 00:21:55,490
everything that was uploaded to the

00:21:51,440 --> 00:21:59,360
archive okay yeah so that's case I

00:21:55,490 --> 00:22:03,020
haven't considered so far so I've

00:21:59,360 --> 00:22:04,760
written it down as something you could

00:22:03,020 --> 00:22:07,880
for example if you're using it build

00:22:04,760 --> 00:22:10,340
package which always tags what you

00:22:07,880 --> 00:22:13,400
uploaded and you could compare the exact

00:22:10,340 --> 00:22:15,320
tag to what is the source uploaded to

00:22:13,400 --> 00:22:16,820
the archive if it's the same or not

00:22:15,320 --> 00:22:20,590
currently there's nothing checking this

00:22:16,820 --> 00:22:20,590
yeah that's a great idea

00:22:33,740 --> 00:22:41,270
okay but other questions do you have

00:22:37,010 --> 00:22:43,870
regarding the architecture proposal so

00:22:41,270 --> 00:22:48,500
who's gonna maintain this log server

00:22:43,870 --> 00:22:53,240
yeah so the Lok Sabha would be something

00:22:48,500 --> 00:22:56,690
that is operated within Debian because

00:22:53,240 --> 00:23:00,290
it needs to be reliable right so the

00:22:56,690 --> 00:23:03,440
archive is submitting a stuff into you

00:23:00,290 --> 00:23:07,220
can impact the proofs that it wants to

00:23:03,440 --> 00:23:09,470
put onto the mirror network so it needs

00:23:07,220 --> 00:23:19,700
to be reliable so we would need to

00:23:09,470 --> 00:23:24,740
maintain it yeah so right now in the

00:23:19,700 --> 00:23:29,690
implementation the what I've done is

00:23:24,740 --> 00:23:35,650
I've used the trillion generic Lok Sabha

00:23:29,690 --> 00:23:39,460
and written a front-end so we have a

00:23:35,650 --> 00:23:44,480
Maria DP database that stores the

00:23:39,460 --> 00:23:53,060
trillion information and HDPE front-end

00:23:44,480 --> 00:23:56,810
that speaks a simple protocol and there

00:23:53,060 --> 00:24:00,350
is also another demon that's provided by

00:23:56,810 --> 00:24:10,900
trillion which takes care of signing a

00:24:00,350 --> 00:24:13,850
sequencing and signing stuff yep so I'm

00:24:10,900 --> 00:24:19,220
running a lock server that I'm feeding

00:24:13,850 --> 00:24:22,280
from the mirror Network so the main

00:24:19,220 --> 00:24:24,950
thing it does it's it's growing in this

00:24:22,280 --> 00:24:28,430
space because sauce packages new source

00:24:24,950 --> 00:24:32,740
packages edit sometimes yeah otherwise

00:24:28,430 --> 00:24:32,740
it's relatively unspectacular

00:24:39,630 --> 00:24:42,630
yep

00:24:45,610 --> 00:24:52,340
feel free to end around the micro

00:24:47,840 --> 00:24:54,590
microphone yourself so that could you

00:24:52,340 --> 00:24:58,580
give more detail how does the log server

00:24:54,590 --> 00:25:03,020
cryptographically prove that the archive

00:24:58,580 --> 00:25:06,620
is correct the client only has one key

00:25:03,020 --> 00:25:10,370
or several keys for the air crash right

00:25:06,620 --> 00:25:12,560
yeah and if that key is compromised how

00:25:10,370 --> 00:25:15,860
can the work sure prove anything

00:25:12,560 --> 00:25:20,150
yeah so we need to be very careful about

00:25:15,860 --> 00:25:23,990
what we assume the lock server can do so

00:25:20,150 --> 00:25:26,600
first of all the client here also knows

00:25:23,990 --> 00:25:29,330
a public key of the lock server so the

00:25:26,600 --> 00:25:33,850
lock server can sign stuff and the stuff

00:25:29,330 --> 00:25:41,320
that it science is most importantly the

00:25:33,850 --> 00:25:45,620
root of the hash tree so if we look at a

00:25:41,320 --> 00:25:48,110
if we look at the list that the lock

00:25:45,620 --> 00:25:51,530
server maintains our squares here are

00:25:48,110 --> 00:25:54,640
things like the release fire packages

00:25:51,530 --> 00:25:58,970
that accept the files that make up the

00:25:54,640 --> 00:26:01,430
source packages and we now the lock

00:25:58,970 --> 00:26:05,360
server now constructs a hash tree over

00:26:01,430 --> 00:26:08,120
this so the label of each inner node is

00:26:05,360 --> 00:26:12,830
the cryptographic hash of its children

00:26:08,120 --> 00:26:21,800
so if we know this hash value here the

00:26:12,830 --> 00:26:25,420
the root hash we can we can identify all

00:26:21,800 --> 00:26:30,980
the items that make up the lists right

00:26:25,420 --> 00:26:34,670
okay so what is done now is the lock

00:26:30,980 --> 00:26:37,910
server signs this root here and thereby

00:26:34,670 --> 00:26:43,880
it states ok for this list size list

00:26:37,910 --> 00:26:47,150
size 8 I think here I have computed this

00:26:43,880 --> 00:26:50,810
root hash and I'm going to assign it so

00:26:47,150 --> 00:26:53,030
everybody who sees that root hash can

00:26:50,810 --> 00:26:56,770
hold the lock server accountable this is

00:26:53,030 --> 00:27:00,730
what the lock services at a generation a

00:26:56,770 --> 00:27:04,059
the elements that make up the list and

00:27:00,730 --> 00:27:08,830
the thing that we one of the things that

00:27:04,059 --> 00:27:09,399
the client can do now is to ask the lock

00:27:08,830 --> 00:27:12,549
server

00:27:09,399 --> 00:27:16,330
can you please convince me that this

00:27:12,549 --> 00:27:19,570
release file I'm I have here is actually

00:27:16,330 --> 00:27:22,840
contained in this list meaning it is

00:27:19,570 --> 00:27:24,700
present in the Lok Sabha and the Lok

00:27:22,840 --> 00:27:30,870
Sabha would do that by providing these

00:27:24,700 --> 00:27:35,380
three notes marked in grey here and

00:27:30,870 --> 00:27:38,500
using these three notes the client can

00:27:35,380 --> 00:27:42,190
recompute the root hash and thereby

00:27:38,500 --> 00:27:45,070
convince themselves that yes the release

00:27:42,190 --> 00:27:50,260
file here is actually included in this

00:27:45,070 --> 00:27:53,200
list so this is a kind of thing the lock

00:27:50,260 --> 00:27:57,250
server can communicate to the client

00:27:53,200 --> 00:28:00,580
client this is help you understand so

00:27:57,250 --> 00:28:02,350
the client has a separate key for the

00:28:00,580 --> 00:28:04,480
lock server yes and if that key is

00:28:02,350 --> 00:28:08,440
compromised then this mechanism doesn't

00:28:04,480 --> 00:28:11,169
work anymore if this key is compromised

00:28:08,440 --> 00:28:12,880
well the question is what what is the

00:28:11,169 --> 00:28:20,559
attack that is happening with the

00:28:12,880 --> 00:28:23,409
compromised the key we make up a fake

00:28:20,559 --> 00:28:27,820
lock server that tells that our

00:28:23,409 --> 00:28:30,250
compromised archive is okay and the

00:28:27,820 --> 00:28:34,809
client must maintain more keys on his

00:28:30,250 --> 00:28:36,820
side so the I mean the lock server

00:28:34,809 --> 00:28:40,450
doesn't make any statement about the

00:28:36,820 --> 00:28:46,450
archive it only says yes I have seen

00:28:40,450 --> 00:28:50,230
this release file so the Lok Sabha

00:28:46,450 --> 00:28:53,860
doesn't do any inspection or anything

00:28:50,230 --> 00:28:57,039
the lock server serves for us to be sure

00:28:53,860 --> 00:29:01,179
that we have a globally unique view so

00:28:57,039 --> 00:29:05,429
that there can be no release fires that

00:29:01,179 --> 00:29:05,429
we don't don't know about for example

00:29:06,809 --> 00:29:15,340
does that help you

00:29:10,080 --> 00:29:16,210
not sure okay we can go back to that

00:29:15,340 --> 00:29:18,460
later

00:29:16,210 --> 00:29:22,810
or perhaps you can ask your question

00:29:18,460 --> 00:29:25,800
another way so I can perhaps try to give

00:29:22,810 --> 00:29:25,800
a better answer to you

00:29:37,910 --> 00:29:43,710
you said you're already running your own

00:29:40,470 --> 00:29:45,809
log server and can you say something

00:29:43,710 --> 00:29:49,200
about the resource requirements both in

00:29:45,809 --> 00:29:54,110
bandwidth and CPU and memory and disk in

00:29:49,200 --> 00:29:58,730
yeah so what I've done previously is

00:29:54,110 --> 00:30:02,300
I've used two years of stretch during

00:29:58,730 --> 00:30:07,860
that was mostly during testing and that

00:30:02,300 --> 00:30:14,610
resulted in a disk usage of the lock

00:30:07,860 --> 00:30:16,770
server of 390 gigabytes or so so so

00:30:14,610 --> 00:30:19,170
that's two years during testing where

00:30:16,770 --> 00:30:21,420
packages are added

00:30:19,170 --> 00:30:24,420
I took the data from snapshots debian

00:30:21,420 --> 00:30:27,630
waka and basically replayed it so that's

00:30:24,420 --> 00:30:32,910
well it is this space but it seems to be

00:30:27,630 --> 00:30:36,330
a manageable amount the lock server

00:30:32,910 --> 00:30:39,059
accepts only write requests or

00:30:36,330 --> 00:30:41,670
submissions from the archive and well my

00:30:39,059 --> 00:30:43,980
lock server now from the mirror but in

00:30:41,670 --> 00:30:50,280
the debian case it won't only accept

00:30:43,980 --> 00:30:53,670
write access from the archive for so

00:30:50,280 --> 00:30:56,309
that's not a huge problem for us because

00:30:53,670 --> 00:30:58,580
we assume the archive doesn't it's not

00:30:56,309 --> 00:31:01,710
going to try to toss the lock server

00:30:58,580 --> 00:31:04,350
yeah was thinking more for on the client

00:31:01,710 --> 00:31:08,850
side and in terms of bandwidth and CPU

00:31:04,350 --> 00:31:12,030
and yeah okay so the clients we would

00:31:08,850 --> 00:31:14,130
probably try to make work in the

00:31:12,030 --> 00:31:16,980
following way so I mentioned here that

00:31:14,130 --> 00:31:19,470
the clients do two checks they check

00:31:16,980 --> 00:31:22,260
that the release 5 was included in the

00:31:19,470 --> 00:31:24,720
Lok Sabha and they check that the lock

00:31:22,260 --> 00:31:27,030
history is not committed so this one is

00:31:24,720 --> 00:31:29,090
called a inclusion proof and the second

00:31:27,030 --> 00:31:35,070
one is called a consistency proof and

00:31:29,090 --> 00:31:38,700
they all are just a list of tree hashes

00:31:35,070 --> 00:31:41,280
and true assigned tree roots so a

00:31:38,700 --> 00:31:44,960
another hash value and a signature and

00:31:41,280 --> 00:31:47,450
the tree size some meta information so

00:31:44,960 --> 00:31:50,120
this is all in the

00:31:47,450 --> 00:31:57,019
a few kilobytes range each of these

00:31:50,120 --> 00:31:59,929
proofs so the way that I would want to

00:31:57,019 --> 00:32:03,769
do it in the moment is when the archive

00:31:59,929 --> 00:32:05,690
submits something into the Lok Sabha it

00:32:03,769 --> 00:32:07,940
also retrieves the proofs that the

00:32:05,690 --> 00:32:12,919
clients are going to need and put them

00:32:07,940 --> 00:32:14,630
on the mirror network and we can so for

00:32:12,919 --> 00:32:16,639
each release you would have one of these

00:32:14,630 --> 00:32:19,309
inclusion proofs and we would need

00:32:16,639 --> 00:32:22,010
consistency proofs how many consistency

00:32:19,309 --> 00:32:24,860
proofs depends on how far we want to be

00:32:22,010 --> 00:32:27,289
able to go back basically so how many

00:32:24,860 --> 00:32:32,690
mirror palaces do we want to be able to

00:32:27,289 --> 00:32:36,789
go back and if we say a year that 360

00:32:32,690 --> 00:32:40,370
times four so that's a number of

00:32:36,789 --> 00:32:43,880
consistency proofs that we that we need

00:32:40,370 --> 00:32:45,649
to provide so like I don't know two

00:32:43,880 --> 00:32:50,120
thousand three thousands or something I

00:32:45,649 --> 00:32:52,460
think yeah it's the three hundred and

00:32:50,120 --> 00:32:54,679
fifty case or whatever the number

00:32:52,460 --> 00:32:57,649
actually was is that all architectures

00:32:54,679 --> 00:32:59,690
or a single architecture it's metadata

00:32:57,649 --> 00:33:03,740
and sauce packages so we don't store

00:32:59,690 --> 00:33:06,230
binary packages the reason is that here

00:33:03,740 --> 00:33:12,260
we assume all packages are reproducible

00:33:06,230 --> 00:33:17,059
and we can use we can rebuild yes to

00:33:12,260 --> 00:33:21,950
Vegas I'm looking forward into the

00:33:17,059 --> 00:33:25,519
future and we can rebuild and check that

00:33:21,950 --> 00:33:27,440
the hash of the binary package matches I

00:33:25,519 --> 00:33:30,529
mean for starting out of course first

00:33:27,440 --> 00:33:31,940
the archive needs to be rebuilt so that

00:33:30,529 --> 00:33:35,210
we have the build and for files to

00:33:31,940 --> 00:33:37,269
rebuild everything and then we would of

00:33:35,210 --> 00:33:41,120
course have to start out with a

00:33:37,269 --> 00:33:46,850
blacklist or whitelist of packages that

00:33:41,120 --> 00:33:49,669
we can check in this way well the size

00:33:46,850 --> 00:33:52,190
of that forever be growing or are you

00:33:49,669 --> 00:33:55,250
looking at doing rotation on a per

00:33:52,190 --> 00:33:57,830
release basis for instance because I

00:33:55,250 --> 00:33:59,840
mean 350 cases by itself might not be a

00:33:57,830 --> 00:34:01,220
problem but when it goes into terabytes

00:33:59,840 --> 00:34:05,750
and terabytes its kind

00:34:01,220 --> 00:34:11,060
annoying to shuffle around yeah so I

00:34:05,750 --> 00:34:14,120
don't have a specific specific proposal

00:34:11,060 --> 00:34:18,230
to do that the thing they do in

00:34:14,120 --> 00:34:20,480
certificate transparency is they have

00:34:18,230 --> 00:34:24,440
lock service for different years and

00:34:20,480 --> 00:34:28,760
then keep the old ones frozen and switch

00:34:24,440 --> 00:34:30,650
the submission to the new lock server so

00:34:28,760 --> 00:34:33,820
something like that could probably be

00:34:30,650 --> 00:34:36,530
done but needs some additional logic

00:34:33,820 --> 00:34:40,040
yeah but I don't have a super specific

00:34:36,530 --> 00:34:42,100
proposal to address that yeah okay thank

00:34:40,040 --> 00:34:42,100
you

00:34:51,150 --> 00:34:58,790
is somebody watching the IRC is anybody

00:34:54,150 --> 00:34:58,790
in Iasi asking something

00:35:13,850 --> 00:35:22,460
okay yeah so if you don't have any

00:35:17,360 --> 00:35:25,450
questions right now we could I could

00:35:22,460 --> 00:35:31,040
quickly tell you what the implementation

00:35:25,450 --> 00:35:34,130
looks like right now so as I said

00:35:31,040 --> 00:35:37,040
there's a mirror that provides these

00:35:34,130 --> 00:35:41,870
proofs as I imagined they could be

00:35:37,040 --> 00:35:43,880
output by attack I'm working on dark

00:35:41,870 --> 00:35:46,970
patches to do this lock submission

00:35:43,880 --> 00:35:53,960
unfortunately I haven't finished those

00:35:46,970 --> 00:35:56,300
yet and the the Lok Sabha of which I've

00:35:53,960 --> 00:36:01,100
already done one rewrite because it

00:35:56,300 --> 00:36:02,540
turns out not all the ideas I had in the

00:36:01,100 --> 00:36:08,120
beginning

00:36:02,540 --> 00:36:12,710
super smart the main things that are

00:36:08,120 --> 00:36:16,280
missing up integration so we would need

00:36:12,710 --> 00:36:18,050
to teach up as I see it two things first

00:36:16,280 --> 00:36:19,640
of all we need to teach it to retrieve

00:36:18,050 --> 00:36:22,160
additional fires which are not covered

00:36:19,640 --> 00:36:24,350
by the release fire because the proof

00:36:22,160 --> 00:36:27,620
files cannot by definition be covered by

00:36:24,350 --> 00:36:31,940
the release fire that's one thing and we

00:36:27,620 --> 00:36:36,380
would need a mechanism in up to do an

00:36:31,940 --> 00:36:39,980
additional verification so for example

00:36:36,380 --> 00:36:42,440
by extending the JSON RPC interface such

00:36:39,980 --> 00:36:45,980
that it would also be called when a

00:36:42,440 --> 00:36:48,860
release file is downloaded so we could

00:36:45,980 --> 00:36:53,600
for example first do the usual GP cheat

00:36:48,860 --> 00:36:56,870
check and then afterwards check the lock

00:36:53,600 --> 00:36:59,300
proofs or I used the JSON RPC interface

00:36:56,870 --> 00:37:01,550
to have the lock proofs checked and then

00:36:59,300 --> 00:37:05,870
depending on the result success or

00:37:01,550 --> 00:37:11,290
failure have the release file accepted

00:37:05,870 --> 00:37:16,160
or rejected so that's one thing and the

00:37:11,290 --> 00:37:17,960
other thing is the mirror sorry the

00:37:16,160 --> 00:37:21,260
monitor component which is responsible

00:37:17,960 --> 00:37:23,750
for investigating all this stuff I have

00:37:21,260 --> 00:37:25,760
a prototype that has all the

00:37:23,750 --> 00:37:26,870
cryptographic verifications and a bunch

00:37:25,760 --> 00:37:30,510
of

00:37:26,870 --> 00:37:33,240
analysis of the meta data produced by

00:37:30,510 --> 00:37:37,110
the archives such as we're all versions

00:37:33,240 --> 00:37:40,290
correctly incremented at all times is a

00:37:37,110 --> 00:37:44,220
sauce package available for this binary

00:37:40,290 --> 00:37:46,370
package and so on but that needs to be

00:37:44,220 --> 00:37:50,370
done for the current locks of

00:37:46,370 --> 00:38:03,180
implementation so the prototype needs to

00:37:50,370 --> 00:38:07,530
be written for the monitor yes we have a

00:38:03,180 --> 00:38:09,540
question from ILC if you are storing

00:38:07,530 --> 00:38:11,730
source packages to this break if one has

00:38:09,540 --> 00:38:14,280
to be removed for instance if it is fun

00:38:11,730 --> 00:38:17,910
to be illegal for copyright reasons yes

00:38:14,280 --> 00:38:20,340
so the current implementation does not

00:38:17,910 --> 00:38:23,730
do that the way that we would do it is

00:38:20,340 --> 00:38:26,220
to remove it from the lock server or

00:38:23,730 --> 00:38:31,080
just have the lock server not offer it

00:38:26,220 --> 00:38:35,070
for download and then put into the lock

00:38:31,080 --> 00:38:41,810
server a statement that this leaf of the

00:38:35,070 --> 00:38:44,880
tree had to be removed so that the code

00:38:41,810 --> 00:38:47,010
doesn't choke on it and we have locked

00:38:44,880 --> 00:38:51,020
and then we have documented the fact

00:38:47,010 --> 00:38:51,020
that it had to be removed

00:39:08,590 --> 00:39:15,640
yes I think we do have a little bit more

00:39:11,900 --> 00:39:15,640
time five minutes

00:39:16,300 --> 00:39:25,640
when do you expect this technique to be

00:39:20,800 --> 00:39:27,620
to make its way into Debian well that's

00:39:25,640 --> 00:39:33,350
a good question because it depends on

00:39:27,620 --> 00:39:37,730
really really many people so FTP master

00:39:33,350 --> 00:39:40,670
needs to be happy with doing the

00:39:37,730 --> 00:39:43,490
submission presumably the essay needs to

00:39:40,670 --> 00:39:46,700
be happy with running the Lok Sabha and

00:39:43,490 --> 00:39:51,980
the app maintainer needs to be happy

00:39:46,700 --> 00:39:57,470
with the way that the verification is

00:39:51,980 --> 00:40:04,190
done estimate I don't know what do you

00:39:57,470 --> 00:40:08,480
hope for from from my point of view it

00:40:04,190 --> 00:40:11,060
also depends on how much progress I'm

00:40:08,480 --> 00:40:14,120
making with the programming of the

00:40:11,060 --> 00:40:17,660
components because they have to exist

00:40:14,120 --> 00:40:25,720
first such that I have a proposal that

00:40:17,660 --> 00:40:25,720
people can suggest improvements to okay

00:40:27,910 --> 00:40:33,950
so what if you would just extend up to

00:40:31,090 --> 00:40:37,090
have some kind of distributed blockchain

00:40:33,950 --> 00:40:41,090
so that the apt clients would compare

00:40:37,090 --> 00:40:43,880
what what what are the hashes of the

00:40:41,090 --> 00:40:45,640
relays files they have been downloading

00:40:43,880 --> 00:40:48,530
and maybe add that to some global

00:40:45,640 --> 00:40:56,000
blockchain so instead of having a

00:40:48,530 --> 00:40:59,120
separate log server so there are

00:40:56,000 --> 00:41:02,200
proposals that go into this direction if

00:40:59,120 --> 00:41:06,590
you're interested in that so I think the

00:41:02,200 --> 00:41:09,500
work is called contour I don't have the

00:41:06,590 --> 00:41:12,320
exact citation here I'm afraid but I

00:41:09,500 --> 00:41:14,650
think you would be able to find it if

00:41:12,320 --> 00:41:17,590
you look at that so the reason why I

00:41:14,650 --> 00:41:21,110
didn't follow that approach in the

00:41:17,590 --> 00:41:25,990
design is that it needs all

00:41:21,110 --> 00:41:31,130
the apt installations to run networking

00:41:25,990 --> 00:41:34,370
code that does lots of things they need

00:41:31,130 --> 00:41:36,470
to communicate a lot with other apt

00:41:34,370 --> 00:41:41,030
clients and these are all things that

00:41:36,470 --> 00:41:46,270
are not done today so basically I have

00:41:41,030 --> 00:41:50,410
tried to use the lowest complexity

00:41:46,270 --> 00:41:52,640
approach and also for all things

00:41:50,410 --> 00:41:58,910
blockchain or distributed if you have

00:41:52,640 --> 00:42:02,320
proof of work that presents a whole

00:41:58,910 --> 00:42:06,550
problem by itself because you need to

00:42:02,320 --> 00:42:11,050
consume energy in order to achieve

00:42:06,550 --> 00:42:16,310
security such as providing the globally

00:42:11,050 --> 00:42:19,400
unique view and this is something that

00:42:16,310 --> 00:42:22,190
we can achieve without spending this

00:42:19,400 --> 00:42:24,670
energy by using this more centralized

00:42:22,190 --> 00:42:27,980
approach which also fits well with the

00:42:24,670 --> 00:42:30,070
model that distributions work in right

00:42:27,980 --> 00:42:34,370
because we already have a centralized

00:42:30,070 --> 00:42:40,070
archive with a CDN so adding another

00:42:34,370 --> 00:42:53,360
central component works I think really

00:42:40,070 --> 00:42:55,940
well ok given that the point is not to

00:42:53,360 --> 00:42:59,600
have a chive and lock be compromised

00:42:55,940 --> 00:43:02,860
together would anyone but DSA be better

00:42:59,600 --> 00:43:09,730
can there be multiple lock servers

00:43:02,860 --> 00:43:14,090
embalmer risks so the that's an

00:43:09,730 --> 00:43:18,380
interesting point there can be multiple

00:43:14,090 --> 00:43:22,310
lock service and the approach that I'm

00:43:18,380 --> 00:43:26,120
hoping for is the following so in the

00:43:22,310 --> 00:43:30,080
case that the lock server tries to

00:43:26,120 --> 00:43:33,900
present different views on the tree in

00:43:30,080 --> 00:43:36,310
cooperation with a malicious archive

00:43:33,900 --> 00:43:37,900
right now in the design I presented this

00:43:36,310 --> 00:43:41,470
kind of attack would work and we

00:43:37,900 --> 00:43:44,530
couldn't do anything against it and I

00:43:41,470 --> 00:43:49,030
think the only way to get around this is

00:43:44,530 --> 00:43:50,820
if there is a third party run block so

00:43:49,030 --> 00:43:53,910
for example involved it's not

00:43:50,820 --> 00:43:56,110
compromised right if we assume one

00:43:53,910 --> 00:43:58,720
organization's administration team is

00:43:56,110 --> 00:44:01,630
compromised then all the servers run

00:43:58,720 --> 00:44:03,970
there can be compromised so we need

00:44:01,630 --> 00:44:07,630
something from the outside and what I'm

00:44:03,970 --> 00:44:09,460
hoping for is in certificate

00:44:07,630 --> 00:44:12,120
transparency this problem isn't solved

00:44:09,460 --> 00:44:16,750
as well right now so there are several

00:44:12,120 --> 00:44:21,220
proposals I also have some proposals and

00:44:16,750 --> 00:44:24,480
the one that I'm hoping for is that we

00:44:21,220 --> 00:44:27,760
can perhaps in that we can perhaps once

00:44:24,480 --> 00:44:29,440
certificate transparency locks are going

00:44:27,760 --> 00:44:31,560
to solve this problem that we can use

00:44:29,440 --> 00:44:34,690
the solution so certificate transparency

00:44:31,560 --> 00:44:36,940
locks aren't usable for our purpose for

00:44:34,690 --> 00:44:39,940
a number of reason but my hope is that

00:44:36,940 --> 00:44:43,450
for the purpose of defeating this kind

00:44:39,940 --> 00:44:46,300
of attack we can actually cooperate with

00:44:43,450 --> 00:44:49,090
them and the way that it would work is

00:44:46,300 --> 00:44:54,700
that we have our lock server submit the

00:44:49,090 --> 00:44:57,520
three routes into a into a lock server

00:44:54,700 --> 00:44:59,830
that accept just accepts tree roots from

00:44:57,520 --> 00:45:02,260
locks and serves the purpose of

00:44:59,830 --> 00:45:07,900
detecting these kinds of split view

00:45:02,260 --> 00:45:10,720
attacks so that's one of the one of the

00:45:07,900 --> 00:45:13,900
ways this is possible at resolve another

00:45:10,720 --> 00:45:17,830
one is to have the auditors or the

00:45:13,900 --> 00:45:22,680
clients exchange three routes with a

00:45:17,830 --> 00:45:26,440
monitor and then these two could be

00:45:22,680 --> 00:45:29,740
would be able to detect that they were

00:45:26,440 --> 00:45:33,400
presented with a different history of

00:45:29,740 --> 00:45:36,010
the tree and could detect that fact and

00:45:33,400 --> 00:45:38,200
also already have the proof that the

00:45:36,010 --> 00:45:41,410
lock server was malicious malicious

00:45:38,200 --> 00:45:43,269
because it has signed to three routes

00:45:41,410 --> 00:45:45,640
that are incompatible with

00:45:43,269 --> 00:45:50,399
another where one is not the does not

00:45:45,640 --> 00:45:54,239
cover a subset of the of the other yeah

00:45:50,399 --> 00:45:59,649
so thank you very much it was very

00:45:54,239 --> 00:46:02,169
interesting to me I hope you so

00:45:59,649 --> 00:46:04,899
certainly you brought up some good ideas

00:46:02,169 --> 00:46:08,949
I hope you understood a bit better what

00:46:04,899 --> 00:46:11,109
we are trying to achieve here we have to

00:46:08,949 --> 00:46:14,380
close this session now but do feel free

00:46:11,109 --> 00:46:17,339
to come to me and talk a bit more about

00:46:14,380 --> 00:46:17,339
it thank you

00:46:19,700 --> 00:46:23,870
[Applause]

00:46:20,740 --> 00:46:23,870

YouTube URL: https://www.youtube.com/watch?v=n5eCbES-Xj8


