Title: Parsing Posix [S]hell
Publication date: 2018-05-27
Playlist: MiniDebConf Hamburg 2018
Description: 
	by Ralf Treinen and Yann Regis-Gianas

At: MiniDebConf Hamburg
https://wiki.debian.org/DebianEvents/de/2018/MiniDebConfHamburg
Room: main
Scheduled start: 2018-05-19 15:00:00
Captions: 
	00:00:05,000 --> 00:00:11,430
okay yes hello okay hello so together

00:00:09,300 --> 00:00:14,549
with you and via talk are going to talk

00:00:11,430 --> 00:00:17,340
about the problem of passing shell shell

00:00:14,549 --> 00:00:19,320
scripts and we're in my part I would

00:00:17,340 --> 00:00:21,530
like to extend you why we are interested

00:00:19,320 --> 00:00:24,960
in this problem and then Jung will

00:00:21,530 --> 00:00:29,610
explain to you what we have experienced

00:00:24,960 --> 00:00:31,290
on our journey so far okay so what what

00:00:29,610 --> 00:00:34,800
up what you are doing is for having a

00:00:31,290 --> 00:00:36,620
project a research project over five

00:00:34,800 --> 00:00:39,510
years but we are trying to analyze

00:00:36,620 --> 00:00:42,570
Debian maintainer scripts so DB on is

00:00:39,510 --> 00:00:44,460
part of the research project and it's

00:00:42,570 --> 00:00:45,989
important that we have this applications

00:00:44,460 --> 00:00:48,480
of what a maintainer script most of you

00:00:45,989 --> 00:00:51,390
know what it is these are pre and post

00:00:48,480 --> 00:00:54,179
and pre RM post RM scripts which may

00:00:51,390 --> 00:00:56,039
exist in binary packages you may have

00:00:54,179 --> 00:00:58,229
none of them you may have all four of

00:00:56,039 --> 00:01:01,170
them or just a combination of them and

00:00:58,229 --> 00:01:02,760
we think it's very important to analyze

00:01:01,170 --> 00:01:05,610
the scripts that we have in these

00:01:02,760 --> 00:01:09,540
packages why well the first thing is

00:01:05,610 --> 00:01:11,399
they executed s route every time you

00:01:09,540 --> 00:01:13,469
install a package shooty install a

00:01:11,399 --> 00:01:17,189
package or that you up create a package

00:01:13,469 --> 00:01:19,350
and obviously a alex talked a talk

00:01:17,189 --> 00:01:21,360
already this morning about what was

00:01:19,350 --> 00:01:23,789
happening then you are funny on a you at

00:01:21,360 --> 00:01:25,979
any arbitrary shell code where this

00:01:23,789 --> 00:01:27,630
stuff is executed a suit on every

00:01:25,979 --> 00:01:30,479
machine though you have to be on

00:01:27,630 --> 00:01:32,280
installed so obviously we should be

00:01:30,479 --> 00:01:36,119
quite sure that these are not doing any

00:01:32,280 --> 00:01:37,560
stupid things a part of the problem is

00:01:36,119 --> 00:01:40,020
that well

00:01:37,560 --> 00:01:43,170
these scripts might be executed in

00:01:40,020 --> 00:01:44,670
different contexts and contexts mean the

00:01:43,170 --> 00:01:46,530
collection of packages that you are

00:01:44,670 --> 00:01:48,240
currently and stored on your packages on

00:01:46,530 --> 00:01:50,820
your on your machine and what these

00:01:48,240 --> 00:01:52,469
scripts are doing might depend on staff

00:01:50,820 --> 00:01:54,149
which countly is installed on your

00:01:52,469 --> 00:01:56,880
machine this is part of the reason why

00:01:54,149 --> 00:01:58,439
these scripts exist at all because they

00:01:56,880 --> 00:02:00,030
are part of the stuff you cannot put

00:01:58,439 --> 00:02:01,920
into the package because they are not

00:02:00,030 --> 00:02:04,109
static they depend on the particular

00:02:01,920 --> 00:02:05,999
situation of your machines or different

00:02:04,109 --> 00:02:08,160
situations and in all situations the

00:02:05,999 --> 00:02:11,009
script self to do do a thing and nothing

00:02:08,160 --> 00:02:13,110
nothing wrong another source of the

00:02:11,009 --> 00:02:15,030
problem is the fact that the packages

00:02:13,110 --> 00:02:18,060
are not living in isolation in a sedated

00:02:15,030 --> 00:02:20,459
service we have packages which

00:02:18,060 --> 00:02:26,340
infrastructure with other packages think

00:02:20,459 --> 00:02:27,840
for instance of tech think of of MX the

00:02:26,340 --> 00:02:30,030
once you install a package which

00:02:27,840 --> 00:02:33,690
contains for instance a tech add-on or

00:02:30,030 --> 00:02:36,810
an MX MX macros these are compiled or

00:02:33,690 --> 00:02:39,480
installed on directories which have been

00:02:36,810 --> 00:02:41,760
installed by other packages so packages

00:02:39,480 --> 00:02:44,130
do not live in isolation and we think

00:02:41,760 --> 00:02:46,739
that we need automated tools to analyze

00:02:44,130 --> 00:02:50,850
these scripts this obviously cannot be

00:02:46,739 --> 00:02:53,040
done by hand alone and just to give you

00:02:50,850 --> 00:02:56,190
an idea about the kind of problems that

00:02:53,040 --> 00:02:58,530
we are intending hoping that you hope to

00:02:56,190 --> 00:02:59,940
be able to find automatically at the end

00:02:58,530 --> 00:03:02,130
of the project I cannot promise that

00:02:59,940 --> 00:03:03,569
this will be the case but if you are on

00:03:02,130 --> 00:03:07,200
the QA mailing list maybe you remember

00:03:03,569 --> 00:03:09,150
this back report two months ago someone

00:03:07,200 --> 00:03:11,280
complained that he could not uninstall

00:03:09,150 --> 00:03:13,430
the sent mail base package because there

00:03:11,280 --> 00:03:16,380
was a buck and the post RM script and

00:03:13,430 --> 00:03:18,660
the thing I would like you to remark

00:03:16,380 --> 00:03:20,580
here is that this particular version of

00:03:18,660 --> 00:03:23,400
the package was in the archive for more

00:03:20,580 --> 00:03:25,470
than two months and the buck is so the

00:03:23,400 --> 00:03:28,590
Buc is at least as old as that and

00:03:25,470 --> 00:03:30,120
probably older and it's not really words

00:03:28,590 --> 00:03:32,130
and that it's not really aware package

00:03:30,120 --> 00:03:34,709
now it has a popcorn of the of almost a

00:03:32,130 --> 00:03:37,260
three thousand and one might wonder why

00:03:34,709 --> 00:03:40,440
this buck has not been found before and

00:03:37,260 --> 00:03:44,100
reported before because this seems to be

00:03:40,440 --> 00:03:48,060
quite an obvious problem and the reason

00:03:44,100 --> 00:03:50,160
is that in fact the buck occurred only

00:03:48,060 --> 00:03:51,540
in a very particular situation the

00:03:50,160 --> 00:03:53,459
situation was the following one in fact

00:03:51,540 --> 00:03:56,549
this was the offending line and the post

00:03:53,459 --> 00:04:00,870
RM script it was a find invocation with

00:03:56,549 --> 00:04:02,820
flag - size zero and all the files found

00:04:00,870 --> 00:04:05,940
by this find invocation would be removed

00:04:02,820 --> 00:04:09,959
by the ex arks - RRM so - is the option

00:04:05,940 --> 00:04:11,880
to ex arcs at not to RM and in fact

00:04:09,959 --> 00:04:14,100
obviously the maintainer here was

00:04:11,880 --> 00:04:16,169
assuming that a directory can never be

00:04:14,100 --> 00:04:18,479
of size zero because in that case of

00:04:16,169 --> 00:04:21,060
course CRM would fail it would not

00:04:18,479 --> 00:04:22,530
remove directory and in fact when you

00:04:21,060 --> 00:04:24,750
try it on your on your machine you

00:04:22,530 --> 00:04:26,610
probably most of you have an ext file

00:04:24,750 --> 00:04:28,590
system in fact you will find that a

00:04:26,610 --> 00:04:31,960
directory always has a size of at least

00:04:28,590 --> 00:04:33,639
one block so one can understand why

00:04:31,960 --> 00:04:36,130
one would make this assumption however

00:04:33,639 --> 00:04:39,160
it's not always true and the unfortunate

00:04:36,130 --> 00:04:41,410
user who was experiencing this bug he

00:04:39,160 --> 00:04:43,030
was yet his if you see on a butter ffs

00:04:41,410 --> 00:04:45,130
filesystem which is the kind of overlay

00:04:43,030 --> 00:04:46,870
filesystem this copy on white and it

00:04:45,130 --> 00:04:48,970
turns out that on this particular file

00:04:46,870 --> 00:04:51,130
system it is possible then you create a

00:04:48,970 --> 00:04:53,410
new directory that it has size zero and

00:04:51,130 --> 00:04:56,009
this explains why two months after the

00:04:53,410 --> 00:04:59,470
package was installed in the archive he

00:04:56,009 --> 00:05:02,530
he to opt on this on this particular but

00:04:59,470 --> 00:05:04,509
which of course once someone found out

00:05:02,530 --> 00:05:06,430
what happened what happened it was quite

00:05:04,509 --> 00:05:08,620
easy to find so the point I would like

00:05:06,430 --> 00:05:11,560
to make here is the testing is not

00:05:08,620 --> 00:05:15,190
enough so this you probably would not

00:05:11,560 --> 00:05:16,990
find I think pio Parts has tried and had

00:05:15,190 --> 00:05:19,330
tried to install the package and 2d

00:05:16,990 --> 00:05:21,759
installer package obviously the back was

00:05:19,330 --> 00:05:25,180
not found because it occurs only in a

00:05:21,759 --> 00:05:28,210
very very particular situation okay

00:05:25,180 --> 00:05:30,400
so we are trying to analyze the the

00:05:28,210 --> 00:05:33,190
maintainer scripts so this is a kind of

00:05:30,400 --> 00:05:36,250
node analysis I did at the end of 2016

00:05:33,190 --> 00:05:38,020
at that time we had almost 32,000

00:05:36,250 --> 00:05:39,580
container scripts in the archive at that

00:05:38,020 --> 00:05:42,099
time we had already more than 50,000

00:05:39,580 --> 00:05:44,620
binary packages and the vast vast

00:05:42,099 --> 00:05:46,840
majority of sieves are POSIX shell

00:05:44,620 --> 00:05:49,180
scripts well there are about 300 bash

00:05:46,840 --> 00:05:51,250
scripts which really have written bin

00:05:49,180 --> 00:05:53,919
bash they probably should be POSIX shell

00:05:51,250 --> 00:05:55,120
anyway and if you perl scripts and even

00:05:53,919 --> 00:05:56,889
1f executable

00:05:55,120 --> 00:05:59,050
but almost all of them are poor sexual

00:05:56,889 --> 00:06:04,060
scripts so at the beginning of our

00:05:59,050 --> 00:06:06,039
project obviously the first building

00:06:04,060 --> 00:06:08,500
block of our tool chain would be to

00:06:06,039 --> 00:06:11,469
construct a front end which would tweet

00:06:08,500 --> 00:06:13,780
support sexual scripts translate them

00:06:11,469 --> 00:06:15,820
into a syntax tree and then we would use

00:06:13,780 --> 00:06:18,729
this as the first fund as the first

00:06:15,820 --> 00:06:20,710
building block in order to have after

00:06:18,729 --> 00:06:23,050
this all the formal analysis stuff which

00:06:20,710 --> 00:06:25,419
would be able to find the bugs so our

00:06:23,050 --> 00:06:27,070
first step was to build this parser and

00:06:25,419 --> 00:06:30,159
at the beginning of the project honestly

00:06:27,070 --> 00:06:32,710
these thought that this would not be too

00:06:30,159 --> 00:06:34,539
difficult so we expected to have to fund

00:06:32,710 --> 00:06:36,280
and after maybe one year of the project

00:06:34,539 --> 00:06:38,949
with a nice specification of Unix

00:06:36,280 --> 00:06:41,349
commands and everything and it turns out

00:06:38,949 --> 00:06:44,440
earned out that it took us much longer

00:06:41,349 --> 00:06:45,639
than that and the reason for that is in

00:06:44,440 --> 00:06:50,310
fact yon who will now

00:06:45,639 --> 00:06:50,310
explain to you why this was so difficult

00:07:06,800 --> 00:07:15,000
we don't have this in head I think no

00:07:10,020 --> 00:07:18,030
it's okay does work okay cool so thank

00:07:15,000 --> 00:07:21,780
you alpha to let them believe that they

00:07:18,030 --> 00:07:23,760
will attend a regular technical talk so

00:07:21,780 --> 00:07:30,390
that they are confident and calm for the

00:07:23,760 --> 00:07:33,930
moment so as a as a ref theater the

00:07:30,390 --> 00:07:35,610
first goal of our project is to to to

00:07:33,930 --> 00:07:39,950
write a position passer

00:07:35,610 --> 00:07:43,220
but as this positional passer will be

00:07:39,950 --> 00:07:47,850
used integrated into a static analyzer

00:07:43,220 --> 00:07:49,680
we really have to be confident in this

00:07:47,850 --> 00:07:53,220
implementation we have we have to trust

00:07:49,680 --> 00:07:56,010
it okay because otherwise we can't trust

00:07:53,220 --> 00:08:00,900
to find the results of the entire tool

00:07:56,010 --> 00:08:03,900
chain so the questions that we'll talk

00:08:00,900 --> 00:08:06,620
about during this talk is how to write a

00:08:03,900 --> 00:08:11,580
POSIX shell passer that you can trust

00:08:06,620 --> 00:08:15,390
but actually the real message of this

00:08:11,580 --> 00:08:17,880
talk is that if you try to if you start

00:08:15,390 --> 00:08:20,420
answering this question you will start a

00:08:17,880 --> 00:08:22,790
journey in a world which is not

00:08:20,420 --> 00:08:25,800
different from hell

00:08:22,790 --> 00:08:30,990
okay so I will shortly explain why

00:08:25,800 --> 00:08:33,390
during this talk but let's start with

00:08:30,990 --> 00:08:37,980
the beginning so when you know that you

00:08:33,390 --> 00:08:40,530
will have a difficult journey you first

00:08:37,980 --> 00:08:43,310
try to be prepared so you open a book

00:08:40,530 --> 00:08:46,710
and you try to listen to listen to the

00:08:43,310 --> 00:08:52,290
wisdom of your ancestors because you

00:08:46,710 --> 00:08:55,200
know for 50 years a lot of computer

00:08:52,290 --> 00:08:57,660
scientists study this problem of parsing

00:08:55,200 --> 00:09:01,160
and Zell said to us a very important

00:08:57,660 --> 00:09:05,450
message parsing is a very difficult

00:09:01,160 --> 00:09:08,880
programming task sometimes and as it is

00:09:05,450 --> 00:09:11,940
difficult for amita's it has to be

00:09:08,880 --> 00:09:14,390
decomposed into simpler tasks and they

00:09:11,940 --> 00:09:16,740
gave us a very beautiful architecture

00:09:14,390 --> 00:09:19,310
okay so one that says

00:09:16,740 --> 00:09:23,280
if you want to built a syntactic

00:09:19,310 --> 00:09:27,210
analysis you first start with a lexical

00:09:23,280 --> 00:09:29,610
analyzer Alexa which will turn your

00:09:27,210 --> 00:09:32,340
stream of characters into a stream of

00:09:29,610 --> 00:09:35,490
tokens a stream of what is really

00:09:32,340 --> 00:09:38,480
relevant in your input and then you will

00:09:35,490 --> 00:09:42,030
write a parser that will take this

00:09:38,480 --> 00:09:44,580
sequence of tokens and recognize some

00:09:42,030 --> 00:09:47,910
structure inside it using a grammar and

00:09:44,580 --> 00:09:50,610
build for you if the input is

00:09:47,910 --> 00:09:54,000
syntactically correct an abstract syntax

00:09:50,610 --> 00:09:58,050
tree okay so that's the beautiful

00:09:54,000 --> 00:10:01,260
architecture that have been here for 50

00:09:58,050 --> 00:10:04,140
years now and it has been so well

00:10:01,260 --> 00:10:06,720
studied that actually people came with

00:10:04,140 --> 00:10:10,620
very nice declarative language that you

00:10:06,720 --> 00:10:12,720
you know like specification and BNF

00:10:10,620 --> 00:10:16,170
specification the types you define

00:10:12,720 --> 00:10:19,350
lexical analyzer analysis and pass pass

00:10:16,170 --> 00:10:22,950
errs with very declarative languages and

00:10:19,350 --> 00:10:25,290
furthermore what the gathers is a way to

00:10:22,950 --> 00:10:29,550
turn these very high level

00:10:25,290 --> 00:10:31,980
specifications into code just like when

00:10:29,550 --> 00:10:33,750
you use a compiler and you trust it to

00:10:31,980 --> 00:10:36,210
be able to turn your high-level language

00:10:33,750 --> 00:10:39,450
into some some assembly code it is

00:10:36,210 --> 00:10:43,350
possible to only have to rezone about

00:10:39,450 --> 00:10:46,770
these specifications and just let the

00:10:43,350 --> 00:10:50,760
code generators work do that work to

00:10:46,770 --> 00:10:53,460
give you code that you can trust okay so

00:10:50,760 --> 00:10:57,030
it's a very beautiful framework and

00:10:53,460 --> 00:10:59,130
everyone wants to when you have to

00:10:57,030 --> 00:11:01,520
define a compiler you really want to use

00:10:59,130 --> 00:11:06,480
that one so of course you start with

00:11:01,520 --> 00:11:09,210
classical architecture and you go in

00:11:06,480 --> 00:11:11,010
another book the POSIX charge

00:11:09,210 --> 00:11:16,590
specification which is defined by the

00:11:11,010 --> 00:11:19,800
open group and well by just looking in a

00:11:16,590 --> 00:11:25,110
very high-level way you first discover a

00:11:19,800 --> 00:11:29,070
yak grammar inside so it's a real moment

00:11:25,110 --> 00:11:29,990
of happiness you say the job is almost

00:11:29,070 --> 00:11:33,110
done

00:11:29,990 --> 00:11:35,360
grammar inside so we'll just have to cut

00:11:33,110 --> 00:11:40,730
and paste it into my code generators and

00:11:35,360 --> 00:11:45,410
then I will go to old days but actually

00:11:40,730 --> 00:11:48,470
it's not exactly a yak specification it

00:11:45,410 --> 00:11:52,279
is a yak specification and notated by

00:11:48,470 --> 00:11:55,760
site conditions which are actually

00:11:52,279 --> 00:11:59,480
totally out of which in terms of

00:11:55,760 --> 00:12:02,300
expressiveness of what you can do what

00:11:59,480 --> 00:12:04,700
you can recognize with LR parsers so it

00:12:02,300 --> 00:12:09,500
means that you can't really use tightly

00:12:04,700 --> 00:12:12,050
at least this yet specification okay so

00:12:09,500 --> 00:12:14,690
you you have to enter the details to

00:12:12,050 --> 00:12:18,140
actually read the text and then you

00:12:14,690 --> 00:12:20,290
understand more and more then actually

00:12:18,140 --> 00:12:24,770
the specifications is really low-level

00:12:20,290 --> 00:12:27,080
it is sometimes contradictory it is

00:12:24,770 --> 00:12:32,000
unconventional you've never seen that

00:12:27,080 --> 00:12:34,579
before and they're so informal okay so

00:12:32,000 --> 00:12:37,850
actually you can't really blame the guys

00:12:34,579 --> 00:12:41,480
that would the specification but because

00:12:37,850 --> 00:12:46,310
the actual truth that the language

00:12:41,480 --> 00:12:48,470
itself is an absolute over okay it's a

00:12:46,310 --> 00:12:52,160
monster it's something it's a world of

00:12:48,470 --> 00:12:56,209
suffering okay if you want to understand

00:12:52,160 --> 00:12:58,149
precisely what it is the way well I will

00:12:56,209 --> 00:13:01,430
explain that during this tour but

00:12:58,149 --> 00:13:04,760
basically the idea is that lexical

00:13:01,430 --> 00:13:07,839
analysis analysis is person dependent so

00:13:04,760 --> 00:13:10,910
that you could you you can see the

00:13:07,839 --> 00:13:14,050
process as a composition of lexical

00:13:10,910 --> 00:13:17,890
analysis and parsing but actually the

00:13:14,050 --> 00:13:21,220
interactions needed between the tube and

00:13:17,890 --> 00:13:26,600
the grammar is actually ambiguous and

00:13:21,220 --> 00:13:29,990
even in general terms in the general

00:13:26,600 --> 00:13:33,339
case you can't write its undecidable to

00:13:29,990 --> 00:13:37,190
write a static parser for shell scripts

00:13:33,339 --> 00:13:39,800
in addition to that the the

00:13:37,190 --> 00:13:41,779
specifications is full of irregularities

00:13:39,800 --> 00:13:43,339
you have a lot of special cases

00:13:41,779 --> 00:13:49,589
everywhere

00:13:43,339 --> 00:13:51,480
so let's try to get I will try to give

00:13:49,589 --> 00:13:52,649
you some examples such what I've just

00:13:51,480 --> 00:13:57,300
said is true

00:13:52,649 --> 00:14:00,180
and to start Wizards consider token

00:13:57,300 --> 00:14:03,890
recognition so if you have if you are a

00:14:00,180 --> 00:14:06,390
compiler writer you are used to a

00:14:03,890 --> 00:14:09,450
definition of lexical analysis in which

00:14:06,390 --> 00:14:12,260
tokens are defined positively you are

00:14:09,450 --> 00:14:16,980
given a regular expression for

00:14:12,260 --> 00:14:19,470
identifiers for keywords for keywords

00:14:16,980 --> 00:14:21,450
you have a list of of the keywords you

00:14:19,470 --> 00:14:24,450
you also have I don't know regular

00:14:21,450 --> 00:14:27,750
expressions for some literals and so on

00:14:24,450 --> 00:14:29,850
and so forth so it's very nice because

00:14:27,750 --> 00:14:32,040
you can just cut and paste the regular

00:14:29,850 --> 00:14:35,520
expression to your legs generator and

00:14:32,040 --> 00:14:39,300
use the common strongest mass longest

00:14:35,520 --> 00:14:43,620
match strategy of this legs tool to

00:14:39,300 --> 00:14:45,600
define your lexical analysis in shell

00:14:43,620 --> 00:14:49,200
it's totally different see all the way

00:14:45,600 --> 00:14:52,560
around tokens are not defined positively

00:14:49,200 --> 00:14:56,160
but negative in the sense that what you

00:14:52,560 --> 00:15:02,000
have is how to delimit your tokens but

00:14:56,160 --> 00:15:04,740
how what is between each tokens okay

00:15:02,000 --> 00:15:08,970
that's not really difficult but it's

00:15:04,740 --> 00:15:11,339
just unconventional unfortunately what

00:15:08,970 --> 00:15:14,279
you can do is still to use like

00:15:11,339 --> 00:15:17,730
specification to define that and it's

00:15:14,279 --> 00:15:21,720
kind of work but there is another

00:15:17,730 --> 00:15:27,510
difficulty normally the lexical analysis

00:15:21,720 --> 00:15:29,610
is defined as as a third function that

00:15:27,510 --> 00:15:31,829
takes two characters and produce the

00:15:29,610 --> 00:15:34,440
tokens that will be consumed by the

00:15:31,829 --> 00:15:36,779
grammar grammars is expressed with these

00:15:34,440 --> 00:15:38,550
tokens but actually in the case of the

00:15:36,779 --> 00:15:42,180
shell specification that's not true what

00:15:38,550 --> 00:15:44,790
you have after lexical recognitions is

00:15:42,180 --> 00:15:49,140
not really talking it's what I would

00:15:44,790 --> 00:15:52,589
call pre tokens it's it's a

00:15:49,140 --> 00:15:56,160
classification of texts change into two

00:15:52,589 --> 00:15:58,110
categories words and operators so you

00:15:56,160 --> 00:16:00,209
we'll have to do some post-processing to

00:15:58,110 --> 00:16:06,810
get actual token but I will talk about

00:16:00,209 --> 00:16:08,759
that later also there are some easy part

00:16:06,810 --> 00:16:11,670
normally in when you write a lexical

00:16:08,759 --> 00:16:15,420
analyzer typically new lines are just

00:16:11,670 --> 00:16:18,209
ignored comments are easy escapes or

00:16:15,420 --> 00:16:21,000
they are just you know backslash and

00:16:18,209 --> 00:16:23,759
something else in the case of shell

00:16:21,000 --> 00:16:26,339
script everything is complicated even

00:16:23,759 --> 00:16:29,699
the semantics of new lines I will come

00:16:26,339 --> 00:16:32,480
back on this using an example in a few

00:16:29,699 --> 00:16:37,170
minutes but let's consider this example

00:16:32,480 --> 00:16:40,670
about token recognition in any same

00:16:37,170 --> 00:16:44,970
language on the first line you would

00:16:40,670 --> 00:16:47,790
detect I would say five tokens okay

00:16:44,970 --> 00:16:52,259
in the case of shell it's just one token

00:16:47,790 --> 00:16:56,970
but okay fine it's how it is specified

00:16:52,259 --> 00:16:59,579
let's continue in on line two well you

00:16:56,970 --> 00:17:03,660
have to separate token by considering

00:16:59,579 --> 00:17:05,370
space so here you have a space okay here

00:17:03,660 --> 00:17:08,220
you have another one here you have all

00:17:05,370 --> 00:17:10,470
wait no this one is between double

00:17:08,220 --> 00:17:13,530
quotes so it's not a space that dairy

00:17:10,470 --> 00:17:15,929
meat tokens fine fine and you have

00:17:13,530 --> 00:17:20,280
another space here no it's not fine too

00:17:15,929 --> 00:17:23,760
because here the spaces in a sub shell

00:17:20,280 --> 00:17:27,030
here so also it's not really did it's

00:17:23,760 --> 00:17:30,690
not eliminating pre tokens so fine it's

00:17:27,030 --> 00:17:33,150
not it's not a space that the limits

00:17:30,690 --> 00:17:35,789
here you have another space which the

00:17:33,150 --> 00:17:37,740
limits token and here on a final one so

00:17:35,789 --> 00:17:42,929
it means that here you have actually

00:17:37,740 --> 00:17:45,390
five token but okay what I've just said

00:17:42,929 --> 00:17:47,280
it means that you have to write your

00:17:45,390 --> 00:17:50,309
lexical analysis by considering some

00:17:47,280 --> 00:17:53,159
form of context to Delhi to define if

00:17:50,309 --> 00:17:54,840
space is delimiting or not your your

00:17:53,159 --> 00:17:59,240
tokens but that's fine you can do it

00:17:54,840 --> 00:18:02,370
further moment is just complex legs

00:17:59,240 --> 00:18:05,309
specifications that you will get by by

00:18:02,370 --> 00:18:08,580
so it means that if it is complexity is

00:18:05,309 --> 00:18:10,080
not simple and I really love to trust

00:18:08,580 --> 00:18:12,179
Finkle simple things

00:18:10,080 --> 00:18:15,299
not complex one but okay we'll trust

00:18:12,179 --> 00:18:18,779
that part if I look at it real for a

00:18:15,299 --> 00:18:21,630
very long time but let's consider a new

00:18:18,779 --> 00:18:24,960
line now actually in the shell scripts

00:18:21,630 --> 00:18:27,289
you have four different interpretation

00:18:24,960 --> 00:18:31,080
of new lines for different

00:18:27,289 --> 00:18:33,330
interpretation of new lines repeated

00:18:31,080 --> 00:18:35,820
again four different in the partition of

00:18:33,330 --> 00:18:39,630
neurons it's totally crazy okay so let's

00:18:35,820 --> 00:18:41,429
consider this example on line on the

00:18:39,630 --> 00:18:45,630
first line for instance you have a new

00:18:41,429 --> 00:18:47,370
line at the end of of the line and it is

00:18:45,630 --> 00:18:51,840
meaningful in terms of the grammar it

00:18:47,370 --> 00:18:53,490
sees a token actually that is that

00:18:51,840 --> 00:18:56,909
appears in the grammar so you have to

00:18:53,490 --> 00:19:00,510
convey it to the parser and it is

00:18:56,909 --> 00:19:04,130
important it is a delimiter the tokens

00:19:00,510 --> 00:19:08,370
that and the sequence on which you are

00:19:04,130 --> 00:19:10,350
iterating go over then of course you

00:19:08,370 --> 00:19:12,720
have new lines in command set must be

00:19:10,350 --> 00:19:15,029
ignored you also have this new line

00:19:12,720 --> 00:19:18,630
preceded by backslash backslash ease

00:19:15,029 --> 00:19:21,419
that means that that you are you have a

00:19:18,630 --> 00:19:24,630
line continuation you know it's just a

00:19:21,419 --> 00:19:27,269
way to continue to the next line so it's

00:19:24,630 --> 00:19:31,110
purely lexically it doesn't the grammar

00:19:27,269 --> 00:19:35,610
is is not telling asking something about

00:19:31,110 --> 00:19:38,909
that and and finally the backslash and

00:19:35,610 --> 00:19:41,399
at the end is an end of phrase marker so

00:19:38,909 --> 00:19:43,559
it's another token again so it means

00:19:41,399 --> 00:19:47,309
that you have to define a very smart

00:19:43,559 --> 00:19:51,269
logic to understand at the lexical in

00:19:47,309 --> 00:19:54,090
your lexical analysis which neurons are

00:19:51,269 --> 00:19:56,580
actually to be ignored which new lines

00:19:54,090 --> 00:20:00,960
are token in which world which one of

00:19:56,580 --> 00:20:06,870
these tokens is is the good one for this

00:20:00,960 --> 00:20:09,809
newline character okay so so at this

00:20:06,870 --> 00:20:12,029
point you may be a bit frightened so you

00:20:09,809 --> 00:20:14,970
may want to escape I don't know maybe

00:20:12,029 --> 00:20:20,850
you want to escape it before that I do

00:20:14,970 --> 00:20:24,120
have a quiz for you so you know - - is

00:20:20,850 --> 00:20:29,309
the debian shell so you all expect of -

00:20:24,120 --> 00:20:32,590
and so you can tell me with no computer

00:20:29,309 --> 00:20:35,860
which one of this line outputs two

00:20:32,590 --> 00:20:38,049
backslashes to the standard output so

00:20:35,860 --> 00:20:40,149
please raise your hand if you think the

00:20:38,049 --> 00:20:42,429
first one with output output two

00:20:40,149 --> 00:20:49,740
backslashes don't be shy

00:20:42,429 --> 00:20:55,690
thank you the second one I don't count

00:20:49,740 --> 00:21:03,730
okay the third one yes you are the

00:20:55,690 --> 00:21:06,149
expert in the room I won't explain why

00:21:03,730 --> 00:21:08,980
today because I don't have one i well i

00:21:06,149 --> 00:21:11,860
doesn't takes one hour but it's a long

00:21:08,980 --> 00:21:15,159
explanation after all but yes you need

00:21:11,860 --> 00:21:21,850
you need six backslashes to output two

00:21:15,159 --> 00:21:23,320
backslashes okay - yeah yeah is it in

00:21:21,850 --> 00:21:26,380
plastic shell actually it's it's

00:21:23,320 --> 00:21:30,340
compliant with POSIX in - yes

00:21:26,380 --> 00:21:34,539
not in bash bash and being the echo

00:21:30,340 --> 00:21:37,000
isn't is also not does not have the

00:21:34,539 --> 00:21:40,840
right behavior with respect to POSIX -

00:21:37,000 --> 00:21:46,090
with that respect okay but now imagine

00:21:40,840 --> 00:21:50,519
that you put back quote around it

00:21:46,090 --> 00:21:54,549
shouldn't change I mean it's just

00:21:50,519 --> 00:21:59,350
running inception right so what will

00:21:54,549 --> 00:22:01,990
happen here syntax error okay this one

00:21:59,350 --> 00:22:04,320
it really takes one hour and we are not

00:22:01,990 --> 00:22:10,799
really sure how to explain it

00:22:04,320 --> 00:22:13,389
exactly so that what I meant when I said

00:22:10,799 --> 00:22:15,240
earlier that escaping depends on the

00:22:13,389 --> 00:22:19,419
nesting of sepcial and double quotes

00:22:15,240 --> 00:22:22,380
okay nobody wants to leave the room I

00:22:19,419 --> 00:22:22,380
mean

00:22:24,590 --> 00:22:32,749
okay okay so I can continue so I've said

00:22:29,629 --> 00:22:34,730
earlier that actually after the lexical

00:22:32,749 --> 00:22:39,710
analysis what you get are three tokens

00:22:34,730 --> 00:22:42,019
and what the grammar needs is tokens so

00:22:39,710 --> 00:22:46,220
what you have to do at some points to

00:22:42,019 --> 00:22:49,999
take words and provide them two key

00:22:46,220 --> 00:22:51,529
words and all two assignment words but I

00:22:49,999 --> 00:22:55,549
won't talk about assignment words

00:22:51,529 --> 00:22:58,100
because I don't have time to do that but

00:22:55,549 --> 00:23:00,649
actually what I want to say is that this

00:22:58,100 --> 00:23:07,759
promotion depends on the passing context

00:23:00,649 --> 00:23:10,580
so it's it's maybe clear it should be

00:23:07,759 --> 00:23:12,590
clear with this example it is not I'm

00:23:10,580 --> 00:23:15,499
not the author of this example Ralph

00:23:12,590 --> 00:23:20,419
Hanan with his twisted mind if device

00:23:15,499 --> 00:23:23,779
this example which was a bit weird maybe

00:23:20,419 --> 00:23:28,999
but it currently explained Alysse traits

00:23:23,779 --> 00:23:31,639
that a keyword I mean something that

00:23:28,999 --> 00:23:33,440
looks like a keyword can be interpreted

00:23:31,639 --> 00:23:37,600
as something that is not a keyword

00:23:33,440 --> 00:23:42,019
depending on its place in the output

00:23:37,600 --> 00:23:43,909
okay so for instance for here this one

00:23:42,019 --> 00:23:47,539
the first one is of course a reserved

00:23:43,909 --> 00:23:50,360
word you start a loop okay but this one

00:23:47,539 --> 00:23:54,820
is just two words that is a part of your

00:23:50,360 --> 00:23:58,879
sequence on which you are iterating over

00:23:54,820 --> 00:24:01,999
okay so it means and and that the same

00:23:58,879 --> 00:24:04,039
for in and for do and so on that's a

00:24:01,999 --> 00:24:09,470
syntactically correct program by the way

00:24:04,039 --> 00:24:11,629
you know of course so when you are in

00:24:09,470 --> 00:24:14,480
your lexical analyzer you have to call

00:24:11,629 --> 00:24:17,419
the parsing context to introspect it to

00:24:14,480 --> 00:24:24,470
observe it to define if you can promote

00:24:17,419 --> 00:24:29,450
a word into a reserved word but not all

00:24:24,470 --> 00:24:31,879
the time sometimes some words some words

00:24:29,450 --> 00:24:36,129
that are actually that could be

00:24:31,879 --> 00:24:38,300
interpreted as reserved word like else

00:24:36,129 --> 00:24:43,250
cannot appeared some

00:24:38,300 --> 00:24:47,680
very specific position okay so you have

00:24:43,250 --> 00:24:50,680
a lot of irregularities in the

00:24:47,680 --> 00:24:53,800
specification a lot of special corner

00:24:50,680 --> 00:24:59,570
everywhere in this very dark world of

00:24:53,800 --> 00:25:03,140
POSIX shell language so never never name

00:24:59,570 --> 00:25:05,210
one of you to be else it will never a

00:25:03,140 --> 00:25:12,320
user will never be able to call it I

00:25:05,210 --> 00:25:14,480
mean without full path okay so it means

00:25:12,320 --> 00:25:17,690
that your parser you will have some

00:25:14,480 --> 00:25:20,060
adult site conditions everywhere to cut

00:25:17,690 --> 00:25:25,670
with all the irregularities of the

00:25:20,060 --> 00:25:29,150
language but at this punch I see some

00:25:25,670 --> 00:25:31,190
eyes that are a bit frightened but not

00:25:29,150 --> 00:25:34,010
that much you've seen a lot already in

00:25:31,190 --> 00:25:36,650
your programmer life but I have

00:25:34,010 --> 00:25:39,560
something that is like I not know the

00:25:36,650 --> 00:25:42,590
final boss so the one that will kill you

00:25:39,560 --> 00:25:46,250
if you don't protect yourself so I won't

00:25:42,590 --> 00:25:50,240
warn you before that so are you prepared

00:25:46,250 --> 00:25:52,610
for this slicer last example so the

00:25:50,240 --> 00:25:56,090
icing of the cake actually static

00:25:52,610 --> 00:25:59,900
parsing is undecidable you can't write a

00:25:56,090 --> 00:26:04,280
static Pancer for shell script why this

00:25:59,900 --> 00:26:08,420
is because of the presence of areas so

00:26:04,280 --> 00:26:12,350
areas is like macro if you want some

00:26:08,420 --> 00:26:15,890
form of define of macro definition what

00:26:12,350 --> 00:26:21,710
you are defining with areas is a word

00:26:15,890 --> 00:26:24,830
that is substituted by some string just

00:26:21,710 --> 00:26:28,930
before syntactic analysis is applied

00:26:24,830 --> 00:26:33,490
okay so it means in that example that

00:26:28,930 --> 00:26:34,970
depending on the exist a choose of foo

00:26:33,490 --> 00:26:38,780
this paga

00:26:34,970 --> 00:26:41,810
this script is syntactical syntactically

00:26:38,780 --> 00:26:44,930
correct or not that's not your choice

00:26:41,810 --> 00:26:50,390
it's first choice okay so you can't

00:26:44,930 --> 00:26:51,860
decide so okay you will say oh it's

00:26:50,390 --> 00:26:55,280
normal because usually

00:26:51,860 --> 00:26:58,610
shell scripts are syntactically another

00:26:55,280 --> 00:27:01,960
analyzed and evaluated just phrase by

00:26:58,610 --> 00:27:03,920
phrase and so I'm able to evaluate this

00:27:01,960 --> 00:27:07,429
polymerizing bash or something like that

00:27:03,920 --> 00:27:10,970
in our case we really have to be static

00:27:07,429 --> 00:27:13,820
we can't evaluate scripts so we can't

00:27:10,970 --> 00:27:18,620
say if the scripts is syntactically

00:27:13,820 --> 00:27:20,780
correct or not okay you're pretty calm

00:27:18,620 --> 00:27:24,830
maybe it's because we are just after the

00:27:20,780 --> 00:27:28,820
lunch but you may wonder at this point

00:27:24,830 --> 00:27:30,860
if so yes passing depends on the

00:27:28,820 --> 00:27:33,470
evaluation so at this point you may

00:27:30,860 --> 00:27:39,919
wonder if it's even possible to write a

00:27:33,470 --> 00:27:42,049
shell passer okay but actually of course

00:27:39,919 --> 00:27:45,530
that's possible because there are very

00:27:42,049 --> 00:27:49,190
smart people in the world that we're

00:27:45,530 --> 00:27:54,710
able to to tackle this problem I mean if

00:27:49,190 --> 00:27:57,950
you look at the path of - it's it's 1600

00:27:54,710 --> 00:28:00,919
lines of an crafted C character level C

00:27:57,950 --> 00:28:03,470
I mean this guy said they took the

00:28:00,919 --> 00:28:07,100
textbook and they use it not to open it

00:28:03,470 --> 00:28:09,650
and to to use it but as a shield okay as

00:28:07,100 --> 00:28:12,710
a weapon so don't use the textbook

00:28:09,650 --> 00:28:14,150
actually as a textbook so just implement

00:28:12,710 --> 00:28:17,330
a person with their bare hands

00:28:14,150 --> 00:28:20,120
there are arrows okay the same is true

00:28:17,330 --> 00:28:21,830
for bash with which is using some form

00:28:20,120 --> 00:28:23,870
of your grammar which is totally

00:28:21,830 --> 00:28:27,020
different from the one of the of the

00:28:23,870 --> 00:28:30,020
specifications and also next high 5,000

00:28:27,020 --> 00:28:35,390
signs of C but actually for bash which

00:28:30,020 --> 00:28:40,130
is a larger language and than share okay

00:28:35,390 --> 00:28:44,809
so what you get is some code like that

00:28:40,130 --> 00:28:48,110
okay so it's a glimpse of of the -

00:28:44,809 --> 00:28:50,240
parser and I don't want you to read it

00:28:48,110 --> 00:28:53,919
and to understand it but the idea is

00:28:50,240 --> 00:28:58,370
that what you get is a very low level

00:28:53,919 --> 00:29:02,710
passing a code which using bitmask

00:28:58,370 --> 00:29:05,810
global variables character level passing

00:29:02,710 --> 00:29:07,610
and a lot of lot of things some

00:29:05,810 --> 00:29:11,600
form of backtracking at some point and

00:29:07,610 --> 00:29:14,000
so on so it's really really impressive

00:29:11,600 --> 00:29:16,190
to be able to write down this code and

00:29:14,000 --> 00:29:20,420
to have it correct I have a deepest

00:29:16,190 --> 00:29:24,890
respect for this programmer and I have

00:29:20,420 --> 00:29:27,530
not a brain as large as their brain so I

00:29:24,890 --> 00:29:30,020
can't personally I can't maintain that

00:29:27,530 --> 00:29:32,120
kind of code I can't trust it because I

00:29:30,020 --> 00:29:36,920
can't maintain it I can't understand it

00:29:32,120 --> 00:29:41,090
my skirt is too small okay so I have to

00:29:36,920 --> 00:29:45,140
find a way to write a parser that is

00:29:41,090 --> 00:29:48,920
POSIX compliant and the source simple in

00:29:45,140 --> 00:29:52,670
some way that with my little brain I can

00:29:48,920 --> 00:29:56,120
under it under its complexity locally

00:29:52,670 --> 00:30:00,140
piece by pieces pieces by pieces and

00:29:56,120 --> 00:30:03,200
that's why we went back to the books

00:30:00,140 --> 00:30:07,460
artwork research article and try to do

00:30:03,200 --> 00:30:12,380
some more advanced magic in terms of

00:30:07,460 --> 00:30:14,810
modular teacher for parcel what we we do

00:30:12,380 --> 00:30:18,500
is a variant of the standard

00:30:14,810 --> 00:30:23,300
architecture for Posadas that have

00:30:18,500 --> 00:30:25,400
presented already and the idea that we

00:30:23,300 --> 00:30:27,650
will use code generators as much as

00:30:25,400 --> 00:30:31,240
possible because we want high-level

00:30:27,650 --> 00:30:39,370
specific code as much as possible and

00:30:31,240 --> 00:30:42,260
what we will do is to to to to to

00:30:39,370 --> 00:30:45,590
orchestrate the interaction between this

00:30:42,260 --> 00:30:48,980
this generated code in such a way that

00:30:45,590 --> 00:30:53,270
this orchestration can be easily mapped

00:30:48,980 --> 00:30:54,740
to the specification okay so we have an

00:30:53,270 --> 00:30:58,420
architecture in which whether per

00:30:54,740 --> 00:31:02,780
lecture which is written by some legs

00:30:58,420 --> 00:31:05,390
specification as usual which produces

00:31:02,780 --> 00:31:10,040
pre tokens and then we have two modules

00:31:05,390 --> 00:31:12,170
which interacts in a way that the legs

00:31:10,040 --> 00:31:15,350
provide tokens to the parser and the

00:31:12,170 --> 00:31:18,850
parser is able to provide it states to

00:31:15,350 --> 00:31:18,850
the lecture for introspection

00:31:19,910 --> 00:31:27,140
but what makes this possible actually is

00:31:24,980 --> 00:31:31,450
the fact that we are using some special

00:31:27,140 --> 00:31:31,450
technology here thank you

00:31:32,240 --> 00:31:41,690
first of all we use a Lac generator

00:31:38,180 --> 00:31:44,120
called mini era which makes it possible

00:31:41,690 --> 00:31:47,090
to simply take the grammar of the

00:31:44,120 --> 00:31:51,680
standard and cast a cut and paste it

00:31:47,090 --> 00:31:54,620
into our code and then built all the

00:31:51,680 --> 00:31:57,320
complex interactions that have already

00:31:54,620 --> 00:32:02,000
to deal with already presented

00:31:57,320 --> 00:32:06,080
complexity of the passing outside around

00:32:02,000 --> 00:32:08,960
this specification so we are very proud

00:32:06,080 --> 00:32:11,900
of this we are very close to this a lot

00:32:08,960 --> 00:32:16,820
because we start with the specification

00:32:11,900 --> 00:32:19,340
of the stone art and the key ingredients

00:32:16,820 --> 00:32:21,560
that makes it works is the fact that we

00:32:19,340 --> 00:32:27,260
are using a purely functional in the

00:32:21,560 --> 00:32:31,010
incremental parser that actors use very

00:32:27,260 --> 00:32:33,800
advanced parsing techniques which are

00:32:31,010 --> 00:32:36,320
called speculative passing longest

00:32:33,800 --> 00:32:38,870
prefix path passing point to

00:32:36,320 --> 00:32:42,200
parameterize alexis and passes state

00:32:38,870 --> 00:32:44,180
into introspection so I can't go into

00:32:42,200 --> 00:32:46,900
the details here but the idea of

00:32:44,180 --> 00:32:50,630
speculative passing is the fact that you

00:32:46,900 --> 00:32:53,150
don't have a single parser you have

00:32:50,630 --> 00:32:57,320
actually many soldiers and sometimes you

00:32:53,150 --> 00:33:00,050
take a person you say he you ask him to

00:32:57,320 --> 00:33:03,610
go into in the future in the future to

00:33:00,050 --> 00:33:06,260
read a little more of the input and

00:33:03,610 --> 00:33:09,590
eventually eventually this parser can

00:33:06,260 --> 00:33:12,800
die but just before he dies is send you

00:33:09,590 --> 00:33:15,440
by a message to describe it with what

00:33:12,800 --> 00:33:18,860
you have seen okay and using this

00:33:15,440 --> 00:33:21,440
information you can you can decide what

00:33:18,860 --> 00:33:24,770
to do in your actual parser we can do

00:33:21,440 --> 00:33:26,990
that because we are purely functional so

00:33:24,770 --> 00:33:29,420
we are stateless and we share a lot of

00:33:26,990 --> 00:33:33,340
things between all our different

00:33:29,420 --> 00:33:37,930
checkpoints in in the person process

00:33:33,340 --> 00:33:41,720
so so I think I will skip the other one

00:33:37,930 --> 00:33:44,510
so I can't show you the code today but

00:33:41,720 --> 00:33:47,390
what I can show you is the difference

00:33:44,510 --> 00:33:52,100
between what will you get

00:33:47,390 --> 00:33:53,810
using our generator Manila with respect

00:33:52,100 --> 00:33:57,140
to the standard output such kit with

00:33:53,810 --> 00:34:01,550
bison for instance if you use bison what

00:33:57,140 --> 00:34:06,470
you get if you took if you give him a

00:34:01,550 --> 00:34:09,169
yak specification is a code that is

00:34:06,470 --> 00:34:12,169
basically of functions that take Alexa

00:34:09,169 --> 00:34:15,250
and then execute and when you you give

00:34:12,169 --> 00:34:18,710
it the control it will execute and

00:34:15,250 --> 00:34:22,159
consume all the input to produce an

00:34:18,710 --> 00:34:24,350
entire abstract syntax tree if the input

00:34:22,159 --> 00:34:27,440
is actually syntactically correct okay

00:34:24,350 --> 00:34:29,690
you can't interrupt it with men you have

00:34:27,440 --> 00:34:34,600
an alternative Nick nature that allows

00:34:29,690 --> 00:34:42,429
us to to to do some interruptible

00:34:34,600 --> 00:34:45,350
passing process actually when you are in

00:34:42,429 --> 00:34:49,940
using a password generated by mania what

00:34:45,350 --> 00:34:52,520
you get is a a checkpoint okay when you

00:34:49,940 --> 00:34:54,889
execute the past parsing function you

00:34:52,520 --> 00:34:58,760
get a checkpoint which correspond to a

00:34:54,889 --> 00:35:01,160
single step in the passing process and

00:34:58,760 --> 00:35:04,370
then you can take the state a true you

00:35:01,160 --> 00:35:09,380
get at this point and you will know

00:35:04,370 --> 00:35:11,630
what's with a very beautiful some type

00:35:09,380 --> 00:35:14,740
you will know in which case you are in

00:35:11,630 --> 00:35:17,870
the passing analysis so that you can

00:35:14,740 --> 00:35:19,490
make an interaction as I've said in the

00:35:17,870 --> 00:35:21,830
preview as I've shown you in the

00:35:19,490 --> 00:35:25,820
previous previous diagrams between the

00:35:21,830 --> 00:35:30,530
parser and Alexa and the Alexa can react

00:35:25,820 --> 00:35:34,430
to each step of the passing process so

00:35:30,530 --> 00:35:37,340
that who - I know for instance promote

00:35:34,430 --> 00:35:42,830
words into wizzy of the world if the

00:35:37,340 --> 00:35:44,570
parser is compatible with that okay so

00:35:42,830 --> 00:35:51,140
that the details

00:35:44,570 --> 00:35:53,360
Skippy's so what we we get for the

00:35:51,140 --> 00:35:56,660
moment is a standalone program could

00:35:53,360 --> 00:36:00,590
more bigger which is able to turn a

00:35:56,660 --> 00:36:03,440
shell script into a syntax some syntax

00:36:00,590 --> 00:36:06,770
tree represented in JSON it's actually

00:36:03,440 --> 00:36:10,970
pretty efficient it we were able to pass

00:36:06,770 --> 00:36:15,230
two copies that have described in nine

00:36:10,970 --> 00:36:20,510
seconds on my laptop so it's pretty

00:36:15,230 --> 00:36:23,000
efficient and so you could say also you

00:36:20,510 --> 00:36:25,280
are done no we are not done at all

00:36:23,000 --> 00:36:28,700
because they are of course a lot of bugs

00:36:25,280 --> 00:36:30,470
in that parser I'm pretty sure that we

00:36:28,700 --> 00:36:33,370
are missing some incorrect

00:36:30,470 --> 00:36:38,030
interpretation of the specification that

00:36:33,370 --> 00:36:40,130
there are some incorrect treecko's

00:36:38,030 --> 00:36:44,990
friction in the process and so on and so

00:36:40,130 --> 00:36:48,290
forth so we are really in sizes journey

00:36:44,990 --> 00:36:50,540
in hell and what we try to achieve it's

00:36:48,290 --> 00:36:53,270
a state in which we will have a

00:36:50,540 --> 00:36:59,030
specification on the code and the code

00:36:53,270 --> 00:37:00,740
will be I never enough that the mapping

00:36:59,030 --> 00:37:02,660
between the specification of the code

00:37:00,740 --> 00:37:04,910
could be explained and shown and

00:37:02,660 --> 00:37:07,730
documented so that the next part of the

00:37:04,910 --> 00:37:11,780
specification could say oh yeah you did

00:37:07,730 --> 00:37:15,260
exactly what I was thinking when I wrote

00:37:11,780 --> 00:37:18,620
this piece of informal human natural

00:37:15,260 --> 00:37:22,370
language text so that's okay

00:37:18,620 --> 00:37:24,890
or sometimes sends us more Pro more

00:37:22,370 --> 00:37:28,160
likely it we all know you you you

00:37:24,890 --> 00:37:31,190
interpret it wrong okay so that we so

00:37:28,160 --> 00:37:33,080
our goal is to be able to be did extract

00:37:31,190 --> 00:37:35,240
some knowledge to the experts by

00:37:33,080 --> 00:37:37,820
confront by being able to explain our

00:37:35,240 --> 00:37:42,830
code to the expert and to do that we

00:37:37,820 --> 00:37:47,360
have to be our level so so that's the

00:37:42,830 --> 00:37:50,870
end I hope that you will not use not

00:37:47,360 --> 00:37:53,120
have too many nightmares tonight I thank

00:37:50,870 --> 00:37:55,190
you for your intention and at some point

00:37:53,120 --> 00:37:57,690
in June we will have the first release

00:37:55,190 --> 00:38:01,680
of of how true

00:37:57,690 --> 00:38:06,270
so if you are brave enough try it give

00:38:01,680 --> 00:38:08,960
us give us some feedbacks and thank you

00:38:06,270 --> 00:38:08,960
bye-bye

00:38:10,339 --> 00:38:21,210
question thank you for the talk are

00:38:14,730 --> 00:38:23,730
there any questions so thank you for

00:38:21,210 --> 00:38:27,869
interesting introduction to this how

00:38:23,730 --> 00:38:32,839
does this actually is going to determine

00:38:27,869 --> 00:38:39,270
or detect this send my post removal okay

00:38:32,839 --> 00:38:41,039
oh okay that's of course very good

00:38:39,270 --> 00:38:44,430
question so we seem to be and in fact

00:38:41,039 --> 00:38:46,200
few are still quite far from this final

00:38:44,430 --> 00:38:48,920
goal of being able to find such a park

00:38:46,200 --> 00:38:52,349
so deposits of course only the first

00:38:48,920 --> 00:38:54,000
element of our to chain and of course

00:38:52,349 --> 00:38:57,450
what what has to be done and the rest of

00:38:54,000 --> 00:38:59,490
the project is to building on the once

00:38:57,450 --> 00:39:02,130
we have constructed abstract or concrete

00:38:59,490 --> 00:39:03,809
syntax three offices of script to

00:39:02,130 --> 00:39:05,960
implement the tool which will do as a

00:39:03,809 --> 00:39:09,089
boring execution of the script and

00:39:05,960 --> 00:39:12,059
construct precisely what this script is

00:39:09,089 --> 00:39:14,760
doing so all the analysis which is going

00:39:12,059 --> 00:39:16,440
to happen still has to be done the

00:39:14,760 --> 00:39:18,150
parser is doing nothing of this kind

00:39:16,440 --> 00:39:20,970
it's just it's just doing a syntactic

00:39:18,150 --> 00:39:23,970
analysis and what we found so far this

00:39:20,970 --> 00:39:26,190
mr. baza is in fact we found a few few

00:39:23,970 --> 00:39:27,510
bucks and charged scripts but these

00:39:26,190 --> 00:39:29,970
could be considered quite quadrivium

00:39:27,510 --> 00:39:33,000
quite quite quite got we were to build a

00:39:29,970 --> 00:39:35,430
syntactic marks wrong wrong implications

00:39:33,000 --> 00:39:37,170
of kumar's every 5 bucks for them but

00:39:35,430 --> 00:39:39,390
these are not the box via via aiming it

00:39:37,170 --> 00:39:41,609
of course in the end we would like to

00:39:39,390 --> 00:39:43,440
find interesting stuff like the park I

00:39:41,609 --> 00:39:45,420
showed before so interesting semantic

00:39:43,440 --> 00:39:49,589
box off of the script but we are still

00:39:45,420 --> 00:39:53,930
far away from this ok fell web but we

00:39:49,589 --> 00:39:58,039
have started I mean we already have some

00:39:53,930 --> 00:40:04,099
idea how to proceed it's but no no truly

00:39:58,039 --> 00:40:04,099
ok we have the questions

00:40:04,490 --> 00:40:15,050
I don't have actually a question I just

00:40:13,040 --> 00:40:17,480
have a compliment this is the mode this

00:40:15,050 --> 00:40:19,369
was the most sickest shellcode I have

00:40:17,480 --> 00:40:24,460
ever I have seen in years

00:40:19,369 --> 00:40:24,460
who's that my lap miss you have shop war

00:40:24,490 --> 00:40:36,290
thank you given how difficult it is to

00:40:34,250 --> 00:40:38,930
pass gel should we be using a different

00:40:36,290 --> 00:40:49,369
language for our post instant post our

00:40:38,930 --> 00:40:51,710
own scripts yes I think so

00:40:49,369 --> 00:40:52,849
but in fact the question comes up from

00:40:51,710 --> 00:40:57,080
time to time or the different mailing

00:40:52,849 --> 00:40:59,180
lists I think yes we need something

00:40:57,080 --> 00:41:03,589
better but the question is of course

00:40:59,180 --> 00:41:05,960
what and obviously the question is how

00:41:03,589 --> 00:41:08,480
can you balance simplicity of the

00:41:05,960 --> 00:41:10,609
language with the need for express X

00:41:08,480 --> 00:41:12,349
passivity and some and some corner cases

00:41:10,609 --> 00:41:14,720
so sometimes you really have to do

00:41:12,349 --> 00:41:18,349
complicated stuff and then you need a

00:41:14,720 --> 00:41:20,510
quite powerful language and the question

00:41:18,349 --> 00:41:22,490
is how can you control a weakened

00:41:20,510 --> 00:41:24,500
scientist there's the need for something

00:41:22,490 --> 00:41:26,750
which is really simple and declarative

00:41:24,500 --> 00:41:29,000
and easy to understand so it's not

00:41:26,750 --> 00:41:30,710
obvious I think well so the short answer

00:41:29,000 --> 00:41:33,170
is yes we need a better a better way to

00:41:30,710 --> 00:41:35,180
what maintainer scripts but it's far

00:41:33,170 --> 00:41:36,780
from obvious how this language could

00:41:35,180 --> 00:41:43,280
look like

00:41:36,780 --> 00:41:45,920
[Music]

00:41:43,280 --> 00:41:49,510
could you define a subset of the basics

00:41:45,920 --> 00:41:54,940
of the POSIX specification that would

00:41:49,510 --> 00:41:57,650
allow you to to check the scripts a

00:41:54,940 --> 00:41:59,600
subset of the specification that is

00:41:57,650 --> 00:42:04,490
compatible with all the already written

00:41:59,600 --> 00:42:07,520
maintenance scripts so what we did is

00:42:04,490 --> 00:42:12,410
some statistical analysis using this

00:42:07,520 --> 00:42:16,310
parser and well there are some patterns

00:42:12,410 --> 00:42:18,650
that comes back every time and there are

00:42:16,310 --> 00:42:20,570
surely some corner case of shell scripts

00:42:18,650 --> 00:42:25,670
that are not used by programmer because

00:42:20,570 --> 00:42:27,770
they are not all crazy so it's yes it's

00:42:25,670 --> 00:42:31,640
likely that there exists a subset of

00:42:27,770 --> 00:42:33,980
shells that capture almost all the

00:42:31,640 --> 00:42:37,600
scripts and the remaining scripts should

00:42:33,980 --> 00:42:41,990
be rewritten anyway because they are too

00:42:37,600 --> 00:42:44,450
complex to be maintained a pathological

00:42:41,990 --> 00:42:46,280
case that can show to you see alias

00:42:44,450 --> 00:42:49,100
which happened conditionally in two

00:42:46,280 --> 00:42:51,050
cases so this does not occur in Debian

00:42:49,100 --> 00:42:52,850
in the corpus of Debian maintainer

00:42:51,050 --> 00:42:55,730
scripts luckily so we were very glad

00:42:52,850 --> 00:42:57,860
about that and in fact our mobic parser

00:42:55,730 --> 00:43:00,110
as Yun explained this case it cannot be

00:42:57,860 --> 00:43:02,570
treated statically so in fact the more

00:43:00,110 --> 00:43:07,220
passive would put would refuse such a

00:43:02,570 --> 00:43:09,400
such a shell script okay and we used in

00:43:07,220 --> 00:43:13,310
fact the parser in to do some

00:43:09,400 --> 00:43:15,890
statistical analysis I we don't have

00:43:13,310 --> 00:43:18,800
anything to show you the results of this

00:43:15,890 --> 00:43:22,370
today but we hope to be able to show it

00:43:18,800 --> 00:43:24,410
to you at Epcon of this year in in in

00:43:22,370 --> 00:43:26,920
august but we will come again

00:43:24,410 --> 00:43:29,750
I hope and presenting side of this

00:43:26,920 --> 00:43:31,870
statistical not static statistical

00:43:29,750 --> 00:43:35,440
analysis of the corpus of

00:43:31,870 --> 00:43:35,440
[Music]

00:43:40,420 --> 00:43:43,619
[Music]

00:43:44,950 --> 00:43:53,290

YouTube URL: https://www.youtube.com/watch?v=1fNsO7Lgfnw


