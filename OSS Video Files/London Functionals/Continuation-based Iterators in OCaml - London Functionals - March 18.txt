Title: Continuation-based Iterators in OCaml - London Functionals - March 18
Publication date: 2018-03-19
Playlist: London Functionals
Description: 
	Rizo Isrof

Continuation-based iterators: pure, safe and fast
Captions: 
	00:00:00,000 --> 00:00:04,890
I'm gonna be talking about iterators

00:00:02,040 --> 00:00:08,760
today you know camel how many of you are

00:00:04,890 --> 00:00:10,860
familiar with the camel oh okay that's a

00:00:08,760 --> 00:00:13,590
big chunk of here that's really good

00:00:10,860 --> 00:00:16,710
so as you know a camel is an impure

00:00:13,590 --> 00:00:19,439
statically typed functional language and

00:00:16,710 --> 00:00:22,439
a common standard library doesn't

00:00:19,439 --> 00:00:26,099
include any built-in iterators it only

00:00:22,439 --> 00:00:30,060
has lists and lists are strict so non

00:00:26,099 --> 00:00:32,160
lazy evaluated in place lists they can

00:00:30,060 --> 00:00:34,110
be infinite in some specific cases if

00:00:32,160 --> 00:00:35,510
it's like a self repeating sequence or

00:00:34,110 --> 00:00:39,930
something but otherwise they're like

00:00:35,510 --> 00:00:41,940
using up your memory so usually when it

00:00:39,930 --> 00:00:43,620
comes to iterators people use libraries

00:00:41,940 --> 00:00:47,059
third-party libraries that implement

00:00:43,620 --> 00:00:51,660
some form of an abstraction model that

00:00:47,059 --> 00:00:54,420
maybe encodes like lazy lists or some

00:00:51,660 --> 00:00:56,550
form of sequences generators and I'm

00:00:54,420 --> 00:00:58,350
gonna be talking about these things and

00:00:56,550 --> 00:01:03,030
I'm gonna be explaining the differences

00:00:58,350 --> 00:01:04,680
between the fundamental models and the

00:01:03,030 --> 00:01:06,630
interesting observations that I can make

00:01:04,680 --> 00:01:09,780
about the models that I'm about to

00:01:06,630 --> 00:01:13,790
present is that most of them are non

00:01:09,780 --> 00:01:16,710
pure they're mutable they use exceptions

00:01:13,790 --> 00:01:19,979
references so not something that would

00:01:16,710 --> 00:01:22,530
like to present like you know Haskell me

00:01:19,979 --> 00:01:24,900
talk so to say so I'm gonna try to

00:01:22,530 --> 00:01:28,110
improve them so bear with me I'm gonna

00:01:24,900 --> 00:01:33,439
try to take these models and beat by

00:01:28,110 --> 00:01:35,549
beat make them less impure more pure and

00:01:33,439 --> 00:01:37,799
at the same time I'm going to introduce

00:01:35,549 --> 00:01:39,810
some safety mechanisms and potentially

00:01:37,799 --> 00:01:41,820
even improve their performance this

00:01:39,810 --> 00:01:44,939
talks includes a lot of code so I'm

00:01:41,820 --> 00:01:47,670
gonna be moving fast ask questions if

00:01:44,939 --> 00:01:49,890
you don't understand something I'm not

00:01:47,670 --> 00:01:53,119
expecting you to follow every single

00:01:49,890 --> 00:01:56,549
line of code just focus on the ideas and

00:01:53,119 --> 00:02:00,600
the models I guess and do ask questions

00:01:56,549 --> 00:02:02,729
please so this talk is not actually

00:02:00,600 --> 00:02:04,530
about iterators or anything it's it's

00:02:02,729 --> 00:02:06,600
more about like fundamental ideas that

00:02:04,530 --> 00:02:07,950
we have in computer science functional

00:02:06,600 --> 00:02:11,500
programming or camel or Haskell or

00:02:07,950 --> 00:02:13,330
whatever it's about functions and

00:02:11,500 --> 00:02:15,880
now that I'm thinking about this after

00:02:13,330 --> 00:02:18,280
the first dog by Ben and I'm thinking

00:02:15,880 --> 00:02:21,280
this dog is actually about fold again so

00:02:18,280 --> 00:02:23,290
it's all folds it's all just folds and

00:02:21,280 --> 00:02:29,950
I'm hoping that you will see this

00:02:23,290 --> 00:02:32,770
pattern here so this is a type you know

00:02:29,950 --> 00:02:35,830
camel and it says I'm expecting a unit

00:02:32,770 --> 00:02:37,270
and I want something of type a this is

00:02:35,830 --> 00:02:41,290
like a generic type for those of you who

00:02:37,270 --> 00:02:41,830
don't know a camel and what can we say

00:02:41,290 --> 00:02:44,950
about this

00:02:41,830 --> 00:02:46,959
so in Haskell of course I think this

00:02:44,950 --> 00:02:49,540
function is like kind of impossible

00:02:46,959 --> 00:02:51,760
right like you can you have to rise an

00:02:49,540 --> 00:02:53,410
exception or like use undefined or

00:02:51,760 --> 00:02:55,690
whatever but you know camel you can

00:02:53,410 --> 00:02:57,970
specialize this function to integers for

00:02:55,690 --> 00:03:00,520
example and return like random integers

00:02:57,970 --> 00:03:02,770
because it's not pure so you can you

00:03:00,520 --> 00:03:05,200
know read stuff from the standard input

00:03:02,770 --> 00:03:07,090
and just throw the intercepts to the

00:03:05,200 --> 00:03:08,860
user what I was saying is that if you

00:03:07,090 --> 00:03:10,900
specialize this function to integers so

00:03:08,860 --> 00:03:12,640
like unit int in that case you can

00:03:10,900 --> 00:03:14,770
produce integers in Haskell you can

00:03:12,640 --> 00:03:16,209
produce one integer but you know can we

00:03:14,770 --> 00:03:19,420
can produce multiple integer so the

00:03:16,209 --> 00:03:22,300
whole domain of integers and this this

00:03:19,420 --> 00:03:24,070
function represents like the basic idea

00:03:22,300 --> 00:03:25,830
of the pool based model so you ask for

00:03:24,070 --> 00:03:32,080
something in it you get something back

00:03:25,830 --> 00:03:34,360
so if we let's assume that this function

00:03:32,080 --> 00:03:37,000
kind of produces values that we need so

00:03:34,360 --> 00:03:39,370
it's like a very primitive form of

00:03:37,000 --> 00:03:42,510
iteration so to say how can we make it

00:03:39,370 --> 00:03:45,489
stop like we need to give it a way to

00:03:42,510 --> 00:03:48,010
terminate its execution signal that I'm

00:03:45,489 --> 00:03:51,040
done how would you usually do this so

00:03:48,010 --> 00:03:52,870
another way to terminate a function and

00:03:51,040 --> 00:03:54,459
say like I'm done I don't want to leave

00:03:52,870 --> 00:03:56,650
it at this world anymore so just throw

00:03:54,459 --> 00:03:58,150
an exception and by just using this

00:03:56,650 --> 00:04:00,580
primitive model let's see what we can

00:03:58,150 --> 00:04:05,440
build that kind of resembles what

00:04:00,580 --> 00:04:07,989
iterators can be so we have eater and as

00:04:05,440 --> 00:04:10,150
you can see the type is unit a we define

00:04:07,989 --> 00:04:13,420
an exception stop iteration we have a

00:04:10,150 --> 00:04:15,910
global mutable reference and then we

00:04:13,420 --> 00:04:18,519
have count as a function and it

00:04:15,910 --> 00:04:21,700
dereference is the current value check

00:04:18,519 --> 00:04:23,410
if checks if that element is greater

00:04:21,700 --> 00:04:24,650
than or equal to 3 and then rise is an

00:04:23,410 --> 00:04:26,720
exception and

00:04:24,650 --> 00:04:32,930
increments the reference and returns

00:04:26,720 --> 00:04:36,889
that so okay how do we use it well we

00:04:32,930 --> 00:04:39,020
can call it so you saw that the type is

00:04:36,889 --> 00:04:41,630
this which means that we can essentially

00:04:39,020 --> 00:04:43,759
just call it and we get zero and then

00:04:41,630 --> 00:04:48,860
one and two and then once it's finished

00:04:43,759 --> 00:04:52,160
it just you know Rises an exception okay

00:04:48,860 --> 00:04:55,490
so this is brilliant right

00:04:52,160 --> 00:04:57,320
we have mutable state exceptions notice

00:04:55,490 --> 00:04:58,039
that this if doesn't even have an else

00:04:57,320 --> 00:05:01,220
statement

00:04:58,039 --> 00:05:03,949
this is just okay but I promised that I

00:05:01,220 --> 00:05:06,410
would try to improve you know these kind

00:05:03,949 --> 00:05:08,360
of models and iteration you know Carmel

00:05:06,410 --> 00:05:09,919
in general so let's let's see if we can

00:05:08,360 --> 00:05:14,090
do something better let's follow your

00:05:09,919 --> 00:05:15,710
advice and let's use options and this is

00:05:14,090 --> 00:05:18,710
actually the type used by one of the

00:05:15,710 --> 00:05:21,289
very popular akarma libraries called gen

00:05:18,710 --> 00:05:23,389
that implements this kind of iterators

00:05:21,289 --> 00:05:24,770
so Bowl based iterators give me

00:05:23,389 --> 00:05:27,259
something i have nothing

00:05:24,770 --> 00:05:29,510
iterators let's see how we can really

00:05:27,259 --> 00:05:33,710
find the count function using this this

00:05:29,510 --> 00:05:36,110
abstraction now this looks better we no

00:05:33,710 --> 00:05:39,830
longer have the global mutable reference

00:05:36,110 --> 00:05:43,250
at least so we don't have exceptions

00:05:39,830 --> 00:05:47,060
which is even better but we still have

00:05:43,250 --> 00:05:50,510
the local mutable state right so this

00:05:47,060 --> 00:05:52,669
function can be used by well first of

00:05:50,510 --> 00:05:54,289
all creating initializing the iterator

00:05:52,669 --> 00:05:55,970
and then calling it a few times and when

00:05:54,289 --> 00:06:00,289
I reach done it is gonna repeat none

00:05:55,970 --> 00:06:02,960
forever and now that we know how to get

00:06:00,289 --> 00:06:04,699
the elements out of this pattern let's

00:06:02,960 --> 00:06:10,699
implement something more functional like

00:06:04,699 --> 00:06:13,630
a fold so this is a fold it takes an

00:06:10,699 --> 00:06:16,220
iterator it requests for more elements

00:06:13,630 --> 00:06:18,380
if the iterator is empty then we just

00:06:16,220 --> 00:06:22,250
return the result otherwise we continue

00:06:18,380 --> 00:06:24,770
the recursion expecting the iterator to

00:06:22,250 --> 00:06:28,789
produce a new element next because it

00:06:24,770 --> 00:06:31,099
has internal mutable state right this

00:06:28,789 --> 00:06:33,650
map definition for example uses local

00:06:31,099 --> 00:06:35,500
references the only way that map has to

00:06:33,650 --> 00:06:38,240
communicate its termination is by

00:06:35,500 --> 00:06:41,060
checking if the inner

00:06:38,240 --> 00:06:43,610
iterator stopped so this is why we have

00:06:41,060 --> 00:06:46,729
the stop flag here initially it's false

00:06:43,610 --> 00:06:49,370
but then once the inner iterator is none

00:06:46,729 --> 00:06:51,530
we say that stop is true so we stop the

00:06:49,370 --> 00:06:53,259
map itself as well okay so with this we

00:06:51,530 --> 00:06:57,590
can actually write some functional code

00:06:53,259 --> 00:07:00,979
underneath it's kind of mutable ugly or

00:06:57,590 --> 00:07:03,169
camel but this is you probably know this

00:07:00,979 --> 00:07:06,259
kind of forward type forward application

00:07:03,169 --> 00:07:14,210
operator we have a nice functional

00:07:06,259 --> 00:07:16,220
interface so why why can why why do we

00:07:14,210 --> 00:07:17,990
have to use this mutable state in most

00:07:16,220 --> 00:07:20,539
cases maybe not map

00:07:17,990 --> 00:07:22,190
not in my but in other cases and the

00:07:20,539 --> 00:07:26,300
type itself is just not flexible right

00:07:22,190 --> 00:07:28,520
like this type I mean it kind of asks

00:07:26,300 --> 00:07:33,440
for mutable state this is something used

00:07:28,520 --> 00:07:34,940
by rust I think pythons iterators are

00:07:33,440 --> 00:07:36,710
very similar to this you just keep

00:07:34,940 --> 00:07:39,770
asking for more and more iterator

00:07:36,710 --> 00:07:42,080
elements you get the exception when the

00:07:39,770 --> 00:07:44,000
iterator is done but anyway we already

00:07:42,080 --> 00:07:47,240
improve this but can we do better I

00:07:44,000 --> 00:07:49,280
think so but before actually go into the

00:07:47,240 --> 00:07:50,030
improvements to this type let me talk

00:07:49,280 --> 00:07:52,099
about something else

00:07:50,030 --> 00:07:54,440
so what do you think it's the opposite

00:07:52,099 --> 00:07:58,250
of this type may be ignore the option

00:07:54,440 --> 00:07:59,810
here well the opposite is like consuming

00:07:58,250 --> 00:08:02,960
elements instead of producing elements

00:07:59,810 --> 00:08:05,330
and it might seem that it's like the

00:08:02,960 --> 00:08:08,800
opposite of iteration but it's just a

00:08:05,330 --> 00:08:11,330
different type of iteration and it's

00:08:08,800 --> 00:08:14,900
iteration that is based on the push

00:08:11,330 --> 00:08:17,389
model so instead of requesting four

00:08:14,900 --> 00:08:19,280
elements we supply a function that will

00:08:17,389 --> 00:08:22,310
get the elements as soon as the producer

00:08:19,280 --> 00:08:27,710
has them potentially all of them which

00:08:22,310 --> 00:08:31,550
is really important so then this type is

00:08:27,710 --> 00:08:34,250
not flexible enough to implement actual

00:08:31,550 --> 00:08:37,339
iterators but if we look at this one I

00:08:34,250 --> 00:08:39,440
think this is good enough and in this

00:08:37,339 --> 00:08:41,270
case we have a function that takes

00:08:39,440 --> 00:08:43,969
another function as an argument and this

00:08:41,270 --> 00:08:46,670
function here the first argument is a

00:08:43,969 --> 00:08:49,329
consumer so it's like a callback this

00:08:46,670 --> 00:08:53,000
thing here is a continuation

00:08:49,329 --> 00:08:56,350
specialized to the unit result-type okay

00:08:53,000 --> 00:09:00,019
so we take this callback function and

00:08:56,350 --> 00:09:02,779
expect the whole function to give us

00:09:00,019 --> 00:09:05,870
elements of type a and then something

00:09:02,779 --> 00:09:09,800
will happen so it's like a dev know like

00:09:05,870 --> 00:09:14,389
a black hole for values the consumer

00:09:09,800 --> 00:09:15,769
function now let's do exactly the same

00:09:14,389 --> 00:09:20,240
thing and try to implement count with

00:09:15,769 --> 00:09:22,069
this we have our type so the iterator is

00:09:20,240 --> 00:09:25,970
something that takes a consumer and then

00:09:22,069 --> 00:09:27,529
returns unit this is how we define count

00:09:25,970 --> 00:09:31,759
the function that I showed you

00:09:27,529 --> 00:09:36,550
previously for loops you don't have

00:09:31,759 --> 00:09:39,680
those in Haskell so as you can see this

00:09:36,550 --> 00:09:43,399
function this.k argument here is the

00:09:39,680 --> 00:09:46,040
continuation function so it's the

00:09:43,399 --> 00:09:49,399
consumer and we eat right on the numbers

00:09:46,040 --> 00:09:51,800
from zero to two including two and we

00:09:49,399 --> 00:09:53,740
just send them down to K and I can do

00:09:51,800 --> 00:09:57,170
with them whatever it wants you know

00:09:53,740 --> 00:10:00,380
it's not the producers responsibility to

00:09:57,170 --> 00:10:03,410
decide what has to be done so now we

00:10:00,380 --> 00:10:07,009
initialize this counter and we can call

00:10:03,410 --> 00:10:09,040
it we just supply the function that you

00:10:07,009 --> 00:10:12,529
know much is the types and it just works

00:10:09,040 --> 00:10:18,139
now how can we get the elements out of

00:10:12,529 --> 00:10:23,600
this thing like the type returns unit

00:10:18,139 --> 00:10:26,380
like we are forced to use mutability

00:10:23,600 --> 00:10:34,040
again so let's look at some functions

00:10:26,380 --> 00:10:36,990
like filter type and fold can you not

00:10:34,040 --> 00:10:40,050
use references in this case

00:10:36,990 --> 00:10:43,649
mmm-hmm what about this one like I think

00:10:40,050 --> 00:10:45,810
that the only way to extract something

00:10:43,649 --> 00:10:48,390
that is happening inside this consumer

00:10:45,810 --> 00:10:51,839
is to use a reference so we initialize a

00:10:48,390 --> 00:10:54,720
reference to the accumulator we run our

00:10:51,839 --> 00:10:58,170
computation trusting our producer to

00:10:54,720 --> 00:11:02,399
give us elements and then once that is

00:10:58,170 --> 00:11:05,250
done we have the updated result right

00:11:02,399 --> 00:11:07,520
and take is a bit more complicated I'm

00:11:05,250 --> 00:11:12,000
not going to talk about that but yeah

00:11:07,520 --> 00:11:14,820
okay so what is this pull based

00:11:12,000 --> 00:11:18,390
iterators and push based iterators like

00:11:14,820 --> 00:11:20,760
two completely opposite models to

00:11:18,390 --> 00:11:22,459
achieve mostly the same thing so each

00:11:20,760 --> 00:11:25,529
one of them has their own like

00:11:22,459 --> 00:11:28,459
advantages and limitations the most

00:11:25,529 --> 00:11:30,990
common one is the ability to zip

00:11:28,459 --> 00:11:32,880
sequences so for example with push based

00:11:30,990 --> 00:11:35,760
iterators is extremely hard to zip

00:11:32,880 --> 00:11:38,010
things because the producer is in charge

00:11:35,760 --> 00:11:40,380
and the producer decides when to send

00:11:38,010 --> 00:11:41,850
elements so we'd have to wait for one of

00:11:40,380 --> 00:11:45,149
the producers to give you the second

00:11:41,850 --> 00:11:50,370
element to zip the pair of of those

00:11:45,149 --> 00:11:55,790
forward and I I was thinking about this

00:11:50,370 --> 00:11:57,930
limitation and and I decided to

00:11:55,790 --> 00:12:01,200
implement something that would support

00:11:57,930 --> 00:12:03,029
this ability to zip and of course pull

00:12:01,200 --> 00:12:05,459
iterator support zipping because at any

00:12:03,029 --> 00:12:07,020
point of time you can ask the to eat

00:12:05,459 --> 00:12:09,089
writers to give you the next element and

00:12:07,020 --> 00:12:13,740
once you have those you can kind of

00:12:09,089 --> 00:12:14,190
yield the pair why why did I want to do

00:12:13,740 --> 00:12:16,709
this

00:12:14,190 --> 00:12:18,240
well because pull iterators are slow the

00:12:16,709 --> 00:12:20,459
reason pulley tracers are slow because

00:12:18,240 --> 00:12:22,680
they allocate an extra boxed value

00:12:20,459 --> 00:12:25,620
optional value for every single element

00:12:22,680 --> 00:12:27,390
that they produce and that goes to the

00:12:25,620 --> 00:12:30,149
heap and then the garbage collector is

00:12:27,390 --> 00:12:32,670
woken up and you know it's complicated

00:12:30,149 --> 00:12:34,290
while push-based iterators don't suffer

00:12:32,670 --> 00:12:37,910
from that problem as you were saying

00:12:34,290 --> 00:12:41,130
it's just function composition so I

00:12:37,910 --> 00:12:42,810
decided to do this kind of small

00:12:41,130 --> 00:12:45,600
experiment and see if I could improve

00:12:42,810 --> 00:12:47,190
pull based et writers using some

00:12:45,600 --> 00:12:49,800
techniques to learn from the push-based

00:12:47,190 --> 00:12:53,760
in traders and just for come

00:12:49,800 --> 00:12:56,160
witness pool by sea traitors are also

00:12:53,760 --> 00:12:58,830
called external iterators and push by

00:12:56,160 --> 00:13:01,470
sintering iterators are sometimes also

00:12:58,830 --> 00:13:03,540
called internal aerials so what is the

00:13:01,470 --> 00:13:05,279
kind of ideal model that I'm trying to

00:13:03,540 --> 00:13:06,750
achieve and I think now that I'm that

00:13:05,279 --> 00:13:08,820
we've discussed this kind of trade-offs

00:13:06,750 --> 00:13:10,709
this is a bit incomplete because yeah of

00:13:08,820 --> 00:13:14,010
course I'm focusing like on pole by city

00:13:10,709 --> 00:13:17,220
writers data structures but in general I

00:13:14,010 --> 00:13:19,589
wanted them to be pure I'm not really

00:13:17,220 --> 00:13:21,149
sure why honestly I think you know camo

00:13:19,589 --> 00:13:22,380
people usually don't ask these kind of

00:13:21,149 --> 00:13:23,700
questions like if you have to use

00:13:22,380 --> 00:13:27,120
references go ahead

00:13:23,700 --> 00:13:28,709
exceptions for control flow why not but

00:13:27,120 --> 00:13:34,500
I mean this was just like an experiment

00:13:28,709 --> 00:13:37,399
so and it kind of fits the Pasco meetup

00:13:34,500 --> 00:13:41,579
being as well I wanted good performance

00:13:37,399 --> 00:13:45,089
safety so closing file descriptors for

00:13:41,579 --> 00:13:47,700
example if needed lazy on demand any

00:13:45,089 --> 00:13:49,950
initialization of those resources early

00:13:47,700 --> 00:13:51,300
termination by consumers and educational

00:13:49,950 --> 00:13:54,390
termination by producer you might know

00:13:51,300 --> 00:13:57,480
this one this - from pipes or conduits

00:13:54,390 --> 00:13:59,610
if you use them and the interface that I

00:13:57,480 --> 00:14:05,279
implemented is similar to this one so

00:13:59,610 --> 00:14:07,140
it's a very basic streaming model the

00:14:05,279 --> 00:14:09,959
interesting bit is that take forces

00:14:07,140 --> 00:14:12,510
early termination fold is the consumer

00:14:09,959 --> 00:14:15,870
filter well doesn't go through the

00:14:12,510 --> 00:14:20,910
doesn't pass all the elements to the

00:14:15,870 --> 00:14:23,459
consumers so I mentioned that we were

00:14:20,910 --> 00:14:26,480
going to try to improve this type so the

00:14:23,459 --> 00:14:29,190
pool based it writers and I decided to

00:14:26,480 --> 00:14:32,760
play with it and the first thing that I

00:14:29,190 --> 00:14:36,000
tried was to introduce this explicit

00:14:32,760 --> 00:14:38,430
state so leave the state to the type

00:14:36,000 --> 00:14:41,670
level and make it part of the

00:14:38,430 --> 00:14:46,350
declaration we have the initial state

00:14:41,670 --> 00:14:49,050
there so if we are iterating on a list

00:14:46,350 --> 00:14:52,800
for example that's the list that we have

00:14:49,050 --> 00:14:54,890
next is the function that expects the

00:14:52,800 --> 00:14:58,829
current list or the current state and

00:14:54,890 --> 00:15:03,209
produces an element from that list and

00:14:58,829 --> 00:15:04,619
also the next version of the state so

00:15:03,209 --> 00:15:07,769
that we can continuously get the

00:15:04,619 --> 00:15:10,790
elements out of the state or otherwise

00:15:07,769 --> 00:15:16,529
it just stops saying none and that means

00:15:10,790 --> 00:15:20,459
the producer is done this is how we can

00:15:16,529 --> 00:15:23,850
implement count with this model I think

00:15:20,459 --> 00:15:28,110
it looks nice what do you think it's

00:15:23,850 --> 00:15:31,519
pretty simple so we define the next

00:15:28,110 --> 00:15:34,980
function that essentially expects an eye

00:15:31,519 --> 00:15:37,709
for a counter I guess if it's end and

00:15:34,980 --> 00:15:39,869
just return none otherwise we yield the

00:15:37,709 --> 00:15:44,970
eye itself and increment the state and

00:15:39,869 --> 00:15:46,319
the initial state is zero okay so now I

00:15:44,970 --> 00:15:48,779
also mentioned that we want to make this

00:15:46,319 --> 00:15:50,699
safe so I decided to include the these

00:15:48,779 --> 00:15:53,009
two helper functions the init and free

00:15:50,699 --> 00:15:56,040
in it protects the state from being

00:15:53,009 --> 00:15:58,259
unnecessary unnecessarily initialized so

00:15:56,040 --> 00:16:01,220
for example if you create an iterator

00:15:58,259 --> 00:16:03,509
and then immediately say like take zero

00:16:01,220 --> 00:16:05,660
well the producer is not going to even

00:16:03,509 --> 00:16:08,369
open the state in the first place and

00:16:05,660 --> 00:16:10,439
free of course just releases the the

00:16:08,369 --> 00:16:15,170
site closest the websocket for example

00:16:10,439 --> 00:16:15,170
or there's some other additional work

00:16:15,889 --> 00:16:22,589
this is how you implement fold with this

00:16:19,049 --> 00:16:24,240
and I'm using the common in Haskell

00:16:22,589 --> 00:16:26,220
bracket pattern to make sure that

00:16:24,240 --> 00:16:28,980
whatever happens inside this lopes in

00:16:26,220 --> 00:16:32,970
inside this loop is always properly

00:16:28,980 --> 00:16:35,879
initialized and cleaned but otherwise I

00:16:32,970 --> 00:16:38,249
think it's pretty straightforward okay

00:16:35,879 --> 00:16:40,639
so what is the problem with this I was

00:16:38,249 --> 00:16:44,040
very happy about this I mean it's not

00:16:40,639 --> 00:16:45,980
massive improvement but it's pure at

00:16:44,040 --> 00:16:50,399
least it has better performance than

00:16:45,980 --> 00:16:53,670
original pull based iterators for the

00:16:50,399 --> 00:16:56,100
general case at least what was happening

00:16:53,670 --> 00:16:58,740
here compared to the push-based

00:16:56,100 --> 00:17:02,309
iterators this was still incredibly

00:16:58,740 --> 00:17:04,620
incredibly slow so as I was researching

00:17:02,309 --> 00:17:08,279
some other ideas I came up with this I

00:17:04,620 --> 00:17:10,740
found this thing called scoring coding

00:17:08,279 --> 00:17:13,860
and this is very similar to charting

00:17:10,740 --> 00:17:15,779
coding which essentially allows you to

00:17:13,860 --> 00:17:18,869
represent a data structure

00:17:15,779 --> 00:17:20,579
as a set of functions I guess functions

00:17:18,869 --> 00:17:22,319
that simulate the data structure instead

00:17:20,579 --> 00:17:23,909
of being the data structure so it's

00:17:22,319 --> 00:17:25,949
focused on the behavior and not the

00:17:23,909 --> 00:17:27,689
structure so the difference between

00:17:25,949 --> 00:17:33,869
coding coding and chart encoding by the

00:17:27,689 --> 00:17:36,269
way is that coding coding uses uses the

00:17:33,869 --> 00:17:38,519
type itself so it's self references

00:17:36,269 --> 00:17:41,899
recursively while in church encoding I

00:17:38,519 --> 00:17:44,940
think lists are like fold rights

00:17:41,899 --> 00:17:46,469
essentially the reason I have this like

00:17:44,940 --> 00:17:49,289
in Haskell is because if you search for

00:17:46,469 --> 00:17:50,580
Scott encoding and accommo the only

00:17:49,289 --> 00:17:53,309
thing that you'll find is like Haskell

00:17:50,580 --> 00:17:54,450
essentially all over the body so but of

00:17:53,309 --> 00:18:00,299
course we can just translate this to a

00:17:54,450 --> 00:18:02,729
comma sorry about that okay so this type

00:18:00,299 --> 00:18:04,139
has a function called view the reason

00:18:02,729 --> 00:18:06,839
I'm using is trucks by the way is

00:18:04,139 --> 00:18:08,909
because we need or at least prefer this

00:18:06,839 --> 00:18:13,889
R type the result type of this whole

00:18:08,909 --> 00:18:17,429
thing to be a universal type and then

00:18:13,889 --> 00:18:21,389
this view function accepts two arguments

00:18:17,429 --> 00:18:23,729
are for the neal case and cons for the

00:18:21,389 --> 00:18:25,589
non neal case I guess for when you have

00:18:23,729 --> 00:18:31,109
the elements and it's easier to

00:18:25,589 --> 00:18:34,190
understand with the example so this is

00:18:31,109 --> 00:18:37,679
wrong by the way should be one this is

00:18:34,190 --> 00:18:40,349
regular pattern matching on lists you

00:18:37,679 --> 00:18:44,159
just check if the list is empty zero in

00:18:40,349 --> 00:18:46,589
that case otherwise one plus recursively

00:18:44,159 --> 00:18:48,539
the length of the tail with this view

00:18:46,589 --> 00:18:50,519
function you do exactly the same thing

00:18:48,539 --> 00:18:53,669
but you don't have to party much you

00:18:50,519 --> 00:18:56,609
supply the value for the default case

00:18:53,669 --> 00:18:59,249
the case in which the list is empty and

00:18:56,609 --> 00:19:02,279
you supply a function that expects X

00:18:59,249 --> 00:19:05,429
being the element of the list that one

00:19:02,279 --> 00:19:09,239
and access the type itself so that one

00:19:05,429 --> 00:19:11,460
you can't use axis on its own because

00:19:09,239 --> 00:19:17,239
it's again this kind of abstract not

00:19:11,460 --> 00:19:20,129
obstruct but obstructed type and you

00:19:17,239 --> 00:19:24,629
recursively call Lang again in this cons

00:19:20,129 --> 00:19:27,869
function so why should we care about

00:19:24,629 --> 00:19:28,950
this well for me the answer to this

00:19:27,869 --> 00:19:32,130
question was performed

00:19:28,950 --> 00:19:37,410
essentially so by using this functional

00:19:32,130 --> 00:19:40,050
obstruction we avoid avoid any runtime

00:19:37,410 --> 00:19:43,440
allocations on the heap and thus get

00:19:40,050 --> 00:19:47,730
better execution times how can we use

00:19:43,440 --> 00:19:49,260
this type well this is how you can

00:19:47,730 --> 00:19:50,640
construct Neil and cones and you can

00:19:49,260 --> 00:19:52,950
figure out the left or the rest I guess

00:19:50,640 --> 00:19:57,630
you can using these two functions you

00:19:52,950 --> 00:20:00,510
can build up lists from any other data

00:19:57,630 --> 00:20:04,410
structure or source in general so Neil

00:20:00,510 --> 00:20:05,790
for example just ignores the F because

00:20:04,410 --> 00:20:07,620
it knows that it's empty it's the

00:20:05,790 --> 00:20:14,010
definition of the empty list and returns

00:20:07,620 --> 00:20:16,500
R so we get zero if we call that cons on

00:20:14,010 --> 00:20:18,390
the other hand ignores the R because it

00:20:16,500 --> 00:20:20,910
knows that it at least has one element

00:20:18,390 --> 00:20:25,440
which is X and then the continuation the

00:20:20,910 --> 00:20:29,160
tail of the list is L here so in that

00:20:25,440 --> 00:20:30,330
case it's gonna be 1 and so on now I was

00:20:29,160 --> 00:20:33,840
looking at this and I was really

00:20:30,330 --> 00:20:35,790
impressed and I decided to merge the

00:20:33,840 --> 00:20:42,990
initial type that I had with this and I

00:20:35,790 --> 00:20:45,810
came up with this type okay so let me

00:20:42,990 --> 00:20:49,920
explain step by step what it does or

00:20:45,810 --> 00:20:51,480
what it is you need and free are pretty

00:20:49,920 --> 00:20:54,870
much the same from the previous slides

00:20:51,480 --> 00:20:58,530
next it's a bit different so next next

00:20:54,870 --> 00:21:00,900
is accepting the current or initial

00:20:58,530 --> 00:21:02,730
state the current or initial result and

00:21:00,900 --> 00:21:04,530
then it has this stepping function and

00:21:02,730 --> 00:21:08,100
the role of the stepping function is to

00:21:04,530 --> 00:21:11,100
essentially take the next element from

00:21:08,100 --> 00:21:13,890
the state it's given the next element

00:21:11,100 --> 00:21:17,060
from the state and it's given the next

00:21:13,890 --> 00:21:19,500
state and it produces the next result

00:21:17,060 --> 00:21:23,640
which is the one that will be returned

00:21:19,500 --> 00:21:26,370
here now the interesting bit is that

00:21:23,640 --> 00:21:31,860
this S has the similar a similar role to

00:21:26,370 --> 00:21:34,500
the list that we have here it only

00:21:31,860 --> 00:21:36,950
exists there to allow our stepping

00:21:34,500 --> 00:21:41,130
function to eventually call next again

00:21:36,950 --> 00:21:42,900
with a new are and with a new S so it

00:21:41,130 --> 00:21:47,280
drives the

00:21:42,900 --> 00:21:51,990
continues okay so now this is how our

00:21:47,280 --> 00:21:56,750
map looks in this model so this is kind

00:21:51,990 --> 00:21:59,040
of identical to pattern matching or

00:21:56,750 --> 00:22:02,940
Karrimor frizam as you usually say in

00:21:59,040 --> 00:22:07,250
Haskell so i'm destructing this state

00:22:02,940 --> 00:22:07,250
with the next so the view or the

00:22:08,390 --> 00:22:14,880
unconscionable that it has so far and

00:22:11,460 --> 00:22:17,730
I'm expecting this step function to get

00:22:14,880 --> 00:22:22,610
an element the next step and then

00:22:17,730 --> 00:22:22,610
finally it calls the step from the inner

00:22:22,730 --> 00:22:29,520
iterator so it essentially rubs the this

00:22:27,120 --> 00:22:31,680
iterator here with a new next function

00:22:29,520 --> 00:22:35,390
and uses this stuff to continue kind of

00:22:31,680 --> 00:22:42,240
let this step drive the recursion

00:22:35,390 --> 00:22:46,050
this is tyke take needs to make some

00:22:42,240 --> 00:22:48,210
changes to the state so not sure if you

00:22:46,050 --> 00:22:50,670
notice but in this case I'm saying eater

00:22:48,210 --> 00:22:53,730
with next so this in a combo

00:22:50,670 --> 00:22:56,550
means take all the fields from eater

00:22:53,730 --> 00:22:59,700
record and replace next with next this

00:22:56,550 --> 00:23:01,050
next while in this case I'm replacing

00:22:59,700 --> 00:23:04,350
all of them because I need to make

00:23:01,050 --> 00:23:08,580
changes as I said so in it is actually

00:23:04,350 --> 00:23:12,210
the original state of the inner iterator

00:23:08,580 --> 00:23:15,090
and then I also add an counter or limit

00:23:12,210 --> 00:23:19,290
sorry free essentially ignores the

00:23:15,090 --> 00:23:21,840
counter and frees the state or parent

00:23:19,290 --> 00:23:25,860
iterator and then inside next I have

00:23:21,840 --> 00:23:28,740
access to both this state from eater and

00:23:25,860 --> 00:23:30,030
I which is the counter and I can you

00:23:28,740 --> 00:23:32,670
know decide what to do next

00:23:30,030 --> 00:23:35,100
the interesting bit is that since s is

00:23:32,670 --> 00:23:38,760
an existential type I'm not actually

00:23:35,100 --> 00:23:40,560
allowed to use this type you know for my

00:23:38,760 --> 00:23:42,780
own purposes the only thing that I can

00:23:40,560 --> 00:23:44,550
do is to essentially pass it to next

00:23:42,780 --> 00:23:47,730
because next understands it

00:23:44,550 --> 00:23:49,770
okay so fold and fold is the one who

00:23:47,730 --> 00:23:51,810
actually drives the drives the you know

00:23:49,770 --> 00:23:54,270
recursion so it's still a pool based

00:23:51,810 --> 00:23:55,559
model fold is in charge four fold is a

00:23:54,270 --> 00:23:57,999
consumer and

00:23:55,559 --> 00:24:00,039
it has this go function which is

00:23:57,999 --> 00:24:02,409
recursive we use bracket to make sure

00:24:00,039 --> 00:24:04,929
that we you know handle resources

00:24:02,409 --> 00:24:06,549
correctly and then finally inside our

00:24:04,929 --> 00:24:08,799
stepping function so that's the one

00:24:06,549 --> 00:24:12,399
that's gonna be used by mob filter and

00:24:08,799 --> 00:24:15,489
so on we call go again with a new state

00:24:12,399 --> 00:24:17,409
so go is like the balancing thing

00:24:15,489 --> 00:24:20,440
between the state and the result the

00:24:17,409 --> 00:24:22,690
state is like the bucket with some input

00:24:20,440 --> 00:24:26,259
and R is the bucket with some output and

00:24:22,690 --> 00:24:28,509
go is kind of responsible for taking

00:24:26,259 --> 00:24:31,779
stuff from the S bucket and putting

00:24:28,509 --> 00:24:37,210
things through the F function to the

00:24:31,779 --> 00:24:42,729
result pocket so I implemented this

00:24:37,210 --> 00:24:45,489
using this model and I try to make a

00:24:42,729 --> 00:24:47,799
simple benchmark that essentially used a

00:24:45,489 --> 00:24:51,609
few Maps if you filter sand view tykes a

00:24:47,799 --> 00:24:56,619
very simple and primitive benchmark it's

00:24:51,609 --> 00:25:00,789
not useful to judge any real-world

00:24:56,619 --> 00:25:02,409
production applications of this model

00:25:00,789 --> 00:25:06,779
but at least it gives us some

00:25:02,409 --> 00:25:10,289
information and here are the results so

00:25:06,779 --> 00:25:12,429
the results are normalized so this is

00:25:10,289 --> 00:25:14,470
showing the percentages between the

00:25:12,429 --> 00:25:17,919
different models here we have the

00:25:14,470 --> 00:25:20,289
absolute values external is the original

00:25:17,919 --> 00:25:22,450
pool based iterator internal is the

00:25:20,289 --> 00:25:26,019
original push based interrater external

00:25:22,450 --> 00:25:27,700
K is mine stream Fusion is the Hamill's

00:25:26,019 --> 00:25:29,379
implementation of something similar to

00:25:27,700 --> 00:25:35,039
haskell stream fusion I guess the one

00:25:29,379 --> 00:25:37,659
that has yield skip and done that

00:25:35,039 --> 00:25:40,989
essentially removes the recursion from

00:25:37,659 --> 00:25:43,629
the combinators and thankless is just a

00:25:40,989 --> 00:25:47,109
lazy list at least protected by a unit

00:25:43,629 --> 00:25:48,729
values and I mean it's performing well I

00:25:47,109 --> 00:25:55,720
was really surprised it's even better

00:25:48,729 --> 00:25:57,729
than our internal of iterators so I mean

00:25:55,720 --> 00:25:59,289
maybe that's an improvement maybe I just

00:25:57,729 --> 00:26:02,409
miss something but I'm gonna continue my

00:25:59,289 --> 00:26:04,359
research in this so yeah this is it and

00:26:02,409 --> 00:26:06,399
that's all I have to share with you

00:26:04,359 --> 00:26:09,519
today some conclusions before I finish

00:26:06,399 --> 00:26:10,029
so I think that in general continuations

00:26:09,519 --> 00:26:11,649
or

00:26:10,029 --> 00:26:14,529
functions in general can lead to better

00:26:11,649 --> 00:26:16,330
performance I've seen cases were like

00:26:14,529 --> 00:26:19,029
libraries that were mentioned here like

00:26:16,330 --> 00:26:21,759
pipes are conduits benefit a lot when

00:26:19,029 --> 00:26:23,679
converted to the conservation bypassing

00:26:21,759 --> 00:26:25,749
style so it's something that we should

00:26:23,679 --> 00:26:29,109
always be aware of yes it does

00:26:25,749 --> 00:26:30,489
complicate the code but I mean if you

00:26:29,109 --> 00:26:30,849
really need performance maybe it's worth

00:26:30,489 --> 00:26:33,639
it

00:26:30,849 --> 00:26:36,009
and also I'm starting to think that

00:26:33,639 --> 00:26:38,259
maybe we just need a better syntax for

00:26:36,009 --> 00:26:41,259
our continuation based you know

00:26:38,259 --> 00:26:43,989
computations that would make this

00:26:41,259 --> 00:26:46,179
problem just disappear

00:26:43,989 --> 00:26:47,499
pure programming is actually possible in

00:26:46,179 --> 00:26:48,940
a camel I mean of course it's not

00:26:47,499 --> 00:26:51,159
enforced by the type system or anything

00:26:48,940 --> 00:26:52,899
but you know even in Haskell you have to

00:26:51,159 --> 00:26:56,519
kind of pretend sometimes right like all

00:26:52,899 --> 00:27:00,129
the unsafe functions and all that and

00:26:56,519 --> 00:27:01,629
also in pure functional code is possible

00:27:00,129 --> 00:27:05,440
in a camel in pure functional code is

00:27:01,629 --> 00:27:09,820
also possible and it essentially means

00:27:05,440 --> 00:27:11,769
that you know yes the the initial post

00:27:09,820 --> 00:27:13,499
based and pull based models that I

00:27:11,769 --> 00:27:16,029
showed you use mutable state and

00:27:13,499 --> 00:27:19,239
exceptions and all of that but they are

00:27:16,029 --> 00:27:21,309
all protected by this interface and like

00:27:19,239 --> 00:27:23,559
I don't really care if Tyco has to throw

00:27:21,309 --> 00:27:27,460
an exception inside to you know maybe

00:27:23,559 --> 00:27:30,159
the number of things to to pass forward

00:27:27,460 --> 00:27:33,729
because you know a commis type system is

00:27:30,159 --> 00:27:36,369
really solid so it allows me to build

00:27:33,729 --> 00:27:42,389
nice functional interfaces on top of

00:27:36,369 --> 00:27:44,580
ugly mutable code so yeah and finally

00:27:42,389 --> 00:27:47,249
functions are the ultimate ultimate

00:27:44,580 --> 00:27:50,440
abstraction in my opinion like it's very

00:27:47,249 --> 00:27:52,059
it's firm it's really impressive how you

00:27:50,440 --> 00:27:56,320
can build really sophisticated things

00:27:52,059 --> 00:27:58,590
with just a few functions and yeah

00:27:56,320 --> 00:28:00,650
that's it

00:27:58,590 --> 00:28:00,650

YouTube URL: https://www.youtube.com/watch?v=KupkEsqdu0E


