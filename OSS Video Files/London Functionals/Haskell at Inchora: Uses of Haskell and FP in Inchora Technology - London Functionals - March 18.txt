Title: Haskell at Inchora: Uses of Haskell and FP in Inchora Technology - London Functionals - March 18
Publication date: 2018-03-19
Playlist: London Functionals
Description: 
	Blake Rain

Haskell and R&D over the years at Inchora
Captions: 
	00:00:00,030 --> 00:00:06,210
well good evening guys sorry about my

00:00:01,909 --> 00:00:07,859
disheveled ex appearance but I was a bit

00:00:06,210 --> 00:00:10,800
of a rush to get here

00:00:07,859 --> 00:00:13,200
my name is Bay tre I'm trimming Cora I

00:00:10,800 --> 00:00:14,490
just thought I'd do a talk about just a

00:00:13,200 --> 00:00:17,070
quick one about some of the uses of

00:00:14,490 --> 00:00:18,810
Haskell in that in Cora we have some

00:00:17,070 --> 00:00:20,939
fairly large projects that we use

00:00:18,810 --> 00:00:22,439
functional programming for I thought I'd

00:00:20,939 --> 00:00:23,550
talk particularly about just some of the

00:00:22,439 --> 00:00:25,170
stuff that we've been doing with it

00:00:23,550 --> 00:00:26,070
rather than going into any details of

00:00:25,170 --> 00:00:28,980
any of the actual technical

00:00:26,070 --> 00:00:31,380
implementations so to give you a quick

00:00:28,980 --> 00:00:32,579
overview the in choral group comprises

00:00:31,380 --> 00:00:34,590
of a number of companies that were

00:00:32,579 --> 00:00:37,140
brought together under a common vision

00:00:34,590 --> 00:00:38,640
and this required the centralization a

00:00:37,140 --> 00:00:40,890
lot of a lot of the technologies that

00:00:38,640 --> 00:00:42,840
came with them we're going to focus

00:00:40,890 --> 00:00:45,450
primarily on in kora home technology

00:00:42,840 --> 00:00:49,140
today just to kind of keep everything

00:00:45,450 --> 00:00:51,449
nice and brief so in kora home we have a

00:00:49,140 --> 00:00:53,789
system called Sulu which provides a

00:00:51,449 --> 00:00:55,289
tenant notification service so that's

00:00:53,789 --> 00:00:58,199
when people move in and out of

00:00:55,289 --> 00:01:00,989
properties they're able to be we notify

00:00:58,199 --> 00:01:02,640
all the council's and the water

00:01:00,989 --> 00:01:04,199
companies and the electricity companies

00:01:02,640 --> 00:01:06,360
that people are moving in and out of

00:01:04,199 --> 00:01:07,799
properties so that makes sure that all

00:01:06,360 --> 00:01:09,360
the billing and everything is closed

00:01:07,799 --> 00:01:11,040
properly and you don't get a bill for

00:01:09,360 --> 00:01:13,020
people who haven't been there and all

00:01:11,040 --> 00:01:14,670
this sort of thing this is a service

00:01:13,020 --> 00:01:17,520
that goes out to a few thousands letting

00:01:14,670 --> 00:01:19,799
agents and they enter the information on

00:01:17,520 --> 00:01:21,600
here and part of the service that we

00:01:19,799 --> 00:01:22,680
offer is a concierge service for the

00:01:21,600 --> 00:01:25,560
tenants that are moving into the

00:01:22,680 --> 00:01:27,360
property and what that entails is we

00:01:25,560 --> 00:01:29,670
sort out their media for them so that's

00:01:27,360 --> 00:01:31,619
setting a broadband and TV and anything

00:01:29,670 --> 00:01:33,210
like that we sort out energy switching

00:01:31,619 --> 00:01:35,970
as well and then any insurance

00:01:33,210 --> 00:01:40,140
requirements they have so off the back

00:01:35,970 --> 00:01:43,259
of a website we have a call center where

00:01:40,140 --> 00:01:45,600
we have to call centres and end-to-end

00:01:43,259 --> 00:01:49,320
the whole thing is controlled by a set

00:01:45,600 --> 00:01:53,250
of Haskell programs so the main site

00:01:49,320 --> 00:01:56,490
itself is built using your soap we use

00:01:53,250 --> 00:01:58,950
the persistent and the SQL sorry sweet

00:01:56,490 --> 00:02:02,369
SQL Ito libraries in order to do our

00:01:58,950 --> 00:02:04,829
data bindings and we have a number of

00:02:02,369 --> 00:02:06,810
integrations with agency software again

00:02:04,829 --> 00:02:09,869
we're using this ode for all the api's

00:02:06,810 --> 00:02:11,640
in Haskell and they allow us to build

00:02:09,869 --> 00:02:13,160
the stable API as we also use that for

00:02:11,640 --> 00:02:14,720
our evolving api's which

00:02:13,160 --> 00:02:17,900
when somebody just comes on board who

00:02:14,720 --> 00:02:20,120
has specific a it was specific API

00:02:17,900 --> 00:02:23,750
requirements we were able to rapidly

00:02:20,120 --> 00:02:26,420
develop them an API there we also use

00:02:23,750 --> 00:02:27,530
scripting for JavaScript because we have

00:02:26,420 --> 00:02:30,470
a number of things that happen

00:02:27,530 --> 00:02:32,090
throughout the ecosystem of the business

00:02:30,470 --> 00:02:34,490
which is where where we need to be able

00:02:32,090 --> 00:02:36,710
to very quickly change the way that the

00:02:34,490 --> 00:02:38,630
system behaves which we can't really do

00:02:36,710 --> 00:02:39,740
with you know Haskell's very good at

00:02:38,630 --> 00:02:41,720
this sort of thing but we can't really

00:02:39,740 --> 00:02:44,360
do it by deploying lots of things so we

00:02:41,720 --> 00:02:48,890
have a scripting system built on top of

00:02:44,360 --> 00:02:50,510
the Haskell infrastructure then behind

00:02:48,890 --> 00:02:52,700
the scenes we have the call center

00:02:50,510 --> 00:02:54,350
management so that's the campaign

00:02:52,700 --> 00:02:56,720
management which is how we take a look

00:02:54,350 --> 00:02:58,490
at when we get new information presented

00:02:56,720 --> 00:02:59,720
to the system new people that have come

00:02:58,490 --> 00:03:02,090
into properties or people leaving

00:02:59,720 --> 00:03:04,280
properties how do we work out what we

00:03:02,090 --> 00:03:08,480
can sell them how do we work out when we

00:03:04,280 --> 00:03:09,920
can call them so on and so forth we're

00:03:08,480 --> 00:03:11,300
not based in London we raised all over

00:03:09,920 --> 00:03:13,430
the place actually our main our head

00:03:11,300 --> 00:03:19,670
office is in Farnborough and with

00:03:13,430 --> 00:03:25,310
offices in Grantham Norwich and Glasgow

00:03:19,670 --> 00:03:27,470
rosco then we have the adaptive dialer

00:03:25,310 --> 00:03:29,060
which is when you've got multiple call

00:03:27,470 --> 00:03:31,130
centres with multiple products you need

00:03:29,060 --> 00:03:32,959
to be able to say to people okay this is

00:03:31,130 --> 00:03:34,580
the next person you need to call and you

00:03:32,959 --> 00:03:37,040
need to have to do that as rapidly as

00:03:34,580 --> 00:03:39,620
mean and as intelligently as you can so

00:03:37,040 --> 00:03:41,480
in order to support this we have a

00:03:39,620 --> 00:03:43,430
dialer system again built in Haskell

00:03:41,480 --> 00:03:46,070
which interfaces with the aver phone

00:03:43,430 --> 00:03:48,200
system which allows us to control the

00:03:46,070 --> 00:03:50,120
call centres and we have to call centres

00:03:48,200 --> 00:03:53,330
which are the Grantham and the Glasgow

00:03:50,120 --> 00:03:54,350
offices so there's a kind of quick

00:03:53,330 --> 00:03:55,640
summary

00:03:54,350 --> 00:03:58,430
obviously there's quite a lot of stuff

00:03:55,640 --> 00:04:00,080
there so our problem I'm only covering

00:03:58,430 --> 00:04:02,060
we'll take a look at some of the

00:04:00,080 --> 00:04:03,770
scripting because it's quite interesting

00:04:02,060 --> 00:04:05,480
with one of the nice things about

00:04:03,770 --> 00:04:07,550
Haskell is that we can automatically

00:04:05,480 --> 00:04:10,100
generate all our bindings for all our

00:04:07,550 --> 00:04:12,200
JavaScript on our server side and we

00:04:10,100 --> 00:04:14,330
don't have to we can rely a lot on the

00:04:12,200 --> 00:04:16,400
type safety I also take a look at some

00:04:14,330 --> 00:04:17,450
of the campaign management because

00:04:16,400 --> 00:04:18,530
that's one of the interesting things

00:04:17,450 --> 00:04:20,710
that high school that's is quite

00:04:18,530 --> 00:04:25,039
trivially build

00:04:20,710 --> 00:04:26,840
so using Haskell and JavaScript we have

00:04:25,039 --> 00:04:28,070
numerous api's because we've got

00:04:26,840 --> 00:04:29,570
all these lacking agent some of them are

00:04:28,070 --> 00:04:31,340
very large letting agents and very

00:04:29,570 --> 00:04:33,919
complicated in their big operations some

00:04:31,340 --> 00:04:36,290
of them are quite small and so we need

00:04:33,919 --> 00:04:38,090
to be able to build api's so what we

00:04:36,290 --> 00:04:40,430
often do is we have the stable api's

00:04:38,090 --> 00:04:42,590
which are written in Haskell and then we

00:04:40,430 --> 00:04:45,770
use scripting on top of the Haskell

00:04:42,590 --> 00:04:49,010
system using JavaScript which allows us

00:04:45,770 --> 00:04:51,139
to build simple api s-- and the this

00:04:49,010 --> 00:04:53,900
allows us to make sure that our

00:04:51,139 --> 00:04:55,780
JavaScript scripts which quite throwaway

00:04:53,900 --> 00:04:58,040
and quite easy to make they are

00:04:55,780 --> 00:05:00,979
essentially combining her school

00:04:58,040 --> 00:05:03,110
functions behind the scenes so that

00:05:00,979 --> 00:05:04,370
makes that makes it but that allows us

00:05:03,110 --> 00:05:06,110
to build quite complicated things back

00:05:04,370 --> 00:05:09,680
room to go to node.js and run the risk

00:05:06,110 --> 00:05:11,750
of having inconsistencies between for

00:05:09,680 --> 00:05:13,340
instance the persistent system that we

00:05:11,750 --> 00:05:15,860
use in the Haskell code in order to

00:05:13,340 --> 00:05:17,840
generate our data bindings and then the

00:05:15,860 --> 00:05:19,520
equivalent in the node.js we're able to

00:05:17,840 --> 00:05:22,330
just do all there's one all part of one

00:05:19,520 --> 00:05:25,520
system which works out quite nicely

00:05:22,330 --> 00:05:26,960
we have campaigns and key management all

00:05:25,520 --> 00:05:28,310
sorts of things like commission schemes

00:05:26,960 --> 00:05:30,289
and so forth and all of these change

00:05:28,310 --> 00:05:33,320
quite a lot they change really rapidly

00:05:30,289 --> 00:05:35,570
we can have a new product where we from

00:05:33,320 --> 00:05:37,100
inception to during life is you know in

00:05:35,570 --> 00:05:40,850
a matter of days it can be very very

00:05:37,100 --> 00:05:44,450
quick and of course the contact center

00:05:40,850 --> 00:05:46,280
strategies which is essentially taking a

00:05:44,450 --> 00:05:47,630
look at maximizing the conversion of a

00:05:46,280 --> 00:05:48,800
contact center so you need to think

00:05:47,630 --> 00:05:50,539
about you know when we're calling

00:05:48,800 --> 00:05:52,190
somebody how often we've called them and

00:05:50,539 --> 00:05:54,770
all this sort of thing these strategies

00:05:52,190 --> 00:05:58,130
can change quite quickly and if we

00:05:54,770 --> 00:05:59,870
wanted to deploy a Haskell program and

00:05:58,130 --> 00:06:01,490
these these are quite big programs if we

00:05:59,870 --> 00:06:04,130
wanted to change them and deploy them

00:06:01,490 --> 00:06:06,110
for every single time we would just be

00:06:04,130 --> 00:06:07,970
continuously changing server code and

00:06:06,110 --> 00:06:09,620
constantly trying to deploy things and

00:06:07,970 --> 00:06:13,729
we would never we would always have this

00:06:09,620 --> 00:06:15,229
huge backlog so the other problem is

00:06:13,729 --> 00:06:17,389
that we ended up finding that we had a

00:06:15,229 --> 00:06:19,760
higher barrier for entry which was the

00:06:17,389 --> 00:06:21,080
Haskell code when you're dealing with

00:06:19,760 --> 00:06:22,280
things that are quite simple is very

00:06:21,080 --> 00:06:24,680
easy to understand it it's a very

00:06:22,280 --> 00:06:26,960
natural way of expressing a function to

00:06:24,680 --> 00:06:28,250
use functional programming and you know

00:06:26,960 --> 00:06:31,099
we're all functional programmers I'm

00:06:28,250 --> 00:06:32,990
assuming and so we know that that's

00:06:31,099 --> 00:06:35,060
that's the case is very easy to express

00:06:32,990 --> 00:06:36,860
them but for when you get into

00:06:35,060 --> 00:06:37,900
non-trivial programs and quite large

00:06:36,860 --> 00:06:40,570
programs

00:06:37,900 --> 00:06:42,250
that barrier for entry does go up it can

00:06:40,570 --> 00:06:43,870
take people a lot longer to understand

00:06:42,250 --> 00:06:46,360
any complex system regardless of the

00:06:43,870 --> 00:06:48,789
language it's written in whereas using

00:06:46,360 --> 00:06:50,139
javascript anybody can use javascript

00:06:48,789 --> 00:06:52,300
it's very simple it's very simple

00:06:50,139 --> 00:06:53,949
language so allowed us it allowed us to

00:06:52,300 --> 00:06:56,560
let people who weren't high school

00:06:53,949 --> 00:06:59,380
developers develop custom functionality

00:06:56,560 --> 00:07:02,620
for the platform so that in essence is

00:06:59,380 --> 00:07:06,070
sort of why we started using javascript

00:07:02,620 --> 00:07:09,190
with Haskell and one of the nice things

00:07:06,070 --> 00:07:10,960
about Haskell is that we have this type

00:07:09,190 --> 00:07:13,120
system we have all this type information

00:07:10,960 --> 00:07:14,789
about everything that is available so

00:07:13,120 --> 00:07:18,490
we're able to automatically generate

00:07:14,789 --> 00:07:20,560
bindings into JavaScript in essence

00:07:18,490 --> 00:07:22,539
every single entity that we have in our

00:07:20,560 --> 00:07:25,289
data model barring some particulars

00:07:22,539 --> 00:07:28,389
we're able to automatically generate all

00:07:25,289 --> 00:07:30,190
the in all the if you want to say

00:07:28,389 --> 00:07:31,900
JavaScript classes the for every single

00:07:30,190 --> 00:07:34,210
one of them all the prototype functions

00:07:31,900 --> 00:07:36,910
and because they are essentially just

00:07:34,210 --> 00:07:39,039
hooking into JavaScript code then

00:07:36,910 --> 00:07:39,880
through an FF I for a foreign function

00:07:39,039 --> 00:07:41,800
interface

00:07:39,880 --> 00:07:44,229
we're in short that you know they're

00:07:41,800 --> 00:07:46,510
only calling Haskell functions so any of

00:07:44,229 --> 00:07:48,729
the i/o that the scripts essentially

00:07:46,510 --> 00:07:50,889
perform is actually just calling Haskell

00:07:48,729 --> 00:07:55,389
functions and the system we use to

00:07:50,889 --> 00:07:57,250
marshal data between JavaScript and the

00:07:55,389 --> 00:07:59,380
Haskell side is the a-sun library which

00:07:57,250 --> 00:08:02,169
takes which is a lovely library for

00:07:59,380 --> 00:08:03,580
transforming JSON and you know that

00:08:02,169 --> 00:08:05,289
makes sure that all the data that we're

00:08:03,580 --> 00:08:09,550
transferring between the two is nice and

00:08:05,289 --> 00:08:11,650
nice and reasonably reliable a

00:08:09,550 --> 00:08:13,449
particular JavaScript library we use is

00:08:11,650 --> 00:08:16,090
one that not on many people have heard

00:08:13,449 --> 00:08:18,280
about it's called duck tape the lovely

00:08:16,090 --> 00:08:22,120
thing about duct tape is it's a very

00:08:18,280 --> 00:08:25,060
lightweight JavaScript engine so many of

00:08:22,120 --> 00:08:27,940
you heard of SQLite yeah yeah

00:08:25,060 --> 00:08:30,669
so SQLite compared to like Postgres yeah

00:08:27,940 --> 00:08:32,380
duck tape is like that too v8 so it's

00:08:30,669 --> 00:08:33,820
very very lightweight and one of the

00:08:32,380 --> 00:08:35,620
nice things is that plays wonderfully

00:08:33,820 --> 00:08:38,469
into Haskell's lightweight threading and

00:08:35,620 --> 00:08:41,169
because Haskell being functional has a

00:08:38,469 --> 00:08:43,959
very lightweight green thread system and

00:08:41,169 --> 00:08:45,760
duct tape each time we create a heap

00:08:43,959 --> 00:08:47,890
allocation it's a couple of kilobytes

00:08:45,760 --> 00:08:50,020
one of the things we can do is we can

00:08:47,890 --> 00:08:51,760
say well we can just create these new

00:08:50,020 --> 00:08:53,800
contexts without worrying

00:08:51,760 --> 00:08:56,530
now running out of memory or resource

00:08:53,800 --> 00:08:58,270
usage and that plays and so we're

00:08:56,530 --> 00:09:00,820
essentially able to spin up a Haskell

00:08:58,270 --> 00:09:02,620
thread which is very lightweight create

00:09:00,820 --> 00:09:04,770
a whole new context for that thread and

00:09:02,620 --> 00:09:06,850
then have this great big pool of

00:09:04,770 --> 00:09:09,010
critical threads and contexts that

00:09:06,850 --> 00:09:10,270
receive messages run sorts of scripts

00:09:09,010 --> 00:09:12,700
and if they fall over it doesn't really

00:09:10,270 --> 00:09:14,350
matter and so at that place quite nicely

00:09:12,700 --> 00:09:15,550
and so duct tape was quite a good choice

00:09:14,350 --> 00:09:18,010
for that

00:09:15,550 --> 00:09:19,240
however as things progresses they

00:09:18,010 --> 00:09:21,580
naturally do things get more and more

00:09:19,240 --> 00:09:23,500
complicated when you create a scripting

00:09:21,580 --> 00:09:25,390
system I should have known this it gets

00:09:23,500 --> 00:09:31,060
abused and then it ends up being used

00:09:25,390 --> 00:09:32,350
for absolutely everything so shot myself

00:09:31,060 --> 00:09:33,100
in the foot so now I've got to look at

00:09:32,350 --> 00:09:35,290
track record

00:09:33,100 --> 00:09:38,170
which is for those of you don't know the

00:09:35,290 --> 00:09:40,750
Microsoft edge browser it's their new

00:09:38,170 --> 00:09:44,350
JavaScript engine it's very nice it's

00:09:40,750 --> 00:09:49,540
very nice it offers a very nice API the

00:09:44,350 --> 00:09:52,150
the other option of course is v8 but so

00:09:49,540 --> 00:09:55,150
anyway back to Haskell so there's an

00:09:52,150 --> 00:09:57,160
example use is there too much but

00:09:55,150 --> 00:09:59,350
essentially the automatic generation of

00:09:57,160 --> 00:10:01,840
the binding allows us to take a Haskell

00:09:59,350 --> 00:10:03,430
function just like this one so this is a

00:10:01,840 --> 00:10:05,620
this is a function that takes the idea

00:10:03,430 --> 00:10:11,440
of an agent and the idea of a product

00:10:05,620 --> 00:10:13,210
category it runs in our SQL monad we're

00:10:11,440 --> 00:10:14,500
able to automatically generate bindings

00:10:13,210 --> 00:10:16,360
against that and we can generate the

00:10:14,500 --> 00:10:18,100
bindings in two ways or both depending

00:10:16,360 --> 00:10:20,170
on what we want we can either generate

00:10:18,100 --> 00:10:21,430
it whereas it as an instance function in

00:10:20,170 --> 00:10:24,280
which case we're able to call it on

00:10:21,430 --> 00:10:25,960
every instance of every object or are

00:10:24,280 --> 00:10:27,250
able to have it as a static in which

00:10:25,960 --> 00:10:28,780
case all of the arguments are

00:10:27,250 --> 00:10:31,780
immediately marshaled so essentially

00:10:28,780 --> 00:10:33,280
what we have is a great big file that

00:10:31,780 --> 00:10:34,930
has a load of template haskell in it

00:10:33,280 --> 00:10:36,880
which generates all these things like

00:10:34,930 --> 00:10:39,070
the ability like the instance methods

00:10:36,880 --> 00:10:41,470
for common things like loading and

00:10:39,070 --> 00:10:44,260
saving from the database and then we

00:10:41,470 --> 00:10:46,510
have every time we have our set of

00:10:44,260 --> 00:10:49,450
controllers like this sort of thing we

00:10:46,510 --> 00:10:50,800
have exports of those and again it's a

00:10:49,450 --> 00:10:52,450
template haskell function which

00:10:50,800 --> 00:10:54,850
generates all the marshaling and

00:10:52,450 --> 00:10:57,220
everything that we need and it quite

00:10:54,850 --> 00:10:58,660
simply looks at things like if this is a

00:10:57,220 --> 00:10:59,980
function of it letting agents well we

00:10:58,660 --> 00:11:01,180
know it's a function overloading agents

00:10:59,980 --> 00:11:03,790
because it takes a lighting agent as an

00:11:01,180 --> 00:11:04,370
argument and so it automatically

00:11:03,790 --> 00:11:06,140
creating

00:11:04,370 --> 00:11:07,760
Stan's methods and things like that so

00:11:06,140 --> 00:11:09,470
the next thing I wanted to talk about

00:11:07,760 --> 00:11:11,450
was campaign management which is one of

00:11:09,470 --> 00:11:12,890
the interesting things we ended up

00:11:11,450 --> 00:11:14,360
having to introduced into the system

00:11:12,890 --> 00:11:19,550
there's no more JavaScript now you'll be

00:11:14,360 --> 00:11:20,990
glad to know because inin Cora home we

00:11:19,550 --> 00:11:22,670
have multiple product journeys for all

00:11:20,990 --> 00:11:25,220
the customers you know primarily this

00:11:22,670 --> 00:11:26,540
would be media energy and insurance but

00:11:25,220 --> 00:11:28,460
if you imagine there's actually quite a

00:11:26,540 --> 00:11:31,070
lot of concurrent things going on within

00:11:28,460 --> 00:11:33,470
that for instance if we sell you if we

00:11:31,070 --> 00:11:35,630
sell you an energy product well a year

00:11:33,470 --> 00:11:37,670
later they may have a new set of tariffs

00:11:35,630 --> 00:11:38,960
open so we then need to sell you and you

00:11:37,670 --> 00:11:40,550
know we need to talk to you again

00:11:38,960 --> 00:11:42,680
because chances are you can be on a

00:11:40,550 --> 00:11:44,089
better tariff and the same with things

00:11:42,680 --> 00:11:46,910
like insurance as well and then you've

00:11:44,089 --> 00:11:48,650
got so things like what about if we ring

00:11:46,910 --> 00:11:50,510
you and we need to ring you again couple

00:11:48,650 --> 00:11:52,220
of hours later or maybe the next day or

00:11:50,510 --> 00:11:53,540
all the appointment management so

00:11:52,220 --> 00:11:55,460
there's an awful lot that goes into a

00:11:53,540 --> 00:11:57,050
call center and we need to be a little

00:11:55,460 --> 00:11:59,360
bit intelligent about how we do this

00:11:57,050 --> 00:12:02,420
sort of things so the campaign system

00:11:59,360 --> 00:12:05,000
was built to allow us to be a little bit

00:12:02,420 --> 00:12:06,770
more flexible rather than just getting a

00:12:05,000 --> 00:12:08,450
piece of data and putting it in a call

00:12:06,770 --> 00:12:09,920
flow and that's mountais we need it to

00:12:08,450 --> 00:12:12,650
be a bit more selective about some of

00:12:09,920 --> 00:12:13,970
the stuff that we did with them and we

00:12:12,650 --> 00:12:15,920
also needed to be able to do this at

00:12:13,970 --> 00:12:17,690
various points within the lifetime so

00:12:15,920 --> 00:12:19,070
for instance when we first get the data

00:12:17,690 --> 00:12:22,070
when somebody has actually been

00:12:19,070 --> 00:12:23,600
contacted when somebody has been

00:12:22,070 --> 00:12:25,520
contacted and that has resulted in a

00:12:23,600 --> 00:12:27,140
particular outcome all those sort of

00:12:25,520 --> 00:12:29,900
things so for instance if we bring you

00:12:27,140 --> 00:12:32,570
and we leave a message and then you

00:12:29,900 --> 00:12:33,560
don't answer maybe five times well it

00:12:32,570 --> 00:12:35,510
doesn't make sense for us to keep

00:12:33,560 --> 00:12:38,890
bringing you and it's also illegal so

00:12:35,510 --> 00:12:38,890
what we do is we send you a text message

00:12:38,980 --> 00:12:45,140
to say we're trying to ring you because

00:12:41,750 --> 00:12:46,490
you wouldn't know otherwise and all of

00:12:45,140 --> 00:12:47,990
this needs to be triggered and there

00:12:46,490 --> 00:12:51,320
needs to be a number of decisions made

00:12:47,990 --> 00:12:52,970
about how we do this sort of stuff it

00:12:51,320 --> 00:12:54,170
also needs to be accessible to contact

00:12:52,970 --> 00:12:55,970
center management cause unlike the

00:12:54,170 --> 00:12:57,740
scripting system which you know changes

00:12:55,970 --> 00:12:59,990
quite slowly and is only ever used in

00:12:57,740 --> 00:13:03,470
sort of extreme circumstances apart from

00:12:59,990 --> 00:13:05,540
when they use it for everything the

00:13:03,470 --> 00:13:07,550
campaign system needs to change very

00:13:05,540 --> 00:13:09,650
very rapidly and quite a lot of these

00:13:07,550 --> 00:13:12,140
campaigns the managers need to be able

00:13:09,650 --> 00:13:15,230
to take a look at this sort of strategy

00:13:12,140 --> 00:13:17,510
that they're applying and

00:13:15,230 --> 00:13:18,980
yeah refinement by scripting we'll just

00:13:17,510 --> 00:13:20,480
ignore though for now though so to give

00:13:18,980 --> 00:13:23,170
you an idea of what campaign looks like

00:13:20,480 --> 00:13:25,550
this is a really really simple campaign

00:13:23,170 --> 00:13:28,040
they're built using a diagram system

00:13:25,550 --> 00:13:29,840
which is in the management web web

00:13:28,040 --> 00:13:32,060
interface the managers can go in there

00:13:29,840 --> 00:13:33,350
and they can drop these nodes which you

00:13:32,060 --> 00:13:36,260
go to look at and you immediately know

00:13:33,350 --> 00:13:37,760
what's going on here essentially we're

00:13:36,260 --> 00:13:41,690
looking at has the person had an

00:13:37,760 --> 00:13:42,980
insurance call and was the offset from

00:13:41,690 --> 00:13:45,640
when they're added less than or equal to

00:13:42,980 --> 00:13:47,810
seven that's seven down there not zero

00:13:45,640 --> 00:13:49,730
so essentially what we're saying is were

00:13:47,810 --> 00:13:53,150
they added less than seven less than

00:13:49,730 --> 00:13:55,010
seven days or less and have they had an

00:13:53,150 --> 00:13:56,690
insurance call so that little campaign

00:13:55,010 --> 00:13:58,760
they can put together and they can

00:13:56,690 --> 00:14:00,380
either leave back and have it for

00:13:58,760 --> 00:14:02,210
instance filling up a doll queue and

00:14:00,380 --> 00:14:04,100
then associate people with that doll

00:14:02,210 --> 00:14:05,900
queue and so people will start calling

00:14:04,100 --> 00:14:07,310
the data that comes through that or they

00:14:05,900 --> 00:14:08,450
could plug it into a text message system

00:14:07,310 --> 00:14:11,090
or they could export it because they

00:14:08,450 --> 00:14:12,380
want to do something else with it the

00:14:11,090 --> 00:14:14,300
campaign's themselves do get very very

00:14:12,380 --> 00:14:17,590
complicated I tried to actually fit one

00:14:14,300 --> 00:14:21,380
of them in the slides but it didn't fit

00:14:17,590 --> 00:14:25,130
and unfortunately I didn't understand it

00:14:21,380 --> 00:14:26,990
either so there we go but the campaign

00:14:25,130 --> 00:14:29,960
system is really quite it's really quite

00:14:26,990 --> 00:14:32,060
quite I don't say elegant cuz it sounds

00:14:29,960 --> 00:14:34,880
very very arrogant but it's quite good

00:14:32,060 --> 00:14:36,710
fun so essentially what it is is they

00:14:34,880 --> 00:14:39,350
create these diagrams which we know is

00:14:36,710 --> 00:14:40,520
just a it's just an AST so that they

00:14:39,350 --> 00:14:41,750
don't make they don't need to know that

00:14:40,520 --> 00:14:44,450
so they create these diagrams and

00:14:41,750 --> 00:14:46,720
connect them together and we essentially

00:14:44,450 --> 00:14:49,610
get the data structure on the left here

00:14:46,720 --> 00:14:52,760
i've grossly simplified for the sake of

00:14:49,610 --> 00:14:54,230
convenience but what we need to do is we

00:14:52,760 --> 00:14:55,970
want to type that because we want to

00:14:54,230 --> 00:14:57,650
make sure that everything's everything

00:14:55,970 --> 00:15:00,050
sane so that people aren't doing things

00:14:57,650 --> 00:15:01,790
like well you know was the added date

00:15:00,050 --> 00:15:03,050
less than how many calls that whether

00:15:01,790 --> 00:15:04,280
they've had a call or not and all that

00:15:03,050 --> 00:15:05,420
sort of thing because we want to make

00:15:04,280 --> 00:15:08,570
sure that the things that things that

00:15:05,420 --> 00:15:10,460
rational so one of the nice things we

00:15:08,570 --> 00:15:12,500
can do with her school is to take that

00:15:10,460 --> 00:15:15,140
structure on the left and turn it into

00:15:12,500 --> 00:15:17,330
what's called a GA DT and there's a

00:15:15,140 --> 00:15:19,700
generic algebraic data type so you've

00:15:17,330 --> 00:15:21,350
got a normal algebraic data type on the

00:15:19,700 --> 00:15:25,160
left there and here you have a

00:15:21,350 --> 00:15:26,810
generalized algebraic data type yeah and

00:15:25,160 --> 00:15:28,579
the nice thing about our generalized

00:15:26,810 --> 00:15:30,980
a ga da

00:15:28,579 --> 00:15:32,239
that we can capture type variables

00:15:30,980 --> 00:15:34,850
within the actual individual

00:15:32,239 --> 00:15:36,920
constructors and those of you that know

00:15:34,850 --> 00:15:39,079
Haskell will see the silly the error

00:15:36,920 --> 00:15:42,110
that I've made here which and those that

00:15:39,079 --> 00:15:44,389
you don't these A's should have been T

00:15:42,110 --> 00:15:46,009
so if you can just pretend that that's

00:15:44,389 --> 00:15:48,860
what I've done it'll be less

00:15:46,009 --> 00:15:51,019
embarrassing for me so essentially we

00:15:48,860 --> 00:15:52,069
can build these structures up and we can

00:15:51,019 --> 00:15:54,619
build them with a very simple function

00:15:52,069 --> 00:15:57,410
that takes these simple expressions on

00:15:54,619 --> 00:15:59,720
the left hand side and the result of it

00:15:57,410 --> 00:16:04,189
is either a type error or it's going to

00:15:59,720 --> 00:16:06,889
be time to you over a not though and so

00:16:04,189 --> 00:16:08,839
in essence we're able to take each and

00:16:06,889 --> 00:16:11,089
every one of the LM and each and every

00:16:08,839 --> 00:16:13,809
one of the constructors here and map it

00:16:11,089 --> 00:16:18,379
over to a typed variant and some present

00:16:13,809 --> 00:16:20,749
marvelous then we need to generate the

00:16:18,379 --> 00:16:22,549
actual SQL and each of these diagrams

00:16:20,749 --> 00:16:23,779
essentially just turns into SQL because

00:16:22,549 --> 00:16:24,610
we need to be able to run it against the

00:16:23,779 --> 00:16:27,079
database

00:16:24,610 --> 00:16:30,049
denne against the database is quite easy

00:16:27,079 --> 00:16:31,309
we take our type two expression as the

00:16:30,049 --> 00:16:35,389
first argument of our compile function

00:16:31,309 --> 00:16:38,899
and we turn it into an x SQL expression

00:16:35,389 --> 00:16:40,879
now the S Polito system has this

00:16:38,899 --> 00:16:43,040
wonderful way of having values wrapped

00:16:40,879 --> 00:16:45,049
inside expressions which complicates the

00:16:43,040 --> 00:16:46,819
type a little bit but essentially we

00:16:45,049 --> 00:16:48,230
just have a read of Mon out here which

00:16:46,819 --> 00:16:50,749
allows us to press some environment

00:16:48,230 --> 00:16:52,669
around for the compiler and we take our

00:16:50,749 --> 00:16:55,939
type two expression and if we were to

00:16:52,669 --> 00:16:57,529
have for instance the lead added note

00:16:55,939 --> 00:17:00,410
we're saying you know when was it added

00:16:57,529 --> 00:17:02,600
all we do is get our environment and

00:17:00,410 --> 00:17:05,510
inspect the lead added field you know

00:17:02,600 --> 00:17:08,089
using essentially lens like format so

00:17:05,510 --> 00:17:10,189
this allows us to build build up the SQL

00:17:08,089 --> 00:17:13,039
expressions and I gave a quick example

00:17:10,189 --> 00:17:16,760
here if we wanted to be able to go from

00:17:13,039 --> 00:17:19,669
a boolean expression to a list of

00:17:16,760 --> 00:17:23,899
entities we could say select from this

00:17:19,669 --> 00:17:26,480
is SQL Ito syntax and just use our

00:17:23,899 --> 00:17:28,250
compiled function here so we use this

00:17:26,480 --> 00:17:29,809
all throughout the system to allow the

00:17:28,250 --> 00:17:31,370
management to be able to go in and say

00:17:29,809 --> 00:17:32,690
actually I want something more than just

00:17:31,370 --> 00:17:35,149
you know simple dropdowns I want

00:17:32,690 --> 00:17:37,039
complicated diagrams because they have

00:17:35,149 --> 00:17:39,409
all sorts of interesting rules going on

00:17:37,039 --> 00:17:41,750
and so that allows us to very quickly do

00:17:39,409 --> 00:17:42,200
this and to make sure that even if they

00:17:41,750 --> 00:17:44,330
put too

00:17:42,200 --> 00:17:46,370
a diagram wrong we're not going to try

00:17:44,330 --> 00:17:48,769
and run against the database and they're

00:17:46,370 --> 00:17:51,139
not gonna get nasty 500 errors the user

00:17:48,769 --> 00:17:52,399
interface itself does have their allows

00:17:51,139 --> 00:17:55,340
them to build those diagrams does

00:17:52,399 --> 00:17:56,659
actually have a little bit of a if you

00:17:55,340 --> 00:17:58,789
like a type you're calling it a type

00:17:56,659 --> 00:17:59,960
checker is really really too generous I

00:17:58,789 --> 00:18:01,549
suppose but it does have a little

00:17:59,960 --> 00:18:03,799
version that just gives them a little

00:18:01,549 --> 00:18:06,230
bit visual feedback when things go wrong

00:18:03,799 --> 00:18:11,679
fantastic did I keep it under just under

00:18:06,230 --> 00:18:11,679

YouTube URL: https://www.youtube.com/watch?v=xqS22zrzYvM


