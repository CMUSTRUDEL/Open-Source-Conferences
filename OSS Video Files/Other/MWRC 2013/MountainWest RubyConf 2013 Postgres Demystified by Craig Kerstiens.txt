Title: MountainWest RubyConf 2013 Postgres Demystified by Craig Kerstiens
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	"Postgres has long been known as a stable database product that reliably stores your data. However, in recent years it has picked up many features, allowing it to become a much sexier database.
We'll cover a whirlwind of Postgres features, which highlight why you should consider it for your next project. These include:
Datatypes
Using other languages within Postgres
Extensions including NoSQL inside your SQL database
Accessing your non-Postgres data (Redis, Oracle, MySQL) from within Postgres
Window Functions

Help us caption & translate this video!

http://amara.org/v/FGbX/
Captions: 
	00:00:00,050 --> 00:00:02,110
you

00:00:10,600 --> 00:00:13,170
mmm

00:00:19,660 --> 00:00:24,290
hi everyone so I'm quite cursings i

00:00:22,580 --> 00:00:26,840
worked at roku specifically on the

00:00:24,290 --> 00:00:28,130
Heroku post crest team so before I get

00:00:26,840 --> 00:00:30,530
started a really quick show of question

00:00:28,130 --> 00:00:34,280
show of hands who years who here uses

00:00:30,530 --> 00:00:37,400
postgres already awesome who doesn't at

00:00:34,280 --> 00:00:38,660
all okay okay so hopefully I can

00:00:37,400 --> 00:00:43,489
convince a few people that time we're

00:00:38,660 --> 00:00:46,400
done before I dig in a really a few

00:00:43,489 --> 00:00:48,140
quick PSAs if you're on a Mac which most

00:00:46,400 --> 00:00:49,489
people are in the room check out

00:00:48,140 --> 00:00:52,670
postgres tap if you're not already using

00:00:49,489 --> 00:00:54,410
it it's just more native it's nice it's

00:00:52,670 --> 00:00:58,129
not Brewer reports it just kind of works

00:00:54,410 --> 00:00:59,780
like most things on that another one if

00:00:58,129 --> 00:01:02,510
you're into postgres postgres weekly is

00:00:59,780 --> 00:01:03,739
a good weekly newsletter and if you're

00:01:02,510 --> 00:01:05,630
already running postgres and it's

00:01:03,739 --> 00:01:07,220
exposed to the internet and you weren't

00:01:05,630 --> 00:01:09,230
busy upgrading your database yesterday

00:01:07,220 --> 00:01:13,610
please go do that now like leave the

00:01:09,230 --> 00:01:16,580
talk go do that it it is the worst

00:01:13,610 --> 00:01:18,800
vulnerability they've had in 67 years

00:01:16,580 --> 00:01:22,450
now that includes a escalation of

00:01:18,800 --> 00:01:25,130
privileges an rce and a permanent d dose

00:01:22,450 --> 00:01:26,689
to your database if it's publicly facing

00:01:25,130 --> 00:01:32,600
to the internet so it's actually pretty

00:01:26,689 --> 00:01:34,820
bad go update if you haven't already it

00:01:32,600 --> 00:01:36,170
was um it was actually committed by a

00:01:34,820 --> 00:01:39,710
guy I'll talk about in a minute which is

00:01:36,170 --> 00:01:41,119
quite shocking so the agenda i'm going

00:01:39,710 --> 00:01:43,490
to give you just a brief history of

00:01:41,119 --> 00:01:45,520
postgres in the project itself talk a

00:01:43,490 --> 00:01:47,450
little bit on developing with postgres

00:01:45,520 --> 00:01:49,820
talk some on how to understand

00:01:47,450 --> 00:01:51,439
performance that's usually a black box

00:01:49,820 --> 00:01:53,630
for most application developers when it

00:01:51,439 --> 00:01:57,829
comes to working with your database and

00:01:53,630 --> 00:02:01,909
a little bit around querying so on some

00:01:57,829 --> 00:02:05,420
brief history first off its its postgres

00:02:01,909 --> 00:02:10,250
or postgresql it's not post gray it's

00:02:05,420 --> 00:02:12,920
not post gray ql this is tom lane so Tom

00:02:10,250 --> 00:02:15,680
line is actually a he created in

00:02:12,920 --> 00:02:18,100
collaboration created tiff jpg PNG and

00:02:15,680 --> 00:02:20,930
it's the primary contributor to postgres

00:02:18,100 --> 00:02:22,880
and this is a mail from about eight

00:02:20,930 --> 00:02:24,140
years ago where he basically says this

00:02:22,880 --> 00:02:28,580
is probably the worst decision we made

00:02:24,140 --> 00:02:29,810
renaming the project so it's been around

00:02:28,580 --> 00:02:33,319
for a long time depending on when you

00:02:29,810 --> 00:02:33,650
count it's been around since probably 95

00:02:33,319 --> 00:02:35,390
is what

00:02:33,650 --> 00:02:36,590
most people consider its origin it came

00:02:35,390 --> 00:02:38,540
out of ingress which is what most

00:02:36,590 --> 00:02:40,909
databases came out of so its shares the

00:02:38,540 --> 00:02:43,640
same roots as Oracle I'm not sure if

00:02:40,909 --> 00:02:45,170
that's a good or a bad thing but it's

00:02:43,640 --> 00:02:46,879
very different in that it's completely

00:02:45,170 --> 00:02:48,620
community owned and driven there is no

00:02:46,879 --> 00:02:50,510
one person that can ever owned postgres

00:02:48,620 --> 00:02:52,609
which puts it in a unique position so

00:02:50,510 --> 00:02:54,470
it's not going away if a company goes

00:02:52,609 --> 00:02:56,390
bankrupt it can't be acquired it's

00:02:54,470 --> 00:02:58,159
completely community I'm driven which I

00:02:56,390 --> 00:02:59,989
think also contributed a lot to its

00:02:58,159 --> 00:03:03,079
momentum which I'll talk about kind of

00:02:59,989 --> 00:03:06,769
more as we go through here a really

00:03:03,079 --> 00:03:09,319
important concept is MVCC in it multi

00:03:06,769 --> 00:03:11,480
version concurrency control essentially

00:03:09,319 --> 00:03:12,739
what this means is as the transactions

00:03:11,480 --> 00:03:14,540
happening other people can be reading

00:03:12,739 --> 00:03:17,120
from it so it doesn't take a look

00:03:14,540 --> 00:03:18,680
anytime it's writing basically I've read

00:03:17,120 --> 00:03:20,209
can see what was there before and then

00:03:18,680 --> 00:03:22,370
as soon as that transaction is committed

00:03:20,209 --> 00:03:24,230
and can read and this says a lot for

00:03:22,370 --> 00:03:25,879
really kind of the core of what post

00:03:24,230 --> 00:03:29,450
Chris believes how it works and kind of

00:03:25,879 --> 00:03:31,700
under the covers a really high level why

00:03:29,450 --> 00:03:33,319
postgres this is actually a quote I

00:03:31,700 --> 00:03:36,170
stole from a co-worker it's the Emacs of

00:03:33,319 --> 00:03:38,120
databases and I think what he was trying

00:03:36,170 --> 00:03:39,859
to say here's myself being a BEM user is

00:03:38,120 --> 00:03:43,040
it's a platform which you know you can

00:03:39,859 --> 00:03:44,599
build on and you can add extensions to

00:03:43,040 --> 00:03:46,760
it you could it's very extensible it's

00:03:44,599 --> 00:03:48,470
not just a place for restoring texts and

00:03:46,760 --> 00:03:51,049
you know numbers it's a lot more than

00:03:48,470 --> 00:03:53,060
that but if you want a better

00:03:51,049 --> 00:03:55,879
description of kind of why postgres

00:03:53,060 --> 00:03:58,519
here's kind of the TLDR will cover a lot

00:03:55,879 --> 00:03:59,959
of these in the talk pretty quickly but

00:03:58,519 --> 00:04:01,519
if not I mean you can basically just

00:03:59,959 --> 00:04:05,569
search for these and find a pretty good

00:04:01,519 --> 00:04:09,199
description so developing with postgres

00:04:05,569 --> 00:04:13,400
first thing p sequel it's your friend if

00:04:09,199 --> 00:04:17,389
you don't use it it's really awesome so

00:04:13,400 --> 00:04:24,139
we're here now so dt will describe

00:04:17,389 --> 00:04:25,970
tables for you you can you know query /e

00:04:24,139 --> 00:04:28,970
it's awesome it'll open up in your

00:04:25,970 --> 00:04:33,710
default editor of choice i can go in

00:04:28,970 --> 00:04:35,090
here and edit this you can set up

00:04:33,710 --> 00:04:38,260
sublime or whatever you want is your

00:04:35,090 --> 00:04:38,260
default editor and it just works

00:04:41,060 --> 00:04:45,450
there's a ton of commands basically in

00:04:43,140 --> 00:04:46,710
there a backslash ? will give you the

00:04:45,450 --> 00:04:49,650
list of all the commands it's basically

00:04:46,710 --> 00:04:51,030
the help and it's basically if you're

00:04:49,650 --> 00:04:55,200
not using it you you should be as your

00:04:51,030 --> 00:04:56,610
query editor so data types postgres has

00:04:55,200 --> 00:04:59,460
a bit of a different approach than most

00:04:56,610 --> 00:05:01,530
databases to data types their data types

00:04:59,460 --> 00:05:03,270
look like this so you've got things like

00:05:01,530 --> 00:05:05,820
you know the obvious which is a ton of

00:05:03,270 --> 00:05:08,720
you know numeric things and currency and

00:05:05,820 --> 00:05:11,850
that kind of stuff but you've also got

00:05:08,720 --> 00:05:14,340
IP and mac addresses in there you've got

00:05:11,850 --> 00:05:16,320
shapes for like very basic geospatial

00:05:14,340 --> 00:05:17,430
stuff so you can have two points and

00:05:16,320 --> 00:05:19,590
basically compute the distance between

00:05:17,430 --> 00:05:21,470
them just going to highlight a few

00:05:19,590 --> 00:05:23,520
really interesting ones that I think are

00:05:21,470 --> 00:05:26,880
really powerful when you need them and

00:05:23,520 --> 00:05:28,620
often overlooked the first is a race I

00:05:26,880 --> 00:05:31,530
assume everyone here is used in a

00:05:28,620 --> 00:05:32,790
writing side your application right but

00:05:31,530 --> 00:05:33,870
how many times have you used one inside

00:05:32,790 --> 00:05:36,030
your database like why can't they

00:05:33,870 --> 00:05:38,850
actually be the same thing they're so

00:05:36,030 --> 00:05:40,890
pretty straightforward if you've got a

00:05:38,850 --> 00:05:43,110
blog post or an articles and you have

00:05:40,890 --> 00:05:44,430
tags there's really no reason to join

00:05:43,110 --> 00:05:45,810
that against another table just putting

00:05:44,430 --> 00:05:50,010
an array in and put a tag cloud in right

00:05:45,810 --> 00:05:51,950
there so pretty straightforward you

00:05:50,010 --> 00:05:54,660
insert just like you would expect

00:05:51,950 --> 00:05:56,400
there's not a lot of magic science here

00:05:54,660 --> 00:06:02,760
it's basically just and a right inside

00:05:56,400 --> 00:06:04,290
your database then basically you can

00:06:02,760 --> 00:06:05,580
query and filter where it contains all

00:06:04,290 --> 00:06:07,590
of them where it contains one of them

00:06:05,580 --> 00:06:09,090
and the nice thing about actually doing

00:06:07,590 --> 00:06:11,780
this inside the database is this kind of

00:06:09,090 --> 00:06:15,210
push down those optimizations for you

00:06:11,780 --> 00:06:17,700
range types are newer one is of postgres

00:06:15,210 --> 00:06:21,210
92 if you ever done a calendaring

00:06:17,700 --> 00:06:23,940
application you probably had a from in a

00:06:21,210 --> 00:06:26,160
to range types are just that it's it's a

00:06:23,940 --> 00:06:28,530
from Anna too but there's a really nice

00:06:26,160 --> 00:06:30,140
thing that you can can do with them so

00:06:28,530 --> 00:06:32,250
basically you know you can have a

00:06:30,140 --> 00:06:35,640
open-ended the parentheses or the

00:06:32,250 --> 00:06:38,940
brackets it's either it starts now or

00:06:35,640 --> 00:06:40,620
it's this or equal to so there's the

00:06:38,940 --> 00:06:41,820
nuances in there pretty easily so you

00:06:40,620 --> 00:06:44,070
don't have to necessarily build that up

00:06:41,820 --> 00:06:45,510
into your application logic but the

00:06:44,070 --> 00:06:47,160
really nice thing is if you're trying to

00:06:45,510 --> 00:06:49,979
you know you have a capacity for a class

00:06:47,160 --> 00:06:51,990
like the conference a classroom only has

00:06:49,979 --> 00:06:53,430
20 seats and people are registering by

00:06:51,990 --> 00:06:54,240
the time you've run the query to see if

00:06:53,430 --> 00:06:56,020
thats

00:06:54,240 --> 00:06:58,150
available you could actually have

00:06:56,020 --> 00:06:59,830
already inserted and then automatically

00:06:58,150 --> 00:07:01,690
commit someone else you've got 21 people

00:06:59,830 --> 00:07:05,140
in a room that seats 21 in your

00:07:01,690 --> 00:07:06,940
application so with the exclusion

00:07:05,140 --> 00:07:10,240
constraint on this kind of data type

00:07:06,940 --> 00:07:11,800
what you can basically say is I can only

00:07:10,240 --> 00:07:14,590
have you no one talk in this conference

00:07:11,800 --> 00:07:16,180
room at a time or I can I only have 20

00:07:14,590 --> 00:07:19,330
people in this conference room at a time

00:07:16,180 --> 00:07:21,100
so i basically added an exclusion

00:07:19,330 --> 00:07:24,670
constraint right here it looks kind of

00:07:21,100 --> 00:07:25,930
crazy it's it's not too bad insert into

00:07:24,670 --> 00:07:27,730
that and then my database is going to

00:07:25,930 --> 00:07:28,900
raise an error so you've actually got

00:07:27,730 --> 00:07:32,770
the enforcement on the data which is

00:07:28,900 --> 00:07:34,030
where you care about but beyond that you

00:07:32,770 --> 00:07:36,550
know you've got the basic data types

00:07:34,030 --> 00:07:38,860
like I said kind of postgres is a data

00:07:36,550 --> 00:07:41,080
platform as much as it is anything so

00:07:38,860 --> 00:07:44,920
you've got a ton of extensions in it and

00:07:41,080 --> 00:07:46,750
extensions and 94 basically there's

00:07:44,920 --> 00:07:48,280
going to be an app 'get packaging

00:07:46,750 --> 00:07:49,900
repository where you can just install an

00:07:48,280 --> 00:07:51,580
extension from anywhere in the wild

00:07:49,900 --> 00:07:54,370
right now they kind of come packaged

00:07:51,580 --> 00:07:57,100
with postgres but they really extend a

00:07:54,370 --> 00:08:00,880
lot of the functionality so a few

00:07:57,100 --> 00:08:03,640
specific to the data types if you're i

00:08:00,880 --> 00:08:05,260
actually had no idea that this was a big

00:08:03,640 --> 00:08:09,640
issue for a lot of my sequel people but

00:08:05,260 --> 00:08:13,000
by default its case insensitive i think

00:08:09,640 --> 00:08:14,500
as a text when you search and hearing

00:08:13,000 --> 00:08:15,640
someone migrate from my sequel to

00:08:14,500 --> 00:08:16,960
postgres they would have loved to know

00:08:15,640 --> 00:08:20,770
about the CI text type which is a

00:08:16,960 --> 00:08:24,460
case-insensitive data type there's cubes

00:08:20,770 --> 00:08:26,230
for for cubing data there's H store and

00:08:24,460 --> 00:08:28,120
a stores are really awesome one it is

00:08:26,230 --> 00:08:29,500
essentially what kind of starts to

00:08:28,120 --> 00:08:32,320
become no sequel inside your sequel

00:08:29,500 --> 00:08:35,170
database so H store it's as simple as

00:08:32,320 --> 00:08:37,990
saying create extension H door to enable

00:08:35,170 --> 00:08:39,670
it inside your Postgres database and

00:08:37,990 --> 00:08:43,030
then you've got a data type just like

00:08:39,670 --> 00:08:44,560
any other and what it is it's a key

00:08:43,030 --> 00:08:47,380
value store inside your database

00:08:44,560 --> 00:08:48,580
unfortunately it's only text but but

00:08:47,380 --> 00:08:50,340
then I can do things like this where i

00:08:48,580 --> 00:08:52,720
can say you know insert sex and state

00:08:50,340 --> 00:08:53,830
and it gives you that flexibility that

00:08:52,720 --> 00:08:55,780
you care about in your data if you're

00:08:53,830 --> 00:08:57,340
early stage prototyping you don't have

00:08:55,780 --> 00:08:59,350
to run you know migrations on your

00:08:57,340 --> 00:09:01,960
database you can just start adding keys

00:08:59,350 --> 00:09:03,400
and values in there we use this pretty

00:09:01,960 --> 00:09:05,170
heavily in production in places at

00:09:03,400 --> 00:09:07,810
Heroku and it actually it's performant

00:09:05,170 --> 00:09:09,160
it works well you can you can do

00:09:07,810 --> 00:09:13,410
everything that you would expect to do

00:09:09,160 --> 00:09:16,390
with it but like i said it's text only

00:09:13,410 --> 00:09:19,840
and its key value you can't mess thing

00:09:16,390 --> 00:09:21,730
so it's not a full document store and

00:09:19,840 --> 00:09:24,100
that's kind of where json comes in so in

00:09:21,730 --> 00:09:28,330
Postgres 92 there's a negative JSON data

00:09:24,100 --> 00:09:31,690
type it does essentially validation on

00:09:28,330 --> 00:09:33,190
the data and that's about it it doesn't

00:09:31,690 --> 00:09:35,740
do too much more so I validates that

00:09:33,190 --> 00:09:37,980
it's it's valid JSON but not too much

00:09:35,740 --> 00:09:40,029
more but it actually can get a lot nicer

00:09:37,980 --> 00:09:43,630
how many people here have heard of or

00:09:40,029 --> 00:09:46,720
use pill v8 okay that's not nearly

00:09:43,630 --> 00:09:50,320
enough hands p l v8 is a v8 JavaScript

00:09:46,720 --> 00:09:51,490
engine embedded inside postgres so it's

00:09:50,320 --> 00:09:53,170
the exact same thing that's running

00:09:51,490 --> 00:09:55,480
inside that's running inside your

00:09:53,170 --> 00:09:58,810
your Chrome web browser and you can do

00:09:55,480 --> 00:10:00,400
things like like this and I'm not sure

00:09:58,810 --> 00:10:03,160
how quickly anyone can pick up on what

00:10:00,400 --> 00:10:05,170
this is but essentially don't do this

00:10:03,160 --> 00:10:07,960
javascript in text and attacks or a bad

00:10:05,170 --> 00:10:11,020
thing now you can do fun things with

00:10:07,960 --> 00:10:12,460
your data with javascript but don't

00:10:11,020 --> 00:10:13,390
execute arbitrary JavaScript in your

00:10:12,460 --> 00:10:18,010
database because sequel injection

00:10:13,390 --> 00:10:19,839
attacks are bad enough as it is beyond

00:10:18,010 --> 00:10:21,850
that you've got full text search and

00:10:19,839 --> 00:10:25,000
post kiss they could use each their own

00:10:21,850 --> 00:10:26,830
full half-hour if you're you've got data

00:10:25,000 --> 00:10:29,020
and you need text search full text

00:10:26,830 --> 00:10:31,210
search is pretty robust there's a gym

00:10:29,020 --> 00:10:33,970
that that kind of adds it out of the box

00:10:31,210 --> 00:10:35,350
and post just there's a broad set of

00:10:33,970 --> 00:10:37,390
libraries forward so if you're doing geo

00:10:35,350 --> 00:10:46,810
base of spatial stuff it's pretty much

00:10:37,390 --> 00:10:49,720
the de facto so performance sequential

00:10:46,810 --> 00:10:53,160
scans how many people know what a

00:10:49,720 --> 00:10:55,360
sequential scan and index skin are okay

00:10:53,160 --> 00:10:57,430
the general idea is you know they're

00:10:55,360 --> 00:10:58,810
usually assumed to be bad but this is

00:10:57,430 --> 00:11:00,430
most of the time if you're doing any

00:10:58,810 --> 00:11:02,260
data warehousing queries they're

00:11:00,430 --> 00:11:04,450
actually pretty okay that's what you

00:11:02,260 --> 00:11:06,089
want to be doing postgres a lot of times

00:11:04,450 --> 00:11:08,620
is smarter than you are about your data

00:11:06,089 --> 00:11:11,080
and trust it when it does them sometimes

00:11:08,620 --> 00:11:12,850
nuts that said you know indexes are

00:11:11,080 --> 00:11:15,240
still usually good but that's also most

00:11:12,850 --> 00:11:15,240
of the time

00:11:17,230 --> 00:11:26,380
so postgres has a variety of index types

00:11:21,580 --> 00:11:28,610
there's be three gin just KN SP just

00:11:26,380 --> 00:11:30,470
usually people just say create index and

00:11:28,610 --> 00:11:32,120
that's worked pretty well but as soon as

00:11:30,470 --> 00:11:36,860
you start digging under the covers it's

00:11:32,120 --> 00:11:39,290
usually a little bit like this if you're

00:11:36,860 --> 00:11:41,000
unsure you're probably safe be tree is

00:11:39,290 --> 00:11:43,580
the default when you say create index

00:11:41,000 --> 00:11:44,960
this is what happens this is usually

00:11:43,580 --> 00:11:48,890
what you want unless you're doing

00:11:44,960 --> 00:11:52,340
anything unique or crazy gin is a

00:11:48,890 --> 00:11:54,680
generalized inverted index it's what you

00:11:52,340 --> 00:11:56,300
want most of the case when you have an

00:11:54,680 --> 00:11:58,100
array or an H store if you've got

00:11:56,300 --> 00:11:59,870
multiple values inside the the same

00:11:58,100 --> 00:12:01,940
column it's essentially what you want

00:11:59,870 --> 00:12:04,130
and there are exceptions to that but

00:12:01,940 --> 00:12:07,910
you're usually pretty safe if you go

00:12:04,130 --> 00:12:10,310
with it just is pretty much the de facto

00:12:07,910 --> 00:12:12,590
for full text search for shapes for GIS

00:12:10,310 --> 00:12:14,600
stuff so if you're doing anything that

00:12:12,590 --> 00:12:18,140
that case that's kind of where you want

00:12:14,600 --> 00:12:20,900
to look into k NN is k-nearest neighbor

00:12:18,140 --> 00:12:22,700
so that's similarity and SPG I've had it

00:12:20,900 --> 00:12:23,960
explained to me five times by postgres

00:12:22,700 --> 00:12:26,510
people and I still don't understand it

00:12:23,960 --> 00:12:27,830
what I hear it's valuable so I hear it's

00:12:26,510 --> 00:12:31,850
valuable for in phone numbers and that's

00:12:27,830 --> 00:12:35,600
about all I know so good if you find out

00:12:31,850 --> 00:12:36,560
a case we're using it let me now so

00:12:35,600 --> 00:12:39,670
that's great but how do you actually

00:12:36,560 --> 00:12:42,490
understand performance on your database

00:12:39,670 --> 00:12:46,840
so so given a really basic query

00:12:42,490 --> 00:12:48,890
postgres has a command called explain

00:12:46,840 --> 00:12:51,200
you can run in and it's going to give

00:12:48,890 --> 00:12:52,490
you something like this and I know a lot

00:12:51,200 --> 00:12:54,140
of people that work with postgres for a

00:12:52,490 --> 00:12:56,960
lot of years and still don't understand

00:12:54,140 --> 00:12:58,940
this it's it's really not too bad I

00:12:56,960 --> 00:13:03,410
won't say it's too friendly but it's not

00:12:58,940 --> 00:13:04,670
too bad those numbers out to the right

00:13:03,410 --> 00:13:06,380
there's essentially three things right

00:13:04,670 --> 00:13:09,680
there so there's the startup time for

00:13:06,380 --> 00:13:11,510
the query its maximum time that it's

00:13:09,680 --> 00:13:17,090
going to estimate and the rose that it

00:13:11,510 --> 00:13:19,550
expects to return so if you if you run

00:13:17,090 --> 00:13:21,170
explain analyze explain annal explain

00:13:19,550 --> 00:13:23,840
show you what it thinks it's going to do

00:13:21,170 --> 00:13:25,430
explain analyze shows it runs the query

00:13:23,840 --> 00:13:27,290
and shows you what it actually did so

00:13:25,430 --> 00:13:28,310
you've got great out you know what it

00:13:27,290 --> 00:13:29,800
thought it was going to do and then

00:13:28,310 --> 00:13:33,730
you've got the actual time down here

00:13:29,800 --> 00:13:35,380
and if you know postgres well you know

00:13:33,730 --> 00:13:37,029
my stats are off and I hadn't vacuumed

00:13:35,380 --> 00:13:39,220
my data just because I bulk loaded but

00:13:37,029 --> 00:13:42,490
either way like it probably would still

00:13:39,220 --> 00:13:43,630
done the same plan in this case and what

00:13:42,490 --> 00:13:46,959
it's going to show is the actual time

00:13:43,630 --> 00:13:48,370
for this is 295 milliseconds some rough

00:13:46,959 --> 00:13:51,220
guidelines for pretty much any web

00:13:48,370 --> 00:13:52,810
application this isn't the case for for

00:13:51,220 --> 00:13:54,790
data warehousing and you know big data

00:13:52,810 --> 00:13:59,110
reporting that kind of thing but web

00:13:54,790 --> 00:14:00,579
applications rare queries you want to be

00:13:59,110 --> 00:14:01,570
under 100 milliseconds and common

00:14:00,579 --> 00:14:03,640
queries you want to be under 10

00:14:01,570 --> 00:14:05,380
milliseconds and I would actually say

00:14:03,640 --> 00:14:07,510
common queries you probably want to be

00:14:05,380 --> 00:14:09,100
closer to 1 millisecond most

00:14:07,510 --> 00:14:10,209
applications I look at that's what we

00:14:09,100 --> 00:14:14,260
aim to get into and we're pretty

00:14:10,209 --> 00:14:16,089
comfortable with them so obviously given

00:14:14,260 --> 00:14:19,510
this it's doing a sequential scan on

00:14:16,089 --> 00:14:21,399
employees it's going to you know look

00:14:19,510 --> 00:14:27,160
for for salary to be above a certain

00:14:21,399 --> 00:14:28,480
thing adding an index on salary I'm

00:14:27,160 --> 00:14:30,630
going to rerun it it's going to use the

00:14:28,480 --> 00:14:32,680
index scan like you would expect and

00:14:30,630 --> 00:14:36,089
then my total run time is now going to

00:14:32,680 --> 00:14:36,089
be you know one point seven milliseconds

00:14:36,420 --> 00:14:45,459
so a few tips on indexes if you haven't

00:14:42,250 --> 00:14:47,649
used create index concurrently it's

00:14:45,459 --> 00:14:48,970
probably what you want all the time when

00:14:47,649 --> 00:14:50,230
you create an index it takes a lock on

00:14:48,970 --> 00:14:51,459
your table which means you can't write

00:14:50,230 --> 00:14:53,649
to it while it's building up the index

00:14:51,459 --> 00:14:54,579
if you create this concurrently it's

00:14:53,649 --> 00:14:56,290
going to be about two to three times

00:14:54,579 --> 00:14:58,990
slower but let you keep writing data to

00:14:56,290 --> 00:15:01,029
the table so if you ever run certain

00:14:58,990 --> 00:15:02,920
other databases and added an index or

00:15:01,029 --> 00:15:05,500
added a column and it taken takes two or

00:15:02,920 --> 00:15:08,470
three hours that doesn't have to be the

00:15:05,500 --> 00:15:09,880
case with postgres or with with column

00:15:08,470 --> 00:15:13,270
addition or with indexes if you do them

00:15:09,880 --> 00:15:16,420
concurrently conditional indexes are

00:15:13,270 --> 00:15:18,610
great if you've got like a phone book

00:15:16,420 --> 00:15:21,250
application right and you have every

00:15:18,610 --> 00:15:22,510
address someone lived at forever but you

00:15:21,250 --> 00:15:24,339
only care about the current one right

00:15:22,510 --> 00:15:26,050
you can basically say where their

00:15:24,339 --> 00:15:27,880
current address is true and it's going

00:15:26,050 --> 00:15:29,260
to index only on that so you can have

00:15:27,880 --> 00:15:33,610
all of your data there and index on only

00:15:29,260 --> 00:15:35,980
a part of it queries like this are bad

00:15:33,610 --> 00:15:38,140
pretty much in all cases queries like

00:15:35,980 --> 00:15:40,899
better okay if you have a wild card at a

00:15:38,140 --> 00:15:42,550
start there's pretty much no optimizer

00:15:40,899 --> 00:15:44,500
that's going to help you there

00:15:42,550 --> 00:15:47,440
with full text search there are some

00:15:44,500 --> 00:15:49,300
things around that but basically never

00:15:47,440 --> 00:15:53,830
run a query with a wild card at the

00:15:49,300 --> 00:15:57,070
start of it there's also some extensions

00:15:53,830 --> 00:15:59,529
for post crest performance there's PG

00:15:57,070 --> 00:16:01,660
row row row locks and PG stat tupple

00:15:59,529 --> 00:16:04,420
that give you various statistic

00:16:01,660 --> 00:16:06,370
information on it you can kind of dig

00:16:04,420 --> 00:16:07,300
into those but I mean I think really the

00:16:06,370 --> 00:16:08,829
more interesting thing is how do you

00:16:07,300 --> 00:16:11,230
understand really from afar what's going

00:16:08,829 --> 00:16:13,810
on in your database it's great if you

00:16:11,230 --> 00:16:15,760
know this query is bad but most

00:16:13,810 --> 00:16:16,959
applications have tens hundreds of

00:16:15,760 --> 00:16:19,510
different queries that are regularly

00:16:16,959 --> 00:16:22,810
running and and how do you know if your

00:16:19,510 --> 00:16:25,300
database is healthy postgres is really

00:16:22,810 --> 00:16:27,880
good and don't worry too much about the

00:16:25,300 --> 00:16:29,890
code that's on here there's a lot of it

00:16:27,880 --> 00:16:31,300
in what's actually there isn't as

00:16:29,890 --> 00:16:33,640
interesting is kind of the high level of

00:16:31,300 --> 00:16:36,250
it essentially postgres keeps frequently

00:16:33,640 --> 00:16:38,320
accessed data in its hot cash it's going

00:16:36,250 --> 00:16:41,050
to keep that in memory for you and it

00:16:38,320 --> 00:16:42,730
knows when you access data frequently so

00:16:41,050 --> 00:16:44,410
what you want is essentially enough

00:16:42,730 --> 00:16:47,380
memory for your database so that it sits

00:16:44,410 --> 00:16:49,870
most of your data is following the 8020

00:16:47,380 --> 00:16:51,310
the 90 10 really in most cases kind of

00:16:49,870 --> 00:16:53,170
been ninety nine percent one percent

00:16:51,310 --> 00:16:55,089
rule where it's it's accessing data from

00:16:53,170 --> 00:16:58,089
cash so I'm just going to copy this

00:16:55,089 --> 00:17:03,430
query actually and come over here and

00:16:58,089 --> 00:17:05,410
run it so right here you can see I've

00:17:03,430 --> 00:17:09,189
got a cache hit rate of ninety-two

00:17:05,410 --> 00:17:10,510
percent an index hit rate of 91 it's on

00:17:09,189 --> 00:17:12,939
my laptop so I'm not too worried about

00:17:10,510 --> 00:17:15,970
that you can also get a more detailed

00:17:12,939 --> 00:17:19,270
breakdown of index hit right so running

00:17:15,970 --> 00:17:22,089
this query will give you index hit rate

00:17:19,270 --> 00:17:23,380
that looks like this and what this is

00:17:22,089 --> 00:17:27,730
going to show is the rows in the table

00:17:23,380 --> 00:17:28,990
on the percent use and rough guidelines

00:17:27,730 --> 00:17:30,370
for these I would say you want your

00:17:28,990 --> 00:17:32,980
cache hit rate to be around ninety nine

00:17:30,370 --> 00:17:34,780
percent if it's not add more memory to

00:17:32,980 --> 00:17:36,730
your box databases scale up really well

00:17:34,780 --> 00:17:38,679
it kind of worked for them you don't

00:17:36,730 --> 00:17:42,280
have to shard when you have you know 100

00:17:38,679 --> 00:17:45,280
megabytes of data index hit right 95 99

00:17:42,280 --> 00:17:47,110
percent it's always good and index is

00:17:45,280 --> 00:17:49,600
really on anything that's kind of 10,000

00:17:47,110 --> 00:17:52,150
rows or better so I mean in this case I

00:17:49,600 --> 00:17:54,400
would take everything from rollouts up

00:17:52,150 --> 00:17:55,710
and basically go back and add indexes to

00:17:54,400 --> 00:17:57,600
it

00:17:55,710 --> 00:17:59,700
to see that the consent of time that the

00:17:57,600 --> 00:18:07,679
index is used is increasing like I'd

00:17:59,700 --> 00:18:09,840
expect so PG stat statements is another

00:18:07,679 --> 00:18:11,909
thing in nine to nine dots you had a lot

00:18:09,840 --> 00:18:14,340
of really good features in it this is

00:18:11,909 --> 00:18:16,860
very possibly I think the best one in

00:18:14,340 --> 00:18:18,770
there what it takes is every when you

00:18:16,860 --> 00:18:22,289
turn it on every single query it's

00:18:18,770 --> 00:18:23,760
basically normalizes it so if I'm you

00:18:22,289 --> 00:18:26,250
know actually putting in email addresses

00:18:23,760 --> 00:18:27,870
there it's normalizing you this to you

00:18:26,250 --> 00:18:30,240
know email equals question right there

00:18:27,870 --> 00:18:32,000
and it's going to track the number of

00:18:30,240 --> 00:18:35,120
times it's run how long it takes to run

00:18:32,000 --> 00:18:38,549
and all these other things that I

00:18:35,120 --> 00:18:40,110
understand some parts of of which blocks

00:18:38,549 --> 00:18:42,270
are red which ones are dirty which ones

00:18:40,110 --> 00:18:43,770
are written to the difference between

00:18:42,270 --> 00:18:45,360
shared and logical all that sort of

00:18:43,770 --> 00:18:46,830
things but the interesting thing that

00:18:45,360 --> 00:18:48,929
you can do with it is is run a query

00:18:46,830 --> 00:18:51,899
like this and what this query is going

00:18:48,929 --> 00:18:53,580
to show is cross my entire system what

00:18:51,899 --> 00:18:56,039
is the total time that this queries been

00:18:53,580 --> 00:18:58,529
run what's the average time and what's

00:18:56,039 --> 00:19:00,480
the query itself so basically with this

00:18:58,529 --> 00:19:01,950
I can see which queries are the absolute

00:19:00,480 --> 00:19:04,559
worst on my system where times being

00:19:01,950 --> 00:19:07,620
spent and optimize this really really

00:19:04,559 --> 00:19:10,020
simply I would start off right here on

00:19:07,620 --> 00:19:11,850
that second query whatever it is and

00:19:10,020 --> 00:19:14,549
probably take that from 80 milliseconds

00:19:11,850 --> 00:19:17,010
down to one as best I could and I'm

00:19:14,549 --> 00:19:19,080
saving you know and on the left actually

00:19:17,010 --> 00:19:21,899
it pulls it up in minutes so I'm going

00:19:19,080 --> 00:19:24,620
to save you know 200 minutes of compute

00:19:21,899 --> 00:19:26,850
time on my database down to hopefully 20

00:19:24,620 --> 00:19:29,279
you can also do some pretty cool things

00:19:26,850 --> 00:19:31,890
this is a project that we've got up on

00:19:29,279 --> 00:19:34,409
github that visualizes a lot of stuff

00:19:31,890 --> 00:19:35,940
based on PG stat statements if you're on

00:19:34,409 --> 00:19:38,370
postgres 9 do take a look at it it's

00:19:35,940 --> 00:19:40,559
pretty easy to set up and configure but

00:19:38,370 --> 00:19:44,669
it overlays a lot of things like lock

00:19:40,559 --> 00:19:46,559
contention cache hit sequential scans

00:19:44,669 --> 00:19:50,190
all those sort of things right there for

00:19:46,559 --> 00:19:52,860
you and if you're on Heroku check out

00:19:50,190 --> 00:19:54,480
BTW extras even if you're not on Heroku

00:19:52,860 --> 00:19:56,730
take a look at it all the queries or in

00:19:54,480 --> 00:19:59,370
the source there it's a command-line

00:19:56,730 --> 00:20:02,610
plug-in but it'll basically easily show

00:19:59,370 --> 00:20:05,279
you cache hit index hit locks currently

00:20:02,610 --> 00:20:06,840
running queries on your database unused

00:20:05,279 --> 00:20:08,760
indexes all these sort of things that

00:20:06,840 --> 00:20:09,580
you actually care about but postgres

00:20:08,760 --> 00:20:16,960
doesn't make it easy

00:20:09,580 --> 00:20:18,460
to really get it so query I'm not going

00:20:16,960 --> 00:20:20,380
to cover too many of the basics hear

00:20:18,460 --> 00:20:23,890
more of hopefully the more interesting

00:20:20,380 --> 00:20:25,270
things window functions are something

00:20:23,890 --> 00:20:26,590
that's been around for a few years but

00:20:25,270 --> 00:20:29,050
it still seems like not enough people

00:20:26,590 --> 00:20:31,420
know about them essentially if you want

00:20:29,050 --> 00:20:34,630
to aggregate on some subgroup and order

00:20:31,420 --> 00:20:35,980
it so if you want to find I've got an

00:20:34,630 --> 00:20:37,750
example database you then we run a query

00:20:35,980 --> 00:20:39,700
on in a minute if i want to find my

00:20:37,750 --> 00:20:41,260
topspin der by every state so i got you

00:20:39,700 --> 00:20:43,720
know their purchases i've got the state

00:20:41,260 --> 00:20:45,670
they're in and I could find the top one

00:20:43,720 --> 00:20:48,910
by just ordering all of it but how do I

00:20:45,670 --> 00:20:51,310
find the top in each site window

00:20:48,910 --> 00:20:53,860
functions make this pretty easy I can

00:20:51,310 --> 00:20:55,870
basically rank over some value and then

00:20:53,860 --> 00:20:59,410
partition by that subgroup so in this

00:20:55,870 --> 00:21:02,050
case I'm going to partition by the H

00:20:59,410 --> 00:21:11,560
store value of state and I can actually

00:21:02,050 --> 00:21:13,300
just run this as well and you can see

00:21:11,560 --> 00:21:15,430
like Florida getting into the number one

00:21:13,300 --> 00:21:16,570
person for New York I've got seven

00:21:15,430 --> 00:21:18,280
people in there and it's got the order

00:21:16,570 --> 00:21:19,570
of them and I can filter on this so if

00:21:18,280 --> 00:21:22,330
you're doing any kind of reporting on

00:21:19,570 --> 00:21:24,520
your data and pulling stuff up into

00:21:22,330 --> 00:21:26,890
application logic and then doing further

00:21:24,520 --> 00:21:28,120
manipulation a window function is

00:21:26,890 --> 00:21:30,480
probably actually what you want to be

00:21:28,120 --> 00:21:34,480
able to solve that pretty quickly

00:21:30,480 --> 00:21:37,780
there's also a lot of extensions around

00:21:34,480 --> 00:21:39,250
reporting fuzzy string matching is a

00:21:37,780 --> 00:21:42,670
really fun one that'll show you how

00:21:39,250 --> 00:21:44,890
similar two strings are I won't go into

00:21:42,670 --> 00:21:46,780
this just to potentially save some room

00:21:44,890 --> 00:21:49,180
if I get through everything for for

00:21:46,780 --> 00:21:50,470
questions but basically it'll say you

00:21:49,180 --> 00:21:52,930
know are these things similar they not

00:21:50,470 --> 00:21:54,130
do they sound the like or do they not so

00:21:52,930 --> 00:21:57,160
it's a nice kind of quick and dirty

00:21:54,130 --> 00:21:59,350
spell check if you want to try it for

00:21:57,160 --> 00:22:01,780
moving data around copy is really great

00:21:59,350 --> 00:22:05,080
it's really efficient at copying data

00:22:01,780 --> 00:22:07,300
into or out of your database but another

00:22:05,080 --> 00:22:09,640
actually kind of fun solution is DB link

00:22:07,300 --> 00:22:11,350
so DB link will let you query from one

00:22:09,640 --> 00:22:13,450
Postgres database to another and then

00:22:11,350 --> 00:22:15,010
join across that data it'll do things

00:22:13,450 --> 00:22:16,270
like pushing down conditions and all

00:22:15,010 --> 00:22:18,520
that sort of stuff so it's actually

00:22:16,270 --> 00:22:20,590
pretty efficient now I wouldn't pull

00:22:18,520 --> 00:22:22,930
back your whole database from one data

00:22:20,590 --> 00:22:24,250
set to another but when you want

00:22:22,930 --> 00:22:28,180
query you know disparate data it's

00:22:24,250 --> 00:22:30,010
actually really good for that and kind

00:22:28,180 --> 00:22:31,900
of in-depth vein there's a something

00:22:30,010 --> 00:22:34,630
called foreign data wrappers so foreign

00:22:31,900 --> 00:22:37,270
data rappers rap external data service

00:22:34,630 --> 00:22:39,460
providers so things like Oracle my

00:22:37,270 --> 00:22:41,920
sequel even Twitter which I haven't

00:22:39,460 --> 00:22:43,210
tried and I'm not sure what it does but

00:22:41,920 --> 00:22:56,470
you can query Twitter from inside

00:22:43,210 --> 00:22:59,710
postgres I there's some interesting ones

00:22:56,470 --> 00:23:01,930
out there um so it's not they're not

00:22:59,710 --> 00:23:03,580
exactly friendly to set up but it's not

00:23:01,930 --> 00:23:06,700
too bad I've actually set one up locally

00:23:03,580 --> 00:23:12,100
and I'm running reddits locally and once

00:23:06,700 --> 00:23:15,370
it's there so before I did dtp to

00:23:12,100 --> 00:23:16,720
describe my tables if I just do /d you

00:23:15,370 --> 00:23:23,110
can see there's a foreign table they're

00:23:16,720 --> 00:23:24,370
called Redis I can select from that and

00:23:23,110 --> 00:23:26,920
it just basically cleared to my droid

00:23:24,370 --> 00:23:28,600
Redis and return that in Postgres I can

00:23:26,920 --> 00:23:31,540
run a more interesting query on that too

00:23:28,600 --> 00:23:33,070
and join against that data so in this

00:23:31,540 --> 00:23:34,780
case I'm in right as I'm storing you

00:23:33,070 --> 00:23:37,930
know like visits every time the user

00:23:34,780 --> 00:23:42,100
visits to the website I can join this

00:23:37,930 --> 00:23:44,680
against user IDs and get you know what

00:23:42,100 --> 00:23:49,690
is the user ID email of people that have

00:23:44,680 --> 00:23:51,190
visited at least 50 times I used to say

00:23:49,690 --> 00:23:52,300
the reddest one wasn't quite production

00:23:51,190 --> 00:23:54,340
ready though actually they've actually

00:23:52,300 --> 00:23:55,630
really you've been working on it so it's

00:23:54,340 --> 00:23:57,880
getting a lot better but if you're doing

00:23:55,630 --> 00:24:01,600
this in reporting fashion it's usually

00:23:57,880 --> 00:24:04,780
not too bad cccs are another thing

00:24:01,600 --> 00:24:07,180
common table expressions or commonly

00:24:04,780 --> 00:24:11,560
referred to as with clauses how many

00:24:07,180 --> 00:24:13,330
people here like writing sequel that's

00:24:11,560 --> 00:24:15,580
entirely too many hands it's a horrible

00:24:13,330 --> 00:24:18,340
language

00:24:15,580 --> 00:24:20,350
it's incredibly powerful but it's it's a

00:24:18,340 --> 00:24:21,970
horrible language it's not it easy to

00:24:20,350 --> 00:24:23,560
follow to understand if you ever looked

00:24:21,970 --> 00:24:25,660
at somebody else's queries and just like

00:24:23,560 --> 00:24:28,540
wanted to you know stab yourself in the

00:24:25,660 --> 00:24:30,940
eye with a pencil that's pretty common

00:24:28,540 --> 00:24:33,280
um ctes actually makes equal pretty

00:24:30,940 --> 00:24:35,680
variable and pretty nice really they're

00:24:33,280 --> 00:24:39,550
kind of like views inside a single query

00:24:35,680 --> 00:24:41,530
so you basically say with whatever i'm

00:24:39,550 --> 00:24:43,660
gonna name it up here I have some more

00:24:41,530 --> 00:24:46,150
complex query inside there and I can

00:24:43,660 --> 00:24:47,920
stain these together and then later in

00:24:46,150 --> 00:24:49,750
an actual query at the bottom I can just

00:24:47,920 --> 00:24:51,160
reference that above so it's going to

00:24:49,750 --> 00:24:52,690
reference the result of that just as if

00:24:51,160 --> 00:24:56,560
it's any other kind of table that exists

00:24:52,690 --> 00:24:58,630
for that query so what you can end up

00:24:56,560 --> 00:25:00,910
with are you know 50 line queries but

00:24:58,630 --> 00:25:04,300
actually it's understandable by someone

00:25:00,910 --> 00:25:08,110
that just comes to it so a few more

00:25:04,300 --> 00:25:12,580
things this is a pretty new one postgres

00:25:08,110 --> 00:25:14,320
hyper log log if there's any stats

00:25:12,580 --> 00:25:17,380
people in the room they may understand

00:25:14,320 --> 00:25:20,200
what all this is better than I do it's a

00:25:17,380 --> 00:25:23,350
que mean value bit observable patterns

00:25:20,200 --> 00:25:25,210
basically it's for storing uniques and

00:25:23,350 --> 00:25:27,010
big data and a really small data set so

00:25:25,210 --> 00:25:32,020
you can store tens of billions of

00:25:27,010 --> 00:25:34,960
uniques inside 180 byte data type with a

00:25:32,020 --> 00:25:36,520
one percent error essentially so really

00:25:34,960 --> 00:25:38,170
efficient at tracking uniques and being

00:25:36,520 --> 00:25:42,460
able to Union across them group across

00:25:38,170 --> 00:25:43,690
it that kind of thing basically it's

00:25:42,460 --> 00:25:45,880
like any other extension created

00:25:43,690 --> 00:25:47,830
extension you've got your data type and

00:25:45,880 --> 00:25:49,960
then you basically add this into that

00:25:47,830 --> 00:25:51,550
data type so you have some other value

00:25:49,960 --> 00:25:53,470
that you want to bucket it by so if it's

00:25:51,550 --> 00:25:56,590
date and then you can roll up in more

00:25:53,470 --> 00:25:58,750
complicated things so I can select like

00:25:56,590 --> 00:26:00,700
a query based on that and basically say

00:25:58,750 --> 00:26:02,380
give me the cardinality of my users by

00:26:00,700 --> 00:26:04,810
by date how many uniques did I have on

00:26:02,380 --> 00:26:06,790
each state within I can also do that

00:26:04,810 --> 00:26:08,380
across month so I can extract the month

00:26:06,790 --> 00:26:10,150
and do that really efficiently without

00:26:08,380 --> 00:26:12,190
having to do a select distinct across

00:26:10,150 --> 00:26:13,840
millions and millions of records this is

00:26:12,190 --> 00:26:17,140
actually really efficient and it should

00:26:13,840 --> 00:26:21,640
come a grenade at as you insert data a

00:26:17,140 --> 00:26:23,380
few more extras listen notify is

00:26:21,640 --> 00:26:25,630
essentially pub/sub inside your database

00:26:23,380 --> 00:26:27,700
so it's not uncommon for people to use

00:26:25,630 --> 00:26:29,020
their databases AQ it's actually not

00:26:27,700 --> 00:26:31,930
that bad if you use it

00:26:29,020 --> 00:26:34,510
without pulling q classic is a great

00:26:31,930 --> 00:26:36,580
library for this hopefully there's a few

00:26:34,510 --> 00:26:40,180
users of it out there instead of delight

00:26:36,580 --> 00:26:41,950
job it's great it's efficient and it

00:26:40,180 --> 00:26:43,780
just kind of works per transaction

00:26:41,950 --> 00:26:46,840
synchronous replication is another nice

00:26:43,780 --> 00:26:49,210
feature by default post-crisis

00:26:46,840 --> 00:26:50,290
replication is asynchronous so there's

00:26:49,210 --> 00:26:52,710
going to be lag there but if there's

00:26:50,290 --> 00:26:55,030
things that you care about like

00:26:52,710 --> 00:26:57,040
purchases you can make sure those are

00:26:55,030 --> 00:26:58,270
synchronous so they can be slower you

00:26:57,040 --> 00:26:59,620
can do it on that only that single

00:26:58,270 --> 00:27:01,660
transaction so everything else in your

00:26:59,620 --> 00:27:02,920
replication is I synchronous so photo

00:27:01,660 --> 00:27:05,430
uploads you don't care about if they're

00:27:02,920 --> 00:27:08,530
lost but purchases you do care about

00:27:05,430 --> 00:27:10,780
select for update is another nice one a

00:27:08,530 --> 00:27:12,700
lot of these things are pretty native in

00:27:10,780 --> 00:27:14,980
Ruby so full text search there's a PG

00:27:12,700 --> 00:27:16,360
search gym there's a nice upsert gym if

00:27:14,980 --> 00:27:19,740
you want that functionality that I think

00:27:16,360 --> 00:27:22,090
uses the CTE q classic to listen notify

00:27:19,740 --> 00:27:24,820
sequel is awesome to actually get most

00:27:22,090 --> 00:27:27,610
of the postgres functionality it doesn't

00:27:24,820 --> 00:27:29,680
try to treat all databases the same it

00:27:27,610 --> 00:27:31,830
actually going to give support to two

00:27:29,680 --> 00:27:34,900
features when they're they're

00:27:31,830 --> 00:27:37,960
essentially again this is the TLDR I

00:27:34,900 --> 00:27:39,400
think the biggest thing that's to me

00:27:37,960 --> 00:27:42,160
kind of exciting about postgres right

00:27:39,400 --> 00:27:43,630
now is the momentum that it's got the

00:27:42,160 --> 00:27:46,030
community seems to be growing as

00:27:43,630 --> 00:27:48,280
including the core community so things

00:27:46,030 --> 00:27:50,590
like more and more extensions more and

00:27:48,280 --> 00:27:52,510
more flexibility better JSON support

00:27:50,590 --> 00:27:54,250
better support for big data all these

00:27:52,510 --> 00:27:56,740
things are rapidly coming in coming

00:27:54,250 --> 00:27:58,180
years which I think we've seen kind of

00:27:56,740 --> 00:28:02,490
that momentum start to build over the

00:27:58,180 --> 00:28:02,490
past few all right thanks

00:28:17,500 --> 00:28:20,500
member

00:28:33,120 --> 00:28:35,360

YouTube URL: https://www.youtube.com/watch?v=3TnVl97ZZL8


