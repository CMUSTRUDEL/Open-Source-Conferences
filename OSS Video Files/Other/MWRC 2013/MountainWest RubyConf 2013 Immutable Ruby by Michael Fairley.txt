Title: MountainWest RubyConf 2013 Immutable Ruby by Michael Fairley
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	Most Ruby code makes heavy use of mutable state, which often contributes to long term maintenance problems. Mutability can lead to code that's difficult to understand, libraries and applications that aren't thread-safe, and tests that are slow and brittle. Immutability, on the other hand, can make code easy to reason about, safe to use in multi-threaded environments, and simple to test. Doesn't that sound nice?
This talk answers the question ""why immutability?"", covers the building blocks of immutable code, such as value objects and persistent data structures, as well as higher order concepts that make heavy use of immutability, such as event sourcing and pure functions, and finally discusses the tradeoffs involved in going immutable.

Help us caption & translate this video!

http://amara.org/v/FGbs/
Captions: 
	00:00:19,640 --> 00:00:24,900
so we learned yesterday that comic sans

00:00:22,950 --> 00:00:26,670
is one of the more readable fonts so i

00:00:24,900 --> 00:00:30,080
went home and immediately changed my

00:00:26,670 --> 00:00:30,080
entire slide deck to be in comic sans

00:00:31,580 --> 00:00:37,890
now I'm actually just trolling with that

00:00:35,090 --> 00:00:40,320
my name is Michael fairly i work at

00:00:37,890 --> 00:00:42,210
braintree payments we make it easy for

00:00:40,320 --> 00:00:44,610
businesses of any size to accept credit

00:00:42,210 --> 00:00:46,320
card payments online we work with

00:00:44,610 --> 00:00:47,820
thousands of really awesome merchants

00:00:46,320 --> 00:00:49,440
including some of these that you

00:00:47,820 --> 00:00:50,820
probably recognize so if you're

00:00:49,440 --> 00:00:53,489
interested in talking about payments

00:00:50,820 --> 00:00:55,370
come find me later I'm going to be

00:00:53,489 --> 00:00:58,710
talking about immutability today

00:00:55,370 --> 00:01:01,409
immutability simply put is when data

00:00:58,710 --> 00:01:03,510
can't be changed so in Ruby this would

00:01:01,409 --> 00:01:05,460
refer to an object that can't be

00:01:03,510 --> 00:01:07,080
modified after you create it but it

00:01:05,460 --> 00:01:09,210
could also be data in your database that

00:01:07,080 --> 00:01:13,380
you only ever insert you never update or

00:01:09,210 --> 00:01:15,659
delete it I've had some some bad

00:01:13,380 --> 00:01:16,830
experiences with mutable code in ruby in

00:01:15,659 --> 00:01:19,140
the past few years and some good

00:01:16,830 --> 00:01:20,340
experiences with some immutable code so

00:01:19,140 --> 00:01:22,560
I'm going to give you some examples of

00:01:20,340 --> 00:01:27,420
pitfalls I've run into and how I've

00:01:22,560 --> 00:01:30,300
worked around them the first point is

00:01:27,420 --> 00:01:32,610
that you already have lots of data in

00:01:30,300 --> 00:01:35,570
your code that you expect not to change

00:01:32,610 --> 00:01:37,860
but that expectation is very implicit

00:01:35,570 --> 00:01:40,950
and I think you should make some of this

00:01:37,860 --> 00:01:43,950
explicit so as an example let's say you

00:01:40,950 --> 00:01:45,660
have a purchase model that I user buy

00:01:43,950 --> 00:01:47,940
something on your site and you record

00:01:45,660 --> 00:01:50,970
who it was what they bought and how much

00:01:47,940 --> 00:01:53,760
they paid well you probably never want

00:01:50,970 --> 00:01:55,560
any of these attributes to change once

00:01:53,760 --> 00:01:57,450
the user made the purchase even if you

00:01:55,560 --> 00:01:59,190
go back and change the price and one of

00:01:57,450 --> 00:02:00,540
these models it won't change how much

00:01:59,190 --> 00:02:03,120
you actually charge their credit card

00:02:00,540 --> 00:02:04,740
and if you change the item ID it won't

00:02:03,120 --> 00:02:07,110
actually change which item you shipped

00:02:04,740 --> 00:02:09,629
them so this is a fairly common pattern

00:02:07,110 --> 00:02:11,550
where you have data that's trying to

00:02:09,629 --> 00:02:14,090
represent events that happened in an

00:02:11,550 --> 00:02:15,780
external system or in the real world and

00:02:14,090 --> 00:02:17,970
you want to make sure those are

00:02:15,780 --> 00:02:19,409
immutable so it'd be nice if we had a

00:02:17,970 --> 00:02:21,180
module like this that we could sort of

00:02:19,409 --> 00:02:24,090
mix into our active record models and

00:02:21,180 --> 00:02:27,150
make them immutable luckily that's five

00:02:24,090 --> 00:02:28,739
lines of code so active record calls the

00:02:27,150 --> 00:02:30,540
read only method any time it tries to

00:02:28,739 --> 00:02:32,370
save our update a method and if it

00:02:30,540 --> 00:02:34,500
returns true it doesn't actually update

00:02:32,370 --> 00:02:35,730
so here we just say that any record

00:02:34,500 --> 00:02:40,319
that's already been persisted is

00:02:35,730 --> 00:02:41,730
read-only and bam immutability and so we

00:02:40,319 --> 00:02:43,379
can create records fine but when we try

00:02:41,730 --> 00:02:45,090
to update them will get an error and so

00:02:43,379 --> 00:02:48,269
our code will sort of enforce the

00:02:45,090 --> 00:02:49,980
behavior you one upon us and if we're in

00:02:48,269 --> 00:02:52,170
a script console in production and we

00:02:49,980 --> 00:02:53,549
sort of have a momentary lapse where we

00:02:52,170 --> 00:02:55,440
forget that we aren't supposed to tweak

00:02:53,549 --> 00:02:58,409
this data the system will stop you and

00:02:55,440 --> 00:03:00,390
that's what you want and you can even

00:02:58,409 --> 00:03:03,620
take this one step further and enforce

00:03:00,390 --> 00:03:06,239
these constraints at the database level

00:03:03,620 --> 00:03:08,040
but what if we have a field or some

00:03:06,239 --> 00:03:09,840
fields that we want to be able to change

00:03:08,040 --> 00:03:11,310
and some that we don't so here I've

00:03:09,840 --> 00:03:14,010
added a status field that's going to

00:03:11,310 --> 00:03:16,190
progress from processing to shipped to

00:03:14,010 --> 00:03:18,480
deliver it and then maybe refunded later

00:03:16,190 --> 00:03:20,030
well we want that field to change but we

00:03:18,480 --> 00:03:26,190
still don't want the other three two

00:03:20,030 --> 00:03:28,200
luckily there's a gem for that so we can

00:03:26,190 --> 00:03:30,870
mark these three attributes as immutable

00:03:28,200 --> 00:03:34,349
and if we ever try to update them will

00:03:30,870 --> 00:03:36,239
get an error and you also run into this

00:03:34,349 --> 00:03:41,430
problem in your code to not just in your

00:03:36,239 --> 00:03:43,440
database so this is a dubiously helpful

00:03:41,430 --> 00:03:45,209
method that lets you take a domain name

00:03:43,440 --> 00:03:47,629
a path and some optional query

00:03:45,209 --> 00:03:50,099
parameters and it builds the URL for you

00:03:47,629 --> 00:03:52,349
and sort of takes care of if there's

00:03:50,099 --> 00:03:56,340
extra slashes or two for you making sure

00:03:52,349 --> 00:03:57,870
they work out so example that common

00:03:56,340 --> 00:04:01,440
blog it just concatenate them together

00:03:57,870 --> 00:04:03,329
or if we pass it a hash it'll sort of

00:04:01,440 --> 00:04:06,389
serialize that into the query parameters

00:04:03,329 --> 00:04:07,590
and tack it on so let's say you have

00:04:06,389 --> 00:04:09,419
this and you realize that you're using

00:04:07,590 --> 00:04:11,970
it the same domain name over and over

00:04:09,419 --> 00:04:14,250
again and you extract another helper on

00:04:11,970 --> 00:04:18,150
top of it so here we have example.com

00:04:14,250 --> 00:04:22,889
hard coded and our blog URL and our

00:04:18,150 --> 00:04:24,990
sordid photos look the same but this

00:04:22,889 --> 00:04:27,030
this hard-coded string is kind of ugly

00:04:24,990 --> 00:04:28,680
its configuration that's been hard coded

00:04:27,030 --> 00:04:30,930
into your app and you want a way to be

00:04:28,680 --> 00:04:32,940
able to tweak it so you pull it out into

00:04:30,930 --> 00:04:35,789
either a constant or this could be an

00:04:32,940 --> 00:04:39,060
environment variable or some data for me

00:04:35,789 --> 00:04:43,080
llamo file you loaded and the blog URL

00:04:39,060 --> 00:04:44,600
looks fine the sorted photos now has

00:04:43,080 --> 00:04:48,800
blog in the path which is a little

00:04:44,600 --> 00:04:50,810
funny let's try that again that's not

00:04:48,800 --> 00:04:53,870
quite what we wanted something has gone

00:04:50,810 --> 00:04:56,690
very wrong here let's try to figure out

00:04:53,870 --> 00:04:58,100
what happened so originally when the

00:04:56,690 --> 00:05:01,130
string was hard-coded into the method

00:04:58,100 --> 00:05:03,020
every time build example URL got called

00:05:01,130 --> 00:05:06,350
we generated a new string that was

00:05:03,020 --> 00:05:08,000
example.com once we extracted this this

00:05:06,350 --> 00:05:10,210
constant out there was only one instance

00:05:08,000 --> 00:05:13,190
of the string ever being created and

00:05:10,210 --> 00:05:14,930
every time we called example URL we're

00:05:13,190 --> 00:05:17,870
passing the same string and to build URL

00:05:14,930 --> 00:05:21,080
and build URL was destructively adding

00:05:17,870 --> 00:05:22,940
on to the end of it so the fix for this

00:05:21,080 --> 00:05:25,040
is pretty simple you just use plus equal

00:05:22,940 --> 00:05:29,660
instead of shovel and that won't modify

00:05:25,040 --> 00:05:33,980
the the base URL but whoever did the

00:05:29,660 --> 00:05:36,350
refactoring to extract the string into a

00:05:33,980 --> 00:05:37,730
constant wasn't paying attention to

00:05:36,350 --> 00:05:39,140
build URL they didn't realize that this

00:05:37,730 --> 00:05:41,360
string was going to be mutated later

00:05:39,140 --> 00:05:43,520
wasn't something that they thought about

00:05:41,360 --> 00:05:44,630
or should have to think about so what

00:05:43,520 --> 00:05:46,790
this person could have done is been a

00:05:44,630 --> 00:05:48,770
little more defensive and frozen the

00:05:46,790 --> 00:05:50,180
string ahead of time and the second the

00:05:48,770 --> 00:05:51,770
test suite runs it would have blown up

00:05:50,180 --> 00:05:54,610
saying you tried to modify this string

00:05:51,770 --> 00:05:56,600
that you intended to never be modified I

00:05:54,610 --> 00:05:59,570
think this is a pattern that you should

00:05:56,600 --> 00:06:00,950
be using for configuration and constants

00:05:59,570 --> 00:06:03,290
and things like that that you plan on

00:06:00,950 --> 00:06:05,960
never ever being modified just to make

00:06:03,290 --> 00:06:08,150
sure that when it gets passed around

00:06:05,960 --> 00:06:10,490
maybe 99 methods down a call stack

00:06:08,150 --> 00:06:13,850
someone doesn't realize that the string

00:06:10,490 --> 00:06:16,580
was supposed to be immutable and there's

00:06:13,850 --> 00:06:17,960
one gotcha with fries which is that if

00:06:16,580 --> 00:06:19,520
you freeze an array it won't freeze the

00:06:17,960 --> 00:06:21,350
elements inside of it or if you freeze

00:06:19,520 --> 00:06:23,570
an object it won't freeze that objects

00:06:21,350 --> 00:06:25,340
instance variables so there's a gem

00:06:23,570 --> 00:06:27,050
called ice nine that adds a deep freeze

00:06:25,340 --> 00:06:30,680
method which will sort of recursively

00:06:27,050 --> 00:06:32,840
freeze an entire tree of objects so when

00:06:30,680 --> 00:06:34,160
you use yambol load file you might want

00:06:32,840 --> 00:06:35,840
to call deep freeze on it and make sure

00:06:34,160 --> 00:06:39,280
that those configuration variables don't

00:06:35,840 --> 00:06:39,280
get changed as your application runs

00:06:39,640 --> 00:06:46,310
next up is values so values conceptually

00:06:43,340 --> 00:06:47,840
are objects whose identity is based on

00:06:46,310 --> 00:06:51,170
the data in sight of them rather than

00:06:47,840 --> 00:06:52,550
some sort of external identity so an

00:06:51,170 --> 00:06:55,040
active record object is not a value

00:06:52,550 --> 00:06:56,990
because even if to active record objects

00:06:55,040 --> 00:06:57,189
have all the same values except for

00:06:56,990 --> 00:07:01,219
their

00:06:57,189 --> 00:07:02,180
they won't be considered equal so values

00:07:01,219 --> 00:07:04,009
you're probably used to working with

00:07:02,180 --> 00:07:05,479
their things like numbers and time where

00:07:04,009 --> 00:07:07,460
you don't really care if the Ruby

00:07:05,479 --> 00:07:08,900
interpreter has two different objects

00:07:07,460 --> 00:07:11,900
that represent the same time you just

00:07:08,900 --> 00:07:13,550
care that they're equal so there's more

00:07:11,900 --> 00:07:16,150
values than just the ones Ruby gives you

00:07:13,550 --> 00:07:19,719
there's things like addresses and

00:07:16,150 --> 00:07:21,830
Cartesian points and you are eyes and

00:07:19,719 --> 00:07:23,749
there's a there's a gem that helps you

00:07:21,830 --> 00:07:27,439
build your own value objects and and use

00:07:23,749 --> 00:07:29,749
them in your system so it works a lot

00:07:27,439 --> 00:07:32,689
like structs here we've created a new

00:07:29,749 --> 00:07:34,849
class called point that has attributes x

00:07:32,689 --> 00:07:37,370
and y and we can build a point at the

00:07:34,849 --> 00:07:39,409
origin and get the data out of it that

00:07:37,370 --> 00:07:41,419
we expect you create another point

00:07:39,409 --> 00:07:43,939
elsewhere and we get the data we expect

00:07:41,419 --> 00:07:45,620
but unlike struct we can't actually

00:07:43,939 --> 00:07:50,180
change the data once we've placed it in

00:07:45,620 --> 00:07:52,400
there like I said and like I said the

00:07:50,180 --> 00:07:54,439
quality is based on the data inside of

00:07:52,400 --> 00:07:57,499
it and not any sort of identity so if

00:07:54,439 --> 00:07:59,060
struct works similarly but with values

00:07:57,499 --> 00:08:02,539
you know that once they're equal they'll

00:07:59,060 --> 00:08:04,419
always be equal you can also add a

00:08:02,539 --> 00:08:06,589
little bit of behavior to values to

00:08:04,419 --> 00:08:08,449
maybe make it print a little more

00:08:06,589 --> 00:08:11,960
prettily or in this case to scale the

00:08:08,449 --> 00:08:16,430
point but these methods can't modify the

00:08:11,960 --> 00:08:19,339
value and so so what good are values

00:08:16,430 --> 00:08:20,779
well skinny controller fat model has

00:08:19,339 --> 00:08:24,110
been a mantra and the rails community

00:08:20,779 --> 00:08:25,219
for close to seven years now and while

00:08:24,110 --> 00:08:27,439
it's awesome that we've gotten all of

00:08:25,219 --> 00:08:28,550
this logic out of our controllers some

00:08:27,439 --> 00:08:31,039
of our models have gotten a little too

00:08:28,550 --> 00:08:33,260
fat most of you probably have I use a

00:08:31,039 --> 00:08:34,820
model called user in your application

00:08:33,260 --> 00:08:37,669
that has hundreds of methods and

00:08:34,820 --> 00:08:39,589
thousands of lines of code and value

00:08:37,669 --> 00:08:44,180
objects are a great way to decompose

00:08:39,589 --> 00:08:45,500
these excessively fat models so let's

00:08:44,180 --> 00:08:48,170
talk about a hypothetical user model

00:08:45,500 --> 00:08:49,850
that has among other things some

00:08:48,170 --> 00:08:52,250
shipping address information in it and

00:08:49,850 --> 00:08:53,930
these are also has a method to calculate

00:08:52,250 --> 00:08:57,290
how much it would cost to ship something

00:08:53,930 --> 00:08:58,760
to that user so first thing we do is we

00:08:57,290 --> 00:09:00,380
make a value that can represent this

00:08:58,760 --> 00:09:03,829
address it has the same four fields that

00:09:00,380 --> 00:09:05,750
we saw in the user and then we can use

00:09:03,829 --> 00:09:08,000
the active record composed of helper to

00:09:05,750 --> 00:09:09,880
map the the fields from the database on

00:09:08,000 --> 00:09:11,190
to one of these value objects

00:09:09,880 --> 00:09:13,120
so this says that we want to make a

00:09:11,190 --> 00:09:16,390
method called shipping address that

00:09:13,120 --> 00:09:18,580
returns an address and then we give the

00:09:16,390 --> 00:09:21,220
mapping from the active record database

00:09:18,580 --> 00:09:25,320
field names to the names that are used

00:09:21,220 --> 00:09:27,610
within the value object itself and so

00:09:25,320 --> 00:09:28,890
when the data gets set on the model as

00:09:27,610 --> 00:09:31,210
it comes out of the database like this

00:09:28,890 --> 00:09:33,940
we can ask for the shipping address and

00:09:31,210 --> 00:09:35,380
it'll give us this value object and we

00:09:33,940 --> 00:09:37,240
can also assign into it with a value

00:09:35,380 --> 00:09:43,360
object and it will decompose it on to

00:09:37,240 --> 00:09:45,280
the constituent fields so there's a

00:09:43,360 --> 00:09:47,230
little bit of pain with the original

00:09:45,280 --> 00:09:48,880
version of this user dot calculate

00:09:47,230 --> 00:09:51,700
shipping price and some of this pain is

00:09:48,880 --> 00:09:53,980
evident from our tests we have to

00:09:51,700 --> 00:09:55,870
require spec helper which requires our

00:09:53,980 --> 00:09:58,180
application which requires all of rails

00:09:55,870 --> 00:10:01,090
and makes our tests take 30 seconds to

00:09:58,180 --> 00:10:03,040
start you know there's hundreds of other

00:10:01,090 --> 00:10:04,390
tests in this file which is a pretty

00:10:03,040 --> 00:10:07,840
clear indication that we're violating

00:10:04,390 --> 00:10:09,430
the single responsibility principle and

00:10:07,840 --> 00:10:10,990
finally we have to use a tool like

00:10:09,430 --> 00:10:13,000
factory girl and we have to insert data

00:10:10,990 --> 00:10:15,880
into the database just to get set up for

00:10:13,000 --> 00:10:17,590
the test if instead we moved the

00:10:15,880 --> 00:10:20,350
calculate shipping price method to

00:10:17,590 --> 00:10:23,170
address you know our test the only

00:10:20,350 --> 00:10:25,180
dependency in here is address there's

00:10:23,170 --> 00:10:27,220
sort of no need for a factory girl or to

00:10:25,180 --> 00:10:29,320
talk to the database and you know maybe

00:10:27,220 --> 00:10:31,630
there's a dozen tests in here but this

00:10:29,320 --> 00:10:35,470
method or this model isn't excessively

00:10:31,630 --> 00:10:37,540
bloated but nicer tests isn't enough

00:10:35,470 --> 00:10:39,850
reason to make it change like this it

00:10:37,540 --> 00:10:41,530
also makes us resilient to sort of

00:10:39,850 --> 00:10:44,320
changing requirements for the

00:10:41,530 --> 00:10:46,540
application what if a user has more than

00:10:44,320 --> 00:10:49,090
one address or we need to be able to

00:10:46,540 --> 00:10:50,920
ship to businesses as well you know with

00:10:49,090 --> 00:10:53,500
the original code it's not obvious how

00:10:50,920 --> 00:10:54,640
we can make these changes but now that

00:10:53,500 --> 00:10:59,620
we've sort of decomposed some of the

00:10:54,640 --> 00:11:02,500
logic on to a value class that can be

00:10:59,620 --> 00:11:05,830
shared it's clear what to do and and

00:11:02,500 --> 00:11:07,960
maybe we want to make it so different

00:11:05,830 --> 00:11:09,790
items have different shipping prices you

00:11:07,960 --> 00:11:11,320
know here we move the calculate shipping

00:11:09,790 --> 00:11:13,990
price method on item and have it taken

00:11:11,320 --> 00:11:15,580
address but if this was taking a user

00:11:13,990 --> 00:11:17,830
instead it wouldn't be clear how to make

00:11:15,580 --> 00:11:20,470
these changes so there's a pattern here

00:11:17,830 --> 00:11:21,760
which is that having different pieces of

00:11:20,470 --> 00:11:24,870
your system communicate with value

00:11:21,760 --> 00:11:26,949
objects gives you a lot more flexibility

00:11:24,870 --> 00:11:29,110
there's another wind from this example

00:11:26,949 --> 00:11:31,420
so let's say you add a checkbox to your

00:11:29,110 --> 00:11:33,459
website that says use my billing address

00:11:31,420 --> 00:11:35,139
is my shipping address well at some

00:11:33,459 --> 00:11:37,509
point you would need code that looks

00:11:35,139 --> 00:11:39,370
like this and if you ever added a new

00:11:37,509 --> 00:11:41,410
field to the address like country for

00:11:39,370 --> 00:11:43,959
example you wouldn't remember to come

00:11:41,410 --> 00:11:45,399
update this but if you're using these

00:11:43,959 --> 00:11:47,259
value objects then you can just assign

00:11:45,399 --> 00:12:00,339
one to the other and it's resilient to

00:11:47,259 --> 00:12:02,889
change in the future so next up is event

00:12:00,339 --> 00:12:04,959
sourcing event sourcing is when you

00:12:02,889 --> 00:12:06,790
capture all of the changes to your

00:12:04,959 --> 00:12:09,279
application state as a sequence of a

00:12:06,790 --> 00:12:13,180
mutable events and this is best

00:12:09,279 --> 00:12:16,209
explained with an example we're going to

00:12:13,180 --> 00:12:17,470
use a bank checking account so you open

00:12:16,209 --> 00:12:19,149
the account you put a thousand dollars

00:12:17,470 --> 00:12:21,670
into it in your balance is a thousand

00:12:19,149 --> 00:12:24,790
dollars you buy a conference ticket your

00:12:21,670 --> 00:12:27,550
balance goes down you get paid your

00:12:24,790 --> 00:12:29,589
balance goes up you buy a book and you

00:12:27,550 --> 00:12:32,529
return it and your balance goes back to

00:12:29,589 --> 00:12:34,720
what it was before so to break this down

00:12:32,529 --> 00:12:36,189
a little bit the events in this system

00:12:34,720 --> 00:12:38,290
are the debits and credits to your

00:12:36,189 --> 00:12:42,189
account the five transactions we saw and

00:12:38,290 --> 00:12:43,540
the derive state is the balance you'll

00:12:42,189 --> 00:12:45,610
notice that if I take away the balance

00:12:43,540 --> 00:12:48,220
each of you could recompute it based on

00:12:45,610 --> 00:12:49,480
the events you see up top so the balance

00:12:48,220 --> 00:12:50,680
here is sort of the state you care about

00:12:49,480 --> 00:12:51,670
when you open your bank account you

00:12:50,680 --> 00:12:54,250
really want to look and see how much

00:12:51,670 --> 00:12:56,019
money do I have it's safe to spend but

00:12:54,250 --> 00:12:57,610
the transactions you've made are

00:12:56,019 --> 00:13:02,470
actually the events that have led to

00:12:57,610 --> 00:13:03,879
that state and because we have this log

00:13:02,470 --> 00:13:05,050
of events we can ask some interesting

00:13:03,879 --> 00:13:07,000
questions and do some interesting things

00:13:05,050 --> 00:13:09,250
with their data you can say what was

00:13:07,000 --> 00:13:11,019
account 110s balance seven days ago and

00:13:09,250 --> 00:13:12,490
if we look at the events leading up

00:13:11,019 --> 00:13:15,279
until that point in time we can answer

00:13:12,490 --> 00:13:17,410
the question pretty easily and then

00:13:15,279 --> 00:13:21,189
events are immutable and so to revert

00:13:17,410 --> 00:13:23,170
them rather than so for the returning

00:13:21,189 --> 00:13:24,790
book example instead of deleting the

00:13:23,170 --> 00:13:26,079
fact that we bought the book at all we

00:13:24,790 --> 00:13:27,999
inserted in a new event that was the

00:13:26,079 --> 00:13:30,490
opposite and return to the money to the

00:13:27,999 --> 00:13:32,110
account and finally events can be

00:13:30,490 --> 00:13:35,319
replayed in a different time or a

00:13:32,110 --> 00:13:36,270
different place so there is an error in

00:13:35,319 --> 00:13:39,020
production at this bank

00:13:36,270 --> 00:13:41,280
they could pull down the event log that

00:13:39,020 --> 00:13:42,840
that was happening when the error

00:13:41,280 --> 00:13:44,700
occurred and replay that event log

00:13:42,840 --> 00:13:46,500
locally up until the point in time where

00:13:44,700 --> 00:13:47,970
the air happened and the developers

00:13:46,500 --> 00:13:50,670
would be looking at the system in the

00:13:47,970 --> 00:13:51,660
exact state where the error occurred or

00:13:50,670 --> 00:13:53,640
if they're ready to roll out a new

00:13:51,660 --> 00:13:55,110
version you can play an event log

00:13:53,640 --> 00:13:57,360
against the old version of the code and

00:13:55,110 --> 00:13:59,160
the new version of the code and make

00:13:57,360 --> 00:14:02,250
sure that they agree at every step along

00:13:59,160 --> 00:14:04,170
the way and there's another event source

00:14:02,250 --> 00:14:07,260
system that most of you use almost every

00:14:04,170 --> 00:14:09,570
day and that's get so and get the events

00:14:07,260 --> 00:14:12,450
are commits the derive state from these

00:14:09,570 --> 00:14:14,130
commits is your working directory you

00:14:12,450 --> 00:14:15,840
can reconstruct pass state and ask

00:14:14,130 --> 00:14:17,910
questions like what am i working

00:14:15,840 --> 00:14:21,780
directory look like as if commits a 3 to

00:14:17,910 --> 00:14:24,690
1 BD and similarly when you revert in a

00:14:21,780 --> 00:14:26,400
bit and get instead of undoing the event

00:14:24,690 --> 00:14:29,250
it adds a new event that's the opposite

00:14:26,400 --> 00:14:31,950
and then get replays git rebase is a

00:14:29,250 --> 00:14:33,450
form of event replay where you take some

00:14:31,950 --> 00:14:38,190
events from one branch and play them on

00:14:33,450 --> 00:14:41,280
another a few years ago I was working at

00:14:38,190 --> 00:14:43,100
a family history startup and we built a

00:14:41,280 --> 00:14:45,150
family tree feature and we decided to

00:14:43,100 --> 00:14:47,730
eventsource all of the changes to this

00:14:45,150 --> 00:14:49,470
family tree so anytime someone came and

00:14:47,730 --> 00:14:52,410
added a family member or changed a

00:14:49,470 --> 00:14:53,970
relationship we log to the event and I'm

00:14:52,410 --> 00:14:56,430
gonna tell you some of the awesome wins

00:14:53,970 --> 00:15:00,180
about we got from this and why we made

00:14:56,430 --> 00:15:01,980
the decision in the first place so you

00:15:00,180 --> 00:15:03,690
can think of family trees as a graph

00:15:01,980 --> 00:15:08,100
where people are the nodes and

00:15:03,690 --> 00:15:09,480
relationships are the edges and up until

00:15:08,100 --> 00:15:11,960
this point in time we have been using

00:15:09,480 --> 00:15:14,190
postgrads to store all of our data and

00:15:11,960 --> 00:15:16,860
post gross is rock-solid it had never

00:15:14,190 --> 00:15:18,810
lost our data we knew how to run it but

00:15:16,860 --> 00:15:20,580
relational databases aren't great for

00:15:18,810 --> 00:15:23,280
storing graphs your queries get ugly

00:15:20,580 --> 00:15:24,570
they're a little slow and sometimes you

00:15:23,280 --> 00:15:26,340
even need to make multiple round trips

00:15:24,570 --> 00:15:28,950
to the database to fully execute the

00:15:26,340 --> 00:15:31,380
query on the other hand there these new

00:15:28,950 --> 00:15:33,510
fancy pants hipster no sequel graph

00:15:31,380 --> 00:15:39,530
databases that make query and graph

00:15:33,510 --> 00:15:39,530
structure sorry the Wi-Fi popped up

00:15:39,660 --> 00:15:45,459
perfect so these graph databases are

00:15:43,180 --> 00:15:46,899
super efficient at querying graph

00:15:45,459 --> 00:15:48,640
structures and traversing along them

00:15:46,899 --> 00:15:51,250
which is exactly what we wanted for our

00:15:48,640 --> 00:15:52,779
family tree but we didn't know how to

00:15:51,250 --> 00:15:54,850
operate this database and we didn't

00:15:52,779 --> 00:15:59,290
really trust it to keep our data in a

00:15:54,850 --> 00:16:01,899
durable fashion so we decided to record

00:15:59,290 --> 00:16:03,640
the event log in Postgres and store the

00:16:01,899 --> 00:16:05,440
computed state of the graph in the graph

00:16:03,640 --> 00:16:06,820
database and so we knew that if the

00:16:05,440 --> 00:16:08,920
graph database fell over in the middle

00:16:06,820 --> 00:16:10,899
of the night we have a canonical copy of

00:16:08,920 --> 00:16:15,040
all of our data in Postgres where we

00:16:10,899 --> 00:16:18,279
trust it another cool thing we got from

00:16:15,040 --> 00:16:20,200
this was an audit log so every so often

00:16:18,279 --> 00:16:24,010
we would have some malicious users calm

00:16:20,200 --> 00:16:26,350
and damage a family tree either by

00:16:24,010 --> 00:16:27,700
adding fake information or removing the

00:16:26,350 --> 00:16:29,800
information that was already there and

00:16:27,700 --> 00:16:32,529
this seems like it'd be a pain to clean

00:16:29,800 --> 00:16:34,000
up but all we had to do was find each of

00:16:32,529 --> 00:16:37,959
the events that one of these malicious

00:16:34,000 --> 00:16:40,329
users caused and revert them and then

00:16:37,959 --> 00:16:41,800
finally we decided that the family tree

00:16:40,329 --> 00:16:43,990
wasn't important to the business and the

00:16:41,800 --> 00:16:45,579
running this graph database was a bigger

00:16:43,990 --> 00:16:47,019
burden than the benefits that it was

00:16:45,579 --> 00:16:49,510
giving us so we decided to move

00:16:47,019 --> 00:16:50,680
everything back into post gross but if

00:16:49,510 --> 00:16:53,110
you've ever done this before you know

00:16:50,680 --> 00:16:55,660
that copying data from one database into

00:16:53,110 --> 00:16:57,250
another is kind of painful even more so

00:16:55,660 --> 00:16:59,079
if they have very different data models

00:16:57,250 --> 00:17:01,899
like a graph database and a relational

00:16:59,079 --> 00:17:03,550
store do so instead of having to copy

00:17:01,899 --> 00:17:05,890
the data out of the graph database back

00:17:03,550 --> 00:17:08,319
into postgres we changed our application

00:17:05,890 --> 00:17:10,240
code so that it knew how to write events

00:17:08,319 --> 00:17:12,280
in to post grads and then we replayed

00:17:10,240 --> 00:17:13,780
the entire event log and at that point

00:17:12,280 --> 00:17:16,360
in time postcards in the graph database

00:17:13,780 --> 00:17:17,559
had the exact same computed values and

00:17:16,360 --> 00:17:20,470
we just turned the graph database off

00:17:17,559 --> 00:17:23,079
and that was the end of the story um so

00:17:20,470 --> 00:17:25,660
you might run into problems where event

00:17:23,079 --> 00:17:28,299
sourcing is an awesome solution that

00:17:25,660 --> 00:17:30,280
gets you some cool winds like this you

00:17:28,299 --> 00:17:31,809
can also do clever things like store

00:17:30,280 --> 00:17:33,790
your computed state in memory where it's

00:17:31,809 --> 00:17:35,740
very fast to query or in Redis where

00:17:33,790 --> 00:17:37,419
it's very fast to query but still have a

00:17:35,740 --> 00:17:39,690
durable record of everything that got

00:17:37,419 --> 00:17:39,690
you there

00:17:43,940 --> 00:17:48,450
there's a bunch of rules in software

00:17:46,380 --> 00:17:50,340
engineering and computer science that

00:17:48,450 --> 00:17:52,320
immutability helps let you sidestep a

00:17:50,340 --> 00:17:54,000
little bit so there's a famous quote

00:17:52,320 --> 00:17:56,430
there are only two hard problems in

00:17:54,000 --> 00:17:59,610
computer science cache invalidation and

00:17:56,430 --> 00:18:01,080
naming things well if all the data you

00:17:59,610 --> 00:18:03,750
have cached you know will never change

00:18:01,080 --> 00:18:05,970
then cache invalidation is no longer a

00:18:03,750 --> 00:18:08,580
problem for you you've probably seen

00:18:05,970 --> 00:18:10,320
this with the rails asset pipeline so

00:18:08,580 --> 00:18:13,500
for every version of each of your assets

00:18:10,320 --> 00:18:15,540
rails appends a version hash onto it and

00:18:13,500 --> 00:18:17,580
it knows that every single request

00:18:15,540 --> 00:18:19,920
against that URL will always return the

00:18:17,580 --> 00:18:21,450
same data so tells the browser and

00:18:19,920 --> 00:18:27,570
proxies to cash it for up to a year

00:18:21,450 --> 00:18:29,430
which is effectively forever and

00:18:27,570 --> 00:18:31,590
database normalization is also

00:18:29,430 --> 00:18:34,230
interesting if you go to Wikipedia and

00:18:31,590 --> 00:18:37,110
figure out why database normalization

00:18:34,230 --> 00:18:39,000
exists it has this to say the objective

00:18:37,110 --> 00:18:41,130
is to isolate data so that additions

00:18:39,000 --> 00:18:44,460
deletions and modifications of a field

00:18:41,130 --> 00:18:46,020
can be made in just one table well if

00:18:44,460 --> 00:18:47,490
you're never updating or modifying this

00:18:46,020 --> 00:18:49,800
data that's copied across multiple

00:18:47,490 --> 00:18:52,350
tables you don't actually need to

00:18:49,800 --> 00:18:55,050
normalize if you have reason to leave

00:18:52,350 --> 00:18:57,030
your data denormalized and then finally

00:18:55,050 --> 00:19:00,600
immutable objects are automatically

00:18:57,030 --> 00:19:02,550
threadsafe value objects and persistent

00:19:00,600 --> 00:19:04,440
data structures can be shared across

00:19:02,550 --> 00:19:10,860
threads without having to worry about

00:19:04,440 --> 00:19:13,080
any sort of blocking as with everything

00:19:10,860 --> 00:19:14,970
they're trade-offs when you choose to

00:19:13,080 --> 00:19:17,730
use immutability so I'm going to point

00:19:14,970 --> 00:19:20,670
out some of the downsides a big one is

00:19:17,730 --> 00:19:22,230
performance when you're using immutable

00:19:20,670 --> 00:19:24,210
data structures and immutable objects

00:19:22,230 --> 00:19:26,220
you end up allocating and copying a lot

00:19:24,210 --> 00:19:29,130
more data which is going to be slower

00:19:26,220 --> 00:19:30,810
and consume more memory you also

00:19:29,130 --> 00:19:32,160
sacrifice some flexibility for

00:19:30,810 --> 00:19:33,450
immutability immutability is a

00:19:32,160 --> 00:19:36,420
constraint that you're placing upon

00:19:33,450 --> 00:19:38,250
yourself and maybe your domain or your

00:19:36,420 --> 00:19:39,840
performance requirements or libraries

00:19:38,250 --> 00:19:41,910
you're using don't work well with

00:19:39,840 --> 00:19:46,470
immutability and in that case it's not

00:19:41,910 --> 00:19:49,710
for you ruby is also not a help towards

00:19:46,470 --> 00:19:51,960
immutability we can reassign constants

00:19:49,710 --> 00:19:53,880
we can reach into other objects and

00:19:51,960 --> 00:19:55,350
change their instance variables there's

00:19:53,880 --> 00:19:57,770
even a gem that lets you unfreeze a

00:19:55,350 --> 00:19:57,770
frozen

00:19:59,429 --> 00:20:05,590
so the the powerful flexibility that's

00:20:02,679 --> 00:20:07,090
built into Ruby sometimes makes putting

00:20:05,590 --> 00:20:10,809
constraints on ourself a little more

00:20:07,090 --> 00:20:12,850
difficult and finally deletion is also a

00:20:10,809 --> 00:20:14,440
form of mutation so if you think about

00:20:12,850 --> 00:20:16,330
Twitter conceptually tweets are

00:20:14,440 --> 00:20:17,830
immutable once you write one you can

00:20:16,330 --> 00:20:19,120
never go back and edit it so it seems

00:20:17,830 --> 00:20:21,670
like Twitter should be able to cash it

00:20:19,120 --> 00:20:23,440
for forever but you can't delete your

00:20:21,670 --> 00:20:24,970
tweet and Twitter still has to worry

00:20:23,440 --> 00:20:28,929
about all the complicated things that

00:20:24,970 --> 00:20:30,250
come with cash and validation there if

00:20:28,929 --> 00:20:34,030
any of this interested you I have

00:20:30,250 --> 00:20:35,800
pointers to a handful of next steps and

00:20:34,030 --> 00:20:37,390
this URL in the bottom corner will have

00:20:35,800 --> 00:20:38,650
links to everything I'm about to mention

00:20:37,390 --> 00:20:42,160
and it'll be up for the rest of the

00:20:38,650 --> 00:20:43,420
presentation I'd recommend learning one

00:20:42,160 --> 00:20:45,880
of these three programming languages

00:20:43,420 --> 00:20:48,130
they each have immutability baked into

00:20:45,880 --> 00:20:50,140
the core and at times will make changing

00:20:48,130 --> 00:20:52,570
things downright hard you might not find

00:20:50,140 --> 00:20:55,600
them useful for your day-to-day work but

00:20:52,570 --> 00:20:56,950
learning them will make you will help

00:20:55,600 --> 00:21:00,640
you learn more about immutability and

00:20:56,950 --> 00:21:03,040
make you a better rubyists rich chicky

00:21:00,640 --> 00:21:04,690
is the creator of closure and he's given

00:21:03,040 --> 00:21:07,720
a handful of really awesome talks in the

00:21:04,690 --> 00:21:09,760
past few years about immutability I

00:21:07,720 --> 00:21:11,710
talked for five minutes about values but

00:21:09,760 --> 00:21:15,580
he has a 90-minute talk about values

00:21:11,710 --> 00:21:17,770
that's incredible there's two awesome

00:21:15,580 --> 00:21:19,690
text about value objects one of them is

00:21:17,770 --> 00:21:22,210
domain driven design which is a book

00:21:19,690 --> 00:21:24,640
that talks a lot about how to have value

00:21:22,210 --> 00:21:25,960
of objects and mutable entity objects

00:21:24,640 --> 00:21:29,290
interacting together in an application

00:21:25,960 --> 00:21:31,540
and then the sea to wiki also has some

00:21:29,290 --> 00:21:33,550
great articles about value objects and

00:21:31,540 --> 00:21:34,809
why you want them to be immutable and

00:21:33,550 --> 00:21:38,230
what to do if you can't make them

00:21:34,809 --> 00:21:39,880
immutable Gary Bernhardt has been

00:21:38,230 --> 00:21:42,309
talking about this idea of the

00:21:39,880 --> 00:21:45,040
functional core imperative shell where

00:21:42,309 --> 00:21:47,320
all of your domain logic lives in pure

00:21:45,040 --> 00:21:49,390
functional entirely immutable parts of

00:21:47,320 --> 00:21:53,710
code that are then tied together by this

00:21:49,390 --> 00:21:55,300
larger mutable imperative show and he

00:21:53,710 --> 00:21:56,590
gave his talk at rubyconf this past

00:21:55,300 --> 00:21:58,540
November called boundaries or he

00:21:56,590 --> 00:22:01,720
explores this idea and great depth and

00:21:58,540 --> 00:22:04,570
give some cool examples and then finally

00:22:01,720 --> 00:22:07,570
Martin Fowler has the canonical text on

00:22:04,570 --> 00:22:09,340
event sourcing talks about a bunch of

00:22:07,570 --> 00:22:10,260
examples different use cases why you

00:22:09,340 --> 00:22:11,760
would want to do it

00:22:10,260 --> 00:22:14,970
and some pitfalls you'll encounter along

00:22:11,760 --> 00:22:17,240
the way and that's all I have for you so

00:22:14,970 --> 00:22:17,240
thank you

00:22:26,160 --> 00:22:34,230
harsh time do we have okay I also have a

00:22:30,550 --> 00:22:34,230
bonus round if we have like five minutes

00:22:34,500 --> 00:22:41,800
awesome so I mentioned persistent data

00:22:37,270 --> 00:22:44,340
structures earlier so persistent data

00:22:41,800 --> 00:22:46,570
structures are mutable data structures

00:22:44,340 --> 00:22:48,850
where when you try to change the data

00:22:46,570 --> 00:22:51,130
inside of it rather than changing it it

00:22:48,850 --> 00:22:52,600
actually returns you a new copy with the

00:22:51,130 --> 00:22:53,830
modification supplied to it and so

00:22:52,600 --> 00:22:56,050
there's an awesome library for doing

00:22:53,830 --> 00:22:57,490
this in Ruby called hamster and I

00:22:56,050 --> 00:23:00,550
believe these are also built into

00:22:57,490 --> 00:23:02,410
Rubinius so I was an example we have a

00:23:00,550 --> 00:23:05,080
vector called foo that contains the

00:23:02,410 --> 00:23:07,120
numbers one two and three when we add a

00:23:05,080 --> 00:23:09,850
fourth element to it we're assigning

00:23:07,120 --> 00:23:12,130
this into bar so bar contains the

00:23:09,850 --> 00:23:14,650
modification we just made but foo

00:23:12,130 --> 00:23:18,090
remains unchanged and when we try to

00:23:14,650 --> 00:23:22,270
change one of the elements in the vector

00:23:18,090 --> 00:23:24,130
Baz has the change but food doesn't so

00:23:22,270 --> 00:23:28,000
I'd help explain like why this is useful

00:23:24,130 --> 00:23:29,470
we have the three stooges so the three

00:23:28,000 --> 00:23:31,360
stooges run a movie called soup to nuts

00:23:29,470 --> 00:23:34,900
and at this point in time the three

00:23:31,360 --> 00:23:37,270
stooges were mo Shemp and larry in the

00:23:34,900 --> 00:23:39,340
next movie meet the Baron chump left the

00:23:37,270 --> 00:23:41,980
Stooges and curly joined on as the third

00:23:39,340 --> 00:23:43,780
stooge and then in another later movie

00:23:41,980 --> 00:23:46,600
gold Raiders curly left and shrimp came

00:23:43,780 --> 00:23:49,360
back here if we were sharing the same

00:23:46,600 --> 00:23:51,610
array or set between these three movies

00:23:49,360 --> 00:23:53,710
of the cast and we changed it when we

00:23:51,610 --> 00:23:55,420
for the second movie took jump out and

00:23:53,710 --> 00:23:57,430
added curly it would have changed the

00:23:55,420 --> 00:24:00,310
cast of the first movie we'd have gotten

00:23:57,430 --> 00:24:02,620
some unexpected results but with these

00:24:00,310 --> 00:24:04,290
persistent data structures the caster

00:24:02,620 --> 00:24:07,540
each of them is exactly what we expect

00:24:04,290 --> 00:24:10,780
so you're asking so like hamsters just

00:24:07,540 --> 00:24:12,100
callin dupa bunch right no there's

00:24:10,780 --> 00:24:15,010
actually some very awesome computer

00:24:12,100 --> 00:24:16,300
science going on here so we have this

00:24:15,010 --> 00:24:18,370
vector of the numbers one through seven

00:24:16,300 --> 00:24:20,470
and you'll notice that the leaf nodes of

00:24:18,370 --> 00:24:21,910
this tree here are the numbers one

00:24:20,470 --> 00:24:24,190
through seven when traversed in order

00:24:21,910 --> 00:24:27,190
and you'll notice that old is sort of a

00:24:24,190 --> 00:24:30,610
pointer to the root of the tree so when

00:24:27,190 --> 00:24:32,770
we add the number eight so the vector we

00:24:30,610 --> 00:24:34,300
end up with the new tree and if you look

00:24:32,770 --> 00:24:35,710
at new and do the inorder traversal of

00:24:34,300 --> 00:24:37,059
the leaf nodes you again get the numbers

00:24:35,710 --> 00:24:40,220
one through eight as you expect

00:24:37,059 --> 00:24:42,590
but old and new are sharing almost all

00:24:40,220 --> 00:24:46,400
of the nodes so it's much more efficient

00:24:42,590 --> 00:24:47,929
and faster and takes less space to share

00:24:46,400 --> 00:24:57,010
these nodes like this than to do a

00:24:47,929 --> 00:24:57,010

YouTube URL: https://www.youtube.com/watch?v=VnC_JccUPkw


