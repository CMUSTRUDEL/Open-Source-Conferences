Title: Cloud Infrastructure as C# and F# with Pulumi - .NET South West - February 2020
Publication date: 2020-03-05
Playlist: Dot Net South West
Description: 
	Pulumi: Cloud Infrastructure with C# and F# by Mikhail Shilkov

Modern cloud platforms offer amazing capabilities for application developers. However, cloud services are hard to manage without employing Infrastructure as Code tools for automation.

Traditional tools like CloudFormation, ARM templates, and Terraform use text-based formats, which tend to be tedious, repetitive, and cumbersome to reuse.

What if instead of configuration files, you could use your favourite programming languages like C# and F#? In this talk, Mikhail will introduce you to Pulumi, which uses actual code to manage infrastructure! See how you can bring your developer tools like code completion, types, components, and abstractions to cloud infrastructure definition.

ðŸ‘©â€ðŸ’» About Mikhail:
Mikhail Shilkov is a software developer at Pulumi, enabling developers and operators to work better together. Mikhail is a Microsoft Azure MVP, a Russian expat living in the Netherlands. He is passionate about the serverless mindset, leveraging the full variety of managed cloud services, and handling cloud infrastructure as code.

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,110 --> 00:00:07,379
Hey so we're going to talk about cloud

00:00:03,899 --> 00:00:10,500
and dotnet today but first I want to

00:00:07,379 --> 00:00:12,620
sort of talk to the audience who is it

00:00:10,500 --> 00:00:15,389
that mad developer here yes

00:00:12,620 --> 00:00:19,140
almost everyone okay who is doing

00:00:15,389 --> 00:00:21,199
something with AWS in their company or

00:00:19,140 --> 00:00:30,720
free time or anything

00:00:21,199 --> 00:00:34,469
sure okay kubernetes right and that's it

00:00:30,720 --> 00:00:38,460
that's a good mix who is familiar with

00:00:34,469 --> 00:00:41,370
terraform Oh a lot of people well okay

00:00:38,460 --> 00:00:43,290
that's great so it's gonna be easier for

00:00:41,370 --> 00:00:46,110
you to understand what I'm talking about

00:00:43,290 --> 00:00:48,930
but also if you are not very familiar

00:00:46,110 --> 00:00:51,719
with infrastructure as code I'll I'll

00:00:48,930 --> 00:00:53,070
have introduction for you so for myself

00:00:51,719 --> 00:00:55,949
I'm also a developer I've been writing

00:00:53,070 --> 00:00:58,949
code for like 20 years net for maybe 15

00:00:55,949 --> 00:01:01,710
years or so and what I found out over

00:00:58,949 --> 00:01:04,650
time is that in addition to writing good

00:01:01,710 --> 00:01:06,090
code I also care about whether this code

00:01:04,650 --> 00:01:09,510
actually goes to production and is

00:01:06,090 --> 00:01:12,570
useful to people basically I really

00:01:09,510 --> 00:01:14,880
really really hate to do something great

00:01:12,570 --> 00:01:16,979
and then the froude way so that nobody

00:01:14,880 --> 00:01:20,340
is using it so I worked in a bunch of

00:01:16,979 --> 00:01:22,619
companies over time different kinds of

00:01:20,340 --> 00:01:26,659
companies and different ways to ship to

00:01:22,619 --> 00:01:30,360
production for example I used to work in

00:01:26,659 --> 00:01:32,369
open source company right so people

00:01:30,360 --> 00:01:34,020
external companies come to us there is

00:01:32,369 --> 00:01:37,799
usually a project manager talking to us

00:01:34,020 --> 00:01:39,570
they have their own stuff to do and we

00:01:37,799 --> 00:01:41,970
have developers they hire us we do

00:01:39,570 --> 00:01:45,320
something we ship the code and then it

00:01:41,970 --> 00:01:48,540
kind of disappears we don't know its

00:01:45,320 --> 00:01:50,250
what happens to it afterwards so it's

00:01:48,540 --> 00:01:52,049
not very satisfying because we never see

00:01:50,250 --> 00:01:54,600
it it's actually run in production I

00:01:52,049 --> 00:01:57,689
also worked in like bigger enterprise

00:01:54,600 --> 00:02:01,350
companies where the users are internal

00:01:57,689 --> 00:02:03,420
or external but still reachable but

00:02:01,350 --> 00:02:05,189
production is still far away because

00:02:03,420 --> 00:02:06,840
there is an IT department they have

00:02:05,189 --> 00:02:08,429
their own rules we ship it to a

00:02:06,840 --> 00:02:11,310
department and then it kind of

00:02:08,429 --> 00:02:12,629
disappears again we don't have access to

00:02:11,310 --> 00:02:13,620
production we don't know if it's up or

00:02:12,629 --> 00:02:17,190
down and so on

00:02:13,620 --> 00:02:19,170
so forth I also worked in a smaller

00:02:17,190 --> 00:02:21,750
company where we still had high two

00:02:19,170 --> 00:02:24,540
people working with us but they would

00:02:21,750 --> 00:02:28,920
sort of work in our team internally

00:02:24,540 --> 00:02:31,829
what's now known as DevOps so that we

00:02:28,920 --> 00:02:34,319
would talk every day or every week we'll

00:02:31,829 --> 00:02:37,230
know the problem I was actually on call

00:02:34,319 --> 00:02:41,250
so I could wake up a.m. to fix something

00:02:37,230 --> 00:02:44,810
and I liked this model a lot well except

00:02:41,250 --> 00:02:47,730
a pregame part but I knew our

00:02:44,810 --> 00:02:50,129
infrastructure I knew our networking set

00:02:47,730 --> 00:02:52,200
up however databases work if something

00:02:50,129 --> 00:02:55,410
is down I know which dashboard I should

00:02:52,200 --> 00:02:59,970
check and sort of keep the pulse of our

00:02:55,410 --> 00:03:02,310
system in the same company we got to

00:02:59,970 --> 00:03:05,579
move to the cloud so we used to host our

00:03:02,310 --> 00:03:08,040
applications in on-premise basically

00:03:05,579 --> 00:03:10,709
on-premises and then we started using

00:03:08,040 --> 00:03:14,579
moving one by one applications to Azure

00:03:10,709 --> 00:03:16,650
cloud so still the same team still the

00:03:14,579 --> 00:03:19,319
same setup but different infrastructure

00:03:16,650 --> 00:03:21,660
also what I found out is that when we

00:03:19,319 --> 00:03:23,519
move to the cloud and we do everything

00:03:21,660 --> 00:03:26,519
properly we start using much more

00:03:23,519 --> 00:03:29,400
diverse set of services so instead of

00:03:26,519 --> 00:03:32,220
just having web servers and databases we

00:03:29,400 --> 00:03:36,389
start to get queues storage some no

00:03:32,220 --> 00:03:40,019
sequel containers service whatnot so

00:03:36,389 --> 00:03:41,849
this the list is quite limitless and the

00:03:40,019 --> 00:03:44,730
more services you use the more

00:03:41,849 --> 00:03:47,579
components you get so the harder it gets

00:03:44,730 --> 00:03:49,440
to manage them and we try to do

00:03:47,579 --> 00:03:52,310
everything right we used like the web's

00:03:49,440 --> 00:03:55,230
practices the ICD continuous integration

00:03:52,310 --> 00:03:57,480
unit testing and so on a part of that we

00:03:55,230 --> 00:04:00,180
started to use infrastructure as code so

00:03:57,480 --> 00:04:03,060
we described our application footprint

00:04:00,180 --> 00:04:07,040
in the cloud as one well a set of JSON

00:04:03,060 --> 00:04:07,040
files for arm templates and Azure and

00:04:07,669 --> 00:04:11,489
another instance of infrastructure could

00:04:10,109 --> 00:04:14,430
be provisioned of thematically from

00:04:11,489 --> 00:04:16,799
scratch just by running that sort of

00:04:14,430 --> 00:04:18,919
tool and just for one application I

00:04:16,799 --> 00:04:21,419
remember we had 5,000 lines of JSON

00:04:18,919 --> 00:04:23,640
to describe all the infrastructure in

00:04:21,419 --> 00:04:26,560
just a couple of web servers and queues

00:04:23,640 --> 00:04:29,020
some databases nothing too fancy

00:04:26,560 --> 00:04:31,840
and the experience of frightened that

00:04:29,020 --> 00:04:33,460
those Jason files was really horrible

00:04:31,840 --> 00:04:36,100
it's basically copy pasting something

00:04:33,460 --> 00:04:37,870
from somewhere on the web running a tool

00:04:36,100 --> 00:04:39,760
which says running for ten minutes and

00:04:37,870 --> 00:04:41,800
it says failed and then you try to

00:04:39,760 --> 00:04:43,090
figure out why it failed change

00:04:41,800 --> 00:04:46,450
something and go again

00:04:43,090 --> 00:04:49,120
run wait and so on so compared to our

00:04:46,450 --> 00:04:51,150
other code in the application it was

00:04:49,120 --> 00:04:53,850
just horrible experience so I thought

00:04:51,150 --> 00:04:57,520
maybe there is an opportunity there and

00:04:53,850 --> 00:04:59,860
some better tools should appear in the

00:04:57,520 --> 00:05:01,990
future so I started using a different

00:04:59,860 --> 00:05:04,630
tool which is called plumie I'm gonna

00:05:01,990 --> 00:05:06,850
talk about this tool today and later on

00:05:04,630 --> 00:05:09,310
so I started as a user then I started

00:05:06,850 --> 00:05:11,380
contributing and then just last November

00:05:09,310 --> 00:05:13,570
so I joined the company as a developer

00:05:11,380 --> 00:05:16,410
so now I'm a developer on the team and

00:05:13,570 --> 00:05:18,850
actually my production now is your

00:05:16,410 --> 00:05:22,930
potential infrastructure so that's why I

00:05:18,850 --> 00:05:25,300
go to meetups conferences because I want

00:05:22,930 --> 00:05:30,030
to see my production users and talk to

00:05:25,300 --> 00:05:32,860
them and see if that clicks or not so

00:05:30,030 --> 00:05:35,610
about me slide I work at the software

00:05:32,860 --> 00:05:38,919
engineer paluma so I'm not like customer

00:05:35,610 --> 00:05:41,260
engagement person not the sales actually

00:05:38,919 --> 00:05:44,950
write code I was writing code in kefir

00:05:41,260 --> 00:05:46,900
just next door from here an hour ago and

00:05:44,950 --> 00:05:49,660
I work on a lot of things we are a small

00:05:46,900 --> 00:05:52,030
company but my main focus now is the net

00:05:49,660 --> 00:05:54,010
SDK that's what we are talking today and

00:05:52,030 --> 00:05:59,620
also a sure infrastructure and other

00:05:54,010 --> 00:06:01,720
code tools beyond paluma I'm interested

00:05:59,620 --> 00:06:03,190
in cloud service stuff so as a function

00:06:01,720 --> 00:06:06,669
saleable is lambda a functional

00:06:03,190 --> 00:06:09,340
programming with f-sharp and just

00:06:06,669 --> 00:06:12,340
general error' stuff by the way who is

00:06:09,340 --> 00:06:14,770
writing F sharp here at their job or how

00:06:12,340 --> 00:06:16,750
big one two three okay that's about the

00:06:14,770 --> 00:06:19,510
proportion of slides dedicated to F

00:06:16,750 --> 00:06:22,180
sharp I have like three slides for F

00:06:19,510 --> 00:06:25,240
sharp and 90 for everything else so

00:06:22,180 --> 00:06:28,450
that's about right

00:06:25,240 --> 00:06:30,789
agenda for today I'll give examples from

00:06:28,450 --> 00:06:32,139
both lady BIOS and Azure and I'll start

00:06:30,789 --> 00:06:34,479
with the general interaction to

00:06:32,139 --> 00:06:36,669
infrastructure as code some existing

00:06:34,479 --> 00:06:38,680
tools out there and then the main time

00:06:36,669 --> 00:06:41,650
must be spent on columbia showing you

00:06:38,680 --> 00:06:43,970
what it is how it works and so on

00:06:41,650 --> 00:06:48,020
so what's what's so special about the

00:06:43,970 --> 00:06:50,990
cloud cloud is different because there

00:06:48,020 --> 00:06:52,670
is an API for everything whatever you

00:06:50,990 --> 00:06:55,580
need from the cloud there is a rest

00:06:52,670 --> 00:06:57,170
endpoint you hit this endpoint several

00:06:55,580 --> 00:06:59,780
seconds or several minutes after that

00:06:57,170 --> 00:07:01,310
you get an instance of your service

00:06:59,780 --> 00:07:04,400
ready to be used

00:07:01,310 --> 00:07:07,670
so whatever tool you used to create

00:07:04,400 --> 00:07:10,340
those resources beat web portal or CLI

00:07:07,670 --> 00:07:12,020
or some custom third-party tools in the

00:07:10,340 --> 00:07:16,090
end they all making requests to that

00:07:12,020 --> 00:07:21,020
endpoint in Asia or in AWS or anywhere

00:07:16,090 --> 00:07:22,880
so the bare minimal way to do this is

00:07:21,020 --> 00:07:25,490
just to call that rest endpoint yourself

00:07:22,880 --> 00:07:29,360
so that's like assembler of provisioning

00:07:25,490 --> 00:07:30,590
you can write HTTP requests in your

00:07:29,360 --> 00:07:33,680
postman or

00:07:30,590 --> 00:07:35,210
curl or whatnot send that wait for

00:07:33,680 --> 00:07:37,100
response and then if you are lucky if

00:07:35,210 --> 00:07:39,470
you got everything right you will get

00:07:37,100 --> 00:07:41,180
something back that would work but of

00:07:39,470 --> 00:07:43,880
course that's too low-level nobody does

00:07:41,180 --> 00:07:46,660
that as a main tool on their job

00:07:43,880 --> 00:07:49,420
sometimes it still might have to do this

00:07:46,660 --> 00:07:51,890
because of that every cloud provider

00:07:49,420 --> 00:07:57,250
rated as the case for the major

00:07:51,890 --> 00:08:00,590
languages dotnet note Python go what not

00:07:57,250 --> 00:08:02,420
the essential do the same you just write

00:08:00,590 --> 00:08:05,300
the code in your familiar language but

00:08:02,420 --> 00:08:07,670
in the end it gets translated to HTTP

00:08:05,300 --> 00:08:10,850
calls to a rest endpoint so if you run

00:08:07,670 --> 00:08:13,100
this application when it hits a line of

00:08:10,850 --> 00:08:15,650
run instances that's going to be an HTTP

00:08:13,100 --> 00:08:18,410
request going out and HTTP response

00:08:15,650 --> 00:08:20,480
going back and then parsed and providing

00:08:18,410 --> 00:08:22,460
you the response it's it's the same

00:08:20,480 --> 00:08:24,680
model it's just that you get better api

00:08:22,460 --> 00:08:27,680
better experience of creating that code

00:08:24,680 --> 00:08:30,950
instead of writing HTTP requests if you

00:08:27,680 --> 00:08:33,710
are more of a payer operation person you

00:08:30,950 --> 00:08:36,170
probably use CLI tools you can write

00:08:33,710 --> 00:08:37,730
bash script powershell scripts to

00:08:36,170 --> 00:08:39,860
provision the infrastructure step by

00:08:37,730 --> 00:08:43,550
step so that works that's one way to

00:08:39,860 --> 00:08:45,350
create infrastructure is code but SDK

00:08:43,550 --> 00:08:47,600
and scripts have a bunch of problems

00:08:45,350 --> 00:08:50,240
they are still quite low level so you

00:08:47,600 --> 00:08:51,920
have to describe exactly the steps that

00:08:50,240 --> 00:08:53,930
you need to go through to create

00:08:51,920 --> 00:08:55,399
infrastructure so how

00:08:53,930 --> 00:08:58,130
you want to do infrastructure to be

00:08:55,399 --> 00:09:01,220
provisioned instead of saying what

00:08:58,130 --> 00:09:02,710
exactly want to get and gets quite

00:09:01,220 --> 00:09:04,670
complex especially if you have multiple

00:09:02,710 --> 00:09:07,220
environments like testing stage in

00:09:04,670 --> 00:09:09,500
production and they are different in

00:09:07,220 --> 00:09:12,500
some ways maybe testing is a bit

00:09:09,500 --> 00:09:14,029
scaled-down production or permissions

00:09:12,500 --> 00:09:17,330
are configured differently so you need

00:09:14,029 --> 00:09:21,500
to script all those differences in your

00:09:17,330 --> 00:09:22,820
code and also your environments tend to

00:09:21,500 --> 00:09:24,830
live for a long time for months or years

00:09:22,820 --> 00:09:26,810
so you tend to write a lot of update

00:09:24,830 --> 00:09:29,600
scripts from state and the state and

00:09:26,810 --> 00:09:32,149
plus two and plus one and they're all

00:09:29,600 --> 00:09:34,220
sort of brittle error-prone if the

00:09:32,149 --> 00:09:35,810
script fails in the middle you usually

00:09:34,220 --> 00:09:38,540
don't know what what's the current state

00:09:35,810 --> 00:09:40,610
of your environment whether you can run

00:09:38,540 --> 00:09:42,140
that same script again or whether it's

00:09:40,610 --> 00:09:44,029
going to create some duplicate resources

00:09:42,140 --> 00:09:46,700
and so on so forth so it's it's still

00:09:44,029 --> 00:09:49,700
quite low level but some people do this

00:09:46,700 --> 00:09:51,230
to overcome these problems there is a

00:09:49,700 --> 00:09:53,180
notion of desired state configuration

00:09:51,230 --> 00:09:55,399
that exists for years and every cloud

00:09:53,180 --> 00:09:58,490
has their own tool for to describe

00:09:55,399 --> 00:10:01,070
desired state the idea is simple that

00:09:58,490 --> 00:10:03,500
you describe not the steps to get to

00:10:01,070 --> 00:10:05,930
your outcome but you describe the end

00:10:03,500 --> 00:10:09,380
goal so you describe the target state

00:10:05,930 --> 00:10:11,900
and then doesn't matter what what's the

00:10:09,380 --> 00:10:13,730
current state of your environment is the

00:10:11,900 --> 00:10:15,740
tool should be able to compare the two

00:10:13,730 --> 00:10:18,230
and sort of figure out automatically

00:10:15,740 --> 00:10:22,339
what are the right steps to bring the

00:10:18,230 --> 00:10:24,260
current state to the target state and

00:10:22,339 --> 00:10:27,800
the useful way to reason about those

00:10:24,260 --> 00:10:30,470
states are graphs in those graphs every

00:10:27,800 --> 00:10:32,630
node is a resource and edges between

00:10:30,470 --> 00:10:34,130
resources are dependencies because

00:10:32,630 --> 00:10:37,610
dependencies are very important to

00:10:34,130 --> 00:10:40,520
figure out the actual migration plan if

00:10:37,610 --> 00:10:42,589
you need to replace a resource which has

00:10:40,520 --> 00:10:44,900
a lot of dependencies then probably you

00:10:42,589 --> 00:10:48,200
need to replace all of them or do

00:10:44,900 --> 00:10:50,149
something smart about this so when the

00:10:48,200 --> 00:10:52,820
tool compares the states it usually

00:10:50,149 --> 00:10:57,350
reasons in terms of graphs of dependent

00:10:52,820 --> 00:10:59,089
resources still these tools are quite

00:10:57,350 --> 00:11:01,070
complicated there is a number of

00:10:59,089 --> 00:11:03,020
challenges well while creating them

00:11:01,070 --> 00:11:06,200
first they should be quite expressive

00:11:03,020 --> 00:11:07,800
they should allow you to describe any

00:11:06,200 --> 00:11:10,279
state that you want in

00:11:07,800 --> 00:11:12,480
more or less concise and correct way

00:11:10,279 --> 00:11:17,640
preferably more than unless of course

00:11:12,480 --> 00:11:20,310
and on the other side whatever current

00:11:17,640 --> 00:11:22,050
state you have whatever target state you

00:11:20,310 --> 00:11:25,230
describe the tool should be good enough

00:11:22,050 --> 00:11:29,130
to be able to reconcile those and the

00:11:25,230 --> 00:11:31,320
permutations are quite numerous because

00:11:29,130 --> 00:11:32,899
those two aspects are not perfect you

00:11:31,320 --> 00:11:35,610
have to have false a transparency

00:11:32,899 --> 00:11:38,640
basically should be able what I was

00:11:35,610 --> 00:11:40,860
missing in my are migration story you

00:11:38,640 --> 00:11:43,260
should be able to preview the changes

00:11:40,860 --> 00:11:45,930
that the tool is going to make before it

00:11:43,260 --> 00:11:47,850
actually starts its work just to show

00:11:45,930 --> 00:11:50,310
you what's the plan what what are the

00:11:47,850 --> 00:11:52,560
difference that the tool detected I

00:11:50,310 --> 00:11:55,050
might have made some mistakes in my

00:11:52,560 --> 00:11:57,060
definition it the tool itself might have

00:11:55,050 --> 00:11:59,940
made some mistakes in planning so I

00:11:57,060 --> 00:12:05,519
should be able to preview that and sort

00:11:59,940 --> 00:12:08,970
of prevent any undesired consequences so

00:12:05,519 --> 00:12:11,700
every every cloud has their own tool to

00:12:08,970 --> 00:12:14,760
provision desert state configuration AWS

00:12:11,700 --> 00:12:17,399
CloudFormation are templates

00:12:14,760 --> 00:12:20,209
Google called the point manager they are

00:12:17,399 --> 00:12:22,950
sort of similar from bird's eye view

00:12:20,209 --> 00:12:25,529
they're all desert state configuration

00:12:22,950 --> 00:12:27,149
tools and they all use markup languages

00:12:25,529 --> 00:12:33,450
either a JSON or llamÃ³

00:12:27,149 --> 00:12:36,149
so here is an example of arm template if

00:12:33,450 --> 00:12:38,700
you never see someone like that's one

00:12:36,149 --> 00:12:40,350
definition of resource storage account

00:12:38,700 --> 00:12:42,000
in this case you always define API

00:12:40,350 --> 00:12:44,010
version type and then some properties

00:12:42,000 --> 00:12:45,720
and then you have a bunch of those and

00:12:44,010 --> 00:12:48,860
then you send out stager and as your

00:12:45,720 --> 00:12:51,839
figures out what exactly needs to happen

00:12:48,860 --> 00:12:53,490
AWS CloudFormation same thing they

00:12:51,839 --> 00:12:57,589
started with Jason now if they use

00:12:53,490 --> 00:13:00,209
mostly mo these days you can see that

00:12:57,589 --> 00:13:03,060
even in this small example you can see

00:13:00,209 --> 00:13:04,890
that they also have a language inside

00:13:03,060 --> 00:13:07,410
the language so yeah Mel itself is not

00:13:04,890 --> 00:13:09,449
expressive enough so they created things

00:13:07,410 --> 00:13:12,300
like references special attributes to

00:13:09,449 --> 00:13:14,339
make references between resources some

00:13:12,300 --> 00:13:16,740
conditionals and so on so that's

00:13:14,339 --> 00:13:19,170
actually not just Yama but that's a DSL

00:13:16,740 --> 00:13:21,480
built on top of your mo

00:13:19,170 --> 00:13:23,640
there are also third-party tools the

00:13:21,480 --> 00:13:27,120
most known one this terraform a lot of

00:13:23,640 --> 00:13:28,829
you know looked already they work for

00:13:27,120 --> 00:13:30,930
multiple clouds and they also invented

00:13:28,829 --> 00:13:34,470
their own language their own markup

00:13:30,930 --> 00:13:37,019
language called HCL it's sort of still a

00:13:34,470 --> 00:13:39,450
text format it's sort of like Jason but

00:13:37,019 --> 00:13:44,310
simplified for cloud resource management

00:13:39,450 --> 00:13:46,529
graph definitions the programs are a bit

00:13:44,310 --> 00:13:50,040
easier it's a bit more expressive but

00:13:46,529 --> 00:13:51,769
still the same kind of thing with markup

00:13:50,040 --> 00:13:54,870
you still get a lot of challenges first

00:13:51,769 --> 00:13:59,160
it's just the text so you don't get any

00:13:54,870 --> 00:14:02,370
tools out of the box initially every

00:13:59,160 --> 00:14:04,769
cloud vendor works on their own like BS

00:14:02,370 --> 00:14:08,060
code extension or something to make the

00:14:04,769 --> 00:14:10,500
process a little bit less painful but

00:14:08,060 --> 00:14:13,260
they have to do all the work that that

00:14:10,500 --> 00:14:18,360
otherwise say compiler already has and

00:14:13,260 --> 00:14:21,690
create all the authoring tools for on

00:14:18,360 --> 00:14:23,880
top of JSON or llamÃ³ discovery of

00:14:21,690 --> 00:14:25,620
creating those resources is usually a

00:14:23,880 --> 00:14:28,529
problem so usually to copy-paste from

00:14:25,620 --> 00:14:31,110
somewhere because writing everything

00:14:28,529 --> 00:14:33,269
from scratch is quite painful and just

00:14:31,110 --> 00:14:35,130
the sheer size of those templates as I

00:14:33,269 --> 00:14:37,829
said again it's it's usually hundreds

00:14:35,130 --> 00:14:40,680
and thousands of lines of markup because

00:14:37,829 --> 00:14:44,610
there it's still quite low level it's

00:14:40,680 --> 00:14:46,980
still per resource in a simple example I

00:14:44,610 --> 00:14:50,160
do a lot of Asia functions in a database

00:14:46,980 --> 00:14:51,930
lambdas so I created a simple

00:14:50,160 --> 00:14:54,209
application service application and on

00:14:51,930 --> 00:14:56,610
top of both of this it's like a URL

00:14:54,209 --> 00:14:59,880
shortener like tinyurl that coma or a

00:14:56,610 --> 00:15:02,459
kms you go to a small URL and and you

00:14:59,880 --> 00:15:04,260
get redirected to the crew URL it's very

00:15:02,459 --> 00:15:06,480
simple you just need to write like 20

00:15:04,260 --> 00:15:09,440
lines of JavaScript to read data from

00:15:06,480 --> 00:15:13,320
edge of storage and then make a redirect

00:15:09,440 --> 00:15:16,260
but to define all the resources say API

00:15:13,320 --> 00:15:19,649
gateways and windings and deployments

00:15:16,260 --> 00:15:21,390
and security and dynamodb and or AG

00:15:19,649 --> 00:15:24,029
functions with storage account and blob

00:15:21,390 --> 00:15:26,519
and container and so on you need sort of

00:15:24,029 --> 00:15:30,420
an order of magnitude more lines of text

00:15:26,519 --> 00:15:32,460
for the infrastructure which

00:15:30,420 --> 00:15:36,120
which doesn't seem right like I don't

00:15:32,460 --> 00:15:42,630
want to write ten times more markup than

00:15:36,120 --> 00:15:45,990
code also as I mentioned those languages

00:15:42,630 --> 00:15:48,000
they are languages within languages they

00:15:45,990 --> 00:15:50,460
invented their own way of doing things

00:15:48,000 --> 00:15:54,590
and they are all different between the

00:15:50,460 --> 00:15:58,200
tools so everyone has a way to reference

00:15:54,590 --> 00:16:00,360
one resort from the other every tool has

00:15:58,200 --> 00:16:02,280
their own way to make conditionals like

00:16:00,360 --> 00:16:04,230
measure you have special attribute

00:16:02,280 --> 00:16:07,110
condition and then some square brackets

00:16:04,230 --> 00:16:09,270
with equal and if that evaluates at

00:16:07,110 --> 00:16:11,400
runtime with to false then they are not

00:16:09,270 --> 00:16:13,470
going to deploy this resource so you

00:16:11,400 --> 00:16:16,590
copy this two times say equals

00:16:13,470 --> 00:16:20,160
production equals staging and then sort

00:16:16,590 --> 00:16:22,620
of get conditional environment loops

00:16:20,160 --> 00:16:25,770
this is terraform the introduced loops

00:16:22,620 --> 00:16:27,690
last year I think so again some special

00:16:25,770 --> 00:16:29,640
attributes with counts and count index

00:16:27,690 --> 00:16:31,650
to creates several resources which are

00:16:29,640 --> 00:16:36,450
the same but not exactly the same and

00:16:31,650 --> 00:16:41,070
then a little bit different it's very

00:16:36,450 --> 00:16:42,150
hard to reuse those markup pieces to

00:16:41,070 --> 00:16:44,790
reuse them for different environments

00:16:42,150 --> 00:16:46,950
also to create sort of abstractions

00:16:44,790 --> 00:16:49,920
sometimes you use multiple resources

00:16:46,950 --> 00:16:52,380
sort of as one unit of deployment like a

00:16:49,920 --> 00:16:56,300
bake it way in lambdas and there is no

00:16:52,380 --> 00:16:59,310
way to express this in Yama file

00:16:56,300 --> 00:17:01,800
packaging and sharing is problematic if

00:16:59,310 --> 00:17:03,990
you have multiple JSON files for our

00:17:01,800 --> 00:17:06,810
templates that's usually uploading it to

00:17:03,990 --> 00:17:08,940
some shared folder and then referencing

00:17:06,810 --> 00:17:10,620
one from the other they cannot share it

00:17:08,940 --> 00:17:13,199
with you another team in your company

00:17:10,620 --> 00:17:16,530
easily or with like open-source

00:17:13,199 --> 00:17:18,209
community testing is Hart usually do

00:17:16,530 --> 00:17:20,760
just deploy something and then test it

00:17:18,209 --> 00:17:23,970
from external perspective there is no

00:17:20,760 --> 00:17:26,760
notion of unit testing like mount based

00:17:23,970 --> 00:17:29,940
testing or integration testing of small

00:17:26,760 --> 00:17:32,790
piece so when I looked at this list I

00:17:29,940 --> 00:17:35,160
thought okay we developers solve this

00:17:32,790 --> 00:17:38,780
long time ago we have all those great

00:17:35,160 --> 00:17:42,330
tools like IDs types functions classes

00:17:38,780 --> 00:17:44,020
unit testing refactoring and so on so

00:17:42,330 --> 00:17:49,120
why Cannot we use the

00:17:44,020 --> 00:17:50,920
same tools for infrastructure and exit

00:17:49,120 --> 00:17:53,140
that's exactly the idea behind follow me

00:17:50,920 --> 00:17:54,510
so polymer is the same idea of desired

00:17:53,140 --> 00:17:56,970
state configuration but using

00:17:54,510 --> 00:18:02,230
general-purpose programming languages

00:17:56,970 --> 00:18:05,740
for instance c-sharp right now we

00:18:02,230 --> 00:18:09,280
support for runtimes now to Python go

00:18:05,740 --> 00:18:10,710
and net the level of support is not the

00:18:09,280 --> 00:18:13,480
same for all those runtimes

00:18:10,710 --> 00:18:16,330
dotnet core and go are still in preview

00:18:13,480 --> 00:18:18,730
but we're gonna GA them in April

00:18:16,330 --> 00:18:21,580
hopefully so if they are quite good

00:18:18,730 --> 00:18:23,140
still we support multiple providers so

00:18:21,580 --> 00:18:27,790
it's not just one provider we support

00:18:23,140 --> 00:18:29,620
all of them as your AWS DCP CloudFlare

00:18:27,790 --> 00:18:33,370
but also something that is not quite

00:18:29,620 --> 00:18:36,700
cloud per sale like kubernetes or even

00:18:33,370 --> 00:18:39,460
Postgres Oracle New Relic and so on so

00:18:36,700 --> 00:18:42,550
everything which has API and sort of can

00:18:39,460 --> 00:18:44,710
be represented as a resource creation

00:18:42,550 --> 00:18:47,140
can be pulling a provider it's open

00:18:44,710 --> 00:18:50,350
model open source and so on I'm gonna

00:18:47,140 --> 00:18:52,870
explain it a bit later so finally some

00:18:50,350 --> 00:18:54,250
code that's a simple polymer program in

00:18:52,870 --> 00:18:57,550
C sharp which creates two major

00:18:54,250 --> 00:19:00,330
resources well there is a class and

00:18:57,550 --> 00:19:03,370
Method there but that's is the essence

00:19:00,330 --> 00:19:05,350
it's just a call of constructors

00:19:03,370 --> 00:19:08,260
creating a new object means that you

00:19:05,350 --> 00:19:09,610
create a new resource in the cloud it

00:19:08,260 --> 00:19:11,140
creates a resource group and then a

00:19:09,610 --> 00:19:14,320
storage account and then you can see

00:19:11,140 --> 00:19:17,440
that storage account definition uses

00:19:14,320 --> 00:19:21,040
resource group as a variable and that

00:19:17,440 --> 00:19:22,570
usage is just enough to create a link

00:19:21,040 --> 00:19:25,450
between them some create a dependency

00:19:22,570 --> 00:19:28,030
between them but by compiling this code

00:19:25,450 --> 00:19:30,220
we all know that storage account depends

00:19:28,030 --> 00:19:32,670
on the resource group and the most

00:19:30,220 --> 00:19:36,850
important thing here to understand and

00:19:32,670 --> 00:19:38,230
to compare it to as the case is that

00:19:36,850 --> 00:19:40,300
this is still desired state

00:19:38,230 --> 00:19:42,820
configuration so that's described in

00:19:40,300 --> 00:19:45,280
your target environment doesn't matter

00:19:42,820 --> 00:19:47,800
what the current state is you don't

00:19:45,280 --> 00:19:50,830
write update scripts or something you

00:19:47,800 --> 00:19:53,530
describe the full configuration and then

00:19:50,830 --> 00:19:56,380
the tool is going to figure out what are

00:19:53,530 --> 00:19:57,610
the differences to be applied

00:19:56,380 --> 00:19:59,110
when we run your program essentially

00:19:57,610 --> 00:20:01,870
what we get back is just a graph

00:19:59,110 --> 00:20:03,550
definition so we don't the resources are

00:20:01,870 --> 00:20:06,010
not created that will make automatically

00:20:03,550 --> 00:20:08,860
just by running this code you also need

00:20:06,010 --> 00:20:11,920
the engine to create them to explain

00:20:08,860 --> 00:20:14,410
this a little bit unlike a chart we have

00:20:11,920 --> 00:20:16,180
several parts at the bottom there is a

00:20:14,410 --> 00:20:18,520
language hosted specific per run time

00:20:16,180 --> 00:20:22,180
obviously for dotnet we know that we

00:20:18,520 --> 00:20:24,130
need to run don't build doesn't run run

00:20:22,180 --> 00:20:26,050
your program and then the result of this

00:20:24,130 --> 00:20:28,570
is going to be the graph the graph is

00:20:26,050 --> 00:20:32,140
then passed to the CLI I'm gonna show a

00:20:28,570 --> 00:20:34,420
demo just in a minute and then she lies

00:20:32,140 --> 00:20:36,370
the smart guy who knows how to compare

00:20:34,420 --> 00:20:39,100
that graph to current graph figure out

00:20:36,370 --> 00:20:42,340
the differences and then it makes a plan

00:20:39,100 --> 00:20:46,060
and the plan would be crowd operations

00:20:42,340 --> 00:20:47,650
on on cloud providers so if we run our

00:20:46,060 --> 00:20:49,090
program the first time we know that we

00:20:47,650 --> 00:20:51,310
need to create two resources it will

00:20:49,090 --> 00:20:54,970
issue two commands to a shoe provider

00:20:51,310 --> 00:20:56,440
and if we run it next time maybe there

00:20:54,970 --> 00:20:59,980
are no differences and then it doesn't

00:20:56,440 --> 00:21:03,640
run anything for the same program so a

00:20:59,980 --> 00:21:07,180
quick demo of a basic scenario so I have

00:21:03,640 --> 00:21:11,830
a seizure project here it's just normal

00:21:07,180 --> 00:21:13,900
that net core project 3.1 it references

00:21:11,830 --> 00:21:16,510
a couple of nougat packages we have two

00:21:13,900 --> 00:21:18,220
for paluma because this one is a WSI

00:21:16,510 --> 00:21:21,040
reference a DB as you can see it's in

00:21:18,220 --> 00:21:22,660
preview but I can can also reference

00:21:21,040 --> 00:21:27,400
whatever and you get packages have I

00:21:22,660 --> 00:21:29,410
need in addition there are two c-sharp

00:21:27,400 --> 00:21:32,770
files program dot C S is very simple

00:21:29,410 --> 00:21:35,200
it's just the consolidation and all it

00:21:32,770 --> 00:21:38,020
does it calls deployment runasync and

00:21:35,200 --> 00:21:43,450
passes a class name well generic

00:21:38,020 --> 00:21:44,800
parameter of class general you can do

00:21:43,450 --> 00:21:47,020
whatever you want here you can read

00:21:44,800 --> 00:21:48,820
configuration files you can make web

00:21:47,020 --> 00:21:50,620
service calls like whatever

00:21:48,820 --> 00:21:52,590
you need to bootstrap and then in the

00:21:50,620 --> 00:21:55,270
end you just need to call deployment run

00:21:52,590 --> 00:21:57,670
and all the code is actually in the

00:21:55,270 --> 00:21:58,810
other class which is called static

00:21:57,670 --> 00:22:01,330
website in this case because I'm

00:21:58,810 --> 00:22:03,910
creating static website on top of a

00:22:01,330 --> 00:22:06,340
double SS free it derives from stack

00:22:03,910 --> 00:22:08,290
stack is like a top-level container of

00:22:06,340 --> 00:22:09,429
all resources which I don't work

00:22:08,290 --> 00:22:12,890
together

00:22:09,429 --> 00:22:17,450
one batch of deployment so the unit of

00:22:12,890 --> 00:22:18,260
deployment and stuff happens in its

00:22:17,450 --> 00:22:20,900
constructor

00:22:18,260 --> 00:22:23,510
I just knew up resources as I showed

00:22:20,900 --> 00:22:25,610
before the first one is bucket I give it

00:22:23,510 --> 00:22:28,520
a name when I say that I wanted to be

00:22:25,610 --> 00:22:31,280
able static website and then I can write

00:22:28,520 --> 00:22:34,070
whatever code I need in this case a list

00:22:31,280 --> 00:22:36,530
files in one email dub-dub-dub root

00:22:34,070 --> 00:22:39,559
directory and then I looked through the

00:22:36,530 --> 00:22:42,710
files extract some name and mime types

00:22:39,559 --> 00:22:46,130
from that file like if it's HTML or GS

00:22:42,710 --> 00:22:48,409
or CSS and for each file I create a

00:22:46,130 --> 00:22:51,530
bucket object and bucket object points

00:22:48,409 --> 00:22:54,320
to that bucket that I created above set

00:22:51,530 --> 00:22:58,159
this content type and points to the file

00:22:54,320 --> 00:23:01,370
path and if I need to change something

00:22:58,159 --> 00:23:03,350
let's say I want to add text here which

00:23:01,370 --> 00:23:06,010
is the dictionary so you see that I get

00:23:03,350 --> 00:23:10,220
intellisense and stuff that's my

00:23:06,010 --> 00:23:15,549
environment production if I make a

00:23:10,220 --> 00:23:18,440
mistake here I will get red squigglies

00:23:15,549 --> 00:23:20,750
so the feedback loop is very fast you

00:23:18,440 --> 00:23:23,450
don't have to run the tool to get some

00:23:20,750 --> 00:23:26,059
basic validation and you can discover

00:23:23,450 --> 00:23:29,570
all the options just by looking at like

00:23:26,059 --> 00:23:33,470
intellisense here it's a little bit

00:23:29,570 --> 00:23:37,220
small font but works in the end I don't

00:23:33,470 --> 00:23:39,770
know the URL of the website that I'm

00:23:37,220 --> 00:23:42,590
gonna get because that's defined by AWS

00:23:39,770 --> 00:23:44,539
so in the end I need to export that URL

00:23:42,590 --> 00:23:48,230
from my program that's like the outcome

00:23:44,539 --> 00:23:50,090
of the program and to express this I

00:23:48,230 --> 00:23:52,909
have an output property with a special

00:23:50,090 --> 00:23:54,730
attribute called endpoint and I assign

00:23:52,909 --> 00:24:00,440
this endpoint in the end of my program

00:23:54,730 --> 00:24:03,710
using bucket website endpoint okay so

00:24:00,440 --> 00:24:05,809
now to run this I don't just don't not

00:24:03,710 --> 00:24:10,850
run because that would just create a

00:24:05,809 --> 00:24:13,880
graph sorry but I need to go to COI and

00:24:10,850 --> 00:24:15,740
say pull me up that's paluma is a binary

00:24:13,880 --> 00:24:19,309
tool cross-platform works and Windows

00:24:15,740 --> 00:24:21,620
Mac OS Linux whatever I install it on my

00:24:19,309 --> 00:24:23,120
system I am in a folder where my project

00:24:21,620 --> 00:24:26,750
is so it picks up the project

00:24:23,120 --> 00:24:29,510
magically and then it will run my

00:24:26,750 --> 00:24:30,980
program and it doesn't create the

00:24:29,510 --> 00:24:34,190
resources yet but it shows me the

00:24:30,980 --> 00:24:37,220
preview of my graph because it's a clean

00:24:34,190 --> 00:24:39,830
state I get four resources as asked f2

00:24:37,220 --> 00:24:42,530
files in the folder it's like a virtual

00:24:39,830 --> 00:24:44,720
resource polymerase stack and then three

00:24:42,530 --> 00:24:48,110
actual AWS resources bucket and bucket

00:24:44,720 --> 00:24:50,660
objects and I can say if I'm happy or

00:24:48,110 --> 00:24:53,390
not it looks looks correct to me so I

00:24:50,660 --> 00:24:57,890
see it yes and now Paloma will run my

00:24:53,390 --> 00:25:00,860
program again and this time it will

00:24:57,890 --> 00:25:03,260
actually go ahead and call AWS to create

00:25:00,860 --> 00:25:04,520
the earth resources it knows that it

00:25:03,260 --> 00:25:06,260
first needs to create a bucket first

00:25:04,520 --> 00:25:08,900
because of the penalties and then bucket

00:25:06,260 --> 00:25:10,970
objects and in the end I get the

00:25:08,900 --> 00:25:13,850
endpoint back I can click it and

00:25:10,970 --> 00:25:17,020
hopefully I will see something bolt put

00:25:13,850 --> 00:25:19,250
them in c-sharp so that's lip light now

00:25:17,020 --> 00:25:20,890
to make it a bit more interesting let's

00:25:19,250 --> 00:25:23,150
change something so let's say it's not

00:25:20,890 --> 00:25:28,240
it's not production actually it's just

00:25:23,150 --> 00:25:32,540
staging and then maybe I will

00:25:28,240 --> 00:25:36,830
like rename a file to make it more

00:25:32,540 --> 00:25:39,830
changes so instead of about HTML I can

00:25:36,830 --> 00:25:42,710
now have companies demo now I can go

00:25:39,830 --> 00:25:43,960
back and use the same workflow run pull

00:25:42,710 --> 00:25:47,179
me up

00:25:43,960 --> 00:25:50,150
it will run my program and show me the

00:25:47,179 --> 00:25:53,090
preview of the changes given my previous

00:25:50,150 --> 00:25:55,220
safe side so in this case it should say

00:25:53,090 --> 00:25:58,400
well let's wait what it's gonna say but

00:25:55,220 --> 00:26:00,650
yeah it says that the old file is gone

00:25:58,400 --> 00:26:02,870
the new file is is going to be created

00:26:00,650 --> 00:26:04,340
and then index.html is going to be

00:26:02,870 --> 00:26:09,350
updated because the difference is in

00:26:04,340 --> 00:26:11,720
text I can see like details why why I

00:26:09,350 --> 00:26:15,110
think so so prod to change the staging

00:26:11,720 --> 00:26:17,000
for example okay make sense to me I hit

00:26:15,110 --> 00:26:21,110
yes again and it's going to be deploy

00:26:17,000 --> 00:26:23,929
those changes to AWS again so we changed

00:26:21,110 --> 00:26:25,850
my program it's desert state the

00:26:23,929 --> 00:26:30,990
deployment is the minimal difference

00:26:25,850 --> 00:26:33,220
that tangent calculates in the end

00:26:30,990 --> 00:26:34,660
if I'm just playing with on my

00:26:33,220 --> 00:26:38,190
development environment my favorite

00:26:34,660 --> 00:26:41,410
command is actually do Lumiere destroy

00:26:38,190 --> 00:26:44,080
what it does it creates an empty target

00:26:41,410 --> 00:26:45,610
state with current state and it deletes

00:26:44,080 --> 00:26:47,470
all the resources and if you ever tried

00:26:45,610 --> 00:26:48,820
to delete all the resources in the NWS

00:26:47,470 --> 00:26:51,220
that you created while clicking the

00:26:48,820 --> 00:26:53,020
console you will appreciate this come on

00:26:51,220 --> 00:26:55,090
because an Escher it's relatively simple

00:26:53,020 --> 00:27:00,100
with with the resource groups but in AWS

00:26:55,090 --> 00:27:02,440
it's just the help to find out so that's

00:27:00,100 --> 00:27:13,720
the idea behind the tool any questions

00:27:02,440 --> 00:27:24,970
here it talks for your PC with Pullum

00:27:13,720 --> 00:27:26,590
engine yes go engine have a slide about

00:27:24,970 --> 00:27:29,890
this but engine and providers are

00:27:26,590 --> 00:27:35,050
written and go and your programs are one

00:27:29,890 --> 00:27:37,960
of the is the case yes it's running on

00:27:35,050 --> 00:27:41,110
my machine so it's a CLI to that I run

00:27:37,960 --> 00:27:45,160
on the machine which has access to AWS

00:27:41,110 --> 00:27:47,530
in this case and so there is no proxy

00:27:45,160 --> 00:27:49,950
here that would have to have credentials

00:27:47,530 --> 00:27:52,600
to your account you have to setup your

00:27:49,950 --> 00:27:54,670
laptop or your CIC the server to have

00:27:52,600 --> 00:27:55,990
access and then run it there but I'm

00:27:54,670 --> 00:27:58,810
gonna touch on this and light show that

00:27:55,990 --> 00:28:01,390
let's let's proceed to the slides and

00:27:58,810 --> 00:28:03,550
then we have questions in the end so

00:28:01,390 --> 00:28:04,180
some more examples of why this makes

00:28:03,550 --> 00:28:06,160
sense to me

00:28:04,180 --> 00:28:09,850
let's say you want to deploy Asia

00:28:06,160 --> 00:28:12,730
functions and like hello world that you

00:28:09,850 --> 00:28:15,310
function to your age your account to run

00:28:12,730 --> 00:28:19,660
a energy function you have to deploy

00:28:15,310 --> 00:28:21,880
five resources integer function app you

00:28:19,660 --> 00:28:24,520
have to deploy a plan and then some

00:28:21,880 --> 00:28:26,980
storage resources like storage account

00:28:24,520 --> 00:28:29,560
container and if you deploy with zip

00:28:26,980 --> 00:28:32,230
deploy you have to deploy file binary

00:28:29,560 --> 00:28:34,240
and also you need resource group so six

00:28:32,230 --> 00:28:36,940
resources as I said that's like two

00:28:34,240 --> 00:28:39,370
hundred lines of Chasen but if you're in

00:28:36,940 --> 00:28:41,350
c-sharp you can do your work once and

00:28:39,370 --> 00:28:43,870
create a reusable component just a class

00:28:41,350 --> 00:28:46,120
that can be reused so I did that work

00:28:43,870 --> 00:28:48,040
and create it in an archive function app

00:28:46,120 --> 00:28:49,780
class that's a custom component we

00:28:48,040 --> 00:28:51,070
actually ship it with typescript is

00:28:49,780 --> 00:28:53,320
decay but not yet with it

00:28:51,070 --> 00:28:55,450
wait dotnet is decay but it creates

00:28:53,320 --> 00:28:57,760
those five resources inside of it and

00:28:55,450 --> 00:29:00,280
then I can make it as flexible as I want

00:28:57,760 --> 00:29:03,040
by default it can assume a lot of

00:29:00,280 --> 00:29:05,950
default properties and I just pointed

00:29:03,040 --> 00:29:08,530
the resource group and this file that

00:29:05,950 --> 00:29:10,809
files on the disk and when I run pulling

00:29:08,530 --> 00:29:12,190
me up on this program I get a nice

00:29:10,809 --> 00:29:14,680
preview that I have one

00:29:12,190 --> 00:29:18,250
archive function up and five resources

00:29:14,680 --> 00:29:20,500
under it but I can also make it more

00:29:18,250 --> 00:29:22,750
flexible say I want to run JavaScript

00:29:20,500 --> 00:29:25,210
functions instead it assumed that

00:29:22,750 --> 00:29:26,800
because I'm writing c-sharp but I can

00:29:25,210 --> 00:29:30,190
say runtime note and then it would

00:29:26,800 --> 00:29:32,800
deploy an odd function app instead it

00:29:30,190 --> 00:29:35,679
can get more complicated these two are

00:29:32,800 --> 00:29:37,240
running on Windows by default if I want

00:29:35,679 --> 00:29:40,030
to deploy a Python function app then I

00:29:37,240 --> 00:29:43,150
have to run on Linux that's just the

00:29:40,030 --> 00:29:45,160
requirement so I have to create my own

00:29:43,150 --> 00:29:49,690
plan say all the right things like

00:29:45,160 --> 00:29:51,730
dynamic Linux and so on and then given

00:29:49,690 --> 00:29:53,890
that I can pass this resource as a

00:29:51,730 --> 00:29:55,870
parameter of that resource and then

00:29:53,890 --> 00:29:58,510
inside the components you can imagine an

00:29:55,870 --> 00:30:01,480
if statement if you got planned

00:29:58,510 --> 00:30:03,700
parameter then use it if you didn't get

00:30:01,480 --> 00:30:06,070
one just create another one inside the

00:30:03,700 --> 00:30:07,990
component so your component can be as

00:30:06,070 --> 00:30:10,840
sophisticated as you want it to make it

00:30:07,990 --> 00:30:13,900
but the usage is going to be still sort

00:30:10,840 --> 00:30:17,620
of playing instantiations of resources

00:30:13,900 --> 00:30:19,929
if you get it right a slightly more

00:30:17,620 --> 00:30:24,760
complicated example let's say I'm

00:30:19,929 --> 00:30:28,510
working in a ecommerce company in a team

00:30:24,760 --> 00:30:30,460
which makes portal pages and we have

00:30:28,510 --> 00:30:32,260
customers all over the world

00:30:30,460 --> 00:30:36,940
we want to serve everybody in the US

00:30:32,260 --> 00:30:38,730
South America Europe Africa wherever so

00:30:36,940 --> 00:30:41,230
basically because we want to be close to

00:30:38,730 --> 00:30:43,270
our users we have to deploy our

00:30:41,230 --> 00:30:46,990
infrastructure to multiple regions so

00:30:43,270 --> 00:30:49,510
that latency is sort of manageable and

00:30:46,990 --> 00:30:52,060
maybe we use cosmos DB to distribute our

00:30:49,510 --> 00:30:54,429
data and they cosmos the buoy is

00:30:52,060 --> 00:30:56,230
supports multi region but if I want to

00:30:54,429 --> 00:30:58,190
use function apps function app is always

00:30:56,230 --> 00:31:00,800
in just one r1

00:30:58,190 --> 00:31:03,140
so I have to deploy and copies of

00:31:00,800 --> 00:31:05,300
function have to end locations and then

00:31:03,140 --> 00:31:07,000
I have to put some front-end load

00:31:05,300 --> 00:31:09,500
balancing service in front of it and

00:31:07,000 --> 00:31:11,840
sort of configure it to talk to the

00:31:09,500 --> 00:31:16,580
right region depending on where the

00:31:11,840 --> 00:31:20,030
customer is okay and but we have more

00:31:16,580 --> 00:31:21,590
teams and maybe shopping cart team they

00:31:20,030 --> 00:31:23,030
have all the challenges that I have

00:31:21,590 --> 00:31:24,890
because they serve the same customers

00:31:23,030 --> 00:31:28,280
but they don't use function apps they

00:31:24,890 --> 00:31:31,070
use container instances and maybe our

00:31:28,280 --> 00:31:33,100
pricing engine team uses some old JVM

00:31:31,070 --> 00:31:35,470
applications that have only run on

00:31:33,100 --> 00:31:38,930
virtual machines so they have to do all

00:31:35,470 --> 00:31:41,750
virtual networks subnets load balancers

00:31:38,930 --> 00:31:43,850
public IP is VM scale sets auto scaling

00:31:41,750 --> 00:31:49,010
so like ten resources in every region

00:31:43,850 --> 00:31:50,900
and copied n times so instead of doing

00:31:49,010 --> 00:31:52,640
it many times in different teams

00:31:50,900 --> 00:31:55,070
completely separate we can sit down

00:31:52,640 --> 00:31:57,230
together and come up with a component

00:31:55,070 --> 00:31:59,150
that would make sense to all of us in

00:31:57,230 --> 00:32:00,950
this case the component could create the

00:31:59,150 --> 00:32:05,000
common infrastructure like cosmos DB

00:32:00,950 --> 00:32:07,370
regions load balancers and then call our

00:32:05,000 --> 00:32:09,590
custom code and times so that we could

00:32:07,370 --> 00:32:13,220
create a pluggable application in every

00:32:09,590 --> 00:32:16,190
region and if we make this component

00:32:13,220 --> 00:32:17,300
once then the client code would look

00:32:16,190 --> 00:32:21,110
something like that

00:32:17,300 --> 00:32:22,490
I'm just saying new cosmos app I pass a

00:32:21,110 --> 00:32:24,050
resource group when the list of

00:32:22,490 --> 00:32:26,330
locations where I want to deploy it and

00:32:24,050 --> 00:32:28,160
then because we are in general-purpose

00:32:26,330 --> 00:32:30,220
programming language we can use the

00:32:28,160 --> 00:32:33,560
patterns that we know like factories and

00:32:30,220 --> 00:32:35,930
we can essentially just give it a

00:32:33,560 --> 00:32:39,200
callback to be called n times by the

00:32:35,930 --> 00:32:41,810
component component would provide

00:32:39,200 --> 00:32:43,370
parameters like connections team to

00:32:41,810 --> 00:32:46,990
cosmos DB and the region where I'm

00:32:43,370 --> 00:32:50,450
creating resources and my duty of the

00:32:46,990 --> 00:32:54,700
client code is just to create that

00:32:50,450 --> 00:32:57,650
specific thing that is usable in my

00:32:54,700 --> 00:32:59,770
program in my team in this case function

00:32:57,650 --> 00:33:01,580
app and the other team will create

00:32:59,770 --> 00:33:04,010
containers and the other team will

00:33:01,580 --> 00:33:06,980
create virtual machines and I returned

00:33:04,010 --> 00:33:09,980
back the endpoint of that resource and

00:33:06,980 --> 00:33:11,840
then all the wiring between front and

00:33:09,980 --> 00:33:15,240
back-end database and

00:33:11,840 --> 00:33:17,880
is done by the component so if that

00:33:15,240 --> 00:33:20,340
makes sense only for my company we can

00:33:17,880 --> 00:33:22,200
create this component put it into nougat

00:33:20,340 --> 00:33:25,049
packaged into private repository

00:33:22,200 --> 00:33:29,120
distribute version it independently like

00:33:25,049 --> 00:33:32,279
supported whatever whatever we I used to

00:33:29,120 --> 00:33:34,590
do with our code and if it makes sense

00:33:32,279 --> 00:33:37,080
for Birla community we can make it

00:33:34,590 --> 00:33:43,590
public and sort of support it it's an

00:33:37,080 --> 00:33:46,049
open-source library so that's the idea

00:33:43,590 --> 00:33:49,169
but behind the components a little bit

00:33:46,049 --> 00:33:52,049
more about how polymer works several

00:33:49,169 --> 00:33:54,450
aspects first the state management the

00:33:52,049 --> 00:33:57,389
same diagram but some more details at

00:33:54,450 --> 00:33:59,600
the left when engine makes decisions it

00:33:57,389 --> 00:34:01,980
needs to compare the current state of

00:33:59,600 --> 00:34:03,870
environment with the target state and

00:34:01,980 --> 00:34:08,510
the current state is actually stored

00:34:03,870 --> 00:34:10,829
separately by Paulo me because we need

00:34:08,510 --> 00:34:14,639
quite a lot of information to make

00:34:10,829 --> 00:34:17,639
decisions so we don't compare AWS or

00:34:14,639 --> 00:34:20,609
Asia directly to your program we store

00:34:17,639 --> 00:34:23,399
the previous state somewhere and then

00:34:20,609 --> 00:34:27,319
compare that stored state with your

00:34:23,399 --> 00:34:29,490
target infrastructure so a couple of

00:34:27,319 --> 00:34:31,859
conclusions here first you need to store

00:34:29,490 --> 00:34:33,990
somewhere my default we store it on our

00:34:31,859 --> 00:34:37,889
back-end service so it's very smooth and

00:34:33,990 --> 00:34:39,899
transparent so star state is just a JSON

00:34:37,889 --> 00:34:43,200
file essentially with all the serialized

00:34:39,899 --> 00:34:45,659
state and it goes to our back-end if you

00:34:43,200 --> 00:34:47,099
don't feel comfortable doing this like

00:34:45,659 --> 00:34:49,530
you don't want to share your state with

00:34:47,099 --> 00:34:50,129
us you can also store choose to store it

00:34:49,530 --> 00:34:52,230
yourself

00:34:50,129 --> 00:34:54,599
a very common use case is like as free

00:34:52,230 --> 00:34:56,429
or easy storage but then it's your

00:34:54,599 --> 00:35:00,030
responsibility to keep it somewhere

00:34:56,429 --> 00:35:02,220
don't lose it and don't screw it up ok

00:35:00,030 --> 00:35:04,200
you can if you are just on your laptop

00:35:02,220 --> 00:35:07,920
you can store it locally next day or

00:35:04,200 --> 00:35:11,220
executable if you start on a polymer

00:35:07,920 --> 00:35:13,589
service we will manage things like

00:35:11,220 --> 00:35:15,000
concurrency so that the same stack is

00:35:13,589 --> 00:35:17,930
not updated by two people at the same

00:35:15,000 --> 00:35:19,880
time and things like that

00:35:17,930 --> 00:35:22,430
and the second conclusion here is that

00:35:19,880 --> 00:35:24,980
if you are sort of naughty person you go

00:35:22,430 --> 00:35:26,180
into your portal for production

00:35:24,980 --> 00:35:29,390
environment and you start changing

00:35:26,180 --> 00:35:32,420
things there the state that we store in

00:35:29,390 --> 00:35:33,980
our back-end organiz free or anywhere

00:35:32,420 --> 00:35:36,200
it's going to be different from the

00:35:33,980 --> 00:35:38,600
actual state and then there is a special

00:35:36,200 --> 00:35:41,180
command and follow me say you say pull

00:35:38,600 --> 00:35:44,060
me refresh and that actually goes to the

00:35:41,180 --> 00:35:46,160
cloud retrieves all the information that

00:35:44,060 --> 00:35:48,680
it has it's still less information that

00:35:46,160 --> 00:35:50,840
we have but it compares our current

00:35:48,680 --> 00:35:52,280
state with the actual state and then it

00:35:50,840 --> 00:35:54,320
shows you the difference like the one I

00:35:52,280 --> 00:35:56,240
showed you and then it's your choice

00:35:54,320 --> 00:35:59,120
what to do with this either you can

00:35:56,240 --> 00:36:01,340
update the state the stored state with

00:35:59,120 --> 00:36:04,760
the actual state or you can say now I

00:36:01,340 --> 00:36:06,350
want to reconcile back to update to sort

00:36:04,760 --> 00:36:11,120
of discard the changes that somebody did

00:36:06,350 --> 00:36:13,610
to apply again the target state to them

00:36:11,120 --> 00:36:15,530
for search so that's your choice if

00:36:13,610 --> 00:36:17,900
you're making changes in multiple places

00:36:15,530 --> 00:36:20,630
it's a hard problem so you will have to

00:36:17,900 --> 00:36:27,110
solve it yourself yes do you have

00:36:20,630 --> 00:36:28,700
anything to resolve configuration if you

00:36:27,110 --> 00:36:36,950
say pulling a refresh and let's say yes

00:36:28,700 --> 00:36:39,170
then we will update the state no no

00:36:36,950 --> 00:36:40,940
that's a manual thing so we don't do it

00:36:39,170 --> 00:36:43,910
when you run pulling me up we don't do

00:36:40,940 --> 00:36:45,500
this automatically you have to something

00:36:43,910 --> 00:36:48,470
has to trigger you to run pulling me

00:36:45,500 --> 00:36:51,050
refresh if you're running me up on

00:36:48,470 --> 00:36:54,160
invalid state or sort of not not true

00:36:51,050 --> 00:36:56,930
state like deployment might fail because

00:36:54,160 --> 00:36:58,430
an operation wasn't valid or something

00:36:56,930 --> 00:37:00,760
like that so it's your responsibility

00:36:58,430 --> 00:37:02,990
ideally you would not mess up with

00:37:00,760 --> 00:37:06,310
important first actually multiple ways

00:37:02,990 --> 00:37:06,310
but hey

00:37:16,740 --> 00:37:19,720
well you you will use pulling me up

00:37:19,089 --> 00:37:22,869
again

00:37:19,720 --> 00:37:24,700
well first we do refresh and then you do

00:37:22,869 --> 00:37:28,539
pull him up to just freaking solace

00:37:24,700 --> 00:37:30,609
again yes sit well it will see that

00:37:28,539 --> 00:37:34,089
because you said to refresh it will see

00:37:30,609 --> 00:37:36,450
the changes and now you can say okay I

00:37:34,089 --> 00:37:39,809
want to cancel that those changes so

00:37:36,450 --> 00:37:42,789
it's just the same updating of the state

00:37:39,809 --> 00:37:46,240
operation so to reiterate paluma is

00:37:42,789 --> 00:37:48,250
multiple things in one one is CLI that

00:37:46,240 --> 00:37:50,440
you saw pulling me up with the engine

00:37:48,250 --> 00:37:53,380
inside the CLI the other thing is

00:37:50,440 --> 00:37:56,799
providers they are also distributed as

00:37:53,380 --> 00:37:58,269
separate binaries well you don't have to

00:37:56,799 --> 00:38:01,210
care about this but it will you can see

00:37:58,269 --> 00:38:02,920
them on your disk and both those things

00:38:01,210 --> 00:38:05,950
are open source and github

00:38:02,920 --> 00:38:07,869
free for any kind of use you can

00:38:05,950 --> 00:38:10,869
contribute you can open issues you can

00:38:07,869 --> 00:38:13,420
make PRS we're happy to accept them so

00:38:10,869 --> 00:38:15,430
that's all open source and free and all

00:38:13,420 --> 00:38:20,019
written and go unfortunately for you

00:38:15,430 --> 00:38:22,839
tonight developers the third component

00:38:20,019 --> 00:38:25,299
is that stayed back and that I mentioned

00:38:22,839 --> 00:38:27,009
but also it's a portal like a web UI

00:38:25,299 --> 00:38:29,170
where you can go and it's sort of like

00:38:27,009 --> 00:38:31,990
github for your git but that's like

00:38:29,170 --> 00:38:33,640
polymer SAS product for your polymer you

00:38:31,990 --> 00:38:35,799
can see the history of changes who did

00:38:33,640 --> 00:38:38,640
what you can manage permissions if you

00:38:35,799 --> 00:38:41,109
are in the team setting you can do audit

00:38:38,640 --> 00:38:44,859
policy that I'm gonna show later so some

00:38:41,109 --> 00:38:46,869
more team enterprise features and this

00:38:44,859 --> 00:38:50,259
one is closed source and it's also paid

00:38:46,869 --> 00:38:52,750
for teams so that's the way we want to

00:38:50,259 --> 00:38:54,369
make money so it's free for any

00:38:52,750 --> 00:38:56,289
individual use if you are just one

00:38:54,369 --> 00:38:59,589
person even if you do it on at work but

00:38:56,289 --> 00:39:02,799
if you start changing the same resources

00:38:59,589 --> 00:39:04,599
from multiple people then you need to

00:39:02,799 --> 00:39:07,119
buy licenses if you want to use this as

00:39:04,599 --> 00:39:11,890
back-end but it's not mandatory you can

00:39:07,119 --> 00:39:12,910
use the tool without the parole also

00:39:11,890 --> 00:39:14,559
it's possible that there is an

00:39:12,910 --> 00:39:16,269
Enterprise version of that if you are in

00:39:14,559 --> 00:39:18,000
sort of restricted environment you can

00:39:16,269 --> 00:39:20,500
install that back-end on your own

00:39:18,000 --> 00:39:22,359
Hardware somewhere and manage it

00:39:20,500 --> 00:39:23,470
yourself but get all the experience of

00:39:22,359 --> 00:39:26,680
the portal

00:39:23,470 --> 00:39:31,750
but that's even more expensive right

00:39:26,680 --> 00:39:33,760
make sense about authentication so even

00:39:31,750 --> 00:39:35,920
if you use Paloma back-end we never get

00:39:33,760 --> 00:39:39,700
your credentials we don't want to like

00:39:35,920 --> 00:39:41,290
they never leave your machine the

00:39:39,700 --> 00:39:43,930
machine which runs CLI has to have

00:39:41,290 --> 00:39:47,560
access basically full access but not to

00:39:43,930 --> 00:39:50,740
cloud provider because they it creates

00:39:47,560 --> 00:39:52,990
resources there usually if you're on

00:39:50,740 --> 00:39:55,840
your laptop that's usually what you get

00:39:52,990 --> 00:39:58,270
from a-z login o or AWS login whatever

00:39:55,840 --> 00:40:00,250
we use the same tokens after you login

00:39:58,270 --> 00:40:02,140
for the portal you will use the same

00:40:00,250 --> 00:40:03,460
token so it's transparent on CI CD

00:40:02,140 --> 00:40:07,030
system is usually like environment

00:40:03,460 --> 00:40:08,620
variable with access tokens and they

00:40:07,030 --> 00:40:13,800
never leave the machine we're polymer

00:40:08,620 --> 00:40:16,510
and so state doesn't have those a

00:40:13,800 --> 00:40:18,250
deployment process is usually twofold so

00:40:16,510 --> 00:40:22,360
if you're developer you have access to

00:40:18,250 --> 00:40:27,520
your developer resources directly you

00:40:22,360 --> 00:40:29,230
mess it up we delete it whatever and in

00:40:27,520 --> 00:40:32,050
production environment usually it goes

00:40:29,230 --> 00:40:34,120
through the ICD pipelines so ideally

00:40:32,050 --> 00:40:37,240
developers don't have write access to

00:40:34,120 --> 00:40:40,210
that one so all the keys were gonna be

00:40:37,240 --> 00:40:44,260
in CIC dear configuration we support

00:40:40,210 --> 00:40:49,270
like 10 15 most popular J cities we have

00:40:44,260 --> 00:40:52,060
say tasks for Asia develops but in the

00:40:49,270 --> 00:40:54,490
end they all call CLI internally so it

00:40:52,060 --> 00:40:58,030
all goes to CLI with proper parameters

00:40:54,490 --> 00:40:59,860
and proper environment variables and see

00:40:58,030 --> 00:41:04,650
ICD pipeline would deploy your resources

00:40:59,860 --> 00:41:04,650
to the production so if something fails

00:41:05,040 --> 00:41:11,020
obviously update can fail to do two

00:41:07,630 --> 00:41:12,640
different reasons we don't roll back

00:41:11,020 --> 00:41:15,820
automatically a lot of people ask that

00:41:12,640 --> 00:41:18,520
it fails we store the state of whatever

00:41:15,820 --> 00:41:21,400
we did and then we say it failed please

00:41:18,520 --> 00:41:24,190
do something with it if it was something

00:41:21,400 --> 00:41:27,550
transient in the cloud Asia was down and

00:41:24,190 --> 00:41:29,530
whatnot you can run it in 15 minutes try

00:41:27,550 --> 00:41:32,620
again in because its target state

00:41:29,530 --> 00:41:34,510
configuration it will eventually work if

00:41:32,620 --> 00:41:36,590
it's some problem in your program that

00:41:34,510 --> 00:41:38,930
we didn't anticipate you

00:41:36,590 --> 00:41:41,150
have to decide either you change your

00:41:38,930 --> 00:41:42,740
program and apply again or you can go to

00:41:41,150 --> 00:41:44,960
the previous version of your program and

00:41:42,740 --> 00:41:46,940
deploy it again and sort of this is

00:41:44,960 --> 00:41:49,490
gonna be your roll back and of course

00:41:46,940 --> 00:41:52,760
that can also fail if the intermediate

00:41:49,490 --> 00:41:56,180
state was sort of in that broken way so

00:41:52,760 --> 00:41:58,430
it's your responsibility to fix it there

00:41:56,180 --> 00:42:03,620
is no universal way to fix any failure

00:41:58,430 --> 00:42:05,840
in the cloud a little bit about how

00:42:03,620 --> 00:42:07,910
providers work so we have a bunch of

00:42:05,840 --> 00:42:11,390
provider set currently 40 or something

00:42:07,910 --> 00:42:13,640
and we have a bunch of runtimes

00:42:11,390 --> 00:42:17,630
currently four but gonna be more

00:42:13,640 --> 00:42:19,310
probably so for every provider say the

00:42:17,630 --> 00:42:21,350
barriers we have to implement for is the

00:42:19,310 --> 00:42:22,970
case in different languages and for

00:42:21,350 --> 00:42:26,060
every provider we have to implement is

00:42:22,970 --> 00:42:29,360
the case so if we had to do it manually

00:42:26,060 --> 00:42:32,900
that's not feasible whole problem is

00:42:29,360 --> 00:42:35,780
like 20 people including sales and

00:42:32,900 --> 00:42:37,940
everything so we actually have

00:42:35,780 --> 00:42:39,710
intermediate representation of every

00:42:37,940 --> 00:42:41,300
provider and then we have a cogeneration

00:42:39,710 --> 00:42:43,900
which takes that intermediate of

00:42:41,300 --> 00:42:48,080
presentation and creates every is DK

00:42:43,900 --> 00:42:49,490
automatically so if you go to github and

00:42:48,080 --> 00:42:51,740
try to change something as your provider

00:42:49,490 --> 00:42:53,330
you will see a header saying please

00:42:51,740 --> 00:42:56,000
don't change this file manually it's

00:42:53,330 --> 00:42:57,590
going to be real overwritten next time

00:42:56,000 --> 00:42:59,540
we generate something so if you need to

00:42:57,590 --> 00:43:01,130
fix something or read we change the

00:42:59,540 --> 00:43:05,050
intermediate representation then every

00:43:01,130 --> 00:43:07,760
provider benefit benefits from that

00:43:05,050 --> 00:43:09,820
representation is internal but also you

00:43:07,760 --> 00:43:13,700
can sort of feed some other

00:43:09,820 --> 00:43:16,640
representations into it too most popular

00:43:13,700 --> 00:43:18,650
examples is terraform and open api we

00:43:16,640 --> 00:43:20,830
can take any terraform provider and make

00:43:18,650 --> 00:43:26,060
it a plumie provider with like one our

00:43:20,830 --> 00:43:27,920
effort so and that's actually what

00:43:26,060 --> 00:43:30,410
happened for the major provided so far

00:43:27,920 --> 00:43:32,480
at the moment for AWS asier and Google

00:43:30,410 --> 00:43:35,180
we use terraform providers as polymer

00:43:32,480 --> 00:43:37,370
providers so the day terraform makes a

00:43:35,180 --> 00:43:41,450
new version the next day we'll have well

00:43:37,370 --> 00:43:43,460
get a paluma version second case is open

00:43:41,450 --> 00:43:45,410
API so kubernetes has great open api

00:43:43,460 --> 00:43:48,590
which is hundred percent correct and

00:43:45,410 --> 00:43:50,170
always work so the way the de kubernetes

00:43:48,590 --> 00:43:53,820
released a new version

00:43:50,170 --> 00:43:56,830
you get a new problem a provider update

00:43:53,820 --> 00:43:59,680
cloud providers also have open API it's

00:43:56,830 --> 00:44:01,810
utter crap they are lying in 50 percent

00:43:59,680 --> 00:44:05,260
x and the other 50 don't exist

00:44:01,810 --> 00:44:07,600
so we tried we failed everybody truck

00:44:05,260 --> 00:44:09,790
who tried failed they know the problem

00:44:07,600 --> 00:44:11,170
we sort of discussed how to fix it in

00:44:09,790 --> 00:44:13,690
the long term in the long term we want

00:44:11,170 --> 00:44:17,290
to go away from terraform because we are

00:44:13,690 --> 00:44:22,180
not really happy with them but and they

00:44:17,290 --> 00:44:25,180
are competitor in the end but yeah it's

00:44:22,180 --> 00:44:29,020
hard problem to solve and every cloud

00:44:25,180 --> 00:44:32,940
has their own challenges so we'll see at

00:44:29,020 --> 00:44:32,940
the moment it's this picture is correct

00:44:34,590 --> 00:44:43,480
yes any questions here ok so next

00:44:41,530 --> 00:44:45,040
example there were several people are

00:44:43,480 --> 00:44:47,410
using kubernetes but also this example

00:44:45,040 --> 00:44:49,750
is going to be of what your more

00:44:47,410 --> 00:44:53,200
sophisticated environment could look

00:44:49,750 --> 00:44:55,960
like in polymer so kubernetes is quite a

00:44:53,200 --> 00:44:57,970
complicated thing so in order to make it

00:44:55,960 --> 00:44:59,490
work you have to deploy stuff on

00:44:57,970 --> 00:45:03,010
multiple layers you have to deploy

00:44:59,490 --> 00:45:05,620
networking storage I didn't you then you

00:45:03,010 --> 00:45:09,310
have to create a managed cluster if you

00:45:05,620 --> 00:45:12,330
are an aw sorry Georgie CP probably use

00:45:09,310 --> 00:45:16,300
some managed services like cosmos DB or

00:45:12,330 --> 00:45:18,610
storage whatnot queues from your

00:45:16,300 --> 00:45:21,310
provider and then you put a bunch of

00:45:18,610 --> 00:45:22,840
applications on that cluster so multiple

00:45:21,310 --> 00:45:25,690
layers they probably change at different

00:45:22,840 --> 00:45:28,750
points at point in time by different

00:45:25,690 --> 00:45:31,570
people so that's a complicated system to

00:45:28,750 --> 00:45:34,300
support and the good thing is that you

00:45:31,570 --> 00:45:38,260
can manage resources on every layer with

00:45:34,300 --> 00:45:41,980
Paloma and so this I'm switching back

00:45:38,260 --> 00:45:44,440
again to in this simple project I only

00:45:41,980 --> 00:45:46,810
have two layers instead of four just to

00:45:44,440 --> 00:45:48,450
illustrate I have one program one

00:45:46,810 --> 00:45:51,370
polymer stack which creates

00:45:48,450 --> 00:45:54,630
infrastructure and cluster and another

00:45:51,370 --> 00:45:56,980
stack which creates application objects

00:45:54,630 --> 00:45:59,680
in the infrastructure that's probably

00:45:56,980 --> 00:46:03,010
done here by your IT people or somebody

00:45:59,680 --> 00:46:05,050
who knows kubernetes morale as well

00:46:03,010 --> 00:46:07,240
they create a cluster stack when I

00:46:05,050 --> 00:46:11,410
called and then it creates the resource

00:46:07,240 --> 00:46:13,150
group some SSH keys ad application

00:46:11,410 --> 00:46:17,079
service principles virtual networks

00:46:13,150 --> 00:46:22,030
subnets clusters everything bare minimal

00:46:17,079 --> 00:46:24,250
to run your IKS cluster and then if this

00:46:22,030 --> 00:46:25,599
works right then the result of this is

00:46:24,250 --> 00:46:29,710
going to be cube conflict that you will

00:46:25,599 --> 00:46:31,960
get from Asia and that's the the output

00:46:29,710 --> 00:46:34,030
of my program here I just output the

00:46:31,960 --> 00:46:36,130
cube config which is like connections to

00:46:34,030 --> 00:46:38,140
into kubernetes so this runs it probably

00:46:36,130 --> 00:46:40,089
doesn't change that often only one new

00:46:38,140 --> 00:46:43,109
versions of kubernetes change or you

00:46:40,089 --> 00:46:45,849
need to obscure cluster whatever

00:46:43,109 --> 00:46:47,920
somebody else is going to use this

00:46:45,849 --> 00:46:50,849
cluster for their applications they

00:46:47,920 --> 00:46:56,920
would have a different paluma program

00:46:50,849 --> 00:46:59,260
that has to use that cluster it can use

00:46:56,920 --> 00:47:01,720
what we call stack reference to get

00:46:59,260 --> 00:47:04,750
outputs of the other stack into their

00:47:01,720 --> 00:47:06,609
program so it instantiates stack

00:47:04,750 --> 00:47:09,490
reference it has to give the name of the

00:47:06,609 --> 00:47:13,270
stack that's like project company

00:47:09,490 --> 00:47:16,720
project stack name and then it can say

00:47:13,270 --> 00:47:21,609
require output called cube config and it

00:47:16,720 --> 00:47:24,010
will get at runtime the string back then

00:47:21,609 --> 00:47:24,670
it create options like a connection

00:47:24,010 --> 00:47:27,510
string again

00:47:24,670 --> 00:47:29,740
to connect to that cluster and starts

00:47:27,510 --> 00:47:32,380
provisional application objects in this

00:47:29,740 --> 00:47:34,770
case again I'm using a component finally

00:47:32,380 --> 00:47:37,180
I can show what the component looks like

00:47:34,770 --> 00:47:39,910
this is a custom component resource that

00:47:37,180 --> 00:47:42,369
I created again it's just a class

00:47:39,910 --> 00:47:44,859
derived from component resource in the

00:47:42,369 --> 00:47:47,530
constructor is defined sort of its name

00:47:44,859 --> 00:47:49,450
that you will see in preview and then

00:47:47,530 --> 00:47:51,220
you start all the logic that they need

00:47:49,450 --> 00:47:53,619
to create resources in this case it

00:47:51,220 --> 00:47:56,109
creates to bring this deployment and the

00:47:53,619 --> 00:48:01,060
service for the deployment in one

00:47:56,109 --> 00:48:02,950
component and then the stack again calls

00:48:01,060 --> 00:48:04,480
that service deployment it can call it

00:48:02,950 --> 00:48:07,510
five times to create five different

00:48:04,480 --> 00:48:09,950
services points to some container image

00:48:07,510 --> 00:48:12,950
or whatnot and so on

00:48:09,950 --> 00:48:15,770
if you have some existing kubernetes

00:48:12,950 --> 00:48:19,339
infrastructure and inform of you amble

00:48:15,770 --> 00:48:22,490
again there is another stack with the

00:48:19,339 --> 00:48:24,859
same stack reference and then it can

00:48:22,490 --> 00:48:28,339
point just to files sorry for the a lot

00:48:24,859 --> 00:48:30,349
of community code you can point to a

00:48:28,339 --> 00:48:33,170
llamo file by using a special resource

00:48:30,349 --> 00:48:35,809
config file or config group you can also

00:48:33,170 --> 00:48:37,790
use things like home charts here so if

00:48:35,809 --> 00:48:39,890
you have some existing definitions of

00:48:37,790 --> 00:48:42,559
resources in UML you can just bring

00:48:39,890 --> 00:48:46,520
those and start managing them from

00:48:42,559 --> 00:48:48,500
Paloma program if you have say arm

00:48:46,520 --> 00:48:50,630
templates or existing there is a

00:48:48,500 --> 00:48:53,930
resource in Azure called arm template

00:48:50,630 --> 00:48:56,780
and then you can give your adjacent to

00:48:53,930 --> 00:48:59,510
that resource and it starts managing it

00:48:56,780 --> 00:49:04,970
in the same workflow with other

00:48:59,510 --> 00:49:07,460
resources of polymer so sort of more

00:49:04,970 --> 00:49:09,309
complicated real world environments

00:49:07,460 --> 00:49:12,890
would usually consist of multiple

00:49:09,309 --> 00:49:15,980
programs referencing to each other and

00:49:12,890 --> 00:49:17,359
getting values one from the other also I

00:49:15,980 --> 00:49:19,849
didn't really explain the concept of

00:49:17,359 --> 00:49:21,920
stack so the stack is class and in the

00:49:19,849 --> 00:49:23,630
program but also it's like an

00:49:21,920 --> 00:49:25,250
environment the same program can be

00:49:23,630 --> 00:49:28,549
deployed to multiple targets like

00:49:25,250 --> 00:49:30,950
production staging testing and that's

00:49:28,549 --> 00:49:32,809
also called stack implement so you can

00:49:30,950 --> 00:49:34,609
switch stacks from production to staging

00:49:32,809 --> 00:49:38,930
and then deploy them your program to

00:49:34,609 --> 00:49:46,210
production or to stage in that case this

00:49:38,930 --> 00:49:49,329
is configured by CLI questions here it's

00:49:46,210 --> 00:49:49,329
pretty much

00:49:51,489 --> 00:49:58,489
I'm thinking about my next-door yes by

00:49:55,729 --> 00:50:00,849
do you mean using actually using home

00:49:58,489 --> 00:50:03,859
charts or replacing what what they do

00:50:00,849 --> 00:50:10,130
yes we can recover 100% of kubernetes

00:50:03,859 --> 00:50:12,140
api with polymer resources yes yes helm

00:50:10,130 --> 00:50:14,359
chart component is just to take helm

00:50:12,140 --> 00:50:17,739
charts actual some charts is employed

00:50:14,359 --> 00:50:20,420
but you can do everything with blue I

00:50:17,739 --> 00:50:22,450
think kubernetes is like the only which

00:50:20,420 --> 00:50:25,849
we have hundred percent coverage because

00:50:22,450 --> 00:50:27,650
for Asia anyway us there are corner

00:50:25,849 --> 00:50:30,440
cases which are not covered by terraform

00:50:27,650 --> 00:50:32,420
and by lumen like to be honest but

00:50:30,440 --> 00:50:33,769
because she used general-purpose

00:50:32,420 --> 00:50:35,569
programming language you can usually

00:50:33,769 --> 00:50:39,950
sort of code around those limitations

00:50:35,569 --> 00:50:43,190
you can say okay I cannot do this one

00:50:39,950 --> 00:50:47,499
thing but I can shell out to a CLI or

00:50:43,190 --> 00:50:47,499
call Asia SDK directly from the same

00:51:05,380 --> 00:51:11,710
code you can say I know what I'm doing I

00:51:07,940 --> 00:51:11,710
just want you can he be so

00:51:13,080 --> 00:51:18,670
well you'd have to do it some somewhat

00:51:16,500 --> 00:51:21,100
instead of pulling me like do it with

00:51:18,670 --> 00:51:23,470
the tool that supports that feature if

00:51:21,100 --> 00:51:25,390
it's only if it's supported by arm

00:51:23,470 --> 00:51:27,760
templates you can have a short snippet

00:51:25,390 --> 00:51:30,400
in your problem a program with arm

00:51:27,760 --> 00:51:33,390
template if it's supported by c-sharp

00:51:30,400 --> 00:51:36,310
SDK we can call to that c-sharp is decay

00:51:33,390 --> 00:51:38,320
but then you sort of have to a little

00:51:36,310 --> 00:51:41,230
bit manage yourself the life cycle so

00:51:38,320 --> 00:51:44,100
you have to kind of detect whether it

00:51:41,230 --> 00:51:46,300
already exists or not and it's a bit

00:51:44,100 --> 00:51:58,140
yeah it doesn't know what you do in your

00:51:46,300 --> 00:52:00,760
custom code I think there are web hooks

00:51:58,140 --> 00:52:02,500
that you can hook to your deployments

00:52:00,760 --> 00:52:05,590
and then the web hook is going to be

00:52:02,500 --> 00:52:07,270
called when deployment is finished but

00:52:05,590 --> 00:52:09,790
that's more like for automation of

00:52:07,270 --> 00:52:12,240
multiple deployments but you could also

00:52:09,790 --> 00:52:14,980
use that or it can be just as simply a

00:52:12,240 --> 00:52:16,750
next step in your C ICD pipeline like

00:52:14,980 --> 00:52:19,900
deploy bloom and then you run your

00:52:16,750 --> 00:52:22,030
custom whatnot or you can call you run

00:52:19,900 --> 00:52:23,590
your custom whatnot from blooming it's

00:52:22,030 --> 00:52:27,720
your choice

00:52:23,590 --> 00:52:32,230
finally all the examples were in c-sharp

00:52:27,720 --> 00:52:35,020
just by the virtue that we create dotnet

00:52:32,230 --> 00:52:37,330
as the case not not c-sharp is the case

00:52:35,020 --> 00:52:39,760
we get all their other languages well

00:52:37,330 --> 00:52:41,950
mostly f-sharp and VB the that I'm not

00:52:39,760 --> 00:52:44,320
sure if other languages exist at this

00:52:41,950 --> 00:52:46,030
point but you can use any dotnet

00:52:44,320 --> 00:52:48,910
language to provision polymer resources

00:52:46,030 --> 00:52:53,410
so f-sharp code would look a lot like

00:52:48,910 --> 00:52:56,950
c-sharp code with new constructor calls

00:52:53,410 --> 00:52:59,080
and property bags and so on F sharp is a

00:52:56,950 --> 00:53:02,050
bit different it's much more explicit so

00:52:59,080 --> 00:53:04,030
we use a lot of implicit conversions to

00:53:02,050 --> 00:53:06,610
move data between resources and that

00:53:04,030 --> 00:53:09,460
sharp sort of has to be very explicitly

00:53:06,610 --> 00:53:11,860
we will see things like IO and input

00:53:09,460 --> 00:53:13,480
function calls that translate say in

00:53:11,860 --> 00:53:15,370
this case from strange to what

00:53:13,480 --> 00:53:18,270
bulimia expects the types you don't see

00:53:15,370 --> 00:53:22,840
this in c-sharp but you have to be more

00:53:18,270 --> 00:53:25,120
mindful of this and enough sharp so this

00:53:22,840 --> 00:53:25,990
is the free part we also explore if we

00:53:25,120 --> 00:53:28,210
want at some point

00:53:25,990 --> 00:53:30,670
start generating is the case specific to

00:53:28,210 --> 00:53:33,010
language features like I've sharper

00:53:30,670 --> 00:53:36,130
decay another example as partial as

00:53:33,010 --> 00:53:38,350
decay you sort of can do plumie

00:53:36,130 --> 00:53:40,450
PowerShell by just calling c-sharp

00:53:38,350 --> 00:53:43,000
classes but that again doesn't feel like

00:53:40,450 --> 00:53:45,940
native PowerShell well this doesn't

00:53:43,000 --> 00:53:47,950
quite feel like an 85 sharp so we

00:53:45,940 --> 00:53:49,270
explore this this this is not something

00:53:47,950 --> 00:53:51,490
that you can use today but there is a

00:53:49,270 --> 00:53:54,670
for F sharp there is a issue open

00:53:51,490 --> 00:53:56,230
somewhere where there are like five

00:53:54,670 --> 00:53:59,800
pages of discussion how this can be done

00:53:56,230 --> 00:54:01,750
and prototype put could look like this

00:53:59,800 --> 00:54:03,220
so this is still F sharp even though

00:54:01,750 --> 00:54:05,830
it's very different but it's based on

00:54:03,220 --> 00:54:09,220
computation expressions indexes syntax

00:54:05,830 --> 00:54:11,590
it sort of looks like Jason again but

00:54:09,220 --> 00:54:13,810
it's strongly typed if you make a

00:54:11,590 --> 00:54:15,880
mistake you get an error you can do

00:54:13,810 --> 00:54:21,130
things like collection comprehensions

00:54:15,880 --> 00:54:23,140
and other difficult F sharp stuff to be

00:54:21,130 --> 00:54:26,710
more expressive about your code and this

00:54:23,140 --> 00:54:29,430
is more natural and sort of DSL like an

00:54:26,710 --> 00:54:31,210
F sharp but that doesn't work today so

00:54:29,430 --> 00:54:33,550
don't be too optimistic

00:54:31,210 --> 00:54:36,040
something about quality control unit

00:54:33,550 --> 00:54:38,560
testing and so on so what I hear a lot

00:54:36,040 --> 00:54:42,010
especially from operations people if I

00:54:38,560 --> 00:54:43,630
give such a powerful tool SC sharp to my

00:54:42,010 --> 00:54:46,990
developers they're gonna shoot

00:54:43,630 --> 00:54:49,600
themselves into the foot kill my cloud

00:54:46,990 --> 00:54:55,030
do horrible things I'm not gonna do this

00:54:49,600 --> 00:54:56,619
so my position is that first they can do

00:54:55,030 --> 00:54:58,050
horrible things with the ml and Jason

00:54:56,619 --> 00:55:00,900
for sure

00:54:58,050 --> 00:55:04,410
so there are tools from the cloud

00:55:00,900 --> 00:55:06,670
vendors to prevent this you have all the

00:55:04,410 --> 00:55:10,090
permission management and policies in

00:55:06,670 --> 00:55:12,490
edge or AWS that you you should use and

00:55:10,090 --> 00:55:15,900
probably have to use at some point if

00:55:12,490 --> 00:55:19,330
you're a big cloud based company and

00:55:15,900 --> 00:55:21,760
also just by giving them better tools

00:55:19,330 --> 00:55:23,830
you can also sort of encourage them to

00:55:21,760 --> 00:55:26,050
make better code because if you write

00:55:23,830 --> 00:55:29,020
c-sharp you can start doing things like

00:55:26,050 --> 00:55:31,900
unit testing for the same stacks that

00:55:29,020 --> 00:55:33,790
you defined before you can call

00:55:31,900 --> 00:55:36,190
deployment tests I think instead of

00:55:33,790 --> 00:55:37,619
deployment run I think and do nothing

00:55:36,190 --> 00:55:40,200
but return the

00:55:37,619 --> 00:55:41,730
the resources back from that call so

00:55:40,200 --> 00:55:44,640
what you get is a list of resources you

00:55:41,730 --> 00:55:46,920
can then find the ones of type T are

00:55:44,640 --> 00:55:49,380
interested about like security group and

00:55:46,920 --> 00:55:51,509
then do some asserts about those

00:55:49,380 --> 00:55:53,900
resources in this case it checks whether

00:55:51,509 --> 00:55:57,589
there are publicly OpenSSH ports and

00:55:53,900 --> 00:56:00,450
then fail if you find this is SSH port

00:55:57,589 --> 00:56:02,579
so this is super fast it doesn't do any

00:56:00,450 --> 00:56:05,640
anything with AWS it runs in

00:56:02,579 --> 00:56:07,829
milliseconds you can have fast feedback

00:56:05,640 --> 00:56:09,690
loop you can write a lot of those unit

00:56:07,829 --> 00:56:11,099
tests you can check whatever well you

00:56:09,690 --> 00:56:13,940
don't have to you cannot check

00:56:11,099 --> 00:56:16,470
everything because this doesn't deploy

00:56:13,940 --> 00:56:19,019
to the cloud so you don't know some

00:56:16,470 --> 00:56:21,089
pieces of data like the website endpoint

00:56:19,019 --> 00:56:25,440
that I showed before it's still not

00:56:21,089 --> 00:56:28,440
populated basically this is testing the

00:56:25,440 --> 00:56:30,749
shape of your inputs or resources but

00:56:28,440 --> 00:56:32,279
that's already a lot and you can even

00:56:30,749 --> 00:56:35,309
without knowing the structure of your

00:56:32,279 --> 00:56:37,470
stack sort of you can query research

00:56:35,309 --> 00:56:43,140
graph and make some assertions about

00:56:37,470 --> 00:56:44,940
about that one making one step forward

00:56:43,140 --> 00:56:48,239
from this there is actually a feature in

00:56:44,940 --> 00:56:49,799
polymer called policies called and this

00:56:48,239 --> 00:56:52,349
is the only typescript slide that I have

00:56:49,799 --> 00:56:55,890
because currently we don't support that

00:56:52,349 --> 00:56:57,749
matter so it's only JavaScript but you

00:56:55,890 --> 00:56:59,519
write sort of the same style of

00:56:57,749 --> 00:57:01,739
assertions but it's not just a unit test

00:56:59,519 --> 00:57:05,249
this is a policy that you can install

00:57:01,739 --> 00:57:07,769
into your team and then every stack that

00:57:05,249 --> 00:57:09,690
you deploy for every deployment at the

00:57:07,769 --> 00:57:11,880
runtime before actually making the

00:57:09,690 --> 00:57:13,559
resource it will run and validate the

00:57:11,880 --> 00:57:16,140
shape before the deployment that will

00:57:13,559 --> 00:57:17,999
fail the deployment if it fails so you

00:57:16,140 --> 00:57:21,210
can say I don't want to see a sports

00:57:17,999 --> 00:57:23,670
open ever on production and then you

00:57:21,210 --> 00:57:27,269
apply this policy to all the stacks

00:57:23,670 --> 00:57:29,339
which are Marcos production and at the

00:57:27,269 --> 00:57:31,230
deployment time it will run and because

00:57:29,339 --> 00:57:32,339
it's deployment time we'll all we will

00:57:31,230 --> 00:57:33,989
already have all the properties

00:57:32,339 --> 00:57:36,920
populated so we have you can check

00:57:33,989 --> 00:57:39,900
everything here and it will fail

00:57:36,920 --> 00:57:43,579
mandatory checks or it can give some

00:57:39,900 --> 00:57:43,579
recommendations if it's like not

00:57:43,700 --> 00:57:49,700
unfortunately unfortunat level

00:57:46,339 --> 00:57:49,700
recommendation or something

00:57:50,219 --> 00:57:55,259
so it checks the target configuration if

00:57:52,199 --> 00:57:58,410
your existing resources violate this

00:57:55,259 --> 00:58:01,380
policy well fine but the new deployments

00:57:58,410 --> 00:58:04,019
will not succeed unless you fix the

00:58:01,380 --> 00:58:06,199
target state to comply so that's a way

00:58:04,019 --> 00:58:10,259
to gradually introduce these policies

00:58:06,199 --> 00:58:12,179
into your footprint probably this is

00:58:10,259 --> 00:58:15,239
written by some different people like

00:58:12,179 --> 00:58:17,009
security people or ops people so maybe

00:58:15,239 --> 00:58:19,410
they would use typescript well you would

00:58:17,009 --> 00:58:22,319
use C sharp for your sticks that that's

00:58:19,410 --> 00:58:23,969
possible and at some point we'll

00:58:22,319 --> 00:58:27,089
introduce it in the end but probably not

00:58:23,969 --> 00:58:28,619
not in April so to be fair there there

00:58:27,089 --> 00:58:31,380
are some alternative products that with

00:58:28,619 --> 00:58:34,049
the same idea let's put them in the most

00:58:31,380 --> 00:58:36,839
notable one is a diverse City Kay cloud

00:58:34,049 --> 00:58:38,009
development kit they have the same idea

00:58:36,839 --> 00:58:39,689
of using general-purpose programming

00:58:38,009 --> 00:58:41,549
languages almost the same list of

00:58:39,689 --> 00:58:45,479
languages they have Java instead of go

00:58:41,549 --> 00:58:47,640
and you define your radius resources and

00:58:45,479 --> 00:58:49,589
then it works a bit different because it

00:58:47,640 --> 00:58:51,569
generates CloudFormation templates from

00:58:49,589 --> 00:58:53,489
that program and then you use the

00:58:51,569 --> 00:58:56,519
deployment tools afraid of barriers to

00:58:53,489 --> 00:58:58,669
deploy that confirmation yamo but at

00:58:56,519 --> 00:59:01,650
least you don't write that EML manually

00:58:58,669 --> 00:59:03,630
so it has pros and cons obviously if

00:59:01,650 --> 00:59:06,049
something is not expressible in crowd

00:59:03,630 --> 00:59:09,869
formation you cannot write program in

00:59:06,049 --> 00:59:12,229
cdk obvious things like Asia resources

00:59:09,869 --> 00:59:15,150
or even kubernetes or stuff like that

00:59:12,229 --> 00:59:16,380
but if you are purely the best company

00:59:15,150 --> 00:59:19,019
my baby it makes sense to start with

00:59:16,380 --> 00:59:21,749
city K and the program looks very much

00:59:19,019 --> 00:59:23,640
like pulling a different sort of set of

00:59:21,749 --> 00:59:26,849
parameters but the same feeling of

00:59:23,640 --> 00:59:31,169
passing property backs into constructors

00:59:26,849 --> 00:59:33,630
and then getting gamal as a result for

00:59:31,169 --> 00:59:35,489
Escher or DCP I don't think anything

00:59:33,630 --> 00:59:36,329
like that exists or is going to exist

00:59:35,489 --> 00:59:41,569
anytime soon

00:59:36,329 --> 00:59:44,400
some people created a lot of their own

00:59:41,569 --> 00:59:47,489
arm template generators so it's just

00:59:44,400 --> 00:59:49,650
someone frustrated with JSON in this

00:59:47,489 --> 00:59:52,529
case that's a sharper tool where you can

00:59:49,650 --> 00:59:55,229
write a sharp code and then as a result

00:59:52,529 --> 00:59:58,140
you get arm template but of course this

00:59:55,229 --> 01:00:00,299
is supported by some individual if you

00:59:58,140 --> 01:00:01,570
miss a feature you go fix it yourself

01:00:00,299 --> 01:00:04,360
basically

01:00:01,570 --> 01:00:08,650
and also this exists for AWS for sure

01:00:04,360 --> 01:00:11,200
things like I forgot the name but there

01:00:08,650 --> 01:00:13,420
are multiple tools like that usually

01:00:11,200 --> 01:00:19,540
people start writing their own when they

01:00:13,420 --> 01:00:22,830
are frustrated by someone else's yes so

01:00:19,540 --> 01:00:25,090
conclusions well first if you are

01:00:22,830 --> 01:00:27,310
developing any sort of cloud

01:00:25,090 --> 01:00:30,640
applications my strong advice is to use

01:00:27,310 --> 01:00:32,320
a two for infrastructures code if you're

01:00:30,640 --> 01:00:34,710
happy with arm templates go for it

01:00:32,320 --> 01:00:37,780
maybe tear form or ctkoeppel you may

01:00:34,710 --> 01:00:39,160
just don't don't click in the portal and

01:00:37,780 --> 01:00:42,700
don't create production resources just

01:00:39,160 --> 01:00:45,880
from from there or from CLI you're gonna

01:00:42,700 --> 01:00:52,300
hit a lot of problems a couple months

01:00:45,880 --> 01:00:53,740
from the time from high-level I already

01:00:52,300 --> 01:00:57,220
mentioned this in the introduction but I

01:00:53,740 --> 01:00:59,920
see that we go from bigger resources

01:00:57,220 --> 01:01:02,220
like physical VM stand virtual machines

01:00:59,920 --> 01:01:05,650
of physical service virtual machines

01:01:02,220 --> 01:01:08,320
container server dysfunctions more and

01:01:05,650 --> 01:01:11,950
more resources smaller and smaller

01:01:08,320 --> 01:01:13,260
resources fine grained full control you

01:01:11,950 --> 01:01:15,850
get a lot of them so you require

01:01:13,260 --> 01:01:18,190
automation and require better automation

01:01:15,850 --> 01:01:19,870
and the better of dimension you get the

01:01:18,190 --> 01:01:22,660
more desire you have to create smaller

01:01:19,870 --> 01:01:24,730
resources and a lot of them so this this

01:01:22,660 --> 01:01:26,560
is like a cycle a loop which goes on and

01:01:24,730 --> 01:01:28,150
on I guess the tools that we're gonna

01:01:26,560 --> 01:01:30,520
use in five years are going to be more

01:01:28,150 --> 01:01:32,260
powerful and different from now so

01:01:30,520 --> 01:01:34,570
that's an exciting space or maybe

01:01:32,260 --> 01:01:39,520
challenging space to watch and keep up

01:01:34,570 --> 01:01:41,950
with and I believe that general-purpose

01:01:39,520 --> 01:01:44,800
languages like C sharp have the future

01:01:41,950 --> 01:01:46,600
here they are developer friendly and

01:01:44,800 --> 01:01:49,450
there are much more developers than

01:01:46,600 --> 01:01:51,310
operations people and they sort of want

01:01:49,450 --> 01:01:54,360
to get into the space of developing

01:01:51,310 --> 01:01:56,620
their applications you get all the

01:01:54,360 --> 01:01:59,230
benefits of logic like conditionals and

01:01:56,620 --> 01:02:04,060
loops basically for free get IDs great

01:01:59,230 --> 01:02:05,830
tooling familiar experience and maybe

01:02:04,060 --> 01:02:08,140
the biggest one for me is that it can

01:02:05,830 --> 01:02:10,120
create abstractions for yourself and for

01:02:08,140 --> 01:02:12,550
others like do the work once and then

01:02:10,120 --> 01:02:15,040
reuse that the way that you are used to

01:02:12,550 --> 01:02:18,430
with functions or classes

01:02:15,040 --> 01:02:22,360
packages and so on somebody in there AWS

01:02:18,430 --> 01:02:24,400
while explaining this said that we go

01:02:22,360 --> 01:02:27,310
from infrastructure is code to something

01:02:24,400 --> 01:02:29,320
like architecture is code when you draw

01:02:27,310 --> 01:02:31,180
your diagram on the whiteboard it's

01:02:29,320 --> 01:02:32,860
usually quite high level and on the

01:02:31,180 --> 01:02:35,650
level that you want to reason about your

01:02:32,860 --> 01:02:37,090
infrastructure and then you go to Jamal

01:02:35,650 --> 01:02:40,540
and you write a completely different

01:02:37,090 --> 01:02:42,640
thing there so instead of doing that you

01:02:40,540 --> 01:02:44,740
can create components without those

01:02:42,640 --> 01:02:47,290
boxes in your architecture diagram and

01:02:44,740 --> 01:02:52,360
your codes sort of starts to have the

01:02:47,290 --> 01:02:55,510
same shape that you reason about so

01:02:52,360 --> 01:02:57,940
maybe we are going there some useful

01:02:55,510 --> 01:02:59,260
links here obviously if you want to get

01:02:57,940 --> 01:03:02,320
started with problem you go to polymer

01:02:59,260 --> 01:03:05,230
calm dotnet is brings you to SDK

01:03:02,320 --> 01:03:07,030
the net is UK we have a lot of blog post

01:03:05,230 --> 01:03:08,890
on paluma dot-com but also we have some

01:03:07,030 --> 01:03:13,180
common posts with with Microsoft for

01:03:08,890 --> 01:03:15,460
example we are sort of challenging their

01:03:13,180 --> 01:03:18,910
arm templates but they on the grand

01:03:15,460 --> 01:03:21,310
scheme we help their customers to bring

01:03:18,910 --> 01:03:24,160
more usage to Asia so they're happy to

01:03:21,310 --> 01:03:28,540
support us in any way possible so we

01:03:24,160 --> 01:03:30,610
have a blog post on the net we have blog

01:03:28,540 --> 01:03:32,890
post and Escher we have channel 9 videos

01:03:30,610 --> 01:03:35,010
and so on so forth I'm going to ignite

01:03:32,890 --> 01:03:38,830
the tour conference to show this to

01:03:35,010 --> 01:03:41,800
Microsoft customers so even though it's

01:03:38,830 --> 01:03:44,140
not first party tool some people I used

01:03:41,800 --> 01:03:46,660
to only use Microsoft tools but it's

01:03:44,140 --> 01:03:50,440
still encouraged by Microsoft as well

01:03:46,660 --> 01:03:52,450
and that's all I got ahead I'm happy to

01:03:50,440 --> 01:03:54,930
take more questions from the audience or

01:03:52,450 --> 01:03:57,810
after with beers or whatnot

01:03:54,930 --> 01:04:02,469
thank you for that

01:03:57,810 --> 01:04:02,469

YouTube URL: https://www.youtube.com/watch?v=SsvfsAJdLFI


