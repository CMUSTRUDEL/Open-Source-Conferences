Title: MountainWest RubyConf 2014 - Big O in a Homemade Hash by Nathan Long
Publication date: 2020-01-24
Playlist: MWRC 2014
Description: 
	Rubyists use hashes all the time. But could you build Ruby's Hash class from scratch?
In this talk, I'll walk you through it. We'll learn what it takes to get the interface we want and maintain O(1) performance as it grows.

Help us caption & translate this video!

http://amara.org/v/FG2n/
Captions: 
	00:00:24,800 --> 00:00:31,619
so um I got a pretty important phone

00:00:28,050 --> 00:00:34,260
call recently um President Obama called

00:00:31,619 --> 00:00:35,760
me up I was uh pretty surprised I was

00:00:34,260 --> 00:00:38,519
brushing my teeth you know whatever he

00:00:35,760 --> 00:00:41,480
calls me up and he's like I've received

00:00:38,519 --> 00:00:44,300
grave news of a news of a grave threat

00:00:41,480 --> 00:00:49,339
unless you re implement Ruby's hash

00:00:44,300 --> 00:00:49,339
alien terrorists will blow up SeaWorld

00:00:49,460 --> 00:00:55,590
blow up SeaWorld that guy's a pom

00:00:53,460 --> 00:00:59,250
impersonation is terrible sorry

00:00:55,590 --> 00:01:00,690
so I said mr. president I I love aquatic

00:00:59,250 --> 00:01:04,649
mammals as much as you do but that

00:01:00,690 --> 00:01:06,119
really makes no sense I thought it was

00:01:04,649 --> 00:01:08,399
gonna you know hang up and blow it off

00:01:06,119 --> 00:01:12,030
but I looked outside and I saw this van

00:01:08,399 --> 00:01:13,640
and I thought maybe I should at least

00:01:12,030 --> 00:01:16,050
give it a shot

00:01:13,640 --> 00:01:17,429
so everybody knows what a hash is a hash

00:01:16,050 --> 00:01:20,759
is a data structure we use these all the

00:01:17,429 --> 00:01:22,649
time basically it's a place to put

00:01:20,759 --> 00:01:24,330
values that you associate with keys and

00:01:22,649 --> 00:01:28,590
you can ask for that key and get that

00:01:24,330 --> 00:01:30,600
value back some languages call this a

00:01:28,590 --> 00:01:32,189
map or a dictionary and our goal is

00:01:30,600 --> 00:01:34,020
basically gonna be let's implement this

00:01:32,189 --> 00:01:38,159
let's make our own hash clasp that works

00:01:34,020 --> 00:01:39,719
just like that piece of cake right we

00:01:38,159 --> 00:01:41,549
can totally do this here's the

00:01:39,719 --> 00:01:43,740
implementation I have in mind okay

00:01:41,549 --> 00:01:45,450
inside the guts of this thing we have an

00:01:43,740 --> 00:01:46,829
array of arrays we've got a bunch of

00:01:45,450 --> 00:01:49,680
little arrays each of them is a pair of

00:01:46,829 --> 00:01:52,320
keys and values so if you say I would

00:01:49,680 --> 00:01:53,520
like to see the value for got cat I can

00:01:52,320 --> 00:01:55,140
just walk through these little arrays of

00:01:53,520 --> 00:01:58,110
arrays until I find one that the key is

00:01:55,140 --> 00:02:00,299
cat and I can give you back gato and if

00:01:58,110 --> 00:02:02,700
you try to insert a value simple I can

00:02:00,299 --> 00:02:04,829
just go along until I find the correct

00:02:02,700 --> 00:02:07,200
key update the value if there isn't one

00:02:04,829 --> 00:02:11,609
I'll insert a new tuple piece of cake

00:02:07,200 --> 00:02:13,230
right that's gonna work perfectly so I

00:02:11,609 --> 00:02:14,880
also know that Ruby has all kinds of

00:02:13,230 --> 00:02:16,890
lovely syntactic sugar you can define

00:02:14,880 --> 00:02:18,480
your own equal methods and stuff so to

00:02:16,890 --> 00:02:20,160
get the nice little bracket notation I'm

00:02:18,480 --> 00:02:22,709
going to define this reader and this

00:02:20,160 --> 00:02:23,430
writer and then it'll look just like

00:02:22,709 --> 00:02:24,750
it's supposed to

00:02:23,430 --> 00:02:27,329
now you notice I'm calling this class

00:02:24,750 --> 00:02:29,760
tuple map it's not really a hash but

00:02:27,329 --> 00:02:31,669
it's close enough and it uses tuples so

00:02:29,760 --> 00:02:34,080
that's a good name

00:02:31,669 --> 00:02:36,090
so I built this class

00:02:34,080 --> 00:02:37,350
I tested it everything looks well it

00:02:36,090 --> 00:02:38,970
works just like this

00:02:37,350 --> 00:02:40,970
hokey is pokey and you can get it back

00:02:38,970 --> 00:02:43,380
out thumbs up

00:02:40,970 --> 00:02:47,550
wrote an email to the president attached

00:02:43,380 --> 00:02:53,990
my class and said there you go sir call

00:02:47,550 --> 00:03:00,780
it a day well I got another phone call

00:02:53,990 --> 00:03:01,560
he's he said well maybe clear that's not

00:03:00,780 --> 00:03:03,330
good enough

00:03:01,560 --> 00:03:05,760
he said now my eggheads tell me that

00:03:03,330 --> 00:03:07,680
your your hash is a wolf 1 and it needs

00:03:05,760 --> 00:03:08,880
to be your craft is Oba Vanna it needs

00:03:07,680 --> 00:03:12,630
to be o of 1 I don't know what that

00:03:08,880 --> 00:03:15,000
means but I want you to fix it if you're

00:03:12,630 --> 00:03:16,800
changing the requirements on me is that

00:03:15,000 --> 00:03:18,270
what happened healthcare.gov I can't I

00:03:16,800 --> 00:03:22,650
can't live under these this kind of

00:03:18,270 --> 00:03:24,510
pressure the problem is his eggheads

00:03:22,650 --> 00:03:26,070
were right Oliv a nano of one or very

00:03:24,510 --> 00:03:29,160
different things and we do have an Olaf

00:03:26,070 --> 00:03:30,560
one hash and that's not good enough but

00:03:29,160 --> 00:03:32,550
what the heck does that mean now

00:03:30,560 --> 00:03:34,500
probably a lot of you have computer

00:03:32,550 --> 00:03:35,459
science backgrounds but I don't so I'm

00:03:34,500 --> 00:03:36,810
going to talk to the ones of you who

00:03:35,459 --> 00:03:39,269
don't and this is going to be computer

00:03:36,810 --> 00:03:40,950
science by noobs for noobs I'm going to

00:03:39,269 --> 00:03:43,800
explain the concept of Big O & & Wine's

00:03:40,950 --> 00:03:46,110
is so important when we talk about Big O

00:03:43,800 --> 00:03:48,269
notation the O is for order like order

00:03:46,110 --> 00:03:50,040
of growth and we're really talking about

00:03:48,269 --> 00:03:53,580
rates of growth let me give you some

00:03:50,040 --> 00:03:55,380
really simple illustrations so if I were

00:03:53,580 --> 00:03:57,090
gonna do a task like go around and shake

00:03:55,380 --> 00:03:58,800
hands with every one of you that's oh of

00:03:57,090 --> 00:04:00,180
n if there's ten of you I've got ten

00:03:58,800 --> 00:04:01,920
handshakes to make if there's 100 I've

00:04:00,180 --> 00:04:04,050
got 100 handshakes to make very simple

00:04:01,920 --> 00:04:05,459
right it scales like that what if I were

00:04:04,050 --> 00:04:07,019
going to try to introduce every person

00:04:05,459 --> 00:04:08,910
in this room to every other person in

00:04:07,019 --> 00:04:10,950
this room that's all Venn squared right

00:04:08,910 --> 00:04:12,060
if there's ten of you there's roughly

00:04:10,950 --> 00:04:13,950
hundred introductions to make I'm

00:04:12,060 --> 00:04:15,330
fudging a little bit if there's 100

00:04:13,950 --> 00:04:17,729
there's roughly 10,000 introductions to

00:04:15,330 --> 00:04:19,109
make that scales really poorly but

00:04:17,729 --> 00:04:21,180
something that scales awesomely is

00:04:19,109 --> 00:04:22,790
waving at you because I don't care how

00:04:21,180 --> 00:04:25,500
many of you there are this is o of one

00:04:22,790 --> 00:04:28,050
right and the great thing is that the N

00:04:25,500 --> 00:04:30,030
describes the number of inputs so in

00:04:28,050 --> 00:04:31,860
this case the number of inputs is how

00:04:30,030 --> 00:04:33,960
many people are we dealing with and you

00:04:31,860 --> 00:04:35,820
notice that in the phrase oh of 1 the

00:04:33,960 --> 00:04:39,000
letter n does not appear because it's

00:04:35,820 --> 00:04:42,360
completely irrelevant so when we talking

00:04:39,000 --> 00:04:43,710
about o of 1 algorithm that's great that

00:04:42,360 --> 00:04:46,380
means it doesn't depend on how many

00:04:43,710 --> 00:04:47,950
inputs we have at all orders of growth

00:04:46,380 --> 00:04:51,160
are a way of describe

00:04:47,950 --> 00:04:53,230
how does this algorithm scale as we

00:04:51,160 --> 00:04:55,480
throw more and more work at it does it

00:04:53,230 --> 00:04:57,070
scale well it does it scale poorly so if

00:04:55,480 --> 00:04:58,660
you have an algorithm to sort a list and

00:04:57,070 --> 00:05:00,550
I give you a list it's twice as large

00:04:58,660 --> 00:05:02,140
does it take you twice as long to sort

00:05:00,550 --> 00:05:04,810
it or less than twice as long or more

00:05:02,140 --> 00:05:08,470
than twice as long how does that scale

00:05:04,810 --> 00:05:10,240
and the thing that we really care about

00:05:08,470 --> 00:05:13,570
when we look at a diagram like this is

00:05:10,240 --> 00:05:14,680
how is it shaped you notice that these

00:05:13,570 --> 00:05:16,090
things are all shaped very differently

00:05:14,680 --> 00:05:18,820
these are all different orders of growth

00:05:16,090 --> 00:05:21,430
we have for example a linear growth here

00:05:18,820 --> 00:05:22,570
on the o-line we have we have some

00:05:21,430 --> 00:05:24,580
exponential growth we have some

00:05:22,570 --> 00:05:26,860
logarithmic growth and what makes these

00:05:24,580 --> 00:05:30,820
these each of these different is their

00:05:26,860 --> 00:05:33,010
shape we can get we can get involved in

00:05:30,820 --> 00:05:36,790
talking about how algorithms perform in

00:05:33,010 --> 00:05:38,830
absolute terms but when you graph these

00:05:36,790 --> 00:05:40,510
things the angle in the location are

00:05:38,830 --> 00:05:44,710
things that we ignore when we're talking

00:05:40,510 --> 00:05:47,440
about Big O so here's an example of ov1

00:05:44,710 --> 00:05:49,120
all of these lines are o of 1 now in

00:05:47,440 --> 00:05:51,940
absolute terms if you have an algorithm

00:05:49,120 --> 00:05:53,410
that performs like any of these these

00:05:51,940 --> 00:05:56,710
these differences may actually matter to

00:05:53,410 --> 00:05:58,810
you so on the x axis we have the number

00:05:56,710 --> 00:06:00,310
of inputs to this algorithm and the y

00:05:58,810 --> 00:06:02,260
axis we have how much work does the

00:06:00,310 --> 00:06:04,300
algorithm have to do if you're dealing

00:06:02,260 --> 00:06:05,770
with the blue line that's obviously much

00:06:04,300 --> 00:06:07,840
better than the red line you your your

00:06:05,770 --> 00:06:09,190
thing takes five steps instead of nine

00:06:07,840 --> 00:06:11,050
or something like that and you might

00:06:09,190 --> 00:06:13,780
want to optimize to try to do fewer

00:06:11,050 --> 00:06:16,330
steps to do less work but in terms of

00:06:13,780 --> 00:06:19,060
growth these are perfect because how

00:06:16,330 --> 00:06:20,590
they grow is they don't you throw more

00:06:19,060 --> 00:06:22,480
and more work at it and it just pretends

00:06:20,590 --> 00:06:27,040
like nothing happens it just continues

00:06:22,480 --> 00:06:28,660
to perform exactly as it has linear

00:06:27,040 --> 00:06:31,360
growth is something that basically is a

00:06:28,660 --> 00:06:33,370
straight line with slope now in absolute

00:06:31,360 --> 00:06:34,420
terms again these different curves you

00:06:33,370 --> 00:06:37,180
would care about the differences between

00:06:34,420 --> 00:06:41,380
them so the red one you have maybe one

00:06:37,180 --> 00:06:43,450
unit of work to do per unit of input the

00:06:41,380 --> 00:06:44,830
steeper line you have maybe five units

00:06:43,450 --> 00:06:46,480
of work or ten units of work to do per

00:06:44,830 --> 00:06:48,340
input if you could manage to optimize

00:06:46,480 --> 00:06:49,960
that so you can do eight steps instead

00:06:48,340 --> 00:06:53,350
of ten steps or two steps or whatever

00:06:49,960 --> 00:06:55,120
that would be great but in in Big O

00:06:53,350 --> 00:06:57,070
terms those differences are irrelevant

00:06:55,120 --> 00:06:59,230
because these are straight lines of

00:06:57,070 --> 00:07:00,880
slope again we've got a line that

00:06:59,230 --> 00:07:01,600
doesn't even intersect with zero zero

00:07:00,880 --> 00:07:04,570
that means

00:07:01,600 --> 00:07:06,580
even if you have no one input or is like

00:07:04,570 --> 00:07:07,780
at the minimum possible input so you

00:07:06,580 --> 00:07:09,310
have some amount of work to do maybe you

00:07:07,780 --> 00:07:10,090
have to boot the JVM to get started with

00:07:09,310 --> 00:07:12,310
whatever you're doing

00:07:10,090 --> 00:07:13,990
but again in big o terms that's

00:07:12,310 --> 00:07:15,280
irrelevant that's position we don't care

00:07:13,990 --> 00:07:20,530
about position and we don't care about

00:07:15,280 --> 00:07:22,360
angle we only care about shape now why

00:07:20,530 --> 00:07:24,430
does a stuff matter this stuff matters

00:07:22,360 --> 00:07:26,500
because if you think about how these

00:07:24,430 --> 00:07:27,700
graphs are going to extend out these

00:07:26,500 --> 00:07:29,920
these differences are only going to

00:07:27,700 --> 00:07:33,370
multiply and become larger and larger so

00:07:29,920 --> 00:07:35,110
a famous a famous algorithm that people

00:07:33,370 --> 00:07:37,060
talk about when they're talking about

00:07:35,110 --> 00:07:38,740
orders of growth is the Traveling

00:07:37,060 --> 00:07:39,880
Salesman problem you've probably heard

00:07:38,740 --> 00:07:42,340
the Traveling Salesman problem

00:07:39,880 --> 00:07:43,780
it's basically you've got a person who

00:07:42,340 --> 00:07:45,610
wants to visit a bunch of cities and

00:07:43,780 --> 00:07:47,470
they want to visit each city once and

00:07:45,610 --> 00:07:49,330
they want to come back home and you want

00:07:47,470 --> 00:07:52,450
to find the shortest path to do that

00:07:49,330 --> 00:07:54,700
so the brute force approach is you try

00:07:52,450 --> 00:07:56,080
every possible route and then you figure

00:07:54,700 --> 00:07:58,150
out how long each one of them takes and

00:07:56,080 --> 00:08:00,670
then you rank them and you return the

00:07:58,150 --> 00:08:03,730
talk result that that approach that

00:08:00,670 --> 00:08:05,830
brute force approach is in a Big O of n

00:08:03,730 --> 00:08:07,090
factorial which means if there's ten

00:08:05,830 --> 00:08:08,290
cities you have ten times nine times

00:08:07,090 --> 00:08:10,840
eight times seven all the way down to

00:08:08,290 --> 00:08:12,970
one steps to do if it's 100 cities you

00:08:10,840 --> 00:08:15,760
have 100 times 99 all the way down to 1

00:08:12,970 --> 00:08:18,730
steps to do so it grows very quickly

00:08:15,760 --> 00:08:21,550
it's very difficult for us as human

00:08:18,730 --> 00:08:23,340
beings to have in our minds what that

00:08:21,550 --> 00:08:27,040
kind of quick growth actually looks like

00:08:23,340 --> 00:08:28,360
so suppose you have a not you're doing

00:08:27,040 --> 00:08:31,930
this brute force approach and five

00:08:28,360 --> 00:08:33,099
cities takes you 0.12 seconds does

00:08:31,930 --> 00:08:34,660
anybody want to make a guess and I'm

00:08:33,099 --> 00:08:36,840
gonna make you look foolish probably how

00:08:34,660 --> 00:08:40,750
long it would take you to do 21 cities

00:08:36,840 --> 00:08:45,150
five cities is 0.12 seconds how long has

00:08:40,750 --> 00:08:45,150
21 cities anybody

00:08:47,540 --> 00:08:57,350
it's crazy 97 billion years it's crazy

00:08:54,519 --> 00:08:59,329
so it's really important to know if your

00:08:57,350 --> 00:09:01,190
algorithm is scaling and factorial

00:08:59,329 --> 00:09:02,980
because think about this maybe you work

00:09:01,190 --> 00:09:05,600
for a travel search site I happen to

00:09:02,980 --> 00:09:07,339
somebody says hey we got this great idea

00:09:05,600 --> 00:09:10,699
for a feature we're gonna help people

00:09:07,339 --> 00:09:13,790
plan their trips okay you can offer that

00:09:10,699 --> 00:09:15,440
feature for three cities you can offer

00:09:13,790 --> 00:09:16,940
that feature for five cities but don't

00:09:15,440 --> 00:09:18,170
try to offer it for ten because the

00:09:16,940 --> 00:09:20,269
person will have taken the trip and come

00:09:18,170 --> 00:09:22,519
home before you finish and don't try to

00:09:20,269 --> 00:09:24,380
offer it for 21 cities because your

00:09:22,519 --> 00:09:25,699
server farm will melt and you will be

00:09:24,380 --> 00:09:29,389
out of business and the Sun will burn

00:09:25,699 --> 00:09:32,120
out and you still won't be finished it's

00:09:29,389 --> 00:09:34,040
important to know what what Big O

00:09:32,120 --> 00:09:37,420
category your algorithm falls into and

00:09:34,040 --> 00:09:39,769
in the big idea here is in the long run

00:09:37,420 --> 00:09:42,050
it doesn't matter how high it is

00:09:39,769 --> 00:09:43,880
any o of one algorithm is going to beat

00:09:42,050 --> 00:09:45,560
the pants off of any o of n algorithm

00:09:43,880 --> 00:09:47,029
and any o of n algorithm is going to

00:09:45,560 --> 00:09:49,310
beat the pants off of any o of N squared

00:09:47,029 --> 00:09:50,509
algorithm so if you can optimize a

00:09:49,310 --> 00:09:52,730
little bit within the linear linear

00:09:50,509 --> 00:09:54,440
category that's good but if you can

00:09:52,730 --> 00:09:59,029
change categories from oh of n - o of

00:09:54,440 --> 00:10:00,589
one that's a huge huge win so what is

00:09:59,029 --> 00:10:03,350
our big goal problem here why is this

00:10:00,589 --> 00:10:06,319
big o of n well if you think about it it

00:10:03,350 --> 00:10:07,970
makes sense right I say to me I want the

00:10:06,319 --> 00:10:09,980
key cap well I have to go walking

00:10:07,970 --> 00:10:11,480
through every one of these inputs until

00:10:09,980 --> 00:10:13,519
I find one where the key is cap

00:10:11,480 --> 00:10:14,750
obviously if there's a thousand of those

00:10:13,519 --> 00:10:17,360
it's going to take me a lot longer and

00:10:14,750 --> 00:10:20,029
then if there's only three so we're

00:10:17,360 --> 00:10:21,649
scaling up this is going to take us

00:10:20,029 --> 00:10:24,410
longer depending on how many inputs we

00:10:21,649 --> 00:10:26,089
have this isn't good one of the great

00:10:24,410 --> 00:10:27,889
features of hashes is that they're over

00:10:26,089 --> 00:10:29,750
one it should be the case that no matter

00:10:27,889 --> 00:10:30,889
how many keys you have in there it takes

00:10:29,750 --> 00:10:34,339
you the same amount of time to look

00:10:30,889 --> 00:10:35,930
something up now this is a measurement I

00:10:34,339 --> 00:10:37,970
actually have built this tuple map class

00:10:35,930 --> 00:10:40,250
and I've done some measurements to show

00:10:37,970 --> 00:10:42,589
that in fact it does grow linearly so

00:10:40,250 --> 00:10:45,050
here I here what I've done on the x-axis

00:10:42,589 --> 00:10:46,939
you have large larger and larger sizes

00:10:45,050 --> 00:10:49,459
of hashes so on the you've got anywhere

00:10:46,939 --> 00:10:53,269
from 150 to somewhere like 14 and a half

00:10:49,459 --> 00:10:54,560
thousand keys in the hash and the way

00:10:53,269 --> 00:10:57,019
I've done this test is really simple

00:10:54,560 --> 00:11:00,710
basically I do a measurement round I do

00:10:57,019 --> 00:11:02,450
150 inserts and then I do 150 reads and

00:11:00,710 --> 00:11:05,690
I do another round and you can see it

00:11:02,450 --> 00:11:07,640
just grows like that so it does grow

00:11:05,690 --> 00:11:10,960
linearly this confirms basically what

00:11:07,640 --> 00:11:13,490
we've figured out by looking at the code

00:11:10,960 --> 00:11:14,600
so the question is how can we implement

00:11:13,490 --> 00:11:16,880
the internals of this thing in a way

00:11:14,600 --> 00:11:20,300
that's all fun what do we know that so

00:11:16,880 --> 00:11:22,220
of one that we can use well one thing

00:11:20,300 --> 00:11:24,650
that we know that's ov1 is a ray lookup

00:11:22,220 --> 00:11:27,440
by index so if I have an index like this

00:11:24,650 --> 00:11:29,750
and I say I want item 328 or if I say I

00:11:27,440 --> 00:11:31,100
want item five it's gonna take this name

00:11:29,750 --> 00:11:35,060
amount of time to look them up it's

00:11:31,100 --> 00:11:37,610
gonna be just like that okay but how the

00:11:35,060 --> 00:11:39,980
heck does that work well because Ram

00:11:37,610 --> 00:11:41,870
this is a which is where we get a little

00:11:39,980 --> 00:11:43,940
hand wavy about the details but RAM is

00:11:41,870 --> 00:11:46,040
random access memory and what that means

00:11:43,940 --> 00:11:47,690
is you can access any random place in

00:11:46,040 --> 00:11:48,950
the memory just as fast as you can

00:11:47,690 --> 00:11:50,540
access any other random place in the

00:11:48,950 --> 00:11:52,220
memory that's completely unlike a

00:11:50,540 --> 00:11:53,780
spinning disk right and a spinning disk

00:11:52,220 --> 00:11:54,980
if the data is over here and I'm over

00:11:53,780 --> 00:11:57,530
there it's going to take me a while to

00:11:54,980 --> 00:12:00,770
get to it Ram has this lovely feature

00:11:57,530 --> 00:12:02,750
and because it has this this can work

00:12:00,770 --> 00:12:04,490
really nicely because all we need to

00:12:02,750 --> 00:12:06,410
know is where is the thing in RAM that

00:12:04,490 --> 00:12:07,760
I'm looking for if I have the address I

00:12:06,410 --> 00:12:10,070
can ask Ram for it and it'll give it

00:12:07,760 --> 00:12:11,810
back to me instantly well in the same

00:12:10,070 --> 00:12:14,090
amount of time doesn't matter how long

00:12:11,810 --> 00:12:17,450
it takes what matters is that it always

00:12:14,090 --> 00:12:19,520
takes the same amount of time so the way

00:12:17,450 --> 00:12:21,140
that this can work is in Ruby Ruby knows

00:12:19,520 --> 00:12:23,960
where the beginning of your array is and

00:12:21,140 --> 00:12:25,730
it knows how wide each slot is because

00:12:23,960 --> 00:12:28,190
each slot is the width of one pointer in

00:12:25,730 --> 00:12:30,740
memory so they can say hey you're trying

00:12:28,190 --> 00:12:33,020
to go five slots in I can multiply five

00:12:30,740 --> 00:12:34,910
times the number of pointers I can

00:12:33,020 --> 00:12:36,440
multiply the pointer size times five and

00:12:34,910 --> 00:12:38,090
that's how far it is from the beginning

00:12:36,440 --> 00:12:40,540
of the array I can figure out the

00:12:38,090 --> 00:12:44,270
address in RAM and I can go right there

00:12:40,540 --> 00:12:47,600
so that's why access by index is going

00:12:44,270 --> 00:12:49,550
to work really nicely for us so let's

00:12:47,600 --> 00:12:53,180
make a new plan how can we make the guts

00:12:49,550 --> 00:12:54,860
of our hash depend on this it's going to

00:12:53,180 --> 00:12:56,960
have basically two parts we have a

00:12:54,860 --> 00:12:59,270
sparse array which is like this we have

00:12:56,960 --> 00:13:00,950
a bunch of blanks in it and then

00:12:59,270 --> 00:13:03,170
wherever we want to put some data we

00:13:00,950 --> 00:13:04,790
have data there and then we have a

00:13:03,170 --> 00:13:08,150
digest function to help us figure out

00:13:04,790 --> 00:13:10,490
where to put data so digest function is

00:13:08,150 --> 00:13:11,810
a way of taking some key that you want

00:13:10,490 --> 00:13:13,460
to store and turning it into a number

00:13:11,810 --> 00:13:13,960
because we need to know the position in

00:13:13,460 --> 00:13:16,240
our sparse

00:13:13,960 --> 00:13:18,280
great to store the value so you can

00:13:16,240 --> 00:13:19,930
think of a digest function sometimes

00:13:18,280 --> 00:13:21,370
these are called hash functions and that

00:13:19,930 --> 00:13:23,470
can be confusing because we have hashes

00:13:21,370 --> 00:13:24,880
and we have hash functions and Ruby very

00:13:23,470 --> 00:13:26,770
wisely generally calls this library

00:13:24,880 --> 00:13:28,780
digest which i think is a great name

00:13:26,770 --> 00:13:31,150
because it conveys what it does because

00:13:28,780 --> 00:13:33,400
just like digestion digestion czar one

00:13:31,150 --> 00:13:38,080
way you can't take poo and turn it back

00:13:33,400 --> 00:13:43,600
into pizza right or at least not the

00:13:38,080 --> 00:13:45,760
same pizza so we have a one-way function

00:13:43,600 --> 00:13:47,410
that's going to turn our string into a

00:13:45,760 --> 00:13:49,780
number and we need a number because we

00:13:47,410 --> 00:13:50,440
need to know in array position and if we

00:13:49,780 --> 00:13:52,180
can do this

00:13:50,440 --> 00:13:53,800
then we'll know exactly where to put it

00:13:52,180 --> 00:13:55,300
and somebody will come back and say hey

00:13:53,800 --> 00:13:57,160
I want the appetizer key and we'll say

00:13:55,300 --> 00:13:58,570
oh great I can turn that into two I can

00:13:57,160 --> 00:14:00,190
go straight to this position two in my

00:13:58,570 --> 00:14:06,640
array here you go there's your value

00:14:00,190 --> 00:14:09,850
that's gonna work beautifully right we

00:14:06,640 --> 00:14:12,610
have some problems our first problem is

00:14:09,850 --> 00:14:14,740
collisions when we do our hash function

00:14:12,610 --> 00:14:17,080
we have no way of guaranteeing

00:14:14,740 --> 00:14:20,020
that every key is gonna produce a unique

00:14:17,080 --> 00:14:22,510
value in fact it probably won't so we

00:14:20,020 --> 00:14:24,400
hash the appetizer we do a digest of the

00:14:22,510 --> 00:14:26,320
appetizer key and we do an ad I jest of

00:14:24,400 --> 00:14:28,540
the mammal key and oh no they both come

00:14:26,320 --> 00:14:32,890
out too - well what do we put in slot

00:14:28,540 --> 00:14:34,990
number two our solution is to have

00:14:32,890 --> 00:14:37,270
buckets so at slot number two we don't

00:14:34,990 --> 00:14:38,890
have a thing we have kind of our old

00:14:37,270 --> 00:14:42,040
familiar key value pairs like we talked

00:14:38,890 --> 00:14:43,360
about before which is nice because now

00:14:42,040 --> 00:14:44,440
we can put both things there we can

00:14:43,360 --> 00:14:46,420
figure out when we go to look for

00:14:44,440 --> 00:14:49,390
appetizer what is the actual correct

00:14:46,420 --> 00:14:50,770
value for it but you can see that that's

00:14:49,390 --> 00:14:52,240
going to sort of reintroduce the same

00:14:50,770 --> 00:14:53,290
problem right if we get to that bucket

00:14:52,240 --> 00:14:55,930
and we have to walk through all the

00:14:53,290 --> 00:15:00,430
things not so good we'll come back to

00:14:55,930 --> 00:15:01,900
that our second problem is waste sure

00:15:00,430 --> 00:15:04,060
it's great that we have this value in

00:15:01,900 --> 00:15:05,410
slot two here but we've got all these

00:15:04,060 --> 00:15:06,970
other Nils we're gonna have a lot of

00:15:05,410 --> 00:15:09,850
Nils just sitting around in memory doing

00:15:06,970 --> 00:15:11,740
us no good so what a waste of memory

00:15:09,850 --> 00:15:16,020
right we don't like that we want to be

00:15:11,740 --> 00:15:19,240
efficient our solution is get over it

00:15:16,020 --> 00:15:21,250
mostly mostly this is a crucial thing to

00:15:19,240 --> 00:15:22,900
see though hashes as they're really

00:15:21,250 --> 00:15:26,320
implemented in Ruby as they really work

00:15:22,900 --> 00:15:27,880
are a trade off we're trading off memory

00:15:26,320 --> 00:15:29,410
for speed we're saying we're

00:15:27,880 --> 00:15:31,270
to waste a bunch of memory on that

00:15:29,410 --> 00:15:36,100
sparse array so that we can get to the

00:15:31,270 --> 00:15:37,330
thing we want really quickly so is there

00:15:36,100 --> 00:15:39,700
a grand solution that we can come up

00:15:37,330 --> 00:15:41,170
with which minimizes collisions because

00:15:39,700 --> 00:15:42,670
the more collisions we have the more

00:15:41,170 --> 00:15:43,930
full that bucket is the more things we

00:15:42,670 --> 00:15:44,890
have to look through the worse the

00:15:43,930 --> 00:15:46,900
performance is we want to minimize

00:15:44,890 --> 00:15:49,810
collisions we also want to minimize

00:15:46,900 --> 00:15:52,960
wasted memory is there a grand solution

00:15:49,810 --> 00:15:54,850
for that yes our solution is going to be

00:15:52,960 --> 00:15:56,350
this we're going to grow as needed we're

00:15:54,850 --> 00:15:58,210
gonna say we're going to trade off some

00:15:56,350 --> 00:16:01,510
RAM so we can continue to have a good

00:15:58,210 --> 00:16:06,430
look up speed but not a lot and as we

00:16:01,510 --> 00:16:09,970
need to well trade off more what does it

00:16:06,430 --> 00:16:11,230
mean to to grow as needed well you can

00:16:09,970 --> 00:16:12,790
define this in a lot of different ways

00:16:11,230 --> 00:16:14,800
but I've chosen a really simple

00:16:12,790 --> 00:16:15,220
definition when any bucket has ten keys

00:16:14,800 --> 00:16:16,960
in it

00:16:15,220 --> 00:16:18,010
time to grow you do an insert I find

00:16:16,960 --> 00:16:20,410
that I'm putting it in a bucket that's

00:16:18,010 --> 00:16:24,490
already pretty full ten keys time to

00:16:20,410 --> 00:16:25,090
grow well what does it mean to grow this

00:16:24,490 --> 00:16:27,190
is crucial

00:16:25,090 --> 00:16:29,740
it's important that when we create our

00:16:27,190 --> 00:16:31,180
new sparse array we spread things out so

00:16:29,740 --> 00:16:33,430
on the Left we have the old situation

00:16:31,180 --> 00:16:35,140
where we have things piled up a lot that

00:16:33,430 --> 00:16:37,930
last bucket only has one I had a minute

00:16:35,140 --> 00:16:39,150
but every bucket has something and most

00:16:37,930 --> 00:16:41,500
of the buckets have more than one thing

00:16:39,150 --> 00:16:42,730
when we grow we want things to be spread

00:16:41,500 --> 00:16:44,650
out so that we have a bunch of spaces

00:16:42,730 --> 00:16:46,210
again and then we don't have many things

00:16:44,650 --> 00:16:47,890
that have more than one in it because

00:16:46,210 --> 00:16:52,570
otherwise we've just got the same old

00:16:47,890 --> 00:16:55,240
performance problem and another thing to

00:16:52,570 --> 00:16:57,580
see is that when we grow the way we do

00:16:55,240 --> 00:16:59,890
that is we have to go back through every

00:16:57,580 --> 00:17:02,920
key and rehash it and put it into the

00:16:59,890 --> 00:17:04,689
new larger sparse array it's going to be

00:17:02,920 --> 00:17:09,699
a matter of going through every single

00:17:04,689 --> 00:17:11,160
key so here's our basic strategy we're

00:17:09,699 --> 00:17:13,420
gonna start with X number of buckets

00:17:11,160 --> 00:17:14,920
we're gonna compute whatever key you

00:17:13,420 --> 00:17:17,170
give me I'm going to compute the raw

00:17:14,920 --> 00:17:18,910
digest value somehow I'm gonna get a

00:17:17,170 --> 00:17:20,860
number let's skip over that for right

00:17:18,910 --> 00:17:22,150
now and then we're gonna take whatever

00:17:20,860 --> 00:17:23,980
that number is and we're gonna do it

00:17:22,150 --> 00:17:25,980
modulus the number of buckets and then

00:17:23,980 --> 00:17:28,360
I'll tell us which bucket to put it in

00:17:25,980 --> 00:17:29,440
you probably all know what modulo is but

00:17:28,360 --> 00:17:30,850
I'm just gonna make sure you're all with

00:17:29,440 --> 00:17:34,360
me because I want you to be able to make

00:17:30,850 --> 00:17:35,830
a hash when you're done so modulo is

00:17:34,360 --> 00:17:37,900
just a way of saying divide by this

00:17:35,830 --> 00:17:39,490
number and take the remainder the nice

00:17:37,900 --> 00:17:40,870
thing about it is as you can see I can

00:17:39,490 --> 00:17:44,410
throw any of these numbers on the left

00:17:40,870 --> 00:17:47,110
and I always get one of three values so

00:17:44,410 --> 00:17:49,059
if I do this then any numeric value that

00:17:47,110 --> 00:17:51,190
I get I know it's going to end up giving

00:17:49,059 --> 00:17:54,100
me a valid erase lot in my sparse array

00:17:51,190 --> 00:17:56,559
if I have three slots now the other

00:17:54,100 --> 00:17:59,500
thing that I want is not only to pick a

00:17:56,559 --> 00:18:01,540
sparse array size that I can use but

00:17:59,500 --> 00:18:04,180
also to be able to make it so that when

00:18:01,540 --> 00:18:06,220
I grow things spread out again so if I

00:18:04,180 --> 00:18:07,780
were to grow from three to seven you can

00:18:06,220 --> 00:18:09,940
see as I do modulo one all these numbers

00:18:07,780 --> 00:18:11,290
three versus seven most of them don't

00:18:09,940 --> 00:18:12,790
come out the same and that's good

00:18:11,290 --> 00:18:14,260
because I don't want everything to just

00:18:12,790 --> 00:18:15,280
show up in the same slots again I want

00:18:14,260 --> 00:18:18,070
them to show up in different slots

00:18:15,280 --> 00:18:19,960
mostly so from three to seven would be a

00:18:18,070 --> 00:18:21,490
good way to grow but how can I

00:18:19,960 --> 00:18:23,830
generalize that I want to be able to

00:18:21,490 --> 00:18:26,470
always know hey if I'm at size blah and

00:18:23,830 --> 00:18:30,250
I need to grow what do I grow to what's

00:18:26,470 --> 00:18:32,440
my new size well the growth strategy

00:18:30,250 --> 00:18:34,120
that I picked and I'm I'm not going in a

00:18:32,440 --> 00:18:36,280
too much detail on this but is to double

00:18:34,120 --> 00:18:38,350
the size and find the next prime it's

00:18:36,280 --> 00:18:41,950
important to double the size because we

00:18:38,350 --> 00:18:43,150
want to we want to make sure that we we

00:18:41,950 --> 00:18:45,100
don't have to do this too often

00:18:43,150 --> 00:18:46,390
essentially and it's important for the

00:18:45,100 --> 00:18:50,160
number to be prime so that we don't

00:18:46,390 --> 00:18:50,160
rehash things to the same slots I

00:18:51,090 --> 00:18:57,610
skipped over this how do we get a raw

00:18:53,440 --> 00:19:00,460
digest value from a key now I own my own

00:18:57,610 --> 00:19:04,360
but let me just give you an idea of what

00:19:00,460 --> 00:19:05,890
the requirements are for this method it

00:19:04,360 --> 00:19:08,380
has to be able to convert any object to

00:19:05,890 --> 00:19:10,090
a number my first attempt was something

00:19:08,380 --> 00:19:11,200
that depended on strings I said I'll

00:19:10,090 --> 00:19:12,730
take this string and I'll convert it to

00:19:11,200 --> 00:19:13,780
Unicode code points which are numbers

00:19:12,730 --> 00:19:16,809
and then I'll smash them all together

00:19:13,780 --> 00:19:18,610
and hey look I got a number well but you

00:19:16,809 --> 00:19:21,910
have to be able to use arrays as keys in

00:19:18,610 --> 00:19:26,350
Ruby and really any object any object

00:19:21,910 --> 00:19:29,650
can be a key in Ruby all right well all

00:19:26,350 --> 00:19:31,240
objects have an object ID right so I

00:19:29,650 --> 00:19:33,850
could use an object ID but that's not

00:19:31,240 --> 00:19:35,590
going to work because I want to be able

00:19:33,850 --> 00:19:38,290
to set something with the string a and

00:19:35,590 --> 00:19:39,520
there's a different string a and I want

00:19:38,290 --> 00:19:41,350
to be able to get it out I don't have to

00:19:39,520 --> 00:19:42,610
save our reference to the key I use and

00:19:41,350 --> 00:19:45,940
use it again to get it back out that's

00:19:42,610 --> 00:19:48,100
silly I need to be able to have same

00:19:45,940 --> 00:19:51,040
value keys quote-unquote be

00:19:48,100 --> 00:19:53,560
interchangeable but what does that mean

00:19:51,040 --> 00:19:54,820
I mean I don't know what same value

00:19:53,560 --> 00:19:58,559
means for you

00:19:54,820 --> 00:20:03,009
same value is kind of a fuzzy concept

00:19:58,559 --> 00:20:04,539
right so I've got two people out of the

00:20:03,009 --> 00:20:06,489
people collection and I I put something

00:20:04,539 --> 00:20:08,619
into the hash with one of them and can I

00:20:06,489 --> 00:20:08,829
get it out with the other one heck if I

00:20:08,619 --> 00:20:13,119
know

00:20:08,829 --> 00:20:15,129
how do I know if two people are equal so

00:20:13,119 --> 00:20:15,969
the solution that really uses is to ask

00:20:15,129 --> 00:20:17,829
the object

00:20:15,969 --> 00:20:20,769
it's the objects job to tell you what

00:20:17,829 --> 00:20:22,209
objects it's equal to so every object in

00:20:20,769 --> 00:20:24,070
Ruby has a hash method in that hash

00:20:22,209 --> 00:20:27,190
method produces a number and these are

00:20:24,070 --> 00:20:30,129
just some examples and the contract that

00:20:27,190 --> 00:20:34,179
the hash method holds up is that hash

00:20:30,129 --> 00:20:35,799
and equal must agree so these two arrays

00:20:34,179 --> 00:20:37,509
are not the same object they don't have

00:20:35,799 --> 00:20:39,489
the same object ID but they are equal in

00:20:37,509 --> 00:20:41,649
value quote-unquote according to them

00:20:39,489 --> 00:20:43,929
and they also produce the same hash

00:20:41,649 --> 00:20:45,999
value so they uphold this contract now

00:20:43,929 --> 00:20:47,949
if you want to have some custom class of

00:20:45,999 --> 00:20:50,109
yours like person and you want to use

00:20:47,949 --> 00:20:51,669
those as array keys and you've decided

00:20:50,109 --> 00:20:52,899
for whatever reason that two people are

00:20:51,669 --> 00:20:54,969
equal if they have the same first and

00:20:52,899 --> 00:20:56,589
last name that's fine you can do that

00:20:54,969 --> 00:20:58,419
but if you want to use them as hash keys

00:20:56,589 --> 00:21:00,399
and you want it to work properly you

00:20:58,419 --> 00:21:02,139
have to define the hash method so that

00:21:00,399 --> 00:21:03,609
any two people that have the same first

00:21:02,139 --> 00:21:08,129
and last name will produce the same hash

00:21:03,609 --> 00:21:10,149
value just took me a while to figure out

00:21:08,129 --> 00:21:12,999
okay so here's a review of what we

00:21:10,149 --> 00:21:14,229
figured out so far we have to take the

00:21:12,999 --> 00:21:16,449
key and turn it into a number using the

00:21:14,229 --> 00:21:17,919
hash method we're gonna do modulo the

00:21:16,449 --> 00:21:19,359
number of available buckets and that'll

00:21:17,919 --> 00:21:23,499
tell us the index of the bucket we want

00:21:19,359 --> 00:21:26,499
to use we found out that growing

00:21:23,499 --> 00:21:27,999
produces fewer collisions and that helps

00:21:26,499 --> 00:21:30,399
us to be fast that helps us to maintain

00:21:27,999 --> 00:21:32,169
the speed that we have we've also found

00:21:30,399 --> 00:21:34,509
that growing means we use more memory as

00:21:32,169 --> 00:21:35,799
we as we grow our hash as needed we're

00:21:34,509 --> 00:21:40,059
eating more memory we're making that

00:21:35,799 --> 00:21:41,889
trade-off but in the course of this

00:21:40,059 --> 00:21:44,889
implementation our whole goal was to get

00:21:41,889 --> 00:21:46,899
a 1 performance so if I were to graph

00:21:44,889 --> 00:21:48,969
like I like a graph tuple map if I were

00:21:46,899 --> 00:21:50,799
to graph my new class hash map and say

00:21:48,969 --> 00:21:51,190
okay for lots of inserts for lots of

00:21:50,799 --> 00:21:54,489
reads

00:21:51,190 --> 00:21:56,649
I should see not a not a line that's

00:21:54,489 --> 00:21:58,539
increasing linearly but I should see a

00:21:56,649 --> 00:22:00,429
nice flat line right you should be able

00:21:58,539 --> 00:22:01,690
to say if I have a hash with a million

00:22:00,429 --> 00:22:03,339
keys in it or if I have a hash with 10

00:22:01,690 --> 00:22:04,569
keys in it I can read from it at the

00:22:03,339 --> 00:22:07,570
same speed I can write to it the same

00:22:04,569 --> 00:22:08,980
speed so did we get o of 1

00:22:07,570 --> 00:22:23,350
are you guys psyched to see the graph

00:22:08,980 --> 00:22:26,850
can you please give me a hand oh well um

00:22:23,350 --> 00:22:29,470
so this kind of looks good parts of it

00:22:26,850 --> 00:22:31,600
so let me explain what we're looking at

00:22:29,470 --> 00:22:34,090
here again on the bottom on the x-axis

00:22:31,600 --> 00:22:35,890
we have size of the hash right so we

00:22:34,090 --> 00:22:38,380
have anywhere from 100,000 entries to

00:22:35,890 --> 00:22:40,450
9.7 million entries I imagine most of

00:22:38,380 --> 00:22:42,400
your hashes don't have that many um

00:22:40,450 --> 00:22:44,080
and the bottom line is the number of

00:22:42,400 --> 00:22:46,450
reads so for a hundred thousand reads

00:22:44,080 --> 00:22:49,180
how long did it take and the upper line

00:22:46,450 --> 00:22:50,620
is for writes and you can see that no

00:22:49,180 --> 00:22:52,600
matter how big the hash is it takes

00:22:50,620 --> 00:22:55,990
about the same amount of time to do some

00:22:52,600 --> 00:22:57,810
reads so that's nice and then you can

00:22:55,990 --> 00:23:00,370
see on the on the line with the writes

00:22:57,810 --> 00:23:02,740
basically it stays flat right I mean

00:23:00,370 --> 00:23:04,090
over here we can do a bunch of writes

00:23:02,740 --> 00:23:07,390
just as fast as we did when we were

00:23:04,090 --> 00:23:10,390
really small we just have a few little

00:23:07,390 --> 00:23:12,450
issues there in the middle kind of some

00:23:10,390 --> 00:23:16,150
spike eNOS

00:23:12,450 --> 00:23:18,100
okay well let's let's think about what

00:23:16,150 --> 00:23:19,600
those spikes are those facts are when we

00:23:18,100 --> 00:23:21,340
redistribute right because every time we

00:23:19,600 --> 00:23:23,320
grow we said we have to go back through

00:23:21,340 --> 00:23:25,030
all of the keys that we have we have to

00:23:23,320 --> 00:23:26,920
rehash them to figure out where do they

00:23:25,030 --> 00:23:30,700
land in the new slot and the new sparse

00:23:26,920 --> 00:23:33,400
array okay so we expect to have some

00:23:30,700 --> 00:23:34,960
spikes what if we look at the native

00:23:33,400 --> 00:23:38,230
Ruby hash does it have this kind of

00:23:34,960 --> 00:23:40,750
signature and in its performance well in

00:23:38,230 --> 00:23:43,090
fact it does you can see that it stays

00:23:40,750 --> 00:23:46,330
pretty linearly as it grows but it also

00:23:43,090 --> 00:23:47,590
has some spikes and I expected it's

00:23:46,330 --> 00:23:51,150
doing exactly what we're doing it's

00:23:47,590 --> 00:23:54,670
redistributing as necessary okay well

00:23:51,150 --> 00:23:57,600
well how big were those spikes they went

00:23:54,670 --> 00:23:57,600
off the screen Oh

00:24:00,300 --> 00:24:07,809
forty-eight seconds out folks you don't

00:24:04,750 --> 00:24:09,640
want to use my hash in production I mean

00:24:07,809 --> 00:24:11,890
I doubt that you actually have hatches

00:24:09,640 --> 00:24:16,840
this big but still the native Ruby

00:24:11,890 --> 00:24:18,429
hashes is much nicer but look before we

00:24:16,840 --> 00:24:21,190
feel like we're failing at this task

00:24:18,429 --> 00:24:22,720
take a look at what we've got they both

00:24:21,190 --> 00:24:25,030
have pretty linear performance between

00:24:22,720 --> 00:24:26,350
the spikes and I are pretty yep sorry

00:24:25,030 --> 00:24:28,090
pretty much oh of one pretty flat

00:24:26,350 --> 00:24:29,770
performance between the spikes and the

00:24:28,090 --> 00:24:32,559
spikes themselves follow a linear

00:24:29,770 --> 00:24:33,730
pattern because every time you get to a

00:24:32,559 --> 00:24:36,940
point where you need to rehash you have

00:24:33,730 --> 00:24:39,190
them working used to deal with so you

00:24:36,940 --> 00:24:40,300
know in Big O terms this is about this

00:24:39,190 --> 00:24:43,809
is the same right we don't care about

00:24:40,300 --> 00:24:45,190
slope sure - look like this and the

00:24:43,809 --> 00:24:49,150
native ruby hat just looked like this

00:24:45,190 --> 00:24:53,110
but they're both linear so hey thumbs up

00:24:49,150 --> 00:24:54,610
and if we zoom in again like I said all

00:24:53,110 --> 00:24:59,170
of the parts in between the spikes are

00:24:54,610 --> 00:25:00,490
flat so what about those spikes can we

00:24:59,170 --> 00:25:03,880
call this over one performance or can't

00:25:00,490 --> 00:25:06,790
we well I'm gonna say it success and

00:25:03,880 --> 00:25:08,559
here's why because reads are always less

00:25:06,790 --> 00:25:11,470
than ten steps we never allow more than

00:25:08,559 --> 00:25:13,450
ten keys in a bucket so thumbs up that's

00:25:11,470 --> 00:25:14,530
o of one you might say oh that's it of

00:25:13,450 --> 00:25:17,050
ten no it's not

00:25:14,530 --> 00:25:18,970
that's a slope thing that's a position

00:25:17,050 --> 00:25:21,940
thing we only care about shape we call

00:25:18,970 --> 00:25:24,070
that o of one well right rights are also

00:25:21,940 --> 00:25:25,540
oval and they're also the same number of

00:25:24,070 --> 00:25:26,650
steps each time you got to do the hash

00:25:25,540 --> 00:25:29,290
you got to go to the position you got to

00:25:26,650 --> 00:25:31,240
write in the end except for if you

00:25:29,290 --> 00:25:33,250
happen to be unfortunate enough to do a

00:25:31,240 --> 00:25:36,850
write at a point when it realizes it

00:25:33,250 --> 00:25:40,679
needs to grow okay what about that

00:25:36,850 --> 00:25:43,150
growth well the growth does take n steps

00:25:40,679 --> 00:25:44,500
but the interesting thing is as it gets

00:25:43,150 --> 00:25:48,760
slower it also gets less frequent

00:25:44,500 --> 00:25:49,900
because we double each time so if you

00:25:48,760 --> 00:25:51,790
think about these things as little

00:25:49,900 --> 00:25:54,190
mountains that are like each mountain is

00:25:51,790 --> 00:25:56,080
taller than the last mountain it's also

00:25:54,190 --> 00:25:58,270
got a larger valley in between it and

00:25:56,080 --> 00:25:59,559
the previous mountain so if we take and

00:25:58,270 --> 00:26:02,920
squish those down into their valleys

00:25:59,559 --> 00:26:06,160
they end up the same so essentially the

00:26:02,920 --> 00:26:08,890
number of number of steps we have to do

00:26:06,160 --> 00:26:11,500
per insert on average stays the same

00:26:08,890 --> 00:26:12,090
this is called amortized analysis we're

00:26:11,500 --> 00:26:13,230
saying

00:26:12,090 --> 00:26:14,940
essentially like all the rights you're

00:26:13,230 --> 00:26:16,650
doing leading up to that spike you're

00:26:14,940 --> 00:26:18,270
kind of incurring some debt because

00:26:16,650 --> 00:26:21,270
eventually you're gonna have to rehash

00:26:18,270 --> 00:26:23,340
and then some unlucky it right causes it

00:26:21,270 --> 00:26:25,289
to actually do the rehashing and that

00:26:23,340 --> 00:26:27,360
pays off the dead but if you look at it

00:26:25,289 --> 00:26:29,429
in and in amortized terms if you spread

00:26:27,360 --> 00:26:31,970
it back out it actually ends up being on

00:26:29,429 --> 00:26:46,980
average the same and we call that of one

00:26:31,970 --> 00:26:49,890
whoo yay so I attached this to an email

00:26:46,980 --> 00:26:54,570
and I sent it off to the president and I

00:26:49,890 --> 00:26:55,740
was feeling very fine so as I said you

00:26:54,570 --> 00:26:58,289
wouldn't want to use this hash that I

00:26:55,740 --> 00:27:00,029
just built in production it's doesn't

00:26:58,289 --> 00:27:01,830
have the years and years of optimization

00:27:00,029 --> 00:27:04,020
that the native ruby hash has doesn't

00:27:01,830 --> 00:27:05,690
have the lovely code written in C so

00:27:04,020 --> 00:27:07,950
that the slope ends up being really low

00:27:05,690 --> 00:27:09,899
and we could figure out ways to optimize

00:27:07,950 --> 00:27:11,640
this right we could trade off more

00:27:09,899 --> 00:27:14,520
memory at a time so that the spikes come

00:27:11,640 --> 00:27:15,840
less often we could maybe rehash in a

00:27:14,520 --> 00:27:18,059
background thread or something crazy

00:27:15,840 --> 00:27:19,409
so say somebody does an insert we say we

00:27:18,059 --> 00:27:21,210
don't wanna make want to make them wait

00:27:19,409 --> 00:27:23,279
around on this so we'll just you know

00:27:21,210 --> 00:27:25,529
take the value and do our rehash and go

00:27:23,279 --> 00:27:27,690
elsewhere we could implement this in C

00:27:25,529 --> 00:27:29,279
so that it actually runs faster but

00:27:27,690 --> 00:27:31,049
again that's remember that's about

00:27:29,279 --> 00:27:35,730
optimizing slope not about optimizing

00:27:31,049 --> 00:27:37,230
shape and there are some applications of

00:27:35,730 --> 00:27:38,610
this you might think well this is really

00:27:37,230 --> 00:27:41,220
nice but I'm not gonna build my own hash

00:27:38,610 --> 00:27:44,250
so you know very interesting Nathan

00:27:41,220 --> 00:27:47,039
well the cool applications of this

00:27:44,250 --> 00:27:48,779
include one hashes are an o1 multi-tool

00:27:47,039 --> 00:27:50,159
there's all kinds of algorithmic

00:27:48,779 --> 00:27:53,399
problems that you may be tasked to solve

00:27:50,159 --> 00:27:55,470
where the answer is use a hash and the

00:27:53,399 --> 00:27:57,720
reason is because they perform so nicely

00:27:55,470 --> 00:28:00,510
so if someone asks you how to dupe a

00:27:57,720 --> 00:28:02,669
list then a great way to do that is to

00:28:00,510 --> 00:28:05,159
go through and take take each value and

00:28:02,669 --> 00:28:06,450
stick it in as a hash key because next

00:28:05,159 --> 00:28:07,740
time you get a value like that you'll be

00:28:06,450 --> 00:28:09,570
able to go and find out if it's in the

00:28:07,740 --> 00:28:10,830
hash very quickly there's all kinds of

00:28:09,570 --> 00:28:12,149
issues that you'll run into with

00:28:10,830 --> 00:28:14,220
algorithms that can be solved by using

00:28:12,149 --> 00:28:16,159
hashes they're a great great multi-tool

00:28:14,220 --> 00:28:19,230
and that's why we use them so often

00:28:16,159 --> 00:28:21,000
another thing is that all of these no

00:28:19,230 --> 00:28:23,520
sequel databases everybody's talking

00:28:21,000 --> 00:28:25,440
about these days some of them are what

00:28:23,520 --> 00:28:27,169
are called distributed hash tables

00:28:25,440 --> 00:28:30,059
and the same principles apply so

00:28:27,169 --> 00:28:32,940
dynamodb is like react and cassandra are

00:28:30,059 --> 00:28:34,169
distributed hash tables so the same kind

00:28:32,940 --> 00:28:36,840
of thing applies if you want to know

00:28:34,169 --> 00:28:38,909
what bucket do I find this in a K what

00:28:36,840 --> 00:28:40,110
server is this key located on they do

00:28:38,909 --> 00:28:41,909
the same sort of thing they take your

00:28:40,110 --> 00:28:43,379
key they hash it they say well that

00:28:41,909 --> 00:28:44,730
would be on server number seven and they

00:28:43,379 --> 00:28:47,909
go off and talk to server number seven

00:28:44,730 --> 00:28:49,980
and the same penalties apply as well so

00:28:47,909 --> 00:28:51,539
if you realize we've got more data than

00:28:49,980 --> 00:28:53,700
we can store on our on our existing

00:28:51,539 --> 00:28:55,649
servers and we need to add some servers

00:28:53,700 --> 00:28:57,419
well when you add something it has to

00:28:55,649 --> 00:28:59,100
rehash everything in your system and

00:28:57,419 --> 00:29:00,750
it's going to take a while so you might

00:28:59,100 --> 00:29:02,639
want to think do I want to add one

00:29:00,750 --> 00:29:05,250
server and pay the entire rehashing

00:29:02,639 --> 00:29:07,080
penalty or do I want to add 20 servers

00:29:05,250 --> 00:29:09,389
and pay the exact same rehashing penalty

00:29:07,080 --> 00:29:11,279
maybe we should add a bunch so

00:29:09,389 --> 00:29:15,659
understanding how these things work does

00:29:11,279 --> 00:29:18,000
have real-world application for you well

00:29:15,659 --> 00:29:21,049
I was thinking about all this stuff but

00:29:18,000 --> 00:29:23,370
I when I got another phone call

00:29:21,049 --> 00:29:25,710
President Obama called me up you said

00:29:23,370 --> 00:29:28,679
dude I thought you were gonna send me

00:29:25,710 --> 00:29:30,659
that hash I said what you talking about

00:29:28,679 --> 00:29:32,940
I sent you an email an hour ago he said

00:29:30,659 --> 00:29:35,519
no I I've been trying to call you look I

00:29:32,940 --> 00:29:38,399
got I got 10 missed calls I look at my

00:29:35,519 --> 00:29:40,740
outbox it's stuck in giraffe's I said

00:29:38,399 --> 00:29:44,480
I'm sorry mr. president I'll send it

00:29:40,740 --> 00:30:01,590
right away he said it it's too late

00:29:44,480 --> 00:30:02,090
alien terrorists blew up Seaworth it was

00:30:01,590 --> 00:30:05,480
all a dream

00:30:02,090 --> 00:30:05,480
thank you very much

00:30:40,700 --> 00:30:42,760

YouTube URL: https://www.youtube.com/watch?v=NMwyWBtSiGM


