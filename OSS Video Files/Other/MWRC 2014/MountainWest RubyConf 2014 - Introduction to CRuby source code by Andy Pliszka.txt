Title: MountainWest RubyConf 2014 - Introduction to CRuby source code by Andy Pliszka
Publication date: 2020-01-24
Playlist: MWRC 2014
Description: 
	Understanding of CRuby source code has profound effects on every Ruby developer. In my talk, I will show you how to build Ruby from source. I will explain how to install and configure your new Ruby build on Mac and Linux. I will walk you through CRuby source code and introduce you to a few of the most important CRuby files. I will show you how to hack CRuby and modify some of the fundament Ruby classes in C. I will demonstrate how to write complete Ruby classes in C. Finally, I will show you that CRuby code can run 100 times faster than Ruby code. I hope that this talk will inspire you to learn more about CRuby and hack it on your own.

Help us caption & translate this video!

http://amara.org/v/FG2i/
Captions: 
	00:00:24,920 --> 00:00:30,020
hello everyone my name is andy i work at

00:00:28,260 --> 00:00:31,920
pivotal labs in New York City and today

00:00:30,020 --> 00:00:35,130
I'm going to give you a gentle

00:00:31,920 --> 00:00:37,170
introduction to see Ruby source code so

00:00:35,130 --> 00:00:39,030
first I'm going to tell you what was my

00:00:37,170 --> 00:00:41,040
motivation for actually looking at see

00:00:39,030 --> 00:00:42,960
Ruby then I'm going to give you a quick

00:00:41,040 --> 00:00:45,150
overview of see Ruby folder structure

00:00:42,960 --> 00:00:49,410
and files and at the end we'll do some

00:00:45,150 --> 00:00:50,850
silver be hacking so one of the main

00:00:49,410 --> 00:00:52,199
reasons why you want to look at this see

00:00:50,850 --> 00:00:54,600
Ruby source code is to actually

00:00:52,199 --> 00:00:56,399
understand Ruby better I think if you do

00:00:54,600 --> 00:00:57,780
if you code in Ruby for a couple of

00:00:56,399 --> 00:01:00,239
years and you read that made a

00:00:57,780 --> 00:01:03,360
programming book or or you read a couple

00:01:00,239 --> 00:01:05,460
of blogs about the object model I think

00:01:03,360 --> 00:01:07,259
that this is not enough if you want to

00:01:05,460 --> 00:01:08,940
really understand how the objects work

00:01:07,259 --> 00:01:11,670
and how the meta meta programming works

00:01:08,940 --> 00:01:14,070
help for example singleton methods work

00:01:11,670 --> 00:01:15,990
the best way to learn about is actually

00:01:14,070 --> 00:01:17,490
look at the sea source code and of

00:01:15,990 --> 00:01:19,500
course if you want to you know learn

00:01:17,490 --> 00:01:20,940
more about garbage collection that's the

00:01:19,500 --> 00:01:24,210
only pretty much the only way you can

00:01:20,940 --> 00:01:26,220
learn about it another another good

00:01:24,210 --> 00:01:28,530
benefit of actually knowing see and

00:01:26,220 --> 00:01:30,900
knowing how to interface see with Ruby

00:01:28,530 --> 00:01:32,310
is to speed up your code i'm not i'm not

00:01:30,900 --> 00:01:34,080
telling that you should rewrite your web

00:01:32,310 --> 00:01:36,210
applications and see but what you should

00:01:34,080 --> 00:01:37,710
do is look profile your app and maybe

00:01:36,210 --> 00:01:40,110
there are really tight loops that you

00:01:37,710 --> 00:01:41,939
can actually rewrite and see and then

00:01:40,110 --> 00:01:44,880
you will realize that you can get 10 to

00:01:41,939 --> 00:01:47,790
50 times faster code and of course if

00:01:44,880 --> 00:01:50,189
you want to write Ruby extensions in C

00:01:47,790 --> 00:01:52,409
it's also there's a couple of examples

00:01:50,189 --> 00:01:55,860
of extensions like psych for example

00:01:52,409 --> 00:01:57,299
that you can use as reference and of

00:01:55,860 --> 00:02:00,479
course a lot of a lot of gems are

00:01:57,299 --> 00:02:02,880
actually Looby extensions and if you

00:02:00,479 --> 00:02:04,829
know Ruby and see you pretty much get

00:02:02,880 --> 00:02:06,750
the best of both worlds so you can get

00:02:04,829 --> 00:02:09,479
the Ruby productivity you can write your

00:02:06,750 --> 00:02:11,700
high level functions in Ruby but you can

00:02:09,479 --> 00:02:13,049
also the very tight loops in your code

00:02:11,700 --> 00:02:15,600
and all the other words you can actually

00:02:13,049 --> 00:02:17,820
write it and see and pretty much get the

00:02:15,600 --> 00:02:21,420
performance that's not possible in other

00:02:17,820 --> 00:02:23,100
languages like Python etc okay so so

00:02:21,420 --> 00:02:26,010
let's actually build our Ruby from from

00:02:23,100 --> 00:02:28,200
from scratch if you are using our vm r

00:02:26,010 --> 00:02:30,540
vm is using pretty i'm going to actually

00:02:28,200 --> 00:02:32,160
show you pretty much almost everything

00:02:30,540 --> 00:02:34,319
that our vm does behind the scenes

00:02:32,160 --> 00:02:36,840
because our vm has to build it from

00:02:34,319 --> 00:02:39,060
so as well so let's get started first

00:02:36,840 --> 00:02:41,099
thing you have to do is to get the

00:02:39,060 --> 00:02:44,040
source code so you basically check it

00:02:41,099 --> 00:02:46,469
out from github and then for these

00:02:44,040 --> 00:02:48,780
slides actually checked out a stable tag

00:02:46,469 --> 00:02:50,909
which is 247 this little bit older but

00:02:48,780 --> 00:02:52,799
just to make sure that when you do it at

00:02:50,909 --> 00:02:56,069
home you will get repeatable results

00:02:52,799 --> 00:02:57,540
please check out that tag next step is

00:02:56,069 --> 00:02:59,579
to actually configure the source code

00:02:57,540 --> 00:03:01,859
because this source code is it designed

00:02:59,579 --> 00:03:03,480
to run on multiple platforms so you have

00:03:01,859 --> 00:03:05,639
to configure it on the for the platform

00:03:03,480 --> 00:03:08,719
that you are running on in this case I

00:03:05,639 --> 00:03:11,280
have mac and i also have a linux example

00:03:08,719 --> 00:03:14,340
you also have to installed open SSL

00:03:11,280 --> 00:03:17,310
because it's required for rubygems then

00:03:14,340 --> 00:03:18,750
you run this out to config utility which

00:03:17,310 --> 00:03:20,939
will actually configure the source code

00:03:18,750 --> 00:03:22,230
for your hardware and the last thing

00:03:20,939 --> 00:03:24,000
that we are doing here is actually

00:03:22,230 --> 00:03:26,430
configure the Ruby source code to

00:03:24,000 --> 00:03:29,129
install into my Ruby folder in your home

00:03:26,430 --> 00:03:31,079
folder with disabled optimization the

00:03:29,129 --> 00:03:33,719
reason why we disable optimization is to

00:03:31,079 --> 00:03:35,699
make debugging easier and we set the

00:03:33,719 --> 00:03:36,780
debug flag to make sure that the bynars

00:03:35,699 --> 00:03:38,489
will actually include the bug

00:03:36,780 --> 00:03:39,959
information so when you run it and

00:03:38,489 --> 00:03:43,859
debugger you can get like line numbers

00:03:39,959 --> 00:03:46,259
etc this is what you should get when you

00:03:43,859 --> 00:03:48,120
run configure if you are linux the setup

00:03:46,259 --> 00:03:50,819
is pretty much exactly the same you

00:03:48,120 --> 00:03:53,609
install lips ssl def then you run out of

00:03:50,819 --> 00:03:56,159
config you specify my Ruby folder as

00:03:53,609 --> 00:03:59,449
your destination in that destination

00:03:56,159 --> 00:04:01,799
folder for your install disable

00:03:59,449 --> 00:04:03,479
optimization the debug flags are

00:04:01,799 --> 00:04:06,959
slightly different because Mac is using

00:04:03,479 --> 00:04:09,329
ll DB and on Linux you have gdb ok so

00:04:06,959 --> 00:04:11,400
after you configure your source code all

00:04:09,329 --> 00:04:14,129
you have to do is just run meg and this

00:04:11,400 --> 00:04:16,139
will compile all your file C files into

00:04:14,129 --> 00:04:18,719
object files and link them into binaries

00:04:16,139 --> 00:04:22,019
at this point the Ruby binary is

00:04:18,719 --> 00:04:24,509
actually built it's a good idea to run

00:04:22,019 --> 00:04:26,550
the unit test after you build your Ruby

00:04:24,509 --> 00:04:29,130
Ruby actually considerably actually

00:04:26,550 --> 00:04:31,409
comes around 14,000 tests so if you run

00:04:29,130 --> 00:04:32,699
make check it it was in a couple of

00:04:31,409 --> 00:04:35,039
minutes it will run through all the

00:04:32,699 --> 00:04:37,289
tests and they should be all green most

00:04:35,039 --> 00:04:38,909
of them should be green from my

00:04:37,289 --> 00:04:40,169
experience if you're going to get at the

00:04:38,909 --> 00:04:41,490
beginning when you're when you're

00:04:40,169 --> 00:04:43,289
starting if you're going to get couple

00:04:41,490 --> 00:04:44,880
of failures let's see two three just

00:04:43,289 --> 00:04:46,199
keep going don't worry about it if you

00:04:44,880 --> 00:04:47,430
have if you get a massive failure like

00:04:46,199 --> 00:04:47,670
thousands of tests are failing you

00:04:47,430 --> 00:04:49,380
should

00:04:47,670 --> 00:04:52,410
probably delete the folder and restart

00:04:49,380 --> 00:04:55,200
the process again so after you check

00:04:52,410 --> 00:04:57,600
your instantly or your Ruby bill that's

00:04:55,200 --> 00:05:00,120
green well it's time to install it and

00:04:57,600 --> 00:05:01,980
you install it by running make install

00:05:00,120 --> 00:05:04,110
and this will actually take all the

00:05:01,980 --> 00:05:06,090
binaries and put it in you can see it

00:05:04,110 --> 00:05:09,210
here it's copying it to my Ruby folder

00:05:06,090 --> 00:05:11,460
and it will also create the gem folder

00:05:09,210 --> 00:05:16,220
structure and it will install the basic

00:05:11,460 --> 00:05:19,770
gems like psych reg etc so at this point

00:05:16,220 --> 00:05:22,080
the Ruby is installed but you still have

00:05:19,770 --> 00:05:23,910
to inform the system where the binaries

00:05:22,080 --> 00:05:26,220
are and also you have to make sure that

00:05:23,910 --> 00:05:29,280
the gem gems are set up correctly so you

00:05:26,220 --> 00:05:31,800
just set up the path to point to my Ruby

00:05:29,280 --> 00:05:35,120
bin folder and you set up a gem home and

00:05:31,800 --> 00:05:37,980
gem path to also point to my Ruby folder

00:05:35,120 --> 00:05:39,930
ok so now everything is set up

00:05:37,980 --> 00:05:42,150
everything should be working so you can

00:05:39,930 --> 00:05:43,530
verify it by running which Ruby and this

00:05:42,150 --> 00:05:45,210
should actually tell you which binary

00:05:43,530 --> 00:05:47,610
will be used every time you run a ruby

00:05:45,210 --> 00:05:50,700
so it points here to my Ruby you can

00:05:47,610 --> 00:05:52,200
also test RB and if you if you are

00:05:50,700 --> 00:05:54,300
curious you can also raise an exception

00:05:52,200 --> 00:05:55,950
from from IRB and you will see that it's

00:05:54,300 --> 00:05:58,770
actually throwing exception from the

00:05:55,950 --> 00:06:03,210
binary in my Ruby folder another

00:05:58,770 --> 00:06:05,010
important fact important aspect of Ruby

00:06:03,210 --> 00:06:07,500
proper Ruby installation is a gem system

00:06:05,010 --> 00:06:09,450
right so to verify that everything is ok

00:06:07,500 --> 00:06:11,280
you should just run jamin and you should

00:06:09,450 --> 00:06:13,140
see that all those folders ready you

00:06:11,280 --> 00:06:15,540
should actually point to all those

00:06:13,140 --> 00:06:19,170
variables should point to my might be

00:06:15,540 --> 00:06:21,030
folder you can also check that there's

00:06:19,170 --> 00:06:22,740
only a few gems it's a clean system and

00:06:21,030 --> 00:06:26,730
you can even verify that there is a

00:06:22,740 --> 00:06:29,940
folder for all your gems ok so good test

00:06:26,730 --> 00:06:32,130
for any Ruby install right it's always

00:06:29,940 --> 00:06:34,770
install rails because it's so big and it

00:06:32,130 --> 00:06:36,840
has you know a lot of gems which

00:06:34,770 --> 00:06:39,420
actually require proper a serial be set

00:06:36,840 --> 00:06:41,520
up so if you install it and it's

00:06:39,420 --> 00:06:43,740
successful you pretty much pretty much

00:06:41,520 --> 00:06:45,600
you assure that the Ruby that we just

00:06:43,740 --> 00:06:49,200
build is almost exactly the same as the

00:06:45,600 --> 00:06:50,910
one that you will get from rpm and here

00:06:49,200 --> 00:06:52,410
is you know you can build an app and

00:06:50,910 --> 00:06:54,240
actually run this app so at this point

00:06:52,410 --> 00:06:57,660
you pretty much we pretty much build

00:06:54,240 --> 00:07:01,140
ruby from scratch we installed rails we

00:06:57,660 --> 00:07:01,449
create a new app and we even run that up

00:07:01,140 --> 00:07:04,960
you

00:07:01,449 --> 00:07:06,610
in our hour see Ruby if he has igloo be

00:07:04,960 --> 00:07:08,289
mine the setup is also easy if you want

00:07:06,610 --> 00:07:11,080
to use the new compiled version of Ruby

00:07:08,289 --> 00:07:12,849
you just specify the in SDK you specify

00:07:11,080 --> 00:07:16,449
the location of the binary under my tree

00:07:12,849 --> 00:07:18,610
folder okay so this completes level 1 we

00:07:16,449 --> 00:07:20,710
build our own version of Ruby we

00:07:18,610 --> 00:07:23,620
installed it and configure it we even

00:07:20,710 --> 00:07:25,150
get rails to work and it shouldn't take

00:07:23,620 --> 00:07:26,979
you longer than 30 minutes so in 30

00:07:25,150 --> 00:07:30,069
minutes you should be able to build your

00:07:26,979 --> 00:07:32,289
own version from scratch and pretty much

00:07:30,069 --> 00:07:34,120
that's what r vm does so this process

00:07:32,289 --> 00:07:36,069
not only allows you to build your own

00:07:34,120 --> 00:07:38,169
version of rubia but also allows you to

00:07:36,069 --> 00:07:42,370
understand better what r BN for other

00:07:38,169 --> 00:07:44,860
tools like that are doing okay so up to

00:07:42,370 --> 00:07:46,810
level 2 because we will be working with

00:07:44,860 --> 00:07:48,939
see it's a good idea to have a working

00:07:46,810 --> 00:07:50,439
debugger so there are multiple options

00:07:48,939 --> 00:07:52,899
that you can use so for example if you

00:07:50,439 --> 00:07:55,899
are on iOS then you can use ldb if you

00:07:52,899 --> 00:07:58,180
are on the linux you can use gdb you can

00:07:55,899 --> 00:07:59,949
even use xcode to debug your code for

00:07:58,180 --> 00:08:03,399
example here this is a simple example

00:07:59,949 --> 00:08:05,680
how would you debug a simple script so

00:08:03,399 --> 00:08:08,139
the point is not to debug the Ruby

00:08:05,680 --> 00:08:10,930
source code like hello hello world but

00:08:08,139 --> 00:08:13,360
it's the point is to actually debug the

00:08:10,930 --> 00:08:15,729
up case method so for example here with

00:08:13,360 --> 00:08:19,419
LL DB you specify the binary my Ruby

00:08:15,729 --> 00:08:22,779
binary and you pass the you know puts

00:08:19,419 --> 00:08:25,089
hello upcase script then when you start

00:08:22,779 --> 00:08:26,709
ldb you just set the breakpoint at the

00:08:25,089 --> 00:08:28,719
beginning of the string up paste

00:08:26,709 --> 00:08:30,639
function and then when you run it it

00:08:28,719 --> 00:08:32,769
should break like this so here's the in

00:08:30,639 --> 00:08:34,599
the frame you have the command and you

00:08:32,769 --> 00:08:36,819
can see here that actually broke at the

00:08:34,599 --> 00:08:39,579
beginning of the c function that gets

00:08:36,819 --> 00:08:45,010
called when you called up case from from

00:08:39,579 --> 00:08:47,829
ruby and if you prefer GUI debugging

00:08:45,010 --> 00:08:50,500
xcode also can be used so here for

00:08:47,829 --> 00:08:52,569
example we are debugging array array

00:08:50,500 --> 00:08:54,880
push so pretty much this book this gives

00:08:52,569 --> 00:09:00,339
you this gives you an opportunity to

00:08:54,880 --> 00:09:03,149
debug NEC function in the Ruby system ok

00:09:00,339 --> 00:09:08,529
so let's take a look at the source code

00:09:03,149 --> 00:09:11,740
so let me open my editor so here is my

00:09:08,529 --> 00:09:14,070
folder where I checked out when i use

00:09:11,740 --> 00:09:16,660
get help to check out the code

00:09:14,070 --> 00:09:18,519
there's a lot of folders you don't have

00:09:16,660 --> 00:09:20,709
to worry about any of them because most

00:09:18,519 --> 00:09:22,209
of the important files are actually in

00:09:20,709 --> 00:09:26,170
the root folder so for example this is

00:09:22,209 --> 00:09:29,620
the array this is the C implementation

00:09:26,170 --> 00:09:35,670
of the Ruby array there are there are

00:09:29,620 --> 00:09:35,670
also files like for example string sorry

00:09:38,610 --> 00:09:44,860
so there's also string implementation

00:09:41,110 --> 00:09:46,600
here there's also fixed numbs all the

00:09:44,860 --> 00:09:48,220
other classes that you are familiar with

00:09:46,600 --> 00:09:52,000
from your Ruby code are pretty much

00:09:48,220 --> 00:09:54,130
implemented here in C so when you are

00:09:52,000 --> 00:09:57,519
browsing through this code just

00:09:54,130 --> 00:10:00,190
concentrate your efforts on on the main

00:09:57,519 --> 00:10:01,870
folder there's only one folder that you

00:10:00,190 --> 00:10:05,110
can actually take a look at which is

00:10:01,870 --> 00:10:07,959
extension this is where all the defaults

00:10:05,110 --> 00:10:09,910
he'll be extensions live and it's a very

00:10:07,959 --> 00:10:11,950
good resource especially if you are

00:10:09,910 --> 00:10:14,200
thinking about writing your own see

00:10:11,950 --> 00:10:16,959
extension gems so for example we have

00:10:14,200 --> 00:10:23,680
psych there I also put a couple of mine

00:10:16,959 --> 00:10:26,410
extensions there syslog etc so it's a

00:10:23,680 --> 00:10:29,110
good place to actually do some browsing

00:10:26,410 --> 00:10:31,600
of the code so let's take a look at a

00:10:29,110 --> 00:10:33,579
couple of important Ruby classes for

00:10:31,600 --> 00:10:37,120
example array what you will notice that

00:10:33,579 --> 00:10:40,420
pretty much every every C file that

00:10:37,120 --> 00:10:42,670
implements that provides implementation

00:10:40,420 --> 00:10:45,610
of a ruby class like for example here

00:10:42,670 --> 00:10:47,140
array always has this init function and

00:10:45,610 --> 00:10:48,880
this is the this is the function that

00:10:47,140 --> 00:10:52,480
gets called to initialize when the class

00:10:48,880 --> 00:10:55,870
is loaded and then it's not really scary

00:10:52,480 --> 00:10:57,640
to the sec code because i found found

00:10:55,870 --> 00:11:00,310
that see Ruby source code is actually

00:10:57,640 --> 00:11:02,890
probably did the best formatted C code

00:11:00,310 --> 00:11:04,930
that I have ever seen because it's very

00:11:02,890 --> 00:11:07,120
easy to read and if you know Ruby

00:11:04,930 --> 00:11:08,589
already you will be at home you will

00:11:07,120 --> 00:11:10,120
just understand it in a couple of

00:11:08,589 --> 00:11:12,100
minutes so for example here let's take a

00:11:10,120 --> 00:11:14,980
look how the array class is defined

00:11:12,100 --> 00:11:17,740
right so here you can see that we we

00:11:14,980 --> 00:11:19,480
call this function Ruby defined class we

00:11:17,740 --> 00:11:21,699
pass in the name of the class which is

00:11:19,480 --> 00:11:23,410
array and we just passed the object the

00:11:21,699 --> 00:11:25,329
class that inherits from in this case

00:11:23,410 --> 00:11:27,939
it's an object which is equivalent to

00:11:25,329 --> 00:11:32,859
whatever you see there in in in the car

00:11:27,939 --> 00:11:35,439
which is class array then you can see

00:11:32,859 --> 00:11:37,720
here that to include a module into it in

00:11:35,439 --> 00:11:40,329
a class you just call this Ruby include

00:11:37,720 --> 00:11:42,549
module you pass in the reference to the

00:11:40,329 --> 00:11:45,189
class and you specify the reference the

00:11:42,549 --> 00:11:46,929
module then there is the a lock function

00:11:45,189 --> 00:11:49,029
which is responsible for actually

00:11:46,929 --> 00:11:52,659
allocating the memory for new objects

00:11:49,029 --> 00:11:55,839
this is the only difference that that is

00:11:52,659 --> 00:11:59,079
is there before between Ruby and the

00:11:55,839 --> 00:12:00,909
c-in-c the actual creation of an object

00:11:59,079 --> 00:12:03,729
is two-step process first allocation of

00:12:00,909 --> 00:12:05,619
memory and then construction in Ruby we

00:12:03,729 --> 00:12:07,329
when you call new it pretty much that

00:12:05,619 --> 00:12:10,569
those two steps are combined into one

00:12:07,329 --> 00:12:11,739
and for example as I mentioned before if

00:12:10,569 --> 00:12:13,869
you're interested in meta programming

00:12:11,739 --> 00:12:16,169
you will think find things here like for

00:12:13,869 --> 00:12:18,939
example define singleton method right

00:12:16,169 --> 00:12:21,309
which is you know when you when you read

00:12:18,939 --> 00:12:24,519
about those methods etc this is a really

00:12:21,309 --> 00:12:26,169
good place to actually see actual

00:12:24,519 --> 00:12:29,049
implementation so it's not that it's

00:12:26,169 --> 00:12:31,449
it's no longer abstract and if you if

00:12:29,049 --> 00:12:33,519
you define methods you use this Ruby

00:12:31,449 --> 00:12:37,409
define method and here for example we

00:12:33,519 --> 00:12:41,349
define a constructor on on an array

00:12:37,409 --> 00:12:45,239
let's take a look at one more class so

00:12:41,349 --> 00:12:47,470
stick like a string so here is string

00:12:45,239 --> 00:12:49,509
you see that at the bottom of the file

00:12:47,470 --> 00:12:51,789
just exactly the same pattern you have

00:12:49,509 --> 00:12:53,019
init function for string and the

00:12:51,789 --> 00:12:55,839
definition of the class is almost

00:12:53,019 --> 00:12:57,819
identical so you define a class give it

00:12:55,839 --> 00:13:00,519
its name it inherits from from Ruby

00:12:57,819 --> 00:13:02,470
object it includes compatible module it

00:13:00,519 --> 00:13:05,079
has analogue function it has a single

00:13:02,470 --> 00:13:06,789
method try convert and then you have

00:13:05,079 --> 00:13:12,669
definitions of of them of all the

00:13:06,789 --> 00:13:15,729
methods ok ok so that's the folder

00:13:12,669 --> 00:13:18,549
structure I'll show you a fixed now in a

00:13:15,729 --> 00:13:20,949
second I already showed you string so

00:13:18,549 --> 00:13:22,809
they are very similar of course there

00:13:20,949 --> 00:13:24,519
are foxit c will be files that for

00:13:22,809 --> 00:13:25,959
example the garbage collection or

00:13:24,519 --> 00:13:27,549
actually creation of the objects that

00:13:25,959 --> 00:13:28,779
are more complicated but at the

00:13:27,549 --> 00:13:32,259
beginning you don't have to look at them

00:13:28,779 --> 00:13:34,449
at all ok so how do you define a method

00:13:32,259 --> 00:13:36,579
in see Ruby it's actually two step

00:13:34,449 --> 00:13:38,649
process and it's very easy all you have

00:13:36,579 --> 00:13:40,479
to do is define call this define method

00:13:38,649 --> 00:13:41,710
which is a helper see Ruby helper method

00:13:40,479 --> 00:13:43,180
you specify the

00:13:41,710 --> 00:13:45,940
reference to the class that you are

00:13:43,180 --> 00:13:47,860
redefining you specify the name of the

00:13:45,940 --> 00:13:50,230
function that it will actually call it

00:13:47,860 --> 00:13:52,300
in your Ruby code then you provide the

00:13:50,230 --> 00:13:54,850
implementation of the method a number of

00:13:52,300 --> 00:13:56,230
extra arguments the reason the reason

00:13:54,850 --> 00:13:57,730
I'm saying number of extra arguments

00:13:56,230 --> 00:14:01,480
because the every method has at least

00:13:57,730 --> 00:14:03,490
one argument which is the reference to

00:14:01,480 --> 00:14:06,280
self to the object that you are calling

00:14:03,490 --> 00:14:08,800
the method on so for example here we

00:14:06,280 --> 00:14:11,260
have implementation of the array length

00:14:08,800 --> 00:14:13,240
function so it returns the value every

00:14:11,260 --> 00:14:16,260
time you see a value think about it as

00:14:13,240 --> 00:14:19,630
it's a reference to an object so this

00:14:16,260 --> 00:14:23,380
this method returns you know reference

00:14:19,630 --> 00:14:25,990
to fix them and it takes itself which is

00:14:23,380 --> 00:14:29,800
the this of the self of the array and

00:14:25,990 --> 00:14:32,980
then converts a long value into Ruby

00:14:29,800 --> 00:14:34,360
numeric a class definition is also a

00:14:32,980 --> 00:14:37,120
little bit more complicated but it's

00:14:34,360 --> 00:14:39,130
also fairly easy and I already told you

00:14:37,120 --> 00:14:41,080
about it for a couple of a couple of

00:14:39,130 --> 00:14:43,300
those tests that have to be taken here

00:14:41,080 --> 00:14:46,000
so for example you always have to define

00:14:43,300 --> 00:14:48,730
the init method the first step is to

00:14:46,000 --> 00:14:50,890
create the defining class which are

00:14:48,730 --> 00:14:53,620
which class inherits from you need to

00:14:50,890 --> 00:14:55,330
define the allocation function and you

00:14:53,620 --> 00:14:57,640
also need to define a constructor and

00:14:55,330 --> 00:15:01,540
then you have the definition of all the

00:14:57,640 --> 00:15:04,420
classes all the methods okay so when you

00:15:01,540 --> 00:15:05,950
are working with see Ruby and rube you

00:15:04,420 --> 00:15:09,910
have to remember there are two very

00:15:05,950 --> 00:15:13,000
distinct worlds which is C and Ruby so

00:15:09,910 --> 00:15:14,710
for example in c you work directly with

00:15:13,000 --> 00:15:17,650
memory so you you're working with

00:15:14,710 --> 00:15:19,390
addresses in memory and you allocate and

00:15:17,650 --> 00:15:22,630
free all your memory using malloc and

00:15:19,390 --> 00:15:24,190
free so you're responsible for for all

00:15:22,630 --> 00:15:26,440
the memory allocation when you're

00:15:24,190 --> 00:15:28,240
working in Ruby well you are working

00:15:26,440 --> 00:15:30,280
with heap and objects and all the memory

00:15:28,240 --> 00:15:33,340
allocation is taking care care for you

00:15:30,280 --> 00:15:35,290
using garbage collection it's important

00:15:33,340 --> 00:15:37,600
to understand always in which world you

00:15:35,290 --> 00:15:40,600
are in because every time you cross the

00:15:37,600 --> 00:15:42,700
boundary from C to Ruby or vice versa

00:15:40,600 --> 00:15:44,560
you have to convert because they have

00:15:42,700 --> 00:15:46,420
completely distinct complete different

00:15:44,560 --> 00:15:50,200
type systems so for example if you are

00:15:46,420 --> 00:15:52,330
calling calling IC c method for a c

00:15:50,200 --> 00:15:54,370
function from from ruby you have to

00:15:52,330 --> 00:15:54,880
convert fixed nom in too long for

00:15:54,370 --> 00:15:57,730
example

00:15:54,880 --> 00:16:00,910
and for that you use this num too long

00:15:57,730 --> 00:16:03,160
macro and if you're going back from sea

00:16:00,910 --> 00:16:05,500
to Ruby for example when you return a

00:16:03,160 --> 00:16:07,300
value let's say length of an array what

00:16:05,500 --> 00:16:11,440
you have to convert it back from long to

00:16:07,300 --> 00:16:12,970
numb okay so this completes level three

00:16:11,440 --> 00:16:14,890
which is I showed you the folder

00:16:12,970 --> 00:16:17,320
structure we now know how to define a

00:16:14,890 --> 00:16:19,840
method how to define a class and how to

00:16:17,320 --> 00:16:23,590
actually convert the ties between C and

00:16:19,840 --> 00:16:27,820
Ruby so let's actually do a couple of a

00:16:23,590 --> 00:16:30,340
couple of interesting things like for

00:16:27,820 --> 00:16:31,930
example adding a fixnum if it'd been

00:16:30,340 --> 00:16:33,820
actually if you can actually a function

00:16:31,930 --> 00:16:35,290
to a fix them so this is how we would

00:16:33,820 --> 00:16:37,810
implement it in Ruby right it would open

00:16:35,290 --> 00:16:40,120
the fixnum fix num class and you will

00:16:37,810 --> 00:16:43,540
define this function and this is an

00:16:40,120 --> 00:16:46,150
example of pure see Fibonacci function

00:16:43,540 --> 00:16:48,190
the promise you cannot really use it

00:16:46,150 --> 00:16:51,820
that directly you have to massage it so

00:16:48,190 --> 00:16:56,020
it's it's it it it complies with see

00:16:51,820 --> 00:16:57,820
Ruby a convention so for example usually

00:16:56,020 --> 00:16:59,650
you have to only change three or four

00:16:57,820 --> 00:17:00,660
things which is you definitely have to

00:16:59,650 --> 00:17:03,760
change the signature of the method

00:17:00,660 --> 00:17:05,500
because instead of returning see long

00:17:03,760 --> 00:17:08,020
time we have to make sure that it

00:17:05,500 --> 00:17:09,640
actually turns an object and also have

00:17:08,020 --> 00:17:11,920
to make sure that you have to make sure

00:17:09,640 --> 00:17:14,680
that it actually takes a reference to

00:17:11,920 --> 00:17:16,689
self which is value which is reference

00:17:14,680 --> 00:17:20,470
to an object and then every time you

00:17:16,689 --> 00:17:22,030
access any object in Ruby in your C code

00:17:20,470 --> 00:17:23,560
you have to convert it using those

00:17:22,030 --> 00:17:25,810
macros that I showed you is 2 slides

00:17:23,560 --> 00:17:28,030
before and then at the end when you are

00:17:25,810 --> 00:17:30,640
returning every time you return any

00:17:28,030 --> 00:17:32,650
value from C to Ruby you also have to

00:17:30,640 --> 00:17:37,920
convert it to an object and then you

00:17:32,650 --> 00:17:40,450
define this dysfunction and and

00:17:37,920 --> 00:17:42,220
obviously the great benefit of doing

00:17:40,450 --> 00:17:44,350
this is actually understanding how see

00:17:42,220 --> 00:17:46,360
Ruby works another benefit is actually

00:17:44,350 --> 00:17:50,710
speed so for example in this case

00:17:46,360 --> 00:17:53,920
running eight fifth fib 80 million times

00:17:50,710 --> 00:17:56,650
in Ruby it takes 30 seconds and if you

00:17:53,920 --> 00:17:59,080
do it directly in see it takes less than

00:17:56,650 --> 00:18:01,450
a second so so see your C code is pretty

00:17:59,080 --> 00:18:04,240
much 30 times faster and I think if you

00:18:01,450 --> 00:18:05,860
compare those two functions there's not

00:18:04,240 --> 00:18:08,620
really a lot that you have to rewrite

00:18:05,860 --> 00:18:10,630
and that that's true for almost any

00:18:08,620 --> 00:18:12,100
and there is a down the road i'm going

00:18:10,630 --> 00:18:16,360
to show you that you can even use

00:18:12,100 --> 00:18:18,160
directly algorithm from from see Ruby

00:18:16,360 --> 00:18:20,830
directly you can use directly see

00:18:18,160 --> 00:18:23,440
algorithms from see Ruby by simply using

00:18:20,830 --> 00:18:26,320
an adapter function okay let me show you

00:18:23,440 --> 00:18:29,860
a quick demo of this how this works so

00:18:26,320 --> 00:18:32,020
for example here let me open the file

00:18:29,860 --> 00:18:37,960
it's called numeric and that's where

00:18:32,020 --> 00:18:40,570
fixnum is actually implemented okay so

00:18:37,960 --> 00:18:42,460
this is the definition of fixham another

00:18:40,570 --> 00:18:45,520
another great thing about actually doing

00:18:42,460 --> 00:18:48,190
this because you can use this this is

00:18:45,520 --> 00:18:49,960
this ebuild of Ruby to actually run your

00:18:48,190 --> 00:18:51,700
production the production apps or you're

00:18:49,960 --> 00:18:54,370
like development apps what you can do

00:18:51,700 --> 00:18:56,050
you can actually play pranks on your

00:18:54,370 --> 00:18:59,440
friends so for example what it can do

00:18:56,050 --> 00:19:03,340
you can just replace plus with minus and

00:18:59,440 --> 00:19:05,710
then build it and you know even people

00:19:03,340 --> 00:19:10,630
with master degrees have hard time

00:19:05,710 --> 00:19:12,309
figuring this out and obviously you know

00:19:10,630 --> 00:19:15,250
possibilities are endless you can do it

00:19:12,309 --> 00:19:17,320
like reverse rings etc up case or for

00:19:15,250 --> 00:19:21,929
example you can up peace but only every

00:19:17,320 --> 00:19:24,520
other string which is also interesting

00:19:21,929 --> 00:19:27,960
let me just go back before I go crazy

00:19:24,520 --> 00:19:31,210
okay cool so we were talking about fib

00:19:27,960 --> 00:19:34,090
so I'm going to go and find c-flip here

00:19:31,210 --> 00:19:36,820
so here's my implementation of fib right

00:19:34,090 --> 00:19:38,530
so this is how I define that method I'm

00:19:36,820 --> 00:19:40,900
going to call it with using see fit to

00:19:38,530 --> 00:19:48,880
indicate that the c function in my Ruby

00:19:40,900 --> 00:19:51,100
code and then this is three seconds this

00:19:48,880 --> 00:19:53,080
is the actual functions is very bad and

00:19:51,100 --> 00:19:55,450
copy from the slides so it's that easy

00:19:53,080 --> 00:19:57,880
you literally have to put in 15 lines of

00:19:55,450 --> 00:19:59,410
code in your in your see Ruby source

00:19:57,880 --> 00:20:01,179
code and you can start playing with it

00:19:59,410 --> 00:20:03,220
and hacking it with its it's a great

00:20:01,179 --> 00:20:07,150
it's a great way to learn more about

00:20:03,220 --> 00:20:10,840
Ruby and now if I control Z from here

00:20:07,150 --> 00:20:12,610
and if I actually so after you change

00:20:10,840 --> 00:20:17,890
the C files all you have to do is make

00:20:12,610 --> 00:20:20,380
and make install its prey fast so we can

00:20:17,890 --> 00:20:22,570
do it here whoops okay I think I made a

00:20:20,380 --> 00:20:24,340
mistake somewhere in the

00:20:22,570 --> 00:20:25,720
I probably have a typo on the code it's

00:20:24,340 --> 00:20:29,559
fine i already have it installed so for

00:20:25,720 --> 00:20:32,380
example here I RB 1 which is fixed an

00:20:29,559 --> 00:20:35,980
answer sir should have C fib yeah there

00:20:32,380 --> 00:20:38,019
you go so for example fib ad there you

00:20:35,980 --> 00:20:40,210
go so it's already I don't have to

00:20:38,019 --> 00:20:43,720
include any gems is that it's directly

00:20:40,210 --> 00:20:45,370
combat compiled into see Ruby of course

00:20:43,720 --> 00:20:46,779
it's not a good good idea to do it in

00:20:45,370 --> 00:20:48,880
production but when you're experimenting

00:20:46,779 --> 00:20:50,620
and you're trying to figure out

00:20:48,880 --> 00:20:53,440
functionality that later on you can

00:20:50,620 --> 00:20:56,139
extract into a gem it's a great way a

00:20:53,440 --> 00:21:00,100
great way to do it okay that's another

00:20:56,139 --> 00:21:01,659
example which is fixed on prime so just

00:21:00,100 --> 00:21:03,820
to reiterate what we have done right

00:21:01,659 --> 00:21:05,470
this is how you would do it in Ruby and

00:21:03,820 --> 00:21:07,600
this is how you would do it in see this

00:21:05,470 --> 00:21:09,129
is see Ruby already version said yet

00:21:07,600 --> 00:21:10,659
again it returns value which is a

00:21:09,129 --> 00:21:13,960
reference to an object it takes

00:21:10,659 --> 00:21:17,259
reference to self we do conversions from

00:21:13,960 --> 00:21:19,419
Ruby to see see types and here we are

00:21:17,259 --> 00:21:21,730
actually using constants q false and Q

00:21:19,419 --> 00:21:25,960
true are just basically single single

00:21:21,730 --> 00:21:28,779
single single photons to Ruby false and

00:21:25,960 --> 00:21:31,990
true and this is how we bind them to fix

00:21:28,779 --> 00:21:35,200
them and yet again like you know this is

00:21:31,990 --> 00:21:39,129
more easy easy comparison so if you do

00:21:35,200 --> 00:21:41,379
it in in Ruby it takes 30 seconds if you

00:21:39,129 --> 00:21:45,480
rewrite it in see Ruby it takes less

00:21:41,379 --> 00:21:47,919
than 22 seconds see Ruby 17 times faster

00:21:45,480 --> 00:21:49,299
okay so this is another example which is

00:21:47,919 --> 00:21:52,659
actually going a little bit farther so

00:21:49,299 --> 00:21:54,879
how about actually building a completely

00:21:52,659 --> 00:21:57,279
new class from scratch right for example

00:21:54,879 --> 00:22:00,009
Ruby arrays a very generic so they have

00:21:57,279 --> 00:22:01,269
to work with any type and they also have

00:22:00,009 --> 00:22:04,779
to work with mixed types you can have

00:22:01,269 --> 00:22:06,549
strings and and and in numbers in in

00:22:04,779 --> 00:22:09,399
them but what if you would know a priori

00:22:06,549 --> 00:22:11,529
that that all you have to do is you are

00:22:09,399 --> 00:22:14,019
storing numbers well you can make

00:22:11,529 --> 00:22:15,940
certain assumptions and make your code

00:22:14,019 --> 00:22:17,860
much much it make your algorithm much

00:22:15,940 --> 00:22:20,649
faster so in this case if you are

00:22:17,860 --> 00:22:23,769
storing lungs well you can create a

00:22:20,649 --> 00:22:25,659
simple C longer ray so you define a

00:22:23,769 --> 00:22:28,419
class you give it a name it inherits

00:22:25,659 --> 00:22:31,690
from an object we define a location

00:22:28,419 --> 00:22:33,490
function we define the constructor we

00:22:31,690 --> 00:22:36,400
define quicksort on it just just an

00:22:33,490 --> 00:22:38,170
example and we define the

00:22:36,400 --> 00:22:41,200
square brackets for accessing and

00:22:38,170 --> 00:22:43,570
setting elements of the array so this is

00:22:41,200 --> 00:22:45,580
the alar function this this is the

00:22:43,570 --> 00:22:47,470
function actually allocates memory for

00:22:45,580 --> 00:22:51,670
your for your object so here we use data

00:22:47,470 --> 00:22:54,190
max truck which is a method provided by

00:22:51,670 --> 00:22:56,530
see Ruby it will actually allocate

00:22:54,190 --> 00:22:58,330
enough memory for your see data

00:22:56,530 --> 00:22:59,260
structures enough memory to actually

00:22:58,330 --> 00:23:03,160
allocate them and it will give you

00:22:59,260 --> 00:23:05,290
actual reference to them when you call

00:23:03,160 --> 00:23:07,090
new 10 that a lock function will be

00:23:05,290 --> 00:23:09,130
called and also this initialize function

00:23:07,090 --> 00:23:12,190
because we specified that it is the

00:23:09,130 --> 00:23:14,170
initializer and here we pass you know it

00:23:12,190 --> 00:23:17,140
here you can see that it actually takes

00:23:14,170 --> 00:23:19,420
one argument that's this argument the

00:23:17,140 --> 00:23:21,460
size of the array and here first thing

00:23:19,420 --> 00:23:23,290
that we do we have to get remember that

00:23:21,460 --> 00:23:25,840
and see you always work with pointers to

00:23:23,290 --> 00:23:28,450
memory so this data gets struck will

00:23:25,840 --> 00:23:31,480
actually give you the address of the of

00:23:28,450 --> 00:23:33,580
your array in memory and then you simply

00:23:31,480 --> 00:23:38,200
use malloc to allocate memory and set

00:23:33,580 --> 00:23:40,350
its size this is the accessor so yet

00:23:38,200 --> 00:23:43,330
again you get the reference of the

00:23:40,350 --> 00:23:45,490
memory location of your array and then

00:23:43,330 --> 00:23:49,150
you set it directly and and you and you

00:23:45,490 --> 00:23:52,030
convert from C to Ruby types and this is

00:23:49,150 --> 00:23:53,650
the setter very similar get always get

00:23:52,030 --> 00:23:55,960
the reference it get the address in

00:23:53,650 --> 00:23:58,740
memory and then work with that address

00:23:55,960 --> 00:24:01,180
with that memory address directly in C

00:23:58,740 --> 00:24:05,920
so this is an example how we can

00:24:01,180 --> 00:24:09,130
actually reuse pure Ruby functions in C

00:24:05,920 --> 00:24:11,160
Ruby so here is a this is a car you can

00:24:09,130 --> 00:24:13,780
find these you know samples of quicksort

00:24:11,160 --> 00:24:15,850
on the internet or an algorithms book so

00:24:13,780 --> 00:24:18,550
this is really simple one I need one

00:24:15,850 --> 00:24:21,610
that would fit on fit on one slide but

00:24:18,550 --> 00:24:23,920
it's not very optimal but this is pure c

00:24:21,610 --> 00:24:26,320
function right and all you have to do is

00:24:23,920 --> 00:24:28,420
create this adapter function which will

00:24:26,320 --> 00:24:30,880
actually get the address memory address

00:24:28,420 --> 00:24:34,240
of your object and pass it to this pure

00:24:30,880 --> 00:24:35,710
c function and you can reuse thousands

00:24:34,240 --> 00:24:38,950
of algorithms that are already written

00:24:35,710 --> 00:24:42,670
for c and yet a good performance of the

00:24:38,950 --> 00:24:45,040
building building sort function is ten

00:24:42,670 --> 00:24:47,140
times slower than actual they actually

00:24:45,040 --> 00:24:48,970
this quicksort implementation and this

00:24:47,140 --> 00:24:49,900
is not very optimal quicksort so you can

00:24:48,970 --> 00:24:52,090
you can do much better

00:24:49,900 --> 00:24:53,680
also remember that when we build the

00:24:52,090 --> 00:24:56,290
Ruby we actually disable all the

00:24:53,680 --> 00:24:58,240
optimization so if you actually build

00:24:56,290 --> 00:25:01,270
your version of Ruby with optimization

00:24:58,240 --> 00:25:04,720
flag this will be even faster okay so

00:25:01,270 --> 00:25:07,720
this completes a fourth lever which is

00:25:04,720 --> 00:25:10,150
we implemented see fib it was 30 times

00:25:07,720 --> 00:25:12,130
faster c prime 17 times faster and

00:25:10,150 --> 00:25:14,200
quicksort so we even build they come we

00:25:12,130 --> 00:25:17,170
implemented first that we hack the fixed

00:25:14,200 --> 00:25:21,160
num class it directly in C and then we

00:25:17,170 --> 00:25:25,990
also create a completely new class all

00:25:21,160 --> 00:25:27,190
in NC I have also a level about graphs

00:25:25,990 --> 00:25:30,660
here I'm going to skip it I don't have

00:25:27,190 --> 00:25:34,060
enough time but here you can see that

00:25:30,660 --> 00:25:36,730
that for example creation of the grid is

00:25:34,060 --> 00:25:39,340
50 times faster in see Ruby and actually

00:25:36,730 --> 00:25:41,500
breakfast search is actually 19 times

00:25:39,340 --> 00:25:44,290
faster in see Ruby I'm going to I'm

00:25:41,500 --> 00:25:46,060
going to tweet all these posts on my

00:25:44,290 --> 00:25:47,830
Twitter account so you can you can this

00:25:46,060 --> 00:25:49,960
these slides on my Twitter account so

00:25:47,830 --> 00:25:52,780
you can actually take a look at the

00:25:49,960 --> 00:25:55,750
graph section well as I said before is

00:25:52,780 --> 00:25:59,010
it saving production of course not if if

00:25:55,750 --> 00:26:01,390
you really are good at edit write it oh

00:25:59,010 --> 00:26:02,770
you know companies like Twitter that's

00:26:01,390 --> 00:26:04,930
what they do right they compile their

00:26:02,770 --> 00:26:07,330
own version of Ruby but for a smaller

00:26:04,930 --> 00:26:10,360
website probably this is great way to

00:26:07,330 --> 00:26:12,190
experiment but if you find something

00:26:10,360 --> 00:26:13,930
interesting well you should definitely

00:26:12,190 --> 00:26:16,000
extract it into a separate gem and

00:26:13,930 --> 00:26:17,950
that's probably the safest way to go

00:26:16,000 --> 00:26:20,260
about it but if you feel confident that

00:26:17,950 --> 00:26:23,020
you want for some reason deployed in

00:26:20,260 --> 00:26:26,230
production then you definitely can can

00:26:23,020 --> 00:26:28,390
are the only the one good reason where I

00:26:26,230 --> 00:26:30,310
would see the one good reason that that

00:26:28,390 --> 00:26:32,770
I would see for deploying your own

00:26:30,310 --> 00:26:35,050
version of Ruben production if you if

00:26:32,770 --> 00:26:37,000
you have very weird see exceptions in

00:26:35,050 --> 00:26:39,340
production so you can for example deploy

00:26:37,000 --> 00:26:41,500
one server with debug information in a

00:26:39,340 --> 00:26:43,140
boat and you can actually debug it at at

00:26:41,500 --> 00:26:46,780
sea level that's the only reason I

00:26:43,140 --> 00:26:49,330
reasonable reason okay so what have we

00:26:46,780 --> 00:26:51,400
done I think I showed you that it's very

00:26:49,330 --> 00:26:53,110
easy to install see Ruby it will take

00:26:51,400 --> 00:26:54,820
you literally 30 minutes and you should

00:26:53,110 --> 00:26:56,860
try it probably today even today it's

00:26:54,820 --> 00:26:58,870
really a lot of fun and the steps that I

00:26:56,860 --> 00:27:00,730
showed you I tested them yesterday so

00:26:58,870 --> 00:27:03,120
they are repeatable as long as you copy

00:27:00,730 --> 00:27:05,550
and paste correctly you are fine

00:27:03,120 --> 00:27:06,600
and if you are interested if you want to

00:27:05,550 --> 00:27:08,280
learn more especially if you've been

00:27:06,600 --> 00:27:10,770
doing Ruby for a couple of years and

00:27:08,280 --> 00:27:12,960
it's getting kind of bored it's a great

00:27:10,770 --> 00:27:15,900
way to spark your interest again because

00:27:12,960 --> 00:27:17,550
if you know Ruby object model and meta

00:27:15,900 --> 00:27:18,900
programming if you look at this see

00:27:17,550 --> 00:27:20,610
robocode then you will have a lot of

00:27:18,900 --> 00:27:22,590
this aha moments where you will see oh

00:27:20,610 --> 00:27:24,750
that's how the single method works or

00:27:22,590 --> 00:27:27,690
that's how how couple of those things

00:27:24,750 --> 00:27:31,410
are done you can also use it to speed up

00:27:27,690 --> 00:27:33,059
your code if you have tight loops and

00:27:31,410 --> 00:27:35,670
you profile your code and you see that

00:27:33,059 --> 00:27:37,590
like certain methods take really it

00:27:35,670 --> 00:27:39,750
takes take majority of the time of the

00:27:37,590 --> 00:27:41,550
execution time of your code well maybe

00:27:39,750 --> 00:27:44,640
it's a good idea to just rewrite it as a

00:27:41,550 --> 00:27:46,500
see Ruby extension and you can also use

00:27:44,640 --> 00:27:49,590
a lot of algorithms that are already on

00:27:46,500 --> 00:27:53,390
the on the net I'm from pivotal pivotal

00:27:49,590 --> 00:27:55,860
is always hiring so give us a call and

00:27:53,390 --> 00:28:02,160
any questions also please follow me on

00:27:55,860 --> 00:28:06,050
Twitter go ahead so the question is are

00:28:02,160 --> 00:28:08,309
there any tools to track down

00:28:06,050 --> 00:28:10,080
allocations and the allocations of the

00:28:08,309 --> 00:28:12,270
SIA rice I haven't done actually

00:28:10,080 --> 00:28:14,280
recently I've done a lot of see in the

00:28:12,270 --> 00:28:17,429
past but recently i was doing mostly

00:28:14,280 --> 00:28:21,240
ruby and iOS development but i remember

00:28:17,429 --> 00:28:24,000
that especially I think Intel compilers

00:28:21,240 --> 00:28:28,440
had really go good tools to actually

00:28:24,000 --> 00:28:31,110
track your your memory usage and make

00:28:28,440 --> 00:28:36,360
sure that you balance fries and Alex and

00:28:31,110 --> 00:28:39,620
and fries okay I think not out of time

00:28:36,360 --> 00:28:39,620

YouTube URL: https://www.youtube.com/watch?v=9oH6sL2sKvw


