Title: MountainWest RubyConf 2014 - Generate Parsers! Prevent Exploits! by Nick Howard
Publication date: 2020-01-24
Playlist: MWRC 2014
Description: 
	Exploits happen when attackers discover that your application is actually an interpreter for a weird programming language with operators like 'make admin', or 'consume all available memory'. Don't give them access to that kind of computational power! Stop them at the very boundaries of your application's input handling--the parser. By generating parsers tailored to the specific input formats of your app, you can prevent it from becoming a weird interpreter and make it harder to exploit.
When you use a parser specific to your input format, it's not only more secure, it's better specified and definite. When you have a grammar for your inputs, you can give your API consumers better error messages and better documentation based on that grammar.
Using Ruby's metaprogramming superpowers, doing this doesn't have to be a painful process. I've been working on a library called Muskox that aims to make generating parsers almost as simple as using Rails 4's Strong Parameters. Writing code to secure your app's inputs should be easy, fun and fast.

Help us caption & translate this video!

http://amara.org/v/FG2h/
Captions: 
	00:00:25,130 --> 00:00:31,440
good morning everybody I I want to be

00:00:29,100 --> 00:00:33,239
talking about parsers are talking about

00:00:31,440 --> 00:00:36,809
exploits so the time of my talk is

00:00:33,239 --> 00:00:38,910
generate parsers prevent exploits ah but

00:00:36,809 --> 00:00:41,910
it could also be called Lang sack for

00:00:38,910 --> 00:00:43,590
Ruby devs or hey do your computation

00:00:41,910 --> 00:00:46,470
this is actually relevant to web

00:00:43,590 --> 00:00:48,660
development well maybe ah so what am I

00:00:46,470 --> 00:00:50,820
talking about I'm going to explain what

00:00:48,660 --> 00:00:52,890
exploits are and talk about how they

00:00:50,820 --> 00:00:55,320
relate to formal languages and then talk

00:00:52,890 --> 00:00:56,910
about how the you want to generate

00:00:55,320 --> 00:00:58,410
parsers to deal with those formal

00:00:56,910 --> 00:01:01,430
languages because that's awesome and

00:00:58,410 --> 00:01:04,589
also there will be pictures of ducks and

00:01:01,430 --> 00:01:07,380
geese to sort of represent you know it's

00:01:04,589 --> 00:01:10,920
like duck duck goose good good bad all

00:01:07,380 --> 00:01:13,229
right so exploits they suck having an

00:01:10,920 --> 00:01:15,810
appt exploit it totally sucks it ruins

00:01:13,229 --> 00:01:17,820
your day attackers they get it access to

00:01:15,810 --> 00:01:22,170
you know they find holes in in your

00:01:17,820 --> 00:01:24,270
application and holds near castle walls

00:01:22,170 --> 00:01:26,070
cracks in your dams you know various

00:01:24,270 --> 00:01:29,670
other analogies it's kind of hard to

00:01:26,070 --> 00:01:31,049
explain and when when they do that they

00:01:29,670 --> 00:01:33,030
end up getting access to all of your

00:01:31,049 --> 00:01:35,070
stuff you know you get your secrets they

00:01:33,030 --> 00:01:37,650
get access to your database shell on

00:01:35,070 --> 00:01:41,520
your servers root access you know

00:01:37,650 --> 00:01:43,680
everything and that sucks Oh as an aside

00:01:41,520 --> 00:01:45,689
make sure that your passwords are hash

00:01:43,680 --> 00:01:48,810
insulted correctly because you don't

00:01:45,689 --> 00:01:51,869
want to be unfortunately you don't want

00:01:48,810 --> 00:01:54,659
those to be unfortunately exposed so um

00:01:51,869 --> 00:01:55,920
trick exploits you know like when you

00:01:54,659 --> 00:01:57,450
think about them and you're looking at

00:01:55,920 --> 00:01:59,759
list of them I sort of feel like these

00:01:57,450 --> 00:02:02,130
tricks like oh well if you do this

00:01:59,759 --> 00:02:05,610
special thing then suddenly everything

00:02:02,130 --> 00:02:06,780
goes wrong and they feel like you it's

00:02:05,610 --> 00:02:09,119
hard to anticipate where they're going

00:02:06,780 --> 00:02:11,489
to show up like how do these things even

00:02:09,119 --> 00:02:13,739
work and I feel like they're unrelated I

00:02:11,489 --> 00:02:15,720
mean or do buffer overflows and sequel

00:02:13,739 --> 00:02:19,410
injection and cross site scripting and

00:02:15,720 --> 00:02:20,730
everything else have in common they sort

00:02:19,410 --> 00:02:22,200
of feel all different but the truth is

00:02:20,730 --> 00:02:24,329
that they're not different they're all

00:02:22,200 --> 00:02:27,630
the same thing their unexpected

00:02:24,329 --> 00:02:30,299
computation I somewhere in your

00:02:27,630 --> 00:02:32,400
application is some control flow that's

00:02:30,299 --> 00:02:34,220
going to run that you didn't really

00:02:32,400 --> 00:02:37,290
intend it to run that way

00:02:34,220 --> 00:02:39,930
and computation is interesting word

00:02:37,290 --> 00:02:41,460
because hey that means that we can use

00:02:39,930 --> 00:02:43,410
theory of computation to think about

00:02:41,460 --> 00:02:46,170
exploits so we're going to hand wave

00:02:43,410 --> 00:02:48,120
about it about that but not yet because

00:02:46,170 --> 00:02:51,050
we don't need to talk about that just

00:02:48,120 --> 00:02:54,210
yet so exploits they're not tricks

00:02:51,050 --> 00:02:55,800
exploits of machines what do I mean by a

00:02:54,210 --> 00:02:58,320
machine well they're they're a

00:02:55,800 --> 00:02:59,690
computational machine so they do the

00:02:58,320 --> 00:03:02,910
same things that you don't like any

00:02:59,690 --> 00:03:04,980
computation machine do they take input a

00:03:02,910 --> 00:03:06,960
you know like they do things with that

00:03:04,980 --> 00:03:12,090
input and then they produce output man

00:03:06,960 --> 00:03:13,680
maybe profit so it's basically the same

00:03:12,090 --> 00:03:14,940
as any regular program I mean like when

00:03:13,680 --> 00:03:16,590
you're making a rails app you want to

00:03:14,940 --> 00:03:19,200
take input do stuff with it and produce

00:03:16,590 --> 00:03:20,790
output and I make money it's great and

00:03:19,200 --> 00:03:22,920
that's the same thing that people trying

00:03:20,790 --> 00:03:24,300
to use exploits are doing but what's

00:03:22,920 --> 00:03:26,430
different so the thing that's different

00:03:24,300 --> 00:03:28,260
about an exploit is that it's made up of

00:03:26,430 --> 00:03:30,870
a slightly different set of components

00:03:28,260 --> 00:03:32,700
than your usual machine there's got to

00:03:30,870 --> 00:03:35,190
be undefined behavior in the application

00:03:32,700 --> 00:03:37,080
that you're looking at and there has to

00:03:35,190 --> 00:03:40,140
be some way of talking to that undefined

00:03:37,080 --> 00:03:43,380
behavior exploits are living inside

00:03:40,140 --> 00:03:45,180
applications of frameworks and the way

00:03:43,380 --> 00:03:49,980
that they get input is through those

00:03:45,180 --> 00:03:51,750
applications or frameworks inputs so you

00:03:49,980 --> 00:03:53,280
can kind of think of an exploit is not

00:03:51,750 --> 00:03:55,590
just a machine but a weird machine

00:03:53,280 --> 00:03:57,420
because it there's this level of

00:03:55,590 --> 00:04:00,270
indirection where the exploit is a

00:03:57,420 --> 00:04:02,790
receiving input through this thing that

00:04:00,270 --> 00:04:05,820
you didn't expect to happen through the

00:04:02,790 --> 00:04:09,660
inputs and a weird machine is actually

00:04:05,820 --> 00:04:12,690
the term that some people in the the

00:04:09,660 --> 00:04:14,280
offensive and so info security community

00:04:12,690 --> 00:04:15,690
used to refer to these because it sort

00:04:14,280 --> 00:04:18,000
of feels like you're programming and

00:04:15,690 --> 00:04:20,130
this really strange language that's

00:04:18,000 --> 00:04:22,590
accepted by a very strange machine so i

00:04:20,130 --> 00:04:24,630
made this neat little diagram so like if

00:04:22,590 --> 00:04:27,030
your if your app has an exploit in it

00:04:24,630 --> 00:04:29,010
what's going to happen is an attacker is

00:04:27,030 --> 00:04:30,330
going to send input to your application

00:04:29,010 --> 00:04:32,669
but really it's going to go to the

00:04:30,330 --> 00:04:35,100
exploit and then output can come out of

00:04:32,669 --> 00:04:37,470
that so it'll hit the boundary of your

00:04:35,100 --> 00:04:39,450
application and instead of you know

00:04:37,470 --> 00:04:41,070
going to the code that you expect it to

00:04:39,450 --> 00:04:42,540
do and computing the thing that you want

00:04:41,070 --> 00:04:44,400
it to compute it's going to go somewhere

00:04:42,540 --> 00:04:46,530
else and it's going to end up at the

00:04:44,400 --> 00:04:47,529
exploit and then it's going to come out

00:04:46,530 --> 00:04:49,179
in the active

00:04:47,529 --> 00:04:51,159
the attacker is going to be able to see

00:04:49,179 --> 00:04:52,509
effects from that and they're going to

00:04:51,159 --> 00:04:54,969
be able to infer what kinds of

00:04:52,509 --> 00:04:57,969
operations I can do with that particular

00:04:54,969 --> 00:05:01,989
exploit so how do you stop these things

00:04:57,969 --> 00:05:04,119
well the answer is relatives here for it

00:05:01,989 --> 00:05:05,709
you need to break their communications

00:05:04,119 --> 00:05:08,979
because if your app has done to find

00:05:05,709 --> 00:05:12,219
behavior that sucks but you can actually

00:05:08,979 --> 00:05:14,919
if if you get rid of the ability to

00:05:12,219 --> 00:05:16,929
exercise that on the fine behavior then

00:05:14,919 --> 00:05:18,489
it's not behavior it's just something

00:05:16,929 --> 00:05:21,039
that's in your code and whatever you

00:05:18,489 --> 00:05:22,629
know it's dead code which is safe so we

00:05:21,039 --> 00:05:26,739
need to do is we need to validate our

00:05:22,629 --> 00:05:30,699
inputs before we use them so let's talk

00:05:26,739 --> 00:05:33,009
about what that input is the input is

00:05:30,699 --> 00:05:35,469
instructions to the exploit I remember

00:05:33,009 --> 00:05:38,379
an exploit is a weird machine and so you

00:05:35,469 --> 00:05:41,679
can think of the the instructions as

00:05:38,379 --> 00:05:43,949
being basically a program and it's a

00:05:41,679 --> 00:05:46,839
program in the language of the exploit

00:05:43,949 --> 00:05:49,049
so if you had a sequel injection in your

00:05:46,839 --> 00:05:51,519
application it's sort of like writing a

00:05:49,049 --> 00:05:55,449
writing for a machine that takes equal

00:05:51,519 --> 00:06:00,189
as its as its language so let's talk

00:05:55,449 --> 00:06:02,499
about an example so last year rails at

00:06:00,189 --> 00:06:04,089
this bug in it where it would when when

00:06:02,499 --> 00:06:06,339
you had XML that you were trying to

00:06:04,089 --> 00:06:07,779
parse it would take that XML and if it

00:06:06,339 --> 00:06:11,589
had a special little thing in it it

00:06:07,779 --> 00:06:14,860
would read that that text as yamo and

00:06:11,589 --> 00:06:17,469
that was a bad idea the reason that was

00:06:14,860 --> 00:06:20,349
a bad idea is because gamal you can get

00:06:17,469 --> 00:06:21,939
access to any class you can create an

00:06:20,349 --> 00:06:24,099
object of any class that's in the

00:06:21,939 --> 00:06:26,529
runtime with the particular animal that

00:06:24,099 --> 00:06:29,229
rails was using so if we look back at

00:06:26,529 --> 00:06:31,359
this diagram again we see that I the

00:06:29,229 --> 00:06:33,009
input comes in it goes to rails goes

00:06:31,359 --> 00:06:35,589
through the XML parser and then there's

00:06:33,009 --> 00:06:38,709
this undefined behavior inside the XML

00:06:35,589 --> 00:06:40,149
parser where it's parsing yamo and we

00:06:38,709 --> 00:06:43,119
didn't you know like you don't think oh

00:06:40,149 --> 00:06:46,299
yeah well that means eval but it does so

00:06:43,119 --> 00:06:48,159
that's not good so the way that worked

00:06:46,299 --> 00:06:50,289
was you'd have this weird crafted input

00:06:48,159 --> 00:06:52,779
where you'd have like a XML document and

00:06:50,289 --> 00:06:54,759
inside that you would say oh the type of

00:06:52,779 --> 00:06:56,860
the contents of this is y Amal and it

00:06:54,759 --> 00:06:59,259
have some evil object that exists in the

00:06:56,860 --> 00:07:01,900
rails runtime that allows you to do evil

00:06:59,259 --> 00:07:03,639
and once you did

00:07:01,900 --> 00:07:05,340
if you were an attacker you would be

00:07:03,639 --> 00:07:08,470
running Ruby on whoever's application

00:07:05,340 --> 00:07:11,410
that was which is terrible if that's

00:07:08,470 --> 00:07:14,080
your application ah so that's big sad

00:07:11,410 --> 00:07:17,680
face and you know like a vague angry

00:07:14,080 --> 00:07:20,680
goose my god this is terrible watch out

00:07:17,680 --> 00:07:22,210
the goose is going to eat you and so if

00:07:20,680 --> 00:07:23,740
you haven't patched that I would really

00:07:22,210 --> 00:07:28,150
strongly advise that you patch it

00:07:23,740 --> 00:07:29,620
because because it's in metasploit you

00:07:28,150 --> 00:07:32,100
know people can just sort of run a

00:07:29,620 --> 00:07:35,229
script and use it on your applications

00:07:32,100 --> 00:07:38,919
so what's the real problem here a real

00:07:35,229 --> 00:07:40,780
problem is bad input validation and the

00:07:38,919 --> 00:07:42,580
way that you deal with that is pretty

00:07:40,780 --> 00:07:44,560
obvious what we want to do is we want to

00:07:42,580 --> 00:07:46,870
have good VIN foot validation we don't

00:07:44,560 --> 00:07:48,789
want to allow bad inputs like it if if

00:07:46,870 --> 00:07:50,860
an input is bad we don't want it even

00:07:48,789 --> 00:07:52,750
our application code to even see it we

00:07:50,860 --> 00:07:56,380
want it to just go away we want to say

00:07:52,750 --> 00:07:59,110
like that's rejected no but but how can

00:07:56,380 --> 00:08:00,849
you do that ah the way that you do that

00:07:59,110 --> 00:08:05,710
is by recognizing inputs before you

00:08:00,849 --> 00:08:07,270
process them and so that brings me to

00:08:05,710 --> 00:08:08,949
Lang sec earlier I said one of the

00:08:07,270 --> 00:08:11,440
titles of this talk is lying sack for

00:08:08,949 --> 00:08:13,810
Ruby developers so blanc-sec is actually

00:08:11,440 --> 00:08:17,770
short for language theoretical security

00:08:13,810 --> 00:08:21,130
and so this is a field in infosec where

00:08:17,770 --> 00:08:22,599
you take a theory of computation and an

00:08:21,130 --> 00:08:27,220
understanding of formal languages and

00:08:22,599 --> 00:08:30,370
you apply them to to securing systems

00:08:27,220 --> 00:08:32,830
because it turns out that if you do like

00:08:30,370 --> 00:08:34,570
the things about formal languages allow

00:08:32,830 --> 00:08:36,310
you to make certain assumptions and you

00:08:34,570 --> 00:08:38,289
can say that certain things are secure

00:08:36,310 --> 00:08:41,409
and certain things aren't and that's

00:08:38,289 --> 00:08:43,330
very interesting and so I watch this

00:08:41,409 --> 00:08:45,279
talk on it like two years ago and I was

00:08:43,330 --> 00:08:47,980
just like this is amazing more people

00:08:45,279 --> 00:08:50,529
need to know about this so anyway this

00:08:47,980 --> 00:08:52,270
last thing that I had up before this is

00:08:50,529 --> 00:08:54,670
actually one of the things that they say

00:08:52,270 --> 00:08:56,470
you should do this is important if you

00:08:54,670 --> 00:08:59,500
don't do this then you're exposed

00:08:56,470 --> 00:09:03,430
because you could you know like end up

00:08:59,500 --> 00:09:08,470
in undefined behaviors so that's just

00:09:03,430 --> 00:09:11,230
ducky but recognize that's an

00:09:08,470 --> 00:09:13,450
interesting word if you've taken a

00:09:11,230 --> 00:09:15,490
compilers course or theory of

00:09:13,450 --> 00:09:17,860
computation you know that recognize

00:09:15,490 --> 00:09:22,330
is not just you know it has a specific

00:09:17,860 --> 00:09:23,980
meaning inside computation so we're

00:09:22,330 --> 00:09:27,490
actually talking about is decidability I

00:09:23,980 --> 00:09:28,839
mean this question of can we do this and

00:09:27,490 --> 00:09:31,600
indeed that's what we're talking about

00:09:28,839 --> 00:09:35,490
so we're going to crack open our theory

00:09:31,600 --> 00:09:39,370
of computation hand wave addition yeah

00:09:35,490 --> 00:09:40,870
so chapter 0 of the theory of

00:09:39,370 --> 00:09:43,270
computation hand wave addition is on

00:09:40,870 --> 00:09:44,800
decidability and decidability is all

00:09:43,270 --> 00:09:48,640
about answering this particular question

00:09:44,800 --> 00:09:52,930
which is if you have a formal system or

00:09:48,640 --> 00:09:55,420
a formal language is every statement

00:09:52,930 --> 00:09:58,300
that can be said in that possible is it

00:09:55,420 --> 00:10:00,580
possible to say yes or no to every

00:09:58,300 --> 00:10:03,490
statement that's in that and so I would

00:10:00,580 --> 00:10:06,570
like to go to an example to explain the

00:10:03,490 --> 00:10:11,260
answer to this particular question so

00:10:06,570 --> 00:10:12,610
this is this example is in a ah a

00:10:11,260 --> 00:10:16,209
natural language that i like to call

00:10:12,610 --> 00:10:18,310
english this statement is false if this

00:10:16,209 --> 00:10:19,870
statement is false then the statement is

00:10:18,310 --> 00:10:22,500
true but then if that's the case then

00:10:19,870 --> 00:10:25,839
it's false and you just keep going and

00:10:22,500 --> 00:10:26,950
since it keeps going you that has a

00:10:25,839 --> 00:10:28,540
relationship with the halting problem

00:10:26,950 --> 00:10:30,820
which is the idea that if you have a

00:10:28,540 --> 00:10:32,050
Turing machine and some input you and

00:10:30,820 --> 00:10:34,360
you don't know anything about the Turing

00:10:32,050 --> 00:10:35,950
machine you can't actually tell given

00:10:34,360 --> 00:10:39,279
that input whether it will halt or not

00:10:35,950 --> 00:10:42,070
and that's important because if an input

00:10:39,279 --> 00:10:43,360
is input to your application you want to

00:10:42,070 --> 00:10:46,660
know whether it's going to halt because

00:10:43,360 --> 00:10:48,220
you want to know Leona like usually we

00:10:46,660 --> 00:10:50,020
want to like do something with a web

00:10:48,220 --> 00:10:51,760
requests and then give it back to the

00:10:50,020 --> 00:10:53,620
browser we don't want to like just sit

00:10:51,760 --> 00:10:56,200
there and definitely that's not good and

00:10:53,620 --> 00:10:59,620
it turns out that kind of thing is

00:10:56,200 --> 00:11:01,870
undecidable so that's that's the first

00:10:59,620 --> 00:11:03,310
hand wave portion so undecidable

00:11:01,870 --> 00:11:06,700
problems exist but what does that have

00:11:03,310 --> 00:11:08,860
to do with input validation well it kind

00:11:06,700 --> 00:11:11,440
of sucks there are types of input

00:11:08,860 --> 00:11:13,810
languages input that recognize merely

00:11:11,440 --> 00:11:16,779
recognizing that input is undecidable so

00:11:13,810 --> 00:11:18,730
if you try to parse something that parts

00:11:16,779 --> 00:11:21,250
could just go forever and you it will

00:11:18,730 --> 00:11:22,990
never come back so you don't you don't

00:11:21,250 --> 00:11:27,190
want that in your in your applications

00:11:22,990 --> 00:11:29,620
that's terrible so the other implication

00:11:27,190 --> 00:11:30,850
of that is that if you want to make

00:11:29,620 --> 00:11:34,060
sure that your application doesn't have

00:11:30,850 --> 00:11:36,970
any exploits in it if you accept that

00:11:34,060 --> 00:11:40,410
kind of input it's impossible provably

00:11:36,970 --> 00:11:43,660
impossible to secure your application so

00:11:40,410 --> 00:11:45,190
yeah that that's that's pretty bad goose

00:11:43,660 --> 00:11:47,980
there you know it'll make you run around

00:11:45,190 --> 00:11:51,940
the circle so certain types that's kind

00:11:47,980 --> 00:11:54,190
of fun let's go back to the theory of

00:11:51,940 --> 00:11:56,320
computation hand wave addition so if

00:11:54,190 --> 00:11:59,260
you've ever taken a compilers course you

00:11:56,320 --> 00:12:00,520
probably know a little bit about formal

00:11:59,260 --> 00:12:02,350
languages but if you don't that's okay

00:12:00,520 --> 00:12:05,339
too so there's this thing called the

00:12:02,350 --> 00:12:07,540
Chomsky hierarchy which describes the

00:12:05,339 --> 00:12:10,210
complexity that's allowed within certain

00:12:07,540 --> 00:12:12,160
grammars so like the biggest one

00:12:10,210 --> 00:12:13,540
contains all the other ones so the other

00:12:12,160 --> 00:12:16,000
ones are all smaller and so I'm going to

00:12:13,540 --> 00:12:18,700
start from the bottom so regular

00:12:16,000 --> 00:12:20,529
languages are boring languages if you

00:12:18,700 --> 00:12:23,710
ever use regular expressions without the

00:12:20,529 --> 00:12:26,800
extended regular expressions regular

00:12:23,710 --> 00:12:28,330
expressions defines regular languages

00:12:26,800 --> 00:12:30,850
and that's why you don't want to use it

00:12:28,330 --> 00:12:32,380
to parse XML because you can't do things

00:12:30,850 --> 00:12:34,450
like match friends you can't handle

00:12:32,380 --> 00:12:36,400
nested stuff but you can do stuff like

00:12:34,450 --> 00:12:39,400
I'm looking for a bunch of these things

00:12:36,400 --> 00:12:41,110
in a delimiter that works you also can't

00:12:39,400 --> 00:12:43,990
count things so you can't say I want

00:12:41,110 --> 00:12:45,880
five I want n of these things and then

00:12:43,990 --> 00:12:49,570
the same number of this other thing you

00:12:45,880 --> 00:12:52,060
can't do that either and so that's just

00:12:49,570 --> 00:12:53,580
ducky because that's it's pretty boring

00:12:52,060 --> 00:12:56,380
language and it's pretty safe

00:12:53,580 --> 00:12:58,240
context-free is a little less boring

00:12:56,380 --> 00:13:03,730
because you can now have you can now

00:12:58,240 --> 00:13:05,140
represent nested structures and it still

00:13:03,730 --> 00:13:07,720
has all the same powers as regular

00:13:05,140 --> 00:13:11,470
languages and they're pretty nice

00:13:07,720 --> 00:13:13,209
languages JSON would be an example so

00:13:11,470 --> 00:13:15,100
that's also pretty ducky but it's it's

00:13:13,209 --> 00:13:17,610
not as cuddly because it requires more

00:13:15,100 --> 00:13:19,900
processing power in order to handle um

00:13:17,610 --> 00:13:24,580
context-sensitive languages are less

00:13:19,900 --> 00:13:26,260
boring and mostly safe so you can so all

00:13:24,580 --> 00:13:28,990
those other languages you can recognize

00:13:26,260 --> 00:13:30,550
them and that's a decidable thing you'll

00:13:28,990 --> 00:13:32,529
know that it will terminate your parser

00:13:30,550 --> 00:13:34,750
will terminate with context-sensitive

00:13:32,529 --> 00:13:36,910
languages it the parser will also

00:13:34,750 --> 00:13:38,470
terminate but um but it's a lot more

00:13:36,910 --> 00:13:42,819
complicated because you can do things

00:13:38,470 --> 00:13:45,129
like you can represent like how

00:13:42,819 --> 00:13:47,289
you're going to parse something within

00:13:45,129 --> 00:13:49,660
the language a little bit so you can say

00:13:47,289 --> 00:13:52,660
like have a field length and then have

00:13:49,660 --> 00:13:56,319
the field so you can you know like you

00:13:52,660 --> 00:13:58,419
could there's this protocol called

00:13:56,319 --> 00:14:01,059
message pack where you say like I have a

00:13:58,419 --> 00:14:02,979
string and my string is 60 bytes long so

00:14:01,059 --> 00:14:05,109
you know like you like 60 bytes and then

00:14:02,979 --> 00:14:07,209
the parser can just skip ahead and find

00:14:05,109 --> 00:14:08,559
the rest of the string all right so you

00:14:07,209 --> 00:14:10,619
can do stuff like that so that's a duck

00:14:08,559 --> 00:14:12,939
but it's not as nice of a duck

00:14:10,619 --> 00:14:16,179
recursively enumerable however which is

00:14:12,939 --> 00:14:18,789
the biggest circle is kind of it's a

00:14:16,179 --> 00:14:20,709
terrible class of language to use as

00:14:18,789 --> 00:14:22,629
input because you can use recursively

00:14:20,709 --> 00:14:25,239
enumerable languages to describe Turing

00:14:22,629 --> 00:14:27,609
machines and if you can use it to

00:14:25,239 --> 00:14:29,410
describe a Turing machine then it if you

00:14:27,609 --> 00:14:32,470
have a parser for it's kind of like

00:14:29,410 --> 00:14:35,859
having a interpreter for Turing machines

00:14:32,470 --> 00:14:38,319
and it and so that runs back into the

00:14:35,859 --> 00:14:41,350
halting problem and that's not great you

00:14:38,319 --> 00:14:45,369
know it's like ah no good that's not

00:14:41,350 --> 00:14:48,850
good at all ah so that's the Chomsky

00:14:45,369 --> 00:14:49,929
hierarchy so I talked a little so I I

00:14:48,850 --> 00:14:53,259
talked a little bit about the

00:14:49,929 --> 00:14:55,809
recognition qualities of that so for for

00:14:53,259 --> 00:14:57,279
recognizing things everything below

00:14:55,809 --> 00:15:00,249
recursively enumerable which sometimes

00:14:57,279 --> 00:15:02,379
it's called turn complete those are all

00:15:00,249 --> 00:15:03,579
safe like if you have those and those

00:15:02,379 --> 00:15:06,129
are the things you're parsing you're

00:15:03,579 --> 00:15:08,979
pretty good but there's another quality

00:15:06,129 --> 00:15:10,899
to these languages which is that um it

00:15:08,979 --> 00:15:12,639
there are also decidability questions

00:15:10,899 --> 00:15:16,389
about whether you can compare two

00:15:12,639 --> 00:15:18,789
implementations of a parser for a

00:15:16,389 --> 00:15:21,009
language and it turns out that that has

00:15:18,789 --> 00:15:25,809
kind of a funny place where it it breaks

00:15:21,009 --> 00:15:29,739
apart so so if you're using recursively

00:15:25,809 --> 00:15:35,799
enumerable input you know like you're

00:15:29,739 --> 00:15:38,489
sol a contact sensitive low it's ok but

00:15:35,799 --> 00:15:40,689
if you're trying to compare parsers well

00:15:38,489 --> 00:15:42,720
so it turns out that context free is

00:15:40,689 --> 00:15:44,919
actually broken into two pieces

00:15:42,720 --> 00:15:46,059
deterministic and non deterministic and

00:15:44,919 --> 00:15:49,179
I'm not going to get into what that

00:15:46,059 --> 00:15:53,169
looks like but things like JSON are

00:15:49,179 --> 00:15:55,029
deterministic um so if you wanted to

00:15:53,169 --> 00:15:56,620
compare contact deterministic

00:15:55,029 --> 00:15:59,080
context-free parsers

00:15:56,620 --> 00:16:00,790
and tell whether whether they are

00:15:59,080 --> 00:16:02,380
equivalent so you like say you're

00:16:00,790 --> 00:16:05,530
writing a standard and you want to say

00:16:02,380 --> 00:16:08,050
like I want all parsers to conform to

00:16:05,530 --> 00:16:10,620
this set of specs with a deterministic

00:16:08,050 --> 00:16:15,850
context-free language you can do that

00:16:10,620 --> 00:16:17,110
it's a sizable duck okay so there's a

00:16:15,850 --> 00:16:18,570
little bit of hand waving their that was

00:16:17,110 --> 00:16:22,650
kind of complicated let's take a break

00:16:18,570 --> 00:16:25,300
this is the the things that are you can

00:16:22,650 --> 00:16:29,650
parse and compare the parsers of is

00:16:25,300 --> 00:16:32,470
actually pretty small so that's good if

00:16:29,650 --> 00:16:33,850
you can keep to those languages so let's

00:16:32,470 --> 00:16:35,950
go back to the thing that we were just

00:16:33,850 --> 00:16:41,470
talking about recognizing inputs before

00:16:35,950 --> 00:16:42,880
processing the this is actually a eight

00:16:41,470 --> 00:16:44,440
one of the thing like I was saying this

00:16:42,880 --> 00:16:46,300
is one of the things that long sec tells

00:16:44,440 --> 00:16:47,530
you to do the other thing that length

00:16:46,300 --> 00:16:49,570
dick tells you to do and the reason why

00:16:47,530 --> 00:16:51,610
I talked about comparing parsers is that

00:16:49,570 --> 00:16:53,620
if you use deterministic context-free

00:16:51,610 --> 00:16:55,330
languages as inputs then you know like

00:16:53,620 --> 00:16:58,240
you're safe you can always say like all

00:16:55,330 --> 00:16:59,890
implementations all work the same but

00:16:58,240 --> 00:17:01,870
you can't do that with anything with an

00:16:59,890 --> 00:17:04,630
input grammar that's more complicated

00:17:01,870 --> 00:17:06,040
than that so that's not good length egg

00:17:04,630 --> 00:17:08,680
also has a bunch of things that it says

00:17:06,040 --> 00:17:12,040
don't do this like seriously don't do

00:17:08,680 --> 00:17:14,620
this so the first one is turn complete

00:17:12,040 --> 00:17:18,100
inputs if your inputs are trained

00:17:14,620 --> 00:17:20,650
complete then your base you're not ja

00:17:18,100 --> 00:17:22,930
you either you are accepting a

00:17:20,650 --> 00:17:24,880
programming languages input or you're

00:17:22,930 --> 00:17:27,040
accepting something that is incidentally

00:17:24,880 --> 00:17:28,990
effectively a programming language and

00:17:27,040 --> 00:17:31,390
neither of those things are good things

00:17:28,990 --> 00:17:33,880
so like for instance if someone tells

00:17:31,390 --> 00:17:35,670
trying to sell you like a like a network

00:17:33,880 --> 00:17:38,140
box and they're like oh the command

00:17:35,670 --> 00:17:40,750
language for this includes programming

00:17:38,140 --> 00:17:46,090
languages so it's extensible I yeah

00:17:40,750 --> 00:17:47,770
don't do that that run along then you

00:17:46,090 --> 00:17:49,570
also don't want to do ad hoc input

00:17:47,770 --> 00:17:51,810
validation and what I mean by that is

00:17:49,570 --> 00:17:54,070
you don't want to like smear parsing and

00:17:51,810 --> 00:17:56,620
validation of of the things you're

00:17:54,070 --> 00:17:58,510
parsing across your application mostly

00:17:56,620 --> 00:18:01,030
in rails and Ruby we don't have to worry

00:17:58,510 --> 00:18:02,770
about that because rails like sets up

00:18:01,030 --> 00:18:05,350
nice structures for handling those kinds

00:18:02,770 --> 00:18:06,910
of problems I let's also known as

00:18:05,350 --> 00:18:10,360
shotgun parsing if you're interested in

00:18:06,910 --> 00:18:12,940
looking at the kind of thing up and then

00:18:10,360 --> 00:18:15,010
the up the other thing is that you don't

00:18:12,940 --> 00:18:16,600
want to use parsers that are weaker than

00:18:15,010 --> 00:18:20,260
the language that you're trying to parse

00:18:16,600 --> 00:18:22,810
this is the classic don't parse XML with

00:18:20,260 --> 00:18:25,150
JSON toy with with regular expressions

00:18:22,810 --> 00:18:28,510
because regular expressions describe

00:18:25,150 --> 00:18:30,430
regular languages and XML is not a

00:18:28,510 --> 00:18:32,200
regular language so if you try to do

00:18:30,430 --> 00:18:34,870
that you will end up in an unexpected

00:18:32,200 --> 00:18:37,180
state in your program so you know if

00:18:34,870 --> 00:18:40,120
it's if you're trying to validate that

00:18:37,180 --> 00:18:41,860
the right codes are being sent and use a

00:18:40,120 --> 00:18:45,880
regular expression you will fire ze

00:18:41,860 --> 00:18:47,590
missiles ah tldr use json it's

00:18:45,880 --> 00:18:50,800
deterministic context-free and it's

00:18:47,590 --> 00:18:52,150
mostly okay so as far as rail to go the

00:18:50,800 --> 00:18:55,240
rails actually does some pretty neat

00:18:52,150 --> 00:18:57,910
stuff so if you look at rails is HTML

00:18:55,240 --> 00:18:59,320
sanitization stuff they don't try to do

00:18:57,910 --> 00:19:01,030
something silly like use a regular

00:18:59,320 --> 00:19:03,250
expression to look for script tags oh no

00:19:01,030 --> 00:19:05,770
they actually have a tiny little XML

00:19:03,250 --> 00:19:07,660
parser that will parse this the data and

00:19:05,770 --> 00:19:09,190
strip out the tags and that we don't

00:19:07,660 --> 00:19:11,230
have to worry about attacks that deal

00:19:09,190 --> 00:19:13,780
with like escaping thing strangely and

00:19:11,230 --> 00:19:16,750
stuff like that which is great um but

00:19:13,780 --> 00:19:19,600
there but I do have some qualms about it

00:19:16,750 --> 00:19:21,520
so I feel like rails parses things too

00:19:19,600 --> 00:19:23,860
early and the reason why I feel like

00:19:21,520 --> 00:19:25,720
this is because rails parses things

00:19:23,860 --> 00:19:27,430
inside rails before it gets your

00:19:25,720 --> 00:19:30,160
application it's like oh the mime type

00:19:27,430 --> 00:19:31,990
is XML I'll parse that put that into the

00:19:30,160 --> 00:19:33,940
parameter and then when you get to your

00:19:31,990 --> 00:19:36,190
controller you can use that prime sash

00:19:33,940 --> 00:19:38,650
that's great or if it's jason on the

00:19:36,190 --> 00:19:40,930
same thing and i feel like that that's

00:19:38,650 --> 00:19:42,130
not great because your application is

00:19:40,930 --> 00:19:43,930
the thing that understands your

00:19:42,130 --> 00:19:45,310
applications input language and if you

00:19:43,930 --> 00:19:47,170
want to treat your input language as a

00:19:45,310 --> 00:19:50,680
formal language you have to do all that

00:19:47,170 --> 00:19:52,570
stuff in the same place so i feel like

00:19:50,680 --> 00:19:56,320
we should be doing stuff more like this

00:19:52,570 --> 00:19:58,300
and the because what the goal is to

00:19:56,320 --> 00:20:02,530
remove undefined behavior and when rails

00:19:58,300 --> 00:20:04,420
is parsing things for you you may not

00:20:02,530 --> 00:20:08,470
even use that input someone could you

00:20:04,420 --> 00:20:10,480
know like you have a a just a a show

00:20:08,470 --> 00:20:14,350
page that show page could you know

00:20:10,480 --> 00:20:16,330
potentially accept query prams or if you

00:20:14,350 --> 00:20:17,650
have a post that post might you know

00:20:16,330 --> 00:20:19,120
like you may or may not actually do

00:20:17,650 --> 00:20:20,470
anything with the body and if you don't

00:20:19,120 --> 00:20:22,360
do anything with the body I feel like

00:20:20,470 --> 00:20:23,950
you shouldn't rails shouldn't even try

00:20:22,360 --> 00:20:25,630
to parse it

00:20:23,950 --> 00:20:28,389
and so that's why I feel like we should

00:20:25,630 --> 00:20:30,639
you know do our parsing in application

00:20:28,389 --> 00:20:31,960
land instead of in rails land because

00:20:30,639 --> 00:20:33,760
what we want to do is remove undefined

00:20:31,960 --> 00:20:35,470
paper so we don't want to allow

00:20:33,760 --> 00:20:38,080
undefined inputs what we want to do is

00:20:35,470 --> 00:20:41,940
only allow defined inputs and this comes

00:20:38,080 --> 00:20:44,380
from the blanks act so the idea is like

00:20:41,940 --> 00:20:46,510
back in the olden days you wanted to say

00:20:44,380 --> 00:20:47,440
I'm going to be liberal with my inputs

00:20:46,510 --> 00:20:49,269
because I want to make sure that

00:20:47,440 --> 00:20:51,130
everyone who tries to talk to me I'm

00:20:49,269 --> 00:20:52,480
going to do something I'm going to try

00:20:51,130 --> 00:20:56,110
to do something reasonable but the

00:20:52,480 --> 00:20:59,260
problem with doing that is that I your

00:20:56,110 --> 00:21:00,669
inputs aren't definite and so you end up

00:20:59,260 --> 00:21:02,500
making these kind of strange machines

00:21:00,669 --> 00:21:04,600
and this ends up in this situation where

00:21:02,500 --> 00:21:06,929
you have these ad hoc parsers that they

00:21:04,600 --> 00:21:10,210
have all these unexpected unexpected

00:21:06,929 --> 00:21:11,529
computations available to them so what

00:21:10,210 --> 00:21:13,720
you want to do is you want to treat your

00:21:11,529 --> 00:21:15,429
inputs as formal languages and you want

00:21:13,720 --> 00:21:17,289
to treat and by doing that you're

00:21:15,429 --> 00:21:19,000
treating computation as a privilege that

00:21:17,289 --> 00:21:22,330
you aren't giving out to random people

00:21:19,000 --> 00:21:25,539
on the internet so defining inputs isn't

00:21:22,330 --> 00:21:27,220
that kind of a pain yeah it is a pain

00:21:25,539 --> 00:21:29,710
but we already do it to a certain extent

00:21:27,220 --> 00:21:31,169
I mean rails has input validations I

00:21:29,710 --> 00:21:33,700
talked about some of them already but

00:21:31,169 --> 00:21:35,289
the ones that I think we interact with

00:21:33,700 --> 00:21:37,779
on a more day-to-day basis are things

00:21:35,289 --> 00:21:41,889
like at are accessible from rails 3

00:21:37,779 --> 00:21:43,870
which which was okay but but what it did

00:21:41,889 --> 00:21:46,149
is it would check the inputs like right

00:21:43,870 --> 00:21:48,159
before the model and the problem with

00:21:46,149 --> 00:21:50,529
doing so that that's good because it

00:21:48,159 --> 00:21:53,320
making constraints all access to the

00:21:50,529 --> 00:21:54,909
database and it blows up on bad keys so

00:21:53,320 --> 00:21:58,659
like you get errors when someone tells

00:21:54,909 --> 00:22:01,330
you bad data but the the place where

00:21:58,659 --> 00:22:03,370
those accesses are controlled and the

00:22:01,330 --> 00:22:05,350
place where their uses isn't a different

00:22:03,370 --> 00:22:07,419
is in different places and use case

00:22:05,350 --> 00:22:09,730
handling is a little weird so rails 3

00:22:07,419 --> 00:22:12,279
added a rest for edits Fronk parameters

00:22:09,730 --> 00:22:14,169
which I thought was great um because it

00:22:12,279 --> 00:22:16,990
allows you to put your validations right

00:22:14,169 --> 00:22:18,820
next to where you are using those those

00:22:16,990 --> 00:22:21,039
inputs and that's that's good because

00:22:18,820 --> 00:22:23,010
you're doing validation and so that

00:22:21,039 --> 00:22:27,580
moves validation a little bit further

00:22:23,010 --> 00:22:29,010
towards where you're parsing but I feel

00:22:27,580 --> 00:22:31,720
like you could do even better than that

00:22:29,010 --> 00:22:33,429
so the president that is you know like

00:22:31,720 --> 00:22:35,529
the usage in the same place the schema

00:22:33,429 --> 00:22:37,270
is allows nesting which is nice because

00:22:35,529 --> 00:22:40,450
you know like we accept nested J

00:22:37,270 --> 00:22:42,520
on a nested form so that's great but the

00:22:40,450 --> 00:22:44,380
things I don't like about it is when you

00:22:42,520 --> 00:22:48,610
when you're using it and you see like

00:22:44,380 --> 00:22:49,750
this permit thing that will if it sees

00:22:48,610 --> 00:22:51,760
something it doesn't understand it

00:22:49,750 --> 00:22:53,740
strips it out so it's not accessible to

00:22:51,760 --> 00:22:55,330
your application which is good but it

00:22:53,740 --> 00:22:56,590
also means that if someone's trying to

00:22:55,330 --> 00:22:58,390
talk to your application your

00:22:56,590 --> 00:22:59,830
application will accept their input but

00:22:58,390 --> 00:23:01,780
it will ignore it which means that you

00:22:59,830 --> 00:23:03,250
have undefined behavior and the schema

00:23:01,780 --> 00:23:07,300
is a little bit ambiguous but I think

00:23:03,250 --> 00:23:08,770
that's okay for what it does but why why

00:23:07,300 --> 00:23:11,560
wouldn't we do that earlier I mean we

00:23:08,770 --> 00:23:14,350
could do input checking right between

00:23:11,560 --> 00:23:17,500
bites and creating the Ruby objects that

00:23:14,350 --> 00:23:19,810
we then used to to build you don't like

00:23:17,500 --> 00:23:21,490
to talk to our database or make web

00:23:19,810 --> 00:23:23,500
requests or whatever your application

00:23:21,490 --> 00:23:25,510
wants to do and so that was the idea

00:23:23,500 --> 00:23:27,370
behind this library that I've been

00:23:25,510 --> 00:23:29,350
starting work on which is called muskox

00:23:27,370 --> 00:23:31,270
as muskox because it's a parser

00:23:29,350 --> 00:23:34,360
generator you know so it's like yak or

00:23:31,270 --> 00:23:37,720
bison but but musk ox because it's beefy

00:23:34,360 --> 00:23:41,110
so it's a it's a schema based parser

00:23:37,720 --> 00:23:42,640
generator and and the the current

00:23:41,110 --> 00:23:45,880
implementation looks kind of like this

00:23:42,640 --> 00:23:48,010
so you can include it as a module and

00:23:45,880 --> 00:23:50,080
I'll define some methods and then you

00:23:48,010 --> 00:23:52,240
can add a parser with a particular name

00:23:50,080 --> 00:23:54,820
and you give it a schema thats related

00:23:52,240 --> 00:23:56,800
to the JSON schema and then that way you

00:23:54,820 --> 00:23:59,500
can strongly specify the types that are

00:23:56,800 --> 00:24:01,930
allowed of the properties and the kinds

00:23:59,500 --> 00:24:05,350
of objects that you're expecting to

00:24:01,930 --> 00:24:07,150
allows input and then it will only allow

00:24:05,350 --> 00:24:09,880
valid strings to be parsed and it won't

00:24:07,150 --> 00:24:13,870
even create hashes if the if things are

00:24:09,880 --> 00:24:15,460
invalid so you know like you create a

00:24:13,870 --> 00:24:17,110
parser then you can parse it and if it

00:24:15,460 --> 00:24:18,670
works it gives you back some nice data

00:24:17,110 --> 00:24:20,860
but if it doesn't work it gives you back

00:24:18,670 --> 00:24:22,900
an error and it tells you this was the

00:24:20,860 --> 00:24:24,340
unexpected thing that I found and these

00:24:22,900 --> 00:24:29,170
are the things that are allowed at this

00:24:24,340 --> 00:24:31,000
level of the input language it's

00:24:29,170 --> 00:24:33,010
structured by breaking a parser into two

00:24:31,000 --> 00:24:34,900
pieces so there's a tokenizer and a

00:24:33,010 --> 00:24:36,550
validator and when the tokenizer does is

00:24:34,900 --> 00:24:38,590
it recognizes the language in this case

00:24:36,550 --> 00:24:40,450
JSON and then it passes the tokens the

00:24:38,590 --> 00:24:41,770
validator and what the validator does is

00:24:40,450 --> 00:24:44,440
it takes the scheme that you provided

00:24:41,770 --> 00:24:46,690
and then it uses that schema to ensure

00:24:44,440 --> 00:24:48,310
that everything is safe and then it

00:24:46,690 --> 00:24:53,350
populates the

00:24:48,310 --> 00:24:55,900
be objects for you um I haven't gotten

00:24:53,350 --> 00:24:58,060
around to making a rails extension for

00:24:55,900 --> 00:24:59,500
this yet but the that's kind of what I'm

00:24:58,060 --> 00:25:03,030
working towards and what I want to be

00:24:59,500 --> 00:25:06,250
able to do is to replace usages of

00:25:03,030 --> 00:25:08,170
strong parameters in the rails parser

00:25:06,250 --> 00:25:10,630
infrastructure that happens upstream of

00:25:08,170 --> 00:25:16,030
your application with code that looks

00:25:10,630 --> 00:25:18,190
like this so I create a a DSL for muskox

00:25:16,030 --> 00:25:20,170
that sort of wraps it and abstracts some

00:25:18,190 --> 00:25:23,290
of that schema generation so it looks

00:25:20,170 --> 00:25:24,580
almost the same as strong parameters but

00:25:23,290 --> 00:25:27,400
works a little bit differently because

00:25:24,580 --> 00:25:31,390
it it is it won't allow you to be

00:25:27,400 --> 00:25:33,340
ambiguous um there's a lot of work left

00:25:31,390 --> 00:25:37,660
to be done on it so I would like to make

00:25:33,340 --> 00:25:40,720
it so that you can swap out form form

00:25:37,660 --> 00:25:42,100
data processing and XML processing and

00:25:40,720 --> 00:25:44,560
all the other kinds of interesting

00:25:42,100 --> 00:25:46,270
inputs that rails applications and other

00:25:44,560 --> 00:25:48,880
Ruby applications tend to receive from

00:25:46,270 --> 00:25:50,980
the internet because i feel like the the

00:25:48,880 --> 00:25:53,200
validator back end part could be used

00:25:50,980 --> 00:25:56,740
for other for anything that you expect

00:25:53,200 --> 00:25:58,630
to turn into ashes in a raise so if you

00:25:56,740 --> 00:26:00,190
want to learn more about lang sec you

00:25:58,630 --> 00:26:02,830
can go to links a korg there's a lot of

00:26:00,190 --> 00:26:04,690
links to good talks that go into a lot

00:26:02,830 --> 00:26:12,160
more depth than I did and if you want to

00:26:04,690 --> 00:26:15,090
check out muskox it's on github all

00:26:12,160 --> 00:26:15,090
right good job dude

00:26:44,360 --> 00:26:46,420

YouTube URL: https://www.youtube.com/watch?v=4EwuuSLr2Lk


