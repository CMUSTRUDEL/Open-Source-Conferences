Title: MountainWest RubyConf 2014 - Re-thinking Regression Testing by Mario Gonzalez
Publication date: 2020-01-24
Playlist: MWRC 2014
Description: 
	Regression testing is invaluable to knowing if changes to code have broken the software. However, it always seems to be the case that no matter how many tests you have in your regression buckets, bugs continue to happily creep in undetected. As a result, you are not sure if you can trust your tests anymore or your methodology, and you are ready to change that. I will present a powerful technique called mutation testing that will help make your tests capable of detecting future bugs. I will also give you a metric to assess the effectiveness of your tests in terms of regression, so that future changes in your software can be done with impunity.
Audience will learn:
What mutation testing is and why it works.
When and how to apply mutation testing.
How to improve their tests so they detect bugs that are introduced during the normal evolution of software.

Help us caption & translate this video!

http://amara.org/v/FG2m/
Captions: 
	00:00:25,100 --> 00:00:32,220
everyone hear me here we fine all right

00:00:29,369 --> 00:00:35,280
sorry for I'm from out of town I'm from

00:00:32,220 --> 00:00:37,050
Tucson I still have to son time zone so

00:00:35,280 --> 00:00:38,940
that's when you know you're having a

00:00:37,050 --> 00:00:47,820
good trip right you're you're late for

00:00:38,940 --> 00:00:53,570
everything all right so speaking of

00:00:47,820 --> 00:00:57,060
Tucson I found out my Sam Rollins is

00:00:53,570 --> 00:00:59,910
when my classmates from the U of A so

00:00:57,060 --> 00:01:04,890
Sam is if you're still here this hi hope

00:00:59,910 --> 00:01:07,890
we can talk later all right so my name

00:01:04,890 --> 00:01:11,520
is Mario Gonzalez and I want to talk to

00:01:07,890 --> 00:01:14,460
you about regression testing rethinking

00:01:11,520 --> 00:01:16,040
regression testing but why do we need to

00:01:14,460 --> 00:01:18,570
talk about regression testing anymore

00:01:16,040 --> 00:01:23,940
all right it's widely understood it's

00:01:18,570 --> 00:01:26,369
widely used practice well the reason is

00:01:23,940 --> 00:01:29,310
because of confidence or rather the lack

00:01:26,369 --> 00:01:31,229
of confidence in our tests because even

00:01:29,310 --> 00:01:33,990
though we trust our test one hundred

00:01:31,229 --> 00:01:37,740
percent we don't really know where their

00:01:33,990 --> 00:01:40,740
weak spots are example or whether they

00:01:37,740 --> 00:01:43,200
have blind spots in where they are we

00:01:40,740 --> 00:01:46,229
don't know we have over test at an area

00:01:43,200 --> 00:01:48,869
of our product and lift others under

00:01:46,229 --> 00:01:51,830
test and by how much or whether we have

00:01:48,869 --> 00:01:53,610
left them untested completely okay and

00:01:51,830 --> 00:01:55,080
some of you might be thinking well

00:01:53,610 --> 00:01:57,210
there's code coverage for that right

00:01:55,080 --> 00:01:59,490
code coverage tells us a good is a good

00:01:57,210 --> 00:02:02,880
indicator for for the quality of our

00:01:59,490 --> 00:02:05,250
tests well not really and let me show

00:02:02,880 --> 00:02:06,210
you some numbers and and i'll tell you

00:02:05,250 --> 00:02:10,229
where these numbers come from in a

00:02:06,210 --> 00:02:12,810
moment so the average test suite the

00:02:10,229 --> 00:02:15,150
average Ruby test suite captures around

00:02:12,810 --> 00:02:19,709
eighty five percent code coverage okay

00:02:15,150 --> 00:02:22,079
that's not bad right and then in our

00:02:19,709 --> 00:02:23,970
sincere efforts to try to minimize those

00:02:22,079 --> 00:02:27,840
gaps because we know the holes exist in

00:02:23,970 --> 00:02:29,880
our tests we introduce redundancy in our

00:02:27,840 --> 00:02:32,760
tests right and these are these are not

00:02:29,880 --> 00:02:34,319
exact duplicates of every every test

00:02:32,760 --> 00:02:35,999
exact copies

00:02:34,319 --> 00:02:37,890
are they are tests that are testing

00:02:35,999 --> 00:02:40,889
ultimately the same thing by doing it in

00:02:37,890 --> 00:02:43,739
widely different ways right so the

00:02:40,889 --> 00:02:45,989
average test suite has an average of

00:02:43,739 --> 00:02:49,650
twenty-five percent redundancy built in

00:02:45,989 --> 00:02:52,950
and yet the actual regression detection

00:02:49,650 --> 00:02:56,849
capability of our tests is only

00:02:52,950 --> 00:02:58,769
fifty-five percent ok so is code

00:02:56,849 --> 00:03:02,579
coverage a good indicator of the quality

00:02:58,769 --> 00:03:04,079
of our tests no not really it's good to

00:03:02,579 --> 00:03:07,680
have what it's a second-order metric

00:03:04,079 --> 00:03:10,980
okay it's a proxy metric so where do

00:03:07,680 --> 00:03:14,489
these numbers come from so the work I do

00:03:10,980 --> 00:03:17,389
in my company or task is research and I

00:03:14,489 --> 00:03:20,280
research focused on software quality and

00:03:17,389 --> 00:03:22,409
the reason I started my company was

00:03:20,280 --> 00:03:25,139
because I noticed these these this

00:03:22,409 --> 00:03:27,030
pattern in my own projects and the

00:03:25,139 --> 00:03:30,000
projects of the teams i was working with

00:03:27,030 --> 00:03:33,599
as well and we were following best

00:03:30,000 --> 00:03:35,579
practices test driven development and I

00:03:33,599 --> 00:03:38,939
was trying to achieve high code coverage

00:03:35,579 --> 00:03:41,780
and yet our projects were riddled with

00:03:38,939 --> 00:03:48,689
bugs were still riddled with bugs right

00:03:41,780 --> 00:03:50,459
so last year I finished to research

00:03:48,689 --> 00:03:52,259
projects basically one one of them was

00:03:50,459 --> 00:03:54,180
focused on the effects of test

00:03:52,259 --> 00:03:56,790
redundancy and that's where that's where

00:03:54,180 --> 00:04:00,470
the redundancy and code coverage numbers

00:03:56,790 --> 00:04:04,560
are coming from and and also finished a

00:04:00,470 --> 00:04:07,319
still unpublished study about regression

00:04:04,560 --> 00:04:08,849
okay and that's where the regression

00:04:07,319 --> 00:04:11,939
detection and code coverage are coming

00:04:08,849 --> 00:04:15,000
from so they strengthen each other so in

00:04:11,939 --> 00:04:17,340
in this presentation I want to focus on

00:04:15,000 --> 00:04:19,109
the regression detection capability of

00:04:17,340 --> 00:04:22,320
our tests how to how to measure it

00:04:19,109 --> 00:04:24,960
accurately and then how to improve it

00:04:22,320 --> 00:04:26,849
okay and the way we're going to do that

00:04:24,960 --> 00:04:30,389
is with a technique called mutation

00:04:26,849 --> 00:04:32,520
testing a mutation analysis okay and I

00:04:30,389 --> 00:04:34,560
know there's been in previous

00:04:32,520 --> 00:04:38,400
conferences there's been presentations

00:04:34,560 --> 00:04:39,690
about mutation analysis and in I'm going

00:04:38,400 --> 00:04:42,000
to do a little bit differently I think

00:04:39,690 --> 00:04:43,370
you already noticed because I'm going to

00:04:42,000 --> 00:04:47,039
be presenting the results of my research

00:04:43,370 --> 00:04:48,150
throughout the presentation and and my

00:04:47,039 --> 00:04:49,830
my goal is

00:04:48,150 --> 00:04:52,910
by the end of this presentation you will

00:04:49,830 --> 00:04:57,660
be empowered to start using this more

00:04:52,910 --> 00:05:00,720
accurate metric to actually assess the

00:04:57,660 --> 00:05:03,420
quality of your of your test and start

00:05:00,720 --> 00:05:05,550
improving them confidently okay so let's

00:05:03,420 --> 00:05:10,050
start talking about why code coverage is

00:05:05,550 --> 00:05:12,000
unreliable okay so suppose that the the

00:05:10,050 --> 00:05:14,580
the graph you're seeing right now the

00:05:12,000 --> 00:05:17,640
curve represents the evolution of your

00:05:14,580 --> 00:05:19,920
software as time goes by okay so on

00:05:17,640 --> 00:05:22,530
there I'm not x axis you have time y

00:05:19,920 --> 00:05:30,000
axis lines of code it's very simplistic

00:05:22,530 --> 00:05:32,610
but it does the work okay so supposing

00:05:30,000 --> 00:05:36,810
we want to get the the slope at a point

00:05:32,610 --> 00:05:39,840
on this curve would it be reasonable to

00:05:36,810 --> 00:05:42,660
expect that that slope would continue on

00:05:39,840 --> 00:05:44,370
forever it wouldn't and that's the

00:05:42,660 --> 00:05:46,860
analogous problem with code coverage

00:05:44,370 --> 00:05:49,200
code coverage is a point in time metric

00:05:46,860 --> 00:05:51,300
right it tells you what your tests are

00:05:49,200 --> 00:05:53,190
covering right now but it has no

00:05:51,300 --> 00:05:56,340
relevance to what they're going to cover

00:05:53,190 --> 00:05:58,370
tomorrow or a month from now okay

00:05:56,340 --> 00:06:00,450
because our software changes so much

00:05:58,370 --> 00:06:02,400
that's why code coverage feels like a

00:06:00,450 --> 00:06:05,370
like a game of catch up all the time

00:06:02,400 --> 00:06:06,600
right because we're it's almost

00:06:05,370 --> 00:06:08,160
impossible to achieve one hundred

00:06:06,600 --> 00:06:13,680
percent code coverage every single day

00:06:08,160 --> 00:06:17,040
okay what we need is the better a better

00:06:13,680 --> 00:06:20,340
way to assess the quality of our tests

00:06:17,040 --> 00:06:22,830
and that that's where mutation analysis

00:06:20,340 --> 00:06:25,320
comes in that's where the mutation score

00:06:22,830 --> 00:06:28,380
the associated mutations score shines

00:06:25,320 --> 00:06:30,870
okay so let's talk about the mutation

00:06:28,380 --> 00:06:33,270
score what is it so the mutation score

00:06:30,870 --> 00:06:36,570
is a is a ratio it's actually a

00:06:33,270 --> 00:06:38,880
probability okay you can have your worst

00:06:36,570 --> 00:06:40,890
score which means that you have zero

00:06:38,880 --> 00:06:43,920
percent probability of detecting of your

00:06:40,890 --> 00:06:46,680
test detecting regressions or you can

00:06:43,920 --> 00:06:48,570
have one or one hundred percent which is

00:06:46,680 --> 00:06:50,430
100 probability of detecting regressions

00:06:48,570 --> 00:06:53,400
this of course is the best score and

00:06:50,430 --> 00:06:55,320
it's called mutation adequate ok so

00:06:53,400 --> 00:06:57,900
there's mutation in the name mutation

00:06:55,320 --> 00:06:59,610
analysis but what do we mutate so

00:06:57,900 --> 00:07:01,980
mutation analysis is a type of fault

00:06:59,610 --> 00:07:04,590
injection when we don't introduce

00:07:01,980 --> 00:07:06,660
use new code although we could we

00:07:04,590 --> 00:07:09,750
actually change what's already there we

00:07:06,660 --> 00:07:12,420
mutate the existing source code and we

00:07:09,750 --> 00:07:14,970
leave our tests unmodified okay because

00:07:12,420 --> 00:07:18,690
we're going to test our tests all right

00:07:14,970 --> 00:07:21,930
it's kind of meta right so for example

00:07:18,690 --> 00:07:24,320
if in our if an hour source code we find

00:07:21,930 --> 00:07:27,600
an arithmetic operator we change it and

00:07:24,320 --> 00:07:32,610
we run our unmodified tests on that on

00:07:27,600 --> 00:07:36,030
that mutant if one of our tests at least

00:07:32,610 --> 00:07:37,140
one of our tests fails that's a good

00:07:36,030 --> 00:07:40,520
thing we say that the mutant has been

00:07:37,140 --> 00:07:42,990
killed and it means that our tests are

00:07:40,520 --> 00:07:45,330
they have a high probability of

00:07:42,990 --> 00:07:49,440
detecting this kind of regression if we

00:07:45,330 --> 00:07:51,030
ever introduced this regression now

00:07:49,440 --> 00:07:53,250
suppose we encounter a relational

00:07:51,030 --> 00:07:55,890
operator in our source code well we

00:07:53,250 --> 00:08:00,150
change it and we run or unmodified tests

00:07:55,890 --> 00:08:01,290
on that okay now suppose that well let

00:08:00,150 --> 00:08:03,210
me let me speak about this mutation

00:08:01,290 --> 00:08:06,570
first of all so this is an interesting

00:08:03,210 --> 00:08:10,290
mutation this is a an instance of a

00:08:06,570 --> 00:08:13,800
class of a type of class of bugs called

00:08:10,290 --> 00:08:16,280
the off by one error right so if when we

00:08:13,800 --> 00:08:19,740
run our unmodified tests on on this if

00:08:16,280 --> 00:08:22,830
none of our tests fail if all our tests

00:08:19,740 --> 00:08:25,920
pass it means that our tests are

00:08:22,830 --> 00:08:29,160
inadequate they have a low probability

00:08:25,920 --> 00:08:33,570
of detecting off by one errors in case

00:08:29,160 --> 00:08:35,040
we ever introduced them okay and of

00:08:33,570 --> 00:08:40,260
course we can flip the relational

00:08:35,040 --> 00:08:42,300
operator so I'm going to have some more

00:08:40,260 --> 00:08:48,890
fun with Windows Lucas want to show you

00:08:42,300 --> 00:08:51,090
a demo and I'm going to run here a

00:08:48,890 --> 00:08:57,360
limitation engine i use for my research

00:08:51,090 --> 00:09:02,010
I was slinging before and okay all right

00:08:57,360 --> 00:09:06,180
so a one run one one mutant gives us a

00:09:02,010 --> 00:09:08,820
binary pass/fail okay that's that's a

00:09:06,180 --> 00:09:10,620
fact well in a moment but what I really

00:09:08,820 --> 00:09:15,380
want to show you right now is how a

00:09:10,620 --> 00:09:15,380
mutation looks okay

00:09:16,040 --> 00:09:24,570
let's see so on your left hand side you

00:09:22,530 --> 00:09:30,810
have the original on the right hand side

00:09:24,570 --> 00:09:34,560
you have the the mutant and we're there

00:09:30,810 --> 00:09:38,430
we go the equal equal has been changed

00:09:34,560 --> 00:09:41,280
to a not equal okay now going back to a

00:09:38,430 --> 00:09:44,670
to the a mutation score so of course

00:09:41,280 --> 00:09:45,930
binary pass/fail 01 to get a like i said

00:09:44,670 --> 00:09:48,060
before mutation analysis is a

00:09:45,930 --> 00:09:49,470
probabilistic technique and if i didn't

00:09:48,060 --> 00:09:52,110
say it before I'm saying it right now

00:09:49,470 --> 00:09:55,170
it's a stochastic technique so to say it

00:09:52,110 --> 00:09:57,000
to get a better mutation score a more

00:09:55,170 --> 00:09:59,130
accurate mutation score we need to run

00:09:57,000 --> 00:10:01,980
at least more time so at least 50 times

00:09:59,130 --> 00:10:04,770
or so so we leave it running for a while

00:10:01,980 --> 00:10:09,950
and come back to it later and see how

00:10:04,770 --> 00:10:11,910
it's doing so how do we get the score

00:10:09,950 --> 00:10:14,070
well the score like I said before is

00:10:11,910 --> 00:10:16,050
just a ratio right it's the total number

00:10:14,070 --> 00:10:18,150
of mutants killed or detected by your

00:10:16,050 --> 00:10:21,960
test they've added a total number of of

00:10:18,150 --> 00:10:24,180
generated mutants and mutation analysis

00:10:21,960 --> 00:10:26,280
is one of those very few techniques in

00:10:24,180 --> 00:10:29,730
software development you can actually

00:10:26,280 --> 00:10:32,550
have fun with because you can have

00:10:29,730 --> 00:10:34,200
mutant scale or zombie scale or ninja

00:10:32,550 --> 00:10:35,340
skill right and and the reason I'm

00:10:34,200 --> 00:10:38,480
trying to say this the reason I'm saying

00:10:35,340 --> 00:10:41,910
this is because the more fun you have

00:10:38,480 --> 00:10:43,440
applying a technique the more you will

00:10:41,910 --> 00:10:45,930
find yourself applying it consistently

00:10:43,440 --> 00:10:47,520
and the more consistently you will

00:10:45,930 --> 00:10:51,600
improve your test and therefore the

00:10:47,520 --> 00:10:53,520
quality or software okay so how many

00:10:51,600 --> 00:10:55,500
mutants should we should we have in that

00:10:53,520 --> 00:11:00,030
in the demo I just showed you we have

00:10:55,500 --> 00:11:01,890
only one one mutation okay so should we

00:11:00,030 --> 00:11:03,870
have more than that should we mutate the

00:11:01,890 --> 00:11:06,570
entire source file and run with that

00:11:03,870 --> 00:11:12,320
well let's let's agree on something

00:11:06,570 --> 00:11:14,810
before so let the permutation quantity

00:11:12,320 --> 00:11:19,800
let it be represented by the variable K

00:11:14,810 --> 00:11:22,410
the aptly-named variable K alright so

00:11:19,800 --> 00:11:24,000
back when when the researcher mutation

00:11:22,410 --> 00:11:26,790
analysis was was beginning back in the

00:11:24,000 --> 00:11:29,279
1970s the original researchers made a

00:11:26,790 --> 00:11:33,379
big assumption and this assumption

00:11:29,279 --> 00:11:36,540
has been validated meaning that it has

00:11:33,379 --> 00:11:39,600
overwhelming evidence in his favor my

00:11:36,540 --> 00:11:44,249
dick is a research ok now this

00:11:39,600 --> 00:11:46,170
assumption is is one of two pillars

00:11:44,249 --> 00:11:47,730
making the foundation for mutation

00:11:46,170 --> 00:11:50,730
analysis it's called the competent

00:11:47,730 --> 00:11:53,809
programmer hypothesis okay and what it

00:11:50,730 --> 00:11:56,790
says is that experienced programmers

00:11:53,809 --> 00:12:01,019
create code that is almost there almost

00:11:56,790 --> 00:12:02,879
correct right and those gaps the

00:12:01,019 --> 00:12:05,670
remaining gaps are the bugs and those

00:12:02,879 --> 00:12:09,809
bugs are the small syntactic errors like

00:12:05,670 --> 00:12:16,680
off by one errors all right so in terms

00:12:09,809 --> 00:12:19,410
of our oops in terms of our mutation

00:12:16,680 --> 00:12:22,470
quantity variable K research has shown

00:12:19,410 --> 00:12:25,170
that we can we only need one mutation to

00:12:22,470 --> 00:12:27,079
capture this area this class of bugs

00:12:25,170 --> 00:12:31,769
introduced by experienced programmers

00:12:27,079 --> 00:12:33,779
okay now let's talk about kyk so in in

00:12:31,769 --> 00:12:35,910
in software engineering and engineering

00:12:33,779 --> 00:12:37,680
insight in science in general we rename

00:12:35,910 --> 00:12:40,199
things to be able to talk about about

00:12:37,680 --> 00:12:43,170
them with with other people so that when

00:12:40,199 --> 00:12:46,470
there's only one mutation we call the

00:12:43,170 --> 00:12:49,259
mutant a first-order mutant okay if

00:12:46,470 --> 00:12:52,259
there's two mutations we call it a

00:12:49,259 --> 00:12:54,149
second-order mutant and in general chem

00:12:52,259 --> 00:12:57,089
mutations leads to a que order mutant

00:12:54,149 --> 00:12:59,670
it's okay the reason why it's so cryptic

00:12:57,089 --> 00:13:01,709
k is just easy to communicate k order

00:12:59,670 --> 00:13:08,009
like a like the error t our relation

00:13:01,709 --> 00:13:10,559
unary binary ternary kre okay so first

00:13:08,009 --> 00:13:11,850
order mutants are also called low-order

00:13:10,559 --> 00:13:15,839
Muse because that that class is very

00:13:11,850 --> 00:13:18,420
important okay but then the rest of a

00:13:15,839 --> 00:13:21,629
class right the rest of the bugs the

00:13:18,420 --> 00:13:24,509
rest of the mutants capture are called

00:13:21,629 --> 00:13:26,970
um higher-order mutants okay in the

00:13:24,509 --> 00:13:28,829
capture the rest of the bugs so why

00:13:26,970 --> 00:13:32,399
would we ever want to have high order

00:13:28,829 --> 00:13:34,649
mutants well if you remember I said that

00:13:32,399 --> 00:13:37,079
competent program hypothesis is one of

00:13:34,649 --> 00:13:40,079
two pillars making the foundation for

00:13:37,079 --> 00:13:42,940
mutation analysis the other pillar is

00:13:40,079 --> 00:13:45,220
called the coupling effect okay

00:13:42,940 --> 00:13:49,540
and this is the i call it the nasty bug

00:13:45,220 --> 00:13:52,720
effect because it says as the the rest

00:13:49,540 --> 00:13:54,430
of the bugs are actually combinations

00:13:52,720 --> 00:13:55,860
are the effects of these small errors

00:13:54,430 --> 00:13:58,720
introduced by experienced programmers

00:13:55,860 --> 00:14:00,310
and the reason i call it the the nasty

00:13:58,720 --> 00:14:02,980
bug effect is because these are the

00:14:00,310 --> 00:14:04,860
types of bugs that you're investigating

00:14:02,980 --> 00:14:06,970
and all the sudden they disappear and

00:14:04,860 --> 00:14:08,890
you didn't do anything but it turns out

00:14:06,970 --> 00:14:13,120
that someone made a change somewhere in

00:14:08,890 --> 00:14:17,770
the code that caused the effect or the

00:14:13,120 --> 00:14:19,810
coupling to disappear okay so this has

00:14:17,770 --> 00:14:21,850
also been shown by by decades of

00:14:19,810 --> 00:14:23,950
research to be a valid hypothesis that's

00:14:21,850 --> 00:14:26,650
why there these two are other pillars of

00:14:23,950 --> 00:14:28,780
mutation analysis in terms of our

00:14:26,650 --> 00:14:31,570
variable K the mutation quantity we only

00:14:28,780 --> 00:14:34,960
need between two and five mutations to

00:14:31,570 --> 00:14:38,260
capture this this area of bugs this

00:14:34,960 --> 00:14:40,390
class of buzz ok so we've seen that why

00:14:38,260 --> 00:14:43,210
mutation analysis works and why it's a

00:14:40,390 --> 00:14:45,340
perfect match to assess the regression

00:14:43,210 --> 00:14:49,110
detection capability of our our tests

00:14:45,340 --> 00:14:52,030
okay because we have one contributor

00:14:49,110 --> 00:14:55,780
committing code for a bug fix or or a

00:14:52,030 --> 00:14:57,340
feature then we have that competent

00:14:55,780 --> 00:15:00,190
hopefully competent programmer

00:14:57,340 --> 00:15:03,580
hypothesis in effect right and then to a

00:15:00,190 --> 00:15:05,770
certain degree the coupling effect now

00:15:03,580 --> 00:15:08,800
if we compound that with many

00:15:05,770 --> 00:15:12,430
contributors we have both hypotheses in

00:15:08,800 --> 00:15:19,840
effect so what so why is it better than

00:15:12,430 --> 00:15:24,880
code coverage so I should you start

00:15:19,840 --> 00:15:27,030
using it more than code coverage so let

00:15:24,880 --> 00:15:29,070
me show you some results of my research

00:15:27,030 --> 00:15:31,030
what are you seeing here is called

00:15:29,070 --> 00:15:34,150
correlations linear correlations or

00:15:31,030 --> 00:15:35,770
pearson correlations okay so let's let's

00:15:34,150 --> 00:15:38,400
focus on the on the correlation between

00:15:35,770 --> 00:15:40,210
code coverage and mutation score now

00:15:38,400 --> 00:15:42,040
correlations can have pearson

00:15:40,210 --> 00:15:44,050
correlations can have to maximum effects

00:15:42,040 --> 00:15:47,500
to maximum strength negative 1 and

00:15:44,050 --> 00:15:50,740
positive 1 okay a negative 1 is a

00:15:47,500 --> 00:15:52,480
one-to-one downward correspondence and a

00:15:50,740 --> 00:15:55,150
positive one is one-to-one upward

00:15:52,480 --> 00:15:56,670
correspondence all right you can see

00:15:55,150 --> 00:16:00,339
here it's

00:15:56,670 --> 00:16:02,680
positive is pretty close to one meaning

00:16:00,339 --> 00:16:07,749
that the higher your mutation score the

00:16:02,680 --> 00:16:11,589
higher your code coverage okay but the

00:16:07,749 --> 00:16:15,670
opposite is not true okay you can see

00:16:11,589 --> 00:16:17,410
that the cluster of test suites that are

00:16:15,670 --> 00:16:19,389
already achieving a hundred percent code

00:16:17,410 --> 00:16:22,600
coverage code coverage azonda is on the

00:16:19,389 --> 00:16:27,249
x-axis by the way is only achieving a

00:16:22,600 --> 00:16:29,829
mere 75% mutation score okay so mutation

00:16:27,249 --> 00:16:33,249
score is a much stronger more reliable

00:16:29,829 --> 00:16:35,589
metric than code coverage but we can we

00:16:33,249 --> 00:16:37,540
can flip it also and we can see the

00:16:35,589 --> 00:16:39,730
positive side we can see that the

00:16:37,540 --> 00:16:43,480
cluster of sweets already achieving a

00:16:39,730 --> 00:16:46,360
mirror or only achieving a mere 75%

00:16:43,480 --> 00:16:51,639
mutation score are achieving already one

00:16:46,360 --> 00:16:52,779
hundred percent code coverage now let's

00:16:51,639 --> 00:16:59,259
look at that correlation between code

00:16:52,779 --> 00:17:02,230
coverage and test redundancy so it's a

00:16:59,259 --> 00:17:04,689
negative correlation and it's very

00:17:02,230 --> 00:17:06,909
strong very close to one as well what

00:17:04,689 --> 00:17:09,730
that means is that the higher your test

00:17:06,909 --> 00:17:12,399
redundancy the lower your code coverage

00:17:09,730 --> 00:17:19,409
or rather the lower the effect of code

00:17:12,399 --> 00:17:23,230
coverage okay now it turns out that the

00:17:19,409 --> 00:17:24,850
test redundancy is a smell it's an

00:17:23,230 --> 00:17:26,549
indication of a problem of a deeper

00:17:24,850 --> 00:17:29,740
problem with the quality of our test

00:17:26,549 --> 00:17:31,899
okay now this doesn't explain why you'll

00:17:29,740 --> 00:17:34,240
see why in the next slide but what this

00:17:31,899 --> 00:17:38,490
explains is that code coverage is highly

00:17:34,240 --> 00:17:45,549
susceptible to redundancy in our tests

00:17:38,490 --> 00:17:48,460
okay so to talk about white s3000 see is

00:17:45,549 --> 00:17:50,559
a smell let's talk about something that

00:17:48,460 --> 00:17:54,190
we really care about bugs and like

00:17:50,559 --> 00:17:57,940
little bugs right so you can see the

00:17:54,190 --> 00:18:02,590
correlation on your right and your left

00:17:57,940 --> 00:18:04,570
and your right my left with code

00:18:02,590 --> 00:18:08,049
likelihood of bugs and code coverage

00:18:04,570 --> 00:18:10,419
okay it's a negative correlation meaning

00:18:08,049 --> 00:18:12,489
that the higher the code coverage

00:18:10,419 --> 00:18:16,739
the lower the likelihood of bugs and

00:18:12,489 --> 00:18:20,440
that's expected that makes sense right

00:18:16,739 --> 00:18:22,960
well unfortunately the correlation

00:18:20,440 --> 00:18:25,330
between like little bugs and test

00:18:22,960 --> 00:18:28,090
redundancy is practically the same but

00:18:25,330 --> 00:18:30,039
it's positive the higher your redundancy

00:18:28,090 --> 00:18:32,499
the higher your likelihood of bugs and I

00:18:30,039 --> 00:18:33,940
was that surprised me okay but that the

00:18:32,499 --> 00:18:35,940
results of the research surprised me I

00:18:33,940 --> 00:18:39,399
wasn't expecting that to happen I

00:18:35,940 --> 00:18:41,499
thought that having redundancy in our

00:18:39,399 --> 00:18:44,649
tests was only a good thing they they

00:18:41,499 --> 00:18:47,139
they maximize the effect of our the

00:18:44,649 --> 00:18:49,659
effectiveness of our test Suites right

00:18:47,139 --> 00:18:53,169
but turns out that's not the case that's

00:18:49,659 --> 00:18:55,359
why test redundancy is a smell all right

00:18:53,169 --> 00:18:57,519
because they increase somehow the

00:18:55,359 --> 00:18:59,830
likelihood of bugs in the way if I've

00:18:57,519 --> 00:19:03,220
come to explain it and understand it is

00:18:59,830 --> 00:19:05,499
by way of analogy so suppose it you need

00:19:03,220 --> 00:19:08,350
to one of your tires your car or your

00:19:05,499 --> 00:19:09,820
your bicycle your motorcycle is under

00:19:08,350 --> 00:19:12,850
inflated and you need to inflate your

00:19:09,820 --> 00:19:14,619
tire now suppose that you want to add

00:19:12,850 --> 00:19:16,509
you the site to over inflate your tire

00:19:14,619 --> 00:19:20,320
in the hopes that you won't have to

00:19:16,509 --> 00:19:22,749
inflate anytime soon nothing wrong will

00:19:20,320 --> 00:19:25,299
happen right well the problem with that

00:19:22,749 --> 00:19:28,539
is that not only do you decrease the

00:19:25,299 --> 00:19:29,769
traction of your tire when you're over

00:19:28,539 --> 00:19:31,619
inflate and therefore you spend more

00:19:29,769 --> 00:19:34,210
energy getting from point A to point B

00:19:31,619 --> 00:19:42,759
but you also decrease the life of your

00:19:34,210 --> 00:19:45,399
tire okay in a analogous way if we when

00:19:42,759 --> 00:19:49,570
we over inflate our test so to speak

00:19:45,399 --> 00:19:51,700
we're introducing technical debt we're

00:19:49,570 --> 00:19:54,999
over testing an area of our product of

00:19:51,700 --> 00:19:56,980
our application and leaving under others

00:19:54,999 --> 00:19:59,470
under test that or completely untested

00:19:56,980 --> 00:20:01,119
in it and my hypothesis is that's where

00:19:59,470 --> 00:20:06,730
the bugs are creeping in that's why the

00:20:01,119 --> 00:20:08,009
effect of coverage goes down okay so

00:20:06,730 --> 00:20:10,749
let's look at correlations between

00:20:08,009 --> 00:20:15,509
mutation scores a focal point and in the

00:20:10,749 --> 00:20:18,789
other two metrics you can see that these

00:20:15,509 --> 00:20:20,619
correlations so of course you have the

00:20:18,789 --> 00:20:23,970
same correlations before between code

00:20:20,619 --> 00:20:25,380
coverage and mutations 4.86

00:20:23,970 --> 00:20:27,450
that's the same as before we already

00:20:25,380 --> 00:20:30,890
talked about that but what about code

00:20:27,450 --> 00:20:33,390
test redundancy it's still negative

00:20:30,890 --> 00:20:35,460
meaning that mutation score is still

00:20:33,390 --> 00:20:39,410
susceptible to redundancy in our tests

00:20:35,460 --> 00:20:42,030
but not as susceptible as code coverage

00:20:39,410 --> 00:20:45,630
all right so now let's talk about how to

00:20:42,030 --> 00:20:47,400
apply mutation analysis okay hopefully

00:20:45,630 --> 00:20:51,150
right by now you're inspired to to see

00:20:47,400 --> 00:20:53,730
how to apply it so I'm listening here

00:20:51,150 --> 00:20:55,650
several mutation analysis tools for

00:20:53,730 --> 00:21:00,060
several languages the first two are for

00:20:55,650 --> 00:21:03,930
Ruby second second to or for java than

00:21:00,060 --> 00:21:05,430
the last one is for C for.net now for my

00:21:03,930 --> 00:21:07,440
research unfortunately I wasn't able to

00:21:05,430 --> 00:21:10,710
use the wreath at the Ruby ones at first

00:21:07,440 --> 00:21:12,060
too because heckle it was already out of

00:21:10,710 --> 00:21:14,580
supporting that in that version of Ruby

00:21:12,060 --> 00:21:18,030
I was using and mutant was a release

00:21:14,580 --> 00:21:22,230
candidate okay but of course now mutant

00:21:18,030 --> 00:21:26,490
has been released and you can use it but

00:21:22,230 --> 00:21:30,120
I wanna just want to say that so I

00:21:26,490 --> 00:21:32,610
wasn't able to use those those tools so

00:21:30,120 --> 00:21:34,860
i had to write my own basically in a way

00:21:32,610 --> 00:21:37,110
that was as silly as that sounds in a

00:21:34,860 --> 00:21:38,940
way that was fast and accurate in

00:21:37,110 --> 00:21:40,830
cross-language because i needed to use

00:21:38,940 --> 00:21:43,980
it for ruby and java and python and and

00:21:40,830 --> 00:21:48,480
this and that okay so if you're

00:21:43,980 --> 00:21:51,270
interested check it out now the major

00:21:48,480 --> 00:21:53,820
remark I've heard from people against

00:21:51,270 --> 00:21:56,850
mutation analysis is that it's very

00:21:53,820 --> 00:21:57,950
difficult and very slow okay you just

00:21:56,850 --> 00:22:00,690
want to share with you some guidelines

00:21:57,950 --> 00:22:03,690
for a painless way to apply mutation

00:22:00,690 --> 00:22:06,240
analysis and you at your work all right

00:22:03,690 --> 00:22:08,970
so first guideline is you don't have

00:22:06,240 --> 00:22:10,470
passing tests now this is not a chicken

00:22:08,970 --> 00:22:12,600
and egg problem this you don't have to

00:22:10,470 --> 00:22:14,850
have correct passing tests you just need

00:22:12,600 --> 00:22:17,040
to have passed and test okay because if

00:22:14,850 --> 00:22:23,280
you get a mutation score of zero you can

00:22:17,040 --> 00:22:25,230
only go up right you're good now the

00:22:23,280 --> 00:22:27,510
issue with mutants okay let me let me

00:22:25,230 --> 00:22:32,040
show you we left the mutation engine

00:22:27,510 --> 00:22:35,670
running for 50 mutants you can get my

00:22:32,040 --> 00:22:37,890
cursor back alright and you can see now

00:22:35,670 --> 00:22:42,660
the mutation score is much more active

00:22:37,890 --> 00:22:43,920
it than before but you can see it was

00:22:42,660 --> 00:22:45,570
actually pretty fast too in less than

00:22:43,920 --> 00:22:49,230
five minutes we have a good mutation

00:22:45,570 --> 00:22:50,940
score for one test suite okay so if you

00:22:49,230 --> 00:22:53,640
follow these these practices these

00:22:50,940 --> 00:22:58,710
guidelines you'll be fine so the reason

00:22:53,640 --> 00:23:02,010
we decided on 50 mutants okay was for a

00:22:58,710 --> 00:23:07,200
very good reason in my research I had to

00:23:02,010 --> 00:23:12,420
run 10,000 mutants per test suite to get

00:23:07,200 --> 00:23:14,820
a very very low error margin but you

00:23:12,420 --> 00:23:16,470
don't have to go that far you can take

00:23:14,820 --> 00:23:20,040
advantage of our property of statistics

00:23:16,470 --> 00:23:21,810
call the central limit theorem which

00:23:20,040 --> 00:23:24,390
says that with with a sufficient sample

00:23:21,810 --> 00:23:27,060
size the average value starts becoming a

00:23:24,390 --> 00:23:29,880
parent okay and that sufficient sample

00:23:27,060 --> 00:23:32,070
size for our intents and purposes is 50

00:23:29,880 --> 00:23:34,770
of course the higher sample size the

00:23:32,070 --> 00:23:37,920
better and you wanna you want to focus

00:23:34,770 --> 00:23:40,500
on low order mutants okay to capture is

00:23:37,920 --> 00:23:42,960
to make sure that your test detect those

00:23:40,500 --> 00:23:44,340
class of bugs introduced by experienced

00:23:42,960 --> 00:23:45,930
programmers but you also want to

00:23:44,340 --> 00:23:47,820
experiment with high order mutants to

00:23:45,930 --> 00:23:51,570
make sure that your tests can detect the

00:23:47,820 --> 00:23:53,130
nasty bugs now there's a cycle for

00:23:51,570 --> 00:23:56,660
mutation analysis just like with

00:23:53,130 --> 00:23:59,460
refactoring right red green refactor

00:23:56,660 --> 00:24:01,290
mutation analysis is very easy you

00:23:59,460 --> 00:24:04,280
follow this cycle so you mutate like you

00:24:01,290 --> 00:24:08,010
saw before then you score your test

00:24:04,280 --> 00:24:11,360
right like you just saw and based on

00:24:08,010 --> 00:24:17,520
that you can actually improve it because

00:24:11,360 --> 00:24:20,910
for every live mutant it means that your

00:24:17,520 --> 00:24:24,180
tests are have a whole related to that

00:24:20,910 --> 00:24:28,800
mutant okay so for example if you recall

00:24:24,180 --> 00:24:31,800
we had the off by one error and if our

00:24:28,800 --> 00:24:34,320
tests didn't detect it no note has

00:24:31,800 --> 00:24:36,660
failed it means that we have a blatant

00:24:34,320 --> 00:24:38,280
hole right there a weak spot and that's

00:24:36,660 --> 00:24:41,160
where we need to focus so mutation

00:24:38,280 --> 00:24:44,270
analysis gives us a really good metric

00:24:41,160 --> 00:24:48,050
to use but also a really good guide and

00:24:44,270 --> 00:24:51,810
tells us where exactly our tests network

00:24:48,050 --> 00:24:53,820
okay and last guideline

00:24:51,810 --> 00:24:56,160
award an uncoupling you really want to

00:24:53,820 --> 00:24:58,680
follow good engineering practices you

00:24:56,160 --> 00:25:00,450
want to have low couple code all right

00:24:58,680 --> 00:25:02,970
with with highly couple code the

00:25:00,450 --> 00:25:06,030
mutation score is really really low and

00:25:02,970 --> 00:25:08,430
effectively useless but I guess on the

00:25:06,030 --> 00:25:11,550
flip side you can you might be able to

00:25:08,430 --> 00:25:13,290
use mutation analysis as a tool to

00:25:11,550 --> 00:25:15,230
detect highly couple code I'm not no I'm

00:25:13,290 --> 00:25:18,690
not sure if that would work though but

00:25:15,230 --> 00:25:22,560
anyway alright so so now I hope that

00:25:18,690 --> 00:25:25,380
that you feel empowered to start using

00:25:22,560 --> 00:25:28,560
this this really all technique but

00:25:25,380 --> 00:25:31,110
really really useful technique okay to

00:25:28,560 --> 00:25:32,940
actually start engineering your tests so

00:25:31,110 --> 00:25:35,490
that they can have the quality that you

00:25:32,940 --> 00:25:38,670
want them to have and so they give you

00:25:35,490 --> 00:25:40,770
confidence all right and I hope that you

00:25:38,670 --> 00:25:44,010
also feel inspired to start bumping code

00:25:40,770 --> 00:25:47,130
coverage down the hierarchy okay because

00:25:44,010 --> 00:25:50,010
it's a second-order metric is useful but

00:25:47,130 --> 00:25:51,630
not for the way we wanted to use okay we

00:25:50,010 --> 00:25:54,270
wanted to tell us the quality of our

00:25:51,630 --> 00:25:56,600
test that's not going to happen all

00:25:54,270 --> 00:25:56,600

YouTube URL: https://www.youtube.com/watch?v=H8lBCI_TQ8E


