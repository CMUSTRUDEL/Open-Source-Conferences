Title: Functional C# - Developer South Coast - May 2018
Publication date: 2018-05-22
Playlist: Developer South Coast
Description: 
	Main Session

Functional programming has been one of the major trends in software development over the last few years. Most of the more useful/important new features of C# in the last few versions have been ported from or inspired by features in F# (e.g. Generics, LINQ and Tuples). This session will look how you can utilise core functional techniques like immutable types and pure functions along with a number of functional features added to the C# language over the last couple of versions to produce code that is easier to reason about and less likely to contain bugs.

Speaker Bio

Experienced developer with over 20 years on the Microsoft stack from VB6, though .Net from 1.1 and laterly in F#. Active in the .Net community for over 10 years from attending alt.net conferences and NxtGenUG, through speaking at user groups and conferences around the UK to starting and running the CraftyCoders and Warwickshire.Net user groups. I have been presenting sessions for 10 years and on functional programming for over 5 years to whoever will allow the time to listen and learn. I still consider myself to be an alt.net developer.
Captions: 
	00:00:00,030 --> 00:00:05,730
thank you and so my name's Ian Russell

00:00:02,970 --> 00:00:07,290
as as rich said I've not been here for

00:00:05,730 --> 00:00:09,000
four and a half years I didn't think I

00:00:07,290 --> 00:00:12,809
was that bad last time I have to say but

00:00:09,000 --> 00:00:15,330
maybe I was and that's my Twitter handle

00:00:12,809 --> 00:00:17,970
hi J Russell and I made to talk about

00:00:15,330 --> 00:00:19,830
functional c-sharp unfortunately there

00:00:17,970 --> 00:00:25,980
will be smashed shelf as well but it

00:00:19,830 --> 00:00:28,769
will be in the context of C chart so

00:00:25,980 --> 00:00:29,939
they have a quick introduction and a

00:00:28,769 --> 00:00:32,309
basic idea of what functional

00:00:29,939 --> 00:00:36,059
programming is and it's a very

00:00:32,309 --> 00:00:38,520
high-level view of it have a bit of a

00:00:36,059 --> 00:00:41,040
 about ROP and how much more

00:00:38,520 --> 00:00:42,809
wonderful FPS than it but I'll try and

00:00:41,040 --> 00:00:45,270
keep it fair and then basically we're

00:00:42,809 --> 00:00:46,680
gonna do some code yeah I think that's

00:00:45,270 --> 00:00:52,500
the best way to learn functional

00:00:46,680 --> 00:00:55,379
programming so functional programming

00:00:52,500 --> 00:00:57,390
it's old and based on the ideas of

00:00:55,379 --> 00:00:59,030
Alonzo Church who did lambda calculus

00:00:57,390 --> 00:01:00,899
back in the 30s

00:00:59,030 --> 00:01:03,600
obviously from tional program didn't

00:01:00,899 --> 00:01:06,630
exist in computers didn't but it's

00:01:03,600 --> 00:01:08,310
basically joint oldest or oldest or

00:01:06,630 --> 00:01:10,710
slightly not the oldest depending on who

00:01:08,310 --> 00:01:13,590
you talk to and what programming

00:01:10,710 --> 00:01:18,540
language they're selling at the time so

00:01:13,590 --> 00:01:19,890
has been around for a long time and but

00:01:18,540 --> 00:01:23,009
it's not very popular it hasn't been

00:01:19,890 --> 00:01:25,890
very popular just the sameness no sequel

00:01:23,009 --> 00:01:28,259
actually predates relational databases

00:01:25,890 --> 00:01:30,509
by a long way but then they disappeared

00:01:28,259 --> 00:01:33,590
off the face of the earth and actually

00:01:30,509 --> 00:01:36,479
it's pretty much the same reason why and

00:01:33,590 --> 00:01:38,490
computers just couldn't cope with it you

00:01:36,479 --> 00:01:43,259
know when I started competing I mean I

00:01:38,490 --> 00:01:46,380
started back in the in the yeah

00:01:43,259 --> 00:01:47,369
the Stone Age and I actually started

00:01:46,380 --> 00:01:50,909
with five and a quarter inch floppy

00:01:47,369 --> 00:01:53,579
disks with the BBC big but will not talk

00:01:50,909 --> 00:01:57,210
about that and but we started I started

00:01:53,579 --> 00:02:00,420
with very low level computer so 286 days

00:01:57,210 --> 00:02:04,259
with kilobytes of memory kilobytes of

00:02:00,420 --> 00:02:05,490
disk space everything mattered and

00:02:04,259 --> 00:02:08,250
unfortunately with functional

00:02:05,490 --> 00:02:10,020
programming the way that the way that

00:02:08,250 --> 00:02:11,760
functions why the functional programming

00:02:10,020 --> 00:02:13,350
works you need a lot of memory to run

00:02:11,760 --> 00:02:14,820
because it throws stuff

00:02:13,350 --> 00:02:16,050
why all it needs to throw stuff away and

00:02:14,820 --> 00:02:17,880
unless you've got a good garbage

00:02:16,050 --> 00:02:20,340
collection or you've got that much

00:02:17,880 --> 00:02:22,080
memory it doesn't make any difference it

00:02:20,340 --> 00:02:24,420
doesn't work or it doesn't work very

00:02:22,080 --> 00:02:26,250
efficiently so there are better ways of

00:02:24,420 --> 00:02:29,660
working and people seem to jump onto

00:02:26,250 --> 00:02:33,960
Hopi and we've been on our ap now for

00:02:29,660 --> 00:02:37,470
well I started with vb6 small talk was

00:02:33,960 --> 00:02:42,240
ten years before that so probably the

00:02:37,470 --> 00:02:45,060
80s and I'd love to say our Opie was now

00:02:42,240 --> 00:02:48,180
dying out but unfortunately it's not but

00:02:45,060 --> 00:02:50,880
FP it's beginning to come back and it's

00:02:48,180 --> 00:02:52,200
coming back because we're now hitting

00:02:50,880 --> 00:02:55,410
some problems with our o P that we've

00:02:52,200 --> 00:02:57,740
never had before so up until relatively

00:02:55,410 --> 00:03:01,140
recently you had a single core computer

00:02:57,740 --> 00:03:02,610
or as fast you had a lot of memory but

00:03:01,140 --> 00:03:05,130
it was a single core now we've got

00:03:02,610 --> 00:03:06,780
multiple cores you know with a lot of

00:03:05,130 --> 00:03:09,120
functional languages they also talk to

00:03:06,780 --> 00:03:13,650
GPUs as well whether thousands of cores

00:03:09,120 --> 00:03:15,900
and if you've got mutable state which is

00:03:13,650 --> 00:03:17,700
how object-oriented programming works it

00:03:15,900 --> 00:03:19,220
doesn't work as efficiently across

00:03:17,700 --> 00:03:24,720
multiple cores

00:03:19,220 --> 00:03:25,890
whereas functional programming does and

00:03:24,720 --> 00:03:28,380
that's the same thing that's happened

00:03:25,890 --> 00:03:31,110
with with no sequel you know now that

00:03:28,380 --> 00:03:33,030
we've got now their costs you know 50

00:03:31,110 --> 00:03:34,830
pounds for a five terabyte disk or

00:03:33,030 --> 00:03:38,040
whatever the costs are now you know

00:03:34,830 --> 00:03:39,660
storage is nothing any longer but in the

00:03:38,040 --> 00:03:41,310
relational days it was it was important

00:03:39,660 --> 00:03:42,930
you're only stored one one bit of

00:03:41,310 --> 00:03:46,230
information you know one copy of

00:03:42,930 --> 00:03:48,420
information now that's gone so there so

00:03:46,230 --> 00:03:50,580
people are now jumping to - no sequel

00:03:48,420 --> 00:03:54,800
what I'm hoping is that people will jump

00:03:50,580 --> 00:03:58,770
to functional programming so I went to

00:03:54,800 --> 00:04:00,840
John will correct me on this but it's

00:03:58,770 --> 00:04:04,560
got to be five years ago might in be six

00:04:00,840 --> 00:04:06,720
so I went to conferences six years to

00:04:04,560 --> 00:04:11,040
conferences within about a week I went

00:04:06,720 --> 00:04:13,250
to no js' and I went to progressive F

00:04:11,040 --> 00:04:17,340
sharp I think it was at the time yep

00:04:13,250 --> 00:04:19,799
and John was there as well and I was

00:04:17,340 --> 00:04:21,180
basically going to say I decided I was

00:04:19,799 --> 00:04:23,250
going to choose one I was two routes to

00:04:21,180 --> 00:04:24,960
go and I'm normally pretty good at

00:04:23,250 --> 00:04:26,570
choosing the route to go and I said

00:04:24,960 --> 00:04:29,630
functional programming is where it's at

00:04:26,570 --> 00:04:30,890
that's what I'll concentrate on and I've

00:04:29,630 --> 00:04:32,720
been waiting for the day when functional

00:04:30,890 --> 00:04:34,340
programs take enough I'm looking across

00:04:32,720 --> 00:04:36,530
with my friends who were doing they were

00:04:34,340 --> 00:04:38,390
doing Java and they're not doing Java

00:04:36,530 --> 00:04:42,470
anymore they're doing scalar and closure

00:04:38,390 --> 00:04:44,840
and now Cullen you know I look over at

00:04:42,470 --> 00:04:46,580
JavaScript I don't look for very long

00:04:44,840 --> 00:04:47,900
admittedly but I dick you know I will

00:04:46,580 --> 00:04:50,600
look over at javascript and a lot of

00:04:47,900 --> 00:04:57,080
that's now functional and then I come

00:04:50,600 --> 00:05:00,170
back to the C sharp world and it's so

00:04:57,080 --> 00:05:01,970
what I'm hoping is that is that we can

00:05:00,170 --> 00:05:05,060
try to get functional programming to be

00:05:01,970 --> 00:05:09,050
the the way it the way forwards and I'm

00:05:05,060 --> 00:05:11,030
going to show you today some of the

00:05:09,050 --> 00:05:12,980
things you can do enough in c-sharp that

00:05:11,030 --> 00:05:18,290
maybe didn't know you could do or that

00:05:12,980 --> 00:05:22,790
have come out relatively recently so f

00:05:18,290 --> 00:05:28,630
sharp and for the public viewing it came

00:05:22,790 --> 00:05:30,410
out in 2010 actually it came out 2001

00:05:28,630 --> 00:05:31,880
publicly it was a publicly available

00:05:30,410 --> 00:05:33,320
provided you knew where to look for it

00:05:31,880 --> 00:05:36,230
but he didn't come in visual studio

00:05:33,320 --> 00:05:37,790
it came Visual Studio in 2010 and now

00:05:36,230 --> 00:05:40,100
it's a first-class citizen so when you

00:05:37,790 --> 00:05:43,840
install Visual Studio you get F sharp

00:05:40,100 --> 00:05:46,210
it's in other languages but it's their

00:05:43,840 --> 00:05:48,290
functional programming and c-sharp

00:05:46,210 --> 00:05:51,440
really started you could argue it

00:05:48,290 --> 00:05:52,790
started in two with generics but most

00:05:51,440 --> 00:05:55,250
people probably saw it when this wasn't

00:05:52,790 --> 00:06:00,650
got linked I'll take it everybody's

00:05:55,250 --> 00:06:04,250
using link yeah good okay and so what's

00:06:00,650 --> 00:06:06,230
now happening is Microsoft are putting

00:06:04,250 --> 00:06:09,200
new functional features they're taking

00:06:06,230 --> 00:06:11,600
them from F sharp and trying to back fit

00:06:09,200 --> 00:06:15,410
them into c-sharp some of its successful

00:06:11,600 --> 00:06:18,100
some of its less so but we'll see quite

00:06:15,410 --> 00:06:18,100
a lot of it today

00:06:19,630 --> 00:06:26,530
so what is functional programming a job

00:06:24,310 --> 00:06:27,610
quote ask 10 people what functional

00:06:26,530 --> 00:06:31,090
programming is you'll get 20 different

00:06:27,610 --> 00:06:31,870
ounces and it's different things to

00:06:31,090 --> 00:06:33,760
different people

00:06:31,870 --> 00:06:35,710
I'm going to argue that I think

00:06:33,760 --> 00:06:41,710
functional programming is functions

00:06:35,710 --> 00:06:45,190
they're immutability and a clear

00:06:41,710 --> 00:06:46,210
separation of data and behavior so I

00:06:45,190 --> 00:06:48,340
think they're the three things you

00:06:46,210 --> 00:06:51,190
should concentrate on so light of other

00:06:48,340 --> 00:06:53,920
stuff as well but if I I've only got a

00:06:51,190 --> 00:06:55,810
slide you know I don't want to do 25

00:06:53,920 --> 00:06:58,090
million things yeah I could we're gonna

00:06:55,810 --> 00:07:01,990
see a lot of things anyway as we go as

00:06:58,090 --> 00:07:06,040
we go through the code and so functions

00:07:01,990 --> 00:07:08,080
first class citizens in F sharp

00:07:06,040 --> 00:07:09,430
functions are first class citizens in

00:07:08,080 --> 00:07:11,860
c-sharp they're not because they have to

00:07:09,430 --> 00:07:14,320
live within something else they have to

00:07:11,860 --> 00:07:17,680
live within a class you can't a moment

00:07:14,320 --> 00:07:18,370
have a free-floating function that may

00:07:17,680 --> 00:07:23,470
or may not happen

00:07:18,370 --> 00:07:25,440
in the future don't know and what we're

00:07:23,470 --> 00:07:28,630
trying to do is to build pure functions

00:07:25,440 --> 00:07:31,330
pure functions are those that take

00:07:28,630 --> 00:07:34,210
arguments don't they don't modify the

00:07:31,330 --> 00:07:35,950
arguments they don't have any state

00:07:34,210 --> 00:07:41,140
mutable state change in the middle in

00:07:35,950 --> 00:07:42,850
the function and the return something so

00:07:41,140 --> 00:07:44,170
that for me is a pure function I'm not

00:07:42,850 --> 00:07:46,690
in the Torah frenched referential

00:07:44,170 --> 00:07:47,110
transparency is here and come to that

00:07:46,690 --> 00:07:51,360
later on

00:07:47,110 --> 00:07:54,040
but I'll be for the test at the end and

00:07:51,360 --> 00:07:56,410
higher-order functions quite simply

00:07:54,040 --> 00:07:58,600
higher-order functions are functions

00:07:56,410 --> 00:08:00,250
that pass into other functions or get

00:07:58,600 --> 00:08:01,480
returned from functions so if you don't

00:08:00,250 --> 00:08:09,000
link you're already using higher order

00:08:01,480 --> 00:08:12,250
functions competition just as you build

00:08:09,000 --> 00:08:13,780
objects out of smaller objects we build

00:08:12,250 --> 00:08:18,310
bigger functions out of smaller

00:08:13,780 --> 00:08:20,500
functions that's all composition if and

00:08:18,310 --> 00:08:22,630
finally expressions versus statements so

00:08:20,500 --> 00:08:25,120
a statement doesn't have to return

00:08:22,630 --> 00:08:27,010
anything i expression does so functional

00:08:25,120 --> 00:08:30,150
language is always or always expressions

00:08:27,010 --> 00:08:30,150
they're always returning a value

00:08:31,560 --> 00:08:40,540
immutability and once you correct it

00:08:35,470 --> 00:08:42,130
doesn't change sounds really dumb you

00:08:40,540 --> 00:08:43,270
know you think if I change it what I'm

00:08:42,130 --> 00:08:47,230
going to have a copy there in the copy

00:08:43,270 --> 00:08:51,100
here and it's amazing how much that

00:08:47,230 --> 00:08:52,270
helps you but the you're thinking where

00:08:51,100 --> 00:08:54,220
I got two copies well actually you

00:08:52,270 --> 00:08:54,910
haven't because garbage collection is

00:08:54,220 --> 00:08:57,250
that good

00:08:54,910 --> 00:08:59,530
the once you've lost track of a use of

00:08:57,250 --> 00:09:02,080
this one it goes anyway so you only have

00:08:59,530 --> 00:09:06,690
one or you might have to for a short

00:09:02,080 --> 00:09:11,290
period of time not having immutability

00:09:06,690 --> 00:09:13,930
means that state can change wherever you

00:09:11,290 --> 00:09:16,330
wanted to and I work on big c-sharp

00:09:13,930 --> 00:09:19,020
applications and I spend most of my day

00:09:16,330 --> 00:09:23,080
debugging multi-threaded multi-core

00:09:19,020 --> 00:09:24,700
state changes that I possibly can

00:09:23,080 --> 00:09:28,090
duplicate one time out of five if I'm

00:09:24,700 --> 00:09:31,390
lucky it's a very frustrating place to

00:09:28,090 --> 00:09:33,340
be you know and we end up we end up

00:09:31,390 --> 00:09:35,980
turning off multi-core stuff in the end

00:09:33,340 --> 00:09:38,880
then we go back to single core just to

00:09:35,980 --> 00:09:41,290
make sure that we don't have these bugs

00:09:38,880 --> 00:09:44,200
so we've got machines sitting there with

00:09:41,290 --> 00:09:46,300
massively powerful processors and we

00:09:44,200 --> 00:09:50,350
hardly use them you know we're like 5%

00:09:46,300 --> 00:09:52,870
usage you know it's a bit a bit daft

00:09:50,350 --> 00:09:57,610
really and clear separation of data and

00:09:52,870 --> 00:10:00,040
behavior and this is a tough one for our

00:09:57,610 --> 00:10:04,090
o P people you know because you've been

00:10:00,040 --> 00:10:06,630
taught about anemic anemic classes you

00:10:04,090 --> 00:10:11,370
know just having data not a bad thing

00:10:06,630 --> 00:10:11,370
but it is in there okey well

00:10:14,340 --> 00:10:18,160
and by the way if you've got any

00:10:16,060 --> 00:10:24,040
questions just ask what he got me coming

00:10:18,160 --> 00:10:25,210
to just say so what's the difference

00:10:24,040 --> 00:10:28,210
between our Opie and functional

00:10:25,210 --> 00:10:33,400
programming object-oriented this state

00:10:28,210 --> 00:10:37,120
and behavior together now I've been I've

00:10:33,400 --> 00:10:40,630
been writing our code for a fashion of

00:10:37,120 --> 00:10:43,000
our code for well over 20 years I think

00:10:40,630 --> 00:10:46,240
I can hold my hand up and say I've seen

00:10:43,000 --> 00:10:50,280
less than five actual our notation

00:10:46,240 --> 00:10:53,080
implementations the majority of the icy

00:10:50,280 --> 00:10:55,600
objects oriented in the round so the use

00:10:53,080 --> 00:10:57,580
classes and these classes to build other

00:10:55,600 --> 00:11:01,150
classes and then everything else is

00:10:57,580 --> 00:11:02,950
imperative so everything else is little

00:11:01,150 --> 00:11:06,700
little jumbled bits of functionality

00:11:02,950 --> 00:11:10,000
inside a function or inside a method and

00:11:06,700 --> 00:11:11,590
lots of those I've seen very little I've

00:11:10,000 --> 00:11:14,740
seen very little that I consider to be

00:11:11,590 --> 00:11:17,200
relatively pure arrow because it's just

00:11:14,740 --> 00:11:19,390
so easy to do it's so easy just to pull

00:11:17,200 --> 00:11:20,950
some data and make a decision don't get

00:11:19,390 --> 00:11:23,350
some more day to make a decision send

00:11:20,950 --> 00:11:25,060
something out it's a lot harder to write

00:11:23,350 --> 00:11:28,630
code that actually goes off and says go

00:11:25,060 --> 00:11:32,680
and make that decision for me now I

00:11:28,630 --> 00:11:35,020
might just have an unlucky but I've

00:11:32,680 --> 00:11:37,600
probably seen I've probably seen 50 code

00:11:35,020 --> 00:11:39,970
bases in the last 20 years and they've

00:11:37,600 --> 00:11:43,870
all been pretty much the same but they

00:11:39,970 --> 00:11:46,630
getting bigger you know so it's actually

00:11:43,870 --> 00:11:47,980
getting harder to work with now it's a

00:11:46,630 --> 00:11:50,410
functional programming clear separation

00:11:47,980 --> 00:11:53,890
between data and behavior your functions

00:11:50,410 --> 00:11:56,460
you have data data gets acted upon by

00:11:53,890 --> 00:11:56,460
functions

00:11:56,980 --> 00:12:01,449
so that's the wrong way put in that data

00:11:59,860 --> 00:12:04,410
gets passed into functions and things

00:12:01,449 --> 00:12:04,410
get passed back out again

00:12:07,940 --> 00:12:12,800
so it's all about data structures and

00:12:10,520 --> 00:12:20,300
parsing data structures through through

00:12:12,800 --> 00:12:23,210
pipelines of compose functions so this

00:12:20,300 --> 00:12:25,070
equate my Michael feathers who's pretty

00:12:23,210 --> 00:12:27,080
famous I think he's one of the I think

00:12:25,070 --> 00:12:31,220
he was one of the the Snowbird guys the

00:12:27,080 --> 00:12:34,730
agile guys that start in 2001 so he says

00:12:31,220 --> 00:12:37,400
that ROP makes code understandable by by

00:12:34,730 --> 00:12:39,340
encapsulating the moving parts and

00:12:37,400 --> 00:12:41,420
functional programming makes it by

00:12:39,340 --> 00:12:43,540
minimizing them so you're less moving

00:12:41,420 --> 00:12:43,540
parts

00:12:43,660 --> 00:12:47,750
now I said pure functions yeah you

00:12:46,400 --> 00:12:50,300
should try and have pure function you

00:12:47,750 --> 00:12:52,190
can't have an application built entirely

00:12:50,300 --> 00:12:55,970
of pure function because it wouldn't do

00:12:52,190 --> 00:12:57,530
anything state has to change you know

00:12:55,970 --> 00:13:00,290
you have to get data from a database you

00:12:57,530 --> 00:13:03,380
have to receive user input so their idea

00:13:00,290 --> 00:13:06,020
is that you put the the functions that

00:13:03,380 --> 00:13:08,510
do the word that do the state so the

00:13:06,020 --> 00:13:09,110
impure functions on the outside of the

00:13:08,510 --> 00:13:10,730
application

00:13:09,110 --> 00:13:12,590
and the pure stuff in the middle that

00:13:10,730 --> 00:13:17,330
this will work so if you imagined if you

00:13:12,590 --> 00:13:21,290
if you wanted to to take a CSV file then

00:13:17,330 --> 00:13:23,090
convert it to PDF so thinking about it

00:13:21,290 --> 00:13:25,550
logically what we'd do is we'd load the

00:13:23,090 --> 00:13:28,790
data in viral function that would turn a

00:13:25,550 --> 00:13:29,870
list of data we'd then pass that list

00:13:28,790 --> 00:13:32,780
into the function that did the

00:13:29,870 --> 00:13:35,030
conversion we'd then pass the result of

00:13:32,780 --> 00:13:38,570
that to something that printed the PDF

00:13:35,030 --> 00:13:41,090
out so the bits that do the i/o the bits

00:13:38,570 --> 00:13:42,620
of the state stuff sit outside of the

00:13:41,090 --> 00:13:45,980
pure function the feel funky you can

00:13:42,620 --> 00:13:47,810
test on its own rather than the ROP

00:13:45,980 --> 00:13:49,520
world you probably have you probably get

00:13:47,810 --> 00:13:51,170
the data at the top of the function do

00:13:49,520 --> 00:13:53,300
the work in the middle and then right at

00:13:51,170 --> 00:13:57,070
the bottom and I'm making my child as a

00:13:53,300 --> 00:13:57,070
test so you end up having multiple

00:13:59,470 --> 00:14:03,760
and obviously as you extend this then it

00:14:01,960 --> 00:14:04,980
makes the it makes your car your tow

00:14:03,760 --> 00:14:07,060
harder and harder to reason about

00:14:04,980 --> 00:14:10,630
functional programming should have small

00:14:07,060 --> 00:14:12,250
functions a lot of the ROP code that I

00:14:10,630 --> 00:14:19,150
see doesn't have small functions it has

00:14:12,250 --> 00:14:20,530
quite some quite sizable things so it's

00:14:19,150 --> 00:14:21,640
not me jabbering let's look at some code

00:14:20,530 --> 00:14:24,370
right don't be scared

00:14:21,640 --> 00:14:27,610
it does say a shout workshop so what

00:14:24,370 --> 00:14:29,260
we're going to do is is I thought it'd

00:14:27,610 --> 00:14:31,390
be a good idea that this is a very nice

00:14:29,260 --> 00:14:33,730
F sharp workshop that does that tells

00:14:31,390 --> 00:14:35,890
you about 16 things the functional

00:14:33,730 --> 00:14:38,860
programming does 16 features of

00:14:35,890 --> 00:14:41,800
functional programming and I thought

00:14:38,860 --> 00:14:44,050
what we do is work through the exercises

00:14:41,800 --> 00:14:47,200
but do them in c-sharp rather than F

00:14:44,050 --> 00:14:49,390
sharp so that way you get to see what

00:14:47,200 --> 00:14:51,220
the F sharp bit looks like and what the

00:14:49,390 --> 00:14:53,920
C sharp bits looks looks like and I can

00:14:51,220 --> 00:14:55,630
tell you when the new features are

00:14:53,920 --> 00:14:57,580
coming so when the bits are F sharp will

00:14:55,630 --> 00:14:59,740
appear in C sharp if they're not already

00:14:57,580 --> 00:15:06,820
there or if they're already there we'll

00:14:59,740 --> 00:15:08,110
try and use them sound good okay it's

00:15:06,820 --> 00:15:13,380
really good exercise you want to learn F

00:15:08,110 --> 00:15:13,380
sharp and it's a really good place to go

00:15:16,050 --> 00:15:23,110
so start off with bindings functions

00:15:20,530 --> 00:15:26,290
tuples and records so the first thing

00:15:23,110 --> 00:15:29,610
we're going to do is create a a customer

00:15:26,290 --> 00:15:33,520
type that's a simple this is a simple

00:15:29,610 --> 00:15:37,960
data store this is immutable and it's

00:15:33,520 --> 00:15:39,550
got three properties on it so it's

00:15:37,960 --> 00:15:41,020
called a record type it's supposed to be

00:15:39,550 --> 00:15:41,350
coming out and seven points something or

00:15:41,020 --> 00:15:44,080
other

00:15:41,350 --> 00:15:45,640
Berk and it's supposed to be coming out

00:15:44,080 --> 00:15:47,340
an 8 point something but I wouldn't hold

00:15:45,640 --> 00:15:51,550
your breath I'd probably wait for 9

00:15:47,340 --> 00:15:54,670
before it comes out but we've done them

00:15:51,550 --> 00:15:56,830
equivalent to this so if I go into and

00:15:54,670 --> 00:15:58,900
have a look at so I've got I've got two

00:15:56,830 --> 00:16:00,580
projects that two projects that I've

00:15:58,900 --> 00:16:03,010
done here I've done a finished version

00:16:00,580 --> 00:16:05,710
so I can copy and paste stuff that I

00:16:03,010 --> 00:16:09,550
have to type too much and then I've got

00:16:05,710 --> 00:16:12,629
a start one as well and so the way that

00:16:09,550 --> 00:16:15,610
a lot of functional applications get

00:16:12,629 --> 00:16:18,790
get written is they have for each

00:16:15,610 --> 00:16:24,850
functional area for each dabangg any

00:16:18,790 --> 00:16:26,499
area of the code bright Sun and you'll

00:16:24,850 --> 00:16:32,439
end up with two files you'll end up with

00:16:26,499 --> 00:16:36,339
a with a types file which contains all

00:16:32,439 --> 00:16:38,410
of your all of your classes and you'll

00:16:36,339 --> 00:16:39,910
end up with a functions file which

00:16:38,410 --> 00:16:41,769
contains all of your all your functions

00:16:39,910 --> 00:16:43,990
so we can't do a record type at the

00:16:41,769 --> 00:16:45,879
moment but record types are coming so a

00:16:43,990 --> 00:16:49,230
record type is something that is just a

00:16:45,879 --> 00:16:53,259
very quick immutable data structure but

00:16:49,230 --> 00:16:57,970
we can write a read only a read-only

00:16:53,259 --> 00:16:59,439
class so they're dead AUC we just have a

00:16:57,970 --> 00:17:01,689
constructor that takes all the data in

00:16:59,439 --> 00:17:04,659
we set it in the constructor and we just

00:17:01,689 --> 00:17:06,490
have getters I've put a little helper to

00:17:04,659 --> 00:17:11,280
string on there just so I can read the

00:17:06,490 --> 00:17:11,280
data out nothing magical

00:17:18,340 --> 00:17:24,880
and and then all this is doing is

00:17:21,370 --> 00:17:26,430
creating the customer so I'll do I'll do

00:17:24,880 --> 00:17:29,910
that just for the sake of doing it so

00:17:26,430 --> 00:17:29,910
over the program

00:17:33,630 --> 00:17:37,410
just to show that it does work

00:17:48,690 --> 00:17:51,870
how do I

00:17:55,400 --> 00:18:08,360
watch better I'll take back everything

00:18:00,950 --> 00:18:12,260
I've ever said about you so I just do a

00:18:08,360 --> 00:18:14,830
two string and do a a read line just to

00:18:12,260 --> 00:18:20,059
stop it blowing up

00:18:14,830 --> 00:18:25,930
I'm not gonna reach are on this right

00:18:20,059 --> 00:18:25,930
let's have a run this it should just

00:18:33,950 --> 00:18:39,740
Yeah right if I set the stack to start a

00:18:38,510 --> 00:18:41,410
project to start one rather than the

00:18:39,740 --> 00:18:46,880
other one

00:18:41,410 --> 00:18:51,580
yeah so just got some data back very

00:18:46,880 --> 00:18:51,580
nice Daisy back to our idea

00:18:54,780 --> 00:18:59,240
[Music]

00:18:55,930 --> 00:19:03,460
so we've got a little little function

00:18:59,240 --> 00:19:07,820
here called try to promote the VIP and

00:19:03,460 --> 00:19:11,300
so it says that's got a little internal

00:19:07,820 --> 00:19:16,400
function there as well it's a tuple okay

00:19:11,300 --> 00:19:19,030
and so in versions seven there's a new

00:19:16,400 --> 00:19:23,000
type of tuple we now have a value tuple

00:19:19,030 --> 00:19:24,830
and a value tuple allows us to do funky

00:19:23,000 --> 00:19:27,620
things like this that we never used to

00:19:24,830 --> 00:19:31,760
be able to so instead of having today to

00:19:27,620 --> 00:19:40,190
pull of customer comma decimal we can

00:19:31,760 --> 00:19:41,510
now just write it like this that's all

00:19:40,190 --> 00:19:44,030
this is doing it so it's in the tuple

00:19:41,510 --> 00:19:46,870
first and then it's a simple I'll come

00:19:44,030 --> 00:19:46,870
back to that in a second

00:19:52,750 --> 00:19:57,179
or I've still got functions open

00:20:00,350 --> 00:20:10,190
so if we try and match this so try to

00:20:02,299 --> 00:20:12,529
remember it the VIP I'm going to make it

00:20:10,190 --> 00:20:15,279
static so all of your pure function

00:20:12,529 --> 00:20:15,279
should be static

00:20:22,000 --> 00:20:28,410
so try to provoke to the IP

00:20:36,180 --> 00:20:46,230
okay and that took the to pull in so

00:20:40,560 --> 00:20:57,090
let's see if we can do that so it takes

00:20:46,230 --> 00:21:03,390
a customer and a and a decimal and it

00:20:57,090 --> 00:21:09,380
was purchases open it to return

00:21:03,390 --> 00:21:12,870
something and that function returns a a

00:21:09,380 --> 00:21:15,650
customer so enough show up the last line

00:21:12,870 --> 00:21:17,850
or the other the end of an F and F

00:21:15,650 --> 00:21:22,160
returns it so in this case it's

00:21:17,850 --> 00:21:22,160
returning the customer so

00:21:26,529 --> 00:21:35,169
so I've got a little function that takes

00:21:28,720 --> 00:21:36,250
a tuple a customer and a tional and it's

00:21:35,169 --> 00:21:38,740
going to return the customer

00:21:36,250 --> 00:21:42,450
so let's deconstruct our tuple to begin

00:21:38,740 --> 00:21:42,450
with so far

00:21:55,600 --> 00:22:01,370
well looks like it's working so we can

00:21:59,029 --> 00:22:02,929
deconstruct the tuple now tuples are

00:22:01,370 --> 00:22:05,269
fantastic if you only got two bits of

00:22:02,929 --> 00:22:07,580
data or three bits of data you don't

00:22:05,269 --> 00:22:09,980
have to create a class just use tuples

00:22:07,580 --> 00:22:12,830
they're dead easy to work with now you

00:22:09,980 --> 00:22:18,100
can even name them in c-sharp as well so

00:22:12,830 --> 00:22:18,100
you name the name the items in the tuple

00:22:18,490 --> 00:22:29,990
and you can see they're deconstructions

00:22:20,690 --> 00:22:33,730
dead easy so it's my logic so if the

00:22:29,990 --> 00:22:33,730
amounts greater than 100

00:22:44,040 --> 00:22:53,140
we'll do that for the moment and then by

00:22:50,260 --> 00:22:59,890
default I'm going to return the original

00:22:53,140 --> 00:23:00,730
customer so we go back to this and so

00:22:59,890 --> 00:23:02,380
one of the things we can do with the

00:23:00,730 --> 00:23:04,570
record is you can create a new record

00:23:02,380 --> 00:23:08,740
that's a copy of the old one but change

00:23:04,570 --> 00:23:11,410
some of the data now we can't do that in

00:23:08,740 --> 00:23:13,030
c-sharp unfortunately so what I tend to

00:23:11,410 --> 00:23:16,990
do in this sort of case is to a fluent

00:23:13,030 --> 00:23:19,680
interface into a builder benefit if

00:23:16,990 --> 00:23:19,680
you've seen those before

00:23:27,250 --> 00:23:38,580
so on a copy up from my from my finished

00:23:34,960 --> 00:23:38,580
one because it takes quite a while to do

00:23:44,659 --> 00:23:46,720
Oh

00:23:47,550 --> 00:23:51,080
that's right only to get rid of thee

00:23:51,350 --> 00:23:56,120
let's get rid of the things that not

00:23:53,220 --> 00:23:56,120
yesterday at the moment

00:24:04,430 --> 00:24:09,680
okay so this is a this is a fluent

00:24:07,130 --> 00:24:11,030
interface this is this is not functional

00:24:09,680 --> 00:24:13,880
it's been you've been able to do this

00:24:11,030 --> 00:24:18,260
virtually since since the beginning of

00:24:13,880 --> 00:24:20,150
c-sharp what you do is you create you

00:24:18,260 --> 00:24:23,330
take in something that you want to to

00:24:20,150 --> 00:24:26,570
use in this case customer and then you

00:24:23,330 --> 00:24:28,820
set up a set of public functions that

00:24:26,570 --> 00:24:31,580
take in values you want to change and

00:24:28,820 --> 00:24:35,390
then you return the instance of the

00:24:31,580 --> 00:24:38,690
Builder that you're working with so what

00:24:35,390 --> 00:24:45,200
you can do is if you want to change that

00:24:38,690 --> 00:24:47,800
customer I can now do a new customer

00:24:45,200 --> 00:24:47,800
builder

00:24:55,559 --> 00:24:59,640
that takes the original customer

00:25:13,070 --> 00:25:27,080
got that clucks it's inside that all

00:25:20,789 --> 00:25:27,080
right sorry I'm guessing there

00:25:40,440 --> 00:25:44,280
right so got them back now

00:25:45,100 --> 00:25:50,830
and what this does is what we've done

00:25:48,970 --> 00:25:53,169
here with this record type is we've set

00:25:50,830 --> 00:26:00,370
is VI P equals true so I'm going to do

00:25:53,169 --> 00:26:02,679
I'm going to do start with VIP and we'll

00:26:00,370 --> 00:26:10,360
set that to true and then I'm going to

00:26:02,679 --> 00:26:12,450
adopt build so it's a little bit of

00:26:10,360 --> 00:26:14,860
extra effort but I've got something that

00:26:12,450 --> 00:26:16,450
that helps me do that otherwise I've got

00:26:14,860 --> 00:26:18,460
to otherwise I've got to literally copy

00:26:16,450 --> 00:26:20,919
all that all the properties and change

00:26:18,460 --> 00:26:22,570
the things I want to change which is

00:26:20,919 --> 00:26:25,059
much harder and this is much more

00:26:22,570 --> 00:26:27,240
readable as well so just test that it

00:26:25,059 --> 00:26:27,240
works

00:26:45,750 --> 00:26:55,500
so it's try notes a lot more functions

00:26:49,110 --> 00:26:59,300
cult now so the function is called try

00:26:55,500 --> 00:26:59,300
convert try to write to the VIP

00:27:17,850 --> 00:27:26,250
copy and paste

00:27:20,970 --> 00:27:29,410
functions on the results functions of us

00:27:26,250 --> 00:27:34,770
yes it's time you stolen resharper again

00:27:29,410 --> 00:27:34,770
I do

00:27:43,000 --> 00:27:46,650
what's up

00:27:51,440 --> 00:27:55,840
I've got no I've got no argument in

00:27:53,570 --> 00:27:55,840
there yet

00:28:07,380 --> 00:28:15,600
okay and if I do my copy that

00:28:22,990 --> 00:28:34,880
hopefully I will okay

00:28:30,980 --> 00:28:36,350
that's change VIP to to true one of the

00:28:34,880 --> 00:28:39,620
other things that we can do as well is

00:28:36,350 --> 00:28:41,029
is I don't like this functions dot thing

00:28:39,620 --> 00:28:44,210
so one of the things that's been

00:28:41,029 --> 00:28:46,250
introduced in I'm trying to no one it

00:28:44,210 --> 00:28:50,679
happiness I think it was six that it

00:28:46,250 --> 00:28:50,679
came in is that you can now do

00:28:53,970 --> 00:28:57,079
[Music]

00:28:59,460 --> 00:29:03,990
you know they're using static functions

00:29:01,890 --> 00:29:07,980
and what that's does is just loads the

00:29:03,990 --> 00:29:15,510
statics in that particular class so I'd

00:29:07,980 --> 00:29:18,380
get rid of functions it should work so

00:29:15,510 --> 00:29:18,380
why am I not doing it

00:29:24,360 --> 00:29:28,340
we saw anything stop

00:29:30,500 --> 00:29:33,500
yeah

00:29:38,440 --> 00:29:43,680
well should be alright soon the same

00:29:40,240 --> 00:29:45,910
namespace oh there we go

00:29:43,680 --> 00:29:48,340
alright just needs a little bit of extra

00:29:45,910 --> 00:29:51,070
help so you've that's that's but I think

00:29:48,340 --> 00:29:53,740
that was introduced in six so you can

00:29:51,070 --> 00:29:56,500
just say things like the the math

00:29:53,740 --> 00:29:58,570
fasting system you just want to take all

00:29:56,500 --> 00:30:01,870
of those rather nothing to do math dot

00:29:58,570 --> 00:30:04,930
pie or math dot square you can just use

00:30:01,870 --> 00:30:08,500
square just tie this it up a little bit

00:30:04,930 --> 00:30:09,880
but I don't know whether it makes that

00:30:08,500 --> 00:30:11,940
much difference but it's it's there and

00:30:09,880 --> 00:30:11,940
available

00:30:20,700 --> 00:30:28,799
okay and the next one is a simple

00:30:23,970 --> 00:30:36,139
function that takes a customer returns a

00:30:28,799 --> 00:30:36,139
tuple yep so get purchases

00:30:41,110 --> 00:30:50,950
so public static whoops and that returns

00:30:48,200 --> 00:30:50,950
to poor doesn't it

00:30:53,670 --> 00:30:58,410
takes a customer returns a tuple the

00:30:56,940 --> 00:31:03,350
text customer in there returns one of

00:30:58,410 --> 00:31:03,350
these so if I copied that

00:31:22,789 --> 00:31:30,559
okay on this earth and I have a TripIt

00:31:27,379 --> 00:31:32,959
of logic in there it's it doesn't matter

00:31:30,559 --> 00:31:35,089
what it does it's just it's just the

00:31:32,959 --> 00:31:37,009
fact that you can it's the fact that you

00:31:35,089 --> 00:31:39,979
can now pass tuples in those parameters

00:31:37,009 --> 00:31:46,119
and pass them out as as the results of

00:31:39,979 --> 00:31:46,119
functions as well in a nice clean way

00:31:47,289 --> 00:31:59,979
so if customer that ID modulo 2 equals 0

00:32:08,890 --> 00:32:12,420
so on 20 night

00:32:26,000 --> 00:32:29,000
okay

00:32:33,260 --> 00:32:40,480
and obviously I can run that function as

00:32:35,360 --> 00:32:40,480
well so what we've covered in in that is

00:32:41,770 --> 00:32:45,860
we've done some functions within some

00:32:43,880 --> 00:32:51,200
tuples and we've done what they couldn't

00:32:45,860 --> 00:32:53,570
a records are on there as well so next

00:32:51,200 --> 00:32:54,830
page higher-order functions before I go

00:32:53,570 --> 00:32:59,480
into higher order functions

00:32:54,830 --> 00:33:07,419
I want to do is I want to want to load a

00:32:59,480 --> 00:33:10,610
link pad does anybody use link pad

00:33:07,419 --> 00:33:15,380
fabulous tool and so the other great

00:33:10,610 --> 00:33:18,169
advantage of link pad is that it

00:33:15,380 --> 00:33:19,490
supports all the C sharp 7 stuff so if

00:33:18,169 --> 00:33:20,410
you want to try it out you want to try

00:33:19,490 --> 00:33:23,390
things out

00:33:20,410 --> 00:33:24,740
have a go in link pad now you haven't

00:33:23,390 --> 00:33:27,980
got to run a full program in Visual

00:33:24,740 --> 00:33:32,330
Studio and download the SDKs you know 4

00:33:27,980 --> 00:33:35,620
4 7 & 7 4.7 4.7 170 they're already in

00:33:32,330 --> 00:33:35,620
with link pad

00:33:50,780 --> 00:34:02,990
right can everybody read that tell ya

00:33:59,580 --> 00:34:02,990
I'm sure everybody can read that now

00:34:04,130 --> 00:34:10,470
anybody recognize it I think they know

00:34:07,050 --> 00:34:15,330
what it might be it's subtle clearing

00:34:10,470 --> 00:34:17,280
the title of the page but it's it's

00:34:15,330 --> 00:34:21,179
basically a decompiled version of the of

00:34:17,280 --> 00:34:22,379
the where clause from link but I think

00:34:21,179 --> 00:34:24,480
this is quite it's quite interesting

00:34:22,379 --> 00:34:26,570
does anybody actually decompiled one can

00:34:24,480 --> 00:34:30,720
have a look at it see what's in there

00:34:26,570 --> 00:34:32,700
quite fascinating it's quite it's quite

00:34:30,720 --> 00:34:37,350
an eye-opener what they what they

00:34:32,700 --> 00:34:44,250
actually do so the interesting things

00:34:37,350 --> 00:34:46,919
that come out of this provided predicate

00:34:44,250 --> 00:34:49,260
so this is it so this is using higher

00:34:46,919 --> 00:34:53,129
order functions so it's passing in a

00:34:49,260 --> 00:34:55,500
funk of timbal so it's a it's a focus a

00:34:53,129 --> 00:34:58,050
function that that takes a parameter of

00:34:55,500 --> 00:35:00,000
T and returns a ball there used to be a

00:34:58,050 --> 00:35:01,800
predicate type but I don't seem to go

00:35:00,000 --> 00:35:05,070
out the window now that seems to be

00:35:01,800 --> 00:35:09,570
since have been pushed off to the funk

00:35:05,070 --> 00:35:11,190
of T and ball now and so this is a

00:35:09,570 --> 00:35:13,920
higher-order function because it's

00:35:11,190 --> 00:35:17,040
taking taking in a funk taking in a

00:35:13,920 --> 00:35:21,930
function provided that predicate is pure

00:35:17,040 --> 00:35:24,360
it's also pure function because TS

00:35:21,930 --> 00:35:31,320
doesn't change and you return a

00:35:24,360 --> 00:35:32,670
brand-new ienumerable from this the

00:35:31,320 --> 00:35:36,380
other one that's interesting here is

00:35:32,670 --> 00:35:38,760
that this word it's an extension method

00:35:36,380 --> 00:35:42,600
basically all of lengthiest extension

00:35:38,760 --> 00:35:44,130
methods which is really interesting

00:35:42,600 --> 00:35:48,960
because the number of people I talk to

00:35:44,130 --> 00:35:50,850
and I say you know do you like link I'll

00:35:48,960 --> 00:35:55,310
never met anybody that doesn't like link

00:35:50,850 --> 00:35:57,410
oh okay okay like that well I thank you

00:35:55,310 --> 00:36:01,020
it was gonna happen one day

00:35:57,410 --> 00:36:03,180
and so I've met people who sometimes

00:36:01,020 --> 00:36:06,300
think so I use resharper

00:36:03,180 --> 00:36:08,160
and sometimes I can't think it's

00:36:06,300 --> 00:36:10,530
particularly a few years ago I couldn't

00:36:08,160 --> 00:36:12,810
think how do I address all this I'll do

00:36:10,530 --> 00:36:15,120
it in an imperative way and resharper

00:36:12,810 --> 00:36:17,100
came up and said I can convert this to

00:36:15,120 --> 00:36:21,570
link for you oh great that's normally

00:36:17,100 --> 00:36:24,840
really good convert it to link and I've

00:36:21,570 --> 00:36:27,000
got that and now I'm just looking like

00:36:24,840 --> 00:36:28,920
thinking no you know it's it's it may be

00:36:27,000 --> 00:36:30,720
clever but I'm going to look back at

00:36:28,920 --> 00:36:32,700
this in in three months time six months

00:36:30,720 --> 00:36:36,090
time and think what on earth does that

00:36:32,700 --> 00:36:38,070
do so will reverted it back again but

00:36:36,090 --> 00:36:39,780
most people like link most people think

00:36:38,070 --> 00:36:42,120
it's really good and handy so the next

00:36:39,780 --> 00:36:44,520
question you ask is do you extend your

00:36:42,120 --> 00:36:49,320
methods and that's the work of the devil

00:36:44,520 --> 00:36:52,100
apparently most people most most c-sharp

00:36:49,320 --> 00:36:55,140
developers hate extension methods

00:36:52,100 --> 00:37:00,170
because they're told to put functions on

00:36:55,140 --> 00:37:06,240
objects having them as separate classes

00:37:00,170 --> 00:37:10,560
doesn't fit in their brain properly it's

00:37:06,240 --> 00:37:13,800
quite a weird one so yes this is so this

00:37:10,560 --> 00:37:15,330
is this is some basic link and it's a

00:37:13,800 --> 00:37:18,140
peel function provided product it's pure

00:37:15,330 --> 00:37:20,660
and it literally just looped through

00:37:18,140 --> 00:37:28,670
pick some value out and yield returns

00:37:20,660 --> 00:37:28,670
something brand-new just as an aside

00:37:28,810 --> 00:37:31,900
[Music]

00:37:33,480 --> 00:37:39,680
so the next function is increased credit

00:37:41,120 --> 00:37:46,250
condition in this case is a is a

00:37:43,770 --> 00:37:46,250
function

00:37:49,170 --> 00:37:56,670
because I read underneath and says if

00:37:51,390 --> 00:37:57,869
condition' customer then okay so I'm not

00:37:56,670 --> 00:38:00,470
going to write that I'm going to copy

00:37:57,869 --> 00:38:00,470
that one over

00:38:05,609 --> 00:38:09,030
so Miss -

00:38:32,860 --> 00:38:42,500
this is what I wish I'd got resharper on

00:38:35,210 --> 00:38:44,860
this box that should I should solve that

00:38:42,500 --> 00:38:44,860
problem

00:38:53,769 --> 00:38:59,299
so this is basically this is using the

00:38:56,690 --> 00:39:02,680
Builder that we use previously and just

00:38:59,299 --> 00:39:05,930
shows you that you can pass in a in a

00:39:02,680 --> 00:39:08,769
higher order function but we know we can

00:39:05,930 --> 00:39:08,769
do that because we saw the link

00:39:13,470 --> 00:39:17,180
I don't know

00:39:22,150 --> 00:39:38,470
right the next one and partial

00:39:32,300 --> 00:39:42,500
application now this is one of those

00:39:38,470 --> 00:39:45,530
really odd odd that's not odd it's T

00:39:42,500 --> 00:39:46,730
it's quite it's very powerful thing but

00:39:45,530 --> 00:39:50,240
it's one of those that doesn't translate

00:39:46,730 --> 00:39:53,410
to c-sharp very well I'll give you an

00:39:50,240 --> 00:39:53,410
idea of what it does

00:40:02,110 --> 00:40:05,340
so this is

00:40:05,400 --> 00:40:12,450
this is something called currying so so

00:40:10,800 --> 00:40:14,700
in F sharp you have two ways of passing

00:40:12,450 --> 00:40:16,680
or in functional languages you have two

00:40:14,700 --> 00:40:19,680
ways of passing parameters you can

00:40:16,680 --> 00:40:22,920
either send them as tuples so that's

00:40:19,680 --> 00:40:24,930
that comes in as one thing but you know

00:40:22,920 --> 00:40:29,210
one thought one thing together or you

00:40:24,930 --> 00:40:31,260
send them in a separate separate inputs

00:40:29,210 --> 00:40:32,580
technically you're not sending them in a

00:40:31,260 --> 00:40:36,810
separate inputs what you're actually

00:40:32,580 --> 00:40:38,820
doing is creating multiple functions so

00:40:36,810 --> 00:40:40,950
in most functional languages for a

00:40:38,820 --> 00:40:44,640
functional language entails one

00:40:40,950 --> 00:40:46,110
parameter and returns one parameter so

00:40:44,640 --> 00:40:48,270
if you're taking two parameters what

00:40:46,110 --> 00:40:50,910
you're actually doing is you're creating

00:40:48,270 --> 00:40:54,200
a brand-new function that takes one

00:40:50,910 --> 00:40:56,790
parameter that then gets passed on to

00:40:54,200 --> 00:41:03,080
the next parameter and that gets added

00:40:56,790 --> 00:41:07,380
on and it doesn't really work well with

00:41:03,080 --> 00:41:11,820
with c-sharp so if we look at a bit of

00:41:07,380 --> 00:41:16,980
code that's commented out so we take a

00:41:11,820 --> 00:41:20,040
func of string string string and we'll

00:41:16,980 --> 00:41:21,840
have a function called join and then we

00:41:20,040 --> 00:41:26,390
just use a little bit of lambda on there

00:41:21,840 --> 00:41:26,390
I've created a couple of extensions here

00:41:27,350 --> 00:41:31,860
because what I wrote there isn't what is

00:41:30,630 --> 00:41:33,990
actually happening what is actually

00:41:31,860 --> 00:41:35,550
happening is this thing underneath here

00:41:33,990 --> 00:41:38,150
so the next stage is function

00:41:35,550 --> 00:41:38,150
composition

00:41:43,380 --> 00:41:50,770
so if you look at this this takes if you

00:41:49,960 --> 00:41:53,940
work your way down

00:41:50,770 --> 00:41:55,930
you've got customer cuts passed in

00:41:53,940 --> 00:42:00,280
customer gets enters the last parameter

00:41:55,930 --> 00:42:03,760
and returns a customer I think that is

00:42:00,280 --> 00:42:06,339
the result of that then gets passed in

00:42:03,760 --> 00:42:08,950
as the last parameter or a parameter

00:42:06,339 --> 00:42:10,330
into this that returns something this

00:42:08,950 --> 00:42:12,760
something then gets used to the end of

00:42:10,330 --> 00:42:16,089
that well that's very much like link to

00:42:12,760 --> 00:42:17,500
me because that's what link does you

00:42:16,089 --> 00:42:18,820
know all those all those dots are

00:42:17,500 --> 00:42:20,950
effectively doing what we've done here

00:42:18,820 --> 00:42:22,540
they're just a nice way of doing it you

00:42:20,950 --> 00:42:27,580
still create all those intermediate bits

00:42:22,540 --> 00:42:32,670
we just don't have names for them so

00:42:27,580 --> 00:42:32,670
let's try and let's try and do that

00:42:36,110 --> 00:42:38,730
so I've got

00:42:37,600 --> 00:42:41,869
[Music]

00:42:38,730 --> 00:42:41,869
get purchases

00:42:43,060 --> 00:42:47,160
oops

00:42:45,030 --> 00:42:51,020
that great customer touched customer

00:42:47,160 --> 00:42:51,020
right so let's create our function

00:42:53,960 --> 00:43:02,450
static void say upgrade customer

00:43:04,369 --> 00:43:08,289
that takes a look

00:43:09,980 --> 00:43:17,050
I'm assuming that's going to return a

00:43:11,420 --> 00:43:17,050
customer so it takes customer

00:43:29,620 --> 00:43:37,570
right so the first thing wants to do is

00:43:31,420 --> 00:43:45,010
do the getpurchases so I'm going to

00:43:37,570 --> 00:43:46,690
treat a little bit here so that's

00:43:45,010 --> 00:43:55,960
getpurchases and that returns a tuple

00:43:46,690 --> 00:44:08,260
okay so far purchases equals get

00:43:55,960 --> 00:44:11,350
purchases that takes one customer the

00:44:08,260 --> 00:44:14,590
next one does a try to promote the VIP

00:44:11,350 --> 00:44:18,270
so we've already got that function so

00:44:14,590 --> 00:44:18,270
that's that one that takes the tuple

00:44:36,299 --> 00:44:44,700
and the last one is increased credit

00:44:40,869 --> 00:44:44,700
using VIP

00:44:51,750 --> 00:44:54,800
let's remove what

00:45:04,979 --> 00:45:19,659
so that takes a customer and it takes a

00:45:10,089 --> 00:45:24,909
funk and that's the VIP thing that we

00:45:19,659 --> 00:45:27,740
didn't do so that's that thing there so

00:45:24,909 --> 00:45:30,800
we've got a funk of customer to two ball

00:45:27,740 --> 00:45:30,800
[Music]

00:45:39,250 --> 00:45:46,720
so funk of customer to bull

00:45:49,400 --> 00:46:00,020
but you can't do so i copy my copper my

00:45:57,450 --> 00:46:00,020
one that i did earlier

00:46:13,070 --> 00:46:16,730
follow me on TV

00:46:19,180 --> 00:46:28,779
sorry yep so I need to pass that into

00:46:23,589 --> 00:46:28,779
two there sorry yes correct

00:46:32,349 --> 00:46:40,339
so that's what we've got so far and I

00:46:36,140 --> 00:46:41,390
can't usually I can't use link style at

00:46:40,339 --> 00:46:44,150
the moment because these aren't

00:46:41,390 --> 00:46:46,819
extension methods so quickest thing to

00:46:44,150 --> 00:46:49,269
do there see use exception methods just

00:46:46,819 --> 00:46:49,269
to go and put

00:46:55,819 --> 00:46:58,839
we'll see what breaks

00:47:02,540 --> 00:47:13,370
nothing's broken there which is good so

00:47:10,400 --> 00:47:17,290
I should now be able to do return get

00:47:13,370 --> 00:47:17,290
purchase you stock customer dots

00:47:24,730 --> 00:47:28,260
try to promote to the IP

00:48:03,110 --> 00:48:07,190
okay boss spotted

00:48:10,980 --> 00:48:19,350
okay so that's a way of doing function

00:48:15,960 --> 00:48:22,290
composition so what we're doing is we're

00:48:19,350 --> 00:48:23,700
building up a a bigger function out of

00:48:22,290 --> 00:48:25,980
smaller functions but we're not doing it

00:48:23,700 --> 00:48:28,020
in one go what we're doing is doing

00:48:25,980 --> 00:48:31,950
individual bits and chaining them

00:48:28,020 --> 00:48:34,080
together so the first thing that people

00:48:31,950 --> 00:48:35,690
say when they say this is but isn't it

00:48:34,080 --> 00:48:38,119
more efficient to do it in one function

00:48:35,690 --> 00:48:41,670
yes it's possible that you could have

00:48:38,119 --> 00:48:43,290
you could have savings if you put it in

00:48:41,670 --> 00:48:45,450
one function that could be optimizations

00:48:43,290 --> 00:48:48,090
in there that you could find but then

00:48:45,450 --> 00:48:51,900
you're making it harder to read you know

00:48:48,090 --> 00:48:53,280
it's it's do you do you make things so

00:48:51,900 --> 00:48:55,109
that they're very easy to read and to

00:48:53,280 --> 00:48:57,990
work with or do you make things so that

00:48:55,109 --> 00:49:00,210
they're fast most of the time machines

00:48:57,990 --> 00:49:03,359
that we run programs on a plenty fast

00:49:00,210 --> 00:49:06,810
enough you know if you save if you save

00:49:03,359 --> 00:49:09,450
a few milliseconds optimizing this

00:49:06,810 --> 00:49:14,040
function that's nothing compared to one

00:49:09,450 --> 00:49:15,270
call across the network so obviously if

00:49:14,040 --> 00:49:17,310
you're working in banking you need every

00:49:15,270 --> 00:49:19,350
millisecond that makes a difference but

00:49:17,310 --> 00:49:22,080
I don't work in banking okay so back to

00:49:19,350 --> 00:49:23,609
one of the fundamental and idioms of

00:49:22,080 --> 00:49:26,100
functional programming you know it's

00:49:23,609 --> 00:49:28,980
it's write small functions compose them

00:49:26,100 --> 00:49:30,960
together into bigger functions that easy

00:49:28,980 --> 00:49:32,910
to reason about that easy to know if

00:49:30,960 --> 00:49:35,609
there's problem it's easy to find where

00:49:32,910 --> 00:49:38,150
the problem is perhaps the core of

00:49:35,609 --> 00:49:38,150
functional programming

00:49:39,299 --> 00:49:44,569
along with immutable data and pure

00:49:42,119 --> 00:49:44,569
functions

00:49:51,730 --> 00:49:57,440
right so those of you who were looking

00:49:54,980 --> 00:50:00,799
at their my opening screen on PowerPoint

00:49:57,440 --> 00:50:04,910
will have seen the the f-sharp forward

00:50:00,799 --> 00:50:07,210
pipe I love that forward pipe literally

00:50:04,910 --> 00:50:11,119
passes whatever's on the left hand side

00:50:07,210 --> 00:50:13,849
to the right hand side so in this case

00:50:11,119 --> 00:50:16,880
I'll pass customer as a parameter to get

00:50:13,849 --> 00:50:20,749
purchases what gets returned out of that

00:50:16,880 --> 00:50:22,970
will get passed as the parameter to try

00:50:20,749 --> 00:50:24,859
for right to VIP and what gets what gets

00:50:22,970 --> 00:50:30,529
returned from that will get passed as a

00:50:24,859 --> 00:50:33,589
parameter into into this function so

00:50:30,529 --> 00:50:35,720
it's the f-sharp way of doing dots in

00:50:33,589 --> 00:50:38,509
effect it's not as neat as dots

00:50:35,720 --> 00:50:40,430
I will admit but this is nice and

00:50:38,509 --> 00:50:42,529
readable you know see it's nice and nice

00:50:40,430 --> 00:50:44,960
and easy to follow and then there's

00:50:42,529 --> 00:50:46,700
another way of doing it because function

00:50:44,960 --> 00:50:49,849
composition is such a thing is we do it

00:50:46,700 --> 00:50:54,289
that often and you can use the double

00:50:49,849 --> 00:50:56,029
pipe operator and I prefer the for

00:50:54,289 --> 00:51:00,230
they'll prefer the previous one to be

00:50:56,029 --> 00:51:04,730
honest that's just clearer yes they're

00:51:00,230 --> 00:51:06,980
exactly the same it is yes but then six

00:51:04,730 --> 00:51:08,269
months down the line you know I can I

00:51:06,980 --> 00:51:09,259
can look at that and most people can

00:51:08,269 --> 00:51:11,450
look at that and understand what it

00:51:09,259 --> 00:51:13,749
meant whereas whereas the the cleaner

00:51:11,450 --> 00:51:16,130
version people look at it and think

00:51:13,749 --> 00:51:19,930
that's F sharp gobbledygook again

00:51:16,130 --> 00:51:19,930
you know good fun workout what it means

00:51:32,920 --> 00:51:40,789
it in further it's clever enough to know

00:51:36,920 --> 00:51:42,829
that getpurchases takes a customer so

00:51:40,789 --> 00:51:46,940
when you call up great customer it would

00:51:42,829 --> 00:51:51,819
still take a customer as input yes a bit

00:51:46,940 --> 00:51:51,819
through doing in places yes

00:51:52,870 --> 00:51:57,680
so some more fun options

00:51:55,910 --> 00:51:59,630
pattern-matching discriminated unions

00:51:57,680 --> 00:52:02,840
will ignore units and message can't do

00:51:59,630 --> 00:52:06,590
that in in c-sharp at all it's just it's

00:52:02,840 --> 00:52:13,820
just compile time sugar that a shopkin

00:52:06,590 --> 00:52:15,500
dates and so options I'm I'm not I've

00:52:13,820 --> 00:52:17,420
not mentioned with null this evening

00:52:15,500 --> 00:52:20,000
that's all

00:52:17,420 --> 00:52:22,640
so in F sharp and all functional

00:52:20,000 --> 00:52:25,010
languages null is is not allowed it's

00:52:22,640 --> 00:52:27,500
not strictly true but we try not to we

00:52:25,010 --> 00:52:31,370
try not to use it at all we try to use

00:52:27,500 --> 00:52:35,690
other options instead and options is a

00:52:31,370 --> 00:52:37,340
key word there and so an option type you

00:52:35,690 --> 00:52:41,120
can think of as being pretty much like a

00:52:37,340 --> 00:52:46,330
nullable type in c-sharp except it works

00:52:41,120 --> 00:52:46,330
for anything not just value types

00:52:48,580 --> 00:52:57,140
c-sharp eight will be getting one of

00:52:52,760 --> 00:53:00,230
these be interesting to see how they

00:52:57,140 --> 00:53:01,970
implement it because it's because i've

00:53:00,230 --> 00:53:05,570
done an implementation of it in this and

00:53:01,970 --> 00:53:07,130
it's not very nice so we'll see how if

00:53:05,570 --> 00:53:08,930
they've got access to the lower levels

00:53:07,130 --> 00:53:14,720
of the language if they can if they can

00:53:08,930 --> 00:53:15,860
make it neater and easier to use so what

00:53:14,720 --> 00:53:18,200
we're going to do is we're going to add

00:53:15,860 --> 00:53:21,080
a there's a few bits in this we're going

00:53:18,200 --> 00:53:22,520
to add a personal details this is a

00:53:21,080 --> 00:53:26,330
record type so i'm going to create a new

00:53:22,520 --> 00:53:28,760
class called personal details so i'm not

00:53:26,330 --> 00:53:30,500
going to

00:53:28,760 --> 00:53:35,770
I'm not gonna do I'm just going to Nick

00:53:30,500 --> 00:53:35,770
it from the from the Finnish version

00:53:42,580 --> 00:53:46,690
forget this just of the right place

00:54:00,340 --> 00:54:06,050
okay so what we're going to do is we're

00:54:02,390 --> 00:54:06,890
going to add personal details in but

00:54:06,050 --> 00:54:09,380
what we're going to do is we're going to

00:54:06,890 --> 00:54:13,460
make it an optional type so it doesn't

00:54:09,380 --> 00:54:15,620
have to be provided so just like if

00:54:13,460 --> 00:54:16,820
you've got a null in the database you

00:54:15,620 --> 00:54:18,320
know you've got it you've got to handle

00:54:16,820 --> 00:54:19,550
that when you get when you get your

00:54:18,320 --> 00:54:22,340
domain model out you need to have

00:54:19,550 --> 00:54:26,870
something in there too to say there's no

00:54:22,340 --> 00:54:28,550
data but we don't want to use null so

00:54:26,870 --> 00:54:30,110
the idea of an option types and

00:54:28,550 --> 00:54:34,190
obviously nullable types have something

00:54:30,110 --> 00:54:35,270
called House value and value and

00:54:34,190 --> 00:54:36,650
obviously we're not talking about value

00:54:35,270 --> 00:54:37,520
types here we're talking about other

00:54:36,650 --> 00:54:40,370
things

00:54:37,520 --> 00:54:43,790
so what sort an option does generally is

00:54:40,370 --> 00:54:49,550
it has a concept of none ie there's

00:54:43,790 --> 00:54:51,380
nothing or some of something so there's

00:54:49,550 --> 00:54:57,850
either something with a value or there's

00:54:51,380 --> 00:54:57,850
none and that's an option type so if I

00:55:03,920 --> 00:55:11,350
oops so I need to show you what option

00:55:08,690 --> 00:55:11,350
looks like

00:55:21,260 --> 00:55:36,440
if I could find it that's in common

00:55:25,670 --> 00:55:39,590
that's right right so this is all option

00:55:36,440 --> 00:55:47,060
so I said sum of T so it is literally

00:55:39,590 --> 00:55:48,619
som a and the value or it's none and I

00:55:47,060 --> 00:55:52,460
have some little helper functions here

00:55:48,619 --> 00:55:55,190
as well and obviously because this is

00:55:52,460 --> 00:55:57,050
this is the first cast support in Afshar

00:55:55,190 --> 00:55:59,060
we don't need to do all of this sort of

00:55:57,050 --> 00:56:01,790
stuff hopefully you won't need to do all

00:55:59,060 --> 00:56:04,010
of this when c-sharp eight comes out

00:56:01,790 --> 00:56:10,220
hopefully it'll all be all be nicely

00:56:04,010 --> 00:56:13,070
done for you so the idea is that by by

00:56:10,220 --> 00:56:16,780
making this an option of something so if

00:56:13,070 --> 00:56:16,780
I go into my types

00:56:25,250 --> 00:56:29,330
so for make this an option of

00:56:34,580 --> 00:56:47,119
[Music]

00:56:37,160 --> 00:56:52,099
I hope if I copy the so I highlighted

00:56:47,119 --> 00:57:02,720
them and then didn't copy them over so

00:56:52,099 --> 00:57:05,750
we take all of that that's in common so

00:57:02,720 --> 00:57:14,680
I pasted at the right place and that

00:57:05,750 --> 00:57:14,680
should be okay so we now got that

00:57:15,910 --> 00:57:20,079
so in optional personal details

00:57:28,800 --> 00:57:32,400
let's just gotta getta

00:57:34,079 --> 00:57:37,950
obviously need to pass that in as well

00:57:43,260 --> 00:57:45,859
and

00:57:55,440 --> 00:58:04,869
okay so what impact does that have

00:58:00,970 --> 00:58:08,560
well obviously when I create your

00:58:04,869 --> 00:58:09,850
customer I've now got to handle this so

00:58:08,560 --> 00:58:13,810
I now put an option in there

00:58:09,850 --> 00:58:16,300
so because I'm using the Builder let's

00:58:13,810 --> 00:58:17,350
go and have a that's kind of a little

00:58:16,300 --> 00:58:28,470
noisy at what we need to do with the

00:58:17,350 --> 00:58:28,470
Builder too many things I'm here

00:58:34,960 --> 00:58:39,460
right so obviously my builder won't

00:58:37,000 --> 00:58:43,540
compile anymore because it needs that

00:58:39,460 --> 00:58:45,750
option of a thing coming in so let's go

00:58:43,540 --> 00:58:45,750
on out

00:58:48,740 --> 00:58:58,910
so private option of personal details

00:59:21,010 --> 00:59:25,180
okay I'll do that there as well

00:59:34,120 --> 00:59:38,380
so with personal details

00:59:59,680 --> 01:00:02,250
and

01:00:11,310 --> 01:00:18,330
sorry I'm trying to induce without

01:00:15,940 --> 01:00:18,330
making mistakes

01:00:31,930 --> 01:00:35,910
right that should be that should compile

01:00:33,640 --> 01:00:35,910
now

01:00:50,140 --> 01:00:54,760
okay I'm missing using again

01:01:13,110 --> 01:01:18,180
okay I'm coming that out for the moment

01:01:15,330 --> 01:01:19,710
I really want to be where to look at how

01:01:18,180 --> 01:01:21,090
I know why just we can't create the

01:01:19,710 --> 01:01:23,450
customer first of all so there's a new

01:01:21,090 --> 01:01:26,610
that's what I'm creating a new customer

01:01:23,450 --> 01:01:36,720
so that's something that's worth a go

01:01:26,610 --> 01:01:38,070
and see if we can sort that out so if I

01:01:36,720 --> 01:01:41,310
haven't got personal details

01:01:38,070 --> 01:01:45,950
I need none so what I can do is I can do

01:01:41,310 --> 01:01:45,950
none dot value

01:02:00,140 --> 01:02:07,710
I've got my way that this stuff again I

01:02:02,970 --> 01:02:09,630
only ignore that for the moment so let's

01:02:07,710 --> 01:02:15,680
create that's copy that line and let's

01:02:09,630 --> 01:02:15,680
try dry one one with them with the some

01:02:26,130 --> 01:02:32,220
so what I'd normally do in a shop is

01:02:27,690 --> 01:02:34,849
just to create a new personal data fact

01:02:32,220 --> 01:02:34,849
I'll do that anyway

01:02:52,319 --> 01:02:56,279
what we think of happened there

01:03:06,790 --> 01:03:15,609
it looks pretty much like it doesn't it

01:03:09,910 --> 01:03:17,630
so that's let's try and see what happens

01:03:15,609 --> 01:03:18,980
see part of the thing because you're

01:03:17,630 --> 01:03:20,840
making small changes with functional

01:03:18,980 --> 01:03:22,670
programming one of the things we tend to

01:03:20,840 --> 01:03:24,980
do is it's play around a lot to be

01:03:22,670 --> 01:03:27,109
honest just try stuff out and see if it

01:03:24,980 --> 01:03:30,410
works and if it doesn't try something

01:03:27,109 --> 01:03:32,090
different so let's run these and see

01:03:30,410 --> 01:03:35,740
what happens let's build it first if it

01:03:32,090 --> 01:03:35,740
if it says that's okay

01:03:43,550 --> 01:03:52,230
so I haven't got my on my to string for

01:03:49,410 --> 01:03:57,660
the customer I've not put the I've not

01:03:52,230 --> 01:03:59,960
put it on for the the personal detail

01:03:57,660 --> 01:03:59,960
shirts

01:04:30,540 --> 01:04:33,560
let's try again

01:04:48,190 --> 01:04:56,240
okay so what I've got there is the

01:04:52,940 --> 01:05:02,720
equipment of none because if I look at

01:04:56,240 --> 01:05:04,940
my the Khmer little helper here I've got

01:05:02,720 --> 01:05:07,520
something called reduce and what this

01:05:04,940 --> 01:05:09,920
does is takes that option of personal

01:05:07,520 --> 01:05:12,950
details and says if there is if it's

01:05:09,920 --> 01:05:15,110
none I can't use null because we're not

01:05:12,950 --> 01:05:16,400
allowed to use null so what I'm going to

01:05:15,110 --> 01:05:18,530
do is give you some values so if you

01:05:16,400 --> 01:05:21,320
imagine I was saving that back to the

01:05:18,530 --> 01:05:26,360
database so I'm saving three fields back

01:05:21,320 --> 01:05:27,950
to the database I can't send null how I

01:05:26,360 --> 01:05:30,350
could send null if I want to talk I put

01:05:27,950 --> 01:05:32,750
null into this but I don't want to in

01:05:30,350 --> 01:05:35,030
this case I want to put in empty string

01:05:32,750 --> 01:05:37,460
empty string and date time today but I

01:05:35,030 --> 01:05:39,230
could have put nulls in there so the

01:05:37,460 --> 01:05:43,010
idea of option of T is that your domain

01:05:39,230 --> 01:05:45,380
model can contain semantic meaning so it

01:05:43,010 --> 01:05:47,000
can say this is this is you can provide

01:05:45,380 --> 01:05:48,620
this or not provide it it depends and

01:05:47,000 --> 01:05:50,930
then when you come to story in the

01:05:48,620 --> 01:05:53,150
database you can store it the completely

01:05:50,930 --> 01:05:55,220
different structure so you can convert

01:05:53,150 --> 01:05:57,800
one from one to the other quite easily

01:05:55,220 --> 01:06:00,920
the same from you think about it from

01:05:57,800 --> 01:06:02,540
user input user input isn't going to be

01:06:00,920 --> 01:06:05,240
in personal details user input is going

01:06:02,540 --> 01:06:07,850
to be three fields and that may come

01:06:05,240 --> 01:06:10,040
through with data may not and then

01:06:07,850 --> 01:06:14,210
you've got to convert that to a to an

01:06:10,040 --> 01:06:17,360
option of personal details so the whole

01:06:14,210 --> 01:06:20,960
idea of an option is you've either got

01:06:17,360 --> 01:06:25,400
data or you haven't got data so this is

01:06:20,960 --> 01:06:28,270
just a way of handling that so we need

01:06:25,400 --> 01:06:28,270
to work out how to get some data

01:06:36,390 --> 01:06:40,130
so to save me tightening

01:07:00,000 --> 01:07:05,010
so that comes through the reason I can

01:07:02,460 --> 01:07:07,050
type in just the new personal details

01:07:05,010 --> 01:07:08,760
and not have to bother about option is

01:07:07,050 --> 01:07:11,420
because of some of the work that I did

01:07:08,760 --> 01:07:11,420
on the types

01:07:18,549 --> 01:07:25,640
so the type has an implicit operator

01:07:21,589 --> 01:07:28,819
that will convert whatever you send in

01:07:25,640 --> 01:07:30,349
if you send in some data of that type it

01:07:28,819 --> 01:07:32,119
will automatically convert it to a sum

01:07:30,349 --> 01:07:37,969
of that type you don't need to know any

01:07:32,119 --> 01:07:39,380
work of it work on it at all but as I

01:07:37,969 --> 01:07:42,650
said this will be done this will be done

01:07:39,380 --> 01:07:45,769
properly in c-sharp 8 and will be much

01:07:42,650 --> 01:07:48,140
more much more obvious how it's supposed

01:07:45,769 --> 01:07:52,249
to work but this concept of being able

01:07:48,140 --> 01:07:54,829
to build domain models that are not just

01:07:52,249 --> 01:07:56,749
series of of properties but actually

01:07:54,829 --> 01:07:59,749
properties combined into other things

01:07:56,749 --> 01:08:03,559
and that you can tell it that that thing

01:07:59,749 --> 01:08:07,909
can be there or not there very easily is

01:08:03,559 --> 01:08:10,009
a really powerful thing so I use this

01:08:07,909 --> 01:08:13,640
all the time I use this this type of

01:08:10,009 --> 01:08:14,959
structure you know how it's stored and

01:08:13,640 --> 01:08:16,819
how its how it comes in from the UI

01:08:14,959 --> 01:08:18,339
they're two totally different things the

01:08:16,819 --> 01:08:21,380
data structures are completely different

01:08:18,339 --> 01:08:24,109
but how how I manage it in the middle is

01:08:21,380 --> 01:08:25,880
how I want to make my domain model look

01:08:24,109 --> 01:08:28,940
so when Tom Lee from the business looks

01:08:25,880 --> 01:08:30,109
at and we talk where we talk about one

01:08:28,940 --> 01:08:32,029
of our structures we've talked about

01:08:30,109 --> 01:08:36,460
personal details and it means something

01:08:32,029 --> 01:08:38,630
to the to the the BAS and the modelers

01:08:36,460 --> 01:08:40,779
whereas giving them three fields of

01:08:38,630 --> 01:08:44,089
first name last name and date of birth

01:08:40,779 --> 01:08:46,069
you know in that case it's probably okay

01:08:44,089 --> 01:08:47,659
but but it's actually they actually have

01:08:46,069 --> 01:08:49,520
business meaning combined together and

01:08:47,659 --> 01:08:52,460
there may be some rules that go with

01:08:49,520 --> 01:08:55,179
them as well so you can combine that

01:08:52,460 --> 01:08:55,179
into this as well

01:08:57,600 --> 01:09:15,100
so option of T is going to become very

01:09:00,250 --> 01:09:16,840
very important discriminated unions so

01:09:15,100 --> 01:09:18,010
the idea of a discriminated union so

01:09:16,840 --> 01:09:21,160
what we'll have a look at there is

01:09:18,010 --> 01:09:25,030
notifications so notifications can

01:09:21,160 --> 01:09:28,180
either be no notifications or you want

01:09:25,030 --> 01:09:29,860
to receive notifications and it's

01:09:28,180 --> 01:09:33,610
whether you want to receive deals or

01:09:29,860 --> 01:09:36,690
alerts or and alerts in there as well so

01:09:33,610 --> 01:09:39,340
they're two different things

01:09:36,690 --> 01:09:44,050
so that's all we need to type in for

01:09:39,340 --> 01:09:46,180
f-sharp if you compile this and D

01:09:44,050 --> 01:09:48,610
compile it in c-sharp what you actually

01:09:46,180 --> 01:09:51,430
get is an abstract class called

01:09:48,610 --> 01:09:54,210
notifications and two concrete classes

01:09:51,430 --> 01:09:57,970
one called no notifications with no

01:09:54,210 --> 01:10:02,110
nobody and you get received

01:09:57,970 --> 01:10:06,970
notifications that has two properties on

01:10:02,110 --> 01:10:08,320
it so it does compile down to 2c show is

01:10:06,970 --> 01:10:10,360
still il at the end of the day it's

01:10:08,320 --> 01:10:12,100
still it still works in C show it

01:10:10,360 --> 01:10:18,400
doesn't quite have the same meaning as

01:10:12,100 --> 01:10:20,380
it does in Afshar it's an F sharp if you

01:10:18,400 --> 01:10:23,950
want to add extra things you've got to

01:10:20,380 --> 01:10:26,020
add them onto the onto the onto the

01:10:23,950 --> 01:10:28,330
discriminated union if you want an extra

01:10:26,020 --> 01:10:30,100
if you want an extra concrete type you

01:10:28,330 --> 01:10:32,640
can add it wherever you like you know

01:10:30,100 --> 01:10:35,230
nobody can nobody can know about it

01:10:32,640 --> 01:10:37,770
whereas with this it sits in one place

01:10:35,230 --> 01:10:37,770
and that's it

01:10:39,150 --> 01:10:43,120
so the idea of this again we're going

01:10:41,350 --> 01:10:46,270
back to our domain model our domain

01:10:43,120 --> 01:10:48,040
model isn't two properties so it isn't

01:10:46,270 --> 01:10:51,220
the property that says receive deals and

01:10:48,040 --> 01:10:53,320
receive alerts what it actually is its

01:10:51,220 --> 01:10:55,860
meaning it means you write your either

01:10:53,320 --> 01:11:01,240
no notifications or you want to receive

01:10:55,860 --> 01:11:03,820
deals or alerts so your domain model can

01:11:01,240 --> 01:11:05,810
contain our notifications property

01:11:03,820 --> 01:11:09,470
rather than

01:11:05,810 --> 01:11:11,930
two separate properties that you need to

01:11:09,470 --> 01:11:17,840
do you need to just you know handle

01:11:11,930 --> 01:11:20,000
separately does that make sense okay

01:11:17,840 --> 01:11:21,950
this is a very powerful thing in

01:11:20,000 --> 01:11:23,570
functional programming and under main

01:11:21,950 --> 01:11:24,830
modeling one of the big things one of

01:11:23,570 --> 01:11:27,710
the big things that's come out over the

01:11:24,830 --> 01:11:30,200
last couple of years is everybody thinks

01:11:27,710 --> 01:11:33,710
functional programming is for you know

01:11:30,200 --> 01:11:36,340
maths geeks and for people who deal with

01:11:33,710 --> 01:11:38,630
millions of rows of data it's not

01:11:36,340 --> 01:11:41,330
functional programming is for everybody

01:11:38,630 --> 01:11:42,740
you know domain modeling in a functional

01:11:41,330 --> 01:11:45,320
language particularly F sharp there's a

01:11:42,740 --> 01:11:49,430
book out there by Scott flushing called

01:11:45,320 --> 01:11:50,870
domain modeling domain modeling in a

01:11:49,430 --> 01:11:53,020
shot made simple I think it's called

01:11:50,870 --> 01:11:55,700
what the main modeling made simple and

01:11:53,020 --> 01:11:57,950
so he takes all of these business he

01:11:55,700 --> 01:12:00,770
type problems or domain problems and

01:11:57,950 --> 01:12:03,170
writes f sharp you know it does all of

01:12:00,770 --> 01:12:04,730
this in F sharp and a lot of it so a

01:12:03,170 --> 01:12:07,430
sales domain could be written on a

01:12:04,730 --> 01:12:09,560
single page the whole domain model for a

01:12:07,430 --> 01:12:11,570
sale system you know it's a very

01:12:09,560 --> 01:12:14,300
powerful it's a very powerful set of

01:12:11,570 --> 01:12:16,250
tools but people don't look at it

01:12:14,300 --> 01:12:18,170
because they've been told that

01:12:16,250 --> 01:12:21,290
functional programming is not for the

01:12:18,170 --> 01:12:24,350
stuff they do day-to-day but actually it

01:12:21,290 --> 01:12:25,520
is you know you can be much more

01:12:24,350 --> 01:12:27,950
productive in the functional language

01:12:25,520 --> 01:12:29,870
you might much less code and it's still

01:12:27,950 --> 01:12:31,700
just as readable if not more readable

01:12:29,870 --> 01:12:36,230
because you've got you've got less noise

01:12:31,700 --> 01:12:38,680
there so as I said notifications will be

01:12:36,230 --> 01:12:38,680
a

01:12:42,050 --> 01:12:49,290
so notifications is a is a an abstract

01:12:45,210 --> 01:12:52,860
class and then there's a class called no

01:12:49,290 --> 01:12:54,480
notifications which I've just put an

01:12:52,860 --> 01:12:57,900
override a two string in there as I felt

01:12:54,480 --> 01:13:00,030
like it and then there's a receive

01:12:57,900 --> 01:13:05,599
notifications that is just an immutable

01:13:00,030 --> 01:13:08,309
class again so if I go back to my

01:13:05,599 --> 01:13:12,510
original type so I need to copy those

01:13:08,309 --> 01:13:15,079
out again and put them into my ear into

01:13:12,510 --> 01:13:15,079
my new class

01:13:27,310 --> 01:13:41,030
so I've now got I've now got a public

01:13:34,010 --> 01:13:44,170
property called notifications sorry of

01:13:41,030 --> 01:13:44,170
tight notifications

01:13:52,280 --> 01:13:55,969
that I can pass in

01:14:12,660 --> 01:14:22,290
I probably need to add the the thing to

01:14:15,120 --> 01:14:23,850
the to string as well so so far it's

01:14:22,290 --> 01:14:25,220
like what you do okay so we've got a bit

01:14:23,850 --> 01:14:27,900
more semantic meaning about the domain

01:14:25,220 --> 01:14:29,100
how to actually use this well that's

01:14:27,900 --> 01:14:29,610
what the other thing comes in pattern

01:14:29,100 --> 01:14:31,320
matching

01:14:29,610 --> 01:14:34,260
so pattern matching came into each up

01:14:31,320 --> 01:14:37,320
seven what you've got in c-sharp seven

01:14:34,260 --> 01:14:40,200
is about 10% of what f-sharp can date

01:14:37,320 --> 01:14:43,770
you're going to get another 20 or 30% in

01:14:40,200 --> 01:14:45,540
c-sharp 8 but it's still not the whole

01:14:43,770 --> 01:14:50,180
lot there's a load of other stuff as

01:14:45,540 --> 01:14:52,620
well so the idea of pattern matching is

01:14:50,180 --> 01:14:54,720
has anybody ever been told never use a

01:14:52,620 --> 01:14:58,380
switch statement you know it's is about

01:14:54,720 --> 01:15:01,770
to use now pattern matching is coming in

01:14:58,380 --> 01:15:02,760
switching is good again I'm sorry but

01:15:01,770 --> 01:15:14,340
that's just the way it is

01:15:02,760 --> 01:15:17,000
so find my my instance of this the loss

01:15:14,340 --> 01:15:17,000
where I am now

01:15:21,239 --> 01:15:24,410
oh the one that

01:15:29,450 --> 01:15:40,690
no I do need to be in functions right

01:15:37,210 --> 01:15:47,000
sort and do so this is function which is

01:15:40,690 --> 01:15:49,060
get alert and what this does so this is

01:15:47,000 --> 01:15:52,490
mission it's extension method as well

01:15:49,060 --> 01:15:54,770
so it takes a customer and what it does

01:15:52,490 --> 01:15:57,050
is it looks it switches on customer dot

01:15:54,770 --> 01:15:59,650
notifications and the pattern matching

01:15:57,050 --> 01:16:01,820
part is the fact you can match on types

01:15:59,650 --> 01:16:05,840
now that you've never been able to do

01:16:01,820 --> 01:16:08,780
before in a switch so because we're

01:16:05,840 --> 01:16:11,110
storing there either no notification or

01:16:08,780 --> 01:16:15,410
the received notification with some data

01:16:11,110 --> 01:16:16,940
we can now pattern match on that so

01:16:15,410 --> 01:16:18,440
rather than having to do F ends and

01:16:16,940 --> 01:16:20,780
everything else and try and if you've

01:16:18,440 --> 01:16:22,160
got four or five parameters trying to

01:16:20,780 --> 01:16:24,350
get all the combinations isn't going to

01:16:22,160 --> 01:16:26,750
work this is a much more powerful way of

01:16:24,350 --> 01:16:31,400
doing it it's a much more readable way

01:16:26,750 --> 01:16:35,210
of doing it so if we take received

01:16:31,400 --> 01:16:38,860
notifications and you get a you get a

01:16:35,210 --> 01:16:42,170
little thing that you're doing in in

01:16:38,860 --> 01:16:44,240
link all the land of stuff that you can

01:16:42,170 --> 01:16:46,510
then say does it want to receive alerts

01:16:44,240 --> 01:16:49,100
if it does do something

01:16:46,510 --> 01:16:50,990
this little underscore here is a wild

01:16:49,100 --> 01:16:55,370
card it just means I'm not interested in

01:16:50,990 --> 01:16:57,320
that and in that case I don't want

01:16:55,370 --> 01:17:00,350
alerts and the other one is just saying

01:16:57,320 --> 01:17:01,880
you know I'm no notifications anyway the

01:17:00,350 --> 01:17:03,380
thing to take away from this is this

01:17:01,880 --> 01:17:06,860
three the three things we talked about

01:17:03,380 --> 01:17:08,750
the beginning which was build functions

01:17:06,860 --> 01:17:09,980
pure functions in particular you know

01:17:08,750 --> 01:17:13,880
higher-order functions all about

01:17:09,980 --> 01:17:16,690
functions immutability if stuff doesn't

01:17:13,880 --> 01:17:18,650
change you're not going to break it

01:17:16,690 --> 01:17:22,030
that's not strictly true because

01:17:18,650 --> 01:17:25,280
obviously you've got you've got

01:17:22,030 --> 01:17:27,290
reflection and I know a lot of people

01:17:25,280 --> 01:17:28,430
that that because they can't get at a

01:17:27,290 --> 01:17:31,430
private variable would just use

01:17:28,430 --> 01:17:33,770
reflection to do it so yeah it's one of

01:17:31,430 --> 01:17:40,460
those things and that separation between

01:17:33,770 --> 01:17:42,769
data and functions you know have small

01:17:40,460 --> 01:17:45,380
classes of data you know that

01:17:42,769 --> 01:17:47,300
that means something I'm passing off the

01:17:45,380 --> 01:17:49,249
functions to do some work that easy

01:17:47,300 --> 01:17:56,869
can't combine them together it's dead

01:17:49,249 --> 01:18:00,530
easy so where can I learn more and the

01:17:56,869 --> 01:18:03,050
first book it's really good what he

01:18:00,530 --> 01:18:04,340
studies right a library that takes all

01:18:03,050 --> 01:18:08,929
the things that you learned from a shelf

01:18:04,340 --> 01:18:10,880
and put them into c-sharp it's much

01:18:08,929 --> 01:18:13,849
nicer than the stuff that I've done then

01:18:10,880 --> 01:18:15,920
here but it's still a little bit over

01:18:13,849 --> 01:18:17,510
the top by that person you know it's a

01:18:15,920 --> 01:18:19,699
good book if you want to read about

01:18:17,510 --> 01:18:22,210
functional stuff in c-sharp that's

01:18:19,699 --> 01:18:24,920
probably my favorite book second one

01:18:22,210 --> 01:18:27,469
it's not as good but it's a little bit

01:18:24,920 --> 01:18:29,900
easier to follow and the third book on

01:18:27,469 --> 01:18:34,849
the end though have a copy here which

01:18:29,900 --> 01:18:36,710
giving away and it's the real deal and I

01:18:34,849 --> 01:18:41,989
shall read it you'll be converted you

01:18:36,710 --> 01:18:43,130
won't want to go back with that thank

01:18:41,989 --> 01:18:49,130
you

01:18:43,130 --> 01:18:49,130

YouTube URL: https://www.youtube.com/watch?v=Yq7WuIiOb_A


