Title: Building Serverless Workflows with Durable Functions - Developer South Coast - December 2018
Publication date: 2018-12-19
Playlist: Developer South Coast
Description: 
	Presented by Mark Heath.

Azure Functions makes it super quick and easy to write create cloud-based functions to respond to events, but once you start connecting functions together into a workflow, things can get complex and chaotic very quickly. In this session Mark will demonstrate how Durable Functions lets you take back control of your serverless workflows, allowing you to keep track of progress and implement advanced workflow patterns such as fan out and fan in, and waiting for external approval.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:05,339
this evening I'm going to talk about as

00:00:01,680 --> 00:00:07,410
your durable functions now I don't know

00:00:05,339 --> 00:00:09,000
how many of you know about if you know

00:00:07,410 --> 00:00:11,309
about Asia functions who have used them

00:00:09,000 --> 00:00:12,960
a few of you okay

00:00:11,309 --> 00:00:15,059
so what I thought we'd do would be to

00:00:12,960 --> 00:00:17,430
start off just with a bit of an overview

00:00:15,059 --> 00:00:19,470
of Asia functions and then we'll get

00:00:17,430 --> 00:00:22,859
into what durable functions adds to that

00:00:19,470 --> 00:00:25,289
later on just to introduce myself

00:00:22,859 --> 00:00:26,760
I'm actually local becoming to this user

00:00:25,289 --> 00:00:28,920
group for a while work for a company

00:00:26,760 --> 00:00:31,980
called nice I also make a number of

00:00:28,920 --> 00:00:37,350
courses for Pluralsight four of them are

00:00:31,980 --> 00:00:39,899
on Asia functions and in fact one of the

00:00:37,350 --> 00:00:42,989
ones I recently published which is

00:00:39,899 --> 00:00:45,210
called as your developer create service

00:00:42,989 --> 00:00:48,450
functions is part of the new Microsoft

00:00:45,210 --> 00:00:50,010
learn initiative which means that you

00:00:48,450 --> 00:00:52,410
can watch this for free even if you're

00:00:50,010 --> 00:00:54,600
not a Pluralsight subscriber so if you'd

00:00:52,410 --> 00:00:56,730
like kind of an introduction to Asha

00:00:54,600 --> 00:00:59,579
functions that takes you through all the

00:00:56,730 --> 00:01:03,120
basics then go via the Microsoft Learn

00:00:59,579 --> 00:01:06,090
website and that will enable you to

00:01:03,120 --> 00:01:07,200
access that I've also been coming to

00:01:06,090 --> 00:01:10,320
this user group for quite a while I

00:01:07,200 --> 00:01:12,750
looked up in my email inbox weren't my

00:01:10,320 --> 00:01:16,920
first session at this user group was in

00:01:12,750 --> 00:01:21,810
it's from November 2007 I came to Visual

00:01:16,920 --> 00:01:24,570
Studio 2008 and dotnet 3.5 which was the

00:01:21,810 --> 00:01:26,159
second ever it wasn't called dev

00:01:24,570 --> 00:01:28,170
Southcoast it was called next-gen user

00:01:26,159 --> 00:01:28,770
group but as you can see some things

00:01:28,170 --> 00:01:32,130
never change

00:01:28,770 --> 00:01:33,689
Pizza and swag and the reason I wanted

00:01:32,130 --> 00:01:35,700
to show this slide was not to brag about

00:01:33,689 --> 00:01:38,009
how long I've been coming but I thought

00:01:35,700 --> 00:01:40,560
it'd be a way to say thanks to John and

00:01:38,009 --> 00:01:42,150
Richy for running this group for such a

00:01:40,560 --> 00:01:44,280
long time I've really enjoyed being part

00:01:42,150 --> 00:01:46,590
of it and I know they had an

00:01:44,280 --> 00:01:49,380
announcement last week about planning to

00:01:46,590 --> 00:01:51,540
hand it over but it's been an impressive

00:01:49,380 --> 00:01:53,310
long innings so well done to you guys

00:01:51,540 --> 00:01:56,159
and hopefully we'll find the right

00:01:53,310 --> 00:02:02,280
people to take the group forwards long

00:01:56,159 --> 00:02:04,380
into the future so as your functions one

00:02:02,280 --> 00:02:05,310
of the questions that may arise when you

00:02:04,380 --> 00:02:06,840
think about something like arrow

00:02:05,310 --> 00:02:09,330
functions is why on earth do we need

00:02:06,840 --> 00:02:11,819
another way to run code in the cloud

00:02:09,330 --> 00:02:13,890
there are already many different options

00:02:11,819 --> 00:02:17,190
that you can take if you've got an app

00:02:13,890 --> 00:02:18,810
you want to run and host it in Asia you

00:02:17,190 --> 00:02:20,970
can go the kind of traditional is

00:02:18,810 --> 00:02:22,980
approach where you provision a virtual

00:02:20,970 --> 00:02:25,200
machine you can install whatever you

00:02:22,980 --> 00:02:29,550
like onto that virtual machine be it

00:02:25,200 --> 00:02:32,490
websites or windows services or Linux in

00:02:29,550 --> 00:02:34,320
any language and if that was very much

00:02:32,490 --> 00:02:38,430
the standard way that we would get code

00:02:34,320 --> 00:02:41,970
running in our data centers or in the

00:02:38,430 --> 00:02:45,420
cloud traditionally however we're seeing

00:02:41,970 --> 00:02:48,360
a shift away from pure is at the moment

00:02:45,420 --> 00:02:50,550
because of the ops overhead involved in

00:02:48,360 --> 00:02:52,860
that there's a when you spin up a

00:02:50,550 --> 00:02:54,330
virtual machine you've got to maintain

00:02:52,860 --> 00:02:55,620
it you've got to make sure the operating

00:02:54,330 --> 00:02:58,470
system is patched you've got to make

00:02:55,620 --> 00:03:00,480
sure that it's still running and so

00:02:58,470 --> 00:03:04,110
we've seen a move away from is towards

00:03:00,480 --> 00:03:06,140
pass platform as a service and as you've

00:03:04,110 --> 00:03:08,910
got a few different pairs offerings

00:03:06,140 --> 00:03:11,160
they're kind of premium one is what's

00:03:08,910 --> 00:03:13,380
called as your app service which allows

00:03:11,160 --> 00:03:15,239
you to easily run your web applications

00:03:13,380 --> 00:03:17,550
and they can be in a variety of

00:03:15,239 --> 00:03:20,370
different programming languages they can

00:03:17,550 --> 00:03:21,920
be as you'd expect net but you can also

00:03:20,370 --> 00:03:25,410
use nodejs

00:03:21,920 --> 00:03:28,110
PHP Python Java all the kind of usual

00:03:25,410 --> 00:03:30,959
ones and as your app service all also

00:03:28,110 --> 00:03:32,370
supports this concept of web jobs which

00:03:30,959 --> 00:03:35,010
is for your long-running background

00:03:32,370 --> 00:03:37,260
tasks so things like you want to listen

00:03:35,010 --> 00:03:38,940
to messages on a queue or maybe you've

00:03:37,260 --> 00:03:42,989
got scheduled background jobs that you

00:03:38,940 --> 00:03:44,880
want to run and also even more recently

00:03:42,989 --> 00:03:47,910
we've seen the meteoric rise of

00:03:44,880 --> 00:03:49,769
containers so I don't know how many how

00:03:47,910 --> 00:03:53,370
many of you played with docker at all

00:03:49,769 --> 00:03:57,420
okay how many of you using docker in

00:03:53,370 --> 00:03:59,220
production okay not so many not so many

00:03:57,420 --> 00:04:02,220
I mean it's still relatively new

00:03:59,220 --> 00:04:04,320
technology but all of the cloud vendors

00:04:02,220 --> 00:04:06,989
are really adopting it and offering you

00:04:04,320 --> 00:04:08,610
many ways of running containers and Asia

00:04:06,989 --> 00:04:10,739
has got several services whether you

00:04:08,610 --> 00:04:13,320
just want to quickly spin up a single

00:04:10,739 --> 00:04:16,640
container with a CI or you want to have

00:04:13,320 --> 00:04:19,700
a full kubernetes cluster with aks

00:04:16,640 --> 00:04:23,400
there's lots of ways to run containers

00:04:19,700 --> 00:04:25,800
however as your functions fits into a

00:04:23,400 --> 00:04:27,870
slightly different category of running

00:04:25,800 --> 00:04:29,850
code in the crowd which is

00:04:27,870 --> 00:04:32,460
become known as functions as a service

00:04:29,850 --> 00:04:35,280
or service which we'll talk about in a

00:04:32,460 --> 00:04:37,500
minute and a number of the major cloud

00:04:35,280 --> 00:04:38,639
providers have got different functions

00:04:37,500 --> 00:04:40,729
as a service offerings

00:04:38,639 --> 00:04:44,040
I think Amazon were the first with

00:04:40,729 --> 00:04:46,169
lambda but Google have got them I think

00:04:44,040 --> 00:04:50,699
IBM's one is open wisk

00:04:46,169 --> 00:04:52,410
or something and all really all the

00:04:50,699 --> 00:04:55,199
functions as a service platform is it's

00:04:52,410 --> 00:04:57,600
a managed platform that you provide your

00:04:55,199 --> 00:04:59,400
code in the form of simply a function so

00:04:57,600 --> 00:05:01,650
it's quite a small unit of deployment

00:04:59,400 --> 00:05:03,900
and you're and you say that I want my

00:05:01,650 --> 00:05:05,550
function to run in response to some kind

00:05:03,900 --> 00:05:08,160
of event so it's event-driven

00:05:05,550 --> 00:05:11,760
programming in the cloud and these

00:05:08,160 --> 00:05:13,380
events are known as triggers and so

00:05:11,760 --> 00:05:16,470
here's an example of some of the

00:05:13,380 --> 00:05:19,289
triggers that Asha functions supports so

00:05:16,470 --> 00:05:21,419
one of the triggers is HTTP request and

00:05:19,289 --> 00:05:23,039
this is particularly flexible because

00:05:21,419 --> 00:05:25,620
that means you can use Azure functions

00:05:23,039 --> 00:05:27,870
to implement web api s-- so you could

00:05:25,620 --> 00:05:29,729
say when a get request comes in on this

00:05:27,870 --> 00:05:31,680
endpoint i want to run this function and

00:05:29,729 --> 00:05:33,030
when a post comes in on this other

00:05:31,680 --> 00:05:35,610
endpoint I want to run a different

00:05:33,030 --> 00:05:37,889
function it's also very popular for

00:05:35,610 --> 00:05:40,080
setting up web app listeners so if

00:05:37,889 --> 00:05:42,030
you've got an external system that

00:05:40,080 --> 00:05:44,419
provides web hooks to tell you about

00:05:42,030 --> 00:05:47,010
interesting things for example github

00:05:44,419 --> 00:05:49,410
produces web hooks slack produces web

00:05:47,010 --> 00:05:53,039
web hooks it's very easy to create a

00:05:49,410 --> 00:05:55,080
simple Asia function to host your code

00:05:53,039 --> 00:05:57,870
that it's going to run in response to

00:05:55,080 --> 00:06:00,450
that web hook but it's not just about

00:05:57,870 --> 00:06:02,880
HTTP requests you can also implement

00:06:00,450 --> 00:06:05,160
scheduled functions in Azure functions

00:06:02,880 --> 00:06:08,220
so you can have a timer trigger you can

00:06:05,160 --> 00:06:10,200
also listen on queues so again if you

00:06:08,220 --> 00:06:12,510
want to implement your asynchronous

00:06:10,200 --> 00:06:13,650
tasks by listening on queues and we'll

00:06:12,510 --> 00:06:17,160
be talking quite a bit more about that

00:06:13,650 --> 00:06:19,289
later this evening you can do that but

00:06:17,160 --> 00:06:22,380
it's also got lots of integrations with

00:06:19,289 --> 00:06:24,270
other systems so for example Azure blob

00:06:22,380 --> 00:06:26,190
storage where you can store files you

00:06:24,270 --> 00:06:28,050
can say whenever a new file gets

00:06:26,190 --> 00:06:31,349
uploaded so blob storage I want that to

00:06:28,050 --> 00:06:34,260
trigger a new function or cosmos DB

00:06:31,349 --> 00:06:37,080
which is one of Ash's document databases

00:06:34,260 --> 00:06:40,140
you can say whenever a document is added

00:06:37,080 --> 00:06:42,499
or updated in cosmos DB I want that to

00:06:40,140 --> 00:06:44,819
trigger a function

00:06:42,499 --> 00:06:46,889
now the unique selling point of

00:06:44,819 --> 00:06:49,979
functions is the service platforms is

00:06:46,889 --> 00:06:53,189
what's known as service and service

00:06:49,979 --> 00:06:55,800
again is a buzzword that has risen in

00:06:53,189 --> 00:06:58,289
popularity over the last few years is

00:06:55,800 --> 00:07:02,430
criticized because spoiler alert there

00:06:58,289 --> 00:07:04,680
are actually still service but the way I

00:07:02,430 --> 00:07:08,849
see service is there are three kind of

00:07:04,680 --> 00:07:10,229
big ideas to it first of all you're not

00:07:08,849 --> 00:07:11,099
you don't want to manage the service

00:07:10,229 --> 00:07:15,120
yourself so they're completely

00:07:11,099 --> 00:07:16,710
abstracted away from you so when you run

00:07:15,120 --> 00:07:18,599
as your functions you don't have to

00:07:16,710 --> 00:07:21,509
worry about what versions of the

00:07:18,599 --> 00:07:22,740
operating system they're running they're

00:07:21,509 --> 00:07:24,899
the servers are just there in the

00:07:22,740 --> 00:07:28,830
background but secondly there's

00:07:24,899 --> 00:07:29,909
automatic scale so when you provision as

00:07:28,830 --> 00:07:32,490
your functions you're not kind of

00:07:29,909 --> 00:07:34,139
picking a size small medium or large as

00:07:32,490 --> 00:07:37,919
your functions is going to automatically

00:07:34,139 --> 00:07:41,699
scale to meet your demand so if you had

00:07:37,919 --> 00:07:44,520
a function that was triggered by a HTTP

00:07:41,699 --> 00:07:46,560
request for example and you found that

00:07:44,520 --> 00:07:48,120
that function was getting loads and

00:07:46,560 --> 00:07:50,580
loads of traffic as your functions would

00:07:48,120 --> 00:07:52,199
very quickly spin up and it and it does

00:07:50,580 --> 00:07:54,959
spin up very quickly to say a hundred

00:07:52,199 --> 00:07:57,599
servers in the background or processing

00:07:54,959 --> 00:07:58,709
those requests to help you meet dramatic

00:07:57,599 --> 00:08:01,620
spikes in load

00:07:58,709 --> 00:08:03,870
similarly with queue listening functions

00:08:01,620 --> 00:08:06,449
if you say this function is processing

00:08:03,870 --> 00:08:08,639
messages from this queue and you drop a

00:08:06,449 --> 00:08:10,169
million messages into that queue again

00:08:08,639 --> 00:08:13,439
as your functions is going to spin up

00:08:10,169 --> 00:08:15,839
very quickly to up to say a hundred

00:08:13,439 --> 00:08:17,759
servers to help you burn through that

00:08:15,839 --> 00:08:19,939
queue as as fast as possible obviously

00:08:17,759 --> 00:08:22,649
you've got to be careful that you don't

00:08:19,939 --> 00:08:26,189
denial-of-service some downstream system

00:08:22,649 --> 00:08:27,749
because you've now got so many servers

00:08:26,189 --> 00:08:29,430
working on it but this is one of the

00:08:27,749 --> 00:08:32,310
really attractive things about service

00:08:29,430 --> 00:08:35,370
scale is automatic you can start small

00:08:32,310 --> 00:08:38,610
and then it will just scale out to meet

00:08:35,370 --> 00:08:41,459
the demands that you have and the third

00:08:38,610 --> 00:08:43,050
key idea behind serverless and this is

00:08:41,459 --> 00:08:45,660
one of the things that really sets it

00:08:43,050 --> 00:08:47,310
apart with all those other ways of

00:08:45,660 --> 00:08:50,279
hosting your code in the cloud that

00:08:47,310 --> 00:08:55,460
we've talked about you typically pay on

00:08:50,279 --> 00:08:57,230
a kind of rent compute resources

00:08:55,460 --> 00:08:58,670
for a month approach so if I've got a

00:08:57,230 --> 00:09:00,140
virtual machine I might be paying

00:08:58,670 --> 00:09:02,420
depending on the size of the virtual

00:09:00,140 --> 00:09:04,700
machine 30 pounds a month or 100 pounds

00:09:02,420 --> 00:09:06,830
a month to have that virtual machine

00:09:04,700 --> 00:09:09,740
available to me and I'm paying that

00:09:06,830 --> 00:09:11,120
whether it's working hard or not and the

00:09:09,740 --> 00:09:12,200
same is actually true with a lot of the

00:09:11,120 --> 00:09:14,210
platform-as-a-service

00:09:12,200 --> 00:09:16,010
or if you've got a kubernetes cluster

00:09:14,210 --> 00:09:18,140
you're paying for the nodes in your

00:09:16,010 --> 00:09:20,990
cluster whether they're doing anything

00:09:18,140 --> 00:09:23,750
or not with serverless you are only

00:09:20,990 --> 00:09:25,100
paying while your function is running so

00:09:23,750 --> 00:09:30,260
if your functions don't run for a month

00:09:25,100 --> 00:09:31,760
you actually pay nothing at all and one

00:09:30,260 --> 00:09:34,280
of the one of the great benefits of this

00:09:31,760 --> 00:09:36,500
is that it allows you to essentially if

00:09:34,280 --> 00:09:38,330
you're creating a new application you

00:09:36,500 --> 00:09:40,310
just prototyping you've just got an idea

00:09:38,330 --> 00:09:42,200
and you've only got a very small amount

00:09:40,310 --> 00:09:44,480
of usage you're paying virtually nothing

00:09:42,200 --> 00:09:46,580
at all and it's only when you start to

00:09:44,480 --> 00:09:49,520
get serious amounts of usage but you

00:09:46,580 --> 00:09:54,080
have to pay so just a quick look at the

00:09:49,520 --> 00:09:57,650
pricing model you pay 15 pence for a

00:09:54,080 --> 00:09:59,480
million function executions and for each

00:09:57,650 --> 00:10:02,660
second that your function is running you

00:09:59,480 --> 00:10:04,760
run some very small you pay some very

00:10:02,660 --> 00:10:06,470
small fraction of a pound but you'll

00:10:04,760 --> 00:10:08,860
also notice in the far right column

00:10:06,470 --> 00:10:11,090
there that you get a monthly free grant

00:10:08,860 --> 00:10:13,520
so what that basically means is that

00:10:11,090 --> 00:10:16,190
every month you're allowed to execute a

00:10:13,520 --> 00:10:17,960
million Osia functions for free and they

00:10:16,190 --> 00:10:20,510
can run for up to four hundred thousand

00:10:17,960 --> 00:10:21,830
seconds essentially for free and so if

00:10:20,510 --> 00:10:23,630
you're just wanting to experiment and

00:10:21,830 --> 00:10:26,300
play with Asia functions it's very

00:10:23,630 --> 00:10:29,650
unlikely you'll pay anything at all it's

00:10:26,300 --> 00:10:33,020
only when you start to hit serious usage

00:10:29,650 --> 00:10:34,580
now one of the criticisms of server

00:10:33,020 --> 00:10:36,980
lists that you sometimes hear is that

00:10:34,580 --> 00:10:38,720
the the function some people talk about

00:10:36,980 --> 00:10:40,700
functions as a service as being nano

00:10:38,720 --> 00:10:43,520
services because you're deploying these

00:10:40,700 --> 00:10:45,890
really tiny packages of code that are

00:10:43,520 --> 00:10:48,560
essentially just a single function that

00:10:45,890 --> 00:10:50,720
that's almost two smaller unit so if

00:10:48,560 --> 00:10:53,450
I've got loads and loads of functions do

00:10:50,720 --> 00:10:54,920
I want to be separately developing each

00:10:53,450 --> 00:10:57,800
one in its own source control repository

00:10:54,920 --> 00:11:00,320
and deploying it all individually that

00:10:57,800 --> 00:11:03,230
seems like a lot of overhead and as your

00:11:00,320 --> 00:11:04,850
functions actually has got the concepts

00:11:03,230 --> 00:11:06,620
of what's called a function app and this

00:11:04,850 --> 00:11:09,260
is kind of a way of grouping together a

00:11:06,620 --> 00:11:11,390
bunch a bunch of functions that logic

00:11:09,260 --> 00:11:13,790
belong together and so when you have

00:11:11,390 --> 00:11:15,470
functions in a function app they share

00:11:13,790 --> 00:11:17,300
common configurations so if you've got

00:11:15,470 --> 00:11:19,190
connection strings they can all access

00:11:17,300 --> 00:11:22,340
the same connection strings you deploy

00:11:19,190 --> 00:11:25,520
them as a group and they will also scale

00:11:22,340 --> 00:11:29,450
as a group so if one of those functions

00:11:25,520 --> 00:11:31,190
is is having to do a lot of work than

00:11:29,450 --> 00:11:33,170
all of the essentially all of them will

00:11:31,190 --> 00:11:36,350
get scaled up to the same number of

00:11:33,170 --> 00:11:38,990
servers and if you know anything about

00:11:36,350 --> 00:11:40,460
Asia app service which is actually the

00:11:38,990 --> 00:11:42,770
underlying platform that as your

00:11:40,460 --> 00:11:44,540
functions runs on then an azure service

00:11:42,770 --> 00:11:47,150
app service has a concept of an app

00:11:44,540 --> 00:11:49,460
service plan and you can run many

00:11:47,150 --> 00:11:55,580
function apps on the same app service

00:11:49,460 --> 00:11:59,030
plan now let me just jump out of my

00:11:55,580 --> 00:12:03,770
slides I'm not going to spend a long

00:11:59,030 --> 00:12:05,900
time talking just about Asia functions

00:12:03,770 --> 00:12:10,070
but just to give you an idea of what an

00:12:05,900 --> 00:12:12,950
Asia function looks like this is an

00:12:10,070 --> 00:12:14,300
example of a scheduled function and one

00:12:12,950 --> 00:12:16,340
of the interesting things with Asia

00:12:14,300 --> 00:12:19,130
functions is you're not limited to just

00:12:16,340 --> 00:12:21,440
C sharp you can create Asia functions in

00:12:19,130 --> 00:12:23,930
several different languages probably the

00:12:21,440 --> 00:12:27,500
best two supported are C sharp and Java

00:12:23,930 --> 00:12:29,390
Script but they've also got Python

00:12:27,500 --> 00:12:32,690
support they've got Java support which

00:12:29,390 --> 00:12:34,730
is fairly new and you can obviously use

00:12:32,690 --> 00:12:37,910
other dotnet languages like F sharp as

00:12:34,730 --> 00:12:39,590
well if you want to and if you are

00:12:37,910 --> 00:12:41,570
writing them in c-sharp this is what

00:12:39,590 --> 00:12:45,230
your code would typically look like each

00:12:41,570 --> 00:12:48,110
function is a static function and it's

00:12:45,230 --> 00:12:50,530
got some attributes that define how your

00:12:48,110 --> 00:12:54,200
function is triggered so in this example

00:12:50,530 --> 00:12:56,720
my function has a name just of scheduled

00:12:54,200 --> 00:12:58,730
function and it has a timer trigger

00:12:56,720 --> 00:13:00,860
which has got a cron expression saying

00:12:58,730 --> 00:13:04,130
that this function is going to run every

00:13:00,860 --> 00:13:07,490
five minutes and as your functions also

00:13:04,130 --> 00:13:09,380
has the concept of bindings so it tries

00:13:07,490 --> 00:13:11,540
to reduce the amount of work that you

00:13:09,380 --> 00:13:13,310
need to amount of code that you need to

00:13:11,540 --> 00:13:14,840
write to interact with other services

00:13:13,310 --> 00:13:17,120
and so there are a lot of built in

00:13:14,840 --> 00:13:20,630
bindings to help you deal with blob

00:13:17,120 --> 00:13:23,030
storage queues cosmos DB databases and

00:13:20,630 --> 00:13:25,640
so on and so in this example I'm you

00:13:23,030 --> 00:13:27,980
using a table binding to say that I want

00:13:25,640 --> 00:13:30,860
to interact with an azure storage table

00:13:27,980 --> 00:13:35,690
as your storage tables is just a very

00:13:30,860 --> 00:13:37,850
cheap key value store type database and

00:13:35,690 --> 00:13:39,440
I can just use a simple binding to

00:13:37,850 --> 00:13:43,510
connect to that and it just cuts down on

00:13:39,440 --> 00:13:43,510
the amount of code that I need to write

00:13:43,660 --> 00:13:50,540
and in this example here this is an

00:13:47,390 --> 00:13:54,800
example of a HTTP triggered function so

00:13:50,540 --> 00:13:56,870
you can see that I've decorated one of

00:13:54,800 --> 00:13:59,050
the parameters as a HTTP trigger I'm

00:13:56,870 --> 00:14:01,280
saying that I'm using anonymous

00:13:59,050 --> 00:14:03,980
authorization it's got support for kind

00:14:01,280 --> 00:14:06,500
of function keys to protect your

00:14:03,980 --> 00:14:10,640
endpoints saying I'm supporting the put

00:14:06,500 --> 00:14:12,680
verb and you can customize the roots of

00:14:10,640 --> 00:14:14,270
your functions and so on one really nice

00:14:12,680 --> 00:14:17,150
thing about as your functions is that

00:14:14,270 --> 00:14:19,160
the runtime is able to run locally on

00:14:17,150 --> 00:14:21,740
your local development machine and so

00:14:19,160 --> 00:14:22,880
when I'm testing this as you can see

00:14:21,740 --> 00:14:24,530
here it's spinning up the edge of

00:14:22,880 --> 00:14:25,910
functions runtime apologize that that

00:14:24,530 --> 00:14:29,750
font is a little bit on the small side

00:14:25,910 --> 00:14:32,060
for you this is running the exact

00:14:29,750 --> 00:14:37,070
runtime that would be running in the

00:14:32,060 --> 00:14:39,200
cloud so you really are you really are

00:14:37,070 --> 00:14:42,140
running the real thing and obviously in

00:14:39,200 --> 00:14:43,970
this example the tape the error storage

00:14:42,140 --> 00:14:45,260
account that I'm connecting to I'm not

00:14:43,970 --> 00:14:49,390
connecting to the cloud I'm collecting

00:14:45,260 --> 00:14:52,130
to there's an azure storage emulator so

00:14:49,390 --> 00:14:53,870
there's the edge of storage emulator so

00:14:52,130 --> 00:14:57,170
what it's done it started up and it's

00:14:53,870 --> 00:14:59,900
detected a bunch of functions that I've

00:14:57,170 --> 00:15:02,090
declared in my project just by scanning

00:14:59,900 --> 00:15:04,370
the assembly and so you can see there's

00:15:02,090 --> 00:15:06,530
this is a like a simple to do app so I

00:15:04,370 --> 00:15:09,470
can get the two do's and delete them and

00:15:06,530 --> 00:15:14,000
it's worked out from those attributes

00:15:09,470 --> 00:15:16,550
what HTTP methods they support and the

00:15:14,000 --> 00:15:17,930
end point will be so that put one

00:15:16,550 --> 00:15:22,310
where's the put one that we were looking

00:15:17,930 --> 00:15:24,050
at there it's it's going to listen on

00:15:22,310 --> 00:15:26,000
slash API which is just its default

00:15:24,050 --> 00:15:28,100
slash to do which we specified in the

00:15:26,000 --> 00:15:30,950
attributes and then it will provide that

00:15:28,100 --> 00:15:37,450
ID to me as another parameter to my

00:15:30,950 --> 00:15:37,450
function and so I'm hoping

00:15:38,720 --> 00:15:51,750
what I've done with this particular

00:15:40,920 --> 00:15:55,080
example my co-host 7071 I've I've

00:15:51,750 --> 00:15:57,210
actually got a user interface this is of

00:15:55,080 --> 00:15:59,970
isn't obviously part of Asia functions

00:15:57,210 --> 00:16:03,600
but just calls those endpoints so I can

00:15:59,970 --> 00:16:07,770
add items to my to-do list as you can

00:16:03,600 --> 00:16:10,620
see as I as I run through them and I

00:16:07,770 --> 00:16:13,920
mark one is completed that we'll call

00:16:10,620 --> 00:16:15,420
call the again apologies it's a small

00:16:13,920 --> 00:16:17,250
font size it calls the update to do

00:16:15,420 --> 00:16:21,870
tasks and so I can see all of this

00:16:17,250 --> 00:16:23,160
running through in the runtime and one

00:16:21,870 --> 00:16:25,500
other interesting thing about the fact

00:16:23,160 --> 00:16:27,510
that the Asia hrunta functions runtime

00:16:25,500 --> 00:16:30,780
runs locally is that if you want to you

00:16:27,510 --> 00:16:32,340
can containerize it as a docker

00:16:30,780 --> 00:16:34,290
container and so if you like the asia

00:16:32,340 --> 00:16:36,330
functions programming model but you're

00:16:34,290 --> 00:16:38,370
not working in Azure

00:16:36,330 --> 00:16:40,620
you can still use as your functions just

00:16:38,370 --> 00:16:42,570
by using a docker container one of the

00:16:40,620 --> 00:16:45,630
questions that I have with that Asia

00:16:42,570 --> 00:16:48,060
functions is and although it's great for

00:16:45,630 --> 00:16:51,180
making little things like web app

00:16:48,060 --> 00:16:52,920
listeners and listening on a cue what

00:16:51,180 --> 00:16:54,780
happens when you start to want to

00:16:52,920 --> 00:17:00,420
implement some longer running business

00:16:54,780 --> 00:17:03,510
processes with a service platform and so

00:17:00,420 --> 00:17:07,280
to give you a sort of idea of the type

00:17:03,510 --> 00:17:12,780
of thing that I work on in my day job

00:17:07,280 --> 00:17:16,260
nice is we deal with evidence for the

00:17:12,780 --> 00:17:18,450
police so in criminal cases these days

00:17:16,260 --> 00:17:19,800
there's a lot of digital evidence that

00:17:18,450 --> 00:17:22,530
the police have to deal with they have

00:17:19,800 --> 00:17:25,620
to deal with crime-scene photos that are

00:17:22,530 --> 00:17:28,260
digital photos they deal with recordings

00:17:25,620 --> 00:17:30,300
of interviews with witnesses a lot of

00:17:28,260 --> 00:17:32,670
police are wearing body worn cameras and

00:17:30,300 --> 00:17:35,490
so there's a lot of footage of that we

00:17:32,670 --> 00:17:37,170
also have the recordings of 999 calls

00:17:35,490 --> 00:17:39,270
and recordings of police radio

00:17:37,170 --> 00:17:43,740
conversations and so there's just a

00:17:39,270 --> 00:17:45,600
large amount of digital evidence and the

00:17:43,740 --> 00:17:47,190
systems that I'm working on are trying

00:17:45,600 --> 00:17:49,890
to help the police manage that and

00:17:47,190 --> 00:17:53,820
organize it and search it effectively

00:17:49,890 --> 00:17:55,920
but also sometimes the general public

00:17:53,820 --> 00:17:58,560
might have some evidence they want to

00:17:55,920 --> 00:18:01,710
upload and provide so maybe somebody has

00:17:58,560 --> 00:18:03,450
captured on their mobile phone something

00:18:01,710 --> 00:18:06,780
taking place and they want to submit it

00:18:03,450 --> 00:18:08,700
and if they have if that was happened

00:18:06,780 --> 00:18:10,950
what we might do in our system is with

00:18:08,700 --> 00:18:13,110
we let them upload it let upload it

00:18:10,950 --> 00:18:14,400
through some kind of website and because

00:18:13,110 --> 00:18:15,360
it's a member of the general public we

00:18:14,400 --> 00:18:17,340
don't really trust what they're

00:18:15,360 --> 00:18:21,240
uploading so we want to virus scan it

00:18:17,340 --> 00:18:24,120
and then once we virus scan that we will

00:18:21,240 --> 00:18:27,420
copy it out of a kind of a safe DMZ zone

00:18:24,120 --> 00:18:29,910
into our system then we might want to

00:18:27,420 --> 00:18:32,970
extract some metadata from that file so

00:18:29,910 --> 00:18:34,620
a lot of videos have got details of what

00:18:32,970 --> 00:18:37,050
the date time they were taken on and

00:18:34,620 --> 00:18:40,410
where where the location was we probably

00:18:37,050 --> 00:18:42,510
want to save it to our database auditing

00:18:40,410 --> 00:18:45,240
is really important so keeping track of

00:18:42,510 --> 00:18:47,790
who uploaded this and when and then

00:18:45,240 --> 00:18:51,390
because the police use cutting-edge

00:18:47,790 --> 00:18:53,790
modern web browsers like IE 8 we have to

00:18:51,390 --> 00:18:59,280
transcode it into a format that's

00:18:53,790 --> 00:19:00,990
playable on their web browsers and maybe

00:18:59,280 --> 00:19:02,670
we have to transcode it into a few

00:19:00,990 --> 00:19:05,460
different formats you know high res and

00:19:02,670 --> 00:19:08,010
low res and so on then we might extract

00:19:05,460 --> 00:19:10,050
a thumbnail image from it because of

00:19:08,010 --> 00:19:12,240
Representative picture and then maybe

00:19:10,050 --> 00:19:15,270
you want to do something fancy to take

00:19:12,240 --> 00:19:17,430
advantage of some a eye and to do some

00:19:15,270 --> 00:19:21,090
kind of an app analytics on the video

00:19:17,430 --> 00:19:24,540
maybe we can detect car registration

00:19:21,090 --> 00:19:28,200
plate numbers maybe we can extract the

00:19:24,540 --> 00:19:30,720
voice and turn that into transcribe it

00:19:28,200 --> 00:19:32,700
into text and then finally when all of

00:19:30,720 --> 00:19:35,670
that is done we'd like to notify the

00:19:32,700 --> 00:19:37,500
detective that hey there's a new piece

00:19:35,670 --> 00:19:41,820
of evidence in your case you might be

00:19:37,500 --> 00:19:44,070
interested in receiving and I've drawn

00:19:41,820 --> 00:19:45,900
this is quite a linear when I've drawn

00:19:44,070 --> 00:19:47,880
it as a completely linear flow one step

00:19:45,900 --> 00:19:49,980
after the other but I'm sure we all know

00:19:47,880 --> 00:19:52,020
that in real-world applications you tend

00:19:49,980 --> 00:19:53,760
to have much more complex work space

00:19:52,020 --> 00:19:56,220
than that you know you've got optional

00:19:53,760 --> 00:19:59,820
steps maybe you've got things that need

00:19:56,220 --> 00:20:01,470
to or can happen in parallel to save

00:19:59,820 --> 00:20:03,840
time to help you get move through that

00:20:01,470 --> 00:20:05,730
more quickly maybe you've got

00:20:03,840 --> 00:20:08,520
external approvals that need to happen

00:20:05,730 --> 00:20:10,500
which we'll talk about later so I know

00:20:08,520 --> 00:20:12,600
that this is just kind of the problem

00:20:10,500 --> 00:20:14,370
domain that I work in but I'm sure

00:20:12,600 --> 00:20:16,710
pretty much all of us here have got

00:20:14,370 --> 00:20:18,960
similar examples that we could give of

00:20:16,710 --> 00:20:20,610
business processes where you have to go

00:20:18,960 --> 00:20:23,730
through a number of steps one after the

00:20:20,610 --> 00:20:26,190
other and so the question is can you

00:20:23,730 --> 00:20:29,789
make something like this using a service

00:20:26,190 --> 00:20:32,400
platform like Asia functions and the

00:20:29,789 --> 00:20:35,010
simple answer is well you could do it

00:20:32,400 --> 00:20:36,899
quite easily if you just turned every

00:20:35,010 --> 00:20:40,380
one of those steps in the workflow into

00:20:36,899 --> 00:20:43,409
a function and you triggered the next

00:20:40,380 --> 00:20:45,870
function with Q's has anybody ever built

00:20:43,409 --> 00:20:48,390
a simple workflow using this technique

00:20:45,870 --> 00:20:51,149
it's quite common it's quite a common

00:20:48,390 --> 00:20:52,710
way to do things so what we'll do is

00:20:51,149 --> 00:20:54,600
when the video is uploaded we'll post a

00:20:52,710 --> 00:20:57,000
message into a queue and that will cause

00:20:54,600 --> 00:20:59,100
the virusscan function to wake up and do

00:20:57,000 --> 00:21:00,419
its virusscan and when it's finished it

00:20:59,100 --> 00:21:02,220
will post him another message into a

00:21:00,419 --> 00:21:03,690
queue and that will cause the copying

00:21:02,220 --> 00:21:05,669
function to wake up and when it's

00:21:03,690 --> 00:21:09,539
finished post another message into a

00:21:05,669 --> 00:21:11,370
queue and and so on and so forth and you

00:21:09,539 --> 00:21:15,870
could make that entire workflow that we

00:21:11,370 --> 00:21:17,220
just saw using this technique and in

00:21:15,870 --> 00:21:19,740
some ways it's got quite a lot of

00:21:17,220 --> 00:21:21,990
strengths to it first of all with queues

00:21:19,740 --> 00:21:25,440
you've got the benefits of asynchronous

00:21:21,990 --> 00:21:28,080
nurse you've got the benefits that quite

00:21:25,440 --> 00:21:29,610
often in queuing systems if the thing

00:21:28,080 --> 00:21:32,760
that processes a message of the queue

00:21:29,610 --> 00:21:35,370
fails that queue message will become

00:21:32,760 --> 00:21:39,120
available again to be retried and so you

00:21:35,370 --> 00:21:40,860
get a bit of built-in retry also we've

00:21:39,120 --> 00:21:43,679
said that Asia functions scales out

00:21:40,860 --> 00:21:46,169
automatically so if one of these tasks

00:21:43,679 --> 00:21:48,270
in the process was getting behind and

00:21:46,169 --> 00:21:50,010
was building up a backlog of queue items

00:21:48,270 --> 00:21:52,320
it would automatically scale up multiple

00:21:50,010 --> 00:21:59,640
instances to help speed up that part of

00:21:52,320 --> 00:22:01,440
the process however this approach also

00:21:59,640 --> 00:22:03,029
comes with quite a lot of pitfalls if

00:22:01,440 --> 00:22:05,730
you try and implement quite a

00:22:03,029 --> 00:22:08,010
complicated workflow using this

00:22:05,730 --> 00:22:09,750
simplistic approach of just saying well

00:22:08,010 --> 00:22:12,630
I'll just use Q messages to connect

00:22:09,750 --> 00:22:15,210
everything together you run into

00:22:12,630 --> 00:22:16,649
problems and so I'm going to go through

00:22:15,210 --> 00:22:17,639
what a number of those problems are

00:22:16,649 --> 00:22:19,499
really just

00:22:17,639 --> 00:22:21,659
help set up the case of why it is that

00:22:19,499 --> 00:22:24,899
durable functions is so interesting and

00:22:21,659 --> 00:22:28,440
what is there to help us deal with so

00:22:24,899 --> 00:22:31,499
one of the first big problems is needing

00:22:28,440 --> 00:22:34,200
to see the big picture when we take a

00:22:31,499 --> 00:22:35,369
whole bunch of azor functions or any

00:22:34,200 --> 00:22:37,379
type of functions that are just

00:22:35,369 --> 00:22:39,599
connected to do together by queues

00:22:37,379 --> 00:22:42,089
there's no one place you can go to in

00:22:39,599 --> 00:22:45,239
the code to see what is the whole big

00:22:42,089 --> 00:22:49,229
picture so when I showed you this nice

00:22:45,239 --> 00:22:50,339
diagram that was particularly easy for

00:22:49,229 --> 00:22:51,809
you to understand it's nothing

00:22:50,339 --> 00:22:54,539
complicated about this because you can

00:22:51,809 --> 00:22:57,359
see in one place what the order of all

00:22:54,539 --> 00:22:59,190
the actions is going to be however if

00:22:57,359 --> 00:23:01,589
you've used a kind of a join everything

00:22:59,190 --> 00:23:03,839
to do together with Q messages approach

00:23:01,589 --> 00:23:06,329
what you find is that you're looking at

00:23:03,839 --> 00:23:09,329
the code and you've got no idea really

00:23:06,329 --> 00:23:10,739
what's the thing that happens before me

00:23:09,329 --> 00:23:12,119
in the sequence and what's the thing

00:23:10,739 --> 00:23:15,299
that happens after me in the sequence

00:23:12,119 --> 00:23:17,879
and so I have had in the past experience

00:23:15,299 --> 00:23:20,070
of sitting with looking at code that

00:23:17,879 --> 00:23:22,919
works like this and trying to draw out

00:23:20,070 --> 00:23:25,529
in my notebook what is actually the big

00:23:22,919 --> 00:23:29,279
picture so that I can understand what's

00:23:25,529 --> 00:23:31,769
going on secondly you tend to end up

00:23:29,279 --> 00:23:36,229
creating a kind of a software version of

00:23:31,769 --> 00:23:38,309
a Rube Goldberg machine and I'm sure

00:23:36,229 --> 00:23:40,529
most of you have seen Rube Goldberg

00:23:38,309 --> 00:23:42,749
machines or seen kind of more modern

00:23:40,529 --> 00:23:44,849
inventions of them interpretations of

00:23:42,749 --> 00:23:47,999
them on YouTube where people make these

00:23:44,849 --> 00:23:50,190
incredibly elaborate inventions so in

00:23:47,999 --> 00:23:52,649
this particular example the woman peels

00:23:50,190 --> 00:23:55,440
an onion it causes her to cry her tears

00:23:52,649 --> 00:23:57,809
flow down the pike it causes the scales

00:23:55,440 --> 00:24:00,659
to tip that causes the bellows to blow

00:23:57,809 --> 00:24:03,899
and the insects fall off and eventually

00:24:00,659 --> 00:24:07,259
the I'm not sure what eventually it will

00:24:03,899 --> 00:24:10,289
do the weight will fall and the reason

00:24:07,259 --> 00:24:12,089
these Rube Goldberg type inventions and

00:24:10,289 --> 00:24:15,179
musers is because we can see that it

00:24:12,089 --> 00:24:17,940
probably could work if everything went

00:24:15,179 --> 00:24:20,450
perfectly but if one thing goes wrong

00:24:17,940 --> 00:24:23,570
anywhere in the process then suddenly

00:24:20,450 --> 00:24:26,659
we've lost track of where we were and

00:24:23,570 --> 00:24:29,159
the end result doesn't happen at all and

00:24:26,659 --> 00:24:31,360
so that's one of the problems that you

00:24:29,159 --> 00:24:33,490
very quickly run into if you

00:24:31,360 --> 00:24:36,450
just try and create your workflows using

00:24:33,490 --> 00:24:39,820
a simplistic queueing based system

00:24:36,450 --> 00:24:41,920
somebody will say I uploaded a video at

00:24:39,820 --> 00:24:44,080
nine o'clock this morning but I've not

00:24:41,920 --> 00:24:47,110
got my notification where's the problem

00:24:44,080 --> 00:24:50,080
and so what you end up having to do is

00:24:47,110 --> 00:24:51,910
kind of trawl through logs and try and

00:24:50,080 --> 00:24:53,860
find evidence which of these functions

00:24:51,910 --> 00:24:58,720
actually run which is the one that it

00:24:53,860 --> 00:25:01,420
got stuck on another thing that you run

00:24:58,720 --> 00:25:03,130
into is that there are some times in a

00:25:01,420 --> 00:25:04,570
where it's quite common really in a

00:25:03,130 --> 00:25:06,760
cloud-based system in a distributed

00:25:04,570 --> 00:25:09,100
system there will be times where a

00:25:06,760 --> 00:25:11,799
transient error prevents you from

00:25:09,100 --> 00:25:14,700
successfully performing a step and if

00:25:11,799 --> 00:25:18,460
you were to retry then maybe it will

00:25:14,700 --> 00:25:20,440
succeed and so the best practice

00:25:18,460 --> 00:25:24,100
generally I don't have any of you used

00:25:20,440 --> 00:25:26,700
libraries like Pali in c-sharp which is

00:25:24,100 --> 00:25:28,990
which is a really nice c-sharp way of

00:25:26,700 --> 00:25:31,510
implementing certain retry and back off

00:25:28,990 --> 00:25:33,340
patterns you just say I'd like to make

00:25:31,510 --> 00:25:35,260
this web request but if it fails through

00:25:33,340 --> 00:25:36,850
the transient error I would want to try

00:25:35,260 --> 00:25:39,070
again in a minute and then try again in

00:25:36,850 --> 00:25:42,059
five minutes and then maybe sleep for 30

00:25:39,070 --> 00:25:44,830
minutes and then try again

00:25:42,059 --> 00:25:47,110
unfortunately you could you can't really

00:25:44,830 --> 00:25:49,179
use something like poly in as your

00:25:47,110 --> 00:25:51,160
functions as your functions because I

00:25:49,179 --> 00:25:53,230
said the pricing model is you pay for

00:25:51,160 --> 00:25:55,210
the time your function is running first

00:25:53,230 --> 00:25:56,559
of all you don't want to be sleeping in

00:25:55,210 --> 00:25:59,320
your as your function because if I sleep

00:25:56,559 --> 00:26:00,820
say I'm going to sleep for 30 minutes in

00:25:59,320 --> 00:26:02,890
my as your function then I'm paying for

00:26:00,820 --> 00:26:04,450
30 minutes of as your function and the

00:26:02,890 --> 00:26:06,280
pricing models starts to become a lot

00:26:04,450 --> 00:26:10,600
less attractive when you have very very

00:26:06,280 --> 00:26:12,640
long-running functions secondly kind of

00:26:10,600 --> 00:26:15,520
as a way of protecting you from yourself

00:26:12,640 --> 00:26:17,650
as your functions kindly limits the

00:26:15,520 --> 00:26:20,380
maximum duration of functions by default

00:26:17,650 --> 00:26:21,549
to 5 minutes so the idea is that

00:26:20,380 --> 00:26:23,770
functions are not supposed to be

00:26:21,549 --> 00:26:26,530
long-running they get in do something do

00:26:23,770 --> 00:26:28,990
it quick and then exit so you can't

00:26:26,530 --> 00:26:32,740
really put sleeps into a service

00:26:28,990 --> 00:26:34,840
platform like this and implementing

00:26:32,740 --> 00:26:37,540
retry and back off just using queues is

00:26:34,840 --> 00:26:39,400
a little bit tricky what you can

00:26:37,540 --> 00:26:42,250
sometimes do is send yourself a future

00:26:39,400 --> 00:26:44,860
scheduled message but that's quite a lot

00:26:42,250 --> 00:26:47,919
of effort to go to

00:26:44,860 --> 00:26:49,720
another thing that you find if you try

00:26:47,919 --> 00:26:52,360
to implement a workflow like this just

00:26:49,720 --> 00:26:54,070
by passing messages to queues is that

00:26:52,360 --> 00:26:56,950
sometimes the steps in your workflow

00:26:54,070 --> 00:26:59,080
aren't actually all that's quite as

00:26:56,950 --> 00:27:02,529
simple as that so for example imagine

00:26:59,080 --> 00:27:05,110
the analytic step in this workflow we're

00:27:02,529 --> 00:27:09,010
going out to an external system that is

00:27:05,110 --> 00:27:14,500
able to do some kind of processing or AI

00:27:09,010 --> 00:27:15,789
on our on our video file that might be

00:27:14,500 --> 00:27:18,519
able to do it really quickly and just

00:27:15,789 --> 00:27:20,200
give us a result however it might be a

00:27:18,519 --> 00:27:22,990
more long-running process so we might

00:27:20,200 --> 00:27:25,240
submit a job to it and then it tells us

00:27:22,990 --> 00:27:27,610
via some other mechanism later that it's

00:27:25,240 --> 00:27:29,919
finished and so how are we going to wait

00:27:27,610 --> 00:27:33,639
for an external response for an external

00:27:29,919 --> 00:27:35,289
system typically that's either done with

00:27:33,639 --> 00:27:36,850
polling so you'd end up having to have a

00:27:35,289 --> 00:27:38,980
scheduled job that was polling to see if

00:27:36,850 --> 00:27:40,840
it was finished or maybe it calls you

00:27:38,980 --> 00:27:43,120
back on a web hook to tell you that it's

00:27:40,840 --> 00:27:46,360
done but the other thing that you run

00:27:43,120 --> 00:27:48,039
into is that sometimes in written in the

00:27:46,360 --> 00:27:50,500
real world you never get the response

00:27:48,039 --> 00:27:52,360
you submitted the the job to it and it

00:27:50,500 --> 00:27:54,700
just never replied to you so you'd also

00:27:52,360 --> 00:27:56,019
like if you're waiting for an event from

00:27:54,700 --> 00:27:58,659
an external system in the middle of a

00:27:56,019 --> 00:28:02,100
workflow to be able to timeout in a

00:27:58,659 --> 00:28:06,429
sensible way so that you can carry on or

00:28:02,100 --> 00:28:08,950
recover in some other way and then the

00:28:06,429 --> 00:28:11,830
final thing that's really hard to do or

00:28:08,950 --> 00:28:14,139
part of this is really hard to do is if

00:28:11,830 --> 00:28:16,539
you want to implement steps in your

00:28:14,139 --> 00:28:18,580
workflow in parallel so for example

00:28:16,539 --> 00:28:21,549
imagine that after I've transcoded a

00:28:18,580 --> 00:28:23,740
video the tasks of voice detection

00:28:21,549 --> 00:28:27,279
analytics and extracting a thumbnail are

00:28:23,740 --> 00:28:30,039
all able to be done in parallel now if

00:28:27,279 --> 00:28:33,399
I'm using cues on a message queue I can

00:28:30,039 --> 00:28:35,139
easily initiate other jobs in parallel

00:28:33,399 --> 00:28:37,929
because I just post three messages and

00:28:35,139 --> 00:28:41,320
those three other Azure functions will

00:28:37,929 --> 00:28:43,899
all run at the same time what's much

00:28:41,320 --> 00:28:47,649
harder to do and so they said that's

00:28:43,899 --> 00:28:50,500
called fanning out fan-in is much more

00:28:47,649 --> 00:28:52,000
difficult because if I'm saying I only

00:28:50,500 --> 00:28:54,639
want to send the notification when all

00:28:52,000 --> 00:28:56,500
three of those tasks have completed what

00:28:54,639 --> 00:28:58,240
I have to do is when each individual one

00:28:56,500 --> 00:28:58,840
completes I have to work out was either

00:28:58,240 --> 00:29:02,559
last

00:28:58,840 --> 00:29:04,960
and only if I was the last one should we

00:29:02,559 --> 00:29:06,360
carry on to the next step and although

00:29:04,960 --> 00:29:08,860
it's possible to write that yourself

00:29:06,360 --> 00:29:10,509
it's the type of code that as as

00:29:08,860 --> 00:29:12,700
developers often accidentally put race

00:29:10,509 --> 00:29:15,999
conditions in and either never proceed

00:29:12,700 --> 00:29:18,490
or proceed more than once so it'd be

00:29:15,999 --> 00:29:21,879
nice if there was a framework that could

00:29:18,490 --> 00:29:24,570
solve a lot of these problems and that's

00:29:21,879 --> 00:29:29,679
really where durable functions comes in

00:29:24,570 --> 00:29:31,899
so durable functions and I'm just going

00:29:29,679 --> 00:29:34,299
to skip over that slide for a minute

00:29:31,899 --> 00:29:36,999
durable functions is an extension to

00:29:34,299 --> 00:29:38,679
Azure functions so if you've got an

00:29:36,999 --> 00:29:41,019
azure functions project you can just

00:29:38,679 --> 00:29:44,619
simply enable durable functions by

00:29:41,019 --> 00:29:47,950
adding a nougat package which is the

00:29:44,619 --> 00:29:49,659
durable task nougat package when as it

00:29:47,950 --> 00:29:53,110
when durable functions initially came

00:29:49,659 --> 00:29:58,360
out it only supported c-sharp it was

00:29:53,110 --> 00:30:00,909
based on some quite clever use of the

00:29:58,360 --> 00:30:03,460
await keyword in in c-sharp

00:30:00,909 --> 00:30:04,990
however JavaScript when I wrote this

00:30:03,460 --> 00:30:08,289
slide it was in preview actually they

00:30:04,990 --> 00:30:10,059
announced I think at the event earlier

00:30:08,289 --> 00:30:12,009
this week that it's out of preview so

00:30:10,059 --> 00:30:14,710
JavaScript support is also available for

00:30:12,009 --> 00:30:17,019
durable functions it is also completely

00:30:14,710 --> 00:30:21,159
open-source as is the whole of Asia

00:30:17,019 --> 00:30:22,619
functions but one nice thing is I've

00:30:21,159 --> 00:30:24,999
been able to get one of my own

00:30:22,619 --> 00:30:27,580
contributions in so feature I wanted I

00:30:24,999 --> 00:30:28,809
was able to submit to Azure functions

00:30:27,580 --> 00:30:30,879
that came out in one of the recent

00:30:28,809 --> 00:30:33,610
releases and a number of other features

00:30:30,879 --> 00:30:36,759
I've requested were released this last

00:30:33,610 --> 00:30:38,440
week so it's a really great community in

00:30:36,759 --> 00:30:42,820
terms of being responsive to people's

00:30:38,440 --> 00:30:46,019
requests and accepting work from from

00:30:42,820 --> 00:30:49,210
the community now

00:30:46,019 --> 00:30:53,379
durable functions adds two new types of

00:30:49,210 --> 00:30:54,820
functions to Asha functions and the most

00:30:53,379 --> 00:30:56,950
important one really is what's called

00:30:54,820 --> 00:30:59,049
the orchestrator function and so

00:30:56,950 --> 00:31:02,259
endurable functions their word for

00:30:59,049 --> 00:31:04,269
workflow is orchestration ok so if if

00:31:02,259 --> 00:31:06,610
you see the word orchestration think of

00:31:04,269 --> 00:31:09,190
them it's a workflow and the

00:31:06,610 --> 00:31:11,919
orchestrator functions job is to define

00:31:09,190 --> 00:31:12,340
what are the steps in the workflow so in

00:31:11,919 --> 00:31:15,549
car

00:31:12,340 --> 00:31:19,870
dude you're going to say what are each

00:31:15,549 --> 00:31:21,820
of the steps were order therein and this

00:31:19,870 --> 00:31:23,200
is this is essentially how you're

00:31:21,820 --> 00:31:25,630
getting the big picture so I said

00:31:23,200 --> 00:31:26,799
earlier there's a problem with not being

00:31:25,630 --> 00:31:28,960
able to see the big picture of your

00:31:26,799 --> 00:31:30,340
workflow this makes it really simple you

00:31:28,960 --> 00:31:32,529
look at the orchestrator function you

00:31:30,340 --> 00:31:34,590
can see exactly what's happening in your

00:31:32,529 --> 00:31:37,029
workflow

00:31:34,590 --> 00:31:39,789
however the orchestrator function is not

00:31:37,029 --> 00:31:42,510
allowed to actually do any work itself

00:31:39,789 --> 00:31:45,010
it's purely to define the workflow and

00:31:42,510 --> 00:31:46,840
all of the actual steps in your workflow

00:31:45,010 --> 00:31:49,510
are performed in what's called activity

00:31:46,840 --> 00:31:50,919
functions so the orchestrator will call

00:31:49,510 --> 00:31:52,960
an activity function and when that

00:31:50,919 --> 00:31:56,110
activity is done it will decide what the

00:31:52,960 --> 00:31:57,510
next activity to call is and so on orcas

00:31:56,110 --> 00:32:00,809
traces can actually call other

00:31:57,510 --> 00:32:02,950
orchestrators which sounds like kind of

00:32:00,809 --> 00:32:05,559
overcomplicated inception but actually

00:32:02,950 --> 00:32:07,240
does turn out to be quite useful when

00:32:05,559 --> 00:32:11,500
you're orchestrations and your workflow

00:32:07,240 --> 00:32:13,360
start getting quite complicated and so

00:32:11,500 --> 00:32:15,250
the orchestrator really is about calling

00:32:13,360 --> 00:32:15,779
other activities and deciding what to do

00:32:15,250 --> 00:32:18,490
next

00:32:15,779 --> 00:32:20,110
one really nice thing about Orchestrator

00:32:18,490 --> 00:32:23,559
functions is that they can handle

00:32:20,110 --> 00:32:25,419
exceptions that are thrown not just in

00:32:23,559 --> 00:32:28,090
the orchestrator itself but in by any

00:32:25,419 --> 00:32:30,429
activity in the workflow and this means

00:32:28,090 --> 00:32:32,590
that you've got a single place that

00:32:30,429 --> 00:32:34,179
could deal with a problem that goes

00:32:32,590 --> 00:32:40,750
wrong no matter where it went wrong in

00:32:34,179 --> 00:32:42,190
the workflow however it's quite there's

00:32:40,750 --> 00:32:43,960
a little bit of magic going on behind

00:32:42,190 --> 00:32:45,580
the scenes in an Orchestrator function

00:32:43,960 --> 00:32:47,860
and it doesn't mean that you have to

00:32:45,580 --> 00:32:50,799
adhere to some very strict rules and

00:32:47,860 --> 00:32:52,149
we'll we'll see why later but in an

00:32:50,799 --> 00:32:54,159
Orchestrator function you can't just do

00:32:52,149 --> 00:32:57,279
anything you like particularly you can't

00:32:54,159 --> 00:33:00,789
do things like going making calls to the

00:32:57,279 --> 00:33:02,590
database or you can't even make

00:33:00,789 --> 00:33:04,059
decisions based on what the current date

00:33:02,590 --> 00:33:07,210
time is without doing it in a very

00:33:04,059 --> 00:33:08,890
special way so your Orchestrator

00:33:07,210 --> 00:33:11,529
function is really about defining the

00:33:08,890 --> 00:33:12,880
shape of the workflow the thing I like

00:33:11,529 --> 00:33:15,399
about what castrates functions is that

00:33:12,880 --> 00:33:18,600
I'm defining my workflow in code I know

00:33:15,399 --> 00:33:21,130
that there are there are other clouds

00:33:18,600 --> 00:33:23,890
workflow platforms that are about visual

00:33:21,130 --> 00:33:25,750
designers and you draw a flow chart as

00:33:23,890 --> 00:33:26,140
your logic apps works that way some

00:33:25,750 --> 00:33:29,020
people do

00:33:26,140 --> 00:33:32,530
prefer the visual side of things but as

00:33:29,020 --> 00:33:37,450
a coder I quite like writing my define

00:33:32,530 --> 00:33:39,370
my workflow in c-sharp the other type of

00:33:37,450 --> 00:33:41,020
function is an activity function and

00:33:39,370 --> 00:33:42,690
these are much simpler though they're

00:33:41,020 --> 00:33:45,490
really almost exactly the same as

00:33:42,690 --> 00:33:47,170
regular as your functions and the

00:33:45,490 --> 00:33:48,490
activity functions their job is just to

00:33:47,170 --> 00:33:52,120
perform a single step in the workflow

00:33:48,490 --> 00:33:54,790
and so an activity function can receive

00:33:52,120 --> 00:33:57,730
input data so the orchestrator can give

00:33:54,790 --> 00:33:59,980
it some useful information to tell it

00:33:57,730 --> 00:34:01,660
what it needs to do and that input data

00:33:59,980 --> 00:34:04,690
can basically be any object that can be

00:34:01,660 --> 00:34:07,210
serialized to Jason and in activity once

00:34:04,690 --> 00:34:09,730
it's complete can return output data

00:34:07,210 --> 00:34:11,200
which is given back to the orchestrator

00:34:09,730 --> 00:34:14,429
and the orchestrator can use that to

00:34:11,200 --> 00:34:17,290
make decisions on what to do next and

00:34:14,429 --> 00:34:19,720
activity functions can use bindings so

00:34:17,290 --> 00:34:21,700
just like when I showed you some example

00:34:19,720 --> 00:34:23,409
area functions earlier which had

00:34:21,700 --> 00:34:25,870
bindings to table storage activity

00:34:23,409 --> 00:34:27,730
functions can use those as well so you

00:34:25,870 --> 00:34:29,290
typically in your activity functions if

00:34:27,730 --> 00:34:32,860
you're talking to databases you're

00:34:29,290 --> 00:34:34,330
talking to other services it's really

00:34:32,860 --> 00:34:36,310
easy to do that and you can use the

00:34:34,330 --> 00:34:42,820
power of the area functions programming

00:34:36,310 --> 00:34:46,440
model okay one of the questions that you

00:34:42,820 --> 00:34:48,280
might be wondering is if I've got a

00:34:46,440 --> 00:34:50,890
something that's trying to help me

00:34:48,280 --> 00:34:53,409
manage the state of workflows and I can

00:34:50,890 --> 00:34:55,780
kick off workflows and I can track where

00:34:53,409 --> 00:34:58,450
I've got to in in the workflow and so on

00:34:55,780 --> 00:35:01,150
where is that state being stored where

00:34:58,450 --> 00:35:02,920
is it managing it and durable function

00:35:01,150 --> 00:35:06,580
stores all of its state in what it calls

00:35:02,920 --> 00:35:09,250
a task cup at the task cup simply is a

00:35:06,580 --> 00:35:11,380
way of knowing what orchestrations are

00:35:09,250 --> 00:35:14,560
currently in progress and how far

00:35:11,380 --> 00:35:16,480
through we've got in them and what use

00:35:14,560 --> 00:35:19,480
is behind the scenes is an azure storage

00:35:16,480 --> 00:35:20,740
account so any of you who use Azure will

00:35:19,480 --> 00:35:23,650
be very familiar with Azure storage

00:35:20,740 --> 00:35:26,860
accounts storage accounts consists of

00:35:23,650 --> 00:35:29,530
blob storage for files table storage

00:35:26,860 --> 00:35:32,500
which is a very cheap and simple key

00:35:29,530 --> 00:35:34,510
value database and queues which is for

00:35:32,500 --> 00:35:37,480
messaging and durable functions in

00:35:34,510 --> 00:35:39,950
particular uses tables and queues quite

00:35:37,480 --> 00:35:42,710
extensively to do it stuff

00:35:39,950 --> 00:35:45,079
but it also uses an event sourcing

00:35:42,710 --> 00:35:47,410
technique how did you come across event

00:35:45,079 --> 00:35:49,970
sourcing okay it's quite an interesting

00:35:47,410 --> 00:35:52,520
approach to storing data in a database

00:35:49,970 --> 00:35:55,730
with event sourcing you don't ever

00:35:52,520 --> 00:35:57,320
update a row in your database so you're

00:35:55,730 --> 00:35:59,859
not using your database to store the

00:35:57,320 --> 00:36:02,450
current value instead you're always

00:35:59,859 --> 00:36:04,700
appending another event of what's

00:36:02,450 --> 00:36:06,770
happened and so to work out the current

00:36:04,700 --> 00:36:08,900
state you have to read through all of

00:36:06,770 --> 00:36:10,849
the events that have happened and so

00:36:08,900 --> 00:36:12,619
what durable functions will do as you're

00:36:10,849 --> 00:36:15,079
working through a workflow is it will

00:36:12,619 --> 00:36:17,390
say this workflow started this activity

00:36:15,079 --> 00:36:19,250
has begun this activity is completed

00:36:17,390 --> 00:36:22,339
this activity has started and so on and

00:36:19,250 --> 00:36:25,430
so it's built up a whole record in its

00:36:22,339 --> 00:36:27,740
task hub of exactly what the path

00:36:25,430 --> 00:36:30,760
through your workflow was and that turns

00:36:27,740 --> 00:36:30,760
out actually to be super useful

00:36:32,500 --> 00:36:36,410
another thing that durable functions

00:36:34,849 --> 00:36:40,790
does when you install it to your area

00:36:36,410 --> 00:36:44,540
functions app it will give you a REST

00:36:40,790 --> 00:36:46,040
API and so the REST API basically adds a

00:36:44,540 --> 00:36:48,410
number of additional endpoints to

00:36:46,040 --> 00:36:51,829
eurasia functions app for example you

00:36:48,410 --> 00:36:53,060
can query the status of a workflow so if

00:36:51,829 --> 00:36:55,099
you've kicked off a workflow and you're

00:36:53,060 --> 00:36:58,790
wondering where's it got to you can call

00:36:55,099 --> 00:37:01,280
this API you can give it the ID of the

00:36:58,790 --> 00:37:04,310
orchestration it's protected by a secret

00:37:01,280 --> 00:37:06,920
code so it's not like anyone can call

00:37:04,310 --> 00:37:09,109
this and you can actually ask it's in

00:37:06,920 --> 00:37:10,880
that request please give me the event

00:37:09,109 --> 00:37:13,460
sourcing history so if you really want

00:37:10,880 --> 00:37:16,099
to know exactly what all the steps were

00:37:13,460 --> 00:37:18,109
you can find that out you can also send

00:37:16,099 --> 00:37:19,400
an events your orchestration and we'll

00:37:18,109 --> 00:37:21,319
talk about that in a minute

00:37:19,400 --> 00:37:23,829
it's about this is useful for where

00:37:21,319 --> 00:37:27,200
you're waiting for an external system if

00:37:23,829 --> 00:37:29,420
you're if you've submitted a job to an

00:37:27,200 --> 00:37:31,790
external system and it's and it wants to

00:37:29,420 --> 00:37:35,270
then tell you that it's done it's not

00:37:31,790 --> 00:37:37,849
likely to know how to call as you have

00:37:35,270 --> 00:37:39,500
durable functions directly so usually it

00:37:37,849 --> 00:37:41,180
will call you on some other mechanism

00:37:39,500 --> 00:37:44,050
and you will then pass that message on

00:37:41,180 --> 00:37:46,579
using an API like this to your

00:37:44,050 --> 00:37:52,839
orchestration and you can terminate an

00:37:46,579 --> 00:37:55,809
orchestration as well okay so demo time

00:37:52,839 --> 00:37:58,960
I've got how much long have we got we

00:37:55,809 --> 00:38:04,680
all wait still good sir they're not

00:37:58,960 --> 00:38:10,599
listening so right we'll carry on okay

00:38:04,680 --> 00:38:14,289
so I made I made a very simple demo

00:38:10,599 --> 00:38:17,499
application and the demo application

00:38:14,289 --> 00:38:20,819
that I've made is of a ecommerce website

00:38:17,499 --> 00:38:25,329
so this is a website which is selling

00:38:20,819 --> 00:38:27,279
ebooks in my example and the way that

00:38:25,329 --> 00:38:29,619
this website is going to work is that

00:38:27,279 --> 00:38:31,930
when somebody buys an e-book on the

00:38:29,619 --> 00:38:33,430
website we're going to kick off a

00:38:31,930 --> 00:38:35,769
workflow that's going to go through a

00:38:33,430 --> 00:38:36,729
few basic steps to show off how durable

00:38:35,769 --> 00:38:39,190
functions works

00:38:36,729 --> 00:38:42,099
and if any of you've ever implemented an

00:38:39,190 --> 00:38:43,630
online shop you probably know that it's

00:38:42,099 --> 00:38:46,839
not a good idea to be the one yourself

00:38:43,630 --> 00:38:49,630
to take credit card payments you usually

00:38:46,839 --> 00:38:53,469
delegate that to a third party so stripe

00:38:49,630 --> 00:38:56,200
is quite a common third party payment

00:38:53,469 --> 00:38:58,180
provider to use on a website and so when

00:38:56,200 --> 00:39:00,009
somebody buys something they will submit

00:38:58,180 --> 00:39:02,170
their credit card details to stripe and

00:39:00,009 --> 00:39:04,869
stripe will then call you with a web

00:39:02,170 --> 00:39:07,119
hook and so when you get the web hook

00:39:04,869 --> 00:39:11,380
that would be the trigger for you to

00:39:07,119 --> 00:39:14,140
begin your your workflow and so here in

00:39:11,380 --> 00:39:16,660
this simple example we've got a web hook

00:39:14,140 --> 00:39:19,210
that's come from stripe or whoever's

00:39:16,660 --> 00:39:21,099
handling our payments and we'll kick off

00:39:19,210 --> 00:39:23,979
a durable functions orchestration and

00:39:21,099 --> 00:39:25,960
the first step we will save details of

00:39:23,979 --> 00:39:27,339
the order into our database which is

00:39:25,960 --> 00:39:29,589
just going to be table storage in this

00:39:27,339 --> 00:39:31,569
example and then I've got an optional

00:39:29,589 --> 00:39:34,239
step I'm going to say that if the order

00:39:31,569 --> 00:39:36,099
is over a certain amount maybe I'm a bit

00:39:34,239 --> 00:39:37,690
suspicious that it might not be genuine

00:39:36,099 --> 00:39:40,900
and they're going to try and ask for

00:39:37,690 --> 00:39:42,940
refund I want to manually approve that

00:39:40,900 --> 00:39:45,660
so if the order value is over a certain

00:39:42,940 --> 00:39:49,680
amount I'm going to email myself and

00:39:45,660 --> 00:39:52,210
then if I approve it then we'll progress

00:39:49,680 --> 00:39:53,890
if the orders under amount under that

00:39:52,210 --> 00:39:55,749
amount we'll just progress anyway and

00:39:53,890 --> 00:39:57,219
then for all of the things in their

00:39:55,749 --> 00:39:59,349
shopping cart that they ordered we're

00:39:57,219 --> 00:40:00,849
going to generate a watermark to PDF for

00:39:59,349 --> 00:40:04,779
them because we're a bit concerned they

00:40:00,849 --> 00:40:06,700
might share it on the internet and when

00:40:04,779 --> 00:40:08,530
all of those PDFs are in general

00:40:06,700 --> 00:40:10,119
rated we want to send them an email

00:40:08,530 --> 00:40:13,630
that's got a link for them to download

00:40:10,119 --> 00:40:19,650
it and so that gives us a chance to see

00:40:13,630 --> 00:40:19,650
the fan out fan in pattern in action so

00:40:19,980 --> 00:40:30,990
here I've got my drug commerce workflow

00:40:27,700 --> 00:40:30,990
and I'll run this up

00:40:51,440 --> 00:40:54,369
okay

00:40:58,770 --> 00:41:03,720
and I'm actually using another this is a

00:41:02,640 --> 00:41:06,089
little bit of a trick that I sometimes

00:41:03,720 --> 00:41:07,349
use for demos with as your function

00:41:06,089 --> 00:41:09,630
session functions has got a feature

00:41:07,349 --> 00:41:11,970
called proxies and which just

00:41:09,630 --> 00:41:15,510
essentially allows you to proxy any

00:41:11,970 --> 00:41:17,339
incoming requests to anywhere else and

00:41:15,510 --> 00:41:19,859
so if I have a website that's associated

00:41:17,339 --> 00:41:23,250
with my Asha functions I will often use

00:41:19,859 --> 00:41:25,680
a proxy to proxy any incoming requests

00:41:23,250 --> 00:41:28,010
through to the actual web static

00:41:25,680 --> 00:41:31,200
resources the HTML Javascript and CSS

00:41:28,010 --> 00:41:32,520
whereas all the other requests go

00:41:31,200 --> 00:41:34,619
through to the Asha functions themselves

00:41:32,520 --> 00:41:37,710
and the reason to do that is to just get

00:41:34,619 --> 00:41:40,970
around cause problems so that it appears

00:41:37,710 --> 00:41:46,950
to this website as though it's calling

00:41:40,970 --> 00:41:50,400
functions on the same the same domain so

00:41:46,950 --> 00:41:51,270
this is about the limit of my web design

00:41:50,400 --> 00:41:53,339
skills

00:41:51,270 --> 00:41:58,589
it's took me a very long time to do I

00:41:53,339 --> 00:42:01,710
did it was view Jas which is quite quite

00:41:58,589 --> 00:42:04,170
fun to use and I was going to try and do

00:42:01,710 --> 00:42:05,460
a Christmassy theme to it but I ran out

00:42:04,170 --> 00:42:07,820
of time because I spent so long trying

00:42:05,460 --> 00:42:10,380
to make this shopping cart thing work

00:42:07,820 --> 00:42:14,060
but if we add a couple of items to our

00:42:10,380 --> 00:42:16,200
carts and we look in the shopping carts

00:42:14,060 --> 00:42:18,540
we've got a few items in the shopping

00:42:16,200 --> 00:42:20,609
cart and when I click buy now this is

00:42:18,540 --> 00:42:22,080
actually going to call an azure function

00:42:20,609 --> 00:42:24,180
in my function app and it's going to

00:42:22,080 --> 00:42:33,300
start the workplace so I'll click buy

00:42:24,180 --> 00:42:36,869
now and you'll see here again don't know

00:42:33,300 --> 00:42:39,830
if I can make this actually give a

00:42:36,869 --> 00:42:39,830
larger font size

00:42:41,510 --> 00:42:48,000
okay we can see that it's it's

00:42:45,030 --> 00:42:50,220
performing the steps in my workflow so

00:42:48,000 --> 00:42:52,440
the my Orchestrator is called process

00:42:50,220 --> 00:42:54,320
order and then it's gone through the

00:42:52,440 --> 00:42:58,700
first step save the order to database

00:42:54,320 --> 00:43:01,800
it's then gone back to my Orchestrator

00:42:58,700 --> 00:43:05,220
to find out what to do next and the

00:43:01,800 --> 00:43:06,510
orchestrator has decided that it doesn't

00:43:05,220 --> 00:43:08,820
need to get approval because this wasn't

00:43:06,510 --> 00:43:11,849
a high-value order and it's created the

00:43:08,820 --> 00:43:12,570
three personalized PDFs and it's gone

00:43:11,849 --> 00:43:14,250
back to my

00:43:12,570 --> 00:43:18,120
traits of function which has decided now

00:43:14,250 --> 00:43:22,350
to send a confirmation email and so if

00:43:18,120 --> 00:43:24,560
all has gone well I should have the

00:43:22,350 --> 00:43:32,280
confirmation email and I'm using a

00:43:24,560 --> 00:43:34,590
website called mail inator which is just

00:43:32,280 --> 00:43:37,590
kind of a throwaway email inbox and so I

00:43:34,590 --> 00:43:41,010
sent the email to durable funks customer

00:43:37,590 --> 00:43:46,380
at Mainland datacom as you can see the

00:43:41,010 --> 00:43:48,690
order has just come through you can see

00:43:46,380 --> 00:43:50,040
the date time there we're not it's not

00:43:48,690 --> 00:43:52,560
smoke and mirrors this was really just

00:43:50,040 --> 00:43:56,700
sent this was actually using the

00:43:52,560 --> 00:43:58,770
SendGrid binding of SEO functions so if

00:43:56,700 --> 00:44:00,540
you've got SendGrid account you can very

00:43:58,770 --> 00:44:06,450
easily send emails with aja functions

00:44:00,540 --> 00:44:08,310
and if I click download here it will

00:44:06,450 --> 00:44:11,820
download the files that it's created you

00:44:08,310 --> 00:44:13,290
know your blob storage and as you can

00:44:11,820 --> 00:44:15,780
see it's not particularly exciting it's

00:44:13,290 --> 00:44:19,670
actually a text file and just saying

00:44:15,780 --> 00:44:24,270
what you ordered and and who it was from

00:44:19,670 --> 00:44:26,040
and I've got another page on this

00:44:24,270 --> 00:44:28,680
website which allows you to query the

00:44:26,040 --> 00:44:34,530
status of your order and so if I follow

00:44:28,680 --> 00:44:36,690
this link what this is doing this again

00:44:34,530 --> 00:44:39,270
it's going back to my as your function

00:44:36,690 --> 00:44:41,790
app and it's looking up the

00:44:39,270 --> 00:44:43,440
orchestration for that order and it's

00:44:41,790 --> 00:44:45,240
asking the dural functions give me

00:44:43,440 --> 00:44:47,700
information about the status of that

00:44:45,240 --> 00:44:52,470
workflow and so I can find out for

00:44:47,700 --> 00:44:54,090
example the azure func the drawable

00:44:52,470 --> 00:44:55,770
functions runtime status so that's

00:44:54,090 --> 00:44:58,500
saying that this workflow has actually

00:44:55,770 --> 00:45:00,330
run to completion now it can tell me the

00:44:58,500 --> 00:45:04,320
last updated time so that was the last

00:45:00,330 --> 00:45:06,510
time that the workflow took a step as

00:45:04,320 --> 00:45:07,770
you can say this this only took three

00:45:06,510 --> 00:45:12,060
seconds to run through that whole

00:45:07,770 --> 00:45:13,920
workflow and workflows can also store

00:45:12,060 --> 00:45:15,750
custom States they can remember what

00:45:13,920 --> 00:45:18,570
their input data was so I'm using that

00:45:15,750 --> 00:45:21,660
to to show this information about who

00:45:18,570 --> 00:45:23,550
purchased it what they purchased and it

00:45:21,660 --> 00:45:25,860
can also an orchestration can also have

00:45:23,550 --> 00:45:26,099
output data so I'm using that to store

00:45:25,860 --> 00:45:28,619
the

00:45:26,099 --> 00:45:34,470
locations of the downloads I can also

00:45:28,619 --> 00:45:36,089
download from here if I go back to my

00:45:34,470 --> 00:45:40,829
shop and let's make another order we're

00:45:36,089 --> 00:45:42,359
gonna buy something she probably have

00:45:40,829 --> 00:45:45,630
implemented that this cart cleared

00:45:42,359 --> 00:45:46,979
itself when you when you bought if I buy

00:45:45,630 --> 00:45:48,359
something else it doesn't really matter

00:45:46,979 --> 00:45:50,999
we can buy multiple things

00:45:48,359 --> 00:45:51,509
this will require approval so if I click

00:45:50,999 --> 00:45:57,690
buy now

00:45:51,509 --> 00:46:05,279
I mean look here you should see process

00:45:57,690 --> 00:46:07,529
order I'm not sorry okay

00:46:05,279 --> 00:46:10,829
scroll pass to quickly yeah needs

00:46:07,529 --> 00:46:15,359
approval for the order and so if I look

00:46:10,829 --> 00:46:17,460
at my order status page we'll see the

00:46:15,359 --> 00:46:19,859
orchestration is running so this

00:46:17,460 --> 00:46:21,869
workflow still in progress and a

00:46:19,859 --> 00:46:24,630
workflow can have a custom status and

00:46:21,869 --> 00:46:26,999
I've set that who needs approval just as

00:46:24,630 --> 00:46:32,549
a diagnostic message so if I go back to

00:46:26,999 --> 00:46:34,829
my mail inator I've got another email

00:46:32,549 --> 00:46:40,049
inbox which is an email to the

00:46:34,829 --> 00:46:43,099
administrator and the administrator gets

00:46:40,049 --> 00:46:46,739
an email saying please can you review

00:46:43,099 --> 00:46:50,009
this order for a certain amount and so I

00:46:46,739 --> 00:46:51,839
can click on that and I can look at my

00:46:50,009 --> 00:46:54,599
admin console which is another little

00:46:51,839 --> 00:46:56,130
page I've got my website and this admin

00:46:54,599 --> 00:46:57,660
console is showing me all the workflows

00:46:56,130 --> 00:47:00,420
that are currently in progress or

00:46:57,660 --> 00:47:03,180
completed that's the one that's we did

00:47:00,420 --> 00:47:07,619
earlier this is a new one so if I say

00:47:03,180 --> 00:47:15,049
approve that will now stop running again

00:47:07,619 --> 00:47:15,049
if I go back to was this inbox wasn't it

00:47:15,349 --> 00:47:18,559
how do I

00:47:19,040 --> 00:47:26,730
exit out of that we should now see this

00:47:23,820 --> 00:47:29,690
this order comes through and we can

00:47:26,730 --> 00:47:32,700
download that item and if we go back to

00:47:29,690 --> 00:47:38,520
the Status page for that one we can see

00:47:32,700 --> 00:47:42,150
now it's completed successfully so that

00:47:38,520 --> 00:47:44,220
was a quick run-through of how of what

00:47:42,150 --> 00:47:47,070
the demos to know anyways so the first

00:47:44,220 --> 00:47:49,770
thing that you tend to have is it's

00:47:47,070 --> 00:47:52,830
what's called a starter function so

00:47:49,770 --> 00:47:55,860
again because it's typically some other

00:47:52,830 --> 00:47:58,170
system that is causing the event that

00:47:55,860 --> 00:48:00,150
triggers your workflow that other system

00:47:58,170 --> 00:48:02,250
is not going to know about durable

00:48:00,150 --> 00:48:04,200
functions so stripe there your payment

00:48:02,250 --> 00:48:05,910
provider they're not going to call the

00:48:04,200 --> 00:48:07,590
durable functions API themselves they're

00:48:05,910 --> 00:48:09,270
just going to call a web hook so

00:48:07,590 --> 00:48:12,980
typically you'd have an azure function

00:48:09,270 --> 00:48:16,320
that receives that web hook and then

00:48:12,980 --> 00:48:19,080
starts a new workflow and so here this

00:48:16,320 --> 00:48:24,120
is a regular error function HTTP trigger

00:48:19,080 --> 00:48:25,710
and what I can use these are binding to

00:48:24,120 --> 00:48:27,600
what's called a durable orchestration

00:48:25,710 --> 00:48:29,370
client and the durable orchestration

00:48:27,600 --> 00:48:31,680
client is simply a helper class inertia

00:48:29,370 --> 00:48:35,010
functions that enables you to interact

00:48:31,680 --> 00:48:36,600
with your workflows and so what I'm

00:48:35,010 --> 00:48:40,800
doing in the body of this is I'm

00:48:36,600 --> 00:48:44,340
deserializing an order object which

00:48:40,800 --> 00:48:45,990
represents what they've ordered in a

00:48:44,340 --> 00:48:49,620
real world example here you would also

00:48:45,990 --> 00:48:51,360
almost certainly validate the H Mac of

00:48:49,620 --> 00:48:52,830
the web hooks so that people can't just

00:48:51,360 --> 00:48:57,180
call this endpoint to get free stuff

00:48:52,830 --> 00:49:00,480
from your shop but then you would call

00:48:57,180 --> 00:49:01,590
start new async on on your durable

00:49:00,480 --> 00:49:03,390
orchestration client which is

00:49:01,590 --> 00:49:07,470
essentially saying I want to initiate a

00:49:03,390 --> 00:49:09,000
new workflow and all you need to do is

00:49:07,470 --> 00:49:10,950
you tell it the name of the workflow

00:49:09,000 --> 00:49:12,270
that you want to implement so here

00:49:10,950 --> 00:49:14,640
process order is the name of the

00:49:12,270 --> 00:49:16,470
workflow you pass it the input data you

00:49:14,640 --> 00:49:19,110
want to give it which can be any json

00:49:16,470 --> 00:49:21,270
serialized object and then it will tell

00:49:19,110 --> 00:49:23,070
you what the orchestration ID is and

00:49:21,270 --> 00:49:25,410
that idea is important because you'll

00:49:23,070 --> 00:49:28,490
need that to query how far through the

00:49:25,410 --> 00:49:31,230
orchestration you are you'll need it to

00:49:28,490 --> 00:49:32,670
terminate it if you want see you can

00:49:31,230 --> 00:49:34,650
however if you want to

00:49:32,670 --> 00:49:36,480
provides actually tell it what

00:49:34,650 --> 00:49:39,780
orchestration ID you want it to use

00:49:36,480 --> 00:49:41,220
which can be useful in some scenarios so

00:49:39,780 --> 00:49:42,599
let's have a look at what an

00:49:41,220 --> 00:49:44,790
Orchestrator function looks like

00:49:42,599 --> 00:49:46,230
and rather than showing you the

00:49:44,790 --> 00:49:48,210
orchestrator function for that entire

00:49:46,230 --> 00:49:50,819
demo that we just did which is quite

00:49:48,210 --> 00:49:52,400
large and complicated this is just a

00:49:50,819 --> 00:49:54,270
simplistic

00:49:52,400 --> 00:49:56,010
Orchestrator just to give you an idea of

00:49:54,270 --> 00:49:59,609
how they work and what they look like so

00:49:56,010 --> 00:50:02,400
again it's a in many ways it's a typical

00:49:59,609 --> 00:50:05,040
as your function it's a static function

00:50:02,400 --> 00:50:07,020
and it's got a trigger a trigger

00:50:05,040 --> 00:50:08,940
attribute to say what triggers this and

00:50:07,020 --> 00:50:11,400
for an Orchestrator function it's an

00:50:08,940 --> 00:50:13,200
orchestration trigger and you bind that

00:50:11,400 --> 00:50:18,780
to what's called a durable orchestration

00:50:13,200 --> 00:50:24,599
context and so here we can see first

00:50:18,780 --> 00:50:26,819
step get get the input so as I said

00:50:24,599 --> 00:50:28,829
orchestrations can have input data that

00:50:26,819 --> 00:50:30,569
they're given in this case it's just the

00:50:28,829 --> 00:50:33,210
order what's who's ordered what

00:50:30,569 --> 00:50:35,880
and so we receive that and then we call

00:50:33,210 --> 00:50:38,520
the first activity so call activity

00:50:35,880 --> 00:50:40,290
async save order to database that's the

00:50:38,520 --> 00:50:42,450
name of another Orchestrator function

00:50:40,290 --> 00:50:43,980
again I can give it some input data so

00:50:42,450 --> 00:50:47,790
I'm just passing it the whole order and

00:50:43,980 --> 00:50:49,530
I'm awaiting that to finish and there's

00:50:47,790 --> 00:50:51,180
some real magic happening here which

00:50:49,530 --> 00:50:54,720
I'll talk about after the pizza break

00:50:51,180 --> 00:50:56,940
but it's if you're used to C sharp and

00:50:54,720 --> 00:50:59,190
you know how a sink and await works it's

00:50:56,940 --> 00:51:01,230
not quite what you think going on here

00:50:59,190 --> 00:51:03,180
but we'll just talk through the rest of

00:51:01,230 --> 00:51:05,309
this function for now and then we'll do

00:51:03,180 --> 00:51:07,440
our pizza break and then we'll we'll go

00:51:05,309 --> 00:51:11,309
into more details of what what the magic

00:51:07,440 --> 00:51:12,599
is but here you can see I'm now looping

00:51:11,309 --> 00:51:15,089
through all the items they've ordered

00:51:12,599 --> 00:51:17,640
and for each one I'm creating a PDF by

00:51:15,089 --> 00:51:20,460
calling another activity and finally I'm

00:51:17,640 --> 00:51:22,619
calling a send email activity so this is

00:51:20,460 --> 00:51:24,599
an example of a workflow that's entirely

00:51:22,619 --> 00:51:26,670
sequential I'm not going to do anything

00:51:24,599 --> 00:51:28,319
in parallel here I'm going to call save

00:51:26,670 --> 00:51:30,960
order to database I'm going to call

00:51:28,319 --> 00:51:33,569
create PDF as many times as I've got

00:51:30,960 --> 00:51:35,730
items in my order and then I'm going to

00:51:33,569 --> 00:51:40,920
send an email this as I said was a very

00:51:35,730 --> 00:51:44,010
simplistic example of of a basic

00:51:40,920 --> 00:51:46,630
Orchestrator that's just calling several

00:51:44,010 --> 00:51:49,210
activity functions one after the other

00:51:46,630 --> 00:51:51,490
and if you remember I said that there's

00:51:49,210 --> 00:51:53,019
a little bit of magic going on here

00:51:51,490 --> 00:51:57,279
that might not be what you expect if

00:51:53,019 --> 00:51:59,140
you're used to if you're used to see

00:51:57,279 --> 00:52:00,730
shops so if you look if you're just as a

00:51:59,140 --> 00:52:03,250
regular see shop developer to look at

00:52:00,730 --> 00:52:06,579
this function it looks like it would

00:52:03,250 --> 00:52:08,650
just run for the entire duration of time

00:52:06,579 --> 00:52:10,329
that the workflow is running however

00:52:08,650 --> 00:52:12,130
we've said earlier that with Azure

00:52:10,329 --> 00:52:16,319
functions you are billed for however

00:52:12,130 --> 00:52:18,670
many seconds your function runs for and

00:52:16,319 --> 00:52:21,009
in this particular example it only ran

00:52:18,670 --> 00:52:22,869
for five seconds our workflow but we

00:52:21,009 --> 00:52:26,049
when we did the run-through with the

00:52:22,869 --> 00:52:27,880
manual approval that might that might

00:52:26,049 --> 00:52:29,319
been several hours or several days and

00:52:27,880 --> 00:52:32,230
we don't want this function to be

00:52:29,319 --> 00:52:34,329
running for all of that time so actually

00:52:32,230 --> 00:52:37,029
this Orchestrator function doesn't run

00:52:34,329 --> 00:52:40,000
for the whole time and the magic all

00:52:37,029 --> 00:52:42,549
happens with the awaits keyword so what

00:52:40,000 --> 00:52:44,650
happens is we come in first time we run

00:52:42,549 --> 00:52:46,990
this Orchestrator we get as far as this

00:52:44,650 --> 00:52:49,059
when we when it does call activity async

00:52:46,990 --> 00:52:51,400
what durable functions is doing behind

00:52:49,059 --> 00:52:53,410
the scenes is it's actually just posting

00:52:51,400 --> 00:52:54,910
a message onto a key so it's posting a

00:52:53,410 --> 00:52:58,829
message onto a queue saying we need to

00:52:54,910 --> 00:53:02,319
run the save order to database activity

00:52:58,829 --> 00:53:05,349
and then when it hits that awaits

00:53:02,319 --> 00:53:08,319
keyword what the orchestrator function

00:53:05,349 --> 00:53:10,900
does is it goes to sleep it actually

00:53:08,319 --> 00:53:13,240
exits at that point and it tracks the

00:53:10,900 --> 00:53:15,339
fact that it's half all through the

00:53:13,240 --> 00:53:17,819
workflow it's got into its event

00:53:15,339 --> 00:53:20,859
sourcing database which is stored in in

00:53:17,819 --> 00:53:25,410
its task hub which is table storage and

00:53:20,859 --> 00:53:27,549
then the activity function will run

00:53:25,410 --> 00:53:29,950
triggered by OSHA durable functions

00:53:27,549 --> 00:53:31,509
using queues as the mechanism it runs

00:53:29,950 --> 00:53:33,670
through whatever its activity is and

00:53:31,509 --> 00:53:37,539
when it's finished it will post a

00:53:33,670 --> 00:53:40,420
message onto another queue that is going

00:53:37,539 --> 00:53:42,039
to wake the orchestrator up and so when

00:53:40,420 --> 00:53:44,589
the orchestrator wakes up because the

00:53:42,039 --> 00:53:47,529
fave orders a database activity function

00:53:44,589 --> 00:53:51,759
has finished what we'd like is to carry

00:53:47,529 --> 00:53:53,769
on from here right but we can't because

00:53:51,759 --> 00:53:56,589
that's not possible in c-sharp you can't

00:53:53,769 --> 00:53:58,509
just jump half way into a function so

00:53:56,589 --> 00:54:00,280
what it actually does is it starts at

00:53:58,509 --> 00:54:02,080
the top of the function again and it

00:54:00,280 --> 00:54:04,240
through everything it gets the input

00:54:02,080 --> 00:54:06,670
data for the orchestrator which it knows

00:54:04,240 --> 00:54:09,310
because it stored that in the task up it

00:54:06,670 --> 00:54:12,280
gets to call activity async save order

00:54:09,310 --> 00:54:13,990
to database and it goes I can see in my

00:54:12,280 --> 00:54:15,760
event sourcing history that I've already

00:54:13,990 --> 00:54:18,990
done that so I don't need to do it again

00:54:15,760 --> 00:54:22,240
and so it gets past this first to wait

00:54:18,990 --> 00:54:24,310
then we go through these items we get to

00:54:22,240 --> 00:54:26,770
another call activity async create PDF

00:54:24,310 --> 00:54:29,740
it hasn't done that yet so it post a

00:54:26,770 --> 00:54:31,570
message on to a queue then we get to win

00:54:29,740 --> 00:54:33,970
a weight so the orchestrator function

00:54:31,570 --> 00:54:36,220
goes to sleep again again in the

00:54:33,970 --> 00:54:39,160
background create PDF will run it will

00:54:36,220 --> 00:54:40,540
post a message back on to the queue the

00:54:39,160 --> 00:54:42,090
orchestrate will wake up again it will

00:54:40,540 --> 00:54:44,920
start at the top it'll go I've done that

00:54:42,090 --> 00:54:46,240
I've done that come through here I've

00:54:44,920 --> 00:54:47,740
done the first one of these go around

00:54:46,240 --> 00:54:48,730
the loop I've not done the second one

00:54:47,740 --> 00:54:50,530
and so on

00:54:48,730 --> 00:54:54,100
so you're Orchestrator function is

00:54:50,530 --> 00:54:56,260
constantly going to sleep waking up

00:54:54,100 --> 00:54:58,360
going to sleep and it's able to know how

00:54:56,260 --> 00:55:00,040
far through it got because of that event

00:54:58,360 --> 00:55:01,870
sourcing history what does an activity

00:55:00,040 --> 00:55:04,390
function look like activity functions as

00:55:01,870 --> 00:55:05,680
I said are not particularly exciting

00:55:04,390 --> 00:55:07,120
because they're just normal as your

00:55:05,680 --> 00:55:09,850
functions they've got the activity

00:55:07,120 --> 00:55:12,010
trigger to say tell Asha functions that

00:55:09,850 --> 00:55:15,340
I'm a function that gets triggered as an

00:55:12,010 --> 00:55:17,860
activity in a workflow and the type that

00:55:15,340 --> 00:55:20,170
you put that activity trigger against is

00:55:17,860 --> 00:55:24,820
the type of the input data for that

00:55:20,170 --> 00:55:27,490
function so deserialize that from jason

00:55:24,820 --> 00:55:28,180
and then inside your function you can do

00:55:27,490 --> 00:55:29,890
whatever you like

00:55:28,180 --> 00:55:31,540
you're obviously allowed to have side

00:55:29,890 --> 00:55:34,570
effects in activity functions because

00:55:31,540 --> 00:55:37,720
they are only going to run the once and

00:55:34,570 --> 00:55:40,030
you can return whatever objects that you

00:55:37,720 --> 00:55:44,020
like again giving information back to

00:55:40,030 --> 00:55:45,880
the orchestrator function so one trick

00:55:44,020 --> 00:55:47,860
that you might want to do with activity

00:55:45,880 --> 00:55:49,810
functions is if your Orchestrator

00:55:47,860 --> 00:55:53,140
function needs to know a value from

00:55:49,810 --> 00:55:54,970
config that's another dangerous thing to

00:55:53,140 --> 00:55:57,340
do in an Orchestrator because the value

00:55:54,970 --> 00:55:59,080
in config could change over time so it'd

00:55:57,340 --> 00:56:01,990
be better for the activity function to

00:55:59,080 --> 00:56:05,170
read the value and return it so that

00:56:01,990 --> 00:56:08,200
it's then always the same every future

00:56:05,170 --> 00:56:10,380
run so let's go back to it orchestrators

00:56:08,200 --> 00:56:14,140
and see how we would do parallel tasks

00:56:10,380 --> 00:56:16,750
so imagine I want to create those PDFs

00:56:14,140 --> 00:56:19,410
all in parallel what are doing my

00:56:16,750 --> 00:56:23,319
Orchestrator is that just go through the

00:56:19,410 --> 00:56:25,839
items in my order and instead of a

00:56:23,319 --> 00:56:27,849
waiting call activity async I'm just

00:56:25,839 --> 00:56:30,339
going to call activity async and save

00:56:27,849 --> 00:56:33,910
the result of that which is a task of

00:56:30,339 --> 00:56:35,170
string in this case into a list and so

00:56:33,910 --> 00:56:36,549
what will happen is the orchestrator

00:56:35,170 --> 00:56:38,170
will go through this say we have ordered

00:56:36,549 --> 00:56:41,019
three things go through and three times

00:56:38,170 --> 00:56:42,460
and it will call call activity async

00:56:41,019 --> 00:56:44,799
three times so there are now three

00:56:42,460 --> 00:56:46,119
messages set on the durable functions

00:56:44,799 --> 00:56:48,339
queue that is going to cause those

00:56:46,119 --> 00:56:52,150
activity functions to run in parallel

00:56:48,339 --> 00:56:55,000
and then I do a task when all and if any

00:56:52,150 --> 00:56:56,829
of you have used a task parallel library

00:56:55,000 --> 00:56:59,799
in c-sharp you'll know that's exactly

00:56:56,829 --> 00:57:01,990
the way that you would run tasks in

00:56:59,799 --> 00:57:03,730
parallel in normal c-sharp code your

00:57:01,990 --> 00:57:05,079
Orchestrator every time it runs it could

00:57:03,730 --> 00:57:07,269
be running on a different server every

00:57:05,079 --> 00:57:09,099
time also all of your activities could

00:57:07,269 --> 00:57:12,910
be running on completely different

00:57:09,099 --> 00:57:19,119
servers and in fact that is exactly what

00:57:12,910 --> 00:57:22,180
my next slide is going to try and

00:57:19,119 --> 00:57:24,900
highlight so in an Orchestrator function

00:57:22,180 --> 00:57:30,430
you can put a try-catch block around

00:57:24,900 --> 00:57:32,740
call activity calls and catch exceptions

00:57:30,430 --> 00:57:34,569
not that were just thrown in the

00:57:32,740 --> 00:57:37,269
orchestrator code which hopefully you

00:57:34,569 --> 00:57:38,650
should almost never see not an exception

00:57:37,269 --> 00:57:41,680
thrown by the orchestrator code because

00:57:38,650 --> 00:57:44,410
it's very simple deterministic code but

00:57:41,680 --> 00:57:47,109
if your activity function which could be

00:57:44,410 --> 00:57:49,720
running on a different computer throws

00:57:47,109 --> 00:57:51,400
an exception what the durable functions

00:57:49,720 --> 00:57:53,230
framework will do is catch the exception

00:57:51,400 --> 00:57:55,750
in the activity function to serialize it

00:57:53,230 --> 00:57:57,640
and then when the orchestrator wakes up

00:57:55,750 --> 00:58:01,869
it will be able to deserialize that

00:57:57,640 --> 00:58:03,940
exception throw it and so your exception

00:58:01,869 --> 00:58:06,160
handler can run and that means that

00:58:03,940 --> 00:58:07,599
you're able to catch an exception that

00:58:06,160 --> 00:58:10,900
could have been thrown on a completely

00:58:07,599 --> 00:58:12,990
different computer in the orchestrator

00:58:10,900 --> 00:58:15,220
function which is super powerful and

00:58:12,990 --> 00:58:18,160
pretty much impossible to implement

00:58:15,220 --> 00:58:20,190
using just the simple message killing

00:58:18,160 --> 00:58:23,230
technique that we talked about earlier

00:58:20,190 --> 00:58:25,150
the other thing as you can see there's

00:58:23,230 --> 00:58:27,700
an overload of call activity async

00:58:25,150 --> 00:58:30,190
called call activity with retry a

00:58:27,700 --> 00:58:32,560
think and you can pass it retry options

00:58:30,190 --> 00:58:34,599
so you can say I want to retry with 30

00:58:32,560 --> 00:58:37,270
seconds intervals a maximum of 3 times

00:58:34,599 --> 00:58:40,300
and you can actually also ask it to

00:58:37,270 --> 00:58:41,980
examine the exception type to make a

00:58:40,300 --> 00:58:45,190
decision on whether you should retry

00:58:41,980 --> 00:58:48,220
based on the exception type and the

00:58:45,190 --> 00:58:50,320
advantage of this is if it calls that

00:58:48,220 --> 00:58:52,390
activity and it fails it's going to do

00:58:50,320 --> 00:58:54,760
that 30-second sleep or however long you

00:58:52,390 --> 00:58:56,770
specify but that the orchestrator is not

00:58:54,760 --> 00:58:59,619
running for that 30 seconds so we've got

00:58:56,770 --> 00:59:05,710
out of the paying for sleeping problem

00:58:59,619 --> 00:59:07,599
using this technique you can also all of

00:59:05,710 --> 00:59:09,490
these call activity methods have got

00:59:07,599 --> 00:59:10,930
equivalent call orchestrators so if

00:59:09,490 --> 00:59:13,720
you're using that sub orchestration

00:59:10,930 --> 00:59:15,910
feature I mentioned you can retry some

00:59:13,720 --> 00:59:20,790
whole sub orchestrations and you can

00:59:15,910 --> 00:59:24,130
also call sub orchestrations in parallel

00:59:20,790 --> 00:59:27,940
how is waiting for external events

00:59:24,130 --> 00:59:30,160
implemented well again in the example

00:59:27,940 --> 00:59:33,400
that we showed we were waiting for an

00:59:30,160 --> 00:59:35,079
approver to approve an order and so if

00:59:33,400 --> 00:59:36,849
you want to tell your Orchestrator that

00:59:35,079 --> 00:59:38,470
it needs to wait for an event from an

00:59:36,849 --> 00:59:42,819
external system you use wait for

00:59:38,470 --> 00:59:45,760
external event every event has a an

00:59:42,819 --> 00:59:48,310
event name and it has a datatype

00:59:45,760 --> 00:59:53,140
associated with it which can be any json

00:59:48,310 --> 00:59:54,970
serializable object and my little

00:59:53,140 --> 00:59:57,280
contribution to gerbil functions was

00:59:54,970 --> 01:00:00,190
that this method also gives allows you

00:59:57,280 --> 01:00:02,349
to specify the timeout as a parameter it

01:00:00,190 --> 01:00:05,470
used to be much more complicated to wait

01:00:02,349 --> 01:00:07,180
for an event with a timeout but here I'm

01:00:05,470 --> 01:00:10,720
saying I'm willing to wait 30 minutes

01:00:07,180 --> 01:00:13,089
for to receive this particular external

01:00:10,720 --> 01:00:16,780
event and if I don't get it I will

01:00:13,089 --> 01:00:18,369
return the string timed out and that

01:00:16,780 --> 01:00:20,560
basically allows me then in my

01:00:18,369 --> 01:00:23,230
Orchestrator to set to make a decision

01:00:20,560 --> 01:00:25,210
based on whether I got the external

01:00:23,230 --> 01:00:28,450
event or not or whether I timed out and

01:00:25,210 --> 01:00:31,270
so here you can see we're emailing the

01:00:28,450 --> 01:00:33,130
customer if the order was approved but

01:00:31,270 --> 01:00:36,089
if not we're going into some other

01:00:33,130 --> 01:00:39,040
activity that will do some kind of

01:00:36,089 --> 01:00:40,640
mitigation of that scenario there is one

01:00:39,040 --> 01:00:43,520
limitation of

01:00:40,640 --> 01:00:46,070
store Storage Q's has got a maximum

01:00:43,520 --> 01:00:48,380
length of time that it can be it can

01:00:46,070 --> 01:00:51,740
future sheds you'll a message for which

01:00:48,380 --> 01:00:52,760
I think I can't remember what exactly is

01:00:51,740 --> 01:00:55,010
this much something in the order of a

01:00:52,760 --> 01:00:57,950
week so if you want to like weights have

01:00:55,010 --> 01:00:59,450
a timeout of of months you you have to

01:00:57,950 --> 01:01:02,960
jump through a few hoops at the moment

01:00:59,450 --> 01:01:05,090
and it's skin I've suggested some code

01:01:02,960 --> 01:01:06,710
on their github repository of how they

01:01:05,090 --> 01:01:09,080
could work around that which might make

01:01:06,710 --> 01:01:17,000
it into a future version of herbal

01:01:09,080 --> 01:01:18,980
functions how do you send an external

01:01:17,000 --> 01:01:20,360
event so if your workflows to set

01:01:18,980 --> 01:01:23,210
they're waiting for an event to happen

01:01:20,360 --> 01:01:24,980
how does it know about that like I said

01:01:23,210 --> 01:01:26,960
it's very unlikely that your external

01:01:24,980 --> 01:01:29,510
system knows about durable functions and

01:01:26,960 --> 01:01:31,670
knows how to send a notification

01:01:29,510 --> 01:01:33,860
directly to the workflow you probably

01:01:31,670 --> 01:01:36,290
wouldn't even want that anyway it's

01:01:33,860 --> 01:01:38,150
better to have a level of indirection so

01:01:36,290 --> 01:01:41,600
your external system sends your webhook

01:01:38,150 --> 01:01:44,150
or contacts you however it does that and

01:01:41,600 --> 01:01:47,240
then you just have a regular as your

01:01:44,150 --> 01:01:50,060
function so this is just a regular HTTP

01:01:47,240 --> 01:01:53,810
Jirga desert function that when it's

01:01:50,060 --> 01:01:55,460
called uses the durable orchestration

01:01:53,810 --> 01:01:57,470
client which is what we use to start the

01:01:55,460 --> 01:01:59,960
workflow in the first place and we call

01:01:57,470 --> 01:02:02,090
raise of an async the name of the event

01:01:59,960 --> 01:02:03,650
and the data that we want to pass to it

01:02:02,090 --> 01:02:06,140
and that will cause our Orchestrator to

01:02:03,650 --> 01:02:08,420
wake up again reach the point where it

01:02:06,140 --> 01:02:10,310
was waiting for external event and make

01:02:08,420 --> 01:02:12,490
the decision of of what he needs to do

01:02:10,310 --> 01:02:12,490
next

01:02:15,160 --> 01:02:20,240
so that was my run-through actually of

01:02:17,900 --> 01:02:23,300
all the code of durable functions I've

01:02:20,240 --> 01:02:24,890
got a slide here on why would you why

01:02:23,300 --> 01:02:26,120
would you want to use durable functions

01:02:24,890 --> 01:02:28,040
what's the case for it

01:02:26,120 --> 01:02:30,770
hopefully I've made a fairly decent case

01:02:28,040 --> 01:02:32,150
for using it tonight I like the fact you

01:02:30,770 --> 01:02:34,160
get to define the big picture of your

01:02:32,150 --> 01:02:35,900
workflow in code and like the fact that

01:02:34,160 --> 01:02:38,180
you in the orchestrator you can handle

01:02:35,900 --> 01:02:40,120
errors wherever they occur in the

01:02:38,180 --> 01:02:42,680
workflow and so you can have global

01:02:40,120 --> 01:02:44,360
exception handling you can retry

01:02:42,680 --> 01:02:47,990
individual steps with back off without

01:02:44,360 --> 01:02:50,090
paying for that waiting time it makes it

01:02:47,990 --> 01:02:52,160
easy to implement waiting for external

01:02:50,090 --> 01:02:54,230
events with timeouts and parallel

01:02:52,160 --> 01:02:56,090
workflows to things which are quite hard

01:02:54,230 --> 01:02:59,780
implement if you've not got a framework

01:02:56,090 --> 01:03:01,520
like this it also makes it really easy

01:02:59,780 --> 01:03:03,470
to track the progress of your workflows

01:03:01,520 --> 01:03:05,330
like I said the the fact that it's using

01:03:03,470 --> 01:03:09,320
event sourcing although it's a slightly

01:03:05,330 --> 01:03:10,580
quirky way of storing information it

01:03:09,320 --> 01:03:13,820
actually turns out to be really useful

01:03:10,580 --> 01:03:16,550
in this case because I can see a full

01:03:13,820 --> 01:03:18,680
audit trail of exactly every single step

01:03:16,550 --> 01:03:21,170
that my workflow went through and so

01:03:18,680 --> 01:03:23,900
something weird does go wrong I can very

01:03:21,170 --> 01:03:25,640
easily work out exactly what's happened

01:03:23,900 --> 01:03:27,830
you can cancel workflows it's open

01:03:25,640 --> 01:03:29,570
source and of course because it's built

01:03:27,830 --> 01:03:31,520
on top of Asia functions everything

01:03:29,570 --> 01:03:33,320
that's great about Asia functions all

01:03:31,520 --> 01:03:35,990
the ways it can be hosted all of the

01:03:33,320 --> 01:03:38,720
deployment tools all of the apps service

01:03:35,990 --> 01:03:41,330
features in Asia are all available to

01:03:38,720 --> 01:03:42,560
you in Asia functions can you test it

01:03:41,330 --> 01:03:45,920
right so that was another one of the

01:03:42,560 --> 01:03:52,609
kind of bonus things to talk about unit

01:03:45,920 --> 01:03:59,090
testing of functions so if we go back to

01:03:52,609 --> 01:04:00,680
the function app I have added in this

01:03:59,090 --> 01:04:03,080
demo project by the way this is on

01:04:00,680 --> 01:04:05,510
github of Tron remember to put the slide

01:04:03,080 --> 01:04:06,980
up with the github link to it so you can

01:04:05,510 --> 01:04:12,800
have a look at it and play with it if

01:04:06,980 --> 01:04:16,280
you like I have got some unit tests for

01:04:12,800 --> 01:04:21,140
the orchestrator and because an

01:04:16,280 --> 01:04:25,310
Orchestrator if we look at the let's

01:04:21,140 --> 01:04:28,310
look at the orchestrator so here's my

01:04:25,310 --> 01:04:31,850
process order Orchestrator function gets

01:04:28,310 --> 01:04:36,400
the input saves the order to database if

01:04:31,850 --> 01:04:39,590
the if the total was over $1,000 then we

01:04:36,400 --> 01:04:41,810
request approval sending the email we

01:04:39,590 --> 01:04:44,390
wait for the external event if it was

01:04:41,810 --> 01:04:46,280
approved if it wasn't approved or we got

01:04:44,390 --> 01:04:47,270
a timeout we send an email to the

01:04:46,280 --> 01:04:50,930
customer saying sorry

01:04:47,270 --> 01:04:52,550
we've not accepted your order if we did

01:04:50,930 --> 01:04:54,530
approve it we go through we run the

01:04:52,550 --> 01:04:57,530
parallel tasks and wait for the mall to

01:04:54,530 --> 01:05:01,190
finish creating the PDFs and then we

01:04:57,530 --> 01:05:03,109
send a confirmation email to the to the

01:05:01,190 --> 01:05:04,580
customer and if something went wrong we

01:05:03,109 --> 01:05:07,070
also send a problem email to the

01:05:04,580 --> 01:05:07,559
customer but if you actually look at the

01:05:07,070 --> 01:05:11,430
signature

01:05:07,559 --> 01:05:13,439
this function all it's got its got one

01:05:11,430 --> 01:05:15,779
it's got an ilogger which we can easily

01:05:13,439 --> 01:05:18,479
mark it's got a durable orchestration

01:05:15,779 --> 01:05:20,880
context base which is an abstract base

01:05:18,479 --> 01:05:24,029
class which we can also easily block so

01:05:20,880 --> 01:05:29,309
all of the unit testing techniques that

01:05:24,029 --> 01:05:31,259
you use so I use an unit and Macchio but

01:05:29,309 --> 01:05:32,759
you can use whatever unit testing

01:05:31,259 --> 01:05:34,709
framework and mocking library you like

01:05:32,759 --> 01:05:37,499
you can just write regular unit tests

01:05:34,709 --> 01:05:39,269
for this so certainly on the unit test

01:05:37,499 --> 01:05:41,729
level it's really easy to write unit

01:05:39,269 --> 01:05:43,439
tests for your orchestrators activities

01:05:41,729 --> 01:05:45,749
can be a bit harder because some of the

01:05:43,439 --> 01:05:48,059
bindings like the blob storage binding

01:05:45,749 --> 01:05:51,239
isn't easy to mock and so it's really

01:05:48,059 --> 01:05:53,459
hard to write a unit test for your X

01:05:51,239 --> 01:05:56,880
activity function if it's using and not

01:05:53,459 --> 01:05:59,519
easily mockable binding object however

01:05:56,880 --> 01:06:02,519
the second the second level would be to

01:05:59,519 --> 01:06:04,529
say I want to do some actual proper

01:06:02,519 --> 01:06:06,930
integration test so once actually run my

01:06:04,529 --> 01:06:09,479
function app so you'd have to deploy an

01:06:06,930 --> 01:06:11,519
instance of it which is actually very

01:06:09,479 --> 01:06:13,939
easy to deploy as your function APS's

01:06:11,519 --> 01:06:16,349
the app service plan has got lots of

01:06:13,939 --> 01:06:19,109
lots of ways of deploying that are quite

01:06:16,349 --> 01:06:22,650
easy just zip it up and push it push a

01:06:19,109 --> 01:06:25,079
new version and then you could literally

01:06:22,650 --> 01:06:27,869
just try calling orchestrations and

01:06:25,079 --> 01:06:32,910
check on their status you might want to

01:06:27,869 --> 01:06:35,039
inject into your workflow some ways of

01:06:32,910 --> 01:06:36,779
mocking out things though because if you

01:06:35,039 --> 01:06:39,269
were really charging credit cards or if

01:06:36,779 --> 01:06:41,009
you were really sending emails or alerts

01:06:39,269 --> 01:06:44,549
to things you might want to have a way

01:06:41,009 --> 01:06:46,679
that you can disable those for your

01:06:44,549 --> 01:06:49,319
integration tests but still test that

01:06:46,679 --> 01:06:52,349
the whole steps in the workflow working

01:06:49,319 --> 01:06:53,880
likewise if there was a an approval time

01:06:52,349 --> 01:06:55,979
out let's say that the approval time out

01:06:53,880 --> 01:06:57,449
was a week you wouldn't probably want

01:06:55,979 --> 01:06:58,799
your integration test to have to wait a

01:06:57,449 --> 01:07:01,920
week so you'd want to have a way of

01:06:58,799 --> 01:07:02,910
injecting into your orchestrators and

01:07:01,920 --> 01:07:07,529
configurability

01:07:02,910 --> 01:07:09,989
of how long the the approval time out

01:07:07,529 --> 01:07:11,969
was but it's certainly possible to set

01:07:09,989 --> 01:07:16,739
that up because I completely rewrote

01:07:11,969 --> 01:07:19,019
like my demo application I didn't finish

01:07:16,739 --> 01:07:21,150
testing it in time to deploy it to

01:07:19,019 --> 01:07:24,150
actually to Azure so we could

01:07:21,150 --> 01:07:27,390
deploy it now to Asia for the first time

01:07:24,150 --> 01:07:29,039
and the way I'll do it it's the way that

01:07:27,390 --> 01:07:30,510
you're absolutely not supposed to deploy

01:07:29,039 --> 01:07:34,890
things to Asia which is a right click

01:07:30,510 --> 01:07:37,710
publish in Visual Studio there are there

01:07:34,890 --> 01:07:40,589
are much better ways to deploy that you

01:07:37,710 --> 01:07:42,750
would use in a real CI CD process one of

01:07:40,589 --> 01:07:45,270
my favorite ways of deploying things in

01:07:42,750 --> 01:07:47,910
Asia is with the azure CLI which is a

01:07:45,270 --> 01:07:51,180
cross-platform command-line interface

01:07:47,910 --> 01:07:57,150
it's super easy to use so you can deploy

01:07:51,180 --> 01:07:59,220
this using that but if I I yes there

01:07:57,150 --> 01:08:05,789
might happen to be a as your CLI force

01:07:59,220 --> 01:08:08,119
like course by me as well so I need to

01:08:05,789 --> 01:08:16,949
right-click on my function project and

01:08:08,119 --> 01:08:19,500
click publish and oh it still remembers

01:08:16,949 --> 01:08:23,549
where I published it to last time okay

01:08:19,500 --> 01:08:26,040
because I did this a version of this

01:08:23,549 --> 01:08:27,960
talk at a conference called Prague net

01:08:26,040 --> 01:08:30,390
and so I published it from there so it

01:08:27,960 --> 01:08:32,460
remembers where I published it so

01:08:30,390 --> 01:08:34,770
however that is all deleted now so it

01:08:32,460 --> 01:08:38,130
won't be able to publish it so a new

01:08:34,770 --> 01:08:40,140
profile I want to create a new as your

01:08:38,130 --> 01:08:43,109
function apps so I need an app service

01:08:40,140 --> 01:08:45,480
to run it on so Asha functions it can

01:08:43,109 --> 01:08:46,920
run on what's called the consumption

01:08:45,480 --> 01:08:51,089
pricing plan and that's where it's got

01:08:46,920 --> 01:08:53,699
the pay per second pricing model that we

01:08:51,089 --> 01:08:56,250
talked about but you can also run it

01:08:53,699 --> 01:08:58,140
just on a regular as your service plan

01:08:56,250 --> 01:09:00,089
which is where you're paying for a

01:08:58,140 --> 01:09:02,489
server per month and one of the

01:09:00,089 --> 01:09:04,290
advantages of that the disadvantage is

01:09:02,489 --> 01:09:06,779
you don't get the infinite scaling and

01:09:04,290 --> 01:09:08,730
the per second pricing model but the

01:09:06,779 --> 01:09:10,980
advantages your functions are running on

01:09:08,730 --> 01:09:12,900
your server you're not sharing tenancy

01:09:10,980 --> 01:09:15,359
with anyone else and you've and you also

01:09:12,900 --> 01:09:17,009
have got fixed price and when you run in

01:09:15,359 --> 01:09:19,650
that mode they also take away that five

01:09:17,009 --> 01:09:20,929
minutes function limit because it

01:09:19,650 --> 01:09:23,759
doesn't really matter anymore you can

01:09:20,929 --> 01:09:26,880
you can wait 30 minutes in your function

01:09:23,759 --> 01:09:30,830
and it doesn't matter but if I say

01:09:26,880 --> 01:09:34,719
select new create new as app service

01:09:30,830 --> 01:09:37,440
publish it will

01:09:34,719 --> 01:09:44,799
way and it will load my subscriptions

01:09:37,440 --> 01:09:48,100
and it will suggest ridiculous that name

01:09:44,799 --> 01:09:49,960
for me it will pick a storage account

01:09:48,100 --> 01:09:55,330
because it needs a storage account for

01:09:49,960 --> 01:09:57,880
the gerbil task hub and I can pick the

01:09:55,330 --> 01:10:00,880
hosting plan the hosting plan is what I

01:09:57,880 --> 01:10:02,680
was saying this is this why one it's not

01:10:00,880 --> 01:10:04,540
very clearly explained in this dialog

01:10:02,680 --> 01:10:08,380
but that means the consumption plan and

01:10:04,540 --> 01:10:14,890
I'm in north europe and i will create a

01:10:08,380 --> 01:10:17,590
new div south coast resource group

01:10:14,890 --> 01:10:19,270
always a good idea inertia to create

01:10:17,590 --> 01:10:25,300
resource groups for the stuff you deploy

01:10:19,270 --> 01:10:26,560
so you say create unfortunately we

01:10:25,300 --> 01:10:30,340
probably won't have time to see this

01:10:26,560 --> 01:10:33,989
completely finished because after I've

01:10:30,340 --> 01:10:36,400
created this I will need to set up some

01:10:33,989 --> 01:10:38,680
set up some app settings which have got

01:10:36,400 --> 01:10:41,590
my SendGrid secret key that lets me send

01:10:38,680 --> 01:10:44,020
emails and also I would need to tell it

01:10:41,590 --> 01:10:46,180
where to find those beautiful web pages

01:10:44,020 --> 01:10:48,070
that I created which I would also need

01:10:46,180 --> 01:10:51,130
to host in Azure which I haven't done

01:10:48,070 --> 01:10:52,420
yet so things you're hovering will

01:10:51,130 --> 01:10:57,320
probably stop there but that is how you

01:10:52,420 --> 01:11:02,979
deploy a function app

01:10:57,320 --> 01:11:02,979

YouTube URL: https://www.youtube.com/watch?v=dIufQmNRsf4


