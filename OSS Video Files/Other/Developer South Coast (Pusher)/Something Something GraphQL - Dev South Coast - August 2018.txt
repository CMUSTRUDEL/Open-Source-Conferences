Title: Something Something GraphQL - Dev South Coast - August 2018
Publication date: 2018-09-09
Playlist: Developer South Coast
Description: 
	Presented by Carlos Perestrelo Correia.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:06,480
hello everyone this is my first time so

00:00:02,159 --> 00:00:08,340
don't hurt me so a little bit about me

00:00:06,480 --> 00:00:10,830
right so my name is Carlos that's my

00:00:08,340 --> 00:00:13,740
name and surname those two bits not my

00:00:10,830 --> 00:00:14,670
middle name I'm from South America

00:00:13,740 --> 00:00:17,070
originally so I've been around the world

00:00:14,670 --> 00:00:20,789
for a bit I've been developing

00:00:17,070 --> 00:00:23,220
professionally since about 2002 I've

00:00:20,789 --> 00:00:26,220
done everything DBA development

00:00:23,220 --> 00:00:30,000
networking patch cables got under desks

00:00:26,220 --> 00:00:32,309
you know build servers my real passion

00:00:30,000 --> 00:00:35,550
is software development and it's kind of

00:00:32,309 --> 00:00:40,559
come to that realization recently I work

00:00:35,550 --> 00:00:41,730
for Centrica so get involved used to get

00:00:40,559 --> 00:00:45,570
involved most can feel the mobile

00:00:41,730 --> 00:00:47,340
application development and but recently

00:00:45,570 --> 00:00:50,550
I've been more around looking around the

00:00:47,340 --> 00:00:53,190
architect space so I am an architect by

00:00:50,550 --> 00:00:56,750
day and a developer by night because

00:00:53,190 --> 00:00:59,969
that's where my heart really is right so

00:00:56,750 --> 00:01:03,750
the reason why sort of the topic is

00:00:59,969 --> 00:01:07,920
graph QL anyway M is a chemical fql

00:01:03,750 --> 00:01:10,770
probably around 2016 and I was working

00:01:07,920 --> 00:01:13,710
on a project for Sentra called the

00:01:10,770 --> 00:01:15,420
Cornwall LEM project so it'll be calm or

00:01:13,710 --> 00:01:17,810
being just down the road they're

00:01:15,420 --> 00:01:21,780
developing a local energy market

00:01:17,810 --> 00:01:23,040
effectively and it's all EU funded and

00:01:21,780 --> 00:01:25,920
you can go to the centrical website and

00:01:23,040 --> 00:01:27,960
have a look and effectively one of the

00:01:25,920 --> 00:01:30,780
challenges that we faced was how do we

00:01:27,960 --> 00:01:35,040
provide a consistent API to our

00:01:30,780 --> 00:01:36,540
potential consumers now we could have

00:01:35,040 --> 00:01:37,979
gone down the rest route and one of the

00:01:36,540 --> 00:01:40,640
challenges that we faced around race as

00:01:37,979 --> 00:01:43,560
we ended up with a plethora of api's

00:01:40,640 --> 00:01:45,930
which becomes a little bit unwieldy and

00:01:43,560 --> 00:01:47,579
then the team started getting concerned

00:01:45,930 --> 00:01:48,960
about versioning and things like that

00:01:47,579 --> 00:01:51,149
and how do we manage that going forward

00:01:48,960 --> 00:01:53,340
and because it's a proof-of-concept or

00:01:51,149 --> 00:01:55,290
even a prototype if you will and we it's

00:01:53,340 --> 00:01:58,140
an R&D project as well we're kind of

00:01:55,290 --> 00:02:02,100
evolving as we go and the rest approach

00:01:58,140 --> 00:02:04,079
wasn't really working and for us to an

00:02:02,100 --> 00:02:05,759
extent okay and it's only from the

00:02:04,079 --> 00:02:08,399
consumers perspective and with a

00:02:05,759 --> 00:02:10,679
graphical stuff that we've used and

00:02:08,399 --> 00:02:12,599
although we've implemented we were able

00:02:10,679 --> 00:02:13,410
to decouple the user interface quite

00:02:12,599 --> 00:02:16,350
cleanly from

00:02:13,410 --> 00:02:18,240
the wrists api's okay so we didn't get

00:02:16,350 --> 00:02:19,920
rid of wrists completely we just

00:02:18,240 --> 00:02:24,180
introduced graph colors an abstraction

00:02:19,920 --> 00:02:26,760
layer okay so that's a bit about me

00:02:24,180 --> 00:02:28,110
that's my Twitter handle

00:02:26,760 --> 00:02:30,330
I would put my github on there if it had

00:02:28,110 --> 00:02:31,440
anything but it doesn't have anything at

00:02:30,330 --> 00:02:35,400
the moment so there's no point in

00:02:31,440 --> 00:02:36,810
sharing that so a brief history and

00:02:35,400 --> 00:02:39,360
diving straight n integral ah so was

00:02:36,810 --> 00:02:41,820
created in 2012 and it was open source

00:02:39,360 --> 00:02:45,240
in 2050 and effectively and developed a

00:02:41,820 --> 00:02:50,370
Facebook when Facebook IPO D one of the

00:02:45,240 --> 00:02:52,080
reasons they needed this effectively was

00:02:50,370 --> 00:02:53,610
that their mobile offering was actually

00:02:52,080 --> 00:02:56,520
pretty poor and then they realized that

00:02:53,610 --> 00:02:58,140
the bulk of the traffic was going to

00:02:56,520 --> 00:02:59,940
come from mobile now the challenge with

00:02:58,140 --> 00:03:02,520
rest and mobile is that obviously you

00:02:59,940 --> 00:03:04,350
have a ton of chatty connectivity right

00:03:02,520 --> 00:03:07,380
so you effectively every time you make a

00:03:04,350 --> 00:03:09,570
request for something if you pierced

00:03:07,380 --> 00:03:10,860
then you end up with the hypermedia link

00:03:09,570 --> 00:03:12,420
potentially to go somewhere else and

00:03:10,860 --> 00:03:13,890
effectively you're pulling and then

00:03:12,420 --> 00:03:18,030
pulling and pulling and it's a kind of

00:03:13,890 --> 00:03:20,100
never-ending cycle okay so this was

00:03:18,030 --> 00:03:22,020
introduced to solve the newsfeed problem

00:03:20,100 --> 00:03:23,670
and that they were having especially to

00:03:22,020 --> 00:03:26,010
resolve the issue around this chatty

00:03:23,670 --> 00:03:27,870
connectivity and poor networks okay you

00:03:26,010 --> 00:03:29,580
can't really have if you go to some

00:03:27,870 --> 00:03:32,940
third-world countries for instance where

00:03:29,580 --> 00:03:35,130
they lean or they use Facebook

00:03:32,940 --> 00:03:36,630
potentially quite extensively they don't

00:03:35,130 --> 00:03:38,580
really have reliable networks so having

00:03:36,630 --> 00:03:40,410
a chatty connectivity isn't really

00:03:38,580 --> 00:03:43,890
useful okay what doesn't actually really

00:03:40,410 --> 00:03:46,020
work so in essence all that was released

00:03:43,890 --> 00:03:47,480
is a query there's a specification right

00:03:46,020 --> 00:03:50,970
across your let's just a specification

00:03:47,480 --> 00:03:51,720
that defines how you should interact

00:03:50,970 --> 00:03:53,850
query

00:03:51,720 --> 00:03:55,770
and endpoint okay there's nothing more

00:03:53,850 --> 00:03:58,140
to it than that they do provide

00:03:55,770 --> 00:04:00,450
reference servers and clients and things

00:03:58,140 --> 00:04:03,560
like that but ultimately it is just like

00:04:00,450 --> 00:04:06,690
oh data if you will but for the new-age

00:04:03,560 --> 00:04:10,320
okay it is an alternative to rest

00:04:06,690 --> 00:04:14,280
although we found that depending on how

00:04:10,320 --> 00:04:15,870
you work you tend to I combine both you

00:04:14,280 --> 00:04:20,070
know some people struggle with some

00:04:15,870 --> 00:04:21,690
concepts in rest or in graph QL and and

00:04:20,070 --> 00:04:24,090
ideally they're more familiar with race

00:04:21,690 --> 00:04:25,800
so you can tend to decide how you want

00:04:24,090 --> 00:04:26,980
to pick your battles you can combine

00:04:25,800 --> 00:04:30,760
both it's not

00:04:26,980 --> 00:04:34,330
be all and end all we found for instance

00:04:30,760 --> 00:04:37,810
that using it for people are familiar

00:04:34,330 --> 00:04:39,460
with the puddin post actions so from

00:04:37,810 --> 00:04:40,540
that perspective you know if you're

00:04:39,460 --> 00:04:41,890
doing commits and things like that

00:04:40,540 --> 00:04:42,910
people understand that concepts are

00:04:41,890 --> 00:04:44,560
therefore it's easier for them to use

00:04:42,910 --> 00:04:46,630
that in growth kill it's slightly

00:04:44,560 --> 00:04:50,230
different and it might be a little bit

00:04:46,630 --> 00:04:51,580
jarring and the typically when you do an

00:04:50,230 --> 00:04:53,830
update or an insert as well you're only

00:04:51,580 --> 00:04:55,720
really doing one thing and you're not

00:04:53,830 --> 00:04:57,310
sort of ending up in a situation we are

00:04:55,720 --> 00:04:58,930
pulling multiple links from various

00:04:57,310 --> 00:05:00,250
places so from that perspective it kind

00:04:58,930 --> 00:05:04,000
of makes sense to mix the two so a

00:05:00,250 --> 00:05:05,380
hybrid approach is quite balanced you

00:05:04,000 --> 00:05:06,850
know I would argue that you could

00:05:05,380 --> 00:05:08,770
potentially start with wrist first and

00:05:06,850 --> 00:05:15,070
then provide this layer on top of it

00:05:08,770 --> 00:05:16,990
okay so as I say was developed and an

00:05:15,070 --> 00:05:19,450
open source by Facebook and it's

00:05:16,990 --> 00:05:23,500
declarative in its nature in terms of

00:05:19,450 --> 00:05:25,060
how the client receives that data so the

00:05:23,500 --> 00:05:26,320
crimes this effectively puts the client

00:05:25,060 --> 00:05:28,210
in control so it opens up a whole world

00:05:26,320 --> 00:05:30,810
of possibilities from an API perspective

00:05:28,210 --> 00:05:35,170
so typically where you have a REST API

00:05:30,810 --> 00:05:37,660
and you expose a endpoint effectively

00:05:35,170 --> 00:05:39,130
and you effectively or the dry and the

00:05:37,660 --> 00:05:41,130
driving seat in terms of what the client

00:05:39,130 --> 00:05:43,900
gets so you're in full control of that

00:05:41,130 --> 00:05:46,690
with graph QL to an extent you're not

00:05:43,900 --> 00:05:48,700
right you effectively provide the API

00:05:46,690 --> 00:05:51,310
and hire the end user consumes the API

00:05:48,700 --> 00:05:54,190
is depending on how you define your

00:05:51,310 --> 00:05:56,500
graph QL endpoint will allow them to

00:05:54,190 --> 00:05:57,790
actually follow relationships that you

00:05:56,500 --> 00:06:00,280
may not necessarily have thought had

00:05:57,790 --> 00:06:01,240
been possible okay or even considered

00:06:00,280 --> 00:06:03,970
purely because it doesn't make sense

00:06:01,240 --> 00:06:08,140
some people like to break things so they

00:06:03,970 --> 00:06:09,310
will try to break things so again and

00:06:08,140 --> 00:06:11,730
another one is an interesting one it's a

00:06:09,310 --> 00:06:15,190
single endpoint for all of your data now

00:06:11,730 --> 00:06:17,080
that is a problem sometimes depending on

00:06:15,190 --> 00:06:20,350
how you actually release or you deploy

00:06:17,080 --> 00:06:22,540
your solution you could argue that the

00:06:20,350 --> 00:06:24,100
benefit of rest is you have you know the

00:06:22,540 --> 00:06:28,540
ability to spread your API across

00:06:24,100 --> 00:06:30,820
multiple nodes in the new world of

00:06:28,540 --> 00:06:32,650
function as a service when you're

00:06:30,820 --> 00:06:34,360
exposing api's you could typically use

00:06:32,650 --> 00:06:36,760
something like a lambda function or a is

00:06:34,360 --> 00:06:38,320
your function and if you expose your API

00:06:36,760 --> 00:06:40,720
by that you get infinite scalability so

00:06:38,320 --> 00:06:40,900
the single endpoint where typically we

00:06:40,720 --> 00:06:42,220
would

00:06:40,900 --> 00:06:43,630
considered well we've got one node

00:06:42,220 --> 00:06:45,100
that's one endpoint if it breaks it's

00:06:43,630 --> 00:06:47,919
gonna break a bunch of stuff that

00:06:45,100 --> 00:06:50,160
problem tends to go away okay if you're

00:06:47,919 --> 00:06:52,210
looking at it it's implementing it in a

00:06:50,160 --> 00:06:56,470
function of the service type environment

00:06:52,210 --> 00:06:57,789
okay there are benefits as well to being

00:06:56,470 --> 00:06:59,050
able to do a single endpoint and that's

00:06:57,789 --> 00:07:01,330
effectively once we get down into the

00:06:59,050 --> 00:07:05,169
queries will soon realize what those

00:07:01,330 --> 00:07:09,370
benefits are okay so as I said it is a

00:07:05,169 --> 00:07:11,229
bit of rest and it is literally just

00:07:09,370 --> 00:07:13,199
because it's not as chatty now what

00:07:11,229 --> 00:07:16,300
happens behind the scenes is completely

00:07:13,199 --> 00:07:17,889
different right so it's not chatty in

00:07:16,300 --> 00:07:20,020
terms of communication with the client

00:07:17,889 --> 00:07:22,240
so the consumer but you know you step

00:07:20,020 --> 00:07:24,880
you typically still back off onto REST

00:07:22,240 --> 00:07:27,160
API soap and points whatever it is that

00:07:24,880 --> 00:07:28,750
you want to do behind the graph QL yeah

00:07:27,160 --> 00:07:30,280
the terminology that they call is

00:07:28,750 --> 00:07:31,660
effectively a resolver so when you

00:07:30,280 --> 00:07:33,250
request something that's usually what

00:07:31,660 --> 00:07:34,389
the core is all the function and that

00:07:33,250 --> 00:07:36,190
resolver function it's just literally

00:07:34,389 --> 00:07:38,620
code then effectively you code that up

00:07:36,190 --> 00:07:39,970
you decide what is returned from the

00:07:38,620 --> 00:07:47,860
resolver and then you present that up

00:07:39,970 --> 00:07:52,479
through your API okay so swiftly moving

00:07:47,860 --> 00:07:54,639
on so in graph QL effectively what we

00:07:52,479 --> 00:07:56,590
have is the SDL sometimes refer to is

00:07:54,639 --> 00:08:01,900
the IDL and it's a schema definition

00:07:56,590 --> 00:08:03,340
language okay in in essence it's

00:08:01,900 --> 00:08:05,500
effectively like a JavaScript file does

00:08:03,340 --> 00:08:07,389
looks a bit like JavaScript not quite

00:08:05,500 --> 00:08:08,919
but it's got some of the similar

00:08:07,389 --> 00:08:10,990
semantics okay so it's got curly bracket

00:08:08,919 --> 00:08:12,729
syntax and things like that you can

00:08:10,990 --> 00:08:15,610
define types of internet interfaces

00:08:12,729 --> 00:08:17,380
which effectively allow you to create

00:08:15,610 --> 00:08:18,750
some abstraction logic in your code and

00:08:17,380 --> 00:08:20,650
there's three main components

00:08:18,750 --> 00:08:22,150
effectively to the SDL you've

00:08:20,650 --> 00:08:24,699
effectively got your types of interfaces

00:08:22,150 --> 00:08:30,760
but you need to have queries mutations

00:08:24,699 --> 00:08:33,219
and subscriptions now so your queries as

00:08:30,760 --> 00:08:36,669
an example are literally how you acquire

00:08:33,219 --> 00:08:39,459
your endpoint now all of this can be is

00:08:36,669 --> 00:08:41,320
effectively defined typically within one

00:08:39,459 --> 00:08:42,459
file you can merge files and things like

00:08:41,320 --> 00:08:44,620
that and run Jim together if you like

00:08:42,459 --> 00:08:47,620
but typically it's a string and it says

00:08:44,620 --> 00:08:49,540
these are my types and these are my

00:08:47,620 --> 00:08:51,730
queries and my mutations are

00:08:49,540 --> 00:08:54,440
subscriptions and mutations is obviously

00:08:51,730 --> 00:08:59,180
what performs the create update

00:08:54,440 --> 00:09:00,560
and delete operations okay again nothing

00:08:59,180 --> 00:09:02,420
is given to you because all they've

00:09:00,560 --> 00:09:03,829
delivered is the schema right so you're

00:09:02,420 --> 00:09:06,529
effectively having to wire this up for

00:09:03,829 --> 00:09:07,730
yourself but there are frameworks in

00:09:06,529 --> 00:09:10,160
assist you with a heavy lifting

00:09:07,730 --> 00:09:12,560
okay um subscription is an interesting

00:09:10,160 --> 00:09:14,860
one so that's kind of obvious if you're

00:09:12,560 --> 00:09:17,180
doing a pub sub type mechanism

00:09:14,860 --> 00:09:19,629
effectively use a subscription to listen

00:09:17,180 --> 00:09:23,060
for entities being added or modified

00:09:19,629 --> 00:09:25,029
against the draft coil endpoint it's a

00:09:23,060 --> 00:09:28,540
bit of a challenge there if you go

00:09:25,029 --> 00:09:31,759
function as a service wiring that up is

00:09:28,540 --> 00:09:33,620
challenging right so because function as

00:09:31,759 --> 00:09:35,089
a service doesn't maintain state and you

00:09:33,620 --> 00:09:39,379
don't actually have a physical server

00:09:35,089 --> 00:09:40,399
available to you all the time you have a

00:09:39,379 --> 00:09:41,930
little bit of problem when you're trying

00:09:40,399 --> 00:09:44,209
to establish a WebSocket connection all

00:09:41,930 --> 00:09:48,050
the way back to the client okay now

00:09:44,209 --> 00:09:49,310
there are ways to do this if you want to

00:09:48,050 --> 00:09:51,230
go down that approach where you're doing

00:09:49,310 --> 00:09:53,360
subscription if you need subscription

00:09:51,230 --> 00:09:54,319
and its function as a service you either

00:09:53,360 --> 00:09:59,060
handle it yourself

00:09:54,319 --> 00:10:02,089
or you can use an AWS framework called

00:09:59,060 --> 00:10:05,300
app sink so app sink will allow you to

00:10:02,089 --> 00:10:06,439
do subscriptions in AWS the AWS way so

00:10:05,300 --> 00:10:09,139
to you it's effectively you're

00:10:06,439 --> 00:10:10,550
interfacing with graph QL but it's

00:10:09,139 --> 00:10:12,980
actually done behind the scenes with a

00:10:10,550 --> 00:10:15,430
bunch of other weird and wonderful

00:10:12,980 --> 00:10:15,430
goodness

00:10:24,350 --> 00:10:29,339
yeah absolutely and yes right so for

00:10:27,960 --> 00:10:32,690
instance if we if we take the Facebook

00:10:29,339 --> 00:10:36,529
example supplying the newsfeed

00:10:32,690 --> 00:10:38,490
effectively to a client application

00:10:36,529 --> 00:10:41,640
there would be done obviously through a

00:10:38,490 --> 00:10:44,490
query and that mechanism is effectively

00:10:41,640 --> 00:10:48,720
to be done allows you to actually

00:10:44,490 --> 00:10:50,670
traverse that entire list and as well as

00:10:48,720 --> 00:10:52,440
it's all its relationships right in a

00:10:50,670 --> 00:10:55,670
simple way so typically what would

00:10:52,440 --> 00:10:59,400
happen as an example if I had a you know

00:10:55,670 --> 00:11:03,270
an article or a news item that appears

00:10:59,400 --> 00:11:05,580
on my Facebook wall that link could then

00:11:03,270 --> 00:11:07,050
effectively point to a news article on

00:11:05,580 --> 00:11:08,370
somebody else's wall and effectively you

00:11:07,050 --> 00:11:10,500
could go down the chain and end up three

00:11:08,370 --> 00:11:12,990
or four pages down and you keep going

00:11:10,500 --> 00:11:14,190
effectively and if you follow all that

00:11:12,990 --> 00:11:15,540
lit if you want to follow all that

00:11:14,190 --> 00:11:16,770
information you're effectively making

00:11:15,540 --> 00:11:18,839
all this multiple calls to the rest

00:11:16,770 --> 00:11:20,190
endpoint to you saying get me this get

00:11:18,839 --> 00:11:22,470
me this get me this get me this and you

00:11:20,190 --> 00:11:24,870
end up calling three or four things that

00:11:22,470 --> 00:11:26,520
still happens right but it happens

00:11:24,870 --> 00:11:27,779
behind the scenes so in graph QL

00:11:26,520 --> 00:11:29,880
typically what you would say is

00:11:27,779 --> 00:11:31,890
effectively give me my news feed and

00:11:29,880 --> 00:11:33,510
within my news feed I would like for

00:11:31,890 --> 00:11:35,760
instance all the related news feeds and

00:11:33,510 --> 00:11:38,630
it's effectively one query so what you

00:11:35,760 --> 00:11:41,520
get back as a JSON structure with the

00:11:38,630 --> 00:11:43,920
specific thing that you requested as

00:11:41,520 --> 00:11:45,360
well as any other sort of nested items

00:11:43,920 --> 00:11:48,660
that you also requested so you're fully

00:11:45,360 --> 00:11:50,220
in control as a developer and you're

00:11:48,660 --> 00:11:53,070
actually fully in control to such an

00:11:50,220 --> 00:11:55,980
extent that if the underlying graph QL

00:11:53,070 --> 00:11:57,540
changes for whatever reason so the graph

00:11:55,980 --> 00:11:59,910
Cal schema gets redefined and it decide

00:11:57,540 --> 00:12:00,300
to change a field they shouldn't but if

00:11:59,910 --> 00:12:01,890
they do

00:12:00,300 --> 00:12:03,570
you've actually got control from your

00:12:01,890 --> 00:12:05,160
client-side to go in there and rename

00:12:03,570 --> 00:12:07,410
that field as part of your query so you

00:12:05,160 --> 00:12:10,800
can actually say okay I would like to

00:12:07,410 --> 00:12:12,000
retrieve this person's first name but I

00:12:10,800 --> 00:12:12,959
don't want to call it first name I want

00:12:12,000 --> 00:12:15,900
to call it something else and in the

00:12:12,959 --> 00:12:17,130
JSON payload will return it to you in

00:12:15,900 --> 00:12:20,310
the sort of the format that you

00:12:17,130 --> 00:12:23,130
requested okay so when you do a query as

00:12:20,310 --> 00:12:24,540
well you can actually group things

00:12:23,130 --> 00:12:27,270
together for instance to say for

00:12:24,540 --> 00:12:28,560
instance you want to you have different

00:12:27,270 --> 00:12:30,630
types of notes with different types of

00:12:28,560 --> 00:12:33,030
importance in your app right so you've

00:12:30,630 --> 00:12:33,649
made a task list and you've got Priority

00:12:33,030 --> 00:12:35,509
One

00:12:33,649 --> 00:12:39,889
two priority three so you make a request

00:12:35,509 --> 00:12:42,110
and you can use and you can use graph

00:12:39,889 --> 00:12:44,540
kill to effectively say based on a

00:12:42,110 --> 00:12:47,269
condition to group those elements into

00:12:44,540 --> 00:12:49,189
Priority One requests not really

00:12:47,269 --> 00:12:51,709
important and you know just the normal

00:12:49,189 --> 00:12:53,740
run-of-the-mill type task does that make

00:12:51,709 --> 00:12:53,740
sense

00:12:55,269 --> 00:12:58,959
no absolutely not

00:13:01,089 --> 00:13:04,939
yes absolutely

00:13:02,839 --> 00:13:06,079
so they do we do we will get to a point

00:13:04,939 --> 00:13:08,569
where we say you have to think like a

00:13:06,079 --> 00:13:09,410
graph but it's not about query on graph

00:13:08,569 --> 00:13:11,119
database that's correct

00:13:09,410 --> 00:13:13,069
it's literally query anything in one of

00:13:11,119 --> 00:13:16,519
the demos they will step through and

00:13:13,069 --> 00:13:17,569
that I did earlier for a product that

00:13:16,519 --> 00:13:22,939
I'm trying to create with a friend of

00:13:17,569 --> 00:13:24,920
mine he we kind of live Ridge that

00:13:22,939 --> 00:13:28,160
functionality axis access a relational

00:13:24,920 --> 00:13:29,470
database yeah so it is some framework

00:13:28,160 --> 00:13:31,369
that does the heavy lifting for us and

00:13:29,470 --> 00:13:35,119
effectively what it does is it creates a

00:13:31,369 --> 00:13:37,129
graph QL ORM on top of your relational

00:13:35,119 --> 00:13:41,209
database to the point that it'll

00:13:37,129 --> 00:13:42,949
actually based on your schema it'll emit

00:13:41,209 --> 00:13:44,209
the entities into the database for you

00:13:42,949 --> 00:13:47,329
so that should create the database and

00:13:44,209 --> 00:13:51,699
everything okay so you're effectively

00:13:47,329 --> 00:13:55,100
doing entity framework code first okay

00:13:51,699 --> 00:13:57,589
then so when we meet a Shannara viously

00:13:55,100 --> 00:13:59,240
the same thing so it's an abstraction

00:13:57,589 --> 00:14:00,379
layer again you can do it on top of race

00:13:59,240 --> 00:14:01,670
you can do it on top of a relational

00:14:00,379 --> 00:14:04,069
database depending on the framework that

00:14:01,670 --> 00:14:06,199
you're using and effectively there take

00:14:04,069 --> 00:14:08,300
straight route takes care of your crud

00:14:06,199 --> 00:14:15,019
operations apart from the read obviously

00:14:08,300 --> 00:14:18,410
code if you will and so this is

00:14:15,019 --> 00:14:19,759
typically I've broken the interfaces up

00:14:18,410 --> 00:14:22,100
into what typically you would

00:14:19,759 --> 00:14:23,629
potentially see so I've not implemented

00:14:22,100 --> 00:14:25,279
the interface but this is effectively

00:14:23,629 --> 00:14:28,249
how you would define a type in JSON or

00:14:25,279 --> 00:14:35,079
not in JSON in graphic you are in your

00:14:28,249 --> 00:14:38,600
schema using the STL now the graph QL

00:14:35,079 --> 00:14:39,829
STL is actually quite limited in what it

00:14:38,600 --> 00:14:41,569
provides you right it actually only

00:14:39,829 --> 00:14:45,490
provides you a certain number of types

00:14:41,569 --> 00:14:45,490
so what's available to you is this

00:14:46,290 --> 00:14:51,779
so you've got in floats string beauty in

00:14:49,109 --> 00:14:56,579
an ID so I or pretty self-explanatory to

00:14:51,779 --> 00:14:58,229
an extent however you can actually use

00:14:56,579 --> 00:14:59,819
create your own types if we've done over

00:14:58,229 --> 00:15:02,279
here and you can use them in what we

00:14:59,819 --> 00:15:03,929
call the fields right so these are

00:15:02,279 --> 00:15:06,419
actually called fields and you can say

00:15:03,929 --> 00:15:11,039
for instance if I have children you can

00:15:06,419 --> 00:15:13,819
declare an array of person using very

00:15:11,039 --> 00:15:15,589
very similar race in text but not quite

00:15:13,819 --> 00:15:19,589
okay

00:15:15,589 --> 00:15:21,269
again we still only talking about schema

00:15:19,589 --> 00:15:23,489
definition so we don't have there's no

00:15:21,269 --> 00:15:25,499
code here there's no nothing happening

00:15:23,489 --> 00:15:30,019
it's literally I want to query something

00:15:25,499 --> 00:15:36,059
and this is what my end point looks like

00:15:30,019 --> 00:15:38,539
so this is what a typical query would

00:15:36,059 --> 00:15:44,549
look like so assuming we've defined and

00:15:38,539 --> 00:15:45,989
end point a graph QL method and call all

00:15:44,549 --> 00:15:47,939
persons we're effectively query like

00:15:45,989 --> 00:15:49,829
this so this is post right just a post

00:15:47,939 --> 00:15:51,269
request there's no magic to it you can

00:15:49,829 --> 00:15:54,539
use libraries from the client-side

00:15:51,269 --> 00:15:57,419
apollo's a particularly use we're in the

00:15:54,539 --> 00:15:59,160
world-renowned one if you will and you

00:15:57,419 --> 00:16:01,949
don't need to in the projects that I've

00:15:59,160 --> 00:16:04,889
worked or in the past we haven't purely

00:16:01,949 --> 00:16:06,449
because it doesn't kind of line up with

00:16:04,889 --> 00:16:09,359
expectations so what we were trying to

00:16:06,449 --> 00:16:11,100
do was find an easy way of doing a query

00:16:09,359 --> 00:16:12,629
against the graph backend without having

00:16:11,100 --> 00:16:15,779
to know graph QL that's what we were

00:16:12,629 --> 00:16:17,730
expecting to do from the client side we

00:16:15,779 --> 00:16:19,649
never really got there and always ends

00:16:17,730 --> 00:16:20,999
up being string so it's kind of easy to

00:16:19,649 --> 00:16:22,859
compose a string yourself and send it

00:16:20,999 --> 00:16:24,569
across the wire and you know then you've

00:16:22,859 --> 00:16:27,539
got full control obviously the string

00:16:24,569 --> 00:16:28,829
composition is interesting so you just

00:16:27,539 --> 00:16:32,069
need to make sure that everything's

00:16:28,829 --> 00:16:35,369
gonna lie on for you it can also be all

00:16:32,069 --> 00:16:36,689
exposed as a get method but typically if

00:16:35,369 --> 00:16:39,779
you're doing post at your post for

00:16:36,689 --> 00:16:41,579
everything it's very straightforward so

00:16:39,779 --> 00:16:44,220
what we've effectively got here as we're

00:16:41,579 --> 00:16:46,799
saying we want to return and all the

00:16:44,220 --> 00:16:48,959
persons or people and that will invoke a

00:16:46,799 --> 00:16:50,519
resolver function within the framework

00:16:48,959 --> 00:16:52,979
eventually once we get to that point and

00:16:50,519 --> 00:16:56,069
we specify what we want to retrieve so

00:16:52,979 --> 00:17:00,619
in this case we've got a name it was an

00:16:56,069 --> 00:17:00,619
example right so previously

00:17:00,660 --> 00:17:05,790
we defined all of these so you could

00:17:02,850 --> 00:17:07,290
pick anything right any of those

00:17:05,790 --> 00:17:08,550
elements and this is what this is where

00:17:07,290 --> 00:17:10,530
the power of graph Cal comes in is that

00:17:08,550 --> 00:17:12,780
you as the court client you decide what

00:17:10,530 --> 00:17:14,339
you want to get yep so it means you're

00:17:12,780 --> 00:17:15,960
not getting stuff that the developer

00:17:14,339 --> 00:17:16,710
thought you needed you're not getting

00:17:15,960 --> 00:17:19,350
what you want

00:17:16,710 --> 00:17:21,510
which obviously reduces the payload if

00:17:19,350 --> 00:17:22,950
you have any child relationships instead

00:17:21,510 --> 00:17:24,870
of that getting an array back that says

00:17:22,950 --> 00:17:26,490
you need to hit this wrist end point and

00:17:24,870 --> 00:17:28,110
this wrist end point you're effectively

00:17:26,490 --> 00:17:31,110
just getting that data through because

00:17:28,110 --> 00:17:34,290
in the same way that you have this

00:17:31,110 --> 00:17:35,910
particular query if you had children in

00:17:34,290 --> 00:17:37,770
here for instance you could have just

00:17:35,910 --> 00:17:39,990
effectively selected children in the

00:17:37,770 --> 00:17:44,010
same way you've got persons there and

00:17:39,990 --> 00:17:46,020
you would have been able to specify name

00:17:44,010 --> 00:17:47,190
as well and then that way you would have

00:17:46,020 --> 00:17:49,230
actually got all the name of the

00:17:47,190 --> 00:17:51,090
children without having to make

00:17:49,230 --> 00:17:53,550
subsequent requests behind the scenes

00:17:51,090 --> 00:18:01,530
again it's still going off in your own

00:17:53,550 --> 00:18:08,480
network and pulling all the stuff ok so

00:18:01,530 --> 00:18:11,850
just some terminology root field payload

00:18:08,480 --> 00:18:13,140
from a query perspective ok so you if

00:18:11,850 --> 00:18:14,610
you see a root field anywhere they were

00:18:13,140 --> 00:18:17,220
referring to that and that's effectively

00:18:14,610 --> 00:18:18,600
what we call the payload ok the payload

00:18:17,220 --> 00:18:20,640
is until you'll control your fixedly

00:18:18,600 --> 00:18:24,720
choose what you want the end result of

00:18:20,640 --> 00:18:28,710
your query is that ok

00:18:24,720 --> 00:18:31,440
so returns JSON so it's not problematic

00:18:28,710 --> 00:18:36,180
the query slightly Jason like but not

00:18:31,440 --> 00:18:38,100
point so you're all persons returns an

00:18:36,180 --> 00:18:41,120
array and then because we've selected

00:18:38,100 --> 00:18:42,330
name we can get to people out of it

00:18:41,120 --> 00:18:44,340
right

00:18:42,330 --> 00:18:45,780
it typically the results are always like

00:18:44,340 --> 00:18:49,520
this it's effectively your route field

00:18:45,780 --> 00:18:49,520
and then your selected payload

00:18:59,390 --> 00:19:06,000
all right so the other thing that you

00:19:02,640 --> 00:19:07,620
can do is effectively add parameters to

00:19:06,000 --> 00:19:10,140
your query so you can do pagination and

00:19:07,620 --> 00:19:11,490
things like that typically you can say I

00:19:10,140 --> 00:19:14,820
would like the first three or last three

00:19:11,490 --> 00:19:17,760
you can specify those yourself you don't

00:19:14,820 --> 00:19:19,770
actually they're not given to you again

00:19:17,760 --> 00:19:21,630
it's just a metal way of invoking that

00:19:19,770 --> 00:19:23,010
when you make the request to a resolver

00:19:21,630 --> 00:19:24,660
you then have to handle that

00:19:23,010 --> 00:19:28,080
functionality it's not going to give

00:19:24,660 --> 00:19:30,380
that to you yeah it's just saying these

00:19:28,080 --> 00:19:32,640
are some parameters I want to do a query

00:19:30,380 --> 00:19:38,670
and these are the parameters for that

00:19:32,640 --> 00:19:42,360
query okay when you define your API or

00:19:38,670 --> 00:19:44,100
your schema you have to actually define

00:19:42,360 --> 00:19:47,300
that as well it's not it's not given to

00:19:44,100 --> 00:20:00,860
you so there's no default if you will

00:19:47,300 --> 00:20:08,250
okay so these this is another concept

00:20:00,860 --> 00:20:10,020
within this called a fragment right we

00:20:08,250 --> 00:20:13,920
still have a query and a fragment is

00:20:10,020 --> 00:20:15,720
basically how we would like a way of

00:20:13,920 --> 00:20:18,720
sharing how we would like the data to be

00:20:15,720 --> 00:20:20,280
returned right obviously all the types

00:20:18,720 --> 00:20:24,240
have to be the same so because we've got

00:20:20,280 --> 00:20:27,050
a type of person that is being returned

00:20:24,240 --> 00:20:29,670
from the query both of these queries

00:20:27,050 --> 00:20:31,260
return person that one's got a parameter

00:20:29,670 --> 00:20:34,200
that says I want the first three

00:20:31,260 --> 00:20:36,900
elements yep because they're both type

00:20:34,200 --> 00:20:39,270
person it's going to obviously return

00:20:36,900 --> 00:20:41,670
the name for both and this is what I was

00:20:39,270 --> 00:20:43,710
saying to you about aliases where you

00:20:41,670 --> 00:20:45,270
can say for instance I'll get a payload

00:20:43,710 --> 00:20:46,800
that says these are all of the elements

00:20:45,270 --> 00:20:48,810
and these are the first three and we'll

00:20:46,800 --> 00:20:51,060
actually separate them out you can do

00:20:48,810 --> 00:20:52,800
that for individual elements so or for

00:20:51,060 --> 00:20:55,040
individual fields if you will so if you

00:20:52,800 --> 00:20:58,350
wanted to for instance change name to

00:20:55,040 --> 00:21:00,090
nickname you effectively say nickname

00:20:58,350 --> 00:21:02,190
colon name and it would rename that so

00:21:00,090 --> 00:21:05,910
your payload when it's returned you've

00:21:02,190 --> 00:21:07,530
effectively got nickname as the value

00:21:05,910 --> 00:21:10,080
that you're looking for which is really

00:21:07,530 --> 00:21:11,760
good if you're potentially moving from

00:21:10,080 --> 00:21:14,820
an API

00:21:11,760 --> 00:21:16,380
for instance your foursome if some

00:21:14,820 --> 00:21:18,660
interesting reason you connected to

00:21:16,380 --> 00:21:20,430
Twitter and now you want to go via this

00:21:18,660 --> 00:21:21,750
weird graph to your API that somebody

00:21:20,430 --> 00:21:23,010
else has developed but you don't really

00:21:21,750 --> 00:21:24,240
want to change all the references that

00:21:23,010 --> 00:21:25,860
you've got in your user interface to all

00:21:24,240 --> 00:21:29,130
these objects you can effectively use

00:21:25,860 --> 00:21:30,750
aliasing to resolve that problem so your

00:21:29,130 --> 00:21:34,170
user interface can remain the same if

00:21:30,750 --> 00:21:44,370
you're binding to specific fields your

00:21:34,170 --> 00:21:48,540
properties right talked about alias and

00:21:44,370 --> 00:21:50,690
fragments and variables and directives I

00:21:48,540 --> 00:21:54,180
won't go too much into detail about

00:21:50,690 --> 00:21:56,250
variables don't really don't really

00:21:54,180 --> 00:21:57,540
actually use them much because I think

00:21:56,250 --> 00:22:00,150
if you're doing a query you can just

00:21:57,540 --> 00:22:02,760
compose on-the-fly what it allows you to

00:22:00,150 --> 00:22:05,100
is effectively to set variables in your

00:22:02,760 --> 00:22:07,740
query and effectively have variables

00:22:05,100 --> 00:22:10,670
down here that you can submit as part of

00:22:07,740 --> 00:22:13,860
your query so you can do a bit like

00:22:10,670 --> 00:22:15,840
binding if you all on the fly so you

00:22:13,860 --> 00:22:18,150
said these are my parameters for all of

00:22:15,840 --> 00:22:19,380
these queries and off it goes so you

00:22:18,150 --> 00:22:22,290
could potentially have used a variable

00:22:19,380 --> 00:22:24,210
over here as an example if you had you

00:22:22,290 --> 00:22:25,530
know first three and last three because

00:22:24,210 --> 00:22:27,030
you have 20 of them and you only wanted

00:22:25,530 --> 00:22:31,410
the first and LA first three and last

00:22:27,030 --> 00:22:32,520
three and I mean to be returned the

00:22:31,410 --> 00:22:35,010
interesting one that we also then have

00:22:32,520 --> 00:22:38,040
is directives I don't know why they call

00:22:35,010 --> 00:22:39,510
it that but you've basically got include

00:22:38,040 --> 00:22:41,670
and skip and those are conditional

00:22:39,510 --> 00:22:44,550
elements so what you can do is you can

00:22:41,670 --> 00:22:50,190
say for instance I would like to include

00:22:44,550 --> 00:22:54,350
only elements that resolve to true for

00:22:50,190 --> 00:22:57,060
instance so if you've got you know

00:22:54,350 --> 00:22:59,760
blu-ray or DVD for instance in your

00:22:57,060 --> 00:23:01,800
movie catalog and you were returning

00:22:59,760 --> 00:23:04,110
blu-ray or DVD you could effectively say

00:23:01,800 --> 00:23:07,260
for this top section here I would like

00:23:04,110 --> 00:23:09,600
to include blu-ray and for the bottom

00:23:07,260 --> 00:23:10,710
section I would like to skip blu-ray and

00:23:09,600 --> 00:23:13,140
it's effectively you're effectively

00:23:10,710 --> 00:23:16,070
doing a comparison on the property type

00:23:13,140 --> 00:23:16,070
yeah

00:23:17,750 --> 00:23:28,690
any questions nope good to go and this

00:23:25,190 --> 00:23:35,570
is the interesting but it's a mutations

00:23:28,690 --> 00:23:37,010
so and this is where mutations are

00:23:35,570 --> 00:23:38,390
particularly interesting notice that the

00:23:37,010 --> 00:23:39,830
difference in terms of the query

00:23:38,390 --> 00:23:41,540
mechanisms that you specify that you're

00:23:39,830 --> 00:23:43,820
doing a mutation you can specify that

00:23:41,540 --> 00:23:46,220
you're doing a query as well yeah

00:23:43,820 --> 00:23:48,170
the syntax that we saw earlier was

00:23:46,220 --> 00:23:50,120
shorthand so the default with graph QL

00:23:48,170 --> 00:23:51,590
is query so you don't have to specify

00:23:50,120 --> 00:23:55,250
that you're actually executing a query

00:23:51,590 --> 00:24:01,340
okay the mutation as we see it is

00:23:55,250 --> 00:24:04,790
effectively your create update and

00:24:01,340 --> 00:24:06,650
delete mechanisms again its convention

00:24:04,790 --> 00:24:08,870
because you call the create doesn't

00:24:06,650 --> 00:24:10,670
necessarily mean it's going to create in

00:24:08,870 --> 00:24:12,890
the same way that effectively when you

00:24:10,670 --> 00:24:14,450
make this request to your graphic your

00:24:12,890 --> 00:24:16,660
endpoint behind the scenes all you're

00:24:14,450 --> 00:24:18,350
going to get is in your resolver

00:24:16,660 --> 00:24:19,910
function is you're gonna get some

00:24:18,350 --> 00:24:21,080
context and it's gotta pass these two

00:24:19,910 --> 00:24:22,370
properties through in and you're going

00:24:21,080 --> 00:24:24,050
to do whatever it is that you want to do

00:24:22,370 --> 00:24:26,690
with those right so there's no magic

00:24:24,050 --> 00:24:29,510
it's literally the person requested this

00:24:26,690 --> 00:24:31,820
here's a some JSON context or some

00:24:29,510 --> 00:24:34,340
context for your variable and you've got

00:24:31,820 --> 00:24:37,550
two properties on their name and age and

00:24:34,340 --> 00:24:39,380
you can do whatever you like right so if

00:24:37,550 --> 00:24:41,030
you wanted to do an update operation

00:24:39,380 --> 00:24:44,990
similar kind of functionality you

00:24:41,030 --> 00:24:46,460
typically include an ID and if you

00:24:44,990 --> 00:24:48,230
wanted to delete you do that ID with

00:24:46,460 --> 00:24:49,430
nothing else and the important thing to

00:24:48,230 --> 00:24:52,520
note as you've all seen you've still got

00:24:49,430 --> 00:24:55,750
a payload over here so the cool thing is

00:24:52,520 --> 00:24:57,800
if you make a request to a create an AP

00:24:55,750 --> 00:24:59,840
entity if you will where it really is

00:24:57,800 --> 00:25:01,160
that you want to create it you have the

00:24:59,840 --> 00:25:04,790
opportunity at this point to return the

00:25:01,160 --> 00:25:06,530
ID in a single hit what so you're not

00:25:04,790 --> 00:25:09,140
going backwards and forwards you could

00:25:06,530 --> 00:25:11,210
extend that and say refresh all of my

00:25:09,140 --> 00:25:13,400
data so you could have pulled you know

00:25:11,210 --> 00:25:16,550
if this again if you had create person

00:25:13,400 --> 00:25:18,710
or you had update person and you changed

00:25:16,550 --> 00:25:21,530
that person's name because I don't know

00:25:18,710 --> 00:25:22,670
you wanted to you could return that

00:25:21,530 --> 00:25:24,410
person and then also include the

00:25:22,670 --> 00:25:27,290
children so effectively this point here

00:25:24,410 --> 00:25:29,410
is doing a query alongside doing the

00:25:27,290 --> 00:25:31,520
actual mutation as well so you can do a

00:25:29,410 --> 00:25:32,600
retrieve operation there

00:25:31,520 --> 00:25:35,540
sort of create operation at the same

00:25:32,600 --> 00:25:39,710
time again the whole point behind is

00:25:35,540 --> 00:25:41,540
reducing Network round trips keeping the

00:25:39,710 --> 00:25:48,080
payload low and effectively just

00:25:41,540 --> 00:25:50,000
reducing data transfer on the whole the

00:25:48,080 --> 00:25:54,140
end result of that particular query is

00:25:50,000 --> 00:25:56,330
that okay again it's the same thing

00:25:54,140 --> 00:25:58,910
notice that you've got your route field

00:25:56,330 --> 00:26:00,350
which is basically what you requested

00:25:58,910 --> 00:26:14,210
and then this is the data that comes

00:26:00,350 --> 00:26:17,480
back for that particular entity that's

00:26:14,210 --> 00:26:18,890
the route field yep so if you go back to

00:26:17,480 --> 00:26:21,680
the previous thing so it's always called

00:26:18,890 --> 00:26:23,240
route field and payload so this is

00:26:21,680 --> 00:26:30,800
always called route field there

00:26:23,240 --> 00:26:32,990
typically is payload then we run two

00:26:30,800 --> 00:26:35,180
subscriptions and the subscription

00:26:32,990 --> 00:26:37,790
mechanism is effectively to find this

00:26:35,180 --> 00:26:40,370
way you make a request

00:26:37,790 --> 00:26:43,250
they'll be route field called new person

00:26:40,370 --> 00:26:44,420
you'll specify name in age and

00:26:43,250 --> 00:26:47,860
effectively what will happen is as

00:26:44,420 --> 00:26:52,190
people insert things into your graph QL

00:26:47,860 --> 00:26:55,070
service or update or delete you should

00:26:52,190 --> 00:26:56,930
get a notification okay not all

00:26:55,070 --> 00:26:58,400
framework supports it so you need to be

00:26:56,930 --> 00:26:59,990
conscious of that depending on whether

00:26:58,400 --> 00:27:02,230
you get gained whether you choose to go

00:26:59,990 --> 00:27:07,940
down the function as a service route or

00:27:02,230 --> 00:27:09,260
the container route you obviously have

00:27:07,940 --> 00:27:16,040
to handle things differently

00:27:09,260 --> 00:27:17,450
okay again so AWS has got the app sync

00:27:16,040 --> 00:27:19,940
which actually gives you a lot of this

00:27:17,450 --> 00:27:21,020
functionality I'm not going to go into

00:27:19,940 --> 00:27:25,070
too much detail about that because I

00:27:21,020 --> 00:27:26,540
find it not great but again route fill

00:27:25,070 --> 00:27:33,590
and payload it's always the same kind of

00:27:26,540 --> 00:27:46,250
thing and that's the response okay

00:27:33,590 --> 00:27:51,020
oh that's a typo my apologies right so

00:27:46,250 --> 00:27:53,270
this is your typical it's a steel file

00:27:51,020 --> 00:27:54,919
if you autograph your phone so this is

00:27:53,270 --> 00:27:56,450
how you define you effectively they all

00:27:54,919 --> 00:27:59,419
have to have these types of these root

00:27:56,450 --> 00:28:03,049
types effectively define what they are

00:27:59,419 --> 00:28:04,429
allowed to do effectively so if your

00:28:03,049 --> 00:28:07,429
endpoint doesn't have to have all of

00:28:04,429 --> 00:28:10,580
them okay but whenever you execute a

00:28:07,429 --> 00:28:12,919
query against a graphical endpoint it'll

00:28:10,580 --> 00:28:14,510
look for the effectively the resolver

00:28:12,919 --> 00:28:17,600
functions and here notice this is the

00:28:14,510 --> 00:28:20,929
old person's method that we requested

00:28:17,600 --> 00:28:24,260
previously and it's got a parameter and

00:28:20,929 --> 00:28:26,029
it returns an array of person and that's

00:28:24,260 --> 00:28:28,399
the square brackets intact that looks

00:28:26,029 --> 00:28:30,770
like an array but quite so typically

00:28:28,399 --> 00:28:31,909
what you do is you can do things and no

00:28:30,770 --> 00:28:33,770
no so you'll get you can get a JSON

00:28:31,909 --> 00:28:36,049
response so you could do what is called

00:28:33,770 --> 00:28:38,779
a union so a union means that when you

00:28:36,049 --> 00:28:40,640
return a person for instance you could

00:28:38,779 --> 00:28:41,919
return a personal error so you could

00:28:40,640 --> 00:28:44,840
potentially return two different types

00:28:41,919 --> 00:28:45,980
okay wasn't there to go into details of

00:28:44,840 --> 00:28:47,240
unions but that's typically how you

00:28:45,980 --> 00:28:48,529
would use that so effectively what would

00:28:47,240 --> 00:28:50,600
happen as you make a request something

00:28:48,529 --> 00:28:53,419
that's wrong instead of throwing up and

00:28:50,600 --> 00:28:55,279
saying error 500 which is probably not

00:28:53,419 --> 00:28:57,039
good from a security perspective because

00:28:55,279 --> 00:29:00,710
then they could just keep hacking you

00:28:57,039 --> 00:29:02,059
you would say handle the error return of

00:29:00,710 --> 00:29:03,830
200 but would potentially return an

00:29:02,059 --> 00:29:08,799
error message the two types would be

00:29:03,830 --> 00:29:12,350
then slightly different okay yes yes

00:29:08,799 --> 00:29:13,820
yeah absolutely that's right so that's

00:29:12,350 --> 00:29:16,880
why there is anyone on there so you can

00:29:13,820 --> 00:29:18,740
invoke so with with graph QL you get a

00:29:16,880 --> 00:29:20,090
thing called introspection so you

00:29:18,740 --> 00:29:24,230
remember in these soak days you used to

00:29:20,090 --> 00:29:26,059
have wisdom graph Cal gives you that yep

00:29:24,230 --> 00:29:28,130
completely discoverable so you don't

00:29:26,059 --> 00:29:29,539
actually have to tell anyone how to use

00:29:28,130 --> 00:29:31,520
your API they should be able to discover

00:29:29,539 --> 00:29:33,100
how they works by themselves obviously

00:29:31,520 --> 00:29:35,330
that causes a number of issues

00:29:33,100 --> 00:29:38,059
especially around how deep do you go

00:29:35,330 --> 00:29:42,050
down the graph when you can traverse in

00:29:38,059 --> 00:29:43,790
both directions right okay

00:29:42,050 --> 00:29:45,200
so create person obviously we need a

00:29:43,790 --> 00:29:49,250
name in a string and returns a person

00:29:45,200 --> 00:29:53,150
and then we had the subscription for new

00:29:49,250 --> 00:29:54,350
person and then we've got a the person

00:29:53,150 --> 00:29:55,790
type which is what we're using up here

00:29:54,350 --> 00:29:57,890
that looks like you're different to the

00:29:55,790 --> 00:30:00,230
other one but kind of highlights the

00:29:57,890 --> 00:30:02,480
point okay

00:30:00,230 --> 00:30:05,240
this would typically be in a string and

00:30:02,480 --> 00:30:08,720
you would use some graphical

00:30:05,240 --> 00:30:12,380
heavy-lifting frameworks to convert this

00:30:08,720 --> 00:30:14,450
or to map this into something that you

00:30:12,380 --> 00:30:16,460
could execute okay and that's

00:30:14,450 --> 00:30:18,320
effectively what will turn this into

00:30:16,460 --> 00:30:24,890
resolvers now depending on the framework

00:30:18,320 --> 00:30:27,410
that you use you may or may not do more

00:30:24,890 --> 00:30:29,390
heavy lifting than you would like so if

00:30:27,410 --> 00:30:32,360
if we start talking about frameworks as

00:30:29,390 --> 00:30:34,280
an example and the defect or the default

00:30:32,360 --> 00:30:36,550
or the starting point for most things is

00:30:34,280 --> 00:30:38,510
what Facebook released its graph Cal j/s

00:30:36,550 --> 00:30:42,350
in the near graph QL server

00:30:38,510 --> 00:30:44,180
implementation it doesn't do very much

00:30:42,350 --> 00:30:46,670
heavy lifting for you so you have to do

00:30:44,180 --> 00:30:50,870
a lot of stuff yourself there is a tool

00:30:46,670 --> 00:30:53,420
or in a package called graph Cal tools

00:30:50,870 --> 00:30:55,420
it does help you with the heavy lifting

00:30:53,420 --> 00:31:05,450
and we'll go into some of that detail

00:30:55,420 --> 00:31:06,620
later on okay so we're at the point now

00:31:05,450 --> 00:31:09,740
we were going to start talking about

00:31:06,620 --> 00:31:11,930
sort of best practices for your schema

00:31:09,740 --> 00:31:14,420
right so naming matters don't rename

00:31:11,930 --> 00:31:16,550
everything okay there's no versioning

00:31:14,420 --> 00:31:18,530
right so where we typically in rest and

00:31:16,550 --> 00:31:21,050
you can version but typically you don't

00:31:18,530 --> 00:31:22,850
so we're in rest you could just say I've

00:31:21,050 --> 00:31:27,590
released a new version of my API here's

00:31:22,850 --> 00:31:30,590
my new my new fields that kind of goes

00:31:27,590 --> 00:31:33,020
away with this this is about creating an

00:31:30,590 --> 00:31:34,550
API that you can evolve constantly yeah

00:31:33,020 --> 00:31:35,150
it has its benefits it also has its

00:31:34,550 --> 00:31:38,030
drawbacks

00:31:35,150 --> 00:31:40,850
right don't think eight points think

00:31:38,030 --> 00:31:44,600
graph so just assume that everybody's

00:31:40,850 --> 00:31:46,220
going to traverse your graph as much as

00:31:44,600 --> 00:31:49,870
they want right and that obviously plays

00:31:46,220 --> 00:31:52,550
creates challenges in terms of you know

00:31:49,870 --> 00:31:53,780
English looping for example where you

00:31:52,550 --> 00:31:55,430
could end up potentially blowing the

00:31:53,780 --> 00:31:57,290
memory out of your

00:31:55,430 --> 00:31:58,970
lambda function or yours your function

00:31:57,290 --> 00:31:59,450
if you've consumed too much in your

00:31:58,970 --> 00:32:00,800
stack

00:31:59,450 --> 00:32:04,100
he's a good potentially end up with

00:32:00,800 --> 00:32:06,590
Stack Overflow exceptions describe the

00:32:04,100 --> 00:32:10,070
data not the view right and that's kind

00:32:06,590 --> 00:32:12,050
of linked into that so typically what

00:32:10,070 --> 00:32:15,080
people would do historically obviously

00:32:12,050 --> 00:32:16,850
let's say historically and is you would

00:32:15,080 --> 00:32:19,130
say you've got your view model this is

00:32:16,850 --> 00:32:22,340
my view I want to make my view model

00:32:19,130 --> 00:32:24,650
represent my view that goes away

00:32:22,340 --> 00:32:28,520
you need two T's to see things from the

00:32:24,650 --> 00:32:29,960
consumer it's not about how it's all

00:32:28,520 --> 00:32:31,130
about you dictating how your consumer

00:32:29,960 --> 00:32:32,540
will use your API it's about

00:32:31,130 --> 00:32:35,150
understanding what they could

00:32:32,540 --> 00:32:37,700
potentially do yep so you have to always

00:32:35,150 --> 00:32:39,290
consider what is the what is it that I'm

00:32:37,700 --> 00:32:41,120
trying to build for always do it based

00:32:39,290 --> 00:32:42,410
on a requirement don't try to come up

00:32:41,120 --> 00:32:45,980
with things yourself because you've got

00:32:42,410 --> 00:32:47,420
to come an evolving API that doesn't

00:32:45,980 --> 00:32:49,460
really require versioning you can

00:32:47,420 --> 00:32:51,680
constantly evolve so from a starting

00:32:49,460 --> 00:32:53,570
point you know you can say this is what

00:32:51,680 --> 00:32:55,070
it looks like now and then decide a week

00:32:53,570 --> 00:32:56,150
later because the new requirements come

00:32:55,070 --> 00:32:57,860
in that you want to add an additional

00:32:56,150 --> 00:33:00,500
field and provided you don't change the

00:32:57,860 --> 00:33:02,270
existing fields then you've got no

00:33:00,500 --> 00:33:05,570
breaking changes unless you've

00:33:02,270 --> 00:33:07,340
introduced ability of code graph

00:33:05,570 --> 00:33:14,360
cureless then right it doesn't actually

00:33:07,340 --> 00:33:16,760
do very much and enterprise type things

00:33:14,360 --> 00:33:18,770
like authentication and authorization is

00:33:16,760 --> 00:33:20,030
not part of the graph chaos bag right so

00:33:18,770 --> 00:33:22,520
you have to handle that yourself and

00:33:20,030 --> 00:33:25,460
there's do's and don'ts about how you

00:33:22,520 --> 00:33:31,130
should derd it's mostly pragmatic

00:33:25,460 --> 00:33:33,350
approach how you want to do it and we'll

00:33:31,130 --> 00:33:36,500
talk about that in a while as well and

00:33:33,350 --> 00:33:39,200
the hiding the implementation details

00:33:36,500 --> 00:33:40,580
right don't show people your database

00:33:39,200 --> 00:33:42,230
effectively that's what that boils down

00:33:40,580 --> 00:33:43,400
to don't expose an API that's tightly

00:33:42,230 --> 00:33:45,320
coupled to your database so that when

00:33:43,400 --> 00:33:47,740
you make database changes you end up

00:33:45,320 --> 00:33:52,580
with changes all the way up the stack

00:33:47,740 --> 00:33:53,630
okay focus more on domain models then

00:33:52,580 --> 00:33:55,460
try to abstract that these are just

00:33:53,630 --> 00:33:58,280
normal practices right this is not

00:33:55,460 --> 00:34:03,590
anything shouldn't be anything new it's

00:33:58,280 --> 00:34:07,929
mostly to reduce coupling okay when

00:34:03,590 --> 00:34:10,220
building your API do you consider the

00:34:07,929 --> 00:34:12,860
your consumer is but obviously don't

00:34:10,220 --> 00:34:14,630
restrict it to specific client type yeah

00:34:12,860 --> 00:34:16,370
so don't think this is only going to

00:34:14,630 --> 00:34:18,050
work this ne has to work for react so

00:34:16,370 --> 00:34:20,990
therefore my ap on I need to make sure

00:34:18,050 --> 00:34:22,100
that it's react compliant if you use the

00:34:20,990 --> 00:34:25,130
heavy lifting frame which you don't have

00:34:22,100 --> 00:34:27,500
to worry about that but typically just

00:34:25,130 --> 00:34:30,470
make sure you're thinking more about you

00:34:27,500 --> 00:34:32,750
know it could be on a desktop it could

00:34:30,470 --> 00:34:35,510
be on a mobile it could be you know on a

00:34:32,750 --> 00:34:37,250
tele if you want and consider those

00:34:35,510 --> 00:34:39,770
potential use cases based on that one

00:34:37,250 --> 00:34:41,360
specific problem okay and it's mostly

00:34:39,770 --> 00:34:43,610
around not restricting the amount of

00:34:41,360 --> 00:34:46,280
data you can actually share with your

00:34:43,610 --> 00:34:47,450
consumer purely because the consumer is

00:34:46,280 --> 00:34:48,710
in control of what they want to get so

00:34:47,450 --> 00:35:01,340
you could actually give them everything

00:34:48,710 --> 00:35:03,140
and then let them decide okay so this is

00:35:01,340 --> 00:35:05,600
what works this is if you want to use

00:35:03,140 --> 00:35:09,800
this in your workplace or in your

00:35:05,600 --> 00:35:13,100
personal hobby project find a client if

00:35:09,800 --> 00:35:14,180
you're your own client rocking typically

00:35:13,100 --> 00:35:20,060
you need to embed yourself within a team

00:35:14,180 --> 00:35:22,580
with a BB the the reason for that is

00:35:20,060 --> 00:35:23,900
because it's actually a mind shift and

00:35:22,580 --> 00:35:25,070
some people get it and some people don't

00:35:23,900 --> 00:35:26,210
and that's fine and some people take a

00:35:25,070 --> 00:35:30,620
little bit longer to get it and that's

00:35:26,210 --> 00:35:32,120
okay too but you actually you can't

00:35:30,620 --> 00:35:33,380
really do this yourself and you can sit

00:35:32,120 --> 00:35:35,840
then wave your flag as much as you want

00:35:33,380 --> 00:35:39,320
I've tried it doesn't work you have to

00:35:35,840 --> 00:35:41,210
find the right project we did I was

00:35:39,320 --> 00:35:42,590
already part of that team and then it

00:35:41,210 --> 00:35:43,880
was all about incremental adoption and

00:35:42,590 --> 00:35:46,250
that's what I was saying to you when you

00:35:43,880 --> 00:35:50,540
come across we started with rest we

00:35:46,250 --> 00:35:51,710
moved to graph QL we didn't go and say

00:35:50,540 --> 00:35:52,910
okay cool now we're going to do graphic

00:35:51,710 --> 00:35:55,690
you're going to change everything and

00:35:52,910 --> 00:35:58,400
we're going to just get rid of all the

00:35:55,690 --> 00:36:00,740
create update and delete operations and

00:35:58,400 --> 00:36:04,400
we're going to just do everything in

00:36:00,740 --> 00:36:06,740
graph QL now the queries um is where it

00:36:04,400 --> 00:36:07,730
had really actually added a lot of value

00:36:06,740 --> 00:36:11,180
for us because we were basically

00:36:07,730 --> 00:36:12,560
providing an API and what happened for

00:36:11,180 --> 00:36:14,660
us was effectively we were returning a

00:36:12,560 --> 00:36:16,220
ton of data to the client that they

00:36:14,660 --> 00:36:20,390
didn't need so was blowing up the page

00:36:16,220 --> 00:36:21,160
um with graph QL we were able to reduce

00:36:20,390 --> 00:36:23,230
that pain

00:36:21,160 --> 00:36:25,119
and reuse the same queries and then

00:36:23,230 --> 00:36:26,200
depending on which area we were in we

00:36:25,119 --> 00:36:29,140
could actually choose to consume

00:36:26,200 --> 00:36:30,490
different data okay so it gave us a

00:36:29,140 --> 00:36:32,230
piecemeal approach with a single

00:36:30,490 --> 00:36:34,270
endpoint right and we were able to

00:36:32,230 --> 00:36:41,799
choose the shape of that data as we were

00:36:34,270 --> 00:36:48,309
using it okay the important things to

00:36:41,799 --> 00:36:49,480
consider are around and in terms of

00:36:48,309 --> 00:36:51,250
increments of adoption is allowing the

00:36:49,480 --> 00:36:53,799
things to coexist right so you've got

00:36:51,250 --> 00:36:55,539
your rest endpoints and let them be

00:36:53,799 --> 00:36:59,770
there's no reason why you have to get

00:36:55,539 --> 00:37:01,869
rid then right we found scenarios we've

00:36:59,770 --> 00:37:05,309
left ours intact as well so we've got

00:37:01,869 --> 00:37:07,539
rest endpoints graph Cal endpoints and

00:37:05,309 --> 00:37:09,369
the mutations as well as part of this

00:37:07,539 --> 00:37:10,869
graph Cal endpoints we typically prefer

00:37:09,369 --> 00:37:12,160
people to use the graph curl but we

00:37:10,869 --> 00:37:15,400
haven't got we haven't basically

00:37:12,160 --> 00:37:17,559
disenfranchised an entire community if

00:37:15,400 --> 00:37:19,839
you will the reason we needed to provide

00:37:17,559 --> 00:37:21,099
api's to third party so we are

00:37:19,839 --> 00:37:23,020
preferences for them to use graft cure

00:37:21,099 --> 00:37:25,990
because it's richer sitting is less load

00:37:23,020 --> 00:37:30,190
for us from a you know connection

00:37:25,990 --> 00:37:31,329
perspective but allow people to decide

00:37:30,190 --> 00:37:32,529
how they want to use it and if you

00:37:31,329 --> 00:37:34,240
started with race there's no reason to

00:37:32,529 --> 00:37:37,119
decommission it over time you'll have to

00:37:34,240 --> 00:37:38,799
duplicate it because you can't maintain

00:37:37,119 --> 00:37:42,910
you can't effectively continue to

00:37:38,799 --> 00:37:44,890
maintain both all right then you ideally

00:37:42,910 --> 00:37:46,619
want to have a single source single

00:37:44,890 --> 00:37:48,880
entry point from a security perspective

00:37:46,619 --> 00:37:52,170
kind of keeps your security tighter that

00:37:48,880 --> 00:38:08,010
way okay

00:37:52,170 --> 00:38:09,300
now typical use cases so graph QL can be

00:38:08,010 --> 00:38:11,940
seen as two of these things data access

00:38:09,300 --> 00:38:13,350
layer in Apr composition when we go

00:38:11,940 --> 00:38:15,540
through the demo shortly hopefully after

00:38:13,350 --> 00:38:19,200
the break to think we're nearing that

00:38:15,540 --> 00:38:20,640
and we will cover them in the reverse

00:38:19,200 --> 00:38:22,790
order because it's easier to actually

00:38:20,640 --> 00:38:25,110
talk about this and there's more to see

00:38:22,790 --> 00:38:26,820
but effectively you can use it to

00:38:25,110 --> 00:38:29,070
compose your API so when I said earlier

00:38:26,820 --> 00:38:30,240
you've got your resolvers your resolvers

00:38:29,070 --> 00:38:32,280
could potentially point to multiple

00:38:30,240 --> 00:38:35,340
systems you could effectively have one

00:38:32,280 --> 00:38:37,730
resolver where you're looking at a soap

00:38:35,340 --> 00:38:41,340
endpoint returning some data from that

00:38:37,730 --> 00:38:43,320
it's children might live in a mana no no

00:38:41,340 --> 00:38:45,240
sequel database that has a REST API and

00:38:43,320 --> 00:38:49,110
then for some reason you need to hit

00:38:45,240 --> 00:38:50,730
some as400 connection from another

00:38:49,110 --> 00:38:52,410
endpoint right so effectively you can

00:38:50,730 --> 00:38:54,870
compose all these different systems in

00:38:52,410 --> 00:38:56,670
one place and provide a single view of

00:38:54,870 --> 00:38:57,930
the world so to the caller they don't

00:38:56,670 --> 00:38:59,610
really care where it comes from right it

00:38:57,930 --> 00:39:04,530
makes no difference to them it's all

00:38:59,610 --> 00:39:06,960
about and you know having a single view

00:39:04,530 --> 00:39:09,270
of your data and allowing the caller to

00:39:06,960 --> 00:39:14,490
actually decide what they want to

00:39:09,270 --> 00:39:15,900
consume and how ok the data access layer

00:39:14,490 --> 00:39:20,060
is what I was talking about earlier you

00:39:15,900 --> 00:39:24,810
can use a framework called prism oh and

00:39:20,060 --> 00:39:30,710
that's relatively new and effectively

00:39:24,810 --> 00:39:33,960
abstract your database through graph QL

00:39:30,710 --> 00:39:36,870
ok so it's a bit like breeze j/s if you

00:39:33,960 --> 00:39:38,520
ever use breeze we breeze you're

00:39:36,870 --> 00:39:40,020
typically a point you create your entity

00:39:38,520 --> 00:39:41,520
framework objects you can expose those

00:39:40,020 --> 00:39:43,920
over the wire and then you have a data

00:39:41,520 --> 00:39:44,430
endpoint and wrist api's it's basically

00:39:43,920 --> 00:39:53,190
a bit like that

00:39:44,430 --> 00:39:55,110
ok the other use cases and that I have

00:39:53,190 --> 00:39:56,340
not mentioned here and it's because they

00:39:55,110 --> 00:39:58,410
don't actually they're not specific

00:39:56,340 --> 00:40:00,390
around how you should use graph QL it's

00:39:58,410 --> 00:40:03,450
more around what is actually being done

00:40:00,390 --> 00:40:06,119
and I like map I call it headless X

00:40:03,450 --> 00:40:07,410
right so headless is Prabha

00:40:06,119 --> 00:40:08,910
where we're heading I don't know if

00:40:07,410 --> 00:40:13,890
you're familiar with the term so

00:40:08,910 --> 00:40:15,150
headless CMS for instance is typically

00:40:13,890 --> 00:40:19,220
where you would have a back-end where

00:40:15,150 --> 00:40:22,319
you for instance WordPress as an example

00:40:19,220 --> 00:40:23,670
you've got a bunch of posts you might

00:40:22,319 --> 00:40:24,779
have a back in administration system

00:40:23,670 --> 00:40:26,549
where you go in then you're quite happy

00:40:24,779 --> 00:40:28,109
to do your posts but you want to really

00:40:26,549 --> 00:40:30,210
fancy you why you don't really want to

00:40:28,109 --> 00:40:31,440
be tied into WordPress with a headless

00:40:30,210 --> 00:40:33,180
type approach effectively what you're

00:40:31,440 --> 00:40:35,099
saying is I might have a back-end for

00:40:33,180 --> 00:40:37,890
administration and creation operations

00:40:35,099 --> 00:40:39,210
but you put the control of building the

00:40:37,890 --> 00:40:41,789
user interface in somebody else's hands

00:40:39,210 --> 00:40:43,349
oh you're right okay so then you've got

00:40:41,789 --> 00:40:44,490
full control over what your user

00:40:43,349 --> 00:40:47,609
interface looks like and how it

00:40:44,490 --> 00:40:53,609
interacts with the various api's okay

00:40:47,609 --> 00:40:55,079
and and there is actually a headless CMS

00:40:53,609 --> 00:41:01,200
so I'm not too sure what the name is it

00:40:55,079 --> 00:41:02,670
might be a graph CMS maybe and they have

00:41:01,200 --> 00:41:04,470
effectively done that do you effectively

00:41:02,670 --> 00:41:06,690
there's a service you go there and you

00:41:04,470 --> 00:41:08,789
pay X amount of money or whatever and

00:41:06,690 --> 00:41:11,190
you create your back-end and expose its

00:41:08,789 --> 00:41:12,839
graphical content for you and then you

00:41:11,190 --> 00:41:14,220
build your eyes you see fit I think the

00:41:12,839 --> 00:41:16,109
whole movement the whole point behind

00:41:14,220 --> 00:41:17,849
this is to actually avoid HTTP status

00:41:16,109 --> 00:41:20,009
codes I think they're trying to move

00:41:17,849 --> 00:41:22,499
away from that and there's no reason why

00:41:20,009 --> 00:41:24,180
you can't do it right the response code

00:41:22,499 --> 00:41:25,619
you're in full response of the response

00:41:24,180 --> 00:41:27,839
control of the response codes

00:41:25,619 --> 00:41:29,249
potentially from your resolver so you

00:41:27,839 --> 00:41:30,869
could return whatever you wanted so if

00:41:29,249 --> 00:41:34,559
you want comfortable doing it that way

00:41:30,869 --> 00:41:36,299
then that's fine if you want to do you

00:41:34,559 --> 00:41:37,589
know I can see potential use case where

00:41:36,299 --> 00:41:39,599
you're doing access denied and things

00:41:37,589 --> 00:41:42,930
like that you know you might want to do

00:41:39,599 --> 00:41:45,779
that and yeah you could use the codes if

00:41:42,930 --> 00:41:48,269
you wanted to typically we've never had

00:41:45,779 --> 00:41:50,730
to so the API is that we've built all

00:41:48,269 --> 00:41:52,799
returned 200 and they'll return a rich

00:41:50,730 --> 00:41:56,160
error message depending what has

00:41:52,799 --> 00:41:58,769
actually happened the reason for that is

00:41:56,160 --> 00:42:00,630
because you don't want the error message

00:41:58,769 --> 00:42:03,239
thing to an extent from my perspective

00:42:00,630 --> 00:42:05,970
becomes an attack vector so for instance

00:42:03,239 --> 00:42:08,009
if somebody works out that they can sort

00:42:05,970 --> 00:42:09,930
of send you down this rabbit hole of

00:42:08,009 --> 00:42:11,039
returning invalid error messages he

00:42:09,930 --> 00:42:12,989
could potentially hit you really really

00:42:11,039 --> 00:42:15,440
hard all the time but then the same

00:42:12,989 --> 00:42:18,299
thing could be said about the 200s

00:42:15,440 --> 00:42:19,980
personally the messages that we send up

00:42:18,299 --> 00:42:26,130
to the user interface tend to

00:42:19,980 --> 00:42:28,230
or status code okay so yeah there seems

00:42:26,130 --> 00:42:29,850
to be that seems to be what's typically

00:42:28,230 --> 00:42:31,980
used i've not seen anywhere where they

00:42:29,850 --> 00:42:33,450
say rely on error codes it's mostly an

00:42:31,980 --> 00:42:35,700
even where they've got examples around

00:42:33,450 --> 00:42:36,600
how you return messages or errors to the

00:42:35,700 --> 00:42:39,390
user interface

00:42:36,600 --> 00:42:43,290
you know return them with a 200

00:42:39,390 --> 00:42:44,340
potentially okay but it's it's up to you

00:42:43,290 --> 00:42:46,410
rights whatever makes you feel

00:42:44,340 --> 00:42:49,170
comfortable prac I always find it

00:42:46,410 --> 00:42:50,400
interesting with them best practices and

00:42:49,170 --> 00:42:52,200
recommendations and things like that

00:42:50,400 --> 00:42:53,250
because it's all about productivity you

00:42:52,200 --> 00:42:55,620
know if one weighs gonna make you more

00:42:53,250 --> 00:42:57,990
productive use that you know there's no

00:42:55,620 --> 00:43:00,570
as long as it's usually understood so

00:42:57,990 --> 00:43:06,270
don't if you convoluting making things

00:43:00,570 --> 00:43:08,100
complicated and for whatever reason and

00:43:06,270 --> 00:43:11,430
it makes it difficult to understand then

00:43:08,100 --> 00:43:12,540
you know that becomes a problem the

00:43:11,430 --> 00:43:14,190
other thing you need to consider is as

00:43:12,540 --> 00:43:15,570
the moment you start using status codes

00:43:14,190 --> 00:43:19,020
you need to start telling your end users

00:43:15,570 --> 00:43:22,500
why yep so that whole you're the user

00:43:19,020 --> 00:43:28,470
interface that you use to explore your

00:43:22,500 --> 00:43:30,390
api's that kind of starts to fall short

00:43:28,470 --> 00:43:33,090
because it's expecting 200 returns all

00:43:30,390 --> 00:43:34,890
the time so if you get an if you submit

00:43:33,090 --> 00:43:37,050
an error back and there's a problem then

00:43:34,890 --> 00:43:39,990
obviously you're gonna have to tell the

00:43:37,050 --> 00:43:41,850
users when this happens this is why but

00:43:39,990 --> 00:43:42,810
it also it makes it less rich from it in

00:43:41,850 --> 00:43:44,160
user perspective because they're

00:43:42,810 --> 00:43:49,170
expecting something to be returned that

00:43:44,160 --> 00:43:50,280
isn't you know you can't stop handling

00:43:49,170 --> 00:43:52,020
all the error codes if you have no

00:43:50,280 --> 00:43:53,700
network connectivity you can it get some

00:43:52,020 --> 00:43:57,180
form of error code anyways we were here

00:43:53,700 --> 00:43:59,730
when I hear right so I'll probably sit

00:43:57,180 --> 00:44:02,280
down for them most of this point and so

00:43:59,730 --> 00:44:08,010
as I said before I kind of look at graph

00:44:02,280 --> 00:44:11,550
QL as a ORM to extend data access layer

00:44:08,010 --> 00:44:16,350
if you will and an API composition

00:44:11,550 --> 00:44:18,240
engine right so what we have here is

00:44:16,350 --> 00:44:21,030
prism assert prism is relatively new the

00:44:18,240 --> 00:44:24,450
website's prism is at i/o it is all

00:44:21,030 --> 00:44:27,330
JavaScript and this is what actually

00:44:24,450 --> 00:44:29,640
provides a veneer on top of a relational

00:44:27,330 --> 00:44:33,480
database and currently currently they

00:44:29,640 --> 00:44:35,609
support MySQL and PostgreSQL

00:44:33,480 --> 00:44:37,710
if you're a cosmos DB fan obviously you

00:44:35,609 --> 00:44:40,140
can just pick a type they're looking to

00:44:37,710 --> 00:44:43,920
implement MongoDB in the future and

00:44:40,140 --> 00:44:45,390
potentially Cassandra as well and

00:44:43,920 --> 00:44:46,680
effectively what that gives you is

00:44:45,390 --> 00:44:48,900
obviously the flexibility to be able to

00:44:46,680 --> 00:44:51,599
say I need my data and it comes from

00:44:48,900 --> 00:44:54,690
these various endpoints and you do it

00:44:51,599 --> 00:44:57,869
all and rock your yep so there's no

00:44:54,690 --> 00:44:59,220
reason there's nothing to stop you from

00:44:57,869 --> 00:45:01,320
creating the slide and then putting

00:44:59,220 --> 00:45:03,030
another graph cure veneer in front of it

00:45:01,320 --> 00:45:06,180
that provides you with the domain

00:45:03,030 --> 00:45:08,579
objects yeah so effectively you can

00:45:06,180 --> 00:45:10,710
build graph QL with the client within

00:45:08,579 --> 00:45:12,750
your graphic your server to then further

00:45:10,710 --> 00:45:14,670
you know return the graph QL up

00:45:12,750 --> 00:45:16,440
specially if you some of the fields are

00:45:14,670 --> 00:45:17,849
the same you might want to do that don't

00:45:16,440 --> 00:45:19,980
recommend keeping the fields the same

00:45:17,849 --> 00:45:23,550
obviously for various reasons but that

00:45:19,980 --> 00:45:26,880
is an option okay so as I say prism is

00:45:23,550 --> 00:45:29,099
relatively new they do a lot of things

00:45:26,880 --> 00:45:30,780
so prism is effectively it's a I believe

00:45:29,099 --> 00:45:32,910
the company or the organization that

00:45:30,780 --> 00:45:34,260
builds the product as well and it also

00:45:32,910 --> 00:45:39,260
builds this thing called prism a

00:45:34,260 --> 00:45:41,250
playground now when you roll a graph QL

00:45:39,260 --> 00:45:43,079
server if you will there's two

00:45:41,250 --> 00:45:45,510
components to it there's effectively the

00:45:43,079 --> 00:45:47,880
graph kill endpoint and then there's a

00:45:45,510 --> 00:45:50,599
lie babe user interface it was built

00:45:47,880 --> 00:45:52,319
very lightweight called graphic URL am

00:45:50,599 --> 00:45:53,849
that's what helps you were the

00:45:52,319 --> 00:45:57,270
introspection right so as we spoke

00:45:53,849 --> 00:46:00,480
before the graph QL endpoint will

00:45:57,270 --> 00:46:03,270
typically describe itself to you if you

00:46:00,480 --> 00:46:06,060
invoke the schema its schema type query

00:46:03,270 --> 00:46:09,660
and and you can actually query that as

00:46:06,060 --> 00:46:13,109
you would any other graph cure object or

00:46:09,660 --> 00:46:15,119
any other graph QL type and so what

00:46:13,109 --> 00:46:18,270
Prisma has done is they've taken graphic

00:46:15,119 --> 00:46:22,619
QL which wasn't really user friendly it

00:46:18,270 --> 00:46:24,599
kind of coupled your endpoint to your

00:46:22,619 --> 00:46:26,579
craft your user interface specifically

00:46:24,599 --> 00:46:28,920
to that endpoint for introspection the

00:46:26,579 --> 00:46:32,760
Prisma playground and allows you to

00:46:28,920 --> 00:46:34,560
actually query multiple endpoints if you

00:46:32,760 --> 00:46:35,670
will so you can actually query multiple

00:46:34,560 --> 00:46:37,740
graph QL endpoints from the same user

00:46:35,670 --> 00:46:39,720
interface and if you don't want to roll

00:46:37,740 --> 00:46:42,900
it on your local machine you can use

00:46:39,720 --> 00:46:44,310
graphical Bend calm that provides you

00:46:42,900 --> 00:46:45,599
with the user interface because all it

00:46:44,310 --> 00:46:46,870
everything you're doing is from the

00:46:45,599 --> 00:46:48,670
client side so you

00:46:46,870 --> 00:46:50,620
composing your grass your endpoint your

00:46:48,670 --> 00:46:51,880
graphical queries from the client

00:46:50,620 --> 00:46:54,040
effectively doesn't matter whether it's

00:46:51,880 --> 00:46:55,960
localhost or whether it's remote right

00:46:54,040 --> 00:46:58,390
so you can actually point the graph job

00:46:55,960 --> 00:47:07,420
been to your local test environment if

00:46:58,390 --> 00:47:11,410
you want okay so graph QL Prisma and I

00:47:07,420 --> 00:47:14,020
use VMs mostly for my development it is

00:47:11,410 --> 00:47:17,260
the next one you don't it isn't a Linux

00:47:14,020 --> 00:47:21,370
specific the demos I'm going to show you

00:47:17,260 --> 00:47:24,970
are no js' but you can create graphical

00:47:21,370 --> 00:47:26,770
servers using net there's various

00:47:24,970 --> 00:47:28,600
libraries if you fancy scala

00:47:26,770 --> 00:47:30,180
you can have a bit of that as well it

00:47:28,600 --> 00:47:32,470
just it's entirely up to you obviously

00:47:30,180 --> 00:47:34,660
they all respond in the same graphical

00:47:32,470 --> 00:47:37,660
syntax even though the client has kind

00:47:34,660 --> 00:47:39,640
of prism a playground and is designed by

00:47:37,660 --> 00:47:40,030
the Prisma team the client works with

00:47:39,640 --> 00:47:42,340
everything

00:47:40,030 --> 00:47:46,330
though you don't actually have to you

00:47:42,340 --> 00:47:51,670
know use Prisma as the back in service

00:47:46,330 --> 00:47:53,020
right okay so to get things going what

00:47:51,670 --> 00:47:56,200
I'll do is I'll show you this particular

00:47:53,020 --> 00:47:58,690
thing that we've built and it's

00:47:56,200 --> 00:48:00,670
basically just a collection of apps the

00:47:58,690 --> 00:48:03,190
introspection is really good the

00:48:00,670 --> 00:48:04,690
effectively the user interface the

00:48:03,190 --> 00:48:05,410
playground allows you to actually use

00:48:04,690 --> 00:48:07,570
intellisense

00:48:05,410 --> 00:48:09,970
so you control space and it tells you

00:48:07,570 --> 00:48:11,440
what's in there right if you go over

00:48:09,970 --> 00:48:15,220
here you've got a schema this is

00:48:11,440 --> 00:48:20,290
effectively what's defined by your graph

00:48:15,220 --> 00:48:21,850
QL STL Prisma in this instance we're

00:48:20,290 --> 00:48:22,990
hitting a prism a end point so it's

00:48:21,850 --> 00:48:24,550
provisioned a bunch of stuff that I

00:48:22,990 --> 00:48:27,160
didn't have to do so what prism has done

00:48:24,550 --> 00:48:29,320
for me in this instance with some very

00:48:27,160 --> 00:48:30,790
very lot of heavy lifting and is

00:48:29,320 --> 00:48:32,980
actually provisioned all of the

00:48:30,790 --> 00:48:35,320
resolvers for me so now if you go back

00:48:32,980 --> 00:48:36,910
where we speak about a resolvers

00:48:35,320 --> 00:48:38,290
effectively when I make a request what

00:48:36,910 --> 00:48:42,280
actually goes off and fetches that on my

00:48:38,290 --> 00:48:44,980
behalf right so Prisma if you want to

00:48:42,280 --> 00:48:49,570
get started with graph QL and you're

00:48:44,980 --> 00:48:52,960
building a you know a crud type system

00:48:49,570 --> 00:48:54,550
you know it's an easy entry point and

00:48:52,960 --> 00:48:56,920
purely because it does do the heavy

00:48:54,550 --> 00:49:00,310
lifting for you you literally specify

00:48:56,920 --> 00:49:00,760
your type definition and I'll show you

00:49:00,310 --> 00:49:03,870
that

00:49:00,760 --> 00:49:07,480
and how that's done and you literally

00:49:03,870 --> 00:49:10,240
execute a function it uses docker by

00:49:07,480 --> 00:49:14,320
default so familiarity with docker it's

00:49:10,240 --> 00:49:17,410
useful learn it necessary and it will

00:49:14,320 --> 00:49:21,010
provision a docker container with a

00:49:17,410 --> 00:49:23,950
database for you if you wanted to and it

00:49:21,010 --> 00:49:25,900
will also then provision the server

00:49:23,950 --> 00:49:28,720
component which is effect so it's

00:49:25,900 --> 00:49:30,520
completely decoupled you can specify the

00:49:28,720 --> 00:49:32,410
database to use so you don't have to

00:49:30,520 --> 00:49:33,730
actually provision a database as part of

00:49:32,410 --> 00:49:35,710
the dr. container you can use an

00:49:33,730 --> 00:49:37,480
existing database you can also reverse

00:49:35,710 --> 00:49:40,180
engineer an existing database into a

00:49:37,480 --> 00:49:41,590
type definition so if you start if you

00:49:40,180 --> 00:49:43,450
decide you want to get database first as

00:49:41,590 --> 00:49:47,530
opposed to code first that's entirely up

00:49:43,450 --> 00:49:50,250
to you okay it does provide some

00:49:47,530 --> 00:49:53,290
authorized service level authorization

00:49:50,250 --> 00:49:54,760
but it is literally here's a key for

00:49:53,290 --> 00:49:57,550
your service it doesn't have

00:49:54,760 --> 00:50:00,010
fine-grained or thil fine-grained access

00:49:57,550 --> 00:50:02,110
control you have to build it yourself to

00:50:00,010 --> 00:50:04,480
an extent and it allows you to do that

00:50:02,110 --> 00:50:07,120
aside from doing the heavy lifting for

00:50:04,480 --> 00:50:09,850
you be when going to that detail today

00:50:07,120 --> 00:50:11,680
here but it also allow it actually makes

00:50:09,850 --> 00:50:14,440
it easier for you to query your back-end

00:50:11,680 --> 00:50:15,910
as well so if you don't want prisoner to

00:50:14,440 --> 00:50:17,350
do all of the heavy lifting for you if

00:50:15,910 --> 00:50:19,720
you want to compose a query yourself for

00:50:17,350 --> 00:50:21,220
example and the prisoner library itself

00:50:19,720 --> 00:50:24,370
also assists you in building those

00:50:21,220 --> 00:50:25,630
queries using a fluent type notation so

00:50:24,370 --> 00:50:28,140
instead of having to write a sequel

00:50:25,630 --> 00:50:30,250
statement you can effectively write

00:50:28,140 --> 00:50:34,300
something akin to entity framework

00:50:30,250 --> 00:50:35,860
queries yeah say you literally do that

00:50:34,300 --> 00:50:38,080
you take that approach as opposed to

00:50:35,860 --> 00:50:39,730
doing a full-on sequel statement some

00:50:38,080 --> 00:50:41,550
people are more comfortable doing that

00:50:39,730 --> 00:50:44,020
you know it's entirely up to you hide it

00:50:41,550 --> 00:50:46,900
but as I say if you want to do a rapid

00:50:44,020 --> 00:50:52,390
prototype or you building a crud type

00:50:46,900 --> 00:50:53,920
system this is probably a good starting

00:50:52,390 --> 00:50:56,410
point for you especially if you want to

00:50:53,920 --> 00:51:00,610
go down to code first route if you then

00:50:56,410 --> 00:51:01,780
use the container image then you can you

00:51:00,610 --> 00:51:03,090
know roll your own containers

00:51:01,780 --> 00:51:05,940
effectively and you've got a nicely

00:51:03,090 --> 00:51:08,470
decoupled system okay

00:51:05,940 --> 00:51:11,170
so effectively what we've got here so

00:51:08,470 --> 00:51:13,560
the introspection for instance soap we

00:51:11,170 --> 00:51:14,850
can start at this point here and tip

00:51:13,560 --> 00:51:17,670
if you want to access introspection its

00:51:14,850 --> 00:51:18,720
underscore underscore right and as I say

00:51:17,670 --> 00:51:20,580
it's gone really until it's in so this

00:51:18,720 --> 00:51:22,620
is defines the schema and within the

00:51:20,580 --> 00:51:25,350
schema whenever you do a query you

00:51:22,620 --> 00:51:27,060
effectively specify your field your

00:51:25,350 --> 00:51:28,710
route and then you specify what you want

00:51:27,060 --> 00:51:29,610
to retrieve so if we go over here we

00:51:28,710 --> 00:51:31,920
want to say one or three of all the

00:51:29,610 --> 00:51:36,180
types and I'm only interested in the

00:51:31,920 --> 00:51:37,410
type name right and then we hit play and

00:51:36,180 --> 00:51:43,260
then returns all the time to have to

00:51:37,410 --> 00:51:45,660
find my system now notice these things

00:51:43,260 --> 00:51:48,690
here because there's Prisma they've got

00:51:45,660 --> 00:51:51,090
app create input at previous values

00:51:48,690 --> 00:51:53,190
those are actually provisioned by prism

00:51:51,090 --> 00:51:55,080
itself as part of the heavy lifting you

00:51:53,190 --> 00:51:57,840
can do this yourself but prism it does

00:51:55,080 --> 00:52:00,990
do a lot of it for you so if you're

00:51:57,840 --> 00:52:04,260
using Prisma you probably want to go

00:52:00,990 --> 00:52:05,550
down this route just to keep things

00:52:04,260 --> 00:52:06,690
simple to start off with you don't

00:52:05,550 --> 00:52:09,090
really want to get knee deep into

00:52:06,690 --> 00:52:12,510
writing your own things and we will

00:52:09,090 --> 00:52:16,680
discuss how you could actually roll your

00:52:12,510 --> 00:52:18,360
own to an extent their backs so roll

00:52:16,680 --> 00:52:22,470
your own effectively Goff Kuehl service

00:52:18,360 --> 00:52:23,880
their backs onto a wrist API okay and

00:52:22,470 --> 00:52:25,110
there's code snippets that I show you

00:52:23,880 --> 00:52:26,040
your way and actually coded I'll just go

00:52:25,110 --> 00:52:28,820
through the curtain I'll kind of explain

00:52:26,040 --> 00:52:28,820
to you what it's doing

00:52:36,490 --> 00:52:40,790
no I don't think so I think you have to

00:52:38,720 --> 00:52:42,500
specify what it is that you want if you

00:52:40,790 --> 00:52:45,950
try to not specify anything it actually

00:52:42,500 --> 00:52:47,510
just breaks yeah so that's the thing

00:52:45,950 --> 00:52:49,250
it's about the consumer being in control

00:52:47,510 --> 00:52:50,660
of the data that's being returned so you

00:52:49,250 --> 00:52:52,850
want to specify you want to be specific

00:52:50,660 --> 00:52:54,350
I know in some cases you don't want to

00:52:52,850 --> 00:52:59,750
be specific you don't want to get get me

00:52:54,350 --> 00:53:01,190
everything but no okay not that I'm

00:52:59,750 --> 00:53:05,900
aware of anyway if you do find out let

00:53:01,190 --> 00:53:06,950
me know so this is a fictive lis schema

00:53:05,900 --> 00:53:10,700
that it builds this thing on the right

00:53:06,950 --> 00:53:12,440
hand side here and as you don't have to

00:53:10,700 --> 00:53:15,500
document stuff anymore brilliant right

00:53:12,440 --> 00:53:16,670
so now people can see what the options

00:53:15,500 --> 00:53:18,500
that are available to you and it

00:53:16,670 --> 00:53:20,270
actually gives you all of that wonderful

00:53:18,500 --> 00:53:22,550
information you can put comments into it

00:53:20,270 --> 00:53:24,080
as well if you want to describe the API

00:53:22,550 --> 00:53:25,210
but typically you name things correctly

00:53:24,080 --> 00:53:29,720
it's not a problem

00:53:25,210 --> 00:53:32,180
you typically you know should be able to

00:53:29,720 --> 00:53:33,830
understand what it's trying to do right

00:53:32,180 --> 00:53:36,590
you're modeling data here at the end of

00:53:33,830 --> 00:53:37,910
the day you're not necessarily changing

00:53:36,590 --> 00:53:42,350
the world with the graph you're querying

00:53:37,910 --> 00:53:44,300
it right so user this again here these

00:53:42,350 --> 00:53:47,420
directives as we spoken about before

00:53:44,300 --> 00:53:48,740
these are prism specific constructs so

00:53:47,420 --> 00:53:51,160
the fact that it's unique that's

00:53:48,740 --> 00:53:52,970
something that's was introduced by prism

00:53:51,160 --> 00:53:55,730
specifically to support the fact that

00:53:52,970 --> 00:53:57,680
you need any unique ID there and as well

00:53:55,730 --> 00:53:59,060
as relations so this is what tells it to

00:53:57,680 --> 00:54:04,220
actually create foreign key

00:53:59,060 --> 00:54:06,200
relationships in your database okay you

00:54:04,220 --> 00:54:07,670
tend to use relation names to avoid any

00:54:06,200 --> 00:54:09,740
weird things especially if you're

00:54:07,670 --> 00:54:10,820
referencing the same table twice for

00:54:09,740 --> 00:54:13,580
whatever reason you might want to have

00:54:10,820 --> 00:54:16,070
you know manager in subordinates if

00:54:13,580 --> 00:54:18,080
you're looking at an org structure this

00:54:16,070 --> 00:54:20,600
keeps it nice and clean otherwise it

00:54:18,080 --> 00:54:22,100
will break and or tell you it's from as

00:54:20,600 --> 00:54:25,100
we've done here right so we've got a

00:54:22,100 --> 00:54:26,810
created by modified by as an example and

00:54:25,100 --> 00:54:28,520
it's effectively two different relations

00:54:26,810 --> 00:54:35,380
so they're you know to use two different

00:54:28,520 --> 00:54:35,380
keys okay the

00:54:35,630 --> 00:54:39,990
so if you look at prism Adama so

00:54:37,769 --> 00:54:44,519
everything is kind of if you're not

00:54:39,990 --> 00:54:46,769
familiar with the Emmel it's just any

00:54:44,519 --> 00:54:49,200
file in windows days right and all it is

00:54:46,769 --> 00:54:51,539
is a bunch of key value pairs and it's

00:54:49,200 --> 00:54:53,160
typically used for configuration seems

00:54:51,539 --> 00:54:54,450
to be popular it seems to be a little

00:54:53,160 --> 00:54:59,849
bit more popular than Jason and Jason

00:54:54,450 --> 00:55:10,859
used to get all the rage so if we look

00:54:59,849 --> 00:55:19,140
at the where is my code there's my data

00:55:10,859 --> 00:55:23,400
model so or config right no code so this

00:55:19,140 --> 00:55:26,819
is a service secret if we wanted to kind

00:55:23,400 --> 00:55:30,000
of restrict things to specific a to sort

00:55:26,819 --> 00:55:31,170
of secure the request I'm not using it

00:55:30,000 --> 00:55:34,170
at the moment so it wouldn't worry too

00:55:31,170 --> 00:55:39,539
much about that we specified a database

00:55:34,170 --> 00:55:42,150
and docker compose because we're doing a

00:55:39,539 --> 00:55:44,759
prisoner config and effectively the

00:55:42,150 --> 00:55:49,319
container that we're pulling is prisoner

00:55:44,759 --> 00:55:54,269
away that will effectively wire up the

00:55:49,319 --> 00:55:55,859
prisoner for me so but they should be an

00:55:54,269 --> 00:55:58,250
index of jeaious here that I am not

00:55:55,859 --> 00:55:58,250
seeing

00:56:23,710 --> 00:56:27,150
it's a prism it deploy

00:56:34,270 --> 00:56:39,880
not the ploy that it wants to do so the

00:56:37,330 --> 00:56:41,650
reason so the JSON file so when we spoke

00:56:39,880 --> 00:56:45,760
earlier we see it effectively that the

00:56:41,650 --> 00:56:47,590
entry point is an indexed ojs when we

00:56:45,760 --> 00:56:48,850
build the container that effectively

00:56:47,590 --> 00:56:49,360
gets compiled and put into the container

00:56:48,850 --> 00:56:54,730
at all

00:56:49,360 --> 00:56:59,380
yeah so this is all you do to actually

00:56:54,730 --> 00:57:00,220
get your prism endpoint to work so

00:56:59,380 --> 00:57:02,110
there's three files you've got your

00:57:00,220 --> 00:57:09,960
graphical endpoint you've got your dog

00:57:02,110 --> 00:57:09,960
or compose and then your away yep

00:57:13,130 --> 00:57:16,800
that's to enable the upgrade of the

00:57:15,420 --> 00:57:18,090
database effectively so it's a same

00:57:16,800 --> 00:57:21,890
concept as entity framework we

00:57:18,090 --> 00:57:23,940
effectively upgrading the database right

00:57:21,890 --> 00:57:27,260
so when we did a docker deployed

00:57:23,940 --> 00:57:30,710
effectively it'll update my container

00:57:27,260 --> 00:57:35,490
this is just a docker compose file

00:57:30,710 --> 00:57:38,670
exposing some ports this is telling the

00:57:35,490 --> 00:57:42,390
prisoner thing to actually install

00:57:38,670 --> 00:57:45,750
PostgreSQL and then a username and

00:57:42,390 --> 00:57:47,280
password for that so that why is

00:57:45,750 --> 00:57:48,600
everything up and the prism about llamo

00:57:47,280 --> 00:57:50,730
there is obviously telling me that the

00:57:48,600 --> 00:57:55,050
data model is stored in here and the end

00:57:50,730 --> 00:58:00,540
point that I want to serve is here yeah

00:57:55,050 --> 00:58:02,610
so no code right we need to find schema

00:58:00,540 --> 00:58:06,660
and it's created all the stuff so what

00:58:02,610 --> 00:58:07,890
does it give us and this is why it's

00:58:06,660 --> 00:58:10,320
actually quite useful because it

00:58:07,890 --> 00:58:12,080
actually gives us a ton of stuff so if

00:58:10,320 --> 00:58:15,720
we go over here we've got an app and

00:58:12,080 --> 00:58:19,500
that's a name if we close this and I run

00:58:15,720 --> 00:58:21,680
that I get an error brilliant your token

00:58:19,500 --> 00:58:24,870
is invalid

00:58:21,680 --> 00:58:27,740
right this is now where I'm going to get

00:58:24,870 --> 00:58:27,740
a bug problem on

00:58:29,880 --> 00:58:39,779
right so it's good yeah say that and

00:58:34,959 --> 00:58:42,969
apps let's go there again and pick name

00:58:39,779 --> 00:58:45,940
okay execute BAM right oh but no apps at

00:58:42,969 --> 00:58:47,619
this moment in time right now all I've

00:58:45,940 --> 00:58:51,779
done is defined a type now I'm going to

00:58:47,619 --> 00:58:57,969
give mutation so in my app for instance

00:58:51,779 --> 00:59:00,309
I will say I want to create a mutation

00:58:57,969 --> 00:59:01,509
so we started for over here mutation and

00:59:00,309 --> 00:59:03,609
again this is the beauty of

00:59:01,509 --> 00:59:06,190
introspection we can go create app

00:59:03,609 --> 00:59:08,619
that's all provision for me I didn't

00:59:06,190 --> 00:59:10,569
have to do anything I want to specify a

00:59:08,619 --> 00:59:12,039
name I'm hoping that I don't have to put

00:59:10,569 --> 00:59:15,390
in tons and tons of things actually

00:59:12,039 --> 00:59:15,390
let's create a user it might be easier

00:59:27,660 --> 00:59:30,829
oh man

00:59:39,530 --> 00:59:48,920
today I'm a mutation

01:00:08,720 --> 01:00:14,720
and the errors for some reason are not

01:00:11,370 --> 01:00:14,720
being displayed which is not great

01:00:25,910 --> 01:00:29,090
let's say

01:00:36,900 --> 01:00:42,819
creating user its what is it saying

01:00:39,960 --> 01:00:47,589
argument data expected type user created

01:00:42,819 --> 01:00:48,670
input but got name organization okay so

01:00:47,589 --> 01:00:50,259
it gives you some information as to

01:00:48,670 --> 01:00:56,710
what's actually gone wrong here so it's

01:00:50,259 --> 01:01:05,170
saying it's missing a organization so if

01:00:56,710 --> 01:01:06,430
we go organization create so the beauty

01:01:05,170 --> 01:01:08,289
is you saw two options there you've got

01:01:06,430 --> 01:01:09,880
create and connect if you go if you

01:01:08,289 --> 01:01:11,109
choose connect you're connecting to an

01:01:09,880 --> 01:01:13,269
existing idea that you may already have

01:01:11,109 --> 01:01:14,349
if you create you actually provisioning

01:01:13,269 --> 01:01:17,859
a new one so this is the whole thing

01:01:14,349 --> 01:01:20,950
around being able to create your graph

01:01:17,859 --> 01:01:23,289
in one hit effectively so you say I'd

01:01:20,950 --> 01:01:24,940
need to create an organization as well

01:01:23,289 --> 01:01:27,940
as create a user if you're for instance

01:01:24,940 --> 01:01:29,470
creating a in some form of

01:01:27,940 --> 01:01:30,880
organizational structure where you need

01:01:29,470 --> 01:01:32,140
somebody to be part of a company and

01:01:30,880 --> 01:01:33,069
then be the manager of that company this

01:01:32,140 --> 01:01:34,809
is the type of approach that you would

01:01:33,069 --> 01:01:37,740
do so you have one person there might be

01:01:34,809 --> 01:01:41,250
the administrator and you provision the

01:01:37,740 --> 01:01:41,250
organization on the fly

01:01:50,730 --> 01:02:02,359
and then create this is when it's gonna

01:01:56,760 --> 01:02:02,359
get interesting name

01:02:09,430 --> 01:02:16,300
and I'm gonna hit this again it's gonna

01:02:11,619 --> 01:02:17,770
tell me some other stuff brilliant so

01:02:16,300 --> 01:02:20,079
I've completely got myself tied up in

01:02:17,770 --> 01:02:24,250
knots with my relationships so let's

01:02:20,079 --> 01:02:25,540
have a look at let's code here to see

01:02:24,250 --> 01:02:29,200
what we can create that isn't going to

01:02:25,540 --> 01:02:34,170
cause me a problem so I've got an

01:02:29,200 --> 01:02:34,170
organization there the organisation is

01:02:34,319 --> 01:02:40,440
down here do I have any users

01:02:47,089 --> 01:02:53,229
I'm hopeful taking us invalid against

01:02:50,390 --> 01:02:53,229
reload that

01:03:07,200 --> 01:03:18,180
actually users no users in my database

01:03:13,440 --> 01:03:27,930
brilliant how do I create a user without

01:03:18,180 --> 01:03:29,790
an organisation yep exactly so because

01:03:27,930 --> 01:03:33,690
I've got the not null they're basically

01:03:29,790 --> 01:03:35,579
tied up myself in knots right and that

01:03:33,690 --> 01:03:39,900
is a problem that I've created for my

01:03:35,579 --> 01:03:41,190
new brilliant and right let's see what I

01:03:39,900 --> 01:03:49,940
can do here maybe I can just recreate

01:03:41,190 --> 01:03:52,230
this container so if I go if I remove

01:03:49,940 --> 01:04:00,770
the need for an organization as an

01:03:52,230 --> 01:04:00,770
example for a user here

01:04:04,390 --> 01:04:07,290
I'm in truth

01:04:16,569 --> 01:04:25,890
my just expecting this secret for the

01:04:19,529 --> 01:04:25,890
cluster taste that

01:04:36,839 --> 01:04:47,799
maybe that one of the other one what did

01:04:39,910 --> 01:04:52,319
it say hey it's this one that's the

01:04:47,799 --> 01:04:52,319
plasti secret wrong secret

01:04:59,570 --> 01:05:07,420
right rocking and deploy

01:05:09,190 --> 01:05:16,810
rockin so it's updated my database

01:05:13,890 --> 01:05:19,990
theoretically alright so if I then go

01:05:16,810 --> 01:05:24,910
back over to this end point here and I

01:05:19,990 --> 01:05:26,609
reload if I look for users I should not

01:05:24,910 --> 01:05:27,819
be able to pick organization anymore

01:05:26,609 --> 01:05:30,700
okay

01:05:27,819 --> 01:05:32,950
so it's actually removed the entry from

01:05:30,700 --> 01:05:36,310
there altogether right so if I now go

01:05:32,950 --> 01:05:40,750
and try to create the user hopefully

01:05:36,310 --> 01:05:43,680
it'll work its mutation am I going to

01:05:40,750 --> 01:05:47,640
the same endpoint yet create the user

01:05:43,680 --> 01:06:00,160
and I want to say the user's name is

01:05:47,640 --> 01:06:03,790
Carlos the bracket so if we recall we

01:06:00,160 --> 01:06:07,630
have the query up there with the data

01:06:03,790 --> 01:06:11,470
parameters getting tied up on me

01:06:07,630 --> 01:06:15,339
I think say that's what we want to

01:06:11,470 --> 01:06:17,800
create and then the payload is the thing

01:06:15,339 --> 01:06:19,480
that we want to return so if we go back

01:06:17,800 --> 01:06:20,770
and say that's going to error but that's

01:06:19,480 --> 01:06:25,000
because it's expecting an email that I

01:06:20,770 --> 01:06:27,069
don't have potentially and then I

01:06:25,000 --> 01:06:34,599
specify what I want to return and I want

01:06:27,069 --> 01:06:37,750
to return ID that one might then thinks

01:06:34,599 --> 01:06:38,950
I know this world of a case there so

01:06:37,750 --> 01:06:42,160
I'll hit there to see what the hell that

01:06:38,950 --> 01:06:47,200
error is data expected so we've got user

01:06:42,160 --> 01:06:49,030
emails not null so emails required again

01:06:47,200 --> 01:06:52,230
Hall that wonderful introspection is

01:06:49,030 --> 01:06:52,230
having a sound so

01:06:59,300 --> 01:07:06,930
and can go administrator it's better

01:07:05,310 --> 01:07:08,099
straighter quiet no that's not required

01:07:06,930 --> 01:07:09,330
you'll notice at the bottom it tells you

01:07:08,099 --> 01:07:14,730
whether it's required or not as well

01:07:09,330 --> 01:07:20,010
probably introspection they go so that's

01:07:14,730 --> 01:07:24,840
user created in database right and I'll

01:07:20,010 --> 01:07:26,640
prove that to you by unfortunately the

01:07:24,840 --> 01:07:29,010
users are the emails aren't unique as

01:07:26,640 --> 01:07:30,750
defined in my schema so I can create the

01:07:29,010 --> 01:07:35,490
user with multiple emails numerous times

01:07:30,750 --> 01:07:38,790
but if I go here and I do that my token

01:07:35,490 --> 01:07:40,260
has expired again so this is all because

01:07:38,790 --> 01:07:41,090
Graf killed things tend to be short

01:07:40,260 --> 01:07:43,349
lived

01:07:41,090 --> 01:07:45,840
you should have really faced this

01:07:43,349 --> 01:07:51,410
problem when you actually execute this

01:07:45,840 --> 01:08:01,470
in Prague so here we go users we ready

01:07:51,410 --> 01:08:04,140
please work Natan right now that's

01:08:01,470 --> 01:08:07,170
pretty awesome and what I wanted to do

01:08:04,140 --> 01:08:10,020
now is if I go back over here and as I

01:08:07,170 --> 01:08:11,580
said before these aren't unique so I can

01:08:10,020 --> 01:08:13,320
hit this again different idea different

01:08:11,580 --> 01:08:22,430
view different ID and then over here

01:08:13,320 --> 01:08:22,430
I'll get a load of that you take

01:08:27,100 --> 01:08:35,029
now raise above that one that's really

01:08:29,719 --> 01:08:44,540
annoying that it keeps doing that so it

01:08:35,029 --> 01:08:46,310
uses and name right cool so so that's

01:08:44,540 --> 01:08:48,859
one thing you can do obviously put email

01:08:46,310 --> 01:08:49,790
in there maybe I might ID rather because

01:08:48,859 --> 01:08:57,100
then at least you'll notice that

01:08:49,790 --> 01:08:59,120
different IDs you can make things pretty

01:08:57,100 --> 01:09:01,969
so there's all the different users with

01:08:59,120 --> 01:09:04,719
different IDs and then we also then have

01:09:01,969 --> 01:09:06,739
the ability to do parameters right and

01:09:04,719 --> 01:09:08,750
again this is all heavy lifting by

01:09:06,739 --> 01:09:13,069
Prisma so that we didn't have to code

01:09:08,750 --> 01:09:15,529
any other stuff we can do aware let's

01:09:13,069 --> 01:09:31,040
have a look if we go for email there's

01:09:15,529 --> 01:09:33,940
an example way syntax is that so if I

01:09:31,040 --> 01:09:40,569
scroll down I should be able to find

01:09:33,940 --> 01:09:40,569
name or email even

01:09:41,569 --> 01:09:54,590
and one of the email addresses that I

01:09:44,969 --> 01:10:05,670
had was if I go back to my create user I

01:09:54,590 --> 01:10:23,489
go back over here where is it just close

01:10:05,670 --> 01:10:25,969
a tab by mistake let's use this one just

01:10:23,489 --> 01:10:28,110
check that two returning stuff cool

01:10:25,969 --> 01:10:30,600
let's have it again make sure it's still

01:10:28,110 --> 01:10:32,639
returning stuff good okay let's do the

01:10:30,600 --> 01:10:43,940
where clause and then the where Clause

01:10:32,639 --> 01:10:43,940
said where the email was a specific user

01:10:55,550 --> 01:11:08,750
No let's go down here and then see if we

01:11:00,740 --> 01:11:10,850
can actually do that and then I have one

01:11:08,750 --> 01:11:13,100
way it was just see a etsy.com hoping

01:11:10,850 --> 01:11:16,430
nope so you'll notice that obviously it

01:11:13,100 --> 01:11:18,500
doesn't return anything with me no

01:11:16,430 --> 01:11:21,860
specific data right so it doesn't return

01:11:18,500 --> 01:11:24,050
any 404s it's typically 200 so you can

01:11:21,860 --> 01:11:27,070
effectively use this to query your API

01:11:24,050 --> 01:11:30,770
you can do then and if you familiar with

01:11:27,070 --> 01:11:38,090
breeze Jas and from the client side you

01:11:30,770 --> 01:11:43,960
can do things like skip like five if you

01:11:38,090 --> 01:11:43,960
will well that should have worked

01:11:45,760 --> 01:11:52,390
that's not working

01:11:47,360 --> 01:11:57,950
gotta wear that one out there's two

01:11:52,390 --> 01:11:59,540
example so that returns to first you

01:11:57,950 --> 01:12:02,180
know in it these are all just built in

01:11:59,540 --> 01:12:04,010
you can do to last as well you know and

01:12:02,180 --> 01:12:05,960
all you do is you effectively leverage

01:12:04,010 --> 01:12:07,370
what prisoner is delivering for you so

01:12:05,960 --> 01:12:13,490
those are the options you can do order

01:12:07,370 --> 01:12:15,350
buys as well cetera so that's how you

01:12:13,490 --> 01:12:18,500
would potentially use prisoner to just

01:12:15,350 --> 01:12:20,750
do mutations and it also provides the

01:12:18,500 --> 01:12:23,240
ability to do an upset so insert or

01:12:20,750 --> 01:12:26,060
create keeps it nice and clean and you

01:12:23,240 --> 01:12:28,100
can do delete so it delete mutation

01:12:26,060 --> 01:12:31,190
again is the same kind of thing so if I

01:12:28,100 --> 01:12:33,320
go to create user mutation here and I

01:12:31,190 --> 01:12:38,840
change us to what and I'll take this ID

01:12:33,320 --> 01:12:41,420
here and I say I want to do a delete

01:12:38,840 --> 01:12:49,730
user mutation I'll do away clause

01:12:41,420 --> 01:12:53,450
I specified ID value I have to do a

01:12:49,730 --> 01:12:58,400
payload to say I want to do ID if you

01:12:53,450 --> 01:13:01,070
will there you go now if I go over here

01:12:58,400 --> 01:13:14,940
back to my query

01:13:01,070 --> 01:13:17,060
sorry yep so then this is the thing

01:13:14,940 --> 01:13:21,540
right so this is where you've got a

01:13:17,060 --> 01:13:22,650
different so this is effectively return

01:13:21,540 --> 01:13:24,150
an error in a different way but

01:13:22,650 --> 01:13:25,920
typically what you can do is you can

01:13:24,150 --> 01:13:28,080
effectively return it in such a way that

01:13:25,920 --> 01:13:32,450
it comes back as part of the deleting

01:13:28,080 --> 01:13:32,450
user payload if you're using a Union

01:13:34,910 --> 01:13:49,890
sorry yeah that's the challenge right so

01:13:48,690 --> 01:13:51,300
you need to be careful so you want to

01:13:49,890 --> 01:13:53,370
roll that stuff out yourself they do

01:13:51,300 --> 01:13:55,320
have some authentication stuff that I

01:13:53,370 --> 01:13:56,820
haven't played with at the moment and

01:13:55,320 --> 01:14:00,800
it's all based around a Worf right so

01:13:56,820 --> 01:14:03,239
it'll be a JW with JA token JWT token

01:14:00,800 --> 01:14:05,940
and effectively you leverage that

01:14:03,239 --> 01:14:07,380
functionality we rolled our own when we

01:14:05,940 --> 01:14:09,420
built our stuff we didn't use prism

01:14:07,380 --> 01:14:12,420
unfortunately it wasn't we didn't know

01:14:09,420 --> 01:14:16,410
about it and we ended up cranking a

01:14:12,420 --> 01:14:17,670
bunch of REST API s to deliver an ORM

01:14:16,410 --> 01:14:21,840
where this would have been really really

01:14:17,670 --> 01:14:24,480
useful for us because our challenge was

01:14:21,840 --> 01:14:26,040
slightly different in that the API they

01:14:24,480 --> 01:14:29,580
were exposing for the ORM we weren't

01:14:26,040 --> 01:14:31,380
exposing to the cloud so it wasn't a

01:14:29,580 --> 01:14:35,040
public facing API so we can control the

01:14:31,380 --> 01:14:38,489
security at a specific point the cloud

01:14:35,040 --> 01:14:41,250
provider that we had because we were

01:14:38,489 --> 01:14:46,400
using function as a service and we could

01:14:41,250 --> 01:14:50,640
use the mechanism we could use the BTC

01:14:46,400 --> 01:14:54,270
identity provider to prevent users that

01:14:50,640 --> 01:14:56,010
didn't have a an OAuth token issued by

01:14:54,270 --> 01:14:58,770
their provider from invoking the request

01:14:56,010 --> 01:15:02,070
yep so typically what would happen is as

01:14:58,770 --> 01:15:04,290
the API gateway that would sit in front

01:15:02,070 --> 01:15:05,400
of our function would reject based on

01:15:04,290 --> 01:15:07,980
the fact that the user didn't have an

01:15:05,400 --> 01:15:09,330
auto tagging people will say don't keep

01:15:07,980 --> 01:15:12,060
graft Kelvin and don't implement

01:15:09,330 --> 01:15:14,310
authorization I say be pragmatic right

01:15:12,060 --> 01:15:17,260
you know I think

01:15:14,310 --> 01:15:20,530
with the way when we've implemented it

01:15:17,260 --> 01:15:22,930
and we rolled the authorization into the

01:15:20,530 --> 01:15:25,270
graph QL endpoint and we went as far as

01:15:22,930 --> 01:15:28,120
to include whitelisting as well so when

01:15:25,270 --> 01:15:30,250
we presented the schema to the client

01:15:28,120 --> 01:15:31,540
and you could probably extend this and

01:15:30,250 --> 01:15:32,650
if you got you know if you got a bit

01:15:31,540 --> 01:15:34,990
creative you could make it so that

01:15:32,650 --> 01:15:36,370
depending on who you log in as it would

01:15:34,990 --> 01:15:37,720
return what was available to you we

01:15:36,370 --> 01:15:40,030
didn't we basically presented the entire

01:15:37,720 --> 01:15:41,110
schema and then based on your role we

01:15:40,030 --> 01:15:43,030
would decide whether or not you could

01:15:41,110 --> 01:15:44,770
have that data so you could request

01:15:43,030 --> 01:15:46,540
whatever you wanted but if your role if

01:15:44,770 --> 01:15:48,070
it wasn't the type of role that you're

01:15:46,540 --> 01:15:50,020
expecting would basically trim that out

01:15:48,070 --> 01:15:51,370
from a security perspective and we'd do

01:15:50,020 --> 01:15:52,840
that at the draft your layer so that's

01:15:51,370 --> 01:15:55,360
kind of the idea so effectively you can

01:15:52,840 --> 01:15:57,460
bundle all of these things up if I'd if

01:15:55,360 --> 01:15:58,900
we've got the relationship right when we

01:15:57,460 --> 01:16:01,990
originally built it you could have

01:15:58,900 --> 01:16:03,610
actively gone I am my own parent and

01:16:01,990 --> 01:16:04,870
effectively going down all the way down

01:16:03,610 --> 01:16:06,040
the tree and effectively go get me my

01:16:04,870 --> 01:16:07,300
parent get me my parent gave me my

01:16:06,040 --> 01:16:09,460
parent and potentially ended up in a

01:16:07,300 --> 01:16:11,140
stack overflow so the way they get

01:16:09,460 --> 01:16:14,200
around things like that is to actually

01:16:11,140 --> 01:16:16,960
limit the number of requests that you

01:16:14,200 --> 01:16:18,390
can do or how far down the tree you can

01:16:16,960 --> 01:16:21,460
go you can just do that using a counter

01:16:18,390 --> 01:16:24,460
it's nothing too trivial too complicated

01:16:21,460 --> 01:16:26,670
and the other thing M that you'll want

01:16:24,460 --> 01:16:28,780
to consider as well as the caching and

01:16:26,670 --> 01:16:32,320
prisoner will probably do some caching

01:16:28,780 --> 01:16:34,570
for you under the hood if you roll your

01:16:32,320 --> 01:16:36,040
own with that graph QL or Apollo server

01:16:34,570 --> 01:16:38,920
for instance you'll have to look after

01:16:36,040 --> 01:16:44,170
that yourself but these libraries that

01:16:38,920 --> 01:16:45,640
help you okay so mutations is probably

01:16:44,170 --> 01:16:49,020
one of the last things I'll show you I

01:16:45,640 --> 01:16:51,070
wanted to show you the have you got

01:16:49,020 --> 01:16:54,610
do you mind staying for an extra 10

01:16:51,070 --> 01:16:56,380
minutes so I can show you the air-five

01:16:54,610 --> 01:16:59,470
or I just give me five minutes I'll show

01:16:56,380 --> 01:17:02,740
you the last bit around make it two off

01:16:59,470 --> 01:17:04,110
two minutes right so let's do them you

01:17:02,740 --> 01:17:06,640
[Music]

01:17:04,110 --> 01:17:10,030
so let's talk about mutations here so

01:17:06,640 --> 01:17:12,930
we've deleted a user let's go back and

01:17:10,030 --> 01:17:12,930
try to create a user

01:17:15,300 --> 01:17:20,349
it really is a date so don't need an

01:17:17,920 --> 01:17:25,900
organization anymore because I've

01:17:20,349 --> 01:17:28,170
removed that get rid of that get rid of

01:17:25,900 --> 01:17:28,170
that

01:17:31,370 --> 01:17:36,520
get rid of that specify the payload ID

01:17:37,810 --> 01:17:44,380
but that's kind of brackets wrong around

01:17:39,860 --> 01:17:47,540
and in that what we get to go chayo

01:17:44,380 --> 01:17:49,070
right and then what I'll do here and

01:17:47,540 --> 01:17:54,950
again this is prisoner doing the heavy

01:17:49,070 --> 01:18:02,660
lifting you have a subscription and I

01:17:54,950 --> 01:18:06,680
want to subscribe to users and I would

01:18:02,660 --> 01:18:09,830
like to understand the node and I would

01:18:06,680 --> 01:18:17,440
like from that know to return the name

01:18:09,830 --> 01:18:26,870
and the ID so is that running yes it is

01:18:17,440 --> 01:18:30,140
if I go here and I do create user we

01:18:26,870 --> 01:18:31,520
effectively have the endpoint that's

01:18:30,140 --> 01:18:35,620
listening and all the users are

01:18:31,520 --> 01:18:35,620
appearing or should be appearing here

01:18:36,850 --> 01:18:41,470
it's clear that and try this again

01:18:42,700 --> 01:18:47,140
actually I'm going to open this up in

01:18:44,600 --> 01:18:47,140
another tab

01:18:55,100 --> 01:19:00,860
right come on subscription

01:19:08,410 --> 01:19:11,700
that is so anyway

01:19:12,079 --> 01:19:18,059
five seconds ago bigger so I'll go

01:19:16,199 --> 01:19:21,360
create news on call and go through to

01:19:18,059 --> 01:19:22,800
execute that go over here and hopefully

01:19:21,360 --> 01:19:30,900
we'll see it Joe to somewhere in the

01:19:22,800 --> 01:19:32,099
body I can get it to scroll oh right

01:19:30,900 --> 01:19:35,090
okay you get the point right

01:19:32,099 --> 01:19:37,650
unfortunately it didn't work as expected

01:19:35,090 --> 01:19:39,780
but effectively what you've got is

01:19:37,650 --> 01:19:42,239
you've got a subscription-based model

01:19:39,780 --> 01:19:47,579
where you can respond to you know

01:19:42,239 --> 01:19:53,820
changes in the underlying data okay yep

01:19:47,579 --> 01:19:57,239
oh there it is took nice and long all

01:19:53,820 --> 01:19:59,820
right so that's it for in terms of

01:19:57,239 --> 01:20:02,550
Prisma the one thing I did want to show

01:19:59,820 --> 01:20:07,889
you was the how you'd potentially roll

01:20:02,550 --> 01:20:11,730
your own and what that would potentially

01:20:07,889 --> 01:20:14,840
look like so again it's all about how

01:20:11,730 --> 01:20:14,840
much heavy lifting you want to do

01:20:24,050 --> 01:20:33,240
I will show you the graph QL version so

01:20:30,900 --> 01:20:36,240
scrappy anybody familiar with swoopy so

01:20:33,240 --> 01:20:38,760
that's the Star Wars API that's REST API

01:20:36,240 --> 01:20:41,100
that's available right and you can just

01:20:38,760 --> 01:20:43,460
query a bunch of stuff that star was

01:20:41,100 --> 01:20:46,110
related I don't think it's really rich

01:20:43,460 --> 01:20:52,050
they use babel typically you don't have

01:20:46,110 --> 01:20:57,750
to do they do quite extensive amount of

01:20:52,050 --> 01:20:59,700
work here so and use flow as well so

01:20:57,750 --> 01:21:04,380
this is just the server being wired up

01:20:59,700 --> 01:21:05,490
are using Express I'm not going to go

01:21:04,380 --> 01:21:06,810
into details around the packages that

01:21:05,490 --> 01:21:13,890
are require you can literally download

01:21:06,810 --> 01:21:15,810
the sample as well from github so what

01:21:13,890 --> 01:21:19,350
you want to be looking for is the types

01:21:15,810 --> 01:21:27,900
type definition of the objects so thanks

01:21:19,350 --> 01:21:29,460
down so these are all the fields that

01:21:27,900 --> 01:21:33,970
you have so these all effectively a

01:21:29,460 --> 01:21:35,510
graph type with some resolvers yeah and

01:21:33,970 --> 01:21:39,320
[Music]

01:21:35,510 --> 01:21:39,320
this is super complicated

01:21:45,150 --> 01:21:47,900
okay

01:21:49,219 --> 01:21:54,050
so this is making a requests effectively

01:21:52,130 --> 01:22:01,160
to remote api's and because I don't have

01:21:54,050 --> 01:22:04,250
Babel that's all going wrong and if I go

01:22:01,160 --> 01:22:08,480
over to the specific API specific types

01:22:04,250 --> 01:22:09,920
that are defined these are them so sadly

01:22:08,480 --> 01:22:11,840
what they've done here is instead of

01:22:09,920 --> 01:22:14,180
they've actually defined the types using

01:22:11,840 --> 01:22:15,020
Java Script and whichever obviously

01:22:14,180 --> 01:22:16,790
makes things a little bit more

01:22:15,020 --> 01:22:19,370
complicated and what you can use is a

01:22:16,790 --> 01:22:20,390
tool called graphical tools and what

01:22:19,370 --> 01:22:23,810
that will do is it allows you to

01:22:20,390 --> 01:22:27,170
actually define the schema using STL and

01:22:23,810 --> 01:22:29,390
effectively unpack a executable schema

01:22:27,170 --> 01:22:32,120
which effectively converts that string

01:22:29,390 --> 01:22:33,800
into this for you on the fly and then

01:22:32,120 --> 01:22:36,530
your map resolvers this if you go down

01:22:33,800 --> 01:22:39,110
this road it's complicated right so

01:22:36,530 --> 01:22:43,580
typically you would use something a

01:22:39,110 --> 01:22:47,900
little bit more akin to this so it's

01:22:43,580 --> 01:22:54,460
Apollo so let's go slap your raced

01:22:47,900 --> 01:23:00,880
Apollo actually may go and code that one

01:22:54,460 --> 01:23:00,880
so here's my schema

01:23:04,780 --> 01:23:11,080
they're not defined again they've gone

01:23:08,470 --> 01:23:18,460
down the route of creating the stuff

01:23:11,080 --> 01:23:20,560
using javascript okay

01:23:18,460 --> 01:23:24,150
and you should have resolvers somewhere

01:23:20,560 --> 01:23:27,400
in here so this is Fitch page of time

01:23:24,150 --> 01:23:30,610
have a look we are there resolving this

01:23:27,400 --> 01:23:35,560
is the wrong code there's all the

01:23:30,610 --> 01:23:36,790
horribly wrong now actually wanted to

01:23:35,560 --> 01:23:41,340
show you the demo that I had for you

01:23:36,790 --> 01:23:41,340
actually shows you the use it using the

01:23:47,310 --> 01:23:51,400
do I want to graph cure to session I

01:23:49,930 --> 01:23:56,010
don't know if you'll have me back I'll

01:23:51,400 --> 01:23:56,010
come back but it's entirely up to you

01:23:59,160 --> 01:24:04,090
know but I can sing that after you

01:24:02,100 --> 01:24:06,280
absolutely no problem I can't just send

01:24:04,090 --> 01:24:09,000
them I'll send them - then we're going

01:24:06,280 --> 01:24:16,960
from there yeah absolutely my problem

01:24:09,000 --> 01:24:20,520
let me just check so where are we I am

01:24:16,960 --> 01:24:25,600
looking for the ah there you go

01:24:20,520 --> 01:24:26,920
no video this is what we saw before so

01:24:25,600 --> 01:24:29,350
this is effectively the scheme it's been

01:24:26,920 --> 01:24:31,120
defined in the same way we defined it in

01:24:29,350 --> 01:24:33,610
a file you could pull it from a file if

01:24:31,120 --> 01:24:34,990
you wanted to you've got a bunch of

01:24:33,610 --> 01:24:36,880
resolvers and then that's the resolver

01:24:34,990 --> 01:24:38,440
function so you've got your query there

01:24:36,880 --> 01:24:40,420
your type you've got your mutation as we

01:24:38,440 --> 01:24:44,230
discussed and effectively you're

01:24:40,420 --> 01:24:47,170
invoking some functions called update

01:24:44,230 --> 01:24:48,430
user etc and there are literally just

01:24:47,170 --> 01:24:49,750
functions that would sit underneath that

01:24:48,430 --> 01:24:50,860
those are anonymous anyway and then the

01:24:49,750 --> 01:24:53,320
work is actually being done in here

01:24:50,860 --> 01:24:55,930
there's no magic in terms of what's

01:24:53,320 --> 01:24:58,060
being queried here so the other thing

01:24:55,930 --> 01:25:03,610
then is effectively how you wire these

01:24:58,060 --> 01:25:06,700
two things up that's typically done in

01:25:03,610 --> 01:25:08,290
this space so you do that you take your

01:25:06,700 --> 01:25:10,600
schema you take your resolver to

01:25:08,290 --> 01:25:13,090
different objects they kind of have to

01:25:10,600 --> 01:25:14,650
relate so that your schema can actually

01:25:13,090 --> 01:25:18,220
be resolved by your resolvers so you

01:25:14,650 --> 01:25:22,000
need to make sure that those line up and

01:25:18,220 --> 01:25:24,370
that's typically done this way so if you

01:25:22,000 --> 01:25:26,440
look over here you've got a query use a

01:25:24,370 --> 01:25:28,060
bi ID if you look at the resolver you've

01:25:26,440 --> 01:25:29,530
got a user by ID and there's part of

01:25:28,060 --> 01:25:32,560
your query so as long as those two

01:25:29,530 --> 01:25:34,930
things line up then it'll automatically

01:25:32,560 --> 01:25:36,870
execute this method based on when you

01:25:34,930 --> 01:25:42,690
make that request to the query endpoint

01:25:36,870 --> 01:25:42,690
and your wiring up is effectively this

01:25:43,650 --> 01:25:47,230
alright are you basically saying this is

01:25:45,730 --> 01:25:48,670
my definition this is my scheme and this

01:25:47,230 --> 01:25:50,160
is my resolver and do those two things

01:25:48,670 --> 01:25:52,360
for me together using the polish server

01:25:50,160 --> 01:25:54,190
and then it's set up to listen this

01:25:52,360 --> 01:25:56,320
isn't using Apollo express this is just

01:25:54,190 --> 01:25:58,390
a rule Apollo serve and it's listening

01:25:56,320 --> 01:26:03,219
on port 4000 that's it

01:25:58,390 --> 01:26:03,219

YouTube URL: https://www.youtube.com/watch?v=fiXZLwVMqmc


