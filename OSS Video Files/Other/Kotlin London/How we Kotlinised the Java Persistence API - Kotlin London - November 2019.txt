Title: How we Kotlinised the Java Persistence API - Kotlin London - November 2019
Publication date: 2019-11-24
Playlist: Kotlin London
Description: 
	How we Kotlinised the Java Persistence API
Kotlin is great on the server: you get a modern, more usable language, with access to 25 years of tried and tested libraries that solve a lot of common engineering problems. The downside is that most of those libraries were written with Java development in mind, so using them from Kotlin can feel weirder, and less comfortable than an API written with Kotlin in mind.
The Java Persistence API, made famous by Hibernate, is one such library: What object type will this query return? When is it safe to persist objects? How can you tell if you’re in a transaction? These are all questions that the JPA makes really hard to answer, but with a bit of work, can become really easy to figure out in Kotlin.
In this talk, we’ll look at the Java Persistence API, and how we’ve used Kotlin’s features to make it feel like a natural Kotlin tool. You’ll come away from this talk with ideas of how to make your favourite Java libraries work better with Kotlin.

Chris is an Australian developer, speaker, and serial community conference organiser. He serves as a director of the Python Software Foundation, and is co-organiser of the acclaimed North Bay Python conference, a boutique one-track conference run in a live music venue in Petaluma, California.
By day, Christopher works as a Senior Software Engineer at AlphaSights, using Kotlin to build technology that helps connect investors, consultants, and corporate strategists to industry experts with the knowledge they need to make better decisions.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:08,639
thank you Hey so I'm Christopher no gay

00:00:03,929 --> 00:00:10,410
bar I am a senior engineer currently

00:00:08,639 --> 00:00:13,139
working as a technical lead on

00:00:10,410 --> 00:00:16,859
communications engineering here at Alpha

00:00:13,139 --> 00:00:18,359
sites I'm based in California work for

00:00:16,859 --> 00:00:19,830
our New York office and I'm talking to

00:00:18,359 --> 00:00:23,490
you all from London which is very

00:00:19,830 --> 00:00:25,939
exciting so our team our communications

00:00:23,490 --> 00:00:28,830
engineering team has been working on a

00:00:25,939 --> 00:00:30,990
Greenfields backend service i've written

00:00:28,830 --> 00:00:32,579
entirely in Kotlin and we've been

00:00:30,990 --> 00:00:34,170
solving a whole pile of interesting

00:00:32,579 --> 00:00:36,390
problems along the way as we've

00:00:34,170 --> 00:00:38,610
discovered how to use Kotlin as an

00:00:36,390 --> 00:00:41,850
alternative implementation language to

00:00:38,610 --> 00:00:43,890
Java so today I'm going to talk a bit

00:00:41,850 --> 00:00:45,570
about the work that we did to rethink

00:00:43,890 --> 00:00:48,809
how a Kotlin service we've been working

00:00:45,570 --> 00:00:50,100
on interacts with its database if you

00:00:48,809 --> 00:00:51,570
have questions you can save them to the

00:00:50,100 --> 00:00:53,699
end if I haven't answered them by the

00:00:51,570 --> 00:00:58,609
end of the talk you can ask in QA or you

00:00:53,699 --> 00:01:01,170
can ask me when I'm not talking I guess

00:00:58,609 --> 00:01:03,329
so my background however it doesn't come

00:01:01,170 --> 00:01:05,790
from Kotlin or Java I've been working

00:01:03,329 --> 00:01:07,740
with Python for most of my life I'm on

00:01:05,790 --> 00:01:08,850
the board of directors of the Python

00:01:07,740 --> 00:01:10,710
Software Foundation

00:01:08,850 --> 00:01:12,840
I ran a community-based Python

00:01:10,710 --> 00:01:15,659
conference so while I'm not going to be

00:01:12,840 --> 00:01:18,600
talking about Python today my background

00:01:15,659 --> 00:01:20,580
in Python informs a lot about this talk

00:01:18,600 --> 00:01:22,710
so while Cortland does a great job of

00:01:20,580 --> 00:01:25,170
replacing the Java language in back-end

00:01:22,710 --> 00:01:27,150
services it's still very easy to write

00:01:25,170 --> 00:01:30,299
Kotlin that looks a lot like Enterprise

00:01:27,150 --> 00:01:32,460
Java I don't have a background in

00:01:30,299 --> 00:01:34,590
enterprise Java so my idea of what a

00:01:32,460 --> 00:01:36,329
good application looks like doesn't

00:01:34,590 --> 00:01:38,130
necessarily agree with what Enterprise

00:01:36,329 --> 00:01:40,680
Java developers think a good application

00:01:38,130 --> 00:01:42,540
looks like most of my back-end

00:01:40,680 --> 00:01:44,310
engineering experience before I started

00:01:42,540 --> 00:01:46,590
working in Kotlin comes from a Python

00:01:44,310 --> 00:01:49,229
framework called Django it has a magical

00:01:46,590 --> 00:01:50,610
pony for a logo I'm not going to dwell

00:01:49,229 --> 00:01:52,619
on the logo too much but I think it's

00:01:50,610 --> 00:01:54,299
worth bringing you up to speed with why

00:01:52,619 --> 00:01:56,430
I think the way that I do before I dive

00:01:54,299 --> 00:01:58,229
into the rest of the talk so django

00:01:56,430 --> 00:02:00,210
provides you with tools for making web

00:01:58,229 --> 00:02:02,250
applications out of the box has a

00:02:00,210 --> 00:02:04,500
library for defining and processing

00:02:02,250 --> 00:02:06,810
input forms has a library for rendering

00:02:04,500 --> 00:02:09,420
templates it has a URL routing framework

00:02:06,810 --> 00:02:11,640
but most importantly it has a data

00:02:09,420 --> 00:02:12,780
management layer the the Django object

00:02:11,640 --> 00:02:16,020
relational mapper the jjang

00:02:12,780 --> 00:02:17,820
Oh RM the idea behind Django's ORM is

00:02:16,020 --> 00:02:21,210
that you define yourself a plain old

00:02:17,820 --> 00:02:23,040
Python class and every class every field

00:02:21,210 --> 00:02:26,160
in that class represents a typed

00:02:23,040 --> 00:02:27,960
database column you type some

00:02:26,160 --> 00:02:29,940
incantations of the command line to make

00:02:27,960 --> 00:02:32,520
the database happen and then suddenly

00:02:29,940 --> 00:02:34,550
you can create instances of your model

00:02:32,520 --> 00:02:37,170
and you can save them to the database

00:02:34,550 --> 00:02:39,240
importantly the ORM makes sure that it's

00:02:37,170 --> 00:02:41,190
always in a position to persist objects

00:02:39,240 --> 00:02:43,110
so if you're not building an application

00:02:41,190 --> 00:02:45,000
it's going to be highly concurrent you

00:02:43,110 --> 00:02:47,610
only have a small number as users it

00:02:45,000 --> 00:02:49,620
will manage transactions for you if your

00:02:47,610 --> 00:02:52,709
database is a database that requires

00:02:49,620 --> 00:02:54,810
transactions such as Postgres it's very

00:02:52,709 --> 00:02:56,970
easy to interact with the database out

00:02:54,810 --> 00:02:59,310
of the box in django and then you can

00:02:56,970 --> 00:03:03,720
incrementally learn more features of

00:02:59,310 --> 00:03:06,630
your ORM as you need to use them you can

00:03:03,720 --> 00:03:09,030
also query the database using plain old

00:03:06,630 --> 00:03:11,640
Python in most cases you can either get

00:03:09,030 --> 00:03:13,980
a single object using this get thing or

00:03:11,640 --> 00:03:17,970
you can ask for query sets which

00:03:13,980 --> 00:03:20,549
represent like full sets of results so

00:03:17,970 --> 00:03:24,330
in Django for better or worse writing

00:03:20,549 --> 00:03:25,500
SQL is strongly discouraged the idea is

00:03:24,330 --> 00:03:27,870
that you write your queries using

00:03:25,500 --> 00:03:30,030
objects where you can if the ORM doesn't

00:03:27,870 --> 00:03:32,310
support your query that's when you start

00:03:30,030 --> 00:03:34,590
writing SQL Django has support for that

00:03:32,310 --> 00:03:37,739
but it's not usually your primary use

00:03:34,590 --> 00:03:39,450
case so that ends my quick primer in

00:03:37,739 --> 00:03:40,850
Django now we can talk about Kotlin

00:03:39,450 --> 00:03:43,019
which i think is why you're all here

00:03:40,850 --> 00:03:44,880
kahlan's a really interesting language

00:03:43,019 --> 00:03:47,220
for back-end service development because

00:03:44,880 --> 00:03:49,890
the designers of Kotlin decided that

00:03:47,220 --> 00:03:51,630
interoperating with legacy Java features

00:03:49,890 --> 00:03:55,530
should be at the core of the language

00:03:51,630 --> 00:03:57,870
and this means that Kotlin already has

00:03:55,530 --> 00:04:00,090
quite a vibrant ecosystem for back-end

00:03:57,870 --> 00:04:03,150
development and that's entirely because

00:04:00,090 --> 00:04:05,670
Java has a quite vibrant ecosystem for

00:04:03,150 --> 00:04:07,970
back-end development if things work in

00:04:05,670 --> 00:04:10,170
Java they tend to work in Kotlin as well

00:04:07,970 --> 00:04:11,970
but this can be a double-edged sword

00:04:10,170 --> 00:04:15,090
because despite being interoperable with

00:04:11,970 --> 00:04:18,150
Java Kotlin is a really opinionated

00:04:15,090 --> 00:04:19,560
language Kotlin first libraries have an

00:04:18,150 --> 00:04:21,720
expressiveness that usually isn't

00:04:19,560 --> 00:04:24,780
matched by Java focused counterparts and

00:04:21,720 --> 00:04:26,070
Java is also quite old it's been popular

00:04:24,780 --> 00:04:28,860
for development work for all

00:04:26,070 --> 00:04:30,810
thirty years now and a lot of libraries

00:04:28,860 --> 00:04:33,090
that people use all the time in Java

00:04:30,810 --> 00:04:35,040
have a history going back as far as the

00:04:33,090 --> 00:04:36,690
first releases of Java and those

00:04:35,040 --> 00:04:38,700
libraries make design decisions that

00:04:36,690 --> 00:04:39,990
might have been good back then but

00:04:38,700 --> 00:04:43,260
they're not design decisions that we

00:04:39,990 --> 00:04:46,100
might make now so hibernate in

00:04:43,260 --> 00:04:49,200
particular predates Django by five years

00:04:46,100 --> 00:04:52,110
it made some decisions that reflected

00:04:49,200 --> 00:04:53,820
how people thought about our ends five

00:04:52,110 --> 00:04:56,610
years between before rails or Django

00:04:53,820 --> 00:04:58,080
came around it doesn't reflect design

00:04:56,610 --> 00:05:01,770
decisions that have been learned about

00:04:58,080 --> 00:05:04,230
ORM design since then the hibernate is

00:05:01,770 --> 00:05:07,080
also really heavily used it's very

00:05:04,230 --> 00:05:09,390
stable it's very reliable and a lot of

00:05:07,080 --> 00:05:11,550
software relies on it you know if you

00:05:09,390 --> 00:05:16,620
want a Java focused IRM you won't get

00:05:11,550 --> 00:05:18,420
fired for selecting hibernate and if you

00:05:16,620 --> 00:05:20,190
want an ORM that's a joy to use in

00:05:18,420 --> 00:05:21,810
Kotlin you're out of luck there are a

00:05:20,190 --> 00:05:23,910
couple of viable AR M's that are out

00:05:21,810 --> 00:05:26,160
there that are designed to be really

00:05:23,910 --> 00:05:28,560
nice to use in Kotlin but they're not

00:05:26,160 --> 00:05:30,480
yet stable JetBrains is working on

00:05:28,560 --> 00:05:32,070
something called exposed it looks like

00:05:30,480 --> 00:05:35,160
it might be a good option in a few years

00:05:32,070 --> 00:05:36,750
time but it's still in an early beta so

00:05:35,160 --> 00:05:38,460
let's go back to hibernate hibernate

00:05:36,750 --> 00:05:40,830
these days it's accessed through a thing

00:05:38,460 --> 00:05:42,810
called the java persistence api the java

00:05:40,830 --> 00:05:44,940
persistence api is an attempt to

00:05:42,810 --> 00:05:47,340
abstract away the details of working

00:05:44,940 --> 00:05:49,830
with specific databases so you can work

00:05:47,340 --> 00:05:51,690
with a generic api instead it's very

00:05:49,830 --> 00:05:55,980
stable hasn't been changed in more than

00:05:51,690 --> 00:05:58,260
ten years so at the core of the JPA is

00:05:55,980 --> 00:06:00,450
the entity manager class the entity

00:05:58,260 --> 00:06:04,260
manager is what represents your

00:06:00,450 --> 00:06:05,940
connection to a database if you wanted

00:06:04,260 --> 00:06:07,920
to get yourself an entity manager you

00:06:05,940 --> 00:06:09,540
might manually write write some

00:06:07,920 --> 00:06:10,620
connection code and get an entity

00:06:09,540 --> 00:06:12,750
manager once you've configured

00:06:10,620 --> 00:06:14,040
everything most of the time you don't do

00:06:12,750 --> 00:06:17,070
that you'll use a configuration

00:06:14,040 --> 00:06:19,920
framework to map it's magic and entity

00:06:17,070 --> 00:06:22,050
manager into being in my case I used

00:06:19,920 --> 00:06:23,640
spring and spring boots you provide some

00:06:22,050 --> 00:06:26,070
configuration instructions to spring

00:06:23,640 --> 00:06:27,450
boots and then you get an entity manager

00:06:26,070 --> 00:06:29,250
that can be injected in all manner of

00:06:27,450 --> 00:06:32,070
places that's the perspective I'm gonna

00:06:29,250 --> 00:06:34,169
be talking on about from here on in so

00:06:32,070 --> 00:06:36,720
once you have an entity manager there's

00:06:34,169 --> 00:06:39,600
two ways out of the box for dealing with

00:06:36,720 --> 00:06:41,700
simple storage operations you get fire

00:06:39,600 --> 00:06:44,070
and find is pretty simple it helps you

00:06:41,700 --> 00:06:44,550
look up database entities by a primary

00:06:44,070 --> 00:06:46,620
key

00:06:44,550 --> 00:06:49,860
you also get persist which lets you

00:06:46,620 --> 00:06:51,540
persist an entity to the database using

00:06:49,860 --> 00:06:53,820
the entity manager to get a thing out of

00:06:51,540 --> 00:06:58,170
the database is very very easy you just

00:06:53,820 --> 00:06:59,760
say hey database find me that thing you

00:06:58,170 --> 00:07:01,350
have to ask the entity manager to find

00:06:59,760 --> 00:07:03,210
you an object which is sort of the

00:07:01,350 --> 00:07:05,310
opposite way of thinking if you're a

00:07:03,210 --> 00:07:07,800
Django or a Rails person where you ask

00:07:05,310 --> 00:07:10,350
the class for an instance of the object

00:07:07,800 --> 00:07:12,630
but it's not a huge step to take to

00:07:10,350 --> 00:07:16,200
think about it the other way around on

00:07:12,630 --> 00:07:18,660
the other hand persist does not work the

00:07:16,200 --> 00:07:20,340
way that you would expect if you get

00:07:18,660 --> 00:07:22,410
given an entity manager you can't

00:07:20,340 --> 00:07:24,660
immediately persist an entity to the

00:07:22,410 --> 00:07:28,110
database because if you have a database

00:07:24,660 --> 00:07:31,910
that requires transactions persist won't

00:07:28,110 --> 00:07:34,860
work persist doesn't work without a

00:07:31,910 --> 00:07:37,170
transaction being opened but the design

00:07:34,860 --> 00:07:40,950
of the API does not make it obvious that

00:07:37,170 --> 00:07:43,140
this is the case so while you can call

00:07:40,950 --> 00:07:45,450
persist at any time in any context

00:07:43,140 --> 00:07:47,430
you'll get a runtime exception if you do

00:07:45,450 --> 00:07:49,110
there's no documentation to say that

00:07:47,430 --> 00:07:50,790
that will be the case and you can't

00:07:49,110 --> 00:07:54,150
really detect it until you test it I

00:07:50,790 --> 00:07:56,520
presume you test things but you get a

00:07:54,150 --> 00:07:58,890
runtime exception so how do you go about

00:07:56,520 --> 00:08:00,570
calling persist the first step if you're

00:07:58,890 --> 00:08:02,010
using spring which I am the easiest way

00:08:00,570 --> 00:08:04,290
to do it is to mark a method as

00:08:02,010 --> 00:08:06,000
transactional this tells spring that the

00:08:04,290 --> 00:08:08,490
method needs to do things that require a

00:08:06,000 --> 00:08:10,020
transaction spring does something I have

00:08:08,490 --> 00:08:12,540
no idea what it is I've tried to read a

00:08:10,020 --> 00:08:14,490
stack trace it's impossible and then

00:08:12,540 --> 00:08:18,060
magically you can call persist inside

00:08:14,490 --> 00:08:20,490
your transactional method sometimes you

00:08:18,060 --> 00:08:23,100
actually need to understand how spring

00:08:20,490 --> 00:08:25,680
injects its transaction management code

00:08:23,100 --> 00:08:29,160
into your code in order to understand

00:08:25,680 --> 00:08:31,260
how to use it so this is how you are

00:08:29,160 --> 00:08:33,900
meant to use a spring transactional

00:08:31,260 --> 00:08:36,780
method so you have a business logic

00:08:33,900 --> 00:08:38,460
class you have a data service there's a

00:08:36,780 --> 00:08:40,140
transactional method inside the data

00:08:38,460 --> 00:08:43,979
service you call from your business

00:08:40,140 --> 00:08:48,089
logic into the transactional method it's

00:08:43,979 --> 00:08:51,240
pretty simple but if you were to call

00:08:48,089 --> 00:08:52,950
from your business logic into a method

00:08:51,240 --> 00:08:55,140
that's not marked as transaction

00:08:52,950 --> 00:08:56,940
and then call your method that is

00:08:55,140 --> 00:08:58,950
transactional from the method that's not

00:08:56,940 --> 00:09:00,950
transactional the transaction doesn't

00:08:58,950 --> 00:09:02,820
get created and you get an exception

00:09:00,950 --> 00:09:05,550
even though your marketing is

00:09:02,820 --> 00:09:07,470
transactional so that's really confusing

00:09:05,550 --> 00:09:10,110
here mark the method is transactional

00:09:07,470 --> 00:09:13,470
but you don't get a transaction so why

00:09:10,110 --> 00:09:16,260
is that the case basically under the

00:09:13,470 --> 00:09:17,430
hood you need to know that when there is

00:09:16,260 --> 00:09:20,070
a method that it's marked as

00:09:17,430 --> 00:09:21,990
transactional like this one is Spring

00:09:20,070 --> 00:09:24,570
doesn't give you the object that you

00:09:21,990 --> 00:09:26,310
think you're going to get spring will

00:09:24,570 --> 00:09:28,200
give you what's called a proxy object

00:09:26,310 --> 00:09:30,090
instead of the original object that you

00:09:28,200 --> 00:09:33,090
think that you're asking for has the

00:09:30,090 --> 00:09:34,410
same interface same methods gets called

00:09:33,090 --> 00:09:37,770
in the same way but it's not the same

00:09:34,410 --> 00:09:39,810
object when you call into the dependency

00:09:37,770 --> 00:09:42,090
that gets injected you actually call a

00:09:39,810 --> 00:09:44,310
method that sets up a transaction and

00:09:42,090 --> 00:09:47,310
then calls the underlying method in the

00:09:44,310 --> 00:09:49,650
underlying class but it only injects

00:09:47,310 --> 00:09:51,420
that transaction management if you call

00:09:49,650 --> 00:09:56,400
into one of the methods that is called

00:09:51,420 --> 00:09:58,590
transactional from outside so using

00:09:56,400 --> 00:10:00,840
transaction using the transactional

00:09:58,590 --> 00:10:03,330
annotation here it's much much easier

00:10:00,840 --> 00:10:05,840
than managing a transaction manually but

00:10:03,330 --> 00:10:08,310
you need to know that specific

00:10:05,840 --> 00:10:10,530
implementation detail to make sure that

00:10:08,310 --> 00:10:12,030
you don't get runtime exceptions when

00:10:10,530 --> 00:10:14,760
you try to do something as simple as

00:10:12,030 --> 00:10:17,490
saving something to a database so

00:10:14,760 --> 00:10:19,770
another problem with the JPA is that

00:10:17,490 --> 00:10:20,940
while find and persist are pretty easy

00:10:19,770 --> 00:10:22,560
to understand

00:10:20,940 --> 00:10:24,600
not that whole transactional business

00:10:22,560 --> 00:10:26,760
notwithstanding it's actually really

00:10:24,600 --> 00:10:30,300
hard to access more general queries

00:10:26,760 --> 00:10:32,670
using the JPA so entity manager gives

00:10:30,300 --> 00:10:34,170
you a method called create query it

00:10:32,670 --> 00:10:37,500
takes a string that is written in a

00:10:34,170 --> 00:10:39,420
query language like SQL and it will

00:10:37,500 --> 00:10:41,550
return an object called a query object

00:10:39,420 --> 00:10:44,130
and that represents the operations that

00:10:41,550 --> 00:10:48,750
you can perform on that query here is a

00:10:44,130 --> 00:10:50,280
selection of the interface of query just

00:10:48,750 --> 00:10:53,010
think about what what you've got there

00:10:50,280 --> 00:10:55,680
for a moment if you write a select query

00:10:53,010 --> 00:10:58,200
you will get the same sort of query

00:10:55,680 --> 00:11:00,600
object as if you write an update query

00:10:58,200 --> 00:11:02,070
which means that you can go create a

00:11:00,600 --> 00:11:04,980
query with the Select and then go

00:11:02,070 --> 00:11:06,060
execute update that will get you an

00:11:04,980 --> 00:11:08,130
exception

00:11:06,060 --> 00:11:09,600
you actually need to call get results

00:11:08,130 --> 00:11:12,030
list which is the thing that will run a

00:11:09,600 --> 00:11:13,650
select query is a select query and if

00:11:12,030 --> 00:11:16,230
you do write an update method you also

00:11:13,650 --> 00:11:17,730
have to make sure that you call execute

00:11:16,230 --> 00:11:21,450
update from within a transactional

00:11:17,730 --> 00:11:23,370
context and then finally if you call the

00:11:21,450 --> 00:11:25,620
correct method for your query you write

00:11:23,370 --> 00:11:28,890
a select query you call get result list

00:11:25,620 --> 00:11:30,840
you still get a list of untyped objects

00:11:28,890 --> 00:11:34,770
rather than a list of things with a

00:11:30,840 --> 00:11:36,900
specific type newer versions of the JPA

00:11:34,770 --> 00:11:39,000
have some support for generics and you

00:11:36,900 --> 00:11:40,860
know create typed query instead that

00:11:39,000 --> 00:11:42,810
lets you specify the underlying type of

00:11:40,860 --> 00:11:45,090
the objects to get returned the

00:11:42,810 --> 00:11:47,160
interface is very similar related things

00:11:45,090 --> 00:11:49,410
that typed but the problem is you can

00:11:47,160 --> 00:11:51,660
you still have to write the right sort

00:11:49,410 --> 00:11:53,670
of query you can assert the query is

00:11:51,660 --> 00:11:55,740
going to run cars even though the SQL

00:11:53,670 --> 00:11:58,770
says this is definitely going to return

00:11:55,740 --> 00:12:00,480
buses there's no way for the compiler to

00:11:58,770 --> 00:12:02,340
detect this you'll get a runtime

00:12:00,480 --> 00:12:05,940
exception if you try to access one of

00:12:02,340 --> 00:12:08,700
the things so in summary the JPA doesn't

00:12:05,940 --> 00:12:10,320
give you an API that lets you that

00:12:08,700 --> 00:12:12,840
guides you towards using it in the right

00:12:10,320 --> 00:12:15,630
way and it relies on you to get type

00:12:12,840 --> 00:12:17,550
safety decisions correct this is very

00:12:15,630 --> 00:12:20,040
much not how Kotlin likes you to think

00:12:17,550 --> 00:12:21,660
about things so this gives us a good

00:12:20,040 --> 00:12:24,810
opportunity for us to think about what

00:12:21,660 --> 00:12:26,940
makes a good Kotlin API so I'm going to

00:12:24,810 --> 00:12:30,570
give you these criteria firstly it's

00:12:26,940 --> 00:12:33,120
easy to perform valid operations so

00:12:30,570 --> 00:12:35,280
things that you should be able to do in

00:12:33,120 --> 00:12:37,980
a given context you can do them and you

00:12:35,280 --> 00:12:40,230
can do them easily if they're an

00:12:37,980 --> 00:12:43,860
operation is flaky the compiler should

00:12:40,230 --> 00:12:46,290
help you make it safe and then if an

00:12:43,860 --> 00:12:48,150
operation is known to be invalid it

00:12:46,290 --> 00:12:51,300
should be impossible to write code that

00:12:48,150 --> 00:12:54,420
will perform that so the JPA violates

00:12:51,300 --> 00:12:56,100
all three of these criteria not only is

00:12:54,420 --> 00:12:57,750
it impossible to persist an object

00:12:56,100 --> 00:12:59,880
without a transaction it's actually

00:12:57,750 --> 00:13:01,920
easier to think you should persist an

00:12:59,880 --> 00:13:03,900
object without a transaction than it is

00:13:01,920 --> 00:13:05,670
to persist an object with a transaction

00:13:03,900 --> 00:13:07,770
which means it's much much easier as an

00:13:05,670 --> 00:13:09,660
unexperienced developer to get runtime

00:13:07,770 --> 00:13:12,240
exceptions in a working database and

00:13:09,660 --> 00:13:15,180
that's not very good for a bonus

00:13:12,240 --> 00:13:17,580
criterion Kotlin likes type safe codes

00:13:15,180 --> 00:13:19,070
so using an api in the way that the api

00:13:17,580 --> 00:13:22,400
presents to you

00:13:19,070 --> 00:13:24,320
be completely typesafe by default so

00:13:22,400 --> 00:13:26,930
after getting frustrated with the JPA

00:13:24,320 --> 00:13:28,670
within : I decide to work on making it

00:13:26,930 --> 00:13:32,300
easier to use and make it feel more like

00:13:28,670 --> 00:13:34,430
natural Kotlin code so the point where I

00:13:32,300 --> 00:13:36,620
started with this was methods that

00:13:34,430 --> 00:13:38,780
insert update or delete database

00:13:36,620 --> 00:13:40,580
entities need to be accessible from

00:13:38,780 --> 00:13:43,760
within a transaction and from nowhere

00:13:40,580 --> 00:13:46,910
else the approach here is to make sure

00:13:43,760 --> 00:13:48,710
that to even see the API for a mutating

00:13:46,910 --> 00:13:51,830
method you need to have open up a

00:13:48,710 --> 00:13:53,990
transaction so to simplify this let's

00:13:51,830 --> 00:13:56,660
look at the simplest to JPA methods find

00:13:53,990 --> 00:13:59,120
and persist so the core of the work that

00:13:56,660 --> 00:14:02,450
I've been doing we have a Data Manager

00:13:59,120 --> 00:14:04,700
which wraps our entity manager so the

00:14:02,450 --> 00:14:06,800
Data Manager is what exposes the find

00:14:04,700 --> 00:14:09,920
method on the underlying entity manager

00:14:06,800 --> 00:14:13,130
and we also have a transaction method

00:14:09,920 --> 00:14:15,830
which constructs a transaction context

00:14:13,130 --> 00:14:18,230
object and we'll accept a receiver

00:14:15,830 --> 00:14:22,160
lambda that operates on that context

00:14:18,230 --> 00:14:24,320
object our run in transaction method

00:14:22,160 --> 00:14:26,660
takes a transaction context it takes a

00:14:24,320 --> 00:14:28,610
block and somehow runs it in that way

00:14:26,660 --> 00:14:30,980
that's a detail that we'll leave alone

00:14:28,610 --> 00:14:32,780
for a bit but basically just understand

00:14:30,980 --> 00:14:33,860
that when you call running transaction

00:14:32,780 --> 00:14:36,350
which is what's called by this

00:14:33,860 --> 00:14:37,970
transaction thing by the time the block

00:14:36,350 --> 00:14:39,890
gets executed you'll be in a transaction

00:14:37,970 --> 00:14:40,340
okay except that that's going to be a

00:14:39,890 --> 00:14:43,040
thing

00:14:40,340 --> 00:14:45,290
so our transaction object is a

00:14:43,040 --> 00:14:47,320
transaction context object is what

00:14:45,290 --> 00:14:49,250
exposes the persist method and

00:14:47,320 --> 00:14:52,190
importantly we're using an internal

00:14:49,250 --> 00:14:53,810
constructor that's means the only way

00:14:52,190 --> 00:14:56,270
you can ever create a transaction

00:14:53,810 --> 00:14:58,370
context object is by using the

00:14:56,270 --> 00:15:00,980
transaction method so you'll note that

00:14:58,370 --> 00:15:03,950
the JPA version of persist returns void

00:15:00,980 --> 00:15:06,080
our version returns the persisted object

00:15:03,950 --> 00:15:08,500
that makes it slightly easier to use in

00:15:06,080 --> 00:15:10,970
cases that will become apparent shortly

00:15:08,500 --> 00:15:13,310
the final thing is that I make use of

00:15:10,970 --> 00:15:15,380
Collins rarefied generics and extension

00:15:13,310 --> 00:15:17,870
methods and this saves us from having to

00:15:15,380 --> 00:15:20,600
explicitly use Java style object

00:15:17,870 --> 00:15:23,210
introspection which JPI relies on quite

00:15:20,600 --> 00:15:25,670
heavily so with that

00:15:23,210 --> 00:15:28,370
pulling an object from the database in

00:15:25,670 --> 00:15:31,640
Java with old busted JPA you'll go

00:15:28,370 --> 00:15:33,620
entity manager dot find the class object

00:15:31,640 --> 00:15:36,170
and then the prime

00:15:33,620 --> 00:15:38,210
with us you'll go data manager find

00:15:36,170 --> 00:15:39,860
class and cave or you can use the

00:15:38,210 --> 00:15:43,010
rarefied generic version which isn't

00:15:39,860 --> 00:15:45,230
data manager dot find with the explicit

00:15:43,010 --> 00:15:48,140
swiping on your variable which i think

00:15:45,230 --> 00:15:49,880
is pretty neat and then instead of

00:15:48,140 --> 00:15:52,070
having to delegate to a separate object

00:15:49,880 --> 00:15:54,920
you can now define transaction

00:15:52,070 --> 00:15:57,260
boundaries using Kotlin blocks if you're

00:15:54,920 --> 00:15:59,300
inside a transaction block you know

00:15:57,260 --> 00:16:01,340
there's a transaction ready to go and

00:15:59,300 --> 00:16:03,020
the other great thing is that because

00:16:01,340 --> 00:16:05,360
our version of persist returns the

00:16:03,020 --> 00:16:07,160
persisted object our transaction blocks

00:16:05,360 --> 00:16:09,440
can be used to pass these entities

00:16:07,160 --> 00:16:11,870
across transaction boundaries whenever

00:16:09,440 --> 00:16:14,990
necessary you can use the convention of

00:16:11,870 --> 00:16:17,090
the last line being the return being the

00:16:14,990 --> 00:16:19,910
return value to persist an object so you

00:16:17,090 --> 00:16:21,530
can go dot create a transaction to

00:16:19,910 --> 00:16:23,480
create something and then returns it and

00:16:21,530 --> 00:16:25,100
then that return value the object that

00:16:23,480 --> 00:16:27,110
you persisted is what gets returned to

00:16:25,100 --> 00:16:30,110
the calling context which i think is

00:16:27,110 --> 00:16:32,630
pretty nice so there is one problem

00:16:30,110 --> 00:16:35,240
however which is that if you want to

00:16:32,630 --> 00:16:37,880
update an object in hibernate using fine

00:16:35,240 --> 00:16:40,430
and persist you need to retrieve the

00:16:37,880 --> 00:16:42,710
object from the database in the same

00:16:40,430 --> 00:16:45,140
transaction context as when you persist

00:16:42,710 --> 00:16:48,680
it so this means that you need to call

00:16:45,140 --> 00:16:52,400
find inside a transaction block but that

00:16:48,680 --> 00:16:54,860
means that find is under a namespace

00:16:52,400 --> 00:16:57,530
that is outside the calling context and

00:16:54,860 --> 00:17:00,830
persist is in a namespace that is inside

00:16:57,530 --> 00:17:02,750
the calling context that's not very nice

00:17:00,830 --> 00:17:05,870
you'd prefer like the complementary

00:17:02,750 --> 00:17:09,110
operations to be at the same level of

00:17:05,870 --> 00:17:11,449
name spacing so the solution that I came

00:17:09,110 --> 00:17:14,000
up with is to extract all of the fetcher

00:17:11,449 --> 00:17:17,449
methods into their own interface called

00:17:14,000 --> 00:17:19,910
has fetcher methods at this point data

00:17:17,449 --> 00:17:22,579
manager can implement that interface and

00:17:19,910 --> 00:17:25,250
then we can pass our data manager into

00:17:22,579 --> 00:17:26,870
our transaction context and use that

00:17:25,250 --> 00:17:29,120
data manager as a delegate

00:17:26,870 --> 00:17:31,520
implementation at that point our

00:17:29,120 --> 00:17:33,380
transaction context automatically

00:17:31,520 --> 00:17:35,660
implements all of the public fetcher

00:17:33,380 --> 00:17:38,210
methods as well as all the mutation

00:17:35,660 --> 00:17:39,590
methods and that means you can go with

00:17:38,210 --> 00:17:42,350
fine and update that looks slightly

00:17:39,590 --> 00:17:43,730
clumsy it's looking really nice and

00:17:42,350 --> 00:17:46,580
clean and easy to use

00:17:43,730 --> 00:17:48,919
Kotlin makes it really easy to organize

00:17:46,580 --> 00:17:51,200
our our interfaces much more

00:17:48,919 --> 00:17:53,750
conveniently like that and that delegate

00:17:51,200 --> 00:17:57,320
implementation thing is like three extra

00:17:53,750 --> 00:18:00,019
characters it's pretty great so the

00:17:57,320 --> 00:18:03,380
question that I I left open which is how

00:18:00,019 --> 00:18:05,059
do we actually get a transaction it's

00:18:03,380 --> 00:18:06,980
actually pretty simple we just create a

00:18:05,059 --> 00:18:07,760
component with a spring transactional

00:18:06,980 --> 00:18:09,799
method in it

00:18:07,760 --> 00:18:12,230
so this thing that I don't particularly

00:18:09,799 --> 00:18:15,440
like we're still using one of them but

00:18:12,230 --> 00:18:17,419
there is only one of them the only thing

00:18:15,440 --> 00:18:19,730
our transactional method does is run

00:18:17,419 --> 00:18:22,490
whatever block of code we pass to it so

00:18:19,730 --> 00:18:24,169
now we just have a single single

00:18:22,490 --> 00:18:26,360
transactional method back in Data

00:18:24,169 --> 00:18:28,519
Manager we can call across our class

00:18:26,360 --> 00:18:30,830
bank boundaries into that transactional

00:18:28,519 --> 00:18:35,090
method which opens and manages the

00:18:30,830 --> 00:18:36,320
transaction for us if you don't want to

00:18:35,090 --> 00:18:37,850
use spring you can write your own

00:18:36,320 --> 00:18:41,690
transaction management code if you

00:18:37,850 --> 00:18:43,340
wanted to but for us that we know that

00:18:41,690 --> 00:18:45,529
spring has done hard work knowing how to

00:18:43,340 --> 00:18:46,700
implement transactions transactions are

00:18:45,529 --> 00:18:49,730
kind of difficult to wrap your head

00:18:46,700 --> 00:18:51,639
around so we use Springs thing but we

00:18:49,730 --> 00:18:55,580
only have one transactional method which

00:18:51,639 --> 00:18:58,010
reduces complexity quite a lot so in

00:18:55,580 --> 00:19:00,500
summary the big realization for us was

00:18:58,010 --> 00:19:02,630
to separate our retrieval and mutation

00:19:00,500 --> 00:19:04,909
methods into separate interfaces and

00:19:02,630 --> 00:19:07,309
then strictly control the availability

00:19:04,909 --> 00:19:09,289
of that mutation interface and then

00:19:07,309 --> 00:19:11,450
finally our delegate interfaces helped

00:19:09,289 --> 00:19:14,720
us make that API inside transaction

00:19:11,450 --> 00:19:17,149
blocks a lot easy to understand so

00:19:14,720 --> 00:19:20,600
finally let's talk about making our

00:19:17,149 --> 00:19:22,580
query API more Kotlin friendly as a

00:19:20,600 --> 00:19:24,230
reminder we have find and persist

00:19:22,580 --> 00:19:26,000
we've already sorted those things out

00:19:24,230 --> 00:19:28,429
they're okay they work fine they're type

00:19:26,000 --> 00:19:30,950
safe and now we have an API that makes

00:19:28,429 --> 00:19:34,130
transaction boundaries clear so we can't

00:19:30,950 --> 00:19:35,750
use it incorrectly for the most part but

00:19:34,130 --> 00:19:37,399
if we wanted to expose the rest of

00:19:35,750 --> 00:19:39,830
entity managers through this method we'd

00:19:37,399 --> 00:19:42,679
still end up with these non type safe

00:19:39,830 --> 00:19:44,510
complex queries you the developer have

00:19:42,679 --> 00:19:47,240
to do work to make sure your queries are

00:19:44,510 --> 00:19:49,760
type safe and then all of your consumers

00:19:47,240 --> 00:19:51,559
get to make use of your type safety so

00:19:49,760 --> 00:19:53,629
you who are writing the persistence

00:19:51,559 --> 00:19:56,600
layer have to do all the work in terms

00:19:53,629 --> 00:19:59,490
of making something type safe

00:19:56,600 --> 00:20:01,559
the solution for us isn't it's actually

00:19:59,490 --> 00:20:05,880
a Java library it's called query DSL

00:20:01,559 --> 00:20:07,559
it's a typesafe query API for the JPA to

00:20:05,880 --> 00:20:10,140
use it in a Kotlin project if you're

00:20:07,559 --> 00:20:12,840
using Gradle importing it into your

00:20:10,140 --> 00:20:15,630
project as simple as adding the JPS that

00:20:12,840 --> 00:20:18,210
the query DSL support library as well as

00:20:15,630 --> 00:20:22,320
their annotation processing library and

00:20:18,210 --> 00:20:24,510
then rebuilding your project so say we

00:20:22,320 --> 00:20:28,770
have a select query that operates on a

00:20:24,510 --> 00:20:32,070
table called items the items table will

00:20:28,770 --> 00:20:34,559
have a matching JPA entity class when

00:20:32,070 --> 00:20:36,659
you build your project query DSL will

00:20:34,559 --> 00:20:39,899
perform some cogeneration under the hood

00:20:36,659 --> 00:20:42,000
it will produce a matching query DSL

00:20:39,899 --> 00:20:45,029
helper class that maps out all of the

00:20:42,000 --> 00:20:47,100
fields on your entity this helper class

00:20:45,029 --> 00:20:49,529
implements a thing called entity path

00:20:47,100 --> 00:20:51,450
you can see that there and the type

00:20:49,529 --> 00:20:53,490
parameter of that interface helps the

00:20:51,450 --> 00:20:57,570
type checker figure out the return type

00:20:53,490 --> 00:20:58,789
of your queries query DSL provides you

00:20:57,570 --> 00:21:02,549
with a couple of methods

00:20:58,789 --> 00:21:05,039
selectfrom produces a typed JPA query

00:21:02,549 --> 00:21:07,830
based on the parameter type of our

00:21:05,039 --> 00:21:11,100
entity path and then fetched on a type

00:21:07,830 --> 00:21:15,149
JP a query returns a list of that type

00:21:11,100 --> 00:21:17,309
and so if you put all that together our

00:21:15,149 --> 00:21:20,940
SQL query from before looks a bit like

00:21:17,309 --> 00:21:24,120
this in query DSL JP a query factory

00:21:20,940 --> 00:21:26,190
select from is the same as select where

00:21:24,120 --> 00:21:27,960
is the same as where and then fetch is

00:21:26,190 --> 00:21:31,289
the thing that goes and executes that

00:21:27,960 --> 00:21:33,029
query you can use a static import so you

00:21:31,289 --> 00:21:34,590
don't have to qualify the helper objects

00:21:33,029 --> 00:21:37,620
name this gets rid of that queue item

00:21:34,590 --> 00:21:41,070
and stuff now because you've called

00:21:37,620 --> 00:21:42,779
select from select from item the type

00:21:41,070 --> 00:21:44,580
checker knows that the query that you're

00:21:42,779 --> 00:21:47,309
constructing here is going to return an

00:21:44,580 --> 00:21:50,100
item so it's much much harder to break

00:21:47,309 --> 00:21:52,320
type safety in this case until you start

00:21:50,100 --> 00:21:57,240
dealing with joins but at that point you

00:21:52,320 --> 00:21:58,830
know joins a hard so update methods they

00:21:57,240 --> 00:22:00,899
also look similar you call update

00:21:58,830 --> 00:22:03,899
instead of select from and you use a set

00:22:00,899 --> 00:22:05,610
Clause to change fields so query DSL

00:22:03,899 --> 00:22:07,620
gives you this type safe query language

00:22:05,610 --> 00:22:09,970
that's easier to reason with than

00:22:07,620 --> 00:22:11,530
writing raw query

00:22:09,970 --> 00:22:14,290
but the problem is that these still

00:22:11,530 --> 00:22:16,030
aren't mutations safe query dear sales

00:22:14,290 --> 00:22:17,980
query Factory has the same issues of the

00:22:16,030 --> 00:22:20,800
JPA itself which is that update and

00:22:17,980 --> 00:22:23,410
delete queries are still exposed when

00:22:20,800 --> 00:22:25,300
it's not safe to call them so what's the

00:22:23,410 --> 00:22:26,700
solution here the solution here is to do

00:22:25,300 --> 00:22:29,560
the same thing that we did earlier

00:22:26,700 --> 00:22:32,140
rather than using the JPA query factory

00:22:29,560 --> 00:22:34,600
that query dsl provides directly we

00:22:32,140 --> 00:22:37,630
expose our select from method from our

00:22:34,600 --> 00:22:39,550
data manager and our mutation methods

00:22:37,630 --> 00:22:42,430
get exposed in our transaction context

00:22:39,550 --> 00:22:44,590
class so suddenly you can't use update

00:22:42,430 --> 00:22:48,160
methods outside of transactions and it's

00:22:44,590 --> 00:22:49,780
great so the final thing we did was to

00:22:48,160 --> 00:22:51,070
use some Kotlin features to make our

00:22:49,780 --> 00:22:54,310
query methods look a bit more natural

00:22:51,070 --> 00:22:56,350
because as query dsl queries get more

00:22:54,310 --> 00:23:01,450
complex you start seeing lots of dots

00:22:56,350 --> 00:23:03,640
and parentheses and quick SQL doesn't

00:23:01,450 --> 00:23:07,240
have lots of dots and parentheses or at

00:23:03,640 --> 00:23:09,580
least not nearly as many as that and SQL

00:23:07,240 --> 00:23:12,490
is actually pretty natural to read this

00:23:09,580 --> 00:23:14,200
once you start getting complicated isn't

00:23:12,490 --> 00:23:17,020
as hard to read it doesn't look much

00:23:14,200 --> 00:23:19,540
like a query but Kotlin has support for

00:23:17,020 --> 00:23:21,610
infix operator functions and better yet

00:23:19,540 --> 00:23:26,410
you can write infix operator functions

00:23:21,610 --> 00:23:29,740
as extension methods so our code can now

00:23:26,410 --> 00:23:32,770
look like this the process for creating

00:23:29,740 --> 00:23:34,270
these operators like our EQ for checking

00:23:32,770 --> 00:23:36,070
that something is equal it's a bit

00:23:34,270 --> 00:23:40,210
tedious you have to do them one at a

00:23:36,070 --> 00:23:42,780
time but from a code readability point

00:23:40,210 --> 00:23:45,940
of view it's it's been paying off for us

00:23:42,780 --> 00:23:48,550
so in summary query DSL even though it's

00:23:45,940 --> 00:23:51,700
a Java library makes our database code

00:23:48,550 --> 00:23:53,380
look a lot more typesafe but we needed

00:23:51,700 --> 00:23:55,150
to do work still to separate those

00:23:53,380 --> 00:23:57,220
selection our reading methods and our

00:23:55,150 --> 00:23:59,590
mutation methods and then finally our

00:23:57,220 --> 00:24:01,540
use of infix operators in Kotlin helped

00:23:59,590 --> 00:24:04,240
make our query language much more

00:24:01,540 --> 00:24:06,070
natural so that's a quick overview

00:24:04,240 --> 00:24:08,320
behind the reasoning of the changes we

00:24:06,070 --> 00:24:12,160
made let's talk about a bit how far we

00:24:08,320 --> 00:24:15,040
got so firstly our work is incomplete in

00:24:12,160 --> 00:24:17,620
our project exposing API is in our data

00:24:15,040 --> 00:24:20,410
management sort of happens as we need to

00:24:17,620 --> 00:24:22,420
write those those methods similarly we

00:24:20,410 --> 00:24:22,680
don't add in fixed operators until we

00:24:22,420 --> 00:24:24,210
need

00:24:22,680 --> 00:24:27,840
them so we haven't implemented all of

00:24:24,210 --> 00:24:31,170
the the query DSL operators that we need

00:24:27,840 --> 00:24:33,180
to do whatever query would like but as

00:24:31,170 --> 00:24:35,070
we use them they appear and most of the

00:24:33,180 --> 00:24:37,320
queries well every query I've written

00:24:35,070 --> 00:24:38,970
has in fixed operators at this point so

00:24:37,320 --> 00:24:41,310
our work is piecemeal but at this point

00:24:38,970 --> 00:24:42,690
the effort to add these features is so

00:24:41,310 --> 00:24:46,260
low that we can just do it incrementally

00:24:42,690 --> 00:24:48,480
as we need to at the moment I don't have

00:24:46,260 --> 00:24:50,460
any code in online to show you our

00:24:48,480 --> 00:24:54,030
implementation is very project specific

00:24:50,460 --> 00:24:55,920
this talk sort of shows what it would

00:24:54,030 --> 00:24:58,470
look like if I release it as open source

00:24:55,920 --> 00:25:00,330
and might do it at some point and that

00:24:58,470 --> 00:25:02,010
would make it generic and reusable by

00:25:00,330 --> 00:25:04,770
other projects and not just within our

00:25:02,010 --> 00:25:06,510
four sites but hopefully for you as well

00:25:04,770 --> 00:25:08,580
and finally our transaction support

00:25:06,510 --> 00:25:11,430
requires you to be using spring and

00:25:08,580 --> 00:25:15,480
spring boots and really this shouldn't

00:25:11,430 --> 00:25:17,640
be to your liking so finally I'm gonna

00:25:15,480 --> 00:25:19,710
make it generic and reusable potentially

00:25:17,640 --> 00:25:21,600
open sources so you can take ideas build

00:25:19,710 --> 00:25:24,780
upon them improve your JPA code without

00:25:21,600 --> 00:25:26,880
fighting the same battles as we did a

00:25:24,780 --> 00:25:29,070
reminder alpha sites is hiring if doing

00:25:26,880 --> 00:25:30,960
interesting back in engineering work in

00:25:29,070 --> 00:25:33,150
Kotlin in a really fascinating field is

00:25:30,960 --> 00:25:35,360
something interesting to you you should

00:25:33,150 --> 00:25:37,530
have a chat with myself matt nico

00:25:35,360 --> 00:25:41,400
there's a bunch of us here come and have

00:25:37,530 --> 00:25:45,469
a chat thank you very much

00:25:41,400 --> 00:25:45,469

YouTube URL: https://www.youtube.com/watch?v=wIOnB1nviGg


