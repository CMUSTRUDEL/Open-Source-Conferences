Title: Virtual EmberConf 2020: AST: the Secret Weapon to Transform a Codebase by Sophia Wang
Publication date: 2020-03-26
Playlist: EmberConf 2020
Description: 
	AST: the Secret Weapon to Transform a Codebase by Sophia Wang

Ever wonder what is metaprogramming? Ever wonder how a machine translates ember code into the websites that you interact with? Want to update your codebase to a newer syntax without going through editing every line? Curious about what linters, codemod, compilers, etc. have in common?

Abstract Syntax Tree (AST)! We'll aim to demystify AST in this talk. You'll realize itâ€™s really fun and cool, and you can leverage this concept to create your own tools!
Captions: 
	00:00:01,270 --> 00:00:24,520
[Music]

00:00:20,670 --> 00:00:26,140
okay hi everyone my name is Sofia hope

00:00:24,520 --> 00:00:29,110
you had a good lunch and you have a good

00:00:26,140 --> 00:00:32,529
conference so far today I'm going to

00:00:29,110 --> 00:00:34,600
talk about abstract syntax tree so to

00:00:32,529 --> 00:00:35,790
start off I'll introduce a little bit

00:00:34,600 --> 00:00:38,699
about myself

00:00:35,790 --> 00:00:40,840
right now I worked for LinkedIn learning

00:00:38,699 --> 00:00:43,300
just in case you don't know

00:00:40,840 --> 00:00:46,330
LinkedIn learning is a platform where we

00:00:43,300 --> 00:00:50,500
offer video courses in fields such as

00:00:46,330 --> 00:00:53,650
technology creative and business taught

00:00:50,500 --> 00:00:56,170
by industry experts I started as selling

00:00:53,650 --> 00:01:00,580
calm and then later it was acquired by

00:00:56,170 --> 00:01:04,510
LinkedIn I'd LinkedIn learning I get my

00:01:00,580 --> 00:01:07,720
first exposure in a member before ember

00:01:04,510 --> 00:01:11,170
I was working at this startup called

00:01:07,720 --> 00:01:13,479
spoke where spoke was trying to help

00:01:11,170 --> 00:01:16,180
employee to work more efficient by using

00:01:13,479 --> 00:01:19,119
machine learning to manage internal

00:01:16,180 --> 00:01:24,479
requests there I was working full stack

00:01:19,119 --> 00:01:24,479
I used tools such as nodejs and angular

00:01:24,719 --> 00:01:31,119
so to start off I want to share kind of

00:01:28,780 --> 00:01:33,729
two problems that I encountered this

00:01:31,119 --> 00:01:37,780
past year that really leads me very

00:01:33,729 --> 00:01:39,939
interested in the this topic so what's

00:01:37,780 --> 00:01:45,609
the problem I encountered this past year

00:01:39,939 --> 00:01:50,710
was a problem to book and its syntax

00:01:45,609 --> 00:01:54,579
awesome at scale for example I was

00:01:50,710 --> 00:01:57,340
trying to wrap around all of our

00:01:54,579 --> 00:02:01,270
requests wrapped around in this like

00:01:57,340 --> 00:02:03,520
global air handler to why I first

00:02:01,270 --> 00:02:06,249
started working on this project my first

00:02:03,520 --> 00:02:07,929
thought is I'll just do it manually but

00:02:06,249 --> 00:02:11,260
then when I started looking at it there

00:02:07,929 --> 00:02:13,569
were thousands or maybe like how many

00:02:11,260 --> 00:02:17,560
hundreds of requests across our code

00:02:13,569 --> 00:02:21,670
base it's gonna be a lot of code that I

00:02:17,560 --> 00:02:24,880
need to like edit and it's gonna take

00:02:21,670 --> 00:02:27,150
days and it's tedious so I thought about

00:02:24,880 --> 00:02:29,370
a second solution which is to use radix

00:02:27,150 --> 00:02:33,090
and I try

00:02:29,370 --> 00:02:35,970
and I wrote the most complicated reg X

00:02:33,090 --> 00:02:39,780
in my life and they solved about half

00:02:35,970 --> 00:02:42,629
the problem for other half reg X can

00:02:39,780 --> 00:02:44,510
just simply cannot do it and wreck X

00:02:42,629 --> 00:02:48,599
especially can't handle a situation

00:02:44,510 --> 00:02:51,140
where the lines the kind of a request

00:02:48,599 --> 00:02:54,209
called that out lasted a couple of lines

00:02:51,140 --> 00:02:56,099
reg X does really well when so single

00:02:54,209 --> 00:02:59,659
line but when it's like a couple of

00:02:56,099 --> 00:03:02,579
lines it doesn't do as a fish enough job

00:02:59,659 --> 00:03:05,670
so that's when I started looking into

00:03:02,579 --> 00:03:10,500
code mod and it made up my life is so

00:03:05,670 --> 00:03:13,440
much better and I was able to transform

00:03:10,500 --> 00:03:16,879
a lot of the code in recode base using

00:03:13,440 --> 00:03:19,140
code mod in just couple of days of work

00:03:16,879 --> 00:03:21,209
so that's the first problem that I

00:03:19,140 --> 00:03:24,799
encounter the second problem I

00:03:21,209 --> 00:03:27,000
encountered started from observations I

00:03:24,799 --> 00:03:29,180
realized we have a lot of code

00:03:27,000 --> 00:03:33,419
commissions in your routine and you

00:03:29,180 --> 00:03:36,900
would see that code reviewers or one

00:03:33,419 --> 00:03:40,919
review code I like we're always trying

00:03:36,900 --> 00:03:43,620
to enforce those conventions sometimes

00:03:40,919 --> 00:03:46,200
I'd feel bad of pointing them out and as

00:03:43,620 --> 00:03:48,690
people who submit code I also feel bad

00:03:46,200 --> 00:03:51,329
of making those mistakes but sometimes

00:03:48,690 --> 00:03:55,799
they're just hard to catch especially

00:03:51,329 --> 00:03:58,230
why I'm trying in a rush it's hard so I

00:03:55,799 --> 00:04:00,989
was wondering if there's a way to

00:03:58,230 --> 00:04:05,160
automate this process and that's why I

00:04:00,989 --> 00:04:08,609
looked into creating a custom linking

00:04:05,160 --> 00:04:12,269
rule and then you also make my I think

00:04:08,609 --> 00:04:15,120
my team's life so much better where we

00:04:12,269 --> 00:04:16,949
can identify problems before it's been

00:04:15,120 --> 00:04:19,590
pointing out to other people and I

00:04:16,949 --> 00:04:21,889
shortened our kind of problem-solving

00:04:19,590 --> 00:04:25,110
cycle it was great

00:04:21,889 --> 00:04:29,160
so from this to problems and those two

00:04:25,110 --> 00:04:32,370
tools I used I realize there both of

00:04:29,160 --> 00:04:35,870
them somehow have this very similar

00:04:32,370 --> 00:04:39,630
underlying way to solve a problem that

00:04:35,870 --> 00:04:42,630
is involved called manipulation and

00:04:39,630 --> 00:04:43,200
transformation and that's what I want to

00:04:42,630 --> 00:04:46,440
talk

00:04:43,200 --> 00:04:51,600
talk to you about today it's to how to

00:04:46,440 --> 00:04:54,930
do it how to just use that tool and make

00:04:51,600 --> 00:04:57,780
your life easier as a developer so to

00:04:54,930 --> 00:05:00,600
start with talking about kind of that

00:04:57,780 --> 00:05:04,800
underlying concept behind them I'm going

00:05:00,600 --> 00:05:06,980
to start with a simple analogy if you

00:05:04,800 --> 00:05:10,620
ever trying to learn different language

00:05:06,980 --> 00:05:12,030
you would always start with probably why

00:05:10,620 --> 00:05:14,160
don't you think first thing you learn

00:05:12,030 --> 00:05:17,850
about vocabulary second thing you will

00:05:14,160 --> 00:05:23,130
learn about grammar you'll learn things

00:05:17,850 --> 00:05:25,320
like Apple is a noun is a subject you

00:05:23,130 --> 00:05:30,170
have sentence you need a subject verb

00:05:25,320 --> 00:05:34,440
and noun if I say a sentence like AI

00:05:30,170 --> 00:05:38,220
Apple some of you just don't understand

00:05:34,440 --> 00:05:41,550
like what does that mean understanding

00:05:38,220 --> 00:05:43,020
grammar behind the language enable

00:05:41,550 --> 00:05:46,140
people to communicate more efficiently

00:05:43,020 --> 00:05:50,670
and enable people to understand each

00:05:46,140 --> 00:05:55,260
other better and how does this relate it

00:05:50,670 --> 00:05:58,170
to our daily life as a developer similar

00:05:55,260 --> 00:06:01,860
to speaking of language writing code is

00:05:58,170 --> 00:06:04,200
very similar where if you understand if

00:06:01,860 --> 00:06:07,530
we can understand how the code are

00:06:04,200 --> 00:06:11,400
working behind the scene and be really

00:06:07,530 --> 00:06:14,040
familiar with the grammar behind it we

00:06:11,400 --> 00:06:15,840
are able to do so much more things with

00:06:14,040 --> 00:06:21,980
the code that we write every day and

00:06:15,840 --> 00:06:23,850
that's become a very efficient developer

00:06:21,980 --> 00:06:28,470
so that's what I'm going to talk about

00:06:23,850 --> 00:06:32,100
today to help you understand better of

00:06:28,470 --> 00:06:33,840
the underlying lines syntax and the

00:06:32,100 --> 00:06:37,350
underlying structure behind the code

00:06:33,840 --> 00:06:39,330
that you write every day so to start off

00:06:37,350 --> 00:06:43,770
I'll go a little bit more in depth about

00:06:39,330 --> 00:06:46,680
the tool the productivity tools that

00:06:43,770 --> 00:06:49,430
were my encounter any ember and from

00:06:46,680 --> 00:06:52,050
there I'll point out to you this

00:06:49,430 --> 00:06:55,170
underlying concept abstract syntax tree

00:06:52,050 --> 00:06:55,980
behind them and then I'll talk about how

00:06:55,170 --> 00:06:58,980
you can apply

00:06:55,980 --> 00:07:07,290
at track syntax tree and use it in your

00:06:58,980 --> 00:07:09,180
future work so to start off I'll go a

00:07:07,290 --> 00:07:10,860
little bit more in depth into some of

00:07:09,180 --> 00:07:16,350
the tools that I may have mentioned

00:07:10,860 --> 00:07:18,900
before the first is linter what linter

00:07:16,350 --> 00:07:22,800
does is it catches area and point out

00:07:18,900 --> 00:07:26,730
errors as you're developing it can often

00:07:22,800 --> 00:07:29,850
see as a code editor plugin or like as a

00:07:26,730 --> 00:07:33,060
pre-commit hook I'll start with an

00:07:29,850 --> 00:07:39,720
example of disallowing unreachable code

00:07:33,060 --> 00:07:45,030
as part of a yes linter rule so for this

00:07:39,720 --> 00:07:48,210
rule if you have a line that's written

00:07:45,030 --> 00:07:52,260
after the return statement like

00:07:48,210 --> 00:07:57,240
assigning of value the code editor will

00:07:52,260 --> 00:07:59,520
barf at you for making this mistake this

00:07:57,240 --> 00:08:02,280
seems like a simple mistake a simple

00:07:59,520 --> 00:08:04,530
like problem to solve like you just

00:08:02,280 --> 00:08:09,980
check what comes after return and that's

00:08:04,530 --> 00:08:14,070
it but it's actually a lot more complex

00:08:09,980 --> 00:08:19,140
because if both the same line return

00:08:14,070 --> 00:08:21,480
value equals to 2 how would the linter

00:08:19,140 --> 00:08:25,380
determine that it's after return but not

00:08:21,480 --> 00:08:28,080
before return how is that position

00:08:25,380 --> 00:08:30,000
determined and how does linter know the

00:08:28,080 --> 00:08:33,720
particular syntax like the context

00:08:30,000 --> 00:08:36,740
around that particular line that's some

00:08:33,720 --> 00:08:39,900
questions that will be answered later

00:08:36,740 --> 00:08:43,320
but for the next thing I'm going to look

00:08:39,900 --> 00:08:44,880
at another tool code mot that I

00:08:43,320 --> 00:08:46,590
mentioned a little bit before and I

00:08:44,880 --> 00:08:47,360
wanted to go a little bit more in depth

00:08:46,590 --> 00:08:50,850
into it

00:08:47,360 --> 00:08:53,940
so code may enable us to poke edit

00:08:50,850 --> 00:08:56,870
syntax within your code base a lot of us

00:08:53,940 --> 00:09:00,860
may have went through the transition of

00:08:56,870 --> 00:09:04,860
upgrading ember 3.4 and trying to get to

00:09:00,860 --> 00:09:06,259
the ember octane to do that you need to

00:09:04,860 --> 00:09:09,889
convert a lot of

00:09:06,259 --> 00:09:12,949
the curly braces syntax in your template

00:09:09,889 --> 00:09:15,559
into angle brackets and that's what code

00:09:12,949 --> 00:09:17,660
ma can do it automatically not only

00:09:15,559 --> 00:09:22,009
convert the curly brackets into angle

00:09:17,660 --> 00:09:25,279
bracket and it has add symbols in front

00:09:22,009 --> 00:09:29,329
of the arguments and skips attributes

00:09:25,279 --> 00:09:32,959
such as class code mod here is really

00:09:29,329 --> 00:09:34,729
impressive because it not only added

00:09:32,959 --> 00:09:38,899
things in bulk and it's able to

00:09:34,729 --> 00:09:44,209
distinguish some of like a very similar

00:09:38,899 --> 00:09:46,819
syntax for example in the original code

00:09:44,209 --> 00:09:48,859
the curly braces version in three point

00:09:46,819 --> 00:09:55,429
four you would have some text such as

00:09:48,859 --> 00:09:58,279
curly braces country town name and code

00:09:55,429 --> 00:10:00,319
mod is able to distinguish this curly

00:09:58,279 --> 00:10:05,269
braces with the curly braces that's

00:10:00,319 --> 00:10:08,959
wrapped around super - selects curly

00:10:05,269 --> 00:10:11,779
braces and they decided to convert the

00:10:08,959 --> 00:10:16,429
curly braces right next to super dashes

00:10:11,779 --> 00:10:18,799
alike but then skip the curly braces

00:10:16,429 --> 00:10:21,079
around the country dot name that's a

00:10:18,799 --> 00:10:23,929
hard problem to solve in order to solve

00:10:21,079 --> 00:10:26,739
it code mod also needs to learn to know

00:10:23,929 --> 00:10:32,509
the context surrounding those two lines

00:10:26,739 --> 00:10:34,309
and similar to winter those are very

00:10:32,509 --> 00:10:38,119
similar problems that it needs to solve

00:10:34,309 --> 00:10:45,350
and I'm going to talk in a little bit

00:10:38,119 --> 00:10:46,730
later of how this problem is solved for

00:10:45,350 --> 00:10:51,799
the next thing I'm going to talk about

00:10:46,730 --> 00:10:54,109
the third tool transpiler the reason why

00:10:51,799 --> 00:10:57,139
I want to look at it is even though this

00:10:54,109 --> 00:11:00,459
tool you may not be actively using it

00:10:57,139 --> 00:11:03,789
but it's probably somewhere in your

00:11:00,459 --> 00:11:07,539
dependency you probably have this as a

00:11:03,789 --> 00:11:11,689
package in your in your project

00:11:07,539 --> 00:11:15,199
what transpiler do is for let's say for

00:11:11,689 --> 00:11:17,689
example Babel what it does is a comfort

00:11:15,199 --> 00:11:19,820
es6 code into backward compatible

00:11:17,689 --> 00:11:23,450
version that can run any browser

00:11:19,820 --> 00:11:25,400
such as Chrome or ie it saves us

00:11:23,450 --> 00:11:27,530
developers so much more time from

00:11:25,400 --> 00:11:32,300
writing code that's particular to our

00:11:27,530 --> 00:11:36,980
browser so I want to look at a specific

00:11:32,300 --> 00:11:38,210
example that babo does in this

00:11:36,980 --> 00:11:41,600
particular example

00:11:38,210 --> 00:11:45,170
bab-oh is kind of a converting the fat

00:11:41,600 --> 00:11:51,680
arrow syntax into a regular function

00:11:45,170 --> 00:11:54,200
syntax and in fact not only from the fat

00:11:51,680 --> 00:11:57,650
arrow to kind of backward compatible

00:11:54,200 --> 00:12:00,080
version transpiler also able to do the

00:11:57,650 --> 00:12:02,150
other way around it can convert older

00:12:00,080 --> 00:12:07,160
version of syntax to the new version of

00:12:02,150 --> 00:12:09,890
syntax this is definitely sure a very

00:12:07,160 --> 00:12:13,190
beneficial tool to be included in our

00:12:09,890 --> 00:12:16,280
repository by similar to code mod and

00:12:13,190 --> 00:12:19,040
linter transpiler also needs to solve a

00:12:16,280 --> 00:12:22,130
lot of problems in order to get to where

00:12:19,040 --> 00:12:26,690
it is one important problem is also very

00:12:22,130 --> 00:12:30,980
similar is how does they know where is

00:12:26,690 --> 00:12:34,910
the ending of a syntax that is trying to

00:12:30,980 --> 00:12:39,050
convert how does they know that when

00:12:34,910 --> 00:12:43,070
it's converting a fat arrow to a regular

00:12:39,050 --> 00:12:45,440
function that n plus 1 at the end of n

00:12:43,070 --> 00:12:47,840
plus 1 that's where is supposed to wrap

00:12:45,440 --> 00:12:54,230
around the function around instead of

00:12:47,840 --> 00:12:58,340
this whole entire item alright so I've

00:12:54,230 --> 00:13:00,530
been throwing a lot of questions at you

00:12:58,340 --> 00:13:03,400
and maybe you've been curious what's the

00:13:00,530 --> 00:13:05,960
answer so for all of those problems have

00:13:03,400 --> 00:13:09,040
all of those tools have very similar

00:13:05,960 --> 00:13:11,480
problems to solve which is to identify a

00:13:09,040 --> 00:13:15,770
contact surrounding a particular line of

00:13:11,480 --> 00:13:19,330
syntax how do they do it the answer is

00:13:15,770 --> 00:13:19,330
abstract syntax tree

00:13:19,920 --> 00:13:24,880
abstract syntax tree is basically a tree

00:13:22,630 --> 00:13:28,329
structure the highlights most important

00:13:24,880 --> 00:13:30,850
syntax of a language to understand

00:13:28,329 --> 00:13:32,920
abstract syntax tree well we had to

00:13:30,850 --> 00:13:36,459
start with the most basic concept of

00:13:32,920 --> 00:13:40,329
tree and then see how the concepts

00:13:36,459 --> 00:13:47,730
evolved from a tree to abstract syntax

00:13:40,329 --> 00:13:51,130
tree so what is a tree data structure

00:13:47,730 --> 00:13:54,610
tree is basically our bunch of nodes

00:13:51,130 --> 00:13:57,930
that are connected by edges if you are

00:13:54,610 --> 00:14:00,579
not familiar with this concept I linked

00:13:57,930 --> 00:14:03,790
article at the bottom of the slide and

00:14:00,579 --> 00:14:07,930
feel free to check it out after the

00:14:03,790 --> 00:14:09,910
presentation so basically tree is very

00:14:07,930 --> 00:14:13,180
useful in computer science and it's

00:14:09,910 --> 00:14:14,980
always adapt to it's widely used and

00:14:13,180 --> 00:14:18,160
it's may adapt to very different forms

00:14:14,980 --> 00:14:23,110
for particular problems we're trying to

00:14:18,160 --> 00:14:28,779
solve so for example we have heap trees

00:14:23,110 --> 00:14:30,760
we use heap trees to store memories in

00:14:28,779 --> 00:14:33,220
order to solve the problem of encoding

00:14:30,760 --> 00:14:35,680
decoding people come up with binary

00:14:33,220 --> 00:14:37,750
trees because that's the kind of a data

00:14:35,680 --> 00:14:40,839
structure that solve a problem

00:14:37,750 --> 00:14:42,850
particularly well what if we want to

00:14:40,839 --> 00:14:47,940
solve the problem for representing a

00:14:42,850 --> 00:14:50,740
language that's what it comes parse tree

00:14:47,940 --> 00:14:53,050
so you can think of parse tree as

00:14:50,740 --> 00:14:56,680
basically making a grammatical structure

00:14:53,050 --> 00:15:01,660
of a sentence on to a tree for example

00:14:56,680 --> 00:15:03,670
when we have formula 3 times 4 plus 2 if

00:15:01,660 --> 00:15:05,680
we map it on to a tree it would look

00:15:03,670 --> 00:15:07,029
something like this so it's a literal

00:15:05,680 --> 00:15:09,880
translation of this grammatical

00:15:07,029 --> 00:15:12,910
structure you can see in this tree

00:15:09,880 --> 00:15:18,730
there's a lot of math terminologies

00:15:12,910 --> 00:15:21,029
about what each part of this this line

00:15:18,730 --> 00:15:21,029
does

00:15:22,360 --> 00:15:27,910
for the example purposes I'm not going

00:15:25,070 --> 00:15:33,170
to go in deep of what each does math

00:15:27,910 --> 00:15:36,800
expression means but here I do want to

00:15:33,170 --> 00:15:39,949
point out the specific term here looks

00:15:36,800 --> 00:15:43,279
my looks really scary but it won't

00:15:39,949 --> 00:15:46,699
change depending on the context if we if

00:15:43,279 --> 00:15:50,029
it's a natural language say I ate an

00:15:46,699 --> 00:15:55,120
apple then the different note here will

00:15:50,029 --> 00:16:00,560
probably be replaced by nun or verb and

00:15:55,120 --> 00:16:02,389
then say if it's a template handlebar

00:16:00,560 --> 00:16:06,620
template each of the node will be

00:16:02,389 --> 00:16:09,380
replaced by things like moustache

00:16:06,620 --> 00:16:13,639
statement and different kind of

00:16:09,380 --> 00:16:15,310
statement or hash values so basically

00:16:13,639 --> 00:16:17,870
the different kind of a node is

00:16:15,310 --> 00:16:21,470
determined by the grammatical structure

00:16:17,870 --> 00:16:22,009
of the language so when we look at the

00:16:21,470 --> 00:16:23,540
parse tree

00:16:22,009 --> 00:16:26,980
it actually looks kind of complicated

00:16:23,540 --> 00:16:30,410
and it's not as efficient as it can be

00:16:26,980 --> 00:16:31,940
if one is looking at this tree there are

00:16:30,410 --> 00:16:36,079
a lot of notes on the tree that actually

00:16:31,940 --> 00:16:37,970
contains repetitive information for

00:16:36,079 --> 00:16:41,510
example if we look at three there are

00:16:37,970 --> 00:16:44,899
three parents here and as a tree is not

00:16:41,510 --> 00:16:48,980
as efficient as it can be and that leads

00:16:44,899 --> 00:16:51,829
us to abstract syntax tree abstract

00:16:48,980 --> 00:16:55,459
syntax tree basically basically have the

00:16:51,829 --> 00:16:58,360
best part of parse tree which is the

00:16:55,459 --> 00:17:02,300
kind of structure grammatical structure

00:16:58,360 --> 00:17:09,049
forest syntax but it highlights the most

00:17:02,300 --> 00:17:12,230
important information for example it

00:17:09,049 --> 00:17:15,530
does so by kind of condensed to change

00:17:12,230 --> 00:17:18,409
notes together and then a take away

00:17:15,530 --> 00:17:22,100
extraneous information mission in this

00:17:18,409 --> 00:17:25,939
case brackets and then that's where we

00:17:22,100 --> 00:17:29,179
get to this new new tree which is the

00:17:25,939 --> 00:17:32,750
abstract syntax tree the way I think

00:17:29,179 --> 00:17:34,460
about it is the abstract syntax tree is

00:17:32,750 --> 00:17:36,980
the tree I would

00:17:34,460 --> 00:17:38,060
think about that would be how actually

00:17:36,980 --> 00:17:40,790
think about in my head

00:17:38,060 --> 00:17:44,560
and then I would think about the tree on

00:17:40,790 --> 00:17:51,110
the left as a way to kind of reproduce

00:17:44,560 --> 00:17:52,760
the original format of this tree as you

00:17:51,110 --> 00:17:56,360
can see if I combine the information

00:17:52,760 --> 00:17:58,750
from the middle tree here with the tree

00:17:56,360 --> 00:18:03,310
on the Left I can get to the original

00:17:58,750 --> 00:18:06,470
expression of three times four plus two

00:18:03,310 --> 00:18:08,860
so as you can see that this tree

00:18:06,470 --> 00:18:13,160
hierarchy really provide a clear way

00:18:08,860 --> 00:18:15,560
like a very hierarchical way to get the

00:18:13,160 --> 00:18:20,080
surrounding syntax because see five look

00:18:15,560 --> 00:18:23,890
at a four here I can clearly see that

00:18:20,080 --> 00:18:27,350
the plus here is taking precedent over

00:18:23,890 --> 00:18:30,050
the expression four plus two and then

00:18:27,350 --> 00:18:36,530
the multiplication is taking a precedent

00:18:30,050 --> 00:18:39,890
over the the plus so it's kind of at a

00:18:36,530 --> 00:18:45,020
higher level so kind of abstract syntax

00:18:39,890 --> 00:18:46,640
tree this is how if we have a code that

00:18:45,020 --> 00:18:48,230
people are able to know the context

00:18:46,640 --> 00:18:49,490
around it is by this kind of a

00:18:48,230 --> 00:18:50,900
hierarchical structure

00:18:49,490 --> 00:18:59,570
that provides a lot more information

00:18:50,900 --> 00:19:02,750
about the context so yeah we just talked

00:18:59,570 --> 00:19:06,650
about the concept of syntax tree and

00:19:02,750 --> 00:19:09,830
then how it provides this context

00:19:06,650 --> 00:19:11,270
through this hierarchical structure how

00:19:09,830 --> 00:19:13,970
does it relate it to the code that we

00:19:11,270 --> 00:19:18,170
write every day this is what I'm going

00:19:13,970 --> 00:19:21,200
to talk about next is a step to step

00:19:18,170 --> 00:19:23,600
from the code that we write every day to

00:19:21,200 --> 00:19:27,290
abstract syntax tree and back to the

00:19:23,600 --> 00:19:29,600
translate back to the code so typically

00:19:27,290 --> 00:19:31,900
to go through this step there are three

00:19:29,600 --> 00:19:31,900
steps

00:19:33,390 --> 00:19:45,370
this three steps are pretty common for

00:19:38,710 --> 00:19:50,470
tools such as compiler translator of not

00:19:45,370 --> 00:19:52,480
translator interpreter so the first

00:19:50,470 --> 00:19:54,970
stage of the code manipulation is this

00:19:52,480 --> 00:20:00,190
parsing process which I'm gonna get into

00:19:54,970 --> 00:20:02,830
it soon so you can think of a parsing as

00:20:00,190 --> 00:20:06,460
a process converting a sentence to

00:20:02,830 --> 00:20:07,299
abstract syntax tree in order to make

00:20:06,460 --> 00:20:11,169
this happen

00:20:07,299 --> 00:20:13,840
we first need to know what are the lines

00:20:11,169 --> 00:20:16,360
were reading so for example to cover

00:20:13,840 --> 00:20:18,580
from the three times four plus plus two

00:20:16,360 --> 00:20:21,780
you have to finish reading it right as a

00:20:18,580 --> 00:20:24,580
machine so that's the skinning step

00:20:21,780 --> 00:20:28,510
after we finished reading it you have to

00:20:24,580 --> 00:20:32,140
find a way to break this statement down

00:20:28,510 --> 00:20:34,900
into a certain way so that's what the

00:20:32,140 --> 00:20:37,630
tokenization does tokenization basically

00:20:34,900 --> 00:20:41,020
break down this particular expression

00:20:37,630 --> 00:20:44,380
into smaller chunks such as three four

00:20:41,020 --> 00:20:47,020
and two and this whole process of

00:20:44,380 --> 00:20:53,140
skinning and tokenization are called

00:20:47,020 --> 00:20:56,620
lexical analysis so let's look at a real

00:20:53,140 --> 00:21:02,230
world code example let's say I have this

00:20:56,620 --> 00:21:04,480
block of code after I scan it this is

00:21:02,230 --> 00:21:11,530
the kind of token I would get it's like

00:21:04,480 --> 00:21:14,260
a div class and become h1 title and next

00:21:11,530 --> 00:21:16,090
line so this is some of the example

00:21:14,260 --> 00:21:21,190
tokens that I would get from this block

00:21:16,090 --> 00:21:23,409
of code after I get this block of code

00:21:21,190 --> 00:21:26,919
the next thing to build up the tree

00:21:23,409 --> 00:21:31,840
structure is we want to put them

00:21:26,919 --> 00:21:36,330
together into a tree and then this

00:21:31,840 --> 00:21:36,330
process is called some technican Alyce's

00:21:36,809 --> 00:21:44,919
so ER to help with this process of

00:21:40,630 --> 00:21:45,549
building a tree we used to called ast

00:21:44,919 --> 00:21:48,519
Explorer

00:21:45,549 --> 00:21:51,850
or I use this too pretty often during my

00:21:48,519 --> 00:21:53,919
development this is a really simple tool

00:21:51,850 --> 00:21:59,289
actually it's a website developed by

00:21:53,919 --> 00:22:01,119
Alex clean and I have linked his link to

00:21:59,289 --> 00:22:03,999
this tool and his name at the bottom of

00:22:01,119 --> 00:22:06,730
the slide so to use this tool you just

00:22:03,999 --> 00:22:08,489
simply go into this website the

00:22:06,730 --> 00:22:11,470
interface will look something like this

00:22:08,489 --> 00:22:14,580
at the top left corner you would have

00:22:11,470 --> 00:22:19,419
the code that you want to transform and

00:22:14,580 --> 00:22:21,489
at the top right it will output you this

00:22:19,419 --> 00:22:30,820
abstract syntax tree with the token

00:22:21,489 --> 00:22:34,749
that's already parsed so here I want to

00:22:30,820 --> 00:22:36,309
use a gleam parser to do the job of

00:22:34,749 --> 00:22:42,070
actually building the abstract syntax

00:22:36,309 --> 00:22:46,659
tree this will be the output of this

00:22:42,070 --> 00:22:49,929
abstract syntax tree as you can see each

00:22:46,659 --> 00:22:53,169
one is this element node and within this

00:22:49,929 --> 00:22:57,220
element node there is mustache statement

00:22:53,169 --> 00:23:00,720
that is this title block and then has

00:22:57,220 --> 00:23:04,539
the value okay original the star title

00:23:00,720 --> 00:23:07,989
so this will be the actual abstract

00:23:04,539 --> 00:23:12,909
syntax tree coming kind of the output of

00:23:07,989 --> 00:23:16,989
the parser so the parsing steps are you

00:23:12,909 --> 00:23:19,809
lay down by existing packages if you

00:23:16,989 --> 00:23:23,639
were to write a compiler or like a new

00:23:19,809 --> 00:23:28,899
tool you usually don't need to kind of

00:23:23,639 --> 00:23:30,869
write your own parser it usually there's

00:23:28,899 --> 00:23:33,399
already parser coming from each language

00:23:30,869 --> 00:23:36,850
for example for JavaScript they're

00:23:33,399 --> 00:23:37,960
already parsers exist like Babylon and

00:23:36,850 --> 00:23:40,419
for handlebars

00:23:37,960 --> 00:23:41,080
there are parsers such as glimmered

00:23:40,419 --> 00:23:43,779
parser

00:23:41,080 --> 00:23:46,389
there's also browsers such as handlebar

00:23:43,779 --> 00:23:49,509
parser and all the different parsers

00:23:46,389 --> 00:23:51,970
works a little bit different and

00:23:49,509 --> 00:23:54,690
therefore the parsing result is also a

00:23:51,970 --> 00:23:54,690
little bit different

00:23:56,540 --> 00:24:02,510
the second stage of the code

00:23:58,860 --> 00:24:06,330
manipulation is the transformation step

00:24:02,510 --> 00:24:08,670
if you ever want to write your own kind

00:24:06,330 --> 00:24:10,920
of code mod or if you ever want to write

00:24:08,670 --> 00:24:11,580
your own winter this will be the bulk of

00:24:10,920 --> 00:24:13,560
the work

00:24:11,580 --> 00:24:16,770
since the parsing step is already done

00:24:13,560 --> 00:24:19,740
for you what the transformation step

00:24:16,770 --> 00:24:26,190
does is help you actually manipulating

00:24:19,740 --> 00:24:30,210
the code for example looking at this

00:24:26,190 --> 00:24:33,540
particular block say I want to add a

00:24:30,210 --> 00:24:40,770
helper function called beautify to this

00:24:33,540 --> 00:24:42,150
in front of this title this is the kind

00:24:40,770 --> 00:24:49,620
of code I would write to actually

00:24:42,150 --> 00:24:52,530
transform it as you can see there the

00:24:49,620 --> 00:24:54,420
kind of to the transformation usually

00:24:52,530 --> 00:24:56,670
have this visitor pattern for this

00:24:54,420 --> 00:24:59,370
particular code block if you're not

00:24:56,670 --> 00:25:01,980
familiar with the visitor hook pattern

00:24:59,370 --> 00:25:05,090
I've linked a link at the bottom of this

00:25:01,980 --> 00:25:10,160
slide if you want to look more into it

00:25:05,090 --> 00:25:12,810
so basically within each hook I write an

00:25:10,160 --> 00:25:16,560
expression that matches the kind of

00:25:12,810 --> 00:25:20,370
statement I want to modify in in this

00:25:16,560 --> 00:25:22,830
particular block I want to modify it's

00:25:20,370 --> 00:25:25,110
this dot title it's with the mustache

00:25:22,830 --> 00:25:29,250
statement so that's the reason why I

00:25:25,110 --> 00:25:33,410
have this modification I was lucky

00:25:29,250 --> 00:25:37,620
inside the mustache statement method and

00:25:33,410 --> 00:25:40,650
then here I'm just time checking if it's

00:25:37,620 --> 00:25:45,420
a path expression then I would add

00:25:40,650 --> 00:25:48,630
beautify in front of the value just an

00:25:45,420 --> 00:25:50,220
FYI this code may not actually work but

00:25:48,630 --> 00:25:52,350
this is example of the kind of

00:25:50,220 --> 00:25:56,840
manipulation I would actually do to

00:25:52,350 --> 00:25:59,550
manipulate the code at a scale an

00:25:56,840 --> 00:26:02,130
interesting thing about this is if I

00:25:59,550 --> 00:26:05,640
were to write a linking linter rule I

00:26:02,130 --> 00:26:07,890
would do exactly the same thing but

00:26:05,640 --> 00:26:08,420
except instead of actually manipulating

00:26:07,890 --> 00:26:11,150
or valley

00:26:08,420 --> 00:26:16,190
which is what kolmad does for linking I

00:26:11,150 --> 00:26:17,630
would do a type checking for example if

00:26:16,190 --> 00:26:20,240
I want to create a linter rule that's

00:26:17,630 --> 00:26:23,000
trying to check its each mustache

00:26:20,240 --> 00:26:25,730
statement okay okay

00:26:23,000 --> 00:26:28,390
like those values that's kind of wrapped

00:26:25,730 --> 00:26:32,870
around a bracket if they have this dot i

00:26:28,390 --> 00:26:35,780
would i would do in here and check

00:26:32,870 --> 00:26:43,130
note that path the original have

00:26:35,780 --> 00:26:45,860
contains this like this style value so

00:26:43,130 --> 00:26:49,070
the last step of the code manipulation

00:26:45,860 --> 00:26:53,180
process is called generation not all the

00:26:49,070 --> 00:26:55,700
tools that we created or like you're

00:26:53,180 --> 00:26:59,140
going to create meet this step this step

00:26:55,700 --> 00:27:03,740
is helpful for tools such as compiler

00:26:59,140 --> 00:27:08,000
transpiler code mod but maybe not as

00:27:03,740 --> 00:27:11,540
much for linking but what this called

00:27:08,000 --> 00:27:13,540
cogeneration step does is every prints

00:27:11,540 --> 00:27:17,440
the trees that we have just manipulated

00:27:13,540 --> 00:27:20,090
in the case of the beautified example

00:27:17,440 --> 00:27:23,090
because in the last example what we did

00:27:20,090 --> 00:27:26,750
is we change the value within a

00:27:23,090 --> 00:27:28,520
particular statement and what the

00:27:26,750 --> 00:27:30,680
cogeneration does is it detect the

00:27:28,520 --> 00:27:34,430
change and then it will print out the

00:27:30,680 --> 00:27:37,100
things that we have changed and then

00:27:34,430 --> 00:27:44,900
this would be the ideal output from the

00:27:37,100 --> 00:27:48,170
code snippet before so just now I went

00:27:44,900 --> 00:27:54,260
over a concept such as abstract syntax

00:27:48,170 --> 00:27:57,830
tree what it is and the process to how

00:27:54,260 --> 00:28:03,320
it's applied in a lot of different tools

00:27:57,830 --> 00:28:06,850
I hope you have a base understanding of

00:28:03,320 --> 00:28:09,920
this concepts and the tools around it

00:28:06,850 --> 00:28:11,810
there are a lot more cool applications

00:28:09,920 --> 00:28:15,040
can be developed using abstract syntax

00:28:11,810 --> 00:28:18,470
tree that hasn't been developed yet and

00:28:15,040 --> 00:28:21,830
I hope with more understanding of this

00:28:18,470 --> 00:28:25,340
concepts you are able to empowered

00:28:21,830 --> 00:28:28,399
to develop your own tools and I'm really

00:28:25,340 --> 00:28:33,379
looking forward to see what you can do

00:28:28,399 --> 00:28:35,570
with this information at the end this is

00:28:33,379 --> 00:28:38,269
a list of resources that I have that I

00:28:35,570 --> 00:28:40,519
found being useful for me while I'm

00:28:38,269 --> 00:28:42,379
putting together this presentation and

00:28:40,519 --> 00:28:45,739
lastly I really want to thank my team

00:28:42,379 --> 00:28:48,350
for their feedback and support and for

00:28:45,739 --> 00:28:50,299
the conference organizer for really

00:28:48,350 --> 00:28:51,139
sticking through everything and make

00:28:50,299 --> 00:28:55,039
this happen

00:28:51,139 --> 00:28:57,639
great job this is my contact information

00:28:55,039 --> 00:29:00,789
just in case if you need to contact me

00:28:57,639 --> 00:29:00,789

YouTube URL: https://www.youtube.com/watch?v=lyFMCqzkn3w


