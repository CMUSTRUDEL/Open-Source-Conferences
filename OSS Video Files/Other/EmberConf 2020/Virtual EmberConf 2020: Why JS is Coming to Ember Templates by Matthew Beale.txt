Title: Virtual EmberConf 2020: Why JS is Coming to Ember Templates by Matthew Beale
Publication date: 2020-03-26
Playlist: EmberConf 2020
Description: 
	Why JS is Coming to Ember Templates by Matthew Beale

In March 2018 the Ember project announced the abandonment of a long-running effort to improve Ember's dynamic resolution system (aka "Module Unification"). We didn't do it, and now we're going to talk about why. Soon, Ember developers are going to be seeing JavaScript in the same files as Ember templates, which opens the door to a new way to organize component implementations.
Captions: 
	00:00:01,270 --> 00:00:23,650
[Music]

00:00:20,400 --> 00:00:25,240
good afternoon I'm Matthew Beale and I'm

00:00:23,650 --> 00:00:28,000
excited to be speaking with you here

00:00:25,240 --> 00:00:29,320
again at ember conf before I start my

00:00:28,000 --> 00:00:30,789
talk here I just want to say I've been

00:00:29,320 --> 00:00:32,800
incredibly inspired by the work that

00:00:30,789 --> 00:00:34,540
tilde the conference organizers my

00:00:32,800 --> 00:00:36,760
fellow speakers and many others have

00:00:34,540 --> 00:00:39,190
done to make this conference virtually

00:00:36,760 --> 00:00:40,570
feel like a success my heart and thanks

00:00:39,190 --> 00:00:41,710
go out to each one of you for the work

00:00:40,570 --> 00:00:44,620
that you've done to make this feel like

00:00:41,710 --> 00:00:46,449
a real moment for our community so last

00:00:44,620 --> 00:00:48,309
year I started a new role in engineering

00:00:46,449 --> 00:00:50,799
at a company called a depart we're

00:00:48,309 --> 00:00:52,930
mostly based in New York City we work on

00:00:50,799 --> 00:00:54,729
one of the longest maintained ember code

00:00:52,930 --> 00:00:57,159
bases that's out there and additionally

00:00:54,729 --> 00:00:59,470
on a couple new code bases using ember

00:00:57,159 --> 00:01:01,299
octane in a big part project like ours

00:00:59,470 --> 00:01:03,280
you quickly learn to prioritize writing

00:01:01,299 --> 00:01:04,930
code that's easy to read and that's one

00:01:03,280 --> 00:01:06,520
of the reasons that this topic today is

00:01:04,930 --> 00:01:09,220
important to me okay

00:01:06,520 --> 00:01:10,869
so to dive in here there's a joke on the

00:01:09,220 --> 00:01:13,750
core teams it goes

00:01:10,869 --> 00:01:15,549
no more unification RFC's and yeah

00:01:13,750 --> 00:01:16,600
that's the punchline maybe some of you

00:01:15,549 --> 00:01:18,909
have an idea why

00:01:16,600 --> 00:01:21,640
just before ember comp last year we

00:01:18,909 --> 00:01:23,890
decided to withdraw this RFC the module

00:01:21,640 --> 00:01:25,659
unification RFC from consideration

00:01:23,890 --> 00:01:26,920
it might seem late to be talking about

00:01:25,659 --> 00:01:29,140
this topic and I'm not going to talk

00:01:26,920 --> 00:01:30,490
about multi unification in detail but

00:01:29,140 --> 00:01:32,439
what you should understand if you don't

00:01:30,490 --> 00:01:34,149
already is that multi notification was a

00:01:32,439 --> 00:01:35,920
last attempt at cleaning up some loose

00:01:34,149 --> 00:01:38,229
ends and how we organize and reference

00:01:35,920 --> 00:01:39,640
of files and ever so let's say that

00:01:38,229 --> 00:01:41,649
we're reading this template in an

00:01:39,640 --> 00:01:43,479
application most of our developers would

00:01:41,649 --> 00:01:45,369
Intuit that when they looked for the

00:01:43,479 --> 00:01:47,079
definition of welcome on disk they would

00:01:45,369 --> 00:01:49,780
look at this location in app components

00:01:47,079 --> 00:01:51,429
and that's often the correct answer but

00:01:49,780 --> 00:01:53,439
if you want to make an implementation of

00:01:51,429 --> 00:01:54,850
jump to definition say so that when you

00:01:53,439 --> 00:01:56,679
hover on welcome you can jump to the

00:01:54,850 --> 00:01:58,960
file where it's defined you would

00:01:56,679 --> 00:02:00,729
actually need to consider a much larger

00:01:58,960 --> 00:02:02,109
range of possible places that that thing

00:02:00,729 --> 00:02:03,639
can be and the same thing we go for

00:02:02,109 --> 00:02:05,520
typescript if you wanted to let

00:02:03,639 --> 00:02:07,960
typescript find the definition that file

00:02:05,520 --> 00:02:09,460
ember uses a resolver system that

00:02:07,960 --> 00:02:11,140
permits components to be defined in a

00:02:09,460 --> 00:02:13,210
number of different locations in your

00:02:11,140 --> 00:02:15,340
app or in an add-on and the logic for

00:02:13,210 --> 00:02:17,830
deciding which to use is implemented as

00:02:15,340 --> 00:02:19,270
part of your applications runtime now

00:02:17,830 --> 00:02:21,580
that makes it challenging to support

00:02:19,270 --> 00:02:23,650
common static analysis tools and things

00:02:21,580 --> 00:02:25,270
in IDs and type systems and bundler is

00:02:23,650 --> 00:02:27,850
that people use across other parts of

00:02:25,270 --> 00:02:29,980
the JavaScript community you might

00:02:27,850 --> 00:02:31,240
already be familiar with the concept of

00:02:29,980 --> 00:02:32,770
a local maximum

00:02:31,240 --> 00:02:34,450
when you're looking for a solution to a

00:02:32,770 --> 00:02:36,520
problem there are probably many like

00:02:34,450 --> 00:02:39,760
viable solutions to that particular

00:02:36,520 --> 00:02:41,260
thing however the path from one solution

00:02:39,760 --> 00:02:43,120
to another solution might not always be

00:02:41,260 --> 00:02:44,920
linear and and so it can get easy to

00:02:43,120 --> 00:02:46,450
over focus on the thing that you have in

00:02:44,920 --> 00:02:48,130
front of you instead of looking at

00:02:46,450 --> 00:02:49,690
though the whole range of design

00:02:48,130 --> 00:02:51,550
possibilities and solutions that might

00:02:49,690 --> 00:02:53,020
be out there you'll often read about

00:02:51,550 --> 00:02:55,140
this idea when you dig into something

00:02:53,020 --> 00:02:57,850
like neural network systems for example

00:02:55,140 --> 00:03:00,430
this neural network that generates

00:02:57,850 --> 00:03:02,860
horses on this this this horse does not

00:03:00,430 --> 00:03:05,680
exist calm a match to generate this

00:03:02,860 --> 00:03:07,930
really realistic image of a horse on the

00:03:05,680 --> 00:03:10,540
right-hand side as a global maximum but

00:03:07,930 --> 00:03:12,160
in other cases such as long left here it

00:03:10,540 --> 00:03:13,510
was equally confident that had found the

00:03:12,160 --> 00:03:16,120
right answer but had completely missed

00:03:13,510 --> 00:03:18,730
the mark so I think that modification

00:03:16,120 --> 00:03:20,800
was probably a local maximum we had

00:03:18,730 --> 00:03:22,570
identified places like real problems

00:03:20,800 --> 00:03:24,760
where mbers resolution system wasn't

00:03:22,570 --> 00:03:26,080
always clear about what file you are

00:03:24,760 --> 00:03:28,060
looking at what component you were

00:03:26,080 --> 00:03:30,040
trying to invoke in the module and

00:03:28,060 --> 00:03:31,570
modification introduced more formal

00:03:30,040 --> 00:03:34,420
rules and requirements in an attempt to

00:03:31,570 --> 00:03:36,190
unifying that system in hindsight though

00:03:34,420 --> 00:03:37,690
it was a local maximum in the rest of

00:03:36,190 --> 00:03:39,640
the JavaScript community was climbing

00:03:37,690 --> 00:03:41,380
the hill to a better solution this talk

00:03:39,640 --> 00:03:43,960
is about how we're going to align ember

00:03:41,380 --> 00:03:45,790
with that better solution so to

00:03:43,960 --> 00:03:47,560
illustrate the problem with embers

00:03:45,790 --> 00:03:49,660
resolver system let's build a little

00:03:47,560 --> 00:03:52,090
fork of Ember I'll call Matt's resolving

00:03:49,660 --> 00:03:54,190
ember micro lib here's a component in my

00:03:52,090 --> 00:03:56,500
framework and you can see it's just a

00:03:54,190 --> 00:03:57,850
function that returns a string done and

00:03:56,500 --> 00:04:01,300
we're gonna presume that it's in a file

00:03:57,850 --> 00:04:02,980
here called components Jas and here's my

00:04:01,300 --> 00:04:04,990
framework know this looks like a lot of

00:04:02,980 --> 00:04:06,460
code the most important bit to look at

00:04:04,990 --> 00:04:08,200
here is on the bottom we're calling a

00:04:06,460 --> 00:04:10,120
render function passing it a template

00:04:08,200 --> 00:04:11,800
and then further up we've got a template

00:04:10,120 --> 00:04:13,570
itself now there's two different things

00:04:11,800 --> 00:04:15,160
that we call op codes in there that say

00:04:13,570 --> 00:04:17,590
how I want to render this template the

00:04:15,160 --> 00:04:19,570
first one is the number zero which says

00:04:17,590 --> 00:04:21,160
I want to append text and the second one

00:04:19,570 --> 00:04:22,810
is the number one which says I want to

00:04:21,160 --> 00:04:24,100
invoke this component and if you look at

00:04:22,810 --> 00:04:26,440
the render function above you can see

00:04:24,100 --> 00:04:28,150
how those things are done and further up

00:04:26,440 --> 00:04:30,310
there's a setup where we create a map of

00:04:28,150 --> 00:04:34,630
all of our components and then we render

00:04:30,310 --> 00:04:35,860
them so let's see how the the ambiguity

00:04:34,630 --> 00:04:37,450
of using this system because we're using

00:04:35,860 --> 00:04:40,060
a string for welcome here let's see how

00:04:37,450 --> 00:04:41,440
that ambiguity is presents problems

00:04:40,060 --> 00:04:43,330
where a lot of tooling can't penetrate

00:04:41,440 --> 00:04:43,790
the meeting so first I've run this

00:04:43,330 --> 00:04:45,890
program

00:04:43,790 --> 00:04:48,050
through some popular build tools roll up

00:04:45,890 --> 00:04:50,660
and tercer roll up takes advantage of

00:04:48,050 --> 00:04:52,490
the fact that es modules are static that

00:04:50,660 --> 00:04:54,020
is the imports and exports from a module

00:04:52,490 --> 00:04:57,770
can be understood without running the

00:04:54,020 --> 00:04:58,880
code relic your multiple modules and

00:04:57,770 --> 00:05:01,310
safely combine them into a single

00:04:58,880 --> 00:05:02,540
JavaScript program you can think of as a

00:05:01,310 --> 00:05:05,210
simple compiler which takes our

00:05:02,540 --> 00:05:07,490
dependency the component and links it to

00:05:05,210 --> 00:05:09,200
the main program tercer is a

00:05:07,490 --> 00:05:10,880
minification tool which uses static

00:05:09,200 --> 00:05:12,560
analysis to make your JavaScript payload

00:05:10,880 --> 00:05:13,940
smaller for this version of the program

00:05:12,560 --> 00:05:16,280
the output looks like what we would

00:05:13,940 --> 00:05:17,990
expect the component here is present and

00:05:16,280 --> 00:05:19,310
the rendering logic is present you can

00:05:17,990 --> 00:05:22,250
see our template in there with the

00:05:19,310 --> 00:05:23,810
opcode 0 and the opcode 1 as well let's

00:05:22,250 --> 00:05:27,380
go ahead and change our template so

00:05:23,810 --> 00:05:28,940
instead of calling opcode 1 to print the

00:05:27,380 --> 00:05:30,950
component here to invoke our component

00:05:28,940 --> 00:05:33,260
let's just render more text with an

00:05:30,950 --> 00:05:36,080
append opcode instead so now I have two

00:05:33,260 --> 00:05:37,940
text op codes of 0 to you I say a fond

00:05:36,080 --> 00:05:39,380
farewell and this would be akin to you

00:05:37,940 --> 00:05:41,060
opening up a template in your ember app

00:05:39,380 --> 00:05:43,180
and deleting the invocation of a

00:05:41,060 --> 00:05:45,710
component to replace it with some text

00:05:43,180 --> 00:05:47,360
so in this output again rolling it

00:05:45,710 --> 00:05:49,190
through roll up running it through roll

00:05:47,360 --> 00:05:51,110
up and tercer you would expect the

00:05:49,190 --> 00:05:52,520
component logic doesn't need to be

00:05:51,110 --> 00:05:55,280
present since we stopped a reference

00:05:52,520 --> 00:05:56,480
referencing in the templates but because

00:05:55,280 --> 00:05:58,220
their relationship was something

00:05:56,480 --> 00:05:59,660
resolved at runtime and because roll-up

00:05:58,220 --> 00:06:01,580
interser don't know what the program

00:05:59,660 --> 00:06:04,580
will actually do they aren't able to

00:06:01,580 --> 00:06:06,170
strip that component out in the Ember

00:06:04,580 --> 00:06:08,240
ecosystem we're working on tools like

00:06:06,170 --> 00:06:10,280
embroider embroider tries to close this

00:06:08,240 --> 00:06:12,170
gap by teaching the build tools to

00:06:10,280 --> 00:06:14,480
assume things about the run time during

00:06:12,170 --> 00:06:15,950
build time analysis but I can give you

00:06:14,480 --> 00:06:17,960
another example of how the resolvers

00:06:15,950 --> 00:06:20,990
dynamic implementation in implementation

00:06:17,960 --> 00:06:23,120
will frustrate other tooling so finding

00:06:20,990 --> 00:06:24,950
a second example of how this ambiguity

00:06:23,120 --> 00:06:27,110
and all in our resolver based library

00:06:24,950 --> 00:06:28,820
has practical impacts is as easy as

00:06:27,110 --> 00:06:31,700
looking at the most popular IDE for

00:06:28,820 --> 00:06:33,260
ember users vs code here I've opened

00:06:31,700 --> 00:06:35,090
opened up the micro Lib and I'm

00:06:33,260 --> 00:06:37,040
attempting to jump to the definition of

00:06:35,090 --> 00:06:38,870
a component just like it was referenced

00:06:37,040 --> 00:06:40,370
inside of our template so it isn't

00:06:38,870 --> 00:06:41,900
surprising that this doesn't work right

00:06:40,370 --> 00:06:44,390
you can actually read it with your eyes

00:06:41,900 --> 00:06:46,520
here we have a string for welcome and

00:06:44,390 --> 00:06:48,470
just like we don't without understanding

00:06:46,520 --> 00:06:50,570
the program have any context for what

00:06:48,470 --> 00:06:52,370
that string means our compilation tools

00:06:50,570 --> 00:06:53,740
don't have that in our analysis tools in

00:06:52,370 --> 00:06:56,690
this case don't have that understanding

00:06:53,740 --> 00:06:57,440
themselves we could again teach the tool

00:06:56,690 --> 00:06:59,120
about this

00:06:57,440 --> 00:07:00,830
we could build a custom language server

00:06:59,120 --> 00:07:04,040
and encode assumptions about where to

00:07:00,830 --> 00:07:05,870
look for these definitions so the first

00:07:04,040 --> 00:07:07,820
draft of my micro lid used dynamic

00:07:05,870 --> 00:07:09,230
resolution to look up components the

00:07:07,820 --> 00:07:10,850
application boots the available

00:07:09,230 --> 00:07:13,310
components are put in a map and then

00:07:10,850 --> 00:07:15,500
templates reference them by strings in

00:07:13,310 --> 00:07:17,180
order for our eyes to know where to find

00:07:15,500 --> 00:07:18,830
a definition and for our tooling to know

00:07:17,180 --> 00:07:21,620
we need to teach the systems what those

00:07:18,830 --> 00:07:23,900
rules for resolution are I and I think

00:07:21,620 --> 00:07:25,820
that that teaching also comes across for

00:07:23,900 --> 00:07:27,350
us as individual developers when I asked

00:07:25,820 --> 00:07:28,520
you to look at this template and tell me

00:07:27,350 --> 00:07:30,260
where the Welcome component is defined

00:07:28,520 --> 00:07:31,610
you could probably give me a pretty

00:07:30,260 --> 00:07:33,650
reasonable answer but that's because

00:07:31,610 --> 00:07:36,860
you've internalized the rules of the

00:07:33,650 --> 00:07:39,230
resolution system in contrast to that in

00:07:36,860 --> 00:07:41,060
a static system one based on echo script

00:07:39,230 --> 00:07:43,190
modules we're always going to be able to

00:07:41,060 --> 00:07:44,930
be explicit about where a definition

00:07:43,190 --> 00:07:47,000
comes from you don't need to teach any

00:07:44,930 --> 00:07:48,650
tooling or people those rules so let's

00:07:47,000 --> 00:07:51,530
build a second draft of the micro Lib

00:07:48,650 --> 00:07:52,940
this time a static version so in this

00:07:51,530 --> 00:07:55,400
version of the template I've referenced

00:07:52,940 --> 00:07:57,200
the welcome component directly down in

00:07:55,400 --> 00:07:59,240
our template we have our opcode 0 with

00:07:57,200 --> 00:08:01,669
our string to append we have our opcode

00:07:59,240 --> 00:08:03,290
1 with the actual argument of welcome

00:08:01,669 --> 00:08:05,270
which is the thing that's imported from

00:08:03,290 --> 00:08:07,360
the top there's no setup there's no list

00:08:05,270 --> 00:08:09,470
of components there's no resolver here

00:08:07,360 --> 00:08:11,270
furthermore if you want to see where the

00:08:09,470 --> 00:08:12,650
Welcome component comes from you can you

00:08:11,270 --> 00:08:16,090
can read this really easily right you

00:08:12,650 --> 00:08:18,169
just look at where it's imported from I

00:08:16,090 --> 00:08:19,970
so now that the template contains a

00:08:18,169 --> 00:08:21,500
direct reference to the component we

00:08:19,970 --> 00:08:23,960
don't need to teach the tooling about

00:08:21,500 --> 00:08:25,790
any ambiguous cases so jump to

00:08:23,960 --> 00:08:27,290
definition just works in the template

00:08:25,790 --> 00:08:29,270
the way that it would work in most

00:08:27,290 --> 00:08:32,300
JavaScript code we've got that running

00:08:29,270 --> 00:08:34,280
and when the bundlers processes again

00:08:32,300 --> 00:08:35,900
through roll-up interser the

00:08:34,280 --> 00:08:38,570
implementation the component is actually

00:08:35,900 --> 00:08:40,729
lifted directly into the template itself

00:08:38,570 --> 00:08:42,770
so we can see our opcode 0 to you I say

00:08:40,729 --> 00:08:45,110
and there are opcode 1 with the actual

00:08:42,770 --> 00:08:47,300
component itself inlined into the

00:08:45,110 --> 00:08:50,450
template we've made the link between the

00:08:47,300 --> 00:08:52,010
program and the component static the

00:08:50,450 --> 00:08:53,660
tooling can not only understand where

00:08:52,010 --> 00:08:55,580
the component is being used but it can

00:08:53,660 --> 00:08:58,070
also understand if it's not used at all

00:08:55,580 --> 00:09:00,470
for example if I change the second

00:08:58,070 --> 00:09:01,970
render step back to a fond farewell as

00:09:00,470 --> 00:09:04,160
an append instead of a component

00:09:01,970 --> 00:09:05,930
invocation the bundler understands that

00:09:04,160 --> 00:09:07,820
the variable welcome was not referenced

00:09:05,930 --> 00:09:11,150
in the entire component implementation

00:09:07,820 --> 00:09:13,040
itself can be dropped ok

00:09:11,150 --> 00:09:14,990
so Everest templates are of course a lot

00:09:13,040 --> 00:09:16,790
more feature fool than my micro lid so

00:09:14,990 --> 00:09:18,920
how can we bring the benefits of a

00:09:16,790 --> 00:09:22,430
statically linked system back into ember

00:09:18,920 --> 00:09:25,700
itself so Godfrey trend has been

00:09:22,430 --> 00:09:28,370
exploring this in RFC 496 here in that

00:09:25,700 --> 00:09:30,710
RFC he proposes stricted templates and

00:09:28,370 --> 00:09:32,630
ember a strict template mode we call it

00:09:30,710 --> 00:09:34,490
mode because just like strict mode in

00:09:32,630 --> 00:09:36,530
JavaScript it opts the user into a

00:09:34,490 --> 00:09:39,890
version of language we're messy edge

00:09:36,530 --> 00:09:41,540
cases are going to be disabled so what's

00:09:39,890 --> 00:09:43,580
going to make a strict mode template a

00:09:41,540 --> 00:09:45,230
strict mode template so really it's

00:09:43,580 --> 00:09:47,390
going to be a list of things that we

00:09:45,230 --> 00:09:49,760
apply as constraints again to remove

00:09:47,390 --> 00:09:51,470
ambiguities from the system so the first

00:09:49,760 --> 00:09:52,970
of these is that there's going to be no

00:09:51,470 --> 00:09:55,280
more implicit this fall back so if you

00:09:52,970 --> 00:09:57,080
invoke something like like or if you

00:09:55,280 --> 00:09:58,790
access something like curly curly foo

00:09:57,080 --> 00:10:00,440
here we're not going to look to this dot

00:09:58,790 --> 00:10:02,480
foo if you want to access the component

00:10:00,440 --> 00:10:04,160
instance you must use this dot this is

00:10:02,480 --> 00:10:05,630
something that's an octane is already

00:10:04,160 --> 00:10:08,540
lint it for it so that's pretty straight

00:10:05,630 --> 00:10:10,760
ahead there's going to be no resolution

00:10:08,540 --> 00:10:12,530
of any invocations so for example curly

00:10:10,760 --> 00:10:15,170
curly foo dash bar is a component

00:10:12,530 --> 00:10:16,730
invocation our angle bracket welcome was

00:10:15,170 --> 00:10:19,670
a different kind of component invocation

00:10:16,730 --> 00:10:21,170
in a strict mode template those things

00:10:19,670 --> 00:10:22,790
won't be those things won't lookup

00:10:21,170 --> 00:10:24,770
components in the app folder of your

00:10:22,790 --> 00:10:26,030
program so this is obviously something

00:10:24,770 --> 00:10:28,970
that we're going to have to come back to

00:10:26,030 --> 00:10:31,340
there's no dynamic resolution so you

00:10:28,970 --> 00:10:33,230
can't use the component helper to pass a

00:10:31,340 --> 00:10:35,150
dynamic string here because this is not

00:10:33,230 --> 00:10:36,830
analyzable at all you could pass any

00:10:35,150 --> 00:10:39,590
string at runtime and there's no way for

00:10:36,830 --> 00:10:41,000
us to know what you might pass in and

00:10:39,590 --> 00:10:42,740
then partials have a similar facility

00:10:41,000 --> 00:10:44,900
where they can also take a dynamic

00:10:42,740 --> 00:10:47,360
argument partials are already deprecated

00:10:44,900 --> 00:10:50,870
so again this is pretty much already on

00:10:47,360 --> 00:10:52,880
the on the happy path okay here's an

00:10:50,870 --> 00:10:55,190
example of what a handlebars strict mode

00:10:52,880 --> 00:10:56,840
template could look like it shouldn't

00:10:55,190 --> 00:10:59,000
look very different than ember template

00:10:56,840 --> 00:11:01,100
you might work in today it's going to

00:10:59,000 --> 00:11:02,720
contain a couple template keywords so in

00:11:01,100 --> 00:11:05,120
this case we have each being used in

00:11:02,720 --> 00:11:06,650
here arguments so at greeting this is an

00:11:05,120 --> 00:11:09,260
argument to this component that I'm

00:11:06,650 --> 00:11:10,460
using it has a block per my greeting

00:11:09,260 --> 00:11:12,530
that we're then using inside of the

00:11:10,460 --> 00:11:14,240
block and we're accessing properties off

00:11:12,530 --> 00:11:17,890
the component State and that works just

00:11:14,240 --> 00:11:20,600
like it would in any regular template

00:11:17,890 --> 00:11:22,430
however there's no actual way to invoke

00:11:20,600 --> 00:11:24,180
the component from app so for example if

00:11:22,430 --> 00:11:26,130
I had put bracket like angle

00:11:24,180 --> 00:11:28,020
get quote in here it wouldn't actually

00:11:26,130 --> 00:11:30,150
render a component at all it would just

00:11:28,020 --> 00:11:32,670
be an error and so this brings us to the

00:11:30,150 --> 00:11:34,200
crux in order for these static templates

00:11:32,670 --> 00:11:36,300
actually be useful we're going to need a

00:11:34,200 --> 00:11:38,220
static solution for getting other

00:11:36,300 --> 00:11:40,530
components into the scope of the

00:11:38,220 --> 00:11:42,630
template since we want to bundle our

00:11:40,530 --> 00:11:43,770
application as JavaScript we want to do

00:11:42,630 --> 00:11:45,810
something that's going to work with es

00:11:43,770 --> 00:11:47,490
modules of course and to work with es

00:11:45,810 --> 00:11:49,470
modules we need to consider what a

00:11:47,490 --> 00:11:52,770
strictmode template looks like when it's

00:11:49,470 --> 00:11:54,660
compiled into JavaScript so here's that

00:11:52,770 --> 00:11:56,280
same strictmode template compiled into

00:11:54,660 --> 00:11:58,320
JavaScript only I've changed it this

00:11:56,280 --> 00:12:00,180
time to invoke the quote component

00:11:58,320 --> 00:12:02,250
around my greeting to bring that

00:12:00,180 --> 00:12:03,930
component into scope I've imported it

00:12:02,250 --> 00:12:05,940
from a file that's in the same directory

00:12:03,930 --> 00:12:07,980
as our component here just quote you can

00:12:05,940 --> 00:12:11,190
imagine that it exports in ember

00:12:07,980 --> 00:12:13,170
component glimmer component just like

00:12:11,190 --> 00:12:14,820
with my static microwave earlier the

00:12:13,170 --> 00:12:16,650
definition of the component itself is

00:12:14,820 --> 00:12:18,120
now passed directly into the compile

00:12:16,650 --> 00:12:19,890
template you can see that down where we

00:12:18,120 --> 00:12:21,480
have a property of scope and then we're

00:12:19,890 --> 00:12:24,750
passing a function with quote being

00:12:21,480 --> 00:12:27,030
closed over common built-in would work

00:12:24,750 --> 00:12:28,770
well with this output and given some

00:12:27,030 --> 00:12:30,450
work on source maps we can make jump to

00:12:28,770 --> 00:12:34,560
definition work as well through the

00:12:30,450 --> 00:12:36,210
template itself of course this API this

00:12:34,560 --> 00:12:37,260
API is basically as far as the

00:12:36,210 --> 00:12:40,650
handlebars strictmode

00:12:37,260 --> 00:12:42,450
RFC itself goes in this API is only a

00:12:40,650 --> 00:12:44,910
primitive right we don't write compiled

00:12:42,450 --> 00:12:46,740
templates by hand in order to make this

00:12:44,910 --> 00:12:48,390
readable and usable we need to find a

00:12:46,740 --> 00:12:50,130
way to lift the import statement that

00:12:48,390 --> 00:12:52,110
we're writing in JavaScript here into

00:12:50,130 --> 00:12:55,980
the temple itself which is going to take

00:12:52,110 --> 00:12:57,630
us into a design for template imports so

00:12:55,980 --> 00:12:59,550
if we want the ability to bring other

00:12:57,630 --> 00:13:01,020
components into a strict mode template

00:12:59,550 --> 00:13:02,850
scope there are a couple different

00:13:01,020 --> 00:13:04,830
plausible designs that we could go into

00:13:02,850 --> 00:13:07,080
and to keep the design kind of

00:13:04,830 --> 00:13:09,870
unsurprising to both new developers and

00:13:07,080 --> 00:13:11,730
advanced ember developers we think that

00:13:09,870 --> 00:13:14,040
two constraints are important to keep in

00:13:11,730 --> 00:13:15,750
mind the first is that you want to be

00:13:14,040 --> 00:13:17,790
able to import a default or a named

00:13:15,750 --> 00:13:19,590
export so you want to be able to say

00:13:17,790 --> 00:13:21,960
that my component from elsewhere or my

00:13:19,590 --> 00:13:23,760
helper or my modifier is the thing which

00:13:21,960 --> 00:13:25,680
I have named arbitrarily in my exports

00:13:23,760 --> 00:13:27,360
and I can pull it into my template and

00:13:25,680 --> 00:13:29,250
the second thing is that on the right

00:13:27,360 --> 00:13:30,780
side of an import the path we want to

00:13:29,250 --> 00:13:33,360
work just like it wouldn't in any know

00:13:30,780 --> 00:13:35,910
jazz resolution nothing nothing special

00:13:33,360 --> 00:13:37,260
to go on there so given that we accept

00:13:35,910 --> 00:13:39,060
these constraints it's going to be

00:13:37,260 --> 00:13:41,790
question if we're going to constrain

00:13:39,060 --> 00:13:44,160
ourselves to so closely re-implementing

00:13:41,790 --> 00:13:46,200
the constraints already provided by es

00:13:44,160 --> 00:13:48,210
modules why not simply adopt the es

00:13:46,200 --> 00:13:50,460
module syntax into templates themselves

00:13:48,210 --> 00:13:52,740
in fact any design that doesn't do that

00:13:50,460 --> 00:13:55,470
it seems to bend common-sense a little

00:13:52,740 --> 00:13:56,940
bit too far so let's see what that's

00:13:55,470 --> 00:14:01,530
going to look like to bring the echo

00:13:56,940 --> 00:14:03,120
script module syntax into templates so a

00:14:01,530 --> 00:14:06,180
strict mode template itself doesn't have

00:14:03,120 --> 00:14:08,940
imports but if we bring in a design for

00:14:06,180 --> 00:14:11,640
template imports we can bring them into

00:14:08,940 --> 00:14:14,430
scope here so we have - - - import quote

00:14:11,640 --> 00:14:16,710
and then another - - - the - - -

00:14:14,430 --> 00:14:18,240
introduces a preamble where we're going

00:14:16,710 --> 00:14:19,830
to be able to write our import

00:14:18,240 --> 00:14:22,710
statements and at the bottom we have our

00:14:19,830 --> 00:14:24,570
template in between the preamble section

00:14:22,710 --> 00:14:26,490
we want to constrain what's available in

00:14:24,570 --> 00:14:28,530
there to only be atma script module

00:14:26,490 --> 00:14:29,940
syntax so you can't use variables you

00:14:28,530 --> 00:14:32,720
can't define functions or anything like

00:14:29,940 --> 00:14:34,920
that and that's really as a first pass

00:14:32,720 --> 00:14:36,210
imports can of course come from any path

00:14:34,920 --> 00:14:37,980
because we want the thing on the right

00:14:36,210 --> 00:14:39,840
side of an import statement to work just

00:14:37,980 --> 00:14:41,580
like it does in normal JavaScript so

00:14:39,840 --> 00:14:43,400
here we're importing quote which would

00:14:41,580 --> 00:14:45,840
be a file that's in our local

00:14:43,400 --> 00:14:47,910
application we're also importing title

00:14:45,840 --> 00:14:49,920
eyes which is a helper that the ember'

00:14:47,910 --> 00:14:51,930
framework itself is providing and then

00:14:49,920 --> 00:14:54,810
we're importing animated each from an

00:14:51,930 --> 00:14:56,820
add-on imports are going to open up new

00:14:54,810 --> 00:14:58,050
organization options for your app if you

00:14:56,820 --> 00:14:59,880
have a naturally group two set of

00:14:58,050 --> 00:15:01,410
components you can group them on disk

00:14:59,880 --> 00:15:03,360
wherever it's going to seem appropriate

00:15:01,410 --> 00:15:05,070
additionally related helpers and

00:15:03,360 --> 00:15:07,170
modifiers could easily share a single

00:15:05,070 --> 00:15:09,180
file but be exposed as named imports for

00:15:07,170 --> 00:15:12,900
example as we're doing for the add ember

00:15:09,180 --> 00:15:15,870
slash template helpers module here so

00:15:12,900 --> 00:15:17,670
how do these imports compile back into

00:15:15,870 --> 00:15:19,650
JavaScript because this is just our

00:15:17,670 --> 00:15:21,090
syntax in the template so just as with

00:15:19,650 --> 00:15:23,460
the handwritten compilation from earlier

00:15:21,090 --> 00:15:25,920
these three components are passed in

00:15:23,460 --> 00:15:27,750
inside of the compiled template closed

00:15:25,920 --> 00:15:29,190
over from their imports the imports from

00:15:27,750 --> 00:15:31,080
our sample that are lifted into the

00:15:29,190 --> 00:15:32,670
JavaScript here then we close over the

00:15:31,080 --> 00:15:35,400
values that are imported and passed them

00:15:32,670 --> 00:15:37,710
into the create template factory itself

00:15:35,400 --> 00:15:39,060
and this is great it means that when we

00:15:37,710 --> 00:15:40,650
look at the Kepala javascript here it's

00:15:39,060 --> 00:15:42,240
easy for our eyes to understand where

00:15:40,650 --> 00:15:44,210
quote is coming from which means it's

00:15:42,240 --> 00:15:46,920
also easy for our tooling to understand

00:15:44,210 --> 00:15:48,870
okay so what are the next steps in the

00:15:46,920 --> 00:15:50,300
process of delivering template imports

00:15:48,870 --> 00:15:53,360
so I

00:15:50,300 --> 00:15:55,580
before glimmer components has landed in

00:15:53,360 --> 00:15:57,560
an ember staple release we actually

00:15:55,580 --> 00:16:00,290
landed a primitive into a stable version

00:15:57,560 --> 00:16:02,360
of ember component manager this allowed

00:16:00,290 --> 00:16:04,790
us to implement glimmer components

00:16:02,360 --> 00:16:06,890
inside of an add-on and circulate them

00:16:04,790 --> 00:16:08,660
amongst like the most passionate users

00:16:06,890 --> 00:16:10,400
who are eager to try and experiment with

00:16:08,660 --> 00:16:12,890
that solution and to get their feedback

00:16:10,400 --> 00:16:14,450
on that feedback kind of helped us shape

00:16:12,890 --> 00:16:15,350
the glimmer components feature until the

00:16:14,450 --> 00:16:17,540
point where we thought it was really

00:16:15,350 --> 00:16:19,100
ready for a stable release we want to do

00:16:17,540 --> 00:16:21,530
the same thing in this case the

00:16:19,100 --> 00:16:22,670
handlebars strictmode is a an RFC that

00:16:21,530 --> 00:16:24,890
we have to get into a final comment

00:16:22,670 --> 00:16:26,660
period and land that primitive that will

00:16:24,890 --> 00:16:28,610
then allow us to build an add-on on top

00:16:26,660 --> 00:16:30,740
of it which provides the template import

00:16:28,610 --> 00:16:32,660
a syntax and then early adopters can

00:16:30,740 --> 00:16:34,610
experiment with that and let us know

00:16:32,660 --> 00:16:37,580
what needs to be shaken out in order to

00:16:34,610 --> 00:16:38,960
make it a success kind of in parallel

00:16:37,580 --> 00:16:41,180
we're also going to need to do a little

00:16:38,960 --> 00:16:42,920
bit design around what the es module API

00:16:41,180 --> 00:16:45,080
would be like for things like linked

00:16:42,920 --> 00:16:46,550
linked to or input it's probably a

00:16:45,080 --> 00:16:50,030
little bit of extra design work to do

00:16:46,550 --> 00:16:52,190
there so I've talked a lot about the

00:16:50,030 --> 00:16:53,810
technical nature of static templates in

00:16:52,190 --> 00:16:55,880
this talk but despite the fact that

00:16:53,810 --> 00:16:58,340
static templates will have performance

00:16:55,880 --> 00:17:00,260
in payload size impacts I wanna remind

00:16:58,340 --> 00:17:02,960
you that performance isn't the headline

00:17:00,260 --> 00:17:05,840
motivation here static templates with es

00:17:02,960 --> 00:17:09,050
imports make it a template simple to

00:17:05,840 --> 00:17:10,760
understand for our eyes as well so in

00:17:09,050 --> 00:17:12,500
this first example we have welcome where

00:17:10,760 --> 00:17:14,270
you as an ember developer need to

00:17:12,500 --> 00:17:16,610
understand how the resolver rules work

00:17:14,270 --> 00:17:18,800
but in the second one even if I've never

00:17:16,610 --> 00:17:20,540
used number before it's really clear to

00:17:18,800 --> 00:17:21,560
me where this thing is coming from and

00:17:20,540 --> 00:17:22,480
where I need to go to find the

00:17:21,560 --> 00:17:24,680
definition

00:17:22,480 --> 00:17:26,180
additionally module notification it had

00:17:24,680 --> 00:17:28,520
some interesting features you might have

00:17:26,180 --> 00:17:30,140
heard of like local lookup of explicit

00:17:28,520 --> 00:17:32,690
imports make those features pretty much

00:17:30,140 --> 00:17:34,310
unnecessary and import syntax will just

00:17:32,690 --> 00:17:35,690
allow you to group components naturally

00:17:34,310 --> 00:17:37,430
in your project without losing the

00:17:35,690 --> 00:17:40,940
common conventions as suggested by

00:17:37,430 --> 00:17:42,710
linting and generators so that's why a

00:17:40,940 --> 00:17:44,810
JavaScript or at least JavaScript

00:17:42,710 --> 00:17:47,420
imports syntax is coming to ember

00:17:44,810 --> 00:17:49,400
templates so the Ember project was one

00:17:47,420 --> 00:17:51,620
of the earliest adopters of es modules

00:17:49,400 --> 00:17:53,360
and embracing the opportunities that es

00:17:51,620 --> 00:17:55,250
modules present in making our templates

00:17:53,360 --> 00:17:57,130
more readable and better analyzed as

00:17:55,250 --> 00:17:59,510
something that I'm pretty excited about

00:17:57,130 --> 00:18:01,100
but more than that it's going to take

00:17:59,510 --> 00:18:03,040
give us the opportunity to take

00:18:01,100 --> 00:18:04,840
challenges that ember has in

00:18:03,040 --> 00:18:06,700
common with other JavaScript projects

00:18:04,840 --> 00:18:09,190
allow and allow us to better share

00:18:06,700 --> 00:18:10,420
common solutions between them if you

00:18:09,190 --> 00:18:11,890
want to do further reading on this topic

00:18:10,420 --> 00:18:13,750
I encourage you to take a look at the

00:18:11,890 --> 00:18:15,130
links that I put on the page here hi and

00:18:13,750 --> 00:18:17,290
I've also included a bid lease that you

00:18:15,130 --> 00:18:19,960
can open up these slides yourself this

00:18:17,290 --> 00:18:22,360
afternoon thanks for joining us here at

00:18:19,960 --> 00:18:23,800
ember kampf virtually and I look forward

00:18:22,360 --> 00:18:27,210
to talking about this topic more with

00:18:23,800 --> 00:18:27,210

YouTube URL: https://www.youtube.com/watch?v=p32zUgp4-_4


