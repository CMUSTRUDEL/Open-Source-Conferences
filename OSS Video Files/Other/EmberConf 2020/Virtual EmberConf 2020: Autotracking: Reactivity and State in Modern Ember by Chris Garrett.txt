Title: Virtual EmberConf 2020: Autotracking: Reactivity and State in Modern Ember by Chris Garrett
Publication date: 2020-03-26
Playlist: EmberConf 2020
Description: 
	Autotracking: Reactivity and State in Modern Ember by Chris Garrett

Tracked properties are one of the most exciting features introduced in Ember Octane, and they represent a shift in the model for state management in modern Ember apps. But what makes a property "tracked"? Why do we have to decorate our properties? And how does this all differ from how other web frameworks think about state?

In this deep dive talk, I'll discuss the problems of state management and reactivity, and a number of solutions that have evolved over the years. I'll also show the internals of autotracking, and demonstrate some the unique benefits it gives to developers!
Captions: 
	00:00:01,270 --> 00:00:23,619
[Music]

00:00:20,430 --> 00:00:25,240
good morning ember Kampf or good

00:00:23,619 --> 00:00:28,060
afternoon or good evening depending on

00:00:25,240 --> 00:00:29,410
where you're joining us from I honestly

00:00:28,060 --> 00:00:31,960
didn't think I'd be giving this talk

00:00:29,410 --> 00:00:34,150
virtually but it has amazed me how the

00:00:31,960 --> 00:00:36,550
Ember community and especially the Ember

00:00:34,150 --> 00:00:39,040
comp team have come together to make

00:00:36,550 --> 00:00:43,030
this all happen and it really is truly

00:00:39,040 --> 00:00:46,390
incredible to me we may be stuck but at

00:00:43,030 --> 00:00:49,239
least we're stuck together anyways my

00:00:46,390 --> 00:00:52,239
name is Chris and I'm a software

00:00:49,239 --> 00:00:55,030
engineer at LinkedIn and I'm also an

00:00:52,239 --> 00:00:57,000
ember core team member you might know me

00:00:55,030 --> 00:01:01,570
better by my internet handle bizarre ik

00:00:57,000 --> 00:01:05,140
this is me on Twitter github discord

00:01:01,570 --> 00:01:08,770
basically everywhere else and today I'm

00:01:05,140 --> 00:01:11,729
here to talk about reactivity first off

00:01:08,770 --> 00:01:15,460
what is it and why do we care

00:01:11,729 --> 00:01:18,490
well in a nutshell reactivity is how

00:01:15,460 --> 00:01:20,830
apps update when things change and this

00:01:18,490 --> 00:01:23,320
is why we care because we're developing

00:01:20,830 --> 00:01:26,679
ambitious application so we want to show

00:01:23,320 --> 00:01:29,020
changes to the user as things occur we

00:01:26,679 --> 00:01:31,270
as users click on buttons or as we

00:01:29,020 --> 00:01:32,850
return API responses from the server or

00:01:31,270 --> 00:01:36,359
what have you

00:01:32,850 --> 00:01:39,369
so we care a lot about this question and

00:01:36,359 --> 00:01:42,820
modern frameworks solve this with

00:01:39,369 --> 00:01:45,070
reactivity auto tracking is a form of

00:01:42,820 --> 00:01:47,799
reactivity but there are many forms of

00:01:45,070 --> 00:01:49,270
reactivity and today we'll take a look

00:01:47,799 --> 00:01:52,030
at a few of them and see how they

00:01:49,270 --> 00:01:54,210
compare and contrast but before we do

00:01:52,030 --> 00:01:56,560
that it's important to understand that

00:01:54,210 --> 00:01:59,409
reactivity is really a subset of

00:01:56,560 --> 00:02:02,499
updating there are many ways you can

00:01:59,409 --> 00:02:04,689
update that we wouldn't call reactive so

00:02:02,499 --> 00:02:06,700
you might be wondering ok why does it

00:02:04,689 --> 00:02:09,520
get a cool buzzword then what makes it

00:02:06,700 --> 00:02:12,040
special what sets it apart and why do I

00:02:09,520 --> 00:02:14,530
want reactivity in my app why do I care

00:02:12,040 --> 00:02:18,610
about this and why not just use any old

00:02:14,530 --> 00:02:22,840
way to update well I think that's best

00:02:18,610 --> 00:02:26,260
described with an example best shown so

00:02:22,840 --> 00:02:29,050
let's build an application this is to do

00:02:26,260 --> 00:02:30,740
MVC and it's a commonly used example app

00:02:29,050 --> 00:02:33,440
for frameworks to demonstrate

00:02:30,740 --> 00:02:35,300
how to build with them and today we're

00:02:33,440 --> 00:02:37,940
going to imagine that we're building a

00:02:35,300 --> 00:02:40,670
framework from scratch and we're using

00:02:37,940 --> 00:02:41,600
that to build to do MVC we're not

00:02:40,670 --> 00:02:43,430
actually going to build it from scratch

00:02:41,600 --> 00:02:46,280
but let's just imagine that we are and

00:02:43,430 --> 00:02:48,950
that we are now trying to figure out how

00:02:46,280 --> 00:02:50,660
users update things in our framework and

00:02:48,950 --> 00:02:52,280
so we're gonna iterate through a few

00:02:50,660 --> 00:02:56,540
solutions and see how they work and

00:02:52,280 --> 00:02:59,980
compare and contrast them but to keep

00:02:56,540 --> 00:03:02,840
things simple we've already decided that

00:02:59,980 --> 00:03:04,850
we want this to be a template oriented

00:03:02,840 --> 00:03:06,770
framework and we like templates and

00:03:04,850 --> 00:03:09,140
handlebars is great templating language

00:03:06,770 --> 00:03:11,330
so we're gonna use handlebars templates

00:03:09,140 --> 00:03:14,060
for our framework so here's the template

00:03:11,330 --> 00:03:19,940
for this application and let's take a

00:03:14,060 --> 00:03:21,770
look at it so first up we can see that

00:03:19,940 --> 00:03:25,150
there's an input at the top which is

00:03:21,770 --> 00:03:27,980
where users can add new to dues and then

00:03:25,150 --> 00:03:30,290
we have the currently displaying to-do

00:03:27,980 --> 00:03:32,180
lists so whatever is currently

00:03:30,290 --> 00:03:34,820
displaying we have their checkboxes and

00:03:32,180 --> 00:03:37,400
their titles and then we have the footer

00:03:34,820 --> 00:03:39,680
where we can see the items left and the

00:03:37,400 --> 00:03:42,140
filter buttons where we can select all -

00:03:39,680 --> 00:03:46,340
dues or active - dues or completed -

00:03:42,140 --> 00:03:50,240
dues and here's the JavaScript that is

00:03:46,340 --> 00:03:53,650
backing that template it's a lot to take

00:03:50,240 --> 00:03:53,650
in so let's take a moment to read it

00:03:59,450 --> 00:04:04,849
so starting from the top we have the

00:04:02,720 --> 00:04:06,620
list of two dues all to dues so

00:04:04,849 --> 00:04:09,670
completed not completed they all go in

00:04:06,620 --> 00:04:12,379
here and we have the displaying property

00:04:09,670 --> 00:04:16,400
which controls which to-do list is

00:04:12,379 --> 00:04:18,850
currently displaying we are then we have

00:04:16,400 --> 00:04:21,380
these getters which is how we define

00:04:18,850 --> 00:04:24,950
things like active to do is completed to

00:04:21,380 --> 00:04:30,680
dues and which to-do list is currently

00:04:24,950 --> 00:04:32,120
displaying and to do is left finally we

00:04:30,680 --> 00:04:34,280
have our actions which is where we

00:04:32,120 --> 00:04:35,810
actually perform the updates this is

00:04:34,280 --> 00:04:39,919
what will happen when a user actually

00:04:35,810 --> 00:04:42,410
wants to add it to do or toggle it and

00:04:39,919 --> 00:04:45,380
we can see here that we're just using

00:04:42,410 --> 00:04:47,690
plain JavaScript as is we're just

00:04:45,380 --> 00:04:50,540
pushing into an array or setting a

00:04:47,690 --> 00:04:52,460
property nothing special here this

00:04:50,540 --> 00:04:54,770
presents a problem though because the

00:04:52,460 --> 00:04:56,330
framework doesn't know that we've made

00:04:54,770 --> 00:04:58,520
these changes it doesn't know that it

00:04:56,330 --> 00:05:01,430
needs to update the template and to show

00:04:58,520 --> 00:05:04,880
the user these changes so the question

00:05:01,430 --> 00:05:06,800
is how do we let it know well we could

00:05:04,880 --> 00:05:08,300
do it directly we could call something

00:05:06,800 --> 00:05:11,120
like this stop rerender whenever

00:05:08,300 --> 00:05:13,490
something changed but that would be

00:05:11,120 --> 00:05:17,120
pretty difficult to remember for us it

00:05:13,490 --> 00:05:19,130
would be it would be hard to remember in

00:05:17,120 --> 00:05:20,840
a lot of complicated code paths that

00:05:19,130 --> 00:05:23,450
every time you update some state you

00:05:20,840 --> 00:05:25,789
have to call this method and it would

00:05:23,450 --> 00:05:27,830
also be not very performant because our

00:05:25,789 --> 00:05:30,350
application doesn't know exactly what

00:05:27,830 --> 00:05:33,919
changed it just knows that it needs to

00:05:30,350 --> 00:05:35,510
rerender because something changed so we

00:05:33,919 --> 00:05:40,039
could try to get a bit more specific to

00:05:35,510 --> 00:05:43,490
fix that problem but this only gets more

00:05:40,039 --> 00:05:45,380
complicated now we need to tell it ok

00:05:43,490 --> 00:05:47,450
rerender this list or rerender the items

00:05:45,380 --> 00:05:49,910
left the remember ender this particular

00:05:47,450 --> 00:05:51,650
to do and that's that's a lot to

00:05:49,910 --> 00:05:53,180
remember that's a lot to think through

00:05:51,650 --> 00:05:55,060
every time you want to update some state

00:05:53,180 --> 00:05:57,710
which parts of the view it's gonna

00:05:55,060 --> 00:06:00,380
affect and which parts need to remember

00:05:57,710 --> 00:06:02,780
every render that's a lot to put on the

00:06:00,380 --> 00:06:06,530
developer we can call this burden

00:06:02,780 --> 00:06:09,229
annotation overhead it's the extra code

00:06:06,530 --> 00:06:11,150
or thought that has to go into code in

00:06:09,229 --> 00:06:13,130
order to do it in the way that the

00:06:11,150 --> 00:06:14,450
framework wants you to do

00:06:13,130 --> 00:06:19,120
as opposed to how you would do it

00:06:14,450 --> 00:06:22,120
without the framework and that

00:06:19,120 --> 00:06:24,080
annotation overhead here is is not only

00:06:22,120 --> 00:06:27,770
constant whenever we want to update

00:06:24,080 --> 00:06:31,070
state it's also combinatorial as our

00:06:27,770 --> 00:06:33,080
application grows there will be more and

00:06:31,070 --> 00:06:34,880
more parts of it that could be updated

00:06:33,080 --> 00:06:39,290
at any given time and more and more ways

00:06:34,880 --> 00:06:41,420
to update it so it grows combinatorially

00:06:39,290 --> 00:06:44,420
with the size of our application which

00:06:41,420 --> 00:06:46,610
is not a good place to be this is really

00:06:44,420 --> 00:06:50,870
the state of the art in the era of

00:06:46,610 --> 00:06:53,480
backbone and jQuery everything was

00:06:50,870 --> 00:06:55,970
pretty ad-hoc on the front end at that

00:06:53,480 --> 00:06:58,250
point so you would have you know one-off

00:06:55,970 --> 00:07:00,080
plugins and and this was fine there were

00:06:58,250 --> 00:07:01,850
small applications it was fine for these

00:07:00,080 --> 00:07:03,560
because things weren't complicated

00:07:01,850 --> 00:07:07,220
enough for this to really become an

00:07:03,560 --> 00:07:10,910
issue but as application size and scale

00:07:07,220 --> 00:07:13,250
began to grow it started to become more

00:07:10,910 --> 00:07:15,950
of an issue and eventually became too

00:07:13,250 --> 00:07:19,910
much so this is where reactivity comes

00:07:15,950 --> 00:07:22,540
in reactivity was a way to solve this to

00:07:19,910 --> 00:07:25,870
make sure that your application

00:07:22,540 --> 00:07:30,340
complexity that your updates and

00:07:25,870 --> 00:07:33,050
complexity grows linearly instead of

00:07:30,340 --> 00:07:36,140
exponentially with the size of your

00:07:33,050 --> 00:07:40,100
application and that way it doesn't get

00:07:36,140 --> 00:07:42,380
out of hand so let's define reactivity

00:07:40,100 --> 00:07:45,710
let's see what sets it apart from plain

00:07:42,380 --> 00:07:47,840
updates but before we do that I do want

00:07:45,710 --> 00:07:50,140
to say real quick this isn't the only

00:07:47,840 --> 00:07:53,090
definition of reactivity you might hear

00:07:50,140 --> 00:07:56,150
it's one of those words that's kind of

00:07:53,090 --> 00:07:58,010
fuzzy and it's a buzzword that it's used

00:07:56,150 --> 00:08:00,260
a lot in context right now but and

00:07:58,010 --> 00:08:02,180
people understand what it means but it

00:08:00,260 --> 00:08:05,090
doesn't really have an agreed-upon a

00:08:02,180 --> 00:08:08,840
super agreed-upon definition so this

00:08:05,090 --> 00:08:11,630
definition attempts to look at the goals

00:08:08,840 --> 00:08:15,230
of reactivity the end result that it

00:08:11,630 --> 00:08:17,150
seeks to achieve and I think it actually

00:08:15,230 --> 00:08:20,000
ends up being a very useful definition

00:08:17,150 --> 00:08:21,770
because of that we it shows us the

00:08:20,000 --> 00:08:24,410
similarities between a lot of different

00:08:21,770 --> 00:08:26,870
frameworks such as view and ember and

00:08:24,410 --> 00:08:28,760
react and angular and Speltz

00:08:26,870 --> 00:08:32,120
and it shows us how different those

00:08:28,760 --> 00:08:35,170
frameworks actually are from ones like

00:08:32,120 --> 00:08:37,610
backbone and libraries like jQuery and

00:08:35,170 --> 00:08:41,870
really shows us that that core

00:08:37,610 --> 00:08:44,300
difference so reactivity is a

00:08:41,870 --> 00:08:48,560
declarative programming model for

00:08:44,300 --> 00:08:51,770
updating based on changes to state ok

00:08:48,560 --> 00:08:54,020
seems simple enough but what does that

00:08:51,770 --> 00:08:55,610
what does that mean let's let's dig in a

00:08:54,020 --> 00:08:58,220
little bit deeper there to understand

00:08:55,610 --> 00:09:01,700
exactly what we mean so first off what

00:08:58,220 --> 00:09:04,000
is declarative well declarative is about

00:09:01,700 --> 00:09:06,680
describing what you want to happen

00:09:04,000 --> 00:09:10,610
without describing how you want it to

00:09:06,680 --> 00:09:13,310
happen exactly so for instance hTML is a

00:09:10,610 --> 00:09:15,580
100% declarative programming language

00:09:13,310 --> 00:09:19,640
because you aren't telling the browser

00:09:15,580 --> 00:09:23,150
exactly how to render this HTML you're

00:09:19,640 --> 00:09:25,280
not telling it ok make a header add some

00:09:23,150 --> 00:09:27,320
text to it apply some styles to it and

00:09:25,280 --> 00:09:30,440
paint it in the DOM and then make the

00:09:27,320 --> 00:09:32,900
form know you are handing it the

00:09:30,440 --> 00:09:36,110
structure that you want to see and the

00:09:32,900 --> 00:09:38,000
browser handles the details of that so

00:09:36,110 --> 00:09:40,880
that's really what declarative means

00:09:38,000 --> 00:09:43,370
it's a way to describe our intent and

00:09:40,880 --> 00:09:46,490
allow the system to figure out how to

00:09:43,370 --> 00:09:49,270
handle that on its own without us

00:09:46,490 --> 00:09:52,040
needing to figure out the details and

00:09:49,270 --> 00:09:55,040
then what about the second part of our

00:09:52,040 --> 00:09:57,440
definition what is state well state is

00:09:55,040 --> 00:09:59,780
effectively anything that can change in

00:09:57,440 --> 00:10:04,400
your application things like variables

00:09:59,780 --> 00:10:06,500
properties user inputs and really

00:10:04,400 --> 00:10:10,480
there's two kinds of state there's root

00:10:06,500 --> 00:10:14,450
state and drive state so root state is

00:10:10,480 --> 00:10:16,580
state that has an actual value that that

00:10:14,450 --> 00:10:19,790
act is the actual data that underlies

00:10:16,580 --> 00:10:21,710
your system so in this example the first

00:10:19,790 --> 00:10:23,960
name and last name properties are the

00:10:21,710 --> 00:10:26,960
root state because they are real

00:10:23,960 --> 00:10:29,270
properties with real string values by

00:10:26,960 --> 00:10:32,390
contrast derive state derives its value

00:10:29,270 --> 00:10:34,750
thus the name from other values either

00:10:32,390 --> 00:10:38,930
other root state or other derive state

00:10:34,750 --> 00:10:41,149
so in this example the full name getter

00:10:38,930 --> 00:10:45,010
is to Rive state because its values

00:10:41,149 --> 00:10:48,620
based on first name and last name and

00:10:45,010 --> 00:10:51,110
when we step back we can really see that

00:10:48,620 --> 00:10:54,410
most modern web frameworks are just a

00:10:51,110 --> 00:11:00,820
way to turn read state some API some

00:10:54,410 --> 00:11:06,610
data into HTML which makes that HTML

00:11:00,820 --> 00:11:08,480
derived State so putting it all together

00:11:06,610 --> 00:11:13,490
reactivity is a declarative programming

00:11:08,480 --> 00:11:15,620
model meaning one that we declare our

00:11:13,490 --> 00:11:19,730
intent in and it figures out the details

00:11:15,620 --> 00:11:23,209
for us with for updating derived state

00:11:19,730 --> 00:11:26,930
based on changes to read state and other

00:11:23,209 --> 00:11:29,750
derived state cool okay so now we

00:11:26,930 --> 00:11:33,110
understand what it means but what does

00:11:29,750 --> 00:11:35,080
it actually look like well let's take a

00:11:33,110 --> 00:11:39,730
look at a few reactive solutions and see

00:11:35,080 --> 00:11:42,709
first up we have observables now the

00:11:39,730 --> 00:11:46,990
observables were made popular by rxjs

00:11:42,709 --> 00:11:50,240
and they're used in angularjs and the

00:11:46,990 --> 00:11:52,010
idea behind them is that they are a

00:11:50,240 --> 00:11:54,230
primitive that is an event emitter they

00:11:52,010 --> 00:11:56,930
emit events which then travel through

00:11:54,230 --> 00:12:00,320
what are called streams streams of

00:11:56,930 --> 00:12:02,029
events and these streams can have

00:12:00,320 --> 00:12:03,770
transformations applied to them which

00:12:02,029 --> 00:12:07,220
change them into different types of

00:12:03,770 --> 00:12:10,070
events or collects them or what have you

00:12:07,220 --> 00:12:11,900
they can also do things like debounce

00:12:10,070 --> 00:12:14,330
them they can split streams into

00:12:11,900 --> 00:12:16,820
multiple streams or join them back into

00:12:14,330 --> 00:12:19,790
a single stream and so you end up with

00:12:16,820 --> 00:12:22,040
this network of events and transforms

00:12:19,790 --> 00:12:24,140
and streams and on the other end of the

00:12:22,040 --> 00:12:26,150
network you have subscribers who are

00:12:24,140 --> 00:12:27,970
listening for events and reacting to

00:12:26,150 --> 00:12:31,430
them as they come through the system

00:12:27,970 --> 00:12:33,110
this is known as push based reactivity

00:12:31,430 --> 00:12:37,040
because we're pushing changes through

00:12:33,110 --> 00:12:42,430
the system as they occur so let's see

00:12:37,040 --> 00:12:42,430
what this does to our code answers a lot

00:12:42,610 --> 00:12:47,540
so stepping through it here's our root

00:12:45,440 --> 00:12:50,720
state the list of to do's and the

00:12:47,540 --> 00:12:52,440
displaying property but it's changed

00:12:50,720 --> 00:12:56,220
from being a plain array

00:12:52,440 --> 00:12:58,230
and property to being a observable

00:12:56,220 --> 00:13:02,150
because now we need everything to be in

00:12:58,230 --> 00:13:04,590
terms of this new reactive system

00:13:02,150 --> 00:13:08,790
everything needs to be made in terms of

00:13:04,590 --> 00:13:10,740
events so we create our observables with

00:13:08,790 --> 00:13:14,730
their initial event which is the state

00:13:10,740 --> 00:13:17,370
of the system next up we have our derive

00:13:14,730 --> 00:13:21,990
state the getters originally but now

00:13:17,370 --> 00:13:24,630
they are transforms on those observables

00:13:21,990 --> 00:13:27,480
because again they have to be defined in

00:13:24,630 --> 00:13:30,030
terms of the system so they transform

00:13:27,480 --> 00:13:32,790
the events our state coming through the

00:13:30,030 --> 00:13:37,040
system and split it off into multiple

00:13:32,790 --> 00:13:39,990
streams finally we have our updates and

00:13:37,040 --> 00:13:41,670
our updates once again need to be rear

00:13:39,990 --> 00:13:44,910
ashen alized in terms of this system

00:13:41,670 --> 00:13:47,220
we're no longer just updating objects we

00:13:44,910 --> 00:13:49,380
are pushing new events representing the

00:13:47,220 --> 00:13:50,910
new state through the system and I do

00:13:49,380 --> 00:13:54,180
this with an immutable approach here

00:13:50,910 --> 00:13:56,970
where I clone the previous state and add

00:13:54,180 --> 00:13:59,400
a new state to it so I'm never actually

00:13:56,970 --> 00:14:02,160
mutating anything because you don't want

00:13:59,400 --> 00:14:03,390
necessarily one references to objects

00:14:02,160 --> 00:14:06,240
that are being mutated floating around

00:14:03,390 --> 00:14:08,820
the system but there are many ways you

00:14:06,240 --> 00:14:12,450
could possibly do this in rxjs and this

00:14:08,820 --> 00:14:14,700
is just one method for it the key point

00:14:12,450 --> 00:14:17,640
is that our annotation overhead has

00:14:14,700 --> 00:14:20,220
grown significantly here in some ways we

00:14:17,640 --> 00:14:22,200
we now have to wrap every part of our

00:14:20,220 --> 00:14:26,340
application the rids state that arrives

00:14:22,200 --> 00:14:28,230
state and the actions so that is

00:14:26,340 --> 00:14:32,460
definitely a lot and it may seem like

00:14:28,230 --> 00:14:35,010
wow that's that's not ideal right but

00:14:32,460 --> 00:14:37,950
this is actually not that different from

00:14:35,010 --> 00:14:41,339
what we had an ember classic as it turns

00:14:37,950 --> 00:14:44,390
out in ember classic you had to wrap

00:14:41,339 --> 00:14:47,100
root state things like ember array and

00:14:44,390 --> 00:14:48,870
proxies and what not would be used to

00:14:47,100 --> 00:14:50,370
wrap route stay quite frequently and you

00:14:48,870 --> 00:14:53,700
wouldn't have to do four properties but

00:14:50,370 --> 00:14:56,339
you still had to do it for derive state

00:14:53,700 --> 00:14:57,900
we had to tell the system about every

00:14:56,339 --> 00:15:00,750
computed property in all of its

00:14:57,900 --> 00:15:02,880
dependencies so that was quite a lot of

00:15:00,750 --> 00:15:07,470
annotation that was required

00:15:02,880 --> 00:15:09,930
and then for adding our actions we had

00:15:07,470 --> 00:15:12,720
to tell the system with ember set or

00:15:09,930 --> 00:15:14,340
push object so those were other forms of

00:15:12,720 --> 00:15:17,940
annotations that were required

00:15:14,340 --> 00:15:19,770
so overall ember classic was the same

00:15:17,940 --> 00:15:23,070
amount of an anotation overhead as

00:15:19,770 --> 00:15:26,040
observables and that actually does isn't

00:15:23,070 --> 00:15:29,010
too surprising because amber classic was

00:15:26,040 --> 00:15:30,480
push based we were pushing events

00:15:29,010 --> 00:15:33,120
through the system and it was very

00:15:30,480 --> 00:15:38,640
similar to how observables work under

00:15:33,120 --> 00:15:40,650
the hood so overall this solution is a

00:15:38,640 --> 00:15:43,050
massive win for performance by default

00:15:40,650 --> 00:15:45,440
we are only updating the parts of the

00:15:43,050 --> 00:15:48,540
system that need to be updated

00:15:45,440 --> 00:15:50,190
for ergonomics it arguably is a win

00:15:48,540 --> 00:15:52,350
because it's no longer growing

00:15:50,190 --> 00:15:55,290
exponentially with the size of our

00:15:52,350 --> 00:15:57,930
application in terms of complexity but

00:15:55,290 --> 00:15:59,030
we have lost a lot in the process as

00:15:57,930 --> 00:16:02,910
well

00:15:59,030 --> 00:16:05,340
now you need to know about the system

00:16:02,910 --> 00:16:08,520
and think in terms of it from the very

00:16:05,340 --> 00:16:10,830
GetGo so to become even a little bit

00:16:08,520 --> 00:16:14,040
productive you need to learn a whole new

00:16:10,830 --> 00:16:16,770
layer on top of normal JavaScript so

00:16:14,040 --> 00:16:18,930
that's a lot that's a lot to take in is

00:16:16,770 --> 00:16:20,880
there a way that we could have a system

00:16:18,930 --> 00:16:26,730
where the annotation overhead is lower

00:16:20,880 --> 00:16:28,080
and we can still be reactive well let's

00:16:26,730 --> 00:16:31,590
look at a solution on the other side of

00:16:28,080 --> 00:16:34,800
the aisle virtual Dom so virtual Dom was

00:16:31,590 --> 00:16:37,230
made popular by react and the idea with

00:16:34,800 --> 00:16:39,270
virtual Dom is that rather than trying

00:16:37,230 --> 00:16:42,720
to understand how state flows to the

00:16:39,270 --> 00:16:45,900
system in specific detail it just asks

00:16:42,720 --> 00:16:49,650
one question where did the state change

00:16:45,900 --> 00:16:54,000
occur what component which part of the

00:16:49,650 --> 00:16:56,150
program changed and then it reruns that

00:16:54,000 --> 00:16:59,300
entire component and all of its children

00:16:56,150 --> 00:17:01,680
andrey renders them but it does so

00:16:59,300 --> 00:17:05,010
virtually with a virtual representation

00:17:01,680 --> 00:17:07,470
and then in order to actually update the

00:17:05,010 --> 00:17:10,730
UI it dips that virtual representation

00:17:07,470 --> 00:17:13,530
only applies the parts that have changed

00:17:10,730 --> 00:17:16,300
this is much cheaper than actually fully

00:17:13,530 --> 00:17:18,490
rerender at a massive win

00:17:16,300 --> 00:17:21,760
and this is a form of what is known as

00:17:18,490 --> 00:17:25,450
pull based reactivity because we are

00:17:21,760 --> 00:17:27,700
pulling on the state changes as they

00:17:25,450 --> 00:17:30,460
occur naturally we're not immediately

00:17:27,700 --> 00:17:32,620
propagating them when they occur but we

00:17:30,460 --> 00:17:36,100
are using them in the next render and

00:17:32,620 --> 00:17:39,940
that allows them to naturally update as

00:17:36,100 --> 00:17:45,760
they are used so let's see how this

00:17:39,940 --> 00:17:48,310
affects our code looking first at our

00:17:45,760 --> 00:17:50,290
red state we can see things are kind of

00:17:48,310 --> 00:17:52,600
back to normal we have a plain

00:17:50,290 --> 00:17:54,730
JavaScript array we have this displaying

00:17:52,600 --> 00:17:58,090
property it's all on this state field

00:17:54,730 --> 00:17:59,980
now that's actually not very necessary

00:17:58,090 --> 00:18:02,070
for virtual Dom though it's more of a

00:17:59,980 --> 00:18:05,310
react ism than something that is

00:18:02,070 --> 00:18:12,250
actually required for this strategy so

00:18:05,310 --> 00:18:15,730
back to pure uh Nana Tate 'add root

00:18:12,250 --> 00:18:18,790
state and then we have our derive state

00:18:15,730 --> 00:18:22,000
and our derive state is also back to

00:18:18,790 --> 00:18:23,380
normal so that's pretty great it's when

00:18:22,000 --> 00:18:25,210
we get to our updates where things are a

00:18:23,380 --> 00:18:27,010
little bit different and part of this is

00:18:25,210 --> 00:18:28,690
I'm still using the immutable pattern

00:18:27,010 --> 00:18:30,910
here because that's what react prefers

00:18:28,690 --> 00:18:34,810
itself but really the key difference

00:18:30,910 --> 00:18:37,180
between this and our original solution

00:18:34,810 --> 00:18:40,030
is we now need to call set state in

00:18:37,180 --> 00:18:42,460
order to update state and if we don't

00:18:40,030 --> 00:18:45,070
call this it won't actually update

00:18:42,460 --> 00:18:46,990
because this is what tells the framework

00:18:45,070 --> 00:18:51,130
that this part of the program this

00:18:46,990 --> 00:18:53,770
component needs to re-render this is a

00:18:51,130 --> 00:18:56,740
very small amount of annotation overhead

00:18:53,770 --> 00:18:59,980
have and it's naturally tied to updating

00:18:56,740 --> 00:19:03,700
states so that really helps this is

00:18:59,980 --> 00:19:07,150
something that is honestly one of the

00:19:03,700 --> 00:19:11,410
main reasons why react was so successful

00:19:07,150 --> 00:19:13,990
in all probability it made the developer

00:19:11,410 --> 00:19:15,790
ergonomics so much better because it

00:19:13,990 --> 00:19:17,440
gave developers a huge amount of

00:19:15,790 --> 00:19:19,810
flexibility in how they solve their

00:19:17,440 --> 00:19:21,430
problem and allowed to write that them

00:19:19,810 --> 00:19:25,390
to write code in a way that made sense

00:19:21,430 --> 00:19:27,880
to them you may have noticed I'm

00:19:25,390 --> 00:19:28,809
actually not using the latest and

00:19:27,880 --> 00:19:31,779
greatest for me

00:19:28,809 --> 00:19:35,499
not using hooks that actually was an

00:19:31,779 --> 00:19:39,070
intentional choice because hooks kind of

00:19:35,499 --> 00:19:40,899
make it seem like they're adding more

00:19:39,070 --> 00:19:44,649
annotation overhead you have to learn

00:19:40,899 --> 00:19:46,450
about these used state things and the

00:19:44,649 --> 00:19:48,429
various other types of hooks and how

00:19:46,450 --> 00:19:51,220
they have to be run in a particular

00:19:48,429 --> 00:19:53,320
order every time in order to write code

00:19:51,220 --> 00:19:56,169
in the system and that's true there is

00:19:53,320 --> 00:19:58,809
more annotation overhead in general but

00:19:56,169 --> 00:20:01,480
that annotation overhead doesn't have

00:19:58,809 --> 00:20:05,440
anything to do with reactivity as a

00:20:01,480 --> 00:20:07,450
whole because from the reactivity model

00:20:05,440 --> 00:20:10,809
standpoint all it needs is something to

00:20:07,450 --> 00:20:13,179
tell it what has changed at what points

00:20:10,809 --> 00:20:15,309
and that's what happens when we call set

00:20:13,179 --> 00:20:16,869
to do from a hook it tells the

00:20:15,309 --> 00:20:18,549
reactivity model hey this part of the

00:20:16,869 --> 00:20:23,049
program has changed rerun everything

00:20:18,549 --> 00:20:24,450
below it so yeah all the extra

00:20:23,049 --> 00:20:27,029
annotation overhead is on the

00:20:24,450 --> 00:20:30,899
programming model side of things and

00:20:27,029 --> 00:20:34,269
this really demonstrates how flexible

00:20:30,899 --> 00:20:37,419
react is our virtual Dom is as a

00:20:34,269 --> 00:20:41,490
strategy it can handle both of these

00:20:37,419 --> 00:20:45,009
very different models hooks and

00:20:41,490 --> 00:20:46,720
class-based components without needing

00:20:45,009 --> 00:20:50,710
to know the details of them at all so

00:20:46,720 --> 00:20:54,700
that's that's pretty great the downside

00:20:50,710 --> 00:20:58,299
is performance because this model

00:20:54,700 --> 00:21:01,690
unfortunately doesn't scale at a certain

00:20:58,299 --> 00:21:03,999
point we running the program entirely

00:21:01,690 --> 00:21:06,730
even sub sections of it and even only

00:21:03,999 --> 00:21:10,330
doing virtual Dom is still very

00:21:06,730 --> 00:21:12,669
expensive and this is why things like

00:21:10,330 --> 00:21:16,090
use memo and should component update and

00:21:12,669 --> 00:21:20,830
reacts concurrent mode exist because

00:21:16,090 --> 00:21:25,149
they are allowing users to manually try

00:21:20,830 --> 00:21:27,129
to optimize and make react faster and

00:21:25,149 --> 00:21:29,230
make this virtual Dom strategy faster

00:21:27,129 --> 00:21:31,720
and this is where a lot of complexity

00:21:29,230 --> 00:21:33,850
can begin to enter react apps because

00:21:31,720 --> 00:21:35,289
now we're doing the math in our head

00:21:33,850 --> 00:21:38,289
again now we're trying to manually

00:21:35,289 --> 00:21:41,470
figure out what are our patterns and how

00:21:38,289 --> 00:21:42,220
do we how do we have two things and

00:21:41,470 --> 00:21:44,500
prevent updating

00:21:42,220 --> 00:21:51,159
so we're doing some more work of the

00:21:44,500 --> 00:21:52,860
reactive system so let's step back so

00:21:51,159 --> 00:21:57,370
far we've looked at two different

00:21:52,860 --> 00:21:59,530
reactivity models observables were very

00:21:57,370 --> 00:22:02,200
performant but they required a lot of

00:21:59,530 --> 00:22:03,700
annotation and they had us constantly

00:22:02,200 --> 00:22:05,650
thinking about the reactivity model

00:22:03,700 --> 00:22:08,559
everywhere we wrote code we had to think

00:22:05,650 --> 00:22:12,010
about it on the other side we had

00:22:08,559 --> 00:22:13,750
virtual Dom and virtual Dom was much

00:22:12,010 --> 00:22:15,760
more minimal in terms of the annotation

00:22:13,750 --> 00:22:18,490
that was required you only had to put it

00:22:15,760 --> 00:22:21,610
on updates and it was very flexible

00:22:18,490 --> 00:22:23,710
because of this but it wasn't very

00:22:21,610 --> 00:22:25,840
performant by default it required some

00:22:23,710 --> 00:22:29,530
manual optimization at a certain point

00:22:25,840 --> 00:22:31,690
at a certain scale and so yeah that

00:22:29,530 --> 00:22:35,169
there seems to be this trade-off between

00:22:31,690 --> 00:22:36,640
the amount of annotation that the system

00:22:35,169 --> 00:22:40,690
requires and how much information it

00:22:36,640 --> 00:22:45,280
knows about what's going on and the

00:22:40,690 --> 00:22:48,250
amount of annotation overhead so the

00:22:45,280 --> 00:22:53,669
question is can we bend the curve can we

00:22:48,250 --> 00:22:54,820
have a reactivity solution that is both

00:22:53,669 --> 00:23:00,030
performant

00:22:54,820 --> 00:23:04,090
by default and that require has minimal

00:23:00,030 --> 00:23:07,659
annotation overhead and our auto

00:23:04,090 --> 00:23:11,140
tracking so auto tracking approaches

00:23:07,659 --> 00:23:15,150
this from a different angle it tries to

00:23:11,140 --> 00:23:17,350
focus entirely on rich State in

00:23:15,150 --> 00:23:19,570
JavaScript we already have a state model

00:23:17,350 --> 00:23:22,150
we have a way for updating state and

00:23:19,570 --> 00:23:23,980
that's through things like pushing into

00:23:22,150 --> 00:23:27,070
an array and setting properties on an

00:23:23,980 --> 00:23:29,409
object and auto tracking tries to

00:23:27,070 --> 00:23:32,140
capture that and so that it can

00:23:29,409 --> 00:23:34,510
interpret those in a way that allows it

00:23:32,140 --> 00:23:38,860
to tell us when things have changed when

00:23:34,510 --> 00:23:41,549
needed so let's see how that effects our

00:23:38,860 --> 00:23:41,549
application

00:23:43,169 --> 00:23:48,190
the first thing we'll notice is that

00:23:45,160 --> 00:23:50,890
there's this new to do class because in

00:23:48,190 --> 00:23:53,590
Auto tracking we need to wrap all of our

00:23:50,890 --> 00:23:56,320
annotate all of our routes state so that

00:23:53,590 --> 00:23:58,570
the system knows about it so we have the

00:23:56,320 --> 00:24:00,220
tracked decorator to track our various

00:23:58,570 --> 00:24:01,929
properties title completed the

00:24:00,220 --> 00:24:04,539
displaying property on our to-do list

00:24:01,929 --> 00:24:07,030
component and we also have this tracked

00:24:04,539 --> 00:24:10,299
array which is just a reactive array

00:24:07,030 --> 00:24:12,669
it's not provided by Amber it's provided

00:24:10,299 --> 00:24:15,549
by the tracked built-ins add-on that I

00:24:12,669 --> 00:24:16,809
maintain but you can just think of it as

00:24:15,549 --> 00:24:19,059
an array that you can treat like a

00:24:16,809 --> 00:24:21,070
normal array but when you mutate it it

00:24:19,059 --> 00:24:24,909
will let the system know that changes

00:24:21,070 --> 00:24:27,820
have occurred and once we wrap our route

00:24:24,909 --> 00:24:29,470
state this way we can see that

00:24:27,820 --> 00:24:33,429
everything else kind of falls into place

00:24:29,470 --> 00:24:35,860
we are derived state is just like normal

00:24:33,429 --> 00:24:38,049
and so are our updates they are just

00:24:35,860 --> 00:24:43,450
like the original example without any

00:24:38,049 --> 00:24:46,570
details needed to be changed so this is

00:24:43,450 --> 00:24:49,539
a massive win for ergonomics overall

00:24:46,570 --> 00:24:51,909
because it requires minimal annotation

00:24:49,539 --> 00:24:55,600
overhead only on one part of the system

00:24:51,909 --> 00:24:58,480
just like virtual dumb but it's also a

00:24:55,600 --> 00:25:02,169
massive win for performance because it

00:24:58,480 --> 00:25:05,200
is just as performant as observables if

00:25:02,169 --> 00:25:09,070
not more performant the secret here is

00:25:05,200 --> 00:25:12,760
that auto tracking associates read state

00:25:09,070 --> 00:25:14,679
without put and it does so without

00:25:12,760 --> 00:25:17,140
caring about the details of how that

00:25:14,679 --> 00:25:22,179
output is generated to it all of those

00:25:17,140 --> 00:25:24,070
details are just a black box how does it

00:25:22,179 --> 00:25:27,400
do this with a technique known as

00:25:24,070 --> 00:25:30,340
memoization normalization is a technique

00:25:27,400 --> 00:25:34,809
where we return a previously computed

00:25:30,340 --> 00:25:37,150
value if nothing has changed so for

00:25:34,809 --> 00:25:39,700
instance in this example we have a

00:25:37,150 --> 00:25:41,830
memorized render function which has a

00:25:39,700 --> 00:25:45,909
call to a real render function within it

00:25:41,830 --> 00:25:48,010
it stores the last value of that render

00:25:45,909 --> 00:25:52,080
function and it stores the last

00:25:48,010 --> 00:25:55,000
arguments so the next time it's called

00:25:52,080 --> 00:25:55,420
if the arguments it's called with are

00:25:55,000 --> 00:25:58,510
this

00:25:55,420 --> 00:26:00,850
same as it was last time it will return

00:25:58,510 --> 00:26:04,000
the last result and skip calling render

00:26:00,850 --> 00:26:06,190
altogether memorization is a way that we

00:26:04,000 --> 00:26:10,230
can really speed up applications because

00:26:06,190 --> 00:26:13,210
we can skip unnecessary work this way

00:26:10,230 --> 00:26:15,400
but in Auto tracking apps we want to do

00:26:13,210 --> 00:26:17,500
something slightly different we don't

00:26:15,400 --> 00:26:19,900
want to memorize based on the arguments

00:26:17,500 --> 00:26:22,930
that are passed to us we want to

00:26:19,900 --> 00:26:25,960
memorize based on the values we access

00:26:22,930 --> 00:26:30,550
while running the function so for

00:26:25,960 --> 00:26:33,730
instance if this was our track state and

00:26:30,550 --> 00:26:37,630
this was the function that we wanted to

00:26:33,730 --> 00:26:40,900
memorize we would want to memorize based

00:26:37,630 --> 00:26:43,180
on these values that are accessed on the

00:26:40,900 --> 00:26:46,480
track state during the call of the

00:26:43,180 --> 00:26:48,880
function such that if any one of them

00:26:46,480 --> 00:26:51,550
changes the next time we call this

00:26:48,880 --> 00:26:54,070
function we rerun it and if none of them

00:26:51,550 --> 00:26:58,600
change we just return the previous value

00:26:54,070 --> 00:27:02,860
and that's it so how do we do this well

00:26:58,600 --> 00:27:06,250
it all starts with a single number the

00:27:02,860 --> 00:27:08,440
global revision counter and whenever any

00:27:06,250 --> 00:27:11,860
state changes in the application we

00:27:08,440 --> 00:27:14,200
increment this number I like to think of

00:27:11,860 --> 00:27:19,480
this as a clock only instead of tracking

00:27:14,200 --> 00:27:21,640
time it tracks changes to state as we

00:27:19,480 --> 00:27:24,790
change state we are creating new

00:27:21,640 --> 00:27:27,430
versions of state in the app and the

00:27:24,790 --> 00:27:30,610
clock always keeps track of the most

00:27:27,430 --> 00:27:33,100
recent version so you can see how this

00:27:30,610 --> 00:27:34,780
would be a good rudimentary way to

00:27:33,100 --> 00:27:37,060
understand if something has changed in

00:27:34,780 --> 00:27:39,340
the app we look at the clock we memorize

00:27:37,060 --> 00:27:41,230
the time we go back to whatever we were

00:27:39,340 --> 00:27:43,210
doing and the next time we want to check

00:27:41,230 --> 00:27:45,550
if something has changed we look back at

00:27:43,210 --> 00:27:49,120
the clock is it later than it was is it

00:27:45,550 --> 00:27:52,240
a higher value than it was yes cool

00:27:49,120 --> 00:27:55,990
something has changed now we know at

00:27:52,240 --> 00:27:58,120
that but really we also want to tell if

00:27:55,990 --> 00:28:00,960
like a specific piece of state has

00:27:58,120 --> 00:28:05,560
changed usually not just like any state

00:28:00,960 --> 00:28:07,500
so for that we need tags every piece of

00:28:05,560 --> 00:28:12,480
state in the application has a

00:28:07,500 --> 00:28:15,630
and every tag has a value and that value

00:28:12,480 --> 00:28:18,390
is a version of the clock whenever we

00:28:15,630 --> 00:28:20,190
want to change this piece of state we

00:28:18,390 --> 00:28:22,500
first increment the clock because

00:28:20,190 --> 00:28:26,100
something has changed and then we assign

00:28:22,500 --> 00:28:29,040
that value to the tag so in this way

00:28:26,100 --> 00:28:32,040
tags always contain the most recent

00:28:29,040 --> 00:28:36,960
version of state that they were updated

00:28:32,040 --> 00:28:40,020
in okay so now going back to our

00:28:36,960 --> 00:28:42,930
original memorized function as we run

00:28:40,020 --> 00:28:46,170
through and execute this function we as

00:28:42,930 --> 00:28:51,420
we encounter track state we store the

00:28:46,170 --> 00:28:54,990
tags and save them for later we store

00:28:51,420 --> 00:28:57,060
them and we also save the value that is

00:28:54,990 --> 00:29:00,690
highest out of all of them the maximum

00:28:57,060 --> 00:29:03,030
value and the next time we come back to

00:29:00,690 --> 00:29:05,520
this function we check that maximum

00:29:03,030 --> 00:29:08,420
value again we iterate through the tags

00:29:05,520 --> 00:29:12,840
again and find the maximum value again

00:29:08,420 --> 00:29:15,390
if that maximum value is the same then

00:29:12,840 --> 00:29:17,490
we know for sure that nothing has

00:29:15,390 --> 00:29:21,060
changed within this function and we can

00:29:17,490 --> 00:29:23,760
return the previous value and if it's

00:29:21,060 --> 00:29:25,920
higher than it was previously then we

00:29:23,760 --> 00:29:30,360
know something must have changed and we

00:29:25,920 --> 00:29:32,340
need to rerun the function how can we

00:29:30,360 --> 00:29:36,150
know that for sure well let's step

00:29:32,340 --> 00:29:37,980
through it let's say we change something

00:29:36,150 --> 00:29:42,450
within the function we increment the

00:29:37,980 --> 00:29:45,960
clock we update the tag to match the new

00:29:42,450 --> 00:29:48,210
value of the clock and the next time we

00:29:45,960 --> 00:29:49,980
come back to this function we check the

00:29:48,210 --> 00:29:52,140
maximum value and it's higher than it

00:29:49,980 --> 00:29:55,080
was previously so we know for sure that

00:29:52,140 --> 00:29:59,010
something has changed we rewound the

00:29:55,080 --> 00:30:00,090
function and let's look at the opposite

00:29:59,010 --> 00:30:02,250
let's say we changed some state

00:30:00,090 --> 00:30:04,500
somewhere else in the app we increment

00:30:02,250 --> 00:30:08,580
the clock again we match the value like

00:30:04,500 --> 00:30:10,650
before but because that tag was not used

00:30:08,580 --> 00:30:12,630
in our function it's not part of the set

00:30:10,650 --> 00:30:15,630
we check so it doesn't affect the

00:30:12,630 --> 00:30:18,630
maximum value of the tags of our state

00:30:15,630 --> 00:30:20,669
and so the maximum value stays the same

00:30:18,630 --> 00:30:22,859
so we know for sure nothing

00:30:20,669 --> 00:30:26,609
changed and it's safe to use the

00:30:22,859 --> 00:30:32,730
previous value our memorization strategy

00:30:26,609 --> 00:30:35,429
works okay let's take a look at what

00:30:32,730 --> 00:30:39,499
operations that required the dirty State

00:30:35,429 --> 00:30:42,899
all we had to do was increment a number

00:30:39,499 --> 00:30:44,489
to validate it to check whether or not

00:30:42,899 --> 00:30:46,230
it was still valid all we have to do is

00:30:44,489 --> 00:30:48,320
map through an array of tags and take

00:30:46,230 --> 00:30:51,359
the maximum value out of all of them

00:30:48,320 --> 00:30:53,279
this is all done lazily so you can

00:30:51,359 --> 00:30:54,749
update a thousand pieces of State and

00:30:53,279 --> 00:30:57,359
all that's doing is incrementing a

00:30:54,749 --> 00:31:01,159
thousand numbers and then the next time

00:30:57,359 --> 00:31:04,409
you go to render you are checking

00:31:01,159 --> 00:31:06,629
validation only if needed if you skip an

00:31:04,409 --> 00:31:07,739
entire section of the app if you deleted

00:31:06,629 --> 00:31:09,570
it or got rid of it

00:31:07,739 --> 00:31:14,549
you don't ever need to do that

00:31:09,570 --> 00:31:16,619
validation you get all of this and all

00:31:14,549 --> 00:31:19,259
you need to do is annotate read state

00:31:16,619 --> 00:31:22,799
every other part of the system handles

00:31:19,259 --> 00:31:26,279
itself read state and the portions that

00:31:22,799 --> 00:31:29,879
you want to memorize this is what

00:31:26,279 --> 00:31:32,639
bending the curve looks like incredible

00:31:29,879 --> 00:31:36,690
developer ergonomics performant by

00:31:32,639 --> 00:31:39,899
default this is hands-down the most

00:31:36,690 --> 00:31:42,419
exciting feature to me in modern ember

00:31:39,899 --> 00:31:47,369
and one of the most amazing things about

00:31:42,419 --> 00:31:49,409
the framework as a whole to me so what's

00:31:47,369 --> 00:31:50,879
next now that we have this amazing new

00:31:49,409 --> 00:31:51,889
reactivity model what are we going to

00:31:50,879 --> 00:31:56,220
build on top of it

00:31:51,889 --> 00:31:58,409
well first up I would like to see more

00:31:56,220 --> 00:31:59,999
libraries and patterns and common

00:31:58,409 --> 00:32:02,909
abstractions built on top of auto

00:31:59,999 --> 00:32:04,649
tracking we had a lot of these for

00:32:02,909 --> 00:32:07,350
computed properties one of my favorites

00:32:04,649 --> 00:32:10,619
was ember macro helpers which was a way

00:32:07,350 --> 00:32:13,379
to define various macros for computers

00:32:10,619 --> 00:32:16,710
stuff like that is going to be very very

00:32:13,379 --> 00:32:18,179
helpful for auto tracking and I've

00:32:16,710 --> 00:32:20,070
already started with the tracked

00:32:18,179 --> 00:32:24,210
built-ins add-on which creates tracked

00:32:20,070 --> 00:32:28,590
versions of Java scripts arrays and maps

00:32:24,210 --> 00:32:31,470
and sets allowing people to create use

00:32:28,590 --> 00:32:33,030
them as route state using their standard

00:32:31,470 --> 00:32:36,600
api's

00:32:33,030 --> 00:32:39,000
and I think we could see more of this we

00:32:36,600 --> 00:32:41,550
can see tracked localstorage and tracked

00:32:39,000 --> 00:32:44,640
indexeddb II tracked versions of Apollo

00:32:41,550 --> 00:32:46,020
and redux I think that making more

00:32:44,640 --> 00:32:47,430
libraries like this will be very helpful

00:32:46,020 --> 00:32:50,460
and I'm very excited to see what the

00:32:47,430 --> 00:32:52,710
community does with that beyond that I

00:32:50,460 --> 00:32:54,750
think that tooling is very important and

00:32:52,710 --> 00:32:59,160
I would like to see us invest a lot more

00:32:54,750 --> 00:33:00,420
in that space I think that actually auto

00:32:59,160 --> 00:33:03,870
tracking kind of gives us an

00:33:00,420 --> 00:33:06,180
unprecedented ability and a chance to

00:33:03,870 --> 00:33:08,310
really make some amazing tooling

00:33:06,180 --> 00:33:10,400
improvements we can do things like when

00:33:08,310 --> 00:33:13,740
you're pausing and debugger tell you

00:33:10,400 --> 00:33:16,530
what you've Auto tracked so far how many

00:33:13,740 --> 00:33:19,490
things are memorized above you what

00:33:16,530 --> 00:33:21,870
changed - cause this code to rerun again

00:33:19,490 --> 00:33:27,270
questions that would be very difficult

00:33:21,870 --> 00:33:30,540
to answer otherwise and I even can see

00:33:27,270 --> 00:33:32,910
some potential improvements to the Ember

00:33:30,540 --> 00:33:36,600
inspector I imagine a state timeline

00:33:32,910 --> 00:33:38,910
that shows the exact order of operations

00:33:36,600 --> 00:33:40,890
the the exact state changes that have

00:33:38,910 --> 00:33:43,230
happened in your application - bringing

00:33:40,890 --> 00:33:45,630
it to where you're at in that moment and

00:33:43,230 --> 00:33:48,870
because of the way Auto tracking works

00:33:45,630 --> 00:33:51,510
we can show you exactly which components

00:33:48,870 --> 00:33:53,820
those state changes are related to we

00:33:51,510 --> 00:33:55,500
can show you which components dirtied

00:33:53,820 --> 00:33:57,870
and updated and were created and we're

00:33:55,500 --> 00:34:00,720
destroyed and we can we can show that

00:33:57,870 --> 00:34:06,920
all to you and show your entanglements

00:34:00,720 --> 00:34:11,250
and everything finally I I want to say

00:34:06,920 --> 00:34:14,940
Auto tracking in a lot of ways is to me

00:34:11,250 --> 00:34:20,840
larger than ever and what I mean by that

00:34:14,940 --> 00:34:24,600
is that it is it's really a general

00:34:20,840 --> 00:34:27,060
reactivity model it's something that can

00:34:24,600 --> 00:34:29,310
be used outside of the context of a

00:34:27,060 --> 00:34:32,429
rendering engine and a view layer it can

00:34:29,310 --> 00:34:34,409
be used anywhere and so and it also is a

00:34:32,429 --> 00:34:37,020
reactivity model that doesn't really

00:34:34,409 --> 00:34:39,330
exist in the wider JavaScript ecosystem

00:34:37,020 --> 00:34:42,750
yet there's nothing really quite like it

00:34:39,330 --> 00:34:45,179
yet mob X and views reactivity are

00:34:42,750 --> 00:34:46,270
similar but there are some pretty

00:34:45,179 --> 00:34:49,550
fundamental difference

00:34:46,270 --> 00:34:51,560
so I'd really like to see us extract it

00:34:49,550 --> 00:34:54,290
and make it usable not only a number

00:34:51,560 --> 00:34:56,840
apps but everywhere so that we can share

00:34:54,290 --> 00:34:59,390
all of the utilities built on top of it

00:34:56,840 --> 00:35:05,060
that we we can share all of the value

00:34:59,390 --> 00:35:07,190
generated by it in general and yeah I I

00:35:05,060 --> 00:35:09,859
think it would be incredibly valuable to

00:35:07,190 --> 00:35:13,180
do that I've even thought as time has

00:35:09,859 --> 00:35:16,640
gone on that it really would make a good

00:35:13,180 --> 00:35:19,010
system a good solution for adding

00:35:16,640 --> 00:35:20,810
reactivity on the language level itself

00:35:19,010 --> 00:35:21,530
either to JavaScript or to another

00:35:20,810 --> 00:35:24,440
language

00:35:21,530 --> 00:35:27,320
unlike previous attempts to do this it's

00:35:24,440 --> 00:35:29,510
not something that requires synchronous

00:35:27,320 --> 00:35:35,060
code to run and it's not super invasive

00:35:29,510 --> 00:35:41,090
so it could be kind of ideal and beyond

00:35:35,060 --> 00:35:43,369
that it's paradigm las' you don't need

00:35:41,090 --> 00:35:45,290
to write object-oriented code for it to

00:35:43,369 --> 00:35:47,240
work you don't need to write functional

00:35:45,290 --> 00:35:48,800
code for it to work you don't need to

00:35:47,240 --> 00:35:50,630
write imperative code for it to work you

00:35:48,800 --> 00:35:53,750
don't you can write any kind of code and

00:35:50,630 --> 00:35:56,030
it works with it because all it cares

00:35:53,750 --> 00:35:58,700
about is that you have properly

00:35:56,030 --> 00:36:00,980
annotated your read state and for a

00:35:58,700 --> 00:36:03,410
language level feature a language that

00:36:00,980 --> 00:36:06,560
is you're able to do all three of those

00:36:03,410 --> 00:36:13,130
in quite a lot that would be ideal

00:36:06,560 --> 00:36:16,130
I think so anyways that's all I've got

00:36:13,130 --> 00:36:17,990
if you're interested in this topic I've

00:36:16,130 --> 00:36:22,960
been logging in more depth on auto

00:36:17,990 --> 00:36:22,960

YouTube URL: https://www.youtube.com/watch?v=HDBSU2HCLbU


