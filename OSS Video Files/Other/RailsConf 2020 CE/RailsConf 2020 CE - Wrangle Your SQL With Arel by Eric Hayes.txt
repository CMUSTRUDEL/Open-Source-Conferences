Title: RailsConf 2020 CE - Wrangle Your SQL With Arel by Eric Hayes
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Wrangle Your SQL With Arel by Eric Hayes

"You wanted to use those fancy Postgres features so you wrote raw SQL. Some time and a few more features go by and now your app is littered with SQL strings. Keep the power and lose the mess by building composable query objects that leverage Arel, the query builder under the hood of ActiveRecord.

Come to this talk and learn what Arel is, how to construct complex SQL with Ruby, and how to wrap it all up in model-like classes that play nice with Rails."

__________

Eric Hayes started using Ruby while working at a school district in 2006. He's been social distancing since 2016 working remotely for Red Hat. In 2017 he became the CTO of a small, all-remote business where he gets to play with everything from design to databases.
Captions: 
	00:00:09,620 --> 00:00:15,139
hi I'm Eric Hayes I lead development for

00:00:13,070 --> 00:00:17,900
a small business that provides a

00:00:15,139 --> 00:00:20,930
reporting app for nonprofits like

00:00:17,900 --> 00:00:23,630
churches we would have what I say a

00:00:20,930 --> 00:00:26,119
medium a database size compared to other

00:00:23,630 --> 00:00:27,590
organizations we have several tables

00:00:26,119 --> 00:00:29,990
that are in the millions or tens of

00:00:27,590 --> 00:00:31,629
millions of rows so we need to do

00:00:29,990 --> 00:00:34,070
everything we can inside the database

00:00:31,629 --> 00:00:36,920
that's why a couple years ago I started

00:00:34,070 --> 00:00:40,160
really learning sequel and everything

00:00:36,920 --> 00:00:42,950
that we could do with Postgres and a lot

00:00:40,160 --> 00:00:45,489
of that is what led to this talk to jump

00:00:42,950 --> 00:00:48,200
in we need some target sequel to write

00:00:45,489 --> 00:00:49,969
imagine we work for a charity the donor

00:00:48,200 --> 00:00:52,910
relations department wants us to help

00:00:49,969 --> 00:00:55,640
identify their donor retention or

00:00:52,910 --> 00:00:58,219
whatever this could easily be adapted

00:00:55,640 --> 00:01:01,340
for various product metrics like return

00:00:58,219 --> 00:01:03,590
visits but usually I like to begin by

00:01:01,340 --> 00:01:06,289
experimenting with sequel first to find

00:01:03,590 --> 00:01:07,880
the results I want here's an example I'm

00:01:06,289 --> 00:01:10,399
going to assume you know the basics of

00:01:07,880 --> 00:01:12,680
sequel but even for a pro this query

00:01:10,399 --> 00:01:16,250
could look daunting let's highlight the

00:01:12,680 --> 00:01:18,470
interesting bits first we want to get

00:01:16,250 --> 00:01:22,190
the first time a donor donated with the

00:01:18,470 --> 00:01:24,410
min aggregate function we use the date

00:01:22,190 --> 00:01:27,890
trunk function to turn whatever date

00:01:24,410 --> 00:01:30,080
that is into just a month this groups

00:01:27,890 --> 00:01:33,679
all of our donors by the first month

00:01:30,080 --> 00:01:36,369
they donated then we select one as a

00:01:33,679 --> 00:01:39,619
marker that they donated in this month

00:01:36,369 --> 00:01:41,479
next we change several similar

00:01:39,619 --> 00:01:44,660
statements together with a left join

00:01:41,479 --> 00:01:46,940
lateral this special join allows us to

00:01:44,660 --> 00:01:49,490
reference values in the original g0

00:01:46,940 --> 00:01:51,560
query when experimenting with see

00:01:49,490 --> 00:01:54,050
quality is a pretty cool Mac app called

00:01:51,560 --> 00:01:57,410
post eco here I've loaded up the query

00:01:54,050 --> 00:02:02,239
and ran it and you can see the results

00:01:57,410 --> 00:02:09,830
so for each donor ID we have the first

00:02:02,239 --> 00:02:13,310
gift that they gave and then the last

00:02:09,830 --> 00:02:16,670
three columns are one month out from

00:02:13,310 --> 00:02:18,920
their first month so if they gave if

00:02:16,670 --> 00:02:22,050
they made a donation four times they

00:02:18,920 --> 00:02:24,000
have one in four columns

00:02:22,050 --> 00:02:26,760
now there's duplication here that we

00:02:24,000 --> 00:02:28,890
want to automate and there are useful

00:02:26,760 --> 00:02:30,140
snippets that we want to rearrange or

00:02:28,890 --> 00:02:33,170
recompose on-the-fly

00:02:30,140 --> 00:02:36,600
for example this version gives us

00:02:33,170 --> 00:02:38,610
individual donor timelines with a few

00:02:36,600 --> 00:02:41,130
changes though we can aggregate the data

00:02:38,610 --> 00:02:43,920
into counts and now we have a cohort

00:02:41,130 --> 00:02:49,230
table well we have the makings of a

00:02:43,920 --> 00:02:51,180
cohort table any way we like to have at

00:02:49,230 --> 00:02:56,690
least 12 of these columns but you could

00:02:51,180 --> 00:03:01,260
see here how the sums have aggregated

00:02:56,690 --> 00:03:05,520
the results and we can start to see a

00:03:01,260 --> 00:03:08,430
retention over time there are a lot more

00:03:05,520 --> 00:03:10,980
ways we can use this sequel we can

00:03:08,430 --> 00:03:13,860
select different things we can add where

00:03:10,980 --> 00:03:16,050
clauses change dates and get totally

00:03:13,860 --> 00:03:18,060
different insights but you can see how

00:03:16,050 --> 00:03:20,910
this starts to getting unwieldy to write

00:03:18,060 --> 00:03:23,100
by hand one thing we could do is just

00:03:20,910 --> 00:03:25,350
build this with strings using loops and

00:03:23,100 --> 00:03:27,060
string interpolation and if this were

00:03:25,350 --> 00:03:29,190
the only special query that would

00:03:27,060 --> 00:03:31,160
probably be the right approach just

00:03:29,190 --> 00:03:33,390
build it with strings and call it done

00:03:31,160 --> 00:03:35,459
but as the number of different queries

00:03:33,390 --> 00:03:36,780
grows it becomes harder and harder to

00:03:35,459 --> 00:03:40,230
keep things working as they're

00:03:36,780 --> 00:03:42,240
rearranged and used in different ways my

00:03:40,230 --> 00:03:44,820
team inherited an app like this

00:03:42,240 --> 00:03:47,280
it was littered with impenetrable blocks

00:03:44,820 --> 00:03:49,170
of unformatted sequel we ended up

00:03:47,280 --> 00:03:51,300
writing around those files rather than

00:03:49,170 --> 00:03:53,580
trying to maintain them now the other

00:03:51,300 --> 00:03:55,890
thing we could do is do what a active

00:03:53,580 --> 00:03:59,250
record does which uses a rail onto the

00:03:55,890 --> 00:04:02,280
hood but there's a slight catch and that

00:03:59,250 --> 00:04:05,850
is that a rail is considered private API

00:04:02,280 --> 00:04:08,100
and rails in this context private means

00:04:05,850 --> 00:04:10,530
that it is considered an implementation

00:04:08,100 --> 00:04:14,310
detail that is subject to change without

00:04:10,530 --> 00:04:16,560
warning contrast this with an active

00:04:14,310 --> 00:04:20,760
record example here's something I ran

00:04:16,560 --> 00:04:23,490
into the other day at least in rails 6.0

00:04:20,760 --> 00:04:27,419
point-to-point - if we pass multiple

00:04:23,490 --> 00:04:31,080
conditions - we're not we will get the

00:04:27,419 --> 00:04:33,090
following warning it basically tells us

00:04:31,080 --> 00:04:35,870
that the way this method works today

00:04:33,090 --> 00:04:38,550
will change in rails 6.1

00:04:35,870 --> 00:04:41,520
it also gives us a helpful hint about

00:04:38,550 --> 00:04:43,410
how to change our code today so that

00:04:41,520 --> 00:04:45,870
things work the way we expect after

00:04:43,410 --> 00:04:48,960
upgrading we should not expect the same

00:04:45,870 --> 00:04:51,480
warning from a rail code it's not like

00:04:48,960 --> 00:04:53,510
the code is going to be broken it is

00:04:51,480 --> 00:04:57,000
tested with the rest of rails after all

00:04:53,510 --> 00:04:59,000
but the a rail code we we write comes

00:04:57,000 --> 00:05:01,920
with a greater responsibility to test

00:04:59,000 --> 00:05:05,040
this might be an unacceptable risk for

00:05:01,920 --> 00:05:06,780
your team but my team weighed the

00:05:05,040 --> 00:05:08,910
trade-offs and discovered that with a

00:05:06,780 --> 00:05:11,910
little test coverage we were protected

00:05:08,910 --> 00:05:14,550
from unexpected changes we've now

00:05:11,910 --> 00:05:17,790
carried our a rail code from rails 4.2

00:05:14,550 --> 00:05:19,710
to Rails 6.0 let's take a closer look at

00:05:17,790 --> 00:05:22,860
a rail by comparing it with some active

00:05:19,710 --> 00:05:24,810
record code here's an active record

00:05:22,860 --> 00:05:27,960
query and here's the equivalent query

00:05:24,810 --> 00:05:31,560
written in a rail notice we called to

00:05:27,960 --> 00:05:33,900
sequel on the active record code to

00:05:31,560 --> 00:05:36,570
build an a rail query we start by

00:05:33,900 --> 00:05:39,150
calling the dot a rail method on an

00:05:36,570 --> 00:05:41,310
active record model and storing it in a

00:05:39,150 --> 00:05:43,820
variable we're going to use this in

00:05:41,310 --> 00:05:43,820
several places

00:05:44,180 --> 00:05:49,170
next we call the project method to set

00:05:47,160 --> 00:05:51,060
up our select Clause I think it's named

00:05:49,170 --> 00:05:52,650
this way because they're trying to avoid

00:05:51,060 --> 00:05:56,760
collisions with other methods named

00:05:52,650 --> 00:05:59,550
select to reference a column we use the

00:05:56,760 --> 00:06:02,610
square brackets on table like we would

00:05:59,550 --> 00:06:05,310
with a hash we use the shortcut a rail

00:06:02,610 --> 00:06:08,370
dot star to give us a correctly quoted

00:06:05,310 --> 00:06:11,610
star and we pass it to the table because

00:06:08,370 --> 00:06:14,520
we want users dot star to match the

00:06:11,610 --> 00:06:16,560
active record version if we just wanted

00:06:14,520 --> 00:06:20,190
star we could pass a rail dot star alone

00:06:16,560 --> 00:06:23,040
in the wear method we reference the

00:06:20,190 --> 00:06:25,770
created at column on the table and use

00:06:23,040 --> 00:06:30,210
the LT predicate method to get the less

00:06:25,770 --> 00:06:34,980
than comparison with the date finally we

00:06:30,210 --> 00:06:37,890
call to sequel to output sequel let's

00:06:34,980 --> 00:06:40,050
compare the output from each the main

00:06:37,890 --> 00:06:42,300
difference is the string we passed is

00:06:40,050 --> 00:06:45,240
not quoted and doesn't reference the

00:06:42,300 --> 00:06:46,950
table this doesn't really matter here

00:06:45,240 --> 00:06:49,620
but it will once we start composing

00:06:46,950 --> 00:06:49,980
queries together we want a rail to

00:06:49,620 --> 00:06:52,890
handle

00:06:49,980 --> 00:06:56,850
all the naming and quoting let's look a

00:06:52,890 --> 00:06:59,910
little deeper what are these objects the

00:06:56,850 --> 00:07:03,890
table is an a rail table the columns are

00:06:59,910 --> 00:07:07,440
instances of a rail attributes attribute

00:07:03,890 --> 00:07:11,310
the whole query is an instance of a rail

00:07:07,440 --> 00:07:16,140
select manager it has an AST variable

00:07:11,310 --> 00:07:19,770
with many nested nodes ast stands for

00:07:16,140 --> 00:07:22,560
abstract syntax tree now abstract syntax

00:07:19,770 --> 00:07:24,540
tree is a computer science e term for a

00:07:22,560 --> 00:07:27,870
data structure that captures the meaning

00:07:24,540 --> 00:07:30,510
or intention of code this allows a rail

00:07:27,870 --> 00:07:34,710
to take our Ruby code and build sequel

00:07:30,510 --> 00:07:38,610
in the context of Postgres or MySQL or

00:07:34,710 --> 00:07:40,830
sequel Lite or any other database in

00:07:38,610 --> 00:07:43,410
other words we ask the system to get

00:07:40,830 --> 00:07:45,120
certain records from the database and a

00:07:43,410 --> 00:07:47,190
rail figured out what the sequel should

00:07:45,120 --> 00:07:50,250
look like to do it when we call to

00:07:47,190 --> 00:07:53,610
sequel on this object Abril uses the

00:07:50,250 --> 00:07:56,520
visitor pattern to turn the ast into

00:07:53,610 --> 00:07:59,760
sequel basically what that means is that

00:07:56,520 --> 00:08:02,460
an object called the visitor visits each

00:07:59,760 --> 00:08:04,890
node in the tree and decides what the

00:08:02,460 --> 00:08:07,320
output should be it collects all these

00:08:04,890 --> 00:08:08,970
little bits of sequel and builds the

00:08:07,320 --> 00:08:11,700
total query we need for the database

00:08:08,970 --> 00:08:12,900
this is a simplification of course but

00:08:11,700 --> 00:08:16,410
this is enough to get us started

00:08:12,900 --> 00:08:18,390
building our query objects let's build a

00:08:16,410 --> 00:08:21,780
simple query object here's our target

00:08:18,390 --> 00:08:24,960
sequel again similar to how we would

00:08:21,780 --> 00:08:27,420
refactor Ruby by extracting methods we

00:08:24,960 --> 00:08:30,330
want to take the inner queries wrap them

00:08:27,420 --> 00:08:33,090
in classes then build an object to take

00:08:30,330 --> 00:08:36,110
them and put them all together the first

00:08:33,090 --> 00:08:39,210
class will call the first donation query

00:08:36,110 --> 00:08:41,300
now first of all we have an execute

00:08:39,210 --> 00:08:44,060
method it does exactly what it says

00:08:41,300 --> 00:08:47,370
execute the sequel against the database

00:08:44,060 --> 00:08:50,100
by the way we delegate to sequel to the

00:08:47,370 --> 00:08:53,060
query method the real work happens in

00:08:50,100 --> 00:08:55,620
that query method like active record

00:08:53,060 --> 00:08:57,780
calling methods multiple times could

00:08:55,620 --> 00:09:00,480
build up duplicates of things so we

00:08:57,780 --> 00:09:01,170
memorize the results to ensure we only

00:09:00,480 --> 00:09:05,130
make

00:09:01,170 --> 00:09:07,769
pass through these steps donations is

00:09:05,130 --> 00:09:11,070
the Abril table from our donation model

00:09:07,769 --> 00:09:15,029
just like our first example then we call

00:09:11,070 --> 00:09:17,040
project to set up our select clause it

00:09:15,029 --> 00:09:19,290
wants an array and I like to define that

00:09:17,040 --> 00:09:22,170
and another method it's a little cleaner

00:09:19,290 --> 00:09:24,180
and you'll see later that sometimes we

00:09:22,170 --> 00:09:28,170
want to construct the columns based on

00:09:24,180 --> 00:09:31,730
some condition the really interesting

00:09:28,170 --> 00:09:34,740
stuff here is in the month trunk method

00:09:31,730 --> 00:09:37,290
to use a Postgres function that a role

00:09:34,740 --> 00:09:40,350
doesn't define itself we can build a

00:09:37,290 --> 00:09:41,910
named function node we just passed the

00:09:40,350 --> 00:09:44,070
name of the function as a regular string

00:09:41,910 --> 00:09:48,540
then wrap the arguments to the function

00:09:44,070 --> 00:09:52,470
in an array we use a rail nodes build

00:09:48,540 --> 00:09:55,160
quoted to make sure our string ends up

00:09:52,470 --> 00:09:57,779
correctly quoted in the sequel output a

00:09:55,160 --> 00:10:00,060
common pitfall is passing strings to a

00:09:57,779 --> 00:10:02,760
rail methods that expect another a rail

00:10:00,060 --> 00:10:06,959
node usually that means you need to wrap

00:10:02,760 --> 00:10:11,220
it in a row SQL or a rail nodes bill

00:10:06,959 --> 00:10:13,350
quoted this is what we do when we want

00:10:11,220 --> 00:10:17,010
to select just the integer one with a

00:10:13,350 --> 00:10:20,459
given name in order to build select one

00:10:17,010 --> 00:10:23,250
as gift 0 we need to cast the 1 as a

00:10:20,459 --> 00:10:25,699
string and then wrap it with a rail dot

00:10:23,250 --> 00:10:25,699
C equal

00:10:26,480 --> 00:10:32,010
finally other classes will reference the

00:10:29,100 --> 00:10:33,990
table and the gift date column if we

00:10:32,010 --> 00:10:35,700
want to change those names here it

00:10:33,990 --> 00:10:37,910
shouldn't break the queries down the

00:10:35,700 --> 00:10:37,910
line

00:10:39,330 --> 00:10:45,060
here's what our test for this class

00:10:41,730 --> 00:10:47,630
looks like first we just want to execute

00:10:45,060 --> 00:10:50,700
the to SQL method and make sure it works

00:10:47,630 --> 00:10:53,430
then we want to test the more complex

00:10:50,700 --> 00:10:56,820
things we're constructing finally we

00:10:53,430 --> 00:10:59,430
execute our query and Postgres even

00:10:56,820 --> 00:11:01,590
though the tests table is empty Postgres

00:10:59,430 --> 00:11:04,530
will still parse the query and raise an

00:11:01,590 --> 00:11:06,300
error if we have syntax problems now we

00:11:04,530 --> 00:11:08,550
can have some confidence that if

00:11:06,300 --> 00:11:11,190
something changes in a rel we'll know

00:11:08,550 --> 00:11:13,790
before we push it to production next

00:11:11,190 --> 00:11:16,800
we'll create the lateral donation query

00:11:13,790 --> 00:11:19,080
this is the part that will repeat and so

00:11:16,800 --> 00:11:22,050
it will be initialized with a couple of

00:11:19,080 --> 00:11:25,500
arguments it depends on the first

00:11:22,050 --> 00:11:27,000
donation query so we'll inject that you

00:11:25,500 --> 00:11:28,590
can imagine that if later we had a

00:11:27,000 --> 00:11:31,710
different initial query we could pass

00:11:28,590 --> 00:11:34,140
that instead of note in this class is

00:11:31,710 --> 00:11:37,350
that we change the naming of things

00:11:34,140 --> 00:11:40,170
based on the position variable and that

00:11:37,350 --> 00:11:42,300
we build this month off set the month

00:11:40,170 --> 00:11:45,240
off set uses the gift date from the

00:11:42,300 --> 00:11:48,420
first query and adds an interval of X

00:11:45,240 --> 00:11:52,170
months to it in order to construct the

00:11:48,420 --> 00:11:54,750
interval we use a unary operation which

00:11:52,170 --> 00:11:58,250
simply connects the strain interval with

00:11:54,750 --> 00:11:58,250
the month string that we pass

00:11:58,410 --> 00:12:04,290
this is what the test for this class

00:12:01,410 --> 00:12:07,380
looks like we can't execute this class

00:12:04,290 --> 00:12:09,900
as is but that part will be covered by

00:12:07,380 --> 00:12:11,730
the next query next we'll build our

00:12:09,900 --> 00:12:14,250
target sequel with what I'm just calling

00:12:11,730 --> 00:12:16,620
the timeline query this is where we

00:12:14,250 --> 00:12:18,600
reference the two queries we just built

00:12:16,620 --> 00:12:21,000
and dynamically build at all with as

00:12:18,600 --> 00:12:22,620
many lateral joins as we like the first

00:12:21,000 --> 00:12:25,440
thing to note here is that we're using a

00:12:22,620 --> 00:12:27,720
select manager instead of a table from

00:12:25,440 --> 00:12:29,880
an active record object there are

00:12:27,720 --> 00:12:32,090
several reasons but suffice it to say

00:12:29,880 --> 00:12:34,830
that a select manager has more abilities

00:12:32,090 --> 00:12:38,070
for example if we wanted to call with

00:12:34,830 --> 00:12:40,800
and build a CTE or set a named window

00:12:38,070 --> 00:12:43,230
that could be called elsewhere we'd use

00:12:40,800 --> 00:12:45,600
a select manager the next interesting

00:12:43,230 --> 00:12:48,000
part is that we reference the query from

00:12:45,600 --> 00:12:51,690
the first gift query as the from source

00:12:48,000 --> 00:12:54,750
a rail is smart enough to know that we

00:12:51,690 --> 00:12:57,480
mean to use it as a sub query then we

00:12:54,750 --> 00:13:00,120
call as on it to give it a name and pass

00:12:57,480 --> 00:13:03,139
it the name method of the first gift

00:13:00,120 --> 00:13:06,170
queries table

00:13:03,139 --> 00:13:07,790
again this allows us to change the name

00:13:06,170 --> 00:13:08,739
in that other class without breaking

00:13:07,790 --> 00:13:12,019
things here

00:13:08,739 --> 00:13:14,929
the next thing to note is the complex

00:13:12,019 --> 00:13:17,379
join that we're building we call join on

00:13:14,929 --> 00:13:20,779
the manager for each month that we want

00:13:17,379 --> 00:13:23,720
the lateral join segment takes our

00:13:20,779 --> 00:13:27,380
lateral donation query object and calls

00:13:23,720 --> 00:13:29,750
lateral on its query output

00:13:27,380 --> 00:13:32,150
you'll see why it's handy to have the

00:13:29,750 --> 00:13:35,060
lateral query and join segment methods

00:13:32,150 --> 00:13:36,890
separate in the next example this is

00:13:35,060 --> 00:13:39,140
what the tests of our time line query

00:13:36,890 --> 00:13:41,240
looks like we want to make sure that

00:13:39,140 --> 00:13:43,490
each of the lateral joins built without

00:13:41,240 --> 00:13:45,650
breaking and that the whole query is

00:13:43,490 --> 00:13:47,630
executable here's what it looks like to

00:13:45,650 --> 00:13:52,580
get the sequel output from our time line

00:13:47,630 --> 00:13:57,020
query here's what our query looks like

00:13:52,580 --> 00:13:58,100
when we execute it now that we have the

00:13:57,020 --> 00:14:01,070
time line query

00:13:58,100 --> 00:14:04,490
I'll just duplicate that file make a few

00:14:01,070 --> 00:14:06,470
changes to our setup and we have the

00:14:04,490 --> 00:14:09,920
cohort table query here's what that

00:14:06,470 --> 00:14:12,580
looks like in this query we build up the

00:14:09,920 --> 00:14:16,220
projection with a sum for each month

00:14:12,580 --> 00:14:18,140
also note that we set the wear group and

00:14:16,220 --> 00:14:20,180
order clauses out of order from our

00:14:18,140 --> 00:14:22,010
joins this totally just works with a row

00:14:20,180 --> 00:14:24,620
you can see that once we've built

00:14:22,010 --> 00:14:26,540
smaller reusable blocks we can quickly

00:14:24,620 --> 00:14:28,550
reuse them in lots of different ways

00:14:26,540 --> 00:14:31,160
also I'm sure you saw plenty of

00:14:28,550 --> 00:14:32,990
opportunities to dry up our code because

00:14:31,160 --> 00:14:35,630
this is all Ruby it lends itself to

00:14:32,990 --> 00:14:36,920
refactoring but let's move on now that

00:14:35,630 --> 00:14:38,630
we have our sequel built with query

00:14:36,920 --> 00:14:39,320
objects how do we integrate all this

00:14:38,630 --> 00:14:41,120
with rails

00:14:39,320 --> 00:14:43,700
what does executing our query objects

00:14:41,120 --> 00:14:46,760
look like this is what it looks like to

00:14:43,700 --> 00:14:51,860
execute our cohort table query clunk

00:14:46,760 --> 00:14:54,160
execute returns a result object and this

00:14:51,860 --> 00:14:58,250
acts a little bit like an array we can

00:14:54,160 --> 00:15:02,450
loop through it with each or we can just

00:14:58,250 --> 00:15:05,180
turn it into an array you can see here

00:15:02,450 --> 00:15:08,110
we have an array of hashes with the

00:15:05,180 --> 00:15:10,850
column name and the value for each row

00:15:08,110 --> 00:15:13,580
how can we use these to load active

00:15:10,850 --> 00:15:15,860
record objects in this variation I added

00:15:13,580 --> 00:15:19,670
a donor's method that uses fine by

00:15:15,860 --> 00:15:23,270
sequel to load donor objects for this to

00:15:19,670 --> 00:15:26,700
work I'm selecting star here and we're

00:15:23,270 --> 00:15:29,320
inner joining with the donor table

00:15:26,700 --> 00:15:35,320
if we run this in the console we can see

00:15:29,320 --> 00:15:38,590
that we get our donor model objects as a

00:15:35,320 --> 00:15:40,150
bonus active record has also loaded the

00:15:38,590 --> 00:15:44,200
extra columns from our sequel as

00:15:40,150 --> 00:15:45,430
attributes on each object this has been

00:15:44,200 --> 00:15:47,620
a really quick tour of how you can

00:15:45,430 --> 00:15:50,050
wrangle up your wild sequel strings and

00:15:47,620 --> 00:15:53,260
Corral them all with a rail and query

00:15:50,050 --> 00:15:55,030
objects usually at this point a speaker

00:15:53,260 --> 00:15:57,250
would point you to more resources where

00:15:55,030 --> 00:15:59,470
you can learn more there are a lot of

00:15:57,250 --> 00:16:02,680
blog posts out there but some of them

00:15:59,470 --> 00:16:06,430
are kind of dated Google is your friend

00:16:02,680 --> 00:16:09,670
of course I learned by looking at github

00:16:06,430 --> 00:16:13,180
PRS and just that other developers

00:16:09,670 --> 00:16:17,020
shared I think the source is kind of

00:16:13,180 --> 00:16:20,320
easy to understand if you get the ast

00:16:17,020 --> 00:16:22,170
and visitor pattern ideas I think you'll

00:16:20,320 --> 00:16:26,620
be able to get through it

00:16:22,170 --> 00:16:29,200
you'll find that a rel library in the

00:16:26,620 --> 00:16:30,580
active record gem of course if you have

00:16:29,200 --> 00:16:33,220
questions you should hit me up on

00:16:30,580 --> 00:16:34,090
Twitter I'm at aJE's and I'd love to

00:16:33,220 --> 00:16:37,080
help if I can

00:16:34,090 --> 00:16:37,080

YouTube URL: https://www.youtube.com/watch?v=8pQGzsDzYEo


