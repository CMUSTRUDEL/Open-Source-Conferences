Title: RailsConf 2020 CE - The Circle Of Lifecycle Events by Nelson Wittwer
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	The Circle Of Lifecycle Events by Nelson Wittwer

"To the new software developer wanting to build a web app with Rails, callbacks and associations are gifts from the gods. As your application grows in complexity however, you may notice your favorite tools have actually turned on you. New users suddenly aren't getting welcome emails and you've somehow orphaned associations. Come learn proven patterns for managing lifecycle events for associated records in a way that sparks joy."

__________

Nelson has spent most of his career working within Rails typically building new startups/products but has also maintained and iterated on platforms at scale supporting tens of millions of users. Nelson is a personable guy who loves to make people laugh.  Nelson currently lives in the Raleigh/Durham area and works for MX.com building banking/fintech products.
Captions: 
	00:00:09,270 --> 00:00:14,530
welcome everyone to the next session of

00:00:11,860 --> 00:00:16,840
rails conference remote edition 2020 I

00:00:14,530 --> 00:00:19,119
will be your host for this next talk

00:00:16,840 --> 00:00:20,890
about life cycle events the circle of

00:00:19,119 --> 00:00:24,910
life cycle events by nelson Bradley

00:00:20,890 --> 00:00:27,460
would were a little about myself Who am

00:00:24,910 --> 00:00:32,020
I I currently work at a company called

00:00:27,460 --> 00:00:36,309
MX Weser we write banking software api's

00:00:32,020 --> 00:00:38,290
web apps mobile apps for banks credit

00:00:36,309 --> 00:00:39,820
unions and fintechs so we serve the

00:00:38,290 --> 00:00:42,579
biggest names and in all of those

00:00:39,820 --> 00:00:44,739
categories have over 20 million users at

00:00:42,579 --> 00:00:48,910
the moment and growing like mad even

00:00:44,739 --> 00:00:50,590
with the the world as it is the way that

00:00:48,910 --> 00:00:52,600
it is today with the virus and all of

00:00:50,590 --> 00:00:54,850
that it's it's great to work in an

00:00:52,600 --> 00:00:57,630
environment of rails of scale and I'm

00:00:54,850 --> 00:01:00,100
really grateful for the opportunity to

00:00:57,630 --> 00:01:03,370
see how far out rails can leverage

00:01:00,100 --> 00:01:05,110
itself I hate all the memes that say the

00:01:03,370 --> 00:01:07,780
rails don't scale because I tell you

00:01:05,110 --> 00:01:09,789
they do that it does so I've also worked

00:01:07,780 --> 00:01:11,890
at rails in a lot of startups so I tried

00:01:09,789 --> 00:01:13,840
my hand at the startup lottery a couple

00:01:11,890 --> 00:01:17,340
times haven't have yet to really cash

00:01:13,840 --> 00:01:22,030
out him on that sucker yet but I believe

00:01:17,340 --> 00:01:25,180
so what is a life cycle event and in

00:01:22,030 --> 00:01:28,240
going back to the topic of our talk

00:01:25,180 --> 00:01:29,950
today right rather than I think just

00:01:28,240 --> 00:01:32,350
diving into a bunch of technical jargon

00:01:29,950 --> 00:01:34,210
I'm a really visual learner so you're

00:01:32,350 --> 00:01:38,500
gonna use me see me use a lot of visual

00:01:34,210 --> 00:01:40,990
aids memes and the like as I as I feel

00:01:38,500 --> 00:01:43,869
that it's a great way to take something

00:01:40,990 --> 00:01:47,400
that's familiar to to explain a concept

00:01:43,869 --> 00:01:47,400
complex subject

00:01:50,670 --> 00:01:55,099
[Music]

00:01:58,740 --> 00:02:03,180
[Music]

00:02:01,100 --> 00:02:04,140
so if you weren't able to pick up the

00:02:03,180 --> 00:02:06,420
clues from that video

00:02:04,140 --> 00:02:08,280
let me explain so when something happens

00:02:06,420 --> 00:02:11,400
in your platform a new user is created

00:02:08,280 --> 00:02:13,230
Simba is born there is likely a chain of

00:02:11,400 --> 00:02:14,790
events that you want to write sit within

00:02:13,230 --> 00:02:16,830
your application for something to happen

00:02:14,790 --> 00:02:19,050
okay so these things could happen on a

00:02:16,830 --> 00:02:21,180
user create on an updated to destroy

00:02:19,050 --> 00:02:23,460
there's likely some things that you'll

00:02:21,180 --> 00:02:25,500
you were writing your software based off

00:02:23,460 --> 00:02:27,660
of those events and these life cycle

00:02:25,500 --> 00:02:29,700
events are a super powerful and

00:02:27,660 --> 00:02:32,280
important thing to get right and it's

00:02:29,700 --> 00:02:33,510
also one of the easiest things to shoot

00:02:32,280 --> 00:02:35,670
yourself in the foot within my

00:02:33,510 --> 00:02:38,460
experience so I thought I would share

00:02:35,670 --> 00:02:40,200
some of my experiences both on a scale

00:02:38,460 --> 00:02:41,430
on the millions and scale of the I'm

00:02:40,200 --> 00:02:42,540
trying to get my start up off the ground

00:02:41,430 --> 00:02:46,410
how does this work

00:02:42,540 --> 00:02:49,350
a type of contexts speaking of startups

00:02:46,410 --> 00:02:52,020
so who rails has this brand of being

00:02:49,350 --> 00:02:54,840
like the go-to framework in startups

00:02:52,020 --> 00:02:56,940
even today years and years after its

00:02:54,840 --> 00:02:59,820
initial launch and there's a couple of

00:02:56,940 --> 00:03:02,459
reasons why startups in particular

00:02:59,820 --> 00:03:05,580
gravitate towards rails it's very easy

00:03:02,459 --> 00:03:07,800
to prototype on something you can open

00:03:05,580 --> 00:03:11,100
run rails new and run a couple scaffolds

00:03:07,800 --> 00:03:13,860
and have a very basic up and

00:03:11,100 --> 00:03:15,750
running very quickly but there in

00:03:13,860 --> 00:03:18,450
specific there's two things that I think

00:03:15,750 --> 00:03:21,000
that really help the backend layer of

00:03:18,450 --> 00:03:22,620
rails marry super well with a brand new

00:03:21,000 --> 00:03:26,190
product that you're trying to prototype

00:03:22,620 --> 00:03:28,550
a release or iterate on and it's it's

00:03:26,190 --> 00:03:31,560
what makes it very fast to develop with

00:03:28,550 --> 00:03:35,190
and that's the way that rails sits on

00:03:31,560 --> 00:03:37,080
top of postgrads any sort of relational

00:03:35,190 --> 00:03:39,959
database today the active record can tie

00:03:37,080 --> 00:03:43,650
into the way that it super simply

00:03:39,959 --> 00:03:46,410
handles model associations so a blog

00:03:43,650 --> 00:03:49,470
post can have many comments right or an

00:03:46,410 --> 00:03:52,440
author can write a blog post and so you

00:03:49,470 --> 00:03:54,989
can have these these relational models

00:03:52,440 --> 00:03:57,660
that are super easy to work with tie

00:03:54,989 --> 00:04:01,440
together and draw associations with and

00:03:57,660 --> 00:04:04,890
build a beautiful view on top of which I

00:04:01,440 --> 00:04:08,010
super love and then tied within here as

00:04:04,890 --> 00:04:10,709
you start to expand on the behavior of

00:04:08,010 --> 00:04:11,460
your applications writing callbacks that

00:04:10,709 --> 00:04:13,590
that

00:04:11,460 --> 00:04:15,990
trigger during a lifecycle event of any

00:04:13,590 --> 00:04:18,540
of those models is a super powerful way

00:04:15,990 --> 00:04:22,680
to build build an app and in fact that's

00:04:18,540 --> 00:04:27,780
what back in my in my startup life those

00:04:22,680 --> 00:04:31,410
two tools and a super simple UI did most

00:04:27,780 --> 00:04:33,300
of the heavy lift lifting so I thought I

00:04:31,410 --> 00:04:35,190
would rather than dealing it with in the

00:04:33,300 --> 00:04:37,980
abstract diving into the content of this

00:04:35,190 --> 00:04:40,590
talk my favorite my favorite tech talks

00:04:37,980 --> 00:04:42,060
are the ones that have a shared domain a

00:04:40,590 --> 00:04:44,970
shared problem that we're trying to

00:04:42,060 --> 00:04:47,100
solve so since I have talked about my

00:04:44,970 --> 00:04:51,180
startup experience before I thought I

00:04:47,100 --> 00:04:53,640
would you know pitch you my idea here so

00:04:51,180 --> 00:04:55,470
let me pitch you my next startup it's

00:04:53,640 --> 00:04:57,470
gonna be huge and I think you're gonna

00:04:55,470 --> 00:05:02,000
love it

00:04:57,470 --> 00:05:04,950
I'm gonna call it the blockchain credit

00:05:02,000 --> 00:05:08,730
or did you credit score's on the

00:05:04,950 --> 00:05:10,620
blockchain because why not it's 2020 we

00:05:08,730 --> 00:05:12,330
should absolutely have credit reporting

00:05:10,620 --> 00:05:16,680
with on a blockchain that is peer

00:05:12,330 --> 00:05:18,360
verified so and if that wasn't enough

00:05:16,680 --> 00:05:20,430
for you we're also gonna do machine

00:05:18,360 --> 00:05:22,470
learning and there's gonna be a hell of

00:05:20,430 --> 00:05:24,180
a lot of AI in this thing so we're good

00:05:22,470 --> 00:05:25,470
it's it's a unicorn already you've gotta

00:05:24,180 --> 00:05:27,480
so you got to get on the ground level

00:05:25,470 --> 00:05:28,890
while you still can right but you know

00:05:27,480 --> 00:05:30,600
what there's one more thing I can do to

00:05:28,890 --> 00:05:32,010
simplify this pitch you know what you

00:05:30,600 --> 00:05:33,720
know what yeah just just drop to the

00:05:32,010 --> 00:05:39,960
blockchain credit I think it's a lot

00:05:33,720 --> 00:05:41,760
cleaner okay so it's here's how I'm

00:05:39,960 --> 00:05:43,080
gonna pitch the technical side of use of

00:05:41,760 --> 00:05:45,090
this to you so there's a couple of

00:05:43,080 --> 00:05:47,370
things that we want to have happen when

00:05:45,090 --> 00:05:49,170
users sign up for our platform so number

00:05:47,370 --> 00:05:50,880
one we would need to create a credit

00:05:49,170 --> 00:05:51,960
score for this user because what's the

00:05:50,880 --> 00:05:53,310
point of having you having the

00:05:51,960 --> 00:05:56,310
blockchain if there's nothing to score

00:05:53,310 --> 00:05:58,230
the test or honor right we want to

00:05:56,310 --> 00:06:01,020
create an alert profile so something to

00:05:58,230 --> 00:06:03,090
track hey do I prefer alerts on my email

00:06:01,020 --> 00:06:06,300
for my credit report do I want to in

00:06:03,090 --> 00:06:08,880
text message a tweet I take talk or

00:06:06,300 --> 00:06:10,680
whatever right and then we want to send

00:06:08,880 --> 00:06:13,830
a welcome email welcome to the beautiful

00:06:10,680 --> 00:06:16,380
land of blockchain credit very

00:06:13,830 --> 00:06:17,940
reasonable expectations right so let's

00:06:16,380 --> 00:06:20,580
take a look at how this flow might work

00:06:17,940 --> 00:06:22,890
so let's say we have an administrator in

00:06:20,580 --> 00:06:24,430
our in our platform in rails and they

00:06:22,890 --> 00:06:26,229
want to create a new user

00:06:24,430 --> 00:06:29,050
okay that's pretty simple we can create

00:06:26,229 --> 00:06:30,940
one user but created a profile created

00:06:29,050 --> 00:06:33,460
create a credit score and then we're

00:06:30,940 --> 00:06:34,900
gonna return that back and and we're

00:06:33,460 --> 00:06:37,900
also in a set of this welcome email like

00:06:34,900 --> 00:06:40,720
right like that flow very reasonable for

00:06:37,900 --> 00:06:44,440
a web application so if I were to spin

00:06:40,720 --> 00:06:47,500
up a rail scaffold that part's pretty

00:06:44,440 --> 00:06:50,050
simple but what about all these steps

00:06:47,500 --> 00:06:51,610
right here what were those go where is

00:06:50,050 --> 00:06:54,370
the chapter on the rails tutorial about

00:06:51,610 --> 00:06:59,160
that right and that's where we introduce

00:06:54,370 --> 00:06:59,160
our first actor activesupport callbacks

00:07:21,780 --> 00:07:30,730
looks like a Christmas tree this is how

00:07:27,970 --> 00:07:32,980
I felt about it like I said you take you

00:07:30,730 --> 00:07:34,450
take models and you give me a Z way to

00:07:32,980 --> 00:07:36,400
tie into all those lifecycle events

00:07:34,450 --> 00:07:39,880
that's that's all I need to need to

00:07:36,400 --> 00:07:42,430
flush up my ideas and in our a little

00:07:39,880 --> 00:07:45,490
startup in our in a rails app here it's

00:07:42,430 --> 00:07:48,250
gonna be no different so are not my

00:07:45,490 --> 00:07:50,020
naive implementation in my early startup

00:07:48,250 --> 00:07:54,190
days might look something like this I

00:07:50,020 --> 00:07:55,900
have a user it's going to have a couple

00:07:54,190 --> 00:07:57,940
of things that take place after we

00:07:55,900 --> 00:07:59,230
create so after I'm created user we're

00:07:57,940 --> 00:08:00,640
going to create our alert profile we're

00:07:59,230 --> 00:08:03,610
gonna send a welcome email and our

00:08:00,640 --> 00:08:04,150
credit score and we are done right easy

00:08:03,610 --> 00:08:06,910
peasy

00:08:04,150 --> 00:08:09,850
so if this is your first stop in rails

00:08:06,910 --> 00:08:12,010
callbacks and lifecycle events I thought

00:08:09,850 --> 00:08:13,870
I would take a quick second to dive a

00:08:12,010 --> 00:08:16,450
little bit into the documentation here

00:08:13,870 --> 00:08:19,200
to explain where and when to use these

00:08:16,450 --> 00:08:23,800
to make sure I'm not losing anybody so

00:08:19,200 --> 00:08:25,660
the these first two steps here with

00:08:23,800 --> 00:08:28,960
these little hyphens these are the

00:08:25,660 --> 00:08:32,110
functions that get the our methods that

00:08:28,960 --> 00:08:34,240
are called that trigger the callbacks

00:08:32,110 --> 00:08:37,360
that fall underneath them right so if we

00:08:34,240 --> 00:08:39,910
are to say user dot save then one two

00:08:37,360 --> 00:08:41,800
what these callbacks one through seven

00:08:39,910 --> 00:08:44,590
would follow in the order that you see

00:08:41,800 --> 00:08:47,440
here if I were to see check to see if a

00:08:44,590 --> 00:08:50,710
model is valid so if I say a user not

00:08:47,440 --> 00:08:53,340
valid then the next step would follow so

00:08:50,710 --> 00:08:56,190
let's take an example so if we were

00:08:53,340 --> 00:09:00,670
trying to do some debugging here and we

00:08:56,190 --> 00:09:02,860
were having a hard time validating our

00:09:00,670 --> 00:09:04,510
users and we're using slack for some

00:09:02,860 --> 00:09:08,560
reason instead of like a test or a

00:09:04,510 --> 00:09:10,960
console there's an example I don't use

00:09:08,560 --> 00:09:12,700
this one a super ton but it's there if

00:09:10,960 --> 00:09:16,180
you need to plug in before you do any

00:09:12,700 --> 00:09:18,610
validation checking so after you

00:09:16,180 --> 00:09:20,560
validate something or the at this point

00:09:18,610 --> 00:09:23,680
this is where we're actually validate it

00:09:20,560 --> 00:09:25,580
so we're gonna we're going to let's say

00:09:23,680 --> 00:09:27,680
we have a email validation on

00:09:25,580 --> 00:09:29,600
here that we require a user to have an

00:09:27,680 --> 00:09:30,110
email address before we can save their

00:09:29,600 --> 00:09:32,870
record

00:09:30,110 --> 00:09:35,800
so after validation maybe want to log it

00:09:32,870 --> 00:09:40,790
and say yes this this user did have a

00:09:35,800 --> 00:09:43,810
valid email address then we have before

00:09:40,790 --> 00:09:46,370
save and before create so these are

00:09:43,810 --> 00:09:48,260
these are used a lot more frequently in

00:09:46,370 --> 00:09:49,430
my experience so after the validations

00:09:48,260 --> 00:09:51,920
have taken place

00:09:49,430 --> 00:09:53,600
and before we save or before before we

00:09:51,920 --> 00:09:55,490
save could be like from an update before

00:09:53,600 --> 00:09:58,010
created specifically for creating a new

00:09:55,490 --> 00:10:01,130
record what are some things I'm going to

00:09:58,010 --> 00:10:04,940
have so before create again more more

00:10:01,130 --> 00:10:07,700
logging here but a more practical

00:10:04,940 --> 00:10:09,560
example is this set modified by let's

00:10:07,700 --> 00:10:11,600
say let's say we were wanting to do some

00:10:09,560 --> 00:10:14,180
author write some auditing in here to

00:10:11,600 --> 00:10:18,080
make sure that we record whoever created

00:10:14,180 --> 00:10:21,110
a user maybe it's to give a sales person

00:10:18,080 --> 00:10:23,540
Commission or something like that like

00:10:21,110 --> 00:10:25,910
these these life cycle events are super

00:10:23,540 --> 00:10:28,820
important because people's livelihoods

00:10:25,910 --> 00:10:31,490
could be on the line and this is an

00:10:28,820 --> 00:10:34,730
example of that right so we're gonna say

00:10:31,490 --> 00:10:36,890
that I modified this user so I'm gonna

00:10:34,730 --> 00:10:38,510
have this set modified by a callback

00:10:36,890 --> 00:10:42,050
that we can attach before we save a

00:10:38,510 --> 00:10:44,660
record so then we get to everything that

00:10:42,050 --> 00:10:48,550
happens after we create something so

00:10:44,660 --> 00:10:50,930
these are a lot more practical as well

00:10:48,550 --> 00:10:53,000
because maybe after we create something

00:10:50,930 --> 00:10:55,310
we that's when we blast our sales

00:10:53,000 --> 00:10:58,610
channel that we have a new sale or a new

00:10:55,310 --> 00:11:01,480
signup and slack write again these are a

00:10:58,610 --> 00:11:05,180
little bit more abstract but the idea is

00:11:01,480 --> 00:11:07,970
you can write whatever custom logic you

00:11:05,180 --> 00:11:13,000
want in these various stages of the

00:11:07,970 --> 00:11:16,100
lifecycle so of creating of of updating

00:11:13,000 --> 00:11:17,600
so the pros of callbacks super easy to

00:11:16,100 --> 00:11:20,540
use they pair really well with

00:11:17,600 --> 00:11:23,690
validations and they're very easy to

00:11:20,540 --> 00:11:25,340
test in an isolated manner and as a

00:11:23,690 --> 00:11:28,400
bonus they run in every database

00:11:25,340 --> 00:11:30,620
operation within active record so no

00:11:28,400 --> 00:11:31,940
matter how you are saving or saving

00:11:30,620 --> 00:11:35,750
something let's say you're in a rails

00:11:31,940 --> 00:11:38,400
console or you've built in a view in

00:11:35,750 --> 00:11:41,310
your synapse controller or maybe

00:11:38,400 --> 00:11:45,270
different the controller that does like

00:11:41,310 --> 00:11:47,010
both processing all of those no matter

00:11:45,270 --> 00:11:48,900
which way you're creating a user they're

00:11:47,010 --> 00:11:51,950
all going to fire the callbacks which is

00:11:48,900 --> 00:11:56,100
super helpful kind of a callbacks is

00:11:51,950 --> 00:11:57,780
they run every time so it's kind of a

00:11:56,100 --> 00:11:59,820
double-edged sword like it is a pro but

00:11:57,780 --> 00:12:01,920
maybe sometimes you don't want to run

00:11:59,820 --> 00:12:05,040
all of that complex logic maybe you want

00:12:01,920 --> 00:12:06,750
to bypass it because we're trying to do

00:12:05,040 --> 00:12:08,670
a bulk import for instance we don't want

00:12:06,750 --> 00:12:10,140
to send them all a welcome email or

00:12:08,670 --> 00:12:12,060
maybe their welcome email needs to have

00:12:10,140 --> 00:12:14,670
specific instructions or something like

00:12:12,060 --> 00:12:16,890
that right so tying those into the

00:12:14,670 --> 00:12:19,200
database itself is tricky because

00:12:16,890 --> 00:12:21,120
they're gonna run every time they have a

00:12:19,200 --> 00:12:23,850
potential for erase conditions and this

00:12:21,120 --> 00:12:26,010
is where I've I've been bitten a lot as

00:12:23,850 --> 00:12:27,650
I relied too many times especially when

00:12:26,010 --> 00:12:30,810
they give you that level of granularity

00:12:27,650 --> 00:12:32,430
it's very easy to write logic that's out

00:12:30,810 --> 00:12:34,290
that gets out of order maybe some

00:12:32,430 --> 00:12:36,090
developer doesn't realize the intricate

00:12:34,290 --> 00:12:38,760
order of all of the logic that needs to

00:12:36,090 --> 00:12:43,160
take place during during your callbacks

00:12:38,760 --> 00:12:45,480
and so you can have a race condition so

00:12:43,160 --> 00:12:47,780
and again complex conditional logic

00:12:45,480 --> 00:12:50,850
you're not going to know like if you're

00:12:47,780 --> 00:12:52,920
depending on some sort of one callback

00:12:50,850 --> 00:12:54,810
running before the other or one

00:12:52,920 --> 00:12:59,250
Association being in place but it's not

00:12:54,810 --> 00:13:01,620
yet it can get very complex and here's a

00:12:59,250 --> 00:13:02,790
terrible joke about race conditions and

00:13:01,620 --> 00:13:05,970
if you're not familiar with a race

00:13:02,790 --> 00:13:07,860
condition the idea is is you might be

00:13:05,970 --> 00:13:09,750
expecting it to be in one place but it

00:13:07,860 --> 00:13:12,450
happens somewhere else or it happens

00:13:09,750 --> 00:13:14,880
later than you thought right and that

00:13:12,450 --> 00:13:16,950
happens all the time with very with

00:13:14,880 --> 00:13:18,390
poorly written callbacks and that's the

00:13:16,950 --> 00:13:21,780
crux that what I want to talk about

00:13:18,390 --> 00:13:23,040
today is is to how to write these life

00:13:21,780 --> 00:13:25,170
cycle events that are going to happen

00:13:23,040 --> 00:13:27,450
that rails gives you beautiful tools to

00:13:25,170 --> 00:13:29,850
tie into in a way that's going to treat

00:13:27,450 --> 00:13:32,010
your that that's going to be easy to

00:13:29,850 --> 00:13:35,690
maintain and maintain your happiness so

00:13:32,010 --> 00:13:38,670
for time as well so our example here

00:13:35,690 --> 00:13:41,640
let's start with our pro tip of the day

00:13:38,670 --> 00:13:44,000
because my example is a very terrible

00:13:41,640 --> 00:13:47,700
example and my pro tip for you is

00:13:44,000 --> 00:13:51,459
callbacks should only modify the model

00:13:47,700 --> 00:13:53,529
that they are defined on so

00:13:51,459 --> 00:13:55,179
we had these associated models right we

00:13:53,529 --> 00:13:58,179
had a user we had a credit score we had

00:13:55,179 --> 00:14:01,360
an alert profile I want you to take away

00:13:58,179 --> 00:14:03,309
from this talk this point callback

00:14:01,360 --> 00:14:05,290
should only modify the model that they

00:14:03,309 --> 00:14:08,410
are defined on so a user should only

00:14:05,290 --> 00:14:11,350
modify a user you shouldn't actually be

00:14:08,410 --> 00:14:14,230
creating an Associated record in a

00:14:11,350 --> 00:14:16,029
callback because for the reasons that

00:14:14,230 --> 00:14:17,619
I've just talked about with my cons this

00:14:16,029 --> 00:14:21,519
is going to lead you down a rabbit hole

00:14:17,619 --> 00:14:22,990
of debugging in the future just you wait

00:14:21,519 --> 00:14:25,329
I know it's easy and you can write it

00:14:22,990 --> 00:14:27,550
and know the code will work but as you

00:14:25,329 --> 00:14:28,839
expand upon your software this is

00:14:27,550 --> 00:14:32,649
getting to be your biggest point of

00:14:28,839 --> 00:14:35,290
friction so let me kind of explain this

00:14:32,649 --> 00:14:36,790
visually here right so active record

00:14:35,290 --> 00:14:38,259
this beautiful interface that we have

00:14:36,790 --> 00:14:40,329
that sits on top of a relational

00:14:38,259 --> 00:14:42,339
database this is how our database is

00:14:40,329 --> 00:14:44,439
gonna be your data and very separately

00:14:42,339 --> 00:14:45,939
defined tables it's not but it's not

00:14:44,439 --> 00:14:48,129
going to know about all the war crimes

00:14:45,939 --> 00:14:50,170
that our application that's committed

00:14:48,129 --> 00:14:51,910
because this is how our application is

00:14:50,170 --> 00:14:53,559
going to look if we implement our

00:14:51,910 --> 00:14:56,769
software the way that I showed you

00:14:53,559 --> 00:14:59,470
within our call backs they're kind of

00:14:56,769 --> 00:15:02,350
like grow come together in this giant

00:14:59,470 --> 00:15:03,999
mass of a snowball that's you know why

00:15:02,350 --> 00:15:05,279
do we even have separate files for all

00:15:03,999 --> 00:15:07,149
of these because if they're so

00:15:05,279 --> 00:15:10,119
interconnected and related to each other

00:15:07,149 --> 00:15:12,939
there's no separation of concerns or

00:15:10,119 --> 00:15:15,189
responsibilities this is a common theme

00:15:12,939 --> 00:15:17,110
with an experienced software as people

00:15:15,189 --> 00:15:19,540
software developers those who have read

00:15:17,110 --> 00:15:22,660
a lot of books on refactoring and

00:15:19,540 --> 00:15:25,029
software design every model should have

00:15:22,660 --> 00:15:30,100
should be responsible for itself and not

00:15:25,029 --> 00:15:32,589
for its associations and callbacks is a

00:15:30,100 --> 00:15:33,970
great way that we can accidentally blur

00:15:32,589 --> 00:15:36,779
those lines and bring everything

00:15:33,970 --> 00:15:39,009
together where there's not a single

00:15:36,779 --> 00:15:45,089
principle of responsibility that each of

00:15:39,009 --> 00:15:48,249
these models has so why no multi model

00:15:45,089 --> 00:15:49,839
modification callback system so like I

00:15:48,249 --> 00:15:51,220
said model responsibilities are not

00:15:49,839 --> 00:15:54,970
respected everything is all kind of

00:15:51,220 --> 00:15:56,769
mushed together and this kind of comes

00:15:54,970 --> 00:15:58,240
back to the hypothetical before what if

00:15:56,769 --> 00:16:00,759
what if we want to create a user that

00:15:58,240 --> 00:16:01,830
doesn't get a welcome email maybe it's

00:16:00,759 --> 00:16:04,440
like a white labeled

00:16:01,830 --> 00:16:06,830
than what they don't want to have the

00:16:04,440 --> 00:16:09,240
same email that goes out to them right

00:16:06,830 --> 00:16:11,040
what if the credit score creation

00:16:09,240 --> 00:16:14,130
process needs to vary from one user to

00:16:11,040 --> 00:16:16,830
another so if you're doing all if you're

00:16:14,130 --> 00:16:19,290
doing a giant if statement for for that

00:16:16,830 --> 00:16:21,060
condition all tied within a complex

00:16:19,290 --> 00:16:24,060
callback with different models it's

00:16:21,060 --> 00:16:25,740
gonna get super hairy super fast I and

00:16:24,060 --> 00:16:27,600
what if we want to change the behavior

00:16:25,740 --> 00:16:32,130
that happens when a new user signs up

00:16:27,600 --> 00:16:33,900
but we want to maintain what what the

00:16:32,130 --> 00:16:35,100
older users had or maybe you have a new

00:16:33,900 --> 00:16:36,720
product that we're spinning app we

00:16:35,100 --> 00:16:39,000
haven't won a new API the versions that

00:16:36,720 --> 00:16:40,800
if you're doing that the call back later

00:16:39,000 --> 00:16:42,360
and the models it's gonna be super

00:16:40,800 --> 00:16:45,600
gnarly for you to be able to tackle that

00:16:42,360 --> 00:16:48,360
I haven't at this point home enough for

00:16:45,600 --> 00:16:50,280
you yet let me do the only there I only

00:16:48,360 --> 00:16:52,770
have one more trick up my sleeve as a

00:16:50,280 --> 00:16:54,900
millennial to really make you consider

00:16:52,770 --> 00:16:58,200
the impact here and that is to give you

00:16:54,900 --> 00:17:01,110
an Instagram beautiful picture with

00:16:58,200 --> 00:17:05,160
cursive with this quote because that's

00:17:01,110 --> 00:17:06,870
what we do damn callback should only

00:17:05,160 --> 00:17:10,230
modify the model that they are defined

00:17:06,870 --> 00:17:12,330
on okay so our example here of creating

00:17:10,230 --> 00:17:15,870
an alert profile welcome email and a

00:17:12,330 --> 00:17:18,630
credit score this breaks our test no

00:17:15,870 --> 00:17:21,030
soup for you this is bad because we're

00:17:18,630 --> 00:17:23,810
modifying associated models than the

00:17:21,030 --> 00:17:28,020
user callbacks for a user should only

00:17:23,810 --> 00:17:29,070
modify the user so common question that

00:17:28,020 --> 00:17:31,380
I get when I'm explaining this concept

00:17:29,070 --> 00:17:33,480
is that does that mean I can't use

00:17:31,380 --> 00:17:35,190
associations and callbacks then cuz I

00:17:33,480 --> 00:17:37,290
love them that you were saying else and

00:17:35,190 --> 00:17:40,590
that's what makes real so so productive

00:17:37,290 --> 00:17:43,980
as a an iteration platform the answer is

00:17:40,590 --> 00:17:47,520
yes you you can use associations as long

00:17:43,980 --> 00:17:49,560
as they are read-only so in this case if

00:17:47,520 --> 00:17:52,800
we're gonna update the status of our

00:17:49,560 --> 00:17:56,580
user after we've saved or after we've

00:17:52,800 --> 00:17:59,280
committed to the database a change we

00:17:56,580 --> 00:18:01,830
can do that in a read-only fashion so in

00:17:59,280 --> 00:18:04,230
this case we're accessing the associated

00:18:01,830 --> 00:18:06,350
credit score of this user but we're just

00:18:04,230 --> 00:18:11,010
checking to see if their credit is good

00:18:06,350 --> 00:18:12,480
because we can English apparently so

00:18:11,010 --> 00:18:14,220
we're not modifying the credit score

00:18:12,480 --> 00:18:14,890
we're not deleting her credit score but

00:18:14,220 --> 00:18:17,620
we're just check

00:18:14,890 --> 00:18:20,080
King on a tray so that's a that's

00:18:17,620 --> 00:18:20,800
alright I'll ride alright because we're

00:18:20,080 --> 00:18:23,080
just reading

00:18:20,800 --> 00:18:25,330
we're not modifying that credit score so

00:18:23,080 --> 00:18:28,420
a couple more examples so let's say we

00:18:25,330 --> 00:18:30,730
have a transaction with paid off a loan

00:18:28,420 --> 00:18:32,980
we've created a new loan we've accrued

00:18:30,730 --> 00:18:35,320
interest etc because it's a credit it's

00:18:32,980 --> 00:18:38,050
a credit application so after a

00:18:35,320 --> 00:18:39,640
transaction happens this is a very

00:18:38,050 --> 00:18:41,440
common pattern we need to update a

00:18:39,640 --> 00:18:45,190
user's credit score this is this is a

00:18:41,440 --> 00:18:47,350
very naive implementation and this reads

00:18:45,190 --> 00:18:49,030
super well like I could open up this

00:18:47,350 --> 00:18:51,820
this this code and be able to know

00:18:49,030 --> 00:18:54,190
exactly where to look but let me show

00:18:51,820 --> 00:18:59,740
you how terrible things can get if we

00:18:54,190 --> 00:19:00,910
crack open this callback yeah okay so at

00:18:59,740 --> 00:19:02,890
least it's readable because these

00:19:00,910 --> 00:19:06,760
variable these function and these method

00:19:02,890 --> 00:19:10,780
names are very english' bulette stake a

00:19:06,760 --> 00:19:12,940
look from a deep in where our debugging

00:19:10,780 --> 00:19:15,250
hat and try to see into the future where

00:19:12,940 --> 00:19:19,240
things could break so after a

00:19:15,250 --> 00:19:19,660
transaction we want to holy cow look at

00:19:19,240 --> 00:19:23,410
this

00:19:19,660 --> 00:19:26,380
we need to obvious some way of checking

00:19:23,410 --> 00:19:28,120
the debt of this transaction so that's

00:19:26,380 --> 00:19:30,040
another associated model that we're

00:19:28,120 --> 00:19:31,630
gonna have to take account of and then

00:19:30,040 --> 00:19:34,420
we're gonna have to see if it was paid

00:19:31,630 --> 00:19:35,890
on time and then we're then based off of

00:19:34,420 --> 00:19:38,380
that we either increased the credit

00:19:35,890 --> 00:19:41,020
score or decrease the credit score again

00:19:38,380 --> 00:19:42,730
this business logic is all sound and if

00:19:41,020 --> 00:19:45,180
it were just these crimes I think we

00:19:42,730 --> 00:19:48,910
could probably squeeze bye for now and

00:19:45,180 --> 00:19:50,620
assume this technical debt but now we're

00:19:48,910 --> 00:19:54,310
gonna do another track of their credit

00:19:50,620 --> 00:19:55,300
ratio again another associated model

00:19:54,310 --> 00:19:58,840
that we're going to have to take alert

00:19:55,300 --> 00:20:00,610
or at least a we'll have to look at

00:19:58,840 --> 00:20:02,350
their credit their credit score and then

00:20:00,610 --> 00:20:05,290
view all their transactions to view

00:20:02,350 --> 00:20:07,860
their ratio and all this is going to

00:20:05,290 --> 00:20:11,080
take place during every transaction

00:20:07,860 --> 00:20:12,970
again we could probably sneak by but now

00:20:11,080 --> 00:20:15,250
we've got some conditional returns in

00:20:12,970 --> 00:20:16,840
here oh because yeah test users happen

00:20:15,250 --> 00:20:19,210
all the time demo users we're going to

00:20:16,840 --> 00:20:21,070
we've got to be able to pitch to get to

00:20:19,210 --> 00:20:22,820
get our next deal all right oh and then

00:20:21,070 --> 00:20:24,500
apparently

00:20:22,820 --> 00:20:26,090
I mean it wouldn't be a FinTech product

00:20:24,500 --> 00:20:29,659
without you know some good old-fashioned

00:20:26,090 --> 00:20:32,840
American nepotism that would totally

00:20:29,659 --> 00:20:36,700
happen oh holy cow now we're reporting

00:20:32,840 --> 00:20:39,590
to external services credit services

00:20:36,700 --> 00:20:41,570
Experian credit bureaus that makes sense

00:20:39,590 --> 00:20:43,340
oh and some Darkman pirates so that all

00:20:41,570 --> 00:20:45,409
assumes that all of these actors are

00:20:43,340 --> 00:20:47,539
online and accepting transaction updates

00:20:45,409 --> 00:20:49,100
and then lastly at the end here we're

00:20:47,539 --> 00:20:51,500
gonna check to see if our users got an

00:20:49,100 --> 00:20:54,129
alert profile and if it does then we're

00:20:51,500 --> 00:20:58,220
going to send them a transaction alert

00:20:54,129 --> 00:21:00,049
holy cow so there's a lot of things that

00:20:58,220 --> 00:21:01,700
can go wrong within this callback what

00:21:00,049 --> 00:21:04,730
happens to your transaction if none of

00:21:01,700 --> 00:21:08,350
those services are up how do ID bug and

00:21:04,730 --> 00:21:12,080
the weird example of it's my nephew's

00:21:08,350 --> 00:21:14,299
debt ratio that's too high should they

00:21:12,080 --> 00:21:15,799
actually get an email or not like should

00:21:14,299 --> 00:21:17,419
all of this happen at every transaction

00:21:15,799 --> 00:21:21,830
that I just open up with an arraylist

00:21:17,419 --> 00:21:24,440
console I'm exhausted by this so the

00:21:21,830 --> 00:21:27,710
only serene option here is you should

00:21:24,440 --> 00:21:31,519
only modify the model that is defined on

00:21:27,710 --> 00:21:35,480
that callback right so please please

00:21:31,519 --> 00:21:38,870
please do not it's I know you can write

00:21:35,480 --> 00:21:41,929
it and it will actually the software

00:21:38,870 --> 00:21:43,519
will work but over time you're setting

00:21:41,929 --> 00:21:45,169
yourself up for failure with that giant

00:21:43,519 --> 00:21:46,850
transaction example because that's what

00:21:45,169 --> 00:21:49,340
will happen over time with a software

00:21:46,850 --> 00:21:50,480
with software that is getting used this

00:21:49,340 --> 00:21:52,700
is a bug taking that it was just

00:21:50,480 --> 00:21:54,440
assigned to me and you know this is

00:21:52,700 --> 00:21:57,019
going to be a great bug because it has

00:21:54,440 --> 00:22:00,830
this terrible word that starts the

00:21:57,019 --> 00:22:04,700
ticket off of sometimes sometimes new

00:22:00,830 --> 00:22:07,009
users are getting welcome emails so that

00:22:04,700 --> 00:22:08,870
sucks or in this ticket we haven't been

00:22:07,009 --> 00:22:11,659
given instructions to how to recreate it

00:22:08,870 --> 00:22:13,190
so that's going to be painful and we

00:22:11,659 --> 00:22:15,440
know that it's gonna be tied within this

00:22:13,190 --> 00:22:16,700
user signup process because it's a

00:22:15,440 --> 00:22:21,230
welcome email we know that's where that

00:22:16,700 --> 00:22:26,480
callback was written so we have to dive

00:22:21,230 --> 00:22:27,860
in so why would this happen so I think

00:22:26,480 --> 00:22:30,559
my first thing that I would do is I'd

00:22:27,860 --> 00:22:32,720
open up a rails console maybe I'd see

00:22:30,559 --> 00:22:34,190
their alert profile just see if anything

00:22:32,720 --> 00:22:35,510
weird is going on oh but look at this

00:22:34,190 --> 00:22:38,750
there's not one

00:22:35,510 --> 00:22:41,210
okay that makes sense what should have

00:22:38,750 --> 00:22:42,560
happened to a user should a user exist

00:22:41,210 --> 00:22:44,540
within our platform if they don't have

00:22:42,560 --> 00:22:47,060
an alert profile should have been

00:22:44,540 --> 00:22:48,560
created it at all what happens when we

00:22:47,060 --> 00:22:51,110
try to send an alert to that user in the

00:22:48,560 --> 00:22:54,410
future how do we ensure that all three

00:22:51,110 --> 00:22:56,960
objects are created so the user the

00:22:54,410 --> 00:22:58,250
credit score's the alert profile how do

00:22:56,960 --> 00:23:00,470
we ensure that all three of those things

00:22:58,250 --> 00:23:02,870
were created at signup how do we fix

00:23:00,470 --> 00:23:06,240
this code smell that I've been having on

00:23:02,870 --> 00:23:16,910
for the past 10 minutes and fix our bug

00:23:06,240 --> 00:23:16,910
[Music]

00:23:17,770 --> 00:23:23,030
one of my favorite tools and rails the

00:23:20,570 --> 00:23:24,909
active record transaction for handling

00:23:23,030 --> 00:23:27,740
my associated models that I love so much

00:23:24,909 --> 00:23:30,559
let me show you how this sucker works so

00:23:27,740 --> 00:23:32,570
a transaction is a block that basically

00:23:30,559 --> 00:23:35,150
says anything that takes place in this

00:23:32,570 --> 00:23:37,190
block if there's ever an error in it

00:23:35,150 --> 00:23:38,480
we're gonna roll everything back and so

00:23:37,190 --> 00:23:41,240
nothing is gonna be written to the

00:23:38,480 --> 00:23:43,190
database it's gonna be an undo so let's

00:23:41,240 --> 00:23:46,159
say our user was created that's all fine

00:23:43,190 --> 00:23:48,740
and good but if our credit profile fails

00:23:46,159 --> 00:23:50,419
to be created then the user it's above

00:23:48,740 --> 00:23:53,570
it also is deleted and that hasn't

00:23:50,419 --> 00:23:57,530
actually get created as well so to

00:23:53,570 --> 00:23:59,090
answer our other hypothetical a should a

00:23:57,530 --> 00:24:01,210
user be able to exist in our platform

00:23:59,090 --> 00:24:04,130
without an alert profile I'd say no

00:24:01,210 --> 00:24:07,880
that's part of our signup process it

00:24:04,130 --> 00:24:09,679
needs to be there so yeah these

00:24:07,880 --> 00:24:11,929
transactions are super helpful because

00:24:09,679 --> 00:24:14,090
it's either all of this code happens or

00:24:11,929 --> 00:24:16,100
none of it so everything with heading

00:24:14,090 --> 00:24:18,470
did this block either it has to take

00:24:16,100 --> 00:24:22,760
place or none of it so the mechanism is

00:24:18,470 --> 00:24:24,380
it triggers that rollback with is is an

00:24:22,760 --> 00:24:27,200
error that gets raised and that's why

00:24:24,380 --> 00:24:30,200
I'm calling my I'm super excited to

00:24:27,200 --> 00:24:33,470
create these records create with a bang

00:24:30,200 --> 00:24:37,190
syntax because rather than defaulting to

00:24:33,470 --> 00:24:39,440
Rails validation API with its user dot

00:24:37,190 --> 00:24:41,809
errors to be able to inspect why my user

00:24:39,440 --> 00:24:44,570
wasn't valid I actually wanted to skip

00:24:41,809 --> 00:24:48,559
that and raise an application error so

00:24:44,570 --> 00:24:51,860
that my transaction will rollback super

00:24:48,559 --> 00:24:54,110
cool so if I use one of those now when a

00:24:51,860 --> 00:24:57,830
user signs up even with my nasty

00:24:54,110 --> 00:25:02,480
callback we at least now know that all

00:24:57,830 --> 00:25:04,580
of all three of these users or all three

00:25:02,480 --> 00:25:08,179
of these objects sorry will be created

00:25:04,580 --> 00:25:10,100
at registration but where does where in

00:25:08,179 --> 00:25:13,940
theory should that transaction fit

00:25:10,100 --> 00:25:16,520
should it fit in the model should it fit

00:25:13,940 --> 00:25:17,600
in the controller we already talked that

00:25:16,520 --> 00:25:19,820
it shouldn't live in that callback

00:25:17,600 --> 00:25:22,820
because it's modifying other

00:25:19,820 --> 00:25:25,790
and this is where I'm gonna harken to

00:25:22,820 --> 00:25:27,800
this this popular rails post that has

00:25:25,790 --> 00:25:29,990
seen many different iterations over time

00:25:27,800 --> 00:25:32,510
and that's should you have a phat model

00:25:29,990 --> 00:25:36,560
or a Fat Controller phat model and a

00:25:32,510 --> 00:25:38,510
skinny controller it had actually argue

00:25:36,560 --> 00:25:41,450
that nothing should be fat everything

00:25:38,510 --> 00:25:43,940
should be skinny hold on let's take a

00:25:41,450 --> 00:25:49,970
moment to salute Weird Al the American

00:25:43,940 --> 00:25:52,090
hero for this great gym so we know that

00:25:49,970 --> 00:25:56,120
I don't want to just take this

00:25:52,090 --> 00:25:58,400
transaction and and we definitely want

00:25:56,120 --> 00:26:00,980
to rip that out of a callback so a model

00:25:58,400 --> 00:26:03,140
doesn't seem like the right fit should I

00:26:00,980 --> 00:26:05,150
put this all into a controller it's

00:26:03,140 --> 00:26:07,190
right in this context it's not a

00:26:05,150 --> 00:26:11,960
terrible example like if this doesn't

00:26:07,190 --> 00:26:13,970
seem like it's overly complex but if we

00:26:11,960 --> 00:26:15,650
already make this a transaction

00:26:13,970 --> 00:26:17,960
controller you can see all that logic

00:26:15,650 --> 00:26:19,490
you can see how the responsibility of

00:26:17,960 --> 00:26:21,920
the controller is getting way out of

00:26:19,490 --> 00:26:23,960
hand so a controller should be very

00:26:21,920 --> 00:26:25,700
skinny should process all of its logic

00:26:23,960 --> 00:26:27,860
to some other entity typically it's a

00:26:25,700 --> 00:26:29,420
model but in this case we've already

00:26:27,860 --> 00:26:30,980
determined that the model is not the

00:26:29,420 --> 00:26:33,800
correct case for it so where does it go

00:26:30,980 --> 00:26:36,410
so please know a model in the callback

00:26:33,800 --> 00:26:38,870
please no controller but where does it

00:26:36,410 --> 00:26:42,250
go and that's our next tool

00:26:38,870 --> 00:26:42,250
service object

00:26:44,070 --> 00:26:50,500
so my good friend Fancy Nancy she always

00:26:48,310 --> 00:26:53,890
says that a service object is just a

00:26:50,500 --> 00:26:56,830
fancy name for a vanilla Ruby object so

00:26:53,890 --> 00:26:59,530
yet you've got plain Ruby objects but

00:26:56,830 --> 00:27:02,470
you have a service object so it's a

00:26:59,530 --> 00:27:04,900
classier distinction of course so here's

00:27:02,470 --> 00:27:07,510
an example of one

00:27:04,900 --> 00:27:10,870
I've abstracted a lot of this stuff but

00:27:07,510 --> 00:27:13,660
this is a very simple simplistic example

00:27:10,870 --> 00:27:14,370
of what a serve user service could look

00:27:13,660 --> 00:27:18,790
like

00:27:14,370 --> 00:27:21,490
and you'll notice unlike all rails

00:27:18,790 --> 00:27:23,140
things that are generated there is no

00:27:21,490 --> 00:27:25,180
inheritance this isn't inheriting from

00:27:23,140 --> 00:27:27,370
something it makes you feel kind of

00:27:25,180 --> 00:27:29,710
naked because you're on your own

00:27:27,370 --> 00:27:31,930
everything that you're writing here is

00:27:29,710 --> 00:27:34,480
not part of the rails framework but as

00:27:31,930 --> 00:27:36,880
part of your business logic and it's

00:27:34,480 --> 00:27:39,240
part of the reasons why I love reaching

00:27:36,880 --> 00:27:41,290
for tools like this is because your

00:27:39,240 --> 00:27:43,720
application your business needs to do

00:27:41,290 --> 00:27:47,400
something specific to you and will

00:27:43,720 --> 00:27:53,230
frequently not fall into the standard

00:27:47,400 --> 00:27:56,500
crud request cycle of a scaffolded

00:27:53,230 --> 00:27:58,420
object in our example here we have got a

00:27:56,500 --> 00:28:00,250
lot of complex logic it should live

00:27:58,420 --> 00:28:03,610
somewhere and a service object is a

00:28:00,250 --> 00:28:05,290
great place to live so just to run

00:28:03,610 --> 00:28:08,170
through this really quick so we're gonna

00:28:05,290 --> 00:28:10,120
create so passing in the params this

00:28:08,170 --> 00:28:11,710
will be like from a registration form

00:28:10,120 --> 00:28:13,990
all of the fields that we correct

00:28:11,710 --> 00:28:16,360
collect and then we are gonna extract

00:28:13,990 --> 00:28:18,850
from those for the fields that we need

00:28:16,360 --> 00:28:21,220
for a user per am or alert profiles from

00:28:18,850 --> 00:28:25,950
our credit from a credit score and then

00:28:21,220 --> 00:28:30,250
we'll actual trigger our create objects

00:28:25,950 --> 00:28:33,160
method here that will utilize our really

00:28:30,250 --> 00:28:34,540
cool active record transaction and

00:28:33,160 --> 00:28:36,490
pretty straightforward whether or not

00:28:34,540 --> 00:28:38,470
you need an object to process that and

00:28:36,490 --> 00:28:39,610
you prefer procedural processing and

00:28:38,470 --> 00:28:41,200
this is actually we're not what I would

00:28:39,610 --> 00:28:44,680
prefer because I think this is a lot

00:28:41,200 --> 00:28:47,650
more straightforward and it's a lot more

00:28:44,680 --> 00:28:50,470
functional well a state to manage we can

00:28:47,650 --> 00:28:53,350
just pass the the objects that we create

00:28:50,470 --> 00:28:57,509
in line something like this would be my

00:28:53,350 --> 00:29:00,720
preference so the procedure is like the

00:28:57,509 --> 00:29:04,179
the super sophisticated approach to this

00:29:00,720 --> 00:29:06,009
just having something that's some some

00:29:04,179 --> 00:29:08,220
procedure that keeps track of all of

00:29:06,009 --> 00:29:10,899
your your registration process

00:29:08,220 --> 00:29:14,289
versioning gets super simple because you

00:29:10,899 --> 00:29:17,820
can take your either your service object

00:29:14,289 --> 00:29:20,019
or your procedure for registration and

00:29:17,820 --> 00:29:22,299
throw a version on it so if you need to

00:29:20,019 --> 00:29:24,519
maintain support for how things used to

00:29:22,299 --> 00:29:26,639
happen when you signed up users to have

00:29:24,519 --> 00:29:30,070
things will with your new and improved

00:29:26,639 --> 00:29:31,539
mobile application let's say yeah just

00:29:30,070 --> 00:29:33,789
increment the version number in this

00:29:31,539 --> 00:29:37,450
module when you're off to the races so

00:29:33,789 --> 00:29:41,019
where should you put a service object a

00:29:37,450 --> 00:29:42,730
procedure where should you put it I've

00:29:41,019 --> 00:29:44,590
seen some people put to these type of

00:29:42,730 --> 00:29:47,350
vanilla Ruby objects in the model

00:29:44,590 --> 00:29:49,179
directory and that's fine like rails is

00:29:47,350 --> 00:29:51,190
gonna load them I personally don't

00:29:49,179 --> 00:29:53,200
prefer the model directory because

00:29:51,190 --> 00:29:55,029
models in my mind should be what rails

00:29:53,200 --> 00:29:57,220
generate like everything there should

00:29:55,029 --> 00:30:00,759
have an Associated database table that

00:29:57,220 --> 00:30:02,500
goes with it I prefer to from doing

00:30:00,759 --> 00:30:05,559
service objects to have some sort of

00:30:02,500 --> 00:30:08,710
other directory for services or maybe in

00:30:05,559 --> 00:30:11,769
Lib since it's not part of the rails

00:30:08,710 --> 00:30:13,450
traditional app structure I don't think

00:30:11,769 --> 00:30:15,090
it really matters what matters is is

00:30:13,450 --> 00:30:17,860
that your team all have the consistence

00:30:15,090 --> 00:30:21,730
preference for all of that

00:30:17,860 --> 00:30:23,769
so pros of a service object so single

00:30:21,730 --> 00:30:25,539
responsibility for everyone so we're

00:30:23,769 --> 00:30:27,940
gonna have a dedicated object that takes

00:30:25,539 --> 00:30:30,909
place that takes care of need your user

00:30:27,940 --> 00:30:33,309
registration it's one object that its

00:30:30,909 --> 00:30:34,779
job is to know how all these pieces

00:30:33,309 --> 00:30:37,179
within our application are glued

00:30:34,779 --> 00:30:38,830
together and each piece of our

00:30:37,179 --> 00:30:41,289
application doesn't need to know about

00:30:38,830 --> 00:30:45,610
everything else like it's everything has

00:30:41,289 --> 00:30:49,440
its single responsibility it's easy to

00:30:45,610 --> 00:30:52,480
test because we don't have to create a

00:30:49,440 --> 00:30:55,929
like a factory bot or something like

00:30:52,480 --> 00:30:58,029
that or a fixture that keeps put track

00:30:55,929 --> 00:30:59,619
of the ordering that all of our various

00:30:58,029 --> 00:31:03,460
associated records need to take place

00:30:59,619 --> 00:31:08,460
and no like a service object or proceed

00:31:03,460 --> 00:31:08,460
it knows that we're gonna feed it a / a

00:31:08,640 --> 00:31:13,560
manifesting very easy to test it's super

00:31:12,130 --> 00:31:16,390
easy to version like we talked about

00:31:13,560 --> 00:31:19,600
very easy to complain contain

00:31:16,390 --> 00:31:22,000
complexities and again because you have

00:31:19,600 --> 00:31:24,640
an object that sole responsibility is to

00:31:22,000 --> 00:31:26,650
juggle all of those things it's easier

00:31:24,640 --> 00:31:29,500
to it's easy to have one place that it

00:31:26,650 --> 00:31:31,960
has it all and we have the option to

00:31:29,500 --> 00:31:34,300
sidestep this registration process if we

00:31:31,960 --> 00:31:38,350
ever wanted if we need to create just a

00:31:34,300 --> 00:31:40,120
user by itself without an alert profile

00:31:38,350 --> 00:31:42,640
or a credit score we can absolutely do

00:31:40,120 --> 00:31:45,450
that and since it's not tied to a

00:31:42,640 --> 00:31:47,830
callback we have that flexibility

00:31:45,450 --> 00:31:51,280
because it's not tied to every database

00:31:47,830 --> 00:31:54,490
event that takes place for a user so the

00:31:51,280 --> 00:31:57,340
cons of a service object so again just

00:31:54,490 --> 00:32:00,220
as the the pros of callbacks worked for

00:31:57,340 --> 00:32:03,100
us they can also disassociate in them

00:32:00,220 --> 00:32:06,760
could could bite us in time like if

00:32:03,100 --> 00:32:09,190
we're if a developer isn't aware on our

00:32:06,760 --> 00:32:11,050
team that's we have the service objects

00:32:09,190 --> 00:32:13,780
or procedures that take place take care

00:32:11,050 --> 00:32:15,880
of user registration they might not they

00:32:13,780 --> 00:32:17,350
just might assume that it's their alert

00:32:15,880 --> 00:32:18,910
profile is always gonna be there when

00:32:17,350 --> 00:32:21,190
they create another way to create users

00:32:18,910 --> 00:32:22,750
within our platform so there is some

00:32:21,190 --> 00:32:24,040
training that you're gonna have and

00:32:22,750 --> 00:32:28,390
responsibilities that you're gonna have

00:32:24,040 --> 00:32:30,910
to to make sure that all of your edge

00:32:28,390 --> 00:32:33,190
cases are handled it's not vanilla rail

00:32:30,910 --> 00:32:35,410
so this isn't something this isn't a

00:32:33,190 --> 00:32:38,110
subject that rails boot camps or college

00:32:35,410 --> 00:32:39,850
courses are going to cover and if they

00:32:38,110 --> 00:32:44,280
do it's going to be like a 30-minute

00:32:39,850 --> 00:32:48,100
session but it's a super powerful way to

00:32:44,280 --> 00:32:50,980
kind of contain the complexity of your

00:32:48,100 --> 00:32:52,390
logic the learning curve might be there

00:32:50,980 --> 00:32:53,710
for a bit especially if this is your

00:32:52,390 --> 00:32:58,930
first time to kind of dealing with data

00:32:53,710 --> 00:33:00,790
pipelines because these this type of

00:32:58,930 --> 00:33:02,350
concept isn't covered in a lot of the

00:33:00,790 --> 00:33:03,910
educational material so there will be

00:33:02,350 --> 00:33:06,520
some training that you're gonna have to

00:33:03,910 --> 00:33:09,160
do and you're also gonna have to figure

00:33:06,520 --> 00:33:11,950
out how you're going to handle errors so

00:33:09,160 --> 00:33:13,840
rails with callbacks they tail suit they

00:33:11,950 --> 00:33:19,060
pair super well with

00:33:13,840 --> 00:33:21,580
API with if you build your own service

00:33:19,060 --> 00:33:25,020
object or your own procedure you're

00:33:21,580 --> 00:33:29,350
gonna have to either use those existing

00:33:25,020 --> 00:33:32,230
error models or those existing

00:33:29,350 --> 00:33:33,730
validation API is but find some way of

00:33:32,230 --> 00:33:36,700
messaging in the controller's of the

00:33:33,730 --> 00:33:39,190
various consumers of your services that

00:33:36,700 --> 00:33:40,180
something went wrong it's it's just more

00:33:39,190 --> 00:33:42,130
things you're gonna have to think about

00:33:40,180 --> 00:33:43,570
but it's good because you should be

00:33:42,130 --> 00:33:46,240
thinking about all of those things

00:33:43,570 --> 00:33:48,070
because going back to our earlier bugs

00:33:46,240 --> 00:33:50,560
should a user be able to exist without

00:33:48,070 --> 00:33:51,820
an alert profile right like you need to

00:33:50,560 --> 00:33:54,640
be thinking through all of those things

00:33:51,820 --> 00:33:56,230
for user registration but it's just it's

00:33:54,640 --> 00:33:58,860
just not as easy out of the box as it

00:33:56,230 --> 00:34:03,280
would be if you're using scaffolding

00:33:58,860 --> 00:34:06,640
okay so going back to our where does our

00:34:03,280 --> 00:34:10,120
fat skinny and models or controllers

00:34:06,640 --> 00:34:13,090
live so in this example our model for a

00:34:10,120 --> 00:34:14,980
user now looks like this we don't have

00:34:13,090 --> 00:34:17,200
any callback that has a new logic for it

00:34:14,980 --> 00:34:19,210
thankfully our controller is just

00:34:17,200 --> 00:34:20,650
passing off to our user service this

00:34:19,210 --> 00:34:21,520
create calls or a controller

00:34:20,650 --> 00:34:25,690
super-skinny

00:34:21,520 --> 00:34:27,970
and our service has the all of the life

00:34:25,690 --> 00:34:30,550
cycle logic that needs to take place in

00:34:27,970 --> 00:34:34,870
a very easily testable and isolated

00:34:30,550 --> 00:34:37,060
environment so our model our Mott our

00:34:34,870 --> 00:34:39,460
database in our application are now

00:34:37,060 --> 00:34:42,330
viewing themselves all in the same way

00:34:39,460 --> 00:34:44,650
and everything is awesome because

00:34:42,330 --> 00:34:48,640
everything is isolated and they all have

00:34:44,650 --> 00:34:50,860
their own responsibilities but all of

00:34:48,640 --> 00:34:53,110
this makes one giant assumption and

00:34:50,860 --> 00:34:55,740
that's that all of your logic is taking

00:34:53,110 --> 00:34:59,790
place within one application and that

00:34:55,740 --> 00:34:59,790
brings us to our last chapter

00:35:03,350 --> 00:35:25,500
hi there little fella so how do we

00:35:22,140 --> 00:35:27,990
handle lifecycle events in a distributed

00:35:25,500 --> 00:35:29,550
environment it could be microservices or

00:35:27,990 --> 00:35:32,330
maybe there's just different apps within

00:35:29,550 --> 00:35:37,530
our within your your platform right

00:35:32,330 --> 00:35:40,230
let's say our our credit our credit app

00:35:37,530 --> 00:35:41,910
has scaled significantly so we needed to

00:35:40,230 --> 00:35:45,690
break these up into multiple apps of

00:35:41,910 --> 00:35:47,100
course cuz we're a web scale now okay so

00:35:45,690 --> 00:35:48,570
we've got a couple of different apps now

00:35:47,100 --> 00:35:49,800
so we've got our main credit app but

00:35:48,570 --> 00:35:51,870
maybe we've got another app that has

00:35:49,800 --> 00:35:53,970
business intelligence one for marketing

00:35:51,870 --> 00:35:56,880
one for alerting and one for sales

00:35:53,970 --> 00:36:00,390
itself right so when we create a user

00:35:56,880 --> 00:36:02,790
how do we tell all these various apps

00:36:00,390 --> 00:36:04,950
about that and how do we handle these

00:36:02,790 --> 00:36:09,560
complex lifecycle events in a

00:36:04,950 --> 00:36:12,120
distributed fashion and the core idea is

00:36:09,560 --> 00:36:14,220
the where before when it was all under

00:36:12,120 --> 00:36:16,020
one hood we had complete control over

00:36:14,220 --> 00:36:18,750
the ordering of how these things all

00:36:16,020 --> 00:36:20,250
happened in a distribute environment you

00:36:18,750 --> 00:36:23,130
have to let go

00:36:20,250 --> 00:36:25,290
you have to relinquish the control of

00:36:23,130 --> 00:36:28,050
all of that and trust that everywhere

00:36:25,290 --> 00:36:30,840
else in the platform can handle the the

00:36:28,050 --> 00:36:34,260
new information about your record that

00:36:30,840 --> 00:36:36,000
you are going to tell it so our job is

00:36:34,260 --> 00:36:38,280
to tell the system at large that

00:36:36,000 --> 00:36:40,110
something has happened and we have to

00:36:38,280 --> 00:36:43,110
trust them to do what they will with

00:36:40,110 --> 00:36:45,210
that information so it looks something

00:36:43,110 --> 00:36:47,430
like this we're gonna send a message out

00:36:45,210 --> 00:36:48,960
that a user is created and then all the

00:36:47,430 --> 00:36:52,860
gossip then the system is going to take

00:36:48,960 --> 00:36:54,480
place right we the only control we have

00:36:52,860 --> 00:36:57,960
is our text message that we're sending

00:36:54,480 --> 00:36:59,880
out is our message of a user update that

00:36:57,960 --> 00:37:01,830
we're sending out and the rest of the

00:36:59,880 --> 00:37:04,320
platform it's their responsibility to

00:37:01,830 --> 00:37:08,670
consume that information and make their

00:37:04,320 --> 00:37:11,100
changes as they see fit so a couple

00:37:08,670 --> 00:37:13,240
technical examples that I have

00:37:11,100 --> 00:37:15,730
implement or technical tools that I've

00:37:13,240 --> 00:37:18,100
used to implement this idea of messaging

00:37:15,730 --> 00:37:21,250
on a distributed basis RabbitMQ and

00:37:18,100 --> 00:37:22,870
Kafka are great tools to reach for they

00:37:21,250 --> 00:37:26,350
each have their pros and their cons I

00:37:22,870 --> 00:37:28,570
won't dive too much into where what tool

00:37:26,350 --> 00:37:30,970
you should use that's for another talk

00:37:28,570 --> 00:37:33,160
but what I want to do is give an example

00:37:30,970 --> 00:37:36,010
of how you deal with these events

00:37:33,160 --> 00:37:38,920
with these tools in a high-level is all

00:37:36,010 --> 00:37:40,930
and the idea is we need to publish in a

00:37:38,920 --> 00:37:42,850
subscribe model so we're gonna publish a

00:37:40,930 --> 00:37:45,820
life cycle event out into our platform

00:37:42,850 --> 00:37:47,140
and the various apps in our platform are

00:37:45,820 --> 00:37:52,390
gonna consume that message by

00:37:47,140 --> 00:37:55,420
subscribing to that event topic so for

00:37:52,390 --> 00:37:58,150
an example here's our credit app we have

00:37:55,420 --> 00:38:00,250
our user that we're going to serialize

00:37:58,150 --> 00:38:02,980
to JSON and then we're going to publish

00:38:00,250 --> 00:38:06,520
it out to the world so in a rabbit

00:38:02,980 --> 00:38:09,160
example we will publish it to a topic of

00:38:06,520 --> 00:38:11,170
like user dot create so anyone any of

00:38:09,160 --> 00:38:13,570
these consuming applications that are

00:38:11,170 --> 00:38:16,090
interested in user create events they

00:38:13,570 --> 00:38:17,620
are gonna subscribe to user creates and

00:38:16,090 --> 00:38:20,620
they can do whatever they would like to

00:38:17,620 --> 00:38:24,250
it so a CRM for instance if we create a

00:38:20,620 --> 00:38:26,170
user within our app they will consume

00:38:24,250 --> 00:38:28,360
that user JSON and maybe create a

00:38:26,170 --> 00:38:29,410
contact for it right then maybe that's

00:38:28,360 --> 00:38:33,460
something that they would be interested

00:38:29,410 --> 00:38:35,710
in and the the cool thing is is this one

00:38:33,460 --> 00:38:38,410
user event kind of gets fanned out to

00:38:35,710 --> 00:38:40,450
everyone and they all get their own cue

00:38:38,410 --> 00:38:44,050
to process that data which is really

00:38:40,450 --> 00:38:48,370
cool for resiliency because if if ever

00:38:44,050 --> 00:38:49,690
our CRM app is down for instance I know

00:38:48,370 --> 00:38:52,600
it's never happened in the history of

00:38:49,690 --> 00:38:55,000
the world but if our CRM is down does

00:38:52,600 --> 00:38:56,970
that mean that it's gonna miss any chase

00:38:55,000 --> 00:38:58,870
user J songs that come in in the future

00:38:56,970 --> 00:39:01,750
that would be a bad system and that's

00:38:58,870 --> 00:39:03,790
part of the benefit of using a messaging

00:39:01,750 --> 00:39:05,560
system like this is rabbit is going to

00:39:03,790 --> 00:39:07,570
persist all of those messages so by the

00:39:05,560 --> 00:39:10,270
time that it comes back up it can

00:39:07,570 --> 00:39:12,430
process all of the the user messages

00:39:10,270 --> 00:39:15,550
that it missed while it was down which

00:39:12,430 --> 00:39:19,150
is really cool so a an example of that

00:39:15,550 --> 00:39:21,190
is this so tying into those callbacks

00:39:19,150 --> 00:39:23,350
that we talked about earlier so when we

00:39:21,190 --> 00:39:24,549
create or update or delete we want to

00:39:23,350 --> 00:39:30,160
publish that

00:39:24,549 --> 00:39:32,410
eight two two two rabbit or two Kafka or

00:39:30,160 --> 00:39:34,420
it's whatever pub/sub service that you

00:39:32,410 --> 00:39:36,910
use right so we're gonna publish the

00:39:34,420 --> 00:39:40,420
state of ourself so in this case self is

00:39:36,910 --> 00:39:44,619
a user so it's gonna be a JSON payload

00:39:40,420 --> 00:39:45,999
and then our CR CRM app will consume

00:39:44,619 --> 00:39:49,150
that message with something like this

00:39:45,999 --> 00:39:51,219
this is all kind of just pseudocode but

00:39:49,150 --> 00:39:53,229
it's gonna listen to any users create

00:39:51,219 --> 00:39:54,969
messages and it will create a new

00:39:53,229 --> 00:39:57,509
contact and maybe it will be able to

00:39:54,969 --> 00:40:00,160
deduce what account in our CRM the

00:39:57,509 --> 00:40:01,929
contact belongs to based off of the

00:40:00,160 --> 00:40:02,439
company name of the user or something

00:40:01,929 --> 00:40:06,549
like that

00:40:02,439 --> 00:40:08,199
right so the responsibility is a lot

00:40:06,549 --> 00:40:10,059
more distributed now and this is where

00:40:08,199 --> 00:40:12,880
the costs of distributing computing

00:40:10,059 --> 00:40:16,059
computing really come into play I don't

00:40:12,880 --> 00:40:19,150
really have a horse in the the monolith

00:40:16,059 --> 00:40:20,979
versus microservices battle but I can

00:40:19,150 --> 00:40:24,099
tell you that distributing computing is

00:40:20,979 --> 00:40:26,609
a lot more expensive so make sure you

00:40:24,099 --> 00:40:32,410
are prepared for the expense in

00:40:26,609 --> 00:40:33,910
technical complexities and the the

00:40:32,410 --> 00:40:36,880
technical services that you're gonna

00:40:33,910 --> 00:40:38,769
have in place for for managing all of

00:40:36,880 --> 00:40:40,209
them because these are a lot more moving

00:40:38,769 --> 00:40:42,539
pieces and since you don't have that

00:40:40,209 --> 00:40:46,390
control of what happens if the user

00:40:42,539 --> 00:40:49,209
errors at what should happen if you

00:40:46,390 --> 00:40:51,160
can't control it then you're more error

00:40:49,209 --> 00:40:53,019
prone and you have to write all sorts of

00:40:51,160 --> 00:40:55,689
logic to get everything back in state

00:40:53,019 --> 00:40:58,859
and all entry synced it it is possible

00:40:55,689 --> 00:41:02,769
just gets more expensive so the pros of

00:40:58,859 --> 00:41:05,589
pub/sub lifecycle event handling what's

00:41:02,769 --> 00:41:08,349
nice is dependent surfaces can go up and

00:41:05,589 --> 00:41:10,660
down and they will not miss out on key

00:41:08,349 --> 00:41:14,799
information and they shouldn't prevent a

00:41:10,660 --> 00:41:16,289
user from being created we can we can

00:41:14,799 --> 00:41:19,479
pick up where we left off when the app

00:41:16,289 --> 00:41:23,079
it comes back online we don't need any

00:41:19,479 --> 00:41:25,199
service objects or procedures there's no

00:41:23,079 --> 00:41:27,219
option for a gnarly call back because

00:41:25,199 --> 00:41:29,619
we're just gonna tell the world about

00:41:27,219 --> 00:41:31,420
our state and we can move on super

00:41:29,619 --> 00:41:33,910
resilient to downtime like I talked

00:41:31,420 --> 00:41:35,950
about our queues can keep track of what

00:41:33,910 --> 00:41:40,300
we've missed when they come back on

00:41:35,950 --> 00:41:45,340
and everyone Minds our business part of

00:41:40,300 --> 00:41:48,940
the part of the the lore of micro

00:41:45,340 --> 00:41:50,380
services and distributed apps is that it

00:41:48,940 --> 00:41:52,270
takes that principle of single

00:41:50,380 --> 00:41:54,310
responsibility and it kind of takes it

00:41:52,270 --> 00:41:56,200
up another level like our credit app

00:41:54,310 --> 00:42:00,070
should only be responsible for credit

00:41:56,200 --> 00:42:02,920
and not for email notifications or CRM

00:42:00,070 --> 00:42:04,330
integration and like I can see where

00:42:02,920 --> 00:42:06,070
they're coming from with that because it

00:42:04,330 --> 00:42:09,240
takes that single responsibility and

00:42:06,070 --> 00:42:11,830
takes it to the next level the cons are

00:42:09,240 --> 00:42:13,810
it's super easy to get out of sync

00:42:11,830 --> 00:42:16,750
especially if you're running into

00:42:13,810 --> 00:42:18,820
problems with let's say there's a data

00:42:16,750 --> 00:42:21,400
problem with users like how are you

00:42:18,820 --> 00:42:23,650
gonna handle updating that problem

00:42:21,400 --> 00:42:25,660
within your database and in your app and

00:42:23,650 --> 00:42:27,520
then telling all the distributed apps

00:42:25,660 --> 00:42:31,420
that hey everything that we did in the

00:42:27,520 --> 00:42:33,460
past we need you to undo everything it

00:42:31,420 --> 00:42:34,960
can get kind of complex my my

00:42:33,460 --> 00:42:37,390
recommendation is to make all of your

00:42:34,960 --> 00:42:39,100
consumers idempotent so that means you

00:42:37,390 --> 00:42:40,540
can process the same message over and

00:42:39,100 --> 00:42:43,870
over and over again without doing any

00:42:40,540 --> 00:42:45,790
harm so that if you have to get things

00:42:43,870 --> 00:42:47,350
back in sync you can just rebroadcast

00:42:45,790 --> 00:42:49,600
the state of your database across and

00:42:47,350 --> 00:42:53,410
everything is like a worst case scenario

00:42:49,600 --> 00:42:55,030
and that's totally fine it's just again

00:42:53,410 --> 00:42:58,180
more complexity that you're gonna have

00:42:55,030 --> 00:42:59,920
to keep in the back of your head super

00:42:58,180 --> 00:43:01,870
is susceptible to race conditions and

00:42:59,920 --> 00:43:04,330
orphans even more so than our call backs

00:43:01,870 --> 00:43:06,490
example from before because there's

00:43:04,330 --> 00:43:11,640
different places where all of this logic

00:43:06,490 --> 00:43:13,810
and and state can live so if you are

00:43:11,640 --> 00:43:15,310
dependent on different consumers for

00:43:13,810 --> 00:43:17,170
creating different objects and then

00:43:15,310 --> 00:43:21,370
broadcasting those out for other people

00:43:17,170 --> 00:43:24,520
to consume it can get really gnarly and

00:43:21,370 --> 00:43:27,070
it's very easy to enable a distributed

00:43:24,520 --> 00:43:29,970
monolith this is an argument that a lot

00:43:27,070 --> 00:43:33,310
of people who hate micro services really

00:43:29,970 --> 00:43:35,890
come back to is that we can have the

00:43:33,310 --> 00:43:39,340
benefit of splitting up applications but

00:43:35,890 --> 00:43:41,680
not realize but not really realize that

00:43:39,340 --> 00:43:44,010
true benefit because if they're all so

00:43:41,680 --> 00:43:46,240
tightly integrated with with in

00:43:44,010 --> 00:43:48,520
understanding the state of all of the

00:43:46,240 --> 00:43:51,950
records from all of the different

00:43:48,520 --> 00:43:54,890
well all we've really done is created a

00:43:51,950 --> 00:43:56,420
giant monolithic app wherever where

00:43:54,890 --> 00:43:58,640
everyone's dependent on the state of a

00:43:56,420 --> 00:44:02,920
user keep that dependency up and running

00:43:58,640 --> 00:44:05,210
is this this pub/sub model that as

00:44:02,920 --> 00:44:07,910
momentum before it kind of can be not

00:44:05,210 --> 00:44:10,370
only to keep up so it can't enable it if

00:44:07,910 --> 00:44:12,590
we're not being vigilant on what our

00:44:10,370 --> 00:44:15,110
dependencies are like what do we have

00:44:12,590 --> 00:44:16,910
what does our CRM have to know about

00:44:15,110 --> 00:44:18,320
does it need to know about transactions

00:44:16,910 --> 00:44:20,330
does it need to know about credit scores

00:44:18,320 --> 00:44:24,800
or does it just need to know about our

00:44:20,330 --> 00:44:26,960
users and it can be a big old single

00:44:24,800 --> 00:44:30,560
point of failure so so if rabbit goes

00:44:26,960 --> 00:44:33,230
down all of this fancy distributed

00:44:30,560 --> 00:44:35,140
architecture that we that we have built

00:44:33,230 --> 00:44:41,350
up could crumble pretty quick

00:44:35,140 --> 00:44:44,420
so in review callbacks they're beautiful

00:44:41,350 --> 00:44:46,460
but the big point is is they should not

00:44:44,420 --> 00:44:49,610
modify other associated records they

00:44:46,460 --> 00:44:50,750
should only modify themselves I beat

00:44:49,610 --> 00:44:53,240
that dead horse pretty well I think

00:44:50,750 --> 00:44:55,130
during this talk it's great for setting

00:44:53,240 --> 00:44:57,650
do you database fields on that model

00:44:55,130 --> 00:44:59,480
itself if you have to use associated

00:44:57,650 --> 00:45:02,420
models make sure you're doing so in a

00:44:59,480 --> 00:45:05,930
read-only matter next it was our active

00:45:02,420 --> 00:45:08,390
record transactions so if you require

00:45:05,930 --> 00:45:09,710
many records to be created in line and

00:45:08,390 --> 00:45:11,720
dependent upon each other use a

00:45:09,710 --> 00:45:12,980
transaction you can easily roll back so

00:45:11,720 --> 00:45:14,510
that you made you know that you're

00:45:12,980 --> 00:45:17,510
either getting all of them or none of

00:45:14,510 --> 00:45:19,720
them but don't put them in callbacks

00:45:17,510 --> 00:45:23,090
because that breaks our earlier rules

00:45:19,720 --> 00:45:24,890
our service objects and procedures so

00:45:23,090 --> 00:45:27,290
use a service object when you are

00:45:24,890 --> 00:45:29,480
required to do a series of dependent

00:45:27,290 --> 00:45:32,030
database calls during a lifecycle event

00:45:29,480 --> 00:45:33,920
so lifecycle events are so if they're if

00:45:32,030 --> 00:45:35,780
they have so much business logic that

00:45:33,920 --> 00:45:38,000
are getting complex and key to your

00:45:35,780 --> 00:45:40,220
business I highly recommend creating in

00:45:38,000 --> 00:45:43,880
their own entity to handle user

00:45:40,220 --> 00:45:46,880
registrations user deletes client

00:45:43,880 --> 00:45:50,570
registrations like all of that should be

00:45:46,880 --> 00:45:53,180
bottle up into their own file ruby file

00:45:50,570 --> 00:45:56,050
just say it as simply as possible and

00:45:53,180 --> 00:45:58,070
you can use if you if you prefer objects

00:45:56,050 --> 00:46:00,470
architecture that's great if you're a

00:45:58,070 --> 00:46:02,810
class method that handles your procedure

00:46:00,470 --> 00:46:05,150
that works

00:46:02,810 --> 00:46:07,760
it helps keep your model separate so if

00:46:05,150 --> 00:46:09,680
you're not a monolithic architecture and

00:46:07,760 --> 00:46:13,220
you are into some sort of distributed

00:46:09,680 --> 00:46:15,230
microservices set up I recommend using a

00:46:13,220 --> 00:46:18,530
distributed messaging platform like

00:46:15,230 --> 00:46:20,900
rabbitmq or Kafka to broadcast and

00:46:18,530 --> 00:46:22,580
handle all of your lifecycle events this

00:46:20,900 --> 00:46:24,050
is really great for maintaining that

00:46:22,580 --> 00:46:27,260
boundary of responsibility

00:46:24,050 --> 00:46:29,660
it's very resilient to downtime but it's

00:46:27,260 --> 00:46:32,060
not immune in fact it's more so immune

00:46:29,660 --> 00:46:34,790
or more so suspect susceptible for

00:46:32,060 --> 00:46:36,590
orphans and race conditions alright we

00:46:34,790 --> 00:46:38,420
made it we got there we've learned a lot

00:46:36,590 --> 00:46:42,050
I had a ton of fun putting this together

00:46:38,420 --> 00:46:44,780
I owe a ton to this rails community at

00:46:42,050 --> 00:46:48,470
large in fact my entire technical career

00:46:44,780 --> 00:46:52,010
I think I owe to it because I these

00:46:48,470 --> 00:46:54,830
tools that help me rapidly iterate have

00:46:52,010 --> 00:46:57,440
given me my career and given me my

00:46:54,830 --> 00:47:00,050
professional passion as well and I just

00:46:57,440 --> 00:47:02,030
wanted to find a way to bottle up all

00:47:00,050 --> 00:47:03,860
the things that I've learned over the

00:47:02,030 --> 00:47:05,630
time so write simpler more maintainable

00:47:03,860 --> 00:47:06,890
code and deliver it in this format so I

00:47:05,630 --> 00:47:08,960
really appreciate you hanging out with

00:47:06,890 --> 00:47:11,420
me if you enjoyed it here's where you

00:47:08,960 --> 00:47:13,970
can find me on Twitter and tell me

00:47:11,420 --> 00:47:15,890
enjoyed it if you laughed at all let me

00:47:13,970 --> 00:47:19,550
know because I Drive so much am i worth

00:47:15,890 --> 00:47:22,130
off of making people chuckle that would

00:47:19,550 --> 00:47:26,800
be great anyways thanks for flying with

00:47:22,130 --> 00:47:26,800

YouTube URL: https://www.youtube.com/watch?v=db-FEuSLIyc


