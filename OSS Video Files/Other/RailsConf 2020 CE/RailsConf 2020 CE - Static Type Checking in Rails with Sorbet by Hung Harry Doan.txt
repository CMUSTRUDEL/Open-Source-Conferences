Title: RailsConf 2020 CE - Static Type Checking in Rails with Sorbet by Hung Harry Doan
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Static Type Checking in Rails with Sorbet by Hung Harry Doan

"Sorbet is a powerful static type-checking tool for Ruby. Type checking can catch errors early and improve the developer experience—and with the right tools, it can even be used with dynamic methods in Rails.

In this talk, we’ll cover the basics of type checking and share the lessons learned from our adoption of Sorbet type checking across our 2,500-file codebase in just six months. We’ll talk about the technical challenges we faced and how we solved them with a new Sorbet-Rails gem, which makes it easy to gradually integrate type checking into your Rails app & improve your team’s efficiency."

__________

Harry Doan is a Staff Software Engineer at the Chan Zuckerberg Initiative. He’s passionate about building great developer productivity tools and applications for the community. He created Sorbet-Rails to help Rails developers benefit from static type checking. In his free time, he can be found meditating or studying Buddhism teachings.
Captions: 
	00:00:09,320 --> 00:00:12,530
-hello everyone thanks for tuning into railsconf.

00:00:12,530 --> 00:00:19,410
Today I would like to talk to you about static type checking in rails using a awesome tool

00:00:19,410 --> 00:00:20,410
called Sorbet.

00:00:20,410 --> 00:00:23,820
We are going to cover three main things today.

00:00:23,820 --> 00:00:29,859
First we will talk about what is static type checking and why the benefits are worth the

00:00:29,859 --> 00:00:30,859
effort.

00:00:30,859 --> 00:00:36,610
I will walk you through how we use Sorbet to type check our result which is going to

00:00:36,610 --> 00:00:38,330
be a fun challenge.

00:00:38,330 --> 00:00:44,850
Plus I will give you some tips and tricks for how you can drive adoptions of Sorbet

00:00:44,850 --> 00:00:47,190
in your team.

00:00:47,190 --> 00:00:48,850
My name is Hung Doan.

00:00:48,850 --> 00:00:53,210
I am a staff engineer at the Chan Zuckerberg initiative.

00:00:53,210 --> 00:00:57,949
Harry is a name I picked for myself because I really enjoy Harry Potter.

00:00:57,949 --> 00:01:04,940
I enjoy Harry Potter so much now I will be using wizard examples throughout this talk.

00:01:04,940 --> 00:01:14,290
CZI is the new kind of philanthropy that applies technology to solve challenging social problems.

00:01:14,290 --> 00:01:16,720
We have three main initiatives.

00:01:16,720 --> 00:01:23,920
One working across science and DC research, two education and three looking in the areas

00:01:23,920 --> 00:01:27,110
of justice and opportunity.

00:01:27,110 --> 00:01:33,350
I work on the education initiative where we build some e-learning program a personalized

00:01:33,350 --> 00:01:37,710
education platform for any k12 school in the U.S.

00:01:37,710 --> 00:01:45,850
It empowers students to learn at their own pace in the best way that works for them,

00:01:45,850 --> 00:01:51,550
so they can help with code base and teams that are large and small old and new.

00:01:51,550 --> 00:01:56,219
To give you a sense of our skills our team has about 35 engineers.

00:01:56,219 --> 00:01:59,930
We've been developing this platform for six years no.

00:01:59,930 --> 00:02:07,479
It is moving on top of Ruby on Rails with more than 2,000 Ruby files and more than 150,000

00:02:07,479 --> 00:02:09,149
lines of Ruby.

00:02:09,149 --> 00:02:13,340
It is a reasonable-sized codebase and team.

00:02:13,340 --> 00:02:19,630
As the theme has expanded we have seen challenges that I think are typical to any engineering

00:02:19,630 --> 00:02:20,630
team.

00:02:20,630 --> 00:02:27,640
Such as maintaining legacy code built years ago, making big code changes safely and reliably,

00:02:27,640 --> 00:02:29,270
and onboarding new engineers.

00:02:29,270 --> 00:02:36,079
This also becomes a challenge as the code base grows and officials become more complex.

00:02:36,079 --> 00:02:41,639
Because of that we have been thinking about different tools that can improve the success

00:02:41,639 --> 00:02:44,130
of our team.

00:02:44,130 --> 00:02:46,440
So why Sorbet?

00:02:46,440 --> 00:02:48,470
Let's look at the code example below.

00:02:48,470 --> 00:02:54,320
I define a levitate function that takes caster as an argument following with three calls

00:02:54,320 --> 00:02:56,310
to the functions.

00:02:56,310 --> 00:03:00,320
Only one of them is valid but Ruby does not complain at all.

00:03:00,320 --> 00:03:04,010
The errors only reveal where the code is run.

00:03:04,010 --> 00:03:08,690
Wouldn't it be great if there is a way to detect the bugs automatically?

00:03:08,690 --> 00:03:16,320
It will help us find errors early, reduce time testing code, and increase time focusing

00:03:16,320 --> 00:03:18,200
on building features.

00:03:18,200 --> 00:03:21,760
And Static type checkers do exactly that.

00:03:21,760 --> 00:03:27,669
It's not a new idea to use static type checking in a dynamic language.

00:03:27,669 --> 00:03:33,880
There are successful tools widely used for other languages such as flow in typescript

00:03:33,880 --> 00:03:38,190
for Java scripts of higher in my PI for Python.

00:03:38,190 --> 00:03:45,450
Part of the most exciting thing last year, for me, was the release of Sorbet the type

00:03:45,450 --> 00:03:48,350
checker open sourced by Stripe.

00:03:48,350 --> 00:03:55,360
Sorbet is fast and powerful it can process 100,000 lines of code per second and can be

00:03:55,360 --> 00:04:01,790
integrated with editors to perform type checking as you write code.

00:04:01,790 --> 00:04:07,230
Sorbet is designed to support gradual typing you can add type checks to this part of your

00:04:07,230 --> 00:04:13,290
codebase benefit from typing immediately and add more files as you like.

00:04:13,290 --> 00:04:16,570
It also comes with a runtime type checking component.

00:04:16,570 --> 00:04:22,979
This sets it apart from tools like flow and typescript in keeping the pipe definition

00:04:22,979 --> 00:04:26,400
correct and up-to-date with the code.

00:04:26,400 --> 00:04:28,380
And the tools is production ready.

00:04:28,380 --> 00:04:34,040
It has been battle tested in productions with hundreds of engineers at Stripe for the last

00:04:34,040 --> 00:04:36,510
two years.

00:04:36,510 --> 00:04:44,210
Sorbet can eliminate common errors like typos, numerical errors and argument errors.

00:04:44,210 --> 00:04:50,500
The type information also makes code a lot easier to understand and make it faster to

00:04:50,500 --> 00:04:54,480
onboard new engineers.

00:04:54,480 --> 00:05:00,020
at the carven survey relies on method signatures to do type check.

00:05:00,020 --> 00:05:07,010
A signature defines the type of the parameters and the returning value of a method.

00:05:07,010 --> 00:05:15,330
Survey uses these informations to enforce that the method is used correctly.

00:05:15,330 --> 00:05:17,160
And it really works.

00:05:17,160 --> 00:05:24,930
Since we integrate the survey it has tremendous impact on our team and it was immediate.

00:05:24,930 --> 00:05:30,580
Below is an example bug the survey found in our code.

00:05:30,580 --> 00:05:34,960
Someone tried to call academic year on the side objects.

00:05:34,960 --> 00:05:37,720
However this method didn't exist.

00:05:37,720 --> 00:05:42,140
The current method name was current academic year.

00:05:42,140 --> 00:05:48,020
This bug was subtle and hard to spot by writing a revue code.

00:05:48,020 --> 00:05:51,150
But Sorbet caught it.

00:05:51,150 --> 00:05:57,390
As we expand Sorbet usage user found more bugs in our code that we didn't know.

00:05:57,390 --> 00:06:03,620
Like they were dead code accessing classes of functions that were already removed.

00:06:03,620 --> 00:06:11,200
How they were bugs caused by incomplete rename of a function bug like these lower the quality

00:06:11,200 --> 00:06:16,250
of the code and slow down engineers working on those products area.

00:06:16,250 --> 00:06:21,640
However when we started out things was not easy.

00:06:21,640 --> 00:06:28,990
Sorbet could understand Ruby syntax and came with supports for car Ruby API like array,

00:06:28,990 --> 00:06:30,690
string, hash.

00:06:30,690 --> 00:06:34,950
But it offer very little support for rails out of the box.

00:06:34,950 --> 00:06:39,600
Rails code is not easy to type check and let me explain why.

00:06:39,600 --> 00:06:44,600
First is a big framework with many functionalities.

00:06:44,600 --> 00:06:52,060
Sure that is one of the challenge, but more than that rails relies heavily on metaprogramming

00:06:52,060 --> 00:06:55,610
to offer the core functionalities.

00:06:55,610 --> 00:06:57,880
What is meta programming?

00:06:57,880 --> 00:07:05,590
It is a way to program where you carry methods dynamically using code instead of writing

00:07:05,590 --> 00:07:08,710
them by hand.

00:07:08,710 --> 00:07:11,910
For example, I have an Oracle class here.

00:07:11,910 --> 00:07:16,120
I'm not writing the answer method but it exists.

00:07:16,120 --> 00:07:22,550
It is created by calling make magic, if make magic is not called answer is not created

00:07:22,550 --> 00:07:26,440
and the last line reproduce an error.

00:07:26,440 --> 00:07:34,040
Now you can already see here how this can be a challenge for a static type checker.

00:07:34,040 --> 00:07:38,680
Sometimes it doesn't even know that a method exists, let alone knowing what the method

00:07:38,680 --> 00:07:43,090
does.

00:07:43,090 --> 00:07:45,390
Let's look at an example in rails.

00:07:45,390 --> 00:07:51,069
Here I have wizard, a typical rails model.

00:07:51,069 --> 00:07:57,650
It has an object relational mapping definition and a database backing it up.

00:07:57,650 --> 00:08:06,340
With this much code rails is able to create a fully flash model with many functionalities.

00:08:06,340 --> 00:08:09,940
You can query the model for records in the database.

00:08:09,940 --> 00:08:15,470
You can access the attributes of the database table.

00:08:15,470 --> 00:08:21,020
You can also access the associations to retrieve data from other tables.

00:08:21,020 --> 00:08:26,760
All these methods are generated dynamically.

00:08:26,760 --> 00:08:31,800
But how does Sorbet see the code?

00:08:31,800 --> 00:08:38,680
With some custom method signature so they can see that Harry is a wizard.

00:08:38,680 --> 00:08:42,200
However he doesn't know much about attributes.

00:08:42,200 --> 00:08:48,690
To Sorbet name and house are untyped.

00:08:48,690 --> 00:08:53,310
Same with the association's they are untyped as well.

00:08:53,310 --> 00:08:57,089
But these are quite typical day to day rails code.

00:08:57,089 --> 00:09:02,760
It is not very useful to type-check your code when nothing is type is it?

00:09:02,760 --> 00:09:08,540
If only so they would know the type of these rails method.

00:09:08,540 --> 00:09:14,210
If only he was this work and me we make it happen.

00:09:14,210 --> 00:09:21,750
Our team at CZI created a gem called Sorbet Rails to bridge the gap between Sorbet and

00:09:21,750 --> 00:09:22,750
Rails.

00:09:22,750 --> 00:09:30,960
It is designed to be a one-stop shop that makes Sorbet work with Rails seamlessly.

00:09:30,960 --> 00:09:37,310
It has a static component that generate method signatures for dynamic methods created by

00:09:37,310 --> 00:09:39,250
Rails.

00:09:39,250 --> 00:09:42,940
And additional runtime features that also help type-checking.

00:09:42,940 --> 00:09:51,620
Let me take a moment to talk about RBI files, because this is a important concept.

00:09:51,620 --> 00:10:00,880
RBI files are like C++ header files, they only contains method definition and signatures

00:10:00,880 --> 00:10:02,780
but no implementation.

00:10:02,780 --> 00:10:09,500
They provide additional information that Sorbet doesn't get from passing the code.

00:10:09,500 --> 00:10:13,310
They are perfect for dynamic methods.

00:10:13,310 --> 00:10:19,400
So Sorbet approaches let's generate the RBI files for dynamic methods so that subway can

00:10:19,400 --> 00:10:22,230
know what they do.

00:10:22,230 --> 00:10:27,870
We weren't the first team that was dealing with meta programming an alternative were

00:10:27,870 --> 00:10:30,370
meta programming plugins.

00:10:30,370 --> 00:10:36,920
The plugins ran alongside with Sorbet when he passed the code and let it know when dynamic

00:10:36,920 --> 00:10:39,160
methods may be created.

00:10:39,160 --> 00:10:43,940
It's best explained with an example.

00:10:43,940 --> 00:10:49,890
Given the article class I define earlier you can write a plug-in that detects the make

00:10:49,890 --> 00:10:57,270
magic cause and generate signature corresponding to the answer method he would produce.

00:10:57,270 --> 00:11:04,700
And Sorbet would know that our method exists in the Oracle class.

00:11:04,700 --> 00:11:10,220
Metaprogramming plugins have the benefits of being evergreen they around with every

00:11:10,220 --> 00:11:15,870
type checking call so they are high on the latest versions of the code.

00:11:15,870 --> 00:11:22,320
However for that same reason it slows down type-checking greatly and thus it cannot be

00:11:22,320 --> 00:11:30,160
used to integrate with the editor where type checking will happen with every keystroke.

00:11:30,160 --> 00:11:36,220
It also can be difficult to write the plugins because it only has static informations about

00:11:36,220 --> 00:11:40,480
the code being passed, compared to the plugins.

00:11:40,480 --> 00:11:48,050
So various approach, which is generating RBI ahead of time, can be less accurate.

00:11:48,050 --> 00:11:55,720
If the cursor change and you haven't rerun the generation scripts it may be out a bit.

00:11:55,720 --> 00:12:02,180
However, because we have meta signatures at hand it is faster to type check even when

00:12:02,180 --> 00:12:05,740
it is in the editor.

00:12:05,740 --> 00:12:12,370
Also it is much easier to generate signatures when you have access to a fully flesh ORS

00:12:12,370 --> 00:12:15,850
runtime environment.

00:12:15,850 --> 00:12:23,589
Because of the advantages of this approach it is now the recommended approach to be able

00:12:23,589 --> 00:12:25,009
metaprogramming.

00:12:25,009 --> 00:12:30,580
Let's see how this approach works with the example we had earlier.

00:12:30,580 --> 00:12:36,600
Using the models configuration so rails can generate signature for name in house.

00:12:36,600 --> 00:12:42,459
Note that other house integrate column the model method we can ...... because this is

00:12:42,459 --> 00:12:45,620
defined as an enum in the model.

00:12:45,620 --> 00:12:51,300
So sometimes generating signatures is not as straightforward as it seems.

00:12:51,300 --> 00:12:56,279
Anyway with these signatures Sorbet starts to understand the code.

00:12:56,279 --> 00:13:01,480
It now knows the name and house returns string.

00:13:01,480 --> 00:13:07,520
Similarly we generate the signatures if we see the written type of the association's

00:13:07,520 --> 00:13:08,730
as well.

00:13:08,730 --> 00:13:15,120
Sorbet Rails can generate signatures for whole lot more methods in a model.

00:13:15,120 --> 00:13:21,120
Finally because rails rely on meta programming to generate methods we can also mimic it's

00:13:21,120 --> 00:13:24,459
process to generate the signatures.

00:13:24,459 --> 00:13:30,490
It is a very suitable way to write signatures especially if you have foreign models like

00:13:30,490 --> 00:13:32,630
we do.

00:13:32,630 --> 00:13:36,380
Still signature generations can be tricky.

00:13:36,380 --> 00:13:39,920
For each type of method we need a different strategy.

00:13:39,920 --> 00:13:44,700
I'm going to explain a few strategies implemented in Sorbet Rails.

00:13:44,700 --> 00:13:48,830
These are quite fun technical challenges.

00:13:48,830 --> 00:13:53,040
First our database attributes an association methods.

00:13:53,040 --> 00:13:58,500
We rely on rails reflections to share it their signatures.

00:13:58,500 --> 00:14:00,770
What is reflection in short?

00:14:00,770 --> 00:14:05,050
It is a mean for a process to see and change your own structure.

00:14:05,050 --> 00:14:08,360
Like seeing the dynamic methods.

00:14:08,360 --> 00:14:12,920
Rails comes with a lot of reflection classes like Association reflections.

00:14:12,920 --> 00:14:14,630
They are great.

00:14:14,630 --> 00:14:18,110
They have a lot of informations about the dynamic methods.

00:14:18,110 --> 00:14:21,000
When they exist our job is easy.

00:14:21,000 --> 00:14:26,490
We can take the informations that provide to generate corresponding method signatures.

00:14:26,490 --> 00:14:34,029
Except when there are null and we have to rely on other sources such as rails documentation.

00:14:34,029 --> 00:14:41,680
Our rails has code, sometimes we have to look up which file they'll generate a method to

00:14:41,680 --> 00:14:45,640
the text is type and signature.

00:14:45,640 --> 00:14:52,210
For enums we even overwrite our method provided by rails to collect more informations for

00:14:52,210 --> 00:14:55,090
the generation code.

00:14:55,090 --> 00:15:00,610
It gets more complicated with gems and private concerns that you can add even more methods

00:15:00,610 --> 00:15:03,019
in a model.

00:15:03,019 --> 00:15:07,320
To solve that Sorbet Rails provides a configurable generator.

00:15:07,320 --> 00:15:13,649
Each plug-in can generate signatures and the generator will aggregate them to produce a

00:15:13,649 --> 00:15:16,470
final RBI file.

00:15:16,470 --> 00:15:20,220
You can add or remove plugins as you want.

00:15:20,220 --> 00:15:25,720
Even the cogeneration logic I described earlier are also implemented as plugin.

00:15:25,720 --> 00:15:30,740
Gem plugins allow the community to share cherish and code for public gems.

00:15:30,740 --> 00:15:37,780
Currently we have plugins for a handful of gems such as shrine and elasticsearch.

00:15:37,780 --> 00:15:45,089
I hope that as the community developed we'll see more and more gem plugins being shared.

00:15:45,089 --> 00:15:51,860
Lastly you can write custom plugins for your own private libraries.

00:15:51,860 --> 00:15:56,510
The generations and aggregation logic here is supported by Paulo gem.

00:15:56,510 --> 00:16:02,850
I recommend using it if you want to write your own generation module.

00:16:02,850 --> 00:16:04,680
I spent a lot of time talking about models.

00:16:04,680 --> 00:16:11,079
It is definitely the most complex generation module but sub-areas provides.

00:16:11,079 --> 00:16:17,110
We also support generation matters for other risk objects listed here.

00:16:17,110 --> 00:16:23,740
Among these objects mirrors and jobs pose an interesting challenge.

00:16:23,740 --> 00:16:31,540
They have class level methods that are generated based on custom user-defined instant methods.

00:16:31,540 --> 00:16:37,730
In this example Mailer class when we define an instant method notify subscriber rows,

00:16:37,730 --> 00:16:41,010
we add a corresponding class level method.

00:16:41,010 --> 00:16:47,230
And so very generous signature for this method as well.

00:16:47,230 --> 00:16:53,990
When there is a custom signature for the instance method Sorbet Rails used survey itself to

00:16:53,990 --> 00:16:59,470
reflect on the signature and generates a better signature for the class method.

00:16:59,470 --> 00:17:07,510
On top of the RBI generation logic there are a few runtime Fisher's in Sorbet Rails to

00:17:07,510 --> 00:17:11,649
make typing easier.

00:17:11,649 --> 00:17:17,069
Here I will only talk about Typed Params because they show how your code can become safer and

00:17:17,069 --> 00:17:20,610
easier to understand with type.

00:17:20,610 --> 00:17:26,970
Normally params in controller actions are string even if it is an integer or greater

00:17:26,970 --> 00:17:32,220
value the value the controller receives our stream.

00:17:32,220 --> 00:17:39,179
However in our code we can define the structure of the params with corresponding types for

00:17:39,179 --> 00:17:40,830
its component.

00:17:40,830 --> 00:17:46,850
Using type params we can coerce the normal parents into this structure and let the rest

00:17:46,850 --> 00:17:49,390
of the code use type values.

00:17:49,390 --> 00:17:54,730
The structure also acts as documentation for the controller actions.

00:17:54,730 --> 00:18:01,799
Now it is super easy to know which parameters you need to send to the actions from the client

00:18:01,799 --> 00:18:04,600
side.

00:18:04,600 --> 00:18:09,960
So we have solved many technical challenges with using Sorbet in a rails app.

00:18:09,960 --> 00:18:13,369
But this is only when the fun begins.

00:18:13,369 --> 00:18:18,509
Adopting type checking means that you asked a team to change the work flow to make room

00:18:18,509 --> 00:18:20,580
for type checking.

00:18:20,580 --> 00:18:26,019
In this section I will share some lessons we learn from driving adoption in our team

00:18:26,019 --> 00:18:32,299
and how you can apply them to make your adoption successful.

00:18:32,299 --> 00:18:37,120
First let's talk about the metrics to measure adoption progress.

00:18:37,120 --> 00:18:44,230
Sorbet offers two metrics to check adoption, fire level metric and course eye level metric.

00:18:44,230 --> 00:18:49,739
There are five different type checking levels you can say it's polish five.

00:18:49,739 --> 00:18:57,710
I wish Flint type shoe in strict because they are the primary levels you will focus on.

00:18:57,710 --> 00:19:03,549
Type suffice will be checked but you don't have to write meta signatures in them.

00:19:03,549 --> 00:19:08,490
This is the ideal level to start with.

00:19:08,490 --> 00:19:12,809
Type check requirements are higher at this level.

00:19:12,809 --> 00:19:18,710
You are required to write signatures and types for instance variable.

00:19:18,710 --> 00:19:25,409
This is the best level to inform because the next level is too limiting and only good for

00:19:25,409 --> 00:19:29,539
simplifies or RBI files.

00:19:29,539 --> 00:19:34,200
So Sorbet can tell you the number of files at each level.

00:19:34,200 --> 00:19:40,940
Within the type files survey checks the number of method calls that are type checked.

00:19:40,940 --> 00:19:45,600
Any method call on untied object is counted as untied.

00:19:45,600 --> 00:19:51,639
This number matches more closely to the notion of type check coverage.

00:19:51,639 --> 00:19:57,750
Both metrics provide insight to where to focus your adoption efforts.

00:19:57,750 --> 00:20:03,340
Usually you want to drive up the number of files type checks then focus on the number

00:20:03,340 --> 00:20:07,369
of call sites in those files.

00:20:07,369 --> 00:20:13,009
You can also create your own matrix to define what adoption success means to you.

00:20:13,009 --> 00:20:18,289
For example we tried who are participating in type code and how much.

00:20:18,289 --> 00:20:23,950
This is important because the size to us mean everyone in the team is writing and type checking

00:20:23,950 --> 00:20:25,279
their code.

00:20:25,279 --> 00:20:31,039
Currently we have over 90% of our file structure or higher.

00:20:31,039 --> 00:20:33,960
That includes our models and controllers.

00:20:33,960 --> 00:20:38,340
That's pretty high, but how about the cosine level matrix.

00:20:38,340 --> 00:20:43,779
Our percentage is currently at about 66%.

00:20:43,779 --> 00:20:49,989
The blue line shows we have seen a steady growth in the number of call size typed.

00:20:49,989 --> 00:20:55,720
Where's the number of call type I call site the red line has died at about the same level.

00:20:55,720 --> 00:21:01,350
Now there was a slight bump in the red line in the middle.

00:21:01,350 --> 00:21:05,389
That is when we made our models and controllers stucture.

00:21:05,389 --> 00:21:12,330
It significantly increase the surface area that Sorbet could type check.

00:21:12,330 --> 00:21:16,019
After that the red line has stayed the same level again.

00:21:16,019 --> 00:21:22,629
Is a very promising results, we see everyone in the team is writing tight code and drive

00:21:22,629 --> 00:21:25,190
up the matrix every day.

00:21:25,190 --> 00:21:30,519
Some sub team have even set up their own magic goal for their code.

00:21:30,519 --> 00:21:38,409
There are two principles that I think help us immensely in driving a successful adoptions.

00:21:38,409 --> 00:21:40,799
First, adopting gradually.

00:21:40,799 --> 00:21:46,909
Sorbet can be useful even when you only have part of your code base type checked.

00:21:46,909 --> 00:21:52,639
In fact I think is an on go to type check every file or every line of code.

00:21:52,639 --> 00:21:55,100
After all ruby is the dynamic language.

00:21:55,100 --> 00:21:58,700
It allows fun and creative magic to happen.

00:21:58,700 --> 00:22:02,890
So you should think about where type checking can be useful.

00:22:02,890 --> 00:22:11,989
Even in type virus is okay to use escape hatches like T and type and T and safe to bypass type

00:22:11,989 --> 00:22:13,979
check if needed.

00:22:13,979 --> 00:22:18,539
Also we found that it is easier to add types to new code.

00:22:18,539 --> 00:22:23,619
By adding type check to new code you are in line more with the team interest of building

00:22:23,619 --> 00:22:24,879
new features.

00:22:24,879 --> 00:22:28,179
So I recommend you to start them.

00:22:28,179 --> 00:22:33,519
The second principle is to not brought people from doing their work.

00:22:33,519 --> 00:22:37,830
We want everyone to find Sorbet as a tool that help them.

00:22:37,830 --> 00:22:42,269
Not another check that is in their way of getting things done.

00:22:42,269 --> 00:22:45,879
There are a few things you can do here.

00:22:45,879 --> 00:22:50,399
Learn about the challenges of type checking code early.

00:22:50,399 --> 00:22:55,409
It could be different in issue code based depending on the coding patterns and libraries

00:22:55,409 --> 00:22:56,789
your team use.

00:22:56,789 --> 00:23:03,600
Be sure to provide workarounds so that people can bypass type checkers when needed, and

00:23:03,600 --> 00:23:08,019
allow them to make mistakes when they are getting used to the tool.

00:23:08,019 --> 00:23:13,799
If they make mistake a new string for a symbol in a signature ideally it shouldn't break

00:23:13,799 --> 00:23:16,489
the fissure in production.

00:23:16,489 --> 00:23:24,100
With those principles in mind let's go through the step-by-step of driving adoptions in your

00:23:24,100 --> 00:23:25,100
team.

00:23:25,100 --> 00:23:26,590
First, setting up the gems.

00:23:26,590 --> 00:23:32,710
This step is easy, you just add the gems to your gem file, run bundle install, and follow

00:23:32,710 --> 00:23:37,220
the installation steps documented in the gems.

00:23:37,220 --> 00:23:43,450
One thing to note here is that you should disable Sorbet's random check in production.

00:23:43,450 --> 00:23:48,869
The random check acts as assertions to enforce the current needs of the inputs and output

00:23:48,869 --> 00:23:49,869
types.

00:23:49,869 --> 00:23:53,369
But if we were bought the running code you violated.

00:23:53,369 --> 00:23:59,759
At the beginning is this best to run it inspect only so that it does not affect your production

00:23:59,759 --> 00:24:01,840
app.

00:24:01,840 --> 00:24:07,179
Once you've done with setting up check out the adoption metric provided by Sorbet.

00:24:07,179 --> 00:24:11,330
I think you'd be surprised.

00:24:11,330 --> 00:24:18,309
I was surprised Sorbet was able to take 80% of our files and 40% of the call sites in

00:24:18,309 --> 00:24:19,360
them.

00:24:19,360 --> 00:24:25,249
This is because Sorbet knows all the cores will be logic and Sorbet rails enable it to

00:24:25,249 --> 00:24:30,169
understand a lot of the rails logic.

00:24:30,169 --> 00:24:33,870
Next let's build up a good foundation.

00:24:33,870 --> 00:24:37,499
Here you want to set up checking for your adoption matrix.

00:24:37,499 --> 00:24:43,159
Those later we reveal to you where you should focus on.

00:24:43,159 --> 00:24:50,109
It is also a good place to investigate how to integrate Sorbet with the Teams development

00:24:50,109 --> 00:24:54,580
tools like git, CI, or editor.

00:24:54,580 --> 00:24:56,809
However this one is awesome yet.

00:24:56,809 --> 00:25:04,929
For our team we run Sorbet check in our CI with a review just to collect logs.

00:25:04,929 --> 00:25:08,720
Also I must say that editor integration is a Game Changer.

00:25:08,720 --> 00:25:13,429
It will change how you write code.

00:25:13,429 --> 00:25:19,240
The most important effort here will be understanding type checking and figure out which code to

00:25:19,240 --> 00:25:20,899
type.

00:25:20,899 --> 00:25:27,109
You should know the type of code people writes most often and how to make them type chunks.

00:25:27,109 --> 00:25:33,340
I have answers for most of the challenges so that you can guide and unblock people in

00:25:33,340 --> 00:25:35,399
the next phase.

00:25:35,399 --> 00:25:41,049
You don't have to do this all in one day take it slow and build a strong foundation.

00:25:41,049 --> 00:25:44,669
It is critical for the success of the next phase.

00:25:44,669 --> 00:25:51,889
After all, adoption is supposed to be a gradual process.

00:25:51,889 --> 00:25:56,830
Once you got a strong foundation it is time to dry up the adoption matrix and get people

00:25:56,830 --> 00:25:58,759
to use the tools.

00:25:58,759 --> 00:26:05,049
In terms of adoption matrix you want to make your type check come true.

00:26:05,049 --> 00:26:10,929
Usually this is easy because you don't have to write any method signatures yet.

00:26:10,929 --> 00:26:16,950
First we focus on our models controllers and data mutation classes.

00:26:16,950 --> 00:26:21,820
While typing the files I also find a lot of existing bugs.

00:26:21,820 --> 00:26:27,470
I will share with the team to get people excited about Sorbet.

00:26:27,470 --> 00:26:34,419
We also had workshops and recruits early adopters to participate in typing.

00:26:34,419 --> 00:26:36,570
People really enjoyed Sorbet.

00:26:36,570 --> 00:26:42,529
I see in the desert we prepare for a workshop that you can see on the photo.

00:26:42,529 --> 00:26:51,029
After then you may think about guiding people into doing type checking.

00:26:51,029 --> 00:26:56,029
One valuable tool I found here is robocop sorbet.

00:26:56,029 --> 00:27:01,999
On the right side I had a cop that enforced that whenever people add new files, the files

00:27:01,999 --> 00:27:08,309
need to be tagged to a Haggar you should also turn on return check in development and turn

00:27:08,309 --> 00:27:14,419
on git integration this should run a check automatically when people push updates to

00:27:14,419 --> 00:27:16,200
remote branches.

00:27:16,200 --> 00:27:22,769
Does a reminder here to implement escape hatches so that people can bypass the checks you've

00:27:22,769 --> 00:27:25,979
needed.

00:27:25,979 --> 00:27:32,760
On the people site I find it immensely useful to celebrate adoption progress and early adopters

00:27:32,760 --> 00:27:33,760
frequently.

00:27:33,760 --> 00:27:41,269
Just do what you came to make people excited about the effort they are putting in.

00:27:41,269 --> 00:27:47,059
The next phase the current phase we are in, is when type-checking becomes the norm.

00:27:47,059 --> 00:27:54,019
When you enjoy logs it's agreed that most people have gotten used to do type checking.

00:27:54,019 --> 00:27:56,320
You can up the adoption guidance.

00:27:56,320 --> 00:28:02,820
For example you may require that new files attached tricks and new method have signature.

00:28:02,820 --> 00:28:08,070
Again I find Robocop sorbet useful here.

00:28:08,070 --> 00:28:14,690
For runtime error is time to direct them to responsible team so that they own them.

00:28:14,690 --> 00:28:18,479
Check out the screenshot here to see our setup.

00:28:18,479 --> 00:28:23,279
Runtime errors are reported without breaking production app.

00:28:23,279 --> 00:28:28,139
This is great, we also think more about adding types to old code.

00:28:28,139 --> 00:28:34,889
One practice I find very effective here is getting a genius, new engineers, junior engineers

00:28:34,889 --> 00:28:37,940
to type-check part of the code in the sub team.

00:28:37,940 --> 00:28:44,309
This helps them understand the code they will work on and helps the team the more code type.

00:28:44,309 --> 00:28:50,140
In fact this is currently our favorite way to onboard new engineers.

00:28:50,140 --> 00:28:53,539
I want to acknowledge that the tools are not perfect yet.

00:28:53,539 --> 00:28:59,000
Sorebet and Sorbet-Rails are still measuring and sometimes you may run into problems.

00:28:59,000 --> 00:29:05,690
For Sorbet their syntax not very well supported yet like shape or block binding.

00:29:05,690 --> 00:29:08,970
However the team are actively developing the tools.

00:29:08,970 --> 00:29:15,529
I'm excited that they would be releasing official support for vs codes very soon.

00:29:15,529 --> 00:29:18,649
Sorebet-Rails is also being admitted frequently.

00:29:18,649 --> 00:29:23,230
But there's two things we can do to make typing easier.

00:29:23,230 --> 00:29:28,570
So make sure you have brief survey and survey rows frequently to get the latest feature.

00:29:28,570 --> 00:29:35,419
CZI is not the only team trying to use Sorbet in Rails.

00:29:35,419 --> 00:29:40,129
Here are a few companies that I know of that are using Sorbet as well.

00:29:40,129 --> 00:29:45,980
There are big companies with thousand employees like Shopify, and there are so small startups

00:29:45,980 --> 00:29:47,719
with just a few engineers.

00:29:47,719 --> 00:29:51,389
All of them are finding benefits when using Sorbet.

00:29:51,389 --> 00:29:58,789
I hope this serve as an inspiration for you to give Sorbet and Sorbet-Rails a try.

00:29:58,789 --> 00:30:04,989
Just follow the first step that set up the chain, see if Sorbet can find any bugs in

00:30:04,989 --> 00:30:07,499
your code base.

00:30:07,499 --> 00:30:15,830
You also welcome to join the slack community, provide feedback, and contribute to the gem.

00:30:15,830 --> 00:30:19,799
Before I stop I would like to thank CZI engineers and leadership.

00:30:19,799 --> 00:30:24,710
The continuous support has helped us achieving a successful adoptions.

00:30:24,710 --> 00:30:30,009
Thanks everyone in the Sorbet team for building a wonderful tool.

00:30:30,009 --> 00:30:34,559
It has provided us so much value and changed how I write Ruby code.

00:30:34,559 --> 00:30:38,229
Last but not least I would like to thank Sorebet-Rails contributors.

00:30:38,229 --> 00:30:44,309
They would thank the contributors very much by a ...... commit to the report.

00:30:44,309 --> 00:30:49,460
I'm very grateful for your contributions.

00:30:49,460 --> 00:30:51,369
And thank you for attending the talk.

00:30:51,369 --> 00:30:57,679
Did you have any questions, feel free to reach out to me through github or Sorbet Slack.

00:30:57,679 --> 00:31:00,480

YouTube URL: https://www.youtube.com/watch?v=APkKh40CF-8


