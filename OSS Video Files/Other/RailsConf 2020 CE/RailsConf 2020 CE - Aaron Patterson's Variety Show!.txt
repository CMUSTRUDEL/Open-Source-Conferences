Title: RailsConf 2020 CE - Aaron Patterson's Variety Show!
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Aaron Patterson's Variety Show!

I will talk about a variety of things related to puns, Rails, and puns on Rails

__________

Aaron is on the Ruby core team, the Rails core team, and the team that takes care of his cat, Gorby puff.  During the day he works for a small technology company.  Someday he will find the perfect safety gear to wear while extreme programming.
Captions: 
	00:00:09,110 --> 00:00:16,800
whoo hello

00:00:14,850 --> 00:00:20,530
happy Mon

00:00:16,800 --> 00:00:20,530
[Music]

00:00:23,550 --> 00:00:27,950
god this is a recording and I'm nervous

00:00:28,280 --> 00:00:32,940
hi everyone and welcome to Aaron's

00:00:30,780 --> 00:00:35,370
variety hour I'm not sure if this thing

00:00:32,940 --> 00:00:37,739
is actually gonna go an hour but I will

00:00:35,370 --> 00:00:40,680
do my best to make it there so that I

00:00:37,739 --> 00:00:42,989
can live up to the name of variety hour

00:00:40,680 --> 00:00:44,340
and as I said it's a variety hour so

00:00:42,989 --> 00:00:48,030
we're gonna talk about a variety of

00:00:44,340 --> 00:00:50,100
things I'm extremely honored this year

00:00:48,030 --> 00:00:52,860
because this is the very first time I've

00:00:50,100 --> 00:00:56,130
been able to do the opening keynote at

00:00:52,860 --> 00:00:59,040
railsconf every other year I have to I

00:00:56,130 --> 00:01:00,750
always give the the final keynote of the

00:00:59,040 --> 00:01:02,190
conference and this is the very first

00:01:00,750 --> 00:01:05,550
time I've been able to give the opening

00:01:02,190 --> 00:01:07,590
keynote at railsconf though I do think

00:01:05,550 --> 00:01:10,320
it is kind of weird that if you go to

00:01:07,590 --> 00:01:14,040
the website and scroll down you'll see

00:01:10,320 --> 00:01:16,290
that I am I'm very last on the webpage

00:01:14,040 --> 00:01:18,630
now I'm sure that this is just an

00:01:16,290 --> 00:01:21,869
oversight like a small oversight by the

00:01:18,630 --> 00:01:23,550
organising committee but you know I'm

00:01:21,869 --> 00:01:26,190
sure we can get this like cleared up

00:01:23,550 --> 00:01:31,399
later but it's really great to be the

00:01:26,190 --> 00:01:33,630
very first opening presentation now

00:01:31,399 --> 00:01:35,670
David usually does the opening keynote

00:01:33,630 --> 00:01:37,740
but since it's my turn this year I

00:01:35,670 --> 00:01:39,380
thought I should change my headshot to

00:01:37,740 --> 00:01:42,149
something a little bit more appropriate

00:01:39,380 --> 00:01:44,520
so I took a new headshot photo and this

00:01:42,149 --> 00:01:47,340
is this is what I am going to start

00:01:44,520 --> 00:01:51,929
using from now on when I give talks of

00:01:47,340 --> 00:01:53,490
places the other thing is that since I

00:01:51,929 --> 00:01:55,649
won't be able to see David's

00:01:53,490 --> 00:01:57,660
presentation ahead of my presentation

00:01:55,649 --> 00:01:58,229
and that's because and I can't stress

00:01:57,660 --> 00:02:01,979
this enough

00:01:58,229 --> 00:02:03,899
I am the opening keynote this year since

00:02:01,979 --> 00:02:06,869
I won't be able to see his talk since

00:02:03,899 --> 00:02:09,450
I'm opening I won't be able to make any

00:02:06,869 --> 00:02:11,009
jokes about it so I've decided that this

00:02:09,450 --> 00:02:13,560
year what I'm gonna do is try to guess

00:02:11,009 --> 00:02:16,980
the things that he'll say and then see

00:02:13,560 --> 00:02:19,020
if I can make some jokes in advance so

00:02:16,980 --> 00:02:21,840
the the first thing I'm pretty sure he's

00:02:19,020 --> 00:02:23,730
gonna talk about coming in 2020

00:02:21,840 --> 00:02:25,370
I heard that base camp is going to be

00:02:23,730 --> 00:02:28,680
starting a new email service called

00:02:25,370 --> 00:02:30,840
Hakam and I'm really excited about this

00:02:28,680 --> 00:02:33,780
but I guess from what I understand they

00:02:30,840 --> 00:02:36,110
plan to monetize the service by charging

00:02:33,780 --> 00:02:38,000
money for email and

00:02:36,110 --> 00:02:39,980
I think that's really great but I don't

00:02:38,000 --> 00:02:40,340
understand why anyone would pay money

00:02:39,980 --> 00:02:43,670
for

00:02:40,340 --> 00:02:47,240
email people send me email all the time

00:02:43,670 --> 00:02:48,770
just constantly and I I don't pay for

00:02:47,240 --> 00:02:50,510
any of it

00:02:48,770 --> 00:02:55,540
so I'm not sure why people would pay for

00:02:50,510 --> 00:02:58,220
that but I wish him best of luck

00:02:55,540 --> 00:03:01,280
the other thing I'm pretty sure is that

00:02:58,220 --> 00:03:03,200
most folks are doing a lot more remote

00:03:01,280 --> 00:03:06,290
working these days and I think that's

00:03:03,200 --> 00:03:07,760
really great and I know that there's a

00:03:06,290 --> 00:03:11,600
lot of people out there who were new to

00:03:07,760 --> 00:03:14,180
doing remote work and I'm also really

00:03:11,600 --> 00:03:16,070
happy that David and Jason decided to

00:03:14,180 --> 00:03:18,140
release this book at such a steep

00:03:16,070 --> 00:03:20,239
discount they wrote a book about remote

00:03:18,140 --> 00:03:22,940
working I haven't actually read the book

00:03:20,239 --> 00:03:25,070
yet but I'm going to I really plan on it

00:03:22,940 --> 00:03:27,140
I ordered a copy I'm gonna read about

00:03:25,070 --> 00:03:29,239
this and the reason I want to read is

00:03:27,140 --> 00:03:31,520
because III too would really like to

00:03:29,239 --> 00:03:34,310
work from home I mean I would really

00:03:31,520 --> 00:03:39,709
like to work from David's home it looks

00:03:34,310 --> 00:03:41,900
very nice now as you've no doubt noticed

00:03:39,709 --> 00:03:44,269
that railsconf is not in Portland this

00:03:41,900 --> 00:03:46,100
year due to the outbreak of Cove in

00:03:44,269 --> 00:03:50,510
nineteen in the United States and I'm

00:03:46,100 --> 00:03:52,730
pretty sad about that I love going to

00:03:50,510 --> 00:03:54,799
Portland it's this is really too bad I

00:03:52,730 --> 00:03:57,410
was looking forward to seeing everybody

00:03:54,799 --> 00:03:59,120
in Portland this year and it's so close

00:03:57,410 --> 00:04:01,190
to Seattle so I can just drive and I

00:03:59,120 --> 00:04:05,660
don't have to like you know fly down

00:04:01,190 --> 00:04:09,860
there so I really like that the other

00:04:05,660 --> 00:04:11,930
thing is that I think that I love that

00:04:09,860 --> 00:04:14,030
show Portlandia so I'm so happy if I

00:04:11,930 --> 00:04:16,250
could visit Portland which the show is

00:04:14,030 --> 00:04:17,690
about but honestly one of the reasons I

00:04:16,250 --> 00:04:21,350
think that the show is really funny is

00:04:17,690 --> 00:04:23,960
because Seattle where I live is so

00:04:21,350 --> 00:04:26,180
similar to Portland and the show could

00:04:23,960 --> 00:04:30,830
really be about either plays but I guess

00:04:26,180 --> 00:04:32,840
Portland got stuck with it so anyway

00:04:30,830 --> 00:04:35,300
this year as I was saying we're doing

00:04:32,840 --> 00:04:37,430
the conference remotely this year and

00:04:35,300 --> 00:04:38,900
doing a pre-recorded talk is like a

00:04:37,430 --> 00:04:42,620
really difficult thing for me to do I

00:04:38,900 --> 00:04:44,510
usually don't do pre-recorded talks it's

00:04:42,620 --> 00:04:46,340
really important for me to get feedback

00:04:44,510 --> 00:04:47,270
from the audience I really need feedback

00:04:46,340 --> 00:04:49,580
from the audience when

00:04:47,270 --> 00:04:51,800
a presentation that way I can adjust my

00:04:49,580 --> 00:04:54,680
presentation if I'm going too long or

00:04:51,800 --> 00:04:56,870
too short and also I get extremely

00:04:54,680 --> 00:04:58,790
nervous when I'm giving a talk and the

00:04:56,870 --> 00:05:02,020
feedback from the crowd like helps me

00:04:58,790 --> 00:05:04,100
actually calm down when I'm on stage and

00:05:02,020 --> 00:05:08,390
unfortunately like since I'm pre

00:05:04,100 --> 00:05:09,980
recording this I feel really nervous but

00:05:08,390 --> 00:05:12,760
I decided I would try to deal with this

00:05:09,980 --> 00:05:17,170
by attempting to give a presentation

00:05:12,760 --> 00:05:17,170
ahead of time and record it in zoom

00:05:22,860 --> 00:05:36,069
all right you started already you're

00:05:25,719 --> 00:05:39,520
muted sorry can you hear me now you hear

00:05:36,069 --> 00:05:40,659
me all right sorry about that let's try

00:05:39,520 --> 00:05:43,930
again

00:05:40,659 --> 00:05:46,719
hi everyone welcome to Aaron's variety

00:05:43,930 --> 00:05:48,639
hour I'm really happy to be here Aaron I

00:05:46,719 --> 00:05:51,759
think you give a color palette on your

00:05:48,639 --> 00:05:52,360
screen still oh really I don't I don't

00:05:51,759 --> 00:05:56,139
see anything

00:05:52,360 --> 00:06:01,029
is there it's like one that's okay one

00:05:56,139 --> 00:06:04,169
sec one sec that is that okay oh yeah

00:06:01,029 --> 00:06:08,319
thank you okay okay let's do this again

00:06:04,169 --> 00:06:10,870
okay hi everybody welcome to Aaron's

00:06:08,319 --> 00:06:17,319
variety hour hopefully this will be an

00:06:10,870 --> 00:06:19,749
hour long I'm not I'm not sure can you

00:06:17,319 --> 00:06:23,860
all mute if you're if you're not on like

00:06:19,749 --> 00:06:27,009
can you somebody's getting a phone call

00:06:23,860 --> 00:06:27,520
can you mute please all right okay let

00:06:27,009 --> 00:06:29,800
me start over

00:06:27,520 --> 00:06:32,979
welcome to Aaron's variety hour I am so

00:06:29,800 --> 00:06:41,740
happy to be here hopefully this will be

00:06:32,979 --> 00:06:45,699
an hour I've been trying to start okay I

00:06:41,740 --> 00:06:46,449
will I will start oh sorry sorry it's

00:06:45,699 --> 00:06:50,770
okay it's okay

00:06:46,449 --> 00:06:55,620
all right everyone welcome there is

00:06:50,770 --> 00:06:55,620
variety oh I'm sorry wrong meeting

00:06:56,080 --> 00:07:08,660
okay hi everyone welcome to variety hour

00:07:01,850 --> 00:07:10,220
this may be an hour but I'm not sure now

00:07:08,660 --> 00:07:11,450
when that didn't work I decided that I

00:07:10,220 --> 00:07:12,020
would try to give the talk in front of

00:07:11,450 --> 00:07:15,980
my cats

00:07:12,020 --> 00:07:19,370
welcome to railsconf welcome to my very

00:07:15,980 --> 00:07:22,310
first opening keynote at railsconf come

00:07:19,370 --> 00:07:22,700
here buddy welcome to railsconf come on

00:07:22,310 --> 00:07:24,830
buddy

00:07:22,700 --> 00:07:26,270
now when that didn't work I decided that

00:07:24,830 --> 00:07:28,930
I would try to give a presentation on

00:07:26,270 --> 00:07:28,930
Animal Crossing

00:07:39,410 --> 00:07:50,470
[Applause]

00:07:57,270 --> 00:08:02,050
now since it was way too hard to give a

00:08:00,460 --> 00:08:03,759
presentation on animal crossing I

00:08:02,050 --> 00:08:05,469
decided to just do the format that I'm

00:08:03,759 --> 00:08:07,569
doing right now which I guess is of

00:08:05,469 --> 00:08:09,520
late-night TV show host

00:08:07,569 --> 00:08:11,169
and I will just start adding laughs

00:08:09,520 --> 00:08:15,999
crash rather than make myself feel

00:08:11,169 --> 00:08:17,499
better now before I get into the stuff

00:08:15,999 --> 00:08:19,900
that I actually want to talk about for

00:08:17,499 --> 00:08:25,300
this conference I want to tell you all

00:08:19,900 --> 00:08:29,259
about my my productivity strategy my

00:08:25,300 --> 00:08:32,229
productivity strategy is procrastination

00:08:29,259 --> 00:08:34,479
so in order for me to focus on building

00:08:32,229 --> 00:08:37,120
a presentation I need to put it off

00:08:34,479 --> 00:08:40,510
until I absolutely can't put it off

00:08:37,120 --> 00:08:43,089
anymore and the reason I do this is

00:08:40,510 --> 00:08:44,890
because it gives me a hyper focus I have

00:08:43,089 --> 00:08:47,079
to focus on the task since I'm required

00:08:44,890 --> 00:08:49,149
to focus on it like I know that there is

00:08:47,079 --> 00:08:51,339
a particular deadline I have to be up in

00:08:49,149 --> 00:08:53,829
front of an audience this helps me

00:08:51,339 --> 00:08:55,199
really focus on preparing my

00:08:53,829 --> 00:09:00,160
presentations for people

00:08:55,199 --> 00:09:04,930
however this this strategy also comes

00:09:00,160 --> 00:09:07,329
along with a lot of extreme guilt now as

00:09:04,930 --> 00:09:09,220
I'm procrastinating and I know I should

00:09:07,329 --> 00:09:12,250
be working on my talk I know I should be

00:09:09,220 --> 00:09:13,959
making this presentation but I'm not so

00:09:12,250 --> 00:09:16,180
in order to relieve my guilt for

00:09:13,959 --> 00:09:18,220
procrastination I have to fill my time

00:09:16,180 --> 00:09:21,070
with things that I deem to either be

00:09:18,220 --> 00:09:22,540
more important than the tasks that I at

00:09:21,070 --> 00:09:24,640
hand more important than the thing that

00:09:22,540 --> 00:09:31,079
I'm doing or it has to be something

00:09:24,640 --> 00:09:33,690
that's more fun now I call this

00:09:31,079 --> 00:09:36,610
procrastination project management or

00:09:33,690 --> 00:09:38,649
ppm for short and actually I take it

00:09:36,610 --> 00:09:41,910
very very seriously in fact I

00:09:38,649 --> 00:09:44,399
meticulously plan out my procrastination

00:09:41,910 --> 00:09:47,380
these projects are actually planned

00:09:44,399 --> 00:09:49,480
procrastination projects now I had

00:09:47,380 --> 00:09:52,350
planned out I had planned on

00:09:49,480 --> 00:09:55,750
procrastinating all the way until April

00:09:52,350 --> 00:09:58,870
and then working on my presentation for

00:09:55,750 --> 00:10:01,860
all of April until railsconf came around

00:09:58,870 --> 00:10:05,160
now unfortunately we got hit with a

00:10:01,860 --> 00:10:08,130
kovat 19 and railsconf was cancer

00:10:05,160 --> 00:10:10,050
and when that happened Evan texted me

00:10:08,130 --> 00:10:11,910
and he asked me are would you be willing

00:10:10,050 --> 00:10:12,630
to record your presentation and of

00:10:11,910 --> 00:10:16,890
course I said yes

00:10:12,630 --> 00:10:19,410
so I asked him well what when is the you

00:10:16,890 --> 00:10:22,320
know I need a deadline for this because

00:10:19,410 --> 00:10:24,240
that's how I work with my I didn't tell

00:10:22,320 --> 00:10:26,400
him that this is my productivity

00:10:24,240 --> 00:10:29,430
strategy but I need to have a deadline

00:10:26,400 --> 00:10:31,050
in order for me to procrastinate and he

00:10:29,430 --> 00:10:33,270
said oh yes the dates will be the same

00:10:31,050 --> 00:10:36,030
as railsconf and I said that is great I

00:10:33,270 --> 00:10:38,400
knew internally okay the dates are the

00:10:36,030 --> 00:10:42,330
same this means that my procrastination

00:10:38,400 --> 00:10:47,820
plan is on schedule things can move like

00:10:42,330 --> 00:10:51,150
according to plan so unfortunately maybe

00:10:47,820 --> 00:10:53,700
a couple weeks later I got an email from

00:10:51,150 --> 00:10:57,180
the railsconf organizing committee

00:10:53,700 --> 00:10:58,950
saying to me oh well actually your

00:10:57,180 --> 00:11:00,570
videos are do we want you to pre-record

00:10:58,950 --> 00:11:03,510
this but your videos are due by April

00:11:00,570 --> 00:11:07,590
13th and unfortunately this is three

00:11:03,510 --> 00:11:09,660
weeks earlier than I had planned so this

00:11:07,590 --> 00:11:13,230
really really put a lot of pressure on

00:11:09,660 --> 00:11:15,510
me and I decided that part of my

00:11:13,230 --> 00:11:17,490
presentation since since now everything

00:11:15,510 --> 00:11:19,320
is pushed up so far I thought okay well

00:11:17,490 --> 00:11:21,690
part of my presentation is I'm going to

00:11:19,320 --> 00:11:24,300
give a presentation of my plan

00:11:21,690 --> 00:11:27,900
procrastination projects so before we

00:11:24,300 --> 00:11:30,510
actually dive into technical details of

00:11:27,900 --> 00:11:32,070
my presentation I'd like to show you

00:11:30,510 --> 00:11:35,310
some of the stuff that I've been doing

00:11:32,070 --> 00:11:39,690
to basically put off doing my actual

00:11:35,310 --> 00:11:42,240
work so once I found out that we are

00:11:39,690 --> 00:11:45,300
gonna be doing railsconf as an online

00:11:42,240 --> 00:11:47,640
conference I got me really worried like

00:11:45,300 --> 00:11:50,940
I kept thinking to myself okay how am i

00:11:47,640 --> 00:11:53,660
how am I gonna record the video now of

00:11:50,940 --> 00:11:59,040
course like I need to record it in 4k

00:11:53,660 --> 00:12:00,810
and obviously an iPhone won't do so I am

00:11:59,040 --> 00:12:03,060
gonna have to purchase a new camera that

00:12:00,810 --> 00:12:05,150
has 4k like you can shoot 4k video

00:12:03,060 --> 00:12:08,670
because it's very important that people

00:12:05,150 --> 00:12:12,930
be able to see like you know how dry my

00:12:08,670 --> 00:12:15,660
skin is or see my face in excruciating

00:12:12,930 --> 00:12:17,230
detail so I decided to purchase a new

00:12:15,660 --> 00:12:21,450
camera I got this camera it's Anna

00:12:17,230 --> 00:12:24,640
this om-d camera it's a very nice camera

00:12:21,450 --> 00:12:26,710
and then I read the manual for it and to

00:12:24,640 --> 00:12:28,330
be honest I haven't owned an SLR camera

00:12:26,710 --> 00:12:31,420
in quite a while so I'm not up on the

00:12:28,330 --> 00:12:33,850
latest technology and I was incredibly

00:12:31,420 --> 00:12:36,520
surprised at how you actually have to

00:12:33,850 --> 00:12:39,550
transfer how you transfer photos from

00:12:36,520 --> 00:12:42,070
the camera onto you know your phone or

00:12:39,550 --> 00:12:45,070
your computer or whatever according to

00:12:42,070 --> 00:12:46,990
the manual what you do is the Wi-Fi

00:12:45,070 --> 00:12:49,840
create or the camera creates a Wi-Fi

00:12:46,990 --> 00:12:53,080
network now you connect to the Wi-Fi

00:12:49,840 --> 00:12:56,410
network with your phone and then your

00:12:53,080 --> 00:13:00,310
phone transfers the photos off of the

00:12:56,410 --> 00:13:04,060
camera via Wi-Fi so of course you have

00:13:00,310 --> 00:13:05,920
to install some kind of like proprietary

00:13:04,060 --> 00:13:08,200
application on your phone some kind of

00:13:05,920 --> 00:13:10,030
app to transfer the photos from the

00:13:08,200 --> 00:13:12,430
phone over to your but are from the

00:13:10,030 --> 00:13:14,950
camera over to your phone and this made

00:13:12,430 --> 00:13:17,770
me think a couple things like first off

00:13:14,950 --> 00:13:20,860
I thought install a new app in this

00:13:17,770 --> 00:13:22,240
economy I've got millions of apps on my

00:13:20,860 --> 00:13:25,960
phone I can't afford to have another

00:13:22,240 --> 00:13:28,510
another app on my phone the other thing

00:13:25,960 --> 00:13:30,490
that I thought is can i hack this there

00:13:28,510 --> 00:13:34,030
has to be a way for me there has to be a

00:13:30,490 --> 00:13:36,370
way for me to be able to hack my hack my

00:13:34,030 --> 00:13:38,970
camera I don't want to transfer all the

00:13:36,370 --> 00:13:41,260
photos off using some third-party

00:13:38,970 --> 00:13:43,750
application I'd rather have a program

00:13:41,260 --> 00:13:45,760
that takes them directly off of the

00:13:43,750 --> 00:13:47,800
camera and imports them right into the

00:13:45,760 --> 00:13:50,640
photos application rather than using

00:13:47,800 --> 00:13:53,380
some weird thing so I decided that my

00:13:50,640 --> 00:13:55,150
one of my procrastination projects I

00:13:53,380 --> 00:13:56,830
mean since I since I bought the camera

00:13:55,150 --> 00:13:58,810
to film the video I need to be able to

00:13:56,830 --> 00:14:01,960
get the photos off of the camera or the

00:13:58,810 --> 00:14:03,910
video off of the camera in order to show

00:14:01,960 --> 00:14:06,280
the video to everyone I decided I needed

00:14:03,910 --> 00:14:08,710
to hack my camera and to get started I

00:14:06,280 --> 00:14:11,110
decided to connect my computer to the

00:14:08,710 --> 00:14:13,930
camera a via Wi-Fi rather than my cell

00:14:11,110 --> 00:14:16,960
phone and when I did I noticed a couple

00:14:13,930 --> 00:14:19,720
of interesting things first the camera

00:14:16,960 --> 00:14:20,800
always had the same IP address so I

00:14:19,720 --> 00:14:23,710
thought that was that was very

00:14:20,800 --> 00:14:24,370
interesting and when I ran a port scan

00:14:23,710 --> 00:14:27,879
on the

00:14:24,370 --> 00:14:31,149
pewter I found that it also had an HTTP

00:14:27,879 --> 00:14:35,019
service open and that was very

00:14:31,149 --> 00:14:37,449
interesting now I also found that I

00:14:35,019 --> 00:14:37,870
could just run curl against the HTTP

00:14:37,449 --> 00:14:39,730
port

00:14:37,870 --> 00:14:41,319
it gave me an error there was there was

00:14:39,730 --> 00:14:46,180
an error that showed on the in the

00:14:41,319 --> 00:14:47,079
terminal but the traffic was all over

00:14:46,180 --> 00:14:49,990
port 80

00:14:47,079 --> 00:14:51,819
it was unencrypted and if I could figure

00:14:49,990 --> 00:14:53,410
out what the actual end points were on

00:14:51,819 --> 00:14:55,779
the camera like maybe I could write my

00:14:53,410 --> 00:14:58,029
own write my own client for the camera

00:14:55,779 --> 00:15:01,029
so I needed a way to figure out like

00:14:58,029 --> 00:15:02,769
okay what is the data going between the

00:15:01,029 --> 00:15:05,259
cell phone and the camera what what are

00:15:02,769 --> 00:15:07,059
they transferring what is it doing and

00:15:05,259 --> 00:15:10,930
if I can figure that out I can write my

00:15:07,059 --> 00:15:12,850
own write my own client so I wanted to

00:15:10,930 --> 00:15:14,889
come up with a way to intercept the data

00:15:12,850 --> 00:15:15,819
that was being transferred between the

00:15:14,889 --> 00:15:18,309
camera and the phone

00:15:15,819 --> 00:15:21,309
so there are a couple things going for

00:15:18,309 --> 00:15:24,790
me the first thing was that we had in a

00:15:21,309 --> 00:15:26,829
hard-coded IP address so the camera

00:15:24,790 --> 00:15:29,860
always had the same IP address and that

00:15:26,829 --> 00:15:31,749
said to me that probably the application

00:15:29,860 --> 00:15:33,939
that's it's accessing the camera is

00:15:31,749 --> 00:15:36,779
gonna have that IP address hard-coded in

00:15:33,939 --> 00:15:39,339
so I can use this to my advantage

00:15:36,779 --> 00:15:42,639
the other thing is that since we have

00:15:39,339 --> 00:15:44,740
port 80 open and not 443 it's probably

00:15:42,639 --> 00:15:47,759
going to be unencrypted traffic so the

00:15:44,740 --> 00:15:51,370
camera is going to be transmitting

00:15:47,759 --> 00:15:54,670
unencrypted data now there is one

00:15:51,370 --> 00:15:57,970
crucial detail or one important thing is

00:15:54,670 --> 00:16:00,189
that this the point of this exercise is

00:15:57,970 --> 00:16:04,540
not actually to write a client for the

00:16:00,189 --> 00:16:08,079
camera but to put off doing the work

00:16:04,540 --> 00:16:09,870
that I really need to do and that means

00:16:08,079 --> 00:16:13,420
that I need to make this project

00:16:09,870 --> 00:16:15,579
worthwhile so that I didn't feel guilty

00:16:13,420 --> 00:16:17,170
about it and this gave me one really big

00:16:15,579 --> 00:16:20,470
constraint and that is that I needed to

00:16:17,170 --> 00:16:25,179
either use Ruby or rails to somehow

00:16:20,470 --> 00:16:28,629
intercept and deal with this traffic so

00:16:25,179 --> 00:16:30,370
my idea for getting access to the data

00:16:28,629 --> 00:16:32,649
that was being transferred between the

00:16:30,370 --> 00:16:35,589
phone and the camera was to essentially

00:16:32,649 --> 00:16:37,840
set up two computers that each had two

00:16:35,589 --> 00:16:40,450
interfaces so one can

00:16:37,840 --> 00:16:44,770
would have two computers each computer

00:16:40,450 --> 00:16:46,960
would have Ethernet and a Wi-Fi now the

00:16:44,770 --> 00:16:51,700
two computers would be connected to each

00:16:46,960 --> 00:16:55,480
other via ethernet and will connect the

00:16:51,700 --> 00:16:58,570
cell phone to one of the computers via

00:16:55,480 --> 00:17:00,730
Wi-Fi and that computer will act as a

00:16:58,570 --> 00:17:03,640
proxy so this computer is going to be

00:17:00,730 --> 00:17:07,180
intercepting the traffic and recording

00:17:03,640 --> 00:17:11,290
it then will connect the camera to the

00:17:07,180 --> 00:17:14,160
other computer via Wi-Fi and create an

00:17:11,290 --> 00:17:17,560
SSH tunnel between the camera and the

00:17:14,160 --> 00:17:20,290
proxy server this way our proxy server

00:17:17,560 --> 00:17:23,709
can access the network for the camera so

00:17:20,290 --> 00:17:27,370
we can have the to two IP to same IP

00:17:23,709 --> 00:17:29,680
addresses with access to each other so

00:17:27,370 --> 00:17:31,510
the secondary computer will set up an

00:17:29,680 --> 00:17:33,130
SSH tunnel between the camera and our

00:17:31,510 --> 00:17:35,890
proxy server and then the proxy server

00:17:33,130 --> 00:17:41,170
can access the access the camera through

00:17:35,890 --> 00:17:44,530
a port on localhost so when the phone

00:17:41,170 --> 00:17:46,960
sends data the proxy server will save a

00:17:44,530 --> 00:17:49,360
copy of the request and when the camera

00:17:46,960 --> 00:17:51,310
responds the proxy server can save a

00:17:49,360 --> 00:17:54,250
copy as a response something like this

00:17:51,310 --> 00:17:56,679
so the phone sends a request we save a

00:17:54,250 --> 00:17:59,230
copy of the request and then the camera

00:17:56,679 --> 00:18:00,910
sends a response we save a copy of the

00:17:59,230 --> 00:18:03,670
response and send that back to the phone

00:18:00,910 --> 00:18:05,740
and if we record all of that data we can

00:18:03,670 --> 00:18:07,570
figure out what is the protocol that the

00:18:05,740 --> 00:18:10,179
phone and the camera are using to talk

00:18:07,570 --> 00:18:14,040
to each other now this is for

00:18:10,179 --> 00:18:17,020
completeness this is the SSH SSH tunnel

00:18:14,040 --> 00:18:19,510
command that I used and you can see here

00:18:17,020 --> 00:18:24,310
essentially what happens is we say we're

00:18:19,510 --> 00:18:28,900
gonna forward all forward port 80 on 192

00:18:24,310 --> 00:18:32,320
168 0 10 to our Raspberry Pi I'm using a

00:18:28,900 --> 00:18:34,900
Raspberry Pi as my proxy server and the

00:18:32,320 --> 00:18:37,690
local the localhost on the proxy server

00:18:34,900 --> 00:18:41,590
can or the proxy server can access the

00:18:37,690 --> 00:18:43,990
camera on localhost via port 22 10 so if

00:18:41,590 --> 00:18:47,130
we connect to 22 10 on localhost that'll

00:18:43,990 --> 00:18:50,110
actually be forwarded over to the camera

00:18:47,130 --> 00:18:51,160
then in order to make this project

00:18:50,110 --> 00:18:54,370
worthwhile

00:18:51,160 --> 00:18:57,580
and make myself feel guilt free I wrote

00:18:54,370 --> 00:19:01,270
the proxy server in Ruby and essentially

00:18:57,580 --> 00:19:03,340
what it is is just a a proxy server

00:19:01,270 --> 00:19:06,040
written with web brick and this is the

00:19:03,340 --> 00:19:11,200
this is the code that handles the get

00:19:06,040 --> 00:19:14,380
request for the proxy server essentially

00:19:11,200 --> 00:19:16,330
all it does is access the SSH tunnel

00:19:14,380 --> 00:19:19,270
here so when a request comes in we we

00:19:16,330 --> 00:19:22,210
the proxy server create a new connection

00:19:19,270 --> 00:19:24,960
to the lope to localhost on for 20 to 10

00:19:22,210 --> 00:19:28,810
which is actually a connection to the

00:19:24,960 --> 00:19:30,900
camera then we send the request replay

00:19:28,810 --> 00:19:33,640
the request that we got from the phone

00:19:30,900 --> 00:19:37,270
then we get the response body that came

00:19:33,640 --> 00:19:41,200
from the camera and then we send the

00:19:37,270 --> 00:19:43,960
response body back to the back to the

00:19:41,200 --> 00:19:47,110
phone logging all this data along the

00:19:43,960 --> 00:19:48,880
way and then we have to handle posts as

00:19:47,110 --> 00:19:50,560
well this is the code for handling posts

00:19:48,880 --> 00:19:53,050
it's almost exactly the same as a code

00:19:50,560 --> 00:19:55,930
for handling gets except that we need to

00:19:53,050 --> 00:19:59,200
log post potties as well so it was very

00:19:55,930 --> 00:20:01,930
similar now the next thing that I did

00:19:59,200 --> 00:20:05,920
was that I used the app on the phone to

00:20:01,930 --> 00:20:07,450
collect data now of course yes this did

00:20:05,920 --> 00:20:10,900
mean that I had to install the

00:20:07,450 --> 00:20:12,850
application on my phone but hopefully I

00:20:10,900 --> 00:20:14,890
installed the application on my phone so

00:20:12,850 --> 00:20:16,870
that you don't have to you too can buy

00:20:14,890 --> 00:20:21,310
this camera and not have to install the

00:20:16,870 --> 00:20:23,920
application I did it for you and I am

00:20:21,310 --> 00:20:26,350
publishing this data so you won't need

00:20:23,920 --> 00:20:29,440
to do this hopefully anyway using the

00:20:26,350 --> 00:20:31,810
data that we were able to collect that

00:20:29,440 --> 00:20:34,450
we intercepted on the proxy server it's

00:20:31,810 --> 00:20:38,310
pretty trivial to write our own client

00:20:34,450 --> 00:20:41,080
and this is the client that I wrote for

00:20:38,310 --> 00:20:42,760
getting photos and getting images and

00:20:41,080 --> 00:20:45,430
movies off the camera basically it just

00:20:42,760 --> 00:20:49,480
has two parts the top part there just

00:20:45,430 --> 00:20:51,520
gets a list of all of images all the

00:20:49,480 --> 00:20:53,320
files that are stored on the camera and

00:20:51,520 --> 00:20:55,450
the second part that downloads all those

00:20:53,320 --> 00:20:58,390
downloads all those images and of course

00:20:55,450 --> 00:20:59,620
I added a little bit of intelligence in

00:20:58,390 --> 00:21:01,620
there so that if we've already

00:20:59,620 --> 00:21:05,309
downloaded the image it won't try to

00:21:01,620 --> 00:21:08,040
again so we did it our cameras hacked

00:21:05,309 --> 00:21:10,500
that is great of course this is clearly

00:21:08,040 --> 00:21:13,410
not not enough procrastination this only

00:21:10,500 --> 00:21:14,910
took a couple of days and I just after

00:21:13,410 --> 00:21:17,010
completing this project I just didn't

00:21:14,910 --> 00:21:19,680
feel enough pressure to work on the

00:21:17,010 --> 00:21:21,360
presentation so the next thing I had to

00:21:19,680 --> 00:21:23,610
do is I wanted to make a virtual

00:21:21,360 --> 00:21:25,770
conference inside of Animal Crossing and

00:21:23,610 --> 00:21:27,780
we saw the clip earlier today but now

00:21:25,770 --> 00:21:30,030
that that clip actually costs me a lot

00:21:27,780 --> 00:21:32,880
of time I had to grind a lot on Belle's

00:21:30,030 --> 00:21:35,580
so that I could buy all the stuff to lay

00:21:32,880 --> 00:21:38,960
out and display for everybody but then

00:21:35,580 --> 00:21:41,610
of course I needed a I needed a way to

00:21:38,960 --> 00:21:43,170
record the video that came off of my

00:21:41,610 --> 00:21:45,150
switch so that I can give the

00:21:43,170 --> 00:21:47,250
presentation an animal crossing so I

00:21:45,150 --> 00:21:48,900
learned about that and buy I bought a

00:21:47,250 --> 00:21:51,600
video capture card so that I could

00:21:48,900 --> 00:21:53,190
record all the data from the switch and

00:21:51,600 --> 00:21:55,170
I had to figure out the right software

00:21:53,190 --> 00:21:58,080
to use to record it which was extremely

00:21:55,170 --> 00:22:01,410
hard as well and now I also needed to

00:21:58,080 --> 00:22:03,210
get a tripod for the camera but it was

00:22:01,410 --> 00:22:05,880
very difficult to get a tripod because

00:22:03,210 --> 00:22:07,679
it was very kovat outside but the good

00:22:05,880 --> 00:22:10,200
news is that now that I've done all this

00:22:07,679 --> 00:22:12,750
yak shaving I'm ready to become a twitch

00:22:10,200 --> 00:22:15,179
gaming streamer but this is all prepared

00:22:12,750 --> 00:22:18,270
me for my next my next big career which

00:22:15,179 --> 00:22:21,330
is to launch my launch myself into the

00:22:18,270 --> 00:22:24,360
great world of online game streaming so

00:22:21,330 --> 00:22:26,760
when I decide to retire from programming

00:22:24,360 --> 00:22:29,250
I can just play Animal Crossing online

00:22:26,760 --> 00:22:31,440
all day the next project that I did

00:22:29,250 --> 00:22:33,150
though is I I still didn't feel enough

00:22:31,440 --> 00:22:36,809
pressure even though I decided to start

00:22:33,150 --> 00:22:40,010
a new career in streaming games I

00:22:36,809 --> 00:22:43,500
decided to do something which I call the

00:22:40,010 --> 00:22:45,240
Eren project after hacking my camera

00:22:43,500 --> 00:22:47,520
grinding with grinding four bells

00:22:45,240 --> 00:22:48,929
dealing with capture cards tripods and

00:22:47,520 --> 00:22:51,450
starting my new career as an online

00:22:48,929 --> 00:22:53,610
streamer since that wasn't enough I had

00:22:51,450 --> 00:22:56,670
to I decided to design and build a sign

00:22:53,610 --> 00:22:57,870
to let me know every time I had done

00:22:56,670 --> 00:23:00,750
messed up

00:22:57,870 --> 00:23:04,200
and this is this is where I came up with

00:23:00,750 --> 00:23:06,030
the ay-ay-ron sign essentially I built a

00:23:04,200 --> 00:23:09,360
sign that sits in my office above my

00:23:06,030 --> 00:23:10,770
desk this is this is the sign then I

00:23:09,360 --> 00:23:14,340
design and

00:23:10,770 --> 00:23:17,460
I designed a PCB this is the PCB this

00:23:14,340 --> 00:23:20,640
PCB controls the sign and the PCB has a

00:23:17,460 --> 00:23:22,860
serial UART connection so I can hook

00:23:20,640 --> 00:23:25,080
this PCB straight into my computer and

00:23:22,860 --> 00:23:26,730
have my computer control the sign now

00:23:25,080 --> 00:23:28,890
I've wired it up so that every time I

00:23:26,730 --> 00:23:31,500
execute a command in my terminal if it

00:23:28,890 --> 00:23:34,380
fails or if any of my tests fail the

00:23:31,500 --> 00:23:36,660
sign will display a a run so right here

00:23:34,380 --> 00:23:40,650
is the serial port on the PCB that I use

00:23:36,660 --> 00:23:44,150
to control it and this sign will let me

00:23:40,650 --> 00:23:44,150
know anytime I've messed up

00:23:58,760 --> 00:24:04,980
moving on our main story tonight

00:24:02,520 --> 00:24:07,320
concerns where clauses in your active

00:24:04,980 --> 00:24:09,289
record queries when you need to offload

00:24:07,320 --> 00:24:12,390
complexity to the database

00:24:09,289 --> 00:24:14,070
they're there for you we're going to

00:24:12,390 --> 00:24:15,960
talk about how where clauses work in

00:24:14,070 --> 00:24:17,789
active record some features that you

00:24:15,960 --> 00:24:19,799
might not know about and then we're

00:24:17,789 --> 00:24:22,160
gonna talk about profiling and speeding

00:24:19,799 --> 00:24:25,110
up speeding up where clauses

00:24:22,160 --> 00:24:26,970
now when I say profiling I don't mean

00:24:25,110 --> 00:24:29,669
profiling your application I mean

00:24:26,970 --> 00:24:32,460
profiling rails itself certainly these

00:24:29,669 --> 00:24:35,070
same profiling techniques techniques can

00:24:32,460 --> 00:24:36,720
be used to profile your application but

00:24:35,070 --> 00:24:42,600
today we're gonna look at how to speed

00:24:36,720 --> 00:24:46,289
up rails itself now this story started a

00:24:42,600 --> 00:24:48,419
while back we have an internal blog at

00:24:46,289 --> 00:24:50,820
work and somebody posted on the internal

00:24:48,419 --> 00:24:54,900
blog like hey check out this check out

00:24:50,820 --> 00:24:57,150
this life hack if you basically the blog

00:24:54,900 --> 00:24:59,039
post just said like sanitizing IDs

00:24:57,150 --> 00:25:01,049
yourself is much faster than letting

00:24:59,039 --> 00:25:03,419
active record sanitize the IDS for you

00:25:01,049 --> 00:25:06,450
so if you have a large list of IDs and

00:25:03,419 --> 00:25:08,370
you need to do an in statement doing the

00:25:06,450 --> 00:25:11,520
sanitize sequel is way faster than

00:25:08,370 --> 00:25:13,620
asking the where clause to do it and I

00:25:11,520 --> 00:25:16,740
read this and at first I just couldn't

00:25:13,620 --> 00:25:19,440
believe it and the next thing I thought

00:25:16,740 --> 00:25:21,750
is well if it's true why would that be

00:25:19,440 --> 00:25:24,299
true these two things do approximately

00:25:21,750 --> 00:25:27,570
the same thing so why would you want to

00:25:24,299 --> 00:25:31,230
use the harder version when you can just

00:25:27,570 --> 00:25:32,880
use the easy version so in order to

00:25:31,230 --> 00:25:35,250
figure out what was going on the first

00:25:32,880 --> 00:25:37,530
thing I did was I wrote a very simple

00:25:35,250 --> 00:25:39,059
benchmark now this benchmark just

00:25:37,530 --> 00:25:42,030
compares the two different strategies

00:25:39,059 --> 00:25:45,000
using this great benchmark IPS gem I

00:25:42,030 --> 00:25:46,799
really like this gem because all it does

00:25:45,000 --> 00:25:49,409
is run the same code over and over again

00:25:46,799 --> 00:25:51,809
for five seconds in whichever a chunk of

00:25:49,409 --> 00:25:54,270
code can run more times in five seconds

00:25:51,809 --> 00:25:55,890
that one is the faster version and this

00:25:54,270 --> 00:25:57,570
is really nice because I don't have to

00:25:55,890 --> 00:26:00,419
think about how many times should I run

00:25:57,570 --> 00:26:02,190
this thing just does it for me and sets

00:26:00,419 --> 00:26:04,280
a deadline and then however many times

00:26:02,190 --> 00:26:08,390
it executed within that deadline is our

00:26:04,280 --> 00:26:10,760
is our benchmark now what this means is

00:26:08,390 --> 00:26:12,770
the more times you run the faster your

00:26:10,760 --> 00:26:16,040
code is so we want to have a higher

00:26:12,770 --> 00:26:17,630
iterations per second our faster code

00:26:16,040 --> 00:26:19,280
will have higher iterations per second

00:26:17,630 --> 00:26:22,310
now if we look at the results for this

00:26:19,280 --> 00:26:25,040
benchmark the results are incredibly

00:26:22,310 --> 00:26:28,910
surprising actually sanitizing the IDS

00:26:25,040 --> 00:26:32,750
yourself was about 74 percent faster

00:26:28,910 --> 00:26:35,510
than calling the easier the easier API

00:26:32,750 --> 00:26:37,790
and this really perplexed me why why

00:26:35,510 --> 00:26:40,460
would this be the case these two things

00:26:37,790 --> 00:26:43,220
were doing almost exactly the same thing

00:26:40,460 --> 00:26:46,310
so how can the performance be so

00:26:43,220 --> 00:26:49,970
dramatically different now before we dig

00:26:46,310 --> 00:26:52,730
into this issue I want to talk about

00:26:49,970 --> 00:26:54,230
using where with active record so we're

00:26:52,730 --> 00:26:57,340
gonna do we're gonna get a little bit

00:26:54,230 --> 00:27:00,380
back to basics here let's take a look at

00:26:57,340 --> 00:27:03,020
calling the wear method and how what it

00:27:00,380 --> 00:27:06,410
actually does and the sequel query is

00:27:03,020 --> 00:27:08,840
that it generates so with active record

00:27:06,410 --> 00:27:10,190
the wear method just is simply used to

00:27:08,840 --> 00:27:13,130
manipulate the where clause that's

00:27:10,190 --> 00:27:14,630
generated in your sequel statements we

00:27:13,130 --> 00:27:16,340
use this method anytime we want to add

00:27:14,630 --> 00:27:19,040
constraints on the query we're making

00:27:16,340 --> 00:27:22,460
and these call these calls are additive

00:27:19,040 --> 00:27:25,400
so if we call wear multiple times it

00:27:22,460 --> 00:27:27,350
will add add multiple things to your

00:27:25,400 --> 00:27:29,150
where clause so we can keep chaining

00:27:27,350 --> 00:27:31,820
warez and saying we want to add this and

00:27:29,150 --> 00:27:34,250
this and this and this so from a

00:27:31,820 --> 00:27:36,560
high-level perspective we're translating

00:27:34,250 --> 00:27:38,420
Ruby calls into sequel we're essentially

00:27:36,560 --> 00:27:41,360
taking the Ruby language and converting

00:27:38,420 --> 00:27:43,640
it into the sequel language and there

00:27:41,360 --> 00:27:47,300
must be some process for converting Ruby

00:27:43,640 --> 00:27:49,670
code into sequel and executing it

00:27:47,300 --> 00:27:51,620
if we look at our benchmark again we'll

00:27:49,670 --> 00:27:53,420
see that the faster version is doing

00:27:51,620 --> 00:27:55,970
some of that translation to sequel

00:27:53,420 --> 00:27:58,040
manually so we can kind of tell

00:27:55,970 --> 00:28:00,830
intuitively that the speed difference

00:27:58,040 --> 00:28:03,410
must come from the way that the slower

00:28:00,830 --> 00:28:05,570
example does sequel generation so

00:28:03,410 --> 00:28:07,700
something about the automatic sequel

00:28:05,570 --> 00:28:10,820
generation is slower than doing it

00:28:07,700 --> 00:28:13,429
manually another interesting thing is

00:28:10,820 --> 00:28:16,280
that if we look at this particular

00:28:13,429 --> 00:28:17,960
example in the console this isn't

00:28:16,280 --> 00:28:20,179
actually the sequel that gets Jen

00:28:17,960 --> 00:28:21,559
so we see the sequel like we think it

00:28:20,179 --> 00:28:23,419
should be the sequel it gets generated

00:28:21,559 --> 00:28:25,220
but when we look at the console it's not

00:28:23,419 --> 00:28:28,639
that's not the sequel that's actually

00:28:25,220 --> 00:28:30,590
generated what's actually generated is

00:28:28,639 --> 00:28:32,659
you'll see the same sequel statements

00:28:30,590 --> 00:28:37,039
but they'll have a limit 11 attached to

00:28:32,659 --> 00:28:41,360
them and this is because active record

00:28:37,039 --> 00:28:44,690
is lazy about generating the query so in

00:28:41,360 --> 00:28:50,269
fact actually the inspect method on

00:28:44,690 --> 00:28:54,320
active record will add this limit 11 to

00:28:50,269 --> 00:28:56,629
the query before it's executed so if we

00:28:54,320 --> 00:28:58,309
want to have the where statement to

00:28:56,629 --> 00:29:01,399
generate the sequel that we would expect

00:28:58,309 --> 00:29:05,119
we need to actually proactively load

00:29:01,399 --> 00:29:06,950
them now this if we look at these three

00:29:05,119 --> 00:29:09,889
calls will notice a difference between

00:29:06,950 --> 00:29:12,289
the behavior where the first one when we

00:29:09,889 --> 00:29:15,350
eagerly load when we call to a no limit

00:29:12,289 --> 00:29:18,289
is added if we call just dot all without

00:29:15,350 --> 00:29:20,539
inspecting it nothing gets executed and

00:29:18,289 --> 00:29:23,570
nothing's executed because we didn't

00:29:20,539 --> 00:29:25,789
access any of the records and we didn't

00:29:23,570 --> 00:29:28,039
do anything with it so nothing is

00:29:25,789 --> 00:29:30,470
executed now the third one it adds limit

00:29:28,039 --> 00:29:32,389
11 and that's because we called the

00:29:30,470 --> 00:29:35,360
inspect method on it and remember that

00:29:32,389 --> 00:29:37,850
the console will call inspect for us or

00:29:35,360 --> 00:29:41,389
calling PU will automatically call

00:29:37,850 --> 00:29:42,980
inspect now the important thing to learn

00:29:41,389 --> 00:29:45,379
from this is we actually wrote our

00:29:42,980 --> 00:29:47,629
benchmark incorrectly if we look at our

00:29:45,379 --> 00:29:49,850
benchmark we'll see that we're just

00:29:47,629 --> 00:29:52,820
calling we're and we're not actually

00:29:49,850 --> 00:29:55,629
loading any records so neither of these

00:29:52,820 --> 00:29:58,009
things will actually query the database

00:29:55,629 --> 00:30:01,460
so the only thing that we've proven is

00:29:58,009 --> 00:30:03,769
that we're able to do nothing faster

00:30:01,460 --> 00:30:06,799
when we call sanitize sequel than if we

00:30:03,769 --> 00:30:08,840
were just calling where so let's fix the

00:30:06,799 --> 00:30:11,149
benchmark you know here we've fixed the

00:30:08,840 --> 00:30:12,889
benchmark to generate a thousand ideas

00:30:11,149 --> 00:30:14,899
and then try and query for those

00:30:12,889 --> 00:30:17,570
thousand IDs and it actually hits the

00:30:14,899 --> 00:30:20,090
database and if we compare that again if

00:30:17,570 --> 00:30:25,220
we run rerun this benchmark we'll see

00:30:20,090 --> 00:30:28,580
that in fact before we before we fix the

00:30:25,220 --> 00:30:28,909
benchmark the where statement was are

00:30:28,580 --> 00:30:31,039
the

00:30:28,909 --> 00:30:34,009
sanitize sequel statement it was 70%

00:30:31,039 --> 00:30:34,820
faster now that we fixed the benchmark

00:30:34,009 --> 00:30:38,659
we can see that

00:30:34,820 --> 00:30:41,210
well it's only 60% faster now so we've

00:30:38,659 --> 00:30:43,999
sped up our we've sped up our program

00:30:41,210 --> 00:30:48,460
but rather than being 70% faster its no

00:30:43,999 --> 00:30:50,749
60% faster so I guess that's better but

00:30:48,460 --> 00:30:54,769
ideally these two things should be

00:30:50,749 --> 00:30:56,389
identical so let's profile let's

00:30:54,769 --> 00:30:58,789
actually profile this code and try and

00:30:56,389 --> 00:31:01,369
figure out what's going on for these two

00:30:58,789 --> 00:31:04,580
pieces of code these two pieces of code

00:31:01,369 --> 00:31:06,739
doing most of the same thing being 60%

00:31:04,580 --> 00:31:08,629
slower it's just it's too slow it's in

00:31:06,739 --> 00:31:11,090
the threshold of something that I would

00:31:08,629 --> 00:31:12,379
consider to be a bug so let's try to

00:31:11,090 --> 00:31:14,659
figure out what the bottleneck of this

00:31:12,379 --> 00:31:17,029
code is and to figure that out I like to

00:31:14,659 --> 00:31:19,309
use a tool called stackprof for

00:31:17,029 --> 00:31:21,440
profiling now this is an example usage

00:31:19,309 --> 00:31:25,129
of stackprof so this is using stackprof

00:31:21,440 --> 00:31:28,249
to profile these to our to benchmark

00:31:25,129 --> 00:31:31,729
issues or to benchmark pieces of code it

00:31:28,249 --> 00:31:33,259
looks very similar to the IPS code we

00:31:31,729 --> 00:31:36,590
saw earlier only this time we're just

00:31:33,259 --> 00:31:39,169
doing getting profiling information now

00:31:36,590 --> 00:31:42,259
what we're doing here is we're

00:31:39,169 --> 00:31:44,509
generating actually two profiles one is

00:31:42,259 --> 00:31:47,059
with our slow case and one is with our

00:31:44,509 --> 00:31:48,889
fast case and I liked in this particular

00:31:47,059 --> 00:31:50,779
case I'd like to generate two profiles

00:31:48,889 --> 00:31:53,029
because we need to I want to compare

00:31:50,779 --> 00:31:55,639
them and it can be helpful to compare

00:31:53,029 --> 00:31:58,220
the two so if we run this we'll end up

00:31:55,639 --> 00:32:01,039
with two two profile files one for the

00:31:58,220 --> 00:32:03,409
fast case and one for the slow case and

00:32:01,039 --> 00:32:06,200
if we run stackprof against the where

00:32:03,409 --> 00:32:08,090
profile our slow case and we look at the

00:32:06,200 --> 00:32:10,580
top six stack frames we'll see that

00:32:08,090 --> 00:32:13,479
approximately 14% of our time is being

00:32:10,580 --> 00:32:16,549
spent clearing the database now

00:32:13,479 --> 00:32:17,869
acquiring the database like normally

00:32:16,549 --> 00:32:19,909
this might be our target for

00:32:17,869 --> 00:32:22,190
optimization so if we were just doing

00:32:19,909 --> 00:32:25,159
profiling on a web app say for for

00:32:22,190 --> 00:32:27,590
example maybe we see that we're spending

00:32:25,159 --> 00:32:29,539
14% of our time in one particular method

00:32:27,590 --> 00:32:32,479
well we would probably want to target

00:32:29,539 --> 00:32:35,090
that method now let's take a look at the

00:32:32,479 --> 00:32:38,149
profile with manual sanitization or fast

00:32:35,090 --> 00:32:39,919
case this top stack frames for the fast

00:32:38,149 --> 00:32:41,600
case well they they look almost

00:32:39,919 --> 00:32:44,720
identical to the frame

00:32:41,600 --> 00:32:46,730
we saw in the slow case now this means

00:32:44,720 --> 00:32:49,340
that if we were to go in and speed up

00:32:46,730 --> 00:32:52,250
that query method we would actually be

00:32:49,340 --> 00:32:54,080
speeding up both cases and that's not

00:32:52,250 --> 00:32:56,179
what we want we want to figure out why

00:32:54,080 --> 00:32:59,120
is one case faster than the other and

00:32:56,179 --> 00:33:02,900
can we can we get those two bits of code

00:32:59,120 --> 00:33:04,580
to be the same speed so speeding up the

00:33:02,900 --> 00:33:07,940
query method in this case won't actually

00:33:04,580 --> 00:33:11,419
help it to you our goal now we can

00:33:07,940 --> 00:33:13,700
figure out like as we see these these

00:33:11,419 --> 00:33:17,419
profiles they're not really helping us

00:33:13,700 --> 00:33:18,860
so much because we don't like we don't

00:33:17,419 --> 00:33:20,150
know what the difference is looking at

00:33:18,860 --> 00:33:22,220
the two they're they're essentially the

00:33:20,150 --> 00:33:23,480
same so why is one faster than the other

00:33:22,220 --> 00:33:26,960
we haven't been able to answer that

00:33:23,480 --> 00:33:29,539
question now these profiles when we're

00:33:26,960 --> 00:33:31,400
reading them they're telling us how much

00:33:29,539 --> 00:33:34,340
time we're spending in any one

00:33:31,400 --> 00:33:37,100
particular function call and we call

00:33:34,340 --> 00:33:38,570
this self so this is this that one call

00:33:37,100 --> 00:33:42,080
we're saying how much time do we spend

00:33:38,570 --> 00:33:43,730
in ourselves versus ourselves and other

00:33:42,080 --> 00:33:47,360
things that we call other functions that

00:33:43,730 --> 00:33:50,870
we call well stackprof also measures the

00:33:47,360 --> 00:33:53,390
amount of time that you're this one

00:33:50,870 --> 00:33:55,039
particular function takes plus all of

00:33:53,390 --> 00:33:59,539
its children as well so we call that

00:33:55,039 --> 00:34:02,450
self plus children so so far we've

00:33:59,539 --> 00:34:04,789
looked at the amount of time or what the

00:34:02,450 --> 00:34:06,770
slowest functions are but that only

00:34:04,789 --> 00:34:09,320
tells us how much time a particular

00:34:06,770 --> 00:34:11,359
function takes it doesn't tell us how

00:34:09,320 --> 00:34:14,450
much time that function takes plus all

00:34:11,359 --> 00:34:16,760
the functions it calls now where this is

00:34:14,450 --> 00:34:18,980
important is let's say let's take a look

00:34:16,760 --> 00:34:21,740
at an example so in this particular case

00:34:18,980 --> 00:34:23,659
if we profiled this code the profiler

00:34:21,740 --> 00:34:25,250
would tell us oh the method the slow

00:34:23,659 --> 00:34:28,369
method the method names slow it is the

00:34:25,250 --> 00:34:30,649
slowest and you should speed that up and

00:34:28,369 --> 00:34:33,020
it's true that method is the slowest and

00:34:30,649 --> 00:34:34,669
this slow caller method it wouldn't even

00:34:33,020 --> 00:34:37,760
show up on profiles because we don't

00:34:34,669 --> 00:34:39,379
spend any time in that method so the

00:34:37,760 --> 00:34:41,090
profiler would say hey you need to speed

00:34:39,379 --> 00:34:46,820
up the slow method it's method named

00:34:41,090 --> 00:34:48,950
slow now it would be even better though

00:34:46,820 --> 00:34:51,020
if we could eliminate the slow caller

00:34:48,950 --> 00:34:53,149
method like maybe maybe we don't need to

00:34:51,020 --> 00:34:53,970
call slow call or so much maybe we we

00:34:53,149 --> 00:34:56,070
can just eliminate

00:34:53,970 --> 00:34:57,750
that method all together but we can't

00:34:56,070 --> 00:35:00,330
see the slow caller method in our

00:34:57,750 --> 00:35:01,710
profiler outputs so what we need to do

00:35:00,330 --> 00:35:03,780
is say stackprof

00:35:01,710 --> 00:35:05,220
i want you to sort by the total amount

00:35:03,780 --> 00:35:08,390
of time that is spent inside of a

00:35:05,220 --> 00:35:11,880
function so we we say hey sort by total

00:35:08,390 --> 00:35:14,880
we can say stackprof pass in the sort

00:35:11,880 --> 00:35:16,740
total flag and this will sort by sort

00:35:14,880 --> 00:35:18,990
functions by how much time is spent in

00:35:16,740 --> 00:35:23,310
that function plus any functions it

00:35:18,990 --> 00:35:25,590
calls so if we sort by that will get a

00:35:23,310 --> 00:35:28,440
profile for our slow case that looks

00:35:25,590 --> 00:35:30,570
something like this and this is actually

00:35:28,440 --> 00:35:32,640
much more interesting than the previous

00:35:30,570 --> 00:35:34,349
profile we looked at and the reason is

00:35:32,640 --> 00:35:36,599
if we look through it we can see where

00:35:34,349 --> 00:35:39,320
are we spending all of our time well

00:35:36,599 --> 00:35:44,760
actually we're spending approximately

00:35:39,320 --> 00:35:46,440
28% or 29% inside of this compile method

00:35:44,760 --> 00:35:47,550
inside of the two sequel visitors so

00:35:46,440 --> 00:35:49,680
this is this is actually very

00:35:47,550 --> 00:35:52,290
interesting why are we spending 30% of

00:35:49,680 --> 00:35:55,109
our time compiling sequel now if we

00:35:52,290 --> 00:35:58,230
compare this profile to the self

00:35:55,109 --> 00:35:59,910
sanitization profile that Errol to

00:35:58,230 --> 00:36:02,849
sequel visitor it doesn't even show up

00:35:59,910 --> 00:36:03,839
at all so here we found our difference

00:36:02,849 --> 00:36:05,700
between the two

00:36:03,839 --> 00:36:08,460
so in our slow case we're spending

00:36:05,700 --> 00:36:11,430
nearly 30% of our time in this compiler

00:36:08,460 --> 00:36:14,790
we're in our fast case we don't even see

00:36:11,430 --> 00:36:17,040
that compiler in the profile output so

00:36:14,790 --> 00:36:19,080
it's not that we're not spending time in

00:36:17,040 --> 00:36:21,450
the compiler in the fast case it's just

00:36:19,080 --> 00:36:24,000
that we don't spend much time in the

00:36:21,450 --> 00:36:26,280
compiler in the fast case so we can tell

00:36:24,000 --> 00:36:28,619
from the comparing these two profiles

00:36:26,280 --> 00:36:30,150
that our actual target is this two

00:36:28,619 --> 00:36:33,410
sequel visitor or this two sequel

00:36:30,150 --> 00:36:35,880
compile so we need to figure out like

00:36:33,410 --> 00:36:39,660
why is this method taking up so much of

00:36:35,880 --> 00:36:42,390
our time but maybe we can speed up that

00:36:39,660 --> 00:36:44,040
method but I think it's better to step

00:36:42,390 --> 00:36:46,830
back a little bit and say you know what

00:36:44,040 --> 00:36:48,960
what exactly is this method doing so

00:36:46,830 --> 00:36:52,230
let's take a look at some active record

00:36:48,960 --> 00:36:53,730
design to understand what that compile

00:36:52,230 --> 00:36:55,290
method is doing I want to look at a

00:36:53,730 --> 00:36:57,839
little bit of active records design

00:36:55,290 --> 00:37:00,990
specifically I want to look at sequel

00:36:57,839 --> 00:37:03,359
generation sequel generation and active

00:37:00,990 --> 00:37:06,960
record compile involves a few a few

00:37:03,359 --> 00:37:07,589
steps our first step is generating a

00:37:06,960 --> 00:37:10,289
relation

00:37:07,589 --> 00:37:12,690
objects now every time we call any type

00:37:10,289 --> 00:37:14,219
of query builder method in active record

00:37:12,690 --> 00:37:17,670
we're generating or creating a new

00:37:14,219 --> 00:37:21,599
relation object so each time we call

00:37:17,670 --> 00:37:23,700
like say we're or order or joins or any

00:37:21,599 --> 00:37:26,099
of these types of query builder methods

00:37:23,700 --> 00:37:27,979
we're creating a new relation object and

00:37:26,099 --> 00:37:31,200
that relation object contains

00:37:27,979 --> 00:37:32,609
information about constraints or things

00:37:31,200 --> 00:37:34,589
that we want to add to the sequel

00:37:32,609 --> 00:37:37,529
statement so in this case we're saying

00:37:34,589 --> 00:37:40,170
hey we want to we want to find cats that

00:37:37,529 --> 00:37:42,029
are age 10 with names Glorian and we

00:37:40,170 --> 00:37:43,799
want you to order them by ID and each of

00:37:42,029 --> 00:37:46,499
these relation objects stores that

00:37:43,799 --> 00:37:48,719
particular information the nice thing

00:37:46,499 --> 00:37:51,719
about this design is that we can reuse

00:37:48,719 --> 00:37:54,869
these relation objects so we can say

00:37:51,719 --> 00:37:56,519
okay I want you to find all cats that

00:37:54,869 --> 00:37:59,279
are age 10 and I want you to order them

00:37:56,519 --> 00:38:01,170
by ID and then we can actually split and

00:37:59,279 --> 00:38:02,880
say well in this case I want you to

00:38:01,170 --> 00:38:04,410
order I want you to find cats named

00:38:02,880 --> 00:38:06,660
Gorby and in this case I want you to

00:38:04,410 --> 00:38:09,719
find cats named SeaTac but we're able to

00:38:06,660 --> 00:38:13,829
reuse part of the query between both of

00:38:09,719 --> 00:38:16,920
those two now this gives us a nice

00:38:13,829 --> 00:38:21,839
ability to reuse relations and refactor

00:38:16,920 --> 00:38:24,059
our or factor our designs so our next

00:38:21,839 --> 00:38:25,799
step is actually active record takes

00:38:24,059 --> 00:38:29,339
these relational objects and converts

00:38:25,799 --> 00:38:31,049
them into an AST this ast what an ast is

00:38:29,339 --> 00:38:33,719
is simply a tree data structure that

00:38:31,049 --> 00:38:36,029
represents the sequel query that we want

00:38:33,719 --> 00:38:38,999
to execute so if we were to imagine the

00:38:36,029 --> 00:38:41,700
object relationship of this ast it would

00:38:38,999 --> 00:38:43,259
look something like this this is what

00:38:41,700 --> 00:38:45,539
the data structure might actually look

00:38:43,259 --> 00:38:47,190
like it's a tree of objects so say we

00:38:45,539 --> 00:38:49,319
have a statement object it points at a

00:38:47,190 --> 00:38:51,749
fields object and the field object

00:38:49,319 --> 00:38:54,599
points at a list of fields it wants to

00:38:51,749 --> 00:38:58,589
query on this tree structure represents

00:38:54,599 --> 00:39:00,539
the actual string below it now active

00:38:58,589 --> 00:39:02,670
record will go through look at each of

00:39:00,539 --> 00:39:04,799
those relation objects and convert them

00:39:02,670 --> 00:39:07,049
into an ast that represents the sequel

00:39:04,799 --> 00:39:08,940
statement that we're going to execute so

00:39:07,049 --> 00:39:15,210
maybe the tree will look something like

00:39:08,940 --> 00:39:18,299
this now we can actually view these or

00:39:15,210 --> 00:39:20,670
get access to this ast by calling some

00:39:18,299 --> 00:39:22,680
extremely internal API is now the

00:39:20,670 --> 00:39:24,480
these api's are very internal but I'm

00:39:22,680 --> 00:39:26,190
and they may break at some point in the

00:39:24,480 --> 00:39:27,960
future but they are very handy when

00:39:26,190 --> 00:39:30,630
you're trying to debug stuff especially

00:39:27,960 --> 00:39:34,020
this kind of performance issues if we

00:39:30,630 --> 00:39:36,480
call dot arrow AST on the relation we

00:39:34,020 --> 00:39:38,250
can actually get access to that ASC

00:39:36,480 --> 00:39:40,589
object so calling this will give us the

00:39:38,250 --> 00:39:42,030
top of that tree and we can traverse

00:39:40,589 --> 00:39:44,280
through the tree and check out the

00:39:42,030 --> 00:39:48,180
actual tree that represents our sequel

00:39:44,280 --> 00:39:51,180
statement or we can call to dot and this

00:39:48,180 --> 00:39:54,000
prints out our tree and graphviz dot

00:39:51,180 --> 00:39:56,609
format now graph is dot format looks

00:39:54,000 --> 00:39:59,369
like this so this is the dot output it's

00:39:56,609 --> 00:40:01,140
actually a bit longer so the it this is

00:39:59,369 --> 00:40:03,180
the whole thing and of course it depends

00:40:01,140 --> 00:40:04,470
on the relation that you've created in

00:40:03,180 --> 00:40:07,109
the sequel statement that you're trying

00:40:04,470 --> 00:40:10,740
to execute now this isn't very helpful

00:40:07,109 --> 00:40:12,210
but if we take this dot format and run

00:40:10,740 --> 00:40:14,069
it through the dot command line tool

00:40:12,210 --> 00:40:16,710
graph it as command line tool we can

00:40:14,069 --> 00:40:18,920
generate a PNG file that shows us the

00:40:16,710 --> 00:40:21,990
actual structure of the sequel statement

00:40:18,920 --> 00:40:24,839
so in this case we're we're querying for

00:40:21,990 --> 00:40:26,930
cats the output of graph is will look

00:40:24,839 --> 00:40:29,609
like this so this is the the actual

00:40:26,930 --> 00:40:31,799
structure of the sequel statement that

00:40:29,609 --> 00:40:33,480
we're going to be executing if we zoom

00:40:31,799 --> 00:40:38,849
in we can see the column name so we have

00:40:33,480 --> 00:40:41,190
name and age and we can also see the

00:40:38,849 --> 00:40:43,349
table that we're executing against as

00:40:41,190 --> 00:40:45,480
well as the columns and order

00:40:43,349 --> 00:40:49,530
information that we want to query with

00:40:45,480 --> 00:40:51,630
query against as well now our final step

00:40:49,530 --> 00:40:53,940
before sending the query to the database

00:40:51,630 --> 00:40:57,390
is actually generating a generating that

00:40:53,940 --> 00:40:59,910
sequel statement that string and to do

00:40:57,390 --> 00:41:01,829
that we're just taking this ast this

00:40:59,910 --> 00:41:04,680
tree data structure and we're gonna walk

00:41:01,829 --> 00:41:06,599
the tree and convert the tree into a

00:41:04,680 --> 00:41:08,940
literal string that we'll send to the

00:41:06,599 --> 00:41:11,010
database so we have a bit of code that's

00:41:08,940 --> 00:41:13,349
called a visitor it's using the what is

00:41:11,010 --> 00:41:15,000
called the visitor pattern on the sequel

00:41:13,349 --> 00:41:17,280
visitor will walk through every one of

00:41:15,000 --> 00:41:21,180
these nodes in the tree converting each

00:41:17,280 --> 00:41:23,730
node into string or each node into a bit

00:41:21,180 --> 00:41:25,680
of a sequel statement and concatenate

00:41:23,730 --> 00:41:29,059
all of them together and then we send

00:41:25,680 --> 00:41:32,430
that string to the database so this is

00:41:29,059 --> 00:41:33,809
this so this particular visitor here is

00:41:32,430 --> 00:41:36,029
generating a sequel

00:41:33,809 --> 00:41:37,680
statement where what we saw in the

00:41:36,029 --> 00:41:39,900
previous slide was actually a graph of

00:41:37,680 --> 00:41:43,410
his visitor that walks the tree in

00:41:39,900 --> 00:41:46,499
outputs of the tree to adopt file that

00:41:43,410 --> 00:41:48,930
we can use with graph is now this is

00:41:46,499 --> 00:41:50,549
very interesting because when we were

00:41:48,930 --> 00:41:53,279
looking at our profiles earlier our

00:41:50,549 --> 00:41:55,109
target is the Aral visitor to sequel

00:41:53,279 --> 00:41:56,779
visitor it is exactly that it is that

00:41:55,109 --> 00:41:59,969
code that's walking through this tree

00:41:56,779 --> 00:42:02,430
now we we know from our profiles that

00:41:59,969 --> 00:42:03,839
this is the bottleneck and that's the

00:42:02,430 --> 00:42:06,569
thing that we need to figure out why

00:42:03,839 --> 00:42:08,009
it's taking so long so we know that the

00:42:06,569 --> 00:42:10,199
difference in performance is something

00:42:08,009 --> 00:42:11,969
to do with the difference in the ast s

00:42:10,199 --> 00:42:13,859
that are being generated so let's

00:42:11,969 --> 00:42:16,859
compare the ast for each of these

00:42:13,859 --> 00:42:20,279
queries so will generate dot files for

00:42:16,859 --> 00:42:22,049
our case that uses sanitize sequel or

00:42:20,279 --> 00:42:24,089
fast case and will generate a dot file

00:42:22,049 --> 00:42:27,599
for our case that doesn't use sanitize

00:42:24,089 --> 00:42:30,390
sequel and we'll compare the two so this

00:42:27,599 --> 00:42:33,449
here is the output for the ast e or this

00:42:30,390 --> 00:42:37,380
is the ast that is the fast case this is

00:42:33,449 --> 00:42:39,509
where we use sanitize sequel now let's

00:42:37,380 --> 00:42:41,339
compare that to the ast for our slow

00:42:39,509 --> 00:42:42,989
case where we're not using sanitize

00:42:41,339 --> 00:42:45,509
sequel this is what it looks like and we

00:42:42,989 --> 00:42:47,429
can see here that this auto sanitized

00:42:45,509 --> 00:42:50,819
version is actually much different than

00:42:47,429 --> 00:42:54,809
our sanitized sequel version if we add

00:42:50,819 --> 00:42:57,209
more IDs to the to the the auto

00:42:54,809 --> 00:42:59,130
sanitized version then this array will

00:42:57,209 --> 00:43:01,679
keep growing and growing and growing in

00:42:59,130 --> 00:43:03,809
size and we know that we it will have

00:43:01,679 --> 00:43:05,429
more and more nodes to process as we're

00:43:03,809 --> 00:43:09,269
walking this tree and converting it into

00:43:05,429 --> 00:43:11,640
an AST and this actually really this

00:43:09,269 --> 00:43:14,789
actually coincides or works well with

00:43:11,640 --> 00:43:17,130
the the performance that we're seeing if

00:43:14,789 --> 00:43:18,989
we compare the performance between the

00:43:17,130 --> 00:43:21,209
self sanitization or the manual

00:43:18,989 --> 00:43:24,359
sanitization and the auto sanitization

00:43:21,209 --> 00:43:26,609
we can see that well our auto san our

00:43:24,359 --> 00:43:28,829
auto sanitization is spending about 29

00:43:26,609 --> 00:43:31,439
percent of our time generating a sequel

00:43:28,829 --> 00:43:33,959
statement where our self sanitization is

00:43:31,439 --> 00:43:35,130
only spending 0.6% of our time so we can

00:43:33,959 --> 00:43:37,349
see that there's a huge difference

00:43:35,130 --> 00:43:38,609
between these two but we can also see

00:43:37,349 --> 00:43:42,779
that there's a huge difference between

00:43:38,609 --> 00:43:45,119
the ast s so these numbers correlate it

00:43:42,779 --> 00:43:46,329
makes sense we have a large ast it takes

00:43:45,119 --> 00:43:49,509
a large time

00:43:46,329 --> 00:43:52,539
oh we have a large a as seen it takes a

00:43:49,509 --> 00:43:56,799
long amount of time to generate that

00:43:52,539 --> 00:43:59,619
query so how can we fix this well we

00:43:56,799 --> 00:44:03,279
have a few options we could speed up the

00:43:59,619 --> 00:44:04,749
compiler that's one option but again

00:44:03,279 --> 00:44:07,569
this would actually speed up both the

00:44:04,749 --> 00:44:09,910
fast in the slow cases so our fast case

00:44:07,569 --> 00:44:12,759
would get faster our slow case would get

00:44:09,910 --> 00:44:14,799
faster too but that's not what we want

00:44:12,759 --> 00:44:17,380
we actually want to have our slow case

00:44:14,799 --> 00:44:20,619
be the same speed as our fast case so

00:44:17,380 --> 00:44:23,109
maybe instead we could do less work our

00:44:20,619 --> 00:44:24,939
faster example is doing much less work

00:44:23,109 --> 00:44:26,920
so maybe there's a way that we could

00:44:24,939 --> 00:44:32,289
reduce the amount of work that are slow

00:44:26,920 --> 00:44:34,209
cases is doing so maybe there's a way

00:44:32,289 --> 00:44:36,660
that we could take this where call and

00:44:34,209 --> 00:44:40,209
have it just call sanitized sequel

00:44:36,660 --> 00:44:43,809
rather than going through the entire

00:44:40,209 --> 00:44:46,449
compiler now if we trace through the

00:44:43,809 --> 00:44:48,549
trace through these profiling frames

00:44:46,449 --> 00:44:52,029
well actually find the find the point

00:44:48,549 --> 00:44:54,819
where these relations are being

00:44:52,029 --> 00:44:56,589
converted into IDs or into an AST and

00:44:54,819 --> 00:45:00,609
that this is the code that converts

00:44:56,589 --> 00:45:02,529
those relations into a list of IDs in

00:45:00,609 --> 00:45:03,759
the ast and we can see here that

00:45:02,529 --> 00:45:05,679
essentially what we're doing is we're

00:45:03,759 --> 00:45:07,689
creating an in node and this in node

00:45:05,679 --> 00:45:09,849
points at all the IDS that we're going

00:45:07,689 --> 00:45:12,819
to be that we're going to be using in

00:45:09,849 --> 00:45:14,469
the ast it would be nice if instead of

00:45:12,819 --> 00:45:16,900
generating so many nodes we could just

00:45:14,469 --> 00:45:19,569
generate a sanitize sequel part right

00:45:16,900 --> 00:45:22,319
here just call sanitize sequel and we

00:45:19,569 --> 00:45:24,609
don't generate all those notes to walk

00:45:22,319 --> 00:45:29,319
of course it'll require a little bit of

00:45:24,609 --> 00:45:31,269
refactoring to get it to work but I have

00:45:29,319 --> 00:45:33,219
to say like when I encounter some code

00:45:31,269 --> 00:45:37,569
that I need to refactor I always ask

00:45:33,219 --> 00:45:41,979
myself the same three questions can i

00:45:37,569 --> 00:45:45,670
refactor this code should I refactor

00:45:41,979 --> 00:45:49,269
this code and do I want my name on the

00:45:45,670 --> 00:45:51,130
blame if I answer yes to all three of

00:45:49,269 --> 00:45:53,679
these questions then I'll refactor this

00:45:51,130 --> 00:45:55,949
code otherwise I need a different

00:45:53,679 --> 00:45:55,949
strategy

00:46:07,630 --> 00:46:12,619
allene and I worked on optimizing this

00:46:10,309 --> 00:46:13,579
code for about three months and it seems

00:46:12,619 --> 00:46:15,619
like it should be a fairly

00:46:13,579 --> 00:46:17,779
straightforward optimization but

00:46:15,619 --> 00:46:18,770
unfortunately it wasn't and that's

00:46:17,779 --> 00:46:21,140
because there are some subtle

00:46:18,770 --> 00:46:24,589
differences between the ways of the two

00:46:21,140 --> 00:46:26,839
code examples were the first issue is

00:46:24,589 --> 00:46:28,819
that we can't use the parameters hash

00:46:26,839 --> 00:46:30,589
and controllers the same way that with

00:46:28,819 --> 00:46:33,079
manual sanitization in the same way that

00:46:30,589 --> 00:46:35,029
we would with Auto sanitization so for

00:46:33,079 --> 00:46:36,589
example here we have params that may

00:46:35,029 --> 00:46:38,660
have come in from the controller and we

00:46:36,589 --> 00:46:42,049
pass those parameters into active record

00:46:38,660 --> 00:46:43,700
now if we look at the queries that are

00:46:42,049 --> 00:46:45,680
generated by these two statements we can

00:46:43,700 --> 00:46:49,460
see that they're totally different the

00:46:45,680 --> 00:46:51,440
first one casts it to an ID whereas the

00:46:49,460 --> 00:46:54,470
second one we use it as strain generates

00:46:51,440 --> 00:46:58,579
an in clause with the strength so this

00:46:54,470 --> 00:47:01,520
is because the ast has some context

00:46:58,579 --> 00:47:04,400
about the values that are being put into

00:47:01,520 --> 00:47:07,039
the sequel statement it knows oh we're

00:47:04,400 --> 00:47:09,710
going to be generating where we're

00:47:07,039 --> 00:47:11,930
dealing with IDs here IDs are integer

00:47:09,710 --> 00:47:13,819
types so we need to cast this value to

00:47:11,930 --> 00:47:16,069
an integer type and it does that for us

00:47:13,819 --> 00:47:18,730
automatically whereas the sanitized

00:47:16,069 --> 00:47:22,700
sequel version doesn't have that context

00:47:18,730 --> 00:47:24,829
another example is URL slugs say we have

00:47:22,700 --> 00:47:27,529
some type of text that comes after the

00:47:24,829 --> 00:47:30,049
ID that come that comes in from the

00:47:27,529 --> 00:47:32,930
controller now when this ID comes in

00:47:30,049 --> 00:47:34,819
what will the query look like if we look

00:47:32,930 --> 00:47:36,589
at the sequel statements we'll see using

00:47:34,819 --> 00:47:38,809
auto sanitization it does the right

00:47:36,589 --> 00:47:40,760
thing it queries with the value of 100

00:47:38,809 --> 00:47:42,410
for the ID whereas the manual

00:47:40,760 --> 00:47:46,010
sanitization will not do that it

00:47:42,410 --> 00:47:52,160
generates an in clause with that string

00:47:46,010 --> 00:47:54,950
literal now again this is because the

00:47:52,160 --> 00:47:56,569
auto sanitization has that context it

00:47:54,950 --> 00:48:00,410
knows that we need to convert these into

00:47:56,569 --> 00:48:03,500
IDs now the third issue is very large

00:48:00,410 --> 00:48:05,119
numbers so in this case we have a very

00:48:03,500 --> 00:48:06,920
large number and we're trying to do a

00:48:05,119 --> 00:48:08,270
query against the database with it if we

00:48:06,920 --> 00:48:08,690
look at the sequel statement that's

00:48:08,270 --> 00:48:11,240
general

00:48:08,690 --> 00:48:12,940
here we'll see that in fact the first

00:48:11,240 --> 00:48:15,800
one doesn't do any query it does nothing

00:48:12,940 --> 00:48:18,710
where the second one does a very an in

00:48:15,800 --> 00:48:20,119
statement with a very large number where

00:48:18,710 --> 00:48:22,819
this could raise an exception or

00:48:20,119 --> 00:48:24,859
something and the reason that the first

00:48:22,819 --> 00:48:26,660
one doesn't do any doesn't do a query is

00:48:24,859 --> 00:48:28,339
because it knows well this number is

00:48:26,660 --> 00:48:31,579
outside of the bounds that this

00:48:28,339 --> 00:48:35,420
particular value can handle so I won't

00:48:31,579 --> 00:48:38,119
do any query I'll return an empty set so

00:48:35,420 --> 00:48:40,400
to deal with this or try to try to speed

00:48:38,119 --> 00:48:42,740
this thing up the solution that we came

00:48:40,400 --> 00:48:44,839
up to came up with was to introduce a

00:48:42,740 --> 00:48:47,599
new type of node called a precompiled

00:48:44,839 --> 00:48:49,310
node part of the reason the compiler is

00:48:47,599 --> 00:48:51,140
slower than we'd like is because it's

00:48:49,310 --> 00:48:51,680
designed to deal with any type of node

00:48:51,140 --> 00:48:54,589
in the tree

00:48:51,680 --> 00:48:56,720
but when application code is calling the

00:48:54,589 --> 00:48:59,270
where function we know that at that

00:48:56,720 --> 00:49:00,920
point we're being called with a list of

00:48:59,270 --> 00:49:03,680
IDs and we can do something a little bit

00:49:00,920 --> 00:49:05,690
more intelligent so the compiler is much

00:49:03,680 --> 00:49:07,760
more general it knows about general

00:49:05,690 --> 00:49:09,920
issues whereas at that point when we

00:49:07,760 --> 00:49:11,270
call where at that call site we know

00:49:09,920 --> 00:49:15,170
that we're only dealing with a list of

00:49:11,270 --> 00:49:17,569
IDs so what we could do is at the point

00:49:15,170 --> 00:49:19,310
where we create that list rather than

00:49:17,569 --> 00:49:22,069
creating that list of IDs we can create

00:49:19,310 --> 00:49:26,240
a precompiled node that has the sequel

00:49:22,069 --> 00:49:28,069
statement we need to insert so normally

00:49:26,240 --> 00:49:30,050
our tree will contain an in node that

00:49:28,069 --> 00:49:31,819
points to a bunch of IDs and we know

00:49:30,050 --> 00:49:35,119
that walking those IDs is our bottleneck

00:49:31,819 --> 00:49:37,849
so we aim to do is instead introduce a

00:49:35,119 --> 00:49:40,640
type of precompiled note this precompile

00:49:37,849 --> 00:49:43,700
node will point at the old in statement

00:49:40,640 --> 00:49:45,619
but it will also point it generated

00:49:43,700 --> 00:49:47,869
sequel that we can use when we're

00:49:45,619 --> 00:49:49,670
compiling our sequel statement now the

00:49:47,869 --> 00:49:50,930
reason we point of both of these is so

00:49:49,670 --> 00:49:53,300
that we can maintain backwards

00:49:50,930 --> 00:49:55,400
compatibility for example maybe we need

00:49:53,300 --> 00:49:56,990
to change the in statement into a not in

00:49:55,400 --> 00:49:59,540
statement so we need to do some kind of

00:49:56,990 --> 00:50:00,890
transformation on the tree well we were

00:49:59,540 --> 00:50:05,000
able to maintain backwards compatibility

00:50:00,890 --> 00:50:06,680
and get higher performance so normally

00:50:05,000 --> 00:50:09,500
during the compilation phase we would

00:50:06,680 --> 00:50:11,859
normally visit these all these in

00:50:09,500 --> 00:50:15,470
statements are all the nodes in this

00:50:11,859 --> 00:50:17,359
inside of the tree whereas now when we

00:50:15,470 --> 00:50:19,250
encounter a precompiled node instead of

00:50:17,359 --> 00:50:19,900
visiting all those we can just say ok i

00:50:19,250 --> 00:50:24,190
want to use

00:50:19,900 --> 00:50:25,569
this precompiled statement so Eileen and

00:50:24,190 --> 00:50:27,099
I implemented this and I want to share

00:50:25,569 --> 00:50:28,569
some of the benchmark results with you

00:50:27,099 --> 00:50:30,490
so if we look at the performance

00:50:28,569 --> 00:50:32,619
difference so this benchmark just

00:50:30,490 --> 00:50:34,990
measures how fast can we execute a where

00:50:32,619 --> 00:50:38,380
statement and we're comparing against

00:50:34,990 --> 00:50:40,990
our our branch to master will see that

00:50:38,380 --> 00:50:42,369
our branch is actually 30% faster so

00:50:40,990 --> 00:50:46,329
we've been able to improve performance

00:50:42,369 --> 00:50:47,890
on master thirty five thirty percent now

00:50:46,329 --> 00:50:51,130
we need to compare this with the

00:50:47,890 --> 00:50:53,440
original benchmark against self

00:50:51,130 --> 00:50:56,260
sanitization to see where where we are

00:50:53,440 --> 00:50:58,180
with regards to self sanitization so we

00:50:56,260 --> 00:51:00,339
compare that as well using a thousand

00:50:58,180 --> 00:51:03,520
ids and if we run the benchmarks we'll

00:51:00,339 --> 00:51:05,770
see here it's still actually slower it's

00:51:03,520 --> 00:51:08,799
18 percent slower than doing self

00:51:05,770 --> 00:51:11,500
sanitization now I think this is good

00:51:08,799 --> 00:51:15,490
news because it used to be sixty percent

00:51:11,500 --> 00:51:17,200
slower of course we saw earlier that

00:51:15,490 --> 00:51:19,630
these two functions are doing something

00:51:17,200 --> 00:51:21,849
a little bit different so we're not

00:51:19,630 --> 00:51:24,099
exactly comparing apples to apples so

00:51:21,849 --> 00:51:26,500
that could be that could be the reason

00:51:24,099 --> 00:51:28,569
for this performance degradation but

00:51:26,500 --> 00:51:31,720
actually I think that we still have a

00:51:28,569 --> 00:51:33,039
lot of work to do this is a work in

00:51:31,720 --> 00:51:34,839
progress and I think that we can

00:51:33,039 --> 00:51:37,089
actually get those numbers closer such

00:51:34,839 --> 00:51:38,250
that there is no performance difference

00:51:37,089 --> 00:51:41,109
at all

00:51:38,250 --> 00:51:44,260
but for the time being I think this is a

00:51:41,109 --> 00:51:47,799
great improvement now I'd like to show

00:51:44,260 --> 00:51:50,230
you all of the source code for this the

00:51:47,799 --> 00:51:52,029
entire diff or fixing this particular

00:51:50,230 --> 00:51:54,579
issue but I think that that would be

00:51:52,029 --> 00:51:56,890
going from zero to draw an owl when

00:51:54,579 --> 00:51:58,510
actually I want to communicate to you

00:51:56,890 --> 00:52:02,650
things that would be more useful to you

00:51:58,510 --> 00:52:05,579
in your daily lives like the

00:52:02,650 --> 00:52:07,779
architecture of active record or

00:52:05,579 --> 00:52:09,789
benchmarking and profiling techniques

00:52:07,779 --> 00:52:11,589
those are the things that I actually

00:52:09,789 --> 00:52:13,170
want to communicate to you in this talk

00:52:11,589 --> 00:52:16,829
versus the

00:52:13,170 --> 00:52:19,109
this one particular performance fix now

00:52:16,829 --> 00:52:21,029
I'd be remiss if I didn't show you some

00:52:19,109 --> 00:52:23,729
of the actual patch so let's take a look

00:52:21,029 --> 00:52:27,059
at it this is the bit of the code that

00:52:23,729 --> 00:52:29,249
handles AST conversion where we are

00:52:27,059 --> 00:52:32,430
looking at in we're generating in nodes

00:52:29,249 --> 00:52:35,039
and we went from this to eater

00:52:32,430 --> 00:52:36,809
compilation to this now the first thing

00:52:35,039 --> 00:52:39,299
you'll notice about this code is it's

00:52:36,809 --> 00:52:40,440
more complicated that is true but you

00:52:39,299 --> 00:52:42,329
can see under the hood that we're

00:52:40,440 --> 00:52:44,700
actually just calling this sanitized

00:52:42,329 --> 00:52:47,460
sequel array just like our fast example

00:52:44,700 --> 00:52:49,319
was doing now actually this isn't merged

00:52:47,460 --> 00:52:51,660
into master yet and the reason is we

00:52:49,319 --> 00:52:54,059
have the main issue with this particular

00:52:51,660 --> 00:52:57,660
patch is we have this neat function here

00:52:54,059 --> 00:53:00,269
called serialized too now we need to

00:52:57,660 --> 00:53:02,969
figure out a better name for this method

00:53:00,269 --> 00:53:05,309
in fact what we had to do to get this

00:53:02,969 --> 00:53:07,319
performance boost is if you look at the

00:53:05,309 --> 00:53:09,660
internals of active record you'll see

00:53:07,319 --> 00:53:12,180
that each type has a serialized method

00:53:09,660 --> 00:53:14,880
now that serialized method actually has

00:53:12,180 --> 00:53:17,560
it doesn't just serialize unfortunately

00:53:14,880 --> 00:53:19,190
it has two responsibilities it does

00:53:17,560 --> 00:53:22,650
[Music]

00:53:19,190 --> 00:53:24,900
verification and serialization so it

00:53:22,650 --> 00:53:26,630
checks to see if the value is within

00:53:24,900 --> 00:53:29,999
bounds and then it does a serialization

00:53:26,630 --> 00:53:32,219
well in this patch we needed to be able

00:53:29,999 --> 00:53:35,519
to split up that functionality so we

00:53:32,219 --> 00:53:37,920
needed to be able to do those checks say

00:53:35,519 --> 00:53:40,109
are these things in bounds and then do

00:53:37,920 --> 00:53:43,109
the serialization or I do the

00:53:40,109 --> 00:53:45,029
serialization unfortunately serialize is

00:53:43,109 --> 00:53:47,460
a public method so we can't change the

00:53:45,029 --> 00:53:49,079
behavior of that method so we just for

00:53:47,460 --> 00:53:51,479
the time being we introduced a method

00:53:49,079 --> 00:53:53,940
called serialize to so we need to figure

00:53:51,479 --> 00:53:55,529
out a better name for that but once we

00:53:53,940 --> 00:53:56,910
do we'll merge this in or we'll just

00:53:55,529 --> 00:53:59,819
make this private or something we'll

00:53:56,910 --> 00:54:04,589
figure out something but for now we have

00:53:59,819 --> 00:54:07,229
this fun method name all right so let's

00:54:04,589 --> 00:54:09,989
wrap this up first thing I want to say

00:54:07,229 --> 00:54:12,239
is that not all code is equal we saw

00:54:09,989 --> 00:54:13,920
those two those two bits of code at the

00:54:12,239 --> 00:54:17,009
very beginning and we saw that they did

00:54:13,920 --> 00:54:20,009
basically the same thing but in fact

00:54:17,009 --> 00:54:23,609
they're not equal at all they handle

00:54:20,009 --> 00:54:25,810
different cases and this manual

00:54:23,609 --> 00:54:27,670
sanitization route may not be applicable

00:54:25,810 --> 00:54:30,010
in the same cases as these regular

00:54:27,670 --> 00:54:32,410
active record calls so it's kind of

00:54:30,010 --> 00:54:34,090
dangerous to say like okay these these

00:54:32,410 --> 00:54:36,900
two things are the same they are

00:54:34,090 --> 00:54:39,430
probably not exactly the same however

00:54:36,900 --> 00:54:42,580
similar behaviors should have similar

00:54:39,430 --> 00:54:44,500
performance but these weren't even the

00:54:42,580 --> 00:54:46,540
same the performance was very different

00:54:44,500 --> 00:54:48,790
the performance should be very close if

00:54:46,540 --> 00:54:50,350
they do approximately the same thing the

00:54:48,790 --> 00:54:52,180
performance should be approximately the

00:54:50,350 --> 00:54:55,300
same but in this case they weren't even

00:54:52,180 --> 00:54:57,250
close at all it was very different so I

00:54:55,300 --> 00:54:59,920
would consider this poor performance to

00:54:57,250 --> 00:55:02,410
be above I think that poor performance

00:54:59,920 --> 00:55:03,700
is a bug if you encounter something like

00:55:02,410 --> 00:55:06,190
this with rails you should absolutely

00:55:03,700 --> 00:55:08,530
report it as an issue rather than saying

00:55:06,190 --> 00:55:10,780
it's you know just a performance protip

00:55:08,530 --> 00:55:12,700
it's cool to have performance Pro tips

00:55:10,780 --> 00:55:14,770
like that but really we shouldn't be

00:55:12,700 --> 00:55:17,500
working to make the framework faster I

00:55:14,770 --> 00:55:20,470
mean if you really think about it like

00:55:17,500 --> 00:55:22,600
poor performance in this economy we

00:55:20,470 --> 00:55:24,550
can't afford that and you're right we

00:55:22,600 --> 00:55:25,270
can't afford that we need to be fixing

00:55:24,550 --> 00:55:28,600
these things

00:55:25,270 --> 00:55:31,720
so to recap today we looked at really

00:55:28,600 --> 00:55:33,700
great ways to procrastinate I verified

00:55:31,720 --> 00:55:36,460
them is really great we looked at tools

00:55:33,700 --> 00:55:38,440
for performance active record internals

00:55:36,460 --> 00:55:40,630
and design and I hope that you all

00:55:38,440 --> 00:55:43,900
enjoyed my very first opening keynote at

00:55:40,630 --> 00:55:46,060
railsconf thank you so much and I really

00:55:43,900 --> 00:55:52,530
hope that we can actually see each other

00:55:46,060 --> 00:55:52,530

YouTube URL: https://www.youtube.com/watch?v=9JEEabL90AA


