Title: RailsConf 2020 CE - Encapsulating Views by Joel Hawksley
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Encapsulating Views by Joel Hawksley

Unlike models and controllers, Rails views are not encapsulated. This makes them hard to reason about and difficult to test, leading us to use abstractions such as presenters and decorators. In this talk, we'll explore the inner workings of how Rails compiles and executes views today, the lessons we've learned building encapsulated views at GitHub over the past year, and how you can do the same with the support for 3rd-party component frameworks coming in Rails 6.1.

__________

Joel is a software engineer at GitHub. He works on the Design Systems team, leading the development of ViewComponent.
Captions: 
	00:00:08,910 --> 00:00:16,720
hello there welcome to railsconf 2020

00:00:12,099 --> 00:00:18,730
point to couch edition my name is Joe

00:00:16,720 --> 00:00:21,610
Oxley and I am coming to you from my

00:00:18,730 --> 00:00:23,380
closet this is the best place I could

00:00:21,610 --> 00:00:26,500
find in my house to make a nice clean

00:00:23,380 --> 00:00:29,349
audio recording I'm an engineer on the

00:00:26,500 --> 00:00:31,149
design systems team at github we are

00:00:29,349 --> 00:00:32,800
responsible for the primer design system

00:00:31,149 --> 00:00:35,829
that's used throughout all the

00:00:32,800 --> 00:00:36,850
applications github builds today I'm

00:00:35,829 --> 00:00:38,920
going to talk about a project I've been

00:00:36,850 --> 00:00:40,929
working on the past year called view

00:00:38,920 --> 00:00:44,109
component I'm gonna talk about why we

00:00:40,929 --> 00:00:46,300
built it how we're using it some lessons

00:00:44,109 --> 00:00:48,899
we've learned and how you get can get

00:00:46,300 --> 00:00:52,449
involved in the future of the project

00:00:48,899 --> 00:00:53,949
but a little about me first I love to

00:00:52,449 --> 00:00:56,440
south of Boulder Colorado with my wife

00:00:53,949 --> 00:00:59,050
Caitlin and our wonderful 90 pound

00:00:56,440 --> 00:01:00,699
golden retriever captain and before I

00:00:59,050 --> 00:01:03,699
was a software engineer I was a sports

00:01:00,699 --> 00:01:05,770
photographer and for a couple of years I

00:01:03,699 --> 00:01:09,010
traveled the country shooting every

00:01:05,770 --> 00:01:11,710
sport imaginable shot portraits for

00:01:09,010 --> 00:01:13,210
marketing campaigns this is a portrait

00:01:11,710 --> 00:01:16,780
of a basketball player for a billboard

00:01:13,210 --> 00:01:19,000
and really enjoyed covering just that

00:01:16,780 --> 00:01:21,850
the wide variety of sports this is an

00:01:19,000 --> 00:01:24,729
image from a NASCAR race in Martinsville

00:01:21,850 --> 00:01:26,680
Virginia I also worked at newspapers for

00:01:24,729 --> 00:01:28,299
a bit a lot of my work was just covering

00:01:26,680 --> 00:01:30,579
daily life this is one of my favorite

00:01:28,299 --> 00:01:32,860
photographs had ever taken of the first

00:01:30,579 --> 00:01:34,869
day of the swimming pools opened during

00:01:32,860 --> 00:01:37,479
an especially hot summer in Grand Rapids

00:01:34,869 --> 00:01:39,310
Michigan I also did a lot of work

00:01:37,479 --> 00:01:41,170
covering breaking news this is a scene

00:01:39,310 --> 00:01:45,219
from a car accident in southern Illinois

00:01:41,170 --> 00:01:47,259
I did that for a while until sometime in

00:01:45,219 --> 00:01:49,539
2013 when I was out riding my bike on

00:01:47,259 --> 00:01:51,820
the Blue Ridge Parkway and I got a call

00:01:49,539 --> 00:01:54,909
from my photo editor telling me that she

00:01:51,820 --> 00:01:56,590
had been laid off and this is a really

00:01:54,909 --> 00:01:59,490
tough day for me because I had aspired

00:01:56,590 --> 00:02:02,380
to have her job and in that moment I saw

00:01:59,490 --> 00:02:05,289
the future of my career vanish from in

00:02:02,380 --> 00:02:07,600
front of me the same day I called my

00:02:05,289 --> 00:02:09,399
friend Erin and asked him for his advice

00:02:07,600 --> 00:02:12,010
and he gave me something better than in

00:02:09,399 --> 00:02:15,040
his advice he gave me an offer to come

00:02:12,010 --> 00:02:17,379
be his apprentice so I moved to Rhode

00:02:15,040 --> 00:02:19,330
Island and after a couple of months he

00:02:17,379 --> 00:02:21,879
had taught me how to be a professional

00:02:19,330 --> 00:02:22,300
software engineer and really I wouldn't

00:02:21,879 --> 00:02:25,110
be here

00:02:22,300 --> 00:02:31,600
if it wasn't for him so thanks Aaron

00:02:25,110 --> 00:02:33,400
enough about me you know it's it's an

00:02:31,600 --> 00:02:35,560
especially stressful time for a lot of

00:02:33,400 --> 00:02:39,340
us right now I'm recording this talk in

00:02:35,560 --> 00:02:42,550
my closet because we're all worried

00:02:39,340 --> 00:02:45,250
about this pandemic and you know it's a

00:02:42,550 --> 00:02:46,780
stressful situation and when I was

00:02:45,250 --> 00:02:48,340
talking to my therapist about it while I

00:02:46,780 --> 00:02:50,500
was working on this talk she said that

00:02:48,340 --> 00:02:54,400
it's important for us to focus in times

00:02:50,500 --> 00:02:57,790
like these on gratitude so I wanted to

00:02:54,400 --> 00:03:01,540
start my presentation today with some

00:02:57,790 --> 00:03:04,660
gratitude so I'm thankful for rails

00:03:01,540 --> 00:03:07,860
rails has been around for a long time

00:03:04,660 --> 00:03:10,330
when it comes to programming frameworks

00:03:07,860 --> 00:03:13,210
think about how much rails has enabled

00:03:10,330 --> 00:03:14,830
us all to accompany us all to accomplish

00:03:13,210 --> 00:03:19,600
that's something we really should be

00:03:14,830 --> 00:03:20,860
thankful for we also should be thankful

00:03:19,600 --> 00:03:23,440
for the value rails has brought to the

00:03:20,860 --> 00:03:25,000
world rails has enabled us to focus on

00:03:23,440 --> 00:03:28,810
the needs of the people who use our

00:03:25,000 --> 00:03:32,050
products and rails is a big part of

00:03:28,810 --> 00:03:34,180
github success more than eight hundred

00:03:32,050 --> 00:03:37,150
people contributed to our rails monolith

00:03:34,180 --> 00:03:39,880
last year and rails has scaled with

00:03:37,150 --> 00:03:43,930
github our app is more less just vanilla

00:03:39,880 --> 00:03:47,590
rails it's just a lot of it we have over

00:03:43,930 --> 00:03:52,750
700 models over 600 controllers and as

00:03:47,590 --> 00:03:54,430
of yesterday over 4400 views and it's

00:03:52,750 --> 00:03:57,459
this specific part of our scale of I'm

00:03:54,430 --> 00:03:59,800
going to focus on soaz rails

00:03:57,459 --> 00:04:03,100
applications scale we often turn to view

00:03:59,800 --> 00:04:04,450
abstractions not provided by rails here

00:04:03,100 --> 00:04:06,420
are a few examples of what they've

00:04:04,450 --> 00:04:08,709
looked like at least in my experience

00:04:06,420 --> 00:04:11,320
so one abstraction we turn to is

00:04:08,709 --> 00:04:13,330
decorators I came across this at my

00:04:11,320 --> 00:04:15,880
first job where I worked with my friend

00:04:13,330 --> 00:04:19,419
Aaron is it a little consultancy called

00:04:15,880 --> 00:04:20,770
mojo Tech and after working a couple of

00:04:19,419 --> 00:04:22,630
rails projects there I landed on my

00:04:20,770 --> 00:04:24,970
first what I would consider large-scale

00:04:22,630 --> 00:04:26,919
rails application and this is the first

00:04:24,970 --> 00:04:29,080
time I saw a rails folder that didn't

00:04:26,919 --> 00:04:30,700
belong and it felt kind of weird I

00:04:29,080 --> 00:04:33,070
didn't know whether I should be ok with

00:04:30,700 --> 00:04:35,500
it and that folder was called decorators

00:04:33,070 --> 00:04:39,820
and it had model

00:04:35,500 --> 00:04:41,740
view logic and it looks something like

00:04:39,820 --> 00:04:45,840
this so we have this user decorator

00:04:41,740 --> 00:04:48,490
class has a status instance method that

00:04:45,840 --> 00:04:50,140
checks to see if this active predicate

00:04:48,490 --> 00:04:53,500
is true and if it does returns one

00:04:50,140 --> 00:04:54,820
string and if not returns the other and

00:04:53,500 --> 00:04:57,790
these decorators were a place to put

00:04:54,820 --> 00:05:00,880
view related logic that was coupled to a

00:04:57,790 --> 00:05:02,140
specific model in my experience though

00:05:00,880 --> 00:05:03,940
looking at this app it was really just

00:05:02,140 --> 00:05:07,660
another place to hide methods that we

00:05:03,940 --> 00:05:09,010
felt bad putting on the model itself so

00:05:07,660 --> 00:05:11,530
these objects were unit tested like

00:05:09,010 --> 00:05:13,990
models so for example here's a mini test

00:05:11,530 --> 00:05:16,300
for the same decorator we knew it up

00:05:13,990 --> 00:05:20,440
with a user and then call an instance

00:05:16,300 --> 00:05:24,120
method on it in this case status and see

00:05:20,440 --> 00:05:24,120
that it returns the inactive string

00:05:24,600 --> 00:05:29,620
another abstraction that I've seen that

00:05:27,370 --> 00:05:31,690
I came across was react rails a nice

00:05:29,620 --> 00:05:34,080
plugin for rails that allows you to

00:05:31,690 --> 00:05:36,700
render react components really easily

00:05:34,080 --> 00:05:38,320
and I was using this out of a at a

00:05:36,700 --> 00:05:40,419
startup where we were using react to

00:05:38,320 --> 00:05:42,040
build our UI but what was curious about

00:05:40,419 --> 00:05:44,080
our use of react rails is it started to

00:05:42,040 --> 00:05:45,220
creep into covering areas of our

00:05:44,080 --> 00:05:46,419
application that really could have just

00:05:45,220 --> 00:05:48,430
been rendered on the server with

00:05:46,419 --> 00:05:50,620
traditional rails templates but we were

00:05:48,430 --> 00:05:54,400
using it because it enabled us to write

00:05:50,620 --> 00:05:56,470
unit tests for our views on our tests in

00:05:54,400 --> 00:05:59,050
this case were really simple so say for

00:05:56,470 --> 00:06:01,000
example we had a button component they

00:05:59,050 --> 00:06:03,580
kind of just visited two things rendered

00:06:01,000 --> 00:06:05,680
the component and then asserted against

00:06:03,580 --> 00:06:08,340
the HTML result and these tests were

00:06:05,680 --> 00:06:11,229
really fast so we wrote a lot of them a

00:06:08,340 --> 00:06:14,050
third abstraction was one called

00:06:11,229 --> 00:06:16,330
presenters in our application in github

00:06:14,050 --> 00:06:18,000
we call these view models and they're

00:06:16,330 --> 00:06:22,330
really just view specific logic

00:06:18,000 --> 00:06:24,040
extracted to Ruby objects and they look

00:06:22,330 --> 00:06:25,690
something like this so they're coupled

00:06:24,040 --> 00:06:28,660
to a specific view this one is the

00:06:25,690 --> 00:06:31,780
repository index view this one has a

00:06:28,660 --> 00:06:33,610
status instance method that based on the

00:06:31,780 --> 00:06:37,510
status of the repository returns either

00:06:33,610 --> 00:06:39,580
disabled or enabled and then when we go

00:06:37,510 --> 00:06:41,620
to test it we can test it like we would

00:06:39,580 --> 00:06:44,190
test any other Ruby object see that the

00:06:41,620 --> 00:06:47,680
status instance method returns enabled

00:06:44,190 --> 00:06:49,240
in my experience though in our code base

00:06:47,680 --> 00:06:52,539
at least and the ones other ones I've

00:06:49,240 --> 00:06:54,639
this used in these ultimately become a

00:06:52,539 --> 00:06:57,099
distraction because they give us a false

00:06:54,639 --> 00:06:58,539
sense of confidence by testing these we

00:06:57,099 --> 00:07:00,460
think we're testing a review later but

00:06:58,539 --> 00:07:02,169
we're really testing is something just

00:07:00,460 --> 00:07:04,000
below it we're testing this object that

00:07:02,169 --> 00:07:07,470
is used to build our views but not

00:07:04,000 --> 00:07:07,470
actually what our users were saying

00:07:08,940 --> 00:07:13,090
another kind of pattern I've seen to

00:07:11,199 --> 00:07:15,520
handle this complexity is just adding

00:07:13,090 --> 00:07:17,460
more logic to partials this is something

00:07:15,520 --> 00:07:20,740
we're especially guilty of here Gabe are

00:07:17,460 --> 00:07:22,449
we have we have templates to have a lot

00:07:20,740 --> 00:07:25,630
of Ruby in them and this does simplify

00:07:22,449 --> 00:07:28,270
our logic it puts it in one place but

00:07:25,630 --> 00:07:30,690
it's hard to test so taking a look at

00:07:28,270 --> 00:07:33,940
the previous view model example

00:07:30,690 --> 00:07:36,340
translating it into some in-line ARB we

00:07:33,940 --> 00:07:38,710
can assign the result of the ternary to

00:07:36,340 --> 00:07:42,909
a status variable and then render inside

00:07:38,710 --> 00:07:45,550
an h2 tag and practice though this gets

00:07:42,909 --> 00:07:47,530
much worse so we often end up with files

00:07:45,550 --> 00:07:50,259
that have Ruby blocks dozens of lines

00:07:47,530 --> 00:07:52,210
long this is one that I very much

00:07:50,259 --> 00:07:56,169
simplified from our code base that is in

00:07:52,210 --> 00:07:59,889
fact dozens of lines long the issue with

00:07:56,169 --> 00:08:01,780
this is that this logic can't be tested

00:07:59,889 --> 00:08:05,530
directly since rails doesn't give us a

00:08:01,780 --> 00:08:07,449
way to unit tests or views so that's

00:08:05,530 --> 00:08:08,889
what I've seen but when I starting to

00:08:07,449 --> 00:08:11,259
look into this I was wondering whether

00:08:08,889 --> 00:08:12,969
my experience was a reflection of the

00:08:11,259 --> 00:08:15,940
greater rails ecosystem or just what I

00:08:12,969 --> 00:08:18,280
had seen so I did a survey I asked my

00:08:15,940 --> 00:08:21,009
local ruby group the wonderful boulder

00:08:18,280 --> 00:08:23,440
ruby group it's about 50 people asked

00:08:21,009 --> 00:08:27,090
them to share their application folders

00:08:23,440 --> 00:08:30,520
just screenshots and here's what I found

00:08:27,090 --> 00:08:33,370
some people use decorators sometimes

00:08:30,520 --> 00:08:36,219
people use presenters but often people

00:08:33,370 --> 00:08:38,469
are using more than one and in more than

00:08:36,219 --> 00:08:39,969
half the responses people had view

00:08:38,469 --> 00:08:42,310
related abstractions that were not

00:08:39,969 --> 00:08:44,920
provided by rails and in my experience

00:08:42,310 --> 00:08:47,649
every app of any scale that I've worked

00:08:44,920 --> 00:08:49,480
in has used one of these we can also see

00:08:47,649 --> 00:08:52,029
this also see this trend in the rails

00:08:49,480 --> 00:08:54,850
ecosystem there are some popular jumps

00:08:52,029 --> 00:08:56,140
for these patterns for example Draper

00:08:54,850 --> 00:08:59,370
and cells are two of them and they

00:08:56,140 --> 00:08:59,370
together have millions of downloads

00:09:00,470 --> 00:09:06,050
I think it's clear something is missing

00:09:03,860 --> 00:09:08,300
here why are we turning to these

00:09:06,050 --> 00:09:11,450
abstractions why are we breaking from

00:09:08,300 --> 00:09:13,670
rails convention and in asking further

00:09:11,450 --> 00:09:17,800
to the people who are responding to that

00:09:13,670 --> 00:09:20,480
survey it really comes down to testing

00:09:17,800 --> 00:09:22,580
so one of my favorite ways to talk about

00:09:20,480 --> 00:09:24,320
testing is within the context of martin

00:09:22,580 --> 00:09:26,510
fowler's test pyramid i think it's

00:09:24,320 --> 00:09:27,830
really a great illustration of the

00:09:26,510 --> 00:09:31,220
trade-offs of different types of tests

00:09:27,830 --> 00:09:33,830
so on the y-axis we have speed and cost

00:09:31,220 --> 00:09:35,600
we're at the top we have the tests that

00:09:33,830 --> 00:09:37,310
are the slowest and most thus most

00:09:35,600 --> 00:09:38,960
expensive and the bottom we have the

00:09:37,310 --> 00:09:41,120
ones are the fastest and that's the

00:09:38,960 --> 00:09:42,530
least costly and the pyramid basically

00:09:41,120 --> 00:09:45,680
prescribes that we should be writing as

00:09:42,530 --> 00:09:47,900
few of the tests at the top as possible

00:09:45,680 --> 00:09:51,200
and generally be writing more at the

00:09:47,900 --> 00:09:53,600
bottom in the context of rails rails

00:09:51,200 --> 00:09:56,750
provides UI tests which you can think of

00:09:53,600 --> 00:09:59,660
as system tests and service tests would

00:09:56,750 --> 00:10:01,280
you can think of as controller tests but

00:09:59,660 --> 00:10:03,800
rails does not give us a way to write

00:10:01,280 --> 00:10:06,050
unit tests for our views which limits us

00:10:03,800 --> 00:10:09,860
to the must extend most expensive

00:10:06,050 --> 00:10:11,990
options so as our apps grow we often

00:10:09,860 --> 00:10:14,240
turn to view objects in part because

00:10:11,990 --> 00:10:15,770
they can be unit tested enabling more

00:10:14,240 --> 00:10:17,390
thorough coverage of our view layer

00:10:15,770 --> 00:10:23,150
without the high cost of those

00:10:17,390 --> 00:10:25,070
controller or system tests but even if

00:10:23,150 --> 00:10:26,750
our views could be unit tested my

00:10:25,070 --> 00:10:29,300
exploration of this problem really

00:10:26,750 --> 00:10:31,610
pointed to a bigger issue and it's one

00:10:29,300 --> 00:10:34,190
of encapsulation so what is

00:10:31,610 --> 00:10:36,310
encapsulation according to the fountain

00:10:34,190 --> 00:10:37,630
of knowledge that is Wikipedia in

00:10:36,310 --> 00:10:39,800
object-oriented programming

00:10:37,630 --> 00:10:41,930
encapsulation refers to the bundling of

00:10:39,800 --> 00:10:44,150
data with methods that operate on that

00:10:41,930 --> 00:10:47,870
data or the restriction of direct access

00:10:44,150 --> 00:10:50,720
to some of an object's components to me

00:10:47,870 --> 00:10:53,660
not being computer scientist this really

00:10:50,720 --> 00:10:55,040
is what I would use as a description of

00:10:53,660 --> 00:10:58,190
object-oriented programming in general

00:10:55,040 --> 00:11:01,670
and rails does provide some

00:10:58,190 --> 00:11:03,230
encapsulation some of the time models

00:11:01,670 --> 00:11:05,660
are pretty well encapsulated for example

00:11:03,230 --> 00:11:08,810
so if we look at say an example user

00:11:05,660 --> 00:11:09,500
model if we have a named instance method

00:11:08,810 --> 00:11:12,350
that's public

00:11:09,500 --> 00:11:13,790
that's bundling of access while our

00:11:12,350 --> 00:11:15,950
welcome email callback

00:11:13,790 --> 00:11:19,790
method would be a private method that is

00:11:15,950 --> 00:11:21,530
restricted from direct access then when

00:11:19,790 --> 00:11:23,300
we go to test our user model we test

00:11:21,530 --> 00:11:26,330
against that public interface but not

00:11:23,300 --> 00:11:28,760
against private methods rails

00:11:26,330 --> 00:11:30,740
controllers are also encapsulated take

00:11:28,760 --> 00:11:33,350
for example a user's controller that

00:11:30,740 --> 00:11:33,860
show method is bundling of access to

00:11:33,350 --> 00:11:36,440
data

00:11:33,860 --> 00:11:41,060
well that private current user method is

00:11:36,440 --> 00:11:43,280
that restriction from direct access and

00:11:41,060 --> 00:11:44,960
then when we go to test it we're doing

00:11:43,280 --> 00:11:47,150
it in a slightly direct way but we're

00:11:44,960 --> 00:11:51,440
still in a way interfacing with that

00:11:47,150 --> 00:11:53,030
show method and our assertion is against

00:11:51,440 --> 00:11:57,400
the result of the current user method

00:11:53,030 --> 00:11:57,400
but not actually calling it directly so

00:11:58,840 --> 00:12:04,010
what about views so the closest thing we

00:12:02,390 --> 00:12:06,080
get to encapsulate encapsulation in

00:12:04,010 --> 00:12:08,810
views is that local variable assignment

00:12:06,080 --> 00:12:11,150
inside the template but when it comes to

00:12:08,810 --> 00:12:13,250
testing our views don't have a public

00:12:11,150 --> 00:12:15,560
interface so we can't really unit test

00:12:13,250 --> 00:12:19,310
them and at least rails doesn't give us

00:12:15,560 --> 00:12:21,080
a way to so to see why encapsulation of

00:12:19,310 --> 00:12:23,840
views is an issue we really need to

00:12:21,080 --> 00:12:27,410
understand how they work so what are

00:12:23,840 --> 00:12:30,020
views unlike models and controllers they

00:12:27,410 --> 00:12:33,020
aren't objects so let's look at some

00:12:30,020 --> 00:12:35,870
example code so we're gonna take a deep

00:12:33,020 --> 00:12:39,200
dive into the explicit render of a

00:12:35,870 --> 00:12:41,300
partial from another file we're gonna do

00:12:39,200 --> 00:12:43,490
it with some example code in this case

00:12:41,300 --> 00:12:48,230
we're gonna use two views the first view

00:12:43,490 --> 00:12:50,570
app views demo index.html RB assigns on

00:12:48,230 --> 00:12:53,270
the first line an instance variable of

00:12:50,570 --> 00:12:55,910
message to be the string hello world and

00:12:53,270 --> 00:12:59,420
then on the second line renders a

00:12:55,910 --> 00:13:01,970
partial called message in the second

00:12:59,420 --> 00:13:05,210
view our message partial app views demo

00:13:01,970 --> 00:13:07,670
message HTML ARB we have an h1 tag the

00:13:05,210 --> 00:13:11,600
inside of it we are rendering the value

00:13:07,670 --> 00:13:13,940
of the instance variable message so when

00:13:11,600 --> 00:13:17,090
I went to go write write this talk I

00:13:13,940 --> 00:13:18,800
didn't expect this to work but what's

00:13:17,090 --> 00:13:21,770
interesting is that when we render that

00:13:18,800 --> 00:13:24,260
index page the second view is able to

00:13:21,770 --> 00:13:27,660
access the instance variable from the

00:13:24,260 --> 00:13:29,490
first so that made me wonder

00:13:27,660 --> 00:13:32,130
what happens when that render method is

00:13:29,490 --> 00:13:34,170
called and it turns out a lot happens

00:13:32,130 --> 00:13:37,100
it's honestly one of the more beautiful

00:13:34,170 --> 00:13:39,270
pieces of engineering I've seen and

00:13:37,100 --> 00:13:40,620
unfortunately it's so complex that I

00:13:39,270 --> 00:13:42,030
can't go over all of it today but I

00:13:40,620 --> 00:13:45,990
wanted to share one of some of the more

00:13:42,030 --> 00:13:48,030
interesting parts so let's skip seven or

00:13:45,990 --> 00:13:50,090
eight steps down the call stack and go

00:13:48,030 --> 00:13:51,750
straight to action view template render

00:13:50,090 --> 00:13:54,450
so when the first things that's

00:13:51,750 --> 00:13:57,560
interesting about this method is that it

00:13:54,450 --> 00:14:02,990
calls another method called compile bang

00:13:57,560 --> 00:14:05,490
now we're in Ruby land what are we doing

00:14:02,990 --> 00:14:09,750
using the word compile Ruby is a dynamic

00:14:05,490 --> 00:14:11,670
language what even is compilation so

00:14:09,750 --> 00:14:14,340
let's have a look so in that compiled

00:14:11,670 --> 00:14:16,830
bag method there is this helpful comment

00:14:14,340 --> 00:14:18,840
to start so let's start there compile a

00:14:16,830 --> 00:14:21,750
template this method ensures a template

00:14:18,840 --> 00:14:24,930
is compiled just once and removes the

00:14:21,750 --> 00:14:26,820
source after it is compiled this method

00:14:24,930 --> 00:14:30,120
itself wraps the non-bang compiled

00:14:26,820 --> 00:14:33,540
method and it passes in this variable

00:14:30,120 --> 00:14:35,400
called mod which is view dot compiled

00:14:33,540 --> 00:14:40,440
method container you can think of this

00:14:35,400 --> 00:14:42,570
as the action view base class so going

00:14:40,440 --> 00:14:44,280
to that non-bank compiled method the

00:14:42,570 --> 00:14:47,280
first interesting piece of this is a

00:14:44,280 --> 00:14:50,610
line called code equals at handler call

00:14:47,280 --> 00:14:52,890
self source so let's go through the

00:14:50,610 --> 00:14:55,380
steps of the state of our application at

00:14:52,890 --> 00:14:58,170
this point in time so we're calling that

00:14:55,380 --> 00:15:00,780
line code equals handler call self

00:14:58,170 --> 00:15:03,120
source so first let's look at what

00:15:00,780 --> 00:15:05,610
handlers handler is an action view

00:15:03,120 --> 00:15:07,650
template handlers ARB which for the sake

00:15:05,610 --> 00:15:09,480
of this exploration we can think of as

00:15:07,650 --> 00:15:12,720
an object that is going to help us work

00:15:09,480 --> 00:15:14,640
with ARB self is an instance of action

00:15:12,720 --> 00:15:17,670
view template among other things this

00:15:14,640 --> 00:15:21,000
object includes the path to the template

00:15:17,670 --> 00:15:22,770
we're working on and then source is the

00:15:21,000 --> 00:15:25,770
source of that template should look very

00:15:22,770 --> 00:15:30,000
familiar so when we call this line it

00:15:25,770 --> 00:15:32,760
returns the string and if we break this

00:15:30,000 --> 00:15:34,740
into multiple lines we can see that what

00:15:32,760 --> 00:15:40,110
handler call has done here is it's

00:15:34,740 --> 00:15:42,240
turned our ARB into Ruby so

00:15:40,110 --> 00:15:45,120
that can action view template we've

00:15:42,240 --> 00:15:46,440
compiled our template into Ruby code so

00:15:45,120 --> 00:15:50,000
now we're going to use it to define a

00:15:46,440 --> 00:15:55,829
method so let's look at the state again

00:15:50,000 --> 00:15:58,920
so method name here is a path plus some

00:15:55,829 --> 00:16:01,170
sort of collision prevention virtual

00:15:58,920 --> 00:16:03,360
path not inspect is a shorthand name for

00:16:01,170 --> 00:16:05,820
our template and then the code is the

00:16:03,360 --> 00:16:08,220
output of that handler comm method the

00:16:05,820 --> 00:16:10,320
compiled version of our template so we

00:16:08,220 --> 00:16:13,019
end up with here is we have a method

00:16:10,320 --> 00:16:14,880
with that generated a name and then a

00:16:13,019 --> 00:16:19,140
body generated by the call to the

00:16:14,880 --> 00:16:22,860
handler so back in action view template

00:16:19,140 --> 00:16:25,500
we then take that method and we evaluate

00:16:22,860 --> 00:16:28,260
it on to action view base that compiled

00:16:25,500 --> 00:16:30,050
method container so if we look at action

00:16:28,260 --> 00:16:34,500
view base at the end of this process

00:16:30,050 --> 00:16:35,940
what we end up with is a method for each

00:16:34,500 --> 00:16:37,890
of the views in our application so you

00:16:35,940 --> 00:16:40,620
can see here we have our index template

00:16:37,890 --> 00:16:45,000
our message partial and then as it turns

00:16:40,620 --> 00:16:46,560
out also our application layout so this

00:16:45,000 --> 00:16:49,649
is really the end of the road we've

00:16:46,560 --> 00:16:51,510
compiled our template all that's left to

00:16:49,649 --> 00:16:54,560
do is to run it so let's look at the

00:16:51,510 --> 00:16:56,730
state here so we have this method named

00:16:54,560 --> 00:16:58,230
using the same method name we did we

00:16:56,730 --> 00:17:01,500
used it the compilation step so we're

00:16:58,230 --> 00:17:03,240
looking at that same result self is

00:17:01,500 --> 00:17:07,079
again in an instance of action be

00:17:03,240 --> 00:17:08,640
template and then buffer is action view

00:17:07,079 --> 00:17:11,730
output buffer which you can think of as

00:17:08,640 --> 00:17:14,250
a string that we are going to shove all

00:17:11,730 --> 00:17:17,270
the HTML we're generating into to be

00:17:14,250 --> 00:17:20,910
returned by the controller in this case

00:17:17,270 --> 00:17:23,669
so inside this run method we set the

00:17:20,910 --> 00:17:25,470
current template and buffer and then

00:17:23,669 --> 00:17:28,260
call the compiled method that we defined

00:17:25,470 --> 00:17:31,140
above with send so we effectively end up

00:17:28,260 --> 00:17:33,720
with this calling that method that we

00:17:31,140 --> 00:17:36,210
generated earlier so that's what happens

00:17:33,720 --> 00:17:40,380
when you render a view in rails at

00:17:36,210 --> 00:17:42,270
runtime so what does this all mean what

00:17:40,380 --> 00:17:47,490
are the implications and what does this

00:17:42,270 --> 00:17:49,200
have to do with encapsulation first and

00:17:47,490 --> 00:17:50,520
foremost if you take nothing else away

00:17:49,200 --> 00:17:52,770
from this presentation

00:17:50,520 --> 00:17:53,420
it's that views are compiled into

00:17:52,770 --> 00:17:57,400
methods

00:17:53,420 --> 00:18:00,410
in this the execute in the same context

00:17:57,400 --> 00:18:02,300
so we look at our templates again and

00:18:00,410 --> 00:18:04,280
run them through compilation this is

00:18:02,300 --> 00:18:07,160
more or less what rails sees it sees

00:18:04,280 --> 00:18:09,410
sibling methods that allow it to that on

00:18:07,160 --> 00:18:11,420
the same object that allows to share

00:18:09,410 --> 00:18:14,660
instant gist variables across views on

00:18:11,420 --> 00:18:18,200
action view base so when we render that

00:18:14,660 --> 00:18:20,750
index actor when we call to render that

00:18:18,200 --> 00:18:22,820
index template we set the message

00:18:20,750 --> 00:18:25,670
instance variable to the value of hello

00:18:22,820 --> 00:18:27,290
world and then when we go to render the

00:18:25,670 --> 00:18:29,180
message partial all we're doing is

00:18:27,290 --> 00:18:33,320
calling another instance method on

00:18:29,180 --> 00:18:35,540
action view base where we have access to

00:18:33,320 --> 00:18:39,350
the message instance variable in our

00:18:35,540 --> 00:18:41,180
rendered output so what what this all

00:18:39,350 --> 00:18:43,400
really means is that our views are

00:18:41,180 --> 00:18:46,100
executing in a global scope all of them

00:18:43,400 --> 00:18:47,960
are on the same scope this includes all

00:18:46,100 --> 00:18:50,030
of our helpers and because they're all

00:18:47,960 --> 00:18:54,200
in the same context the music can all

00:18:50,030 --> 00:18:57,140
share state which in my mind is really

00:18:54,200 --> 00:18:59,870
kind of the opposite of encapsulation so

00:18:57,140 --> 00:19:02,720
in our application we have over 4400

00:18:59,870 --> 00:19:04,700
view files and they're all executing in

00:19:02,720 --> 00:19:08,720
the same scope which makes it really

00:19:04,700 --> 00:19:10,700
hard when we go to debug them to reason

00:19:08,720 --> 00:19:13,850
about their execution behavior because

00:19:10,700 --> 00:19:14,990
they're in this global context this also

00:19:13,850 --> 00:19:16,400
means that unit testing them is very

00:19:14,990 --> 00:19:19,670
difficult because you can't really

00:19:16,400 --> 00:19:21,890
isolate them and ultimately this is a

00:19:19,670 --> 00:19:23,360
problem because views have a very high

00:19:21,890 --> 00:19:25,970
business value views are what we

00:19:23,360 --> 00:19:27,470
ultimately ship to our users and yet

00:19:25,970 --> 00:19:31,130
because of these problems they're often

00:19:27,470 --> 00:19:33,530
a blind spot in our architecture so

00:19:31,130 --> 00:19:36,620
given all of this I had to wonder what

00:19:33,530 --> 00:19:38,600
my encapsulated views look like well we

00:19:36,620 --> 00:19:41,690
already kind of know decorators

00:19:38,600 --> 00:19:43,160
presenters and components are attempts

00:19:41,690 --> 00:19:45,950
to bring encapsulation to the view layer

00:19:43,160 --> 00:19:49,580
and all these are solutions that make

00:19:45,950 --> 00:19:52,460
them easier to test so I spent most of

00:19:49,580 --> 00:19:55,010
2019 incorporating these ideas into a

00:19:52,460 --> 00:19:59,750
vision for how we could address these

00:19:55,010 --> 00:20:01,910
issues and it's called view component so

00:19:59,750 --> 00:20:03,950
first and foremost view components are

00:20:01,910 --> 00:20:06,230
encapsulated instead of having one

00:20:03,950 --> 00:20:07,100
context for all views we have one

00:20:06,230 --> 00:20:12,470
context

00:20:07,100 --> 00:20:14,840
per view so take this example this is

00:20:12,470 --> 00:20:15,580
what components look like in a very

00:20:14,840 --> 00:20:18,679
simple case

00:20:15,580 --> 00:20:21,080
so in our app components directory we

00:20:18,679 --> 00:20:23,090
have a message component Ruby file in

00:20:21,080 --> 00:20:26,740
this case our message component takes a

00:20:23,090 --> 00:20:30,110
single named argument it assigns it to a

00:20:26,740 --> 00:20:32,240
message instance variable and then next

00:20:30,110 --> 00:20:34,580
to that component sits a message

00:20:32,240 --> 00:20:36,530
component template which has ER B that

00:20:34,580 --> 00:20:39,289
is basically just what was in our

00:20:36,530 --> 00:20:41,870
partial earlier and then when we want to

00:20:39,289 --> 00:20:43,809
go render this thing if we go to our app

00:20:41,870 --> 00:20:46,250
views demo index file

00:20:43,809 --> 00:20:50,390
let me call render we just pass in an

00:20:46,250 --> 00:20:52,250
instance of that component object so

00:20:50,390 --> 00:20:54,919
looking at that render call we already

00:20:52,250 --> 00:20:56,960
see some benefits here and one of them

00:20:54,919 --> 00:20:58,400
is that this component is referenced

00:20:56,960 --> 00:21:00,440
directly which means there's no

00:20:58,400 --> 00:21:03,130
ambiguity or translation in between say

00:21:00,440 --> 00:21:06,710
a string and then a template in our in

00:21:03,130 --> 00:21:07,940
our views directory so if we wanted to

00:21:06,710 --> 00:21:09,530
see every single place this message

00:21:07,940 --> 00:21:11,210
component is used we could just search

00:21:09,530 --> 00:21:16,429
our code base for that message component

00:21:11,210 --> 00:21:18,110
class name so looking back at our

00:21:16,429 --> 00:21:20,120
component we follow a similar

00:21:18,110 --> 00:21:24,409
compilation process to what we saw in

00:21:20,120 --> 00:21:26,330
our exploration of the view stack but

00:21:24,409 --> 00:21:28,580
instead of attaching the compiled view

00:21:26,330 --> 00:21:30,890
to some global context we attach it

00:21:28,580 --> 00:21:32,030
directly to the component object which

00:21:30,890 --> 00:21:34,610
means that when we're rendering this

00:21:32,030 --> 00:21:36,559
this template it doesn't have access to

00:21:34,610 --> 00:21:38,270
state from other views which means that

00:21:36,559 --> 00:21:39,590
we can safely use instance variables

00:21:38,270 --> 00:21:44,870
without worrying about them leaking

00:21:39,590 --> 00:21:47,179
across contexts it also enables us to

00:21:44,870 --> 00:21:50,480
encapsulate access to helpers so in this

00:21:47,179 --> 00:21:53,690
case we have a template that references

00:21:50,480 --> 00:21:54,799
the star icon helper in order to make it

00:21:53,690 --> 00:21:58,730
work we actually need to include that

00:21:54,799 --> 00:22:01,250
helper on the component we can also use

00:21:58,730 --> 00:22:03,200
a helpers dot escape hatch which is

00:22:01,250 --> 00:22:05,120
really similar to what rails gives you

00:22:03,200 --> 00:22:10,520
for accessing view helpers and

00:22:05,120 --> 00:22:12,799
controllers unit testing components is

00:22:10,520 --> 00:22:14,510
really simple we can render the

00:22:12,799 --> 00:22:16,790
component in line using a render and

00:22:14,510 --> 00:22:18,830
line helper and then assert against the

00:22:16,790 --> 00:22:20,840
rendered result using capybara matters

00:22:18,830 --> 00:22:22,580
which are the same that are which are

00:22:20,840 --> 00:22:25,820
same set of matters that are used by

00:22:22,580 --> 00:22:27,470
rail system tests what's nice though is

00:22:25,820 --> 00:22:30,640
that there's no browser being used

00:22:27,470 --> 00:22:33,110
underneath here so these are much faster

00:22:30,640 --> 00:22:35,510
so we published this library as a gem in

00:22:33,110 --> 00:22:37,250
August it was an extraction from the

00:22:35,510 --> 00:22:39,020
github monolith and this was actually my

00:22:37,250 --> 00:22:40,760
first open-source project and honestly

00:22:39,020 --> 00:22:42,650
I've been blown away by the support

00:22:40,760 --> 00:22:44,900
we've seen we've shipped I think at this

00:22:42,650 --> 00:22:47,270
point as of mid-april thirty nine

00:22:44,900 --> 00:22:49,960
releases including our second major

00:22:47,270 --> 00:22:51,799
release in late March of version 2.0

00:22:49,960 --> 00:22:53,690
most of our work has come from the

00:22:51,799 --> 00:22:55,399
community we've had over three dozen

00:22:53,690 --> 00:22:58,270
people contribute from all over the

00:22:55,399 --> 00:23:00,409
world some cool contributions include

00:22:58,270 --> 00:23:02,149
simple things like adding generator

00:23:00,409 --> 00:23:04,090
support this was added by the NAC s

00:23:02,149 --> 00:23:06,260
stock an engineer at Shopify

00:23:04,090 --> 00:23:08,690
we've also had more complex features

00:23:06,260 --> 00:23:11,510
contributed one Manuel Maya from

00:23:08,690 --> 00:23:12,770
Argentina at a component previews which

00:23:11,510 --> 00:23:16,100
are very much a variant of Miller

00:23:12,770 --> 00:23:18,679
previous so these are pretty cool just

00:23:16,100 --> 00:23:20,720
like mailers a component preview

00:23:18,679 --> 00:23:22,549
inherits from a preview class let me

00:23:20,720 --> 00:23:26,510
define a method for each preview in this

00:23:22,549 --> 00:23:28,399
case open and closed and then this

00:23:26,510 --> 00:23:29,809
generates a really simple UI that allows

00:23:28,399 --> 00:23:33,460
you to click on one of those states and

00:23:29,809 --> 00:23:35,690
see the component rendered by itself

00:23:33,460 --> 00:23:37,850
another really cool feature contributed

00:23:35,690 --> 00:23:40,720
by the community was with content areas

00:23:37,850 --> 00:23:43,789
contributed by John Palmer from Boston

00:23:40,720 --> 00:23:45,200
so to explain this feature let's look at

00:23:43,789 --> 00:23:50,929
the Box component from our primary

00:23:45,200 --> 00:23:52,789
design system so here's the HTML that it

00:23:50,929 --> 00:23:57,010
that is used to render this design

00:23:52,789 --> 00:24:03,350
element we have a header body and footer

00:23:57,010 --> 00:24:05,539
wrapped in a box on a box class div so

00:24:03,350 --> 00:24:08,390
let's go back to that example HTML and

00:24:05,539 --> 00:24:09,350
we write it as a view component so start

00:24:08,390 --> 00:24:11,539
with a component that renders that

00:24:09,350 --> 00:24:15,049
example code so we have our box

00:24:11,539 --> 00:24:17,330
component dot RB its associated template

00:24:15,049 --> 00:24:19,700
and that template just has that same

00:24:17,330 --> 00:24:22,340
source that we had before and then in

00:24:19,700 --> 00:24:24,850
our index action we'll render by passing

00:24:22,340 --> 00:24:27,320
an instance of that component its render

00:24:24,850 --> 00:24:29,419
so if we skip a few steps we might end

00:24:27,320 --> 00:24:32,990
up with a couple of components one for

00:24:29,419 --> 00:24:34,610
the header body and footer so you can

00:24:32,990 --> 00:24:36,860
see here we have a

00:24:34,610 --> 00:24:38,299
component now just renders the the

00:24:36,860 --> 00:24:41,090
content that's passed into it is a block

00:24:38,299 --> 00:24:44,030
and then in our index template we pass

00:24:41,090 --> 00:24:47,600
in a block that has three sub components

00:24:44,030 --> 00:24:52,100
rendered and this is really nice but we

00:24:47,600 --> 00:24:54,710
lose some benefits here so for example

00:24:52,100 --> 00:24:56,929
in our design system it's probably

00:24:54,710 --> 00:24:59,240
fairly obvious in this case but like you

00:24:56,929 --> 00:25:01,370
probably only want that header to be

00:24:59,240 --> 00:25:03,380
first you never want it to be after body

00:25:01,370 --> 00:25:05,210
or after footer and then same goes for

00:25:03,380 --> 00:25:07,549
footer you probably only ever want that

00:25:05,210 --> 00:25:09,500
to be the last element so while this

00:25:07,549 --> 00:25:12,860
architecture it's useful it doesn't

00:25:09,500 --> 00:25:15,169
prevent misuse of the design system so

00:25:12,860 --> 00:25:18,200
this is where this with content areas

00:25:15,169 --> 00:25:21,620
feature comes in so if we go back into

00:25:18,200 --> 00:25:24,790
our component we can declare a content

00:25:21,620 --> 00:25:26,960
area for the header body and footer and

00:25:24,790 --> 00:25:29,390
then in the template that renders the

00:25:26,960 --> 00:25:32,870
component we can refactor this usage of

00:25:29,390 --> 00:25:34,850
effectively four components to be the

00:25:32,870 --> 00:25:37,820
use to use just one component and

00:25:34,850 --> 00:25:40,010
instead use named blocks instead of

00:25:37,820 --> 00:25:42,890
those separate components so we pass in

00:25:40,010 --> 00:25:46,330
the named header block the named body

00:25:42,890 --> 00:25:48,830
block and the named footer block and

00:25:46,330 --> 00:25:52,000
then in our component template we can

00:25:48,830 --> 00:25:56,780
render that header body and footer

00:25:52,000 --> 00:25:58,040
inside the wrapping div what's great

00:25:56,780 --> 00:25:59,809
about this solution is that we've ended

00:25:58,040 --> 00:26:01,700
up with a codification of our design

00:25:59,809 --> 00:26:03,830
system that helps developers use it

00:26:01,700 --> 00:26:05,750
properly no matter what order they

00:26:03,830 --> 00:26:07,520
passes name blocks in we're always going

00:26:05,750 --> 00:26:11,870
to render the title body and footer in

00:26:07,520 --> 00:26:14,090
the correct place another cool thing is

00:26:11,870 --> 00:26:16,240
that since components are just Ruby

00:26:14,090 --> 00:26:18,110
classes we can extract them into gems

00:26:16,240 --> 00:26:19,400
and while we haven't done this yet

00:26:18,110 --> 00:26:22,100
ourselves we know of a few people who

00:26:19,400 --> 00:26:23,780
have one example is a company in the

00:26:22,100 --> 00:26:25,730
financial services industry they have a

00:26:23,780 --> 00:26:28,190
half dozen rails apps at this point that

00:26:25,730 --> 00:26:30,260
use a single gem the design that defines

00:26:28,190 --> 00:26:31,640
all the elements of their design system

00:26:30,260 --> 00:26:36,080
in this case there are buttons and

00:26:31,640 --> 00:26:38,600
labels here come from a gem but perhaps

00:26:36,080 --> 00:26:40,610
it's most exciting is that we've landed

00:26:38,600 --> 00:26:42,140
a pea art and rails to add native

00:26:40,610 --> 00:26:44,660
support for third-party component

00:26:42,140 --> 00:26:48,050
libraries like view component and this

00:26:44,660 --> 00:26:51,590
will be shipping in rails 6 1 shortly

00:26:48,050 --> 00:26:53,660
so what about performance the current

00:26:51,590 --> 00:26:55,220
implementation of rails views leads to

00:26:53,660 --> 00:26:58,610
some less than optimal caching behavior

00:26:55,220 --> 00:27:01,880
especially at our scale since views are

00:26:58,610 --> 00:27:03,740
compiled into methods at runtime after

00:27:01,880 --> 00:27:06,860
forking servers like unicorn and Puma

00:27:03,740 --> 00:27:10,010
spawn their working processes one part

00:27:06,860 --> 00:27:12,770
of the cold you know you see in rails

00:27:10,010 --> 00:27:14,540
apps there's often a cold first request

00:27:12,770 --> 00:27:17,720
render time that is higher than usual

00:27:14,540 --> 00:27:19,670
and that's because that compilation

00:27:17,720 --> 00:27:21,770
process is happening at our scale on

00:27:19,670 --> 00:27:24,800
every process of which there are

00:27:21,770 --> 00:27:27,290
thousands each time a process serves a

00:27:24,800 --> 00:27:30,830
view that hasn't seen before it has to

00:27:27,290 --> 00:27:32,390
compile that view first but with

00:27:30,830 --> 00:27:34,820
components we're able to get around this

00:27:32,390 --> 00:27:38,420
issue and that's because in the library

00:27:34,820 --> 00:27:40,100
we define an initializer that compiles

00:27:38,420 --> 00:27:42,470
all descendants of the view component

00:27:40,100 --> 00:27:43,970
based class and in practice this looks

00:27:42,470 --> 00:27:46,280
something like this so on our example

00:27:43,970 --> 00:27:48,100
component that template is compiled into

00:27:46,280 --> 00:27:50,480
a call method like we showed earlier and

00:27:48,100 --> 00:27:52,970
because this is in a rails initializer

00:27:50,480 --> 00:27:57,890
this happens at boot before worker

00:27:52,970 --> 00:28:00,140
processes are spawned we also see big

00:27:57,890 --> 00:28:02,180
speed benefits and testing so it's

00:28:00,140 --> 00:28:05,120
compared to cases from the github

00:28:02,180 --> 00:28:07,100
codebase the first is a very I would

00:28:05,120 --> 00:28:09,500
call typical component tests of the

00:28:07,100 --> 00:28:11,780
issues state component it makes a couple

00:28:09,500 --> 00:28:14,900
assertions against the DOM and it takes

00:28:11,780 --> 00:28:16,310
about 20 milliseconds so let's compare

00:28:14,900 --> 00:28:17,960
this to one of the simplest controller

00:28:16,310 --> 00:28:20,150
tests I could find in our code base this

00:28:17,960 --> 00:28:22,040
one loads the user profile settings page

00:28:20,150 --> 00:28:24,950
and just simply asserts that it was a

00:28:22,040 --> 00:28:27,380
200 this test takes about one and a half

00:28:24,950 --> 00:28:30,320
seconds in our code base which is 73

00:28:27,380 --> 00:28:33,680
times slower now keep in mind this is a

00:28:30,320 --> 00:28:35,360
conservative case a typical component

00:28:33,680 --> 00:28:38,000
test against really what I would call a

00:28:35,360 --> 00:28:39,590
best case controller test the more

00:28:38,000 --> 00:28:43,100
typical difference is around a hundred

00:28:39,590 --> 00:28:44,900
times or two orders of magnitude so for

00:28:43,100 --> 00:28:47,140
a real world example these are the test

00:28:44,900 --> 00:28:49,610
cases for our issues state component

00:28:47,140 --> 00:28:51,470
there are six of them if they were

00:28:49,610 --> 00:28:53,330
controller tests in the best case

00:28:51,470 --> 00:28:56,150
scenario it would take nine seconds to

00:28:53,330 --> 00:28:58,750
run them as unit tests they take 120

00:28:56,150 --> 00:28:58,750
milliseconds

00:29:00,680 --> 00:29:04,980
but perhaps more importantly because of

00:29:03,390 --> 00:29:06,600
this abstraction layer we can write

00:29:04,980 --> 00:29:08,880
tested a more appropriate level of

00:29:06,600 --> 00:29:10,920
abstraction so looking back at our

00:29:08,880 --> 00:29:12,840
testing pyramid we had to test our views

00:29:10,920 --> 00:29:14,550
at the controller layer which means that

00:29:12,840 --> 00:29:16,740
for partials that we reuse across the

00:29:14,550 --> 00:29:19,440
app we end up testing them in each place

00:29:16,740 --> 00:29:21,420
that we use them so take for example the

00:29:19,440 --> 00:29:23,850
issue badge component we use it four

00:29:21,420 --> 00:29:25,920
times and three different files which

00:29:23,850 --> 00:29:27,630
means that without unit tests we'd

00:29:25,920 --> 00:29:29,490
likely end up with testing it in

00:29:27,630 --> 00:29:31,800
multiple controller tests which further

00:29:29,490 --> 00:29:35,670
increases the performance impact of this

00:29:31,800 --> 00:29:37,620
of this lack of abstraction but ours at

00:29:35,670 --> 00:29:39,150
our scale the consequences of this

00:29:37,620 --> 00:29:42,150
problem are in fact much more

00:29:39,150 --> 00:29:43,470
significant because as you met as you

00:29:42,150 --> 00:29:46,200
know I mentioned earlier that we have

00:29:43,470 --> 00:29:49,380
over 4400 views in our monolith and of

00:29:46,200 --> 00:29:50,280
those views over 3,000 or partials which

00:29:49,380 --> 00:29:51,990
means that there is a lot of

00:29:50,280 --> 00:29:54,750
opportunities for duplicate controller

00:29:51,990 --> 00:29:57,600
tests so looking back at our testing

00:29:54,750 --> 00:30:01,170
pyramid by using components with unit

00:29:57,600 --> 00:30:03,390
tests we can test our view layer

00:30:01,170 --> 00:30:06,390
permutations thoroughly at the unit

00:30:03,390 --> 00:30:08,010
level without duplication this allows us

00:30:06,390 --> 00:30:10,710
to leave the most the more expensive

00:30:08,010 --> 00:30:14,060
service and UI tests for happy path

00:30:10,710 --> 00:30:16,350
assertions instead of permutation checks

00:30:14,060 --> 00:30:17,970
so we've learned a lot in the past year

00:30:16,350 --> 00:30:19,740
of experimenting with this pattern and

00:30:17,970 --> 00:30:23,940
not all the things we learned have been

00:30:19,740 --> 00:30:25,280
good perhaps the biggest mistake we've

00:30:23,940 --> 00:30:29,160
made when working with this architecture

00:30:25,280 --> 00:30:31,770
was using validations so for example we

00:30:29,160 --> 00:30:34,260
have an avatar component as a few

00:30:31,770 --> 00:30:36,660
constants it says a default size of 20

00:30:34,260 --> 00:30:40,290
and a constant that defines the allowed

00:30:36,660 --> 00:30:42,060
sizes as that default size and 32 in

00:30:40,290 --> 00:30:43,920
order to help developers use the

00:30:42,060 --> 00:30:45,690
component correctly we figured why not

00:30:43,920 --> 00:30:47,070
use active model validations to check

00:30:45,690 --> 00:30:49,620
that that size that's provided the

00:30:47,070 --> 00:30:51,840
component is valid this also let us

00:30:49,620 --> 00:30:54,480
write code that expected size to be one

00:30:51,840 --> 00:30:56,640
of those allowed values and while this

00:30:54,480 --> 00:30:59,430
was all well and good it came at a real

00:30:56,640 --> 00:31:01,770
price and if we paid that price in

00:30:59,430 --> 00:31:03,300
production this is a deploy to some test

00:31:01,770 --> 00:31:05,340
servers we're just a look we send a

00:31:03,300 --> 00:31:08,820
little bit of traffic it's what we call

00:31:05,340 --> 00:31:10,800
it canary to play and we had a presence

00:31:08,820 --> 00:31:12,270
validation error that was not caught by

00:31:10,800 --> 00:31:12,809
tests we had a case where something

00:31:12,270 --> 00:31:14,700
wasn't

00:31:12,809 --> 00:31:16,320
and one was supposed to be and well this

00:31:14,700 --> 00:31:18,299
only affected a couple of users and was

00:31:16,320 --> 00:31:20,789
quickly rolled back before really more

00:31:18,299 --> 00:31:21,809
than a few dozen people could notice we

00:31:20,789 --> 00:31:24,659
knew that we need to rethink our

00:31:21,809 --> 00:31:27,450
approach to the way components would

00:31:24,659 --> 00:31:29,909
handle invalid input so we came up with

00:31:27,450 --> 00:31:32,549
was a simple helper that we call fetch

00:31:29,909 --> 00:31:34,440
or fall back so fetch or fall back is

00:31:32,549 --> 00:31:36,269
just one method that's your fallback it

00:31:34,440 --> 00:31:39,169
takes three arguments an array of

00:31:36,269 --> 00:31:42,960
allowed valuable values a given value

00:31:39,169 --> 00:31:44,909
and a fallback and then what we do is we

00:31:42,960 --> 00:31:48,059
check to see if our list of allowed

00:31:44,909 --> 00:31:50,580
values include the given value and if it

00:31:48,059 --> 00:31:53,490
does we just return it and if it doesn't

00:31:50,580 --> 00:31:55,259
we return the fallback however if we're

00:31:53,490 --> 00:31:59,009
running in development we raise a really

00:31:55,259 --> 00:32:00,119
nice helpful error message so this gives

00:31:59,009 --> 00:32:03,330
us the feedback we wanted from

00:32:00,119 --> 00:32:04,980
validations and the safety knowing that

00:32:03,330 --> 00:32:07,789
we are working with a value we expect

00:32:04,980 --> 00:32:09,690
without raising exceptions in production

00:32:07,789 --> 00:32:11,940
so if you look back at that avatar

00:32:09,690 --> 00:32:13,830
component instead of using a validation

00:32:11,940 --> 00:32:16,889
on the size attribute we use fetch or

00:32:13,830 --> 00:32:20,460
fall back to safely guarantee that size

00:32:16,889 --> 00:32:21,960
is one of the values we expect the

00:32:20,460 --> 00:32:24,389
lesson we learned here is ultimately one

00:32:21,960 --> 00:32:26,340
of designing for resiliency we hadn't

00:32:24,389 --> 00:32:28,049
fully understood the downstream risks of

00:32:26,340 --> 00:32:30,360
using validations in our components and

00:32:28,049 --> 00:32:32,159
more broadly we learned that designing

00:32:30,360 --> 00:32:35,639
error cases out of our systems is of

00:32:32,159 --> 00:32:37,919
utmost importance another thing we've

00:32:35,639 --> 00:32:41,159
learned is that refactoring code to use

00:32:37,919 --> 00:32:43,350
components often exposes complexity we

00:32:41,159 --> 00:32:45,600
weren't aware of so one of the most

00:32:43,350 --> 00:32:48,299
complex examples has been the details

00:32:45,600 --> 00:32:51,570
dialog partial we have it has it's used

00:32:48,299 --> 00:32:54,659
right around 220 times in about 150

00:32:51,570 --> 00:32:57,149
files and it's massive it handles a ton

00:32:54,659 --> 00:32:59,850
of complexity in use cases has 17

00:32:57,149 --> 00:33:01,529
different local variables and refactor

00:32:59,850 --> 00:33:03,629
it into a component this complexity

00:33:01,529 --> 00:33:07,350
becomes more visible the initializer

00:33:03,629 --> 00:33:09,629
takes 17 possible arguments and even

00:33:07,350 --> 00:33:11,249
more so than the view this focus this

00:33:09,629 --> 00:33:13,830
really forces us to reckon with that

00:33:11,249 --> 00:33:16,470
complexity but it also allows us some

00:33:13,830 --> 00:33:18,840
safety as we can at least unit test to

00:33:16,470 --> 00:33:21,269
that component thoroughly in this case

00:33:18,840 --> 00:33:23,460
we have 20 cases or so and we could

00:33:21,269 --> 00:33:25,529
probably use more but because we can

00:33:23,460 --> 00:33:26,800
write unit tests we can also refactor

00:33:25,529 --> 00:33:29,020
and that's exactly

00:33:26,800 --> 00:33:31,030
happening as we've exposes complexity

00:33:29,020 --> 00:33:33,070
people are more aware of it and they're

00:33:31,030 --> 00:33:36,490
working to refactor the component to be

00:33:33,070 --> 00:33:37,810
drastically simpler another lesson we've

00:33:36,490 --> 00:33:40,180
learned from working with components has

00:33:37,810 --> 00:33:41,740
been the power of consistency when an

00:33:40,180 --> 00:33:44,140
example of this was building the pr

00:33:41,740 --> 00:33:45,760
state component it's this little badge

00:33:44,140 --> 00:33:47,410
the one here that has the icon and the

00:33:45,760 --> 00:33:49,900
word open and we render it in 9

00:33:47,410 --> 00:33:51,340
different places in our application and

00:33:49,900 --> 00:33:53,230
when we want to implement the component

00:33:51,340 --> 00:33:55,510
the existing view code was more or less

00:33:53,230 --> 00:33:57,550
just copy and paste it for each usage

00:33:55,510 --> 00:33:59,320
and as we were factored to use the

00:33:57,550 --> 00:34:01,480
component we realized that several of

00:33:59,320 --> 00:34:03,100
the cases cases had never been updated

00:34:01,480 --> 00:34:05,470
to handle draft pull requests which was

00:34:03,100 --> 00:34:06,790
a feature we had recently shipped so by

00:34:05,470 --> 00:34:08,920
using the component we were able to

00:34:06,790 --> 00:34:10,900
ensure that we consistently handled that

00:34:08,920 --> 00:34:13,770
case and provided a really nice high

00:34:10,900 --> 00:34:16,000
quality experience to our users

00:34:13,770 --> 00:34:18,030
another benefit this component exposed

00:34:16,000 --> 00:34:20,830
is how we can benefit from composition

00:34:18,030 --> 00:34:22,750
so is it this component itself is a

00:34:20,830 --> 00:34:24,760
wrapper of another component from our

00:34:22,750 --> 00:34:26,650
design system in this case it renders

00:34:24,760 --> 00:34:28,270
the primer state component based on

00:34:26,650 --> 00:34:30,280
arguments that we translate from a pull

00:34:28,270 --> 00:34:32,020
request object and this is a common

00:34:30,280 --> 00:34:33,940
pattern that has come out as we've built

00:34:32,020 --> 00:34:35,440
components in our application we have an

00:34:33,940 --> 00:34:38,020
application specific component that

00:34:35,440 --> 00:34:40,210
takes a say an active record object like

00:34:38,020 --> 00:34:42,400
a pull request and maps it into a

00:34:40,210 --> 00:34:46,570
component from our design system in this

00:34:42,400 --> 00:34:48,400
case our state component another cool

00:34:46,570 --> 00:34:51,340
example is the primer layout component

00:34:48,400 --> 00:34:53,169
built by my colleague John Rohan we use

00:34:51,340 --> 00:34:55,090
this component to render a simple layout

00:34:53,169 --> 00:34:56,919
that is a main content body and a

00:34:55,090 --> 00:34:58,930
sidebar and this is an action today

00:34:56,919 --> 00:35:01,240
amongst other places on pole request

00:34:58,930 --> 00:35:03,640
pages rendering this main content body

00:35:01,240 --> 00:35:05,020
and then the sidebar where you see

00:35:03,640 --> 00:35:07,390
amongst other things like labels and

00:35:05,020 --> 00:35:09,790
reviewers so here's what it looks like

00:35:07,390 --> 00:35:11,620
under the hood this object in the

00:35:09,790 --> 00:35:13,960
initializer takes a couple arguments it

00:35:11,620 --> 00:35:17,440
takes whether or not the responsive mode

00:35:13,960 --> 00:35:19,780
is enabled or not what side the sidebar

00:35:17,440 --> 00:35:21,550
should appear on it uses in this case we

00:35:19,780 --> 00:35:23,500
use some constants we have a default

00:35:21,550 --> 00:35:27,640
side of right and then we allow it to be

00:35:23,500 --> 00:35:30,390
set to either right or left we use fetch

00:35:27,640 --> 00:35:33,150
or fall back to make sure that that side

00:35:30,390 --> 00:35:36,340
argument that's passed in is one of the

00:35:33,150 --> 00:35:37,990
one of the ones we allow and we also

00:35:36,340 --> 00:35:39,940
leverage that multiple content area

00:35:37,990 --> 00:35:43,930
feature to capture

00:35:39,940 --> 00:35:45,760
a main and sidebar set of content and we

00:35:43,930 --> 00:35:48,550
rendered them side by side with proper

00:35:45,760 --> 00:35:50,500
responsive support so in the template we

00:35:48,550 --> 00:35:52,420
render that main content body and then

00:35:50,500 --> 00:35:54,720
the sidebar based on the argument is

00:35:52,420 --> 00:35:56,530
rendered on either the left or the right

00:35:54,720 --> 00:35:57,970
so it's really useful about this

00:35:56,530 --> 00:35:59,770
component is that there's actually a

00:35:57,970 --> 00:36:01,839
fair amount of complexity and getting

00:35:59,770 --> 00:36:03,910
the responsive behavior here just right

00:36:01,839 --> 00:36:05,440
and now we have a single implementation

00:36:03,910 --> 00:36:09,040
of this pattern that is used I think

00:36:05,440 --> 00:36:13,480
eight or nine places in the app it's a

00:36:09,040 --> 00:36:15,700
great benefit for us so what does this

00:36:13,480 --> 00:36:17,349
mean for the future of our views we're

00:36:15,700 --> 00:36:19,690
starting to migrate our view models to

00:36:17,349 --> 00:36:21,400
be components we've added a linter that

00:36:19,690 --> 00:36:24,150
caps usage of our view models and

00:36:21,400 --> 00:36:26,380
directs people to use components instead

00:36:24,150 --> 00:36:29,530
we also have plenty of examples already

00:36:26,380 --> 00:36:32,589
as of the middle of April we have 112

00:36:29,530 --> 00:36:34,680
components in our application and

00:36:32,589 --> 00:36:38,530
another 16 in our design system and

00:36:34,680 --> 00:36:42,819
we're using them around 150 around 550

00:36:38,530 --> 00:36:44,530
times and around 250 views so what about

00:36:42,819 --> 00:36:46,329
for new views while components are

00:36:44,530 --> 00:36:48,520
useful for building our entire views our

00:36:46,329 --> 00:36:53,530
rule has generally been that if it could

00:36:48,520 --> 00:36:55,510
be a partial it could be a component so

00:36:53,530 --> 00:36:57,480
we've released our the Ruby library it's

00:36:55,510 --> 00:36:59,650
an open source on github since August

00:36:57,480 --> 00:37:01,150
contributions are welcome and we'd love

00:36:59,650 --> 00:37:02,890
to see you guys give it a try in your

00:37:01,150 --> 00:37:06,270
applications and let us know what you

00:37:02,890 --> 00:37:06,270

YouTube URL: https://www.youtube.com/watch?v=YVYRus_2KZM


