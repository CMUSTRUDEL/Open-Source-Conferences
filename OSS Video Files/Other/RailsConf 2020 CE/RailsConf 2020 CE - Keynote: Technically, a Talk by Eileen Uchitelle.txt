Title: RailsConf 2020 CE - Keynote: Technically, a Talk by Eileen Uchitelle
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Keynote: Technically, a Talk by Eileen Uchitelle

"Peer deep into Rails’ database handling and you may find the code overly complex, hard to follow, and full of technical debt. On the surface you’re right - it is complex, but that complexity represents the strong foundation that keeps your applications simple and focused on your product code. In this talk we’ll look at how to use multiple databases, the beauty (and horror) of Rails connection management, and why we built this feature for you.
"
__________

Eileen Uchitelle is a Staff Software Engineer on the Ruby Architecture Team at GitHub and a member of the Rails Core team. She's an avid contributor to open source focusing on the Ruby on Rails framework and its dependencies. Eileen is passionate about scalability, performance, and making open source communities more sustainable and welcoming.
Captions: 
	00:00:08,880 --> 00:00:14,050
well hello there everyone i'm eileen you

00:00:12,490 --> 00:00:16,480
should tell and I'm a staff engineer on

00:00:14,050 --> 00:00:18,100
github Scooby architecture team our team

00:00:16,480 --> 00:00:19,840
works to improve code based stability

00:00:18,100 --> 00:00:22,029
and resilience by looking for ways the

00:00:19,840 --> 00:00:23,770
Ruby language and rails framework can be

00:00:22,029 --> 00:00:26,320
improved to support github for the long

00:00:23,770 --> 00:00:28,000
term I'm also a member of the rails core

00:00:26,320 --> 00:00:29,860
team were responsible for deciding the

00:00:28,000 --> 00:00:31,419
future of the rails framework when new

00:00:29,860 --> 00:00:33,790
releases should come out and what

00:00:31,419 --> 00:00:35,290
features we want to build and support if

00:00:33,790 --> 00:00:37,000
you want to get in touch with me you can

00:00:35,290 --> 00:00:39,340
find me anywhere online at the handle

00:00:37,000 --> 00:00:41,830
eileen codes welcome to my online

00:00:39,340 --> 00:00:44,230
railsconf keynote called technically a

00:00:41,830 --> 00:00:46,420
talk this title is a little bit of a

00:00:44,230 --> 00:00:47,020
joke when I was first asked to keynote

00:00:46,420 --> 00:00:48,520
rails comp

00:00:47,020 --> 00:00:50,770
I heard that Evan Phoenix wanted a

00:00:48,520 --> 00:00:52,330
really technical keynote he asked for a

00:00:50,770 --> 00:00:54,670
talk that was so technical that people

00:00:52,330 --> 00:00:57,540
wanted to leave the room jokes on him

00:00:54,670 --> 00:01:01,000
there's no room for you to leave now

00:00:57,540 --> 00:01:03,160
today we're going to talk about multiple

00:01:01,000 --> 00:01:05,110
databases we're gonna deep dive into the

00:01:03,160 --> 00:01:06,310
design and architecture of the api's and

00:01:05,110 --> 00:01:08,680
how connection management works

00:01:06,310 --> 00:01:10,600
internally when I first started working

00:01:08,680 --> 00:01:12,520
on this talk I mapped out every single

00:01:10,600 --> 00:01:14,020
PR and commit that I was involved in

00:01:12,520 --> 00:01:16,420
that implemented multiple database

00:01:14,020 --> 00:01:18,100
support I was impressed to find that

00:01:16,420 --> 00:01:19,659
over time we had amassed over a hundred

00:01:18,100 --> 00:01:21,189
pull requests that added the

00:01:19,659 --> 00:01:24,520
functionality that rails needed to

00:01:21,189 --> 00:01:27,009
support database stability and growth we

00:01:24,520 --> 00:01:29,740
did work to improve migrations then

00:01:27,009 --> 00:01:32,439
improve database configurations then we

00:01:29,740 --> 00:01:34,450
built out and improved rails tasks we

00:01:32,439 --> 00:01:36,549
built easy-to-use api's for establishing

00:01:34,450 --> 00:01:39,340
connections and we build an auto

00:01:36,549 --> 00:01:41,590
switching API as I look at this timeline

00:01:39,340 --> 00:01:43,299
I don't just see years of work instead I

00:01:41,590 --> 00:01:45,549
see how much I care about this framework

00:01:43,299 --> 00:01:47,319
and this community so while this is

00:01:45,549 --> 00:01:47,950
technically a talk it's also so much

00:01:47,319 --> 00:01:50,710
more than that

00:01:47,950 --> 00:01:53,399
this talk as well as this timeline is my

00:01:50,710 --> 00:01:55,539
love letter to rails into this community

00:01:53,399 --> 00:01:56,979
two and a half years ago I started

00:01:55,539 --> 00:01:59,740
working on bringing multiple database

00:01:56,979 --> 00:02:01,389
support to rails there are a few

00:01:59,740 --> 00:02:03,609
third-party gems that provided solutions

00:02:01,389 --> 00:02:05,200
and it github we had written our own

00:02:03,609 --> 00:02:07,929
internal code for handling multiple

00:02:05,200 --> 00:02:08,350
databases from my experience working at

00:02:07,929 --> 00:02:09,670
github

00:02:08,350 --> 00:02:12,069
I knew that supporting multiple

00:02:09,670 --> 00:02:14,410
databases in rails wasn't just a nice to

00:02:12,069 --> 00:02:16,270
have it was a requirement for rails

00:02:14,410 --> 00:02:18,790
continued success as a modern web

00:02:16,270 --> 00:02:21,069
framework we have to continue to improve

00:02:18,790 --> 00:02:22,300
the foundation that rails provides for

00:02:21,069 --> 00:02:24,130
applications

00:02:22,300 --> 00:02:27,550
companies that were built on Rails come

00:02:24,130 --> 00:02:30,130
ature and grow on Rails as well github

00:02:27,550 --> 00:02:32,140
is one of rails many success stories we

00:02:30,130 --> 00:02:34,090
weren't successful in spite of rails we

00:02:32,140 --> 00:02:36,130
thrived because of it and because of the

00:02:34,090 --> 00:02:38,500
changes we made to be able to continue

00:02:36,130 --> 00:02:40,600
using it there were many good reasons

00:02:38,500 --> 00:02:42,010
for us to upstream our database code to

00:02:40,600 --> 00:02:43,480
rails it meant that we could delete

00:02:42,010 --> 00:02:46,120
hundreds of thousands of lines of code

00:02:43,480 --> 00:02:47,830
from github this would make our code

00:02:46,120 --> 00:02:50,530
less complex more modern and more

00:02:47,830 --> 00:02:52,030
resilient more than that it meant that

00:02:50,530 --> 00:02:53,440
we were finally sharing what we had

00:02:52,030 --> 00:02:55,780
built for rails with the rest of the

00:02:53,440 --> 00:02:58,300
community and today I'd like to share

00:02:55,780 --> 00:03:00,760
this work with you well first talk about

00:02:58,300 --> 00:03:02,200
what multiple databases are and then

00:03:00,760 --> 00:03:03,970
then we'll get into how to use them in

00:03:02,200 --> 00:03:05,620
your application and then we'll deep

00:03:03,970 --> 00:03:08,890
dive into how the architecture and

00:03:05,620 --> 00:03:10,390
design works let's get started when I

00:03:08,890 --> 00:03:12,250
talk about multiple databases I'm

00:03:10,390 --> 00:03:14,950
talking about the ability for your rails

00:03:12,250 --> 00:03:16,750
application to connect to write to and

00:03:14,950 --> 00:03:19,180
select from more than one database in a

00:03:16,750 --> 00:03:21,370
single environment in a standard new

00:03:19,180 --> 00:03:23,350
rails application there is one database

00:03:21,370 --> 00:03:25,060
per environment the database for the

00:03:23,350 --> 00:03:26,950
current environment traditionally holds

00:03:25,060 --> 00:03:29,470
all your tables your application needs

00:03:26,950 --> 00:03:31,090
often as an application grows the

00:03:29,470 --> 00:03:32,950
database will become too large to

00:03:31,090 --> 00:03:35,230
effectively handle the data and traffic

00:03:32,950 --> 00:03:36,700
it needs to support when that happens

00:03:35,230 --> 00:03:38,530
there are many ways to alleviate the

00:03:36,700 --> 00:03:40,270
pressure on your database I'm not a

00:03:38,530 --> 00:03:41,500
database administrator so I'm not going

00:03:40,270 --> 00:03:43,600
to talk to you about all the ways that

00:03:41,500 --> 00:03:45,280
you can petition your data in this talk

00:03:43,600 --> 00:03:48,130
I'm going to only focus on the three

00:03:45,280 --> 00:03:49,480
ways that we now support in rails one

00:03:48,130 --> 00:03:51,670
way of bringing up your data is to use

00:03:49,480 --> 00:03:53,890
horizontal sharding also known as

00:03:51,670 --> 00:03:55,650
horizontal partitioning multi-tenant

00:03:53,890 --> 00:03:57,430
sharding or simply just sharding

00:03:55,650 --> 00:03:59,290
horizontal charting is when you take

00:03:57,430 --> 00:04:02,140
your database and horizontally split the

00:03:59,290 --> 00:04:03,760
tables up by row with horizontal

00:04:02,140 --> 00:04:05,380
charting each of the partitions of your

00:04:03,760 --> 00:04:06,280
database contains the same schema but

00:04:05,380 --> 00:04:08,020
different data

00:04:06,280 --> 00:04:10,000
this approach is focused on limiting the

00:04:08,020 --> 00:04:11,980
number of rows in each shard or

00:04:10,000 --> 00:04:13,720
partition therefore reducing the number

00:04:11,980 --> 00:04:16,030
of rows that need to be indexed and then

00:04:13,720 --> 00:04:17,739
selected from another way of splitting

00:04:16,030 --> 00:04:19,330
up your data to alleviate pressure on

00:04:17,739 --> 00:04:21,640
your database is with functional

00:04:19,330 --> 00:04:23,530
partitioning in this method tables are

00:04:21,640 --> 00:04:25,870
split by function or need rather than by

00:04:23,530 --> 00:04:27,520
row functional partitioning means

00:04:25,870 --> 00:04:29,050
splitting whole tables it is on two

00:04:27,520 --> 00:04:31,300
separate servers rather than a set of

00:04:29,050 --> 00:04:33,280
rows each partition has a different

00:04:31,300 --> 00:04:34,870
schema this method focuses on moving

00:04:33,280 --> 00:04:35,330
high-volume right tables out of your

00:04:34,870 --> 00:04:37,400
main day

00:04:35,330 --> 00:04:39,379
cluster into their own clusters to

00:04:37,400 --> 00:04:41,599
alleviate pressure on that main database

00:04:39,379 --> 00:04:43,370
both of these types of database

00:04:41,599 --> 00:04:46,340
partitioning can also support read

00:04:43,370 --> 00:04:48,080
replicas Reb Lazar copies of the primary

00:04:46,340 --> 00:04:49,849
writer database in order to reduce

00:04:48,080 --> 00:04:52,189
pressure on the writing database for

00:04:49,849 --> 00:04:54,379
select queries the goal is to sent as

00:04:52,189 --> 00:04:56,840
many queries as possible to the replicas

00:04:54,379 --> 00:04:58,340
when I write happens there's often a

00:04:56,840 --> 00:05:00,289
slight delay called replication lag

00:04:58,340 --> 00:05:02,719
before the change you're inserted data

00:05:00,289 --> 00:05:04,310
is copied to the replicas in a

00:05:02,719 --> 00:05:07,340
well-functioning system the replication

00:05:04,310 --> 00:05:08,479
lag is usually less than a second now

00:05:07,340 --> 00:05:10,129
that we have an understanding of what

00:05:08,479 --> 00:05:11,270
multiple databases are we can take a

00:05:10,129 --> 00:05:13,490
look at how to use them in our

00:05:11,270 --> 00:05:15,740
application in this demo we have a

00:05:13,490 --> 00:05:17,060
recipes application this application has

00:05:15,740 --> 00:05:19,580
one primary database that contains

00:05:17,060 --> 00:05:21,440
tables such as users and as a second

00:05:19,580 --> 00:05:23,840
database named meals that contains

00:05:21,440 --> 00:05:25,729
recipes the meals database has three

00:05:23,840 --> 00:05:27,349
shards the default shard that contains

00:05:25,729 --> 00:05:29,389
the shard keys to look up the data from

00:05:27,349 --> 00:05:31,520
the other two shards by and the two

00:05:29,389 --> 00:05:33,169
shards that contain our data both the

00:05:31,520 --> 00:05:35,689
primary database and meal shards have

00:05:33,169 --> 00:05:37,879
replicas databases now that we know

00:05:35,689 --> 00:05:39,080
there's structure of our database let's

00:05:37,879 --> 00:05:41,389
look at how to setup them in our

00:05:39,080 --> 00:05:43,400
application well first take a look at

00:05:41,389 --> 00:05:45,110
our database UML here we can see that

00:05:43,400 --> 00:05:46,550
our database schema has multiple entries

00:05:45,110 --> 00:05:48,979
under the development key we have a

00:05:46,550 --> 00:05:51,169
primary primary replica meals default

00:05:48,979 --> 00:05:53,509
meals default replica meals wine shard

00:05:51,169 --> 00:05:55,789
meals one shard replica meals two shard

00:05:53,509 --> 00:05:57,289
and meals two sharp replicas this

00:05:55,789 --> 00:05:59,569
matches the database diagram that we

00:05:57,289 --> 00:06:00,830
just looked at now that we have a

00:05:59,569 --> 00:06:03,770
database team we'll set up let's create

00:06:00,830 --> 00:06:05,479
some databases when we run DB create we

00:06:03,770 --> 00:06:07,099
can see that rails creates the databases

00:06:05,479 --> 00:06:09,440
for all of the writer entries under

00:06:07,099 --> 00:06:10,849
development and test since replicas use

00:06:09,440 --> 00:06:13,460
the same name as the writers browse

00:06:10,849 --> 00:06:16,039
won't create them okay now we need to

00:06:13,460 --> 00:06:19,279
set up our connections first we open app

00:06:16,039 --> 00:06:21,830
models application record and in this

00:06:19,279 --> 00:06:23,060
file we're going to add connects to for

00:06:21,830 --> 00:06:24,949
our writing and reading roles for the

00:06:23,060 --> 00:06:29,870
main database primary is for writing and

00:06:24,949 --> 00:06:32,659
primary replica is for reading pretty

00:06:29,870 --> 00:06:34,310
easy right next we need to create a new

00:06:32,659 --> 00:06:36,229
file for our meals databases

00:06:34,310 --> 00:06:38,089
this we call whatever you want but I

00:06:36,229 --> 00:06:39,409
like to keep the application record

00:06:38,089 --> 00:06:41,990
naming conventions so we're going to

00:06:39,409 --> 00:06:43,399
call it a meal a application record new

00:06:41,990 --> 00:06:45,139
connection classes need to be in an

00:06:43,399 --> 00:06:47,389
abstract class so that rails knows that

00:06:45,139 --> 00:06:49,009
it's not an active record model if

00:06:47,389 --> 00:06:50,839
you're working with shards

00:06:49,009 --> 00:06:53,210
use the shards keyword argument instead

00:06:50,839 --> 00:07:00,020
of database and said each shards writing

00:06:53,210 --> 00:07:04,969
and reading configurations now let's

00:07:00,020 --> 00:07:06,949
create some models first we'll create a

00:07:04,969 --> 00:07:08,809
scaffold for users for our primary

00:07:06,949 --> 00:07:10,129
database this is the same this is the

00:07:08,809 --> 00:07:14,029
same as creating a scaffold for any

00:07:10,129 --> 00:07:16,969
rails application now we can see that it

00:07:14,029 --> 00:07:18,589
created the migration in the DB migrate

00:07:16,969 --> 00:07:20,569
directory and now we're going to only

00:07:18,589 --> 00:07:25,460
run migrations for this primary database

00:07:20,569 --> 00:07:26,749
by running DB migrate primary this is

00:07:25,460 --> 00:07:29,330
basically the same that you would do for

00:07:26,749 --> 00:07:31,009
any application except for that we're

00:07:29,330 --> 00:07:33,139
using the name tasks here because I want

00:07:31,009 --> 00:07:35,240
to specifically avoid running migrations

00:07:33,139 --> 00:07:36,889
for the Millis database now we're going

00:07:35,240 --> 00:07:40,819
to create a scaffold for our meals

00:07:36,889 --> 00:07:43,759
database called dare recipe the dinner

00:07:40,819 --> 00:07:45,409
recipe has a title and a recipe but you

00:07:43,759 --> 00:07:47,899
can also see that we're going to pass a

00:07:45,409 --> 00:07:48,979
database argument which informs the

00:07:47,899 --> 00:07:51,800
generator that we want to create

00:07:48,979 --> 00:07:52,849
migrations in any different directory we

00:07:51,800 --> 00:07:54,529
need to choose one of our meals

00:07:52,849 --> 00:07:56,209
configurations as an argument but it

00:07:54,529 --> 00:07:58,159
doesn't matter which one we can see that

00:07:56,209 --> 00:08:00,169
raus created in the meals the DB meals

00:07:58,159 --> 00:08:01,819
migrate directory before we run the

00:08:00,169 --> 00:08:04,550
migration we need to update our model to

00:08:01,819 --> 00:08:06,409
use the meal application record model so

00:08:04,550 --> 00:08:08,539
that we you know any queries use the

00:08:06,409 --> 00:08:11,209
right connection and lastly we're going

00:08:08,539 --> 00:08:12,949
to run rails DB migrate and we're gonna

00:08:11,209 --> 00:08:15,430
see that it's going to migrate all three

00:08:12,949 --> 00:08:18,529
of the databases at once

00:08:15,430 --> 00:08:20,120
so we've rotten our migration for dinner

00:08:18,529 --> 00:08:22,580
recipes three times for each of the

00:08:20,120 --> 00:08:23,930
shards that we have so now that all of

00:08:22,580 --> 00:08:25,759
our models and data are set up let's

00:08:23,930 --> 00:08:28,339
look at how we how to switch connections

00:08:25,759 --> 00:08:29,899
in our application rel ships with a

00:08:28,339 --> 00:08:31,789
method called connected to you which is

00:08:29,899 --> 00:08:33,709
used to switch the context the current

00:08:31,789 --> 00:08:35,120
the connection context here we can see

00:08:33,709 --> 00:08:36,800
that by default rails is set to the

00:08:35,120 --> 00:08:40,610
writing connection and the default pool

00:08:36,800 --> 00:08:42,769
key is default we can change the char we

00:08:40,610 --> 00:08:46,519
can change the connection context by

00:08:42,769 --> 00:08:48,860
passing role reading to the two

00:08:46,519 --> 00:08:55,639
connected to this is going to switch our

00:08:48,860 --> 00:08:58,490
role to reading perfect now we're going

00:08:55,639 --> 00:08:59,779
to do the same thing let's switch to the

00:08:58,490 --> 00:09:02,259
shard and we're going to see how the

00:08:59,779 --> 00:09:04,089
shard key works shard to

00:09:02,259 --> 00:09:05,529
then we're gonna output the current role

00:09:04,089 --> 00:09:08,709
so you can see that it also switched to

00:09:05,529 --> 00:09:13,029
reading and then output the current pool

00:09:08,709 --> 00:09:14,649
key and we can see that it's switched

00:09:13,029 --> 00:09:16,509
both of the context this can be used

00:09:14,649 --> 00:09:18,999
together or separately anything that you

00:09:16,509 --> 00:09:20,259
need for your application in addition to

00:09:18,999 --> 00:09:21,729
the ability to manually switch

00:09:20,259 --> 00:09:25,089
connections rails also has an auto

00:09:21,729 --> 00:09:27,369
switcher that will automatically switch

00:09:25,089 --> 00:09:30,249
connections for you all we have to do is

00:09:27,369 --> 00:09:32,649
put these three lines in our application

00:09:30,249 --> 00:09:34,809
configuration now we're going to start

00:09:32,649 --> 00:09:36,879
the server I have added logging to show

00:09:34,809 --> 00:09:38,619
us when we are on writing or reading

00:09:36,879 --> 00:09:39,699
roles so we can see that we're on the

00:09:38,619 --> 00:09:41,589
reading role because does it get

00:09:39,699 --> 00:09:43,359
requests we're gonna create a user and

00:09:41,589 --> 00:09:45,069
we're on the writing role we're gonna go

00:09:43,359 --> 00:09:46,989
we are still on the writing role and now

00:09:45,069 --> 00:09:49,779
we're back to reading what's happening

00:09:46,989 --> 00:09:51,339
here is after we did that write rails

00:09:49,779 --> 00:09:52,929
will keep us on the writing connection

00:09:51,339 --> 00:09:55,779
for the delay that was set in our

00:09:52,929 --> 00:09:58,479
application configuration and that's it

00:09:55,779 --> 00:10:00,539
pretty simple right that's how to use

00:09:58,479 --> 00:10:03,069
multiple databases in your application

00:10:00,539 --> 00:10:04,419
now that we've seen how to use these in

00:10:03,069 --> 00:10:07,589
your app let's take a look at the design

00:10:04,419 --> 00:10:09,699
and architecture of the public api's I

00:10:07,589 --> 00:10:11,169
gave hope we had written our own code

00:10:09,699 --> 00:10:13,829
for handling multiple databases that

00:10:11,169 --> 00:10:16,209
monkey patched an extended active record

00:10:13,829 --> 00:10:17,949
once I had a handle on what was Birkin

00:10:16,209 --> 00:10:20,019
and rails and needed to be fixed

00:10:17,949 --> 00:10:21,579
I built api's in rails that were

00:10:20,019 --> 00:10:23,919
inspired by our code in github

00:10:21,579 --> 00:10:25,600
I changed the api's a fair bit to better

00:10:23,919 --> 00:10:28,480
match real style but effectively the

00:10:25,600 --> 00:10:30,129
internal code would remain the same this

00:10:28,480 --> 00:10:31,539
approach to building functionality is

00:10:30,129 --> 00:10:33,910
unique because I build the public-facing

00:10:31,539 --> 00:10:35,919
code first and fixed internals second

00:10:33,910 --> 00:10:37,509
this may sound backwards but it allowed

00:10:35,919 --> 00:10:39,579
me to architect changes based on

00:10:37,509 --> 00:10:42,249
real-world applications rather than for

00:10:39,579 --> 00:10:44,319
a perfect but unnecessary use case in

00:10:42,249 --> 00:10:46,389
rails we focus always on building easy

00:10:44,319 --> 00:10:47,919
to use simple and functional api's that

00:10:46,389 --> 00:10:51,159
are a hundred percent focused on user

00:10:47,919 --> 00:10:53,470
experience our goal is to optimize for

00:10:51,159 --> 00:10:55,209
your happiness rails internals take on

00:10:53,470 --> 00:10:57,639
complexity so that you can focus on

00:10:55,209 --> 00:10:59,049
building your application one of the

00:10:57,639 --> 00:11:00,939
first places that we improve the user

00:10:59,049 --> 00:11:03,279
experience from multiple databases was

00:11:00,939 --> 00:11:04,989
in the migration code as you saw earlier

00:11:03,279 --> 00:11:07,359
in our demo we can use the rails

00:11:04,989 --> 00:11:09,399
generators with a database argument the

00:11:07,359 --> 00:11:12,339
argument will look up the migrations

00:11:09,399 --> 00:11:14,379
paths set that you set in your database

00:11:12,339 --> 00:11:15,550
configurations for sharding we want to

00:11:14,379 --> 00:11:17,529
always use one

00:11:15,550 --> 00:11:19,779
directory and migrate that multiple time

00:11:17,529 --> 00:11:22,480
so that you don't have to copy

00:11:19,779 --> 00:11:23,800
migrations after you generate them so

00:11:22,480 --> 00:11:25,390
we're not going to deep dive into any

00:11:23,800 --> 00:11:26,680
internal changes for migrations that I

00:11:25,390 --> 00:11:29,890
did because I talked about it two years

00:11:26,680 --> 00:11:31,300
ago at railsconf 2018 the migration

00:11:29,890 --> 00:11:32,980
internals haven't changed since this

00:11:31,300 --> 00:11:34,899
talk so if you're interested in that

00:11:32,980 --> 00:11:37,089
work that went into migrations you can

00:11:34,899 --> 00:11:38,350
watch this on confreaks or YouTube I'd

00:11:37,089 --> 00:11:39,790
rather spend this time talking about

00:11:38,350 --> 00:11:43,510
some of the other fun stuff that we did

00:11:39,790 --> 00:11:45,070
since 2018 on the other end one of our

00:11:43,510 --> 00:11:46,660
biggest changes to rails to support

00:11:45,070 --> 00:11:49,240
multiple databases was to the database

00:11:46,660 --> 00:11:51,850
configurations one of the first major

00:11:49,240 --> 00:11:52,990
architectural decisions that we made was

00:11:51,850 --> 00:11:54,670
to turn the internal database

00:11:52,990 --> 00:11:56,620
configuration hashes that are generated

00:11:54,670 --> 00:11:59,050
from your database configuration into

00:11:56,620 --> 00:12:00,579
objects hashes had served us well in

00:11:59,050 --> 00:12:02,800
applications used a two-level

00:12:00,579 --> 00:12:04,089
configuration Rallos would parse the

00:12:02,800 --> 00:12:07,000
database camel and turn it into a

00:12:04,089 --> 00:12:08,740
two-level hash we also could easily find

00:12:07,000 --> 00:12:11,410
the right configuration to use because

00:12:08,740 --> 00:12:13,029
it was always it always correspondent to

00:12:11,410 --> 00:12:14,110
the current environment if we're in

00:12:13,029 --> 00:12:15,940
development there's only one

00:12:14,110 --> 00:12:18,160
configuration that can possibly be

00:12:15,940 --> 00:12:20,079
selected for development because of this

00:12:18,160 --> 00:12:21,610
many of the internals of rails assumed

00:12:20,079 --> 00:12:23,500
the configuration to connect you could

00:12:21,610 --> 00:12:26,680
always be found by looking up the hash

00:12:23,500 --> 00:12:28,000
associated with the environment key when

00:12:26,680 --> 00:12:29,440
rails introduced a three-level

00:12:28,000 --> 00:12:31,300
configuration of support multiple

00:12:29,440 --> 00:12:33,310
databases it increased the complexity of

00:12:31,300 --> 00:12:35,740
the generated hash and broke many of

00:12:33,310 --> 00:12:37,630
rails internal assumptions when app

00:12:35,740 --> 00:12:41,140
boots and it has to connect to a

00:12:37,630 --> 00:12:43,149
database Wells Sorrell includes a rel

00:12:41,140 --> 00:12:45,160
tie that establishes a connection to the

00:12:43,149 --> 00:12:46,540
configuration for that environment but

00:12:45,160 --> 00:12:48,040
if we have two or more configurations

00:12:46,540 --> 00:12:49,990
per environment how does rails know

00:12:48,040 --> 00:12:51,670
which one to connect to by default we

00:12:49,990 --> 00:12:53,350
can't just assume non replicas because

00:12:51,670 --> 00:12:54,820
in a multiple database application there

00:12:53,350 --> 00:12:57,279
can be more than one writing database

00:12:54,820 --> 00:12:59,170
per environment in addition how do we

00:12:57,279 --> 00:13:03,250
know we have a three-level configuration

00:12:59,170 --> 00:13:04,570
and how do we know how do we know to use

00:13:03,250 --> 00:13:06,240
that configuration to create the name

00:13:04,570 --> 00:13:08,470
tasks for each of the database entries

00:13:06,240 --> 00:13:10,240
constantly parsing hashes to figure out

00:13:08,470 --> 00:13:12,820
where we are on the stack is pasta is

00:13:10,240 --> 00:13:15,730
possible but error-prone brittle and

00:13:12,820 --> 00:13:17,079
introduces unnecessary complexity he

00:13:15,730 --> 00:13:19,149
wondered what if we could just parse the

00:13:17,079 --> 00:13:20,290
hash once and know everything that we

00:13:19,149 --> 00:13:22,260
needed to know about all of the

00:13:20,290 --> 00:13:24,850
configurations after the app was booted

00:13:22,260 --> 00:13:27,190
we decided to introduce a new database

00:13:24,850 --> 00:13:28,779
configuration object the idea was that

00:13:27,190 --> 00:13:29,470
we could parse the configurations once

00:13:28,779 --> 00:13:30,940
turn every

00:13:29,470 --> 00:13:33,190
objects and be able to more easily

00:13:30,940 --> 00:13:36,400
select and enumerate all those objects

00:13:33,190 --> 00:13:38,410
as that were created once the hashes

00:13:36,400 --> 00:13:40,060
became an object we know everything that

00:13:38,410 --> 00:13:41,560
we need to know about the configurations

00:13:40,060 --> 00:13:43,180
like what environment they belong to

00:13:41,560 --> 00:13:45,520
what their name is what their connection

00:13:43,180 --> 00:13:47,140
requirements are we don't need to keep

00:13:45,520 --> 00:13:48,940
repurchasing the hash I keep track of

00:13:47,140 --> 00:13:51,460
where we are in the configuration levels

00:13:48,940 --> 00:13:53,470
the database configuration objects look

00:13:51,460 --> 00:13:55,360
like this the hash config object has an

00:13:53,470 --> 00:13:57,040
envier Man identifier name and a

00:13:55,360 --> 00:13:58,800
configuration hash the corresponds to

00:13:57,040 --> 00:14:02,080
the first second and third level of the

00:13:58,800 --> 00:14:03,970
Gamelin respectively if you're using a

00:14:02,080 --> 00:14:06,340
URL configuration rails will generate a

00:14:03,970 --> 00:14:07,930
URL config instead of a hash config it's

00:14:06,340 --> 00:14:09,730
super similar to the hash configure it

00:14:07,930 --> 00:14:11,770
has all the same keys except for the URL

00:14:09,730 --> 00:14:14,710
a config includes an instance variable

00:14:11,770 --> 00:14:16,540
for the original URL passed database

00:14:14,710 --> 00:14:18,160
configuration objects get generated by

00:14:16,540 --> 00:14:20,560
rails and the application is booted in

00:14:18,160 --> 00:14:22,450
an active record initializer this

00:14:20,560 --> 00:14:24,640
configurations method instantiates a new

00:14:22,450 --> 00:14:26,050
database configurations object which

00:14:24,640 --> 00:14:29,860
loops through all of the hashes and

00:14:26,050 --> 00:14:31,900
turns them into objects we're not going

00:14:29,860 --> 00:14:33,340
to deep dive into the build configs

00:14:31,900 --> 00:14:35,980
method here because honestly it's not

00:14:33,340 --> 00:14:37,300
that interesting I actually deleted 10

00:14:35,980 --> 00:14:39,100
slides showing how this works because

00:14:37,300 --> 00:14:40,420
they were boring maybe I'll write a blog

00:14:39,100 --> 00:14:42,730
post about it if you all find it

00:14:40,420 --> 00:14:44,110
interesting the result returned to

00:14:42,730 --> 00:14:45,600
active record configurations is an

00:14:44,110 --> 00:14:47,890
object that contains an array of

00:14:45,600 --> 00:14:49,540
configurations these objects make it

00:14:47,890 --> 00:14:51,250
easy for us to iterate enumerate and

00:14:49,540 --> 00:14:53,230
select the correct configurations from

00:14:51,250 --> 00:14:56,110
the list without parsing a three-level

00:14:53,230 --> 00:14:57,880
hash multiple times now that we have the

00:14:56,110 --> 00:14:59,320
configuration objects we can ask after

00:14:57,880 --> 00:15:00,610
record your favorite configurations for

00:14:59,320 --> 00:15:02,440
all the configurations for an

00:15:00,610 --> 00:15:04,510
environment with the configs 4 method

00:15:02,440 --> 00:15:06,460
this is pretty similar to using a hash

00:15:04,510 --> 00:15:08,650
accessor and will return a list of the

00:15:06,460 --> 00:15:10,720
configuration objects for the production

00:15:08,650 --> 00:15:12,400
environment we can also get the

00:15:10,720 --> 00:15:15,100
configurations for an environment and a

00:15:12,400 --> 00:15:18,070
name a name production and name meals

00:15:15,100 --> 00:15:20,620
one will return a matching configuration

00:15:18,070 --> 00:15:21,880
object for those parameters by default

00:15:20,620 --> 00:15:24,010
replicas are excluded from the

00:15:21,880 --> 00:15:25,960
configurations returned by configs 4

00:15:24,010 --> 00:15:28,570
since in general you just don't need to

00:15:25,960 --> 00:15:30,490
operate on them their database name

00:15:28,570 --> 00:15:32,380
should be the same as the writer so we

00:15:30,490 --> 00:15:34,570
generally ignore them for the raid tasks

00:15:32,380 --> 00:15:36,280
if you need to get replicas from the

00:15:34,570 --> 00:15:38,110
configurations list for any reason you

00:15:36,280 --> 00:15:39,910
can simply pass include replicas with

00:15:38,110 --> 00:15:41,860
true and the replica configurations will

00:15:39,910 --> 00:15:43,390
be returned in addition to the primary

00:15:41,860 --> 00:15:45,010
ones

00:15:43,390 --> 00:15:46,600
these database configuration objects

00:15:45,010 --> 00:15:47,440
make it easier for rails internals to

00:15:46,600 --> 00:15:49,390
interact with the database

00:15:47,440 --> 00:15:51,280
configurations but also provides a

00:15:49,390 --> 00:15:55,240
cleaner interface for applications to

00:15:51,280 --> 00:15:56,890
interact as well when needed once we

00:15:55,240 --> 00:15:58,150
have the objects working correctly for

00:15:56,890 --> 00:16:00,160
creating the rake tasks and

00:15:58,150 --> 00:16:02,290
configurations we started working on the

00:16:00,160 --> 00:16:03,940
internal API we wanted to ensure that

00:16:02,290 --> 00:16:06,970
all of the methods internally in rails

00:16:03,940 --> 00:16:08,710
also use the configuration objects rails

00:16:06,970 --> 00:16:10,180
was still using the configuration hash

00:16:08,710 --> 00:16:12,460
in the connection pool in other places

00:16:10,180 --> 00:16:14,290
internally an active record since the

00:16:12,460 --> 00:16:15,940
objects included the hash there was no

00:16:14,290 --> 00:16:18,010
reason to pass this around instead of

00:16:15,940 --> 00:16:19,720
the object the only place that actually

00:16:18,010 --> 00:16:21,520
needed a hash is the connection method

00:16:19,720 --> 00:16:24,190
for the database clients everything else

00:16:21,520 --> 00:16:25,410
could just use the objects in order to

00:16:24,190 --> 00:16:27,790
accomplish this we needed to identify

00:16:25,410 --> 00:16:29,620
everywhere we were accessing values in

00:16:27,790 --> 00:16:32,080
the hash and ad reader methods for those

00:16:29,620 --> 00:16:33,760
this was required because we didn't want

00:16:32,080 --> 00:16:35,620
to change the hashes to configurations

00:16:33,760 --> 00:16:37,780
and have to access the hash directly

00:16:35,620 --> 00:16:39,100
anyway instead we wanted to be able to

00:16:37,780 --> 00:16:40,780
get all the information that rails

00:16:39,100 --> 00:16:42,880
needed from the configurations on the

00:16:40,780 --> 00:16:46,210
objects themselves in short we needed to

00:16:42,880 --> 00:16:47,920
be able to ask DB config directly for

00:16:46,210 --> 00:16:50,410
its database rather than reaching into

00:16:47,920 --> 00:16:52,510
the hash to accomplish this we needed to

00:16:50,410 --> 00:16:54,520
look at all the places we were using the

00:16:52,510 --> 00:16:56,950
configuration hash and figure out what

00:16:54,520 --> 00:17:00,070
keys in the hash were values that rails

00:16:56,950 --> 00:17:01,330
needs to access and which accusing the

00:17:00,070 --> 00:17:05,170
hash sure what the client needs or

00:17:01,330 --> 00:17:07,120
simply said everything else more simply

00:17:05,170 --> 00:17:08,920
rel should never have to reach into the

00:17:07,120 --> 00:17:10,750
hash stored on the database config for

00:17:08,920 --> 00:17:12,370
values it should always be able to ask

00:17:10,750 --> 00:17:14,709
the object directly for the data it

00:17:12,370 --> 00:17:16,300
needs for each value that rails needed

00:17:14,709 --> 00:17:18,370
we added reader methods to the database

00:17:16,300 --> 00:17:20,050
config objects this lets us remove all

00:17:18,370 --> 00:17:22,260
of the hash access there's an active

00:17:20,050 --> 00:17:24,699
record and turn them into real accessors

00:17:22,260 --> 00:17:27,430
here's an example of an internal change

00:17:24,699 --> 00:17:29,020
we made in rails by moving to using

00:17:27,430 --> 00:17:30,550
objects everywhere internally we ended

00:17:29,020 --> 00:17:32,380
up with cleaner code in a single place

00:17:30,550 --> 00:17:34,030
to set defaults the database

00:17:32,380 --> 00:17:36,190
configuration objects have been really

00:17:34,030 --> 00:17:37,870
useful for improving the internal code

00:17:36,190 --> 00:17:39,940
in rails and we're instrumental in some

00:17:37,870 --> 00:17:42,520
important features like generating the

00:17:39,940 --> 00:17:44,380
rails tasks active records database

00:17:42,520 --> 00:17:46,150
tasks are super important to having a

00:17:44,380 --> 00:17:48,100
good development experience and testing

00:17:46,150 --> 00:17:49,750
experience without them you need to run

00:17:48,100 --> 00:17:52,390
a lot of manual sequel queries just to

00:17:49,750 --> 00:17:53,890
get your databases set up even if all of

00:17:52,390 --> 00:17:55,480
the rails internals supported multiple

00:17:53,890 --> 00:17:57,309
databases and that the feature would

00:17:55,480 --> 00:18:00,399
have been a failure if we didn't support

00:17:57,309 --> 00:18:02,049
where else tasks reals tasks make using

00:18:00,399 --> 00:18:04,809
rails applications enjoyable because

00:18:02,049 --> 00:18:06,370
they do the hard setup work for you the

00:18:04,809 --> 00:18:07,870
database objects were instrumental in

00:18:06,370 --> 00:18:10,389
creating the rails tasks because they

00:18:07,870 --> 00:18:12,100
allow for us to enumerate on find and

00:18:10,389 --> 00:18:14,980
select the database configurations

00:18:12,100 --> 00:18:16,960
needed to generate the tasks the first

00:18:14,980 --> 00:18:18,820
thing we did to support the multiple

00:18:16,960 --> 00:18:20,889
databases in rails tasks was to update

00:18:18,820 --> 00:18:23,230
the existing tasks like create drop and

00:18:20,889 --> 00:18:25,179
my gradient others to operate on all the

00:18:23,230 --> 00:18:28,299
configuration all the configured

00:18:25,179 --> 00:18:29,889
databases for an environment to do this

00:18:28,299 --> 00:18:31,749
we update the tasks use the database

00:18:29,889 --> 00:18:33,669
configuration objects here's an example

00:18:31,749 --> 00:18:35,590
of the migrate tasks first we look up

00:18:33,669 --> 00:18:38,379
all the configurations for the current

00:18:35,590 --> 00:18:41,230
environment and return an array of the

00:18:38,379 --> 00:18:43,299
database config object since configs 4

00:18:41,230 --> 00:18:45,009
doesn't return replicas by default we

00:18:43,299 --> 00:18:46,779
know that all the DB config the objects

00:18:45,009 --> 00:18:48,909
here are for the primary databases that

00:18:46,779 --> 00:18:50,710
need to be migrated if we return

00:18:48,909 --> 00:18:52,419
replicas they would raise errors because

00:18:50,710 --> 00:18:54,039
replicas can't I usually have a

00:18:52,419 --> 00:18:58,330
read-only user so they're not able to

00:18:54,039 --> 00:19:00,009
run any create migrate tasks we then

00:18:58,330 --> 00:19:01,809
establish a new connection using the

00:19:00,009 --> 00:19:05,559
database that database configure object

00:19:01,809 --> 00:19:07,480
that's returned since rails tasks don't

00:19:05,559 --> 00:19:09,580
boot the application and don't know what

00:19:07,480 --> 00:19:10,899
models to use to run the migrations we

00:19:09,580 --> 00:19:12,820
need to establish a connection so we're

00:19:10,899 --> 00:19:15,039
connected to the correct database when

00:19:12,820 --> 00:19:17,769
running these tasks once connected rails

00:19:15,039 --> 00:19:18,999
calls migrate lastly we established a

00:19:17,769 --> 00:19:21,639
connection to the original configuration

00:19:18,999 --> 00:19:23,200
so we don't accidentally have to have

00:19:21,639 --> 00:19:24,940
active record base connected to the

00:19:23,200 --> 00:19:28,059
wrong database when migrations are

00:19:24,940 --> 00:19:29,860
completed in addition to supporting all

00:19:28,059 --> 00:19:32,289
databases with the original database

00:19:29,860 --> 00:19:35,289
tasks we added individual tasks as well

00:19:32,289 --> 00:19:37,179
for each of the database names creating

00:19:35,289 --> 00:19:38,740
these tasks turned out to be a lot more

00:19:37,179 --> 00:19:41,619
difficult than ensuring the default

00:19:38,740 --> 00:19:43,869
tasks operated on all databases less of

00:19:41,619 --> 00:19:45,669
a code that generates these named tasks

00:19:43,869 --> 00:19:47,889
first you'll notice that we call a

00:19:45,669 --> 00:19:50,230
method named for each before loading the

00:19:47,889 --> 00:19:51,940
configuration the configuration objects

00:19:50,230 --> 00:19:53,919
are generated with load config is called

00:19:51,940 --> 00:19:56,379
but we need to access the names before

00:19:53,919 --> 00:19:59,169
we load the environment since database

00:19:56,379 --> 00:20:01,090
configurations allow applications to add

00:19:59,169 --> 00:20:03,460
yarby and environment specific

00:20:01,090 --> 00:20:05,169
configurations into the Gamo file if you

00:20:03,460 --> 00:20:06,909
were if we were to load the database TM

00:20:05,169 --> 00:20:09,639
well before the environment and parse it

00:20:06,909 --> 00:20:10,990
as rails does we'd get an exception if

00:20:09,639 --> 00:20:13,120
we loaded the config

00:20:10,990 --> 00:20:15,760
to generate the tasks rails - tea would

00:20:13,120 --> 00:20:17,320
take a dramatic performance hit kind of

00:20:15,760 --> 00:20:19,330
had a chicken and an egg situation here

00:20:17,320 --> 00:20:22,510
we needed a way to parse the hamlet

00:20:19,330 --> 00:20:26,500
without evaluating any er er B after a

00:20:22,510 --> 00:20:28,840
lot of painful PRS we ended up creating

00:20:26,500 --> 00:20:32,890
a special gamma loader in the rail ties

00:20:28,840 --> 00:20:36,039
just for the rake tasks this special

00:20:32,890 --> 00:20:38,320
loader parses the ERV with a dummy er B

00:20:36,039 --> 00:20:40,990
class this class has only one job and

00:20:38,320 --> 00:20:43,570
that is to replace any RB and the amal

00:20:40,990 --> 00:20:45,220
with an empty string this gives us

00:20:43,570 --> 00:20:46,929
database configurations that are not

00:20:45,220 --> 00:20:48,549
suitable to connect your database but

00:20:46,929 --> 00:20:50,230
give us just enough information to have

00:20:48,549 --> 00:20:52,270
the environment and configuration name

00:20:50,230 --> 00:20:55,270
to be able to generate the rails the

00:20:52,270 --> 00:20:56,470
rails tasks so once we call load config

00:20:55,270 --> 00:20:58,029
we can actually look up the real

00:20:56,470 --> 00:20:59,770
configuration objects because the

00:20:58,029 --> 00:21:01,419
environment will be loaded we use the

00:20:59,770 --> 00:21:03,010
fake ones to create the name then we

00:21:01,419 --> 00:21:05,590
load the config and then get the real

00:21:03,010 --> 00:21:07,630
ones this lets us avoid a performance

00:21:05,590 --> 00:21:08,950
hit on generating the task names but

00:21:07,630 --> 00:21:11,830
still gets everything we need for

00:21:08,950 --> 00:21:14,230
multiple databases the rest of this task

00:21:11,830 --> 00:21:16,149
is similar to the main migrate tasks so

00:21:14,230 --> 00:21:17,590
we're just not going to look at it while

00:21:16,149 --> 00:21:19,360
the majority of rails tasks are

00:21:17,590 --> 00:21:22,090
supported there are a few that we don't

00:21:19,360 --> 00:21:24,190
support DB migrated up DB migrated down

00:21:22,090 --> 00:21:26,700
and DB rollback tasks can support

00:21:24,190 --> 00:21:29,620
multiple databases because

00:21:26,700 --> 00:21:31,090
operating on all data tasks databases in

00:21:29,620 --> 00:21:33,220
an environment doesn't make sense for

00:21:31,090 --> 00:21:34,960
these tasks if you say to roll back two

00:21:33,220 --> 00:21:36,370
steps should all the databases roll back

00:21:34,960 --> 00:21:38,799
or just the one that was most recently

00:21:36,370 --> 00:21:39,970
migrated we had a hard time answering

00:21:38,799 --> 00:21:41,590
those questions so instead of

00:21:39,970 --> 00:21:44,169
implementing a potentially confusing

00:21:41,590 --> 00:21:46,990
solution we decided to just not fix

00:21:44,169 --> 00:21:49,029
these tasks if you call these tasks in

00:21:46,990 --> 00:21:51,190
particular in a multiple database

00:21:49,029 --> 00:21:53,950
application we'll raise an error that

00:21:51,190 --> 00:21:55,870
recommends using the named tasks instead

00:21:53,950 --> 00:21:57,010
this gives your application the

00:21:55,870 --> 00:21:59,020
functionality it needs without

00:21:57,010 --> 00:22:02,860
implementing a confusing solution to the

00:21:59,020 --> 00:22:04,690
main tasks one of my favorite features

00:22:02,860 --> 00:22:06,760
of multiple databases are the connection

00:22:04,690 --> 00:22:08,169
api's these simple API is for

00:22:06,760 --> 00:22:10,330
establishing connections and swapping

00:22:08,169 --> 00:22:13,240
connection context are what powers

00:22:10,330 --> 00:22:15,190
multiple databases the connects to API

00:22:13,240 --> 00:22:17,020
enables you to establish more than one

00:22:15,190 --> 00:22:18,789
connection on your models this is very

00:22:17,020 --> 00:22:20,289
similar to established connection except

00:22:18,789 --> 00:22:21,760
for that you need to specify the type of

00:22:20,289 --> 00:22:23,710
connection and the database

00:22:21,760 --> 00:22:24,730
configuration at the same time for all

00:22:23,710 --> 00:22:26,710
of your connections

00:22:24,730 --> 00:22:28,330
in a single database application you

00:22:26,710 --> 00:22:29,950
don't need to call establish connection

00:22:28,330 --> 00:22:31,420
in your application code because rails

00:22:29,950 --> 00:22:34,210
does it for you in an active record

00:22:31,420 --> 00:22:35,890
railtie when the app is booted in an

00:22:34,210 --> 00:22:37,570
application with multiple databases we

00:22:35,890 --> 00:22:39,040
need to tell rails that there are more

00:22:37,570 --> 00:22:41,440
there are other connections that need to

00:22:39,040 --> 00:22:43,030
be established depending on the types of

00:22:41,440 --> 00:22:44,380
connections we need there are two ways

00:22:43,030 --> 00:22:46,120
of establishing connections with

00:22:44,380 --> 00:22:47,830
connects two if you're using functional

00:22:46,120 --> 00:22:50,530
partitioning with a single primary and a

00:22:47,830 --> 00:22:52,750
single replica you should pass database

00:22:50,530 --> 00:22:54,580
two connects to the keys in this hash

00:22:52,750 --> 00:22:56,440
represent the role names that you want

00:22:54,580 --> 00:22:58,060
your connection to have by default rails

00:22:56,440 --> 00:22:59,740
expects you to set your primaries to

00:22:58,060 --> 00:23:01,540
writing and your replicas to reading

00:22:59,740 --> 00:23:04,450
there are ways to change this but I

00:23:01,540 --> 00:23:06,250
don't recommend using it the second part

00:23:04,450 --> 00:23:07,780
of the hash represents the database

00:23:06,250 --> 00:23:09,730
configuration names you want to use

00:23:07,780 --> 00:23:11,560
these must match the second level of

00:23:09,730 --> 00:23:13,570
your configuration database

00:23:11,560 --> 00:23:15,730
configuration exactly in order to set up

00:23:13,570 --> 00:23:16,960
the connections properly connects to

00:23:15,730 --> 00:23:19,060
should only ever be called on an

00:23:16,960 --> 00:23:20,560
abstract classes database clients have a

00:23:19,060 --> 00:23:22,750
limit to the number of open connections

00:23:20,560 --> 00:23:25,690
you can have so you want to ensure that

00:23:22,750 --> 00:23:27,160
you're only establishing each connection

00:23:25,690 --> 00:23:28,960
once always set up your database

00:23:27,160 --> 00:23:30,370
connections in an abstract class and

00:23:28,960 --> 00:23:33,820
inherent models that need to talk to

00:23:30,370 --> 00:23:35,470
that database from the parent class you

00:23:33,820 --> 00:23:37,240
can also connect to multiple shards and

00:23:35,470 --> 00:23:40,270
roles in a model with the shards keyword

00:23:37,240 --> 00:23:42,310
argument default shard one and shard to

00:23:40,270 --> 00:23:43,810
represent the shard keys you must name

00:23:42,310 --> 00:23:45,550
one of the shards default otherwise

00:23:43,810 --> 00:23:46,600
rails will automatically create one and

00:23:45,550 --> 00:23:48,610
you might end up with duplicate

00:23:46,600 --> 00:23:51,210
connections all the other shards can

00:23:48,610 --> 00:23:53,410
have any name you want the default shard

00:23:51,210 --> 00:23:54,940
should be the shard that contains the

00:23:53,410 --> 00:23:56,710
references to the other shards that you

00:23:54,940 --> 00:23:59,860
know which turn to look up your data

00:23:56,710 --> 00:24:01,660
from just like the database argument the

00:23:59,860 --> 00:24:03,640
hash for each shard represents the role

00:24:01,660 --> 00:24:04,600
and database configuration name

00:24:03,640 --> 00:24:06,630
respectively

00:24:04,600 --> 00:24:08,530
once you have an active connection your

00:24:06,630 --> 00:24:10,690
applications models will need to be able

00:24:08,530 --> 00:24:12,190
to switch between roles and shards we

00:24:10,690 --> 00:24:15,040
provided that functionality with the

00:24:12,190 --> 00:24:16,720
connected to API this API enables you to

00:24:15,040 --> 00:24:18,520
switch between shards or roles in a

00:24:16,720 --> 00:24:19,660
model controller scripts anywhere that

00:24:18,520 --> 00:24:22,120
you need to change the connection

00:24:19,660 --> 00:24:24,070
context let's look at how we can use the

00:24:22,120 --> 00:24:26,560
connections connected to API to select

00:24:24,070 --> 00:24:28,150
data from your replicas this method will

00:24:26,560 --> 00:24:29,620
swap the reading role so that you can

00:24:28,150 --> 00:24:31,870
select data from the reading connection

00:24:29,620 --> 00:24:33,460
pools the connection itself is chosen by

00:24:31,870 --> 00:24:36,100
the model that were that we're loading

00:24:33,460 --> 00:24:37,480
like user or dinner recipe we also knows

00:24:36,100 --> 00:24:38,890
that user inherits from

00:24:37,480 --> 00:24:40,390
education record and dinner recipe

00:24:38,890 --> 00:24:42,160
inherits from meal application record

00:24:40,390 --> 00:24:44,710
and we'll use that to select the

00:24:42,160 --> 00:24:46,270
connection from the pool connected to is

00:24:44,710 --> 00:24:49,179
used to switch the context in which

00:24:46,270 --> 00:24:51,940
you're finding of which pool which group

00:24:49,179 --> 00:24:53,350
of pools you're looking up from if you

00:24:51,940 --> 00:24:55,750
try to write data to the reading role

00:24:53,350 --> 00:24:57,280
rails will raise a read-only error this

00:24:55,750 --> 00:24:58,299
happened this will happen regardless of

00:24:57,280 --> 00:24:58,960
whether your replicas have a read-only

00:24:58,299 --> 00:25:00,940
user

00:24:58,960 --> 00:25:03,370
it's just a nice freebie that we give in

00:25:00,940 --> 00:25:05,710
addition connected to can also take a

00:25:03,370 --> 00:25:07,990
prevent writes argument which can raise

00:25:05,710 --> 00:25:10,120
it a read-only error on any role for you

00:25:07,990 --> 00:25:11,860
this might be useful if your app is just

00:25:10,120 --> 00:25:13,450
getting started with multiple databases

00:25:11,860 --> 00:25:16,240
and you want to ensure that you're not

00:25:13,450 --> 00:25:17,860
writing when you mean to read before you

00:25:16,240 --> 00:25:20,710
get your data your replicas set up in

00:25:17,860 --> 00:25:22,090
production this is also also useful if

00:25:20,710 --> 00:25:23,530
you're using a role name something other

00:25:22,090 --> 00:25:25,660
than reading and want to ensure writes

00:25:23,530 --> 00:25:27,450
or blocks if you have a slow reading

00:25:25,660 --> 00:25:29,740
role or something like that

00:25:27,450 --> 00:25:31,600
switching shards with connected to is as

00:25:29,740 --> 00:25:34,150
simple as passing the shard key with a

00:25:31,600 --> 00:25:36,070
shard name that you want to switch the

00:25:34,150 --> 00:25:37,630
shard key behaves similarly to the role

00:25:36,070 --> 00:25:39,760
key by looking up connections from the

00:25:37,630 --> 00:25:41,980
pool based on the context set and

00:25:39,760 --> 00:25:43,510
connected to if you only pass a shard

00:25:41,980 --> 00:25:44,830
and don't have some role rao's assumes

00:25:43,510 --> 00:25:46,630
that you want the writing connection

00:25:44,830 --> 00:25:48,790
switching to the reading connection is

00:25:46,630 --> 00:25:51,160
is as easy as calling roll and shard

00:25:48,790 --> 00:25:52,809
together and connected to if you switch

00:25:51,160 --> 00:25:54,340
to shard two and try to load a model

00:25:52,809 --> 00:25:56,260
that doesn't have a shard to connection

00:25:54,340 --> 00:25:58,450
a connection not established error will

00:25:56,260 --> 00:26:00,760
be raised this is because the user has

00:25:58,450 --> 00:26:02,650
no connection user has no connection

00:26:00,760 --> 00:26:04,419
associate with a shard to key if we

00:26:02,650 --> 00:26:06,130
establish one an application record with

00:26:04,419 --> 00:26:08,770
connects to we'd be able to find that

00:26:06,130 --> 00:26:10,090
one in the pool let's take a look at how

00:26:08,770 --> 00:26:12,309
these connection contacts work

00:26:10,090 --> 00:26:13,870
internally in rails in a single database

00:26:12,309 --> 00:26:15,940
application we have a single connection

00:26:13,870 --> 00:26:18,190
handler by default rails will always

00:26:15,940 --> 00:26:20,320
have a writing role the writing handler

00:26:18,190 --> 00:26:23,049
looks of connections by class name in

00:26:20,320 --> 00:26:24,910
rl6 and below the class name lookup for

00:26:23,049 --> 00:26:26,770
active record base was set to primary

00:26:24,910 --> 00:26:28,450
but in the sixth one we changed it to

00:26:26,770 --> 00:26:29,950
match the class name since all of the

00:26:28,450 --> 00:26:32,679
other connections are looked at by class

00:26:29,950 --> 00:26:34,419
name and we wanted to be consistent the

00:26:32,679 --> 00:26:36,850
class name is mapped to an object called

00:26:34,419 --> 00:26:37,990
pool config the pool config codes holds

00:26:36,850 --> 00:26:39,549
a reference to the connection

00:26:37,990 --> 00:26:42,580
specification name which is a pointer

00:26:39,549 --> 00:26:44,860
back to the cat the class cache key the

00:26:42,580 --> 00:26:46,480
DB config which is an entire database

00:26:44,860 --> 00:26:49,299
configuration object that belongs to

00:26:46,480 --> 00:26:51,480
pool and the schema cache last of the

00:26:49,299 --> 00:26:54,520
pool config points to the pool

00:26:51,480 --> 00:26:56,380
connection pool itself when you call a

00:26:54,520 --> 00:26:58,630
model in one of in one of the meals

00:26:56,380 --> 00:27:00,250
databases like dinner recipe reals looks

00:26:58,630 --> 00:27:01,900
at the connection based on the parent

00:27:00,250 --> 00:27:04,450
class name which for dinner recipe is

00:27:01,900 --> 00:27:06,220
meal application record as with after

00:27:04,450 --> 00:27:07,360
record based the class references the

00:27:06,220 --> 00:27:10,030
pool config which references the

00:27:07,360 --> 00:27:12,340
connection pool when you switch

00:27:10,030 --> 00:27:13,900
connections from writing to reading

00:27:12,340 --> 00:27:15,610
rails is able to look up the connection

00:27:13,900 --> 00:27:17,410
the same way to Don the writing handler

00:27:15,610 --> 00:27:19,450
all it's doing is switching the contact

00:27:17,410 --> 00:27:21,490
and then using the same lookup code to

00:27:19,450 --> 00:27:23,950
find the pool based on the parent class

00:27:21,490 --> 00:27:25,330
name since browser knows how to find the

00:27:23,950 --> 00:27:26,980
connection based on the class name its

00:27:25,330 --> 00:27:28,960
symbol for the connections from the pool

00:27:26,980 --> 00:27:30,910
wants me switch from reading to reading

00:27:28,960 --> 00:27:33,010
context and vice-versa where else can

00:27:30,910 --> 00:27:34,630
easily just pick those up looking at

00:27:33,010 --> 00:27:37,440
this example you may be realizing that

00:27:34,630 --> 00:27:39,550
this can't possibly support shards if

00:27:37,440 --> 00:27:41,380
we're always keying connections in the

00:27:39,550 --> 00:27:43,240
class name then adding a second and

00:27:41,380 --> 00:27:44,500
third shard or the same class name would

00:27:43,240 --> 00:27:46,180
make it impossible to look up the

00:27:44,500 --> 00:27:47,590
correct connection when we swap shards

00:27:46,180 --> 00:27:48,940
how can we look up the correct

00:27:47,590 --> 00:27:52,030
connection if we don't have a unique

00:27:48,940 --> 00:27:54,010
identifier this particular problem was

00:27:52,030 --> 00:27:56,470
our blocker for adding sharding support

00:27:54,010 --> 00:27:58,840
we fix this by creating an intermediary

00:27:56,470 --> 00:28:01,150
called pool manager instead of pointing

00:27:58,840 --> 00:28:02,470
the handler the handler to the class and

00:28:01,150 --> 00:28:04,960
then the pool directly to the pool

00:28:02,470 --> 00:28:06,820
config we changed active record to have

00:28:04,960 --> 00:28:09,400
the class point to a new object called

00:28:06,820 --> 00:28:13,090
pool manager the pool manager was keyed

00:28:09,400 --> 00:28:15,130
but is pute is key by the shard key

00:28:13,090 --> 00:28:17,110
passed and it connects to for non shard

00:28:15,130 --> 00:28:18,970
edit connections we simply continue

00:28:17,110 --> 00:28:21,250
using that default sharp key this is why

00:28:18,970 --> 00:28:23,800
it's important that you always have a

00:28:21,250 --> 00:28:25,330
default because rails will set one this

00:28:23,800 --> 00:28:27,490
is the way that we were able to maintain

00:28:25,330 --> 00:28:30,340
behavior for a non-charter applications

00:28:27,490 --> 00:28:32,830
without breaking any api's and then this

00:28:30,340 --> 00:28:34,720
that then we allow multiple connections

00:28:32,830 --> 00:28:36,700
on shards for a single class by having a

00:28:34,720 --> 00:28:38,140
different pool manager for each of the

00:28:36,700 --> 00:28:41,050
pool can fix that belong to meal

00:28:38,140 --> 00:28:44,290
application base meal application record

00:28:41,050 --> 00:28:46,390
this intermediary allowed a public API

00:28:44,290 --> 00:28:47,980
for sharding to be implemented and we

00:28:46,390 --> 00:28:52,240
were able to solve this without breaking

00:28:47,980 --> 00:28:53,860
a single public API don't worry if you

00:28:52,240 --> 00:28:55,270
didn't follow this too closely you don't

00:28:53,860 --> 00:28:56,830
need to know how any of the internal

00:28:55,270 --> 00:28:58,090
architecture of connection management

00:28:56,830 --> 00:29:00,790
works to be able to use multiple

00:28:58,090 --> 00:29:02,890
databases in your application as you saw

00:29:00,790 --> 00:29:04,840
in my demo earlier and enhancements and

00:29:02,890 --> 00:29:06,659
rails that rails provides is a middle

00:29:04,840 --> 00:29:08,710
we're for automatic connection swapping

00:29:06,659 --> 00:29:10,240
currently only role swapping is

00:29:08,710 --> 00:29:11,590
supported in the middleware sharding

00:29:10,240 --> 00:29:14,380
support should be coming soon

00:29:11,590 --> 00:29:16,450
the automatic role swapping middleware

00:29:14,380 --> 00:29:18,340
switches the comp the connection context

00:29:16,450 --> 00:29:20,799
based on the request type and how a

00:29:18,340 --> 00:29:22,570
recent the last Rite was the middleware

00:29:20,799 --> 00:29:24,279
is designed to guarantee read your own

00:29:22,570 --> 00:29:26,260
right which means that if you write data

00:29:24,279 --> 00:29:28,390
we guarantee that you'll be able to read

00:29:26,260 --> 00:29:30,039
it because we send your requests the

00:29:28,390 --> 00:29:31,870
primary until it's safe to send them to

00:29:30,039 --> 00:29:34,179
the replicas it does not guarantee

00:29:31,870 --> 00:29:37,360
immediate rights for any user who didn't

00:29:34,179 --> 00:29:40,029
perform the data update the middleware

00:29:37,360 --> 00:29:42,070
can be activated by the rails

00:29:40,029 --> 00:29:43,899
configuration by default rails will use

00:29:42,070 --> 00:29:45,700
a two-second delay before switching read

00:29:43,899 --> 00:29:48,610
requests back to the replica after a

00:29:45,700 --> 00:29:50,140
right to account for replication lag you

00:29:48,610 --> 00:29:51,309
can change this to any number or

00:29:50,140 --> 00:29:53,200
calculation that works for your

00:29:51,309 --> 00:29:55,000
application for more advanced

00:29:53,200 --> 00:29:57,190
requirements of any of the classes in

00:29:55,000 --> 00:29:59,230
the middle where they can be overwritten

00:29:57,190 --> 00:30:01,840
and were specifically designed for that

00:29:59,230 --> 00:30:03,970
purpose internally in rails the database

00:30:01,840 --> 00:30:05,860
selector middleware is initialized by an

00:30:03,970 --> 00:30:09,130
app resolve our class context class and

00:30:05,860 --> 00:30:10,899
options the resolver class determines

00:30:09,130 --> 00:30:12,580
which database role to switch to and the

00:30:10,899 --> 00:30:14,559
context class is the context in which we

00:30:12,580 --> 00:30:16,960
switch by default the context for

00:30:14,559 --> 00:30:18,460
switching is stored in a session when a

00:30:16,960 --> 00:30:20,980
request begins the select database

00:30:18,460 --> 00:30:22,899
method is called in this method rails

00:30:20,980 --> 00:30:25,809
checks whether the request is a reading

00:30:22,899 --> 00:30:28,779
request a reading request is a get or

00:30:25,809 --> 00:30:30,460
head request if if it is we'll call

00:30:28,779 --> 00:30:33,039
resolver read otherwise we'll call

00:30:30,460 --> 00:30:34,419
resolver write the resolver read method

00:30:33,039 --> 00:30:36,730
checks whether it's safe to read from

00:30:34,419 --> 00:30:38,710
the replicas or not read from primary

00:30:36,730 --> 00:30:41,080
checks whether the time since the since

00:30:38,710 --> 00:30:43,090
last write is OK this is calculated by

00:30:41,080 --> 00:30:44,409
the context timestamp which is by

00:30:43,090 --> 00:30:46,840
default the sessions last right

00:30:44,409 --> 00:30:48,909
timestamp so tracted by the current time

00:30:46,840 --> 00:30:51,520
and then ensures that it's less than or

00:30:48,909 --> 00:30:53,649
equal to the delay greater than or equal

00:30:51,520 --> 00:30:55,840
to the day the delay is set by the

00:30:53,649 --> 00:30:58,720
middleware options and the default is

00:30:55,840 --> 00:31:00,940
two seconds if times this last write is

00:30:58,720 --> 00:31:03,220
not okay we read from the primary

00:31:00,940 --> 00:31:05,380
bypassing the writing role to connected

00:31:03,220 --> 00:31:07,120
to and ensuring writes are prevented if

00:31:05,380 --> 00:31:09,220
time since last right is okay we call

00:31:07,120 --> 00:31:11,980
reverb replica which uses the reading

00:31:09,220 --> 00:31:13,600
role lastly if we have an on reading

00:31:11,980 --> 00:31:15,460
request and are performing a put patch

00:31:13,600 --> 00:31:18,070
pose delete or any other kind of request

00:31:15,460 --> 00:31:18,730
that writes the database we call right

00:31:18,070 --> 00:31:21,880
to primary

00:31:18,730 --> 00:31:23,820
and the rating rule and writing role is

00:31:21,880 --> 00:31:26,470
set and prevent writes is set to false

00:31:23,820 --> 00:31:29,320
the right to primary method also updates

00:31:26,470 --> 00:31:30,429
the contexts last right timestamp this

00:31:29,320 --> 00:31:31,809
is the timestamp that is used to

00:31:30,429 --> 00:31:33,400
determine when the last write occurred

00:31:31,809 --> 00:31:35,500
so that we can read from the primary

00:31:33,400 --> 00:31:36,790
conditional there are even primary

00:31:35,500 --> 00:31:39,490
conditional can determine whether it's

00:31:36,790 --> 00:31:40,720
safe to read from the replicas or not as

00:31:39,490 --> 00:31:43,240
I mentioned before the middleware is

00:31:40,720 --> 00:31:44,770
designed to be extensible changed and

00:31:43,240 --> 00:31:46,929
overwritten to match your applications

00:31:44,770 --> 00:31:48,520
needs if you prefer to use a cookie for

00:31:46,929 --> 00:31:50,350
your context you can write your own

00:31:48,520 --> 00:31:52,360
cookie class in your application and

00:31:50,350 --> 00:31:54,580
then update the rails configuration to

00:31:52,360 --> 00:31:55,750
use that new class the middleware is

00:31:54,580 --> 00:31:57,940
designed to be a guideline for

00:31:55,750 --> 00:31:59,980
implementing can automatic swapping in

00:31:57,940 --> 00:32:01,419
rails it's purposefully compact and does

00:31:59,980 --> 00:32:04,059
it do everything your application will

00:32:01,419 --> 00:32:05,770
likely need because replication lag and

00:32:04,059 --> 00:32:07,679
other issues with database traffic are

00:32:05,770 --> 00:32:10,450
unique to your application we created

00:32:07,679 --> 00:32:12,340
something that provided a guide for

00:32:10,450 --> 00:32:15,490
automatic swapping without strictly

00:32:12,340 --> 00:32:16,630
forcing you to use rails defaults before

00:32:15,490 --> 00:32:18,640
we get into the last portion of this

00:32:16,630 --> 00:32:21,880
talk I want to take some time to say

00:32:18,640 --> 00:32:23,320
thank you to a few folks first I want to

00:32:21,880 --> 00:32:25,720
say thank you to Ruby central for

00:32:23,320 --> 00:32:27,640
inviting me to railsconf to keynote

00:32:25,720 --> 00:32:29,950
railsconf this year you all do an

00:32:27,640 --> 00:32:31,540
amazing job and I appreciate you while

00:32:29,950 --> 00:32:32,919
we can't be in a room together I'm so

00:32:31,540 --> 00:32:34,510
happy that you were able to provide a

00:32:32,919 --> 00:32:36,520
way for me to share this work with

00:32:34,510 --> 00:32:38,200
everyone next I'd like to thank my

00:32:36,520 --> 00:32:40,030
husband Dave you should tell who we

00:32:38,200 --> 00:32:42,130
spent countless hours listening to me go

00:32:40,030 --> 00:32:44,559
on and on about multiple databases this

00:32:42,130 --> 00:32:46,690
talk and rails in general aim inspires

00:32:44,559 --> 00:32:49,419
me to do great work and has always been

00:32:46,690 --> 00:32:49,900
supportive of me and my goals next I'd

00:32:49,419 --> 00:32:52,120
like to thank

00:32:49,900 --> 00:32:53,950
searles who has helped me with many

00:32:52,120 --> 00:32:55,900
talks over the years and especially this

00:32:53,950 --> 00:32:57,490
one he's the person that I call when I

00:32:55,900 --> 00:32:59,380
can't make a talk work and every single

00:32:57,490 --> 00:33:01,540
time it turns out better because of his

00:32:59,380 --> 00:33:03,490
help next of course I'd like to thank

00:33:01,540 --> 00:33:05,200
thh for creating this framework that has

00:33:03,490 --> 00:33:07,150
not only given me a fulfilling career

00:33:05,200 --> 00:33:09,669
that I love but awesome community and

00:33:07,150 --> 00:33:11,230
some of my closest friends I wouldn't be

00:33:09,669 --> 00:33:12,669
here keynoting railsconf are talking

00:33:11,230 --> 00:33:14,650
about this work if it wasn't for tender

00:33:12,669 --> 00:33:16,000
love it's because of Aaron that I

00:33:14,650 --> 00:33:18,610
started contributing to rails and

00:33:16,000 --> 00:33:19,570
working on fun bugs in active record my

00:33:18,610 --> 00:33:21,700
career wouldn't be the same without

00:33:19,570 --> 00:33:23,679
Aaron and it was his idea to turn the

00:33:21,700 --> 00:33:24,760
database hashes into objects and this

00:33:23,679 --> 00:33:28,240
feature turned out so much better

00:33:24,760 --> 00:33:31,090
because of that thank you to see John

00:33:28,240 --> 00:33:31,610
run we started pairing to fix a bug in

00:33:31,090 --> 00:33:33,110
your

00:33:31,610 --> 00:33:34,700
configs one day and then we just never

00:33:33,110 --> 00:33:38,270
stopped many of the features and

00:33:34,700 --> 00:33:39,590
improvements in late 2019 and early this

00:33:38,270 --> 00:33:41,750
year were work that John and I did

00:33:39,590 --> 00:33:43,670
together it was John's idea to use the

00:33:41,750 --> 00:33:44,630
pool manager for sharding and without

00:33:43,670 --> 00:33:46,900
him we probably wouldn't have

00:33:44,630 --> 00:33:48,980
implemented charting yet four six one

00:33:46,900 --> 00:33:50,420
lastly I want to say thank you to all of

00:33:48,980 --> 00:33:52,250
you watching at home from your couch

00:33:50,420 --> 00:33:53,480
while it's sad that we can't be in a

00:33:52,250 --> 00:33:55,280
room together I'm glad that I'm still

00:33:53,480 --> 00:33:56,840
able to share this experience and talk

00:33:55,280 --> 00:34:00,350
with you I hope that you've enjoyed it

00:33:56,840 --> 00:34:02,330
so far when I first started working on

00:34:00,350 --> 00:34:04,460
multiple databases I had no idea how

00:34:02,330 --> 00:34:05,660
much work it was going to be I could

00:34:04,460 --> 00:34:08,119
hope we had rolled around multiple

00:34:05,660 --> 00:34:10,250
database setup years ago we had monkey

00:34:08,119 --> 00:34:12,230
patched active record adding custom

00:34:10,250 --> 00:34:14,480
methods for establishing connections and

00:34:12,230 --> 00:34:16,639
written custom rails tasks we had hacks

00:34:14,480 --> 00:34:18,710
on hacks on hacks on hacks to make my

00:34:16,639 --> 00:34:20,570
creations work connection swapping work

00:34:18,710 --> 00:34:22,760
and an around filter for auto swapping

00:34:20,570 --> 00:34:24,560
connections since I hadn't written any

00:34:22,760 --> 00:34:26,149
of the functionality we had a github I

00:34:24,560 --> 00:34:27,980
couldn't go straight to up streaming our

00:34:26,149 --> 00:34:29,359
hacks I needed to figure out what rails

00:34:27,980 --> 00:34:31,639
was missing and what features we

00:34:29,359 --> 00:34:33,260
actually needed just because it was in

00:34:31,639 --> 00:34:35,330
github didn't mean it was necessary to

00:34:33,260 --> 00:34:36,800
implement in rails I am home added

00:34:35,330 --> 00:34:38,119
multiple databases on a brand new

00:34:36,800 --> 00:34:40,639
application to see what the user

00:34:38,119 --> 00:34:42,440
experience and rails was really like it

00:34:40,639 --> 00:34:44,000
didn't take long to find that even basic

00:34:42,440 --> 00:34:45,320
functionality was missing and I quickly

00:34:44,000 --> 00:34:46,280
discovered that migrations were

00:34:45,320 --> 00:34:47,929
completely broken

00:34:46,280 --> 00:34:49,570
there was no chain way to change the

00:34:47,929 --> 00:34:51,919
connection no migration was running on

00:34:49,570 --> 00:34:54,950
there was three level there was a three

00:34:51,919 --> 00:34:57,590
level config that was that was supported

00:34:54,950 --> 00:34:59,090
by rails but the feature wasn't parsing

00:34:57,590 --> 00:35:00,410
the configurations correctly and any

00:34:59,090 --> 00:35:03,530
application using this feature would

00:35:00,410 --> 00:35:05,090
fail to boot there were no rails tasks

00:35:03,530 --> 00:35:06,710
for creating deleting migrating or

00:35:05,090 --> 00:35:09,770
operating on more than one database per

00:35:06,710 --> 00:35:11,420
environment beyond missing the basics

00:35:09,770 --> 00:35:12,619
that make rails enjoyable there was no

00:35:11,420 --> 00:35:14,420
way to establish more than one

00:35:12,619 --> 00:35:16,640
connection per class there was no

00:35:14,420 --> 00:35:20,300
support support for roles or shards or

00:35:16,640 --> 00:35:23,600
replicas lastly there was no API or a

00:35:20,300 --> 00:35:25,460
pattern for an auto switching API in

00:35:23,600 --> 00:35:27,320
situations like this it's easy to get

00:35:25,460 --> 00:35:28,940
overwhelmed and I'd be lying to you if I

00:35:27,320 --> 00:35:30,800
never said that I got frustrated or

00:35:28,940 --> 00:35:32,810
angry or unsure of the right way to fix

00:35:30,800 --> 00:35:34,490
something I wasn't the first person

00:35:32,810 --> 00:35:36,080
involved in rails that tried to add

00:35:34,490 --> 00:35:38,450
first-class support from multiple

00:35:36,080 --> 00:35:40,220
databases there are a bunch of gems that

00:35:38,450 --> 00:35:41,930
do similar work and we had tried over

00:35:40,220 --> 00:35:44,990
the years to make it a priority on rails

00:35:41,930 --> 00:35:46,760
core however often we get hung up on the

00:35:44,990 --> 00:35:49,550
perfect API or how to fix on the

00:35:46,760 --> 00:35:51,500
internals without breaking public api's

00:35:49,550 --> 00:35:53,300
I knew this was going to be a big

00:35:51,500 --> 00:35:54,050
project so instead of trying to fix it

00:35:53,300 --> 00:35:56,210
all at once

00:35:54,050 --> 00:35:57,860
I broke the problem into features that

00:35:56,210 --> 00:36:00,020
were needed to make multiple databases

00:35:57,860 --> 00:36:02,840
and rails not just functional but a

00:36:00,020 --> 00:36:04,340
positive user experience first we fix

00:36:02,840 --> 00:36:06,890
migrations to know about migrations

00:36:04,340 --> 00:36:08,900
paths then we turn the configurations

00:36:06,890 --> 00:36:11,000
into objects then we made the rails

00:36:08,900 --> 00:36:13,190
tasks functional next we focused on a

00:36:11,000 --> 00:36:14,600
connection api's we fixed a lot of

00:36:13,190 --> 00:36:17,300
internals and eventually built a

00:36:14,600 --> 00:36:18,740
sharding API then we implemented a API

00:36:17,300 --> 00:36:21,500
and pattern for automatic connection

00:36:18,740 --> 00:36:24,380
switching there's a lot of work left to

00:36:21,500 --> 00:36:26,090
do but we've accomplished a ton in two

00:36:24,380 --> 00:36:27,680
and a half years if we zoom in on the

00:36:26,090 --> 00:36:30,950
timeline we'd be able to see that from

00:36:27,680 --> 00:36:33,410
January 2018 to June 2019 the majority

00:36:30,950 --> 00:36:35,450
of the work was on the public API we

00:36:33,410 --> 00:36:37,580
heavily focused on application and user

00:36:35,450 --> 00:36:40,190
experience to ensure a smooth and easy

00:36:37,580 --> 00:36:41,630
to use feature if we rewrote internals

00:36:40,190 --> 00:36:43,970
without knowing the user experience or

00:36:41,630 --> 00:36:46,040
API so I mean end up either trying to

00:36:43,970 --> 00:36:48,230
force the API to fit into work that we'd

00:36:46,040 --> 00:36:51,230
done or turning internal code over and

00:36:48,230 --> 00:36:54,520
over again for the later half of 2019

00:36:51,230 --> 00:36:57,800
into 2020 we focused mostly on private

00:36:54,520 --> 00:36:59,810
internal api's a lot of this work was to

00:36:57,800 --> 00:37:01,520
fix bugs or inconsistencies in the non

00:36:59,810 --> 00:37:03,650
public facing code we removed

00:37:01,520 --> 00:37:05,000
undocumented classes shopify we rewrote

00:37:03,650 --> 00:37:08,090
the paid tracker to use a more modern

00:37:05,000 --> 00:37:10,010
active support fork tracker and we can

00:37:08,090 --> 00:37:11,930
convert into hash lookups to use the

00:37:10,010 --> 00:37:13,910
database configuration objects our

00:37:11,930 --> 00:37:15,650
approach to fixing the public API first

00:37:13,910 --> 00:37:18,200
and then working inwards is kind of

00:37:15,650 --> 00:37:20,630
unique as software engineers we want to

00:37:18,200 --> 00:37:22,400
anticipate everyone's needs and future

00:37:20,630 --> 00:37:24,859
use cases and try to fix all of the

00:37:22,400 --> 00:37:26,060
broken internal things first we want to

00:37:24,859 --> 00:37:28,220
build the most resilient and most

00:37:26,060 --> 00:37:30,650
perfect software to do this we need a

00:37:28,220 --> 00:37:32,090
strong foundation right what have I told

00:37:30,650 --> 00:37:33,650
you that rails foundation is already

00:37:32,090 --> 00:37:35,030
strong enough it wouldn't have an

00:37:33,650 --> 00:37:37,280
impossible for me to build these public

00:37:35,030 --> 00:37:38,480
API if that wasn't true it would have

00:37:37,280 --> 00:37:39,890
been impossible for everyone to monkey

00:37:38,480 --> 00:37:41,660
patch rails to work with multiple

00:37:39,890 --> 00:37:43,310
databases or build their gems if Wells

00:37:41,660 --> 00:37:46,520
is prompt to foundation wasn't already

00:37:43,310 --> 00:37:48,170
strong enough well a strong foundation

00:37:46,520 --> 00:37:50,330
is why applications that start on rails

00:37:48,170 --> 00:37:52,550
can grow on Rails as long as we keep

00:37:50,330 --> 00:37:54,080
improving that foundation where else

00:37:52,550 --> 00:37:55,400
keeps your applications simple and less

00:37:54,080 --> 00:37:58,250
complex because it takes on that

00:37:55,400 --> 00:37:58,810
complexity for you we built rails as a

00:37:58,250 --> 00:38:00,400
strong

00:37:58,810 --> 00:38:02,200
Foundation to support your applications

00:38:00,400 --> 00:38:03,790
as they grow from rails new into an

00:38:02,200 --> 00:38:05,890
application that serves millions of

00:38:03,790 --> 00:38:08,050
requests and stores terabytes of data

00:38:05,890 --> 00:38:09,790
the majority of rails functionality has

00:38:08,050 --> 00:38:11,650
been extracted from real applications

00:38:09,790 --> 00:38:14,080
running in production this is what makes

00:38:11,650 --> 00:38:16,120
rails so stable we build rails to

00:38:14,080 --> 00:38:18,510
support your applications we don't build

00:38:16,120 --> 00:38:21,100
rails for perfect imaginary use cases

00:38:18,510 --> 00:38:23,080
building for perfect use cases doesn't

00:38:21,100 --> 00:38:25,750
work when you have to support public

00:38:23,080 --> 00:38:27,580
widely used api's when you're building

00:38:25,750 --> 00:38:28,990
for open source we're not building for

00:38:27,580 --> 00:38:31,690
ourselves or for our company or a

00:38:28,990 --> 00:38:33,040
product we're building for everyone it

00:38:31,690 --> 00:38:34,330
would've been selfish for me to rewrite

00:38:33,040 --> 00:38:36,310
connection management to be what I

00:38:34,330 --> 00:38:38,490
thought it would be the thought would be

00:38:36,310 --> 00:38:40,900
perfect without considering your needs

00:38:38,490 --> 00:38:42,550
when building open-source tools you must

00:38:40,900 --> 00:38:44,320
consider what public api's might break

00:38:42,550 --> 00:38:46,120
what use cases you're not considering

00:38:44,320 --> 00:38:47,590
you must be flexible enough to change

00:38:46,120 --> 00:38:49,390
course when your plans don't work out

00:38:47,590 --> 00:38:51,490
but not so flexible that features never

00:38:49,390 --> 00:38:53,980
shipped you to scope creep or a strive

00:38:51,490 --> 00:38:55,570
for perfection finding this balance is

00:38:53,980 --> 00:38:58,180
really difficult but it's essential to

00:38:55,570 --> 00:38:59,770
supporting open source work when we

00:38:58,180 --> 00:39:01,960
build features for rails we don't build

00:38:59,770 --> 00:39:05,200
features for ourselves or egos or needs

00:39:01,960 --> 00:39:08,380
we built brows fruit you you built

00:39:05,200 --> 00:39:10,180
multiple databases for you rails is

00:39:08,380 --> 00:39:11,890
truly unique even if you think that

00:39:10,180 --> 00:39:13,360
rails has too many features our don't

00:39:11,890 --> 00:39:14,590
agree with the API is or don't like how

00:39:13,360 --> 00:39:16,030
we run the community you'd be

00:39:14,590 --> 00:39:17,920
hard-pressed to find any framework that

00:39:16,030 --> 00:39:19,360
cares more about you than rails we

00:39:17,920 --> 00:39:21,280
literally optimized for programmer

00:39:19,360 --> 00:39:22,420
happiness how many languages are

00:39:21,280 --> 00:39:24,880
frameworks in the world can say they

00:39:22,420 --> 00:39:26,050
actually care about you without this

00:39:24,880 --> 00:39:28,300
rails would just be another framework

00:39:26,050 --> 00:39:29,800
most frameworks only care about bites

00:39:28,300 --> 00:39:32,080
and widgets and other interpersonal

00:39:29,800 --> 00:39:34,090
things rails actually cares about you

00:39:32,080 --> 00:39:35,740
not in the sense that it's sentient but

00:39:34,090 --> 00:39:37,780
it's built with your experience as a

00:39:35,740 --> 00:39:39,160
human in mind where else cares about

00:39:37,780 --> 00:39:41,560
your applications your company where

00:39:39,160 --> 00:39:43,360
else cared about you when I give

00:39:41,560 --> 00:39:45,520
presentations I usually ask something in

00:39:43,360 --> 00:39:46,720
the audience in past talks I've asked

00:39:45,520 --> 00:39:48,430
you to look at your applications for a

00:39:46,720 --> 00:39:50,350
technical debt that you can upstream to

00:39:48,430 --> 00:39:52,390
Rails or I've asked you to upgrade your

00:39:50,350 --> 00:39:54,130
applications so we continue to serve so

00:39:52,390 --> 00:39:56,950
we can continue to support and use rails

00:39:54,130 --> 00:39:58,570
for the long term for this talk I only

00:39:56,950 --> 00:39:59,920
want you to know how much it means to me

00:39:58,570 --> 00:40:02,530
that you are all a part of this

00:39:59,920 --> 00:40:05,350
community I'm so grateful for all of you

00:40:02,530 --> 00:40:07,300
this timeline in this talk isn't just a

00:40:05,350 --> 00:40:09,460
visual representation of the work that

00:40:07,300 --> 00:40:11,140
went into multiple databases it's a

00:40:09,460 --> 00:40:12,010
visual representation of my love of

00:40:11,140 --> 00:40:14,470
rails

00:40:12,010 --> 00:40:16,930
this community while this railsconf

00:40:14,470 --> 00:40:19,540
keynote was technically a talk it's

00:40:16,930 --> 00:40:21,340
actually a love letter regardless of

00:40:19,540 --> 00:40:23,230
your role whether it's user bug report

00:40:21,340 --> 00:40:26,110
or contributor multiple databases is a

00:40:23,230 --> 00:40:28,090
success because of you your success is

00:40:26,110 --> 00:40:30,960
my success thank you for letting me

00:40:28,090 --> 00:40:30,960

YouTube URL: https://www.youtube.com/watch?v=vebtTRXAznU


