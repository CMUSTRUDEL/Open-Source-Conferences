Title: RailsConf 2020 CE - Fake It While You Make It by Kevin Murphy
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Fake It While You Make It by Kevin Murphy

"We all write code to interface with external systems, like a web service or a message queue. Can you confidently write tests without requiring the system as a dependency? How can you shield users of your code from the inner workings of the interface? Explore one attempt to answer these questions.

There's no shortage of tools at your disposal to solve these problems. This talk will introduce some available options, provide guidance on when one approach may be more appropriate than another, and discuss how to use these tools together to ease the testing process."

__________

"Kevin spent more time investigating, refactoring, and rewriting tests for the project that prompted this talk than he did writing the actual implementation.

Kevin lives near Boston, where he is a Software Developer at The Gnar Company."
Captions: 
	00:00:09,330 --> 00:00:15,269
today we're going to be talking about

00:00:12,150 --> 00:00:15,269
third-party dependencies

00:00:15,990 --> 00:00:21,599
ask what's the weather like for your app

00:00:19,130 --> 00:00:24,210
obviously I've been spending a lot more

00:00:21,599 --> 00:00:25,800
time at home lately but still been

00:00:24,210 --> 00:00:27,360
trying to get out the neighborhood for a

00:00:25,800 --> 00:00:29,099
walk once a day and you know after

00:00:27,360 --> 00:00:32,189
spending the day cooped up inside I've

00:00:29,099 --> 00:00:35,280
got a wonder before I head out should I

00:00:32,189 --> 00:00:37,410
put a sweater on yeah obviously that's

00:00:35,280 --> 00:00:40,080
partially dependent on the weather

00:00:37,410 --> 00:00:41,580
outside and personal preferences but the

00:00:40,080 --> 00:00:43,170
Weather Channel tried to answer that

00:00:41,580 --> 00:00:45,180
question a few years ago by running a

00:00:43,170 --> 00:00:46,910
survey where they asked people what they

00:00:45,180 --> 00:00:50,159
thought the start of sweater weather was

00:00:46,910 --> 00:00:53,339
in the United States the answer was

00:00:50,159 --> 00:00:55,650
between 55 and 65 degrees Fahrenheit

00:00:53,339 --> 00:00:57,690
obviously differed between regions and

00:00:55,650 --> 00:01:00,619
where I'm at in Massachusetts the

00:00:57,690 --> 00:01:03,900
average was 57 degrees Fahrenheit so

00:01:00,619 --> 00:01:06,720
today we're going to build a system to

00:01:03,900 --> 00:01:09,930
help answer the question is at the start

00:01:06,720 --> 00:01:11,640
of sweater weather my name is Kevin

00:01:09,930 --> 00:01:13,530
Murphy and I'm a software developer at

00:01:11,640 --> 00:01:16,890
the NAR company we're a software

00:01:13,530 --> 00:01:17,970
consultancy in Boston Massachusetts so

00:01:16,890 --> 00:01:19,729
let's start to think about what it would

00:01:17,970 --> 00:01:22,770
look like to build one of these systems

00:01:19,729 --> 00:01:24,079
one of the core things we need is the

00:01:22,770 --> 00:01:27,000
ability to know what the temperature is

00:01:24,079 --> 00:01:28,560
and right now the temperature I care

00:01:27,000 --> 00:01:29,759
about is really just hyperlocal

00:01:28,560 --> 00:01:32,460
right I really just need to know what

00:01:29,759 --> 00:01:34,380
it's like right outside my window so I

00:01:32,460 --> 00:01:36,240
could pull the Raspberry Pi house out of

00:01:34,380 --> 00:01:38,310
the closet stick a temperature probe

00:01:36,240 --> 00:01:42,359
connected to it and put that out the

00:01:38,310 --> 00:01:44,310
window and that'd be sufficient but

00:01:42,359 --> 00:01:45,479
hopefully some time soon it will be safe

00:01:44,310 --> 00:01:47,880
to go out and about

00:01:45,479 --> 00:01:49,170
throughout the world and I might want to

00:01:47,880 --> 00:01:51,990
know what the temperature is in other

00:01:49,170 --> 00:01:54,539
places right like the office or my

00:01:51,990 --> 00:01:56,490
parents house the next date over and I

00:01:54,539 --> 00:01:58,499
suppose I could adjust that by deploying

00:01:56,490 --> 00:01:59,670
a fleet of these raspberry PI's that I

00:01:58,499 --> 00:02:01,560
can connect you to figure out what the

00:01:59,670 --> 00:02:03,600
temperature is where I care about but

00:02:01,560 --> 00:02:05,340
that's not a very scalable solution and

00:02:03,600 --> 00:02:07,920
not very general-purpose right if anyone

00:02:05,340 --> 00:02:09,270
else wanted to use this they have to

00:02:07,920 --> 00:02:12,420
have very specific interests which is

00:02:09,270 --> 00:02:14,910
the weather where I care about so I

00:02:12,420 --> 00:02:16,980
guess what I really need is a weather

00:02:14,910 --> 00:02:18,240
satellite so that anyone can figure out

00:02:16,980 --> 00:02:20,730
what the temperature is where they're at

00:02:18,240 --> 00:02:23,580
and probably a rocket ship to be able to

00:02:20,730 --> 00:02:25,830
launch the satellite into orbit but I

00:02:23,580 --> 00:02:28,490
also like building redundant systems so

00:02:25,830 --> 00:02:30,020
I probably need a couple of these things

00:02:28,490 --> 00:02:31,670
and all of this is to say that this

00:02:30,020 --> 00:02:34,220
presentation is really just my pitch

00:02:31,670 --> 00:02:36,530
deck for my latest startup sweather

00:02:34,220 --> 00:02:38,510
which brings you the latest in real-time

00:02:36,530 --> 00:02:41,150
notifications if you should be wearing a

00:02:38,510 --> 00:02:43,850
sweater this is a great opportunity for

00:02:41,150 --> 00:02:45,620
anyone looking for a new investment all

00:02:43,850 --> 00:02:49,430
I need from you is probably something in

00:02:45,620 --> 00:02:51,860
the realm of eleven billion dollars or I

00:02:49,430 --> 00:02:53,750
mean maybe twenty two billion I'm gonna

00:02:51,860 --> 00:02:56,620
be honest I don't really know I have no

00:02:53,750 --> 00:02:59,660
idea how much of weather satellite costs

00:02:56,620 --> 00:03:00,650
and other than the obvious reasons why I

00:02:59,660 --> 00:03:02,660
don't know what a weather satellite

00:03:00,650 --> 00:03:04,610
costs the main one is I would never

00:03:02,660 --> 00:03:09,080
actually propose that we do this if we

00:03:04,610 --> 00:03:11,540
were building the system we can and will

00:03:09,080 --> 00:03:13,310
build sweather in this presentation but

00:03:11,540 --> 00:03:14,810
I can build it on top of an existing

00:03:13,310 --> 00:03:16,670
system that can tell me what the

00:03:14,810 --> 00:03:18,230
temperature is and thence weather will

00:03:16,670 --> 00:03:21,110
add the value of if you should be

00:03:18,230 --> 00:03:24,200
wearing a sweater this other system is

00:03:21,110 --> 00:03:27,530
the weather API and in this example that

00:03:24,200 --> 00:03:29,270
is our third-party dependency and in

00:03:27,530 --> 00:03:32,510
this presentation this is this

00:03:29,270 --> 00:03:33,830
dependency is an HTTP API but the

00:03:32,510 --> 00:03:37,460
methods were going to discuss for

00:03:33,830 --> 00:03:39,410
testing this HTTP API hold just the same

00:03:37,460 --> 00:03:41,870
as if it were any other kind of

00:03:39,410 --> 00:03:43,760
dependency whether it be a persistence

00:03:41,870 --> 00:03:47,480
layer or a message queue or even just

00:03:43,760 --> 00:03:49,640
someone else's code so let's start to

00:03:47,480 --> 00:03:51,230
build sweater here the main thing is

00:03:49,640 --> 00:03:52,970
going to be a location class that

00:03:51,230 --> 00:03:56,330
answers the question if it's sweater

00:03:52,970 --> 00:03:59,630
weather and we're going to build up a

00:03:56,330 --> 00:04:00,820
URI that is the URL that we need to

00:03:59,630 --> 00:04:03,160
communicate with for our weather API

00:04:00,820 --> 00:04:06,020
we're then going to issue a get request

00:04:03,160 --> 00:04:08,150
and I know that that gives me back JSON

00:04:06,020 --> 00:04:10,700
is when it parse that out to get a hash

00:04:08,150 --> 00:04:12,320
and I know what the response structure

00:04:10,700 --> 00:04:13,610
looks like so now I can get the

00:04:12,320 --> 00:04:16,760
information that I need out of it which

00:04:13,610 --> 00:04:18,890
is what does it feel like outside and

00:04:16,760 --> 00:04:21,230
then I can figure out if it's between 55

00:04:18,890 --> 00:04:23,170
and 65 degrees outside and I can tell

00:04:21,230 --> 00:04:26,630
you if it's the start of sweater weather

00:04:23,170 --> 00:04:29,930
so here it is we basically already built

00:04:26,630 --> 00:04:31,250
sweather so again if anyone's looking

00:04:29,930 --> 00:04:35,210
for an investment opportunity I've got a

00:04:31,250 --> 00:04:36,770
working product ready to go well I guess

00:04:35,210 --> 00:04:38,570
you're sort of taking me at my word that

00:04:36,770 --> 00:04:40,740
it works so I'll prove it to you we'll

00:04:38,570 --> 00:04:45,060
build a test

00:04:40,740 --> 00:04:46,890
I will new up a new location and will

00:04:45,060 --> 00:04:50,220
ask if it's wet weather and will assert

00:04:46,890 --> 00:04:52,680
that it's true now when I was originally

00:04:50,220 --> 00:04:54,300
writing this test it was an unseasonable

00:04:52,680 --> 00:04:56,880
warm day where I'm at and it was about

00:04:54,300 --> 00:04:59,670
70 degrees out and I ran the test and it

00:04:56,880 --> 00:05:01,440
failed which was disappointing

00:04:59,670 --> 00:05:02,700
I guess I'd rather not tell you as

00:05:01,440 --> 00:05:04,650
potential investors but I just wanna

00:05:02,700 --> 00:05:06,720
come clean I didn't have a lot of time

00:05:04,650 --> 00:05:08,310
to look into it so I had to move on with

00:05:06,720 --> 00:05:11,310
my day and I got back to it around dusk

00:05:08,310 --> 00:05:12,600
and my desk passed so I was feeling

00:05:11,310 --> 00:05:14,190
really good about things and I was

00:05:12,600 --> 00:05:16,320
making some other changes to the system

00:05:14,190 --> 00:05:20,730
and then ended up running the test suite

00:05:16,320 --> 00:05:24,720
later on and it failed and I was

00:05:20,730 --> 00:05:26,490
disappointing but then I realized the

00:05:24,720 --> 00:05:29,060
reason this test is passing or failing

00:05:26,490 --> 00:05:32,040
has nothing to do with my system itself

00:05:29,060 --> 00:05:33,120
the problem is this test is literally

00:05:32,040 --> 00:05:35,760
dependent on what the weather was

00:05:33,120 --> 00:05:37,920
outside every time I run this test it's

00:05:35,760 --> 00:05:40,710
asking the weather API what the

00:05:37,920 --> 00:05:42,720
temperature is and so if whether it's

00:05:40,710 --> 00:05:45,750
sweater weather or not depends on what

00:05:42,720 --> 00:05:48,480
the temperature is outside so in this

00:05:45,750 --> 00:05:50,760
test I am directly interacting with my

00:05:48,480 --> 00:05:53,610
dependency and that has a lot of

00:05:50,760 --> 00:05:55,710
benefits when I'm when I'm executing

00:05:53,610 --> 00:05:57,060
this test I'm pretty confident when it

00:05:55,710 --> 00:05:59,460
works that it's going to continue to

00:05:57,060 --> 00:06:01,560
work because I'm using the real thing

00:05:59,460 --> 00:06:03,720
right it's when I roll this out into

00:06:01,560 --> 00:06:05,790
production I don't have a lot of

00:06:03,720 --> 00:06:07,830
concerns about if it's going to interact

00:06:05,790 --> 00:06:09,620
differently it's the same exact thing

00:06:07,830 --> 00:06:12,620
that's going to run

00:06:09,620 --> 00:06:15,180
however this test is also pretty slow

00:06:12,620 --> 00:06:18,840
right now I have to issue an actual API

00:06:15,180 --> 00:06:20,010
request and as we've seen sometimes it's

00:06:18,840 --> 00:06:22,800
going to pass and sometimes it's going

00:06:20,010 --> 00:06:25,440
to fail it's it's literally dependent on

00:06:22,800 --> 00:06:28,350
the weather even in situations that

00:06:25,440 --> 00:06:30,090
aren't as fickle as that you might have

00:06:28,350 --> 00:06:33,350
a situation where the server goes down

00:06:30,090 --> 00:06:35,370
and then your test suite doesn't pass

00:06:33,350 --> 00:06:37,440
this also means that you need to have

00:06:35,370 --> 00:06:40,740
access to independency which seems kind

00:06:37,440 --> 00:06:42,360
of silly but this means that I can't run

00:06:40,740 --> 00:06:43,110
this test suite if I don't have access

00:06:42,360 --> 00:06:46,130
to the Internet

00:06:43,110 --> 00:06:48,630
right or my dependency was between some

00:06:46,130 --> 00:06:49,920
VPN network connection that I wouldn't

00:06:48,630 --> 00:06:51,960
have available to me all the time I

00:06:49,920 --> 00:06:53,420
would have a problem my tests wouldn't

00:06:51,960 --> 00:06:56,150
pass

00:06:53,420 --> 00:06:58,670
I also have an issue if my dependency

00:06:56,150 --> 00:07:01,190
has some sort of rate limiting and if I

00:06:58,670 --> 00:07:02,900
can only issue X number of requests over

00:07:01,190 --> 00:07:04,970
Y period of time particularly from

00:07:02,900 --> 00:07:07,520
working in a team with a CI server and

00:07:04,970 --> 00:07:08,660
we're all sharing an account I don't

00:07:07,520 --> 00:07:11,660
want to be in a position where I tell

00:07:08,660 --> 00:07:16,580
people not to run their tests frequently

00:07:11,660 --> 00:07:18,620
for some reason but there is merit in

00:07:16,580 --> 00:07:20,450
using this approach it's particularly

00:07:18,620 --> 00:07:22,250
valuable when you've ever used the

00:07:20,450 --> 00:07:24,830
dependency before it's not worth putting

00:07:22,250 --> 00:07:26,360
the effort into imagine how your

00:07:24,830 --> 00:07:28,070
dependency might interact I just

00:07:26,360 --> 00:07:31,510
actually use the real thing and get a

00:07:28,070 --> 00:07:34,340
handle on it figure out how it works and

00:07:31,510 --> 00:07:37,970
also it's it's beneficial to use when

00:07:34,340 --> 00:07:40,430
it's just so darn easy to do it so in a

00:07:37,970 --> 00:07:42,500
lot of rails apps we probably have model

00:07:40,430 --> 00:07:45,190
tests that we consider to be unit tests

00:07:42,500 --> 00:07:47,240
that are interacting with the database

00:07:45,190 --> 00:07:51,440
that database is a third-party

00:07:47,240 --> 00:07:53,150
dependency and from academic perspective

00:07:51,440 --> 00:07:54,410
not a unit test because it is

00:07:53,150 --> 00:07:58,370
interacting with an external

00:07:54,410 --> 00:08:00,470
collaborator however the cost for that

00:07:58,370 --> 00:08:03,140
one particular test is so low and so

00:08:00,470 --> 00:08:06,020
easy that sometimes it's a worthwhile

00:08:03,140 --> 00:08:07,430
trade-off it still has all of the

00:08:06,020 --> 00:08:08,660
baggage that comes with that we talked

00:08:07,430 --> 00:08:10,100
about on the last slide of it's slower

00:08:08,660 --> 00:08:12,830
and you know it's dependent on the

00:08:10,100 --> 00:08:17,360
dependency but it might be a decision

00:08:12,830 --> 00:08:19,070
worth making for our purposes this

00:08:17,360 --> 00:08:20,750
pattern obviously isn't going to work

00:08:19,070 --> 00:08:22,700
right we want to make sure our tests

00:08:20,750 --> 00:08:23,410
pass consistently so let's try something

00:08:22,700 --> 00:08:27,400
else

00:08:23,410 --> 00:08:31,190
let's try stubbing out the response and

00:08:27,400 --> 00:08:33,410
so here we're going to prepare some JSON

00:08:31,190 --> 00:08:37,490
that says it's always 55 degrees outside

00:08:33,410 --> 00:08:39,830
and again this is an HTTP API so we're

00:08:37,490 --> 00:08:41,900
going to use a tool called web mock and

00:08:39,830 --> 00:08:45,200
what web mock is going to do is going to

00:08:41,900 --> 00:08:48,700
say anytime in my test that I issue a

00:08:45,200 --> 00:08:51,350
get request to this particular URL I

00:08:48,700 --> 00:08:53,000
don't want you to actually make the API

00:08:51,350 --> 00:08:55,160
request instead I want you to just

00:08:53,000 --> 00:08:59,150
return a 200 with the response that I

00:08:55,160 --> 00:09:01,730
just gave you above okay so now when we

00:08:59,150 --> 00:09:03,800
run the same test this is always going

00:09:01,730 --> 00:09:07,279
to pass assuming our implementation is

00:09:03,800 --> 00:09:09,860
correct because the API is Oh

00:09:07,279 --> 00:09:13,730
returning that's 55° because it's not

00:09:09,860 --> 00:09:17,180
actually issuing an API request so this

00:09:13,730 --> 00:09:20,269
is wonderful right now our test will

00:09:17,180 --> 00:09:22,870
pass every time unless there's something

00:09:20,269 --> 00:09:25,189
actually wrong with our code

00:09:22,870 --> 00:09:26,899
it also means we don't even need the

00:09:25,189 --> 00:09:29,769
dependency so I can run this test feat

00:09:26,899 --> 00:09:32,769
when I don't have access to the Internet

00:09:29,769 --> 00:09:35,360
it also brings us closer to that

00:09:32,769 --> 00:09:38,079
academic definition of a unit test so I

00:09:35,360 --> 00:09:41,540
don't actually need the dependency

00:09:38,079 --> 00:09:43,610
however I need as you have some

00:09:41,540 --> 00:09:45,199
knowledge or intuition to be able to set

00:09:43,610 --> 00:09:47,600
up this test correctly I need to know

00:09:45,199 --> 00:09:49,660
what the JSON response was that I care

00:09:47,600 --> 00:09:52,309
about that the API is going to return

00:09:49,660 --> 00:09:54,800
and moreover I need to keep that up to

00:09:52,309 --> 00:09:57,470
date with reality these response values

00:09:54,800 --> 00:09:58,879
are hard-coded and there's nothing

00:09:57,470 --> 00:10:00,829
saying that the dependency couldn't

00:09:58,879 --> 00:10:02,720
change over time and if my tests aren't

00:10:00,829 --> 00:10:05,089
updated then I have a situation where my

00:10:02,720 --> 00:10:08,149
tests pass but production is going to be

00:10:05,089 --> 00:10:10,699
on fire because my code wasn't set up to

00:10:08,149 --> 00:10:15,620
handle how the response changed and I

00:10:10,699 --> 00:10:17,329
didn't know about it thus last concern

00:10:15,620 --> 00:10:20,449
here is you know a bit of a stylistic

00:10:17,329 --> 00:10:21,709
concern depending on your response and

00:10:20,449 --> 00:10:25,329
how much of it you need you might have a

00:10:21,709 --> 00:10:27,949
lot of code in your test that's just

00:10:25,329 --> 00:10:30,259
preparing what's going to be responded

00:10:27,949 --> 00:10:32,480
from your stub and you know maybe that

00:10:30,259 --> 00:10:36,589
takes away some of the value or

00:10:32,480 --> 00:10:38,089
difficulty in reading your tests so I

00:10:36,589 --> 00:10:40,759
find stubbing to be a particularly

00:10:38,089 --> 00:10:42,529
effective approach when you're working

00:10:40,759 --> 00:10:46,209
with a dependency that is very stable

00:10:42,529 --> 00:10:50,480
right that way it's unlikely to change

00:10:46,209 --> 00:10:52,459
this minimizes the risk are concerned

00:10:50,480 --> 00:10:54,920
that your response that you've

00:10:52,459 --> 00:10:56,600
hard-coded gets out of date with reality

00:10:54,920 --> 00:11:00,259
it doesn't make it go away but it makes

00:10:56,600 --> 00:11:02,720
it less likely to occur and lastly if

00:11:00,259 --> 00:11:04,550
you care about the verbosity of your

00:11:02,720 --> 00:11:06,050
test setup you might only prefer

00:11:04,550 --> 00:11:07,819
stubbing in situations where you only

00:11:06,050 --> 00:11:09,829
care about a small part of the response

00:11:07,819 --> 00:11:14,839
or if the response itself is

00:11:09,829 --> 00:11:16,850
particularly small so maybe this

00:11:14,839 --> 00:11:18,889
stubbing is a bit too much indirection

00:11:16,850 --> 00:11:21,170
you'd like to see your code actually be

00:11:18,889 --> 00:11:23,870
exercised a little more than this is

00:11:21,170 --> 00:11:27,050
actually doing and that's totally fine

00:11:23,870 --> 00:11:31,570
we can take care of that let's build a

00:11:27,050 --> 00:11:33,529
fake and what a fake is is an actual

00:11:31,570 --> 00:11:36,529
version of the dependency it's going to

00:11:33,529 --> 00:11:37,579
stand in for the real one so in this

00:11:36,529 --> 00:11:41,600
case we're going to build our own

00:11:37,579 --> 00:11:43,070
weather API I know this is railsconf but

00:11:41,600 --> 00:11:44,870
just for ease of fitting everything on

00:11:43,070 --> 00:11:49,370
the slide I'm going to build us an

00:11:44,870 --> 00:11:52,130
operation okay our Sinatra app is going

00:11:49,370 --> 00:11:56,510
to have one route that route is the same

00:11:52,130 --> 00:11:58,459
as the real weather API and it's going

00:11:56,510 --> 00:12:02,000
to return JSON that looks the same as

00:11:58,459 --> 00:12:03,730
the real weather API and now if we go

00:12:02,000 --> 00:12:06,709
back to the test we've been working on

00:12:03,730 --> 00:12:11,810
I'm going to use a tool called capybara

00:12:06,709 --> 00:12:13,670
disco ball which is going to take the

00:12:11,810 --> 00:12:16,399
code that's running in anytime that is

00:12:13,670 --> 00:12:18,290
you an API request rather than sending

00:12:16,399 --> 00:12:20,540
that API request to the actual

00:12:18,290 --> 00:12:25,160
dependency it's going to instead use my

00:12:20,540 --> 00:12:28,130
fake weather application instead so now

00:12:25,160 --> 00:12:29,750
when I ask if it's sweater weather this

00:12:28,130 --> 00:12:32,540
is going to be true because my fake

00:12:29,750 --> 00:12:38,360
weather map app always says it's 56

00:12:32,540 --> 00:12:40,760
degrees anywhere in the world so this is

00:12:38,360 --> 00:12:44,420
neat because this is a full-stack test

00:12:40,760 --> 00:12:47,209
and that it's actually issuing an API

00:12:44,420 --> 00:12:48,890
request it just happens to be to a local

00:12:47,209 --> 00:12:51,680
server that we have set up just for the

00:12:48,890 --> 00:12:56,410
purposes of our test so we have

00:12:51,680 --> 00:12:56,410
everything we need on our local system

00:12:56,500 --> 00:13:02,589
we've also taken away any concern of

00:12:59,360 --> 00:13:08,870
having all of that noise and the setup

00:13:02,589 --> 00:13:10,790
moved it into a separate file and we can

00:13:08,870 --> 00:13:13,339
make this fake as simple or as complex

00:13:10,790 --> 00:13:15,649
as we needed to be for the purposes of

00:13:13,339 --> 00:13:17,360
our test just having it be 56 degrees

00:13:15,649 --> 00:13:19,579
everywhere all the time is perfectly

00:13:17,360 --> 00:13:21,050
fine but there's nothing stopping us

00:13:19,579 --> 00:13:23,930
from making our web app say that it's

00:13:21,050 --> 00:13:26,959
always 12 degrees in Alaska and 70

00:13:23,930 --> 00:13:28,699
degrees in Alabama and on every third

00:13:26,959 --> 00:13:30,769
Tuesday where the moon is full it's

00:13:28,699 --> 00:13:31,769
negative two degrees in any particular

00:13:30,769 --> 00:13:35,420
zip code

00:13:31,769 --> 00:13:38,009
it just depends on what needs we have

00:13:35,420 --> 00:13:39,779
however we still have the same problem

00:13:38,009 --> 00:13:42,509
that we have with stubbing where we need

00:13:39,779 --> 00:13:46,739
to make sure that the fake responds the

00:13:42,509 --> 00:13:48,689
same way as the real thing right the the

00:13:46,739 --> 00:13:51,179
route needs to look the same way and the

00:13:48,689 --> 00:13:53,660
response needs to be the same structure

00:13:51,179 --> 00:13:56,399
and give you the same information right

00:13:53,660 --> 00:13:58,379
and then we're also just adding more

00:13:56,399 --> 00:14:00,540
complexity right so I started this

00:13:58,379 --> 00:14:01,860
presentation with sort of a silly notion

00:14:00,540 --> 00:14:03,540
that we were going to launch weather

00:14:01,860 --> 00:14:05,819
satellites into orbit in order to be

00:14:03,540 --> 00:14:08,549
able to tell what the weather was and

00:14:05,819 --> 00:14:10,920
now what I'm proposing is that we build

00:14:08,549 --> 00:14:12,749
a whole application that tells you what

00:14:10,920 --> 00:14:14,879
the weather is somewhere just for the

00:14:12,749 --> 00:14:16,799
purposes of testing our interaction with

00:14:14,879 --> 00:14:18,689
another system that tells you what the

00:14:16,799 --> 00:14:22,619
weather is somewhere right

00:14:18,689 --> 00:14:24,629
and now when our test if a test fails we

00:14:22,619 --> 00:14:26,369
now have to figure out is it a problem

00:14:24,629 --> 00:14:28,499
with our test do we have an actual log

00:14:26,369 --> 00:14:30,480
in our implementation or did we do

00:14:28,499 --> 00:14:33,239
something wrong with our fate and then

00:14:30,480 --> 00:14:35,009
do we need tests for our fake and what

00:14:33,239 --> 00:14:37,110
how do we make sure we have confidence

00:14:35,009 --> 00:14:42,929
that our fake system is working the same

00:14:37,110 --> 00:14:47,639
as the real system does so I find fakes

00:14:42,929 --> 00:14:49,679
to be an effective method of the testing

00:14:47,639 --> 00:14:51,540
with third party dependencies if you're

00:14:49,679 --> 00:14:54,209
particularly interested in testing the

00:14:51,540 --> 00:14:57,019
communication mechanism so if I were

00:14:54,209 --> 00:14:59,100
building in HTTP client library I

00:14:57,019 --> 00:15:01,259
probably want some tests in there that

00:14:59,100 --> 00:15:02,850
actually make HTTP requests because

00:15:01,259 --> 00:15:05,970
that's incredibly important for what my

00:15:02,850 --> 00:15:07,889
library does but I probably don't want

00:15:05,970 --> 00:15:10,829
to be reliant on an external system so I

00:15:07,889 --> 00:15:14,879
can build my own web app that you use in

00:15:10,829 --> 00:15:16,649
tests and just use that um

00:15:14,879 --> 00:15:18,540
fakes can also be particularly valuable

00:15:16,649 --> 00:15:20,730
when you're looking to test something

00:15:18,540 --> 00:15:23,519
that has multiple steps between

00:15:20,730 --> 00:15:25,889
different systems so for example if

00:15:23,519 --> 00:15:28,829
you're testing an OAuth handshake you

00:15:25,889 --> 00:15:31,589
could build a fake web app that responds

00:15:28,829 --> 00:15:34,669
to whatever side of the OAuth handshake

00:15:31,589 --> 00:15:36,959
you're testing the other part of and

00:15:34,669 --> 00:15:39,299
that way you don't have to interact with

00:15:36,959 --> 00:15:42,329
the real system but you don't have to

00:15:39,299 --> 00:15:45,220
have like this big long stubbing of you

00:15:42,329 --> 00:15:46,899
know however many different API requests

00:15:45,220 --> 00:15:48,399
sponsons in there you just build your

00:15:46,899 --> 00:15:54,160
web app that responds to the same routes

00:15:48,399 --> 00:15:57,610
and does the things you need so this

00:15:54,160 --> 00:15:59,050
will work perfectly fine for us but it

00:15:57,610 --> 00:16:00,399
has a lot of machinery complexity right

00:15:59,050 --> 00:16:01,420
we had to build our own web app but

00:16:00,399 --> 00:16:03,850
maybe we don't want to have to worry

00:16:01,420 --> 00:16:05,319
about that well we have another option

00:16:03,850 --> 00:16:08,160
we can investigate

00:16:05,319 --> 00:16:12,959
maybe we can we can use fixtures and

00:16:08,160 --> 00:16:15,639
fixtures are certain just files that

00:16:12,959 --> 00:16:17,620
document particular requests and

00:16:15,639 --> 00:16:20,980
responses that occurred and then replay

00:16:17,620 --> 00:16:24,250
them on subsequent invocations of that

00:16:20,980 --> 00:16:26,860
request so let's look at this by way of

00:16:24,250 --> 00:16:28,449
example we have the same tests that

00:16:26,860 --> 00:16:32,589
we've been looking at this entire time

00:16:28,449 --> 00:16:36,000
and we're going to use a tool called VCR

00:16:32,589 --> 00:16:41,709
to generate and manage these fixtures

00:16:36,000 --> 00:16:46,649
VCR very much leans into the terminology

00:16:41,709 --> 00:16:49,720
of it being a system that replaces a VCR

00:16:46,649 --> 00:16:52,029
if you don't know what a VCR is for the

00:16:49,720 --> 00:16:53,680
purposes of this analogy it's a thing

00:16:52,029 --> 00:16:57,519
that we use to use to be able to watch

00:16:53,680 --> 00:17:00,009
movies on our TV at home before DVD

00:16:57,519 --> 00:17:02,110
players and if you don't know what a DVD

00:17:00,009 --> 00:17:04,000
player is it's a thing we used to use to

00:17:02,110 --> 00:17:08,169
watch movies at home before we had

00:17:04,000 --> 00:17:11,230
streaming so what VCR is going to do is

00:17:08,169 --> 00:17:14,020
it's going to look for an existence of a

00:17:11,230 --> 00:17:15,850
fixture which it calls a cassette and

00:17:14,020 --> 00:17:18,520
the first time this test is run we're

00:17:15,850 --> 00:17:21,699
not going to find one so we're going to

00:17:18,520 --> 00:17:23,980
issue an actual API request to the real

00:17:21,699 --> 00:17:28,419
weather API and get an actual response

00:17:23,980 --> 00:17:30,039
back VCR is going to keep track of all

00:17:28,419 --> 00:17:32,049
the information we send over and

00:17:30,039 --> 00:17:35,350
received and store that in a file and

00:17:32,049 --> 00:17:38,230
save that and now the second time we've

00:17:35,350 --> 00:17:40,750
on this test VCR is going to notice oh I

00:17:38,230 --> 00:17:43,360
already have this fixture so I'm going

00:17:40,750 --> 00:17:47,740
to use that to stand in for the actual

00:17:43,360 --> 00:17:49,630
API request so the second through and

00:17:47,740 --> 00:17:51,669
time that we run this test this isn't

00:17:49,630 --> 00:17:55,809
hitting the actual weather API it's

00:17:51,669 --> 00:17:57,700
using the fixture instead so this is

00:17:55,809 --> 00:17:59,090
cool because we have absolute truth at a

00:17:57,700 --> 00:18:01,700
particular moment in time

00:17:59,090 --> 00:18:03,379
right we've documented the exact request

00:18:01,700 --> 00:18:06,740
we've sent over and the full response

00:18:03,379 --> 00:18:08,389
we've received right we get the complete

00:18:06,740 --> 00:18:13,220
picture of everything that we sent over

00:18:08,389 --> 00:18:16,580
and everything we got back can also make

00:18:13,220 --> 00:18:18,169
our test a little difficult to read we

00:18:16,580 --> 00:18:21,019
don't really have any strong indication

00:18:18,169 --> 00:18:22,759
as to why it's sweater weather we just

00:18:21,019 --> 00:18:25,669
look at the test instead we'd have to

00:18:22,759 --> 00:18:27,320
open up the fixture and notice oh and

00:18:25,669 --> 00:18:29,960
the response it said its 58 degrees

00:18:27,320 --> 00:18:32,330
that's why it's sweater weather we also

00:18:29,960 --> 00:18:34,129
have the same problem in the fake where

00:18:32,330 --> 00:18:36,139
you need to look into how the fake is

00:18:34,129 --> 00:18:40,610
set up to know why it's responding this

00:18:36,139 --> 00:18:42,350
particular way it's also great that it's

00:18:40,610 --> 00:18:44,539
absolute truth at a particular moment in

00:18:42,350 --> 00:18:47,809
time but unfortunately at that moment in

00:18:44,539 --> 00:18:49,610
time is immediately the past so there's

00:18:47,809 --> 00:18:51,889
no guarantee that in the future or even

00:18:49,610 --> 00:18:54,950
in the present that your dependency

00:18:51,889 --> 00:18:56,720
still interacts that way so things can

00:18:54,950 --> 00:19:02,720
get out of sync and out of date becomes

00:18:56,720 --> 00:19:03,980
stale and to be able to generate this

00:19:02,720 --> 00:19:05,629
fixture and keep them up to date we've

00:19:03,980 --> 00:19:08,389
got to be able to access our dependency

00:19:05,629 --> 00:19:09,710
which you know may be a challenge

00:19:08,389 --> 00:19:15,440
depending on what we're looking to do

00:19:09,710 --> 00:19:18,679
right so pictures can be beneficial if

00:19:15,440 --> 00:19:20,059
we need the full response we need to

00:19:18,679 --> 00:19:22,039
keep track of everything the gains back

00:19:20,059 --> 00:19:24,289
comes back alright maybe we want to use

00:19:22,039 --> 00:19:26,539
it as documentation of how the API

00:19:24,289 --> 00:19:28,070
interacts or maybe we just care about

00:19:26,539 --> 00:19:30,830
more information than just the one thing

00:19:28,070 --> 00:19:32,119
that we care about right the weather

00:19:30,830 --> 00:19:34,549
I've got that we're using here returns

00:19:32,119 --> 00:19:36,220
hundreds of data points we just only

00:19:34,549 --> 00:19:38,840
care for this example about one of them

00:19:36,220 --> 00:19:41,590
but if we cared about all of them or a

00:19:38,840 --> 00:19:43,549
sub you know some substantial number

00:19:41,590 --> 00:19:49,100
this may be more beneficial than

00:19:43,549 --> 00:19:51,139
stuffing out a big long response again

00:19:49,100 --> 00:19:52,519
we need to have access to dependency to

00:19:51,139 --> 00:19:54,110
generate the fixture so it really only

00:19:52,519 --> 00:19:58,220
applies in situations where we can

00:19:54,110 --> 00:20:00,889
readily access it and fixtures are

00:19:58,220 --> 00:20:03,080
really most beneficial when regenerating

00:20:00,889 --> 00:20:06,049
them won't cause any adverse effect on

00:20:03,080 --> 00:20:07,669
the dependency now

00:20:06,049 --> 00:20:11,360
this isn't that obvious with a weather

00:20:07,669 --> 00:20:12,920
API so let's consider an example where

00:20:11,360 --> 00:20:15,020
we were testing

00:20:12,920 --> 00:20:17,840
the use of some third-party user

00:20:15,020 --> 00:20:20,330
registration service so we want to test

00:20:17,840 --> 00:20:23,480
making an API request to register a user

00:20:20,330 --> 00:20:24,350
and make sure it works and so the first

00:20:23,480 --> 00:20:26,960
time we do that

00:20:24,350 --> 00:20:29,840
everything works perfectly fine and we

00:20:26,960 --> 00:20:32,620
save that fixture and we use that going

00:20:29,840 --> 00:20:34,640
forward but then later on we want to

00:20:32,620 --> 00:20:36,320
change that fixture and just keep it up

00:20:34,640 --> 00:20:37,700
to date right because we've you know

00:20:36,320 --> 00:20:40,610
it's been a certain number of time out

00:20:37,700 --> 00:20:42,200
of time let's just run it again we've

00:20:40,610 --> 00:20:43,070
run it the second time and our test is

00:20:42,200 --> 00:20:46,190
going to fail

00:20:43,070 --> 00:20:47,929
probably because that user registration

00:20:46,190 --> 00:20:51,710
system probably has some uniqueness

00:20:47,929 --> 00:20:53,150
validation on email address so now

00:20:51,710 --> 00:20:56,150
whenever we want to regenerate the

00:20:53,150 --> 00:20:59,690
fixture we need to change our test to be

00:20:56,150 --> 00:21:01,610
some unused email address or if we have

00:20:59,690 --> 00:21:04,820
access to the user registration service

00:21:01,610 --> 00:21:06,620
we need to delete that user name or

00:21:04,820 --> 00:21:09,169
email address from the system before

00:21:06,620 --> 00:21:10,460
regenerating the fixture and now that

00:21:09,169 --> 00:21:12,429
this means is that it's much more

00:21:10,460 --> 00:21:16,100
unlikely that we're actually going to

00:21:12,429 --> 00:21:17,750
continually refresh these fixtures and

00:21:16,100 --> 00:21:19,760
the ability to do that and make that as

00:21:17,750 --> 00:21:22,010
seamless and easy as possible is very

00:21:19,760 --> 00:21:23,540
important because we want to minimize

00:21:22,010 --> 00:21:25,610
the risk that these things become out of

00:21:23,540 --> 00:21:29,380
date and make sure that our system still

00:21:25,610 --> 00:21:29,380
reacts the same way that we expected to

00:21:29,590 --> 00:21:34,910
so let's take a second and think about

00:21:32,630 --> 00:21:37,400
what we've done here we've investigated

00:21:34,910 --> 00:21:40,580
four different ways to test a

00:21:37,400 --> 00:21:42,200
third-party dependency but let's look

00:21:40,580 --> 00:21:46,120
back at our implementation take a closer

00:21:42,200 --> 00:21:46,120
look as to why we had to do that

00:21:47,260 --> 00:21:53,210
everything this method isn't super

00:21:50,750 --> 00:21:56,929
complex but there's still a lot going on

00:21:53,210 --> 00:21:58,490
here I mean it's not it's not very large

00:21:56,929 --> 00:22:02,330
it all fits on the slide so that's

00:21:58,490 --> 00:22:04,040
that's good but really the the business

00:22:02,330 --> 00:22:07,640
logic we're testing is just a number

00:22:04,040 --> 00:22:10,549
comparison between two other numbers but

00:22:07,640 --> 00:22:12,380
in order to test that part of it we need

00:22:10,549 --> 00:22:14,900
to take the whole kit and kaboodle with

00:22:12,380 --> 00:22:16,520
it this test is doing a number of

00:22:14,900 --> 00:22:18,890
different things right it has this whole

00:22:16,520 --> 00:22:21,770
block here that's interacting with our

00:22:18,890 --> 00:22:24,050
dependency then we have this section

00:22:21,770 --> 00:22:26,270
that's taking out the relevant

00:22:24,050 --> 00:22:27,010
information that we care about and then

00:22:26,270 --> 00:22:29,800
lastly

00:22:27,010 --> 00:22:31,180
we have our piece of code which is just

00:22:29,800 --> 00:22:33,550
saying is this number between those

00:22:31,180 --> 00:22:35,650
other numbers but we can't test this

00:22:33,550 --> 00:22:38,770
last part without the other parts the

00:22:35,650 --> 00:22:40,030
way this is set up so let's let's

00:22:38,770 --> 00:22:42,280
decompose this a little bit in two

00:22:40,030 --> 00:22:45,700
different classes and let's start at the

00:22:42,280 --> 00:22:47,170
top we'll build an API client the API

00:22:45,700 --> 00:22:50,080
client is going to be solely responsible

00:22:47,170 --> 00:22:52,930
for issuing a request and getting a

00:22:50,080 --> 00:22:54,460
response back and then making it someone

00:22:52,930 --> 00:22:58,390
else's concern to do anything meaningful

00:22:54,460 --> 00:22:59,680
with that so it's going to build up your

00:22:58,390 --> 00:23:02,340
eye punch like the initial

00:22:59,680 --> 00:23:04,540
implementation issue again request and

00:23:02,340 --> 00:23:08,950
we'll parse the JSON to give it a hash

00:23:04,540 --> 00:23:13,030
back just for convenience so now we need

00:23:08,950 --> 00:23:14,440
to test this but we're pretty familiar

00:23:13,030 --> 00:23:16,870
with a number of different ways to test

00:23:14,440 --> 00:23:18,070
this so let's just choose a fixture

00:23:16,870 --> 00:23:21,640
because it happened to be the last when

00:23:18,070 --> 00:23:25,090
we talked about and so similarly as

00:23:21,640 --> 00:23:28,180
before we're going to exercise the API

00:23:25,090 --> 00:23:30,790
request get a response back what I'm

00:23:28,180 --> 00:23:33,250
going to assert here is not that we got

00:23:30,790 --> 00:23:37,510
any particular value back but that the

00:23:33,250 --> 00:23:39,730
structure looks a certain way now the

00:23:37,510 --> 00:23:42,430
API class itself doesn't really care

00:23:39,730 --> 00:23:44,980
about the structure here at all all

00:23:42,430 --> 00:23:46,900
cares about making sure is that it made

00:23:44,980 --> 00:23:48,360
a request and got a response at that

00:23:46,900 --> 00:23:50,740
point it did its job

00:23:48,360 --> 00:23:52,000
however this layer the application is

00:23:50,740 --> 00:23:54,580
going to be the part that's actually

00:23:52,000 --> 00:23:56,770
interacting with the dependency so we

00:23:54,580 --> 00:23:59,350
want to have its test serve as an early

00:23:56,770 --> 00:24:01,810
warning system that anything changed in

00:23:59,350 --> 00:24:03,790
the actual dependency right and it's

00:24:01,810 --> 00:24:06,820
very important to us for our application

00:24:03,790 --> 00:24:11,140
that this response returns some JSON

00:24:06,820 --> 00:24:14,170
that has that is composed like this it

00:24:11,140 --> 00:24:16,120
has this information in here but it's

00:24:14,170 --> 00:24:17,650
not very important that it's any

00:24:16,120 --> 00:24:19,900
particular temperature at a given time

00:24:17,650 --> 00:24:22,090
right whether it's 56 degrees or 72

00:24:19,900 --> 00:24:25,600
degrees so I don't want this test to

00:24:22,090 --> 00:24:27,010
fail for that reason particularly

00:24:25,600 --> 00:24:29,010
because I want to make this as easy as

00:24:27,010 --> 00:24:31,420
possible to regenerate these cassettes

00:24:29,010 --> 00:24:34,060
all right so I should be able to

00:24:31,420 --> 00:24:35,530
regenerate this cassette every time or

00:24:34,060 --> 00:24:36,970
not even have the cassette at all and

00:24:35,530 --> 00:24:40,000
directly interact with the dependency

00:24:36,970 --> 00:24:42,580
and this test should continue to pass a

00:24:40,000 --> 00:24:45,310
the structure change in some way that

00:24:42,580 --> 00:24:49,290
that way this test feeling gives me

00:24:45,310 --> 00:24:52,390
valuable feedback okay

00:24:49,290 --> 00:24:56,410
the second thing we need to do is to be

00:24:52,390 --> 00:24:58,300
able to take that response and translate

00:24:56,410 --> 00:25:02,080
it into meaningful values that we care

00:24:58,300 --> 00:25:04,690
about so let's build a ruby object here

00:25:02,080 --> 00:25:06,700
called current conditions that takes in

00:25:04,690 --> 00:25:10,600
a hash that's the response that we got

00:25:06,700 --> 00:25:12,160
back from the API and it responds to

00:25:10,600 --> 00:25:14,050
methods with the information we care

00:25:12,160 --> 00:25:16,990
about in this example well the

00:25:14,050 --> 00:25:19,300
temperature feels like outside and just

00:25:16,990 --> 00:25:20,830
like before well dig into the hash and

00:25:19,300 --> 00:25:24,790
get the piece of information that we

00:25:20,830 --> 00:25:26,740
need but we're also going to convert it

00:25:24,790 --> 00:25:29,290
to a float because it turns up the API

00:25:26,740 --> 00:25:33,490
gives me back a string and I don't

00:25:29,290 --> 00:25:35,200
really want a string I want a number and

00:25:33,490 --> 00:25:37,750
now to test this I can test this in

00:25:35,200 --> 00:25:40,390
complete isolation is just a regular you

00:25:37,750 --> 00:25:43,780
know input-output Ruby test right so

00:25:40,390 --> 00:25:46,840
given this particular JSON I expect this

00:25:43,780 --> 00:25:49,660
particular result and this is where it

00:25:46,840 --> 00:25:51,790
made it really easy to know that this

00:25:49,660 --> 00:25:52,930
isn't giving the API isn't giving me

00:25:51,790 --> 00:25:54,670
back a number it's gonna be back a

00:25:52,930 --> 00:25:59,500
string because originally this test

00:25:54,670 --> 00:26:03,070
failed because the string 55.5 is not

00:25:59,500 --> 00:26:04,540
the number of 55.5 and so that tipped me

00:26:03,070 --> 00:26:06,010
off that I had to actually change

00:26:04,540 --> 00:26:08,170
something to be you know meaningful

00:26:06,010 --> 00:26:11,860
representation that we care off for our

00:26:08,170 --> 00:26:14,050
application and then because this is

00:26:11,860 --> 00:26:16,180
just given particular input expect a

00:26:14,050 --> 00:26:17,890
certain output it's very lightweight and

00:26:16,180 --> 00:26:20,830
easy to be able to build all sorts of

00:26:17,890 --> 00:26:23,620
edge cases without having to have all of

00:26:20,830 --> 00:26:24,940
the machinery and rigmarole of setting

00:26:23,620 --> 00:26:27,280
up some way to interact with the

00:26:24,940 --> 00:26:30,420
third-party dependency and have it give

00:26:27,280 --> 00:26:34,200
you these results back I need to do is

00:26:30,420 --> 00:26:36,820
given this particular set of a JSON hash

00:26:34,200 --> 00:26:41,590
here's how our data representation is

00:26:36,820 --> 00:26:44,170
going to react under these conditions we

00:26:41,590 --> 00:26:46,120
need to tie these things together so I

00:26:44,170 --> 00:26:48,280
like to build a domain class on this

00:26:46,120 --> 00:26:50,860
case the domain module we'll call it a

00:26:48,280 --> 00:26:53,440
weather module and the weather module is

00:26:50,860 --> 00:26:54,700
going to interact with the API

00:26:53,440 --> 00:26:59,680
give us back the information that we

00:26:54,700 --> 00:27:01,540
need so it has our API client it has the

00:26:59,680 --> 00:27:04,350
ability to tell us what the current

00:27:01,540 --> 00:27:07,870
conditions are for a given zip code and

00:27:04,350 --> 00:27:10,420
this method here is going to make an API

00:27:07,870 --> 00:27:12,130
request with our client give those

00:27:10,420 --> 00:27:15,430
results to our current conditions class

00:27:12,130 --> 00:27:17,770
and then any consumers of this or colors

00:27:15,430 --> 00:27:22,720
of this can do whatever it is they need

00:27:17,770 --> 00:27:24,940
to do with the current conditions so

00:27:22,720 --> 00:27:28,660
let's see how we would use this domain

00:27:24,940 --> 00:27:29,950
module in our sweater implementation so

00:27:28,660 --> 00:27:32,770
we're back to our sweater weather method

00:27:29,950 --> 00:27:34,690
and now we're going to use that weather

00:27:32,770 --> 00:27:36,930
module to ask it what the current

00:27:34,690 --> 00:27:39,130
conditions are at this zip code and

00:27:36,930 --> 00:27:40,900
we're going to pull out what the

00:27:39,130 --> 00:27:45,850
temperature feels like and figure out if

00:27:40,900 --> 00:27:48,520
it's between 55 and 65 degrees and

00:27:45,850 --> 00:27:50,860
that's it now this method is solely

00:27:48,520 --> 00:27:52,390
responsible for getting some information

00:27:50,860 --> 00:27:53,560
and performing our business logic it

00:27:52,390 --> 00:27:55,450
doesn't care about how it gets the

00:27:53,560 --> 00:28:00,790
information that's a responsibility of

00:27:55,450 --> 00:28:03,460
the weather module one change I'd like

00:28:00,790 --> 00:28:05,830
to propose to the weather module is not

00:28:03,460 --> 00:28:07,810
only the ability to tell us what the

00:28:05,830 --> 00:28:12,090
client is but also the ability to set

00:28:07,810 --> 00:28:14,080
the client so given any particular class

00:28:12,090 --> 00:28:17,590
be able to have the client be whatever

00:28:14,080 --> 00:28:21,700
whatever we sell it tell it to be and

00:28:17,590 --> 00:28:24,460
that will allow us to build and use a

00:28:21,700 --> 00:28:25,840
fake client that we can then dependency

00:28:24,460 --> 00:28:29,920
inject into the module and you that

00:28:25,840 --> 00:28:31,990
instead of the real thing so much like

00:28:29,920 --> 00:28:35,200
our fake web server that we built our

00:28:31,990 --> 00:28:37,680
fake client needs to respond to the same

00:28:35,200 --> 00:28:40,390
messages that the real one does and

00:28:37,680 --> 00:28:44,500
respond in the same way that the real

00:28:40,390 --> 00:28:47,470
one does but our fake client can also

00:28:44,500 --> 00:28:50,110
respond to additional messages so let's

00:28:47,470 --> 00:28:53,200
build an additional method here that

00:28:50,110 --> 00:28:56,140
lets us provide some preconditions to

00:28:53,200 --> 00:28:59,050
say for any given zip code here is the

00:28:56,140 --> 00:29:03,040
temperature so now in my test I can

00:28:59,050 --> 00:29:05,260
control the weather anywhere that only

00:29:03,040 --> 00:29:06,910
exists for my particular test

00:29:05,260 --> 00:29:11,830
I can I can set up the state of the

00:29:06,910 --> 00:29:16,780
world before running my tests okay so

00:29:11,830 --> 00:29:19,059
now I can use this or easily by building

00:29:16,780 --> 00:29:21,640
out something called a test mode which

00:29:19,059 --> 00:29:24,760
is just another module that has two

00:29:21,640 --> 00:29:26,770
methods you can enable test mode which

00:29:24,760 --> 00:29:31,510
sets the client to be this fake client

00:29:26,770 --> 00:29:32,730
and you can disable test mode by setting

00:29:31,510 --> 00:29:35,290
the client to be the real one

00:29:32,730 --> 00:29:37,630
you don't explicitly need this testing

00:29:35,290 --> 00:29:39,549
module you can just do this in your test

00:29:37,630 --> 00:29:41,410
code but I find having this module just

00:29:39,549 --> 00:29:43,450
makes a little easier you don't have to

00:29:41,410 --> 00:29:46,000
worry about how it does it just that it

00:29:43,450 --> 00:29:49,059
does it so now let's look at how our

00:29:46,000 --> 00:29:52,120
tests would change using test mode we're

00:29:49,059 --> 00:29:55,299
going to test the exact same thing first

00:29:52,120 --> 00:29:57,160
we need to turn on test mode and then

00:29:55,299 --> 00:29:59,320
we're going to use that add condition

00:29:57,160 --> 00:30:01,270
method to set up the state of the world

00:29:59,320 --> 00:30:03,640
we're going to say for the purposes of

00:30:01,270 --> 00:30:07,240
this test it is currently 56 degrees at

00:30:03,640 --> 00:30:08,320
this zip code all right then our test is

00:30:07,240 --> 00:30:10,240
going to look just like it did before

00:30:08,320 --> 00:30:13,600
we're going to new up the unit under

00:30:10,240 --> 00:30:16,270
test ask if it's sweater weather assert

00:30:13,600 --> 00:30:17,590
that it's true we have one more step we

00:30:16,270 --> 00:30:19,840
need to do in this test get some

00:30:17,590 --> 00:30:22,630
teardown we want to turn off test mode

00:30:19,840 --> 00:30:24,669
right we may have some other tests that

00:30:22,630 --> 00:30:27,400
are expecting to make an actual API

00:30:24,669 --> 00:30:30,070
request or if we don't we just want to

00:30:27,400 --> 00:30:33,220
be a good citizen and not globally

00:30:30,070 --> 00:30:39,309
change the state of the world throughout

00:30:33,220 --> 00:30:41,770
our entire test suite so Tesla Motors

00:30:39,309 --> 00:30:44,140
beneficial because it's should be at

00:30:41,770 --> 00:30:47,049
least faster than using the real thing

00:30:44,140 --> 00:30:49,240
this is performing all of its work in

00:30:47,049 --> 00:30:55,150
memory as opposed to having to make any

00:30:49,240 --> 00:30:57,580
sort of API request at all ever we also

00:30:55,150 --> 00:31:01,000
have a lot of control of the state of

00:30:57,580 --> 00:31:04,030
our system right similar to the fake web

00:31:01,000 --> 00:31:07,540
app right we can say that it's any

00:31:04,030 --> 00:31:11,410
temperature and a point on we have a bit

00:31:07,540 --> 00:31:13,270
more benefit in test mode where we can

00:31:11,410 --> 00:31:15,010
make that obvious in the test itself

00:31:13,270 --> 00:31:17,150
all right the test itself set you just

00:31:15,010 --> 00:31:19,580
currently 56 degrees at this

00:31:17,150 --> 00:31:22,610
as opposed to need to have to look into

00:31:19,580 --> 00:31:27,350
the fake class to say why is this

00:31:22,610 --> 00:31:29,150
reporting that it's 56 degrees we can

00:31:27,350 --> 00:31:32,720
also bolster the functionality of the

00:31:29,150 --> 00:31:34,730
test modes you insert some functionality

00:31:32,720 --> 00:31:37,880
to keep track of interactions with the

00:31:34,730 --> 00:31:40,850
client so we can know if any particular

00:31:37,880 --> 00:31:42,850
block of code made seven API requests or

00:31:40,850 --> 00:31:48,440
a zero API requests and then we can

00:31:42,850 --> 00:31:51,260
build assertions based off of that this

00:31:48,440 --> 00:31:53,090
also means that we're not interacting

00:31:51,260 --> 00:31:55,190
with the dependency at all which may be

00:31:53,090 --> 00:31:58,160
perfectly fine but you know has the same

00:31:55,190 --> 00:32:02,210
issues that we've had with stuffing and

00:31:58,160 --> 00:32:03,860
building a fake which is that we need to

00:32:02,210 --> 00:32:08,059
make sure it stays up to date with the

00:32:03,860 --> 00:32:12,920
real thing here it's really the API of

00:32:08,059 --> 00:32:15,500
the API class but ultimately that still

00:32:12,920 --> 00:32:17,210
means the third-party dependency because

00:32:15,500 --> 00:32:19,100
the response that comes back from the

00:32:17,210 --> 00:32:20,570
API class is going to change based on

00:32:19,100 --> 00:32:24,850
what comes back from the third-party

00:32:20,570 --> 00:32:28,010
dependency so I find test mode can be

00:32:24,850 --> 00:32:29,150
very valuable when you have coverage of

00:32:28,010 --> 00:32:32,000
your interaction with the dependency

00:32:29,150 --> 00:32:33,890
somewhere else and the way we set up our

00:32:32,000 --> 00:32:35,660
code right now we do we have that

00:32:33,890 --> 00:32:37,700
separate client class that is

00:32:35,660 --> 00:32:40,100
responsible for testing its interaction

00:32:37,700 --> 00:32:42,160
with the dependency and then any layers

00:32:40,100 --> 00:32:46,220
above that don't have to worry about

00:32:42,160 --> 00:32:47,809
talking to the actual dependency the

00:32:46,220 --> 00:32:49,910
test mode can also be beneficial when

00:32:47,809 --> 00:32:52,220
you need to keep track on some of that

00:32:49,910 --> 00:32:54,710
metadata information all right so if I

00:32:52,220 --> 00:32:57,080
need to keep track of you know the

00:32:54,710 --> 00:33:00,260
number of the API requests we made in a

00:32:57,080 --> 00:33:03,020
particular block of code we can do that

00:33:00,260 --> 00:33:04,340
or make sure that you know this didn't

00:33:03,020 --> 00:33:05,990
ask what the temperature is in Alaska

00:33:04,340 --> 00:33:11,900
but it did ask what the temperature is

00:33:05,990 --> 00:33:14,480
in Massachusetts so the purpose of this

00:33:11,900 --> 00:33:15,980
talk was to discuss how to test

00:33:14,480 --> 00:33:19,460
third-party dependencies in our

00:33:15,980 --> 00:33:23,840
applications and ultimately my

00:33:19,460 --> 00:33:26,690
conclusion is don't and what I really

00:33:23,840 --> 00:33:30,140
mean by that is to avoid it most of the

00:33:26,690 --> 00:33:30,650
time instead build enough layers of

00:33:30,140 --> 00:33:33,170
separate

00:33:30,650 --> 00:33:35,630
between your dependency and your

00:33:33,170 --> 00:33:37,970
business logic so that you don't have to

00:33:35,630 --> 00:33:41,090
worry about it in every test in your

00:33:37,970 --> 00:33:43,460
system right so here we built a client

00:33:41,090 --> 00:33:47,150
class that we then handed off the

00:33:43,460 --> 00:33:49,550
results to a data representation that we

00:33:47,150 --> 00:33:52,940
use both of them in a domain module and

00:33:49,550 --> 00:33:56,120
that's what our business logic used to

00:33:52,940 --> 00:33:57,820
do some meaningful work on it so now

00:33:56,120 --> 00:34:00,140
when we're testing each of these things

00:33:57,820 --> 00:34:01,940
we still need to test that the client

00:34:00,140 --> 00:34:04,220
interacts with the third part dependency

00:34:01,940 --> 00:34:05,330
correctly we can use any of the methods

00:34:04,220 --> 00:34:08,480
we've talked about in this presentation

00:34:05,330 --> 00:34:10,280
to do that and any of the other layers

00:34:08,480 --> 00:34:12,320
like in the data representation or the

00:34:10,280 --> 00:34:14,570
domain we can test those in complete

00:34:12,320 --> 00:34:17,750
isolation we don't need to worry about

00:34:14,570 --> 00:34:19,190
how the third-party dependency reacts at

00:34:17,750 --> 00:34:21,679
most we need to worry about how our

00:34:19,190 --> 00:34:24,260
client class interacts you need to have

00:34:21,679 --> 00:34:27,050
the confidence that our client class

00:34:24,260 --> 00:34:31,429
tests sufficiently cover how the API

00:34:27,050 --> 00:34:34,310
responds then our business logic we can

00:34:31,429 --> 00:34:37,460
use test mode to not have to worry about

00:34:34,310 --> 00:34:40,909
how any of this works because all we

00:34:37,460 --> 00:34:43,070
care about for our example is what the

00:34:40,909 --> 00:34:46,220
temperature is at some position in the

00:34:43,070 --> 00:34:51,010
world right and then in our application

00:34:46,220 --> 00:34:53,780
the concern is how do we react to that

00:34:51,010 --> 00:34:54,770
so when you're testing third party

00:34:53,780 --> 00:34:56,750
dependencies when you're building

00:34:54,770 --> 00:34:58,070
systems and architecture that work with

00:34:56,750 --> 00:35:00,290
third party dependencies

00:34:58,070 --> 00:35:02,090
I recommend that you build enough layers

00:35:00,290 --> 00:35:05,600
of abstraction to limit your interaction

00:35:02,090 --> 00:35:08,570
with them which still allow you to test

00:35:05,600 --> 00:35:10,760
confidently right still have those lower

00:35:08,570 --> 00:35:12,680
layers working with the actual

00:35:10,760 --> 00:35:16,370
dependency and have those tested

00:35:12,680 --> 00:35:18,110
independently we don't have build up all

00:35:16,370 --> 00:35:20,600
of that interaction at your higher

00:35:18,110 --> 00:35:22,430
levels of abstraction because you have

00:35:20,600 --> 00:35:26,360
the competence of those lower layers I'm

00:35:22,430 --> 00:35:27,770
going to take care of that for you if

00:35:26,360 --> 00:35:29,900
you're interested in a copy of these

00:35:27,770 --> 00:35:31,460
slides or if you'd like to see the rails

00:35:29,900 --> 00:35:34,310
application that was used to generate

00:35:31,460 --> 00:35:37,370
all the examples in this slide deck you

00:35:34,310 --> 00:35:40,760
can visit my github page my user name is

00:35:37,370 --> 00:35:44,560
Kevin - J - M and the repository is

00:35:40,760 --> 00:35:48,420
testing services I'm also on

00:35:44,560 --> 00:35:50,350
at Kevin underscore J underscore M

00:35:48,420 --> 00:35:51,340
please give me any sort of feedback

00:35:50,350 --> 00:35:53,590
questions you might have

00:35:51,340 --> 00:35:56,290
I'd love to hear from you and otherwise

00:35:53,590 --> 00:35:59,100
thank you very much for your time and I

00:35:56,290 --> 00:35:59,100

YouTube URL: https://www.youtube.com/watch?v=iEfpAp2sqiw


