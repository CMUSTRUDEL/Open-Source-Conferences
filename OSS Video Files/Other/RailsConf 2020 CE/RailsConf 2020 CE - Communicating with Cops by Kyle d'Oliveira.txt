Title: RailsConf 2020 CE - Communicating with Cops by Kyle d'Oliveira
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Communicating with Cops by Kyle d'Oliveira

"As the number of developers grows within an organization, how do you keep others informed of best practices, or patterns that caused problems in the past? Is there a lot of tribal knowledge or documentation that developers need to memorize? That is a recipe for cognitive overload.

Alternatively, we can use Rubocop to codify some best practices or common traps to avoid. This talk will dive into how Rubocop can be used to not only enforce styling but also keep problematic patterns out, while also providing the motivation and context for enforcing it."

__________

Based in Vancouver, Canada, Kyle is a jack of all trades and a master of some; at least he thinks so. He works as a staff software developer to readily turn abstract ideas into working pieces of software. He has worked on every major Rails version, and remembers the days when everyone implemented their own authentication system. When not developing, he enjoys picking up really heavy objects so that they can be put back down again.
Captions: 
	00:00:08,580 --> 00:00:15,080
welcome to my talk communicating with

00:00:10,860 --> 00:00:15,080
cops in this entirely virtual cow

00:00:15,129 --> 00:00:19,790
in this talk we will explore using

00:00:17,780 --> 00:00:21,740
Robocop to communicate best practices

00:00:19,790 --> 00:00:25,580
and provide education to developers in

00:00:21,740 --> 00:00:28,130
an automated fashion my name is Kyle

00:00:25,580 --> 00:00:29,630
oliveira and this is my pop garage

00:00:28,130 --> 00:00:32,449
I'm from beautiful British Columbia

00:00:29,630 --> 00:00:34,970
Canada I've been working on rails since

00:00:32,449 --> 00:00:37,010
the pre 1.0 days and I've been hooked on

00:00:34,970 --> 00:00:38,239
Rubin rails because of how great it is

00:00:37,010 --> 00:00:40,550
to work with the language and framework

00:00:38,239 --> 00:00:44,480
but also because of how amazing the

00:00:40,550 --> 00:00:47,989
community is I'm currently a staff

00:00:44,480 --> 00:00:50,030
software developer at Cleo Cleo is a 13

00:00:47,989 --> 00:00:52,070
year old SAS company focused on making

00:00:50,030 --> 00:00:55,070
legal software to help transform the

00:00:52,070 --> 00:00:57,110
practice of law for good I work on their

00:00:55,070 --> 00:00:59,299
back-end infrastructure team and my team

00:00:57,110 --> 00:01:02,330
has three major areas of focus

00:00:59,299 --> 00:01:05,000
the first is scalability so this is in

00:01:02,330 --> 00:01:07,190
terms of data set size code base size

00:01:05,000 --> 00:01:09,590
but also the number of developers within

00:01:07,190 --> 00:01:11,690
the company as well the second is

00:01:09,590 --> 00:01:13,520
approachability for instance how long

00:01:11,690 --> 00:01:15,380
does it take for developer to get ramped

00:01:13,520 --> 00:01:18,619
up in a specific area of the code and

00:01:15,380 --> 00:01:20,510
the last is the overall developer

00:01:18,619 --> 00:01:22,820
experience working within all of our

00:01:20,510 --> 00:01:25,300
repositories this talk will touch a

00:01:22,820 --> 00:01:27,920
little bit of all three of these areas

00:01:25,300 --> 00:01:30,560
back in the early days of cleo

00:01:27,920 --> 00:01:32,540
when developer was first on boarded we

00:01:30,560 --> 00:01:35,870
used to have a project we made them do

00:01:32,540 --> 00:01:37,430
call the pet project cleo is a platform

00:01:35,870 --> 00:01:39,850
that lawyers can use to manage their

00:01:37,430 --> 00:01:43,100
cases and contacts as well as very

00:01:39,850 --> 00:01:45,230
various other things we had a fake

00:01:43,100 --> 00:01:47,180
feature we wanted new developers to

00:01:45,230 --> 00:01:50,120
implement where they could allow lawyers

00:01:47,180 --> 00:01:51,920
to manage various pets as well the goal

00:01:50,120 --> 00:01:53,570
of this project was to get developers

00:01:51,920 --> 00:01:56,030
used to working with our code base and

00:01:53,570 --> 00:01:58,850
align them on issues such as consistent

00:01:56,030 --> 00:02:00,200
styling or behavior traps for instance

00:01:58,850 --> 00:02:01,970
we would often notice that new

00:02:00,200 --> 00:02:03,950
developers would sometimes skip things

00:02:01,970 --> 00:02:06,020
like pagination and we'd be able to

00:02:03,950 --> 00:02:08,629
educate and they'd be able to learn by

00:02:06,020 --> 00:02:09,950
doing in this project this project

00:02:08,629 --> 00:02:11,599
really did the trick of getting

00:02:09,950 --> 00:02:14,239
developers used to our code base and

00:02:11,599 --> 00:02:16,040
getting them up and running we would

00:02:14,239 --> 00:02:17,750
have some comments that happen on the

00:02:16,040 --> 00:02:20,000
pull request such as what's shown here

00:02:17,750 --> 00:02:22,040
in this case someone was commenting that

00:02:20,000 --> 00:02:23,630
it's easier to read code if there's a

00:02:22,040 --> 00:02:25,910
new line separating these various

00:02:23,630 --> 00:02:28,700
contacts blocks this comment and

00:02:25,910 --> 00:02:30,440
isolation is fine small and concise

00:02:28,700 --> 00:02:33,290
there's room for discussion as well as

00:02:30,440 --> 00:02:34,760
potential disagreements in other cases

00:02:33,290 --> 00:02:37,220
developers might catch something that

00:02:34,760 --> 00:02:38,810
should be removed in this case someone

00:02:37,220 --> 00:02:41,000
found a method that didn't have any code

00:02:38,810 --> 00:02:42,080
in it so that should be deleted again

00:02:41,000 --> 00:02:43,910
this is a good thing

00:02:42,080 --> 00:02:46,010
we shouldn't be committing code that

00:02:43,910 --> 00:02:48,489
isn't being used this makes it harder to

00:02:46,010 --> 00:02:50,750
work with these classes in the future

00:02:48,489 --> 00:02:52,280
but the important thing is that neither

00:02:50,750 --> 00:02:55,310
of these two comments really touched on

00:02:52,280 --> 00:02:56,930
the actual behavior of the code the

00:02:55,310 --> 00:02:58,819
reviewer needed to make the comment and

00:02:56,930 --> 00:03:00,470
provide enough context to the developer

00:02:58,819 --> 00:03:02,500
writing the plural quest to understand

00:03:00,470 --> 00:03:06,830
and agree which is a lot of work and

00:03:02,500 --> 00:03:09,680
overall kind of unnecessary but at the

00:03:06,830 --> 00:03:11,450
end of it we noticed that these pet

00:03:09,680 --> 00:03:14,060
projects would become a dumping ground

00:03:11,450 --> 00:03:16,370
of all kinds of comments like this the

00:03:14,060 --> 00:03:18,860
goal here was good we are trying to use

00:03:16,370 --> 00:03:20,900
this as a mechanism for teaching but it

00:03:18,860 --> 00:03:23,840
wouldn't be uncommon to see hundreds of

00:03:20,900 --> 00:03:26,090
comments on a pull request well you may

00:03:23,840 --> 00:03:27,590
not have had a similar feature like this

00:03:26,090 --> 00:03:29,480
I'm sure many of you have had a

00:03:27,590 --> 00:03:31,130
situation were pull requests from new

00:03:29,480 --> 00:03:33,230
developers to the company or even new

00:03:31,130 --> 00:03:37,209
developers to your team are littered

00:03:33,230 --> 00:03:37,209
with comments to align them on styling

00:03:37,510 --> 00:03:41,840
imagine being this developer who's

00:03:39,560 --> 00:03:44,720
writing the pull request this is

00:03:41,840 --> 00:03:47,180
information overload there are literally

00:03:44,720 --> 00:03:49,720
hundreds of pieces of information coming

00:03:47,180 --> 00:03:52,160
in that you need to process and retain

00:03:49,720 --> 00:03:53,870
these are all things that are useful to

00:03:52,160 --> 00:03:55,970
teach and convey but when it comes into

00:03:53,870 --> 00:03:59,690
this big dump it is just cognitive

00:03:55,970 --> 00:04:01,910
overload imagine if instead we took that

00:03:59,690 --> 00:04:04,100
information and provided it to the

00:04:01,910 --> 00:04:05,750
developer as they were writing it or

00:04:04,100 --> 00:04:08,660
when they were trying to commit the code

00:04:05,750 --> 00:04:10,600
if we did the developer would have much

00:04:08,660 --> 00:04:12,650
more context of what is going on and

00:04:10,600 --> 00:04:16,579
processing that information would be

00:04:12,650 --> 00:04:18,799
much easier also consider what it's like

00:04:16,579 --> 00:04:20,810
to be a reviewer if you need to

00:04:18,799 --> 00:04:22,970
constantly correct style or common

00:04:20,810 --> 00:04:25,520
behavior traps you may be very focused

00:04:22,970 --> 00:04:27,880
on calling out that instead of focusing

00:04:25,520 --> 00:04:31,070
on the behavior of the actual code for

00:04:27,880 --> 00:04:32,720
instance in Ruby did you know that you

00:04:31,070 --> 00:04:35,389
can call super without needing any

00:04:32,720 --> 00:04:38,419
parentheses the reviewer in this slide

00:04:35,389 --> 00:04:40,340
knew that and wanted to call it out but

00:04:38,419 --> 00:04:42,449
in this situation the parentheses are

00:04:40,340 --> 00:04:45,719
required because the number of

00:04:42,449 --> 00:04:48,960
others have changed imagine if all of

00:04:45,719 --> 00:04:51,210
the styling and common issues could be

00:04:48,960 --> 00:04:53,610
automatically caught and identified to

00:04:51,210 --> 00:04:55,379
the writer the reviewer no longer needs

00:04:53,610 --> 00:04:58,080
to focus on making those kinds of

00:04:55,379 --> 00:05:00,270
comments and instead can focus on the

00:04:58,080 --> 00:05:02,219
actual behavior of the code which can

00:05:00,270 --> 00:05:06,559
lead to much higher quality code and

00:05:02,219 --> 00:05:09,419
less bugs there has to be a better way

00:05:06,559 --> 00:05:12,809
we can simplify this knowledge exchange

00:05:09,419 --> 00:05:15,479
and remove the human element from it we

00:05:12,809 --> 00:05:17,069
don't need to entirely rely on humans to

00:05:15,479 --> 00:05:19,400
catch these simple errors which is

00:05:17,069 --> 00:05:22,560
error-prone and can be overwhelming

00:05:19,400 --> 00:05:24,779
further we don't need to rely entirely

00:05:22,560 --> 00:05:28,409
on the tribal knowledge that a developer

00:05:24,779 --> 00:05:31,080
accumulates over time instead we can

00:05:28,409 --> 00:05:33,029
codify that knowledge and use it to

00:05:31,080 --> 00:05:35,999
teach other developers at the moment

00:05:33,029 --> 00:05:37,439
that it is relevant to them by doing so

00:05:35,999 --> 00:05:39,569
we can keep bad patterns and

00:05:37,439 --> 00:05:41,569
inconsistent styles out of the codebase

00:05:39,569 --> 00:05:44,159
forever

00:05:41,569 --> 00:05:46,740
people make mistakes all of the time

00:05:44,159 --> 00:05:49,199
this is code that someone at Clio wrote

00:05:46,740 --> 00:05:52,499
in early 2020 and it has a very subtle

00:05:49,199 --> 00:05:54,810
bug in it this test would run with a

00:05:52,499 --> 00:05:57,120
group of other tests and run in a very

00:05:54,810 --> 00:06:00,240
specific order can cause those other

00:05:57,120 --> 00:06:02,219
tests to fail however I don't want to

00:06:00,240 --> 00:06:03,930
point out what is wrong here yet I've

00:06:02,219 --> 00:06:05,909
just talked about removing some of the

00:06:03,930 --> 00:06:08,159
human element of teaching these kinds of

00:06:05,909 --> 00:06:10,680
lessons and if I simply point out what

00:06:08,159 --> 00:06:14,159
is wrong here I'm relying on my tribal

00:06:10,680 --> 00:06:15,629
knowledge to educate I want to show what

00:06:14,159 --> 00:06:17,490
it would look like to automatically

00:06:15,629 --> 00:06:21,060
prevent this kind of problem in the

00:06:17,490 --> 00:06:22,949
future so I will come back to this one

00:06:21,060 --> 00:06:25,740
of the ways we can tackle this problem

00:06:22,949 --> 00:06:28,889
is through linters Ruby has a really

00:06:25,740 --> 00:06:30,839
fantastic linter called Rubicon that has

00:06:28,889 --> 00:06:32,909
a lot of community support and it is a

00:06:30,839 --> 00:06:35,430
very powerful tool for static code

00:06:32,909 --> 00:06:37,770
analysis however I think there are some

00:06:35,430 --> 00:06:39,689
misconceptions of what can be done with

00:06:37,770 --> 00:06:44,430
a linter that I want to talk about first

00:06:39,689 --> 00:06:46,199
I often see when the idea of linting

00:06:44,430 --> 00:06:48,589
comes up that people think about things

00:06:46,199 --> 00:06:50,279
that are purely style or code layout

00:06:48,589 --> 00:06:51,959
while Robocop

00:06:50,279 --> 00:06:53,909
definitely offers built-in cops to

00:06:51,959 --> 00:06:55,950
handle these rules such as what you see

00:06:53,909 --> 00:06:59,940
here for instance it could be

00:06:55,950 --> 00:07:02,580
bad to have an empty else block this

00:06:59,940 --> 00:07:05,160
empty block doesn't actually influence

00:07:02,580 --> 00:07:07,350
the behavior at all although it might

00:07:05,160 --> 00:07:08,940
influence developers reading the code it

00:07:07,350 --> 00:07:12,240
might make the code maintainable but it

00:07:08,940 --> 00:07:14,220
doesn't touch the behavior you can also

00:07:12,240 --> 00:07:17,160
have layout cops that look something

00:07:14,220 --> 00:07:19,800
like this this is something that you can

00:07:17,160 --> 00:07:21,480
configure of what style you would like

00:07:19,800 --> 00:07:23,820
when changing methods over multiple

00:07:21,480 --> 00:07:26,580
lines you can either have methods that

00:07:23,820 --> 00:07:27,960
use a trailing dot or a leading dot but

00:07:26,580 --> 00:07:30,840
again this doesn't influence the

00:07:27,960 --> 00:07:34,710
behavior at all but it does help make

00:07:30,840 --> 00:07:37,080
code look consistent but linters can do

00:07:34,710 --> 00:07:40,290
so much more we can use it to handle

00:07:37,080 --> 00:07:41,940
complex behavior and as I mentioned also

00:07:40,290 --> 00:07:45,570
provide education when it detects

00:07:41,940 --> 00:07:48,180
something that violates the rule looking

00:07:45,570 --> 00:07:50,730
back at that dot position rule the one

00:07:48,180 --> 00:07:52,500
thing that is provided by robocop on top

00:07:50,730 --> 00:07:57,210
of all that is the ability to auto

00:07:52,500 --> 00:07:59,760
correct things although it is not not

00:07:57,210 --> 00:08:01,770
all of the cops provide it many do and I

00:07:59,760 --> 00:08:03,630
found many of the issues that can arise

00:08:01,770 --> 00:08:05,970
about trying to get a developer bought

00:08:03,630 --> 00:08:09,120
into using linters particularly those

00:08:05,970 --> 00:08:10,100
that are controversial is the ability to

00:08:09,120 --> 00:08:15,300
auto correct

00:08:10,100 --> 00:08:17,340
if you can auto correct decode it makes

00:08:15,300 --> 00:08:18,990
it much easier for developers to get on

00:08:17,340 --> 00:08:22,640
board since there's no additional work

00:08:18,990 --> 00:08:25,170
for them to do but as I mentioned

00:08:22,640 --> 00:08:28,380
Robocop can do much more than simple

00:08:25,170 --> 00:08:31,650
style or layout changes for instance it

00:08:28,380 --> 00:08:34,050
can do security checks for instance did

00:08:31,650 --> 00:08:36,780
you know that there are some methods

00:08:34,050 --> 00:08:38,729
on the llamó class that are potentially

00:08:36,780 --> 00:08:41,700
unsafe and can lead to a remote code

00:08:38,729 --> 00:08:44,370
execution if you don't use a linter to

00:08:41,700 --> 00:08:46,110
verify this you this is something that

00:08:44,370 --> 00:08:47,970
you need to keep in mind every time

00:08:46,110 --> 00:08:50,640
there is a code review otherwise it is a

00:08:47,970 --> 00:08:53,460
potential security risk but with a

00:08:50,640 --> 00:08:55,680
linter in place watching for it this is

00:08:53,460 --> 00:08:57,900
one less thing you need to think about

00:08:55,680 --> 00:08:59,700
one last thing for the developer writing

00:08:57,900 --> 00:09:02,370
the pull request and one less thing for

00:08:59,700 --> 00:09:04,920
the reviewer and while this might not

00:09:02,370 --> 00:09:07,140
seem like a lot as more and more of

00:09:04,920 --> 00:09:09,330
these rules are in place this benefit

00:09:07,140 --> 00:09:12,370
can really

00:09:09,330 --> 00:09:14,770
you can also do things like watching for

00:09:12,370 --> 00:09:17,440
code that rescues from the exception

00:09:14,770 --> 00:09:20,080
class most of the time this is not what

00:09:17,440 --> 00:09:22,270
you want to do likely you want to rescue

00:09:20,080 --> 00:09:24,250
from standard error or specific lists of

00:09:22,270 --> 00:09:28,090
exceptions there is good reason to this

00:09:24,250 --> 00:09:30,040
and I'll come back to this later and I'm

00:09:28,090 --> 00:09:32,530
sure many of you have had to do a rails

00:09:30,040 --> 00:09:34,570
upgrade at some point in the past the

00:09:32,530 --> 00:09:37,180
community has built some cops to help

00:09:34,570 --> 00:09:41,230
with this as well for instance if you're

00:09:37,180 --> 00:09:43,390
upgrading from rails 5.0 to 5.1 the

00:09:41,230 --> 00:09:46,150
format of how to send in parameters and

00:09:43,390 --> 00:09:47,560
controller tests have changed instead of

00:09:46,150 --> 00:09:49,930
being reliant on the position of the

00:09:47,560 --> 00:09:52,510
arguments it relies on the params

00:09:49,930 --> 00:09:55,840
keyword so you if you are in the process

00:09:52,510 --> 00:09:58,300
of an upgrade you could not only add

00:09:55,840 --> 00:10:00,400
this cop to prevent additional uses of

00:09:58,300 --> 00:10:02,290
the deprecated pattern but you can also

00:10:00,400 --> 00:10:04,630
use it to auto correct the instances

00:10:02,290 --> 00:10:08,440
that were already in place that is more

00:10:04,630 --> 00:10:10,510
work that you don't need to focus on but

00:10:08,440 --> 00:10:12,190
the most powerful aspect of Robocop in

00:10:10,510 --> 00:10:15,400
my opinion is that it's really

00:10:12,190 --> 00:10:17,290
customizable anyone can write their own

00:10:15,400 --> 00:10:18,970
cops and you can use them to omit

00:10:17,290 --> 00:10:22,660
various warnings and provide

00:10:18,970 --> 00:10:24,040
just-in-time education to developers you

00:10:22,660 --> 00:10:26,380
could write a cop that is highly

00:10:24,040 --> 00:10:28,360
specific to you or your place of work

00:10:26,380 --> 00:10:30,250
you can also write cops that are a

00:10:28,360 --> 00:10:33,610
benefit to the entire community

00:10:30,250 --> 00:10:36,040
as I mentioned before one of the best

00:10:33,610 --> 00:10:39,460
aspects of Ruby and rails is the

00:10:36,040 --> 00:10:41,500
community not only has the community

00:10:39,460 --> 00:10:43,240
done good job of supporting Robocop but

00:10:41,500 --> 00:10:45,160
the community has built lots of custom

00:10:43,240 --> 00:10:47,980
cops that can be immediately leveraged

00:10:45,160 --> 00:10:49,810
and used by all of you some people have

00:10:47,980 --> 00:10:52,030
dug into performance analysis and wrote

00:10:49,810 --> 00:10:54,910
a cop to help protect and educate

00:10:52,030 --> 00:10:57,730
against common performance gotchas there

00:10:54,910 --> 00:11:00,160
are rails specific ones r-spec specific

00:10:57,730 --> 00:11:03,990
ones things to look for wealth in the

00:11:00,160 --> 00:11:03,990
handling thread safety and so much more

00:11:04,500 --> 00:11:09,600
that customizability is really powerful

00:11:07,930 --> 00:11:12,910
but it's hard to know where to start

00:11:09,600 --> 00:11:15,220
when writing a cop so let's take a look

00:11:12,910 --> 00:11:19,390
under the hood about how Google cop

00:11:15,220 --> 00:11:20,499
works ruby has really strong support for

00:11:19,390 --> 00:11:23,679
meta programming and

00:11:20,499 --> 00:11:26,589
under the hood Robocop analyzes the Ruby

00:11:23,679 --> 00:11:29,679
code generates an abstract syntax tree

00:11:26,589 --> 00:11:32,139
and then provides hooks to run a ruby

00:11:29,679 --> 00:11:35,439
code on various parts of that abstract

00:11:32,139 --> 00:11:37,359
syntax tree I'm only going to be doing a

00:11:35,439 --> 00:11:39,639
high-level overview of how abstract

00:11:37,359 --> 00:11:41,349
syntax tree and Ruby looks and if you're

00:11:39,639 --> 00:11:42,699
curious to learn more there are plenty

00:11:41,349 --> 00:11:46,359
of interesting things you can learn

00:11:42,699 --> 00:11:48,299
about abstract syntax trees there's also

00:11:46,359 --> 00:11:51,549
a gem available called parser that

00:11:48,299 --> 00:11:53,679
provides a tool called Ruby parse this

00:11:51,549 --> 00:11:56,229
is an interesting command-line tool that

00:11:53,679 --> 00:11:57,479
you can provide arbitrary Ruby and it

00:11:56,229 --> 00:12:00,759
will convert it into the corresponding

00:11:57,479 --> 00:12:02,229
abstract syntax tree however this can

00:12:00,759 --> 00:12:04,299
look pretty complicated and hard to

00:12:02,229 --> 00:12:07,229
understand so let's break the syntax

00:12:04,299 --> 00:12:10,089
down a little bit with a couple examples

00:12:07,229 --> 00:12:12,039
let's come back to this example with the

00:12:10,089 --> 00:12:14,289
dot position whether or not we should

00:12:12,039 --> 00:12:17,499
have a leading or trailing dot how does

00:12:14,289 --> 00:12:19,839
robocop handle this under the hood well

00:12:17,499 --> 00:12:23,169
we first must look at the syntax tree

00:12:19,839 --> 00:12:24,909
generated by this code the code is

00:12:23,169 --> 00:12:27,129
something dot method and what is

00:12:24,909 --> 00:12:29,379
happening here this is a method being

00:12:27,129 --> 00:12:32,079
called so it is represented by a sent

00:12:29,379 --> 00:12:35,499
node the send note has two or more

00:12:32,079 --> 00:12:37,899
children the first child is the receiver

00:12:35,499 --> 00:12:40,149
the second child is the name of the

00:12:37,899 --> 00:12:43,809
method and the rest are the arguments

00:12:40,149 --> 00:12:46,119
being passed to the method so here we

00:12:43,809 --> 00:12:48,249
have a method named method so that is

00:12:46,119 --> 00:12:50,019
the second child we don't have any

00:12:48,249 --> 00:12:52,239
arguments so there are no children after

00:12:50,019 --> 00:12:55,659
that but now we need to look at the

00:12:52,239 --> 00:12:58,059
first child this is also a method call

00:12:55,659 --> 00:13:00,099
which as I mentioned earlier is

00:12:58,059 --> 00:13:03,279
represented by the send note and we

00:13:00,099 --> 00:13:06,339
recurse through this so we take a look

00:13:03,279 --> 00:13:08,349
at this one piece of code as well and we

00:13:06,339 --> 00:13:10,629
realize that the this is a method being

00:13:08,349 --> 00:13:13,869
called with a name something with a

00:13:10,629 --> 00:13:15,699
receiver being nil so there you have it

00:13:13,869 --> 00:13:18,009
this is the full abstract syntax tree

00:13:15,699 --> 00:13:19,779
for this one line of code and if we

00:13:18,009 --> 00:13:22,179
wanted to guess what Rubalcaba will be

00:13:19,779 --> 00:13:24,519
doing after looking at this we would

00:13:22,179 --> 00:13:27,099
probably need to watch somehow for a

00:13:24,519 --> 00:13:30,609
send node we need to somehow check that

00:13:27,099 --> 00:13:32,199
was being called on an object and we

00:13:30,609 --> 00:13:34,140
need to ensure that the dot was in the

00:13:32,199 --> 00:13:36,460
proper place

00:13:34,140 --> 00:13:39,130
this is the Ruby code that's powering

00:13:36,460 --> 00:13:40,510
that rule look how it's very similar to

00:13:39,130 --> 00:13:43,480
what I just described

00:13:40,510 --> 00:13:45,700
Robocop provides an on send method that

00:13:43,480 --> 00:13:47,740
gets called whenever the send node is

00:13:45,700 --> 00:13:51,520
triggered there are many of these that

00:13:47,740 --> 00:13:53,410
Robocop provides and this is just ruby

00:13:51,520 --> 00:13:57,670
code that we can write regular Ruby to

00:13:53,410 --> 00:13:59,230
do whatever we want we can take a look

00:13:57,670 --> 00:14:02,050
at the node and ask whether or not it

00:13:59,230 --> 00:14:03,490
contains a dot or an ampersand dot so we

00:14:02,050 --> 00:14:05,650
know that it's being called on an object

00:14:03,490 --> 00:14:08,230
we can check to see if it's in the

00:14:05,650 --> 00:14:11,470
proper position and if not we can add an

00:14:08,230 --> 00:14:14,350
offence and an error message and if we

00:14:11,470 --> 00:14:15,970
run Ruby cop on the file we can see that

00:14:14,350 --> 00:14:18,790
this the error that will be generated

00:14:15,970 --> 00:14:20,800
this is a pretty simple rule so the

00:14:18,790 --> 00:14:22,450
message is pretty simple as well it

00:14:20,800 --> 00:14:23,920
informs the developer that the dot

00:14:22,450 --> 00:14:26,020
should be placed on the next line

00:14:23,920 --> 00:14:28,090
together with the method name it also

00:14:26,020 --> 00:14:30,430
points at the exact file and line that

00:14:28,090 --> 00:14:32,860
it happened the error message here

00:14:30,430 --> 00:14:34,570
doesn't tell us why however it is

00:14:32,860 --> 00:14:37,300
something that is entirely Auto

00:14:34,570 --> 00:14:39,670
correctable so the why is a little bit

00:14:37,300 --> 00:14:41,530
less important developers can be

00:14:39,670 --> 00:14:43,690
informed that the change occurred in

00:14:41,530 --> 00:14:45,190
what file and what line but they don't

00:14:43,690 --> 00:14:48,130
have to worry about doing it themselves

00:14:45,190 --> 00:14:50,470
and in fact there are plugins that can

00:14:48,130 --> 00:14:52,840
be set up to run rugelach inside of your

00:14:50,470 --> 00:14:54,760
editor or you couldn't run Robocop with

00:14:52,840 --> 00:14:56,890
git hooks so that the autocorrect can

00:14:54,760 --> 00:15:00,970
happen very close to when the developer

00:14:56,890 --> 00:15:01,750
was writing it okay let's take a look at

00:15:00,970 --> 00:15:03,450
another example

00:15:01,750 --> 00:15:06,010
one that's a little bit more complicated

00:15:03,450 --> 00:15:07,900
this is that rule of checking whether or

00:15:06,010 --> 00:15:10,660
not we are are rescuing from exception

00:15:07,900 --> 00:15:12,940
or not in the previous example we only

00:15:10,660 --> 00:15:14,950
looked at a single line of code so let's

00:15:12,940 --> 00:15:16,570
look at what the abstract syntax tree of

00:15:14,950 --> 00:15:18,700
these lines of code would look like and

00:15:16,570 --> 00:15:21,910
see how the ruble clock would perform

00:15:18,700 --> 00:15:24,850
this behavior check so let's look at

00:15:21,910 --> 00:15:27,580
these five lines of code the top of the

00:15:24,850 --> 00:15:30,550
tree is represented with a kW begin node

00:15:27,580 --> 00:15:32,500
assume the K W stands for keyword and

00:15:30,550 --> 00:15:35,550
there are a couple different beginning

00:15:32,500 --> 00:15:38,170
nodes but this is what is rendered here

00:15:35,550 --> 00:15:40,930
there's only a single child to this node

00:15:38,170 --> 00:15:42,910
now this is where the abstract syntax

00:15:40,930 --> 00:15:46,990
tree might be different than how you may

00:15:42,910 --> 00:15:47,500
read the code the one child of the kW

00:15:46,990 --> 00:15:52,690
big and

00:15:47,500 --> 00:15:55,360
here is actually the rescue keyword the

00:15:52,690 --> 00:15:57,340
rescue note here has three children the

00:15:55,360 --> 00:15:59,620
first child happens is what happens

00:15:57,340 --> 00:16:01,810
before the rescue so in this case it's

00:15:59,620 --> 00:16:03,520
this line here and we've known we know

00:16:01,810 --> 00:16:06,310
from the previous example that this is a

00:16:03,520 --> 00:16:09,880
send node with a method do something

00:16:06,310 --> 00:16:13,030
that is being called on nil now the next

00:16:09,880 --> 00:16:15,190
child represents the contents of the

00:16:13,030 --> 00:16:19,120
rescue block and is represented with the

00:16:15,190 --> 00:16:22,420
res body note this note also has three

00:16:19,120 --> 00:16:26,200
children the first child is the list of

00:16:22,420 --> 00:16:29,580
exceptions that we want to rescue so in

00:16:26,200 --> 00:16:32,980
this case it's an array of constants

00:16:29,580 --> 00:16:36,940
with the value exception with no name

00:16:32,980 --> 00:16:39,610
space we only have one the next child of

00:16:36,940 --> 00:16:41,470
res body is the local variable name that

00:16:39,610 --> 00:16:43,780
we're going to provide for the exception

00:16:41,470 --> 00:16:46,000
in this case we happen to assign the

00:16:43,780 --> 00:16:50,590
value of that exception to anything so

00:16:46,000 --> 00:16:53,230
it is nil the last child is the code of

00:16:50,590 --> 00:16:56,050
the body inside of the rescue and we've

00:16:53,230 --> 00:16:58,390
seen this before too this is a send node

00:16:56,050 --> 00:17:01,540
with the method name handle exception

00:16:58,390 --> 00:17:03,940
that is being called on nil and lastly I

00:17:01,540 --> 00:17:06,520
mentioned that rescue has three children

00:17:03,940 --> 00:17:08,500
the last child is the contents of the

00:17:06,520 --> 00:17:11,050
else block which you may or may not have

00:17:08,500 --> 00:17:13,240
known could be provided by the rescue in

00:17:11,050 --> 00:17:16,240
this case we didn't provide it so it is

00:17:13,240 --> 00:17:18,459
nil this is what the syntax tree of

00:17:16,240 --> 00:17:21,339
those five lines of code looked like and

00:17:18,459 --> 00:17:23,400
if we wanted to look at how robocop

00:17:21,339 --> 00:17:26,350
would power that rule to prevent

00:17:23,400 --> 00:17:29,380
rescuing from exception we would need to

00:17:26,350 --> 00:17:31,030
look for the res body node we would have

00:17:29,380 --> 00:17:33,400
to look for that list of exceptions

00:17:31,030 --> 00:17:34,840
which was its first child and we just

00:17:33,400 --> 00:17:40,090
need to check if any of them is a

00:17:34,840 --> 00:17:41,860
constant with the value exception if you

00:17:40,090 --> 00:17:43,800
look at the Ruby code for the cop we can

00:17:41,860 --> 00:17:47,200
see it pretty much does exactly that

00:17:43,800 --> 00:17:49,240
whenever we see a res body node we take

00:17:47,200 --> 00:17:51,370
a look at its children if it has no

00:17:49,240 --> 00:17:54,160
exceptions provided so this is just a

00:17:51,370 --> 00:17:56,440
bear rescue then this is acceptable but

00:17:54,160 --> 00:17:58,150
if the list of exceptions were provided

00:17:56,440 --> 00:18:00,370
we should take a look at each one and

00:17:58,150 --> 00:18:02,679
check if it's the class exception

00:18:00,370 --> 00:18:07,900
if any of them are we can record an

00:18:02,679 --> 00:18:10,059
offense so if we run Robocop we once

00:18:07,900 --> 00:18:11,679
again see the error message we can run

00:18:10,059 --> 00:18:14,529
this via the command line and see this

00:18:11,679 --> 00:18:16,690
message show up in there or we can have

00:18:14,529 --> 00:18:19,419
it run in our editor and see that as we

00:18:16,690 --> 00:18:22,029
are writing the code the message here is

00:18:19,419 --> 00:18:23,230
okay it mentions what is wrong and how

00:18:22,029 --> 00:18:25,840
to fix it but there's a little bit of

00:18:23,230 --> 00:18:27,610
information that's still missing and it

00:18:25,840 --> 00:18:30,010
would still require an developer who is

00:18:27,610 --> 00:18:32,799
unfamiliar with this problem to go

00:18:30,010 --> 00:18:36,039
research to understand why this is a bad

00:18:32,799 --> 00:18:37,809
pattern if you go look at the Robocop

00:18:36,039 --> 00:18:39,669
documentation for this rule you'll find

00:18:37,809 --> 00:18:42,429
a link that links you to a page that

00:18:39,669 --> 00:18:45,669
explains why blind these rescues could

00:18:42,429 --> 00:18:47,799
be bad if you rescue from exception you

00:18:45,669 --> 00:18:49,960
may also be rescuing signal exceptions

00:18:47,799 --> 00:18:53,440
which mean mean that your Ruby process

00:18:49,960 --> 00:18:54,909
may not exit when you expect them to the

00:18:53,440 --> 00:18:56,200
developer would have to dig a little bit

00:18:54,909 --> 00:18:58,690
in order to find that so in the most

00:18:56,200 --> 00:19:01,080
ideal situation we want to be able to

00:18:58,690 --> 00:19:03,490
have this information readily available

00:19:01,080 --> 00:19:05,350
so let's come back to that original bit

00:19:03,490 --> 00:19:07,690
of code that I laid out earlier that was

00:19:05,350 --> 00:19:09,700
problematic let's go through what it

00:19:07,690 --> 00:19:11,710
would take to codify why this is a

00:19:09,700 --> 00:19:15,399
problem and prevent this classification

00:19:11,710 --> 00:19:17,049
of issues from happening again however

00:19:15,399 --> 00:19:19,240
now I do need to tell you what's wrong

00:19:17,049 --> 00:19:21,580
with this code the issue here lies in

00:19:19,240 --> 00:19:23,710
this line right here on this line we're

00:19:21,580 --> 00:19:27,549
assigning the value true to the permit

00:19:23,710 --> 00:19:29,649
all parameters configuration looking at

00:19:27,549 --> 00:19:32,080
that permit all parameters method we can

00:19:29,649 --> 00:19:33,760
see that it's a C ad or accessor which

00:19:32,080 --> 00:19:37,419
effectively means it is a global

00:19:33,760 --> 00:19:40,480
variable assigning a global variable in

00:19:37,419 --> 00:19:42,909
a test like what is shown can be okay

00:19:40,480 --> 00:19:44,980
but the main thing is we didn't reset it

00:19:42,909 --> 00:19:47,200
back to the original value it was when

00:19:44,980 --> 00:19:49,149
the test started so when that test

00:19:47,200 --> 00:19:51,789
friend it has the potential to change

00:19:49,149 --> 00:19:55,419
the global state which is why they're

00:19:51,789 --> 00:19:57,789
the subtle bug exists so if we didn't

00:19:55,419 --> 00:20:00,520
set it back before the proper code would

00:19:57,789 --> 00:20:02,710
look something like this if we are

00:20:00,520 --> 00:20:05,110
setting some value to something that is

00:20:02,710 --> 00:20:07,809
global we should be inside of a begin

00:20:05,110 --> 00:20:11,710
block we should remember to cache the

00:20:07,809 --> 00:20:13,390
original value before we should image to

00:20:11,710 --> 00:20:13,960
have an ensure block in case there's an

00:20:13,390 --> 00:20:17,110
exception

00:20:13,960 --> 00:20:20,380
raised in between and finally we want to

00:20:17,110 --> 00:20:23,559
reset the value of that variable to the

00:20:20,380 --> 00:20:25,330
original value at the end there's a lot

00:20:23,559 --> 00:20:27,840
of steps here and it can seem

00:20:25,330 --> 00:20:30,820
complicated but it isn't too bad

00:20:27,840 --> 00:20:33,549
remember that ruble cop is just ruby and

00:20:30,820 --> 00:20:35,409
we can write tests for Ruby this may

00:20:33,549 --> 00:20:37,929
seem a little meta we are writing Ruby

00:20:35,409 --> 00:20:40,299
code for a class that's looking at Ruby

00:20:37,929 --> 00:20:43,270
code but we can still take a TDD

00:20:40,299 --> 00:20:44,500
approach to build this Cup first we can

00:20:43,270 --> 00:20:47,260
start with a little bit of boilerplate

00:20:44,500 --> 00:20:50,049
and then we can write a test that states

00:20:47,260 --> 00:20:52,690
that if you are assigning a value to a

00:20:50,049 --> 00:20:55,659
global variable the custom cop code

00:20:52,690 --> 00:20:58,539
should consider it an offence so now we

00:20:55,659 --> 00:21:02,380
have a test and we can figure out what

00:20:58,539 --> 00:21:04,750
would a cop here look like well what is

00:21:02,380 --> 00:21:08,529
the permit all parameters equal that is

00:21:04,750 --> 00:21:11,529
a method call and we've seen one of

00:21:08,529 --> 00:21:15,250
those before already this is we can tie

00:21:11,529 --> 00:21:17,980
into this with the on send method we can

00:21:15,250 --> 00:21:20,110
add a guard clause to ensure that the

00:21:17,980 --> 00:21:22,120
method is something that does modify

00:21:20,110 --> 00:21:24,520
global variable this could be as simple

00:21:22,120 --> 00:21:27,610
as a whitelisted array of methods that

00:21:24,520 --> 00:21:30,429
could be considered bad and then we can

00:21:27,610 --> 00:21:32,830
assert that this code has to be inside

00:21:30,429 --> 00:21:34,600
of a begin block this doesn't fully

00:21:32,830 --> 00:21:36,730
implement the rule but it does make our

00:21:34,600 --> 00:21:41,679
test paths let's continue iterating over

00:21:36,730 --> 00:21:44,409
this okay so if the assignment inside of

00:21:41,679 --> 00:21:47,830
the begin is not OK we should add

00:21:44,409 --> 00:21:50,440
another test so let's wrap that

00:21:47,830 --> 00:21:55,360
assignment in a begin end and assert

00:21:50,440 --> 00:21:57,399
that it does fail now so now we can

00:21:55,360 --> 00:21:59,649
implement the behavior for this why is

00:21:57,399 --> 00:22:01,750
the assignment of the beginning inside

00:21:59,649 --> 00:22:03,309
of that begin block not enough well

00:22:01,750 --> 00:22:06,880
that's because we didn't cache the

00:22:03,309 --> 00:22:09,309
original value Ruby grubo cop gives us

00:22:06,880 --> 00:22:11,679
the ability to navigate abstract syntax

00:22:09,309 --> 00:22:14,919
trees so we can even look and grab the

00:22:11,679 --> 00:22:17,830
local variable names so we can grab that

00:22:14,919 --> 00:22:20,590
local variable if it wasn't present or

00:22:17,830 --> 00:22:23,799
someone did not write it we can add an

00:22:20,590 --> 00:22:26,679
offense and huzzah our tests are passing

00:22:23,799 --> 00:22:27,790
again again doesn't fully describe the

00:22:26,679 --> 00:22:31,300
behavior but we're still

00:22:27,790 --> 00:22:33,400
over this so what makes the assignment

00:22:31,300 --> 00:22:36,670
inside of the begin block bad if it

00:22:33,400 --> 00:22:38,830
caches the value well it isn't

00:22:36,670 --> 00:22:40,960
assigning the value back at the end so

00:22:38,830 --> 00:22:43,570
let's write a test that has most of the

00:22:40,960 --> 00:22:45,610
pieces we're in a begin block we cache

00:22:43,570 --> 00:22:48,010
the original value we have an ensure

00:22:45,610 --> 00:22:50,080
block what happens if we don't assign it

00:22:48,010 --> 00:22:51,970
back the original value we should have

00:22:50,080 --> 00:22:55,300
an offence there so this test should

00:22:51,970 --> 00:22:58,330
fail again so now we have to implement

00:22:55,300 --> 00:23:00,220
that last piece we should assert that

00:22:58,330 --> 00:23:03,160
the variable inside of the ensure block

00:23:00,220 --> 00:23:06,600
matches the local variable of the stored

00:23:03,160 --> 00:23:11,080
or original value if that isn't the case

00:23:06,600 --> 00:23:13,420
we raise an offence okay now our rule

00:23:11,080 --> 00:23:14,890
seems to work but let's write one more

00:23:13,420 --> 00:23:16,330
piece to make sure that it's actually

00:23:14,890 --> 00:23:18,930
doing what we expect

00:23:16,330 --> 00:23:21,550
so let's write one last test that

00:23:18,930 --> 00:23:24,010
asserts we have all of the pieces we

00:23:21,550 --> 00:23:26,080
have a begin block we have the cashing

00:23:24,010 --> 00:23:29,440
of the old value we have an ensure block

00:23:26,080 --> 00:23:31,660
and we reset the value to the original

00:23:29,440 --> 00:23:35,830
there should not be an offense here and

00:23:31,660 --> 00:23:37,840
now we have a custom working cup now

00:23:35,830 --> 00:23:40,120
through this entire process we have full

00:23:37,840 --> 00:23:45,880
control over what the error message is

00:23:40,120 --> 00:23:48,670
and we can be as verbose as possible so

00:23:45,880 --> 00:23:50,500
now when a new developer comes along and

00:23:48,670 --> 00:23:52,960
tries to write code that is the same

00:23:50,500 --> 00:23:54,640
issue they can have the linter run as

00:23:52,960 --> 00:23:56,770
part of them writing the code and be

00:23:54,640 --> 00:23:59,680
provided immediate feedback on what they

00:23:56,770 --> 00:24:01,840
literally just wrote this is fantastic

00:23:59,680 --> 00:24:03,340
we can tell them that they modified a

00:24:01,840 --> 00:24:05,710
global variable and that this could

00:24:03,340 --> 00:24:08,050
cause a transient spec failure because

00:24:05,710 --> 00:24:10,960
they didn't save what the original value

00:24:08,050 --> 00:24:12,610
was the developer already has full

00:24:10,960 --> 00:24:14,260
context and we're alerting them to an

00:24:12,610 --> 00:24:16,960
issue that they may or may not be aware

00:24:14,260 --> 00:24:19,390
of and this also means that the

00:24:16,960 --> 00:24:21,010
reviewers of this code don't need to

00:24:19,390 --> 00:24:22,750
worry about this in the future either

00:24:21,010 --> 00:24:25,330
because that knowledge has become

00:24:22,750 --> 00:24:27,420
codified and it is now a pattern that

00:24:25,330 --> 00:24:29,440
will stay out of the codebase forever

00:24:27,420 --> 00:24:32,680
there is also another interesting

00:24:29,440 --> 00:24:35,380
consequence as well because this check

00:24:32,680 --> 00:24:37,450
now exists inside of the code base other

00:24:35,380 --> 00:24:39,460
developers can extend it to make it

00:24:37,450 --> 00:24:41,460
apply to other methods or in similar

00:24:39,460 --> 00:24:44,590
situations

00:24:41,460 --> 00:24:48,190
we use cops like this all of the time a

00:24:44,590 --> 00:24:50,110
clue we have many different ones some

00:24:48,190 --> 00:24:52,420
other examples include things like this

00:24:50,110 --> 00:24:56,220
at some point someone made a constant

00:24:52,420 --> 00:24:59,230
that used time now or two days from now

00:24:56,220 --> 00:25:01,840
this constant would have its values set

00:24:59,230 --> 00:25:05,170
on boot and it's typically not what the

00:25:01,840 --> 00:25:07,000
developer was expecting because they

00:25:05,170 --> 00:25:09,970
were expecting this to always be two

00:25:07,000 --> 00:25:12,790
days from now but someone made this

00:25:09,970 --> 00:25:14,290
mistake once and we can prevent this

00:25:12,790 --> 00:25:16,570
from ever happening again with a very

00:25:14,290 --> 00:25:19,090
simple check and we can also provide

00:25:16,570 --> 00:25:22,570
context an education event of the moment

00:25:19,090 --> 00:25:25,270
developer writes it we also don't need

00:25:22,570 --> 00:25:27,520
to just isolate to the code itself this

00:25:25,270 --> 00:25:30,100
is Ruby and we can write any Ruby we

00:25:27,520 --> 00:25:31,750
want for instance we have a custom rule

00:25:30,100 --> 00:25:34,660
that asserts that we're adhering to the

00:25:31,750 --> 00:25:37,059
rails convention for naming things in

00:25:34,660 --> 00:25:39,850
this case we have a user class that's

00:25:37,059 --> 00:25:41,679
inside of a managed module the developer

00:25:39,850 --> 00:25:44,020
made a typo when making the test file

00:25:41,679 --> 00:25:46,780
and accidentally made the tot the test

00:25:44,020 --> 00:25:48,640
file plural well we can have a custom

00:25:46,780 --> 00:25:50,740
chalk off that can check the file names

00:25:48,640 --> 00:25:51,520
and inform the developer that something

00:25:50,740 --> 00:25:53,980
seems off

00:25:51,520 --> 00:25:56,050
they likely just wrote the test and have

00:25:53,980 --> 00:25:59,530
full context around the error that it is

00:25:56,050 --> 00:26:01,360
describing remember too that these rules

00:25:59,530 --> 00:26:04,090
are not dumping all of this information

00:26:01,360 --> 00:26:07,030
on the developer at once at review time

00:26:04,090 --> 00:26:09,340
is providing this education in context

00:26:07,030 --> 00:26:13,630
as close to the developer writing the

00:26:09,340 --> 00:26:16,090
code as possible we have many custom

00:26:13,630 --> 00:26:19,059
costs that we set up at Clio and we

00:26:16,090 --> 00:26:20,770
build new ones frequently other custom

00:26:19,059 --> 00:26:23,530
costs we have for instance

00:26:20,770 --> 00:26:26,980
teach people about bad stubbing patterns

00:26:23,530 --> 00:26:28,870
in specs we have deprecated classes that

00:26:26,980 --> 00:26:30,700
we don't want people to inherit from and

00:26:28,870 --> 00:26:34,600
we can provide context and how you can

00:26:30,700 --> 00:26:36,610
use the new classes instead we can

00:26:34,600 --> 00:26:39,010
provide warnings for deprecated methods

00:26:36,610 --> 00:26:40,720
or methods we don't want used anymore

00:26:39,010 --> 00:26:44,200
because will provide why and what you

00:26:40,720 --> 00:26:46,240
should do we can ensure that temp files

00:26:44,200 --> 00:26:48,580
are always closed and what are the

00:26:46,240 --> 00:26:51,820
dangers of leaving some of them open and

00:26:48,580 --> 00:26:53,559
many more whenever we encounter a

00:26:51,820 --> 00:26:55,990
problem that's problematic

00:26:53,559 --> 00:26:57,970
we aim to write a custom cop to prevent

00:26:55,990 --> 00:26:59,890
this pattern in the future and we

00:26:57,970 --> 00:27:04,660
provide that knowledge to everyone and

00:26:59,890 --> 00:27:06,940
our codebase continually gets better so

00:27:04,660 --> 00:27:09,280
by leveraging the linter we can get

00:27:06,940 --> 00:27:10,510
consistent style across our application

00:27:09,280 --> 00:27:14,500
and we can guarantee you that

00:27:10,510 --> 00:27:16,750
problematic behavior stays out but

00:27:14,500 --> 00:27:19,270
because reviewers no longer need to

00:27:16,750 --> 00:27:22,179
focus on that inconsistency they can

00:27:19,270 --> 00:27:24,400
focus on the code quality in which is

00:27:22,179 --> 00:27:26,440
which will significantly increase the

00:27:24,400 --> 00:27:30,940
quality of the code and result in less

00:27:26,440 --> 00:27:33,760
bugs and we can codify all of our

00:27:30,940 --> 00:27:35,980
learnings rather than have to rely on a

00:27:33,760 --> 00:27:38,320
developer catching things and providing

00:27:35,980 --> 00:27:40,690
that education we can start collecting

00:27:38,320 --> 00:27:42,960
these pieces of knowledge and have an

00:27:40,690 --> 00:27:45,550
automated system that checks for them

00:27:42,960 --> 00:27:47,050
for things that are really common is

00:27:45,550 --> 00:27:49,150
possible you can even provide these

00:27:47,050 --> 00:27:52,960
tools back to the community and improve

00:27:49,150 --> 00:27:55,150
the code quality for everyone ok so how

00:27:52,960 --> 00:27:57,520
do you get started if you're not

00:27:55,150 --> 00:27:59,620
currently using the lentor here are some

00:27:57,520 --> 00:28:01,240
of the insights we have at CLIA that has

00:27:59,620 --> 00:28:05,290
really helped us get buy-in from our

00:28:01,240 --> 00:28:07,960
developers and team first Google Cup

00:28:05,290 --> 00:28:09,880
comes with a lot of rules some of them

00:28:07,960 --> 00:28:12,130
may make sense and some of them may be

00:28:09,880 --> 00:28:14,830
more controversial in your organization

00:28:12,130 --> 00:28:17,200
you are not obligated to enable them all

00:28:14,830 --> 00:28:19,390
by default in fact you don't need to

00:28:17,200 --> 00:28:22,090
enable any of them if you only want to

00:28:19,390 --> 00:28:23,980
run custom code you can start with the

00:28:22,090 --> 00:28:28,300
pieces that make the most sense for you

00:28:23,980 --> 00:28:31,570
and enable those next you can leverage

00:28:28,300 --> 00:28:33,550
autocorrect as much as possible although

00:28:31,570 --> 00:28:36,400
I didn't go over it with the custom cop

00:28:33,550 --> 00:28:38,440
that was outlined you could also use it

00:28:36,400 --> 00:28:41,980
implement your own autocorrect behavior

00:28:38,440 --> 00:28:44,110
for custom cops as well when the rules

00:28:41,980 --> 00:28:46,300
are safely an autocorrect are

00:28:44,110 --> 00:28:48,490
automatically auto corrected a lot of

00:28:46,300 --> 00:28:49,090
the disagreements about Styles just go

00:28:48,490 --> 00:28:51,160
away

00:28:49,090 --> 00:28:52,480
who cares if you have a leading or

00:28:51,160 --> 00:28:55,120
trailing dot when you're chaining

00:28:52,480 --> 00:28:57,700
methods across multiple lines if Robocop

00:28:55,120 --> 00:29:01,750
will just correct it for you and you'll

00:28:57,700 --> 00:29:03,250
end up with a consistent style you want

00:29:01,750 --> 00:29:06,429
to provide as much feedback as possible

00:29:03,250 --> 00:29:07,420
to the developers as fast as possible so

00:29:06,429 --> 00:29:09,700
do it in multiple

00:29:07,420 --> 00:29:11,350
places encourage the developers to set

00:29:09,700 --> 00:29:13,780
up lending in their editors so they can

00:29:11,350 --> 00:29:17,650
see everything and as close to real time

00:29:13,780 --> 00:29:20,170
as they're writing their code if you use

00:29:17,650 --> 00:29:23,470
get set up a pre-commit hook that Lintz

00:29:20,170 --> 00:29:25,390
the changed or added files then you know

00:29:23,470 --> 00:29:27,730
the moment a developer tries to commit

00:29:25,390 --> 00:29:29,230
code they'll get feedback it's a little

00:29:27,730 --> 00:29:31,300
bit slower than the editor but it will

00:29:29,230 --> 00:29:34,870
still provide feedback very close to

00:29:31,300 --> 00:29:36,760
when they write the code you can also

00:29:34,870 --> 00:29:39,460
set up a continuous integration server

00:29:36,760 --> 00:29:41,620
that does a full linting pass our code

00:29:39,460 --> 00:29:42,880
base at Clio is quite large and the step

00:29:41,620 --> 00:29:44,440
only takes a couple minutes

00:29:42,880 --> 00:29:47,170
so we've run it in parallel with our

00:29:44,440 --> 00:29:49,120
test suite this guarantee is that all of

00:29:47,170 --> 00:29:53,110
the code in the pull request lines up

00:29:49,120 --> 00:29:55,690
with the expected rules but lastly and

00:29:53,110 --> 00:29:58,180
probably most importantly we should

00:29:55,690 --> 00:30:01,330
treat linting as a method to educate and

00:29:58,180 --> 00:30:03,490
train other developers if you want to

00:30:01,330 --> 00:30:06,070
get buy-in from an organization you can

00:30:03,490 --> 00:30:08,470
voice how codifying developers learnings

00:30:06,070 --> 00:30:10,840
and providing just-in-time education for

00:30:08,470 --> 00:30:12,780
them will keep out bad patterns and make

00:30:10,840 --> 00:30:15,400
all of the other developers better

00:30:12,780 --> 00:30:18,070
likely they will see value in investing

00:30:15,400 --> 00:30:20,260
time and end in a tool that can help

00:30:18,070 --> 00:30:26,010
make all the developers better and make

00:30:20,260 --> 00:30:26,010

YouTube URL: https://www.youtube.com/watch?v=ws_8ie6TMtA


