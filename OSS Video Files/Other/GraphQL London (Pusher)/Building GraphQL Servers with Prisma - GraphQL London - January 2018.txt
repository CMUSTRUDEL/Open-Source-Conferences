Title: Building GraphQL Servers with Prisma - GraphQL London - January 2018
Publication date: 2018-02-05
Playlist: GraphQL London
Description: 
	Johannes is a Berlin/SF-based entrepreneur and founder of Graphcool, a GraphQL database proxy & platform. He previously built and sold the VR company *Optonaut*. Johannes studied computer science at KIT, Germany and loves cutting-edge Mobile/Web technologies.

Prisma is an open-source GraphQL API layer that turns your database into a GraphQL API. It is also the core technology powering the Graphcool Framework and now available for everyone to build their own GraphQL servers. Together with GraphQL bindings, it drastically improves developer experience for developing backends that are based on GraphQL.

In this talk, youâ€™ll learn more about what Prisma actually is, how it works, why we built it and of course how you can use to build your own GraphQL servers!

________________________________________________________________

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:04,589
all right yeah it's it's awesome to be

00:00:02,040 --> 00:00:06,720
here again and by the way for those of

00:00:04,589 --> 00:00:09,090
you who are new to graph Cal and like

00:00:06,720 --> 00:00:12,030
have there was probably quite a daunting

00:00:09,090 --> 00:00:13,860
entry point you to learn about graph Cal

00:00:12,030 --> 00:00:16,199
with all of the tooling and all of these

00:00:13,860 --> 00:00:18,600
advanced concepts so for those of you

00:00:16,199 --> 00:00:20,660
who it's just like the first interaction

00:00:18,600 --> 00:00:23,640
with graph gal I can highly recommend

00:00:20,660 --> 00:00:27,300
getting started on how to graph Cal calm

00:00:23,640 --> 00:00:30,960
so just takes you like through really

00:00:27,300 --> 00:00:33,420
from zero to either a client-side graph

00:00:30,960 --> 00:00:37,170
care lab or a server-side graph Cal app

00:00:33,420 --> 00:00:38,579
with any prior knowledge so for the

00:00:37,170 --> 00:00:41,280
beginners here I can really recommend

00:00:38,579 --> 00:00:44,219
that so yeah my name is Johanna

00:00:41,280 --> 00:00:45,960
chuckling I'm based in Berlin and spend

00:00:44,219 --> 00:00:48,870
more and more time also in San Francisco

00:00:45,960 --> 00:00:51,750
and I also work at graphical you can

00:00:48,870 --> 00:00:56,129
find me with this handle on on Twitter

00:00:51,750 --> 00:00:59,190
and at chickling on github today I want

00:00:56,129 --> 00:01:04,080
to give you a quick overview over Prisma

00:00:59,190 --> 00:01:05,909
what we launched last week and a bit

00:01:04,080 --> 00:01:08,159
more practical want to show you how you

00:01:05,909 --> 00:01:11,549
can build your own node based graphical

00:01:08,159 --> 00:01:16,830
servers using Prisma with an actual live

00:01:11,549 --> 00:01:20,570
demo in the end yeah so Prisma who of

00:01:16,830 --> 00:01:21,840
you has seen this last week on twitter

00:01:20,570 --> 00:01:27,450
yes

00:01:21,840 --> 00:01:30,090
great range awesome so Prisma is very

00:01:27,450 --> 00:01:33,450
simple to explain so you can kind of

00:01:30,090 --> 00:01:35,909
think about it as a graphical proxy

00:01:33,450 --> 00:01:38,460
layer for your database so what you do

00:01:35,909 --> 00:01:40,470
is like you put Prisma in front of your

00:01:38,460 --> 00:01:43,860
database and you get a graph Gale API

00:01:40,470 --> 00:01:46,439
and this is not really exciting because

00:01:43,860 --> 00:01:48,990
they're the graphical ecosystem has

00:01:46,439 --> 00:01:51,960
advanced quite a lot so you have a whole

00:01:48,990 --> 00:01:54,600
different range of possibilities how you

00:01:51,960 --> 00:01:56,369
can use that you cannot just directly

00:01:54,600 --> 00:01:58,860
connect from the from the front end to

00:01:56,369 --> 00:02:00,719
this graphical API but you can use it to

00:01:58,860 --> 00:02:02,540
build your own graphical server and this

00:02:00,719 --> 00:02:07,530
is what I what I want to focus today on

00:02:02,540 --> 00:02:11,760
so I said Prisma is a proxy layer for

00:02:07,530 --> 00:02:13,830
your database it generates a crud crud

00:02:11,760 --> 00:02:15,510
style Roth Cal API

00:02:13,830 --> 00:02:17,640
based on your data model if you're

00:02:15,510 --> 00:02:19,950
starting from scratch and this graph gal

00:02:17,640 --> 00:02:22,770
API can be used either from the front

00:02:19,950 --> 00:02:26,490
end or to build your own graphical

00:02:22,770 --> 00:02:29,460
server and Prisma also provides some

00:02:26,490 --> 00:02:32,250
tooling around operating and and

00:02:29,460 --> 00:02:35,580
migrating your your database so on a

00:02:32,250 --> 00:02:37,830
high-level how it works is that when

00:02:35,580 --> 00:02:40,530
you're starting out from scratch is that

00:02:37,830 --> 00:02:42,720
you use graphical STL to define your

00:02:40,530 --> 00:02:45,600
data model and you get a fully

00:02:42,720 --> 00:02:46,230
functional graphical API generated out

00:02:45,600 --> 00:02:49,950
of the box

00:02:46,230 --> 00:02:52,800
so again graph Cal STL for those of you

00:02:49,950 --> 00:02:55,770
who are not familiar it's a really

00:02:52,800 --> 00:02:59,610
simple notation to essentially define

00:02:55,770 --> 00:03:02,610
types that relate to each other and bate

00:02:59,610 --> 00:03:05,220
and this this type definition is

00:03:02,610 --> 00:03:06,930
understood by a lot of tooling and it's

00:03:05,220 --> 00:03:09,660
the foundation for the schema you're

00:03:06,930 --> 00:03:11,220
generating so typically you also have

00:03:09,660 --> 00:03:13,860
like another type that's called query

00:03:11,220 --> 00:03:15,840
this query this type Kirby has a special

00:03:13,860 --> 00:03:17,850
meaning since it's the entry point into

00:03:15,840 --> 00:03:21,060
your graphical API that you can query

00:03:17,850 --> 00:03:23,160
from here for example the the type query

00:03:21,060 --> 00:03:25,830
if there would be one would have a field

00:03:23,160 --> 00:03:30,810
users weight then can can traverse your

00:03:25,830 --> 00:03:34,230
graph girls server so there I said there

00:03:30,810 --> 00:03:36,690
are two ways to use Prisma so either you

00:03:34,230 --> 00:03:39,000
connect directly from a front-end

00:03:36,690 --> 00:03:41,160
application this is for example great if

00:03:39,000 --> 00:03:43,620
you're building out prototypes or if

00:03:41,160 --> 00:03:45,989
you're building internal tools where

00:03:43,620 --> 00:03:47,040
you're you know trusted in a trusted

00:03:45,989 --> 00:03:50,100
context where you don't need

00:03:47,040 --> 00:03:54,750
sophisticated authentication also reset

00:03:50,100 --> 00:03:56,970
authorization methods or you can use

00:03:54,750 --> 00:03:58,410
that as a foundation to build your own

00:03:56,970 --> 00:04:01,890
graphical server it's actually also

00:03:58,410 --> 00:04:03,570
really nice to do this in a incremental

00:04:01,890 --> 00:04:06,390
way so that means you're starting out

00:04:03,570 --> 00:04:08,700
using Prisma directly from the front-end

00:04:06,390 --> 00:04:11,549
for your first iteration of your for a

00:04:08,700 --> 00:04:13,769
first MVP and then you put in your own

00:04:11,549 --> 00:04:17,040
graphical server and implement all of

00:04:13,769 --> 00:04:19,410
the business logic that you need so then

00:04:17,040 --> 00:04:22,200
this is the second option how you can

00:04:19,410 --> 00:04:25,560
use it and what we've what we've already

00:04:22,200 --> 00:04:27,210
seen in Jason's talk is that you can

00:04:25,560 --> 00:04:31,979
also use this

00:04:27,210 --> 00:04:34,440
for a gateway microservice pattern so on

00:04:31,979 --> 00:04:36,780
a high-level architecture it looks

00:04:34,440 --> 00:04:39,360
somewhat like this you have a database

00:04:36,780 --> 00:04:41,699
currently we're supporting my sequel you

00:04:39,360 --> 00:04:44,789
put Prisma in front of it either you

00:04:41,699 --> 00:04:48,210
hosted yourself using docker you can run

00:04:44,789 --> 00:04:50,820
it like this locally or you you can use

00:04:48,210 --> 00:04:52,979
it as a cloud offering and you

00:04:50,820 --> 00:04:58,080
instrument all of that development time

00:04:52,979 --> 00:05:00,210
throughout a CLI so this not just works

00:04:58,080 --> 00:05:03,419
for a single database and a single

00:05:00,210 --> 00:05:06,300
server but this actually allows for

00:05:03,419 --> 00:05:09,900
multi tenant system so that means within

00:05:06,300 --> 00:05:12,780
a single instance you can run a couple

00:05:09,900 --> 00:05:15,150
of different services for example like a

00:05:12,780 --> 00:05:16,800
staging environment or a testing

00:05:15,150 --> 00:05:19,470
environment of production environment or

00:05:16,800 --> 00:05:21,509
if you set this up in your in your own

00:05:19,470 --> 00:05:24,419
infrastructure then you your entire

00:05:21,509 --> 00:05:28,470
company gets access to this and can spin

00:05:24,419 --> 00:05:31,199
up different different apps so let's

00:05:28,470 --> 00:05:33,389
take a quick look and the building

00:05:31,199 --> 00:05:37,110
blocks of how would you you would use

00:05:33,389 --> 00:05:40,289
Prisma so the foundation for a so called

00:05:37,110 --> 00:05:42,870
service a service it Maps like a

00:05:40,289 --> 00:05:46,050
database to an actual graphical API

00:05:42,870 --> 00:05:48,389
which has the foundation of the the data

00:05:46,050 --> 00:05:51,539
model and entry point to all of that is

00:05:48,389 --> 00:05:53,729
your Prisma llaman file that contains a

00:05:51,539 --> 00:05:56,430
bunch of meteor information such as like

00:05:53,729 --> 00:05:59,460
what the service name is which stage

00:05:56,430 --> 00:06:03,419
this on which cluster this running so a

00:05:59,460 --> 00:06:05,460
cluster like or a server just where your

00:06:03,419 --> 00:06:08,070
database lives and where the prisoner

00:06:05,460 --> 00:06:11,220
server in front of it lives and you can

00:06:08,070 --> 00:06:14,159
also set a secret to secure the the

00:06:11,220 --> 00:06:16,070
authentication and it points to your

00:06:14,159 --> 00:06:20,099
data model which is the foundation for

00:06:16,070 --> 00:06:23,130
your for your result in graphical schema

00:06:20,099 --> 00:06:25,889
and the data model aside we we looked at

00:06:23,130 --> 00:06:29,250
it earlier this is where you just use

00:06:25,889 --> 00:06:31,580
plain graphical STL with a couple of

00:06:29,250 --> 00:06:34,440
directives which allow you to specify

00:06:31,580 --> 00:06:37,279
relations or certain constraints and

00:06:34,440 --> 00:06:39,990
this is just a really intuitive way to

00:06:37,279 --> 00:06:40,810
define your data model so whoever has

00:06:39,990 --> 00:06:44,730
like

00:06:40,810 --> 00:06:47,800
and a lot of time like writing long long

00:06:44,730 --> 00:06:49,840
sequel statements to to sort of my grade

00:06:47,800 --> 00:06:52,720
your your database and all of that I

00:06:49,840 --> 00:06:56,110
think that's a really a lot more of an

00:06:52,720 --> 00:06:58,090
expressive way to define your data model

00:06:56,110 --> 00:07:01,950
that even front-end developers can

00:06:58,090 --> 00:07:06,540
understand and work with I'm not kidding

00:07:01,950 --> 00:07:11,590
so based on your data model you get a

00:07:06,540 --> 00:07:13,389
generated graphical API so if we look

00:07:11,590 --> 00:07:16,120
back at our data model here we have a

00:07:13,389 --> 00:07:18,910
type user and a type post so now we get

00:07:16,120 --> 00:07:22,030
an entry point to get all of your users

00:07:18,910 --> 00:07:24,940
you can query the the name you can also

00:07:22,030 --> 00:07:27,850
traverse to the posts and traverse the

00:07:24,940 --> 00:07:29,440
entire relationship here and this you

00:07:27,850 --> 00:07:31,960
cannot just get all of the data but you

00:07:29,440 --> 00:07:35,110
can also filter it so whatever you could

00:07:31,960 --> 00:07:37,810
really Express using a sequel where

00:07:35,110 --> 00:07:40,120
statement or aggregations you can also

00:07:37,810 --> 00:07:42,760
now do this in this in this graphical

00:07:40,120 --> 00:07:45,100
API which the advantage is just the

00:07:42,760 --> 00:07:47,530
tooling is a lot more advanced and it's

00:07:45,100 --> 00:07:51,669
a lot more intuitive and a lot more

00:07:47,530 --> 00:07:53,890
intuitive view on your data and so it

00:07:51,669 --> 00:07:56,400
comes with all sorts of features out of

00:07:53,890 --> 00:07:59,140
box such as transactional mutations

00:07:56,400 --> 00:08:01,530
aggregations the these relational

00:07:59,140 --> 00:08:05,710
filters and even a real-time

00:08:01,530 --> 00:08:09,190
subscription API so to interact with all

00:08:05,710 --> 00:08:12,130
of that you basically use the prism

00:08:09,190 --> 00:08:14,770
Aseel I where it can run Prisma in it to

00:08:12,130 --> 00:08:17,770
set up a new Christmas service you just

00:08:14,770 --> 00:08:19,389
deploy that basically you select a

00:08:17,770 --> 00:08:24,610
cluster where you want to deploy to and

00:08:19,389 --> 00:08:27,100
that migrates your service and the way

00:08:24,610 --> 00:08:31,900
how you would then or how you can

00:08:27,100 --> 00:08:34,719
interact with so generated API is using

00:08:31,900 --> 00:08:36,969
the the playground which CERN already

00:08:34,719 --> 00:08:42,430
presented earlier but we see all of that

00:08:36,969 --> 00:08:43,990
in in the live demo anyway so I saw with

00:08:42,430 --> 00:08:48,279
me do you have a rough understanding

00:08:43,990 --> 00:08:50,290
what what prism is awesome so then let's

00:08:48,279 --> 00:08:52,360
take a look as how you would build a

00:08:50,290 --> 00:08:54,700
graphical server using Prisma

00:08:52,360 --> 00:08:57,190
again you could also use

00:08:54,700 --> 00:08:58,840
directly from your reactor plication or

00:08:57,190 --> 00:09:01,120
your iOS application that connect

00:08:58,840 --> 00:09:03,310
directly but today we want to see how

00:09:01,120 --> 00:09:07,540
you would build your own graphical

00:09:03,310 --> 00:09:09,820
server using prism on so this is

00:09:07,540 --> 00:09:13,510
probably what most of you who have built

00:09:09,820 --> 00:09:16,450
a graphical server are familiar with so

00:09:13,510 --> 00:09:18,790
you define your type definitions your

00:09:16,450 --> 00:09:20,800
schema and then you start implementing

00:09:18,790 --> 00:09:24,130
the actual resolvers for your graphical

00:09:20,800 --> 00:09:26,910
server start that using Express or

00:09:24,130 --> 00:09:31,390
something like that and then you have a

00:09:26,910 --> 00:09:33,550
operating graphical server but let's

00:09:31,390 --> 00:09:37,000
take a look at a bit of a more complex

00:09:33,550 --> 00:09:39,010
example so let's assume this is the

00:09:37,000 --> 00:09:42,370
graphical server this is a graphical

00:09:39,010 --> 00:09:46,270
schema that we want to implement so here

00:09:42,370 --> 00:09:48,280
we have a query called users with was a

00:09:46,270 --> 00:09:51,250
type user that looks like this and a

00:09:48,280 --> 00:09:54,250
typos that looks like this and this

00:09:51,250 --> 00:09:56,680
would be the graph query that we want to

00:09:54,250 --> 00:09:59,260
issue and imagine you're not using

00:09:56,680 --> 00:10:02,440
Prisma but you would want to implement

00:09:59,260 --> 00:10:04,270
that yourself and this is where I need

00:10:02,440 --> 00:10:07,060
to implement resolvers and resolvers are

00:10:04,270 --> 00:10:09,550
really the hard part here so who has

00:10:07,060 --> 00:10:10,570
tried to use graphical in combination

00:10:09,550 --> 00:10:14,130
sequel

00:10:10,570 --> 00:10:16,900
then this is probably looks oh look so

00:10:14,130 --> 00:10:19,870
quite familiar and this is the simple

00:10:16,900 --> 00:10:22,270
case this is like the the case where you

00:10:19,870 --> 00:10:24,220
know like okay this will probably be the

00:10:22,270 --> 00:10:27,250
case where the query that we are

00:10:24,220 --> 00:10:29,880
expecting and if certain other case hits

00:10:27,250 --> 00:10:34,330
and you have like tons of nested if-else

00:10:29,880 --> 00:10:37,780
madness and and so on so that's that's

00:10:34,330 --> 00:10:40,510
quite complex so mapping in general

00:10:37,780 --> 00:10:44,010
between a graphical API and a database

00:10:40,510 --> 00:10:47,500
is quite a difficult task it can be that

00:10:44,010 --> 00:10:50,560
your data model your data model Maps

00:10:47,500 --> 00:10:54,130
quite nicely to your to your graphical

00:10:50,560 --> 00:10:56,470
API and you use something like but

00:10:54,130 --> 00:11:00,460
as soon as you want to really work with

00:10:56,470 --> 00:11:02,770
relational couple capabilities you your

00:11:00,460 --> 00:11:08,110
back to you having to do a lot of manual

00:11:02,770 --> 00:11:10,660
work the case of a sequel database you

00:11:08,110 --> 00:11:13,300
to think about which fields am i

00:11:10,660 --> 00:11:16,480
returning so either you built manually

00:11:13,300 --> 00:11:20,079
build a selection set and you say select

00:11:16,480 --> 00:11:22,510
name from and all of that or you do

00:11:20,079 --> 00:11:23,680
select star we just returned way more

00:11:22,510 --> 00:11:27,010
than you need to

00:11:23,680 --> 00:11:29,079
and in general whoever who has built a

00:11:27,010 --> 00:11:31,450
graphical server probably knows there

00:11:29,079 --> 00:11:34,300
are multiple ways to implement these

00:11:31,450 --> 00:11:36,519
resolvers so either on a root level in

00:11:34,300 --> 00:11:39,339
the first resolver you return just

00:11:36,519 --> 00:11:43,060
everything and kind of hope that other

00:11:39,339 --> 00:11:45,430
at these deeper levels it still maps to

00:11:43,060 --> 00:11:48,190
your graphical schema or you implement

00:11:45,430 --> 00:11:52,209
your resolvers at every layer but that's

00:11:48,190 --> 00:11:55,540
also a lot of work so when we look back

00:11:52,209 --> 00:11:58,269
at this example here what might already

00:11:55,540 --> 00:12:01,860
help and make that a bit loose look less

00:11:58,269 --> 00:12:04,720
scary is if we would be using an ORM

00:12:01,860 --> 00:12:07,779
comes with its own set of trade-offs and

00:12:04,720 --> 00:12:10,779
so on and typically who's built a system

00:12:07,779 --> 00:12:13,899
with a bigger OM probably hit always the

00:12:10,779 --> 00:12:17,350
same point in time where just say okay

00:12:13,899 --> 00:12:20,529
either it gets it it gets to in

00:12:17,350 --> 00:12:22,690
performance or you hit a certain edge

00:12:20,529 --> 00:12:24,940
case that you really cannot express with

00:12:22,690 --> 00:12:27,760
this RM and you go back to to writing

00:12:24,940 --> 00:12:31,870
your own group sequel queries and we're

00:12:27,760 --> 00:12:33,910
back here so but this is where graph KL

00:12:31,870 --> 00:12:36,970
actually gives you a great new

00:12:33,910 --> 00:12:39,790
abstraction over your data so what if

00:12:36,970 --> 00:12:42,220
there was like something like a graph KL

00:12:39,790 --> 00:12:46,180
over m and this is how it would look

00:12:42,220 --> 00:12:49,269
like so it would so now let's let's

00:12:46,180 --> 00:12:52,089
think about implementing a a resolver

00:12:49,269 --> 00:12:55,810
for the type user that returns your your

00:12:52,089 --> 00:12:57,610
posts and this is where it comes back to

00:12:55,810 --> 00:12:59,949
to what CERN already talked about with

00:12:57,610 --> 00:13:02,949
graphical bindings what you here really

00:12:59,949 --> 00:13:05,680
can do is if you have already a

00:13:02,949 --> 00:13:10,570
graphical API for your database that

00:13:05,680 --> 00:13:12,790
maps to your to the graphical schema of

00:13:10,570 --> 00:13:15,010
your server that you want to expose what

00:13:12,790 --> 00:13:19,420
you can here actually do is you can just

00:13:15,010 --> 00:13:20,940
specify how you want to delegate how you

00:13:19,420 --> 00:13:23,340
want to delegate your in

00:13:20,940 --> 00:13:25,710
coming query so what do you really hear

00:13:23,340 --> 00:13:28,170
you're delegating two things so one

00:13:25,710 --> 00:13:31,740
you're rewriting all of the

00:13:28,170 --> 00:13:37,160
sophisticated seek sequel where and so

00:13:31,740 --> 00:13:40,680
on so all of the stuff that we have here

00:13:37,160 --> 00:13:44,910
we we basically pass in here as as

00:13:40,680 --> 00:13:47,760
arguments in this nice typed manner and

00:13:44,910 --> 00:13:49,590
what we've seen before where you say I'm

00:13:47,760 --> 00:13:52,590
interested in a name field and the ID

00:13:49,590 --> 00:13:55,140
and all of these relations all of that

00:13:52,590 --> 00:13:57,330
we don't need to specify here because

00:13:55,140 --> 00:14:01,530
we're making use of schemas stitching

00:13:57,330 --> 00:14:04,440
which is done but this little info

00:14:01,530 --> 00:14:06,090
object here so this info object you

00:14:04,440 --> 00:14:08,100
don't need to know too much about it

00:14:06,090 --> 00:14:11,490
but that's basically an implementation

00:14:08,100 --> 00:14:15,270
detail of how graphical j/s works and

00:14:11,490 --> 00:14:17,940
that contains things like the selection

00:14:15,270 --> 00:14:19,380
set so it just contains like the list of

00:14:17,940 --> 00:14:22,140
all fields that you're interested in

00:14:19,380 --> 00:14:24,600
this contains stuff like if you using

00:14:22,140 --> 00:14:26,370
variables in your graph query that

00:14:24,600 --> 00:14:29,640
contains the variables it just contains

00:14:26,370 --> 00:14:31,680
fragments and all of that and what you

00:14:29,640 --> 00:14:34,110
really just need to do is you just need

00:14:31,680 --> 00:14:36,480
to pass on this info into this graphical

00:14:34,110 --> 00:14:39,990
or m and this figures it out

00:14:36,480 --> 00:14:42,090
so using this sort of syntax that that

00:14:39,990 --> 00:14:43,080
would be really nice that would be quite

00:14:42,090 --> 00:14:46,980
a big step forward

00:14:43,080 --> 00:14:50,910
from from this and this actually works

00:14:46,980 --> 00:14:54,390
so this is based on graphical bindings

00:14:50,910 --> 00:14:56,700
since your rough kill the the database

00:14:54,390 --> 00:14:58,950
it you're accessing is just exposed as a

00:14:56,700 --> 00:15:01,320
graphical API so we can just make use of

00:14:58,950 --> 00:15:03,890
all of the capabilities we have from

00:15:01,320 --> 00:15:05,070
graphical bindings either dynamically or

00:15:03,890 --> 00:15:07,170
statically

00:15:05,070 --> 00:15:09,089
under the hood it's using schema

00:15:07,170 --> 00:15:11,700
stitching to that you don't have to

00:15:09,089 --> 00:15:15,360
write out all of the fields that you

00:15:11,700 --> 00:15:17,220
want and yep essentially just takes in a

00:15:15,360 --> 00:15:19,020
part of your query that's coming in and

00:15:17,220 --> 00:15:22,740
sends it off to your other graphical

00:15:19,020 --> 00:15:25,290
server so the core problem and when it

00:15:22,740 --> 00:15:27,390
comes to in efficiencies of a of an ORM

00:15:25,290 --> 00:15:29,280
is really like not the case here because

00:15:27,390 --> 00:15:31,200
the or M is kind of like you can think

00:15:29,280 --> 00:15:33,420
about it as a synchronous function it

00:15:31,200 --> 00:15:34,800
gives you a nice API where you can

00:15:33,420 --> 00:15:36,660
construct

00:15:34,800 --> 00:15:39,179
whatever data requirements you want to

00:15:36,660 --> 00:15:40,739
express and then you say execute that

00:15:39,179 --> 00:15:43,679
typically do two things

00:15:40,739 --> 00:15:46,139
does two things one it creates a crazy

00:15:43,679 --> 00:15:47,819
unoptimized sequel query sense to your

00:15:46,139 --> 00:15:50,459
database gives you data back and that

00:15:47,819 --> 00:15:52,379
takes forever in this case it just

00:15:50,459 --> 00:15:54,779
propagates the graphical query which

00:15:52,379 --> 00:15:57,540
inherently is not slow or fast this is

00:15:54,779 --> 00:16:00,779
handled by the layer below which you can

00:15:57,540 --> 00:16:04,199
then really optimize so

00:16:00,779 --> 00:16:06,779
benefits I think we we all can agree on

00:16:04,199 --> 00:16:10,049
that the API is a lot more intuitive to

00:16:06,779 --> 00:16:12,290
to work with we've also heard like from

00:16:10,049 --> 00:16:14,819
people that it's like kind of makes a

00:16:12,290 --> 00:16:17,009
sequel database it's not limited to

00:16:14,819 --> 00:16:18,660
sequel database but makes the sequel

00:16:17,009 --> 00:16:22,769
database almost like it's nice to work

00:16:18,660 --> 00:16:26,279
with as a monger API from from the API

00:16:22,769 --> 00:16:29,009
perspective base given that it's based

00:16:26,279 --> 00:16:31,439
on graphical bindings it Maps really

00:16:29,009 --> 00:16:33,689
directly to to your programming language

00:16:31,439 --> 00:16:36,600
this which is especially nice if you're

00:16:33,689 --> 00:16:38,689
using type languages where it gets we

00:16:36,600 --> 00:16:42,029
can literally map all of the

00:16:38,689 --> 00:16:44,939
capabilities of your graphical API to

00:16:42,029 --> 00:16:47,309
your programming language so for those

00:16:44,939 --> 00:16:49,740
of you who are new to graph KL graph KL

00:16:47,309 --> 00:16:52,350
is basically a big type system what

00:16:49,740 --> 00:16:54,019
we've seen before and which comes with

00:16:52,350 --> 00:16:56,699
all of the benefits of a type system

00:16:54,019 --> 00:16:58,259
crutching errors if you have a type of

00:16:56,699 --> 00:17:00,329
somewhere at compile time

00:16:58,259 --> 00:17:02,399
giving you nice auto completion

00:17:00,329 --> 00:17:04,980
functionality all of that what your

00:17:02,399 --> 00:17:07,620
graph get API provides you to you now

00:17:04,980 --> 00:17:13,010
have in your program language which is

00:17:07,620 --> 00:17:15,449
super exciting and it's it's lightweight

00:17:13,010 --> 00:17:19,199
yes we spoke about that if you're using

00:17:15,449 --> 00:17:22,169
aesthetic bindings you get nice item ID

00:17:19,199 --> 00:17:24,569
integrations you get compile time error

00:17:22,169 --> 00:17:27,419
detection which reads as such a small

00:17:24,569 --> 00:17:29,580
thing but that's actually a huge deal if

00:17:27,419 --> 00:17:31,529
you're building big graphical servers

00:17:29,580 --> 00:17:33,450
where we have a little type of somewhere

00:17:31,529 --> 00:17:36,000
which you'd like written in the middle

00:17:33,450 --> 00:17:38,730
of the night and then you get like nice

00:17:36,000 --> 00:17:43,529
red squiggly lines which tells you hey

00:17:38,730 --> 00:17:44,580
you stupid so this is how how it looks

00:17:43,529 --> 00:17:47,130
like

00:17:44,580 --> 00:17:50,490
action so here we're just implementing a

00:17:47,130 --> 00:17:53,519
little example app and you see all the

00:17:50,490 --> 00:17:55,559
nice auto completion here of all of you

00:17:53,519 --> 00:17:58,500
queries that your graph gal acre I give

00:17:55,559 --> 00:18:01,649
you so does this all just through

00:17:58,500 --> 00:18:03,659
through graphical bindings here mapping

00:18:01,649 --> 00:18:05,610
to a prism API all of what you see here

00:18:03,659 --> 00:18:07,860
is not limited to prism at all that you

00:18:05,610 --> 00:18:10,440
can use that for any graph gal like I

00:18:07,860 --> 00:18:11,940
for the github graph gal API Shopify out

00:18:10,440 --> 00:18:14,940
graphical I buy for your own graphical

00:18:11,940 --> 00:18:20,039
micro services was really just just an

00:18:14,940 --> 00:18:22,649
example here so in terms of using it in

00:18:20,039 --> 00:18:26,279
in this scenario is and this is what

00:18:22,649 --> 00:18:29,490
we'll do in the in the demo on a prism

00:18:26,279 --> 00:18:32,279
azide again how it works is you need to

00:18:29,490 --> 00:18:34,409
define your data model you then deploy

00:18:32,279 --> 00:18:37,409
that service which migrates your

00:18:34,409 --> 00:18:40,049
database and gives you a graphical API

00:18:37,409 --> 00:18:43,049
endpoint that you can use directly and

00:18:40,049 --> 00:18:44,970
in your graph get server you just need

00:18:43,049 --> 00:18:47,399
to install the the prism of binding

00:18:44,970 --> 00:18:48,059
package you put in the endpoint that you

00:18:47,399 --> 00:18:50,279
just got

00:18:48,059 --> 00:18:54,380
and then you implement these resolvers

00:18:50,279 --> 00:18:56,460
in the in the way that we saw before a

00:18:54,380 --> 00:19:00,000
typical like if you're building a

00:18:56,460 --> 00:19:02,700
node.js server this is how a project

00:19:00,000 --> 00:19:07,679
could look like on a high level here you

00:19:02,700 --> 00:19:09,510
have an entire folder if you're using

00:19:07,679 --> 00:19:12,200
Prisma you typically have like a

00:19:09,510 --> 00:19:16,260
database folder which contains your

00:19:12,200 --> 00:19:17,789
Prisma Yama file and your data model you

00:19:16,260 --> 00:19:21,240
can also split that up into multiple

00:19:17,789 --> 00:19:25,889
files and you can also see your your

00:19:21,240 --> 00:19:29,309
services if you want then here we've put

00:19:25,889 --> 00:19:31,830
in all of our server files right now

00:19:29,309 --> 00:19:35,130
that's not really split up a lot but you

00:19:31,830 --> 00:19:38,130
can handle this however you want your

00:19:35,130 --> 00:19:41,309
actual data your actual graphical server

00:19:38,130 --> 00:19:44,700
schema you typically express in an own

00:19:41,309 --> 00:19:47,880
graphical file and here we have a couple

00:19:44,700 --> 00:19:51,360
of configuration files package Jason and

00:19:47,880 --> 00:19:55,500
our graphical config which we learned

00:19:51,360 --> 00:19:58,570
about before so let's take a look at

00:19:55,500 --> 00:20:01,570
some of the files more more in detail

00:19:58,570 --> 00:20:03,940
so since one thing when when getting

00:20:01,570 --> 00:20:06,730
started with this is like whoa there are

00:20:03,940 --> 00:20:10,200
a lot of these dot graph corel files so

00:20:06,730 --> 00:20:12,160
what they are they actually about so

00:20:10,200 --> 00:20:15,370
what I have in common

00:20:12,160 --> 00:20:18,490
it's like uses graphical syntax using

00:20:15,370 --> 00:20:20,320
also graphical STL so here data model

00:20:18,490 --> 00:20:23,800
what we've seen before as a foundation

00:20:20,320 --> 00:20:26,080
for your service seed graph Corel you

00:20:23,800 --> 00:20:30,010
can have graphical limitations which are

00:20:26,080 --> 00:20:33,250
just initially executed this Prisma

00:20:30,010 --> 00:20:36,700
graphical file is generated

00:20:33,250 --> 00:20:39,670
automatically which represents the

00:20:36,700 --> 00:20:41,560
Prisma graphical schema that you have so

00:20:39,670 --> 00:20:44,710
this is basically this wouldn't need to

00:20:41,560 --> 00:20:47,100
be here but this is needed for for some

00:20:44,710 --> 00:20:49,750
of the tooling such as graphical import

00:20:47,100 --> 00:20:52,090
when we're using this when we're

00:20:49,750 --> 00:20:58,660
importing some type definitions in our

00:20:52,090 --> 00:21:02,200
actual schema and this is how the graph

00:20:58,660 --> 00:21:05,230
Gale config looks like so here we have

00:21:02,200 --> 00:21:08,770
in a graphical config you have this

00:21:05,230 --> 00:21:10,390
concept of projects so if you have you

00:21:08,770 --> 00:21:13,480
can use this either in a front-end app

00:21:10,390 --> 00:21:16,300
where you have iOS app an Android app

00:21:13,480 --> 00:21:19,990
and you have all of that in a big folder

00:21:16,300 --> 00:21:22,690
or here where we have our database

00:21:19,990 --> 00:21:25,060
project and our actual server app

00:21:22,690 --> 00:21:27,580
project in a graphical configure

00:21:25,060 --> 00:21:31,240
typically have a schema path which links

00:21:27,580 --> 00:21:34,420
to the to this file over here or the

00:21:31,240 --> 00:21:37,450
schema paths for all database and it has

00:21:34,420 --> 00:21:39,520
a cut a bunch of extensions so here

00:21:37,450 --> 00:21:41,710
extensions would get an extension would

00:21:39,520 --> 00:21:43,480
be for the endpoints so this is where

00:21:41,710 --> 00:21:45,700
we're hosting our node based graphical

00:21:43,480 --> 00:21:48,820
server and here we are using the Prisma

00:21:45,700 --> 00:21:50,530
extension which is a shortcut that we

00:21:48,820 --> 00:21:54,970
don't need to write this out where our

00:21:50,530 --> 00:21:57,340
Prisma endpoint action lives um then

00:21:54,970 --> 00:22:00,460
let's take a quick look at of how you

00:21:57,340 --> 00:22:03,570
would use the prism abiding directly in

00:22:00,460 --> 00:22:08,410
your in your server so you would install

00:22:03,570 --> 00:22:11,230
Prisma binding from NPM and what do you

00:22:08,410 --> 00:22:12,169
then would do is you instantiate per

00:22:11,230 --> 00:22:14,779
request

00:22:12,169 --> 00:22:17,359
when she ate a Prisma object that you

00:22:14,779 --> 00:22:18,519
put on the graphical context the context

00:22:17,359 --> 00:22:20,690
is like when you're familiar with

00:22:18,519 --> 00:22:22,159
express middle words you always also

00:22:20,690 --> 00:22:25,399
have like this context object that's

00:22:22,159 --> 00:22:28,179
basically the same thing so here we're

00:22:25,399 --> 00:22:30,320
just creating new Prisma object which

00:22:28,179 --> 00:22:34,850
which just needs to know about the

00:22:30,320 --> 00:22:37,489
endpoint the secret and then you can

00:22:34,850 --> 00:22:40,220
just use it from within your your

00:22:37,489 --> 00:22:42,950
resolvers where on the context you then

00:22:40,220 --> 00:22:46,039
can access your database and you can

00:22:42,950 --> 00:22:47,179
delegate these queries so that's

00:22:46,039 --> 00:22:49,159
essentially it

00:22:47,179 --> 00:22:52,039
what do you need to know about this so

00:22:49,159 --> 00:22:54,739
let's use the the last five to ten

00:22:52,039 --> 00:22:56,960
minutes for a demo i'm in this case i'm

00:22:54,739 --> 00:23:01,580
using the the graphical seal i and the

00:22:56,960 --> 00:23:03,409
create commands which uses there's a

00:23:01,580 --> 00:23:06,139
project called graphical boilerplates

00:23:03,409 --> 00:23:08,419
which is basically for nodejs a type

00:23:06,139 --> 00:23:10,759
script or react it has just like state

00:23:08,419 --> 00:23:12,230
of the art boilerplate projects when you

00:23:10,759 --> 00:23:14,869
want to get started with a new graphical

00:23:12,230 --> 00:23:17,480
project so this is what we can use

00:23:14,869 --> 00:23:20,059
directly with graph girl crate let's

00:23:17,480 --> 00:23:24,919
create a new project that's called

00:23:20,059 --> 00:23:28,580
London I'm using the typescript advanced

00:23:24,919 --> 00:23:31,429
boilerplate so what this is doing it's

00:23:28,580 --> 00:23:34,519
like downloading it already installs all

00:23:31,429 --> 00:23:36,259
of the the the dependencies and in the

00:23:34,519 --> 00:23:38,330
boilerplate itself there is all of the

00:23:36,259 --> 00:23:40,940
configuration already with graphical

00:23:38,330 --> 00:23:43,429
config just that we have something to

00:23:40,940 --> 00:23:47,119
get started with and this is also using

00:23:43,429 --> 00:23:50,450
Prisma under the hood so and to to makes

00:23:47,119 --> 00:23:53,960
getting started easier it already has

00:23:50,450 --> 00:23:56,210
like a default data model and wants to

00:23:53,960 --> 00:23:58,940
deploy it throughout the crowd commands

00:23:56,210 --> 00:24:01,909
so it prompts me here hey please select

00:23:58,940 --> 00:24:06,200
where you want to deploy this to I just

00:24:01,909 --> 00:24:10,149
deploy this here to this cluster oops is

00:24:06,200 --> 00:24:19,869
my the internet is not working let me

00:24:10,149 --> 00:24:19,869
just run it on docker locally seconds

00:24:22,860 --> 00:24:27,450
have some patience with this little

00:24:25,270 --> 00:24:27,450
whale

00:24:41,830 --> 00:24:45,309
one seconds

00:24:50,320 --> 00:25:00,020
there we go all right so let me just

00:24:53,779 --> 00:25:03,200
deploy this one more time and I just

00:25:00,020 --> 00:25:11,320
need to change the the cluster where I

00:25:03,200 --> 00:25:20,649
want to deploy this to so here I just

00:25:11,320 --> 00:25:20,649
change just to local say Prizmo deploy

00:25:23,110 --> 00:25:29,320
so this basically starts this from

00:25:25,940 --> 00:25:32,899
scratch seeds a bit of data generates my

00:25:29,320 --> 00:25:35,450
my graphical schema and spits me out my

00:25:32,899 --> 00:25:41,210
graphical endpoints which I could use

00:25:35,450 --> 00:25:43,690
here directly I just need to now copy

00:25:41,210 --> 00:25:46,909
them in here

00:25:43,690 --> 00:25:51,380
let's I'll show you I'll walk you

00:25:46,909 --> 00:25:54,020
through the setup now so this is fairly

00:25:51,380 --> 00:25:56,090
similar to what we've seen before you

00:25:54,020 --> 00:25:59,090
have database folder which contains the

00:25:56,090 --> 00:26:02,990
data model here we have a user and house

00:25:59,090 --> 00:26:05,210
in the Prisma llamÃ³ file all of the

00:26:02,990 --> 00:26:08,179
media information is configured here

00:26:05,210 --> 00:26:10,580
we're using with we're basing this on

00:26:08,179 --> 00:26:13,190
environment variables so these

00:26:10,580 --> 00:26:18,350
environment variables coming from a dot

00:26:13,190 --> 00:26:20,809
end file so and we we have a bunch of

00:26:18,350 --> 00:26:24,529
seed data that that we that we can get

00:26:20,809 --> 00:26:27,649
started more easily then in the source

00:26:24,529 --> 00:26:30,789
folder we have the foundation for our

00:26:27,649 --> 00:26:33,559
graphical server so here we're using

00:26:30,789 --> 00:26:36,590
yoga to start a new graphical server

00:26:33,559 --> 00:26:39,440
which uses this schema here the schema

00:26:36,590 --> 00:26:43,309
is very simple here we have our we have

00:26:39,440 --> 00:26:45,679
a feed query we have drafts we have a

00:26:43,309 --> 00:26:49,909
pose and we have me as an authenticated

00:26:45,679 --> 00:26:53,299
user and the actual posts that the

00:26:49,909 --> 00:26:58,159
actual post type we import

00:26:53,299 --> 00:27:00,350
from our generated Prisma graphical here

00:26:58,159 --> 00:27:02,179
the graphical convict already as we

00:27:00,350 --> 00:27:04,700
looked at before we have we just

00:27:02,179 --> 00:27:07,940
configured the the graphical server app

00:27:04,700 --> 00:27:11,659
and the database here we configure the

00:27:07,940 --> 00:27:14,869
schema path and what's what's important

00:27:11,659 --> 00:27:17,239
here is we generate we configure how we

00:27:14,869 --> 00:27:20,919
want to generate a static graphical

00:27:17,239 --> 00:27:25,820
binding so this basically just points to

00:27:20,919 --> 00:27:28,789
where the binding file should be should

00:27:25,820 --> 00:27:30,590
be saved up and we are saying okay we

00:27:28,789 --> 00:27:34,009
want to use the typescript Prisma

00:27:30,590 --> 00:27:36,619
generator so let's take a quick look

00:27:34,009 --> 00:27:38,649
again this is the entry point for for

00:27:36,619 --> 00:27:41,059
our server let's take a quick look at

00:27:38,649 --> 00:27:43,519
how some of these resolvers are

00:27:41,059 --> 00:27:46,639
implemented so let's take a look at the

00:27:43,519 --> 00:27:49,100
query resolver the query resolver looks

00:27:46,639 --> 00:27:52,279
something like this we have for a feed

00:27:49,100 --> 00:27:55,489
query we just delegate to the posts to

00:27:52,279 --> 00:27:59,539
the published posts and we have also a

00:27:55,489 --> 00:28:02,210
drafts query which delegates to also

00:27:59,539 --> 00:28:04,820
some posts but the unpublished posts

00:28:02,210 --> 00:28:08,359
which belong to me as an authenticated

00:28:04,820 --> 00:28:12,889
user so I would suggest let's just take

00:28:08,359 --> 00:28:15,950
a look of how that works in in action so

00:28:12,889 --> 00:28:19,220
what I can just do is I can run yarn def

00:28:15,950 --> 00:28:24,139
which starts the webserver and it starts

00:28:19,220 --> 00:28:27,889
up my graphical playground let's make

00:28:24,139 --> 00:28:31,369
that big bigger so what we can you all

00:28:27,889 --> 00:28:33,649
see it perfect so let's explore the

00:28:31,369 --> 00:28:40,090
schema here you can see okay we have

00:28:33,649 --> 00:28:43,309
feed for a feed we have 1/2 a D title

00:28:40,090 --> 00:28:45,769
and the text so let's just query that

00:28:43,309 --> 00:28:50,539
and this is some data that has been

00:28:45,769 --> 00:28:54,230
seeded let's also try out the drafts

00:28:50,539 --> 00:28:59,409
let's try that whoops we get not

00:28:54,230 --> 00:29:02,179
authorized so which is sort of expected

00:28:59,409 --> 00:29:05,659
because this implementation looks like

00:29:02,179 --> 00:29:06,830
this that it asks for the user ID which

00:29:05,659 --> 00:29:09,710
checks oh do

00:29:06,830 --> 00:29:13,970
we have an authorization header set if

00:29:09,710 --> 00:29:22,360
not throw an error so we just quickly

00:29:13,970 --> 00:29:27,370
need to sign us up email test tests come

00:29:22,360 --> 00:29:27,370
no time for good code style here and

00:29:27,669 --> 00:29:42,830
name and guess let's back it the the

00:29:37,220 --> 00:29:46,639
token can just get the token here let's

00:29:42,830 --> 00:29:48,470
set them as an HTTP header - if you want

00:29:46,639 --> 00:29:52,429
to try out prism on you can just install

00:29:48,470 --> 00:29:57,440
it like that from from NPM run Prisma in

00:29:52,429 --> 00:30:00,620
it and yeah on Prisma graph girl.com you

00:29:57,440 --> 00:30:04,309
you should also find some some resources

00:30:00,620 --> 00:30:06,620
and tutorials to get started a couple of

00:30:04,309 --> 00:30:10,039
notes so on Prisma right now we're

00:30:06,620 --> 00:30:13,580
supporting my sequel which you can also

00:30:10,039 --> 00:30:15,289
use with a SS Aurora but over time we're

00:30:13,580 --> 00:30:17,929
gonna add more and more support for all

00:30:15,289 --> 00:30:20,600
sorts of databases Postgres is one of

00:30:17,929 --> 00:30:23,570
one of the next ones but also among

00:30:20,600 --> 00:30:25,720
would be DynamoDB so we really want to

00:30:23,570 --> 00:30:28,789
enable you to use graph KL as a

00:30:25,720 --> 00:30:32,090
universal Curie language for all sorts

00:30:28,789 --> 00:30:34,220
of databases and it will also be

00:30:32,090 --> 00:30:40,610
impossible then you can use it with your

00:30:34,220 --> 00:30:42,590
existing database right so it's already

00:30:40,610 --> 00:30:45,710
a chart and certain set would be really

00:30:42,590 --> 00:30:49,220
awesome to to see some of you at this

00:30:45,710 --> 00:30:52,220
year's graphical conference we have yeah

00:30:49,220 --> 00:30:54,409
pretty much everybody off the graph gale

00:30:52,220 --> 00:30:57,350
core team from Facebook there with the

00:30:54,409 --> 00:30:59,120
guys from Apollo there and we have some

00:30:57,350 --> 00:31:03,500
fantastic speakers that are flying over

00:30:59,120 --> 00:31:05,659
from Australia Asia and last year was

00:31:03,500 --> 00:31:10,340
already awesome so I kind of wait for

00:31:05,659 --> 00:31:11,630
this year certain I gonna be around for

00:31:10,340 --> 00:31:13,340
the rest of the evening I think we're

00:31:11,630 --> 00:31:16,220
also gonna grab some beer with some of

00:31:13,340 --> 00:31:17,960
you if you if you're interested and yeah

00:31:16,220 --> 00:31:20,020
thanks

00:31:17,960 --> 00:31:20,020

YouTube URL: https://www.youtube.com/watch?v=ziETMDEJdUI


