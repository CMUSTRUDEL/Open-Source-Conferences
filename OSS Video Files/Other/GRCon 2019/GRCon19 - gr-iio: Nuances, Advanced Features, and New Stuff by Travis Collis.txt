Title: GRCon19 - gr-iio: Nuances, Advanced Features, and New Stuff by Travis Collis
Publication date: 2019-11-05
Playlist: GRCon 2019
Description: 
	gr-iio: Nuances, Advanced Features, and New Stuff by Travis Collis

In this presentation, we will discuss the current out-of-tree module gr-iio which enables data streaming and control of any device with an Industrial Input/Output (IIO) kernel driver. The module not only supports SDRs like ADALM-PLUTO and USRP-E310 today but also provides access to hundreds of sensor devices and even gigasample converters using the standard kernel framework.

We will provide a basic introduction to gr-iio and IIO for new users. We will also discuss how the standard blocks can be extended using the new Attribute blocks. This will focus on advanced features of the controlling drivers for AD936X based radios, as well as new enhancements made to current blocks. For advanced users, we will demonstrate how gr-iio can be used to interact with deployed IP on an FPGA, which will be done using an ADALM-PLUTO. This demonstration will examine controlling the frequency hopping features of the AD9363 transceiver using custom IP and controlling IIO driver. Finally, we will discuss merging gr-iio into mainline GNU Radio to allow simplified adoption for end users.
Captions: 
	00:00:16,490 --> 00:00:22,380
hi everyone my name is Travis Collins or

00:00:19,350 --> 00:00:24,720
with analog devices so just a little

00:00:22,380 --> 00:00:27,060
background on myself I've been a radio

00:00:24,720 --> 00:00:29,189
user for about say ten years now I

00:00:27,060 --> 00:00:32,400
remember the days of like using

00:00:29,189 --> 00:00:35,580
bootstrap and for the this whole see

00:00:32,400 --> 00:00:39,690
make overhaul back at my masters and PhD

00:00:35,580 --> 00:00:42,629
days and about two years ago or three

00:00:39,690 --> 00:00:46,640
years ago now I joined Adi and I took

00:00:42,629 --> 00:00:50,820
over the GRI o or the i/o interfaces

00:00:46,640 --> 00:00:54,329
from Paul and I've kind of continued the

00:00:50,820 --> 00:00:56,160
the great work that he's done and in the

00:00:54,329 --> 00:00:59,129
presentation I'm just gonna give kind of

00:00:56,160 --> 00:01:00,899
an intro to IO and how the kernel

00:00:59,129 --> 00:01:04,470
framework that we use to develop drivers

00:01:00,899 --> 00:01:06,119
works the library that we use to talk to

00:01:04,470 --> 00:01:09,630
those drivers and then how can you radio

00:01:06,119 --> 00:01:11,250
interfaces with that library then I'm

00:01:09,630 --> 00:01:13,890
going to talk a little bit about some of

00:01:11,250 --> 00:01:15,390
the libido isms that might exist that

00:01:13,890 --> 00:01:18,420
might be a little confusing or has been

00:01:15,390 --> 00:01:21,810
confusing traditionally for users how

00:01:18,420 --> 00:01:24,060
you can use libido and gr and GRI o to

00:01:21,810 --> 00:01:26,490
access custom IP that might exist in

00:01:24,060 --> 00:01:28,710
your fpga we'll talk a little bit about

00:01:26,490 --> 00:01:30,720
io performance some of the current state

00:01:28,710 --> 00:01:33,720
of live io and some of the new things

00:01:30,720 --> 00:01:36,330
that we're working on then I want to

00:01:33,720 --> 00:01:38,549
talk about some new features in ER IO

00:01:36,330 --> 00:01:40,470
that are kind of in progress and should

00:01:38,549 --> 00:01:44,579
be merged soon so if you have a Pluto or

00:01:40,470 --> 00:01:46,680
and columns or an ARV these really apply

00:01:44,579 --> 00:01:49,439
to you and then finally I just want to

00:01:46,680 --> 00:01:52,170
talk about the GRI yo grep that we have

00:01:49,439 --> 00:01:55,470
the enhancement proposal to merge GRI o

00:01:52,170 --> 00:01:57,930
into mainline just to make it easier for

00:01:55,470 --> 00:01:59,840
everyone to use and just kind of the

00:01:57,930 --> 00:02:02,820
activity that's going on there

00:01:59,840 --> 00:02:06,180
okay let's kind of get into the basics

00:02:02,820 --> 00:02:06,630
of IO and low bio now if you're not

00:02:06,180 --> 00:02:08,820
familiar

00:02:06,630 --> 00:02:10,799
uh-oh stands for word the industrial

00:02:08,820 --> 00:02:13,410
input-output framework this is a kernel

00:02:10,799 --> 00:02:16,290
framework that's designed for generic

00:02:13,410 --> 00:02:19,680
ADCs DACs sensors kind of things that

00:02:16,290 --> 00:02:21,180
don't fit into htw mon or the input

00:02:19,680 --> 00:02:23,550
framework which is for like keyboard

00:02:21,180 --> 00:02:25,770
mice that kind of thing so it's kind of

00:02:23,550 --> 00:02:27,630
perfect for the devices that Adi works

00:02:25,770 --> 00:02:31,200
on but this is not

00:02:27,630 --> 00:02:36,210
adi only thing our competitors other

00:02:31,200 --> 00:02:37,980
vendors have tons of io drivers from you

00:02:36,210 --> 00:02:40,890
know temperature sensors pressure

00:02:37,980 --> 00:02:42,510
sensors all kinds of things and the GR

00:02:40,890 --> 00:02:46,770
io blocks kind of allow you to access

00:02:42,510 --> 00:02:50,040
all kinds of different devices so it's

00:02:46,770 --> 00:02:52,140
not just STRs it's like I am use its

00:02:50,040 --> 00:02:55,080
temperature sensors you can control

00:02:52,140 --> 00:02:58,530
amplifiers or generic IP using io

00:02:55,080 --> 00:03:01,050
drivers and you know well pretty much

00:02:58,530 --> 00:03:03,090
focus on STRs because that's kind of the

00:03:01,050 --> 00:03:05,940
most interest in in this this community

00:03:03,090 --> 00:03:09,810
here and we have drivers for obviously

00:03:05,940 --> 00:03:10,500
like our products like Pluto and the is

00:03:09,810 --> 00:03:14,910
ready on the right

00:03:10,500 --> 00:03:17,340
this the guy here blue as part of a kit

00:03:14,910 --> 00:03:19,710
we call pack RF as well as we support

00:03:17,340 --> 00:03:22,820
even third party radios like the

00:03:19,710 --> 00:03:25,260
sidekick here and even the Odyssey 310

00:03:22,820 --> 00:03:27,450
we have actually a full SD card that

00:03:25,260 --> 00:03:29,130
works on that product and you get audio

00:03:27,450 --> 00:03:33,540
support and it controls even the

00:03:29,130 --> 00:03:34,920
external filter banks now the big

00:03:33,540 --> 00:03:38,430
question is how do you go from that I

00:03:34,920 --> 00:03:40,140
owed driver into can your radio and this

00:03:38,430 --> 00:03:42,440
is what I'm gonna try to break down for

00:03:40,140 --> 00:03:46,890
you so you understand it a little bit

00:03:42,440 --> 00:03:48,450
now there are I'm just gonna start at

00:03:46,890 --> 00:03:50,820
the driver level first and we'll kind of

00:03:48,450 --> 00:03:53,190
talk about how the i/o pieces come into

00:03:50,820 --> 00:03:55,650
play there's a lot of complexity and

00:03:53,190 --> 00:03:59,070
chips for example this is kind of the

00:03:55,650 --> 00:04:00,870
simplified diagram of the 93-60 one the

00:03:59,070 --> 00:04:02,400
part has over a thousand registers a lot

00:04:00,870 --> 00:04:06,209
of state that you need to maintain and

00:04:02,400 --> 00:04:07,709
we do this through an i/o driver and you

00:04:06,209 --> 00:04:09,060
know you can't just connect the USB and

00:04:07,709 --> 00:04:10,709
magically it works there's a lot of

00:04:09,060 --> 00:04:14,459
pieces that happen in the back end in

00:04:10,709 --> 00:04:19,470
the in the FPGA in the arm where the

00:04:14,459 --> 00:04:21,660
driver lives to make the part work now a

00:04:19,470 --> 00:04:23,460
more kind of appropriate perspective to

00:04:21,660 --> 00:04:26,220
have is more like a system level guide

00:04:23,460 --> 00:04:27,690
where we have a physical piece of

00:04:26,220 --> 00:04:31,710
hardware on the right so like a

00:04:27,690 --> 00:04:34,650
transceiver 93-60 one in this case Zink

00:04:31,710 --> 00:04:37,890
where we have the programmable logic and

00:04:34,650 --> 00:04:40,020
then the PS here the arm which is

00:04:37,890 --> 00:04:40,900
running Linux and then the far right we

00:04:40,020 --> 00:04:43,420
have a

00:04:40,900 --> 00:04:45,340
a host machine that's running your radio

00:04:43,420 --> 00:04:47,260
or some other application that we want

00:04:45,340 --> 00:04:49,810
to interface the radio or some other

00:04:47,260 --> 00:04:52,180
device but generally this doesn't have

00:04:49,810 --> 00:04:54,310
to be a transceiver here on the left it

00:04:52,180 --> 00:04:58,690
could be a sensor or a generic device

00:04:54,310 --> 00:05:01,720
that has an i/o driver now IO has this

00:04:58,690 --> 00:05:03,730
very hierarchical structure so at the

00:05:01,720 --> 00:05:05,890
top we have this concept called contexts

00:05:03,730 --> 00:05:09,190
and context can be local they can be

00:05:05,890 --> 00:05:10,360
remotes and a context will be I say the

00:05:09,190 --> 00:05:12,460
best way to think about it is like a

00:05:10,360 --> 00:05:14,680
board or a laptop can actually be a

00:05:12,460 --> 00:05:17,950
context and a context will have devices

00:05:14,680 --> 00:05:21,280
that are associated with it so on Pluto

00:05:17,950 --> 00:05:23,500
you'll see devices that are the

00:05:21,280 --> 00:05:25,060
transmitter the receiver the Phi which

00:05:23,500 --> 00:05:29,650
is kind of like the overarching driver

00:05:25,060 --> 00:05:32,620
as well as a power monitoring chip the

00:05:29,650 --> 00:05:35,170
ADM 1177 you'll see here we had just

00:05:32,620 --> 00:05:37,830
have an example of what may be a like I

00:05:35,170 --> 00:05:39,700
am you might show up as where we have

00:05:37,830 --> 00:05:40,960
attributes that are associated with it

00:05:39,700 --> 00:05:43,240
so the device itself will have

00:05:40,960 --> 00:05:46,210
attributes like sample rate or more kind

00:05:43,240 --> 00:05:48,580
of complicated attributes that you might

00:05:46,210 --> 00:05:50,200
not want to play with at all times where

00:05:48,580 --> 00:05:53,980
they're called debug attributes they're

00:05:50,200 --> 00:05:55,930
not really for runtime or common uses

00:05:53,980 --> 00:05:57,760
and then when we want to deal with

00:05:55,930 --> 00:06:02,110
buffers or point data back from the

00:05:57,760 --> 00:06:04,840
device from like a converter then we

00:06:02,110 --> 00:06:06,490
have these these buffers and these

00:06:04,840 --> 00:06:08,380
channels and they have attributes

00:06:06,490 --> 00:06:10,690
associated with them like the length of

00:06:08,380 --> 00:06:12,670
data the type of the data the scientist

00:06:10,690 --> 00:06:16,990
of the data and this is how we can

00:06:12,670 --> 00:06:21,220
describe a very different number of

00:06:16,990 --> 00:06:23,470
devices so if you want to interface

00:06:21,220 --> 00:06:26,080
directly with the i/o driver you can go

00:06:23,470 --> 00:06:26,980
through the sisyphus API you can log in

00:06:26,080 --> 00:06:30,610
to say Pluto

00:06:26,980 --> 00:06:33,160
you go to sis bus IO device zero and

00:06:30,610 --> 00:06:35,620
you'll see a number of file descriptors

00:06:33,160 --> 00:06:37,390
there so they'll be like name which will

00:06:35,620 --> 00:06:38,680
be a device attribute and they'll you'll

00:06:37,390 --> 00:06:40,060
see some that are like hardware gain

00:06:38,680 --> 00:06:42,490
which will be channel attributes and

00:06:40,060 --> 00:06:44,860
these allow you to directly interface or

00:06:42,490 --> 00:06:47,500
control different parts of the hardware

00:06:44,860 --> 00:06:50,260
so here at the bottom we're simply using

00:06:47,500 --> 00:06:52,510
cats to pull out the name and then we're

00:06:50,260 --> 00:06:53,800
echoing a value into Hardware gain and

00:06:52,510 --> 00:06:55,300
we're pulling that out and

00:06:53,800 --> 00:06:57,310
getting the actual hardware game that's

00:06:55,300 --> 00:06:59,889
written to the device and IO is designed

00:06:57,310 --> 00:07:03,879
to be friendly to the user so it

00:06:59,889 --> 00:07:06,340
provides data in scientific units or

00:07:03,879 --> 00:07:10,770
relative units so you'll get data back

00:07:06,340 --> 00:07:14,620
in like bolts amps DB things like that

00:07:10,770 --> 00:07:17,440
so going back to that that system level

00:07:14,620 --> 00:07:19,120
framework here we have that driver that

00:07:17,440 --> 00:07:20,919
i/o driver that's specific to a device

00:07:19,120 --> 00:07:23,560
that lives in the kernel that's running

00:07:20,919 --> 00:07:25,210
in the arm on board and you can interact

00:07:23,560 --> 00:07:30,009
with it directly through the system

00:07:25,210 --> 00:07:32,530
facet API now you know using sisyphus is

00:07:30,009 --> 00:07:34,449
great for Colonel Dreyer developers but

00:07:32,530 --> 00:07:36,370
when I want to change the gain of my

00:07:34,449 --> 00:07:38,379
radio and I have to SSH into the board

00:07:36,370 --> 00:07:42,250
and cat and echo some something in and

00:07:38,379 --> 00:07:44,080
out that's not really great and when

00:07:42,250 --> 00:07:47,139
you're using a device as complicated as

00:07:44,080 --> 00:07:49,090
the 9th or 61 you have to set you know

00:07:47,139 --> 00:07:53,229
tons and tons of attributes and that's

00:07:49,090 --> 00:07:55,750
really no fun as a result this library

00:07:53,229 --> 00:07:57,400
that was designed for interfacing with

00:07:55,750 --> 00:08:00,909
these attributes was developed this is

00:07:57,400 --> 00:08:03,340
called low bio or adalah bio and it's a

00:08:00,909 --> 00:08:09,279
C API where we have a number of bindings

00:08:03,340 --> 00:08:12,370
for C++ C sharp Python MATLAB and you

00:08:09,279 --> 00:08:13,960
can interface a lot more easily with

00:08:12,370 --> 00:08:15,460
these attributes and it handles things

00:08:13,960 --> 00:08:17,889
like buffer maintenance and things like

00:08:15,460 --> 00:08:19,479
that and error handling and it makes it

00:08:17,889 --> 00:08:24,460
a lot simpler to interact for the

00:08:19,479 --> 00:08:26,879
devices now if we kind of go back to

00:08:24,460 --> 00:08:29,469
that picture now we have this low bio

00:08:26,879 --> 00:08:31,990
library that's living on the board and

00:08:29,469 --> 00:08:34,180
this is calling in to the i/o driver

00:08:31,990 --> 00:08:35,849
that's in the kernel and then that is

00:08:34,180 --> 00:08:37,659
talking to the physical chip itself

00:08:35,849 --> 00:08:38,890
technically you can't run it in your

00:08:37,659 --> 00:08:41,079
radio on the board

00:08:38,890 --> 00:08:42,940
and we do this in our standard SD cards

00:08:41,079 --> 00:08:48,010
for our FM coms boards that come with

00:08:42,940 --> 00:08:50,260
like a CC 706 or a CCD 102 some people

00:08:48,010 --> 00:08:52,570
have got it to work on pluto but the

00:08:50,260 --> 00:08:55,149
conclusion that they came to was like

00:08:52,570 --> 00:08:57,790
this was interesting but don't do it

00:08:55,149 --> 00:09:01,740
it's not a great experience when you

00:08:57,790 --> 00:09:05,529
have a single core arm at 666 megahertz

00:09:01,740 --> 00:09:06,940
now the question is you know this is

00:09:05,529 --> 00:09:09,790
great for an embedded platform

00:09:06,940 --> 00:09:14,140
but how can i interact with widow from

00:09:09,790 --> 00:09:16,360
my host machine and to do that Luo has

00:09:14,140 --> 00:09:19,000
this concept of backends and backends

00:09:16,360 --> 00:09:21,370
allow you to directly remote into a

00:09:19,000 --> 00:09:22,930
board or use the same Luo bio API on

00:09:21,370 --> 00:09:24,940
your host machine and talk to the device

00:09:22,930 --> 00:09:26,950
this is kind of like an RPC if you're

00:09:24,940 --> 00:09:29,920
familiar with that concept

00:09:26,950 --> 00:09:32,440
if you look on Pluto or any of our

00:09:29,920 --> 00:09:34,030
standard eval boards and you just look

00:09:32,440 --> 00:09:35,770
at a look at the processes you'll see

00:09:34,030 --> 00:09:38,320
this little process called IOD that's

00:09:35,770 --> 00:09:40,960
running and that's responsible for doing

00:09:38,320 --> 00:09:42,760
this translation for you so if we look

00:09:40,960 --> 00:09:44,230
physically at how this is kind of laid

00:09:42,760 --> 00:09:46,620
out where we have a machine on the right

00:09:44,230 --> 00:09:49,570
here the development board on the Left

00:09:46,620 --> 00:09:51,370
we have live i/o on the right and it's

00:09:49,570 --> 00:09:53,740
calling over the network to that little

00:09:51,370 --> 00:09:57,060
I Oh D daemon and that's doing the

00:09:53,740 --> 00:09:59,320
rights to the part through blue bio okay

00:09:57,060 --> 00:10:02,140
we do support a number of different

00:09:59,320 --> 00:10:05,920
backends from Ethernet serial like USB

00:10:02,140 --> 00:10:07,210
PCIe a number of different options that

00:10:05,920 --> 00:10:09,820
you have depending on the bandwidth that

00:10:07,210 --> 00:10:14,230
you need or the simplicity that you need

00:10:09,820 --> 00:10:17,590
or the board that you have and this is

00:10:14,230 --> 00:10:19,240
what's applications like gr IO are using

00:10:17,590 --> 00:10:21,940
this is what mal abuses to talk to the

00:10:19,240 --> 00:10:24,100
device this is what gr QX is using

00:10:21,940 --> 00:10:25,780
that's your angel all these open source

00:10:24,100 --> 00:10:29,760
projects if they want to talk to sudo

00:10:25,780 --> 00:10:31,780
they're using live i/o under the hood

00:10:29,760 --> 00:10:33,610
now this that kind of completes the

00:10:31,780 --> 00:10:37,210
picture for us just to quickly go over

00:10:33,610 --> 00:10:39,250
that again from the chip that's

00:10:37,210 --> 00:10:42,790
interfaced through the FPGA which has

00:10:39,250 --> 00:10:45,010
the i/o driver which we'll pull will be

00:10:42,790 --> 00:10:46,900
talk to you through live i/o which is

00:10:45,010 --> 00:10:48,250
that interface with IOD that little

00:10:46,900 --> 00:10:52,270
daemon and then that will do the

00:10:48,250 --> 00:10:54,250
translation from the network or USB from

00:10:52,270 --> 00:10:55,810
live io that's on your host and this is

00:10:54,250 --> 00:11:00,280
how we're moving data back and forth and

00:10:55,810 --> 00:11:02,260
controlling the device okay but the

00:11:00,280 --> 00:11:04,510
great thing about this is it's it's very

00:11:02,260 --> 00:11:06,880
transparent to the host machine so this

00:11:04,510 --> 00:11:09,370
could be a pluto it could be one of our

00:11:06,880 --> 00:11:12,700
ssam boards it could be a more

00:11:09,370 --> 00:11:16,120
traditional FMC card that's connected to

00:11:12,700 --> 00:11:16,690
an eval board like a 706 dead board that

00:11:16,120 --> 00:11:18,670
kind of thing

00:11:16,690 --> 00:11:19,860
and you don't have to have a transceiver

00:11:18,670 --> 00:11:22,589
on the left

00:11:19,860 --> 00:11:28,470
be a standard sensor or some other

00:11:22,589 --> 00:11:30,089
device that has an i/o driver okay but

00:11:28,470 --> 00:11:31,560
like any good library it has standard

00:11:30,089 --> 00:11:33,600
command-line tools so if you want to

00:11:31,560 --> 00:11:35,670
change say the sample rate or the yellow

00:11:33,600 --> 00:11:38,130
frequency or some device attribute you

00:11:35,670 --> 00:11:40,459
can directly do that you can directly

00:11:38,130 --> 00:11:42,450
access registers if you want to do that

00:11:40,459 --> 00:11:45,269
so you have a number of command-line

00:11:42,450 --> 00:11:47,670
tools from directly accessing attributes

00:11:45,269 --> 00:11:49,500
finding devices on the network reading

00:11:47,670 --> 00:11:51,510
and writing from buffers if you want to

00:11:49,500 --> 00:11:54,180
get really low level on the device you

00:11:51,510 --> 00:11:56,010
can do that with these tools but if you

00:11:54,180 --> 00:11:57,660
want to crank it up a little bit and you

00:11:56,010 --> 00:11:58,709
don't pull some data visualize that we

00:11:57,660 --> 00:12:01,740
do have a completely open-source

00:11:58,709 --> 00:12:03,180
application called i/o scope it has this

00:12:01,740 --> 00:12:05,010
plugin concept so you can add other

00:12:03,180 --> 00:12:07,410
devices if you have a custom board if

00:12:05,010 --> 00:12:08,880
you have your own io drivers they'll

00:12:07,410 --> 00:12:12,720
find them in i/o scope and you can add

00:12:08,880 --> 00:12:15,390
your own plug-ins for those boards okay

00:12:12,720 --> 00:12:18,000
now let's talk a little bit about the

00:12:15,390 --> 00:12:20,720
new radio interface when you install GRE

00:12:18,000 --> 00:12:24,329
o it will come with a number of blocks

00:12:20,720 --> 00:12:26,250
these are STR spacer blocks device

00:12:24,329 --> 00:12:28,920
generic blocks so if you have your own

00:12:26,250 --> 00:12:30,959
IO device you can use our generic blocks

00:12:28,920 --> 00:12:33,480
for that we have attribute blocks which

00:12:30,959 --> 00:12:35,370
are used for accessing device debug

00:12:33,480 --> 00:12:38,070
registers if you want to do that

00:12:35,370 --> 00:12:39,660
directly from your radio and then we

00:12:38,070 --> 00:12:43,140
have these kind of extra ones these

00:12:39,660 --> 00:12:45,390
these math blocks and these are actually

00:12:43,140 --> 00:12:47,070
part of scope II that are run under the

00:12:45,390 --> 00:12:48,980
hood so Adrienne talked about scope

00:12:47,070 --> 00:12:51,029
yesterday about how we use can you radio

00:12:48,980 --> 00:12:53,790
how we use flow graphs out of the hood

00:12:51,029 --> 00:12:56,220
and that's why those blocks exist inside

00:12:53,790 --> 00:12:59,310
your eye oh but they're actually super

00:12:56,220 --> 00:13:01,380
useful for other things besides a kind

00:12:59,310 --> 00:13:03,570
of instrumentation you can do generic

00:13:01,380 --> 00:13:08,370
kind of functional math inside those

00:13:03,570 --> 00:13:10,890
blocks now the blocks themselves have

00:13:08,370 --> 00:13:13,920
this inheritance structure at the base

00:13:10,890 --> 00:13:15,720
we always have a very basic block so we

00:13:13,920 --> 00:13:19,230
have our i/o device source block for

00:13:15,720 --> 00:13:21,899
source devices and then our FM coms to

00:13:19,230 --> 00:13:23,760
simply inherits from that device and

00:13:21,899 --> 00:13:26,040
then Pluto is really just a subset of

00:13:23,760 --> 00:13:27,180
our original iPhone comm sports and if

00:13:26,040 --> 00:13:28,740
you look at the code you'll see that

00:13:27,180 --> 00:13:30,829
it's just simply inheriting there's not

00:13:28,740 --> 00:13:34,200
a lot of duplication all over the place

00:13:30,829 --> 00:13:36,300
and since these io device stores

00:13:34,200 --> 00:13:37,920
those are so generic you can actually

00:13:36,300 --> 00:13:40,350
create your own versions of these blocks

00:13:37,920 --> 00:13:43,050
I kind of do that all the time for debug

00:13:40,350 --> 00:13:45,900
and test people have created them for

00:13:43,050 --> 00:13:47,790
other third party radios I know a number

00:13:45,900 --> 00:13:50,160
of users that have done that for the

00:13:47,790 --> 00:13:55,680
psychic radios that are using our pluto

00:13:50,160 --> 00:13:57,390
images on those devices now a kind of a

00:13:55,680 --> 00:14:02,040
confusing topic that comes up all the

00:13:57,390 --> 00:14:02,780
time is how do I set contexts within the

00:14:02,040 --> 00:14:05,700
i/o blocks

00:14:02,780 --> 00:14:07,830
so again contexts are how we address a

00:14:05,700 --> 00:14:11,430
device and they can be local they can be

00:14:07,830 --> 00:14:15,030
remote but setting it can be kind of a

00:14:11,430 --> 00:14:17,700
mystery to some people now the context

00:14:15,030 --> 00:14:20,010
or the the context is addressed what we

00:14:17,700 --> 00:14:21,930
call a URI which is simply a address

00:14:20,010 --> 00:14:25,470
that you use to talk to the device and

00:14:21,930 --> 00:14:28,110
it's structured by the protocol and then

00:14:25,470 --> 00:14:31,520
the address so for IP of the IP and the

00:14:28,110 --> 00:14:34,650
address USB the USB and then the

00:14:31,520 --> 00:14:37,770
actually the address given out by live

00:14:34,650 --> 00:14:40,440
USB and if you're physically on a board

00:14:37,770 --> 00:14:44,210
or you have local i/o devices you can

00:14:40,440 --> 00:14:46,770
simply use local on my Linux laptop the

00:14:44,210 --> 00:14:49,470
the gyroscope inside it actually shows

00:14:46,770 --> 00:14:51,210
up as an i/o device and I can pull that

00:14:49,470 --> 00:14:52,680
right into iOS cope I can pull that

00:14:51,210 --> 00:14:54,660
device into can do radio and I can look

00:14:52,680 --> 00:14:56,510
at the gyroscope data as I rotate my

00:14:54,660 --> 00:14:59,510
keyboard which is a pretty interesting

00:14:56,510 --> 00:15:01,980
now there are some kind of special

00:14:59,510 --> 00:15:06,560
things that you can use inside the or

00:15:01,980 --> 00:15:09,470
inside the radio blocks for URI if you

00:15:06,560 --> 00:15:12,570
leave it blank it will do auto discovery

00:15:09,470 --> 00:15:16,260
for Pluto if you leave a blank it will

00:15:12,570 --> 00:15:18,840
just pick up the device automatically so

00:15:16,260 --> 00:15:21,770
this doesn't work if you don't set a

00:15:18,840 --> 00:15:26,610
specific global attribute or a global

00:15:21,770 --> 00:15:29,670
variable for network devices however you

00:15:26,610 --> 00:15:31,860
can simply put IP and the hostname of

00:15:29,670 --> 00:15:34,770
your board so for us our standard boards

00:15:31,860 --> 00:15:38,250
are analog that's the host name Pluto is

00:15:34,770 --> 00:15:39,870
Pluto local and when you fill that in it

00:15:38,250 --> 00:15:41,310
will use of aji under the hood if you

00:15:39,870 --> 00:15:43,830
have that installed or punch or if you

00:15:41,310 --> 00:15:46,230
have like a Mac and auto find the device

00:15:43,830 --> 00:15:48,339
automatically

00:15:46,230 --> 00:15:51,360
which is this kind of like a

00:15:48,339 --> 00:15:56,649
little-known feature that you can do

00:15:51,360 --> 00:15:59,230
okay now when you add multiple blocks

00:15:56,649 --> 00:16:02,079
into a flow graph they'll actually share

00:15:59,230 --> 00:16:06,279
contexts if you use the same URI so if

00:16:02,079 --> 00:16:08,350
you use your IP Pluto local for both

00:16:06,279 --> 00:16:12,310
blocks they'll share the same URI when

00:16:08,350 --> 00:16:14,740
they're talking to the device and this

00:16:12,310 --> 00:16:16,600
is great this even works if you're

00:16:14,740 --> 00:16:19,870
talking to physically different

00:16:16,600 --> 00:16:21,910
components on the board so here I just

00:16:19,870 --> 00:16:24,070
printed out the different devices that

00:16:21,910 --> 00:16:25,720
are available on this this reference

00:16:24,070 --> 00:16:28,329
radio that we have as part of our pack

00:16:25,720 --> 00:16:30,430
RF kit and here I have an individual

00:16:28,329 --> 00:16:34,390
block for the IMU sensor that's pulling

00:16:30,430 --> 00:16:36,550
out acceleration data as well as for the

00:16:34,390 --> 00:16:37,930
transceiver itself and both are using

00:16:36,550 --> 00:16:40,209
the same URI and I'll use the same

00:16:37,930 --> 00:16:44,640
context to talk to the board and this is

00:16:40,209 --> 00:16:44,640
automatically handled in the flow graph

00:16:44,940 --> 00:16:52,270
now if you have separate context names

00:16:48,360 --> 00:16:54,850
say for example if you have two little

00:16:52,270 --> 00:16:56,829
box what about local or Fe and you're

00:16:54,850 --> 00:16:59,920
using the your eyes Pluto dot local and

00:16:56,829 --> 00:17:04,839
the standard IP address that we give to

00:16:59,920 --> 00:17:06,880
Pluto this will actually work now they

00:17:04,839 --> 00:17:08,439
actually do not share a context they

00:17:06,880 --> 00:17:11,199
have separate contexts when you're

00:17:08,439 --> 00:17:16,419
talking to boys and what will happen is

00:17:11,199 --> 00:17:18,760
that IOD will send interleaved data to

00:17:16,419 --> 00:17:21,339
each board or to each source so the

00:17:18,760 --> 00:17:23,829
first buffer will go to the first device

00:17:21,339 --> 00:17:25,480
the next buffer and the the key will

00:17:23,829 --> 00:17:27,429
actually go to the second device and it

00:17:25,480 --> 00:17:29,230
kind of goes like that back and forth so

00:17:27,429 --> 00:17:33,179
just be careful if you set up a system

00:17:29,230 --> 00:17:35,890
like this it will work but kind of the

00:17:33,179 --> 00:17:38,020
outcome might be something unexpected

00:17:35,890 --> 00:17:40,630
that you have but this is really useful

00:17:38,020 --> 00:17:42,850
for example if you once you've run a

00:17:40,630 --> 00:17:45,429
flow graph and you want to use some

00:17:42,850 --> 00:17:47,530
external tool to modify some attribute

00:17:45,429 --> 00:17:50,890
in the part this is a special feature of

00:17:47,530 --> 00:17:53,860
the IP contexts with USB contexts

00:17:50,890 --> 00:17:55,929
actually pulls the the context away so

00:17:53,860 --> 00:17:58,059
that no other application on your

00:17:55,929 --> 00:18:01,419
machine can actually talk to the toys

00:17:58,059 --> 00:18:03,789
so if you need to say use io scope and

00:18:01,419 --> 00:18:05,409
can you radio together use the IP

00:18:03,789 --> 00:18:11,229
context and it will allow you to address

00:18:05,409 --> 00:18:13,210
the device okay now let's move over to

00:18:11,229 --> 00:18:14,950
talk a little bit about custom IP and

00:18:13,210 --> 00:18:18,849
how we can talk to that on our remote

00:18:14,950 --> 00:18:22,119
systems now why should you care about

00:18:18,849 --> 00:18:25,679
this so you know it's not just

00:18:22,119 --> 00:18:27,849
offloading heavy processing to the FPGA

00:18:25,679 --> 00:18:31,059
doing things in the FPGA is really

00:18:27,849 --> 00:18:33,190
useful for tight timing applications

00:18:31,059 --> 00:18:34,629
where so you're doing radar and you need

00:18:33,190 --> 00:18:37,719
tight coupling between transmit receive

00:18:34,629 --> 00:18:39,879
or you're doing frequency hopping and

00:18:37,719 --> 00:18:42,729
you need very tight control over what

00:18:39,879 --> 00:18:45,489
frequency you're on and you doing things

00:18:42,729 --> 00:18:46,690
over the network or over USB really is

00:18:45,489 --> 00:18:48,549
not the best way to do that because

00:18:46,690 --> 00:18:51,369
there's inherent latency in those

00:18:48,549 --> 00:18:53,889
designs or for example if you're using a

00:18:51,369 --> 00:18:55,359
very like a slotted Mac like a time

00:18:53,889 --> 00:18:59,349
division multiplexing Mac Android Mac

00:18:55,359 --> 00:19:01,299
system doing things in software is not

00:18:59,349 --> 00:19:03,820
always the best option and this is why

00:19:01,299 --> 00:19:08,289
it's really useful to do things on the

00:19:03,820 --> 00:19:10,570
FPGA however I would say that the

00:19:08,289 --> 00:19:13,599
standard tools that are provided by a

00:19:10,570 --> 00:19:17,919
lot of vendors don't make it easy to

00:19:13,599 --> 00:19:19,659
talk to IP how you generate Movado hls

00:19:17,919 --> 00:19:22,299
is a great tool a DSP Bill there are

00:19:19,659 --> 00:19:24,549
great tools they get your IP on the

00:19:22,299 --> 00:19:28,749
board they make it simple but actually

00:19:24,549 --> 00:19:32,169
talking to that IP is can be challenging

00:19:28,749 --> 00:19:33,669
and talking to that IP remotely can be

00:19:32,169 --> 00:19:35,339
even a bigger challenge because there's

00:19:33,669 --> 00:19:37,929
really no standard tools to do that and

00:19:35,339 --> 00:19:40,210
that's why things like RF knock are

00:19:37,929 --> 00:19:42,759
really great because they allow you to

00:19:40,210 --> 00:19:45,070
kind of bridge that gap they allow you a

00:19:42,759 --> 00:19:46,899
lot of software control over IP that you

00:19:45,070 --> 00:19:53,019
might deploy and we can do something

00:19:46,899 --> 00:19:54,489
similar with with Alibi oh and i/o now

00:19:53,019 --> 00:19:56,979
let's kind of look at an example of

00:19:54,489 --> 00:20:00,339
where this really might be useful there

00:19:56,979 --> 00:20:01,989
was a paper done in 2016 about the

00:20:00,339 --> 00:20:05,710
frequency hopping capability of

00:20:01,989 --> 00:20:08,139
different STRs and on the right I just

00:20:05,710 --> 00:20:11,920
have a table of some of the results and

00:20:08,139 --> 00:20:14,110
they say that the b200 and the e3 10

00:20:11,920 --> 00:20:16,290
all which have a ninety 361 inside them

00:20:14,110 --> 00:20:21,840
or a sixty-four I believe for the b200

00:20:16,290 --> 00:20:25,990
all have a super-long frequency-hopping

00:20:21,840 --> 00:20:28,450
capability and this was all done through

00:20:25,990 --> 00:20:32,410
software so there would be simple start

00:20:28,450 --> 00:20:34,450
hop finish hop kind of check if the ello

00:20:32,410 --> 00:20:37,380
was locked and then that time was

00:20:34,450 --> 00:20:42,130
measured and this was on the order of

00:20:37,380 --> 00:20:43,840
milliseconds now in reality the part is

00:20:42,130 --> 00:20:46,650
actually capable of hopping at 25

00:20:43,840 --> 00:20:50,650
microseconds so much much much faster

00:20:46,650 --> 00:20:53,800
but to do this you have to be able to

00:20:50,650 --> 00:20:57,010
keep up with the part at that speed so

00:20:53,800 --> 00:20:59,590
if you want to hop very quickly at this

00:20:57,010 --> 00:21:01,680
rate you have to use this concept called

00:20:59,590 --> 00:21:04,210
fast lock profiles in the transceiver

00:21:01,680 --> 00:21:07,690
now if you don't use these in a

00:21:04,210 --> 00:21:09,220
traditional manner you have to so you

00:21:07,690 --> 00:21:11,260
kind of have this logic on the left here

00:21:09,220 --> 00:21:14,350
in the default ello mode where if you

00:21:11,260 --> 00:21:17,970
change the ello beyond 100 megahertz you

00:21:14,350 --> 00:21:23,820
have to retune or recalibrate the VCO

00:21:17,970 --> 00:21:26,580
and this can take a lot longer than that

00:21:23,820 --> 00:21:29,230
hundreds of microseconds in some cases

00:21:26,580 --> 00:21:32,620
now in the case of fast lock profiles

00:21:29,230 --> 00:21:34,570
what you can do is simply save a number

00:21:32,620 --> 00:21:38,350
of these calibrations in what we call

00:21:34,570 --> 00:21:39,520
these these profile registers and then

00:21:38,350 --> 00:21:41,560
when you want to move to the next one

00:21:39,520 --> 00:21:43,960
you simply tell the part hallo this

00:21:41,560 --> 00:21:45,940
profile and it will simply change in the

00:21:43,960 --> 00:21:51,340
ello will shift and lock in in 25

00:21:45,940 --> 00:21:53,170
microseconds now this can be done or

00:21:51,340 --> 00:21:55,090
this can be controlled in two ways here

00:21:53,170 --> 00:21:57,430
we just have a little diagram of the

00:21:55,090 --> 00:21:58,810
chip itself and a baseband processor so

00:21:57,430 --> 00:22:00,640
this would be your Zink that's actually

00:21:58,810 --> 00:22:05,080
physically connected to the part and you

00:22:00,640 --> 00:22:06,420
can talk to the part over spy or you can

00:22:05,080 --> 00:22:09,640
talk to it through these control pins

00:22:06,420 --> 00:22:11,050
and spy will actually keep up with the

00:22:09,640 --> 00:22:13,990
part if you want to hop at that rate

00:22:11,050 --> 00:22:16,210
however it's not as the terminus tick so

00:22:13,990 --> 00:22:19,090
if you need like sample level control

00:22:16,210 --> 00:22:23,740
you really need to use the control pins

00:22:19,090 --> 00:22:25,630
to be able to control that hop and a

00:22:23,740 --> 00:22:28,540
kind of a way that you could

00:22:25,630 --> 00:22:32,740
set us up would be that you have this

00:22:28,540 --> 00:22:34,180
hot controller so this diagram is a so

00:22:32,740 --> 00:22:36,850
we have the PL in the middle sort of

00:22:34,180 --> 00:22:38,470
fabric the PS in the left with a kernel

00:22:36,850 --> 00:22:40,060
in it and then ship on the right and

00:22:38,470 --> 00:22:41,740
we're talking to the chip through those

00:22:40,060 --> 00:22:45,310
control pins and then reading them out

00:22:41,740 --> 00:22:47,740
so we can make sure that the the

00:22:45,310 --> 00:22:49,120
basement PLL is always locked and then

00:22:47,740 --> 00:22:51,070
we could use this hop controller to

00:22:49,120 --> 00:22:52,780
basically control these pins tell the

00:22:51,070 --> 00:22:55,030
part when to hop and then control the

00:22:52,780 --> 00:22:57,160
DMA data so that during those

00:22:55,030 --> 00:22:59,290
transitions we don't allow any data into

00:22:57,160 --> 00:23:02,800
the DMA or out of the DMA back into the

00:22:59,290 --> 00:23:05,260
part and if you're curious about this

00:23:02,800 --> 00:23:07,420
design it's actually documented on our

00:23:05,260 --> 00:23:10,270
wiki so you can understand how its

00:23:07,420 --> 00:23:14,200
structured and this was implemented in

00:23:10,270 --> 00:23:18,550
the fpga and then we actually wrote a

00:23:14,200 --> 00:23:21,400
little driver for it in i/o so there are

00:23:18,550 --> 00:23:23,200
kind of two ways you can go about or so

00:23:21,400 --> 00:23:25,630
traditionally there are a lot of ways

00:23:23,200 --> 00:23:28,510
you can develop drivers but this is a

00:23:25,630 --> 00:23:30,760
common flow I use I'd usually start with

00:23:28,510 --> 00:23:34,150
this a kind of stumped driver that we

00:23:30,760 --> 00:23:36,250
have a really basic driver this was

00:23:34,150 --> 00:23:39,180
actually developed by the MathWorks to

00:23:36,250 --> 00:23:41,620
talk to you I Oh devices and it exposes

00:23:39,180 --> 00:23:44,080
just registers to the device so if you

00:23:41,620 --> 00:23:46,090
want to get at the registers of a

00:23:44,080 --> 00:23:47,740
specific IP this is a really simple way

00:23:46,090 --> 00:23:49,420
to do that we have a patch available

00:23:47,740 --> 00:23:52,330
that will add the driver to your kernel

00:23:49,420 --> 00:23:55,390
or you can use the standard kernels from

00:23:52,330 --> 00:23:57,910
MathWorks and so it's in the support

00:23:55,390 --> 00:24:00,190
packages for e3 10 FM columns a trv the

00:23:57,910 --> 00:24:02,530
standard boards this is great for

00:24:00,190 --> 00:24:05,350
debugging but all the logic or the

00:24:02,530 --> 00:24:08,650
control of the driver is on the user and

00:24:05,350 --> 00:24:11,380
they have to kind of manage it and it's

00:24:08,650 --> 00:24:14,230
not I wouldn't say it's not a great

00:24:11,380 --> 00:24:15,490
portable solution and when you want to

00:24:14,230 --> 00:24:17,470
kind of do something that's more

00:24:15,490 --> 00:24:19,270
portable you start you develop your

00:24:17,470 --> 00:24:25,360
custom driver and this is what we did

00:24:19,270 --> 00:24:29,170
for this application so let's actually

00:24:25,360 --> 00:24:31,660
see this working this demo actually runs

00:24:29,170 --> 00:24:36,610
on this board I'm showing here which is

00:24:31,660 --> 00:24:37,800
our ATR p9 361 song and the test I'm

00:24:36,610 --> 00:24:42,180
just

00:24:37,800 --> 00:24:44,640
using the psalm

00:24:42,180 --> 00:24:45,930
that's so transmitted is connected to

00:24:44,640 --> 00:24:47,670
receive so we can just see we're

00:24:45,930 --> 00:24:50,220
transmitting and I'm going to be hopping

00:24:47,670 --> 00:24:55,920
the are moving yellow using this fast

00:24:50,220 --> 00:24:57,570
lock controller that we built and so and

00:24:55,920 --> 00:24:58,650
it will just continuously hop the

00:24:57,570 --> 00:25:01,620
transmitter and we're going to be

00:24:58,650 --> 00:25:06,990
observing that on the receive side so in

00:25:01,620 --> 00:25:08,550
this flow graph I have a FM comm source

00:25:06,990 --> 00:25:11,310
in the middle here that's just being

00:25:08,550 --> 00:25:13,740
sent out to some frequency plots and

00:25:11,310 --> 00:25:14,850
then on the Left we have some attribute

00:25:13,740 --> 00:25:16,530
blocks that are actually controlling

00:25:14,850 --> 00:25:19,950
that I yo driver and setting different

00:25:16,530 --> 00:25:21,990
attributes at the bottom

00:25:19,950 --> 00:25:23,580
I'm simply pulling out the different

00:25:21,990 --> 00:25:25,590
listening different drivers as we can

00:25:23,580 --> 00:25:27,780
see that the hopper driver is there and

00:25:25,590 --> 00:25:31,800
we can see that the 93 61 five driver is

00:25:27,780 --> 00:25:38,550
there and now I'm just going to start

00:25:31,800 --> 00:25:40,140
the flow graph and we can see the tone

00:25:38,550 --> 00:25:42,980
that's being transmitted by the DDS

00:25:40,140 --> 00:25:46,890
that's in our standard reference designs

00:25:42,980 --> 00:25:49,110
now next what I do is I load up the fast

00:25:46,890 --> 00:25:51,600
lock profiles individually so I move to

00:25:49,110 --> 00:25:53,850
each ello and I save the the calibration

00:25:51,600 --> 00:25:55,890
did off into the part and you can see

00:25:53,850 --> 00:25:58,970
that the tone is just moving across the

00:25:55,890 --> 00:25:58,970
different frequencies that I'm using

00:26:02,720 --> 00:26:06,800
now I have all the profiles loaded and

00:26:05,000 --> 00:26:14,600
what I'll do is I'll turn on fast

00:26:06,800 --> 00:26:16,760
hopping and you can see it just hopping

00:26:14,600 --> 00:26:18,890
all over those frequencies now it is

00:26:16,760 --> 00:26:20,330
smearing just because we're not keeping

00:26:18,890 --> 00:26:24,350
up with the device so it's not a

00:26:20,330 --> 00:26:26,120
real-time spectrum analyzer and what we

00:26:24,350 --> 00:26:28,250
can do is actually change how long it

00:26:26,120 --> 00:26:29,720
spends on each frequency and that's what

00:26:28,250 --> 00:26:32,450
I'm doing by changing that slider and

00:26:29,720 --> 00:26:33,680
you can see that the lines are not

00:26:32,450 --> 00:26:37,240
smearing anymore just because we're

00:26:33,680 --> 00:26:37,240
spending more time on those frequencies

00:26:45,450 --> 00:26:53,769
so that's just an example of kind of the

00:26:48,730 --> 00:26:55,990
control and the way you can use IO to

00:26:53,769 --> 00:26:59,590
control external IP this is a really

00:26:55,990 --> 00:27:02,649
easy way to get at really time-sensitive

00:26:59,590 --> 00:27:05,710
things in the ship to get at IP from can

00:27:02,649 --> 00:27:07,059
you radio or since it's a io driver you

00:27:05,710 --> 00:27:12,000
can get at the command line if you want

00:27:07,059 --> 00:27:14,049
to and its really really portable ok

00:27:12,000 --> 00:27:17,379
next I'm just going to talk a little bit

00:27:14,049 --> 00:27:18,850
about Laval performance so we had our

00:27:17,379 --> 00:27:22,269
really interesting talk the other day

00:27:18,850 --> 00:27:26,649
about its e3 10 and pulling data off of

00:27:22,269 --> 00:27:29,769
it at speed how we do this is with a

00:27:26,649 --> 00:27:33,220
kernel driver and inside the kernel

00:27:29,769 --> 00:27:36,039
driver is a as a ring buffer that we use

00:27:33,220 --> 00:27:38,710
so when you pull data from the chip the

00:27:36,039 --> 00:27:40,570
DMA puts it into this ring buffer and

00:27:38,710 --> 00:27:41,799
then you pull from that ring buffer and

00:27:40,570 --> 00:27:45,129
that's what you're seeing and get your

00:27:41,799 --> 00:27:50,289
radio on board so this is a a map device

00:27:45,129 --> 00:27:52,450
it's super fast it's really limited from

00:27:50,289 --> 00:27:56,409
our experience by the memory controllers

00:27:52,450 --> 00:28:01,769
in the FPGA so we use it for Giga sample

00:27:56,409 --> 00:28:04,570
devices and it keeps up pretty well

00:28:01,769 --> 00:28:07,210
however when you're using a remote

00:28:04,570 --> 00:28:11,740
context this is a little bit different

00:28:07,210 --> 00:28:13,600
how your interacts with the device so it

00:28:11,740 --> 00:28:17,230
has the synchronous transfer mechanism

00:28:13,600 --> 00:28:19,990
where for every transfer you have to do

00:28:17,230 --> 00:28:20,980
a buffer pull request so you you request

00:28:19,990 --> 00:28:22,870
the buffer it gives you want your

00:28:20,980 --> 00:28:26,860
request buffered it gives you one so you

00:28:22,870 --> 00:28:29,289
have to deal with this latency of doing

00:28:26,860 --> 00:28:32,639
a request every time so this will

00:28:29,289 --> 00:28:36,399
actually cause a roughly 30% overhead

00:28:32,639 --> 00:28:41,110
from the ceiling yeah of your of your

00:28:36,399 --> 00:28:42,669
platform so in live IO 2.0 we're

00:28:41,110 --> 00:28:45,490
actually looking at modifying this to do

00:28:42,669 --> 00:28:46,779
a more a secure transfer so you do a

00:28:45,490 --> 00:28:49,059
single request and then you just keep

00:28:46,779 --> 00:28:53,019
pulling buffers back and this will give

00:28:49,059 --> 00:28:55,240
you a lot more speed and just for

00:28:53,019 --> 00:28:57,280
reference if you can use local context

00:28:55,240 --> 00:29:01,000
please do this is kind of

00:28:57,280 --> 00:29:04,870
an example of the overflow occurrence

00:29:01,000 --> 00:29:07,060
probability with local contexts you can

00:29:04,870 --> 00:29:10,600
pretty much max out their choice but

00:29:07,060 --> 00:29:14,040
with IP increase your buffer size and

00:29:10,600 --> 00:29:16,150
you'll do much much much much better

00:29:14,040 --> 00:29:18,220
okay so I'm just going to quickly go

00:29:16,150 --> 00:29:21,610
over some new features that are in gr IO

00:29:18,220 --> 00:29:25,090
that are coming out soon so we're adding

00:29:21,610 --> 00:29:27,060
a lot more filtering control or filter

00:29:25,090 --> 00:29:29,730
configuration control in the blocks

00:29:27,060 --> 00:29:32,160
we're doing this by adding a filter tab

00:29:29,730 --> 00:29:34,600
to the FM columns and the Pluto blocks

00:29:32,160 --> 00:29:36,940
so you'll have options to either turn

00:29:34,600 --> 00:29:39,280
off filters provide some auto preset

00:29:36,940 --> 00:29:40,990
filters you can load a filter file from

00:29:39,280 --> 00:29:42,730
our filter generation tool or you can

00:29:40,990 --> 00:29:45,910
use this new feature where you can

00:29:42,730 --> 00:29:47,680
design a filter on the fly using just

00:29:45,910 --> 00:29:50,530
some some simple parameters like f-stop

00:29:47,680 --> 00:29:52,120
transition band the analog bandwidth and

00:29:50,530 --> 00:29:56,020
we take all those into consideration and

00:29:52,120 --> 00:29:57,880
design a filter on the fly for you we're

00:29:56,020 --> 00:30:01,570
adding underflow and overflow indicators

00:29:57,880 --> 00:30:04,240
so the standard like OHS and use that

00:30:01,570 --> 00:30:08,970
you're probably used to from uhd that we

00:30:04,240 --> 00:30:08,970
provide it now across all our blocks

00:30:09,090 --> 00:30:14,440
we're enabling the FPGA filters that are

00:30:12,130 --> 00:30:16,150
inside pseudo if you didn't know there

00:30:14,440 --> 00:30:18,880
are additional decimation interpolation

00:30:16,150 --> 00:30:21,010
filters inside Pluto and this will allow

00:30:18,880 --> 00:30:25,120
you to get down to 60 65 kilohertz

00:30:21,010 --> 00:30:27,160
sample rate and you don't have to do

00:30:25,120 --> 00:30:29,200
anything you simply install the new

00:30:27,160 --> 00:30:30,490
blocks and you're you said you can set

00:30:29,200 --> 00:30:34,240
the sample rate lower and it will turn

00:30:30,490 --> 00:30:37,210
on those destinations for you the last

00:30:34,240 --> 00:30:40,690
feature is we're adding a DDS controller

00:30:37,210 --> 00:30:44,860
block if you didn't know there are DDS

00:30:40,690 --> 00:30:47,080
inside Pluto and so that all or pretty

00:30:44,860 --> 00:30:48,820
much all of our reference designs and we

00:30:47,080 --> 00:30:51,160
have a block that you can independently

00:30:48,820 --> 00:30:55,750
control that throughout through bug in

00:30:51,160 --> 00:30:59,680
your radio now do I have time for

00:30:55,750 --> 00:31:01,240
another video or nope okay come to the

00:30:59,680 --> 00:31:03,970
workshop later if you're curious about

00:31:01,240 --> 00:31:09,070
this just an example of how the DDS work

00:31:03,970 --> 00:31:10,390
and just a final notes so we are we do

00:31:09,070 --> 00:31:12,730
have a grep open

00:31:10,390 --> 00:31:13,720
mainline GRI oh and we're doing this

00:31:12,730 --> 00:31:17,770
because we want to make it easier for

00:31:13,720 --> 00:31:20,080
everyone and so you don't have to go to

00:31:17,770 --> 00:31:22,480
our auditory module and we're always

00:31:20,080 --> 00:31:25,540
being pushed to maintain all of our

00:31:22,480 --> 00:31:30,040
blocks to keep up with your radio

00:31:25,540 --> 00:31:31,960
development and we're doing this by the

00:31:30,040 --> 00:31:33,130
the grip actually proposes to remove

00:31:31,960 --> 00:31:35,380
there just the scope e blocks that are

00:31:33,130 --> 00:31:38,530
in and you can conditionally install the

00:31:35,380 --> 00:31:43,120
device specific blocks or just pull in

00:31:38,530 --> 00:31:45,760
the standard streaming ones and just the

00:31:43,120 --> 00:31:47,290
final notes we are adding Python

00:31:45,760 --> 00:31:50,260
bindings so if you want to use Python

00:31:47,290 --> 00:31:52,300
for talking to our transceivers or

00:31:50,260 --> 00:31:54,190
different devices we have a new

00:31:52,300 --> 00:31:56,290
simplified API that you can install from

00:31:54,190 --> 00:31:59,470
hit today so if you don't want to write

00:31:56,290 --> 00:32:01,000
a bunch of live audio code which is this

00:31:59,470 --> 00:32:03,850
is just setting up the transceiver and

00:32:01,000 --> 00:32:04,690
setting to parameters and this is

00:32:03,850 --> 00:32:08,370
setting

00:32:04,690 --> 00:32:10,780
I'll see you like eight here seven and

00:32:08,370 --> 00:32:16,690
it's a lot simpler to interface with the

00:32:10,780 --> 00:32:17,770
transceivers okay thank you everyone if

00:32:16,690 --> 00:32:21,529
you have any

00:32:17,770 --> 00:32:21,529

YouTube URL: https://www.youtube.com/watch?v=tX8Tg9TBkPw


