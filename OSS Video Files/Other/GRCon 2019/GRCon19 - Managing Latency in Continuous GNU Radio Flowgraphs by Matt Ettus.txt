Title: GRCon19 - Managing Latency in Continuous GNU Radio Flowgraphs by Matt Ettus
Publication date: 2019-11-05
Playlist: GRCon 2019
Description: 
	Managing Latency in Continuous GNU Radio Flowgraphs by Matt Ettus
Captions: 
	00:00:14,320 --> 00:00:23,020
I originally started out with intending

00:00:18,700 --> 00:00:26,950
to talk about diversity in my mo here

00:00:23,020 --> 00:00:29,380
but actually decided to switch to

00:00:26,950 --> 00:00:32,320
talking about a special case of latency

00:00:29,380 --> 00:00:36,129
and canoe radio flow graphs which was

00:00:32,320 --> 00:00:38,860
originally inspired by a company giving

00:00:36,129 --> 00:00:42,340
a talk at the Atlanta gr con back in I

00:00:38,860 --> 00:00:44,230
think was 2012 called skybox and they

00:00:42,340 --> 00:00:47,830
had a problem that we renamed the skybox

00:00:44,230 --> 00:00:49,330
problem and and came up with a solution

00:00:47,830 --> 00:00:52,120
for it but never actually implemented it

00:00:49,330 --> 00:00:53,530
till now skybox is no longer around but

00:00:52,120 --> 00:00:56,280
I think the problem was still there and

00:00:53,530 --> 00:01:00,250
it's a general thing in good radio so

00:00:56,280 --> 00:01:02,229
that's the motivation for this talk but

00:01:00,250 --> 00:01:05,019
anyway we'll start with the problem

00:01:02,229 --> 00:01:07,330
statement so first what is latency and I

00:01:05,019 --> 00:01:11,049
think everybody has a good idea about

00:01:07,330 --> 00:01:13,869
what latency is but where it comes from

00:01:11,049 --> 00:01:19,120
and how to deal with it is not always as

00:01:13,869 --> 00:01:22,420
clear so I divided latency really into

00:01:19,120 --> 00:01:25,000
in as occurs in a can radio flow graph

00:01:22,420 --> 00:01:27,700
into three categories so first is

00:01:25,000 --> 00:01:29,620
inherent this is just the basic time

00:01:27,700 --> 00:01:31,510
that it takes to do your computation

00:01:29,620 --> 00:01:33,190
it's it's kind of unavoidable so if you

00:01:31,510 --> 00:01:35,770
have to do a bunch of ads and an FFT

00:01:33,190 --> 00:01:38,530
well you're going to need to do all

00:01:35,770 --> 00:01:42,490
those computations so the time from your

00:01:38,530 --> 00:01:46,060
input to your result you know has a

00:01:42,490 --> 00:01:49,510
certain minimum latency to it the next I

00:01:46,060 --> 00:01:50,740
would call scheduler induced and so and

00:01:49,510 --> 00:01:52,780
I would say the scheduler does a very

00:01:50,740 --> 00:01:56,310
good job of minimizing that can somebody

00:01:52,780 --> 00:01:56,310
turn this slightly down it's a little

00:01:56,400 --> 00:02:03,250
scheduler induced latency is things like

00:01:59,860 --> 00:02:05,290
I have to add some numbers but the

00:02:03,250 --> 00:02:06,820
scheduler does its best to to make it as

00:02:05,290 --> 00:02:09,190
efficient as possible in the bandwidth

00:02:06,820 --> 00:02:10,929
sense so it gives me a thousand numbers

00:02:09,190 --> 00:02:13,599
to add and so I add all the thousand

00:02:10,929 --> 00:02:15,489
numbers and then I send it along whereas

00:02:13,599 --> 00:02:16,750
if I just done one that that one could

00:02:15,489 --> 00:02:18,940
have percolated along it might have

00:02:16,750 --> 00:02:20,440
reduced the latency in the system and so

00:02:18,940 --> 00:02:24,030
that's that scheduler induced and that

00:02:20,440 --> 00:02:26,650
that's really a trade-off between

00:02:24,030 --> 00:02:28,420
bandwidth and processor efficiency and

00:02:26,650 --> 00:02:30,580
latency

00:02:28,420 --> 00:02:32,050
and I think the the flow the radio

00:02:30,580 --> 00:02:34,660
scheduler does a pretty good job of

00:02:32,050 --> 00:02:36,040
managing that as things get faster and

00:02:34,660 --> 00:02:39,670
faster you kind of want to do work and

00:02:36,040 --> 00:02:42,430
bigger and bigger chunks but what what

00:02:39,670 --> 00:02:46,330
really we're talking about in this talk

00:02:42,430 --> 00:02:50,050
is why I didn't mean the lights I meant

00:02:46,330 --> 00:02:53,200
the sound but that's cool too lights and

00:02:50,050 --> 00:02:54,640
lights are good but really what I'm

00:02:53,200 --> 00:02:58,060
talking about here is buffer induced

00:02:54,640 --> 00:03:00,520
latency and and this is I think the

00:02:58,060 --> 00:03:01,780
biggest problem that we see in in

00:03:00,520 --> 00:03:03,340
certain types of applications

00:03:01,780 --> 00:03:07,750
specifically those that have continuous

00:03:03,340 --> 00:03:10,600
streaming so so what really causes it

00:03:07,750 --> 00:03:12,550
and and when is it a problem so so first

00:03:10,600 --> 00:03:15,190
of all it's this is generally only a TX

00:03:12,550 --> 00:03:16,690
problem and it's most obvious when

00:03:15,190 --> 00:03:21,280
you're doing something relatively narrow

00:03:16,690 --> 00:03:24,100
band but but it's it's always there you

00:03:21,280 --> 00:03:25,030
just may not see it if you're not if

00:03:24,100 --> 00:03:28,540
you're not really concerned about

00:03:25,030 --> 00:03:29,890
latency but I'm gonna do show a flow

00:03:28,540 --> 00:03:33,490
graph here to do a quick demonstration

00:03:29,890 --> 00:03:36,310
of this so this is pretty simple we've

00:03:33,490 --> 00:03:38,500
got a signal source on the Left we've

00:03:36,310 --> 00:03:40,090
got I multiplied by a constant so this

00:03:38,500 --> 00:03:42,070
is essentially turning it on and off and

00:03:40,090 --> 00:03:44,770
that's controlled by a GUI push button

00:03:42,070 --> 00:03:47,410
so when you press it it turns on the

00:03:44,770 --> 00:03:50,140
sine wave and or sets the amplitudes is

00:03:47,410 --> 00:03:52,000
1 and when you release the button it

00:03:50,140 --> 00:03:53,200
goes back to 0 I add in some noise just

00:03:52,000 --> 00:03:55,120
so there's something there even when

00:03:53,200 --> 00:03:56,860
you're not generating a signal so you

00:03:55,120 --> 00:03:58,570
can see things updating add that

00:03:56,860 --> 00:04:02,050
together and it goes to a GUI sync and

00:03:58,570 --> 00:04:03,730
then to simulate just doing a little bit

00:04:02,050 --> 00:04:05,500
of computation we have this add Const

00:04:03,730 --> 00:04:07,209
block and then it goes to audio and it

00:04:05,500 --> 00:04:08,380
goes to the GUI time sync now I don't

00:04:07,209 --> 00:04:09,700
know if you guys will hear the audio

00:04:08,380 --> 00:04:13,690
when it comes out but you'll see it on

00:04:09,700 --> 00:04:17,380
the on the display so so how it will run

00:04:13,690 --> 00:04:19,570
this and no so you're definitely not

00:04:17,380 --> 00:04:22,720
going to hear that and unfortunately we

00:04:19,570 --> 00:04:24,160
may not even see it that well at this

00:04:22,720 --> 00:04:25,600
resolution maybe I should go back to the

00:04:24,160 --> 00:04:31,360
other resolution and just deal with the

00:04:25,600 --> 00:04:34,200
small fonts sorry about that folks let's

00:04:31,360 --> 00:04:34,200
let's switch this

00:04:36,830 --> 00:04:50,429
so what what you'll see here is that we

00:04:43,139 --> 00:04:55,830
have okay so we have two two displays

00:04:50,429 --> 00:04:58,229
the upper one is the first GUI sync and

00:04:55,830 --> 00:05:00,240
then the second one is after all we do

00:04:58,229 --> 00:05:02,099
is add a constant of zero to it and then

00:05:00,240 --> 00:05:03,959
you see it on the second one and it's

00:05:02,099 --> 00:05:07,409
also going to audio which of course

00:05:03,959 --> 00:05:08,610
you're not hearing and so I'm gonna

00:05:07,409 --> 00:05:13,439
click on this little button in the

00:05:08,610 --> 00:05:17,879
middle and okay so actually you can hear

00:05:13,439 --> 00:05:19,559
that so the when I press it first you

00:05:17,879 --> 00:05:21,689
see some latency between when I press it

00:05:19,559 --> 00:05:23,639
and when the top sine wave appears but

00:05:21,689 --> 00:05:25,800
you also see some between the top and

00:05:23,639 --> 00:05:27,149
the bottom now that's not too bad but

00:05:25,800 --> 00:05:28,919
this would make for anybody who does

00:05:27,149 --> 00:05:30,179
Morse code in ham radio this would make

00:05:28,919 --> 00:05:34,409
it difficult to use because there's this

00:05:30,179 --> 00:05:36,149
delay but now let's let's say we we did

00:05:34,409 --> 00:05:39,179
something with a little bit more complex

00:05:36,149 --> 00:05:44,069
computation which I'll simulate just by

00:05:39,179 --> 00:05:58,769
having a lot of adders in it and so

00:05:44,069 --> 00:06:04,159
instead of this will small font sir okay

00:05:58,769 --> 00:06:04,159
and then we will send the same output

00:06:04,309 --> 00:06:11,939
into into the same places right and and

00:06:10,499 --> 00:06:13,139
of course as you see here that since we

00:06:11,939 --> 00:06:16,079
have an audio sync and everything's

00:06:13,139 --> 00:06:19,889
running at 48 kilohertz that is what is

00:06:16,079 --> 00:06:23,039
setting the the processing in the system

00:06:19,889 --> 00:06:24,569
so now we do that and this you know

00:06:23,039 --> 00:06:27,089
there's a few blocks so it's a moderate

00:06:24,569 --> 00:06:32,939
amount of processing but I click on this

00:06:27,089 --> 00:06:34,949
and let's let's and I click on it and

00:06:32,939 --> 00:06:36,419
the top one happens quickly but you'll

00:06:34,949 --> 00:06:39,149
actually see this quite a significant

00:06:36,419 --> 00:06:41,429
delay in the bottom and so so what

00:06:39,149 --> 00:06:43,139
what's happening here right so I press

00:06:41,429 --> 00:06:44,699
it again it takes a while

00:06:43,139 --> 00:06:47,009
shows up and then I let go and it

00:06:44,699 --> 00:06:48,229
actually still goes for a while now why

00:06:47,009 --> 00:06:49,650
is that happening

00:06:48,229 --> 00:06:51,000
so if you look

00:06:49,650 --> 00:06:52,979
the flow graph which is unfortunately

00:06:51,000 --> 00:06:56,100
very small right now you see these

00:06:52,979 --> 00:06:58,139
arrows now every arrow is actually a

00:06:56,100 --> 00:06:59,850
circularbuffer and a guna radio those

00:06:58,139 --> 00:07:04,110
default to I think about 32 kilobytes

00:06:59,850 --> 00:07:08,310
depending on on circumstances but 32

00:07:04,110 --> 00:07:11,729
kilobytes is is forth out of 8,000

00:07:08,310 --> 00:07:15,389
samples at when their float numbers like

00:07:11,729 --> 00:07:18,330
this so 8000 samples at 32 kilo samples

00:07:15,389 --> 00:07:20,400
per second is you know a quarter of a

00:07:18,330 --> 00:07:23,100
second and now we have a whole bunch of

00:07:20,400 --> 00:07:25,830
them in a row and you end up filling up

00:07:23,100 --> 00:07:28,680
all these buffers and actually I'll show

00:07:25,830 --> 00:07:32,610
it an even crazier case here which is

00:07:28,680 --> 00:07:42,030
what happens if we if we replace that

00:07:32,610 --> 00:07:43,770
with a vector operation so I all I do is

00:07:42,030 --> 00:07:45,990
I take that stream turn it into a vector

00:07:43,770 --> 00:07:53,220
and I turn the vector back into a stream

00:07:45,990 --> 00:07:55,800
and but I chose a vector size of I

00:07:53,220 --> 00:07:58,560
believe it's 137 which is a nice prime

00:07:55,800 --> 00:08:00,389
number and what that does is it causes

00:07:58,560 --> 00:08:02,070
the the buffers to become really big

00:08:00,389 --> 00:08:04,590
because they have to be multiples of

00:08:02,070 --> 00:08:08,190
4096 bytes and so you find the least

00:08:04,590 --> 00:08:10,979
common multiple of 137 and 4096 and it

00:08:08,190 --> 00:08:14,760
becomes really bad so let's let's let's

00:08:10,979 --> 00:08:17,729
see what happens there so I'll click on

00:08:14,760 --> 00:08:19,680
this and you'll see it takes quite a

00:08:17,729 --> 00:08:21,120
significant amount of time before this

00:08:19,680 --> 00:08:23,190
stuff actually percolates through these

00:08:21,120 --> 00:08:25,500
giant buffers and of course it continues

00:08:23,190 --> 00:08:26,940
for quite a while after I've pressed in

00:08:25,500 --> 00:08:28,470
I think this is something like 8

00:08:26,940 --> 00:08:30,150
secconds

00:08:28,470 --> 00:08:31,800
so clearly clear that there's an issue

00:08:30,150 --> 00:08:35,310
so how do we solve that with ink in a

00:08:31,800 --> 00:08:41,729
radio and actually whoops that's let's

00:08:35,310 --> 00:08:44,070
bring this back so so so what causes

00:08:41,729 --> 00:08:46,440
this well we have at the beginning of

00:08:44,070 --> 00:08:49,500
the flow graph we have our action right

00:08:46,440 --> 00:08:51,570
it's a modulation but then the scheduler

00:08:49,500 --> 00:08:52,830
does its best to percolate things

00:08:51,570 --> 00:08:54,240
through the flow graph and keep the

00:08:52,830 --> 00:08:56,220
buffers full so that everything moves

00:08:54,240 --> 00:08:57,720
along as quickly as possible but what

00:08:56,220 --> 00:08:59,790
that means is that you now have many

00:08:57,720 --> 00:09:02,279
many buffers full of samples that you've

00:08:59,790 --> 00:09:03,360
already made your decision on whether

00:09:02,279 --> 00:09:07,320
that what their amplitude

00:09:03,360 --> 00:09:09,660
and when you change that you those all

00:09:07,320 --> 00:09:12,089
have to go out the audio sync or you HD

00:09:09,660 --> 00:09:15,839
or you know to whatever hardware before

00:09:12,089 --> 00:09:18,750
that can change and so so you end up

00:09:15,839 --> 00:09:20,519
with this long delay and what skybox had

00:09:18,750 --> 00:09:23,250
it they had a similar problem it's a

00:09:20,519 --> 00:09:25,649
little harder to show but what they were

00:09:23,250 --> 00:09:27,510
doing was they had a telemetry stream up

00:09:25,649 --> 00:09:30,120
to their satellite and the telemetry

00:09:27,510 --> 00:09:34,200
stream what it needed to do was first it

00:09:30,120 --> 00:09:36,630
was a continuous PSK signal and when

00:09:34,200 --> 00:09:39,120
they had to data to send they would send

00:09:36,630 --> 00:09:40,410
data and when they had no data to send

00:09:39,120 --> 00:09:42,180
they had to send idols to keep

00:09:40,410 --> 00:09:44,130
synchronization so they sent an idle

00:09:42,180 --> 00:09:45,810
signal but what happened is when you

00:09:44,130 --> 00:09:48,810
when you MUX those together in gonna

00:09:45,810 --> 00:09:50,519
radio vital can be computed way way way

00:09:48,810 --> 00:09:53,370
in advance because it's it's not

00:09:50,519 --> 00:09:55,920
changing and your data has to wait for

00:09:53,370 --> 00:09:57,300
the actual data to arrive and so what

00:09:55,920 --> 00:10:00,990
you ended up doing was filling up a huge

00:09:57,300 --> 00:10:02,339
buffer with idols and so that caused you

00:10:00,990 --> 00:10:04,019
know when there actually was data to

00:10:02,339 --> 00:10:05,670
send it took quite a while I think they

00:10:04,019 --> 00:10:08,880
were on the order of four seconds before

00:10:05,670 --> 00:10:12,269
it gets sent there's another company

00:10:08,880 --> 00:10:15,570
also in in an allied field let's say

00:10:12,269 --> 00:10:18,480
that had a they were making a

00:10:15,570 --> 00:10:20,880
self-destruct signal like what happens

00:10:18,480 --> 00:10:22,769
if our hardware is going to hurt people

00:10:20,880 --> 00:10:25,949
well we have to send it a self-destruct

00:10:22,769 --> 00:10:30,180
signal but you want that self-destruct

00:10:25,949 --> 00:10:32,279
signal to be if it goes away you also

00:10:30,180 --> 00:10:34,649
need to do a self-destruct because you

00:10:32,279 --> 00:10:38,670
can't you you you need to still need a

00:10:34,649 --> 00:10:40,620
positive a sort of a positive

00:10:38,670 --> 00:10:42,449
acknowledgment so so what they did was

00:10:40,620 --> 00:10:45,390
they send they send the continuous don't

00:10:42,449 --> 00:10:46,920
self destruct signal and then when they

00:10:45,390 --> 00:10:48,510
need a self-destruct then they change it

00:10:46,920 --> 00:10:49,769
and they say send a self-destruct well

00:10:48,510 --> 00:10:52,500
what happens if you're sending that

00:10:49,769 --> 00:10:54,630
through a flow graph and you built up a

00:10:52,500 --> 00:10:55,680
whole big buffer full of don't don't

00:10:54,630 --> 00:10:58,589
self-destruct

00:10:55,680 --> 00:11:00,060
it now takes five six ten seconds to

00:10:58,589 --> 00:11:01,079
actually do the self-destruct and

00:11:00,060 --> 00:11:03,390
somebody could get hurt in the meantime

00:11:01,079 --> 00:11:05,370
so this is a Deadman switch kind of

00:11:03,390 --> 00:11:08,329
problem and so they they also suffered

00:11:05,370 --> 00:11:11,430
from this issue so the the these

00:11:08,329 --> 00:11:13,980
solution or well really the cause is

00:11:11,430 --> 00:11:15,899
again as I said the the the buffers and

00:11:13,980 --> 00:11:17,220
and if you really want to get a good

00:11:15,899 --> 00:11:19,230
deep understanding of how this all

00:11:17,220 --> 00:11:24,360
so I would suggest reading this article

00:11:19,230 --> 00:11:28,410
by Marcus on the radio blog that really

00:11:24,360 --> 00:11:30,180
explains it pretty well but the the the

00:11:28,410 --> 00:11:32,220
basic concept is that because you have

00:11:30,180 --> 00:11:34,079
this slow sink at the end you know

00:11:32,220 --> 00:11:36,540
whether it's a radio or audio or

00:11:34,079 --> 00:11:38,970
whatever everything

00:11:36,540 --> 00:11:40,319
the schedule just does its best to move

00:11:38,970 --> 00:11:42,629
things along and so you end up filling

00:11:40,319 --> 00:11:44,040
these buffers so so what are the

00:11:42,629 --> 00:11:45,870
solutions so the solution the first

00:11:44,040 --> 00:11:48,329
first one everybody says and everyone

00:11:45,870 --> 00:11:51,149
tries is to shrink the buffers and this

00:11:48,329 --> 00:11:53,670
can help a little bit and you can use

00:11:51,149 --> 00:11:55,529
the set max output buffer number of

00:11:53,670 --> 00:11:57,389
items and stuff like that but the

00:11:55,529 --> 00:11:59,819
reality is it's still a problem if you

00:11:57,389 --> 00:12:01,439
have a lot of there's a certain minimum

00:11:59,819 --> 00:12:03,120
size that the buffers can function at

00:12:01,439 --> 00:12:04,470
and if you have a lot of them they're

00:12:03,120 --> 00:12:08,579
going to add up anyway and at a low

00:12:04,470 --> 00:12:11,819
sample rate or or if latency if your

00:12:08,579 --> 00:12:17,459
latency requirements are close to your

00:12:11,819 --> 00:12:20,699
sample size then you have an issue with

00:12:17,459 --> 00:12:22,199
that right and you know this is not in

00:12:20,699 --> 00:12:23,970
we're not talking like absolute numbers

00:12:22,199 --> 00:12:25,800
of milliseconds here we're talking it's

00:12:23,970 --> 00:12:27,209
relative to your number of samples so if

00:12:25,800 --> 00:12:30,809
even if you're running in a gig of

00:12:27,209 --> 00:12:32,759
sample per second and if you you know if

00:12:30,809 --> 00:12:34,470
you might need you know a millisecond

00:12:32,759 --> 00:12:35,610
latency that's not hard even if the

00:12:34,470 --> 00:12:38,129
buffers fill up but if you're running

00:12:35,610 --> 00:12:40,230
but if you need a microsecond of latency

00:12:38,129 --> 00:12:42,569
at a gig example per second that's hard

00:12:40,230 --> 00:12:44,759
and if you're running at a killer sample

00:12:42,569 --> 00:12:48,480
on this in those demos I'm showing here

00:12:44,759 --> 00:12:50,639
you know a millisecond is hard and so so

00:12:48,480 --> 00:12:54,629
it's easy to show at the audio rates but

00:12:50,639 --> 00:12:55,920
it's a real problem at all rates so so

00:12:54,629 --> 00:12:59,699
shrinking buffers is not really a

00:12:55,920 --> 00:13:00,779
solution the minimum size buffers can be

00:12:59,699 --> 00:13:03,329
too big because there's too many of them

00:13:00,779 --> 00:13:05,040
and and if you have an fft in there you

00:13:03,329 --> 00:13:07,050
can have a minimum size of a computation

00:13:05,040 --> 00:13:08,819
buffer or there's many many operations

00:13:07,050 --> 00:13:10,920
that require the minimum size I mean it

00:13:08,819 --> 00:13:12,480
can be useful to control the scheduler

00:13:10,920 --> 00:13:14,160
induced latency though so if you don't

00:13:12,480 --> 00:13:15,689
want to add the giant array of numbers

00:13:14,160 --> 00:13:18,000
all at once and you want to add them in

00:13:15,689 --> 00:13:20,149
smaller pieces setting the output buffer

00:13:18,000 --> 00:13:22,889
size can help with that a little bit

00:13:20,149 --> 00:13:24,959
others have suggested to drop items

00:13:22,889 --> 00:13:26,459
already in flight that's that's

00:13:24,959 --> 00:13:29,910
dangerous it's not really a mechanism

00:13:26,459 --> 00:13:31,050
for doing that within goona radio and it

00:13:29,910 --> 00:13:33,690
can create discontinuity

00:13:31,050 --> 00:13:35,430
right the the you know in the

00:13:33,690 --> 00:13:36,810
self-destruct case if all sudden

00:13:35,430 --> 00:13:39,210
everything resynchronize is because

00:13:36,810 --> 00:13:40,860
there's a rotation because you swapped

00:13:39,210 --> 00:13:42,480
out at one modulated signal for another

00:13:40,860 --> 00:13:45,960
that's not synchronized then that

00:13:42,480 --> 00:13:47,610
doesn't help you right so so so dropping

00:13:45,960 --> 00:13:49,680
items in flight doesn't really work so

00:13:47,610 --> 00:13:51,660
so really I think the solution is to

00:13:49,680 --> 00:13:54,480
intelligently control the filling of the

00:13:51,660 --> 00:13:56,520
buffers and so we call that active

00:13:54,480 --> 00:13:58,410
latency management and the idea is to

00:13:56,520 --> 00:14:00,060
you limit the number of in-flight items

00:13:58,410 --> 00:14:04,860
between your decision point and the

00:14:00,060 --> 00:14:08,400
consumption and and and I'll show a

00:14:04,860 --> 00:14:11,280
little bit of how that works here so so

00:14:08,400 --> 00:14:16,140
we have the same flow graph that we used

00:14:11,280 --> 00:14:19,800
for the audio demonstration earlier but

00:14:16,140 --> 00:14:21,120
now this is the fixed version so so

00:14:19,800 --> 00:14:23,370
first I'll run it just to show that it

00:14:21,120 --> 00:14:26,340
it actually does fix the issue and

00:14:23,370 --> 00:14:29,340
you'll you'll notice some some tags on

00:14:26,340 --> 00:14:34,620
the on the streams here but it's the

00:14:29,340 --> 00:14:35,850
same but that's that's related to how we

00:14:34,620 --> 00:14:38,070
solved the problem and I'll get into

00:14:35,850 --> 00:14:40,680
that so now you can see everything

00:14:38,070 --> 00:14:42,690
happens pretty quickly right there even

00:14:40,680 --> 00:14:44,880
though we've got in in this flow graph

00:14:42,690 --> 00:14:47,370
we've got the same stream to vector the

00:14:44,880 --> 00:14:49,580
same pile of adders and the same total

00:14:47,370 --> 00:14:51,960
amount of buffering in the whole system

00:14:49,580 --> 00:14:53,520
in fact there's a slightly more buffers

00:14:51,960 --> 00:14:56,910
in there because there's a couple of

00:14:53,520 --> 00:14:59,430
additional blocks but the the latency is

00:14:56,910 --> 00:15:01,260
is quite controlled and now now when we

00:14:59,430 --> 00:15:03,750
ran it you did see there's a there's a

00:15:01,260 --> 00:15:08,250
tiny there's still a tiny delay that you

00:15:03,750 --> 00:15:11,520
can tell but if I if I that's that's

00:15:08,250 --> 00:15:12,780
really controlled by the these these

00:15:11,520 --> 00:15:16,230
stream two vectors here so I'll get

00:15:12,780 --> 00:15:20,340
those out and then I can actually reduce

00:15:16,230 --> 00:15:26,970
the latency further to the point that

00:15:20,340 --> 00:15:28,980
you can't even really see it also you

00:15:26,970 --> 00:15:30,860
notice that the display got faster and

00:15:28,980 --> 00:15:36,090
and and what's happening is here we're

00:15:30,860 --> 00:15:38,220
we're so we're we are chunking the data

00:15:36,090 --> 00:15:40,020
in smaller pieces here and that's

00:15:38,220 --> 00:15:41,370
actually causing the displays to run at

00:15:40,020 --> 00:15:43,380
the speed that you actually ask them if

00:15:41,370 --> 00:15:44,579
you ever noticed in the QT GUI blocks or

00:15:43,380 --> 00:15:46,410
this one in four

00:15:44,579 --> 00:15:48,119
particular if you say I want to see it's

00:15:46,410 --> 00:15:50,549
60 Hertz you don't actually see anything

00:15:48,119 --> 00:15:51,660
at 60 Hertz and and we've always sort of

00:15:50,549 --> 00:15:53,730
assumed oh that's because they're not

00:15:51,660 --> 00:15:55,410
fast enough to it's not true

00:15:53,730 --> 00:15:56,910
you actually can display them at 60

00:15:55,410 --> 00:16:00,929
Hertz the problem is the way they're

00:15:56,910 --> 00:16:02,910
dropping samples is is is related to the

00:16:00,929 --> 00:16:05,129
buffering issue so so we're actually

00:16:02,910 --> 00:16:07,739
getting full 60 Hertz display here and

00:16:05,129 --> 00:16:09,839
everything happens quite quickly so now

00:16:07,739 --> 00:16:12,089
how did how did we do that so if we look

00:16:09,839 --> 00:16:14,309
at the the display or we look at the

00:16:12,089 --> 00:16:18,329
blocks here it's the exact same flow

00:16:14,309 --> 00:16:20,519
graph except we added two things one is

00:16:18,329 --> 00:16:22,889
this tag to message at the end and all

00:16:20,519 --> 00:16:25,799
this does is is it takes tags off of the

00:16:22,889 --> 00:16:27,839
stream and if they match a filter it

00:16:25,799 --> 00:16:30,929
sends it out as a message so it's

00:16:27,839 --> 00:16:33,269
basically it's a null sink where we we

00:16:30,929 --> 00:16:34,799
grab the tags and send them send them

00:16:33,269 --> 00:16:36,839
out to a recipient so you just tell it

00:16:34,799 --> 00:16:38,489
and in this case I if you can't read it

00:16:36,839 --> 00:16:42,209
probably but it says the tag I'm

00:16:38,489 --> 00:16:43,949
filtering for it is latency strobe so it

00:16:42,209 --> 00:16:46,410
takes those it sends them and you can

00:16:43,949 --> 00:16:48,420
sort of see the the line and comes back

00:16:46,410 --> 00:16:50,429
to this latency manager block at the

00:16:48,420 --> 00:16:53,059
beginning now if you look at latency

00:16:50,429 --> 00:16:55,529
manager it asks you a couple of things

00:16:53,059 --> 00:16:57,360
first you know obviously type in length

00:16:55,529 --> 00:17:00,360
but the important things are maximum

00:16:57,360 --> 00:17:03,869
tags in flight and tagging interval and

00:17:00,360 --> 00:17:06,899
so what this says is what what this does

00:17:03,869 --> 00:17:10,769
is it puts places a tag on what it

00:17:06,899 --> 00:17:12,659
passes through every tagging interval

00:17:10,769 --> 00:17:14,760
number of samples so every 10 samples

00:17:12,659 --> 00:17:16,799
it's putting a tag on here now every 10

00:17:14,760 --> 00:17:19,079
is quite a bit for for anything fast but

00:17:16,799 --> 00:17:20,909
for audio you you know 10 samples is not

00:17:19,079 --> 00:17:23,100
so hard for the processor to keep up and

00:17:20,909 --> 00:17:25,709
then it says I'm only allowed to have 5

00:17:23,100 --> 00:17:28,139
tags in flight so what does that mean it

00:17:25,709 --> 00:17:29,639
means I can write out five tags worth of

00:17:28,139 --> 00:17:32,909
data which would be 50 samples alright

00:17:29,639 --> 00:17:35,700
five times ten and I can't write out any

00:17:32,909 --> 00:17:37,289
more data or tags until I get a message

00:17:35,700 --> 00:17:39,809
back that one of those tags has been

00:17:37,289 --> 00:17:42,090
consumed at the opera's event so once

00:17:39,809 --> 00:17:44,039
that once one comes back I can send one

00:17:42,090 --> 00:17:47,279
more out which would be ten more samples

00:17:44,039 --> 00:17:49,110
and so you you're basically creating a

00:17:47,279 --> 00:17:52,019
flow control that doesn't rely on back

00:17:49,110 --> 00:17:53,730
pressure between the blocks to to keep

00:17:52,019 --> 00:17:55,830
everything from filling up and this is

00:17:53,730 --> 00:17:58,530
actually very similar to what you syrup

00:17:55,830 --> 00:18:03,330
uses between uhd on the

00:17:58,530 --> 00:18:05,550
and the physical Hardware on on across

00:18:03,330 --> 00:18:07,740
the Ethernet right we send out the

00:18:05,550 --> 00:18:09,810
samples and only when they're consumed

00:18:07,740 --> 00:18:11,760
the the usurp itself says okay I

00:18:09,810 --> 00:18:14,220
finished those you I've got more space

00:18:11,760 --> 00:18:16,110
and you can send more and that and that

00:18:14,220 --> 00:18:17,850
actually is because Ethernet does not

00:18:16,110 --> 00:18:20,310
have flow control or it has flow control

00:18:17,850 --> 00:18:22,350
but it doesn't work for any realistic

00:18:20,310 --> 00:18:23,970
application and you should never use

00:18:22,350 --> 00:18:25,880
Ethernet flow control it's evil we did

00:18:23,970 --> 00:18:30,540
that in very very early days of usurp -

00:18:25,880 --> 00:18:32,130
and instead anything that you you sent

00:18:30,540 --> 00:18:33,930
across would would get dropped because

00:18:32,130 --> 00:18:36,270
there's no back pressure and so we had

00:18:33,930 --> 00:18:38,610
to build our own back pressure into the

00:18:36,270 --> 00:18:41,220
into the back into the host code in

00:18:38,610 --> 00:18:43,020
radio by doing this flow control over

00:18:41,220 --> 00:18:46,350
the wire and so all I've done here is

00:18:43,020 --> 00:18:50,370
extend that style of flow control to the

00:18:46,350 --> 00:18:52,350
flow graph and so this controls you know

00:18:50,370 --> 00:18:53,370
how much is in flight so in this case 50

00:18:52,350 --> 00:18:56,910
items is in flight

00:18:53,370 --> 00:18:58,530
now obviously you know to lower the

00:18:56,910 --> 00:19:00,630
latency you have the minimum number

00:18:58,530 --> 00:19:03,390
right so we could put you know one tag

00:19:00,630 --> 00:19:06,290
with one sample in it but what happens

00:19:03,390 --> 00:19:10,140
if you do if you make it too low is that

00:19:06,290 --> 00:19:12,780
you're now you now consume a sample and

00:19:10,140 --> 00:19:15,210
you have nothing waiting after it right

00:19:12,780 --> 00:19:16,500
so so you have to have a sort of a

00:19:15,210 --> 00:19:19,200
minimum amount of latency and that's

00:19:16,500 --> 00:19:21,210
really controlled by how fast the

00:19:19,200 --> 00:19:22,620
processing happens so if we have more

00:19:21,210 --> 00:19:24,020
and more complicated processing we have

00:19:22,620 --> 00:19:26,970
to have a little bit more in flight

00:19:24,020 --> 00:19:30,060
because the we have we can't attempt to

00:19:26,970 --> 00:19:32,010
make our buffer and dus latency hide the

00:19:30,060 --> 00:19:34,770
natural latency that the computation

00:19:32,010 --> 00:19:35,910
actually has so if you have very complex

00:19:34,770 --> 00:19:37,140
computation there you're gonna have to

00:19:35,910 --> 00:19:38,940
make the you're gonna have to allow the

00:19:37,140 --> 00:19:41,190
buffers to cover that otherwise you'll

00:19:38,940 --> 00:19:42,960
get under runs so with audio it's

00:19:41,190 --> 00:19:45,390
actually very hard to in to create an

00:19:42,960 --> 00:19:48,930
under run on the computer but if I set

00:19:45,390 --> 00:19:51,930
this to 1 and 1 or sorry I'm tagging

00:19:48,930 --> 00:19:53,970
interval so let's set it to 1 in 1 which

00:19:51,930 --> 00:19:55,940
basically lets one sample out and it's

00:19:53,970 --> 00:20:00,000
consumed then you can start the next one

00:19:55,940 --> 00:20:05,040
this actually may even work or some

00:20:00,000 --> 00:20:07,980
other issue but let's make it really

00:20:05,040 --> 00:20:11,780
really small let's do two tags and an

00:20:07,980 --> 00:20:11,780
interval of to see if that

00:20:12,390 --> 00:20:16,110
okay there's

00:20:22,200 --> 00:20:26,440
okay yes so you can make it incredibly

00:20:24,700 --> 00:20:26,980
small and we don't see any audio

00:20:26,440 --> 00:20:29,140
underruns

00:20:26,980 --> 00:20:30,280
if this was on a user P we might have to

00:20:29,140 --> 00:20:31,870
make it bigger because you might be

00:20:30,280 --> 00:20:34,060
consuming mega samples per second and

00:20:31,870 --> 00:20:36,820
the natural processing is not going to

00:20:34,060 --> 00:20:39,250
be in the nanosecond so you have to

00:20:36,820 --> 00:20:40,720
adjust that so but the bigger we make

00:20:39,250 --> 00:20:42,760
this the more latency we had so if we

00:20:40,720 --> 00:20:45,760
allow this if I change this maximum tags

00:20:42,760 --> 00:20:48,040
to 2,000 tags in flight and I only

00:20:45,760 --> 00:20:49,870
tagged every you know thousand samples

00:20:48,040 --> 00:20:51,730
that's basically two million tags in

00:20:49,870 --> 00:20:53,890
flight which is actually more than the

00:20:51,730 --> 00:20:55,240
latency sorry two million samples in

00:20:53,890 --> 00:20:56,740
flight which is actually more than the

00:20:55,240 --> 00:20:58,930
size of the buffers so this makes it

00:20:56,740 --> 00:21:02,620
essentially do nothing and we get back

00:20:58,930 --> 00:21:04,120
to our same issue of the long delay so

00:21:02,620 --> 00:21:08,620
so this allows you to control the

00:21:04,120 --> 00:21:12,250
maximum latency through there so how do

00:21:08,620 --> 00:21:16,890
we how do we do this let me go back to

00:21:12,250 --> 00:21:21,280
the presentation here so really the the

00:21:16,890 --> 00:21:22,510
that the stream two tags block is is is

00:21:21,280 --> 00:21:23,890
pretty simple so I won't bother with

00:21:22,510 --> 00:21:25,510
that but this is the latency manager

00:21:23,890 --> 00:21:27,010
code itself and you can see it's

00:21:25,510 --> 00:21:30,970
actually a very small work function so

00:21:27,010 --> 00:21:32,650
this is a a-actually async block we

00:21:30,970 --> 00:21:35,200
didn't even need to use you know sort of

00:21:32,650 --> 00:21:37,210
a general work kind of function but what

00:21:35,200 --> 00:21:39,160
we do is we copy the first thing we do

00:21:37,210 --> 00:21:41,320
is we figure out how many items are we

00:21:39,160 --> 00:21:43,920
allowed to send which is the it's the

00:21:41,320 --> 00:21:49,630
minimum of how many items do I have and

00:21:43,920 --> 00:21:51,310
how many items I have left in the Masson

00:21:49,630 --> 00:21:53,680
the number of tokens I've received from

00:21:51,310 --> 00:21:56,470
the tags that come back and based on

00:21:53,680 --> 00:21:58,690
that we just copy those we decrement our

00:21:56,470 --> 00:22:02,020
counters we add tags on them as

00:21:58,690 --> 00:22:04,810
necessary and and we send it and and you

00:22:02,020 --> 00:22:07,330
will notice there's one part here at the

00:22:04,810 --> 00:22:10,000
bottom if we've copied nothing because

00:22:07,330 --> 00:22:11,860
we have no tokens if we were to just

00:22:10,000 --> 00:22:13,540
return zero we would immediately get

00:22:11,860 --> 00:22:15,580
called again and we'd spin lock on the

00:22:13,540 --> 00:22:17,650
on the processor so instead we put a

00:22:15,580 --> 00:22:19,750
small sleep there in this case I think

00:22:17,650 --> 00:22:21,100
it's a hundred microseconds so you put

00:22:19,750 --> 00:22:25,690
that sleep so you don't keep getting

00:22:21,100 --> 00:22:27,160
called and and waste CPU and you can

00:22:25,690 --> 00:22:30,310
experiment with different sizes for that

00:22:27,160 --> 00:22:31,450
based on the the latency for audio we

00:22:30,310 --> 00:22:34,600
can put it make it more like a

00:22:31,450 --> 00:22:35,380
millisecond that's fine and the only

00:22:34,600 --> 00:22:39,340
other thing in here

00:22:35,380 --> 00:22:42,610
is there's a function in in there - in

00:22:39,340 --> 00:22:44,080
the block to receive the the tokens on

00:22:42,610 --> 00:22:45,549
the message port and all it does is

00:22:44,080 --> 00:22:47,650
every time it receives a token that

00:22:45,549 --> 00:22:49,240
matches it increments the counter and

00:22:47,650 --> 00:22:51,039
every time we use one we decrement the

00:22:49,240 --> 00:22:52,539
counter and as long as you have your

00:22:51,039 --> 00:22:54,700
counters greater than zero you can send

00:22:52,539 --> 00:22:57,250
samples so it's really straightforward

00:22:54,700 --> 00:22:59,860
and actually ideally you know late

00:22:57,250 --> 00:23:03,010
latency manager has this will work in a

00:22:59,860 --> 00:23:05,470
lot of use cases but this this

00:23:03,010 --> 00:23:08,620
functionality really should be in put

00:23:05,470 --> 00:23:12,190
into your source block because what we

00:23:08,620 --> 00:23:14,470
end up with here is the latency is

00:23:12,190 --> 00:23:17,049
actually controlled inside the graph so

00:23:14,470 --> 00:23:19,690
between this this feedback loop of this

00:23:17,049 --> 00:23:23,380
point to this point but any latency

00:23:19,690 --> 00:23:24,730
outside there is uncontrolled so ideally

00:23:23,380 --> 00:23:29,590
everything is inside the loop and it's

00:23:24,730 --> 00:23:31,360
okay but if it's not it helps to to put

00:23:29,590 --> 00:23:33,520
this functionality directly in your

00:23:31,360 --> 00:23:35,260
ultimate source at the beginning right

00:23:33,520 --> 00:23:37,390
so if you have something as deciding

00:23:35,260 --> 00:23:40,150
whether to send an idle message or or

00:23:37,390 --> 00:23:41,679
the signal you should that's where you

00:23:40,150 --> 00:23:43,780
should be receiving the tag so you know

00:23:41,679 --> 00:23:45,039
when you need the idle message right so

00:23:43,780 --> 00:23:46,450
this is more general it's easy to drag

00:23:45,039 --> 00:23:47,590
and drop but this is really

00:23:46,450 --> 00:23:51,159
functionality you should put in your

00:23:47,590 --> 00:23:56,020
source similarly it would be useful to

00:23:51,159 --> 00:23:58,659
put the the the consumption of the tacks

00:23:56,020 --> 00:24:01,630
in your sink itself because what happens

00:23:58,659 --> 00:24:04,809
here is this tag to message block sees

00:24:01,630 --> 00:24:08,350
the same buffer as the audio sink but

00:24:04,809 --> 00:24:11,380
the audio sink you know can allow that

00:24:08,350 --> 00:24:12,730
buffer to back up and our tag to buffer

00:24:11,380 --> 00:24:15,460
is finding stuff at the beginning of the

00:24:12,730 --> 00:24:17,950
buffer that is not yet consumed so we

00:24:15,460 --> 00:24:19,690
you still have the the buffer sorry the

00:24:17,950 --> 00:24:21,640
yet the size of the buffer adding to

00:24:19,690 --> 00:24:23,530
your latency that's outside this loop so

00:24:21,640 --> 00:24:25,270
ideally this functionality of the tag to

00:24:23,530 --> 00:24:28,270
message should be included in the audio

00:24:25,270 --> 00:24:30,010
sink or the usurp sink or whatever is

00:24:28,270 --> 00:24:32,950
the ultimate consumer and in that case

00:24:30,010 --> 00:24:33,250
you have full full you know start to

00:24:32,950 --> 00:24:37,840
finish

00:24:33,250 --> 00:24:39,880
latency control so so that's the code so

00:24:37,840 --> 00:24:41,470
use cases you'll see this in a lot of

00:24:39,880 --> 00:24:43,809
continuous transmission so interactive

00:24:41,470 --> 00:24:45,549
signal generators right if you too much

00:24:43,809 --> 00:24:47,440
processing and you slide your frequency

00:24:45,549 --> 00:24:49,600
slider you'll see that the signal takes

00:24:47,440 --> 00:24:52,480
a while to move so signal

00:24:49,600 --> 00:24:55,210
Raiders a bunch of ham radio mode cwr

00:24:52,480 --> 00:24:57,910
TTY PSK 31 all have idle modes and

00:24:55,210 --> 00:25:00,930
you'll run into this issue their Deadman

00:24:57,910 --> 00:25:03,490
switches satellite telemetry links

00:25:00,930 --> 00:25:06,640
anytime your muxing a bunch of data in a

00:25:03,490 --> 00:25:09,340
downlink on a satellite that sort of

00:25:06,640 --> 00:25:10,660
thing you can also use this to create a

00:25:09,340 --> 00:25:12,880
true priority MUX

00:25:10,660 --> 00:25:16,330
which you can't otherwise do in canoe

00:25:12,880 --> 00:25:17,950
radio so you send the high priority when

00:25:16,330 --> 00:25:21,640
it's there and fill in with low priority

00:25:17,950 --> 00:25:23,260
when it's not also this is very

00:25:21,640 --> 00:25:26,800
important for real-time control systems

00:25:23,260 --> 00:25:28,480
if you have Hardware in the loop and you

00:25:26,800 --> 00:25:31,450
can actually extend this Hulk this

00:25:28,480 --> 00:25:34,060
concept to mixed rate flow graphs so if

00:25:31,450 --> 00:25:36,520
anybody has ever done the you know the

00:25:34,060 --> 00:25:38,800
sort of canonical wideband FM receiver

00:25:36,520 --> 00:25:41,260
where you have a UHD source the wideband

00:25:38,800 --> 00:25:44,290
FM D mod and then an audio sync but the

00:25:41,260 --> 00:25:45,400
audio sample rate is not exactly 30 mm

00:25:44,290 --> 00:25:47,980
and the usurped sample rate is not

00:25:45,400 --> 00:25:50,710
exactly 100 million or whatever and if

00:25:47,980 --> 00:25:52,300
if the usurps a little faster then you

00:25:50,710 --> 00:25:54,130
build up a lot of samples in here and

00:25:52,300 --> 00:25:56,410
then there's a lot of delay and

00:25:54,130 --> 00:25:58,060
eventually there's drops or if the

00:25:56,410 --> 00:26:00,910
usurps a little slower and the the audio

00:25:58,060 --> 00:26:02,650
sync is a little faster than then you

00:26:00,910 --> 00:26:04,360
get audio clicks and under runs because

00:26:02,650 --> 00:26:06,100
there's not enough samples percolating

00:26:04,360 --> 00:26:12,310
through so what what you need to do

00:26:06,100 --> 00:26:14,680
there is is the it is a controlled

00:26:12,310 --> 00:26:16,690
resampler and so this is a you know a

00:26:14,680 --> 00:26:19,270
hypothetical diagram instead of sending

00:26:16,690 --> 00:26:20,890
the wideband FM receiver to audio sync

00:26:19,270 --> 00:26:22,330
you would send it through a latency

00:26:20,890 --> 00:26:24,520
manager that had an output that

00:26:22,330 --> 00:26:26,530
controlled a fractional resampler and so

00:26:24,520 --> 00:26:28,090
you don't just have to control for not

00:26:26,530 --> 00:26:29,920
more than a certain number of buffers of

00:26:28,090 --> 00:26:31,630
the data items in flight but you can

00:26:29,920 --> 00:26:33,940
also control for not less than a certain

00:26:31,630 --> 00:26:37,230
number of data items in flight and so if

00:26:33,940 --> 00:26:40,060
there's too few data items in flight you

00:26:37,230 --> 00:26:41,530
you slow down your resampler or you make

00:26:40,060 --> 00:26:44,560
it generate more outputs for the same

00:26:41,530 --> 00:26:46,720
input and if it's if there's too many in

00:26:44,560 --> 00:26:48,820
flight you you do the reverse and you

00:26:46,720 --> 00:26:50,680
make it output fewer items for the input

00:26:48,820 --> 00:26:53,500
and if you do it properly and you smooth

00:26:50,680 --> 00:26:55,900
that out it's not perceivable to the

00:26:53,500 --> 00:26:58,540
user and this is actually how how things

00:26:55,900 --> 00:27:00,400
effectively work in like when you do

00:26:58,540 --> 00:27:02,020
Bluetooth audio for example right the

00:27:00,400 --> 00:27:03,280
Bluetooth clock in the audio clock are

00:27:02,020 --> 00:27:05,260
not synchronized and

00:27:03,280 --> 00:27:07,960
Audio is running too fast you'd get

00:27:05,260 --> 00:27:10,540
clicks and so you do this in software in

00:27:07,960 --> 00:27:13,830
that case but you can but you have to

00:27:10,540 --> 00:27:16,570
sort of slide your sample rate clock to

00:27:13,830 --> 00:27:20,050
effectively long term average match the

00:27:16,570 --> 00:27:25,360
the the hardware clock simply by doing

00:27:20,050 --> 00:27:27,820
this resampling so you can and finally

00:27:25,360 --> 00:27:29,530
you can also handle under runs nicely so

00:27:27,820 --> 00:27:31,360
if you actually really do have some

00:27:29,530 --> 00:27:33,700
complex processing that has a lot of

00:27:31,360 --> 00:27:35,590
natural latency and you find that you

00:27:33,700 --> 00:27:39,100
don't have a sample to send the latency

00:27:35,590 --> 00:27:42,250
manager can then automatically insert or

00:27:39,100 --> 00:27:46,510
automatically control the the resampler

00:27:42,250 --> 00:27:48,040
so that so that you can sort of spread

00:27:46,510 --> 00:27:52,270
out those those symbols that you've

00:27:48,040 --> 00:27:53,500
already created and and you know not end

00:27:52,270 --> 00:27:57,640
up with under runs and clicks and pops

00:27:53,500 --> 00:27:59,740
and things like that so as I said

00:27:57,640 --> 00:28:01,060
limitation is that it's only only

00:27:59,740 --> 00:28:02,770
controlled buffers within the feedback

00:28:01,060 --> 00:28:04,750
loop so really your source should

00:28:02,770 --> 00:28:07,380
implement the manager and your sync

00:28:04,750 --> 00:28:11,530
should report the tags and actually

00:28:07,380 --> 00:28:13,630
ideally you would you would you use the

00:28:11,530 --> 00:28:15,880
actual consumption of the sample all the

00:28:13,630 --> 00:28:18,910
way at the endpoints so you HD could be

00:28:15,880 --> 00:28:23,080
extended to report not when it has sent

00:28:18,910 --> 00:28:25,600
the data out to to the hardware and and

00:28:23,080 --> 00:28:28,360
has consumed it in the flow graph but it

00:28:25,600 --> 00:28:32,140
can report the tag when the that sample

00:28:28,360 --> 00:28:33,430
has been sent to the DAC and and and

00:28:32,140 --> 00:28:34,720
that's already part of the flow control

00:28:33,430 --> 00:28:35,920
so this really it doesn't even need to

00:28:34,720 --> 00:28:38,140
change in the FPGA it only needs to

00:28:35,920 --> 00:28:42,010
change in the user sink or the uhd-sync

00:28:38,140 --> 00:28:44,020
to to report the tag back at the right

00:28:42,010 --> 00:28:45,520
time and that would allow you to control

00:28:44,020 --> 00:28:47,620
because even if you control this this

00:28:45,520 --> 00:28:49,090
latency within your the flow graph you

00:28:47,620 --> 00:28:50,470
see in kinder radio if you then have a

00:28:49,090 --> 00:28:51,970
megabyte of buffering in your hardware

00:28:50,470 --> 00:28:53,590
it's not gonna help right you still have

00:28:51,970 --> 00:28:55,750
a huge amount of buffering there so you

00:28:53,590 --> 00:28:57,280
can you can make it full round-trip so

00:28:55,750 --> 00:29:00,820
keep everything in the control loop and

00:28:57,280 --> 00:29:03,370
and you can you know control the whole

00:29:00,820 --> 00:29:05,410
latency so audio sinks and UHD syncs

00:29:03,370 --> 00:29:09,340
would ideally have this capability as

00:29:05,410 --> 00:29:09,820
well so the actual implementation this

00:29:09,340 --> 00:29:12,430
code

00:29:09,820 --> 00:29:14,950
dereck worked with me while we were in

00:29:12,430 --> 00:29:16,900
Berlin a few weeks ago so thanks to

00:29:14,950 --> 00:29:20,610
Derek for that and you can

00:29:16,900 --> 00:29:24,040
find the code on on his github and

00:29:20,610 --> 00:29:26,740
contact with email and and like

00:29:24,040 --> 00:29:29,110
apparently everybody else here I am

00:29:26,740 --> 00:29:33,070
hiring I work at Apple although not on

00:29:29,110 --> 00:29:34,720
this specific project and we're looking

00:29:33,070 --> 00:29:36,610
for interns and full time and anybody

00:29:34,720 --> 00:29:39,520
who's into communication systems and

00:29:36,610 --> 00:29:49,960
software engineering so anyway thank you

00:29:39,520 --> 00:29:51,340
and let's link Matt we have two minutes

00:29:49,960 --> 00:29:54,060
for questions there's any questions for

00:29:51,340 --> 00:29:54,060
the audience yep

00:29:56,010 --> 00:30:00,280
do you think this solution is something

00:29:58,150 --> 00:30:01,960
we can kind of build into getting a

00:30:00,280 --> 00:30:04,000
radio without thinking about it anymore

00:30:01,960 --> 00:30:07,000
is it always gonna be a case-by-case you

00:30:04,000 --> 00:30:09,640
have to just do it when you need it uh I

00:30:07,000 --> 00:30:11,590
as in I mean I think the best way to

00:30:09,640 --> 00:30:14,800
handle that would be to make it the

00:30:11,590 --> 00:30:18,610
default that syncs report tags for

00:30:14,800 --> 00:30:20,260
consumption and that sources act or

00:30:18,610 --> 00:30:22,450
sources receive them and do something

00:30:20,260 --> 00:30:24,760
intelligent with them there's a lot of

00:30:22,450 --> 00:30:26,170
cases where you don't like run into this

00:30:24,760 --> 00:30:27,790
so if you haven't just a truly bursty

00:30:26,170 --> 00:30:30,300
communication system that does nothing

00:30:27,790 --> 00:30:33,210
in between this won't really affect that

00:30:30,300 --> 00:30:35,950
it really only affects the cases where

00:30:33,210 --> 00:30:41,500
you're you're you're making a decision

00:30:35,950 --> 00:30:42,730
about what to generate and and you need

00:30:41,500 --> 00:30:44,230
that to percolate very quickly but

00:30:42,730 --> 00:30:47,710
you're continuously generating something

00:30:44,230 --> 00:30:49,510
otherwise so so I would like to see it

00:30:47,710 --> 00:30:52,180
standardize that hardware interfaces at

00:30:49,510 --> 00:30:54,340
the end report the tags and and then

00:30:52,180 --> 00:30:55,420
your source can can handle it and you

00:30:54,340 --> 00:30:59,050
know make these blocks part of the

00:30:55,420 --> 00:31:00,390
standard distribution any other

00:30:59,050 --> 00:31:03,670
questions

00:31:00,390 --> 00:31:04,510
no all right with that then we are going

00:31:03,670 --> 00:31:05,920
to break for lunch

00:31:04,510 --> 00:31:07,390
thank you see you all back here in an

00:31:05,920 --> 00:31:10,859
hour thanks again Matt

00:31:07,390 --> 00:31:10,859

YouTube URL: https://www.youtube.com/watch?v=jq0RewceCwc


