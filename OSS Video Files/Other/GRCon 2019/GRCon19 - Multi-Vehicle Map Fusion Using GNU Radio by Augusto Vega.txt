Title: GRCon19 - Multi-Vehicle Map Fusion Using GNU Radio by Augusto Vega
Publication date: 2019-11-05
Playlist: GRCon 2019
Description: 
	Multi-Vehicle Map Fusion Using GNU Radio by Augusto Vega

In this paper, we present a representative open-source application for fully/semi autonomous vehicles operating as a collaborative swarm using GNU Radio. This application is the driver of our PROJECT-NAME* project, focusing on system-on-a-chip (SoC) development. The PROJECT-NAME* Reference Application (ERA) incorporates local sensing, creation of occupancy grid maps, vehicle-to-vehicle (V2V) communication of grid maps between neighboring vehicles using a GNU Radio implementation of dedicated short-range communications (DSRC), and map fusion to create a joint higher accurate grid map. In this paper, we also analyze the GNU Radio-based DSRC transceiver workload on a Xilinx UltraScale+ ZCU102 board, and identify computation kernels for software or hardware acceleration. In particular, we present optimizations of complex exponentiation and Viterbi decoding that result in a measured 24% throughput improvement, with potential for up to 58% throughput improvement with additional optimizations.

Project name removed to comply with the double blind review process.
Captions: 
	00:00:14,660 --> 00:00:19,260
okay so good morning everyone my name is

00:00:17,430 --> 00:00:21,360
Alistair Vega from IBM TG Watson

00:00:19,260 --> 00:00:23,430
Research Center today I will talk about

00:00:21,360 --> 00:00:26,160
some work that we are conducting in the

00:00:23,430 --> 00:00:28,160
context of multi vehicle map fusion or

00:00:26,160 --> 00:00:30,380
perception you see in new radio

00:00:28,160 --> 00:00:32,099
specifically I will present some

00:00:30,380 --> 00:00:34,770
optimization and acceleration

00:00:32,099 --> 00:00:38,910
opportunities that we have in 25 and

00:00:34,770 --> 00:00:41,040
explore and study this is a relatively

00:00:38,910 --> 00:00:43,770
large project so let me and knowledge

00:00:41,040 --> 00:00:46,350
not only were IVN collaborators but also

00:00:43,770 --> 00:00:48,839
our university partners which include

00:00:46,350 --> 00:00:50,370
Harvard University Columbia and the

00:00:48,839 --> 00:00:53,100
University of Illinois at

00:00:50,370 --> 00:00:55,949
urbana-champaign plus all the brilliant

00:00:53,100 --> 00:00:59,399
students postdocs who are doing amazing

00:00:55,949 --> 00:01:01,109
work here special thanks also to dr. Tom

00:00:59,399 --> 00:01:03,449
Randolph with the program manager of the

00:01:01,109 --> 00:01:06,090
DARPA sponsored azad program who and

00:01:03,449 --> 00:01:10,760
under which we are developing this this

00:01:06,090 --> 00:01:13,470
work so today I will start talking about

00:01:10,760 --> 00:01:15,210
let's say an umbrella research topic

00:01:13,470 --> 00:01:18,750
something that we call adaptive swarm

00:01:15,210 --> 00:01:23,399
intelligence which is or we hope it will

00:01:18,750 --> 00:01:25,200
be a novel computation paradigm then I

00:01:23,399 --> 00:01:27,420
will go into more specific I will

00:01:25,200 --> 00:01:29,969
represent our DARPA sponsz or a pox

00:01:27,420 --> 00:01:33,509
project which revolves around these

00:01:29,969 --> 00:01:34,950
adaptive swarm intelligence idea we have

00:01:33,509 --> 00:01:38,070
developed under that project an

00:01:34,950 --> 00:01:41,520
application for connected autonomous

00:01:38,070 --> 00:01:43,439
cars and then as a result I will focus

00:01:41,520 --> 00:01:46,399
on one specific piece of that

00:01:43,439 --> 00:01:49,079
application which is a neo 2.11 P

00:01:46,399 --> 00:01:51,049
transceiver using new radio and some

00:01:49,079 --> 00:01:52,829
performance optimizations and

00:01:51,049 --> 00:01:57,750
exploration that we have done of that

00:01:52,829 --> 00:01:59,600
specific piece of the code so we all

00:01:57,750 --> 00:02:02,520
know very well that the number of

00:01:59,600 --> 00:02:04,079
connected devices is growing very fast

00:02:02,520 --> 00:02:06,240
and will keep growing

00:02:04,079 --> 00:02:08,610
some people say we will have like 80 or

00:02:06,240 --> 00:02:11,130
100 billion connected devices in the war

00:02:08,610 --> 00:02:14,040
in a few years generating huge amount of

00:02:11,130 --> 00:02:15,840
data the way we have a ball so far is

00:02:14,040 --> 00:02:17,840
very device centric putting our

00:02:15,840 --> 00:02:20,700
attention in making those devices us

00:02:17,840 --> 00:02:23,190
powerful and capable as possible by

00:02:20,700 --> 00:02:24,690
making them putting more let's say

00:02:23,190 --> 00:02:26,459
computational resources on the devices

00:02:24,690 --> 00:02:27,750
in the case of the car putting more

00:02:26,459 --> 00:02:31,470
sophisticated sensors

00:02:27,750 --> 00:02:35,040
or etc we believe that we can exploit

00:02:31,470 --> 00:02:37,890
the brush an alternative approach which

00:02:35,040 --> 00:02:39,510
is the swarming approach trying to make

00:02:37,890 --> 00:02:42,720
those devices to collaborate collaborate

00:02:39,510 --> 00:02:45,420
to each other in order to enable a level

00:02:42,720 --> 00:02:47,940
of cognition and adaptability to ants in

00:02:45,420 --> 00:02:50,430
circumstances that can only emerge

00:02:47,940 --> 00:02:52,170
synergistically from the swarm but not

00:02:50,430 --> 00:02:54,959
from individual devices so that is the

00:02:52,170 --> 00:02:57,120
ultimate goal of this paradigm we also

00:02:54,959 --> 00:03:00,900
believe that swarm intelligence can help

00:02:57,120 --> 00:03:03,989
devices to learn from each other to

00:03:00,900 --> 00:03:07,800
exchange experience to exchange

00:03:03,989 --> 00:03:09,540
knowledge in order to learn over time

00:03:07,800 --> 00:03:12,180
and this is probably one of the most

00:03:09,540 --> 00:03:14,640
important differences compared to

00:03:12,180 --> 00:03:17,610
traditional swarm intelligence we are

00:03:14,640 --> 00:03:19,020
devices basically follow simple fixed

00:03:17,610 --> 00:03:21,209
rules so that is probably one of the

00:03:19,020 --> 00:03:23,160
noble part of this adaptive swarm

00:03:21,209 --> 00:03:26,670
intelligence paradigm so this is not

00:03:23,160 --> 00:03:28,680
just distributed computing it's beyond

00:03:26,670 --> 00:03:30,690
that right we want these devices to

00:03:28,680 --> 00:03:34,680
learn from each other to evolve over

00:03:30,690 --> 00:03:37,230
time why we think other people tradition

00:03:34,680 --> 00:03:40,350
is going to happen soon if we look back

00:03:37,230 --> 00:03:42,390
where we can remember that in the 90s I

00:03:40,350 --> 00:03:44,790
mean smallest K processors fueled by

00:03:42,390 --> 00:03:48,690
very large scale integration gave rise

00:03:44,790 --> 00:03:52,170
to mobile computing right then we have

00:03:48,690 --> 00:03:54,299
pervasive sensing where which way every

00:03:52,170 --> 00:03:56,700
physical device became a source of data

00:03:54,299 --> 00:03:59,640
so these two enablers a small sk

00:03:56,700 --> 00:04:03,660
processor plus erase it sensing gave

00:03:59,640 --> 00:04:07,140
rise to the IOT revolution what we have

00:04:03,660 --> 00:04:09,360
now what we have very soon is ultra

00:04:07,140 --> 00:04:12,360
high-bandwidth low-latency connectivity

00:04:09,360 --> 00:04:14,760
for example through cellular phi g right

00:04:12,360 --> 00:04:18,090
and we believe these are the three key

00:04:14,760 --> 00:04:20,760
ingredients to enable the next big

00:04:18,090 --> 00:04:24,470
revolution which we hope will be along

00:04:20,760 --> 00:04:24,470
the lines of adaptive swarm intelligence

00:04:24,770 --> 00:04:29,520
adopt its own intelligence ASI has

00:04:27,200 --> 00:04:31,560
applications in multiple domains going

00:04:29,520 --> 00:04:34,140
from network cyber security connected

00:04:31,560 --> 00:04:37,650
cars unmanned aerial vehicles or in

00:04:34,140 --> 00:04:39,539
general cyber physical systems but today

00:04:37,650 --> 00:04:42,310
I will focus on the case of connected

00:04:39,539 --> 00:04:45,710
and autonomous vehicles

00:04:42,310 --> 00:04:48,380
if we look into the how cars are

00:04:45,710 --> 00:04:50,450
evolving and how automakers are thinking

00:04:48,380 --> 00:04:53,360
about future connected and autonomous

00:04:50,450 --> 00:04:56,030
cars we will see that again I mean the

00:04:53,360 --> 00:04:57,980
prose is mostly car sending we are

00:04:56,030 --> 00:05:00,800
trying to put more sophisticated sensors

00:04:57,980 --> 00:05:02,660
in the car lidar radars camera etc we

00:05:00,800 --> 00:05:05,660
are trying to put more powerful

00:05:02,660 --> 00:05:07,790
computers on board right but that car

00:05:05,660 --> 00:05:09,290
centric approach we believe still has

00:05:07,790 --> 00:05:11,810
some limitation I mean this is a very

00:05:09,290 --> 00:05:14,090
simple example where a car is the doing

00:05:11,810 --> 00:05:16,580
an object recognition and properly

00:05:14,090 --> 00:05:20,540
identifies two cars in front of it but

00:05:16,580 --> 00:05:23,900
also identifies a person and a few

00:05:20,540 --> 00:05:26,330
bicycles which in reality are just the

00:05:23,900 --> 00:05:28,340
Carl stick on the back of the car in

00:05:26,330 --> 00:05:30,500
front of it right so this is a very

00:05:28,340 --> 00:05:32,900
simple example of Mis classification or

00:05:30,500 --> 00:05:35,720
false prediction brain so we believe

00:05:32,900 --> 00:05:37,340
that if we exploit the interaction

00:05:35,720 --> 00:05:39,950
within vehicles in something that is

00:05:37,340 --> 00:05:41,960
usually known as multi be a comparative

00:05:39,950 --> 00:05:45,320
sensor fusion or comparative perception

00:05:41,960 --> 00:05:49,760
we can alleviate this kind of product

00:05:45,320 --> 00:05:51,860
right in other words if we want to

00:05:49,760 --> 00:05:54,290
significantly reduce the number of fall

00:05:51,860 --> 00:05:56,390
predictions and this is qualitatively I

00:05:54,290 --> 00:05:58,310
mean this is not a quantitative chart if

00:05:56,390 --> 00:06:00,860
we follow the car centric approach it

00:05:58,310 --> 00:06:02,660
doesn't matter how much computation

00:06:00,860 --> 00:06:06,560
power or sensing power we put on the car

00:06:02,660 --> 00:06:08,960
we won't be able to reduce that rate of

00:06:06,560 --> 00:06:11,419
false prediction that's significantly

00:06:08,960 --> 00:06:13,310
compared to case where we also follow

00:06:11,419 --> 00:06:15,680
this farm based approach so we are not

00:06:13,310 --> 00:06:17,030
saying that we have to get rid of the

00:06:15,680 --> 00:06:18,919
car centric approach of course I mean

00:06:17,030 --> 00:06:21,050
cars have to be more powerful of course

00:06:18,919 --> 00:06:25,280
but we should also explore the swarm in

00:06:21,050 --> 00:06:28,100
between the vehicles so with that in

00:06:25,280 --> 00:06:30,860
mind with that motivation in mind we

00:06:28,100 --> 00:06:32,900
started like one year ago this DARPA

00:06:30,860 --> 00:06:35,960
sponsored a box project in which you

00:06:32,900 --> 00:06:39,440
have developed an application for

00:06:35,960 --> 00:06:41,870
connected autonomous vehicles so this

00:06:39,440 --> 00:06:43,600
project the epics project is part of the

00:06:41,870 --> 00:06:44,960
DARPA sponsored domain-specific

00:06:43,600 --> 00:06:48,560
system-on-a-chip

00:06:44,960 --> 00:06:51,919
or this sub program led by dr. Tom Rando

00:06:48,560 --> 00:06:54,780
the main goal of the diesel program

00:06:51,919 --> 00:06:58,460
actually is to develop it

00:06:54,780 --> 00:07:03,900
genius hardware software platforms chips

00:06:58,460 --> 00:07:05,430
to basically meet some matrix of

00:07:03,900 --> 00:07:08,700
interest including performance

00:07:05,430 --> 00:07:12,270
throughput and power efficiency for a

00:07:08,700 --> 00:07:14,820
given application domain of interest in

00:07:12,270 --> 00:07:16,680
this context a domain is larger than an

00:07:14,820 --> 00:07:18,780
application actually in our project we

00:07:16,680 --> 00:07:21,960
talk about a super domain of connected

00:07:18,780 --> 00:07:23,880
and autonomous cars which integrates

00:07:21,960 --> 00:07:28,100
elements from for example computer

00:07:23,880 --> 00:07:28,100
vision as well as overly fun ready

00:07:28,130 --> 00:07:32,820
so the efficient primary probability of

00:07:30,870 --> 00:07:35,850
cognitive ethology no systems which is

00:07:32,820 --> 00:07:36,930
this box project led by IBM with our our

00:07:35,850 --> 00:07:39,360
university partners

00:07:36,930 --> 00:07:41,040
it's our proposed solution for the

00:07:39,360 --> 00:07:42,330
design challenge presented by the desaad

00:07:41,040 --> 00:07:44,790
program based it's a very large

00:07:42,330 --> 00:07:47,520
relatively large project so I cannot

00:07:44,790 --> 00:07:50,010
cover all of it but basically what we

00:07:47,520 --> 00:07:52,110
are trying to do is to take this box

00:07:50,010 --> 00:07:54,780
reference application from the context

00:07:52,110 --> 00:07:57,210
of connected optimist vehicles and

00:07:54,780 --> 00:08:00,200
create a novel methodology that will

00:07:57,210 --> 00:08:04,830
allow us to generate the underline

00:08:00,200 --> 00:08:07,710
domain-specific SOC to execute such an

00:08:04,830 --> 00:08:09,450
application domain and meet some

00:08:07,710 --> 00:08:13,560
performance throughput and efficiency

00:08:09,450 --> 00:08:16,650
metrics so in this process we are

00:08:13,560 --> 00:08:19,380
working to develop an advanced compiler

00:08:16,650 --> 00:08:22,110
for this kind of scenarios and advanced

00:08:19,380 --> 00:08:24,780
OSS schedule scheduler for a true genius

00:08:22,110 --> 00:08:28,289
platform we are also creating algorithms

00:08:24,780 --> 00:08:30,600
for ontology discovery which basically

00:08:28,289 --> 00:08:33,180
means to analyze application and detect

00:08:30,600 --> 00:08:35,550
the more or less automatic manner what

00:08:33,180 --> 00:08:37,530
portions of the application are good

00:08:35,550 --> 00:08:39,830
candidates for Howell external hardware

00:08:37,530 --> 00:08:43,460
acceleration we are of course

00:08:39,830 --> 00:08:45,839
implemented a novel hardware axiom

00:08:43,460 --> 00:08:48,089
development methodology that at the

00:08:45,839 --> 00:08:50,910
beginning will involve FPGA prototyping

00:08:48,089 --> 00:08:53,970
but we also plan to tape out this chip

00:08:50,910 --> 00:08:57,480
so it's a relatively large a project

00:08:53,970 --> 00:08:59,160
that I cannot cover fully but today I

00:08:57,480 --> 00:09:00,780
will focus actually on only one piece

00:08:59,160 --> 00:09:05,459
which is this a box reference

00:09:00,780 --> 00:09:07,589
application so the box reference

00:09:05,459 --> 00:09:09,180
application or array as I mentioned

00:09:07,589 --> 00:09:11,880
before

00:09:09,180 --> 00:09:13,680
integrate together elements from

00:09:11,880 --> 00:09:17,750
computer vision and software-defined

00:09:13,680 --> 00:09:21,029
radio in a single open-source

00:09:17,750 --> 00:09:24,120
application or wardrobe so the

00:09:21,029 --> 00:09:26,550
communication fabric implements in a

00:09:24,120 --> 00:09:28,680
protocol is in radio for vehicle to

00:09:26,550 --> 00:09:33,209
vehicle communication a YouTube Pony

00:09:28,680 --> 00:09:35,970
leaven P while the sensing fabric takes

00:09:33,209 --> 00:09:37,980
care of all the sensing activities for

00:09:35,970 --> 00:09:41,850
example from cameras in the car as well

00:09:37,980 --> 00:09:44,339
as a generating a representation of the

00:09:41,850 --> 00:09:45,680
wall of the surrounding war in real-time

00:09:44,339 --> 00:09:48,089
in this case we are using

00:09:45,680 --> 00:09:50,010
two-dimensional occupants degree maps

00:09:48,089 --> 00:09:51,630
where I mean the car is Center in a

00:09:50,010 --> 00:09:53,459
two-dimensional and grid map with

00:09:51,630 --> 00:09:55,380
information about obstacles around the

00:09:53,459 --> 00:09:57,630
car so very very simple in this initial

00:09:55,380 --> 00:09:59,850
version that part I mean the sensing

00:09:57,630 --> 00:10:02,250
fabric is mostly implemented using the

00:09:59,850 --> 00:10:03,570
robot operating system rows so we are

00:10:02,250 --> 00:10:06,390
integrating together these two words

00:10:03,570 --> 00:10:09,000
radiant rows in the same software

00:10:06,390 --> 00:10:12,120
platform so array is actually one

00:10:09,000 --> 00:10:14,100
specific adaptive swarm intelligence use

00:10:12,120 --> 00:10:17,970
case may be a simple one but still one

00:10:14,100 --> 00:10:21,899
specific implementation of the ASI idea

00:10:17,970 --> 00:10:23,699
so you are I mean you're invited to to

00:10:21,899 --> 00:10:26,220
check out the code is open source and

00:10:23,699 --> 00:10:29,399
eventually reach out to us if you find

00:10:26,220 --> 00:10:33,690
any interest or any way to contribute to

00:10:29,399 --> 00:10:35,670
it so now I will focus on one specific

00:10:33,690 --> 00:10:38,760
element without within the array

00:10:35,670 --> 00:10:43,140
application which is this vehicle to be

00:10:38,760 --> 00:10:45,029
active communication box there actually

00:10:43,140 --> 00:10:47,970
this is a part that we didn't implement

00:10:45,029 --> 00:10:50,459
but we rely on open source and open

00:10:47,970 --> 00:10:53,070
source implementation of the you 2.11 P

00:10:50,459 --> 00:10:55,949
transceiver implemented in in radio by

00:10:53,070 --> 00:10:58,380
dr. bascomb Lewis so this code is

00:10:55,949 --> 00:11:00,390
available in this link here so we took

00:10:58,380 --> 00:11:04,860
that code and we integrated it into our

00:11:00,390 --> 00:11:06,390
main array platform so of course I mean

00:11:04,860 --> 00:11:10,490
numbers any transceiver we have a

00:11:06,390 --> 00:11:15,470
transmitter chain and a receiver chain

00:11:10,490 --> 00:11:17,850
so what we initially did is to conduct

00:11:15,470 --> 00:11:20,370
say very straightforward performance

00:11:17,850 --> 00:11:24,569
analysis of that

00:11:20,370 --> 00:11:26,819
transceiver and we detected that some

00:11:24,569 --> 00:11:29,610
blocks one in Braille in the receiver

00:11:26,819 --> 00:11:32,879
for example are the most CPU intensive

00:11:29,610 --> 00:11:35,399
ones and specifically within those

00:11:32,879 --> 00:11:37,709
blocks we identified two functions which

00:11:35,399 --> 00:11:39,809
is function to compute the complex

00:11:37,709 --> 00:11:41,910
exponent and another function to compute

00:11:39,809 --> 00:11:44,730
the Viterbi butterfly which are the most

00:11:41,910 --> 00:11:47,160
CPU or time-consuming ones within those

00:11:44,730 --> 00:11:48,839
those blocks so at the beginning we said

00:11:47,160 --> 00:11:51,709
okay let's focus on these two financials

00:11:48,839 --> 00:11:54,329
as two possible candidates for

00:11:51,709 --> 00:11:58,350
performance optimization and hardware

00:11:54,329 --> 00:12:02,300
acceleration another thing that we did I

00:11:58,350 --> 00:12:05,009
mean very very easy stuff here say ok

00:12:02,300 --> 00:12:06,749
let's try to measure I mean what is the

00:12:05,009 --> 00:12:08,490
potential performance benefit that we

00:12:06,749 --> 00:12:11,339
can get in return if we decide to

00:12:08,490 --> 00:12:14,100
optimize these two function so we took

00:12:11,339 --> 00:12:16,050
the transceiver we created the version

00:12:14,100 --> 00:12:17,850
that works in a loopback mode basically

00:12:16,050 --> 00:12:20,879
what we inject in the transmitter is fed

00:12:17,850 --> 00:12:23,279
back into the receiver and we measure

00:12:20,879 --> 00:12:25,019
the rate at which the receiver can

00:12:23,279 --> 00:12:26,249
decode data as a function of the rate at

00:12:25,019 --> 00:12:27,959
which we inject data into the

00:12:26,249 --> 00:12:31,230
transmitter which is this chart here

00:12:27,959 --> 00:12:33,629
ideally we want the receiver to keep the

00:12:31,230 --> 00:12:37,350
pace with it with a transmitter which is

00:12:33,629 --> 00:12:39,839
this ideal scale in line here but what

00:12:37,350 --> 00:12:43,199
we see in our baseline which is an arm

00:12:39,839 --> 00:12:44,670
cortex a53 processor is that we I mean

00:12:43,199 --> 00:12:48,389
the receiver actually hit like a

00:12:44,670 --> 00:12:52,199
saturation point right at certain around

00:12:48,389 --> 00:12:55,709
400 kilo bits per second right so we

00:12:52,199 --> 00:12:57,600
started measuring the same using an

00:12:55,709 --> 00:12:59,249
ideal version of the Viterbi function

00:12:57,600 --> 00:13:00,720
ideal means that we replace the original

00:12:59,249 --> 00:13:03,179
function with a function that is

00:13:00,720 --> 00:13:04,740
completely empty and just return a pre

00:13:03,179 --> 00:13:07,139
computed value I mean this is only to

00:13:04,740 --> 00:13:08,730
know what would be like the potential

00:13:07,139 --> 00:13:11,309
benefits for for that kind of

00:13:08,730 --> 00:13:13,559
optimization mean even if the

00:13:11,309 --> 00:13:16,740
computation is not a semantically a

00:13:13,559 --> 00:13:18,779
correct let's say with the same with the

00:13:16,740 --> 00:13:21,300
complex exponent which actually provides

00:13:18,779 --> 00:13:22,769
higher benefit of course I mean because

00:13:21,300 --> 00:13:25,079
this is the most time-consuming of the

00:13:22,769 --> 00:13:27,389
two functions and then we have measure

00:13:25,079 --> 00:13:30,299
the same have involved ideal version of

00:13:27,389 --> 00:13:32,370
Batarian complex exponent which provide

00:13:30,299 --> 00:13:34,020
a little bit more benefit so this is

00:13:32,370 --> 00:13:35,399
basically our upper bound

00:13:34,020 --> 00:13:39,180
in terms of how much performance

00:13:35,399 --> 00:13:40,950
improvement we can we can get then we

00:13:39,180 --> 00:13:43,020
focus on one of these two functions the

00:13:40,950 --> 00:13:45,480
complex exponent one and we executed it

00:13:43,020 --> 00:13:49,649
like across different platforms we

00:13:45,480 --> 00:13:52,080
started with baseline arm cortex a53 CPU

00:13:49,649 --> 00:13:56,130
and we measure that each invocation of

00:13:52,080 --> 00:13:58,860
that function takes around 37 CPU cycles

00:13:56,130 --> 00:14:01,490
and then we created our own hardware

00:13:58,860 --> 00:14:04,560
accelerator on an FPGA right this is a

00:14:01,490 --> 00:14:06,480
formula to compute a complex exponent so

00:14:04,560 --> 00:14:09,779
what we created was a dual that that

00:14:06,480 --> 00:14:11,370
data pod pipeline where one branch

00:14:09,779 --> 00:14:13,230
compute the exponent and the other

00:14:11,370 --> 00:14:15,779
branch computes the cosine and the sine

00:14:13,230 --> 00:14:17,820
and we multiplied them together at the

00:14:15,779 --> 00:14:21,870
end to generate the final complex

00:14:17,820 --> 00:14:23,580
exponent result and with this relatively

00:14:21,870 --> 00:14:26,279
straightforward implementation we

00:14:23,580 --> 00:14:30,149
managed to reduce the computation time

00:14:26,279 --> 00:14:32,339
from 37 to around 6 or 7 cycles per

00:14:30,149 --> 00:14:35,279
invocation although most of the time

00:14:32,339 --> 00:14:39,270
here is basically memory copy overhead

00:14:35,279 --> 00:14:41,940
which is not nice then we say ok let's

00:14:39,270 --> 00:14:44,370
do something even simpler let's create a

00:14:41,940 --> 00:14:46,620
vectorized version of that function

00:14:44,370 --> 00:14:49,230
using the arms in the extension the nyan

00:14:46,620 --> 00:14:52,709
extension and that was even better than

00:14:49,230 --> 00:14:55,529
our hardware accelerator we basically

00:14:52,709 --> 00:14:57,270
measure around 5 CPU cycles per

00:14:55,529 --> 00:14:59,700
invocation but that was because our

00:14:57,270 --> 00:15:02,070
hardware accelerator was pretty let's

00:14:59,700 --> 00:15:04,380
say conservative so we say ok let's

00:15:02,070 --> 00:15:07,579
think about extra optimizations for our

00:15:04,380 --> 00:15:09,810
Hardware put a accelerator and this is

00:15:07,579 --> 00:15:13,050
actually chassis projection we don't

00:15:09,810 --> 00:15:14,520
have this last part already implemented

00:15:13,050 --> 00:15:17,370
and tested and we think that we can

00:15:14,520 --> 00:15:20,490
increase the frequency significantly we

00:15:17,370 --> 00:15:23,100
can have 4 copies of this pipeline

00:15:20,490 --> 00:15:24,750
itself only 1 and more importantly we

00:15:23,100 --> 00:15:28,020
should be able to completely get rid of

00:15:24,750 --> 00:15:29,990
that memory copy overhead how do we do

00:15:28,020 --> 00:15:33,570
that so in terms of frequency scaling

00:15:29,990 --> 00:15:36,270
ECC I mean we cranked up frequency from

00:15:33,570 --> 00:15:38,310
in this case 100 to 300 mega mega Hertz

00:15:36,270 --> 00:15:39,779
but we have to be very careful we have

00:15:38,310 --> 00:15:41,880
to I mean

00:15:39,779 --> 00:15:44,279
basically take into account that they

00:15:41,880 --> 00:15:45,900
for example they excite interfaces in

00:15:44,279 --> 00:15:46,589
FPGA platform our stable at that

00:15:45,900 --> 00:15:47,310
frequency

00:15:46,589 --> 00:15:53,970
something

00:15:47,310 --> 00:15:56,760
we believe happens then having multiple

00:15:53,970 --> 00:15:59,450
copies of the accelerator ECC but we

00:15:56,760 --> 00:16:03,330
need enough FPGA real estate and we need

00:15:59,450 --> 00:16:05,970
enough a bi-level ax i interfaces so we

00:16:03,330 --> 00:16:08,010
need a larger fpga for that and the most

00:16:05,970 --> 00:16:10,529
important optimization which is getting

00:16:08,010 --> 00:16:13,470
rid of this memory copy overhead this is

00:16:10,529 --> 00:16:16,950
a trickier one what happens today is

00:16:13,470 --> 00:16:19,290
that I mean the way the new radio

00:16:16,950 --> 00:16:23,930
buffers are implemented forces us to

00:16:19,290 --> 00:16:26,730
basically have this extra memory copy

00:16:23,930 --> 00:16:28,200
step here within the physical addresses

00:16:26,730 --> 00:16:31,650
space right I mean the buffer is mapped

00:16:28,200 --> 00:16:34,589
from virtual to this chunk of physical

00:16:31,650 --> 00:16:35,880
memory and since this mapping is

00:16:34,589 --> 00:16:38,250
changing all the time because if the

00:16:35,880 --> 00:16:40,050
buffers are dynamic we need to all the

00:16:38,250 --> 00:16:42,150
time copy data from here to there which

00:16:40,050 --> 00:16:46,110
is where from where the fpga accelerator

00:16:42,150 --> 00:16:48,480
reads and right there if we could fix no

00:16:46,110 --> 00:16:50,880
radio to fils it to have any static

00:16:48,480 --> 00:16:53,460
mapping of the buffer to from visual to

00:16:50,880 --> 00:16:56,240
physical memory then we don't need that

00:16:53,460 --> 00:16:58,589
extra copy step and and and we would

00:16:56,240 --> 00:17:01,050
completely get rid of that memory copy

00:16:58,589 --> 00:17:04,230
overhead with a potential improvement of

00:17:01,050 --> 00:17:07,290
33 times in terms of performance so

00:17:04,230 --> 00:17:09,030
these three optimizations are not yet in

00:17:07,290 --> 00:17:12,120
place but we believe this the tree of

00:17:09,030 --> 00:17:15,270
the elvenar dual are feasible so this is

00:17:12,120 --> 00:17:20,670
our next step in optimizing our Hardware

00:17:15,270 --> 00:17:24,060
accelerate what I showed before was by

00:17:20,670 --> 00:17:26,160
taking the transceiver and creating a

00:17:24,060 --> 00:17:28,800
standalone version of it that works in

00:17:26,160 --> 00:17:31,890
loopback mode on an ARM processor

00:17:28,800 --> 00:17:33,780
without over-the-air communication so we

00:17:31,890 --> 00:17:36,450
okay how do we know that what we have

00:17:33,780 --> 00:17:38,700
the measuring is correct so let's try to

00:17:36,450 --> 00:17:39,900
replicate the same scenario but in a

00:17:38,700 --> 00:17:41,640
more realistic scenario with

00:17:39,900 --> 00:17:43,920
over-the-air communication so we had in

00:17:41,640 --> 00:17:46,230
this case measurements in a set up with

00:17:43,920 --> 00:17:49,410
two machines when transmitting they are

00:17:46,230 --> 00:17:52,020
one receiving over there with the proper

00:17:49,410 --> 00:17:53,820
user P devices so we measure different

00:17:52,020 --> 00:17:58,740
kind of a scenarios for example two

00:17:53,820 --> 00:18:01,170
coding schemes BPSK and 16 2 am the

00:17:58,740 --> 00:18:05,370
chart on the table basically is showing

00:18:01,170 --> 00:18:07,140
the CPU time for the different blogs in

00:18:05,370 --> 00:18:07,730
the transmitter for the two coding

00:18:07,140 --> 00:18:10,440
schemes

00:18:07,730 --> 00:18:12,960
while the chart in both in the botton is

00:18:10,440 --> 00:18:15,180
measuring the same in the time consumed

00:18:12,960 --> 00:18:18,180
by the different blocks in the receiver

00:18:15,180 --> 00:18:19,800
for the two schemes plus the noise case

00:18:18,180 --> 00:18:21,540
where we are actually not transmitting

00:18:19,800 --> 00:18:23,550
anything but but still there are some

00:18:21,540 --> 00:18:26,760
blocks in the receiver which are doing

00:18:23,550 --> 00:18:30,630
work right for example the ones for

00:18:26,760 --> 00:18:33,120
synchronization so the message here is

00:18:30,630 --> 00:18:34,890
that what we observe here is matches

00:18:33,120 --> 00:18:36,510
what we observe in the other scenario

00:18:34,890 --> 00:18:38,490
where we were not doing actually

00:18:36,510 --> 00:18:44,610
over-the-air communication so this is

00:18:38,490 --> 00:18:47,130
more like a sanity check for us right so

00:18:44,610 --> 00:18:51,660
to summarize basically what I presented

00:18:47,130 --> 00:18:53,040
today in a very generic way is a novel

00:18:51,660 --> 00:18:54,960
computation paradigm that we call

00:18:53,040 --> 00:18:57,740
adaptive swarm intelligence that we

00:18:54,960 --> 00:19:01,440
believe will be like the next revolution

00:18:57,740 --> 00:19:02,880
now that we have or we will have ultra

00:19:01,440 --> 00:19:05,340
high bandwidth connectivity which is a

00:19:02,880 --> 00:19:08,760
key element in swarming connectivity is

00:19:05,340 --> 00:19:11,040
the king then we I focus on one specific

00:19:08,760 --> 00:19:14,040
use case this idea of comparative sensor

00:19:11,040 --> 00:19:16,380
fusion which is the application that we

00:19:14,040 --> 00:19:20,690
took within our DARPA sponsor about a

00:19:16,380 --> 00:19:24,300
box project this application basically

00:19:20,690 --> 00:19:25,770
integrates together elements of computer

00:19:24,300 --> 00:19:27,450
vision for local sensing plus

00:19:25,770 --> 00:19:31,680
vehicle-to-vehicle communications using

00:19:27,450 --> 00:19:34,830
software-defined radio as I said I mean

00:19:31,680 --> 00:19:37,650
in ASI communication is key it's really

00:19:34,830 --> 00:19:39,870
important it's crucial so we started

00:19:37,650 --> 00:19:41,940
focusing on the vehicle to be a

00:19:39,870 --> 00:19:43,940
communication part and analyzing the

00:19:41,940 --> 00:19:46,230
performance of that piece of the code

00:19:43,940 --> 00:19:48,500
and this is what I presented today

00:19:46,230 --> 00:19:52,350
actually it is detail characterization

00:19:48,500 --> 00:19:54,000
and some potential optimization and

00:19:52,350 --> 00:19:55,380
acceleration opportunities for these two

00:19:54,000 --> 00:19:58,410
functions that are the most critical

00:19:55,380 --> 00:20:00,900
ones but in general and I think this is

00:19:58,410 --> 00:20:02,370
I think the most important message I

00:20:00,900 --> 00:20:04,260
want you to take I mean we are working

00:20:02,370 --> 00:20:07,440
on this a box reference application

00:20:04,260 --> 00:20:11,520
array something that we started like

00:20:07,440 --> 00:20:15,059
maybe one year ago and we want to create

00:20:11,520 --> 00:20:17,820
out of array like a benchmark platform

00:20:15,059 --> 00:20:20,690
or competitive mobility which integrate

00:20:17,820 --> 00:20:22,620
together perception and communication

00:20:20,690 --> 00:20:26,279
capabilities in the same software

00:20:22,620 --> 00:20:27,480
platform this is a say pretty unique

00:20:26,279 --> 00:20:29,940
most of the time when we talk about

00:20:27,480 --> 00:20:33,509
connected autonomous vehicles either we

00:20:29,940 --> 00:20:35,309
find a benchmark suite for computer

00:20:33,509 --> 00:20:38,730
vision and onboard planning and

00:20:35,309 --> 00:20:40,470
uncontrolled or we have separately other

00:20:38,730 --> 00:20:42,299
benchmark for vehicle-to-vehicle

00:20:40,470 --> 00:20:44,340
communications we won't we need I think

00:20:42,299 --> 00:20:47,100
we need to create a single unified

00:20:44,340 --> 00:20:49,799
platform for that and open it for

00:20:47,100 --> 00:20:53,129
collaborative development so please feel

00:20:49,799 --> 00:20:55,590
free to reach out to me to us if you see

00:20:53,129 --> 00:20:57,869
that I mean this is of interest to your

00:20:55,590 --> 00:20:59,999
work and you may have any way to

00:20:57,869 --> 00:21:02,629
collaborate or contribute to this idea

00:20:59,999 --> 00:21:07,799
this is a longer maybe not very long

00:21:02,629 --> 00:21:10,559
term goal for URI so that's it thank you

00:21:07,799 --> 00:21:14,149
for your time I don't know I will

00:21:10,559 --> 00:21:14,149
appreciate if you have any questions

00:21:20,179 --> 00:21:29,249
time for questions I just need some

00:21:23,100 --> 00:21:32,249
raised hands so can you ever you are

00:21:29,249 --> 00:21:36,149
looking at how to expand beyond just the

00:21:32,249 --> 00:21:38,850
software to debate a radio but radar so

00:21:36,149 --> 00:21:43,529
you can actually use convenient

00:21:38,850 --> 00:21:46,610
convenient energy and then do a passive

00:21:43,529 --> 00:21:48,960
receiver so you can actually have a

00:21:46,610 --> 00:21:51,320
moving picture of where you're going

00:21:48,960 --> 00:21:54,749
right so you can fuse that together

00:21:51,320 --> 00:21:58,259
making sense so the question is if we

00:21:54,749 --> 00:22:00,720
have focus also on exchange in other

00:21:58,259 --> 00:22:04,470
type of information in addition to

00:22:00,720 --> 00:22:06,480
conventional radar we are considering

00:22:04,470 --> 00:22:08,580
other I mean actually that is a question

00:22:06,480 --> 00:22:12,779
that we have open in this project what

00:22:08,580 --> 00:22:14,879
what should we exchange between vehicles

00:22:12,779 --> 00:22:20,639
but in general between devices in a

00:22:14,879 --> 00:22:22,350
swarm to make this problem of interest

00:22:20,639 --> 00:22:24,029
right now what we are exchanging is

00:22:22,350 --> 00:22:25,590
something relatively simple we create

00:22:24,029 --> 00:22:27,869
this two-dimensional keep and secret

00:22:25,590 --> 00:22:30,179
maps we compress them together and we

00:22:27,869 --> 00:22:32,909
have changed across nearby vehicles so

00:22:30,179 --> 00:22:34,769
when a vehicle generate its own map and

00:22:32,909 --> 00:22:37,110
receives other maps fuse them together

00:22:34,769 --> 00:22:40,710
to generate a version that hopefully is

00:22:37,110 --> 00:22:45,059
let's say more precise has fewer false

00:22:40,710 --> 00:22:48,240
positives or false negatives but in the

00:22:45,059 --> 00:22:50,249
original asi paradigm we want to also

00:22:48,240 --> 00:22:52,619
change knowledge I mean if we car

00:22:50,249 --> 00:22:54,539
learned something over time how do we

00:22:52,619 --> 00:22:57,119
have change that knowledge between

00:22:54,539 --> 00:22:59,549
vehicles we believe that we need a

00:22:57,119 --> 00:23:01,679
common knowledge representation

00:22:59,549 --> 00:23:03,179
mechanism to do that because we are

00:23:01,679 --> 00:23:06,450
talking about maybe I will be the

00:23:03,179 --> 00:23:09,619
ontology know ontology is a piece of the

00:23:06,450 --> 00:23:12,119
methodology that takes an application

00:23:09,619 --> 00:23:13,679
wherever mean arbitrary application is

00:23:12,119 --> 00:23:16,559
cased the URI application and

00:23:13,679 --> 00:23:20,820
automatically identifies portions in the

00:23:16,559 --> 00:23:23,100
application functions or even processes

00:23:20,820 --> 00:23:25,409
which are probably the most

00:23:23,100 --> 00:23:28,259
time-consuming ones or the more the most

00:23:25,409 --> 00:23:30,090
critical ones for hardware acceleration

00:23:28,259 --> 00:23:32,100
so this methodology ontology the

00:23:30,090 --> 00:23:32,970
ontology will tell us this part of the

00:23:32,100 --> 00:23:35,460
array

00:23:32,970 --> 00:23:39,530
should be accelerated for example

00:23:35,460 --> 00:23:42,090
hardware and with this there is ontology

00:23:39,530 --> 00:23:49,380
analysis discovery part of the of the

00:23:42,090 --> 00:23:54,150
methodology yes any other questions

00:23:49,380 --> 00:23:59,550
I mean I'm gonna ask one question that

00:23:54,150 --> 00:24:01,470
is actually not about your slides so in

00:23:59,550 --> 00:24:03,540
industrial / commercial research center

00:24:01,470 --> 00:24:06,090
stone always gravitate towards

00:24:03,540 --> 00:24:08,370
open-source software in some cases even

00:24:06,090 --> 00:24:11,220
shy away from it and yet you going like

00:24:08,370 --> 00:24:13,020
even further you're also going putting

00:24:11,220 --> 00:24:14,190
it out on github so what was the what

00:24:13,020 --> 00:24:17,430
was the thought process made healthy

00:24:14,190 --> 00:24:19,800
behind then well I can talk about IBM

00:24:17,430 --> 00:24:24,000
specifically iBM is is actually trying

00:24:19,800 --> 00:24:26,010
to go open source open in general

00:24:24,000 --> 00:24:30,420
because we are also going open Hardware

00:24:26,010 --> 00:24:33,540
right recently open power platform -

00:24:30,420 --> 00:24:35,760
right so right now is part of IBM

00:24:33,540 --> 00:24:37,410
culture to go open source we believe in

00:24:35,760 --> 00:24:39,960
collaboration we strongly believe in

00:24:37,410 --> 00:24:42,570
collaboration and we learn over times

00:24:39,960 --> 00:24:45,300
probably over many years and maybe in

00:24:42,570 --> 00:24:48,300
some some times with some pain in that

00:24:45,300 --> 00:24:50,670
process that closing things doesn't help

00:24:48,300 --> 00:24:52,380
help anybody either the own company so

00:24:50,670 --> 00:24:54,270
this is why IBM believes in doing that

00:24:52,380 --> 00:24:58,800
and this is why we are putting

00:24:54,270 --> 00:25:00,600
everything in you will certainly not

00:24:58,800 --> 00:25:02,610
find any disagreement for myself for

00:25:00,600 --> 00:25:04,880
many people here all right one more

00:25:02,610 --> 00:25:08,089
applause for our speak

00:25:04,880 --> 00:25:08,089

YouTube URL: https://www.youtube.com/watch?v=kqWUCon0kKg


