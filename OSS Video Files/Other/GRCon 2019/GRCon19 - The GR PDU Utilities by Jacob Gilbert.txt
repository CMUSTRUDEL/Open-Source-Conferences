Title: GRCon19 - The GR PDU Utilities by Jacob Gilbert
Publication date: 2019-11-05
Playlist: GRCon 2019
Description: 
	The GR PDU Utilities by Jacob Gilbert

The GNU Radio PDU Utilities [1] serve to extend functionality of GR’s in-tree PDU API, and enhance user ability to understand and interact with the RF Spectrum. At a basic level there are a number of general purpose PDU ‘feature’ blocks analogous to GR streaming DSP blocks such as filtering and data conversion, an efficient implementation of M. Ossman’s WPCR [2], and many basic data operations applied to PDUs. Additionally, there is a straightforward and robust set of blocks for converting between streaming and PDU based data that can be combined with the GR Timing Utilities [3] to enable precise interaction with low-complexity bursty communication systems (e.g.: FHSS ISM Radios). In a more general sense, this module allow SDR applications to react to RF energy at a given time/frequency with RF energy at a specified time/frequency which is something that can be surprisingly difficult using in-tree functionality.

This talk will include an overview of the PDU Utilities theory of operation, provide details of implementation, summarize key blocks, describe how it fits into existing GR design practices, and discuss how it compares to other packet-data implementation patterns that exist within GR such as T. O’Shea’s gr-eventstream and GR’s Packet Communications API. The talk will also cover some off-label applications of the features contained in this module.

While it was published in early 2018, announced on the mailing list [4], and included in PyBombs, the PDU Utilities addresses a number of common requests on Slack and the GR mailing list. It was intended for demo at the 2018 conference but scheduling conflicts prevented submission. This module will see a significant update from what is available on github today in the June timeframe as approvals for open source release work their way through DOE approval chains. It may slip slightly but the update will be published before the 2019 conference.

[1] https://github.com/sandialabs/gr-pdu_utils
[2] https://github.com/mossmann/clock-recovery/blob/master/wpcr.py
[3] https://github.com/sandialabs/gr-timing_utils
[4] http://lists.gnu.org/archive/html/discuss-gnuradio/2018-04/msg00103.html

Sandia National Laboratories is a multimission laboratory managed and operated by National Technology & Engineering Solutions of Sandia, LLC, a wholly owned subsidiary of Honeywell International Inc., for the U.S. Department of Energy’s National Nuclear Security Administration under contract DE-NA0003525.
Captions: 
	00:00:14,330 --> 00:00:21,980
so I'm Jacob I've been a new radio user

00:00:17,060 --> 00:00:23,750
for a while since 2007 or so first time

00:00:21,980 --> 00:00:26,000
talking here so I'm really excited it's

00:00:23,750 --> 00:00:28,699
good I've benefited from a lot of the

00:00:26,000 --> 00:00:30,439
work that everyone here is done and I'm

00:00:28,699 --> 00:00:32,029
with Sandia National Laboratories at

00:00:30,439 --> 00:00:34,160
Albuquerque where a conference sponsor

00:00:32,029 --> 00:00:37,610
we're also happy to be doing that this

00:00:34,160 --> 00:00:40,280
year and we're really happy to get some

00:00:37,610 --> 00:00:41,989
of the code that we've built back to the

00:00:40,280 --> 00:00:45,739
open source it's not always super easy

00:00:41,989 --> 00:00:47,450
for us for a lot of government processes

00:00:45,739 --> 00:00:49,730
to do that but I think we finally

00:00:47,450 --> 00:00:52,610
figured it out and as of yesterday this

00:00:49,730 --> 00:00:54,410
is all on our official github page so

00:00:52,610 --> 00:00:56,540
you can go download it that's awesome

00:00:54,410 --> 00:01:00,020
it's a lot of work and hopefully it's

00:00:56,540 --> 00:01:02,000
useful to you the I'm going to talk

00:01:00,020 --> 00:01:06,049
through some extensions that we built

00:01:02,000 --> 00:01:08,030
into the PDU concept within the new

00:01:06,049 --> 00:01:12,920
radio system antigen ta synchronous

00:01:08,030 --> 00:01:15,350
message passing interface and just in

00:01:12,920 --> 00:01:16,399
case anybody isn't familiar this talk

00:01:15,350 --> 00:01:17,899
will be fairly useless without

00:01:16,399 --> 00:01:19,759
understanding that so you have the

00:01:17,899 --> 00:01:21,649
regular streaming way of doing things

00:01:19,759 --> 00:01:24,380
I'll say regular it's probably the most

00:01:21,649 --> 00:01:26,719
common and then you have the

00:01:24,380 --> 00:01:29,630
asynchronous message passing or PDU

00:01:26,719 --> 00:01:31,789
passing interface here so that

00:01:29,630 --> 00:01:34,130
ultimately the difference is that

00:01:31,789 --> 00:01:36,350
there's no back pressure but you're

00:01:34,130 --> 00:01:40,310
still moving data through through the

00:01:36,350 --> 00:01:43,369
flow graph in this case the PDUs are

00:01:40,310 --> 00:01:45,380
going to be polymorphic type pairs of a

00:01:43,369 --> 00:01:48,679
dictionary of metadata that you could

00:01:45,380 --> 00:01:52,939
change and a standard a uniform vector

00:01:48,679 --> 00:01:54,409
of some sort of data and what we're kind

00:01:52,939 --> 00:01:56,749
of presenting here and what we've made

00:01:54,409 --> 00:02:01,639
available is some interfaces to convert

00:01:56,749 --> 00:02:06,799
between the streaming API and PDUs which

00:02:01,639 --> 00:02:08,720
don't necessarily exist in tree so a

00:02:06,799 --> 00:02:11,510
little bit about the motivation for

00:02:08,720 --> 00:02:14,120
doing this the reason we started

00:02:11,510 --> 00:02:17,690
building these tools out was because we

00:02:14,120 --> 00:02:19,700
had a we were given a challenge here

00:02:17,690 --> 00:02:22,000
which doesn't sound very hard at all and

00:02:19,700 --> 00:02:25,550
conceptually it's very simple but

00:02:22,000 --> 00:02:28,940
receive a burst of information from a

00:02:25,550 --> 00:02:32,750
software-defined radio or where

00:02:28,940 --> 00:02:34,640
and receive that process it and transmit

00:02:32,750 --> 00:02:39,549
another burst of information on the same

00:02:34,640 --> 00:02:42,739
or some other frequency if it's not all

00:02:39,549 --> 00:02:45,440
together in you know a common way the

00:02:42,739 --> 00:02:47,569
same modulation type the same the same

00:02:45,440 --> 00:02:49,430
symbol rate that you expect things like

00:02:47,569 --> 00:02:53,120
that things break down pretty quickly

00:02:49,430 --> 00:02:54,860
and once you start factoring in real

00:02:53,120 --> 00:02:57,819
world constraints of radios where you

00:02:54,860 --> 00:03:00,709
have turnaround time requirements or

00:02:57,819 --> 00:03:02,629
TDMA constraints where you have a time

00:03:00,709 --> 00:03:04,760
slot that is available to you to

00:03:02,629 --> 00:03:06,620
transmit energy back in things get

00:03:04,760 --> 00:03:08,859
complicated very very very quickly and

00:03:06,620 --> 00:03:11,989
then you throw in frequency hopping or

00:03:08,859 --> 00:03:13,970
the the need to switch frequency bands

00:03:11,989 --> 00:03:16,760
arbitrarily or change modulation coding

00:03:13,970 --> 00:03:20,030
schemes it gets complicated pretty quick

00:03:16,760 --> 00:03:22,129
I think of those things latency tends to

00:03:20,030 --> 00:03:24,920
be a huge sticking point for people and

00:03:22,129 --> 00:03:26,420
I in my experience is one of the reasons

00:03:24,920 --> 00:03:28,790
and we go talk to people about using a

00:03:26,420 --> 00:03:30,019
new radio they'll say oh no you can't

00:03:28,790 --> 00:03:32,060
use canny radio there's way too much

00:03:30,019 --> 00:03:33,019
latency so we use something else

00:03:32,060 --> 00:03:36,109
entirely

00:03:33,019 --> 00:03:38,930
and these are some examples there are a

00:03:36,109 --> 00:03:40,910
whole whole bunch of other for their

00:03:38,930 --> 00:03:43,819
options but the new radio is really

00:03:40,910 --> 00:03:45,500
really good and we wanted to build some

00:03:43,819 --> 00:03:49,630
tools that would help us continue to

00:03:45,500 --> 00:03:54,319
keep our capability with enga new radio

00:03:49,630 --> 00:03:55,609
when it comes to latency we tend to say

00:03:54,319 --> 00:03:57,680
we're low latency but that doesn't

00:03:55,609 --> 00:03:59,000
really mean anything because everyone's

00:03:57,680 --> 00:04:00,919
version of latency is different we're

00:03:59,000 --> 00:04:03,769
having this conversation last night

00:04:00,919 --> 00:04:05,660
what is low latency is is low latency

00:04:03,769 --> 00:04:08,269
being able to do something within a

00:04:05,660 --> 00:04:11,299
second within a millisecond within a

00:04:08,269 --> 00:04:12,739
microsecond and so when we say low

00:04:11,299 --> 00:04:15,590
latency we're kind of talking about the

00:04:12,739 --> 00:04:18,500
the millisecond accurate or millisecond

00:04:15,590 --> 00:04:20,570
turnaround time this may or may not be

00:04:18,500 --> 00:04:22,760
low latency to you if you're building an

00:04:20,570 --> 00:04:24,830
802 11 fie it's definitely not low

00:04:22,760 --> 00:04:26,830
latency if you're doing voice comms then

00:04:24,830 --> 00:04:29,780
this is way faster than you should need

00:04:26,830 --> 00:04:31,099
there are some there are some current

00:04:29,780 --> 00:04:34,099
tools that exist and I'll walk through

00:04:31,099 --> 00:04:36,080
those quickly but they had all of them

00:04:34,099 --> 00:04:40,500
had limitations for what we're trying to

00:04:36,080 --> 00:04:42,480
do which was so

00:04:40,500 --> 00:04:44,100
back to the you know what are we trying

00:04:42,480 --> 00:04:45,930
to do here trying to convert bursts of

00:04:44,100 --> 00:04:51,180
energy into chunks of data we can

00:04:45,930 --> 00:04:52,590
process and be able to understand where

00:04:51,180 --> 00:04:55,170
in time where in frequency that came

00:04:52,590 --> 00:04:57,330
from and then on the other side on the

00:04:55,170 --> 00:04:59,850
transmit side turn that around and with

00:04:57,330 --> 00:05:02,370
we call it sample accurate transmission

00:04:59,850 --> 00:05:03,720
time so depending on how fast your

00:05:02,370 --> 00:05:05,340
sample rate is I'd like to be able to

00:05:03,720 --> 00:05:08,520
put that energy over the air at a time

00:05:05,340 --> 00:05:11,850
and a frequency of my choosing with

00:05:08,520 --> 00:05:13,320
reasonable accuracy portable so nothing

00:05:11,850 --> 00:05:15,450
super specialized we didn't want to

00:05:13,320 --> 00:05:17,400
build up a whole bunch of FPGA code to

00:05:15,450 --> 00:05:19,230
do this we wanted to keep it all all in

00:05:17,400 --> 00:05:21,150
software that we can build and target

00:05:19,230 --> 00:05:26,100
any of these embedded processing

00:05:21,150 --> 00:05:28,230
platforms laptops whatever robust so

00:05:26,100 --> 00:05:30,840
keeping track of time when we're talking

00:05:28,230 --> 00:05:34,200
about latency and timing you have to be

00:05:30,840 --> 00:05:36,300
able to handle sit drop data there's

00:05:34,200 --> 00:05:37,890
really no no value to us and a tool

00:05:36,300 --> 00:05:39,870
that's going to slough over time and

00:05:37,890 --> 00:05:42,060
require to be reset so there's a lot of

00:05:39,870 --> 00:05:45,690
work that went into keeping accurate

00:05:42,060 --> 00:05:47,910
track of time and then efficient you

00:05:45,690 --> 00:05:50,760
know we didn't want to develop a clunky

00:05:47,910 --> 00:05:52,380
Clippy tool that was going to take up a

00:05:50,760 --> 00:05:57,060
ton of a ton of processing power and

00:05:52,380 --> 00:05:59,070
require a server to run so suck through

00:05:57,060 --> 00:06:01,440
the existing tool set prior to this that

00:05:59,070 --> 00:06:04,080
we that we went through there are some

00:06:01,440 --> 00:06:06,030
entry tools available and a lot of

00:06:04,080 --> 00:06:07,830
people get horribly misguided into this

00:06:06,030 --> 00:06:10,229
this question gets asked all the time

00:06:07,830 --> 00:06:14,460
and inevitably the answer is oh use the

00:06:10,229 --> 00:06:19,260
tag use tags use tag streams don't use

00:06:14,460 --> 00:06:21,210
tag streams they're really bad here's so

00:06:19,260 --> 00:06:24,750
so if this isn't a selling point for tag

00:06:21,210 --> 00:06:26,820
streams I don't know what is bugs and

00:06:24,750 --> 00:06:29,970
efficiencies grief undocumented

00:06:26,820 --> 00:06:31,350
contracts that they're bad don't use

00:06:29,970 --> 00:06:33,060
them I think they might be going away

00:06:31,350 --> 00:06:35,370
I'm not entirely sure if somebody in

00:06:33,060 --> 00:06:40,800
this room surely knows but hopefully

00:06:35,370 --> 00:06:42,600
they do the other the other thing that

00:06:40,800 --> 00:06:45,030
gets brought up a lot I'll say is the

00:06:42,600 --> 00:06:47,100
GRU HD stream tags so this is a way of

00:06:45,030 --> 00:06:50,849
providing a receive time tracking and

00:06:47,100 --> 00:06:54,330
information metadata as Stream tags all

00:06:50,849 --> 00:06:56,220
of the the UHD devices

00:06:54,330 --> 00:06:58,020
all the edits devices support this on

00:06:56,220 --> 00:06:59,669
the receive side and there are similar

00:06:58,020 --> 00:07:02,039
constructs on the transmit side where

00:06:59,669 --> 00:07:03,330
you can tag what you know the start of a

00:07:02,039 --> 00:07:05,219
verse the end of a verse and what

00:07:03,330 --> 00:07:07,860
frequency you want energy to go out at

00:07:05,219 --> 00:07:09,449
this this is really really useful but

00:07:07,860 --> 00:07:12,990
it's not a complete solution to do

00:07:09,449 --> 00:07:15,150
everything we wanted to do our our code

00:07:12,990 --> 00:07:18,180
that we're providing does make extensive

00:07:15,150 --> 00:07:21,120
use of this style of stream tag and

00:07:18,180 --> 00:07:23,460
we've extended it to other hardware that

00:07:21,120 --> 00:07:25,740
we use for example the the sidekick

00:07:23,460 --> 00:07:28,620
Hardware adding the ability to use this

00:07:25,740 --> 00:07:31,409
type of time tag is really helpful when

00:07:28,620 --> 00:07:36,210
you want to keep sample plus or minus

00:07:31,409 --> 00:07:39,599
accurate track of time there's also an

00:07:36,210 --> 00:07:42,659
extensive packet communications API this

00:07:39,599 --> 00:07:44,460
is a this is a powerful a powerful

00:07:42,659 --> 00:07:46,650
scheme in it but it does make use of

00:07:44,460 --> 00:07:50,699
these tag stream blocks in a couple

00:07:46,650 --> 00:07:53,340
places and ultimately we were never able

00:07:50,699 --> 00:07:55,379
to make this run fast enough transmitted

00:07:53,340 --> 00:07:58,229
to receive latency lerna never able to

00:07:55,379 --> 00:08:00,719
get it low enough I'm not saying it

00:07:58,229 --> 00:08:04,469
doesn't work but we were we weren't able

00:08:00,719 --> 00:08:07,740
to get this below ten maybe five

00:08:04,469 --> 00:08:09,509
millisecond turnaround time I think it's

00:08:07,740 --> 00:08:11,069
a reasonable option if you're doing

00:08:09,509 --> 00:08:12,210
things yourself and you can build around

00:08:11,069 --> 00:08:13,889
some of the limitations that we

00:08:12,210 --> 00:08:16,199
experienced or you understand it better

00:08:13,889 --> 00:08:18,440
than we did but we found the the PDU

00:08:16,199 --> 00:08:22,740
utility module that we built

00:08:18,440 --> 00:08:23,759
significantly easier to use there's a

00:08:22,740 --> 00:08:26,849
couple links there

00:08:23,759 --> 00:08:29,879
the doxygen is pretty good and the GRE

00:08:26,849 --> 00:08:31,589
UAS link is an interesting module that

00:08:29,879 --> 00:08:35,459
makes use of that for kind of custom

00:08:31,589 --> 00:08:38,010
communication projects there's a vent

00:08:35,459 --> 00:08:40,140
stream so event stream does provide

00:08:38,010 --> 00:08:42,180
closed-loop timing by interleaving

00:08:40,140 --> 00:08:45,810
information interleaving bursts of data

00:08:42,180 --> 00:08:48,050
into a steady transmit streams gr vin

00:08:45,810 --> 00:08:51,959
stream works really really well

00:08:48,050 --> 00:08:53,880
however it relies on typical back

00:08:51,959 --> 00:08:56,880
pressure so if you have a lot of blocks

00:08:53,880 --> 00:08:58,589
you can end up getting having a few of a

00:08:56,880 --> 00:09:00,690
lot of blocks between your event stream

00:08:58,589 --> 00:09:03,149
source and your software-defined radios

00:09:00,690 --> 00:09:05,490
sync you can end up with a significant

00:09:03,149 --> 00:09:07,470
amount of data in flight between when

00:09:05,490 --> 00:09:08,190
you're able to insert data and when it

00:09:07,470 --> 00:09:11,940
goes out over the

00:09:08,190 --> 00:09:13,440
which sets your minimum latency this was

00:09:11,940 --> 00:09:15,420
really the limiting factor here but

00:09:13,440 --> 00:09:17,100
there are a lot of really good concepts

00:09:15,420 --> 00:09:20,389
with an event stream that I think will

00:09:17,100 --> 00:09:22,649
probably consider using moving forward

00:09:20,389 --> 00:09:25,050
the other thing that event stream does

00:09:22,649 --> 00:09:27,029
is I know our Tim is but some of these

00:09:25,050 --> 00:09:30,509
some of the things that look like normal

00:09:27,029 --> 00:09:33,360
messages are not normal messages and

00:09:30,509 --> 00:09:37,819
they cause blocks like the zmq message

00:09:33,360 --> 00:09:40,500
syncing source to to freak out so

00:09:37,819 --> 00:09:43,110
ultimately we didn't make too much use

00:09:40,500 --> 00:09:46,980
of G our event stream in the module that

00:09:43,110 --> 00:09:52,459
we're presenting here so we'll go into

00:09:46,980 --> 00:09:56,399
what what is the GRP D u utils module

00:09:52,459 --> 00:09:58,649
this is kind of the general flow for for

00:09:56,399 --> 00:10:00,930
how how this module is intended to be

00:09:58,649 --> 00:10:03,149
used ultimately what you're getting here

00:10:00,930 --> 00:10:04,829
is a set of tools for converting between

00:10:03,149 --> 00:10:07,680
the streaming and the asynchronous

00:10:04,829 --> 00:10:11,040
message API is within Guinea radio so

00:10:07,680 --> 00:10:12,959
the idea is that you have data you tag

00:10:11,040 --> 00:10:14,189
it with stream tags and you say this is

00:10:12,959 --> 00:10:15,600
the start of something interesting this

00:10:14,189 --> 00:10:17,579
is the end of something interesting and

00:10:15,600 --> 00:10:21,720
there are tools that would convert that

00:10:17,579 --> 00:10:23,730
to to PDUs and send them out timing

00:10:21,720 --> 00:10:25,980
information is preserved as metadata in

00:10:23,730 --> 00:10:30,269
the PDU dictionary that we had we

00:10:25,980 --> 00:10:32,430
mentioned earlier so that that is nice

00:10:30,269 --> 00:10:33,750
because you can keep track of that as

00:10:32,430 --> 00:10:35,730
you move forward and if you do something

00:10:33,750 --> 00:10:38,939
in the PDU processing stage where you

00:10:35,730 --> 00:10:41,029
change rates or you resample something

00:10:38,939 --> 00:10:43,470
or you convert data types you can simply

00:10:41,029 --> 00:10:45,480
propagate more information or modify

00:10:43,470 --> 00:10:49,139
timing information within that that

00:10:45,480 --> 00:10:50,850
metadata dictionary and then eventually

00:10:49,139 --> 00:10:52,559
if you want to transmit something you

00:10:50,850 --> 00:10:54,240
may choose to convert that to us back

00:10:52,559 --> 00:10:59,339
into a stream there are tools to do that

00:10:54,240 --> 00:11:03,630
and that timing information can again be

00:10:59,339 --> 00:11:06,209
used to append those TX sob TXE OB & TX

00:11:03,630 --> 00:11:08,639
time tags and a little bit more

00:11:06,209 --> 00:11:10,170
information on that and ultimately if

00:11:08,639 --> 00:11:12,360
you're using a software defined radio

00:11:10,170 --> 00:11:14,100
that is capable of adjusting that

00:11:12,360 --> 00:11:17,809
information for transmission you should

00:11:14,100 --> 00:11:17,809
get energy out at that point in time

00:11:19,180 --> 00:11:27,280
so time management is done with tags the

00:11:24,280 --> 00:11:31,840
the TX time tag key will be appended by

00:11:27,280 --> 00:11:36,430
that PD you to stream block and you HD

00:11:31,840 --> 00:11:45,460
style time tuples are used on the on the

00:11:36,430 --> 00:11:47,560
receive path the this talk is titled

00:11:45,460 --> 00:11:49,530
gr PD you utils there's actually four

00:11:47,560 --> 00:11:51,820
modules that we published open source

00:11:49,530 --> 00:11:54,820
one of the other ones is this timing

00:11:51,820 --> 00:11:58,000
utilities module this is very related to

00:11:54,820 --> 00:12:00,730
PD you utils some of the complexity is

00:11:58,000 --> 00:12:04,030
now OBE up until a couple years ago when

00:12:00,730 --> 00:12:05,800
Andy Walz finally fixed tag propagation

00:12:04,030 --> 00:12:09,370
within the symbol synchronizer block

00:12:05,800 --> 00:12:11,230
which there was a bunch of a bunch of

00:12:09,370 --> 00:12:13,480
overhead on top of this where we could

00:12:11,230 --> 00:12:15,340
add a bunch of tags and see where they

00:12:13,480 --> 00:12:16,840
end up knowing where they were on the

00:12:15,340 --> 00:12:19,240
input stream and then track on the

00:12:16,840 --> 00:12:23,050
output stream to keep that approx sample

00:12:19,240 --> 00:12:24,910
level accuracy on timing a lot of that

00:12:23,050 --> 00:12:27,150
complexity is OBE so this doesn't really

00:12:24,910 --> 00:12:29,290
need to be a separate module but I

00:12:27,150 --> 00:12:32,920
recommend installing it it's pretty

00:12:29,290 --> 00:12:34,840
small and it provides a lot of time to

00:12:32,920 --> 00:12:37,920
help or it provides a lot of

00:12:34,840 --> 00:12:42,880
functionality to help keep track of time

00:12:37,920 --> 00:12:45,520
the there are there are UHD style time

00:12:42,880 --> 00:12:48,400
keys or time tags which are a

00:12:45,520 --> 00:12:49,930
combination of a integer an unsigned

00:12:48,400 --> 00:12:52,060
integer and a double to keep track of

00:12:49,930 --> 00:12:54,670
time and prevent round off from from

00:12:52,060 --> 00:12:59,170
eventually causing havoc there's a

00:12:54,670 --> 00:13:01,630
second type of of time tag that is used

00:12:59,170 --> 00:13:05,830
within this module here that also adds

00:13:01,630 --> 00:13:07,990
in the sample offset and sample rate so

00:13:05,830 --> 00:13:11,710
if you end up using this just keep that

00:13:07,990 --> 00:13:14,380
in mind so how do you put this together

00:13:11,710 --> 00:13:16,800
to extend this kind of basic FSK a

00:13:14,380 --> 00:13:20,350
receiver example so this is a pretty

00:13:16,800 --> 00:13:23,020
pretty common way of doing streaming

00:13:20,350 --> 00:13:27,040
demodulation the old you know channel

00:13:23,020 --> 00:13:30,520
filter FM demodulation symbol recovery

00:13:27,040 --> 00:13:32,380
clock recovery slice the data really all

00:13:30,520 --> 00:13:34,390
that you're going to want to do

00:13:32,380 --> 00:13:37,630
you take that information and get it

00:13:34,390 --> 00:13:40,090
into a PDU is identify where the start

00:13:37,630 --> 00:13:43,330
of a burst is in this case the correlate

00:13:40,090 --> 00:13:46,420
access code tag block will use a you

00:13:43,330 --> 00:13:50,140
know a a start of frame delimiter or the

00:13:46,420 --> 00:13:52,390
end of your preamble to do that and then

00:13:50,140 --> 00:13:56,290
at that point there are a couple options

00:13:52,390 --> 00:13:58,270
you can either configure the tags to PD

00:13:56,290 --> 00:13:59,860
you block to have a maximum amount of

00:13:58,270 --> 00:14:02,260
data and it will just accumulate data

00:13:59,860 --> 00:14:05,680
and then spit it back out or you can end

00:14:02,260 --> 00:14:09,910
of burst tag or do some sort of some

00:14:05,680 --> 00:14:11,470
sort of real-time decoding of the length

00:14:09,910 --> 00:14:15,910
information if it's present in whatever

00:14:11,470 --> 00:14:17,680
you're looking at the ultimately putting

00:14:15,910 --> 00:14:19,390
that end of burst tag you'll know

00:14:17,680 --> 00:14:21,490
exactly what you're getting in that PDU

00:14:19,390 --> 00:14:23,410
but you don't have to do that and at

00:14:21,490 --> 00:14:25,240
that point you have one of these these

00:14:23,410 --> 00:14:27,400
PDS where you've got some timing

00:14:25,240 --> 00:14:30,820
information you've got a unique ID

00:14:27,400 --> 00:14:34,510
number you can key off of you have and

00:14:30,820 --> 00:14:36,700
then you have the the uniform vector of

00:14:34,510 --> 00:14:44,050
the actual data that you pulled off of

00:14:36,700 --> 00:14:48,630
the slicer and so how that how that

00:14:44,050 --> 00:14:50,830
works inside of a full TDMA transceiver

00:14:48,630 --> 00:14:54,070
would look something like this

00:14:50,830 --> 00:14:56,740
so you can take that top concept and

00:14:54,070 --> 00:14:58,420
then on the transmit side you might have

00:14:56,740 --> 00:15:02,050
a block that's going to do some sort of

00:14:58,420 --> 00:15:04,960
preamble adding that's that's provided

00:15:02,050 --> 00:15:07,240
within this module you might want to

00:15:04,960 --> 00:15:10,150
modulate that data in this case there is

00:15:07,240 --> 00:15:12,730
a GM gmsk modulator that's built into

00:15:10,150 --> 00:15:15,220
this as well and then you can convert

00:15:12,730 --> 00:15:19,540
that back to streaming for transmission

00:15:15,220 --> 00:15:23,050
or if you have a block that can ingest

00:15:19,540 --> 00:15:25,810
this PD you as is you don't really even

00:15:23,050 --> 00:15:27,400
need that step to to be compatible with

00:15:25,810 --> 00:15:29,740
all of the use of Hardware out there

00:15:27,400 --> 00:15:31,600
it's pretty convenient to just convert

00:15:29,740 --> 00:15:33,430
it back to streaming but the nice thing

00:15:31,600 --> 00:15:35,680
is in the middle of this receiver side

00:15:33,430 --> 00:15:37,690
and transmitter side you have a super

00:15:35,680 --> 00:15:39,340
convenient place where you're passing

00:15:37,690 --> 00:15:40,240
around a really well-structured chunk of

00:15:39,340 --> 00:15:42,640
data that has all the information

00:15:40,240 --> 00:15:44,770
content of your message so you can take

00:15:42,640 --> 00:15:45,520
this you can send it out over a network

00:15:44,770 --> 00:15:47,860
if you use

00:15:45,520 --> 00:15:49,500
MQ my source you can put that over to

00:15:47,860 --> 00:15:51,880
some sort of higher layer processor and

00:15:49,500 --> 00:15:53,200
now you have the ability to make you

00:15:51,880 --> 00:15:57,700
know decisions based on that information

00:15:53,200 --> 00:15:59,650
and formulated a new response you can

00:15:57,700 --> 00:16:02,410
also choose wherever you want to omit

00:15:59,650 --> 00:16:06,760
this in frequency using using the

00:16:02,410 --> 00:16:08,470
frequency metadata field and the PD you

00:16:06,760 --> 00:16:11,280
to stream block wool will take care of

00:16:08,470 --> 00:16:11,280
that for you as well

00:16:13,020 --> 00:16:19,120
so I mentioned this earlier and this was

00:16:15,610 --> 00:16:20,710
low NC sort of was the the reason that

00:16:19,120 --> 00:16:22,480
none of the entry are existing

00:16:20,710 --> 00:16:25,950
capabilities that we came across worked

00:16:22,480 --> 00:16:29,110
very well for for our application but

00:16:25,950 --> 00:16:31,510
what is what was low latency mean that's

00:16:29,110 --> 00:16:33,640
subjective and and what are the causes

00:16:31,510 --> 00:16:36,880
of latency within within getting radio I

00:16:33,640 --> 00:16:38,890
think primarily I see things that posts

00:16:36,880 --> 00:16:42,670
that end up ultimately blaming something

00:16:38,890 --> 00:16:44,530
related to the runtime it's not really

00:16:42,670 --> 00:16:46,720
the runtime that causes latency within

00:16:44,530 --> 00:16:48,730
the new radio what it primarily is is

00:16:46,720 --> 00:16:51,070
this concept of accumulating data and

00:16:48,730 --> 00:16:53,320
buffers and then passing it along

00:16:51,070 --> 00:16:54,970
the largest buffer size in your flow

00:16:53,320 --> 00:16:58,870
graph is going to set your minimum

00:16:54,970 --> 00:17:00,910
latency if the if the start of whatever

00:16:58,870 --> 00:17:02,440
energy that you received is in the very

00:17:00,910 --> 00:17:03,670
beginning of your buffer you have to

00:17:02,440 --> 00:17:07,140
wait until all of that other data

00:17:03,670 --> 00:17:10,930
accumulates before you can move it along

00:17:07,140 --> 00:17:12,339
things that are not transparent to or

00:17:10,930 --> 00:17:14,500
that are completely I'm sorry that are

00:17:12,339 --> 00:17:15,640
not obvious to a user like transport

00:17:14,500 --> 00:17:17,980
control buffering and things like that

00:17:15,640 --> 00:17:20,050
can cause huge sources of latency if

00:17:17,980 --> 00:17:22,089
your scr hardware is accumulating a ton

00:17:20,050 --> 00:17:24,670
of data before it ever provides it to

00:17:22,089 --> 00:17:27,670
the host you're already sunk in terms of

00:17:24,670 --> 00:17:30,910
getting latency are getting TR turn

00:17:27,670 --> 00:17:32,950
around better than that to solve that

00:17:30,910 --> 00:17:34,330
you can reduce data buffer sizes that's

00:17:32,950 --> 00:17:36,400
the best you can also increase sample

00:17:34,330 --> 00:17:40,660
rate that means there is less time in

00:17:36,400 --> 00:17:42,730
that buffer of data and that will that

00:17:40,660 --> 00:17:45,070
will help reduce your latency but it's

00:17:42,730 --> 00:17:46,660
always a trade-off smaller buffers if

00:17:45,070 --> 00:17:48,070
you're processing one sample at a time

00:17:46,660 --> 00:17:50,260
the smallest buffer you have a lot of

00:17:48,070 --> 00:17:53,350
overhead with regard to calling that and

00:17:50,260 --> 00:17:56,310
it it it's going to increase your your

00:17:53,350 --> 00:17:56,310
CPU utilization

00:17:56,620 --> 00:18:03,279
so within the PDU utils block there's a

00:18:00,429 --> 00:18:05,890
tool to characterize round trip latency

00:18:03,279 --> 00:18:08,950
so we built a flow graph that will work

00:18:05,890 --> 00:18:10,330
with the PDU utils module and uhd

00:18:08,950 --> 00:18:13,470
hardware and it will actually

00:18:10,330 --> 00:18:16,240
characterize round-trip latency and so

00:18:13,470 --> 00:18:18,100
what the flow graphs a little bit

00:18:16,240 --> 00:18:20,320
confusing so here's a decoder for it

00:18:18,100 --> 00:18:22,630
what you get out of that is you

00:18:20,320 --> 00:18:26,260
basically generate a periodic signal

00:18:22,630 --> 00:18:28,419
that tells the flow graph to emit a PD

00:18:26,260 --> 00:18:29,799
you message for transmission and then

00:18:28,419 --> 00:18:31,299
you correlate when that happened

00:18:29,799 --> 00:18:32,860
relative to when it comes back around

00:18:31,299 --> 00:18:34,809
and you receive it so you need to just

00:18:32,860 --> 00:18:38,529
loop back your STR or terminate it and

00:18:34,809 --> 00:18:40,690
you'll get internal leakage when you do

00:18:38,529 --> 00:18:42,700
that with the default uhd arguments and

00:18:40,690 --> 00:18:45,220
this was done on a you serve be 210 I

00:18:42,700 --> 00:18:46,840
think you end up getting about 2

00:18:45,220 --> 00:18:49,289
millisecond round-trip latency which is

00:18:46,840 --> 00:18:53,230
actually really good however if you've

00:18:49,289 --> 00:18:56,200
tuned some of the transport parameters

00:18:53,230 --> 00:18:59,440
which can be passed as an argument to

00:18:56,200 --> 00:19:02,169
the user source block you can actually

00:18:59,440 --> 00:19:05,070
get this down really really low so it's

00:19:02,169 --> 00:19:08,770
a statistical problem and ultimately

00:19:05,070 --> 00:19:11,770
some some process on your computer will

00:19:08,770 --> 00:19:13,419
end up causing some sort of delay and a

00:19:11,770 --> 00:19:15,399
block getting called and you'll get

00:19:13,419 --> 00:19:18,250
latency but you can see the histograms

00:19:15,399 --> 00:19:21,070
there of they were measured with these

00:19:18,250 --> 00:19:24,309
low lower latency uhd arguments and you

00:19:21,070 --> 00:19:27,909
can turn that energy around in about 270

00:19:24,309 --> 00:19:31,210
microseconds nominally it will it will

00:19:27,909 --> 00:19:33,309
inevitably take longer sometimes but you

00:19:31,210 --> 00:19:34,960
can see the the gray part of the gray

00:19:33,309 --> 00:19:36,850
histogram there is with the default

00:19:34,960 --> 00:19:39,549
arguments and it's a little bit ugly but

00:19:36,850 --> 00:19:42,580
once you've tuned down those those late

00:19:39,549 --> 00:19:44,169
the transport control arguments you can

00:19:42,580 --> 00:19:46,620
you can turn around information very

00:19:44,169 --> 00:19:46,620
very quickly

00:19:48,419 --> 00:19:54,039
so a couple notable blocks that are

00:19:51,159 --> 00:19:55,720
included in this there are I won't read

00:19:54,039 --> 00:19:59,169
all of these off it's mostly included

00:19:55,720 --> 00:20:01,529
just as a reference but there are a

00:19:59,169 --> 00:20:04,690
whole bunch of really really useful

00:20:01,529 --> 00:20:07,690
capabilities beyond just the stream

00:20:04,690 --> 00:20:09,970
conversion blocks we talked about that

00:20:07,690 --> 00:20:12,190
pretty well but in addition there are

00:20:09,970 --> 00:20:13,660
or some other kind of useful interesting

00:20:12,190 --> 00:20:16,120
things you can start doing once you

00:20:13,660 --> 00:20:18,160
adopt this methodology so there's this

00:20:16,120 --> 00:20:19,480
tag message trigger block which allows

00:20:18,160 --> 00:20:21,730
you based on certain streaming

00:20:19,480 --> 00:20:23,410
conditions to emit a message and this is

00:20:21,730 --> 00:20:25,540
really helpful if you want to send like

00:20:23,410 --> 00:20:28,360
an acknowledgement whenever you get a

00:20:25,540 --> 00:20:31,540
certain type of energy you can this this

00:20:28,360 --> 00:20:33,790
block can do that based on tag keys you

00:20:31,540 --> 00:20:36,040
can provide an arming condition before

00:20:33,790 --> 00:20:37,300
that block will actually trigger there

00:20:36,040 --> 00:20:39,580
are a whole bunch of things you can do

00:20:37,300 --> 00:20:42,100
there and it can emit fixed messages or

00:20:39,580 --> 00:20:46,420
time PDUs so if you want to reply

00:20:42,100 --> 00:20:50,020
exactly 2.000 milliseconds after you

00:20:46,420 --> 00:20:52,390
receive energy of some of specifies

00:20:50,020 --> 00:20:55,540
format or whatever you can use this

00:20:52,390 --> 00:20:58,660
block to change the transmit time

00:20:55,540 --> 00:21:01,150
accordingly and and it will very very

00:20:58,660 --> 00:21:04,120
reliably within a few microseconds emit

00:21:01,150 --> 00:21:07,510
that message at that time there are data

00:21:04,120 --> 00:21:09,940
converter box so that the first PDU I

00:21:07,510 --> 00:21:12,550
showed was a bunch of ones and zeros

00:21:09,940 --> 00:21:15,370
represented as a bit provide there are

00:21:12,550 --> 00:21:18,430
blocks to convert that into you know to

00:21:15,370 --> 00:21:22,960
stuff those bits into bytes there is a

00:21:18,430 --> 00:21:25,600
really cool block so Michael Osman over

00:21:22,960 --> 00:21:28,810
here put together a really good talk on

00:21:25,600 --> 00:21:32,380
whole packet clock recovery and so we

00:21:28,810 --> 00:21:34,600
implemented that as as a as a block

00:21:32,380 --> 00:21:35,710
within the PDU utilities and it's really

00:21:34,600 --> 00:21:37,510
interesting because you don't need to

00:21:35,710 --> 00:21:41,170
know too much about the symbol rate of

00:21:37,510 --> 00:21:43,570
information and it will it will attempt

00:21:41,170 --> 00:21:46,600
to using that algorithm it will attempt

00:21:43,570 --> 00:21:48,640
to determine what the clock rate is it

00:21:46,600 --> 00:21:50,530
will append that as a metadata tag into

00:21:48,640 --> 00:21:51,850
your dictionary and it will provide you

00:21:50,530 --> 00:21:53,560
out soft symbols and I have a little

00:21:51,850 --> 00:21:58,360
demonstration that I'll do in a minute

00:21:53,560 --> 00:22:00,960
on that there's also some kind of

00:21:58,360 --> 00:22:04,240
strange blocks like this flow controller

00:22:00,960 --> 00:22:06,850
basically this block checks buffer sizes

00:22:04,240 --> 00:22:09,070
checks how many PDU messages have been

00:22:06,850 --> 00:22:10,990
accumulated in the input queues for

00:22:09,070 --> 00:22:13,360
these blocks and will actually start

00:22:10,990 --> 00:22:16,510
dropping them if they get too full it's

00:22:13,360 --> 00:22:19,230
kind of dangerous maybe don't use it but

00:22:16,510 --> 00:22:19,230
it is there

00:22:21,190 --> 00:22:24,850
so real quick I'll just talk through a

00:22:23,140 --> 00:22:28,210
couple other modules that are included

00:22:24,850 --> 00:22:29,710
in this there's I talked about PDU utils

00:22:28,210 --> 00:22:32,290
there's a timing you toast and there's

00:22:29,710 --> 00:22:35,650
the southern module fhss utils so we

00:22:32,290 --> 00:22:37,720
built this this module to receive energy

00:22:35,650 --> 00:22:41,260
from a frequency hopping transmitter

00:22:37,720 --> 00:22:43,990
that was sitting in an is M band this is

00:22:41,260 --> 00:22:45,790
derived from GR iridium so I don't know

00:22:43,990 --> 00:22:48,370
if anyone who worked on their build gr

00:22:45,790 --> 00:22:50,140
iridium is here but if you want to

00:22:48,370 --> 00:22:52,510
receive iridium information you have a

00:22:50,140 --> 00:22:53,920
similar problem that we did receiving

00:22:52,510 --> 00:22:58,270
hopping data that you don't know what

00:22:53,920 --> 00:23:00,310
frequency it's at iridium is a satellite

00:22:58,270 --> 00:23:02,500
system as data satellite system and

00:23:00,310 --> 00:23:05,050
while it is channelized and you could

00:23:02,500 --> 00:23:07,870
say I'm gonna look at channel you know

00:23:05,050 --> 00:23:08,350
47 and there's a frequency associated

00:23:07,870 --> 00:23:10,420
with it

00:23:08,350 --> 00:23:13,000
the the iridium constellation that

00:23:10,420 --> 00:23:14,440
Doppler spread is wider than the channel

00:23:13,000 --> 00:23:15,670
width so you effectively have a similar

00:23:14,440 --> 00:23:17,380
problem where you need to be able to

00:23:15,670 --> 00:23:19,750
receive energy from anywhere in the

00:23:17,380 --> 00:23:23,950
entire ten or so megahertz that iridium

00:23:19,750 --> 00:23:27,370
exists so to do that they built this FFT

00:23:23,950 --> 00:23:30,730
based energy detector and what that does

00:23:27,370 --> 00:23:32,560
is whenever it sees energy it puts a tag

00:23:30,730 --> 00:23:33,790
into the sample stream so you get timing

00:23:32,560 --> 00:23:36,220
information and that tag contains

00:23:33,790 --> 00:23:37,930
frequency information as well the

00:23:36,220 --> 00:23:40,210
downstream blocks kind of segment that

00:23:37,930 --> 00:23:43,420
out they time sliced them and then they

00:23:40,210 --> 00:23:46,900
frequency they they recenter and

00:23:43,420 --> 00:23:49,450
decimate the verse significantly so this

00:23:46,900 --> 00:23:52,060
is very convenient in a general sense so

00:23:49,450 --> 00:23:54,850
we sort of retooled this into just two

00:23:52,060 --> 00:23:56,950
blocks here where you tag energy and so

00:23:54,850 --> 00:23:59,080
the input there is a sample stream and

00:23:56,950 --> 00:24:01,720
the output is a tagged sample stream and

00:23:59,080 --> 00:24:03,100
then this tag bursts PDU block is going

00:24:01,720 --> 00:24:07,770
to take all of those and admit them as

00:24:03,100 --> 00:24:11,400
individual individual PDU messages so

00:24:07,770 --> 00:24:14,770
what that looks like here's kind of a

00:24:11,400 --> 00:24:16,870
real-world very clean is M band

00:24:14,770 --> 00:24:19,270
recording and what you get out of that

00:24:16,870 --> 00:24:22,660
if you run that through the FA those two

00:24:19,270 --> 00:24:24,760
FHSS utils blocks is you get a bunch of

00:24:22,660 --> 00:24:27,100
detections that end up highlighted there

00:24:24,760 --> 00:24:30,250
and as an output of those you end up

00:24:27,100 --> 00:24:32,050
with with the the uniform vector

00:24:30,250 --> 00:24:34,890
representing the raw data of that of

00:24:32,050 --> 00:24:37,500
that sample what you also get

00:24:34,890 --> 00:24:39,470
that's really cool is you can start

00:24:37,500 --> 00:24:41,970
making measurements about that and

00:24:39,470 --> 00:24:43,500
Pindos is metadata in that dictionary so

00:24:41,970 --> 00:24:45,330
in this case you have things like a

00:24:43,500 --> 00:24:47,820
symbol rate estimate which the whole

00:24:45,330 --> 00:24:51,450
packet clock recovery block gave you you

00:24:47,820 --> 00:24:54,780
have these are kind of small noise

00:24:51,450 --> 00:24:56,640
information about the the FFT binned

00:24:54,780 --> 00:24:58,380
that that was detected from as well as

00:24:56,640 --> 00:25:00,840
magnitude information on the signal

00:24:58,380 --> 00:25:04,160
these are unitless but useful in a

00:25:00,840 --> 00:25:06,120
relative sense bandwidth information

00:25:04,160 --> 00:25:07,470
it's kind of cool and you can start

00:25:06,120 --> 00:25:10,560
making additional measurements on this

00:25:07,470 --> 00:25:12,090
and kind of get a good sense without

00:25:10,560 --> 00:25:13,530
knowing almost anything about what

00:25:12,090 --> 00:25:16,260
what's out in the I sim ban you can get

00:25:13,530 --> 00:25:17,760
a sense for what's there so it's not

00:25:16,260 --> 00:25:20,850
perfect but it does work pretty well

00:25:17,760 --> 00:25:25,740
down to about 6 DB signal-to-noise ratio

00:25:20,850 --> 00:25:29,070
for for data out there if you do use

00:25:25,740 --> 00:25:31,200
this for for long signals or very short

00:25:29,070 --> 00:25:33,590
signals you'll need to tune it it does a

00:25:31,200 --> 00:25:36,240
lot of work to kick out false detection

00:25:33,590 --> 00:25:37,550
and primarily it does that based on time

00:25:36,240 --> 00:25:39,780
think it's very very very short

00:25:37,550 --> 00:25:41,850
detections which it does all the time it

00:25:39,780 --> 00:25:44,430
will not emit those to prevent you from

00:25:41,850 --> 00:25:46,560
getting totally swamped with data and

00:25:44,430 --> 00:25:48,090
then this other module that we published

00:25:46,560 --> 00:25:50,580
we talked about should we publish this

00:25:48,090 --> 00:25:53,070
or not this Sandia Utilities is our

00:25:50,580 --> 00:25:56,430
dumping ground but it does contain a lot

00:25:53,070 --> 00:25:57,840
of even a lot of pre-release stuff

00:25:56,430 --> 00:26:02,370
before we're able to upstream them

00:25:57,840 --> 00:26:04,680
especially with with 3/7 not getting any

00:26:02,370 --> 00:26:06,660
feature changes when we want to add

00:26:04,680 --> 00:26:08,130
little little stuff to blocks that we

00:26:06,660 --> 00:26:11,100
find are generally useful we'll store

00:26:08,130 --> 00:26:12,780
them here and it also contains other

00:26:11,100 --> 00:26:15,210
really really dangerous blocks like this

00:26:12,780 --> 00:26:18,240
block buffer thing the intention of this

00:26:15,210 --> 00:26:21,050
block buffer is to do whatever it can to

00:26:18,240 --> 00:26:23,400
provide you continuous chunks of data so

00:26:21,050 --> 00:26:25,020
say you have a processor that can't come

00:26:23,400 --> 00:26:27,570
anywhere close to keeping up with your

00:26:25,020 --> 00:26:30,180
use your UHD data stream it will do

00:26:27,570 --> 00:26:32,220
whatever it can to provide you only

00:26:30,180 --> 00:26:33,870
continuous chunks of data it sounds very

00:26:32,220 --> 00:26:36,060
simple but it ends up with all sorts of

00:26:33,870 --> 00:26:39,810
absolutely horrendous side effects and

00:26:36,060 --> 00:26:41,400
edge cases so if you're using our rgr

00:26:39,810 --> 00:26:43,700
toolkit I recommend you install this one

00:26:41,400 --> 00:26:43,700
as well

00:26:44,580 --> 00:26:48,000
this isn't this isn't out yet I

00:26:46,320 --> 00:26:48,690
apologize I mentioned that we extended

00:26:48,000 --> 00:26:50,750
some of these time

00:26:48,690 --> 00:26:53,070
Tagg features for the sidekick radios

00:26:50,750 --> 00:26:55,770
this is something we will get out there

00:26:53,070 --> 00:26:57,090
soon ish where we're working with epic

00:26:55,770 --> 00:26:59,280
to figure out the right way to make this

00:26:57,090 --> 00:27:01,320
live I call this yet another gr sidekick

00:26:59,280 --> 00:27:04,190
there are at least five of you in this

00:27:01,320 --> 00:27:05,820
room who've built your own gr sidekick

00:27:04,190 --> 00:27:08,790
that's okay

00:27:05,820 --> 00:27:11,760
we built our own too but we will try to

00:27:08,790 --> 00:27:15,120
make this out there it does have DCs and

00:27:11,760 --> 00:27:18,030
D UCS and the FPGA there are there are

00:27:15,120 --> 00:27:19,170
command queues and time tag support is

00:27:18,030 --> 00:27:24,780
really really helpful if you're trying

00:27:19,170 --> 00:27:27,270
to do any transmission so some things I

00:27:24,780 --> 00:27:29,610
kind of take aways PMT's are are

00:27:27,270 --> 00:27:31,020
underutilized they really are there's a

00:27:29,610 --> 00:27:33,420
ton of stuff you can do with them and

00:27:31,020 --> 00:27:35,100
they're very powerful you just have to

00:27:33,420 --> 00:27:40,110
deal with a small amount of frustrating

00:27:35,100 --> 00:27:44,070
PMT behavior this is how this is how ed

00:27:40,110 --> 00:27:48,210
us handle x' command information into

00:27:44,070 --> 00:27:49,980
the uhd blocks the PMT dictionaries

00:27:48,210 --> 00:27:51,750
there this is just an example of the

00:27:49,980 --> 00:27:54,780
frustrating stuff you have to deal with

00:27:51,750 --> 00:27:56,520
sometimes PMT pairs and dictionaries

00:27:54,780 --> 00:27:58,230
both pass the tests for each other

00:27:56,520 --> 00:27:58,850
because dictionaries are composed of

00:27:58,230 --> 00:28:01,050
pairs

00:27:58,850 --> 00:28:02,400
however they process differently so you

00:28:01,050 --> 00:28:04,100
have to do some kind of weird stuff to

00:28:02,400 --> 00:28:07,860
figure it out

00:28:04,100 --> 00:28:12,090
the this module I hope helps bridge the

00:28:07,860 --> 00:28:14,510
PDU and streaming api's and and methods

00:28:12,090 --> 00:28:16,500
of doing this

00:28:14,510 --> 00:28:18,090
there are straightforward tools that are

00:28:16,500 --> 00:28:20,250
available out there now for developing

00:28:18,090 --> 00:28:22,350
bursty transceivers frequency-hopping

00:28:20,250 --> 00:28:27,240
transceivers in kind of a different way

00:28:22,350 --> 00:28:31,500
than we've seen done so far and you can

00:28:27,240 --> 00:28:34,080
you can do low latency systems with

00:28:31,500 --> 00:28:37,980
engineer radios you do not need to do

00:28:34,080 --> 00:28:40,110
this all in c++ or something I kind of

00:28:37,980 --> 00:28:42,090
hope that some of these tools are are

00:28:40,110 --> 00:28:43,920
useful enough that we talk about pulling

00:28:42,090 --> 00:28:48,330
them into a new radio certainly some of

00:28:43,920 --> 00:28:50,760
the basic like PDU data manipulation

00:28:48,330 --> 00:28:52,950
just like counting peta blocked account

00:28:50,760 --> 00:28:54,300
pd use for example this type of thing is

00:28:52,950 --> 00:28:55,590
pretty useful in general and I'd like to

00:28:54,300 --> 00:28:58,040
see them pulled in to get new radio at

00:28:55,590 --> 00:28:58,040
some point

00:28:59,240 --> 00:29:04,490
so thanks thanks for time this is a

00:29:02,990 --> 00:29:06,770
picture of our github as of yesterday

00:29:04,490 --> 00:29:09,649
afternoon so go go download these if

00:29:06,770 --> 00:29:14,360
this would be useful to you and and let

00:29:09,649 --> 00:29:16,250
us know if if they're helpful I will do

00:29:14,360 --> 00:29:23,510
a couple things real quick since I think

00:29:16,250 --> 00:29:26,090
I have a few minutes so I will attempt

00:29:23,510 --> 00:29:28,190
to run this one of the examples that's

00:29:26,090 --> 00:29:31,730
included with the frequency-hopping

00:29:28,190 --> 00:29:34,399
utils module is this arbitrary sort of

00:29:31,730 --> 00:29:36,470
energy detector I'll run this over the

00:29:34,399 --> 00:29:38,090
air I have a user appear on my laptop I

00:29:36,470 --> 00:29:41,450
don't know if it'll actually pick much

00:29:38,090 --> 00:29:43,850
up so this is tuned to the nine hundred

00:29:41,450 --> 00:29:49,669
is M band that's about thirty megahertz

00:29:43,850 --> 00:29:51,590
wide that input spectrogram and there's

00:29:49,669 --> 00:29:53,659
not a lot going on here this is probably

00:29:51,590 --> 00:29:58,850
like capture the flag spoilers or

00:29:53,659 --> 00:30:04,130
something I don't know but anyhow at

00:29:58,850 --> 00:30:06,590
least are spoiled for everybody so this

00:30:04,130 --> 00:30:10,460
I will say this does not look like it is

00:30:06,590 --> 00:30:12,350
any sort of like FSK signal or something

00:30:10,460 --> 00:30:15,669
this FM demodulation window here is

00:30:12,350 --> 00:30:18,760
showing kind of zoom in a little bit oh

00:30:15,669 --> 00:30:21,649
that's for even more spoilers isn't it

00:30:18,760 --> 00:30:23,450
what I can do though is I have a data

00:30:21,649 --> 00:30:29,299
recording that will be a little bit more

00:30:23,450 --> 00:30:33,020
interesting so here's one that actually

00:30:29,299 --> 00:30:35,360
has this is what the is M band looks

00:30:33,020 --> 00:30:38,120
like a lot more frequently and so what

00:30:35,360 --> 00:30:40,279
you're seeing there is you know the

00:30:38,120 --> 00:30:42,110
input spectrogram it's kind of hard to

00:30:40,279 --> 00:30:44,600
see up there but there are little bursts

00:30:42,110 --> 00:30:46,909
of data all over the place see if I can

00:30:44,600 --> 00:30:47,750
make it so that it is more obvious for

00:30:46,909 --> 00:30:49,460
you guys

00:30:47,750 --> 00:30:50,600
there that looks better see how these

00:30:49,460 --> 00:30:53,539
little things hopping around I don't

00:30:50,600 --> 00:30:55,010
know a lot of these a lot of these look

00:30:53,539 --> 00:30:58,010
very similar so they're probably from

00:30:55,010 --> 00:30:59,929
the same the same family of of radios

00:30:58,010 --> 00:31:03,409
but what you're seeing there is

00:30:59,929 --> 00:31:04,940
completely uninformed just quadrature

00:31:03,409 --> 00:31:06,620
demodulation and the FM demodulation

00:31:04,940 --> 00:31:09,289
window there in the middle and then that

00:31:06,620 --> 00:31:11,990
soft symbol output is the result of the

00:31:09,289 --> 00:31:13,070
whole packet clock recovery and when you

00:31:11,990 --> 00:31:14,600
see them very nice

00:31:13,070 --> 00:31:16,370
a line like that you can tell that it is

00:31:14,600 --> 00:31:18,909
actually you know it is actually doing

00:31:16,370 --> 00:31:24,860
symbol alignment and what's really cool

00:31:18,909 --> 00:31:26,210
if so what you can see here down in the

00:31:24,860 --> 00:31:27,740
window and I don't know if you guys can

00:31:26,210 --> 00:31:30,230
read all of this but I was talking about

00:31:27,740 --> 00:31:34,940
all that metadata and what you're seeing

00:31:30,230 --> 00:31:37,279
there in sort of real-time is all that

00:31:34,940 --> 00:31:38,240
information popping out so you're

00:31:37,279 --> 00:31:40,429
getting center frequency information

00:31:38,240 --> 00:31:44,000
duration information time information

00:31:40,429 --> 00:31:47,629
power and then symbol rate so a lot of

00:31:44,000 --> 00:31:50,809
these are like 165 Kilis and bulls per

00:31:47,629 --> 00:31:52,279
second this is cool because I didn't

00:31:50,809 --> 00:31:56,529
know that I don't know what's in this

00:31:52,279 --> 00:31:58,879
file it was recorded from somewhere and

00:31:56,529 --> 00:32:03,799
you're able to pull that out completely

00:31:58,879 --> 00:32:05,240
uninformed so anyhow give these tools a

00:32:03,799 --> 00:32:07,159
try they're kind of interesting I have

00:32:05,240 --> 00:32:09,009
one other demo I can do that I'll show

00:32:07,159 --> 00:32:12,740
you what that latency test looks like

00:32:09,009 --> 00:32:16,279
and so this this flow graph is included

00:32:12,740 --> 00:32:21,289
in the in the FHSS utils example file

00:32:16,279 --> 00:32:22,879
and then here's that latency determining

00:32:21,289 --> 00:32:25,460
flow graph one second

00:32:22,879 --> 00:32:30,080
I'll run it first with the default UHD

00:32:25,460 --> 00:32:32,000
arguments the the default transport

00:32:30,080 --> 00:32:38,870
control which I don't know what it is

00:32:32,000 --> 00:32:42,080
somebody does and so what you can see

00:32:38,870 --> 00:32:46,009
here is the scale on the bottom is in

00:32:42,080 --> 00:32:49,730
microseconds this this start window here

00:32:46,009 --> 00:32:51,889
is at five five microseconds and my

00:32:49,730 --> 00:32:54,139
cursor over here is it I'm sorry five

00:32:51,889 --> 00:32:56,720
milliseconds my cursor here right here

00:32:54,139 --> 00:33:01,610
is about ten milliseconds so what you're

00:32:56,720 --> 00:33:03,860
seeing there is that packet buffer delay

00:33:01,610 --> 00:33:05,690
so the reason it's cycling like that is

00:33:03,860 --> 00:33:07,730
sometimes that burst is right at the

00:33:05,690 --> 00:33:09,080
very end of a block of data in which

00:33:07,730 --> 00:33:10,549
case you can respond to it very very

00:33:09,080 --> 00:33:12,230
quickly and sometimes that burst is at

00:33:10,549 --> 00:33:14,360
the beginning of a block of data so

00:33:12,230 --> 00:33:15,799
somewhere in there there's buffering

00:33:14,360 --> 00:33:19,429
that's adding up to two or three

00:33:15,799 --> 00:33:23,659
milliseconds of data and you can kind of

00:33:19,429 --> 00:33:26,269
see that see that running through this

00:33:23,659 --> 00:33:26,960
flow graph if you're interested amongst

00:33:26,269 --> 00:33:29,240
so this

00:33:26,960 --> 00:33:33,020
built with live blog for CPP so I'm

00:33:29,240 --> 00:33:35,720
getting all these debug messages but you

00:33:33,020 --> 00:33:38,179
know it's printing out the the the

00:33:35,720 --> 00:33:43,820
latency in milliseconds but what's cool

00:33:38,179 --> 00:33:45,799
if we use a different value for the

00:33:43,820 --> 00:33:49,460
receive frame size and thus in frame

00:33:45,799 --> 00:33:51,289
size you can use this to figure out what

00:33:49,460 --> 00:33:58,220
that impact is and without changing

00:33:51,289 --> 00:34:00,529
anything other than that value now

00:33:58,220 --> 00:34:03,230
you're looking at so my cursor is at 6

00:34:00,529 --> 00:34:06,279
milliseconds here and it starts at 5 so

00:34:03,230 --> 00:34:11,300
now you're looking at like 200 to 500

00:34:06,279 --> 00:34:12,830
microseconds of turnaround time there's

00:34:11,300 --> 00:34:15,560
a there's one of these for the sidekick

00:34:12,830 --> 00:34:20,419
tool too if that's of interest to you

00:34:15,560 --> 00:34:22,070
but yeah if you want talked talk about

00:34:20,419 --> 00:34:24,849
any of this let me know if you want to

00:34:22,070 --> 00:34:28,210
see the demo all I'll have it with me

00:34:24,849 --> 00:34:28,210
that's what I got

00:34:32,810 --> 00:34:45,840
thank you very much Jacob all right do

00:34:35,760 --> 00:34:48,150
we have any questions for Jacob Kyle hey

00:34:45,840 --> 00:34:50,370
there thanks I think this is actually

00:34:48,150 --> 00:34:52,500
really awesome I'm sure a lot of

00:34:50,370 --> 00:34:54,540
companies like I mean we've definitely

00:34:52,500 --> 00:34:57,510
built utilities that have done burst

00:34:54,540 --> 00:34:59,220
processing on the back end via zmq or

00:34:57,510 --> 00:35:00,570
something else right a lot of companies

00:34:59,220 --> 00:35:02,880
have had to do that so this would

00:35:00,570 --> 00:35:05,460
actually be really useful my question

00:35:02,880 --> 00:35:08,310
was about the the buffer detect or the

00:35:05,460 --> 00:35:10,170
block buffer yes one

00:35:08,310 --> 00:35:13,140
so does that detect like upstream

00:35:10,170 --> 00:35:15,240
discontinuities like in the signal and

00:35:13,140 --> 00:35:17,310
then it tries to build like a one

00:35:15,240 --> 00:35:18,780
megabyte or like a huge block of data

00:35:17,310 --> 00:35:21,630
that's continuous that's how it works

00:35:18,780 --> 00:35:24,000
pretty much it doesn't do any sort of

00:35:21,630 --> 00:35:25,740
like data aided detection it uses tags

00:35:24,000 --> 00:35:29,280
it relies on something having knowledge

00:35:25,740 --> 00:35:32,330
of dropping data and it uses tags to do

00:35:29,280 --> 00:35:35,370
that will it detect like the US do you

00:35:32,330 --> 00:35:37,500
so oh you sprinted out by the logging

00:35:35,370 --> 00:35:39,570
part of Libya HD I think but what it

00:35:37,500 --> 00:35:42,260
will detect is the source block puts a

00:35:39,570 --> 00:35:44,580
tag when there's a discontinuity

00:35:42,260 --> 00:35:47,130
frustratingly sometimes that tag is

00:35:44,580 --> 00:35:48,660
after the discontinuity so you're sort

00:35:47,130 --> 00:35:50,640
of limited to what your hardware will

00:35:48,660 --> 00:35:53,040
allow you to do but there's a similar

00:35:50,640 --> 00:35:54,810
construct within lib sidekick that it

00:35:53,040 --> 00:35:56,850
will detect that those blocks will

00:35:54,810 --> 00:36:03,600
detect it but it's basically doing tag

00:35:56,850 --> 00:36:08,040
based detection of drop data cool any

00:36:03,600 --> 00:36:10,830
other questions from the audience okay

00:36:08,040 --> 00:36:12,300
we have several now all right might take

00:36:10,830 --> 00:36:15,050
just one or two more and then go to

00:36:12,300 --> 00:36:17,430
break where'd the hand come from

00:36:15,050 --> 00:36:20,180
nice and quick are you going to port it

00:36:17,430 --> 00:36:20,180
to gr3 eight

00:36:22,170 --> 00:36:26,650
[Laughter]

00:36:27,130 --> 00:36:36,680
wrap it up bin yeah we will eventually

00:36:33,230 --> 00:36:37,190
so the truth is like we have a lot of

00:36:36,680 --> 00:36:38,810
work

00:36:37,190 --> 00:36:41,270
oh we're hiring did I say that the other

00:36:38,810 --> 00:36:43,310
day yeah like everybody else we're

00:36:41,270 --> 00:36:45,710
really busy we'd really liked you the

00:36:43,310 --> 00:36:47,780
honest truth is I attempted to build 3/8

00:36:45,710 --> 00:36:48,860
from pie bombs like a month ago and it

00:36:47,780 --> 00:36:51,140
didn't feel the first time so I was like

00:36:48,860 --> 00:36:54,610
I'll just come back to this later and we

00:36:51,140 --> 00:36:58,100
will where is Ryan are you here Ryan

00:36:54,610 --> 00:37:01,910
Ryan told me so Ryan works for another

00:36:58,100 --> 00:37:03,530
deal.we lab he told me that he got some

00:37:01,910 --> 00:37:04,910
of it working in 3/8 you could talk to

00:37:03,530 --> 00:37:08,900
talk to the guy with his hand up over

00:37:04,910 --> 00:37:09,950
there all right another few other

00:37:08,900 --> 00:37:11,780
questions I think we're going to end it

00:37:09,950 --> 00:37:13,940
so I really want to thank Jacob this is

00:37:11,780 --> 00:37:15,350
a significant country and everyone who

00:37:13,940 --> 00:37:17,960
contributed from Scindia this is a

00:37:15,350 --> 00:37:19,460
really significant release of tools I

00:37:17,960 --> 00:37:22,490
think were badly needed I hope it's

00:37:19,460 --> 00:37:24,050
helpful if you want it so if you do want

00:37:22,490 --> 00:37:27,050
to talk to me about this anyone feel

00:37:24,050 --> 00:37:28,550
free to come up also if you are with the

00:37:27,050 --> 00:37:31,250
government and you're curious about how

00:37:28,550 --> 00:37:33,410
I went through my process maybe it's

00:37:31,250 --> 00:37:35,630
helpful to you maybe it's not especially

00:37:33,410 --> 00:37:37,460
if you're do a government I can possibly

00:37:35,630 --> 00:37:39,650
help with that too but it's worth

00:37:37,460 --> 00:37:41,510
getting code out there I feel bad this I

00:37:39,650 --> 00:37:42,950
feel bad not having this out two years

00:37:41,510 --> 00:37:44,480
ago when a lot of it was written right

00:37:42,950 --> 00:37:48,080
like it just is a lot of energy

00:37:44,480 --> 00:37:49,640
sometimes so yeah so I round of applause

00:37:48,080 --> 00:37:51,970
for Jacob first talk and for getting his

00:37:49,640 --> 00:37:51,970

YouTube URL: https://www.youtube.com/watch?v=YPfkjWtIFXs


