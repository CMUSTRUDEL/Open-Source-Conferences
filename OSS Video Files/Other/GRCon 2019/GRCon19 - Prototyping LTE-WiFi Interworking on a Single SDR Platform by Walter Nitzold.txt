Title: GRCon19 - Prototyping LTE-WiFi Interworking on a Single SDR Platform by Walter Nitzold
Publication date: 2019-11-05
Playlist: GRCon 2019
Description: 
	Prototyping LTE-WiFi Interworking on a Single SDR Platform by Walter Nitzold, Clemens Felber, Vincent Kotzsch

New use cases and requirements of future communication systems have driven the focus of research towards the coordination and coexistence of heterogeneous wireless technologies such as LTE, WiFi as well as 5G. We present a prototyping system focused on the joint real-time prototyping of LTE and WiFi. The system consists of real-time FPGA implementations of WiFi and LTE PHY layers using NI Application Frameworks. These run on the FPGAs of an USRP-2974 and an attached USRP-2953. A complete setup for joint prototyping would consist of a USRP-2974 and USRP-2953 as LTE eNB and WiFi AP while a second USRP-2974 and USRP-2953 are used as LTE UE and WiFi STA. To integrate the PHY layer implementations with higher layers and enable joint prototyping of these two wireless standards, we use network simulator 3 (ns3) â€“ a widely known open-source simulation environment for end-to-end communication research. Our contribution is a generalized API definition that specifies the connection between the PHY and the MAC layer. The API itself is vendor-independent and can be used to interface any LTE and WiFi PHY implementation with any given MAC layer implementations of LTE and WiFi. We exemplarily implemented this API within the LTE and WiFi Application Frameworks as well as in ns3 such that LTE and WiFi is directly coupled to ns3. With this system, one can model arbitrary network topologies in ns3 that include LTE and WiFi radio access technologies and benefit from the use of real SDR hardware and over-the-air (OTA) transmission on the PHY layer. In this respect, the system bridges the gap between network research and real-world SDR prototyping and therefore enables real-world experiments to be as easy as simulations. The API specification itself is openly available as part of the user manuals of the NI LTE and 802.11 Application Frameworks. Our exemplary implementations of the API can be found in the NI LTE and 802.11 Application Frameworks as well as in a customized implementation of ns3 to be accessed under https://github.com/ni/NI-ns3-ApplicationExample. The use of an USRP-2974 has been shown beneficial as this device includes an embedded controller with Intel CPU that can directly run the API handler as well as ns3 on a real-time Linux and therefore make efficient use of the computing resources with a small footprint.
Captions: 
	00:00:14,929 --> 00:00:21,410
so this is the last talk for today yes

00:00:18,080 --> 00:00:23,539
and it is so as being in German myself

00:00:21,410 --> 00:00:24,800
the last thing I want to do is keeping

00:00:23,539 --> 00:00:27,650
us off and going to the German beer

00:00:24,800 --> 00:00:30,710
garden so I bear with me I tried to keep

00:00:27,650 --> 00:00:31,970
things brief but anyway I have to tell

00:00:30,710 --> 00:00:34,339
you something so my name is Walter an

00:00:31,970 --> 00:00:37,820
insult and I'm from National Instruments

00:00:34,339 --> 00:00:39,830
in Dresden Germany actually where I'm

00:00:37,820 --> 00:00:44,750
part of a small research team that is

00:00:39,830 --> 00:00:48,860
basically drawn to ya communications

00:00:44,750 --> 00:00:50,510
research 405-g and Beyond communication

00:00:48,860 --> 00:00:54,589
systems and what we do is that we

00:00:50,510 --> 00:00:58,489
basically participate in you funded or

00:00:54,589 --> 00:01:01,519
other lis funded research projects ya to

00:00:58,489 --> 00:01:03,140
do research yes exactly so let's work

00:01:01,519 --> 00:01:07,130
that I did together with my colleagues

00:01:03,140 --> 00:01:10,490
Clements Felber and Vincent coach and I

00:01:07,130 --> 00:01:13,220
wanted to talk a little bit about how to

00:01:10,490 --> 00:01:15,950
prototype LTE and Wi-Fi interworking

00:01:13,220 --> 00:01:20,950
technologies and especially doing that

00:01:15,950 --> 00:01:24,050
on an SDR platform so the question is

00:01:20,950 --> 00:01:25,700
yeah what does motivate that work and I

00:01:24,050 --> 00:01:28,550
think we have heard it before in some of

00:01:25,700 --> 00:01:30,500
the other talks already that with future

00:01:28,550 --> 00:01:32,330
and upcoming communication systems like

00:01:30,500 --> 00:01:34,909
5g and so on there are lots of different

00:01:32,330 --> 00:01:37,580
applications that pop up like whatever a

00:01:34,909 --> 00:01:40,610
virtual reality and high-throughput

00:01:37,580 --> 00:01:42,680
video streaming or whatever so there is

00:01:40,610 --> 00:01:45,290
a quite a big demand for a higher

00:01:42,680 --> 00:01:46,880
throughput but on the other hand also

00:01:45,290 --> 00:01:48,590
for lower latency so those different

00:01:46,880 --> 00:01:52,520
KPIs or metrics that need to be

00:01:48,590 --> 00:01:54,530
optimized and you can do two things for

00:01:52,520 --> 00:01:56,330
that the one thing is that you can

00:01:54,530 --> 00:01:59,240
optimize the radio access technology

00:01:56,330 --> 00:02:04,250
itself that is done for example in LTE

00:01:59,240 --> 00:02:06,920
and Wi-Fi itself but what is a currently

00:02:04,250 --> 00:02:08,929
ongoing and interesting new research or

00:02:06,920 --> 00:02:10,280
a communications paradigm is actually to

00:02:08,929 --> 00:02:12,500
combine different radio access

00:02:10,280 --> 00:02:15,799
technologies and yeah do inter working

00:02:12,500 --> 00:02:17,450
between those different technologies and

00:02:15,799 --> 00:02:19,640
this is a little bit motivated by an end

00:02:17,450 --> 00:02:22,730
to end point of view that an application

00:02:19,640 --> 00:02:24,680
doesn't care about the underlying

00:02:22,730 --> 00:02:26,810
communication technology as long as

00:02:24,680 --> 00:02:28,090
those kpi is like throughput and latency

00:02:26,810 --> 00:02:32,409
are

00:02:28,090 --> 00:02:34,780
satisfied so it's kind of a transparent

00:02:32,409 --> 00:02:36,549
and to end point of view that we have

00:02:34,780 --> 00:02:38,709
here in mind and this is what we wanted

00:02:36,549 --> 00:02:43,180
to study in conjunction with a research

00:02:38,709 --> 00:02:44,829
project that we did in Germany so the

00:02:43,180 --> 00:02:47,790
question for us was how to actually

00:02:44,829 --> 00:02:49,719
study those interpreting technologies

00:02:47,790 --> 00:02:52,060
you can see that here on the bottom

00:02:49,719 --> 00:02:53,680
actually just just to a conclusion that

00:02:52,060 --> 00:02:55,120
you have a transmission or a

00:02:53,680 --> 00:02:56,980
communication system here where you have

00:02:55,120 --> 00:02:59,560
a server or an application and then you

00:02:56,980 --> 00:03:02,349
have a network in between and then you

00:02:59,560 --> 00:03:05,019
have the connection to a access point

00:03:02,349 --> 00:03:07,659
for Wi-Fi and to an annuity for LTE and

00:03:05,019 --> 00:03:11,500
they both are connected to one something

00:03:07,659 --> 00:03:13,449
that we would call a multi rut yeah

00:03:11,500 --> 00:03:15,099
user equipment or something which is

00:03:13,449 --> 00:03:16,840
kind of your normal mobile phone that

00:03:15,099 --> 00:03:20,980
has a Wi-Fi chip and it also has an LTE

00:03:16,840 --> 00:03:22,840
modem inside so and your application

00:03:20,980 --> 00:03:24,939
would actually talk to that so how can

00:03:22,840 --> 00:03:27,669
you actually yeah research these

00:03:24,939 --> 00:03:29,230
interworking technologies or these there

00:03:27,669 --> 00:03:31,930
was these two radio access technologies

00:03:29,230 --> 00:03:33,639
together and so we had a look into what

00:03:31,930 --> 00:03:36,909
is actually available and the open

00:03:33,639 --> 00:03:38,079
source world and also beyond that it

00:03:36,909 --> 00:03:40,989
turns out that there are quite a few

00:03:38,079 --> 00:03:43,989
solutions there so those are solutions

00:03:40,989 --> 00:03:46,000
that are actually not open source but

00:03:43,989 --> 00:03:47,829
commercial or I think yet SRS has

00:03:46,000 --> 00:03:50,290
something also available open source I

00:03:47,829 --> 00:03:52,060
think and on the bottom you see

00:03:50,290 --> 00:03:54,129
different options for open source

00:03:52,060 --> 00:03:57,519
implementations of different radio

00:03:54,129 --> 00:03:59,169
access technologies and they all

00:03:57,519 --> 00:04:01,900
basically all of them have different

00:03:59,169 --> 00:04:03,879
functionality for example open air

00:04:01,900 --> 00:04:06,699
interface is something that incorporates

00:04:03,879 --> 00:04:12,340
a T transmission and also has a path for

00:04:06,699 --> 00:04:15,370
5g a while Linux 802 max something that

00:04:12,340 --> 00:04:17,799
only incorporates Wi-Fi transmission and

00:04:15,370 --> 00:04:18,880
there is also an s3 so after looking

00:04:17,799 --> 00:04:22,449
through all those different simulators

00:04:18,880 --> 00:04:24,009
or technologies or software stacks we

00:04:22,449 --> 00:04:26,530
actually came up with the idea of using

00:04:24,009 --> 00:04:28,419
industry and it had certain reasons the

00:04:26,530 --> 00:04:32,009
first thing is it's open source so that

00:04:28,419 --> 00:04:34,509
was quite intriguing for us to use that

00:04:32,009 --> 00:04:37,240
and it actually allows for completely

00:04:34,509 --> 00:04:38,919
simulating IP networks within this

00:04:37,240 --> 00:04:40,810
network simulator so this was quite nice

00:04:38,919 --> 00:04:42,910
to have an overall system

00:04:40,810 --> 00:04:47,740
that can simulate a complete

00:04:42,910 --> 00:04:50,260
communication system but beyond that it

00:04:47,740 --> 00:04:51,639
also has support for different radio

00:04:50,260 --> 00:04:54,600
access technologies and we are

00:04:51,639 --> 00:04:57,310
especially interested in LTE and Wi-Fi

00:04:54,600 --> 00:04:58,930
so industry is actually capable of doing

00:04:57,310 --> 00:05:00,370
simulations for that so that's why we

00:04:58,930 --> 00:05:03,010
actually were drawn to this and we used

00:05:00,370 --> 00:05:04,930
and try to use that so the question for

00:05:03,010 --> 00:05:07,570
us is network simulator three and a

00:05:04,930 --> 00:05:08,910
three is purely for simulation stare so

00:05:07,570 --> 00:05:11,260
it's from the computer science community

00:05:08,910 --> 00:05:13,600
they use it completely for simulations

00:05:11,260 --> 00:05:16,710
so for us the question was how can we

00:05:13,600 --> 00:05:20,139
get rid of the simulated channel and

00:05:16,710 --> 00:05:21,460
yeah integrate real sdrs to have the

00:05:20,139 --> 00:05:23,760
chance to do real over-the-air

00:05:21,460 --> 00:05:25,570
transmission

00:05:23,760 --> 00:05:27,430
therefore we have to have a little bit

00:05:25,570 --> 00:05:29,410
of a look into I guess you are familiar

00:05:27,430 --> 00:05:31,810
with that the OSI model of transmission

00:05:29,410 --> 00:05:33,520
so the different layers of this

00:05:31,810 --> 00:05:35,200
transmission model that yeah kind of

00:05:33,520 --> 00:05:37,870
model different we are functionally

00:05:35,200 --> 00:05:41,950
within a communication system and if we

00:05:37,870 --> 00:05:45,610
look on to a specific LT stack

00:05:41,950 --> 00:05:47,080
implementation of this OSI model we can

00:05:45,610 --> 00:05:48,550
actually see the different layers for

00:05:47,080 --> 00:05:51,039
example we have to file a or on top I

00:05:48,550 --> 00:05:52,960
guess you all right aware of this how

00:05:51,039 --> 00:05:56,440
this thing works after physical layer

00:05:52,960 --> 00:05:58,030
who does specific functionality and then

00:05:56,440 --> 00:06:01,300
we have the other layers on top of that

00:05:58,030 --> 00:06:02,560
and you are basically giving different

00:06:01,300 --> 00:06:04,810
functionality for the communication

00:06:02,560 --> 00:06:05,979
system and then on top we have the user

00:06:04,810 --> 00:06:08,020
plate in the control plane which

00:06:05,979 --> 00:06:13,870
actually does the IP connection to some

00:06:08,020 --> 00:06:16,060
application in the end so for us we had

00:06:13,870 --> 00:06:17,560
some we were looking into some physical

00:06:16,060 --> 00:06:19,840
implementation it turns out that

00:06:17,560 --> 00:06:21,400
National Instruments itself has

00:06:19,840 --> 00:06:23,669
something available for the physical

00:06:21,400 --> 00:06:26,080
layer which is the application framework

00:06:23,669 --> 00:06:28,150
that has an LT and and why if our

00:06:26,080 --> 00:06:31,660
implementation could also be something

00:06:28,150 --> 00:06:33,520
else for example what I would be really

00:06:31,660 --> 00:06:35,850
interested is in to see is how we can

00:06:33,520 --> 00:06:38,050
especially use scanner radio and for

00:06:35,850 --> 00:06:40,630
simple physical layer implementations

00:06:38,050 --> 00:06:43,870
and especially also RF NOC for that that

00:06:40,630 --> 00:06:45,490
would be interesting but in that context

00:06:43,870 --> 00:06:47,289
we were missing the upper layers so the

00:06:45,490 --> 00:06:48,760
question was how do we use the upper

00:06:47,289 --> 00:06:52,180
layers and that's why we actually used

00:06:48,760 --> 00:06:53,240
NS three in the end so below that we

00:06:52,180 --> 00:06:55,759
have

00:06:53,240 --> 00:06:57,860
specific physical layer especially FPGA

00:06:55,759 --> 00:07:01,009
implementation here and on top we have

00:06:57,860 --> 00:07:04,160
we decided to use NS three which is yeah

00:07:01,009 --> 00:07:09,440
Linux based C++ implementation of the

00:07:04,160 --> 00:07:11,330
upper layers yeah so this is this is the

00:07:09,440 --> 00:07:15,050
idea behind it and so we needed to

00:07:11,330 --> 00:07:18,020
somehow connect the upper layers of ns3

00:07:15,050 --> 00:07:21,050
with our physical implementation in blue

00:07:18,020 --> 00:07:22,550
with the SDR essence themselves so we

00:07:21,050 --> 00:07:25,880
needed to have some point where we

00:07:22,550 --> 00:07:28,610
connected those two worlds so to say and

00:07:25,880 --> 00:07:29,960
this is where we started to yeah think

00:07:28,610 --> 00:07:33,349
about the concept of having a

00:07:29,960 --> 00:07:35,599
generalized 1/2 API so an api and that

00:07:33,349 --> 00:07:38,740
actually connects the lower layer the

00:07:35,599 --> 00:07:41,410
physical layer to the upper layers and

00:07:38,740 --> 00:07:44,470
yeah this is what this work is all about

00:07:41,410 --> 00:07:47,659
about an API that connects that

00:07:44,470 --> 00:07:49,970
generalized or generalized solution to

00:07:47,659 --> 00:07:53,900
connecting a physical and Meg layer and

00:07:49,970 --> 00:07:56,840
the paradigms behind it as I just said

00:07:53,900 --> 00:07:59,120
we just looked onto a cellular type of

00:07:56,840 --> 00:08:01,610
thing and what with this API concept is

00:07:59,120 --> 00:08:03,080
actually possible is that we have the

00:08:01,610 --> 00:08:05,090
option to kind of if we have a

00:08:03,080 --> 00:08:07,310
generalized API concept we can

00:08:05,090 --> 00:08:08,599
interchange things we want to do so we

00:08:07,310 --> 00:08:10,070
have several different options for

00:08:08,599 --> 00:08:12,020
example we can exchange the physical

00:08:10,070 --> 00:08:15,560
layer and instead of a team you could

00:08:12,020 --> 00:08:18,259
use a possibly a five GNR or 5g or

00:08:15,560 --> 00:08:20,599
whatever 6g layer put beneath that and

00:08:18,259 --> 00:08:22,820
make it compliant to the api and same

00:08:20,599 --> 00:08:24,289
thing on top so if for example someone

00:08:22,820 --> 00:08:26,000
wants to do something in left view you

00:08:24,289 --> 00:08:28,460
can do a left you based make

00:08:26,000 --> 00:08:32,690
implementation or use some other third

00:08:28,460 --> 00:08:34,579
party or open source protocol l2 or even

00:08:32,690 --> 00:08:36,320
a complete protocol stack as we did in

00:08:34,579 --> 00:08:37,909
this example here with NS three and

00:08:36,320 --> 00:08:39,919
there could also be the option to

00:08:37,909 --> 00:08:41,979
include other API is like between layer

00:08:39,919 --> 00:08:43,789
2 and layer 3 and you can have another

00:08:41,979 --> 00:08:47,420
implementation on top which you just

00:08:43,789 --> 00:08:48,920
plug together exactly so this is to sell

00:08:47,420 --> 00:08:51,140
you that part but as I said we always

00:08:48,920 --> 00:08:52,579
looking into a Wi-Fi so this is why we

00:08:51,140 --> 00:08:56,240
in the right side we have also divided

00:08:52,579 --> 00:08:59,560
by path and we thought about how would

00:08:56,240 --> 00:09:01,940
we do this implementation of an API and

00:08:59,560 --> 00:09:05,060
yeah we came up with the idea to make

00:09:01,940 --> 00:09:06,440
things easy and align concepts so such

00:09:05,060 --> 00:09:07,180
that you have one generalized

00:09:06,440 --> 00:09:09,250
architecture

00:09:07,180 --> 00:09:11,590
and you can kind of use that and reuse

00:09:09,250 --> 00:09:13,840
that and it was a basic code for us to

00:09:11,590 --> 00:09:15,160
use concepts that we have here also in

00:09:13,840 --> 00:09:17,560
here

00:09:15,160 --> 00:09:19,480
in terms of concepts mechanisms and also

00:09:17,560 --> 00:09:22,480
the general message structure structure

00:09:19,480 --> 00:09:24,730
that this API is using so what

00:09:22,480 --> 00:09:28,240
advantages are yeah what potential does

00:09:24,730 --> 00:09:30,310
such an API system actually have so at

00:09:28,240 --> 00:09:33,070
first you have the same ease of use so

00:09:30,310 --> 00:09:36,040
it no matter if you use a te API or

00:09:33,070 --> 00:09:38,380
views and Wi-Fi API it's similar matters

00:09:36,040 --> 00:09:42,010
similar concepts that you use so it's

00:09:38,380 --> 00:09:44,860
really easy to use it's relatively

00:09:42,010 --> 00:09:46,690
flexible in terms of configuring a lower

00:09:44,860 --> 00:09:50,560
layer of physic layer to actually

00:09:46,690 --> 00:09:53,470
incorporate this into yeah end-to-end

00:09:50,560 --> 00:09:55,510
simulations with industry and so on

00:09:53,470 --> 00:09:58,720
another thing that is really important

00:09:55,510 --> 00:10:01,780
is with having a generalized API concept

00:09:58,720 --> 00:10:04,330
and implementation of that you are

00:10:01,780 --> 00:10:05,860
really fast and adopting this - yeah new

00:10:04,330 --> 00:10:08,470
implementations for example what you're

00:10:05,860 --> 00:10:12,640
currently doing is that we are looking

00:10:08,470 --> 00:10:14,290
into 5g path and it's actually pretty

00:10:12,640 --> 00:10:15,700
easy to just take what we already had

00:10:14,290 --> 00:10:17,740
and the implementation and the

00:10:15,700 --> 00:10:19,780
specification for the API and just put

00:10:17,740 --> 00:10:21,760
it onto a 5g physical layer

00:10:19,780 --> 00:10:24,370
implementation with slight adaptions and

00:10:21,760 --> 00:10:26,770
then we could use that what it also

00:10:24,370 --> 00:10:29,620
helps is in terms of system abstraction

00:10:26,770 --> 00:10:33,550
because if you use an API especially for

00:10:29,620 --> 00:10:37,390
it pretty sophisticated physically our

00:10:33,550 --> 00:10:39,880
implementation you can get rid of all

00:10:37,390 --> 00:10:42,460
those detail of the physical layer and

00:10:39,880 --> 00:10:45,510
should just use it with a define

00:10:42,460 --> 00:10:48,040
interface of this API to the lower layer

00:10:45,510 --> 00:10:50,920
exactly and as I said before the reuse

00:10:48,040 --> 00:10:53,020
this is somehow as I said before it's

00:10:50,920 --> 00:10:54,640
really nice that you can just use the

00:10:53,020 --> 00:10:56,020
API and also an implementation and

00:10:54,640 --> 00:10:59,050
adapters to other physically of

00:10:56,020 --> 00:11:01,720
implementations okay so let's have a

00:10:59,050 --> 00:11:03,820
look on how this API actually works

00:11:01,720 --> 00:11:07,630
so the general principle principle of

00:11:03,820 --> 00:11:10,320
this API is it is based on three message

00:11:07,630 --> 00:11:13,390
types that we actually have defined here

00:11:10,320 --> 00:11:15,250
and they are yeah exchange between the

00:11:13,390 --> 00:11:17,380
file layer and the Mac layer so the

00:11:15,250 --> 00:11:19,870
first thing is that Mac layer could send

00:11:17,380 --> 00:11:20,870
some kind of request to the physical

00:11:19,870 --> 00:11:24,140
layer

00:11:20,870 --> 00:11:26,930
and then we have a possible confirm of

00:11:24,140 --> 00:11:27,650
that request so if McClair sending a

00:11:26,930 --> 00:11:29,480
request

00:11:27,650 --> 00:11:30,950
it could be confirmed by the failure

00:11:29,480 --> 00:11:35,000
that is recast request has been

00:11:30,950 --> 00:11:37,250
processed and then physically I could

00:11:35,000 --> 00:11:39,920
also send some indication up to the mech

00:11:37,250 --> 00:11:41,450
lair transporting some information so in

00:11:39,920 --> 00:11:43,700
example is here on the right side you

00:11:41,450 --> 00:11:45,560
have a TX request for the data channel

00:11:43,700 --> 00:11:48,380
that means that you have some control

00:11:45,560 --> 00:11:51,230
data and the mac layer is actually

00:11:48,380 --> 00:11:54,770
sending such a TX request with data that

00:11:51,230 --> 00:11:56,180
needs to be sent over the channel down

00:11:54,770 --> 00:11:57,650
to the physic layer and with that some

00:11:56,180 --> 00:11:59,360
control information which would for

00:11:57,650 --> 00:12:01,760
example include the modulation encoding

00:11:59,360 --> 00:12:03,620
scheme resource block allocation and

00:12:01,760 --> 00:12:05,330
things like that and of course it needs

00:12:03,620 --> 00:12:06,920
to transport the payload to the physical

00:12:05,330 --> 00:12:09,790
layer that physically I can basically

00:12:06,920 --> 00:12:12,110
process it and send it over the air

00:12:09,790 --> 00:12:13,730
exactly so this is the basic paradigm

00:12:12,110 --> 00:12:15,410
the basic message is and there are

00:12:13,730 --> 00:12:18,830
specific messages that are drawn then

00:12:15,410 --> 00:12:20,330
either to Wi-Fi or to LTE depending on

00:12:18,830 --> 00:12:24,529
the other physical layer that you are

00:12:20,330 --> 00:12:25,940
actually using this is a sequence chart

00:12:24,529 --> 00:12:28,970
that should give you a little bit of an

00:12:25,940 --> 00:12:30,950
insight in how the structure and the

00:12:28,970 --> 00:12:33,800
functionality for especially LTE works

00:12:30,950 --> 00:12:37,160
so the interesting thing about this is

00:12:33,800 --> 00:12:39,290
that LTE itself runs yeah it has an

00:12:37,160 --> 00:12:41,660
inherent tick of one millisecond which

00:12:39,290 --> 00:12:43,100
is the subframe that is constantly

00:12:41,660 --> 00:12:47,630
running in the physical layers actually

00:12:43,100 --> 00:12:50,120
running in debt yeah timescale so in

00:12:47,630 --> 00:12:52,279
that sense the e node B or the base

00:12:50,120 --> 00:12:56,029
station physic layer is the timing

00:12:52,279 --> 00:12:58,130
master and one message that is going to

00:12:56,029 --> 00:13:00,650
be sent every millisecond is a so called

00:12:58,130 --> 00:13:02,959
Phi timing indication that indicates to

00:13:00,650 --> 00:13:05,089
the upper layers the timing grid how

00:13:02,959 --> 00:13:07,250
physical layer works and with that

00:13:05,089 --> 00:13:11,750
timing indication the mech layer

00:13:07,250 --> 00:13:13,550
actually is going to send requests to

00:13:11,750 --> 00:13:15,080
the physical layer of transporting data

00:13:13,550 --> 00:13:18,290
and this could be for example here at

00:13:15,080 --> 00:13:20,660
downlinked TX config request that

00:13:18,290 --> 00:13:25,390
actually yeah request to send some data

00:13:20,660 --> 00:13:27,920
over over the air and it has some yeah

00:13:25,390 --> 00:13:30,320
actually this is those are two sub

00:13:27,920 --> 00:13:31,670
messages of such a request the one is

00:13:30,320 --> 00:13:33,260
the config request message would

00:13:31,670 --> 00:13:34,370
actually configures the physical layer

00:13:33,260 --> 00:13:36,830
to a certain State

00:13:34,370 --> 00:13:38,840
and then we have a downlink TX payload

00:13:36,830 --> 00:13:42,020
request which is actually yeah conveying

00:13:38,840 --> 00:13:44,060
the data that needs to be sent and in

00:13:42,020 --> 00:13:45,590
the same subframe we don't only want to

00:13:44,060 --> 00:13:47,240
send data what we probably also want to

00:13:45,590 --> 00:13:48,710
get data from the physical layer because

00:13:47,240 --> 00:13:50,330
there was something sent in the uplink

00:13:48,710 --> 00:13:52,550
so that's why actually the physical

00:13:50,330 --> 00:13:58,240
layer here of the inner piece actually

00:13:52,550 --> 00:14:00,830
sending a uplink optics channel rx

00:13:58,240 --> 00:14:03,410
indication so it means it indicates to

00:14:00,830 --> 00:14:05,210
the higher layer that data is there and

00:14:03,410 --> 00:14:06,800
it actually sends this data upwards such

00:14:05,210 --> 00:14:09,350
that the MEC layer can process it and

00:14:06,800 --> 00:14:11,180
then everything of this has to happen

00:14:09,350 --> 00:14:13,880
within one milliseconds because after

00:14:11,180 --> 00:14:15,680
one millisecond the physical layer is

00:14:13,880 --> 00:14:19,430
actually again sending a timing

00:14:15,680 --> 00:14:21,230
indication for the next millisecond yeah

00:14:19,430 --> 00:14:23,089
when things go come to be a process

00:14:21,230 --> 00:14:24,950
newly for the next subframe so to say

00:14:23,089 --> 00:14:28,970
and basically the same thing happens on

00:14:24,950 --> 00:14:31,160
the UI side - exactly and the important

00:14:28,970 --> 00:14:32,870
thing here is that the FPGA on the you

00:14:31,160 --> 00:14:34,760
know here or the physical layer is the

00:14:32,870 --> 00:14:37,400
master clock and everything else has to

00:14:34,760 --> 00:14:39,140
cope with it and it's actually also a

00:14:37,400 --> 00:14:40,990
problem that we currently or that we

00:14:39,140 --> 00:14:43,460
have for a scene and we are currently

00:14:40,990 --> 00:14:45,200
heavily optimizing for that because the

00:14:43,460 --> 00:14:45,830
physical layer and especially this FPGA

00:14:45,200 --> 00:14:49,040
implementation

00:14:45,830 --> 00:14:51,650
it runs rock stable in one millisecond

00:14:49,040 --> 00:14:54,320
tick and if an s3 which we had here on

00:14:51,650 --> 00:14:56,810
the side for the upper yes if it doesn't

00:14:54,320 --> 00:14:58,730
get everything processed within one

00:14:56,810 --> 00:15:01,610
millisecond we get problems because we

00:14:58,730 --> 00:15:03,440
got running out of sync and that's why

00:15:01,610 --> 00:15:07,280
we actually needs to have also the upper

00:15:03,440 --> 00:15:09,710
layers kind of run relatively fast and

00:15:07,280 --> 00:15:11,240
they also ideally would run on a

00:15:09,710 --> 00:15:12,890
real-time system such that you can

00:15:11,240 --> 00:15:14,540
really guarantee that everything is

00:15:12,890 --> 00:15:19,160
being processed within the one

00:15:14,540 --> 00:15:20,780
millisecond that we have here okay so

00:15:19,160 --> 00:15:22,480
how is this actually implemented so this

00:15:20,780 --> 00:15:25,370
is one thing that I want to also show

00:15:22,480 --> 00:15:27,170
because this is the interesting thing

00:15:25,370 --> 00:15:28,790
about this API and actually the

00:15:27,170 --> 00:15:33,560
difference between the API specification

00:15:28,790 --> 00:15:35,300
and the API implementation so what you

00:15:33,560 --> 00:15:37,339
would have in your system is that you

00:15:35,300 --> 00:15:40,070
have one l1 right the physic layer in

00:15:37,339 --> 00:15:42,650
our case is a te and we have the two Meg

00:15:40,070 --> 00:15:45,500
layer or the upper layers and we need to

00:15:42,650 --> 00:15:47,209
make them work together with the API so

00:15:45,500 --> 00:15:47,990
what you need for that is actually you

00:15:47,209 --> 00:15:50,450
need some message

00:15:47,990 --> 00:15:52,310
generous and message generators that are

00:15:50,450 --> 00:15:53,899
capable of yeah

00:15:52,310 --> 00:15:56,600
talking to your actual physical layer

00:15:53,899 --> 00:15:58,790
implementation so they they talk in the

00:15:56,600 --> 00:16:01,010
yeah and the interface that you're

00:15:58,790 --> 00:16:04,279
physically or implementation would yeah

00:16:01,010 --> 00:16:06,050
request would use right and so this is

00:16:04,279 --> 00:16:07,760
an implementation specific interface it

00:16:06,050 --> 00:16:10,640
could be different on C++ could be

00:16:07,760 --> 00:16:13,640
different on FPGA or whatever and the

00:16:10,640 --> 00:16:15,140
same happens to be on the two sites on

00:16:13,640 --> 00:16:17,120
the upper sides so there's also a

00:16:15,140 --> 00:16:18,950
specific order yeah implementation

00:16:17,120 --> 00:16:21,529
specific interface for example in our

00:16:18,950 --> 00:16:25,250
case on this side we haven't sort of say

00:16:21,529 --> 00:16:26,839
an FPGA implementation and C++ on the

00:16:25,250 --> 00:16:28,520
upper side it could for example also be

00:16:26,839 --> 00:16:29,990
a few implementation or whatever kind of

00:16:28,520 --> 00:16:31,940
implementer it's something in peyten so

00:16:29,990 --> 00:16:33,380
you need to have some message than the

00:16:31,940 --> 00:16:35,510
Raiders and some message handlers that

00:16:33,380 --> 00:16:38,180
are written in your language of your

00:16:35,510 --> 00:16:41,839
solution and then need to talk to your

00:16:38,180 --> 00:16:43,399
yeah l2 or l1 implementation but those

00:16:41,839 --> 00:16:45,020
message to narrator's and message

00:16:43,399 --> 00:16:48,050
handlers are actually the ones that

00:16:45,020 --> 00:16:49,520
translate your implementation into the

00:16:48,050 --> 00:16:52,820
api's yeah

00:16:49,520 --> 00:16:54,200
basic specification and this is where

00:16:52,820 --> 00:16:57,160
egg this is actually the other interface

00:16:54,200 --> 00:17:00,470
so this is the common message interface

00:16:57,160 --> 00:17:02,029
that we implemented here such that these

00:17:00,470 --> 00:17:03,920
two different implementations can

00:17:02,029 --> 00:17:06,980
actually talk to each other and so now

00:17:03,920 --> 00:17:08,600
you have translated the basically the

00:17:06,980 --> 00:17:12,050
interface from your implementation

00:17:08,600 --> 00:17:14,390
towards the API interface and what is

00:17:12,050 --> 00:17:16,939
left to do is kind of transmitting those

00:17:14,390 --> 00:17:19,400
messages those API messages somehow to

00:17:16,939 --> 00:17:21,380
the other part and there you are so

00:17:19,400 --> 00:17:23,420
relatively free to go so the only thing

00:17:21,380 --> 00:17:25,309
you need is to have read and write for a

00:17:23,420 --> 00:17:28,790
specific transport medium that you want

00:17:25,309 --> 00:17:31,070
to use and I just said you are

00:17:28,790 --> 00:17:33,920
relatively free to use whatever you like

00:17:31,070 --> 00:17:36,559
although there are specific constraints

00:17:33,920 --> 00:17:37,940
and depending on what yeah what kind of

00:17:36,559 --> 00:17:39,740
time constraints you have in your

00:17:37,940 --> 00:17:40,309
implementation so you could for example

00:17:39,740 --> 00:17:44,240
use

00:17:40,309 --> 00:17:46,100
send those those messages over UDP yeah

00:17:44,240 --> 00:17:48,950
Ethernet for example if you want to plug

00:17:46,100 --> 00:17:50,179
a l1 over Ethernet to some network

00:17:48,950 --> 00:17:51,700
simulator or something like that

00:17:50,179 --> 00:17:54,559
but depending on your implementational

00:17:51,700 --> 00:17:57,610
also use just memory point or direct

00:17:54,559 --> 00:17:59,870
access or a C API that you use for that

00:17:57,610 --> 00:18:01,049
or even if you're using that on

00:17:59,870 --> 00:18:04,590
indirectly on

00:18:01,049 --> 00:18:05,009
J or something you can use five pose for

00:18:04,590 --> 00:18:07,409
that

00:18:05,009 --> 00:18:10,129
things like that exactly so this is

00:18:07,409 --> 00:18:13,019
something really which is up to you and

00:18:10,129 --> 00:18:15,269
for example for as he and for Wi-Fi we

00:18:13,019 --> 00:18:18,450
use different transport mechanisms

00:18:15,269 --> 00:18:20,279
because in Wi-Fi we had an

00:18:18,450 --> 00:18:24,029
implementation that actually has the

00:18:20,279 --> 00:18:26,220
time constraint Wi-Fi processing in the

00:18:24,029 --> 00:18:28,559
FPGA so we were relatively relaxed in

00:18:26,220 --> 00:18:29,999
terms of timing constraints so that's

00:18:28,559 --> 00:18:31,649
what we could actually use UDP

00:18:29,999 --> 00:18:36,509
for the transmission of those API

00:18:31,649 --> 00:18:38,759
messages for LTE however we needed to

00:18:36,509 --> 00:18:40,049
really go in this one millisecond tick

00:18:38,759 --> 00:18:43,580
and that's why we needed something that

00:18:40,049 --> 00:18:46,169
is way less jitter prone I would say

00:18:43,580 --> 00:18:48,690
then UDP actually so we did some tests

00:18:46,169 --> 00:18:51,149
and in turn didn't turn out well so we

00:18:48,690 --> 00:18:53,309
actually went for yeah transmission via

00:18:51,149 --> 00:18:55,830
Linux pipes to actually get those

00:18:53,309 --> 00:18:58,590
messages from air to to our l1

00:18:55,830 --> 00:19:00,330
implementation so this is something when

00:18:58,590 --> 00:19:03,029
one really needs to figure out based on

00:19:00,330 --> 00:19:07,529
the specific implementation how what is

00:19:03,029 --> 00:19:09,389
sufficient for the use okay and we

00:19:07,529 --> 00:19:12,509
didn't actually do an implementation for

00:19:09,389 --> 00:19:15,529
that and for that we used some specific

00:19:12,509 --> 00:19:18,899
user piadmin this is a who's a p2 974

00:19:15,529 --> 00:19:22,049
which is a specific user P that actually

00:19:18,899 --> 00:19:24,059
includes an Intel i7 CPU and if this was

00:19:22,049 --> 00:19:25,409
a perfect fit for implementation because

00:19:24,059 --> 00:19:28,830
we needed something where we could run

00:19:25,409 --> 00:19:30,149
those message handlers on and it we

00:19:28,830 --> 00:19:32,429
could run actually a Linux distribution

00:19:30,149 --> 00:19:34,379
on this inter CPU so we were actually

00:19:32,429 --> 00:19:36,179
capable of additionally to the message

00:19:34,379 --> 00:19:38,039
handlers you could also run the complete

00:19:36,179 --> 00:19:40,739
n is free on top of that so this all

00:19:38,039 --> 00:19:42,570
runs in that box and as we have LTE

00:19:40,739 --> 00:19:47,940
running and wife are running for doing

00:19:42,570 --> 00:19:51,299
this interpreting research we have one

00:19:47,940 --> 00:19:55,399
intern FPGA in this USRP which actually

00:19:51,299 --> 00:19:57,869
runs an FPGA implementation of LTE and

00:19:55,399 --> 00:19:59,999
we wanted to use Wi-Fi to so this

00:19:57,869 --> 00:20:03,600
actually has the opportunity to yeah

00:19:59,999 --> 00:20:05,820
attention another USRP with a PCI

00:20:03,600 --> 00:20:08,160
expansion port so we have a second use

00:20:05,820 --> 00:20:09,930
of here which just has a

00:20:08,160 --> 00:20:13,320
an FPGA and this runs to 802 11

00:20:09,930 --> 00:20:15,030
implementation and yeah basically all of

00:20:13,320 --> 00:20:16,560
this fits just in this one box and this

00:20:15,030 --> 00:20:18,270
is actually quite nice because we are

00:20:16,560 --> 00:20:20,280
using this also in a in the research

00:20:18,270 --> 00:20:23,940
project and conjunction with test beds

00:20:20,280 --> 00:20:25,500
in Germany especially interesting where

00:20:23,940 --> 00:20:28,380
we have those those here's a piece

00:20:25,500 --> 00:20:30,570
running and this is quite quite neat and

00:20:28,380 --> 00:20:32,340
easy to and portable I would say to have

00:20:30,570 --> 00:20:35,070
those one of those things around and

00:20:32,340 --> 00:20:36,540
then two different tests exactly so with

00:20:35,070 --> 00:20:39,300
this set up we actually were capable of

00:20:36,540 --> 00:20:44,990
having this complete end-to-end system

00:20:39,300 --> 00:20:48,660
running just on this one machine exactly

00:20:44,990 --> 00:20:50,700
we also did some tests regarding let's

00:20:48,660 --> 00:20:52,200
say some simple tests to measure

00:20:50,700 --> 00:20:53,570
actually the end-to-end throughput so

00:20:52,200 --> 00:20:57,120
what we did was actually we had a

00:20:53,570 --> 00:20:59,010
application for data transmission from a

00:20:57,120 --> 00:21:02,510
server point of view and we actually

00:20:59,010 --> 00:21:06,090
sent it over the complete system towards

00:21:02,510 --> 00:21:10,950
our so called multi rut user equipment

00:21:06,090 --> 00:21:13,170
and yeah hard to see but what we did

00:21:10,950 --> 00:21:15,960
very is we so we check different packet

00:21:13,170 --> 00:21:17,940
sizes and we decreased a packet interval

00:21:15,960 --> 00:21:19,890
which would ya result in higher

00:21:17,940 --> 00:21:23,400
throughputs and you can actually see

00:21:19,890 --> 00:21:25,500
that we get higher throughput sorry the

00:21:23,400 --> 00:21:27,780
theoretical limit of LTE is actually 75

00:21:25,500 --> 00:21:29,640
megabits per second and with this

00:21:27,780 --> 00:21:32,700
implementation we get I would say a

00:21:29,640 --> 00:21:36,180
relative in closer so we are a little

00:21:32,700 --> 00:21:38,490
bit below 70 megabits and it is quite a

00:21:36,180 --> 00:21:40,710
strength of this this segmentation of

00:21:38,490 --> 00:21:43,290
having an FPGA implementation for that

00:21:40,710 --> 00:21:45,180
and having the end-to-end stakes on top

00:21:43,290 --> 00:21:49,370
that you can do end-to-end measurements

00:21:45,180 --> 00:21:54,450
or end-to-end experiments over the air

00:21:49,370 --> 00:21:56,880
with those throughputs exactly so I

00:21:54,450 --> 00:22:01,290
think this is it already know it's the

00:21:56,880 --> 00:22:05,160
time okay so what did we do we have this

00:22:01,290 --> 00:22:06,900
generalized API specification to connect

00:22:05,160 --> 00:22:08,790
physical and make layers of different

00:22:06,900 --> 00:22:13,290
rods so we did this for LTE and for

00:22:08,790 --> 00:22:15,330
Wi-Fi and with this and in conjunction

00:22:13,290 --> 00:22:17,070
with the and with ns3 as the network

00:22:15,330 --> 00:22:19,410
simulator on top we were actually

00:22:17,070 --> 00:22:22,560
capable of doing interworking research

00:22:19,410 --> 00:22:24,780
and this era actually universities and

00:22:22,560 --> 00:22:26,310
Europe especially in Spain that they're

00:22:24,780 --> 00:22:28,110
working on specifically those

00:22:26,310 --> 00:22:30,530
interpreting technologies between a tea

00:22:28,110 --> 00:22:32,550
and Wi-Fi and they actually use our our

00:22:30,530 --> 00:22:36,240
platform in conjunction with this

00:22:32,550 --> 00:22:38,160
research project called Orca where they

00:22:36,240 --> 00:22:39,510
actually implemented also helped us

00:22:38,160 --> 00:22:40,860
implementing these things and they're

00:22:39,510 --> 00:22:42,960
using that in a test bit of the

00:22:40,860 --> 00:22:47,640
Technical University of Dresden in

00:22:42,960 --> 00:22:50,460
Germany exactly and yeah one last thing

00:22:47,640 --> 00:22:53,880
here is that this implementation that we

00:22:50,460 --> 00:22:55,170
did for this one to API we actually made

00:22:53,880 --> 00:22:57,900
this available on github

00:22:55,170 --> 00:23:00,930
and we as good as possible we try to

00:22:57,900 --> 00:23:03,060
maintain this and feed new things in and

00:23:00,930 --> 00:23:05,070
new features and so on for example week

00:23:03,060 --> 00:23:07,740
recently had another actually there was

00:23:05,070 --> 00:23:09,960
another university from Spain they seem

00:23:07,740 --> 00:23:11,250
to be drawn to that kind of network

00:23:09,960 --> 00:23:13,140
simulator they did another

00:23:11,250 --> 00:23:15,570
implementation of interval technologies

00:23:13,140 --> 00:23:17,760
between LTE and 80s or so called dual

00:23:15,570 --> 00:23:20,190
connectivity and they implemented this

00:23:17,760 --> 00:23:22,760
this industry such that it can now be

00:23:20,190 --> 00:23:25,320
used actually and they and the test pets

00:23:22,760 --> 00:23:27,720
exactly so this is free to use here so

00:23:25,320 --> 00:23:30,750
check out github the nins free

00:23:27,720 --> 00:23:34,080
application example other than that what

00:23:30,750 --> 00:23:36,000
we will do next is yeah we basically

00:23:34,080 --> 00:23:38,670
want to maintain what we did and also

00:23:36,000 --> 00:23:43,620
kind of get in new things new features

00:23:38,670 --> 00:23:45,300
into this network simulator exactly what

00:23:43,620 --> 00:23:48,450
we also want to do is to look in a

00:23:45,300 --> 00:23:50,520
little bit be tight and a-three and also

00:23:48,450 --> 00:23:51,750
look into all my interface I think we

00:23:50,520 --> 00:23:53,280
mentioned that beforehand that there was

00:23:51,750 --> 00:23:56,190
an open air interface demo at E and I

00:23:53,280 --> 00:23:58,020
booth right so this is what we are

00:23:56,190 --> 00:24:01,710
currently also looking into or start

00:23:58,020 --> 00:24:04,140
looking into we see how we can exploit

00:24:01,710 --> 00:24:07,380
this API interface also for of meander

00:24:04,140 --> 00:24:08,940
phase and last but not least we are

00:24:07,380 --> 00:24:10,800
currently working together with

00:24:08,940 --> 00:24:12,630
Technical University of Dresden because

00:24:10,800 --> 00:24:15,240
they have a very specific physical layer

00:24:12,630 --> 00:24:17,400
implementation of what they think could

00:24:15,240 --> 00:24:18,810
be five or a six G I would say as

00:24:17,400 --> 00:24:21,660
there's a specific modulation scheme

00:24:18,810 --> 00:24:23,700
called GF TM and they have a physical

00:24:21,660 --> 00:24:24,929
layer FPGA implementation for that and

00:24:23,700 --> 00:24:27,750
we were working together with them to

00:24:24,929 --> 00:24:29,340
actually get the API on top of that such

00:24:27,750 --> 00:24:31,320
that we can plug everything together to

00:24:29,340 --> 00:24:31,980
n is 3 and we have actually three

00:24:31,320 --> 00:24:33,660
different radio

00:24:31,980 --> 00:24:36,500
technologies and industry which

00:24:33,660 --> 00:24:43,770
researchers can use for doing research I

00:24:36,500 --> 00:24:46,440
think it's it Thanks all right perfect

00:24:43,770 --> 00:24:48,090
on time German punctuality so that means

00:24:46,440 --> 00:24:50,580
we can ask a few questions yeah

00:24:48,090 --> 00:24:52,290
yeah have you considered using like an

00:24:50,580 --> 00:24:54,059
RF channel emulator in addition to this

00:24:52,290 --> 00:24:56,160
like connected to the actual hardware to

00:24:54,059 --> 00:24:58,410
do you know additional things like

00:24:56,160 --> 00:24:59,970
especially for satellite orbits if we

00:24:58,410 --> 00:25:02,010
can emulate what the channel looks like

00:24:59,970 --> 00:25:04,410
and add that to the simulation so you

00:25:02,010 --> 00:25:06,450
can have the hardware there is that

00:25:04,410 --> 00:25:10,890
something that you've you've looked at

00:25:06,450 --> 00:25:14,100
or denied so like adding adding like an

00:25:10,890 --> 00:25:15,470
RF channel emulator to this work so you

00:25:14,100 --> 00:25:19,500
have your NS three at the top layer

00:25:15,470 --> 00:25:22,350
talking to an actual physical device and

00:25:19,500 --> 00:25:23,730
then that connected to an RF channel

00:25:22,350 --> 00:25:25,260
emulator that would emulate the

00:25:23,730 --> 00:25:29,309
environment that you're trying to look

00:25:25,260 --> 00:25:31,320
at so we haven't although we had

00:25:29,309 --> 00:25:32,910
discussions with technology University

00:25:31,320 --> 00:25:35,760
of Dresden because they have done things

00:25:32,910 --> 00:25:40,890
before for their 5g of cm physical layer

00:25:35,760 --> 00:25:43,080
so you can do two things usually when we

00:25:40,890 --> 00:25:44,520
test this stuff we do it cables because

00:25:43,080 --> 00:25:47,490
that's the easiest way and you get a

00:25:44,520 --> 00:25:49,410
plain smooth awgn channel and other than

00:25:47,490 --> 00:25:53,040
that if you have a license especially

00:25:49,410 --> 00:25:54,090
for LTE somewhere and actually technical

00:25:53,040 --> 00:25:56,070
units you have trace and they have a

00:25:54,090 --> 00:25:58,320
test license to also run LTE so you can

00:25:56,070 --> 00:26:01,650
just use plain antenna and also play

00:25:58,320 --> 00:26:03,840
with that but actually RF channel

00:26:01,650 --> 00:26:06,140
emulators which we put between the

00:26:03,840 --> 00:26:09,290
system we haven't done yet - no thanks

00:26:06,140 --> 00:26:11,280
other are there any other questions I

00:26:09,290 --> 00:26:12,750
actually have one you mentioned

00:26:11,280 --> 00:26:14,220
approaching from a youth Spanish

00:26:12,750 --> 00:26:16,020
University I did not catch that is

00:26:14,220 --> 00:26:17,520
that's not on this slide right

00:26:16,020 --> 00:26:19,440
oh is it well it's actually in

00:26:17,520 --> 00:26:21,240
conjunction so this oka research project

00:26:19,440 --> 00:26:24,210
is an European funded research project

00:26:21,240 --> 00:26:26,160
where we have a consortium of like seven

00:26:24,210 --> 00:26:27,690
partners and the specific of this

00:26:26,160 --> 00:26:29,630
project is that the partners are working

00:26:27,690 --> 00:26:32,100
in that project together to do things

00:26:29,630 --> 00:26:34,860
but we also have so-called open calls

00:26:32,100 --> 00:26:37,890
where we ask or we promote externally

00:26:34,860 --> 00:26:40,530
that partners could apply for those open

00:26:37,890 --> 00:26:42,000
calls to actually do research on the

00:26:40,530 --> 00:26:44,220
platform that we are offering in that

00:26:42,000 --> 00:26:45,490
project and there are a calls where

00:26:44,220 --> 00:26:46,780
actually partners from Spain

00:26:45,490 --> 00:26:49,000
actually wanted to implement specific

00:26:46,780 --> 00:26:51,190
things so for example is Wi-Fi LTE

00:26:49,000 --> 00:26:52,540
interworking this was an offer which we

00:26:51,190 --> 00:26:54,340
had we thought it would be nice to have

00:26:52,540 --> 00:26:56,500
that in the NSA network simulator and

00:26:54,340 --> 00:26:58,270
this university from Spain said ok I

00:26:56,500 --> 00:26:59,110
want to do that I apply for this open

00:26:58,270 --> 00:27:01,360
call and they won

00:26:59,110 --> 00:27:03,070
so they got funding for it it was like

00:27:01,360 --> 00:27:05,290
nine months actually implement and test

00:27:03,070 --> 00:27:07,990
this and we worked together and got that

00:27:05,290 --> 00:27:11,440
working yeah okay well that's very cool

00:27:07,990 --> 00:27:15,120
so one final round of applause for all

00:27:11,440 --> 00:27:15,120

YouTube URL: https://www.youtube.com/watch?v=N7TcN-8yolU


