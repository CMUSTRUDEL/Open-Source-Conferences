Title: GRCon19 - GNU Radio Beyond 3.8 - A Technical Outlook by Marcus Muller
Publication date: 2019-11-05
Playlist: GRCon 2019
Description: 
	GNU Radio Beyond 3.8 - A Technical Outlook by Marcus Muller
Captions: 
	00:00:14,560 --> 00:00:24,170
my talk kind of tries to complement with

00:00:18,320 --> 00:00:27,230
that and talk from yesterday but I will

00:00:24,170 --> 00:00:29,900
not give you as much of a project update

00:00:27,230 --> 00:00:32,210
as I will give you a bit of a technical

00:00:29,900 --> 00:00:37,610
outlook so welcome to my talk on

00:00:32,210 --> 00:00:40,640
narrator beyond 3.8 so as you can see

00:00:37,610 --> 00:00:44,360
I've got 17th rights of which I filled

00:00:40,640 --> 00:00:46,969
the brown 50 with actual content I've

00:00:44,360 --> 00:00:48,350
got about two minutes per slide a lot

00:00:46,969 --> 00:00:49,940
less if I actually want to put emphasis

00:00:48,350 --> 00:00:54,949
on the questions and answers that I

00:00:49,940 --> 00:00:57,109
hopefully have so here we go I'll very

00:00:54,949 --> 00:00:59,750
quickly introduce myself then we'll have

00:00:57,109 --> 00:01:04,510
a short look back at what I actually

00:00:59,750 --> 00:01:07,730
what we achieved when we release 3.8

00:01:04,510 --> 00:01:10,550
what will immediately do for the next

00:01:07,730 --> 00:01:13,340
release and then we'll hopefully make

00:01:10,550 --> 00:01:15,530
then a bit happier and you know talk

00:01:13,340 --> 00:01:19,250
about what the next large version of

00:01:15,530 --> 00:01:22,550
Ranger brings so let me let me get

00:01:19,250 --> 00:01:26,300
started with a really short intro on

00:01:22,550 --> 00:01:29,870
myself I need to do that because there's

00:01:26,300 --> 00:01:32,300
like I couldn't be here if some of these

00:01:29,870 --> 00:01:35,060
roads wouldn't allow me to do that so my

00:01:32,300 --> 00:01:39,860
primary job is I work at the University

00:01:35,060 --> 00:01:42,140
try to reach for PhD I work in Germany

00:01:39,860 --> 00:01:43,550
at the Cultural Institute of Technology

00:01:42,140 --> 00:01:47,810
at the communications engineering lab

00:01:43,550 --> 00:01:51,200
where I'm mostly doing exercises for a

00:01:47,810 --> 00:01:53,180
couple of courses that the probability

00:01:51,200 --> 00:01:55,670
theory for third semesters communication

00:01:53,180 --> 00:02:00,020
theory one for the first semesters and a

00:01:55,670 --> 00:02:03,380
few advanced courses which have 40

00:02:00,020 --> 00:02:05,090
students each about kind of and as you

00:02:03,380 --> 00:02:09,709
can see from the number of course where

00:02:05,090 --> 00:02:12,170
I do the exercise we are hiring so if

00:02:09,709 --> 00:02:15,379
you're interested in you know SDR

00:02:12,170 --> 00:02:16,970
channel coding whatever I send an email

00:02:15,379 --> 00:02:19,730
to the mailing list that we're hiring

00:02:16,970 --> 00:02:23,410
just reply to me or reach out to me on

00:02:19,730 --> 00:02:25,760
that I myself I'm doing a PhD I said

00:02:23,410 --> 00:02:27,740
mostly it'll be on low-density

00:02:25,760 --> 00:02:31,370
parity-check

00:02:27,740 --> 00:02:33,620
systems on channels where the error

00:02:31,370 --> 00:02:35,510
probability is not constant but as you

00:02:33,620 --> 00:02:40,310
can guess I have not been doing that

00:02:35,510 --> 00:02:42,740
very much so I got to it like apologized

00:02:40,310 --> 00:02:44,810
to my professor there that I'm doing

00:02:42,740 --> 00:02:47,030
this stuff and that nevertheless he lets

00:02:44,810 --> 00:02:48,890
me go so here's my thanks for that other

00:02:47,030 --> 00:02:53,000
than that I earned a bit of money as a

00:02:48,890 --> 00:02:55,610
freelancing engineer you might have

00:02:53,000 --> 00:02:57,800
noticed that I run have run not really

00:02:55,610 --> 00:02:59,690
run a workshop would be ettus folks

00:02:57,800 --> 00:03:01,940
yesterday's I'm still part of their

00:02:59,690 --> 00:03:04,240
support team so I supply all the

00:03:01,940 --> 00:03:07,160
necessary grumpiness to add a support

00:03:04,240 --> 00:03:07,490
and what's most probably interesting for

00:03:07,160 --> 00:03:09,860
you guys

00:03:07,490 --> 00:03:14,120
I am the technical maintainer of didn't

00:03:09,860 --> 00:03:17,720
radio project so in that role I've had

00:03:14,120 --> 00:03:21,010
the honour and honestly the joy of

00:03:17,720 --> 00:03:26,510
releasing 3.8 just a couple of weeks ago

00:03:21,010 --> 00:03:29,390
and and there was in one hand there was

00:03:26,510 --> 00:03:30,410
a big change on the other as you can see

00:03:29,390 --> 00:03:33,050
by the things that we've actually

00:03:30,410 --> 00:03:36,380
changed that didn't address very much of

00:03:33,050 --> 00:03:38,950
the systemic structure of Rayo

00:03:36,380 --> 00:03:41,090
what we did we we progress our

00:03:38,950 --> 00:03:43,940
programming languages so instead of

00:03:41,090 --> 00:03:46,940
being stuck with Python 2 you can now

00:03:43,940 --> 00:03:51,860
choose for the 3:8 release between 5 and

00:03:46,940 --> 00:03:55,460
2 or 3 that's an X or you can you can

00:03:51,860 --> 00:03:59,270
use C++ 11 I very much encourage you to

00:03:55,460 --> 00:04:01,760
write beautiful C++ we ran an all-round

00:03:59,270 --> 00:04:05,870
source formatting that was super helpful

00:04:01,760 --> 00:04:07,580
at getting you know the source code into

00:04:05,870 --> 00:04:09,500
a state where it's actually a pleasure

00:04:07,580 --> 00:04:12,710
to work with there wasn't the case

00:04:09,500 --> 00:04:14,900
before in very many places we updated a

00:04:12,710 --> 00:04:18,020
lot of dependencies we've updated our

00:04:14,900 --> 00:04:20,989
build structures but to the end user

00:04:18,020 --> 00:04:24,760
that mostly is under the hood what the

00:04:20,989 --> 00:04:28,130
end user does see is that we overhauled

00:04:24,760 --> 00:04:30,020
GRC quite a bit so you have seen from

00:04:28,130 --> 00:04:32,150
our presentations that I do know that

00:04:30,020 --> 00:04:34,970
coming presentations will feature there

00:04:32,150 --> 00:04:36,890
too that you can write a companion now

00:04:34,970 --> 00:04:41,229
no longer has these boring straight

00:04:36,890 --> 00:04:44,719
lines but these fun round the curves

00:04:41,229 --> 00:04:45,919
yeah and that and this is interesting to

00:04:44,719 --> 00:04:48,020
all the academic folks you can actually

00:04:45,919 --> 00:04:52,339
explore vector graphics and put them

00:04:48,020 --> 00:04:55,789
into your papers that is actually what

00:04:52,339 --> 00:04:59,149
you see on the surface but that doesn't

00:04:55,789 --> 00:05:00,499
look like a big feature right that

00:04:59,149 --> 00:05:03,080
doesn't look like something that should

00:05:00,499 --> 00:05:05,449
have taken us six years to come to so

00:05:03,080 --> 00:05:07,520
what did we do in the six years well we

00:05:05,449 --> 00:05:11,539
had a lot of these under the hood very

00:05:07,520 --> 00:05:13,459
pervasive changes and making the day we

00:05:11,539 --> 00:05:17,240
decided that this should have been done

00:05:13,459 --> 00:05:21,319
on a separate thread a git branch there

00:05:17,240 --> 00:05:23,959
was the next French the way we chose to

00:05:21,319 --> 00:05:25,759
develop that was at some point we

00:05:23,959 --> 00:05:27,830
branched off the next branch and all the

00:05:25,759 --> 00:05:30,349
cool new features or the future looking

00:05:27,830 --> 00:05:32,509
work the dependency updates should have

00:05:30,349 --> 00:05:35,809
him on the next branch and we had the

00:05:32,509 --> 00:05:38,269
main branch which was a stable branch

00:05:35,809 --> 00:05:40,580
where all the patches the back fixes

00:05:38,269 --> 00:05:42,919
happened to be on and we had to master

00:05:40,580 --> 00:05:46,159
branch into which the main French was

00:05:42,919 --> 00:05:49,610
regularly merged so to keep the back

00:05:46,159 --> 00:05:51,110
fixes also available on the forward kind

00:05:49,610 --> 00:05:56,259
of forward-looking but not so

00:05:51,110 --> 00:06:00,439
revolutionary branch but that actually

00:05:56,259 --> 00:06:02,149
led to stalling why well if you had

00:06:00,439 --> 00:06:03,800
something that would only work with

00:06:02,149 --> 00:06:06,439
Python three or something that should

00:06:03,800 --> 00:06:07,969
require QT 5 or something that you

00:06:06,439 --> 00:06:10,219
simply didn't want to implement two

00:06:07,969 --> 00:06:13,759
times you would do that on a next branch

00:06:10,219 --> 00:06:17,059
right but that next branch actually

00:06:13,759 --> 00:06:22,389
never saw like extra usage by non core

00:06:17,059 --> 00:06:25,369
developers so we had like a diverse I

00:06:22,389 --> 00:06:27,019
befo patient in development and that was

00:06:25,369 --> 00:06:30,079
not a good thing in terms of getting

00:06:27,019 --> 00:06:31,909
releases out so turns out that you can

00:06:30,079 --> 00:06:33,729
stall development by being very

00:06:31,909 --> 00:06:36,309
progressive and having a very you know

00:06:33,729 --> 00:06:39,860
aggressively forward-looking next branch

00:06:36,309 --> 00:06:46,639
and we decide that we will not do that

00:06:39,860 --> 00:06:50,449
anymore so with the 3/8 release we've

00:06:46,639 --> 00:06:53,029
decided that okay we've now said finally

00:06:50,449 --> 00:06:54,040
completely on the new development model

00:06:53,029 --> 00:06:58,470
where

00:06:54,040 --> 00:06:58,470
all features should go on to master and

00:06:58,860 --> 00:07:05,260
basically bug fixes get happily back

00:07:02,530 --> 00:07:07,660
ported to all the release branches but

00:07:05,260 --> 00:07:09,250
please please please do work on this

00:07:07,660 --> 00:07:11,890
common master branch so that we don't

00:07:09,250 --> 00:07:14,320
you know go to different parts during

00:07:11,890 --> 00:07:16,000
development because turns out merging

00:07:14,320 --> 00:07:18,940
six years of development is actually a

00:07:16,000 --> 00:07:22,150
lot of work and now it's a good thing as

00:07:18,940 --> 00:07:24,940
a maintainer I was astonished by how

00:07:22,150 --> 00:07:28,240
much people were still like willing to

00:07:24,940 --> 00:07:30,550
help to get this out the door like fans

00:07:28,240 --> 00:07:36,250
showed that slight yesterday where we

00:07:30,550 --> 00:07:38,050
compared last year's to current a commit

00:07:36,250 --> 00:07:40,120
activity a contributor activity and

00:07:38,050 --> 00:07:41,740
shows that if you promise to actually

00:07:40,120 --> 00:07:43,470
get this out the door people will help

00:07:41,740 --> 00:07:45,990
you so this is a big thank you for

00:07:43,470 --> 00:07:49,360
everyone that basically stuck with us

00:07:45,990 --> 00:07:53,800
through these longest periods of having

00:07:49,360 --> 00:07:56,050
no significance for release it wouldn't

00:07:53,800 --> 00:07:57,580
be possible and if people hadn't be okay

00:07:56,050 --> 00:07:59,770
we're finally getting this done and

00:07:57,580 --> 00:08:02,080
we're very motivated

00:07:59,770 --> 00:08:05,500
one thing that I've also learned is that

00:08:02,080 --> 00:08:07,360
if you're doing something that is kind

00:08:05,500 --> 00:08:09,820
of a bigger release you need to be

00:08:07,360 --> 00:08:12,400
extremely careful about how you virt

00:08:09,820 --> 00:08:15,340
your release notes because people will

00:08:12,400 --> 00:08:18,310
literally take single word from that and

00:08:15,340 --> 00:08:19,960
say okay this is a minor release which I

00:08:18,310 --> 00:08:22,750
meant with like we're increasing the

00:08:19,960 --> 00:08:24,370
minor version number and people were

00:08:22,750 --> 00:08:27,760
like this is six years of work that's a

00:08:24,370 --> 00:08:29,890
minor thing that we did that was not

00:08:27,760 --> 00:08:32,110
perfect but I think we've learned our

00:08:29,890 --> 00:08:34,570
lesson we've got a lot of publicity from

00:08:32,110 --> 00:08:37,270
from the release I don't think that

00:08:34,570 --> 00:08:40,180
every future release will see the same

00:08:37,270 --> 00:08:43,229
and I'll explain why I hope that's the

00:08:40,180 --> 00:08:43,229
case in a minute

00:08:43,560 --> 00:08:49,300
namely what what do we do now that we've

00:08:46,810 --> 00:08:51,160
got three eight or the door but first of

00:08:49,300 --> 00:08:53,410
all I need to talk to all the developers

00:08:51,160 --> 00:08:57,760
and this is a very effective way of

00:08:53,410 --> 00:09:01,210
doing so about how you will please

00:08:57,760 --> 00:09:04,570
develop in the future this starts with

00:09:01,210 --> 00:09:07,300
the fact that master will become the

00:09:04,570 --> 00:09:07,630
coming ready release so if you'd want

00:09:07,300 --> 00:09:08,880
some

00:09:07,630 --> 00:09:12,580
to happen to be in the next release

00:09:08,880 --> 00:09:15,430
please develop it on master that's kind

00:09:12,580 --> 00:09:17,080
of obvious but it's not as obvious as

00:09:15,430 --> 00:09:20,170
you think because if you want something

00:09:17,080 --> 00:09:22,510
to be fixed on 3.8 you'd be very tempted

00:09:20,170 --> 00:09:26,080
to fix it on mein 3.8 so please do that

00:09:22,510 --> 00:09:29,320
if you find it back in three point 800

00:09:26,080 --> 00:09:32,560
which is the current release fuse please

00:09:29,320 --> 00:09:35,350
do submit their back fix but if you can

00:09:32,560 --> 00:09:37,240
please do that against master and tell

00:09:35,350 --> 00:09:39,760
us about this is a bug fix X applies to

00:09:37,240 --> 00:09:41,560
3/8 to we otherwise have to check

00:09:39,760 --> 00:09:43,990
manually whether that applies to and

00:09:41,560 --> 00:09:46,000
cherry-pick forward or backwards and if

00:09:43,990 --> 00:09:48,760
I can I'd rather cherry-pick backwards

00:09:46,000 --> 00:09:51,610
and back port stuff then trying to get

00:09:48,760 --> 00:09:54,850
something that was hard to fix on 3/8

00:09:51,610 --> 00:10:00,460
into 3 9 2 that's usually the harder

00:09:54,850 --> 00:10:02,190
case so that's all the magic work

00:10:00,460 --> 00:10:07,540
towards the future not to were surpassed

00:10:02,190 --> 00:10:11,820
I need to address a bit about the future

00:10:07,540 --> 00:10:14,620
of the 3 7 release serious I

00:10:11,820 --> 00:10:19,120
deliberately not put too much of that

00:10:14,620 --> 00:10:23,080
onto the slides because we've not we're

00:10:19,120 --> 00:10:25,900
not able to make a hard guarantee that

00:10:23,080 --> 00:10:28,660
says ok we'll be supporting 3 7 for the

00:10:25,900 --> 00:10:30,700
next 20 years why because we had to

00:10:28,660 --> 00:10:33,190
release 3.8 we had to because our

00:10:30,700 --> 00:10:37,990
dependencies are dying so if you lose in

00:10:33,190 --> 00:10:40,450
3.8 add if you're using 3.7 then rest

00:10:37,990 --> 00:10:42,250
assured that if you find a bug we will

00:10:40,450 --> 00:10:44,470
try our best to figure out what's wrong

00:10:42,250 --> 00:10:46,090
there as long it's not in a component

00:10:44,470 --> 00:10:48,670
that's been labeled implicated for a

00:10:46,090 --> 00:10:52,230
long time that's where most people find

00:10:48,670 --> 00:10:52,230
the same back over and over again and

00:10:52,620 --> 00:10:58,330
but I can't promise you that

00:10:54,790 --> 00:11:01,000
here for example Ubuntu 24:04 will still

00:10:58,330 --> 00:11:06,640
be able to run main 3.7 because that's

00:11:01,000 --> 00:11:10,630
literally not possible so with that in

00:11:06,640 --> 00:11:14,050
mind I think 3.8 has been a great

00:11:10,630 --> 00:11:16,690
success in terms of actually wrapping

00:11:14,050 --> 00:11:19,480
work up and getting into a kind of

00:11:16,690 --> 00:11:20,290
release regimen where we know how this

00:11:19,480 --> 00:11:21,550
all works

00:11:20,290 --> 00:11:24,550
we now know

00:11:21,550 --> 00:11:26,459
how do we get contributions in how do we

00:11:24,550 --> 00:11:29,440
get them in on time how do we coordinate

00:11:26,459 --> 00:11:32,200
okay if you do this back fix by

00:11:29,440 --> 00:11:37,959
Wednesday we'll make it into this next

00:11:32,200 --> 00:11:40,420
release so this gives me a confidence

00:11:37,959 --> 00:11:46,029
that we'll be going much much quicker

00:11:40,420 --> 00:11:49,570
two words 3.9 and that leads me to the

00:11:46,029 --> 00:11:53,200
opportunity to talk about 3.9 and if

00:11:49,570 --> 00:11:55,149
you've met me last year Khan and if you

00:11:53,200 --> 00:11:57,399
met me at FOSDEM this year you might

00:11:55,149 --> 00:12:02,470
have noticed that we kind of set on a

00:11:57,399 --> 00:12:05,050
few features already so the first

00:12:02,470 --> 00:12:07,690
feature is if kind of that will make the

00:12:05,050 --> 00:12:10,839
analog device guys in the room rather

00:12:07,690 --> 00:12:15,029
happy we're up streaming GRI a Oh IO is

00:12:10,839 --> 00:12:19,200
not an exclusive analog devices deal

00:12:15,029 --> 00:12:22,390
it's the interface for basically

00:12:19,200 --> 00:12:24,250
sampling devices that analog is very

00:12:22,390 --> 00:12:26,320
heavily involved would they support it

00:12:24,250 --> 00:12:31,180
with most of their devices including the

00:12:26,320 --> 00:12:32,079
Pluto and but if it's a standard thing

00:12:31,180 --> 00:12:34,300
to do

00:12:32,079 --> 00:12:36,310
there's kernel modules for that so if

00:12:34,300 --> 00:12:38,410
you've got like zero copy device you

00:12:36,310 --> 00:12:41,110
might hook that up into that in the

00:12:38,410 --> 00:12:44,589
introduced Linux kernel that way it's a

00:12:41,110 --> 00:12:46,470
interesting platform and that's why

00:12:44,589 --> 00:12:49,510
we're proving it

00:12:46,470 --> 00:12:51,430
we also upstream cheer so p.m. very much

00:12:49,510 --> 00:12:54,010
in the same sense we might not make you

00:12:51,430 --> 00:12:56,589
a do useful for as many people as

00:12:54,010 --> 00:12:59,820
possible not only for a few that you

00:12:56,589 --> 00:13:02,500
know have an extra 10 sitting at home

00:12:59,820 --> 00:13:04,329
that means that I don't think the

00:13:02,500 --> 00:13:07,060
situation where people had to go out in

00:13:04,329 --> 00:13:09,670
storm radio then had to install your

00:13:07,060 --> 00:13:13,060
Ozma SCR and rtl-sdr and everything so

00:13:09,670 --> 00:13:15,490
that they're $6.00 RTL dongle would work

00:13:13,060 --> 00:13:17,769
was a good situation I want to back

00:13:15,490 --> 00:13:19,720
basically be a bit more like Python and

00:13:17,769 --> 00:13:21,550
come with all batteries included so

00:13:19,720 --> 00:13:24,190
that's why we're also up streaming cheer

00:13:21,550 --> 00:13:27,670
so P just to be clear we're not

00:13:24,190 --> 00:13:31,449
duplicating GRU HD that's still a

00:13:27,670 --> 00:13:33,790
first-class citizen so don't worry

00:13:31,449 --> 00:13:35,339
another feature that we do is we'll drop

00:13:33,790 --> 00:13:38,320
patent 2

00:13:35,339 --> 00:13:40,329
that doesn't sound like a feature at

00:13:38,320 --> 00:13:42,880
first until you realize how much energy

00:13:40,329 --> 00:13:46,990
went into supporting both fighting 2 and

00:13:42,880 --> 00:13:49,240
PI 3 in the 3:8 release and we need to

00:13:46,990 --> 00:13:51,160
make kind of a trade-off between you

00:13:49,240 --> 00:13:53,920
know supporting every everyone's use

00:13:51,160 --> 00:13:58,360
case and being able to still develop in

00:13:53,920 --> 00:14:00,730
a timely fashion so that's why this to

00:13:58,360 --> 00:14:04,269
me as a developer is a feature and to me

00:14:00,730 --> 00:14:07,360
as a user it's also featured because I

00:14:04,269 --> 00:14:10,300
can now be sure that whatever I develop

00:14:07,360 --> 00:14:13,779
agna radio program the guy running it

00:14:10,300 --> 00:14:17,940
we run Python 3 and not Python 2.7 5

00:14:13,779 --> 00:14:22,870
which is no fun to support

00:14:17,940 --> 00:14:23,860
so with these promises made do we wait

00:14:22,870 --> 00:14:27,430
another 6 years

00:14:23,860 --> 00:14:28,899
I say we don't we've been having

00:14:27,430 --> 00:14:32,139
internal discussions about that for

00:14:28,899 --> 00:14:35,670
quite a while now and basically I've

00:14:32,139 --> 00:14:40,269
settled on on what I thought was an

00:14:35,670 --> 00:14:44,470
optimal schedule when I adopted the role

00:14:40,269 --> 00:14:47,760
of being the maintainer and as due to

00:14:44,470 --> 00:14:51,220
releases a year they don't need to be

00:14:47,760 --> 00:14:56,620
large releases like I won't promise that

00:14:51,220 --> 00:14:59,740
4.0 is out in a year but we can now work

00:14:56,620 --> 00:15:03,940
towards like dedicated goals we can say

00:14:59,740 --> 00:15:06,070
you know what on this day 2020 that's

00:15:03,940 --> 00:15:07,720
the day when we stop merging any more

00:15:06,070 --> 00:15:09,790
code that's the day when we start

00:15:07,720 --> 00:15:13,480
preparing actually like tour balls

00:15:09,790 --> 00:15:15,459
release binaries this kind of thing and

00:15:13,480 --> 00:15:17,380
how that schedule would look like is

00:15:15,459 --> 00:15:21,459
first of all obviously I need to

00:15:17,380 --> 00:15:23,980
entertain the crowds and since this is

00:15:21,459 --> 00:15:26,560
not instant Rome I can't do that with

00:15:23,980 --> 00:15:31,089
gladiators I do that releases um so

00:15:26,560 --> 00:15:33,750
about a month before the icon should be

00:15:31,089 --> 00:15:36,430
enough to keep you you know entertained

00:15:33,750 --> 00:15:40,000
that the one release the other release

00:15:36,430 --> 00:15:42,220
would be after for stem which is to come

00:15:40,000 --> 00:15:45,970
free and open source developers meeting

00:15:42,220 --> 00:15:48,550
in Europe in Brussels which would be

00:15:45,970 --> 00:15:51,310
about mid-march by then

00:15:48,550 --> 00:15:53,740
because that's an awesome opportunity to

00:15:51,310 --> 00:15:58,839
get like one half of the community into

00:15:53,740 --> 00:16:01,180
a room talk to them and kora network and

00:15:58,839 --> 00:16:05,410
then get something done this kind of

00:16:01,180 --> 00:16:07,180
dictates that the FOSDEM release would

00:16:05,410 --> 00:16:09,430
be often more more of a janitorial

00:16:07,180 --> 00:16:11,430
release where you do a lot of small

00:16:09,430 --> 00:16:15,040
stuff that finally needs to be done and

00:16:11,430 --> 00:16:16,839
the GR con release would you know offer

00:16:15,040 --> 00:16:21,070
itself to being the one that you

00:16:16,839 --> 00:16:23,589
introduce cool new directions but I

00:16:21,070 --> 00:16:26,410
guess we'll figure out how that pans out

00:16:23,589 --> 00:16:28,390
and in the future by doing so so but

00:16:26,410 --> 00:16:31,839
that's basically the thing about six

00:16:28,390 --> 00:16:34,390
months between releases we are not

00:16:31,839 --> 00:16:39,760
setting up for saying okay this is gonna

00:16:34,390 --> 00:16:41,769
be we always gonna do a large major

00:16:39,760 --> 00:16:44,589
version release per year we're doing

00:16:41,769 --> 00:16:46,149
with setting targets we're figuring out

00:16:44,589 --> 00:16:48,310
where these targets can be done within a

00:16:46,149 --> 00:16:50,010
minor or within a major release and then

00:16:48,310 --> 00:16:52,329
we decide upon that all that we've

00:16:50,010 --> 00:16:54,850
promised is that we're giving you

00:16:52,329 --> 00:16:57,550
definite dates on which you can expect

00:16:54,850 --> 00:17:00,480
your code to appear in the public as

00:16:57,550 --> 00:17:00,480
long as it works

00:17:00,959 --> 00:17:08,679
so three point nine is fine and Danny

00:17:06,189 --> 00:17:11,679
comes with a few new features that we've

00:17:08,679 --> 00:17:14,860
haven't written yet so that's gonna be a

00:17:11,679 --> 00:17:17,559
lot of fun but what about you know the

00:17:14,860 --> 00:17:22,419
future future like where do we take new

00:17:17,559 --> 00:17:24,730
radio let's pan set narrator's gotten

00:17:22,419 --> 00:17:31,000
pretty old actually like if 18 now it

00:17:24,730 --> 00:17:35,140
can buy booze and Germany's and yeah

00:17:31,000 --> 00:17:38,470
it's not getting any less crusty with

00:17:35,140 --> 00:17:41,830
age so how do we address the things that

00:17:38,470 --> 00:17:43,660
go wrong what actually does go wrong

00:17:41,830 --> 00:17:47,740
what do we need to address to make you

00:17:43,660 --> 00:17:49,960
know stay the top free software and you

00:17:47,740 --> 00:17:52,809
know globally probably the most popular

00:17:49,960 --> 00:17:56,380
software different radio environment and

00:17:52,809 --> 00:17:58,960
um over the last gr concept literally

00:17:56,380 --> 00:18:01,960
been the last five 60 our concept at

00:17:58,960 --> 00:18:03,520
least I witness we

00:18:01,960 --> 00:18:05,620
identified a couple of things the first

00:18:03,520 --> 00:18:07,809
thing is while our scheduling is

00:18:05,620 --> 00:18:09,700
actually pretty cool but it's also

00:18:07,809 --> 00:18:11,890
pretty primitive I'll go into detail on

00:18:09,700 --> 00:18:14,679
that in a second we need to work on that

00:18:11,890 --> 00:18:21,070
because especially the embedded guys and

00:18:14,679 --> 00:18:23,230
they hire eight people they tend to one

00:18:21,070 --> 00:18:28,390
features that we can't offer with the

00:18:23,230 --> 00:18:30,909
current scheduling system to do that

00:18:28,390 --> 00:18:33,730
though we need to learn a lot about how

00:18:30,909 --> 00:18:35,710
the system actually behaves because as I

00:18:33,730 --> 00:18:39,039
don't play explaining a second this is

00:18:35,710 --> 00:18:40,450
actually not deterministic the result

00:18:39,039 --> 00:18:42,880
should be deterministic and whenever

00:18:40,450 --> 00:18:46,360
they are not please fire back

00:18:42,880 --> 00:18:48,850
but the way things are computed is not

00:18:46,360 --> 00:18:53,559
this deterministic at this point and

00:18:48,850 --> 00:18:56,110
probably never will for reason so let me

00:18:53,559 --> 00:18:58,480
talk about for a second how no writer

00:18:56,110 --> 00:19:01,360
currently works I think this is four out

00:18:58,480 --> 00:19:03,789
of the attendance in this room this

00:19:01,360 --> 00:19:08,010
might actually be an interesting thing

00:19:03,789 --> 00:19:10,360
to talk about so what you see here is a

00:19:08,010 --> 00:19:12,399
write a companion three-point-seven flow

00:19:10,360 --> 00:19:15,010
graph it's very minimal it consists of

00:19:12,399 --> 00:19:16,570
three blocks so what does can all really

00:19:15,010 --> 00:19:18,580
do when you hit the Run button

00:19:16,570 --> 00:19:20,440
well you generate a Python file that

00:19:18,580 --> 00:19:22,330
tells can radio okay I need to

00:19:20,440 --> 00:19:24,549
instantiate three blocks and this is how

00:19:22,330 --> 00:19:28,690
I connect them and then the flow graph

00:19:24,549 --> 00:19:31,659
starts what does that mean that means

00:19:28,690 --> 00:19:35,590
that no radio checks the graph structure

00:19:31,659 --> 00:19:37,630
and figures out okay the only block that

00:19:35,590 --> 00:19:40,690
can actually do something with zero

00:19:37,630 --> 00:19:43,809
input is the signal source the source

00:19:40,690 --> 00:19:46,809
block on the very left and it helps that

00:19:43,809 --> 00:19:48,880
hey you could now work I've got zero

00:19:46,809 --> 00:19:51,190
input samples on zero input streams this

00:19:48,880 --> 00:19:53,020
is awesome and you've got half your

00:19:51,190 --> 00:19:54,090
output buffer in space so please do

00:19:53,020 --> 00:19:56,679
something with that

00:19:54,090 --> 00:19:59,919
and the signal source will go ahead

00:19:56,679 --> 00:20:01,870
calculate a sine wave for cosine wave

00:19:59,919 --> 00:20:03,970
through the output buffer half of the

00:20:01,870 --> 00:20:09,340
output buffer like how much is offered

00:20:03,970 --> 00:20:13,299
with that data and tell the runtime that

00:20:09,340 --> 00:20:15,389
hey I'm done now I've produced 4069 and

00:20:13,299 --> 00:20:18,839
ninety-six items

00:20:15,389 --> 00:20:20,549
now that's the moment when the

00:20:18,839 --> 00:20:23,099
downstream block in this case the

00:20:20,549 --> 00:20:25,200
multiplied cons block would get notified

00:20:23,099 --> 00:20:28,950
there's input which start working on

00:20:25,200 --> 00:20:31,289
that input in the meantime remember the

00:20:28,950 --> 00:20:34,229
signal source was only called with half

00:20:31,289 --> 00:20:37,320
the output space as possible output

00:20:34,229 --> 00:20:39,509
buffer it can be called again because

00:20:37,320 --> 00:20:41,519
there's still free space it's being

00:20:39,509 --> 00:20:43,619
called again so why are the multiply

00:20:41,519 --> 00:20:45,690
constants already running the signal

00:20:43,619 --> 00:20:47,940
source starts running again so we've now

00:20:45,690 --> 00:20:50,009
got a parallelism of two blocks running

00:20:47,940 --> 00:20:51,679
the moment the multiply construct which

00:20:50,009 --> 00:20:55,529
should be rather fast compared to

00:20:51,679 --> 00:20:57,179
generating a cosine it's finished the

00:20:55,529 --> 00:21:02,489
fighting is notified that there's now

00:20:57,179 --> 00:21:04,859
four in a 4096 items waiting for it now

00:21:02,489 --> 00:21:09,109
that's usually not the case but imagine

00:21:04,859 --> 00:21:13,139
the file source can't accept or 4096

00:21:09,109 --> 00:21:15,509
items at once it can at most say process

00:21:13,139 --> 00:21:18,179
1,000 of them at a time so the first

00:21:15,509 --> 00:21:21,179
thing will then take these thousand

00:21:18,179 --> 00:21:24,509
items and process them and at the end of

00:21:21,179 --> 00:21:28,049
its work function will return a value

00:21:24,509 --> 00:21:30,839
that tells the run time that it only

00:21:28,049 --> 00:21:33,659
consumed thousands of the items which is

00:21:30,839 --> 00:21:39,269
no problem because the runtime knows

00:21:33,659 --> 00:21:41,729
that this means the the later 3096 items

00:21:39,269 --> 00:21:44,070
are still unprocessed so it combines

00:21:41,729 --> 00:21:46,349
these with the output of multiply

00:21:44,070 --> 00:21:48,989
constants that appeared in the meantime

00:21:46,349 --> 00:21:52,799
which happens to be community located

00:21:48,989 --> 00:21:54,389
directly after memory and we get like

00:21:52,799 --> 00:21:56,509
this kind of continuous flow when out

00:21:54,389 --> 00:21:59,849
three blocks can work in parallel and

00:21:56,509 --> 00:22:02,519
there's no constraint on how many items

00:21:59,849 --> 00:22:05,659
someone has to consume as long as as

00:22:02,519 --> 00:22:09,029
it's less than what's available or equal

00:22:05,659 --> 00:22:12,659
that's awesome that means we get high

00:22:09,029 --> 00:22:15,329
parallelism that means we run blocks

00:22:12,659 --> 00:22:17,459
with the largest possible contiguous

00:22:15,329 --> 00:22:22,739
amount of input which is very nice for

00:22:17,459 --> 00:22:25,019
throughput usually and that's very

00:22:22,739 --> 00:22:27,299
convenient to program right we just you

00:22:25,019 --> 00:22:29,050
know spawn threats and tell the

00:22:27,299 --> 00:22:31,300
operating system that you know

00:22:29,050 --> 00:22:33,760
that threat it can now continue there's

00:22:31,300 --> 00:22:40,120
a notification message telling it that

00:22:33,760 --> 00:22:43,660
hey you're ready to work so with that

00:22:40,120 --> 00:22:45,340
being said there's a few points that

00:22:43,660 --> 00:22:48,490
don't really fit well with us

00:22:45,340 --> 00:22:50,170
so scheduler might we always talk about

00:22:48,490 --> 00:22:52,240
ignore a scheduler and that might be a

00:22:50,170 --> 00:22:54,610
bit of a grandiose word for something

00:22:52,240 --> 00:22:56,830
that just informs the offset you've got

00:22:54,610 --> 00:23:00,400
twenty thousand threats and these five

00:22:56,830 --> 00:23:03,010
can now work out there's no exchange of

00:23:00,400 --> 00:23:04,990
data from the flow graph into the

00:23:03,010 --> 00:23:10,690
operating system so there's no knowledge

00:23:04,990 --> 00:23:12,010
of who owns more data so this is kind of

00:23:10,690 --> 00:23:13,540
like if you think about that that's kind

00:23:12,010 --> 00:23:15,430
of catastrophic if you know anything

00:23:13,540 --> 00:23:17,410
about CPU modern modern system

00:23:15,430 --> 00:23:19,300
architectures than CPU and RAM then you

00:23:17,410 --> 00:23:21,370
know that caching is very important for

00:23:19,300 --> 00:23:24,070
for speed because getting a single value

00:23:21,370 --> 00:23:26,020
from RAM usually takes depends on the

00:23:24,070 --> 00:23:29,380
CPU something between two hundreds and

00:23:26,020 --> 00:23:32,680
thousands times the time it takes to

00:23:29,380 --> 00:23:37,060
multiply two numbers so if you can you

00:23:32,680 --> 00:23:39,190
keep stuff in cash but migrating threats

00:23:37,060 --> 00:23:40,900
between CPU cores randomly because you

00:23:39,190 --> 00:23:43,210
just told you us that this threat can

00:23:40,900 --> 00:23:45,550
now be scheduled again and the else just

00:23:43,210 --> 00:23:48,010
goes in and says what CPU core is

00:23:45,550 --> 00:23:50,800
currently unaware unoccupied and then

00:23:48,010 --> 00:23:52,720
picks the random CPU core execute that

00:23:50,800 --> 00:23:54,670
block on instead of using the same CPU

00:23:52,720 --> 00:23:56,470
core that was computed to compute the

00:23:54,670 --> 00:23:59,320
input they used to compute the input of

00:23:56,470 --> 00:24:01,630
that block leads to a lot of memory

00:23:59,320 --> 00:24:06,190
having to be you know flashed out to ram

00:24:01,630 --> 00:24:09,310
and loaded into the other CPU cache so

00:24:06,190 --> 00:24:12,850
this is very very suboptimal and we know

00:24:09,310 --> 00:24:18,100
that the other thing though is this

00:24:12,850 --> 00:24:21,070
works surprisingly well anything like we

00:24:18,100 --> 00:24:23,200
are the most successful STR framework so

00:24:21,070 --> 00:24:25,540
it can't be so bad and tests show that

00:24:23,200 --> 00:24:28,540
we can get better so if you remember gr

00:24:25,540 --> 00:24:30,970
con in San Diego there was a company

00:24:28,540 --> 00:24:33,670
called simply executive and Kirby

00:24:30,970 --> 00:24:38,020
Cartwright I think had a Lima where they

00:24:33,670 --> 00:24:39,880
optimized a TV receiver program which is

00:24:38,020 --> 00:24:41,380
rather CPU intense and pretty

00:24:39,880 --> 00:24:42,770
drastically like increasing throughput

00:24:41,380 --> 00:24:46,030
by I think it was

00:24:42,770 --> 00:24:48,890
in the tens of persons by simply pinning

00:24:46,030 --> 00:24:51,890
specific blocks to be specific CPU cores

00:24:48,890 --> 00:24:56,090
which you know eradicate the opportunity

00:24:51,890 --> 00:24:58,400
to migrate them between CPU cores but

00:24:56,090 --> 00:25:00,110
there is like human intervention and

00:24:58,400 --> 00:25:01,610
it's also not clear whether there was an

00:25:00,110 --> 00:25:03,740
optimal solution or whether they should

00:25:01,610 --> 00:25:05,960
have picked more blocks to that threat

00:25:03,740 --> 00:25:08,360
or whether pinning these blocks to the

00:25:05,960 --> 00:25:10,460
threat to the CPU core actually that's

00:25:08,360 --> 00:25:12,320
what we want because it might still mean

00:25:10,460 --> 00:25:13,880
that you know the block at the very end

00:25:12,320 --> 00:25:15,800
of the processing chain might be

00:25:13,880 --> 00:25:20,800
scheduled before and we're again

00:25:15,800 --> 00:25:23,960
thrashing our caches so my dad in mind

00:25:20,800 --> 00:25:25,700
we need to address all these issues in

00:25:23,960 --> 00:25:29,000
scheduling another thing that we need to

00:25:25,700 --> 00:25:31,670
address is that usually like in digital

00:25:29,000 --> 00:25:34,040
communications we are very much used to

00:25:31,670 --> 00:25:35,360
dealing with pages we're not so much

00:25:34,040 --> 00:25:38,660
used to dealing with streams not

00:25:35,360 --> 00:25:40,700
everything is an FM receiver right so

00:25:38,660 --> 00:25:42,950
what we did in the past to come up with

00:25:40,700 --> 00:25:46,580
that to deal with that is come up with

00:25:42,950 --> 00:25:49,490
ways of tagging sample streams and

00:25:46,580 --> 00:25:53,960
basically emulating a packet interface

00:25:49,490 --> 00:25:55,400
on our stream based interconnect those

00:25:53,960 --> 00:25:57,830
were to take stream blocks and everyone

00:25:55,400 --> 00:26:01,370
who's worked with them probably notice

00:25:57,830 --> 00:26:02,990
that they have some kinks to work out

00:26:01,370 --> 00:26:05,420
and they might not be the greatest

00:26:02,990 --> 00:26:07,910
solution to that problem so what I

00:26:05,420 --> 00:26:09,500
really envisioned here is that it should

00:26:07,910 --> 00:26:12,500
actually make no difference to a work

00:26:09,500 --> 00:26:15,770
function where the buffer it's working

00:26:12,500 --> 00:26:17,480
on comes from a message or comes from a

00:26:15,770 --> 00:26:19,250
ring buffer or how many let it ring

00:26:17,480 --> 00:26:23,030
buffer as we do now with streams or

00:26:19,250 --> 00:26:30,860
comes from say a GPU that is used as an

00:26:23,030 --> 00:26:33,920
accelerator so and also there's no way

00:26:30,860 --> 00:26:36,410
no elegant way for a block that takes as

00:26:33,920 --> 00:26:38,870
in Cronus messages in and outputs a

00:26:36,410 --> 00:26:41,930
stream of data for example to feed into

00:26:38,870 --> 00:26:45,260
an SDR transmitter to you know go to

00:26:41,930 --> 00:26:48,290
sleep and with zero latency wake up as

00:26:45,260 --> 00:26:50,600
soon as there's a message so ice met

00:26:48,290 --> 00:26:52,760
about that I've had a very long and

00:26:50,600 --> 00:26:55,860
intense discussion over quite a few

00:26:52,760 --> 00:26:58,260
click Marta at Congress or at cam

00:26:55,860 --> 00:27:00,450
it's actually not not trivial nor it's

00:26:58,260 --> 00:27:03,510
not generally even possible so we need

00:27:00,450 --> 00:27:06,270
to address that I'm not going to go into

00:27:03,510 --> 00:27:08,190
too many details on this but I think we

00:27:06,270 --> 00:27:12,540
need to talk about the next big thing

00:27:08,190 --> 00:27:14,910
MBT so what what what meat does that

00:27:12,540 --> 00:27:18,360
need to do it first of all it needs to

00:27:14,910 --> 00:27:21,270
address the fact that CPU pores are not

00:27:18,360 --> 00:27:23,309
you know infinite while blocks might

00:27:21,270 --> 00:27:25,950
very well be spawned in very large

00:27:23,309 --> 00:27:28,130
numbers so we need at least an

00:27:25,950 --> 00:27:31,470
architecture that allows us to aggregate

00:27:28,130 --> 00:27:34,890
multiple blocks onto one CPU core and do

00:27:31,470 --> 00:27:36,480
that in a way that's kind of flexible we

00:27:34,890 --> 00:27:39,840
need to have a single input queue per

00:27:36,480 --> 00:27:42,660
worker I go into detail on that in a

00:27:39,840 --> 00:27:44,850
second and we need to be less dependent

00:27:42,660 --> 00:27:46,950
on where the data is actually coming

00:27:44,850 --> 00:27:51,000
from so I'm now going to into detail on

00:27:46,950 --> 00:27:53,250
these three points that worker idea

00:27:51,000 --> 00:27:55,350
doesn't mean that we have to drop the

00:27:53,250 --> 00:27:57,840
mechanism that works so well at this

00:27:55,350 --> 00:28:00,900
time the book can still be a one-to-one

00:27:57,840 --> 00:28:03,000
mapping and that's what you'd start with

00:28:00,900 --> 00:28:07,080
implementing we recreate what works well

00:28:03,000 --> 00:28:09,950
at this time so ideally we just know we

00:28:07,080 --> 00:28:15,150
implement the block executors worker to

00:28:09,950 --> 00:28:16,920
actually be less dependent on the exact

00:28:15,150 --> 00:28:18,840
Waggoner aiders implemented right now on

00:28:16,920 --> 00:28:22,020
can more easily accept messages

00:28:18,840 --> 00:28:24,690
basically from anywhere in the future

00:28:22,020 --> 00:28:27,420
that will obviously aim for as many

00:28:24,690 --> 00:28:30,720
workers as you can actually you know

00:28:27,420 --> 00:28:32,850
deal with as you have CPU cores maybe

00:28:30,720 --> 00:28:35,100
over provision a bit if you know that

00:28:32,850 --> 00:28:37,020
not all of these will be ok like working

00:28:35,100 --> 00:28:40,140
at the same time depends on your signal

00:28:37,020 --> 00:28:41,970
flow graph if you've got these workers

00:28:40,140 --> 00:28:44,490
then they need some some way of

00:28:41,970 --> 00:28:47,130
organizing their work right and the way

00:28:44,490 --> 00:28:49,679
to do that in my opinion would would be

00:28:47,130 --> 00:28:52,679
the single queue per worker that there's

00:28:49,679 --> 00:28:55,290
a single queue of workload items that

00:28:52,679 --> 00:28:56,640
you want to deal with that comes with a

00:28:55,290 --> 00:28:58,140
lot of advantages like from a

00:28:56,640 --> 00:28:59,970
programming point of view you don't get

00:28:58,140 --> 00:29:01,890
a special block state that's different

00:28:59,970 --> 00:29:03,540
whether you're blocked on input space or

00:29:01,890 --> 00:29:05,280
blocked on output space you're just your

00:29:03,540 --> 00:29:08,730
queues empty so you can't do anything or

00:29:05,280 --> 00:29:09,389
the top item in your blue queue is not

00:29:08,730 --> 00:29:10,769
able to

00:29:09,389 --> 00:29:12,839
be processed for some reason that's

00:29:10,769 --> 00:29:16,469
that's the only thing that can actually

00:29:12,839 --> 00:29:17,929
work if you got a blue queue with items

00:29:16,469 --> 00:29:20,159
that are not yet being worked on

00:29:17,929 --> 00:29:21,839
shifting these items to a different

00:29:20,159 --> 00:29:24,329
queue would actually be easy right

00:29:21,839 --> 00:29:26,369
everyone knows how how much of a pain it

00:29:24,329 --> 00:29:28,739
is to reconfigure our gonna read your

00:29:26,369 --> 00:29:30,059
flow graph in this time and age it means

00:29:28,739 --> 00:29:33,629
that you stopped all the flow graph

00:29:30,059 --> 00:29:35,279
everything grinds to a halt and then you

00:29:33,629 --> 00:29:37,700
restart and hope that all the hardware

00:29:35,279 --> 00:29:41,039
that you use in the meantime you know

00:29:37,700 --> 00:29:44,729
retained its state that can be pretty

00:29:41,039 --> 00:29:46,919
critical also that queue could be clever

00:29:44,729 --> 00:29:49,079
it could be assessing its own state it

00:29:46,919 --> 00:29:51,059
could be able to you know real sort

00:29:49,079 --> 00:29:54,679
things if it turns out that maybe you

00:29:51,059 --> 00:29:57,209
can optimize cache access that way and

00:29:54,679 --> 00:29:59,219
the last thing is that a queue might

00:29:57,209 --> 00:30:00,809
just consist of workload items rather

00:29:59,219 --> 00:30:04,489
than making a distinction between

00:30:00,809 --> 00:30:07,289
messages to be processed and stream

00:30:04,489 --> 00:30:08,849
pointers to be advanced and then work to

00:30:07,289 --> 00:30:12,029
be called you can just have a workload

00:30:08,849 --> 00:30:14,639
item that's like okay in this buffer

00:30:12,029 --> 00:30:16,889
there's input items input data like in a

00:30:14,639 --> 00:30:18,989
stream oh you might be oh this is a

00:30:16,889 --> 00:30:22,289
message it contains input please process

00:30:18,989 --> 00:30:24,149
that we can work with the existing very

00:30:22,289 --> 00:30:26,879
successful semantics we don't need to

00:30:24,149 --> 00:30:29,309
change what the generated block is which

00:30:26,879 --> 00:30:31,409
is a very successful concept it's a fact

00:30:29,309 --> 00:30:33,239
it's a it's a single class with the

00:30:31,409 --> 00:30:36,209
constructor and a burp function and

00:30:33,239 --> 00:30:37,679
that's what 99% of you usually care for

00:30:36,209 --> 00:30:40,349
you implement a verb function it works

00:30:37,679 --> 00:30:43,079
and you shouldn't have to care about

00:30:40,349 --> 00:30:46,799
whether your work function works on data

00:30:43,079 --> 00:30:49,289
from an OFDM framer or you know from an

00:30:46,799 --> 00:30:52,259
outer Aldo model so that's that's what I

00:30:49,289 --> 00:30:53,789
envisioned here also that means that you

00:30:52,259 --> 00:30:57,889
know as soon as we stop caring about

00:30:53,789 --> 00:31:00,359
where that buffer space comes from yeah

00:30:57,889 --> 00:31:03,029
taking that buffer space and filling it

00:31:00,359 --> 00:31:05,519
with data from an rxq on and network

00:31:03,029 --> 00:31:07,589
interface card becomes a lot easier and

00:31:05,519 --> 00:31:11,039
we don't have to rely on the memory

00:31:07,589 --> 00:31:13,349
coming from some memory mapped emulators

00:31:11,039 --> 00:31:15,209
ring buffer so acceleration is now

00:31:13,349 --> 00:31:17,690
possible and he's telling me I've got

00:31:15,209 --> 00:31:17,690
two minutes left

00:31:20,830 --> 00:31:26,200
so that necessitates a lot of changes

00:31:23,680 --> 00:31:29,290
and luckily these are pretty easy to

00:31:26,200 --> 00:31:31,030
categorize as benchmarking that needs to

00:31:29,290 --> 00:31:32,410
be done before and after obviously we

00:31:31,030 --> 00:31:33,670
don't want to optimize something that

00:31:32,410 --> 00:31:36,070
works well and we don't want to make it

00:31:33,670 --> 00:31:39,070
worse we need to be sure that we're

00:31:36,070 --> 00:31:42,310
doing the right thing and we need to

00:31:39,070 --> 00:31:44,290
refactor what is already in there so I'm

00:31:42,310 --> 00:31:46,180
very happy that Bastion has actually

00:31:44,290 --> 00:31:51,760
taken the lead on that

00:31:46,180 --> 00:31:53,920
I'm his he's working on a branch himself

00:31:51,760 --> 00:31:58,630
and his very update up-to-date in radio

00:31:53,920 --> 00:32:01,630
p.m. repository and there's already

00:31:58,630 --> 00:32:06,040
being things being set back into the

00:32:01,630 --> 00:32:07,360
mainline radio and that is the immediate

00:32:06,040 --> 00:32:09,490
years that we already have

00:32:07,360 --> 00:32:12,220
I'm is that some of the code and the

00:32:09,490 --> 00:32:16,240
scheduler initially about 18 years old

00:32:12,220 --> 00:32:18,340
and it doesn't work so great and now she

00:32:16,240 --> 00:32:20,980
has been refactoring that please do look

00:32:18,340 --> 00:32:26,140
over what he's doing we're fine it on

00:32:20,980 --> 00:32:29,770
his github we now have benchmarking

00:32:26,140 --> 00:32:32,560
based on EBP F so on Linux kernel

00:32:29,770 --> 00:32:35,350
facilities that allows us to actually

00:32:32,560 --> 00:32:36,970
know when cache misses happen that

00:32:35,350 --> 00:32:40,720
actually allows us to count how often

00:32:36,970 --> 00:32:43,450
threats were migrated between CPU cores

00:32:40,720 --> 00:32:45,880
that actually allows us to you know look

00:32:43,450 --> 00:32:49,720
how long certain functions are is way

00:32:45,880 --> 00:32:52,690
more in depth than control port used to

00:32:49,720 --> 00:32:54,820
do it for us also and this is the master

00:32:52,690 --> 00:32:59,410
and I side-effect its way lower in

00:32:54,820 --> 00:33:02,760
overhead so that I think that the

00:32:59,410 --> 00:33:05,940
logical evolvement of control parties or

00:33:02,760 --> 00:33:10,090
imperf counters is going this direction

00:33:05,940 --> 00:33:13,390
also what passages did is implement gr

00:33:10,090 --> 00:33:17,140
sketch which is a benchmarking tool that

00:33:13,390 --> 00:33:18,910
does test the current scheduler under

00:33:17,140 --> 00:33:21,010
certain you can tweak the Linux kernel

00:33:18,910 --> 00:33:25,090
on ways that schedules different

00:33:21,010 --> 00:33:27,850
processes differently and we actually

00:33:25,090 --> 00:33:30,550
from party actually found out that not

00:33:27,850 --> 00:33:32,530
everything is optimal that generator

00:33:30,550 --> 00:33:33,639
does add that link starts by default if

00:33:32,530 --> 00:33:35,950
you switch

00:33:33,639 --> 00:33:39,909
real-time scheduler you can get pretty

00:33:35,950 --> 00:33:41,679
easy pretty nice gains so we might as

00:33:39,909 --> 00:33:44,559
well be doing that by default in the

00:33:41,679 --> 00:33:47,889
future and he also says okay we're

00:33:44,559 --> 00:33:49,719
building a mock-up of an idiot idealized

00:33:47,889 --> 00:33:53,469
scheduler and always employees to

00:33:49,719 --> 00:33:55,269
maximum cache coherency and then we hit

00:33:53,469 --> 00:33:57,820
drafts like I really much like this

00:33:55,269 --> 00:34:02,799
draft because it looks so cool that's

00:33:57,820 --> 00:34:05,799
basically telling us which block went on

00:34:02,799 --> 00:34:07,929
with Ren at a given time and how often

00:34:05,799 --> 00:34:10,569
it was migrated something so you can't

00:34:07,929 --> 00:34:14,649
probably read it but this is flocks and

00:34:10,569 --> 00:34:16,359
vertical and time in horizontal s

00:34:14,649 --> 00:34:18,010
there's a lot of interesting

00:34:16,359 --> 00:34:19,720
visualizations coming out of there and I

00:34:18,010 --> 00:34:22,510
very much encourage you to check out G

00:34:19,720 --> 00:34:25,269
our sketch because it is fun to run that

00:34:22,510 --> 00:34:28,319
and it's far from being done we need to

00:34:25,269 --> 00:34:30,579
incorporate information about how your

00:34:28,319 --> 00:34:32,109
software your hardware architecture

00:34:30,579 --> 00:34:33,940
actually looks like in a way of

00:34:32,109 --> 00:34:36,029
reporting that back so that we can in

00:34:33,940 --> 00:34:39,549
the future actually do something about

00:34:36,029 --> 00:34:43,379
optimal scheduling for everyone instead

00:34:39,549 --> 00:34:50,259
of just for the developers hexa-core

00:34:43,379 --> 00:34:53,649
machine so that's where we are so what

00:34:50,259 --> 00:34:56,379
what's the immediate things to do yeah

00:34:53,649 --> 00:34:59,019
we the refactoring and whatever we can

00:34:56,379 --> 00:35:01,960
immediately use for 3:9 as soon as

00:34:59,019 --> 00:35:05,490
possible because honestly um that

00:35:01,960 --> 00:35:05,490
spaghetti code is no fun to work with

00:35:05,500 --> 00:35:11,710
and we obviously change a lot of how

00:35:08,380 --> 00:35:14,650
radio works when we do the next big

00:35:11,710 --> 00:35:16,690
thing and that probably will mean that

00:35:14,650 --> 00:35:18,190
we can't you know keep the

00:35:16,690 --> 00:35:20,769
three-point-something versioning which

00:35:18,190 --> 00:35:22,240
is I'm actually pretty excited about so

00:35:20,769 --> 00:35:24,309
we'll see if we write it for release

00:35:22,240 --> 00:35:25,869
that probably incorporates that not

00:35:24,309 --> 00:35:27,970
promising that it's actually gonna be

00:35:25,869 --> 00:35:29,619
fall it might be five because if

00:35:27,970 --> 00:35:31,930
something in-between happens that needs

00:35:29,619 --> 00:35:34,680
us to change something and I'm done I'm

00:35:31,930 --> 00:35:38,200
so sorry

00:35:34,680 --> 00:35:39,070
questions thank you Marcus you'll find

00:35:38,200 --> 00:35:41,130
me

00:35:39,070 --> 00:35:41,130

YouTube URL: https://www.youtube.com/watch?v=oqZ1K-Ng-Qk


