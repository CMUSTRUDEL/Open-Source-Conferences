Title: GRCon19 - Fixing the E310 Bottleneck: Implementing a High-Rate Heterogeneous... by Edward Kreinar
Publication date: 2019-11-05
Playlist: GRCon 2019
Description: 
	Fixing the E310 Bottleneck: Implementing a High-Rate Heterogeneous FPGA DMA Transport
by Edward Kreinar, Lorin Metzger, Dan CaJacob

FPGAs are a common solution when accelerating software defined radio processing in an embedded form factor, but several implementation-specific limitations need to be addressed in order to take full advantage of today’s heterogeneous processing capabilities. Case in point: Ettus’s E310 embedded family of devices, a Zynq-based architecture, struggles to transfer an uninterrupted stream of 2 Msps between the FPGA and a Gnuradio application running in the Zynq’s ARM-based processor. As a counter example, Analog Devices’s “libiio” family of software, which is compatible with Zynq and Altera SoCs, is able to transfer the full rate of multichannel (2x) TX/RX streaming data at 61.44 Msps between FPGA and host processor. In an effort to build FPGA-based applications within RFNoC, Hawkeye 360 has explored the limitations, causes, and potential resolutions to the E310’s relatively poor FPGA/ARM transport performance, and in doing so, has created an alternate transport for the E310 hardware which achieves full-rate data transfers between FPGA and ARM.

This talk will first discuss the observed limitations of the E310 performance bottleneck; when can the existing embedded E310 transport be used “as-is”? Secondly, the talk will summarize common software and hardware paradigms for direct memory access (DMA) transport between FPGA and host in a SoC architecture, and identify the root cause of poor performance; why does the libiio architecture perform an order of magnitude better than the E310 solution? Finally, Hawkeye 360 will discuss a “do it yourself” approach, whereby a Xilinx DMA core plus a custom kernel module optimized for high-rate data transfers can sustain continuous and bursted data transfers into Gnuradio applications within a heterogenous RFNoC flowgraph.
Captions: 
	00:00:14,580 --> 00:00:27,450
hello ok I'm back now with a 360 hat on

00:00:24,400 --> 00:00:31,470
and what I'm going to talk about here is

00:00:27,450 --> 00:00:36,840
he's an application that we put together

00:00:31,470 --> 00:00:39,970
over the past two years and it's

00:00:36,840 --> 00:00:44,890
basically a high great heterogeneous

00:00:39,970 --> 00:00:47,050
behave concentrates at work before I do

00:00:44,890 --> 00:00:50,830
I want to provide a little bit of

00:00:47,050 --> 00:00:53,110
background to what a 360 is doing and

00:00:50,830 --> 00:00:57,490
why this is relevant to us so some of

00:00:53,110 --> 00:00:59,920
you may be familiar with 360 it's all

00:00:57,490 --> 00:01:04,390
said company who's watching a

00:00:59,920 --> 00:01:10,390
constellation of small satellites we are

00:01:04,390 --> 00:01:13,119
flying in a cluster with they receive

00:01:10,390 --> 00:01:15,899
data from received RF data

00:01:13,119 --> 00:01:19,200
it's basically flying suffered by radio

00:01:15,899 --> 00:01:23,470
from space they receive data from

00:01:19,200 --> 00:01:26,950
emitters on the ground and we make t do

00:01:23,470 --> 00:01:28,900
it the way that the receive signals on a

00:01:26,950 --> 00:01:36,270
platform and then we turn this into a

00:01:28,900 --> 00:01:41,520
few locations so we find data source for

00:01:36,270 --> 00:01:44,440
RF do location and analytics and the

00:01:41,520 --> 00:01:46,450
technical problems we solve are pretty

00:01:44,440 --> 00:01:49,030
similar to everything that we're talking

00:01:46,450 --> 00:01:54,690
about through this week one of the big

00:01:49,030 --> 00:01:56,670
ones is how do we capture data with

00:01:54,690 --> 00:01:58,979
small

00:01:56,670 --> 00:02:00,510
and that's really the word for us

00:01:58,979 --> 00:02:03,390
because the power that's available to

00:02:00,510 --> 00:02:07,950
our so my credo is about five watts

00:02:03,390 --> 00:02:18,360
what we launched this year so a small it

00:02:07,950 --> 00:02:22,370
needs to assume well to power and so

00:02:18,360 --> 00:02:22,370
this is just a quick room

00:02:22,550 --> 00:02:32,130
we're gonna specifically focus on the

00:02:27,410 --> 00:02:35,730
transport and DMA because technically

00:02:32,130 --> 00:02:41,780
what we basically decide is a platform

00:02:35,730 --> 00:02:41,780
that uses UHD are not radio and and it's

00:02:42,110 --> 00:02:55,860
ten doesn't receive 15 acres of data

00:02:48,470 --> 00:02:57,600
work well for us I was very excited to

00:02:55,860 --> 00:03:05,010
see the previous talk about the

00:02:57,600 --> 00:03:08,269
visionary is a heterogeneous in practice

00:03:05,010 --> 00:03:12,299
we've got to make something that works

00:03:08,269 --> 00:03:13,650
today so we have to have something that

00:03:12,299 --> 00:03:16,620
works so what I'm going to do here is

00:03:13,650 --> 00:03:22,049
talk about the first principles of what

00:03:16,620 --> 00:03:34,549
the problem is we talked about the

00:03:22,049 --> 00:03:38,940
solution just access space alright so

00:03:34,549 --> 00:03:40,920
we've got a low power device we can't do

00:03:38,940 --> 00:03:42,329
everything in the processor like - we

00:03:40,920 --> 00:03:44,070
have five watts of data

00:03:42,329 --> 00:03:46,110
all right five watts of power available

00:03:44,070 --> 00:03:47,269
and that's about enough for zinc

00:03:46,110 --> 00:03:52,230
system-on-chip

00:03:47,269 --> 00:03:53,280
plus a 361 we don't have a big processor

00:03:52,230 --> 00:03:55,410
that we can use

00:03:53,280 --> 00:03:58,200
we can't throw 50 you hundreds of

00:03:55,410 --> 00:03:59,819
problem and beakers and

00:03:58,200 --> 00:04:01,349
and be happy with that we have to be

00:03:59,819 --> 00:04:03,120
more efficient without the community

00:04:01,349 --> 00:04:04,890
power that we have but that means that

00:04:03,120 --> 00:04:06,300
we have to transfer data between the

00:04:04,890 --> 00:04:09,660
processor and some other computer

00:04:06,300 --> 00:04:11,400
architecture in this case EGA but in

00:04:09,660 --> 00:04:13,550
many cases this data transfer becomes

00:04:11,400 --> 00:04:17,760
the bottleneck so there's just a couple

00:04:13,550 --> 00:04:21,840
a couple examples here

00:04:17,760 --> 00:04:26,160
GPUs I got the USF one instances or

00:04:21,840 --> 00:04:28,290
tablet a big FPGA situated next to a

00:04:26,160 --> 00:04:37,050
processor a PCIe and even a pretty cool

00:04:28,290 --> 00:04:38,250
example of to your face and there's and

00:04:37,050 --> 00:04:41,370
if you want to do it through some

00:04:38,250 --> 00:04:43,169
purified radio with low power low swap

00:04:41,370 --> 00:04:52,950
got some good options

00:04:43,169 --> 00:04:56,070
you've got the tens ink on it here's as

00:04:52,950 --> 00:05:00,840
an ulterior version and since we're

00:04:56,070 --> 00:05:06,750
pulling an emergency but it's also

00:05:00,840 --> 00:05:10,380
similar to court examples let's just

00:05:06,750 --> 00:05:12,840
characterize what pretend gets as far as

00:05:10,380 --> 00:05:15,030
just just trying to take data from the

00:05:12,840 --> 00:05:17,789
straight off for the 1936 and one and

00:05:15,030 --> 00:05:21,690
save it to disk and if you just transfer

00:05:17,789 --> 00:05:25,320
data from from the GA to the processor

00:05:21,690 --> 00:05:27,330
and with like a benchmark US benchmark

00:05:25,320 --> 00:05:31,050
great application or you put it into

00:05:27,330 --> 00:05:33,690
radio adult sync so shouldn't be doing

00:05:31,050 --> 00:05:35,760
any file i/o the shorter side I was able

00:05:33,690 --> 00:05:41,669
to get about ten megahertz receive only

00:05:35,760 --> 00:05:43,110
without there's definitely limits the

00:05:41,669 --> 00:05:44,940
processor but if you were trying to

00:05:43,110 --> 00:05:47,669
great to file the psych decline was

00:05:44,940 --> 00:05:48,930
about one megahertz on a good day this

00:05:47,669 --> 00:05:54,080
is where I was testing through thirty

00:05:48,930 --> 00:05:59,340
seconds at a time and stories so

00:05:54,080 --> 00:06:00,750
particularly here is that you know in an

00:05:59,340 --> 00:06:02,280
ideal world like the previous

00:06:00,750 --> 00:06:04,800
presentation we have something that does

00:06:02,280 --> 00:06:07,950
this for us but often times we'll find

00:06:04,800 --> 00:06:08,670
that thing we're doing it those limits

00:06:07,950 --> 00:06:11,040
so

00:06:08,670 --> 00:06:11,880
let's talk about I didn't know we can

00:06:11,040 --> 00:06:16,440
fix it

00:06:11,880 --> 00:06:17,820
and the solution which which is what all

00:06:16,440 --> 00:06:21,090
these devices Friday it was a direct

00:06:17,820 --> 00:06:22,590
memory access DMA transfer and the

00:06:21,090 --> 00:06:24,720
concept of this is that the processor

00:06:22,590 --> 00:06:32,760
you can't really service the entire them

00:06:24,720 --> 00:06:35,580
copy itself hundred six hundred pending

00:06:32,760 --> 00:06:36,810
on what are you have and you will you

00:06:35,580 --> 00:06:39,090
just can't transfer that amount of data

00:06:36,810 --> 00:06:40,800
and do other irrelevant stuff so the

00:06:39,090 --> 00:06:42,270
idea is that you have some hardware

00:06:40,800 --> 00:06:44,910
feature that's able to perform the copy

00:06:42,270 --> 00:06:50,700
he synchronously and without processor

00:06:44,910 --> 00:06:53,280
involvement how can well what what are

00:06:50,700 --> 00:06:55,310
the hardware architectures that do dmas

00:06:53,280 --> 00:06:57,780
first the first one to talk about is uh

00:06:55,310 --> 00:07:01,860
is what's called the scanner to gather

00:06:57,780 --> 00:07:04,700
DMA and yeah here is that the hardware

00:07:01,860 --> 00:07:08,070
that you're using is able to look at

00:07:04,700 --> 00:07:10,260
memory pointers figure all this at a

00:07:08,070 --> 00:07:12,150
time and then the hardware that smoothly

00:07:10,260 --> 00:07:16,260
transferred changed together multiple

00:07:12,150 --> 00:07:18,930
DMA requests so transfer data and then

00:07:16,260 --> 00:07:20,910
it will receive read addresses per the

00:07:18,930 --> 00:07:22,770
next racer and then it'll go ahead and

00:07:20,910 --> 00:07:25,350
do that to the processor you can set up

00:07:22,770 --> 00:07:27,390
a bunch of traitors at once in that yeah

00:07:25,350 --> 00:07:31,260
or the upper greater with River maybe

00:07:27,390 --> 00:07:33,990
they would go ahead and execute this has

00:07:31,260 --> 00:07:40,170
least amount of yes a proxy across the

00:07:33,990 --> 00:07:41,850
system interaction the other version we

00:07:40,170 --> 00:07:44,550
could do is something that's called a

00:07:41,850 --> 00:07:47,990
direct register business this is kind of

00:07:44,550 --> 00:07:51,120
like I call it a non scattered either so

00:07:47,990 --> 00:07:54,060
if you put the processor in the loop for

00:07:51,120 --> 00:07:57,540
every upper transfer and the processor

00:07:54,060 --> 00:08:00,420
will rate the sort of the source

00:07:57,540 --> 00:08:01,770
destination greatly the sorry source

00:08:00,420 --> 00:08:03,510
address right the destination address

00:08:01,770 --> 00:08:05,940
then the hardware isn't doesn't that

00:08:03,510 --> 00:08:08,820
sends interrupts that says I'm done in

00:08:05,940 --> 00:08:13,380
the processor you go handle that and so

00:08:08,820 --> 00:08:15,090
the next one so it's it requires a

00:08:13,380 --> 00:08:19,970
little bit more closer there actually

00:08:15,090 --> 00:08:19,970
but it's a little bit easier to set up

00:08:23,450 --> 00:08:28,800
specifically on the zinc question

00:08:25,800 --> 00:08:31,170
becomes what is the theoretical limit

00:08:28,800 --> 00:08:35,310
and how do you do it so how do you do it

00:08:31,170 --> 00:08:37,979
the FPGA fabric you allocate where I

00:08:35,310 --> 00:08:42,240
work and this is similar to doll Tara

00:08:37,979 --> 00:08:46,830
and I were is able to access memory

00:08:42,240 --> 00:08:53,820
transfer across bars on the zinc

00:08:46,830 --> 00:08:55,830
hardware and you can radiate it and zinc

00:08:53,820 --> 00:08:58,980
the annual and you see that were the

00:08:55,830 --> 00:09:01,650
high performance actually bus you could

00:08:58,980 --> 00:09:04,320
get up to twelve hundred megabytes per

00:09:01,650 --> 00:09:06,540
second and that's that's pretty high

00:09:04,320 --> 00:09:08,100
it's you're never actually going to get

00:09:06,540 --> 00:09:12,650
there because there's overhead

00:09:08,100 --> 00:09:19,140
associated transfer yeah packetize the

00:09:12,650 --> 00:09:20,400
packets that go on to this point there

00:09:19,140 --> 00:09:22,800
and on top of that you also need to

00:09:20,400 --> 00:09:25,350
share the the controllers with other

00:09:22,800 --> 00:09:27,210
things so if you have a that's accessing

00:09:25,350 --> 00:09:30,660
that and something else then actually

00:09:27,210 --> 00:09:33,300
has so so there's a lot of reasons where

00:09:30,660 --> 00:09:35,810
you won't get the full bandwidth but but

00:09:33,300 --> 00:09:38,130
ideally you could get pretty clicks and

00:09:35,810 --> 00:09:42,150
you know ten to ten mega samples per

00:09:38,130 --> 00:09:44,760
second you know you leave that you sit

00:09:42,150 --> 00:09:46,710
through two four bytes for example and

00:09:44,760 --> 00:09:55,940
it's only forty megabytes per second and

00:09:46,710 --> 00:10:04,820
it's not quite here also on the zinc and

00:09:55,940 --> 00:10:04,820
further FPGA based concepts you'll see

00:10:05,510 --> 00:10:10,170
possible channels where you go the

00:10:08,220 --> 00:10:12,990
terminology is a memory mapped to stream

00:10:10,170 --> 00:10:15,120
and so that's that six that's a DMA that

00:10:12,990 --> 00:10:17,100
reads from the memory and they're burned

00:10:15,120 --> 00:10:18,600
out and then it becomes a string so this

00:10:17,100 --> 00:10:21,300
is like the X extreme they're basically

00:10:18,600 --> 00:10:23,430
CWPP a and you can read out the samples

00:10:21,300 --> 00:10:25,230
and then the vice versa is being

00:10:23,430 --> 00:10:27,390
stubborn ass it's like try to read stuff

00:10:25,230 --> 00:10:28,890
off that your 61 this is thing I'm most

00:10:27,390 --> 00:10:30,720
interested in which is taking samples

00:10:28,890 --> 00:10:32,950
from between the interface and putting

00:10:30,720 --> 00:10:34,090
in the ferry and

00:10:32,950 --> 00:10:35,620
and then when the processor is

00:10:34,090 --> 00:10:45,880
interacting with that use accent or

00:10:35,620 --> 00:10:47,620
light their face which basically when

00:10:45,880 --> 00:10:52,120
you're doing the software how do you

00:10:47,620 --> 00:10:55,150
great the software the on the left is

00:10:52,120 --> 00:10:59,680
that polygons grits is probably an easy

00:10:55,150 --> 00:11:01,600
easier way to do it you can run the

00:10:59,680 --> 00:11:03,280
processor in a tight loop and respond

00:11:01,600 --> 00:11:05,320
quickly from DMA so if you look at the

00:11:03,280 --> 00:11:06,700
tutorials of how to actually do DMA or

00:11:05,320 --> 00:11:08,320
your active I think we will see

00:11:06,700 --> 00:11:10,690
something like this it's written in

00:11:08,320 --> 00:11:12,670
userspace you little semesters and you

00:11:10,690 --> 00:11:15,460
do copy it goes from one place to

00:11:12,670 --> 00:11:24,310
another really actually pretty easy you

00:11:15,460 --> 00:11:26,340
get that running in the other software

00:11:24,310 --> 00:11:30,640
option is using an arab driver and

00:11:26,340 --> 00:11:33,670
ultimately DMA software is gonna use a

00:11:30,640 --> 00:11:35,830
kernel driver because you have to be

00:11:33,670 --> 00:11:40,140
able to service the request which is not

00:11:35,830 --> 00:11:45,820
something you can do it's more difficult

00:11:40,140 --> 00:11:48,070
but it fits inside overlapping Venn

00:11:45,820 --> 00:11:52,600
diagrams that Robin showed earlier so

00:11:48,070 --> 00:11:55,360
that I got to do it okay

00:11:52,600 --> 00:11:59,500
what did we specifically do for our

00:11:55,360 --> 00:12:01,450
spacecraft sticking with the uhd in

00:11:59,500 --> 00:12:03,730
arcmap architecture he did some major

00:12:01,450 --> 00:12:05,320
surgery this is a quick overview so we

00:12:03,730 --> 00:12:09,520
made a new art not clock that

00:12:05,320 --> 00:12:12,190
essentially pulls data off of the off of

00:12:09,520 --> 00:12:16,120
the XE grabber and the knock shell and

00:12:12,190 --> 00:12:20,410
feeds it into silence a key for it does

00:12:16,120 --> 00:12:22,210
the amazed scream extroverted kernel

00:12:20,410 --> 00:12:26,710
driver in order to service these that

00:12:22,210 --> 00:12:29,350
are else after that we have the USB bot

00:12:26,710 --> 00:12:34,390
controller that is able to register

00:12:29,350 --> 00:12:35,740
reads and writes all right and and then

00:12:34,390 --> 00:12:38,470
in radio world

00:12:35,740 --> 00:12:42,130
we override the general work function as

00:12:38,470 --> 00:12:43,580
everything else and the samples into the

00:12:42,130 --> 00:12:47,420
radio and just views

00:12:43,580 --> 00:12:48,980
I'll say operation the Chakiris MA that

00:12:47,420 --> 00:12:53,510
we put together use this larger packet

00:12:48,980 --> 00:12:57,680
sent a little bit more later this is

00:12:53,510 --> 00:12:59,990
just illustrating the architecture as

00:12:57,680 --> 00:13:03,680
disgusting so we have in the art not

00:12:59,990 --> 00:13:05,990
block is the black shell exit wrapper

00:13:03,680 --> 00:13:07,940
and then we add some extra IO it goes

00:13:05,990 --> 00:13:10,850
out and it goes to the next PMA ID

00:13:07,940 --> 00:13:13,490
before when you're using these I likes

00:13:10,850 --> 00:13:17,870
an IP you've got an option for a dative

00:13:13,490 --> 00:13:21,220
River which provides the core and that

00:13:17,870 --> 00:13:25,070
was a little bit difficult museum

00:13:21,220 --> 00:13:26,990
protocol and the XE d ma that's adds

00:13:25,070 --> 00:13:29,810
more logic to be able to do the scatter

00:13:26,990 --> 00:13:36,410
gather or direct register operation

00:13:29,810 --> 00:13:38,270
goods we're out okay moving up the stack

00:13:36,410 --> 00:13:39,230
we talked about it ETA now let's talk

00:13:38,270 --> 00:13:41,960
about her driver

00:13:39,230 --> 00:13:46,220
we started off trying to work with the

00:13:41,960 --> 00:13:48,260
Xilinx execute a Linux driver there's a

00:13:46,220 --> 00:13:50,660
long story with that one I won't go

00:13:48,260 --> 00:13:52,820
through these to a point but at the end

00:13:50,660 --> 00:13:56,690
of the day for that we're able to get it

00:13:52,820 --> 00:13:58,959
to work in any reliable way even try it

00:13:56,690 --> 00:14:04,400
adding up streaming patches for this and

00:13:58,959 --> 00:14:06,890
it was still unreliable lockup and so so

00:14:04,400 --> 00:14:08,990
now maybe you know 2019 maybe it's

00:14:06,890 --> 00:14:14,270
better but we haven't actually returned

00:14:08,990 --> 00:14:18,470
to that one another other option and

00:14:14,270 --> 00:14:20,510
that's really tight so well I won't

00:14:18,470 --> 00:14:23,270
promote speaker by a lot of devices

00:14:20,510 --> 00:14:26,209
people but I'm also excited to learn

00:14:23,270 --> 00:14:28,700
more about that we wanted something a

00:14:26,209 --> 00:14:31,490
little bit more basic and specific to

00:14:28,700 --> 00:14:38,110
our specific needs so I will add this

00:14:31,490 --> 00:14:38,110
fun comic here now there are 15

00:14:38,830 --> 00:14:44,830
all right so so what did we do

00:14:42,130 --> 00:14:48,640
basically the simplest curl driver you

00:14:44,830 --> 00:14:51,880
can you can can ask for service and

00:14:48,640 --> 00:14:53,830
request when it's what's available

00:14:51,880 --> 00:14:57,399
we've also reallocated the marriage so

00:14:53,830 --> 00:15:03,850
also probably this earlier in the pluto

00:14:57,399 --> 00:15:05,110
has about thirty eight something similar

00:15:03,850 --> 00:15:08,680
peer reviews a hundred sixteen megabytes

00:15:05,110 --> 00:15:11,230
we can get one second 40 megahertz data

00:15:08,680 --> 00:15:12,940
buffered up in RAM so with three

00:15:11,230 --> 00:15:16,110
allocated memory buffers and then we

00:15:12,940 --> 00:15:21,130
have programmer that swaps out the

00:15:16,110 --> 00:15:23,709
buffers man this is uses interrupts and

00:15:21,130 --> 00:15:26,800
it does use direct register vote as as

00:15:23,709 --> 00:15:28,269
the quickest path to success but trick

00:15:26,800 --> 00:15:30,910
here is that we're using good large

00:15:28,269 --> 00:15:34,420
buffers we have 160 megabytes of grand

00:15:30,910 --> 00:15:36,850
and then we transfer over 28 bytes which

00:15:34,420 --> 00:15:38,079
if you're running a little late it's

00:15:36,850 --> 00:15:39,430
gonna have a lot of latency but if

00:15:38,079 --> 00:15:40,839
you're running at a high rate you're

00:15:39,430 --> 00:15:42,610
going to accrue some of the processor

00:15:40,839 --> 00:15:50,620
would so this is pretty much the real

00:15:42,610 --> 00:15:52,839
jerk okay let's go up the stack a little

00:15:50,620 --> 00:15:55,029
bit more next you have user space

00:15:52,839 --> 00:15:56,890
software so when you're routing users

00:15:55,029 --> 00:15:58,089
based software in the Linux world and

00:15:56,890 --> 00:16:03,279
you want to interact with the total

00:15:58,089 --> 00:16:09,240
battery use and the trick here I mean

00:16:03,279 --> 00:16:13,839
you definitely want to use them and then

00:16:09,240 --> 00:16:22,300
it's done so from the DNA the girl says

00:16:13,839 --> 00:16:25,300
it's ready so how exactly does this look

00:16:22,300 --> 00:16:28,750
UHD our plot controller that interacts

00:16:25,300 --> 00:16:31,120
the user space with the custom driver

00:16:28,750 --> 00:16:33,310
and then on top of that we have a new

00:16:31,120 --> 00:16:38,110
radio that perhaps the block controller

00:16:33,310 --> 00:16:40,500
is able to stuff in the radio and that

00:16:38,110 --> 00:16:44,199
leads me directly to this slide one

00:16:40,500 --> 00:16:49,449
additional level higher which is is how

00:16:44,199 --> 00:16:51,370
we do radio with this and I mean it's

00:16:49,449 --> 00:16:53,350
pretty straight word

00:16:51,370 --> 00:16:55,120
near ad escape group called scheduler

00:16:53,350 --> 00:16:57,730
cause we're function s or so amount of

00:16:55,120 --> 00:17:03,580
samples we fill the top of buffer with

00:16:57,730 --> 00:17:06,220
samples and save the recipe and people

00:17:03,580 --> 00:17:07,810
cool here is just we definitely we just

00:17:06,220 --> 00:17:09,699
want to record as much as we can

00:17:07,810 --> 00:17:11,709
straight interview new video for our

00:17:09,699 --> 00:17:14,829
particular application we didn't care

00:17:11,709 --> 00:17:18,459
too much about latency so so so it makes

00:17:14,829 --> 00:17:31,930
these large buffers feasible we only did

00:17:18,459 --> 00:17:34,450
one channel so we could do other better

00:17:31,930 --> 00:17:37,390
ways to transfer data to from the new

00:17:34,450 --> 00:17:39,130
radio besides creating a new block that

00:17:37,390 --> 00:17:42,100
has a general work function that

00:17:39,130 --> 00:17:45,100
interacts with your heterogeneous

00:17:42,100 --> 00:17:46,840
software that's what we've done here

00:17:45,100 --> 00:17:49,030
that's what we've seen in most other

00:17:46,840 --> 00:17:56,890
these cases but I think it's an

00:17:49,030 --> 00:17:59,230
interesting part going forward alright

00:17:56,890 --> 00:18:02,560
so that was pretty much a full stack I

00:17:59,230 --> 00:18:04,870
want to add another twist so recently in

00:18:02,560 --> 00:18:08,290
the last couple months we've found that

00:18:04,870 --> 00:18:11,200
we have a lot of small packets that we

00:18:08,290 --> 00:18:13,330
need to be able to work and so our use

00:18:11,200 --> 00:18:15,700
case turns from one where we had

00:18:13,330 --> 00:18:17,110
continuous streaming data and we wanted

00:18:15,700 --> 00:18:19,810
to write that into periods and whenever

00:18:17,110 --> 00:18:23,830
we had lots of small packets probably

00:18:19,810 --> 00:18:29,700
256 bytes or so and and each of those is

00:18:23,830 --> 00:18:29,700
self contained some number of samples so

00:18:30,600 --> 00:18:37,380
based on the hold your the stream here

00:18:33,640 --> 00:18:40,630
architecture we cut it off what we saw

00:18:37,380 --> 00:18:43,960
and where we needed to rid of timestamp

00:18:40,630 --> 00:18:46,810
differently but we did here was we

00:18:43,960 --> 00:18:50,350
reworked some of the BGA that just

00:18:46,810 --> 00:18:52,240
coalesce these packets and so you can

00:18:50,350 --> 00:18:54,100
see the diagram of the RF nut block

00:18:52,240 --> 00:18:56,530
which used to have an option and an exit

00:18:54,100 --> 00:18:59,620
grappler that pulls the information off

00:18:56,530 --> 00:19:00,930
of that we actually are just kind of

00:18:59,620 --> 00:19:03,240
exit out the hexagram

00:19:00,930 --> 00:19:06,920
so straight from the shell and we take

00:19:03,240 --> 00:19:10,110
the entire packet and pushing a oxy of a

00:19:06,920 --> 00:19:12,720
yak cdma IV port and then that goes into

00:19:10,110 --> 00:19:15,660
Peoria and then on the radio side we

00:19:12,720 --> 00:19:18,210
could look at the packets use the UHD

00:19:15,660 --> 00:19:20,940
checker parsing pull out the packet

00:19:18,210 --> 00:19:24,030
information and then either convert the

00:19:20,940 --> 00:19:27,620
news or just dump the data yes and that

00:19:24,030 --> 00:19:31,050
puts a skip in order of magnitude larger

00:19:27,620 --> 00:19:33,720
more for small packets and we work and

00:19:31,050 --> 00:19:37,050
we could even add some extra flexibility

00:19:33,720 --> 00:19:38,970
here so one of the channels is blocking

00:19:37,050 --> 00:19:48,600
that for your software we could do that

00:19:38,970 --> 00:19:51,750
and what are the results here so there's

00:19:48,600 --> 00:19:55,490
no PS load max continuous receive great

00:19:51,750 --> 00:19:58,680
without ever flows it can't go higher we

00:19:55,490 --> 00:20:02,520
tested 240 because it's it's convenient

00:19:58,680 --> 00:20:05,300
and nice around the earth now if you're

00:20:02,520 --> 00:20:07,890
ready to file though there's there's a

00:20:05,300 --> 00:20:12,330
hitch when you're ready to file and that

00:20:07,890 --> 00:20:15,770
is that actually doing the file i/o

00:20:12,330 --> 00:20:18,420
takes nasir about our cosmic time and

00:20:15,770 --> 00:20:20,610
your kernel drivers trying to service

00:20:18,420 --> 00:20:24,720
the DMA interrupts also try to service

00:20:20,610 --> 00:20:27,390
the IO to write to the SD card then they

00:20:24,720 --> 00:20:28,740
kind of fight with each other and and we

00:20:27,390 --> 00:20:30,510
top out around for my career it's

00:20:28,740 --> 00:20:31,560
continuous which is partly driven by the

00:20:30,510 --> 00:20:33,660
i/o

00:20:31,560 --> 00:20:35,250
fight and it's also actually partly

00:20:33,660 --> 00:20:37,440
driven by the max data rate that you can

00:20:35,250 --> 00:20:39,360
prank actually two days carts at some

00:20:37,440 --> 00:20:41,670
point on likely through 10 for example

00:20:39,360 --> 00:20:45,360
where the SD card only supports a few 20

00:20:41,670 --> 00:20:46,590
to 30 megabytes per second and you're

00:20:45,360 --> 00:20:47,790
not you're not gonna be able to sustain

00:20:46,590 --> 00:20:49,950
any higher than that

00:20:47,790 --> 00:20:51,270
so the other thing we did is is turn

00:20:49,950 --> 00:20:52,920
this into the first didn't we're seeing

00:20:51,270 --> 00:20:56,040
great where we collect a contiguous

00:20:52,920 --> 00:20:58,070
chunk of data put that into the ramp and

00:20:56,040 --> 00:21:00,020
then break data from the RAM

00:20:58,070 --> 00:21:10,460
the our dryer burn off that data and

00:21:00,020 --> 00:21:12,350
that could also break we have a alright

00:21:10,460 --> 00:21:17,330
but what are the really trade off set

00:21:12,350 --> 00:21:19,610
that we make here principal basis so arm

00:21:17,330 --> 00:21:21,860
knock you've got a small teammate other

00:21:19,610 --> 00:21:24,050
just gives you lower latency that's a

00:21:21,860 --> 00:21:25,760
good thing it increases your flexibility

00:21:24,050 --> 00:21:28,190
it allows you to route packets to

00:21:25,760 --> 00:21:29,870
different parts of your cross guard if

00:21:28,190 --> 00:21:33,260
you're trying to use multiple blocks of

00:21:29,870 --> 00:21:37,900
the cross part you're trying to actually

00:21:33,260 --> 00:21:43,490
use the FPGAs berger software-defined

00:21:37,900 --> 00:21:45,620
low ground but on the other hand having

00:21:43,490 --> 00:21:48,620
smaller packets increases the required

00:21:45,620 --> 00:21:51,230
processor load and at least with a harm

00:21:48,620 --> 00:21:53,990
you can't support as much as hear

00:21:51,230 --> 00:21:58,580
anything could ya buffers for our

00:21:53,990 --> 00:22:02,810
application we want to be able to record

00:21:58,580 --> 00:22:05,510
the full rate and so we larger buffers

00:22:02,810 --> 00:22:07,970
we don't we don't use the scanner gather

00:22:05,510 --> 00:22:11,180
we just use the direct register hood for

00:22:07,970 --> 00:22:16,480
simplicity and and we work up to the

00:22:11,180 --> 00:22:18,500
pool and so the key point here is it I

00:22:16,480 --> 00:22:21,020
think this is a good takeaway point

00:22:18,500 --> 00:22:24,080
actually which is that he hesitate to

00:22:21,020 --> 00:22:26,390
say a better adverse result because they

00:22:24,080 --> 00:22:29,180
both have their place so let's consider

00:22:26,390 --> 00:22:31,370
the actual implementation when we do it

00:22:29,180 --> 00:22:38,270
versus the goals of your application

00:22:31,370 --> 00:22:41,230
when we're creating this layer this I

00:22:38,270 --> 00:22:44,030
hope that right enough of course here

00:22:41,230 --> 00:22:46,220
for you to address these issues or at

00:22:44,030 --> 00:22:47,920
least understand what some of these

00:22:46,220 --> 00:22:54,140
things that are doing behind the scenes

00:22:47,920 --> 00:22:57,440
if they are and I also want to emphasize

00:22:54,140 --> 00:22:58,760
the poor a clear genius transfers in

00:22:57,440 --> 00:23:02,690
turn out of

00:22:58,760 --> 00:23:05,650
our Hospital on meditates and I hope

00:23:02,690 --> 00:23:05,650
this to inspire

00:23:09,740 --> 00:23:13,019

YouTube URL: https://www.youtube.com/watch?v=Y8QQ0sh5IhI


