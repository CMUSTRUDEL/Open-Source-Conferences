Title: Mountain West JavaScript 2014 - Be Predictable, Not Correct. by Pete Hunt
Publication date: 2020-01-24
Playlist: MountainWest JavaScript 2014
Description: 
	Functional programming is a great way of managing complexity in user interfaces. User interfaces are very difficult to build due to the difficulty in determining if they're "correct" or not. In this talk I'll go into some ways that functional programming techniques like referential transparency and immutability can lead to easier-to-build user interfaces.

Help us caption & translate this video!

http://amara.org/v/FG3B/
Captions: 
	00:00:24,779 --> 00:00:33,780
hey everybody I'm Pete so who's excited

00:00:30,340 --> 00:00:35,980
for some big o-notation in the morning

00:00:33,780 --> 00:00:39,640
alright alright so we're gonna get to

00:00:35,980 --> 00:00:42,699
that but before we we do I'm just gonna

00:00:39,640 --> 00:00:44,350
say I'm I'm Pete I I work at Facebook on

00:00:42,699 --> 00:00:46,150
the Instagram team and I'm I'm a

00:00:44,350 --> 00:00:48,879
contributor to a library called react

00:00:46,150 --> 00:00:50,530
which you may have heard is the one that

00:00:48,879 --> 00:00:54,010
puts the angle brackets and your

00:00:50,530 --> 00:00:56,199
JavaScript but I'm not going to really

00:00:54,010 --> 00:00:58,750
talk too much about react and why it why

00:00:56,199 --> 00:01:00,159
it's so awesome because that doesn't

00:00:58,750 --> 00:01:01,629
that's not the interesting part what I

00:01:00,159 --> 00:01:03,460
want to talk about is the ideas behind

00:01:01,629 --> 00:01:05,560
react and react is the reference

00:01:03,460 --> 00:01:09,640
reference implementation of those ideas

00:01:05,560 --> 00:01:12,190
so this isn't a tutorial and we're going

00:01:09,640 --> 00:01:13,900
to focus on ideas not implementations so

00:01:12,190 --> 00:01:15,220
I'm gonna talk about some of the ideas

00:01:13,900 --> 00:01:17,680
behind react some of the ideas behind

00:01:15,220 --> 00:01:19,270
other systems how they're how they're

00:01:17,680 --> 00:01:20,920
different kind of what the different

00:01:19,270 --> 00:01:23,080
trade-offs are and there are different

00:01:20,920 --> 00:01:24,640
trade-offs between them and hopefully

00:01:23,080 --> 00:01:27,280
you can take some of the ideas and bring

00:01:24,640 --> 00:01:28,570
them to your favorite system or maybe

00:01:27,280 --> 00:01:32,050
you think that react is cool and you

00:01:28,570 --> 00:01:34,720
contribute to it but let's talk about

00:01:32,050 --> 00:01:37,990
what makes user interfaces difficult to

00:01:34,720 --> 00:01:41,290
build so has anybody here built a user

00:01:37,990 --> 00:01:45,670
interface before all right okay okay I

00:01:41,290 --> 00:01:47,530
figured was it really easy yeah testing

00:01:45,670 --> 00:01:49,810
it was super easy maintaining quality

00:01:47,530 --> 00:01:52,720
was probably a joke right it just kind

00:01:49,810 --> 00:01:55,900
of always worked he said sarcastically

00:01:52,720 --> 00:01:58,720
but you get this a lot it just doesn't

00:01:55,900 --> 00:02:00,159
feel right so you know even if you use

00:01:58,720 --> 00:02:02,050
all the test-driven development that you

00:02:00,159 --> 00:02:03,700
that you can throw at it you still have

00:02:02,050 --> 00:02:04,840
to have a human look at this and be like

00:02:03,700 --> 00:02:06,400
you know this doesn't look right or this

00:02:04,840 --> 00:02:07,479
doesn't feel right or when I click this

00:02:06,400 --> 00:02:11,980
button then I click this button then I

00:02:07,479 --> 00:02:13,989
click this button it breaks so there's a

00:02:11,980 --> 00:02:15,849
lot of things that come into this they

00:02:13,989 --> 00:02:18,190
are human verified but you eyes are also

00:02:15,849 --> 00:02:20,739
deceptively complex we have a bunch of

00:02:18,190 --> 00:02:23,019
designers who focus exclusively on

00:02:20,739 --> 00:02:25,450
making UI seem simple but underlying

00:02:23,019 --> 00:02:28,330
that simplicity is a lot of complexity

00:02:25,450 --> 00:02:32,110
there's a lot of state there and the

00:02:28,330 --> 00:02:33,540
tools that we have today aren't there's

00:02:32,110 --> 00:02:37,540
some pointing over there I don't know

00:02:33,540 --> 00:02:40,150
but there's a lot of you know your

00:02:37,540 --> 00:02:41,920
traditional unit testing for example it

00:02:40,150 --> 00:02:44,170
helps in you eyes but it doesn't really

00:02:41,920 --> 00:02:45,670
you know solve a lot of the problems

00:02:44,170 --> 00:02:47,620
that it does in the backend static

00:02:45,670 --> 00:02:50,140
analysis tools to they are helpful but

00:02:47,620 --> 00:02:52,269
they don't really kind of they don't

00:02:50,140 --> 00:02:54,610
prevent you from or they don't replace

00:02:52,269 --> 00:02:55,930
the human in the loop but at the end of

00:02:54,610 --> 00:02:59,049
the day you eyes have a lot of

00:02:55,930 --> 00:03:01,629
complexity the good news is were

00:02:59,049 --> 00:03:03,430
programmers and our job is to organize

00:03:01,629 --> 00:03:05,230
this complexity Dykstra said the art of

00:03:03,430 --> 00:03:07,390
programming is the art of organizing

00:03:05,230 --> 00:03:09,130
complexity of mastering multitude and

00:03:07,390 --> 00:03:12,010
avoiding its bastard chaos as

00:03:09,130 --> 00:03:13,569
effectively as possible now isn't

00:03:12,010 --> 00:03:17,500
everybody just amped up right now to go

00:03:13,569 --> 00:03:19,930
build some you eyes come on I like to

00:03:17,500 --> 00:03:21,670
focus on being predictable and another

00:03:19,930 --> 00:03:23,950
word for being predictable is to be

00:03:21,670 --> 00:03:25,629
reliable so it's really hard to build

00:03:23,950 --> 00:03:28,720
you eyes I would just prefer if they

00:03:25,629 --> 00:03:30,340
broke the same way every time and if you

00:03:28,720 --> 00:03:32,650
know the same like series of

00:03:30,340 --> 00:03:34,060
interactions that a user does if I do it

00:03:32,650 --> 00:03:35,769
on my workstation in my development

00:03:34,060 --> 00:03:40,510
environment I want it to have the same

00:03:35,769 --> 00:03:44,130
behavior so let's talk about how we we

00:03:40,510 --> 00:03:46,540
make you eyes a little more reliable

00:03:44,130 --> 00:03:49,019
data binding is what we do today does

00:03:46,540 --> 00:03:53,769
anybody here use data binding before

00:03:49,019 --> 00:03:55,690
okay cool so Dykstra is a really smart

00:03:53,769 --> 00:03:58,359
guy and I think he came up with data

00:03:55,690 --> 00:03:59,889
binding back in the 70s and because he

00:03:58,359 --> 00:04:01,870
said we should do our utmost to shorten

00:03:59,889 --> 00:04:04,540
the conceptual gap between the static

00:04:01,870 --> 00:04:05,889
program and the dynamic process to make

00:04:04,540 --> 00:04:09,120
the correspondence between the program

00:04:05,889 --> 00:04:12,459
and the process is trivial as possible

00:04:09,120 --> 00:04:14,260
what does this even mean data money

00:04:12,459 --> 00:04:16,870
makes the UI which is a dynamic process

00:04:14,260 --> 00:04:19,180
look like a static program relative to

00:04:16,870 --> 00:04:20,799
this other dynamic process which is your

00:04:19,180 --> 00:04:23,380
your kind of business logic and your

00:04:20,799 --> 00:04:25,060
your fundamental interactions the TLDR

00:04:23,380 --> 00:04:27,030
here is that it syncs some state in one

00:04:25,060 --> 00:04:29,560
place with the state of your UI

00:04:27,030 --> 00:04:34,180
everybody by that who uses data binding

00:04:29,560 --> 00:04:35,889
seem seems reasonable so the way I look

00:04:34,180 --> 00:04:39,820
at data binding is that it's a polyfill

00:04:35,889 --> 00:04:41,440
for reactive JavaScript in the Dom so if

00:04:39,820 --> 00:04:43,630
we want to sync state between different

00:04:41,440 --> 00:04:44,770
parts of your program one of those

00:04:43,630 --> 00:04:46,960
solutions that is something called

00:04:44,770 --> 00:04:50,050
reactive programming which is basically

00:04:46,960 --> 00:04:51,400
pressing your constraints and then the

00:04:50,050 --> 00:04:53,699
data is always guaranteed to be

00:04:51,400 --> 00:04:57,190
consistent where you expect it to be

00:04:53,699 --> 00:04:59,319
now unfortunately JavaScript isn't

00:04:57,190 --> 00:05:01,690
actually reactive so we have to build an

00:04:59,319 --> 00:05:03,009
abstraction on top of it and because

00:05:01,690 --> 00:05:05,319
this is definitely a non-trivial

00:05:03,009 --> 00:05:07,000
abstraction every data binding technique

00:05:05,319 --> 00:05:08,380
that we have including the virtual Dom

00:05:07,000 --> 00:05:16,660
which is the one that react implements

00:05:08,380 --> 00:05:18,550
is leaky let's talk about simplicity so

00:05:16,660 --> 00:05:20,889
we had a data binding system at Facebook

00:05:18,550 --> 00:05:22,870
a couple of years ago called bolt and we

00:05:20,889 --> 00:05:24,639
used the traditional kind of observable

00:05:22,870 --> 00:05:26,349
data binding approach and we found that

00:05:24,639 --> 00:05:27,759
was very difficult for us to understand

00:05:26,349 --> 00:05:30,070
what was happening specifically on our

00:05:27,759 --> 00:05:31,419
ads products so there are maybe two

00:05:30,070 --> 00:05:33,280
people at the company that if they got

00:05:31,419 --> 00:05:34,930
hit by a bus no one would understand

00:05:33,280 --> 00:05:37,870
which order the events would fire in and

00:05:34,930 --> 00:05:39,580
couldn't keep the UI consistent so we

00:05:37,870 --> 00:05:41,020
wanted to find a solution that was

00:05:39,580 --> 00:05:42,909
simpler and easier for people to

00:05:41,020 --> 00:05:45,780
understand what was going to happen that

00:05:42,909 --> 00:05:47,919
is something that was more predictable

00:05:45,780 --> 00:05:49,840
Dykstra man he just has so many great

00:05:47,919 --> 00:05:51,729
quotes simplicity is prerequisite for

00:05:49,840 --> 00:05:54,550
reliability so if we want to make this

00:05:51,729 --> 00:05:58,630
this reliable user interface we need to

00:05:54,550 --> 00:06:00,310
focus on simplicity now simplicity is

00:05:58,630 --> 00:06:02,320
one of these loaded terms that everybody

00:06:00,310 --> 00:06:04,419
throws around and it feels very

00:06:02,320 --> 00:06:05,830
subjective what's simple than me maybe

00:06:04,419 --> 00:06:09,190
it doesn't seem simple to you or vice

00:06:05,830 --> 00:06:11,740
versa but there's actually an objective

00:06:09,190 --> 00:06:13,479
way to look at it and it's the the one

00:06:11,740 --> 00:06:14,830
that the definition of simplicity I'm

00:06:13,479 --> 00:06:17,889
gonna be using throughout the rest of

00:06:14,830 --> 00:06:20,590
the talk which is marked by the lack of

00:06:17,889 --> 00:06:22,449
interleaving so rich hippy rich Hickey

00:06:20,590 --> 00:06:24,099
gives a great talk called simple made

00:06:22,449 --> 00:06:27,219
easy he's the guy who invented closure

00:06:24,099 --> 00:06:31,240
and he focuses on a couple aspects of

00:06:27,219 --> 00:06:34,259
simplicity versus easy and simplicity is

00:06:31,240 --> 00:06:36,340
marked by the lack of interleaving and

00:06:34,259 --> 00:06:38,110
what's important about this is that when

00:06:36,340 --> 00:06:39,789
you want to go and solve a problem when

00:06:38,110 --> 00:06:41,710
you're programming you need to basically

00:06:39,789 --> 00:06:43,360
page in all this information into your

00:06:41,710 --> 00:06:45,729
brain and the less stuff you have to

00:06:43,360 --> 00:06:48,009
hold in your brain the easier it is to

00:06:45,729 --> 00:06:50,349
solve a problem so if we try to just

00:06:48,009 --> 00:06:52,240
purge all of the interleaved concepts in

00:06:50,349 --> 00:06:54,400
a given piece of code and and separate

00:06:52,240 --> 00:06:55,750
those out separate those concerns if we

00:06:54,400 --> 00:06:57,610
want to solve a problem with a piece of

00:06:55,750 --> 00:07:01,440
code we don't have to load in all those

00:06:57,610 --> 00:07:01,440
interleaved concerns into our brain

00:07:02,320 --> 00:07:04,880
it's important to keep in mind that

00:07:04,220 --> 00:07:08,270
simple

00:07:04,880 --> 00:07:10,610
is not equal to familiar so as we

00:07:08,270 --> 00:07:12,140
examine some systems you know whether

00:07:10,610 --> 00:07:14,000
you're familiar with it or not let's try

00:07:12,140 --> 00:07:16,520
to look at it in terms of interleaving

00:07:14,000 --> 00:07:18,650
of concerns rather than you know whether

00:07:16,520 --> 00:07:20,260
it looks familiar feels familiar or the

00:07:18,650 --> 00:07:24,530
API it looks good

00:07:20,260 --> 00:07:25,820
so the most popular way that we

00:07:24,530 --> 00:07:27,410
implement data binding today is

00:07:25,820 --> 00:07:30,980
something called key value observation

00:07:27,410 --> 00:07:33,890
and this is pretty much everybody but

00:07:30,980 --> 00:07:36,890
angular and on different platforms as

00:07:33,890 --> 00:07:40,190
well so dotnet implements this core data

00:07:36,890 --> 00:07:41,480
implements this on iOS and it's built

00:07:40,190 --> 00:07:43,160
around the idea of observables and

00:07:41,480 --> 00:07:45,740
computed properties now later today

00:07:43,160 --> 00:07:47,480
there's going to be some talks on rxjs

00:07:45,740 --> 00:07:49,850
and they use observables in a different

00:07:47,480 --> 00:07:52,130
way I'm thinking about this more in

00:07:49,850 --> 00:07:55,010
terms of kind of a knockout or ember

00:07:52,130 --> 00:07:56,570
style observable so let's walk through

00:07:55,010 --> 00:07:59,840
an example of how we would build an

00:07:56,570 --> 00:08:01,669
application let's say we get some some

00:07:59,840 --> 00:08:03,320
JSON from the server and we're gonna

00:08:01,669 --> 00:08:06,229
build like a rotten tomato for

00:08:03,320 --> 00:08:08,120
businesses application so we've got

00:08:06,229 --> 00:08:09,740
titles number of up votes on a number of

00:08:08,120 --> 00:08:11,590
down votes and let's say we have a

00:08:09,740 --> 00:08:14,240
couple hundred items in this array I

00:08:11,590 --> 00:08:16,880
wonder we want to render a UI that looks

00:08:14,240 --> 00:08:21,290
like this and our designers are very

00:08:16,880 --> 00:08:22,850
talented by the way we have the the name

00:08:21,290 --> 00:08:25,280
of the company and then we have the

00:08:22,850 --> 00:08:27,740
percentage of votes that are the that

00:08:25,280 --> 00:08:29,240
are up votes and we sort them by the

00:08:27,740 --> 00:08:30,440
total number of votes not that

00:08:29,240 --> 00:08:32,120
percentage of it but it's the total

00:08:30,440 --> 00:08:33,289
number of votes and we take the top

00:08:32,120 --> 00:08:34,390
three so we're basically showing you

00:08:33,289 --> 00:08:38,890
know here are the three most popular

00:08:34,390 --> 00:08:42,010
companies and here are their ratings so

00:08:38,890 --> 00:08:44,180
again I'm gonna focus on on ideas not

00:08:42,010 --> 00:08:45,890
implementations and so I want to really

00:08:44,180 --> 00:08:48,080
look at at key value observation right

00:08:45,890 --> 00:08:49,700
now and if I want to think about kind of

00:08:48,080 --> 00:08:51,680
the most the premier way to implement

00:08:49,700 --> 00:08:53,330
kvo on the web right now I would say

00:08:51,680 --> 00:08:55,400
it's probably ember this team has

00:08:53,330 --> 00:08:57,200
focused a lot on developer experience

00:08:55,400 --> 00:08:58,220
they've built a lot of applications and

00:08:57,200 --> 00:09:00,410
they're starting to focus a lot on

00:08:58,220 --> 00:09:03,050
performance as well so the way I look at

00:09:00,410 --> 00:09:08,329
it is if if ember can't get kvo

00:09:03,050 --> 00:09:10,999
simple who can so

00:09:08,329 --> 00:09:14,480
this is the template and it's

00:09:10,999 --> 00:09:16,399
implemented in handlebars and we

00:09:14,480 --> 00:09:18,499
basically iterate over every one of the

00:09:16,399 --> 00:09:21,499
top companies and we render a title and

00:09:18,499 --> 00:09:23,689
a score into the Dom now if we want to

00:09:21,499 --> 00:09:25,399
bind anything to the Dom in ember or in

00:09:23,689 --> 00:09:27,619
any of these other sort of traditional

00:09:25,399 --> 00:09:29,239
kv-- of data binding systems we need to

00:09:27,619 --> 00:09:32,059
have some sort of template like thing

00:09:29,239 --> 00:09:34,249
that provides a DSL for gluing some

00:09:32,059 --> 00:09:35,920
observable to a Dom node and that's what

00:09:34,249 --> 00:09:39,199
we're doing here

00:09:35,920 --> 00:09:40,999
so obviously this isn't expressive

00:09:39,199 --> 00:09:42,499
enough to build our entire application

00:09:40,999 --> 00:09:44,749
because we're limited to some primitives

00:09:42,499 --> 00:09:46,249
like each and we don't have kind of the

00:09:44,749 --> 00:09:49,519
complexity will set that javascript

00:09:46,249 --> 00:09:52,999
gives us so we write some code on the

00:09:49,519 --> 00:09:56,149
back end of the front end that that

00:09:52,999 --> 00:09:57,709
implements this functionality so I want

00:09:56,149 --> 00:10:00,290
to compute the total votes of a company

00:09:57,709 --> 00:10:01,699
so I I use the get earnest and or I used

00:10:00,290 --> 00:10:06,619
to get errs to get the up votes and the

00:10:01,699 --> 00:10:09,199
downloads and I sum them then I model

00:10:06,619 --> 00:10:10,699
the company as an ember model and I want

00:10:09,199 --> 00:10:13,279
to compute the score this is called a

00:10:10,699 --> 00:10:15,889
computed property so what this is doing

00:10:13,279 --> 00:10:17,149
is this is taking the percentage of the

00:10:15,889 --> 00:10:19,189
total votes that are upvotes

00:10:17,149 --> 00:10:20,779
and rendering it as a percent so this is

00:10:19,189 --> 00:10:22,970
what the two fixed does and multiplying

00:10:20,779 --> 00:10:25,160
by 100 now it's important to look at

00:10:22,970 --> 00:10:28,429
this dot property syntax what this is

00:10:25,160 --> 00:10:31,040
saying is whenever the uploads are the

00:10:28,429 --> 00:10:32,989
down votes change for a company make

00:10:31,040 --> 00:10:34,879
sure that the score is is automatically

00:10:32,989 --> 00:10:37,579
rear-ended so when we render the score

00:10:34,879 --> 00:10:40,309
into the Dom it will track the changes

00:10:37,579 --> 00:10:41,540
you know if I change an upvote it will

00:10:40,309 --> 00:10:43,009
make sure that that Dom node is kept

00:10:41,540 --> 00:10:45,110
up-to-date because it maintains a

00:10:43,009 --> 00:10:47,869
representation in the somewhere in the

00:10:45,110 --> 00:10:52,369
internals that map's all of that stuff

00:10:47,869 --> 00:10:53,689
together so if you remember in the

00:10:52,369 --> 00:10:55,639
template I edited over something called

00:10:53,689 --> 00:10:57,559
top companies this is another computed

00:10:55,639 --> 00:10:59,899
property where I sort by the total

00:10:57,559 --> 00:11:02,899
number of votes descending slice off the

00:10:59,899 --> 00:11:05,149
top three and whenever the array of

00:11:02,899 --> 00:11:08,839
companies changes we want to update that

00:11:05,149 --> 00:11:11,419
sorting so imagine we have kind of live

00:11:08,839 --> 00:11:13,069
updated uploads here so we might need a

00:11:11,419 --> 00:11:14,329
restart when a new company is added or

00:11:13,069 --> 00:11:16,459
might want to restore it when when

00:11:14,329 --> 00:11:17,869
somebody votes on something so the the

00:11:16,459 --> 00:11:20,199
top view that are shown could change at

00:11:17,869 --> 00:11:20,199
any time

00:11:20,510 --> 00:11:24,200
and the last step is we just glue it

00:11:22,190 --> 00:11:26,210
into our data model so I have this get

00:11:24,200 --> 00:11:28,270
companies Jason function that is

00:11:26,210 --> 00:11:30,500
standing in for that that Jason document

00:11:28,270 --> 00:11:35,500
and that 100 is just the number of

00:11:30,500 --> 00:11:39,020
companies so this code look good

00:11:35,500 --> 00:11:40,130
pretty happy with it I'll take your

00:11:39,020 --> 00:11:42,380
silence to mean let's push it to

00:11:40,130 --> 00:11:44,920
production all right great

00:11:42,380 --> 00:11:48,320
so so here's a video of it in action and

00:11:44,920 --> 00:11:50,420
I'm updating the votes randomly every

00:11:48,320 --> 00:11:52,070
second and because I'm updating the

00:11:50,420 --> 00:11:54,080
number of votes randomly every second

00:11:52,070 --> 00:11:56,120
simulating like WebSocket pushes or

00:11:54,080 --> 00:11:59,540
server refreshes you would think that

00:11:56,120 --> 00:12:02,030
this would be resorted let's run it

00:11:59,540 --> 00:12:04,520
again if I know how to use keynote yeah

00:12:02,030 --> 00:12:06,140
so the top three shouldn't be the top

00:12:04,520 --> 00:12:11,060
three throughout this entire video they

00:12:06,140 --> 00:12:13,180
should be resore time so where's the

00:12:11,060 --> 00:12:16,910
where's the problem

00:12:13,180 --> 00:12:19,490
it's right there so in a KVL based

00:12:16,910 --> 00:12:21,470
system you need to tell the system you

00:12:19,490 --> 00:12:24,290
know update the top companies whenever

00:12:21,470 --> 00:12:25,790
this companies are rate changes now the

00:12:24,290 --> 00:12:27,890
problem is we're not actually observing

00:12:25,790 --> 00:12:29,630
changes of the items within that

00:12:27,890 --> 00:12:32,660
company's array so we have to change

00:12:29,630 --> 00:12:34,970
this to read like this and this is a a

00:12:32,660 --> 00:12:38,960
domain-specific language for for

00:12:34,970 --> 00:12:42,230
specifying observation now the problem

00:12:38,960 --> 00:12:44,810
is going back to reliable reliability

00:12:42,230 --> 00:12:46,970
from simplicity and simplicity is lack

00:12:44,810 --> 00:12:49,670
of interleaving and how much stuff you

00:12:46,970 --> 00:12:51,020
need to hold in your head how am I

00:12:49,670 --> 00:12:53,810
supposed to know that I have to write

00:12:51,020 --> 00:12:55,700
those and in this function because if I

00:12:53,810 --> 00:12:58,010
if I look at top companies I don't see

00:12:55,700 --> 00:13:00,230
those up votes or down votes anywhere I

00:12:58,010 --> 00:13:01,880
have to actually know the implementation

00:13:00,230 --> 00:13:05,770
of total votes and keep that in my head

00:13:01,880 --> 00:13:09,800
as I write my code so when I apply this

00:13:05,770 --> 00:13:13,370
fix-it resource kind of as you would

00:13:09,800 --> 00:13:17,710
expect it to so I get the feeling that

00:13:13,370 --> 00:13:20,600
there are a bunch of ember fans here and

00:13:17,710 --> 00:13:22,730
they probably spotted that bug early and

00:13:20,600 --> 00:13:24,020
they said you know you shouldn't have

00:13:22,730 --> 00:13:25,730
total votes as a function you should

00:13:24,020 --> 00:13:29,350
have it as another computed property and

00:13:25,730 --> 00:13:31,730
they're right but the way I look at it

00:13:29,350 --> 00:13:33,800
this is a problem that we we shouldn't

00:13:31,730 --> 00:13:34,400
have Ember says that you're not allowed

00:13:33,800 --> 00:13:36,200
to use

00:13:34,400 --> 00:13:38,090
gins to compose your programs anymore

00:13:36,200 --> 00:13:39,350
and this isn't a limitation of ember

00:13:38,090 --> 00:13:42,140
this is a limitation of key-value

00:13:39,350 --> 00:13:44,570
observation because the language doesn't

00:13:42,140 --> 00:13:46,250
support true reactive programming and

00:13:44,570 --> 00:13:48,770
this is a leak in that abstraction so

00:13:46,250 --> 00:13:50,690
you have to use units of composition

00:13:48,770 --> 00:13:53,960
that the the observation system gives

00:13:50,690 --> 00:13:56,630
you so there's a lot of criticisms of

00:13:53,960 --> 00:13:57,800
this model and angular tries to solve

00:13:56,630 --> 00:14:01,010
that using something called dirty

00:13:57,800 --> 00:14:03,740
checking so let's build a different

00:14:01,010 --> 00:14:05,570
widget this is a unit that we have on

00:14:03,740 --> 00:14:07,130
Facebook all the time it's a profile

00:14:05,570 --> 00:14:08,600
picture with a user name next to it and

00:14:07,130 --> 00:14:10,640
we want this component to be reusable

00:14:08,600 --> 00:14:14,060
and and live updating if they're wearing

00:14:10,640 --> 00:14:16,940
interesting pieces of data in there so

00:14:14,060 --> 00:14:18,860
um in angular this is kind of an angular

00:14:16,940 --> 00:14:20,330
specific thing a little less related to

00:14:18,860 --> 00:14:22,910
data binding but this is how you would

00:14:20,330 --> 00:14:26,810
specify you know I want to I want to

00:14:22,910 --> 00:14:30,200
render this avatar in my page looks

00:14:26,810 --> 00:14:31,730
pretty good actually let's go through

00:14:30,200 --> 00:14:34,460
the code that we need to write in order

00:14:31,730 --> 00:14:37,160
to to build this so we'll start with a

00:14:34,460 --> 00:14:39,050
little bit of boilerplate I'm kind of

00:14:37,160 --> 00:14:40,570
you know setting up this the scope and

00:14:39,050 --> 00:14:42,800
scope is how you pass data between

00:14:40,570 --> 00:14:44,960
directives and controllers in angular

00:14:42,800 --> 00:14:47,570
and what angular will do is angular will

00:14:44,960 --> 00:14:49,310
we'll watch that scope variable and when

00:14:47,570 --> 00:14:52,400
changes happen on that scope it will

00:14:49,310 --> 00:14:55,490
rerender for you so if I want to build

00:14:52,400 --> 00:14:58,220
my FB avatar directive that I showed you

00:14:55,490 --> 00:14:59,750
in that previous slide I want to

00:14:58,220 --> 00:15:01,700
actually use composition here and I want

00:14:59,750 --> 00:15:03,710
to I might have like a face pile on the

00:15:01,700 --> 00:15:06,020
right hand column of facebook.com/ where

00:15:03,710 --> 00:15:07,490
I only want to show profile pictures so

00:15:06,020 --> 00:15:10,250
I should be able to reuse that component

00:15:07,490 --> 00:15:12,650
in multiple places so I compose the

00:15:10,250 --> 00:15:16,460
Avatar out of you know some HTML and

00:15:12,650 --> 00:15:19,520
this picture component or directive and

00:15:16,460 --> 00:15:20,510
if I want to you know describe that that

00:15:19,520 --> 00:15:21,200
picture directive this is how I

00:15:20,510 --> 00:15:23,510
implement it

00:15:21,200 --> 00:15:25,490
now again you'll notice that because

00:15:23,510 --> 00:15:27,590
we're doing we're using data binding

00:15:25,490 --> 00:15:29,240
here I can't compose with my regular

00:15:27,590 --> 00:15:31,940
primitives that JavaScript gives me I

00:15:29,240 --> 00:15:33,740
have to do this scope user equal thing

00:15:31,940 --> 00:15:35,570
and there's like a bunch of different

00:15:33,740 --> 00:15:37,250
ways that you have to to tell angular

00:15:35,570 --> 00:15:39,590
hey this is how I want to pass my data

00:15:37,250 --> 00:15:42,320
and you still have problems with deep

00:15:39,590 --> 00:15:43,700
observation so it only you know if we

00:15:42,320 --> 00:15:45,680
want to actually observe changes in the

00:15:43,700 --> 00:15:48,200
user name and the full name we have to

00:15:45,680 --> 00:15:49,310
set up kind of spec

00:15:48,200 --> 00:15:55,160
like we have to change the way that that

00:15:49,310 --> 00:15:57,830
scope works so we can build complex

00:15:55,160 --> 00:15:59,530
performant applications using kvo or

00:15:57,830 --> 00:16:01,640
dirty-checking

00:15:59,530 --> 00:16:05,330
but I don't think it's the simplest way

00:16:01,640 --> 00:16:07,700
to build things and again we've got like

00:16:05,330 --> 00:16:09,950
Google what are they one of the most

00:16:07,700 --> 00:16:13,640
premier web companies out there and and

00:16:09,950 --> 00:16:15,230
ember is focusing so you know so hard on

00:16:13,640 --> 00:16:17,690
making this easy to use and getting

00:16:15,230 --> 00:16:20,060
successful and I don't think that

00:16:17,690 --> 00:16:22,910
they've come up with simple tools so

00:16:20,060 --> 00:16:26,030
let's see if we can build a better

00:16:22,910 --> 00:16:28,130
abstraction and we'll start by kind of

00:16:26,030 --> 00:16:30,440
thinking about what is our ideal system

00:16:28,130 --> 00:16:32,150
so if we had you know a really talented

00:16:30,440 --> 00:16:34,490
engineering team we wanted to build an

00:16:32,150 --> 00:16:36,970
implementation of JavaScript that was

00:16:34,490 --> 00:16:43,160
reactive what would that look like

00:16:36,970 --> 00:16:44,300
let's go back to this example so we'd

00:16:43,160 --> 00:16:47,270
start with some code that looks like

00:16:44,300 --> 00:16:48,620
this now remember with with the Ember

00:16:47,270 --> 00:16:51,860
example we need to use a domain-specific

00:16:48,620 --> 00:16:55,160
language handlebars to glue this data

00:16:51,860 --> 00:16:56,840
model to your Dom so let's use

00:16:55,160 --> 00:16:59,120
JavaScript and say hey you know rendered

00:16:56,840 --> 00:17:00,920
component and then we'll do something in

00:16:59,120 --> 00:17:02,690
this function in a second but put it

00:17:00,920 --> 00:17:04,810
into the document body specify that

00:17:02,690 --> 00:17:08,600
binding in our reactive JavaScript

00:17:04,810 --> 00:17:10,880
mythical language if I want to compute

00:17:08,600 --> 00:17:13,610
the total votes I just write a function

00:17:10,880 --> 00:17:15,350
that computes the total votes and the

00:17:13,610 --> 00:17:18,530
runtime will will track all those

00:17:15,350 --> 00:17:22,610
changes for me in this mythical reactive

00:17:18,530 --> 00:17:25,940
JavaScript language then we'll render

00:17:22,610 --> 00:17:28,520
you know a UL an unordered list element

00:17:25,940 --> 00:17:30,440
with our factory functions now normally

00:17:28,520 --> 00:17:32,270
that would be document dot create

00:17:30,440 --> 00:17:34,250
element you know and you pass it the

00:17:32,270 --> 00:17:36,530
string ul but just for the sake of this

00:17:34,250 --> 00:17:39,470
of this example I don't want to write

00:17:36,530 --> 00:17:40,940
all that code and then we'd sort the

00:17:39,470 --> 00:17:42,620
list of companies by the total number of

00:17:40,940 --> 00:17:45,370
votes just like we did in the previous

00:17:42,620 --> 00:17:49,190
example we'd slice off the top three and

00:17:45,370 --> 00:17:51,830
then we map over each one and we return

00:17:49,190 --> 00:17:53,480
a list item and we have this inline

00:17:51,830 --> 00:17:56,830
expression here that computes that

00:17:53,480 --> 00:17:58,550
percentage votes or the percentage score

00:17:56,830 --> 00:18:00,500
what's important to note here is that

00:17:58,550 --> 00:18:01,180
I'm just using JavaScript primitives

00:18:00,500 --> 00:18:03,070
here

00:18:01,180 --> 00:18:06,280
we've implemented this reactive

00:18:03,070 --> 00:18:08,170
JavaScript mythical implementation it

00:18:06,280 --> 00:18:09,670
all just kind of stays up-to-date and

00:18:08,170 --> 00:18:11,410
that means if you don't like the way

00:18:09,670 --> 00:18:12,820
this code looks you just refactor it

00:18:11,410 --> 00:18:15,220
like you refactor any other piece of

00:18:12,820 --> 00:18:17,050
JavaScript so you know let's say that we

00:18:15,220 --> 00:18:19,300
we don't like that that inline

00:18:17,050 --> 00:18:21,040
expression right there we can do it

00:18:19,300 --> 00:18:23,020
because we don't have to use a helper or

00:18:21,040 --> 00:18:24,610
computed property for it but if we want

00:18:23,020 --> 00:18:27,390
to move it out we can just make a

00:18:24,610 --> 00:18:30,760
function and and move that code around

00:18:27,390 --> 00:18:32,080
and at this point we can actually unit

00:18:30,760 --> 00:18:33,520
test these components separately so if

00:18:32,080 --> 00:18:35,230
we want to do more of an integration

00:18:33,520 --> 00:18:38,080
style test we test render wrap but if we

00:18:35,230 --> 00:18:42,820
want to test just how the ros render we

00:18:38,080 --> 00:18:44,980
can test that specifically so we can't

00:18:42,820 --> 00:18:48,550
do this today because we don't have a

00:18:44,980 --> 00:18:51,640
reactive JavaScript implementation jump

00:18:48,550 --> 00:18:52,870
ahead of my slide that's the first

00:18:51,640 --> 00:18:55,540
problem the second problem is that the

00:18:52,870 --> 00:18:57,040
DOM is stateful if anybody's done game

00:18:55,540 --> 00:19:00,810
programming before you can think of the

00:18:57,040 --> 00:19:03,850
Dom as a retained mode rendering engine

00:19:00,810 --> 00:19:05,650
so we do actually need to build some

00:19:03,850 --> 00:19:06,790
layer of abstraction on top of this but

00:19:05,650 --> 00:19:10,660
we'd like to build one that gets as

00:19:06,790 --> 00:19:12,730
close to that example as we can so we

00:19:10,660 --> 00:19:14,530
built a virtual Dom which i think is a

00:19:12,730 --> 00:19:19,000
less leaky polyfill for reactive

00:19:14,530 --> 00:19:22,000
JavaScript than the Dom so the good news

00:19:19,000 --> 00:19:26,020
is this is actually valid react code

00:19:22,000 --> 00:19:27,730
today and there's it's important to

00:19:26,020 --> 00:19:30,190
remember that there's while this might

00:19:27,730 --> 00:19:31,840
seem unfamiliar there's no data binding

00:19:30,190 --> 00:19:33,130
artifacts here you don't even have to

00:19:31,840 --> 00:19:35,320
think about kind of your data

00:19:33,130 --> 00:19:36,400
dependencies because it solves them for

00:19:35,320 --> 00:19:39,070
you using the same tools that you

00:19:36,400 --> 00:19:40,780
already have today in JavaScript and it

00:19:39,070 --> 00:19:43,060
can take advantage of like 50 years of

00:19:40,780 --> 00:19:44,680
programming language research if you

00:19:43,060 --> 00:19:50,020
think javascript took advantage of this

00:19:44,680 --> 00:19:55,300
I actually do but uh yeah imagine trolls

00:19:50,020 --> 00:19:56,860
trolling the UNPROFOR that so how would

00:19:55,300 --> 00:19:59,590
we implement this if we can't build our

00:19:56,860 --> 00:20:01,120
own JavaScript VM well we want to use

00:19:59,590 --> 00:20:04,030
the tools like the full power of

00:20:01,120 --> 00:20:05,800
JavaScript within our applications so we

00:20:04,030 --> 00:20:08,050
treat the user code as a completely

00:20:05,800 --> 00:20:09,760
black box where there's a signal that

00:20:08,050 --> 00:20:12,040
says hey something in your application

00:20:09,760 --> 00:20:14,149
may have changed and we run your code

00:20:12,040 --> 00:20:16,129
and then we only look at the output so

00:20:14,149 --> 00:20:19,879
whatever you do inside of this black box

00:20:16,129 --> 00:20:22,969
is completely up to you and whenever

00:20:19,879 --> 00:20:24,979
anything or whenever we rerender we take

00:20:22,969 --> 00:20:27,109
your your return value and we dip it

00:20:24,979 --> 00:20:28,249
with the previous return value using a

00:20:27,109 --> 00:20:30,439
set of heuristics that we've come up

00:20:28,249 --> 00:20:33,469
with and we only update the real-time

00:20:30,439 --> 00:20:35,299
with what actually changed and a lot of

00:20:33,469 --> 00:20:37,599
nice things fall out of treating user

00:20:35,299 --> 00:20:40,369
code as a black box not only do you

00:20:37,599 --> 00:20:42,139
because you avoid interleaving this

00:20:40,369 --> 00:20:44,509
observable abstraction with your code

00:20:42,139 --> 00:20:48,319
you can get a lot more expressive power

00:20:44,509 --> 00:20:50,539
and this is the kind of textbook

00:20:48,319 --> 00:20:53,599
definition of expressive power when

00:20:50,539 --> 00:20:56,209
applied to programming languages and I

00:20:53,599 --> 00:20:58,309
don't think it's actually the exact

00:20:56,209 --> 00:20:59,629
definition that I'd like to use for for

00:20:58,309 --> 00:21:01,879
data mining because you can build the

00:20:59,629 --> 00:21:04,189
same applications in a virtual Dom

00:21:01,879 --> 00:21:06,559
system that you can in a KVL system that

00:21:04,189 --> 00:21:09,979
you can in a dirty check system but

00:21:06,559 --> 00:21:11,929
practical expert civet II is a subset of

00:21:09,979 --> 00:21:14,629
expressive power and it means how

00:21:11,929 --> 00:21:17,689
concise is it to express those concepts

00:21:14,629 --> 00:21:19,819
in that system so how often are you

00:21:17,689 --> 00:21:23,989
fighting the framework or the or the

00:21:19,819 --> 00:21:25,159
language or whatever but the reason I

00:21:23,989 --> 00:21:26,419
think people are doing data binding

00:21:25,159 --> 00:21:28,519
right now is because they think that

00:21:26,419 --> 00:21:30,409
re-rendering and differing is expensive

00:21:28,519 --> 00:21:31,599
and kind of intuitively it seems like

00:21:30,409 --> 00:21:33,649
that would be expensive you know

00:21:31,599 --> 00:21:36,379
whenever something may have changed

00:21:33,649 --> 00:21:38,509
rerender everything and then do an event

00:21:36,379 --> 00:21:42,729
walk through that result like that just

00:21:38,509 --> 00:21:42,729
seems like a lot of unnecessary work

00:21:44,409 --> 00:21:48,979
this quotes actually about Lisp

00:21:46,519 --> 00:21:52,459
programmers but Java scripts kind of

00:21:48,979 --> 00:21:54,859
like Lisp programmers know the value of

00:21:52,459 --> 00:21:58,909
everything in the cost of nothing so

00:21:54,859 --> 00:21:59,889
it's true with a kvo system you're doing

00:21:58,909 --> 00:22:02,479
a lot less

00:21:59,889 --> 00:22:04,609
Rikka recomputation of things that you

00:22:02,479 --> 00:22:05,299
don't need to compute but there are

00:22:04,609 --> 00:22:07,339
downsides

00:22:05,299 --> 00:22:10,429
so kvo does entangle your app code with

00:22:07,339 --> 00:22:12,619
observables and angular style

00:22:10,429 --> 00:22:14,359
dirty-checking is similar in that you

00:22:12,619 --> 00:22:17,029
have to pass everything through scope in

00:22:14,359 --> 00:22:18,709
order to get those automatic updates and

00:22:17,029 --> 00:22:20,149
the leak with virtual Dom is that you

00:22:18,709 --> 00:22:22,939
need a signal somewhere that says

00:22:20,149 --> 00:22:24,799
something may have changed so because of

00:22:22,939 --> 00:22:26,239
some some performance characteristics in

00:22:24,799 --> 00:22:27,480
the closure script programming language

00:22:26,239 --> 00:22:29,550
their bindings

00:22:27,480 --> 00:22:31,950
to react which is our reference

00:22:29,550 --> 00:22:34,110
implementation of virtual Dom use

00:22:31,950 --> 00:22:37,050
requestanimationframe as that signal so

00:22:34,110 --> 00:22:40,920
it's kind of invisible but it could be

00:22:37,050 --> 00:22:45,270
any user event server response object

00:22:40,920 --> 00:22:46,230
that observe if you want but most data

00:22:45,270 --> 00:22:47,970
binding systems aren't actually

00:22:46,230 --> 00:22:49,620
statically analyzable this is another

00:22:47,970 --> 00:22:51,900
constraint of these systems so anytime

00:22:49,620 --> 00:22:54,810
you put a JavaScript identifier in a

00:22:51,900 --> 00:22:56,400
string all of that tooling that you can

00:22:54,810 --> 00:23:00,290
use for for statically analyzing

00:22:56,400 --> 00:23:02,690
JavaScript so think j/s hint typescript

00:23:00,290 --> 00:23:04,860
Google closure compiler Advanced Mode

00:23:02,690 --> 00:23:07,980
they don't know whether that string

00:23:04,860 --> 00:23:11,160
represents an identifier or or like a

00:23:07,980 --> 00:23:12,540
user string so they can't do all that

00:23:11,160 --> 00:23:17,210
analysis that they that they normally

00:23:12,540 --> 00:23:19,530
can do and they can't minify it as well

00:23:17,210 --> 00:23:22,890
so we've talked about the costs here but

00:23:19,530 --> 00:23:24,810
it still seems like a kvo system would

00:23:22,890 --> 00:23:28,230
be the most performant way to build

00:23:24,810 --> 00:23:30,600
these user interfaces but like anything

00:23:28,230 --> 00:23:34,860
there is you know a nuanced set of

00:23:30,600 --> 00:23:37,740
trade-offs and the one that most people

00:23:34,860 --> 00:23:40,110
overlook is memory actually so there's a

00:23:37,740 --> 00:23:42,420
lot of focus on benchmarks and CPU but

00:23:40,110 --> 00:23:45,360
on mobile you know if you burn a lot of

00:23:42,420 --> 00:23:46,680
CPU you might burn through their battery

00:23:45,360 --> 00:23:48,390
a little bit but your application still

00:23:46,680 --> 00:23:51,090
works if you burn through too much

00:23:48,390 --> 00:23:53,370
memory iOS is going to kill your your

00:23:51,090 --> 00:23:54,540
browser in process and you're just not

00:23:53,370 --> 00:23:57,960
gonna be able to use the application at

00:23:54,540 --> 00:24:02,490
all so keep that in mind as we start

00:23:57,960 --> 00:24:04,560
thinking about performance so yes kvo

00:24:02,490 --> 00:24:05,850
basically triggers a callback and then

00:24:04,560 --> 00:24:07,770
recomputes only what needs to be

00:24:05,850 --> 00:24:10,530
recomputed but you have to maintain a

00:24:07,770 --> 00:24:11,820
representation of that dependency graph

00:24:10,530 --> 00:24:13,590
so you need to know when a when a

00:24:11,820 --> 00:24:15,360
computed property needs to change

00:24:13,590 --> 00:24:19,980
relative to another computed property or

00:24:15,360 --> 00:24:24,510
observable and there's a cost of that in

00:24:19,980 --> 00:24:26,880
CPU and memory with a with a virtual Dom

00:24:24,510 --> 00:24:29,670
approach one observation we made is that

00:24:26,880 --> 00:24:31,620
render code is actually very cheap so if

00:24:29,670 --> 00:24:34,020
you think about the types of logic that

00:24:31,620 --> 00:24:36,120
you write in your UIs there's usually

00:24:34,020 --> 00:24:37,440
very few if any really tight loops and

00:24:36,120 --> 00:24:40,320
that's normally where your performance

00:24:37,440 --> 00:24:40,980
problems will come into play again these

00:24:40,320 --> 00:24:44,220
are these are kind

00:24:40,980 --> 00:24:45,510
usually we have found like kind of

00:24:44,220 --> 00:24:48,030
hand-wavy but just think of about

00:24:45,510 --> 00:24:50,630
examples in your own work and see if

00:24:48,030 --> 00:24:52,890
this is true or not because a lot of the

00:24:50,630 --> 00:24:54,090
intuition that we've had is based on on

00:24:52,890 --> 00:24:57,240
experiences we've had building

00:24:54,090 --> 00:25:00,120
applications and another thing we

00:24:57,240 --> 00:25:02,490
observed was your view is usually

00:25:00,120 --> 00:25:04,320
smaller than your model and if it's not

00:25:02,490 --> 00:25:06,510
you don't normally have performance

00:25:04,320 --> 00:25:08,460
problems so think about the types of

00:25:06,510 --> 00:25:11,040
things that are historically performance

00:25:08,460 --> 00:25:12,600
sensitive Giants infinite scrolling data

00:25:11,040 --> 00:25:15,260
tables that are sortable by whatever

00:25:12,600 --> 00:25:17,370
column you want or type-ahead searches

00:25:15,260 --> 00:25:18,950
tend to be the things that we could we

00:25:17,370 --> 00:25:21,360
care about performance on the web and

00:25:18,950 --> 00:25:24,679
those have a lot of data and they don't

00:25:21,360 --> 00:25:24,679
actually render that much of it

00:25:24,809 --> 00:25:28,860
and this example is is a perfect example

00:25:26,940 --> 00:25:30,419
of that there's actually any number of

00:25:28,860 --> 00:25:39,419
companies underlying this user interface

00:25:30,419 --> 00:25:43,530
so we're only showing three of them nice

00:25:39,419 --> 00:25:45,799
they left great so I'm going to show

00:25:43,530 --> 00:25:48,450
some some raw performance benchmarks

00:25:45,799 --> 00:25:50,880
remember this talk is about ideas not

00:25:48,450 --> 00:25:53,669
implementations and this is going to be

00:25:50,880 --> 00:25:57,179
used as evidence of the order of growth

00:25:53,669 --> 00:25:58,200
of a performance of these systems so I'm

00:25:57,179 --> 00:25:59,190
going to try to make it clear that

00:25:58,200 --> 00:26:01,770
they're like kind of order of magnitude

00:25:59,190 --> 00:26:04,160
differences not like you know or three

00:26:01,770 --> 00:26:10,890
milliseconds faster or spinning balls on

00:26:04,160 --> 00:26:12,240
jsfiddle or something so that previous

00:26:10,890 --> 00:26:14,220
example where we're rendering the list

00:26:12,240 --> 00:26:16,230
of companies and we show that percentage

00:26:14,220 --> 00:26:21,480
score and we take the top three and we

00:26:16,230 --> 00:26:24,390
sort them when we have 25 items the kbo

00:26:21,480 --> 00:26:26,580
example our numbers from ember and the

00:26:24,390 --> 00:26:28,169
the virtual Dom is numbers from react

00:26:26,580 --> 00:26:29,880
you'll see that it doesn't really matter

00:26:28,169 --> 00:26:33,750
what technique you use these are for all

00:26:29,880 --> 00:26:36,270
intents and purposes the same but when

00:26:33,750 --> 00:26:37,770
you bring it up to 10,000 items you

00:26:36,270 --> 00:26:41,730
start to see pretty significant

00:26:37,770 --> 00:26:42,929
differences in performance and I would

00:26:41,730 --> 00:26:44,280
say that these differences are big

00:26:42,929 --> 00:26:46,110
enough that it suggests like a

00:26:44,280 --> 00:26:47,850
fundamental performance trade-off with

00:26:46,110 --> 00:26:51,120
the underlying ideas rather than the

00:26:47,850 --> 00:26:54,240
implementation itself and the reason for

00:26:51,120 --> 00:26:57,419
that is event

00:26:54,240 --> 00:26:59,220
one of me bio of and big o-notation is a

00:26:57,419 --> 00:27:02,220
is a way of expressing the how the

00:26:59,220 --> 00:27:03,299
performance of an algorithm or what the

00:27:02,220 --> 00:27:05,669
performance characteristics of an

00:27:03,299 --> 00:27:08,730
algorithm are but it matters a lot what

00:27:05,669 --> 00:27:11,759
n is so let's break it out into oh uh V

00:27:08,730 --> 00:27:14,720
versus o of M which is the size of your

00:27:11,759 --> 00:27:17,549
view versus the size of your model and

00:27:14,720 --> 00:27:20,309
in our observation the performance

00:27:17,549 --> 00:27:23,789
sensitive apps have V which is a lot

00:27:20,309 --> 00:27:25,639
smaller than n again those performance

00:27:23,789 --> 00:27:29,759
examples are like type-ahead search

00:27:25,639 --> 00:27:33,059
sortable data tables time line on

00:27:29,759 --> 00:27:37,559
Facebook as well so if we were to look

00:27:33,059 --> 00:27:39,360
at those systems in Big O notation we

00:27:37,559 --> 00:27:41,519
would see that you know on a single

00:27:39,360 --> 00:27:44,100
update your inner wishin is correct like

00:27:41,519 --> 00:27:46,230
a kvo system triggers a single callback

00:27:44,100 --> 00:27:48,659
and then computes only when it needs to

00:27:46,230 --> 00:27:52,289
recompute and it's basically a constant

00:27:48,659 --> 00:27:53,610
time operation whereas for a virtual Dom

00:27:52,289 --> 00:27:56,399
system because we have to diff

00:27:53,610 --> 00:27:57,779
everything that diff is is linear time

00:27:56,399 --> 00:28:02,340
so you have to diff everything in your

00:27:57,779 --> 00:28:05,039
view but the the big win with memory is

00:28:02,340 --> 00:28:06,539
that a virtual Dom system only keeps

00:28:05,039 --> 00:28:09,029
track of what's actually rendered

00:28:06,539 --> 00:28:11,249
whereas a kvo system has to keep track

00:28:09,029 --> 00:28:12,749
of everything in your model so if you

00:28:11,249 --> 00:28:14,070
want to sort a long list like you have

00:28:12,749 --> 00:28:19,039
to build this giant dataflow

00:28:14,070 --> 00:28:21,029
representation in the implementation so

00:28:19,039 --> 00:28:24,720
obviously I have some bias because I

00:28:21,029 --> 00:28:27,929
work on a virtual Dom system but let's

00:28:24,720 --> 00:28:30,840
look at the worst case scenario again

00:28:27,929 --> 00:28:32,490
we're talking about dipping these two

00:28:30,840 --> 00:28:33,720
kind of opaque data structures and if

00:28:32,490 --> 00:28:36,059
you're only changing one tiny little

00:28:33,720 --> 00:28:37,320
thing in this giant haystack of Dom

00:28:36,059 --> 00:28:38,999
nodes you would think that that diff

00:28:37,320 --> 00:28:40,830
would be a lot of wasted effort because

00:28:38,999 --> 00:28:44,340
you have to render it and walk through

00:28:40,830 --> 00:28:48,779
each item and your intuition would be

00:28:44,340 --> 00:28:50,580
correct if you look here for this warm

00:28:48,779 --> 00:28:53,149
update this needle-in-a-haystack thing

00:28:50,580 --> 00:28:55,110
you'll see that kvo system ember is

00:28:53,149 --> 00:28:56,580
sub-millisecond it's just a callback and

00:28:55,110 --> 00:28:58,110
a Dom manipulation it doesn't get much

00:28:56,580 --> 00:29:00,149
faster than that

00:28:58,110 --> 00:29:02,850
whereas virtual Dom system has to diff

00:29:00,149 --> 00:29:06,919
all 10,000 of those Dom nodes and it

00:29:02,850 --> 00:29:08,330
takes around 40 milliseconds and

00:29:06,919 --> 00:29:10,519
I think that I've constructed like a

00:29:08,330 --> 00:29:13,100
pretty pessimistic use case here like

00:29:10,519 --> 00:29:15,799
this is a pretty big DOM and I haven't

00:29:13,100 --> 00:29:18,200
seen you know you don't see this kind of

00:29:15,799 --> 00:29:20,600
scenario very often so normally this

00:29:18,200 --> 00:29:23,419
doesn't bite you but let's say that you

00:29:20,600 --> 00:29:25,340
you're in this scenario when you

00:29:23,419 --> 00:29:27,230
normally try to solve performance

00:29:25,340 --> 00:29:29,690
problems with data-binding the

00:29:27,230 --> 00:29:30,799
instruction manual says like do it

00:29:29,690 --> 00:29:33,919
manually and break out of the DNA

00:29:30,799 --> 00:29:37,269
budding abstraction with virtual done

00:29:33,919 --> 00:29:39,830
because this is just JavaScript and your

00:29:37,269 --> 00:29:41,029
your implementation is a black box to us

00:29:39,830 --> 00:29:42,950
you would just solve it the same way

00:29:41,029 --> 00:29:44,419
with with um with you would in

00:29:42,950 --> 00:29:48,320
JavaScript which is caching or

00:29:44,419 --> 00:29:50,210
memoization so with our reference

00:29:48,320 --> 00:29:51,980
implementation react you can provide a

00:29:50,210 --> 00:29:54,379
hint to the system that says hey cache

00:29:51,980 --> 00:29:56,539
the results of this component and it

00:29:54,379 --> 00:29:58,070
looks something like this so in our

00:29:56,539 --> 00:30:00,139
example if we had you know tons and tons

00:29:58,070 --> 00:30:01,999
of companies and we were rendering all

00:30:00,139 --> 00:30:04,340
of them into the Dom like in this

00:30:01,999 --> 00:30:05,749
example we would just add a hint to each

00:30:04,340 --> 00:30:09,080
row of the list and we would say you

00:30:05,749 --> 00:30:12,529
know only diff or only only render and

00:30:09,080 --> 00:30:14,409
diff this subtree or this row if the

00:30:12,529 --> 00:30:16,700
uploads or the downloads have changed

00:30:14,409 --> 00:30:20,119
and we have profiling tools to help you

00:30:16,700 --> 00:30:22,609
create those so when we apply this hint

00:30:20,119 --> 00:30:24,470
you can see with the optimized virtual

00:30:22,609 --> 00:30:27,889
Dom we can get it down to seven

00:30:24,470 --> 00:30:34,249
milliseconds which by the way is ten

00:30:27,889 --> 00:30:37,309
times slower than KBL but it's still

00:30:34,249 --> 00:30:39,049
within a single requestanimationframe so

00:30:37,309 --> 00:30:40,759
this isn't user perceptible because the

00:30:39,049 --> 00:30:42,590
browser literally will not paint faster

00:30:40,759 --> 00:30:45,440
than then this operation occurs and this

00:30:42,590 --> 00:30:49,279
is a kind of worst-case scenario for

00:30:45,440 --> 00:30:50,899
virtual Dom so think about all the

00:30:49,279 --> 00:30:53,690
performance and usability trade-offs

00:30:50,899 --> 00:30:56,899
that I've talked about we get we can get

00:30:53,690 --> 00:30:58,820
lower memory usage and we can get if

00:30:56,899 --> 00:31:00,519
you're not if you're windowing basically

00:30:58,820 --> 00:31:03,109
only rendering a small part of your data

00:31:00,519 --> 00:31:06,049
and it's a lot more expressive in my

00:31:03,109 --> 00:31:08,059
opinion and what you lose is you you

00:31:06,049 --> 00:31:09,609
don't even lose a full frame when you

00:31:08,059 --> 00:31:12,710
have to apply this optimization hit

00:31:09,609 --> 00:31:15,649
which granted is a leak in the virtual

00:31:12,710 --> 00:31:17,840
Dom reactive abstraction but it's a leak

00:31:15,649 --> 00:31:20,240
that you can apply at the end after your

00:31:17,840 --> 00:31:25,730
application is already built and

00:31:20,240 --> 00:31:27,050
can help you with it very easily so my

00:31:25,730 --> 00:31:28,160
friend who works on ember performance

00:31:27,050 --> 00:31:29,270
says if you're gonna keep making the

00:31:28,160 --> 00:31:33,680
performance argument you'll eventually

00:31:29,270 --> 00:31:35,360
lose and this is true and ember has been

00:31:33,680 --> 00:31:37,520
my example here but they're making you

00:31:35,360 --> 00:31:39,200
know great performance strides and the

00:31:37,520 --> 00:31:41,600
next version of their templating system

00:31:39,200 --> 00:31:42,860
it's gonna be really fast but I think

00:31:41,600 --> 00:31:47,630
that ideas have fundamental performance

00:31:42,860 --> 00:31:51,440
properties so the secret of the virtual

00:31:47,630 --> 00:31:53,690
Dom so to speak as tacky as that is is

00:31:51,440 --> 00:31:55,730
not about performance it's about

00:31:53,690 --> 00:31:58,430
simplicity if you want to build

00:31:55,730 --> 00:32:00,590
sophisticated applications sophisticated

00:31:58,430 --> 00:32:02,360
reliable applications they need to be

00:32:00,590 --> 00:32:05,420
simple they need to be built on simple

00:32:02,360 --> 00:32:07,150
composable primitives and I'll make the

00:32:05,420 --> 00:32:09,950
argument that because of its simplicity

00:32:07,150 --> 00:32:11,690
a virtual Dom based system is the most

00:32:09,950 --> 00:32:16,340
expressive way to build user interfaces

00:32:11,690 --> 00:32:17,630
in JavaScript bar none it's you know the

00:32:16,340 --> 00:32:20,360
difference between writing some regular

00:32:17,630 --> 00:32:21,500
JavaScript and writing a bunch of stuff

00:32:20,360 --> 00:32:23,930
that explicitly needs to deal with

00:32:21,500 --> 00:32:27,050
observables and and data binding to the

00:32:23,930 --> 00:32:28,820
Dom and you're not allowed to use

00:32:27,050 --> 00:32:31,400
functions and it's the difference

00:32:28,820 --> 00:32:33,950
between composing with these sorts of

00:32:31,400 --> 00:32:36,590
primitives and these sorts of primitives

00:32:33,950 --> 00:32:38,360
and you can see these in kind of order

00:32:36,590 --> 00:32:39,740
of magnitude lines of code so if you

00:32:38,360 --> 00:32:42,830
want to use firebase which is a real

00:32:39,740 --> 00:32:44,180
time database it's like 300 code or 300

00:32:42,830 --> 00:32:47,240
lines of code to build bindings to these

00:32:44,180 --> 00:32:49,090
systems with a virtual Dom system it's

00:32:47,240 --> 00:32:51,020
literally passed the data model in and

00:32:49,090 --> 00:32:51,890
because it's a black box that doesn't

00:32:51,020 --> 00:32:53,480
know about observables

00:32:51,890 --> 00:32:57,470
it just works it's like 10 lines of code

00:32:53,480 --> 00:32:58,700
so performance isn't the main goal but

00:32:57,470 --> 00:33:00,590
if you're worried about performance most

00:32:58,700 --> 00:33:04,250
workloads are as fast or faster out of

00:33:00,590 --> 00:33:05,750
the box and in the worst case you add an

00:33:04,250 --> 00:33:07,550
optimization hint and you can get within

00:33:05,750 --> 00:33:10,220
one frame without completely breaking

00:33:07,550 --> 00:33:13,240
out of the abstraction so I urge you to

00:33:10,220 --> 00:33:16,240
not trade simplicity for familiarity

00:33:13,240 --> 00:33:16,240
Thanks

00:33:47,230 --> 00:33:49,290

YouTube URL: https://www.youtube.com/watch?v=h3KksH8gfcQ


