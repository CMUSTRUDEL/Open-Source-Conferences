Title: MountainWest JavaScript 2014 - And Benchmarks for All! by Alex Navasardyan
Publication date: 2020-01-24
Playlist: MountainWest JavaScript 2014
Description: 
	If you're a framework maintainer it is really hard to measure performance of your library and it can be a real pain in the butt. This talk will show you how to write different kinds of benchmarks (certainly, not micro benchmarks), including the ones that will profile DOM interactions and JavaScript execution. Ember.js will be taken as a playground for showing different benchmarks' demos
And benchmarks for all!

Help us caption & translate this video!

http://amara.org/v/FG3H/
Captions: 
	00:00:25,510 --> 00:00:34,309
alright cool so i'm i'm here to talk to

00:00:32,000 --> 00:00:38,030
you guys about benchmarks and what they

00:00:34,309 --> 00:00:40,489
are and why is it interesting and kind

00:00:38,030 --> 00:00:43,640
of useful to to have them or to like

00:00:40,489 --> 00:00:46,370
sort of start writing them i guess so a

00:00:43,640 --> 00:00:47,870
little bit about me i'm alex nova saudi

00:00:46,370 --> 00:00:50,000
and to cool and github to cool and

00:00:47,870 --> 00:00:53,090
twitter i work for a company called

00:00:50,000 --> 00:00:58,880
dockyard we are ember.js rails mobile

00:00:53,090 --> 00:01:01,820
consultancy based in boston so kind of

00:00:58,880 --> 00:01:04,630
like so benchmark is is hard especially

00:01:01,820 --> 00:01:09,250
especially when we talk about

00:01:04,630 --> 00:01:09,250
benchmarking your JavaScript code and

00:01:10,090 --> 00:01:15,289
that's because we are working with

00:01:12,110 --> 00:01:16,670
browsers and browsers are like the

00:01:15,289 --> 00:01:20,649
actually sophisticated pieces of

00:01:16,670 --> 00:01:24,679
software because when you run your code

00:01:20,649 --> 00:01:26,450
JavaScript code it gets executed it

00:01:24,679 --> 00:01:29,569
actually executed native code which is

00:01:26,450 --> 00:01:34,039
an assembler right and then JavaScript

00:01:29,569 --> 00:01:35,420
engines they are written in C++ I then

00:01:34,039 --> 00:01:36,770
you know there's a complexity of your

00:01:35,420 --> 00:01:38,569
JavaScript code because your JavaScript

00:01:36,770 --> 00:01:41,660
code can be really sophisticated

00:01:38,569 --> 00:01:43,750
depending on the framework they're using

00:01:41,660 --> 00:01:47,869
like ember.js or backbone or whatever

00:01:43,750 --> 00:01:50,840
right and another quirk of benchmarking

00:01:47,869 --> 00:01:53,479
is hardware hardware is a big big

00:01:50,840 --> 00:01:55,190
problem because not a richly problem but

00:01:53,479 --> 00:01:59,630
you sort of have to be aware of that if

00:01:55,190 --> 00:02:02,630
you want to know or or reliably run

00:01:59,630 --> 00:02:04,039
benchmarks and have reliable results you

00:02:02,630 --> 00:02:06,410
better off having like it's you know

00:02:04,039 --> 00:02:09,739
server standalone server that does

00:02:06,410 --> 00:02:12,440
nothing but just runs benchmarks so that

00:02:09,739 --> 00:02:15,530
is kind of like hard it's like a lot of

00:02:12,440 --> 00:02:19,970
moving parts and like why even bother

00:02:15,530 --> 00:02:23,239
right so giving that we're all writing

00:02:19,970 --> 00:02:26,000
JavaScript in world web developers we

00:02:23,239 --> 00:02:27,980
should be aware of that when you run

00:02:26,000 --> 00:02:29,870
your code when you're on you go in the

00:02:27,980 --> 00:02:31,730
browser you are only just scratching the

00:02:29,870 --> 00:02:32,870
surface so you only touch on touching

00:02:31,730 --> 00:02:38,209
this one layer which

00:02:32,870 --> 00:02:41,120
javascript right so again yo code then

00:02:38,209 --> 00:02:43,400
there is a compiler and what do I mean

00:02:41,120 --> 00:02:46,849
by compiler compiler is actually not the

00:02:43,400 --> 00:02:48,799
i would say proper term for that it's

00:02:46,849 --> 00:02:50,810
more like javascript engine compiler is

00:02:48,799 --> 00:02:54,079
a part of the javascript engine so

00:02:50,810 --> 00:02:57,920
firefox is spider monkey opera has

00:02:54,079 --> 00:02:59,680
Carrick on IE has chakra but i'm going

00:02:57,920 --> 00:03:06,200
to be specifically talking about v8 here

00:02:59,680 --> 00:03:08,840
so this yoko javascript is being run by

00:03:06,200 --> 00:03:11,930
the compiler so compiler does something

00:03:08,840 --> 00:03:16,700
to it and then it turns on the native

00:03:11,930 --> 00:03:18,319
code so it turns out that the code that

00:03:16,700 --> 00:03:20,420
you write your JavaScript code is

00:03:18,319 --> 00:03:24,079
actually not the same code that gets

00:03:20,420 --> 00:03:28,220
executed sounds kind of bizarre right so

00:03:24,079 --> 00:03:30,260
like what what is going on right so for

00:03:28,220 --> 00:03:32,739
that I'll talk a little bit about

00:03:30,260 --> 00:03:36,409
compilers I just sort of a compiler

00:03:32,739 --> 00:03:37,910
compilers one to one thing this is this

00:03:36,409 --> 00:03:39,919
example is called constant propagation

00:03:37,910 --> 00:03:41,569
right so we're trying to benchmark here

00:03:39,919 --> 00:03:44,750
we're trying to benchmark converting a

00:03:41,569 --> 00:03:46,280
string to a number and there's double

00:03:44,750 --> 00:03:49,250
dildo operator if you guys are to know

00:03:46,280 --> 00:03:51,440
that's just a an equivalent of parson so

00:03:49,250 --> 00:03:53,269
we have this constant a right and we're

00:03:51,440 --> 00:03:57,889
running thousand times a loop and then

00:03:53,269 --> 00:04:00,190
we measured the time which is log it on

00:03:57,889 --> 00:04:03,919
the console right so it's kind of like

00:04:00,190 --> 00:04:07,609
simple right so this is the code that

00:04:03,919 --> 00:04:10,220
we're working with but compiler is kind

00:04:07,609 --> 00:04:12,199
of like smart so what it does it looks

00:04:10,220 --> 00:04:13,940
at the a and says well it's a constant

00:04:12,199 --> 00:04:18,199
right so I might as well just in line it

00:04:13,940 --> 00:04:21,410
right that cool then it looks further

00:04:18,199 --> 00:04:23,539
and it goes well it's a constant and all

00:04:21,410 --> 00:04:26,810
you do you just basic converted in

00:04:23,539 --> 00:04:28,639
constant so I might as well just perform

00:04:26,810 --> 00:04:30,500
this operation once i'm just going to

00:04:28,639 --> 00:04:33,620
convert it once and it just going to

00:04:30,500 --> 00:04:38,000
line it again and at this point your

00:04:33,620 --> 00:04:40,070
bench marketing that assignment cool all

00:04:38,000 --> 00:04:42,020
right so let's take a look at another

00:04:40,070 --> 00:04:43,430
example so it smart developer will look

00:04:42,020 --> 00:04:46,460
at that and says you know what let's

00:04:43,430 --> 00:04:50,150
let's make a a non-constant

00:04:46,460 --> 00:04:53,840
let me use data now to string so now

00:04:50,150 --> 00:04:55,490
using constant anymore awesome right but

00:04:53,840 --> 00:05:00,050
compiler will take a look at that and

00:04:55,490 --> 00:05:01,729
say well you know what it's all good but

00:05:00,050 --> 00:05:04,099
I'm just going to hoist out that

00:05:01,729 --> 00:05:06,199
operations of conversion out of the loop

00:05:04,099 --> 00:05:08,660
I don't have to do it like many times

00:05:06,199 --> 00:05:11,930
right so I'm just going to create a new

00:05:08,660 --> 00:05:15,229
variable and you are benchmarking the

00:05:11,930 --> 00:05:19,310
assignment again so it's totally not

00:05:15,229 --> 00:05:22,130
what you think is going on and even that

00:05:19,310 --> 00:05:24,580
is called loop invariant code motion

00:05:22,130 --> 00:05:29,090
when things are hosted out of the loop

00:05:24,580 --> 00:05:32,539
so it's all good and then compiler looks

00:05:29,090 --> 00:05:35,300
at the code and it goes like okay so

00:05:32,539 --> 00:05:38,870
nobody's using see that variable over

00:05:35,300 --> 00:05:45,069
there nobody is using be so why the heck

00:05:38,870 --> 00:05:48,319
am i doing all this crazy work gone

00:05:45,069 --> 00:05:50,330
right and now your code is infinitely

00:05:48,319 --> 00:05:53,930
fast which is awesome right you're

00:05:50,330 --> 00:05:56,180
benchmarking Ardley gets you like really

00:05:53,930 --> 00:05:58,159
nice results you high-five your

00:05:56,180 --> 00:06:03,289
colleagues right and you call it a day

00:05:58,159 --> 00:06:06,949
nice all right so give me that oh that's

00:06:03,289 --> 00:06:09,789
another thing called inlining so if you

00:06:06,949 --> 00:06:14,000
ever want to benchmark your function and

00:06:09,789 --> 00:06:15,800
I took this one as an example so you run

00:06:14,000 --> 00:06:18,949
this code right so it basically takes

00:06:15,800 --> 00:06:21,889
four arguments and just puts them

00:06:18,949 --> 00:06:23,360
together right so what compiler will do

00:06:21,889 --> 00:06:25,669
it'll let you look at the function and

00:06:23,360 --> 00:06:30,530
say I might as well just in line it

00:06:25,669 --> 00:06:34,550
right and does this and this this point

00:06:30,530 --> 00:06:36,979
you are putting a string together which

00:06:34,550 --> 00:06:39,229
is a constant which is going to be

00:06:36,979 --> 00:06:44,270
eliminated as well so you benchmark

00:06:39,229 --> 00:06:46,099
nothing all right so given hold a given

00:06:44,270 --> 00:06:48,440
all this complexity and like weird

00:06:46,099 --> 00:06:51,229
things that are happening under the hood

00:06:48,440 --> 00:06:54,050
of the JavaScript engine like why oven

00:06:51,229 --> 00:06:56,870
right benchmarks right what did like why

00:06:54,050 --> 00:06:59,510
do I bother well the first thing it

00:06:56,870 --> 00:06:59,750
actually helps you understand what what

00:06:59,510 --> 00:07:02,480
is

00:06:59,750 --> 00:07:05,660
really happening to you code how how

00:07:02,480 --> 00:07:07,670
JavaScript engine works right so and

00:07:05,660 --> 00:07:08,810
given that given that you understand

00:07:07,670 --> 00:07:11,480
what's happening you can improve your

00:07:08,810 --> 00:07:13,550
code you can help the compiler to run

00:07:11,480 --> 00:07:15,890
your code faster which is you know

00:07:13,550 --> 00:07:19,220
generally good you run the code runs

00:07:15,890 --> 00:07:20,960
faster and after that you can measure

00:07:19,220 --> 00:07:23,690
and validate all the assumptions that

00:07:20,960 --> 00:07:26,090
you made that means that you can have a

00:07:23,690 --> 00:07:30,140
suite of benchmarks that will run over

00:07:26,090 --> 00:07:32,240
time and well first off it's going to

00:07:30,140 --> 00:07:36,140
tell you like it's x percent faster or

00:07:32,240 --> 00:07:37,730
slower and the more important is that it

00:07:36,140 --> 00:07:39,580
will allow you to validate the

00:07:37,730 --> 00:07:43,730
assumption that you took so let's say v8

00:07:39,580 --> 00:07:45,980
optimizes the code very well so you code

00:07:43,730 --> 00:07:49,130
code runs faster but spider monkey

00:07:45,980 --> 00:07:52,490
doesn't it's just like it's sexually

00:07:49,130 --> 00:07:56,570
slower so you will able to find the

00:07:52,490 --> 00:08:00,169
balance which is pretty pretty awesome

00:07:56,570 --> 00:08:02,870
as well so given that it seems like you

00:08:00,169 --> 00:08:04,340
know you have to know a lot about like a

00:08:02,870 --> 00:08:08,210
lot of what you have to know a lot of

00:08:04,340 --> 00:08:11,000
things to write benchmarks but that's

00:08:08,210 --> 00:08:15,770
not actually true you just have to know

00:08:11,000 --> 00:08:17,750
a little bit about compilers and you

00:08:15,770 --> 00:08:20,090
don't have to know how compilers are

00:08:17,750 --> 00:08:22,190
implemented nothing crazy like that you

00:08:20,090 --> 00:08:25,190
just have to know basic things of like

00:08:22,190 --> 00:08:27,800
how compiler operates how how compiler

00:08:25,190 --> 00:08:29,630
thinks about the code so this particular

00:08:27,800 --> 00:08:32,300
feature here on classes this is

00:08:29,630 --> 00:08:37,460
something that is implemented in v8 and

00:08:32,300 --> 00:08:39,680
this is how v8 optimizes the code so it

00:08:37,460 --> 00:08:42,950
might sound complicated human classes

00:08:39,680 --> 00:08:46,160
but kitten classes are just metadata so

00:08:42,950 --> 00:08:49,610
anytime you create an object it creates

00:08:46,160 --> 00:08:51,290
a fiddle kid in class so why do I do

00:08:49,610 --> 00:08:53,720
that right well the problem is that

00:08:51,290 --> 00:08:55,130
javascript is a dynamically type crowded

00:08:53,720 --> 00:08:58,250
by prototype based language that means

00:08:55,130 --> 00:08:59,870
at any point of runtime you can take the

00:08:58,250 --> 00:09:02,750
object you can you can change its state

00:08:59,870 --> 00:09:04,460
that makes it really hard to optimize

00:09:02,750 --> 00:09:09,410
the code because you don't know the type

00:09:04,460 --> 00:09:11,690
so like what do I do what is going on so

00:09:09,410 --> 00:09:13,310
that's why that's why VA creates all the

00:09:11,690 --> 00:09:16,370
hidden classes so he stores

00:09:13,310 --> 00:09:20,600
information and this type information

00:09:16,370 --> 00:09:23,690
knowledge them to optimize the code so

00:09:20,600 --> 00:09:26,330
this particular example we have a

00:09:23,690 --> 00:09:32,420
function called person and we create two

00:09:26,330 --> 00:09:34,970
instances of the function the Iron Man

00:09:32,420 --> 00:09:37,160
and the captain america so let's see

00:09:34,970 --> 00:09:41,510
what's happening here so we are

00:09:37,160 --> 00:09:45,080
executing function new person so as soon

00:09:41,510 --> 00:09:47,360
as we inside the body it creates the

00:09:45,080 --> 00:09:50,470
hidden class CEO it's actually not the

00:09:47,360 --> 00:09:53,839
DNA that just made it up CEO whatever

00:09:50,470 --> 00:09:55,580
and as soon as we start adding new

00:09:53,839 --> 00:09:58,850
properties it's going to create new

00:09:55,580 --> 00:10:04,100
classes so now we there's another

00:09:58,850 --> 00:10:05,420
another class c-1 that based on Co with

00:10:04,100 --> 00:10:08,360
the perp your first name the same thing

00:10:05,420 --> 00:10:09,680
that thing happens with last name so now

00:10:08,360 --> 00:10:14,750
what you end up having you have you have

00:10:09,680 --> 00:10:15,980
a chain so now you know that the object

00:10:14,750 --> 00:10:19,010
that you get back from the person

00:10:15,980 --> 00:10:24,020
function has this chain and has this

00:10:19,010 --> 00:10:26,450
type cool so what happens here the next

00:10:24,020 --> 00:10:29,780
time we call a new person it's going to

00:10:26,450 --> 00:10:33,620
have the same the same chain the same c2

00:10:29,780 --> 00:10:36,320
so the class classes they match and this

00:10:33,620 --> 00:10:39,800
is how v8 knows that I don't actually

00:10:36,320 --> 00:10:41,450
optimize the calls and different

00:10:39,800 --> 00:10:43,790
operations and those two objects Iron

00:10:41,450 --> 00:10:46,610
Man and Captain America but as soon as

00:10:43,790 --> 00:10:48,200
you change the layer the layout or they

00:10:46,610 --> 00:10:55,220
call a shitty call it a shape of the

00:10:48,200 --> 00:10:57,080
object and changing the layout means for

00:10:55,220 --> 00:11:00,650
example assign a new property that

00:10:57,080 --> 00:11:03,709
wasn't known to VA before as soon as you

00:11:00,650 --> 00:11:05,990
do that it's going to create a new new

00:11:03,709 --> 00:11:08,830
seat in class let's just annoy based in

00:11:05,990 --> 00:11:14,180
situ with the new property called age

00:11:08,830 --> 00:11:16,880
and this is bad this is bad because the

00:11:14,180 --> 00:11:19,850
optimized code that VA had before it has

00:11:16,880 --> 00:11:22,400
to throw it away put the day optimized

00:11:19,850 --> 00:11:27,460
code 1 and let it run and Dan is going

00:11:22,400 --> 00:11:32,000
to come up with new assumptions etc etc

00:11:27,460 --> 00:11:36,230
alright so giving the giving this

00:11:32,000 --> 00:11:41,980
feature the hidden classes feature that

00:11:36,230 --> 00:11:46,460
allows you to implement another feature

00:11:41,980 --> 00:11:48,740
inline caching which is huge too it

00:11:46,460 --> 00:11:51,320
pretty much speeds you code like 20

00:11:48,740 --> 00:11:54,730
times so what is in line cash well

00:11:51,320 --> 00:11:58,490
obviously it is a cash but what it does

00:11:54,730 --> 00:12:01,070
what VA does it looks at the code looks

00:11:58,490 --> 00:12:02,300
at the function and actually not the

00:12:01,070 --> 00:12:05,210
function pretty much everything look

00:12:02,300 --> 00:12:09,290
let's say you access something very

00:12:05,210 --> 00:12:13,520
often and v8 noticed that and instead of

00:12:09,290 --> 00:12:16,190
like calling retrieve operations all the

00:12:13,520 --> 00:12:18,800
time is going to just swap it with a

00:12:16,190 --> 00:12:21,800
fast path so I'm just going to give you

00:12:18,800 --> 00:12:24,710
an example so let's say you have these

00:12:21,800 --> 00:12:27,560
dead puppies that's an array and let's

00:12:24,710 --> 00:12:30,020
say this dot puppies is hot by hot I

00:12:27,560 --> 00:12:32,570
mean it's used everywhere many many

00:12:30,020 --> 00:12:34,550
times so instead of doing and this is

00:12:32,570 --> 00:12:36,740
this is a sample of code that gets gets

00:12:34,550 --> 00:12:38,990
generated by v8 so don't get scared that

00:12:36,740 --> 00:12:41,770
says this is not relevant all is

00:12:38,990 --> 00:12:43,730
relevant is this right so first time

00:12:41,770 --> 00:12:46,660
this is dead puppies is going to be

00:12:43,730 --> 00:12:49,190
accessed uh this guy is going to be cold

00:12:46,660 --> 00:12:53,000
so it's going to call this function and

00:12:49,190 --> 00:12:56,360
go retrieve the value either for memory

00:12:53,000 --> 00:12:59,210
or probably for memory and it's going to

00:12:56,360 --> 00:13:02,180
get back getting back to you right but

00:12:59,210 --> 00:13:04,670
as it runs v8 looks at that and says

00:13:02,180 --> 00:13:07,670
well you know what I might as well just

00:13:04,670 --> 00:13:10,370
swap it but swap the function call with

00:13:07,670 --> 00:13:12,230
the actual address in the memory so no

00:13:10,370 --> 00:13:14,209
flow no normal function calls it just

00:13:12,230 --> 00:13:15,830
gets you back the value right away it's

00:13:14,209 --> 00:13:23,959
an optimistic assumption but it is

00:13:15,830 --> 00:13:29,300
usually valid all right so having said

00:13:23,959 --> 00:13:31,490
all of that about JavaScript engines and

00:13:29,300 --> 00:13:32,839
above VA let's move to benchmarking

00:13:31,490 --> 00:13:36,530
patterns as like how do you actually

00:13:32,839 --> 00:13:39,530
benchmark your code what is what are the

00:13:36,530 --> 00:13:40,520
ways right so the first one is fairly

00:13:39,530 --> 00:13:44,600
simple right

00:13:40,520 --> 00:13:46,810
you write your code sorry you have a

00:13:44,600 --> 00:13:50,330
number of iterations right and then you

00:13:46,810 --> 00:13:52,400
run you code six times it like in this

00:13:50,330 --> 00:13:55,160
particular case six times and that's

00:13:52,400 --> 00:13:59,300
pretty straightforward the downside of

00:13:55,160 --> 00:14:01,220
that is that as browsers they you know

00:13:59,300 --> 00:14:04,730
they get faster and you end up having

00:14:01,220 --> 00:14:06,290
this zero millisecond results so it's

00:14:04,730 --> 00:14:09,790
not it's unusable so you don't know how

00:14:06,290 --> 00:14:14,720
like how fast or slow your code is

00:14:09,790 --> 00:14:16,600
another way of doing that is not relying

00:14:14,720 --> 00:14:21,260
upon the number of iterations but

00:14:16,600 --> 00:14:22,880
relying on the own on the total time so

00:14:21,260 --> 00:14:25,640
you say my benchmarks are going to run

00:14:22,880 --> 00:14:27,890
for 10 seconds and then I'm going to

00:14:25,640 --> 00:14:33,500
measure the number of operations happen

00:14:27,890 --> 00:14:36,800
during those those don't ten seconds the

00:14:33,500 --> 00:14:41,270
dro block of that is that the results

00:14:36,800 --> 00:14:43,700
may vary because because of the

00:14:41,270 --> 00:14:46,130
JavaScript garbage collection and

00:14:43,700 --> 00:14:48,970
different engine optimizations and also

00:14:46,130 --> 00:14:51,800
as I mentioned before about the hardware

00:14:48,970 --> 00:14:53,270
it actually is very important not to

00:14:51,800 --> 00:14:54,590
have any background processes running

00:14:53,270 --> 00:14:58,630
when you're running benchmarks because

00:14:54,590 --> 00:15:02,360
that's going to affect the results so

00:14:58,630 --> 00:15:04,520
anyway to to get more or less reliable

00:15:02,360 --> 00:15:07,070
results when you using this particular

00:15:04,520 --> 00:15:12,860
pattern you have to run many many times

00:15:07,070 --> 00:15:17,840
to get the average whoa all right this

00:15:12,860 --> 00:15:19,490
one is called the loop unrolling so so

00:15:17,840 --> 00:15:23,300
you let's say you want to run your

00:15:19,490 --> 00:15:26,780
benchmark the test one right X number of

00:15:23,300 --> 00:15:28,730
times so the approach here is that

00:15:26,780 --> 00:15:33,650
you're not going to have a loop so Lulu

00:15:28,730 --> 00:15:36,980
gets thrown away the test function is

00:15:33,650 --> 00:15:38,480
going to be in line like that and you're

00:15:36,980 --> 00:15:41,810
going to hand you're going to basically

00:15:38,480 --> 00:15:45,050
end up having you're going to inline

00:15:41,810 --> 00:15:46,910
your function x times so the problem

00:15:45,050 --> 00:15:50,180
with that is this is actually going to

00:15:46,910 --> 00:15:53,610
increase the number usage and slow down

00:15:50,180 --> 00:15:55,680
the CPU so that

00:15:53,610 --> 00:15:59,339
why for like when I do benchmarking i

00:15:55,680 --> 00:16:03,209
use benchmark Jess so those guys John

00:15:59,339 --> 00:16:05,640
David Dalton and Mathias I can't

00:16:03,209 --> 00:16:09,230
remember his last name anyway so those

00:16:05,640 --> 00:16:12,290
guys they wrote the benchmark jas a

00:16:09,230 --> 00:16:15,329
library and this library gives you a

00:16:12,290 --> 00:16:18,000
reliable precise timers and you know

00:16:15,329 --> 00:16:21,420
better benchmark benchmarking patterns

00:16:18,000 --> 00:16:23,850
so the those guys just figured it out so

00:16:21,420 --> 00:16:26,579
you didn't have to worry about like hide

00:16:23,850 --> 00:16:32,760
away which benchmark pattern to use to

00:16:26,579 --> 00:16:34,649
run benchmarks anyway so they use a sort

00:16:32,760 --> 00:16:36,690
of like the combination of patterns a

00:16:34,649 --> 00:16:40,890
and B and the function body instruction

00:16:36,690 --> 00:16:42,540
extraction so long story short so this

00:16:40,890 --> 00:16:44,940
is set up this is this is how you

00:16:42,540 --> 00:16:46,829
typically write your benchmarks using

00:16:44,940 --> 00:16:49,470
benchmark Jess so you have a setup

00:16:46,829 --> 00:16:52,019
function which a lot of people get it

00:16:49,470 --> 00:16:57,510
wrong which gets executed only once

00:16:52,019 --> 00:17:00,660
before the test cycle so you have that

00:16:57,510 --> 00:17:03,899
and then you create a sweet and then you

00:17:00,660 --> 00:17:06,780
add basically a task that you want to

00:17:03,899 --> 00:17:09,290
run so this is the code that you see

00:17:06,780 --> 00:17:12,990
this is the code you interacting with

00:17:09,290 --> 00:17:15,540
but under the hood it gets converted

00:17:12,990 --> 00:17:18,540
into this don't sweat the details it

00:17:15,540 --> 00:17:21,900
doesn't matter basically what benchmark

00:17:18,540 --> 00:17:24,510
jess is trying to do is try tries to

00:17:21,900 --> 00:17:28,020
guard you from the the optimization that

00:17:24,510 --> 00:17:30,480
v8 does in other JavaScript engines this

00:17:28,020 --> 00:17:32,790
is what matters so you have the setup

00:17:30,480 --> 00:17:41,870
code over here and then the while loop

00:17:32,790 --> 00:17:41,870
and you just execute X number of times

00:17:42,049 --> 00:17:51,390
so given all that let's move to the demo

00:17:45,150 --> 00:17:58,250
and I'll show you what would I typically

00:17:51,390 --> 00:17:58,250
do to run benchmarks all right

00:17:59,919 --> 00:18:08,029
can you see you okay seems fine cool all

00:18:05,480 --> 00:18:11,210
right so what we're looking at is the

00:18:08,029 --> 00:18:13,340
typical setup I guess there's a back

00:18:11,210 --> 00:18:15,950
burner and for you who doesn't know what

00:18:13,340 --> 00:18:18,019
back burner is it's a famous wrong loop

00:18:15,950 --> 00:18:25,970
ember.js wrong loop it's a micro library

00:18:18,019 --> 00:18:27,950
to a basic q a lot of actions put boot

00:18:25,970 --> 00:18:31,039
actions on the queue and executing like

00:18:27,950 --> 00:18:32,779
batch execute them I guess so that's a

00:18:31,039 --> 00:18:36,320
back burner over here benchmark jsin

00:18:32,779 --> 00:18:39,259
lodash that's low dash is a as a

00:18:36,320 --> 00:18:41,570
requirement from benchmark gas then we

00:18:39,259 --> 00:18:44,809
have an actual test here and the index

00:18:41,570 --> 00:18:48,080
HTML here so I have index HTML because

00:18:44,809 --> 00:18:50,570
we're the way I do it you you can open

00:18:48,080 --> 00:18:53,119
the instance of chrome i use canary

00:18:50,570 --> 00:18:56,149
chrome canary browser with specific

00:18:53,119 --> 00:18:59,389
flags that'll tell you and look it'll

00:18:56,149 --> 00:19:01,970
just dump a lot of information about

00:18:59,389 --> 00:19:03,850
what VA does to you code so that's why

00:19:01,970 --> 00:19:07,029
you have index HTML is going to be open

00:19:03,850 --> 00:19:10,999
opening this code in the browser so

00:19:07,029 --> 00:19:14,119
let's do it so for the sake of time just

00:19:10,999 --> 00:19:15,230
going to copy their over here so what's

00:19:14,119 --> 00:19:21,799
going to happen is that you're going to

00:19:15,230 --> 00:19:24,619
see that the code is running in in

00:19:21,799 --> 00:19:27,619
canary so canary was open and all this

00:19:24,619 --> 00:19:29,389
output is basically the metadata of what

00:19:27,619 --> 00:19:35,480
is actually happening out of the hood

00:19:29,389 --> 00:19:38,299
and what v8 does to your code so bear

00:19:35,480 --> 00:19:45,950
with me all right so it seems like it's

00:19:38,299 --> 00:19:50,090
fine yeah seems like it's fine

00:19:45,950 --> 00:19:55,700
now look at that we have a lot of

00:19:50,090 --> 00:19:58,870
different files here so all this SMIC of

00:19:55,700 --> 00:20:02,149
G files those are those are files

00:19:58,870 --> 00:20:04,340
metadata files that basically contain

00:20:02,149 --> 00:20:08,440
information about different D

00:20:04,340 --> 00:20:12,130
optimizations and things like that so

00:20:08,440 --> 00:20:16,460
just to show you what it looks like

00:20:12,130 --> 00:20:19,220
don't get scared it gets better so it

00:20:16,460 --> 00:20:22,190
looks something like that all right like

00:20:19,220 --> 00:20:26,630
this is total crap I mean like you can't

00:20:22,190 --> 00:20:28,850
work with that right tells you nothing

00:20:26,630 --> 00:20:34,309
as a JavaScript engineer so what do we

00:20:28,850 --> 00:20:36,919
do then Deza does a tool that one of the

00:20:34,309 --> 00:20:41,000
Google engineers wrote and it's called

00:20:36,919 --> 00:20:45,830
are Hydra and guess what it does it

00:20:41,000 --> 00:20:48,830
actually helps you it actually helps you

00:20:45,830 --> 00:20:52,130
parse this information so let's try to

00:20:48,830 --> 00:20:55,159
open this two guys here yeah okay cool

00:20:52,130 --> 00:20:57,980
cool right so notice that you have this

00:20:55,159 --> 00:21:00,649
long list of things over here and this

00:20:57,980 --> 00:21:04,490
is the function that when you called

00:21:00,649 --> 00:21:05,840
defer this is the sort of under the

00:21:04,490 --> 00:21:09,230
under the hood function that gets in

00:21:05,840 --> 00:21:11,630
executed and back burner right so again

00:21:09,230 --> 00:21:15,860
so you look at that which is like all

00:21:11,630 --> 00:21:17,330
right what and you CD opt write

00:21:15,860 --> 00:21:19,880
something like it's something really bad

00:21:17,330 --> 00:21:24,399
I guess it doesn't tell you anything

00:21:19,880 --> 00:21:27,980
right so for JavaScript engineers he

00:21:24,399 --> 00:21:30,039
what what okay cool google so for

00:21:27,980 --> 00:21:33,559
javascript engineers he actually

00:21:30,039 --> 00:21:40,669
implemented this source view rights and

00:21:33,559 --> 00:21:42,289
what is happening this is the D

00:21:40,669 --> 00:21:44,000
optimization that happened that happens

00:21:42,289 --> 00:21:50,059
right so and this is where it gets

00:21:44,000 --> 00:21:51,649
tricky it's it's a tricky tricky problem

00:21:50,059 --> 00:21:56,139
i would say and that's a known issue in

00:21:51,649 --> 00:21:58,549
VA basically what it does it thinks

00:21:56,139 --> 00:21:59,280
anyway that doesn't I don't want to dive

00:21:58,549 --> 00:22:02,370
into details

00:21:59,280 --> 00:22:07,910
basically having that having that in

00:22:02,370 --> 00:22:10,860
place you can you can understand what

00:22:07,910 --> 00:22:13,620
what is happening under under the hood

00:22:10,860 --> 00:22:15,210
of we ate and why or why the deer

00:22:13,620 --> 00:22:21,090
formulations happen so in this

00:22:15,210 --> 00:22:29,400
particular case doesn't there's a notion

00:22:21,090 --> 00:22:30,570
of what do you call it I figure out what

00:22:29,400 --> 00:22:34,470
what the function is called but

00:22:30,570 --> 00:22:36,540
basically when v8 works with with one

00:22:34,470 --> 00:22:39,690
assumption so in this particular case

00:22:36,540 --> 00:22:44,430
like this means that the assumption that

00:22:39,690 --> 00:22:46,470
v8 made before is invalidated now so now

00:22:44,430 --> 00:22:51,060
it has to spend some time d optimizing

00:22:46,470 --> 00:22:56,220
the code and returning to non non ti up

00:22:51,060 --> 00:22:59,550
to my slow code it has some you know

00:22:56,220 --> 00:23:02,610
some road to go and some it's not

00:22:59,550 --> 00:23:06,210
perfect but it actually tells you you

00:23:02,610 --> 00:23:08,280
can figure out with a little reading of

00:23:06,210 --> 00:23:11,310
like what is what is happening what does

00:23:08,280 --> 00:23:17,790
it mean or ping somebody on the emailing

00:23:11,310 --> 00:23:20,940
list of VA so and say you figured out

00:23:17,790 --> 00:23:24,210
the problem or you know or you are even

00:23:20,940 --> 00:23:29,220
better you fix the problem so you kind

00:23:24,210 --> 00:23:31,710
of know that you fix the problem you

00:23:29,220 --> 00:23:37,890
improve the performance right so how do

00:23:31,710 --> 00:23:39,210
i I don't I make sure that how do i test

00:23:37,890 --> 00:23:42,690
that how do i run it in the long run

00:23:39,210 --> 00:23:46,170
right or how do I compare two

00:23:42,690 --> 00:23:47,910
implementations so there's one thing

00:23:46,170 --> 00:23:49,620
there's one little library that I wrote

00:23:47,910 --> 00:23:52,710
I'm still kind of poking poking around

00:23:49,620 --> 00:23:54,510
that it's called perform so basically

00:23:52,710 --> 00:23:56,370
what it allows you to do it allows you

00:23:54,510 --> 00:24:02,040
to have two different implementations

00:23:56,370 --> 00:24:04,200
and one benchmark so so let's say we

00:24:02,040 --> 00:24:07,260
have implementation called master which

00:24:04,200 --> 00:24:09,180
is an implementation of your library in

00:24:07,260 --> 00:24:10,800
this case it's back burner and then you

00:24:09,180 --> 00:24:13,049
have different benchmarks which is in

00:24:10,800 --> 00:24:20,999
this case defer differ once

00:24:13,049 --> 00:24:23,730
some of them i created whoa okay so they

00:24:20,999 --> 00:24:28,739
look sort of like that so this is the

00:24:23,730 --> 00:24:30,419
es6 modules syntax you have a name then

00:24:28,739 --> 00:24:35,249
you have the initialize function with

00:24:30,419 --> 00:24:37,950
which is going to give you the which is

00:24:35,249 --> 00:24:41,429
going to give you this object over here

00:24:37,950 --> 00:24:43,440
they'd be b1 which is a back burner so

00:24:41,429 --> 00:24:46,440
having the initialize function you can

00:24:43,440 --> 00:24:49,739
pass values to your to your to your to

00:24:46,440 --> 00:24:53,029
your actual tasks like this so and this

00:24:49,739 --> 00:25:00,659
is the actual task that you're running

00:24:53,029 --> 00:25:05,489
so all right okay so basically what

00:25:00,659 --> 00:25:07,850
allows you to do along just magical

00:25:05,489 --> 00:25:07,850
command

00:25:12,350 --> 00:25:18,200
alright

00:25:15,049 --> 00:25:20,690
right so it just took one of the

00:25:18,200 --> 00:25:23,570
benchmarks which is the q q 1 and

00:25:20,690 --> 00:25:27,710
adrenaline run it with implementation of

00:25:23,570 --> 00:25:28,940
master so if you want to know like if

00:25:27,710 --> 00:25:32,480
you want to start poking around with a

00:25:28,940 --> 00:25:35,269
code and like try to figure out what our

00:25:32,480 --> 00:25:37,909
benchmarks the pitfalls and etc you can

00:25:35,269 --> 00:25:41,690
create a new implementation so let's

00:25:37,909 --> 00:25:46,190
call it to week maybe come on there you

00:25:41,690 --> 00:25:50,179
go so it's going to be a copy right and

00:25:46,190 --> 00:25:51,409
the copy is that the copy that you're

00:25:50,179 --> 00:25:54,129
going to be changing in order to improve

00:25:51,409 --> 00:25:57,169
your code so you have one canonical

00:25:54,129 --> 00:26:01,399
master implementation and then you have

00:25:57,169 --> 00:26:03,080
this two-week one so now what you're

00:26:01,399 --> 00:26:05,450
looking at is that actually it took the

00:26:03,080 --> 00:26:09,919
same benchmark and run it against two

00:26:05,450 --> 00:26:14,509
implementations so it's it's actually an

00:26:09,919 --> 00:26:17,929
easy way to well first identify what the

00:26:14,509 --> 00:26:21,919
problem is using v8 and that I our hydro

00:26:17,929 --> 00:26:24,320
tool and then making sure that when you

00:26:21,919 --> 00:26:32,169
change when you change the code it

00:26:24,320 --> 00:26:37,730
actually reflects the D optimization so

00:26:32,169 --> 00:26:40,009
do you do I guess that would be it step

00:26:37,730 --> 00:26:41,869
that will be it for demo and that would

00:26:40,009 --> 00:26:44,109
be it for talk so thanks thanks you guys

00:26:41,869 --> 00:26:44,109
for listening

00:27:15,040 --> 00:27:17,100

YouTube URL: https://www.youtube.com/watch?v=pnM3JlqCQX8


