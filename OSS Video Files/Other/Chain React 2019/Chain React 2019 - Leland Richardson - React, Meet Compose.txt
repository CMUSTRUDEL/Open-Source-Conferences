Title: Chain React 2019 - Leland Richardson - React, Meet Compose
Publication date: 2019-08-06
Playlist: Chain React 2019
Description: 
	Jetpack Compose is a new declarative UI framework that is being developed in the open for Android. It has a very similar programming model to React, and this talk will dive deep into the internals of both to explain the similarities and differences in the architectures of both, and how React Native might be able to leverage some of this technology long term.

https://speakerdeck.com/lelandrichardson/react-meet-compose
Captions: 
	00:00:00,000 --> 00:00:16,800
I just a heads up some of my slides are

00:00:14,969 --> 00:00:20,699
gonna have code on the sides of the

00:00:16,800 --> 00:00:32,099
screen if anyone wants to scoot in early

00:00:20,699 --> 00:00:33,870
on now would be the time to do so cool

00:00:32,099 --> 00:00:36,809
so it's really great to be here my name

00:00:33,870 --> 00:00:39,300
is Leland Richardson as Jason said I I

00:00:36,809 --> 00:00:42,090
work at Google I work on the Android UI

00:00:39,300 --> 00:00:47,640
toolkit team on a project called jetpack

00:00:42,090 --> 00:00:50,300
compose so show of hands that who here

00:00:47,640 --> 00:00:54,570
has actually heard of jetpack compose

00:00:50,300 --> 00:00:58,340
okay some people so let's let's dive in

00:00:54,570 --> 00:01:00,870
and say okay what is what is compose

00:00:58,340 --> 00:01:04,170
so first and foremost compose is a

00:01:00,870 --> 00:01:06,840
declarative UI runtime it's a component

00:01:04,170 --> 00:01:09,720
based UI framework much like react in

00:01:06,840 --> 00:01:11,580
fact many of the api's were inspired by

00:01:09,720 --> 00:01:13,970
react and other frameworks that you're

00:01:11,580 --> 00:01:17,130
probably familiar with

00:01:13,970 --> 00:01:19,439
it's a Kotlin compiler plug-in as well

00:01:17,130 --> 00:01:22,049
so we we do some compile time opt

00:01:19,439 --> 00:01:25,080
optimizations and we actually plug flee

00:01:22,049 --> 00:01:26,670
into the Colin compiler and so that

00:01:25,080 --> 00:01:29,070
means that if you want to use Jeff I

00:01:26,670 --> 00:01:31,770
compose you do need to write your code

00:01:29,070 --> 00:01:34,650
in Kotlin and Kotlin if you're not

00:01:31,770 --> 00:01:37,200
familiar with it is the is the language

00:01:34,650 --> 00:01:41,240
that you can use for Android it is now

00:01:37,200 --> 00:01:46,040
Android is now in Colin first platform

00:01:41,240 --> 00:01:48,329
and Jeff had composed is built by the

00:01:46,040 --> 00:01:50,909
it's built by Google it's built by the

00:01:48,329 --> 00:01:53,100
thread UI toolkit team themselves so

00:01:50,909 --> 00:01:58,320
this is the same people that maintain

00:01:53,100 --> 00:02:00,780
view dot Java for instance now compose

00:01:58,320 --> 00:02:02,909
is sort of like three parts there's the

00:02:00,780 --> 00:02:05,060
runtime there's the compiler and then

00:02:02,909 --> 00:02:07,860
there's also what we call compose UI and

00:02:05,060 --> 00:02:11,250
compose UI is a complete ground-up

00:02:07,860 --> 00:02:13,860
rewrite of the Android UI toolkit and so

00:02:11,250 --> 00:02:15,960
this means that the entire

00:02:13,860 --> 00:02:18,300
UI framework that you think of when you

00:02:15,960 --> 00:02:20,310
think of Android is sort of actively

00:02:18,300 --> 00:02:24,780
being rewritten on top of this new

00:02:20,310 --> 00:02:26,460
programming model and runtime this is a

00:02:24,780 --> 00:02:27,840
really big undertaking but I'm actually

00:02:26,460 --> 00:02:29,700
not going to be talking much about this

00:02:27,840 --> 00:02:32,730
today and I'm mostly going to be

00:02:29,700 --> 00:02:34,730
focusing on the runtime and how it works

00:02:32,730 --> 00:02:38,040
and what that might mean to you

00:02:34,730 --> 00:02:39,810
so compose UI and the runtime and

00:02:38,040 --> 00:02:41,580
everything else is completely unbundled

00:02:39,810 --> 00:02:44,550
from the underlying Android operating

00:02:41,580 --> 00:02:46,560
system we do this for several reasons

00:02:44,550 --> 00:02:49,050
but a big one is just so that we can

00:02:46,560 --> 00:02:51,660
actually iterate on things and release

00:02:49,050 --> 00:02:53,400
new features and so people like you

00:02:51,660 --> 00:02:54,989
don't have to wait for phone

00:02:53,400 --> 00:02:56,520
manufacturers or anything like that to

00:02:54,989 --> 00:03:01,020
upgrade the operating system it's just a

00:02:56,520 --> 00:03:01,560
user space library and it's also open

00:03:01,020 --> 00:03:03,540
source

00:03:01,560 --> 00:03:05,720
so as of Google i/o we started

00:03:03,540 --> 00:03:08,370
developing working on this in the open

00:03:05,720 --> 00:03:10,440
and so you can go and kind of see what

00:03:08,370 --> 00:03:11,870
what we're working on how things work if

00:03:10,440 --> 00:03:15,630
you really want to dive into it

00:03:11,870 --> 00:03:18,120
contribute any of that but the kicker is

00:03:15,630 --> 00:03:22,640
it's really not ready to use it

00:03:18,120 --> 00:03:25,170
it's not even alpha its pre alpha so if

00:03:22,640 --> 00:03:28,769
you know look at this talk as me just

00:03:25,170 --> 00:03:30,060
sort of talking about it and sort of

00:03:28,769 --> 00:03:31,950
things that I find interesting and I

00:03:30,060 --> 00:03:33,570
think you might find interesting not

00:03:31,950 --> 00:03:37,530
trying to sell it to you right now is

00:03:33,570 --> 00:03:39,450
like a thing to actually use so

00:03:37,530 --> 00:03:42,959
obviously I'm pretty excited about this

00:03:39,450 --> 00:03:44,820
I work on it but here I am at a react

00:03:42,959 --> 00:03:47,459
conference and I'm talking about this

00:03:44,820 --> 00:03:49,769
Android thing and some of you might be

00:03:47,459 --> 00:03:52,910
like well why is he here talking about

00:03:49,769 --> 00:03:55,890
this how is this actually relevant to me

00:03:52,910 --> 00:03:57,690
and that that might be a fair question

00:03:55,890 --> 00:04:00,989
I assume some people in the audience

00:03:57,690 --> 00:04:06,630
might be Android developers maybe in a

00:04:00,989 --> 00:04:08,610
past life things like that but I I think

00:04:06,630 --> 00:04:11,760
really I just want us to take a step

00:04:08,610 --> 00:04:15,870
back and really look at the mobile UI

00:04:11,760 --> 00:04:17,070
development landscape right now and some

00:04:15,870 --> 00:04:21,750
of you might be aware that recently

00:04:17,070 --> 00:04:23,880
Apple released Swift UI and so this is

00:04:21,750 --> 00:04:25,590
pretty interesting what we're starting

00:04:23,880 --> 00:04:27,690
to see just in the last couple of months

00:04:25,590 --> 00:04:29,550
is that

00:04:27,690 --> 00:04:32,520
like three of the world's largest

00:04:29,550 --> 00:04:35,670
companies are investing a ton of time

00:04:32,520 --> 00:04:39,600
into declarative UI frameworks and

00:04:35,670 --> 00:04:41,010
really this kind of represents I don't

00:04:39,600 --> 00:04:44,030
know I think that we've like past an

00:04:41,010 --> 00:04:47,520
inflection point declarative UI is now

00:04:44,030 --> 00:04:50,220
the way to build UI and that that's kind

00:04:47,520 --> 00:04:51,510
of cool because we you know I I was a

00:04:50,220 --> 00:04:55,830
big part of the react community for a

00:04:51,510 --> 00:04:57,660
long time still AM I think and it's it's

00:04:55,830 --> 00:04:59,160
kind of like hey we were right like this

00:04:57,660 --> 00:05:02,220
is this is a really powerful way to do

00:04:59,160 --> 00:05:03,840
things people are taking notice and so

00:05:02,220 --> 00:05:06,300
this is this is a really cool time and

00:05:03,840 --> 00:05:09,630
so I kind of want to try and play my

00:05:06,300 --> 00:05:11,700
part in that time and kind of introduce

00:05:09,630 --> 00:05:15,060
all of you to compose and really talk

00:05:11,700 --> 00:05:17,360
about how in this environment we're a

00:05:15,060 --> 00:05:20,010
big company you know said hey let's

00:05:17,360 --> 00:05:21,570
let's build something and invest a lot

00:05:20,010 --> 00:05:23,250
of time and energy into making it the

00:05:21,570 --> 00:05:25,020
right thing how does that look different

00:05:23,250 --> 00:05:28,470
from react and how does it look similar

00:05:25,020 --> 00:05:30,810
and I think there's really a lot of

00:05:28,470 --> 00:05:32,880
interesting differences here and so this

00:05:30,810 --> 00:05:39,450
talk is actually kind of a technical

00:05:32,880 --> 00:05:42,240
deep dive so get get prepared jetpack

00:05:39,450 --> 00:05:45,300
compose has a very similar programming

00:05:42,240 --> 00:05:47,190
model to react it you'll see some slides

00:05:45,300 --> 00:05:50,250
soon it should look fairly familiar to

00:05:47,190 --> 00:05:52,050
you but the execution model is actually

00:05:50,250 --> 00:05:53,130
quite different and so we're going to

00:05:52,050 --> 00:05:55,760
talk about some of those differences and

00:05:53,130 --> 00:05:59,130
what they mean

00:05:55,760 --> 00:06:00,810
both compose and reacts have a kind of

00:05:59,130 --> 00:06:03,540
target functions as the fundamental

00:06:00,810 --> 00:06:05,010
building block function components are

00:06:03,540 --> 00:06:07,710
our thing and react and they're actually

00:06:05,010 --> 00:06:11,160
the only thing in compose and so to turn

00:06:07,710 --> 00:06:14,370
a function into a component you annotate

00:06:11,160 --> 00:06:15,690
it with a composable annotation and we

00:06:14,370 --> 00:06:18,150
can see here this is caught one on the

00:06:15,690 --> 00:06:21,000
right looks pretty similar react

00:06:18,150 --> 00:06:23,670
actually you pass it in a props object

00:06:21,000 --> 00:06:27,030
it's kind of one big bag of properties

00:06:23,670 --> 00:06:30,170
whereas in composed we actually use the

00:06:27,030 --> 00:06:34,530
individual parameters as the properties

00:06:30,170 --> 00:06:36,419
and so here's where things start to get

00:06:34,530 --> 00:06:38,430
interesting if you look on the

00:06:36,419 --> 00:06:41,580
right-hand side there's sort of a an

00:06:38,430 --> 00:06:43,260
ominously missing return statement

00:06:41,580 --> 00:06:47,130
so in react you actually return the

00:06:43,260 --> 00:06:47,850
result of JSX right you returned a blob

00:06:47,130 --> 00:06:49,770
of GSX

00:06:47,850 --> 00:06:52,800
and composed you actually just execute

00:06:49,770 --> 00:06:54,180
other composable functions and it kind

00:06:52,800 --> 00:06:56,610
of does the same thing and you can kind

00:06:54,180 --> 00:06:58,919
of think of it very similarly the two

00:06:56,610 --> 00:07:01,760
pieces of code looked the same and

00:06:58,919 --> 00:07:05,460
actually you can kind of think that the

00:07:01,760 --> 00:07:08,220
JSX element itself is kind of like an

00:07:05,460 --> 00:07:11,010
invocation of a composable function and

00:07:08,220 --> 00:07:15,240
we can kind of see the similarities here

00:07:11,010 --> 00:07:17,190
on both sides now when we're just

00:07:15,240 --> 00:07:18,810
invoking functions how do we kind of

00:07:17,190 --> 00:07:20,250
make it look structural we're kind of

00:07:18,810 --> 00:07:23,280
building trees and we want it to feel

00:07:20,250 --> 00:07:27,090
that way and you can actually see here

00:07:23,280 --> 00:07:28,979
in Kotlin we have these curly braces to

00:07:27,090 --> 00:07:32,400
the right of the the function call and

00:07:28,979 --> 00:07:34,139
that's actually syntax for a lambda but

00:07:32,400 --> 00:07:36,539
the lambda in this syntax which is

00:07:34,139 --> 00:07:39,000
called trailing lambda syntax is

00:07:36,539 --> 00:07:41,039
implicitly passed into the function as

00:07:39,000 --> 00:07:43,650
the last parameter to that function and

00:07:41,039 --> 00:07:46,710
so this kind of gives us this structural

00:07:43,650 --> 00:07:48,780
nesting of elements that that kind of

00:07:46,710 --> 00:07:50,789
looks familiar and so this means that if

00:07:48,780 --> 00:07:53,460
you're a composable function and you

00:07:50,789 --> 00:07:55,770
want to accept children you would add a

00:07:53,460 --> 00:07:58,110
children parameter or any name that you

00:07:55,770 --> 00:08:01,410
want and the type of that would be a

00:07:58,110 --> 00:08:03,599
composable lambda and so we can see that

00:08:01,410 --> 00:08:08,669
over here we would kind of be how that

00:08:03,599 --> 00:08:10,680
would work so we're now kind of seeing

00:08:08,669 --> 00:08:12,990
some of these differences in compose I

00:08:10,680 --> 00:08:15,180
actually execute these functions whereas

00:08:12,990 --> 00:08:16,740
in react I'm returning this data

00:08:15,180 --> 00:08:19,590
structure and a lot of a lot of you may

00:08:16,740 --> 00:08:21,570
have heard this referred to as a virtual

00:08:19,590 --> 00:08:22,919
Dom or something this is this is

00:08:21,570 --> 00:08:27,270
basically a lightweight data structure

00:08:22,919 --> 00:08:29,820
that JSX creates for you and the

00:08:27,270 --> 00:08:32,580
equivalent in compose isn't really there

00:08:29,820 --> 00:08:33,839
we're not returning anything but we do

00:08:32,580 --> 00:08:36,479
need to do a lot of the same things that

00:08:33,839 --> 00:08:39,000
react does which is you know kind of

00:08:36,479 --> 00:08:42,570
handle inserts and deletes and moves and

00:08:39,000 --> 00:08:43,709
the sort of reconciliation pass and the

00:08:42,570 --> 00:08:46,230
way we do that is we actually store

00:08:43,709 --> 00:08:49,290
things in a linear array and that array

00:08:46,230 --> 00:08:50,940
is getting passed around by the compiler

00:08:49,290 --> 00:08:52,770
all that has kind of done for you and

00:08:50,940 --> 00:08:54,860
we're going to show you a little bit of

00:08:52,770 --> 00:08:54,860
that

00:08:55,170 --> 00:09:00,029
so also when you're building sort of

00:08:57,960 --> 00:09:02,250
these.you is you need to introduce state

00:09:00,029 --> 00:09:06,660
at some point and react you can do that

00:09:02,250 --> 00:09:08,400
with a use state hook and and compose

00:09:06,660 --> 00:09:10,590
you have a similar sort of concept

00:09:08,400 --> 00:09:14,190
there's a state function for instance

00:09:10,590 --> 00:09:15,570
that returns a value and you can use

00:09:14,190 --> 00:09:17,880
that as state and you can see how these

00:09:15,570 --> 00:09:19,890
look pretty similar you can even make it

00:09:17,880 --> 00:09:22,410
more similar if you want to using

00:09:19,890 --> 00:09:24,360
Cullen's destructuring syntax but

00:09:22,410 --> 00:09:28,680
basically the the programming model

00:09:24,360 --> 00:09:31,650
Hulett here is the same so let's go into

00:09:28,680 --> 00:09:34,730
this execution model which we're seeing

00:09:31,650 --> 00:09:37,890
now is kind of a little different a

00:09:34,730 --> 00:09:40,260
primary sort of data structure that we

00:09:37,890 --> 00:09:42,870
use for compose it's actually called a

00:09:40,260 --> 00:09:45,270
gap buffer if any of you have heard of a

00:09:42,870 --> 00:09:47,490
gap buffer it's commonly used in text

00:09:45,270 --> 00:09:50,190
editors it's a data structure that

00:09:47,490 --> 00:09:52,860
allows you to efficiently update text in

00:09:50,190 --> 00:09:56,220
the context of editing but we actually

00:09:52,860 --> 00:09:58,260
use it for our runtime and internally we

00:09:56,220 --> 00:09:59,580
we sort of call it a slot table so you

00:09:58,260 --> 00:10:02,220
might hear me say that

00:09:59,580 --> 00:10:05,310
so slot table gap buffer kind of the

00:10:02,220 --> 00:10:08,280
same thing and this gap buffer

00:10:05,310 --> 00:10:11,600
represents a sort of a linear collection

00:10:08,280 --> 00:10:14,880
of items underlying it is a flat array

00:10:11,600 --> 00:10:18,839
contiguous array in memory and here I'm

00:10:14,880 --> 00:10:20,610
just representing an empty one and that

00:10:18,839 --> 00:10:23,640
empty part of the array is sort of

00:10:20,610 --> 00:10:26,400
considered the gap and if I want to

00:10:23,640 --> 00:10:27,420
start inserting items into this array I

00:10:26,400 --> 00:10:30,030
can do that

00:10:27,420 --> 00:10:32,160
and keep adding items and the gap

00:10:30,030 --> 00:10:34,710
essentially gets smaller right I don't

00:10:32,160 --> 00:10:38,100
have those items or I don't have those

00:10:34,710 --> 00:10:40,020
slots in the array to use so minister

00:10:38,100 --> 00:10:44,100
these items what if I want to go back

00:10:40,020 --> 00:10:46,890
and start running code on top of that

00:10:44,100 --> 00:10:48,150
array what I can do is if I want to keep

00:10:46,890 --> 00:10:50,490
the same item in there I can just

00:10:48,150 --> 00:10:52,440
increment an index if I want to update

00:10:50,490 --> 00:10:54,450
night them in there I can change it and

00:10:52,440 --> 00:10:57,150
then if I want to insert items I

00:10:54,450 --> 00:10:59,610
actually first move the gap to that

00:10:57,150 --> 00:11:01,800
index and then I can insert an item I

00:10:59,610 --> 00:11:04,520
can insert more items and sort of keep

00:11:01,800 --> 00:11:06,959
going and so the point here is that

00:11:04,520 --> 00:11:08,420
essentially every operate every array

00:11:06,959 --> 00:11:11,480
based operation here

00:11:08,420 --> 00:11:13,579
is constant time the only thing that is

00:11:11,480 --> 00:11:15,320
not constant time is moving the gap and

00:11:13,579 --> 00:11:18,110
so the bet that we're making is that

00:11:15,320 --> 00:11:20,870
most you eyes don't change structurally

00:11:18,110 --> 00:11:22,670
all that often and so we won't have to

00:11:20,870 --> 00:11:24,800
move the gap all that often and we do

00:11:22,670 --> 00:11:26,959
it'll be kind of be good for that big

00:11:24,800 --> 00:11:29,899
insert and so this is sort of the the

00:11:26,959 --> 00:11:31,579
trade-off that we're making so we want

00:11:29,899 --> 00:11:34,640
to see how that looks in practice let's

00:11:31,579 --> 00:11:37,040
take this counter component and let's do

00:11:34,640 --> 00:11:38,810
the sugar the syntax a little bit so I

00:11:37,040 --> 00:11:40,820
took away that composable annotation and

00:11:38,810 --> 00:11:41,990
then I added these parameters to the

00:11:40,820 --> 00:11:44,930
function and that's kind of what our

00:11:41,990 --> 00:11:47,390
compiler is doing to a real simple level

00:11:44,930 --> 00:11:50,149
and then we're adding some calls to this

00:11:47,390 --> 00:11:52,700
synthetic composer parameter in the body

00:11:50,149 --> 00:11:55,000
of the function and I'm going to kind of

00:11:52,700 --> 00:11:57,980
walk you through what that's doing and

00:11:55,000 --> 00:11:59,990
you can see that also the I have taken

00:11:57,980 --> 00:12:02,300
that composer parameter and I've passed

00:11:59,990 --> 00:12:03,649
it in to all of the other composable

00:12:02,300 --> 00:12:05,600
functions that I'm calling in the body

00:12:03,649 --> 00:12:07,790
so the compiler kind of threads it

00:12:05,600 --> 00:12:11,269
through for you but in addition to that

00:12:07,790 --> 00:12:14,420
I my compiler has added these integers

00:12:11,269 --> 00:12:16,790
and there's just these kind of numbers

00:12:14,420 --> 00:12:19,550
the the way you should think of them is

00:12:16,790 --> 00:12:22,160
that they're sort of like a hash of the

00:12:19,550 --> 00:12:25,940
unique source position for the call site

00:12:22,160 --> 00:12:27,980
of that composable function and so this

00:12:25,940 --> 00:12:32,839
number kind of uniquely identifies its

00:12:27,980 --> 00:12:36,529
position in the code so when we're

00:12:32,839 --> 00:12:38,360
executing through this function we run

00:12:36,529 --> 00:12:41,600
in the composer at start kind of stores

00:12:38,360 --> 00:12:43,310
this group object into the array we go

00:12:41,600 --> 00:12:45,079
and call state and it's going to store

00:12:43,310 --> 00:12:47,300
another group into the array with one

00:12:45,079 --> 00:12:49,579
two three and then state itself might do

00:12:47,300 --> 00:12:52,670
something and it's gonna store this

00:12:49,579 --> 00:12:54,649
state value in the table then we move on

00:12:52,670 --> 00:12:56,390
to button and it's gonna create another

00:12:54,649 --> 00:12:59,449
group and it's gonna start storing these

00:12:56,390 --> 00:13:02,120
parameters and then the actual button

00:12:59,449 --> 00:13:03,560
function itself might go and do a bunch

00:13:02,120 --> 00:13:04,550
of other stuff but we're not going into

00:13:03,560 --> 00:13:06,880
that but we're just going to represent

00:13:04,550 --> 00:13:10,449
it here in the bottom of the array so

00:13:06,880 --> 00:13:14,000
we've gone through this component and

00:13:10,449 --> 00:13:15,890
the way to look at this is that the the

00:13:14,000 --> 00:13:17,420
execution of all of these functions that

00:13:15,890 --> 00:13:19,399
I'm doing sort of form an implicit

00:13:17,420 --> 00:13:22,160
hierarchy it's like the execution graph

00:13:19,399 --> 00:13:26,210
of my entire UI

00:13:22,160 --> 00:13:28,700
and that graph that that tree is stored

00:13:26,210 --> 00:13:32,000
in this array sort of as like a

00:13:28,700 --> 00:13:33,530
depth-first traversal of it but we're

00:13:32,000 --> 00:13:36,800
actually taking up a lot of room with

00:13:33,530 --> 00:13:38,960
these groups here and it's kind of

00:13:36,800 --> 00:13:41,360
unclear why they're needed so the the

00:13:38,960 --> 00:13:43,550
groups are actually needed to deal with

00:13:41,360 --> 00:13:47,900
the shape of that graph changing over

00:13:43,550 --> 00:13:49,490
time and in react this is kind of what

00:13:47,900 --> 00:13:52,640
the virtual DOM is used for it's to

00:13:49,490 --> 00:13:54,200
understand when something changes but

00:13:52,640 --> 00:13:56,540
here since we're a compiler we can

00:13:54,200 --> 00:13:58,220
actually know kind of statically when

00:13:56,540 --> 00:14:00,110
one of those things is going to change

00:13:58,220 --> 00:14:02,120
and when it's not it turns out these

00:14:00,110 --> 00:14:04,790
groups are almost never needed they're

00:14:02,120 --> 00:14:07,970
actually only needed for control flow so

00:14:04,790 --> 00:14:10,220
in most cases we don't need to put them

00:14:07,970 --> 00:14:11,480
in there but let's look at an example

00:14:10,220 --> 00:14:14,810
where we do need to put them in there

00:14:11,480 --> 00:14:17,690
which is for control flow one such

00:14:14,810 --> 00:14:20,450
example is an if statement and so here

00:14:17,690 --> 00:14:23,270
we have a component that gets in data if

00:14:20,450 --> 00:14:25,070
that is null it renders the loading like

00:14:23,270 --> 00:14:28,310
screen or something and then if it's not

00:14:25,070 --> 00:14:30,680
and all it renders something else so the

00:14:28,310 --> 00:14:33,110
kind of D sugared version of this from

00:14:30,680 --> 00:14:34,820
the compiler is going to look something

00:14:33,110 --> 00:14:37,070
like this and actually each block of the

00:14:34,820 --> 00:14:39,230
F is going to have its own little group

00:14:37,070 --> 00:14:41,390
like we had before and we see that we no

00:14:39,230 --> 00:14:44,420
longer need to pass in a key to the

00:14:41,390 --> 00:14:46,010
function so if we go through here we're

00:14:44,420 --> 00:14:48,520
basically going to create a group call

00:14:46,010 --> 00:14:51,950
loading and then we're kind of done and

00:14:48,520 --> 00:14:53,960
that's that's how this sort of part of

00:14:51,950 --> 00:14:56,840
the UI is representing in the graph if

00:14:53,960 --> 00:14:58,430
we go back and now there's data we're

00:14:56,840 --> 00:15:01,700
going to enter in a different block of

00:14:58,430 --> 00:15:04,190
the if and so at this point the runtime

00:15:01,700 --> 00:15:07,130
is going to look at the the integer here

00:15:04,190 --> 00:15:09,800
the key see four five six doesn't equal

00:15:07,130 --> 00:15:11,750
one two three and at this point it knows

00:15:09,800 --> 00:15:13,220
that it needs to make a change and it

00:15:11,750 --> 00:15:15,470
knows that the structure of the UI has

00:15:13,220 --> 00:15:17,810
changed and so what we're going to do is

00:15:15,470 --> 00:15:19,850
we're gonna move the gap up up to the

00:15:17,810 --> 00:15:21,050
current position and then we're

00:15:19,850 --> 00:15:23,030
essentially going to remove the the

00:15:21,050 --> 00:15:26,240
group from before and start adding the

00:15:23,030 --> 00:15:28,160
new one and and this gets stored in the

00:15:26,240 --> 00:15:30,920
array like so and so we can see that

00:15:28,160 --> 00:15:34,310
these groups are important for control

00:15:30,920 --> 00:15:35,480
flow like for loops if if statements

00:15:34,310 --> 00:15:38,379
stuff like that

00:15:35,480 --> 00:15:41,239
but actually almost nowhere else and

00:15:38,379 --> 00:15:43,129
that that's that's pretty valuable now

00:15:41,239 --> 00:15:46,009
we've saved a lot of space and we've

00:15:43,129 --> 00:15:49,790
kind of learned how to utilize this this

00:15:46,009 --> 00:15:52,759
backing cache while still having

00:15:49,790 --> 00:15:55,069
arbitrary control flow and this concept

00:15:52,759 --> 00:15:58,970
is what we call positional memorization

00:15:55,069 --> 00:16:02,600
so the this combination of using a gap

00:15:58,970 --> 00:16:05,359
buffer cache and then using the

00:16:02,600 --> 00:16:07,339
execution of kind of arbitrary code and

00:16:05,359 --> 00:16:09,980
and having that backing cache threaded

00:16:07,339 --> 00:16:11,689
through the the concept positional

00:16:09,980 --> 00:16:14,809
memoization is what we came up with and

00:16:11,689 --> 00:16:17,209
this is basically the fundamental piece

00:16:14,809 --> 00:16:19,309
of compose this is what compose is built

00:16:17,209 --> 00:16:22,609
on and so let's look at a more

00:16:19,309 --> 00:16:24,859
elementary example memoization if that's

00:16:22,609 --> 00:16:26,509
an unfamiliar term for you it's

00:16:24,859 --> 00:16:28,429
basically just a fancy word for caching

00:16:26,509 --> 00:16:31,279
the result of a function based on the

00:16:28,429 --> 00:16:32,959
inputs of the function and so here would

00:16:31,279 --> 00:16:34,089
be a common example of where memoization

00:16:32,959 --> 00:16:37,819
might make sense

00:16:34,089 --> 00:16:41,299
we've got an app component we've got

00:16:37,819 --> 00:16:43,789
items and a query string and then inside

00:16:41,299 --> 00:16:45,679
the body of our function were doing some

00:16:43,789 --> 00:16:48,169
computational work in this case we're

00:16:45,679 --> 00:16:50,049
like filtering a list based on a query

00:16:48,169 --> 00:16:52,299
and getting a refined set of results

00:16:50,049 --> 00:16:54,649
what we can do is we can wrap that

00:16:52,299 --> 00:16:58,429
calculation with a call to this function

00:16:54,649 --> 00:16:59,749
called memo and we're passing that in

00:16:58,429 --> 00:17:02,629
and we're assuming that this this code

00:16:59,749 --> 00:17:04,699
works basically the same way and it does

00:17:02,629 --> 00:17:06,769
that by using this gap buffer cache that

00:17:04,699 --> 00:17:09,860
we're we're talking about so when we run

00:17:06,769 --> 00:17:12,769
in the memo we store the input so we

00:17:09,860 --> 00:17:14,539
store items into the cache and we store

00:17:12,769 --> 00:17:17,720
the the query parameter these are the

00:17:14,539 --> 00:17:19,970
inputs and since we haven't ever run

00:17:17,720 --> 00:17:21,409
this component before we also have to

00:17:19,970 --> 00:17:23,750
run the calculation and we're going to

00:17:21,409 --> 00:17:26,059
store the result and then we get it back

00:17:23,750 --> 00:17:29,600
and then we just kind of continue but

00:17:26,059 --> 00:17:30,889
the next time we run this function we're

00:17:29,600 --> 00:17:34,250
going to have that we're gonna be at the

00:17:30,889 --> 00:17:36,529
same position of that of that array and

00:17:34,250 --> 00:17:38,960
so we're going to go and instead of

00:17:36,529 --> 00:17:41,269
storing items we're gonna first check to

00:17:38,960 --> 00:17:43,730
see if it matches the the previous

00:17:41,269 --> 00:17:46,100
execution and if it does we're gonna

00:17:43,730 --> 00:17:47,960
check the next one and if that does then

00:17:46,100 --> 00:17:49,280
we don't need to run the calculation we

00:17:47,960 --> 00:17:53,060
can just pull out there's

00:17:49,280 --> 00:17:54,800
and throw it back and so this memo

00:17:53,060 --> 00:17:56,930
function is kind of like a very

00:17:54,800 --> 00:18:00,500
fundamental piece for how we can start

00:17:56,930 --> 00:18:05,180
to to kind of efficiently build up

00:18:00,500 --> 00:18:06,740
maintain and update our UI and one of

00:18:05,180 --> 00:18:09,290
the interesting pieces of this is

00:18:06,740 --> 00:18:12,250
actually a sort of a degenerate case for

00:18:09,290 --> 00:18:14,660
memoization let's imagine that we took

00:18:12,250 --> 00:18:17,900
memo and we actually memorized a

00:18:14,660 --> 00:18:19,790
calculation that wasn't pure and it

00:18:17,900 --> 00:18:21,940
wasn't really expected to be so here

00:18:19,790 --> 00:18:24,110
we're memorizing math not random and

00:18:21,940 --> 00:18:26,720
this actually kind of changes the

00:18:24,110 --> 00:18:28,580
semantics of the code what what happens

00:18:26,720 --> 00:18:31,400
now is that we've we've generated a

00:18:28,580 --> 00:18:33,530
random number but now we're gonna keep

00:18:31,400 --> 00:18:38,330
reusing that same random number each

00:18:33,530 --> 00:18:41,180
time each each time the the hierarchy

00:18:38,330 --> 00:18:44,540
sort of gets regenerated or re-rendered

00:18:41,180 --> 00:18:48,170
if you will if you think about it that's

00:18:44,540 --> 00:18:50,300
kind of like persistence in a way and so

00:18:48,170 --> 00:18:54,560
one of the big realizations that we had

00:18:50,300 --> 00:18:56,840
is that you can think of an under

00:18:54,560 --> 00:18:58,880
specified positional memoization as

00:18:56,840 --> 00:19:01,670
equivalent to persistence and

00:18:58,880 --> 00:19:04,460
persistence gives rise to what we all

00:19:01,670 --> 00:19:06,650
sort of call state and so we can create

00:19:04,460 --> 00:19:10,010
this state function here just using this

00:19:06,650 --> 00:19:11,090
this memo function and actually I'm not

00:19:10,010 --> 00:19:12,740
going to get into it but there's a lot

00:19:11,090 --> 00:19:15,470
of other real fundamental things that

00:19:12,740 --> 00:19:18,530
you can think of that that are sort of

00:19:15,470 --> 00:19:20,720
based on this primitive here and because

00:19:18,530 --> 00:19:22,310
we're appealing to that cache we're

00:19:20,720 --> 00:19:23,840
going to add this at composable

00:19:22,310 --> 00:19:26,900
annotation that's sort of an indication

00:19:23,840 --> 00:19:31,280
that this function is appealing to this

00:19:26,900 --> 00:19:33,260
slot table gap buffer thing right and so

00:19:31,280 --> 00:19:36,650
now that this function works this way

00:19:33,260 --> 00:19:38,060
just like a component works this way we

00:19:36,650 --> 00:19:40,250
can do some things that are kind of cool

00:19:38,060 --> 00:19:42,590
so hooks have this limitation right now

00:19:40,250 --> 00:19:43,910
and in react where you you can't use

00:19:42,590 --> 00:19:45,590
them at the root of the function you can

00:19:43,910 --> 00:19:49,280
only or you can only use them at the

00:19:45,590 --> 00:19:52,520
root of the function and in compose we

00:19:49,280 --> 00:19:53,960
can we can use this State thing inside

00:19:52,520 --> 00:19:56,450
of a for loop or inside of an if

00:19:53,960 --> 00:19:58,130
statement or whatever and the reason we

00:19:56,450 --> 00:20:00,110
can do that is the same reason that we

00:19:58,130 --> 00:20:02,090
can put components inside of a for loop

00:20:00,110 --> 00:20:02,780
and an if statement and things like that

00:20:02,090 --> 00:20:06,590
and they

00:20:02,780 --> 00:20:08,630
work very similar and so one of the kind

00:20:06,590 --> 00:20:11,660
of things to come away with this is that

00:20:08,630 --> 00:20:15,140
a a react component is kind of

00:20:11,660 --> 00:20:18,860
equivalent to a composable function but

00:20:15,140 --> 00:20:20,570
oh sorry but also reacts hooks are kind

00:20:18,860 --> 00:20:22,730
of equivalent to a composable function

00:20:20,570 --> 00:20:25,550
and so the composable function is kind

00:20:22,730 --> 00:20:29,960
of a more fundamental primitive in this

00:20:25,550 --> 00:20:33,680
sense and the the interesting thing to

00:20:29,960 --> 00:20:36,650
me is that compose overall its execution

00:20:33,680 --> 00:20:40,010
model is actually really close to react

00:20:36,650 --> 00:20:42,530
hooks and its execution model but pretty

00:20:40,010 --> 00:20:44,300
far from react components execution

00:20:42,530 --> 00:20:48,170
model and the reconciliation model that

00:20:44,300 --> 00:20:50,290
react has so that's I don't know kind of

00:20:48,170 --> 00:20:53,420
interesting to me but let's take this

00:20:50,290 --> 00:20:56,210
another step further so let's imagine

00:20:53,420 --> 00:21:00,020
that we have an address component which

00:20:56,210 --> 00:21:02,450
you know takes in State City Street

00:21:00,020 --> 00:21:04,570
stuff like that and we're just kind of

00:21:02,450 --> 00:21:06,970
combining them into different text nodes

00:21:04,570 --> 00:21:09,830
and then we have another component

00:21:06,970 --> 00:21:11,930
Google which is kind of wrapping this

00:21:09,830 --> 00:21:14,560
component with a couple of things sort

00:21:11,930 --> 00:21:17,660
of automatically passed in all right

00:21:14,560 --> 00:21:19,580
when when we execute this with with

00:21:17,660 --> 00:21:21,290
compose we see that the the parameters

00:21:19,580 --> 00:21:23,870
are going to get stored in the slot

00:21:21,290 --> 00:21:26,120
table something like this and so the

00:21:23,870 --> 00:21:27,950
parameters are mapped here and then we

00:21:26,120 --> 00:21:31,340
see that actually there's sort of this

00:21:27,950 --> 00:21:35,540
redundancy we're storing the same values

00:21:31,340 --> 00:21:37,670
again when we execute address and and so

00:21:35,540 --> 00:21:39,080
this is this is kind of inefficient this

00:21:37,670 --> 00:21:41,720
is redundant information that we're

00:21:39,080 --> 00:21:44,540
storing and so what if we what if we

00:21:41,720 --> 00:21:46,610
didn't have to what if as a compiler we

00:21:44,540 --> 00:21:50,510
could kind of get rid of this

00:21:46,610 --> 00:21:52,070
inefficiency and so when we look at the

00:21:50,510 --> 00:21:55,040
Google component what if we added

00:21:52,070 --> 00:21:57,410
another parameter here which was like a

00:21:55,040 --> 00:21:59,240
bit field that we're just calling static

00:21:57,410 --> 00:22:03,500
here and now what I could do is I could

00:21:59,240 --> 00:22:06,320
pass another value into the next

00:22:03,500 --> 00:22:09,430
composable that determines which of

00:22:06,320 --> 00:22:12,650
those parameters I know are static and

00:22:09,430 --> 00:22:14,990
then the address component could take

00:22:12,650 --> 00:22:16,020
advantage of that information and say

00:22:14,990 --> 00:22:17,160
okay

00:22:16,020 --> 00:22:19,470
any of the any of the any other

00:22:17,160 --> 00:22:21,000
parameters that are static of mine I'm

00:22:19,470 --> 00:22:22,170
not gonna store I'm not gonna look at

00:22:21,000 --> 00:22:23,850
I'm not gonna do anything I don't need

00:22:22,170 --> 00:22:27,960
to I know they're gonna be the same the

00:22:23,850 --> 00:22:29,640
whole time and so don't worry about the

00:22:27,960 --> 00:22:30,960
bitwise logic that's going on here you

00:22:29,640 --> 00:22:33,120
don't have to write that as user the

00:22:30,960 --> 00:22:37,020
compiler is good at writing that humans

00:22:33,120 --> 00:22:40,470
aren't so we'll take care of it but what

00:22:37,020 --> 00:22:42,810
this allows is basically all of these

00:22:40,470 --> 00:22:44,700
redundant pieces of data that we've been

00:22:42,810 --> 00:22:48,180
storing we can get rid of those in the

00:22:44,700 --> 00:22:50,220
slot table and even more there's all of

00:22:48,180 --> 00:22:52,980
these values that are left which are

00:22:50,220 --> 00:22:54,600
essentially all of the string literal

00:22:52,980 --> 00:22:55,830
values that we haven't and there and

00:22:54,600 --> 00:22:58,440
those are static too so we can get rid

00:22:55,830 --> 00:23:02,250
of those and so this whole thing kind of

00:22:58,440 --> 00:23:04,680
washes away to just two slots we're just

00:23:02,250 --> 00:23:08,070
storing the number and and you know this

00:23:04,680 --> 00:23:09,960
string concatenation and when you start

00:23:08,070 --> 00:23:13,200
to do this it gets kind of interesting

00:23:09,960 --> 00:23:14,970
because we say okay now this the the

00:23:13,200 --> 00:23:17,010
whole the whole sub hierarchy here is

00:23:14,970 --> 00:23:20,730
just purely determined by this one

00:23:17,010 --> 00:23:22,890
number you know parameter and so what if

00:23:20,730 --> 00:23:24,210
I generate a code that looked at the

00:23:22,890 --> 00:23:27,000
number and then looked at the previous

00:23:24,210 --> 00:23:29,430
version of the number and then said skip

00:23:27,000 --> 00:23:31,830
yeah if it hasn't changed we don't need

00:23:29,430 --> 00:23:34,770
to do any of that again and so we

00:23:31,830 --> 00:23:37,110
actually generate that code and that

00:23:34,770 --> 00:23:39,480
code starts to look or feel a lot like

00:23:37,110 --> 00:23:42,960
what y'all might consider I should

00:23:39,480 --> 00:23:46,020
component update method and so we we do

00:23:42,960 --> 00:23:47,880
this component level skipping and a lot

00:23:46,020 --> 00:23:50,580
of places but our compiler kind of

00:23:47,880 --> 00:23:50,940
determines what places it's safe to do

00:23:50,580 --> 00:23:54,000
so

00:23:50,940 --> 00:23:56,000
and correct to do so and adds the code

00:23:54,000 --> 00:23:59,580
in for you and you just write code that

00:23:56,000 --> 00:24:06,570
takes in these parameters and and

00:23:59,580 --> 00:24:10,530
executes the code that you want so here

00:24:06,570 --> 00:24:12,270
we are a chain react 2019 I'm talking

00:24:10,530 --> 00:24:14,880
about compose and like how does this all

00:24:12,270 --> 00:24:18,150
relate to react native and and what are

00:24:14,880 --> 00:24:23,760
we going to do here so Jetpack composed

00:24:18,150 --> 00:24:25,380
is kind of being going to be one of one

00:24:23,760 --> 00:24:27,180
of the ways to write UI on android and

00:24:25,380 --> 00:24:29,299
eventually react native might want to

00:24:27,180 --> 00:24:32,869
target

00:24:29,299 --> 00:24:34,789
and doing so is actually kind of

00:24:32,869 --> 00:24:38,029
counter-intuitively maybe a little bit

00:24:34,789 --> 00:24:42,230
difficult react is kind of built to

00:24:38,029 --> 00:24:43,940
target an imperative UI framework and

00:24:42,230 --> 00:24:45,499
it's not very good at targeting a

00:24:43,940 --> 00:24:48,259
declarative UI framework even though it

00:24:45,499 --> 00:24:49,639
is one and so one of the things I'm

00:24:48,259 --> 00:24:52,220
really interested in is like how could

00:24:49,639 --> 00:24:54,799
this work and and serve knowing the

00:24:52,220 --> 00:24:56,389
inner workings of of compose what can we

00:24:54,799 --> 00:24:59,450
do and I think it has to be at a more

00:24:56,389 --> 00:25:02,029
fundamental level to actually work I

00:24:59,450 --> 00:25:04,129
think we need to you know really kind of

00:25:02,029 --> 00:25:06,859
think about how we can how we can form

00:25:04,129 --> 00:25:09,440
this bridge here and maybe have these

00:25:06,859 --> 00:25:12,070
these two frameworks interrupt but also

00:25:09,440 --> 00:25:14,570
you know how can react native learn from

00:25:12,070 --> 00:25:17,029
from the this new way of doing things

00:25:14,570 --> 00:25:21,379
and is there any sort of lessons there

00:25:17,029 --> 00:25:22,429
we can take take back anyway so I don't

00:25:21,379 --> 00:25:24,710
I don't know exactly what this would

00:25:22,429 --> 00:25:27,830
look like but I hope this talk story

00:25:24,710 --> 00:25:29,809
gives a good starting point and I want

00:25:27,830 --> 00:25:32,029
to kind of leave you today just with

00:25:29,809 --> 00:25:33,919
this message that you know the landscape

00:25:32,029 --> 00:25:36,440
is really evolving and this is a pretty

00:25:33,919 --> 00:25:38,450
exciting time I think ten years from now

00:25:36,440 --> 00:25:40,609
we're gonna kind of look back and think

00:25:38,450 --> 00:25:42,679
like wow wasn't it weird when like

00:25:40,609 --> 00:25:44,480
everyone started doing declared UI at

00:25:42,679 --> 00:25:46,700
the same time and it all happened at

00:25:44,480 --> 00:25:48,830
once and I don't know so anyway I just

00:25:46,700 --> 00:25:51,230
think you know embraced it be curious

00:25:48,830 --> 00:25:52,909
investigate how these things work it's

00:25:51,230 --> 00:25:53,899
open source come take a look come talk

00:25:52,909 --> 00:25:56,179
to me

00:25:53,899 --> 00:25:58,700
anything you want to do there's

00:25:56,179 --> 00:26:00,230
literally engineer centuries being

00:25:58,700 --> 00:26:03,649
invested into these frameworks at both

00:26:00,230 --> 00:26:07,489
Google and Apple it'd be a shame if we

00:26:03,649 --> 00:26:10,879
didn't collaborate you know or just talk

00:26:07,489 --> 00:26:12,950
to each other and sort of everything is

00:26:10,879 --> 00:26:15,139
the same it's the same programming model

00:26:12,950 --> 00:26:17,210
but everything is also different you

00:26:15,139 --> 00:26:20,210
know it's these frameworks are being

00:26:17,210 --> 00:26:22,009
built with clean slates and with with

00:26:20,210 --> 00:26:24,350
the benefit of hindsight that react

00:26:22,009 --> 00:26:26,090
didn't necessarily have and I think

00:26:24,350 --> 00:26:30,080
it'll be really interesting to see how

00:26:26,090 --> 00:26:33,499
these models are different when you know

00:26:30,080 --> 00:26:34,770
when they really get to maturity anyway

00:26:33,499 --> 00:26:38,140
thank you

00:26:34,770 --> 00:26:51,450
[Applause]

00:26:38,140 --> 00:26:51,450

YouTube URL: https://www.youtube.com/watch?v=4EFjDSijAZU


