Title: Chain React 2019: Hermes Engine Announcement
Publication date: 2019-08-06
Playlist: Chain React 2019
Description: 
	Note: there's a problem with the audio until 2:13 into the video, after which it is fixed. We apologize for the inconvenience!

Facebook drops a huge announcement at Chain React 2019! Marc Horowitz from Facebook gave us a look at Hermes Engine, a small and lightweight JavaScript engine optimized for running React Native on Android.

Hosted by Infinite Red, Chain React is the largest React Native conference in the U.S.

https://hermesengine.dev
Captions: 
	00:00:11,000 --> 00:00:14,500
Good morning, my name is Marc

00:00:14,500 --> 00:00:16,500
and as you just heard I'm an engineer at Facebook

00:00:16,500 --> 00:00:18,500
I'm here to tell you about a project at Facebook

00:00:18,500 --> 00:00:21,340
to improve performance of React Native infrastructure

00:00:22,900 --> 00:00:25,620
User experience on mobile benefits from three primary metrics

00:00:25,720 --> 00:00:30,480
Time to interaction, which is the amount of time between when you launch the app

00:00:30,480 --> 00:00:32,480
or when you start bringing up the surface

00:00:32,480 --> 00:00:34,480
and when people can actually interact with that

00:00:34,480 --> 00:00:36,480
and use it usefully.

00:00:36,820 --> 00:00:40,260
The App Store download size, on Android that's the APK size,

00:00:40,260 --> 00:00:42,260
which is just the size of your artifact

00:00:42,260 --> 00:00:44,260
that you download from the Play Store.

00:00:46,360 --> 00:00:50,120
And memory utilization, which is the amount of memory your application consumes,

00:00:50,120 --> 00:00:51,400
while running on the device

00:00:51,400 --> 00:00:54,600
Which has to be shared with all the other applications

00:00:54,900 --> 00:00:56,900
which are running on the phone.

00:00:58,920 --> 00:01:00,840
So what did we do to improve these metrics?

00:01:01,720 --> 00:01:03,720
As React Native developers, you're all

00:01:03,720 --> 00:01:05,720
familiar with the way React Native uses JavaScript.

00:01:05,720 --> 00:01:07,460
Your code manipulates state & props,

00:01:07,460 --> 00:01:10,280
you return other components, and you have all of your other business logic.

00:01:11,120 --> 00:01:13,940
But you might not be familiar with the way React Native works under the hood.

00:01:13,940 --> 00:01:15,940
So let me talk about that for a little bit.

00:01:16,740 --> 00:01:20,540
In an Android app, messages pass from Java native modules

00:01:20,800 --> 00:01:24,180
Across the C++ bridge to a JavaScript engine,

00:01:24,180 --> 00:01:27,080
sometimes called a JavaScript virtual machine, or VM.

00:01:27,280 --> 00:01:29,560
Messages can also pass in the other direction.

00:01:29,560 --> 00:01:32,000
This JavaScript Engine is actually what executes

00:01:32,020 --> 00:01:34,020
the JavaScript code to run the UI.

00:01:34,120 --> 00:01:38,860
The primary metrics are significantly affected by the startup performance of that JavaScript engine.

00:01:40,040 --> 00:01:41,660
Which leads me to the real topic of my talk,

00:01:41,660 --> 00:01:43,660
so, let's bring up the title slide again.

00:01:44,320 --> 00:01:45,900
I'm here to talk today about Facebook's

00:01:45,960 --> 00:01:47,960
Hermes JavaScript Engine.

00:01:49,720 --> 00:01:51,720
So what is Hermes?

00:01:53,220 --> 00:01:58,900
Hermes is a new JavaScript engine, designed for the mobile environment, focusing on startup performance.

00:01:59,200 --> 00:02:01,200
Application code...

00:02:01,200 --> 00:02:03,200
[clapping]

00:02:04,020 --> 00:02:07,020
Application code generally requires no changes to work with Hermes.

00:02:07,440 --> 00:02:09,860
All the changes are within the React Native infrastructure

00:02:10,480 --> 00:02:12,140
Hermes is in production today.

00:02:12,140 --> 00:02:15,960
Most of Facebook's React Native products on Android are already powered by Hermes

00:02:16,420 --> 00:02:23,000
This includes our biggest React Native app, marketplace, and other apps such as crisis response and the oculus companion app.

00:02:23,530 --> 00:02:28,470
We've seen significant performance benefits, but you're justified investing in the team dedicated to this work

00:02:32,340 --> 00:02:36,080
I'll share some numbers later, but let's start off with a quick video demo.

00:02:36,460 --> 00:02:39,100
MatterMost is a real world open source React Native app

00:02:39,260 --> 00:02:45,320
We compiled it with Hermes, on the left, and with the 0.60.1 React Native release on the right

00:02:45,610 --> 00:02:47,610
running on a google pixel phone

00:02:47,860 --> 00:02:52,860
Remember, this is a phone which came out in 2016 phones have gotten much better in the last few years.

00:02:59,980 --> 00:03:06,640
[clapping]

00:03:07,000 --> 00:03:10,860
You can see the app using Hermes is ready to use more than two seconds sooner.

00:03:10,860 --> 00:03:13,529
This is consistent with the TTI metric I discussed before

00:03:14,739 --> 00:03:17,969
So I went over these metrics over earlier. Let me review them

00:03:17,969 --> 00:03:22,980
So TTI, time to interaction, is the amount of time between when you start the app or launch a surface

00:03:23,000 --> 00:03:24,740
and you can actually start using it.

00:03:24,740 --> 00:03:26,720
App size, our APK size,

00:03:26,740 --> 00:03:32,000
which is the size of the binary that people fetch from the App Store over Wi-Fi or in a lot of places over

00:03:32,010 --> 00:03:33,819
a carrier network and

00:03:33,819 --> 00:03:37,559
Memory, which is how much shared resources on your phone that you use

00:03:38,620 --> 00:03:42,390
So here are the measurements for the metrics the MatterMost startup demo

00:03:42,390 --> 00:03:45,989
you just saw. You can see the TTI difference reflected in the video

00:03:46,060 --> 00:03:50,250
These numbers are a little bit different than what was actually in the video because the video takes into account

00:03:50,620 --> 00:03:55,230
Things that the Android platform does before we can actually do our own measurement traces

00:03:55,510 --> 00:03:57,310
But the difference is about the same

00:03:57,310 --> 00:04:03,149
You can see that memory utilization is down by about a quarter which makes you a better citizen on the phone less likely to have

00:04:03,150 --> 00:04:09,179
Other issues and the apk size has dropped by nearly half. The job Hermes is much smaller than than other VMs

00:04:09,760 --> 00:04:13,799
Our build includes arm and x86 for both 32 and 64-bit

00:04:13,799 --> 00:04:19,108
So the overall app size is bigger than some of your applications maybe bigger in some of your applications

00:04:19,109 --> 00:04:21,030
But you can always package things separately

00:04:21,030 --> 00:04:27,030
If you want in Facebook apps this improvement in metrics has led to more downloads and fewer audit memory errors

00:04:28,210 --> 00:04:31,919
You might be wondering why I used an older device like this for our demo

00:04:32,979 --> 00:04:34,979
We're focused on mobile

00:04:37,360 --> 00:04:41,920
Excuse me focusing on mobile devices means focusing on devices people have.

00:04:42,540 --> 00:04:47,660
As developers we tend to carry the latest flagship devices. Most users around the world don't.

00:04:48,280 --> 00:04:54,640
Commonly, use Android devices have less memory and less storage than newest phones and much less than a desktop or laptop

00:04:54,760 --> 00:04:57,359
This is especially true outside of the United States

00:04:58,120 --> 00:05:03,660
Mobile flash is also relatively slow leading to high i/o latency. In the next section of the talk

00:05:03,660 --> 00:05:06,839
I'll explain how the Hermes focus on these device characteristics

00:05:07,389 --> 00:05:09,389
benefits the primary metrics

00:05:14,150 --> 00:05:18,310
But first we're proud to announce we're open sourcing Hermes today on github.

00:05:18,310 --> 00:05:25,540
[clapping]

00:05:25,840 --> 00:05:31,860
We're also open sourcing Hermes integration with React Native so developers can opt into using Hermes immediately.

00:05:32,560 --> 00:05:35,220
At the end of the talk I'll give some links which explain how you can do this.

00:05:38,000 --> 00:05:42,200
So couple other background about Hermes, Hermes implements the JavaScript language

00:05:42,380 --> 00:05:47,980
But the mobile apps that we have in mind when building Hermes are really different than other common JavaScript use cases

00:05:48,110 --> 00:05:52,480
We're not trying to compete in the web browser space or in the server space

00:05:52,850 --> 00:05:57,100
Hermes could in theory be used for those kinds of use cases that's never been our goal

00:06:00,440 --> 00:06:04,690
Now let's talk a little bit about some of the design decisions we made and the trade-offs they represent

00:06:07,520 --> 00:06:10,840
Earlier I said the JavaScript engine is what executes your JavaScript code

00:06:10,940 --> 00:06:15,910
This is actually a multi-step pipeline. Some of you may be familiar with this, but I'll talk to it a little bit

00:06:15,979 --> 00:06:20,379
So babel takes the code that you actually write and converts it into

00:06:20,960 --> 00:06:23,140
compliant javascript code so for example

00:06:23,140 --> 00:06:26,499
If you have XJS representing part of your user interface

00:06:26,870 --> 00:06:34,090
Babel will translate that into javascript calls that create those underlying objects for the engine and for the React Native

00:06:34,220 --> 00:06:40,179
Infrastructure to use once you have the JavaScript code minified just shrinks it. So your apps gonna be a little bit smaller

00:06:41,120 --> 00:06:45,609
And then once you're done with that you package it up in your apk and you upload it to the Play Store

00:06:46,430 --> 00:06:51,160
When you're when the user downloads the app and then runs the app then the JavaScript engine

00:06:52,310 --> 00:06:53,630
Excuse me

00:06:53,630 --> 00:07:01,119
JavaScript engine loads that, parses the code, compiles it into an intermediate form that can be interpreted, and then finally executes it

00:07:01,640 --> 00:07:05,440
With Hermes instead of needing to parse and compile the JavaScript

00:07:05,800 --> 00:07:10,800
on device, while the user is waiting, we can move that work to build time.

00:07:11,539 --> 00:07:16,509
By running the compiler at Build time, and incorporating the bytecode in the apk sent to the Play Store,

00:07:16,509 --> 00:07:19,100
we can reduce the size of the application.

00:07:21,400 --> 00:07:28,800
Now when the user runs the app the execution can begin immediately reducing time to interaction to just the execution of your JavaScript code

00:07:35,900 --> 00:07:39,200
Ahead of time compilation also, lets us to more complex, time-consuming,

00:07:39,360 --> 00:07:46,020
Optimizations and whole program optimizations. For example, we can look for identical functions throughout your program and

00:07:46,020 --> 00:07:53,340
deduplicate them. We can also take the strings from all your JavaScript code, pack them together into an efficient storage form

00:07:53,500 --> 00:07:56,020
That actually has no runtime overhead to access

00:07:57,740 --> 00:08:03,200
Flash memory I/O also adds significant latency on many medium and low-end mobile devices.

00:08:03,400 --> 00:08:09,900
With Hermes, byte code can be memory mapped and loaded from flash incrementally as needed, because flash is

00:08:10,180 --> 00:08:14,680
often so slow optimizing byte code for size can lead to significant TTI improvements

00:08:16,100 --> 00:08:21,640
Because the memory is mapped read-only and backed by a file mobile operating systems that don't swap such as Android

00:08:21,800 --> 00:08:24,160
Can still evict these pages under memory pressure

00:08:24,710 --> 00:08:31,510
This reduces auto process kills on memory constrained devices and can help you work better in the background

00:08:33,260 --> 00:08:39,640
Byte code is also smaller than JS, and our experience with Facebook apps, about 1/3 smaller than minified JS

00:08:45,709 --> 00:08:48,849
If you aren't familiar with a just-in-time compiler or JIT

00:08:48,850 --> 00:08:50,540
Let me explain what that is.

00:08:50,540 --> 00:08:58,029
An engine can measure which parts of the JavaScript code are commonly used, and then compile them to machine code, to increase execution speed.

00:08:58,610 --> 00:09:02,020
Unlike the most commonly used engines today, Hermes does not implement a JIT

00:09:02,540 --> 00:09:10,450
Jits, improve common compute heavy benchmarks such as PDF rendering but these benchmarks are not representative of mobile app workloads

00:09:11,209 --> 00:09:17,109
We've measured that most functions and our React Native app bundles are executed 0 or 1 times during TTI

00:09:17,510 --> 00:09:23,589
This would make it quite challenging to achieve beneficial speed improvements with the JIT without regressing any of our primary metrics

00:09:25,520 --> 00:09:31,629
Spending time measuring this commonly used code on warm-up can increase TTI because we have to do a little bit more work

00:09:33,020 --> 00:09:38,589
By not including a JIT in the in the executable at all, then we can keep the code size down.

00:09:40,270 --> 00:09:45,489
And, we can avoid using memory for the output of the JIT, the compiled machine code, which

00:09:45,740 --> 00:09:50,830
is generally five to ten times larger than the underlying byte code, which performs exactly the same tasks

00:09:53,900 --> 00:09:58,059
We've also invested in a garbage collector which is fast and makes efficient use of memory

00:09:59,060 --> 00:10:02,560
Garbage collection is how you do memory management in a JavaScript application

00:10:02,750 --> 00:10:08,350
And because memory management is such a common allocating and releasing resources is so common

00:10:08,420 --> 00:10:13,749
Especially when you're scrolling around or doing other interactions with the app, it's really important part of your overall performance

00:10:14,360 --> 00:10:17,559
We believe our combination of GC features is unique

00:10:18,350 --> 00:10:24,069
Our garbage collector allocates virtual address space in chunks on demand as needed

00:10:24,110 --> 00:10:26,679
this avoids need to estimate the heap size and

00:10:27,200 --> 00:10:31,900
Minimizes overhead due to pre allocating a large virtual address region during initialization

00:10:33,860 --> 00:10:39,399
Virtual address space need not be contiguous. This avoids resource limits on 32-bit devices,

00:10:39,590 --> 00:10:46,689
where the space must be shared with Java and with other native code this actually was an issue for us in practice and early testing

00:10:48,860 --> 00:10:50,920
We implement a moving garbage collector

00:10:50,920 --> 00:10:58,200
This means memory can be defragmented over time and trunks from the operating system to keep memory usage of the application down

00:11:00,050 --> 00:11:02,660
And finally, we implement a generational garbage collector

00:11:02,680 --> 00:11:04,810
This means that when we do a garbage collection

00:11:04,810 --> 00:11:07,690
We don't have to look at all the objects in the application

00:11:07,690 --> 00:11:11,619
We can just, most of the time, just look at a small fraction of the most recently used ones

00:11:11,960 --> 00:11:16,720
This speeds up garbage collection and reduces pauses in your application while people are using it

00:11:17,450 --> 00:11:22,749
In addition with cooperation from the application you can actually defer garbage collection completely

00:11:23,150 --> 00:11:28,629
And delay it until after TTI. This lets users interact with the application as soon as possible.

00:11:31,340 --> 00:11:37,740
Of course some of production performance isn't enough. It's also important that developers using Hermes have a really great experience

00:11:39,220 --> 00:11:41,220
Migrating to Hermes should be easy

00:11:42,200 --> 00:11:44,200
Hermes is built on the React Native

00:11:44,360 --> 00:11:49,420
0.60.1 release. First thing you'll have to do if you want to use Hermes to support your app to that version of

00:11:49,670 --> 00:11:52,569
React Native. This will be most of the work that you have to do

00:11:56,600 --> 00:12:01,149
Then, it'll be easy to enable Hermes with just a few changes to your build.gradle file

00:12:01,280 --> 00:12:07,899
This slide shows the most important additions in bold and then you can easily choose to disable Hermes again if you ought to try it

00:12:07,900 --> 00:12:13,220
Both ways, the React Native documentation gives more complete instructions on how to migrate your apps.

00:12:13,560 --> 00:12:17,220
I'll leave the URL up at the end of the talk so that you can write that down

00:12:17,750 --> 00:12:19,750
Or take a picture of it

00:12:22,540 --> 00:12:26,560
One of the main developer benefits that everybody loves about using React Native is iteration speed.

00:12:26,980 --> 00:12:32,300
You all really appreciate editing code and being able to really quickly see how it effects your application.

00:12:32,800 --> 00:12:35,580
Precompilation at the core of Hermes is a production win

00:12:35,590 --> 00:12:40,509
But it would slow down the iteration speed if use in your edit, refresh, debug loop

00:12:41,570 --> 00:12:45,010
instead Hermes generates byte code lazily on device

00:12:45,380 --> 00:12:48,429
skipping some expensive optimizations. This preserves

00:12:48,429 --> 00:12:53,520
The fast iteration speed that React Native developers are used to without impacting production performance

00:12:59,000 --> 00:13:01,720
[ringtone]

00:13:02,560 --> 00:13:04,360
[laughing]

00:13:04,800 --> 00:13:12,200
Hermes targets the es6 JavaScript specification, including features such as symbols, iterators, destructuring, assignment, arrow functions

00:13:12,730 --> 00:13:15,300
Libraries such as map and set, and a bunch of other stuff

00:13:16,120 --> 00:13:20,220
We have chosen to omit some language features such as proxies and local eval

00:13:20,260 --> 00:13:25,770
Which don't appear to be commonly used in React Native applications. We base this based on our own

00:13:26,050 --> 00:13:29,369
Applications and reviewing those and seeing what language features they use

00:13:29,620 --> 00:13:33,090
There's a complete list in the documentation of unsupported features

00:13:33,310 --> 00:13:37,950
If you find that we actually omitted any features that your apps use, please let us know

00:13:40,810 --> 00:13:45,750
React Native apps using Hermes also includes support for the Chrome remote debugging protocol

00:13:45,880 --> 00:13:49,679
This is different from the debug JS remotely feature that you might be used to today

00:13:50,470 --> 00:13:52,679
This runs the JavaScript in your browser

00:13:53,050 --> 00:14:00,149
Instead with with Hermes Chrome connects directly the JavaScript engine running inside your application on your simulator or device

00:14:00,400 --> 00:14:04,860
this means you can run the same engine with or without the debugger and

00:14:05,040 --> 00:14:08,660
Synchronous bridge calls can now be supported which helps with newer frameworks

00:14:08,980 --> 00:14:11,220
[clapping]

00:14:11,640 --> 00:14:14,180
Which helps with newer work coming down the pipe like

00:14:14,920 --> 00:14:16,420
like fabric

00:14:16,420 --> 00:14:23,849
Because you're always using Hermes on the device. You can avoid subtle bugs that might occur due to differences in your development and build environments

00:14:25,030 --> 00:14:26,850
In the future

00:14:26,850 --> 00:14:31,559
we also look forward to implementing support for VSCode, to enable the broadest range of

00:14:31,930 --> 00:14:39,180
Developer tools that React Native developers want to use and time and memory profiling tools to make easier to understand and improve

00:14:39,610 --> 00:14:41,610
application behavior

00:14:42,910 --> 00:14:47,489
We're excited to build the community of Hermes users and developers, please try out Hermes

00:14:47,490 --> 00:14:54,270
We think you'll like it. We welcome issues and PRs on GitHub and security issues reported through Facebook's white hat program

00:14:54,970 --> 00:15:00,600
We're also interested to hear about new use cases for mobile optimized JavaScript engine beyond React Native

00:15:03,010 --> 00:15:09,540
Here are some links to the GitHub repo on Facebook, the React Native integration and that URL got truncated

00:15:09,540 --> 00:15:11,540
So go there and you can click to Hermes

00:15:12,520 --> 00:15:13,390
Sorry about that

00:15:13,390 --> 00:15:20,319
And our white hat program where you you can submit security issues if you find any. Thanks for listening

00:15:20,320 --> 00:15:23,320
And I hope you have a good time and using Hermes. Thank you

00:15:23,560 --> 00:15:26,860

YouTube URL: https://www.youtube.com/watch?v=zEjqDWqeDdg


