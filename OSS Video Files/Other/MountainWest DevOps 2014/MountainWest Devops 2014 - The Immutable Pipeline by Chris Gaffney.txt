Title: MountainWest Devops 2014 - The Immutable Pipeline by Chris Gaffney
Publication date: 2020-01-24
Playlist: MountainWest DevOps 2014
Description: 
	better tooling for building consistent servers. With the introduction of Packer this last year, it's become easier to automate the process of building consistent images. Thinking of images as compiled (immutable), configurable, runnable, containers opens up some interesting possibilities.
In this talk I'll be introducing the Immutable Pipeline, a process our team uses to ensure consistency between staging and production. I will also be covering ways we test our images before they move to production.

Help us caption & translate this video!

http://amara.org/v/FG2b/
Captions: 
	00:00:24,770 --> 00:00:31,020
so today I'm going to be talking about

00:00:27,420 --> 00:00:33,060
the mutable pipeline it's it's a process

00:00:31,020 --> 00:00:36,750
that we have been playing around with

00:00:33,060 --> 00:00:39,660
lately a collective idea for one of the

00:00:36,750 --> 00:00:42,210
applications that we own called dead

00:00:39,660 --> 00:00:43,470
man's edge just quick little

00:00:42,210 --> 00:00:47,100
advertisement Deadman switch is a

00:00:43,470 --> 00:00:50,340
monitoring tool for cron jobs you hit a

00:00:47,100 --> 00:00:56,329
URL and we do our best to tell you when

00:00:50,340 --> 00:00:59,820
things aren't working so to begin with

00:00:56,329 --> 00:01:02,010
the immutable pipeline is itself just

00:00:59,820 --> 00:01:04,979
basically a deployment pipeline for

00:01:02,010 --> 00:01:10,820
immutable servers the idea of immutable

00:01:04,979 --> 00:01:12,899
servers is that servers themselves are

00:01:10,820 --> 00:01:14,520
at least a way that we've been seeing it

00:01:12,899 --> 00:01:20,820
service themselves can be treated as

00:01:14,520 --> 00:01:22,619
processes as essentially compiled like

00:01:20,820 --> 00:01:28,190
macro compiled binaries like a

00:01:22,619 --> 00:01:30,479
collection of binaries themselves so a a

00:01:28,190 --> 00:01:33,450
little bit about mutable servers so

00:01:30,479 --> 00:01:36,119
mutable servers are yes actually

00:01:33,450 --> 00:01:39,689
immutable immutable is a term that comes

00:01:36,119 --> 00:01:41,939
from our mutable objects is a term that

00:01:39,689 --> 00:01:46,670
comes from software development and that

00:01:41,939 --> 00:01:50,549
an immutable object is an object that

00:01:46,670 --> 00:01:55,830
once instantiated once created doesn't

00:01:50,549 --> 00:01:57,570
get changed at all and so this is this

00:01:55,830 --> 00:01:59,490
is a common thing like strings like

00:01:57,570 --> 00:02:02,009
initialize the string you say this is

00:01:59,490 --> 00:02:06,030
the state of this object and then from

00:02:02,009 --> 00:02:08,250
that point on that object itself should

00:02:06,030 --> 00:02:10,890
always represent that straight string so

00:02:08,250 --> 00:02:13,860
that state so if you initialize a string

00:02:10,890 --> 00:02:20,670
foo it will always be foo from here

00:02:13,860 --> 00:02:23,930
until the end of the the program run so

00:02:20,670 --> 00:02:26,730
servers could be immutable means that

00:02:23,930 --> 00:02:29,730
once we've booted them once we've

00:02:26,730 --> 00:02:34,260
configured them we don't make any

00:02:29,730 --> 00:02:37,470
changes to them we tend to we use chef

00:02:34,260 --> 00:02:42,299
but for immutable servers we don't run

00:02:37,470 --> 00:02:46,170
convergence on them ever again we don't

00:02:42,299 --> 00:02:48,870
modify config files we're consultancy

00:02:46,170 --> 00:02:50,129
and we've had a number of clients and we

00:02:48,870 --> 00:02:52,170
deal with a lot of people and every now

00:02:50,129 --> 00:02:53,970
and then we'll see somebody who decides

00:02:52,170 --> 00:02:55,920
that doing development on the server is

00:02:53,970 --> 00:02:57,720
a great idea so they'll log into the

00:02:55,920 --> 00:03:01,200
server and they'll make a few changes

00:02:57,720 --> 00:03:05,519
and then next thing you know this server

00:03:01,200 --> 00:03:11,310
is got some weird state were you know

00:03:05,519 --> 00:03:13,739
it's it's essentially a mutant it it has

00:03:11,310 --> 00:03:18,120
code that isn't isn't in the isn't in

00:03:13,739 --> 00:03:20,280
chef isn't in the repository and so when

00:03:18,120 --> 00:03:22,650
we need to make changes that server if

00:03:20,280 --> 00:03:36,060
we ever if that server ever goes away we

00:03:22,650 --> 00:03:40,169
can't easily get that state anymore one

00:03:36,060 --> 00:03:43,199
of the things that we do is anytime that

00:03:40,169 --> 00:03:47,250
you can do something like pseudo into a

00:03:43,199 --> 00:03:50,849
box you have the ability to make a

00:03:47,250 --> 00:03:52,940
change to that server and so the idea

00:03:50,849 --> 00:03:59,000
behind me part of the idea behind

00:03:52,940 --> 00:04:05,400
mutable servers is that once you have

00:03:59,000 --> 00:04:08,040
booted this thing and once you've once

00:04:05,400 --> 00:04:09,900
you've configured it that can be easily

00:04:08,040 --> 00:04:13,199
replicated it can be destroyed and

00:04:09,900 --> 00:04:17,909
brought back up so just like immutable

00:04:13,199 --> 00:04:23,280
objects we need to instantiate the state

00:04:17,909 --> 00:04:26,030
of a server and so our servers we do a

00:04:23,280 --> 00:04:30,870
process when we boot them of

00:04:26,030 --> 00:04:33,419
configuration and the configuration step

00:04:30,870 --> 00:04:35,400
should be as minimal as possible it

00:04:33,419 --> 00:04:37,919
shouldn't require you'd ever go and hit

00:04:35,400 --> 00:04:41,190
this hit the network to figure out this

00:04:37,919 --> 00:04:44,849
is actually an upstart job that we use

00:04:41,190 --> 00:04:47,680
in one of the dead man stench services

00:04:44,849 --> 00:04:50,250
that it takes the user

00:04:47,680 --> 00:04:54,340
they are provided by ec2 that we set as

00:04:50,250 --> 00:04:58,710
simply adjacent string and actually does

00:04:54,340 --> 00:04:58,710
the configuration of our application

00:05:01,889 --> 00:05:12,039
this includes things like configuring

00:05:05,440 --> 00:05:15,340
external services database amqp logging

00:05:12,039 --> 00:05:18,460
services so this is it this is trimmed

00:05:15,340 --> 00:05:21,220
down slightly we also include like

00:05:18,460 --> 00:05:23,289
talking off 22 log lee your paper trail

00:05:21,220 --> 00:05:26,110
or a service like that and making sure

00:05:23,289 --> 00:05:27,820
that you know syslog-ng and the

00:05:26,110 --> 00:05:33,130
dependent services have been properly

00:05:27,820 --> 00:05:36,400
restarted and so this is run at boot and

00:05:33,130 --> 00:05:39,310
never run again ideally there's there

00:05:36,400 --> 00:05:43,150
are some packages like cloud in it that

00:05:39,310 --> 00:05:47,740
come in with Ubuntu's based images that

00:05:43,150 --> 00:05:48,940
include a version of this but we simple

00:05:47,740 --> 00:05:55,659
enough thing to hack together that we

00:05:48,940 --> 00:06:01,599
can build our own mutable servers are

00:05:55,659 --> 00:06:05,470
consistent and the idea is is images

00:06:01,599 --> 00:06:11,349
themselves as I'll be talking about a

00:06:05,470 --> 00:06:14,380
little bit can be booted up at some

00:06:11,349 --> 00:06:17,470
point in the future and as long as let's

00:06:14,380 --> 00:06:22,240
say backing services are still there

00:06:17,470 --> 00:06:24,699
they can they can still be run they can

00:06:22,240 --> 00:06:26,979
still be executed six months two years

00:06:24,699 --> 00:06:31,720
in the future you can spit up a new

00:06:26,979 --> 00:06:37,240
instance of a compiled image and it

00:06:31,720 --> 00:06:41,800
should still boot immutable servers are

00:06:37,240 --> 00:06:44,349
expendable try and keep any sort of

00:06:41,800 --> 00:06:46,000
state outside of them inside of backing

00:06:44,349 --> 00:06:50,099
services now this this may not work for

00:06:46,000 --> 00:06:54,430
something like a database service but uh

00:06:50,099 --> 00:06:59,440
or database server but a backing service

00:06:54,430 --> 00:07:01,029
could be a EBS volume it could be a hard

00:06:59,440 --> 00:07:01,520
drive on that actually stores the data

00:07:01,029 --> 00:07:05,120
that can

00:07:01,520 --> 00:07:10,310
be detached from the server re attached

00:07:05,120 --> 00:07:14,409
to a new server we want our servers to

00:07:10,310 --> 00:07:19,669
be able to be blown away and recreated

00:07:14,409 --> 00:07:23,990
constantly to make sure that no changes

00:07:19,669 --> 00:07:34,159
no mutations that happen to them live

00:07:23,990 --> 00:07:38,780
for very long so a little bit about the

00:07:34,159 --> 00:07:40,819
pipeline itself the pipeline is really

00:07:38,780 --> 00:07:42,139
taken out of a lot of the continuous

00:07:40,819 --> 00:07:48,009
integration continuous deployment

00:07:42,139 --> 00:07:51,110
processes for software we have been seen

00:07:48,009 --> 00:07:55,310
servers themselves more as binaries and

00:07:51,110 --> 00:07:58,430
and more as processes that your run that

00:07:55,310 --> 00:08:00,979
you like something we traditionally deal

00:07:58,430 --> 00:08:05,449
with when you're you know compiling

00:08:00,979 --> 00:08:07,280
engine X or compiling your application

00:08:05,449 --> 00:08:12,380
like if it's written in C your go or

00:08:07,280 --> 00:08:17,029
something along those lines and so the

00:08:12,380 --> 00:08:20,569
the traditional like s traditional is

00:08:17,029 --> 00:08:25,370
fairly new but deployment process is one

00:08:20,569 --> 00:08:29,300
of compile tests deploy continuously

00:08:25,370 --> 00:08:30,949
every commit we compile we test we

00:08:29,300 --> 00:08:36,950
deploy to staging we deploy to

00:08:30,949 --> 00:08:41,120
production the compilation step for us

00:08:36,950 --> 00:08:44,329
and this is where we have a service

00:08:41,120 --> 00:08:48,740
called wind trap inside of DMS are dead

00:08:44,329 --> 00:08:52,339
men stench that is the the actual

00:08:48,740 --> 00:08:57,860
collection service for when what a cron

00:08:52,339 --> 00:09:01,520
job checks in and that is software it

00:08:57,860 --> 00:09:05,329
has it's just happens to be written and

00:09:01,520 --> 00:09:09,380
go we compile it through our continuous

00:09:05,329 --> 00:09:13,820
integration server into a binary we run

00:09:09,380 --> 00:09:15,379
tests on it before deployment that

00:09:13,820 --> 00:09:16,910
binary out to s3

00:09:15,379 --> 00:09:20,509
and then we actually start the

00:09:16,910 --> 00:09:27,859
compilation process of are immutable

00:09:20,509 --> 00:09:31,429
server and we are building a mis we're

00:09:27,859 --> 00:09:32,359
building ec2 images in this processes

00:09:31,429 --> 00:09:38,169
and this is something that could work

00:09:32,359 --> 00:09:40,909
for dr. it could work for I haven't used

00:09:38,169 --> 00:09:43,579
so but some of the other providers that

00:09:40,909 --> 00:09:50,569
allow you to generate an image boot from

00:09:43,579 --> 00:09:55,159
that image the compilation step uses

00:09:50,569 --> 00:09:58,159
packer and we use the boom tubes are as

00:09:55,159 --> 00:10:03,709
our base we have a couple shell scripts

00:09:58,159 --> 00:10:06,459
that just do a little bit of initial

00:10:03,709 --> 00:10:11,479
like the apt get update the apt-get

00:10:06,459 --> 00:10:14,029
upgrade process and a little bit of

00:10:11,479 --> 00:10:15,999
cleanup as far as you know deleting the

00:10:14,029 --> 00:10:18,289
provisioning user and things like that

00:10:15,999 --> 00:10:21,619
but otherwise everything else has done

00:10:18,289 --> 00:10:24,609
in chef and with this compile step our

00:10:21,619 --> 00:10:27,829
goal is to end up with an image that

00:10:24,609 --> 00:10:32,419
will never have to run chef on again and

00:10:27,829 --> 00:10:37,549
so our chef cookbooks and our chef build

00:10:32,419 --> 00:10:41,299
is is a fairly static we don't ever have

00:10:37,549 --> 00:10:46,209
to worry about what the state of the

00:10:41,299 --> 00:10:51,379
system is in prior to running chef

00:10:46,209 --> 00:10:55,159
because our our bases always that that

00:10:51,379 --> 00:10:58,970
fresh a boon to I so you know 12 04 01

00:10:55,159 --> 00:11:07,600
or 14 0403 or whatever you know the next

00:10:58,970 --> 00:11:11,979
one is that we pick is our base so that

00:11:07,600 --> 00:11:16,069
makes our chef cookbooks quite a bit

00:11:11,979 --> 00:11:18,739
more a quite a bit simpler because we

00:11:16,069 --> 00:11:22,999
don't have to deal with the corner cases

00:11:18,739 --> 00:11:26,569
of some config that we added six months

00:11:22,999 --> 00:11:28,230
ago or six weeks ago that may still

00:11:26,569 --> 00:11:30,060
exist or have having

00:11:28,230 --> 00:11:33,110
deleted and we know that every time we

00:11:30,060 --> 00:11:39,900
compile a new image we are starting from

00:11:33,110 --> 00:11:44,610
a clean base so like I said we use

00:11:39,900 --> 00:11:46,410
Packer this is feel bad i mentioned

00:11:44,610 --> 00:11:47,490
packer in my my talk but we're not

00:11:46,410 --> 00:11:51,570
actually going to be covering it too

00:11:47,490 --> 00:11:58,260
much this is this is the actual Packer

00:11:51,570 --> 00:12:00,270
file that we use for a wind trap since

00:11:58,260 --> 00:12:03,180
it looks like a man some time and go

00:12:00,270 --> 00:12:08,040
over it real quick we do all of our

00:12:03,180 --> 00:12:11,070
building with Amazon EBS Packers is sort

00:12:08,040 --> 00:12:19,050
of broken down into builders

00:12:11,070 --> 00:12:25,880
provisioners the Builder section we use

00:12:19,050 --> 00:12:29,160
a ami is just a one of the canonical

00:12:25,880 --> 00:12:32,930
Ubuntu images that they release quite

00:12:29,160 --> 00:12:38,840
regularly with with updates supplied

00:12:32,930 --> 00:12:42,140
like I said we use chef solo yeah

00:12:38,840 --> 00:12:42,140
nothing too exciting

00:12:45,600 --> 00:12:54,620
now the images that we build our a

00:12:51,199 --> 00:12:57,329
container of the application itself of

00:12:54,620 --> 00:13:00,600
like this the service for example wind

00:12:57,329 --> 00:13:03,290
trap the image holds everything it needs

00:13:00,600 --> 00:13:06,839
to run an instance of that application

00:13:03,290 --> 00:13:11,610
the application itself any internal

00:13:06,839 --> 00:13:16,949
dependencies let's say memcache or Redis

00:13:11,610 --> 00:13:19,670
or engine X for example that container

00:13:16,949 --> 00:13:23,370
that server is essentially a macro

00:13:19,670 --> 00:13:28,740
compilation of all of those all of those

00:13:23,370 --> 00:13:30,720
services we we've been doing some some

00:13:28,740 --> 00:13:32,910
playing around with with application

00:13:30,720 --> 00:13:36,740
servers something that's been fairly

00:13:32,910 --> 00:13:40,170
popular in the java community where

00:13:36,740 --> 00:13:42,839
you've got something like what a JBoss

00:13:40,170 --> 00:13:44,399
or you know we're Ruby developers so

00:13:42,839 --> 00:13:48,300
we've been we've been using torque box

00:13:44,399 --> 00:13:50,519
and that is this whole setup of like

00:13:48,300 --> 00:13:54,480
it's got a messaging bus and it's got a

00:13:50,519 --> 00:13:56,519
caching layer and it and you compile

00:13:54,480 --> 00:13:57,509
your war and you just employ it you push

00:13:56,519 --> 00:14:00,149
it out to this thing with the

00:13:57,509 --> 00:14:03,660
configuration file and like all of that

00:14:00,149 --> 00:14:06,120
like you can build a fairly complex

00:14:03,660 --> 00:14:10,009
application that is easily deployable as

00:14:06,120 --> 00:14:12,870
a single container and we've been seeing

00:14:10,009 --> 00:14:14,670
we like this idea of the immutable

00:14:12,870 --> 00:14:17,639
servers as being these these containers

00:14:14,670 --> 00:14:20,310
as well so that let's say you wanted to

00:14:17,639 --> 00:14:21,750
have an LRU cache in your code or it

00:14:20,310 --> 00:14:25,709
needed it you can do implement that

00:14:21,750 --> 00:14:27,959
yourself or you could just build a

00:14:25,709 --> 00:14:29,699
memcache use a memcache client and get a

00:14:27,959 --> 00:14:34,319
lot of that for free that kind of thing

00:14:29,699 --> 00:14:37,110
or you want to build your application as

00:14:34,319 --> 00:14:41,339
a series of workers behind a message bus

00:14:37,110 --> 00:14:42,660
you can easily have your image contain

00:14:41,339 --> 00:14:48,029
all of those workers and every single

00:14:42,660 --> 00:14:49,949
time you do a compilation it sets up all

00:14:48,029 --> 00:14:52,410
those workers and sets up a message bus

00:14:49,949 --> 00:14:54,980
like internally that you can you can

00:14:52,410 --> 00:14:54,980
work off of

00:14:56,810 --> 00:15:07,310
so test now we've got this image that is

00:15:02,510 --> 00:15:10,430
a essentially a snapshot of the the code

00:15:07,310 --> 00:15:12,320
a snapshot of the everything put

00:15:10,430 --> 00:15:16,490
together at a particular point in time

00:15:12,320 --> 00:15:21,740
or for a particular commit the testing

00:15:16,490 --> 00:15:25,370
phase is black box testing where you can

00:15:21,740 --> 00:15:28,520
spin up an instance and because it's

00:15:25,370 --> 00:15:31,490
configurable you can say something you

00:15:28,520 --> 00:15:33,950
could use to like post gresham to spin

00:15:31,490 --> 00:15:37,820
up a Postgres database in the background

00:15:33,950 --> 00:15:40,460
see it it with a set of information run

00:15:37,820 --> 00:15:44,930
your like boot up an instance of the am

00:15:40,460 --> 00:15:48,589
I with that and then talk directly to

00:15:44,930 --> 00:15:53,060
database to see data or do test

00:15:48,589 --> 00:15:55,760
assertions that kind of thing the

00:15:53,060 --> 00:15:59,480
testing process is a lot of spin it up

00:15:55,760 --> 00:16:01,010
make a bunch of requests make sure

00:15:59,480 --> 00:16:02,630
everything is working make sure that the

00:16:01,010 --> 00:16:04,990
the contract that we've defined for the

00:16:02,630 --> 00:16:09,620
application the api's and things are

00:16:04,990 --> 00:16:13,760
continuing to function and then finally

00:16:09,620 --> 00:16:15,400
we deploy and in our continuous

00:16:13,760 --> 00:16:18,230
integration setup we deploy to staging

00:16:15,400 --> 00:16:22,700
constantly we only promote certain

00:16:18,230 --> 00:16:24,410
builds to production just to match the

00:16:22,700 --> 00:16:30,740
other development that's going on with

00:16:24,410 --> 00:16:33,260
the application deployment is a process

00:16:30,740 --> 00:16:36,080
similar to something like doing an

00:16:33,260 --> 00:16:38,720
engine next upgrade we spin up new

00:16:36,080 --> 00:16:41,450
instances we have a load balancer

00:16:38,720 --> 00:16:43,670
instead of a shared socket but we tell

00:16:41,450 --> 00:16:45,140
the load balancer that hey we've got

00:16:43,670 --> 00:16:47,660
these new instances you should add them

00:16:45,140 --> 00:16:50,510
into the rotation and then once they are

00:16:47,660 --> 00:16:52,990
up we remove the old instances from the

00:16:50,510 --> 00:16:52,990
rotation

00:16:58,280 --> 00:17:08,970
alright so that's about it for my talk

00:17:04,710 --> 00:17:14,970
Chris Gaffney Gaffney see on twitter and

00:17:08,970 --> 00:17:22,250
github and work a collective idea that's

00:17:14,970 --> 00:17:22,250
that alright well thank you very much

00:17:52,670 --> 00:17:54,730

YouTube URL: https://www.youtube.com/watch?v=-oedW5IGnik


