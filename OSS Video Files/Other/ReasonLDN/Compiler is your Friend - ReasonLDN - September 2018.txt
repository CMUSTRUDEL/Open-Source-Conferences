Title: Compiler is your Friend - ReasonLDN - September 2018
Publication date: 2018-09-18
Playlist: ReasonLDN
Description: 
	Presented by Jakub Korzeniowski - @carkujon

Type systems are all the rage, but they are not all created equal. Jakub will run us through a comparison of the different approaches to typing found in Java, OCaml, and TypeScript while dropping hot pro/con knowledge bombs throughout.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:07,290
hi everyone my name is Jakob I work for

00:00:04,230 --> 00:00:09,960
the company called vortex ax and we use

00:00:07,290 --> 00:00:12,719
machine learning to provide all traders

00:00:09,960 --> 00:00:16,650
with a real-time view of supply of

00:00:12,719 --> 00:00:18,900
energy in the old markets it's a pretty

00:00:16,650 --> 00:00:20,880
cool and quite a difficult problem to

00:00:18,900 --> 00:00:25,430
crack a lot of analytics love mapping a

00:00:20,880 --> 00:00:28,470
lot of scaleable AI buzzwords as well

00:00:25,430 --> 00:00:31,199
you can find me on the internet under

00:00:28,470 --> 00:00:33,930
those handles and I want to talk to you

00:00:31,199 --> 00:00:36,630
today about various type systems

00:00:33,930 --> 00:00:38,219
specifically three of them one of them

00:00:36,630 --> 00:00:41,969
is Java one of them is type scripting

00:00:38,219 --> 00:00:44,190
one of them is all common a little bit

00:00:41,969 --> 00:00:46,530
of a disclaimer I'm by no means a type

00:00:44,190 --> 00:00:49,230
systems expert I just happen to be

00:00:46,530 --> 00:00:52,670
working with all three of them gained

00:00:49,230 --> 00:00:55,590
some insights into how they work and

00:00:52,670 --> 00:00:59,070
kind of formed opinions and how they

00:00:55,590 --> 00:01:00,829
helped me in very different situations

00:00:59,070 --> 00:01:03,420
so without further ado let's get into it

00:01:00,829 --> 00:01:04,830
start with Java I'm going to be

00:01:03,420 --> 00:01:07,020
specifically talking about Java 10

00:01:04,830 --> 00:01:12,240
because a massive improvement over your

00:01:07,020 --> 00:01:15,960
regular uber verbose Java that you're

00:01:12,240 --> 00:01:18,659
used to there's a quote that I would

00:01:15,960 --> 00:01:21,840
like to suggest that it's really because

00:01:18,659 --> 00:01:26,430
Java would be a very dangerous choice to

00:01:21,840 --> 00:01:28,409
use in such contexts and and it's not a

00:01:26,430 --> 00:01:31,320
bad thing to me this is there's a theme

00:01:28,409 --> 00:01:36,299
of this compiler honesty like flat-out

00:01:31,320 --> 00:01:38,640
honesty so let's learn about a few

00:01:36,299 --> 00:01:41,880
features of the type system so out of

00:01:38,640 --> 00:01:47,100
the box you get two different types of

00:01:41,880 --> 00:01:49,409
types so unboxed and boxed unboxed types

00:01:47,100 --> 00:01:52,500
are something that you'll be familiar

00:01:49,409 --> 00:01:55,500
from background like C or C++

00:01:52,500 --> 00:01:57,360
they're just primitives pure values no

00:01:55,500 --> 00:01:59,729
methods just assign the value and then

00:01:57,360 --> 00:02:02,430
you cannot do anything with that value

00:01:59,729 --> 00:02:04,079
unless you some utility methods etc and

00:02:02,430 --> 00:02:07,079
they follow structural quality as well

00:02:04,079 --> 00:02:08,879
so now literally if one value is set to

00:02:07,079 --> 00:02:11,760
one value no value is set to the same

00:02:08,879 --> 00:02:15,959
value there are equal pretty boring

00:02:11,760 --> 00:02:18,300
they're also box types which are which

00:02:15,959 --> 00:02:20,099
for JavaScript folks you're going to be

00:02:18,300 --> 00:02:22,379
kind of familiar with for everything is

00:02:20,099 --> 00:02:25,980
an object so you can you know call

00:02:22,379 --> 00:02:29,220
methods on it like to string and they

00:02:25,980 --> 00:02:31,950
mostly behave like object / reference

00:02:29,220 --> 00:02:33,360
types when it comes to equality namely

00:02:31,950 --> 00:02:34,290
they can hold the same value but there

00:02:33,360 --> 00:02:36,510
are generally going to be different

00:02:34,290 --> 00:02:38,220
because the references are different I'm

00:02:36,510 --> 00:02:40,830
saying mostly because you know JVM

00:02:38,220 --> 00:02:43,140
optimizes some of those crazy cases and

00:02:40,830 --> 00:02:45,630
common cases into single tones similarly

00:02:43,140 --> 00:02:49,530
to Python but that that whole thing is

00:02:45,630 --> 00:02:52,620
for another talk I guess so where those

00:02:49,530 --> 00:02:54,269
two types differ the most is when it

00:02:52,620 --> 00:02:57,150
comes to representing the concept of no

00:02:54,269 --> 00:03:02,150
value and then me know and this is a

00:02:57,150 --> 00:03:02,150
quote from an inventor of no actually

00:03:02,390 --> 00:03:08,730
the most important takeaway here is that

00:03:06,140 --> 00:03:12,950
null doesn't have any type therefore it

00:03:08,730 --> 00:03:15,630
means it can be assigned to any box type

00:03:12,950 --> 00:03:17,010
and compiler doesn't give you any

00:03:15,630 --> 00:03:20,760
guarantees whatsoever it doesn't even

00:03:17,010 --> 00:03:23,489
attempt to do anything about it and it's

00:03:20,760 --> 00:03:26,480
clear it's obvious you are on your own

00:03:23,489 --> 00:03:28,799
so you have to be careful how you code

00:03:26,480 --> 00:03:30,359
and again it's quite honest it's not

00:03:28,799 --> 00:03:32,730
attempting to do anything about it it's

00:03:30,359 --> 00:03:35,910
just flat-out to understate I'm just

00:03:32,730 --> 00:03:40,769
gonna leave you to it another

00:03:35,910 --> 00:03:43,530
interesting feature should I call it or

00:03:40,769 --> 00:03:45,739
behavior is a type erasure so Java has

00:03:43,530 --> 00:03:50,459
good generics like a lot of other

00:03:45,739 --> 00:03:53,579
programming languages out there but

00:03:50,459 --> 00:03:57,090
strangely enough also Java needs the

00:03:53,579 --> 00:03:59,730
type information at runtime so for

00:03:57,090 --> 00:04:04,220
example you know to be able to choose

00:03:59,730 --> 00:04:04,220
the correct methods overloads etc etc

00:04:04,549 --> 00:04:11,430
the type erasure feature means that all

00:04:08,090 --> 00:04:13,560
generics are gone at runtime so if

00:04:11,430 --> 00:04:16,289
you've got a list of string and if

00:04:13,560 --> 00:04:18,870
you've got a list of long they all look

00:04:16,289 --> 00:04:22,190
exactly the same to each other at

00:04:18,870 --> 00:04:24,520
runtime and again with the theme of

00:04:22,190 --> 00:04:27,070
honesty here's a

00:04:24,520 --> 00:04:29,680
recently simple example which won't

00:04:27,070 --> 00:04:31,570
compile even though to a person who's

00:04:29,680 --> 00:04:33,940
not worked with Java these look like

00:04:31,570 --> 00:04:36,039
perfectly fine overloads once taking a

00:04:33,940 --> 00:04:38,710
list of integers and when it's taking a

00:04:36,039 --> 00:04:41,070
list of longs but because of this

00:04:38,710 --> 00:04:43,810
typewriter feature should I call it

00:04:41,070 --> 00:04:46,120
compiler is just telling you I can't do

00:04:43,810 --> 00:04:49,050
anything about it I'm too primitive but

00:04:46,120 --> 00:04:49,050
I'm gonna be honest about it

00:04:50,130 --> 00:04:56,860
Giavotella introduced something that has

00:04:55,419 --> 00:04:59,410
improved my opinion the type system

00:04:56,860 --> 00:05:03,150
dramatically named a local typing

00:04:59,410 --> 00:05:05,710
friends namely something that a

00:05:03,150 --> 00:05:08,110
programmer in any other language is kind

00:05:05,710 --> 00:05:09,669
of used to where you can type in a VAR

00:05:08,110 --> 00:05:15,130
key Wharton's going to figure out what

00:05:09,669 --> 00:05:17,500
what type is that local variable of this

00:05:15,130 --> 00:05:19,150
is by the way applying to only local

00:05:17,500 --> 00:05:23,410
variables it won't impair your method

00:05:19,150 --> 00:05:26,460
arguments etc etc so you know you type

00:05:23,410 --> 00:05:28,810
barn you assign a string value to it and

00:05:26,460 --> 00:05:31,900
it's gonna figure out its drink great

00:05:28,810 --> 00:05:35,970
like any other type language at the same

00:05:31,900 --> 00:05:38,740
time this is feature being new is quite

00:05:35,970 --> 00:05:41,289
it's in quite early stages so for

00:05:38,740 --> 00:05:43,659
example if you were to assign a lambda

00:05:41,289 --> 00:05:45,580
to it which has been introduced in Java

00:05:43,659 --> 00:05:47,740
10 it's gonna blow up it's not gonna

00:05:45,580 --> 00:05:49,990
blow up with any cryptic expression it's

00:05:47,740 --> 00:05:52,659
just going to again very honestly tell

00:05:49,990 --> 00:05:56,380
you this listen I can't do it you have

00:05:52,659 --> 00:05:59,229
to give me some hints and I quite like

00:05:56,380 --> 00:06:03,669
this honesty if I quite like Java to

00:05:59,229 --> 00:06:06,070
guys so that's a it's my conclusion Java

00:06:03,669 --> 00:06:08,349
it's a very likeable friend not the

00:06:06,070 --> 00:06:13,800
sharpest but self-aware I noticed about

00:06:08,349 --> 00:06:17,949
it ok let's catch up of typescript

00:06:13,800 --> 00:06:22,780
which immediately strikes you as a

00:06:17,949 --> 00:06:24,909
language with many more advanced type

00:06:22,780 --> 00:06:26,979
features that I'm gonna try to walk you

00:06:24,909 --> 00:06:29,289
through in here and it's even more

00:06:26,979 --> 00:06:31,810
remarkable I want to you know give

00:06:29,289 --> 00:06:34,120
credit to typescript because it's in my

00:06:31,810 --> 00:06:35,590
opinion trying to achieve the impossible

00:06:34,120 --> 00:06:37,360
it's trying to type javascript without

00:06:35,590 --> 00:06:38,800
changing the semantics of JavaScript and

00:06:37,360 --> 00:06:41,590
JavaScript is

00:06:38,800 --> 00:06:44,620
the wildest of the West really so many

00:06:41,590 --> 00:06:46,960
different ways of screwing things up and

00:06:44,620 --> 00:06:52,330
trying to type it in my personal opinion

00:06:46,960 --> 00:06:54,400
is an impossible task one of those more

00:06:52,330 --> 00:06:56,560
advanced features or strict no checks or

00:06:54,400 --> 00:06:58,199
in general just you know types gives in

00:06:56,560 --> 00:07:02,199
strict mode

00:06:58,199 --> 00:07:05,050
it promises null safety and it does

00:07:02,199 --> 00:07:07,419
deliver so if you consider this

00:07:05,050 --> 00:07:09,460
particular example may be a bit

00:07:07,419 --> 00:07:13,419
convoluted and made it completed on

00:07:09,460 --> 00:07:18,639
purpose you know I've got an optional

00:07:13,419 --> 00:07:21,970
I've got a or no value on an ID and I

00:07:18,639 --> 00:07:24,460
want to you know return this ID and if I

00:07:21,970 --> 00:07:28,060
don't check for when the ID is no the

00:07:24,460 --> 00:07:30,639
compiler is going to warn me and error

00:07:28,060 --> 00:07:32,889
out on me and telling me that you know I

00:07:30,639 --> 00:07:34,990
have to type guard against the null case

00:07:32,889 --> 00:07:37,629
because I cannot assign straight to

00:07:34,990 --> 00:07:38,080
string great so I do so on the next

00:07:37,629 --> 00:07:39,759
slide

00:07:38,080 --> 00:07:43,900
another thing nicely compiles in the

00:07:39,759 --> 00:07:45,460
code is nice and solid and it's

00:07:43,900 --> 00:07:47,409
obviously a big improvement over

00:07:45,460 --> 00:07:48,880
Java's we've seen where you know pretty

00:07:47,409 --> 00:07:52,599
much anything can be no you're on your

00:07:48,880 --> 00:07:54,550
own and this feature is so great that

00:07:52,599 --> 00:07:58,840
you end up relying on it and that is

00:07:54,550 --> 00:08:02,229
until it doesn't work so in this

00:07:58,840 --> 00:08:05,159
particular case if you just look at

00:08:02,229 --> 00:08:08,080
those the last example from here and

00:08:05,159 --> 00:08:11,279
this example from here the only

00:08:08,080 --> 00:08:14,469
difference that we see is really we just

00:08:11,279 --> 00:08:18,699
flipped the way we perform the check up

00:08:14,469 --> 00:08:20,440
top so we check for the ID is different

00:08:18,699 --> 00:08:23,259
to know first and then for the value of

00:08:20,440 --> 00:08:25,840
type foo and suddenly the type script

00:08:23,259 --> 00:08:29,380
gets confused in in this particular case

00:08:25,840 --> 00:08:31,890
so it's quite a common occurrence in my

00:08:29,380 --> 00:08:36,820
in my experience with typescript where

00:08:31,890 --> 00:08:39,729
you end up you end up tweaking the code

00:08:36,820 --> 00:08:41,770
so that it's semantically exactly the

00:08:39,729 --> 00:08:43,390
same it just has to be written slightly

00:08:41,770 --> 00:08:45,610
differently in order to make it work

00:08:43,390 --> 00:08:47,160
like in this particular case I mean and

00:08:45,610 --> 00:08:49,089
operator is commutative

00:08:47,160 --> 00:08:52,529
especially this simple case when there

00:08:49,089 --> 00:08:52,529
is no evaluation and

00:08:54,520 --> 00:08:59,810
unions and pattern matching pattern

00:08:57,770 --> 00:09:02,000
matching because a common reason have

00:08:59,810 --> 00:09:03,260
got proper pattern matching but touch

00:09:02,000 --> 00:09:05,120
script gets really close and it's

00:09:03,260 --> 00:09:08,300
another one of the super cool features

00:09:05,120 --> 00:09:10,670
in typescript unions by the way for

00:09:08,300 --> 00:09:12,470
variant for those who are unaware allow

00:09:10,670 --> 00:09:16,580
you to express a concept of type or

00:09:12,470 --> 00:09:19,550
another type and there are mega powerful

00:09:16,580 --> 00:09:21,590
feature especially combined with what

00:09:19,550 --> 00:09:24,710
you will see here and the typescript

00:09:21,590 --> 00:09:26,990
feature to enforce the exhaustive Ness

00:09:24,710 --> 00:09:29,890
of your checks so I've defined the union

00:09:26,990 --> 00:09:34,100
up top for bar they happen to be strings

00:09:29,890 --> 00:09:36,350
and if I check in my function that takes

00:09:34,100 --> 00:09:40,640
only an Union for just the value of foo

00:09:36,350 --> 00:09:42,230
it's going to give me an error that you

00:09:40,640 --> 00:09:43,460
know in other case I'm gonna have a

00:09:42,230 --> 00:09:45,920
fault true and return undefined

00:09:43,460 --> 00:09:48,020
therefore I've not exhaustively checked

00:09:45,920 --> 00:09:52,820
for all of the cases it's mega useful

00:09:48,020 --> 00:09:55,490
feature you know it allows you to write

00:09:52,820 --> 00:09:57,710
code which is which covers pretty much

00:09:55,490 --> 00:10:00,590
all of the cases so at the bottom I've

00:09:57,710 --> 00:10:03,080
just that I think compiles I don't need

00:10:00,590 --> 00:10:10,040
the default case and everything works

00:10:03,080 --> 00:10:11,540
beautifully and at my company we

00:10:10,040 --> 00:10:14,470
actually quite really like this feature

00:10:11,540 --> 00:10:16,970
so we decided to flip it on its head and

00:10:14,470 --> 00:10:18,350
get closer to pattern matching by

00:10:16,970 --> 00:10:21,290
starting using the following pattern

00:10:18,350 --> 00:10:23,240
where you start using switch true

00:10:21,290 --> 00:10:27,500
instead of switch variable and then you

00:10:23,240 --> 00:10:30,260
can just cram any complex if expression

00:10:27,500 --> 00:10:32,870
into your case into your case part of

00:10:30,260 --> 00:10:34,820
the switch statement and do something

00:10:32,870 --> 00:10:37,790
that is very akin to to pattern matching

00:10:34,820 --> 00:10:39,920
so for example something that really

00:10:37,790 --> 00:10:45,310
helps with validation it makes really

00:10:39,920 --> 00:10:49,070
clear to read from top to bottom and

00:10:45,310 --> 00:10:51,800
then I personally got so used to this

00:10:49,070 --> 00:10:54,740
particular style of writing switch

00:10:51,800 --> 00:10:58,370
statements it was like muscle memory at

00:10:54,740 --> 00:11:01,730
some points and it happens not to work

00:10:58,370 --> 00:11:03,890
with exhaustively exhaustive Ness checks

00:11:01,730 --> 00:11:04,790
against unions so this is exactly the

00:11:03,890 --> 00:11:07,310
same example

00:11:04,790 --> 00:11:08,930
as the first example with the exhaustive

00:11:07,310 --> 00:11:11,570
news checks just written in a slightly

00:11:08,930 --> 00:11:14,300
different way I'm switching true against

00:11:11,570 --> 00:11:17,029
the possible values that can value a to

00:11:14,300 --> 00:11:19,970
true rather than switching the value to

00:11:17,029 --> 00:11:23,360
against things that this value is equal

00:11:19,970 --> 00:11:26,110
to and the exhaustive Ness is not

00:11:23,360 --> 00:11:30,410
working anymore in this particular case

00:11:26,110 --> 00:11:32,089
so this is very interesting because if

00:11:30,410 --> 00:11:33,950
you're writing this code and if you're

00:11:32,089 --> 00:11:35,510
reading this code will do you might be

00:11:33,950 --> 00:11:37,670
tempted to do instead of rewrite it to

00:11:35,510 --> 00:11:40,310
do switch value and do these normal

00:11:37,670 --> 00:11:41,990
exhaustive miss checks you add a default

00:11:40,310 --> 00:11:45,519
case and when you add a default case

00:11:41,990 --> 00:11:45,519
effectively everything is exhaustive

00:11:46,750 --> 00:11:54,320
this is one of the most interesting

00:11:50,420 --> 00:11:56,690
things in my opinion we we quite often

00:11:54,320 --> 00:11:59,540
you know get data from a server and

00:11:56,690 --> 00:12:03,290
especially as front-end developers we

00:11:59,540 --> 00:12:05,930
chat to third party aap is you kind of

00:12:03,290 --> 00:12:11,329
cannot necessarily trust what's coming

00:12:05,930 --> 00:12:13,070
out from a third party API so the safety

00:12:11,329 --> 00:12:14,899
of this boundary in between you know a

00:12:13,070 --> 00:12:17,690
third party system and your own system

00:12:14,899 --> 00:12:19,160
is paramount in my opinion and parse you

00:12:17,690 --> 00:12:21,890
know server responses if you are using

00:12:19,160 --> 00:12:24,140
the fetch API or you can use JSON with

00:12:21,890 --> 00:12:27,140
powers directly provided you don't want

00:12:24,140 --> 00:12:30,529
any other library and you can use that

00:12:27,140 --> 00:12:32,510
and in typescript it's it's not about

00:12:30,529 --> 00:12:35,120
actually in this particular case a

00:12:32,510 --> 00:12:36,920
feature or lack of features and in

00:12:35,120 --> 00:12:39,380
typescript itself it's more about how

00:12:36,920 --> 00:12:40,970
you know the standard library in in

00:12:39,380 --> 00:12:42,949
typescript this type it allows you to

00:12:40,970 --> 00:12:46,430
effectively claim that the response is

00:12:42,949 --> 00:12:48,380
of a certain type without performing any

00:12:46,430 --> 00:12:50,329
checks so I can get a crazy situation

00:12:48,380 --> 00:12:52,670
and claim two boolean it's gonna be just

00:12:50,329 --> 00:12:56,000
fine so it can lead to interesting

00:12:52,670 --> 00:12:59,600
scenarios like like this if you just

00:12:56,000 --> 00:13:02,149
scan through this code it it looks fine

00:12:59,600 --> 00:13:04,640
right we've got a doctor of a name and

00:13:02,149 --> 00:13:06,110
shift both strings with great nice

00:13:04,640 --> 00:13:08,540
function which takes a doctor and

00:13:06,110 --> 00:13:12,110
renders some information about this

00:13:08,540 --> 00:13:13,430
doctor as a string and then we do a

00:13:12,110 --> 00:13:17,170
simple json.parse

00:13:13,430 --> 00:13:18,910
on the response that we supposedly

00:13:17,170 --> 00:13:20,260
from the server and then we render dr.

00:13:18,910 --> 00:13:23,740
and we get something that doesn't look

00:13:20,260 --> 00:13:24,850
like what we intended very simple

00:13:23,740 --> 00:13:26,769
mistake to make

00:13:24,850 --> 00:13:30,339
you know because Jason powers didn't

00:13:26,769 --> 00:13:34,180
force us to perform any type checking as

00:13:30,339 --> 00:13:36,519
we are parsing a simple thing the

00:13:34,180 --> 00:13:39,459
response being wrapped in an array can

00:13:36,519 --> 00:13:43,300
lead to you know situations like that in

00:13:39,459 --> 00:13:45,490
your application so this leads me to my

00:13:43,300 --> 00:13:48,610
conclusion the type tube is incredible

00:13:45,490 --> 00:13:53,910
capable and confident when you press it

00:13:48,610 --> 00:13:56,500
struggles a little bit so the last

00:13:53,910 --> 00:14:03,070
language I want to talk about is Oh

00:13:56,500 --> 00:14:07,240
camel it got all encompassing it's not a

00:14:03,070 --> 00:14:08,800
type system theory term and type

00:14:07,240 --> 00:14:12,279
inference meaning that it's not only

00:14:08,800 --> 00:14:14,320
your VAR local variable that it will

00:14:12,279 --> 00:14:16,000
infer you can theoretically write your

00:14:14,320 --> 00:14:19,990
whole program without a single type

00:14:16,000 --> 00:14:22,209
annotation and it's going to work so in

00:14:19,990 --> 00:14:25,180
Java or typescript certain operations

00:14:22,209 --> 00:14:28,180
can be unchecked the local itself won't

00:14:25,180 --> 00:14:29,470
compile at least unless it's it knows

00:14:28,180 --> 00:14:34,410
the type of each and every single

00:14:29,470 --> 00:14:38,199
expression in in the whole program so

00:14:34,410 --> 00:14:41,110
you know a function that takes a boolean

00:14:38,199 --> 00:14:43,899
and a list of other boolean and if all

00:14:41,110 --> 00:14:46,180
of the boolean Xin the second lists are

00:14:43,899 --> 00:14:48,519
true or if the first boolean is true

00:14:46,180 --> 00:14:51,220
then is going to return you truth so not

00:14:48,519 --> 00:14:52,930
the most super straightforward thing you

00:14:51,220 --> 00:14:54,640
can write but it requires absolutely

00:14:52,930 --> 00:14:58,120
zero type annotations so for example

00:14:54,640 --> 00:14:59,860
knows what B is because it's been piped

00:14:58,120 --> 00:15:03,190
in to fold left just an equivalent of

00:14:59,860 --> 00:15:05,380
reduce and inside of the function that

00:15:03,190 --> 00:15:08,380
we are using for reducing we use the and

00:15:05,380 --> 00:15:12,970
operator therefore it immediately

00:15:08,380 --> 00:15:15,190
figured out B is a boolean and therefore

00:15:12,970 --> 00:15:17,829
also C is a boolean and then we all did

00:15:15,190 --> 00:15:21,730
with a and figured out that is a boolean

00:15:17,829 --> 00:15:24,399
as well so it can infer it can infer all

00:15:21,730 --> 00:15:27,819
the types for you and this is you know

00:15:24,399 --> 00:15:30,620
an example limited to to one function in

00:15:27,819 --> 00:15:33,740
certain edge cases

00:15:30,620 --> 00:15:35,840
ask you for a type annotation but 99.9%

00:15:33,740 --> 00:15:38,330
of the time you just don't have to

00:15:35,840 --> 00:15:39,890
annotate it knows it and type to friends

00:15:38,330 --> 00:15:41,480
I want to stress that it's a it's such a

00:15:39,890 --> 00:15:43,940
great feature because if the compiler

00:15:41,480 --> 00:15:48,170
knows the type and you don't have to

00:15:43,940 --> 00:15:54,020
annotate it the the disc op for lying to

00:15:48,170 --> 00:15:58,700
the compiler is much more variants are

00:15:54,020 --> 00:16:01,370
quite similar to typescript unions so

00:15:58,700 --> 00:16:03,980
again there's a very similar to what we

00:16:01,370 --> 00:16:07,450
did with typescript we define a variant

00:16:03,980 --> 00:16:10,250
of forum bar the only differences we are

00:16:07,450 --> 00:16:12,200
bar also happens to hold the value of a

00:16:10,250 --> 00:16:14,720
float and if we switch in a

00:16:12,200 --> 00:16:17,990
non-exhaustive fashion is going to warn

00:16:14,720 --> 00:16:20,950
us about the fact that we've not handled

00:16:17,990 --> 00:16:24,440
a possible value so nothing too

00:16:20,950 --> 00:16:29,080
different so far and of course we fix it

00:16:24,440 --> 00:16:31,610
by addressing all the cases one of the

00:16:29,080 --> 00:16:32,930
concepts in here the difference is

00:16:31,610 --> 00:16:34,190
between typescript is the new types

00:16:32,930 --> 00:16:36,230
we've seen that there is this concept of

00:16:34,190 --> 00:16:38,180
type narrowing you can have a variant

00:16:36,230 --> 00:16:40,040
like something or something else and you

00:16:38,180 --> 00:16:45,050
can perform a guard against it and turn

00:16:40,040 --> 00:16:48,740
it into just something in in Oh camel

00:16:45,050 --> 00:16:50,300
with an asterisks you cannot do it a

00:16:48,740 --> 00:16:51,920
variant the type constructor of a

00:16:50,300 --> 00:16:54,230
variant so for bar in this particular

00:16:51,920 --> 00:16:57,320
case cannot live in isolation and the

00:16:54,230 --> 00:16:59,660
only way to guard against this is to use

00:16:57,320 --> 00:17:01,520
pattern matching and a side note here

00:16:59,660 --> 00:17:03,440
because I know polymorphic variants are

00:17:01,520 --> 00:17:05,510
a little bit different than that but

00:17:03,440 --> 00:17:08,120
regular variants cannot live in

00:17:05,510 --> 00:17:11,660
isolation from their parent variant if

00:17:08,120 --> 00:17:13,190
you will yeah so therefore the only the

00:17:11,660 --> 00:17:16,460
only way to get a value out of this is

00:17:13,190 --> 00:17:18,770
to is to pattern match it's literally

00:17:16,460 --> 00:17:22,580
the only way to figure out which value

00:17:18,770 --> 00:17:26,320
of the variant we are holding and

00:17:22,580 --> 00:17:29,060
o'connell it's a it's quite humble I

00:17:26,320 --> 00:17:31,700
think to provide one and only good one

00:17:29,060 --> 00:17:33,320
option not brag about you know multiple

00:17:31,700 --> 00:17:35,330
different ways in which we could do it

00:17:33,320 --> 00:17:37,070
so for example in typescript you could

00:17:35,330 --> 00:17:40,160
do it by switch you could do it by if

00:17:37,070 --> 00:17:42,380
statements you could use a the following

00:17:40,160 --> 00:17:43,940
function you could use a radio filter

00:17:42,380 --> 00:17:47,539
with a type guard to get

00:17:43,940 --> 00:17:50,320
exactly this this particular result

00:17:47,539 --> 00:17:52,820
namely give me a list of things that

00:17:50,320 --> 00:17:55,370
contains things that are knowable or

00:17:52,820 --> 00:17:57,110
optionals or maybe however you want to

00:17:55,370 --> 00:18:01,940
call them and turn me into the list

00:17:57,110 --> 00:18:03,740
which is just some and in you know camel

00:18:01,940 --> 00:18:05,809
the nice thing is there's only one way

00:18:03,740 --> 00:18:09,110
way to get the value out of this namely

00:18:05,809 --> 00:18:12,620
the pattern matching another one is

00:18:09,110 --> 00:18:14,539
interesting so you know camel everything

00:18:12,620 --> 00:18:18,590
is immutable by default but mutability

00:18:14,539 --> 00:18:20,779
is really useful to weather weather bit

00:18:18,590 --> 00:18:22,820
poor performance or sometimes it's quite

00:18:20,779 --> 00:18:24,590
nice for expressiveness if you don't

00:18:22,820 --> 00:18:26,360
want to go all crazy functional and you

00:18:24,590 --> 00:18:28,610
want to write something using a while

00:18:26,360 --> 00:18:29,330
loop because it communicates your

00:18:28,610 --> 00:18:33,500
intention better

00:18:29,330 --> 00:18:35,480
mutability is a useful tool to have and

00:18:33,500 --> 00:18:37,159
your common what's nice is that mutable

00:18:35,480 --> 00:18:39,830
meet immutable types are fundamentally

00:18:37,159 --> 00:18:42,889
incompatible with each other so you

00:18:39,830 --> 00:18:44,929
you'll never end up accidentally you

00:18:42,889 --> 00:18:47,929
know sneaking a mutable type into an

00:18:44,929 --> 00:18:51,919
immutable type or even worse immutable

00:18:47,929 --> 00:18:53,870
type into a mutable type you can achieve

00:18:51,919 --> 00:18:55,580
this by either using immutable keyword

00:18:53,870 --> 00:18:57,110
when you're dealing with records or

00:18:55,580 --> 00:19:01,039
reference type like in this particular

00:18:57,110 --> 00:19:03,799
example so I find this example quite

00:19:01,039 --> 00:19:06,940
good of about how even though it's

00:19:03,799 --> 00:19:09,799
simple about how those type differs so

00:19:06,940 --> 00:19:12,340
first first error is obvious like you

00:19:09,799 --> 00:19:16,519
cannot mutate they by default immutable

00:19:12,340 --> 00:19:18,470
let binding the second example is quite

00:19:16,519 --> 00:19:21,740
interesting as well because even the

00:19:18,470 --> 00:19:24,470
syntax for declaring something immutable

00:19:21,740 --> 00:19:26,779
namely the reference is wildly different

00:19:24,470 --> 00:19:28,580
from the current something from

00:19:26,779 --> 00:19:30,080
declaring something immutable so the

00:19:28,580 --> 00:19:32,450
reference types by the way the reference

00:19:30,080 --> 00:19:35,690
itself immutable but the valued holds is

00:19:32,450 --> 00:19:37,879
and even the way you assign or you

00:19:35,690 --> 00:19:40,700
mutate the value that the reference type

00:19:37,879 --> 00:19:43,129
holds the even the syntax for that is

00:19:40,700 --> 00:19:44,960
different so it's quite hard to even

00:19:43,129 --> 00:19:46,879
make a mistake and then if you make a

00:19:44,960 --> 00:19:49,370
mistake as you can see in the two bottom

00:19:46,879 --> 00:19:53,029
examples the compiler is gonna warn you

00:19:49,370 --> 00:19:54,379
against that this is not the feature of

00:19:53,029 --> 00:19:55,309
the type system this is a feature of a

00:19:54,379 --> 00:19:56,860
camel

00:19:55,309 --> 00:20:00,200
- the last feature I'm gonna talk about

00:19:56,860 --> 00:20:04,820
by far the coolest thing even though

00:20:00,200 --> 00:20:08,539
when I heard about some hipster sweet

00:20:04,820 --> 00:20:12,049
J's sort of things back in the day I was

00:20:08,539 --> 00:20:13,879
really struggling to understand how why

00:20:12,049 --> 00:20:16,039
would you like to create your own

00:20:13,879 --> 00:20:18,409
version and syntax flavor of the

00:20:16,039 --> 00:20:19,669
language but PPX is is a feature which

00:20:18,409 --> 00:20:22,990
effectively allows you to do some

00:20:19,669 --> 00:20:26,090
tactical extensions - oh come on

00:20:22,990 --> 00:20:28,580
so for example JSX could be implemented

00:20:26,090 --> 00:20:32,659
as a PBX not sure whether the current

00:20:28,580 --> 00:20:35,960
implementation is and one of the coolest

00:20:32,659 --> 00:20:37,879
things deny allows you to do is you can

00:20:35,960 --> 00:20:40,429
have a string and you can type some

00:20:37,879 --> 00:20:42,860
stuff or the contents in this string and

00:20:40,429 --> 00:20:45,799
you can drop the type system into the

00:20:42,860 --> 00:20:47,929
actual value of the string and the type

00:20:45,799 --> 00:20:50,330
check against it so I've got a few now

00:20:47,929 --> 00:20:53,629
like give examples thrown from the

00:20:50,330 --> 00:20:57,230
internet this is an example of a graph

00:20:53,629 --> 00:20:59,809
KO PBX in action so all of this you see

00:20:57,230 --> 00:21:01,789
from the keyword graph killed all the

00:20:59,809 --> 00:21:04,580
way down to the bottom really no Connell

00:21:01,789 --> 00:21:07,610
is a string the difference is that we

00:21:04,580 --> 00:21:10,100
flagged it with graph kill which tells

00:21:07,610 --> 00:21:13,490
the compiler use the graph kill PBX for

00:21:10,100 --> 00:21:16,100
it so not only you are gonna get you

00:21:13,490 --> 00:21:18,619
know autocomplete like you expect from

00:21:16,100 --> 00:21:20,779
any editor when you're writing your own

00:21:18,619 --> 00:21:23,509
queries you're gonna get type checking

00:21:20,779 --> 00:21:25,580
against your own schema and you know you

00:21:23,509 --> 00:21:29,499
could theoretically do it for any query

00:21:25,580 --> 00:21:34,519
system with SQL elasticsearch etc etc

00:21:29,499 --> 00:21:39,470
another cool PPX the result there is a

00:21:34,519 --> 00:21:40,279
CSS PP x or PP xbs CSS if you want to

00:21:39,470 --> 00:21:42,860
find on github

00:21:40,279 --> 00:21:44,720
little bit harder to configure but so

00:21:42,860 --> 00:21:47,090
amazing so allows you to write

00:21:44,720 --> 00:21:50,419
effectively CSS inside of your o'connell

00:21:47,090 --> 00:21:54,049
slash reason file and you're gonna get

00:21:50,419 --> 00:21:56,749
proper power of of a type system inside

00:21:54,049 --> 00:21:58,639
of your CSS so in this particular case

00:21:56,749 --> 00:22:01,159
it's telling you you know you cannot

00:21:58,639 --> 00:22:04,159
assign you can't use a unit of degrees

00:22:01,159 --> 00:22:05,940
when dealing with margins just quite

00:22:04,159 --> 00:22:09,390
more powerful than you

00:22:05,940 --> 00:22:15,150
winters this is what I think of a comma

00:22:09,390 --> 00:22:16,860
simply reliable and humble friend thank

00:22:15,150 --> 00:22:22,740
you

00:22:16,860 --> 00:22:22,740

YouTube URL: https://www.youtube.com/watch?v=2X1liDB-F1o


