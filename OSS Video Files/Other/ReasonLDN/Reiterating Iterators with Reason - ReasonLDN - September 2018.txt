Title: Reiterating Iterators with Reason - ReasonLDN - September 2018
Publication date: 2018-09-20
Playlist: ReasonLDN
Description: 
	Presented by Rizo Isrof - @rizo_isrof

What is the essence of iteration? How can we replace for-loops with safe, fast and composable code? Rediscover the fundamental ideas behind iterators through precise types in Reason. The always-wise Rizo will present two competing iteration models and discuss their trade-offs.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:06,120
so this talk is about iterators if you

00:00:02,970 --> 00:00:08,750
haven't guessed yet I can be similar

00:00:06,120 --> 00:00:12,059
again I gave a similar talk at a

00:00:08,750 --> 00:00:14,210
functional London functional Meetup

00:00:12,059 --> 00:00:16,710
where I talked about core routines and

00:00:14,210 --> 00:00:19,020
continuations and stuff like that that

00:00:16,710 --> 00:00:22,650
was a bit more technical so I extracted

00:00:19,020 --> 00:00:24,960
some more interesting ideas core ideas

00:00:22,650 --> 00:00:26,699
from that talk and we rolled them in

00:00:24,960 --> 00:00:30,570
reason so today I'm going to be

00:00:26,699 --> 00:00:34,050
presenting two different almost opposite

00:00:30,570 --> 00:00:35,910
models of iterators and I'm going to

00:00:34,050 --> 00:00:37,530
show you some examples I'm going to show

00:00:35,910 --> 00:00:40,620
you how to actually implement those

00:00:37,530 --> 00:00:43,320
iteration models in reason without any

00:00:40,620 --> 00:00:45,690
libraries without any special language

00:00:43,320 --> 00:00:48,239
features just a quick introduction about

00:00:45,690 --> 00:00:49,110
myself I'm a platform architect at

00:00:48,239 --> 00:00:54,000
pusher

00:00:49,110 --> 00:00:57,570
this is pusher by the way we use reason

00:00:54,000 --> 00:01:00,780
at pusher we mostly use it with the

00:00:57,570 --> 00:01:06,990
native back-end so almost like a camel

00:01:00,780 --> 00:01:09,720
with a recent syntax and our project is

00:01:06,990 --> 00:01:12,270
essentially a data processing analytics

00:01:09,720 --> 00:01:13,530
pipeline we implemented some of our

00:01:12,270 --> 00:01:15,479
metrics in in recent if you're

00:01:13,530 --> 00:01:17,310
interested in that just feel free to

00:01:15,479 --> 00:01:19,890
grab me after this talk and talk more

00:01:17,310 --> 00:01:23,189
about that so I've been using a comma

00:01:19,890 --> 00:01:25,380
for four years now and I started using

00:01:23,189 --> 00:01:27,030
reason on the day one when it was

00:01:25,380 --> 00:01:29,009
released I was super excited about it

00:01:27,030 --> 00:01:32,340
because I also I'm a language designer

00:01:29,009 --> 00:01:34,290
myself and I was building a relatively

00:01:32,340 --> 00:01:36,270
similar language at that time I'm also

00:01:34,290 --> 00:01:37,170
very interested in streaming it writers

00:01:36,270 --> 00:01:40,680
and coroutines

00:01:37,170 --> 00:01:43,950
and that's kind of explains this talk as

00:01:40,680 --> 00:01:49,710
well so many problems can be solved with

00:01:43,950 --> 00:01:52,619
iterators streaming streaming problems

00:01:49,710 --> 00:01:55,530
are everywhere in around us in in

00:01:52,619 --> 00:01:58,229
programming we might not see some things

00:01:55,530 --> 00:02:00,630
as streaming but in reality I think even

00:01:58,229 --> 00:02:02,189
some things like for example functional

00:02:00,630 --> 00:02:04,770
reactive programming can be described as

00:02:02,189 --> 00:02:08,160
streaming I'm not going to talk about

00:02:04,770 --> 00:02:12,270
that specifically but I think most

00:02:08,160 --> 00:02:15,960
people probably know about that so

00:02:12,270 --> 00:02:19,700
why our iterators useful or interesting

00:02:15,960 --> 00:02:23,010
for me personally is it's because they

00:02:19,700 --> 00:02:25,410
allow us to replace imperative for loops

00:02:23,010 --> 00:02:28,310
with something that is more composable

00:02:25,410 --> 00:02:31,740
and sometimes even more efficient

00:02:28,310 --> 00:02:33,540
essentially if we have a for loop and we

00:02:31,740 --> 00:02:35,520
want we want to write an efficient code

00:02:33,540 --> 00:02:38,310
then we need to just literally write

00:02:35,520 --> 00:02:40,350
everything in that for loop otherwise we

00:02:38,310 --> 00:02:41,760
will probably sacrifice performance but

00:02:40,350 --> 00:02:44,400
with iterators what we can do is

00:02:41,760 --> 00:02:46,140
preserve this composability of like

00:02:44,400 --> 00:02:48,950
modular design we can write different

00:02:46,140 --> 00:02:52,920
units and compose them together without

00:02:48,950 --> 00:02:55,230
paying too much for that specifically so

00:02:52,920 --> 00:02:58,530
this line here I think is essentially

00:02:55,230 --> 00:03:01,020
the core idea behind this principle on

00:02:58,530 --> 00:03:04,620
the Left we have something that applies

00:03:01,020 --> 00:03:06,840
the function f and G with the map

00:03:04,620 --> 00:03:09,210
Combinator so we essentially apply this

00:03:06,840 --> 00:03:11,670
function to the elements in the list but

00:03:09,210 --> 00:03:14,490
we do it twice what's happening there is

00:03:11,670 --> 00:03:18,090
map G list is producing a new list and

00:03:14,490 --> 00:03:19,290
then we say map F over that list and

00:03:18,090 --> 00:03:20,820
essentially we have to traverse the

00:03:19,290 --> 00:03:23,400
collection twice and we need to allocate

00:03:20,820 --> 00:03:25,710
that collection twice while in the

00:03:23,400 --> 00:03:28,200
second case what's happening is that we

00:03:25,710 --> 00:03:30,750
just took these two functions F and G we

00:03:28,200 --> 00:03:33,120
combine them we compose them and we run

00:03:30,750 --> 00:03:34,710
the map transformation only once in the

00:03:33,120 --> 00:03:37,380
list so this is like the core idea

00:03:34,710 --> 00:03:39,840
behind a traitor's we can think about

00:03:37,380 --> 00:03:43,380
them as non-blocking collections or like

00:03:39,840 --> 00:03:46,050
streams and many modern programming

00:03:43,380 --> 00:03:48,090
languages adopted iterators and put them

00:03:46,050 --> 00:03:51,180
in the center at the core of the

00:03:48,090 --> 00:03:54,390
language design languages like Python

00:03:51,180 --> 00:03:57,030
Ruby C++ JavaScript or even like rust

00:03:54,390 --> 00:03:59,370
have iterators and yeah and they have

00:03:57,030 --> 00:04:02,460
very good support for iterators but what

00:03:59,370 --> 00:04:05,270
about reason well reason doesn't really

00:04:02,460 --> 00:04:05,270
have iterators

00:04:06,840 --> 00:04:11,459
at least there's no built-in support for

00:04:09,510 --> 00:04:13,560
them but that's fine we can we can

00:04:11,459 --> 00:04:15,510
create them in in reason without any

00:04:13,560 --> 00:04:19,410
changes to go in which we see which is

00:04:15,510 --> 00:04:21,329
super awesome so again I will be talking

00:04:19,410 --> 00:04:23,310
about two different bottles let's start

00:04:21,329 --> 00:04:25,139
with something simpler

00:04:23,310 --> 00:04:30,540
let's just look at it writers in

00:04:25,139 --> 00:04:36,570
JavaScript so this is a simple wrench

00:04:30,540 --> 00:04:38,310
iterator it confirms to the protocol the

00:04:36,570 --> 00:04:40,530
iterator protocol which is really just a

00:04:38,310 --> 00:04:43,260
convention and the only thing that it

00:04:40,530 --> 00:04:46,950
needs to do is say that it is a symbol

00:04:43,260 --> 00:04:50,100
it has the symbol dot iterator key to

00:04:46,950 --> 00:04:53,240
indicate that it's an iterator and it

00:04:50,100 --> 00:04:56,639
has the next function which will produce

00:04:53,240 --> 00:04:59,220
the value for the consumer of this

00:04:56,639 --> 00:05:02,430
iterator the way it's done it is quite

00:04:59,220 --> 00:05:05,130
interesting our function next function

00:05:02,430 --> 00:05:08,010
returns a pair of values it returns the

00:05:05,130 --> 00:05:14,490
done flag which is a boolean and the

00:05:08,010 --> 00:05:16,680
value itself and while while our done

00:05:14,490 --> 00:05:18,539
flag is set to true we know that we have

00:05:16,680 --> 00:05:20,940
values to consume but once it's set to

00:05:18,539 --> 00:05:24,110
false the computation is essentially

00:05:20,940 --> 00:05:26,880
finished and we need to stop and

00:05:24,110 --> 00:05:29,190
JavaScript has a built-in syntax for for

00:05:26,880 --> 00:05:33,210
iterators which is also very useful so

00:05:29,190 --> 00:05:36,360
we can use that range iterator create

00:05:33,210 --> 00:05:37,919
the iterator itself and iterate on all

00:05:36,360 --> 00:05:39,330
the numbers produced by that and of

00:05:37,919 --> 00:05:43,169
course that's just going to give us one

00:05:39,330 --> 00:05:47,760
two three four there's a simple way to

00:05:43,169 --> 00:05:49,380
write iterators in JavaScript and that

00:05:47,760 --> 00:05:51,870
can be achieved with generators so

00:05:49,380 --> 00:05:53,850
generators are really just an easy way

00:05:51,870 --> 00:05:58,190
to write iterators it's a special

00:05:53,850 --> 00:06:01,880
built-in syntax that translates a simple

00:05:58,190 --> 00:06:03,750
code like this into something that

00:06:01,880 --> 00:06:05,180
implements the protocol that I showed

00:06:03,750 --> 00:06:08,430
you previously

00:06:05,180 --> 00:06:11,780
so yield is the keyword in English in

00:06:08,430 --> 00:06:16,620
Atmos script 6 and it essentially will

00:06:11,780 --> 00:06:18,090
handle the publishing of this value to

00:06:16,620 --> 00:06:19,949
the consumer and it will suspend the

00:06:18,090 --> 00:06:22,770
state of this iterator

00:06:19,949 --> 00:06:25,039
and it will resume the state once the

00:06:22,770 --> 00:06:28,069
consumer calls the iterator again and

00:06:25,039 --> 00:06:31,349
again we can just simply use this value

00:06:28,069 --> 00:06:32,789
in the same way so there's no actual

00:06:31,349 --> 00:06:35,129
difference between iterators and

00:06:32,789 --> 00:06:40,460
generators generators are just iterators

00:06:35,129 --> 00:06:42,779
with better syntax so before I explain

00:06:40,460 --> 00:06:44,729
iterators in reason let's just go back

00:06:42,779 --> 00:06:45,719
to something very very simple like just

00:06:44,729 --> 00:06:48,150
the fundamentals

00:06:45,719 --> 00:06:49,919
what is it eration about what is the

00:06:48,150 --> 00:06:54,240
essence of iteration and for me

00:06:49,919 --> 00:06:56,689
personally it's as simple as as a

00:06:54,240 --> 00:06:58,860
function so we can start with functions

00:06:56,689 --> 00:07:01,830
what do we need from functions we need

00:06:58,860 --> 00:07:05,189
to well iterate on values so we need to

00:07:01,830 --> 00:07:07,939
get valleys from functions there's a

00:07:05,189 --> 00:07:11,279
type of that so this is not an actual

00:07:07,939 --> 00:07:13,439
reason or a common syntax I simplified

00:07:11,279 --> 00:07:17,759
it a bit but essentially this is a

00:07:13,439 --> 00:07:20,969
function that once code will give us a

00:07:17,759 --> 00:07:22,229
value of some type we can continuously

00:07:20,969 --> 00:07:24,750
call it we can call it multiple times

00:07:22,229 --> 00:07:29,849
and we will get the value every single

00:07:24,750 --> 00:07:32,759
time so it's essentially a a producer we

00:07:29,849 --> 00:07:35,189
can pull it it's a almost like a pull

00:07:32,759 --> 00:07:37,229
based iterator we can pull it and it

00:07:35,189 --> 00:07:41,009
will give us this value there's one

00:07:37,229 --> 00:07:44,129
issue with this function if analyze from

00:07:41,009 --> 00:07:48,000
this iteration perspective can you can

00:07:44,129 --> 00:07:52,469
you tell me what it is what do you think

00:07:48,000 --> 00:07:54,599
is the problem yep yeah exactly so what

00:07:52,469 --> 00:07:57,930
if it runs out of pace what if the

00:07:54,599 --> 00:08:01,110
iterator is limited so it has a specific

00:07:57,930 --> 00:08:03,750
fixed number of things how can we you

00:08:01,110 --> 00:08:07,139
know say that it's done when I the

00:08:03,750 --> 00:08:08,759
consumer don't need any more values I

00:08:07,139 --> 00:08:10,830
can just stop calling this function and

00:08:08,759 --> 00:08:14,310
I'm satisfied I'm done but what if the

00:08:10,830 --> 00:08:15,779
iterator terminates because we exhausted

00:08:14,310 --> 00:08:17,039
the collection or maybe because we're

00:08:15,779 --> 00:08:18,960
reading lines from the standard input

00:08:17,039 --> 00:08:21,020
and we got end of file or something like

00:08:18,960 --> 00:08:25,770
that so how can we say that it stopped

00:08:21,020 --> 00:08:27,240
well we could is an optional value type

00:08:25,770 --> 00:08:29,669
or something like that to signal this

00:08:27,240 --> 00:08:31,480
termination but well it's just what

00:08:29,669 --> 00:08:36,040
about

00:08:31,480 --> 00:08:38,620
sections so if I try to call this

00:08:36,040 --> 00:08:40,990
function and it doesn't have any values

00:08:38,620 --> 00:08:42,760
to give me you can just rise an

00:08:40,990 --> 00:08:47,200
exception and that's acceptable that's

00:08:42,760 --> 00:08:49,360
fine I'll try to explain later why it's

00:08:47,200 --> 00:08:51,160
fine why I think it's fine and I will

00:08:49,360 --> 00:08:53,830
also show you the implementation with

00:08:51,160 --> 00:08:55,390
options but for now let's just see what

00:08:53,830 --> 00:08:58,870
happens let's just use exceptions let's

00:08:55,390 --> 00:09:01,570
just use this specific model so we

00:08:58,870 --> 00:09:03,100
define this iterator type that is the

00:09:01,570 --> 00:09:05,320
same thing that I showed you so it's a

00:09:03,100 --> 00:09:08,230
pool based iterator we need to ask for

00:09:05,320 --> 00:09:11,260
things to to get them we define the stop

00:09:08,230 --> 00:09:13,360
iteration exception that will be used to

00:09:11,260 --> 00:09:16,270
indicate the termination of the producer

00:09:13,360 --> 00:09:20,110
and then you know we need some state

00:09:16,270 --> 00:09:21,940
let's let's implement a function called

00:09:20,110 --> 00:09:24,300
count for example that will produce a

00:09:21,940 --> 00:09:27,160
sequence of numbers up to a specific and

00:09:24,300 --> 00:09:30,940
so for that we need something like a

00:09:27,160 --> 00:09:32,170
current value current count and that's

00:09:30,940 --> 00:09:34,690
going to be a reference immutable

00:09:32,170 --> 00:09:38,160
reference and our count function will

00:09:34,690 --> 00:09:42,490
look like this so we have our reference

00:09:38,160 --> 00:09:44,440
notice that the count function has the

00:09:42,490 --> 00:09:46,210
type of iterator it's not explicitly

00:09:44,440 --> 00:09:48,280
stated there but it it's structurally

00:09:46,210 --> 00:09:51,580
compatible with that type so it's a

00:09:48,280 --> 00:09:54,310
function from nothing to a value in this

00:09:51,580 --> 00:09:59,530
case it's an integer so what's happening

00:09:54,310 --> 00:10:03,430
here well we we dereference the current

00:09:59,530 --> 00:10:06,010
value with a strength symbol to get the

00:10:03,430 --> 00:10:08,500
actual and we check if that n is greater

00:10:06,010 --> 00:10:13,030
than or equal to 3 and if it is we just

00:10:08,500 --> 00:10:13,900
stop explore the world and just stop and

00:10:13,030 --> 00:10:17,170
after that

00:10:13,900 --> 00:10:20,980
sorry if that's not the case if n is

00:10:17,170 --> 00:10:23,500
less than 3 we increment our current

00:10:20,980 --> 00:10:25,480
value and seem to return the previous

00:10:23,500 --> 00:10:28,990
value before we incremented it so that's

00:10:25,480 --> 00:10:30,850
gonna be like zero so and we can

00:10:28,990 --> 00:10:32,770
immediately start using this iterator

00:10:30,850 --> 00:10:35,710
it's a very silly and simple iterator

00:10:32,770 --> 00:10:37,660
but I think it's an iterator so we can

00:10:35,710 --> 00:10:40,180
call it multiple times and what once it

00:10:37,660 --> 00:10:43,420
reaches to the next time is going to be

00:10:40,180 --> 00:10:44,870
stopped iteration so we terminated this

00:10:43,420 --> 00:10:48,100
iteration

00:10:44,870 --> 00:10:50,080
okay so what do you think about this

00:10:48,100 --> 00:10:52,220
this is functional programming

00:10:50,080 --> 00:10:54,650
exceptions mutable state global

00:10:52,220 --> 00:10:57,380
variables I guess that's not what you

00:10:54,650 --> 00:10:59,570
came here for let's let's see if you can

00:10:57,380 --> 00:11:03,470
improve things a bit but the interesting

00:10:59,570 --> 00:11:06,190
thing here is that in reason this is not

00:11:03,470 --> 00:11:12,770
actually an issue and I'll explain why

00:11:06,190 --> 00:11:16,430
so let's go back to our pull function

00:11:12,770 --> 00:11:18,680
without the option type and let's add

00:11:16,430 --> 00:11:21,080
this option type so instead of using

00:11:18,680 --> 00:11:23,030
exceptions we will now use the option

00:11:21,080 --> 00:11:25,280
type which is slightly better from like

00:11:23,030 --> 00:11:28,150
a conceptual perspective it does have

00:11:25,280 --> 00:11:33,080
one issue though option types at least

00:11:28,150 --> 00:11:36,290
in the native compilation tool chain

00:11:33,080 --> 00:11:38,450
have a relatively high cost so every

00:11:36,290 --> 00:11:40,940
single time you have a value it has to

00:11:38,450 --> 00:11:42,500
be box it essentially in this option

00:11:40,940 --> 00:11:44,930
type I think the same applies to

00:11:42,500 --> 00:11:46,640
JavaScript I run some benchmarks that I

00:11:44,930 --> 00:11:48,310
will show you in the end and the results

00:11:46,640 --> 00:11:51,050
are quite interesting

00:11:48,310 --> 00:11:52,580
okay so let's use this type to implement

00:11:51,050 --> 00:11:55,070
our convention and see what happens

00:11:52,580 --> 00:11:58,190
so this time I'm not using global

00:11:55,070 --> 00:12:01,100
variables I'm putting this current

00:11:58,190 --> 00:12:03,940
mutable value within the scope of the

00:12:01,100 --> 00:12:10,520
closure that is returned but it's still

00:12:03,940 --> 00:12:12,440
this iterator type so it's almost the

00:12:10,520 --> 00:12:15,140
same code code the only difference is

00:12:12,440 --> 00:12:19,910
that instead of rising an exception we

00:12:15,140 --> 00:12:22,430
say none and we rub our count value into

00:12:19,910 --> 00:12:25,730
the sum constructor and of course we can

00:12:22,430 --> 00:12:27,920
just call it and we will get some zero

00:12:25,730 --> 00:12:30,790
someone some two and then none so this

00:12:27,920 --> 00:12:34,010
way we know that the iterator terminated

00:12:30,790 --> 00:12:39,410
without having to handle that exception

00:12:34,010 --> 00:12:41,450
seems like an improvement okay so but

00:12:39,410 --> 00:12:43,070
this this what does it have to do with

00:12:41,450 --> 00:12:46,940
iterators is this what we want to do

00:12:43,070 --> 00:12:52,070
well I feel I feel like there's one

00:12:46,940 --> 00:12:53,990
thing that I need to explain and and I

00:12:52,070 --> 00:12:56,630
hope that you will understand why this

00:12:53,990 --> 00:12:58,810
kind of code mutable code code is uses

00:12:56,630 --> 00:13:01,330
exceptions is actually quite

00:12:58,810 --> 00:13:04,810
in reason and the reason behind that is

00:13:01,330 --> 00:13:07,990
interfaces so interfaces are a very

00:13:04,810 --> 00:13:11,680
powerful way to describe abstract

00:13:07,990 --> 00:13:14,770
computations abstract logic in general

00:13:11,680 --> 00:13:19,210
so here we have the module type iterator

00:13:14,770 --> 00:13:22,150
interface the type T is essentially like

00:13:19,210 --> 00:13:24,550
the type of the interface which is

00:13:22,150 --> 00:13:28,840
iterator you can think about it as this

00:13:24,550 --> 00:13:30,760
for that scope and I listed here in am

00:13:28,840 --> 00:13:32,680
rated here a few functions helper

00:13:30,760 --> 00:13:36,240
functions that are typically seen in

00:13:32,680 --> 00:13:40,060
iterators like map filter taken fold

00:13:36,240 --> 00:13:42,610
just to give a quick explanation of what

00:13:40,060 --> 00:13:46,780
each one of them does essentially map

00:13:42,610 --> 00:13:49,780
takes a function that can transform some

00:13:46,780 --> 00:13:52,630
values and it translates the iterator of

00:13:49,780 --> 00:13:55,230
types of values of type a into an

00:13:52,630 --> 00:13:58,660
iterator of values of values of type B

00:13:55,230 --> 00:14:00,760
filter can ignore some values by having

00:13:58,660 --> 00:14:03,400
a predicate function that essentially

00:14:00,760 --> 00:14:05,140
says no I don't want this value when it

00:14:03,400 --> 00:14:06,760
returns false it means that we we are

00:14:05,140 --> 00:14:09,700
not interested in that value at all so

00:14:06,760 --> 00:14:11,410
just ignore it take it's quite

00:14:09,700 --> 00:14:14,320
interesting because it limits our

00:14:11,410 --> 00:14:19,270
iterator it has to the power to say I'm

00:14:14,320 --> 00:14:20,500
only going to publish and elements and

00:14:19,270 --> 00:14:22,570
after that I'm done

00:14:20,500 --> 00:14:26,380
so essentially it would rise an

00:14:22,570 --> 00:14:28,180
exception or use a non value to indicate

00:14:26,380 --> 00:14:30,130
that and finally fold is a very useful

00:14:28,180 --> 00:14:32,530
Combinator that allows us to essentially

00:14:30,130 --> 00:14:36,100
compress an iterator into one single

00:14:32,530 --> 00:14:39,580
value using this stepping reducer

00:14:36,100 --> 00:14:43,870
function okay so what's so special about

00:14:39,580 --> 00:14:45,970
this well this is abstraction this is

00:14:43,870 --> 00:14:48,070
something that allows us to think about

00:14:45,970 --> 00:14:50,500
it writers in a very general sense

00:14:48,070 --> 00:14:52,630
without having to commit to a specific

00:14:50,500 --> 00:14:55,240
implementation so this is something that

00:14:52,630 --> 00:14:57,430
just describes what we want to have but

00:14:55,240 --> 00:15:03,790
it doesn't give gives give us any

00:14:57,430 --> 00:15:05,200
specific implementations so and if if

00:15:03,790 --> 00:15:07,030
you have something that implements this

00:15:05,200 --> 00:15:09,580
interface regardless of the

00:15:07,030 --> 00:15:12,160
implementation you can be assured you

00:15:09,580 --> 00:15:12,430
can be safe that nothing bad is going to

00:15:12,160 --> 00:15:15,040
happen

00:15:12,430 --> 00:15:17,200
because do you see any mutations here do

00:15:15,040 --> 00:15:21,520
you see any exceptions all of that is

00:15:17,200 --> 00:15:25,360
essentially protected by this interface

00:15:21,520 --> 00:15:29,140
okay so now that we know that let's try

00:15:25,360 --> 00:15:35,080
to implement this interface with our

00:15:29,140 --> 00:15:36,250
original pool iteration type this is the

00:15:35,080 --> 00:15:37,990
map and fault functions

00:15:36,250 --> 00:15:40,720
I think the implementation is very

00:15:37,990 --> 00:15:43,180
straightforward so essentially what's

00:15:40,720 --> 00:15:45,790
happening here is that we take our

00:15:43,180 --> 00:15:47,950
iteration iterator as a as an argument

00:15:45,790 --> 00:15:50,170
in map and since we know that it's a

00:15:47,950 --> 00:15:52,450
function because of that specific type

00:15:50,170 --> 00:15:54,940
declaration we can simply call it and

00:15:52,450 --> 00:15:57,520
see whether it has a value to give us

00:15:54,940 --> 00:16:00,370
and if it doesn't have well that's fine

00:15:57,520 --> 00:16:02,709
the map itself which is an iterator is

00:16:00,370 --> 00:16:04,750
going to terminate too if it does have a

00:16:02,709 --> 00:16:08,350
value we simply need to you know obey

00:16:04,750 --> 00:16:10,630
the type and wrap it into an option and

00:16:08,350 --> 00:16:13,029
apply F to perform the transformation

00:16:10,630 --> 00:16:14,620
and fold is very straightforward

00:16:13,029 --> 00:16:16,630
straight forward to the same thing

00:16:14,620 --> 00:16:19,060
happens here we check if the iterator

00:16:16,630 --> 00:16:21,810
has any values for us if it doesn't we

00:16:19,060 --> 00:16:25,360
simply terminate with the initial or the

00:16:21,810 --> 00:16:27,160
the accumulator value so far if it does

00:16:25,360 --> 00:16:29,980
have values then we use the F function

00:16:27,160 --> 00:16:34,240
to compress that value into the next one

00:16:29,980 --> 00:16:37,690
and we continue recursively and with

00:16:34,240 --> 00:16:39,370
this to three functions and a type we

00:16:37,690 --> 00:16:44,709
can already start writing some pipe

00:16:39,370 --> 00:16:47,410
lines like this one so that symbol here

00:16:44,709 --> 00:16:49,480
is a pipe operator it's essentially

00:16:47,410 --> 00:16:53,260
function application in this case it's

00:16:49,480 --> 00:16:55,690
going to take count 3 as a argument and

00:16:53,260 --> 00:16:58,360
put it right there

00:16:55,690 --> 00:17:00,100
map will translate every single value

00:16:58,360 --> 00:17:02,589
that passes through that iterator and

00:17:00,100 --> 00:17:05,199
finally fold will wait for all the fun

00:17:02,589 --> 00:17:09,309
of a lose and sum them with a plus

00:17:05,199 --> 00:17:12,520
operator so we get 33 in this case okay

00:17:09,309 --> 00:17:17,559
so as I said there's a problem with this

00:17:12,520 --> 00:17:21,350
approach because it it might be slow in

00:17:17,559 --> 00:17:23,630
some cases okay so

00:17:21,350 --> 00:17:26,480
I promised that I would tell you about

00:17:23,630 --> 00:17:27,799
two different iteration models and as it

00:17:26,480 --> 00:17:29,090
typically happens in computer science

00:17:27,799 --> 00:17:33,740
there's always like this

00:17:29,090 --> 00:17:35,780
opposite model dual model that which

00:17:33,740 --> 00:17:37,760
essentially in which everything is

00:17:35,780 --> 00:17:41,840
essentially inverted so if we have this

00:17:37,760 --> 00:17:45,260
pool type that is a producer how can we

00:17:41,840 --> 00:17:47,450
get the opposite of that if that one was

00:17:45,260 --> 00:17:51,919
producing elements the opposite has to

00:17:47,450 --> 00:17:54,049
consume them right now this is a push

00:17:51,919 --> 00:17:56,510
this thing can be used to implement a

00:17:54,049 --> 00:17:59,780
push based iterator something that is

00:17:56,510 --> 00:18:02,270
actually consumes values but how can I

00:17:59,780 --> 00:18:04,610
use this to implement iterators I can

00:18:02,270 --> 00:18:06,350
give it something and it doesn't give me

00:18:04,610 --> 00:18:08,600
back anything it's like a black hole

00:18:06,350 --> 00:18:11,390
I just keep sending stuff but nothing

00:18:08,600 --> 00:18:14,299
comes out it's not that doesn't seem

00:18:11,390 --> 00:18:17,270
very useful but if I have a consumer

00:18:14,299 --> 00:18:20,179
like this one I can pass it to a

00:18:17,270 --> 00:18:22,700
producer and that producer might be able

00:18:20,179 --> 00:18:25,850
to give it some values and that can be

00:18:22,700 --> 00:18:28,159
useful so this is the final type of our

00:18:25,850 --> 00:18:30,620
push iterator it might look complicated

00:18:28,159 --> 00:18:32,299
but this is just two functions really

00:18:30,620 --> 00:18:34,280
it's just one function taking another

00:18:32,299 --> 00:18:37,179
function as an argument there's no magic

00:18:34,280 --> 00:18:40,159
here it's just regular tight and valleys

00:18:37,179 --> 00:18:42,679
okay so let's see if we can build

00:18:40,159 --> 00:18:45,520
something with this abstraction here we

00:18:42,679 --> 00:18:47,539
can defy the define the consumer type

00:18:45,520 --> 00:18:50,150
which is something that takes a value

00:18:47,539 --> 00:18:52,700
and does nothing unit means nothing and

00:18:50,150 --> 00:18:55,510
our iterator in this case is something

00:18:52,700 --> 00:19:02,390
that takes a consumer and does nothing

00:18:55,510 --> 00:19:03,620
so let's look at an example of our

00:19:02,390 --> 00:19:07,070
account function implemented in

00:19:03,620 --> 00:19:10,789
JavaScript with generators so here we

00:19:07,070 --> 00:19:12,320
have this count function or a generator

00:19:10,789 --> 00:19:14,809
because of the star symbol after

00:19:12,320 --> 00:19:16,760
function it it's a simple for loop and

00:19:14,809 --> 00:19:21,049
then it just yields the values up to a

00:19:16,760 --> 00:19:23,210
given n what can we tell about this

00:19:21,049 --> 00:19:25,130
yield keyword it seems very special the

00:19:23,210 --> 00:19:27,260
first time I learned about

00:19:25,130 --> 00:19:30,140
iterators I was like what is this yield

00:19:27,260 --> 00:19:34,130
like it just seems so strange like how

00:19:30,140 --> 00:19:34,900
is different to return and so on what is

00:19:34,130 --> 00:19:39,340
it

00:19:34,900 --> 00:19:41,980
type does it have a type well as I was

00:19:39,340 --> 00:19:46,780
researching this specific iteration

00:19:41,980 --> 00:19:48,910
model I was quite amazed by how my

00:19:46,780 --> 00:19:52,060
understanding of this specific pattern

00:19:48,910 --> 00:19:55,600
improved by learning this iteration

00:19:52,060 --> 00:19:59,200
model let's look at this equivalent

00:19:55,600 --> 00:20:01,180
implementation in in reason so the body

00:19:59,200 --> 00:20:03,940
of the function is almost identical to

00:20:01,180 --> 00:20:06,130
our JavaScript example as we can see

00:20:03,940 --> 00:20:08,110
there's a yield there's a for loop we

00:20:06,130 --> 00:20:09,910
just iterate and yield values but the

00:20:08,110 --> 00:20:12,070
difference is yield is not special

00:20:09,910 --> 00:20:16,270
anymore it's just an argument and it

00:20:12,070 --> 00:20:20,620
happens to be a function and count is an

00:20:16,270 --> 00:20:23,920
iterator that matches that type there so

00:20:20,620 --> 00:20:26,530
yield is a consumer and we essentially

00:20:23,920 --> 00:20:29,970
just you know recreated this iteration

00:20:26,530 --> 00:20:33,550
model from scratch I think it's pretty

00:20:29,970 --> 00:20:35,140
interesting and another interesting

00:20:33,550 --> 00:20:37,570
thing to notice is that yield is

00:20:35,140 --> 00:20:40,420
essentially just a callback or a

00:20:37,570 --> 00:20:42,460
continuation we we supply this function

00:20:40,420 --> 00:20:44,740
to receive the values and the producer

00:20:42,460 --> 00:20:47,050
will do something and generate these

00:20:44,740 --> 00:20:51,090
values and send them down so let's use

00:20:47,050 --> 00:20:52,210
this function we can create this numbers

00:20:51,090 --> 00:20:53,950
iterator

00:20:52,210 --> 00:20:56,800
that will only count up to three and

00:20:53,950 --> 00:20:59,380
then we need to give it a consumer that

00:20:56,800 --> 00:21:01,600
satisfies the consumer type well the

00:20:59,380 --> 00:21:05,310
easiest one is actually just you know GS

00:21:01,600 --> 00:21:08,290
dot log if you look at the type of GS

00:21:05,310 --> 00:21:10,720
log in back to script documentation

00:21:08,290 --> 00:21:16,390
it literally is our consumer it's the

00:21:10,720 --> 00:21:19,870
same thing and as we call noms with GS

00:21:16,390 --> 00:21:23,380
dot log that GS dot blog is our yield so

00:21:19,870 --> 00:21:26,280
we are essentially just for iterating

00:21:23,380 --> 00:21:27,430
with the for loop and logging things

00:21:26,280 --> 00:21:29,890
okay

00:21:27,430 --> 00:21:32,380
so how would we implement other

00:21:29,890 --> 00:21:37,170
functions in our original interface with

00:21:32,380 --> 00:21:39,770
this this is the implementation of map

00:21:37,170 --> 00:21:42,060
so

00:21:39,770 --> 00:21:44,160
yield is still in argument it's not

00:21:42,060 --> 00:21:47,340
special we receive it and we know that

00:21:44,160 --> 00:21:49,020
it's gonna consume the values somehow it

00:21:47,340 --> 00:21:50,610
doesn't really matter what its gonna do

00:21:49,020 --> 00:21:52,920
we just know that we need to send them

00:21:50,610 --> 00:21:56,880
down to that consumer that's our only

00:21:52,920 --> 00:21:59,510
responsibility in map but eater itself

00:21:56,880 --> 00:22:03,540
look at the type is a function right

00:21:59,510 --> 00:22:07,620
eater itself is a producer and we we saw

00:22:03,540 --> 00:22:11,610
here that if we pass a consumer to our

00:22:07,620 --> 00:22:15,000
producer things happen so in this case

00:22:11,610 --> 00:22:18,060
if we call eater which is our producer

00:22:15,000 --> 00:22:21,090
with that new function we know that the

00:22:18,060 --> 00:22:23,520
the final iterator itself will use that

00:22:21,090 --> 00:22:25,520
consumer right and in this consumer

00:22:23,520 --> 00:22:28,470
we're intercepting essentially that

00:22:25,520 --> 00:22:31,560
consumption instance and we are applying

00:22:28,470 --> 00:22:35,070
F before it actually consumes the value

00:22:31,560 --> 00:22:39,510
right before it we consume the value

00:22:35,070 --> 00:22:43,530
value with yield we apply F let's look

00:22:39,510 --> 00:22:47,880
at filter filter is very easy filter is

00:22:43,530 --> 00:22:51,240
essentially do you want to consume if we

00:22:47,880 --> 00:22:54,000
have P which is a predicate to test our

00:22:51,240 --> 00:22:57,410
value for inclusion in in the iterator

00:22:54,000 --> 00:23:02,370
in this new consumer function we check

00:22:57,410 --> 00:23:05,210
is P X true and if it is yield if not

00:23:02,370 --> 00:23:08,190
just don't do anything at all

00:23:05,210 --> 00:23:12,480
okay so fold fold is interesting because

00:23:08,190 --> 00:23:15,720
fold requires us to use mutation we have

00:23:12,480 --> 00:23:17,430
this consumer that we pass to eater but

00:23:15,720 --> 00:23:19,920
there's no way for us to extract any

00:23:17,430 --> 00:23:22,170
values from it it's a sink essentially

00:23:19,920 --> 00:23:24,000
it's a black hole again so we we know

00:23:22,170 --> 00:23:27,120
that whatever we put inside that

00:23:24,000 --> 00:23:28,710
iterator sorry consumer will happen but

00:23:27,120 --> 00:23:31,050
there's no way for us to extract values

00:23:28,710 --> 00:23:33,930
well turn out turns out there's a there

00:23:31,050 --> 00:23:36,750
is by using mutation so if we pre

00:23:33,930 --> 00:23:39,990
declare a result reference and then in

00:23:36,750 --> 00:23:43,440
our consumer we continuously change the

00:23:39,990 --> 00:23:45,780
result reference we know that in the end

00:23:43,440 --> 00:23:48,360
once eater itself the producer is

00:23:45,780 --> 00:23:50,460
finished we have the final value so

00:23:48,360 --> 00:23:55,040
that's our fault and we of course return

00:23:50,460 --> 00:23:55,040
the final result dereferenced

00:23:55,910 --> 00:23:59,880
another function that I had in my

00:23:57,840 --> 00:24:02,340
interface was take and take is very

00:23:59,880 --> 00:24:05,970
tricky because it requires us to use

00:24:02,340 --> 00:24:09,210
mutation and exceptions so in this case

00:24:05,970 --> 00:24:11,070
I separated the consumer into a step

00:24:09,210 --> 00:24:15,960
function it's essentially it's a

00:24:11,070 --> 00:24:19,440
consuming step downhill in the final

00:24:15,960 --> 00:24:21,090
statement expression in of take we call

00:24:19,440 --> 00:24:23,810
either with that step function and we

00:24:21,090 --> 00:24:27,360
wait for stop iteration exceptions and

00:24:23,810 --> 00:24:29,340
the step function itself will receive

00:24:27,360 --> 00:24:32,580
the value will consume the value it will

00:24:29,340 --> 00:24:36,870
also check the state of take to see if

00:24:32,580 --> 00:24:38,970
the count reached our limit n and if it

00:24:36,870 --> 00:24:41,580
haven't well in that case we need to

00:24:38,970 --> 00:24:44,040
update our count and consume let the

00:24:41,580 --> 00:24:47,040
yield consume the value otherwise we

00:24:44,040 --> 00:24:50,430
stop iteration but the thing is this top

00:24:47,040 --> 00:24:53,640
iteration exception is only available

00:24:50,430 --> 00:24:56,450
here we know that we handled it so it's

00:24:53,640 --> 00:24:59,550
not going to leak out into the other

00:24:56,450 --> 00:25:01,200
parts of our code it's completely

00:24:59,550 --> 00:25:07,860
contained in this function there's no

00:25:01,200 --> 00:25:10,200
risk of getting unsafe exceptions so I

00:25:07,860 --> 00:25:13,020
run some benchmarks with these different

00:25:10,200 --> 00:25:15,240
models I compared them with the standard

00:25:13,020 --> 00:25:17,610
JavaScript implementation I used both

00:25:15,240 --> 00:25:19,190
push and pull based iterator models

00:25:17,610 --> 00:25:22,650
iteration models that I showed you here

00:25:19,190 --> 00:25:24,120
and for the pull based model I used the

00:25:22,650 --> 00:25:27,390
one with options and the one with

00:25:24,120 --> 00:25:29,550
exceptions this is the basic benchmark

00:25:27,390 --> 00:25:31,680
that I came up with it's very simple it

00:25:29,550 --> 00:25:35,030
doesn't really do anything useful but it

00:25:31,680 --> 00:25:39,050
applies our combinators multiple times

00:25:35,030 --> 00:25:39,050
just to make sure that we have some

00:25:39,380 --> 00:25:46,770
diversity here and these are the results

00:25:43,460 --> 00:25:48,630
so blue is our standard iterators in

00:25:46,770 --> 00:25:50,700
JavaScript the ones that I showed you in

00:25:48,630 --> 00:25:51,530
the beginning red is our push based

00:25:50,700 --> 00:25:54,600
model

00:25:51,530 --> 00:25:59,700
yellow is pull and green is pull with

00:25:54,600 --> 00:26:01,680
exceptions as you can see our red which

00:25:59,700 --> 00:26:03,570
is the push based model the last one

00:26:01,680 --> 00:26:05,130
that I showed you is consistently more

00:26:03,570 --> 00:26:07,080
efficient than even the standard

00:26:05,130 --> 00:26:09,029
iterators I find it's very

00:26:07,080 --> 00:26:10,710
because it's the same language it's

00:26:09,029 --> 00:26:14,730
still JavaScript all of this is compiled

00:26:10,710 --> 00:26:16,440
to JavaScript and of course we can

00:26:14,730 --> 00:26:18,539
implement the same model in JavaScript

00:26:16,440 --> 00:26:19,980
but the one that we have in the language

00:26:18,539 --> 00:26:21,509
is slower than this one that I just

00:26:19,980 --> 00:26:26,549
implemented and it's not that

00:26:21,509 --> 00:26:29,100
complicated so yeah back to our types we

00:26:26,549 --> 00:26:30,889
have pull based iterators with option in

00:26:29,100 --> 00:26:33,419
this case and push based iterators

00:26:30,889 --> 00:26:36,570
sometimes they're called external and

00:26:33,419 --> 00:26:39,570
internal iterators and why do we need

00:26:36,570 --> 00:26:41,129
both like if this one is more efficient

00:26:39,570 --> 00:26:43,470
in in that benchmark why do we need the

00:26:41,129 --> 00:26:44,940
external iterators well there's always a

00:26:43,470 --> 00:26:47,100
trade-off right like in this case

00:26:44,940 --> 00:26:48,809
specifically there are some things that

00:26:47,100 --> 00:26:50,549
we can do with external iterators and

00:26:48,809 --> 00:26:51,029
thumbs some things that we cannot do

00:26:50,549 --> 00:26:53,970
with them

00:26:51,029 --> 00:26:56,700
for example zipping multiple iterators

00:26:53,970 --> 00:27:00,149
at once is hard if not impossible with

00:26:56,700 --> 00:27:02,309
internal iterators and splitting one

00:27:00,149 --> 00:27:04,109
iterator into multiple iterators is

00:27:02,309 --> 00:27:07,320
almost impossible with the externally

00:27:04,109 --> 00:27:11,669
return iteration model so I guess we

00:27:07,320 --> 00:27:15,929
just need both if you're if you want to

00:27:11,669 --> 00:27:18,809
use this iteration models both of them

00:27:15,929 --> 00:27:21,929
are implemented in a camel libraries

00:27:18,809 --> 00:27:26,340
they're compatible with reason there's

00:27:21,929 --> 00:27:27,230
no special there's nothing special in

00:27:26,340 --> 00:27:28,980
them essentially they're just

00:27:27,230 --> 00:27:30,629
essentially the same code that I showed

00:27:28,980 --> 00:27:33,450
you today so they can easily be compiled

00:27:30,629 --> 00:27:36,059
to JavaScript with reason I also wrote a

00:27:33,450 --> 00:27:39,570
very simple pull base iteration library

00:27:36,059 --> 00:27:40,889
which is entirely pure and doesn't rely

00:27:39,570 --> 00:27:44,909
on exceptions

00:27:40,889 --> 00:27:48,720
it's essentially a mixed approach that

00:27:44,909 --> 00:27:51,029
that I came up with based on both the

00:27:48,720 --> 00:27:55,200
portion pool based iterations iteration

00:27:51,029 --> 00:27:58,769
bowls so just to conclude what we have

00:27:55,200 --> 00:28:00,779
learned here was that it writers don't

00:27:58,769 --> 00:28:02,580
really require any special language

00:28:00,779 --> 00:28:04,789
features we can quite easily build them

00:28:02,580 --> 00:28:08,159
if we have a powerful enough language

00:28:04,789 --> 00:28:11,399
pure ish programming is possible in

00:28:08,159 --> 00:28:13,409
reason and a camel if we have strong

00:28:11,399 --> 00:28:16,200
types and interfaces essentially we can

00:28:13,409 --> 00:28:18,960
afford having mutations exceptions and

00:28:16,200 --> 00:28:21,180
all of that imperative stuff completely

00:28:18,960 --> 00:28:22,680
protected from the rest of the code

00:28:21,180 --> 00:28:26,150
because the interface is there to to

00:28:22,680 --> 00:28:28,440
make sure that it doesn't leak and also

00:28:26,150 --> 00:28:32,000
imperial functional code is possible so

00:28:28,440 --> 00:28:33,840
we can have impure dirty you know

00:28:32,000 --> 00:28:35,670
performance-oriented tricks in our

00:28:33,840 --> 00:28:37,920
functional code that's very interesting

00:28:35,670 --> 00:28:39,660
too and of course functions are the

00:28:37,920 --> 00:28:42,380
ultimate obstruction that the conclusion

00:28:39,660 --> 00:28:48,539
of my talk thank you very much

00:28:42,380 --> 00:28:48,539

YouTube URL: https://www.youtube.com/watch?v=9bHQJqzWQPU


