Title: Imandra Puts Reasoning into ReasonML - ReasonLDN - September 2018
Publication date: 2018-09-20
Playlist: ReasonLDN
Description: 
	Presented by Denis Ignatovich & Team AI - @DenisIgnatovich, @VerifiedByAI 

Ever wanted to know how theorem proofs can shortcut web application testing? Then don't miss this talk!

Denis and the team will lead us on a journey through Imandra, a sparkling new cloud native automated reasoning system allowing you to write code, mathematically analyse it, and verify its properties. Learn how a bleeding edge approach to code can unlock novel solutions to everyday problems with style.

Check it out before the meetup at https://www.imandra.ai/

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:03,510
hi everyone so we're a aesthetic

00:00:02,310 --> 00:00:06,000
integration and we'll talk to you about

00:00:03,510 --> 00:00:09,929
some mathematics that you can use today

00:00:06,000 --> 00:00:11,550
to make your lives much easier and so

00:00:09,929 --> 00:00:13,799
I'll just start with a brief kind of

00:00:11,550 --> 00:00:17,900
background so my name is Dennis and with

00:00:13,799 --> 00:00:21,449
me today we have actually met Jerry no

00:00:17,900 --> 00:00:23,519
Nicola and Dave and what kind of tax him

00:00:21,449 --> 00:00:27,510
in a bit and the slides that I'm showing

00:00:23,519 --> 00:00:28,949
you right now in hindsight after

00:00:27,510 --> 00:00:30,689
watching these things I realized that

00:00:28,949 --> 00:00:33,540
I've been speaking to business people

00:00:30,689 --> 00:00:37,290
for too long and when you're in that

00:00:33,540 --> 00:00:39,480
mode you you have to explain something

00:00:37,290 --> 00:00:41,219
like formal verification to people that

00:00:39,480 --> 00:00:44,129
have never written a line of code hence

00:00:41,219 --> 00:00:47,190
these slides and kind of hearing these

00:00:44,129 --> 00:00:49,110
great talks today helped me get back

00:00:47,190 --> 00:00:51,600
into the kind of technical frame of mind

00:00:49,110 --> 00:00:55,530
but please excuse the kind of the level

00:00:51,600 --> 00:00:59,399
of let's say technical analysis on these

00:00:55,530 --> 00:01:01,770
days but the basic idea is that if you

00:00:59,399 --> 00:01:02,940
think about different tried different

00:01:01,770 --> 00:01:06,540
types of systems whether we're talking

00:01:02,940 --> 00:01:09,600
about in commercial jets or all these

00:01:06,540 --> 00:01:11,640
constant glitches that you're seeing

00:01:09,600 --> 00:01:13,650
today so for example Nasdaq a couple of

00:01:11,640 --> 00:01:15,600
days ago now so they had a bug and they

00:01:13,650 --> 00:01:18,689
were closing auction for seven years

00:01:15,600 --> 00:01:22,380
that they just didn't know existed right

00:01:18,689 --> 00:01:24,689
so my background is up until three years

00:01:22,380 --> 00:01:25,920
ago I was working in Deutsche Bank and

00:01:24,689 --> 00:01:28,290
something called central is creating

00:01:25,920 --> 00:01:31,320
discs and one of the things that was

00:01:28,290 --> 00:01:33,420
responsible for is making sure that a

00:01:31,320 --> 00:01:36,119
trading system that had at any point in

00:01:33,420 --> 00:01:38,790
time you know billions of years of

00:01:36,119 --> 00:01:42,000
exposure out in the market couldn't have

00:01:38,790 --> 00:01:44,100
a glitch and that could happen because

00:01:42,000 --> 00:01:46,860
the brain of it was implemented about

00:01:44,100 --> 00:01:48,450
10,000 lines of matlab code so lots of

00:01:46,860 --> 00:01:53,280
things going in and lots of things going

00:01:48,450 --> 00:01:54,659
out so very quickly to have a situation

00:01:53,280 --> 00:01:56,850
where you lose a lot of money you get

00:01:54,659 --> 00:02:00,060
fired so I spend most of my time

00:01:56,850 --> 00:02:02,399
think about edge cases so you know

00:02:00,060 --> 00:02:06,390
what's a possible input that would lead

00:02:02,399 --> 00:02:11,459
to something bad and around that time

00:02:06,390 --> 00:02:12,920
2014 my best friend and roommate from

00:02:11,459 --> 00:02:16,180
college grant passed more

00:02:12,920 --> 00:02:20,180
for the company he was doing a PhD

00:02:16,180 --> 00:02:24,200
actually a postdoc research at Cambridge

00:02:20,180 --> 00:02:26,060
and we realized that again I apologize

00:02:24,200 --> 00:02:27,650
for the other technical slides we just

00:02:26,060 --> 00:02:30,910
put this together it comes from a

00:02:27,650 --> 00:02:33,950
business deck but it would basically

00:02:30,910 --> 00:02:35,230
what we realized is the techniques that

00:02:33,950 --> 00:02:37,670
people used to make sure that autopilot

00:02:35,230 --> 00:02:39,440
systems are safe and what I mean by that

00:02:37,670 --> 00:02:42,200
is you have to cover infinitely many

00:02:39,440 --> 00:02:44,930
possibilities right those techniques

00:02:42,200 --> 00:02:47,030
from formal methods got to important

00:02:44,930 --> 00:02:48,770
that they're mature enough that we can

00:02:47,030 --> 00:02:50,390
actually scale them to software develop

00:02:48,770 --> 00:02:54,650
in large so we're talking about things

00:02:50,390 --> 00:02:57,709
like finance products etc so this is

00:02:54,650 --> 00:02:59,600
about four and say five years ago and we

00:02:57,709 --> 00:03:03,890
had this idea and what the idea was that

00:02:59,600 --> 00:03:06,500
people are going to be writing a lot

00:03:03,890 --> 00:03:07,459
more functional code and again when

00:03:06,500 --> 00:03:09,650
we're trying to explain it to business

00:03:07,459 --> 00:03:11,900
people they ask what is functional

00:03:09,650 --> 00:03:13,700
programming and then they once we

00:03:11,900 --> 00:03:17,269
explain it to them they thought we were

00:03:13,700 --> 00:03:19,910
crazy so we started the company we

00:03:17,269 --> 00:03:21,530
started working on least on this product

00:03:19,910 --> 00:03:27,920
in Monza but also in a second

00:03:21,530 --> 00:03:34,130
and a couple years ago actually maybe

00:03:27,920 --> 00:03:35,780
even a year ago we can we saw that

00:03:34,130 --> 00:03:38,660
something called reason ml came out of

00:03:35,780 --> 00:03:40,519
Facebook and it was a big thing for us

00:03:38,660 --> 00:03:41,480
because we you know realize this this is

00:03:40,519 --> 00:03:43,160
something that's getting much much

00:03:41,480 --> 00:03:46,880
traction so even though we've been

00:03:43,160 --> 00:03:48,620
working finance and robotics luckily you

00:03:46,880 --> 00:03:51,140
know this community has formed and we

00:03:48,620 --> 00:03:52,190
you know happily embraced it and one of

00:03:51,140 --> 00:03:54,560
the things that we've done over the past

00:03:52,190 --> 00:03:56,420
couple of months is we've created an

00:03:54,560 --> 00:03:58,790
interface to reason ml so what we'll

00:03:56,420 --> 00:04:00,680
show you today allows you to really take

00:03:58,790 --> 00:04:04,100
these latest advances in formal

00:04:00,680 --> 00:04:06,709
verification so automated induction all

00:04:04,100 --> 00:04:09,709
of it type system stuff they don't see

00:04:06,709 --> 00:04:11,420
in a second SMT etc to make your life so

00:04:09,709 --> 00:04:14,239
much easier and what I mean by that is

00:04:11,420 --> 00:04:15,920
anytime you write a piece of code and

00:04:14,239 --> 00:04:18,530
you want to make sure it does something

00:04:15,920 --> 00:04:20,600
the traditional approach is you come up

00:04:18,530 --> 00:04:23,090
with a couple of test cases right which

00:04:20,600 --> 00:04:25,580
everyone hates you take courses on it

00:04:23,090 --> 00:04:29,060
anytime even then react I saw

00:04:25,580 --> 00:04:31,610
like point out on 12 out of 12 is

00:04:29,060 --> 00:04:33,530
testing jest or whatever it is but

00:04:31,610 --> 00:04:36,949
because it's it's painful everyone hates

00:04:33,530 --> 00:04:39,889
it what a mantra our product lousy to do

00:04:36,949 --> 00:04:41,620
is to write properties of your code at a

00:04:39,889 --> 00:04:42,949
high level at the level that you think

00:04:41,620 --> 00:04:44,180
so

00:04:42,949 --> 00:04:46,610
when you write something and say okay

00:04:44,180 --> 00:04:48,740
when a happens I expect beat always

00:04:46,610 --> 00:04:50,449
happen right when you're testing for

00:04:48,740 --> 00:04:52,340
these things you have to come up with a

00:04:50,449 --> 00:04:56,300
few examples of that and obviously

00:04:52,340 --> 00:04:58,669
testing never tells you that something

00:04:56,300 --> 00:05:00,680
will always work it just shows you a few

00:04:58,669 --> 00:05:02,710
instances where it might break down so

00:05:00,680 --> 00:05:06,319
this is the kind of the big idea behind

00:05:02,710 --> 00:05:08,629
a product mantra which you can try today

00:05:06,319 --> 00:05:12,169
it literally tried out a module that a I

00:05:08,629 --> 00:05:14,000
and what we will do today is give you a

00:05:12,169 --> 00:05:15,650
brief intro into it which is gonna be

00:05:14,000 --> 00:05:18,199
slightly kind of I guess Oh camel

00:05:15,650 --> 00:05:20,569
centric and then it will show you a game

00:05:18,199 --> 00:05:22,550
of tic-tac-toe which will be implement

00:05:20,569 --> 00:05:26,150
reason ml and all the cool things you

00:05:22,550 --> 00:05:28,400
can actually do with the mantra so I'm

00:05:26,150 --> 00:05:30,650
gonna quickly describe to you what Iman

00:05:28,400 --> 00:05:33,099
Dre is and how to use it and what the

00:05:30,650 --> 00:05:35,509
capabilities are being on there are

00:05:33,099 --> 00:05:38,000
we're just gonna go quickly over some

00:05:35,509 --> 00:05:40,430
examples from this first note hood that

00:05:38,000 --> 00:05:42,099
we brought so Amanda is a couple of

00:05:40,430 --> 00:05:45,500
things

00:05:42,099 --> 00:05:50,539
amanda is a programming language which

00:05:45,500 --> 00:05:53,210
is essentially Oh camel and it also is a

00:05:50,539 --> 00:05:56,419
reasoning engine that can reason about

00:05:53,210 --> 00:05:58,129
the pure purely functional subset of a

00:05:56,419 --> 00:06:01,069
camel transitively

00:05:58,129 --> 00:06:02,779
it can also reason about reason ml code

00:06:01,069 --> 00:06:05,319
because it's just a different front-end

00:06:02,779 --> 00:06:09,139
for the same AST

00:06:05,319 --> 00:06:12,860
so if you look at this very very simple

00:06:09,139 --> 00:06:17,449
example couple of functions they don't

00:06:12,860 --> 00:06:20,779
do a whole lot just taking an input an

00:06:17,449 --> 00:06:22,879
int value and checking whether a certain

00:06:20,779 --> 00:06:25,279
range is satisfied and returning

00:06:22,879 --> 00:06:29,629
different values depending on different

00:06:25,279 --> 00:06:31,699
ranges we input those function to mandra

00:06:29,629 --> 00:06:34,969
and we can compute with those functions

00:06:31,699 --> 00:06:37,639
so we can invoke the function G with a

00:06:34,969 --> 00:06:39,159
value of 5 and we got the result of

00:06:37,639 --> 00:06:46,099
applying

00:06:39,159 --> 00:06:48,349
irregular rattle what is unique about

00:06:46,099 --> 00:06:50,870
him andrew is that he could support a

00:06:48,349 --> 00:06:55,610
couple of key words that other languages

00:06:50,870 --> 00:06:57,889
don't and a key word that we we support

00:06:55,610 --> 00:07:00,309
is very fine

00:06:57,889 --> 00:07:05,539
what verify does is it takes

00:07:00,309 --> 00:07:07,999
specification and it tries to prove that

00:07:05,539 --> 00:07:11,569
specification for you

00:07:07,999 --> 00:07:15,469
the interesting part of how Amanda works

00:07:11,569 --> 00:07:19,129
is that it doesn't do if you're familiar

00:07:15,469 --> 00:07:21,650
with a quick check for example or other

00:07:19,129 --> 00:07:25,669
forms of generative testing imagine

00:07:21,650 --> 00:07:27,889
doesn't do that in mantra reasons about

00:07:25,669 --> 00:07:29,689
code that you've written it statically

00:07:27,889 --> 00:07:32,990
analyzes the code that you've written

00:07:29,689 --> 00:07:35,240
and it's able to prove properties about

00:07:32,990 --> 00:07:37,389
all possible values that those functions

00:07:35,240 --> 00:07:43,729
or the those property that were

00:07:37,389 --> 00:07:46,189
satisfied so in in mantra is a formal

00:07:43,729 --> 00:07:49,099
system and in formal methods there's

00:07:46,189 --> 00:07:52,580
essentially three different classes of

00:07:49,099 --> 00:07:54,499
systems there's automatic theorem

00:07:52,580 --> 00:07:58,459
provers there is a model checkers and

00:07:54,499 --> 00:08:02,649
there's abstract interpreters abstract

00:07:58,459 --> 00:08:05,839
interpreters are kind of a way of

00:08:02,649 --> 00:08:10,430
verifying properties for a sufficiently

00:08:05,839 --> 00:08:15,199
correct approximation of a program model

00:08:10,430 --> 00:08:18,080
checking deals with exploring the entire

00:08:15,199 --> 00:08:20,180
state space of a program and testing

00:08:18,080 --> 00:08:24,409
properties for every possible branch of

00:08:20,180 --> 00:08:26,479
that program the critical thing about

00:08:24,409 --> 00:08:29,569
model checking is that it only works for

00:08:26,479 --> 00:08:32,870
finite state systems so you can't reason

00:08:29,569 --> 00:08:36,169
with model checking on a function like

00:08:32,870 --> 00:08:37,870
map because map is what actually takes

00:08:36,169 --> 00:08:42,229
an infinite the least it doesn't

00:08:37,870 --> 00:08:45,440
necessarily terminate automatic theorem

00:08:42,229 --> 00:08:49,100
proving is a different way and it deals

00:08:45,440 --> 00:08:51,020
with proving properties from the ground

00:08:49,100 --> 00:08:54,830
up from set of axioms

00:08:51,020 --> 00:08:58,940
and a set of inference rules what Amanda

00:08:54,830 --> 00:09:02,270
is is kind of a mix of automatic tear

00:08:58,940 --> 00:09:07,070
improving and form of bounded mullet

00:09:02,270 --> 00:09:12,980
checking in this case for example when

00:09:07,070 --> 00:09:15,470
we say verify that every for every X the

00:09:12,980 --> 00:09:19,130
invocation of G of X is going to be less

00:09:15,470 --> 00:09:22,940
or equal of 120 - Amanda can prove this

00:09:19,130 --> 00:09:25,910
by model checking because the G function

00:09:22,940 --> 00:09:26,390
that we saw here only has two cases

00:09:25,910 --> 00:09:28,910
right

00:09:26,390 --> 00:09:33,770
it can only say whether X is bigger than

00:09:28,910 --> 00:09:36,230
22 then it returns 9 if X is less than

00:09:33,770 --> 00:09:38,209
22 then it just returns 100 plus X it

00:09:36,230 --> 00:09:41,360
doesn't amount that doesn't need to the

00:09:38,209 --> 00:09:45,320
reason about infinite space to verify

00:09:41,360 --> 00:09:50,959
that this G DX is less than equal to 122

00:09:45,320 --> 00:09:52,310
holds one very cool feature about Amanda

00:09:50,959 --> 00:09:54,080
that you're not going to find in many

00:09:52,310 --> 00:09:55,940
other formal system is that it has

00:09:54,080 --> 00:09:58,520
first-class support for counter examples

00:09:55,940 --> 00:10:01,870
so when you try to pull up property that

00:09:58,520 --> 00:10:06,860
doesn't hold so we try to put off for F

00:10:01,870 --> 00:10:10,670
that for any value of X f of X is going

00:10:06,860 --> 00:10:13,399
to be different from 158 Amanda can tell

00:10:10,670 --> 00:10:16,339
you not only that this is not true but

00:10:13,399 --> 00:10:19,690
it can also tell you a specific instance

00:10:16,339 --> 00:10:23,089
of X for which this property isn't true

00:10:19,690 --> 00:10:25,520
so if we try to compute F with this

00:10:23,089 --> 00:10:27,950
counter example which is X equal to 20

00:10:25,520 --> 00:10:31,480
to 69 then we're going to be able to see

00:10:27,950 --> 00:10:31,480
that F doesn't actually return true

00:10:32,170 --> 00:10:37,040
another very cool feature of our mantra

00:10:35,029 --> 00:10:39,920
is what we call state space

00:10:37,040 --> 00:10:42,680
decomposition so when we invoke

00:10:39,920 --> 00:10:47,029
decompose on on the function f we get

00:10:42,680 --> 00:10:51,170
this graph of all the possible regions

00:10:47,029 --> 00:10:55,490
of state which in the case of F are

00:10:51,170 --> 00:10:57,890
going to completely match with the if

00:10:55,490 --> 00:10:59,779
statements of F but in the case of

00:10:57,890 --> 00:11:02,060
massively larger programs this is going

00:10:59,779 --> 00:11:03,829
to be quite different so for example if

00:11:02,060 --> 00:11:04,490
you look at the region number two we're

00:11:03,829 --> 00:11:07,130
gonna see that

00:11:04,490 --> 00:11:09,950
Amanda tells us that for every input to

00:11:07,130 --> 00:11:13,070
the function f where X is less than or

00:11:09,950 --> 00:11:15,649
equal to 99 then F is always gonna

00:11:13,070 --> 00:11:17,899
return 100 if we look at a different

00:11:15,649 --> 00:11:22,220
region I'm gonna see that if X is

00:11:17,899 --> 00:11:24,080
between 70 and 20 and it's not 20 to 10

00:11:22,220 --> 00:11:27,110
the result is gonna be 29 that's wrong

00:11:24,080 --> 00:11:29,630
and Amanda can figure out this without

00:11:27,110 --> 00:11:32,000
doing any computation at all so it's not

00:11:29,630 --> 00:11:34,550
actually running your f function it just

00:11:32,000 --> 00:11:39,100
analyzing your code and figuring out

00:11:34,550 --> 00:11:42,380
properties about your code automatically

00:11:39,100 --> 00:11:44,959
so I said but I said before that Amanda

00:11:42,380 --> 00:11:48,320
does model checking for simple cases but

00:11:44,959 --> 00:11:50,779
in in the case of recursive functions

00:11:48,320 --> 00:11:57,250
model checking just doesn't cut it

00:11:50,779 --> 00:12:00,830
and what in mandra does is it has a very

00:11:57,250 --> 00:12:03,100
strong support for a start of proving

00:12:00,830 --> 00:12:06,589
that we Connie that's called induction

00:12:03,100 --> 00:12:09,370
so induction it's kind of you can kind

00:12:06,589 --> 00:12:12,250
of think of it as a d2l of recursion and

00:12:09,370 --> 00:12:16,700
the very cool thing about humans is that

00:12:12,250 --> 00:12:18,649
it can figure out how to induct on a

00:12:16,700 --> 00:12:22,820
function just based off of its

00:12:18,649 --> 00:12:25,459
definition so we're just gonna skip over

00:12:22,820 --> 00:12:27,980
the definition of PSD and some but

00:12:25,459 --> 00:12:30,490
essentially we're asking Amanda to

00:12:27,980 --> 00:12:32,390
verify that those two functions are

00:12:30,490 --> 00:12:35,990
essentially equivalent

00:12:32,390 --> 00:12:39,140
so that's if this PSD function of Y to X

00:12:35,990 --> 00:12:40,790
returns true that implies that B sum of

00:12:39,140 --> 00:12:45,260
all the elements on X just gonna be

00:12:40,790 --> 00:12:47,360
bigger or equal to zero very find this

00:12:45,260 --> 00:12:49,339
by induction we can see that in mandra

00:12:47,360 --> 00:12:52,670
comes up with an induction scheme and

00:12:49,339 --> 00:12:56,360
this Phi symbol is what mathematicians

00:12:52,670 --> 00:12:58,610
use to essentially say the property that

00:12:56,360 --> 00:13:00,470
we're trying to verify and what Amanda

00:12:58,610 --> 00:13:03,290
is telling us that to verify this

00:13:00,470 --> 00:13:07,420
statement we need to prove it for Phi of

00:13:03,290 --> 00:13:10,100
the empty list and for the case where

00:13:07,420 --> 00:13:11,600
the rest of the list implies the

00:13:10,100 --> 00:13:16,760
property for the entirety of the list

00:13:11,600 --> 00:13:18,200
the the power of Amanda comes from being

00:13:16,760 --> 00:13:24,410
able to generate

00:13:18,200 --> 00:13:27,260
those induction schemes and the the

00:13:24,410 --> 00:13:33,200
final very cool property of Amanda is

00:13:27,260 --> 00:13:36,290
that everything that we can write in a

00:13:33,200 --> 00:13:38,600
mantra is guaranteed to be a function

00:13:36,290 --> 00:13:41,240
that terminates so in a manner it's

00:13:38,600 --> 00:13:43,220
literally impossible to write never to

00:13:41,240 --> 00:13:46,040
look that doesn't terminate because

00:13:43,220 --> 00:13:47,690
Amanda's going to tell you I can't prove

00:13:46,040 --> 00:13:49,100
that that this function terminates

00:13:47,690 --> 00:13:51,530
you're either going to help me to prove

00:13:49,100 --> 00:13:54,470
it or you're just not going to be able

00:13:51,530 --> 00:13:57,470
to write this this is incredibly

00:13:54,470 --> 00:14:01,790
powerful for correctness and it's very

00:13:57,470 --> 00:14:03,710
very powerful even from for people that

00:14:01,790 --> 00:14:07,400
are starting to learn computer programs

00:14:03,710 --> 00:14:09,320
just imagine like you guys are a reason

00:14:07,400 --> 00:14:11,270
developers you understand the value of a

00:14:09,320 --> 00:14:13,580
type system imagine a type system who

00:14:11,270 --> 00:14:15,800
can set it figure out that your function

00:14:13,580 --> 00:14:19,060
is not gonna terminate that's an immense

00:14:15,800 --> 00:14:23,240
amount of power that that's given to you

00:14:19,060 --> 00:14:25,340
so yeah this is a quick overview of all

00:14:23,240 --> 00:14:28,370
the features that amanda has now dave is

00:14:25,340 --> 00:14:30,890
going to show you an actual example of

00:14:28,370 --> 00:14:34,190
how to use them via code right hi there

00:14:30,890 --> 00:14:36,620
so yeah ethnically said I'm gonna try

00:14:34,190 --> 00:14:40,940
and show you this code now which is

00:14:36,620 --> 00:14:42,860
reason code and actually the demo she

00:14:40,940 --> 00:14:45,140
showed you before in a camel and this

00:14:42,860 --> 00:14:47,240
model was originally written in a camel

00:14:45,140 --> 00:14:49,220
and I used reformat to just converge

00:14:47,240 --> 00:14:53,540
straight to reason which is been great

00:14:49,220 --> 00:14:56,120
and it's a little model of tic-tac-toe

00:14:53,540 --> 00:15:00,100
or noughts and crosses so we've got a

00:14:56,120 --> 00:15:05,890
game here you get three in a row Marx is

00:15:00,100 --> 00:15:10,010
one sure you've seen that before so

00:15:05,890 --> 00:15:14,510
we've got a kind of pure functional core

00:15:10,010 --> 00:15:16,400
to the model and and then I've got a

00:15:14,510 --> 00:15:18,980
little diagram here so got core core of

00:15:16,400 --> 00:15:20,810
the model that was originally written a

00:15:18,980 --> 00:15:23,630
camel and then I wrapped it in like a

00:15:20,810 --> 00:15:24,980
react layer and that's what I'm

00:15:23,630 --> 00:15:29,210
presenting today we're hoping in the

00:15:24,980 --> 00:15:30,630
future to be able to kind of write in a

00:15:29,210 --> 00:15:34,380
camel as well a kind of

00:15:30,630 --> 00:15:36,930
a reason layer as well because when

00:15:34,380 --> 00:15:39,300
you're when you're gluing components

00:15:36,930 --> 00:15:41,400
together you inevitably kind of have

00:15:39,300 --> 00:15:45,330
some logic in the view layer and so

00:15:41,400 --> 00:15:46,770
being able to kind of show like for

00:15:45,330 --> 00:15:49,080
example here I've got different buttons

00:15:46,770 --> 00:15:52,200
glued together logically I'm sort of

00:15:49,080 --> 00:15:57,050
mapping view states like is the button

00:15:52,200 --> 00:15:59,190
disabled on to this internal logic layer

00:15:57,050 --> 00:16:01,050
there's inevitably going to be some

00:15:59,190 --> 00:16:03,990
logic here so the more we can kind of

00:16:01,050 --> 00:16:06,240
cover the better so that's the idea so

00:16:03,990 --> 00:16:12,630
this is this is as thin as possible for

00:16:06,240 --> 00:16:15,480
now and then inside the logic file we've

00:16:12,630 --> 00:16:18,000
got the actual game logic and this is

00:16:15,480 --> 00:16:23,100
building so I'll just go to this screen

00:16:18,000 --> 00:16:28,110
here so if I break this file my build

00:16:23,100 --> 00:16:30,060
breaks go back up here and now it's

00:16:28,110 --> 00:16:32,070
fixed

00:16:30,060 --> 00:16:33,840
so I'm going to start going through this

00:16:32,070 --> 00:16:35,700
and yeah as I said Nicola wrote this so

00:16:33,840 --> 00:16:38,730
you're kind of joining me on the journey

00:16:35,700 --> 00:16:40,770
journey of discovery of how it works so

00:16:38,730 --> 00:16:46,710
I'm going to fire up and mandra over

00:16:40,770 --> 00:16:48,930
here okay so we'll start loading the

00:16:46,710 --> 00:16:51,960
definitions in reason into a mandra so

00:16:48,930 --> 00:16:54,600
the type of the player there's the

00:16:51,960 --> 00:16:57,480
square state so whether or not it's an X

00:16:54,600 --> 00:16:59,040
zero or not filled in we have the grid

00:16:57,480 --> 00:17:00,180
represented here it's just the different

00:16:59,040 --> 00:17:03,000
letters ater

00:17:00,180 --> 00:17:07,170
I as the different numbers in the grid

00:17:03,000 --> 00:17:09,540
sort of in rows laid that in which moves

00:17:07,170 --> 00:17:11,760
you're going to make mapping to the

00:17:09,540 --> 00:17:14,100
square on the grid the state of the game

00:17:11,760 --> 00:17:16,890
which is the grid state and also who

00:17:14,100 --> 00:17:18,360
went last so when at the start of the

00:17:16,890 --> 00:17:20,550
game and the last player is none and

00:17:18,360 --> 00:17:24,360
from that point onwards it's away some X

00:17:20,550 --> 00:17:26,400
or 0 and the states of the game so

00:17:24,360 --> 00:17:30,240
whether it's in progress someone's made

00:17:26,400 --> 00:17:32,760
a bad move or one or tide and the

00:17:30,240 --> 00:17:35,910
initial game here is just the empty grid

00:17:32,760 --> 00:17:38,610
and I'm going to do something now just

00:17:35,910 --> 00:17:40,640
to kind of so you can see here it's due

00:17:38,610 --> 00:17:43,159
to the representation of the grid and

00:17:40,640 --> 00:17:46,769
you get this

00:17:43,159 --> 00:17:48,210
like a 2h nun it's quite hard to see

00:17:46,769 --> 00:17:54,659
what's going on so I'm just going to

00:17:48,210 --> 00:17:57,239
quickly load these guys in so this is

00:17:54,659 --> 00:18:02,269
just to sort of help the output in am

00:17:57,239 --> 00:18:11,429
andrew down here so we'll load that and

00:18:02,269 --> 00:18:20,220
this guy and gonna do install doc doc of

00:18:11,429 --> 00:18:22,559
grid so now if I print initial game doc

00:18:20,220 --> 00:18:24,509
grid it kind of prints a little bored

00:18:22,559 --> 00:18:27,409
instead of the values so it's a bit

00:18:24,509 --> 00:18:30,269
easier to see what's going on and if I

00:18:27,409 --> 00:18:34,889
put another grid down we get sort of

00:18:30,269 --> 00:18:36,629
visual representation of it and so I'll

00:18:34,889 --> 00:18:39,600
carry on with what I was doing so carry

00:18:36,629 --> 00:18:42,350
on loading the definitions in it's about

00:18:39,600 --> 00:18:45,749
initial player the value of a particular

00:18:42,350 --> 00:18:47,690
like move on the grid so this is just a

00:18:45,749 --> 00:18:51,059
sort of mapping between the variants and

00:18:47,690 --> 00:18:52,679
part in the state and then the first

00:18:51,059 --> 00:18:54,929
actual like bit of logic of the game is

00:18:52,679 --> 00:18:57,629
whether or not someone's winning so I'm

00:18:54,929 --> 00:18:59,960
going to load that in and then this is

00:18:57,629 --> 00:19:02,220
quite so Snickle I mentioned about

00:18:59,960 --> 00:19:03,809
finding counter examples when a property

00:19:02,220 --> 00:19:06,269
can't be proved I'm kind of doing the

00:19:03,809 --> 00:19:09,119
inverse here so I want I want Amanda to

00:19:06,269 --> 00:19:10,470
find me an instance where we see a

00:19:09,119 --> 00:19:15,720
winning game and purely from these

00:19:10,470 --> 00:19:17,369
definitions that I've loaded it can so

00:19:15,720 --> 00:19:25,379
see X gamed

00:19:17,369 --> 00:19:28,109
grid it's generated this value where X

00:19:25,379 --> 00:19:30,389
is winning the game and that's true

00:19:28,109 --> 00:19:31,590
because there's three in a row and this

00:19:30,389 --> 00:19:35,869
is according to our definition of

00:19:31,590 --> 00:19:37,859
winning here which is quite thin but

00:19:35,869 --> 00:19:38,970
this is sort of one of the most basic

00:19:37,859 --> 00:19:40,980
functions so we're going to start

00:19:38,970 --> 00:19:42,269
building on top of this building around

00:19:40,980 --> 00:19:43,499
this and like adding more of the logic

00:19:42,269 --> 00:19:45,419
to the game so we should start seeing

00:19:43,499 --> 00:19:48,480
more boards that look a bit more

00:19:45,419 --> 00:19:52,109
realistic so another function are the

00:19:48,480 --> 00:19:54,930
player and this this function will count

00:19:52,109 --> 00:19:56,580
how many moves are made by each player

00:19:54,930 --> 00:19:58,590
which you could see might be quite key

00:19:56,580 --> 00:20:04,290
to getting more useful examples than we

00:19:58,590 --> 00:20:07,010
just saw and then building up whether or

00:20:04,290 --> 00:20:10,200
not a grid is valid in this version of

00:20:07,010 --> 00:20:13,710
tic-tac-toe either player can go first

00:20:10,200 --> 00:20:16,920
so we check that if X went last then X

00:20:13,710 --> 00:20:23,010
has one more move than naught otherwise

00:20:16,920 --> 00:20:27,990
naught has one more move than X so we'll

00:20:23,010 --> 00:20:29,520
load that in and again let's look take a

00:20:27,990 --> 00:20:31,200
look at what we've written so I find

00:20:29,520 --> 00:20:32,720
this instance to be really useful for

00:20:31,200 --> 00:20:36,540
actually getting a feel for what your

00:20:32,720 --> 00:20:39,510
functions are doing so let's get an

00:20:36,540 --> 00:20:44,550
instance of a valid grid so we do see X

00:20:39,510 --> 00:20:46,800
dot game grid and as Nicola mentioned

00:20:44,550 --> 00:20:49,290
these values of first class back back

00:20:46,800 --> 00:20:52,190
into the into sort of session so I can

00:20:49,290 --> 00:21:00,930
use there is valid grid function on it

00:20:52,190 --> 00:21:03,810
CX dot game and CX dot P just the actual

00:21:00,930 --> 00:21:12,630
game no I need the last layer as well CX

00:21:03,810 --> 00:21:13,530
dot P and it anyway you can see that

00:21:12,630 --> 00:21:17,040
it's giving me an error I've done

00:21:13,530 --> 00:21:18,360
something wrong and so it's it and it's

00:21:17,040 --> 00:21:21,030
worked out the types of the two things

00:21:18,360 --> 00:21:26,310
so you can use these values in real time

00:21:21,030 --> 00:21:27,720
as I'm doing with printing them so yeah

00:21:26,310 --> 00:21:29,760
let's get a couple more instances so

00:21:27,720 --> 00:21:32,010
let's try and get it to prove something

00:21:29,760 --> 00:21:33,780
that can't like shouldn't be valid

00:21:32,010 --> 00:21:36,270
according to our logic so in this case

00:21:33,780 --> 00:21:40,530
we're saying get the move counts of a

00:21:36,270 --> 00:21:43,620
game that you've generated from the

00:21:40,530 --> 00:21:45,930
definitions that we've put in and I want

00:21:43,620 --> 00:21:47,820
a game that's where the grid is valid

00:21:45,930 --> 00:21:51,930
with according to the grid and the

00:21:47,820 --> 00:21:54,390
player but we're too ahead and in this

00:21:51,930 --> 00:21:55,950
case it says it can't do it because

00:21:54,390 --> 00:22:02,430
we've kind of given it like

00:21:55,950 --> 00:22:03,960
contradiction so we'll instead encode

00:22:02,430 --> 00:22:05,610
that as a verification statement which

00:22:03,960 --> 00:22:07,650
is what Nicola mentioned and we can kind

00:22:05,610 --> 00:22:10,260
of see these as like tests

00:22:07,650 --> 00:22:12,480
so here we're saying make sure that for

00:22:10,260 --> 00:22:13,530
these properties like it's not doing

00:22:12,480 --> 00:22:14,970
something stupid and you don't have to

00:22:13,530 --> 00:22:16,770
kind of come up with a test case that's

00:22:14,970 --> 00:22:22,200
potentially arbitrary potentially wrong

00:22:16,770 --> 00:22:26,340
it's just saying for all inputs it will

00:22:22,200 --> 00:22:27,630
it'll prove it for you so carry on

00:22:26,340 --> 00:22:29,520
building a few more layers around this

00:22:27,630 --> 00:22:30,690
so we've got before we had whether or

00:22:29,520 --> 00:22:33,030
not the grid was valid now we have

00:22:30,690 --> 00:22:34,080
whether or not the game is valid so

00:22:33,030 --> 00:22:38,250
we're checking some properties about

00:22:34,080 --> 00:22:40,890
winning and get an instance of a valid

00:22:38,250 --> 00:22:42,179
game and this one's quite interesting

00:22:40,890 --> 00:22:44,640
I'll just get the other two because

00:22:42,179 --> 00:22:46,890
there you probably get the idea but so

00:22:44,640 --> 00:22:53,010
we want to valid game where X is winning

00:22:46,890 --> 00:22:57,450
the game and now we see that looks more

00:22:53,010 --> 00:23:02,370
like a real game now which is cool we'll

00:22:57,450 --> 00:23:07,230
add the other rule tied game did I hit

00:23:02,370 --> 00:23:09,390
the right button there Arne yeah and a

00:23:07,230 --> 00:23:11,100
valid of instance of a tied game tied

00:23:09,390 --> 00:23:12,420
games the grid is always full so let's

00:23:11,100 --> 00:23:16,440
just see what that looks like

00:23:12,420 --> 00:23:24,510
see X don't game grid the grid is full

00:23:16,440 --> 00:23:28,880
and no one seems to be winning we'll add

00:23:24,510 --> 00:23:31,710
another function is valid move play move

00:23:28,880 --> 00:23:36,090
so we can play a move on the initial

00:23:31,710 --> 00:23:38,309
game here this is not using this is just

00:23:36,090 --> 00:23:40,440
computing with the value that it's that

00:23:38,309 --> 00:23:42,000
we've already entered

00:23:40,440 --> 00:23:44,550
so we're saying when play move on the

00:23:42,000 --> 00:23:46,500
initial game at position a we get this

00:23:44,550 --> 00:23:53,610
grid so again it's just normal

00:23:46,500 --> 00:23:56,429
computation here and then the status of

00:23:53,610 --> 00:23:59,190
the game based on those winning and tie

00:23:56,429 --> 00:24:00,420
functions and this will actually play

00:23:59,190 --> 00:24:04,200
this is the function we actually call

00:24:00,420 --> 00:24:12,080
from reason to play the game so we'll do

00:24:04,200 --> 00:24:12,080
that as well and then this

00:24:12,809 --> 00:24:18,629
is a kind of a sort of a property that

00:24:15,809 --> 00:24:20,340
seems fairly reasonable like if we've

00:24:18,629 --> 00:24:22,889
got a valid game and we've got a valid

00:24:20,340 --> 00:24:25,620
move then when we play a move on the

00:24:22,889 --> 00:24:27,649
game with the move the game should be

00:24:25,620 --> 00:24:29,850
valid if that makes sense

00:24:27,649 --> 00:24:34,590
so let's put that in and see what

00:24:29,850 --> 00:24:37,679
happens and it's actually found that

00:24:34,590 --> 00:24:38,820
that's not the case which indicates that

00:24:37,679 --> 00:24:41,879
we probably have a bug in the whole

00:24:38,820 --> 00:24:43,169
thing and so let's have a look so to

00:24:41,879 --> 00:24:47,129
figure out what's going on here we'd

00:24:43,169 --> 00:24:50,220
probably well run these functions so

00:24:47,129 --> 00:24:56,159
we'd run is valid game on our counter

00:24:50,220 --> 00:24:57,990
example that's true and so on and so on

00:24:56,159 --> 00:24:59,879
and we could execute all the functions

00:24:57,990 --> 00:25:02,999
with the valid value it's found I happen

00:24:59,879 --> 00:25:05,070
to know what the bug is in advance to

00:25:02,999 --> 00:25:08,129
save a bit of time so I'm going to show

00:25:05,070 --> 00:25:09,990
you here I didn't when I demoed it to

00:25:08,129 --> 00:25:14,220
you I didn't show you the bug so I can

00:25:09,990 --> 00:25:15,869
actually play this and then it doesn't

00:25:14,220 --> 00:25:17,759
check if the previous lift the square

00:25:15,869 --> 00:25:23,970
that you're moving on is empty so I can

00:25:17,759 --> 00:25:25,799
actually override that and and if I go

00:25:23,970 --> 00:25:34,519
back over here this is the condition I

00:25:25,799 --> 00:25:37,519
need I'm gonna sneak that in into here

00:25:34,519 --> 00:25:37,519
comment

00:25:39,399 --> 00:25:49,589
I'm just gonna reload this back into a

00:25:41,739 --> 00:25:52,330
mandra with the new definition oh thanks

00:25:49,589 --> 00:25:53,589
so it doesn't let you override

00:25:52,330 --> 00:25:55,450
definitions they're already there by

00:25:53,589 --> 00:25:57,599
default but I'm just going to change the

00:25:55,450 --> 00:26:01,269
setting that allows you to do that and

00:25:57,599 --> 00:26:03,279
just to stop making mistakes so fact

00:26:01,269 --> 00:26:05,499
that is like up to the user whether or

00:26:03,279 --> 00:26:08,649
not they want to be able to do that so

00:26:05,499 --> 00:26:17,109
now I've turned that on evaluate that

00:26:08,649 --> 00:26:23,320
and this function G and let's try that

00:26:17,109 --> 00:26:25,299
final statement again and now we see

00:26:23,320 --> 00:26:28,179
after analyzing all that stuff it's

00:26:25,299 --> 00:26:32,109
proved and it that final properties is

00:26:28,179 --> 00:26:33,820
true so yeah that's the the kind of

00:26:32,109 --> 00:26:35,200
overall demo I've got a couple of other

00:26:33,820 --> 00:26:37,809
things I want to mention at the end so

00:26:35,200 --> 00:26:40,869
around reason stuff where we're working

00:26:37,809 --> 00:26:43,119
on a like a Visual Studio code extension

00:26:40,869 --> 00:26:44,229
if anyone uses that for reason I know it

00:26:43,119 --> 00:26:47,710
seems to be quite popular in the

00:26:44,229 --> 00:26:50,109
community and by default if you load a

00:26:47,710 --> 00:26:52,599
reason file in our keywords like verify

00:26:50,109 --> 00:26:55,839
and stuff like cause a syntax error say

00:26:52,599 --> 00:26:57,999
we've got this mode where you and you

00:26:55,839 --> 00:26:59,769
can add these keywords and the idea is

00:26:57,999 --> 00:27:02,049
here we'd be able to kind of have

00:26:59,769 --> 00:27:04,450
instances being popping up on in line

00:27:02,049 --> 00:27:05,919
like interactively and verification

00:27:04,450 --> 00:27:07,149
statements with a big green tick as you

00:27:05,919 --> 00:27:09,249
as you go through your code and you're

00:27:07,149 --> 00:27:11,799
working on it bit more interactively

00:27:09,249 --> 00:27:15,249
than the kind of repple based approach

00:27:11,799 --> 00:27:16,239
that I just showed you and then yeah if

00:27:15,249 --> 00:27:17,320
you want to go and have a play around

00:27:16,239 --> 00:27:21,039
with it yourself as Dennis mentioned

00:27:17,320 --> 00:27:22,599
we've got tryam Ondra and so the docs

00:27:21,039 --> 00:27:24,580
that nicola was walking through his doc

00:27:22,599 --> 00:27:27,070
Stata mandra and if you like hit try

00:27:24,580 --> 00:27:30,309
they'll launch into a notebook that you

00:27:27,070 --> 00:27:32,649
can edit these statements yourself and

00:27:30,309 --> 00:27:35,830
like change the values and play around

00:27:32,649 --> 00:27:38,830
with and I not actually on the Wi-Fi but

00:27:35,830 --> 00:27:40,330
yeah on try um Andrew again if you this

00:27:38,830 --> 00:27:42,460
is all in the camel but if you create a

00:27:40,330 --> 00:27:44,169
new notebook from the sort of menu at

00:27:42,460 --> 00:27:46,659
the top you can choose to use reason

00:27:44,169 --> 00:27:49,050
syntax as well so yeah I think that's

00:27:46,659 --> 00:27:54,150
pretty much it

00:27:49,050 --> 00:27:54,150

YouTube URL: https://www.youtube.com/watch?v=K6KQNce9reo


