Title: GoGaRuCo 2014 Gilding the Rose: Refactoring Legacy Code
Publication date: 2020-01-23
Playlist: GoGaRuCo 2014
Description: 
	By, Randy Coulman
We all run into legacy code. Sometimes, we even write it ourselves. Working with legacy code can be a daunting challenge, but there are ways to tackle it. The Gilded Rose code kata is a coding exercise for practicing refactoring and testing skills in a legacy codebase.

In this presentation, I use the Gilded Rose kata to demonstrate techniques for safely working with a legacy codebase and using pure baby-step refactorings to improve the design.

Help us caption & translate this video!

http://amara.org/v/FV8n/
Captions: 
	00:00:13,250 --> 00:00:17,430
okay so today I want to talk about

00:00:15,330 --> 00:00:19,500
refactoring legacy code and this whole

00:00:17,430 --> 00:00:21,029
talk is based on a code kata which is

00:00:19,500 --> 00:00:23,279
like a code exercise that you do to

00:00:21,029 --> 00:00:25,410
practice your skills called the gilded

00:00:23,279 --> 00:00:27,269
rose caught on Sandi Metz has been doing

00:00:25,410 --> 00:00:29,119
a talk this year based on this kata she

00:00:27,269 --> 00:00:31,349
goes a different direction than I do

00:00:29,119 --> 00:00:34,079
there's a whole bunch of Coty's on a

00:00:31,349 --> 00:00:36,239
site CMU something Todd sadhana who's

00:00:34,079 --> 00:00:39,090
down here maintains that site there's a

00:00:36,239 --> 00:00:40,680
lot of really cool exercises anyway this

00:00:39,090 --> 00:00:42,570
is a Kolkata and you should actually try

00:00:40,680 --> 00:00:44,100
it out sometime but I actually ask that

00:00:42,570 --> 00:00:47,370
you wait until after my talk to it's

00:00:44,100 --> 00:00:49,320
followed them alright so we are starting

00:00:47,370 --> 00:00:50,940
a new job today we're working at the

00:00:49,320 --> 00:00:52,800
gilded Rose Inn which in addition to

00:00:50,940 --> 00:00:54,809
being an N cells a bunch of interesting

00:00:52,800 --> 00:00:56,940
items and they have an inventory

00:00:54,809 --> 00:00:58,739
management system and the previous

00:00:56,940 --> 00:01:01,230
developer left and they need us to come

00:00:58,739 --> 00:01:04,820
in and take over the system the system

00:01:01,230 --> 00:01:07,229
runs us a nightly process and updates

00:01:04,820 --> 00:01:09,570
how many days we have left to sell the

00:01:07,229 --> 00:01:11,640
item and how the quality or what the

00:01:09,570 --> 00:01:13,920
quality of the item is so as items age

00:01:11,640 --> 00:01:15,630
they degrade in quality and different

00:01:13,920 --> 00:01:17,970
kinds of items have different rules it's

00:01:15,630 --> 00:01:20,460
pretty straightforward there is a spec

00:01:17,970 --> 00:01:22,320
we have no idea if we can trust it like

00:01:20,460 --> 00:01:24,900
most legacy code specs are out of date

00:01:22,320 --> 00:01:26,070
they lie they're wrong we don't need to

00:01:24,900 --> 00:01:28,170
spend a lot of time on this we'll come

00:01:26,070 --> 00:01:30,150
back to it later but we don't know if we

00:01:28,170 --> 00:01:32,490
can trust this spec there is a

00:01:30,150 --> 00:01:35,009
constraint this team does not practice

00:01:32,490 --> 00:01:36,720
collective code ownership and there's a

00:01:35,009 --> 00:01:38,430
very grumpy guy in the corner that

00:01:36,720 --> 00:01:40,290
maintains the item class and does not

00:01:38,430 --> 00:01:42,090
let anybody else touch it now this is

00:01:40,290 --> 00:01:43,710
our first day at work so we're not going

00:01:42,090 --> 00:01:45,270
to kind of come in and rock the boat and

00:01:43,710 --> 00:01:48,149
try to solve this team issue we're gonna

00:01:45,270 --> 00:01:50,210
hold off a little bit and so we're gonna

00:01:48,149 --> 00:01:52,770
respect this constraint for today our

00:01:50,210 --> 00:01:54,360
task is to add support for a new kind of

00:01:52,770 --> 00:01:56,159
item called a conjured item and a

00:01:54,360 --> 00:01:57,899
concert item is just like a normal item

00:01:56,159 --> 00:01:59,759
except it degrades in quality twice as

00:01:57,899 --> 00:02:01,729
fast that seems pretty straightforward

00:01:59,759 --> 00:02:04,469
let's take a look at the code

00:02:01,729 --> 00:02:05,909
there's the forbidden item cloths that

00:02:04,469 --> 00:02:07,140
we're not allowed to touch and we're

00:02:05,909 --> 00:02:09,300
only going to look at it to notice

00:02:07,140 --> 00:02:10,709
there's nothing weird here there's no

00:02:09,300 --> 00:02:13,020
weird side effects it's just straight

00:02:10,709 --> 00:02:13,890
access there's getters and setters no

00:02:13,020 --> 00:02:15,390
magic

00:02:13,890 --> 00:02:16,260
no weird side effects and that's

00:02:15,390 --> 00:02:17,940
important when you're dealing with

00:02:16,260 --> 00:02:19,770
legacy code because you need some firm

00:02:17,940 --> 00:02:21,050
ground to stand on while you reason

00:02:19,770 --> 00:02:23,670
about the code you're trying to clean up

00:02:21,050 --> 00:02:25,459
so that's all I'll say about the item

00:02:23,670 --> 00:02:28,500
class but that's a very important point

00:02:25,459 --> 00:02:30,540
this is our database that's fairly

00:02:28,500 --> 00:02:32,100
interesting database notice at the

00:02:30,540 --> 00:02:35,100
bottom there there is a concert item in

00:02:32,100 --> 00:02:36,480
the database already it probably is not

00:02:35,100 --> 00:02:38,880
being handled correctly we don't know

00:02:36,480 --> 00:02:41,580
that yet and then there's this update

00:02:38,880 --> 00:02:43,020
quality method and I mean we have a task

00:02:41,580 --> 00:02:44,430
today we have to support these new items

00:02:43,020 --> 00:02:47,280
now it looks like maybe where we want to

00:02:44,430 --> 00:02:48,690
look so let's look at that code okay

00:02:47,280 --> 00:02:50,160
it's been a while since lunch been a

00:02:48,690 --> 00:02:51,350
while since snack so hopefully it's okay

00:02:50,160 --> 00:02:56,760
to look at this right now

00:02:51,350 --> 00:02:59,220
that's nasty but wait there's more okay

00:02:56,760 --> 00:03:00,300
let's look at the tests test should be

00:02:59,220 --> 00:03:04,980
better right

00:03:00,300 --> 00:03:07,830
there are no tests none not one public

00:03:04,980 --> 00:03:10,500
service announcement please write tests

00:03:07,830 --> 00:03:12,000
for your code all right so what are we

00:03:10,500 --> 00:03:13,700
gonna do about this there are lots of

00:03:12,000 --> 00:03:15,959
techniques for dealing with legacy code

00:03:13,700 --> 00:03:17,130
in fact we could probably write a book

00:03:15,959 --> 00:03:18,600
with all the techniques in it

00:03:17,130 --> 00:03:20,640
unfortunately we don't have to because

00:03:18,600 --> 00:03:22,620
Michael feathers already did if you work

00:03:20,640 --> 00:03:25,040
with legacy code at all you need this

00:03:22,620 --> 00:03:28,730
book it is awesome

00:03:25,040 --> 00:03:31,380
second thing we need some safety we need

00:03:28,730 --> 00:03:32,820
tests and so I'm not going to talk about

00:03:31,380 --> 00:03:34,350
writing tests for legacy code that's a

00:03:32,820 --> 00:03:36,930
different talk but when I was working

00:03:34,350 --> 00:03:38,489
through this for this talk I wrote what

00:03:36,930 --> 00:03:40,019
Michael feathers calls characterisation

00:03:38,489 --> 00:03:41,700
tests because what I want to do is

00:03:40,019 --> 00:03:43,709
preserve the existing behavior of the

00:03:41,700 --> 00:03:45,390
code whether it's right or wrong I want

00:03:43,709 --> 00:03:47,489
I want to make sure that I don't change

00:03:45,390 --> 00:03:50,130
that behavior while I'm doing my work

00:03:47,489 --> 00:03:52,079
and so I wrote characterization tests I

00:03:50,130 --> 00:03:54,150
use simple code to make sure I got 100%

00:03:52,079 --> 00:03:55,650
coverage and everything I show you in

00:03:54,150 --> 00:03:57,690
this talk with one exception that I'll

00:03:55,650 --> 00:04:00,239
point out kept the test green the whole

00:03:57,690 --> 00:04:02,010
time okay and that's important I will

00:04:00,239 --> 00:04:03,480
made sure I didn't change the visible

00:04:02,010 --> 00:04:05,700
behavior of this code when I was

00:04:03,480 --> 00:04:08,220
refactoring so we're not going to trust

00:04:05,700 --> 00:04:09,989
the spec like I said and we are gonna

00:04:08,220 --> 00:04:12,570
fight the urge to rewrite when we don't

00:04:09,989 --> 00:04:14,280
know if we can trust the spec we don't

00:04:12,570 --> 00:04:16,829
know if we can safely rewrite I mean

00:04:14,280 --> 00:04:19,140
everybody I've seen do this kata takes

00:04:16,829 --> 00:04:20,850
the spec and looks at the code and says

00:04:19,140 --> 00:04:24,000
I'm throwing that on I'm gonna rewrite

00:04:20,850 --> 00:04:25,470
it we're not going to do that rewriting

00:04:24,000 --> 00:04:27,780
is often very expensive and very

00:04:25,470 --> 00:04:30,060
error-prone and you can't always do it

00:04:27,780 --> 00:04:31,920
we need to have some techniques in our

00:04:30,060 --> 00:04:34,680
tool bag for when we can't rewrite what

00:04:31,920 --> 00:04:36,120
do we do instead we're gonna follow the

00:04:34,680 --> 00:04:38,010
Boy Scout rule we're not just gonna hack

00:04:36,120 --> 00:04:40,200
in our change and perpetuate the evil

00:04:38,010 --> 00:04:41,669
that's in that code we're gonna leave

00:04:40,200 --> 00:04:42,960
the campground cleaner than we find it

00:04:41,669 --> 00:04:45,090
so we're gonna try to improve the code

00:04:42,960 --> 00:04:47,730
in the area where we're working so we're

00:04:45,090 --> 00:04:50,010
gonna take a lot of baby steps very tiny

00:04:47,730 --> 00:04:51,750
refactorings that add up to big changes

00:04:50,010 --> 00:04:53,880
but we're not going to boil the ocean

00:04:51,750 --> 00:04:55,470
we're gonna stay focused on our task so

00:04:53,880 --> 00:04:57,180
we're only going to be really messing

00:04:55,470 --> 00:04:59,490
with the code that we have to touch to

00:04:57,180 --> 00:05:00,600
implement this new feature it would be

00:04:59,490 --> 00:05:03,540
tempting to go rewrite the whole thing

00:05:00,600 --> 00:05:04,950
but that's not what we're doing here all

00:05:03,540 --> 00:05:06,780
right and Kent Beck has this great

00:05:04,950 --> 00:05:09,630
advice for each decided change make the

00:05:06,780 --> 00:05:11,310
change easy which may be hard and then

00:05:09,630 --> 00:05:14,160
make the easy change and we're gonna do

00:05:11,310 --> 00:05:16,080
that all right so we have to stay

00:05:14,160 --> 00:05:17,669
focused on our tasks are we there yet

00:05:16,080 --> 00:05:21,030
can we see an easy way to implement

00:05:17,669 --> 00:05:23,790
support for conjured items not one that

00:05:21,030 --> 00:05:25,860
leaves the campground clean so let's see

00:05:23,790 --> 00:05:27,720
what we can do about this code we're

00:05:25,860 --> 00:05:29,940
gonna start this is the time when we

00:05:27,720 --> 00:05:31,260
know the least about this code and so we

00:05:29,940 --> 00:05:32,940
just want to start getting our hands on

00:05:31,260 --> 00:05:34,950
a little bit and we're just going to do

00:05:32,940 --> 00:05:37,560
some really simple mechanical changes to

00:05:34,950 --> 00:05:38,820
try to improve things I used to Ruby

00:05:37,560 --> 00:05:40,320
mine for this talk and it's got some

00:05:38,820 --> 00:05:41,910
great refactoring tools and I used those

00:05:40,320 --> 00:05:43,320
a lot in here so a lot easier factories

00:05:41,910 --> 00:05:45,600
I'm talking about can be automated in

00:05:43,320 --> 00:05:47,760
something like Ruby mine so the first

00:05:45,600 --> 00:05:48,900
thing we're gonna do I like I found this

00:05:47,760 --> 00:05:50,100
quote when I was preparing the talk and

00:05:48,900 --> 00:05:51,419
I had to put it in there when you

00:05:50,100 --> 00:05:52,890
started a new programming job you have

00:05:51,419 --> 00:05:54,330
to walk right up to the biggest function

00:05:52,890 --> 00:05:58,830
in the yard and refactor it in front of

00:05:54,330 --> 00:06:00,780
everyone so here we go so the first

00:05:58,830 --> 00:06:02,460
thing we're gonna do is we're gonna get

00:06:00,780 --> 00:06:04,110
rid of some noise so we can start to see

00:06:02,460 --> 00:06:04,669
the structure of this of this code a

00:06:04,110 --> 00:06:08,130
little bit

00:06:04,669 --> 00:06:11,070
the first noise I see is this at items I

00:06:08,130 --> 00:06:12,810
everywhere there's actually 34 instances

00:06:11,070 --> 00:06:14,729
of hiddenness in this code the two pages

00:06:12,810 --> 00:06:16,860
so let's extract that to a temporary

00:06:14,729 --> 00:06:18,479
variable Martin Fowler calls that

00:06:16,860 --> 00:06:21,000
extract temporary extract variable I

00:06:18,479 --> 00:06:22,800
forget the exact name so we pull that

00:06:21,000 --> 00:06:24,900
out we have this variable at the top and

00:06:22,800 --> 00:06:27,840
that's a little bit less noise let's

00:06:24,900 --> 00:06:29,820
zoom in on that a little bit so we've

00:06:27,840 --> 00:06:31,680
got this loop an assignment and then

00:06:29,820 --> 00:06:33,660
we've got 40-plus lines of code that all

00:06:31,680 --> 00:06:35,310
refer to item that method is doing two

00:06:33,660 --> 00:06:37,530
things it's looping and it's messing

00:06:35,310 --> 00:06:39,710
with items let's extract those 40-plus

00:06:37,530 --> 00:06:41,520
lines of code into their own method

00:06:39,710 --> 00:06:43,379
that's better

00:06:41,520 --> 00:06:45,360
and that loop is kind of weird for Ruby

00:06:43,379 --> 00:06:46,650
and it is using a ruby range which is

00:06:45,360 --> 00:06:48,270
kind of neat this code was actually

00:06:46,650 --> 00:06:49,770
ported from c-sharp so that's why you

00:06:48,270 --> 00:06:51,750
see some of this stuff but there's a

00:06:49,770 --> 00:06:54,180
much more idiomatic Ruby way to say that

00:06:51,750 --> 00:06:56,669
and I was him in a little bit an

00:06:54,180 --> 00:06:57,629
idiomatic code is more readable and so

00:06:56,669 --> 00:06:59,340
we're gonna try to make the code a

00:06:57,629 --> 00:07:00,419
little more idiomatic so that you can

00:06:59,340 --> 00:07:01,889
see at a glance what it's doing you

00:07:00,419 --> 00:07:03,060
don't have to study it it's like okay

00:07:01,889 --> 00:07:05,580
that's just looking through all the

00:07:03,060 --> 00:07:07,770
items so we can use in each here and

00:07:05,580 --> 00:07:09,690
that's a little better now this method

00:07:07,770 --> 00:07:12,090
is pretty clean and it's kind of an

00:07:09,690 --> 00:07:14,490
island of sanity in this sea of chaos we

00:07:12,090 --> 00:07:17,130
have a place to stand while we work okay

00:07:14,490 --> 00:07:18,479
back to the update method there's still

00:07:17,130 --> 00:07:20,159
some noise in here notice all the

00:07:18,479 --> 00:07:21,449
conditionals are wrapped in parenthesis

00:07:20,159 --> 00:07:23,880
I assume that's a holdover from the

00:07:21,449 --> 00:07:25,710
c-sharp Ruby doesn't need those get rid

00:07:23,880 --> 00:07:27,539
of them there's a semicolon near the

00:07:25,710 --> 00:07:32,009
bottom Ruby doesn't need it get rid of

00:07:27,539 --> 00:07:33,419
it getting rid of noise alright there's

00:07:32,009 --> 00:07:35,159
actually two more parenthesis I could

00:07:33,419 --> 00:07:41,940
get rid of rid of yes I know Ryan but

00:07:35,159 --> 00:07:43,349
I'm not get rid of them anyway yes so we

00:07:41,940 --> 00:07:44,699
have this item quality equals item

00:07:43,349 --> 00:07:46,530
quality minus 1 or plus 1

00:07:44,699 --> 00:07:48,240
Ruby has the minus equals and plus

00:07:46,530 --> 00:07:49,949
equals operator and again that gets rid

00:07:48,240 --> 00:07:52,590
of a little bit of noise a little more

00:07:49,949 --> 00:07:53,520
idiomatic a little bit cleaner all right

00:07:52,590 --> 00:07:56,940
are we there yet

00:07:53,520 --> 00:08:01,020
can we do conjured items yet no I don't

00:07:56,940 --> 00:08:02,969
think so so the next thing is there's a

00:08:01,020 --> 00:08:05,069
code smell on this code known as feature

00:08:02,969 --> 00:08:07,169
envy so let's get rid of the feature

00:08:05,069 --> 00:08:09,719
Envy so what feature Envy is when you've

00:08:07,169 --> 00:08:11,550
got a method that is way too interested

00:08:09,719 --> 00:08:13,710
in the internals of another object you

00:08:11,550 --> 00:08:15,419
see all those item dots in there that's

00:08:13,710 --> 00:08:16,560
a clear sign of the feature Envy smell

00:08:15,419 --> 00:08:18,659
there's all this stuff we're doing two

00:08:16,560 --> 00:08:22,319
items rather than asking items to do

00:08:18,659 --> 00:08:24,120
that for us so we'd like to extract the

00:08:22,319 --> 00:08:25,680
body of this update method over to the

00:08:24,120 --> 00:08:27,630
item class except that we have this

00:08:25,680 --> 00:08:29,130
constraint we're not allowed to touch

00:08:27,630 --> 00:08:31,110
item so we have to come up with a

00:08:29,130 --> 00:08:32,909
different strategy here we've only been

00:08:31,110 --> 00:08:34,289
working here for a few minutes and so

00:08:32,909 --> 00:08:36,180
we're not really ready to address the

00:08:34,289 --> 00:08:39,810
grumpy guy in the corner so we need to

00:08:36,180 --> 00:08:42,180
do something else so what we're gonna do

00:08:39,810 --> 00:08:44,730
is we're gonna wrap the items in another

00:08:42,180 --> 00:08:46,470
class and then we can move some behavior

00:08:44,730 --> 00:08:47,640
on for the wrapper and to do that we can

00:08:46,470 --> 00:08:50,040
use something from the Ruby standard

00:08:47,640 --> 00:08:51,480
library called simpledelegator so i've

00:08:50,040 --> 00:08:53,220
implemented a class called item wrapper

00:08:51,480 --> 00:08:54,640
that inherits some simpledelegator with

00:08:53,220 --> 00:08:56,770
simpledelegator does

00:08:54,640 --> 00:08:59,110
is it you constructed around an object

00:08:56,770 --> 00:09:00,850
and any message you send to the

00:08:59,110 --> 00:09:03,430
delegator that it doesn't understand if

00:09:00,850 --> 00:09:05,020
forwards onto the original object so

00:09:03,430 --> 00:09:06,460
this rule or refactoring right here

00:09:05,020 --> 00:09:07,960
where I introduced this class did not

00:09:06,460 --> 00:09:10,060
change any behavior because all the

00:09:07,960 --> 00:09:12,040
messages were sending to item gets sent

00:09:10,060 --> 00:09:14,050
to the wrapper which forwards it on to

00:09:12,040 --> 00:09:15,640
the atom that were wrapping but now this

00:09:14,050 --> 00:09:17,440
gives us a place to move some behavior

00:09:15,640 --> 00:09:19,270
to so now we can take the whole body of

00:09:17,440 --> 00:09:21,250
the update method and move it to a

00:09:19,270 --> 00:09:22,360
method on item wrapper there are some

00:09:21,250 --> 00:09:23,800
tools that can actually do this

00:09:22,360 --> 00:09:25,180
refactoring automatically visual work

00:09:23,800 --> 00:09:26,830
Smalltalk has a refactoring called

00:09:25,180 --> 00:09:29,020
extract method - component that does

00:09:26,830 --> 00:09:31,300
this for you Ruby mine does not so we're

00:09:29,020 --> 00:09:32,380
gonna do it in a few steps by hand so

00:09:31,300 --> 00:09:34,750
first of all we're going to copy and

00:09:32,380 --> 00:09:37,960
paste that whole body of the update

00:09:34,750 --> 00:09:39,970
method move it to a method on item

00:09:37,960 --> 00:09:41,920
wrapper and because I don't want to

00:09:39,970 --> 00:09:44,110
change those 43 lines yet I introduce a

00:09:41,920 --> 00:09:45,670
temporary variable called item which is

00:09:44,110 --> 00:09:48,220
the same name that the parameter had and

00:09:45,670 --> 00:09:49,870
just assign self to it so that I'm

00:09:48,220 --> 00:09:51,490
actually talking to the object that I'm

00:09:49,870 --> 00:09:52,930
doing it through a temporary variable

00:09:51,490 --> 00:09:54,910
just so I don't have to change those

00:09:52,930 --> 00:09:56,950
forty three lines of code yet now that

00:09:54,910 --> 00:09:58,240
update method at the bottom really isn't

00:09:56,950 --> 00:09:59,830
carrying its own weight so we can go

00:09:58,240 --> 00:10:01,990
ahead and inline that it's called inline

00:09:59,830 --> 00:10:05,350
method refactoring and you can see there

00:10:01,990 --> 00:10:07,510
item wrapper got new on item update all

00:10:05,350 --> 00:10:09,880
right and now we can go look at that the

00:10:07,510 --> 00:10:13,270
item wrapper is update method and we can

00:10:09,880 --> 00:10:16,180
inline that temporary variable now which

00:10:13,270 --> 00:10:17,980
is actually worse but now almost all of

00:10:16,180 --> 00:10:20,530
those self dots are completely

00:10:17,980 --> 00:10:22,210
unnecessary because when you're calling

00:10:20,530 --> 00:10:23,530
a getter on self you don't need self dot

00:10:22,210 --> 00:10:26,920
when you're calling a setter you need it

00:10:23,530 --> 00:10:28,090
so we have to keep some of them that's

00:10:26,920 --> 00:10:31,330
starting to look a little bit more

00:10:28,090 --> 00:10:34,390
readable are we there yet can we do

00:10:31,330 --> 00:10:35,920
conjured items yet no still not I'm not

00:10:34,390 --> 00:10:37,840
seeing it anyway the code is better

00:10:35,920 --> 00:10:40,300
we've left it better but it's not a

00:10:37,840 --> 00:10:42,730
great way to not not a great thing now I

00:10:40,300 --> 00:10:45,220
see some duplication so let's get rid of

00:10:42,730 --> 00:10:47,560
the duplication first of all duplication

00:10:45,220 --> 00:10:49,840
is a place for bugs to live because you

00:10:47,560 --> 00:10:51,100
fix you know n - one of the places where

00:10:49,840 --> 00:10:53,770
the code is duplicated but you missed

00:10:51,100 --> 00:10:55,000
the other one and you get in trouble and

00:10:53,770 --> 00:10:56,440
the other thing that removing

00:10:55,000 --> 00:10:58,450
duplication does is it allows you to

00:10:56,440 --> 00:10:59,200
give things names that can help the code

00:10:58,450 --> 00:11:01,180
communicate better

00:10:59,200 --> 00:11:03,040
so the first duplication I see is this

00:11:01,180 --> 00:11:06,310
little phrase if quality is less than 50

00:11:03,040 --> 00:11:07,570
self dot quality plus equals one let's

00:11:06,310 --> 00:11:08,640
extract that to a method called

00:11:07,570 --> 00:11:11,200
increased quality

00:11:08,640 --> 00:11:12,760
like so now there's one more case that

00:11:11,200 --> 00:11:14,590
looks like we could extract it but not

00:11:12,760 --> 00:11:16,270
quite because there's a nested-if inside

00:11:14,590 --> 00:11:19,090
of it so let's dive in and look at that

00:11:16,270 --> 00:11:21,910
a little bit what I'd like to do is pull

00:11:19,090 --> 00:11:23,500
that in or if out a level but in order

00:11:21,910 --> 00:11:24,460
to do that I have to make sure that it's

00:11:23,500 --> 00:11:26,020
safe to do that

00:11:24,460 --> 00:11:27,310
so this is the first refactoring we're

00:11:26,020 --> 00:11:28,630
doing we actually have to think a little

00:11:27,310 --> 00:11:30,760
bit about the code everything else up to

00:11:28,630 --> 00:11:32,440
this point has been very mechanical this

00:11:30,760 --> 00:11:34,030
one we have to think about so what's it

00:11:32,440 --> 00:11:35,650
doing inside that inner if while we're

00:11:34,030 --> 00:11:37,690
comparing against name we're comparing

00:11:35,650 --> 00:11:39,070
against cell in we already saw that name

00:11:37,690 --> 00:11:40,720
and cell n are just simple getters

00:11:39,070 --> 00:11:42,640
there's no magic there and then there's

00:11:40,720 --> 00:11:44,830
two calls to increase quality those

00:11:42,640 --> 00:11:46,360
calls both are protected by and if

00:11:44,830 --> 00:11:48,400
quality is less than 50 down at the

00:11:46,360 --> 00:11:51,370
bottom so we can safely pull that if

00:11:48,400 --> 00:11:53,590
statement out a level like so and now

00:11:51,370 --> 00:11:54,760
we've got exactly duplicated code and we

00:11:53,590 --> 00:11:57,970
can replace that with a call to increase

00:11:54,760 --> 00:12:00,010
quality all right there's another

00:11:57,970 --> 00:12:01,900
instance of duplication in this code and

00:12:00,010 --> 00:12:03,280
that's this phrase now this looks like

00:12:01,900 --> 00:12:05,710
it might want to be a decreased quality

00:12:03,280 --> 00:12:06,910
method but there's this extra comparison

00:12:05,710 --> 00:12:08,950
against name in there that really

00:12:06,910 --> 00:12:10,210
doesn't belong in decrease quality so

00:12:08,950 --> 00:12:13,060
again we have to reason about this a

00:12:10,210 --> 00:12:14,890
little bit and what we see is we've got

00:12:13,060 --> 00:12:17,110
these two nested if statements there's

00:12:14,890 --> 00:12:18,280
no else clauses to worry about and the

00:12:17,110 --> 00:12:19,690
two conditions are completely

00:12:18,280 --> 00:12:21,280
independent it's not like we're checking

00:12:19,690 --> 00:12:22,540
for nil and then sending a message to

00:12:21,280 --> 00:12:24,220
the object that we're sure is not nil

00:12:22,540 --> 00:12:26,740
these are completely independent so we

00:12:24,220 --> 00:12:28,480
can just reverse them okay then we have

00:12:26,740 --> 00:12:30,880
to think about that a little bit but not

00:12:28,480 --> 00:12:33,610
too bad all right and now we can extract

00:12:30,880 --> 00:12:36,490
a decreased quality method and that's

00:12:33,610 --> 00:12:40,300
better okay are we there yet can we do

00:12:36,490 --> 00:12:43,450
conjured items yet I'm really not seeing

00:12:40,300 --> 00:12:44,770
it but what I am seeing is that there's

00:12:43,450 --> 00:12:46,840
kind of three main sections to this

00:12:44,770 --> 00:12:48,940
method the top section is all about

00:12:46,840 --> 00:12:50,890
updating the quality then there's this

00:12:48,940 --> 00:12:53,590
little tiny middle section that's about

00:12:50,890 --> 00:12:55,330
updating a cell one date or cell in days

00:12:53,590 --> 00:12:57,670
and then the bottom section which is

00:12:55,330 --> 00:12:58,900
also about adjusting the quality so what

00:12:57,670 --> 00:13:01,540
I'd like to do is I'd like to group

00:12:58,900 --> 00:13:03,220
similar tasks so what I want to do is I

00:13:01,540 --> 00:13:04,810
want to move that cell in clause in the

00:13:03,220 --> 00:13:06,610
middle either up to the top or down to

00:13:04,810 --> 00:13:11,080
the bottom so zoom in on that a little

00:13:06,610 --> 00:13:12,820
bit if we move it to the top what our

00:13:11,080 --> 00:13:14,830
method looks like is we're adjusting the

00:13:12,820 --> 00:13:16,720
cell and date of the item and then we're

00:13:14,830 --> 00:13:18,220
adjusting the quality based on that new

00:13:16,720 --> 00:13:19,750
cell and date that seems to make logical

00:13:18,220 --> 00:13:21,820
sense to me that seems to read very well

00:13:19,750 --> 00:13:23,920
so I'd like to move it up to the

00:13:21,820 --> 00:13:25,360
but if I do that sellin is going to be

00:13:23,920 --> 00:13:27,010
one less than it used to be and so I

00:13:25,360 --> 00:13:28,690
have to adjust those other two if

00:13:27,010 --> 00:13:31,240
statements that talk about selling in

00:13:28,690 --> 00:13:32,980
there so I'm gonna do that again we had

00:13:31,240 --> 00:13:34,690
to think about this a little bit still

00:13:32,980 --> 00:13:35,649
not too complex reasoning but we do have

00:13:34,690 --> 00:13:37,600
to think and we have the

00:13:35,649 --> 00:13:39,790
characterization test to protect us if

00:13:37,600 --> 00:13:42,550
it goes wrong so now we've moved that up

00:13:39,790 --> 00:13:45,070
to the top and we'll zoom back out and

00:13:42,550 --> 00:13:47,920
see the whole method again now we've got

00:13:45,070 --> 00:13:49,750
this method that does two distinct tasks

00:13:47,920 --> 00:13:51,279
so let's extract those and give those

00:13:49,750 --> 00:13:53,950
names so we're gonna first extract the

00:13:51,279 --> 00:13:55,420
top part and call it age and then we'll

00:13:53,950 --> 00:13:58,480
extract the bottom part and call it

00:13:55,420 --> 00:14:00,220
update quality okay so now update is a

00:13:58,480 --> 00:14:01,450
very nice clean method it says exactly

00:14:00,220 --> 00:14:02,980
what it does it actually follow

00:14:01,450 --> 00:14:05,320
something Kent Beck calls the composed

00:14:02,980 --> 00:14:07,060
method pattern which I'm not going to go

00:14:05,320 --> 00:14:08,709
into here but it's a very nice clean

00:14:07,060 --> 00:14:10,270
method and that's actually our top level

00:14:08,709 --> 00:14:11,680
entry point in the item wrapper class if

00:14:10,270 --> 00:14:13,480
you remember so you look at the item

00:14:11,680 --> 00:14:15,089
wrapper and say oh to update an item I

00:14:13,480 --> 00:14:18,370
ate it and I update its quality I

00:14:15,089 --> 00:14:20,260
understand that that makes sense now can

00:14:18,370 --> 00:14:25,570
we do contrib items we made it better

00:14:20,260 --> 00:14:28,170
right no it's still pretty nasty so I

00:14:25,570 --> 00:14:30,550
think we finally got to the point where

00:14:28,170 --> 00:14:32,230
all we can really do is tackle these

00:14:30,550 --> 00:14:33,910
nasty conditionals so it's time to

00:14:32,230 --> 00:14:35,560
simplify those so this is where things

00:14:33,910 --> 00:14:36,730
get ugly but now we've got our hands on

00:14:35,560 --> 00:14:38,020
the code a little bit we've kind of got

00:14:36,730 --> 00:14:40,120
the feel of what we're starting to get a

00:14:38,020 --> 00:14:41,529
sense of it and now we're feeling a

00:14:40,120 --> 00:14:43,000
little more confident in our ability to

00:14:41,529 --> 00:14:45,370
tackle this code and that's that's a

00:14:43,000 --> 00:14:46,660
good thing so the first thing I see is

00:14:45,370 --> 00:14:49,450
that all of these conditions are

00:14:46,660 --> 00:14:51,339
negative not equal to not equal to not

00:14:49,450 --> 00:14:53,020
equal to and negative conditions are

00:14:51,339 --> 00:14:54,490
generally harder to reason about them

00:14:53,020 --> 00:14:57,550
positive conditions so I'd like to

00:14:54,490 --> 00:14:59,020
reverse those now there's the inner ones

00:14:57,550 --> 00:15:01,360
where a name not equal to sulphurous

00:14:59,020 --> 00:15:02,680
there is no else there those ones are

00:15:01,360 --> 00:15:04,150
harder to negate so we'll ignore that

00:15:02,680 --> 00:15:07,209
but let's zoom in down at the bottom on

00:15:04,150 --> 00:15:08,500
just the backstage passes check and I'd

00:15:07,209 --> 00:15:10,180
like to negate that and make it an

00:15:08,500 --> 00:15:11,709
equals equals rather than a not equals

00:15:10,180 --> 00:15:13,839
and to do that you just have to swap

00:15:11,709 --> 00:15:15,930
those in and the else parts okay just

00:15:13,839 --> 00:15:18,940
reverse those so that looks like this

00:15:15,930 --> 00:15:20,709
okay so now it's a positive check not a

00:15:18,940 --> 00:15:22,480
negative check and we can zoom out one

00:15:20,709 --> 00:15:25,420
level and do the same thing with aged

00:15:22,480 --> 00:15:27,550
brie and then we can go look at the top

00:15:25,420 --> 00:15:29,350
condition now and I like to do that here

00:15:27,550 --> 00:15:31,510
but this is a compound condition it's a

00:15:29,350 --> 00:15:33,220
little more complex to negate that

00:15:31,510 --> 00:15:34,630
condition we still swap those n in the

00:15:33,220 --> 00:15:36,820
else that's fine but

00:15:34,630 --> 00:15:38,230
condition is harder to reverse and

00:15:36,820 --> 00:15:40,540
thankfully Ryan already taught you about

00:15:38,230 --> 00:15:42,490
the Morgans law I'm gonna teach you

00:15:40,540 --> 00:15:46,180
about it again using Ruby this time

00:15:42,490 --> 00:15:48,130
instead of circuits or gates so if you

00:15:46,180 --> 00:15:50,350
wanted to gate a and B so a and B is

00:15:48,130 --> 00:15:51,760
false if either a is false or B is false

00:15:50,350 --> 00:15:53,470
and that's basically what de Morgan's

00:15:51,760 --> 00:15:55,240
says and then there's a version for

00:15:53,470 --> 00:15:56,410
switching ORS to Anne's so let's apply

00:15:55,240 --> 00:15:59,140
that to our code so there's our

00:15:56,410 --> 00:16:02,710
condition we want to negate it and then

00:15:59,140 --> 00:16:03,370
we applied to Morgan's law which looks

00:16:02,710 --> 00:16:05,140
really ugly

00:16:03,370 --> 00:16:08,890
and then we simplify those all those

00:16:05,140 --> 00:16:11,740
knots okay so for quick steps there and

00:16:08,890 --> 00:16:13,270
now we have the inverted condition and

00:16:11,740 --> 00:16:15,250
now we can apply that back to our code

00:16:13,270 --> 00:16:19,300
swap the then and the else parts like we

00:16:15,250 --> 00:16:21,340
did before and that looks like that okay

00:16:19,300 --> 00:16:23,530
next let's look at the overall skeleton

00:16:21,340 --> 00:16:24,970
of this of this method just the if

00:16:23,530 --> 00:16:26,620
something else is notice this pattern

00:16:24,970 --> 00:16:29,350
where there's an else with a nested if

00:16:26,620 --> 00:16:31,090
and else with nested if ruby has an

00:16:29,350 --> 00:16:33,940
else--if keyword that allows us to get

00:16:31,090 --> 00:16:36,580
rid of a lot of that nesting so that

00:16:33,940 --> 00:16:42,580
looks a little better and we can look at

00:16:36,580 --> 00:16:44,920
that in full context here the next thing

00:16:42,580 --> 00:16:46,390
I want to do is I want to look at this a

00:16:44,920 --> 00:16:48,160
little bit at the bottom of both of

00:16:46,390 --> 00:16:50,260
these if clauses there's an else if name

00:16:48,160 --> 00:16:52,510
not equal to self URIs and then we do

00:16:50,260 --> 00:16:55,930
nothing so let's zoom in on that a

00:16:52,510 --> 00:16:58,120
little bit if name is sulfurous this

00:16:55,930 --> 00:17:00,760
whole method does absolutely nothing we

00:16:58,120 --> 00:17:02,200
skip everything and so what I want to do

00:17:00,760 --> 00:17:03,850
is I want to take these to duplicate

00:17:02,200 --> 00:17:05,560
conditions and extract them up and make

00:17:03,850 --> 00:17:07,569
them a guard clause in the method so

00:17:05,560 --> 00:17:08,860
that we just return if it's self URIs

00:17:07,569 --> 00:17:12,010
and forget about them for the rest of

00:17:08,860 --> 00:17:15,459
the method okay so that looks like that

00:17:12,010 --> 00:17:17,829
and then we zoom out a level notice that

00:17:15,459 --> 00:17:19,689
age does almost exactly the same thing

00:17:17,829 --> 00:17:21,040
and we can quickly invert that condition

00:17:19,689 --> 00:17:24,610
make it a guard clause and make it

00:17:21,040 --> 00:17:26,380
exactly the same now we've got two

00:17:24,610 --> 00:17:28,240
methods that have the exact same guard

00:17:26,380 --> 00:17:29,980
clause at the top and they're both

00:17:28,240 --> 00:17:32,050
called from a higher level method and

00:17:29,980 --> 00:17:34,030
that's the only place they're called

00:17:32,050 --> 00:17:36,250
from because we just extracted those two

00:17:34,030 --> 00:17:37,990
methods we know that so we can move that

00:17:36,250 --> 00:17:39,760
guard clause up a level and Kent Beck

00:17:37,990 --> 00:17:42,250
just wrote a blog post a couple of weeks

00:17:39,760 --> 00:17:44,440
ago about something called call graph

00:17:42,250 --> 00:17:46,870
refactorings and this is kind of a call

00:17:44,440 --> 00:17:48,220
graph refactoring I actually exchanged

00:17:46,870 --> 00:17:48,530
some emails with them on the topic to

00:17:48,220 --> 00:17:50,030
make sure

00:17:48,530 --> 00:17:52,280
understood it and I'm not sure I do yet

00:17:50,030 --> 00:17:54,740
but I want to appreciate him taking the

00:17:52,280 --> 00:17:57,260
time to answer me so we'll do that

00:17:54,740 --> 00:17:58,850
refactoring right there all right

00:17:57,260 --> 00:18:02,840
now they can go back and look at update

00:17:58,850 --> 00:18:04,070
quality again that compound conditionals

00:18:02,840 --> 00:18:05,900
bothering me especially when we're

00:18:04,070 --> 00:18:07,850
checking backstage passes almost twice

00:18:05,900 --> 00:18:10,160
right in a row so what I'd like to do is

00:18:07,850 --> 00:18:11,990
split that compound conditional and kind

00:18:10,160 --> 00:18:13,970
of merge the backstage passes cases and

00:18:11,990 --> 00:18:15,710
to do that we have to duplicate that one

00:18:13,970 --> 00:18:18,850
increased quality line and that looks

00:18:15,710 --> 00:18:20,720
like that okay

00:18:18,850 --> 00:18:22,990
notice these are all really tiny

00:18:20,720 --> 00:18:25,610
baby-step refactorings all along the way

00:18:22,990 --> 00:18:27,290
now if you look at the top if statement

00:18:25,610 --> 00:18:28,940
and then the if statements that's nested

00:18:27,290 --> 00:18:31,460
in the if cell in less than zero at the

00:18:28,940 --> 00:18:34,490
bottom those if statements have the

00:18:31,460 --> 00:18:35,930
exact same structure and switching on

00:18:34,490 --> 00:18:37,970
the name of the item seems to be an

00:18:35,930 --> 00:18:39,350
important concept in this code remember

00:18:37,970 --> 00:18:40,940
kind of our system description talked

00:18:39,350 --> 00:18:43,760
about you know different kinds of items

00:18:40,940 --> 00:18:45,530
have different rules I want to kind of

00:18:43,760 --> 00:18:47,000
unify those those if statements together

00:18:45,530 --> 00:18:48,650
and to do that we kind of have to

00:18:47,000 --> 00:18:50,480
distribute that cell in less than zero

00:18:48,650 --> 00:18:52,250
check to all the conditions so I'm going

00:18:50,480 --> 00:18:54,740
to first merge that the bottom else

00:18:52,250 --> 00:18:56,240
clauses that looks like that so we

00:18:54,740 --> 00:18:57,730
decrease quality and then if someone was

00:18:56,240 --> 00:19:00,490
less than zero we decrease quality again

00:18:57,730 --> 00:19:03,830
repeat that for backstage passes and

00:19:00,490 --> 00:19:05,540
repeat that for aged brie and now we

00:19:03,830 --> 00:19:07,790
have this method with the top level

00:19:05,540 --> 00:19:09,980
switching on the name and then logic for

00:19:07,790 --> 00:19:11,570
each of the cases okay

00:19:09,980 --> 00:19:14,720
are we there yet can we do conjured

00:19:11,570 --> 00:19:16,760
items yet this is the first time I feel

00:19:14,720 --> 00:19:19,850
like I can confidently support conjured

00:19:16,760 --> 00:19:21,380
items and actually have it work and have

00:19:19,850 --> 00:19:23,390
the code not be significantly worse than

00:19:21,380 --> 00:19:25,550
it is now so let's go ahead and give it

00:19:23,390 --> 00:19:27,110
a shot now we're going to make the easy

00:19:25,550 --> 00:19:29,090
change we spent all this time making the

00:19:27,110 --> 00:19:32,090
change easy now let's make the easy

00:19:29,090 --> 00:19:33,740
change so there's our code and remember

00:19:32,090 --> 00:19:36,740
conjured items degrading quality twice

00:19:33,740 --> 00:19:38,870
as fast as normal items so we just add a

00:19:36,740 --> 00:19:40,430
new clause for conjured items we're

00:19:38,870 --> 00:19:42,050
comparing against the name just like the

00:19:40,430 --> 00:19:44,270
other guys do now notice we have to call

00:19:42,050 --> 00:19:46,850
decreased quality twice I really wanted

00:19:44,270 --> 00:19:48,620
to write this code but that fails two

00:19:46,850 --> 00:19:50,480
tests and the reason is the decreased

00:19:48,620 --> 00:19:54,110
quality does a check to make sure that

00:19:50,480 --> 00:19:58,460
quality never goes below zero so we have

00:19:54,110 --> 00:20:00,110
to stick with this for now okay so

00:19:58,460 --> 00:20:02,720
at this point we've actually implemented

00:20:00,110 --> 00:20:04,970
our new feature this is where I had to

00:20:02,720 --> 00:20:06,140
change the test because conjured items

00:20:04,970 --> 00:20:07,970
actually have different rules and they

00:20:06,140 --> 00:20:09,230
needed to make the test reflect that but

00:20:07,970 --> 00:20:11,360
I didn't change the test for any of the

00:20:09,230 --> 00:20:15,140
other kinds of items and our tests are

00:20:11,360 --> 00:20:16,550
green again we could stop here but we

00:20:15,140 --> 00:20:17,720
still have some time left so let's see

00:20:16,550 --> 00:20:19,220
if we can make the code just a little

00:20:17,720 --> 00:20:21,830
bit better you know we still have some

00:20:19,220 --> 00:20:23,480
time left for this feature so we want to

00:20:21,830 --> 00:20:26,180
express some important ideas in the code

00:20:23,480 --> 00:20:27,740
and the first idea comes in these two

00:20:26,180 --> 00:20:29,960
methods to decrease an increase quality

00:20:27,740 --> 00:20:31,640
they're expressing an idea from the spec

00:20:29,960 --> 00:20:33,230
which is that the quality of an item is

00:20:31,640 --> 00:20:35,930
never negative and the quality neither

00:20:33,230 --> 00:20:37,340
of them is never more than 50 but the

00:20:35,930 --> 00:20:38,990
problem is they don't express it at the

00:20:37,340 --> 00:20:41,090
lowest possible level there's other ways

00:20:38,990 --> 00:20:42,710
we can set the quality that don't go

00:20:41,090 --> 00:20:44,810
through these checks and that's why we

00:20:42,710 --> 00:20:46,280
had to call decrease quality twice so I

00:20:44,810 --> 00:20:47,990
want to push those down a level so what

00:20:46,280 --> 00:20:51,020
we can do is we can introduce a quality

00:20:47,990 --> 00:20:53,360
equals method here now we remember we're

00:20:51,020 --> 00:20:55,430
on item wrapper which is a simple

00:20:53,360 --> 00:20:57,140
delegator so by calling super we're

00:20:55,430 --> 00:20:58,820
calling simpledelegator version of

00:20:57,140 --> 00:21:00,290
quality equals which it doesn't

00:20:58,820 --> 00:21:03,200
understand so it forwards it onto the

00:21:00,290 --> 00:21:04,910
original item again this is really a no

00:21:03,200 --> 00:21:06,260
op with an extra method in there but it

00:21:04,910 --> 00:21:08,240
gives us a place to move some behavior

00:21:06,260 --> 00:21:09,860
so we can take that quality greater than

00:21:08,240 --> 00:21:11,570
zero check from decreased quality and

00:21:09,860 --> 00:21:14,030
push that down to the quality equals

00:21:11,570 --> 00:21:15,770
method we have to recast it a little bit

00:21:14,030 --> 00:21:17,960
because it's a new context but it's

00:21:15,770 --> 00:21:19,430
basically the same check so we just say

00:21:17,960 --> 00:21:21,200
if quality's less new quality's less

00:21:19,430 --> 00:21:22,490
than zero then make it zero and we can

00:21:21,200 --> 00:21:25,490
do the same thing with the quality less

00:21:22,490 --> 00:21:28,130
than 50 check and that's a little bit

00:21:25,490 --> 00:21:29,390
cleaner there's more you could do to

00:21:28,130 --> 00:21:31,970
refactor that there's actually a

00:21:29,390 --> 00:21:33,980
proposal for Ruby to add a method called

00:21:31,970 --> 00:21:36,680
clamp to numeric types that does this

00:21:33,980 --> 00:21:37,250
for you you just say new quality doc

00:21:36,680 --> 00:21:39,320
clamp

00:21:37,250 --> 00:21:42,110
0 50 and and that would work but that

00:21:39,320 --> 00:21:44,390
hasn't been implemented yet now decrease

00:21:42,110 --> 00:21:45,500
quality and increased quality really

00:21:44,390 --> 00:21:47,000
aren't pulling their own weight anymore

00:21:45,500 --> 00:21:48,980
so I'm gonna go ahead and inline those

00:21:47,000 --> 00:21:50,750
so we extracted them because they were

00:21:48,980 --> 00:21:52,010
duplication but now we've simplified

00:21:50,750 --> 00:21:54,200
them enough that we're gonna end on the

00:21:52,010 --> 00:21:55,760
back it feels like we're waffling a

00:21:54,200 --> 00:21:56,870
little bit but we're really not we kind

00:21:55,760 --> 00:21:59,180
of learned some things by extracting

00:21:56,870 --> 00:22:00,890
them and now we can put them back in so

00:21:59,180 --> 00:22:02,900
in line decrease quality in line

00:22:00,890 --> 00:22:04,730
increase quality and now we have those

00:22:02,900 --> 00:22:06,650
duplicate quality minus equals 1 lines

00:22:04,730 --> 00:22:07,850
that we can finally merge together and

00:22:06,650 --> 00:22:11,170
get the code we wanted in the first

00:22:07,850 --> 00:22:13,060
place so that's better

00:22:11,170 --> 00:22:14,920
there's another idea that's not being

00:22:13,060 --> 00:22:16,870
expressed in this code everywhere where

00:22:14,920 --> 00:22:18,940
we touch quality we're adjusting it by

00:22:16,870 --> 00:22:20,620
some amount and so there's this concept

00:22:18,940 --> 00:22:22,630
of a quality adjustment that seems like

00:22:20,620 --> 00:22:24,250
it might be important now I did this

00:22:22,630 --> 00:22:25,570
refactoring in probably six or seven

00:22:24,250 --> 00:22:26,650
steps which I don't have time to run

00:22:25,570 --> 00:22:29,590
through so I'm just gonna show you the

00:22:26,650 --> 00:22:31,060
final product so update quality now just

00:22:29,590 --> 00:22:32,440
says self-taught quality plus equals

00:22:31,060 --> 00:22:33,760
quality adjustment and then quality

00:22:32,440 --> 00:22:35,620
adjustment goes through all the cases

00:22:33,760 --> 00:22:42,010
and computes what the quality adjustment

00:22:35,620 --> 00:22:45,130
should be okay and now what we can do

00:22:42,010 --> 00:22:48,370
with that and we just double check if I

00:22:45,130 --> 00:22:49,570
go around yes all right so there's

00:22:48,370 --> 00:22:51,430
another refactoring I want to do here we

00:22:49,570 --> 00:22:53,290
have this big long conditional and all

00:22:51,430 --> 00:22:55,090
those cases are independent and there's

00:22:53,290 --> 00:22:57,880
a refactoring called replace conditional

00:22:55,090 --> 00:23:00,610
with polymorphism so we're gonna do that

00:22:57,880 --> 00:23:01,570
next so we have our item wrappers and

00:23:00,610 --> 00:23:04,000
what we want to do is we're gonna make

00:23:01,570 --> 00:23:05,740
subclasses of item wrapper and push

00:23:04,000 --> 00:23:07,000
behavior down to those subclasses so

00:23:05,740 --> 00:23:10,150
that each Bri will go to an age Bri

00:23:07,000 --> 00:23:13,750
subclass and so on pardon me for a

00:23:10,150 --> 00:23:16,810
second in order to do that we need to

00:23:13,750 --> 00:23:17,980
create the right kind of subclass off of

00:23:16,810 --> 00:23:19,630
an item so we're gonna introduce

00:23:17,980 --> 00:23:20,980
something called a factory method to

00:23:19,630 --> 00:23:21,550
item wrapper and I'm just gonna call it

00:23:20,980 --> 00:23:23,830
wrap

00:23:21,550 --> 00:23:25,720
notice the self dot wrap it's a class

00:23:23,830 --> 00:23:27,460
method and all it does right now is

00:23:25,720 --> 00:23:28,900
delegate to new again we're introducing

00:23:27,460 --> 00:23:31,420
a place that we can move some behavior

00:23:28,900 --> 00:23:34,690
to step at a time very small steps every

00:23:31,420 --> 00:23:36,580
time okay and we're calling wrap instead

00:23:34,690 --> 00:23:38,170
and new down below and now we can look

00:23:36,580 --> 00:23:40,930
at the aged Bree case now we can

00:23:38,170 --> 00:23:42,790
introduce an aged Bree subclass so the

00:23:40,930 --> 00:23:44,650
factory now says oh if item name is aged

00:23:42,790 --> 00:23:47,020
Bree then make an aged Bree otherwise

00:23:44,650 --> 00:23:48,370
make a regular item aged Bree itself

00:23:47,020 --> 00:23:50,140
just inherits from item wrapper does

00:23:48,370 --> 00:23:52,060
nothing special but now we can take the

00:23:50,140 --> 00:23:55,030
aged Bree case of quality adjustment and

00:23:52,060 --> 00:23:57,910
push that down okay

00:23:55,030 --> 00:24:00,910
and now we can read we can do that again

00:23:57,910 --> 00:24:04,660
for backstage passes and for conjured

00:24:00,910 --> 00:24:06,720
monarch cakes and now our quality

00:24:04,660 --> 00:24:10,450
adjustment method is pretty clean and

00:24:06,720 --> 00:24:11,920
all of the checks against name are up in

00:24:10,450 --> 00:24:13,390
that factory method there's no checks

00:24:11,920 --> 00:24:13,870
for name anywhere else with one

00:24:13,390 --> 00:24:16,270
exception

00:24:13,870 --> 00:24:17,950
we still have that sulfuric check down

00:24:16,270 --> 00:24:20,020
an update so let's make a subclass for

00:24:17,950 --> 00:24:21,730
those look at the spec it says so

00:24:20,020 --> 00:24:23,380
furious being a legendary item never has

00:24:21,730 --> 00:24:24,760
to be sold or decreases in quality so

00:24:23,380 --> 00:24:28,420
we're gonna make a salad

00:24:24,760 --> 00:24:30,970
item subclass and add that to the

00:24:28,420 --> 00:24:33,400
factory and then we can push down the

00:24:30,970 --> 00:24:35,320
sulfurous behavior of update down to

00:24:33,400 --> 00:24:37,230
that subclass well what happens in

00:24:35,320 --> 00:24:39,010
update if the name is so furious

00:24:37,230 --> 00:24:41,020
absolutely nothing we need an empty

00:24:39,010 --> 00:24:42,460
update method when I have one of those I

00:24:41,020 --> 00:24:44,230
tend to put a little comment and there

00:24:42,460 --> 00:24:47,320
just so the next guy coming along like

00:24:44,230 --> 00:24:49,420
next person coming along doesn't think I

00:24:47,320 --> 00:24:51,610
I forgot to put code in there I want to

00:24:49,420 --> 00:24:53,260
make it clear all right so now our

00:24:51,610 --> 00:24:54,790
Factory is the only place where we do

00:24:53,260 --> 00:24:56,320
name checks we can look at that a little

00:24:54,790 --> 00:24:57,880
bit closer there's one more little

00:24:56,320 --> 00:24:59,440
simplification we can do here we can use

00:24:57,880 --> 00:25:03,190
a case statement that makes it read just

00:24:59,440 --> 00:25:05,050
a little bit better alright so now we

00:25:03,190 --> 00:25:07,120
want to express some domain concepts we

00:25:05,050 --> 00:25:09,250
have a few minutes left to do that and

00:25:07,120 --> 00:25:11,470
have to go through this pretty quick but

00:25:09,250 --> 00:25:13,150
let's look at our spec so once the sell

00:25:11,470 --> 00:25:16,590
by date has passed quality degrades

00:25:13,150 --> 00:25:19,570
twice as fast does this code say that

00:25:16,590 --> 00:25:29,890
kind of implicit it sort of does but not

00:25:19,570 --> 00:25:31,600
really so this is about this is about

00:25:29,890 --> 00:25:39,130
five or six little baby step

00:25:31,600 --> 00:25:40,420
refactorings to get to here so quality

00:25:39,130 --> 00:25:41,680
adjustment now says if sellings less

00:25:40,420 --> 00:25:43,240
than zero then use a passed date

00:25:41,680 --> 00:25:45,280
adjustment otherwise a normal adjustment

00:25:43,240 --> 00:25:47,050
normal adjustment is minus one past date

00:25:45,280 --> 00:25:49,150
adjustment is two times normal

00:25:47,050 --> 00:25:52,230
adjustment so now that's saying quality

00:25:49,150 --> 00:25:55,000
degrades twice as fast that's better

00:25:52,230 --> 00:25:58,120
next line in the spec age spree actually

00:25:55,000 --> 00:26:01,000
increases in quality older it gets that

00:25:58,120 --> 00:26:03,190
doesn't really say that again five or

00:26:01,000 --> 00:26:05,740
six steps and we can get to here now

00:26:03,190 --> 00:26:08,440
this is a little bit weird normal items

00:26:05,740 --> 00:26:10,300
adjustment is minus one age three

00:26:08,440 --> 00:26:12,670
increases instead of decreases so we

00:26:10,300 --> 00:26:14,230
just negate the super super class

00:26:12,670 --> 00:26:15,760
implementation that might be a little

00:26:14,230 --> 00:26:17,890
too couple that may not actually do that

00:26:15,760 --> 00:26:19,900
for real I did it here because it to me

00:26:17,890 --> 00:26:21,880
it expresses the idea that it increases

00:26:19,900 --> 00:26:24,940
instead of decreases it's the opposite

00:26:21,880 --> 00:26:26,740
of what the base class was conjured

00:26:24,940 --> 00:26:29,110
items degrading quality twice as fast as

00:26:26,740 --> 00:26:33,550
normal items that doesn't really say

00:26:29,110 --> 00:26:36,280
that that does again five or six steps

00:26:33,550 --> 00:26:37,430
to get there and finally backstage

00:26:36,280 --> 00:26:39,590
passes

00:26:37,430 --> 00:26:41,450
first one of the things that says as the

00:26:39,590 --> 00:26:43,550
quality drops to zero after the concert

00:26:41,450 --> 00:26:45,290
so we can use this past date adjustment

00:26:43,550 --> 00:26:48,050
that we have in the base class and just

00:26:45,290 --> 00:26:49,970
override it and return - quality doesn't

00:26:48,050 --> 00:26:51,140
quite say it drops to zero unfortunately

00:26:49,970 --> 00:26:54,020
it doesn't read quite that cleanly I

00:26:51,140 --> 00:26:55,400
might do a little more work on that but

00:26:54,020 --> 00:26:56,810
it's not bad and then we can look at

00:26:55,400 --> 00:26:58,310
normal adjustment we can clean it up

00:26:56,810 --> 00:27:01,250
just a little bit again this is a few

00:26:58,310 --> 00:27:02,150
steps that reads pretty good now let's

00:27:01,250 --> 00:27:05,210
look at the rest of the spec for

00:27:02,150 --> 00:27:06,920
backstage passes quality increases by

00:27:05,210 --> 00:27:08,570
two when there are ten days or less and

00:27:06,920 --> 00:27:13,340
by three when there are five days or

00:27:08,570 --> 00:27:15,470
less does this say that pretty close but

00:27:13,340 --> 00:27:17,660
the spec says five days or less in ten

00:27:15,470 --> 00:27:21,140
days or less this code says less than

00:27:17,660 --> 00:27:24,680
five less than ten that's a mismatch is

00:27:21,140 --> 00:27:27,310
that a bug we don't know maybe the spec

00:27:24,680 --> 00:27:30,110
is out of date maybe the code is wrong

00:27:27,310 --> 00:27:31,790
we are not gonna blindly fix that bug

00:27:30,110 --> 00:27:33,170
because there might be people relying on

00:27:31,790 --> 00:27:35,480
that behavior or other systems

00:27:33,170 --> 00:27:38,420
downstream a lot of times in legacy code

00:27:35,480 --> 00:27:39,740
one bug masks another bug so when you're

00:27:38,420 --> 00:27:42,230
working legacy code you really have to

00:27:39,740 --> 00:27:43,790
be careful to preserve behavior until

00:27:42,230 --> 00:27:45,140
you can find out more information and

00:27:43,790 --> 00:27:46,280
decide if that's really a bug and

00:27:45,140 --> 00:27:48,710
whether you should really fix it right

00:27:46,280 --> 00:27:50,210
now so we are not going to do that so

00:27:48,710 --> 00:27:52,010
let's quickly review the final code

00:27:50,210 --> 00:27:56,420
remember where we started avert your

00:27:52,010 --> 00:27:58,130
eyes if this bothered you before I

00:27:56,420 --> 00:28:00,680
actually ran flog Thank You Ryan for

00:27:58,130 --> 00:28:03,920
that tool this is where we started the

00:28:00,680 --> 00:28:08,000
total was 170 9.5 and that one update

00:28:03,920 --> 00:28:12,650
quality method was 155 point one so 80

00:28:08,000 --> 00:28:15,110
this was actually 80 steps later there's

00:28:12,650 --> 00:28:16,850
our database quote-unquote there's the

00:28:15,110 --> 00:28:18,290
new update quality method just loops

00:28:16,850 --> 00:28:21,190
through the items wraps them and updates

00:28:18,290 --> 00:28:24,860
them there's our factory that we built

00:28:21,190 --> 00:28:28,040
there's update and age there's how we

00:28:24,860 --> 00:28:33,680
update quality and there's the

00:28:28,040 --> 00:28:36,500
subclasses now our total 67.1 down from

00:28:33,680 --> 00:28:39,050
179 point 5 the worst method is now

00:28:36,500 --> 00:28:41,360
gilded road initialized which we didn't

00:28:39,050 --> 00:28:42,680
touch that method that was out of scope

00:28:41,360 --> 00:28:44,060
for the change we were trying to make so

00:28:42,680 --> 00:28:45,950
the worst method is one we didn't touch

00:28:44,060 --> 00:28:47,690
the worst method that we touched was

00:28:45,950 --> 00:28:50,570
actually the factory method which was a

00:28:47,690 --> 00:28:50,870
9.5 so our worst method went from a 155

00:28:50,570 --> 00:28:54,170
point

00:28:50,870 --> 00:28:56,360
to a 9.5 of the code we touched that's a

00:28:54,170 --> 00:28:58,790
pretty good improvement I would argue so

00:28:56,360 --> 00:29:00,410
what do we learn slow and steady wins

00:28:58,790 --> 00:29:02,780
the race we didn't rewrite this thing we

00:29:00,410 --> 00:29:04,550
just very tiny steps very tiny safe

00:29:02,780 --> 00:29:06,170
steps there's a few places where we have

00:29:04,550 --> 00:29:08,270
to think a little bit but mostly this

00:29:06,170 --> 00:29:09,800
was mechanical changes following

00:29:08,270 --> 00:29:11,240
standard refactorings out of martin

00:29:09,800 --> 00:29:12,230
fowler's book if you haven't read that

00:29:11,240 --> 00:29:16,790
book you need to read that one too

00:29:12,230 --> 00:29:18,470
refactoring but just very tiny steps we

00:29:16,790 --> 00:29:21,440
made the change easy then we made the

00:29:18,470 --> 00:29:22,820
easy change we made simple mechanical

00:29:21,440 --> 00:29:24,290
changes first so we could get our hands

00:29:22,820 --> 00:29:26,720
on the code and start to get a sense of

00:29:24,290 --> 00:29:28,730
it we reduced noise we remove

00:29:26,720 --> 00:29:30,530
duplication and we made sure we

00:29:28,730 --> 00:29:32,600
expressed important ideas and we express

00:29:30,530 --> 00:29:34,520
domain concepts in the code so that the

00:29:32,600 --> 00:29:35,870
next person that comes along will have

00:29:34,520 --> 00:29:38,270
an easier time with the code and that's

00:29:35,870 --> 00:29:39,380
probably going to be us like live said

00:29:38,270 --> 00:29:40,580
if you don't have empathy for other

00:29:39,380 --> 00:29:43,370
people at least have empathy for

00:29:40,580 --> 00:29:47,690
yourself and we didn't mindlessly fix

00:29:43,370 --> 00:29:49,820
the bugs there is a github repo that has

00:29:47,690 --> 00:29:51,500
every single tiny refactoring that I did

00:29:49,820 --> 00:29:53,390
including one more I didn't talk about

00:29:51,500 --> 00:29:55,010
so there's actually a t1 in there so if

00:29:53,390 --> 00:29:56,780
you want to go see all the micro steps I

00:29:55,010 --> 00:29:59,090
did there there

00:29:56,780 --> 00:30:00,559
I thank my company for sending me zeal

00:29:59,090 --> 00:30:01,760
as a local consulting company where I

00:30:00,559 --> 00:30:03,350
live that they let me come in and do

00:30:01,760 --> 00:30:05,090
this as a Tech Talk for them giving lots

00:30:03,350 --> 00:30:07,550
of great feedback and Kent Beck

00:30:05,090 --> 00:30:09,440
exchanged some email with me there's

00:30:07,550 --> 00:30:10,700
some references slides will be up on

00:30:09,440 --> 00:30:12,290
speaker deck I don't have time for

00:30:10,700 --> 00:30:15,110
questions unfortunately I apologize for

00:30:12,290 --> 00:30:16,610
that any feedback on the talk could be

00:30:15,110 --> 00:30:17,990
great and the slides will be on speaker

00:30:16,610 --> 00:30:20,360
deck actually I think they're up already

00:30:17,990 --> 00:30:24,320
so if you want to see them great and

00:30:20,360 --> 00:30:26,740
thank you very much awesome thanks very

00:30:24,320 --> 00:30:26,740
much Randy

00:30:34,100 --> 00:30:36,160

YouTube URL: https://www.youtube.com/watch?v=r3bi2xv5t20


