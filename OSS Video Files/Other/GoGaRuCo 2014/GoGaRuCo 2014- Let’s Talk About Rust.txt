Title: GoGaRuCo 2014- Let’s Talk About Rust
Publication date: 2020-01-23
Playlist: GoGaRuCo 2014
Description: 
	By, Yehuda Katz

Help us caption & translate this video!

http://amara.org/v/FUGR/
Captions: 
	00:00:12,620 --> 00:00:18,000
so 30 minutes is a really aggressive

00:00:15,480 --> 00:00:20,010
timeframe to introduce a group of people

00:00:18,000 --> 00:00:22,529
that doesn't really have much context

00:00:20,010 --> 00:00:25,050
for this so I'm gonna maybe go a little

00:00:22,529 --> 00:00:26,880
fast maybe hopefully not too fast but

00:00:25,050 --> 00:00:28,769
also there's a you should think of this

00:00:26,880 --> 00:00:31,230
talk as a starting off point a

00:00:28,769 --> 00:00:33,750
jumping-off point for your in interest

00:00:31,230 --> 00:00:35,130
in rust if you become interested and

00:00:33,750 --> 00:00:36,780
maybe there will be a few things here

00:00:35,130 --> 00:00:40,079
and there that you could sort of jump

00:00:36,780 --> 00:00:42,210
off and use or look into I'm gonna be

00:00:40,079 --> 00:00:44,280
writing a blog post over the next few

00:00:42,210 --> 00:00:46,289
weeks I think that talks about how you

00:00:44,280 --> 00:00:48,480
specifically integrate rust into a Ruby

00:00:46,289 --> 00:00:49,500
or rails application and I'm not gonna

00:00:48,480 --> 00:00:51,420
talk about that today because that's

00:00:49,500 --> 00:00:52,860
kind of its whole other talk but I think

00:00:51,420 --> 00:00:54,600
if you really if you leave this talk

00:00:52,860 --> 00:00:56,820
thinking that you really want to use

00:00:54,600 --> 00:00:58,079
rust for something real that's probably

00:00:56,820 --> 00:01:00,270
gonna be the best way for you to do that

00:00:58,079 --> 00:01:04,739
so keep an eye out for on the skylight

00:01:00,270 --> 00:01:07,519
blog we'll be talking about it yeah

00:01:04,739 --> 00:01:07,519
what's up with that

00:01:11,689 --> 00:01:16,749
so I think the way a lot of people look

00:01:15,079 --> 00:01:19,340
at programming languages is with this

00:01:16,749 --> 00:01:20,929
sort of quadrant grid you can see that

00:01:19,340 --> 00:01:24,409
when they announce Swift Apple created

00:01:20,929 --> 00:01:26,479
this quadrant grid and among despite the

00:01:24,409 --> 00:01:28,850
fact that it's really silly like I don't

00:01:26,479 --> 00:01:31,670
think Ruby is faster and more performant

00:01:28,850 --> 00:01:33,590
and more performant than JavaScript and

00:01:31,670 --> 00:01:38,240
I don't really I don't understand any of

00:01:33,590 --> 00:01:39,649
it really but I think people do think of

00:01:38,240 --> 00:01:41,450
the world in terms of these quadrants

00:01:39,649 --> 00:01:42,979
and I think if I was gonna give a talk

00:01:41,450 --> 00:01:44,479
about rust and I wasn't me probably I

00:01:42,979 --> 00:01:46,429
would also make one of these quadrant

00:01:44,479 --> 00:01:49,610
diagrams and try to stick rust in one of

00:01:46,429 --> 00:01:51,170
the quadrants and for me I am showing

00:01:49,610 --> 00:01:53,299
this because I think it's kind of a bad

00:01:51,170 --> 00:01:55,069
way to think about program programs and

00:01:53,299 --> 00:01:57,649
programming in general and the reason

00:01:55,069 --> 00:01:59,420
for that is that in programming really

00:01:57,649 --> 00:02:01,459
the only thing that is that stays the

00:01:59,420 --> 00:02:03,770
same is change the only constant is

00:02:01,459 --> 00:02:05,569
change and what that means is that a lot

00:02:03,770 --> 00:02:06,849
of people have this fixed picture in

00:02:05,569 --> 00:02:09,890
their head of this trade-off between

00:02:06,849 --> 00:02:11,690
performance and productivity and they

00:02:09,890 --> 00:02:13,250
imagine that that trade-off is kind of

00:02:11,690 --> 00:02:14,780
fixed so if you gain a little more

00:02:13,250 --> 00:02:16,190
productivity then surely what that means

00:02:14,780 --> 00:02:20,180
is that you've traded off some

00:02:16,190 --> 00:02:21,980
performance but if you look at reality

00:02:20,180 --> 00:02:24,200
you look at reality and this is let's

00:02:21,980 --> 00:02:25,519
say 2005 you'll see okay there's the

00:02:24,200 --> 00:02:27,470
programming language JavaScript which

00:02:25,519 --> 00:02:29,359
didn't have that logo at the time it was

00:02:27,470 --> 00:02:31,549
a reasonably productive programming

00:02:29,359 --> 00:02:35,660
language it was a dynamic language maíam

00:02:31,549 --> 00:02:37,849
does not very fast and then if you were

00:02:35,660 --> 00:02:39,829
gonna look at that diagram and fast

00:02:37,849 --> 00:02:43,459
forward 10 years obviously javascript

00:02:39,829 --> 00:02:45,139
hasn't improved it's it hasn't really

00:02:43,459 --> 00:02:47,630
changed that much in terms of

00:02:45,139 --> 00:02:49,280
productivity it hasn't gotten maybe it's

00:02:47,630 --> 00:02:50,540
gotten a little bit better but for the

00:02:49,280 --> 00:02:51,739
most part the language that most people

00:02:50,540 --> 00:02:53,810
write today is the same language the

00:02:51,739 --> 00:02:54,919
most people wrote ten years ago so if

00:02:53,810 --> 00:02:56,299
you were gonna think about things as

00:02:54,919 --> 00:02:59,269
just a trade-off between productivity

00:02:56,299 --> 00:03:01,160
and performance you would expect well of

00:02:59,269 --> 00:03:03,049
course JavaScript hasn't gotten any

00:03:01,160 --> 00:03:03,950
hasn't become worse than productivity so

00:03:03,049 --> 00:03:05,599
that means it must not have gotten

00:03:03,950 --> 00:03:06,669
faster but of course what actually

00:03:05,599 --> 00:03:08,720
happened during that time is that

00:03:06,669 --> 00:03:10,459
javascript got a little bit more

00:03:08,720 --> 00:03:14,209
productive with es5 and some es6

00:03:10,459 --> 00:03:16,700
features and a lot faster and really in

00:03:14,209 --> 00:03:18,190
in reality every language that has that

00:03:16,700 --> 00:03:21,380
sticks around for any period of time

00:03:18,190 --> 00:03:22,910
tries to figure out ways to improve

00:03:21,380 --> 00:03:24,320
productivity without reducing

00:03:22,910 --> 00:03:25,040
performance over time which means that

00:03:24,320 --> 00:03:26,900
every single

00:03:25,040 --> 00:03:28,579
language is always moving you it looks

00:03:26,900 --> 00:03:29,959
like you should have to go down and to

00:03:28,579 --> 00:03:31,670
the right but really every language

00:03:29,959 --> 00:03:35,390
going up into the right and when the

00:03:31,670 --> 00:03:37,519
language changes enough or when a new

00:03:35,390 --> 00:03:40,010
language comes out that is sufficiently

00:03:37,519 --> 00:03:41,720
different from other languages it

00:03:40,010 --> 00:03:43,069
enables a whole new generation of people

00:03:41,720 --> 00:03:44,629
to do something that they couldn't do

00:03:43,069 --> 00:03:45,590
before and I think you javascript is

00:03:44,629 --> 00:03:47,989
really good example this right

00:03:45,590 --> 00:03:49,579
JavaScript was really a slow language to

00:03:47,989 --> 00:03:50,840
begin with but when JavaScript got fast

00:03:49,579 --> 00:03:52,700
and when it got a little more productive

00:03:50,840 --> 00:03:54,500
and when the ergonomics of using it on

00:03:52,700 --> 00:03:56,329
the server got better it enabled a whole

00:03:54,500 --> 00:03:58,129
generation of front-end developers to

00:03:56,329 --> 00:03:59,599
write back-end code and I think you

00:03:58,129 --> 00:04:00,920
could you could say oh well I don't want

00:03:59,599 --> 00:04:02,750
my jQuery developer writing back-end

00:04:00,920 --> 00:04:04,819
code you can say that all you want but

00:04:02,750 --> 00:04:06,470
the reality is that if you're looking at

00:04:04,819 --> 00:04:08,239
the quadrant you missed these shifts

00:04:06,470 --> 00:04:10,939
these changes in the programming

00:04:08,239 --> 00:04:13,159
landscape that enables whole generations

00:04:10,939 --> 00:04:14,480
of people large groups of people to do

00:04:13,159 --> 00:04:18,530
something that they weren't able to do

00:04:14,480 --> 00:04:19,849
before and rust is sort of trying to do

00:04:18,530 --> 00:04:22,880
a similar thing right so Russ is a new

00:04:19,849 --> 00:04:24,889
language but rust is also trying to

00:04:22,880 --> 00:04:26,150
enable people who might not have been

00:04:24,889 --> 00:04:27,620
willing to do something before or might

00:04:26,150 --> 00:04:30,139
not be able to do something for it to do

00:04:27,620 --> 00:04:32,210
something now and just to give you a

00:04:30,139 --> 00:04:34,370
high-level sense of what's going on here

00:04:32,210 --> 00:04:36,770
before Russ there were essentially two

00:04:34,370 --> 00:04:39,320
kinds of languages there were languages

00:04:36,770 --> 00:04:40,520
that were safe and what I mean by safe

00:04:39,320 --> 00:04:42,530
is that if you write a program in the

00:04:40,520 --> 00:04:44,750
programming language and there's no bugs

00:04:42,530 --> 00:04:47,240
in the compiler or the interpreter your

00:04:44,750 --> 00:04:48,500
program cannot have a seg fault right so

00:04:47,240 --> 00:04:50,000
whenever that happens to you in Ruby

00:04:48,500 --> 00:04:52,010
what that means is that there's some C

00:04:50,000 --> 00:04:53,449
code involved it's not Ruby giving you

00:04:52,010 --> 00:04:55,580
the seg fault it's some C code giving it

00:04:53,449 --> 00:04:57,260
a seg fault and that's a guarantee if

00:04:55,580 --> 00:04:58,729
you write in Ruby or you write in Python

00:04:57,260 --> 00:05:00,139
you're writing go because there's a

00:04:58,729 --> 00:05:02,630
garbage collector in those programming

00:05:00,139 --> 00:05:04,760
languages you're guaranteed that if you

00:05:02,630 --> 00:05:08,360
write code will not get a seg fault and

00:05:04,760 --> 00:05:10,699
then there's other languages C C++ and a

00:05:08,360 --> 00:05:13,010
few other languages of that oak that

00:05:10,699 --> 00:05:14,750
give you direct control over where you

00:05:13,010 --> 00:05:16,250
can put your memory and that correct

00:05:14,750 --> 00:05:18,560
control gives you the ability to get

00:05:16,250 --> 00:05:21,169
better performance better memory usage

00:05:18,560 --> 00:05:22,520
and all that but the trade-off of that

00:05:21,169 --> 00:05:24,320
is that if you make a little mistake if

00:05:22,520 --> 00:05:25,909
you slip up a little bit and everybody

00:05:24,320 --> 00:05:27,710
knows who's ever tried to work with C or

00:05:25,909 --> 00:05:29,570
C++ that it's not just a matter of

00:05:27,710 --> 00:05:31,370
learning these five tricks here it's a

00:05:29,570 --> 00:05:33,860
matter of being a guru basically in the

00:05:31,370 --> 00:05:35,419
language if you make any mistakes it's

00:05:33,860 --> 00:05:35,779
unsafe and you could fail you could seg

00:05:35,419 --> 00:05:38,719
fault

00:05:35,779 --> 00:05:40,699
and what rust is trying to do

00:05:38,719 --> 00:05:43,659
fundamentally at a high level is to give

00:05:40,699 --> 00:05:46,189
you the safety of a language like Ruby

00:05:43,659 --> 00:05:47,149
without forcing everything to go through

00:05:46,189 --> 00:05:48,709
a garbage collector or a reference

00:05:47,149 --> 00:05:50,479
counter so basically giving you the

00:05:48,709 --> 00:05:53,029
ability to control where your memory is

00:05:50,479 --> 00:05:54,769
going directly exactly and for people

00:05:53,029 --> 00:05:57,079
who know it that could mean putting

00:05:54,769 --> 00:05:58,189
things on the stack or a variety of

00:05:57,079 --> 00:05:59,419
other places where you might want to

00:05:58,189 --> 00:06:01,759
allocate memory you have direct control

00:05:59,419 --> 00:06:04,759
over that but you don't have to trade

00:06:01,759 --> 00:06:08,209
off safety and I think from from an

00:06:04,759 --> 00:06:10,009
ergonomics perspective if you are a

00:06:08,209 --> 00:06:11,779
person that has ever tried to write code

00:06:10,009 --> 00:06:14,899
that's more efficient by having more

00:06:11,779 --> 00:06:16,369
control the biggest source of ergonomic

00:06:14,899 --> 00:06:19,099
pain the biggest source of productivity

00:06:16,369 --> 00:06:21,019
is is not just that you lose all these

00:06:19,099 --> 00:06:23,089
high-level features it's also that at

00:06:21,019 --> 00:06:24,589
any point you could crash so just

00:06:23,089 --> 00:06:26,719
eliminating the ability to ever crash

00:06:24,589 --> 00:06:29,719
really is a big shift in the landscape

00:06:26,719 --> 00:06:32,149
of of what's possible so what is this

00:06:29,719 --> 00:06:33,319
enable what does it mean so like I said

00:06:32,149 --> 00:06:34,669
before I think the way you should always

00:06:33,319 --> 00:06:37,249
look at the programming landscape is

00:06:34,669 --> 00:06:39,499
looking for shifts for changes in what

00:06:37,249 --> 00:06:41,269
some language is doing what's possible

00:06:39,499 --> 00:06:45,229
what does it mean to have a language

00:06:41,269 --> 00:06:46,789
that is both low level and direct memory

00:06:45,229 --> 00:06:49,699
controlled but also safe what is that

00:06:46,789 --> 00:06:51,229
enable for us and what it enables is a

00:06:49,699 --> 00:06:53,029
whole new generation of people who are

00:06:51,229 --> 00:06:55,759
systems programmers and by that I mean

00:06:53,029 --> 00:06:57,949
you everyone in this room it enables

00:06:55,759 --> 00:06:59,419
every people who maybe would have been

00:06:57,949 --> 00:07:01,999
excited or interested in low level

00:06:59,419 --> 00:07:06,169
systems programming to do it and no js'

00:07:01,999 --> 00:07:07,309
which claims to be low low to the metal

00:07:06,169 --> 00:07:09,709
that's not what I mean when I say

00:07:07,309 --> 00:07:11,209
systems programming I don't mean you

00:07:09,709 --> 00:07:13,309
know programming on the metal in node.js

00:07:11,209 --> 00:07:15,259
I mean really really programming on the

00:07:13,309 --> 00:07:18,979
metal really programming at the level of

00:07:15,259 --> 00:07:21,469
the machine so before I continue I want

00:07:18,979 --> 00:07:24,800
to just throw out some real talk here

00:07:21,469 --> 00:07:26,599
and that's to say that all of us in this

00:07:24,800 --> 00:07:29,689
room including myself have been part of

00:07:26,599 --> 00:07:31,669
the high level language tribe we spend a

00:07:29,689 --> 00:07:33,649
lot of time talking to ourselves and

00:07:31,669 --> 00:07:35,329
each other about why we find ourselves

00:07:33,649 --> 00:07:37,159
being productive in high-level languages

00:07:35,329 --> 00:07:40,009
and a big part of the high-level

00:07:37,159 --> 00:07:41,899
language a big part of what we tell each

00:07:40,009 --> 00:07:43,399
other within a high-level language is a

00:07:41,899 --> 00:07:46,339
lot of yagna you aren't gonna need it

00:07:43,399 --> 00:07:47,869
and some of that stuff has to do with

00:07:46,339 --> 00:07:49,459
features that you don't need but if for

00:07:47,869 --> 00:07:50,929
this purpose of this talk what I'm

00:07:49,459 --> 00:07:52,009
talking about is you aren't going to

00:07:50,929 --> 00:07:53,749
need better

00:07:52,009 --> 00:07:55,249
performance and I think that's a thing

00:07:53,749 --> 00:07:57,020
that we tell each other a lot and I

00:07:55,249 --> 00:07:58,669
think that in many many cases maybe

00:07:57,020 --> 00:08:01,580
perhaps most cases that ends up being

00:07:58,669 --> 00:08:03,409
true but sometimes there are some cases

00:08:01,580 --> 00:08:05,270
where you actually do need better

00:08:03,409 --> 00:08:07,550
performance and I'll give you some

00:08:05,270 --> 00:08:11,419
examples of this so one example is any

00:08:07,550 --> 00:08:14,240
time anybody ever says 60 FPS or jank or

00:08:11,419 --> 00:08:15,649
real-time or high frequency trading or

00:08:14,240 --> 00:08:17,839
anything like that any time anybody ever

00:08:15,649 --> 00:08:19,430
talks about needing predictable

00:08:17,839 --> 00:08:21,710
performance I think 60fps is a good

00:08:19,430 --> 00:08:23,449
example they need better control than

00:08:21,710 --> 00:08:24,770
you get with a garbage collector any

00:08:23,449 --> 00:08:27,649
time anybody ever says I need to use

00:08:24,770 --> 00:08:29,029
less memory that memory is too high if

00:08:27,649 --> 00:08:31,069
you're writing a cross-platform a

00:08:29,029 --> 00:08:32,810
cross-platform library like a like

00:08:31,069 --> 00:08:33,949
libsass something that is meant to be

00:08:32,810 --> 00:08:35,569
embedded in a lot of different places

00:08:33,949 --> 00:08:38,000
that's a place where you care about

00:08:35,569 --> 00:08:40,490
performance and and more importantly

00:08:38,000 --> 00:08:41,719
whenever you're starting to dig into

00:08:40,490 --> 00:08:43,010
your programming language internals

00:08:41,719 --> 00:08:44,720
whenever you're reading the Ruby C code

00:08:43,010 --> 00:08:47,449
or trying to understand the JavaScript

00:08:44,720 --> 00:08:49,720
JIT these are cases where it turns out

00:08:47,449 --> 00:08:53,120
that you do need the performance and

00:08:49,720 --> 00:08:54,949
what it means when we say I don't have

00:08:53,120 --> 00:08:56,360
to worry about performance I don't have

00:08:54,949 --> 00:08:57,860
to worry about the details I don't have

00:08:56,360 --> 00:08:59,449
to worry about whether I put this on the

00:08:57,860 --> 00:09:00,800
stack or the heap I don't have to worry

00:08:59,449 --> 00:09:02,449
about whether this is allocating or not

00:09:00,800 --> 00:09:03,589
what that means is not just that you

00:09:02,449 --> 00:09:05,269
don't have to worry about it which is a

00:09:03,589 --> 00:09:07,130
great blessing when you when it doesn't

00:09:05,269 --> 00:09:09,620
matter but it also means that you can't

00:09:07,130 --> 00:09:11,149
worry about it and I think perhaps more

00:09:09,620 --> 00:09:12,740
importantly it means that if you figure

00:09:11,149 --> 00:09:14,899
out a way to control what you're doing

00:09:12,740 --> 00:09:16,790
by reading the C code or figuring out

00:09:14,899 --> 00:09:18,170
how the JIT works or doing some hacks it

00:09:16,790 --> 00:09:20,060
means it's very very difficult to

00:09:18,170 --> 00:09:21,440
communicate to other developers about

00:09:20,060 --> 00:09:23,990
what it is that you're trying to do from

00:09:21,440 --> 00:09:25,459
a performance perspective and sometimes

00:09:23,990 --> 00:09:28,760
it does matter so here I have a couple

00:09:25,459 --> 00:09:29,930
examples from ember which in JavaScript

00:09:28,760 --> 00:09:31,639
there's very very good jits

00:09:29,930 --> 00:09:33,529
but those very very good jits are very

00:09:31,639 --> 00:09:34,970
opaque but when you're when you end up

00:09:33,529 --> 00:09:36,290
caring about performance you end up

00:09:34,970 --> 00:09:37,459
really trying to understand how it works

00:09:36,290 --> 00:09:39,560
so here's an example where we have a

00:09:37,459 --> 00:09:42,319
function called make dictionary and we

00:09:39,560 --> 00:09:44,660
do a whole bunch of pointless things

00:09:42,319 --> 00:09:46,459
that are total no-ops in the semantics

00:09:44,660 --> 00:09:50,180
of the language but what it does is it

00:09:46,459 --> 00:09:52,010
tells the runtime to not try to compute

00:09:50,180 --> 00:09:54,260
this into a struct and that allows

00:09:52,010 --> 00:09:55,730
allows us to get to avoid certain

00:09:54,260 --> 00:09:58,220
deoptimization that you can see there's

00:09:55,730 --> 00:09:59,810
a big comment here here's another thing

00:09:58,220 --> 00:10:02,360
there's a function called in turn which

00:09:59,810 --> 00:10:04,069
takes a string and gets back an on rope

00:10:02,360 --> 00:10:04,670
version of the string and that ends up

00:10:04,069 --> 00:10:07,160
having

00:10:04,670 --> 00:10:08,300
performance problems to not do it and

00:10:07,160 --> 00:10:09,560
you can see on top it says when do I

00:10:08,300 --> 00:10:11,450
need this function for the most part

00:10:09,560 --> 00:10:14,870
never premature optimization is bad etc

00:10:11,450 --> 00:10:19,040
etc and here's the whole comment right

00:10:14,870 --> 00:10:20,870
so it turns out that when you care about

00:10:19,040 --> 00:10:21,980
performance we should think about what

00:10:20,870 --> 00:10:23,210
is the point of a programming language

00:10:21,980 --> 00:10:24,590
the point of a programming language is

00:10:23,210 --> 00:10:26,270
to let us communicate with other human

00:10:24,590 --> 00:10:28,520
beings about what it is that we're

00:10:26,270 --> 00:10:30,260
trying to do and if it turns out that

00:10:28,520 --> 00:10:31,130
you don't care about performance then

00:10:30,260 --> 00:10:32,510
you don't want to waste your time

00:10:31,130 --> 00:10:33,740
communicating with other human beings

00:10:32,510 --> 00:10:35,270
about performance that becomes a waste

00:10:33,740 --> 00:10:36,680
of time it becomes very noisy becomes

00:10:35,270 --> 00:10:39,260
difficult for you to understand what's

00:10:36,680 --> 00:10:41,900
going on in your code but as Dave Herman

00:10:39,260 --> 00:10:43,420
who founded mozilla research says when

00:10:41,900 --> 00:10:46,130
you actually do care about performance

00:10:43,420 --> 00:10:47,060
then performance is part of the domain

00:10:46,130 --> 00:10:48,680
of discourse for you and your

00:10:47,060 --> 00:10:50,270
collaborators you actually want away in

00:10:48,680 --> 00:10:51,230
the programming language to explain the

00:10:50,270 --> 00:10:55,640
performance requirements that you

00:10:51,230 --> 00:10:57,980
actually have so it is true that it

00:10:55,640 --> 00:10:59,930
often doesn't matter and I think what

00:10:57,980 --> 00:11:01,580
I'll say clearly here is if it doesn't

00:10:59,930 --> 00:11:02,840
matter than using a programming language

00:11:01,580 --> 00:11:04,340
like rust to solve that particular

00:11:02,840 --> 00:11:06,230
problem that you have is not gonna be

00:11:04,340 --> 00:11:08,390
the best use of your time because it's

00:11:06,230 --> 00:11:09,800
gonna end up forcing you to say a lot of

00:11:08,390 --> 00:11:10,970
things that you don't care about but

00:11:09,800 --> 00:11:12,440
there are many cases where it actually

00:11:10,970 --> 00:11:14,150
does matter where performance actually

00:11:12,440 --> 00:11:16,460
has a real impact remember usage has

00:11:14,150 --> 00:11:18,050
really impact like skylight which is the

00:11:16,460 --> 00:11:19,880
project I work on that caused me to get

00:11:18,050 --> 00:11:21,890
into rust in the first place and when it

00:11:19,880 --> 00:11:23,180
matters it's actually a blessing that

00:11:21,890 --> 00:11:24,710
you have it's not that I have to write

00:11:23,180 --> 00:11:26,960
all these annotations it's that I'm able

00:11:24,710 --> 00:11:28,100
to communicate to Carl and Tom and all

00:11:26,960 --> 00:11:29,780
the other programmers who I'm working

00:11:28,100 --> 00:11:31,370
with exactly what performance

00:11:29,780 --> 00:11:33,650
requirements we expect to have from the

00:11:31,370 --> 00:11:35,540
program that we're writing so that's why

00:11:33,650 --> 00:11:36,950
you should care about Rosten the kinds

00:11:35,540 --> 00:11:39,830
of cases you should care about now I

00:11:36,950 --> 00:11:42,290
want to get into sort of what is rust so

00:11:39,830 --> 00:11:44,300
I can spend a lot of time talking about

00:11:42,290 --> 00:11:45,710
the low-level performance I think you

00:11:44,300 --> 00:11:47,570
can write do some benchmarks if you want

00:11:45,710 --> 00:11:49,190
to look at sort of all the performance

00:11:47,570 --> 00:11:50,330
features I want to talk a little bit

00:11:49,190 --> 00:11:53,180
more because this is a ruby crowd about

00:11:50,330 --> 00:11:54,620
high-level productivity and before I

00:11:53,180 --> 00:11:56,360
talked about productivity I want to talk

00:11:54,620 --> 00:11:57,920
about one really important principle in

00:11:56,360 --> 00:11:59,540
rust which is the idea of zero cost

00:11:57,920 --> 00:12:02,660
abstraction which I know sounds a little

00:11:59,540 --> 00:12:04,430
bit like snake oil but the idea behind

00:12:02,660 --> 00:12:07,220
zero cost abstractions is that when you

00:12:04,430 --> 00:12:09,140
add the ability to do an abstraction in

00:12:07,220 --> 00:12:10,580
a programming language in most cases if

00:12:09,140 --> 00:12:11,930
you're not very careful you end up

00:12:10,580 --> 00:12:13,370
adding a little bit of cost a little bit

00:12:11,930 --> 00:12:14,500
of cost a little bit of cost and then

00:12:13,370 --> 00:12:17,300
when you get to something that's

00:12:14,500 --> 00:12:18,050
abstract as rails you end up with a lot

00:12:17,300 --> 00:12:20,600
of cost

00:12:18,050 --> 00:12:22,100
and the idea by us is to find

00:12:20,600 --> 00:12:23,510
abstractions that you can enable and

00:12:22,100 --> 00:12:24,649
I'll show you some examples of that in a

00:12:23,510 --> 00:12:27,260
minute

00:12:24,649 --> 00:12:28,670
but you can add with very little or zero

00:12:27,260 --> 00:12:30,200
cost and what that means is that you can

00:12:28,670 --> 00:12:31,250
get pretty abstract in terms of the

00:12:30,200 --> 00:12:33,050
programs that you're able to write

00:12:31,250 --> 00:12:34,880
without it introducing a whole lot of

00:12:33,050 --> 00:12:36,500
cost and I think this is a big part of

00:12:34,880 --> 00:12:38,209
what is really appealing to me about

00:12:36,500 --> 00:12:40,730
rust which is that even if we didn't

00:12:38,209 --> 00:12:42,380
consider the safety aspects of writing

00:12:40,730 --> 00:12:44,570
in a programming language like C and of

00:12:42,380 --> 00:12:46,730
course I do the fact that C is so

00:12:44,570 --> 00:12:50,120
difficult to have to write abstractions

00:12:46,730 --> 00:12:52,040
in is really also a big problem so I'm

00:12:50,120 --> 00:12:54,019
gonna start by looking at some a program

00:12:52,040 --> 00:12:56,329
in Ruby that you can look at if you go

00:12:54,019 --> 00:12:59,269
to active support and that's the blank

00:12:56,329 --> 00:13:00,649
method that exists on strings in Ruby so

00:12:59,269 --> 00:13:02,240
here's how its implemented I just

00:13:00,649 --> 00:13:04,459
dragged this out of active support that

00:13:02,240 --> 00:13:06,380
you reopen the string class you specify

00:13:04,459 --> 00:13:08,240
blank regex and that's there because

00:13:06,380 --> 00:13:10,839
performance reasons you don't want to be

00:13:08,240 --> 00:13:13,100
putting it in line and then you

00:13:10,839 --> 00:13:15,350
investigate the blank regex at runtime

00:13:13,100 --> 00:13:17,660
and then similarly we have this method

00:13:15,350 --> 00:13:20,000
on array which is basically an alias for

00:13:17,660 --> 00:13:21,620
empty and then we have nil class no

00:13:20,000 --> 00:13:23,300
class is always considered blank and

00:13:21,620 --> 00:13:25,970
then you know there's more and more

00:13:23,300 --> 00:13:27,920
there's bullying's and whatever and this

00:13:25,970 --> 00:13:29,209
exact kind of problem this exact kind of

00:13:27,920 --> 00:13:31,010
thing is actually something that rust

00:13:29,209 --> 00:13:32,570
lets you talk about and I'll talk I'll

00:13:31,010 --> 00:13:34,970
show you how that works in Russ so in

00:13:32,570 --> 00:13:36,529
Ruby actually the one I showed you here

00:13:34,970 --> 00:13:38,570
is sort of traditionally how you would

00:13:36,529 --> 00:13:39,860
do it and that basically globally opens

00:13:38,570 --> 00:13:41,329
up all these objects and as the blank

00:13:39,860 --> 00:13:43,579
method there's also a new feature in

00:13:41,329 --> 00:13:44,899
Ruby called refinements which allows you

00:13:43,579 --> 00:13:46,970
to do a similar thing but in a scoped

00:13:44,899 --> 00:13:50,300
way and that's more like how it works in

00:13:46,970 --> 00:13:51,920
rust so first of all in rust when you

00:13:50,300 --> 00:13:53,300
everything statically typed so if you

00:13:51,920 --> 00:13:54,829
want to say that there's a blank method

00:13:53,300 --> 00:13:57,170
you say that there's a trait called is

00:13:54,829 --> 00:13:59,300
blank and we just make a trait called is

00:13:57,170 --> 00:14:01,760
blank and we say that has a function on

00:13:59,300 --> 00:14:03,260
it that function takes whatever you know

00:14:01,760 --> 00:14:05,120
self whatever it is and it returns a

00:14:03,260 --> 00:14:08,060
boolean and the first thing that we do

00:14:05,120 --> 00:14:09,800
is we implement is blank for Strings and

00:14:08,060 --> 00:14:11,690
that ampersand string thing over there

00:14:09,800 --> 00:14:13,640
just means that it's a static fixed

00:14:11,690 --> 00:14:14,810
sized string so there's also strings

00:14:13,640 --> 00:14:16,699
that you could push things on to

00:14:14,810 --> 00:14:19,490
basically mutable strings this is that

00:14:16,699 --> 00:14:22,970
symbol there means immutable string that

00:14:19,490 --> 00:14:25,850
guy over there and this reg x over here

00:14:22,970 --> 00:14:27,050
basically is a macro so anything with

00:14:25,850 --> 00:14:29,720
bang at the end of it which is gonna

00:14:27,050 --> 00:14:31,570
change to prefix and act soon but

00:14:29,720 --> 00:14:33,280
anything with a bang means

00:14:31,570 --> 00:14:36,550
macro and that means basically that it

00:14:33,280 --> 00:14:37,960
gets converted into something fast so

00:14:36,550 --> 00:14:39,700
even though it's a red X it's not

00:14:37,960 --> 00:14:43,180
doesn't end up being interpreted every

00:14:39,700 --> 00:14:44,770
time and basically what this is doing is

00:14:43,180 --> 00:14:46,450
essentially equivalent thing that we did

00:14:44,770 --> 00:14:49,660
in Ruby we basically say we have this is

00:14:46,450 --> 00:14:51,220
blank trait and it hasn't his bike

00:14:49,660 --> 00:14:54,940
method and if it's a boolean and here is

00:14:51,220 --> 00:14:56,560
the implementation of it you can do

00:14:54,940 --> 00:14:58,300
similar things for other types so we've

00:14:56,560 --> 00:15:00,550
now said I want to implement is blank

00:14:58,300 --> 00:15:03,070
for a raise this that basically also

00:15:00,550 --> 00:15:04,180
means a fixed sized array this little

00:15:03,070 --> 00:15:06,490
thing here if you're not familiar with

00:15:04,180 --> 00:15:08,200
other languages that have types is

00:15:06,490 --> 00:15:11,350
called a generic so this is basically

00:15:08,200 --> 00:15:12,970
saying this is implemented for an array

00:15:11,350 --> 00:15:14,350
of any type so it doesn't matter what

00:15:12,970 --> 00:15:16,360
type it is as long as it's an array of

00:15:14,350 --> 00:15:17,440
that type it's what this means over here

00:15:16,360 --> 00:15:19,720
it's an array of that type it's

00:15:17,440 --> 00:15:21,130
implemented and then the actual

00:15:19,720 --> 00:15:22,540
implementation just says check the

00:15:21,130 --> 00:15:36,400
length if the length is bigger than zero

00:15:22,540 --> 00:15:38,350
actually that should be equal zero so if

00:15:36,400 --> 00:15:40,870
the length is zero its blank and then we

00:15:38,350 --> 00:15:43,000
do a similar so rust also has no null so

00:15:40,870 --> 00:15:45,270
null is always represented as a type of

00:15:43,000 --> 00:15:48,160
option so here we're gonna say implement

00:15:45,270 --> 00:15:49,300
is blank for an option of anything and

00:15:48,160 --> 00:15:51,130
the option of anything is basically

00:15:49,300 --> 00:15:53,230
saying okay if it's none which is like

00:15:51,130 --> 00:15:56,230
the nil question mark method in Ruby so

00:15:53,230 --> 00:15:58,000
and then finally implement the same

00:15:56,230 --> 00:15:59,710
thing for bool right so basically in

00:15:58,000 --> 00:16:03,760
this in the same way that you can go

00:15:59,710 --> 00:16:05,950
ahead and and implement things in Ruby

00:16:03,760 --> 00:16:07,780
for any any type even at types you don't

00:16:05,950 --> 00:16:08,950
own you can basically make a trait in

00:16:07,780 --> 00:16:10,990
rust and you can implement it for any

00:16:08,950 --> 00:16:12,520
type and the way that that gets used as

00:16:10,990 --> 00:16:14,440
you would say something like in use

00:16:12,520 --> 00:16:16,570
activesupport colon colon is blank and

00:16:14,440 --> 00:16:18,250
then you would be able to use it so that

00:16:16,570 --> 00:16:19,690
is the scoping mechanism you have to say

00:16:18,250 --> 00:16:20,890
where you want to use it but once you've

00:16:19,690 --> 00:16:22,810
said that you want to use a trait it's

00:16:20,890 --> 00:16:24,820
now imported into that scope and you can

00:16:22,810 --> 00:16:26,350
use it for any method any day object so

00:16:24,820 --> 00:16:27,970
any object that's implemented for so we

00:16:26,350 --> 00:16:31,360
can implement it for use of restraint

00:16:27,970 --> 00:16:33,280
for you know arrays for boolean x' and

00:16:31,360 --> 00:16:34,600
then the last one there is I made an

00:16:33,280 --> 00:16:36,880
array of 1 and I pulled out the last

00:16:34,600 --> 00:16:39,000
value of it and in rust that would

00:16:36,880 --> 00:16:41,230
return an option cuz it could be nil and

00:16:39,000 --> 00:16:42,880
like I said before I implemented this

00:16:41,230 --> 00:16:44,470
four options so basically it works for

00:16:42,880 --> 00:16:46,360
all these different types and one really

00:16:44,470 --> 00:16:48,010
cool thing about rust traits actually is

00:16:46,360 --> 00:16:50,680
that if you make your own type so if I

00:16:48,010 --> 00:16:52,360
make my own type in my own library and I

00:16:50,680 --> 00:16:53,980
want to implement is blank I can

00:16:52,360 --> 00:16:56,350
actually implement it just fine which

00:16:53,980 --> 00:16:57,550
means that just like in Ruby you know

00:16:56,350 --> 00:16:58,810
the blank you just have to implement the

00:16:57,550 --> 00:17:00,700
blank question mark method and it will

00:16:58,810 --> 00:17:02,860
work if I make my own type and I want it

00:17:00,700 --> 00:17:04,209
to be compatible with this trait I can

00:17:02,860 --> 00:17:05,740
implement it myself it doesn't have to

00:17:04,209 --> 00:17:07,089
be something that something the person

00:17:05,740 --> 00:17:10,060
implemented the trait decided to

00:17:07,089 --> 00:17:11,260
implement in the first place and so I

00:17:10,060 --> 00:17:14,110
just showed you a pretty cool feature

00:17:11,260 --> 00:17:16,870
which is basically it looks like oh you

00:17:14,110 --> 00:17:19,360
know dynamic dispatch awesome everything

00:17:16,870 --> 00:17:20,829
is a message etc but like I said before

00:17:19,360 --> 00:17:21,970
in rust everything is a zero cost

00:17:20,829 --> 00:17:24,699
abstraction so how does that actually

00:17:21,970 --> 00:17:26,980
work and the way it works in rust is

00:17:24,699 --> 00:17:29,440
that rust actually knows when it looks

00:17:26,980 --> 00:17:31,630
at those when it looks at empty string

00:17:29,440 --> 00:17:33,250
blank that is blank it actually knows

00:17:31,630 --> 00:17:35,160
ahead of time exactly what method that's

00:17:33,250 --> 00:17:37,360
gonna be calling and it actually will

00:17:35,160 --> 00:17:39,310
statically dispatch that method to the

00:17:37,360 --> 00:17:41,230
that method to the specific function

00:17:39,310 --> 00:17:41,740
that needs to be called or it might even

00:17:41,230 --> 00:17:43,420
in line

00:17:41,740 --> 00:17:44,730
and you can explicitly tell to inline it

00:17:43,420 --> 00:17:46,870
if you know it's performance critical

00:17:44,730 --> 00:17:49,090
also using traits doesn't involve

00:17:46,870 --> 00:17:50,260
allocating anything so even though in a

00:17:49,090 --> 00:17:51,490
you know normal language you would

00:17:50,260 --> 00:17:53,470
basically be forced to allocate because

00:17:51,490 --> 00:17:56,559
it's virtual dispatch e the dispatching

00:17:53,470 --> 00:17:57,910
table in rust simply using a trade

00:17:56,559 --> 00:18:01,630
doesn't cause any kind of special

00:17:57,910 --> 00:18:03,100
allocations it basically works just it

00:18:01,630 --> 00:18:04,660
works fast it's like as if you had

00:18:03,100 --> 00:18:06,790
written a static method and called it

00:18:04,660 --> 00:18:09,940
directly even though now it's basically

00:18:06,790 --> 00:18:11,050
polymorphic now there's one other thing

00:18:09,940 --> 00:18:12,880
that you can do with traits that's

00:18:11,050 --> 00:18:14,170
pretty awesome so so far I showed you

00:18:12,880 --> 00:18:15,520
that you have a you know you have an

00:18:14,170 --> 00:18:17,470
object and you want to call a method on

00:18:15,520 --> 00:18:21,010
it and you can it can be polymorphic

00:18:17,470 --> 00:18:22,090
right and now I'm gonna show you what if

00:18:21,010 --> 00:18:24,370
I want to make a method and that method

00:18:22,090 --> 00:18:25,660
will take something that is that

00:18:24,370 --> 00:18:27,220
implements a particular trait so in this

00:18:25,660 --> 00:18:29,140
case I have a method called a function

00:18:27,220 --> 00:18:30,910
called first line and that first line

00:18:29,140 --> 00:18:33,670
function is just gonna call read line on

00:18:30,910 --> 00:18:34,870
whatever reader I give it now obviously

00:18:33,670 --> 00:18:36,880
I could write a first line function and

00:18:34,870 --> 00:18:38,830
I could make it specific for standard in

00:18:36,880 --> 00:18:40,720
or I could make it specific for a file

00:18:38,830 --> 00:18:42,460
but what I want to do is I want to make

00:18:40,720 --> 00:18:46,150
a function that's specific to any kind

00:18:42,460 --> 00:18:47,440
of bufferedreader and in Ruby of course

00:18:46,150 --> 00:18:49,150
you just do this by saying please

00:18:47,440 --> 00:18:52,110
implement the read line method and I'll

00:18:49,150 --> 00:18:54,160
call it in rust you say I'm gonna take

00:18:52,110 --> 00:18:56,440
you say this thing here which means I'm

00:18:54,160 --> 00:18:58,660
gonna take its generic over any type R

00:18:56,440 --> 00:19:00,070
as long as that type implements buffer

00:18:58,660 --> 00:19:03,010
and buffer is the thing that implements

00:19:00,070 --> 00:19:04,809
the read line method and then here I'm

00:19:03,010 --> 00:19:08,830
basically saying I'm taking a mutable

00:19:04,809 --> 00:19:11,790
reader of that type and then sorry and

00:19:08,830 --> 00:19:15,450
then when I go to call it basically

00:19:11,790 --> 00:19:15,450
actually that's another mistake

00:19:22,440 --> 00:19:26,610
okay so then when I go to call it

00:19:24,090 --> 00:19:27,840
basically Rasta will mow okay well

00:19:26,610 --> 00:19:28,890
you're calling first line and you can

00:19:27,840 --> 00:19:30,180
basically call it with a bufferedreader

00:19:28,890 --> 00:19:32,400
or you can call it standard in or

00:19:30,180 --> 00:19:33,630
whatever type that you want and again if

00:19:32,400 --> 00:19:35,580
you just look at this you could imagine

00:19:33,630 --> 00:19:37,250
well I'm calling it with some random

00:19:35,580 --> 00:19:39,570
thing and it doesn't know ahead of time

00:19:37,250 --> 00:19:41,580
it's like the function is not written

00:19:39,570 --> 00:19:43,170
for a specific type so probably what

00:19:41,580 --> 00:19:45,090
that means is that it will be super slow

00:19:43,170 --> 00:19:47,790
because it will have to be packaged up

00:19:45,090 --> 00:19:49,320
it will have to come with maybe a lookup

00:19:47,790 --> 00:19:50,190
table and then it will have to get sent

00:19:49,320 --> 00:19:52,110
and then it'll have to be virtually

00:19:50,190 --> 00:19:53,880
dispatched but actually what happens in

00:19:52,110 --> 00:19:56,010
practice and rust is that it's super

00:19:53,880 --> 00:19:57,180
fast and the reason it's super fast is

00:19:56,010 --> 00:19:59,820
that every single time you call that

00:19:57,180 --> 00:20:00,810
function it will basically say okay

00:19:59,820 --> 00:20:02,160
you're calling that function with the

00:20:00,810 --> 00:20:03,750
bufferedreader I'm gonna go make a

00:20:02,160 --> 00:20:05,640
special version of that first line

00:20:03,750 --> 00:20:07,830
function for bufferedreader and I'm

00:20:05,640 --> 00:20:09,960
gonna use that at compile time and what

00:20:07,830 --> 00:20:12,330
that means is that the actual all the

00:20:09,960 --> 00:20:14,640
lookups at runtime are static are known

00:20:12,330 --> 00:20:16,650
ahead of time and again when I call

00:20:14,640 --> 00:20:18,570
standard IO standard in and I call the

00:20:16,650 --> 00:20:20,400
same function first line it's basically

00:20:18,570 --> 00:20:22,080
as if I had called this special first

00:20:20,400 --> 00:20:24,000
line to function that was I was set up

00:20:22,080 --> 00:20:27,030
so the idea is that you get the high

00:20:24,000 --> 00:20:28,470
level the high level functionality that

00:20:27,030 --> 00:20:29,550
you expect the productivity that you

00:20:28,470 --> 00:20:30,810
expect for being able to just say I

00:20:29,550 --> 00:20:32,430
don't really care what this is it's just

00:20:30,810 --> 00:20:34,410
anything that takes a reader I'll just

00:20:32,430 --> 00:20:35,850
call read line on it and under the hood

00:20:34,410 --> 00:20:39,240
what's happening is it gets specialized

00:20:35,850 --> 00:20:40,530
it gets made super fast so another way

00:20:39,240 --> 00:20:42,360
that this is zero cost is that the

00:20:40,530 --> 00:20:43,920
compiler specializes any methods that

00:20:42,360 --> 00:20:46,590
use trained what we've got what we call

00:20:43,920 --> 00:20:48,420
trait constraints so that's pretty

00:20:46,590 --> 00:20:50,550
awesome and I think it's a good example

00:20:48,420 --> 00:20:53,580
of something where you can get a pretty

00:20:50,550 --> 00:20:56,310
high level of productivity in even above

00:20:53,580 --> 00:20:58,380
what most dynamic line at ik languages

00:20:56,310 --> 00:20:59,670
let you get at a performance level

00:20:58,380 --> 00:21:03,530
that's much higher than what most static

00:20:59,670 --> 00:21:05,820
languages let you get so that's traits

00:21:03,530 --> 00:21:07,320
the next thing I want to talk about is

00:21:05,820 --> 00:21:09,180
iterators and lambdas so if you've

00:21:07,320 --> 00:21:11,250
written Ruby code or JavaScript code

00:21:09,180 --> 00:21:13,680
then what you know is that it's very

00:21:11,250 --> 00:21:17,160
powerful to be able to use blocks or

00:21:13,680 --> 00:21:21,390
lambdas to abstract over some kinds of

00:21:17,160 --> 00:21:22,950
things and rust has a thing called has

00:21:21,390 --> 00:21:24,540
lambdas but it also has a feature called

00:21:22,950 --> 00:21:26,460
iterators which are you can basically

00:21:24,540 --> 00:21:28,470
think of as being the equivalent of lazy

00:21:26,460 --> 00:21:29,910
enumerators in Ruby and basically the

00:21:28,470 --> 00:21:32,190
idea here is that you can base to say

00:21:29,910 --> 00:21:34,200
okay give me a range from 0 to 100 and

00:21:32,190 --> 00:21:36,120
then I'm gonna filter over it by saying

00:21:34,200 --> 00:21:37,680
it's filtered by you know is it

00:21:36,120 --> 00:21:39,030
visible by six and then I'm gonna map if

00:21:37,680 --> 00:21:41,460
I'm multiplying by three and then I'm

00:21:39,030 --> 00:21:46,560
gonna print it by saying numero whatever

00:21:41,460 --> 00:21:48,260
and then run it and there's so number

00:21:46,560 --> 00:21:50,880
one if you look at this it looks very

00:21:48,260 --> 00:21:52,200
high-level II it looks first of all

00:21:50,880 --> 00:21:54,660
there's no types which is pretty cool

00:21:52,200 --> 00:21:56,130
but second of all looks high-level looks

00:21:54,660 --> 00:21:59,040
you know you're using filter and map and

00:21:56,130 --> 00:22:00,630
all this stuff but again you sort of get

00:21:59,040 --> 00:22:03,300
this zero cost abstraction thing going

00:22:00,630 --> 00:22:04,650
on you get so first of all iterators are

00:22:03,300 --> 00:22:06,060
always lazy which means there's never

00:22:04,650 --> 00:22:08,810
any intermediate objects that get

00:22:06,060 --> 00:22:11,310
created but unlike in Ruby that doesn't

00:22:08,810 --> 00:22:14,430
produce any additional allocations this

00:22:11,310 --> 00:22:16,140
is basically all done locally it also

00:22:14,430 --> 00:22:17,460
uses generics under the hood like I

00:22:16,140 --> 00:22:18,990
showed you before which basically means

00:22:17,460 --> 00:22:21,000
that every single time you call that map

00:22:18,990 --> 00:22:22,290
or dot filter it's actually generating a

00:22:21,000 --> 00:22:24,170
special version of the code for the

00:22:22,290 --> 00:22:26,430
thing that you're actually trying to do

00:22:24,170 --> 00:22:27,870
also so one thing that you have to do

00:22:26,430 --> 00:22:29,970
whenever you're doing a loop in a

00:22:27,870 --> 00:22:31,500
high-level language if you want to look

00:22:29,970 --> 00:22:33,270
up you have an array of 100 items and

00:22:31,500 --> 00:22:36,930
you say give me the 50th item is that

00:22:33,270 --> 00:22:38,580
the at best the compiler has to say let

00:22:36,930 --> 00:22:40,470
me check to see if the 50th item is

00:22:38,580 --> 00:22:41,400
there and don't let you access memory

00:22:40,470 --> 00:22:44,250
that's out of the bounds of the array

00:22:41,400 --> 00:22:45,870
but if you use something like math not

00:22:44,250 --> 00:22:48,360
only is it a higher level of abstraction

00:22:45,870 --> 00:22:49,710
you're using a lambda but you could

00:22:48,360 --> 00:22:51,210
actually do a single bounce jack and say

00:22:49,710 --> 00:22:52,650
okay I can see these 50 items so then

00:22:51,210 --> 00:22:54,420
you can basically just do the rest of

00:22:52,650 --> 00:22:55,980
the iteration without doing any

00:22:54,420 --> 00:22:57,810
additional bounce checks as you go

00:22:55,980 --> 00:22:59,700
through it so you can get both higher

00:22:57,810 --> 00:23:00,960
level of abstraction and faster

00:22:59,700 --> 00:23:01,500
performance at the same time which is

00:23:00,960 --> 00:23:04,440
pretty awesome

00:23:01,500 --> 00:23:06,210
and finally rust actually doesn't have

00:23:04,440 --> 00:23:09,660
any C style for loops it only has

00:23:06,210 --> 00:23:12,050
looping over it it has a raw loop but

00:23:09,660 --> 00:23:14,400
other than that it only has looping over

00:23:12,050 --> 00:23:15,660
iterators and that's because rust itself

00:23:14,400 --> 00:23:18,000
is very very confident in the

00:23:15,660 --> 00:23:20,460
performance of iterators and the ability

00:23:18,000 --> 00:23:23,730
to make those very fast and an efficient

00:23:20,460 --> 00:23:24,840
and low memory usage so I talked so

00:23:23,730 --> 00:23:26,580
those are sort of two high level

00:23:24,840 --> 00:23:28,050
features and I think you can definitely

00:23:26,580 --> 00:23:29,310
see that if you look at these features

00:23:28,050 --> 00:23:31,410
that they're features that you would

00:23:29,310 --> 00:23:33,270
expect to have in a productive language

00:23:31,410 --> 00:23:37,680
but not necessarily in a low-level

00:23:33,270 --> 00:23:41,070
language so I talked about the fact that

00:23:37,680 --> 00:23:42,840
this is if this is productive but

00:23:41,070 --> 00:23:44,130
earlier I said that rust is sort of

00:23:42,840 --> 00:23:46,980
unique in the in the sense that it gives

00:23:44,130 --> 00:23:50,070
you something that's both fast but also

00:23:46,980 --> 00:23:54,180
safe unlike a lot C or C++ which gives

00:23:50,070 --> 00:23:56,070
you fast but not safe and so far all the

00:23:54,180 --> 00:23:57,810
things that I showed you you sort of

00:23:56,070 --> 00:23:59,310
come to expect from languages that are

00:23:57,810 --> 00:24:01,350
managed that are have a garbage

00:23:59,310 --> 00:24:02,940
collector don't necessarily come to

00:24:01,350 --> 00:24:04,290
expect from a low-level language and

00:24:02,940 --> 00:24:05,430
there's a reason for that which is that

00:24:04,290 --> 00:24:07,050
it's a little bit tricky to do and I

00:24:05,430 --> 00:24:08,700
want to show you I don't want to get too

00:24:07,050 --> 00:24:10,500
much into the details here but I want to

00:24:08,700 --> 00:24:12,780
show you one kind of example that I

00:24:10,500 --> 00:24:14,430
think may help you understand number one

00:24:12,780 --> 00:24:16,950
what's tricky and number two how Russ

00:24:14,430 --> 00:24:19,950
deals with it so I made a little program

00:24:16,950 --> 00:24:22,230
here which is a ruby program it has a

00:24:19,950 --> 00:24:24,360
point it inherits from structure the XY

00:24:22,230 --> 00:24:26,850
make a line the line has length method

00:24:24,360 --> 00:24:29,160
on it and the length is just figuring

00:24:26,850 --> 00:24:31,110
out the length of distance between two

00:24:29,160 --> 00:24:33,240
points I made a distance method which

00:24:31,110 --> 00:24:35,310
takes two points makes a new line p1 and

00:24:33,240 --> 00:24:36,930
p2 gets the length and then my count

00:24:35,310 --> 00:24:38,730
method basically I have a count function

00:24:36,930 --> 00:24:40,770
which is sort of like main function here

00:24:38,730 --> 00:24:43,200
which basically will go get the distance

00:24:40,770 --> 00:24:45,450
and it will return the right value now

00:24:43,200 --> 00:24:47,490
let me sort of trace through the program

00:24:45,450 --> 00:24:48,750
what exactly is happening here so the

00:24:47,490 --> 00:24:51,780
first thing that happens is I make a new

00:24:48,750 --> 00:24:53,520
point and because this is a garbage

00:24:51,780 --> 00:24:55,740
collected language because it's trying

00:24:53,520 --> 00:24:56,730
to be safe and Ruby doesn't really know

00:24:55,740 --> 00:24:58,350
what else is gonna happen with this

00:24:56,730 --> 00:25:00,060
point afterwards it's basically forced

00:24:58,350 --> 00:25:01,440
to allocate that point on the heap it's

00:25:00,060 --> 00:25:02,850
basically forced to make an actual

00:25:01,440 --> 00:25:04,110
object and allocate it and put it

00:25:02,850 --> 00:25:05,310
somewhere else because it doesn't know

00:25:04,110 --> 00:25:07,200
what else might happen with this point

00:25:05,310 --> 00:25:09,330
in the future so I go and I make a

00:25:07,200 --> 00:25:11,160
second point now the next thing I do is

00:25:09,330 --> 00:25:12,840
I call the distance function and the

00:25:11,160 --> 00:25:14,340
distance function also makes a line

00:25:12,840 --> 00:25:15,660
object and again because the Ruby

00:25:14,340 --> 00:25:17,250
doesn't really know what's gonna happen

00:25:15,660 --> 00:25:19,190
with the line object it has to go and

00:25:17,250 --> 00:25:21,690
put a line somewhere on the heap and

00:25:19,190 --> 00:25:23,430
then it goes and calls the length method

00:25:21,690 --> 00:25:24,750
on the line and the length method

00:25:23,430 --> 00:25:25,860
actually starts pulling things off of

00:25:24,750 --> 00:25:27,810
the point which is actually super

00:25:25,860 --> 00:25:29,280
dangerous if you weren't garbage

00:25:27,810 --> 00:25:30,690
collected right because now we're just

00:25:29,280 --> 00:25:32,790
pulling random things off of this object

00:25:30,690 --> 00:25:34,350
so we're really happy that these things

00:25:32,790 --> 00:25:35,490
are allocated on the heap because if

00:25:34,350 --> 00:25:37,890
they weren't allocated on the heap if

00:25:35,490 --> 00:25:39,300
they were basically if they were managed

00:25:37,890 --> 00:25:40,860
manually if you were basically

00:25:39,300 --> 00:25:42,510
allocating them and freeing them and you

00:25:40,860 --> 00:25:43,770
start pulling random things off who

00:25:42,510 --> 00:25:45,810
knows what could happen so we basically

00:25:43,770 --> 00:25:48,600
go and we pull a few things off we do

00:25:45,810 --> 00:25:49,620
some calculations then we call the

00:25:48,600 --> 00:25:51,150
square root function which is get

00:25:49,620 --> 00:25:55,200
another function we give it the values

00:25:51,150 --> 00:25:58,140
that we gave it and then we return sorry

00:25:55,200 --> 00:25:59,490
and then we return and what's kind of

00:25:58,140 --> 00:26:01,620
interesting about this is that I sort of

00:25:59,490 --> 00:26:03,240
told you a story of it being somewhat

00:26:01,620 --> 00:26:04,350
unclear about what's going on like what

00:26:03,240 --> 00:26:05,370
this point object what is this flying

00:26:04,350 --> 00:26:07,110
object I don't really know what's

00:26:05,370 --> 00:26:09,030
happening here but what's kind of

00:26:07,110 --> 00:26:10,920
interesting is that most programs

00:26:09,030 --> 00:26:13,170
actually are written in this way in

00:26:10,920 --> 00:26:15,059
which even though in theory the point

00:26:13,170 --> 00:26:16,800
object isn't sort of known what it's

00:26:15,059 --> 00:26:18,120
doing in practice it's being created

00:26:16,800 --> 00:26:19,559
it's getting past a bunch of functions

00:26:18,120 --> 00:26:21,000
then it's getting returned and then

00:26:19,559 --> 00:26:22,440
we're done with it right so in practice

00:26:21,000 --> 00:26:24,150
what's happening is that we're creating

00:26:22,440 --> 00:26:26,130
objects they basically get used in

00:26:24,150 --> 00:26:27,750
computation they get returned right away

00:26:26,130 --> 00:26:29,400
nobody hangs on to them people aren't

00:26:27,750 --> 00:26:31,590
making threads and storing them off or

00:26:29,400 --> 00:26:34,260
putting them in other structures right

00:26:31,590 --> 00:26:36,300
and what and this ends up meaning is

00:26:34,260 --> 00:26:37,470
that even though in theory this is all

00:26:36,300 --> 00:26:39,420
very simple and you can sort of

00:26:37,470 --> 00:26:41,250
understand statically okay I can just

00:26:39,420 --> 00:26:43,140
put the memory in some known location

00:26:41,250 --> 00:26:45,960
pass it around get it back everything's

00:26:43,140 --> 00:26:47,340
great because of the fact that Ruby

00:26:45,960 --> 00:26:49,260
doesn't really know it ends up being

00:26:47,340 --> 00:26:52,559
forced to go and do a lot of extra

00:26:49,260 --> 00:26:53,790
memory work to deal with the fact that

00:26:52,559 --> 00:26:55,470
doesn't really know what's going on so

00:26:53,790 --> 00:27:00,960
let's look at the equivalent program let

00:26:55,470 --> 00:27:02,400
me zoom through that sorry so let's look

00:27:00,960 --> 00:27:03,630
at the equivalent program in rust and

00:27:02,400 --> 00:27:05,850
the first thing that you should note is

00:27:03,630 --> 00:27:07,470
that it's not that many more lines right

00:27:05,850 --> 00:27:08,670
sort of equivalently sized there's more

00:27:07,470 --> 00:27:11,429
types obviously involved so it's a

00:27:08,670 --> 00:27:12,660
little denser but there's a little bit

00:27:11,429 --> 00:27:14,309
of a different thing going on here so

00:27:12,660 --> 00:27:16,950
first of all when we say point over here

00:27:14,309 --> 00:27:18,120
in rust when you say it this way when

00:27:16,950 --> 00:27:20,100
you don't explicitly allocated what

00:27:18,120 --> 00:27:22,110
you're saying is I would like the point

00:27:20,100 --> 00:27:23,460
to actually be allocated in a known

00:27:22,110 --> 00:27:25,410
fixed location that doesn't have to be

00:27:23,460 --> 00:27:27,300
allocated and you have to do extra work

00:27:25,410 --> 00:27:29,010
to make it be allocated somewhere else

00:27:27,300 --> 00:27:30,390
so you make these two points and then

00:27:29,010 --> 00:27:31,679
you call this other function and the

00:27:30,390 --> 00:27:34,830
other function also gets these two

00:27:31,679 --> 00:27:37,130
points and the way that it received them

00:27:34,830 --> 00:27:39,480
is basically by moving them into this

00:27:37,130 --> 00:27:43,740
into this function so this function is

00:27:39,480 --> 00:27:45,120
now the owner of these points and what

00:27:43,740 --> 00:27:47,460
it does with those points is it makes a

00:27:45,120 --> 00:27:49,200
line and it's basically takes the points

00:27:47,460 --> 00:27:51,330
puts them into a line and it's basically

00:27:49,200 --> 00:27:53,040
now created this new object and again

00:27:51,330 --> 00:27:54,300
because it because I didn't explicitly

00:27:53,040 --> 00:27:54,950
say that I want to allocate this

00:27:54,300 --> 00:27:57,720
somewhere else

00:27:54,950 --> 00:28:00,360
now it gets allocated in a fixed loan

00:27:57,720 --> 00:28:02,190
location and when I call the length

00:28:00,360 --> 00:28:03,929
function the length function is getting

00:28:02,190 --> 00:28:05,220
called and actually you might notice

00:28:03,929 --> 00:28:07,050
something interesting here which is this

00:28:05,220 --> 00:28:10,140
ampersand before itself and what the

00:28:07,050 --> 00:28:12,300
ampersand means is just what it means

00:28:10,140 --> 00:28:14,220
something very simple which is you can

00:28:12,300 --> 00:28:15,600
you can use itself but you can't hang on

00:28:14,220 --> 00:28:16,450
to it you're not allowed to go make a

00:28:15,600 --> 00:28:17,470
thread

00:28:16,450 --> 00:28:18,670
move it somewhere else you're not

00:28:17,470 --> 00:28:21,580
allowed to do something that would cause

00:28:18,670 --> 00:28:23,560
this reference of this line to outlive

00:28:21,580 --> 00:28:24,730
this function call so this is something

00:28:23,560 --> 00:28:26,800
that you don't get the same Ruby you

00:28:24,730 --> 00:28:28,300
don't get to say this line cannot

00:28:26,800 --> 00:28:30,520
outlive this function call but if you do

00:28:28,300 --> 00:28:32,290
get to say it now you know for sure what

00:28:30,520 --> 00:28:35,020
exactly is happening with it so then you

00:28:32,290 --> 00:28:36,700
do all the same sorry then you do all

00:28:35,020 --> 00:28:38,470
the same amount of work but when you

00:28:36,700 --> 00:28:41,170
return from the length function you're

00:28:38,470 --> 00:28:43,240
actually confident that that line hasn't

00:28:41,170 --> 00:28:44,770
disappeared which means that the

00:28:43,240 --> 00:28:47,650
compiler can look at this whole program

00:28:44,770 --> 00:28:48,910
and it can say okay I know well it

00:28:47,650 --> 00:28:50,110
doesn't have to just say I know that I

00:28:48,910 --> 00:28:51,760
don't I don't have to allocate anything

00:28:50,110 --> 00:28:53,200
we as a programmer have told Ross

00:28:51,760 --> 00:28:55,540
exactly where it should allocate

00:28:53,200 --> 00:28:58,060
everything and so that's that's fine

00:28:55,540 --> 00:29:01,090
that I think you can sort of understand

00:28:58,060 --> 00:29:02,920
how that could work but what but you're

00:29:01,090 --> 00:29:04,180
probably thinking okay well you can do

00:29:02,920 --> 00:29:06,790
that but what if you actually make

00:29:04,180 --> 00:29:08,230
mistakes like what if you need to hold

00:29:06,790 --> 00:29:10,720
something for the long longer than the

00:29:08,230 --> 00:29:12,990
size of the stack and let me look at a

00:29:10,720 --> 00:29:16,000
really simple function here which is the

00:29:12,990 --> 00:29:18,280
function which opens a new file from a

00:29:16,000 --> 00:29:19,750
particular path and prints it and I'll

00:29:18,280 --> 00:29:21,510
just sort of walk through how this works

00:29:19,750 --> 00:29:23,680
this is a more complicated example and

00:29:21,510 --> 00:29:26,950
so what happens is we make a new file

00:29:23,680 --> 00:29:29,530
and what we do in the same function is

00:29:26,950 --> 00:29:30,820
we read from the file and again remember

00:29:29,530 --> 00:29:32,260
what I said before which is that in rust

00:29:30,820 --> 00:29:33,850
if you don't say something specific and

00:29:32,260 --> 00:29:35,830
this thing that you say specific is box

00:29:33,850 --> 00:29:37,420
which basically means put this box this

00:29:35,830 --> 00:29:38,650
up and put it somewhere else if you

00:29:37,420 --> 00:29:40,000
don't say that it's always allocating

00:29:38,650 --> 00:29:42,610
things on the stack so basically what we

00:29:40,000 --> 00:29:45,520
said is open this new file allocate it

00:29:42,610 --> 00:29:48,190
here and then we go print you know print

00:29:45,520 --> 00:29:49,780
line that says go read some stuff from a

00:29:48,190 --> 00:29:51,370
file and don't worry about errors that's

00:29:49,780 --> 00:29:52,780
what unwrap means and then when we get

00:29:51,370 --> 00:29:54,430
to the end of this function it's

00:29:52,780 --> 00:29:56,110
basically going to go close the file

00:29:54,430 --> 00:29:58,990
automatically because it knows that only

00:29:56,110 --> 00:30:02,500
one thing has access to at a time so

00:29:58,990 --> 00:30:03,970
that works fine and as expected and you

00:30:02,500 --> 00:30:04,900
can't obviously you can see that there's

00:30:03,970 --> 00:30:06,280
nothing dangerous that could happen

00:30:04,900 --> 00:30:08,170
there we can't accidentally refer to

00:30:06,280 --> 00:30:10,360
memory that we didn't expect because

00:30:08,170 --> 00:30:11,740
it's all self-contained now let's look

00:30:10,360 --> 00:30:14,440
at a second example where we actually

00:30:11,740 --> 00:30:18,550
read the file to a string inside of a

00:30:14,440 --> 00:30:20,710
thread so we go we say I have a file let

00:30:18,550 --> 00:30:22,510
me open the file and then we go and we

00:30:20,710 --> 00:30:24,850
spawn a new thread and we read from it

00:30:22,510 --> 00:30:26,350
so actually this is also fine because

00:30:24,850 --> 00:30:28,060
what happened here is that we read from

00:30:26,350 --> 00:30:30,130
the file in the first place and then we

00:30:28,060 --> 00:30:31,600
the only other time we ever you

00:30:30,130 --> 00:30:33,730
that again in the entire program was

00:30:31,600 --> 00:30:37,450
inside the thread so the Russ compiler

00:30:33,730 --> 00:30:38,890
is like okay the file was allocated in

00:30:37,450 --> 00:30:41,590
one place now we can get moved somewhere

00:30:38,890 --> 00:30:43,120
else and we're good and then when the

00:30:41,590 --> 00:30:44,260
thread ends up finishing that's the

00:30:43,120 --> 00:30:49,660
point at which the file gets the

00:30:44,260 --> 00:30:52,360
allocated and closed but there is

00:30:49,660 --> 00:30:53,740
actually one case that doesn't work

00:30:52,360 --> 00:30:55,270
where it's very dangerous somewhere you

00:30:53,740 --> 00:30:56,920
will be doing something bad and that's

00:30:55,270 --> 00:30:59,260
here where you say make me a file and

00:30:56,920 --> 00:31:00,490
then you say okay in a thread I want to

00:30:59,260 --> 00:31:01,840
read from it and I also want to read it

00:31:00,490 --> 00:31:03,250
from it outside of here the thread

00:31:01,840 --> 00:31:04,750
obviously in a garbage collected

00:31:03,250 --> 00:31:05,740
language this is totally fine because

00:31:04,750 --> 00:31:07,210
what will happen is the garbage

00:31:05,740 --> 00:31:08,500
collector will hold a reference will

00:31:07,210 --> 00:31:09,550
hold two references and we'll wait till

00:31:08,500 --> 00:31:11,160
both of them get cleaned up and then it

00:31:09,550 --> 00:31:13,210
will clean it up but like we said before

00:31:11,160 --> 00:31:14,230
what we would like to be able to do is

00:31:13,210 --> 00:31:16,390
not have to worry about the garbage

00:31:14,230 --> 00:31:18,490
collector and what hopefully you've seen

00:31:16,390 --> 00:31:19,930
so far is that in many many cases you

00:31:18,490 --> 00:31:21,490
can just write normal programs and

00:31:19,930 --> 00:31:23,080
everything will work fine and you won't

00:31:21,490 --> 00:31:26,170
have to worry too much about these rules

00:31:23,080 --> 00:31:30,340
right but you may write a program where

00:31:26,170 --> 00:31:31,630
you decide to have a file and or any any

00:31:30,340 --> 00:31:33,730
object and have it be referenced from

00:31:31,630 --> 00:31:36,430
two threads at a time or there's other

00:31:33,730 --> 00:31:38,380
ways to have this happen and if you go

00:31:36,430 --> 00:31:39,850
ahead and do that if you try to do

00:31:38,380 --> 00:31:41,980
something that violates the ownership

00:31:39,850 --> 00:31:43,690
rules and rust you get a compile time

00:31:41,980 --> 00:31:46,420
error and what that compile time error

00:31:43,690 --> 00:31:48,430
will say is hey you use this moved value

00:31:46,420 --> 00:31:49,750
file and there's more that it prints out

00:31:48,430 --> 00:31:51,910
which tells you exactly where it was

00:31:49,750 --> 00:31:54,610
used in other places right so basically

00:31:51,910 --> 00:31:56,350
what this means is that if you actually

00:31:54,610 --> 00:31:57,580
end up doing something where you try to

00:31:56,350 --> 00:32:00,130
do something that would require a

00:31:57,580 --> 00:32:03,130
garbage collector then obviously since

00:32:00,130 --> 00:32:04,210
Russ doesn't have one by default you it

00:32:03,130 --> 00:32:05,620
will basically it will give you an error

00:32:04,210 --> 00:32:08,290
and what this means is that you can

00:32:05,620 --> 00:32:09,670
write most of time normal programs that

00:32:08,290 --> 00:32:13,000
you they're a very memory efficient that

00:32:09,670 --> 00:32:16,030
are very fast that are that don't that

00:32:13,000 --> 00:32:17,320
are also very safe but you do have to

00:32:16,030 --> 00:32:20,410
worry about the case where you're doing

00:32:17,320 --> 00:32:22,750
something dangerous but unlike in C or

00:32:20,410 --> 00:32:25,900
C++ you get notified when you try to do

00:32:22,750 --> 00:32:27,430
something dangerous so this probably was

00:32:25,900 --> 00:32:28,210
a little involved for people and that's

00:32:27,430 --> 00:32:29,620
fine I think

00:32:28,210 --> 00:32:30,580
ownership is probably the only reason

00:32:29,620 --> 00:32:32,980
I've talked about here is because

00:32:30,580 --> 00:32:34,030
ownership is the number one topic that I

00:32:32,980 --> 00:32:36,760
think people need to know when they

00:32:34,030 --> 00:32:38,170
learn rust because there it's kind of

00:32:36,760 --> 00:32:39,730
magic how you basically how you get

00:32:38,170 --> 00:32:42,130
automatic memory management but also

00:32:39,730 --> 00:32:43,480
know GC and all so it's safe it's like

00:32:42,130 --> 00:32:44,800
kind of a magic combination and

00:32:43,480 --> 00:32:46,150
is how it works that there's sort of a

00:32:44,800 --> 00:32:48,490
set of rules that you have to follow

00:32:46,150 --> 00:32:50,110
about who gets to own what pointers but

00:32:48,490 --> 00:32:51,490
it ends up being very powerful so that's

00:32:50,110 --> 00:32:53,290
called ownership and if you start

00:32:51,490 --> 00:32:54,520
learning rust make sure you pay special

00:32:53,290 --> 00:32:55,570
attention when you come across the

00:32:54,520 --> 00:32:58,300
section of the guide or whatever

00:32:55,570 --> 00:32:59,920
tutorial that talks about ownership so

00:32:58,300 --> 00:33:02,680
let me go sort of back to the beginning

00:32:59,920 --> 00:33:04,750
which is why does this end up mattering

00:33:02,680 --> 00:33:07,180
for anybody the reason it end this ends

00:33:04,750 --> 00:33:09,220
up mattering is because rust

00:33:07,180 --> 00:33:11,020
sort of opens up the ability for people

00:33:09,220 --> 00:33:12,940
to do low level systems programming who

00:33:11,020 --> 00:33:14,230
would not have done it before like me I

00:33:12,940 --> 00:33:16,390
would not have done low level systems

00:33:14,230 --> 00:33:18,010
programming before whenever I wrote C

00:33:16,390 --> 00:33:19,540
code before I roast I was always very

00:33:18,010 --> 00:33:21,460
afraid and I always didn't really feel

00:33:19,540 --> 00:33:24,640
comfortable experimenting because I knew

00:33:21,460 --> 00:33:25,720
that if I wrote 500 lines of C code and

00:33:24,640 --> 00:33:26,830
tried to put it in production there was

00:33:25,720 --> 00:33:28,420
a good chance that I made some kind of

00:33:26,830 --> 00:33:31,330
mistake even the people who write

00:33:28,420 --> 00:33:32,260
browsers who are the best people as plus

00:33:31,330 --> 00:33:34,720
hackers in the world

00:33:32,260 --> 00:33:36,430
make mistakes and get exploited so I was

00:33:34,720 --> 00:33:38,620
never very comfortable experimenting in

00:33:36,430 --> 00:33:40,090
my own applications with C code or C++

00:33:38,620 --> 00:33:42,550
code because they were so dangerous and

00:33:40,090 --> 00:33:44,500
what this lets you do what rust lets you

00:33:42,550 --> 00:33:46,480
do is lets you say I have some area that

00:33:44,500 --> 00:33:47,950
has been driving me crazy performance

00:33:46,480 --> 00:33:50,500
wise I've tried everything it's been

00:33:47,950 --> 00:33:52,450
crazy I've spent all this time you know

00:33:50,500 --> 00:33:55,270
reading the C code learning how the JIT

00:33:52,450 --> 00:33:57,220
works all this stuff and I just want to

00:33:55,270 --> 00:33:58,900
basically go in and be explicit about

00:33:57,220 --> 00:34:00,820
the performance requirements this is

00:33:58,900 --> 00:34:02,080
something that you can really experiment

00:34:00,820 --> 00:34:03,430
with and not worry that you're gonna

00:34:02,080 --> 00:34:04,450
write a little bit of low-level code and

00:34:03,430 --> 00:34:06,610
all the sudden you're gonna start having

00:34:04,450 --> 00:34:08,140
your app crashing constantly and what

00:34:06,610 --> 00:34:09,700
this also means if you're willing to go

00:34:08,140 --> 00:34:12,070
and learn rust is that you can if

00:34:09,700 --> 00:34:13,210
there's an area where performance

00:34:12,070 --> 00:34:14,830
actually matters you can beat your

00:34:13,210 --> 00:34:16,810
competitors right if you're a high

00:34:14,830 --> 00:34:18,280
frequency trading company and all your

00:34:16,810 --> 00:34:21,310
competitors are writing code in Java and

00:34:18,280 --> 00:34:22,990
they have all these GC pauses and you

00:34:21,310 --> 00:34:25,510
write your code in Brussels be able to

00:34:22,990 --> 00:34:27,820
you know beat them out and so obviously

00:34:25,510 --> 00:34:28,900
don't do this whenever performance

00:34:27,820 --> 00:34:30,760
doesn't matter but when performance

00:34:28,900 --> 00:34:32,440
matters probably your competitors have

00:34:30,760 --> 00:34:33,880
similar performance requirements and you

00:34:32,440 --> 00:34:36,760
could you could compete you can

00:34:33,880 --> 00:34:39,880
out-compete them and just in general

00:34:36,760 --> 00:34:41,920
it's safe I think it's easy to think

00:34:39,880 --> 00:34:43,780
about low-level code and say low-level

00:34:41,920 --> 00:34:45,580
code is either you know low-level code

00:34:43,780 --> 00:34:46,840
is super dangerous and it's so hard to

00:34:45,580 --> 00:34:48,930
write and there's all these crazy s'i

00:34:46,840 --> 00:34:50,980
macros and what's happening here and

00:34:48,930 --> 00:34:52,840
rust is a safe language it's a

00:34:50,980 --> 00:34:55,330
productive language it's not as

00:34:52,840 --> 00:34:57,010
high-level and as productive maybe as

00:34:55,330 --> 00:34:57,250
Ruby but if you care about performance I

00:34:57,010 --> 00:34:59,770
think

00:34:57,250 --> 00:35:01,450
it's great it's safe Rus enables a whole

00:34:59,770 --> 00:35:03,400
new generation of high-level programmers

00:35:01,450 --> 00:35:04,750
to write systems-level code so I think

00:35:03,400 --> 00:35:07,270
what you should ask yourself is what can

00:35:04,750 --> 00:35:09,480
you do with that power thank you very

00:35:07,270 --> 00:35:09,480
much

00:35:14,470 --> 00:35:16,530

YouTube URL: https://www.youtube.com/watch?v=ySW6Yk_DerY


