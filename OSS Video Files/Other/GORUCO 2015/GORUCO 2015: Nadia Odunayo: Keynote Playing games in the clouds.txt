Title: GORUCO 2015: Nadia Odunayo: Keynote Playing games in the clouds
Publication date: 2020-01-23
Playlist: GORUCO 2015
Description: 
	@nodunayo
What does haggling at a garage sale have to do with load balancing in distributed systems? How does bidding in an art auction relate to cloud service orchestration? Familiarity with the ideas and technologies involved in cloud computing is becoming ever more important for developers. This talk will demonstrate how you can use game theory - the study of strategic decision making - to design more efficient, and innovative, distributed systems.
 "Talk given at GORUCO 2015: http://goruco.com"
Captions: 
	00:00:13,910 --> 00:00:21,260
so I want to start with a story about

00:00:17,750 --> 00:00:24,920
tuned University students and their

00:00:21,260 --> 00:00:28,849
final chemistry exam they had received

00:00:24,920 --> 00:00:31,430
a's in chemistry all semester but on the

00:00:28,849 --> 00:00:34,400
night before their final exam they went

00:00:31,430 --> 00:00:36,440
partying in another state and they

00:00:34,400 --> 00:00:40,519
didn't get back to school until the exam

00:00:36,440 --> 00:00:43,610
was over they had to think of an a

00:00:40,519 --> 00:00:46,129
determined excuse so they thought about

00:00:43,610 --> 00:00:48,800
it before finally going to their

00:00:46,129 --> 00:00:52,190
professor and saying we're really sorry

00:00:48,800 --> 00:00:54,620
we went to visit some friends last

00:00:52,190 --> 00:00:58,280
evening and we would have made it back

00:00:54,620 --> 00:01:01,730
in time except for the fact that we had

00:00:58,280 --> 00:01:05,270
a flat tire can we please set a makeup

00:01:01,730 --> 00:01:08,539
test the professor thought about it

00:01:05,270 --> 00:01:11,539
eventually agreed and wrote out another

00:01:08,539 --> 00:01:13,520
test for them when the time came for

00:01:11,539 --> 00:01:17,899
them to take it she said them two

00:01:13,520 --> 00:01:22,340
separate rooms they sat down and turned

00:01:17,899 --> 00:01:27,110
the page to the first question easy they

00:01:22,340 --> 00:01:29,740
thought then they turn the page to the

00:01:27,110 --> 00:01:29,740
second question

00:01:34,210 --> 00:01:40,970
so what would you write in this

00:01:36,320 --> 00:01:43,910
situation it was stories like this that

00:01:40,970 --> 00:01:46,040
got me into game theory I'm a software

00:01:43,910 --> 00:01:47,960
engineer at pivotal labs in London and

00:01:46,040 --> 00:01:49,880
I've been mainly working on their cloud

00:01:47,960 --> 00:01:52,820
foundry platform which is a platform as

00:01:49,880 --> 00:01:56,360
a service and i found the cloud domain

00:01:52,820 --> 00:01:57,560
challenging to grass and for me i found

00:01:56,360 --> 00:01:59,900
that when i don't understand something

00:01:57,560 --> 00:02:01,790
it's very helpful to be able to frame it

00:01:59,900 --> 00:02:05,660
into concepts that i'm familiar with and

00:02:01,790 --> 00:02:07,970
for me that was game theory i studied

00:02:05,660 --> 00:02:10,940
economics at university and game theory

00:02:07,970 --> 00:02:12,920
was one of my favorite modules through

00:02:10,940 --> 00:02:14,959
my readings I've discovered how game

00:02:12,920 --> 00:02:17,800
theory can provide simplicity and

00:02:14,959 --> 00:02:20,690
clarity in what is a complicated expense

00:02:17,800 --> 00:02:24,230
and we'll explore this by discussing a

00:02:20,690 --> 00:02:26,020
simple problem so first we're going to

00:02:24,230 --> 00:02:28,720
have a brief introduction to game theory

00:02:26,020 --> 00:02:31,480
then I've got two games for us to play

00:02:28,720 --> 00:02:36,200
the first one looks at bargaining and

00:02:31,480 --> 00:02:37,760
the second one an auction scenario then

00:02:36,200 --> 00:02:40,190
we're going to look at how these simple

00:02:37,760 --> 00:02:43,310
examples have led to interesting real

00:02:40,190 --> 00:02:46,940
wild case studies before it'll be time

00:02:43,310 --> 00:02:49,160
to wrap up and by the end I hope to have

00:02:46,940 --> 00:02:51,440
shown you that not only is game theory a

00:02:49,160 --> 00:02:54,350
useful tool for working with distributed

00:02:51,440 --> 00:02:55,760
systems but by using game theory you can

00:02:54,350 --> 00:02:57,769
discover how you can efficiently

00:02:55,760 --> 00:03:01,370
allocate resources in systems that you

00:02:57,769 --> 00:03:05,090
go on to build or work with so let's

00:03:01,370 --> 00:03:06,950
begin with more about game theory game

00:03:05,090 --> 00:03:09,580
theory is the study of strategic

00:03:06,950 --> 00:03:12,290
interactions between rational agent and

00:03:09,580 --> 00:03:16,250
applications include economics politics

00:03:12,290 --> 00:03:18,140
biology and computer science it was

00:03:16,250 --> 00:03:21,170
developed by John von Neumann and Oscar

00:03:18,140 --> 00:03:23,209
morgenson in the 1940s with many other

00:03:21,170 --> 00:03:26,660
scholars developing it extensively in

00:03:23,209 --> 00:03:28,700
the 1950s Conlon's one such notable

00:03:26,660 --> 00:03:30,670
scholar was John Nash who is sadly

00:03:28,700 --> 00:03:35,360
killed with his wife Alicia last month

00:03:30,670 --> 00:03:37,160
in a car accident in New Jersey so game

00:03:35,360 --> 00:03:39,320
theory applies to a range of games and

00:03:37,160 --> 00:03:43,070
interactions and we typically see it

00:03:39,320 --> 00:03:44,560
applied to behavioral scenarios but

00:03:43,070 --> 00:03:47,020
despite its breath

00:03:44,560 --> 00:03:51,930
all games no matter how complex have

00:03:47,020 --> 00:03:56,560
some basic components so what is a game

00:03:51,930 --> 00:03:58,690
there are at least two players each

00:03:56,560 --> 00:04:00,250
player has a set of strategies based on

00:03:58,690 --> 00:04:03,190
the information they have and the

00:04:00,250 --> 00:04:04,810
actions they can take and there are

00:04:03,190 --> 00:04:08,080
payoffs to each player for every

00:04:04,810 --> 00:04:09,970
possible outcome so we're going to look

00:04:08,080 --> 00:04:12,310
at games that help us solve a load

00:04:09,970 --> 00:04:14,319
balancing problem so we've got a

00:04:12,310 --> 00:04:17,709
distributed system of two computers a

00:04:14,319 --> 00:04:19,870
and B and we have a scenario where jobs

00:04:17,709 --> 00:04:22,450
are being sent into a task distributor

00:04:19,870 --> 00:04:26,500
which then has to decide how many jobs

00:04:22,450 --> 00:04:31,350
to send to each capitola so let's look

00:04:26,500 --> 00:04:33,520
at our first game badly one afternoon

00:04:31,350 --> 00:04:35,560
you're walking along the street with

00:04:33,520 --> 00:04:38,620
your friend Jemma and you come across a

00:04:35,560 --> 00:04:40,450
bag of sweets on the floor you both want

00:04:38,620 --> 00:04:41,860
the sweets and so now you have to

00:04:40,450 --> 00:04:44,770
negotiate as to how you're going to

00:04:41,860 --> 00:04:47,410
split them out bargaining Theory

00:04:44,770 --> 00:04:49,030
attempts to give a precise answer as to

00:04:47,410 --> 00:04:51,910
how you will eventually divide up those

00:04:49,030 --> 00:04:53,500
sweets between you so another way of

00:04:51,910 --> 00:04:56,710
saying that is that bargaining theory

00:04:53,500 --> 00:05:00,520
asks how will surplus be split between

00:04:56,710 --> 00:05:02,440
agents so in this case with sweets their

00:05:00,520 --> 00:05:04,750
surplus to be gained from acquiring some

00:05:02,440 --> 00:05:06,880
sleep and the mac of maximum surface

00:05:04,750 --> 00:05:08,380
that you can get is equivalent to you

00:05:06,880 --> 00:05:11,110
getting all of the sweets and jemmye

00:05:08,380 --> 00:05:12,970
getting none so one way of answering

00:05:11,110 --> 00:05:16,150
this question is to look at something

00:05:12,970 --> 00:05:17,830
called a Nash bargaining solution so you

00:05:16,150 --> 00:05:19,600
can plot a chart showing all the

00:05:17,830 --> 00:05:22,419
different possible payoffs depending on

00:05:19,600 --> 00:05:24,760
how the sweets are divided up and the

00:05:22,419 --> 00:05:27,100
outer edge of the payoff set represents

00:05:24,760 --> 00:05:29,350
all the possible combinations where the

00:05:27,100 --> 00:05:30,789
full surplus is expected so this means

00:05:29,350 --> 00:05:32,860
that all of the suites are divided

00:05:30,789 --> 00:05:35,050
between you and Gemma and anywhere in

00:05:32,860 --> 00:05:36,550
the purple area means that after you

00:05:35,050 --> 00:05:39,070
stood up the tix petes between you

00:05:36,550 --> 00:05:42,280
you've left some behind on the floor on

00:05:39,070 --> 00:05:43,900
the axis representing Gemma's payoff we

00:05:42,280 --> 00:05:46,389
have the case where gemma takes a whole

00:05:43,900 --> 00:05:48,250
bag of sweets and on the axis

00:05:46,389 --> 00:05:50,940
representing your payoff we've also got

00:05:48,250 --> 00:05:53,230
the case where you take all of the sweet

00:05:50,940 --> 00:05:55,390
we find something called the Nash

00:05:53,230 --> 00:05:57,490
bargaining solution point on the

00:05:55,390 --> 00:06:00,010
frontier of the payoff set we're both

00:05:57,490 --> 00:06:02,350
you and Emma have a high utility then if

00:06:00,010 --> 00:06:04,000
you do not have any sweets but there's

00:06:02,350 --> 00:06:05,380
nowhere else in this payoff set where

00:06:04,000 --> 00:06:07,180
you can increase the payoff for one of

00:06:05,380 --> 00:06:10,870
you without decreasing the payoff for

00:06:07,180 --> 00:06:12,580
the other so in this example I'm

00:06:10,870 --> 00:06:15,130
assuming that yours and jealous payoffs

00:06:12,580 --> 00:06:17,530
are linear and the same with respect to

00:06:15,130 --> 00:06:20,170
the sweet so this means that an

00:06:17,530 --> 00:06:22,420
additional sweet or two or three in your

00:06:20,170 --> 00:06:25,300
pocket represent identical pay us or

00:06:22,420 --> 00:06:27,250
identical happiness but often in game

00:06:25,300 --> 00:06:29,560
theory examples are more complicated and

00:06:27,250 --> 00:06:32,170
the frontier tends to be curved not

00:06:29,560 --> 00:06:34,750
straight and this represents the fact

00:06:32,170 --> 00:06:36,880
that ADA's typically have nonlinear and

00:06:34,750 --> 00:06:39,100
differing responses to marginal

00:06:36,880 --> 00:06:41,500
increases or decreases to whatever is

00:06:39,100 --> 00:06:44,230
being bargained for but in this case

00:06:41,500 --> 00:06:46,330
we'll assume linear chaos and that means

00:06:44,230 --> 00:06:49,500
that the bag of sweets will be sit in

00:06:46,330 --> 00:06:52,600
half so this is all well and good but

00:06:49,500 --> 00:06:55,840
you're wondering what has this repeated

00:06:52,600 --> 00:06:58,030
systems got to do with this so we can

00:06:55,840 --> 00:06:59,830
use bargaining theory to think about how

00:06:58,030 --> 00:07:03,010
is also should be allocated within a

00:06:59,830 --> 00:07:04,720
distributed system so in a system where

00:07:03,010 --> 00:07:06,610
some computers are heavily loaded and

00:07:04,720 --> 00:07:08,800
others have a lighter load we can have

00:07:06,610 --> 00:07:11,770
cases of poor system performance and we

00:07:08,800 --> 00:07:13,360
want to mitigate it back so let's return

00:07:11,770 --> 00:07:15,280
to our distributed system of two

00:07:13,360 --> 00:07:18,430
computers that need to work together to

00:07:15,280 --> 00:07:23,800
complete some time so how do we model

00:07:18,430 --> 00:07:25,630
them the players are the computers each

00:07:23,800 --> 00:07:27,610
computer has a different processing rate

00:07:25,630 --> 00:07:31,240
and we know this information from the

00:07:27,610 --> 00:07:33,520
beginning of the game each computer

00:07:31,240 --> 00:07:37,210
strategy is to accept a pre-agreed

00:07:33,520 --> 00:07:39,100
number of incoming jobs and the payoffs

00:07:37,210 --> 00:07:41,440
to each computer is related to their

00:07:39,100 --> 00:07:44,890
final load and we assume the computers

00:07:41,440 --> 00:07:47,410
with lighter loads are better off so

00:07:44,890 --> 00:07:49,450
we've got two computers one that can

00:07:47,410 --> 00:07:51,390
handle a maximum of five incoming jobs

00:07:49,450 --> 00:07:53,950
every second before it crashes and

00:07:51,390 --> 00:07:56,590
another one that can handle two

00:07:53,950 --> 00:08:00,550
and together they need to deal with four

00:07:56,590 --> 00:08:02,890
jobs every second so here's what's

00:08:00,550 --> 00:08:06,310
happening for jobs are fed in from a

00:08:02,890 --> 00:08:07,810
main computer alongside this a certain

00:08:06,310 --> 00:08:10,030
number of jobs are sent to computer a

00:08:07,810 --> 00:08:13,930
and a certain number of jobs do computer

00:08:10,030 --> 00:08:15,790
be and we want to know how many jobs did

00:08:13,930 --> 00:08:19,690
each computer agree to accept in this

00:08:15,790 --> 00:08:21,670
bargaining game we want to distribute

00:08:19,690 --> 00:08:24,280
the jobs in such a way that optimally

00:08:21,670 --> 00:08:26,530
minimizes execution time and what do I

00:08:24,280 --> 00:08:28,780
mean by optimal I mean that once we've

00:08:26,530 --> 00:08:30,790
come up with the job allocation we

00:08:28,780 --> 00:08:32,200
cannot reallocate the jobs in such a way

00:08:30,790 --> 00:08:34,300
that the performance of at least one

00:08:32,200 --> 00:08:38,110
computer is not worsened and the overall

00:08:34,300 --> 00:08:40,900
execution time increases so how do we

00:08:38,110 --> 00:08:42,940
break this down we assume that each

00:08:40,900 --> 00:08:46,270
computer has a payoff function we can

00:08:42,940 --> 00:08:48,670
view it as happiness in this example I'm

00:08:46,270 --> 00:08:52,030
going to say that that is equal to log

00:08:48,670 --> 00:08:54,700
of X minus y where x is the computer's

00:08:52,030 --> 00:08:57,310
processing rate and why is the rate of

00:08:54,700 --> 00:08:58,720
jobs arriving at the computer now don't

00:08:57,310 --> 00:09:01,030
worry too much about the log function

00:08:58,720 --> 00:09:02,920
it's just more way of saying that as

00:09:01,030 --> 00:09:05,440
more and more jobs arrive at a computer

00:09:02,920 --> 00:09:08,800
the response time to complete those jobs

00:09:05,440 --> 00:09:10,450
increases exponentially so here's what

00:09:08,800 --> 00:09:13,270
that looks like for the computer that

00:09:10,450 --> 00:09:15,310
can handle five drugs every second if

00:09:13,270 --> 00:09:17,290
I'm the computer from my point of view

00:09:15,310 --> 00:09:20,290
I'm happiest when I can sit around do

00:09:17,290 --> 00:09:22,210
not do any work I know I have to do some

00:09:20,290 --> 00:09:24,610
but I want that to be as little as

00:09:22,210 --> 00:09:26,770
possible and as the amount of work you

00:09:24,610 --> 00:09:29,590
send me increases I get unhappier and

00:09:26,770 --> 00:09:32,020
unhappier but the few of the number of

00:09:29,590 --> 00:09:33,460
jobs I have to complete the short of the

00:09:32,020 --> 00:09:38,800
time it takes for me to complete them

00:09:33,460 --> 00:09:40,330
therefore the happier I am so we want to

00:09:38,800 --> 00:09:42,910
find the maximum of a function that

00:09:40,330 --> 00:09:44,260
looks like this this is what you get

00:09:42,910 --> 00:09:46,140
when you take one of those happiness

00:09:44,260 --> 00:09:48,370
functions for each of the computers

00:09:46,140 --> 00:09:49,220
substitute in their processing rates and

00:09:48,370 --> 00:09:51,690
add it

00:09:49,220 --> 00:09:53,339
and we have the constraint that the

00:09:51,690 --> 00:09:55,740
total number of jobs arriving at each

00:09:53,339 --> 00:09:58,710
computer has to equal four as stated in

00:09:55,740 --> 00:10:00,480
the problem so if you're to plot that on

00:09:58,710 --> 00:10:03,300
a graph you get something that looks

00:10:00,480 --> 00:10:05,460
like this and we want to find the point

00:10:03,300 --> 00:10:08,070
up here where happiness is greatest in

00:10:05,460 --> 00:10:10,170
the system so when we sold for that

00:10:08,070 --> 00:10:12,290
point we get that the number of jobs to

00:10:10,170 --> 00:10:14,820
send a computer a it's three and a half

00:10:12,290 --> 00:10:16,980
meaning half a job should be sent to

00:10:14,820 --> 00:10:19,220
computer be so here's what that looks

00:10:16,980 --> 00:10:19,220
like

00:10:25,670 --> 00:10:30,470
so what might that look like on a

00:10:27,230 --> 00:10:32,090
bargaining diagram here we can see the

00:10:30,470 --> 00:10:34,790
joint payoff set for the system with a

00:10:32,090 --> 00:10:36,020
curved out of frontier and this is the

00:10:34,790 --> 00:10:38,960
line where all four jobs are being

00:10:36,020 --> 00:10:40,510
completed and it's curved because the

00:10:38,960 --> 00:10:42,740
processing rates is the computer

00:10:40,510 --> 00:10:44,570
computers mean that marginal increases

00:10:42,740 --> 00:10:46,580
and decreases in the number of jobs that

00:10:44,570 --> 00:10:48,290
they have to handle results in different

00:10:46,580 --> 00:10:49,790
performance levels depending on which

00:10:48,290 --> 00:10:52,910
computer we're looking at and its

00:10:49,790 --> 00:10:54,560
current capacity so with the allocation

00:10:52,910 --> 00:10:57,290
of three and a half jobs to computer a

00:10:54,560 --> 00:11:01,580
you get that the response time based on

00:10:57,290 --> 00:11:03,170
the numbers given is 1.33 seconds but

00:11:01,580 --> 00:11:05,900
what happens if we were to give a bit

00:11:03,170 --> 00:11:09,020
more work to computer a and look at this

00:11:05,900 --> 00:11:10,490
point over here well then an optimal

00:11:09,020 --> 00:11:13,940
response time becomes one point three

00:11:10,490 --> 00:11:16,880
nine seconds and what if we were to give

00:11:13,940 --> 00:11:19,670
a bit more work to computer be so this

00:11:16,880 --> 00:11:21,230
point over here well then the optimal

00:11:19,670 --> 00:11:23,810
response time becomes one point three

00:11:21,230 --> 00:11:26,480
six seconds and what I'm trying to show

00:11:23,810 --> 00:11:28,070
is that when you calculate the the job

00:11:26,480 --> 00:11:30,650
allocation based on the Nash bargaining

00:11:28,070 --> 00:11:32,630
solution there's no way that you could

00:11:30,650 --> 00:11:36,680
reallocate those jobs without increasing

00:11:32,630 --> 00:11:38,390
the response time so by using game

00:11:36,680 --> 00:11:40,370
theoretic principles we can find

00:11:38,390 --> 00:11:43,370
efficient distributions of resources in

00:11:40,370 --> 00:11:44,990
our computer system and we've only we've

00:11:43,370 --> 00:11:47,360
looked at an example with only two

00:11:44,990 --> 00:11:48,980
computers but we can extrapolate the

00:11:47,360 --> 00:11:51,560
same calculation to any number of

00:11:48,980 --> 00:11:53,030
computers and this enables us to start

00:11:51,560 --> 00:11:55,010
thinking about algorithms that can

00:11:53,030 --> 00:11:57,200
dynamically and efficiently distribute

00:11:55,010 --> 00:11:58,460
jobs as they queue up in a system and

00:11:57,200 --> 00:12:01,400
there'll be a bit more on this later on

00:11:58,460 --> 00:12:05,240
in the talk but for now let's look at

00:12:01,400 --> 00:12:07,790
another game in auction so in the end

00:12:05,240 --> 00:12:09,410
you and Gemma decide that instead of

00:12:07,790 --> 00:12:11,420
splitting up the sweets between you

00:12:09,410 --> 00:12:13,010
you'd be better off taking them to the

00:12:11,420 --> 00:12:16,400
school playgrounds and auctioning them

00:12:13,010 --> 00:12:19,130
off amongst your friends so how does

00:12:16,400 --> 00:12:20,360
this auction work we're going to use

00:12:19,130 --> 00:12:24,110
something called a second-price auction

00:12:20,360 --> 00:12:25,790
setup so participants in this auction

00:12:24,110 --> 00:12:27,560
for your sleep some will teach

00:12:25,790 --> 00:12:30,530
simultaneously submit their bids to you

00:12:27,560 --> 00:12:33,020
in an envelope the person who makes the

00:12:30,530 --> 00:12:34,760
highest bid wins the sweets but they'll

00:12:33,020 --> 00:12:37,640
only pay the value of the SEC

00:12:34,760 --> 00:12:39,620
highest fit so this may seem like a

00:12:37,640 --> 00:12:41,990
strange setup but there are auctions

00:12:39,620 --> 00:12:44,330
today that use this concept including

00:12:41,990 --> 00:12:47,690
ebay and google and yahoo's ad online

00:12:44,330 --> 00:12:50,710
advertising programs so let's look at it

00:12:47,690 --> 00:12:56,530
at an example with three participants

00:12:50,710 --> 00:13:00,830
Lucy $25 mark bids five dollars

00:12:56,530 --> 00:13:03,920
hell it's ten dollars so given a second

00:13:00,830 --> 00:13:05,960
price auction setup Lucy wins for making

00:13:03,920 --> 00:13:09,100
the highest bid but she only pays ten

00:13:05,960 --> 00:13:12,620
dollars the second highest bid so

00:13:09,100 --> 00:13:16,280
auction theory asks how should an agent

00:13:12,620 --> 00:13:18,860
fit given varying inter intrinsic values

00:13:16,280 --> 00:13:22,610
that the agent has for the object being

00:13:18,860 --> 00:13:24,620
paid for so I want to interject now to

00:13:22,610 --> 00:13:28,160
introduce the concept of a dominant

00:13:24,620 --> 00:13:30,500
strategy so a strategy is dominant if

00:13:28,160 --> 00:13:32,990
that strategy gives the player their

00:13:30,500 --> 00:13:36,490
highest payoff regardless of what the

00:13:32,990 --> 00:13:38,780
other players due to declare off' I a

00:13:36,490 --> 00:13:41,180
dominant strategy is not the same as a

00:13:38,780 --> 00:13:43,190
winning strategy it does not guarantee

00:13:41,180 --> 00:13:46,430
that you win and nor does every game

00:13:43,190 --> 00:13:49,880
have one and a double its strategy

00:13:46,430 --> 00:13:51,650
doesn't always exist but if it does then

00:13:49,880 --> 00:13:54,470
it will guarantee your highest payoff so

00:13:51,650 --> 00:13:56,210
you're always better off playing it and

00:13:54,470 --> 00:13:57,980
the reason I introduce that now is

00:13:56,210 --> 00:13:59,990
because i want to show you that in a

00:13:57,980 --> 00:14:03,020
second price auction game it's the

00:13:59,990 --> 00:14:04,760
dominant strategy to bid truthfully so

00:14:03,020 --> 00:14:07,310
this means that in the case of the sweet

00:14:04,760 --> 00:14:09,470
it's in the best interest interest of

00:14:07,310 --> 00:14:12,800
the participants to bid the amount that

00:14:09,470 --> 00:14:14,450
the bag of sweets is worth for them so

00:14:12,800 --> 00:14:16,670
let's assume that all three of the

00:14:14,450 --> 00:14:19,280
participants had bit the true value that

00:14:16,670 --> 00:14:22,220
they held for the sweets and that these

00:14:19,280 --> 00:14:25,130
are their respective payoffs zero if you

00:14:22,220 --> 00:14:26,570
don't win the sweets and the true value

00:14:25,130 --> 00:14:29,500
that you hold for the sweets minus the

00:14:26,570 --> 00:14:31,880
second highest bid so for Lucy that's 50

00:14:29,500 --> 00:14:34,040
because she values the sweets of

00:14:31,880 --> 00:14:36,830
twenty-five dollars and only pays ten

00:14:34,040 --> 00:14:39,470
dollars for them so the way of second

00:14:36,830 --> 00:14:41,600
price auction is set up there is no way

00:14:39,470 --> 00:14:44,160
that Lucy Helen all mark could have

00:14:41,600 --> 00:14:47,350
rebid such that their payoff improve

00:14:44,160 --> 00:14:49,899
so let's focus on Helen she's come

00:14:47,350 --> 00:14:51,519
second in this auction there's no point

00:14:49,899 --> 00:14:54,310
her bidding any lower than ten dollars

00:14:51,519 --> 00:14:57,060
because she'll still be using and any

00:14:54,310 --> 00:15:00,819
bid up to $25 again makes no difference

00:14:57,060 --> 00:15:03,670
but what if she had been $26 to move her

00:15:00,819 --> 00:15:05,519
into a winning position well then her

00:15:03,670 --> 00:15:08,380
payoff becomes minus sixteen dollars

00:15:05,519 --> 00:15:10,630
because Helen only values the suite 210

00:15:08,380 --> 00:15:13,449
dollars in reality but she has to pay

00:15:10,630 --> 00:15:15,639
twenty six dollars for them so there is

00:15:13,449 --> 00:15:17,230
no other bid but her true value of ten

00:15:15,639 --> 00:15:20,019
dollars that make sense for Helen and

00:15:17,230 --> 00:15:23,889
this result is true for any participant

00:15:20,019 --> 00:15:26,019
in a second price auction so we can use

00:15:23,889 --> 00:15:27,940
auction theory to reveal the resource

00:15:26,019 --> 00:15:30,399
capabilities of machines within a

00:15:27,940 --> 00:15:33,040
district because systems sometimes there

00:15:30,399 --> 00:15:35,680
are cases where the computers are owned

00:15:33,040 --> 00:15:38,620
by self-interested agents and any load

00:15:35,680 --> 00:15:42,959
allocation algorithms are vulnerable to

00:15:38,620 --> 00:15:47,740
manipulation so how can we model this

00:15:42,959 --> 00:15:48,819
again the players are the computers each

00:15:47,740 --> 00:15:51,279
computer has different capabilities

00:15:48,819 --> 00:15:54,910
which this time are only known to the

00:15:51,279 --> 00:15:58,060
computers themselves and each computer

00:15:54,910 --> 00:15:59,769
strategy is to announce a bid so in this

00:15:58,060 --> 00:16:01,589
case a bid is going to be a statement

00:15:59,769 --> 00:16:04,120
about what capability that machine has

00:16:01,589 --> 00:16:06,639
so for example or computer can have a

00:16:04,120 --> 00:16:08,800
memory of 10 gigabytes and so an honest

00:16:06,639 --> 00:16:12,100
bid would be represented by the number

00:16:08,800 --> 00:16:14,199
10 in this example and the payoff to

00:16:12,100 --> 00:16:17,410
each computer is related for the result

00:16:14,199 --> 00:16:20,920
of the auction so again we've got two

00:16:17,410 --> 00:16:23,880
computers computer a with 15 gigs of

00:16:20,920 --> 00:16:27,069
memory and computer be with 10 and

00:16:23,880 --> 00:16:28,779
they're going to enter an auction to win

00:16:27,069 --> 00:16:32,199
the prize of running a set of jobs in

00:16:28,779 --> 00:16:35,410
their machine computer a will submit its

00:16:32,199 --> 00:16:37,209
fifth in the form of vid a and computer

00:16:35,410 --> 00:16:39,759
be will submit its bid in the form of

00:16:37,209 --> 00:16:41,529
bid be and these bids are going to take

00:16:39,759 --> 00:16:45,550
the form of a statement of how much

00:16:41,529 --> 00:16:47,470
memory the computer has and ideally we

00:16:45,550 --> 00:16:49,660
want the job to run on the machine that

00:16:47,470 --> 00:16:50,760
has the most memory but the computers

00:16:49,660 --> 00:16:53,730
may have other motive a

00:16:50,760 --> 00:16:55,950
shins so let's return to our diagram

00:16:53,730 --> 00:16:59,070
which now has a new component of an

00:16:55,950 --> 00:17:02,490
auctioneer first the auctioneer will

00:16:59,070 --> 00:17:04,980
announce an auction to run the jobs each

00:17:02,490 --> 00:17:07,500
computer will then submit their bids to

00:17:04,980 --> 00:17:09,300
the auctioneer and after receiving the

00:17:07,500 --> 00:17:12,000
bids the auctioneer selects the winner

00:17:09,300 --> 00:17:15,060
and communicates the results to add up

00:17:12,000 --> 00:17:17,390
to the task distributor who then sends

00:17:15,060 --> 00:17:19,530
the incoming jobs to the winning machine

00:17:17,390 --> 00:17:22,140
now there's also something else going on

00:17:19,530 --> 00:17:24,150
behind the scenes the computers are

00:17:22,140 --> 00:17:27,030
programmed with payoff functions that

00:17:24,150 --> 00:17:30,240
mimic the second price auction set up so

00:17:27,030 --> 00:17:31,980
let's look at what this means so this is

00:17:30,240 --> 00:17:33,150
a rather abstract example and it's

00:17:31,980 --> 00:17:35,520
independent to the one we looked up

00:17:33,150 --> 00:17:37,230
earlier and for now we're going to

00:17:35,520 --> 00:17:40,920
ignore the burden on the machine of any

00:17:37,230 --> 00:17:42,090
jobs jobs that it eventually runs so

00:17:40,920 --> 00:17:44,550
let's have a look at computer age

00:17:42,090 --> 00:17:48,210
potential payoff the one with 15

00:17:44,550 --> 00:17:52,010
gigabytes remembering if computer a does

00:17:48,210 --> 00:17:55,020
not participate then the payoff is 0 if

00:17:52,010 --> 00:17:57,480
computer a loses so it submits a bit

00:17:55,020 --> 00:18:01,140
lower than computer be again it's pay up

00:17:57,480 --> 00:18:04,770
with 0 but if computer a Windsor auction

00:18:01,140 --> 00:18:06,660
the payoff becomes 15-50 so that it is

00:18:04,770 --> 00:18:09,060
it receives a payoff that's

00:18:06,660 --> 00:18:10,470
representative of its memory but

00:18:09,060 --> 00:18:14,580
subtracted from that is whatever

00:18:10,470 --> 00:18:16,710
computer be bit so similar to the

00:18:14,580 --> 00:18:18,630
earlier example I'm going to show that

00:18:16,710 --> 00:18:20,310
with this setup it's the dominant

00:18:18,630 --> 00:18:23,390
strategy for computers to truthfully

00:18:20,310 --> 00:18:26,130
report their memory so for computer a

00:18:23,390 --> 00:18:29,670
it's always in its best interest to bid

00:18:26,130 --> 00:18:31,500
15 so first I'm going to demonstrate

00:18:29,670 --> 00:18:35,690
where computer a will never want to bid

00:18:31,500 --> 00:18:38,280
higher than 15 so in this first graph

00:18:35,690 --> 00:18:41,520
computer a has bid fifteen and computer

00:18:38,280 --> 00:18:46,380
be his vid eight so computer a win's and

00:18:41,520 --> 00:18:48,990
has a payoff of seven 15-8 its computer

00:18:46,380 --> 00:18:51,960
baked be a so I would have bid higher

00:18:48,990 --> 00:18:53,700
than 15 so let's say 20 then there would

00:18:51,960 --> 00:18:55,590
be no increase in pay off due to the way

00:18:53,700 --> 00:18:58,029
that they're structured so there's no

00:18:55,590 --> 00:19:00,340
incentive to a bit higher

00:18:58,029 --> 00:19:03,070
but what about the case where computer a

00:19:00,340 --> 00:19:06,989
is losing at a bit of 50 as shown in

00:19:03,070 --> 00:19:09,460
this chart for computer be has been 17

00:19:06,989 --> 00:19:12,549
what is computed a have put in that bit

00:19:09,460 --> 00:19:14,169
of 20 then well it would have won the

00:19:12,549 --> 00:19:15,789
auction but given the payoff structure

00:19:14,169 --> 00:19:19,809
the computer ends up with a negative

00:19:15,789 --> 00:19:21,879
payoff so similar to the sweets example

00:19:19,809 --> 00:19:23,769
whenever a computer has a bit of higher

00:19:21,879 --> 00:19:25,809
value than its true capabilities in

00:19:23,769 --> 00:19:28,509
order to win an auction the ultimate

00:19:25,809 --> 00:19:29,889
payoff would always be negative meaning

00:19:28,509 --> 00:19:33,879
that the computer would prefer not to

00:19:29,889 --> 00:19:35,349
deviate from its to value and now we'll

00:19:33,879 --> 00:19:38,499
look at why computer a will never want

00:19:35,349 --> 00:19:40,899
to bid lower than 50 so in this case

00:19:38,499 --> 00:19:43,330
computer a is losing with its bit of 15

00:19:40,899 --> 00:19:45,460
and moving it to fit to anything lower

00:19:43,330 --> 00:19:47,830
say 11 for example will make no

00:19:45,460 --> 00:19:49,989
difference the payoff remains 0 there's

00:19:47,830 --> 00:19:53,589
no incentive to move away from that bit

00:19:49,989 --> 00:19:56,229
of 15 but what about where computer a is

00:19:53,589 --> 00:19:59,169
winning with a bit of 15 again it can

00:19:56,229 --> 00:20:00,759
fit anything lower up until eight but

00:19:59,169 --> 00:20:03,399
that will make no difference the payoff

00:20:00,759 --> 00:20:05,259
will remain at seven but if computer hey

00:20:03,399 --> 00:20:08,469
had tried to under appoint capabilities

00:20:05,259 --> 00:20:10,960
to say six then the payoff goes from

00:20:08,469 --> 00:20:13,359
seven to zero when it loses and so once

00:20:10,960 --> 00:20:17,049
again there is no better alternative to

00:20:13,359 --> 00:20:19,389
an honest bit of 50 so with this example

00:20:17,049 --> 00:20:21,599
each computer will submit an honest fit

00:20:19,389 --> 00:20:24,129
when asked and since it has more memory

00:20:21,599 --> 00:20:26,909
computer a who will the opportunity to

00:20:24,129 --> 00:20:26,909
run all of the dogs

00:20:34,040 --> 00:20:39,800
so what does this result show us using

00:20:37,460 --> 00:20:41,420
concepts like second price auction we

00:20:39,800 --> 00:20:43,250
can design systems that incentivize

00:20:41,420 --> 00:20:45,920
machines to truthfully report their

00:20:43,250 --> 00:20:47,840
capabilities meaning that distribution

00:20:45,920 --> 00:20:52,310
of jobs remains efficient even as

00:20:47,840 --> 00:20:53,930
resource availability changes so so far

00:20:52,310 --> 00:20:57,460
we've looked at a couple of examples and

00:20:53,930 --> 00:20:59,870
made quite a few assumptions for example

00:20:57,460 --> 00:21:02,600
we've assumed that all jobs and tasks

00:20:59,870 --> 00:21:04,700
considered are the same but how can we

00:21:02,600 --> 00:21:07,130
distinguish between one of tasks or long

00:21:04,700 --> 00:21:09,080
long running processes and what about

00:21:07,130 --> 00:21:10,670
things such as deadlines or wanting

00:21:09,080 --> 00:21:14,030
certain jobs to run on the same machine

00:21:10,670 --> 00:21:15,560
and in the auction example we ignored

00:21:14,030 --> 00:21:17,600
the burden upon machine of actually

00:21:15,560 --> 00:21:19,310
running the jobs and just focus on the

00:21:17,600 --> 00:21:22,160
abstract second price auction payoffs

00:21:19,310 --> 00:21:24,950
and there were many more assumptions

00:21:22,160 --> 00:21:27,470
implicit but the simple starting points

00:21:24,950 --> 00:21:29,240
are key however because not only do they

00:21:27,470 --> 00:21:31,280
help us to build up models to think

00:21:29,240 --> 00:21:32,990
around these problems these starting

00:21:31,280 --> 00:21:36,350
points have already led to interesting

00:21:32,990 --> 00:21:39,200
real-world applications so let's go back

00:21:36,350 --> 00:21:41,090
to that first bargaining available in a

00:21:39,200 --> 00:21:43,730
paper called load balancing a game

00:21:41,090 --> 00:21:45,590
theoretic approach Daniel grocery shows

00:21:43,730 --> 00:21:48,100
how to develop an algorithm based off of

00:21:45,590 --> 00:21:50,690
the Nash bargaining solution calculation

00:21:48,100 --> 00:21:53,870
say we had a distributed system of three

00:21:50,690 --> 00:21:56,090
computers a B and C with the following

00:21:53,870 --> 00:21:59,480
processing rate and they need to handle

00:21:56,090 --> 00:22:01,580
seven jobs every second after doing the

00:21:59,480 --> 00:22:04,190
initial calculation to work out how many

00:22:01,580 --> 00:22:08,120
jobs to send to each computer computer

00:22:04,190 --> 00:22:10,520
see returns a negative value in this

00:22:08,120 --> 00:22:12,320
framework that is equivalent to the

00:22:10,520 --> 00:22:14,480
computer being too slow to be effective

00:22:12,320 --> 00:22:18,110
and so we remove it from the system

00:22:14,480 --> 00:22:20,270
before redoing the optimization and we

00:22:18,110 --> 00:22:22,130
repeat the calculation until all

00:22:20,270 --> 00:22:23,840
remaining computers in the system has a

00:22:22,130 --> 00:22:26,630
positive value for the number of jobs

00:22:23,840 --> 00:22:28,790
they'll accept so the final outcome

00:22:26,630 --> 00:22:30,740
represents the the unique bargaining

00:22:28,790 --> 00:22:33,140
point as dictated by the Nash bargaining

00:22:30,740 --> 00:22:34,340
solution so this means that we've got

00:22:33,140 --> 00:22:37,280
that optimal outcome that we're looking

00:22:34,340 --> 00:22:38,780
for that is there are no games and

00:22:37,280 --> 00:22:42,320
performance to be made by redistributing

00:22:38,780 --> 00:22:43,879
the jobs but this also leads to another

00:22:42,320 --> 00:22:45,769
interesting results

00:22:43,879 --> 00:22:47,539
so experiments was set up using this

00:22:45,769 --> 00:22:49,429
algorithm and it was pitted against

00:22:47,539 --> 00:22:51,579
other allocation mechanisms that

00:22:49,429 --> 00:22:54,649
optimized for different things and

00:22:51,579 --> 00:22:56,599
during the experiments not only was this

00:22:54,649 --> 00:22:59,539
algorithm simpler to grasp and simpler

00:22:56,599 --> 00:23:01,909
to compute it gave each job the same

00:22:59,539 --> 00:23:04,579
expected response time independent of

00:23:01,909 --> 00:23:06,799
which computer that job ran on the

00:23:04,579 --> 00:23:09,349
slowest computers will not utilized by

00:23:06,799 --> 00:23:11,239
the algorithm whereas other allocation

00:23:09,349 --> 00:23:13,009
frameworks tended to overload server

00:23:11,239 --> 00:23:16,839
computers leading to performance

00:23:13,009 --> 00:23:19,459
inefficiencies and what about auctions

00:23:16,839 --> 00:23:21,529
to cloud foundry and the platform that I

00:23:19,459 --> 00:23:23,479
work on a pivotal incorporates some of

00:23:21,529 --> 00:23:25,569
these auction elements when it comes to

00:23:23,479 --> 00:23:28,609
orchestrating where applications of run

00:23:25,569 --> 00:23:32,329
so I at a very basic level this is how

00:23:28,609 --> 00:23:34,159
it works a user asks the platform for a

00:23:32,329 --> 00:23:37,579
certain number of application instances

00:23:34,159 --> 00:23:40,159
an auctioneer request fits from all the

00:23:37,579 --> 00:23:41,599
virtual machines in the system and the

00:23:40,159 --> 00:23:45,409
machines report back as their

00:23:41,599 --> 00:23:47,690
capabilities so in a blog post fire

00:23:45,409 --> 00:23:50,509
class country a foundry engineer on a

00:23:47,690 --> 00:23:52,069
placement he writes how these bids are

00:23:50,509 --> 00:23:55,129
constructed out of various pieces of

00:23:52,069 --> 00:23:57,469
information such as available memory and

00:23:55,129 --> 00:24:00,289
available disk and given certain

00:23:57,469 --> 00:24:01,669
constraints such such as the available

00:24:00,289 --> 00:24:03,589
memory older machine has to be at least

00:24:01,669 --> 00:24:06,169
as great as the required memory for the

00:24:03,589 --> 00:24:07,969
application instance the auctioneer can

00:24:06,169 --> 00:24:10,759
then determine where best to place and

00:24:07,969 --> 00:24:13,069
appens so on the surface this is a

00:24:10,759 --> 00:24:15,169
rather straightforward set up and this

00:24:13,069 --> 00:24:17,029
structure came out of a rewrite of how

00:24:15,169 --> 00:24:18,739
cloud foundry operated where a

00:24:17,029 --> 00:24:21,889
previously complicated setup Letta

00:24:18,739 --> 00:24:23,329
frigidity so game theoretic concepts

00:24:21,889 --> 00:24:27,129
have helped these engineers to find

00:24:23,329 --> 00:24:29,569
simplicity and a more effective solution

00:24:27,129 --> 00:24:31,099
earlier I talked through an example that

00:24:29,569 --> 00:24:34,940
demonstrates how agents can be

00:24:31,099 --> 00:24:37,009
incentivized to truthfully report so in

00:24:34,940 --> 00:24:39,379
sum distribute assistance resources

00:24:37,009 --> 00:24:40,909
belong to self-interested agents and as

00:24:39,379 --> 00:24:43,209
I said this can lead to poor performance

00:24:40,909 --> 00:24:45,919
if there's any manipulation of the load

00:24:43,209 --> 00:24:48,379
allocation algorithm and so we have

00:24:45,919 --> 00:24:50,929
incomplete information and to help

00:24:48,379 --> 00:24:52,550
uncover this information frameworks have

00:24:50,929 --> 00:24:55,220
been built around ideas that stem

00:24:52,550 --> 00:24:56,810
the second price auction and one such

00:24:55,220 --> 00:24:59,270
framework is something called a victory

00:24:56,810 --> 00:25:01,060
Clark groves mechanism where computers

00:24:59,270 --> 00:25:05,060
are programmed with a profit function

00:25:01,060 --> 00:25:07,010
equal to a payment minus of cost the

00:25:05,060 --> 00:25:08,900
payment is paid by the auction in to

00:25:07,010 --> 00:25:11,900
each machine after it receives the bids

00:25:08,900 --> 00:25:15,290
and the cost is related to how much work

00:25:11,900 --> 00:25:16,820
the computer eventually has to do so the

00:25:15,290 --> 00:25:19,250
structure of payments given out in the

00:25:16,820 --> 00:25:20,810
system is such that each machine only

00:25:19,250 --> 00:25:22,990
maximizes their profit when they

00:25:20,810 --> 00:25:25,040
truthfully report their capabilities and

00:25:22,990 --> 00:25:28,280
again you can find more on this in

00:25:25,040 --> 00:25:29,900
groceries paper but what did game

00:25:28,280 --> 00:25:31,730
theoretic approaches mean more broadly

00:25:29,900 --> 00:25:34,820
for the types of systems that will build

00:25:31,730 --> 00:25:36,830
the seam Nicholas Taleb in his latest

00:25:34,820 --> 00:25:39,500
book developed the concept of anti

00:25:36,830 --> 00:25:41,540
frigidity where in the face of failures

00:25:39,500 --> 00:25:44,720
systems learn from feedback and get

00:25:41,540 --> 00:25:46,640
stronger systems built focused in

00:25:44,720 --> 00:25:49,010
individual machines that optimize with

00:25:46,640 --> 00:25:50,440
game theoretic algorithms a well placed

00:25:49,010 --> 00:25:54,230
to be able to adapt to strenuous

00:25:50,440 --> 00:25:56,450
circumstances if a machine goes down or

00:25:54,230 --> 00:25:58,310
there are network partitions the

00:25:56,450 --> 00:25:59,960
algorithms in the system in dynamically

00:25:58,310 --> 00:26:02,000
update and reallocate jobs were

00:25:59,960 --> 00:26:03,920
necessary so they may be able to

00:26:02,000 --> 00:26:08,350
demonstrate some of these anti-fraud are

00:26:03,920 --> 00:26:10,610
characteristics now it's time to wrap up

00:26:08,350 --> 00:26:14,120
what are the specific results that we've

00:26:10,610 --> 00:26:15,980
looked at today when we know the

00:26:14,120 --> 00:26:18,470
capabilities of the machines in a

00:26:15,980 --> 00:26:20,450
distributed system we can use things

00:26:18,470 --> 00:26:22,280
such as the Nash bargaining solution to

00:26:20,450 --> 00:26:25,640
help us determine how we should allocate

00:26:22,280 --> 00:26:27,740
those resources and when we don't know

00:26:25,640 --> 00:26:30,320
the capabilities of the machines and we

00:26:27,740 --> 00:26:31,940
need to know them then frameworks built

00:26:30,320 --> 00:26:33,710
around second price auction can be

00:26:31,940 --> 00:26:37,820
really helpful in terms of revealing

00:26:33,710 --> 00:26:39,980
what those capabilities are so in some

00:26:37,820 --> 00:26:41,870
ways computers are similar to human and

00:26:39,980 --> 00:26:44,300
that they can often behavior ways you

00:26:41,870 --> 00:26:46,370
don't expect and when you're dealing

00:26:44,300 --> 00:26:48,560
with uncertainty you need ways to clear

00:26:46,370 --> 00:26:51,770
away the loins and this is where game

00:26:48,560 --> 00:26:53,960
who becomes very handy you don't need

00:26:51,770 --> 00:26:57,080
max to use game theory as a tool to

00:26:53,960 --> 00:26:58,970
understand complex issues as a starting

00:26:57,080 --> 00:27:01,110
point just think about how you would

00:26:58,970 --> 00:27:02,940
model parts of your system as a game

00:27:01,110 --> 00:27:04,910
and what contracts are competition need

00:27:02,940 --> 00:27:07,950
to happen between the components and

00:27:04,910 --> 00:27:09,840
full of mathematical out there it opens

00:27:07,950 --> 00:27:11,640
up a world of interesting simple yet

00:27:09,840 --> 00:27:14,760
powerful algorithms to help us produce

00:27:11,640 --> 00:27:17,520
better performing systems so what can

00:27:14,760 --> 00:27:19,950
you go and do now you can start by

00:27:17,520 --> 00:27:21,360
reading this book it doesn't really look

00:27:19,950 --> 00:27:23,549
like it but it's essentially an

00:27:21,360 --> 00:27:25,620
introduction to game theory filled with

00:27:23,549 --> 00:27:28,500
stories from a range of areas spanning

00:27:25,620 --> 00:27:31,080
from football to war strategy and when

00:27:28,500 --> 00:27:33,500
reading think about how the examples may

00:27:31,080 --> 00:27:35,640
relate to different computer setups

00:27:33,500 --> 00:27:38,250
there were many other types of games

00:27:35,640 --> 00:27:40,320
that I didn't touch on so perhaps if

00:27:38,250 --> 00:27:42,390
you're interested in cloud security you

00:27:40,320 --> 00:27:44,809
can find some interesting parallels to

00:27:42,390 --> 00:27:46,980
draw with non cooperative game theory

00:27:44,809 --> 00:27:48,480
maybe you're interested in clustering

00:27:46,980 --> 00:27:51,150
you're perhaps working with a database

00:27:48,480 --> 00:27:52,380
like Cassandra well evolutionary game

00:27:51,150 --> 00:27:55,140
theory will have some interesting

00:27:52,380 --> 00:27:56,580
results for you and maybe you're

00:27:55,140 --> 00:27:59,250
interested in the platform as a service

00:27:56,580 --> 00:28:02,730
landscape well then coalition theory can

00:27:59,250 --> 00:28:04,350
help with that if you want to dig deeper

00:28:02,730 --> 00:28:05,669
these are some of the sort of the

00:28:04,350 --> 00:28:09,110
sources that I used to help me write

00:28:05,669 --> 00:28:14,750
this talk and one final question remains

00:28:09,110 --> 00:28:14,750
would you like to play again thank you

00:28:32,780 --> 00:28:34,840

YouTube URL: https://www.youtube.com/watch?v=aHJEzIzhbf8


