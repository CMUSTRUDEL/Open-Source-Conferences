Title: GORUCO 2015: Bryan Reinero: Event sourcing
Publication date: 2020-01-23
Playlist: GORUCO 2015
Description: 
	@blimpyacht
Event Sourcing is powerful way to think about domain objects and transaction processing. Rather than persisting an object in it's current state, event sourcing instead writes an immutable log of deltas (domain events) to the database. from this set of events, an object's state is derived, at any point in the past, simply by replaying the event history sequentially. Event sourcing is a deceptively radical idea which challenges our contemporary notions about transaction processing, while also being a mature pattern with a long history. This talk will take a look at how event processing is used across a spectrum of use cases, including database engines and financial systems, to Google Docs hacks.

 Talk given at GORUCO 2015: http://goruco.com
Captions: 
	00:00:14,170 --> 00:00:19,090
Oh everyone my name is Brian Bernero I

00:00:16,420 --> 00:00:21,910
work as a software developer advocate at

00:00:19,090 --> 00:00:24,250
MongoDB and another thing about me today

00:00:21,910 --> 00:00:30,850
is my birthday so standing here means my

00:00:24,250 --> 00:00:33,040
wish came true so let's talk about event

00:00:30,850 --> 00:00:34,989
sourcing what event sourcing is how can

00:00:33,040 --> 00:00:36,129
it be ubiquitous and how can I assert

00:00:34,989 --> 00:00:38,590
that you've never heard of it before

00:00:36,129 --> 00:00:40,930
more importantly why might you want to

00:00:38,590 --> 00:00:45,460
use it well let's dive into an example

00:00:40,930 --> 00:00:46,720
let's build a banking app okay so if I'm

00:00:45,460 --> 00:00:48,729
building a banking app I'm probably

00:00:46,720 --> 00:00:51,129
going to need to persist state in some

00:00:48,729 --> 00:00:53,290
form back on my data store in some way

00:00:51,129 --> 00:00:55,780
now this seems like a pretty obvious

00:00:53,290 --> 00:00:59,260
problem to solve I'm going to have to

00:00:55,780 --> 00:01:01,839
users user a and creatively named user B

00:00:59,260 --> 00:01:03,549
and they both have balances and the

00:01:01,839 --> 00:01:06,580
balance describes the current state of

00:01:03,549 --> 00:01:08,920
their accounts so when I want to do a

00:01:06,580 --> 00:01:11,590
transaction between the two accounts

00:01:08,920 --> 00:01:13,630
transfer money let's say user a buy

00:01:11,590 --> 00:01:17,290
something for five dollars from user B

00:01:13,630 --> 00:01:21,280
that's easy I just credit the account of

00:01:17,290 --> 00:01:23,530
user B while cittÃ  maclee in an acid

00:01:21,280 --> 00:01:26,829
transaction take away five dollars from

00:01:23,530 --> 00:01:28,659
user a but the problem is if I'm

00:01:26,829 --> 00:01:32,469
thinking along this way I may already be

00:01:28,659 --> 00:01:35,289
doing it wrong why because by design I'm

00:01:32,469 --> 00:01:36,969
throwing away you useful information the

00:01:35,289 --> 00:01:39,640
only thing I'm persisting right now is

00:01:36,969 --> 00:01:41,799
the current state of the users I've lost

00:01:39,640 --> 00:01:43,749
the history of what I've done or how

00:01:41,799 --> 00:01:47,020
they got there so if there's any

00:01:43,749 --> 00:01:48,789
corruption or data loss I can't all

00:01:47,020 --> 00:01:52,179
right i'm attacked where someone changes

00:01:48,789 --> 00:01:55,030
my state I can't derive what happened so

00:01:52,179 --> 00:01:57,609
instead event sourcing was first

00:01:55,030 --> 00:02:00,939
proposed by two gentlemen Greg young and

00:01:57,609 --> 00:02:02,409
oody DeHaan and it is often used in

00:02:00,939 --> 00:02:04,780
conjunction with command query

00:02:02,409 --> 00:02:06,340
responsibility segregation you have to

00:02:04,780 --> 00:02:09,610
say that ten times fast before you can

00:02:06,340 --> 00:02:11,680
invoke it in your code so event sourcing

00:02:09,610 --> 00:02:14,530
in command query responsibility

00:02:11,680 --> 00:02:16,569
segregation what are these things event

00:02:14,530 --> 00:02:18,940
sourcing says forget about current state

00:02:16,569 --> 00:02:20,770
don't think about current state we don't

00:02:18,940 --> 00:02:21,880
care about kurt say well we do care

00:02:20,770 --> 00:02:24,099
about current state but we're not going

00:02:21,880 --> 00:02:26,260
to persist current state we're instead

00:02:24,099 --> 00:02:29,379
going to log abend

00:02:26,260 --> 00:02:32,230
that change our state we're saying that

00:02:29,379 --> 00:02:34,480
in this case I'm instead of updating a

00:02:32,230 --> 00:02:36,010
user's account i'm updating the

00:02:34,480 --> 00:02:39,819
transactions that would change that

00:02:36,010 --> 00:02:43,420
account and i can derive my state by

00:02:39,819 --> 00:02:45,640
replaying the event log what is more is

00:02:43,420 --> 00:02:47,890
that if I lose this current state i can

00:02:45,640 --> 00:02:51,280
always regenerate it by replaying the

00:02:47,890 --> 00:02:53,319
event the event log plus I can come up

00:02:51,280 --> 00:02:55,569
to any state in the past I can tell you

00:02:53,319 --> 00:02:58,659
what the world used to be like at any

00:02:55,569 --> 00:03:01,569
time at different points in time so I

00:02:58,659 --> 00:03:03,159
can do temporal queries this is actually

00:03:01,569 --> 00:03:04,870
kind of useful if I've learned something

00:03:03,159 --> 00:03:08,650
new about the people in the way that

00:03:04,870 --> 00:03:10,060
users use my tool my website I can go

00:03:08,650 --> 00:03:11,980
back and see how many people I could

00:03:10,060 --> 00:03:15,609
have reached in the past as long as I've

00:03:11,980 --> 00:03:18,659
kept that information in the law now how

00:03:15,609 --> 00:03:20,950
is this more about is this more secure

00:03:18,659 --> 00:03:22,180
consider if someone tries to attack me

00:03:20,950 --> 00:03:24,370
how might they attack me what's the

00:03:22,180 --> 00:03:26,829
easiest way of attacking me start

00:03:24,370 --> 00:03:29,500
sending an erroneous data no problem

00:03:26,829 --> 00:03:31,060
because I have a log of the attack I can

00:03:29,500 --> 00:03:33,579
play up to the point where I detect the

00:03:31,060 --> 00:03:35,290
attack and I since I have a log of the

00:03:33,579 --> 00:03:38,739
attack I can analyze it and protect

00:03:35,290 --> 00:03:39,970
myself in the future now for those of

00:03:38,739 --> 00:03:43,389
you who might think that this is a

00:03:39,970 --> 00:03:46,230
radical new idea untested kinds of ways

00:03:43,389 --> 00:03:49,720
of thinking about data not necessarily

00:03:46,230 --> 00:03:53,889
this is the Reagan third of it got a

00:03:49,720 --> 00:03:56,590
gusty which translates into the divine

00:03:53,889 --> 00:03:58,690
deeds of Augustus this is Caesars record

00:03:56,590 --> 00:04:01,599
of payments pension payments to his

00:03:58,690 --> 00:04:03,579
Legionnaires that have retired and he's

00:04:01,599 --> 00:04:06,160
not recording state these are the

00:04:03,579 --> 00:04:08,470
payments so he can get his accounts at

00:04:06,160 --> 00:04:12,280
any given time and it's a pretty borough

00:04:08,470 --> 00:04:13,870
bus data store that's durability for

00:04:12,280 --> 00:04:16,000
those of you who like their technology

00:04:13,870 --> 00:04:17,949
explained in modern contexts you might

00:04:16,000 --> 00:04:20,560
already guess that this kind of pattern

00:04:17,949 --> 00:04:23,710
is already used in What's Wrong write

00:04:20,560 --> 00:04:25,630
code repository systems right because

00:04:23,710 --> 00:04:27,760
when I'm chained what I'm logging a code

00:04:25,630 --> 00:04:29,860
repository system is such as github is

00:04:27,760 --> 00:04:32,409
the changes that I've done to my code

00:04:29,860 --> 00:04:34,570
such that i can always rebuild what the

00:04:32,409 --> 00:04:36,789
current snapshot is or i can go back to

00:04:34,570 --> 00:04:38,830
a previous code state in time I can also

00:04:36,789 --> 00:04:39,490
do merges and blends and all sorts of

00:04:38,830 --> 00:04:41,590
fun stuff

00:04:39,490 --> 00:04:44,220
that confuses everybody and that's why

00:04:41,590 --> 00:04:48,940
we want continuous integration begin my

00:04:44,220 --> 00:04:50,949
also databases make big use of event

00:04:48,940 --> 00:04:53,800
sourcing internally in the case of

00:04:50,949 --> 00:04:55,030
MongoDB we have replication so what

00:04:53,800 --> 00:04:56,949
we're going to be doing is the primary

00:04:55,030 --> 00:04:59,080
who takes the right is going to be

00:04:56,949 --> 00:05:01,479
writing to what's called the OP log and

00:04:59,080 --> 00:05:03,400
it makes item potent inserts of write

00:05:01,479 --> 00:05:05,530
operations from the database the

00:05:03,400 --> 00:05:08,020
secondary will follow off of that log

00:05:05,530 --> 00:05:10,479
and replay the applause to get itself in

00:05:08,020 --> 00:05:12,220
a consistent state with the primary the

00:05:10,479 --> 00:05:14,409
neat thing about the op log is just like

00:05:12,220 --> 00:05:16,509
a vent sourcing I can start at any point

00:05:14,409 --> 00:05:19,090
in time in the past and replay up to get

00:05:16,509 --> 00:05:21,400
into a current state anywhere I stopped

00:05:19,090 --> 00:05:25,449
reading is a consistent state at that

00:05:21,400 --> 00:05:27,099
weight in the OP log okay so you might

00:05:25,449 --> 00:05:29,770
detect there's a little bit of a problem

00:05:27,099 --> 00:05:32,020
with event sourcing if every time I want

00:05:29,770 --> 00:05:33,970
to derive my current status I have to go

00:05:32,020 --> 00:05:36,250
back against the log to the beginning of

00:05:33,970 --> 00:05:38,169
time the beginning of time for me it

00:05:36,250 --> 00:05:41,020
could be many years many months many

00:05:38,169 --> 00:05:42,880
years and replaying that whole log it's

00:05:41,020 --> 00:05:46,300
going to be time consuming it might even

00:05:42,880 --> 00:05:48,250
blow out my cache which is painful so

00:05:46,300 --> 00:05:50,680
instead the solution is of course to

00:05:48,250 --> 00:05:52,780
make snapshots at given intervals when I

00:05:50,680 --> 00:05:54,820
need to go back to a note when I want to

00:05:52,780 --> 00:05:56,710
go to a targeted state I go back to the

00:05:54,820 --> 00:05:59,440
last snapshot before the target and

00:05:56,710 --> 00:06:03,699
simply replay the OP log from that point

00:05:59,440 --> 00:06:06,389
for the event log okay so this kind of

00:06:03,699 --> 00:06:08,770
precedence also has its roots in ancient

00:06:06,389 --> 00:06:11,380
ancient history well if you think the

00:06:08,770 --> 00:06:13,599
14th century is ancient which I do this

00:06:11,380 --> 00:06:16,569
gentleman is look up Charlie he is the

00:06:13,599 --> 00:06:18,280
he is a renaissance man again that you

00:06:16,569 --> 00:06:20,710
may not have ever heard of but he is the

00:06:18,280 --> 00:06:24,969
father of modern accounting because he

00:06:20,710 --> 00:06:27,370
was the first in 1495 to put down a kind

00:06:24,969 --> 00:06:30,159
of accounting called dual entry

00:06:27,370 --> 00:06:32,530
accounting and basically idea is he's

00:06:30,159 --> 00:06:34,900
going to take his event log the journal

00:06:32,530 --> 00:06:38,110
which the etymology of journal is juror

00:06:34,900 --> 00:06:40,330
or day and he's going to aggregate this

00:06:38,110 --> 00:06:42,460
as we saw in the snapshot pattern into a

00:06:40,330 --> 00:06:45,940
ledger in the etymology of the ledger is

00:06:42,460 --> 00:06:48,520
to lay the book lays in one spot so we

00:06:45,940 --> 00:06:51,320
have our logs which are being aggregated

00:06:48,520 --> 00:06:53,810
into a ledger this is very similar to

00:06:51,320 --> 00:06:56,330
eric evans pattern of aggregations and

00:06:53,810 --> 00:06:58,040
domain driven design his particular

00:06:56,330 --> 00:07:00,320
innovation was he was doing this duel

00:06:58,040 --> 00:07:02,270
entry accounting where we have accounts

00:07:00,320 --> 00:07:04,100
payable and accounts receivable this

00:07:02,270 --> 00:07:06,920
works so well in fact that this actually

00:07:04,100 --> 00:07:09,980
funded the age of exploration in the

00:07:06,920 --> 00:07:12,460
1500s in the century to follow but we

00:07:09,980 --> 00:07:15,970
can call this today as command query

00:07:12,460 --> 00:07:19,850
responsibility segregation or seek urs

00:07:15,970 --> 00:07:22,340
the notion behind seek urs is that the

00:07:19,850 --> 00:07:25,310
way that we command we call commands

00:07:22,340 --> 00:07:27,560
write operations commands are different

00:07:25,310 --> 00:07:30,230
than the way that we read or query the

00:07:27,560 --> 00:07:32,900
data off our data store so since they

00:07:30,230 --> 00:07:35,390
are fundamentally different and also

00:07:32,900 --> 00:07:38,050
scale it asymmetrical loads meaning that

00:07:35,390 --> 00:07:40,220
I might read far more than I do write

00:07:38,050 --> 00:07:42,340
operations that mutate state on the data

00:07:40,220 --> 00:07:45,410
store they should be separate objects

00:07:42,340 --> 00:07:49,640
what's the consequence of that consider

00:07:45,410 --> 00:07:51,800
CQ RS vs crud this is the normal pattern

00:07:49,640 --> 00:07:53,600
that we've kind of been accustomed to

00:07:51,800 --> 00:07:55,520
with interacting with a back-end data

00:07:53,600 --> 00:07:57,470
store I have a single object that

00:07:55,520 --> 00:07:59,750
performs create reads updates and

00:07:57,470 --> 00:08:01,580
deletes right and then I add getters and

00:07:59,750 --> 00:08:03,130
setters to change that state back on

00:08:01,580 --> 00:08:06,110
whatever is happening on the database

00:08:03,130 --> 00:08:08,000
now if I you see QRS I've separated

00:08:06,110 --> 00:08:10,340
these models the right model than the

00:08:08,000 --> 00:08:12,530
read model away from one another this

00:08:10,340 --> 00:08:15,950
works if I this works particularly well

00:08:12,530 --> 00:08:18,380
if my right load is significantly less

00:08:15,950 --> 00:08:20,870
than my read load because I can scale up

00:08:18,380 --> 00:08:24,770
my reader objects to a greater degree

00:08:20,870 --> 00:08:27,530
than I would my writer objects okay now

00:08:24,770 --> 00:08:30,350
seek urs has in addition to this being

00:08:27,530 --> 00:08:33,500
on the client side has implications on

00:08:30,350 --> 00:08:36,340
the server side that say that if I'm if

00:08:33,500 --> 00:08:39,500
I'm asymmetrically scaling my readers I

00:08:36,340 --> 00:08:41,360
can use eventual consistency or

00:08:39,500 --> 00:08:43,820
eventually consistent data source such

00:08:41,360 --> 00:08:46,100
as MongoDB which use replication to go

00:08:43,820 --> 00:08:49,000
out for secondaries and send that load

00:08:46,100 --> 00:08:52,970
distributed out to those secondary nodes

00:08:49,000 --> 00:08:55,760
leveraging eventual consistency so

00:08:52,970 --> 00:08:58,760
that's basically event sourcing and see

00:08:55,760 --> 00:09:00,740
QRF kind of an obvious solution I look

00:08:58,760 --> 00:09:05,200
forward to discussing with this

00:09:00,740 --> 00:09:09,110
with you further on oh and sorry stop

00:09:05,200 --> 00:09:10,640
one last thing ping me at blimpie yacht

00:09:09,110 --> 00:09:12,920
I love reaching out and discussing this

00:09:10,640 --> 00:09:16,000
kind of stuff so hit me with your best

00:09:12,920 --> 00:09:16,000
shot thank you

00:09:30,480 --> 00:09:32,540

YouTube URL: https://www.youtube.com/watch?v=dOlTRl8gJIs


