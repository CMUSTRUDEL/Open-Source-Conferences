Title: Building functional islands - Front-end London (FEL)
Publication date: 2016-07-14
Playlist: Front-End London
Description: 
	In this talk, Mark Jones introduces the techniques and concepts you’ll need to begin building functional islands. He explains how to introduce functional programming into your code base, as well as why this might be beneficial, in terms we can all understand.

▼ Links mentioned in the talk ▼

- https://drboolean.gitbooks.io/mostly-adequate-guide/content
- http://ramdajs.com
- https://github.com/lodash/lodash/wiki/FP-Guide
- https://youtube.com/watch?v=m3svKOdZijA
- https://github.com/substack/deep-freeze
- https://frontendmasters.com/courses/functional-js-lite
- https://frontendmasters.com/courses/functional-javascript

▼ Slides ▼

http://www.slideshare.net/MarkJones154/building-functional-islands

▼ Speaker ▼

Mark Jones (@mark_jones)

▼ Event ▼

This talk was part of the Front-end London (fel) April 2016 event.

▼ Transcript ▼

https://blog.pusher.com/building-functional-islands/

▼ Video by Pusher ▼

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to http://pusher.com and create a free account. Happy hacking!

▼ More from Pusher ▼

- Subscribe to Pusher: https://www.youtube.com/c/pusherrealtime?sub_confirmation=1
- Front End London playlist: https://www.youtube.com/playlist?list=PL8xuokhAnn4pZ6tAyFobOcUrLI2MNKZbU
Captions: 
	00:00:09,530 --> 00:00:15,880
my name is Mark and I'm a JavaScript

00:00:12,049 --> 00:00:17,530
engineer at a company called kohout and

00:00:15,880 --> 00:00:19,180
and basically today I'm gonna be talking

00:00:17,530 --> 00:00:21,760
about something cool build building

00:00:19,180 --> 00:00:23,619
functional islands unfortunately there's

00:00:21,760 --> 00:00:25,180
no I was told that I should have added

00:00:23,619 --> 00:00:27,390
some cat gifts or something there's no

00:00:25,180 --> 00:00:30,160
gifts there's lots of code lots of words

00:00:27,390 --> 00:00:34,690
I've got a laser pointer so I clearly

00:00:30,160 --> 00:00:37,270
won start with I don't actually have

00:00:34,690 --> 00:00:39,070
anything to win but just a little bit of

00:00:37,270 --> 00:00:40,540
audience participation I'm quite keen to

00:00:39,070 --> 00:00:45,760
like gauge the room so if everyone could

00:00:40,540 --> 00:00:48,730
take a slice stand up and face up lights

00:00:45,760 --> 00:00:52,750
everyone who knows what functional

00:00:48,730 --> 00:00:55,240
programming is to stay standing cool I'm

00:00:52,750 --> 00:00:57,220
so sorry and just to clarify anyone that

00:00:55,240 --> 00:00:59,350
can explain the difference between

00:00:57,220 --> 00:01:01,060
functional programming and imperative or

00:00:59,350 --> 00:01:09,250
object oriented programming stay

00:01:01,060 --> 00:01:10,390
standing so that works stay standing if

00:01:09,250 --> 00:01:12,369
you would say you use functional

00:01:10,390 --> 00:01:14,350
programming in your JavaScript like ever

00:01:12,369 --> 00:01:17,799
it doesn't matter how much just a little

00:01:14,350 --> 00:01:19,150
bit and stay standing if you say use

00:01:17,799 --> 00:01:20,799
functional programming for the majority

00:01:19,150 --> 00:01:22,719
of what you do so you pretty much only

00:01:20,799 --> 00:01:24,549
write functional codes you very rarely

00:01:22,719 --> 00:01:29,740
write anything imperative you probably

00:01:24,549 --> 00:01:31,659
don't write JavaScript cool so no one

00:01:29,740 --> 00:01:35,799
who can ask too many difficult questions

00:01:31,659 --> 00:01:37,030
later and so what is functional

00:01:35,799 --> 00:01:39,100
programming fillets of you that don't

00:01:37,030 --> 00:01:40,719
know this is going to be really

00:01:39,100 --> 00:01:42,520
simplified explanation much like

00:01:40,719 --> 00:01:44,950
everything in my talk I want to try and

00:01:42,520 --> 00:01:46,539
avoid too much terminology and it's

00:01:44,950 --> 00:01:47,920
super important I think like it can

00:01:46,539 --> 00:01:49,600
cause a lot of confusion when you're

00:01:47,920 --> 00:01:51,639
learning and I think most functional

00:01:49,600 --> 00:01:54,069
programmers would argue and that you

00:01:51,639 --> 00:01:55,840
need terminology immediately we're not

00:01:54,069 --> 00:01:59,139
going to do that and we'll see how we go

00:01:55,840 --> 00:02:01,600
so functional programming is programming

00:01:59,139 --> 00:02:03,429
using expressions instead of statements

00:02:01,600 --> 00:02:05,139
and we're going to avoid changing any

00:02:03,429 --> 00:02:07,630
state and we're going to avoid mutable

00:02:05,139 --> 00:02:09,310
data it's a more declarative way of

00:02:07,630 --> 00:02:11,440
programming and a functional programmer

00:02:09,310 --> 00:02:13,980
is going to tell the computer what they

00:02:11,440 --> 00:02:16,420
want not how they want to guess it and

00:02:13,980 --> 00:02:18,430
before I go any further is one too i

00:02:16,420 --> 00:02:20,980
don't know i'm using that and i just

00:02:18,430 --> 00:02:22,540
wanted to explain statements and

00:02:20,980 --> 00:02:24,340
expressions because I realized like not

00:02:22,540 --> 00:02:27,310
everyone is the nurse you know what that

00:02:24,340 --> 00:02:29,080
means so this is code code using

00:02:27,310 --> 00:02:31,090
statements it's in

00:02:29,080 --> 00:02:33,190
parative it's in everyone's javascript

00:02:31,090 --> 00:02:37,090
code realistically it's unavoidable so

00:02:33,190 --> 00:02:39,190
we have assignment statements obviously

00:02:37,090 --> 00:02:41,770
you're going to do this we have control

00:02:39,190 --> 00:02:43,630
statements again well you might not loop

00:02:41,770 --> 00:02:45,550
like this anymore but you're probably

00:02:43,630 --> 00:02:47,590
going to have control statement here

00:02:45,550 --> 00:02:49,270
we've got some mutable data so we're

00:02:47,590 --> 00:02:51,070
pushing into an array and we're not

00:02:49,270 --> 00:02:53,530
actually assigning the return value to

00:02:51,070 --> 00:02:54,820
anything so this is mutable data a

00:02:53,530 --> 00:02:59,020
functional program is not gonna be too

00:02:54,820 --> 00:03:01,360
happy with you whereas expressions are a

00:02:59,020 --> 00:03:03,550
combination of variables operators and

00:03:01,360 --> 00:03:06,460
functions and they evaluate to produce a

00:03:03,550 --> 00:03:08,140
new value and so for people that aren't

00:03:06,460 --> 00:03:09,940
aware of what map does have a seat a

00:03:08,140 --> 00:03:12,010
list of data and it applies a function

00:03:09,940 --> 00:03:13,690
to each item so what we're going to do

00:03:12,010 --> 00:03:14,620
is we're going to see this expression

00:03:13,690 --> 00:03:17,110
kind of tenants with some different

00:03:14,620 --> 00:03:19,480
expressions we're going to x 1 x 2 to x

00:03:17,110 --> 00:03:21,670
2 3 by tues and we're going to evaluate

00:03:19,480 --> 00:03:24,310
those expressions and it's going to 46

00:03:21,670 --> 00:03:29,080
they've got our final value and it

00:03:24,310 --> 00:03:31,600
leaves our original array untouched but

00:03:29,080 --> 00:03:32,980
why I guess is the kind of key point why

00:03:31,600 --> 00:03:34,660
don't talk about functional programming

00:03:32,980 --> 00:03:36,459
like you don't have to do functional

00:03:34,660 --> 00:03:39,790
programming its academic it's

00:03:36,459 --> 00:03:42,550
potentially dry and personally I've seen

00:03:39,790 --> 00:03:43,810
a huge increase in FP I'm gonna say FPS

00:03:42,550 --> 00:03:46,570
now I'm spunctional-- program is really

00:03:43,810 --> 00:03:49,390
long and concepts in front-end libraries

00:03:46,570 --> 00:03:51,519
over the past I was in a couple of years

00:03:49,390 --> 00:03:52,900
I guess and that's kind of all got me

00:03:51,519 --> 00:03:54,610
interested in it because the reading

00:03:52,900 --> 00:03:56,950
blogs people were using terminology I

00:03:54,610 --> 00:03:58,300
have no idea what they're saying and

00:03:56,950 --> 00:03:59,769
eventually it resolves to me beginning

00:03:58,300 --> 00:04:02,040
to learn Haskell which I wouldn't

00:03:59,769 --> 00:04:04,540
necessarily recommend anyone does but

00:04:02,040 --> 00:04:07,390
it's really enlightening like you start

00:04:04,540 --> 00:04:09,610
to see the concepts and why you would

00:04:07,390 --> 00:04:11,170
want to do them so and it became quite

00:04:09,610 --> 00:04:12,700
apparent that these concepts might be

00:04:11,170 --> 00:04:14,530
really valuable for JavaScript as well

00:04:12,700 --> 00:04:16,330
and but there's not many talks about the

00:04:14,530 --> 00:04:17,650
basics as I say most people like to go

00:04:16,330 --> 00:04:20,080
straight into the terminology rather

00:04:17,650 --> 00:04:21,609
than starting from scratch so that's

00:04:20,080 --> 00:04:23,140
kind of what we're going to do and we're

00:04:21,609 --> 00:04:24,910
going to look at each the blocks to

00:04:23,140 --> 00:04:27,960
start building sort of functional code

00:04:24,910 --> 00:04:30,610
in our JavaScript and unsurprisingly

00:04:27,960 --> 00:04:34,690
functions are building block number one

00:04:30,610 --> 00:04:37,630
so her there's several like things about

00:04:34,690 --> 00:04:38,919
functions that we care about so first

00:04:37,630 --> 00:04:40,510
pass functions is something we care

00:04:38,919 --> 00:04:42,520
about these are just functions in

00:04:40,510 --> 00:04:43,990
JavaScript all functions are first

00:04:42,520 --> 00:04:46,150
their first class citizens of the

00:04:43,990 --> 00:04:48,039
language which basically means that they

00:04:46,150 --> 00:04:49,810
can be used anywhere any other value can

00:04:48,039 --> 00:04:52,150
so you can assign a variable to be a

00:04:49,810 --> 00:04:55,050
function you're gonna use a function as

00:04:52,150 --> 00:04:57,580
an argument and this shouldn't be news

00:04:55,050 --> 00:04:59,250
in some languages you didn't use to be

00:04:57,580 --> 00:05:02,440
able to do or still can't do this so

00:04:59,250 --> 00:05:04,990
it's important and they give us the

00:05:02,440 --> 00:05:06,669
ability to create higher order functions

00:05:04,990 --> 00:05:11,229
which again we see these all the time

00:05:06,669 --> 00:05:13,870
add event listener is a high order

00:05:11,229 --> 00:05:16,120
function they basically you'll see them

00:05:13,870 --> 00:05:18,330
in a van cool box you'll see them in ray

00:05:16,120 --> 00:05:21,340
extras if you use map filter or reduce

00:05:18,330 --> 00:05:22,750
but um let's ignore the add event

00:05:21,340 --> 00:05:25,479
listener example don't feel like it's

00:05:22,750 --> 00:05:26,590
that useful here's my trusty add

00:05:25,479 --> 00:05:29,319
function we're going to see a lot of

00:05:26,590 --> 00:05:34,060
this guy tonight and basically takes two

00:05:29,319 --> 00:05:35,710
numbers returns them added together then

00:05:34,060 --> 00:05:38,349
I have a function that I would never

00:05:35,710 --> 00:05:41,050
recommend writing but it's lava Phi what

00:05:38,349 --> 00:05:42,310
it does is it takes a function it's a

00:05:41,050 --> 00:05:46,360
cool of a function it's going to return

00:05:42,310 --> 00:05:48,250
a new function that is going to perform

00:05:46,360 --> 00:05:49,360
all of the like logic of the original

00:05:48,250 --> 00:05:50,919
function but it's also going to log out

00:05:49,360 --> 00:05:54,069
with the arguments you pass to the new

00:05:50,919 --> 00:05:56,380
function so it basically works like this

00:05:54,069 --> 00:05:58,419
you would say laga fight add so we've

00:05:56,380 --> 00:06:00,130
got a new lava fight add function then

00:05:58,419 --> 00:06:02,469
we're going to cool it and you can see

00:06:00,130 --> 00:06:05,529
it logs out one and two and also logs

00:06:02,469 --> 00:06:07,719
out free well it returns free and so it

00:06:05,529 --> 00:06:11,560
maintained all the original behavior but

00:06:07,719 --> 00:06:13,300
we added some extra behavior so why do

00:06:11,560 --> 00:06:15,520
we care about this for higher-order

00:06:13,300 --> 00:06:17,800
functions are functions that create new

00:06:15,520 --> 00:06:19,599
functions they might be very similar but

00:06:17,800 --> 00:06:22,509
they're probably customized based on the

00:06:19,599 --> 00:06:24,099
premises you pass them or they might be

00:06:22,509 --> 00:06:25,779
functions that change other functions a

00:06:24,099 --> 00:06:27,069
bit like my logo fly example where we're

00:06:25,779 --> 00:06:28,630
decorating the function with new

00:06:27,069 --> 00:06:31,000
behavior so we're adding the ability for

00:06:28,630 --> 00:06:32,830
it to log its params which is kind of

00:06:31,000 --> 00:06:35,020
like a functional form of inheritance or

00:06:32,830 --> 00:06:36,400
mix-ins for functions obviously if

00:06:35,020 --> 00:06:38,050
you're using classes you could use

00:06:36,400 --> 00:06:41,469
extends if using objects you could

00:06:38,050 --> 00:06:44,020
literally mix them together and so

00:06:41,469 --> 00:06:47,169
another type of function and that FP

00:06:44,020 --> 00:06:49,419
cares about is pure functions so these

00:06:47,169 --> 00:06:52,389
functions only care about input and

00:06:49,419 --> 00:06:54,279
output and they have no side effects so

00:06:52,389 --> 00:06:56,470
they don't know anything about the state

00:06:54,279 --> 00:06:58,840
of the application they will sit down

00:06:56,470 --> 00:07:01,150
change the state of the application them

00:06:58,840 --> 00:07:04,180
something else about a function like add

00:07:01,150 --> 00:07:05,890
is that ad is referential e transparent

00:07:04,180 --> 00:07:07,990
and that's about as complex as the

00:07:05,890 --> 00:07:11,320
terminology or get but this means that

00:07:07,990 --> 00:07:14,110
we can take an expression like this so

00:07:11,320 --> 00:07:17,110
add 1 to plus at 34 and we can basically

00:07:14,110 --> 00:07:19,180
just substitute the expression for its

00:07:17,110 --> 00:07:21,670
value so we can substitute ad for one

00:07:19,180 --> 00:07:23,830
add 12 with free and then we can

00:07:21,670 --> 00:07:26,470
substitute add 347 so we substitute in a

00:07:23,830 --> 00:07:28,930
value for the eventual value of the

00:07:26,470 --> 00:07:30,550
expression and then get 10 and our

00:07:28,930 --> 00:07:31,840
program hasn't changed it's exactly the

00:07:30,550 --> 00:07:33,730
same as it used to be which is why

00:07:31,840 --> 00:07:36,460
they're cool being there referential e

00:07:33,730 --> 00:07:38,410
transparent and pure functions will be

00:07:36,460 --> 00:07:41,440
like that whereas this is kind of the

00:07:38,410 --> 00:07:44,080
alternative so and no one can tell me

00:07:41,440 --> 00:07:45,400
what do something else does so no one

00:07:44,080 --> 00:07:48,520
can tell me what added and something

00:07:45,400 --> 00:07:50,830
else does like it's impossible it's got

00:07:48,520 --> 00:07:52,330
side effects ms for some crazy reason do

00:07:50,830 --> 00:07:54,400
something else there's no up that does

00:07:52,330 --> 00:07:57,820
nothing I don't know why you do that but

00:07:54,400 --> 00:08:01,360
and it's got to read state elsewhere or

00:07:57,820 --> 00:08:03,250
mutate something else like we can't do

00:08:01,360 --> 00:08:05,860
why I did a minute ago and replace the

00:08:03,250 --> 00:08:09,790
expression with the value so we don't

00:08:05,860 --> 00:08:12,040
want code like this well we need it and

00:08:09,790 --> 00:08:13,860
which I'll get onto but and what the

00:08:12,040 --> 00:08:17,260
other benefits of your functions so

00:08:13,860 --> 00:08:19,060
they're testable if you try and test a

00:08:17,260 --> 00:08:21,400
function like add it cares about to

00:08:19,060 --> 00:08:24,669
input and output it's very easy to test

00:08:21,400 --> 00:08:26,590
there's no setup you don't need to mock

00:08:24,669 --> 00:08:28,090
objects or make sure the applications in

00:08:26,590 --> 00:08:30,220
a certain state before you run your test

00:08:28,090 --> 00:08:31,510
it's just going to work so trivial to

00:08:30,220 --> 00:08:32,890
unit test which is brilliant because

00:08:31,510 --> 00:08:35,469
testing is hard and we should be doing

00:08:32,890 --> 00:08:38,200
it but um you know it shouldn't be a

00:08:35,469 --> 00:08:39,550
chore they're portable so you can move a

00:08:38,200 --> 00:08:41,289
pure function around in your code base

00:08:39,550 --> 00:08:43,330
you move between different apps it

00:08:41,289 --> 00:08:45,670
doesn't care about where it is so um

00:08:43,330 --> 00:08:49,300
this is brilliant thing we can create

00:08:45,670 --> 00:08:51,460
easily reusable pieces of code the

00:08:49,300 --> 00:08:54,400
cacheable anything anyone that knows

00:08:51,460 --> 00:08:55,780
what memoization is I'll explain very

00:08:54,400 --> 00:08:59,200
quickly but it's basically if you call a

00:08:55,780 --> 00:09:01,000
function with some values and then you

00:08:59,200 --> 00:09:01,960
call it again with the same values it's

00:09:01,000 --> 00:09:03,160
not going to actually run the code

00:09:01,960 --> 00:09:05,650
inside the function it's just gonna

00:09:03,160 --> 00:09:07,510
return the value from a cash and I'm

00:09:05,650 --> 00:09:09,640
pure functions do that if they perform

00:09:07,510 --> 00:09:10,209
side effects then what would you return

00:09:09,640 --> 00:09:11,860
what

00:09:10,209 --> 00:09:14,709
would you do you can't memorize the

00:09:11,860 --> 00:09:16,660
impure function and they're also very

00:09:14,709 --> 00:09:19,209
easy to reason about we hear this term a

00:09:16,660 --> 00:09:22,329
lot when we kind of go to talks about

00:09:19,209 --> 00:09:23,529
Java scripts and reacts usually and and

00:09:22,329 --> 00:09:25,300
this is because they're referential II

00:09:23,529 --> 00:09:26,589
transparent it's very easy to reason

00:09:25,300 --> 00:09:29,649
about what's going on between your

00:09:26,589 --> 00:09:31,779
substitute things in our code and it can

00:09:29,649 --> 00:09:33,069
also be run in parallel so if you happen

00:09:31,779 --> 00:09:35,050
to write node and you've got different

00:09:33,069 --> 00:09:36,550
processes running at the same time they

00:09:35,050 --> 00:09:39,429
don't the the functions don't care about

00:09:36,550 --> 00:09:41,350
the outside world so you can run them in

00:09:39,429 --> 00:09:43,059
any order it really doesn't matter and

00:09:41,350 --> 00:09:44,619
that's a brilliant thing when you start

00:09:43,059 --> 00:09:48,399
writing quite complex multi pretty code

00:09:44,619 --> 00:09:51,160
and but the reality of pure functions is

00:09:48,399 --> 00:09:54,129
that not all functions can or will be

00:09:51,160 --> 00:09:57,429
pure you need side effects like if your

00:09:54,129 --> 00:09:59,889
app has no side effects your app it

00:09:57,429 --> 00:10:01,660
doesn't do anything like if you want to

00:09:59,889 --> 00:10:03,999
read a file if you want to make an HTTP

00:10:01,660 --> 00:10:06,490
request if you want to like handle some

00:10:03,999 --> 00:10:10,319
user input it's a side effect you just

00:10:06,490 --> 00:10:13,300
have to accept that move on and

00:10:10,319 --> 00:10:16,240
immutability is building block number

00:10:13,300 --> 00:10:18,189
two so as I said earlier like functional

00:10:16,240 --> 00:10:21,549
programmers they like to avoid mutable

00:10:18,189 --> 00:10:23,829
data javascript doesn't really lend

00:10:21,549 --> 00:10:27,549
itself to this very well so how are we

00:10:23,829 --> 00:10:29,439
going to do this um just quickly her

00:10:27,549 --> 00:10:31,420
mutable values if we have some data

00:10:29,439 --> 00:10:33,910
we've got an array and got an object and

00:10:31,420 --> 00:10:36,009
then we change like the first item in

00:10:33,910 --> 00:10:41,110
that array to be too and then when you

00:10:36,009 --> 00:10:43,959
change my age to be a 27 it's going to

00:10:41,110 --> 00:10:46,689
work like unsurprisingly why wouldn't it

00:10:43,959 --> 00:10:47,949
work um you know might some people might

00:10:46,689 --> 00:10:50,410
say well who cares you know you can

00:10:47,949 --> 00:10:52,779
mutate objects that's fine and well as

00:10:50,410 --> 00:10:54,519
we know variables bouncer objects are

00:10:52,779 --> 00:10:55,929
references so if you mutate it in one

00:10:54,519 --> 00:10:58,360
place it's going to mutate everywhere

00:10:55,929 --> 00:10:59,980
and you might want that like that might

00:10:58,360 --> 00:11:01,959
be behavior you want and your app might

00:10:59,980 --> 00:11:04,209
rely on it but I'll be perfectly honest

00:11:01,959 --> 00:11:08,709
you shouldn't you don't want to rely on

00:11:04,209 --> 00:11:10,480
that and but what can we do and so one

00:11:08,709 --> 00:11:11,920
all turns well one solution is to use

00:11:10,480 --> 00:11:15,040
someone called object freeze and it was

00:11:11,920 --> 00:11:17,709
introduced in es5 personally like when I

00:11:15,040 --> 00:11:20,499
when I first learn JavaScript I saw this

00:11:17,709 --> 00:11:22,299
I was kind of like well why would you

00:11:20,499 --> 00:11:23,830
why would you freeze an object's meaning

00:11:22,299 --> 00:11:25,870
that you can you taste it

00:11:23,830 --> 00:11:26,950
um didn't really get it until I started

00:11:25,870 --> 00:11:29,650
learning about functional programming

00:11:26,950 --> 00:11:31,000
and so it's a function of jiggle

00:11:29,650 --> 00:11:35,110
freezers function that takes and data

00:11:31,000 --> 00:11:37,450
and returns a frozen version so we can't

00:11:35,110 --> 00:11:39,640
mutate an array item and we can't you

00:11:37,450 --> 00:11:42,610
take my age everything stays the same

00:11:39,640 --> 00:11:45,280
but you know that would be great but if

00:11:42,610 --> 00:11:47,530
we take this complex object complex in

00:11:45,280 --> 00:11:50,440
the sense that it has a nested object

00:11:47,530 --> 00:11:52,960
inside it object or freeze doesn't do

00:11:50,440 --> 00:11:55,480
what you forwarded and it's actually

00:11:52,960 --> 00:11:58,780
still going to change my age so it's not

00:11:55,480 --> 00:12:00,820
what we want and my suggestion is to use

00:11:58,780 --> 00:12:03,670
something called deep freeze it's an NPM

00:12:00,820 --> 00:12:05,800
install away and your problem solved my

00:12:03,670 --> 00:12:08,920
age remains the same when I try mutator

00:12:05,800 --> 00:12:11,470
and it's only 12 lines of code unlike

00:12:08,920 --> 00:12:13,330
the density monolithic alternatives you

00:12:11,470 --> 00:12:18,010
might find out there is simply a

00:12:13,330 --> 00:12:19,540
recursive object freeze yeah what you

00:12:18,010 --> 00:12:22,240
know why are we doing this so we want to

00:12:19,540 --> 00:12:23,740
guarantee that values haven't changed we

00:12:22,240 --> 00:12:25,540
want it's going to help us avoid

00:12:23,740 --> 00:12:28,060
mutation and it's going to bring a sense

00:12:25,540 --> 00:12:30,220
of predictability to our code it's also

00:12:28,060 --> 00:12:32,110
hopefully going to restore some sanity I

00:12:30,220 --> 00:12:34,720
don't think every JavaScript developer

00:12:32,110 --> 00:12:37,150
realizes the pain mutability is going to

00:12:34,720 --> 00:12:38,620
cause them regularly you're not going to

00:12:37,150 --> 00:12:39,940
be chasing down why objects have been

00:12:38,620 --> 00:12:42,760
mutated in different parts of your

00:12:39,940 --> 00:12:44,050
application if it's frozen as I say you

00:12:42,760 --> 00:12:47,590
might you might want to depend on that

00:12:44,050 --> 00:12:49,690
it's fine and so the reality of

00:12:47,590 --> 00:12:52,390
mutability is that it makes me tasting

00:12:49,690 --> 00:12:53,830
object harder that's just a fact and if

00:12:52,390 --> 00:12:55,060
it's frozen you can't change it

00:12:53,830 --> 00:12:57,700
therefore you have to do something first

00:12:55,060 --> 00:13:00,940
to change it so what we would do is we

00:12:57,700 --> 00:13:02,200
would clone it and and baseball we're

00:13:00,940 --> 00:13:03,910
doing is we're doing a very deep clone

00:13:02,200 --> 00:13:05,980
of knob jerks and this is expensive in

00:13:03,910 --> 00:13:08,830
terms of memory personally I don't

00:13:05,980 --> 00:13:10,300
really care too much and which you know

00:13:08,830 --> 00:13:12,730
some people might say well you're crazy

00:13:10,300 --> 00:13:14,500
why you should care if you do care

00:13:12,730 --> 00:13:17,800
there's libraries like Maury which

00:13:14,500 --> 00:13:19,720
implement closure immutable data

00:13:17,800 --> 00:13:21,820
structures and there's musical chairs

00:13:19,720 --> 00:13:24,370
which is a Facebook version of something

00:13:21,820 --> 00:13:26,230
similar they don't have the same

00:13:24,370 --> 00:13:27,730
penalties and memory because of the fact

00:13:26,230 --> 00:13:29,770
that they're persistent data structures

00:13:27,730 --> 00:13:31,150
and they basically reuse different parts

00:13:29,770 --> 00:13:34,060
the structures and it kind of avoids the

00:13:31,150 --> 00:13:36,310
problem um and also not everything

00:13:34,060 --> 00:13:37,660
should be immutable necessarily this is

00:13:36,310 --> 00:13:40,300
not a rule it's just some

00:13:37,660 --> 00:13:43,210
think that might help us and personally

00:13:40,300 --> 00:13:45,250
I find if you avoid mutation just by

00:13:43,210 --> 00:13:47,710
convention it's going to make you happy

00:13:45,250 --> 00:13:49,000
if you're not mutating like all the time

00:13:47,710 --> 00:13:54,340
you're probably going to be a happier

00:13:49,000 --> 00:13:56,200
JavaScript developer so we've got

00:13:54,340 --> 00:13:59,950
functions we've got a mutability what's

00:13:56,200 --> 00:14:01,480
next currying is what's next and I don't

00:13:59,950 --> 00:14:03,400
know about everyone else but whenever

00:14:01,480 --> 00:14:06,430
when I learned Java scripts and I read

00:14:03,400 --> 00:14:09,550
about currying I just thought what late

00:14:06,430 --> 00:14:12,190
what is this thing like why one why's it

00:14:09,550 --> 00:14:13,480
called that and to what does it what's

00:14:12,190 --> 00:14:15,130
it for I just did I just didn't

00:14:13,480 --> 00:14:16,690
understand it but basically what you'll

00:14:15,130 --> 00:14:18,310
find out if you start learning about

00:14:16,690 --> 00:14:21,070
functional programming is it's super

00:14:18,310 --> 00:14:23,530
important in haskell all functions are

00:14:21,070 --> 00:14:25,690
carried and there are no encourage

00:14:23,530 --> 00:14:28,740
functions and bear in mind i'm just a

00:14:25,690 --> 00:14:31,540
beginner so it might not true but and

00:14:28,740 --> 00:14:34,110
facts when people say things in front of

00:14:31,540 --> 00:14:40,690
you you got to believe them on station

00:14:34,110 --> 00:14:42,610
but yeah yeah so you actually this next

00:14:40,690 --> 00:14:44,140
section does make more sense i would say

00:14:42,610 --> 00:14:47,250
in a language like Haskell because it's

00:14:44,140 --> 00:14:51,130
like the norm in javascript is not but

00:14:47,250 --> 00:14:53,650
i'll just explain see how we go so

00:14:51,130 --> 00:14:56,320
currying allows us to create functions

00:14:53,650 --> 00:14:58,570
that don't need to be called with the

00:14:56,320 --> 00:15:03,010
same amount of arguments as there are

00:14:58,570 --> 00:15:05,440
prams so um we can create functions if

00:15:03,010 --> 00:15:08,920
we call later this ad for example again

00:15:05,440 --> 00:15:11,500
its back we're going to we've got a

00:15:08,920 --> 00:15:13,930
function at X plus y and we're using

00:15:11,500 --> 00:15:15,820
this thing curry this is a utility that

00:15:13,930 --> 00:15:18,280
you don't need to worry about how it

00:15:15,820 --> 00:15:20,620
works and you'll be able to get it from

00:15:18,280 --> 00:15:23,380
quite a few helpful libraries and it

00:15:20,620 --> 00:15:26,620
basically means that this function add I

00:15:23,380 --> 00:15:28,720
can call it with only one argument even

00:15:26,620 --> 00:15:30,400
though it takes two and what I'm doing

00:15:28,720 --> 00:15:32,440
is creating a successor function which

00:15:30,400 --> 00:15:34,090
basis is going to add one to what I give

00:15:32,440 --> 00:15:36,060
to it so if i call it with one it's

00:15:34,090 --> 00:15:38,950
gonna give me to back which obviously

00:15:36,060 --> 00:15:40,660
hopefully is blowing your mind and you

00:15:38,950 --> 00:15:46,120
believe function programming's the right

00:15:40,660 --> 00:15:47,620
things do now and so please note like

00:15:46,120 --> 00:15:50,470
you know the function body of AD

00:15:47,620 --> 00:15:51,640
actually this this this X plus y it

00:15:50,470 --> 00:15:53,410
doesn't run until we for

00:15:51,640 --> 00:15:55,120
made all the arguments and that can

00:15:53,410 --> 00:15:58,180
cause a bit of confusion like if you put

00:15:55,120 --> 00:16:01,240
a debugger in there for example it's not

00:15:58,180 --> 00:16:03,280
going to run so I call me out a little

00:16:01,240 --> 00:16:06,280
bit and when I was learning this kind of

00:16:03,280 --> 00:16:08,590
stuff so let's use a slightly better

00:16:06,280 --> 00:16:10,450
example functional programs not just

00:16:08,590 --> 00:16:13,030
sorry functional programming is not just

00:16:10,450 --> 00:16:15,130
all about basic mathematics so we've got

00:16:13,030 --> 00:16:17,380
some developers we've got two people in

00:16:15,130 --> 00:16:19,720
an array and we want to get their first

00:16:17,380 --> 00:16:21,580
names so this is quite a standard way of

00:16:19,720 --> 00:16:23,380
doing this we're going to map over our

00:16:21,580 --> 00:16:26,470
devs and we've got a callback function

00:16:23,380 --> 00:16:28,060
there give us back the first prop sorry

00:16:26,470 --> 00:16:30,520
it gives us about the first name prop

00:16:28,060 --> 00:16:31,690
off each of the developers you know this

00:16:30,520 --> 00:16:33,670
could be shortened with an arrow

00:16:31,690 --> 00:16:36,400
function one liner which i think is

00:16:33,670 --> 00:16:38,950
quite a common kind of criticism of like

00:16:36,400 --> 00:16:40,390
examples like this but and to me it

00:16:38,950 --> 00:16:44,520
still has some issues even if we made it

00:16:40,390 --> 00:16:48,010
shorter so um we're mentioning our dev

00:16:44,520 --> 00:16:51,070
quite a few times for no real reason

00:16:48,010 --> 00:16:53,230
we're mentioning deaths what like we're

00:16:51,070 --> 00:16:55,150
coupling our code to our implementation

00:16:53,230 --> 00:16:57,520
this is a this is code to get first

00:16:55,150 --> 00:17:01,150
names off something it's not code to get

00:16:57,520 --> 00:17:03,460
first names off devs so you know we

00:17:01,150 --> 00:17:06,520
could make a function the abstract this

00:17:03,460 --> 00:17:08,290
and but the callback function return dev

00:17:06,520 --> 00:17:10,500
first name for example I would say that

00:17:08,290 --> 00:17:16,930
still doesn't really serve any purpose

00:17:10,500 --> 00:17:19,690
except for a central which is yeah so

00:17:16,930 --> 00:17:21,730
here's the same example using curried

00:17:19,690 --> 00:17:23,949
functions I'm going to explain a few

00:17:21,730 --> 00:17:25,329
helpers the tech the great x is a lot

00:17:23,949 --> 00:17:26,380
more visible than I realize it would be

00:17:25,329 --> 00:17:29,560
it was meant to be though really hidden

00:17:26,380 --> 00:17:32,530
but and basically prop takes the key and

00:17:29,560 --> 00:17:34,210
an object so it's going to take a key

00:17:32,530 --> 00:17:36,450
then an object it's going to give us the

00:17:34,210 --> 00:17:39,730
value of the key of the object so I'm

00:17:36,450 --> 00:17:42,100
currying prop first prop with first name

00:17:39,730 --> 00:17:46,300
so this is a function that will give me

00:17:42,100 --> 00:17:48,190
the first name of any object um and this

00:17:46,300 --> 00:17:50,050
is partially applied I imagine us a

00:17:48,190 --> 00:17:52,210
concept that quite a few people are

00:17:50,050 --> 00:17:54,220
aware of if you have curried functions

00:17:52,210 --> 00:17:56,200
you can partially apply them and that's

00:17:54,220 --> 00:17:58,420
probably not technically the like soup

00:17:56,200 --> 00:18:03,070
scientific version but it makes sense to

00:17:58,420 --> 00:18:05,560
me um map we've also partially applied

00:18:03,070 --> 00:18:07,530
it so we've given it a function which

00:18:05,560 --> 00:18:10,320
as I just explained as prop first name

00:18:07,530 --> 00:18:14,110
and it's waiting for an array of data

00:18:10,320 --> 00:18:15,880
this is actually unusual when you used

00:18:14,110 --> 00:18:18,280
to using map because map usually takes

00:18:15,880 --> 00:18:19,510
data than a function so the arguments

00:18:18,280 --> 00:18:20,920
might seem a little bit backwards

00:18:19,510 --> 00:18:23,080
compared to even to the examples I've

00:18:20,920 --> 00:18:26,020
given in the talk but curried functions

00:18:23,080 --> 00:18:27,400
always take their data last and this is

00:18:26,020 --> 00:18:29,760
because it lets us create reusable

00:18:27,400 --> 00:18:32,260
functions if we were carrying with data

00:18:29,760 --> 00:18:34,120
well you wouldn't be reusable but if

00:18:32,260 --> 00:18:36,730
we're carrying like with functions that

00:18:34,120 --> 00:18:39,390
do things and we can reuse this and

00:18:36,730 --> 00:18:41,200
there's a really really good talk called

00:18:39,390 --> 00:18:43,450
underscore you're doing it wrong by

00:18:41,200 --> 00:18:47,350
Brian lunch Dorf that explains is much

00:18:43,450 --> 00:18:50,790
much better and but it's kind of it's an

00:18:47,350 --> 00:18:53,860
interesting thing to kind of see and

00:18:50,790 --> 00:18:56,410
we're never like in this code like we're

00:18:53,860 --> 00:18:59,530
never saying do something with debs

00:18:56,410 --> 00:19:02,920
whenever swell sefa hit like this get

00:18:59,530 --> 00:19:04,780
first names it's called a point free

00:19:02,920 --> 00:19:07,960
function it doesn't mention the data it

00:19:04,780 --> 00:19:09,520
operates on and this is a style of

00:19:07,960 --> 00:19:11,770
programming that functional programmers

00:19:09,520 --> 00:19:14,620
are super into they're going to strive

00:19:11,770 --> 00:19:16,210
to be point free they're separating the

00:19:14,620 --> 00:19:18,340
functionality from the data which is

00:19:16,210 --> 00:19:21,100
going to aid reusability might get first

00:19:18,340 --> 00:19:23,680
names and admittedly it's a contrived

00:19:21,100 --> 00:19:26,800
example but I can get the first names of

00:19:23,680 --> 00:19:33,400
anything what just devs now so this is

00:19:26,800 --> 00:19:35,140
quite cool um so currying um it aids

00:19:33,400 --> 00:19:36,750
composition which is actually something

00:19:35,140 --> 00:19:39,190
for the next section and we've heard

00:19:36,750 --> 00:19:41,710
composition tonight already which is

00:19:39,190 --> 00:19:43,720
good and the point freestyle might

00:19:41,710 --> 00:19:45,970
increase you reuse because it's not

00:19:43,720 --> 00:19:48,310
coupled to the implementation we're not

00:19:45,970 --> 00:19:49,900
using unnecessary callbacks as much I

00:19:48,310 --> 00:19:52,570
think you'd actually quite surprised how

00:19:49,900 --> 00:19:54,520
often a curried function in a map for

00:19:52,570 --> 00:19:57,310
example means you don't have to have the

00:19:54,520 --> 00:19:58,720
callback whatsoever I mean you are kind

00:19:57,310 --> 00:20:00,190
of using one you're not creating these

00:19:58,720 --> 00:20:04,480
anonymous functions that serve very

00:20:00,190 --> 00:20:06,580
little purpose and the reality of

00:20:04,480 --> 00:20:09,040
currying is that if you're used to using

00:20:06,580 --> 00:20:11,410
array extras like map and filter and

00:20:09,040 --> 00:20:14,290
reduce as in you're calling map on an

00:20:11,410 --> 00:20:16,090
array and all you're using lodash you're

00:20:14,290 --> 00:20:19,299
using underscore they're not going to do

00:20:16,090 --> 00:20:22,899
the trick and you want to use something

00:20:19,299 --> 00:20:25,179
randa or lodash FP because they'll give

00:20:22,899 --> 00:20:27,220
you a curry friendly toolkit all of the

00:20:25,179 --> 00:20:29,110
functions in randa and load a chef p

00:20:27,220 --> 00:20:32,200
which is a functional version of lodash

00:20:29,110 --> 00:20:33,970
are carried by default the parameters

00:20:32,200 --> 00:20:38,919
are flipped so their curry friendly

00:20:33,970 --> 00:20:40,289
would get data last each time um but you

00:20:38,919 --> 00:20:43,059
know I'm telling you use different tools

00:20:40,289 --> 00:20:45,909
this might be an alien concept your team

00:20:43,059 --> 00:20:49,509
already let alone an alien kind of

00:20:45,909 --> 00:20:51,369
library so that needs to be considered i

00:20:49,509 --> 00:20:53,019
would say before you start kind of doing

00:20:51,369 --> 00:20:54,639
this kind of thing but we're creating a

00:20:53,019 --> 00:20:58,149
smaller surface area for bugs which I

00:20:54,639 --> 00:21:00,359
say is a win and also point free

00:20:58,149 --> 00:21:02,649
shouldn't always be aimed for sometimes

00:21:00,359 --> 00:21:05,169
you just have to accept your codes not

00:21:02,649 --> 00:21:06,970
point free and it might be tied to

00:21:05,169 --> 00:21:08,440
something and you don't want to make

00:21:06,970 --> 00:21:09,909
your code less readable because you're

00:21:08,440 --> 00:21:15,100
trying to be point free which i think is

00:21:09,909 --> 00:21:16,419
very common in haskell so this kind of

00:21:15,100 --> 00:21:19,330
is what it's all been building up for

00:21:16,419 --> 00:21:22,090
like not for it's the final building

00:21:19,330 --> 00:21:23,440
block of what i'm gonna go into in terms

00:21:22,090 --> 00:21:25,799
of functional programming and it's made

00:21:23,440 --> 00:21:29,049
possible because of the other blocks

00:21:25,799 --> 00:21:30,340
this is usually where mathematics starts

00:21:29,049 --> 00:21:33,730
appearing in functional programming

00:21:30,340 --> 00:21:35,619
quite heavily I should talk about

00:21:33,730 --> 00:21:37,809
composition laws associative Izzy in

00:21:35,619 --> 00:21:39,999
category theory I'm not going to talk

00:21:37,809 --> 00:21:42,639
about any of those things because it's

00:21:39,999 --> 00:21:45,239
the last talk and I don't feel like I

00:21:42,639 --> 00:21:49,450
can explain it that well so my

00:21:45,239 --> 00:21:51,970
explanation is going to be mass free so

00:21:49,450 --> 00:21:55,509
what's the end result we're after when

00:21:51,970 --> 00:21:58,330
we're composing and we want to do is we

00:21:55,509 --> 00:22:01,450
want to take a value 1 school a function

00:21:58,330 --> 00:22:03,460
with it and so I'm calling G with my

00:22:01,450 --> 00:22:05,559
value 1 and then I want to take the

00:22:03,460 --> 00:22:08,109
result of that and call another function

00:22:05,559 --> 00:22:12,309
with it so we're calling F with the

00:22:08,109 --> 00:22:14,379
result of calling Geo of a value I'd say

00:22:12,309 --> 00:22:16,720
this is kind of an imperative approach

00:22:14,379 --> 00:22:18,850
to a very basic function composition and

00:22:16,720 --> 00:22:21,220
we'll look at the functional approach in

00:22:18,850 --> 00:22:24,190
a second but just quickly like to

00:22:21,220 --> 00:22:27,159
introduce another helper before we start

00:22:24,190 --> 00:22:29,230
getting a little bit more confusing so

00:22:27,159 --> 00:22:31,090
we could have written the previous

00:22:29,230 --> 00:22:32,440
example like this we get the same result

00:22:31,090 --> 00:22:35,080
we're calling

00:22:32,440 --> 00:22:37,030
gee with our value and then we're

00:22:35,080 --> 00:22:41,440
calling F with the result of calling Geo

00:22:37,030 --> 00:22:45,280
of about you and and this kind of looks

00:22:41,440 --> 00:22:47,320
okay I guess but we could do this so

00:22:45,280 --> 00:22:49,740
composed is another helper that you'll

00:22:47,320 --> 00:22:52,240
find in things like lodash Aranda and

00:22:49,740 --> 00:22:54,220
basically it cause each function from

00:22:52,240 --> 00:22:56,530
the right to the left there's going to

00:22:54,220 --> 00:23:00,730
go G with the value and then F with the

00:22:56,530 --> 00:23:02,260
result of that um and it basically pipes

00:23:00,730 --> 00:23:04,690
the result of calling each function with

00:23:02,260 --> 00:23:06,820
the value and from right to left which

00:23:04,690 --> 00:23:08,830
is actually it's exactly the same as

00:23:06,820 --> 00:23:12,940
this the way you read it you know it

00:23:08,830 --> 00:23:15,910
right to left and and so it's not very

00:23:12,940 --> 00:23:17,530
different um but let's look at a more

00:23:15,910 --> 00:23:20,650
realistic example of what I'm trying to

00:23:17,530 --> 00:23:22,540
explain and it's in code to get a

00:23:20,650 --> 00:23:25,060
respond where we get we got a response

00:23:22,540 --> 00:23:27,460
from server and we want to do a few

00:23:25,060 --> 00:23:30,730
things to it we want to Jason plaza we

00:23:27,460 --> 00:23:32,470
want to get the film's key value and

00:23:30,730 --> 00:23:34,930
then we want to get the IDS of each of

00:23:32,470 --> 00:23:39,490
those films and I think that's not very

00:23:34,930 --> 00:23:41,710
easy to understand and and you would oh

00:23:39,490 --> 00:23:45,040
no I have got an ID so the film's basis

00:23:41,710 --> 00:23:46,990
have an idea so we need to know and so

00:23:45,040 --> 00:23:48,490
we're gonna as I say Jason positive

00:23:46,990 --> 00:23:50,590
response we're going to get the film so

00:23:48,490 --> 00:23:51,910
we're gonna get the key films off of it

00:23:50,590 --> 00:23:55,930
and then we're going to get the ids and

00:23:51,910 --> 00:23:57,970
get an array now we're using real

00:23:55,930 --> 00:23:59,770
function names not F and G I'd say this

00:23:57,970 --> 00:24:02,470
code is not particularly pretty I don't

00:23:59,770 --> 00:24:04,420
really I don't want to write that it

00:24:02,470 --> 00:24:06,070
says becoming hard to read it's becoming

00:24:04,420 --> 00:24:08,140
hard to extend if we want to add more

00:24:06,070 --> 00:24:09,790
steps to this if we want to add our

00:24:08,140 --> 00:24:12,340
handling to this it's going to get

00:24:09,790 --> 00:24:15,210
really hard and so how can composition

00:24:12,340 --> 00:24:19,810
help this is the functional version

00:24:15,210 --> 00:24:24,610
using the using compose it does the same

00:24:19,810 --> 00:24:27,940
stuff it parses the Jason it gets the

00:24:24,610 --> 00:24:31,030
film's key off of the object using our

00:24:27,940 --> 00:24:34,510
courage prop function and then it gets

00:24:31,030 --> 00:24:37,690
the IDS of each of those films i've got

00:24:34,510 --> 00:24:41,320
a curried map function here with a curry

00:24:37,690 --> 00:24:45,520
prop ID and then we're composing the

00:24:41,320 --> 00:24:46,300
whole lot and I'd say that once you're

00:24:45,520 --> 00:24:47,800
used to think

00:24:46,300 --> 00:24:49,570
is quite important once you use the

00:24:47,800 --> 00:24:52,150
composition and once you use to carrying

00:24:49,570 --> 00:24:55,330
and once they clear in your mind this is

00:24:52,150 --> 00:24:57,670
easier to read this is easier to extend

00:24:55,330 --> 00:24:59,620
and it's more declarative we're saying

00:24:57,670 --> 00:25:02,320
I'll get film IDs from response there's

00:24:59,620 --> 00:25:04,540
a composition of getting the IDS off of

00:25:02,320 --> 00:25:07,420
the film's prop and then let's offer the

00:25:04,540 --> 00:25:09,340
pars Jason and we're using all of the

00:25:07,420 --> 00:25:11,080
things we've just seen we're looking at

00:25:09,340 --> 00:25:13,120
higher order functions pure functions

00:25:11,080 --> 00:25:16,750
that's really important pure slaying

00:25:13,120 --> 00:25:19,750
that sack and curried functions so why

00:25:16,750 --> 00:25:21,760
would we go to all this effort apps

00:25:19,750 --> 00:25:24,100
should be built from lots of small parts

00:25:21,760 --> 00:25:27,100
I feel like most people would agree with

00:25:24,100 --> 00:25:29,650
me there and composition is one of those

00:25:27,100 --> 00:25:31,960
tools that we have to do this it's

00:25:29,650 --> 00:25:34,900
actually it's very easy to refactor code

00:25:31,960 --> 00:25:37,720
that's written like this because it's

00:25:34,900 --> 00:25:39,580
hard to show on a slide but once you

00:25:37,720 --> 00:25:42,190
start seeing more and more composition

00:25:39,580 --> 00:25:44,380
you can start extracting and composes

00:25:42,190 --> 00:25:45,730
out in smaller functions that you might

00:25:44,380 --> 00:25:47,410
be able to reuse and they might be point

00:25:45,730 --> 00:25:49,750
free so they're actually agnostic to the

00:25:47,410 --> 00:25:51,400
dates they're operating on this is going

00:25:49,750 --> 00:25:56,500
to greatly increase the reusability of

00:25:51,400 --> 00:25:58,300
your code as with everything I've spoken

00:25:56,500 --> 00:26:00,550
about tonight like there's a reality

00:25:58,300 --> 00:26:03,610
here it takes a while to adjust to

00:26:00,550 --> 00:26:05,380
programming like this also powerful

00:26:03,610 --> 00:26:09,370
tools in the wrong hands might be

00:26:05,380 --> 00:26:11,350
dangerous I'm sure I'm sure there's some

00:26:09,370 --> 00:26:14,200
terrible terrible code written like this

00:26:11,350 --> 00:26:17,440
out there it requires pure functions to

00:26:14,200 --> 00:26:19,690
be saying and you can reason about code

00:26:17,440 --> 00:26:22,300
like this if you don't know that that

00:26:19,690 --> 00:26:25,870
doesn't cause a side effect somewhere so

00:26:22,300 --> 00:26:27,790
we want pure functions um and actually

00:26:25,870 --> 00:26:30,400
you can compose all sorts of things so

00:26:27,790 --> 00:26:33,700
the gravity is this is just a taster of

00:26:30,400 --> 00:26:35,950
what you could be doing and you can map

00:26:33,700 --> 00:26:38,590
and compose over things like input

00:26:35,950 --> 00:26:40,780
output promises so you know values

00:26:38,590 --> 00:26:42,640
aren't there yet error handling can be

00:26:40,780 --> 00:26:44,050
done like this as well and they're

00:26:42,640 --> 00:26:47,310
completely out of the scope of this talk

00:26:44,050 --> 00:26:51,040
i say i'm still learning myself and i I

00:26:47,310 --> 00:26:53,800
wouldn't necessarily suggest going that

00:26:51,040 --> 00:26:57,160
far this isn't Haskell and I don't think

00:26:53,800 --> 00:27:01,770
it should be so if you're still confused

00:26:57,160 --> 00:27:01,770
about what is a functional

00:27:02,100 --> 00:27:06,940
not all of your code base needs to be

00:27:04,480 --> 00:27:08,919
functional even in Haskell we need to

00:27:06,940 --> 00:27:10,809
make trade-offs so even a strict

00:27:08,919 --> 00:27:12,460
functional language you know you have to

00:27:10,809 --> 00:27:16,360
have side effects as I said you have to

00:27:12,460 --> 00:27:19,450
do something so how big the functional

00:27:16,360 --> 00:27:21,220
the pure island you create is is coming

00:27:19,450 --> 00:27:23,049
out to you you can make it as big or as

00:27:21,220 --> 00:27:24,789
small as you want you may even have some

00:27:23,049 --> 00:27:27,700
islands you don't know about in your

00:27:24,789 --> 00:27:29,409
imperative kind of code base already and

00:27:27,700 --> 00:27:31,720
all I'm hoping is that this is enough

00:27:29,409 --> 00:27:32,860
information that you know you can now

00:27:31,720 --> 00:27:36,940
see maybe you're already using

00:27:32,860 --> 00:27:38,980
functional programming concepts and you

00:27:36,940 --> 00:27:41,830
hopefully will leave knowing you know

00:27:38,980 --> 00:27:45,789
how and why you might want to use it

00:27:41,830 --> 00:27:48,070
more and if you're interested in

00:27:45,789 --> 00:27:50,380
learning how to do a bit more of this

00:27:48,070 --> 00:27:54,490
and I'll cut these slides up as always

00:27:50,380 --> 00:27:56,380
and just here's some good free resources

00:27:54,490 --> 00:27:59,110
about learning this kind of stuff here's

00:27:56,380 --> 00:28:02,909
some really really good paid ones the

00:27:59,110 --> 00:28:07,740
bottom one is crazy and really cool and

00:28:02,909 --> 00:28:07,740

YouTube URL: https://www.youtube.com/watch?v=CDRDb1pHQ6Q


